{
  "metadata": {
    "timestamp": 1736709825888,
    "page": 288,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sysstat/sysstat",
      "stars": 3045,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.79296875,
          "content": "# Lines starting with '#' are considered comments.\n# List of files to ignore:\nMakefile\n*.[oa]\nsa1\nsa2\nsysstat\ncrontab\nversion.h\nsysconfig.h\nsysstat.sysconfig\nsysstat.service\nsysstat.crond\nsysstat.cron.daily\nsysstat.cron.hourly\nsysstat.crond.sample\nsysstat.crond.sample.in\ncron/sysstat-collect.service\ncron/sysstat-collect.timer\ncron/sysstat-summary.service\ncron/sysstat-summary.timer\ncron/sysstat-rotate.timer\ncron/sysstat-rotate.service\ncron/sysstat.sleep\nman/sa1.8\nman/sa2.8\nman/sadc.8\nman/sysstat.5\nman/sadf.1\nman/sar.1\nman/iostat.1\nman/cifsiostat.1\n*.log\nconfig.status\nautom4te.cache/\n*.save\n*.old\n.*.swp\ndata\n*~\nman/*~\nbuild/*~\nsadc\nsar\nsadf\niostat\ntapestat\nmpstat\npidstat\ncifsiostat\ncore\nTAGS\nnls/*.gmo\ntests/*.tmp\ntests/sa[0123]*\ntests/variables\ntests/pcpar.*\ntests/LAST\ntests/SKIPPED\ninisar\nsar32\nsadc32\n"
        },
        {
          "name": ".lgtm.yml",
          "type": "blob",
          "size": 0.0478515625,
          "content": "path_classifiers:\n    library:\n        - contrib\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.029296875,
          "content": "language: c\nscript: ./do_test\n"
        },
        {
          "name": "BUG_REPORT",
          "type": "blob",
          "size": 0.6201171875,
          "content": "This file contains the data that you should provide to report a bug:\n\nSystem info: [Include sysstat version (e.g., the output of \"sar -V\" or \"iostat -V\" etc.),\noperating system name (e.g., the output of \"uname -a\"), and other relevant details]\n\nSteps to reproduce:\n\n    [First Step]\n    [Second Step]\n    [and so on...]\n\nExpected behavior: [What you expected to happen]\n\nActual behavior: [What actually happened]\n\nAdditional info: [Include gist of relevant binary system activity datafile, config, logs, etc.\nor send them directly to me at sysstat <at> orange_dot_fr]\n\nOpening an issue on GitHub is the preferred way to report a bug.\n\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 140.49609375,
          "content": "Changes:\n\n2024/07/03: Version 12.7.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadf: [A_NET_ETCP]: Rename retrans/s field to retrseg/s\n\t  because it was already used in A_NET_NFS report.\n\t* sadf: SVG: Fix oversized SVG canvas height.\n\t* sadf: Don't cap SVG graph output at 100%.\n\t* sadf: A_NET_SOFT: Don't display graphs for offline CPU.\n\t* sadf: SVG: Don't ignore other views when one has to be skipped.\n\t* sadf: Make sure structures will be alloacated for every installed\n\t  CPU.\n\t* sadf: Define MIN_CANVAS_HEIGHT constant.\n\t* sar: Display min/max values only when available.\n\t* Define macros for CPU manipulation.\n\t* SREALLOC() macro: Make sure size is not zero.\n\t* Fix a warning given by gcc v13 with -fanalyzer option.\n\t* [Eli Schwartz]: configure.ac: fix erroneous bashisms.\n\t* sar manual page updated.\n\t* DTD and XSD documents updated.\n\t* Year updated in copyright messages.\n\t* Other cosmetic changes in code.\n\t* FAQ and README files updated.\n\t* Non regression tests updated. New tests added.\n\n2023/12/17: Version 12.7.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Quan quan Cao]: sar/sadc: Add new metrics pgprom/s and pgdem/s.\n\t* sar: Remove %vmeff metric.\n\t* sadf: Update various output formats to take into account metrics\n\t  that have been added or removed.\n\t* Update DTD and XSD documents.\n\t* Update sar manual page.\n\t* sar: Add a cron entry and a new systemd service and timer to rotate\n\t  daily data file at midnight.\n\t* Option -V with sysstat commands also displays environment contents.\n\t* [Sam Morris]: Use correct encoding to produce hyphen-minus when\n\t  rendering man pages.\n\t* Add UMASK variable definition to sysstat(5) manual page.\n\t* Update non regression tests.\n\t* Add --getenv option to commands that didn't have it.\n\t* Update README file for Debian-based distros.\n\t* Update link to my personal web page in README and manual pages.\n\t* NLS: Translations updated.\n\n2023/06/18: Version 12.7.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Makefile.in: Fix installation error.\n\t* Makefile.in: Remove gcc warning displayed in LTO mode.\n\n2023/06/16: Version 12.7.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Add new option '-x' used to display extended reports.\n\t* [Pavel Kopylov]: Fix an overflow which is still possible for\n\t  some values.\n\t* [Jan Kurik]: Fix export of PSI metrics to a PCP archive.\n\t* [Lukáš Zaoral]: Tools that take `--dec=X` option should only accept\n\t  digits.\n\t* common.c: Fix an overflow which was still possible for some values.\n\t* iostat: Try to avoid displaying negative values.\n\t* Free pointer if realloc() fails.\n\t* Don't check if unsigned expressions are less than zero.\n\t* Declare parameters with \"const\" when possible.\n\t* Remove conditions which are always true.\n\t* Reduce variables scope when relevant.\n\t* Don't assign values that are never used.\n\t* Fix types used in format strings.\n\t* Split large functions into smaller ones.\n\t* Specify field width when using sscanf() function.\n\t* search_list_item(): Return position in list instead of a boolean.\n\t* add_list_item(): Also return item position in list.\n\t* svg_stats.c: Ignore negative values for fields position.\n\t* svg_stats.c: Reuse buffers pointers definition.\n\t* svg_stats.c: Reuse intermediate calculations.\n\t* svg_stats.c: Don't repeat test on DISPLAY_CPU_DEF().\n\t* sa_common.c: Don't use (void *) pointer in calculation.\n\t* iostat.c: Clarify calculation precedence for '+' and '?'.\n\t* sar/sadf: Refactor buffer allocation functions.\n\t* sar/sadf: Add a check on file's records header data.\n\t* sar/sadf: Stop when invalid data are read in records header.\n\t* sar/sadf: Check upper bounds of value read from file.\n\t* sadf_misc.c: Fix indentation in code.\n\t* activity.c: Init item_list even for other commands than sadf.\n\t* sa_conv.c: Reallocate buffers only when needed.\n\t* sa_conv.c: Fix untrusted allocation size.\n\t* pr_stats.c: Remove some dead code.\n\t* sar.c: Make sure buffer is null terminated.\n\t* do_test: Add several new options.\n\t* do_test: Don't strip binaries when in TEST mode.\n\t* Update non regression tests.\n\t* simtest: Change default _unix_time value.\n\t* Makefile.in: Simplify dependencies.\n\t* Makefile_in: Small update made to copyyear target.\n\t* sadf: XML: Update DTD and XSD documents.\n\t* sadf: XML: Remove references to my personal web site.\n\t* Restore mode for iconfig file.\n\t* Fix typo in sar's manual page. Sar manual page updated.\n\t* Other manual pages updated.\n\n2023/01/29: Version 12.7.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* All commands: Avoid displaying healthy metrics values in \"red\".\n*\t* sar/sadf: Add new activity: Battery statistics (A_PWR_BAT).\n\t* [Kevin Stubbings]: Add CodeQL workflow.\n\t* sar: Make sure timestamps are always displayed in local time.\n\t* sar/sadf: Starting and ending times used with options -s/-e can now\n\t  be entered as a number of seconds since the epoch.\n\t* sar/sadf: Strengthen tests made on arguments given to options -s/-e.\n\t* sadf: PCP: Fix pmiID used for two USB metrics [12.6.2].\n\t* [Nathanael P Wilson]: sadf: Fix extra space when no TZ printed.\n\t* sadc: Add another overflow check [12.6.2].\n\t* DTD and XSD documents updated.\n\t* Makefile: Fix dependencies.\n\t* NLS translations updated. New Belarusian translation added.\n\t* Remove LGTM links from README file.\n\t* Manual pages updated.\n\t* Non regression tests updated.\n\n2022/11/06: Version 12.7.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Fix possible overflow in sa_common.c (GHSL-2022-074) [12.6.1].\n\t* sadf: Add support for option -t with SVG output to make it possible\n\t  to display timestamps in the same locale as that of the file creator.\n\t* sadf: Print timezone instead of UTC in true time mode. Timezone is\n\t  also displayed in local time.\n\t* sadf: PCP: Fix timestamps written to PCP archive file.\n\t* sar: Add new environment variable S_REPEAT_HEADER.\n\t* pidstat: Return exit code of the process that was monitored with option\n\t  -e.\n\t* mpstat: Add option -H to handle vCPU physical hotplug.\n\t* Add local, xlocal and debug targets to iconfig script.\n\t* Turn off gcc's tree-slp-vectorize option which was making sadf crash\n\t  in some situations.\n\t* sa_conv.c: Make size of statistics structures from older sysstat\n\t  versions immutable [12.6.1].\n\t* [Bernhard M. Wiedemann]: Declare sadc dependency on libsyscom.a\n\t  [12.6.1].\n\t* [Steve Kay]: Fix gcc v11.2 warnings [12.6.1].\n\t* [Steve Kay]: Various cosmetic fixes [12.6.1].\n\t* [Jan Christoph Uhde]: sar: Remove `-I int_list` from man-page and\n\t  help [12.6.1].\n\t* [Frank Dana]: Consolidate systemctl commands in README file [12.6.1].\n\t* [Rong Tao]: Remove whitespace characters at the end of lines\n\t  [12.6.1].\n\t* Update configure file to deal with newer autoconf version. configure.in\n\t  file is renamed to configure.ac.\n\t* Update DTD and XSD documents.\n\t* sar and sysstat manual pages updated.\n\t* NLS updated. Add new Georgian translation.\n\t* Non regression tests updated.\n\n2022/05/29: Version 12.6.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Fix maximum value for A_IRQ activity.\n\t* sar/sadf: A_NET_SOFT: Add new metric softnet network backlog.\n\t* sadc: A_NET_SOFT: Use CPU id from /proc/net/softnet_stat.\n\t* Update DTD and XSD documents (softnet backlog).\n\t* [Chris Bagwell]: sar/sadf: Convert 64-bit time value to time_t\n\t  as needed.\n\t* sadf: Add basic colorization to sadf's output.\n\t* sadf: Add sanity checks on values read from file.\n\t* sadf: PCP: Fix multiple metrics name problems.\n\t* sa_common.c: Remove unneeded variable assignment.\n\t* [Lukáš Zaoral]: Take into account LDFLAGS passer to configure\n\t  script.\n\t* Various janitorial fixes and updated.\n\t* Update FAQ.\n\t* Update sar manual page.\n\t* Update NLS translations.\n\t* Update non regression tests.\n\n2022/02/28: Version 12.5.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadc: Rewrite code used to collect and display interrupts\n\t  statistics. Statistics are now collected from /proc/interrupts\n\t  (instead of /proc/stat) and are displayed for each installed CPU.\n\t* sar/sadf: Add new \"--int=\" option to enter a list of interrupts on\n\t  the command line.\n\t* sadf: Update the various output formats to deal with the new\n\t  per-CPU interrupts statistics.\n\t* Update DTD and XSD documents. CPU elements may be non-existent when\n\t  all selected CPU are offline.\n\t* Update sar and sadf manual pages.\n\t* mpstat: Create its own function to read the total number of\n\t  interrupts from /proc/stat file.\n\t* mpstat: Remove unneeded \"aligned\" attribute from struct stats_irqcpu\n\t  definition.\n\t* sar: Fix index value used in online_cpu_bitmap array.\n\t* sar/sadf: Make sure that datafiles with unknown activities can\n\t  be read by sar and sadf [12.4.5].\n\t* sar/sadf: Don't reallocate buffers for activities not present\n\t  in file [12.4.5].\n\t* sar: Make sure that all buffers are copied in copy_structures()\n\t  function [12.4.5].\n\t* PCP: Fix flow_limit_count metric's unit (A_NET_SOFT activity).\n\t* PCP: Fix instance names for getattr call (A_NET_NFS(D) activities).\n\t* Use sizeof() macro instead of hard-coded values with snprintf()\n\t  functions.\n\t* rndr_stats.c: Use NOVAL instead of NULL as last argument for cons()\n\t  function.\n\t* Use strings definitions whenever possible.\n\t* Add new non regression tests. Update some existing ones.\n\t* Various cosmetic fixes.\n\n2021/12/05: Version 12.5.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* iostat: Add --compact option.\n\t* iostat: Always display persistent names with option -j [12.4.4].\n\t* iostat: Fix how device mapper names are taken into account when\n\t  entered on the command line [12.4.4].\n\t* iostat: Update manual page.\n\t* mpstat: Don't display offline CPU [12.4.4].\n\t* mpstat: Fix values displayed when an offline CPU goes back online\n\t  [12.4.4].\n\t* mpstat: Fix untrusted loop bound [12.4.4].\n\t* mpstat: Update non regression tests [12.4.4].\n\t* sar: Tell the user to convert the file when needed.\n\t* sadc: Reuse count results for sub-items.\n\t* [Ville Skyttä]: Use `grep -E` instead of deprecated `egrep` [12.4.4].\n\t* [Ville Skyttä]: Spelling and grammar fixes [12.4.4].\n\t* Update FAQ.\n\t* [Nathan Naze]: Update man pages with correct spelling of\n\t  \"JavaScript\" [12.4.4].\n\t* Update non regression tests.\n\n2021/06/07: Version 12.5.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Nathan Scott]: PCP: Update sadf to use metadata matching the same\n\t  metrics from PCP.\n\t* [Parth Shah]: pidstat monitors and shows statistics at the end of the\n\t  program run with option -e, when no interval and count parameters\n\t  have been defined.\n\t* pidstat: Simplify use of P_D_PID flag.\n\t* Restore mode for iconfig file.\n\t* Non regression tests updated.\n\t* Various cosmetic fixes.\n\t* NLS translations updated.\n\n2021/02/14: Version 12.5.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Add Link Time Optimization (LTO) support.\n\t* Fix LTO compilation warnings.\n\t* sar: Fix return code sent by write_stats() function [12.4.3].\n\t* sar/sadc: Dereference nr array pointer in struct activity [12.4.3].\n\t* sadf: SVG: Make graphs discontinuous for disconnected devices\n\t  [12.4.3].\n\t* sadf: SVG: Fix inadequate discontinuities in some graphs [12.4.3].\n\t* sadf: Raw: Display number of items in debug mode even if it's zero.\n\t* sadf: SVG: Use the <count> parameter entered on the command line\n\t  [12.4.3].\n\t* sadf: SVG: Add 'debug' option.\n\t* sadf: Update manual page.\n\t* sar/sadc/sadf: Check untrusted values before use [12.4.3].\n\t* sar/sadc: Don't use IFNAMSIZ value from <net/if.h> [12.4.3].\n\t* sar/sadf: Test codes returned by functions.\n\t* simtest: Update/enhance simulation tests environment.\n\t* simtest: Add new non regression tests (USB statistics, ...)\n\t* Makefile: Define TEST flag when making simulation tests [12.4.3].\n\t* Makefile: Add copyyear target to make it easier to update year in (C)\n\t  messages.\n\t* Update NLS translations [12.4.3].\n\t* Cosmetic changes in code. Some dead code removed. Code simplified.\n\t* irqstat: Sync with upstream version (1.0.1-pre).\n\n2020/12/19: Version 12.5.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Aleksei Nikiforov]: Fix alignment and structure size for 32-bit\n\t  systems [12.4.2].\n\t* Fix metric's name in sar -y output: txmtin -> xmtin [12.4.2].\n\t* FAQ: Add links to markdown file [12.4.2].\n\t* [Tim Gates]: sar.c: Fix typo in comment [12.4.2].\n\t* simtest: Create a 32 bit version of sar and sadc. This is to make\n\t  sure that datafiles created by 32 and 64 bit versions of sadc can\n\t  be used on both architectures.\n\t* simtest: Update non regression tests. Also add new tests.\n\t* systest.c: Fix GCC warnings.\n\t* NLS translations updated [12.4.2].\n\n2020/11/21: Version 12.5.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadf: Make option -j work with filesystems statistics.\n\t* sa1: Add \"--rotate\" option to make it easier to handle file rotation.\n\t* [Petr Pavlu]: Workaround for iowait being decremented [12.4.1].\n\t* [SacValleyTech]: Make sure setbuf() is the first operation\n\t  performed on stream [12.4.1].\n\t* [Michal Berger]: Fix typo in PHYS_PACK_ID definition [12.4.1].\n\t* sadc: Rework softnet stats reading procedure to make sure that all\n\t  lines from /proc/net/softnet_stat are actually read.\n\t* sadc: Don't reallocate structures if buffers are large enough.\n\t* configure: Fix option --disable-compress-manpg [12.4.1].\n\t* sar: Update definition for runq-sz metric in manual page [12.4.1].\n\t* iostat: Update manual page (explain \"*_w+d*\" fields) [12.4.1].\n\t* iostat: Explain options -f/+f in manual page [12.4.1].\n\t* [Nan Xiao]: mpstat: Add -T option in help message [12.4.1].\n\t* [Nan Xiao]: mpstat: Fix typo in manual page [12.4.1].\n\t* FAQ.md file: Add missing spaces at end of line [12.4.1].\n\t* FAQ updated.\n\t* sa1 manual page updated.\n\t* Add a sponsor button to GitHub page.\n\t* systest: Small fix for array index value.\n\t* Makefile: Rename object files used by sadc.\n\t* Add new non regression tests and update some existing ones.\n\t* Simplify/merge non regression tests.\n\t* NLS translations updated.\n\n2020/07/31: Version 12.4.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* All commands: Display statistics in color by default when the\n\t  output is connected to a terminal.\n\t* sar: Now pretty-print all device names by default (that is to\n\t  say, you no longer need to use option -p with option -d for that).\n\t* cifsiostat, iostat, sar: Add new --pretty option (this option\n\t  makes the reports easier to read when long item names are used).\n\t* iostat: No longer use sysstat.ioconf file to determine the name\n\t  of the devices. This file gave a wrong name for some devices\n\t  with big minor numbers.\n\t* iostat, sar: Make device name consistent between both of them.\n\t* configure: Add new option \"--enable-use-crond\" to use standard\n\t  cron daemon even if systemd is installed.\n\t* configure: Use AC_COMPILE_IFELSE instead of old AC_TRY_COMPILE\n\t  macro. Remove other obsolete autoconf macros.\n\t* configure: Add new option \"delay_range=\". Used by sa2 script\n\t  to wait for a random delay.\n\t* configure: Fix --enable-debuginfo option.\n\t* sa1: Insert a comment in daily datafile on system suspend/resume.\n\t* sa2: Wait for a random delay before running to prevent massive\n\t  I/O burst on some systems.\n\t* sar: Fix typo in manual page.\n\t* sar, iostat, cifsiostat, mpstat, pidstat, tapestat and sa1 manual\n\t  pages updated.\n\t* Update style for all manual pages.\n\t* Compress manual pages by default when they are installed.\n\t* Makefile: Remove all reports and data files (even those compressed\n\t  with another program than gzip) when told to do so.\n\t* Add pcp help file to be used with iconfig script.\n\t* Update Travis script (now calls do_test script).\n\t* sadf: Output format which doesn't accept the use of option -T\n\t  should not also reject the use of option -t [12.2.3].\n\t* [Tom Hebb]: Replace index() call with strchr() call [12.2.3].\n\t* Use NULL as an argument for time(2) system call [12.2.3].\n\t* Various cosmetic changes in code (comments updated, dead code\n\t  removed, etc.)\n\t* NLS updated.\n\t* Non regression environment updated. New tests added.\n\t* Better handle big minor numbers in sysstat test code.\n\t* Fix gcc V10 warnings in sysstat 12.0.1 code used for test.\n\n2020/05/08: Version 12.3.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadc: Add new Pressure-Stall Information (PSI) statistics.\n\t* sadf: Add support for PSI statistics.\n\t* iostat: Add support for devices managed by userspace drivers\n\t  (e.g. spdk). Add new flags -f/+f to specify an alternate location\n\t  for stats files.\n\t* sar: Don't display duplicate entries in /etc/mtab [12.2.2].\n\t* sar: Don't display \"Inconsistent input data\" error message when no\n\t  activities are collected by sadc.\n\t* sadf: XML: Remove \"per\" attribute for memory activity.\n\t* sadf: Add new option \"hz=\" for datafile conversion.\n\t* Various updates to remove GCC v9/v10 warnings.\n\t* sar: Don't check if we are close enough to selected interval when\n\t  interval=1 [12.2.2].\n\t* sadf: Use actual number of items, not its pointer address [12.2.2].\n\t* [Sdrkun]: sa1: Create default sa directory if it doesn't exist\n\t  [12.2.2].\n\t* pr_stats.c: Printing timestamp should appear only once [12.2.2].\n\t* common.c: Remove unused get_dev_part_nr() function [12.2.2].\n\t* DTD and XSD documents updated.\n\t* sar and sadf manual pages updated.\n\t* Non regression tests updated. New tests added (sar, iostat).\n\n2020/04/10: Version 12.3.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* pidstat: Major code refactoring. Several bugs fixed.\n\t* pidstat: Don't display unneeded spaces following command name\n\t  when option -l is used.\n\t* cifsiostat: Major code refactoring.\n\t* simtest: Add test environment for pidstat command.\n\t* simtest: Add new non regression tests for iostat command.\n\t* pidstat: Remove extra space at end of command name [12.2.2].\n\t* [Anatoly Pugachev]: Fix sa2 script, so it won't complain on empty list\n\t  for compress program [12.2.2].\n\t* iostat: Make sure pointer on linked list is initialized [12.2.2].\n\t* [Fabrice Fontaine]: Makefile: Link with -lintl if needed [12.2.2].\n\t* NLS translation updated.\n\n2019/12/27: Version 12.3.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Konstantin Khlebnikov]: iostat: Add flush I/O statistics\n\t  (statistics available starting with kernel 5.5).\n\t* mpstat: Add new switch to display system topology.\n\t* mpstat: Allow to select individual CPU/nodes with option -A.\n\t* cifsiostat: Add support for SMB2 version of statistics file.\n\t* mpstat: Add non regression tests.\n\t* tapestat: Add non regression tests.\n\t* cifsiostat: Add non regression tests.\n\t* iostat: Add new non regression tests.\n\t* sadf: Fix double free in check_file_actlst() [12.2.1].\n\t* sadf: Fix heap overflow in logic2_display_loop() function.\n\t* iostat: Fix wrong unit used in JSON output [12.2.1].\n\t* [Leo]: Add missing header files when using musl C library [12.2.1].\n\t* [Albert]: Add missing empty line in FAQ.md file [12.2.1].\n\t* mpstat and iostat manual pages updated.\n\t* Cosmetic changes.\n\n2019/11/11: Version 12.2.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadc: Save timezone value in binary data files (saDD).\n\t* sadf: Display timezone value in output from sadf -H.\n\t* sar/sadf: Make sure we will always be able to read file headers\n\t  structures\n\t  from older versions.\n\t* sadf: Enhance raw format output (now also display records header\n\t  contents).\n\t* sadf: Update DTD and XSD documents. Fix their contents so that XML\n\t  output from 12.0.x sadf versions validates.\n\t* sar/sadf: Change 'flags' variable type from \"unsigned int\" to\n\t  \"uint64_t\".\n\t* simtest: Make all tests independent from timezone value.\n\t* simtest: Add more non regression tests.\n\t* sadf: Small fix in manual page.\n\t* NLS updated.\n\t* FAQ updated.\n\n2019/09/30: Version 12.1.7 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadc: Add stable identifier support for disks statistics.\n\t* sar/sadf: Add extra flexibility in binary data file in case of\n\t  a future format change.\n\t* sadf: sadf -H output updated.\n\t* iostat: Fix several bugs (CID ##349502, #349503, #349500 and\n\t  #349501).\n\t* sar: Manual page updated.\n\t* sadf: Fix memory corruption bug due to integer overflow in\n\t  remap_struct() function (try #2).\n\t* configure: Add new configuration variables: conf_file and sar_dir.\n\t* simtest: sar: Add new non regression tests.\n\t* simtest: iostat: Make tests independent from timezone value.\n\t* NLS updated.\n\n2019/08/14: Version 12.1.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* iostat: Major code refactoring. Devices structures are now\n\t  dynamically allocated, better handle the case when devices are\n\t  removed then inserted again in the system, better command line\n\t  parsing, better handle devices with a slash in their name.\n\t* sar/sadf: Allow to select individual CPU and/or interrupts when\n\t  option -A is used.\n\t* sar: Better handle the case when Fibre Channel hosts are added to\n\t  the system.\n\t* [Alexandros Kosiaris]: sadc: Check if InCsumErrors is present for\n\t  EICMP as well [12.0.6].\n\t* sar: Fix sar -s/-e output on datafiles spanning two consecutive days.\n\t* sadf: XML: Fix bad transmission words statistics for Fibre Channel\n\t  hosts [12.0.6].\n\t* sadf: Fix memory corruption bug due to integer overflow in\n\t  remap_struct() function.\n\t* iostat: Fix wrong CPU statistics displayed for the first sample\n\t  when option -y is used [12.0.6].\n\t* iostat: Make sure UUID given on the command line is not taken as\n\t  interval value [12.0.6].\n\t* Allow more space for persistent type directory names [12.0.6].\n\t* Update sysstat simulation test environment (new tests added, etc.)\n\t* sar manual page updated.\n\t* Various cosmetic fixes (comments updated in code, etc.)\n\t* NLS updated.\n\n2019/05/31: Version 12.1.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Support completed for PCP (Performance Co-Pilote) output format.\n\t* Add sysstat simulation test environment.\n\t* Add non regression tests.\n\t* sar: Use nanoseconds to choose between saDD and saYYYYMMDD files.\n\t* sar/sadf: Time used by options -s/-e no longer depends on the timezone\n\t  value.\n\t* sar: Add missing %gnice CPU value for tickless CPU [12.0.5].\n\t* sar: Better detect if a disk has been unregistered then registered\n\t  again [12.0.5].\n\t* sar: Allow option -i when no input file is specified [12.0.5].\n\t* sadc: Fix bad number of CPU displayed in a LINUX RESTART message [12.0.5].\n\t* sadf: Fix SVG output for filesystem statistics when the user asked for\n\t  the mount point to be displayed (\"-F MOUNT\") [12.0.5].\n\t* sadf: Fix PCP and SVG output for filesystem statistics.\n\t* iostat: Fix invalid JSON output when option -y is used [12.0.5].\n\t* iostat: Fix regression for groups of devices which were no longer displayed\n\t  in the report with option -g.\n\t* sar: Cosmetic fix in manual page [12.0.5].\n\t* sadf manual page updated.\n\t* FAQ updated.\n\t* Cosmectic changes in code [12.0.5].\n\n2019/04/18: Version 12.1.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Add initial support for PCP (Performance Co-Pilote).\n\t  sadf can now export some of its data to a PCP archive file with\n\t  its new option \"-l\".\n\t* configure: Add option --disable-pcp to configuration scripts.\n\t* [Ondrej Dubaj]: sar/sadc: Ignore autofs entries in /etc/mtab [12.0.4].\n\t* [Huang Ying]: mpstat: Fix missing \"}\" and \"]\" in JSON output when\n\t  stopped by SIGINT [12.0.4].\n\t* iostat: Add a SIGINT handler so that JSON output can be terminated\n\t  properly when the user presses Ctrl/C [12.0.4].\n\t* sadf: Fix segmentation fault error when trying to display XML or JSON\n\t  data using a file which contains only RESTART records [12.0.4].\n\t* mpstat: JSON output should display \"all\" for CPU number for global\n\t  CPU utilization [12.0.4].\n\t* [Danny Smit]: Add umask sysconfig variable for sa1 and sa2 [12.0.4].\n\t* configure: Don't check for sensors library if --disable-sensors\n\t  option is used [12.0.4].\n\t* sadf: Don't test for activities available in file if only the header\n\t  needs to be displayed [12.0.4].\n\t* sadf: Make code more independent from the selected output format.\n\t* sar/sadc: Make sure number of items are always counted for certain\n\t  activities (like A_CPU) even if they are not collected.\n\t* Fix many alerts reported by LGTM.\n\t* sadc and sadf manual pages updated.\n\t* Makefile updated.\n\t* json_stats.h: Replace XML -> JSON [12.0.4].\n\n2019/02/15: Version 12.1.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: SVG: Add new \"customcol\" and \"bwcol\" options. These options\n\t  enable the user to select distinct color palettes to draw the\n\t  graphs with \"sadf -g\".\n\t* sadf: SVG: Make it possible for the user to customize color palette\n\t  used to draw graphs.\n\t* sadf: SVG: Fix wrong variable used to draw discard IO graph.\n\t* [Kyle Walker]: sadc: Add -f flag to force fdatasync() use.\n\t* sadf and sadc manual pages updated.\n\t* NLS translations updated.\n\n2018/12/14: Version 12.1.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Fix out of bound reads security issues (CVE-2018-19416 and\n\t  CVE-2018-19517) [12.0.3].\n\t* iostat: Add support for discard I/O statistics.\n\t* iostat/sar: Remove service time (svctm) metric.\n\t* sar/sadf: Add support for discard I/O statistics.\n\t* sar: Add a return code to remap_struct() function.\n\t* DTD and XSD documents updated.\n\t* sar and iostat manual pages updated.\n\t* Add non regression tests for XML output and improve those for\n\t  JSON output.\n\t* sadf: Fix possible infinite loop [12.0.3].\n\t* Remove remap_struct() prototype from sa.h [12.0.3].\n\t* [Jamin]: Add a JSON parse test.\n\t* [Todd Walton]: Clarify sadc manual page and FAQ on using multiple -S keywords\n\t  [12.0.3].\n\t* [Steve Kay]: Use memcpy rather than strncpy, in order to avoid truncation\n\t  warning [12.0.3].\n\t* [Steve Kay]: Cosmetic fixes in configure file [12.0.3].\n\t* [Anatoly Pugachev]: Fix comment in sar.c [12.0.3].\n\n2018/10/13: Version 12.1.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Fix wrong size for stats_huge structure [12.0.1].\n\t* sar/sadc/sadf: Add new HugePages metrics: HugePages_Rsvd and\n\t  HugePages_Surp.\n\t* DTD and XSD documents updated.\n\t* sadf: Make it more robust to corrupted datafiles.\n\t* sadc: Allow to unselect activities by name.\n\t* Use thread-safe versions of gmtime() and localtime() functions.\n\t* sar: Fortify remap_struct() function [12.0.2].\t\n\t* sar: Fix timestamp format in report output [12.0.2] [11.6.6] [11.4.11].\n\t* sar: Make sure header lines are always displayed in report for statistics\n\t  [12.0.2] [11.6.6] [11.4.11].\n\t* Makefile: Fix \"unexpected operator\" error on install [12.0.2] [11.6.6]\n\t  [11.4.11].\n\t* sar: Fix typo in manual page [12.0.2] [11.6.6] [11.4.11].\n\t* New non regression tests added.\n\t* README file updated: Added LGTM code quality badges.\n\t* sar manual page updated.\n\t* FAQ updated.\n\t* Cosmetic fixes.\n\n2018/08/03: Version 12.0.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: SVG: Remove id tag from individual graphs. Use activities\n\t  identification numbers for id tags.\n\t* sadf: SVG: Add new option \"showtoc\", which can be used to display\n\t  the list of activities for which there are graphs (\"table of\n\t  contents\").\n\t* sadf: SVG: Improve output for softnet activity: Add a discontinuity in\n\t  graph when corresponding CPU is marked offline.\n\t* sadf: SVG: Improve function used to assess SVG canvas height.\n\t* sadf: SVG: Fix core dumped on buffers reallocation.\n\t* sar/sadf: Devices list management code refactoring.\n\t* sadf: SVG: Display graphs for swap utilization in packed mode [11.6.5].\n\t* sadf: SVG: Don't take into account activities with no graphs when\n\t  calculating canvas height [11.6.5].\n\t* sadf: SVG: Don't insert a gap in SVG output if an activity is not\n\t  displayed [11.6.5].\n\t* sadf: SVG: Fix possible negative value in graphs coordinates [11.6.5].\n\t* sa_conv.c: Use write_all() function instead of write() to handle possible\n\t  signal interruptions.\n\t* spec file updated: No longer create a debug package.\n\t* Remove many warnings from gcc v7/v8.\n\t* README file updated.\n\t* Manual pages updated.\n\n2018/06/01: Version 11.7.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadf: Add new option \"--iface=\": Allow the user to select the\n\t  network interfaces to display.\n\t* sar/sadf: Add new option \"--dev=\": Allow the user to select the\n\t  block devices to display.\n\t* sar/sadf: Add new option \"--fs=\": Allow the user to select the\n\t  filesystems to display.\n\t* Add new option \"--dec=\": Allow the user to choose the number of decimal\n\t  places to be used by sysstat commands.\n\t* Manual pages updated (sar, sadf, cifsiostat, iostat, mpstat, pidstat).\n\t* sar: Change how used memory (kbmemused) is calculated to be\n\t  consistent with free(1) and top(1)'s output [11.6.4] [11.4.10].\n\t* pidstat: Fix incorrect thread names displayed with -t and -l options\n\t  [11.6.4] [11.4.10].\n\n2018/04/06: Version 11.7.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Fix possible crash happening when buffers needed to be\n\t  reallocated to accomodate more devices.\n\t* sar/sadf/mpstat: Compute global CPU statistics as the sum of individual\n\t  CPU ones.\n\t* mpstat: Compute statistics for node \"all\" as the sum of individual\n\t  CPU statistics.\n\t* sar: Add new \"-z\" option, which tells sar to omit output for any\n\t  devices for which there was no activity during the sample period.\n\t* sar/sadf: Now better take into account offline and online CPU when\n\t  displaying softnet statistics.\n\t* sadc: Shrink size of sadc binary file by compiling out unneeded\n\t  functions.\n\t* sadf: Change raw format output to be CSV compliant.\n\t* sadf: Reorder some values displayed in debug mode/raw format.\n\t* Add initial support for major numbers > 255.\n\t* Update sysstat.ioconf devices list.\n\t* mpstat: Remove option \"-P ON\". mpstat now displays only online CPU by\n\t  default.\n\t* sar and mpstat manual pages updated.\n\t* pidstat: Report CPU usage for a process as the sum of all threads\n\t  [11.6.3] [11.4.9].\n\t* sar: Change condition used in workaround for CPU coming back online\n\t  [11.6.3] [11.4.9].\n\t* NLS updated: Various translations updated.\n\n2018/02/12: Version 11.7.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Rewrite function used to convert an old binary data file to\n\t  the up-to-date format.\n\t* sar: Display all items for USB and filesystems activities in the\n\t  summary ending the report.\n\t* sar: Don't read statistics twice when displaying average stats since\n\t  system startup.\n\t* sar: Update magic number for certain activities structures (should have\n\t  been done in 11.7.1).\n\t* sar: Display reports name in help message (sar --help).\n\t* sadc: Enable the user to select which activities will be collected\n\t  by their name.\n\t* sar/sadc: Add DEBUG code.\n\t* sadf: RAW: Enhance output.\n\t* sadf: RAW: Rename \"showhints\" option to \"debug\".\n\t* sadf: sadf -H now displays more details on file.\n\t* sadf: SVG: Set minimum canvas height to 100 points.\n\t* sadf: SVG: Display grid and graduations on the whole width of the graph\n\t  [11.6.3] [11.4.9].\n\t* sadf: SVG: Don't display graphs for offline CPU.\n\t* iostat, cifsiostat: Display device name at the end of the line\n\t  when option -h is used.\n\t* iostat: Refresh device list properly [11.6.3] [11.4.9].\n\t* Travis CI: Add new tests.\n\t* Increase maximum number of interrupts that can be processed by sysstat\n\t  commands (NR_IRQS).\n\t* FAQ updated [11.6.3] [11.4.9].\n\t* sadf and sar manual pages updated.\n\t* NLS updated: Various translations updated.\n\t* README file updated.\n\t* Code cleaned and cosmetic fixes.\n\n2018/01/12: Version 11.7.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadc: New binary data file format, which is now more flexible\n\t  and takes much less space on disk.\n\t* sar/sadc: Dynamic structures allocation for all devices registered\n\t  by the system.\n\t* sar/sadf: Support for big-endian/little-endian format for binary\n\t  data files.\n\t* sar/sadc: Use 64-bit time values in binary data files.\n\t* sar/sadc: Update statistics structures to keep with current kernels.\n\t* sar/sadc: Update binary file's header data to deal with patchlevel\n\t  and sublevel version numbers greater than 15.\n\t* sadc: Save HZ value in data file header.\n\t* sar/sadc: Don't assume CPU statistics are always saved in binary\n\t  data files.\n\t* sar/sadf: Don't display offline CPU.\n\t* sadf: Conversion function (option -c) temporarily inhibited.\n\t  It will work again with next sysstat version (11.7.2).\n\t* sar: The option used to display a help message is now \"--help\".\n\t* sar: Add new option -h to make sar's output easier to read by a\n\t  human. This option moves device names (disks, network interfaces)\n\t  at the end of the line. This option also sets options -p (pretty-\n\t  print) and --human.\n\t* sadf: RAW: Display number of items for each activity.\n\t* sadf: Make option -H display all the activities present in file,\n\t  whether known or unknown.\n\t* All commands now use only /proc/uptime to compute system uptime.\n\t  Also use a time interval expressed in seconds, not in jiffies.\n\t* Makefile: Fix dependencies between files.\n\t* Makefile: Remove old references to nfsiostat command.\n\t* [Robert Luberda]: Fix sadc crash when really long lines are\n\t  read from /etc/mtab [11.6.1] [11.4.7] [11.2.13].\n\t* [JoungKyun Kim]: NLS updated: Add Korean translation [11.6.1].\n\t* [Christian Ehrhardt]: Fix 00 byte after values when --human is\n\t  not set [11.6.1].\n\t* Fix invalid token in \"iostat -y\" JSON output [11.6.1].\n\t* Workaround for offline CPU coming back online [11.6.2] [11.4.8]\n\t  [11.2.14].\n\t* sadf: Fix CSV output for TTY statistics [11.6.2] [11.4.8]\n\t  [11.2.14].\n\t* sadf: Remove duplicate % sign displayed in ppc mode [11.6.2].\n\t* SVG: Display time as xx:00 instead of xxH when \"oneday\" option\n\t  is used [11.6.2] [11.4.8].\n\t* sar: Use ULLONG_MAX/2 to check if network device counters have\n\t  overflown [11.6.2] [11.4.8] [11.2.14].\n\t* Remove SCCSID strings in executable files to allow reproducible\n\t  build [11.6.1] [11.4.7] [11.2.13].\n\t* Remove unused parameters passed to functions [11.6.1] [11.4.7]\n\t  [11.2.13].\n\t* sadf: Don't use f_count2() function pointer [11.6.1] [11.4.7]\n\t  [11.2.13].\n\t* [Lukas Zapletal]: Update comment of SA_DIR in sysconfig file [11.6.1]\n\t  [11.4.7] [11.2.13].\n\t* NLS: Various translations updated.\n\t* Various cosmetic fixes, typo fixes and documentation enhancements\n\t  in source code.\n\n2017/08/14: Version 11.6.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* pidstat: Add new option (-e) which can be used to pass a program\n\t  to execute and make pidstat monitor it.\n\t* pidstat: Add new option (-H) to display timestamps in seconds\n\t  since the Epoch.\n\t* pidstat manual page updated.\n\t* Revert \"ARM: Fix sadc crash because of unaligned memory accesses\".\n\t  The fix may cause segmentation faults in some cases [11.4.6]\n\t  [11.2.12].\n\t* Add BUG_REPORT template file.\n\t* README file updated.\n\t* Cosmetic changes in code.\n\t* lsm file updated [11.4.6] [11.2.12].\n\n2017/07/05: Version 11.5.7 - Sebastien Godard (sysstat <at> orange.fr)\n\t* iostat: Add new \"-s\" switch used to display a short (narrow)\n\t  version of the report that should fit in 80 chars wide screens.\n\t* iostat: Add new metrics to iostat's extended statistics report.\n\t* iostat: Express requests average size in kB, not sectors.\n\t* iostat: Make JSON output depend on options used.\n\t* iostat: Remove trailing colon following \"Device\" field name.\n\t* sar/sadf: Metrics from disks report previously expressed in\n\t  sectors are now expressed in kB.\n\t* Update DTD/XSD documents.\n\t* SVG: Fix graphs for swap space utilization statistics.\n\t* Display unit with areq-sz metric values when --human option used.\n\t* Display a percent sign after values when --human option used.\n\t* pidstat: Don't stop if /proc/#/schedstat files don't exist.\n\t* Fix ressource leak (CID 144609) [11.4.5] [11.2.11].\n\t* Cast variables to target type before use [11.4.5] [11.2.11].\n\t* Fix buffer overflow when options -s or -e are used with sar\n\t  (DEBIAN bug #863197) [11.4.5] [11.2.11].\n\t* SVG: Define a max number of horizontal lines for the background\n\t  grid [11.4.5].\n\t* Change default colors to be usable on both dark and light\n\t  terminal backgrounds [11.4.5] [11.2.11].\n\t* Start collect and summary systemd services after sysstat.service\n\t  [11.4.5] [11.2.11].\n\t* Manual pages updated.\n\t* CREDITS file updated.\n\n2017/05/10: Version 11.5.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* mpstat: Provide CPU statistics based on NUMA node placement.\n\t* SVG: Add new option: \"showinfo\".\n\t* ARM: Fix sadc crash because of unaligned memory accesses [11.4.4]\n\t  [11.2.10].\n\t* Makefile: Fix test failures on big endian archs.\n\t* rndr_stats.c: Simplify fix for warning given by\n\t  gcc -Werror=format-security\n\t* mpstat: Remove unneeded parameter from JSON functions.\n\t* mpstat and sadf manual pages updated.\n\t* [Robert Luberda]: isag: Add several enhancements and fixes.\n\t* Fix typo in sadf manual page [11.4.4].\n\n2017/02/27: Version 11.5.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* SVG: Allow multiple charts on a row (new option added: \"packed\").\n\t* SVG: Add new option: \"height=...\"\n\t* SVG: Properly terminate SVG file when no data have been found\n\t  [11.4.4].\n\t* SVG: Don't extend X axis beyond time end [11.4.4].\n\t* Add new %wait field to pidstat CPU utilization.\n\t* sadf: Fix insecure data handling (CID #139643).\n\t* sadf: Small code cleanup.\n\t* Fix comment in /etc/sysconfig/sysstat file [11.4.4] [11.2.10].\n\t* Makefile: Add regression tests (\"test\" target).\n\t* Hook up to Travis CI.\n\t* README file completely rewritten.\n\t* FAQ file converted to MarkDown format.\n\t* Remove isag support.\n\t* sadf and pisdstat manual pages updated.\n\t* Remove nfsiostat from .gitignore file [11.4.4] [11.2.10].\n\n2017/01/11: Version 11.5.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Add new \"raw\" output format.\n\t* sar: Remove memory statistics (option -R).\n\t* SVG: Give actual canvas height at the end of SVG output.\n\t* Make sar's -I option work again with sadf.\n\t* sar: Better handle dynamically registered devices [11.4.3]\n\t  [11.2.9].\n\t* sar: Fix incorrect gcc warning in svg_stats.c [11.4.3].\n\t* SVG: Init f_svg_print() function pointer to NULL [11.4.3].\n\t* sadf and sar manual pages updated.\n\t* README file updated (added Coverity Badge).\n\t* NLS translations updated. Added new Friulian translation.\n\t* Cosmetic fixes in source code.\n\n2016/12/06: Version 11.5.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Add new metric \"available free memory\" to memory statistics.\n\t* Update DTD and XSD documents to include new metric.\n\t* sar/pidstat/iostat/tapestat/cifsiostat: Add new --human option to\n\t  display values in human readable format.\n\t* SVG: Add new option \"showidle\" to be used with sadf to display\n\t  CPU idle state.\n\t* sar/mpstat: Allow selection of a range of CPU or interrupts.\n\t* Update mpstat, sar and sadf manual pages.\n\t* iostat/mpstat: Fix \"'LC_NUMERIC' undeclared\" error message when\n\t  compiling sysstat.\n\t* Sort keywords definition in sar, sadc and mpstat manual pages\n\t  [11.2.9] [11.4.3].\n\t* SVG: Change some colors to make graphs easier to distinguish\n\t  [11.4.3].\n\t* Small fix in iostat manual page [11.2.9] [11.4.3].\n\t* Cosmetic changes in source code [11.2.9] [11.4.3].\n\t* Update lsm file contents.\n\t* NLS updated.\n\n2016/11/04: Version 11.5.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Add software-based network processing (softnet) statistics.\n\t* sadf: Add output formats for softnet statistics.\n\t* [Michal Sekletar]: sar: Make buffers that hold timestamps\n\t  bigger [11.2.8] [11.4.2].\n\t* [Shantanu Goel]: sar: /proc/vmstat fix for Linux 4.8 [11.2.8]\n\t  [11.4.2].\n\t* [Mike Winter]: pidstat: Use system constants for process name\n\t  length and username length.\n\t* [Breno Leitao]: sar: Improve cpuinfo read for POWER architecture\n\t  [11.2.8] [11.4.2].\n\t* Make various buffers size holding timestamps consistent.\n\t* sadf: Use a decimal point instead of a coma in JSON output\n\t  [11.2.8] [11.4.2].\n\t* mpstat, iostat: Use a decimal point instead of a coma in JSON\n\t  output.\n\t* pidstat: Use either the short or the full command line when\n\t  looking for a pattern with options -C or -G [11.2.8] [11.4.2].\n\t* sar manual page updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2016/09/23: Version 11.5.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* iostat: Add JSON output (option \"-o JSON\").\n\t* mpstat: Add JSON output (option \"-o JSON\").\n\t* sadf: Fix broken datafile conversion from old formats\n\t  [11.2.7] [11.4.1].\n\t* sadf: Fix fields list displayed by sadf -d for filesystem\n\t  activity [11.2.7] [11.4.1].\n\t* pidstat: Don't omit kernel threads when using -l option [11.2.7]\n\t  [11.4.1].\n\t* Reuse hdr_line string from struct activity to display activities\n\t  title line.\n\t* sadf: Remove sysstat-version from JSON output.\n\t* iostat and mpstat manual pages updated.\n\n2016/08/15: Version 11.4.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar: Workaround for I/O and transfer rates statistics which may\n\t  be wrongly calculated if a filesystem is unmounted [11.2.6].\n\t* SVG: Fix how bar graphs are displayed for filesystems statistics\n\t  in order to not loose the first sample.\n\t* SVG: Change graphs order to be consistent with the output of sar.\n\t* SVG: Change some graphs's title.\n\t* Replace strcpy() with strncpy() to avoid buffer overflows [11.2.6].\n\t* Fixed unsigned compared against 0 problem (CID#127473) [11.2.6].\n\t* NLS updated.\n\n2016/06/24: Version 11.3.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* SVG: Add SVG output for ICMP{v4,v6}, IPv6, UDPv6, voltage inputs,\n\t  NFS client, NFS server, disks, filesystems and FC HBA statistics.\n\t* SVG: Add SVG output for IPv4, ICMPv4, TCPv4, IPv6 and ICMP\n\t  network errors statistics.\n\t* SVG: Make sure graduations are properly aligned with grid.\n\t* SVG: Add oneday option to control SVG output.\n\t* SVG: Fix skipempty option.\n\t* [Peter Schiffer]: Stricter check for file_magic->header_size [11.2.5].\n\t* [Peter Schiffer]: tapestat: Various fixes [11.2.5].\n\t* [Esteban Fallas]: Check for undefined UID variable in sysstat script\n\t  [11.2.5].\n\t* [Carsten Grohmann]: Unify description of the tps value in the sar\n\t  manual page for -b and -d flags [11.2.5].\n\t* sadf manual page updated.\n\n2016/05/14: Version 11.3.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* SVG: Add SVG output for fan speed and temperature sensors\n\t  statistics, I/O and transfer rate statistics, kernel tables\n\t  statistics, hugepages utilization statistics, IPv4 and IPv6\n\t  network sockets statistics, UDPv4, TCPv4 and IPv4 network statistics.\n\t* SVG: Add skipempty and autoscale options to control SVG output.\n\t* sadf and sar manual pages updated [11.2.4].\n\t* NLS translation updated.\n\t* Various cosmetic changes in code [11.2.4].\n\n2016/04/09: Version 11.3.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* SVG: Add SVG output for CPU statistics, CPU frequency statistics,\n\t  memory and swap statistics, and queue length and load average\n\t  statistics.\n\t* SVG: Make SVG code independent from the locale used to display\n\t  numerical values.\n\t* SVG: Fix possibly truncated SVG code.\n\t* SVG: Make sure that a minimum interval value is used on X and Y\n\t  axis.\n\t* [Peter Portante]: Quick fix for cprintf_u64 non-uintv64_t [11.2.3].\n\t* NLS translations updated.\n\n2016/03/13: Version 11.3.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Add SVG output for paging statistics, network interfaces\n\t  and swap statistics.\n\t* SVG: Specify charset encoding in SVG header.\n\t* SVG: Fix invalid use of attribute vector-effect.\n\t* sar: Fix possible confusion between network interfaces that\n\t  could happen when a new interface was registered and appeared\n\t  in the middle of the list in the /proc/net/dev file [11.2.2].\n\t* sar: Fix possible compatibility issues between sysstat versions\n\t  [11.2.2.].\n\t* [Y. Namiki]: sar: Print time in the ISO format if\n\t  S_TIME_FORMAT=ISO [11.2.2].\n\t* mpstat/pidstat: Print time in the ISO format if S_TIME_FORMAT=ISO\n\t  [11.2.2].\n\t* [Steve Kay]: Disable NLS if any gettext components are\n\t  unavailable [11.2.2].\n\t* [Steve Kay]: sadf: Fix several typos in SVG output.\n\t* [Steve Kay]: Fix tapestat manual page typos [11.2.2].\n\t* [Peter Schiffer]: Add new SP_VALUE_100() macro which limits\n\t  value to 100% for CPU statistics displayed by pidstat [11.2.2].\n\t* sar, sadf, pidstat and mpstat manual pages updated.\n\n2016/02/21: Version 11.3.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: Add new SVG (Scalable Vector Graphics) output format.\n\t  This option enables the user to display fancy graphs in a\n\t  web brower using the data collected by sar/sadc!\n\t* sar/sadf: Major code refactoring.\n\t* sadf: Don't display the JSON fchosts tag when no statistics\n\t  data exist for Fibre Channel [11.2.1].\n\t* README file converted to Markdown format [11.2.1].\n\t* [Peter Schiffer]: Convert CREDITS file to utf-8 [11.2.1].\n\t* [Peter Schiffer]: Update license text [11.2.1].\n\t* sadf manual page updated.\n\t* FAQ updated.\n\t* Update README file and copyright messages [11.2.1].\n\t* NLS updated [11.2.1].\n\n2015/12/27: Version 11.2.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* mpstat: Code refactoring (better handle some special borderline\n\t  cases for per-processor interrupts statistics).\n\t* mpstat: Option -I now accepts a list of comma-separated\n\t  arguments.\n\t* sar: Fix color output for %temp and %in fields.\n\t* sadf: Fix bug preventing sadf from converting a data file with\n\t  an old format.\n\t* sadc: Fix insecure data handling, really (CID #29720).\n\t* [Peter Schiffer]: Increase NR_CPUS to match kernel upstream.\n\t* sar: Check minimum size of sa data files header (CID #29719).\n\t* sadc: Fix default number of frequencies for A_PWR_WGHFREQ\n\t  activity.\n\t* pidstat: Define new SCHED_DEADLINE scheduling policy.\n\t* Remove obsolete nfsiostat-sysstat command.\n\t* mpstat manual page updated.\n\t* NLS updated.\n\n2015/10/23: Version 11.1.8 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Add support for color customization.\n\t* Add color support for pidstat, tapestat and cifsiostat commands.\n\t* Define values \"always\", \"never\" and \"auto\" for S_COLORS\n\t  environment variable.\n\t* sar: Remove extra line of statistics displayed when SIGINT is\n\t  received.\n\t* Add missing va_end() statements (CID #113539, #113540, #113541,\n\t  #113542).\n\t* Fix possible NULL pointer dereference in SREALLOC macro (CID\n\t  #29706) [11.0.8].\n\t* sadc: Fix untrusted value used as argument (CID #29720) [11.0.8].\n\t* sadc: Fix another insecure data handling (CID #29720).\n\t* sar/sadc: Set an upper limit for each kind of item that sar/sadc\n\t  can handle.\n\t* Manual pages updated for iostat, mpstat, sar, pidstat, tapestat\n\t  and cifsiostat commands.\n\t* Update librdsensors.a target in Makefile [11.0.8].\n\n2015/09/20: Version 11.1.7 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Add color support for mpstat, iostat and sar commands.\n\t* [Peter Schiffer]: Fix problem with pidstat output values > 100%\n\t  for %CPU [11.0.7].\n\t* [Shane Seymour]: tapestat: Fix issue when st driver is unloaded\n\t  then loaded again.\n\t* [Christian Neukirchen]: Fix header files included in tapestat.\n\t* Make sysstat build on musl (non-glibc) environment.\n\t* tapestat: Check fscanf() return values.\n\t* [Alexis Solanas]: Fix issue with iostat not showing the full\n\t  device name [11.0.7].\n\t* sa2: DATE couldn't be set when DATE_OPTS variable was empty.\n\t  Fix this.\n\t* Add sa2 option to avoid sarDD report generation.\n\t* [Julian Taylor]: sargraph2: Fix MB/s units and help typo.\n\t* sysstat(5), iostat, mpstat and sar manual pages updated.\n\t* NLS: Sync'd with Translation Project.\n\t* CREDITS file updated.\n\n2015/08/24: Version 11.1.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Shane Seymour]: Added new \"tapestat\" command aimed at\n\t  displaying statistics for tape drives.\n\t* [Shane Seymour]: Added tapestat manual page.\n\t* Check /proc/net/snmp format to collect ICMP statistics at\n\t  their right positions [11.0.6].\n\t* sadc: Fix untrusted value used as argument.\n\t* sa_conv.c: Fix ressource leak.\n\t* ioconf.c: Fix several ressource leaks [11.0.6].\n\t* mpstat: Fix alignment output, really [11.0.6].\n\t* [Sampsa Kiiskinen]: Fix bug in isag [11.0.6].\n\t* iostat's option -T renamed to -H.\n\t* iostat manual page updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2015/06/12: Version 11.1.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Steve Kay]: sar: Added fibre channel HBA statistics.\n\t* [Steve Kay]: Replace non printable characters in comments\n\t  displayed by sar/sadf.\n\t* [Peter Schiffer]: Fixed and simplified some math expressions\n\t  in pr_stats.c [11.0.5].\n\t* [Peter Schiffer]: ioconf.c: Check value of variable \"major\"\n\t  read from file [11.0.5].\n\t* [Peter Schiffer]: ioconf.c: Use strncpy instead of strcpy [11.0.5].\n\t* sar: Fixed untrusted loop bound [11.0.5].\n\t* sadc: Fixed time-of-check, time-of-use race condition.\n\t* [Vitezslav Cizek]: Assume device-mapper is not running when\n\t  it is not found in /proc/devices.\n\t* sar: Added option --sadc. This option indicates which data\n\t  collector will be called by sar.\n\t* sadf: Fixed null pointer dereference which could happen with a\n\t  malformed system activity datafile.\n\t* cifsiostat: Fixed possible integer overflowed argument [11.0.5].\n\t* sar manual page updated.\n\t* FAQ updated.\n\t* DTD and XSD documents updated.\n\t* NLS updated.\n\n2015/04/07: Version 11.1.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Makefile: sysstat init script may sometimes be called rc.sysstat.\n\t  So use that name when needed [11.0.4].\n\t* pidstat: Don't stop if gtime and cgtime fields are unavailable\n\t  [11.0.4].\n\t* sar: Fix output with filesystems having more than MAX_FS_LEN\n\t  characters in length.\n\t* Updated DTD and XSD documents. XML document, as displayed by\n\t  sadf -x, should now be properly validated against them.\n\t* [Peter Schiffer]: Replace spaces with tabs in Makefile.in [11.0.4].\n\t* [Peter Schiffer]: Create appropriate directories in DESTDIR if\n\t  missing [11.0.4].\n\t* [Peter Schiffer]: Fixed installation of systemd/cron files on\n\t  systems w/o systemd [11.0.4].\n\t* [Peter Schiffer]: Don't look in weird places for programs during\n\t  configuration [11.0.4].\n\t* [Steve Kay]: sar: Added option to display mountpoint names instead\n\t  of filesystem names.\n\t* [Steve Kay]: sar/sadf: Permit hh:mm:ss as well as hh:mm.\n\t* [Steve Kay]: Fix mpstat SCPU alignment output [11.0.4].\n\t* [Steve Kay]: Fix unproperly indented line in sar -h output.\n\t* Makefile: Call chkconfig only if $(COPY_ONLY) is set to no [11.0.4].\n\t* sysstat(5) manual page updated [11.0.4].\n\t* [Dimitrios Apostolou]: Updated sargraph tool.\n\t* [Dimitrios Apostolou]: Updated sa2 script to support more compression\n\t  formats. Simplify logic with regexes.\n\t* [Dimitrios Apostolou]: YESTERDAY variable can now be changed in sysstat\n\t  config file (/etc/sysconfig/sysstat).\n\t* [Dimitrios Apostolou]: By default sa2 now generates yesterday's summary.\n\t* CREDITS file updated.\n\n2015/02/13: Version 11.1.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar/sadc: Added new metrics from /proc/meminfo to memory\n\t  statistics.\n\t* sadf: Update output formats to take into account new memory\n\t  metrics.\n\t* [Peter Schiffer]: Fixes from static analysis.\n\t* [Peter Schiffer]: Prefer xz compression program when compressing\n\t  sa data files [11.0.3].\n\t* [Peter Schiffer]: Portable way to detect 64 bit OS in configure\n\t  script [11.0.4].\n\t* [Vasant Hegde]: sadc: Fix possible race condition in signal\n\t  handler code [11.0.3].\n\t* Fix description of %util in iostat and sar manual pages [11.0.3].\n\t* Fix wrong size used in upgrade_magic_section() function.\n\t* Add new sadc_options variable to configure script.\n\t* Rename --disable-man-group option to --disable-file-attr. This\n\t  configure's option prevents the build process from setting\n\t  attributes of files being installed.\n\t* Make sure that no crontabs are activated when configure's option\n\t  --enable-copy-only is used [11.0.3].\n\t* FAQ updated.\n\t* RPM spec file updated.\n\t* sar manual page updated.\n\t* sadc manual page updated [11.0.3].\n\t* CREDITS file updated.\n\t* Code cleaned [11.0.3].\n\n2014/10/19: Version 11.1.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Robert Elliott]: Added irqtop command. irqtop monitors\n\t  differences in /proc/interrupts and /proc/softirqs per CPU,\n\t  along with CPU statistics. irqtop is currently in the contrib\n\t  directory.\n\t* [Lance Shelton]: Added irqstat command, a better way to watch\n\t  /proc/interrupts, designed for NUMA systems with many\n\t  processors.\n\t* [Vasant Hegde]: sadc: Don't send SIGINT signal if parent\n\t  process is already dead [11.0.2].\n\t* sadc: Make sure that functions used to count items (CPU,\n\t  network interfaces, etc.) are called only once.\n\t* sar and sadf now tell the user when they cannot read a file\n\t  because the endian format doesn't match.\n\t* Fixed incomplete sar and sadf output when end time (specified\n\t  with option -e) crosses 24 hour boundary [11.0.2].\n\t* cifsiostat/nfsiostat: Fix output on single core CPU [11.0.2].\n\t* pidstat didn't handle processes with spaces in their name\n\t  properly. This is now fixed [11.0.2].\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2014/08/30: Version 11.1.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added option -c to sadf: This option enables the user to\n\t  convert an sa datafile with an old format (at least 9.1.6)\n\t  to the up-to-date format (11.1.1 as of today).\n\t* Update sadf -H output to print datafile date and tell whether\n\t  this file has been converted from an old datafile or not.\n\t* Added option -[0-9]+ to sadf to show data of that days ago\n\t  [11.0.1].\n\t* Use statvfs() system call instead of deprecated statfs() to\n\t  get filesystems statistics with sar [11.0.1].\n\t* sar: Stricter syntax check [11.0.1].\n\t* Remove unneeded include file in sa_common.c [11.0.1].\n\t* [Kosaki Motohiro]: Update workaround for 32bit CPU counters\n\t  [11.0.1].\n\t* Define unknown scheduling policies in pidstat.h [11.0.1].\n\t* [Ivana Varekova]: Test return value for fgets/fscanf calls\n\t  [11.0.1].\n\t* Makefile updated: Follow symlinks when creating the tarballs\n\t  [11.0.1].\n\t* sadf manual page updated [11.0.1].\n\n2014/06/17: Version 11.0.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Cedric Marie]: pidstat now displays task scheduling priority\n\t  and policy along with task switching activity (-w option).\n\t* [Cedric Marie]: pidstat: Add option -G to filter processes\n\t  by name.\n\t* pidstat: Update variables type to be consistent with recent\n\t  3.x kernels.\n\t* sadc/sar/sadf: The standard daily data files may now be\n\t  named saYYYYMMDD instead of saDD. Option -D has been added\n\t  to sar and sadc to tell them to write to data files under the\n\t  name saYYYYMMDD.\n\t* sadc/sar/sadf: Take into account alternate locations for\n\t  standard daily data files.\n\t* sa1 and sa2 scripts updated: Don't create a tree of directories\n\t  any more if HISTORY is greater than 28. Use saYYYYMMDD\n\t  data files instead.\n\t* sa1 and sa2 scripts now take into account two new variables:\n\t  SA_DIR (directory where sa and sar files are located) and\n\t  ZIP (compression program to use).\n\t* Make sysstat init script source the functions library\n\t* Fix possible buffer overflow.\n\t* Small fix with sadc's option -S: It is now possible to enter\n\t  several comma separated values.\n\t* Don't install crontabs when using systemd timer units.\n\t* Manual pages updated.\n\t* FAQ updated.\n\t* NLS updated. Galician and Hungarian translations added.\n\t* CREDITS file updated.\n\n2014/03/18: Version 10.3.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n          compatible with the previous one! [0x2173]\n\t* sar/sadc/sadf: Now take into account a change of CPU count\n\t  in datafiles. The number of CPU is displayed in the RESTART\n\t  messages.\n\t* DTD and XSD documents updated.\n\t* [Tomasz Torcz]: Add systemd timer units replacing cronjobs.\n\t* [Mike Kazantsev]: Fix output of sadf -j with file-utc-time present.\n\t* [Peter Portante]: sa2 script now also catches 'xz' compressed\n\t  files as well.\n\t* Rename nfsiostat to nfsiostat-sysstat and indicate it is now\n\t  obsolete. An nfsiostat command is already included in the\n\t  nfs-utils package.\n\t* When attempting to use a non existent daily datafile, sar and\n\t  sadf tell the user to check if data collecting is enabled.\n\t* sadf -H now displays the number of activities in file.\n\t* nfsiostat manual page updated.\n\t* FAQ updated.\n\t* README file updated.\n\t* NLS updated.\n\n2014/01/19: Version 10.2.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added new --enable-copy-only option to configure script.\n\t  This option may be useful when creating sysstat package to\n\t  make sure that files are only copied to $DESTDIR and that\n\t  no service is activated (eg. for distro using systemd).\n\t* pidstat: Add a new metric to pidstat I/O statistics:\n\t  per-task block I/O delays.\n\t* Take $DESTDIR variable into account when installing sysstat\n\t  service used by systemd.\n\t* sadf -H, sadf -j and sadf -x now also display the file\n\t  creation time.\n\t* Use sizeof() instead of hardcoded size values.\n\t* pidstat manual page updated.\n\t* Cosmetic fixes.\n\t* NLS updated.\n\n2013/11/03: Version 10.2.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* pidstat: Added option -v, enabling the user to display the\n\t  number of threads and file descriptors associated with tasks.\n\t* Stack stats displayed by \"pidstat -s\" were sometimes not\n\t  displayed for some processes although values had changed.\n\t  This is now fixed.\n\t* pidstat can now display stats since system startup for a list\n\t  of processes given on the command line.\n\t* pidstat -d now displays -1 for I/O stats values when the\n\t  process I/O file cannot be read (permission denied or file\n\t  non existent).\n\t* mpstat and pidstat commands now exit immediately when they\n\t  get a SIGINT signal during the first interval of time.\n\t* [Alexander Troosh]: mpstat: Take into account the highest\n\t  processor number in mpstat output.\n\t* Rearrange options displayed by sar -h (upper case option\n\t  should be displayed before its lower case counterpart).\n\t* Added \"prealloc\" variable to configure script. This variable\n\t  will determine the size of data files created by sar/sadc.\n\t* Added xz-compressed target to Makefile.\n\t* pidstat manual page updated.\n\t* NLS updated.\n\t* CREDIT updated.\n\n2013/09/13: Version 10.1.7 - Sebastien Godard (sysstat <at> orange.fr)\n\t* New metric added to sar network devices statistics: %ifutil\n\t  now gives the network interface utilization percentage.\n\t* Now use a lightweight static library having only the necessary\n\t  functions to compile sysstat commands. This results in a\n\t  size 25% to almost 45% smaller for some commands.\n\t* [Kevin Johnson]: Rewrite rule for librdstats.a in Makefile\n\t  to allow parallel execution.\n\t* [Peter Schiffer]: Fix wrong permissions for data file created\n\t  by sa1 script when HISTORY is greater than 28.\n\t* [Muneyuki Noguchi]: Use %u instead of %d for unsigned int\n\t  variables.\n\t* [Muneyuki Noguchi]: Close file descriptor before exit in\n\t  pidstat.c.\n\t* [Muneyuki Noguchi]: Remove redundant NULL checks.\n\t* [James Fraser]: Replace comma with semi-colon in filesystems\n\t  statistics header line.\n\t* Fixed sar log file corruption in odd Feb 28th edge-case.\n\t* Filesystems statistics (displayed by sar -F) are now collected\n\t  by sadc only if option \"-S XDISK\" is used.\n\t* sar now collects all statistics (including partitions ones)\n\t  when data are saved into a file with option -o.\n\t* [Yan Gao]: Update iostat manual page: Don't say that device\n\t  saturation occurs when %util is close to 100% for devices\n\t  serving multiple requests simultaneously.\n\t* Documentation fixes and updates.\n\t* Several manual pages updated (sar, sadc, sadf, sa1, sa2, sysstat).\n\t* NLS updated.\n\n2013/06/09: Version 10.1.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Filesystems statistics added to sar/sadc/sadf. These stats can\n\t  be displayed with option -F.\n\t* DTD and XSD documents updated. \n\t* Code cleaned: Removed several unused constants from header files.\n\t* Sysstat command options can now be 'collapsed' (grouped) when\n\t  not followed by an argument. So it's now possible for example\n\t  to enter 'iostat -px 2 5' since no device name is given to\n\t  option -p. This also concerns pidstat option -U.\n\t* Fixed type for \"memfree\" and \"intr\" elements in XSD document.\n\t* Removed functions used to count number of items from rd_stats.c\n\t  and put them in a separate file (count.c).\n\t* NLS updated (da, hr, cs). Turkish translation added.\n\t* Typos fixed. README file updated.\n\t* Yet another cosmetic fix in pidstat manual page. Sar and\n\t  mpstat manual pages updated.\n\n2013/03/31: Version 10.1.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* mpstat now takes into account every interrupt per processor\n\t  so that their number adds up to the number displayed for CPU \"all\".\n\t* [Peter Schiffer]: systemd unit file couldn't be installed\n\t  because PKG_PROG_PKG_CONFIG macro wasn't expanded in configure\n\t  script. This is now fixed.\n\t* [Benno Schulenberg]: Fixed a small inconsistency in pidstat\n\t  usage message.\n\t* Cosmetic fixes in pidstat manual page.\n\t* NLS updated (de, eo, fi, fr, ja, nb, nl, ru, uk, vi).\n\t* CREDITS file updated.\n\n2013/03/08: Version 10.1.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Christophe Cerin]: pidstat now stops and displays its average\n\t  stats when it receives SIGINT (crtl/c).\n\t* mpstat now stops and displays its average stats when it\n\t  receives SIGINT (crtl/c).\n\t* sar now stops and displays its average stats when it receives\n\t  SIGINT (crtl/c).\n\t* pidstat now displays task's UID for all tasks.\n\t* pidstat: -U option added. This option tells pidstat to display\n\t  the username of the task instead of its UID. When this option is\n\t  followed by a user name, then only tasks belonging to the\n\t  specified user are displayed by pidstat.\n\t* pidstat manual page updated.\n\t* Now use sigaction() instead of signal() for signals handling\n\t  to avoid portability problems.\n\t* FAQ updated.\n\t* NLS updated.\n\n2012/12/23: Version 10.1.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Changed network counters (used by sar -n {DEV | EDEV }) to\n\t  unsigned long long to keep in sync with current kernels.\n\t  WARNING: This breaks compatibility with older sar data\n\t  files format for network statistics.\n\t* Changed IPv4 counters (used by sar -n { IP | EIP}) to\n\t  unsigned long long to keep in sync with current kernels.\n\t  WARNING: This breaks compatibility with older sar data\n\t  files format for IPv4 statistics.\n\t* Changed IPv6 counters (used by sar -n { IP6 | EIP6}) to\n          unsigned long long to keep in sync with current kernels.\n          WARNING: This breaks compatibility with older sar data\n          files format for IPv6 statistics.\n\t* [Peter Schiffer]: Added option -y to iostat. This option\n\t  prevents iostat from displaying its first report with\n\t  statistics since system boot.\n\t* [Peter Schiffer]: Increase NR_CPUS and NR_IRQS values.\n\t* [John Lau]: sadc didn't collect all its activities when\n\t  it had to overwrite an old sysstat data file with some\n\t  unknown activity formats. This is now fixed.\n\t* Now install sadc in $prefix/lib64 directory on 64 bit machines\n\t  even if $prefix/lib directory also exists.\n\t* Fixed DTD document: If computer has run all day without\n\t  restart, XML output file from sadf -x has no boot elements.\n\t* Remove heading spaces in softirq names displayed by mpstat\n\t  for easier reading.\n\t* Fixed wrong command execution syntax in configure script.\n\t* Removed several unused definitions in some header files.\n\t* iostat manual page updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2012/10/06: Version 10.1.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* New field added to sar -u and mpstat: %gnice (time spent\n\t  running a niced guest).\n\t* New field added to sar -r: kbdirty (amount of memory waiting\n\t  to get written back to disk).\n\t* [Peter Schiffer]: systemd support added.\n\t* [Peter Schiffer]: Sysstat init script updated to make it\n\t  more conforming to LSB.\n\t* XML DTD document name is now tagged with a version number.\n\t* Fixed a fatal error when compiled with -Werror=format-security.\n\t* sar, sadf and mpstat manual pages updated.\n\t* DTD and XSD documents updated.\n\t* Cosmetic change in sadf -H output.\n\t* NLS updated.\n\n2012/07/29: Version 10.1.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added option -[0-9]+ to sar to show data of that days ago.\n\t* [Peter Schiffer]: Persistent device names support added to\n\t  sar and iostat (option -j).\n\t* [Peter Schiffer]: Make sysstat disk counters consistent\n\t  with those from latest kernel (3.5).\n\t  WARNING: This breaks compatibility with older sar data\n\t  files format for disk activity.\n\t* [Peter Schiffer]: sar: Use /sys/dev/block/major:minor links\n\t  to determine devices real name.\n\t* Part of 'sadf -H' output was written to stderr instead of\n\t  stdout. This is now fixed.\n\t* WARNING: sadf: Option '-T' has been renamed into '-U', and\n\t  option '-t' has been renamed into '-T'.\n\t* sadf: New option -t added. This option tells sadf to display\n\t  the timestamps in the local time of the data file creator\n\t  instead of UTC. The same option exists for sar.\n\t* [Peter Schiffer]: Various cosmetic changes in manual pages\n\t  and usage messages displayed by sysstat commands.\n\t* FAQ updated.\n\t* NLS updated.\n\t* sar, sadf and iostat manual pages updated.\n\n2012/05/16: Version 10.0.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Alain Chereau]: Options -g and -T added to iostat. These\n\t  options enable the user to display statistics for groups of\n\t  devices.\n\t* [Vitezslav Cizek]: sadc now overwrites its standard daily\n\t  data file when this file is from a past month.\n\t* sadf: Change time format from HH-MM-SS to HH:MM:SS in the\n\t  various reports displayed by sadf.\n\t* XSD document updated: Added a maxOccurs indicator for the\n\t  timestamp element.\n\t* Added option --enable-collect-all to configure script.\n\t  This option tells sadc to collect all possible activities,\n\t  including optional ones.\n\t* [Peter Schiffer]: Set exit code to 0 for sa2 shell script.\n\t* NLS updated. Croatian translation added.\n\t* iostat and sadc manual pages updated.\n\t* FAQ updated.\n\t* CREDITS file updated.\n\n2012/03/07: Version 10.0.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Andrey Borzenkov]: Don't take virtual devices into account in\n\t  sar -b results.\n\t* [Peter Schiffer]: iostat didn't display target device\n\t  information when a symbolic link was specified as a parameter.\n\t  This is now fixed.\n\t* The number of jiffies spent by a CPU in guest mode given by the\n\t  corresponding counter in /proc/stat may be slightly different\n\t  from that included in the user counter. Take this into account\n\t  when calculating current time interval value.\n\t* configure script updated: Added --disable-stripping option.\n\t  Using this option tells configure to NOT strip object files.\n\t* FAQ updated.\t\n\t* sa1 manual page updated.\n\t* NLS updated. Serbian translation added.\n\n2011/11/27: Version 10.0.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf: New output format added: JSON (JavaScript Object\n\t  Notation). This format can be displayed with sadf's option -j.\n\t* [Jurgen Heinemann]: Fixed a bug in sadf XML output.\n\t* [Jurgen Heinemann]: Fixed several bugs in DTD and XSD\n\t  documents.\n\t* [Petr Uzel]: Fixed random crash with iostat when called with\n\t  option -N [NOVELL Bug#729130].\n\t* sadf manual page updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2011/08/28: Version 10.0.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadf modified to make it easier to add new output formats.\n\t  Its design is still not generic anyway.\n\t* Option -T added to sadf: This option tells sadf to display\n\t  timestamps in seconds since the epoch (when applicable).\n\t* Option \"-P ON\" added to mpstat. This option tells mpstat\n\t  to display stats only for online CPU.\n\t* [Kei Ishida]: pidstat displayed stats for processes that\n\t  had terminated while pidstat was running. This is now fixed.\n\t* [Jeroen Roovers]: Automate translation files handling in\n\t  Makefile.in.\n\t* DTD and XSD documents updated.\n\t* sadf and mpstat manual pages updated.\n\t* pidstat manual page updated: Added description of field %MEM\n\t  displayed by pidstat -r.\n\t* Various cosmetic changes (sar.c, sadf.c).\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2011/06/03: Version 10.0.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added USB devices statistics to sar and sadc. The option\n\t  \"-m USB\" can now be used with sar to take a snapshot of all\n\t  the USB devices currently plugged into the system.\n\t* sadf -p now displays the sensor device name for temperature,\n\t  voltage inputs and fans statistics.\n\t* sar and pidstat: Check that _(\"Average\") string doesn't exceed\n\t  the size of the timestamp buffer.\n\t* [Ivana Varekova]: Added option -h to iostat. This option makes\n\t  the device utilization report easier to read with long device\n\t  names.\n\t* [Ivana Varekova]: cifsiostat didn't count open files from the\n\t  \"Posix Open\" column in /proc/fs/cifs/Stats file. This is now\n\t  fixed.\n\t* [Ivana Varekova]: Close file descriptor in read_uptime()\n\t  function (rd_stats.c file).\n\t* Fixed XML output displayed by sadf (hugepages statistics were\n\t  included in <power-management> section).\n\t* sar: Decrease column width for sensor device name (temperature,\n\t  voltage inputs and fans statistics).\n\t* Remove unnecessary arguments from functions in pr_stats.c.\n\t* sar manual page updated.\n\t* DTD and XSD documents updated and cleaned.\n\t* NLS updated. Esperanto translation added.\n\t* CREDITS file updated.\n\n2011/03/15: Version 10.0.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Ivana Varekova]: Fixed a problem with long NFS and CIFS share\n\t  names in cifsiostat and nfsiostat.\n\t* [Ivana Varekova]: Added the possibility to extend the number\n\t  of slots for NFS and CIFS mount points on the fly.\n\t* [Ivana Varekova]: Check calloc() return value in cifsiostat\n\t  and nfsiostat.\n\t* [Jan Kaluza]: Added --debuginfo option to cifsiostat and\n\t  nfsiostat.\n\t* cifsiostat and nfsiostat manual pages updated.\n\t* Don't link sysstat's commands with sensors library if not\n\t  needed [DEBIAN Bug#612571].\n\t* [Adam Heath]: iostat incorrectly mapped device-mapper IDs\n\t  greater than 256. This is now fixed [DEBIAN Bug#614397].\n\t* Sysstat's commands option -V now displays the version number\n\t  on stdout and returns 0 for the exit code.\n\t* sysstat_panic function is now defined only in DEBUG mode.\n\t* NLS updated. Ukrainian translation added.\n\t* CREDITS file updated.\n\n2010/12/26: Version 9.1.7 - Sebastien Godard (sysstat <at> orange.fr)\n\t  INFO: stats_queue structure format has changed and is *not*\n\t  compatible with the previous one [+1]\n\t* sar now tells sadc to read only the necessary groups of\n\t  activities.\n\t* Added a new metric (number of tasks waiting for I/O) to\n\t  sar -q.\n\t* Added two new metrics (amount of active and inactive\n\t  memory) to sar -r.\n\t* [Ivana Varekova]: Fix segfaults on bogus localtime input.\n\t* Fixed bogus CPU statistics output, which happened when\n\t  CPU user value from /proc/stat wasn't incremented whereas\n\t  CPU guest value was.\n\t* nfsiostat now takes into account POSIXLY_CORRECT environment\n\t  variable. nfsiostat default output is expressed in kB/s,\n\t  unless this variable is set (in which case the output is\n\t  expressed in blocks/s).\n\t* No longer assume that device-mapper major number is 253.\n\t  Get the real number from /proc/devices file.\n\t* DTD and XSD documents updated.\n\t* [Kenichi Okuyama]: Small change to sar manual page.\n\t* sar manual page updated.\n\t* NLS updated.\n\t* Code cleaned.\n\n2010/11/10: Version 9.1.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2171]\n\t* Added a new magical value for each activity in file.\n\t  A format change can now hit only one activity instead of\n\t  the whole file.\n\t* Added CPU average clock frequency statistics to sar and sadc.\n\t* Added hugepages utilization statistics to sar and sadc.\n\t* Fixed some differences between XML output (as displayed by\n\t  sadf -x) and DTD document.\n\t* sadc -S POWER didn't include voltage inputs statistics.\n\t  This is now fixed.\n\t* Define groups of activities: Each activity has now a new\n\t  attribute specifying the group it belongs to (POWER, IPV6, etc.)\n\t* [Ivana Varekova]: Moved manual pages to $prefix/share/man\n\t  instead of $prefix/man.\n\t* [Ivana Varekova]: Fixed configure's --disable-man-group option.\n\t* [Ivana Varekova]: Added SADC_OPTIONS to sysstat configuration file.\n\t* [Ivana Varekova]: Added sysstat(5) manual page.\n\t* sar manual page updated.\n\t* DTD and XSD documents updated.\n\t* NLS updated.\n\t* Split up prf_stats.c file into rndr_stats.c and xml_stats.c\n\t* Moved cron files in a separate cron subdirectory.\n\t* Made sysstat git aware.\n\t* CREDITS file updated.\n\n2010/09/12: Version 9.1.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added voltage inputs statistics to sar and sadc.\n\t* Added %temp field to device temperature statistics (sar -m TEMP).\n\t* Added drpm field to fan speed statistics (sar -m FAN).\n\t* XSD and DTD documents updated.\n\t* sar manual page updated. Indicate that svctm field should\n\t  no longer be trusted.\n\t* Removed link to isag(1) from man pages.\n\t* NLS updated. Czech translation added.\n\t* Sample crontabs and sysstat init script: Don't collect disk\n\t  data by default.\n\t* Code cleaned.\n\n2010/07/29: Version 9.1.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Jan Kaluza]: Added fan speed and device temperature\n\t  statistics to sar and sadc.\n\t* [Jan Kaluza]: Configure script updated. Now check for\n\t  lm_sensors library.\n\t* Configure script updated: Added --disable-sensors option.\n\t* Configure script updated: Removed --enable-smp-race option.\n\t* iconfig script updated.\n\t* sar manual page updated.\n\t* XSD and DTD documents updated.\n\t* [Ivana Varekova]: sysstat init script updated.\n\t* Default owner for sadc/sar crontab is now root.\n\t* Various fixes in cifsiostat and nfsiostat manual pages.\n\t* NLS updated.\n\n2010/06/27: Version 9.1.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Ivana Varekova]: Move NFS code out from iostat and create\n\t  the new nfsiostat command.\n\t* [Ivana Varekova]: Added cifsiostat command. This command\n\t  displays CIFS statistics.\n\t* [Mario Konrad]: Added regular expressions support to pidstat's\n\t  option -C.\n\t* [Mario Konrad]: Added option -s to pidstat to display stack\n\t  statistics.\n\t* [Ivana Varekova]: Fixed condition used by sar to distinguish\n\t  betwwen a counter reset by a newly registered device and a\n\t  counter overflow.\n\t* [Jan Kaluza]: Added --debuginfo option to iostat.\n\t* [Jan Kaluza]: Added --enable-debuginfo option to configure script.\n\t* iconfig configuration script updated.\n\t* iostat manual page updated. Indicate that svctm field should\n\t  no longer be trusted.\n\t* pidstat manual page updated.\n\t* autoconf script updated.\n\t* NLS updated.\n\t* README and CREDITS files updated.\n\n2010/05/23: Version 9.1.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added r_await and w_await fields to iostat's extended statistics.\n\t* Added support for tickless CPUs in sar and mpstat.\n\t* NLS was not taken into account when mpstat or sar were displaying\n\t  some null statistics. This is now fixed.\n\t* sadc no longer syncs data with its output file contents. It\n\t  put a pain on flash devices as it undermined any tuning of\n\t  the vm's write behavior [DEBIAN Bug#559686].\n\t* NLS updated. Basque translation added.\n\t* iostat, sar and sa1 manual pages updated.\n\t* CREDITS file updated.\n\n2010/02/28: Version 9.1.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Remove support for kernels older than 2.6.x.\n\t* iostat now takes into account POSIXLY_CORRECT environment\n\t  variable. iostat default output for disk utilization is\n\t  expressed in kB/s, unless this variable is set (in which case\n\t  the output is expressed in blocks/s).\n\t* mpstat can now display per processor software interrupts\n\t  statistics. This requires Linux kernel 2.6.31 or later.\n\t* Because of a change in /proc/interrupts file format, mpstat\n\t  was no longer counting the proper number of interrupts. This\n\t  is now fixed.\n\t* Manual pages updated.\n\t* NLS updated.\n\t* Code cleaned.\n\n2009/11/11: Version 9.0.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* \"sadf -x\" now takes into account options -s and -e (which\n\t  specify a starting and ending time) and also interval and\n\t  count parameters [DEBIAN bug#546259].\n\t* Option -C added to sadf. Use it to tell sadf to display comments\n\t  present in file (also works with XML format).\n\t* sar and sadf sometimes didn't handle COMMENT records properly.\n\t  This is now fixed.\n\t* XML output (displayed by sadf -x) modified for kernel tables\n\t  statistics.\n\t* XSD and DTD documents updated.\n\t* [Yibin Shen]: HZ variable was not explicitly set in sadc.c. This\n\t  is now fixed.\n\t* [Lans Carstensen]: sargraph added (sargraph is a shell script\n\t  used to make graphs based on sadf XML output).\n\t* sadf manual page updated.\n\t* FAQ updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2009/09/20: Version 9.0.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sysstat should now be able to pretty print device names whose\n\t  minor numbers are greater than or equal to 256. (Tests have\n\t  been made on a large 26TB RHEL5/PP Linux cluster.)\n\t* sadc manual page updated.\n\t* NLS updated.\n\t* FAQ updated.\n\n2009/07/19: Version 9.0.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Jonathan Kamens]: Fix double free/memory corruption bug\n\t  with sadc.\n\t* [Jeroen Roovers]: Get entirely rid of implicit rule for\n\t  libsyscom.a in Makefile to fix a problem with parallel\n\t  execution.\n\t* sysstat.ioconf configuration file updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2009/05/24: Version 9.0.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Michael Blakeley]: Option -z added to iostat. This option\n\t  tells iostat to omit output for any devices for which there\n\t  was no activity during the sample period.\n\t* [Tomasz Pala]: Fix mpstat where interrupt values should be\n\t  read as unsigned integers.\n\t* sar -n ALL didn't select IPv6 statistics. This is now fixed.\n\t* iostat, sar and mpstat manual pages updated.\n\t* sadf -x now displays file creation date.\n\t* XSD and DTD documents updated.\n\t* NLS updated. Latvian translation added.\n\t* CREDITS file updated.\n\t* Code cleaned.\n\n2009/04/02: Version 9.0.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sadc can now collect partition statistics in addition to disk ones.\n\t  Keywords XDISK and XALL have been added to -S option.\n\t* Fixed a memory corruption in pidstat and iostat. This corruption\n\t  could happen when a list of comma-separated values following\n\t  option -p was entered on the command line.\n\t* configure now takes into account a new variable named rcdir.\n\t  This variable may be used to specify the directory where\n\t  startup scripts will be installed.\n\t* The value of directory for installing documentation files\n\t  can now be set with configure's --docdir option.\n\t* Fixed a small bug in activity.c file, where there was a\n\t  missing semicolon between two fields.\n\t* sar and sadc manual pages updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2009/03/07: Version 9.0.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Fix a crash with sar where a pointer was freed twice.\n\t* NLS updated.\n\t* sar manual page updated.\n\t* CREDITS file updated.\n\n2009/03/01: Version 9.0.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Option -m added to sar. This option is intended to display\n\t  power management statistics. At the present time, only\n\t  CPU frequency statistics are available.\n\t* sadc updated: Option \"-S POWER\" tells sadc to collect power\n\t  management statistics.\n\t* sadf command updated to take into account power management\n\t  statistics.\n\t* [Mike Harvey]: No longer truncate the interval of time to\n\t  32 bits, as this may cause some problems when displaying\n\t  average values statistics on machines with hundreds of CPU.\n\t* read_uptime(): Cast values read from /proc/uptime to\n\t  unsigned long long.\n\t* Fixed a small bug in sar where it didn't parse arguments\n\t  properly when some options were entered in a specific order.\n\t* sadc and sar manual pages updated.\n\t* XSD and DTD documents updated.\n\t* FAQ updated.\n\t* NLS updated.\n\t* Code cleaned. Makefile cleaned.\n\n2009/01/11: Version 8.1.8 - Sebastien Godard (sysstat <at> orange.fr)\n\t* IPv6 support added. A bunch of new metrics have been added to\n\t  sar, enabling the user to display statistics for IPv6 protocol\n\t  family (IPv6, ICMPv6, UDPv6 and network sockets).\n\t* sadc updated: Option \"-S IPV6\" tells sadc to collect IPv6\n\t  statistics.\n\t* sadf command updated to take into account IPv6 statistics.\n\t* Options -S (for sadc), -P (for mpstat, sar and sadf), -p (for\n\t  iostat and pidstat) and -n and -I (for sar) now accept a list of\n\t  comma-separated arguments.\n\t* [Ivana Varekova]: Make iostat display statistics for devices only\n\t  (and not partitions) when not using its option -d. This was\n\t  no longer possible with kernels 2.6.25 and later because iostat\n\t  couldn't distinguish between devices and partitions any more.\n\t* iostat's options -x and -p are no longer mutually exclusive:\n\t  Extended statistics are now available even for partitions with\n\t  recent kernels.\n\t* iostat was unable to read stats from sysfs for devices who had\n\t  a slash in their names (for example, iostat -p /dev/cciss/c0d0\n\t  didn't work properly before). This is now fixed.\n\t* [Amir Rapson]: Fixed a bug in iostat where %CPU spent\n\t  servicing hard and soft irq were counted twice. This bug\n\t  was introduced in 8.1.5.\n\t* DTD and XSD files updated.\n\t* Manual pages updated.\n\t* NLS updated. Maltese translation added.\n\t* CREDITS file updated.\n\n2008/11/13: Version 8.1.7 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Support for SNMP statistics added to sar. Several keywords\n\t  have been added to option \"-n\". The user can now display\n\t  statistics about IP, ICMP, TCP and UDP network traffic.\n\t* sadc updated: Option \"-S SNMP\" tells sadc to collect SNMP\n\t  statistics.\n\t* sadf command updated to take into account SNMP statistics.\n\t* sadf -x now also displays number of CPU.\n\t* DTD and XSD files updated.\n\t* sar/sadc: Each item (like network interfaces) is now counted\n\t  once.\n\t* [Eduardo Ferro Aldama]: Option -l added to pidstat. This\n\t  option enables the user to display the whole command line for\n\t  each process.\n\t* Option -h added to sar. This option displays a short help message.\n\t* Cosmetic change in sadf -x output for network statistics.\n\t* sadf -H now displays the real name of each activity saved in file.\n\t* Fixed some memory leaks detected by valgrind.\n\t* pidstat, sar and sadc manual pages updated.\n\t* FAQ updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\t* Code cleaned.\n\n2008/09/30: Version 8.1.6 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [David Alan Gilbert]: Option -h added to pidstat. This\n\t  option is used to display all activities horizontally on a\n\t  single line.\n\t* Fixed a bug in pidstat: When pidstat was used to monitor a\n\t  process and all its threads (with pidstat's option -t), it\n\t  could display weird values if the thread group leader terminated.\n\t* Header line displayed by sar, iostat, mpstat, pidstat and\n\t  sadf -H now includes the number of CPU.\n\t* Use the correct word TGID instead of PID with pidstat -t.\n\t* mpstat now displays stats for all interrupts, including NMI,\n\t  LOC, etc.\n\t* sar and sadf now check that CPU activity is available in file.\n\t* iostat's option -t now always displays the date and the time.\n\t* Added option \"--disable-documentation\" to ./configure. Using\n\t  this option prevents documentation files (including manual\n\t  pages) from being installed.\n\t* iconfig script updated. Now ask the user for documentation\n\t  and isag script installation.\n\t* Manual pages updated.\n\t* NLS updated. Indonesian and Chinese (traditional) translations\n\t  added.\n\t* README-nls file updated.\n\t* Makefile updated: There is now a dedicated target to install\n\t  or uninstall NLS files\n\t* FAQ updated.\n\t* CREDITS file updated.\n\t* Code cleaned.\n\n2008/07/14: Version 8.1.5 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Added virtual machine time accounting to \"sar -u ALL\" and\n\t  mpstat (%guest).\n\t* pidstat has also been updated to be able to display time\n\t  spent in virtual machine for a task, and for a task and all\n\t  its children.\n\t* Option -S added to sar: This options tells sar to display\n\t  swap space utilization. Option -r now only displays memory\n\t  utilization.\n\t* Added %swpcad to sar -S (percentage of cached swap memory\n\t  in relation to the amount of used swap space).\n\t* Added kbcommit and %commit to sar -r (amount and percentage\n\t  of memory needed for current workload).\n\t* sadf -x now distinguishes between options -r and -R.\n\t* sadf command updated to take into account new fields\n\t  (%guest, %swpcad, etc.)\n\t* [Ivana Varekova]: iostat now displays the total number of\n\t  operations per second in the NFS report.\n\t* Fixed iostat so that %system (percentage of CPU utilization\n\t  that occurred while executing at system level) also takes\n\t  into account time spent to service interrupts and softirqs.\n\t* Added a missing header line for activities with multiple\n\t  outputs displayed by sar (eg. sar -rR ...).\n\t* Makefile updated: There is now a dedicated target to install\n\t  or uninstall manual pages.\n\t* Manual pages updated.\n\t* Code cleaned.\n\t* XSD and DTD documents updated.\n\t* isag script updated.\n\n2008/06/22: Version 8.1.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* sar can now collect and display all CPU fields with its new\n\t  option \"-u ALL\". sadf has also been updated to be able to\n\t  display them.\n\t* mpstat can now display per-CPU interrupts statistics with its\n\t  option \"-I CPU\". This was a feature available in sar that was\n\t  removed in previous sysstat version.\n\t* mpstat uses now a separate option (\"-I SUM\") to display the\n\t  total number of interrupts for each processor.\n\t* Option -A added to mpstat. This switch tells mpstat to display\n\t  all possible activities.\n\t* NFS v4 support added to sar -n NFS(D). When both NFS v3 and\n\t  NFS v4 are used, stats from NFS v3 and NFS v4 are added\n\t  together [DEBIAN bug#434442].\n\t* Code cleaned: mpstat, iostat and pidstat now use the common\n\t  functions from rd_stats.c to read CPU stats from /proc/stat;\n\t  Computing extended disk statistics (service time, etc.) is now\n\t  done in one place (common function used by iostat, sar, sadf).\n\t* All sysstat commands are made consistent with how parameters\n\t  are interpreted: \"COMMAND <interval>\" now generates a report\n\t  continuously, \"COMMAND <interval> 0\" causes an error,\n\t  \"COMMAND 0\" displays a report since system startup\n\t  [DEBIAN bug#475707].\n\t* Changed XML output for processes and context switches displayed\n\t  by sadf -x to be consistent with output from sar.\n\t* mpstat and sar manual pages updated.\n\t* isag script updated.\n\t* FAQ updated.\n\t* DTD and XML Schema updated.\n\t* NLS updated.\n\n2008/05/25: Version 8.1.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2170]\n\t* sar, sadc and sadf heavily modified. It is now easier to add\n\t  (or remove) activities since sar and sadc have been rewritten\n\t  in a non-monolithic way with a generic design architecture.\n\t* Option -c removed from sar. Task creation and context switch\n\t  activities are now merged and available with option -w.\n\t* sar no longer displays interrupts per processor statistics.\n\t  This feature will be included in mpstat in next sysstat version.\n\t* Option -S added to sadc. This option replaces previous options\n\t  -I or -d, and is used to select activities that should be\n\t  collected and saved in file. It is even possible to\n\t  select each activity collected by sadc.\n\t* Format of data files created by sar/sadc heavily modified.\n\t  In some cases, it is now possible to add or remove activities\n\t  while keeping a compatible format that can be read by a previous\n\t  or future sysstat version.\n\t* sadf now only displays activities that have been explicitly\n\t  selected.\n\t* sar now checks that devices displayed by option -d are whole\n\t  devices (and not partitions) using sysstat.ioconf configuration\n\t  file. If this file is not found in its default directory, then\n\t  sysstat looks for it in current directory.\n\t* gettextize entire usage() messages so that translators have\n\t  free scope to act.\n\t* DTD and XML Schema updated.\n\t* Manual pages updated.\n\t* Crontab samples updated.\n\t* FAQ updated.\n\t* Code cleaned.\n\n2008/03/16: Version 8.1.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* [Ivana Varekova]: iostat now displays read and write operations\n\t  per second in the NFS report.\n\t* [Tomas Mraz]: sadc now retries to write its buffers when the\n\t  write() call has been interrupted by a signal.\n\t* Use setbuf() call instead of fflush() to indicate that data\n\t  should not be buffered to stdout.\n\t* Option -h added to sadf. Used with options -d or -D, it\n\t  indicates that all activities should be displayed horizontally\n\t  on a single line of data.\n\t* sadf -d and sadf -D now display the list of fields for easier\n\t  data reading.\n\t* sadf and iostat manual pages updated.\n\t* NLS updated: Chinese (simplified) translation added, other\n\t  translations updated.\n\n2008/02/10: Version 8.1.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x216f]\n\t* System activity data files now have extra header data that\n\t  enable to identify which version of sysstat created them.\n\t* sadf -H now displays the version of sysstat used to create\n\t  a system activity data file.\n\t* Machine architecture is now displayed in the reports header.\n\t  sadf -x also displays machine architecture.\n\t* DTD and XML Schema documents updated.\n\t* The number of processors was not properly calculated on\n\t  machines where a directory named cpuidle was present in the\n\t  /sys/devices/system/cpu directory [GENTOO bug# 207886].\n\t* Use __CPU_SETSIZE definition from <sched.h> instead of a\n\t  static definition for the maximum number of CPUs (NR_CPUS).\n\t* Improved error messages displayed by sysstat's commands.\n\t* NLS updated: Finnish translation added, Dutch translation\n\t  updated.\n\t* FAQ updated.\n\t* Code cleaned and documented. Linux-like style applied to\n\t  code source. Large functions split into smaller ones.\n\n2008/01/06: Version 8.0.4 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Removed a 'packed' attribute in pidstat.h that generated\n\t  a warning with gcc 4.1.1.\n\t* Take account of all memory zone types when calculating\n\t  pgscank, pgscand and pgsteal displayed by sar -B.\n\t* XML Schema added. Useful with sadf option -x.\n\t* sadc and sadf manual pages updated.\n\t* NLS updated: Dutch translation added.\n\t* NLS updated: Brazilian Portuguese translation added.\n\t* NLS updated: Vietnamese translation added.\n\t* NLS updated: Kirghiz translation added.\n\t* NLS updated: Added a PO template file in nls directory.\n\t  Makefile modified to enable PO files update.\n\t* sccsid string now also includes package name and version number.\n\t* Makefile updated: Startup links are named S01xxx instead of S03xxx\n\t  to be consistent with chkconfig values.\n\t* Various spelling fixes.\n\t* CREDITS file updated.\n\n2007/11/19: Version 8.0.3 - Sebastien Godard (sysstat <at> orange.fr)\n\t* mpstat and sar didn't parse /proc/interrupts correctly when\n\t  some CPUs had been disabled. This is now fixed.\n\t* Fixed a bug in pidstat where a confusion between PID and TID\n\t  could sometimes happen, resulting in erroneous statistics\n\t  values being displayed.\n\t* iconfig script updated: Help for --enable-compress-manpg\n\t  parameter is now available, help for --enable-install-cron\n\t  parameter updated, added parameter cron_interval.\n\t* sa2 shell script can now compress sar data files using bzip2.\n\t* Makefile updated: Now also remove sysstat.crond.sample.in.\n\t  Documentation is installed in $prefix/share/doc/ instead of\n\t  $prefix/doc/ directory.\n\t* isag updated.\n\t* FAQ updated.\n\t* CREDITS file updated.\n\t* Sysstat's URL updated.\n\n2007/10/26: Version 8.0.2 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Option -w added to pidstat. pidstat can now display task\n\t  switching activity.\n\t* Fixed a memory leak in pidstat that was triggered when\n\t  reading stats for threads.\n\t* Fixed a bug where device names were incorrectly displayed by\n\t  sar -d or sar -dp. Fixed also this bug for sadf.\n\t* When using option -o, sar now saves by default all the\n\t  statistics into the file, including interrupts and disks\n\t  statistics. Interrupts and disks statistics remain optional\n\t  when using sadc.\n\t* sysstat startup script updated.\n\t* sar and pidstat manual pages updated.\n\t* isag updated.\n\t* NLS updated.\n\t* Code cleaned.\n\t* CREDITS file updated.\n\n2007/09/30: Version 8.0.1 - Sebastien Godard (sysstat <at> orange.fr)\n\t* Option -t added to pistat. pidstat can now display stats for\n\t  every thread (TID) of a process.\n\t* pidstat's option -T CHILD now reports global statistics for\n\t  selected tasks and all their children (and not only for the\n\t  children).\n\t* pidstat now reads VSZ and RSS values from /proc/#/stat instead\n\t  of /proc/#/status.\n\t* Fixed a rare parallel make issue creating archive libsyscom.a\n\t  [GENTOO bug #193208].\n\t* pidstat manual page updated.\n\t* SCCS identification string added to all commands.\n\t* NLS updated.\n\t* Code cleaned.\n\t* CREDITS file updated.\n\n2007/09/02: Version 8.0.0 - Sebastien Godard (sysstat <at> orange.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x216e]\n\t* pidstat command improved. It is now able to report CPU and\n\t  page fault statistics for the child processes of a task.\n\t* Option -T added to pidstat. This option tells pidstat if\n\t  statistics are to be reported for tasks (which is the default)\n\t  or for their children.\n\t* Fixed a security flaw in sysstat startup script (CVE-2007-3852).\n\t* Removed super*, dquot* and rtsig* fields from sar -v.\n\t  They were made obsolete in Linux kernels 2.6.\n\t* Fields file-sz and inode-sz from sar -v renamed to file-nr\n\t  and inode-nr.\n\t* Added field pty-nr (number of pseudo-terminals) to sar -v.\n\t* Added field tcp-tw (number of sockets in TIME_WAIT state)\n\t  to sar -n SOCK.\n\t* sar and sadf updated so that they can properly extract records\n\t  (with their options -s and -e) from a file containing data for\n\t  two consecutive days.\n\t* Added option \"--enable-install-isag\" to \"configure\" to enable\n\t  the user to install isag script.\n\t* Fixed a typo in iconfig script: The user was unable to specify\n\t  the crontab owner.\n\t* Manual pages updated.\n\t* Sysstat DTD file updated.\n\t* isag updated.\n\t* NLS updated.\n\t* FAQ updated.\n\t* CREDITS file updated.\n\t* Author's email updated.\n\n2007/07/08: Version 7.1.6 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x216d]\n\t* New VM paging metrics added to sar (option -B).\n\t* Options -x and -X have been removed from sar. Use pidstat(1)\n\t  command instead.\n\t* NR_CPUS increased to 16384 so that sysstat can be used on\n\t  very large systems.\n\t* Fixed a bug in sadc.c where it was using a hardcoded 256 char\n\t  buffer to store lines read from /proc/interrupts.\n\t* sar updated to avoid overflow when computing some average values.\n\t* sar and mpstat manual pages updated.\n\t* Sysstat DTD file updated.\n\t* FAQ updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2007/06/07: Version 7.1.5 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x216c]\n\t* Option -d added to pidstat: This option reports I/O statistics\n\t  for individual tasks.\n\t* Option -C added to sadc: This option enables the user to insert\n\t  a timestamped comment in the binary data file.\n\t* Option -C added to sar: This option tells sar to display\n\t  comments inserted in the binary data file by sadc.\n\t* sadf updated to display comments.\n\t* Fixed a bug that could happen while reading /proc/interrupts,\n\t  where irq numbers can now be 4 digits long in recent kernels.\n\t* Fixed a possible buffer overflow in ioconf.c.\n\t* Makefile updated: Remove previous manual pages before installing\n\t  new ones.\n\t* pidstat, sar and sadc manual pages updated.\n\t* Sysstat DTD file updated.\n\t* Fixed DTD version in sadf.h.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2007/04/29: Version 7.1.4 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Addition of a new command \"pidstat\" aimed at displaying\n\t  per-process statistics.\n\t* Option -N added to iostat. This option enables the user to\n\t  query any device-mapper devices for their registered device name\n\t  [bugzilla #177540].\n\t* Fixed a small memory leak in readp_uptime() function.\n\t* Typo fixed in configure.in file\n\t  (s+INIT_DIR/etc/rc.d/init.d+INIT_DIR=/etc/rc.d/init.d+).\n\t* Stricter syntax checking for iostat.\n\t* sar -dp now displays the device as \"devM-N\" (instead of \"nodev\")\n\t  when it can't find its real name in sysstat.ioconf file.\n\t* iostat -t now also takes into account the value of environment\n\t  variable S_TIME_FORMAT.\n\t* Manual pages now take into account variables defined by\n\t  \"configure\".\n\t* isag now takes into account variables defined by \"configure\".\n\t* \"configure\" now determines automatically whether workaround for\n\t  SMP race is needed. This workaround is for SMP kernels 2.2.x with\n\t  x <= 15 only.\n\t* pidstat manual page added. Other manual pages updated.\n\t* Makefile updated.\n\t* NLS updated.\n\t* FAQ updated.\n\t* Code cleaned again and again...\n\t* Removed sargon from contrib directory since its features are\n\t  now included in sysstat by default.\n\n2007/03/27: Version 7.1.3 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x216b]\n\t* Hotplug CPU support: Fixed a bug that happened when sar tried\n\t  to read a datafile created while a least one processor was\n\t  disabled.\n\t* Better support for keeping sar logfiles for more than one month\n\t  (several bugs fixed in sa1 and sa2 scripts).\n\t* Fixed a small bug in sa2 script, where obsolete log files would not\n\t  be deleted if system activity directory was a symbolic link to\n\t  some other directory.\n\t* The new variable \"conf_dir\" now enables the user to specify sysstat\n\t  configuration directory. This variable is used by \"configure\".\n\t* Added option \"--enable-compress-manpg\" to \"configure\" to enable the\n\t  user to compress manual pages during installation.\n\t* Removed some 'packed' attributes in sa.h and iostat.h that\n\t  generated warnings with gcc 4.1.1.\n\t* isag (Interactive System Activity Grapher) improved.\n\t* CREDITS file updated.\n\t* Code cleaned.\n\n2007/03/04: Version 7.1.2 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x216a]\n\t* Better hotplug CPU support. Now sysstat no longer assumes that\n\t  CPU#0 can never be disabled. It uses /proc/uptime file to\n\t  compute time interval.\n\t* Various structures realignment to save memory (and disk space).\n\t* Make sar -n display network traffic in kilobytes instead of bytes.\n\t* Make sysstat compile cleanly with gcc 4.0.2.\n\t* sysstat DTD file updated.\n\t* NLS updated: Danish translation added.\n\t* Manual pages updated.\n\t* CREDITS file updated.\n\n2007/02/21: Version 7.1.1 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Autoconf support added.\n\t* iconfig (Interactive Configuration script) added. iconfig is\n\t  a front-end to ./configure.\n\t* spec file updated.\n\t* FAQ updated.\n\t* sadf manual page updated.\n\t* CREDITS file updated.\n\n2007/02/04: Version 7.0.4 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Removed linux/major.h from list of files included in ioconf.c.\n\t  It was actually not used and also prevented sysstat from being\n\t  compiled on GNU/kFreeBSD.\n\t* Sysstat scripts (sa1, sa2, sysstat) modified to enable the user\n\t  to keep sar data for more than one month.\n\t* New parameter (COMPRESSAFTER) added to /etc/sysconfig/sysstat.\n\t  It gives the number of days after which sar datafiles must be\n\t  compressed to save disk space.\n\t* Replaced the word \"Device\" with \"Filesystem\" for iostat\n\t  NFS report.\n\t* iostat manual page updated.\n\t* Makefile updated: don't use a static list of languages to\n\t  compile NLS files.\n\t* \"make install\" now always install sysstat configuration file\n\t  (default location is /etc/sysconfig).\n\t* FAQ updated.\n\t* Added my email address when displaying sysstat version.\n\t* NLS updated.\n\n2006/12/03: Version 7.0.3 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* iostat NFS statistics added.\n\t* iostat manual page updated.\n\t* Columns \"r/s\" and \"w/s\" enlarged for iostat -x.\n\t* Minor change so that sar -u may fit in 80 columns.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2006/10/22: Version 7.0.2 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Hotplug CPU support added to sar and mpstat \n\t* Use /sys to count the number of available processors.\n\t  /proc/stat is used for that only if /sys is not found.\n\t* sysstat DTD updated.\n\t* sysstat spec file updated (gettext is now required).\n\t* NLS updated: Swedish translation added.\n\t* Manual pages updated.\n\t* Makefile updated.\n\t* CREDITS file updated.\n\n2006/09/17: Version 7.0.1 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Use now sysconf() function to get the size of a memory page\n\t  instead of using header file <asm/page.h>.\n\t* The time specified with sadf options -s and -e is now always\n\t  considered as given in local time. sadf output is now\treally\n\t  consistent with that of sar.\n\t* Fixed a bug in the SREALLOC() macro which was causing sar to\n\t  exit unexpectedly with this message: \"realloc: Success\".\n\t* Try to better guess when a stats title line has to be displayed\n\t  by sar.\n\t* Makefile updated (SMP_RACE definition was no longer taken into\n\t  account when compiling sadc).\n\t* sysstat spec file updated.\n\t* sar and sadf manual pages updated.\n\t* FAQ updated.\n\t* CREDITS file updated.\n\n2006/07/09: Version 7.0.0 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* S_TIME_DEF_TIME environment variable added for sar, sadc and\n\t  sadf.\n\t* Use now sysconf() function to get the number of clock ticks\n\t  per second (HZ value) instead of using kernel include file\n\t  <sys/param.h>.\n\t* Columns \"Device\", \"rrqm/s\" and \"wrqm/s\" enlarged for iostat -x.\n\t* sysstat installation process updated to use chkconfig if\n\t  available.\n\t* Manual pages updated.\n\t* Makefile updated.\n\t* sysstat web site address updated.\n\t* Code cleaned.\n\t* CREDITS file updated.\n\n2006/05/24: Version 6.1.3 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2169]\n\t* Option -P can now be used with sar even on SMP machines where\n\t  only one processor is available.\n\t* Small bug fixed for mpstat, where explicitly specifying\n\t  processor 0 (\"-P 0\") could lead to incorrect output on UP\n\t  machines.\n\t* Option -D added to sadf: this option displays the contents of\n\t  a data file in a database-friendly format with a timestamp\n\t  expressed in seconds from the epoch.\n\t* sadf manual page updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\n2006/04/23: Version 6.1.2 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Fix incorrect NFS client and server statistics for sar.\n\t* sar can now display stats for newly created processes when\n\t  option -x ALL or -X ALL is used.\n\t* iostat -x was displaying redundant information. It now\n\t  displays amount of data read from or written to devices in\n\t  sectors, kilobytes or megabytes depending on the switch used.\n\t* isag updated to keep up with current sar version.\n\t* sar and mpstat manual pages updated.\n\t* FAQ updated.\n\n2006/02/22: Version 6.1.1 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2168]\n\t* New field added to sar: %steal.\n\t* The size of a long integer in now saved in the header of the\n\t  data file created by sar. This size can be displayed with\n\t  sadf -H.\n\t* Replaced the keyword \"FULL\" by the keyword \"ALL\" for sar -n\n\t  to be consistent with remaining options.\n\t* Makefile updated (use implicit rules).\n\t* sar manual page updated.\n\t* CREDITS and FAQ files updated.\n\n2005/11/28: Version 6.0.2 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* New field added to mpstat and iostat: %steal.\n\t* sar updated to take into account cpu steal time.\n\t* Off-by-one error in ioc_conv which was corrupting device names\n\t  on 64-bit architecture [Debian bug #334305].\n\t* Binary RPM package now installs a sample crontab in /etc/cron.d.\n\t* Makefile updated (remove sysstat.cron.* during make clean -\n\t  new target added: sysstat.crond.sample).\n\t* sar now checks exit code from dup2() system calls.\n\t* Option -V now only displays sysstat version number.\n\t* NLS updated.\n\t* FAQ updated.\n\t* Manual pages updated.\n\n2005/06/25: Version 6.0.1 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Fixed a memory leak in ioconf parsing functions used by sar\n\t  and iostat.\n\t* sar now displays its statistics to STDOUT in addition to saving\n\t  them into the file when option -o has been entered on the\n\t  command line.\n\t* sar now recalculates number of system items (network interfaces,\n\t  disks, serial lines, etc.) when a file rotation happens.\n\t* Make sar -b work again when used without option -d.\n\t* Small changes so that sysstat can be compiled with gcc-4.0.1.\n\t* sysstat updated so that it may be installed on Slackware.\n\t* sar manual page updated.\n\t* CREDITS file updated.\n\t* Code cleaned.\n\n2005/05/14: Version 6.0.0 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2167]\n\t* Additional fields added to sar -y (TTY statistics). sar, sadf\n\t  and DTD updated.\n\t* sar -d now only reports for used devices (devices with non zero\n\t  statistics).\n\t* Stricter sadf syntax checking: various output formats are now\n\t  mutually exclusive.\n\t* Stricter iostat syntax checking: -k and -m options are now\n\t  mutually exclusive.\n\t* iostat: option -m is now taken into account even when\n\t  displaying extended statistics.\n\t* Fixed a bug that prevented iostat from displaying stats about\n\t  devices that were unknown in sysstat.ioconf file.\n\t* iostat might display bogus sectors values when the corresponding\n\t  kernel counters had overflown. This is now fixed.\n\t* \"sadf datafile -- -A\" should also display individual interrupts\n\t  if available in datafile.\n\t* Fixed a bug that prevented sar -x from displaying stats about a\n\t  process if it was after the first 256 processes in the process\n\t  list.\n\t* Manual pages updated.\n\t* sa1 script always uses option -d in crontab.\n\t* sysstat.ioconf device configuration file updated.\n\t* NLS updated.\n\t* FAQ and CREDITS files updated.\n\t* Code cleaned.\n\n2005/02/25: Version 5.1.5 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* -x option added to sadf: it is now able to display the contents of\n\t  a sar datafile in XML. The corresponding DTD (Document Type\n\t  Definition) is included in the sysstat package.\n\t* Small code change so that sysstat may be compiled with gcc-4.0.\n\t* A few typos fixed in formulas used by sadf to display stats \n\t  on machines where HZ<>100 (typos appeared in sysstat 5.1.4).\n\t* Fixed a bug in the stats displayed by sar -d.\n\t* Removed a false workaround in iostat: better show that the kernel\n\t  is buggy rather than display a value that seems correct but which\n\t  is actually not...\n\t* Fixed sar -i option which might not select records at the specified\n\t  interval on machines with multiple processors.\n\t* NLS updated and cleaned. Do no longer translate fields names (sar,\n\t  iostat, etc.). Changed nb_NO.po and nn_NO.po files to nb.po and\n\t  nn.po.\n\t* Bug fixed in spec file: when installing sysstat i586 RPM package,\n\t  sa1 and sa2 scripts were pointing to the wrong sadc location.\n\t* Now sar and sadc display the magic number when they meet an\n\t  invalid system activity file.\n\t* sadf manual page updated.\n\t* sysstat RPM spec file is now included in source package.\n\t* Code cleaned.\n\t* FAQ, Makefile and CREDITS files updated.\n\n2005/01/02: Version 5.1.4 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2166]\n\t* NFS client and server statistics added to sar.\n\t* sar -d now only reads stats for devices (and not partitions)\n\t  from /proc/partitions. (This is what it was already doing with\n\t  /proc/diskstats).\n\t* Display routines from sadf merged, so that -ppc and -db\n\t  always output the same values.\n\t* sadf updated to handle NFS statistics.\n\t* sadf can now display the header of a data file (option -H).\n\t* Define MAX_BLKDEV in ioconf.h if non-existent in <linux/major.h>.\n\t* sar now looks for sadc in one directory only, specified at\n\t  compile time. Moreover it is now possible to have two different\n\t  sysstat versions installed: sar knows where its sadc counterpart\n\t  is located.\n\t* sapath.in removed. SADC_PATH is defined in CONFIG file.\n\t* sar and sadf manual pages updated.\n\t* sysstat.ioconf file updated.\n\t* Fixed a bug in i386 RPM package, where sadc location was not\n\t  consistent with that of sar. Spec file updated.\n\t* Makefile updated.\n\t* NLS updated.\n\t* Various cosmetic changes (code and manual pages). Code cleaned.\n\t* FAQ and CREDITS files updated.\n\n2004/11/22: Version 5.1.3 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2165]\n\t* Option -p added to sar: It enables sar (and also sadf) to\n\t  display device names as they appear in /dev.\n\t* sysstat.ioconf support added.\n\t* New fields added to sar -d (more disk activities displayed):\n\t  avgrq-sz, avgqu-sz, await, svctm, %util.\n\t* sadf updated to handle new disk activities.\n\t* I/O and transfer rate statistics as displayed by sar -b are\n\t  available whatever the version of the kernel is (i.e. even on\n\t  recent kernels).\n\t* Disk stats are read by sadc from /proc/stat only if they cannot\n\t  be read from /proc/{partitions,diskstats}.\n\t* sadc: Some variables declarations moved around.\n\t* sar manual page updated.\n\t* Added workaround for EMC PowerPath driver bug to enable iostat\n\t  to display proper device name.\n\t* Makefile updated: Use $@ and $< everywhere; 'make {iostat,mpstat}'\n\t  work again; Create object files before linking; Removed unused\n\t  IOS_DFLAGS variable; Use DESTDIR variable everywhere; Create\n\t  libsysioc.a; Install sysstat.ioconf.\n\t* NLS updated.\n\t* README and CREDITS files updated.\n\n2004/11/05: Version 5.1.2 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* sar -d now also uses /proc/partitions to get its data.\n\t  From now on sar -d looks in the following files in that order:\n\t  /proc/diskstats, /proc/partitions, /proc/stat.\n\t* sadc writes disks data to file only if -d option is explicitly\n\t  set on the command line.\n\t* sadc now reads individual interrupts data from /proc/stat only\n\t  if -I option was entered on the command line.\n\t* 'sar -A' is now equivalent to 'sar -bBcdqrRuvwWy -I SUM -I XALL\n\t  -n FULL -P ALL' (i.e. individual interrupts are also included\n\t  in activities).\n\t* Option -m now tells iostat to display statistics in megabytes\n\t  per second instead of blocks per second.\n\t* Make history (number of days to keep log files) configurable\n\t  in /etc/sysconfig/sysstat file, which is used by sa2 script.\n\t* Now use Vixie cron to launch sadc when possible.\n\t* sadc, sa1 and sa2 may now be installed in another directory\n\t  than ${PREFIX}/lib/sa. This is useful on 64-bit systems where\n\t  the proper directory should be ${PREFIX}/lib64/sa.\n\t* When uninstalling sysstat, always delete sysstat script,\n\t  config file and links in /etc tree. Also always delete\n\t  Vixie cron entry.\n\t* sysstat script now returns real exit code.\n\t* sar/sadc: Stricter syntax checking for -x and -X options use.\n\t* sysstat \"*.sh\" files renamed in \"*.in\".\n\t* Makefile updated.\n\t* sadc and sar manual pages updated.\n\t* NLS updated.\n\t* FAQ updated.\n\t* CREDITS and README files updated.\n\n2004/10/09: Version 5.1.1 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2164]\n\t* sar now reads CPU data, number of context switches, number\n\t  of sectors and total number of interrupts as 64-bit unsigned\n\t  values. It also reads the number of running processes as\n\t  unsigned long instead of unsigned int.\n\t* sadf - System activity data formatter command added.\n\t* Options -h and -H removed from sar. \"sar -h\" is replaced by\n\t  \"sadf -p\", and \"sar -H\" is replaced by \"sadf -d\". Read sadf\n\t  manual page, as its syntax is a bit different from that of sar.\n\t* Common code for sar and sadf moved to sa_common.c file.\n\t* pid_stats members don't need to be aligned since these stats\n\t  are not written to daily data files. Packing them saves some\n\t  memory on 32-bit architectures.\n\t* No longer indicate that -x and -X are possible options for sadc.\n\t  They are only useful when used as options for sar, not sadc.\n\t* Minor buffer overrun fixed in iostat.\n\t* Updated CPU header for iostat and mpstat: CPU used while executing\n\t  at the system level is displayed as '%system' by iostat (like sar)\n\t  and as '%sys' by mpstat.\n\t* sadf manual page added. Other manual pages updated.\n\t* Updated the GPL notices (the address of the FSF was wrong).\n\t* Makefile updated.\n\t* NLS updated.\n\t* README, FAQ and CREDITS files updated.\n\n2004/08/09: Version 5.0.6 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* The value for file-sz reported by sar -v was a number of free\n\t  handles, and not a number of used ones! This is now fixed (and\n\t  this is really now a number of _used_ file handles).\n\t* Now ask during config stage for the directory where sadc will\n\t  be located. This may be useful for some systems where sadc\n\t  needs to be installed in a specific location (e.g. on 64 bit\n\t  s390 systems, the proper directory should be /usr/lib64/sa).\n\t* sa1 script updated: Use '-' to specify current daily data file\n\t  instead of guessing its name using current date.\n\t* NLS updated: be consistent with GNU gettext standards.\n\t* iostat manual page updated.\n\t* FAQ updated.\n\t* Makefile updated.\n\t* CREDITS file updated.\n\n2004/06/08: Version 5.0.5 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* Timestamp is no longer limited to 11 characters. This should\n\t  avoid problems with somes locales (for example Japanese locale,\n\t  where 'mojibake' used to be displayed by sar and mpstat sometimes).\n\t* Fixed a bug in sysstat RPM spec file (symlinks to sysstat\n\t  script were wrong in /etc/rc.d directories).\n\t* sar now checks parameters for options -n, -s and -e more\n\t  aggressively.\n\t* NLS updated: Japanese translation added.\n\t* Various typos fixed in several files (manual pages, README, etc.)\n\t* CREDITS file updated.\n\n2004/05/20: Version 5.0.4 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* When trying to lock file, sadc now checks for both EWOULDBLOCK\n\t  and EAGAIN error codes to be portable.\n\t* sar could sometimes display a line whose time stamp was greater\n\t  than the limit set by -e option. This is no longer possible.\n\t* The sadc command in sysstat.sh script had to be enclosed in\n\t  quotes to work when called via 'su -c'.\n\t* The sysstat.sh script was sending the output of sadc command\n\t  to stdout instead of the standard system activity file. This\n\t  is now fixed.\n\t* Outfile must now be explicitly set to \"-\" for sadc to use the\n\t  standard system activity file.\n\t* FAQ updated.\n\t* iostat manual page updated. Typo fixed in sadc manual page.\n\t* Fixed the \"Save picture\" option of isag script.\n\n2004/04/07: Version 5.0.3 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* iostat now reads the number of sectors in /proc/diskstats or\n\t  from sysfs as 64-bit unsigned values.\n\t* iostat and mpstat now read CPU data and the number of\n\t  interrupts in /proc/stat as 64-bit unsigned values.\n\t* sar uses \"%u\" instead of \"%d\" to read unsigned integer\n\t  values _everywhere_.\n\t* sar and sadc are now a little bit more verbose when dealing\n\t  with invalid activity files.\n\t* Network interface name size is now read from include file\n\t  <net/if.h>.\n\t* FAQ polished up.\n\t* Slovak translation added. NLS updated.\n\t* Typo fixed in iostat manual page.\n\t* Makefile and CREDITS file updated.\n\t* isag upgraded to version 1.26 (isag package release 0.81.0).\n\n2004/03/10: Version 5.0.2 - Sebastien Godard (sysstat <at> wanadoo.fr)\n\t* iostat will _again_ look for statistics in /proc/partitions if\n\t  available. Too many production servers are still using 2.2.x or\n\t  2.4.x kernels and iostat must be able to display extended stats\n\t  also for them (/proc/partitions support was removed in sysstat\n\t  version 4.1.3). So now, iostat gets its statistics from the\n\t  following sources in that order: /proc/diskstats, sysfs,\n\t  /proc/partitions and then /proc/stat.\n\t* statistics are now read by iostat and mpstat as unsigned long\n\t  instead of int to avoid integer overflow.\n\t* iostat should now handle properly the case when the 'weighted\n\t  number of milliseconds spent doing I/Os' (read in sysfs or\n\t  /proc/{partitions,diskstats}) decreases with time.\n\t* iostat manual page updated.\n\t* Minor temporary file vulnerability fixed in isag command.\n\t* README, FAQ and CREDITS files updated.\n\t* Author's email changed.\n\n2004/02/02: Version 5.0.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* -L option added to sadc. Enable sadc to lock its output file\n\t  to prevent multiple instances from writing to it at once.\n\t* sa1 and sysstat scripts updated to take advantage of -L option.\n\t* Handle the case where, under very special circumstances, STDOUT\n\t  may become unavailable, and sar, iostat and mpstat are no longer\n\t  able to display anything.\n\t* sadc as called in sysstat script also uses -F option to force\n\t  the creation of daily data file.\n\t* sar, sadc and mpstat manual pages updated.\n\t* Code cleaned.\n\t* FAQ and CREDITS files updated.\n\n2003/11/09: Version 5.0.0 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* New fields added to mpstat: %irq (%time spent servicing\n\t  interrupts) and %soft (%time spent servicing softirqs).\n\t* sar and iostat updated to take into account time spent servicing\n\t  interrupts and softirqs when displaying percentage of time\n\t  in system mode.\n\t* By default iostat now displays only statistics information for\n\t  devices that are used by the system. You should now use the ALL\n\t  keyword to tell iostat to display statistics for every device\n\t  including those that have never been used.\n\t* The file version.h is now dynamically created. sysstat's version\n\t  number is now only recorded in the Makefile.\n\t* sar manual page updated: beginning with kernels 2.4 and later,\n\t  pgpgin and pgpgout statistics are in kilobytes and not in\n\t  blocks (see linux-2.4/fs/proc/proc_misc.c and\n\t  linux-2.6/mm/page_alloc.c).\n\t* iostat and mpstat manual pages updated.\n\t* Makefile updated: don't process NLS files if they are up-to-date.\n\t* sysstat's RPM spec file updated to enable clean, non-root builds.\n\t* NLS updated.\n\t* FAQ and CREDITS files updated.\n\n2003/09/28: Version 4.1.7 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2163]\n\t* /proc/diskstats is now the preferred source for iostat to get its\n\t  statistics. If non-existent, iostat falls back on sysfs then\n\t  on /proc/stat.\n\t* In addition to devices, partitions can also be entered on the\n\t  command line for iostat providing that option -x is not used.\n\t* /dev prefix has been removed from device name displayed by iostat -x.\n\t* sar -d now looks for disks statistics in /proc/diskstats with\n\t  post 2.5 kernels.\n\t* sar uses /proc/vmstat file with post 2.5 kernels to find paging\n\t  and swapping statistics.\n\t* activepg, inadtypg, inaclnpg and inatarpg stats removed from\n\t  sar -B report (they were not really useful).\n\t* sar -B now displays the number of page faults made by the system\n\t  (pgfault/s and pgmajflt/s).\n\t* Stat on shared memory removed from sar -r and sar -R (this stat\n\t  was no longer maintained by the kernel since 2.4 because of\n\t  performance problems).\n\t* Cached swap statistic information added to sar -r.\n\t* sar -d now displays separate statistics for sectors that are\n\t  read from or written to devices.\n\t* %file-sz (percentage of used file handles) is no longer displayed\n\t  by sar -v, since the upper limit for the number of open files\n\t  will self-scale with 2.6 kernels.\n\t* sar now looks more aggressively for network devices in /proc/net/dev.\n\t* Heading spaces in network interface names removed (sar -n).\n\t* Fixed a problem reading /proc/interrupts when there are a lot\n\t  of CPUs (mpstat, sadc).\n\t* NR_IRQS value increased to 256, since IA64 supports 256 irqs\n\t  per CPU.\n\t* Some stats counters are now read as unsigned long instead of\n\t  unsigned int (pgpgin, pgpgout, pswpin, pswpout, irq_sum).\n\t* sar and iostat manual pages updated.\n\t* FAQ, README and CREDITS files updated.\n\t* NLS updated.\n\n2003/08/20: Version 4.1.6 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! [0x2162]\n\t* Machine uptime calculation is now optimized on SMP machines\n\t  to minimize the consequences if an overflow condition happens.\n\t  Especially useful when asking for stats since system boot.\n\t* -F option added to sadc. Useful to force the creation of the\n\t  daily data file: an already existing file with a wrong format\n\t  will be truncated by sadc if this option is used.\n\t* sa1 script now calls sadc with -F option.\n\t* The processor number to which the process is attached was no\n\t  longer displayed by sar -x. Make it appear again.\n\t* CPU usage for processes, as displayed by sar -x and sar -X, should\n\t  now be correct on machines where HZ <> 100 (e.g. IA64 architecture).\n\t* iostat still assumed that jiffies were 100ths of a second in some\n\t  places. Now use Linux HZ definition *everywhere*.\n\t* The average I/O requests queue length as displayed by iostat -x was\n\t  wrongly calculated. This is now fixed.\n\t* Manual pages updated.\n\t* NLS updated.\n\t* Cosmetic changes in various parts of the code.\n\t* FAQ, README and CREDITS files updated.\n\n2003/07/21: Version 4.1.5 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! Delete existing data files\n\t  in /var/log/sa directory! [0x2161]\n\t* 'sar -x <pid>' and 'sar -X <pid>' work again.\n\t* sar had a longstanding bug that prevented option -P from\n\t  working properly if the machine had more than 32 processors.\n\t  This is now fixed.\n\t* Fixed a bug introduced in 4.1.2, which made some LINUX RESTART\n\t  messages to not be displayed by sar.\n\t* sar now uses bitmap of char instead of int to avoid endianness\n\t  problems.\n\t* sar can now handle a huge number of processors, serial lines and\n\t  network interfaces.\n\t* FAQ updated.\n\n2003/07/01: Version 4.1.4 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! Delete existing data files\n\t  in /var/log/sa directory! [0x2160]\n\t* Fixed the way overflow conditions were handled by sar for\n\t  interfaces counters.\n\t* On really big machines with 100 GB of memory or more, the values\n\t  read by sadc in /proc/meminfo would get truncated and cause havoc\n\t  in the calculations. This is now fixed.\n\t* iostat and sar can now read many more disk entries in /proc/stat if\n\t  necessary.\n\t* Option \"-x SUM\" removed for sar. It was used to tell sar to display\n\t  the total number of minor and major faults made by the system.\n\t  Unfortunately, the calculation was tricky, and the results were\n\t  uncertain...\n\t* NLS updated. Polish translation added. Also proper charset and\n\t  encoding declarations added to fix msgfmt warnings and allow\n\t  gettext to recode between various charsets (e.g. German\n\t  translation will be shown properly both with\n\t  LANG=de_DE.ISO-8859-1, and LANG=de_DE.UTF-8)\n\t* Code 'sanitization'.\n\t* Manual pages updated.\n\t* README and FAQ files updated.\n\n2003/05/08: Version 4.1.3 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* iostat should now be fully 2.5/2.6 kernel compliant.\n\t* Disks arrays in iostat are now dynamically sized.\n\t* iostat: sysfs is now used in preference to /proc/stat if available.\n\t* iostat will no longer look for statistics in /proc/partitions.\n\t  sysfs filesystem must now be available for iostat to get its\n\t  extended stats (post 2.5 kernels).\n\t* iostat: Devices for which statistics are requested can now be entered\n\t  on the command line even if option -x is not used.\n\t* Usage messages updated.\n\t* Manual pages updated.\n\t* Code cleaned (dk_drive_sum removed in iostat, long lines folded,\n\t  functions split in smaller parts, etc.)\n\t* NLS updated. Romanian translation added.\n\t* isag upgraded to version 1.22.\n\n2003/01/24: Version 4.1.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! Delete existing data files\n\t  in /var/log/sa directory! [0x215f]\n\t* sar -q now also displays load average for the past 15 minutes.\n\t* -P option added to sar. This option enables sar to display\n\t  stats on a per processor basis. Options -U and '-I PROC' are\n\t  deprecated. 'sar -U ALL' is replaced by 'sar -u -P ALL', and\n\t  'sar -I PROC' by 'sar -I SUM -P ALL'.\n\t* Fixed iowait value displayed by sar on SMP machines with pre 2.5\n\t  kernels.\n\t* When displaying CPU utilization on SMP machines, sar now\n\t  recalculates the interval based on current CPU's tick count.\n\t* Always check that the number of CPUs has not increased when\n\t  reading /proc/stat (sadc, mpstat).\n\t* sadc: Don't assume that the first line in /proc/net/sockstat\n\t  concerns sockets. Check it!\n\t* Serial lines are ignored by sadc for every kind of kernels\n\t  (UP, SMP...) if SMP_RACE is defined.\n\t  SMP_RACE is no longer defined by default in RPM packages.\n\t* Code cleaned: Dead code removed in iostat.c, some lines longer\n\t  than 80 chars folded, etc.\n\t* sar manual page updated.\n\t* FAQ updated.\n\t* NLS updated.\n\n2003/01/02: Version 4.1.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! Delete existing data files\n\t  in /var/log/sa directory! [0x215e]\n\t* sar -u/-U, iostat and mpstat can now display time spent in\n\t  I/O wait mode (with 2.5 kernels and above).\n\t* Values like -1 and -2 are no longer aliases for keywords\n\t  ALL and XALL (sar -U, sar -I, mpstat -P).\n\t* Buglet fixed in iostat.h.\n\t* LC_CTYPE needs to be set, or it will emit messages with ?????? only\n\t  on some locales, especially ja_JP.eucJP\n\t* sar, mpstat and iostat manual pages updated.\n\t* NLS updated.\n\t* CREDITS file updated.\n\t* Typo removed in FAQ file.\n\n2002/11/13: Version 4.0.7 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Make data for timestamp 00:00:00 appear in one of the daily data\n\t  files when sar/sadc rotates its output file.\n\t* Take out check for non SMP configuration when asking for\n\t  mpstat -P.\n\t* sargon script updated.\n\t* FAQ updated.\n\n2002/08/04: Version 4.0.6 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* mpstat now uses a bitmap of char instead of int to avoid endianness\n\t  problems. As a consequence, mpstat should now work on PowerMac\n\t  architectures.\n\t* CPU activity as displayed by mpstat -P for a given processor was\n\t  in a wrong range on SMP machines (e.g. 0-50% for a dual processor\n\t  box).\n\t* Missing bitmap initialization fixed in mpstat.c.\n\t* Configuration script updated.\n\t* FAQ updated.\n\n2002/05/12: Version 4.0.5 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Average wait times and service times as displayed by iostat -x\n\t  were wrong by a factor of 10. This is now fixed.\n\t* Linux RESTART messages must now be in the interval specified by\n\t  -s/-e options to be displayed by sar.\n\t* Fixed a small bug that affected the timestamp for RESTART messages\n\t  displayed by sar -h when option -t was used.\n\t* sar -H now displays its data in local time instead of UTC when\n\t  option -t is used.\n\t* sargon shell script added.\n\t* Created a contrib directory, including sargon and isag commands.\n\t* NLS updated.\n\t* FAQ updated.\n\t* Makefile updated.\n\t* sar manual page updated.\n\n2002/04/07: Version 4.0.4 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* iostat is now able to display I/O activity in kB/s with 2.4.x\n\t  kernels (option -k).\n\t* Fixed a typo in 'sar -W -h' output.\n\t* Try to handle the case when some parameters in /proc/net/dev\n\t  may overflow ULONG_MAX.\n\t* 'sar -d' now displays sectors per second instead of blocks\n\t  per second.\n\t* iostat and sar manual pages updated.\n\t* Added a FAQ.\n\t* NLS updated: Russian translation added.\n\n2002/01/27: Version 4.0.3 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* iostat now displays statistics in kB/s when option -x is used.\n\t* Configuration script updated.\n\t* sar and iostat manual pages updated.\n\t* umask also set in sa1 shell script.\n\t* Various sanity checks added.\n\t* Fixed potential segmentation faults that could happen with some\n\t  locales.\n\t* KB (standing for kilobytes) replaced with kB in various places.\n\t* NLS updated: Italian translation added.\n\n2001/09/22: Version 4.0.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* CPU usage, as displayed by iostat, mpstat and sar, should now\n\t  be OK on machines where HZ <> 100 (e.g. IA64 architecture).\n\t* MAX_PART constant set to 256 in iostat.h.\n\t* \"-H\" database friendly option added to sar.\n\t* Better disks and network interfaces management (both may be\n\t  registered dynamically).\n\t* Made options \"-s\" and \"-e\" work when option \"-h\" is used.\n\t* isag upgraded to version 1.17.\n\t* isag installation is now optional and can be chosen at config stage.\n\t* Now try to install man pages in ${PREFIX}/share/man instead of\n\t  ${PREFIX}/man.\n\t* sa2 shell script updated.\n\t* Configuration script updated.\n\t* sar manual page updated.\n\t* NLS updated: Norwegian translation added.\n\n2001/06/24: Version 4.0.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Files created by sa2 shell script were world writable. This is\n\t  now fixed.\n\t* sa2.sh shell script updated: only remove sa?? and sar?? files.\n\t* Don't use PAGE_SHIFT since it no longer necessarily exists in\n\t  <asm/page.h>. Compute it using page size instead.\n\t* Cosmetic changes for iostat.\n\t* NLS updated: Afrikaans translation added.\n\n2001/04/08: Version 4.0.0 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Better network interfaces handling. Now take into account the\n\t  fact that they may be registered/unregistered dynamically.\n\t* Changed formula used to display statistics in order to avoid\n\t  overflow conditions.\n\t* Fixed a bug in iostat, where the %util value scaled incorrectly.\n\t* Better long file names management by iostat.\n\t* mpstat and sar no longer periodically display the title line when\n\t  stdout has been redirected to a pipe or a file.\n\t* sa2.sh shell script updated: Now exec sadc.\n\t* Configuration script updated.\n\t* NLS updated.\n\t* Makefile updated.\n\t* Manual pages updated.\n\t* isag command updated.\n\n2001/03/04: Version 3.3.6 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! Delete existing data files\n\t  in /var/log/sa directory! [0x215d]\n\t* New paging statistics added (sar -B). Kernel 2.4 only.\n\t* Load averages and queue length statistics added (option -q for sar).\n\t* Per device statistics added (option -d for sar). Kernel 2.4 only.\n\t* Better accuracy when computing average for some statistics.\n\t* Display all the contents of a daily data file when the count\n\t  parameter is not given on the command line.\n\t* Check sar command line options more aggressively.\n\t* iostat no longer freezes if -c and -d options are used together.\n\t* Fixed a bug that prevented iostat from displaying more than an\n\t  average of three devices with 2.4 kernels (a buffer was too small).\n\t* Check added to ensure that sar and sadc commands are consistent.\n\t* sar manual page updated.\n\t* NLS updated.\n\t* Code cleaned (use smaller subroutines).\n\t* Makefile updated.\n\t* isag command updates.\n\n2001/02/11: Version 3.3.5 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* iostat command improved. Take now full advantage of Stephen\n\t  Tweedie's I/O accounting patch to display extended statistics\n\t  (option -x).\n\t* The default value for the count parameter of the sar command is\n\t  now 1 (this is how sar works with other Un*xes...). A value of\n\t  0 will indicate that reports are to be generated continuously.\n\t* Code cleaned: Now always use 'double' numbers instead of the\n\t  INT_PART, INT_VAL, DEC_PART and DEC_VAL macros.\n\t* Don't assume that jiffies are 100ths of a second. Use Linux\n\t  HZ definition instead.\n\t* NLS updated (small fix).\n\t* sar and iostat manual pages updated.\n\t* isag (Interactive System Activity Graph) command added.\n\t* Makefile updated.\n\n2001/01/26: Version 3.3.4 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Disk I/O statistics for the last device were counted twice when\n\t  reading /proc/stat file with 2.4 kernels (sar -b). This is now\n\t  fixed.\n\t* iostat command is no longer able to save its data to a file.\n\t  In fact, iostat has never been supposed to work that way, and I\n\t  have never really maintained this option.\n\t* iostat now also works with 2.4 kernels. It can handle the format\n\t  of the /proc/stat file for both 2.2 and 2.4 kernels.\n\t* sar now reports statistics on allocated disk quotas entries\n\t  instead of on used ones (sar -v).\n\t* Manual pages updated for sar and iostat.\n\n2000/12/31: Version 3.3.3 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one! Delete existing data files\n\t  in /var/log/sa directory!\n\t* Disk usage displayed by iostat on SMP machines was wrong. This\n\t  is now fixed.\n\t* iostat command cleaned: All the statistics not implemented in\n\t  the standard Linux kernel have been removed (tty, iowait...).\n\t* sar can now handle I/O and transfer rate statistics with both\n\t  2.2.x and 2.4.x Linux kernels (-b option).\n\t* Removed %inode-sz that was displayed by sar -v, since the file\n\t  inode-max in /proc/sys/fs no longer exists in Linux 2.4.\n\t  The new 2.4.x kernels now seem to be able to allocate inode\n\t  structures dynamically, and to free them when necessary (see\n\t  linux/fs/inode.c).\n\t* Removed statistics on highest in-used sockets. Relevant\n\t  counters have disappeared from sockstat file in /proc/net\n\t  for 2.4 kernels (sar -n SOCK).\n\t* Added statistics on IP datagram fragments (sar -n SOCK).\n\t  Only available for 2.4 kernels.\n\n2000/11/19: Version 3.3.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* sar now saves timestamps in its daily data files both in UST\n\t  and in the user's timezone formats.\n\t  WARNING: Daily data files format has changed, and is *not*\n\t  compatible with the previous one!\n\t* sar now displays timestamps in locale time when reading data\n\t  from its daily data files. -t option has been added to sar,\n\t  to enable it to display timestamps in the original locale\n\t  time of the data file creator.\n\t* Size of various buffers made larger.\n\t* Number of interrupts per second for 'all' CPU displayed by the\n\t  mpstat command was wrong. This is now fixed.\n\t* Makefile updated.\n\t* Usage message updated.\n\n2000/09/17: Version 3.3.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* mpstat command added.\n\t* Manual page added for mpstat.\n\t* Option -h added, enabling sar to display data from a daily data\n\t  file in a format that can easily be handled with pattern\n\t  processing commands like awk.\n\t* Manual page updated for sar.\n\t* iostat now writes KB (for kilobytes) instead of Kb, which could\n\t  have been interpreted as kilobits...\n\t* Disk accounting patch for iostat removed.\n\t* NLS updated.\n\n2000/08/06: Version 3.2.4 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Fixed a bug that prevented sar from reading its daily data files\n\t  when they had been created using -I option.\n\t* Network statistics averages were sometimes wrong when reading\n\t  data from a file. This is now fixed.\n\t* README-patch file updated.\n\t* Configuration script updated to deal with Debian directories.\n\n2000/06/25: Version 3.2.3 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Configuration scripts updated. Can now print a help message.\n\t* Workaround for SMP race in Linux serial driver added.\n\t  This workaround is enabled by default in RPM binary packages.\n\t* sar manual page updated.\n\t* Added iostat disk accounting patch against 2.2.16 linux kernel.\n\t* Removed a few typos in the comments of the source code.\n\n2000/06/11: Version 3.2.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Now handle interrupts per processor better. Output improved.\n\t* Makefile modified to comply with redhat good packaging.\n\t* sysstat initialization script updated (don't su to root when\n\t  we are already root).\n\t* sar now looks for sadc data collector in more places.\n\t* NLS is now enabled by default.\n\t* Silly bug in iostat disk accounting patch fixed.\n\t* Added iostat disk accounting patch against 2.2.15 linux kernel.\n\n2000/04/02: Version 3.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* sadc no longer complains when daily data files have a null length.\n\t* Configuration script added (make config).\n\t* Statistics on sockets in use added.\n\t* Got rid of various limits (maximum number of serial lines,\n\t  maximum number of network interfaces).\n\t* Better management of dynamic files contents.\n\t* Cosmetic change for timestamp display.\n\t* Manual pages updated.\n\t* Documentation added in ${PREFIX}/doc/sysstat-x.y.\n\n2000/02/20: Version 3.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Fixed a bug that made average numbers wrong for some statistics\n\t  when reading them from a system activity file.\n\t* Fixed a bug that prevented the user from retrieving some\n\t  statistics when reading them from a system activity file.\n\t* sadc no longer core-dumps on UP machines with SMP support enabled\n\t  in the kernel.\n\t* System activity files are now readable by everybody.\n\t* Average statistics since boot time are now printed when interval\n\t  parameter is set to 0. If interval and count parameters are not\n\t  set on the command line, sar selects requested activities from\n\t  the current system activity daily data file.\n\t* sadc, sa1 and sa2 manual pages moved to chapter 8 instead of 1m.\n\t* iostat disk accounting patch modified to work with md drivers.\n\n2000/01/30: Version 3.0 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* sadc - system activity data collector added.\n\t* sa1, sa2 and sysstat.sh shell scripts added.\n\t* Manual pages added for sadc, sa1, sa2.\n\t* sar heavily modified to use stats sent by sadc.\n\t* System activity data file now records system restarts.\n\t* Every records in the iostat and system activity data files have\n\t  their own timestamp now.\n\t* sar and iostat largely modified to use structures when reading or\n\t  writing data files.\n\t* Per-process statistics added.\n\t* System minor and major fault statistics added.\n\t* TTY device statistics added.\n\t* Memory and swap space utilization statistics added.\n\t* Per-processor interrupt statistics added.\n\t* Statistics for kernel parameters (dcache, inodes, superblocks, etc.) \n\t  added.\n\t* Network device statistics added.\n\t* S_TIME_FORMAT environment variable added.\n\t* Meaning of -i option has changed for sar.\n\t* -d option removed for sar since it is no longer needed (we have\n\t  sadc now).\n\t* sar now uses keywords such as ALL, SUM, etc. instead of numerical\n\t  parameters.\n\t* iostat disk accounting patch improved.\n\t* 'page' field in /proc/stat is no longer used by iostat (was\n\t  unreliable).\n\t* Workaround for buggy RTC (or kernels?) added. Used when the number\n\t  of jiffies spent by the system in the idle task is decreasing in\n\t  /proc/stat.\n\t* Manual pages updated.\n\t* NLS updated: Portuguese translation added.\n\t* Makefile updated.\n\n1999/11/28: Version 2.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Option -d added to sar to enable it to be started as a daemon.\n\t* sar initialization script updated to use -d option.\n\t* Option -V added to sar and iostat (print version number and usage).\n\t* Fixed a bug that made CPU utilization displayed by iostat wrong on\n\t  SMP machines.\n\t* Manual pages updated and moved to chapter 1 instead of 8.\n\t* sar '-m' option renamed to '-r'.\n\t* Display improved for iostat.\n\t* NLS updated: Spanish translation added.\n\t* Patch against kernel 2.2.13 added for iostat.\n\n1999/10/24: Version 2.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* The sar and iostat commands can now work on non SMP-machines even\n\t  if the kernel is compiled with SMP support enabled.\n\t* Fixed a bug that made the time displayed by iostat wrong when\n\t  reading stats back from a file.\n\t* Added memory statistics: free/shared/buffer/cached pages (sar -m).\n\t* Option -h added to sar to print its header periodically.\n\t* Set unavailable fields to zero when writing iostat file.\n\t* sar now displays 'proc/s' instead of 'fork/s' since exec'ed\n\t  processes are also taken into account.\n\t* Manual pages updated.\n\t* sysstat is now available in RPM format.\n\t* Code cleaned up and made safer.\n\n1999/09/19: Version 2.0 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* iostat now displays logical block I/O stats for each IDE device, or\n\t  global Kb/s rate for all the block devices. Stats in Kb/s for each\n\t  block device are not available for standard kernels due to Linux\n\t  poor disk accounting... Anyway a patch is provided in this version\n\t  of 'sysstat' in the 'patch' directory to fix that.\n\t* System uptime is no longer read in /proc/uptime but computed from\n\t  the cpu line in /proc/stat.\n\t* When stats are read from a file (option -f of iostat and sar),\n\t  values are now computed in accordance with the interval given by\n\t  the user on the command line.\n\t* Old '-o' option for iostat removed. Now iostat can save data\n\t  into a file in a binary format and re-read them later (options\n\t  '-o' and '-f') in the same way sar does.\n\t* Number of available processors now taken into account when\n\t  retrieving CPU usage from /proc/stat.\n\t* Removed a bug that prevented 'sar -U' to work on SMP machines.\n\t* Fixed a bug that made per-CPU average usage wrong on SMP machines.\n\t* Use of option -U is now possible for sar when reading from a file\n\t  even if the machine is not an SMP one.\n\t* Fixed a bug that prevented sar from re-reading stats saved in a file\n\t  when -I or -U option had been used.\n\t* iostat modified to work on SMP machines.\n\t* Changed the formula used to display stats in order not to get\n\t  numbers greater than UINT_MAX.\n\t* System name, release number and hostname are now saved in \n\t  system activity files.\n\t* iostat now displays system name, release number and hostname\n\t  when invoked.\n\t* Daily system activity file rotation added for sar.\n\t* Improved 64-bit system support.\n\t* CREDITS file added.\n\t* NLS updated: German translation added.\n\t* Manual pages updated.\n\t* Makefile updated: Do not call msgfmt if NLS is not enabled.\n\n1999/06/25: Version 1.2 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* Better NLS support (date, time and numerical values, NLS enabled\n\t  for sar, etc.).\n\t* System activity daily file structure changed: Is now independent of\n\t  the locale and is more compact.\n\t* sar updated to support SMP machines (per CPU accounting).\n\t* Code cleaned, man pages updated...\n\n1999/05/28: Version 1.1 - Sebastien Godard <sebastien.godard@wanadoo.fr>\n\t* NLS support added. French translation started but needs to be\n\t  completed.\n\t* sar updated to support more than 16 interrupts (potential APIC\n\t  interrupt sources).\n\t* A few typos removed (man pages, etc.).\n\t* Author email address updated :-)\n\t* Tested on kernel 2.2.5.\n\n1999/03/06: Version 1.0 - Sebastien Godard <sebastien.godard@gazdefrance.com>\n\t* Initial Revision. Tested on kernel 2.0.36.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.623046875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    {description}\n    Copyright (C) {year}  {fullname}\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  {signature of Ty Coon}, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 9.90625,
          "content": "The following people have contributed to 'sysstat' in one way or another:\n\n\tFirst I would like to thank Michael <michael [at] roka.net>: He is the\n\tvery first person to have given me feedback about sysstat, and to\n\tpoint out to me that certain fields in /proc/stat didn't have the\n\tmeaning I thought they had. This was in 1999!\n\n\tMany thanks to the translators involved in sysstat:\n\n\t  * Birko Bergt <birko.bergt [at] gmx.de> for his translation into\n\t    German,\n\t  * Fernando Félix Redondo <fernando.felix [at] rediris.es> for his\n\t    translation into Spanish (now maintained by Muralito\n\t    <muralito [at] montevideo.com.uy>),\n\t  * Frederic L. W. Meunier <0 [at] pervalidus.net> for the\n\t    Portuguese translation.\n\t  * Gert Brits <gbrits [at] techconcepts.co.za> for the translation\n\t    into Afrikaans.\n\t  * Roy Sigurd Karlsbakk <roy [at] karlsbakk.net> for the Norwegian\n\t    translation.\n\t  * Stefano Barni <barninga [at] interfree.it> for the translation\n\t    into Italian.\n\t  * Dennis Selsky <selsky [at] siberia.net> for the Russian translation.\n\t  * Eugen Hoanca <eugenh [at] urban-grafx.ro> for the Romanian\n\t    translation.\n\t  * Robert Luberda <robert [at] debian.org> for the translation into\n\t    Polish.\n\t  * Miroslav David <md20128 [at] decef.elf.stuba.sk> for the Slovak\n\t    translation.\n\t  * Hideki Yamane <henrich [at] samba.gr.jp> for the translation into\n\t    Japanese.\n\t  * Daniel Nylander <po [at] danielnylander.se> for the Swedish\n\t    translation.\n\t  * John Damm Sørensen <john [at] hovedpuden.dk> for the Danish\n\t    translation.\n\t  * Bram Schoenmakers <bramschoenmakers [at] kde.nl> for the Dutch\n\t    translation.\n\n\tCarl-Christian Weber <ccweber [at] itz-koeln.de> helped me to make sar\n\twork on SMP machines.\n\n\tStefan Majer <smajer [at] advance-bank.de> provided me with a patch to\n\trotate daily system activity files.\n\n\tKlaus Franken <klaus.franken [at] fth2.siemens.de> created the RPM\n\tpackages. He also included a short initialization script for sar\n\tto start it as a daemon on boot.\n\n\tJason (Jay) R. Fink <jay_rf [at] exis.net> set up and maintained the\n\tfirst web site for sysstat.\n\n\tPreston Brown <pbrown [at] redhat.com> sent me the RedHat patch to\n\tenable good packaging.\n\n\tDavid Doubrava <linux_monitor [at] volny.cz> created the isag\n\tcommand (Interactive System Activity Graph).\n\n\tRik van Riel <riel [at] conectiva.com.br> explained me the meaning\n\tof several fields that were added in Linux kernel 2.4\n\t/proc/meminfo file.\n\n\tHubert Nueckel <hubert.nueckel [at] oracle.com> sent me a patch to\n\tfix CPU utilization displayed by sar, iostat and mpstat commands\n\ton IA64 machines.\n\n\tVictor Hazlewood <victor [at] sdsc.edu> sent me a patch to implement\n\ta database friendly option for sar (option -H).\n\n\tChristopher Blizzard <blizzard [at] redhat.com> added the ability to\n\tdisplay kB/s transfers to devices in iostat reporting when\n\toption -x is used.\n\n\tJohn Caruso <caruso [at] paradiso.umuc.edu> wrote the sargon script\n\tshell as a replacement for sa1/sa2 files.\n\n\tWilhelm Nuesser <wilhelm.nuesser [at] sap.com> sent me a patch to\n\tfix average wait times and service times displayed by iostat -x.\n\n\tRick Lindsley <ricklind [at] us.ibm.com> has played a great part in\n\tmaking sysstat work on kernels 2.5 and above.\n\n\tJohn Salmon <John.Salmon [at] cw.com> wrote a patch to enable file\n\tlocking for sadc (option -L).\n\n\tJim W. Jaszewski <grok [at] sprint.ca> fixed several typos in\n\tsysstat FAQ!\n\n\tCharlie Bennett <ccb [at] redhat.com> sent me several patches to\n\tfix known problems with sysstat. He also added the sysstat.ioconf\n\tfile support, and the -p option to sar.\n\n\tThomas Polliard <thomas [at] polliard.com> helped me define the XML\n\toutput format for sadf. He also wrote the corresponding DTD.\n\n\tDwight Tovey <dtovey [at] emergecore.com> updated sysstat so that\n\tit may be installed on Slackware.\n\n\tBryce Harrington <bryce [at] osdl.org> helped me to add support for\n\thotplug CPU to sysstat.\n\n\tIvana Varekova <varekova [at] redhat.com> added support for iostat\n\tNFS statistics. Ivana also added support for autoconf, and created\n\tcifsiostat command.\n\n\tNils Philippsen <nphilipp [at] redhat.com> made history configurable.\n\n\tRobert Luberda <robert [at] debian.org> brought a few improvements\n\tto sysstat's code, and also reported several bugs.\n\n\tJeroen Roovers <jer [at] gentoo.org> sent me a patch to fix a rare\n\tparallel make issue creating archive libsyscom.a.\n\n\tLivio Soares <livio [at] eecg.toronto.edu> sent me a patch to fix\n\ta bug where mpstat didn't parse /proc/interrupts correctly when\n\tsome CPUs had been set offline.\n\n\tEmil Glatz <Emil.Glatz [at] wescoglobal.com> wrote the XML Schema\n\tto be used with sadf option -x.\n\n\tEduardo Ferro Aldama <eduardo.ferro.aldama [at] gmail.com> added\n\toption -l to pidstat to display the process command name and\n\targuments.\n\n\tMario Konrad <Mario.Konrad [at] gmx.net> added regular expressions\n\tsupport to pidstat'x option -C. He also added option -s to pidstat\n\tto display task stack statistics.\n\n\tJan Kaluza <jkaluza [at] redhat.com> contributed several patches\n\tto sysstat. Among them, he added some more power management\n\tstatistics to sar.\n\n\tAlain Chéreau <cheralain [at] googlemail.com> added support for\n\tdisk groups statistics to iostat.\n\n\tCédric Marie <cedric.marie [at] openmailbox.org> sent me\n\tseveral patches to improve pidstat.\n\n\tRobert Elliott <Elliott [at] hp.com> contributed the irqtop\n\tcommand, and Lance Shelton <Lance.Shelton [at] sandisk.com>\n\tthe irqstat command.\n\n\tDimitrios Apostolou <jimis [at] gmx.net> contributed the\n\tsargraph2 plotting tool.\n\n\tShane M. SEYMOUR <shane.seymour [at] hpe.com> contributed the\n\ttapestat command.\n\nI would also thank the following people for their hints or bug reports\n(in alphabetical order):\n\n\tDes Atkinson <Des.Atkinson@met[...].uk>\n\tAlexander Bangert <bangert.alex@gma[...].com>\n\tSravan Bhamidipati <bsravanin@gma[...].com>\n\tChuck Blake <cb@mit[...].edu>\n\tMichael Blakeley <mike@bla[...].com>\n\tPascal Bleser <pbleser@ato[...].com>\n\tLodewijk Bonebakker <jlbonebakker@gma[...].com>\n\tAndrey Borzenkov <arvidjaar@gma[...].com>\n\tJesse Brandeburg <jesse.brandeburg@int[...].com>\n\tXavier Bru <xavier.bru@bul[...].net>\n\tJason Burnett <jason@jnj[...].org>\n\tFabricio Ceolin <ceolin@ule[...].com\n\tVitezslav Cizek <vcizek@sus[...].cz>\n\tMark J. Cox <mjc@red[...].com>\n\tJean Dagenais <jean.dagenais@int[...].com>\n\tNicolas Denis <denisn@wan[...].fr>\n\tAndrew Donkin <ard@wai[...].nz>\n\tGreg Edwards <edwardsg@sgi[...].com>\n\tTony Ernst <tee@sgi[...].com>\n\tChris Evans <chris@sca[...].org>\n\tDamien Faure <damien-jn.faure@bul[...].net>\n\tJames Fraser <jameswfraser@gma[...].com>\n\tDr. David Alan Gilbert <dave@tre[...].org>\n\tDavid Gesswein <djg@drs[...].com>\n\tFrank Glinka <glinkaf@uni[...].de>\n\tJohn Goodyear <johngood@us[...].com>\n\tGurinder Shergill <gurinder.shergill@hp[...].com>\n\tLadislav Hagara <ladislav.hagara@uno[...].cz>\n\tDon Harrop <don@swb[...].com>\n\tMark Harvey <markh794@gma[...].com>\n\tVasant Hegde <hegdevasant@lin[...].com>\n\tJürgen Heinemann <heinemann.juergen@hjc[...].de>\n\tKei Ishida <ishida.kei@oss[...].jp>\n\tTatsuo Ito <tito@mir[...].com>\n\tDavid S. Jackson <dsj@syl[...].net>\n\tErik Jacobson <erikj@sub[...].com>\n\tJordan <ledzep37@hom[...].com>\n\tJurriaan <thunder7@xs4[...].nl>\n\tJonathan Kamens <jik@kam[...].us>\n\tIlya Katsnelson <ilya.katsnelson@mot[...].com>\n\tSteve Kay <stevekay@gma[...].com>\n\tSampsa Kiiskinen <tuplanolla@gma[...].com>\n\tMike Kobler <mkobler@gma[...].com>\n\tJohn Lau <johnlcf@gma[...].com>\n\tByeong-taek Lee <btlee@psy[...].kr>\n\tBreno Leitao <breno.leitao@gma[...].com>\n\tIvo Letzas <letzas@for[...].nu>\n\tWayne Lin <wlin@mvi[...].com>\n\tGunnar Lindholm <lindholm.gunnar@gma[...].com>\n\tNeculai Macarie <macarie.neculai@nex[...].com>\n\tRobert Macaulay <Robert_Macaulay@Del[...].com>\n\tPierre Machard <pmachard@deb[...].org>\n\tJérôme Marchand <jmarchan@red[...].com>\n\tAlan Matsuoka <alanm@red[...].com>\n\tRodney J. Mertz <rjm@elv[...].com>\n\tRoy Millar <100044.14@com[...].com>\n\tChris Minshull <CMinshull@nyx[...].com>\n\tPascal Monschein <ext.astek.monschein@snc[...].fr>\n\tChris Morrow <cmorrow@ver[...].com>\n\tDavid J. Morse <David_J_Morse@Del[...].com>\n\tHariprasad Nellitheertha <hari@in.[...].com>\n\tChristian Neukirchen <chneukirchen@gma[...].com>\n\tMuneyuki Noguchi <nogu.dev@gma[...].com>\n\tGiulio Orsero <giulioo@pob[...].com>\n\tEdouard G. Parmelan <edouard.parmelan@qua[...].fr>\n\tOliver Paukstadt <oliver.paukstadt@mil[...].com>\n\tPlattner(?) <Plattner.external@inf[...].com>\n\tPeter Portante <peter.a.portante@gma[...].com>\n\tGerardo Exequiel Pozzi <vmlinuz386@yah[...].ar>\n\tReDragon <redragon@vns[...].net>\n\tAmir Rapson <amir.rapson@gma[...].com>\n\tPaul Rivoli <paul@kbs[...].au>\n\tScott Rochford <Scott_Rochford@DEL[...].com>\n\tRolphin <rolphin@fre[...].fr>\n\tJeroen Roovers <jer@gen[...].org>\n\tPavol Rusnak <prusnak@sus[...].cz>\n\tJoseph E. Sacco <jsacco@ear[...].net>\n\tSachin Sant <sachinp@in.[...].com>\n\tEivind Sarto <ivan@kas[...].com>\n\tDanilo Sartori <d.sartori@res[...].it>\n\tTan Shao Yi <tansy@tan[...].org>\n\tYibin Shen <zituan@taobao.com>\n\tLee Schermerhorn <lee.schermerhorn@hp.[...].com>\n\tPeter Schiffer <pschiffe@red[...].com>\n\tBenno Schulenberg <bensberg@jus[...].net>\n\tMichal Sekletar <msekleta@red[...].com>\n\tMichel Simoni <m_simoni@clu[...].fr>\n\tGabrielle Singleton <gelle@umi[...].edu>\n\tRod Skinner <rod.skinner@int[...].com>\n\tKevin C. Smallwood <kcs@lin[...].com>\n\tDick Snippe <Dick.Snippe@tec[...].nl>\n\tAlexis Solanas <alexis@red[...].com>\n\tGraham Swallow <gps@tri[...].uk>\n\tMike Sweger <mikesw@whi[...].net>\n\tJulian Taylor <jtaylor.debian@goo[...].com>\n\tDon Totten <dontotten@ibm[...].net>\n\tAlexander Troosh <trush@yan[...].ru>\n\tStephen Tweedie <sct@red[...].com>\n\tPetr Uzel <petr.uzel@sus[...].cz>\n\tThomas Weber <TWEBER@de.[...].com>\n\tYongjun Wei <yjwei@nan[...].com>\n\tStefan Wild <SWILD@de.[...].com>\n\tThomas Winn <tcwinn@gma[...].com>\n\tMike Winter <mike.winter@usa[...].ca>\n\tHolger Wolf <Holger.Wolf@de.[...].com>\n\tUrban Widmark <urban@sve[...].se>\n\tYu Yongcong <yuyc@cn.[...].com>\n\tPeter Zaitsev <pz@spy[...].ru>\n\tZhen Zhang <furykerry@gma[...].com>\n\n--\nSebastien Godard (sysstat <at> orange.fr) is the author and the current\nmaintainer of this package.\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 35.357421875,
          "content": "## Welcome to the sysstat's Frequently Asked Questions!\n\n### Table of contents\n\n**[1. General questions](#general)**\n\n[1.1.](#1_1) When I compile sysstat, it fails with the following message: `make: msgfmt: Command not found`  \n[1.2.](#1_2) When I try to compile sysstat, it fails and says it cannot find some include files.  \n[1.3.](#1_3) I don't understand why sysstat displays the time sometimes as `HH:MM:SS` and sometimes as `HH:MM:SS AM/PM`...  \n[1.4.](#1_4) What are the units actually used by sysstat commands?  \n[1.5.](#1_5) Does sysstat still use odd/even numbers for development/stable versions?\n\n**[2. Questions related to sar, sadc and sadf](#sar)**\n\n[2.1.](#2_1) The sar command complains with the following message: `Invalid system activity file: ...`  \n[2.2.](#2_2) The sar command complains with the following message: `Cannot append data to that file (...)`  \n[2.3.](#2_3) The sar command complains with the following message: `Inconsistent input data`  \n[2.4.](#2_4) I get the following error message when I try to run sar: `Cannot open /var/log/sa/sa30: No such file or directory`  \n[2.5.](#2_5) Are sar daily data files fully compatible with Sun Solaris format sar files?  \n[2.6.](#2_6) The `Average:` results from the sar command are just rubbish...  \n[2.7.](#2_7) My database (e.g. MySQL) doesn't appear to understand the time zone displayed by 'sadf -d'...  \n[2.8.](#2_8) I tried to use options -s and -e with sadf. Unfortunately, I have nothing displayed at all / the output doesn't match that of sar.  \n[2.9.](#2_9) I cannot see all my disks when I use the sar -d command...  \n[2.10.](#2_10) Do you know a tool which can graphically plot the data collected by sar?  \n[2.11.](#2_11) When I launch sadc, I get the error message: `flock: Resource temporarily unavailable`  \n[2.12.](#2_12) How should I run sysstat / sar so that I get a reading for `00:00:00`?  \n[2.13.](#2_13) The sar command complains with the following message: `Requested activities not available in file ...`  \n[2.14.](#2_14) Does sar need a lot of resources to run?  \n[2.15.](#2_15) Are the measurements gathered by sadc cumulative or instantaneous?  \n[2.16.](#2_16) Some fields are always displayed as `0.00` when I use the `sar -d` command.  \n[2.17.](#2_17) The sar command complains with the following message: `Requested activities not available`  \n[2.18.](#2_18) How can I keep sar data for more than one month?  \n[2.19.](#2_19) How can I load sar data into an Oracle database for performance analysis and capacity planning?  \n[2.20.](#2_20) The sar command displays some weird output values...  \n[2.21.](#2_21) What happened to sar's options -h, -H, -x and -X?  \n[2.22.](#2_22) What is the exact meaning of the `count` parameter for sar and sadc?  \n[2.23.](#2_23) Why doesn't sar deal with sub-second sampling/monitoring?  \n[2.24.](#2_24) Is it possible to make sadc save only some specific activities in my binary daily data files?  \n[2.25.](#2_25) The sar and/or sadf command complain(s) with the following message: `End of system activity file unexpected`  \n\n**[3. Questions related to iostat](#iostat)**\n\n[3.1.](#3_1) I can't see all my disks when I use the iostat command...  \n[3.2.](#3_2) iostat -x doesn't report disk I/O statistics...  \n[3.3.](#3_3) Why can't iostat display extended statistics for partitions with 2.6.x kernels?  \n[3.4.](#3_4) I don't understand the output of iostat. It doesn't match what I expect it to be...  \n[3.5.](#3_5) Why values displayed by iostat are so different in the first report from those displayed in subsequent ones?  \n[3.6.](#3_6) iostat -x displays huge numbers for some fields...  \n\n**[4. Questions related to pidstat](#pidstat)**\n\n[4.1.](#4_1) pidstat -d doesn't report task I/O statistics...  \n[4.2.](#4_2) The pidstat command complains with the following message: `Requested activities not available`  \n[4.3.](#4_3) pidstat doesn't display statistics for process (task) _xyz_...  \n[4.4.](#4_4) I noticed that the total CPU utilization for threads running on an individual CPU can exceed 100%...  \n\n---\n\n### 1. General questions<a name=\"general\"></a>\n\n1.1.<a name=\"1_1\"></a> When I compile sysstat, it fails with the following message:\n```\nmake: msgfmt: Command not found\nmake: ***[locales] Error 127\n```\nA: The **msgfmt** command belongs to the GNU gettext package.\nIf you don't have it on your system, just configure sysstat with NLS disabled like this:\n```\n$ ./configure --disable-nls\n```\nor answer 'y' (for \"yes\") to the question\n```\nDisable National Language Support (NLS)? (y/n) [--disable-nls]\n```\nif you use the Interactive Configuration script (_iconfig_),\nthen compile sysstat as usual (make ; make install).\n\nPlease read the _README-nls_ file included in sysstat source package to learn\nsome more about National Language Support.\n\n---\n1.2.<a name=\"1_2\"></a> When I try to compile sysstat, it fails and says it cannot find some include files:\n```\nIn file included from /usr/include/bits/errno.h:25,\n                 from /usr/include/errno.h:36,\n                 from common.c:26:\n/usr/include/linux/errno.h:4: asm/errno.h: No such file or directory\n<SNIP>\ncommon.c: In function `get_kb_shift':\ncommon.c:180: `PAGE_SIZE' undeclared (first use in this function)\ncommon.c:178: warning: `size' might be used uninitialized in this function\nmake: *** [common.o] Error 1\n```\nA: Make sure that you have the Linux kernel sources installed in\n`/usr/src/linux`. Also make sure that the symbolic link exists in the\n`/usr/src/linux/include` directory and points to the right architecture, e.g.:\n```\n# ll /usr/src/linux/include/asm\nlrwxrwxrwx   1 root     root            8 May  5 18:31 /usr/src/linux/include/asm -> asm-i386\n```\nIn fact, only the Linux kernel headers should be necessary to be able to compile sysstat.\n\n---\n1.3.<a name=\"1_3\"></a> I don't understand why sysstat displays the time sometimes as `HH:MM:SS` and sometimes as `HH:MM:SS AM/PM`...\n  \nA: The time format used by sysstat tools depends on the locale of your system.\nThe locale is defined by several environment variables, among which the **LANG**\nvariable is perhaps the most widely used. See the following example:\n```\n$ export LANG=en_US\n$ sar\nLinux 2.4.9 (brooks.seringas.fr)        07/20/04\n\n04:32:11 PM       LINUX RESTART\n\n05:00:00 PM       CPU     %user     %nice   %system   %iowait     %idle\n05:10:00 PM       all      0.24      0.00     89.64      0.00     10.12\nAverage:          all      0.24      0.00     89.64      0.00     10.12\n\n$ export LANG=fr_FR\n$ sar\nLinux 2.4.9 (brooks.seringas.fr)        20.07.2004\n\n16:32:11          LINUX RESTART\n\n17:00:00          CPU     %user     %nice   %system   %iowait     %idle\n17:10:00          all      0,24      0,00     89,64      0,00     10,12\nMoyenne:          all      0,24      0,00     89,64      0,00     10,12\n```\nAs you can notice, the time format but also the date, the decimal point, and\neven some words (like \"Average\") have changed according to the specified locale.\n\n---\n\n1.4.<a name=\"1_4\"></a> What are the units actually used by sysstat commands?\n\n\nA: Although sysstat commands use the following abbreviations: kB, MB, etc.\nas part of the metrics names (e.g. kB_read/s, wkB/s, or even sometimes with a\nlower 'b': kbmemfree, kbavail...), we always actually refer to kibibytes (kiB),\nmebibytes (MiB),...  \nA kibibyte is equal to 1024 bytes, and a mebibyte is equal to 1024 kibibytes.  \nMetrics names have been defined many years ago. We don't modify them to avoid\nbreaking third-party programs parsing sysstat commands' output.\n\n---\n\n1.5.<a name=\"1_5\"></a> Does sysstat still use odd/even numbers for development/stable\nversions?\n\n\nNo, starting with sysstat versions 12.7.x, sysstat no longer uses odd and even version\nnumbers to identify development and stable series. The latest sysstat release should\nalways be considered as a stable version that can be used for distribution packaging.\n\n---\n### 2. Questions related to sar, sadc and sadf<a name=\"sar\"></a>\n\n2.1.<a name=\"2_1\"></a> The sar command complains with the following message:\n```\nInvalid system activity file: ...\n```\nA: You are trying to use a file which is not a system activity file, or whose\nformat is no longer compatible with that of files created by current version of sar.\nIf you were trying to use the standard system activity files located in the\n`/var/log/sa` directory then the solution is easy: just log in as root and\nremove by hand all the files located in the `/var/log/sa` directory:\n```\n# rm /var/log/sa/sa??\n```\nIf you are using sysstat 11.1.1 and later, you can also use the sadf command\nto convert an old system activity binary datafile (version 9.1.6 and later) to\ncurrent up-to-date format. Use the following syntax:\n```\n$ sadf -c old_datafile > new_datafile\n```\nNote: Starting with sysstat version 8.1.1 and later, it is possible to\nknow which version of sar or sadc has been used to create a data file.\nJust enter the following command:\n```\n$ sadf -H /your/datafile | grep sysstat\nFile created using sar/sadc from sysstat version 8.1.7\n```\n\n---\n2.2.<a name=\"2_2\"></a> The sar command complains with the following message:\n```\nCannot append data to that file (...)\n```\nA: The internal structure of the data file does not allow sar to append\ndata to it. The data file may come from another machine, or the components\nof the current box, such as the number of processors, may have changed.\nUse another data file, or delete the current daily data file, and try again.  \nWith sysstat version 10.1.3 and later, it is now possible to append data\nto a data file even if the number of processors has changed. But first,\nyou have to make the data file aware of this change by inserting a restart\nmark (this is typically done when sadc is called at system restart). You\ncan then append data to the data file as usual.\n\n---\n2.3.<a name=\"2_3\"></a> The sar command complains with the following message:\n```\nInconsistent input data\n```\nA: This error message means that sadc (the system activity data collector that\nsar is using) is not consistent with the sar command. In most cases this is\nbecause the sar and sadc commands do not belong to the same release of the\nsysstat package. Remember that sar may search for sadc in predefined\ndirectories (`/usr/local/lib/sa`, `/usr/lib/sa`, ...) before looking in the\ncurrent directory!  \nWith sysstat version 11.1.5 and later, enter `sar --sadc`\nto determine which data collector is called by sar.\n\n---\n2.4.<a name=\"2_4\"></a> I get the following error message when I try to run sar:\n```\nCannot open /var/log/sa/sa30: No such file or directory\n```\nA: Please read the sar(1) manual page! Daily data files are created by default\nin the `/var/log/sa` directory using the data collector (sadc) or using\noption -o with sar. Once they are created, sar can display statistics\nsaved in those files.  \nBut sar can also display statistics collected \"on the fly\": Just enter\nthe proper options on the command line to indicate which statistics are\nto be displayed, and also specify `interval` and `count` numbers, e.g.:\n```\n# sar 2 5       --> will report CPU utilization every two seconds, five times.\n# sar -n DEV 3  --> will report network device utilization every 3 seconds, in an infinite loop.\n```\n\n---\n2.5.<a name=\"2_5\"></a> Are sar daily data files fully compatible with Sun Solaris format\nsar files?\n\n\nA: No, the format of the binary data files created by sysstat's sar command\nis not compatible with formats from other Unixes, because it contains\ndata which are closely linked to Linux.  \nFor the same reason, sysstat cannot work on platforms other than Linux...\n\n---\n2.6.<a name=\"2_6\"></a> The `Average:` results from the sar command are just rubbish, e.g.:\n```\n 11:00:00 AM       CPU     %user     %nice   %system     %idle\n 11:10:00 AM       all      0.54      0.00      0.89     98.57\n 11:20:01 AM       all      3.02      8.05     22.85     66.08\n 11:30:01 AM       all      8.15      0.00      2.31     89.54\n 11:40:01 AM       all      8.03      0.00      2.42     89.55\n 11:50:01 AM       all     16.04      0.00      2.81     81.16\n 12:00:00 PM       all     21.11      0.00      3.23     75.66\n 03:40:01 PM       all    100.01    100.01    100.01      0.00\n 04:40:00 PM       all    100.00      0.00    100.00      0.00\n 04:50:00 PM       all      5.87      0.00      1.26     92.87\n 05:00:00 PM       all      4.70      0.00      1.48     93.82\n 05:10:00 PM       all      4.93      0.00      1.29     93.78\n Average:          all    100.22    100.20    100.13      0.00\n```\nA: Your sar command was not installed properly. Whenever your computer\nis restarted (as it is the case here between `12:00:00 PM` and `03:40:01 PM`),\nthe `sysstat` shell script must be called by the system, so that the\nLINUX RESTART message can be inserted into the daily data file, indicating\nthat the relevant kernel counters have been reinitialized...  \nYou can install the `sysstat` script by hand in the relevant startup\ndirectory, or you can ask sysstat to do it for you during configuration\nstage by entering:\n```\n$ ./configure --enable-install-cron\n```\nOr you can answer 'y' to the question:\n```\nSet crontab to start sar automatically? (y/n) [--enable-install-cron]\n```\nif you use the Interactive Configuration script (iconfig).  \nThen compile sysstat as usual and run 'make install' as the last stage.\n\n---\n2.7.<a name=\"2_7\"></a> My database (e.g. MySQL) doesn't appear to understand the time zone\ndisplayed by 'sadf -d'...\n\n\nA: The format includes the timezone detail in the output. This is to make\nsure it is communicated clearly that UTC is how the data is always\nconverted and printed. Moreover we don't depend on the TZ environment\nvariable and we don't have some data converted to a different timezone\nfor any reason, known or unknown.  \nWhen you deal with raw accounting data you always want it in UTC.\nOf course, you want it to all be the same when loading into a database.\nIf your database can't deal with timezones, you should write a short script\nto strip the \"UTC\" characters from the data being loaded into the database.\n\n---\n2.8.<a name=\"2_8\"></a> I tried to use options -s and -e with sadf. Unfortunately, I have\nnothing displayed at all / the output doesn't match that of sar.\n\n\nA: The way how options -s and -e are interpreted has changed with sysstat's\nversions.\nFirst if you don't have any data displayed by sadf, this is because no data\nbelong to the specified time interval! Up to sysstat version 12.1.4, the\ntime specified with options -s and -e was always considered as being given\nin local time to be consistent with sar's default output. Yet sadf displays\nits timestamps in UTC (Coordinated Universal Time) by default (and in local\ntime with option -T). This could lead to some misunderstandings, as if sadf's\noptions -s and -e didn't work properly.\nSo with sysstat version 12.1.5, the time specified with options -s and -e\nis now consistent with the timestamps displayed by sadf (either in UTC by\ndefault or in local time with option -T), even if the output doesn't match\nthat of sar.\n\n---\n2.9.<a name=\"2_9\"></a> I cannot see all my disks when I use the sar -d command...\n\n\nA: See question \"I can't see all my disks when I use the iostat command\" below.\n\n---\n2.10.<a name=\"2_10\"></a> Do you know a tool which can graphically plot the data collected by sar?\n\n\nA: You can now draw graphs with sysstat's standard tools!\nSVG (Scalable Vector Graphics) is a new output format that has been added to\nsadf in sysstat version 11.3.1. Read sadf(1) manual page to learn some more\nabout this new format.  \nThere are other tools lying around on the internet that you can use to draw\nsome graphs. I haven't tested all of them and there must still be some\nway for improvement...  First, some of them are included in the sysstat\npackage although they are no longer maintained: isag (a Perl script) or\nsargraph (a shell script).\nYou can also find: kSar (a Java application capable of visualizing a sar file\nwith static graphs), sarjitsu (a more sophisticated application producing\ndynamic visualizations based on Grafana), sarvant, sar2gp, loadgraph,\nSysStat Charts, sarplot...\n[rrd.cgi](http://haroon.easi.utoronto.ca/rrd/scripts/) is a perl front-end for\nrrdtool and can be used to make some graphs (see a demo [here](http://haroon.easi.utoronto.ca/perl/rrd.cgi/sar_stats/)).\n[sysstat_mail_report](https://github.com/desbma/sysstat_mail_report) is a script\nthat automatically generates and sends an email report every day/week/month\nwith graphs generated from sysstat data.  \nI've also heard of commercial tools which use sysstat: PerfMan comes to mind,\namong others.\n\n---\n2.11.<a name=\"2_11\"></a> When I launch sadc, I get the error message:\n```\nflock: Resource temporarily unavailable\n```\nA: You are launching sadc using -L option. With this option, sadc tries to\nget an exclusive lock on the output file. The above error message indicates\nthat another sadc process was running and had already locked the same output\nfile. Stop all sadc instances and try again.\n\n---\n2.12.<a name=\"2_12\"></a> I have sysstat setup to run via cron:\n```\n0 * * * * /usr/local/lib/sa/sa1 600 6\n```\nso that I get an activity report every 10 minutes.  \nWhen I use sar to get my output, there is no reading for `00:00:00`. This\nmeans that at midnight every night there is a spike, or dip, in the graphs.\nHow should I run sysstat / sar so that I get a reading for `00:00:00`?\n\n\nA: Sysstat does get its data at midnight, but two data samples are needed to\ndisplay the values.  \nWhen there is a \"file rotation\" (beginning of a new day), sadc writes its data\nat the end of the previous daily data file (`/var/log/sa/sa<DD>`) **and** at the\nbeginning of the new one (`/var/log/sa/sa<DD+1>`). Please note that '-' must be\nused to specify the output file for sadc to be able to detect such a file\nrotation. So a crontab like the following one should enable you to get the\ndata for midnight at the end of each daily data file:\n```\n# Activity reports every 10 minutes from 01:00:00 to 22:50:00\n0 1-22 * * * /usr/local/lib/sa/sa1 600 6\n# Activity reports every 10 minutes from 23:00:00 to 00:00:00\n# Reporting until 00:00:00 ensures that a file rotation will be detected\n# by sadc\n0 23 * * * /usr/local/lib/sa/sa1 600 7\n# Activity reports every 10 minutes from 00:10:00 to 00:50:00\n10 0 * * * /usr/local/lib/sa/sa1 600 5\n```\nAnother possible crontab would be:\n```\n*/10 1-22 * * * /usr/lib/sa/sa1 1 1\n0,10,20,30,40 23 * * * /usr/lib/sa/sa1 1 1\n50 23 * * * /usr/lib/sa/sa1 600 2\n10,20,30,40,50 0 * * * /usr/lib/sa/sa1 1 1\n```\nThings are much easier with recent sysstat versions (12.5.1 and later): You simply have to run\nsa1 with its option `--rotate` shortly after midnight to add a statistics record to the system\nactivity daily data file of the previous day. So your full crontab could be:\n```\n# Rotate file at midnight\n0 0 * * * /usr/lib/sa/sa1 --rotate\n# Run system activity accounting tool every 10 minutes\n0,10,20,30,40,50 * * * * /usr/lib/sa/sa1 1 1\n# Generate a text summary of previous day process accounting at 00:07\n7 0 * * * /usr/lib/sa/sa2 -A\n```\n\n---\n2.13.<a name=\"2_13\"></a> The sar command complains with the following message:\n```\nRequested activities not available in file ...\n```\nA: This error message means that you are trying to extract non-existent activities\nfrom the data file. Usually sadc reads all the available activities from the\nsystem and stores them in the data file. However, to prevent data files from\ntaking too much space on disk, some activities must be explicitly set on the\ncommand line to be read by sadc.  \nTo tell sadc that an optional activity should be collected, use switch -S\nfollowed by the keyword corresponding to that activity (see sadc(8) manual page).\nAs of this writing, optional activities are: interrupts, disks, SNMP, IPv6 and\npower management statistics.  \nIMPORTANT NOTE: The list of activities that are saved in a file can no longer\nbe modified once the file has been created. So it is important to use the proper\noptions the first time sadc is called (whether via a crontab, a script like\nsa1 or even the script used to insert a RESTART message when the machine is\nrebooted).  \nNB: If the sar command complains with the error message:\n```\nRequested activities not available\n```\n(without mentioning `in file`), then see question 2.17 below.\n\n---\n2.14.<a name=\"2_14\"></a> Does sar need a lot of resources to run?\n\n\nA: No, sar doesn't need a lot of CPU to run, nor does it make your system slow,\ncontrary to what some people think. In the first place, it only runs every ten\nminutes by default. Secondly, when it does run, it is over and done very\nquickly. Try:\n```\n$ time /usr/lib/sa/sa1\n```\nto verify that for yourself.  \nNor do you have to be concerned about using up all your disk space.\nsar will use a few hundred kilobytes for a whole day's worth of data, and it\nnormally only stores one week worth (this can be configured via the HISTORY\nvariable in the `/etc/sysconfig/sysstat` file). It is entirely self limiting.\nMoreover, you can ask sar to compress its datafiles older than a certain\nnumber of days: see the COMPRESSAFTER parameter in the `/etc/sysconfig/sysstat`\nconfiguration file.\n\n---\n2.15.<a name=\"2_15\"></a> Are the measurements gathered by sadc cumulative or instantaneous values?\n\n\nA: Each counter maintained by the kernel is cumulative since system boot. As a\nconsequence the measurements gathered by sadc are cumulative values.\nMoreover all per-second statistics displayed by sar are average values on the\ngiven time interval. So the value for counter foo at time T is calculated as:\n```\nfoo/s = [foo(T) - foo(T-dt)] / dt\n```\nwhere dt is the interval given on the command line.\n\n---\n2.16.<a name=\"2_16\"></a> Some fields are always displayed as 0.00 when I use the sar -d\ncommand.\n\n\nA: See question 3.2 below.\n\n---\n2.17.<a name=\"2_17\"></a> The sar command complains with the following message:\n```\nRequested activities not available\n```\nA: This error message means that you are trying to display activities that the\nkernel itself is unable to provide.  \nWhen this error message is displayed while trying to save the data into an\nexisting file (`sar -o datafile ...`), this may also be because the target\nfile cannot accept the requested activities. In this case, just try to use\nanother file or create a new one. See also question 2.13 above.\n\n---\n2.18.<a name=\"2_18\"></a> How can I keep sar data for more than one month?\n\n\nA: By default sar saves its data in the standard system activity data file,\nthe `/var/log/sa/saDD` file, where DD is the current day in the month.\nTo prevent sar from overwriting any existing files, just set the variable\nHISTORY in `/etc/sysconfig/sysstat` to the number of days during which data\nmust be kept. When this variable has a value greater than 28, sa1 script\nuses a month-by-month directory structure; datafiles are named `YYYYMM/saDD`\nand the script maintains links to these datafiles to mimic the standard\nsar datafile structure. However please note that pre-existing datafiles\nwill be deleted as links will be created and replace them.\nBeginning with sysstat version 11.0.0, this tree of directories is no\nlonger created. When HISTORY has a value greater than 28, sa1 now calls\nsadc with option -D set, telling it to use `saYYYYMMDD` instead of `saDD`\nas the name for the standard system activity daily data files, where\nYYYY stands for the current year, MM for the current month and DD for\nthe current day. All these files are saved in the same directory\n(`/var/log/sa` by default).\n\n---\n2.19.<a name=\"2_19\"></a> How can I load sar data into an Oracle database for performance\nanalysis and capacity planning?\n\n\nA: The simplest way for that is to use sadf (a command included in sysstat\npackage) with its option -d. It displays sar data in a format that can\neasily be ingested by a relational database system (fields are separated\nby a semicolon). It should then be easy for a tool like SQL*Loader to\nload the data into the Oracle database.\n\n---\n2.20.<a name=\"2_20\"></a> The sar command displays some weird CPU values, e.g.:\n```\n10:50:01 AM       CPU     %user     %nice   %system   %iowait     %idle\n11:00:01 AM       all     90.90      0.00      5.17      3.93      0.00\n11:00:01 AM         0     39.40      0.00      2.37      2.07     56.17\n11:00:01 AM         1     29.71      0.00      1.73      1.17     67.39\n11:00:01 AM         2     42.69      0.00      2.34      1.11     53.85\n11:00:01 AM         3     26.24      0.00      1.41      1.61     70.74\n...\n```\nA: Sysstat may have met an overflow condition while reading CPU usage from\nyour /proc/stat file. This condition is all the more likely to happen as\nyour machine uptime is high and/or there are many processors.\nSysstat up to version 5.0.6 uses 32-bit integer variables to store CPU usage.\nThen, beginning with version 5.1.1, sysstat has shifted to 64-bit variables,\nwhich has fixed the problem. So try to upgrade your version of sysstat to\nthe latest release and check that the problem has gone.\nAlso see question 2.6 above.\n\n---\n2.21.<a name=\"2_21\"></a> What happened to sar's options -h, -H, -x and -X?\n\n\nA: These old options have been removed from sar because new commands have been\nmade available. You should now use the sadf command instead of sar -h or\nsar -H, and the pidstat command instead of sar -x or sar -X. Please read\ntheir manual page to learn some more about their respective options.\n\n---\n2.22.<a name=\"2_22\"></a> What is the exact meaning of the `count` parameter for sar and sadc?\n\n\nA: For sadc, `count` is the number of data samples collected.  \nFor sar, `count` is the number of records to display (a record contains\nthe average values for counters over the given time interval - See 2.15).\n\n\nStarting with an empty file `datafile`:\n```\nsadc datafile 1 6         will write 6 data samples to datafile.\nsar -f datafile 1 6       6 is invalid because there are only 5 intervals.\n```\nBased on the `count` value entered for sadc the \"valid\" `count` values for\nsar are 1 through 5. Any value greater than 5 for sar will give the\nsame output as 5 in this example. So entering `sar -f datafile 1 2000`\nfor a file populated with the output of `sadc 1 6 datafile` will give the\nsame output as `sar -f datafile 1 5`. Note that it all depends on the number\nof data samples pre-existing in the data file. If the file is empty\nwhen first running sadc then the above is true.\n\n---\n2.23.<a name=\"2_23\"></a> Why doesn't sar deal with sub-second sampling/monitoring?\n\n\nA: There are two reasons for sar to not handle sub-second intervals:\n\n\n1) This is not sar's purpose. sar has been created to give the\nsys admin a global overview of its machine daily utilization so\nthat when a problem happens, he has a benchmark and can compare\nthe statistics gathered by sar with those saved before. For that\nreason an interval of 10 minutes (which is the default for sar) is\nquite appropriate.\n\n\n2) Because this is just a dumb idea to try to gather a huge amount\nof data on a sub-second interval basis (and sar really collects\na lot of data). This can be resource-consuming and you are all the\nmore prone to have an influence on the data you are retrieving as\nthe interval of time is small.\n\n---\n2.24.<a name=\"2_24\"></a> Is it possible to make sadc save only some specific activities\nin my binary daily data files?\n\n\nA: sadc's option -S followed by one or more keywords (DISK, SNMP...)\ncan already be used to specify which optional activities are to be\ncollected. Without this option, sadc collects a default set of\nactivities (CPU activity, memory activity, network activity, etc.)  \nYet it is actually possible to specify explicitly which activities\nshould be collected by sadc! You have to use sadc's option -S\nfollowed by the report name corresponding to the activity you want\nto collect (enter \"sar --help\" to know the formal report names\nused by sadc).  \nExample: To tell sadc to collect only temperature sensors activity\nin addition to the default set of activities, enter:\n\n```\nsadc -S A_PWR_TEMP (...)\n```\n\nfollowed by the other classic options (interval, count, filename...)\nNow assume you want to collect temperature sensors activity **without**\nthe other activities collected by default,\nadd the special report name A_NULL to the list passed to sadc, e.g.:\n```\nsadc -S A_NULL,A_PWR_TEMP (...)\n```\nOf course you can enter as many report names as you want to collect\ndifferent activities.\nLast you can exclude a specific activity from a list by prefixing its\nreport name with a dash. For example, to collect all possible activities\n**except** statistics for interrupts, enter:\n```\nsadc -S XALL,-A_IRQ (...)\n```\nThis way you can tell sadc to collect only the desired activities.\n\n---\n2.25.<a name=\"2_25\"></a> The sar and/or sadf command complain(s) with the following message:\n```\nEnd of system activity file unexpected\n```\nA: sadc, the data collector, was unable to write all its data to the\nsystem activity data file (`/var/log/sa/saDD` by default).\nThis is probably because there was no space left on the device where\nthe data file is located.\nMake sure there is enough free space on the device. Sometimes it seems\nthere is enough free space but there may be some jobs run by crontab\n(particularly during the night) that can temporarily consume all of\nyour free space, making sadc fail.\n\nAnother reason could be linked to the system activity daily data file\nbeing corrupted. This could possibly happen when several instances of\nsadc are trying to update the same data file, especially around midnight\nwhen making a file rotation. See question 2.12 to know how to make such\na file rotation properly.\n\nLast this issue can also be triggered when the system is rebooted forcibly\nwithout data in cache being written to disk. You can use switch -f with sadc\nto make sure data are written to disk immediately. Of course sync'ing each\ndata sample to disk implies a (probably slight) performance penalty.\n\n---\n### 3. Questions related to iostat<a name=\"iostat\"></a>\n\n3.1.<a name=\"3_1\"></a> I can't see all my disks when I use the iostat command...\n\n\nA: Yes. This is a kernel limit. Old kernels (2.2.x for instance) used to\nmaintain stats for the first four devices.  \nThe accounting code has changed in 2.4 kernels, and the result may (or\nmay not) be better for your system. Indeed, Linux 2.4 maintains the stats\nin a two dimensional array, with a maximum of 16 devices (DK_MAX_DISK\nin the kernel sources). Moreover, if the device major number exceeds\nDK_MAX_MAJOR (whose value also defaults to 16 in the kernel sources),\nthen stats for this device will not be collected.  \nSo, a solution may be simply to change the values of these limits in\nlinux/include/linux/kernel_stat.h and recompile your kernel.\nYou should no longer have any problem with post 2.5 kernels, since\nstatistics are maintained by the kernel for all the devices.\nIn the particular case of iostat, also be sure to use the ALL keyword\non the command line to display statistical information relating to\nevery device, including those that are defined but have never been used\nby the system.\n\n---\n3.2.<a name=\"3_2\"></a> iostat -x doesn't report disk I/O statistics...\n\n\nA: For `iostat -x` to be able to report extended disk I/O statistics,\nit is better to use a recent version of the Linux kernel (2.6.x).\nIndeed, iostat tries to read data from the `/proc/diskstats` file or\nfrom the sysfs filesystem for that.  \nBut iostat may also be able to display extended statistics with\nolder kernels (e.g. 2.4.x) providing that all the necessary\nstatistical information is available in the /proc/partitions file,\nwhich requires that a patch be applied to the kernel (this is\noften done on kernels included in various distros). In recent 2.4.x\nkernels, the /proc/partitions file has all the necessary data\nproviding that the kernel has been compiled with CONFIG_BLK_STATS=y.\n\n---\n3.3.<a name=\"3_3\"></a> Why can't iostat display extended statistics for partitions with\nsome 2.6.x kernels?\n\n\nA: Because the kernel maintains these stats only for devices, and not for\npartitions! Here is an excerpt from the document iostats.txt included in\nthe kernel source documentation:\n```\nThere were significant changes between 2.4 and 2.6 in the I/O subsystem.\nAs a result, some statistic information disappeared. The translation from\na disk address relative to a partition to the disk address relative to\nthe host disk happens much earlier.  All merges and timings now happen\nat the disk level rather than at both the disk and partition level as\nin 2.4.  Consequently, you'll see a different statistics output on 2.6 for\npartitions from that for disks.\n```\nExtended I/O statistics for partitions are available again with kernels\n2.6.25 and later.\n\n---\n3.4.<a name=\"3_4\"></a> I don't understand the output of iostat. It doesn't match what I expect it\nto be...\n\n\nA: By default iostat displays I/O activity in blocks per second. With old\nkernels (i.e. older than 2.4.x) a block is of indeterminate size and therefore\nthe displayed values are not useful.  \nWith recent kernels (kernels 2.4 and later), iostat is now able to get disk\nactivities from the kernel expressed in a number of sectors. If you take a\nlook at the kernel code, the sector size is actually allowed to vary although\nI have never seen anything other than 512 bytes.\n\n---\n3.5.<a name=\"3_5\"></a> Why values displayed by iostat are so different in the first report\nfrom those displayed in subsequent ones?\n\n\nA: Probably because, as written in the manual page, the first report generated\nby iostat concerns the time since system startup, whereas subsequent ones\ncover only the time since the previous report (that is to say, the interval\nof time entered on the command line).\n\n---\n3.6.<a name=\"3_6\"></a> iostat -x displays huge numbers for some fields...\n\n\nA: Because of a Linux kernel bug, iostat -x may display huge I/O response times\n(svctm) and a bandwidth utilization (%util) of 100% for some devices. Indeed\nthese devices have a value for the field #9 (beginning after the device name)\nin `/proc/{partitions,diskstats}` which is always different from 0, and even\nnegative sometimes. Yet this field should go to zero, since it gives the\nnumber of I/Os currently in progress (it is incremented as requests are\nsubmitted, and decremented as they finish).\nTo (temporarily) fix the problem, you should reboot your system to reset the\ncounters in `/proc/{partitions,diskstats}`.\n\n---\n### 4. Questions related to pidstat<a name=\"pidstat\"></a>\n\n4.1.<a name=\"4_1\"></a> pidstat -d doesn't report task I/O statistics...\n\n\nA: For pidstat -d to be able to report I/O statistics for tasks, you need\na recent Linux kernel (2.6.20 or later) with the option\nCONFIG_TASK_IO_ACCOUNTING compiled in.\n\n---\n4.2.<a name=\"4_2\"></a> The pidstat command complains with the following message:\n```\nRequested activities not available\n```\nA: This message is displayed when the pidstat command is unable to display\nthe statistics you have requested. This may happen when you try to display\nstatistics for child processes (option -T CHILD) because all options of\npidstat don't necessarily work for child processes. Read the manual page\nto know which statistics are available for child processes.\n\n---\n4.3.<a name=\"4_3\"></a> pidstat doesn't display statistics for process (task) _xyz_...\n\n\nA: This must be because pidstat only displays statistics for active tasks\nby default. If you don't use option -p on the command line, then pidstat\nwill display only tasks with non-zero statistics. For example, `pidstat -u`\nwill display only tasks that have actually used some CPU resources since\nsystem startup. You should enter `pidstat -u -p ALL` to make sure that all\nthe processes are listed in the report.\n\n---\n4.4.<a name=\"4_4\"></a> I noticed that the total CPU utilization for threads running on\nan individual CPU can exceed 100%...\n\n\nA: The CPU number displayed by pidstat is the CPU to which the task is attached\nwhen the statistics are actually displayed. This doesn't mean that the task\nhas spent its whole interval of time attached to it. Hence the CPU ressource\nused by a thread on an interval of time as displayed by pidstat may have\nconcerned several processors.\n\n---\nSebastien Godard (sysstat at orange dot fr) is the author and the current\nmaintainer of this package.\n\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 9.0234375,
          "content": "Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002 Free Software\nFoundation, Inc.\n\n   This file is free documentation; the Free Software Foundation gives\nunlimited permission to copy, distribute and modify it.\n\nBasic Installation\n==================\n\n   These are generic installation instructions.\n\n   The `configure' shell script attempts to guess correct values for\nvarious system-dependent variables used during compilation.  It uses\nthose values to create a `Makefile' in each directory of the package.\nIt may also create one or more `.h' files containing system-dependent\ndefinitions.  Finally, it creates a shell script `config.status' that\nyou can run in the future to recreate the current configuration, and a\nfile `config.log' containing compiler output (useful mainly for\ndebugging `configure').\n\n   It can also use an optional file (typically called `config.cache'\nand enabled with `--cache-file=config.cache' or simply `-C') that saves\nthe results of its tests to speed up reconfiguring.  (Caching is\ndisabled by default to prevent problems with accidental use of stale\ncache files.)\n\n   If you need to do unusual things to compile the package, please try\nto figure out how `configure' could check whether to do them, and mail\ndiffs or instructions to the address given in the `README' so they can\nbe considered for the next release.  If you are using the cache, and at\nsome point `config.cache' contains results you don't want to keep, you\nmay remove or edit it.\n\n   The file `configure.ac' (or `configure.in') is used to create\n`configure' by a program called `autoconf'.  You only need\n`configure.ac' if you want to change it or regenerate `configure' using\na newer version of `autoconf'.\n\nThe simplest way to compile this package is:\n\n  1. `cd' to the directory containing the package's source code and type\n     `./configure' to configure the package for your system.  If you're\n     using `csh' on an old version of System V, you might need to type\n     `sh ./configure' instead to prevent `csh' from trying to execute\n     `configure' itself.\n\n     Running `configure' takes awhile.  While running, it prints some\n     messages telling which features it is checking for.\n\n  2. Type `make' to compile the package.\n\n  3. Optionally, type `make check' to run any self-tests that come with\n     the package.\n\n  4. Type `make install' to install the programs and any data files and\n     documentation.\n\n  5. You can remove the program binaries and object files from the\n     source code directory by typing `make clean'.  To also remove the\n     files that `configure' created (so you can compile the package for\n     a different kind of computer), type `make distclean'.  There is\n     also a `make maintainer-clean' target, but that is intended mainly\n     for the package's developers.  If you use it, you may have to get\n     all sorts of other programs in order to regenerate files that came\n     with the distribution.\n\nCompilers and Options\n=====================\n\n   Some systems require unusual options for compilation or linking that\nthe `configure' script does not know about.  Run `./configure --help'\nfor details on some of the pertinent environment variables.\n\n   You can give `configure' initial values for configuration parameters\nby setting variables in the command line or in the environment.  Here\nis an example:\n\n     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix\n\n   *Note Defining Variables::, for more details.\n\nCompiling For Multiple Architectures\n====================================\n\n   You can compile the package for more than one kind of computer at the\nsame time, by placing the object files for each architecture in their\nown directory.  To do this, you must use a version of `make' that\nsupports the `VPATH' variable, such as GNU `make'.  `cd' to the\ndirectory where you want the object files and executables to go and run\nthe `configure' script.  `configure' automatically checks for the\nsource code in the directory that `configure' is in and in `..'.\n\n   If you have to use a `make' that does not support the `VPATH'\nvariable, you have to compile the package for one architecture at a\ntime in the source code directory.  After you have installed the\npackage for one architecture, use `make distclean' before reconfiguring\nfor another architecture.\n\nInstallation Names\n==================\n\n   By default, `make install' will install the package's files in\n`/usr/local/bin', `/usr/local/man', etc.  You can specify an\ninstallation prefix other than `/usr/local' by giving `configure' the\noption `--prefix=PATH'.\n\n   You can specify separate installation prefixes for\narchitecture-specific files and architecture-independent files.  If you\ngive `configure' the option `--exec-prefix=PATH', the package will use\nPATH as the prefix for installing programs and libraries.\nDocumentation and other data files will still use the regular prefix.\n\n   In addition, if you use an unusual directory layout you can give\noptions like `--bindir=PATH' to specify different values for particular\nkinds of files.  Run `configure --help' for a list of the directories\nyou can set and what kinds of files go in them.\n\n   If the package supports it, you can cause programs to be installed\nwith an extra prefix or suffix on their names by giving `configure' the\noption `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.\n\nOptional Features\n=================\n\n   Some packages pay attention to `--enable-FEATURE' options to\n`configure', where FEATURE indicates an optional part of the package.\nThey may also pay attention to `--with-PACKAGE' options, where PACKAGE\nis something like `gnu-as' or `x' (for the X Window System).  The\n`README' should mention any `--enable-' and `--with-' options that the\npackage recognizes.\n\n   For packages that use the X Window System, `configure' can usually\nfind the X include and library files automatically, but if it doesn't,\nyou can use the `configure' options `--x-includes=DIR' and\n`--x-libraries=DIR' to specify their locations.\n\nSpecifying the System Type\n==========================\n\n   There may be some features `configure' cannot figure out\nautomatically, but needs to determine by the type of machine the package\nwill run on.  Usually, assuming the package is built to be run on the\n_same_ architectures, `configure' can figure that out, but if it prints\na message saying it cannot guess the machine type, give it the\n`--build=TYPE' option.  TYPE can either be a short name for the system\ntype, such as `sun4', or a canonical name which has the form:\n\n     CPU-COMPANY-SYSTEM\n\nwhere SYSTEM can have one of these forms:\n\n     OS KERNEL-OS\n\n   See the file `config.sub' for the possible values of each field.  If\n`config.sub' isn't included in this package, then this package doesn't\nneed to know the machine type.\n\n   If you are _building_ compiler tools for cross-compiling, you should\nuse the `--target=TYPE' option to select the type of system they will\nproduce code for.\n\n   If you want to _use_ a cross compiler, that generates code for a\nplatform different from the build platform, you should specify the\n\"host\" platform (i.e., that on which the generated programs will\neventually be run) with `--host=TYPE'.\n\nSharing Defaults\n================\n\n   If you want to set default values for `configure' scripts to share,\nyou can create a site shell script called `config.site' that gives\ndefault values for variables like `CC', `cache_file', and `prefix'.\n`configure' looks for `PREFIX/share/config.site' if it exists, then\n`PREFIX/etc/config.site' if it exists.  Or, you can set the\n`CONFIG_SITE' environment variable to the location of the site script.\nA warning: not all `configure' scripts look for a site script.\n\nDefining Variables\n==================\n\n   Variables not defined in a site shell script can be set in the\nenvironment passed to `configure'.  However, some packages may run\nconfigure again during the build, and the customized values of these\nvariables may be lost.  In order to avoid this problem, you should set\nthem in the `configure' command line, using `VAR=value'.  For example:\n\n     ./configure CC=/usr/local2/bin/gcc\n\nwill cause the specified gcc to be used as the C compiler (unless it is\noverridden in the site shell script).\n\n`configure' Invocation\n======================\n\n   `configure' recognizes the following options to control how it\noperates.\n\n`--help'\n`-h'\n     Print a summary of the options to `configure', and exit.\n\n`--version'\n`-V'\n     Print the version of Autoconf used to generate the `configure'\n     script, and exit.\n\n`--cache-file=FILE'\n     Enable the cache: use and save the results of the tests in FILE,\n     traditionally `config.cache'.  FILE defaults to `/dev/null' to\n     disable caching.\n\n`--config-cache'\n`-C'\n     Alias for `--cache-file=config.cache'.\n\n`--quiet'\n`--silent'\n`-q'\n     Do not print messages saying which checks are being made.  To\n     suppress all normal output, redirect it to `/dev/null' (any error\n     messages will still be shown).\n\n`--srcdir=DIR'\n     Look for the package's source code in directory DIR.  Usually\n     `configure' can determine that directory automatically.\n\n`configure' also accepts some other, not widely useful, options.  Run\n`configure --help' for more details.\n\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 28.4541015625,
          "content": "# Makefile to build sysstat commands\n# (C) 1999-2023 Sebastien GODARD (sysstat <at> orange.fr)\n\n# Version and package name\nVERSION = @PACKAGE_VERSION@\nPACKAGE = @PACKAGE_NAME@\n# Needed by docdir\nPACKAGE_TARNAME = $(PACKAGE)-$(VERSION)\n\n# Compiler to use\nCC = @CC@\n\n# Other commands\nCHMOD = @CHMOD@\nCHOWN = @CHOWN@\nLN_S = @LN_S@\nAR = @AR@\n# Full path to prevent from using aliases\nCP = @PATH_CP@\n\nCHKCONFIG = @PATH_CHKCONFIG@\nINSTALL = @INSTALL@\nINSTALL_DATA = @INSTALL_DATA@\nINSTALL_BIN = @INSTALL_BIN@\n\nifndef HAVE_SENSORS\nHAVE_SENSORS = @HAVE_SENSORS@\nendif\nLFSENSORS =\nDFSENSORS =\nifeq ($(HAVE_SENSORS),y)\nLFSENSORS = @LFSENSORS@\nDFSENSORS = @DFSENSORS@\nendif\nifndef HAVE_SENSORS32\nHAVE_SENSORS32 = @HAVE_SENSORS32@\nendif\nLFSENSORS32 =\nDFSENSORS32 =\nifeq ($(HAVE_SENSORS32),y)\nLFSENSORS32 = @LFSENSORS32@\nDFSENSORS32 = @DFSENSORS32@\nendif\n\nHAVE_PCP = @HAVE_PCP@\nLFPCP =\nDFPCP =\nifeq ($(HAVE_PCP),y)\nLFPCP = @LFPCP@\nDFPCP = @DFPCP@\nendif\n\n# Directories\nifndef PREFIX\nPREFIX = @prefix@\nendif\nifndef DESTDIR\nDESTDIR = $(RPM_BUILD_ROOT)\nendif\n# These two variables are needed by other ones (eg bindir)\nprefix = $(PREFIX)\nexec_prefix = @exec_prefix@\ndatarootdir = @datarootdir@\n\nifndef SA_LIB_DIR\nSA_LIB_DIR = @SA_LIB_DIR@\nendif\nSADC_PATH = $(SA_LIB_DIR)/sadc\nifndef SA_DIR\nSA_DIR = @SA_DIR@\nendif\nBIN_DIR = @bindir@\n\nifndef MAN_DIR\n# With recent versions of autoconf, mandir defaults to ${datarootdir}/man\n# (i.e. $prefix/share/man)\nMAN_DIR = @mandir@\nendif\nMAN1_DIR = $(MAN_DIR)/man1\nMAN5_DIR = $(MAN_DIR)/man5\nMAN8_DIR = $(MAN_DIR)/man8\n\nifndef DOC_DIR\nDOC_DIR = @docdir@\nendif\n\nNLS_DIR = $(PREFIX)/share/locale\n\nifndef SYSCONFIG_DIR\nSYSCONFIG_DIR = @SYSCONFIG_DIR@\nendif\nifndef SYSCONFIG_FILE\nSYSCONFIG_FILE = @SYSCONFIG_FILE@\nendif\n\n# Compiler flags\nifndef CFLAGS\nCFLAGS = @CFLAGS@\nendif\nCFLAGS += -Wall -Wstrict-prototypes -pipe -O2 -fno-tree-slp-vectorize\n\nifndef DFLAGS\nDFLAGS = @DFLAGS@\nendif\nDFLAGS += -DSA_DIR=\\\"$(SA_DIR)\\\" -DSADC_PATH=\\\"$(SADC_PATH)\\\"\nDFLAGS += $(DFSENSORS) $(DFSENSORS32)\nDFLAGS += $(DFPCP)\nifdef TFLAGS\nDFLAGS += $(TFLAGS)\nendif\n\nifndef LFLAGS\nLFLAGS = @STRIP@ @LDFLAGS@\nendif\n\n# Commands\nifndef MSGFMT\nMSGFMT = @MSGFMT@\nendif\nifndef XGETTEXT\nXGETTEXT = @XGETTEXT@\nendif\nifndef MSGMERGE\nMSGMERGE = @MSGMERGE@\nendif\nifndef ZIP\nZIP = @ZIP@\nendif\n\n# Settings\nSYSMACROS = @SYSMACROS@\nifeq ($(SYSMACROS),y)\n\tDFLAGS += -DHAVE_SYS_SYSMACROS_H\nendif\nLINUX_SCHED = @LINUX_SCHED@\nifeq ($(LINUX_SCHED),y)\n\tDFLAGS += -DHAVE_LINUX_SCHED_H\nendif\nPCP_IMPL = @PCP_IMPL@\nifeq ($(PCP_IMPL),y)\n\tDFLAGS += -DHAVE_PCP_IMPL_H\nendif\nSYSPARAM = @SYSPARAM@\nifeq ($(SYSPARAM),y)\n\tDFLAGS += -DHAVE_SYS_PARAM_H\nendif\n\nifndef TGLIB32\nTGLIB32 = @TGLIB32@\nendif\n\nifndef NLS\nNLS = @NLS@\nendif\nLFLAGS += @LFINTL@\nifeq ($(NLS),y)\nREQUIRE_NLS = -DUSE_NLS -DPACKAGE=\\\"$(PACKAGE)\\\" -DLOCALEDIR=\\\"$(NLS_DIR)\\\"\nendif\nifdef REQUIRE_NLS\n\tDFLAGS += $(REQUIRE_NLS)\nendif\n\nifndef LTO\nLTO = @LTO@\nendif\nifndef GCC_AR\nGCC_AR = @GCC_AR@\nendif\nifeq ($(LTO),y)\nAR = $(GCC_AR)\nCFLAGS += -flto=auto\nLD = gcc\nLDFLAGS += $(CFLAGS)\nendif\n\nifndef INSTALL_CRON\nINSTALL_CRON = @INSTALL_CRON@\nendif\nifndef CRON_OWNER\nCRON_OWNER = @CRON_OWNER@\nendif\n\nMAN_GROUP = @MAN_GROUP@\nifndef IGNORE_FILE_ATTRIBUTES\nIGNORE_FILE_ATTRIBUTES = @IGNORE_FILE_ATTRIBUTES@\nendif\nifeq ($(IGNORE_FILE_ATTRIBUTES),y)\nMANGRPARG =\nelse\nMANGRPARG = -g $(MAN_GROUP)\nendif\nifndef CLEAN_SA_DIR\nCLEAN_SA_DIR = @CLEAN_SA_DIR@\nendif\nifndef COMPRESS_MANPG\nCOMPRESS_MANPG = @COMPRESS_MANPG@\nendif\nifndef INSTALL_DOC\nINSTALL_DOC = @INSTALL_DOC@\nendif\nifndef COPY_ONLY\nCOPY_ONLY = @COPY_ONLY@\nendif\n\n# Systemd\nSYSTEMCTL = @SYSTEMCTL@\nSYSTEMD_UNIT_DIR = @SYSTEMD_UNIT_DIR@\nSYSTEMD_SLEEP_DIR = @SYSTEMD_SLEEP_DIR@\n\nifndef USE_CROND\nUSE_CROND = @USE_CROND@\nendif\nifeq ($(USE_CROND),y)\nSYSTEMD_UNIT_DIR =\nendif\n\n# Run-command directories\nifndef RC_DIR\nRC_DIR = @RC_DIR@\nendif\nRC0_DIR = $(RC_DIR)/rc0.d\nRC1_DIR = $(RC_DIR)/rc1.d\nRC2_DIR = $(RC_DIR)/rc2.d\nRC3_DIR = $(RC_DIR)/rc3.d\nRC4_DIR = $(RC_DIR)/rc4.d\nRC5_DIR = $(RC_DIR)/rc5.d\nRC6_DIR = $(RC_DIR)/rc6.d\nifndef INIT_DIR\nINIT_DIR = @INIT_DIR@\nendif\nifndef INITD_DIR\nINITD_DIR = @INITD_DIR@\nendif\n\nSOURCE_CODE= $(wildcard *.c *.h)\n\nNLSPO= $(wildcard nls/*.po)\nNLSGMO= $(NLSPO:.po=.gmo)\nNLSPOT= $(NLSPO:.po=.pot)\n\n%.gmo: %.po\n\t$(MSGFMT) -o $@ $<\n\n%.pot: %.po\n\t$(MSGMERGE) -U $< nls/sysstat.pot\n\n%.o: %.c\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\n% : %.o\n\t$(CC) -o $@ $(CFLAGS) $^ $(LFLAGS)\n\nall: sadc sar sadf iostat tapestat mpstat pidstat cifsiostat locales\n\ncommon_light.o: common.c version.h common.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ncommon.o: common.c version.h common.h\n\nsystest.o: systest.c systest.h\n\nsa_common_light.o: sa_common.c version.h sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\nsa_common.o: sa_common.c version.h sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\nioconf.o: ioconf.c ioconf.h common.h sysconfig.h\n\nact_sadc.o: activity.c sa.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\nact_sar.o: activity.c sa.h common.h rd_stats.h rd_sensors.h pr_stats.h pr_xstats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SAR $(DFLAGS) $<\n\nact_sadf.o: activity.c sa.h common.h rd_stats.h rd_sensors.h rndr_stats.h xml_stats.h json_stats.h svg_stats.h raw_stats.h pcp_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADF $(DFLAGS) $<\n\nrd_stats.o: rd_stats.c common.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\nrd_stats_light.o: rd_stats.c common.h rd_stats.h ioconf.h sysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ncount.o: count.c common.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ncount_light.o: count.c common.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\nrd_sensors.o: rd_sensors.c common.h rd_sensors.h rd_stats.h\n\npr_stats.o: pr_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h pr_xstats.h\n\npr_xstats.o: pr_xstats.c sa.h common.h rd_stats.h rd_sensors.h\n\nrndr_stats.o: rndr_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h rndr_stats.h\n\nxml_stats.o: xml_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\njson_stats.o: json_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\nsvg_stats.o: svg_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\nraw_stats.o: raw_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\npcp_stats.o: pcp_stats.c common.h rd_stats.h rd_sensors.h sa.h\n\nsa_wrap.o: sa_wrap.c sa.h common.h rd_stats.h count.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\nformat_sadf.o: format.c sadf.h sa.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADF $(DFLAGS) $<\n\nformat_sar.o: format.c sa.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SAR $(DFLAGS) $<\n\npcp_def_metrics.o: pcp_def_metrics.c common.h sa.h rd_stats.h rd_sensors.h\n\nsadf_misc.o: sadf_misc.c sadf.h pcp_def_metrics.h sa.h common.h rd_stats.h rd_sensors.h\n\nsa_conv.o: sa_conv.c version.h sadf.h sa.h common.h rd_stats.h rd_sensors.h sa_conv.h\n\n# Explicit rules needed to prevent possible file corruption\n# when using parallel execution.\nlibsyscom.a: common.o ioconf.o systest.o\n\t$(AR) rvs $@ $?\n\n# Ditto\nlibrdstats.a: rd_stats.o count.o\n\t$(AR) rvs $@ $?\n\nlibrdstats_light.a: rd_stats_light.o count_light.o\n\t$(AR) rvs $@ $?\n\n# librdsensors.a: librdsensors.a(rd_sensors.o)\nlibrdsensors.a: rd_sensors.o\n\t$(AR) rvs $@ $?\n\nsadc.o: sadc.c sa.h version.h common.h rd_stats.h rd_sensors.h\n\nsadc: LFLAGS += $(LFSENSORS)\n\nsadc: sadc.o act_sadc.o sa_wrap.o sa_common_light.o common_light.o systest.o librdstats.a librdsensors.a libsyscom.a\n\nsar.o: sar.c sa.h version.h common.h rd_stats.h rd_sensors.h\n\nsar: sar.o act_sar.o format_sar.o sa_common.o pr_stats.o pr_xstats.o librdstats_light.a libsyscom.a\n\nsadf.o: sadf.c sadf.h version.h sa.h common.h rd_stats.h rd_sensors.h\n\nsadf: LFLAGS += $(LFPCP)\n\nsadf: sadf.o act_sadf.o format_sadf.o sadf_misc.o pcp_def_metrics.o sa_conv.o rndr_stats.o xml_stats.o json_stats.o svg_stats.o raw_stats.o pcp_stats.o sa_common.o librdstats_light.a libsyscom.a\n\niostat.o: iostat.c iostat.h version.h common.h ioconf.h sysconfig.h rd_stats.h count.h\n\niostat: iostat.o librdstats_light.a libsyscom.a\n\ntapestat.o: tapestat.c tapestat.h version.h common.h count.h rd_stats.h\n\ntapestat: tapestat.o librdstats_light.a libsyscom.a\n\npidstat.o: pidstat.c pidstat.h version.h common.h rd_stats.h count.h\n\npidstat: pidstat.o librdstats_light.a libsyscom.a\n\nmpstat.o: mpstat.c mpstat.h version.h common.h rd_stats.h count.h\n\nmpstat: mpstat.o librdstats_light.a libsyscom.a\n\ncifsiostat.o: cifsiostat.c cifsiostat.h count.h rd_stats.h version.h common.h\n\ncifsiostat: cifsiostat.o librdstats_light.a libsyscom.a\n\n# inisar: Old sar version\n\ntests/ini/sa_common.o: tests/ini/sa_common.c tests/ini/iniversion.h tests/ini/sa.h tests/ini/common.h tests/ini/rd_stats.h tests/ini/rd_sensors.h tests/ini/ioconf.h tests/ini/inisysconfig.h\n\ntests/ini/act_sar.o: tests/ini/activity.c tests/ini/sa.h tests/ini/common.h tests/ini/rd_stats.h tests/ini/rd_sensors.h tests/ini/pr_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SAR $(DFLAGS) $<\n\ntests/ini/rd_stats_light.o: tests/ini/rd_stats.c tests/ini/common.h tests/ini/rd_stats.h tests/ini/ioconf.h tests/ini/inisysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/ini/count_light.o: tests/ini/count.c tests/ini/common.h tests/ini/rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/ini/libsyscom.a: tests/ini/common.o tests/ini/ioconf.o\n\t$(AR) rvs $@ $?\n\ntests/ini/format_sar.o: tests/ini/format.c tests/ini/sa.h tests/ini/common.h tests/ini/rd_stats.h tests/ini/rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SAR $(DFLAGS) $<\n\ntests/ini/pr_stats.o: tests/ini/pr_stats.c tests/ini/sa.h tests/ini/common.h tests/ini/rd_stats.h tests/ini/rd_sensors.h tests/ini/ioconf.h tests/ini/inisysconfig.h tests/ini/pr_stats.h\n\ntests/ini/librdstats_light.a: tests/ini/rd_stats_light.o tests/ini/count_light.o\n\t$(AR) rvs $@ $?\n\ntests/ini/inisar.o: tests/ini/inisar.c tests/ini/sa.h tests/ini/iniversion.h tests/ini/common.h tests/ini/rd_stats.h tests/ini/rd_sensors.h\n\ntests/ini/inisar: tests/ini/inisar.o tests/ini/act_sar.o tests/ini/format_sar.o tests/ini/sa_common.o tests/ini/pr_stats.o tests/ini/librdstats_light.a tests/ini/libsyscom.a\n\n# sar32/sadc32: 32-bit versions of sar/sadc\ntests/32bits/sadc32.o: sadc.c sa.h version.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/sar32.o: sar.c sa.h version.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/act_sadc32.o: activity.c sa.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ntests/32bits/act_sar32.o: activity.c sa.h common.h rd_stats.h rd_sensors.h pr_stats.h pr_xstats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SAR $(DFLAGS) $<\n\ntests/32bits/sa_wrap32.o: sa_wrap.c sa.h common.h rd_stats.h count.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ntests/32bits/sa_common_light32.o: sa_common.c version.h sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ntests/32bits/sa_common32.o: sa_common.c version.h sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/common_light32.o: common.c version.h common.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ntests/32bits/systest32.o: systest.c systest.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/libsyscom32.a: tests/32bits/common32.o tests/32bits/ioconf32.o tests/32bits/systest32.o\n\t$(AR) rvs $@ $?\n\ntests/32bits/librdstats32.a: tests/32bits/rd_stats32.o tests/32bits/count32.o\n\t$(AR) rvs $@ $?\n\ntests/32bits/librdstats_light32.a: tests/32bits/rd_stats_light32.o tests/32bits/count_light32.o\n\t$(AR) rvs $@ $?\n\ntests/32bits/librdsensors32.a: tests/32bits/rd_sensors32.o\n\t$(AR) rvs $@ $?\n\ntests/32bits/rd_stats32.o: rd_stats.c common.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ntests/32bits/rd_stats_light32.o: rd_stats.c common.h rd_stats.h ioconf.h sysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/count32.o: count.c common.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SADC $(DFLAGS) $<\n\ntests/32bits/count_light32.o: count.c common.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/format_sar32.o: format.c sa.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) -DSOURCE_SAR $(DFLAGS) $<\n\ntests/32bits/pr_stats32.o: pr_stats.c sa.h common.h rd_stats.h rd_sensors.h ioconf.h sysconfig.h pr_stats.h pr_xstats.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/pr_xstats32.o: pr_xstats.c sa.h common.h rd_stats.h rd_sensors.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/common32.o: common.c version.h common.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/ioconf32.o: ioconf.c ioconf.h common.h sysconfig.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/rd_sensors32.o: rd_sensors.c common.h rd_sensors.h rd_stats.h\n\t$(CC) -o $@ -c $(CFLAGS) $(DFLAGS) $<\n\ntests/32bits/sadc32: LFLAGS += $(LFSENSORS32)\n\ntests/32bits/sadc32: tests/32bits/sadc32.o tests/32bits/act_sadc32.o tests/32bits/sa_wrap32.o tests/32bits/sa_common_light32.o tests/32bits/common_light32.o tests/32bits/systest32.o tests/32bits/librdstats32.a tests/32bits/librdsensors32.a\n\ntests/32bits/sar32: tests/32bits/sar32.o tests/32bits/act_sar32.o tests/32bits/format_sar32.o tests/32bits/sa_common32.o tests/32bits/pr_stats32.o tests/32bits/pr_xstats32.o tests/32bits/librdstats_light32.a tests/32bits/libsyscom32.a\n\nifdef REQUIRE_NLS\nlocales: $(NLSGMO)\nelse\nlocales:\nendif\n\nnls/sysstat.pot: $(wildcard *.c)\n\t$(XGETTEXT) -o $@ -k_ --msgid-bugs-address=\"sysstat <at> orange.fr\" $^\n\n# Phony targets\n.PHONY: clean distclean install install_base install_all uninstall copyyear \\\n\tuninstall_base uninstall_all dist bdist xdist gitdist squeeze simtest extratest\n\ninstall_man: man/sadc.8 man/sar.1 man/sadf.1 man/sa1.8 man/sa2.8 man/sysstat.5\nifeq ($(INSTALL_DOC),y)\n\tmkdir -p $(DESTDIR)$(MAN1_DIR)\n\tmkdir -p $(DESTDIR)$(MAN5_DIR)\n\tmkdir -p $(DESTDIR)$(MAN8_DIR)\n\trm -f $(DESTDIR)$(MAN8_DIR)/sa1.8*\n\t$(INSTALL_DATA) $(MANGRPARG) man/sa1.8 $(DESTDIR)$(MAN8_DIR)\n\trm -f $(DESTDIR)$(MAN8_DIR)/sa2.8*\n\t$(INSTALL_DATA) $(MANGRPARG) man/sa2.8 $(DESTDIR)$(MAN8_DIR)\n\trm -f $(DESTDIR)$(MAN8_DIR)/sadc.8*\n\t$(INSTALL_DATA) $(MANGRPARG) man/sadc.8 $(DESTDIR)$(MAN8_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/sar.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/sar.1 $(DESTDIR)$(MAN1_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/sadf.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/sadf.1 $(DESTDIR)$(MAN1_DIR)\n\trm -f $(DESTDIR)$(MAN5_DIR)/sysstat.5*\n\t$(INSTALL_DATA) $(MANGRPARG) man/sysstat.5 $(DESTDIR)$(MAN5_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/iostat.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/iostat.1 $(DESTDIR)$(MAN1_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/tapestat.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/tapestat.1 $(DESTDIR)$(MAN1_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/mpstat.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/mpstat.1 $(DESTDIR)$(MAN1_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/pidstat.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/pidstat.1 $(DESTDIR)$(MAN1_DIR)\n\trm -f $(DESTDIR)$(MAN1_DIR)/cifsiostat.1*\n\t$(INSTALL_DATA) $(MANGRPARG) man/cifsiostat.1 $(DESTDIR)$(MAN1_DIR)\nifeq ($(COMPRESS_MANPG),y)\n\t$(ZIP) $(DESTDIR)$(MAN8_DIR)/sa1.8\n\t$(ZIP) $(DESTDIR)$(MAN8_DIR)/sa2.8\n\t$(ZIP) $(DESTDIR)$(MAN8_DIR)/sadc.8\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/sar.1\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/sadf.1\n\t$(ZIP) $(DESTDIR)$(MAN5_DIR)/sysstat.5\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/iostat.1\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/tapestat.1\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/mpstat.1\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/pidstat.1\n\t$(ZIP) $(DESTDIR)$(MAN1_DIR)/cifsiostat.1\nendif\nendif\n\nsqueeze:\n\tcatalogs=\"$(SOURCE_CODE)\"; \\\n\tfor c in $$catalogs; do \\\n\t\techo \"Squeezing file: $$c\"; \\\n\t\tsed 's/[\\t ]*$$//g' $$c > squeeze.tmp; \\\n\t\tmv squeeze.tmp $$c; \\\n\tdone\n\n# Update Makefile.in by hand - Restore mode for iconfig.\ncopyyear:\n\tcatalogs=\"$(SOURCE_CODE) iconfig do_test README.md sa1.in sa2.in sysconfig.in sysstat.in version.in\"; \\\n\tfor c in $$catalogs; do \\\n\t\techo \"Updating file: $$c\"; \\\n\t\tsed 's/-2023/-2024/g' $$c > copyyear.tmp; \\\n\t\tmv copyyear.tmp $$c; \\\n\tdone\n\tchmod 755 iconfig do_test\n\ninstall_nls: locales\nifdef REQUIRE_NLS\n\tcatalogs='$(NLSGMO)'; \\\n\tfor c in $$catalogs; do \\\n\t\tc=`basename $$c`; \\\n\t\tc=`echo $$c | sed 's/\\.gmo$$//'`; \\\n\t\tmkdir -p $(DESTDIR)$(NLS_DIR)/$$c/LC_MESSAGES; \\\n\t\techo \"NLS: Installing $$c file...\" ; \\\n\t\t$(INSTALL_DATA) nls/$$c.gmo $(DESTDIR)$(NLS_DIR)/$$c/LC_MESSAGES/$(PACKAGE).mo; \\\n\tdone\nendif\n\ninstall_base: all sa1 sa2 sysstat.sysconfig install_man install_nls\n\tmkdir -p $(DESTDIR)$(SA_LIB_DIR)\n\tmkdir -p $(DESTDIR)$(SA_DIR)\nifeq ($(CLEAN_SA_DIR),y)\n\tfind $(DESTDIR)$(SA_DIR) -type f | grep -E \"/sar?[0-9]{2,8}(\\.(Z|gz|bz2|xz|lz|lzo))?$$\" | xargs rm -f\n\tfind $(DESTDIR)$(SA_DIR) -type f | grep -E \"/sar?[0-9]{2,8}$$\" | xargs rm -f\nendif\n\tmkdir -p $(DESTDIR)$(BIN_DIR)\n\tmkdir -p $(DESTDIR)$(DOC_DIR)\n\tmkdir -p $(DESTDIR)$(SYSCONFIG_DIR)\n\t$(INSTALL_BIN) sa1 $(DESTDIR)$(SA_LIB_DIR)\n\t$(INSTALL_BIN) sa2 $(DESTDIR)$(SA_LIB_DIR)\n\t$(INSTALL_BIN) sadc $(DESTDIR)$(SA_LIB_DIR)\n\t$(INSTALL_BIN) sar $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_BIN) sadf $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_BIN) iostat $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_BIN) tapestat $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_BIN) mpstat $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_BIN) pidstat $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_BIN) cifsiostat $(DESTDIR)$(BIN_DIR)\n\t$(INSTALL_DATA) sysstat.ioconf $(DESTDIR)$(SYSCONFIG_DIR)\n\t$(INSTALL_DATA) sysstat.sysconfig $(DESTDIR)$(SYSCONFIG_DIR)/$(SYSCONFIG_FILE)\nifeq ($(INSTALL_DOC),y)\n\t$(INSTALL_DATA) CHANGES $(DESTDIR)$(DOC_DIR)\n\t$(INSTALL_DATA) COPYING $(DESTDIR)$(DOC_DIR)\n\t$(INSTALL_DATA) CREDITS $(DESTDIR)$(DOC_DIR)\n\t$(INSTALL_DATA) README.md $(DESTDIR)$(DOC_DIR)\n\t$(INSTALL_DATA) FAQ.md $(DESTDIR)$(DOC_DIR)\nendif\n\nifdef SYSTEMD_UNIT_DIR\ninstall_all: install_base cron/sysstat-collect.service cron/sysstat-collect.timer \\\n\tcron/sysstat.sleep cron/sysstat-summary.service cron/sysstat-summary.timer \\\n\tcron/sysstat-rotate.service cron/sysstat-rotate.timer\nelse\ninstall_all: install_base cron/crontab sysstat \\\n\tcron/sysstat.crond cron/sysstat.cron.daily cron/sysstat.cron.hourly\nendif\n\nifneq ($(IGNORE_FILE_ATTRIBUTES),y)\n\t$(CHOWN) $(CRON_OWNER) $(DESTDIR)$(SA_DIR)\nendif\nifdef SYSTEMD_UNIT_DIR\n\tmkdir -p $(DESTDIR)$(SYSTEMD_UNIT_DIR)\nelse\n\tif [ -d /etc/cron.d ]; then \\\n\t\tmkdir -p $(DESTDIR)/etc/cron.d; \\\n\telif [ -d /etc/cron.hourly -a -d /etc/cron.daily ]; then \\\n\t\tmkdir -p $(DESTDIR)/etc/cron.hourly $(DESTDIR)/etc/cron.daily; \\\n\tfi\n\tif [ -d $(INIT_DIR) ]; then \\\n\t\tmkdir -p $(DESTDIR)$(INIT_DIR); \\\n\telif [ -d $(RC_DIR) ]; then \\\n\t\tmkdir -p $(DESTDIR)$(RC_DIR); \\\n\tfi\nendif\n\nifdef SYSTEMD_SLEEP_DIR\n\tmkdir -p $(DESTDIR)$(SYSTEMD_SLEEP_DIR)\nendif\n\n\tif [ -z \"$(SYSTEMD_UNIT_DIR)\" -o ! -d \"$(DESTDIR)$(SYSTEMD_UNIT_DIR)\" ]; then \\\n\t\tif [ -d $(DESTDIR)/etc/cron.d ]; then \\\n\t\t\t$(INSTALL_DATA) cron/sysstat.crond $(DESTDIR)/etc/cron.d/sysstat; \\\n\t\telif [ -d $(DESTDIR)/etc/cron.hourly -a -d $(DESTDIR)/etc/cron.daily ]; then \\\n\t\t\t$(INSTALL_BIN) cron/sysstat.cron.hourly $(DESTDIR)/etc/cron.hourly/sysstat; \\\n\t\t\t$(INSTALL_BIN) cron/sysstat.cron.daily $(DESTDIR)/etc/cron.daily/sysstat; \\\n\t\tfi \\\n\tfi\nifeq ($(COPY_ONLY),n)\n\tif [ \\( -z \"$(SYSTEMD_UNIT_DIR)\" -o ! -d \"$(DESTDIR)$(SYSTEMD_UNIT_DIR)\" \\) -a ! -d $(DESTDIR)/etc/cron.d ]; then \\\n\t\tif [ ! -d $(DESTDIR)/etc/cron.hourly -o ! -d $(DESTDIR)/etc/cron.daily ]; then \\\n\t\t\tsu $(CRON_OWNER) -c \"crontab -l > /tmp/crontab-$(CRON_OWNER).save\"; \\\n\t\t\t$(CP) -a /tmp/crontab-$(CRON_OWNER).save ./crontab-$(CRON_OWNER).`date '+%Y%m%d.%H%M%S'`.save; \\\n\t\t\techo \"USER'S PREVIOUS CRONTAB SAVED IN CURRENT DIRECTORY (USING .save SUFFIX).\"; \\\n\t\t\tsu $(CRON_OWNER) -c \"crontab cron/crontab\"; \\\n\t\tfi \\\n\tfi\nendif\n\tif [ -n \"$(SYSTEMD_UNIT_DIR)\" -a -d \"$(DESTDIR)$(SYSTEMD_UNIT_DIR)\" ]; then \\\n\t\t$(INSTALL_DATA) sysstat.service $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\t\t$(INSTALL_DATA) cron/sysstat-collect.service $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\t\t$(INSTALL_DATA) cron/sysstat-collect.timer $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\t\t$(INSTALL_DATA) cron/sysstat-summary.service $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\t\t$(INSTALL_DATA) cron/sysstat-summary.timer $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\t\t$(INSTALL_DATA) cron/sysstat-rotate.service $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\t\t$(INSTALL_DATA) cron/sysstat-rotate.timer $(DESTDIR)$(SYSTEMD_UNIT_DIR); \\\n\telif [ -d $(DESTDIR)$(INIT_DIR) ]; then \\\n\t\t$(INSTALL_BIN) sysstat $(DESTDIR)$(INIT_DIR)/sysstat; \\\n\t\tif [ \"$(COPY_ONLY)\" = \"n\" ]; then \\\n\t\t\tif [ -x \"$(CHKCONFIG)\" ]; then \\\n\t\t\t\tcd $(DESTDIR)$(INIT_DIR) && $(CHKCONFIG) --add sysstat; \\\n\t\t\telse \\\n\t\t\t\t[ -d $(DESTDIR)$(RC2_DIR) ] || mkdir -p $(DESTDIR)$(RC2_DIR); \\\n\t\t\t\t[ -d $(DESTDIR)$(RC3_DIR) ] || mkdir -p $(DESTDIR)$(RC3_DIR); \\\n\t\t\t\t[ -d $(DESTDIR)$(RC5_DIR) ] || mkdir -p $(DESTDIR)$(RC5_DIR); \\\n\t\t\t\tcd $(DESTDIR)$(RC2_DIR) && $(LN_S) -f ../$(INITD_DIR)/sysstat S01sysstat; \\\n\t\t\t\tcd $(DESTDIR)$(RC3_DIR) && $(LN_S) -f ../$(INITD_DIR)/sysstat S01sysstat; \\\n\t\t\t\tcd $(DESTDIR)$(RC5_DIR) && $(LN_S) -f ../$(INITD_DIR)/sysstat S01sysstat; \\\n\t\t\tfi \\\n\t\tfi \\\n\telif [ -d $(DESTDIR)$(RC_DIR) ]; then \\\n\t\t$(INSTALL_BIN) sysstat $(DESTDIR)$(RC_DIR)/rc.sysstat; \\\n\t\tif [ \"$(COPY_ONLY)\" = \"n\" ]; then \\\n\t\t\tif [ -x \"$(CHKCONFIG)\" ]; then \\\n\t\t\t\tcd $(DESTDIR)$(RC_DIR) && $(CHKCONFIG) --add rc.sysstat; \\\n\t\t\telse \\\n\t\t\t\t[ -d $(DESTDIR)$(RC2_DIR) ] || mkdir -p $(DESTDIR)$(RC2_DIR); \\\n\t\t\t\t[ -d $(DESTDIR)$(RC3_DIR) ] || mkdir -p $(DESTDIR)$(RC3_DIR); \\\n\t\t\t\t[ -d $(DESTDIR)$(RC5_DIR) ] || mkdir -p $(DESTDIR)$(RC5_DIR); \\\n\t\t\t\tcd $(DESTDIR)$(RC2_DIR) && $(LN_S) -f ../rc.sysstat S01sysstat; \\\n\t\t\t\tcd $(DESTDIR)$(RC3_DIR) && $(LN_S) -f ../rc.sysstat S01sysstat; \\\n\t\t\t\tcd $(DESTDIR)$(RC5_DIR) && $(LN_S) -f ../rc.sysstat S01sysstat; \\\n\t\t\tfi \\\n\t\tfi \\\n\tfi\n\tif [ -n \"$(SYSTEMD_UNIT_DIR)\" -a -n \"$(SYSTEMD_SLEEP_DIR)\" -a -d \"$(DESTDIR)$(SYSTEMD_SLEEP_DIR)\" ]; then \\\n\t\t$(INSTALL_BIN) cron/sysstat.sleep $(DESTDIR)$(SYSTEMD_SLEEP_DIR); \\\n\tfi\n\nifeq ($(COPY_ONLY),n)\n\tif [ -n \"$(SYSTEMD_UNIT_DIR)\" -a -x \"$(SYSTEMCTL)\" ]; then \\\n\t\t$(SYSTEMCTL) enable sysstat.service; \\\n\tfi\nendif\n\nuninstall_man:\nifeq ($(INSTALL_DOC),y)\n\trm -f $(DESTDIR)$(MAN8_DIR)/sadc.8*\n\trm -f $(DESTDIR)$(MAN8_DIR)/sa1.8*\n\trm -f $(DESTDIR)$(MAN8_DIR)/sa2.8*\n\trm -f $(DESTDIR)$(MAN1_DIR)/sar.1*\n\trm -f $(DESTDIR)$(MAN1_DIR)/sadf.1*\n\trm -f $(DESTDIR)$(MAN5_DIR)/sysstat.5*\n\trm -f $(DESTDIR)$(MAN1_DIR)/iostat.1*\n\trm -f $(DESTDIR)$(MAN1_DIR)/tapestat.1*\n\trm -f $(DESTDIR)$(MAN1_DIR)/mpstat.1*\n\trm -f $(DESTDIR)$(MAN1_DIR)/pidstat.1*\n\trm -f $(DESTDIR)$(MAN1_DIR)/cifsiostat.1*\nendif\n\nuninstall_nls:\nifdef REQUIRE_NLS\n\t-catalogs='$(NLSGMO)'; \\\n\tfor c in $$catalogs; do \\\n\t\tc=`basename $$c`; \\\n\t\tc=`echo $$c | sed 's/\\.gmo$$//'`; \\\n\t\trm -f $(DESTDIR)$(PREFIX)/share/locale/$$c/LC_MESSAGES/$(PACKAGE).mo; \\\n\t\trmdir --ignore-fail-on-non-empty $(DESTDIR)$(PREFIX)/share/locale/$$c/LC_MESSAGES 2>/dev/null; \\\n\t\trmdir --ignore-fail-on-non-empty $(DESTDIR)$(PREFIX)/share/locale/$$c 2>/dev/null; \\\n\tdone\nendif\n\nuninstall_base: uninstall_man uninstall_nls\n\trm -f $(DESTDIR)$(SA_LIB_DIR)/sadc\n\trm -f $(DESTDIR)$(SA_LIB_DIR)/sa1\n\trm -f $(DESTDIR)$(SA_LIB_DIR)/sa2\n\trm -f $(DESTDIR)$(BIN_DIR)/sar\n\trm -f $(DESTDIR)$(BIN_DIR)/sadf\n\trm -f $(DESTDIR)$(BIN_DIR)/iostat\n\trm -f $(DESTDIR)$(BIN_DIR)/tapestat\n\trm -f $(DESTDIR)$(BIN_DIR)/mpstat\n\trm -f $(DESTDIR)$(BIN_DIR)/pidstat\n\trm -f $(DESTDIR)$(BIN_DIR)/cifsiostat\n\t-rmdir --ignore-fail-on-non-empty $(DESTDIR)$(SA_LIB_DIR)\n\t-rmdir --ignore-fail-on-non-empty $(DESTDIR)$(SA_DIR)/[0-9]?????\n\t-rmdir --ignore-fail-on-non-empty $(DESTDIR)$(SA_DIR)\n#\t\tNo need to keep sysstat scripts, config files and links since\n#\t\tthe binaries have been deleted.\n\trm -f $(DESTDIR)$(INIT_DIR)/sysstat\n\trm -f $(DESTDIR)$(RC_DIR)/rc.sysstat\n\trm -f $(DESTDIR)$(SYSCONFIG_DIR)/$(SYSCONFIG_FILE)\n\trm -f $(DESTDIR)$(SYSCONFIG_DIR)/sysstat.ioconf\n\trm -f $(DESTDIR)$(RC2_DIR)/S??sysstat\n\trm -f $(DESTDIR)$(RC2_DIR)/S??rc.sysstat\n\trm -f $(DESTDIR)$(RC3_DIR)/S??sysstat\n\trm -f $(DESTDIR)$(RC3_DIR)/S??rc.sysstat\n\trm -f $(DESTDIR)$(RC5_DIR)/S??sysstat\n\trm -f $(DESTDIR)$(RC5_DIR)/S??rc.sysstat\n#\t\tDelete possible kill entries installed by chkconfig\n\trm -f $(DESTDIR)$(RC0_DIR)/K??sysstat\n\trm -f $(DESTDIR)$(RC0_DIR)/K??rc.sysstat\n\trm -f $(DESTDIR)$(RC1_DIR)/K??sysstat\n\trm -f $(DESTDIR)$(RC1_DIR)/K??rc.sysstat\n\trm -f $(DESTDIR)$(RC4_DIR)/K??sysstat\n\trm -f $(DESTDIR)$(RC4_DIR)/K??rc.sysstat\n\trm -f $(DESTDIR)$(RC6_DIR)/K??sysstat\n\trm -f $(DESTDIR)$(RC6_DIR)/K??rc.sysstat\n#\t\tVixie cron entries also can be safely deleted here\n\trm -f $(DESTDIR)/etc/cron.d/sysstat\n#\t\tId. for Slackware cron entries\n\trm -f $(DESTDIR)/etc/cron.hourly/sysstat\n\trm -f $(DESTDIR)/etc/cron.daily/sysstat\nifeq ($(INSTALL_DOC),y)\n\trm -f $(DESTDIR)$(DOC_DIR)/*\n\t-rmdir $(DESTDIR)$(DOC_DIR)\nendif\n\t@echo \"Please ignore the errors above, if any.\"\n\nuninstall_all: uninstall_base\nifeq ($(COPY_ONLY),n)\n\t-if [ -z \"$(SYSTEMD_UNIT_DIR)\" -o ! -d \"$(DESTDIR)$(SYSTEMD_UNIT_DIR)\" ]; then \\\n\t\tsu $(CRON_OWNER) -c \"crontab -l > /tmp/crontab-$(CRON_OWNER).old\" ; \\\n\t\t$(CP) -a /tmp/crontab-$(CRON_OWNER).old ./crontab-$(CRON_OWNER).`date '+%Y%m%d.%H%M%S'`.old ; \\\n\t\techo \"USER'S CRONTAB SAVED IN CURRENT DIRECTORY (USING .old SUFFIX).\" ; \\\n\t\tsu $(CRON_OWNER) -c \"crontab -r\" ; \\\n\tfi\n\t-if [ -n \"$(SYSTEMD_UNIT_DIR)\" -a -x \"$(SYSTEMCTL)\" ]; then \\\n\t\t$(SYSTEMCTL) disable sysstat.service; \\\n\tfi\nendif\n\tif [ -n \"$(SYSTEMD_UNIT_DIR)\" -a -d \"$(DESTDIR)$(SYSTEMD_UNIT_DIR)\" ]; then \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat.service; \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat-collect.service; \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat-collect.timer; \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat-summary.service; \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat-summary.timer; \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat-rotate.service; \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_UNIT_DIR)/sysstat-rotate.timer; \\\n\tfi\n\tif [ -n \"$(SYSTEMD_UNIT_DIR)\" -a -n \"$(SYSTEMD_SLEEP_DIR)\" -a -d \"$(DESTDIR)$(SYSTEMD_SLEEP_DIR)\" ]; then \\\n\t\trm -f $(DESTDIR)$(SYSTEMD_SLEEP_DIR)/sysstat.sleep; \\\n\tfi\n\nifeq ($(INSTALL_CRON),y)\nuninstall: uninstall_all\nelse\nuninstall: uninstall_base\nendif\n\nifeq ($(INSTALL_CRON),y)\ninstall: install_all\nelse\ninstall: install_base\nendif\n\nifdef REQUIRE_NLS\npo-files: nls/sysstat.pot $(NLSPOT)\nelse\npo-files:\nendif\n\nTESTDIR=\"tests\"\nTESTRUN=\"/bin/sh\"\nTESTLIST:=$(shell ls $(TESTDIR) | grep -E '^[0-9]+$$' | sort -n)\nEXTRADIR=\"tests/extra\"\nEXTRALIST:=$(shell ls $(EXTRADIR) | grep -E '^[0-9]+$$' | sort -n)\n\ntestcomp: tests/ini/inisar sa32bit\n\nifeq ($(TGLIB32),yes)\nsa32bit: DFLAGS += -DARCH32\n\nsa32bit: CFLAGS += -m32\n\nsa32bit: tests/32bits/sadc32 tests/32bits/sar32\nelse\nsa32bit:\nendif\n\nunit:\n\t@echo $(X) 2>&1\n\t@cat $(TESTDIR)/$(X) | $(TESTRUN)\n\nextraunit:\n\t@echo $(X) 2>&1\n\t@cat $(EXTRADIR)/$(X) | $(TESTRUN)\n\n# Use \"do_test\" script to make the following targets\nsimtest: DFLAGS += -DTEST\n\nsimtest: all testcomp\n#\t@$(foreach x, $(TESTLIST), $(MAKE) X=$x unit || exit;)\n#\trm -f tests/root\n#\tln -s root1 tests/root\n#\t@echo Simulation tests: Success!\n\nextratest: DFLAGS += -DTEST\n\nextratest: all\n\t@$(foreach x, $(EXTRALIST), $(MAKE) X=$x extraunit || exit;)\n\trm -f tests/root\n\tln -s root1 tests/root\n\t@echo Extra simulation tests: Success!\n\nclean:\n\trm -f sadc sar sadf iostat tapestat mpstat pidstat cifsiostat *.o *.a core TAGS tests/*.tmp tests/extra/*.tmp\n\trm -f tests/LAST tests/SKIPPED\n\trm -f nfsiostat* man/nfsiostat*\n\trm -f tests/sa[0123]*\n\trm -f tests/root\n\tln -s root1 tests/root\n\trm -f tests/ini/inisar tests/32bits/sadc32 tests/32bits/sar32\n\trm -f tests/ini/*.o tests/ini/*.a tests/ini/core tests/pcpar.* tests/extra/pcpar-ssr.*\n\trm -f tests/32bits/*.o tests/32bits/*.a tests/32bits/core\n\tfind nls -name \"*.gmo\" -exec rm -f {} \\;\n\nalmost-distclean: clean nls/sysstat.pot\n\trm -f sa1 sa2 sysstat cron/crontab version.h sysconfig.h\n\trm -f sysstat.sysconfig cron/sysstat.crond cron/sysstat.cron.daily sysstat.service\n\trm -f cron/sysstat-collect.service cron/sysstat-collect.timer\n\trm -f cron/sysstat-rotate.service cron/sysstat-rotate.timer\n\trm -f cron/sysstat-summary.service cron/sysstat-summary.timer cron/sysstat.sleep\n\trm -f cron/sysstat.cron.hourly cron/sysstat.crond.sample cron/sysstat.crond.sample.in\n\trm -f man/sa1.8 man/sa2.8 man/sadc.8 man/sadf.1 man/sar.1 man/iostat.1 man/sysstat.5\n\trm -f tests/variables tests/data\n\trm -f man/cifsiostat.1\n\trm -f *.log config.status\n\trm -rf autom4te.cache\n\trm -f *.save *.old .*.swp data\n\tfind . -name \"*~\" -exec rm -f {} \\;\n\ndistclean: almost-distclean\n\trm -f Makefile\n\nmaintainer-clean: distclean\n\trm -f configure\n\ndist: almost-distclean\n\tcd .. && (tar --exclude=Makefile --exclude=.git -cvf - sysstat-$(VERSION) | gzip -v9 > sysstat-$(VERSION).tar.gz)\n\nbdist: almost-distclean\n\tcd .. && (tar --exclude=Makefile --exclude=.git -cvf - sysstat-$(VERSION) | bzip2 > sysstat-$(VERSION).tar.bz2)\n\nxdist: almost-distclean\n\tcd .. && (tar --exclude=Makefile --exclude=.git -cvf - sysstat-$(VERSION) | xz > sysstat-$(VERSION).tar.xz)\n\ngitdist: almost-distclean\n\tcd .. && (tar --exclude=Makefile -cvf - sysstat-$(VERSION) | bzip2 > sysstat-$(VERSION)-git.tar.bz2)\n\ntags:\n\tetags ./*.[hc]\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.4248046875,
          "content": "## sysstat - System performance tools for the Linux operating system\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/4040/badge.svg)](https://scan.coverity.com/projects/sysstat-sysstat)\n[![Donate](https://img.shields.io/badge/Donate-PayPal-blue.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=45U6F9R73ESFQ)\n\n(C) 1999-2024 Sebastien GODARD (sysstat (at) orange (dot) fr)\n\n### Introduction\n\nThe sysstat package contains various utilities, common to many commercial Unixes, to monitor system performance and usage activity:\n\n* **iostat** reports CPU statistics and input/output statistics for block devices and partitions.\n* **mpstat** reports individual or combined processor related statistics.\n* **pidstat** reports statistics for Linux tasks (processes) : I/O, CPU, memory, etc.\n* **tapestat** reports statistics for tape drives connected to the system.\n* **cifsiostat** reports CIFS statistics.\n\nSysstat also contains tools you can schedule via cron or systemd to collect and historize performance and activity data:\n\n* **sar** collects, reports and saves system activity information (see below a list of metrics collected by sar).\n* **sadc** is the system activity data collector, used as a backend for sar.\n* **sa1** collects and stores binary data in the system activity daily data file. It is a front end to sadc designed to be run from cron or systemd.\n* **sa2** writes a summarized daily activity report. It is a front end to sar designed to be run from cron or systemd.\n* **sadf** displays data collected by sar in multiple formats (CSV, XML, JSON, etc.) and can be used for data exchange with other programs. This command can also be used to draw graphs for the various activities collected by sar using SVG (Scalable Vector Graphics) format.\n\nDefault sampling interval is 10 minutes but this can be changed of course (it can be as small as 1 second).\n\n#### System statistics collected by sar:\n- Input / Output and transfer rate statistics (global, per device, per partition and per network filesystem)\n- CPU statistics (global and per CPU), including support for virtualization architectures\n- Memory, hugepages and swap space utilization statistics\n- Virtual memory, paging and fault statistics\n- Process creation activity\n- Interrupt statistics (global, per CPU and per interrupt, including potential APIC interrupt sources, hardware and software interrupts)\n- Extensive network statistics: network interface activity (number of packets and kB received and transmitted per second, etc.) including failures from network devices; network traffic statistics for IP, TCP, ICMP and UDP protocols based on SNMPv2 standards; support for IPv6-related protocols\n- Fibre Channel traffic statistics\n- Software-based network processing (softnet) statistics\n- NFS server and client activity\n- Sockets statistics\n- Run queue and system load statistics\n- Kernel internal tables utilization statistics\n- Swapping statistics\n- TTY devices activity\n- Power management statistics (instantaneous and average CPU clock frequency, fans speed, devices temperature, voltage inputs)\n- USB devices plugged into the system\n- Filesystems utilization (inodes and blocks)\n- Pressure-Stall Information statistics\n\n#### Sysstat key features:\n- Display average statistics values at the end of the reports.\n- On-the-fly detection of new devices (disks, network interfaces, etc.) that are created or registered dynamically.\n- Support for UP and SMP machines, including machines with hyperthreaded or multi-core processors.\n- Support for hotplug CPUs (it detects automagically processors that are disabled or enabled on the fly) and tickless CPUs.\n- Works on many different architectures, whether 32- or 64-bit.\n- Needs very little CPU time to run (written in C).\n- System statistics collected by sar/sadc can be saved in a file for future inspection. You can configure the length of data history to keep. There is no limit for this history length but the available space on your storage device.\n- System statistics collected by sar/sadc can be exported in various different formats (CSV, XML, JSON, SVG, etc.). DTD and XML Schema documents are included in sysstat package. JSON output format is also available for mpstat and iostat commands.\n- iostat can display statistics for devices managed by drivers in userspace like spdk.\n- Smart color output for easier statistics reading.\n\n![Smart color output](images/color_output.png)\n- Internationalization support (sysstat has been translated into numerous different languages). Sysstat is now part of the [Translation Project](http://translationproject.org/).\n- Sysstat commands can automatically select the unit used to display sizes for easier reading (see option `--human`):\n\n![Sample iostat output](images/iostat.png)\n\n- Graphs can be generated (SVG format - Scalable Vector Graphics) and displayed in your favorite web browser. See some sample screenshots below:\n\n![Fancy sysstat graph](images/cpugraph.jpg)\n\n![Fancy sysstat graph](images/tcgraph.png)\n\n![Fancy sysstat graph](images/loadavg-svg.png)\n\n\nSysstat is Open Source / Free Software, and is freely available under the GNU General Public License, version 2.\nThe latest version of sysstat can always be found on my web site at:\n\n[https://sysstat.github.io/](https://sysstat.github.io/)\n\nSee the CHANGES file to know the new features/improvements/bug fixes added\nin this release of sysstat.\n\nNote that sysstat no longer uses odd and even version numbers to identify development and stable\nversions. The latest sysstat release should always be considered as a stable version that can be\nused for distribution packaging.\n\nSysstat development can be tracked on [GitHub](https://github.com/sysstat/sysstat).\n\n### Installation\n\n#### Install from RHEL/Fedora/CentOS\n\nEnter:\n\n```\n$ sudo yum install sysstat\n```\n\nCentOS and Fedora systems call the collector process using a cron job in /etc/cron.d and it's enabled by default.\nOn recent versions, systemd is used instead of cron. You may need to enable and start the sysstat service:\n\n```\n$ sudo systemctl enable --now sysstat\n```\n\n(or enter:\n\n```\n$ sudo systemctl enable sysstat\n$ sudo systemctl start sysstat\n```\n\nif option `--now` is not supported by your systemd version.)\n\n#### Install from Ubuntu\n\nEnter:\n\n```\n$ sudo apt-get install sysstat\n```\n\nThen enable data collecting:\n\n```\n$ sudo dpkg-reconfigure sysstat\nSelect \"Yes\"\n```\n\n#### Install from sources\n\nClone sysstat public repository with:\n\n```\n$ git clone git://github.com/sysstat/sysstat\n```\n\nThen configure sysstat for your system:\n\n```\n$ cd sysstat\n$ ./configure\n```\n\nYou can set several variables and parameters on the command line. For example you\ncan enter the following option to activate data collecting (either using cron or systemd):\n\n```\n$ ./configure --enable-install-cron\n```\n\nEnter `./configure --help` to display all possible options.\nNote: There is another way to configure sysstat instead of entering `./configure`:\nThis is the **Interactive Configuration script** (_iconfig_) which will ask you\nfor the value of the main sysstat variables and parameters.\nEnter `./iconfig` then answer the questions or enter Return to accept\nthe (sane) default values. For yes/no questions, answer 'y' or 'n'\n(without the quotes): It is case sensitive! You can also enter '?' to get\na help message that will explain the meaning of each variable or parameter.\n\nCompile and install:\n\n```\n$ make\n$ sudo make install\n```\n\n### Feedback welcome!\n\nPlease use the BUG_REPORT template file to report a bug: It contains important data\nthat should be provided for this.\nPlease also remember to read the FAQ that comes with sysstat or is available\nfrom the Wiki page on GitHub.\n\nOpening an issue or a pull request on GitHub is the preferred way to report a bug or submit a patch.\nPatches and suggestions for improvements are always welcome!\n\n### Support sysstat!\n\nIf you are reading this README file then you are probably about to use the sysstat tools\nto help you monitor your system and maybe troubleshoot some performance issues. Good choice.\nSysstat is made for you. Moreover sysstat is free software and always will be.\n\nYet have you ever considered making a donation to sysstat, regardless of how much your\ncontribution is? This in turn would encourage me to keep up the work as good as it can be...\n\nClick on the \"Donate PayPal\" button above at the beginning of this file.\nYou can also make a donation as a sponsor from [the GitHub page](https://github.com/sysstat/sysstat) or from [my personal web page](https://sysstat.github.io/).\n\nEnjoy!\n\n--\n\nSebastien GODARD - sysstat (at) orange (dot) fr\n\n"
        },
        {
          "name": "activity.c",
          "type": "blob",
          "size": 60.1953125,
          "content": "/*\n * activity.c: Define system activities available for sar/sadc.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include \"sa.h\"\n\n#ifdef SOURCE_SAR\n#include \"pr_stats.h\"\n#endif\n\n#ifdef SOURCE_SADF\n#include \"rndr_stats.h\"\n#include \"xml_stats.h\"\n#include \"json_stats.h\"\n#include \"svg_stats.h\"\n#include \"raw_stats.h\"\n#include \"pcp_stats.h\"\n#endif\n\n/*\n ***************************************************************************\n * Definitions of system activities.\n * See sa.h file for activity structure definition.\n * Activity structure doesn't matter for daily data files.\n ***************************************************************************\n */\n\n/*\n * Bitmaps needed by activities.\n * Remember to allocate them before use!\n */\n\n/* CPU bitmap */\nstruct act_bitmap cpu_bitmap = {\n\t.b_array\t= NULL,\n\t.b_size\t\t= NR_CPUS\n};\n\n\n/*\n * CPU statistics. Switch: -u\n * This is the only activity which *must* be collected by sadc\n * so that uptime can be filled.\n */\nstruct activity cpu_act = {\n\t.id\t\t= A_CPU,\n\t.options\t= AO_COLLECTED + AO_COUNTED + AO_PERSISTENT +\n\t\t\t  AO_MULTIPLE_OUTPUTS + AO_GRAPH_PER_ITEM +\n\t\t\t  AO_ALWAYS_COUNTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 0,\t/* wrap_get_cpu_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_stat_cpu,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_cpu_stats,\n\t.f_print_avg\t= print_cpu_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"CPU;%user;%nice;%system;%iowait;%steal;%idle|\"\n\t\t          \"CPU;%usr;%nice;%sys;%iowait;%steal;%irq;%soft;%guest;%gnice;%idle\",\n#endif\n\t.gtypes_nr\t= {STATS_CPU_ULL, STATS_CPU_UL, STATS_CPU_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_cpu_stats,\n\t.f_xml_print\t= xml_print_cpu_stats,\n\t.f_json_print\t= json_print_cpu_stats,\n\t.f_svg_print\t= svg_print_cpu_stats,\n\t.f_raw_print\t= raw_print_cpu_stats,\n\t.f_pcp_print\t= pcp_print_cpu_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"CPU utilization\",\n#endif\n\t.name\t\t= \"A_CPU\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 1,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= NR_CPUS + 1,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_CPU_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_CPU_SIZE,\n\t.msize\t\t= STATS_CPU_SIZE,\n\t.opt_flags\t= AO_F_CPU_DEF,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= &cpu_bitmap\n};\n\n/* Process (task) creation and context switch activity. Switch: -w */\nstruct activity pcsw_act = {\n\t.id\t\t= A_PCSW,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_stat_pcsw,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pcsw_stats,\n\t.f_print_avg\t= print_pcsw_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"proc/s;cswch/s\",\n#endif\n\t.gtypes_nr\t= {STATS_PCSW_ULL, STATS_PCSW_UL, STATS_PCSW_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pcsw_stats,\n\t.f_xml_print\t= xml_print_pcsw_stats,\n\t.f_json_print\t= json_print_pcsw_stats,\n\t.f_svg_print\t= svg_print_pcsw_stats,\n\t.f_raw_print\t= raw_print_pcsw_stats,\n\t.f_pcp_print\t= pcp_print_pcsw_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Task creation and switching activity\",\n#endif\n\t.name\t\t= \"A_PCSW\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PCSW_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PCSW_SIZE,\n\t.msize\t\t= STATS_PCSW_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Interrupts statistics. Switch: -I */\nstruct activity irq_act = {\n\t.id\t\t= A_IRQ,\n\t.options\t= AO_COUNTED + AO_MATRIX + AO_PERSISTENT,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_INT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 0,\t/* wrap_get_cpu_nr() */\n\t.f_count2_index\t= 1,\t/* wrap_get_irq_nr() */\n\t.f_read\t\t= wrap_read_stat_irq,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_irq_stats,\n\t.f_print_avg\t= print_irq_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"INTR;CPU*\",\n#endif\n\t.gtypes_nr\t= {STATS_IRQ_ULL, STATS_IRQ_UL, STATS_IRQ_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_irq_stats,\n\t.f_xml_print\t= xml_print_irq_stats,\n\t.f_json_print\t= json_print_irq_stats,\n\t.f_svg_print\t= NULL,\n\t.f_raw_print\t= raw_print_irq_stats,\n\t.f_pcp_print\t= pcp_print_irq_stats,\n\t.f_count_new\t= count_new_int,\n\t.desc\t\t= \"Interrupts statistics\",\n#endif\n\t.name\t\t= \"A_IRQ\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 0,\n\t.nr_ini\t\t= -1,\t/* Nr of CPU */\n\t.nr2\t\t= -1,\t/* Nr of int */\n\t.nr_max\t\t= NR_CPUS + 1,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_IRQ_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_IRQ_SIZE,\n\t.msize\t\t= STATS_IRQ_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= &cpu_bitmap\n};\n\n/* Swapping activity. Switch: -W */\nstruct activity swap_act = {\n\t.id\t\t= A_SWAP,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_swap,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_swap_stats,\n\t.f_print_avg\t= print_swap_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"pswpin/s;pswpout/s\",\n#endif\n\t.gtypes_nr\t= {STATS_SWAP_ULL, STATS_SWAP_UL, STATS_SWAP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_swap_stats,\n\t.f_xml_print\t= xml_print_swap_stats,\n\t.f_json_print\t= json_print_swap_stats,\n\t.f_svg_print\t= svg_print_swap_stats,\n\t.f_raw_print\t= raw_print_swap_stats,\n\t.f_pcp_print\t= pcp_print_swap_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Swap activity\",\n#endif\n\t.name\t\t= \"A_SWAP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 1,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_SWAP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_SWAP_SIZE,\n\t.msize\t\t= STATS_SWAP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Paging activity. Switch: -B */\nstruct activity paging_act = {\n\t.id\t\t= A_PAGE,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_paging,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_paging_stats,\n\t.f_print_avg\t= print_paging_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"pgpgin/s;pgpgout/s;fault/s;majflt/s;\"\n\t\t\t  \"pgfree/s;pgscank/s;pgscand/s;pgsteal/s;\"\n\t\t\t  \"pgprom/s;pgdem/s\",\n#endif\n\t.gtypes_nr\t= {STATS_PAGING_ULL, STATS_PAGING_UL, STATS_PAGING_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_paging_stats,\n\t.f_xml_print\t= xml_print_paging_stats,\n\t.f_json_print\t= json_print_paging_stats,\n\t.f_svg_print\t= svg_print_paging_stats,\n\t.f_raw_print\t= raw_print_paging_stats,\n\t.f_pcp_print\t= pcp_print_paging_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Paging activity\",\n#endif\n\t.name\t\t= \"A_PAGE\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PAGING_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PAGING_SIZE,\n\t.msize\t\t= STATS_PAGING_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* I/O and transfer rate activity. Switch: -b */\nstruct activity io_act = {\n\t.id\t\t= A_IO,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_io,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_io_stats,\n\t.f_print_avg\t= print_io_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"tps;rtps;wtps;dtps;bread/s;bwrtn/s;bdscd/s\",\n#endif\n\t.gtypes_nr\t= {STATS_IO_ULL, STATS_IO_UL, STATS_IO_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_io_stats,\n\t.f_xml_print\t= xml_print_io_stats,\n\t.f_json_print\t= json_print_io_stats,\n\t.f_svg_print\t= svg_print_io_stats,\n\t.f_raw_print\t= raw_print_io_stats,\n\t.f_pcp_print\t= pcp_print_io_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"I/O and transfer rate statistics\",\n#endif\n\t.name\t\t= \"A_IO\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_IO_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_IO_SIZE,\n\t.msize\t\t= STATS_IO_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Memory and swap space utilization activity. Switch: -r */\nstruct activity memory_act = {\n\t.id\t\t= A_MEMORY,\n\t.options\t= AO_COLLECTED + AO_MULTIPLE_OUTPUTS,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_meminfo,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_memory_stats,\n\t.f_print_avg\t= print_avg_memory_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"kbmemfree;kbavail;kbmemused;%memused;kbbuffers;kbcached;kbcommit;%commit;kbactive;kbinact;kbdirty&kbanonpg;kbslab;kbkstack;kbpgtbl;kbvmused|\"\n\t\t          \"kbswpfree;kbswpused;%swpused;kbswpcad;%swpcad\",\n#endif\n\t.gtypes_nr\t= {STATS_MEMORY_ULL, STATS_MEMORY_UL, STATS_MEMORY_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_memory_stats,\n\t.f_xml_print\t= xml_print_memory_stats,\n\t.f_json_print\t= json_print_memory_stats,\n\t.f_svg_print\t= svg_print_memory_stats,\n\t.f_raw_print\t= raw_print_memory_stats,\n\t.f_pcp_print\t= pcp_print_memory_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Memory and/or swap utilization\",\n#endif\n\t.name\t\t= \"A_MEMORY\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 9,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_MEMORY_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_MEMORY_SIZE,\n\t.msize\t\t= STATS_MEMORY_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Kernel tables activity. Switch: -v */\nstruct activity ktables_act = {\n\t.id\t\t= A_KTABLES,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_kernel_tables,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_ktables_stats,\n\t.f_print_avg\t= print_avg_ktables_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"dentunusd;file-nr;inode-nr;pty-nr\",\n#endif\n\t.gtypes_nr\t= {STATS_KTABLES_ULL, STATS_KTABLES_UL, STATS_KTABLES_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_ktables_stats,\n\t.f_xml_print\t= xml_print_ktables_stats,\n\t.f_json_print\t= json_print_ktables_stats,\n\t.f_svg_print\t= svg_print_ktables_stats,\n\t.f_raw_print\t= raw_print_ktables_stats,\n\t.f_pcp_print\t= pcp_print_ktables_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Kernel tables statistics\",\n#endif\n\t.name\t\t= \"A_KTABLES\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_KTABLES_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_KTABLES_SIZE,\n\t.msize\t\t= STATS_KTABLES_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Queue and load activity. Switch: -q LOAD */\nstruct activity queue_act = {\n\t.id\t\t= A_QUEUE,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_loadavg,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_queue_stats,\n\t.f_print_avg\t= print_avg_queue_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"runq-sz;plist-sz;ldavg-1;ldavg-5;ldavg-15;blocked\",\n#endif\n\t.gtypes_nr\t= {STATS_QUEUE_ULL, STATS_QUEUE_UL, STATS_QUEUE_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_queue_stats,\n\t.f_xml_print\t= xml_print_queue_stats,\n\t.f_json_print\t= json_print_queue_stats,\n\t.f_svg_print\t= svg_print_queue_stats,\n\t.f_raw_print\t= raw_print_queue_stats,\n\t.f_pcp_print\t= pcp_print_queue_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Queue length and load average statistics\",\n#endif\n\t.name\t\t= \"A_QUEUE\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 3,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_QUEUE_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_QUEUE_SIZE,\n\t.msize\t\t= STATS_QUEUE_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Serial lines activity. Switch: -y */\nstruct activity serial_act = {\n\t.id\t\t= A_SERIAL,\n\t.options\t= AO_COLLECTED + AO_COUNTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 2,\t/* wrap_get_serial_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_tty_driver_serial,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_serial_stats,\n\t.f_print_avg\t= print_serial_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"TTY;rcvin/s;xmtin/s;framerr/s;prtyerr/s;brk/s;ovrun/s\",\n#endif\n\t.gtypes_nr\t= {STATS_SERIAL_ULL, STATS_SERIAL_UL, STATS_SERIAL_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_serial_stats,\n\t.f_xml_print\t= xml_print_serial_stats,\n\t.f_json_print\t= json_print_serial_stats,\n\t.f_svg_print\t= NULL,\n\t.f_raw_print\t= raw_print_serial_stats,\n\t.f_pcp_print\t= pcp_print_serial_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"TTY devices statistics\",\n#endif\n\t.name\t\t= \"A_SERIAL\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 0,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_SERIAL_LINES,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_SERIAL_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_SERIAL_SIZE,\n\t.msize\t\t= STATS_SERIAL_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Block devices activity. Switch: -d */\nstruct activity disk_act = {\n\t.id\t\t= A_DISK,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_DISK,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 3,\t/* wrap_get_disk_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_disk,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_disk_stats,\n\t.f_print_avg\t= print_disk_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"DEV;tps;rkB/s;wkB/s;dkB/s;areq-sz;aqu-sz;await;%util\",\n#endif\n\t.gtypes_nr\t= {STATS_DISK_ULL, STATS_DISK_UL, STATS_DISK_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_disk_stats,\n\t.f_xml_print\t= xml_print_disk_stats,\n\t.f_json_print\t= json_print_disk_stats,\n\t.f_svg_print\t= svg_print_disk_stats,\n\t.f_raw_print\t= raw_print_disk_stats,\n\t.f_pcp_print\t= pcp_print_disk_stats,\n\t.f_count_new\t= count_new_disk,\n\t.desc\t\t= \"Block devices statistics\",\n#endif\n\t.name\t\t= \"A_DISK\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 5,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_DISKS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_DISK_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_DISK_SIZE,\n\t.msize\t\t= STATS_DISK_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Network interfaces activity. Switch: -n DEV */\nstruct activity net_dev_act = {\n\t.id\t\t= A_NET_DEV,\n\t.options\t= AO_COLLECTED + AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 3,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 4,\t/* wrap_get_iface_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_dev,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_dev_stats,\n\t.f_print_avg\t= print_net_dev_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"IFACE;rxpck/s;txpck/s;rxkB/s;txkB/s;rxcmp/s;txcmp/s;rxmcst/s;%ifutil\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_DEV_ULL, STATS_NET_DEV_UL, STATS_NET_DEV_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_dev_stats,\n\t.f_xml_print\t= xml_print_net_dev_stats,\n\t.f_json_print\t= json_print_net_dev_stats,\n\t.f_svg_print\t= svg_print_net_dev_stats,\n\t.f_raw_print\t= raw_print_net_dev_stats,\n\t.f_pcp_print\t= pcp_print_net_dev_stats,\n\t.f_count_new\t= count_new_net_dev,\n\t.desc\t\t= \"Network interfaces statistics\",\n#endif\n\t.name\t\t= \"A_NET_DEV\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_IFACES,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_DEV_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_DEV_SIZE,\n\t.msize\t\t= STATS_NET_DEV_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Network interfaces (errors) activity. Switch: -n EDEV */\nstruct activity net_edev_act = {\n\t.id\t\t= A_NET_EDEV,\n\t.options\t= AO_COLLECTED + AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 4,\t/* wrap_get_iface_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_edev,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_edev_stats,\n\t.f_print_avg\t= print_net_edev_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"IFACE;rxerr/s;txerr/s;coll/s;rxdrop/s;txdrop/s;\"\n\t\t          \"txcarr/s;rxfram/s;rxfifo/s;txfifo/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_EDEV_ULL, STATS_NET_EDEV_UL, STATS_NET_EDEV_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_edev_stats,\n\t.f_xml_print\t= xml_print_net_edev_stats,\n\t.f_json_print\t= json_print_net_edev_stats,\n\t.f_svg_print\t= svg_print_net_edev_stats,\n\t.f_raw_print\t= raw_print_net_edev_stats,\n\t.f_pcp_print\t= pcp_print_net_edev_stats,\n\t.f_count_new\t= count_new_net_edev,\n\t.desc\t\t= \"Network interfaces errors statistics\",\n#endif\n\t.name\t\t= \"A_NET_EDEV\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_IFACES,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_EDEV_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_EDEV_SIZE,\n\t.msize\t\t= STATS_NET_EDEV_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* NFS client activity. Switch: -n NFS */\nstruct activity net_nfs_act = {\n\t.id\t\t= A_NET_NFS,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_nfs,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_nfs_stats,\n\t.f_print_avg\t= print_net_nfs_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"call/s;retrans/s;read/s;write/s;access/s;getatt/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_NFS_ULL, STATS_NET_NFS_UL, STATS_NET_NFS_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_nfs_stats,\n\t.f_xml_print\t= xml_print_net_nfs_stats,\n\t.f_json_print\t= json_print_net_nfs_stats,\n\t.f_svg_print\t= svg_print_net_nfs_stats,\n\t.f_raw_print\t= raw_print_net_nfs_stats,\n\t.f_pcp_print\t= pcp_print_net_nfs_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"NFS client statistics\",\n#endif\n\t.name\t\t= \"A_NET_NFS\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 3,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_NFS_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_NFS_SIZE,\n\t.msize\t\t= STATS_NET_NFS_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* NFS server activity. Switch: -n NFSD */\nstruct activity net_nfsd_act = {\n\t.id\t\t= A_NET_NFSD,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_nfsd,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_nfsd_stats,\n\t.f_print_avg\t= print_net_nfsd_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"scall/s;badcall/s;packet/s;udp/s;tcp/s;hit/s;miss/s;\"\n\t\t          \"sread/s;swrite/s;saccess/s;sgetatt/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_NFSD_ULL, STATS_NET_NFSD_UL, STATS_NET_NFSD_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_nfsd_stats,\n\t.f_xml_print\t= xml_print_net_nfsd_stats,\n\t.f_json_print\t= json_print_net_nfsd_stats,\n\t.f_svg_print\t= svg_print_net_nfsd_stats,\n\t.f_raw_print\t= raw_print_net_nfsd_stats,\n\t.f_pcp_print\t= pcp_print_net_nfsd_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"NFS server statistics\",\n#endif\n\t.name\t\t= \"A_NET_NFSD\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 5,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_NFSD_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_NFSD_SIZE,\n\t.msize\t\t= STATS_NET_NFSD_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Network sockets activity. Switch: -n SOCK */\nstruct activity net_sock_act = {\n\t.id\t\t= A_NET_SOCK,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_sock,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_sock_stats,\n\t.f_print_avg\t= print_avg_net_sock_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"totsck;tcpsck;udpsck;rawsck;ip-frag;tcp-tw\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_SOCK_ULL, STATS_NET_SOCK_UL, STATS_NET_SOCK_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_sock_stats,\n\t.f_xml_print\t= xml_print_net_sock_stats,\n\t.f_json_print\t= json_print_net_sock_stats,\n\t.f_svg_print\t= svg_print_net_sock_stats,\n\t.f_raw_print\t= raw_print_net_sock_stats,\n\t.f_pcp_print\t= pcp_print_net_sock_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"IPv4 sockets statistics\",\n#endif\n\t.name\t\t= \"A_NET_SOCK\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_SOCK_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_SOCK_SIZE,\n\t.msize\t\t= STATS_NET_SOCK_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* IP network traffic activity. Switch: -n IP */\nstruct activity net_ip_act = {\n\t.id\t\t= A_NET_IP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_ip,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_ip_stats,\n\t.f_print_avg\t= print_net_ip_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"irec/s;fwddgm/s;idel/s;orq/s;asmrq/s;asmok/s;fragok/s;fragcrt/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_IP_ULL, STATS_NET_IP_UL, STATS_NET_IP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_ip_stats,\n\t.f_xml_print\t= xml_print_net_ip_stats,\n\t.f_json_print\t= json_print_net_ip_stats,\n\t.f_svg_print\t= svg_print_net_ip_stats,\n\t.f_raw_print\t= raw_print_net_ip_stats,\n\t.f_pcp_print\t= pcp_print_net_ip_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"IPv4 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_IP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 3,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_IP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_IP_SIZE,\n\t.msize\t\t= STATS_NET_IP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* IP network traffic (errors) activity. Switch: -n EIP */\nstruct activity net_eip_act = {\n\t.id\t\t= A_NET_EIP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_eip,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_eip_stats,\n\t.f_print_avg\t= print_net_eip_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"ihdrerr/s;iadrerr/s;iukwnpr/s;idisc/s;odisc/s;onort/s;asmf/s;fragf/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_EIP_ULL, STATS_NET_EIP_UL, STATS_NET_EIP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_eip_stats,\n\t.f_xml_print\t= xml_print_net_eip_stats,\n\t.f_json_print\t= json_print_net_eip_stats,\n\t.f_svg_print\t= svg_print_net_eip_stats,\n\t.f_raw_print\t= raw_print_net_eip_stats,\n\t.f_pcp_print\t= pcp_print_net_eip_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"IPv4 traffic errors statistics\",\n#endif\n\t.name\t\t= \"A_NET_EIP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 3,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_EIP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_EIP_SIZE,\n\t.msize\t\t= STATS_NET_EIP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* ICMP network traffic activity. Switch: -n ICMP */\nstruct activity net_icmp_act = {\n\t.id\t\t= A_NET_ICMP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_icmp,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_icmp_stats,\n\t.f_print_avg\t= print_net_icmp_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"imsg/s;omsg/s;iech/s;iechr/s;oech/s;oechr/s;itm/s;itmr/s;otm/s;\"\n\t\t          \"otmr/s;iadrmk/s;iadrmkr/s;oadrmk/s;oadrmkr/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_ICMP_ULL, STATS_NET_ICMP_UL, STATS_NET_ICMP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_icmp_stats,\n\t.f_xml_print\t= xml_print_net_icmp_stats,\n\t.f_json_print\t= json_print_net_icmp_stats,\n\t.f_svg_print\t= svg_print_net_icmp_stats,\n\t.f_raw_print\t= raw_print_net_icmp_stats,\n\t.f_pcp_print\t= pcp_print_net_icmp_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"ICMPv4 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_ICMP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_ICMP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_ICMP_SIZE,\n\t.msize\t\t= STATS_NET_ICMP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* ICMP network traffic (errors) activity. Switch: -n EICMP */\nstruct activity net_eicmp_act = {\n\t.id\t\t= A_NET_EICMP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_eicmp,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_eicmp_stats,\n\t.f_print_avg\t= print_net_eicmp_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"ierr/s;oerr/s;idstunr/s;odstunr/s;itmex/s;otmex/s;\"\n\t\t          \"iparmpb/s;oparmpb/s;isrcq/s;osrcq/s;iredir/s;oredir/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_EICMP_ULL, STATS_NET_EICMP_UL, STATS_NET_EICMP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_eicmp_stats,\n\t.f_xml_print\t= xml_print_net_eicmp_stats,\n\t.f_json_print\t= json_print_net_eicmp_stats,\n\t.f_svg_print\t= svg_print_net_eicmp_stats,\n\t.f_raw_print\t= raw_print_net_eicmp_stats,\n\t.f_pcp_print\t= pcp_print_net_eicmp_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"ICMPv4 traffic errors statistics\",\n#endif\n\t.name\t\t= \"A_NET_EICMP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 6,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_EICMP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_EICMP_SIZE,\n\t.msize\t\t= STATS_NET_EICMP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* TCP network traffic activity. Switch: -n TCP */\nstruct activity net_tcp_act = {\n\t.id\t\t= A_NET_TCP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_tcp,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_tcp_stats,\n\t.f_print_avg\t= print_net_tcp_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"active/s;passive/s;iseg/s;oseg/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_TCP_ULL, STATS_NET_TCP_UL, STATS_NET_TCP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_tcp_stats,\n\t.f_xml_print\t= xml_print_net_tcp_stats,\n\t.f_json_print\t= json_print_net_tcp_stats,\n\t.f_svg_print\t= svg_print_net_tcp_stats,\n\t.f_raw_print\t= raw_print_net_tcp_stats,\n\t.f_pcp_print\t= pcp_print_net_tcp_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"TCPv4 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_TCP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_TCP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_TCP_SIZE,\n\t.msize\t\t= STATS_NET_TCP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* TCP network traffic (errors) activity. Switch: -n ETCP */\nstruct activity net_etcp_act = {\n\t.id\t\t= A_NET_ETCP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_etcp,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_etcp_stats,\n\t.f_print_avg\t= print_net_etcp_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"atmptf/s;estres/s;retrseg/s;isegerr/s;orsts/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_ETCP_ULL, STATS_NET_ETCP_UL, STATS_NET_ETCP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_etcp_stats,\n\t.f_xml_print\t= xml_print_net_etcp_stats,\n\t.f_json_print\t= json_print_net_etcp_stats,\n\t.f_svg_print\t= svg_print_net_etcp_stats,\n\t.f_raw_print\t= raw_print_net_etcp_stats,\n\t.f_pcp_print\t= pcp_print_net_etcp_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"TCPv4 traffic errors statistics\",\n#endif\n\t.name\t\t= \"A_NET_ETCP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_ETCP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_ETCP_SIZE,\n\t.msize\t\t= STATS_NET_ETCP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* UDP network traffic activity. Switch: -n UDP */\nstruct activity net_udp_act = {\n\t.id\t\t= A_NET_UDP,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_SNMP,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_udp,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_udp_stats,\n\t.f_print_avg\t= print_net_udp_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"idgm/s;odgm/s;noport/s;idgmerr/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_UDP_ULL, STATS_NET_UDP_UL, STATS_NET_UDP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_udp_stats,\n\t.f_xml_print\t= xml_print_net_udp_stats,\n\t.f_json_print\t= json_print_net_udp_stats,\n\t.f_svg_print\t= svg_print_net_udp_stats,\n\t.f_raw_print\t= raw_print_net_udp_stats,\n\t.f_pcp_print\t= pcp_print_net_udp_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"UDPv4 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_UDP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_UDP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_UDP_SIZE,\n\t.msize\t\t= STATS_NET_UDP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* IPv6 sockets activity. Switch: -n SOCK6 */\nstruct activity net_sock6_act = {\n\t.id\t\t= A_NET_SOCK6,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_IPV6,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_sock6,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_sock6_stats,\n\t.f_print_avg\t= print_avg_net_sock6_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"tcp6sck;udp6sck;raw6sck;ip6-frag\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_SOCK6_ULL, STATS_NET_SOCK6_UL, STATS_NET_SOCK6_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_sock6_stats,\n\t.f_xml_print\t= xml_print_net_sock6_stats,\n\t.f_json_print\t= json_print_net_sock6_stats,\n\t.f_svg_print\t= svg_print_net_sock6_stats,\n\t.f_raw_print\t= raw_print_net_sock6_stats,\n\t.f_pcp_print\t= pcp_print_net_sock6_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"IPv6 sockets statistics\",\n#endif\n\t.name\t\t= \"A_NET_SOCK6\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 1,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_SOCK6_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_SOCK6_SIZE,\n\t.msize\t\t= STATS_NET_SOCK6_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* IPv6 network traffic activity. Switch: -n IP6 */\nstruct activity net_ip6_act = {\n\t.id\t\t= A_NET_IP6,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_IPV6,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_ip6,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_ip6_stats,\n\t.f_print_avg\t= print_net_ip6_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"irec6/s;fwddgm6/s;idel6/s;orq6/s;asmrq6/s;asmok6/s;\"\n\t\t\t  \"imcpck6/s;omcpck6/s;fragok6/s;fragcr6/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_IP6_ULL, STATS_NET_IP6_UL, STATS_NET_IP6_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_ip6_stats,\n\t.f_xml_print\t= xml_print_net_ip6_stats,\n\t.f_json_print\t= json_print_net_ip6_stats,\n\t.f_svg_print\t= svg_print_net_ip6_stats,\n\t.f_raw_print\t= raw_print_net_ip6_stats,\n\t.f_pcp_print\t= pcp_print_net_ip6_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"IPv6 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_IP6\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_IP6_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_IP6_SIZE,\n\t.msize\t\t= STATS_NET_IP6_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* IPv6 network traffic (errors) activity. Switch: -n EIP6 */\nstruct activity net_eip6_act = {\n\t.id\t\t= A_NET_EIP6,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 2,\n\t.group\t\t= G_IPV6,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_eip6,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_eip6_stats,\n\t.f_print_avg\t= print_net_eip6_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"ihdrer6/s;iadrer6/s;iukwnp6/s;i2big6/s;idisc6/s;odisc6/s;\"\n\t\t\t  \"inort6/s;onort6/s;asmf6/s;fragf6/s;itrpck6/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_EIP6_ULL, STATS_NET_EIP6_UL, STATS_NET_EIP6_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_eip6_stats,\n\t.f_xml_print\t= xml_print_net_eip6_stats,\n\t.f_json_print\t= json_print_net_eip6_stats,\n\t.f_svg_print\t= svg_print_net_eip6_stats,\n\t.f_raw_print\t= raw_print_net_eip6_stats,\n\t.f_pcp_print\t= pcp_print_net_eip6_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"IPv6 traffic errors statistics\",\n#endif\n\t.name\t\t= \"A_NET_EIP6\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_EIP6_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_EIP6_SIZE,\n\t.msize\t\t= STATS_NET_EIP6_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* ICMPv6 network traffic activity. Switch: -n ICMP6 */\nstruct activity net_icmp6_act = {\n\t.id\t\t= A_NET_ICMP6,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_IPV6,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_icmp6,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_icmp6_stats,\n\t.f_print_avg\t= print_net_icmp6_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"imsg6/s;omsg6/s;iech6/s;iechr6/s;oechr6/s;igmbq6/s;igmbr6/s;ogmbr6/s;\"\n\t\t\t  \"igmbrd6/s;ogmbrd6/s;irtsol6/s;ortsol6/s;irtad6/s;inbsol6/s;onbsol6/s;\"\n\t\t\t  \"inbad6/s;onbad6/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_ICMP6_ULL, STATS_NET_ICMP6_UL, STATS_NET_ICMP6_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_icmp6_stats,\n\t.f_xml_print\t= xml_print_net_icmp6_stats,\n\t.f_json_print\t= json_print_net_icmp6_stats,\n\t.f_svg_print\t= svg_print_net_icmp6_stats,\n\t.f_raw_print\t= raw_print_net_icmp6_stats,\n\t.f_pcp_print\t= pcp_print_net_icmp6_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"ICMPv6 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_ICMP6\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 5,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_ICMP6_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_ICMP6_SIZE,\n\t.msize\t\t= STATS_NET_ICMP6_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* ICMPv6 network traffic (errors) activity. Switch: -n EICMP6 */\nstruct activity net_eicmp6_act = {\n\t.id\t\t= A_NET_EICMP6,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_IPV6,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_eicmp6,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_eicmp6_stats,\n\t.f_print_avg\t= print_net_eicmp6_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"ierr6/s;idtunr6/s;odtunr6/s;itmex6/s;otmex6/s;\"\n\t\t          \"iprmpb6/s;oprmpb6/s;iredir6/s;oredir6/s;ipck2b6/s;opck2b6/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_EICMP6_ULL, STATS_NET_EICMP6_UL, STATS_NET_EICMP6_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_eicmp6_stats,\n\t.f_xml_print\t= xml_print_net_eicmp6_stats,\n\t.f_json_print\t= json_print_net_eicmp6_stats,\n\t.f_svg_print\t= svg_print_net_eicmp6_stats,\n\t.f_raw_print\t= raw_print_net_eicmp6_stats,\n\t.f_pcp_print\t= pcp_print_net_eicmp6_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"ICMPv6 traffic errors statistics\",\n#endif\n\t.name\t\t= \"A_NET_EICMP6\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 6,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_EICMP6_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_EICMP6_SIZE,\n\t.msize\t\t= STATS_NET_EICMP6_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* UDPv6 network traffic activity. Switch: -n UDP6 */\nstruct activity net_udp6_act = {\n\t.id\t\t= A_NET_UDP6,\n\t.options\t= AO_NULL,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_IPV6,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_net_udp6,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_net_udp6_stats,\n\t.f_print_avg\t= print_net_udp6_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"idgm6/s;odgm6/s;noport6/s;idgmer6/s\",\n#endif\n\t.gtypes_nr\t= {STATS_NET_UDP6_ULL, STATS_NET_UDP6_UL, STATS_NET_UDP6_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_net_udp6_stats,\n\t.f_xml_print\t= xml_print_net_udp6_stats,\n\t.f_json_print\t= json_print_net_udp6_stats,\n\t.f_svg_print\t= svg_print_net_udp6_stats,\n\t.f_raw_print\t= raw_print_net_udp6_stats,\n\t.f_pcp_print\t= pcp_print_net_udp6_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"UDPv6 traffic statistics\",\n#endif\n\t.name\t\t= \"A_NET_UDP6\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_NET_UDP6_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_NET_UDP6_SIZE,\n\t.msize\t\t= STATS_NET_UDP6_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* CPU frequency. Switch: -m CPU */\nstruct activity pwr_cpufreq_act = {\n\t.id\t\t= A_PWR_CPU,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 0,\t/* wrap_get_cpu_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_cpuinfo,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_cpufreq_stats,\n\t.f_print_avg\t= print_avg_pwr_cpufreq_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"CPU;MHz\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_CPUFREQ_ULL, STATS_PWR_CPUFREQ_UL, STATS_PWR_CPUFREQ_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_cpufreq_stats,\n\t.f_xml_print\t= xml_print_pwr_cpufreq_stats,\n\t.f_json_print\t= json_print_pwr_cpufreq_stats,\n\t.f_svg_print\t= svg_print_pwr_cpufreq_stats,\n\t.f_raw_print\t= raw_print_pwr_cpufreq_stats,\n\t.f_pcp_print\t= pcp_print_pwr_cpufreq_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"CPU clock frequency\",\n#endif\n\t.name\t\t= \"A_PWR_CPU\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 1,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= NR_CPUS + 1,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_CPUFREQ_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_CPUFREQ_SIZE,\n\t.msize\t\t= STATS_PWR_CPUFREQ_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= &cpu_bitmap\n};\n\n/* Fan. Switch: -m FAN */\nstruct activity pwr_fan_act = {\n\t.id\t\t= A_PWR_FAN,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 5,\t/* wrap_get_fan_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_fan,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_fan_stats,\n\t.f_print_avg\t= print_avg_pwr_fan_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"FAN;DEVICE;rpm;drpm\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_FAN_ULL, STATS_PWR_FAN_UL, STATS_PWR_FAN_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_fan_stats,\n\t.f_xml_print\t= xml_print_pwr_fan_stats,\n\t.f_json_print\t= json_print_pwr_fan_stats,\n\t.f_svg_print\t= svg_print_pwr_fan_stats,\n\t.f_raw_print\t= raw_print_pwr_fan_stats,\n\t.f_pcp_print\t= pcp_print_pwr_fan_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Fans speed\",\n#endif\n\t.name\t\t= \"A_PWR_FAN\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 1,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_FANS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_FAN_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_FAN_SIZE,\n\t.msize\t\t= STATS_PWR_FAN_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Temperature. Switch: -m TEMP */\nstruct activity pwr_temp_act = {\n\t.id\t\t= A_PWR_TEMP,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 6,\t/* wrap_get_temp_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_temp,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_temp_stats,\n\t.f_print_avg\t= print_avg_pwr_temp_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"TEMP;DEVICE;degC;%temp\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_TEMP_ULL, STATS_PWR_TEMP_UL, STATS_PWR_TEMP_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_temp_stats,\n\t.f_xml_print\t= xml_print_pwr_temp_stats,\n\t.f_json_print\t= json_print_pwr_temp_stats,\n\t.f_svg_print\t= svg_print_pwr_temp_stats,\n\t.f_raw_print\t= raw_print_pwr_temp_stats,\n\t.f_pcp_print\t= pcp_print_pwr_temp_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Devices temperature\",\n#endif\n\t.name\t\t= \"A_PWR_TEMP\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_TEMP_SENSORS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_TEMP_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_TEMP_SIZE,\n\t.msize\t\t= STATS_PWR_TEMP_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Voltage inputs. Switch: -m IN */\nstruct activity pwr_in_act = {\n\t.id\t\t= A_PWR_IN,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 7,\t/* wrap_get_in_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_in,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_in_stats,\n\t.f_print_avg\t= print_avg_pwr_in_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"IN;DEVICE;inV;%in\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_IN_ULL, STATS_PWR_IN_UL, STATS_PWR_IN_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_in_stats,\n\t.f_xml_print\t= xml_print_pwr_in_stats,\n\t.f_json_print\t= json_print_pwr_in_stats,\n\t.f_svg_print\t= svg_print_pwr_in_stats,\n\t.f_raw_print\t= raw_print_pwr_in_stats,\n\t.f_pcp_print\t= pcp_print_pwr_in_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Voltage inputs statistics\",\n#endif\n\t.name\t\t= \"A_PWR_IN\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_IN_SENSORS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_IN_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_IN_SIZE,\n\t.msize\t\t= STATS_PWR_IN_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Hugepages activity. Switch: -H */\nstruct activity huge_act = {\n\t.id\t\t= A_HUGE,\n\t.options\t= AO_COLLECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= -1,\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_meminfo_huge,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_huge_stats,\n\t.f_print_avg\t= print_avg_huge_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"kbhugfree;kbhugused;%hugused;kbhugrsvd;kbhugsurp\",\n#endif\n\t.gtypes_nr\t= {STATS_HUGE_ULL, STATS_HUGE_UL, STATS_HUGE_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_huge_stats,\n\t.f_xml_print\t= xml_print_huge_stats,\n\t.f_json_print\t= json_print_huge_stats,\n\t.f_svg_print\t= svg_print_huge_stats,\n\t.f_raw_print\t= raw_print_huge_stats,\n\t.f_pcp_print\t= pcp_print_huge_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Huge pages utilization\",\n#endif\n\t.name\t\t= \"A_HUGE\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_HUGE_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_HUGE_SIZE,\n\t.msize\t\t= STATS_HUGE_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* CPU weighted frequency. Switch: -m FREQ */\nstruct activity pwr_wghfreq_act = {\n\t.id\t\t= A_PWR_FREQ,\n\t.options\t= AO_COUNTED + AO_MATRIX,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 0,\t/* wrap_get_cpu_nr() */\n\t.f_count2_index\t= 12,\t/* wrap_get_freq_nr() */\n\t.f_read\t\t= wrap_read_cpu_wghfreq,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_wghfreq_stats,\n\t.f_print_avg\t= print_pwr_wghfreq_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"CPU;wghMHz\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_WGHFREQ_ULL, STATS_PWR_WGHFREQ_UL, STATS_PWR_WGHFREQ_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_wghfreq_stats,\n\t.f_xml_print\t= xml_print_pwr_wghfreq_stats,\n\t.f_json_print\t= json_print_pwr_wghfreq_stats,\n\t.f_svg_print\t= NULL,\n\t.f_raw_print\t= raw_print_pwr_wghfreq_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"CPU weighted frequency\",\n#endif\n\t.name\t\t= \"A_PWR_FREQ\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 0,\n\t.nr_ini\t\t= -1,\t/* Nr of CPU */\n\t.nr2\t\t= -1,\t/* Nr of frequencies */\n\t.nr_max\t\t= NR_CPUS + 1,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_WGHFREQ_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_WGHFREQ_SIZE,\n\t.msize\t\t= STATS_PWR_WGHFREQ_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= &cpu_bitmap\n};\n\n/* USB devices plugged into the system. Switch: -m USB */\nstruct activity pwr_usb_act = {\n\t.id\t\t= A_PWR_USB,\n\t.options\t= AO_COUNTED + AO_CLOSE_MARKUP,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 8,\t/* wrap_get_usb_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_bus_usb_dev,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_usb_stats,\n\t.f_print_avg\t= print_avg_pwr_usb_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"manufact;product;BUS;idvendor;idprod;maxpower\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_USB_ULL, STATS_PWR_USB_UL, STATS_PWR_USB_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_usb_stats,\n\t.f_xml_print\t= xml_print_pwr_usb_stats,\n\t.f_json_print\t= json_print_pwr_usb_stats,\n\t.f_svg_print\t= NULL,\n\t.f_raw_print\t= raw_print_pwr_usb_stats,\n\t.f_pcp_print\t= pcp_print_pwr_usb_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"USB devices\",\n#endif\n\t.name\t\t= \"A_PWR_USB\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 0,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_USB,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_USB_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_USB_SIZE,\n\t.msize\t\t= STATS_PWR_USB_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Filesystem usage activity. Switch: -F */\nstruct activity filesystem_act = {\n\t.id\t\t= A_FS,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM + AO_MULTIPLE_OUTPUTS,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE + 1,\n\t.group\t\t= G_XDISK,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 9,\t/* wrap_get_filesystem_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_filesystem,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_filesystem_stats,\n\t.f_print_avg\t= print_avg_filesystem_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"FILESYSTEM;MBfsfree;MBfsused;%fsused;%ufsused;Ifree;Iused;%Iused|\"\n\t\t\t  \"MOUNTPOINT;MBfsfree;MBfsused;%fsused;%ufsused;Ifree;Iused;%Iused\",\n#endif\n\t.gtypes_nr\t= {STATS_FILESYSTEM_ULL, STATS_FILESYSTEM_UL, STATS_FILESYSTEM_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_filesystem_stats,\n\t.f_xml_print\t= xml_print_filesystem_stats,\n\t.f_json_print\t= json_print_filesystem_stats,\n\t.f_svg_print\t= svg_print_filesystem_stats,\n\t.f_raw_print\t= raw_print_filesystem_stats,\n\t.f_pcp_print\t= pcp_print_filesystem_stats,\n\t.f_count_new\t= count_new_filesystem,\n\t.desc\t\t= \"Filesystems statistics\",\n#endif\n\t.name\t\t= \"A_FS\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_FS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_FILESYSTEM_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_FILESYSTEM_SIZE,\n\t.msize\t\t= STATS_FILESYSTEM_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Fibre Channel HBA usage activity. Switch: -n FC */\nstruct activity fchost_act = {\n\t.id\t\t= A_NET_FC,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DISK,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 10,\t/* wrap_get_fchost_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_fchost,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_fchost_stats,\n\t.f_print_avg\t= print_fchost_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"FCHOST;fch_rxf/s;fch_txf/s;fch_rxw/s;fch_txw/s\",\n#endif\n\t.gtypes_nr\t= {STATS_FCHOST_ULL, STATS_FCHOST_UL, STATS_FCHOST_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_fchost_stats,\n\t.f_xml_print\t= xml_print_fchost_stats,\n\t.f_json_print\t= json_print_fchost_stats,\n\t.f_svg_print\t= svg_print_fchost_stats,\n\t.f_raw_print\t= raw_print_fchost_stats,\n\t.f_pcp_print\t= pcp_print_fchost_stats,\n\t.f_count_new\t= count_new_fchost,\n\t.desc\t\t= \"Fibre Channel HBA statistics\",\n#endif\n\t.name\t\t= \"A_NET_FC\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_FCHOSTS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_FCHOST_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_FCHOST_SIZE,\n\t.msize\t\t= STATS_FCHOST_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Softnet activity. Switch: -n SOFT */\nstruct activity softnet_act = {\n\t.id\t\t= A_NET_SOFT,\n\t.options\t= AO_COLLECTED + AO_COUNTED + AO_CLOSE_MARKUP +\n\t\t\t  AO_GRAPH_PER_ITEM + AO_PERSISTENT,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 0,\t/* wrap_get_cpu_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_softnet,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_softnet_stats,\n\t.f_print_avg\t= print_avg_softnet_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"CPU;total/s;dropd/s;squeezd/s;rx_rps/s;flw_lim/s;blg_len\",\n#endif\n\t.gtypes_nr\t= {STATS_SOFTNET_ULL, STATS_SOFTNET_UL, STATS_SOFTNET_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_softnet_stats,\n\t.f_xml_print\t= xml_print_softnet_stats,\n\t.f_json_print\t= json_print_softnet_stats,\n\t.f_svg_print\t= svg_print_softnet_stats,\n\t.f_raw_print\t= raw_print_softnet_stats,\n\t.f_pcp_print\t= pcp_print_softnet_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Software-based network processing statistics\",\n#endif\n\t.name\t\t= \"A_NET_SOFT\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 3,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= NR_CPUS + 1,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_SOFTNET_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_SOFTNET_SIZE,\n\t.msize\t\t= STATS_SOFTNET_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= &cpu_bitmap\n};\n\n/* Pressure-stall CPU activity. Switch: -q CPU */\nstruct activity psi_cpu_act = {\n\t.id\t\t= A_PSI_CPU,\n\t.options\t= AO_COLLECTED + AO_DETECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 11,\t/* wrap_detect_psi() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_psicpu,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_psicpu_stats,\n\t.f_print_avg\t= print_avg_psicpu_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"%scpu-10;%scpu-60;%scpu-300;%scpu\",\n#endif\n\t.gtypes_nr\t= {STATS_PSI_CPU_ULL, STATS_PSI_CPU_UL, STATS_PSI_CPU_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_psicpu_stats,\n\t.f_xml_print\t= xml_print_psicpu_stats,\n\t.f_json_print\t= json_print_psicpu_stats,\n\t.f_svg_print\t= svg_print_psicpu_stats,\n\t.f_raw_print\t= raw_print_psicpu_stats,\n\t.f_pcp_print\t= pcp_print_psicpu_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Pressure-stall CPU statistics\",\n#endif\n\t.name\t\t= \"A_PSI_CPU\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 2,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PSI_CPU_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PSI_CPU_SIZE,\n\t.msize\t\t= STATS_PSI_CPU_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Pressure-stall I/O activity. Switch: -q IO */\nstruct activity psi_io_act = {\n\t.id\t\t= A_PSI_IO,\n\t.options\t= AO_COLLECTED + AO_DETECTED,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 11,\t/* wrap_detect_psi() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_psiio,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_psiio_stats,\n\t.f_print_avg\t= print_avg_psiio_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"%sio-10;%sio-60;%sio-300;%sio;%fio-10;%fio-60;%fio-300;%fio\",\n#endif\n\t.gtypes_nr\t= {STATS_PSI_IO_ULL, STATS_PSI_IO_UL, STATS_PSI_IO_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_psiio_stats,\n\t.f_xml_print\t= xml_print_psiio_stats,\n\t.f_json_print\t= json_print_psiio_stats,\n\t.f_svg_print\t= svg_print_psiio_stats,\n\t.f_raw_print\t= raw_print_psiio_stats,\n\t.f_pcp_print\t= pcp_print_psiio_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Pressure-stall I/O statistics\",\n#endif\n\t.name\t\t= \"A_PSI_IO\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PSI_IO_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PSI_IO_SIZE,\n\t.msize\t\t= STATS_PSI_IO_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Pressure-stall memory activity. Switch: -q MEM */\nstruct activity psi_mem_act = {\n\t.id\t\t= A_PSI_MEM,\n\t.options\t= AO_COLLECTED + AO_DETECTED + AO_CLOSE_MARKUP,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_DEFAULT,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 11,\t/* wrap_detect_psi() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_psimem,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_psimem_stats,\n\t.f_print_avg\t= print_avg_psimem_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"%smem-10;%smem-60;%smem-300;%smem;%fmem-10;%fmem-60;%fmem-300;%fmem\",\n#endif\n\t.gtypes_nr\t= {STATS_PSI_MEM_ULL, STATS_PSI_MEM_UL, STATS_PSI_MEM_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_psimem_stats,\n\t.f_xml_print\t= xml_print_psimem_stats,\n\t.f_json_print\t= json_print_psimem_stats,\n\t.f_svg_print\t= svg_print_psimem_stats,\n\t.f_raw_print\t= raw_print_psimem_stats,\n\t.f_pcp_print\t= pcp_print_psimem_stats,\n\t.f_count_new\t= NULL,\n\t.desc\t\t= \"Pressure-stall memory statistics\",\n#endif\n\t.name\t\t= \"A_PSI_MEM\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 4,\n\t.nr_ini\t\t= 1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= 1,\n\t.nr\t\t= {1, 1, 1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PSI_MEM_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PSI_MEM_SIZE,\n\t.msize\t\t= STATS_PSI_MEM_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n/* Battery capacity. Switch: -m BAT */\nstruct activity pwr_bat_act = {\n\t.id\t\t= A_PWR_BAT,\n\t.options\t= AO_COUNTED + AO_GRAPH_PER_ITEM,\n\t.magic\t\t= ACTIVITY_MAGIC_BASE,\n\t.group\t\t= G_POWER,\n#ifdef SOURCE_SADC\n\t.f_count_index\t= 13,\t/* wrap_get_bat_nr() */\n\t.f_count2_index\t= -1,\n\t.f_read\t\t= wrap_read_bat,\n#endif\n#ifdef SOURCE_SAR\n\t.f_print\t= print_pwr_bat_stats,\n\t.f_print_avg\t= print_avg_pwr_bat_stats,\n#endif\n#if defined(SOURCE_SAR) || defined(SOURCE_SADF)\n\t.hdr_line\t= \"BAT;%cap;cap/min;status\",\n#endif\n\t.gtypes_nr\t= {STATS_PWR_BAT_ULL, STATS_PWR_BAT_UL, STATS_PWR_BAT_U},\n\t.ftypes_nr\t= {0, 0, 0},\n#ifdef SOURCE_SADF\n\t.f_render\t= render_pwr_bat_stats,\n\t.f_xml_print\t= xml_print_pwr_bat_stats,\n\t.f_json_print\t= json_print_pwr_bat_stats,\n\t.f_svg_print\t= svg_print_pwr_bat_stats,\n\t.f_raw_print\t= raw_print_pwr_bat_stats,\n\t.f_pcp_print\t= pcp_print_pwr_bat_stats,\n\t.f_count_new\t= count_new_bat,\n\t.desc\t\t= \"Batteries capacity\",\n#endif\n\t.name\t\t= \"A_PWR_BAT\",\n\t.item_list\t= NULL,\n\t.item_list_sz\t= 0,\n\t.g_nr\t\t= 1,\n\t.nr_ini\t\t= -1,\n\t.nr2\t\t= 1,\n\t.nr_max\t\t= MAX_NR_BATS,\n\t.nr\t\t= {-1, -1, -1},\n\t.nr_allocated\t= 0,\n\t.xnr\t\t= STATS_PWR_BAT_XNR,\n\t.xdev_list\t= NULL,\n\t.fsize\t\t= STATS_PWR_BAT_SIZE,\n\t.msize\t\t= STATS_PWR_BAT_SIZE,\n\t.opt_flags\t= 0,\n\t.buf\t\t= {NULL, NULL, NULL},\n\t.spmin\t\t= NULL,\n\t.spmax\t\t= NULL,\n\t.nr_spalloc\t= 0,\n\t.bitmap\t\t= NULL\n};\n\n#ifdef SOURCE_SADC\n/*\n * Array of functions used to count number of items.\n */\n__nr_t (*f_count[NR_F_COUNT]) (struct activity *) = {\n\twrap_get_cpu_nr,\t/* 0 */\n\twrap_get_irq_nr,\t/* 1 */\n\twrap_get_serial_nr,\t/* 2 */\n\twrap_get_disk_nr,\t/* 3 */\n\twrap_get_iface_nr,\t/* 4 */\n\twrap_get_fan_nr,\t/* 5 */\n\twrap_get_temp_nr,\t/* 6 */\n\twrap_get_in_nr,\t\t/* 7 */\n\twrap_get_usb_nr,\t/* 8 */\n\twrap_get_filesystem_nr,\t/* 9 */\n\twrap_get_fchost_nr,\t/* 10 */\n\twrap_detect_psi,\t/* 11 */\n\twrap_get_freq_nr,\t/* 12 */\n\twrap_get_bat_nr\t\t/* 13 */\n};\n#endif\n\n/*\n * Array of activities.\n * (Order of activities doesn't matter for daily data files).\n */\nstruct activity *act[NR_ACT] = {\n\t&cpu_act,\n\t&pcsw_act,\n\t&irq_act,\n\t&swap_act,\n\t&paging_act,\n\t&io_act,\n\t&memory_act,\n\t&huge_act,\n\t&ktables_act,\n\t&queue_act,\n\t&serial_act,\n\t&disk_act,\n\t/* <network> */\n\t&net_dev_act,\n\t&net_edev_act,\n\t&net_nfs_act,\n\t&net_nfsd_act,\n\t&net_sock_act,\n\t&net_ip_act,\n\t&net_eip_act,\n\t&net_icmp_act,\n\t&net_eicmp_act,\n\t&net_tcp_act,\n\t&net_etcp_act,\n\t&net_udp_act,\n\t&net_sock6_act,\n\t&net_ip6_act,\n\t&net_eip6_act,\n\t&net_icmp6_act,\n\t&net_eicmp6_act,\n\t&net_udp6_act,\n\t&fchost_act,\n\t&softnet_act,\t/* AO_CLOSE_MARKUP */\n\t/* </network> */\n\t/* <power-management> */\n\t&pwr_cpufreq_act,\n\t&pwr_fan_act,\n\t&pwr_temp_act,\n\t&pwr_in_act,\n\t&pwr_wghfreq_act,\n\t&pwr_bat_act,\n\t&pwr_usb_act,\t/* AO_CLOSE_MARKUP */\n\t/* </power-management> */\n\t&filesystem_act,\n\t/* <psi> */\n\t&psi_cpu_act,\n\t&psi_io_act,\n\t&psi_mem_act\t/* AO_CLOSE_MARKUP */\n\t/* </psi> */\n};\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "cifsiostat.c",
          "type": "blob",
          "size": 20.5673828125,
          "content": "/*\n * cifsiostat: Report I/O statistics for CIFS filesystems.\n * Copyright (C) 2010 Red Hat, Inc. All Rights Reserved\n * Written by Ivana Varekova <varekova@redhat.com>\n * Maintained / multiple enhancements by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA                   *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n\n#include \"version.h\"\n#include \"cifsiostat.h\"\n#include \"rd_stats.h\"\n#include \"count.h\"\n\n#include <locale.h>\t/* For setlocale() */\n#ifdef USE_NLS\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern int __env;\n#endif\n\nunsigned long long uptime_cs[2] = {0, 0};\nstruct io_cifs *cifs_list = NULL;\n\nint cpu_nr = 0;\t\t/* Nb of processors on the machine */\nuint64_t flags = 0;\t/* Flag for common options and system state */\nuint64_t xflags = 0;\t/* Extended flag for options used by multiple commands */\nint dplaces_nr = -1;\t/* Number of decimal places */\n\nlong interval = 0;\nchar timestamp[TIMESTAMP_LEN];\n\nstruct sigaction alrm_act, int_act;\nint sigint_caught = 0;\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command.\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ]\\n\"),\n\t\tprogname);\n\n#ifdef DEBUG\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ --dec={ 0 | 1 | 2 } ] [ --human ] [ --pretty ] [ -o JSON ]\\n\"\n\t\t\t  \"[ -h ] [ -k | -m ] [ -t ] [ -V ] [ -y ] [ --debuginfo ]\\n\"));\n#else\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ --dec={ 0 | 1 | 2 } ] [ --human ] [ --pretty ] [ -o JSON ]\\n\"\n\t\t\t  \"[ -h ] [ -k | -m ] [ -t ] [ -V ] [ -y ]\\n\"));\n#endif\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * SIGALRM signal handler.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid alarm_handler(int sig)\n{\n\talarm(interval);\n}\n\n/*\n * **************************************************************************\n * SIGINT signal handler.\n *\n * IN:\n * @sig\tSignal number.\n **************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tsigint_caught = 1;\n}\n\n/*\n ***************************************************************************\n * Set every cifs entry to nonexistent status.\n *\n * IN:\n * @clist\tPointer on the start of the linked list.\n ***************************************************************************\n */\nvoid set_cifs_nonexistent(struct io_cifs *clist)\n{\n\twhile (clist != NULL) {\n\t\tclist->exist = FALSE;\n\t\tclist = clist->next;\n\t}\n}\n\n/*\n ***************************************************************************\n * Check if a cifs filesystem is present in the list, and add it if requested.\n *\n * IN:\n * @clist\tAddress of pointer on the start of the linked list.\n * @name\tcifs name.\n *\n * RETURNS:\n * Pointer on the io_cifs structure in the list where the cifs is located\n * (whether it was already in the list or if it has been added).\n * NULL if the cifs name is too long or if the cifs doesn't exist and we\n * don't want to add it.\n ***************************************************************************\n */\nstruct io_cifs *add_list_cifs(struct io_cifs **clist, char *name)\n{\n\tstruct io_cifs *c, *cs;\n\tint i;\n\n\tif (strnlen(name, MAX_NAME_LEN) == MAX_NAME_LEN)\n\t\t/* cifs name is too long */\n\t\treturn NULL;\n\n\twhile (*clist != NULL) {\n\n\t\tc = *clist;\n\t\tif ((i = strcmp(c->name, name)) == 0) {\n\t\t\t/* cifs found in list */\n\t\t\tc->exist = TRUE;\n\t\t\treturn c;\n\t\t}\n\t\tif (i > 0)\n\t\t\t/*\n\t\t\t * If no group defined and we don't use /proc/diskstats,\n\t\t\t * insert current device in alphabetical order.\n\t\t\t * NB: Using /proc/diskstats (\"iostat -p ALL\") is a bit better than\n\t\t\t * using alphabetical order because sda10 comes after sda9...\n\t\t\t */\n\t\t\tbreak;\n\n\t\tclist = &(c->next);\n\t}\n\n\t/* cifs not found */\n\tcs = *clist;\n\n\t/* Add cifs to the list */\n\tif ((*clist = (struct io_cifs *) malloc(IO_CIFS_SIZE)) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tmemset(*clist, 0, IO_CIFS_SIZE);\n\n\tc = *clist;\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((c->cifs_stats[i] = (struct cifs_st *) malloc(CIFS_ST_SIZE)) == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(4);\n\t\t}\n\t\tmemset(c->cifs_stats[i], 0, CIFS_ST_SIZE);\n\t}\n\tstrncpy(c->name, name, sizeof(c->name));\n\tc->name[sizeof(c->name) - 1] = '\\0';\n\tc->exist = TRUE;\n\tc->next = cs;\n\n\treturn c;\n}\n\n/*\n ***************************************************************************\n * Read CIFS-mount directories stats from /proc/fs/cifs/Stats.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 1 if no CIFS filesystems found, and 0 otherwise.\n ***************************************************************************\n */\nint read_cifs_stat(int curr)\n{\n\tFILE *fp;\n\tchar line[256];\n\tchar aux[32];\n\tint start = 0;\n\tlong long unsigned aux_open;\n\tlong long unsigned all_open = 0;\n\tchar cifs_name[MAX_NAME_LEN];\n\tchar name_tmp[MAX_NAME_LEN];\n\tstruct cifs_st scifs;\n\tstruct io_cifs *ci;\n\n\tif ((fp = fopen(CIFSSTATS, \"r\")) == NULL)\n\t\treturn 1;\n\n\tsprintf(aux, \"%%*d) %%%ds\",\n\t\tMAX_NAME_LEN < 200 ? MAX_NAME_LEN - 1 : 200);\n\n\tmemset(&scifs, 0, CIFS_ST_SIZE);\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\t/* Read CIFS directory name */\n\t\tif (isdigit((unsigned char) line[0]) && sscanf(line, aux , name_tmp) == 1) {\n\t\t\tif (start) {\n\t\t\t\tscifs.fopens = all_open;\n\t\t\t\tci = add_list_cifs(&cifs_list, cifs_name);\n\t\t\t\tif (ci != NULL) {\n\t\t\t\t\t*ci->cifs_stats[curr] = scifs;\n\t\t\t\t}\n\t\t\t\tall_open = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t\tstrncpy(cifs_name, name_tmp, sizeof(cifs_name));\n\t\t\tcifs_name[sizeof(cifs_name) - 1] = '\\0';\n\t\t\tmemset(&scifs, 0, CIFS_ST_SIZE);\n\t\t}\n\t\telse {\n\t\t\tif (!strncmp(line, \"Reads:\", 6)) {\n\t\t\t\t/*\n\t\t\t\t * SMB1 format: Reads: %llu Bytes: %llu\n\t\t\t\t * SMB2 format: Reads: %llu sent %llu failed\n\t\t\t\t * If this is SMB2 format then only the first variable (rd_ops) will be set.\n\t\t\t\t */\n\t\t\t\tsscanf(line, \"Reads: %llu Bytes: %llu\", &scifs.rd_ops, &scifs.rd_bytes);\n\t\t\t}\n\t\t\telse if (!strncmp(line, \"Bytes read:\", 11)) {\n\t\t\t\tsscanf(line, \"Bytes read: %llu  Bytes written: %llu\",\n\t\t\t\t       &scifs.rd_bytes, &scifs.wr_bytes);\n\t\t\t}\n\t\t\telse if (!strncmp(line, \"Writes:\", 7)) {\n\t\t\t\t/*\n\t\t\t\t * SMB1 format: Writes: %llu Bytes: %llu\n\t\t\t\t * SMB2 format: Writes: %llu sent %llu failed\n\t\t\t\t * If this is SMB2 format then only the first variable (wr_ops) will be set.\n\t\t\t\t */\n\t\t\t\tsscanf(line, \"Writes: %llu Bytes: %llu\", &scifs.wr_ops, &scifs.wr_bytes);\n\t\t\t}\n\t\t\telse if (!strncmp(line, \"Opens:\", 6)) {\n\t\t\t\tsscanf(line, \"Opens: %llu Closes:%llu Deletes: %llu\",\n\t\t\t\t       &aux_open, &scifs.fcloses, &scifs.fdeletes);\n\t\t\t\tall_open += aux_open;\n\t\t\t}\n\t\t\telse if (!strncmp(line, \"Posix Opens:\", 12)) {\n\t\t\t\tsscanf(line, \"Posix Opens: %llu\", &aux_open);\n\t\t\t\tall_open += aux_open;\n\t\t\t}\n\t\t\telse if (!strncmp(line, \"Open files:\", 11)) {\n\t\t\t\tsscanf(line, \"Open files: %llu total (local), %llu\",\n\t\t\t\t       &all_open, &aux_open);\n\t\t\t\tall_open += aux_open;\n\t\t\t}\n\t\t\telse if (!strncmp(line, \"Closes:\", 7)) {\n\t\t\t\tsscanf(line, \"Closes: %llu\", &scifs.fcloses);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start) {\n\t\tscifs.fopens = all_open;\n\t\tci = add_list_cifs(&cifs_list, cifs_name);\n\t\tif (ci != NULL) {\n\t\t\t*ci->cifs_stats[curr] = scifs;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Display CIFS stats header.\n *\n * OUT:\n * @fctr\tConversion factor.\n * @tab\t\tNumber of tabs to print (JSON format only).\n ***************************************************************************\n */\nvoid write_cifs_stat_header(int *fctr, int *tab)\n{\n\tchar *units, *spc;\n\n\tif (DISPLAY_KILOBYTES(flags)) {\n\t\t*fctr = 1024;\n\t\tunits = \"kB\";\n\t\tspc = \"\";\n\t}\n\telse if (DISPLAY_MEGABYTES(flags)) {\n\t\t*fctr = 1024 * 1024;\n\t\tunits = \"MB\";\n\t\tspc = \"\";\n\t}\n\telse {\n\t\t*fctr = 1;\n\t\tunits = \"B\";\n\t\tspc = \" \";\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf((*tab)++, \"\\\"filesystem\\\": [\");\n\t\treturn;\n\t}\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tprintf(\"Filesystem            \");\n\t}\n\n\tprintf(\"        %sr%s/s        %sw%s/s\"\n\t       \"    rops/s    wops/s         fo/s         fc/s         fd/s\",\n\t       spc, units, spc, units);\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tprintf(\" Filesystem\");\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Write CIFS stats read from /proc/fs/cifs/Stats in plain format.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time (in 1/100th of a second).\n * @fctr\tConversion factor.\n * @clist\tPointer on the linked list where the cifs is saved.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n ***************************************************************************\n */\nvoid write_plain_cifs_stat(int curr, unsigned long long itv, int fctr,\n\t\t\t   struct io_cifs *clist, struct cifs_st *ioni,\n\t\t\t   struct cifs_st *ionj)\n{\n\tdouble rbytes, wbytes;\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \"%-22s\", clist->name, 0);\n\t}\n\n\t/*       rB/s   wB/s   fo/s   fc/s   fd/s*/\n\trbytes = S_VALUE(ionj->rd_bytes, ioni->rd_bytes, itv);\n\twbytes = S_VALUE(ionj->wr_bytes, ioni->wr_bytes, itv);\n\tif (!DISPLAY_UNIT(flags)) {\n\t\trbytes /= fctr;\n\t\twbytes /= fctr;\n\t}\n\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_BYTE : NO_UNIT, FALSE, 2, 12, 2,\n\t\t  rbytes, wbytes);\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t  S_VALUE(ionj->rd_ops, ioni->rd_ops, itv),\n\t\t  S_VALUE(ionj->wr_ops, ioni->wr_ops, itv));\n\tcprintf_f(NO_UNIT, FALSE, 3, 12, 2,\n\t\t  S_VALUE(ionj->fopens, ioni->fopens, itv),\n\t\t  S_VALUE(ionj->fcloses, ioni->fcloses, itv),\n\t\t  S_VALUE(ionj->fdeletes, ioni->fdeletes, itv));\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", clist->name, 0);\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Write CIFS stats read from /proc/fs/cifs/Stats in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time (in 1/100th of a second).\n * @fctr\tConversion factor.\n * @clist\tPointer on the linked list where the cifs is saved.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n ***************************************************************************\n */\nvoid write_json_cifs_stat(int tab, int curr, unsigned long long itv, int fctr,\n\t\t\t  struct io_cifs *clist, struct cifs_st *ioni,\n\t\t\t  struct cifs_st *ionj)\n{\n\tchar line[256];\n\n\txprintf0(tab,\n\t\t \"{\\\"fs_name\\\": \\\"%s\\\", \", escape_bs_char(clist->name));\n\n\tif (DISPLAY_KILOBYTES(flags)) {\n\t\tsprintf(line, \"\\\"rkB/s\\\": %%.2f, \\\"wkB/s\\\": %%.2f, \");\n\t}\n\telse if (DISPLAY_MEGABYTES(flags)) {\n\t\tsprintf(line, \"\\\"rMB/s\\\": %%.2f, \\\"wMB/s\\\": %%.2f, \");\n\t}\n\telse {\n\t\tsprintf(line, \"\\\"rB/s\\\": %%.2f, \\\"wB/s\\\": %%.2f, \");\n\t}\n\tprintf(line,\n\t       S_VALUE(ionj->rd_bytes, ioni->rd_bytes, itv) / fctr,\n\t       S_VALUE(ionj->wr_bytes, ioni->wr_bytes, itv) / fctr);\n\n\tprintf(\"\\\"rops/s\\\": %.2f, \\\"wops/s\\\": %.2f, \"\n\t       \"\\\"fo/s\\\": %.2f, \\\"fc/s\\\": %.2f, \\\"fd/s\\\": %.2f}\",\n\t       S_VALUE(ionj->rd_ops, ioni->rd_ops, itv),\n\t       S_VALUE(ionj->wr_ops, ioni->wr_ops, itv),\n\t       S_VALUE(ionj->fopens, ioni->fopens, itv),\n\t       S_VALUE(ionj->fcloses, ioni->fcloses, itv),\n\t       S_VALUE(ionj->fdeletes, ioni->fdeletes, itv));\n}\n\n/*\n ***************************************************************************\n * Write CIFS stats read from /proc/fs/cifs/Stats in plain or JSON format.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time (in 1/100th of a second).\n * @fctr\tConversion factor.\n * @clist\tPointer on the linked list where the cifs is saved.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @tab\t\tNumber of tabs to print (JSON format only).\n ***************************************************************************\n */\nvoid write_cifs_stat(int curr, unsigned long long itv, int fctr,\n\t\t     struct io_cifs *clist, struct cifs_st *ioni,\n\t\t     struct cifs_st *ionj, int tab)\n{\n#ifdef DEBUG\n\tif (DISPLAY_DEBUG(xflags)) {\n\t\t/* Debug output */\n\t\tfprintf(stderr, \"name=%s itv=%llu fctr=%d ioni{ rd_bytes=%llu \"\n\t\t\"wr_bytes=%llu rd_ops=%llu wr_ops=%llu fopens=%llu \"\n\t\t\"fcloses=%llu fdeletes=%llu}\\n\",\n\t  clist->name, itv, fctr,\n\t  ioni->rd_bytes, ioni->wr_bytes,\n\t  ioni->rd_ops,   ioni->wr_ops,\n\t  ioni->fopens,   ioni->fcloses,\n\t  ioni->fdeletes);\n\t}\n#endif\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\twrite_json_cifs_stat(tab, curr, itv, fctr, clist, ioni, ionj);\n\t}\n\telse {\n\t\twrite_plain_cifs_stat(curr, itv, fctr, clist, ioni, ionj);\n\t}\n}\n\n/*\n ***************************************************************************\n * Print everything now (stats and uptime).\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @rectime\tCurrent date and time.\n ***************************************************************************\n */\nvoid write_stats(int curr, struct tm *rectime)\n{\n\tint fctr = 1, tab = 4, next = FALSE;\n\tunsigned long long itv;\n\tstruct io_cifs *clist;\n\tstruct cifs_st *ioni, *ionj;\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf(tab++, \"{\");\n\t}\n\n\t/* Print time stamp */\n\tif (DISPLAY_TIMESTAMP(flags)) {\n\t\twrite_sample_timestamp(tab, rectime, xflags);\n\t}\n\n\t/* Interval of time, reduced to one processor */\n\titv = get_interval(uptime_cs[!curr], uptime_cs[curr]);\n\n\t/* Display CIFS stats header */\n\twrite_cifs_stat_header(&fctr, &tab);\n\n\tfor (clist = cifs_list; clist != NULL; clist = clist->next) {\n\n\t\tif (!clist->exist)\n\t\t\t/* Current cifs non existent */\n\t\t\tcontinue;\n\n\t\tioni = clist->cifs_stats[curr];\n\t\tionj = clist->cifs_stats[!curr];\n\n\t\tif (DISPLAY_JSON_OUTPUT(xflags) && next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\twrite_cifs_stat(curr, itv, fctr, clist, ioni, ionj, tab);\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\n\");\n\t\txprintf(--tab, \"]\");\n\t\txprintf0(--tab, \"}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Main loop: Read stats from the relevant sources and display them.\n *\n * IN:\n * @count\tNumber of lines of stats to print.\n * @rectime\tCurrent date and time.\n ***************************************************************************\n */\nvoid rw_io_stat_loop(long int count, struct tm *rectime)\n{\n\tint curr = 1;\n\tint skip = 0;\n\n\t/* Should we skip first report? */\n\tif (DISPLAY_OMIT_SINCE_BOOT(flags) && interval > 0) {\n\t\tskip = 1;\n\t}\n\n\t/* Set a handler for SIGALRM */\n\tmemset(&alrm_act, 0, sizeof(alrm_act));\n\talrm_act.sa_handler = alarm_handler;\n\tsigaction(SIGALRM, &alrm_act, NULL);\n\talarm(interval);\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\tdo {\n\t\t/* Every device is potentially nonexistent */\n\t\tset_cifs_nonexistent(cifs_list);\n\n\t\t/* Read system uptime in 1/100th of a second */\n\t\tread_uptime(&(uptime_cs[curr]));\n\n\t\t/* Read CIFS stats */\n\t\tif (read_cifs_stat(curr)) {\n\t\t\t/* No CIFS fs found */\n\t\t\tif (!DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\t\tfprintf(stderr, _(\"No CIFS filesystems with statistics found\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Don't exit now if displaying stats in JSON format so that\n\t\t\t * JSON file can be properly terminated.\n\t\t\t */\n\t\t\tcount = 0;\n\t\t}\n\n\t\t/* Get time */\n\t\tget_xtime(rectime, 0, LOCAL_TIME);\n\n\t\t/* Check whether we should skip first report */\n\t\tif (!skip) {\n\t\t\t/* Print results */\n\t\t\twrite_stats(curr, rectime);\n\n\t\t\tif (count > 0) {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\t\t\tcurr ^= 1;\n\t\t\t__pause();\n\n\t\t\tif (sigint_caught) {\n\t\t\t\t/* SIGINT signal caught => Terminate JSON output properly */\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse if (DISPLAY_JSON_OUTPUT(xflags) && !skip) {\t/* count != 0 */\n\t\t\t\tprintf(\",\");\n\t\t\t}\n\t\t}\n\t\tskip = 0;\n\t\tprintf(\"\\n\");\n\t}\n\twhile (count);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}}\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Main entry to the cifsiostat program.\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint it = 0;\n\tint opt = 1;\n\tint i;\n\tlong count = 1;\n\tstruct utsname header;\n\tstruct tm rectime;\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\t/* Init color strings */\n\tinit_colors();\n\n\t/* Process args... */\n\twhile (opt < argc) {\n\n#ifdef DEBUG\n\t\tif (!strcmp(argv[opt], \"--debuginfo\")) {\n\t\t\txflags |= X_D_DEBUG;\n\t\t\topt++;\n\t\t} else\n#endif\n\n\t\tif (!strcmp(argv[opt], \"--human\")) {\n\t\t\tflags |= I_D_UNIT;\n\t\t\topt++;\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t\topt++;\n\t\t}\n#endif\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\t/* Select output format */\n\t\t\tif (argv[++opt] && !strcmp(argv[opt], K_JSON)) {\n\t\t\t\txflags |= X_D_JSON_OUTPUT;\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--pretty\")) {\n\t\t\t/* Display an easy-to-read CIFS report */\n\t\t\tflags |= I_D_PRETTY;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--dec=\", 6) && (strlen(argv[opt]) == 7)) {\n\t\t\t/* Check that the argument is a digit */\n\t\t\tif (!isdigit(argv[opt][6])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\n\t\t\t/* Get number of decimal places */\n\t\t\tdplaces_nr = atoi(argv[opt] + 6);\n\t\t\tif ((dplaces_nr < 0) || (dplaces_nr > 2)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\tfor (i = 1; *(argv[opt] + i); i++) {\n\n\t\t\t\tswitch (*(argv[opt] + i)) {\n\n\t\t\t\tcase 'h':\n\t\t\t\t\t/* Option -h is equivalent to --pretty --human */\n\t\t\t\t\tflags |= I_D_PRETTY + I_D_UNIT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'k':\n\t\t\t\t\tif (DISPLAY_MEGABYTES(flags)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\t/* Display stats in kB/s */\n\t\t\t\t\tflags |= I_D_KILOBYTES;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'm':\n\t\t\t\t\tif (DISPLAY_KILOBYTES(flags)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\t/* Display stats in MB/s */\n\t\t\t\t\tflags |= I_D_MEGABYTES;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 't':\n\t\t\t\t\t/* Display timestamp */\n\t\t\t\t\tflags |= I_D_TIMESTAMP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'y':\n\t\t\t\t\t/* Don't display stats since system restart */\n\t\t\t\t\tflags |= I_D_OMIT_SINCE_BOOT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'V':\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *cifsiostat_env[] = {ENV_COLORS,\n\t\t\t\t\t\t\t\t\t  ENV_COLORS_SGR,\n\t\t\t\t\t\t\t\t\t  ENV_TIME_FMT};\n#define CIFSIOSTAT_ENV_NR\t3\n\t\t\t\t\t\t/* Print environment contents, version number and exit */\n\t\t\t\t\t\tprint_version(cifsiostat_env, CIFSIOSTAT_ENV_NR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!it) {\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = -1;\n\t\t\tit = 1;\n\t\t}\n\n\t\telse if (it > 0) {\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif ((count < 1) || !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tit = -1;\n\t\t}\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!interval) {\n\t\tcount = 1;\n\t}\n\n\t/* How many processors on this machine? */\n\tcpu_nr = get_cpu_nr(~0, FALSE);\n\n\tget_xtime(&rectime, 0, LOCAL_TIME);\n\n\t/*\n\t * Don't buffer data if redirected to a pipe.\n\t * Note: With musl-c, the behavior of this function is undefined except\n\t * when it is the first operation on the stream.\n\t */\n\tsetbuf(stdout, NULL);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t/* Use a decimal point to make JSON code compliant with RFC7159 */\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t}\n\n\t/* Get system name, release number and hostname */\n\t__uname(&header);\n\tif (print_gal_header(&rectime, header.sysname, header.release,\n\t\t\t     header.nodename, header.machine, cpu_nr,\n\t\t\t     DISPLAY_JSON_OUTPUT(xflags))) {\n\t\txflags |= X_D_ISO;\n\t}\n\n\tif (!DISPLAY_JSON_OUTPUT(xflags) &&\n\t\t(!DISPLAY_OMIT_SINCE_BOOT(flags) || (interval == 0))) {\n\t\tprintf(\"\\n\");\n\t\t}\n\n\t/* Main loop */\n\trw_io_stat_loop(count, &rectime);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "cifsiostat.h",
          "type": "blob",
          "size": 1.6357421875,
          "content": "/*\n * cifsiostat: Report CIFS statistics\n * Copyright (C) 2010 Red Hat, Inc. All Rights Reserved\n * Written by Ivana Varekova <varekova@redhat.com>\n */\n\n#ifndef _CIFSIOSTAT_H\n#define _CIFSIOSTAT_H\n\n#include \"common.h\"\n\n#define CIFSSTATS  PRE \"/proc/fs/cifs/Stats\"\n\n/* I_: cifsiostat - D_: Display - F_: Flag */\n#define I_D_TIMESTAMP\t\t0x001\n#define I_D_KILOBYTES\t\t0x002\n#define I_D_MEGABYTES\t\t0x004\n#define I_D_OMIT_SINCE_BOOT\t0x008\n#define I_D_PRETTY\t\t0x010\n/* Unused\t\t\t0x020 */\n#define I_D_UNIT\t\t0x040\n/* Unused\t\t\t0x080 */\n\n#define DISPLAY_TIMESTAMP(m)\t   (((m) & I_D_TIMESTAMP)        == I_D_TIMESTAMP)\n#define DISPLAY_KILOBYTES(m)\t   (((m) & I_D_KILOBYTES)        == I_D_KILOBYTES)\n#define DISPLAY_MEGABYTES(m)\t   (((m) & I_D_MEGABYTES)        == I_D_MEGABYTES)\n#define DISPLAY_OMIT_SINCE_BOOT(m) (((m) & I_D_OMIT_SINCE_BOOT)  == I_D_OMIT_SINCE_BOOT)\n#define DISPLAY_PRETTY(m)\t   (((m) & I_D_PRETTY)           == I_D_PRETTY)\n#define DISPLAY_UNIT(m)\t\t   (((m) & I_D_UNIT)             == I_D_UNIT)\n\nstruct cifs_st {\n\tunsigned long long rd_bytes     __attribute__ ((aligned (8)));\n\tunsigned long long wr_bytes     __attribute__ ((packed));\n\tunsigned long long rd_ops       __attribute__ ((packed));\n\tunsigned long long wr_ops       __attribute__ ((packed));\n\tunsigned long long fopens       __attribute__ ((packed));\n\tunsigned long long fcloses      __attribute__ ((packed));\n\tunsigned long long fdeletes     __attribute__ ((packed));\n};\n\n#define CIFS_ST_SIZE\t(sizeof(struct cifs_st))\n\nstruct io_cifs {\n\tchar name[MAX_NAME_LEN];\n\tint exist;\n\tstruct cifs_st *cifs_stats[2];\n\tstruct io_cifs *next;\n};\n\n#define IO_CIFS_SIZE\t(sizeof(struct io_cifs))\n\n#endif  /* _CIFSIOSTAT_H */\n"
        },
        {
          "name": "common.c",
          "type": "blob",
          "size": 44.583984375,
          "content": "/*\n * sar, sadc, sadf, mpstat and iostat common routines.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\t/* For STDOUT_FILENO, among others */\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <limits.h>\n#include <libgen.h>\n\n#include \"version.h\"\n#include \"common.h\"\n#include \"ioconf.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n/* Number of decimal places */\nextern int dplaces_nr;\n\n/* Units (sectors, Bytes, kilobytes, etc.) */\nchar units[] = {'s', 'B', 'k', 'M', 'G', 'T', 'P', '?'};\n\n/* Number of ticks per second */\nunsigned long hz;\n/* Number of bit shifts to convert pages to kB */\nunsigned int kb_shift;\n\n/* Colors strings */\nchar sc_percent_warn[MAX_SGR_LEN] = C_BOLD_MAGENTA;\nchar sc_percent_xtreme[MAX_SGR_LEN] = C_BOLD_RED;\nchar sc_zero_int_stat[MAX_SGR_LEN] = C_LIGHT_BLUE;\nchar sc_int_stat[MAX_SGR_LEN] = C_BOLD_BLUE;\nchar sc_item_name[MAX_SGR_LEN] = C_LIGHT_GREEN;\nchar sc_sa_restart[MAX_SGR_LEN] = C_LIGHT_RED;\nchar sc_sa_comment[MAX_SGR_LEN] = C_LIGHT_YELLOW;\nchar sc_trend_pos[MAX_SGR_LEN] = C_BOLD_GREEN;\nchar sc_trend_neg[MAX_SGR_LEN] = C_BOLD_RED;\nchar sc_normal[MAX_SGR_LEN] = C_NORMAL;\n\n/*\n * Type of persistent device names in lowercase letters\n * (e.g. \"uuid\", \"label\", \"path\"...) Used in sar and iostat.\n */\nchar persistent_name_type[MAX_FILE_LEN];\n\n/*\n ***************************************************************************\n * Print sysstat version number, environment variables and exit.\n *\n * IN:\n * @env\t\tArray with environment variable names.\n * @n\t\tNumber of environment variables.\n ***************************************************************************\n */\nvoid print_version(char *env[], int n)\n{\n\tchar *e;\n\tint i;\n\n\t/* Display contents of environment variables */\n\tfor (i = 0; i < n; i++) {\n\t\tif ((e = __getenv(env[i])) != NULL) {\n\t\t\tprintf(\"%s=%s\\n\", env[i], e);\n\t\t}\n\t}\n\n\t/* Print sysstat version number */\n\tprintf(_(\"sysstat version %s\\n\"), VERSION);\n\tprintf(\"(C) Sebastien Godard (sysstat <at> orange.fr)\\n\");\n\n\texit(0);\n}\n\n/*\n ***************************************************************************\n * Get date and time, expressed in UTC or in local time.\n *\n * IN:\n * @d_off\tDay offset (number of days to go back in the past).\n * @utc\t\tTRUE if date and time shall be expressed in UTC.\n *\n * OUT:\n * @rectime\tCurrent local date and time.\n *\n * RETURNS:\n * Value of time in seconds since the Epoch (always in UTC)\n ***************************************************************************\n */\ntime_t get_xtime(struct tm *rectime, int d_off, int utc)\n{\n\ttime_t timer;\n\n\ttimer = __time(NULL);\n\ttimer -= SEC_PER_DAY * d_off;\n\n\tif (utc) {\n\t\t/* Get date and time in UTC */\n\t\tgmtime_r(&timer, rectime);\n\t}\n\telse {\n\t\t/* Get date and time in local time */\n\t\tlocaltime_r(&timer, rectime);\n\t}\n\n\treturn timer;\n}\n\n/*\n ***************************************************************************\n * Get date and time and take into account <ENV_TIME_DEFTM> variable.\n *\n * IN:\n * @d_off\tDay offset (number of days to go back in the past).\n *\n * OUT:\n * @rectime\tCurrent date and time.\n *\n * RETURNS:\n * Value of time in seconds since the Epoch.\n ***************************************************************************\n */\ntime_t get_time(struct tm *rectime, int d_off)\n{\n\tstatic int utc = 0;\n\n\tif (!utc) {\n\t\tchar *e;\n\n\t\t/* Read environment variable value once */\n\t\tif ((e = __getenv(ENV_TIME_DEFTM)) != NULL) {\n\t\t\tutc = !strcmp(e, K_UTC);\n\t\t}\n\t\tutc++;\n\t}\n\n\treturn get_xtime(rectime, d_off, utc == 2);\n}\n\n#ifdef USE_NLS\n/*\n ***************************************************************************\n * Init National Language Support.\n ***************************************************************************\n */\nvoid init_nls(void)\n{\n\tsetlocale(LC_MESSAGES, \"\");\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_TIME, \"\");\n\tsetlocale(LC_NUMERIC, \"\");\n\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n}\n#endif\n\n/*\n ***************************************************************************\n * Test whether given name is a device or a partition, using sysfs.\n *\n * IN:\n * @sysdev\t\tsysfs location.\n * @name\t\tDevice or partition name.\n * @allow_virtual\tTRUE if virtual devices are also accepted.\n *\t\t\tThe device is assumed to be virtual if no\n *\t\t\t/sys/block/<device>/device link exists.\n *\n * RETURNS:\n * TRUE if @name is a device, and FALSE if it's a partition.\n ***************************************************************************\n */\nint is_device(char *sysdev, char *name, int allow_virtual)\n{\n\tchar syspath[PATH_MAX];\n\tchar *slash;\n\n\t/* Some devices may have a slash in their name (eg. cciss/c0d0...) */\n\twhile ((slash = strchr(name, '/'))) {\n\t\t*slash = '!';\n\t}\n\tsnprintf(syspath, sizeof(syspath), \"%s/%s/%s%s\", sysdev, __BLOCK, name,\n\t\t allow_virtual ? \"\" : \"/device\");\n\n\treturn !(access(syspath, F_OK));\n}\n\n/*\n ***************************************************************************\n * Get page shift in kB.\n ***************************************************************************\n */\nvoid get_kb_shift(void)\n{\n\tint shift = 0;\n\tlong size;\n\n\t/* One can also use getpagesize() to get the size of a page */\n\tif ((size = sysconf(_SC_PAGESIZE)) == -1) {\n\t\tperror(\"sysconf\");\n\t}\n\n\tsize >>= 10;\t/* Assume that a page has a minimum size of 1 kB */\n\n\twhile (size > 1) {\n\t\tshift++;\n\t\tsize >>= 1;\n\t}\n\n\tkb_shift = (unsigned int) shift;\n}\n\n/*\n ***************************************************************************\n * Get number of clock ticks per second.\n ***************************************************************************\n */\nvoid get_HZ(void)\n{\n\tlong ticks;\n\n\tif ((ticks = sysconf(_SC_CLK_TCK)) == -1) {\n\t\tperror(\"sysconf\");\n\t}\n\n\thz = (unsigned long) ticks;\n}\n\n/*\n ***************************************************************************\n * Unhandled situation: Panic and exit. Should never happen.\n *\n * IN:\n * @function\tFunction name where situation occured.\n * @error_code\tError code.\n ***************************************************************************\n */\nvoid sysstat_panic(const char *function, int error_code)\n{\n\tfprintf(stderr, \"sysstat: %s[%d]: Internal error...\\n\",\n\t\tfunction, error_code);\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * Extract WWWN identifiers from filename, as read from /dev/disk/by-id.\n *\n * Sample valid names read from /dev/disk/by-id:\n * wwn-0x5000cca369f193ac\n * wwn-0x5000cca369f193ac-part12\n * wwn-0x600605b00a2bdf00242b28c10dcb1999\n * wwn-0x600605b00a2bdf00242b28c10dcb1999-part2\n *\n * WWN ids like these ones are ignored:\n * wwn-0x5438850077615869953x\n * wwn-0x5438850077615869953x-part1\n *\n * IN:\n * @name\tFilename read from /dev/disk/by-id.\n *\n * OUT:\n * @wwn\t\tWWN identifier (8 or 16 hex characters).\n * @part-nr\tPartition number if applicable.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n*/\nint extract_wwnid(char *name, unsigned long long *wwn, unsigned int *part_nr)\n{\n\tchar id[17];\n\tchar *s;\n\tint wwnlen;\n\n\t*wwn = *(wwn + 1) = 0ULL;\n\t*part_nr = 0;\n\n\t/* Check name */\n\tif (((wwnlen = strlen(name)) < 22) || (strncmp(name, \"wwn-0x\", 6)))\n\t\treturn -1;\n\n\t/* Is there a partition number? */\n\tif ((s = strstr(name, \"-part\")) != NULL) {\n\t\t/* Yes: Get partition number */\n\t\tif (sscanf(s + 5, \"%u\", part_nr) == 0)\n\t\t\treturn -1;\n\t\twwnlen = s - name - 6;\n\t}\n\telse {\n\t\twwnlen -= 6;\t/* Don't count \"wwn-0x\" */\n\t}\n\n\t/* Check WWN length */\n\tif ((wwnlen != 16) && (wwnlen != 32))\n\t\treturn -1;\n\n\t/* Extract first 16 hex chars of WWN */\n\tstrncpy(id, name + 6, 16);\n\tid[16] = '\\0';\n\tif (sscanf(id, \"%llx\", wwn) == 0)\n\t\treturn -1;\n\n\tif (strlen(name) < 38)\n\t\t/* This is a short (16 hex chars) WWN id */\n\t\treturn 0;\n\n\t/* Extract second part of WWN */\n\tif (sscanf(name + 22, \"%llx\", wwn + 1) == 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Get WWWN identifiers from a pretty filename using links present in\n * /dev/disk/by-id directory.\n *\n * IN:\n * @pretty\tPretty name (e.g. sda, sdb3...).\n *\n * OUT:\n * @wwn\t\tWWN identifier (8 or 16 hex characters).\n * @part-nr\tPartition number if applicable.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n*/\nint get_wwnid_from_pretty(char *pretty, unsigned long long *wwn, unsigned int *part_nr)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\tssize_t r;\n\tchar link[PATH_MAX], target[PATH_MAX], wwn_name[FILENAME_MAX];\n\tchar *name;\n\tint rc = -1;\n\n\t/* Open  /dev/disk/by-id directory */\n\tif ((dir = opendir(DEV_DISK_BY_ID)) == NULL)\n\t\treturn -1;\n\n\t/* Get current id */\n\twhile ((drd = readdir(dir)) != NULL) {\n\n\t\tif (strncmp(drd->d_name, \"wwn-0x\", 6))\n\t\t\tcontinue;\n\n\t\t/* Get absolute path for current persistent name */\n\t\tsnprintf(link, PATH_MAX, \"%s/%s\", DEV_DISK_BY_ID, drd->d_name);\n\n\t\t/* Persistent name is usually a symlink: Read it... */\n\t\tr = readlink(link, target, PATH_MAX);\n\t\tif ((r <= 0) || (r >= PATH_MAX))\n\t\t\tcontinue;\n\n\t\ttarget[r] = '\\0';\n\n\t\t/* ... and get device pretty name it points at */\n\t\tname = basename(target);\n\t\tif (!name || (name[0] == '\\0'))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(name, pretty, FILENAME_MAX)) {\n\t\t\t/* We have found pretty name for current persistent one */\n\t\t\tstrncpy(wwn_name, drd->d_name, MINIMUM(sizeof(wwn_name), sizeof(drd->d_name)));\n\t\t\twwn_name[sizeof(wwn_name) - 1] = '\\0';\n\n\t\t\t/* Try to extract WWN */\n\t\t\tif (!extract_wwnid(wwn_name, wwn, part_nr)) {\n\t\t\t\t/* WWN successfully extracted */\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Close directory */\n\tclosedir(dir);\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Check if a directory exists.\n *\n * IN:\n * @dirname\tName of the directory.\n *\n * RETURNS:\n * TRUE if @dirname is actually an existing directory.\n ***************************************************************************\n */\nint check_dir(char *dirname)\n{\n\tstruct stat sb;\n\n\tif (!stat(dirname, &sb) && S_ISDIR(sb.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n * **************************************************************************\n * Check if the multiplication of the 4 values may be greater than UINT_MAX.\n *\n * IN:\n * @val1\tFirst value.\n * @val2\tSecond value.\n * @val3\tThird value.\n * @val4\tFourth value.\n ***************************************************************************\n */\nvoid check_overflow(unsigned int val1, unsigned int val2,\n\t\t    unsigned int val3, unsigned int val4)\n{\n\tif ((val1 != 0) && (val2 != 0) && (val3 != 0) &&\n\t    (((unsigned long long) UINT_MAX / (unsigned long long) val1 <\n\t      (unsigned long long) val2) ||\n\t     ((unsigned long long) UINT_MAX / ((unsigned long long) val1 * (unsigned long long) val2) <\n\t      (unsigned long long) val3) ||\n\t     ((val4 != 0) &&\n\t      (unsigned long long) UINT_MAX / ((unsigned long long) val1 * (unsigned long long) val2\n\t\t\t\t\t\t\t\t\t * (unsigned long long) val3) <\n\t      (unsigned long long) val4))) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: Overflow detected (%u,%u,%u,%u). Aborting...\\n\",\n\t\t\t__FUNCTION__, val1, val2, val3, val4);\n#endif\n\t\texit(4);\n\t}\n}\n\n#ifndef SOURCE_SADC\n/*\n ***************************************************************************\n * Read /proc/devices file and get device-mapper major number.\n * If device-mapper entry is not found in file, assume it's not active.\n *\n * RETURNS:\n * Device-mapper major number.\n ***************************************************************************\n */\nunsigned int get_devmap_major(void)\n{\n\tFILE *fp;\n\tchar line[128];\n\t/*\n\t * Linux uses 12 bits for the major number,\n\t * so this shouldn't match any real device.\n\t */\n\tunsigned int dm_major = ~0U;\n\n\tif ((fp = fopen(DEVICES, \"r\")) == NULL)\n\t\treturn dm_major;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (strstr(line, \"device-mapper\")) {\n\t\t\t/* Read device-mapper major number */\n\t\t\tsscanf(line, \"%u\", &dm_major);\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn dm_major;\n}\n\n/*\n ***************************************************************************\n * Returns whether S_TIME_FORMAT is set to ISO.\n *\n * RETURNS:\n * TRUE if S_TIME_FORMAT is set to ISO, or FALSE otherwise.\n ***************************************************************************\n */\nint is_iso_time_fmt(void)\n{\n\tstatic int is_iso = -1;\n\n\tif (is_iso < 0) {\n\t\tchar *e;\n\n\t\tis_iso = (((e = __getenv(ENV_TIME_FMT)) != NULL) && !strcmp(e, K_ISO));\n\t}\n\treturn is_iso;\n}\n\n/*\n ***************************************************************************\n * Print tabulations\n *\n * IN:\n * @nr_tab\tNumber of tabs to print.\n ***************************************************************************\n */\nvoid prtab(int nr_tab)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_tab; i++) {\n\t\tprintf(\"\\t\");\n\t}\n}\n\n/*\n ***************************************************************************\n * printf() function modified for XML-like output. Don't print a CR at the\n * end of the line.\n *\n * IN:\n * @nr_tab\tNumber of tabs to print.\n * @fmtf\tprintf() format.\n ***************************************************************************\n */\nvoid xprintf0(int nr_tab, const char *fmtf, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\n\tva_start(args, fmtf);\n\tvsnprintf(buf, sizeof(buf), fmtf, args);\n\tva_end(args);\n\n\tprtab(nr_tab);\n\tprintf(\"%s\", buf);\n}\n\n/*\n ***************************************************************************\n * printf() function modified for XML-like output. Print a CR at the end of\n * the line.\n *\n * IN:\n * @nr_tab\tNumber of tabs to print.\n * @fmtf\tprintf() format.\n ***************************************************************************\n */\nvoid xprintf(int nr_tab, const char *fmtf, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\n\tva_start(args, fmtf);\n\tvsnprintf(buf, sizeof(buf), fmtf, args);\n\tva_end(args);\n\n\tprtab(nr_tab);\n\tprintf(\"%s\\n\", buf);\n}\n\n/*\n ***************************************************************************\n * Get report date as a string of characters.\n *\n * IN:\n * @tm_time\tDate to display (don't use time fields).\n * @cur_date\tString where date will be saved.\n * @sz\t\tMax size of cur_date string.\n *\n * OUT:\n * @cur_date\tDate (string format).\n *\n * RETURNS:\n * TRUE if S_TIME_FORMAT is set to ISO, or FALSE otherwise.\n ***************************************************************************\n */\nint set_report_date(struct tm *tm_time, char cur_date[], int sz)\n{\n\tif (tm_time == NULL) {\n\t\tstrncpy(cur_date, \"?/?/?\", sz);\n\t\tcur_date[sz - 1] = '\\0';\n\t}\n\telse if (is_iso_time_fmt()) {\n\t\tstrftime(cur_date, sz, \"%Y-%m-%d\", tm_time);\n\t\treturn 1;\n\t}\n\telse {\n\t\tstrftime(cur_date, sz, \"%x\", tm_time);\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Print banner.\n *\n * IN:\n * @tm_time\tDate to display (don't use time fields).\n * @sysname\tSystem name to display.\n * @release\tSystem release number to display.\n * @nodename\tHostname to display.\n * @machine\tMachine architecture to display.\n * @cpu_nr\tNumber of CPU.\n * @format\tSet to FALSE for (default) plain output, and to TRUE for\n * \t\tJSON format output.\n *\n * RETURNS:\n * TRUE if S_TIME_FORMAT is set to ISO, or FALSE otherwise.\n ***************************************************************************\n */\nint print_gal_header(struct tm *tm_time, char *sysname, char *release,\n\t\t     char *nodename, char *machine, int cpu_nr, int format)\n{\n\tchar cur_date[TIMESTAMP_LEN];\n\tint rc = 0;\n\n\trc = set_report_date(tm_time, cur_date, sizeof(cur_date));\n\n\tif (format == PLAIN_OUTPUT) {\n\t\t/* Plain output */\n\t\tprintf(\"%s %s (%s) \\t%s \\t_%s_\\t(%d CPU)\\n\", sysname, release, nodename,\n\t\t       cur_date, machine, cpu_nr);\n\t}\n\telse {\n\t\t/* JSON output */\n\t\txprintf(0, \"{\\\"sysstat\\\": {\");\n\t\txprintf(1, \"\\\"hosts\\\": [\");\n\t\txprintf(2, \"{\");\n\t\txprintf(3, \"\\\"nodename\\\": \\\"%s\\\",\", nodename);\n\t\txprintf(3, \"\\\"sysname\\\": \\\"%s\\\",\", sysname);\n\t\txprintf(3, \"\\\"release\\\": \\\"%s\\\",\", release);\n\t\txprintf(3, \"\\\"machine\\\": \\\"%s\\\",\", machine);\n\t\txprintf(3, \"\\\"number-of-cpus\\\": %d,\", cpu_nr);\n\t\txprintf(3, \"\\\"date\\\": \\\"%s\\\",\", cur_date);\n\t\txprintf(3, \"\\\"statistics\\\": [\");\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Get number of rows for current window.\n * If stdout is not a terminal then use the value given by environment\n * variable S_REPEAT_HEADER if existent.\n *\n * RETURNS:\n * Number of rows.\n ***************************************************************************\n */\nint get_win_height(void)\n{\n\tstruct winsize win;\n\tchar *e;\n\t/*\n\t * This default value will be used whenever STDOUT\n\t * is redirected to a pipe or a file and S_REPEAT_HEADER variable is not set\n\t */\n\tint rows = 3600 * 24;\n\n\t/* Get number of lines of current terminal */\n\tif (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != -1) {\n\t\tif (win.ws_row > 2) {\n\t\t\trows = win.ws_row - 2;\n\t\t}\n\t}\n\t/* STDOUT is not a terminal. Look for S_REPEAT_HEADER variable's value instead */\n\telse if ((e = __getenv(ENV_REPEAT_HEADER)) != NULL) {\n\t\tif (strspn(e, DIGITS) == strlen(e)) {\n\t\t\tint v = atol(e);\n\t\t\tif (v > 0) {\n\t\t\t\trows = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn rows;\n}\n\n/*\n ***************************************************************************\n * Canonicalize and remove /dev from path name. If the device has a slash\n * character in its name, replace it with a bang character ('!'), e.g.:\n * cciss/c0d0 -> cciss!c0d0\n * cciss/c0d0p1 -> cciss!c0d0p1\n *\n * IN:\n * @name\tDevice name (may begin with \"/dev/\" or can be a symlink).\n *\n * RETURNS:\n * Device basename.\n ***************************************************************************\n */\nchar *device_name(char *name)\n{\n\tstatic char out[MAX_FILE_LEN];\n\tchar *resolved_name = NULL, *slash;\n\tint i = 0;\n\n\t/* realpath() creates new string, so we need to free it later */\n\tresolved_name = __realpath(name, NULL);\n\n\t/* If path doesn't exist, just return input */\n\tif (!resolved_name) {\n\t\treturn name;\n\t}\n\n#ifdef DEBUG\n\tfprintf(stderr, \"Real pathname: %s (%s)\\n\", resolved_name, name);\n#endif\n\n\tif (!strncmp(resolved_name, \"/dev/\", 5)) {\n\t\ti = 5;\n\t}\n\tstrncpy(out, resolved_name + i, sizeof(out));\n\tout[sizeof(out) - 1] = '\\0';\n\n\t/* Some devices may have a slash in their name (eg. cciss/c0d0...) */\n\twhile ((slash = strchr(out, '/'))) {\n\t\t*slash = '!';\n\t}\n\n\tfree(resolved_name);\n\n\treturn out;\n}\n\n/*\n ***************************************************************************\n * Escape a '\\' character in a JSON string (replace '\\' with \"\\\\\").\n *\n * IN:\n * @str\t\tString which may contain '\\' characters.\n *\n * RETURNS:\n * String where '\\' characters have been escaped.\n ***************************************************************************\n */\nchar *escape_bs_char(char *str)\n{\n\tstatic char buffer[MAX_NAME_LEN];\n\tint i = 0, j = 0;\n\n\twhile (str[i] != '\\0' && j < MAX_NAME_LEN - 1) {\n\t\tif (str[i] == '\\\\') {\n\t\t\tif (j < MAX_NAME_LEN - 2) {\n\t\t\t\tbuffer[j++] = '\\\\';\n\t\t\t\tbuffer[j++] = '\\\\';\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbuffer[j++] = str[i];\n\t\t}\n\t\ti++;\n\t}\n\n\tbuffer[j] = '\\0';\n\n\treturn buffer;\n}\n\n/*\n ***************************************************************************\n * Workaround for CPU counters read from /proc/stat: Dyn-tick kernels\n * have a race issue that can make those counters go backward.\n ***************************************************************************\n */\ndouble ll_sp_value(unsigned long long value1, unsigned long long value2,\n\t\t   unsigned long long itv)\n{\n\tif (value2 < value1)\n\t\treturn (double) 0;\n\telse\n\t\treturn SP_VALUE(value1, value2, itv);\n}\n\n/*\n ***************************************************************************\n * Compute time interval.\n *\n * IN:\n * @prev_uptime\tPrevious uptime value (in jiffies or 1/100th of a second).\n * @curr_uptime\tCurrent uptime value (in jiffies or 1/100th of a second).\n *\n * RETURNS:\n * Interval of time in jiffies or 1/100th of a second.\n ***************************************************************************\n */\nunsigned long long get_interval(unsigned long long prev_uptime,\n\t\t\t\tunsigned long long curr_uptime)\n{\n\tunsigned long long itv;\n\n\t/* prev_time=0 when displaying stats since system startup */\n\titv = curr_uptime - prev_uptime;\n\n\tif (!itv) {\t/* Paranoia checking */\n\t\titv = 1;\n\t}\n\n\treturn itv;\n}\n\n/*\n ***************************************************************************\n * Count number of bits set in an array.\n *\n * IN:\n * @ptr\t\tPointer to array.\n * @size\tSize of array in bytes.\n *\n * RETURNS:\n * Number of bits set in the array.\n ***************************************************************************\n*/\nint count_bits(void *ptr, int size)\n{\n\tint nr = 0, i, k;\n\tchar *p;\n\n\tp = ptr;\n\tfor (i = 0; i < size; i++, p++) {\n\t\tk = 0x80;\n\t\twhile (k) {\n\t\t\tif (*p & k)\n\t\t\t\tnr++;\n\t\t\tk >>= 1;\n\t\t}\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Convert in-place input string to lowercase.\n *\n * IN:\n * @str\t\tString to be converted.\n *\n * OUT:\n * @str\t\tString in lowercase.\n *\n * RETURNS:\n * String in lowercase.\n ***************************************************************************\n*/\nchar *strtolower(char *str)\n{\n\tchar *cp = str;\n\n\twhile (*cp) {\n\t\t*cp = tolower(*cp);\n\t\tcp++;\n\t}\n\n\treturn(str);\n}\n\n/*\n ***************************************************************************\n * Get persistent type name directory from type.\n *\n * IN:\n * @type\tPersistent type name (UUID, LABEL, etc.)\n *\n * RETURNS:\n * Path to the persistent type name directory, or NULL if access is denied\n * or strings have been truncated.\n ***************************************************************************\n*/\nchar *get_persistent_type_dir(char *type)\n{\n\tstatic char dir[PATH_MAX];\n\tint n;\n\n\tn = snprintf(dir, sizeof(dir), \"%s-%s\", DEV_DISK_BY, type);\n\n\tif ((n >= sizeof(dir)) || access(dir, R_OK)) {\n\t\treturn (NULL);\n\t}\n\n\treturn (dir);\n}\n\n/*\n ***************************************************************************\n * Get persistent name absolute path.\n *\n * IN:\n * @name\tPersistent name.\n *\n * RETURNS:\n * Path to the persistent name, or NULL if file doesn't exist or strings\n * have been truncated.\n ***************************************************************************\n*/\nchar *get_persistent_name_path(char *name)\n{\n\tstatic char path[PATH_MAX];\n\tint n;\n\n\tn = snprintf(path, sizeof(path), \"%s/%s\",\n\t\t     get_persistent_type_dir(persistent_name_type), name);\n\n\tif ((n >= sizeof(path)) || access(path, F_OK)) {\n\t\treturn (NULL);\n\t}\n\n\treturn (path);\n}\n\n/*\n ***************************************************************************\n * Get files from persistent type name directory.\n *\n * RETURNS:\n * List of files in the persistent type name directory in alphabetical order.\n ***************************************************************************\n*/\nchar **get_persistent_names(void)\n{\n\tint n, i, k = 0;\n\tchar *dir;\n\tchar **files = NULL;\n\tstruct dirent **namelist;\n\n\t/* Get directory name for selected persistent type */\n\tdir = get_persistent_type_dir(persistent_name_type);\n\tif (!dir)\n\t\treturn (NULL);\n\n\tn = scandir(dir, &namelist, NULL, alphasort);\n\tif (n < 0)\n\t\treturn (NULL);\n\n\t/* If directory is empty, it contains 2 entries: \".\" and \"..\" */\n\tif (n <= 2)\n\t\t/* Free list and return NULL */\n\t\tgoto free_list;\n\n\t/* Ignore the \".\" and \"..\", but keep place for one last NULL. */\n\tfiles = (char **) calloc(n - 1, sizeof(char *));\n\tif (!files)\n\t\tgoto free_list;\n\n\t/*\n\t * i is for traversing namelist, k is for files.\n\t * i != k because we are ignoring \".\" and \"..\" entries.\n\t */\n\tfor (i = 0; i < n; i++) {\n\t\t/* Ignore \".\" and \"..\" */\n\t\tif (!strcmp(\".\", namelist[i]->d_name) ||\n\t\t    !strcmp(\"..\", namelist[i]->d_name))\n\t\t\tcontinue;\n\n\t\tfiles[k] = (char *) calloc(strlen(namelist[i]->d_name) + 1, sizeof(char));\n\t\tif (!files[k])\n\t\t\tcontinue;\n\n\t\tstrcpy(files[k++], namelist[i]->d_name);\n\t}\n\tfiles[k] = NULL;\n\nfree_list:\n\n\tfor (i = 0; i < n; i++) {\n\t\tfree(namelist[i]);\n\t}\n\tfree(namelist);\n\n\treturn (files);\n}\n\n/*\n ***************************************************************************\n * Get persistent name from pretty name.\n *\n * IN:\n * @pretty\tPretty name (e.g. sda, sda1, ..).\n *\n * RETURNS:\n * Persistent name.\n ***************************************************************************\n*/\nchar *get_persistent_name_from_pretty(char *pretty)\n{\n\tint i = -1;\n\tssize_t r;\n\tchar *link, *name;\n\tchar **persist_names;\n\tchar target[PATH_MAX];\n\tstatic char persist_name[FILENAME_MAX];\n\n\tpersist_name[0] = '\\0';\n\n\t/* Get list of files from persistent type name directory */\n\tpersist_names = get_persistent_names();\n\tif (!persist_names)\n\t\treturn (NULL);\n\n\twhile (persist_names[++i]) {\n\n\t\t/* Get absolute path for current persistent name */\n\t\tlink = get_persistent_name_path(persist_names[i]);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\t/* Persistent name is usually a symlink: Read it... */\n\t\tr = readlink(link, target, PATH_MAX);\n\t\tif ((r <= 0) || (r >= PATH_MAX))\n\t\t\tcontinue;\n\n\t\ttarget[r] = '\\0';\n\n\t\t/* ... and get device pretty name it points at */\n\t\tname = basename(target);\n\t\tif (!name || (name[0] == '\\0'))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(name, pretty, FILENAME_MAX)) {\n\t\t\t/* We have found pretty name for current persistent one */\n\t\t\tstrncpy(persist_name, persist_names[i], sizeof(persist_name));\n\t\t\tpersist_name[sizeof(persist_name) - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti = -1;\n\twhile (persist_names[++i]) {\n\t\tfree (persist_names[i]);\n\t}\n\tfree (persist_names);\n\n\tif (!strlen(persist_name))\n\t\treturn (NULL);\n\n\treturn persist_name;\n}\n\n/*\n ***************************************************************************\n * Get pretty name (sda, sda1...) from persistent name.\n *\n * IN:\n * @persistent\tPersistent name.\n *\n * RETURNS:\n * Pretty name.\n ***************************************************************************\n*/\nchar *get_pretty_name_from_persistent(char *persistent)\n{\n\tssize_t r;\n\tchar *link, *pretty, target[PATH_MAX];\n\n\t/* Get absolute path for persistent name */\n\tlink = get_persistent_name_path(persistent);\n\tif (!link)\n\t\treturn (NULL);\n\n\t/* Persistent name is usually a symlink: Read it... */\n\tr = readlink(link, target, PATH_MAX);\n\tif ((r <= 0) || (r >= PATH_MAX))\n\t\treturn (NULL);\n\n\ttarget[r] = '\\0';\n\n\t/* ... and get device pretty name it points at */\n\tpretty = basename(target);\n\tif (!pretty || (pretty[0] == '\\0'))\n\t\treturn (NULL);\n\n\treturn pretty;\n}\n\n/*\n * **************************************************************************\n * Try to get device real name from sysfs tree.\n *\n * IN:\n * @major\tMajor number of the device.\n * @minor\tMinor number of the device.\n *\n * RETURNS:\n * The name of the device, which may be the real name (as it appears in /dev)\n * or NULL.\n ***************************************************************************\n */\nchar *get_devname_from_sysfs(unsigned int major, unsigned int minor)\n{\n\tstatic char link[256], target[PATH_MAX];\n\tchar *devname;\n\tssize_t r;\n\n\tsnprintf(link, sizeof(link), \"%s/%u:%u\", SYSFS_DEV_BLOCK, major, minor);\n\n\t/* Get full path to device knowing its major and minor numbers */\n\tr = readlink(link, target, PATH_MAX);\n\tif (r <= 0 || r >= PATH_MAX)\n\t\treturn (NULL);\n\n\ttarget[r] = '\\0';\n\n\t/* Get device name */\n\tdevname = basename(target);\n\tif (!devname || strnlen(devname, FILENAME_MAX) == 0) {\n\t\treturn (NULL);\n\t}\n\n\treturn (devname);\n}\n\n/*\n * **************************************************************************\n * Get device real name if possible.\n *\n * IN:\n * @major\tMajor number of the device.\n * @minor\tMinor number of the device.\n *\n * RETURNS:\n * The name of the device, which may be the real name (as it appears in /dev)\n * or a string with the following format devM-n.\n ***************************************************************************\n */\nchar *get_devname(unsigned int major, unsigned int minor)\n{\n\tstatic char buf[32];\n\tchar *name;\n\n\tname = get_devname_from_sysfs(major, minor);\n\tif (name != NULL)\n\t\treturn (name);\n\n\tname = ioc_name(major, minor);\n\tif ((name != NULL) && strcmp(name, K_NODEV))\n\t\treturn (name);\n\n\tsnprintf(buf, sizeof(buf), \"dev%u-%u\", major, minor);\n\treturn (buf);\n}\n\n/*\n * **************************************************************************\n * Get device name (whether pretty-printed, persistent or not).\n *\n * IN:\n * @major\t\tMajor number of the device.\n * @minor\t\tMinor number of the device.\n * @wwn\t\t\tWWN identifier of the device (0 if unknown).\n * @part_nr\t\tPartition number (0 if unknown).\n * @disp_devmap_name\tDisplay device mapper name.\n * @disp_persist_name\tDisplay persistent name of the device.\n * @use_stable_id\tDisplay stable-across-reboots name.\n * @dflt_name\t\tDevice name to use by default (if existent).\n *\n * RETURNS:\n * The name of the device.\n ***************************************************************************\n */\nchar *get_device_name(unsigned int major, unsigned int minor, unsigned long long wwn[],\n\t\t      unsigned int part_nr, unsigned int disp_devmap_name,\n\t\t      unsigned int disp_persist_name, unsigned int use_stable_id,\n\t\t      char *dflt_name)\n{\n\tstatic unsigned int dm_major = 0;\n\tchar *dev_name = NULL, *persist_dev_name = NULL, *bang;\n\tstatic char sid[64], dname[MAX_NAME_LEN];\n\n\tif (disp_persist_name) {\n\t\tpersist_dev_name = get_persistent_name_from_pretty(get_devname(major, minor));\n\t}\n\n\tif (persist_dev_name) {\n\t\tdev_name = persist_dev_name;\n\t}\n\telse {\n\t\tif (use_stable_id && (wwn[0] != 0)) {\n\t\t\tchar xsid[32] = \"\", pn[16] = \"\";\n\n\t\t\tif (wwn[1] != 0) {\n\t\t\t\tsprintf(xsid, \"%016llx\", wwn[1]);\n\t\t\t}\n\t\t\tif (part_nr) {\n\t\t\t\tsprintf(pn, \"-%u\", part_nr);\n\t\t\t}\n\t\t\tsnprintf(sid, sizeof(sid), \"%#016llx%s%s\", wwn[0], xsid, pn);\n\t\t\tdev_name = sid;\n\t\t}\n\t\telse if (disp_devmap_name) {\n\t\t\tif (!dm_major) {\n\t\t\t\tdm_major = get_devmap_major();\n\t\t\t}\n\t\t\tif (major == dm_major) {\n\t\t\t\tdev_name = transform_devmapname(major, minor);\n\t\t\t}\n\t\t}\n\n\t\tif (!dev_name) {\n\t\t\tif (dflt_name) {\n\t\t\t\tdev_name = dflt_name;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdev_name = get_devname(major, minor);\n\t\t\t}\n\t\t}\n\t}\n\n\tstrncpy(dname, dev_name, sizeof(dname));\n\tdname[sizeof(dname) - 1] = '\\0';\n\n\twhile ((bang = strchr(dname, '!'))) {\n\t\t/*\n\t\t * Some devices may have had a slash replaced with\n\t\t * a bang character (eg. cciss!c0d0...)\n\t\t * Restore their original names.\n\t\t */\n\t\t*bang = '/';\n\t}\n\n\treturn dname;\n}\n\n/*\n ***************************************************************************\n * Init color strings.\n ***************************************************************************\n */\nvoid init_colors(void)\n{\n\tchar *e, *p;\n\tint len;\n\n\t/* Read S_COLORS environment variable */\n\tif ((e = __getenv(ENV_COLORS)) == NULL\n\t     ? !isatty(STDOUT_FILENO)\n\t     : (!strcmp(e, C_NEVER) ||\n\t\t(strcmp(e, C_ALWAYS) && !isatty(STDOUT_FILENO)))) {\n\t\t/*\n\t\t * Environment variable not set and stdout is not a terminal,\n\t\t * or set to \"never\",\n\t\t * or set to \"auto\" and stdout is not a terminal:\n\t\t * Unset color strings.\n\t\t */\n\t\tstrcpy(sc_percent_warn, \"\");\n\t\tstrcpy(sc_percent_xtreme, \"\");\n\t\tstrcpy(sc_zero_int_stat, \"\");\n\t\tstrcpy(sc_int_stat, \"\");\n\t\tstrcpy(sc_item_name, \"\");\n\t\tstrcpy(sc_sa_comment, \"\");\n\t\tstrcpy(sc_sa_restart, \"\");\n\t\tstrcpy(sc_trend_pos, \"\");\n\t\tstrcpy(sc_trend_neg, \"\");\n\t\tstrcpy(sc_normal, \"\");\n\n\t\treturn;\n\t}\n\n\t/* Read S_COLORS_SGR environment variable */\n\tif ((e = __getenv(ENV_COLORS_SGR)) == NULL)\n\t\t/* Environment variable not set */\n\t\treturn;\n\n\tfor (p = strtok(e, \":\"); p; p =strtok(NULL, \":\")) {\n\n\t\tlen = strlen(p);\n\t\tif ((len > 7) || (len < 3) || (*(p + 1) != '=') ||\n\t\t    (strspn(p + 2, \";0123456789\") != (len - 2)))\n\t\t\t/* Ignore malformed codes */\n\t\t\tcontinue;\n\n\t\tswitch (*p) {\n\t\t\tcase 'M':\n\t\t\tcase 'W':\n\t\t\t\tsnprintf(sc_percent_warn, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\tcase 'H':\n\t\t\t\tsnprintf(sc_percent_xtreme, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'Z':\n\t\t\t\tsnprintf(sc_zero_int_stat, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tsnprintf(sc_int_stat, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tsnprintf(sc_item_name, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tsnprintf(sc_sa_comment, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tsnprintf(sc_sa_restart, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tsnprintf(sc_trend_pos, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tsnprintf(sc_trend_neg, MAX_SGR_LEN, \"\\e[%sm\", p + 2);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Print a value in human readable format. Such a value is a decimal number\n * followed by a unit (B, k, M, etc.)\n *\n * IN:\n * @unit\tDefault value unit.\n * @dval\tValue to print.\n * @wi\t\tOutput width.\n ***************************************************************************\n*/\nvoid cprintf_unit(int unit, int wi, double dval)\n{\n\tif (wi < 4) {\n\t\t/* E.g. 1.3M */\n\t\twi = 4;\n\t}\n\tif (!unit) {\n\t\t/* Value is a number of sectors. Convert it to kB */\n\t\tdval /= 2;\n\t\tunit = 2;\n\t}\n\twhile (dval >= 1024) {\n\t\tdval /= 1024;\n\t\tunit++;\n\t}\n\tprintf(\" %*.*f\", wi - 1, dplaces_nr ? 1 : 0, dval);\n\tprintf(\"%s\", sc_normal);\n\n\t/* Display unit */\n\tif (unit >= NR_UNITS) {\n\t\tunit = NR_UNITS - 1;\n\t}\n\tprintf(\"%c\", units[unit]);\n}\n\n/*\n ***************************************************************************\n * Print 64 bit unsigned values using colors, possibly followed by a unit.\n *\n * IN:\n * @unit\tDefault values unit. -1 if no unit should be displayed.\n * @num\t\tNumber of values to print.\n * @wi\t\tOutput width.\n ***************************************************************************\n */\nvoid cprintf_u64(int unit, int num, int wi, ...)\n{\n\tint i;\n\tuint64_t val;\n\tva_list args;\n\n\tva_start(args, wi);\n\n\tfor (i = 0; i < num; i++) {\n\t\tval = va_arg(args, unsigned long long);\n\t\tif (!val) {\n\t\t\tprintf(\"%s\", sc_zero_int_stat);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s\", sc_int_stat);\n\t\t}\n\t\tif (unit < 0) {\n\t\t\tprintf(\" %*\"PRIu64, wi, val);\n\t\t\tprintf(\"%s\", sc_normal);\n\t\t}\n\t\telse {\n\t\t\tcprintf_unit(unit, wi, (double) val);\n\t\t}\n\t}\n\n\tva_end(args);\n}\n\n/*\n ***************************************************************************\n * Print hex values using colors.\n *\n * IN:\n * @num\t\tNumber of values to print.\n * @wi\t\tOutput width.\n ***************************************************************************\n*/\nvoid cprintf_x(int num, int wi, ...)\n{\n\tint i;\n\tunsigned int val;\n\tva_list args;\n\n\tva_start(args, wi);\n\n\tfor (i = 0; i < num; i++) {\n\t\tval = va_arg(args, unsigned int);\n\t\tprintf(\"%s\", sc_int_stat);\n\t\tprintf(\" %*x\", wi, val);\n\t\tprintf(\"%s\", sc_normal);\n\t}\n\n\tva_end(args);\n}\n\n/*\n ***************************************************************************\n * Print \"double\" statistics values using colors, possibly followed by a\n * unit.\n *\n * IN:\n * @unit\tDefault values unit. -1 if no unit should be displayed.\n * @sign\tTRUE if sign (+/-) should be explicitly displayed.\n * @num\t\tNumber of values to print.\n * @wi\t\tOutput width.\n * @wd\t\tNumber of decimal places.\n ***************************************************************************\n*/\nvoid cprintf_f(int unit, int sign, int num, int wi, int wd, ...)\n{\n\tint i;\n\tdouble val, lim = 0.005;;\n\tva_list args;\n\n\t/*\n\t * If there are decimal places then get the value\n\t * entered on the command line (if existing).\n\t */\n\tif ((wd > 0) && (dplaces_nr >= 0)) {\n\t\twd = dplaces_nr;\n\t}\n\n\t/* Update limit value according to number of decimal places */\n\tif (wd == 1) {\n\t\tlim = 0.05;\n\t}\n\n\tva_start(args, wd);\n\n\tfor (i = 0; i < num; i++) {\n\t\tval = va_arg(args, double);\n\t\tif (((wd > 0) && (val < lim) && (val > (lim * -1))) ||\n\t\t    ((wd == 0) && (val <= 0.5) && (val >= -0.5))) {\t/* \"Round half to even\" law */\n\t\t\tprintf(\"%s\", sc_zero_int_stat);\n\t\t}\n\t\telse if (sign && (val <= -10.0)) {\n\t\t\tprintf(\"%s\", sc_percent_xtreme);\n\t\t}\n\t\telse if (sign && (val <= -5.0)) {\n\t\t\tprintf(\"%s\", sc_percent_warn);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s\", sc_int_stat);\n\t\t}\n\n\t\tif (unit < 0) {\n\t\t\tif (sign) {\n\t\t\t\tprintf(\" %+*.*f\", wi, wd, val);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\" %*.*f\", wi, wd, val);\n\t\t\t}\n\t\t\tprintf(\"%s\", sc_normal);\n\t\t}\n\t\telse {\n\t\t\tcprintf_unit(unit, wi, val);\n\t\t}\n\t}\n\n\tva_end(args);\n}\n\n/*\n ***************************************************************************\n * Print \"percent\" statistics values using colors.\n *\n * IN:\n * @human\tSet to > 0 if a percent sign (%) shall be displayed after\n *\t\tthe value.\n * @xtrem\tSet to non 0 to indicate that extreme (low or high) values\n *\t\tshould be displayed in specific color if beyond predefined\n *\t\tlimits.\n * @num\t\tNumber of values to print.\n * @wi\t\tOutput width.\n * @wd\t\tNumber of decimal places.\n ***************************************************************************\n*/\nvoid cprintf_xpc(int human, int xtrem, int num, int wi, int wd, ...)\n{\n\tint i;\n\tdouble val, lim = 0.005;\n\tva_list args;\n\n\t/*\n\t * If there are decimal places then get the value\n\t * entered on the command line (if existing).\n\t */\n\tif ((wd > 0) && (dplaces_nr >= 0)) {\n\t\twd = dplaces_nr;\n\t}\n\n\t/*\n\t * If a percent sign is to be displayed, then there will be\n\t * zero (or one) decimal place.\n\t */\n\tif (human > 0) {\n\t\tif (wi < 4) {\n\t\t\t/* E.g., 100% */\n\t\t\twi = 4;\n\t\t}\n\t\t/* Keep one place for the percent sign */\n\t\twi -= 1;\n\t\tif (wd > 1) {\n\t\t\twd -= 1;\n\t\t}\n\t}\n\n\t/* Update limit value according to number of decimal places */\n\tif (wd == 1) {\n\t\tlim = 0.05;\n\t}\n\n\tva_start(args, wd);\n\n\tfor (i = 0; i < num; i++) {\n\t\tval = va_arg(args, double);\n\t\tif ((xtrem == XHIGH) && (val >= PERCENT_LIMIT_XHIGH)) {\n\t\t\tprintf(\"%s\", sc_percent_xtreme);\n\t\t}\n\t\telse if ((xtrem == XHIGH) && (val >= PERCENT_LIMIT_HIGH)) {\n\t\t\tprintf(\"%s\", sc_percent_warn);\n\t\t}\n\t\telse if ((xtrem == XLOW) && (val <= PERCENT_LIMIT_XLOW)) {\n\t\t\tprintf(\"%s\", sc_percent_xtreme);\n\t\t}\n\t\telse if ((xtrem == XLOW0) && (val <= PERCENT_LIMIT_XLOW) && (val >= lim)) {\n\t\t\tprintf(\"%s\", sc_percent_xtreme);\n\t\t}\n\t\telse if ((xtrem == XLOW) && (val <= PERCENT_LIMIT_LOW)) {\n\t\t\tprintf(\"%s\", sc_percent_warn);\n\t\t}\n\t\telse if ((xtrem == XLOW0) && (val <= PERCENT_LIMIT_LOW) && (val >= lim)) {\n\t\t\tprintf(\"%s\", sc_percent_warn);\n\t\t}\n\t\telse if (((wd > 0) && (val < lim)) ||\n\t\t\t ((wd == 0) && (val <= 0.5))) {\t/* \"Round half to even\" law */\n\t\t\tprintf(\"%s\", sc_zero_int_stat);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s\", sc_int_stat);\n\t\t}\n\t\tprintf(\" %*.*f\", wi, wd, val);\n\t\tprintf(\"%s\", sc_normal);\n\t\tif (human > 0) printf(\"%%\");\n\t}\n\n\tva_end(args);\n}\n\n/*\n ***************************************************************************\n * Print item name using selected color.\n * Only one name can be displayed. Name can be an integer or a string.\n *\n * IN:\n * @type\t0 if name is an int, 1 if name is a string\n * @format\tOutput format.\n * @item_string\tItem name (given as a string of characters).\n * @item_int\tItem name (given as an integer value).\n ***************************************************************************\n*/\nvoid cprintf_in(int type, char *format, char *item_string, int item_int)\n{\n\tprintf(\"%s\", sc_item_name);\n\tif (type) {\n\t\tprintf(format, item_string);\n\t}\n\telse {\n\t\tprintf(format, item_int);\n\t}\n\tprintf(\"%s\", sc_normal);\n}\n\n/*\n ***************************************************************************\n * Print a string using selected color.\n *\n * IN:\n * @type\tType of string to display.\n * @format\tOutput format.\n * @string\tString to display.\n ***************************************************************************\n*/\nvoid cprintf_s(int type, char *format, char *string)\n{\n\tif (type == IS_STR) {\n\t\tprintf(\"%s\", sc_int_stat);\n\t}\n\telse if (type == IS_ZERO) {\n\t\tprintf(\"%s\", sc_zero_int_stat);\n\t}\n\t/* IS_RESTART and IS_DEBUG are the same value */\n\telse if (type == IS_RESTART) {\n\t\tprintf(\"%s\", sc_sa_restart);\n\t}\n\telse {\n\t\t/* IS_COMMENT */\n\t\tprintf(\"%s\", sc_sa_comment);\n\t}\n\tprintf(format, string);\n\tprintf(\"%s\", sc_normal);\n}\n\n/*\n * **************************************************************************\n * Print trend string using selected color.\n *\n * IN:\n * @trend\tTrend (TRUE: positive; FALSE: negative).\n * @format\tOutput format.\n * @tstring\tString to display.\n ***************************************************************************\n */\nvoid cprintf_tr(int trend, char *format, char *tstring)\n{\n\tif (trend) {\n\t\tprintf(\"%s\", sc_trend_pos);\n\t}\n\telse {\n\t\tprintf(\"%s\", sc_trend_neg);\n\t}\n\n\tprintf(format, tstring);\n\n\tprintf(\"%s\", sc_normal);\n}\n\n/*\n ***************************************************************************\n * Parse a string containing a numerical value (e.g. CPU or IRQ number).\n * The string should contain only one value, not a range of values.\n *\n * IN:\n * @s\t\tString to parse.\n * @max_val\tUpper limit that value should not reach.\n *\n * OUT:\n * @val\t\tValue, or -1 if the string @s was empty.\n *\n * RETURNS:\n * 0 if the value has been properly read, 1 otherwise.\n ***************************************************************************\n */\nint parse_valstr(char *s, int max_val, int *val)\n{\n\tif (!strlen(s)) {\n\t\t*val = -1;\n\t\treturn 0;\n\t}\n\tif (strspn(s, DIGITS) != strlen(s))\n\t\treturn 1;\n\n\t*val = atoi(s);\n\tif ((*val < 0) || (*val >= max_val))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Parse string containing a single value or a range of values\n * (e.g. \"0,2-5,10-\").\n *\n * IN:\n * @t\t\tString to parse.\n * @max_val\tUpper limit that value should not reach.\n *\n * OUT:\n * @val_low\tLow value in range\n * @val\t\tHigh value in range. @val_low and @val are the same if it's\n *\t\ta single value.\n *\n * RETURNS:\n * 0 on success, 1 otherwise.\n ***************************************************************************\n */\nint parse_range_values(char *t, int max_val, int *val_low, int *val)\n{\n\tchar *s, *valstr, range[16];\n\n\t/* Parse value or range of values */\n\tstrncpy(range, t, 16);\n\trange[15] = '\\0';\n\tvalstr = t;\n\n\tif ((s = strchr(range, '-')) != NULL) {\n\t\t/* Possible range of values */\n\t\t*s = '\\0';\n\t\tif (parse_valstr(range, max_val, val_low) || (*val_low < 0))\n\t\t\treturn 1;\n\t\tvalstr = s + 1;\n\t}\n\tif (parse_valstr(valstr, max_val, val))\n\t\treturn 1;\n\tif (s && *val < 0) {\n\t\t/* Range of values with no upper limit (e.g. \"3-\") */\n\t\t*val = max_val - 1;\n\t}\n\tif ((!s && (*val < 0)) || (s && (*val < *val_low)))\n\t\t/*\n\t\t * Individual value: string cannot be empty.\n\t\t * Range of values: n-m: m can be empty (e.g. \"3-\") but\n\t\t * cannot be lower than n.\n\t\t */\n\t\treturn 1;\n\tif (!s) {\n\t\t*val_low = *val;\n\t}\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Parse string containing a set of coma-separated values or ranges of\n * values (e.g. \"0,2-5,10-\"). The ALL keyword is allowed and indicate that\n * all possible values are selected.\n *\n * IN:\n * @strargv\tCurrent argument in list to parse.\n * @bitmap\tBitmap whose contents will indicate which values have been\n *\t\tselected.\n * @max_val\tUpper limit that value should not reach.\n * @__K_VALUE0\tKeyword corresponding to the first bit in bitmap (e.g \"all\",\n *\t\t\"SUM\"...)\n *\n * OUT:\n * @bitmap\tBitmap updated with selected values.\n *\n * RETURNS:\n * 0 on success, 1 otherwise.\n ***************************************************************************\n */\nint parse_values(char *strargv, unsigned char bitmap[], int max_val, const char *__K_VALUE0)\n{\n\tint i, val_low, val;\n\tchar *t;\n\n\tif (!strcmp(strargv, K_ALL)) {\n\t\t/* Set bit for every possible values (CPU, IRQ, etc.) */\n\t\tmemset(bitmap, ~0, BITMAP_SIZE(max_val));\n\t\treturn 0;\n\t}\n\n\tfor (t = strtok(strargv, \",\"); t; t = strtok(NULL, \",\")) {\n\t\tif (!strcmp(t, __K_VALUE0)) {\n\t\t\t/*\n\t\t\t * Set bit 0 in bitmap. This may correspond\n\t\t\t * to CPU \"all\" or IRQ \"SUM\" for example.\n\t\t\t */\n\t\t\tbitmap[0] |= 1;\n\t\t}\n\t\telse {\n\t\t\t/* Parse value or range of values */\n\t\t\tif (parse_range_values(t, max_val, &val_low, &val))\n\t\t\t\treturn 1;\n\n\t\t\tfor (i = val_low; i <= val; i++) {\n\t\t\t\tSET_CPU_BITMAP(bitmap, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * **************************************************************************\n * Write current sample's timestamp, either in plain or JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @rectime\tCurrent date and time.\n * @xflags\tFlag for common options and system state.\n ***************************************************************************\n */\nvoid write_sample_timestamp(int tab, struct tm *rectime, uint64_t xflags)\n{\n\tchar timestamp[TIMESTAMP_LEN];\n\n\tif (DISPLAY_ISO(xflags)) {\n\t\tstrftime(timestamp, sizeof(timestamp), \"%FT%T%z\", rectime);\n\t}\n\telse {\n\t\tstrftime(timestamp, sizeof(timestamp), \"%x %X\", rectime);\n\t}\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf(tab, \"\\\"timestamp\\\": \\\"%s\\\",\", timestamp);\n\t}\n\telse {\n\t\tprintf(\"%s\\n\", timestamp);\n\t}\n\n#ifdef DEBUG\n\tif (DISPLAY_DEBUG(xflags)) {\n\t\tfprintf(stderr, \"%s\\n\", timestamp);\n\t}\n#endif\n}\n\n#endif /* SOURCE_SADC undefined */\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 9.5078125,
          "content": "/*\n * sysstat: System performance tools for Linux\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _COMMON_H\n#define _COMMON_H\n\n/* Maximum length of sensors device name */\n#define MAX_SENSORS_DEV_LEN\t20\n\n#include <time.h>\n#include <sched.h>\t/* For __CPU_SETSIZE */\n#include <limits.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"systest.h\"\n\n#ifdef HAVE_SYS_SYSMACROS_H\n/* Needed on some non-glibc environments */\n#include <sys/sysmacros.h>\n#endif\n\n/*\n ***************************************************************************\n * Various keywords and constants\n ***************************************************************************\n */\n\n#define FALSE\t0\n#define TRUE\t1\n\n#define PLAIN_OUTPUT\t0\n\n#define DISP_HDR\t1\n\n/* Index in units array (see common.c) */\n#define NO_UNIT\t\t-1\n\nenum {\n\tUNIT_SECTOR\t= 0,\n\tUNIT_BYTE\t= 1,\n\tUNIT_KILOBYTE\t= 2\n};\n\n#define NR_UNITS\t8\n\n/* Timestamp buffer length */\n#define TIMESTAMP_LEN\t64\n\n/* Number of seconds per day */\n#define SEC_PER_DAY\t3600 * 24\n\n/* Maximum number of CPUs */\n#if defined(__CPU_SETSIZE) && __CPU_SETSIZE > 8192\n#define NR_CPUS\t\t__CPU_SETSIZE\n#else\n#define NR_CPUS\t\t8192\n#endif\n\n/* Maximum number of interrupts */\n#define NR_IRQS\t\t4096\n\n/* Size of /proc/interrupts line, CPU data excluded */\n#define INTERRUPTS_LINE\t128\n\n/* Keywords */\n#define K_ISO\t\t\"ISO\"\n#define K_ALL\t\t\"ALL\"\n#define K_LOWERALL\t\"all\"\n#define K_LOWERSUM\t\"sum\"\n#define K_UTC\t\t\"UTC\"\n#define K_JSON\t\t\"JSON\"\n\n/* Flags used with multiple commands (iostat, cifsiostat...) */\n#define X_D_DEBUG\t\t0x01\n#define X_D_ISO\t\t\t0x02\n#define X_D_JSON_OUTPUT\t\t0x04\n\n#define DISPLAY_DEBUG(m)\t(((m) & X_D_DEBUG)       == X_D_DEBUG)\n#define DISPLAY_ISO(m)\t\t(((m) & X_D_ISO)         == X_D_ISO)\n#define DISPLAY_JSON_OUTPUT(m)\t(((m) & X_D_JSON_OUTPUT) == X_D_JSON_OUTPUT)\n\n/* Files */\n#define __DISKSTATS\t\t\"diskstats\"\n#define __BLOCK\t\t\t\"block\"\n#define __DEV_BLOCK\t\t\"dev/block\"\n#define SLASH_SYS\t\tPRE \"/sys\"\n#define SLASH_DEV\t\tPRE \"/dev/\"\n#define STAT\t\t\tPRE \"/proc/stat\"\n#define UPTIME\t\t\tPRE \"/proc/uptime\"\n#define DISKSTATS\t\tPRE \"/proc/\" __DISKSTATS\n#define INTERRUPTS\t\tPRE \"/proc/interrupts\"\n#define MEMINFO\t\t\tPRE \"/proc/meminfo\"\n#define SYSFS_BLOCK\t\tSLASH_SYS \"/\" __BLOCK\n#define SYSFS_DEV_BLOCK\t\tSLASH_SYS \"/\" __DEV_BLOCK\n#define SYSFS_DEVCPU\t\tPRE \"/sys/devices/system/cpu\"\n#define S_STAT\t\t\t\"stat\"\n#define DEVMAP_DIR\t\tPRE \"/dev/mapper\"\n#define DEVICES\t\t\tPRE \"/proc/devices\"\n#define DEV_DISK_BY\t\tPRE \"/dev/disk/by\"\n#define DEV_DISK_BY_ID\t\tPRE \"/dev/disk/by-id\"\n\n#define MAX_FILE_LEN\t\t512\n#define MAX_PF_NAME\t\t1024\n#define MAX_NAME_LEN\t\t128\n\n#define IGNORE_VIRTUAL_DEVICES\tFALSE\n#define ACCEPT_VIRTUAL_DEVICES\tTRUE\n#define LOCAL_TIME\t\tFALSE\n\n/* Environment variables */\n#define ENV_TIME_FMT\t\t\"S_TIME_FORMAT\"\n#define ENV_TIME_DEFTM\t\t\"S_TIME_DEF_TIME\"\n#define ENV_COLORS\t\t\"S_COLORS\"\n#define ENV_COLORS_SGR\t\t\"S_COLORS_SGR\"\n#define ENV_REPEAT_HEADER\t\"S_REPEAT_HEADER\"\n\n#define C_NEVER\t\t\t\"never\"\n#define C_ALWAYS\t\t\"always\"\n\n#define DIGITS\t\t\t\"0123456789\"\n#define XDIGITS\t\t\t\"0123456789-\"\n\n/* Batteries status */\nenum {\n\tBAT_STS_UNKNOWN\t\t= 0,\n\tBAT_STS_CHARGING\t= 1,\n\tBAT_STS_DISCHARGING\t= 2,\n\tBAT_STS_NOTCHARGING\t= 3,\n\tBAT_STS_FULL\t\t= 4\n};\n\n/* Number of different statuses */\n#define BAT_STS_NR\t5\n\n/*\n ***************************************************************************\n * Macro functions definitions.\n ***************************************************************************\n */\n\n/*\n * Macro used to define activity bitmap size.\n * All those bitmaps have an additional bit used for global activity\n * (eg. CPU \"all\" or total number of interrupts). That's why we do \"(m) + 1\".\n */\n#define BITMAP_SIZE(m)\t((((m) + 1) >> 3) + 1)\n\n/* Allocate and init structure */\n#ifdef DEBUG\n#define SREALLOC(S, TYPE, SIZE)\tdo {\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\tif ((SIZE) == 0) {\t\t\t\t\t   \\\n\t\t\t\t\t\t /* SIZE may be zero when an overflow happens */   \\\n\t\t\t\t\t\t /* when two non-zero values are multiplied   */   \\\n\t\t\t\t\t\t /* together.\t\t\t\t      */   \\\n\t\t\t\t\t\t fprintf(stderr, \"%s: SREALLOC: SIZE is zero!\\n\", __FUNCTION__); \\\n\t\t\t\t\t\t exit(4); \t\t\t\t\t   \\\n\t\t\t\t\t}\t\t\t\t\t\t\t   \\\n\t\t\t\t\t__SREALLOC(S, TYPE, SIZE);\t\t\t\t   \\\n\t\t\t\t} while (0)\n#else\n#define SREALLOC(S, TYPE, SIZE)\tdo {\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\tif ((SIZE) == 0) {\t\t\t\t\t   \\\n\t\t\t\t\t\texit(4); \t\t\t\t\t   \\\n\t\t\t\t\t}\t\t\t\t\t\t\t   \\\n\t\t\t\t\t__SREALLOC(S, TYPE, SIZE);\t\t\t\t   \\\n\t\t\t\t} while (0)\n#endif\n\n#define __SREALLOC(S, TYPE, SIZE)\tdo {\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\tTYPE *_p_;\t\t\t\t\t   \\\n\t\t\t\t\t\tif ((_p_ = (TYPE *) realloc(S, (SIZE))) == NULL) { \\\n\t\t\t\t\t\t\tperror(\"realloc\");\t\t\t   \\\n\t\t\t\t\t\t\tif (S) {\t\t\t\t   \\\n\t\t\t\t\t\t\t\tfree(S);\t\t\t   \\\n\t\t\t\t\t\t\t}\t\t\t\t\t   \\\n\t\t\t\t\t\t\texit(4);\t\t\t\t   \\\n\t\t\t\t\t\t}\t\t\t\t\t\t   \\\n\t\t\t\t\t\t/* If the ptr was null, then it's a malloc() */\t   \\\n\t\t\t\t\t\tif (!S) {\t\t\t\t\t   \\\n\t\t\t\t\t\t\tmemset(_p_, 0, (SIZE));\t\t\t   \\\n\t\t\t\t\t\t}\t\t\t\t\t\t   \\\n\t\t\t\t\t\tS = _p_;\t\t\t\t\t   \\\n\t\t\t\t\t} while (0)\n\n/* Set CPU in given bitmap   */\n#define SET_CPU_BITMAP(bitmap, cpu)\tbitmap[(cpu) >> 3] |= 1 << ((cpu) & 0x07)\n/* Check if CPU is set in bitmap */\n#define IS_CPU_SET(bitmap, cpu)\t\t(bitmap[(cpu) >> 3] & (1 << ((cpu) & 0x07)))\n/* Mark CPU as offline in dedicated CPU bitmap */\n#define MARK_CPU_OFFLINE(bitmap, cpu) \tSET_CPU_BITMAP(bitmap, cpu)\n/* Check if given CPU is offline */\n#define IS_CPU_OFFLINE(bitmap, cpu)\tIS_CPU_SET(bitmap, cpu)\n/* Check if given CPU has been selected */\n#define IS_CPU_SELECTED(bitmap, cpu)\tIS_CPU_SET(bitmap, cpu)\n\n/*\n * Macros used to display statistics values.\n *\n */\n/* With S_VALUE macro, the interval of time (@p) is given in 1/100th of a second */\n#define S_VALUE(m,n,p)\t\t(((double) ((n) - (m))) / (p) * 100)\n/* Define SP_VALUE() to normalize to % */\n#define SP_VALUE(m,n,p)\t\t(((double) ((n) - (m))) / (p) * 100)\n\n/*\n * Under very special circumstances, STDOUT may become unavailable.\n * This is what we try to guess here.\n */\n#define TEST_STDOUT(_fd_)\tdo {\t\t\t\t\t\\\n\t\t\t\t\tif (write(_fd_, \"\", 0) == -1) {\t\\\n\t\t\t\t        \tperror(\"stdout\");\t\\\n\t\t\t\t       \t\texit(6);\t\t\\\n\t\t\t\t \t}\t\t\t\t\\\n\t\t\t\t} while (0)\n\n#define MINIMUM(a,b)\t((a) < (b) ? (a) : (b))\n\n#define PANIC(m)\tsysstat_panic(__FUNCTION__, m)\n\n/* Number of ticks per second */\n#define HZ\t\thz\nextern unsigned long hz;\n\n/* Number of bit shifts to convert pages to kB */\nextern unsigned int kb_shift;\n\n/*\n * kB <-> number of pages.\n * Page size depends on machine architecture (4 kB, 8 kB, 16 kB, 64 kB...)\n */\n#define KB_TO_PG(k)\t((k) >> kb_shift)\n#define PG_TO_KB(k)\t((k) << kb_shift)\n\n/* Type of persistent device names used in sar and iostat */\nextern char persistent_name_type[MAX_FILE_LEN];\n\n/*\n ***************************************************************************\n * Colors definitions\n ***************************************************************************\n */\n\n#define C_LIGHT_RED\t\"\\e[31;22m\"\n#define C_BOLD_RED\t\"\\e[31;1m\"\n#define C_LIGHT_GREEN\t\"\\e[32;22m\"\n#define C_BOLD_GREEN\t\"\\e[32;1m\"\n#define C_LIGHT_YELLOW\t\"\\e[33;22m\"\n#define C_BOLD_MAGENTA\t\"\\e[35;1m\"\n#define C_BOLD_BLUE\t\"\\e[34;1m\"\n#define C_LIGHT_BLUE\t\"\\e[34;22m\"\n#define C_NORMAL\t\"\\e[0m\"\n\n#define PERCENT_LIMIT_XHIGH\t90.0\n#define PERCENT_LIMIT_HIGH\t75.0\n#define PERCENT_LIMIT_LOW\t25.0\n#define PERCENT_LIMIT_XLOW\t10.0\n\nenum {\n\tXHIGH\t= 1,\n\tXLOW\t= 2,\n\tXLOW0\t= 3\n};\n\n#define MAX_SGR_LEN\t16\n\nenum {\n\tIS_INT\t\t= 0,\n\tIS_STR\t\t= 1,\n\tIS_RESTART\t= 2,\n\tIS_COMMENT\t= 3,\n\tIS_ZERO\t\t= 4,\n\tIS_DEBUG\t= IS_RESTART\n};\n\n/*\n ***************************************************************************\n * Structures definitions\n ***************************************************************************\n */\n\n/* Structure used for extended disk statistics */\nstruct ext_disk_stats {\n\tdouble util;\n\tdouble await;\n\tdouble arqsz;\n};\n\n/*\n ***************************************************************************\n * Functions prototypes\n ***************************************************************************\n */\nvoid print_version\n\t(char *[], int);\nvoid get_HZ\n\t(void);\nvoid get_kb_shift\n\t(void);\ntime_t get_xtime\n\t(struct tm *, int, int);\ntime_t get_time\n\t(struct tm *, int);\nvoid init_nls\n\t(void);\nint is_device\n\t(char *, char *, int);\nvoid sysstat_panic\n\t(const char *, int);\nint extract_wwnid\n\t(char *, unsigned long long *, unsigned int *);\nint get_wwnid_from_pretty\n\t(char *, unsigned long long *, unsigned int *);\nint check_dir\n\t(char *);\nvoid check_overflow\n\t(unsigned int, unsigned int, unsigned int, unsigned int);\n\n#ifndef SOURCE_SADC\nint count_bits\n\t(void *, int);\nint count_csvalues\n\t(int, char **);\nvoid cprintf_f\n\t(int, int, int, int, int, ...);\nvoid cprintf_in\n\t(int, char *, char *, int);\nvoid cprintf_xpc\n\t(int, int, int, int, int, ...);\nvoid cprintf_s\n\t(int, char *, char *);\nvoid cprintf_u64\n\t(int, int, int, ...);\nvoid cprintf_x\n\t(int, int, ...);\nvoid cprintf_tr\n\t(int, char *, char *);\nchar *device_name\n\t(char *);\nchar *escape_bs_char\n\t(char *);\nchar *get_device_name\n\t(unsigned int, unsigned int, unsigned long long [],\n\t unsigned int, unsigned int, unsigned int, unsigned int, char *);\nunsigned int get_devmap_major\n\t(void);\nunsigned long long get_interval\n\t(unsigned long long, unsigned long long);\nchar *get_persistent_name_from_pretty\n\t(char *);\nchar *get_persistent_type_dir\n\t(char *);\nchar *get_pretty_name_from_persistent\n\t(char *);\nint get_sysfs_dev_nr\n\t(int);\nint get_win_height\n\t(void);\nvoid init_colors\n\t(void);\ndouble ll_sp_value\n\t(unsigned long long, unsigned long long, unsigned long long);\nint is_iso_time_fmt\n\t(void);\nint parse_range_values\n\t(char *t, int, int *, int *);\nint parse_values\n\t(char *, unsigned char[], int, const char *);\nint print_gal_header\n\t(struct tm *, char *, char *, char *, char *, int, int);\nint set_report_date\n\t(struct tm *, char[], int);\nchar *strtolower\n\t(char *);\nvoid write_sample_timestamp\n\t(int, struct tm *, uint64_t);\nvoid xprintf\n\t(int, const char *, ...);\nvoid xprintf0\n\t(int, const char *, ...);\n\n#endif /* SOURCE_SADC undefined */\n#endif  /* _COMMON_H */\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 196.294921875,
          "content": "#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.71 for sysstat 12.7.7.\n#\n#\n# Copyright (C) 1992-1996, 1998-2017, 2020-2021 Free Software Foundation,\n# Inc.\n#\n#\n# This configure script is free software; the Free Software Foundation\n# gives unlimited permission to copy, distribute and modify it.\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nas_nop=:\nif test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse $as_nop\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\n\n# Reset variables that may have inherited troublesome values from\n# the environment.\n\n# IFS needs to be set, to space, tab, and newline, in precisely that order.\n# (If _AS_PATH_WALK were called with IFS unset, it would have the\n# side effect of setting IFS to empty, thus disabling word splitting.)\n# Quoting is to prevent editors from complaining about space-tab.\nas_nl='\n'\nexport as_nl\nIFS=\" \"\"\t$as_nl\"\n\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# Ensure predictable behavior from utilities with locale-dependent output.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# We cannot yet rely on \"unset\" to work, but we need these variables\n# to be unset--not just set to an empty or harmless value--now, to\n# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct\n# also avoids known problems related to \"unset\" and subshell syntax\n# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).\nfor as_var in BASH_ENV ENV MAIL MAILPATH CDPATH\ndo eval test \\${$as_var+y} \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\n\n# Ensure that fds 0, 1, and 2 are open.\nif (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi\nif (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi\nif (exec 3>&2)            ; then :; else exec 2>/dev/null; fi\n\n# The user is always right.\nif ${PATH_SEPARATOR+false} :; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    test -r \"$as_dir$0\" && as_myself=$as_dir$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  printf \"%s\\n\" \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n\n# Use a proper internal environment variable to ensure we don't fall\n  # into an infinite loop, continuously re-executing ourselves.\n  if test x\"${_as_can_reexec}\" != xno && test \"x$CONFIG_SHELL\" != x; then\n    _as_can_reexec=no; export _as_can_reexec;\n    # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\nprintf \"%s\\n\" \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\n  fi\n  # We don't want this to propagate to other subprocesses.\n          { _as_can_reexec=; unset _as_can_reexec;}\nif test \"x$CONFIG_SHELL\" = x; then\n  as_bourne_compatible=\"as_nop=:\nif test \\${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse \\$as_nop\n  case \\`(set -o) 2>/dev/null\\` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\"\n  as_required=\"as_fn_return () { (exit \\$1); }\nas_fn_success () { as_fn_return 0; }\nas_fn_failure () { as_fn_return 1; }\nas_fn_ret_success () { return 0; }\nas_fn_ret_failure () { return 1; }\n\nexitcode=0\nas_fn_success || { exitcode=1; echo as_fn_success failed.; }\nas_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }\nas_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }\nas_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }\nif ( set x; as_fn_ret_success y && test x = \\\"\\$1\\\" )\nthen :\n\nelse \\$as_nop\n  exitcode=1; echo positional parameters were not saved.\nfi\ntest x\\$exitcode = x0 || exit 1\nblah=\\$(echo \\$(echo blah))\ntest x\\\"\\$blah\\\" = xblah || exit 1\ntest -x / || exit 1\"\n  as_suggested=\"  as_lineno_1=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_1a=\\$LINENO\n  as_lineno_2=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_2a=\\$LINENO\n  eval 'test \\\"x\\$as_lineno_1'\\$as_run'\\\" != \\\"x\\$as_lineno_2'\\$as_run'\\\" &&\n  test \\\"x\\`expr \\$as_lineno_1'\\$as_run' + 1\\`\\\" = \\\"x\\$as_lineno_2'\\$as_run'\\\"' || exit 1\"\n  if (eval \"$as_required\") 2>/dev/null\nthen :\n  as_have_required=yes\nelse $as_nop\n  as_have_required=no\nfi\n  if test x$as_have_required = xyes && (eval \"$as_suggested\") 2>/dev/null\nthen :\n\nelse $as_nop\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nas_found=false\nfor as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n  as_found=:\n  case $as_dir in #(\n\t /*)\n\t   for as_base in sh bash ksh sh5; do\n\t     # Try only shells that exist, to save several forks.\n\t     as_shell=$as_dir$as_base\n\t     if { test -f \"$as_shell\" || test -f \"$as_shell.exe\"; } &&\n\t\t    as_run=a \"$as_shell\" -c \"$as_bourne_compatible\"\"$as_required\" 2>/dev/null\nthen :\n  CONFIG_SHELL=$as_shell as_have_required=yes\n\t\t   if as_run=a \"$as_shell\" -c \"$as_bourne_compatible\"\"$as_suggested\" 2>/dev/null\nthen :\n  break 2\nfi\nfi\n\t   done;;\n       esac\n  as_found=false\ndone\nIFS=$as_save_IFS\nif $as_found\nthen :\n\nelse $as_nop\n  if { test -f \"$SHELL\" || test -f \"$SHELL.exe\"; } &&\n\t      as_run=a \"$SHELL\" -c \"$as_bourne_compatible\"\"$as_required\" 2>/dev/null\nthen :\n  CONFIG_SHELL=$SHELL as_have_required=yes\nfi\nfi\n\n\n      if test \"x$CONFIG_SHELL\" != x\nthen :\n  export CONFIG_SHELL\n             # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\nprintf \"%s\\n\" \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\nfi\n\n    if test x$as_have_required = xno\nthen :\n  printf \"%s\\n\" \"$0: This script requires a shell more modern than all\"\n  printf \"%s\\n\" \"$0: the shells that I found on your system.\"\n  if test ${ZSH_VERSION+y} ; then\n    printf \"%s\\n\" \"$0: In particular, zsh $ZSH_VERSION has bugs and should\"\n    printf \"%s\\n\" \"$0: be upgraded to zsh 4.3.4 or later.\"\n  else\n    printf \"%s\\n\" \"$0: Please tell bug-autoconf@gnu.org about your system,\n$0: including any error possibly output before this\n$0: message. Then install a modern shell, or manually run\n$0: the script under such a shell if you do have one.\"\n  fi\n  exit 1\nfi\nfi\nfi\nSHELL=${CONFIG_SHELL-/bin/sh}\nexport SHELL\n# Unset more variables known to interfere with behavior of common tools.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n## --------------------- ##\n## M4sh Shell Functions. ##\n## --------------------- ##\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n# as_fn_nop\n# ---------\n# Do nothing but, unlike \":\", preserve the value of $?.\nas_fn_nop ()\n{\n  return $?\n}\nas_nop=as_fn_nop\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`printf \"%s\\n\" \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null\nthen :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse $as_nop\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null\nthen :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse $as_nop\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n# as_fn_nop\n# ---------\n# Do nothing but, unlike \":\", preserve the value of $?.\nas_fn_nop ()\n{\n  return $?\n}\nas_nop=as_fn_nop\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  printf \"%s\\n\" \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n  as_lineno_1=$LINENO as_lineno_1a=$LINENO\n  as_lineno_2=$LINENO as_lineno_2a=$LINENO\n  eval 'test \"x$as_lineno_1'$as_run'\" != \"x$as_lineno_2'$as_run'\" &&\n  test \"x`expr $as_lineno_1'$as_run' + 1`\" = \"x$as_lineno_2'$as_run'\"' || {\n  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)\n  sed -n '\n    p\n    /[$]LINENO/=\n  ' <$as_myself |\n    sed '\n      s/[$]LINENO.*/&-/\n      t lineno\n      b\n      :lineno\n      N\n      :loop\n      s/[$]LINENO\\([^'$as_cr_alnum'_].*\\n\\)\\(.*\\)/\\2\\1\\2/\n      t loop\n      s/-\\n.*//\n    ' >$as_me.lineno &&\n  chmod +x \"$as_me.lineno\" ||\n    { printf \"%s\\n\" \"$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell\" >&2; as_fn_exit 1; }\n\n  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have\n  # already done that, so ensure we don't try to do so again and fall\n  # in an infinite loop.  This has already happened in practice.\n  _as_can_reexec=no; export _as_can_reexec\n  # Don't try to exec as it changes $[0], causing all sort of problems\n  # (the dirname of $[0] is not the place where we might find the\n  # original and so on.  Autoconf is especially sensitive to this).\n  . \"./$as_me.lineno\"\n  # Exit status is that of the last command.\n  exit\n}\n\n\n# Determine whether it's possible to make 'echo' print without a newline.\n# These variables are no longer used directly by Autoconf, but are AC_SUBSTed\n# for compatibility with existing Makefiles.\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\n# For backward compatibility with old third-party macros, we provide\n# the shell variables $as_echo and $as_echo_n.  New code should use\n# AS_ECHO([\"message\"]) and AS_ECHO_N([\"message\"]), respectively.\nas_echo='printf %s\\n'\nas_echo_n='printf %s'\n\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\ntest -n \"$DJDIR\" || exec 7<&0 </dev/null\nexec 6>&1\n\n# Name of the host.\n# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,\n# so uname gets run too.\nac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`\n\n#\n# Initializations.\n#\nac_default_prefix=/usr/local\nac_clean_files=\nac_config_libobj_dir=.\nLIBOBJS=\ncross_compiling=no\nsubdirs=\nMFLAGS=\nMAKEFLAGS=\n\n# Identity of this package.\nPACKAGE_NAME='sysstat'\nPACKAGE_TARNAME='sysstat'\nPACKAGE_VERSION='12.7.7'\nPACKAGE_STRING='sysstat 12.7.7'\nPACKAGE_BUGREPORT=''\nPACKAGE_URL=''\n\nac_unique_file=\"ioconf.h\"\n# Factoring default headers for most tests.\nac_includes_default=\"\\\n#include <stddef.h>\n#ifdef HAVE_STDIO_H\n# include <stdio.h>\n#endif\n#ifdef HAVE_STDLIB_H\n# include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\"\n\nac_header_c_list=\nac_subst_vars='LTLIBOBJS\nLIBOBJS\nSTRIP\nWITH_DEBUG\nDFLAGS\nINSTALL_DOC\nCOLLECT_ALL\nREM_CHOWN\nQUOTE\nCRON_COUNT\nCRON_INTERVAL_SEC\nCRON_INTERVAL\nSU_C_OWNER\nCRON_OWNER\nCOPY_ONLY\nSADC_OPT\nsadc_options\ncron_interval\nUSE_CROND\ncron_owner\nINSTALL_CRON\nCLEAN_SA_DIR\nCOMPRESS_MANPG\nIGNORE_FILE_ATTRIBUTES\nMAN_GROUP\nman_group\nDELAY_RANGE\ndelay_range\nCOMPRESSAFTER\ncompressafter\nHISTORY\nhistory\nLTO\nGCC_AR\nNLS\nLFINTL\nSYSCONFIG_FILE\nconf_file\nSYSCONFIG_DIR\nconf_dir\nSAR_DIR\nsar_dir\nSA_DIR\nsa_dir\nSA_LIB_DIR\nsa_lib_dir\nSYSPARAM\nLINUX_SCHED\nSYSMACROS\nINITD_DIR\nINIT_DIR\nRC_DIR\nrcdir\nTGLIB32\nDFSENSORS32\nLFSENSORS32\nHAVE_SENSORS32\nDFSENSORS\nLFSENSORS\nHAVE_SENSORS\nPCP_IMPL\nDFPCP\nLFPCP\nHAVE_PCP\nSYSTEMD_SLEEP_DIR\nSYSTEMD_UNIT_DIR\nSYSTEMCTL\nPKG_CONFIG\nPATH_CHKCONFIG\nPATH_CP\nINSTALL_BIN\nINSTALL_DATA\nZIP\nVER_JSON\nVER_XML\nMSGMERGE\nXGETTEXT\nMSGFMT\nINSTALL\nAR\nCHOWN\nCHMOD\nLN_S\nOBJEXT\nEXEEXT\nac_ct_CC\nCPPFLAGS\nLDFLAGS\nCFLAGS\nCC\ntarget_alias\nhost_alias\nbuild_alias\nLIBS\nECHO_T\nECHO_N\nECHO_C\nDEFS\nmandir\nlocaledir\nlibdir\npsdir\npdfdir\ndvidir\nhtmldir\ninfodir\ndocdir\noldincludedir\nincludedir\nrunstatedir\nlocalstatedir\nsharedstatedir\nsysconfdir\ndatadir\ndatarootdir\nlibexecdir\nsbindir\nbindir\nprogram_transform_name\nprefix\nexec_prefix\nPACKAGE_URL\nPACKAGE_BUGREPORT\nPACKAGE_STRING\nPACKAGE_VERSION\nPACKAGE_TARNAME\nPACKAGE_NAME\nPATH_SEPARATOR\nSHELL'\nac_subst_files=''\nac_user_opts='\nenable_option_checking\nwith_systemdsystemunitdir\nwith_systemdsleepdir\nenable_pcp\nenable_sensors\nenable_largefile\nenable_nls\nenable_lto\nenable_file_attr\nenable_compress_manpg\nenable_clean_sa_dir\nenable_install_cron\nenable_use_crond\nenable_collect_all\nenable_copy_only\nenable_documentation\nenable_debuginfo\nenable_stripping\n'\n      ac_precious_vars='build_alias\nhost_alias\ntarget_alias\nCC\nCFLAGS\nLDFLAGS\nLIBS\nCPPFLAGS\nrcdir\nsa_lib_dir\nsa_dir\nsar_dir\nconf_dir\nconf_file\nhistory\ncompressafter\ndelay_range\nman_group\ncron_owner\ncron_interval\nsadc_options'\n\n\n# Initialize some variables set by options.\nac_init_help=\nac_init_version=false\nac_unrecognized_opts=\nac_unrecognized_sep=\n# The variables have the same names as the options, with\n# dashes changed to underlines.\ncache_file=/dev/null\nexec_prefix=NONE\nno_create=\nno_recursion=\nprefix=NONE\nprogram_prefix=NONE\nprogram_suffix=NONE\nprogram_transform_name=s,x,x,\nsilent=\nsite=\nsrcdir=\nverbose=\nx_includes=NONE\nx_libraries=NONE\n\n# Installation directory options.\n# These are left unexpanded so users can \"make install exec_prefix=/foo\"\n# and all the variables that are supposed to be based on exec_prefix\n# by default will actually change.\n# Use braces instead of parens because sh, perl, etc. also accept them.\n# (The list follows the same order as the GNU Coding Standards.)\nbindir='${exec_prefix}/bin'\nsbindir='${exec_prefix}/sbin'\nlibexecdir='${exec_prefix}/libexec'\ndatarootdir='${prefix}/share'\ndatadir='${datarootdir}'\nsysconfdir='${prefix}/etc'\nsharedstatedir='${prefix}/com'\nlocalstatedir='${prefix}/var'\nrunstatedir='${localstatedir}/run'\nincludedir='${prefix}/include'\noldincludedir='/usr/include'\ndocdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\ninfodir='${datarootdir}/info'\nhtmldir='${docdir}'\ndvidir='${docdir}'\npdfdir='${docdir}'\npsdir='${docdir}'\nlibdir='${exec_prefix}/lib'\nlocaledir='${datarootdir}/locale'\nmandir='${datarootdir}/man'\n\nac_prev=\nac_dashdash=\nfor ac_option\ndo\n  # If the previous option needs an argument, assign it.\n  if test -n \"$ac_prev\"; then\n    eval $ac_prev=\\$ac_option\n    ac_prev=\n    continue\n  fi\n\n  case $ac_option in\n  *=?*) ac_optarg=`expr \"X$ac_option\" : '[^=]*=\\(.*\\)'` ;;\n  *=)   ac_optarg= ;;\n  *)    ac_optarg=yes ;;\n  esac\n\n  case $ac_dashdash$ac_option in\n  --)\n    ac_dashdash=yes ;;\n\n  -bindir | --bindir | --bindi | --bind | --bin | --bi)\n    ac_prev=bindir ;;\n  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)\n    bindir=$ac_optarg ;;\n\n  -build | --build | --buil | --bui | --bu)\n    ac_prev=build_alias ;;\n  -build=* | --build=* | --buil=* | --bui=* | --bu=*)\n    build_alias=$ac_optarg ;;\n\n  -cache-file | --cache-file | --cache-fil | --cache-fi \\\n  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)\n    ac_prev=cache_file ;;\n  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \\\n  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)\n    cache_file=$ac_optarg ;;\n\n  --config-cache | -C)\n    cache_file=config.cache ;;\n\n  -datadir | --datadir | --datadi | --datad)\n    ac_prev=datadir ;;\n  -datadir=* | --datadir=* | --datadi=* | --datad=*)\n    datadir=$ac_optarg ;;\n\n  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \\\n  | --dataroo | --dataro | --datar)\n    ac_prev=datarootdir ;;\n  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \\\n  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)\n    datarootdir=$ac_optarg ;;\n\n  -disable-* | --disable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*disable-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=no ;;\n\n  -docdir | --docdir | --docdi | --doc | --do)\n    ac_prev=docdir ;;\n  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)\n    docdir=$ac_optarg ;;\n\n  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)\n    ac_prev=dvidir ;;\n  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)\n    dvidir=$ac_optarg ;;\n\n  -enable-* | --enable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*enable-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=\\$ac_optarg ;;\n\n  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \\\n  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \\\n  | --exec | --exe | --ex)\n    ac_prev=exec_prefix ;;\n  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \\\n  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \\\n  | --exec=* | --exe=* | --ex=*)\n    exec_prefix=$ac_optarg ;;\n\n  -gas | --gas | --ga | --g)\n    # Obsolete; use --with-gas.\n    with_gas=yes ;;\n\n  -help | --help | --hel | --he | -h)\n    ac_init_help=long ;;\n  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)\n    ac_init_help=recursive ;;\n  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)\n    ac_init_help=short ;;\n\n  -host | --host | --hos | --ho)\n    ac_prev=host_alias ;;\n  -host=* | --host=* | --hos=* | --ho=*)\n    host_alias=$ac_optarg ;;\n\n  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)\n    ac_prev=htmldir ;;\n  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \\\n  | --ht=*)\n    htmldir=$ac_optarg ;;\n\n  -includedir | --includedir | --includedi | --included | --include \\\n  | --includ | --inclu | --incl | --inc)\n    ac_prev=includedir ;;\n  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \\\n  | --includ=* | --inclu=* | --incl=* | --inc=*)\n    includedir=$ac_optarg ;;\n\n  -infodir | --infodir | --infodi | --infod | --info | --inf)\n    ac_prev=infodir ;;\n  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)\n    infodir=$ac_optarg ;;\n\n  -libdir | --libdir | --libdi | --libd)\n    ac_prev=libdir ;;\n  -libdir=* | --libdir=* | --libdi=* | --libd=*)\n    libdir=$ac_optarg ;;\n\n  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \\\n  | --libexe | --libex | --libe)\n    ac_prev=libexecdir ;;\n  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \\\n  | --libexe=* | --libex=* | --libe=*)\n    libexecdir=$ac_optarg ;;\n\n  -localedir | --localedir | --localedi | --localed | --locale)\n    ac_prev=localedir ;;\n  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)\n    localedir=$ac_optarg ;;\n\n  -localstatedir | --localstatedir | --localstatedi | --localstated \\\n  | --localstate | --localstat | --localsta | --localst | --locals)\n    ac_prev=localstatedir ;;\n  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \\\n  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)\n    localstatedir=$ac_optarg ;;\n\n  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)\n    ac_prev=mandir ;;\n  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)\n    mandir=$ac_optarg ;;\n\n  -nfp | --nfp | --nf)\n    # Obsolete; use --without-fp.\n    with_fp=no ;;\n\n  -no-create | --no-create | --no-creat | --no-crea | --no-cre \\\n  | --no-cr | --no-c | -n)\n    no_create=yes ;;\n\n  -no-recursion | --no-recursion | --no-recursio | --no-recursi \\\n  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)\n    no_recursion=yes ;;\n\n  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \\\n  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \\\n  | --oldin | --oldi | --old | --ol | --o)\n    ac_prev=oldincludedir ;;\n  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \\\n  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \\\n  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)\n    oldincludedir=$ac_optarg ;;\n\n  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)\n    ac_prev=prefix ;;\n  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)\n    prefix=$ac_optarg ;;\n\n  -program-prefix | --program-prefix | --program-prefi | --program-pref \\\n  | --program-pre | --program-pr | --program-p)\n    ac_prev=program_prefix ;;\n  -program-prefix=* | --program-prefix=* | --program-prefi=* \\\n  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)\n    program_prefix=$ac_optarg ;;\n\n  -program-suffix | --program-suffix | --program-suffi | --program-suff \\\n  | --program-suf | --program-su | --program-s)\n    ac_prev=program_suffix ;;\n  -program-suffix=* | --program-suffix=* | --program-suffi=* \\\n  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)\n    program_suffix=$ac_optarg ;;\n\n  -program-transform-name | --program-transform-name \\\n  | --program-transform-nam | --program-transform-na \\\n  | --program-transform-n | --program-transform- \\\n  | --program-transform | --program-transfor \\\n  | --program-transfo | --program-transf \\\n  | --program-trans | --program-tran \\\n  | --progr-tra | --program-tr | --program-t)\n    ac_prev=program_transform_name ;;\n  -program-transform-name=* | --program-transform-name=* \\\n  | --program-transform-nam=* | --program-transform-na=* \\\n  | --program-transform-n=* | --program-transform-=* \\\n  | --program-transform=* | --program-transfor=* \\\n  | --program-transfo=* | --program-transf=* \\\n  | --program-trans=* | --program-tran=* \\\n  | --progr-tra=* | --program-tr=* | --program-t=*)\n    program_transform_name=$ac_optarg ;;\n\n  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)\n    ac_prev=pdfdir ;;\n  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)\n    pdfdir=$ac_optarg ;;\n\n  -psdir | --psdir | --psdi | --psd | --ps)\n    ac_prev=psdir ;;\n  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)\n    psdir=$ac_optarg ;;\n\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil)\n    silent=yes ;;\n\n  -runstatedir | --runstatedir | --runstatedi | --runstated \\\n  | --runstate | --runstat | --runsta | --runst | --runs \\\n  | --run | --ru | --r)\n    ac_prev=runstatedir ;;\n  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \\\n  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \\\n  | --run=* | --ru=* | --r=*)\n    runstatedir=$ac_optarg ;;\n\n  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n    ac_prev=sbindir ;;\n  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n  | --sbi=* | --sb=*)\n    sbindir=$ac_optarg ;;\n\n  -sharedstatedir | --sharedstatedir | --sharedstatedi \\\n  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \\\n  | --sharedst | --shareds | --shared | --share | --shar \\\n  | --sha | --sh)\n    ac_prev=sharedstatedir ;;\n  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \\\n  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \\\n  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \\\n  | --sha=* | --sh=*)\n    sharedstatedir=$ac_optarg ;;\n\n  -site | --site | --sit)\n    ac_prev=site ;;\n  -site=* | --site=* | --sit=*)\n    site=$ac_optarg ;;\n\n  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n    ac_prev=srcdir ;;\n  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n    srcdir=$ac_optarg ;;\n\n  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \\\n  | --syscon | --sysco | --sysc | --sys | --sy)\n    ac_prev=sysconfdir ;;\n  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \\\n  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)\n    sysconfdir=$ac_optarg ;;\n\n  -target | --target | --targe | --targ | --tar | --ta | --t)\n    ac_prev=target_alias ;;\n  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)\n    target_alias=$ac_optarg ;;\n\n  -v | -verbose | --verbose | --verbos | --verbo | --verb)\n    verbose=yes ;;\n\n  -version | --version | --versio | --versi | --vers | -V)\n    ac_init_version=: ;;\n\n  -with-* | --with-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*with-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=\\$ac_optarg ;;\n\n  -without-* | --without-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*without-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=no ;;\n\n  --x)\n    # Obsolete; use --with-x.\n    with_x=yes ;;\n\n  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \\\n  | --x-incl | --x-inc | --x-in | --x-i)\n    ac_prev=x_includes ;;\n  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \\\n  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)\n    x_includes=$ac_optarg ;;\n\n  -x-libraries | --x-libraries | --x-librarie | --x-librari \\\n  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)\n    ac_prev=x_libraries ;;\n  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \\\n  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)\n    x_libraries=$ac_optarg ;;\n\n  -*) as_fn_error $? \"unrecognized option: \\`$ac_option'\nTry \\`$0 --help' for more information\"\n    ;;\n\n  *=*)\n    ac_envvar=`expr \"x$ac_option\" : 'x\\([^=]*\\)='`\n    # Reject names that are not valid shell variable names.\n    case $ac_envvar in #(\n      '' | [0-9]* | *[!_$as_cr_alnum]* )\n      as_fn_error $? \"invalid variable name: \\`$ac_envvar'\" ;;\n    esac\n    eval $ac_envvar=\\$ac_optarg\n    export $ac_envvar ;;\n\n  *)\n    # FIXME: should be removed in autoconf 3.0.\n    printf \"%s\\n\" \"$as_me: WARNING: you should use --build, --host, --target\" >&2\n    expr \"x$ac_option\" : \".*[^-._$as_cr_alnum]\" >/dev/null &&\n      printf \"%s\\n\" \"$as_me: WARNING: invalid host type: $ac_option\" >&2\n    : \"${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}\"\n    ;;\n\n  esac\ndone\n\nif test -n \"$ac_prev\"; then\n  ac_option=--`echo $ac_prev | sed 's/_/-/g'`\n  as_fn_error $? \"missing argument to $ac_option\"\nfi\n\nif test -n \"$ac_unrecognized_opts\"; then\n  case $enable_option_checking in\n    no) ;;\n    fatal) as_fn_error $? \"unrecognized options: $ac_unrecognized_opts\" ;;\n    *)     printf \"%s\\n\" \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2 ;;\n  esac\nfi\n\n# Check all directory arguments for consistency.\nfor ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n\t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n\t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n\t\tlibdir localedir mandir runstatedir\ndo\n  eval ac_val=\\$$ac_var\n  # Remove trailing slashes.\n  case $ac_val in\n    */ )\n      ac_val=`expr \"X$ac_val\" : 'X\\(.*[^/]\\)' \\| \"X$ac_val\" : 'X\\(.*\\)'`\n      eval $ac_var=\\$ac_val;;\n  esac\n  # Be sure to have absolute directory names.\n  case $ac_val in\n    [\\\\/$]* | ?:[\\\\/]* )  continue;;\n    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;\n  esac\n  as_fn_error $? \"expected an absolute directory name for --$ac_var: $ac_val\"\ndone\n\n# There might be people who depend on the old broken behavior: `$host'\n# used to hold the argument of --host etc.\n# FIXME: To remove some day.\nbuild=$build_alias\nhost=$host_alias\ntarget=$target_alias\n\n# FIXME: To remove some day.\nif test \"x$host_alias\" != x; then\n  if test \"x$build_alias\" = x; then\n    cross_compiling=maybe\n  elif test \"x$build_alias\" != \"x$host_alias\"; then\n    cross_compiling=yes\n  fi\nfi\n\nac_tool_prefix=\ntest -n \"$host_alias\" && ac_tool_prefix=$host_alias-\n\ntest \"$silent\" = yes && exec 6>/dev/null\n\n\nac_pwd=`pwd` && test -n \"$ac_pwd\" &&\nac_ls_di=`ls -di .` &&\nac_pwd_ls_di=`cd \"$ac_pwd\" && ls -di .` ||\n  as_fn_error $? \"working directory cannot be determined\"\ntest \"X$ac_ls_di\" = \"X$ac_pwd_ls_di\" ||\n  as_fn_error $? \"pwd does not report name of working directory\"\n\n\n# Find the source files, if location was not specified.\nif test -z \"$srcdir\"; then\n  ac_srcdir_defaulted=yes\n  # Try the directory containing this script, then the parent directory.\n  ac_confdir=`$as_dirname -- \"$as_myself\" ||\n$as_expr X\"$as_myself\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_myself\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_myself\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  srcdir=$ac_confdir\n  if test ! -r \"$srcdir/$ac_unique_file\"; then\n    srcdir=..\n  fi\nelse\n  ac_srcdir_defaulted=no\nfi\nif test ! -r \"$srcdir/$ac_unique_file\"; then\n  test \"$ac_srcdir_defaulted\" = yes && srcdir=\"$ac_confdir or ..\"\n  as_fn_error $? \"cannot find sources ($ac_unique_file) in $srcdir\"\nfi\nac_msg=\"sources are in $srcdir, but \\`cd $srcdir' does not work\"\nac_abs_confdir=`(\n\tcd \"$srcdir\" && test -r \"./$ac_unique_file\" || as_fn_error $? \"$ac_msg\"\n\tpwd)`\n# When building in place, set srcdir=.\nif test \"$ac_abs_confdir\" = \"$ac_pwd\"; then\n  srcdir=.\nfi\n# Remove unnecessary trailing slashes from srcdir.\n# Double slashes in file names in object file debugging info\n# mess up M-x gdb in Emacs.\ncase $srcdir in\n*/) srcdir=`expr \"X$srcdir\" : 'X\\(.*[^/]\\)' \\| \"X$srcdir\" : 'X\\(.*\\)'`;;\nesac\nfor ac_var in $ac_precious_vars; do\n  eval ac_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_env_${ac_var}_value=\\$${ac_var}\n  eval ac_cv_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_cv_env_${ac_var}_value=\\$${ac_var}\ndone\n\n#\n# Report the --help message.\n#\nif test \"$ac_init_help\" = \"long\"; then\n  # Omit some internal or obsolete options to make the list less imposing.\n  # This message is too long to be a string in the A/UX 3.1 sh.\n  cat <<_ACEOF\n\\`configure' configures sysstat 12.7.7 to adapt to many kinds of systems.\n\nUsage: $0 [OPTION]... [VAR=VALUE]...\n\nTo assign environment variables (e.g., CC, CFLAGS...), specify them as\nVAR=VALUE.  See below for descriptions of some of the useful variables.\n\nDefaults for the options are specified in brackets.\n\nConfiguration:\n  -h, --help              display this help and exit\n      --help=short        display options specific to this package\n      --help=recursive    display the short help of all the included packages\n  -V, --version           display version information and exit\n  -q, --quiet, --silent   do not print \\`checking ...' messages\n      --cache-file=FILE   cache test results in FILE [disabled]\n  -C, --config-cache      alias for \\`--cache-file=config.cache'\n  -n, --no-create         do not create output files\n      --srcdir=DIR        find the sources in DIR [configure dir or \\`..']\n\nInstallation directories:\n  --prefix=PREFIX         install architecture-independent files in PREFIX\n                          [$ac_default_prefix]\n  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n                          [PREFIX]\n\nBy default, \\`make install' will install all the files in\n\\`$ac_default_prefix/bin', \\`$ac_default_prefix/lib' etc.  You can specify\nan installation prefix other than \\`$ac_default_prefix' using \\`--prefix',\nfor instance \\`--prefix=\\$HOME'.\n\nFor better control, use the options below.\n\nFine tuning of the installation directories:\n  --bindir=DIR            user executables [EPREFIX/bin]\n  --sbindir=DIR           system admin executables [EPREFIX/sbin]\n  --libexecdir=DIR        program executables [EPREFIX/libexec]\n  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]\n  --libdir=DIR            object code libraries [EPREFIX/lib]\n  --includedir=DIR        C header files [PREFIX/include]\n  --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]\n  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]\n  --infodir=DIR           info documentation [DATAROOTDIR/info]\n  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]\n  --mandir=DIR            man documentation [DATAROOTDIR/man]\n  --docdir=DIR            documentation root [DATAROOTDIR/doc/sysstat]\n  --htmldir=DIR           html documentation [DOCDIR]\n  --dvidir=DIR            dvi documentation [DOCDIR]\n  --pdfdir=DIR            pdf documentation [DOCDIR]\n  --psdir=DIR             ps documentation [DOCDIR]\n_ACEOF\n\n  cat <<\\_ACEOF\n_ACEOF\nfi\n\nif test -n \"$ac_init_help\"; then\n  case $ac_init_help in\n     short | recursive ) echo \"Configuration of sysstat 12.7.7:\";;\n   esac\n  cat <<\\_ACEOF\n\nOptional Features:\n  --disable-option-checking  ignore unrecognized --enable/--with options\n  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)\n  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]\n  --disable-pcp           disable PCP support\n  --disable-sensors       disable sensors support\n  --disable-largefile     omit support for large files\n  --disable-nls           disable National Language Support\n  --enable-lto            enable Link Time Optimization\n  --disable-file-attr     do not set attributes on files being installed\n  --disable-compress-manpg\n                          do not compress sysstat manual pages\n  --enable-clean-sa-dir   clean system activity directory\n  --enable-install-cron   install a crontab to start sar\n  --enable-use-crond      use standard cron daemon\n  --enable-collect-all    collect all possible activities\n  --enable-copy-only      only copy files when installing\n  --disable-documentation do not install documentation\n  --enable-debuginfo      enable debug output (--debuginfo option)\n  --disable-stripping     do not strip object files\n\nOptional Packages:\n  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]\n  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)\n  --with-systemdsystemunitdir=DIR\n                          Directory for systemd service files\n  --with-systemdsleepdir=DIR\n                          Directory for systemd suspend/resume scripts\n\nSome influential environment variables:\n  CC          C compiler command\n  CFLAGS      C compiler flags\n  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a\n              nonstandard directory <lib dir>\n  LIBS        libraries to pass to the linker, e.g. -l<library>\n  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if\n              you have headers in a nonstandard directory <include dir>\n  rcdir       run-commands directory\n  sa_lib_dir  sadc directory\n  sa_dir      system activity directory\n  sar_dir     sar directory\n  conf_dir    sysstat configuration directory\n  conf_file   sysstat configuration file\n  history     number of daily data files to keep (default value is 7)\n  compressafter\n              number of days after which data files are compressed (default\n              value is 10)\n  delay_range maximum delay (in seconds) to wait before sa2 script generates\n              its reports\n  man_group   group for manual pages\n  cron_owner  crontab owner\n  cron_interval\n              crontab interval\n  sadc_options\n              options to be passed to sadc\n\nUse these variables to override the choices made by `configure' or to help\nit to find libraries and programs with nonstandard names/locations.\n\nReport bugs to the package provider.\n_ACEOF\nac_status=$?\nfi\n\nif test \"$ac_init_help\" = \"recursive\"; then\n  # If there are subdirs, report their specific --help.\n  for ac_dir in : $ac_subdirs_all; do test \"x$ac_dir\" = x: && continue\n    test -d \"$ac_dir\" ||\n      { cd \"$srcdir\" && ac_pwd=`pwd` && srcdir=. && test -d \"$ac_dir\"; } ||\n      continue\n    ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`printf \"%s\\n\" \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`printf \"%s\\n\" \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n    cd \"$ac_dir\" || { ac_status=$?; continue; }\n    # Check for configure.gnu first; this name is used for a wrapper for\n    # Metaconfig's \"Configure\" on case-insensitive file systems.\n    if test -f \"$ac_srcdir/configure.gnu\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure.gnu\" --help=recursive\n    elif test -f \"$ac_srcdir/configure\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure\" --help=recursive\n    else\n      printf \"%s\\n\" \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n    fi || ac_status=$?\n    cd \"$ac_pwd\" || { ac_status=$?; break; }\n  done\nfi\n\ntest -n \"$ac_init_help\" && exit $ac_status\nif $ac_init_version; then\n  cat <<\\_ACEOF\nsysstat configure 12.7.7\ngenerated by GNU Autoconf 2.71\n\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis configure script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\n_ACEOF\n  exit\nfi\n\n## ------------------------ ##\n## Autoconf initialization. ##\n## ------------------------ ##\n\n# ac_fn_c_try_compile LINENO\n# --------------------------\n# Try to compile conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext conftest.beam\n  if { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest.$ac_objext\nthen :\n  ac_retval=0\nelse $as_nop\n  printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1\nfi\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_compile\n\n# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES\n# -------------------------------------------------------\n# Tests whether HEADER exists and can be compiled using the include files in\n# INCLUDES, setting the cache variable VAR accordingly.\nac_fn_c_check_header_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\n#include <$2>\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  eval \"$3=yes\"\nelse $as_nop\n  eval \"$3=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_header_compile\n\n# ac_fn_c_check_type LINENO TYPE VAR INCLUDES\n# -------------------------------------------\n# Tests whether TYPE exists after having included INCLUDES, setting cache\n# variable VAR accordingly.\nac_fn_c_check_type ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  eval \"$3=no\"\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\nint\nmain (void)\n{\nif (sizeof ($2))\n\t return 0;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\nint\nmain (void)\n{\nif (sizeof (($2)))\n\t    return 0;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse $as_nop\n  eval \"$3=yes\"\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_type\n\n# ac_fn_c_try_link LINENO\n# -----------------------\n# Try to link conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_link ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext conftest.beam conftest$ac_exeext\n  if { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest$ac_exeext && {\n\t test \"$cross_compiling\" = yes ||\n\t test -x conftest$ac_exeext\n       }\nthen :\n  ac_retval=0\nelse $as_nop\n  printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1\nfi\n  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information\n  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would\n  # interfere with the next link command; also delete a directory that is\n  # left behind by Apple's compiler.  We do this before executing the actions.\n  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_link\n\n# ac_fn_c_check_func LINENO FUNC VAR\n# ----------------------------------\n# Tests whether FUNC exists, setting the cache variable VAR accordingly\nac_fn_c_check_func ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n/* Define $2 to an innocuous variant, in case <limits.h> declares $2.\n   For example, HP-UX 11i <limits.h> declares gettimeofday.  */\n#define $2 innocuous_$2\n\n/* System header to define __stub macros and hopefully few prototypes,\n   which can conflict with char $2 (); below.  */\n\n#include <limits.h>\n#undef $2\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar $2 ();\n/* The GNU C library defines this for functions which it implements\n    to always fail with ENOSYS.  Some functions are actually named\n    something starting with __ and the normal name is an alias.  */\n#if defined __stub_$2 || defined __stub___$2\nchoke me\n#endif\n\nint\nmain (void)\n{\nreturn $2 ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  eval \"$3=yes\"\nelse $as_nop\n  eval \"$3=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_func\nac_configure_args_raw=\nfor ac_arg\ndo\n  case $ac_arg in\n  *\\'*)\n    ac_arg=`printf \"%s\\n\" \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n  esac\n  as_fn_append ac_configure_args_raw \" '$ac_arg'\"\ndone\n\ncase $ac_configure_args_raw in\n  *$as_nl*)\n    ac_safe_unquote= ;;\n  *)\n    ac_unsafe_z='|&;<>()$`\\\\\"*?[ ''\t' # This string ends in space, tab.\n    ac_unsafe_a=\"$ac_unsafe_z#~\"\n    ac_safe_unquote=\"s/ '\\\\([^$ac_unsafe_a][^$ac_unsafe_z]*\\\\)'/ \\\\1/g\"\n    ac_configure_args_raw=`      printf \"%s\\n\" \"$ac_configure_args_raw\" | sed \"$ac_safe_unquote\"`;;\nesac\n\ncat >config.log <<_ACEOF\nThis file contains any messages produced by compilers while\nrunning configure, to aid debugging if configure makes a mistake.\n\nIt was created by sysstat $as_me 12.7.7, which was\ngenerated by GNU Autoconf 2.71.  Invocation command line was\n\n  $ $0$ac_configure_args_raw\n\n_ACEOF\nexec 5>>config.log\n{\ncat <<_ASUNAME\n## --------- ##\n## Platform. ##\n## --------- ##\n\nhostname = `(hostname || uname -n) 2>/dev/null | sed 1q`\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`\n\n/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`\n/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`\n/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`\n/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`\n\n_ASUNAME\n\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    printf \"%s\\n\" \"PATH: $as_dir\"\n  done\nIFS=$as_save_IFS\n\n} >&5\n\ncat >&5 <<_ACEOF\n\n\n## ----------- ##\n## Core tests. ##\n## ----------- ##\n\n_ACEOF\n\n\n# Keep a trace of the command line.\n# Strip out --no-create and --no-recursion so they do not pile up.\n# Strip out --silent because we don't want to record it for future runs.\n# Also quote any args containing shell meta-characters.\n# Make two passes to allow for proper duplicate-argument suppression.\nac_configure_args=\nac_configure_args0=\nac_configure_args1=\nac_must_keep_next=false\nfor ac_pass in 1 2\ndo\n  for ac_arg\n  do\n    case $ac_arg in\n    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;\n    -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n    | -silent | --silent | --silen | --sile | --sil)\n      continue ;;\n    *\\'*)\n      ac_arg=`printf \"%s\\n\" \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    case $ac_pass in\n    1) as_fn_append ac_configure_args0 \" '$ac_arg'\" ;;\n    2)\n      as_fn_append ac_configure_args1 \" '$ac_arg'\"\n      if test $ac_must_keep_next = true; then\n\tac_must_keep_next=false # Got value, back to normal.\n      else\n\tcase $ac_arg in\n\t  *=* | --config-cache | -C | -disable-* | --disable-* \\\n\t  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \\\n\t  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \\\n\t  | -with-* | --with-* | -without-* | --without-* | --x)\n\t    case \"$ac_configure_args0 \" in\n\t      \"$ac_configure_args1\"*\" '$ac_arg' \"* ) continue ;;\n\t    esac\n\t    ;;\n\t  -* ) ac_must_keep_next=true ;;\n\tesac\n      fi\n      as_fn_append ac_configure_args \" '$ac_arg'\"\n      ;;\n    esac\n  done\ndone\n{ ac_configure_args0=; unset ac_configure_args0;}\n{ ac_configure_args1=; unset ac_configure_args1;}\n\n# When interrupted or exit'd, cleanup temporary files, and complete\n# config.log.  We remove comments because anyway the quotes in there\n# would cause problems or look ugly.\n# WARNING: Use '\\'' to represent an apostrophe within the trap.\n# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.\ntrap 'exit_status=$?\n  # Sanitize IFS.\n  IFS=\" \"\"\t$as_nl\"\n  # Save into config.log some information that might help in debugging.\n  {\n    echo\n\n    printf \"%s\\n\" \"## ---------------- ##\n## Cache variables. ##\n## ---------------- ##\"\n    echo\n    # The following way of writing the cache mishandles newlines in values,\n(\n  for ac_var in `(set) 2>&1 | sed -n '\\''s/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'\\''`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n  (set) 2>&1 |\n    case $as_nl`(ac_space='\\'' '\\''; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      sed -n \\\n\t\"s/'\\''/'\\''\\\\\\\\'\\'''\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\''\\\\2'\\''/p\"\n      ;; #(\n    *)\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n)\n    echo\n\n    printf \"%s\\n\" \"## ----------------- ##\n## Output variables. ##\n## ----------------- ##\"\n    echo\n    for ac_var in $ac_subst_vars\n    do\n      eval ac_val=\\$$ac_var\n      case $ac_val in\n      *\\'\\''*) ac_val=`printf \"%s\\n\" \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n      esac\n      printf \"%s\\n\" \"$ac_var='\\''$ac_val'\\''\"\n    done | sort\n    echo\n\n    if test -n \"$ac_subst_files\"; then\n      printf \"%s\\n\" \"## ------------------- ##\n## File substitutions. ##\n## ------------------- ##\"\n      echo\n      for ac_var in $ac_subst_files\n      do\n\teval ac_val=\\$$ac_var\n\tcase $ac_val in\n\t*\\'\\''*) ac_val=`printf \"%s\\n\" \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n\tesac\n\tprintf \"%s\\n\" \"$ac_var='\\''$ac_val'\\''\"\n      done | sort\n      echo\n    fi\n\n    if test -s confdefs.h; then\n      printf \"%s\\n\" \"## ----------- ##\n## confdefs.h. ##\n## ----------- ##\"\n      echo\n      cat confdefs.h\n      echo\n    fi\n    test \"$ac_signal\" != 0 &&\n      printf \"%s\\n\" \"$as_me: caught signal $ac_signal\"\n    printf \"%s\\n\" \"$as_me: exit $exit_status\"\n  } >&5\n  rm -f core *.core core.conftest.* &&\n    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&\n    exit $exit_status\n' 0\nfor ac_signal in 1 2 13 15; do\n  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal\ndone\nac_signal=0\n\n# confdefs.h avoids OS command line length limits that DEFS can exceed.\nrm -f -r conftest* confdefs.h\n\nprintf \"%s\\n\" \"/* confdefs.h */\" > confdefs.h\n\n# Predefined preprocessor variables.\n\nprintf \"%s\\n\" \"#define PACKAGE_NAME \\\"$PACKAGE_NAME\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_TARNAME \\\"$PACKAGE_TARNAME\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_VERSION \\\"$PACKAGE_VERSION\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_STRING \\\"$PACKAGE_STRING\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_BUGREPORT \\\"$PACKAGE_BUGREPORT\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_URL \\\"$PACKAGE_URL\\\"\" >>confdefs.h\n\n\n# Let the site file select an alternate cache file if it wants to.\n# Prefer an explicitly selected file to automatically selected ones.\nif test -n \"$CONFIG_SITE\"; then\n  ac_site_files=\"$CONFIG_SITE\"\nelif test \"x$prefix\" != xNONE; then\n  ac_site_files=\"$prefix/share/config.site $prefix/etc/config.site\"\nelse\n  ac_site_files=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\nfi\n\nfor ac_site_file in $ac_site_files\ndo\n  case $ac_site_file in #(\n  */*) :\n     ;; #(\n  *) :\n    ac_site_file=./$ac_site_file ;;\nesac\n  if test -f \"$ac_site_file\" && test -r \"$ac_site_file\"; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file\" >&5\nprintf \"%s\\n\" \"$as_me: loading site script $ac_site_file\" >&6;}\n    sed 's/^/| /' \"$ac_site_file\" >&5\n    . \"$ac_site_file\" \\\n      || { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"failed to load site script $ac_site_file\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n  fi\ndone\n\nif test -r \"$cache_file\"; then\n  # Some versions of bash will fail to source /dev/null (special files\n  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.\n  if test /dev/null != \"$cache_file\" && test -f \"$cache_file\"; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: loading cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: loading cache $cache_file\" >&6;}\n    case $cache_file in\n      [\\\\/]* | ?:[\\\\/]* ) . \"$cache_file\";;\n      *)                      . \"./$cache_file\";;\n    esac\n  fi\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: creating cache $cache_file\" >&6;}\n  >$cache_file\nfi\n\n# Test code for whether the C compiler supports C89 (global declarations)\nac_c_conftest_c89_globals='\n/* Does the compiler advertise C89 conformance?\n   Do not test the value of __STDC__, because some compilers set it to 0\n   while being otherwise adequately conformant. */\n#if !defined __STDC__\n# error \"Compiler does not advertise C89 conformance\"\n#endif\n\n#include <stddef.h>\n#include <stdarg.h>\nstruct stat;\n/* Most of the following tests are stolen from RCS 5.7 src/conf.sh.  */\nstruct buf { int x; };\nstruct buf * (*rcsopen) (struct buf *, struct stat *, int);\nstatic char *e (p, i)\n     char **p;\n     int i;\n{\n  return p[i];\n}\nstatic char *f (char * (*g) (char **, int), char **p, ...)\n{\n  char *s;\n  va_list v;\n  va_start (v,p);\n  s = g (p, va_arg (v,int));\n  va_end (v);\n  return s;\n}\n\n/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has\n   function prototypes and stuff, but not \\xHH hex character constants.\n   These do not provoke an error unfortunately, instead are silently treated\n   as an \"x\".  The following induces an error, until -std is added to get\n   proper ANSI mode.  Curiously \\x00 != x always comes out true, for an\n   array size at least.  It is necessary to write \\x00 == 0 to get something\n   that is true only with -std.  */\nint osf4_cc_array ['\\''\\x00'\\'' == 0 ? 1 : -1];\n\n/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters\n   inside strings and character constants.  */\n#define FOO(x) '\\''x'\\''\nint xlc6_cc_array[FOO(a) == '\\''x'\\'' ? 1 : -1];\n\nint test (int i, double x);\nstruct s1 {int (*f) (int a);};\nstruct s2 {int (*f) (double a);};\nint pairnames (int, char **, int *(*)(struct buf *, struct stat *, int),\n               int, int);'\n\n# Test code for whether the C compiler supports C89 (body of main).\nac_c_conftest_c89_main='\nok |= (argc == 0 || f (e, argv, 0) != argv[0] || f (e, argv, 1) != argv[1]);\n'\n\n# Test code for whether the C compiler supports C99 (global declarations)\nac_c_conftest_c99_globals='\n// Does the compiler advertise C99 conformance?\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L\n# error \"Compiler does not advertise C99 conformance\"\n#endif\n\n#include <stdbool.h>\nextern int puts (const char *);\nextern int printf (const char *, ...);\nextern int dprintf (int, const char *, ...);\nextern void *malloc (size_t);\n\n// Check varargs macros.  These examples are taken from C99 6.10.3.5.\n// dprintf is used instead of fprintf to avoid needing to declare\n// FILE and stderr.\n#define debug(...) dprintf (2, __VA_ARGS__)\n#define showlist(...) puts (#__VA_ARGS__)\n#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))\nstatic void\ntest_varargs_macros (void)\n{\n  int x = 1234;\n  int y = 5678;\n  debug (\"Flag\");\n  debug (\"X = %d\\n\", x);\n  showlist (The first, second, and third items.);\n  report (x>y, \"x is %d but y is %d\", x, y);\n}\n\n// Check long long types.\n#define BIG64 18446744073709551615ull\n#define BIG32 4294967295ul\n#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)\n#if !BIG_OK\n  #error \"your preprocessor is broken\"\n#endif\n#if BIG_OK\n#else\n  #error \"your preprocessor is broken\"\n#endif\nstatic long long int bignum = -9223372036854775807LL;\nstatic unsigned long long int ubignum = BIG64;\n\nstruct incomplete_array\n{\n  int datasize;\n  double data[];\n};\n\nstruct named_init {\n  int number;\n  const wchar_t *name;\n  double average;\n};\n\ntypedef const char *ccp;\n\nstatic inline int\ntest_restrict (ccp restrict text)\n{\n  // See if C++-style comments work.\n  // Iterate through items via the restricted pointer.\n  // Also check for declarations in for loops.\n  for (unsigned int i = 0; *(text+i) != '\\''\\0'\\''; ++i)\n    continue;\n  return 0;\n}\n\n// Check varargs and va_copy.\nstatic bool\ntest_varargs (const char *format, ...)\n{\n  va_list args;\n  va_start (args, format);\n  va_list args_copy;\n  va_copy (args_copy, args);\n\n  const char *str = \"\";\n  int number = 0;\n  float fnumber = 0;\n\n  while (*format)\n    {\n      switch (*format++)\n\t{\n\tcase '\\''s'\\'': // string\n\t  str = va_arg (args_copy, const char *);\n\t  break;\n\tcase '\\''d'\\'': // int\n\t  number = va_arg (args_copy, int);\n\t  break;\n\tcase '\\''f'\\'': // float\n\t  fnumber = va_arg (args_copy, double);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n  va_end (args_copy);\n  va_end (args);\n\n  return *str && number && fnumber;\n}\n'\n\n# Test code for whether the C compiler supports C99 (body of main).\nac_c_conftest_c99_main='\n  // Check bool.\n  _Bool success = false;\n  success |= (argc != 0);\n\n  // Check restrict.\n  if (test_restrict (\"String literal\") == 0)\n    success = true;\n  char *restrict newvar = \"Another string\";\n\n  // Check varargs.\n  success &= test_varargs (\"s, d'\\'' f .\", \"string\", 65, 34.234);\n  test_varargs_macros ();\n\n  // Check flexible array members.\n  struct incomplete_array *ia =\n    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));\n  ia->datasize = 10;\n  for (int i = 0; i < ia->datasize; ++i)\n    ia->data[i] = i * 1.234;\n\n  // Check named initializers.\n  struct named_init ni = {\n    .number = 34,\n    .name = L\"Test wide string\",\n    .average = 543.34343,\n  };\n\n  ni.number = 58;\n\n  int dynamic_array[ni.number];\n  dynamic_array[0] = argv[0][0];\n  dynamic_array[ni.number - 1] = 543;\n\n  // work around unused variable warnings\n  ok |= (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == '\\''x'\\''\n\t || dynamic_array[ni.number - 1] != 543);\n'\n\n# Test code for whether the C compiler supports C11 (global declarations)\nac_c_conftest_c11_globals='\n// Does the compiler advertise C11 conformance?\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L\n# error \"Compiler does not advertise C11 conformance\"\n#endif\n\n// Check _Alignas.\nchar _Alignas (double) aligned_as_double;\nchar _Alignas (0) no_special_alignment;\nextern char aligned_as_int;\nchar _Alignas (0) _Alignas (int) aligned_as_int;\n\n// Check _Alignof.\nenum\n{\n  int_alignment = _Alignof (int),\n  int_array_alignment = _Alignof (int[100]),\n  char_alignment = _Alignof (char)\n};\n_Static_assert (0 < -_Alignof (int), \"_Alignof is signed\");\n\n// Check _Noreturn.\nint _Noreturn does_not_return (void) { for (;;) continue; }\n\n// Check _Static_assert.\nstruct test_static_assert\n{\n  int x;\n  _Static_assert (sizeof (int) <= sizeof (long int),\n                  \"_Static_assert does not work in struct\");\n  long int y;\n};\n\n// Check UTF-8 literals.\n#define u8 syntax error!\nchar const utf8_literal[] = u8\"happens to be ASCII\" \"another string\";\n\n// Check duplicate typedefs.\ntypedef long *long_ptr;\ntypedef long int *long_ptr;\ntypedef long_ptr long_ptr;\n\n// Anonymous structures and unions -- taken from C11 6.7.2.1 Example 1.\nstruct anonymous\n{\n  union {\n    struct { int i; int j; };\n    struct { int k; long int l; } w;\n  };\n  int m;\n} v1;\n'\n\n# Test code for whether the C compiler supports C11 (body of main).\nac_c_conftest_c11_main='\n  _Static_assert ((offsetof (struct anonymous, i)\n\t\t   == offsetof (struct anonymous, w.k)),\n\t\t  \"Anonymous union alignment botch\");\n  v1.i = 2;\n  v1.w.k = 5;\n  ok |= v1.i != 5;\n'\n\n# Test code for whether the C compiler supports C11 (complete).\nac_c_conftest_c11_program=\"${ac_c_conftest_c89_globals}\n${ac_c_conftest_c99_globals}\n${ac_c_conftest_c11_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  ${ac_c_conftest_c99_main}\n  ${ac_c_conftest_c11_main}\n  return ok;\n}\n\"\n\n# Test code for whether the C compiler supports C99 (complete).\nac_c_conftest_c99_program=\"${ac_c_conftest_c89_globals}\n${ac_c_conftest_c99_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  ${ac_c_conftest_c99_main}\n  return ok;\n}\n\"\n\n# Test code for whether the C compiler supports C89 (complete).\nac_c_conftest_c89_program=\"${ac_c_conftest_c89_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  return ok;\n}\n\"\n\nas_fn_append ac_header_c_list \" stdio.h stdio_h HAVE_STDIO_H\"\nas_fn_append ac_header_c_list \" stdlib.h stdlib_h HAVE_STDLIB_H\"\nas_fn_append ac_header_c_list \" string.h string_h HAVE_STRING_H\"\nas_fn_append ac_header_c_list \" inttypes.h inttypes_h HAVE_INTTYPES_H\"\nas_fn_append ac_header_c_list \" stdint.h stdint_h HAVE_STDINT_H\"\nas_fn_append ac_header_c_list \" strings.h strings_h HAVE_STRINGS_H\"\nas_fn_append ac_header_c_list \" sys/stat.h sys_stat_h HAVE_SYS_STAT_H\"\nas_fn_append ac_header_c_list \" sys/types.h sys_types_h HAVE_SYS_TYPES_H\"\nas_fn_append ac_header_c_list \" unistd.h unistd_h HAVE_UNISTD_H\"\nas_fn_append ac_header_c_list \" wchar.h wchar_h HAVE_WCHAR_H\"\nas_fn_append ac_header_c_list \" minix/config.h minix_config_h HAVE_MINIX_CONFIG_H\"\n# Check that the precious variables saved in the cache have kept the same\n# value.\nac_cache_corrupted=false\nfor ac_var in $ac_precious_vars; do\n  eval ac_old_set=\\$ac_cv_env_${ac_var}_set\n  eval ac_new_set=\\$ac_env_${ac_var}_set\n  eval ac_old_val=\\$ac_cv_env_${ac_var}_value\n  eval ac_new_val=\\$ac_env_${ac_var}_value\n  case $ac_old_set,$ac_new_set in\n    set,)\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&5\nprintf \"%s\\n\" \"$as_me: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,set)\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was not set in the previous run\" >&5\nprintf \"%s\\n\" \"$as_me: error: \\`$ac_var' was not set in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,);;\n    *)\n      if test \"x$ac_old_val\" != \"x$ac_new_val\"; then\n\t# differences in whitespace do not lead to failure.\n\tac_old_val_w=`echo x $ac_old_val`\n\tac_new_val_w=`echo x $ac_new_val`\n\tif test \"$ac_old_val_w\" != \"$ac_new_val_w\"; then\n\t  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' has changed since the previous run:\" >&5\nprintf \"%s\\n\" \"$as_me: error: \\`$ac_var' has changed since the previous run:\" >&2;}\n\t  ac_cache_corrupted=:\n\telse\n\t  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&5\nprintf \"%s\\n\" \"$as_me: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&2;}\n\t  eval $ac_var=\\$ac_old_val\n\tfi\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   former value:  \\`$ac_old_val'\" >&5\nprintf \"%s\\n\" \"$as_me:   former value:  \\`$ac_old_val'\" >&2;}\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   current value: \\`$ac_new_val'\" >&5\nprintf \"%s\\n\" \"$as_me:   current value: \\`$ac_new_val'\" >&2;}\n      fi;;\n  esac\n  # Pass precious variables to config.status.\n  if test \"$ac_new_set\" = set; then\n    case $ac_new_val in\n    *\\'*) ac_arg=$ac_var=`printf \"%s\\n\" \"$ac_new_val\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    *) ac_arg=$ac_var=$ac_new_val ;;\n    esac\n    case \" $ac_configure_args \" in\n      *\" '$ac_arg' \"*) ;; # Avoid dups.  Use of quotes ensures accuracy.\n      *) as_fn_append ac_configure_args \" '$ac_arg'\" ;;\n    esac\n  fi\ndone\nif $ac_cache_corrupted; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build\" >&5\nprintf \"%s\\n\" \"$as_me: error: changes in the environment can compromise the build\" >&2;}\n  as_fn_error $? \"run \\`${MAKE-make} distclean' and/or \\`rm $cache_file'\n\t    and start over\" \"$LINENO\" 5\nfi\n## -------------------- ##\n## Main body of script. ##\n## -------------------- ##\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n\n# Ensure that a recent enough version of Autoconf is being used\n\n\n# Check whether the configure script is in the right dir\n\n\n# Check programs\necho .\necho Check programs:\necho .\n\n\n\n\n\n\n\n\n\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\nif test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}gcc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"gcc\", so it can be a program name with args.\nset dummy gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nif test -z \"$CC\"; then\n          if test -n \"$ac_tool_prefix\"; then\n    # Extract the first word of \"${ac_tool_prefix}cc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  fi\nfi\nif test -z \"$CC\"; then\n  # Extract the first word of \"cc\", so it can be a program name with args.\nset dummy cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\n  ac_prog_rejected=no\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    if test \"$as_dir$ac_word$ac_exec_ext\" = \"/usr/ucb/cc\"; then\n       ac_prog_rejected=yes\n       continue\n     fi\n    ac_cv_prog_CC=\"cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nif test $ac_prog_rejected = yes; then\n  # We found a bogon in the path, so make sure we never use it.\n  set dummy $ac_cv_prog_CC\n  shift\n  if test $# != 0; then\n    # We chose a different compiler from the bogus one.\n    # However, it has the same basename, so the bogon will be chosen\n    # first if we set CC to just the basename; use the full file name.\n    shift\n    ac_cv_prog_CC=\"$as_dir$ac_word${1+' '}$@\"\n  fi\nfi\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  for ac_prog in cl.exe\n  do\n    # Extract the first word of \"$ac_tool_prefix$ac_prog\", so it can be a program name with args.\nset dummy $ac_tool_prefix$ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"$ac_tool_prefix$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n    test -n \"$CC\" && break\n  done\nfi\nif test -z \"$CC\"; then\n  ac_ct_CC=$CC\n  for ac_prog in cl.exe\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$ac_ct_CC\" && break\ndone\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nfi\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}clang\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"clang\", so it can be a program name with args.\nset dummy clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nfi\n\n\ntest -z \"$CC\" && { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"no acceptable C compiler found in \\$PATH\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n\n# Provide some information about the compiler.\nprintf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler version\" >&5\nset X $ac_compile\nac_compiler=$2\nfor ac_option in --version -v -V -qversion -version; do\n  { { ac_try=\"$ac_compiler $ac_option >&5\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compiler $ac_option >&5\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    sed '10a\\\n... rest of stderr output deleted ...\n         10q' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n  fi\n  rm -f conftest.er1 conftest.err\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\ndone\n\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files a.out a.out.dSYM a.exe b.out\"\n# Try to create an executable without -o first, disregard a.out.\n# It will help us diagnose broken compilers, and finding out an intuition\n# of exeext.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the C compiler works\" >&5\nprintf %s \"checking whether the C compiler works... \" >&6; }\nac_link_default=`printf \"%s\\n\" \"$ac_link\" | sed 's/ -o *conftest[^ ]*//'`\n\n# The possible output files:\nac_files=\"a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*\"\n\nac_rmfiles=\nfor ac_file in $ac_files\ndo\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    * ) ac_rmfiles=\"$ac_rmfiles $ac_file\";;\n  esac\ndone\nrm -f $ac_rmfiles\n\nif { { ac_try=\"$ac_link_default\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link_default\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.\n# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'\n# in a Makefile.  We should not override ac_cv_exeext if it was cached,\n# so that the user can short-circuit this test for compilers unknown to\n# Autoconf.\nfor ac_file in $ac_files ''\ndo\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )\n\t;;\n    [ab].out )\n\t# We found the default executable, but exeext='' is most\n\t# certainly right.\n\tbreak;;\n    *.* )\n\tif test ${ac_cv_exeext+y} && test \"$ac_cv_exeext\" != no;\n\tthen :; else\n\t   ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\tfi\n\t# We set ac_cv_exeext here because the later test for it is not\n\t# safe: cross compilers may not add the suffix if given an `-o'\n\t# argument, so we may need to know it at that point already.\n\t# Even if this section looks crufty: it has the advantage of\n\t# actually working.\n\tbreak;;\n    * )\n\tbreak;;\n  esac\ndone\ntest \"$ac_cv_exeext\" = no && ac_cv_exeext=\n\nelse $as_nop\n  ac_file=''\nfi\nif test -z \"$ac_file\"\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nprintf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error 77 \"C compiler cannot create executables\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; }\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name\" >&5\nprintf %s \"checking for C compiler default output file name... \" >&6; }\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_file\" >&5\nprintf \"%s\\n\" \"$ac_file\" >&6; }\nac_exeext=$ac_cv_exeext\n\nrm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out\nac_clean_files=$ac_clean_files_save\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for suffix of executables\" >&5\nprintf %s \"checking for suffix of executables... \" >&6; }\nif { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  # If both `conftest.exe' and `conftest' are `present' (well, observable)\n# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will\n# work properly (i.e., refer to `conftest.exe'), while it won't with\n# `rm'.\nfor ac_file in conftest.exe conftest conftest.*; do\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    *.* ) ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\t  break;;\n    * ) break;;\n  esac\ndone\nelse $as_nop\n  { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of executables: cannot compile and link\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\nrm -f conftest conftest$ac_cv_exeext\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext\" >&5\nprintf \"%s\\n\" \"$ac_cv_exeext\" >&6; }\n\nrm -f conftest.$ac_ext\nEXEEXT=$ac_cv_exeext\nac_exeext=$EXEEXT\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdio.h>\nint\nmain (void)\n{\nFILE *f = fopen (\"conftest.out\", \"w\");\n return ferror (f) || fclose (f) != 0;\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files=\"$ac_clean_files conftest.out\"\n# Check that the compiler produces executables we can run.  If not, either\n# the compiler is broken, or we cross compile.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling\" >&5\nprintf %s \"checking whether we are cross compiling... \" >&6; }\nif test \"$cross_compiling\" != yes; then\n  { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\n  if { ac_try='./conftest$ac_cv_exeext'\n  { { case \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_try\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; }; then\n    cross_compiling=no\n  else\n    if test \"$cross_compiling\" = maybe; then\n\tcross_compiling=yes\n    else\n\t{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error 77 \"cannot run C compiled programs.\nIf you meant to cross compile, use \\`--host'.\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n    fi\n  fi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $cross_compiling\" >&5\nprintf \"%s\\n\" \"$cross_compiling\" >&6; }\n\nrm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out\nac_clean_files=$ac_clean_files_save\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for suffix of object files\" >&5\nprintf %s \"checking for suffix of object files... \" >&6; }\nif test ${ac_cv_objext+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nrm -f conftest.o conftest.obj\nif { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  for ac_file in conftest.o conftest.obj conftest.*; do\n  test -f \"$ac_file\" || continue;\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;\n    *) ac_cv_objext=`expr \"$ac_file\" : '.*\\.\\(.*\\)'`\n       break;;\n  esac\ndone\nelse $as_nop\n  printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of object files: cannot compile\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\nrm -f conftest.$ac_cv_objext conftest.$ac_ext\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext\" >&5\nprintf \"%s\\n\" \"$ac_cv_objext\" >&6; }\nOBJEXT=$ac_cv_objext\nac_objext=$OBJEXT\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C\" >&5\nprintf %s \"checking whether the compiler supports GNU C... \" >&6; }\nif test ${ac_cv_c_compiler_gnu+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n#ifndef __GNUC__\n       choke me\n#endif\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_compiler_gnu=yes\nelse $as_nop\n  ac_compiler_gnu=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nac_cv_c_compiler_gnu=$ac_compiler_gnu\n\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu\" >&5\nprintf \"%s\\n\" \"$ac_cv_c_compiler_gnu\" >&6; }\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\nif test $ac_compiler_gnu = yes; then\n  GCC=yes\nelse\n  GCC=\nfi\nac_test_CFLAGS=${CFLAGS+y}\nac_save_CFLAGS=$CFLAGS\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g\" >&5\nprintf %s \"checking whether $CC accepts -g... \" >&6; }\nif test ${ac_cv_prog_cc_g+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_save_c_werror_flag=$ac_c_werror_flag\n   ac_c_werror_flag=yes\n   ac_cv_prog_cc_g=no\n   CFLAGS=\"-g\"\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nelse $as_nop\n  CFLAGS=\"\"\n      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse $as_nop\n  ac_c_werror_flag=$ac_save_c_werror_flag\n\t CFLAGS=\"-g\"\n\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n   ac_c_werror_flag=$ac_save_c_werror_flag\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_g\" >&6; }\nif test $ac_test_CFLAGS; then\n  CFLAGS=$ac_save_CFLAGS\nelif test $ac_cv_prog_cc_g = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-g -O2\"\n  else\n    CFLAGS=\"-g\"\n  fi\nelse\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-O2\"\n  else\n    CFLAGS=\n  fi\nfi\nac_prog_cc_stdc=no\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features\" >&5\nprintf %s \"checking for $CC option to enable C11 features... \" >&6; }\nif test ${ac_cv_prog_cc_c11+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_prog_cc_c11=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c11_program\n_ACEOF\nfor ac_arg in '' -std=gnu11\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c11=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c11\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\nfi\n\nif test \"x$ac_cv_prog_cc_c11\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse $as_nop\n  if test \"x$ac_cv_prog_cc_c11\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c11\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c11\"\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11\n  ac_prog_cc_stdc=c11\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features\" >&5\nprintf %s \"checking for $CC option to enable C99 features... \" >&6; }\nif test ${ac_cv_prog_cc_c99+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_prog_cc_c99=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c99_program\n_ACEOF\nfor ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c99=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c99\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\nfi\n\nif test \"x$ac_cv_prog_cc_c99\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse $as_nop\n  if test \"x$ac_cv_prog_cc_c99\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c99\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c99\"\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99\n  ac_prog_cc_stdc=c99\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features\" >&5\nprintf %s \"checking for $CC option to enable C89 features... \" >&6; }\nif test ${ac_cv_prog_cc_c89+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_prog_cc_c89=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c89_program\n_ACEOF\nfor ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae \"-Aa -D_HPUX_SOURCE\" \"-Xc -D__EXTENSIONS__\"\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c89=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c89\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\nfi\n\nif test \"x$ac_cv_prog_cc_c89\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse $as_nop\n  if test \"x$ac_cv_prog_cc_c89\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c89\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c89\"\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89\n  ac_prog_cc_stdc=c89\nfi\nfi\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\nac_header= ac_cache=\nfor ac_item in $ac_header_c_list\ndo\n  if test $ac_cache; then\n    ac_fn_c_check_header_compile \"$LINENO\" $ac_header ac_cv_header_$ac_cache \"$ac_includes_default\"\n    if eval test \\\"x\\$ac_cv_header_$ac_cache\\\" = xyes; then\n      printf \"%s\\n\" \"#define $ac_item 1\" >> confdefs.h\n    fi\n    ac_header= ac_cache=\n  elif test $ac_header; then\n    ac_cache=$ac_item\n  else\n    ac_header=$ac_item\n  fi\ndone\n\n\n\n\n\n\n\n\nif test $ac_cv_header_stdlib_h = yes && test $ac_cv_header_string_h = yes\nthen :\n\nprintf \"%s\\n\" \"#define STDC_HEADERS 1\" >>confdefs.h\n\nfi\n\n\n\n\n\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether it is safe to define __EXTENSIONS__\" >&5\nprintf %s \"checking whether it is safe to define __EXTENSIONS__... \" >&6; }\nif test ${ac_cv_safe_to_define___extensions__+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n#         define __EXTENSIONS__ 1\n          $ac_includes_default\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_safe_to_define___extensions__=yes\nelse $as_nop\n  ac_cv_safe_to_define___extensions__=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_safe_to_define___extensions__\" >&5\nprintf \"%s\\n\" \"$ac_cv_safe_to_define___extensions__\" >&6; }\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether _XOPEN_SOURCE should be defined\" >&5\nprintf %s \"checking whether _XOPEN_SOURCE should be defined... \" >&6; }\nif test ${ac_cv_should_define__xopen_source+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_should_define__xopen_source=no\n    if test $ac_cv_header_wchar_h = yes\nthen :\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n          #include <wchar.h>\n          mbstate_t x;\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n            #define _XOPEN_SOURCE 500\n            #include <wchar.h>\n            mbstate_t x;\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_should_define__xopen_source=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_should_define__xopen_source\" >&5\nprintf \"%s\\n\" \"$ac_cv_should_define__xopen_source\" >&6; }\n\n  printf \"%s\\n\" \"#define _ALL_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _DARWIN_C_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _GNU_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _HPUX_ALT_XOPEN_SOCKET_API 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _NETBSD_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _OPENBSD_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _POSIX_PTHREAD_SEMANTICS 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_BFP_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_DFP_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_TYPES_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_LIB_EXT2__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_MATH_SPEC_FUNCS__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _TANDEM_SOURCE 1\" >>confdefs.h\n\n  if test $ac_cv_header_minix_config_h = yes\nthen :\n  MINIX=yes\n    printf \"%s\\n\" \"#define _MINIX 1\" >>confdefs.h\n\n    printf \"%s\\n\" \"#define _POSIX_SOURCE 1\" >>confdefs.h\n\n    printf \"%s\\n\" \"#define _POSIX_1_SOURCE 2\" >>confdefs.h\n\nelse $as_nop\n  MINIX=\nfi\n  if test $ac_cv_safe_to_define___extensions__ = yes\nthen :\n  printf \"%s\\n\" \"#define __EXTENSIONS__ 1\" >>confdefs.h\n\nfi\n  if test $ac_cv_should_define__xopen_source = yes\nthen :\n  printf \"%s\\n\" \"#define _XOPEN_SOURCE 500\" >>confdefs.h\n\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether ln -s works\" >&5\nprintf %s \"checking whether ln -s works... \" >&6; }\nLN_S=$as_ln_s\nif test \"$LN_S\" = \"ln -s\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no, using $LN_S\" >&5\nprintf \"%s\\n\" \"no, using $LN_S\" >&6; }\nfi\n\n\nDFLAGS=\"\"\n\n# Extract the first word of \"chmod\", so it can be a program name with args.\nset dummy chmod; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CHMOD+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CHMOD\"; then\n  ac_cv_prog_CHMOD=\"$CHMOD\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CHMOD=\"chmod\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCHMOD=$ac_cv_prog_CHMOD\nif test -n \"$CHMOD\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CHMOD\" >&5\nprintf \"%s\\n\" \"$CHMOD\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"chown\", so it can be a program name with args.\nset dummy chown; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CHOWN+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CHOWN\"; then\n  ac_cv_prog_CHOWN=\"$CHOWN\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CHOWN=\"chown\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCHOWN=$ac_cv_prog_CHOWN\nif test -n \"$CHOWN\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CHOWN\" >&5\nprintf \"%s\\n\" \"$CHOWN\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"ar\", so it can be a program name with args.\nset dummy ar; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_AR+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$AR\"; then\n  ac_cv_prog_AR=\"$AR\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_AR=\"ar\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nAR=$ac_cv_prog_AR\nif test -n \"$AR\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AR\" >&5\nprintf \"%s\\n\" \"$AR\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"install\", so it can be a program name with args.\nset dummy install; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_INSTALL+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$INSTALL\"; then\n  ac_cv_prog_INSTALL=\"$INSTALL\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_INSTALL=\"install\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nINSTALL=$ac_cv_prog_INSTALL\nif test -n \"$INSTALL\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $INSTALL\" >&5\nprintf \"%s\\n\" \"$INSTALL\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"msgfmt\", so it can be a program name with args.\nset dummy msgfmt; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_MSGFMT+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$MSGFMT\"; then\n  ac_cv_prog_MSGFMT=\"$MSGFMT\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_MSGFMT=\"msgfmt\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nMSGFMT=$ac_cv_prog_MSGFMT\nif test -n \"$MSGFMT\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $MSGFMT\" >&5\nprintf \"%s\\n\" \"$MSGFMT\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"xgettext\", so it can be a program name with args.\nset dummy xgettext; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_XGETTEXT+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$XGETTEXT\"; then\n  ac_cv_prog_XGETTEXT=\"$XGETTEXT\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_XGETTEXT=\"xgettext\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nXGETTEXT=$ac_cv_prog_XGETTEXT\nif test -n \"$XGETTEXT\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $XGETTEXT\" >&5\nprintf \"%s\\n\" \"$XGETTEXT\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"msgmerge\", so it can be a program name with args.\nset dummy msgmerge; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_MSGMERGE+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$MSGMERGE\"; then\n  ac_cv_prog_MSGMERGE=\"$MSGMERGE\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_MSGMERGE=\"msgmerge\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nMSGMERGE=$ac_cv_prog_MSGMERGE\nif test -n \"$MSGMERGE\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $MSGMERGE\" >&5\nprintf \"%s\\n\" \"$MSGMERGE\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"xmllint\", so it can be a program name with args.\nset dummy xmllint; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_VER_XML+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$VER_XML\"; then\n  ac_cv_prog_VER_XML=\"$VER_XML\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_VER_XML=\"xmllint\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nVER_XML=$ac_cv_prog_VER_XML\nif test -n \"$VER_XML\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $VER_XML\" >&5\nprintf \"%s\\n\" \"$VER_XML\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfor ac_prog in json_verify json_pp\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_VER_JSON+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$VER_JSON\"; then\n  ac_cv_prog_VER_JSON=\"$VER_JSON\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_VER_JSON=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nVER_JSON=$ac_cv_prog_VER_JSON\nif test -n \"$VER_JSON\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $VER_JSON\" >&5\nprintf \"%s\\n\" \"$VER_JSON\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$VER_JSON\" && break\ndone\ntest -n \"$VER_JSON\" || VER_JSON=\"true\"\n\nfor ac_prog in xz bzip2 gzip\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ZIP+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ZIP\"; then\n  ac_cv_prog_ZIP=\"$ZIP\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ZIP=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nZIP=$ac_cv_prog_ZIP\nif test -n \"$ZIP\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ZIP\" >&5\nprintf \"%s\\n\" \"$ZIP\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$ZIP\" && break\ndone\ntest -n \"$ZIP\" || ZIP=\"gzip\"\n\nINSTALL_DATA=\"\\${INSTALL} -m 644\"\n\nINSTALL_BIN=\"\\${INSTALL} -m 755\"\n\n\n\n\n\n# Extract the first word of \"cp\", so it can be a program name with args.\nset dummy cp; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_path_PATH_CP+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  case $PATH_CP in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_PATH_CP=\"$PATH_CP\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_path_PATH_CP=\"$as_dir$ac_word$ac_exec_ext\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nPATH_CP=$ac_cv_path_PATH_CP\nif test -n \"$PATH_CP\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $PATH_CP\" >&5\nprintf \"%s\\n\" \"$PATH_CP\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"chkconfig\", so it can be a program name with args.\nset dummy chkconfig; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_path_PATH_CHKCONFIG+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  case $PATH_CHKCONFIG in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_PATH_CHKCONFIG=\"$PATH_CHKCONFIG\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_path_PATH_CHKCONFIG=\"$as_dir$ac_word$ac_exec_ext\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nPATH_CHKCONFIG=$ac_cv_path_PATH_CHKCONFIG\nif test -n \"$PATH_CHKCONFIG\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $PATH_CHKCONFIG\" >&5\nprintf \"%s\\n\" \"$PATH_CHKCONFIG\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n\n# Check for systemd\n# Extract the first word of \"pkg-config\", so it can be a program name with args.\nset dummy pkg-config; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_PKG_CONFIG+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$PKG_CONFIG\"; then\n  ac_cv_prog_PKG_CONFIG=\"$PKG_CONFIG\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_PKG_CONFIG=\"pkg-config\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nPKG_CONFIG=$ac_cv_prog_PKG_CONFIG\nif test -n \"$PKG_CONFIG\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG\" >&5\nprintf \"%s\\n\" \"$PKG_CONFIG\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"systemctl\", so it can be a program name with args.\nset dummy systemctl; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_path_SYSTEMCTL+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  case $SYSTEMCTL in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_SYSTEMCTL=\"$SYSTEMCTL\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_path_SYSTEMCTL=\"$as_dir$ac_word$ac_exec_ext\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nSYSTEMCTL=$ac_cv_path_SYSTEMCTL\nif test -n \"$SYSTEMCTL\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SYSTEMCTL\" >&5\nprintf \"%s\\n\" \"$SYSTEMCTL\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n\n# Check whether --with-systemdsystemunitdir was given.\nif test ${with_systemdsystemunitdir+y}\nthen :\n  withval=$with_systemdsystemunitdir;\nelse $as_nop\n  with_systemdsystemunitdir=$($PKG_CONFIG --variable=systemdsystemunitdir systemd)\nfi\n\nif test -n \"$with_systemdsystemunitdir\" -a \"x$with_systemdsystemunitdir\" != xno ; then\n    SYSTEMD_UNIT_DIR=$with_systemdsystemunitdir\n\nfi\n\n# Check whether --with-systemdsleepdir was given.\nif test ${with_systemdsleepdir+y}\nthen :\n  withval=$with_systemdsleepdir;\nelse $as_nop\n  with_systemdsleepdir=$($PKG_CONFIG --variable=systemdsleepdir systemd)\nfi\n\nif test -n \"$with_systemdsleepdir\" -a \"x$with_systemdsleepdir\" != xno ; then\n    SYSTEMD_SLEEP_DIR=$with_systemdsleepdir\n\nfi\n\n# Check libraries\n\n# Check header files\necho .\necho Check header files:\necho .\nHAVE_LIBINTL_H=\nHAVE_LOCALE_H=\nHAVE_SYS_SYSMACROS_H=\nHAVE_SYS_PARAM_H=\nac_fn_c_check_header_compile \"$LINENO\" \"ctype.h\" \"ac_cv_header_ctype_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_ctype_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_CTYPE_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"errno.h\" \"ac_cv_header_errno_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_errno_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_ERRNO_H 1\" >>confdefs.h\n\nfi\n\n       for ac_header in libintl.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"libintl.h\" \"ac_cv_header_libintl_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_libintl_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LIBINTL_H 1\" >>confdefs.h\n HAVE_LIBINTL_H=1\nfi\n\ndone\n       for ac_header in locale.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"locale.h\" \"ac_cv_header_locale_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_locale_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LOCALE_H 1\" >>confdefs.h\n HAVE_LOCALE_H=1\nfi\n\ndone\n       for ac_header in linux/sched.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"linux/sched.h\" \"ac_cv_header_linux_sched_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_linux_sched_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LINUX_SCHED_H 1\" >>confdefs.h\n HAVE_LINUX_SCHED_H=1\nfi\n\ndone\nac_fn_c_check_header_compile \"$LINENO\" \"net/if.h\" \"ac_cv_header_net_if_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_net_if_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_NET_IF_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"regex.h\" \"ac_cv_header_regex_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_regex_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_REGEX_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"signal.h\" \"ac_cv_header_signal_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_signal_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SIGNAL_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"stdio.h\" \"ac_cv_header_stdio_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_stdio_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STDIO_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"stdint.h\" \"ac_cv_header_stdint_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_stdint_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STDINT_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"fcntl.h\" \"ac_cv_header_fcntl_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_fcntl_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_FCNTL_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"inttypes.h\" \"ac_cv_header_inttypes_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_inttypes_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_INTTYPES_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"libgen.h\" \"ac_cv_header_libgen_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_libgen_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LIBGEN_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"pwd.h\" \"ac_cv_header_pwd_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_pwd_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_PWD_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"time.h\" \"ac_cv_header_time_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_time_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_TIME_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"unistd.h\" \"ac_cv_header_unistd_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_unistd_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_UNISTD_H 1\" >>confdefs.h\n\nfi\n\n       for ac_header in pcp/pmapi.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"pcp/pmapi.h\" \"ac_cv_header_pcp_pmapi_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_pcp_pmapi_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_PCP_PMAPI_H 1\" >>confdefs.h\n HAVE_PCP_PMAPI_H=1\nfi\n\ndone\n       for ac_header in pcp/impl.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"pcp/impl.h\" \"ac_cv_header_pcp_impl_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_pcp_impl_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_PCP_IMPL_H 1\" >>confdefs.h\n HAVE_PCP_IMPL_H=1\nfi\n\ndone\nac_fn_c_check_header_compile \"$LINENO\" \"sys/time.h\" \"ac_cv_header_sys_time_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_time_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_TIME_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"sys/statvfs.h\" \"ac_cv_header_sys_statvfs_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_statvfs_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_STATVFS_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"sys/types.h\" \"ac_cv_header_sys_types_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_types_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_TYPES_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"sys/file.h\" \"ac_cv_header_sys_file_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_file_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_FILE_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"sys/ioctl.h\" \"ac_cv_header_sys_ioctl_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_ioctl_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_IOCTL_H 1\" >>confdefs.h\n\nfi\n\n       for ac_header in sys/param.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"sys/param.h\" \"ac_cv_header_sys_param_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_param_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_PARAM_H 1\" >>confdefs.h\n HAVE_SYS_PARAM_H=1\nfi\n\ndone\nac_fn_c_check_header_compile \"$LINENO\" \"sys/stat.h\" \"ac_cv_header_sys_stat_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_stat_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_STAT_H 1\" >>confdefs.h\n\nfi\n\n       for ac_header in sys/sysmacros.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"sys/sysmacros.h\" \"ac_cv_header_sys_sysmacros_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_sysmacros_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_SYSMACROS_H 1\" >>confdefs.h\n HAVE_SYS_SYSMACROS_H=1\nfi\n\ndone\nac_fn_c_check_header_compile \"$LINENO\" \"sys/utsname.h\" \"ac_cv_header_sys_utsname_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_utsname_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_UTSNAME_H 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_header_compile \"$LINENO\" \"sys/wait.h\" \"ac_cv_header_sys_wait_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_wait_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_WAIT_H 1\" >>confdefs.h\n\nfi\n\n\necho .\necho Check typedefs, structures and compiler characteristics:\necho .\n\nprintf \"%s\\n\" \"#define RETSIGTYPE $ac_cv_type_signal\" >>confdefs.h\n\n\nac_fn_c_check_type \"$LINENO\" \"size_t\" \"ac_cv_type_size_t\" \"$ac_includes_default\"\nif test \"x$ac_cv_type_size_t\" = xyes\nthen :\n\nelse $as_nop\n\nprintf \"%s\\n\" \"#define size_t unsigned int\" >>confdefs.h\n\nfi\n\nac_fn_c_check_type \"$LINENO\" \"off_t\" \"ac_cv_type_off_t\" \"$ac_includes_default\"\nif test \"x$ac_cv_type_off_t\" = xyes\nthen :\n\nelse $as_nop\n\nprintf \"%s\\n\" \"#define off_t long int\" >>confdefs.h\n\nfi\n\n\necho .\necho Check library functions:\necho .\nac_fn_c_check_func \"$LINENO\" \"strchr\" \"ac_cv_func_strchr\"\nif test \"x$ac_cv_func_strchr\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRCHR 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_func \"$LINENO\" \"strcspn\" \"ac_cv_func_strcspn\"\nif test \"x$ac_cv_func_strcspn\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRCSPN 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_func \"$LINENO\" \"strspn\" \"ac_cv_func_strspn\"\nif test \"x$ac_cv_func_strspn\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRSPN 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_func \"$LINENO\" \"strstr\" \"ac_cv_func_strstr\"\nif test \"x$ac_cv_func_strstr\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRSTR 1\" >>confdefs.h\n\nfi\n\n\n# Should we check for PCP support?\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for PCP support\" >&5\nprintf %s \"checking for PCP support... \" >&6; }\n# Check whether --enable-pcp was given.\nif test ${enable_pcp+y}\nthen :\n  enableval=$enable_pcp; PCP=$enableval\nelse $as_nop\n  PCP=yes\nfi\n\nif test $PCP != \"yes\"; then\n\tHAVE_PCP=\"n\"\nelse\n\tHAVE_PCP=\"y\"\nfi\n\nif test ! $HAVE_PCP_PMAPI_H; then\n\tHAVE_PCP=\"n\"\n\tPCP=no\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $PCP\" >&5\nprintf \"%s\\n\" \"$PCP\" >&6; }\n\n# Check for PCP libraries\nLFPCP=\"\"\nDFPCP=\"\"\nif test $HAVE_PCP = \"y\"; then\n\tPCP=no\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for pmGetVersion in -lpcp\" >&5\nprintf %s \"checking for pmGetVersion in -lpcp... \" >&6; }\nif test ${ac_cv_lib_pcp_pmGetVersion+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lpcp  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\nchar pmGetVersion ();\nint\nmain (void)\n{\nreturn pmGetVersion ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  ac_cv_lib_pcp_pmGetVersion=yes\nelse $as_nop\n  ac_cv_lib_pcp_pmGetVersion=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcp_pmGetVersion\" >&5\nprintf \"%s\\n\" \"$ac_cv_lib_pcp_pmGetVersion\" >&6; }\nif test \"x$ac_cv_lib_pcp_pmGetVersion\" = xyes\nthen :\n  LFPCP=\"-lpcp -lpcp_import\"\nelse $as_nop\n  HAVE_PCP=\"n\"\nfi\n\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for PCP libraries\" >&5\nprintf %s \"checking for PCP libraries... \" >&6; }\n\tcat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <pcp/pmapi.h>\n\t\t\t\t\t     #include <pcp/import.h>\nint\nmain (void)\n{\npmiEnd();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  PCP=yes; DFPCP=\"-DHAVE_PCP\"\nelse $as_nop\n  HAVE_PCP=\"n\"; PCP=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $PCP\" >&5\nprintf \"%s\\n\" \"$PCP\" >&6; }\nfi\n\n\n\n\nif test $HAVE_PCP_IMPL_H; then\n   PCP_IMPL=\"y\"\nelse\n   PCP_IMPL=\"n\"\nfi\n\n\n# Should we check for lm_sensors?\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for sensors support\" >&5\nprintf %s \"checking for sensors support... \" >&6; }\n# Check whether --enable-sensors was given.\nif test ${enable_sensors+y}\nthen :\n  enableval=$enable_sensors; SENSORS=$enableval\nelse $as_nop\n  SENSORS=yes\nfi\n\nif test $SENSORS != \"yes\"; then\n\tSENSORS_SUPPORT=\"n\"\nelse\n\tSENSORS_SUPPORT=\"y\"\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SENSORS\" >&5\nprintf \"%s\\n\" \"$SENSORS\" >&6; }\n\n# Check for lm_sensors library\nLFSENSORS=\"\"\nDFSENSORS=\"\"\nHAVE_SENSORS=\"n\"\nif test $SENSORS_SUPPORT = \"y\"; then\n\tSENSORS=no\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for sensors_get_detected_chips in -lsensors\" >&5\nprintf %s \"checking for sensors_get_detected_chips in -lsensors... \" >&6; }\nif test ${ac_cv_lib_sensors_sensors_get_detected_chips+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lsensors  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\nchar sensors_get_detected_chips ();\nint\nmain (void)\n{\nreturn sensors_get_detected_chips ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  ac_cv_lib_sensors_sensors_get_detected_chips=yes\nelse $as_nop\n  ac_cv_lib_sensors_sensors_get_detected_chips=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sensors_sensors_get_detected_chips\" >&5\nprintf \"%s\\n\" \"$ac_cv_lib_sensors_sensors_get_detected_chips\" >&6; }\nif test \"x$ac_cv_lib_sensors_sensors_get_detected_chips\" = xyes\nthen :\n  LFSENSORS=\"-lsensors\"\nelse $as_nop\n  HAVE_SENSORS=\"n\"\nfi\n\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for sensors library\" >&5\nprintf %s \"checking for sensors library... \" >&6; }\n\tcat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <sensors/sensors.h>\n\t\t\t\t\t     #include <sensors/error.h>\nint\nmain (void)\n{\nsensors_cleanup();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  SENSORS=yes; HAVE_SENSORS=\"y\"; DFSENSORS=\"-DHAVE_SENSORS\"\nelse $as_nop\n  HAVE_SENSORS=\"n\"; SENSORS=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SENSORS\" >&5\nprintf \"%s\\n\" \"$SENSORS\" >&6; }\nfi\n\n\n\n\n# Check for 32-bit version of lm_sensors library\nLFSENSORS32=\"\"\nDFSENSORS32=\"\"\nHAVE_SENSORS32=\"n\"\nif test $SENSORS_SUPPORT = \"y\"; then\n\tCFLAGS_SAVE=$CFLAGS\n        # Was: CFLAGS+=\" -m32\" which is specific to bash and not sh\n\tCFLAGS=\"$CFLAGS -m32\"\n\tLDFLAGS_SAVE=$LDFLAGS\n\tLDFLAGS=\"$LDFLAGS -lsensors\"\n\tSENSORS=no\n#\tCheck for another function to avoid using cached result\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for sensors_cleanup in -lsensors\" >&5\nprintf %s \"checking for sensors_cleanup in -lsensors... \" >&6; }\nif test ${ac_cv_lib_sensors_sensors_cleanup+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lsensors  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\nchar sensors_cleanup ();\nint\nmain (void)\n{\nreturn sensors_cleanup ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  ac_cv_lib_sensors_sensors_cleanup=yes\nelse $as_nop\n  ac_cv_lib_sensors_sensors_cleanup=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sensors_sensors_cleanup\" >&5\nprintf \"%s\\n\" \"$ac_cv_lib_sensors_sensors_cleanup\" >&6; }\nif test \"x$ac_cv_lib_sensors_sensors_cleanup\" = xyes\nthen :\n  LFSENSORS32=\"-lsensors\"\nelse $as_nop\n  HAVE_SENSORS32=\"n\"\nfi\n\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for sensors 32-bit library\" >&5\nprintf %s \"checking for sensors 32-bit library... \" >&6; }\n\tcat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <sensors/sensors.h>\n\t\t\t\t\t  #include <sensors/error.h>\nint\nmain (void)\n{\nsensors_cleanup();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  SENSORS=yes; HAVE_SENSORS32=\"y\"; DFSENSORS32=\"-DHAVE_SENSORS32\"\nelse $as_nop\n  HAVE_SENSORS32=\"n\"; SENSORS=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SENSORS\" >&5\nprintf \"%s\\n\" \"$SENSORS\" >&6; }\n\tCFLAGS=$CFLAGS_SAVE\n\tLDFLAGS=$LDFLAGS_SAVE\nfi\n\n\n\n\n# Check for 32-bit system libraries\nTGLIB32=no\nCFLAGS_SAVE=$CFLAGS\nCFLAGS=\"$CFLAGS -m32\"\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for 32-bit system libraries\" >&5\nprintf %s \"checking for 32-bit system libraries... \" >&6; }\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdio.h>\nint\nmain (void)\n{\nprintf(\"%d\\n\", sizeof(long));\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  TGLIB32=yes\nelse $as_nop\n  TGLIB32=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $TGLIB32\" >&5\nprintf \"%s\\n\" \"$TGLIB32\" >&6; }\nCFLAGS=$CFLAGS_SAVE\n\n\necho .\necho Check system services:\necho .\n# Check whether --enable-largefile was given.\nif test ${enable_largefile+y}\nthen :\n  enableval=$enable_largefile;\nfi\n\nif test \"$enable_largefile\" != no; then\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files\" >&5\nprintf %s \"checking for special C compiler options needed for large files... \" >&6; }\nif test ${ac_cv_sys_largefile_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_sys_largefile_CC=no\n     if test \"$GCC\" != yes; then\n       ac_save_CC=$CC\n       while :; do\n\t # IRIX 6.2 and later do not support large files by default,\n\t # so use the C compiler's -n32 option if that helps.\n\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <sys/types.h>\n /* Check that off_t can represent 2**63 - 1 correctly.\n    We can't simply define LARGE_OFF_T to be 9223372036854775807,\n    since some C++ compilers masquerading as C compilers\n    incorrectly reject 9223372036854775807.  */\n#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))\n  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n\t\t       && LARGE_OFF_T % 2147483647 == 1)\n\t\t      ? 1 : -1];\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\n\t if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  break\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n\t CC=\"$CC -n32\"\n\t if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_sys_largefile_CC=' -n32'; break\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n\t break\n       done\n       CC=$ac_save_CC\n       rm -f conftest.$ac_ext\n    fi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC\" >&5\nprintf \"%s\\n\" \"$ac_cv_sys_largefile_CC\" >&6; }\n  if test \"$ac_cv_sys_largefile_CC\" != no; then\n    CC=$CC$ac_cv_sys_largefile_CC\n  fi\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files\" >&5\nprintf %s \"checking for _FILE_OFFSET_BITS value needed for large files... \" >&6; }\nif test ${ac_cv_sys_file_offset_bits+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  while :; do\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <sys/types.h>\n /* Check that off_t can represent 2**63 - 1 correctly.\n    We can't simply define LARGE_OFF_T to be 9223372036854775807,\n    since some C++ compilers masquerading as C compilers\n    incorrectly reject 9223372036854775807.  */\n#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))\n  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n\t\t       && LARGE_OFF_T % 2147483647 == 1)\n\t\t      ? 1 : -1];\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_sys_file_offset_bits=no; break\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#define _FILE_OFFSET_BITS 64\n#include <sys/types.h>\n /* Check that off_t can represent 2**63 - 1 correctly.\n    We can't simply define LARGE_OFF_T to be 9223372036854775807,\n    since some C++ compilers masquerading as C compilers\n    incorrectly reject 9223372036854775807.  */\n#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))\n  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n\t\t       && LARGE_OFF_T % 2147483647 == 1)\n\t\t      ? 1 : -1];\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_sys_file_offset_bits=64; break\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n  ac_cv_sys_file_offset_bits=unknown\n  break\ndone\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits\" >&5\nprintf \"%s\\n\" \"$ac_cv_sys_file_offset_bits\" >&6; }\ncase $ac_cv_sys_file_offset_bits in #(\n  no | unknown) ;;\n  *)\nprintf \"%s\\n\" \"#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits\" >>confdefs.h\n;;\nesac\nrm -rf conftest*\n  if test $ac_cv_sys_file_offset_bits = unknown; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files\" >&5\nprintf %s \"checking for _LARGE_FILES value needed for large files... \" >&6; }\nif test ${ac_cv_sys_large_files+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  while :; do\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <sys/types.h>\n /* Check that off_t can represent 2**63 - 1 correctly.\n    We can't simply define LARGE_OFF_T to be 9223372036854775807,\n    since some C++ compilers masquerading as C compilers\n    incorrectly reject 9223372036854775807.  */\n#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))\n  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n\t\t       && LARGE_OFF_T % 2147483647 == 1)\n\t\t      ? 1 : -1];\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_sys_large_files=no; break\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#define _LARGE_FILES 1\n#include <sys/types.h>\n /* Check that off_t can represent 2**63 - 1 correctly.\n    We can't simply define LARGE_OFF_T to be 9223372036854775807,\n    since some C++ compilers masquerading as C compilers\n    incorrectly reject 9223372036854775807.  */\n#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))\n  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n\t\t       && LARGE_OFF_T % 2147483647 == 1)\n\t\t      ? 1 : -1];\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_sys_large_files=1; break\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n  ac_cv_sys_large_files=unknown\n  break\ndone\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files\" >&5\nprintf \"%s\\n\" \"$ac_cv_sys_large_files\" >&6; }\ncase $ac_cv_sys_large_files in #(\n  no | unknown) ;;\n  *)\nprintf \"%s\\n\" \"#define _LARGE_FILES $ac_cv_sys_large_files\" >>confdefs.h\n;;\nesac\nrm -rf conftest*\n  fi\nfi\n\n\necho .\necho Check configuration:\necho .\n# Check arguments used\n#\n# Optional Features:\n#  --disable-FEATURE        do not include FEATURE (same as --enable-FEATURE=no)\n#  --enable-FEATURE[=ARG]   include FEATURE [ARG=yes]\n#  --disable-largefile      omit support for large files\n#  --disable-nls            disable National Language Support\n#  --disable-file-attr      don't set attributes on files being installed\n#  --enable-install-cron    tell sysstat to install cron scripts\n#  --collect-all            tell sadc to collect all possible data\n#  --enable-clean-sa-dir    clean system activity directory\n#  --disable-compress-manpg do not compress manual pages when installed\n#  --enable-debuginfo       enable debug output (--debuginfo option)\n#  --disable-documentation  do not install documentation (man pages...)\n#  --disable-sensors        do not link against libsensors even if available\n#  --disable-pcp            do not link against PCP libraries even if available\n#  --disable-stripping      do not strip object files\n#  --enable-copy-only       only copy files when installing sysstat\n#  --enable-use-crond       use standard cron daemon\n#  --enable-lto\t            compile with Link Time Optimizations\n#\n# Some influential environment variables:\n#  rcdir         directory where startup scripts are installed\n#  sa_lib_dir    sadc, sa1 and sa2 directory\n#  sa_dir        system activity daily datafiles directory\n#  sar_dir       sar binary location. Used only in sa2 shell script\n#  conf_dir      sysstat configuration directory (default is /etc/sysconfig)\n#  conf_file     sysstat configuration file (default is sysstat)\n#  history       number of daily datafiles to keep (default value is 7)\n#  delay_range   maximum delay (in seconds) to wait before sa2 script generates its reports\n#  compressafter number of days after which datafiles are compressed\n#  man_group     group for man pages\n#  cron_owner    crontab owner\n#  cron_interval crontab sampling interval\n#  sadc_options  options to be passed to sadc\n#\n# Fine tuning the installation directories:\n#  --mandir=DIR           man documentation directory [PREFIX/man]\n#  --docdir=DIR           other documentation directory [PREFIX/share/doc]\n#\n# Installation directories:\n#  --prefix=PREFIX         install architecture-independent files in PREFIX\n#                            [/usr/local]\n#  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n#                            [PREFIX]\n\n# Set directories\nif test -d /etc/init.d && test ! -L /etc/init.d; then\n   if test -d /etc/init.d/rc2.d; then\n      RC_DIR=/etc/init.d\n      INITD_DIR=.\n   else\n      RC_DIR=/etc\n      INITD_DIR=init.d\n   fi\n   INIT_DIR=/etc/init.d\nelif test -d /sbin/init.d; then\n   RC_DIR=/sbin/init.d\n   INIT_DIR=/sbin/init.d\n   INITD_DIR=.\nelse\n   RC_DIR=/etc/rc.d\n   INIT_DIR=/etc/rc.d/init.d\n   INITD_DIR=init.d\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking run-commands directory\" >&5\nprintf %s \"checking run-commands directory... \" >&6; }\n\nif test x$rcdir != x\"\"; then\n\t# Override previous rc directories values\n\tRC_DIR=$rcdir\n\tINIT_DIR=$rcdir/init.d\n\tINITD_DIR=init.d\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $RC_DIR\" >&5\nprintf \"%s\\n\" \"$RC_DIR\" >&6; }\nif test ! -d $RC_DIR; then\n\techo \"INFO: Directory ${RC_DIR} doesn't exist.\"\n\techo \"INFO: Startup scripts won't be installed.\"\nfi\n\n\n\n\n\nif test $HAVE_SYS_SYSMACROS_H; then\n   SYSMACROS=\"y\"\nelse\n   SYSMACROS=\"n\"\nfi\n\n\nif test $HAVE_LINUX_SCHED_H; then\n   LINUX_SCHED=\"y\"\nelse\n   LINUX_SCHED=\"n\"\nfi\n\n\nif test $HAVE_SYS_PARAM_H; then\n   SYSPARAM=\"y\"\nelse\n   SYSPARAM=\"n\"\nfi\n\n\n# Set sadc directory\nif test $prefix != \"NONE\"; then\n   AuxPrefix=$prefix\nelse\n   AuxPrefix=/usr/local\nfi\n\nSADC_DIR=$AuxPrefix/lib\nif test -d $AuxPrefix/lib64; then\n    # Verify that this OS is really 64 bit\n    BITS=$(getconf LONG_BIT 2>/dev/null)\n    if test $? = 0; then\n        if test $BITS = 64; then\n            SADC_DIR=$AuxPrefix/lib64\n        fi\n    else\n        # Fallback: look for lm (long mode) flag to know if CPU is 64 bit\n        grep \" lm \" /proc/cpuinfo >/dev/null 2>&1\n        if test $? = 0; then\n            SADC_DIR=$AuxPrefix/lib64\n        fi\n    fi\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking sadc directory\" >&5\nprintf %s \"checking sadc directory... \" >&6; }\n\nif test x$sa_lib_dir != x\"\"; then\n   SA_LIB_DIR=$sa_lib_dir\nelse\n   SA_LIB_DIR=$SADC_DIR/sa\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SA_LIB_DIR\" >&5\nprintf \"%s\\n\" \"$SA_LIB_DIR\" >&6; }\nif test ! -d $SA_LIB_DIR; then\n   echo \"INFO: Directory ${SA_LIB_DIR} will be created during installation stage.\"\nfi\n\n\n# Set system activity directory\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking system activity directory\" >&5\nprintf %s \"checking system activity directory... \" >&6; }\n\nif test x$sa_dir != x\"\"; then\n   SA_DIR=$sa_dir\nelse\n   SA_DIR=/var/log/sa\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SA_DIR\" >&5\nprintf \"%s\\n\" \"$SA_DIR\" >&6; }\nif test ! -d $SA_DIR; then\n   echo \"INFO: Directory ${SA_DIR} will be created during installation stage.\"\nfi\n\n\n# sar binary location. Used only in sa2 shell script\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking sar directory\" >&5\nprintf %s \"checking sar directory... \" >&6; }\n\nif test x$sar_dir != x\"\"; then\n   SAR_DIR=$sar_dir\nelse\n   SAR_DIR=\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SAR_DIR\" >&5\nprintf \"%s\\n\" \"$SAR_DIR\" >&6; }\n\n\n# Set configuration directory\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking sysstat configuration directory\" >&5\nprintf %s \"checking sysstat configuration directory... \" >&6; }\n\nif test x$conf_dir != x\"\"; then\n   SYSCONFIG_DIR=$conf_dir\nelse\n   SYSCONFIG_DIR=/etc/sysconfig\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SYSCONFIG_DIR\" >&5\nprintf \"%s\\n\" \"$SYSCONFIG_DIR\" >&6; }\nif test ! -d $SYSCONFIG_DIR; then\n   echo \"INFO: Directory ${SYSCONFIG_DIR} will be created during installation stage.\"\nfi\n\n\n# Set configuration directory\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking sysstat configuration file\" >&5\nprintf %s \"checking sysstat configuration file... \" >&6; }\n\nif test x$conf_file != x\"\"; then\n   SYSCONFIG_FILE=$conf_file\nelse\n   SYSCONFIG_FILE=sysstat\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SYSCONFIG_FILE\" >&5\nprintf \"%s\\n\" \"$SYSCONFIG_FILE\" >&6; }\n\n\n# National Language Support\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking National Language Support\" >&5\nprintf %s \"checking National Language Support... \" >&6; }\n# Check whether --enable-nls was given.\nif test ${enable_nls+y}\nthen :\n  enableval=$enable_nls; AUX_NLS=$enableval\nelse $as_nop\n  AUX_NLS=yes\nfi\n\nif test $AUX_NLS != \"no\" && test $HAVE_LIBINTL_H && test $HAVE_LOCALE_H; then\n   AUX_NLS=\"yes\"\n   NLS=\"y\"\nelse\n   AUX_NLS=\"no\"\n   NLS=\"n\"\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_NLS\" >&5\nprintf \"%s\\n\" \"$AUX_NLS\" >&6; }\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for gettext in -lintl\" >&5\nprintf %s \"checking for gettext in -lintl... \" >&6; }\nif test ${ac_cv_lib_intl_gettext+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lintl  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\nchar gettext ();\nint\nmain (void)\n{\nreturn gettext ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  ac_cv_lib_intl_gettext=yes\nelse $as_nop\n  ac_cv_lib_intl_gettext=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_gettext\" >&5\nprintf \"%s\\n\" \"$ac_cv_lib_intl_gettext\" >&6; }\nif test \"x$ac_cv_lib_intl_gettext\" = xyes\nthen :\n  LFINTL=\"-lintl\"\nfi\n\n\nLACKING_GETTEXT=\"n\"\nif test $AUX_NLS = \"yes\" &&  test x$MSGFMT != x\"msgfmt\"; then\n   echo \"WARNING: msgfmt command not found!\"\n   LACKING_GETTEXT=\"y\"\nfi\nif test $AUX_NLS = \"yes\" &&  test x$XGETTEXT != x\"xgettext\"; then\n   echo \"WARNING: xgettext command not found!\"\n   LACKING_GETTEXT=\"y\"\nfi\nif test $AUX_NLS = \"yes\" &&  test x$MSGMERGE != x\"msgmerge\"; then\n   echo \"WARNING: msgmerge command not found!\"\n   LACKING_GETTEXT=\"y\"\nfi\nif test $NLS = \"y\" && test $LACKING_GETTEXT = \"y\"; then\n   echo \"WARNING: Disabling NLS\"\n   NLS=\"n\"\nfi\n\n\n# Link Time Optimization\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking Link Time Optimization support\" >&5\nprintf %s \"checking Link Time Optimization support... \" >&6; }\n# Check whether --enable-lto was given.\nif test ${enable_lto+y}\nthen :\n  enableval=$enable_lto; AUX_LTO=$enableval\nelse $as_nop\n  AUX_LTO=no\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_LTO\" >&5\nprintf \"%s\\n\" \"$AUX_LTO\" >&6; }\nLTO=\"n\"\nif test $AUX_LTO = \"yes\"; then\n\t# Extract the first word of \"gcc-ar\", so it can be a program name with args.\nset dummy gcc-ar; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_GCC_AR+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$GCC_AR\"; then\n  ac_cv_prog_GCC_AR=\"$GCC_AR\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_GCC_AR=\"gcc-ar\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nGCC_AR=$ac_cv_prog_GCC_AR\nif test -n \"$GCC_AR\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $GCC_AR\" >&5\nprintf \"%s\\n\" \"$GCC_AR\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n\tif test x$GCC_AR != x\"gcc-ar\"; then\n\t\techo \"WARNING: gcc-ar command not found! Disabling LTO support\"\n\t\tAUX_LTO=\"no\"\n\telse\n\t\tLTO=\"y\"\n\tfi\nfi\n\n\n# Data history to keep by sa2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking number of daily data files to keep\" >&5\nprintf %s \"checking number of daily data files to keep... \" >&6; }\n\nif test x$history = x\"\"; then\n   HISTORY=7\nelse\n   HISTORY=$history\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $HISTORY\" >&5\nprintf \"%s\\n\" \"$HISTORY\" >&6; }\n\n\n# Number of days after which datafiles are compressed\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking number of days after which data files are compressed\" >&5\nprintf %s \"checking number of days after which data files are compressed... \" >&6; }\n\nif test x$compressafter = x\"\"; then\n   COMPRESSAFTER=10\nelse\n   COMPRESSAFTER=$compressafter\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $COMPRESSAFTER\" >&5\nprintf \"%s\\n\" \"$COMPRESSAFTER\" >&6; }\n\n\n# Random delay to wait before sa2 script runs\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking random delay to wait before sa2 script runs\" >&5\nprintf %s \"checking random delay to wait before sa2 script runs... \" >&6; }\n\nif test x$delay_range = x\"\"; then\n   DELAY_RANGE=0\nelse\n   DELAY_RANGE=$delay_range\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $DELAY_RANGE\" >&5\nprintf \"%s\\n\" \"$DELAY_RANGE\" >&6; }\n\n\n# Manual page group\ngrep ^man: /etc/group >/dev/null 2>&1\nif test $? = 0; then\n   GRP=man\nelse\n   GRP=root\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking group for manual pages\" >&5\nprintf %s \"checking group for manual pages... \" >&6; }\n\nif test x$man_group = x\"\"; then\n   MAN_GROUP=$GRP\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $MAN_GROUP\" >&5\nprintf \"%s\\n\" \"$MAN_GROUP\" >&6; }\nelse\n   grep ^$man_group: /etc/group >/dev/null 2>&1\n   if test $? = 1; then\n      MAN_GROUP=$GRP\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $MAN_GROUP\" >&5\nprintf \"%s\\n\" \"$MAN_GROUP\" >&6; }\n      echo \"WARNING: Group ${man_group} not found: Using ${GRP} instead\"\n   else\n      MAN_GROUP=$man_group\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $MAN_GROUP\" >&5\nprintf \"%s\\n\" \"$MAN_GROUP\" >&6; }\n   fi\nfi\n\n\n# Don't set attributes on files being installed?\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether attributes should not be set on files being installed\" >&5\nprintf %s \"checking whether attributes should not be set on files being installed... \" >&6; }\n# Check whether --enable-file-attr was given.\nif test ${enable_file_attr+y}\nthen :\n  enableval=$enable_file_attr; AUX_IMG=$enableval\nelse $as_nop\n  AUX_IMG=yes\nfi\n\nif test $AUX_IMG != \"no\"; then\n   IGNORE_FILE_ATTRIBUTES=n\n   AUX_IMG=no\nelse\n   IGNORE_FILE_ATTRIBUTES=y\n   AUX_IMG=yes\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_IMG\" >&5\nprintf \"%s\\n\" \"$AUX_IMG\" >&6; }\n\n\n# Compress manual pages?\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether manual pages should be compressed\" >&5\nprintf %s \"checking whether manual pages should be compressed... \" >&6; }\n# Check whether --enable-compress-manpg was given.\nif test ${enable_compress_manpg+y}\nthen :\n  enableval=$enable_compress_manpg; AUX_MPG=$enableval\nelse $as_nop\n  AUX_MPG=yes\nfi\n\nif test $AUX_MPG != \"yes\"; then\n   COMPRESS_MANPG=n\nelse\n   COMPRESS_MANPG=y\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_MPG\" >&5\nprintf \"%s\\n\" \"$AUX_MPG\" >&6; }\n\n\n# Check whether sa directory should be cleaned\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether system activity directory should be cleaned\" >&5\nprintf %s \"checking whether system activity directory should be cleaned... \" >&6; }\n# Check whether --enable-clean-sa-dir was given.\nif test ${enable_clean_sa_dir+y}\nthen :\n  enableval=$enable_clean_sa_dir; AUX_CSD=$enableval\nelse $as_nop\n  AUX_CSD=no\nfi\n\nif test $AUX_CSD != \"yes\"; then\n   CLEAN_SA_DIR=n\n   AUX_CSD=no\nelse\n   CLEAN_SA_DIR=y\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_CSD\" >&5\nprintf \"%s\\n\" \"$AUX_CSD\" >&6; }\n\n\n# Start crontab\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether cron should start sar automatically\" >&5\nprintf %s \"checking whether cron should start sar automatically... \" >&6; }\n# Check whether --enable-install-cron was given.\nif test ${enable_install_cron+y}\nthen :\n  enableval=$enable_install_cron; INSTALL_CRON=$enableval\nelse $as_nop\n  INSTALL_CRON=n\nfi\n\nif test $INSTALL_CRON != \"yes\"; then\n   INSTALL_CRON=n\n   AUX_CRON=no\nelse\n   INSTALL_CRON=y\n   AUX_CRON=yes\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_CRON\" >&5\nprintf \"%s\\n\" \"$AUX_CRON\" >&6; }\n\n\n# Crontab owner\nCUSR=\"root\"\nif test $INSTALL_CRON = \"y\"; then\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking crontab owner\" >&5\nprintf %s \"checking crontab owner... \" >&6; }\n\n   if test x$cron_owner = x\"\"; then\n      CRON_OWNER=$CUSR\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CRON_OWNER\" >&5\nprintf \"%s\\n\" \"$CRON_OWNER\" >&6; }\n   else\n      grep ^$cron_owner: /etc/passwd >/dev/null 2>&1\n      if test $? = 1; then\n         CRON_OWNER=$CUSR;\n         { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CRON_OWNER\" >&5\nprintf \"%s\\n\" \"$CRON_OWNER\" >&6; }\n         echo \"WARNING: User ${cron_owner} not found: Using ${CUSR} instead.\"\n      else\n         CRON_OWNER=$cron_owner\n         { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CRON_OWNER\" >&5\nprintf \"%s\\n\" \"$CRON_OWNER\" >&6; }\n      fi\n   fi\n   echo \"INFO: Crontab for ${CRON_OWNER} will be saved in current directory if necessary\"\n   if test $CRON_OWNER = \"root\"; then\n      SU_C_OWNER=\"\"\n      QUOTE=\"\"\n      REM_CHOWN=\"# REM_CHOWN\"\n   else\n      SU_C_OWNER=\"su $CRON_OWNER -c \"\n      QUOTE=\\\"\n      # \" (ignore this line)\n      REM_CHOWN=$CHOWN\n   fi\n\n#  Check whether we should use the standard cron daemon\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether we should use the standard cron daemon\" >&5\nprintf %s \"checking whether we should use the standard cron daemon... \" >&6; }\n   # Check whether --enable-use-crond was given.\nif test ${enable_use_crond+y}\nthen :\n  enableval=$enable_use_crond; UCROND=$enableval\nelse $as_nop\n  UCROND=no\nfi\n\n   if test $UCROND != \"yes\"; then\n      USE_CROND=n\n      UCROND=no\n   else\n      USE_CROND=y\n   fi\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $UCROND\" >&5\nprintf \"%s\\n\" \"$UCROND\" >&6; }\n\n\n#  Crontab interval\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking crontab interval\" >&5\nprintf %s \"checking crontab interval... \" >&6; }\n\n   if test x$cron_interval = x\"\"; then\n      CRON_INTERVAL=10\n   else\n      CRON_INTERVAL=$cron_interval\n   fi\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CRON_INTERVAL\" >&5\nprintf \"%s\\n\" \"$CRON_INTERVAL\" >&6; }\n   CRON_INTERVAL_SEC=`expr ${CRON_INTERVAL} \\* 60`\n   CRON_COUNT=`expr 60 / ${CRON_INTERVAL}`\n\n#  Check whether sadc should collect all possible activities\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether sadc should collect all possible activities\" >&5\nprintf %s \"checking whether sadc should collect all possible activities... \" >&6; }\n   # Check whether --enable-collect-all was given.\nif test ${enable_collect_all+y}\nthen :\n  enableval=$enable_collect_all; COLLECT_ALL=$enableval\nelse $as_nop\n  COLLECT_ALL=n\nfi\n\n   if test $COLLECT_ALL != \"yes\"; then\n      COLLECT_ALL=\"\"\n      AUX_COLL=no\n   else\n      COLLECT_ALL=\"-S XALL\"\n      AUX_COLL=yes\n   fi\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_COLL\" >&5\nprintf \"%s\\n\" \"$AUX_COLL\" >&6; }\n\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking options to be passed to sadc\" >&5\nprintf %s \"checking options to be passed to sadc... \" >&6; }\n\n   if test x\"$sadc_options\" != x\"\"; then\n\tSADC_OPT=\"$sadc_options\"\n   else\n\tSADC_OPT=\n   fi\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $SADC_OPT\" >&5\nprintf \"%s\\n\" \"$SADC_OPT\" >&6; }\n\n\n#  Check whether files should only be copied\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether files should only be copied\" >&5\nprintf %s \"checking whether files should only be copied... \" >&6; }\n   # Check whether --enable-copy-only was given.\nif test ${enable_copy_only+y}\nthen :\n  enableval=$enable_copy_only; OCOPY=$enableval\nelse $as_nop\n  OCOPY=no\nfi\n\n   if test $OCOPY != \"yes\"; then\n      COPY_ONLY=n\n      OCOPY=no\n   else\n      COPY_ONLY=y\n   fi\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $OCOPY\" >&5\nprintf \"%s\\n\" \"$OCOPY\" >&6; }\n\n\nelse\n   CRON_OWNER=\"root\"\n   SU_C_OWNER=\"\"\n   QUOTE=\"\"\n   REM_CHOWN=\"# REM_CHOWN\"\n   CRON_INTERVAL=10\n   CRON_INTERVAL_SEC=600\n   CRON_COUNT=6\n   COLLECT_ALL=\"\"\nfi\n\n\n\n\n\n\n\n\n\n# Check whether documentation should be installed\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether documentation should be installed\" >&5\nprintf %s \"checking whether documentation should be installed... \" >&6; }\n# Check whether --enable-documentation was given.\nif test ${enable_documentation+y}\nthen :\n  enableval=$enable_documentation; AUX_DOC=$enableval\nelse $as_nop\n  AUX_DOC=yes\nfi\n\nif test $AUX_DOC != \"no\"; then\n   AUX_DOC=\"yes\"\n   INSTALL_DOC=\"y\"\nelse\n   AUX_DOC=\"no\"\n   INSTALL_DOC=\"n\"\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_DOC\" >&5\nprintf \"%s\\n\" \"$AUX_DOC\" >&6; }\n\n\n# Set directory for installing manual pages (see comment in Makefile)\n\n\n# Check whether debug mode should be activated\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether debug mode should be activated\" >&5\nprintf %s \"checking whether debug mode should be activated... \" >&6; }\n# Check whether --enable-debuginfo was given.\nif test ${enable_debuginfo+y}\nthen :\n  enableval=$enable_debuginfo; WITH_DEBUG=yes ; DFLAGS=\"$DFLAGS -DDEBUG\"\nelse $as_nop\n  WITH_DEBUG=no\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $WITH_DEBUG\" >&5\nprintf \"%s\\n\" \"$WITH_DEBUG\" >&6; }\n\n\n\n# Check whether object files should be stripped\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether object files should be stripped\" >&5\nprintf %s \"checking whether object files should be stripped... \" >&6; }\n# Check whether --enable-stripping was given.\nif test ${enable_stripping+y}\nthen :\n  enableval=$enable_stripping; AUX_STRIP=$enableval\nelse $as_nop\n  AUX_STRIP=yes\nfi\n\nif test $AUX_STRIP != \"no\"; then\n   AUX_STRIP=\"yes\"\n   STRIP=\"-s\"\nelse\n   AUX_STRIP=\"no\"\n   STRIP=\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AUX_STRIP\" >&5\nprintf \"%s\\n\" \"$AUX_STRIP\" >&6; }\n\n\n# Create files\necho .\necho Now create files:\necho .\nac_config_files=\"$ac_config_files sa1\"\n  \t# Permissions must be changed\nac_config_files=\"$ac_config_files sa2\"\n\t\t# Permissions must be changed\nac_config_files=\"$ac_config_files cron/crontab:cron/crontab.sample\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files sysstat.sysconfig\"\n\nac_config_files=\"$ac_config_files version.h:version.in\"\n\t\t# File must be renamed\nac_config_files=\"$ac_config_files sysconfig.h:sysconfig.in\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files cron/sysstat.cron.daily\"\n\nac_config_files=\"$ac_config_files cron/sysstat.cron.hourly\"\n\nac_config_files=\"$ac_config_files cron/sysstat.crond\"\n\nac_config_files=\"$ac_config_files cron/sysstat.crond.sample.in:cron/sysstat.crond.in\"\n\nac_config_files=\"$ac_config_files sysstat\"\n\t# Permissions must be changed\nac_config_files=\"$ac_config_files sysstat.service\"\n\nac_config_files=\"$ac_config_files cron/sysstat-collect.service\"\n\nac_config_files=\"$ac_config_files cron/sysstat-collect.timer\"\n\nac_config_files=\"$ac_config_files cron/sysstat-summary.service\"\n\nac_config_files=\"$ac_config_files cron/sysstat-summary.timer\"\n\nac_config_files=\"$ac_config_files cron/sysstat-rotate.service\"\n\nac_config_files=\"$ac_config_files cron/sysstat-rotate.timer\"\n\nac_config_files=\"$ac_config_files cron/sysstat.sleep\"\n\t# Permissions must be changed\nac_config_files=\"$ac_config_files man/sa1.8:man/sa1.in\"\n\t\t# File must be renamed\nac_config_files=\"$ac_config_files man/sa2.8:man/sa2.in\"\n\t\t# File must be renamed\nac_config_files=\"$ac_config_files man/sadc.8:man/sadc.in\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files man/sadf.1:man/sadf.in\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files man/sar.1:man/sar.in\"\n\t\t# File must be renamed\nac_config_files=\"$ac_config_files man/sysstat.5:man/sysstat.in\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files man/iostat.1:man/iostat.in\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files man/cifsiostat.1:man/cifsiostat.in\"\n\t# File must be renamed\nac_config_files=\"$ac_config_files tests/variables\"\n\n\nac_config_files=\"$ac_config_files Makefile\"\n\ncat >confcache <<\\_ACEOF\n# This file is a shell script that caches the results of configure\n# tests run on this system so they can be shared between configure\n# scripts and configure runs, see configure's option --config-cache.\n# It is not useful on other systems.  If it contains results you don't\n# want to keep, you may remove or edit it.\n#\n# config.status only pays attention to the cache file if you give it\n# the --recheck option to rerun configure.\n#\n# `ac_cv_env_foo' variables (set or unset) will be overridden when\n# loading this file, other *unset* `ac_cv_foo' will be assigned the\n# following values.\n\n_ACEOF\n\n# The following way of writing the cache mishandles newlines in values,\n# but we know of no workaround that is simple, portable, and efficient.\n# So, we kill variables containing newlines.\n# Ultrix sh set writes to stderr and can't be redirected directly,\n# and sets the high bit in the cache file unless we assign to the vars.\n(\n  for ac_var in `(set) 2>&1 | sed -n 's/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n\n  (set) 2>&1 |\n    case $as_nl`(ac_space=' '; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      # `set' does not quote correctly, so add quotes: double-quote\n      # substitution turns \\\\\\\\ into \\\\, and sed turns \\\\ into \\.\n      sed -n \\\n\t\"s/'/'\\\\\\\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\\\2'/p\"\n      ;; #(\n    *)\n      # `set' quotes correctly as required by POSIX, so do not add quotes.\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n) |\n  sed '\n     /^ac_cv_env_/b end\n     t clear\n     :clear\n     s/^\\([^=]*\\)=\\(.*[{}].*\\)$/test ${\\1+y} || &/\n     t end\n     s/^\\([^=]*\\)=\\(.*\\)$/\\1=${\\1=\\2}/\n     :end' >>confcache\nif diff \"$cache_file\" confcache >/dev/null 2>&1; then :; else\n  if test -w \"$cache_file\"; then\n    if test \"x$cache_file\" != \"x/dev/null\"; then\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: updating cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: updating cache $cache_file\" >&6;}\n      if test ! -f \"$cache_file\" || test -h \"$cache_file\"; then\n\tcat confcache >\"$cache_file\"\n      else\n        case $cache_file in #(\n        */* | ?:*)\n\t  mv -f confcache \"$cache_file\"$$ &&\n\t  mv -f \"$cache_file\"$$ \"$cache_file\" ;; #(\n        *)\n\t  mv -f confcache \"$cache_file\" ;;\n\tesac\n      fi\n    fi\n  else\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: not updating unwritable cache $cache_file\" >&6;}\n  fi\nfi\nrm -f confcache\n\ntest \"x$prefix\" = xNONE && prefix=$ac_default_prefix\n# Let make expand exec_prefix.\ntest \"x$exec_prefix\" = xNONE && exec_prefix='${prefix}'\n\n# Transform confdefs.h into DEFS.\n# Protect against shell expansion while executing Makefile rules.\n# Protect against Makefile macro expansion.\n#\n# If the first sed substitution is executed (which looks for macros that\n# take arguments), then branch to the quote section.  Otherwise,\n# look for a macro that doesn't take arguments.\nac_script='\n:mline\n/\\\\$/{\n N\n s,\\\\\\n,,\n b mline\n}\nt clear\n:clear\ns/^[\t ]*#[\t ]*define[\t ][\t ]*\\([^\t (][^\t (]*([^)]*)\\)[\t ]*\\(.*\\)/-D\\1=\\2/g\nt quote\ns/^[\t ]*#[\t ]*define[\t ][\t ]*\\([^\t ][^\t ]*\\)[\t ]*\\(.*\\)/-D\\1=\\2/g\nt quote\nb any\n:quote\ns/[\t `~#$^&*(){}\\\\|;'\\''\"<>?]/\\\\&/g\ns/\\[/\\\\&/g\ns/\\]/\\\\&/g\ns/\\$/$$/g\nH\n:any\n${\n\tg\n\ts/^\\n//\n\ts/\\n/ /g\n\tp\n}\n'\nDEFS=`sed -n \"$ac_script\" confdefs.h`\n\n\nac_libobjs=\nac_ltlibobjs=\nU=\nfor ac_i in : $LIBOBJS; do test \"x$ac_i\" = x: && continue\n  # 1. Remove the extension, and $U if already installed.\n  ac_script='s/\\$U\\././;s/\\.o$//;s/\\.obj$//'\n  ac_i=`printf \"%s\\n\" \"$ac_i\" | sed \"$ac_script\"`\n  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR\n  #    will be set to the directory where LIBOBJS objects are built.\n  as_fn_append ac_libobjs \" \\${LIBOBJDIR}$ac_i\\$U.$ac_objext\"\n  as_fn_append ac_ltlibobjs \" \\${LIBOBJDIR}$ac_i\"'$U.lo'\ndone\nLIBOBJS=$ac_libobjs\n\nLTLIBOBJS=$ac_ltlibobjs\n\n\n\n: \"${CONFIG_STATUS=./config.status}\"\nac_write_fail=0\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files $CONFIG_STATUS\"\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS\" >&5\nprintf \"%s\\n\" \"$as_me: creating $CONFIG_STATUS\" >&6;}\nas_write_fail=0\ncat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\n\ndebug=false\nac_cs_recheck=false\nac_cs_silent=false\n\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$CONFIG_STATUS <<\\_ASEOF || as_write_fail=1\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nas_nop=:\nif test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse $as_nop\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\n\n# Reset variables that may have inherited troublesome values from\n# the environment.\n\n# IFS needs to be set, to space, tab, and newline, in precisely that order.\n# (If _AS_PATH_WALK were called with IFS unset, it would have the\n# side effect of setting IFS to empty, thus disabling word splitting.)\n# Quoting is to prevent editors from complaining about space-tab.\nas_nl='\n'\nexport as_nl\nIFS=\" \"\"\t$as_nl\"\n\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# Ensure predictable behavior from utilities with locale-dependent output.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# We cannot yet rely on \"unset\" to work, but we need these variables\n# to be unset--not just set to an empty or harmless value--now, to\n# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct\n# also avoids known problems related to \"unset\" and subshell syntax\n# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).\nfor as_var in BASH_ENV ENV MAIL MAILPATH CDPATH\ndo eval test \\${$as_var+y} \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\n\n# Ensure that fds 0, 1, and 2 are open.\nif (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi\nif (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi\nif (exec 3>&2)            ; then :; else exec 2>/dev/null; fi\n\n# The user is always right.\nif ${PATH_SEPARATOR+false} :; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    test -r \"$as_dir$0\" && as_myself=$as_dir$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  printf \"%s\\n\" \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  printf \"%s\\n\" \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null\nthen :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse $as_nop\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null\nthen :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse $as_nop\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n# Determine whether it's possible to make 'echo' print without a newline.\n# These variables are no longer used directly by Autoconf, but are AC_SUBSTed\n# for compatibility with existing Makefiles.\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\n# For backward compatibility with old third-party macros, we provide\n# the shell variables $as_echo and $as_echo_n.  New code should use\n# AS_ECHO([\"message\"]) and AS_ECHO_N([\"message\"]), respectively.\nas_echo='printf %s\\n'\nas_echo_n='printf %s'\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`printf \"%s\\n\" \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\nexec 6>&1\n## ----------------------------------- ##\n## Main body of $CONFIG_STATUS script. ##\n## ----------------------------------- ##\n_ASEOF\ntest $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# Save the log message, to keep $0 and so on meaningful, and to\n# report actual input values of CONFIG_FILES etc. instead of their\n# values after options handling.\nac_log=\"\nThis file was extended by sysstat $as_me 12.7.7, which was\ngenerated by GNU Autoconf 2.71.  Invocation command line was\n\n  CONFIG_FILES    = $CONFIG_FILES\n  CONFIG_HEADERS  = $CONFIG_HEADERS\n  CONFIG_LINKS    = $CONFIG_LINKS\n  CONFIG_COMMANDS = $CONFIG_COMMANDS\n  $ $0 $@\n\non `(hostname || uname -n) 2>/dev/null | sed 1q`\n\"\n\n_ACEOF\n\ncase $ac_config_files in *\"\n\"*) set x $ac_config_files; shift; ac_config_files=$*;;\nesac\n\n\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n# Files that config.status was made for.\nconfig_files=\"$ac_config_files\"\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nac_cs_usage=\"\\\n\\`$as_me' instantiates files and other configuration actions\nfrom templates according to the current configuration.  Unless the files\nand actions are specified as TAGs, all are instantiated by default.\n\nUsage: $0 [OPTION]... [TAG]...\n\n  -h, --help       print this help, then exit\n  -V, --version    print version number and configuration settings, then exit\n      --config     print configuration, then exit\n  -q, --quiet, --silent\n                   do not print progress messages\n  -d, --debug      don't remove temporary files\n      --recheck    update $as_me by reconfiguring in the same conditions\n      --file=FILE[:TEMPLATE]\n                   instantiate the configuration file FILE\n\nConfiguration files:\n$config_files\n\nReport bugs to the package provider.\"\n\n_ACEOF\nac_cs_config=`printf \"%s\\n\" \"$ac_configure_args\" | sed \"$ac_safe_unquote\"`\nac_cs_config_escaped=`printf \"%s\\n\" \"$ac_cs_config\" | sed \"s/^ //; s/'/'\\\\\\\\\\\\\\\\''/g\"`\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_cs_config='$ac_cs_config_escaped'\nac_cs_version=\"\\\\\nsysstat config.status 12.7.7\nconfigured by $0, generated by GNU Autoconf 2.71,\n  with options \\\\\"\\$ac_cs_config\\\\\"\n\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis config.status script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\"\n\nac_pwd='$ac_pwd'\nsrcdir='$srcdir'\ntest -n \"\\$AWK\" || AWK=awk\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# The default lists apply if the user does not specify any file.\nac_need_defaults=:\nwhile test $# != 0\ndo\n  case $1 in\n  --*=?*)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=`expr \"X$1\" : 'X[^=]*=\\(.*\\)'`\n    ac_shift=:\n    ;;\n  --*=)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=\n    ac_shift=:\n    ;;\n  *)\n    ac_option=$1\n    ac_optarg=$2\n    ac_shift=shift\n    ;;\n  esac\n\n  case $ac_option in\n  # Handling of the options.\n  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)\n    ac_cs_recheck=: ;;\n  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )\n    printf \"%s\\n\" \"$ac_cs_version\"; exit ;;\n  --config | --confi | --conf | --con | --co | --c )\n    printf \"%s\\n\" \"$ac_cs_config\"; exit ;;\n  --debug | --debu | --deb | --de | --d | -d )\n    debug=: ;;\n  --file | --fil | --fi | --f )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`printf \"%s\\n\" \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    '') as_fn_error $? \"missing file argument\" ;;\n    esac\n    as_fn_append CONFIG_FILES \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --he | --h |  --help | --hel | -h )\n    printf \"%s\\n\" \"$ac_cs_usage\"; exit ;;\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil | --si | --s)\n    ac_cs_silent=: ;;\n\n  # This is an error.\n  -*) as_fn_error $? \"unrecognized option: \\`$1'\nTry \\`$0 --help' for more information.\" ;;\n\n  *) as_fn_append ac_config_targets \" $1\"\n     ac_need_defaults=false ;;\n\n  esac\n  shift\ndone\n\nac_configure_extra_args=\n\nif $ac_cs_silent; then\n  exec 6>/dev/null\n  ac_configure_extra_args=\"$ac_configure_extra_args --silent\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nif \\$ac_cs_recheck; then\n  set X $SHELL '$0' $ac_configure_args \\$ac_configure_extra_args --no-create --no-recursion\n  shift\n  \\printf \"%s\\n\" \"running CONFIG_SHELL=$SHELL \\$*\" >&6\n  CONFIG_SHELL='$SHELL'\n  export CONFIG_SHELL\n  exec \"\\$@\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nexec 5>>config.log\n{\n  echo\n  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX\n## Running $as_me. ##\n_ASBOX\n  printf \"%s\\n\" \"$ac_log\"\n} >&5\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n\n# Handling of arguments.\nfor ac_config_target in $ac_config_targets\ndo\n  case $ac_config_target in\n    \"sa1\") CONFIG_FILES=\"$CONFIG_FILES sa1\" ;;\n    \"sa2\") CONFIG_FILES=\"$CONFIG_FILES sa2\" ;;\n    \"cron/crontab\") CONFIG_FILES=\"$CONFIG_FILES cron/crontab:cron/crontab.sample\" ;;\n    \"sysstat.sysconfig\") CONFIG_FILES=\"$CONFIG_FILES sysstat.sysconfig\" ;;\n    \"version.h\") CONFIG_FILES=\"$CONFIG_FILES version.h:version.in\" ;;\n    \"sysconfig.h\") CONFIG_FILES=\"$CONFIG_FILES sysconfig.h:sysconfig.in\" ;;\n    \"cron/sysstat.cron.daily\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat.cron.daily\" ;;\n    \"cron/sysstat.cron.hourly\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat.cron.hourly\" ;;\n    \"cron/sysstat.crond\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat.crond\" ;;\n    \"cron/sysstat.crond.sample.in\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat.crond.sample.in:cron/sysstat.crond.in\" ;;\n    \"sysstat\") CONFIG_FILES=\"$CONFIG_FILES sysstat\" ;;\n    \"sysstat.service\") CONFIG_FILES=\"$CONFIG_FILES sysstat.service\" ;;\n    \"cron/sysstat-collect.service\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat-collect.service\" ;;\n    \"cron/sysstat-collect.timer\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat-collect.timer\" ;;\n    \"cron/sysstat-summary.service\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat-summary.service\" ;;\n    \"cron/sysstat-summary.timer\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat-summary.timer\" ;;\n    \"cron/sysstat-rotate.service\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat-rotate.service\" ;;\n    \"cron/sysstat-rotate.timer\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat-rotate.timer\" ;;\n    \"cron/sysstat.sleep\") CONFIG_FILES=\"$CONFIG_FILES cron/sysstat.sleep\" ;;\n    \"man/sa1.8\") CONFIG_FILES=\"$CONFIG_FILES man/sa1.8:man/sa1.in\" ;;\n    \"man/sa2.8\") CONFIG_FILES=\"$CONFIG_FILES man/sa2.8:man/sa2.in\" ;;\n    \"man/sadc.8\") CONFIG_FILES=\"$CONFIG_FILES man/sadc.8:man/sadc.in\" ;;\n    \"man/sadf.1\") CONFIG_FILES=\"$CONFIG_FILES man/sadf.1:man/sadf.in\" ;;\n    \"man/sar.1\") CONFIG_FILES=\"$CONFIG_FILES man/sar.1:man/sar.in\" ;;\n    \"man/sysstat.5\") CONFIG_FILES=\"$CONFIG_FILES man/sysstat.5:man/sysstat.in\" ;;\n    \"man/iostat.1\") CONFIG_FILES=\"$CONFIG_FILES man/iostat.1:man/iostat.in\" ;;\n    \"man/cifsiostat.1\") CONFIG_FILES=\"$CONFIG_FILES man/cifsiostat.1:man/cifsiostat.in\" ;;\n    \"tests/variables\") CONFIG_FILES=\"$CONFIG_FILES tests/variables\" ;;\n    \"Makefile\") CONFIG_FILES=\"$CONFIG_FILES Makefile\" ;;\n\n  *) as_fn_error $? \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n  esac\ndone\n\n\n# If the user did not use the arguments to specify the items to instantiate,\n# then the envvar interface is used.  Set only those that are not.\n# We use the long form for the default assignment because of an extremely\n# bizarre bug on SunOS 4.1.3.\nif $ac_need_defaults; then\n  test ${CONFIG_FILES+y} || CONFIG_FILES=$config_files\nfi\n\n# Have a temporary directory for convenience.  Make it in the build tree\n# simply because there is no reason against having it here, and in addition,\n# creating and moving files from /tmp can sometimes cause problems.\n# Hook for its removal unless debugging.\n# Note that there is a small window in which the directory will not be cleaned:\n# after its creation but before its name has been assigned to `$tmp'.\n$debug ||\n{\n  tmp= ac_tmp=\n  trap 'exit_status=$?\n  : \"${ac_tmp:=$tmp}\"\n  { test ! -d \"$ac_tmp\" || rm -fr \"$ac_tmp\"; } && exit $exit_status\n' 0\n  trap 'as_fn_exit 1' 1 2 13 15\n}\n# Create a (secure) tmp directory for tmp files.\n\n{\n  tmp=`(umask 077 && mktemp -d \"./confXXXXXX\") 2>/dev/null` &&\n  test -d \"$tmp\"\n}  ||\n{\n  tmp=./conf$$-$RANDOM\n  (umask 077 && mkdir \"$tmp\")\n} || as_fn_error $? \"cannot create a temporary directory in .\" \"$LINENO\" 5\nac_tmp=$tmp\n\n# Set up the scripts for CONFIG_FILES section.\n# No need to generate them if there are no CONFIG_FILES.\n# This happens for instance with `./config.status config.h'.\nif test -n \"$CONFIG_FILES\"; then\n\n\nac_cr=`echo X | tr X '\\015'`\n# On cygwin, bash can eat \\r inside `` if the user requested igncr.\n# But we know of no other shell where ac_cr would be empty at this\n# point, so we can use a bashism as a fallback.\nif test \"x$ac_cr\" = x; then\n  eval ac_cr=\\$\\'\\\\r\\'\nfi\nac_cs_awk_cr=`$AWK 'BEGIN { print \"a\\rb\" }' </dev/null 2>/dev/null`\nif test \"$ac_cs_awk_cr\" = \"a${ac_cr}b\"; then\n  ac_cs_awk_cr='\\\\r'\nelse\n  ac_cs_awk_cr=$ac_cr\nfi\n\necho 'BEGIN {' >\"$ac_tmp/subs1.awk\" &&\n_ACEOF\n\n\n{\n  echo \"cat >conf$$subs.awk <<_ACEOF\" &&\n  echo \"$ac_subst_vars\" | sed 's/.*/&!$&$ac_delim/' &&\n  echo \"_ACEOF\"\n} >conf$$subs.sh ||\n  as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\nac_delim_num=`echo \"$ac_subst_vars\" | grep -c '^'`\nac_delim='%!_!# '\nfor ac_last_try in false false false false false :; do\n  . ./conf$$subs.sh ||\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n\n  ac_delim_n=`sed -n \"s/.*$ac_delim\\$/X/p\" conf$$subs.awk | grep -c X`\n  if test $ac_delim_n = $ac_delim_num; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\nrm -f conf$$subs.sh\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\ncat >>\"\\$ac_tmp/subs1.awk\" <<\\\\_ACAWK &&\n_ACEOF\nsed -n '\nh\ns/^/S[\"/; s/!.*/\"]=/\np\ng\ns/^[^!]*!//\n:repl\nt repl\ns/'\"$ac_delim\"'$//\nt delim\n:nl\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\n\"\\\\/\np\nn\nb repl\n:more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt nl\n:delim\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/\np\nb\n:more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt delim\n' <conf$$subs.awk | sed '\n/^[^\"\"]/{\n  N\n  s/\\n//\n}\n' >>$CONFIG_STATUS || ac_write_fail=1\nrm -f conf$$subs.awk\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACAWK\ncat >>\"\\$ac_tmp/subs1.awk\" <<_ACAWK &&\n  for (key in S) S_is_set[key] = 1\n  FS = \"\u0007\"\n\n}\n{\n  line = $ 0\n  nfields = split(line, field, \"@\")\n  substed = 0\n  len = length(field[1])\n  for (i = 2; i < nfields; i++) {\n    key = field[i]\n    keylen = length(key)\n    if (S_is_set[key]) {\n      value = S[key]\n      line = substr(line, 1, len) \"\" value \"\" substr(line, len + keylen + 3)\n      len += length(value) + length(field[++i])\n      substed = 1\n    } else\n      len += 1 + keylen\n  }\n\n  print line\n}\n\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nif sed \"s/$ac_cr//\" < /dev/null > /dev/null 2>&1; then\n  sed \"s/$ac_cr\\$//; s/$ac_cr/$ac_cs_awk_cr/g\"\nelse\n  cat\nfi < \"$ac_tmp/subs1.awk\" > \"$ac_tmp/subs.awk\" \\\n  || as_fn_error $? \"could not setup config files machinery\" \"$LINENO\" 5\n_ACEOF\n\n# VPATH may cause trouble with some makes, so we remove sole $(srcdir),\n# ${srcdir} and @srcdir@ entries from VPATH if srcdir is \".\", strip leading and\n# trailing colons and then remove the whole line if VPATH becomes empty\n# (actually we leave an empty line to preserve line numbers).\nif test \"x$srcdir\" = x.; then\n  ac_vpsub='/^[\t ]*VPATH[\t ]*=[\t ]*/{\nh\ns///\ns/^/:/\ns/[\t ]*$/:/\ns/:\\$(srcdir):/:/g\ns/:\\${srcdir}:/:/g\ns/:@srcdir@:/:/g\ns/^:*//\ns/:*$//\nx\ns/\\(=[\t ]*\\).*/\\1/\nG\ns/\\n//\ns/^[^=]*=[\t ]*$//\n}'\nfi\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nfi # test -n \"$CONFIG_FILES\"\n\n\neval set X \"  :F $CONFIG_FILES      \"\nshift\nfor ac_tag\ndo\n  case $ac_tag in\n  :[FHLC]) ac_mode=$ac_tag; continue;;\n  esac\n  case $ac_mode$ac_tag in\n  :[FHL]*:*);;\n  :L* | :C*:*) as_fn_error $? \"invalid tag \\`$ac_tag'\" \"$LINENO\" 5;;\n  :[FH]-) ac_tag=-:-;;\n  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;\n  esac\n  ac_save_IFS=$IFS\n  IFS=:\n  set x $ac_tag\n  IFS=$ac_save_IFS\n  shift\n  ac_file=$1\n  shift\n\n  case $ac_mode in\n  :L) ac_source=$1;;\n  :[FH])\n    ac_file_inputs=\n    for ac_f\n    do\n      case $ac_f in\n      -) ac_f=\"$ac_tmp/stdin\";;\n      *) # Look for the file first in the build tree, then in the source tree\n\t # (if the path is not absolute).  The absolute path cannot be DOS-style,\n\t # because $ac_f cannot contain `:'.\n\t test -f \"$ac_f\" ||\n\t   case $ac_f in\n\t   [\\\\/$]*) false;;\n\t   *) test -f \"$srcdir/$ac_f\" && ac_f=\"$srcdir/$ac_f\";;\n\t   esac ||\n\t   as_fn_error 1 \"cannot find input file: \\`$ac_f'\" \"$LINENO\" 5;;\n      esac\n      case $ac_f in *\\'*) ac_f=`printf \"%s\\n\" \"$ac_f\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; esac\n      as_fn_append ac_file_inputs \" '$ac_f'\"\n    done\n\n    # Let's still pretend it is `configure' which instantiates (i.e., don't\n    # use $as_me), people would be surprised to read:\n    #    /* config.h.  Generated by config.status.  */\n    configure_input='Generated from '`\n\t  printf \"%s\\n\" \"$*\" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'\n\t`' by configure.'\n    if test x\"$ac_file\" != x-; then\n      configure_input=\"$ac_file.  $configure_input\"\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating $ac_file\" >&5\nprintf \"%s\\n\" \"$as_me: creating $ac_file\" >&6;}\n    fi\n    # Neutralize special characters interpreted by sed in replacement strings.\n    case $configure_input in #(\n    *\\&* | *\\|* | *\\\\* )\n       ac_sed_conf_input=`printf \"%s\\n\" \"$configure_input\" |\n       sed 's/[\\\\\\\\&|]/\\\\\\\\&/g'`;; #(\n    *) ac_sed_conf_input=$configure_input;;\n    esac\n\n    case $ac_tag in\n    *:-:* | *:-) cat >\"$ac_tmp/stdin\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5 ;;\n    esac\n    ;;\n  esac\n\n  ac_dir=`$as_dirname -- \"$ac_file\" ||\n$as_expr X\"$ac_file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)$' \\| \\\n\t X\"$ac_file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$ac_file\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  as_dir=\"$ac_dir\"; as_fn_mkdir_p\n  ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`printf \"%s\\n\" \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`printf \"%s\\n\" \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n\n  case $ac_mode in\n  :F)\n  #\n  # CONFIG_FILE\n  #\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# If the template does not know about datarootdir, expand it.\n# FIXME: This hack should be removed a few years after 2.60.\nac_datarootdir_hack=; ac_datarootdir_seen=\nac_sed_dataroot='\n/datarootdir/ {\n  p\n  q\n}\n/@datadir@/p\n/@docdir@/p\n/@infodir@/p\n/@localedir@/p\n/@mandir@/p'\ncase `eval \"sed -n \\\"\\$ac_sed_dataroot\\\" $ac_file_inputs\"` in\n*datarootdir*) ac_datarootdir_seen=yes;;\n*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&2;}\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  ac_datarootdir_hack='\n  s&@datadir@&$datadir&g\n  s&@docdir@&$docdir&g\n  s&@infodir@&$infodir&g\n  s&@localedir@&$localedir&g\n  s&@mandir@&$mandir&g\n  s&\\\\\\${datarootdir}&$datarootdir&g' ;;\nesac\n_ACEOF\n\n# Neutralize VPATH when `$srcdir' = `.'.\n# Shell code in configure.ac might set extrasub.\n# FIXME: do we really want to maintain this feature?\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_sed_extra=\"$ac_vpsub\n$extrasub\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n:t\n/@[a-zA-Z_][a-zA-Z_0-9]*@/!b\ns|@configure_input@|$ac_sed_conf_input|;t t\ns&@top_builddir@&$ac_top_builddir_sub&;t t\ns&@top_build_prefix@&$ac_top_build_prefix&;t t\ns&@srcdir@&$ac_srcdir&;t t\ns&@abs_srcdir@&$ac_abs_srcdir&;t t\ns&@top_srcdir@&$ac_top_srcdir&;t t\ns&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t\ns&@builddir@&$ac_builddir&;t t\ns&@abs_builddir@&$ac_abs_builddir&;t t\ns&@abs_top_builddir@&$ac_abs_top_builddir&;t t\n$ac_datarootdir_hack\n\"\neval sed \\\"\\$ac_sed_extra\\\" \"$ac_file_inputs\" | $AWK -f \"$ac_tmp/subs.awk\" \\\n  >$ac_tmp/out || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n\ntest -z \"$ac_datarootdir_hack$ac_datarootdir_seen\" &&\n  { ac_out=`sed -n '/\\${datarootdir}/p' \"$ac_tmp/out\"`; test -n \"$ac_out\"; } &&\n  { ac_out=`sed -n '/^[\t ]*datarootdir[\t ]*:*=/p' \\\n      \"$ac_tmp/out\"`; test -z \"$ac_out\"; } &&\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&2;}\n\n  rm -f \"$ac_tmp/stdin\"\n  case $ac_file in\n  -) cat \"$ac_tmp/out\" && rm -f \"$ac_tmp/out\";;\n  *) rm -f \"$ac_file\" && mv \"$ac_tmp/out\" \"$ac_file\";;\n  esac \\\n  || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n ;;\n\n\n\n  esac\n\n\n  case $ac_file$ac_mode in\n    \"sa1\":F) chmod +x sa1 ;;\n    \"sa2\":F) chmod +x sa2 ;;\n    \"cron/sysstat.crond.sample.in\":F) sed s/^/#/ cron/sysstat.crond.sample.in > cron/sysstat.crond.sample ;;\n    \"sysstat\":F) chmod +x sysstat ;;\n    \"cron/sysstat.sleep\":F) chmod +x cron/sysstat.sleep ;;\n\n  esac\ndone # for ac_tag\n\n\nas_fn_exit 0\n_ACEOF\nac_clean_files=$ac_clean_files_save\n\ntest $ac_write_fail = 0 ||\n  as_fn_error $? \"write failure creating $CONFIG_STATUS\" \"$LINENO\" 5\n\n\n# configure is writing to config.log, and then calls config.status.\n# config.status does its own redirection, appending to config.log.\n# Unfortunately, on DOS this fails, as config.log is still kept open\n# by configure, so config.status won't be able to write to it; its\n# output is simply discarded.  So we exec the FD to /dev/null,\n# effectively closing config.log, so it can be properly (re)opened and\n# appended to by config.status.  When coming back to configure, we\n# need to make the FD available again.\nif test \"$no_create\" != yes; then\n  ac_cs_success=:\n  ac_config_status_args=\n  test \"$silent\" = yes &&\n    ac_config_status_args=\"$ac_config_status_args --quiet\"\n  exec 5>/dev/null\n  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false\n  exec 5>>config.log\n  # Use ||, not &&, to avoid exiting from the if with $? = 1, which\n  # would make configure fail if this is the last instruction.\n  $ac_cs_success || as_fn_exit 1\nfi\nif test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\nfi\n\n\necho \"\n   Sysstat version:\t\t$PACKAGE_VERSION\n   Installation prefix:\t\t$prefix\n   rc directory:\t\t${RC_DIR}\n   Init directory:\t\t${INIT_DIR}\"\nif test \"$UCROND\" != \"yes\"; then\n   echo \"   Systemd unit dir:\t\t${with_systemdsystemunitdir}\"\n   echo \"   Systemd sleep dir:\t\t${with_systemdsleepdir}\"\nelse\n   echo \"   Use standard cron daemon\"\nfi\necho \"   Configuration file:\t\t${SYSCONFIG_DIR}/${SYSCONFIG_FILE}\n   Man pages directory:\t\t$mandir\n   Compiler:\t\t\t$CC\n   Compiler flags:\t\t$CFLAGS\n   Linker flags:\t\t$LDFLAGS\n\"\n\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 22.955078125,
          "content": "# configure.ac\n#\n# (C) 2007 - Ivana Varekova <varekova@redhat.com>\n# Modified by Sebastien Godard (sysstat <at> orange.fr)\n\n# Initialization of $PACKAGE_VERSION and $PACKAGE_NAME variables\nAC_INIT([sysstat],[12.7.7])\n\n# Ensure that a recent enough version of Autoconf is being used\nAC_PREREQ([2.71])\n\n# Check whether the configure script is in the right dir\nAC_CONFIG_SRCDIR(ioconf.h)\n\n# Check programs\necho .\necho Check programs:\necho .\n\nAC_PROG_CC\nAC_USE_SYSTEM_EXTENSIONS\nAC_PROG_LN_S\n\nDFLAGS=\"\"\n\nAC_CHECK_PROG(CHMOD, chmod, chmod)\nAC_CHECK_PROG(CHOWN, chown, chown)\nAC_CHECK_PROG(AR, ar, ar)\nAC_CHECK_PROG(INSTALL, install, install)\nAC_CHECK_PROG(MSGFMT, msgfmt, msgfmt)\nAC_CHECK_PROG(XGETTEXT, xgettext, xgettext)\nAC_CHECK_PROG(MSGMERGE, msgmerge, msgmerge)\nAC_CHECK_PROG(VER_XML, xmllint, xmllint)\nAC_CHECK_PROGS(VER_JSON, json_verify json_pp, true)\nAC_CHECK_PROGS(ZIP, xz bzip2 gzip, gzip)\nINSTALL_DATA=\"\\${INSTALL} -m 644\"\nAC_SUBST(INSTALL_DATA)\nINSTALL_BIN=\"\\${INSTALL} -m 755\"\nAC_SUBST(INSTALL_BIN)\n\nAC_SUBST(VER_JSON)\nAC_SUBST(VER_XML)\n\nAC_PATH_PROG(PATH_CP, cp)\nAC_PATH_PROG(PATH_CHKCONFIG, chkconfig)\n\n# Check for systemd\nAC_CHECK_PROG(PKG_CONFIG, pkg-config, pkg-config)\nAC_PATH_PROG(SYSTEMCTL, systemctl)\nAC_ARG_WITH([systemdsystemunitdir],\n    AS_HELP_STRING([--with-systemdsystemunitdir=DIR],[Directory for systemd service files]),\n    [], [with_systemdsystemunitdir=$($PKG_CONFIG --variable=systemdsystemunitdir systemd)])\nif test -n \"$with_systemdsystemunitdir\" -a \"x$with_systemdsystemunitdir\" != xno ; then\n    AC_SUBST([SYSTEMD_UNIT_DIR], [$with_systemdsystemunitdir])\nfi\nAC_ARG_WITH([systemdsleepdir],\n    AS_HELP_STRING([--with-systemdsleepdir=DIR],[Directory for systemd suspend/resume scripts]),\n    [], [with_systemdsleepdir=$($PKG_CONFIG --variable=systemdsleepdir systemd)])\nif test -n \"$with_systemdsleepdir\" -a \"x$with_systemdsleepdir\" != xno ; then\n    AC_SUBST([SYSTEMD_SLEEP_DIR], [$with_systemdsleepdir])\nfi\n\n# Check libraries\n\n# Check header files\necho .\necho Check header files:\necho .\nHAVE_LIBINTL_H=\nHAVE_LOCALE_H=\nHAVE_SYS_SYSMACROS_H=\nHAVE_SYS_PARAM_H=\nAC_CHECK_HEADERS(ctype.h)\nAC_CHECK_HEADERS(errno.h)\nAC_CHECK_HEADERS(libintl.h, HAVE_LIBINTL_H=1)\nAC_CHECK_HEADERS(locale.h, HAVE_LOCALE_H=1)\nAC_CHECK_HEADERS(linux/sched.h, HAVE_LINUX_SCHED_H=1)\nAC_CHECK_HEADERS(net/if.h)\nAC_CHECK_HEADERS(regex.h)\nAC_CHECK_HEADERS(signal.h)\nAC_CHECK_HEADERS(stdio.h)\nAC_CHECK_HEADERS(stdint.h)\nAC_CHECK_HEADERS(fcntl.h)\nAC_CHECK_HEADERS(inttypes.h)\nAC_CHECK_HEADERS(libgen.h)\nAC_CHECK_HEADERS(pwd.h)\nAC_CHECK_HEADERS(time.h)\nAC_CHECK_HEADERS(unistd.h)\nAC_CHECK_HEADERS(pcp/pmapi.h, HAVE_PCP_PMAPI_H=1)\nAC_CHECK_HEADERS(pcp/impl.h, HAVE_PCP_IMPL_H=1)\nAC_CHECK_HEADERS(sys/time.h)\nAC_CHECK_HEADERS(sys/statvfs.h)\nAC_CHECK_HEADERS(sys/types.h)\nAC_CHECK_HEADERS(sys/file.h)\nAC_CHECK_HEADERS(sys/ioctl.h)\nAC_CHECK_HEADERS(sys/param.h, HAVE_SYS_PARAM_H=1)\nAC_CHECK_HEADERS(sys/stat.h)\nAC_CHECK_HEADERS(sys/sysmacros.h, HAVE_SYS_SYSMACROS_H=1)\nAC_CHECK_HEADERS(sys/utsname.h)\nAC_CHECK_HEADERS(sys/wait.h)\n\necho .\necho Check typedefs, structures and compiler characteristics:\necho .\nAC_DEFINE_UNQUOTED([RETSIGTYPE],[$ac_cv_type_signal],[Define as the return type of signal handlers\n\t\t    (`int' or `void').])\n\nAC_TYPE_SIZE_T\nAC_TYPE_OFF_T\n\necho .\necho Check library functions:\necho .\nAC_CHECK_FUNCS(strchr)\nAC_CHECK_FUNCS(strcspn)\nAC_CHECK_FUNCS(strspn)\nAC_CHECK_FUNCS(strstr)\n\n# Should we check for PCP support?\nAC_MSG_CHECKING(for PCP support)\nAC_ARG_ENABLE(pcp,\n\t      AS_HELP_STRING([--disable-pcp],[disable PCP support]),\n\t\t\t     PCP=$enableval,PCP=yes)\nif test $PCP != \"yes\"; then\n\tHAVE_PCP=\"n\"\nelse\n\tHAVE_PCP=\"y\"\nfi\n\nif test ! $HAVE_PCP_PMAPI_H; then\n\tHAVE_PCP=\"n\"\n\tPCP=no\nfi\nAC_MSG_RESULT($PCP)\n\n# Check for PCP libraries\nLFPCP=\"\"\nDFPCP=\"\"\nif test $HAVE_PCP = \"y\"; then\n\tPCP=no\n\tAC_CHECK_LIB(pcp, pmGetVersion, LFPCP=\"-lpcp -lpcp_import\", HAVE_PCP=\"n\")\n\tAC_MSG_CHECKING(for PCP libraries)\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <pcp/pmapi.h>\n\t\t\t\t\t     #include <pcp/import.h>]],\n\t\t\t\t\t   [[pmiEnd();]])],PCP=yes; DFPCP=\"-DHAVE_PCP\", HAVE_PCP=\"n\"; PCP=no)\n\tAC_MSG_RESULT($PCP)\nfi\nAC_SUBST(HAVE_PCP)\nAC_SUBST(LFPCP)\nAC_SUBST(DFPCP)\n\nif test $HAVE_PCP_IMPL_H; then\n   PCP_IMPL=\"y\"\nelse\n   PCP_IMPL=\"n\"\nfi\nAC_SUBST(PCP_IMPL)\n\n# Should we check for lm_sensors?\nAC_MSG_CHECKING(for sensors support)\nAC_ARG_ENABLE(sensors,\n\t      AS_HELP_STRING([--disable-sensors],[disable sensors support]),\n\t\t\t     SENSORS=$enableval,SENSORS=yes)\nif test $SENSORS != \"yes\"; then\n\tSENSORS_SUPPORT=\"n\"\nelse\n\tSENSORS_SUPPORT=\"y\"\nfi\nAC_MSG_RESULT($SENSORS)\n\n# Check for lm_sensors library\nLFSENSORS=\"\"\nDFSENSORS=\"\"\nHAVE_SENSORS=\"n\"\nif test $SENSORS_SUPPORT = \"y\"; then\n\tSENSORS=no\n\tAC_CHECK_LIB(sensors, sensors_get_detected_chips, LFSENSORS=\"-lsensors\", HAVE_SENSORS=\"n\")\n\tAC_MSG_CHECKING(for sensors library)\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sensors/sensors.h>\n\t\t\t\t\t     #include <sensors/error.h>]],\n\t\t\t\t\t   [[sensors_cleanup();]])], SENSORS=yes; HAVE_SENSORS=\"y\"; DFSENSORS=\"-DHAVE_SENSORS\", HAVE_SENSORS=\"n\"; SENSORS=no)\n\tAC_MSG_RESULT($SENSORS)\nfi\nAC_SUBST(HAVE_SENSORS)\nAC_SUBST(LFSENSORS)\nAC_SUBST(DFSENSORS)\n\n# Check for 32-bit version of lm_sensors library\nLFSENSORS32=\"\"\nDFSENSORS32=\"\"\nHAVE_SENSORS32=\"n\"\nif test $SENSORS_SUPPORT = \"y\"; then\n\tCFLAGS_SAVE=$CFLAGS\n        # Was: CFLAGS+=\" -m32\" which is specific to bash and not sh\n\tCFLAGS=\"$CFLAGS -m32\"\n\tLDFLAGS_SAVE=$LDFLAGS\n\tLDFLAGS=\"$LDFLAGS -lsensors\"\n\tSENSORS=no\n#\tCheck for another function to avoid using cached result\n\tAC_CHECK_LIB(sensors, sensors_cleanup, LFSENSORS32=\"-lsensors\", HAVE_SENSORS32=\"n\")\n\tAC_MSG_CHECKING(for sensors 32-bit library)\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <sensors/sensors.h>\n\t\t\t\t\t  #include <sensors/error.h>]],\n\t\t\t\t\t[[sensors_cleanup();]])], SENSORS=yes; HAVE_SENSORS32=\"y\"; DFSENSORS32=\"-DHAVE_SENSORS32\", HAVE_SENSORS32=\"n\"; SENSORS=no)\n\tAC_MSG_RESULT($SENSORS)\n\tCFLAGS=$CFLAGS_SAVE\n\tLDFLAGS=$LDFLAGS_SAVE\nfi\nAC_SUBST(HAVE_SENSORS32)\nAC_SUBST(LFSENSORS32)\nAC_SUBST(DFSENSORS32)\n\n# Check for 32-bit system libraries\nTGLIB32=no\nCFLAGS_SAVE=$CFLAGS\nCFLAGS=\"$CFLAGS -m32\"\nAC_MSG_CHECKING(for 32-bit system libraries)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stdio.h>]],\n\t\t\t\t   [[printf(\"%d\\n\", sizeof(long));]])],TGLIB32=yes, TGLIB32=no)\nAC_MSG_RESULT($TGLIB32)\nCFLAGS=$CFLAGS_SAVE\nAC_SUBST(TGLIB32)\n\necho .\necho Check system services:\necho .\nAC_SYS_LARGEFILE\n\necho .\necho Check configuration:\necho .\n# Check arguments used\n#\n# Optional Features:\n#  --disable-FEATURE        do not include FEATURE (same as --enable-FEATURE=no)\n#  --enable-FEATURE[=ARG]   include FEATURE [ARG=yes]\n#  --disable-largefile      omit support for large files\n#  --disable-nls            disable National Language Support\n#  --disable-file-attr      don't set attributes on files being installed\n#  --enable-install-cron    tell sysstat to install cron scripts\n#  --collect-all            tell sadc to collect all possible data\n#  --enable-clean-sa-dir    clean system activity directory\n#  --disable-compress-manpg do not compress manual pages when installed\n#  --enable-debuginfo       enable debug output (--debuginfo option)\n#  --disable-documentation  do not install documentation (man pages...)\n#  --disable-sensors        do not link against libsensors even if available\n#  --disable-pcp            do not link against PCP libraries even if available\n#  --disable-stripping      do not strip object files\n#  --enable-copy-only       only copy files when installing sysstat\n#  --enable-use-crond       use standard cron daemon\n#  --enable-lto\t            compile with Link Time Optimizations\n#\n# Some influential environment variables:\n#  rcdir         directory where startup scripts are installed\n#  sa_lib_dir    sadc, sa1 and sa2 directory\n#  sa_dir        system activity daily datafiles directory\n#  sar_dir       sar binary location. Used only in sa2 shell script\n#  conf_dir      sysstat configuration directory (default is /etc/sysconfig)\n#  conf_file     sysstat configuration file (default is sysstat)\n#  history       number of daily datafiles to keep (default value is 7)\n#  delay_range   maximum delay (in seconds) to wait before sa2 script generates its reports\n#  compressafter number of days after which datafiles are compressed\n#  man_group     group for man pages\n#  cron_owner    crontab owner\n#  cron_interval crontab sampling interval\n#  sadc_options  options to be passed to sadc\n#\n# Fine tuning the installation directories:\n#  --mandir=DIR           man documentation directory [PREFIX/man]\n#  --docdir=DIR           other documentation directory [PREFIX/share/doc]\n#\n# Installation directories:\n#  --prefix=PREFIX         install architecture-independent files in PREFIX\n#                            [/usr/local]\n#  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n#                            [PREFIX]\n\n# Set directories\nif test -d /etc/init.d && test ! -L /etc/init.d; then\n   if test -d /etc/init.d/rc2.d; then\n      RC_DIR=/etc/init.d\n      INITD_DIR=.\n   else\n      RC_DIR=/etc\n      INITD_DIR=init.d\n   fi\n   INIT_DIR=/etc/init.d\nelif test -d /sbin/init.d; then\n   RC_DIR=/sbin/init.d\n   INIT_DIR=/sbin/init.d\n   INITD_DIR=.\nelse\n   RC_DIR=/etc/rc.d\n   INIT_DIR=/etc/rc.d/init.d\n   INITD_DIR=init.d\nfi\n\nAC_MSG_CHECKING(run-commands directory)\nAC_ARG_VAR([rcdir],[run-commands directory])\nif test x$rcdir != x\"\"; then\n\t# Override previous rc directories values\n\tRC_DIR=$rcdir\n\tINIT_DIR=$rcdir/init.d\n\tINITD_DIR=init.d\nfi\nAC_MSG_RESULT($RC_DIR)\nif test ! -d $RC_DIR; then\n\techo \"INFO: Directory ${RC_DIR} doesn't exist.\"\n\techo \"INFO: Startup scripts won't be installed.\"\nfi\n\nAC_SUBST(RC_DIR)\nAC_SUBST(INIT_DIR)\nAC_SUBST(INITD_DIR)\n\nif test $HAVE_SYS_SYSMACROS_H; then\n   SYSMACROS=\"y\"\nelse\n   SYSMACROS=\"n\"\nfi\nAC_SUBST(SYSMACROS)\n\nif test $HAVE_LINUX_SCHED_H; then\n   LINUX_SCHED=\"y\"\nelse\n   LINUX_SCHED=\"n\"\nfi\nAC_SUBST(LINUX_SCHED)\n\nif test $HAVE_SYS_PARAM_H; then\n   SYSPARAM=\"y\"\nelse\n   SYSPARAM=\"n\"\nfi\nAC_SUBST(SYSPARAM)\n\n# Set sadc directory\nif test $prefix != \"NONE\"; then\n   AuxPrefix=$prefix\nelse\n   AuxPrefix=/usr/local\nfi\n\nSADC_DIR=$AuxPrefix/lib\nif test -d $AuxPrefix/lib64; then\n    # Verify that this OS is really 64 bit\n    BITS=$(getconf LONG_BIT 2>/dev/null)\n    if test $? = 0; then\n        if test $BITS = 64; then\n            SADC_DIR=$AuxPrefix/lib64\n        fi\n    else\n        # Fallback: look for lm (long mode) flag to know if CPU is 64 bit\n        grep \" lm \" /proc/cpuinfo >/dev/null 2>&1\n        if test $? = 0; then\n            SADC_DIR=$AuxPrefix/lib64\n        fi\n    fi\nfi\n\nAC_MSG_CHECKING(sadc directory)\nAC_ARG_VAR([sa_lib_dir],[sadc directory])\nif test x$sa_lib_dir != x\"\"; then\n   SA_LIB_DIR=$sa_lib_dir\nelse\n   SA_LIB_DIR=$SADC_DIR/sa\nfi\nAC_MSG_RESULT($SA_LIB_DIR)\nif test ! -d $SA_LIB_DIR; then\n   echo \"INFO: Directory ${SA_LIB_DIR} will be created during installation stage.\"\nfi\nAC_SUBST(SA_LIB_DIR)\n\n# Set system activity directory\nAC_MSG_CHECKING(system activity directory)\nAC_ARG_VAR([sa_dir],[system activity directory])\nif test x$sa_dir != x\"\"; then\n   SA_DIR=$sa_dir\nelse\n   SA_DIR=/var/log/sa\nfi\nAC_MSG_RESULT($SA_DIR)\nif test ! -d $SA_DIR; then\n   echo \"INFO: Directory ${SA_DIR} will be created during installation stage.\"\nfi\nAC_SUBST(SA_DIR)\n\n# sar binary location. Used only in sa2 shell script\nAC_MSG_CHECKING(sar directory)\nAC_ARG_VAR([sar_dir],[sar directory])\nif test x$sar_dir != x\"\"; then\n   SAR_DIR=$sar_dir\nelse\n   SAR_DIR=\nfi\nAC_MSG_RESULT($SAR_DIR)\nAC_SUBST(SAR_DIR)\n\n# Set configuration directory\nAC_MSG_CHECKING(sysstat configuration directory)\nAC_ARG_VAR([conf_dir],[sysstat configuration directory])\nif test x$conf_dir != x\"\"; then\n   SYSCONFIG_DIR=$conf_dir\nelse\n   SYSCONFIG_DIR=/etc/sysconfig\nfi\nAC_MSG_RESULT($SYSCONFIG_DIR)\nif test ! -d $SYSCONFIG_DIR; then\n   echo \"INFO: Directory ${SYSCONFIG_DIR} will be created during installation stage.\"\nfi\nAC_SUBST(SYSCONFIG_DIR)\n\n# Set configuration directory\nAC_MSG_CHECKING(sysstat configuration file)\nAC_ARG_VAR([conf_file],[sysstat configuration file])\nif test x$conf_file != x\"\"; then\n   SYSCONFIG_FILE=$conf_file\nelse\n   SYSCONFIG_FILE=sysstat\nfi\nAC_MSG_RESULT($SYSCONFIG_FILE)\nAC_SUBST(SYSCONFIG_FILE)\n\n# National Language Support\nAC_MSG_CHECKING(National Language Support)\nAC_ARG_ENABLE(nls,\n\t      AS_HELP_STRING([--disable-nls],[disable National Language Support]),\n\t\t\t     AUX_NLS=$enableval,AUX_NLS=yes)\nif test $AUX_NLS != \"no\" && test $HAVE_LIBINTL_H && test $HAVE_LOCALE_H; then\n   AUX_NLS=\"yes\"\n   NLS=\"y\"\nelse\n   AUX_NLS=\"no\"\n   NLS=\"n\"\nfi\nAC_MSG_RESULT($AUX_NLS)\nAC_CHECK_LIB(intl, gettext, LFINTL=\"-lintl\")\nAC_SUBST(LFINTL)\nLACKING_GETTEXT=\"n\"\nif test $AUX_NLS = \"yes\" &&  test x$MSGFMT != x\"msgfmt\"; then\n   echo \"WARNING: msgfmt command not found!\"\n   LACKING_GETTEXT=\"y\"\nfi\nif test $AUX_NLS = \"yes\" &&  test x$XGETTEXT != x\"xgettext\"; then\n   echo \"WARNING: xgettext command not found!\"\n   LACKING_GETTEXT=\"y\"\nfi\nif test $AUX_NLS = \"yes\" &&  test x$MSGMERGE != x\"msgmerge\"; then\n   echo \"WARNING: msgmerge command not found!\"\n   LACKING_GETTEXT=\"y\"\nfi\nif test $NLS = \"y\" && test $LACKING_GETTEXT = \"y\"; then\n   echo \"WARNING: Disabling NLS\"\n   NLS=\"n\"\nfi\nAC_SUBST(NLS)\n\n# Link Time Optimization\nAC_MSG_CHECKING(Link Time Optimization support)\nAC_ARG_ENABLE(lto,\n\t      AS_HELP_STRING([--enable-lto],[enable Link Time Optimization]),\n\t\t\t     AUX_LTO=$enableval,AUX_LTO=no)\nAC_MSG_RESULT($AUX_LTO)\nLTO=\"n\"\nif test $AUX_LTO = \"yes\"; then\n\tAC_CHECK_PROG(GCC_AR, gcc-ar, gcc-ar)\n\tif test x$GCC_AR != x\"gcc-ar\"; then\n\t\techo \"WARNING: gcc-ar command not found! Disabling LTO support\"\n\t\tAUX_LTO=\"no\"\n\telse\n\t\tLTO=\"y\"\n\tfi\nfi\nAC_SUBST(LTO)\n\n# Data history to keep by sa2\nAC_MSG_CHECKING(number of daily data files to keep)\nAC_ARG_VAR([history],[number of daily data files to keep (default value is 7)])\nif test x$history = x\"\"; then\n   HISTORY=7\nelse\n   HISTORY=$history\nfi\nAC_MSG_RESULT($HISTORY)\nAC_SUBST(HISTORY)\n\n# Number of days after which datafiles are compressed\nAC_MSG_CHECKING(number of days after which data files are compressed)\nAC_ARG_VAR([compressafter],[number of days after which data files are compressed (default value is 10)])\nif test x$compressafter = x\"\"; then\n   COMPRESSAFTER=10\nelse\n   COMPRESSAFTER=$compressafter\nfi\nAC_MSG_RESULT($COMPRESSAFTER)\nAC_SUBST(COMPRESSAFTER)\n\n# Random delay to wait before sa2 script runs\nAC_MSG_CHECKING(random delay to wait before sa2 script runs)\nAC_ARG_VAR([delay_range],[maximum delay (in seconds) to wait before sa2 script generates its reports])\nif test x$delay_range = x\"\"; then\n   DELAY_RANGE=0\nelse\n   DELAY_RANGE=$delay_range\nfi\nAC_MSG_RESULT($DELAY_RANGE)\nAC_SUBST(DELAY_RANGE)\n\n# Manual page group\ngrep ^man: /etc/group >/dev/null 2>&1\nif test $? = 0; then\n   GRP=man\nelse\n   GRP=root\nfi\n\nAC_MSG_CHECKING(group for manual pages)\nAC_ARG_VAR([man_group],[group for manual pages])\nif test x$man_group = x\"\"; then\n   MAN_GROUP=$GRP\n   AC_MSG_RESULT($MAN_GROUP)\nelse\n   grep ^$man_group: /etc/group >/dev/null 2>&1\n   if test $? = 1; then\n      MAN_GROUP=$GRP\n      AC_MSG_RESULT($MAN_GROUP)\n      echo \"WARNING: Group ${man_group} not found: Using ${GRP} instead\"\n   else\n      MAN_GROUP=$man_group\n      AC_MSG_RESULT($MAN_GROUP)\n   fi\nfi\nAC_SUBST(MAN_GROUP)\n\n# Don't set attributes on files being installed?\nAC_MSG_CHECKING(whether attributes should not be set on files being installed)\nAC_ARG_ENABLE(file-attr,\n\t      AS_HELP_STRING([--disable-file-attr],[do not set attributes on files being installed]),\n\t\t\t     AUX_IMG=$enableval,AUX_IMG=yes)\nif test $AUX_IMG != \"no\"; then\n   IGNORE_FILE_ATTRIBUTES=n\n   AUX_IMG=no\nelse\n   IGNORE_FILE_ATTRIBUTES=y\n   AUX_IMG=yes\nfi\nAC_MSG_RESULT($AUX_IMG)\nAC_SUBST(IGNORE_FILE_ATTRIBUTES)\n\n# Compress manual pages?\nAC_MSG_CHECKING(whether manual pages should be compressed)\nAC_ARG_ENABLE(compress-manpg,\n\t      AS_HELP_STRING([--disable-compress-manpg],[do not compress sysstat manual pages]),\n\t\t\t     AUX_MPG=$enableval,AUX_MPG=yes)\nif test $AUX_MPG != \"yes\"; then\n   COMPRESS_MANPG=n\nelse\n   COMPRESS_MANPG=y\nfi\nAC_MSG_RESULT($AUX_MPG)\nAC_SUBST(COMPRESS_MANPG)\n\n# Check whether sa directory should be cleaned\nAC_MSG_CHECKING(whether system activity directory should be cleaned)\nAC_ARG_ENABLE(clean-sa-dir,\n\t      AS_HELP_STRING([--enable-clean-sa-dir],[clean system activity directory]),\n\t\t\t    AUX_CSD=$enableval,AUX_CSD=no)\nif test $AUX_CSD != \"yes\"; then\n   CLEAN_SA_DIR=n\n   AUX_CSD=no\nelse\n   CLEAN_SA_DIR=y\nfi\nAC_MSG_RESULT($AUX_CSD)\nAC_SUBST(CLEAN_SA_DIR)\n\n# Start crontab\nAC_MSG_CHECKING(whether cron should start sar automatically)\nAC_ARG_ENABLE(install-cron,\n\t      AS_HELP_STRING([--enable-install-cron],[install a crontab to start sar]),\n\t\t\t     INSTALL_CRON=$enableval,INSTALL_CRON=n)\nif test $INSTALL_CRON != \"yes\"; then\n   INSTALL_CRON=n\n   AUX_CRON=no\nelse\n   INSTALL_CRON=y\n   AUX_CRON=yes\nfi\nAC_MSG_RESULT($AUX_CRON)\nAC_SUBST(INSTALL_CRON)\n\n# Crontab owner\nCUSR=\"root\"\nif test $INSTALL_CRON = \"y\"; then\n   AC_MSG_CHECKING(crontab owner)\n   AC_ARG_VAR([cron_owner],[crontab owner])\n   if test x$cron_owner = x\"\"; then\n      CRON_OWNER=$CUSR\n      AC_MSG_RESULT($CRON_OWNER)\n   else\n      grep ^$cron_owner: /etc/passwd >/dev/null 2>&1\n      if test $? = 1; then\n         CRON_OWNER=$CUSR;\n         AC_MSG_RESULT($CRON_OWNER)\n         echo \"WARNING: User ${cron_owner} not found: Using ${CUSR} instead.\"\n      else\n         CRON_OWNER=$cron_owner\n         AC_MSG_RESULT($CRON_OWNER)\n      fi\n   fi\n   echo \"INFO: Crontab for ${CRON_OWNER} will be saved in current directory if necessary\"\n   if test $CRON_OWNER = \"root\"; then\n      SU_C_OWNER=\"\"\n      QUOTE=\"\"\n      REM_CHOWN=\"# REM_CHOWN\"\n   else\n      SU_C_OWNER=\"su $CRON_OWNER -c \"\n      QUOTE=\\\"\n      # \" (ignore this line)\n      REM_CHOWN=$CHOWN\n   fi\n\n#  Check whether we should use the standard cron daemon\n   AC_MSG_CHECKING(whether we should use the standard cron daemon)\n   AC_ARG_ENABLE(use-crond,\n\t         AS_HELP_STRING([--enable-use-crond],[use standard cron daemon]),\n\t\t\t        UCROND=$enableval,UCROND=no)\n   if test $UCROND != \"yes\"; then\n      USE_CROND=n\n      UCROND=no\n   else\n      USE_CROND=y\n   fi\n   AC_MSG_RESULT($UCROND)\n   AC_SUBST(USE_CROND)\n\n#  Crontab interval\n   AC_MSG_CHECKING(crontab interval)\n   AC_ARG_VAR([cron_interval],[crontab interval])\n   if test x$cron_interval = x\"\"; then\n      CRON_INTERVAL=10\n   else\n      CRON_INTERVAL=$cron_interval\n   fi\n   AC_MSG_RESULT($CRON_INTERVAL)\n   CRON_INTERVAL_SEC=`expr ${CRON_INTERVAL} \\* 60`\n   CRON_COUNT=`expr 60 / ${CRON_INTERVAL}`\n\n#  Check whether sadc should collect all possible activities\n   AC_MSG_CHECKING(whether sadc should collect all possible activities)\n   AC_ARG_ENABLE(collect-all,\n\t         AS_HELP_STRING([--enable-collect-all],[collect all possible activities]),\n\t\t\t        COLLECT_ALL=$enableval,COLLECT_ALL=n)\n   if test $COLLECT_ALL != \"yes\"; then\n      COLLECT_ALL=\"\"\n      AUX_COLL=no\n   else\n      COLLECT_ALL=\"-S XALL\"\n      AUX_COLL=yes\n   fi\n   AC_MSG_RESULT($AUX_COLL)\n\n   AC_MSG_CHECKING(options to be passed to sadc)\n   AC_ARG_VAR([sadc_options],[options to be passed to sadc])\n   if test x\"$sadc_options\" != x\"\"; then\n\tSADC_OPT=\"$sadc_options\"\n   else\n\tSADC_OPT=\n   fi\n   AC_MSG_RESULT($SADC_OPT)\n   AC_SUBST(SADC_OPT)\n\n#  Check whether files should only be copied\n   AC_MSG_CHECKING(whether files should only be copied)\n   AC_ARG_ENABLE(copy-only,\n\t         AS_HELP_STRING([--enable-copy-only],[only copy files when installing]),\n\t\t\t        OCOPY=$enableval,OCOPY=no)\n   if test $OCOPY != \"yes\"; then\n      COPY_ONLY=n\n      OCOPY=no\n   else\n      COPY_ONLY=y\n   fi\n   AC_MSG_RESULT($OCOPY)\n   AC_SUBST(COPY_ONLY)\n\nelse\n   CRON_OWNER=\"root\"\n   SU_C_OWNER=\"\"\n   QUOTE=\"\"\n   REM_CHOWN=\"# REM_CHOWN\"\n   CRON_INTERVAL=10\n   CRON_INTERVAL_SEC=600\n   CRON_COUNT=6\n   COLLECT_ALL=\"\"\nfi\nAC_SUBST(CRON_OWNER)\nAC_SUBST(SU_C_OWNER)\nAC_SUBST(CRON_INTERVAL)\nAC_SUBST(CRON_INTERVAL_SEC)\nAC_SUBST(CRON_COUNT)\nAC_SUBST(QUOTE)\nAC_SUBST(REM_CHOWN)\nAC_SUBST(COLLECT_ALL)\n\n# Check whether documentation should be installed\nAC_MSG_CHECKING(whether documentation should be installed)\nAC_ARG_ENABLE(documentation,\n\t      AS_HELP_STRING([--disable-documentation],[do not install documentation]),\n\t\t\t     AUX_DOC=$enableval,AUX_DOC=yes)\nif test $AUX_DOC != \"no\"; then\n   AUX_DOC=\"yes\"\n   INSTALL_DOC=\"y\"\nelse\n   AUX_DOC=\"no\"\n   INSTALL_DOC=\"n\"\nfi\nAC_MSG_RESULT($AUX_DOC)\nAC_SUBST(INSTALL_DOC)\n\n# Set directory for installing manual pages (see comment in Makefile)\nAC_SUBST(mandir)\n\n# Check whether debug mode should be activated\nAC_MSG_CHECKING(whether debug mode should be activated)\nAC_ARG_ENABLE(debuginfo,\n\t      AS_HELP_STRING([--enable-debuginfo],[enable debug output (--debuginfo option)]),\n\t\t\t     WITH_DEBUG=yes ; DFLAGS=\"$DFLAGS -DDEBUG\" , WITH_DEBUG=no)\nAC_MSG_RESULT($WITH_DEBUG)\nAC_SUBST(DFLAGS)\nAC_SUBST(WITH_DEBUG)\n\n# Check whether object files should be stripped\nAC_MSG_CHECKING(whether object files should be stripped)\nAC_ARG_ENABLE(stripping,\n\t      AS_HELP_STRING([--disable-stripping],[do not strip object files]),\n\t\t\t     AUX_STRIP=$enableval,AUX_STRIP=yes)\nif test $AUX_STRIP != \"no\"; then\n   AUX_STRIP=\"yes\"\n   STRIP=\"-s\"\nelse\n   AUX_STRIP=\"no\"\n   STRIP=\nfi\nAC_MSG_RESULT($AUX_STRIP)\nAC_SUBST(STRIP)\n\n# Create files\necho .\necho Now create files:\necho .\nAC_CONFIG_FILES([sa1], [chmod +x sa1])  \t# Permissions must be changed\nAC_CONFIG_FILES([sa2], [chmod +x sa2])\t\t# Permissions must be changed\nAC_CONFIG_FILES([cron/crontab:cron/crontab.sample])\t# File must be renamed\nAC_CONFIG_FILES([sysstat.sysconfig])\nAC_CONFIG_FILES([version.h:version.in])\t\t# File must be renamed\nAC_CONFIG_FILES([sysconfig.h:sysconfig.in])\t# File must be renamed\nAC_CONFIG_FILES([cron/sysstat.cron.daily])\nAC_CONFIG_FILES([cron/sysstat.cron.hourly])\nAC_CONFIG_FILES([cron/sysstat.crond])\nAC_CONFIG_FILES([cron/sysstat.crond.sample.in:cron/sysstat.crond.in], [sed s/^/#/ cron/sysstat.crond.sample.in > cron/sysstat.crond.sample])\nAC_CONFIG_FILES([sysstat], [chmod +x sysstat])\t# Permissions must be changed\nAC_CONFIG_FILES([sysstat.service])\nAC_CONFIG_FILES([cron/sysstat-collect.service])\nAC_CONFIG_FILES([cron/sysstat-collect.timer])\nAC_CONFIG_FILES([cron/sysstat-summary.service])\nAC_CONFIG_FILES([cron/sysstat-summary.timer])\nAC_CONFIG_FILES([cron/sysstat-rotate.service])\nAC_CONFIG_FILES([cron/sysstat-rotate.timer])\nAC_CONFIG_FILES([cron/sysstat.sleep], [chmod +x cron/sysstat.sleep])\t# Permissions must be changed\nAC_CONFIG_FILES([man/sa1.8:man/sa1.in])\t\t# File must be renamed\nAC_CONFIG_FILES([man/sa2.8:man/sa2.in])\t\t# File must be renamed\nAC_CONFIG_FILES([man/sadc.8:man/sadc.in])\t# File must be renamed\nAC_CONFIG_FILES([man/sadf.1:man/sadf.in])\t# File must be renamed\nAC_CONFIG_FILES([man/sar.1:man/sar.in])\t\t# File must be renamed\nAC_CONFIG_FILES([man/sysstat.5:man/sysstat.in])\t# File must be renamed\nAC_CONFIG_FILES([man/iostat.1:man/iostat.in])\t# File must be renamed\nAC_CONFIG_FILES([man/cifsiostat.1:man/cifsiostat.in])\t# File must be renamed\nAC_CONFIG_FILES([tests/variables])\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n\necho \"\n   Sysstat version:\t\t$PACKAGE_VERSION\n   Installation prefix:\t\t$prefix\n   rc directory:\t\t${RC_DIR}\n   Init directory:\t\t${INIT_DIR}\"\nif test \"$UCROND\" != \"yes\"; then\n   echo \"   Systemd unit dir:\t\t${with_systemdsystemunitdir}\"\n   echo \"   Systemd sleep dir:\t\t${with_systemdsleepdir}\"\nelse\n   echo \"   Use standard cron daemon\"\nfi\necho \"   Configuration file:\t\t${SYSCONFIG_DIR}/${SYSCONFIG_FILE}\n   Man pages directory:\t\t$mandir\n   Compiler:\t\t\t$CC\n   Compiler flags:\t\t$CFLAGS\n   Linker flags:\t\t$LDFLAGS\n\"\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "count.c",
          "type": "blob",
          "size": 13.7236328125,
          "content": "/*\n * count.c: Count items for which statistics will be collected.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <unistd.h>\n\n#include \"common.h\"\n#include \"rd_stats.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n\n/*\n ***************************************************************************\n * Count number of processors in /sys.\n *\n * IN:\n * @highest\tIf set to TRUE, then look for the highest processor number.\n * \t\tThis is used when eg. the machine has 4 CPU numbered 0, 1, 4\n *\t\tand 5. In this case, this procedure will return 6.\n *\n * RETURNS:\n * Number of processors (online and offline).\n * A value of 0 means that /sys was not mounted.\n * A value of N (!=0) means N processor(s) (cpu0 .. cpu(N-1)).\n ***************************************************************************\n */\nint get_sys_cpu_nr(int highest)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\tstruct stat buf;\n\tchar line[MAX_PF_NAME];\n\tint num_proc, proc_nr = -1;\n\n\t/* Open relevant /sys directory */\n\tif ((dir = opendir(SYSFS_DEVCPU)) == NULL)\n\t\treturn 0;\n\n\t/* Get current file entry */\n\twhile ((drd = readdir(dir)) != NULL) {\n\n\t\tif (!strncmp(drd->d_name, \"cpu\", 3) && isdigit(drd->d_name[3])) {\n\t\t\tsnprintf(line, sizeof(line), \"%s/%s\", SYSFS_DEVCPU, drd->d_name);\n\t\t\tline[sizeof(line) - 1] = '\\0';\n\t\t\tif (stat(line, &buf) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (S_ISDIR(buf.st_mode)) {\n\t\t\t\tif (highest) {\n\t\t\t\t\tsscanf(drd->d_name + 3, \"%d\", &num_proc);\n\t\t\t\t\tif (num_proc > proc_nr) {\n\t\t\t\t\t\tproc_nr = num_proc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tproc_nr++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Close directory */\n\tclosedir(dir);\n\n\treturn (proc_nr + 1);\n}\n\n/*\n ***************************************************************************\n * Count number of processors in /proc/stat.\n *\n * RETURNS:\n * Number of processors. The returned value is greater than or equal to the\n * number of online processors.\n * A value of 0 means one processor and non SMP kernel.\n * A value of N (!=0) means N processor(s) (0 .. N-1) with SMP kernel.\n ***************************************************************************\n */\nint get_proc_cpu_nr(void)\n{\n\tFILE *fp;\n\tchar line[16];\n\tint num_proc, proc_nr = -1;\n\n\tif ((fp = fopen(STAT, \"r\")) == NULL) {\n\t\tfprintf(stderr, _(\"Cannot open %s: %s\\n\"), STAT, strerror(errno));\n\t\texit(1);\n\t}\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (strncmp(line, \"cpu \", 4) && !strncmp(line, \"cpu\", 3)) {\n\t\t\tsscanf(line + 3, \"%d\", &num_proc);\n\t\t\tif (num_proc > proc_nr) {\n\t\t\t\tproc_nr = num_proc;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tproc_nr++;\n\treturn proc_nr;\n}\n\n/*\n ***************************************************************************\n * Count the number of processors on the machine, or look for the\n * highest processor number.\n * Try to use /sys for that, or /proc/stat if /sys doesn't exist.\n *\n * IN:\n * @max_nr_cpus\tMaximum number of proc that sysstat can handle.\n * @highest\tIf set to TRUE, then look for the highest processor number.\n * \t\tThis is used when eg. the machine has 4 CPU numbered 0, 1, 4\n *\t\tand 5. In this case, this procedure will return 6.\n *\n * RETURNS:\n * Number of processors.\n * 0: one proc and non SMP kernel.\n * 1: one proc and SMP kernel (NB: On SMP machines where all the CPUs but\n *    one have been disabled, we get the total number of proc since we use\n *    /sys to count them).\n * 2: two proc...\n *\n * USED BY:\n * sadc, cifsiostat, iostat, mpstat, pidstat, tapestat\n ***************************************************************************\n */\n__nr_t get_cpu_nr(unsigned int max_nr_cpus, int highest)\n{\n\t__nr_t cpu_nr;\n\n\tif ((cpu_nr = get_sys_cpu_nr(highest)) == 0) {\n\t\t/* /sys may be not mounted. Use /proc/stat instead */\n\t\tcpu_nr = get_proc_cpu_nr();\n\t}\n\n\tif (cpu_nr > max_nr_cpus) {\n\t\tfprintf(stderr, _(\"Cannot handle so many processors!\\n\"));\n\t\texit(1);\n\t}\n\n\treturn cpu_nr;\n}\n\n/*\n ***************************************************************************\n * Find number of interrupts available per processor (use\n * /proc/interrupts file or /proc/softirqs).\n *\n * IN:\n * @file\t\t/proc file to read (interrupts or softirqs).\n * @max_nr_irqcpu       Maximum number of interrupts per processor that\n *                      sadc can handle.\n * @cpu_nr\t\tNumber of processors.\n *\n * RETURNS:\n * Number of interrupts per processor.\n *\n * USED BY:\n * sadc, mpstat\n ***************************************************************************\n */\n__nr_t get_irqcpu_nr(char *file, int max_nr_irqcpu, int cpu_nr)\n{\n\tFILE *fp;\n\tchar *line = NULL;\n\t__nr_t irq = 0;\n\tint p;\n\n\tif ((fp = fopen(file, \"r\")) == NULL)\n\t\treturn 0;       /* No interrupts file */\n\n\tSREALLOC(line, char, INTERRUPTS_LINE + 11 * cpu_nr);\n\n\twhile ((fgets(line, INTERRUPTS_LINE + 11 * cpu_nr , fp) != NULL) &&\n\t       (irq < max_nr_irqcpu)) {\n\n\t\tp = strcspn(line, \":\");\n\t\tif ((p > 0) && (p < 16)) {\n\t\t\tirq++;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tfree(line);\n\n\treturn irq;\n}\n\n#ifdef SOURCE_SADC\n/*---------------- BEGIN: FUNCTIONS USED BY SADC ONLY ---------------------*/\n\n/*\n ***************************************************************************\n * Find number of devices and partitions available in /proc/diskstats.\n *\n * IN:\n * @count_part\t\tSet to TRUE if devices _and_ partitions are to be\n *\t\t\tcounted.\n * @only_used_dev\tWhen counting devices, set to TRUE if only devices\n *\t\t\twith non zero stats must be counted.\n *\n * RETURNS:\n * Number of devices (and partitions).\n ***************************************************************************\n */\n__nr_t get_diskstats_dev_nr(int count_part, int only_used_dev)\n{\n\tFILE *fp;\n\tchar line[256];\n\tchar dev_name[MAX_NAME_LEN];\n\t__nr_t dev = 0;\n\tint i;\n\tunsigned long rd_ios, wr_ios;\n\n\tif ((fp = fopen(DISKSTATS, \"r\")) == NULL)\n\t\t/* File non-existent */\n\t\treturn 0;\n\n\t/*\n\t * Counting devices and partitions is simply a matter of counting\n\t * the number of lines...\n\t */\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!count_part) {\n\t\t\ti = sscanf(line, \"%*d %*d %127s %lu %*u %*u %*u %lu\",\n\t\t\t\t   dev_name, &rd_ios, &wr_ios);\n\t\t\tif ((i == 2) || !is_device(SLASH_SYS, dev_name, ACCEPT_VIRTUAL_DEVICES))\n\t\t\t\t/* It was a partition and not a device */\n\t\t\t\tcontinue;\n\t\t\tif (only_used_dev && !rd_ios && !wr_ios)\n\t\t\t\t/* Unused device */\n\t\t\t\tcontinue;\n\t\t}\n\t\tdev++;\n\t}\n\n\tfclose(fp);\n\n\treturn dev;\n}\n\n/*\n ***************************************************************************\n * Find number of serial lines that support tx/rx accounting\n * in /proc/tty/driver/serial file.\n *\n * RETURNS:\n * Number of serial lines supporting tx/rx accouting.\n ***************************************************************************\n */\n__nr_t get_serial_nr(void)\n{\n\tFILE *fp;\n\tchar line[256];\n\t__nr_t sl = 0;\n\n\tif ((fp = fopen(SERIAL, \"r\")) == NULL)\n\t\treturn 0;\t/* No SERIAL file */\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\t/*\n\t\t * tx/rx statistics are always present,\n\t\t * except when serial line is unknown.\n\t\t */\n\t\tif (strstr(line, \"tx:\") != NULL) {\n\t\t\tsl++;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn sl;\n}\n\n/*\n ***************************************************************************\n * Find number of interfaces (network devices) that are in /proc/net/dev\n * file.\n *\n * RETURNS:\n * Number of network interfaces.\n ***************************************************************************\n */\n__nr_t get_iface_nr(void)\n{\n\tFILE *fp;\n\tchar line[128];\n\t__nr_t iface = 0;\n\n\tif ((fp = fopen(NET_DEV, \"r\")) == NULL)\n\t\treturn 0;\t/* No network device file */\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\tif (strchr(line, ':')) {\n\t\t\tiface++;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn iface;\n}\n\n/*\n ***************************************************************************\n * Get number of devices in /proc/diskstats.\n *\n * IN:\n * @f\tNon zero (true) if disks *and* partitions should be counted, and\n *\tzero (false) if only disks must be counted.\n *\n * RETURNS:\n * Number of devices.\n ***************************************************************************\n */\n__nr_t get_disk_nr(unsigned int f)\n{\n\t__nr_t disk_nr;\n\n\t/*\n\t * Partitions are taken into account by sar -d only with\n\t * kernels 2.6.25 and later.\n\t */\n\tdisk_nr = get_diskstats_dev_nr(f, CNT_USED_DEV);\n\n\treturn disk_nr;\n}\n\n/*\n ***************************************************************************\n * Count number of possible frequencies for CPU#0.\n *\n * RETURNS:\n * Number of frequencies.\n ***************************************************************************\n */\n__nr_t get_freq_nr(void)\n{\n\tFILE *fp;\n\tchar filename[MAX_PF_NAME];\n\tchar line[128];\n\t__nr_t freq = 0;\n\n\tsnprintf(filename, MAX_PF_NAME, \"%s/cpu0/%s\",\n\t\t SYSFS_DEVCPU, SYSFS_TIME_IN_STATE);\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\t/* No time_in_state file for CPU#0 */\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\tfreq++;\n\t}\n\n\tfclose(fp);\n\n\treturn freq;\n}\n\n/*\n ***************************************************************************\n * Count number of USB devices in /sys/bus/usb/devices.\n *\n * RETURNS:\n * Number of USB devices plugged into the system.\n * Don't count USB root hubs.\n * Return -1 if directory doesn't exist in sysfs.\n ***************************************************************************\n */\n__nr_t get_usb_nr(void)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\t__nr_t usb = 0;\n\n\t/* Open relevant /sys directory */\n\tif ((dir = opendir(SYSFS_USBDEV)) == NULL)\n\t\treturn -1;\n\n\t/* Get current file entry */\n\twhile ((drd = readdir(dir)) != NULL) {\n\n\t\tif (isdigit(drd->d_name[0]) && !strchr(drd->d_name, ':')) {\n\t\t\tusb++;\n\t\t}\n\t}\n\n\t/* Close directory */\n\tclosedir(dir);\n\n\treturn usb;\n}\n\n/*\n ***************************************************************************\n * Find number of filesystems in /etc/mtab. Pseudo-filesystems are ignored.\n *\n * RETURNS:\n * Number of filesystems.\n ***************************************************************************\n */\n__nr_t get_filesystem_nr(void)\n{\n\tFILE *fp;\n\tchar line[512], fs_name[MAX_FS_LEN], mountp[256], type[128];\n\tchar *pos = 0, *pos2 = 0;\n\t__nr_t fs = 0;\n\tint skip, skip_next = 0;\n\tstruct statvfs buf;\n\n\tif ((fp = fopen(MTAB, \"r\")) == NULL)\n\t\t/* File non-existent */\n\t\treturn 0;\n\n\t/* Get current filesystem */\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\t/*\n\t\t * Ignore line if the preceding line did not contain '\\n'.\n\t\t * (Some very long lines may be found for instance when\n\t\t * overlay2 filesystem with docker is used).\n\t\t */\n\t\tskip = skip_next;\n\t\tskip_next = (strchr(line, '\\n') == NULL);\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tif (line[0] == '/') {\n\t\t\t/* Find field separator position */\n\t\t\tpos = strchr(line, ' ');\n\t\t\tif (pos == NULL)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Find second field separator position,\n\t\t\t * read filesystem type,\n\t\t\t * if filesystem type is autofs, skip it\n\t\t\t*/\n\t\t\tpos2 = strchr(pos + 1, ' ');\n\t\t\tif (pos2 == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tsscanf(pos2 + 1, \"%127s\", type);\n\t\t\tif (strcmp(type, \"autofs\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* Read filesystem name and mount point */\n\t\t\tsscanf(line, \"%127s\", fs_name);\n\t\t\tsscanf(pos + 1, \"%255s\", mountp);\n\n\t\t\t/* Replace octal codes */\n\t\t\toct2chr(mountp);\n\n\t\t\t/* Check that total size is not zero */\n\t\t\tif (__statvfs(mountp, &buf) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (buf.f_blocks) {\n\t\t\t\tfs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn fs;\n}\n\n/*\n ***************************************************************************\n * Find number of fibre channel hosts in /sys/class/fc_host/.\n *\n * RETURNS:\n * Number of FC hosts.\n * Return -1 if directory doesn't exist in sysfs.\n ***************************************************************************\n */\n__nr_t get_fchost_nr(void)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\t__nr_t fc = 0;\n\n\tif ((dir = opendir(SYSFS_FCHOST)) == NULL) {\n\t\t/* Directory non-existent */\n\t\treturn -1;\n\t}\n\n\twhile ((drd = readdir(dir)) != NULL) {\n\n\t\tif (!strncmp(drd->d_name, \"host\", 4)) {\n\t\t\tfc++;\n\t\t}\n\t}\n\n\t/* Close directory */\n\tclosedir(dir);\n\n\treturn fc;\n}\n\n/*\n * **************************************************************************\n * Find number of batteries in /sys/class/power_supply/.\n * Assume that batteries keep their id number (0, 1...) as long as the\n * computer is not restarted.\n *\n * RETURNS:\n * Number of batteries.\n * Return -1 if directory doesn't exist in sysfs.\n ***************************************************************************\n */\n__nr_t get_bat_nr(void)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\t__nr_t bat = 0;\n\n\tif ((dir = opendir(SYSFS_PWR_SUPPLY)) == NULL) {\n\t\t/* Directory non-existent */\n\t\treturn -1;\n\t}\n\n\twhile ((drd = readdir(dir)) != NULL) {\n\n\t\tif (!strncmp(drd->d_name, \"BAT\", 3) && isdigit(drd->d_name[3])) {\n\t\t\tbat++;\n\t\t}\n\t}\n\n\t/* Close directory */\n\tclosedir(dir);\n\n\treturn bat;\n}\n\n/*------------------ END: FUNCTIONS USED BY SADC ONLY ---------------------*/\n#endif /* SOURCE_SADC */\n"
        },
        {
          "name": "count.h",
          "type": "blob",
          "size": 0.802734375,
          "content": "/*\n * count.h: Include file used to count items for which\n * statistics will be collected.\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _COUNT_H\n#define _COUNT_H\n\n#include \"common.h\"\n\n/*\n ***************************************************************************\n * Prototypes for functions used to count number of items.\n ***************************************************************************\n */\n\n__nr_t get_cpu_nr\n\t(unsigned int, int);\n__nr_t get_irqcpu_nr\n\t(char *, int, int);\n__nr_t get_diskstats_dev_nr\n\t(int, int);\n__nr_t get_serial_nr\n\t(void);\n__nr_t get_iface_nr\n\t(void);\n__nr_t get_disk_nr\n\t(unsigned int);\n__nr_t get_freq_nr\n\t(void);\n__nr_t get_usb_nr\n\t(void);\n__nr_t get_filesystem_nr\n\t(void);\n__nr_t get_fchost_nr\n\t(void);\n__nr_t get_bat_nr\n\t(void);\n\n#endif /* _COUNT_H */\n"
        },
        {
          "name": "cron",
          "type": "tree",
          "content": null
        },
        {
          "name": "do_test",
          "type": "blob",
          "size": 2.1396484375,
          "content": "#!/bin/sh\n# Script for sysstat simulation test environment\n# (C) 2020-2024 Sebastien GODARD (sysstat <at> orange.fr)\n\nif [ \"$1\" = \"conf\" ]\nthen\n\t# Configure sysstat in test mode\n\tmake distclean\n\t./configure sa_lib_dir=. sar_dir=. conf_dir=. conf_file=sysstat.sysconfig sa_dir=tests --enable-debuginfo --disable-stripping\nelif [ \"$1\" = \"conflto\" ]\nthen\n\t# Configure sysstat in test mode with LTO support\n\tmake distclean\n\t./configure sa_lib_dir=. sar_dir=. conf_dir=. conf_file=sysstat.sysconfig sa_dir=tests --enable-debuginfo --enable-lto --disable-stripping\nelif [ \"$1\" = \"comp\" ]\nthen\n\t# Compile sysstat in test mode\n\tmake simtest TFLAGS=\"-DTEST\"\nelse\n\tif [ \"$1\" != \"sim\" ]\n\tthen\n\t\t# Configure then compile sysstat in test mode\n\t\tmake distclean\n#\t\t./configure sa_lib_dir=. sar_dir=. conf_dir=. conf_file=sysstat.sysconfig sa_dir=tests --enable-debuginfo && make TFLAGS=\"-DTEST\" && make simtest\n\t\t./configure sa_lib_dir=. sar_dir=. conf_dir=. conf_file=sysstat.sysconfig sa_dir=tests --enable-debuginfo --disable-stripping && make simtest TFLAGS=\"-DTEST\"\n\tfi\n\trm -f tests/results.tmp\n\tCOUNT=0\n\tTOTAL=`ls -1 tests/0* | wc -l`\n\n\tLIST=`ls tests | grep -E '^[0-9]+$' | sort -n`\n\n\tfor f in ${LIST}; do\n\n\t\tif [ \"$2\" = cont -a -f tests/LAST ]\n\t\tthen\n\t\t\tL=`cat tests/LAST`\n\t\t\tif [ $f -lt $L ]\n\t\t\tthen\n\t\t\t\tcontinue\n\t\t\telse\n\t\t\t\trm -f tests/LAST\n\t\t\tfi\n\t\tfi\n\n\t\tlet \"COUNT+=1\"\n\t\techo $f\n\t\techo -n \"$f: \" >> tests/results.tmp\n\t\tcat tests/$f | /bin/sh\n\n\t\tif [ $? -eq 0 ]\n\t\tthen\n\t\t\tif [ -f tests/SKIPPED ]\n\t\t\tthen\n\t\t\t\techo Skipped. >> tests/results.tmp\n\t\t\t\trm tests/SKIPPED;\n\t\t\telse\n\t\t\t\techo Success! >> tests/results.tmp;\n\t\t\tfi\n\t\telse\n\t\t\techo Failed... >> tests/results.tmp;\n\t\t\techo $f > tests/LAST;\n\t\t\tif [ \"$1\" != \"ignore\" -a \"$2\" != \"ignore\" ]\n\t\t\tthen\n\t\t\t\texit\n\t\t\tfi\n\t\tfi\n\tdone\n\trm -f tests/root\n\tln -s root1 tests/root\n\techo Run ${COUNT}/${TOTAL} test\\(s\\)\n\techo Simulation tests: Success!\nfi\n\nif [ \"$?\" = \"0\" -a \"$1\" = \"all\" ]\nthen\n\tmake extratest && make distclean && ./configure --disable-nls --disable-sensors --disable-pcp sa_lib_dir=. sar_dir=. conf_dir=. conf_file=sysstat.sysconfig sa_dir=tests --enable-debuginfo --disable-stripping && make TFLAGS=\"-DTEST\" && echo \"EXTRA TESTS: Success!\"\nfi\n"
        },
        {
          "name": "format.c",
          "type": "blob",
          "size": 4.984375,
          "content": "/*\n * format.c: Output format definitions for sadf and sar\n * (C) 2011-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#ifdef SOURCE_SADF\n#include \"sadf.h\"\n#endif\n\n#ifdef SOURCE_SAR\n#include \"sa.h\"\n#endif\n\n/*\n ***************************************************************************\n * Definitions of output formats.\n * See sadf.h file for format structure definition.\n ***************************************************************************\n */\n\n#ifdef SOURCE_SADF\n/*\n * Display only datafile header.\n */\nstruct report_format hdr_fmt = {\n\t.id\t\t= F_HEADER_OUTPUT,\n\t.options\t= FO_HEADER_ONLY,\n\t.f_header\t= print_hdr_header,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= NULL,\n\t.f_restart\t= NULL,\n\t.f_comment\t= NULL,\n\t.f_display\t= NULL\n};\n\n/*\n * Database friendly format.\n */\nstruct report_format db_fmt = {\n\t.id\t\t= F_DB_OUTPUT,\n\t.options\t= FO_LOCAL_TIME + FO_HORIZONTALLY +\n\t\t\t  FO_SEC_EPOCH + FO_FIELD_LIST,\n\t.f_header\t= NULL,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= print_db_timestamp,\n\t.f_restart\t= print_db_restart,\n\t.f_comment\t= print_db_comment,\n\t.f_display\t= logic2_display_loop\n};\n\n/*\n * Format easily handled by pattern processing commands like awk.\n */\nstruct report_format ppc_fmt = {\n\t.id\t\t= F_PPC_OUTPUT,\n\t.options\t= FO_LOCAL_TIME + FO_SEC_EPOCH,\n\t.f_header\t= NULL,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= print_ppc_timestamp,\n\t.f_restart\t= print_ppc_restart,\n\t.f_comment\t= print_ppc_comment,\n\t.f_display\t= logic2_display_loop\n};\n\n/*\n * XML output.\n */\nstruct report_format xml_fmt = {\n\t.id\t\t= F_XML_OUTPUT,\n\t.options\t= FO_HEADER_ONLY + FO_LOCAL_TIME + FO_TEST_MARKUP,\n\t.f_header\t= print_xml_header,\n\t.f_statistics\t= print_xml_statistics,\n\t.f_timestamp\t= print_xml_timestamp,\n\t.f_restart\t= print_xml_restart,\n\t.f_comment\t= print_xml_comment,\n\t.f_display\t= logic1_display_loop\n};\n\n/*\n * JSON output.\n */\nstruct report_format json_fmt = {\n\t.id\t\t= F_JSON_OUTPUT,\n\t.options\t= FO_HEADER_ONLY + FO_LOCAL_TIME + FO_TEST_MARKUP +\n\t\t\t  FO_LC_NUMERIC_C,\n\t.f_header\t= print_json_header,\n\t.f_statistics\t= print_json_statistics,\n\t.f_timestamp\t= print_json_timestamp,\n\t.f_restart\t= print_json_restart,\n\t.f_comment\t= print_json_comment,\n\t.f_display\t= logic1_display_loop\n};\n\n/*\n * Convert an old datafile to up-to-date format.\n */\nstruct report_format conv_fmt = {\n\t.id\t\t= F_CONV_OUTPUT,\n\t.options\t= 0,\n\t.f_header\t= NULL,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= NULL,\n\t.f_restart\t= NULL,\n\t.f_comment\t= NULL,\n\t.f_display\t= NULL\n};\n\n/*\n * SVG output.\n */\nstruct report_format svg_fmt = {\n\t.id\t\t= F_SVG_OUTPUT,\n\t.options\t= FO_HEADER_ONLY + FO_LOCAL_TIME +\n\t\t\t  FO_LC_NUMERIC_C,\n\t.f_header\t= print_svg_header,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= NULL,\n\t.f_restart\t= NULL,\n\t.f_comment\t= NULL,\n\t.f_display\t= svg_display_loop\n};\n\n/*\n * Raw output.\n */\nstruct report_format raw_fmt = {\n\t.id\t\t= F_RAW_OUTPUT,\n\t.options\t= FO_LOCAL_TIME + FO_SEC_EPOCH,\n\t.f_header\t= NULL,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= print_raw_timestamp,\n\t.f_restart\t= print_raw_restart,\n\t.f_comment\t= print_raw_comment,\n\t.f_display\t= logic2_display_loop\n};\n\n/*\n * PCP output.\n */\nstruct report_format pcp_fmt = {\n\t.id\t\t= F_PCP_OUTPUT,\n\t.options\t= FO_HEADER_ONLY + FO_LOCAL_TIME + FO_NO_TRUE_TIME +\n\t\t\t  FO_ITEM_LIST + FO_FULL_ORDER,\n\t.f_header\t= print_pcp_header,\n\t.f_statistics\t= print_pcp_statistics,\n\t.f_timestamp\t= print_pcp_timestamp,\n\t.f_restart\t= print_pcp_restart,\n\t.f_comment\t= print_pcp_comment,\n\t.f_display\t= logic1_display_loop\n};\n\n/*\n * Array of output formats.\n */\nstruct report_format *fmt[NR_FMT] = {\n\t&hdr_fmt,\n\t&db_fmt,\n\t&ppc_fmt,\n\t&xml_fmt,\n\t&json_fmt,\n\t&conv_fmt,\n\t&svg_fmt,\n\t&raw_fmt,\n\t&pcp_fmt\n};\n#endif\n\n#ifdef SOURCE_SAR\n/*\n * Special output format for sar.\n * Used only for functions to display special\n * (RESTART and COMMENT) records.\n */\nstruct report_format sar_fmt = {\n\t.id\t\t= F_SAR_OUTPUT,\n\t.options\t= 0,\n\t.f_header\t= NULL,\n\t.f_statistics\t= NULL,\n\t.f_timestamp\t= NULL,\n\t.f_restart\t= print_sar_restart,\n\t.f_comment\t= print_sar_comment\n};\n#endif\n"
        },
        {
          "name": "iconfig",
          "type": "blob",
          "size": 7.7587890625,
          "content": "#!/bin/sh\n#@(#) Configuration script for sysstat\n# (C) 2000-2024 Sebastien GODARD (sysstat <at> orange.fr)\n\nif [ \"$1\" = \"xlocal\" ]\nthen\n\techo\n\techo -n \"./configure sa_lib_dir=. sa_dir=. conf_dir=. conf_file=sysstat.sysconfig\"\n\techo\n\t./configure sa_lib_dir=. sa_dir=. sar_dir=. conf_dir=. conf_file=sysstat.sysconfig\n\texit\nelif [ \"$1\" = \"local\" ]\nthen\n\t# This mode is just to make sure that sar will call sadc located in current directory\n\techo\n\techo -n \"./configure sa_lib_dir=.\"\n\techo\n\t./configure sa_lib_dir=.\n\texit\nelif [ \"$1\" = \"debug\" ]\nthen\n\techo\n\techo -n \"./configure sa_lib_dir=. --enable-debuginfo --disable-stripping\"\n\techo\n\t./configure sa_lib_dir=. --enable-debuginfo --disable-stripping\n\texit\nfi\n\nASK=\"sh build/Ask.sh\"\n\necho ; echo\necho Welcome to sysstat\\'s  Interactive Configuration script!\necho\necho This script enables you to set the parameters value used by ./configure.\necho Please enter the value for the parameters listed below.\necho Press Return to tell ./configure to use the default value or to try to guess the proper one.\necho \"Default value for yes/no questions is no (parameter is NOT set).\"\necho You can enter a ? to display a help message at any time...\necho\n\n# Syntax: Ask <QUESTION> <PARM> <TEXT_FILE>\n\n# Installation directory\nPREFIX=`${ASK} 'Installation directory:' \"--prefix\" \"prefix\"`\nif [ \"${PREFIX}\" != \"\" ]; then\n\tPREFIX=\"--prefix=${PREFIX} \"\nfi\n\n# sadc directory\nSA_LIB_DIR=`${ASK} 'sadc directory:' \"sa_lib_dir\" \"sa_lib_dir\"`\nif [ \"${SA_LIB_DIR}\" != \"\" ]; then\n\tSA_LIB_DIR=\"sa_lib_dir=${SA_LIB_DIR} \"\nfi\n\n# System Activity directory\nSA_DIR=`${ASK} 'System activity directory:' \"sa_dir\" \"sa_dir\"`\nif [ \"${SA_DIR}\" != \"\" ]; then\n\tSA_DIR=\"sa_dir=${SA_DIR} \"\nfi\n\n# sysstat configuration directory\nSYSCONFIG_DIR=`${ASK} 'sysstat configuration directory:' \"conf_dir\" \"conf_dir\"`\nif [ \"${SYSCONFIG_DIR}\" != \"\" ]; then\n\tSYSCONFIG_DIR=\"conf_dir=${SYSCONFIG_DIR} \"\nfi\n\n# sysstat configuration file\nSYSCONFIG_FILE=`${ASK} 'sysstat configuration file:' \"conf_file\" \"conf_file\"`\nif [ \"${SYSCONFIG_FILE}\" != \"\" ]; then\n\tSYSCONFIG_FILE=\"conf_file=${SYSCONFIG_FILE} \"\nfi\n\n# Clean sa directory\nCLEAN_SA_DIR=`${ASK} 'Clean system activity directory? (y/n)' \"--enable-clean-sa-dir\" \"clean-sa-dir\"`\nif [ \"${CLEAN_SA_DIR}\" = \"y\" ]; then\n\tCLEAN_SA_DIR=\"--enable-clean-sa-dir \"\nelse\n\tCLEAN_SA_DIR=\"\"\n\techo \"Parameter --enable-clean-sa-dir is NOT set\"\nfi\n\n# National Language Support\nNLS=`${ASK} 'Disable National Language Support (NLS)? (y/n)' \"--disable-nls\" \"nls\"`\nif [ \"${NLS}\" = \"y\" ]; then\n\tNLS=\"--disable-nls \"\nelse\n\tNLS=\"\"\n\techo \"Parameter --disable-nls is NOT set\"\nfi\n\n# Link Time Optimization support\nLTO=`${ASK} 'Compile with Link Time Optimizations (LTO)? (y/n)' \"--enable-lto\" \"lto\"`\nif [ \"${LTO}\" = \"y\" ]; then\n\tLTO=\"--enable-lto \"\nelse\n\tLTO=\"\"\n\techo \"Parameter --enable-lto is NOT set\"\nfi\n\n# Sensors support\nSENSORS=`${ASK} 'Disable sensors support? (y/n)' \"--disable-sensors\" \"sensors\"`\nif [ \"${SENSORS}\" = \"y\" ]; then\n\tSENSORS=\"--disable-sensors \"\nelse\n\tSENSORS=\"\"\n\techo \"Parameter --disable-sensors is NOT set\"\nfi\n\n# PCP support\nPCP=`${ASK} 'Disable PCP support? (y/n)' \"--disable-pcp\" \"pcp\"`\nif [ \"${PCP}\" = \"y\" ]; then\n\tPCP=\"--disable-pcp \"\nelse\n\tPCP=\"\"\n\techo \"Parameter --disable-pcp is NOT set\"\nfi\n\n# Data history to keep by sa2\nHISTORY=`${ASK} 'Number of daily data files to keep:' \"history\" \"history\"`\nif [ \"${HISTORY}\" != \"\" ]; then\n\tHISTORY=\"history=${HISTORY} \"\nfi\n\n# Random delay before sa2 script generates its reports files\nDELAY_RANGE=`${ASK} 'Maximum delay in seconds to wait before sa2 script runs:' \"delay_range\" \"delay_range\"`\nif [ \"${DELAY_RANGE}\" != \"\" ]; then\n\tDELAY_RANGE=\"delay_range=${DELAY_RANGE} \"\nfi\n\n# Delay after which datafiles are to be compressed\nCOMPRESSAFTER=`${ASK} 'Number of days after which sar datafiles must be compressed:' \"compressafter\" \"compressafter\"`\nif [ \"${COMPRESSAFTER}\" != \"\" ]; then\n\tCOMPRESSAFTER=\"compressafter=${COMPRESSAFTER} \"\nfi\n\n# Manual page group\nMAN=`${ASK} 'Group for manual pages:' \"man_group\" \"man_group\"`\nif [ \"${MAN}\" != \"\" ]; then\n\tMAN=\"man_group=${MAN} \"\nfi\n\n# Don't set attributes on files being installed\nIGNORE_FILE_ATTR=`${ASK} 'Do not set attributes on files being installed? (y/n)' \"--disable-file-attr\" \"ignore-file-attr\"`\nif [ \"${IGNORE_FILE_ATTR}\" = \"y\" ]; then\n\tIGNORE_FILE_ATTR=\"--disable-file-attr \"\nelse\n\tIGNORE_FILE_ATTR=\"\"\n\techo \"Parameter --disable-file-attr is NOT set\"\nfi\n\n# Crontab\nCRON=`${ASK} 'Set crontab to start sar automatically? (y/n)' \"--enable-install-cron\" \"install-cron\"`\nif [ \"${CRON}\" = \"y\" ]; then\n\tCRON=\"--enable-install-cron \"\nelse\n\tCRON=\"\"\n\techo \"Parameter --enable-install-cron is NOT set\"\nfi\n\nif [ \"${CRON}\" != \"\" ];\nthen\n\tCRON_OWNER=`${ASK} 'Crontab owner:' \"cron_owner\" \"cron_owner\"`\n\tif [ \"${CRON_OWNER}\" != \"\" ]; then\n\t\tCRON=\"${CRON}cron_owner=${CRON_OWNER} \"\n\tfi\nfi\n\nif [ \"${CRON}\" != \"\" ];\nthen\n\tUSE_CROND=`${ASK} 'Use standard cron daemon? (y/n)' \"--enable-use-crond\" \"use-crond\"`\n\tif [ \"${USE_CROND}\" = \"y\" ]; then\n\t\tUSE_CROND=\"--enable-use-crond \"\n\telse\n\t\tUSE_CROND=\"\"\n\t\techo \"Parameter --enable-use-crond is NOT set\"\n\tfi\nfi\n\nif [ \"${CRON}\" != \"\" ];\nthen\n\tCRON_INTERVAL=`${ASK} 'Crontab sampling interval (in minutes):' \"cron_interval\" \"cron_interval\"`\n\tif [ \"${CRON_INTERVAL}\" != \"\" ]; then\n\t\tCRON=\"${CRON}cron_interval=${CRON_INTERVAL} \"\n\tfi\nfi\n\nif [ \"${CRON}\" != \"\" ];\nthen\n\tCOLL_ALL=`${ASK} 'Should sadc collect optional activities? (y/n)' \"--enable-collect-all\" \"collect-all\"`\n\tif [ \"${COLL_ALL}\" = \"y\" ]; then\n\t\tCRON=\"${CRON}--enable-collect-all \"\n\telse\n\t\techo \"Parameter --enable-collect-all is NOT set\"\n\tfi\nfi\n\nif [ \"${CRON}\" != \"\" -a \"${COLL_ALL}\" != \"y\" ];\nthen\n\t# Optional args for sadc\n\tSADC_OPT=`${ASK} 'Options to be passed to sadc:' \"sadc_options\" \"sadc_options\"`\nelse\n\tSADC_OPT=\nfi\n\nif [ \"${CRON}\" != \"\" ];\nthen\n\t# rc directory\n\tRCDIR=`${ASK} 'rc directory:' \"rcdir\" \"rcdir\"`\n\tif [ \"${RCDIR}\" != \"\" ]; then\n\t        RCDIR=\"rcdir=${RCDIR} \"\n\tfi\nfi\n\nif [ \"${CRON}\" != \"\" ];\nthen\n\t# Only copy files\n\tCOPY_ONLY=`${ASK} 'Only copy files when installing sysstat? (y/n)' \"--enable-copy-only\" \"copy-only\"`\n\tif [ \"${COPY_ONLY}\" = \"y\" ]; then\n\t\tCOPY_ONLY=\"--enable-copy-only \"\n\telse\n\t\tCOPY_ONLY=\"\"\n\t\techo \"Parameter --enable-copy-only is NOT set\"\n\tfi\nfi\n\n# Compress manual pages\nCOMPRESSMANPG=`${ASK} 'Do not compress manual pages? (y/n)' \"--disable-compress-manpg\" \"compress-manpg\"`\nif [ \"${COMPRESSMANPG}\" = \"y\" ]; then\n\tCOMPRESSMANPG=\"--disable-compress-manpg \"\nelse\n\tCOMPRESSMANPG=\"\"\n\techo \"Parameter --disable-compress-manpg is NOT set\"\nfi\n\n# Install documentation\nINSTALL_DOC=`${ASK} 'Skip documentation installation? (y/n)' \"--disable-documentation\" \"install-doc\"`\nif [ \"${INSTALL_DOC}\" = \"y\" ]; then\n\tINSTALL_DOC=\"--disable-documentation \"\nelse\n\tINSTALL_DOC=\"\"\n\techo \"Parameter --disable-documentation is NOT set\"\nfi\n\n# Debug mode\nDEBUGINFO=`${ASK} 'Debug mode support? (y/n)' \"--enable-debuginfo\" \"debuginfo\"`\nif [ \"${DEBUGINFO}\" = \"y\" ]; then\n\tDEBUGINFO=\"--enable-debuginfo \"\nelse\n\tDEBUGINFO=\"\"\n\techo \"Parameter --enable-debuginfo is NOT set\"\nfi\n\n# Strip object files\nSTRIP=`${ASK} 'Do not strip object files? (y/n)' \"--disable-stripping\" \"stripping\"`\nif [ \"${STRIP}\" = \"y\" ]; then\n\tSTRIP=\"--disable-stripping \"\nelse\n\tSTRIP=\"\"\n\techo \"Parameter --disable-stripping is NOT set\"\nfi\n\necho\necho -n \"./configure ${PREFIX}${SA_LIB_DIR}${SA_DIR}${SYSCONFIG_DIR}${SYSCONFIG_FILE} \\\n${CLEAN_SA_DIR}${NLS}${LTO}${HISTORY}${DELAY_RANGE}${COMPRESSAFTER}${MAN}${IGNORE_FILE_ATTR} \\\n${CRON}${USE_CROND}${RCDIR}\"\nif [ \"${SADC_OPT}\" != \"\" ];\nthen\n\techo -n \"sadc_options=\\\"${SADC_OPT}\\\"\"\nfi\necho \"${COMPRESSMANPG}${INSTALL_DOC}${DEBUGINFO}${SENSORS}${PCP}${STRIP}${COPY_ONLY}\"\necho\n\n./configure ${PREFIX}${SA_LIB_DIR}${SA_DIR}${SYSCONFIG_DIR}${SYSCONFIG_FILE} \\\n${CLEAN_SA_DIR}${NLS}${LTO} \\\n${HISTORY}${DELAY_RANGE}${COMPRESSAFTER}${MAN}${IGNORE_FILE_ATTR}${CRON}${USE_CROND}${RCDIR} \\\nsadc_options=\"${SADC_OPT}\" ${COMPRESSMANPG}${INSTALL_DOC}${DEBUGINFO}${SENSORS} \\\n${PCP}${STRIP}${COPY_ONLY}\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "ioconf.c",
          "type": "blob",
          "size": 12.6337890625,
          "content": "/*\n * ioconf: ioconf configuration file handling code\n * Original code (C) 2004 by Red Hat (Charlie Bennett <ccb@redhat.com>)\n *\n * Modified and maintained by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA                   *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"ioconf.h\"\n#include \"common.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nstatic unsigned int ioc_parsed = 0;\nstatic struct ioc_entry *ioconf[MAX_BLKDEV + 1];\nstatic unsigned int ioc_refnr[MAX_BLKDEV + 1];\n\n/*\n ***************************************************************************\n * Free ioc_entry structures\n ***************************************************************************\n */\nstatic void ioc_free(void)\n{\n\tunsigned int i;\n\tstruct ioc_entry **p;\n\n\t/* Take out all of the references first */\n\tfor (i = 0, p = ioconf; i < MAX_BLKDEV; ++i, ++p) {\n\t\tif ((*p == NULL) || ((*p)->live))\n\t\t\tcontinue;\n\n\t\tif ((*p)->desc != (*p)->blkp->desc) {\n\t\t\t/* Not a shared description */\n\t\t\tfree((*p)->desc);\n\t\t}\n\t\tfree(*p);\n\t\t*p = NULL;\n\t}\n\n\t/* Now the live ones */\n\tfor (i = 0, p = ioconf; i < MAX_BLKDEV; ++i, ++p) {\n\t\tif (*p == NULL)\n\t\t\tcontinue;\n\t\tfree((*p)->blkp);\n\t\tfree(*p);\n\t\t*p = NULL;\n\t}\n}\n\n/*\n ***************************************************************************\n * ioc_conv - Turn a number into a string in radix <radix> using symbol\n *   set (and ordering) syms.  Use nozero to generate strings\n *   in which the number system uses a single sym for the\n *   radix value (not 2, like decimal) and adds a column only\n *   at radix+1.  If decimal were like this:\n *\n *   (no zero) 1 2 3 4 5 6 7 8 9 0 11 12 13 14 15 16 17 18 19 10 ...\n ***************************************************************************\n */\nstatic char *ioc_conv(int radix, int nozero, const char *syms,\n\t\t      unsigned int val)\n{\n\tstatic char out[17];\n\tchar *p;\n\tint j;\n\n\t*(p = out + 16) = '\\0';\n\n\tval += nozero;\n\n\tif (val == 0) {\n\t\tif (!nozero) {\n\t\t\t*--p = '0';\n\t\t}\n\t\treturn (p);\t/* Empty string if nozero radix gets val == 0 */\n\t}\n\n\twhile (val > 0) {\n\n\t\t*--p = syms[j = val % radix];\n\t\tval /= radix;\n\t\tif (nozero && (j == 0)) {\n\t\t\t/* Comp for 10 in nozero bases */\n\t\t\t--val;\n\t\t}\n\t}\n\treturn (p);\n}\n\nchar *ioc_ito10(unsigned int n)\n{\n\treturn (ioc_conv(10, 0, DIGITS, n));\n}\n\nchar *ioc_ito26(unsigned int n)\n{\n\treturn (ioc_conv(26, 1, \"zabcdefghijklmnopqrstuvwxy\", n));\n}\n\n/*\n ***************************************************************************\n * ioc_init() - internalize the ioconf file\n *\n * given:    void\n * does:     parses IOCONF into ioconf, an array of ioc_entry *\n *           Only entries having lines in IOCONF will have valid pointers\n * return:   1 on success\n *           0 on failure\n ***************************************************************************\n */\nint ioc_init(void)\n{\n\tFILE *fp;\n\tunsigned int i, major, indirect, count = 0;\n\tchar buf[IOC_LINESIZ];\n\tchar cfmt[IOC_FMTLEN];\n\tchar dfmt[IOC_FMTLEN];\n\tchar pfmt[IOC_FMTLEN];\n\tchar desc[IOC_DESCLEN];\n\tstruct ioc_entry  *iocp = NULL;\n\tstruct blk_config *blkp = NULL;\n\tchar ioconf_name[64];\n\n\tif ((fp = fopen(IOCONF, \"r\")) == NULL) {\n\t\tif ((fp = fopen(LOCAL_IOCONF, \"r\")) == NULL)\n\t\t\treturn 0;\n\t\tstrncpy(ioconf_name, LOCAL_IOCONF, sizeof(ioconf_name));\n\t}\n\telse {\n\t\tstrncpy(ioconf_name, IOCONF, sizeof(ioconf_name));\n\t}\n\tioconf_name[sizeof(ioconf_name) - 1] = '\\0';\n\n\t/* Init ioc_refnr array */\n\tmemset(ioc_refnr, 0, sizeof(ioc_refnr));\n\n\twhile (fgets(buf, sizeof(buf) - 1, fp)) {\n\n\t\tif ((*buf == '#') || (*buf == '\\n'))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Preallocate some (probably) needed data structures\n\t\t */\n\t\tIOC_ALLOC(blkp, struct blk_config, BLK_CONFIG_SIZE);\n\t\tIOC_ALLOC(iocp, struct ioc_entry, IOC_ENTRY_SIZE);\n\t\tmemset(blkp, 0, BLK_CONFIG_SIZE);\n\t\tmemset(iocp, 0, IOC_ENTRY_SIZE);\n\n\t\ti = sscanf(buf, \"%u:%u:%u:%63s\",\n\t\t\t   &major, &indirect, &iocp->ctrlno, desc);\n\n\t\tif (i != 4) {\n\t\t\ti = sscanf(buf, \"%u:%u:%u\",\n\t\t\t\t   &major, &indirect, &iocp->ctrlno);\n\t\t}\n\n\t\tif ((i == 3) || (i == 4)) {\n\t\t\t/* indirect record */\n\t\t\tif (indirect == 0) {\n\t\t\t\t/* conventional usage for unsupported device */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (indirect > MAX_BLKDEV) {\n\t\t\t\tfprintf(stderr, \"%s: Indirect major #%u out of range\\n\",\n\t\t\t\t\tioconf_name, indirect);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (major > MAX_BLKDEV) {\n\t\t\t\tfprintf(stderr, \"%s: Major #%u out of range\\n\",\n\t\t\t\t\tioconf_name, major);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ioconf[indirect] == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: Indirect record '%u:%u:%u:...'\"\n\t\t\t\t\t\" references not yet seen major %u\\n\",\n\t\t\t\t\tioconf_name, major, indirect, iocp->ctrlno, major);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Cool. Point this device at its referent.\n\t\t\t * Skip last: (last field my be empty...)\n\t\t\t * if it was empty and : was in the sscanf spec\n\t\t\t * we'd only see 3 fields...\n\t\t\t */\n\t\t\tif (i == 3) {\n\t\t\t\t/* reference the mothership */\n\t\t\t\tiocp->desc = ioconf[indirect]->blkp->desc;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tIOC_ALLOC(iocp->desc, char, IOC_DESCLEN);\n\t\t\t\tmemcpy(iocp->desc, desc, IOC_DESCLEN);\n\t\t\t}\n\t\t\tioc_refnr[indirect]++;\n\t\t\tioconf[major] = iocp;\n\t\t\tiocp->basemajor = indirect;\n\t\t\tiocp->blkp = ioconf[indirect]->blkp;\n\t\t\tiocp->live = 0;\n\t\t\tiocp = NULL;\n\t\t\tcontinue;\n\t\t\t/* all done with indirect record */\n\t\t}\n\n\t\t/* maybe it's a full record? */\n\n\t\ti = sscanf(buf, \"%u:%[^:]:%[^:]:%u:%[^:]:%u:%[^:]:%u:%63s\",\n\t\t\t   &major, blkp->name,\n\t\t\t   cfmt, &iocp->ctrlno,\n\t\t\t   dfmt, &blkp->dcount,\n\t\t\t   pfmt, &blkp->pcount,\n\t\t\t   desc);\n\n\t\tif (i != 9) {\n\t\t\tfprintf(stderr, \"%s: Malformed %u field record: %s\\n\",\n\t\t\t\tioconf_name, i, buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* this is a full-fledged direct record */\n\n\t\tif ((major == 0) || (major >= MAX_BLKDEV)) {\n\t\t\tfprintf(stderr, \"%s: major #%u out of range\\n\",\n\t\t\t\t__FUNCTION__, major);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* is this an exception record? */\n\t\tif (*cfmt == 'x') {\n\t\t\tstruct blk_config *xblkp;\n\n\t\t\t/*\n\t\t\t * device has an aliased minor\n\t\t\t * for now we only support one exception per major\n\t\t\t * (catering to initrd: (1,250))\n\t\t\t */\n\t\t\tif (ioconf[major] == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: type 'x' record for\"\n\t\t\t\t\t\" major #%u must follow the base record - ignored\\n\",\n\t\t\t\t\tioconf_name, major);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\txblkp = ioconf[major]->blkp;\n\n\t\t\tif (xblkp->ext) {\n\t\t\t\t/*\n\t\t\t\t * Enforce one minor exception per major policy\n\t\t\t\t * note: this applies to each major number and\n\t\t\t\t * all of it's indirect (short form) majors\n\t\t\t\t */\n\t\t\t\tfprintf(stderr, \"%s: duplicate 'x' record for\"\n\t\t\t\t\t\" major #%u - ignored\\ninput line: %s\\n\",\n\t\t\t\t\tioconf_name, major, buf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Decorate the base major struct with the\n\t\t\t * exception info\n\t\t\t */\n\t\t\txblkp->ext_minor = iocp->ctrlno;\n\t\t\tstrncpy(xblkp->ext_name, blkp->name, IOC_NAMELEN);\n\t\t\txblkp->ext_name[IOC_NAMELEN - 1] = '\\0';\n\t\t\txblkp->ext = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Preformat the sprintf format strings for generating\n\t\t * c-d-p info in ioc_name()\n\t\t */\n\n\t\t/* basename of device + provided string + controller # */\n\t\tif (*cfmt == '*') {\n\t\t\tstrncpy(blkp->cfmt, blkp->name, MINIMUM(sizeof(blkp->name), sizeof(blkp->cfmt) - 1));\n\t\t\tblkp->cfmt[sizeof(blkp->cfmt) - 1] = '\\0';\n\t\t}\n\t\telse {\n\t\t\tsprintf(blkp->cfmt, \"%s%s%%d\", blkp->name, cfmt);\n\t\t\t++(blkp->ctrl_explicit);\n\t\t}\n\n\t\t/* Disk */\n\t\t*blkp->dfmt = '\\0';\n\t\tswitch (*dfmt) {\n\t\tcase 'a':\n\t\t\tblkp->cconv = ioc_ito26;\n\t\t\tstrcpy(blkp->dfmt, \"%s\");\n\t\t\tbreak;\n\n\t\tcase '%':\n\t\t\tstrncpy(blkp->dfmt, dfmt + 1, IOC_FMTLEN - 1);\n\t\t\t/* fallthrough to next case */\n\t\tcase 'd':\n\t\t\tblkp->cconv = ioc_ito10;\n\t\t\tstrcat(blkp->dfmt, \"%s\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Partition */\n\t\tsprintf(blkp->pfmt, \"%s%%d\", (*pfmt == '*') ? \"\" : pfmt);\n\n\t\t/*\n\t\t * We're good to go.\n\t\t * Stuff the ioc_entry and ref it.\n\t\t */\n\t\tiocp->live = 1;\n\t\tiocp->blkp = blkp;\n\t\tiocp->desc = NULL;\n\t\tiocp->basemajor = major;\n\t\tioconf[major] = iocp;\n\t\tmemcpy(blkp->desc, desc, IOC_DESCLEN);\n\t\tblkp = NULL; iocp = NULL;\n\t\t++count;\n\t}\n\tfclose(fp);\n\n\t/*\n\t * These will become leaks if we ever 'continue'\n\t * after IOC_ALLOC( blkp->desc ... ).\n\t * Right now, we don't.\n\t */\n\tfree(blkp);\n\tfree(iocp);\n\n\t/* Indicate that ioconf file has been parsed */\n\tioc_parsed = 1;\n\n\treturn (count);\n\nfree_and_return:\n\t/* Free pointers and return */\n\tfclose(fp);\n\tif (blkp) {\n\t\tfree(blkp);\n\t}\n\tif (iocp) {\n\t\tfree(iocp);\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n *  ioc_name() - Generate a name from a maj,min pair\n *\n * IN:\n * @major\tDevice major number.\n * @minor\tDevice minor number.\n *\n * RETURNS:\n * Returns NULL if major or minor are out of range\n * otherwise returns a pointer to a static string containing\n * the generated name.\n ***************************************************************************\n */\n\nchar *ioc_name(unsigned int major, unsigned int minor)\n{\n\tstatic char name[IOC_DEVLEN];\n\tstruct ioc_entry *p;\n\tint base, offset;\n\n\tif ((major > MAX_BLKDEV) || (minor > IOC_MAXMINOR)) {\n\t\treturn (NULL);\n\t}\n\n\tif (!ioc_parsed && !ioc_init())\n\t\treturn (NULL);\n\n\tp = ioconf[major];\n\n\t/* Invalid major or minor numbers? */\n\tif ((p == NULL) || ((minor & 0xff) >= (p->blkp->dcount * p->blkp->pcount))) {\n\t\t/*\n\t\t * That minor test is only there for IDE-style devices\n\t\t * that have no minors over 128.\n\t\t */\n\t\tstrcpy(name, K_NODEV);\n\t\treturn (name);\n\t}\n\n\t/* Is this an extension record? */\n\tif (p->blkp->ext && (p->blkp->ext_minor == minor)) {\n\t\tstrncpy(name, p->blkp->ext_name, sizeof(name));\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\treturn (name);\n\t}\n\n\t/* OK.  we're doing an actual device name... */\n\n\t/*\n\t * Assemble base + optional controller info\n\t * this is of course too clever by half\n\t * the parser has already cooked cfmt, dfmt to make this easy\n\t * (we parse once but may generate lots of names)\n\t */\n\tbase = p->ctrlno * p->blkp->dcount;\n\tif (minor >= 256) {\n\t\tbase += p->blkp->dcount * (ioc_refnr[p->basemajor] + 1) * (minor >> 8);\n\t}\n\n\toffset = (minor & 0xff) / p->blkp->pcount;\n\tif (!p->blkp->ctrl_explicit) {\n\t\toffset += base;\n\t}\n\n\t/*\n\t * These sprintfs can't be coalesced because the first might\n\t * ignore its first arg\n\t */\n\tsprintf(name, p->blkp->cfmt, p->ctrlno);\n\tsprintf(name + strlen(name), p->blkp->dfmt, p->blkp->cconv(offset));\n\n\tif (!IS_WHOLE(major, minor)) {\n\t\t/*\n\t\t * Tack on partition info, format string cooked (curried?) by\n\t\t * the parser\n\t\t */\n\t\tsprintf(name + strlen(name), p->blkp->pfmt, minor % p->blkp->pcount);\n\t}\n\treturn (name);\n}\n\n/*\n ***************************************************************************\n * Transform device mapper name: Get the user assigned name of the logical\n * device instead of the internal device mapper numbering.\n *\n * IN:\n * @major\tDevice major number.\n * @minor\tDevice minor number.\n *\n * RETURNS:\n * Assigned name of the logical device.\n ***************************************************************************\n */\nchar *transform_devmapname(unsigned int major, unsigned int minor)\n{\n\tDIR *dm_dir;\n\tstruct dirent *dp;\n\tchar filen[MAX_FILE_LEN];\n\tchar *dm_name = NULL;\n\tstatic char name[MAX_NAME_LEN];\n\tstruct stat aux;\n\tunsigned int dm_major, dm_minor;\n\n\tif ((dm_dir = opendir(DEVMAP_DIR)) == NULL) {\n\t\tfprintf(stderr, _(\"Cannot open %s: %s\\n\"), DEVMAP_DIR, strerror(errno));\n\t\texit(4);\n\t}\n\n\twhile ((dp = readdir(dm_dir)) != NULL) {\n\t\t/* For each file in DEVMAP_DIR */\n\n\t\tsnprintf(filen, sizeof(filen), \"%s/%s\", DEVMAP_DIR, dp->d_name);\n\t\tfilen[sizeof(filen) - 1] = '\\0';\n\n\t\tif (__stat(filen, &aux) == 0) {\n\t\t\t/* Get its minor and major numbers */\n\n\t\t\tdm_major = __major(aux.st_rdev);\n\t\t\tdm_minor = __minor(aux.st_rdev);\n\n\t\t\tif ((dm_minor == minor) && (dm_major == major)) {\n\t\t\t\tstrncpy(name, dp->d_name, sizeof(name));\n\t\t\t\tname[sizeof(name) - 1] = '\\0';\n\t\t\t\tdm_name = name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dm_dir);\n\n\treturn dm_name;\n}\n"
        },
        {
          "name": "ioconf.h",
          "type": "blob",
          "size": 2.525390625,
          "content": "/*\n * ioconf: ioconf configuration file handling code\n * Original code (C) 2004 by Red Hat (Charlie Bennett <ccb@redhat.com>)\n *\n * Modified and maintained by Sebastien GODARD (sysstat <at> orange.fr)\n */\n\n#ifndef _IOCONF_H\n#define _IOCONF_H\n\n#include \"sysconfig.h\"\n\n#define IOC_NAMELEN\t32\n#define IOC_DESCLEN\t64\n#define IOC_DEVLEN\t48\n#define IOC_LINESIZ\t256\n#define IOC_FMTLEN\t16\n#define IOC_XFMTLEN\t(IOC_FMTLEN + IOC_NAMELEN + 3)\n\n#ifndef MINORBITS\n#define MINORBITS\t20\n#endif\n#define IOC_MAXMINOR\t((1U << MINORBITS) - 1)\n#ifndef MAX_BLKDEV\n/* #define MAX_BLKDEV\t((1U << (32 - MINORBITS)) - 1) */\n/* Use a lower value since this value is used to allocate arrays statically in ioconf.c */\n#define MAX_BLKDEV\t511\n#endif\n\n#define K_NODEV\t\"nodev\"\n\n#define IS_WHOLE(maj,min)\t((min % ioconf[maj]->blkp->pcount) == 0)\n\n/*\n * When is C going to get templates?\n */\n#define IOC_ALLOC(P,TYPE,SIZE)\t\t\t\\\n     do {\t\t\t\t\t\\\n         if (P == NULL) {\t\t\t\\\n              P = (TYPE *) malloc(SIZE);\t\\\n              if (P == NULL) {\t\t\t\\\n                   perror(\"malloc\");\t\t\\\n                   ioc_free();\t\t\t\\\n                   goto free_and_return;\t\\\n              }\t\t\t\t\t\\\n         }\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n     while (0)\n/* That dummy while allows ';' on the line that invokes the macro... */\n\n\nstruct blk_config {\n\tchar name[IOC_NAMELEN];\t/* device basename */\n\tchar cfmt[IOC_XFMTLEN];\t/* controller format string */\n\tchar dfmt[IOC_FMTLEN];\t/* disk format string */\n\tchar pfmt[IOC_FMTLEN + 2];\t/* partition format string */\n\t/* ctrlno is in the ioc_entry */\n\tunsigned int ctrl_explicit;\t/* use \"cN\" in name */\n\tunsigned int dcount;\t\t/* number of devices handled by this major */\n\tunsigned int pcount;\t\t/* partitions per device */\n\tchar desc[IOC_DESCLEN];\n\t/* disk info unit # conversion function */\n\tchar *(*cconv)(unsigned int);\n\n\t/* extension properties (all this for initrd?) */\n\tchar ext_name[IOC_NAMELEN];\n\tunsigned int ext;\t\t/* flag - this is an extension record */\n\tunsigned int ext_minor;\t\t/* which minor does this apply to */\n};\n\n#define BLK_CONFIG_SIZE\t(sizeof(struct blk_config))\n\n\nstruct ioc_entry {\n\tint live;\t\t\t/* is this a Direct entry? */\n\tunsigned int ctrlno;\t\t/* controller number */\n\tunsigned int basemajor;\t\t/* Major number of the template */\n\tchar *desc;\t\t\t/* (dynamic) per-controller description */\n\tstruct blk_config *blkp;\t/* the real info, may be a shared ref */\n};\n\n#define IOC_ENTRY_SIZE\t(sizeof(struct ioc_entry))\n\n\nint ioc_iswhole\n\t(unsigned int, unsigned int);\nchar *ioc_name\n\t(unsigned int, unsigned int);\nchar *transform_devmapname\n\t(unsigned int, unsigned int);\n\n#endif\n"
        },
        {
          "name": "iostat.c",
          "type": "blob",
          "size": 69.078125,
          "content": "/*\n * iostat: report CPU and I/O statistics\n * (C) 1998-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <libgen.h>\n\n#include \"version.h\"\n#include \"iostat.h\"\n#include \"ioconf.h\"\n#include \"rd_stats.h\"\n#include \"count.h\"\n\n#include <locale.h>\t/* For setlocale() */\n#ifdef USE_NLS\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern int __env;\n#endif\n\nstruct stats_cpu *st_cpu[2];\nunsigned long long uptime_cs[2] = {0, 0};\nunsigned long long tot_jiffies[2] = {0, 0};\nstruct io_device *dev_list = NULL;\n\n/* Number of decimal places */\nint dplaces_nr = -1;\n\nint group_nr = 0;\t/* Nb of device groups */\nint cpu_nr = 0;\t\t/* Nb of processors on the machine */\nuint64_t flags = 0;\t/* Flag for common options and system state */\nuint64_t xflags = 0;\t/* Extended flag for options used by multiple commands */\n\nlong interval = 0;\nchar alt_dir[MAX_FILE_LEN];\n\nstruct sigaction alrm_act, int_act;\nint sigint_caught = 0;\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command.\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ]\\n\"),\n\t\tprogname);\n#ifdef DEBUG\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -c ] [ -d ] [ -h ] [ -k | -m ] [ -N ] [ -s ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ]\\n\"\n\t\t\t  \"[ { -f | +f } <directory> ] [ -j { ID | LABEL | PATH | UUID | ... } ]\\n\"\n\t\t\t  \"[ --compact ] [ --dec={ 0 | 1 | 2 } ] [ --human ] [ --pretty ] [ -o JSON ]\\n\"\n\t\t\t  \"[ [ -H ] -g <group_name> ] [ -p [ <device> [,...] | ALL ] ]\\n\"\n\t\t\t  \"[ <device> [...] | ALL ] [ --debuginfo ]\\n\"));\n#else\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -c ] [ -d ] [ -h ] [ -k | -m ] [ -N ] [ -s ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ]\\n\"\n\t\t\t  \"[ { -f | +f } <directory> ] [ -j { ID | LABEL | PATH | UUID | ... } ]\\n\"\n\t\t\t  \"[ --compact ] [ --dec={ 0 | 1 | 2 } ] [ --human ] [ --pretty ] [ -o JSON ]\\n\"\n\t\t\t  \"[ [ -H ] -g <group_name> ] [ -p [ <device> [,...] | ALL ] ]\\n\"\n\t\t\t  \"[ <device> [...] | ALL ]\\n\"));\n#endif\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * Set disk output unit. Unit will be kB/s unless POSIXLY_CORRECT\n * environment variable has been set, in which case the output will be\n * expressed in blocks/s.\n ***************************************************************************\n */\nvoid set_disk_output_unit(void)\n{\n\tif (DISPLAY_KILOBYTES(flags) || DISPLAY_MEGABYTES(flags))\n\t\treturn;\n\n\t/* Check POSIXLY_CORRECT environment variable */\n\tif (__getenv(ENV_POSIXLY_CORRECT) == NULL) {\n\t\t/* Variable not set: Unit is kB/s and not blocks/s */\n\t\tflags |= I_D_KILOBYTES;\n\t}\n}\n\n/*\n ***************************************************************************\n * Get device mapper name (e.g. \"dm-0\") from its registered name (e.g.\n * \"virtualhd-home\").\n *\n * IN:\n * @name\tRegistered name of the device (e.g. \"virtualhd-home\").\n *\n * RETURNS:\n * Name of the device mapper name (e.g. \"dm-0\").\n ***************************************************************************\n */\nchar *get_dm_name_from_registered_name(char *registered_name)\n{\n\tint n;\n\tchar filen[PATH_MAX];\n\tchar target[PATH_MAX];\n\n\t/*\n\t * The registered device name is a symlink pointing at its device mapper name\n\t * in the /dev/mapper directory.\n\t */\n\tn = snprintf(filen, sizeof(filen), \"%s/%s\", DEVMAP_DIR, registered_name);\n\tif ((n >= sizeof(filen)) || access(filen, F_OK)) {\n\t\treturn (NULL);\n\t}\n\n\t/* Read symlink */\n\tn = readlink(filen, target, PATH_MAX);\n\tif ((n <= 0) || (n >= PATH_MAX))\n\t\treturn (NULL);\n\n\ttarget[n] = '\\0';\n\n\t/* ... and get device mapper name it points at */\n\treturn basename(target);\n}\n\n/*\n ***************************************************************************\n * SIGALRM signal handler. No need to reset the handler here.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid alarm_handler(int sig)\n{\n\talarm(interval);\n}\n\n/*\n ***************************************************************************\n * SIGINT signal handler.\n *\n * IN:\n * @sig\tSignal number.\n **************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tsigint_caught = 1;\n}\n\n/*\n ***************************************************************************\n * Initialize stats common structures.\n ***************************************************************************\n */\nvoid init_stats(void)\n{\n\tint i;\n\n\t/* Allocate structures for CPUs \"all\" and 0 */\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((st_cpu[i] = (struct stats_cpu *) malloc(STATS_CPU_SIZE * 2)) == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(4);\n\t\t}\n\t\tmemset(st_cpu[i], 0, STATS_CPU_SIZE * 2);\n\t}\n}\n\n/*\n ***************************************************************************\n * Set every device entry to nonexistent status.\n *\n * IN:\n * @dlist\tPointer on the start of the linked list.\n ***************************************************************************\n */\nvoid set_devices_nonexistent(struct io_device *dlist)\n{\n\twhile (dlist != NULL) {\n\t\tdlist->exist = FALSE;\n\t\tdlist = dlist->next;\n\t}\n}\n\n/*\n ***************************************************************************\n * Get device major and minor numbers.\n *\n * IN:\n * @filename\tName of the device (\"sda\", \"/dev/sdb1\"...)\n *\n * OUT:\n * @major\tMajor number of the device.\n * @minor\tMinor number of the device.\n *\n * RETURNS:\n * 0 on success, and -1 otherwise.\n ***************************************************************************\n */\nint get_major_minor_nr(char filename[], int *major, int *minor)\n{\n\tstruct stat statbuf;\n\tchar *bang;\n\tchar dfile[MAX_PF_NAME];\n\n\tsnprintf(dfile, sizeof(dfile), \"%s%s\", filename[0] == '/' ? \"\" : SLASH_DEV, filename);\n\tdfile[sizeof(dfile) - 1] = '\\0';\n\n\twhile ((bang = strchr(dfile, '!'))) {\n\t\t/*\n\t\t * Some devices may have had a slash replaced with a bang character (eg. cciss!c0d0...)\n\t\t * Restore their original names so that they can be found in /dev directory.\n\t\t */\n\t\t*bang = '/';\n\t}\n\n\tif (__stat(dfile, &statbuf) < 0)\n\t\treturn -1;\n\n\t*major = __major(statbuf.st_rdev);\n\t*minor = __minor(statbuf.st_rdev);\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Check if a device is present in the list, and add it if requested.\n * Also look for its type (device or partition) and save it.\n *\n * IN:\n * @dlist\tAddress of pointer on the start of the linked list.\n * @name\tDevice name.\n * @dtype\tT_PART_DEV (=2) if the device and all its partitions should\n *\t\talso be read (option -p used), T_GROUP (=3) if it's a group\n *\t\tname, and 0 otherwise.\n * @major\tMajor number of the device (set to UKWN_MAJ_NR by caller if\n *\t\tunknown: In this case, major and minor numbers will be\n *\t\tdetermined here).\n * @minor\tMinor number of the device.\n *\n * RETURNS:\n * Pointer on the io_device structure in the list where the device is located\n * (whether it was already in the list or if it has been added).\n * NULL if the device name is too long or if the device doesn't exist and we\n * don't want to add it.\n ***************************************************************************\n */\nstruct io_device *add_list_device(struct io_device **dlist, char *name, int dtype,\n\t\t\t\t  int major, int minor)\n{\n\tstruct io_device *d, *ds;\n\tint i, maj_nr, min_nr;\n\n\tif (strnlen(name, MAX_NAME_LEN) == MAX_NAME_LEN)\n\t\t/* Device name is too long */\n\t\treturn NULL;\n\n\twhile (*dlist != NULL) {\n\n\t\td = *dlist;\n\t\tif ((i = strcmp(d->name, name)) == 0) {\n\t\t\t/* Device found in list */\n\t\t\tif ((dtype == T_PART_DEV) && (d->dev_tp == T_DEV)) {\n\t\t\t\td->dev_tp = dtype;\n\t\t\t}\n\t\t\td->exist = TRUE;\n\t\t\treturn d;\n\t\t}\n\t\tif (!GROUP_DEFINED(flags) && !DISPLAY_EVERYTHING(flags) && (i > 0))\n\t\t\t/*\n\t\t\t * If no group defined and we don't use /proc/diskstats,\n\t\t\t * insert current device in alphabetical order.\n\t\t\t * NB: Using /proc/diskstats (\"iostat -p ALL\") is a bit better than\n\t\t\t * using alphabetical order because sda10 comes after sda9...\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdlist = &(d->next);\n\t}\n\n\t/* Device not found */\n\tds = *dlist;\n\n\t/* Add device to the list */\n\tif ((*dlist = (struct io_device *) malloc(sizeof(struct io_device))) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tmemset(*dlist, 0, sizeof(struct io_device));\n\n\td = *dlist;\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((d->dev_stats[i] = (struct io_stats *) malloc(sizeof(struct io_stats))) == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(4);\n\t\t}\n\t\tmemset(d->dev_stats[i], 0, sizeof(struct io_stats));\n\t}\n\tif (DISPLAY_DEVMAP_NAME(flags)) {\n\t\tchar *dm_name;\n\n\t\t/*\n\t\t * Save device mapper name (e.g. \"dm-0\") instead of\n\t\t * its registered name (e.g. \"virtualhd-home\")\n\t\t * This is because we won't read stats for a file named \"virtualhd-home\" but\n\t\t * for a file named \"dm-0\" (we will display \"virtualhd-home\" anyway at the end\n\t\t * because option -N has been used).\n\t\t */\n\t\tdm_name = get_dm_name_from_registered_name(name);\n\t\tif (!dm_name) {\n\t\t\tdm_name = name;\n\t\t}\n\t\tstrncpy(d->name, dm_name, sizeof(d->name) - 1);\n\t}\n\telse {\n\t\tstrncpy(d->name, name, sizeof(d->name));\n\t}\n\td->name[MAX_NAME_LEN - 1] = '\\0';\n\td->exist = TRUE;\n\td->next = ds;\n\n\tif (dtype == T_GROUP) {\n\t\td->dev_tp = dtype;\n\t}\n\telse  {\n\t\tint rc = 0;\n\n\t\tif (!alt_dir[0] || USE_ALL_DIR(flags)) {\n\t\t\trc = is_device(SLASH_SYS, name, ACCEPT_VIRTUAL_DEVICES);\n\t\t}\n\n\t\tif (alt_dir[0] && (!USE_ALL_DIR(flags) || (USE_ALL_DIR(flags) && !rc))) {\n\t\t\trc = is_device(alt_dir, name, ACCEPT_VIRTUAL_DEVICES);\n\t\t}\n\n\t\tif (rc) {\n\t\t\td->dev_tp = (dtype == T_PART_DEV ? T_PART_DEV : T_DEV);\n\t\t}\n\t\telse {\n\t\t\t/* This is a partition (T_PART) */\n\t\t\td->dev_tp = T_PART;\n\t\t}\n\n\t\t/* Save major and minor numbers */\n\t\tif (major != UKWN_MAJ_NR) {\n\t\t\td->major = major;\n\t\t\td->minor = minor;\n\t\t}\n\t\telse {\n\t\t\t/* Look for device major and minor numbers */\n\t\t\tif (get_major_minor_nr(d->name, &maj_nr, &min_nr) == 0) {\n\t\t\t\td->major = maj_nr;\n\t\t\t\td->minor = min_nr;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stat for current block device or partition.\n *\n * IN:\n * @filename\tFile name where stats will be read.\n * @ios\t\tStructure where stats will be saved.\n *\n * OUT:\n * @ios\t\tStructure where stats have been saved.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_file_stat_work(char *filename, struct io_stats *ios)\n{\n\tFILE *fp;\n\tstruct io_stats sdev;\n\tint i;\n\tunsigned int ios_pgr, tot_ticks, rq_ticks, wr_ticks, dc_ticks, fl_ticks;\n\tunsigned long rd_ios, rd_merges_or_rd_sec, wr_ios, wr_merges;\n\tunsigned long rd_sec_or_wr_ios, wr_sec, rd_ticks_or_wr_sec;\n\tunsigned long dc_ios, dc_merges, dc_sec, fl_ios;\n\n\t/* Try to read given stat file */\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\treturn -1;\n\n\ti = fscanf(fp, \"%lu %lu %lu %lu %lu %lu %lu %u %u %u %u %lu %lu %lu %u %lu %u\",\n\t\t   &rd_ios, &rd_merges_or_rd_sec, &rd_sec_or_wr_ios, &rd_ticks_or_wr_sec,\n\t\t   &wr_ios, &wr_merges, &wr_sec, &wr_ticks, &ios_pgr, &tot_ticks, &rq_ticks,\n\t\t   &dc_ios, &dc_merges, &dc_sec, &dc_ticks,\n\t\t   &fl_ios, &fl_ticks);\n\n\tmemset(&sdev, 0, sizeof(struct io_stats));\n\n\tif (i >= 11) {\n\t\t/* Device or partition */\n\t\tsdev.rd_ios     = rd_ios;\n\t\tsdev.rd_merges  = rd_merges_or_rd_sec;\n\t\tsdev.rd_sectors = rd_sec_or_wr_ios;\n\t\tsdev.rd_ticks   = (unsigned int) rd_ticks_or_wr_sec;\n\t\tsdev.wr_ios     = wr_ios;\n\t\tsdev.wr_merges  = wr_merges;\n\t\tsdev.wr_sectors = wr_sec;\n\t\tsdev.wr_ticks   = wr_ticks;\n\t\tsdev.ios_pgr    = ios_pgr;\n\t\tsdev.tot_ticks  = tot_ticks;\n\t\tsdev.rq_ticks   = rq_ticks;\n\n\t\tif (i >= 15) {\n\t\t\t/* Discard I/O */\n\t\t\tsdev.dc_ios     = dc_ios;\n\t\t\tsdev.dc_merges  = dc_merges;\n\t\t\tsdev.dc_sectors = dc_sec;\n\t\t\tsdev.dc_ticks   = dc_ticks;\n\t\t}\n\n\t\tif (i >= 17) {\n\t\t\t/* Flush I/O */\n\t\t\tsdev.fl_ios     = fl_ios;\n\t\t\tsdev.fl_ticks   = fl_ticks;\n\t\t}\n\t}\n\telse if (i == 4) {\n\t\t/* Partition without extended statistics */\n\t\tsdev.rd_ios     = rd_ios;\n\t\tsdev.rd_sectors = rd_merges_or_rd_sec;\n\t\tsdev.wr_ios     = rd_sec_or_wr_ios;\n\t\tsdev.wr_sectors = rd_ticks_or_wr_sec;\n\t}\n\n\t*ios = sdev;\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stat for current whole device using /sys or an alternate\n * location.\n *\n * IN:\n * @devname\tDevice name for which stats have to be read.\n * @ios\t\tStructure where stats will be saved.\n *\n * OUT:\n * @ios\t\tStructure where stats have been saved.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_file_stat(char *devname, struct io_stats *ios)\n{\n\tint rc = 0;\n\tchar dfile[MAX_PF_NAME];\n\n\tif (!alt_dir[0] || USE_ALL_DIR(flags)) {\n\t\t/* Read stats for current whole device using /sys/block/ directory */\n\t\tsnprintf(dfile, sizeof(dfile), \"%s/%s/%s/%s\",\n\t\t\t SLASH_SYS, __BLOCK, devname, S_STAT);\n\t\tdfile[sizeof(dfile) - 1] = '\\0';\n\n\t\trc = read_sysfs_file_stat_work(dfile, ios);\n\t}\n\n\tif (alt_dir[0] && (!USE_ALL_DIR(flags) || (USE_ALL_DIR(flags) && (rc < 0)))) {\n\t\t/* Read stats for current whole device using an alternate /sys directory */\n\t\tsnprintf(dfile, sizeof(dfile), \"%s/%s/%s/%s\",\n\t\t\t alt_dir, __BLOCK, devname, S_STAT);\n\t\tdfile[sizeof(dfile) - 1] = '\\0';\n\n\t\trc = read_sysfs_file_stat_work(dfile, ios);\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stats for all the partitions of a whole device. Devices are\n * saved in the linked list.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @dname\tWhole device name.\n * @sysdev\tsysfs location.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_device_part_stat_work(int curr, char *dname, char *sysdev)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\tstruct io_stats sdev;\n\tstruct io_device *d;\n\tchar dfile[MAX_PF_NAME], filename[MAX_PF_NAME + 512];\n\n\tsnprintf(dfile, sizeof(dfile), \"%s/%s/%s\", sysdev, __BLOCK, dname);\n\tdfile[sizeof(dfile) - 1] = '\\0';\n\n\t/* Open current device directory in /sys/block */\n\tif ((dir = __opendir(dfile)) == NULL)\n\t\treturn -1;\n\n\t/* Get current entry */\n\twhile ((drd = __readdir(dir)) != NULL) {\n\n\t\tif (!strcmp(drd->d_name, \".\") || !strcmp(drd->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s/%s\", dfile, drd->d_name, S_STAT);\n\t\tfilename[sizeof(filename) - 1] = '\\0';\n\n\t\t/* Read current partition stats */\n\t\tif (read_sysfs_file_stat_work(filename, &sdev) < 0)\n\t\t\tcontinue;\n\n\t\td = add_list_device(&dev_list, drd->d_name, 0, UKWN_MAJ_NR, 0);\n\t\tif (d != NULL) {\n\t\t\t*(d->dev_stats[curr]) = sdev;\n\t\t}\n\t}\n\n\t/* Close device directory */\n\t__closedir(dir);\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stats for all the partitions of a whole device.\n * Stats are from /sys or an alternate directory.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @dname\tWhole device name.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_device_part_stat(int curr, char *dname)\n{\n\tint rc = 0;\n\n\tif (!alt_dir[0] || USE_ALL_DIR(flags)) {\n\t\t/* Read partition stats from /sys */\n\t\trc = read_sysfs_device_part_stat_work(curr, dname, SLASH_SYS);\n\t}\n\n\tif (alt_dir[0] && (!USE_ALL_DIR(flags) || (USE_ALL_DIR(flags) && (rc < 0)))) {\n\t\t/* Read partition stats from an alternate /sys directory */\n\t\trc = read_sysfs_device_part_stat_work(curr, dname, alt_dir);\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stats for every whole device. Devices are\tsaved in the linked\n * list.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @sysblock\t__sys/block directory location.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_all_devices_stat_work(int curr, char *sysblock)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\tstruct io_stats sdev;\n\tstruct io_device *d;\n\tchar dfile[MAX_PF_NAME];\n\n\t/* Open __sys/block directory */\n\tif ((dir = __opendir(sysblock)) == NULL)\n\t\treturn -1;\n\n\t/* Get current entry */\n\twhile ((drd = __readdir(dir)) != NULL) {\n\n\t\tif (!strcmp(drd->d_name, \".\") || !strcmp(drd->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsnprintf(dfile, sizeof(dfile), \"%s/%s/%s\", sysblock, drd->d_name, S_STAT);\n\t\tdfile[sizeof(dfile) - 1] = '\\0';\n\n\t\t/* Read current whole device stats */\n\t\tif (read_sysfs_file_stat_work(dfile, &sdev) < 0)\n\t\t\tcontinue;\n\n\t\td = add_list_device(&dev_list, drd->d_name, 0, UKWN_MAJ_NR, 0);\n\t\tif (d != NULL) {\n\t\t\t*(d->dev_stats[curr]) = sdev;\n\t\t}\n\t}\n\n\t/* Close device directory */\n\t__closedir(dir);\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stats for every whole device from /sys or an alternate\n * location.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 0 on success, -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_all_devices_stat(int curr)\n{\n\tint rc = 0;\n\n\tif (!alt_dir[0] || USE_ALL_DIR(flags)) {\n\t\t/* Read all whole devices from /sys */\n\t\trc = read_sysfs_all_devices_stat_work(curr, SYSFS_BLOCK);\n\t}\n\n\tif (alt_dir[0]) {\n\t\tchar sysblock[MAX_PF_NAME];\n\n\t\tsnprintf(sysblock, sizeof(sysblock), \"%s/%s\", alt_dir, __BLOCK);\n\t\tsysblock[sizeof(sysblock) - 1] = '\\0';\n\t\t/* Read stats from an alternate sys location */\n\t\trc = read_sysfs_all_devices_stat_work(curr, sysblock);\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Read sysfs stats for a partition using __sys/dev/block/M:m/ directory.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @d\t\tDevice structure.\n * @sysdev\tsysfs directory.\n *\n * RETURNS:\n * 0 on success, and -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_part_stat_work(int curr, struct io_device *d, char *sysdev)\n{\n\tchar dfile[MAX_PF_NAME];\n\n\t/* Read stats for device */\n\tsnprintf(dfile, sizeof(dfile), \"%s/%s/%d:%d/%s\",\n\t\t sysdev, __DEV_BLOCK, d->major, d->minor, S_STAT);\n\tdfile[sizeof(dfile) - 1] = '\\0';\n\n\treturn read_sysfs_file_stat_work(dfile, d->dev_stats[curr]);\n}\n\n/*\n ***************************************************************************\n * Read sysfs stats for a partition using /sys/dev/block/M:m/ directory or\n * an alternate directory.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @d\t\tDevice structure.\n *\n * RETURNS:\n * 0 on success, and -1 otherwise.\n ***************************************************************************\n */\nint read_sysfs_part_stat(int curr, struct io_device *d)\n{\n\tint rc = 0;\n\n\tif (!alt_dir[0] || USE_ALL_DIR(flags)) {\n\t\t/* Read partition stats from /sys */\n\t\trc = read_sysfs_part_stat_work(curr, d, SLASH_SYS);\n\t}\n\n\tif (alt_dir[0] && (!USE_ALL_DIR(flags) || (USE_ALL_DIR(flags) && (rc < 0)))) {\n\t\t/* Read partition stats from an alternate /sys directory */\n\t\trc = read_sysfs_part_stat_work(curr, d, alt_dir);\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Read stats from the sysfs filesystem for the devices entered on the\n * command line.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\nvoid read_sysfs_dlist_stat(int curr)\n{\n\tstruct io_device *dlist;\n\n\tfor (dlist = dev_list; dlist != NULL; dlist = dlist->next) {\n\t\tif (dlist->exist)\n\t\t\t/* Device stats already read */\n\t\t\tcontinue;\n\n\t\telse if (dlist->dev_tp == T_PART) {\n\t\t\t/*\n\t\t\t * This is a partition.\n\t\t\t * Read its stats using /sys/dev/block/M:n/ directory.\n\t\t\t */\n\t\t\tif (read_sysfs_part_stat(curr, dlist) == 0) {\n\t\t\t\tdlist->exist = TRUE;\n\t\t\t}\n\t\t}\n\n\t\telse if ((dlist->dev_tp == T_PART_DEV) || (dlist->dev_tp == T_DEV)) {\n\t\t\t/* Read stats for current whole device using /sys/block/ directory */\n\t\t\tif (read_sysfs_file_stat(dlist->name, dlist->dev_stats[curr]) == 0) {\n\t\t\t\tdlist->exist = TRUE;\n\t\t\t}\n\n\t\t\tif (dlist->dev_tp == T_PART_DEV) {\n\t\t\t\t/* Also read all its partitions now */\n\t\t\t\tread_sysfs_device_part_stat(curr, dlist->name);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Read all whole devices stats if requested (\"iostat ALL ...\") */\n\tif (DISPLAY_ALL_DEVICES(flags)) {\n\t\tread_sysfs_all_devices_stat(curr);\n\t}\n}\n\n/*\n ***************************************************************************\n * Read stats from the diskstats file. Only used when \"-p ALL\" has been\n * entered on the command line.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @diskstats\tPath to diskstats file (e.g. \"/proc/diskstats\").\n ***************************************************************************\n */\nvoid read_diskstats_stat_work(int curr, char *diskstats)\n{\n\tFILE *fp;\n\tchar line[256], dev_name[MAX_NAME_LEN];\n\tstruct io_device *d;\n\tstruct io_stats sdev;\n\tint i;\n\tunsigned int ios_pgr, tot_ticks, rq_ticks, wr_ticks, dc_ticks, fl_ticks;\n\tunsigned long rd_ios, rd_merges_or_rd_sec, rd_ticks_or_wr_sec, wr_ios;\n\tunsigned long wr_merges, rd_sec_or_wr_ios, wr_sec;\n\tunsigned long dc_ios, dc_merges, dc_sec, fl_ios;\n\tunsigned int major, minor;\n\n\tif ((fp = fopen(diskstats, \"r\")) == NULL)\n\t\treturn;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tmemset(&sdev, 0, sizeof(struct io_stats));\n\n\t\t/* major minor name rio rmerge rsect ruse wio wmerge wsect wuse running use aveq dcio dcmerge dcsect dcuse flio fltm */\n\t\ti = sscanf(line, \"%u %u %s %lu %lu %lu %lu %lu %lu %lu %u %u %u %u %lu %lu %lu %u %lu %u\",\n\t\t\t   &major, &minor, dev_name,\n\t\t\t   &rd_ios, &rd_merges_or_rd_sec, &rd_sec_or_wr_ios, &rd_ticks_or_wr_sec,\n\t\t\t   &wr_ios, &wr_merges, &wr_sec, &wr_ticks, &ios_pgr, &tot_ticks, &rq_ticks,\n\t\t\t   &dc_ios, &dc_merges, &dc_sec, &dc_ticks,\n\t\t\t   &fl_ios, &fl_ticks);\n\n\t\tif (i >= 14) {\n\t\t\tsdev.rd_ios     = rd_ios;\n\t\t\tsdev.rd_merges  = rd_merges_or_rd_sec;\n\t\t\tsdev.rd_sectors = rd_sec_or_wr_ios;\n\t\t\tsdev.rd_ticks   = (unsigned int) rd_ticks_or_wr_sec;\n\t\t\tsdev.wr_ios     = wr_ios;\n\t\t\tsdev.wr_merges  = wr_merges;\n\t\t\tsdev.wr_sectors = wr_sec;\n\t\t\tsdev.wr_ticks   = wr_ticks;\n\t\t\tsdev.ios_pgr    = ios_pgr;\n\t\t\tsdev.tot_ticks  = tot_ticks;\n\t\t\tsdev.rq_ticks   = rq_ticks;\n\n\t\t\tif (i >= 18) {\n\t\t\t\t/* Discard I/O */\n\t\t\t\tsdev.dc_ios     = dc_ios;\n\t\t\t\tsdev.dc_merges  = dc_merges;\n\t\t\t\tsdev.dc_sectors = dc_sec;\n\t\t\t\tsdev.dc_ticks   = dc_ticks;\n\t\t\t}\n\n\t\t\tif (i >= 20) {\n\t\t\t\t/* Flush I/O */\n\t\t\t\tsdev.fl_ios     = fl_ios;\n\t\t\t\tsdev.fl_ticks   = fl_ticks;\n\t\t\t}\n\t\t}\n\t\telse if (i == 7) {\n\t\t\t/* Partition without extended statistics */\n\t\t\tif (DISPLAY_EXTENDED(flags))\n\t\t\t\tcontinue;\n\n\t\t\tsdev.rd_ios     = rd_ios;\n\t\t\tsdev.rd_sectors = rd_merges_or_rd_sec;\n\t\t\tsdev.wr_ios     = rd_sec_or_wr_ios;\n\t\t\tsdev.wr_sectors = rd_ticks_or_wr_sec;\n\t\t}\n\t\telse\n\t\t\t/* Unknown entry: Ignore it */\n\t\t\tcontinue;\n\n\t\td = add_list_device(&dev_list, dev_name, 0, major, minor);\n\t\tif (d != NULL) {\n\t\t\t*d->dev_stats[curr] = sdev;\n\t\t}\n\t}\n\tfclose(fp);\n}\n\n/*\n ***************************************************************************\n * Read stats from /proc/diskstats or an alternate diskstats file.\n * Only used when \"-p ALL\" has been entered on the command line.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\nvoid read_diskstats_stat(int curr)\n{\n\tif (!alt_dir[0] || USE_ALL_DIR(flags)) {\n\t\t/* Read stats from /proc/diskstats */\n\t\tread_diskstats_stat_work(curr, DISKSTATS);\n\t}\n\n\tif (alt_dir[0]) {\n\t\tchar diskstats[MAX_PF_NAME];\n\n\t\tsnprintf(diskstats, sizeof(diskstats), \"%s/%s\", alt_dir, __DISKSTATS);\n\t\tdiskstats[sizeof(diskstats) - 1] = '\\0';\n\t\t/* Read stats from an alternate diskstats file */\n\t\tread_diskstats_stat_work(curr, diskstats);\n\t}\n}\n\n/*\n ***************************************************************************\n * Add current device statistics to corresponding group.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @iodev_nr\t\tNumber of devices and partitions.\n ***************************************************************************\n */\nvoid compute_device_groups_stats(int curr, struct io_device *d, struct io_device *g)\n{\n\tif (!DISPLAY_UNFILTERED(flags)) {\n\t\tif (!d->dev_stats[curr]->rd_ios &&\n\t\t    !d->dev_stats[curr]->wr_ios &&\n\t\t    !d->dev_stats[curr]->dc_ios &&\n\t\t    !d->dev_stats[curr]->fl_ios)\n\t\t\treturn;\n\t}\n\n\tg->dev_stats[curr]->rd_ios     += d->dev_stats[curr]->rd_ios;\n\tg->dev_stats[curr]->rd_merges  += d->dev_stats[curr]->rd_merges;\n\tg->dev_stats[curr]->rd_sectors += d->dev_stats[curr]->rd_sectors;\n\tg->dev_stats[curr]->rd_ticks   += d->dev_stats[curr]->rd_ticks;\n\tg->dev_stats[curr]->wr_ios     += d->dev_stats[curr]->wr_ios;\n\tg->dev_stats[curr]->wr_merges  += d->dev_stats[curr]->wr_merges;\n\tg->dev_stats[curr]->wr_sectors += d->dev_stats[curr]->wr_sectors;\n\tg->dev_stats[curr]->wr_ticks   += d->dev_stats[curr]->wr_ticks;\n\tg->dev_stats[curr]->dc_ios     += d->dev_stats[curr]->dc_ios;\n\tg->dev_stats[curr]->dc_merges  += d->dev_stats[curr]->dc_merges;\n\tg->dev_stats[curr]->dc_sectors += d->dev_stats[curr]->dc_sectors;\n\tg->dev_stats[curr]->dc_ticks   += d->dev_stats[curr]->dc_ticks;\n\tg->dev_stats[curr]->fl_ios     += d->dev_stats[curr]->fl_ios;\n\tg->dev_stats[curr]->fl_ticks   += d->dev_stats[curr]->fl_ticks;\n\tg->dev_stats[curr]->ios_pgr    += d->dev_stats[curr]->ios_pgr;\n\tg->dev_stats[curr]->tot_ticks  += d->dev_stats[curr]->tot_ticks;\n\tg->dev_stats[curr]->rq_ticks   += d->dev_stats[curr]->rq_ticks;\n}\n\n/*\n ***************************************************************************\n * Display CPU utilization in plain format.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n ***************************************************************************\n */\nvoid write_plain_cpu_stat(int curr, unsigned long long deltot_jiffies)\n{\n\tprintf(\"avg-cpu:  %%user   %%nice %%system %%iowait  %%steal   %%idle\\n\");\n\n\tprintf(\"       \");\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 5, 7, 2,\n\t\t   ll_sp_value(st_cpu[!curr]->cpu_user, st_cpu[curr]->cpu_user, deltot_jiffies),\n\t\t   ll_sp_value(st_cpu[!curr]->cpu_nice, st_cpu[curr]->cpu_nice, deltot_jiffies),\n\t\t   /*\n\t\t    * Time spent in system mode also includes time spent servicing\n\t\t    * hard and soft interrupts.\n\t\t    */\n\t\t   ll_sp_value(st_cpu[!curr]->cpu_sys + st_cpu[!curr]->cpu_softirq +\n\t\t\t       st_cpu[!curr]->cpu_hardirq,\n\t\t\t       st_cpu[curr]->cpu_sys + st_cpu[curr]->cpu_softirq +\n\t\t\t       st_cpu[curr]->cpu_hardirq, deltot_jiffies),\n\t\t   ll_sp_value(st_cpu[!curr]->cpu_iowait, st_cpu[curr]->cpu_iowait, deltot_jiffies),\n\t\t   ll_sp_value(st_cpu[!curr]->cpu_steal, st_cpu[curr]->cpu_steal, deltot_jiffies));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 7, 2,\n\t\t   (st_cpu[curr]->cpu_idle < st_cpu[!curr]->cpu_idle) ?\n\t\t   0.0 :\n\t\t   ll_sp_value(st_cpu[!curr]->cpu_idle, st_cpu[curr]->cpu_idle, deltot_jiffies));\n\n\tprintf(\"\\n\\n\");\n}\n\n/*\n ***************************************************************************\n * Display CPU utilization in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @curr\tIndex in array for current sample statistics.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n ***************************************************************************\n */\nvoid write_json_cpu_stat(int tab, int curr, unsigned long long deltot_jiffies)\n{\n\txprintf0(tab, \"\\\"avg-cpu\\\":  {\\\"user\\\": %.2f, \\\"nice\\\": %.2f, \\\"system\\\": %.2f,\"\n\t\t      \" \\\"iowait\\\": %.2f, \\\"steal\\\": %.2f, \\\"idle\\\": %.2f}\",\n\t\t ll_sp_value(st_cpu[!curr]->cpu_user, st_cpu[curr]->cpu_user, deltot_jiffies),\n\t\t ll_sp_value(st_cpu[!curr]->cpu_nice, st_cpu[curr]->cpu_nice, deltot_jiffies),\n\t\t /*\n\t\t  * Time spent in system mode also includes time spent servicing\n\t\t  * hard and soft interrupts.\n\t\t  */\n\t\t ll_sp_value(st_cpu[!curr]->cpu_sys + st_cpu[!curr]->cpu_softirq +\n\t\t\t     st_cpu[!curr]->cpu_hardirq,\n\t\t\t     st_cpu[curr]->cpu_sys + st_cpu[curr]->cpu_softirq +\n\t\t\t     st_cpu[curr]->cpu_hardirq, deltot_jiffies),\n\t\t ll_sp_value(st_cpu[!curr]->cpu_iowait, st_cpu[curr]->cpu_iowait, deltot_jiffies),\n\t\t ll_sp_value(st_cpu[!curr]->cpu_steal, st_cpu[curr]->cpu_steal, deltot_jiffies),\n\t\t (st_cpu[curr]->cpu_idle < st_cpu[!curr]->cpu_idle) ?\n\t\t 0.0 :\n\t\t ll_sp_value(st_cpu[!curr]->cpu_idle, st_cpu[curr]->cpu_idle, deltot_jiffies));\n}\n\n/*\n ***************************************************************************\n * Display CPU utilization in plain or JSON format.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tNumber of tabs to print (JSON format only).\n ***************************************************************************\n */\nvoid write_cpu_stat(int curr, int tab)\n{\n\tunsigned long long deltot_jiffies;\n\n\t/* Total number of jiffies spent on the interval */\n\tdeltot_jiffies = get_interval(tot_jiffies[!curr], tot_jiffies[curr]);\n\n#ifdef DEBUG\n\t\tif (DISPLAY_DEBUG(xflags)) {\n\t\t\t/* Debug output */\n\t\t\tfprintf(stderr, \"deltot_jiffies=%llu st_cpu[curr]{ cpu_user=%llu cpu_nice=%llu \"\n\t\t\t\t\t\"cpu_sys=%llu cpu_idle=%llu cpu_iowait=%llu cpu_steal=%llu \"\n\t\t\t\t\t\"cpu_hardirq=%llu cpu_softirq=%llu cpu_guest=%llu \"\n\t\t\t\t\t\"cpu_guest_nice=%llu }\\n\",\n\t\t\t\tdeltot_jiffies,\n\t\t\t\tst_cpu[curr]->cpu_user,\n\t\t\t\tst_cpu[curr]->cpu_nice,\n\t\t\t\tst_cpu[curr]->cpu_sys,\n\t\t\t\tst_cpu[curr]->cpu_idle,\n\t\t\t\tst_cpu[curr]->cpu_iowait,\n\t\t\t\tst_cpu[curr]->cpu_steal,\n\t\t\t\tst_cpu[curr]->cpu_hardirq,\n\t\t\t\tst_cpu[curr]->cpu_softirq,\n\t\t\t\tst_cpu[curr]->cpu_guest,\n\t\t\t\tst_cpu[curr]->cpu_guest_nice);\n\t\t}\n#endif\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\twrite_json_cpu_stat(tab, curr, deltot_jiffies);\n\t}\n\telse {\n\t\twrite_plain_cpu_stat(curr, deltot_jiffies);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display disk stats header in plain or JSON format.\n *\n * OUT:\n * @fctr\tConversion factor.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @hpart\tIndicate which part of the report should be displayed in\n *\t\thuman mode. A value of 0 indicates that output should not be\n *\t\tbroken in several parts.\n ***************************************************************************\n */\nvoid write_disk_stat_header(int *fctr, int *tab, int hpart)\n{\n\tchar *units, *spc;\n\n\tif (DISPLAY_KILOBYTES(flags)) {\n\t\t*fctr = 2;\n\t\tunits = \"kB\";\n\t\tspc = \" \";\n\t}\n\telse if (DISPLAY_MEGABYTES(flags)) {\n\t\t*fctr = 2048;\n\t\tunits = \"MB\";\n\t\tspc = \" \";\n\t}\n\telse if (DISPLAY_EXTENDED(flags)) {\n\t\tunits = \"sec\";\n\t\tspc = \"\";\n\t}\n\telse {\n\t\tunits = \"Blk\";\n\t\tspc = \"\";\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf((*tab)++, \"\\\"disk\\\": [\");\n\t\treturn;\n\t}\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tprintf(\"Device       \");\n\t}\n\tif (DISPLAY_EXTENDED(flags)) {\n\t\t/* Extended stats */\n\t\tif (DISPLAY_SHORT_OUTPUT(flags)) {\n\t\t\tprintf(\"      tps     %s%s/s    rqm/s   await  areq-sz  aqu-sz  %%util\",\n\t\t\t       spc, units);\n\t\t}\n\t\telse {\n\t\t\tif ((hpart == 1) || !hpart) {\n\t\t\t\tprintf(\"     r/s    %sr%s/s   rrqm/s  %%rrqm r_await rareq-sz\",\n\t\t\t\t       spc, units);\n\t\t\t}\n\t\t\tif ((hpart == 2) || !hpart) {\n\t\t\t\tprintf(\"     w/s    %sw%s/s   wrqm/s  %%wrqm w_await wareq-sz\",\n\t\t\t\t       spc, units);\n\t\t\t}\n\t\t\tif ((hpart == 3) || !hpart) {\n\t\t\t       printf(\"     d/s    %sd%s/s   drqm/s  %%drqm d_await dareq-sz\",\n\t\t\t\t      spc, units);\n\t\t\t}\n\t\t\tif ((hpart == 4) || !hpart) {\n\t\t\t       printf(\"     f/s f_await  aqu-sz  %%util\");\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t/* Basic stats */\n\t\tif (DISPLAY_SHORT_OUTPUT(flags)) {\n\t\t\tprintf(\"      tps   %s%s_read/s    %s%s_w+d/s   %s%s_read    %s%s_w+d\",\n\t\t\t       spc, units, spc, units, spc, units, spc, units);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"      tps   %s%s_read/s   %s%s_wrtn/s   %s%s_dscd/s   %s%s_read   %s%s_wrtn   %s%s_dscd\",\n\t\t\t       spc, units, spc, units, spc, units, spc, units, spc, units, spc, units);\n\t\t}\n\t}\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tprintf(\" Device\");\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display extended stats, read from /proc/{diskstats,partitions} or /sys,\n * in plain format.\n *\n * IN:\n * @itv\t\tInterval of time.\n * @fctr\tConversion factor.\n * @hpart\tIndicate which part of the report should be displayed in\n *\t\thuman mode. A value of 0 indicates that output should not be\n *\t\tbroken in several parts.\n * @d\t\tStructure containing device description.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @devname\tCurrent device name.\n * @xds\t\tExtended stats for current device.\n * @xios\tAdditional extended statistics for current device.\n ***************************************************************************\n */\nvoid write_plain_ext_stat(unsigned long long itv, int fctr, int hpart,\n\t\t\t  struct io_device *d, struct io_stats *ioi,\n\t\t\t  struct io_stats *ioj, char *devname, struct ext_disk_stats *xds,\n\t\t\t  struct ext_io_stats *xios)\n{\n\tint n;\n\n\t/* If this is a group with no devices, skip it */\n\tif (d->dev_tp == T_GROUP)\n\t\treturn;\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \"%-13s\", devname, 0);\n\t}\n\n\t/* Compute number of devices in group */\n\tif (d->dev_tp > T_GROUP) {\n\t\tn = d->dev_tp - T_GROUP;\n\t}\n\telse {\n\t\tn = 1;\n\t}\n\n\tif (DISPLAY_SHORT_OUTPUT(flags)) {\n\t\t/* tps */\n\t\t/* Origin (unmerged) flush operations are counted as writes */\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t  ioi->rd_ios + ioi->wr_ios + ioi->dc_ios < ioj->rd_ios + ioj->wr_ios + ioj->dc_ios ?\n\t\t\t  0.0 :\n\t\t\t  S_VALUE(ioj->rd_ios + ioj->wr_ios + ioj->dc_ios,\n\t\t\t\t  ioi->rd_ios + ioi->wr_ios + ioi->dc_ios, itv));\n\t\t/* kB/s */\n\t\tif (!DISPLAY_UNIT(flags)) {\n\t\t\txios->sectors /= fctr;\n\t\t}\n\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t  xios->sectors);\n\t\t/* rqm/s */\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t  ioi->rd_merges + ioi->wr_merges + ioi->dc_merges < ioj->rd_merges + ioj->wr_merges + ioj->dc_merges ?\n\t\t\t  0.0 :\n\t\t\t  S_VALUE(ioj->rd_merges + ioj->wr_merges + ioj->dc_merges,\n\t\t\t\t  ioi->rd_merges + ioi->wr_merges + ioi->dc_merges, itv));\n\t\t/* await */\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t  xds->await);\n\t\t/* areq-sz (in kB, not sectors) */\n\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_KILOBYTE : NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t  xds->arqsz / 2);\n\t\t/* aqu-sz */\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t  ioi->rq_ticks < ioj->rq_ticks ? 0.0 :\n\t\t\t  S_VALUE(ioj->rq_ticks, ioi->rq_ticks, itv) / 1000.0);\n\t\t/*\n\t\t * %util\n\t\t * Again: Ticks in milliseconds.\n\t\t */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 6, 2, xds->util / 10.0 / (double) n);\n\t}\n\telse {\n\t\tif ((hpart == 1) || !hpart) {\n\t\t\t/* r/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  ioi->rd_ios < ioj->rd_ios ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->rd_ios, ioi->rd_ios, itv));\n\t\t\t/* rkB/s */\n\t\t\tif (!DISPLAY_UNIT(flags)) {\n\t\t\t\txios->rsectors /= fctr;\n\t\t\t}\n\t\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  xios->rsectors);\n\t\t\t/* rrqm/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t\t  ioi->rd_merges < ioj->rd_merges ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->rd_merges, ioi->rd_merges, itv));\n\t\t\t/* %rrqm */\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW0, 1, 6, 2,\n\t\t\t\t   xios->rrqm_pc);\n\t\t\t/* r_await */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  xios->r_await);\n\t\t\t/* rareq-sz  (in kB, not sectors) */\n\t\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_KILOBYTE : NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t\t  xios->rarqsz / 2);\n\t\t}\n\t\tif ((hpart == 2) || !hpart) {\n\t\t\t/* w/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  ioi->wr_ios < ioj->wr_ios ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->wr_ios, ioi->wr_ios, itv));\n\t\t\t/* wkB/s */\n\t\t\tif (!DISPLAY_UNIT(flags)) {\n\t\t\t\txios->wsectors /= fctr;\n\t\t\t}\n\t\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  xios->wsectors);\n\t\t\t/* wrqm/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t\t  ioi->wr_merges < ioj->wr_merges ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->wr_merges, ioi->wr_merges, itv));\n\t\t\t/* %wrqm */\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW0, 1, 6, 2,\n\t\t\t\t   xios->wrqm_pc);\n\t\t\t/* w_await */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  xios->w_await);\n\t\t\t/* wareq-sz (in kB, not sectors) */\n\t\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_KILOBYTE : NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t\t  xios->warqsz / 2);\n\t\t}\n\t\tif ((hpart == 3) || !hpart) {\n\t\t\t/* d/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  ioi->dc_ios < ioj->dc_ios ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->dc_ios, ioi->dc_ios, itv));\n\t\t\t/* dkB/s */\n\t\t\tif (!DISPLAY_UNIT(flags)) {\n\t\t\t\txios->dsectors /= fctr;\n\t\t\t}\n\t\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  xios->dsectors);\n\t\t\t/* drqm/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t\t  ioi->dc_merges < ioj->dc_merges ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->dc_merges, ioi->dc_merges, itv));\n\t\t\t/* %drqm */\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW0, 1, 6, 2,\n\t\t\t\t   xios->drqm_pc);\n\t\t\t/* d_await */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  xios->d_await);\n\t\t\t/* dareq-sz (in kB, not sectors) */\n\t\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_KILOBYTE : NO_UNIT, FALSE, 1, 8, 2,\n\t\t\t\t  xios->darqsz / 2);\n\t\t}\n\t\tif ((hpart == 4) || !hpart) {\n\t\t\t/* f/s */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  ioi->fl_ios < ioj->fl_ios ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->fl_ios, ioi->fl_ios, itv));\n\t\t\t/* f_await */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  xios->f_await);\n\t\t\t/* aqu-sz */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 2,\n\t\t\t\t  ioi->rq_ticks < ioj->rq_ticks ? 0.0 :\n\t\t\t\t  S_VALUE(ioj->rq_ticks, ioi->rq_ticks, itv) / 1000.0);\n\t\t\t/*\n\t\t\t * %util\n\t\t\t * Again: Ticks in milliseconds.\n\t\t\t */\n\t\t\tif (d->dev_tp > T_GROUP) {\n\t\t\t\tn = d->dev_tp - T_GROUP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 6, 2, xds->util / 10.0 / (double) n);\n\t\t}\n\t}\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", devname, 0);\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display extended stats, read from /proc/{diskstats,partitions} or /sys,\n * in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @itv\t\tInterval of time.\n * @fctr\tConversion factor.\n * @d\t\tStructure containing the device description.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @devname\tCurrent device name.\n * @xds\t\tExtended stats for current device.\n * @xios\tAdditional extended statistics for current device.\n ***************************************************************************\n */\nvoid write_json_ext_stat(int tab, unsigned long long itv, int fctr,\n\t\t\t struct io_device *d, struct io_stats *ioi,\n\t\t\t struct io_stats *ioj, char *devname, struct ext_disk_stats *xds,\n\t\t\t struct ext_io_stats *xios)\n{\n\tint n;\n\n\t/* If this is a group with no devices, skip it */\n\tif (d->dev_tp == T_GROUP)\n\t\treturn;\n\n\txprintf0(tab,\n\t\t \"{\\\"disk_device\\\": \\\"%s\\\", \",\n\t\t devname);\n\n\tif (DISPLAY_SHORT_OUTPUT(flags)) {\n\t\tprintf(\"\\\"tps\\\": %.2f, \\\"\",\n\t\t       /* Origin (unmerged) flush operations are counted as writes */\n\t\t       ioi->rd_ios + ioi->wr_ios + ioi->dc_ios < ioj->rd_ios + ioj->wr_ios + ioj->dc_ios ?\n\t\t       0.0 :\n\t\t       S_VALUE(ioj->rd_ios + ioj->wr_ios + ioj->dc_ios,\n\t\t\t       ioi->rd_ios + ioi->wr_ios + ioi->dc_ios, itv));\n\t\tif (DISPLAY_MEGABYTES(flags)) {\n\t\t\tprintf(\"MB/s\");\n\t\t}\n\t\telse if (DISPLAY_KILOBYTES(flags)) {\n\t\t\tprintf(\"kB/s\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"sec/s\");\n\t\t}\n\t\tprintf(\"\\\": %.2f, \\\"rqm/s\\\": %.2f, \\\"await\\\": %.2f, \"\n\t\t       \"\\\"areq-sz\\\": %.2f, \\\"aqu-sz\\\": %.2f, \",\n\t\t       xios->sectors /= fctr,\n\t\t       ioi->rd_merges + ioi->wr_merges + ioi->dc_merges < ioj->rd_merges + ioj->wr_merges + ioj->dc_merges ?\n\t\t       0.0 :\n\t\t       S_VALUE(ioj->rd_merges + ioj->wr_merges + ioj->dc_merges,\n\t\t\t       ioi->rd_merges + ioi->wr_merges + ioi->dc_merges, itv),\n\t\t       xds->await,\n\t\t       xds->arqsz / 2,\n\t\t       ioi->rq_ticks < ioj->rq_ticks ? 0.0\n\t\t\t\t\t\t     : S_VALUE(ioj->rq_ticks, ioi->rq_ticks, itv) / 1000.0);\n\t}\n\telse {\n\t\tchar line[256];\n\n\t\tprintf(\"\\\"r/s\\\": %.2f, \\\"w/s\\\": %.2f, \\\"d/s\\\": %.2f, \\\"f/s\\\": %.2f, \",\n\t\t       ioi->rd_ios < ioj->rd_ios ? 0.0\n\t\t\t\t\t\t : S_VALUE(ioj->rd_ios, ioi->rd_ios, itv),\n\t\t       ioi->wr_ios < ioj->wr_ios ? 0.0\n\t\t\t\t\t\t : S_VALUE(ioj->wr_ios, ioi->wr_ios, itv),\n\t\t       ioi->dc_ios < ioj->dc_ios ? 0.0\n\t\t\t\t\t\t : S_VALUE(ioj->dc_ios, ioi->dc_ios, itv),\n\t\t       ioi->fl_ios < ioj->fl_ios ? 0.0\n\t\t\t\t\t\t : S_VALUE(ioj->fl_ios, ioi->fl_ios, itv));\n\t\tif (DISPLAY_MEGABYTES(flags)) {\n\t\t\tsprintf(line, \"\\\"rMB/s\\\": %%.2f, \\\"wMB/s\\\": %%.2f, \\\"dMB/s\\\": %%.2f, \");\n\t\t}\n\t\telse if (DISPLAY_KILOBYTES(flags)) {\n\t\t\tsprintf(line, \"\\\"rkB/s\\\": %%.2f, \\\"wkB/s\\\": %%.2f, \\\"dkB/s\\\": %%.2f, \");\n\t\t}\n\t\telse {\n\t\t\tsprintf(line, \"\\\"rsec/s\\\": %%.2f, \\\"wsec/s\\\": %%.2f, \\\"dsec/s\\\": %%.2f, \");\n\t\t}\n\t\tprintf(line,\n\t\t       xios->rsectors /= fctr,\n\t\t       xios->wsectors /= fctr,\n\t\t       xios->dsectors /= fctr);\n\t\tprintf(\"\\\"rrqm/s\\\": %.2f, \\\"wrqm/s\\\": %.2f, \\\"drqm/s\\\": %.2f, \"\n\t\t       \"\\\"rrqm\\\": %.2f, \\\"wrqm\\\": %.2f, \\\"drqm\\\": %.2f, \"\n\t\t       \"\\\"r_await\\\": %.2f, \\\"w_await\\\": %.2f, \\\"d_await\\\": %.2f, \\\"f_await\\\": %.2f, \"\n\t\t       \"\\\"rareq-sz\\\": %.2f, \\\"wareq-sz\\\": %.2f, \\\"dareq-sz\\\": %.2f, \"\n\t\t       \"\\\"aqu-sz\\\": %.2f, \",\n\t\t       ioi->rd_merges < ioj->rd_merges ? 0.0\n\t\t\t\t\t\t       : S_VALUE(ioj->rd_merges, ioi->rd_merges, itv),\n\t\t       ioi->wr_merges < ioj->wr_merges ? 0.0\n\t\t\t\t\t\t       : S_VALUE(ioj->wr_merges, ioi->wr_merges, itv),\n\t\t       ioi->dc_merges < ioj->dc_merges ? 0.0\n\t\t\t\t\t\t       : S_VALUE(ioj->dc_merges, ioi->dc_merges, itv),\n\t\t       xios->rrqm_pc,\n\t\t       xios->wrqm_pc,\n\t\t       xios->drqm_pc,\n\t\t       xios->r_await,\n\t\t       xios->w_await,\n\t\t       xios->d_await,\n\t\t       xios->f_await,\n\t\t       xios->rarqsz / 2,\n\t\t       xios->warqsz / 2,\n\t\t       xios->darqsz / 2,\n\t\t       ioi->rq_ticks < ioj->rq_ticks ? 0.0\n\t\t\t\t\t\t     : S_VALUE(ioj->rq_ticks, ioi->rq_ticks, itv) / 1000.0);\n\t}\n\n\tif (d->dev_tp > T_GROUP) {\n\t\tn = d->dev_tp - T_GROUP;\n\t}\n\telse {\n\t\tn = 1;\n\t}\n\tprintf(\"\\\"util\\\": %.2f}\", xds->util / 10.0 / (double) n);\n}\n\n/*\n ***************************************************************************\n * Display extended stats, read from /proc/{diskstats,partitions} or /sys,\n * in plain or JSON format.\n *\n * IN:\n * @itv\t\tInterval of time.\n * @fctr\tConversion factor.\n * @hpart\tIndicate which part of the report should be displayed in\n *\t\thuman mode. A value of 0 indicates that output should not be\n *\t\tbroken in several parts.\n * @d\t\tStructure containing device description.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @tab\t\tNumber of tabs to print (JSON output only).\n * @dname\tName to be used for display for current device.\n ***************************************************************************\n */\nvoid write_ext_stat(unsigned long long itv, int fctr, int hpart,\n\t\t    struct io_device *d, struct io_stats *ioi,\n\t\t    struct io_stats *ioj, int tab, char *dname)\n{\n\tstruct stats_disk sdc, sdp;\n\tstruct ext_disk_stats xds;\n\tstruct ext_io_stats xios;\n\n\tmemset(&xds, 0, sizeof(struct ext_disk_stats));\n\tmemset(&xios, 0, sizeof(struct ext_io_stats));\n\n\t/*\n\t * Counters overflows are possible, but don't need to be handled in\n\t * a special way: The difference is still properly calculated if the\n\t * result is of the same type as the two values.\n\t * Exception is field rq_ticks which is incremented by the number of\n\t * I/O in progress times the number of milliseconds spent doing I/O.\n\t * But the number of I/O in progress (field ios_pgr) happens to be\n\t * sometimes negative...\n\t */\n\n\tif ((hpart == 4) || !hpart || DISPLAY_SHORT_OUTPUT(flags)) {\n\t\t/* Origin (unmerged) flush operations are counted as writes */\n\t\tsdc.nr_ios    = ioi->rd_ios + ioi->wr_ios + ioi->dc_ios;\n\t\tsdp.nr_ios    = ioj->rd_ios + ioj->wr_ios + ioj->dc_ios;\n\n\t\tsdc.tot_ticks = ioi->tot_ticks;\n\t\tsdp.tot_ticks = ioj->tot_ticks;\n\n\t\tsdc.rd_ticks  = ioi->rd_ticks;\n\t\tsdp.rd_ticks  = ioj->rd_ticks;\n\t\tsdc.wr_ticks  = ioi->wr_ticks;\n\t\tsdp.wr_ticks  = ioj->wr_ticks;\n\t\tsdc.dc_ticks  = ioi->dc_ticks;\n\t\tsdp.dc_ticks  = ioj->dc_ticks;\n\n\t\tsdc.rd_sect   = ioi->rd_sectors;\n\t\tsdp.rd_sect   = ioj->rd_sectors;\n\t\tsdc.wr_sect   = ioi->wr_sectors;\n\t\tsdp.wr_sect   = ioj->wr_sectors;\n\t\tsdc.dc_sect   = ioi->dc_sectors;\n\t\tsdp.dc_sect   = ioj->dc_sectors;\n\n\t\tcompute_ext_disk_stats(&sdc, &sdp, itv, &xds);\n\t}\n\n\t/*\n\t * rkB/s  wkB/s dkB/s\n\t * Note: We've already tried to determine if a device had been\n\t * removed then added again (see write_stats() function).\n\t * Anyway we need to check again for possible negative values.\n\t */\n\txios.rsectors = ioi->rd_sectors < ioj->rd_sectors ? 0.0 :\n\t\t\tS_VALUE(ioj->rd_sectors, ioi->rd_sectors, itv);\n\txios.wsectors = ioi->wr_sectors < ioj->wr_sectors ? 0.0 :\n\t\t\tS_VALUE(ioj->wr_sectors, ioi->wr_sectors, itv);\n\txios.dsectors = ioi->dc_sectors < ioj->dc_sectors ? 0.0 :\n\t\t\tS_VALUE(ioj->dc_sectors, ioi->dc_sectors, itv);\n\n\tif (DISPLAY_SHORT_OUTPUT(flags)) {\n\t\txios.sectors  = xios.rsectors + xios.wsectors + xios.dsectors;\n\t}\n\telse {\n\t\tif ((hpart == 1) || !hpart) {\n\t\t\t/* %rrqm */\n\t\t\txios.rrqm_pc = ((ioi->rd_merges - ioj->rd_merges) + (ioi->rd_ios - ioj->rd_ios)) ?\n\t\t\t\t       (double) ((ioi->rd_merges - ioj->rd_merges)) /\n\t\t\t\t       ((ioi->rd_merges - ioj->rd_merges) + (ioi->rd_ios - ioj->rd_ios)) * 100 :\n\t\t\t\t       0.0;\n\t\t\t/* r_await */\n\t\t\txios.r_await = (ioi->rd_ios > ioj->rd_ios) ?\n\t\t\t\t       (ioi->rd_ticks - ioj->rd_ticks) /\n\t\t\t\t       ((double) (ioi->rd_ios - ioj->rd_ios)) : 0.0;\n\t\t\t/* rareq-sz (still in sectors, not kB) */\n\t\t\txios.rarqsz = (ioi->rd_ios > ioj->rd_ios) ?\n\t\t\t\t      (ioi->rd_sectors - ioj->rd_sectors) / ((double) (ioi->rd_ios - ioj->rd_ios)) :\n\t\t\t\t      0.0;\n\t\t}\n\t\tif ((hpart == 2) || !hpart) {\n\t\t\t/* %wrqm */\n\t\t\txios.wrqm_pc = ((ioi->wr_merges - ioj->wr_merges) + (ioi->wr_ios - ioj->wr_ios)) ?\n\t\t\t\t       (double) ((ioi->wr_merges - ioj->wr_merges)) /\n\t\t\t\t       ((ioi->wr_merges - ioj->wr_merges) + (ioi->wr_ios - ioj->wr_ios)) * 100 :\n\t\t\t\t       0.0;\n\t\t\t/* w_await */\n\t\t\txios.w_await = (ioi->wr_ios > ioj->wr_ios) ?\n\t\t\t\t       (ioi->wr_ticks - ioj->wr_ticks) /\n\t\t\t\t       ((double) (ioi->wr_ios - ioj->wr_ios)) : 0.0;\n\t\t\t/* wareq-sz (still in sectors, not kB) */\n\t\t\txios.warqsz = (ioi->wr_ios > ioj->wr_ios) ?\n\t\t\t\t      (ioi->wr_sectors - ioj->wr_sectors) / ((double) (ioi->wr_ios - ioj->wr_ios)) :\n\t\t\t\t      0.0;\n\t\t}\n\t\tif ((hpart == 3) || !hpart) {\n\t\t\t/* %drqm */\n\t\t\txios.drqm_pc = ((ioi->dc_merges - ioj->dc_merges) + (ioi->dc_ios - ioj->dc_ios)) ?\n\t\t\t\t       (double) ((ioi->dc_merges - ioj->dc_merges)) /\n\t\t\t\t       ((ioi->dc_merges - ioj->dc_merges) + (ioi->dc_ios - ioj->dc_ios)) * 100 :\n\t\t\t\t       0.0;\n\t\t\t/* d_await */\n\t\t\txios.d_await = (ioi->dc_ios > ioj->dc_ios) ?\n\t\t\t\t       (ioi->dc_ticks - ioj->dc_ticks) /\n\t\t\t\t       ((double) (ioi->dc_ios - ioj->dc_ios)) : 0.0;\n\t\t\t/* dareq-sz (still in sectors, not kB) */\n\t\t\txios.darqsz = (ioi->dc_ios > ioj->dc_ios) ?\n\t\t\t\t      (ioi->dc_sectors - ioj->dc_sectors) / ((double) (ioi->dc_ios - ioj->dc_ios)) :\n\t\t\t\t      0.0;\n\t\t}\n\t\tif ((hpart == 4) || !hpart) {\n\t\t\t/* f_await */\n\t\t\txios.f_await = (ioi->fl_ios > ioj->fl_ios) ?\n\t\t\t\t       (ioi->fl_ticks - ioj->fl_ticks) /\n\t\t\t\t       ((double) (ioi->fl_ios - ioj->fl_ios)) : 0.0;\n\t\t}\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\twrite_json_ext_stat(tab, itv, fctr, d, ioi, ioj, dname, &xds, &xios);\n\t}\n\telse {\n\t\twrite_plain_ext_stat(itv, fctr, hpart, d, ioi, ioj, dname, &xds, &xios);\n\t}\n}\n\n/*\n ***************************************************************************\n * Write basic stats, read from /proc/diskstats or from sysfs, in plain\n * format.\n *\n * IN:\n * @itv\t\tInterval of time.\n * @fctr\tConversion factor.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @devname\tCurrent device name.\n * @rd_sec\tNumber of sectors read.\n * @wr_sec\tNumber of sectors written.\n * @dc_sec\tNumber of sectors discarded.\n ***************************************************************************\n */\nvoid write_plain_basic_stat(unsigned long long itv, int fctr,\n\t\t\t    struct io_stats *ioi, struct io_stats *ioj,\n\t\t\t    char *devname, unsigned long long rd_sec,\n\t\t\t    unsigned long long wr_sec, unsigned long long dc_sec)\n{\n\tdouble rsectors, wsectors, dsectors;\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \"%-13s\", devname, 0);\n\t}\n\n\trsectors = S_VALUE(ioj->rd_sectors, ioi->rd_sectors, itv);\n\twsectors = S_VALUE(ioj->wr_sectors, ioi->wr_sectors, itv);\n\tdsectors = S_VALUE(ioj->dc_sectors, ioi->dc_sectors, itv);\n\tif (!DISPLAY_UNIT(flags)) {\n\t\trsectors /= fctr;\n\t\twsectors /= fctr;\n\t\tdsectors /= fctr;\n\t}\n\n\t/* tps */\n\tcprintf_f(NO_UNIT, FALSE, 1, 8, 2,\n\t\t  /* Origin (unmerged) flush operations are counted as writes */\n\t\t  S_VALUE(ioj->rd_ios + ioj->wr_ios + ioj->dc_ios,\n\t\t\t  ioi->rd_ios + ioi->wr_ios + ioi->dc_ios, itv));\n\n\tif (DISPLAY_SHORT_OUTPUT(flags)) {\n\t\t/* kB_read/s kB_w+d/s */\n\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, FALSE, 2, 12, 2,\n\t\t\t  rsectors, wsectors + dsectors);\n\t\t/* kB_read kB_w+d */\n\t\tcprintf_u64(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, 2, 10,\n\t\t\t    DISPLAY_UNIT(flags) ? (unsigned long long) rd_sec\n\t\t\t\t\t\t: (unsigned long long) rd_sec / fctr,\n\t\t\t    DISPLAY_UNIT(flags) ? (unsigned long long) wr_sec + dc_sec\n\t\t\t\t\t\t: (unsigned long long) (wr_sec + dc_sec) / fctr);\n\t}\n\telse {\n\t\t/* kB_read/s kB_wrtn/s kB_dscd/s */\n\t\tcprintf_f(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, FALSE, 3, 12, 2,\n\t\t\t  rsectors, wsectors, dsectors);\n\t\t/* kB_read kB_wrtn kB_dscd */\n\t\tcprintf_u64(DISPLAY_UNIT(flags) ? UNIT_SECTOR : NO_UNIT, 3, 10,\n\t\t\t    DISPLAY_UNIT(flags) ? (unsigned long long) rd_sec\n\t\t\t\t\t\t: (unsigned long long) rd_sec / fctr,\n\t\t\t    DISPLAY_UNIT(flags) ? (unsigned long long) wr_sec\n\t\t\t\t\t\t: (unsigned long long) wr_sec / fctr,\n\t\t\t    DISPLAY_UNIT(flags) ? (unsigned long long) dc_sec\n\t\t\t\t\t\t: (unsigned long long) dc_sec / fctr);\n\t}\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", devname, 0);\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Write basic stats, read from /proc/diskstats or from sysfs, in JSON\n * format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @itv\t\tInterval of time.\n * @fctr\tConversion factor.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @devname\tCurrent device name.\n * @rd_sec\tNumber of sectors read.\n * @wr_sec\tNumber of sectors written.\n ***************************************************************************\n */\nvoid write_json_basic_stat(int tab, unsigned long long itv, int fctr,\n\t\t\t   struct io_stats *ioi, struct io_stats *ioj,\n\t\t\t   char *devname, unsigned long long rd_sec,\n\t\t\t   unsigned long long wr_sec, unsigned long long dc_sec)\n{\n\tchar line[256];\n\n\txprintf0(tab,\n\t\t \"{\\\"disk_device\\\": \\\"%s\\\", \\\"tps\\\": %.2f, \",\n\t\t devname,\n\t\t /* Origin (unmerged) flush operations are counted as writes */\n\t\t S_VALUE(ioj->rd_ios + ioj->wr_ios + ioj->dc_ios,\n\t\t\t ioi->rd_ios + ioi->wr_ios + ioi->dc_ios, itv));\n\tif (DISPLAY_KILOBYTES(flags)) {\n\t\tsprintf(line, \"\\\"kB_read/s\\\": %%.2f, \\\"kB_wrtn/s\\\": %%.2f, \\\"kB_dscd/s\\\": %%.2f, \"\n\t\t\t\"\\\"kB_read\\\": %%llu, \\\"kB_wrtn\\\": %%llu, \\\"kB_dscd\\\": %%llu}\");\n\t}\n\telse if (DISPLAY_MEGABYTES(flags)) {\n\t\tsprintf(line, \"\\\"MB_read/s\\\": %%.2f, \\\"MB_wrtn/s\\\": %%.2f, \\\"MB_dscd/s\\\": %%.2f, \"\n\t\t\t\"\\\"MB_read\\\": %%llu, \\\"MB_wrtn\\\": %%llu, \\\"MB_dscd\\\": %%llu}\");\n\t}\n\telse {\n\t\tsprintf(line, \"\\\"Blk_read/s\\\": %%.2f, \\\"Blk_wrtn/s\\\": %%.2f, \\\"Blk_dscd/s\\\": %%.2f, \"\n\t\t\t\"\\\"Blk_read\\\": %%llu, \\\"Blk_wrtn\\\": %%llu, \\\"Blk_dscd\\\": %%llu}\");\n\t}\n\tprintf(line,\n\t       S_VALUE(ioj->rd_sectors, ioi->rd_sectors, itv) / fctr,\n\t       S_VALUE(ioj->wr_sectors, ioi->wr_sectors, itv) / fctr,\n\t       S_VALUE(ioj->dc_sectors, ioi->dc_sectors, itv) / fctr,\n\t       (unsigned long long) rd_sec / fctr,\n\t       (unsigned long long) wr_sec / fctr,\n\t       (unsigned long long) dc_sec / fctr);\n}\n\n/*\n ***************************************************************************\n * Write basic stats, read from /proc/diskstats or from sysfs, in plain or\n * JSON format.\n *\n * IN:\n * @itv\t\tInterval of time.\n * @fctr\tConversion factor.\n * @d\t\tStructure containing device description.\n * @ioi\t\tCurrent sample statistics.\n * @ioj\t\tPrevious sample statistics.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @dname\tName to be used for display for current device.\n ***************************************************************************\n */\nvoid write_basic_stat(unsigned long long itv, int fctr,\n\t\t      struct io_device *d, struct io_stats *ioi,\n\t\t      struct io_stats *ioj, int tab, char *dname)\n{\n\tunsigned long long rd_sec, wr_sec, dc_sec;\n\n\t/* Print stats coming from /sys or /proc/diskstats */\n\trd_sec = ioi->rd_sectors - ioj->rd_sectors;\n\tif ((ioi->rd_sectors < ioj->rd_sectors) && (ioj->rd_sectors <= 0xffffffff)) {\n\t\trd_sec &= 0xffffffff;\n\t}\n\twr_sec = ioi->wr_sectors - ioj->wr_sectors;\n\tif ((ioi->wr_sectors < ioj->wr_sectors) && (ioj->wr_sectors <= 0xffffffff)) {\n\t\twr_sec &= 0xffffffff;\n\t}\n\tdc_sec = ioi->dc_sectors - ioj->dc_sectors;\n\tif ((ioi->dc_sectors < ioj->dc_sectors) && (ioj->dc_sectors <= 0xffffffff)) {\n\t\tdc_sec &= 0xffffffff;\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\twrite_json_basic_stat(tab, itv, fctr, ioi, ioj, dname,\n\t\t\t\t      rd_sec, wr_sec, dc_sec);\n\t}\n\telse {\n\t\twrite_plain_basic_stat(itv, fctr, ioi, ioj, dname,\n\t\t\t\t       rd_sec, wr_sec, dc_sec);\n\t}\n}\n\n/*\n ***************************************************************************\n * Print everything now (stats and uptime).\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @rectime\tCurrent date and time.\n * @skip\tTRUE if nothing should be displayed (option -y). We must\n *\t\tgo through write_stats() anyway to compute groups statistics.\n ***************************************************************************\n */\nvoid write_stats(int curr, struct tm *rectime, int skip)\n{\n\tint h, hl = 0, hh = 0, fctr = 1, tab = 4, next = FALSE;\n\tunsigned long long itv;\n\tstruct io_device *d, *dtmp, *g = NULL, *dnext = NULL;\n\tchar *dev_name;\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags) && !skip) {\n\t\txprintf(tab++, \"{\");\n\t}\n\n\t/* Print time stamp */\n\tif (DISPLAY_TIMESTAMP(flags) && !skip) {\n\t\twrite_sample_timestamp(tab, rectime, xflags);\n\t}\n\n\tif (DISPLAY_CPU(flags) && !skip) {\n\t\t/* Display CPU utilization */\n\t\twrite_cpu_stat(curr, tab);\n\n\t\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\tif (DISPLAY_DISK(flags)) {\n\t\t\t\tprintf(\",\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\t/* Calculate time interval in 1/100th of a second */\n\titv = get_interval(uptime_cs[!curr], uptime_cs[curr]);\n\n\tif (DISPLAY_DISK(flags)) {\n\t\tstruct io_stats *ioi, *ioj, iozero;\n\n\t\tmemset(&iozero, 0, sizeof(struct io_stats));\n\n\t\tif (DISPLAY_PRETTY(flags) &&\n\t\t    DISPLAY_EXTENDED(flags) &&\n\t\t    !DISPLAY_SHORT_OUTPUT(flags) &&\n\t\t    !DISPLAY_JSON_OUTPUT(xflags) &&\n\t\t    !DISPLAY_COMPACT(flags)) {\n\t\t\thl = 1; hh = 4;\n\t\t}\n\n\t\tfor (h = hl; h <= hh; h++) {\n\n\t\t\tif (!skip) {\n\t\t\t\t/* Display disk stats header */\n\t\t\t\twrite_disk_stat_header(&fctr, &tab, h);\n\t\t\t}\n\n\t\t\tfor (d = dev_list; ; d = dnext) {\n\n\t\t\t\tif (d == NULL) {\n\t\t\t\t\tif (g == NULL)\n\t\t\t\t\t\t/* No group processing in progress */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* Display last group before exit */\n\t\t\t\t\tdnext = NULL;\n\t\t\t\t\td = g;\n\t\t\t\t\tg = NULL;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdnext = d->next;\n\n\t\t\t\t\tif (d->dev_tp >= T_GROUP) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a new group: Save group position\n\t\t\t\t\t\t * and display previous one.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (g != NULL) {\n\t\t\t\t\t\t\tdtmp = g;\n\t\t\t\t\t\t\tg = d;\n\t\t\t\t\t\t\td = dtmp;\n\t\t\t\t\t\t\tmemset(g->dev_stats[curr], 0, sizeof(struct io_stats));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tg = d;\n\t\t\t\t\t\t\tmemset(g->dev_stats[curr], 0, sizeof(struct io_stats));\n\t\t\t\t\t\t\tcontinue;\t/* No previous group to display */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!d->exist && (d->dev_tp < T_GROUP))\n\t\t\t\t\t/* Current device is non existent (e.g. it has been unregistered from the system */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((g != NULL) && (h == hl) && (d->dev_tp < T_GROUP)) {\n\t\t\t\t\t/* We are within a group: Increment number of disks in the group */\n\t\t\t\t\t(g->dev_tp)++;\n\t\t\t\t\t/* Add current device stats to group */\n\t\t\t\t\tcompute_device_groups_stats(curr, d, g);\n\t\t\t\t}\n\n\t\t\t\tif (DISPLAY_GROUP_TOTAL_ONLY(flags) && (g != NULL) && (d->dev_tp < T_GROUP))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tioi = d->dev_stats[curr];\n\t\t\t\tioj = d->dev_stats[!curr];\n\t\t\t\t/* Origin (unmerged) flush operations are counted as writes */\n\t\t\t\tif (!DISPLAY_UNFILTERED(flags)) {\n\t\t\t\t\tif (!ioi->rd_ios && !ioi->wr_ios && !ioi->dc_ios && !ioi->fl_ios)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (DISPLAY_ZERO_OMIT(flags)) {\n\t\t\t\t\tif ((ioi->rd_ios == ioj->rd_ios) &&\n\t\t\t\t\t    (ioi->wr_ios == ioj->wr_ios) &&\n\t\t\t\t\t    (ioi->dc_ios == ioj->dc_ios) &&\n\t\t\t\t\t    (ioi->fl_ios == ioj->fl_ios))\n\t\t\t\t\t\t/* No activity: Ignore it */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Try to detect if device has been removed then inserted again */\n\t\t\t\tif (((ioi->rd_ios + ioi->wr_ios + ioi->dc_ios + ioi->fl_ios) <\n\t\t\t\t\t(ioj->rd_ios + ioj->wr_ios + ioj->dc_ios + ioj->fl_ios)) &&\n\t\t\t\t    (!ioj->rd_sectors || (ioi->rd_sectors < ioj->rd_sectors)) &&\n\t\t\t\t    (!ioj->wr_sectors || (ioi->wr_sectors < ioj->wr_sectors)) &&\n\t\t\t\t    (!ioj->dc_sectors || (ioi->dc_sectors < ioj->dc_sectors))) {\n\t\t\t\t\t    ioj = &iozero;\n\t\t\t\t}\n\n\t\t\t\tdev_name = get_device_name(d->major, d->minor, NULL, 0,\n\t\t\t\t\t\t\t   DISPLAY_DEVMAP_NAME(flags),\n\t\t\t\t\t\t\t   DISPLAY_PERSIST_NAME_I(flags),\n\t\t\t\t\t\t\t   FALSE, d->name);\n#ifdef DEBUG\n\t\t\t\tif (DISPLAY_DEBUG(xflags)) {\n\t\t\t\t\t/* Debug output */\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"name=%s itv=%llu fctr=%d ioi{ rd_sectors=%lu \"\n\t\t\t\t\t\t\"wr_sectors=%lu dc_sectors=%lu \"\n\t\t\t\t\t\t\"rd_ios=%lu rd_merges=%lu rd_ticks=%u \"\n\t\t\t\t\t\t\"wr_ios=%lu wr_merges=%lu wr_ticks=%u \"\n\t\t\t\t\t\t\"dc_ios=%lu dc_merges=%lu dc_ticks=%u \"\n\t\t\t\t\t\t\"fl_ios=%lu fl_ticks=%u \"\n\t\t\t\t\t\t\"ios_pgr=%u tot_ticks=%u \"\n\t\t\t\t\t\t\"rq_ticks=%u }\\n\",\n\t\t\t\t\t\tdev_name,\n\t\t\t\t\t\titv,\n\t\t\t\t\t\tfctr,\n\t\t\t\t\t\tioi->rd_sectors,\n\t\t\t\t\t\tioi->wr_sectors,\n\t\t\t\t\t\tioi->dc_sectors,\n\t\t\t\t\t\tioi->rd_ios,\n\t\t\t\t\t\tioi->rd_merges,\n\t\t\t\t\t\tioi->rd_ticks,\n\t\t\t\t\t\tioi->wr_ios,\n\t\t\t\t\t\tioi->wr_merges,\n\t\t\t\t\t\tioi->wr_ticks,\n\t\t\t\t\t\tioi->dc_ios,\n\t\t\t\t\t\tioi->dc_merges,\n\t\t\t\t\t\tioi->dc_ticks,\n\t\t\t\t\t\tioi->fl_ios,\n\t\t\t\t\t\tioi->fl_ticks,\n\t\t\t\t\t\tioi->ios_pgr,\n\t\t\t\t\t\tioi->tot_ticks,\n\t\t\t\t\t\tioi->rq_ticks);\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (!skip) {\n\t\t\t\t\tif (DISPLAY_JSON_OUTPUT(xflags) && next) {\n\t\t\t\t\t\tprintf(\",\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tnext = TRUE;\n\n\t\t\t\t\tif (DISPLAY_EXTENDED(flags)) {\n\t\t\t\t\t\twrite_ext_stat(itv, fctr, h, d, ioi, ioj, tab, dev_name);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twrite_basic_stat(itv, fctr, d, ioi, ioj, tab, dev_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((h > 0) && (h < hh) && !skip) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (DISPLAY_JSON_OUTPUT(xflags) && !skip) {\n\t\t\tprintf(\"\\n\");\n\t\t\txprintf(--tab, \"]\");\n\t\t}\n\t}\n\n\tif (!skip) {\n\t\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\txprintf0(--tab, \"}\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Main loop: Read I/O stats from the relevant sources and display them.\n *\n * IN:\n * @count\tNumber of reports to print.\n * @rectime\tCurrent date and time.\n ***************************************************************************\n */\nvoid rw_io_stat_loop(long int count, struct tm *rectime)\n{\n\tint curr = 1;\n\tint skip = 0;\n\n\t/* Should we skip first report? */\n\tif (DISPLAY_OMIT_SINCE_BOOT(flags) && interval > 0) {\n\t\tskip = 1;\n\t}\n\n\t/* Set a handler for SIGALRM */\n\tmemset(&alrm_act, 0, sizeof(alrm_act));\n\talrm_act.sa_handler = alarm_handler;\n\tsigaction(SIGALRM, &alrm_act, NULL);\n\talarm(interval);\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\tdo {\n\t\t/* Every device is potentially nonexistent */\n\t\tset_devices_nonexistent(dev_list);\n\n\t\t/* Read system uptime */\n\t\tread_uptime(&(uptime_cs[curr]));\n\n\t\t/* Read stats for CPU \"all\" */\n\t\tread_stat_cpu(st_cpu[curr], 1);\n\n\t\t/*\n\t\t * Compute the total number of jiffies spent by all processors.\n\t\t * NB: Don't add cpu_guest/cpu_guest_nice because cpu_user/cpu_nice\n\t\t * already include them.\n\t\t */\n\t\ttot_jiffies[curr] = st_cpu[curr]->cpu_user + st_cpu[curr]->cpu_nice +\n\t\t\t\t    st_cpu[curr]->cpu_sys + st_cpu[curr]->cpu_idle +\n\t\t\t\t    st_cpu[curr]->cpu_iowait + st_cpu[curr]->cpu_hardirq +\n\t\t\t\t    st_cpu[curr]->cpu_steal + st_cpu[curr]->cpu_softirq;\n\n\t\tif (DISPLAY_EVERYTHING(flags)) {\n\t\t\tread_diskstats_stat(curr);\n\t\t}\n\t\telse {\n\t\t\tread_sysfs_dlist_stat(curr);\n\t\t}\n\n\t\t/* Get time */\n\t\tget_xtime(rectime, 0, LOCAL_TIME);\n\n\t\t/* Print results */\n\t\twrite_stats(curr, rectime, skip);\n\n\t\tif (!skip) {\n\t\t\tif (count > 0) {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\t\t\tcurr ^= 1;\n\t\t\t__pause();\n\n\t\t\tif (sigint_caught) {\n\t\t\t\t/* SIGINT signal caught => Terminate JSON output properly */\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse if (DISPLAY_JSON_OUTPUT(xflags) && !skip) {\t/* count != 0 */\n\t\t\t\tprintf(\",\");\n\t\t\t}\n\t\t\tskip = 0;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\twhile (count);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}}\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Main entry to the iostat program.\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint it = 0;\n\tint opt = 1;\n\tint i, report_set = FALSE;\n\tlong count = 1;\n\tstruct utsname header;\n\tstruct tm rectime;\n\tchar *t, *persist_devname, *devname;\n\tchar group_name[MAX_NAME_LEN];\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\talt_dir[0] = '\\0';\n\n\t/* Process args... */\n\twhile (opt < argc) {\n\n\t\t/* -p option used individually. See below for grouped use */\n\t\tif (!strcmp(argv[opt], \"-p\")) {\n\t\t\tif (argv[++opt] &&\n\t\t\t    (strspn(argv[opt], DIGITS) != strlen(argv[opt])) &&\n\t\t\t    (strncmp(argv[opt], \"-\", 1))) {\n\t\t\t\tflags |= I_D_UNFILTERED;\n\n\t\t\t\tfor (t = strtok(argv[opt], \",\"); t; t = strtok(NULL, \",\")) {\n\t\t\t\t\tif (!strcmp(t, K_ALL)) {\n\t\t\t\t\t\tflags |= I_D_EVERYTHING;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdevname = device_name(t);\n\t\t\t\t\t\tif (DISPLAY_PERSIST_NAME_I(flags)) {\n\t\t\t\t\t\t\t/* Get device persistent name */\n\t\t\t\t\t\t\tpersist_devname = get_pretty_name_from_persistent(devname);\n\t\t\t\t\t\t\tif (persist_devname != NULL) {\n\t\t\t\t\t\t\t\tdevname = persist_devname;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Store device name */\n\t\t\t\t\t\tadd_list_device(&dev_list, devname, T_PART_DEV, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflags |= I_D_EVERYTHING;\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-g\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tflags |= I_F_GROUP_DEFINED;\n\n\t\t\t/*\n\t\t\t * MAX_NAME_LEN - 2: one char for the heading space,\n\t\t\t * and one for the trailing '\\0'.\n\t\t\t */\n\t\t\tsnprintf(group_name, MAX_NAME_LEN, \" %-.*s\", MAX_NAME_LEN - 2, argv[opt++]);\n\t\t\tadd_list_device(&dev_list, group_name, T_GROUP, 0, 0);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--human\")) {\n\t\t\tflags |= I_D_UNIT;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--pretty\")) {\n\t\t\t/* Display an easy-to-read CIFS report */\n\t\t\tflags |= I_D_PRETTY;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--compact\")) {\n\t\t\tflags |= I_D_COMPACT;\n\t\t\topt++;\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t\topt++;\n\t\t}\n#endif\n\n\t\telse if (!strncmp(argv[opt], \"--dec=\", 6) && (strlen(argv[opt]) == 7)) {\n\t\t\t/* Check that the argument is a digit */\n\t\t\tif (!isdigit(argv[opt][6])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\n\t\t\t/* Get number of decimal places */\n\t\t\tdplaces_nr = atoi(argv[opt] + 6);\n\t\t\tif ((dplaces_nr < 0) || (dplaces_nr > 2)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-f\") || !strcmp(argv[opt], \"+f\")) {\n\t\t\tif (alt_dir[0] || !argv[opt + 1]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (argv[opt++][0] == '+') {\n\t\t\t\tflags |= I_D_ALL_DIR;\n\t\t\t}\n\t\t\tstrncpy(alt_dir, argv[opt++], sizeof(alt_dir));\n\t\t\talt_dir[sizeof(alt_dir) - 1] = '\\0';\n\t\t\tif (!check_dir(alt_dir)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-j\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (strnlen(argv[opt], sizeof(persistent_name_type)) >= sizeof(persistent_name_type) - 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tstrncpy(persistent_name_type, argv[opt], sizeof(persistent_name_type) - 1);\n\t\t\tpersistent_name_type[sizeof(persistent_name_type) - 1] = '\\0';\n\t\t\tstrtolower(persistent_name_type);\n\t\t\t/* Check that this is a valid type of persistent device name */\n\t\t\tif (!get_persistent_type_dir(persistent_name_type)) {\n\t\t\t\tfprintf(stderr, _(\"Invalid type of persistent device name\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t/* Persistent names are usually long: Pretty display them */\n\t\t\tflags |= I_D_PERSIST_NAME + I_D_PRETTY;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\t/* Select output format */\n\t\t\tif (argv[++opt] && !strcmp(argv[opt], K_JSON)) {\n\t\t\t\txflags |= X_D_JSON_OUTPUT;\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n#ifdef DEBUG\n\t\telse if (!strcmp(argv[opt], \"--debuginfo\")) {\n\t\t\txflags |= X_D_DEBUG;\n\t\t\topt++;\n\t\t}\n#endif\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\tfor (i = 1; *(argv[opt] + i); i++) {\n\n\t\t\t\tswitch (*(argv[opt] + i)) {\n\n\t\t\t\tcase 'c':\n\t\t\t\t\t/* Display cpu usage */\n\t\t\t\t\tflags |= I_D_CPU;\n\t\t\t\t\treport_set = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\t/* Display disk utilization */\n\t\t\t\t\tflags |= I_D_DISK;\n\t\t\t\t\treport_set = TRUE;\n\t\t\t\t\tbreak;\n\n                                case 'H':\n\t\t\t\t\t/* Display stats only for the groups */\n\t\t\t\t\tflags |= I_D_GROUP_TOTAL_ONLY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'h':\n\t\t\t\t\t/* Option -h is equivalent to --pretty --human */\n\t\t\t\t\tflags |= I_D_PRETTY + I_D_UNIT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'k':\n\t\t\t\t\tif (DISPLAY_MEGABYTES(flags)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\t/* Display stats in kB/s */\n\t\t\t\t\tflags |= I_D_KILOBYTES;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'm':\n\t\t\t\t\tif (DISPLAY_KILOBYTES(flags)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\t/* Display stats in MB/s */\n\t\t\t\t\tflags |= I_D_MEGABYTES;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'N':\n\t\t\t\t\t/* Display device mapper logical name */\n\t\t\t\t\tflags |= I_D_DEVMAP_NAME;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'p':\n\t\t\t\t\t/* If option -p is grouped then it cannot take an arg */\n\t\t\t\t\tflags |= I_D_EVERYTHING;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 's':\n\t\t\t\t\t/* Display short output */\n\t\t\t\t\tflags |= I_D_SHORT_OUTPUT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 't':\n\t\t\t\t\t/* Display timestamp */\n\t\t\t\t\tflags |= I_D_TIMESTAMP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'x':\n\t\t\t\t\t/* Display extended stats */\n\t\t\t\t\tflags |= I_D_EXTENDED;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'y':\n\t\t\t\t\t/* Don't display stats since system restart */\n\t\t\t\t\tflags |= I_D_OMIT_SINCE_BOOT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'z':\n\t\t\t\t\t/* Omit output for devices with no activity */\n\t\t\t\t\tflags |= I_D_ZERO_OMIT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'V':\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *iostat_env[] = {ENV_POSIXLY_CORRECT,\n\t\t\t\t\t\t\t\t      ENV_COLORS,\n\t\t\t\t\t\t\t\t      ENV_COLORS_SGR,\n\t\t\t\t\t\t\t\t      ENV_TIME_FMT};\n#define IOSTAT_ENV_NR\t4\n\t\t\t\t\t\t/* Print environment contents, version number and exit */\n\t\t\t\t\t\tprint_version(iostat_env, IOSTAT_ENV_NR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t/*\n\t\t\t * By default iostat doesn't display unused devices.\n\t\t\t * If some devices are explicitly entered on the command line\n\t\t\t * then don't apply this rule any more.\n\t\t\t */\n\t\t\tflags |= I_D_UNFILTERED;\n\n\t\t\tif (strcmp(argv[opt], K_ALL)) {\n\t\t\t\t/* Store device name entered on the command line */\n\t\t\t\tdevname = device_name(argv[opt++]);\n\t\t\t\tif (DISPLAY_PERSIST_NAME_I(flags)) {\n\t\t\t\t\tpersist_devname = get_pretty_name_from_persistent(devname);\n\t\t\t\t\tif (persist_devname != NULL) {\n\t\t\t\t\t\tdevname = persist_devname;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadd_list_device(&dev_list, devname, 0, UKWN_MAJ_NR, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflags |= I_D_ALL_DEVICES;\n\t\t\t\topt++;\n\t\t\t}\n\t\t}\n\n\t\telse if (!it) {\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = -1;\n\t\t\tit = 1;\n\t\t}\n\n\t\telse if (it > 0) {\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif ((count < 1) || !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tit = -1;\n\t\t}\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!interval) {\n\t\tcount = 1;\n\t}\n\n\t/* Init color strings */\n\tinit_colors();\n\n\t/* Default: Display CPU and DISK reports */\n\tif (!report_set) {\n\t\tflags |= I_D_CPU + I_D_DISK;\n\t}\n\t/*\n\t * Also display DISK reports if options -p, -x or a device has been entered\n\t * on the command line.\n\t */\n\tif (DISPLAY_EVERYTHING(flags) || DISPLAY_EXTENDED(flags) ||\n\t    DISPLAY_UNFILTERED(flags)) {\n\t\tflags |= I_D_DISK;\n\t}\n\n\tif (!DISPLAY_UNFILTERED(flags)) {\n\t\tflags |= I_D_ALL_DEVICES;\n\t}\n\t/* Option -H can only be used with option -g */\n\tif (DISPLAY_GROUP_TOTAL_ONLY(flags) && !GROUP_DEFINED(flags)) {\n\t\tusage(argv[0]);\n\t}\n\n\t/* Select disk output unit (kB/s or blocks/s) */\n\tset_disk_output_unit();\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t/* Use a decimal point to make JSON code compliant with RFC7159 */\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t}\n\n\t/* Allocate and init stat common counters */\n\tinit_stats();\n\n\t/* How many processors on this machine? */\n\tcpu_nr = get_cpu_nr(~0, FALSE);\n\n\tget_xtime(&rectime, 0, LOCAL_TIME);\n\n\t/*\n\t * Don't buffer data if redirected to a pipe.\n\t * Note: With musl-c, the behavior of this function is undefined except\n\t * when it is the first operation on the stream.\n\t */\n\tsetbuf(stdout, NULL);\n\n\t/* Get system name, release number and hostname */\n\t__uname(&header);\n\tif (print_gal_header(&rectime, header.sysname, header.release,\n\t\t\t     header.nodename, header.machine, cpu_nr,\n\t\t\t     DISPLAY_JSON_OUTPUT(xflags))) {\n\t\txflags |= X_D_ISO;\n\t}\n\tif (!DISPLAY_JSON_OUTPUT(xflags) &&\n\t    (!DISPLAY_OMIT_SINCE_BOOT(flags) || (interval == 0))) {\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* Main loop */\n\trw_io_stat_loop(count, &rectime);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "iostat.h",
          "type": "blob",
          "size": 5.228515625,
          "content": "/*\n * iostat: report CPU and I/O statistics\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _IOSTAT_H\n#define _IOSTAT_H\n\n#include \"common.h\"\n\n/* I_: iostat - D_: Display - F_: Flag */\n#define I_D_CPU\t\t\t0x000001\n#define I_D_DISK\t\t0x000002\n#define I_D_TIMESTAMP\t\t0x000004\n#define I_D_EXTENDED\t\t0x000008\n#define I_D_EVERYTHING\t\t0x000010\n#define I_D_KILOBYTES\t\t0x000020\n#define I_D_ALL_DIR\t\t0x000040\n/* Unused\t\t\t0x000080 */\n#define I_D_UNFILTERED\t\t0x000100\n#define I_D_MEGABYTES\t\t0x000200\n#define I_D_ALL_DEVICES\t\t0x000400\n#define I_F_GROUP_DEFINED\t0x000800\n#define I_D_PRETTY\t\t0x001000\n#define I_D_PERSIST_NAME\t0x002000\n#define I_D_OMIT_SINCE_BOOT\t0x004000\n/* Unused\t\t\t0x008000 */\n#define I_D_DEVMAP_NAME\t\t0x010000\n/* Unused\t\t\t0x020000 */\n#define I_D_GROUP_TOTAL_ONLY\t0x040000\n#define I_D_ZERO_OMIT\t\t0x080000\n#define I_D_UNIT\t\t0x100000\n#define I_D_SHORT_OUTPUT\t0x200000\n#define I_D_COMPACT\t\t0x400000\n\n#define DISPLAY_CPU(m)\t\t\t(((m) & I_D_CPU)              == I_D_CPU)\n#define DISPLAY_DISK(m)\t\t\t(((m) & I_D_DISK)             == I_D_DISK)\n#define DISPLAY_TIMESTAMP(m)\t\t(((m) & I_D_TIMESTAMP)        == I_D_TIMESTAMP)\n#define DISPLAY_EXTENDED(m)\t\t(((m) & I_D_EXTENDED)         == I_D_EXTENDED)\n#define DISPLAY_EVERYTHING(m)\t\t(((m) & I_D_EVERYTHING)       == I_D_EVERYTHING)\n#define DISPLAY_KILOBYTES(m)\t\t(((m) & I_D_KILOBYTES)        == I_D_KILOBYTES)\n#define DISPLAY_MEGABYTES(m)\t\t(((m) & I_D_MEGABYTES)        == I_D_MEGABYTES)\n#define DISPLAY_UNFILTERED(m)\t\t(((m) & I_D_UNFILTERED)       == I_D_UNFILTERED)\n#define DISPLAY_ALL_DEVICES(m)\t\t(((m) & I_D_ALL_DEVICES)      == I_D_ALL_DEVICES)\n#define GROUP_DEFINED(m)\t\t(((m) & I_F_GROUP_DEFINED)    == I_F_GROUP_DEFINED)\n#define DISPLAY_PRETTY(m)\t\t(((m) & I_D_PRETTY)           == I_D_PRETTY)\n#define DISPLAY_PERSIST_NAME_I(m)\t(((m) & I_D_PERSIST_NAME)     == I_D_PERSIST_NAME)\n#define DISPLAY_OMIT_SINCE_BOOT(m)\t(((m) & I_D_OMIT_SINCE_BOOT)  == I_D_OMIT_SINCE_BOOT)\n#define DISPLAY_DEVMAP_NAME(m)\t\t(((m) & I_D_DEVMAP_NAME)      == I_D_DEVMAP_NAME)\n#define DISPLAY_GROUP_TOTAL_ONLY(m)\t(((m) & I_D_GROUP_TOTAL_ONLY) == I_D_GROUP_TOTAL_ONLY)\n#define DISPLAY_ZERO_OMIT(m)\t\t(((m) & I_D_ZERO_OMIT)        == I_D_ZERO_OMIT)\n#define DISPLAY_UNIT(m)\t\t\t(((m) & I_D_UNIT)\t      == I_D_UNIT)\n#define DISPLAY_SHORT_OUTPUT(m)\t\t(((m) & I_D_SHORT_OUTPUT)     == I_D_SHORT_OUTPUT)\n#define USE_ALL_DIR(m)\t\t\t(((m) & I_D_ALL_DIR)          == I_D_ALL_DIR)\n#define DISPLAY_COMPACT(m)\t\t(((m) & I_D_COMPACT)          == I_D_COMPACT)\n\nenum {\n\tT_PART\t\t= 0,\n\tT_DEV\t\t= 1,\n\tT_PART_DEV\t= 2,\n\tT_GROUP\t\t= 3\n};\n\n#define UKWN_MAJ_NR\t0\n\n/* Environment variable */\n#define ENV_POSIXLY_CORRECT\t\"POSIXLY_CORRECT\"\n\n/*\n * Structures for I/O stats.\n * These are now dynamically allocated.\n */\nstruct io_stats {\n\t/* # of sectors read */\n\tunsigned long rd_sectors\t__attribute__ ((aligned (8)));\n\t/* # of sectors written */\n\tunsigned long wr_sectors\t__attribute__ ((packed));\n\t/* # of sectors discarded */\n\tunsigned long dc_sectors\t__attribute__ ((packed));\n\t/* # of read operations issued to the device */\n\tunsigned long rd_ios\t\t__attribute__ ((packed));\n\t/* # of read requests merged */\n\tunsigned long rd_merges\t\t__attribute__ ((packed));\n\t/* # of write operations issued to the device */\n\tunsigned long wr_ios\t\t__attribute__ ((packed));\n\t/* # of write requests merged */\n\tunsigned long wr_merges\t\t__attribute__ ((packed));\n\t/* # of discard operations issued to the device */\n\tunsigned long dc_ios\t\t__attribute__ ((packed));\n\t/* # of discard requests merged */\n\tunsigned long dc_merges\t\t__attribute__ ((packed));\n\t/* # of flush requests issued to the device */\n\tunsigned long fl_ios\t\t__attribute__ ((packed));\n\t/* Time of read requests in queue */\n\tunsigned int  rd_ticks\t\t__attribute__ ((packed));\n\t/* Time of write requests in queue */\n\tunsigned int  wr_ticks\t\t__attribute__ ((packed));\n\t/* Time of discard requests in queue */\n\tunsigned int  dc_ticks\t\t__attribute__ ((packed));\n\t/* Time of flush requests in queue */\n\tunsigned int  fl_ticks\t\t__attribute__ ((packed));\n\t/* # of I/Os in progress */\n\tunsigned int  ios_pgr\t\t__attribute__ ((packed));\n\t/* # of ticks total (for this device) for I/O */\n\tunsigned int  tot_ticks\t\t__attribute__ ((packed));\n\t/* # of ticks requests spent in queue */\n\tunsigned int  rq_ticks\t\t__attribute__ ((packed));\n};\n\n#define IO_STATS_SIZE\t(sizeof(struct io_stats))\n\nstruct io_device {\n\tchar name[MAX_NAME_LEN];\n\t/*\n\t * 0: Not a whole device (T_PART)\n\t * 1: whole device (T_DEV)\n\t * 2: whole device and all its partitions to be read (T_PART_DEV)\n\t * 3+: group name (T_GROUP) (4 means 1 device in the group, 5 means 2 devices in the group, etc.)\n\t */\n\tint dev_tp;\n\t/* TRUE if device exists in /proc/diskstats or /sys. Don't apply for groups. */\n\tint exist;\n\t/* major and minor numbers (not set for T_GROUP \"devices\") */\n\tint major;\n\tint minor;\n\tstruct io_stats *dev_stats[2];\n\tstruct io_device *next;\n};\n\nstruct ext_io_stats {\n\t/* r_await */\n\tdouble r_await;\n\t/* w_await */\n\tdouble w_await;\n\t/* d_await */\n\tdouble d_await;\n\t/* f_await */\n\tdouble f_await;\n\t/* rsec/s */\n\tdouble rsectors;\n\t/* wsec/s */\n\tdouble wsectors;\n\t/* dsec/s */\n\tdouble dsectors;\n\t/* sec/s */\n\tdouble sectors;\n\t/* %rrqm */\n\tdouble rrqm_pc;\n\t/* %wrqm */\n\tdouble wrqm_pc;\n\t/* %drqm */\n\tdouble drqm_pc;\n\t/* rareq-sz */\n\tdouble rarqsz;\n\t/* wareq-sz */\n\tdouble warqsz;\n\t/* dareq-sz */\n\tdouble darqsz;\n};\n\n#endif  /* _IOSTAT_H */\n"
        },
        {
          "name": "json_stats.c",
          "type": "blob",
          "size": 76.900390625,
          "content": "/*\n * json_stats.c: Functions used by sadf to display statistics in JSON format.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"sa.h\"\n#include \"ioconf.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nextern uint64_t flags;\nextern char bat_status[][16];\n\n/*\n ***************************************************************************\n * Open or close \"network\" markup.\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tOpen or close action.\n ***************************************************************************\n */\nvoid json_markup_network(int tab, enum json_action action)\n{\n\tstatic int markup_state = CLOSE_JSON_MARKUP;\n\n\tif (action == markup_state)\n\t\treturn;\n\tmarkup_state = action;\n\n\tif (action == OPEN_JSON_MARKUP) {\n\t\t/* Open markup */\n\t\txprintf(tab, \"\\\"network\\\": {\");\n\t}\n\telse {\n\t\t/* Close markup */\n\t\tprintf(\"\\n\");\n\t\txprintf0(tab, \"}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Open or close \"power-management\" markup.\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tOpen or close action.\n ***************************************************************************\n */\nvoid json_markup_power_management(int tab, enum json_action action)\n{\n\tstatic int markup_state = CLOSE_JSON_MARKUP;\n\n\tif (action == markup_state)\n\t\treturn;\n\tmarkup_state = action;\n\n\tif (action == OPEN_JSON_MARKUP) {\n\t\t/* Open markup */\n\t\txprintf(tab, \"\\\"power-management\\\": {\");\n\t}\n\telse {\n\t\t/* Close markup */\n\t\tprintf(\"\\n\");\n\t\txprintf0(tab, \"}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Open or close \"psi\" markup.\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tOpen or close action.\n ***************************************************************************\n */\nvoid json_markup_psi(int tab, enum json_action action)\n{\n\tstatic int markup_state = CLOSE_JSON_MARKUP;\n\n\tif (action == markup_state)\n\t\treturn;\n\tmarkup_state = action;\n\n\tif (action == OPEN_JSON_MARKUP) {\n\t\t/* Open markup */\n\t\txprintf(tab, \"\\\"psi\\\": {\");\n\t}\n\telse {\n\t\t/* Close markup */\n\t\tprintf(\"\\n\");\n\t\txprintf0(tab, \"}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second (independent of the\n *\t\tnumber of processors). Unused here.\n ***************************************************************************\n */\n__print_funct_t json_print_cpu_stats(struct activity *a, int curr, int tab,\n\t\t\t\t     unsigned long long itv)\n{\n\tint i;\n\tint sep = FALSE;\n\tunsigned long long deltot_jiffies = 1;\n\tstruct stats_cpu *scc, *scp;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tchar cpuno[16];\n\n\txprintf(tab++, \"\\\"cpu-load\\\": [\");\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/*\n\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t * and look for offline CPU.\n\t */\n\tif (a->nr_ini > 1) {\n\t\tdeltot_jiffies = get_global_cpu_statistics(a, !curr, curr,\n\t\t\t\t\t\t\t   flags, offline_cpu_bitmap);\n\t}\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* Don't display CPU */\n\t\t\tcontinue;\n\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr]  + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\n\t\t\tif (a->nr_ini == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a UP machine. In this case\n\t\t\t\t * interval has still not been calculated.\n\t\t\t\t */\n\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t\t}\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* CPU \"all\" cannot be tickless */\n\t\t\t\tdeltot_jiffies = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\n\t\t\t/*\n\t\t\t * Recalculate interval for current proc.\n\t\t\t * If result is 0 then current CPU is a tickless one.\n\t\t\t */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* Current CPU is tickless */\n\t\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%d\\\", \"\n\t\t\t\t\t\t \"\\\"user\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"nice\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"system\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"iowait\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"steal\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"idle\\\": %.2f}\",\n\t\t\t\t\t\t i - 1, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t\t}\n\t\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%d\\\", \"\n\t\t\t\t\t\t \"\\\"usr\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"nice\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"sys\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"iowait\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"steal\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"irq\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"soft\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"guest\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"gnice\\\": %.2f, \"\n\t\t\t\t\t\t \"\\\"idle\\\": %.2f}\",\n\t\t\t\t\t\t i - 1, 0.0, 0.0, 0.0, 0.0,\n\t\t\t\t\t\t 0.0, 0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%s\\\", \"\n\t\t\t\t \"\\\"user\\\": %.2f, \"\n\t\t\t\t \"\\\"nice\\\": %.2f, \"\n\t\t\t\t \"\\\"system\\\": %.2f, \"\n\t\t\t\t \"\\\"iowait\\\": %.2f, \"\n\t\t\t\t \"\\\"steal\\\": %.2f, \"\n\t\t\t\t \"\\\"idle\\\": %.2f}\",\n\t\t\t\t cpuno,\n\t\t\t\t ll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\t     scc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t\t\t\t     deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t\t scc->cpu_idle < scp->cpu_idle ?\n\t\t\t\t 0.0 :\n\t\t\t\t ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies));\n\t\t}\n\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%s\\\", \"\n\t\t\t\t \"\\\"usr\\\": %.2f, \"\n\t\t\t\t \"\\\"nice\\\": %.2f, \"\n\t\t\t\t \"\\\"sys\\\": %.2f, \"\n\t\t\t\t \"\\\"iowait\\\": %.2f, \"\n\t\t\t\t \"\\\"steal\\\": %.2f, \"\n\t\t\t\t \"\\\"irq\\\": %.2f, \"\n\t\t\t\t \"\\\"soft\\\": %.2f, \"\n\t\t\t\t \"\\\"guest\\\": %.2f, \"\n\t\t\t\t \"\\\"gnice\\\": %.2f, \"\n\t\t\t\t \"\\\"idle\\\": %.2f}\",\n\t\t\t\t cpuno,\n\t\t\t\t (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t\t 0.0 :\n\t\t\t\t ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\t     scc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t\t (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t\t 0.0 :\n\t\t\t\t ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\t     scc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_sys, scc->cpu_sys, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies),\n\t\t\t\t ll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t scc->cpu_idle < scp->cpu_idle ?\n\t\t\t\t 0.0 :\n\t\t\t\t ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies));\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display task creation and context switch statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pcsw_stats(struct activity *a, int curr, int tab,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr],\n\t\t*spp = (struct stats_pcsw *) a->buf[!curr];\n\n\t/* proc/s and cswch/s */\n\txprintf0(tab, \"\\\"process-and-context-switch\\\": {\"\n\t\t \"\\\"proc\\\": %.2f, \"\n\t\t \"\\\"cswch\\\": %.2f}\",\n\t\t S_VALUE(spp->processes, spc->processes, itv),\n\t\t S_VALUE(spp->context_switch, spc->context_switch, itv));\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_irq_stats(struct activity *a, int curr, int tab,\n\t\t\t\t     unsigned long long itv)\n{\n\tint i, c;\n\tstruct stats_irq *stc_cpu_irq, *stp_cpu_irq, *stc_cpuall_irq;\n\tunsigned char masked_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tint sep = FALSE, first;\n\n\txprintf(tab++, \"\\\"interrupts\\\": [\");\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Identify offline and unselected CPU, and keep persistent statistics values */\n\tget_global_int_statistics(a, !curr, curr, flags, masked_cpu_bitmap);\n\n\tfor (i = 0; i < a->nr2; i++) {\n\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, stc_cpuall_irq->irq_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfirst = TRUE;\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\n\t\tfor (c = 0; (c < a->nr[curr]) && (c < a->bitmap->b_size + 1); c++) {\n\n\t\t\tstc_cpu_irq = (struct stats_irq *) ((char *) a->buf[curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\t\t\tstp_cpu_irq = (struct stats_irq *) ((char *) a->buf[!curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (IS_CPU_SET(masked_cpu_bitmap, c))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\t/* Yes: Display it */\n\t\t\tif (first) {\n\t\t\t\txprintf0(tab, \"{\\\"intr\\\": \\\"%s\\\"\", stc_cpuall_irq->irq_name);\n\t\t\t\tfirst = FALSE;\n\t\t\t}\n\n\t\t\tif (!c) {\n\t\t\t\tprintf(\", \\\"all\\\": %.2f\",\n\t\t\t\t       (stc_cpu_irq->irq_nr < stp_cpu_irq->irq_nr) ? 0.0 :\n\t\t\t\t       S_VALUE(stp_cpu_irq->irq_nr, stc_cpu_irq->irq_nr, itv));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\", \\\"CPU%d\\\": %.2f\", c - 1,\n\t\t\t\t       S_VALUE(stp_cpu_irq->irq_nr, stc_cpu_irq->irq_nr, itv));\n\t\t\t}\n\t\t}\n\t\tif (!first) {\n\t\t\tprintf(\"}\");\n\t\t\tsep = TRUE;\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display swapping statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_swap_stats(struct activity *a, int curr, int tab,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr],\n\t\t*ssp = (struct stats_swap *) a->buf[!curr];\n\n\txprintf0(tab, \"\\\"swap-pages\\\": {\"\n\t\t \"\\\"pswpin\\\": %.2f, \"\n\t\t \"\\\"pswpout\\\": %.2f}\",\n\t\t S_VALUE(ssp->pswpin,  ssc->pswpin,  itv),\n\t\t S_VALUE(ssp->pswpout, ssc->pswpout, itv));\n}\n\n/*\n ***************************************************************************\n * Display paging statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_paging_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr],\n\t\t*spp = (struct stats_paging *) a->buf[!curr];\n\n\txprintf0(tab, \"\\\"paging\\\": {\"\n\t\t \"\\\"pgpgin\\\": %.2f, \"\n\t\t \"\\\"pgpgout\\\": %.2f, \"\n\t\t \"\\\"fault\\\": %.2f, \"\n\t\t \"\\\"majflt\\\": %.2f, \"\n\t\t \"\\\"pgfree\\\": %.2f, \"\n\t\t \"\\\"pgscank\\\": %.2f, \"\n\t\t \"\\\"pgscand\\\": %.2f, \"\n\t\t \"\\\"pgsteal\\\": %.2f, \"\n\t\t \"\\\"pgprom\\\": %.2f, \"\n\t\t \"\\\"pgdem\\\": %.2f}\",\n\t\t S_VALUE(spp->pgpgin,        spc->pgpgin,        itv),\n\t\t S_VALUE(spp->pgpgout,       spc->pgpgout,       itv),\n\t\t S_VALUE(spp->pgfault,       spc->pgfault,       itv),\n\t\t S_VALUE(spp->pgmajfault,    spc->pgmajfault,    itv),\n\t\t S_VALUE(spp->pgfree,        spc->pgfree,        itv),\n\t\t S_VALUE(spp->pgscan_kswapd, spc->pgscan_kswapd, itv),\n\t\t S_VALUE(spp->pgscan_direct, spc->pgscan_direct, itv),\n\t\t S_VALUE(spp->pgsteal,       spc->pgsteal,       itv),\n\t\t S_VALUE(spp->pgpromote,     spc->pgpromote,     itv),\n\t\t S_VALUE(spp->pgdemote,      spc->pgdemote,      itv));\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_io_stats(struct activity *a, int curr, int tab,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr],\n\t\t*sip = (struct stats_io *) a->buf[!curr];\n\n\txprintf0(tab, \"\\\"io\\\": {\"\n\t\t \"\\\"tps\\\": %.2f, \"\n\t\t \"\\\"io-reads\\\": {\"\n\t\t \"\\\"rtps\\\": %.2f, \"\n\t\t \"\\\"bread\\\": %.2f}, \"\n\t\t \"\\\"io-writes\\\": {\"\n\t\t \"\\\"wtps\\\": %.2f, \"\n\t\t \"\\\"bwrtn\\\": %.2f}, \"\n\t\t \"\\\"io-discard\\\": {\"\n\t\t \"\\\"dtps\\\": %.2f, \"\n\t\t \"\\\"bdscd\\\": %.2f}}\",\n\t\t /*\n\t\t  * If we get negative values, this is probably because\n\t\t  * one or more devices/filesystems have been unmounted.\n\t\t  * We display 0.0 in this case though we should rather tell\n\t\t  * the user that the value cannot be calculated here.\n\t\t  */\n\t\t sic->dk_drive < sip->dk_drive ? 0.0 :\n\t\t S_VALUE(sip->dk_drive, sic->dk_drive, itv),\n\t\t sic->dk_drive_rio < sip->dk_drive_rio ? 0.0 :\n\t\t S_VALUE(sip->dk_drive_rio, sic->dk_drive_rio, itv),\n\t\t sic->dk_drive_rblk < sip->dk_drive_rblk ? 0.0 :\n\t\t S_VALUE(sip->dk_drive_rblk, sic->dk_drive_rblk, itv),\n\t\t sic->dk_drive_wio < sip->dk_drive_wio ? 0.0 :\n\t\t S_VALUE(sip->dk_drive_wio, sic->dk_drive_wio, itv),\n\t\t sic->dk_drive_wblk < sip->dk_drive_wblk ? 0.0 :\n\t\t S_VALUE(sip->dk_drive_wblk, sic->dk_drive_wblk, itv),\n\t\t sic->dk_drive_dio < sip->dk_drive_dio ? 0.0 :\n\t\t S_VALUE(sip->dk_drive_dio, sic->dk_drive_dio, itv),\n\t\t sic->dk_drive_dblk < sip->dk_drive_dblk ? 0.0 :\n\t\t S_VALUE(sip->dk_drive_dblk, sic->dk_drive_dblk, itv));\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization in JSON.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @dispall\tTRUE if all memory fields should be displayed.\n ***************************************************************************\n */\nvoid json_print_ram_memory_stats(struct stats_memory *smc, int dispall)\n{\n\tunsigned long long nousedmem;\n\n\tnousedmem = smc->frmkb + smc->bufkb + smc->camkb + smc->slabkb;\n\tif (nousedmem > smc->tlmkb) {\n\t\tnousedmem = smc->tlmkb;\n\t}\n\n\tprintf(\"\\\"memfree\\\": %llu, \"\n\t       \"\\\"avail\\\": %llu, \"\n\t       \"\\\"memused\\\": %llu, \"\n\t       \"\\\"memused-percent\\\": %.2f, \"\n\t       \"\\\"buffers\\\": %llu, \"\n\t       \"\\\"cached\\\": %llu, \"\n\t       \"\\\"commit\\\": %llu, \"\n\t       \"\\\"commit-percent\\\": %.2f, \"\n\t       \"\\\"active\\\": %llu, \"\n\t       \"\\\"inactive\\\": %llu, \"\n\t       \"\\\"dirty\\\": %llu\",\n\t       smc->frmkb,\n\t       smc->availablekb,\n\t       smc->tlmkb - nousedmem,\n\t       smc->tlmkb ? SP_VALUE(nousedmem, smc->tlmkb, smc->tlmkb)\n\t\t\t  : 0.0,\n\t       smc->bufkb,\n\t       smc->camkb,\n\t       smc->comkb,\n\t       (smc->tlmkb + smc->tlskb) ? SP_VALUE(0, smc->comkb, smc->tlmkb + smc->tlskb)\n\t\t\t\t\t : 0.0,\n\t       smc->activekb,\n\t       smc->inactkb,\n\t       smc->dirtykb);\n\n\tif (dispall) {\n\t\t/* Display extended memory stats */\n\t\tprintf(\", \\\"anonpg\\\": %llu, \"\n\t\t       \"\\\"slab\\\": %llu, \"\n\t\t       \"\\\"kstack\\\": %llu, \"\n\t\t       \"\\\"pgtbl\\\": %llu, \"\n\t\t       \"\\\"vmused\\\": %llu\",\n\t\t       smc->anonpgkb,\n\t\t       smc->slabkb,\n\t\t       smc->kstackkb,\n\t\t       smc->pgtblkb,\n\t\t       smc->vmusedkb);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization in JSON.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n ***************************************************************************\n */\nvoid json_print_swap_memory_stats(struct stats_memory *smc)\n{\n\tprintf(\"\\\"swpfree\\\": %llu, \"\n\t       \"\\\"swpused\\\": %llu, \"\n\t       \"\\\"swpused-percent\\\": %.2f, \"\n\t       \"\\\"swpcad\\\": %llu, \"\n\t       \"\\\"swpcad-percent\\\": %.2f\",\n\t       smc->frskb,\n\t       smc->tlskb - smc->frskb,\n\t       smc->tlskb ? SP_VALUE(smc->frskb, smc->tlskb, smc->tlskb)\n\t\t\t  : 0.0,\n\t       smc->caskb,\n\t       (smc->tlskb - smc->frskb) ? SP_VALUE(0, smc->caskb, smc->tlskb - smc->frskb)\n\t\t\t\t\t : 0.0);\n}\n\n/*\n ***************************************************************************\n * Display memory statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_memory_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\tint sep = FALSE;\n\n\txprintf0(tab, \"\\\"memory\\\": {\");\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\tsep = TRUE;\n\t\tjson_print_ram_memory_stats(smc, DISPLAY_MEM_ALL(a->opt_flags));\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\tif (sep) {\n\t\t\tprintf(\", \");\n\t\t}\n\t\tjson_print_swap_memory_stats(smc);\n\t}\n\n\tprintf(\"}\");\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_ktables_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\n\txprintf0(tab, \"\\\"kernel\\\": {\"\n\t\t \"\\\"dentunusd\\\": %llu, \"\n\t\t \"\\\"file-nr\\\": %llu, \"\n\t\t \"\\\"inode-nr\\\": %llu, \"\n\t\t \"\\\"pty-nr\\\": %llu}\",\n\t\t skc->dentry_stat,\n\t\t skc->file_used,\n\t\t skc->inode_used,\n\t\t skc->pty_nr);\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_queue_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\n\txprintf0(tab, \"\\\"queue\\\": {\"\n\t\t \"\\\"runq-sz\\\": %llu, \"\n\t\t \"\\\"plist-sz\\\": %llu, \"\n\t\t \"\\\"ldavg-1\\\": %.2f, \"\n\t\t \"\\\"ldavg-5\\\": %.2f, \"\n\t\t \"\\\"ldavg-15\\\": %.2f, \"\n\t\t \"\\\"blocked\\\": %llu}\",\n\t\t sqc->nr_running,\n\t\t sqc->nr_threads,\n\t\t (double) sqc->load_avg_1 / 100,\n\t\t (double) sqc->load_avg_5 / 100,\n\t\t (double) sqc->load_avg_15 / 100,\n\t\t sqc->procs_blocked);\n}\n\n/*\n ***************************************************************************\n * Display serial lines statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_serial_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_serial *ssc, *ssp;\n\tint sep = FALSE;\n\n\txprintf(tab++, \"\\\"serial\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\tssc = (struct stats_serial *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\t/* Look for corresponding serial line in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tssp = (struct stats_serial *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (ssc->line == ssp->line) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"line\\\": %d, \"\n\t\t\t \"\\\"rcvin\\\": %.2f, \"\n\t\t\t \"\\\"xmtin\\\": %.2f, \"\n\t\t\t \"\\\"framerr\\\": %.2f, \"\n\t\t\t \"\\\"prtyerr\\\": %.2f, \"\n\t\t\t \"\\\"brk\\\": %.2f, \"\n\t\t\t \"\\\"ovrun\\\": %.2f}\",\n\t\t\t ssc->line,\n\t\t\t S_VALUE(ssp->rx,      ssc->rx,      itv),\n\t\t\t S_VALUE(ssp->tx,      ssc->tx,      itv),\n\t\t\t S_VALUE(ssp->frame,   ssc->frame,   itv),\n\t\t\t S_VALUE(ssp->parity,  ssc->parity,  itv),\n\t\t\t S_VALUE(ssp->brk,     ssc->brk,     itv),\n\t\t\t S_VALUE(ssp->overrun, ssc->overrun, itv));\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display disks statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_disk_stats(struct activity *a, int curr, int tab,\n\t\t\t\t      unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_disk *sdc,\t*sdp, sdpzero;\n\tstruct ext_disk_stats xds;\n\tint sep = FALSE;\n\tchar *dev_name;\n\n\tmemset(&sdpzero, 0, STATS_DISK_SIZE);\n\n\txprintf(tab++, \"\\\"disk\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tj = check_disk_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsdp = &sdpzero;\n\t\t}\n\t\telse {\n\t\t\tsdp = (struct stats_disk *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\t/* Get device name */\n\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Compute extended statistics values */\n\t\tcompute_ext_disk_stats(sdc, sdp, itv, &xds);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"disk-device\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"tps\\\": %.2f, \"\n\t\t\t \"\\\"rd_sec\\\": %.2f, \"\n\t\t\t \"\\\"wr_sec\\\": %.2f, \"\n\t\t\t \"\\\"dc_sec\\\": %.2f, \"\n\t\t\t \"\\\"rkB\\\": %.2f, \"\n\t\t\t \"\\\"wkB\\\": %.2f, \"\n\t\t\t \"\\\"dkB\\\": %.2f, \"\n\t\t\t \"\\\"avgrq-sz\\\": %.2f, \"\n\t\t\t \"\\\"areq-sz\\\": %.2f, \"\n\t\t\t \"\\\"avgqu-sz\\\": %.2f, \"\n\t\t\t \"\\\"aqu-sz\\\": %.2f, \"\n\t\t\t \"\\\"await\\\": %.2f, \"\n\t\t\t \"\\\"util-percent\\\": %.2f}\",\n\t\t\t /* Confusion possible here between index and minor numbers */\n\t\t\t dev_name,\n\t\t\t S_VALUE(sdp->nr_ios, sdc->nr_ios, itv),\n\t\t\t S_VALUE(sdp->rd_sect, sdc->rd_sect, itv), /* Unit = sectors (for backward compatibility) */\n\t\t\t S_VALUE(sdp->wr_sect, sdc->wr_sect, itv),\n\t\t\t S_VALUE(sdp->dc_sect, sdc->dc_sect, itv),\n\t\t\t S_VALUE(sdp->rd_sect, sdc->rd_sect, itv) / 2,\n\t\t\t S_VALUE(sdp->wr_sect, sdc->wr_sect, itv) / 2,\n\t\t\t S_VALUE(sdp->dc_sect, sdc->dc_sect, itv) / 2,\n\t\t\t /* See iostat for explanations */\n\t\t\t xds.arqsz,\t/* Unit = sectors (for backward compatibility) */\n\t\t\t xds.arqsz / 2,\n\t\t\t S_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0,\t/* For backward compatibility */\n\t\t\t S_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0,\n\t\t\t xds.await,\n\t\t\t xds.util / 10.0);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_dev_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_dev *sndc, *sndp, sndzero;\n\tint sep = FALSE;\n\tdouble rxkb, txkb, ifutil;\n\n\tmemset(&sndzero, 0, STATS_NET_DEV_SIZE);\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"net-dev\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tj = check_net_dev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsndp = &sndzero;\n\t\t}\n\t\telse {\n\t\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\trxkb = S_VALUE(sndp->rx_bytes, sndc->rx_bytes, itv);\n\t\ttxkb = S_VALUE(sndp->tx_bytes, sndc->tx_bytes, itv);\n\t\tifutil = compute_ifutil(sndc, rxkb, txkb);\n\n\t\txprintf0(tab, \"{\\\"iface\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"rxpck\\\": %.2f, \"\n\t\t\t \"\\\"txpck\\\": %.2f, \"\n\t\t\t \"\\\"rxkB\\\": %.2f, \"\n\t\t\t \"\\\"txkB\\\": %.2f, \"\n\t\t\t \"\\\"rxcmp\\\": %.2f, \"\n\t\t\t \"\\\"txcmp\\\": %.2f, \"\n\t\t\t \"\\\"rxmcst\\\": %.2f, \"\n\t\t\t \"\\\"ifutil-percent\\\": %.2f}\",\n\t\t\t sndc->interface,\n\t\t\t S_VALUE(sndp->rx_packets,    sndc->rx_packets,    itv),\n\t\t\t S_VALUE(sndp->tx_packets,    sndc->tx_packets,    itv),\n\t\t\t rxkb / 1024,\n\t\t\t txkb / 1024,\n\t\t\t S_VALUE(sndp->rx_compressed, sndc->rx_compressed, itv),\n\t\t\t S_VALUE(sndp->tx_compressed, sndc->tx_compressed, itv),\n\t\t\t S_VALUE(sndp->multicast,     sndc->multicast,     itv),\n\t\t\t ifutil);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces errors statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_edev_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_edev *snedc, *snedp, snedzero;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tmemset(&snedzero, 0, STATS_NET_EDEV_SIZE);\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"net-edev\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tj = check_net_edev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsnedp = &snedzero;\n\t\t}\n\t\telse {\n\t\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"iface\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"rxerr\\\": %.2f, \"\n\t\t\t \"\\\"txerr\\\": %.2f, \"\n\t\t\t \"\\\"coll\\\": %.2f, \"\n\t\t\t \"\\\"rxdrop\\\": %.2f, \"\n\t\t\t \"\\\"txdrop\\\": %.2f, \"\n\t\t\t \"\\\"txcarr\\\": %.2f, \"\n\t\t\t \"\\\"rxfram\\\": %.2f, \"\n\t\t\t \"\\\"rxfifo\\\": %.2f, \"\n\t\t\t \"\\\"txfifo\\\": %.2f}\",\n\t\t\t snedc->interface,\n\t\t\t S_VALUE(snedp->rx_errors,         snedc->rx_errors,         itv),\n\t\t\t S_VALUE(snedp->tx_errors,         snedc->tx_errors,         itv),\n\t\t\t S_VALUE(snedp->collisions,        snedc->collisions,        itv),\n\t\t\t S_VALUE(snedp->rx_dropped,        snedc->rx_dropped,        itv),\n\t\t\t S_VALUE(snedp->tx_dropped,        snedc->tx_dropped,        itv),\n\t\t\t S_VALUE(snedp->tx_carrier_errors, snedc->tx_carrier_errors, itv),\n\t\t\t S_VALUE(snedp->rx_frame_errors,   snedc->rx_frame_errors,   itv),\n\t\t\t S_VALUE(snedp->rx_fifo_errors,    snedc->rx_fifo_errors,    itv),\n\t\t\t S_VALUE(snedp->tx_fifo_errors,    snedc->tx_fifo_errors,    itv));\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_nfs_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr],\n\t\t*snnp = (struct stats_net_nfs *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-nfs\\\": {\"\n\t\t \"\\\"call\\\": %.2f, \"\n\t\t \"\\\"retrans\\\": %.2f, \"\n\t\t \"\\\"read\\\": %.2f, \"\n\t\t \"\\\"write\\\": %.2f, \"\n\t\t \"\\\"access\\\": %.2f, \"\n\t\t \"\\\"getatt\\\": %.2f}\",\n\t\t S_VALUE(snnp->nfs_rpccnt,     snnc->nfs_rpccnt,     itv),\n\t\t S_VALUE(snnp->nfs_rpcretrans, snnc->nfs_rpcretrans, itv),\n\t\t S_VALUE(snnp->nfs_readcnt,    snnc->nfs_readcnt,    itv),\n\t\t S_VALUE(snnp->nfs_writecnt,   snnc->nfs_writecnt,   itv),\n\t\t S_VALUE(snnp->nfs_accesscnt,  snnc->nfs_accesscnt,  itv),\n\t\t S_VALUE(snnp->nfs_getattcnt,  snnc->nfs_getattcnt,  itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_nfsd_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr],\n\t\t*snndp = (struct stats_net_nfsd *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-nfsd\\\": {\"\n\t\t \"\\\"scall\\\": %.2f, \"\n\t\t \"\\\"badcall\\\": %.2f, \"\n\t\t \"\\\"packet\\\": %.2f, \"\n\t\t \"\\\"udp\\\": %.2f, \"\n\t\t \"\\\"tcp\\\": %.2f, \"\n\t\t \"\\\"hit\\\": %.2f, \"\n\t\t \"\\\"miss\\\": %.2f, \"\n\t\t \"\\\"sread\\\": %.2f, \"\n\t\t \"\\\"swrite\\\": %.2f, \"\n\t\t \"\\\"saccess\\\": %.2f, \"\n\t\t \"\\\"sgetatt\\\": %.2f}\",\n\t\t S_VALUE(snndp->nfsd_rpccnt,    snndc->nfsd_rpccnt,    itv),\n\t\t S_VALUE(snndp->nfsd_rpcbad,    snndc->nfsd_rpcbad,    itv),\n\t\t S_VALUE(snndp->nfsd_netcnt,    snndc->nfsd_netcnt,    itv),\n\t\t S_VALUE(snndp->nfsd_netudpcnt, snndc->nfsd_netudpcnt, itv),\n\t\t S_VALUE(snndp->nfsd_nettcpcnt, snndc->nfsd_nettcpcnt, itv),\n\t\t S_VALUE(snndp->nfsd_rchits,    snndc->nfsd_rchits,    itv),\n\t\t S_VALUE(snndp->nfsd_rcmisses,  snndc->nfsd_rcmisses,  itv),\n\t\t S_VALUE(snndp->nfsd_readcnt,   snndc->nfsd_readcnt,   itv),\n\t\t S_VALUE(snndp->nfsd_writecnt,  snndc->nfsd_writecnt,  itv),\n\t\t S_VALUE(snndp->nfsd_accesscnt, snndc->nfsd_accesscnt, itv),\n\t\t S_VALUE(snndp->nfsd_getattcnt, snndc->nfsd_getattcnt, itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network socket statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_sock_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-sock\\\": {\"\n\t\t \"\\\"totsck\\\": %u, \"\n\t\t \"\\\"tcpsck\\\": %u, \"\n\t\t \"\\\"udpsck\\\": %u, \"\n\t\t \"\\\"rawsck\\\": %u, \"\n\t\t \"\\\"ip-frag\\\": %u, \"\n\t\t \"\\\"tcp-tw\\\": %u}\",\n\t\t snsc->sock_inuse,\n\t\t snsc->tcp_inuse,\n\t\t snsc->udp_inuse,\n\t\t snsc->raw_inuse,\n\t\t snsc->frag_inuse,\n\t\t snsc->tcp_tw);\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IP network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_ip_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-ip\\\": {\"\n\t\t \"\\\"irec\\\": %.2f, \"\n\t\t \"\\\"fwddgm\\\": %.2f, \"\n\t\t \"\\\"idel\\\": %.2f, \"\n\t\t \"\\\"orq\\\": %.2f, \"\n\t\t \"\\\"asmrq\\\": %.2f, \"\n\t\t \"\\\"asmok\\\": %.2f, \"\n\t\t \"\\\"fragok\\\": %.2f, \"\n\t\t \"\\\"fragcrt\\\": %.2f}\",\n\t\t S_VALUE(snip->InReceives,    snic->InReceives,    itv),\n\t\t S_VALUE(snip->ForwDatagrams, snic->ForwDatagrams, itv),\n\t\t S_VALUE(snip->InDelivers,    snic->InDelivers,    itv),\n\t\t S_VALUE(snip->OutRequests,   snic->OutRequests,   itv),\n\t\t S_VALUE(snip->ReasmReqds,    snic->ReasmReqds,    itv),\n\t\t S_VALUE(snip->ReasmOKs,      snic->ReasmOKs,      itv),\n\t\t S_VALUE(snip->FragOKs,       snic->FragOKs,       itv),\n\t\t S_VALUE(snip->FragCreates,   snic->FragCreates,   itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IP network errors statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_eip_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-eip\\\": {\"\n\t\t \"\\\"ihdrerr\\\": %.2f, \"\n\t\t \"\\\"iadrerr\\\": %.2f, \"\n\t\t \"\\\"iukwnpr\\\": %.2f, \"\n\t\t \"\\\"idisc\\\": %.2f, \"\n\t\t \"\\\"odisc\\\": %.2f, \"\n\t\t \"\\\"onort\\\": %.2f, \"\n\t\t \"\\\"asmf\\\": %.2f, \"\n\t\t \"\\\"fragf\\\": %.2f}\",\n\t\t S_VALUE(sneip->InHdrErrors,     sneic->InHdrErrors,     itv),\n\t\t S_VALUE(sneip->InAddrErrors,    sneic->InAddrErrors,    itv),\n\t\t S_VALUE(sneip->InUnknownProtos, sneic->InUnknownProtos, itv),\n\t\t S_VALUE(sneip->InDiscards,      sneic->InDiscards,      itv),\n\t\t S_VALUE(sneip->OutDiscards,     sneic->OutDiscards,     itv),\n\t\t S_VALUE(sneip->OutNoRoutes,     sneic->OutNoRoutes,     itv),\n\t\t S_VALUE(sneip->ReasmFails,      sneic->ReasmFails,      itv),\n\t\t S_VALUE(sneip->FragFails,       sneic->FragFails,       itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMP network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_icmp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-icmp\\\": {\"\n\t\t \"\\\"imsg\\\": %.2f, \"\n\t\t \"\\\"omsg\\\": %.2f, \"\n\t\t \"\\\"iech\\\": %.2f, \"\n\t\t \"\\\"iechr\\\": %.2f, \"\n\t\t \"\\\"oech\\\": %.2f, \"\n\t\t \"\\\"oechr\\\": %.2f, \"\n\t\t \"\\\"itm\\\": %.2f, \"\n\t\t \"\\\"itmr\\\": %.2f, \"\n\t\t \"\\\"otm\\\": %.2f, \"\n\t\t \"\\\"otmr\\\": %.2f, \"\n\t\t \"\\\"iadrmk\\\": %.2f, \"\n\t\t \"\\\"iadrmkr\\\": %.2f, \"\n\t\t \"\\\"oadrmk\\\": %.2f, \"\n\t\t \"\\\"oadrmkr\\\": %.2f}\",\n\t\t S_VALUE(snip->InMsgs,           snic->InMsgs,           itv),\n\t\t S_VALUE(snip->OutMsgs,          snic->OutMsgs,          itv),\n\t\t S_VALUE(snip->InEchos,          snic->InEchos,          itv),\n\t\t S_VALUE(snip->InEchoReps,       snic->InEchoReps,       itv),\n\t\t S_VALUE(snip->OutEchos,         snic->OutEchos,         itv),\n\t\t S_VALUE(snip->OutEchoReps,      snic->OutEchoReps,      itv),\n\t\t S_VALUE(snip->InTimestamps,     snic->InTimestamps,     itv),\n\t\t S_VALUE(snip->InTimestampReps,  snic->InTimestampReps,  itv),\n\t\t S_VALUE(snip->OutTimestamps,    snic->OutTimestamps,    itv),\n\t\t S_VALUE(snip->OutTimestampReps, snic->OutTimestampReps, itv),\n\t\t S_VALUE(snip->InAddrMasks,      snic->InAddrMasks,      itv),\n\t\t S_VALUE(snip->InAddrMaskReps,   snic->InAddrMaskReps,   itv),\n\t\t S_VALUE(snip->OutAddrMasks,     snic->OutAddrMasks,     itv),\n\t\t S_VALUE(snip->OutAddrMaskReps,  snic->OutAddrMaskReps,  itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMP errors message statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_eicmp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-eicmp\\\": {\"\n\t\t \"\\\"ierr\\\": %.2f, \"\n\t\t \"\\\"oerr\\\": %.2f, \"\n\t\t \"\\\"idstunr\\\": %.2f, \"\n\t\t \"\\\"odstunr\\\": %.2f, \"\n\t\t \"\\\"itmex\\\": %.2f, \"\n\t\t \"\\\"otmex\\\": %.2f, \"\n\t\t \"\\\"iparmpb\\\": %.2f, \"\n\t\t \"\\\"oparmpb\\\": %.2f, \"\n\t\t \"\\\"isrcq\\\": %.2f, \"\n\t\t \"\\\"osrcq\\\": %.2f, \"\n\t\t \"\\\"iredir\\\": %.2f, \"\n\t\t \"\\\"oredir\\\": %.2f}\",\n\t\t S_VALUE(sneip->InErrors,        sneic->InErrors,        itv),\n\t\t S_VALUE(sneip->OutErrors,       sneic->OutErrors,       itv),\n\t\t S_VALUE(sneip->InDestUnreachs,  sneic->InDestUnreachs,  itv),\n\t\t S_VALUE(sneip->OutDestUnreachs, sneic->OutDestUnreachs, itv),\n\t\t S_VALUE(sneip->InTimeExcds,     sneic->InTimeExcds,     itv),\n\t\t S_VALUE(sneip->OutTimeExcds,    sneic->OutTimeExcds,    itv),\n\t\t S_VALUE(sneip->InParmProbs,     sneic->InParmProbs,     itv),\n\t\t S_VALUE(sneip->OutParmProbs,    sneic->OutParmProbs,    itv),\n\t\t S_VALUE(sneip->InSrcQuenchs,    sneic->InSrcQuenchs,    itv),\n\t\t S_VALUE(sneip->OutSrcQuenchs,   sneic->OutSrcQuenchs,   itv),\n\t\t S_VALUE(sneip->InRedirects,     sneic->InRedirects,     itv),\n\t\t S_VALUE(sneip->OutRedirects,    sneic->OutRedirects,    itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display TCP network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_tcp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr],\n\t\t*sntp = (struct stats_net_tcp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-tcp\\\": {\"\n\t\t \"\\\"active\\\": %.2f, \"\n\t\t \"\\\"passive\\\": %.2f, \"\n\t\t \"\\\"iseg\\\": %.2f, \"\n\t\t \"\\\"oseg\\\": %.2f}\",\n\t\t S_VALUE(sntp->ActiveOpens,  sntc->ActiveOpens,  itv),\n\t\t S_VALUE(sntp->PassiveOpens, sntc->PassiveOpens, itv),\n\t\t S_VALUE(sntp->InSegs,       sntc->InSegs,       itv),\n\t\t S_VALUE(sntp->OutSegs,      sntc->OutSegs,      itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display TCP network errors statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_etcp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr],\n\t\t*snetp = (struct stats_net_etcp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-etcp\\\": {\"\n\t\t \"\\\"atmptf\\\": %.2f, \"\n\t\t \"\\\"estres\\\": %.2f, \"\n\t\t \"\\\"retrseg\\\": %.2f, \"\n\t\t \"\\\"isegerr\\\": %.2f, \"\n\t\t \"\\\"orsts\\\": %.2f}\",\n\t\t S_VALUE(snetp->AttemptFails, snetc->AttemptFails,  itv),\n\t\t S_VALUE(snetp->EstabResets,  snetc->EstabResets,  itv),\n\t\t S_VALUE(snetp->RetransSegs,  snetc->RetransSegs,  itv),\n\t\t S_VALUE(snetp->InErrs,       snetc->InErrs,  itv),\n\t\t S_VALUE(snetp->OutRsts,      snetc->OutRsts,  itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display UDP network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_udp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-udp\\\": {\"\n\t\t \"\\\"idgm\\\": %.2f, \"\n\t\t \"\\\"odgm\\\": %.2f, \"\n\t\t \"\\\"noport\\\": %.2f, \"\n\t\t \"\\\"idgmerr\\\": %.2f}\",\n\t\t S_VALUE(snup->InDatagrams,  snuc->InDatagrams,  itv),\n\t\t S_VALUE(snup->OutDatagrams, snuc->OutDatagrams, itv),\n\t\t S_VALUE(snup->NoPorts,      snuc->NoPorts,      itv),\n\t\t S_VALUE(snup->InErrors,     snuc->InErrors,     itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network socket statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_sock6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-sock6\\\": {\"\n\t\t \"\\\"tcp6sck\\\": %u, \"\n\t\t \"\\\"udp6sck\\\": %u, \"\n\t\t \"\\\"raw6sck\\\": %u, \"\n\t\t \"\\\"ip6-frag\\\": %u}\",\n\t\t snsc->tcp6_inuse,\n\t\t snsc->udp6_inuse,\n\t\t snsc->raw6_inuse,\n\t\t snsc->frag6_inuse);\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_ip6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-ip6\\\": {\"\n\t\t \"\\\"irec6\\\": %.2f, \"\n\t\t \"\\\"fwddgm6\\\": %.2f, \"\n\t\t \"\\\"idel6\\\": %.2f, \"\n\t\t \"\\\"orq6\\\": %.2f, \"\n\t\t \"\\\"asmrq6\\\": %.2f, \"\n\t\t \"\\\"asmok6\\\": %.2f, \"\n\t\t \"\\\"imcpck6\\\": %.2f, \"\n\t\t \"\\\"omcpck6\\\": %.2f, \"\n\t\t \"\\\"fragok6\\\": %.2f, \"\n\t\t \"\\\"fragcr6\\\": %.2f}\",\n\t\t S_VALUE(snip->InReceives6,       snic->InReceives6,       itv),\n\t\t S_VALUE(snip->OutForwDatagrams6, snic->OutForwDatagrams6, itv),\n\t\t S_VALUE(snip->InDelivers6,       snic->InDelivers6,       itv),\n\t\t S_VALUE(snip->OutRequests6,      snic->OutRequests6,      itv),\n\t\t S_VALUE(snip->ReasmReqds6,       snic->ReasmReqds6,       itv),\n\t\t S_VALUE(snip->ReasmOKs6,         snic->ReasmOKs6,         itv),\n\t\t S_VALUE(snip->InMcastPkts6,      snic->InMcastPkts6,      itv),\n\t\t S_VALUE(snip->OutMcastPkts6,     snic->OutMcastPkts6,     itv),\n\t\t S_VALUE(snip->FragOKs6,          snic->FragOKs6,          itv),\n\t\t S_VALUE(snip->FragCreates6,      snic->FragCreates6,      itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network errors statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_eip6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-eip6\\\": {\"\n\t\t \"\\\"ihdrer6\\\": %.2f, \"\n\t\t \"\\\"iadrer6\\\": %.2f, \"\n\t\t \"\\\"iukwnp6\\\": %.2f, \"\n\t\t \"\\\"i2big6\\\": %.2f, \"\n\t\t \"\\\"idisc6\\\": %.2f, \"\n\t\t \"\\\"odisc6\\\": %.2f, \"\n\t\t \"\\\"inort6\\\": %.2f, \"\n\t\t \"\\\"onort6\\\": %.2f, \"\n\t\t \"\\\"asmf6\\\": %.2f, \"\n\t\t \"\\\"fragf6\\\": %.2f, \"\n\t\t \"\\\"itrpck6\\\": %.2f}\",\n\t\t S_VALUE(sneip->InHdrErrors6,     sneic->InHdrErrors6,     itv),\n\t\t S_VALUE(sneip->InAddrErrors6,    sneic->InAddrErrors6,    itv),\n\t\t S_VALUE(sneip->InUnknownProtos6, sneic->InUnknownProtos6, itv),\n\t\t S_VALUE(sneip->InTooBigErrors6,  sneic->InTooBigErrors6,  itv),\n\t\t S_VALUE(sneip->InDiscards6,      sneic->InDiscards6,      itv),\n\t\t S_VALUE(sneip->OutDiscards6,     sneic->OutDiscards6,     itv),\n\t\t S_VALUE(sneip->InNoRoutes6,      sneic->InNoRoutes6,      itv),\n\t\t S_VALUE(sneip->OutNoRoutes6,     sneic->OutNoRoutes6,     itv),\n\t\t S_VALUE(sneip->ReasmFails6,      sneic->ReasmFails6,      itv),\n\t\t S_VALUE(sneip->FragFails6,       sneic->FragFails6,       itv),\n\t\t S_VALUE(sneip->InTruncatedPkts6, sneic->InTruncatedPkts6, itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_icmp6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-icmp6\\\": {\"\n\t\t \"\\\"imsg6\\\": %.2f, \"\n\t\t \"\\\"omsg6\\\": %.2f, \"\n\t\t \"\\\"iech6\\\": %.2f, \"\n\t\t \"\\\"iechr6\\\": %.2f, \"\n\t\t \"\\\"oechr6\\\": %.2f, \"\n\t\t \"\\\"igmbq6\\\": %.2f, \"\n\t\t \"\\\"igmbr6\\\": %.2f, \"\n\t\t \"\\\"ogmbr6\\\": %.2f, \"\n\t\t \"\\\"igmbrd6\\\": %.2f, \"\n\t\t \"\\\"ogmbrd6\\\": %.2f, \"\n\t\t \"\\\"irtsol6\\\": %.2f, \"\n\t\t \"\\\"ortsol6\\\": %.2f, \"\n\t\t \"\\\"irtad6\\\": %.2f, \"\n\t\t \"\\\"inbsol6\\\": %.2f, \"\n\t\t \"\\\"onbsol6\\\": %.2f, \"\n\t\t \"\\\"inbad6\\\": %.2f, \"\n\t\t \"\\\"onbad6\\\": %.2f}\",\n\t\t S_VALUE(snip->InMsgs6,                    snic->InMsgs6,                    itv),\n\t\t S_VALUE(snip->OutMsgs6,                   snic->OutMsgs6,                   itv),\n\t\t S_VALUE(snip->InEchos6,                   snic->InEchos6,                   itv),\n\t\t S_VALUE(snip->InEchoReplies6,             snic->InEchoReplies6,             itv),\n\t\t S_VALUE(snip->OutEchoReplies6,            snic->OutEchoReplies6,            itv),\n\t\t S_VALUE(snip->InGroupMembQueries6,        snic->InGroupMembQueries6,        itv),\n\t\t S_VALUE(snip->InGroupMembResponses6,      snic->InGroupMembResponses6,      itv),\n\t\t S_VALUE(snip->OutGroupMembResponses6,     snic->OutGroupMembResponses6,     itv),\n\t\t S_VALUE(snip->InGroupMembReductions6,     snic->InGroupMembReductions6,     itv),\n\t\t S_VALUE(snip->OutGroupMembReductions6,    snic->OutGroupMembReductions6,    itv),\n\t\t S_VALUE(snip->InRouterSolicits6,          snic->InRouterSolicits6,          itv),\n\t\t S_VALUE(snip->OutRouterSolicits6,         snic->OutRouterSolicits6,         itv),\n\t\t S_VALUE(snip->InRouterAdvertisements6,    snic->InRouterAdvertisements6,    itv),\n\t\t S_VALUE(snip->InNeighborSolicits6,        snic->InNeighborSolicits6,        itv),\n\t\t S_VALUE(snip->OutNeighborSolicits6,       snic->OutNeighborSolicits6,       itv),\n\t\t S_VALUE(snip->InNeighborAdvertisements6,  snic->InNeighborAdvertisements6,  itv),\n\t\t S_VALUE(snip->OutNeighborAdvertisements6, snic->OutNeighborAdvertisements6, itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 error messages statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_eicmp6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-eicmp6\\\": {\"\n\t\t \"\\\"ierr6\\\": %.2f, \"\n\t\t \"\\\"idtunr6\\\": %.2f, \"\n\t\t \"\\\"odtunr6\\\": %.2f, \"\n\t\t \"\\\"itmex6\\\": %.2f, \"\n\t\t \"\\\"otmex6\\\": %.2f, \"\n\t\t \"\\\"iprmpb6\\\": %.2f, \"\n\t\t \"\\\"oprmpb6\\\": %.2f, \"\n\t\t \"\\\"iredir6\\\": %.2f, \"\n\t\t \"\\\"oredir6\\\": %.2f, \"\n\t\t \"\\\"ipck2b6\\\": %.2f, \"\n\t\t \"\\\"opck2b6\\\": %.2f}\",\n\t\t S_VALUE(sneip->InErrors6,        sneic->InErrors6,        itv),\n\t\t S_VALUE(sneip->InDestUnreachs6,  sneic->InDestUnreachs6,  itv),\n\t\t S_VALUE(sneip->OutDestUnreachs6, sneic->OutDestUnreachs6, itv),\n\t\t S_VALUE(sneip->InTimeExcds6,     sneic->InTimeExcds6,     itv),\n\t\t S_VALUE(sneip->OutTimeExcds6,    sneic->OutTimeExcds6,    itv),\n\t\t S_VALUE(sneip->InParmProblems6,  sneic->InParmProblems6,  itv),\n\t\t S_VALUE(sneip->OutParmProblems6, sneic->OutParmProblems6, itv),\n\t\t S_VALUE(sneip->InRedirects6,     sneic->InRedirects6,     itv),\n\t\t S_VALUE(sneip->OutRedirects6,    sneic->OutRedirects6,    itv),\n\t\t S_VALUE(sneip->InPktTooBigs6,    sneic->InPktTooBigs6,    itv),\n\t\t S_VALUE(sneip->OutPktTooBigs6,   sneic->OutPktTooBigs6,   itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display UDPv6 network statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_net_udp6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"net-udp6\\\": {\"\n\t\t \"\\\"idgm6\\\": %.2f, \"\n\t\t \"\\\"odgm6\\\": %.2f, \"\n\t\t \"\\\"noport6\\\": %.2f, \"\n\t\t \"\\\"idgmer6\\\": %.2f}\",\n\t\t S_VALUE(snup->InDatagrams6,  snuc->InDatagrams6,  itv),\n\t\t S_VALUE(snup->OutDatagrams6, snuc->OutDatagrams6, itv),\n\t\t S_VALUE(snup->NoPorts6,      snuc->NoPorts6,      itv),\n\t\t S_VALUE(snup->InErrors6,     snuc->InErrors6,     itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_cpufreq_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t     unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_cpufreq *spc;\n\tint sep = FALSE;\n\tchar cpuno[16];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"cpu-frequency\\\": [\");\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\t\t}\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"number\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"frequency\\\": %.2f}\",\n\t\t\t cpuno,\n\t\t\t ((double) spc->cpufreq) / 100);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display fan statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_fan_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_fan *spc;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"fan-speed\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"number\\\": %d, \"\n\t\t\t \"\\\"rpm\\\": %llu, \"\n\t\t\t \"\\\"drpm\\\": %llu, \"\n\t\t\t \"\\\"device\\\": \\\"%s\\\"}\",\n\t\t\t i + 1,\n\t\t\t (unsigned long long) spc->rpm,\n\t\t\t (unsigned long long) (spc->rpm - spc->rpm_min),\n\t\t\t spc->device);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_temp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_temp *spc;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"temperature\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"number\\\": %d, \"\n\t\t\t \"\\\"degC\\\": %.2f, \"\n\t\t\t \"\\\"percent-temp\\\": %.2f, \"\n\t\t\t \"\\\"device\\\": \\\"%s\\\"}\",\n\t\t\t i + 1,\n\t\t\t spc->temp,\n\t\t\t (spc->temp_max - spc->temp_min) ?\n\t\t\t (spc->temp - spc->temp_min) / (spc->temp_max - spc->temp_min) * 100 :\n\t\t\t 0.0,\n\t\t\t spc->device);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_in_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_in *spc;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"voltage-input\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"number\\\": %d, \"\n\t\t\t \"\\\"inV\\\": %.2f, \"\n\t\t\t \"\\\"percent-in\\\": %.2f, \"\n\t\t\t \"\\\"device\\\": \\\"%s\\\"}\",\n\t\t\t i,\n\t\t\t spc->in,\n\t\t\t (spc->in_max - spc->in_min) ?\n\t\t\t (spc->in - spc->in_min) / (spc->in_max - spc->in_min) * 100 :\n\t\t\t 0.0,\n\t\t\t spc->device);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_huge_stats(struct activity *a, int curr, int tab,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\n\txprintf0(tab, \"\\\"hugepages\\\": {\"\n\t\t \"\\\"hugfree\\\": %llu, \"\n\t\t \"\\\"hugused\\\": %llu, \"\n\t\t \"\\\"hugused-percent\\\": %.2f, \"\n\t\t \"\\\"hugrsvd\\\": %llu, \"\n\t\t \"\\\"hugsurp\\\": %llu}\",\n\t\t smc->frhkb,\n\t\t smc->tlhkb - smc->frhkb,\n\t\t smc->tlhkb ?\n\t\t SP_VALUE(smc->frhkb, smc->tlhkb, smc->tlhkb) : 0.0,\n\t\t smc->rsvdhkb,\n\t\t smc->surphkb);\n}\n\n/*\n ***************************************************************************\n * Display weighted CPU frequency statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_wghfreq_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t     unsigned long long itv)\n{\n\tint i, k;\n\tstruct stats_pwr_wghfreq *spc, *spp, *spc_k, *spp_k;\n\tunsigned long long tis, tisfreq;\n\tint sep = FALSE;\n\tchar cpuno[16];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"cpu-weighted-frequency\\\": [\");\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_wghfreq *) ((char *) a->buf[curr]  + i * a->msize * a->nr2);\n\t\tspp = (struct stats_pwr_wghfreq *) ((char *) a->buf[!curr] + i * a->msize * a->nr2);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\ttisfreq = 0;\n\t\ttis = 0;\n\n\t\tfor (k = 0; k < a->nr2; k++) {\n\n\t\t\tspc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * a->msize);\n\t\t\tif (!spc_k->freq)\n\t\t\t\tbreak;\n\t\t\tspp_k = (struct stats_pwr_wghfreq *) ((char *) spp + k * a->msize);\n\n\t\t\ttisfreq += (spc_k->freq / 1000) *\n\t\t\t           (spc_k->time_in_state - spp_k->time_in_state);\n\t\t\ttis     += (spc_k->time_in_state - spp_k->time_in_state);\n\t\t}\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\t\t}\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"number\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"weighted-frequency\\\": %.2f}\",\n\t\t\t cpuno,\n\t\t\t tis ? ((double) tisfreq) / tis : 0.0);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display USB devices statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_usb_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_usb *suc;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"usb-devices\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsuc = (struct stats_pwr_usb *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"bus_number\\\": %d, \"\n\t\t\t \"\\\"idvendor\\\": \\\"%x\\\", \"\n\t\t\t \"\\\"idprod\\\": \\\"%x\\\", \"\n\t\t\t \"\\\"maxpower\\\": %u, \"\n\t\t\t \"\\\"manufact\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"product\\\": \\\"%s\\\"}\",\n\t\t\t suc->bus_nr,\n\t\t\t suc->vendor_id,\n\t\t\t suc->product_id,\n\t\t\t suc->bmaxpower << 1,\n\t\t\t suc->manufacturer,\n\t\t\t suc->product);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display filesystems statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_filesystem_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t    unsigned long long itv)\n{\n\tint i;\n\tstruct stats_filesystem *sfc;\n\tint sep = FALSE;\n\tchar *dev_name;\n\n\txprintf(tab++, \"\\\"filesystems\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"%s\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"MBfsfree\\\": %.0f, \"\n\t\t\t \"\\\"MBfsused\\\": %.0f, \"\n\t\t\t \"\\\"%%fsused\\\": %.2f, \"\n\t\t\t \"\\\"%%ufsused\\\": %.2f, \"\n\t\t\t \"\\\"Ifree\\\": %llu, \"\n\t\t\t \"\\\"Iused\\\": %llu, \"\n\t\t\t \"\\\"%%Iused\\\": %.2f}\",\n\t\t\t DISPLAY_MOUNT(a->opt_flags) ? \"mountpoint\" : \"filesystem\",\n\t\t\t dev_name,\n\t\t\t (double) sfc->f_bfree / 1024 / 1024,\n\t\t\t (double) (sfc->f_blocks - sfc->f_bfree) / 1024 / 1024,\n\t\t\t sfc->f_blocks ? SP_VALUE(sfc->f_bfree, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t     : 0.0,\n\t\t\t sfc->f_blocks ? SP_VALUE(sfc->f_bavail, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t     : 0.0,\n\t\t\t sfc->f_ffree,\n\t\t\t sfc->f_files - sfc->f_ffree,\n\t\t\t sfc->f_files ? SP_VALUE(sfc->f_ffree, sfc->f_files, sfc->f_files)\n\t\t\t\t    : 0.0);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_fchost_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_fchost *sfcc, *sfcp, sfczero;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tmemset(&sfczero, 0, sizeof(struct stats_fchost));\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"fchosts\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\t/* Look for corresponding structure in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (!strcmp(sfcc->fchost_name, sfcp->fchost_name)) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tif (!found) {\n\t\t\t/* This is a newly registered host */\n\t\t\tsfcp = &sfczero;\n\t\t}\n\n\t\tif (sep)\n\t\t\tprintf(\",\\n\");\n\n\t\tsep = TRUE;\n\n\t\txprintf0(tab, \"{\\\"fchost\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"fch_rxf\\\": %.2f, \"\n\t\t\t \"\\\"fch_txf\\\": %.2f, \"\n\t\t\t \"\\\"fch_rxw\\\": %.2f, \"\n\t\t\t \"\\\"fch_txw\\\": %.2f}\",\n\t\t\t sfcc->fchost_name,\n\t\t\t S_VALUE(sfcp->f_rxframes, sfcc->f_rxframes, itv),\n\t\t\t S_VALUE(sfcp->f_txframes, sfcc->f_txframes, itv),\n\t\t\t S_VALUE(sfcp->f_rxwords,  sfcc->f_rxwords,  itv),\n\t\t\t S_VALUE(sfcp->f_txwords,  sfcc->f_txwords,  itv));\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\n\ttab --;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_softnet_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i;\n\tstruct stats_softnet *ssnc, *ssnp;\n\tint sep = FALSE;\n\tchar cpuno[16];\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_network(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"softnet\\\": [\");\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Compute statistics for CPU \"all\" */\n\tget_global_soft_statistics(a, !curr, curr, flags, offline_cpu_bitmap);\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * Should current CPU (including CPU \"all\") be displayed?\n\t\t * Note: a->nr is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_pwr_cpufreq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * ssnc = (struct stats_softnet *) a->buf[...] + i;\n                 */\n                ssnc = (struct stats_softnet *) ((char *) a->buf[curr]  + i * a->msize);\n                ssnp = (struct stats_softnet *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\t\t}\n\n\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"total\\\": %.2f, \"\n\t\t\t \"\\\"dropd\\\": %.2f, \"\n\t\t\t \"\\\"squeezd\\\": %.2f, \"\n\t\t\t \"\\\"rx_rps\\\": %.2f, \"\n\t\t\t \"\\\"flw_lim\\\": %.2f, \"\n\t\t\t \"\\\"blg_len\\\": %u}\",\n\t\t\t cpuno,\n\t\t\t S_VALUE(ssnp->processed,    ssnc->processed,    itv),\n\t\t\t S_VALUE(ssnp->dropped,      ssnc->dropped,      itv),\n\t\t\t S_VALUE(ssnp->time_squeeze, ssnc->time_squeeze, itv),\n\t\t\t S_VALUE(ssnp->received_rps, ssnc->received_rps, itv),\n\t\t\t S_VALUE(ssnp->flow_limit,   ssnc->flow_limit,   itv),\n\t\t\t ssnc->backlog_len);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\n\ttab --;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_network(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_psicpu_stats(struct activity *a, int curr, int tab,\n\t\t\t\t        unsigned long long itv)\n{\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr],\n\t\t*psip = (struct stats_psi_cpu *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options))\n\t\tgoto close_json_markup;\n\n\tjson_markup_psi(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"psi-cpu\\\": {\"\n\t\t \"\\\"some_avg10\\\": %.2f, \"\n\t\t \"\\\"some_avg60\\\": %.2f, \"\n\t\t \"\\\"some_avg300\\\": %.2f, \"\n\t\t \"\\\"some_avg\\\": %.2f}\",\n\t\t (double) psic->some_acpu_10  / 100,\n\t\t (double) psic->some_acpu_60  / 100,\n\t\t (double) psic->some_acpu_300 / 100,\n\t\t ((double) psic->some_cpu_total - psip->some_cpu_total) / (100 * itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_psi(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_psiio_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr],\n\t\t*psip = (struct stats_psi_io *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options))\n\t\tgoto close_json_markup;\n\n\tjson_markup_psi(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"psi-io\\\": {\"\n\t\t \"\\\"some_avg10\\\": %.2f, \"\n\t\t \"\\\"some_avg60\\\": %.2f, \"\n\t\t \"\\\"some_avg300\\\": %.2f, \"\n\t\t \"\\\"some_avg\\\": %.2f, \"\n\t\t \"\\\"full_avg10\\\": %.2f, \"\n\t\t \"\\\"full_avg60\\\": %.2f, \"\n\t\t \"\\\"full_avg300\\\": %.2f, \"\n\t\t \"\\\"full_avg\\\": %.2f}\",\n\t\t (double) psic->some_aio_10  / 100,\n\t\t (double) psic->some_aio_60  / 100,\n\t\t (double) psic->some_aio_300 / 100,\n\t\t ((double) psic->some_io_total - psip->some_io_total) / (100 * itv),\n\t\t (double) psic->full_aio_10  / 100,\n\t\t (double) psic->full_aio_60  / 100,\n\t\t (double) psic->full_aio_300 / 100,\n\t\t ((double) psic->full_io_total - psip->full_io_total) / (100 * itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_psi(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_psimem_stats(struct activity *a, int curr, int tab,\n\t\t\t\t        unsigned long long itv)\n{\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr],\n\t\t*psip = (struct stats_psi_mem *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options))\n\t\tgoto close_json_markup;\n\n\tjson_markup_psi(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf0(tab, \"\\\"psi-mem\\\": {\"\n\t\t \"\\\"some_avg10\\\": %.2f, \"\n\t\t \"\\\"some_avg60\\\": %.2f, \"\n\t\t \"\\\"some_avg300\\\": %.2f, \"\n\t\t \"\\\"some_avg\\\": %.2f, \"\n\t\t \"\\\"full_avg10\\\": %.2f, \"\n\t\t \"\\\"full_avg60\\\": %.2f, \"\n\t\t \"\\\"full_avg300\\\": %.2f, \"\n\t\t \"\\\"full_avg\\\": %.2f}\",\n\t\t (double) psic->some_amem_10  / 100,\n\t\t (double) psic->some_amem_60  / 100,\n\t\t (double) psic->some_amem_300 / 100,\n\t\t ((double) psic->some_mem_total - psip->some_mem_total) / (100 * itv),\n\t\t (double) psic->full_amem_10  / 100,\n\t\t (double) psic->full_amem_60  / 100,\n\t\t (double) psic->full_amem_300 / 100,\n\t\t ((double) psic->full_mem_total - psip->full_mem_total) / (100 * itv));\n\ttab--;\n\nclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_psi(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display battery statistics in JSON.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t json_print_pwr_bat_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_bat *spbc, *spbp;\n\tint sep = FALSE;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_json_markup;\n\n\tjson_markup_power_management(tab, OPEN_JSON_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"\\\"battery\\\": [\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\t\tspbp = (struct stats_pwr_bat *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tsep = TRUE;\n\n\t\t/* Battery status code should not be greater than or equal to BAT_STS_NR */\n\t\tif (spbc->status >= BAT_STS_NR) {\n\t\t\tspbc->status = 0;\n\t\t}\n\n\t\txprintf0(tab, \"{\\\"number\\\": %d, \"\n\t\t\t      \"\\\"percent-capacity\\\": %u, \"\n\t\t\t      \"\\\"variation\\\": %.2f, \"\n\t\t\t      \"\\\"status\\\": \\\"%s\\\"}\",\n\t\tspbc->bat_id,\n\t\t(unsigned int) spbc->capacity,\n\t\t(double) (spbc->capacity - spbp->capacity) * 6000 / itv,\n\t\tbat_status[(unsigned int) spbc->status]);\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\ttab--;\n\n\tclose_json_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\tjson_markup_power_management(tab, CLOSE_JSON_MARKUP);\n\t}\n}\n"
        },
        {
          "name": "json_stats.h",
          "type": "blob",
          "size": 4.412109375,
          "content": "/*\n * json_stats.h: Include file used to display system statistics in JSON format.\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _JSON_STATS_H\n#define _JSON_STATS_H\n\n#include \"common.h\"\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display system statistics in JSON.\n ***************************************************************************\n */\n\n/* Functions used to display statistics in JSON */\n__print_funct_t json_print_cpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pcsw_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_irq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_swap_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_paging_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_io_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_memory_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_ktables_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_queue_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_serial_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_disk_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_dev_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_edev_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_nfs_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_nfsd_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_sock_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_ip_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_eip_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_icmp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_eicmp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_tcp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_etcp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_udp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_sock6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_ip6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_eip6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_icmp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_eicmp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_net_udp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_cpufreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_fan_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_temp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_in_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_huge_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_wghfreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_usb_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_filesystem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_fchost_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_softnet_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_psicpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_psiio_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_psimem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t json_print_pwr_bat_stats\n\t(struct activity *, int, int, unsigned long long);\n\n#endif /* _JSON_STATS_H */\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "mpstat.c",
          "type": "blob",
          "size": 71.24609375,
          "content": "/*\n * mpstat: per-processor statistics\n * (C) 2000-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n * Copyright (C) 2022 Oracle and/or its affiliates.\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/utsname.h>\n\n#include \"version.h\"\n#include \"mpstat.h\"\n#include \"count.h\"\n\n#include <locale.h>\t/* For setlocale() */\n#ifdef USE_NLS\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \"  __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern int __env;\n#endif\n\nunsigned long long uptime_cs[3] = {0, 0, 0};\n\n/* NOTE: Use array of _char_ for bitmaps to avoid endianness problems...*/\nunsigned char *cpu_bitmap = NULL;\t/* Bit 0: Global; Bit 1: 1st proc; etc. */\nunsigned char *node_bitmap = NULL;\t/* Bit 0: Global; Bit 1: 1st NUMA node; etc. */\n\n/* Structures used to save CPU and NUMA nodes CPU stats */\nstruct stats_cpu *st_cpu[3] = {NULL, NULL, NULL};\nstruct stats_cpu *st_node[3] = {NULL, NULL, NULL};\n\n/*\n * Structure used to save total number of interrupts received\n * among all CPU and for each CPU.\n */\nstruct stats_global_irq *st_irq[3] = {NULL, NULL, NULL};\n\n/*\n * Structures used to save, for each interrupt, the number\n * received by each CPU.\n */\nstruct stats_irqcpu *st_irqcpu[3] = {NULL, NULL, NULL};\nstruct stats_irqcpu *st_softirqcpu[3] = {NULL, NULL, NULL};\n\n/*\n * Number of CPU per node, e.g.:\n * cpu_per_node[0]: total nr of CPU (this is node \"all\")\n * cpu_per_node[1]: nr of CPU for node 0\n * etc.\n */\nint *cpu_per_node = NULL;\n\n/*\n * Node number the CPU belongs to, e.g.:\n * cpu2node[0]: node nr for CPU 0\n */\nint *cpu2node = NULL;\n\n/* CPU topology */\nstruct cpu_topology *st_cpu_topology = NULL;\n\nstruct tm mp_tstamp[3];\n\n/* Activity flag */\nuint64_t actflags = 0;\n\nuint64_t flags = 0;\nuint64_t xflags = 0;\t/* Extended flag for options used by multiple commands */\n\n/* Interval and count parameters */\nlong interval = -1, count = 0;\n/* Number of decimal places */\nint dplaces_nr = -1;\n\n/*\n * Nb of processors on the machine.\n * A value of 2 means there are 2 processors (0 and 1).\n */\nint cpu_nr = 0;\n\n/*\n * Highest NUMA node number found on the machine.\n * A value of 0 means node 0 (one node).\n * A value of -1 means no nodes found.\n * We have: node_nr < cpu_nr (see get_node_placement() function).\n */\nint node_nr = -1;\n\n/* Nb of interrupts per processor */\nint irqcpu_nr = 0;\n/* Nb of soft interrupts per processor */\nint softirqcpu_nr = 0;\n\nstruct sigaction alrm_act, int_act;\nint sigint_caught = 0;\n\n/*\n ***************************************************************************\n * Print usage and exit\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ]\\n\"),\n\t\tprogname);\n\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -A ] [ -H ] [ -n ] [ -T ] [ -u ] [ -V ]\\n\"\n\t\t\t  \"[ -I { SUM | CPU | SCPU | ALL } ] [ -N { <node_list> | ALL } ]\\n\"\n\t\t\t  \"[ --dec={ 0 | 1 | 2 } ] [ -o JSON ] [ -P { <cpu_list> | ALL } ]\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * SIGALRM signal handler. No need to reset the handler here.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid alarm_handler(int sig)\n{\n\talarm(interval);\n}\n\n/*\n ***************************************************************************\n * SIGINT signal handler.\n *\n * IN:\n * @sig\tSignal number.\n **************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tsigint_caught = 1;\n}\n\n/*\n ***************************************************************************\n * Allocate stats structures and cpu bitmap. Also do it for NUMA nodes\n * (although the machine may not be a NUMA one). Assume that the number of\n * nodes is lower or equal than that of CPU.\n *\n * IN:\n * @nr_cpus\tNumber of CPUs. This is the real number of available CPUs + 1\n * \t\tbecause we also have to allocate a structure for CPU 'all'.\n * @pos\t\tIndicate which structures should be initialized. When @pos is\n *\t\tnon zero, it means that only the additional, newly allocated\n *\t\tstructures should be initialized.\n ***************************************************************************\n */\nvoid salloc_mp_struct(int nr_cpus, int pos)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tSREALLOC(st_cpu[i], struct stats_cpu, STATS_CPU_SIZE * nr_cpus);\n\t\tSREALLOC(st_node[i], struct stats_cpu, STATS_CPU_SIZE * nr_cpus);\n\t\tSREALLOC(st_irq[i], struct stats_global_irq, STATS_GLOBAL_IRQ_SIZE * nr_cpus);\n\t\tSREALLOC(st_irqcpu[i], struct stats_irqcpu,\n\t\t\t STATS_IRQCPU_SIZE * nr_cpus * irqcpu_nr);\n\t\tSREALLOC(st_softirqcpu[i], struct stats_irqcpu,\n\t\t\t STATS_IRQCPU_SIZE * nr_cpus * softirqcpu_nr);\n\t}\n\n\tSREALLOC(cpu_bitmap, unsigned char, (nr_cpus >> 3) + 1);\n\tSREALLOC(node_bitmap, unsigned char, (nr_cpus >> 3) + 1);\n\n\tSREALLOC(cpu_per_node, int, sizeof(int) * nr_cpus);\n\tSREALLOC(cpu2node, int, sizeof(int) * nr_cpus);\n\tSREALLOC(st_cpu_topology, struct cpu_topology, sizeof(struct cpu_topology) * nr_cpus);\n\n\tif (pos) {\n\t\t/* Init already done in SREALLOC macro if @pos == 0 */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tmemset(st_cpu[i] + pos, 0, STATS_CPU_SIZE * (nr_cpus - pos));\n\t\t\tmemset(st_node[i] + pos, 0, STATS_CPU_SIZE * (nr_cpus - pos));\n\t\t\tmemset(st_irq[i] + pos, 0, STATS_GLOBAL_IRQ_SIZE * (nr_cpus - pos));\n\t\t\tmemset(st_irqcpu[i] + pos, 0, STATS_IRQCPU_SIZE * (nr_cpus - pos) * irqcpu_nr);\n\t\t\tmemset(st_softirqcpu[i] + pos, 0, STATS_IRQCPU_SIZE * (nr_cpus - pos) * softirqcpu_nr);\n\t\t}\n\t}\n\telse {\n\t\tmemset(cpu_bitmap, 0, (nr_cpus >> 3) + 1);\n\t\tmemset(node_bitmap, 0, (nr_cpus >> 3) + 1);\n\t}\n}\n\n/*\n ***************************************************************************\n * Free structures and bitmap.\n ***************************************************************************\n */\nvoid sfree_mp_struct(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfree(st_cpu[i]);\n\t\tfree(st_node[i]);\n\t\tfree(st_irq[i]);\n\t\tfree(st_irqcpu[i]);\n\t\tfree(st_softirqcpu[i]);\n\t}\n\n\tfree(cpu_bitmap);\n\tfree(node_bitmap);\n\tfree(cpu_per_node);\n\tfree(cpu2node);\n}\n\n/*\n ***************************************************************************\n * Set interrupt values for current sample to those of previous sample.\n *\n * IN:\n * @st_ic\tArray for per-CPU interrupts statistics.\n * @c\t\tFist CPU to process.\n * @last\tLast CPU to process.\n * @ic_nr\tNumber of interrupts (hard or soft) per CPU.\n * @curr\tPosition in array where current statistics will be saved.\n **************************************************************************\n */\nvoid fwd_irq_values(struct stats_irqcpu *st_ic[], unsigned int c,\n\t\t    unsigned int last, int ic_nr, int curr)\n{\n\tstruct stats_global_irq *st_irq_i, *st_irq_j;\n\tstruct stats_irqcpu *p, *q;\n\tint j;\n\n\twhile (c < last) {\n\n\t\tst_irq_i = st_irq[curr] + c + 1;\n\t\tst_irq_j = st_irq[!curr] + c + 1;\n\t\tst_irq_i->irq_nr = st_irq_j->irq_nr;\n\n\t\tfor (j = 0; j < ic_nr; j++) {\n\t\t\tp = st_ic[curr] + c * ic_nr + j;\n\t\t\tq = st_ic[!curr] + c * ic_nr + j;\n\t\t\tp->interrupt = q->interrupt;\n\t\t}\n\t\tc++;\n\t}\n}\n\n/*\n ***************************************************************************\n * Get node placement (which node each CPU belongs to, and total number of\n * CPU that each node has).\n *\n * IN:\n * @nr_cpus\t\tNumber of CPU on this machine.\n *\n * OUT:\n * @cpu_per_node\tNumber of CPU per node.\n * @cpu2node\t\tThe node the CPU belongs to.\n *\n * RETURNS:\n * Highest node number found (e.g., 0 means node 0).\n * A value of -1 means no nodes have been found.\n ***************************************************************************\n */\nint get_node_placement(int nr_cpus, int cpu_per_node[], int cpu2node[])\n\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\tchar line[MAX_PF_NAME];\n\tint cpu, node, hi_node_nr = -1;\n\n\t/* Init number of CPU per node */\n\tmemset(cpu_per_node, 0, sizeof(int) * (nr_cpus + 1));\n\t/* CPU belongs to no node by default */\n\tmemset(cpu2node, -1, sizeof(int) * nr_cpus);\n\n\t/* This is node \"all\" */\n\tcpu_per_node[0] = nr_cpus;\n\n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tsnprintf(line, sizeof(line), \"%s/cpu%d\", SYSFS_DEVCPU, cpu);\n\t\tline[sizeof(line) - 1] = '\\0';\n\n\t\t/* Open relevant /sys directory */\n\t\tif ((dir = opendir(line)) == NULL)\n\t\t\treturn -1;\n\n\t\t/* Get current file entry */\n\t\twhile ((drd = readdir(dir)) != NULL) {\n\n\t\t\tif (!strncmp(drd->d_name, \"node\", 4) && isdigit(drd->d_name[4])) {\n\t\t\t\tnode = atoi(drd->d_name + 4);\n\t\t\t\tif ((node >= nr_cpus) || (node < 0)) {\n\t\t\t\t\t/* Assume we cannot have more nodes than CPU */\n\t\t\t\t\tclosedir(dir);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcpu_per_node[node + 1]++;\n\t\t\t\tcpu2node[cpu] = node;\n\t\t\t\tif (node > hi_node_nr) {\n\t\t\t\t\thi_node_nr = node;\n\t\t\t\t}\n\t\t\t\t/* Node placement found for current CPU: Go to next CPU directory */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Close directory */\n\t\tclosedir(dir);\n\t}\n\n\treturn hi_node_nr;\n}\n\n/*\n ***************************************************************************\n * Read system logical topology: Socket number for each logical core is read\n * from the /sys/devices/system/cpu/cpu{N}/topology/physical_package_id file,\n * and the logical core id number is the first number read from the\n * /sys/devices/system/cpu/cpu{N}/topology/thread_siblings_list file.\n * Don't use /sys/devices/system/cpu/cpu{N}/topology/core_id as this is the\n * physical core id (seems to be different from the number displayed by lscpu).\n *\n * IN:\n * @nr_cpus\tNumber of CPU on this machine.\n * @cpu_topo\tStructures where socket and core id numbers will be saved.\n *\n * OUT:\n * @cpu_topo\tStructures where socket and core id numbers have been saved.\n ***************************************************************************\n */\nvoid read_topology(int nr_cpus, struct cpu_topology *cpu_topo)\n{\n\tstruct cpu_topology *cpu_topo_i;\n\tFILE *fp;\n\tchar filename[MAX_PF_NAME];\n\tint cpu, rc;\n\n\t/* Init system topology */\n\tmemset(st_cpu_topology, 0, sizeof(struct cpu_topology) * nr_cpus);\n\n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\n\t\tcpu_topo_i = cpu_topo + cpu;\n\n\t\t/* Read current CPU's socket number */\n\t\tsnprintf(filename, sizeof(filename), \"%s/cpu%d/%s\", SYSFS_DEVCPU, cpu, PHYS_PACK_ID);\n\t\tfilename[sizeof(filename) - 1] = '\\0';\n\n\t\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\t\trc = fscanf(fp, \"%d\", &cpu_topo_i->phys_package_id);\n\t\t\tfclose(fp);\n\n\t\t\tif (rc < 1) {\n\t\t\t\tcpu_topo_i->phys_package_id = -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Read current CPU's logical core id number */\n\t\tsnprintf(filename, sizeof(filename), \"%s/cpu%d/%s\", SYSFS_DEVCPU, cpu, THREAD_SBL_LST);\n\t\tfilename[sizeof(filename) - 1] = '\\0';\n\n\t\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\t\trc = fscanf(fp, \"%d\", &cpu_topo_i->logical_core_id);\n\t\t\tfclose(fp);\n\n\t\t\tif (rc < 1) {\n\t\t\t\tcpu_topo_i->logical_core_id = -1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Compute node statistics: Split CPU statistics among nodes.\n *\n * IN:\n * @src\t\tStructure containing CPU stats to add.\n *\n * OUT:\n * @dest\tStructure containing global CPU stats.\n ***************************************************************************\n */\nvoid add_cpu_stats(struct stats_cpu *dest, struct stats_cpu *src)\n{\n\tdest->cpu_user       += src->cpu_user;\n\tdest->cpu_nice       += src->cpu_nice;\n\tdest->cpu_sys        += src->cpu_sys;\n\tdest->cpu_idle       += src->cpu_idle;\n\tdest->cpu_iowait     += src->cpu_iowait;\n\tdest->cpu_hardirq    += src->cpu_hardirq;\n\tdest->cpu_softirq    += src->cpu_softirq;\n\tdest->cpu_steal      += src->cpu_steal;\n\tdest->cpu_guest      += src->cpu_guest;\n\tdest->cpu_guest_nice += src->cpu_guest_nice;\n}\n\n/*\n ***************************************************************************\n * Compute node statistics: Split CPU statistics among nodes.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n *\n * OUT:\n * @st_node\tArray where CPU stats for each node have been saved.\n ***************************************************************************\n */\nvoid set_node_cpu_stats(int prev, int curr)\n{\n\tint cpu;\n\tunsigned long long tot_jiffies_p;\n\tstruct stats_cpu *scp, *scc, *snp, *snc;\n\tstruct stats_cpu *scc_all = st_cpu[curr];\n\tstruct stats_cpu *scp_all = st_cpu[prev];\n\tstruct stats_cpu *snc_all = st_node[curr];\n\tstruct stats_cpu *snp_all = st_node[prev];\n\n\t/* Reset structures */\n\tmemset(st_node[prev], 0, STATS_CPU_SIZE * (cpu_nr + 1));\n\tmemset(st_node[curr], 0, STATS_CPU_SIZE * (cpu_nr + 1));\n\n\t/* Node 'all' is the same as CPU 'all' */\n\t*snp_all = *scp_all;\n\t*snc_all = *scc_all;\n\n\t/* Individual nodes */\n\tfor (cpu = 0; cpu < cpu_nr; cpu++) {\n\t\tscc = st_cpu[curr] + cpu + 1;\n\t\tscp = st_cpu[prev] + cpu + 1;\n\t\tsnp = st_node[prev] + cpu2node[cpu] + 1;\n\t\tsnc = st_node[curr] + cpu2node[cpu] + 1;\n\n\n\t\ttot_jiffies_p = scp->cpu_user + scp->cpu_nice +\n\t\t\t\tscp->cpu_sys + scp->cpu_idle +\n\t\t\t\tscp->cpu_iowait + scp->cpu_hardirq +\n\t\t\t\tscp->cpu_steal + scp->cpu_softirq;\n\t\tif ((tot_jiffies_p == 0) && (interval != 0))\n\t\t\t/*\n\t\t\t * CPU has just come back online with no ref from\n\t\t\t * previous iteration: Skip it.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tadd_cpu_stats(snp, scp);\n\t\tadd_cpu_stats(snc, scc);\n\t}\n}\n\n/*\n ***************************************************************************\n * Compute global CPU statistics as the sum of individual CPU ones, and\n * calculate interval for global CPU.\n * Also identify offline CPU.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n *\n * OUT:\n * @offline_cpu_bitmap\n *\t\tCPU bitmap with offline CPU.\n *\n * RETURNS:\n * Interval for global CPU.\n ***************************************************************************\n */\nunsigned long long get_global_cpu_mpstats(int prev, int curr,\n\t\t\t\t\t  unsigned char offline_cpu_bitmap[])\n{\n\tint i;\n\tunsigned long long tot_jiffies_c, tot_jiffies_p;\n\tunsigned long long deltot_jiffies = 0;\n\tstruct stats_cpu *scc, *scp;\n\tstruct stats_cpu *scc_all = st_cpu[curr];\n\tstruct stats_cpu *scp_all = st_cpu[prev];\n\n\t/*\n\t * For UP machines we keep the values read from global CPU line in /proc/stat.\n\t * Also look for offline CPU: They won't be displayed, and some of their values may\n\t * have to be modified.\n\t */\n\tif (cpu_nr > 1) {\n\t\tmemset(scc_all, 0, sizeof(struct stats_cpu));\n\t\tmemset(scp_all, 0, sizeof(struct stats_cpu));\n\t}\n\telse {\n\t\t/* This is a UP machine */\n\t\treturn get_per_cpu_interval(st_cpu[curr], st_cpu[prev]);\n\t}\n\n\tfor (i = 1; i <= cpu_nr; i++) {\n\n\t\tscc = st_cpu[curr] + i;\n\t\tscp = st_cpu[prev] + i;\n\n\t\t/*\n\t\t * Compute the total number of jiffies spent by current processor.\n\t\t * NB: Don't add cpu_guest/cpu_guest_nice because cpu_user/cpu_nice\n\t\t * already include them.\n\t\t */\n\t\ttot_jiffies_c = scc->cpu_user + scc->cpu_nice +\n\t\t\t\tscc->cpu_sys + scc->cpu_idle +\n\t\t\t\tscc->cpu_iowait + scc->cpu_hardirq +\n\t\t\t\tscc->cpu_steal + scc->cpu_softirq;\n\t\ttot_jiffies_p = scp->cpu_user + scp->cpu_nice +\n\t\t\t\tscp->cpu_sys + scp->cpu_idle +\n\t\t\t\tscp->cpu_iowait + scp->cpu_hardirq +\n\t\t\t\tscp->cpu_steal + scp->cpu_softirq;\n\n\t\t/*\n\t\t * If the CPU is offline then it is omitted from /proc/stat:\n\t\t * All the fields couldn't have been read and the sum of them is zero.\n\t\t */\n\t\tif (tot_jiffies_c == 0) {\n\t\t\t/*\n\t\t\t * CPU is currently offline.\n\t\t\t * Set current struct fields (which have been set to zero)\n\t\t\t * to values from previous iteration. Hence their values won't\n\t\t\t * jump from zero when the CPU comes back online.\n\t\t\t * Note that this workaround no longer fully applies with recent kernels,\n\t\t\t * as I have noticed that when a CPU comes back online, some fields\n\t\t\t * restart from their previous value (e.g. user, nice, system)\n\t\t\t * whereas others restart from zero (idle, iowait)! To deal with this,\n\t\t\t * the get_per_cpu_interval() function will set these previous values\n\t\t\t * to zero if necessary.\n\t\t\t */\n\t\t\t*scc = *scp;\n\n\t\t\t/*\n\t\t\t * Mark CPU as offline to not display it\n\t\t\t * (and thus it will not be confused with a tickless CPU).\n\t\t\t */\n\t\t\tMARK_CPU_OFFLINE(offline_cpu_bitmap, i);\n\t\t}\n\n\t\tif ((tot_jiffies_p == 0) && (interval != 0)) {\n\t\t\t/*\n\t\t\t * CPU has just come back online.\n\t\t\t * Unfortunately, no reference values are available\n\t\t\t * from a previous iteration, probably because it was\n\t\t\t * already offline when the first sample has been taken.\n\t\t\t * So don't display that CPU to prevent \"jump-from-zero\"\n\t\t\t * output syndrome, and don't take it into account for CPU \"all\".\n\t\t\t * NB: Test for interval != 0 to make sure we don't want stats\n\t\t\t * since boot time.\n\t\t\t */\n\t\t\tMARK_CPU_OFFLINE(offline_cpu_bitmap, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get interval for current CPU and add it to global CPU.\n\t\t * Note: Previous idle and iowait values (saved in scp) may be modified here.\n\t\t */\n\t\tdeltot_jiffies += get_per_cpu_interval(scc, scp);\n\n\t\tadd_cpu_stats(scc_all, scc);\n\t\tadd_cpu_stats(scp_all, scp);\n\t}\n\n\treturn deltot_jiffies;\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in plain format.\n *\n * IN:\n * @dis\t\tTRUE if a header line must be printed.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_plain_cpu_stats(int dis, unsigned long long deltot_jiffies, int prev, int curr,\n\t\t\t   char *prev_string, char *curr_string,\n\t\t\t   const unsigned char offline_cpu_bitmap[])\n{\n\tint i;\n\tstruct stats_cpu *scc, *scp;\n\tstruct cpu_topology *cpu_topo_i;\n\n\tif (dis) {\n\t\tprintf(\"\\n%-11s  CPU\", prev_string);\n\t\tif (DISPLAY_TOPOLOGY(flags)) {\n\t\t\tprintf(\" CORE SOCK NODE\");\n\t\t}\n\t\tprintf(\"    %%usr   %%nice    %%sys %%iowait    %%irq   \"\n\t\t       \"%%soft  %%steal  %%guest  %%gnice   %%idle\\n\");\n\t}\n\n\t/*\n\t * Now display CPU statistics (including CPU \"all\"),\n\t * except for offline CPU or CPU that the user doesn't want to see.\n\t */\n\tfor (i = 0; i <= cpu_nr; i++) {\n\n\t\t/* Check if we want stats about this proc */\n\t\tif (!(*(cpu_bitmap + (i >> 3)) & (1 << (i & 0x07))) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\tcontinue;\n\n\t\tscc = st_cpu[curr] + i;\n\t\tscp = st_cpu[prev] + i;\n\n\t\tprintf(\"%-11s\", curr_string);\n\n\t\tif (i == 0) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tcprintf_in(IS_STR, \" %s\", \" all\", 0);\n\n\t\t\tif (DISPLAY_TOPOLOGY(flags)) {\n\t\t\t\tprintf(\"               \");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcprintf_in(IS_INT, \" %4d\", \"\", i - 1);\n\n\t\t\tif (DISPLAY_TOPOLOGY(flags)) {\n\t\t\t\tcpu_topo_i = st_cpu_topology + i - 1;\n\t\t\t\tcprintf_in(IS_INT, \" %4d\", \"\", cpu_topo_i->logical_core_id);\n\t\t\t\tcprintf_in(IS_INT, \" %4d\", \"\", cpu_topo_i->phys_package_id);\n\t\t\t\tcprintf_in(IS_INT, \" %4d\", \"\", cpu2node[i - 1]);\n\t\t\t}\n\n\t\t\t/* Recalculate itv for current proc */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/*\n\t\t\t\t * If the CPU is tickless then there is no change in CPU values\n\t\t\t\t * but the sum of values is not zero.\n\t\t\t\t */\n\t\t\t\tcprintf_xpc(NO_UNIT, FALSE, 10, 7, 2,\n\t\t\t\t\t   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tcprintf_xpc(NO_UNIT, XHIGH, 9, 7, 2,\n\t\t\t   (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t   0.0 :\n\t\t\t   ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t       scc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t   (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t   0.0 :\n\t\t\t   ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t       scc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_sys,\n\t\t\t\t       scc->cpu_sys, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_iowait,\n\t\t\t\t       scc->cpu_iowait, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_hardirq,\n\t\t\t\t       scc->cpu_hardirq, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_softirq,\n\t\t\t\t       scc->cpu_softirq, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_steal,\n\t\t\t\t       scc->cpu_steal, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_guest,\n\t\t\t\t       scc->cpu_guest, deltot_jiffies),\n\t\t\t   ll_sp_value(scp->cpu_guest_nice,\n\t\t\t\t       scc->cpu_guest_nice, deltot_jiffies));\n\t\tcprintf_xpc(NO_UNIT, XLOW, 1, 7, 2,\n\t\t\t    (scc->cpu_idle < scp->cpu_idle) ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_idle,\n\t\t\t\t\tscc->cpu_idle, deltot_jiffies));\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_json_cpu_stats(int tab, unsigned long long deltot_jiffies, int prev, int curr,\n\t\t\t  const unsigned char offline_cpu_bitmap[])\n{\n\tint i, next = FALSE;\n\tchar cpu_name[16], topology[1024] = \"\";\n\tstruct stats_cpu *scc, *scp;\n\tstruct cpu_topology *cpu_topo_i;\n\n\txprintf(tab++, \"\\\"cpu-load\\\": [\");\n\n\t/*\n\t * Now display CPU statistics (including CPU \"all\"),\n\t * except for offline CPU or CPU that the user doesn't want to see.\n\t */\n\tfor (i = 0; i <= cpu_nr; i++) {\n\n\t\t/* Check if we want stats about this proc */\n\t\tif (!(*(cpu_bitmap + (i >> 3)) & (1 << (i & 0x07))) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\tcontinue;\n\n\t\tscc = st_cpu[curr] + i;\n\t\tscp = st_cpu[prev] + i;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tif (i == 0) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpu_name, K_LOWERALL);\n\n\t\t\tif (DISPLAY_TOPOLOGY(flags)) {\n\t\t\t\tsnprintf(topology, sizeof(topology),\n\t\t\t\t\t \", \\\"core\\\": \\\"\\\", \\\"socket\\\": \\\"\\\", \\\"node\\\": \\\"\\\"\");\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tsnprintf(cpu_name, sizeof(cpu_name), \"%d\", i - 1);\n\t\t\tcpu_name[sizeof(cpu_name) - 1] = '\\0';\n\n\t\t\tif (DISPLAY_TOPOLOGY(flags)) {\n\t\t\t\tcpu_topo_i = st_cpu_topology + i - 1;\n\t\t\t\tsnprintf(topology, sizeof(topology),\n\t\t\t\t\t \", \\\"core\\\": \\\"%d\\\", \\\"socket\\\": \\\"%d\\\", \\\"node\\\": \\\"%d\\\"\",\n\t\t\t\t\t cpu_topo_i->logical_core_id, cpu_topo_i->phys_package_id, cpu2node[i - 1]);\n\t\t\t}\n\n\t\t\t/* Recalculate itv for current proc */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/*\n\t\t\t\t * If the CPU is tickless then there is no change in CPU values\n\t\t\t\t * but the sum of values is not zero.\n\t\t\t\t */\n\t\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%d\\\"%s, \\\"usr\\\": 0.00, \\\"nice\\\": 0.00, \"\n\t\t\t\t\t \"\\\"sys\\\": 0.00, \\\"iowait\\\": 0.00, \\\"irq\\\": 0.00, \"\n\t\t\t\t\t \"\\\"soft\\\": 0.00, \\\"steal\\\": 0.00, \\\"guest\\\": 0.00, \"\n\t\t\t\t\t \"\\\"gnice\\\": 0.00, \\\"idle\\\": 100.00}\", i - 1, topology);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%s\\\"%s, \\\"usr\\\": %.2f, \\\"nice\\\": %.2f, \\\"sys\\\": %.2f, \"\n\t\t\t \"\\\"iowait\\\": %.2f, \\\"irq\\\": %.2f, \\\"soft\\\": %.2f, \\\"steal\\\": %.2f, \"\n\t\t\t \"\\\"guest\\\": %.2f, \\\"gnice\\\": %.2f, \\\"idle\\\": %.2f}\",\n\t\t\t cpu_name, topology,\n\t\t\t (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t 0.0 :\n\t\t\t ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t     scc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t 0.0 :\n\t\t\t ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t     scc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_sys,\n\t\t\t\t     scc->cpu_sys, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_iowait,\n\t\t\t\t     scc->cpu_iowait, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_hardirq,\n\t\t\t\t     scc->cpu_hardirq, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_softirq,\n\t\t\t\t     scc->cpu_softirq, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_steal,\n\t\t\t\t     scc->cpu_steal, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_guest,\n\t\t\t\t     scc->cpu_guest, deltot_jiffies),\n\t\t\t ll_sp_value(scp->cpu_guest_nice,\n\t\t\t\t     scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t (scc->cpu_idle < scp->cpu_idle) ?\n\t\t\t 0.0 :\n\t\t\t ll_sp_value(scp->cpu_idle,\n\t\t\t\t     scc->cpu_idle, deltot_jiffies));\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in plain or JSON format.\n *\n * IN:\n * @dis\t\tTRUE if a header line must be printed.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @next\tTRUE is a previous activity has been displayed (JSON format\n * \t\tonly).\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_cpu_stats(int dis, unsigned long long deltot_jiffies, int prev, int curr,\n\t\t     char *prev_string, char *curr_string, int tab, int *next,\n\t\t     unsigned char offline_cpu_bitmap[])\n{\n\tif (!deltot_jiffies) {\n\t\t/* CPU \"all\" cannot be tickless */\n\t\tdeltot_jiffies = 1;\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tif (*next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\t*next = TRUE;\n\t\twrite_json_cpu_stats(tab, deltot_jiffies, prev, curr,\n\t\t\t\t     offline_cpu_bitmap);\n\t}\n\telse {\n\t\twrite_plain_cpu_stats(dis, deltot_jiffies, prev, curr,\n\t\t\t\t      prev_string, curr_string, offline_cpu_bitmap);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics for NUMA nodes in plain format.\n *\n * IN:\n * @dis\t\tTRUE if a header line must be printed.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n ***************************************************************************\n */\nvoid write_plain_node_stats(int dis, unsigned long long deltot_jiffies,\n\t\t\t    int prev, int curr, char *prev_string, char *curr_string)\n{\n\tstruct stats_cpu *snc, *snp, *scc, *scp;\n\tint cpu, node;\n\n\tif (dis) {\n\t\tprintf(\"\\n%-11s NODE    %%usr   %%nice    %%sys %%iowait    %%irq   \"\n\t\t       \"%%soft  %%steal  %%guest  %%gnice   %%idle\\n\",\n\t\t       prev_string);\n\t}\n\n\tfor (node = 0; node <= node_nr + 1; node++) {\n\n\t\tsnc = st_node[curr] + node;\n\t\tsnp = st_node[prev] + node;\n\n\t\t/* Check if we want stats about this node */\n\t\tif (!(*(node_bitmap + (node >> 3)) & (1 << (node & 0x07))))\n\t\t\tcontinue;\n\n\t\tif (!cpu_per_node[node])\n\t\t\t/* No CPU in this node */\n\t\t\tcontinue;\n\n\t\tprintf(\"%-11s\", curr_string);\n\t\tif (node == 0) {\n\t\t\t/* This is node \"all\", i.e. CPU \"all\" */\n\t\t\tcprintf_in(IS_STR, \" %s\", \" all\", 0);\n\t\t}\n\t\telse {\n\t\t\tcprintf_in(IS_INT, \" %4d\", \"\", node - 1);\n\n\t\t\t/* Recalculate interval for current node */\n\t\t\tdeltot_jiffies = 0;\n\t\t\tfor (cpu = 1; cpu <= cpu_nr; cpu++) {\n\t\t\t\tscc = st_cpu[curr] + cpu;\n\t\t\t\tscp = st_cpu[prev] + cpu;\n\n\t\t\t\tif ((scp->cpu_user + scp->cpu_nice + scp->cpu_sys +\n\t\t\t\t     scp->cpu_idle + scp->cpu_iowait + scp->cpu_hardirq +\n\t\t\t\t     scp->cpu_steal + scp->cpu_softirq == 0) && (interval != 0))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (cpu2node[cpu - 1] == node - 1) {\n\t\t\t\t\tdeltot_jiffies += get_per_cpu_interval(scc, scp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* All CPU in node are tickless and/or offline */\n\t\t\t\tcprintf_xpc(NO_UNIT, FALSE, 10, 7, 2,\n\t\t\t\t\t   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tcprintf_xpc(NO_UNIT, XHIGH, 9, 7, 2,\n\t\t\t   (snc->cpu_user - snc->cpu_guest) < (snp->cpu_user - snp->cpu_guest) ?\n\t\t\t   0.0 :\n\t\t\t   ll_sp_value(snp->cpu_user - snp->cpu_guest,\n\t\t\t\t       snc->cpu_user - snc->cpu_guest, deltot_jiffies),\n\t\t\t   (snc->cpu_nice - snc->cpu_guest_nice) < (snp->cpu_nice - snp->cpu_guest_nice) ?\n\t\t\t   0.0 :\n\t\t\t   ll_sp_value(snp->cpu_nice - snp->cpu_guest_nice,\n\t\t\t\t       snc->cpu_nice - snc->cpu_guest_nice, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_sys,\n\t\t\t\t       snc->cpu_sys, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_iowait,\n\t\t\t\t       snc->cpu_iowait, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_hardirq,\n\t\t\t\t       snc->cpu_hardirq, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_softirq,\n\t\t\t\t       snc->cpu_softirq, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_steal,\n\t\t\t\t       snc->cpu_steal, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_guest,\n\t\t\t\t       snc->cpu_guest, deltot_jiffies),\n\t\t\t   ll_sp_value(snp->cpu_guest_nice,\n\t\t\t\t       snc->cpu_guest_nice, deltot_jiffies));\n\t\tcprintf_xpc(NO_UNIT, XLOW, 1, 7, 2,\n\t\t\t    (snc->cpu_idle < snp->cpu_idle) ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(snp->cpu_idle,\n\t\t\t\t\tsnc->cpu_idle, deltot_jiffies));\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics for NUMA nodes in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n ***************************************************************************\n */\nvoid write_json_node_stats(int tab, unsigned long long deltot_jiffies,\n\t\t\t   int prev, int curr)\n{\n\tstruct stats_cpu *snc, *snp, *scc, *scp;\n\tint cpu, node, next = FALSE;\n\tchar node_name[16];\n\n\txprintf(tab++, \"\\\"node-load\\\": [\");\n\n\tfor (node = 0; node <= node_nr + 1; node++) {\n\n\t\tsnc = st_node[curr] + node;\n\t\tsnp = st_node[prev] + node;\n\n\t\t/* Check if we want stats about this node */\n\t\tif (!(*(node_bitmap + (node >> 3)) & (1 << (node & 0x07))))\n\t\t\tcontinue;\n\n\t\tif (!cpu_per_node[node])\n\t\t\t/* No CPU in this node */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tif (node == 0) {\n\t\t\t/* This is node \"all\", i.e. CPU \"all\" */\n\t\t\tstrcpy(node_name, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsnprintf(node_name, sizeof(node_name), \"%d\", node - 1);\n\t\t\tnode_name[sizeof(node_name) -1] = '\\0';\n\n\t\t\t/* Recalculate interval for current node */\n\t\t\tdeltot_jiffies = 0;\n\t\t\tfor (cpu = 1; cpu <= cpu_nr; cpu++) {\n\t\t\t\tscc = st_cpu[curr] + cpu;\n\t\t\t\tscp = st_cpu[prev] + cpu;\n\n\t\t\t\tif ((scp->cpu_user + scp->cpu_nice + scp->cpu_sys +\n\t\t\t\t     scp->cpu_idle + scp->cpu_iowait + scp->cpu_hardirq +\n\t\t\t\t     scp->cpu_steal + scp->cpu_softirq == 0) && (interval != 0))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (cpu2node[cpu - 1] == node - 1) {\n\t\t\t\t\tdeltot_jiffies += get_per_cpu_interval(scc, scp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* All CPU in node are tickless and/or offline */\n\t\t\t\txprintf0(tab, \"{\\\"node\\\": \\\"%d\\\", \\\"usr\\\": 0.00, \\\"nice\\\": 0.00, \\\"sys\\\": 0.00, \"\n\t\t\t      \"\\\"iowait\\\": 0.00, \\\"irq\\\": 0.00, \\\"soft\\\": 0.00, \\\"steal\\\": 0.00, \"\n\t\t\t      \"\\\"guest\\\": 0.00, \\\"gnice\\\": 0.00, \\\"idle\\\": 100.00}\", node - 1);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\txprintf0(tab, \"{\\\"node\\\": \\\"%s\\\", \\\"usr\\\": %.2f, \\\"nice\\\": %.2f, \\\"sys\\\": %.2f, \"\n\t\t\t      \"\\\"iowait\\\": %.2f, \\\"irq\\\": %.2f, \\\"soft\\\": %.2f, \\\"steal\\\": %.2f, \"\n\t\t\t      \"\\\"guest\\\": %.2f, \\\"gnice\\\": %.2f, \\\"idle\\\": %.2f}\", node_name,\n\t\t\t (snc->cpu_user - snc->cpu_guest) < (snp->cpu_user - snp->cpu_guest) ?\n\t\t\t 0.0 :\n\t\t\t ll_sp_value(snp->cpu_user - snp->cpu_guest,\n\t\t\t\t     snc->cpu_user - snc->cpu_guest, deltot_jiffies),\n\t\t\t (snc->cpu_nice - snc->cpu_guest_nice) < (snp->cpu_nice - snp->cpu_guest_nice) ?\n\t\t\t 0.0 :\n\t\t\t ll_sp_value(snp->cpu_nice - snp->cpu_guest_nice,\n\t\t\t\t     snc->cpu_nice - snc->cpu_guest_nice, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_sys,\n\t\t\t\t     snc->cpu_sys, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_iowait,\n\t\t\t\t     snc->cpu_iowait, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_hardirq,\n\t\t\t\t     snc->cpu_hardirq, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_softirq,\n\t\t\t\t     snc->cpu_softirq, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_steal,\n\t\t\t\t     snc->cpu_steal, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_guest,\n\t\t\t\t     snc->cpu_guest, deltot_jiffies),\n\t\t\t ll_sp_value(snp->cpu_guest_nice,\n\t\t\t\t     snc->cpu_guest_nice, deltot_jiffies),\n\t\t\t (snc->cpu_idle < snp->cpu_idle) ?\n\t\t\t 0.0 :\n\t\t\t ll_sp_value(snp->cpu_idle,\n\t\t\t\t     snc->cpu_idle, deltot_jiffies));\n\t}\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display nodes statistics in plain or JSON format.\n *\n * IN:\n * @dis\t\tTRUE if a header line must be printed.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @next\tTRUE is a previous activity has been displayed (JSON format\n * \t\tonly).\n ***************************************************************************\n */\nvoid write_node_stats(int dis, unsigned long long deltot_jiffies, int prev, int curr,\n\t\t      char *prev_string, char *curr_string, int tab, int *next)\n{\n\tif (!deltot_jiffies) {\n\t\t/* CPU \"all\" cannot be tickless */\n\t\tdeltot_jiffies = 1;\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tif (*next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\t*next = TRUE;\n\t\twrite_json_node_stats(tab, deltot_jiffies, prev, curr);\n\t}\n\telse {\n\t\twrite_plain_node_stats(dis, deltot_jiffies, prev, curr,\n\t\t\t\t       prev_string, curr_string);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display total number of interrupts per CPU in plain format.\n *\n * IN:\n * @dis\t\tTRUE if a header line must be printed.\n * @itv\t\tInterval value.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_plain_isumcpu_stats(int dis, unsigned long long itv, int prev, int curr,\n\t\t\t       char *prev_string, char *curr_string,\n\t\t\t       const unsigned char offline_cpu_bitmap[])\n{\n\tstruct stats_cpu *scc, *scp;\n\tstruct stats_global_irq *sic, *sip;\n\tunsigned long long pc_itv;\n\tint cpu;\n\n\tif (dis) {\n\t\tprintf(\"\\n%-11s  CPU    intr/s\\n\", prev_string);\n\t\t}\n\n\tif (*cpu_bitmap & 1) {\n\t\tprintf(\"%-11s\", curr_string);\n\t\tcprintf_in(IS_STR, \" %s\", \" all\", 0);\n\t\t/* Print total number of interrupts among all cpu */\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t  S_VALUE(st_irq[prev]->irq_nr, st_irq[curr]->irq_nr, itv));\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (cpu = 1; cpu <= cpu_nr; cpu++) {\n\n\t\tsic = st_irq[curr] + cpu;\n\t\tsip = st_irq[prev] + cpu;\n\n\t\tscc = st_cpu[curr] + cpu;\n\t\tscp = st_cpu[prev] + cpu;\n\n\t\t/* Check if we want stats about this CPU */\n\t\tif (!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, cpu))\n\t\t\tcontinue;\n\n\t\tprintf(\"%-11s\", curr_string);\n\t\tcprintf_in(IS_INT, \" %4d\", \"\", cpu - 1);\n\n\t\t/* Recalculate itv for current proc */\n\t\tpc_itv = get_per_cpu_interval(scc, scp);\n\n\t\tif (!pc_itv) {\n\t\t\t/* This is a tickless CPU: Value displayed is 0.00 */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, 0.0);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\t/* Display total number of interrupts for current CPU */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  S_VALUE(sip->irq_nr, sic->irq_nr, itv));\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display total number of interrupts per CPU in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @itv\t\tInterval value.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_json_isumcpu_stats(int tab, unsigned long long itv, int prev, int curr,\n\t\t\t      const unsigned char offline_cpu_bitmap[])\n{\n\tstruct stats_cpu *scc, *scp;\n\tstruct stats_global_irq *sic, *sip;\n\tunsigned long long pc_itv;\n\tint cpu, next = FALSE;\n\n\txprintf(tab++, \"\\\"sum-interrupts\\\": [\");\n\n\tif (*cpu_bitmap & 1) {\n\n\t\tnext = TRUE;\n\t\t/* Print total number of interrupts among all cpu */\n\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"all\\\", \\\"intr\\\": %.2f}\",\n\t\t\t S_VALUE(st_irq[prev]->irq_nr, st_irq[curr]->irq_nr, itv));\n\t}\n\n\tfor (cpu = 1; cpu <= cpu_nr; cpu++) {\n\n\t\tsic = st_irq[curr] + cpu;\n\t\tsip = st_irq[prev] + cpu;\n\n\t\tscc = st_cpu[curr] + cpu;\n\t\tscp = st_cpu[prev] + cpu;\n\n\t\t/* Check if we want stats about this CPU */\n\t\tif (!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, cpu))\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\t/* Recalculate itv for current proc */\n\t\tpc_itv = get_per_cpu_interval(scc, scp);\n\n\t\tif (!pc_itv) {\n\t\t\t/* This is a tickless CPU: Value displayed is 0.00 */\n\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%d\\\", \\\"intr\\\": 0.00}\",\n\t\t\t\t cpu - 1);\n\t\t}\n\t\telse {\n\t\t\t/* Display total number of interrupts for current CPU */\n\t\t\txprintf0(tab, \"{\\\"cpu\\\": \\\"%d\\\", \\\"intr\\\": %.2f}\",\n\t\t\t\t cpu - 1,\n\t\t\t\t S_VALUE(sip->irq_nr, sic->irq_nr, itv));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display total number of interrupts per CPU in plain or JSON format.\n *\n * IN:\n * @dis\t\tTRUE if a header line must be printed.\n * @itv\t\tInterval value.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @next\tTRUE is a previous activity has been displayed (JSON format\n * \t\tonly).\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_isumcpu_stats(int dis, unsigned long long itv, int prev, int curr,\n\t\t\t char *prev_string, char *curr_string, int tab, int *next,\n\t\t\t unsigned char offline_cpu_bitmap[])\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tif (*next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\t*next = TRUE;\n\t\twrite_json_isumcpu_stats(tab, itv, prev, curr, offline_cpu_bitmap);\n\t}\n\telse {\n\t\twrite_plain_isumcpu_stats(dis, itv, prev, curr, prev_string, curr_string,\n\t\t\t\t\t  offline_cpu_bitmap);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics for each CPU in plain format.\n *\n * IN:\n * @st_ic\tArray for per-CPU statistics.\n * @ic_nr\tNumber of interrupts (hard or soft) per CPU.\n * @dis\t\tTRUE if a header line must be printed.\n * @itv\t\tInterval value.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_plain_irqcpu_stats(struct stats_irqcpu *st_ic[], int ic_nr, int dis,\n\t\t\t      unsigned long long itv, int prev, int curr,\n\t\t\t      char *prev_string, char *curr_string,\n\t\t\t      const unsigned char offline_cpu_bitmap[])\n{\n\tint j = ic_nr, offset, cpu, colwidth[NR_IRQS];\n\tstruct stats_irqcpu *p, *q, *p0, *q0;\n\n\t/*\n\t * Check if number of interrupts has changed.\n\t * If this is the case, the header line will be printed again.\n\t * NB: A zero interval value indicates that we are\n\t * displaying statistics since system startup.\n\t */\n\tif (!dis && interval) {\n\t\tfor (j = 0; j < ic_nr; j++) {\n\t\t\tp0 = st_ic[curr] + j;\n\t\t\tq0 = st_ic[prev] + j;\n\t\t\tif (strcmp(p0->irq_name, q0->irq_name))\n\t\t\t\t/*\n\t\t\t\t * These are two different interrupts: The header must be displayed\n\t\t\t\t * (maybe an interrupt has disappeared, or a new one has just been registered).\n\t\t\t\t * Note that we compare even empty strings for the case where\n\t\t\t\t * a disappearing interrupt would be the last one in the list.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (dis || (j < ic_nr)) {\n\t\t/* Print header */\n\t\tprintf(\"\\n%-11s  CPU\", prev_string);\n\t\tfor (j = 0; j < ic_nr; j++) {\n\t\t\tp0 = st_ic[curr] + j;\n\t\t\tif (p0->irq_name[0] == '\\0')\n\t\t\t\t/* End of the list of interrupts */\n\t\t\t\tbreak;\n\t\t\tprintf(\" %8s/s\", p0->irq_name);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* Calculate column widths */\n\tfor (j = 0; j < ic_nr; j++) {\n\t\tp0 = st_ic[curr] + j;\n\t\t/*\n\t\t * Width is IRQ name + 2 for the trailing \"/s\".\n\t\t * Width is calculated even for \"undefined\" interrupts (with\n\t\t * an empty irq_name string) to quiet code analysis tools.\n\t\t */\n\t\tcolwidth[j] = strlen(p0->irq_name) + 2;\n\t\t/*\n\t\t * Normal space for printing a number is 11 chars\n\t\t * (space + 10 digits including the period).\n\t\t */\n\t\tif (colwidth[j] < 10) {\n\t\t\tcolwidth[j] = 10;\n\t\t}\n\t}\n\n\tfor (cpu = 1; cpu <= cpu_nr; cpu++) {\n\n\t\t/*\n\t\t * Check if we want stats about this CPU.\n\t\t * CPU must have been explicitly selected using option -P,\n\t\t * else we display every CPU (unless it's offline).\n\t\t */\n\t\tif ((!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))) && USE_OPTION_P(flags)) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, cpu))\n\t\t\tcontinue;\n\n\t\tprintf(\"%-11s\", curr_string);\n\t\tcprintf_in(IS_INT, \"  %3d\", \"\", cpu - 1);\n\n\t\tfor (j = 0; j < ic_nr; j++) {\n\t\t\tp0 = st_ic[curr] + j;\t/* irq_name set only for CPU#0 */\n\t\t\t/*\n\t\t\t * An empty string for irq_name means it is a remaining interrupt\n\t\t\t * which is no longer used, for example because the\n\t\t\t * number of interrupts has decreased in /proc/interrupts.\n\t\t\t */\n\t\t\tif (p0->irq_name[0] == '\\0')\n\t\t\t\t/* End of the list of interrupts */\n\t\t\t\tbreak;\n\t\t\tq0 = st_ic[prev] + j;\n\t\t\toffset = j;\n\n\t\t\t/*\n\t\t\t * If we want stats for the time since system startup,\n\t\t\t * we have p0->irq_name != q0->irq_name, since q0 structure\n\t\t\t * is completely set to zero.\n\t\t\t */\n\t\t\tif (strcmp(p0->irq_name, q0->irq_name) && interval) {\n\t\t\t\t/* Check if interrupt exists elsewhere in list */\n\t\t\t\tfor (offset = 0; offset < ic_nr; offset++) {\n\t\t\t\t\tq0 = st_ic[prev] + offset;\n\t\t\t\t\tif (!strcmp(p0->irq_name, q0->irq_name))\n\t\t\t\t\t\t/* Interrupt found at another position */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = st_ic[curr] + (cpu - 1) * ic_nr + j;\n\n\t\t\tif (!strcmp(p0->irq_name, q0->irq_name) || !interval) {\n\t\t\t\tq = st_ic[prev] + (cpu - 1) * ic_nr + offset;\n\t\t\t\tcprintf_f(NO_UNIT, FALSE, 1, colwidth[j], 2,\n\t\t\t\t\t  S_VALUE(q->interrupt, p->interrupt, itv));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Instead of printing \"N/A\", assume that previous value\n\t\t\t\t * for this new interrupt was zero.\n\t\t\t\t */\n\t\t\t\tcprintf_f(NO_UNIT, FALSE, 1, colwidth[j], 2,\n\t\t\t\t\t  S_VALUE(0, p->interrupt, itv));\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics for each CPU in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @st_ic\tArray for per-CPU statistics.\n * @ic_nr\tNumber of interrupts (hard or soft) per CPU.\n * @itv\t\tInterval value.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @type\tActivity (M_D_IRQ_CPU or M_D_SOFTIRQS).\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_json_irqcpu_stats(int tab, struct stats_irqcpu *st_ic[], int ic_nr,\n\t\t\t     unsigned long long itv, int prev, int curr, int type,\n\t\t\t     const unsigned char offline_cpu_bitmap[])\n{\n\tint j = ic_nr, offset, cpu;\n\tstruct stats_irqcpu *p, *q, *p0, *q0;\n\tint nextcpu = FALSE, nextirq;\n\n\tif (type == M_D_IRQ_CPU) {\n\t\txprintf(tab++, \"\\\"individual-interrupts\\\": [\");\n\t}\n\telse {\n\t\txprintf(tab++, \"\\\"soft-interrupts\\\": [\");\n\t}\n\n\tfor (cpu = 1; cpu <= cpu_nr; cpu++) {\n\n\t\t/*\n\t\t * Check if we want stats about this CPU.\n\t\t * CPU must have been explicitly selected using option -P,\n\t\t * else we display every CPU (unless it's offline).\n\t\t */\n\t\tif ((!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))) && USE_OPTION_P(flags)) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, cpu))\n\t\t\tcontinue;\n\n\t\tif (nextcpu) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnextcpu = TRUE;\n\t\tnextirq = FALSE;\n\t\txprintf(tab++, \"{\\\"cpu\\\": \\\"%d\\\", \\\"intr\\\": [\", cpu - 1);\n\n\t\tfor (j = 0; j < ic_nr; j++) {\n\n\t\t\tp0 = st_ic[curr] + j;\t/* irq_name set only for CPU#0 */\n\t\t\t/*\n\t\t\t * An empty string for irq_name means it is a remaining interrupt\n\t\t\t * which is no longer used, for example because the\n\t\t\t * number of interrupts has decreased in /proc/interrupts.\n\t\t\t */\n\t\t\tif (p0->irq_name[0] == '\\0')\n\t\t\t\t/* End of the list of interrupts */\n\t\t\t\tbreak;\n\t\t\tq0 = st_ic[prev] + j;\n\t\t\toffset = j;\n\n\t\t\tif (nextirq) {\n\t\t\t\tprintf(\",\\n\");\n\t\t\t}\n\t\t\tnextirq = TRUE;\n\n\t\t\t/*\n\t\t\t * If we want stats for the time since system startup,\n\t\t\t * we have p0->irq_name != q0->irq_name, since q0 structure\n\t\t\t * is completely set to zero.\n\t\t\t */\n\t\t\tif (strcmp(p0->irq_name, q0->irq_name) && interval) {\n\t\t\t\t/* Check if interrupt exists elsewhere in list */\n\t\t\t\tfor (offset = 0; offset < ic_nr; offset++) {\n\t\t\t\t\tq0 = st_ic[prev] + offset;\n\t\t\t\t\tif (!strcmp(p0->irq_name, q0->irq_name))\n\t\t\t\t\t\t/* Interrupt found at another position */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = st_ic[curr] + (cpu - 1) * ic_nr + j;\n\n\t\t\tif (!strcmp(p0->irq_name, q0->irq_name) || !interval) {\n\t\t\t\tq = st_ic[prev] + (cpu - 1) * ic_nr + offset;\n\t\t\t\txprintf0(tab, \"{\\\"name\\\": \\\"%s\\\", \\\"value\\\": %.2f}\",\n\t\t\t\t\t p0->irq_name,\n\t\t\t\t\t S_VALUE(q->interrupt, p->interrupt, itv));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Instead of printing \"N/A\", assume that previous value\n\t\t\t\t * for this new interrupt was zero.\n\t\t\t\t */\n\t\t\t\txprintf0(tab, \"{\\\"name\\\": \\\"%s\\\", \\\"value\\\": %.2f}\",\n\t\t\t\t\t p0->irq_name,\n\t\t\t\t\t S_VALUE(0, p->interrupt, itv));\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\txprintf0(--tab, \"] }\");\n\t}\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics for each CPU in plain or JSON format.\n *\n * IN:\n * @st_ic\tArray for per-CPU statistics.\n * @ic_nr\tNumber of interrupts (hard or soft) per CPU.\n * @dis\t\tTRUE if a header line must be printed.\n * @itv\t\tInterval value.\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where current statistics will be saved.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @next\tTRUE is a previous activity has been displayed (JSON format\n * \t\tonly).\n * @type\tActivity (M_D_IRQ_CPU or M_D_SOFTIRQS).\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n ***************************************************************************\n */\nvoid write_irqcpu_stats(struct stats_irqcpu *st_ic[], int ic_nr, int dis,\n\t\t\tunsigned long long itv, int prev, int curr,\n\t\t\tchar *prev_string, char *curr_string, int tab,\n\t\t\tint *next, int type, unsigned char offline_cpu_bitmap[])\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tif (*next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\t*next = TRUE;\n\t\twrite_json_irqcpu_stats(tab, st_ic, ic_nr, itv, prev, curr, type,\n\t\t\t\t\toffline_cpu_bitmap);\n\t}\n\telse {\n\t\twrite_plain_irqcpu_stats(st_ic, ic_nr, dis, itv, prev, curr,\n\t\t\t\t\t prev_string, curr_string, offline_cpu_bitmap);\n\t}\n}\n\n/*\n ***************************************************************************\n * Core function used to display statistics.\n *\n * IN:\n * @prev\tPosition in array where statistics used\tas reference are.\n *\t\tStats used as reference may be the previous ones read, or\n *\t\tthe very first ones when calculating the average.\n * @curr\tPosition in array where statistics for current sample are.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n ***************************************************************************\n */\nvoid write_stats_core(int prev, int curr, int dis,\n\t\t      char *prev_string, char *curr_string)\n{\n\tunsigned long long itv, deltot_jiffies = 1;\n\tint tab = 4, next = FALSE;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\t/*\n\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t * and look for offline CPU.\n\t */\n\tdeltot_jiffies = get_global_cpu_mpstats(prev, curr, offline_cpu_bitmap);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf(tab++, \"{\");\n\t\txprintf(tab, \"\\\"timestamp\\\": \\\"%s\\\",\", curr_string);\n\t}\n\n\t/* Get time interval */\n\titv = get_interval(uptime_cs[prev], uptime_cs[curr]);\n\n\t/* Print CPU stats */\n\tif (DISPLAY_CPU(actflags)) {\n\t\twrite_cpu_stats(dis, deltot_jiffies, prev, curr,\n\t\t\t\tprev_string, curr_string, tab, &next, offline_cpu_bitmap);\n\t}\n\n\t/* Print node CPU stats */\n\tif (DISPLAY_NODE(actflags)) {\n\t\tset_node_cpu_stats(prev, curr);\n\t\twrite_node_stats(dis, deltot_jiffies, prev, curr, prev_string,\n\t\t\t\t curr_string, tab, &next);\n\t}\n\n\t/* Print total number of interrupts per processor */\n\tif (DISPLAY_IRQ_SUM(actflags)) {\n\t\twrite_isumcpu_stats(dis, itv, prev, curr, prev_string, curr_string,\n\t\t\t\t    tab, &next, offline_cpu_bitmap);\n\t}\n\n\t/* Display each interrupt value for each CPU */\n\tif (DISPLAY_IRQ_CPU(actflags)) {\n\t\twrite_irqcpu_stats(st_irqcpu, irqcpu_nr, dis, itv, prev, curr,\n\t\t\t\t   prev_string, curr_string, tab, &next, M_D_IRQ_CPU,\n\t\t\t\t   offline_cpu_bitmap);\n\t}\n\tif (DISPLAY_SOFTIRQS(actflags)) {\n\t\twrite_irqcpu_stats(st_softirqcpu, softirqcpu_nr, dis, itv, prev, curr,\n\t\t\t\t   prev_string, curr_string, tab, &next, M_D_SOFTIRQS,\n\t\t\t\t   offline_cpu_bitmap);\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\n\");\n\t\txprintf0(--tab, \"}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Print statistics average.\n *\n * IN:\n * @curr\tPosition in array where statistics for current sample are.\n * @dis\t\tTRUE if a header line must be printed.\n ***************************************************************************\n */\nvoid write_stats_avg(int curr, int dis)\n{\n\tchar string[16];\n\n\tstrncpy(string, _(\"Average:\"), 16);\n\tstring[15] = '\\0';\n\twrite_stats_core(2, curr, dis, string, string);\n}\n\n/*\n ***************************************************************************\n * Print statistics.\n *\n * IN:\n * @curr\tPosition in array where statistics for current sample are.\n * @dis\t\tTRUE if a header line must be printed.\n ***************************************************************************\n */\nvoid write_stats(int curr, int dis)\n{\n\tchar cur_time[2][TIMESTAMP_LEN];\n\n\t/* Get previous timestamp */\n\tif (is_iso_time_fmt()) {\n\t\tstrftime(cur_time[!curr], sizeof(cur_time[!curr]), \"%H:%M:%S\", &mp_tstamp[!curr]);\n\t}\n\telse {\n\t\tstrftime(cur_time[!curr], sizeof(cur_time[!curr]), \"%X\", &(mp_tstamp[!curr]));\n\t}\n\n\t/* Get current timestamp */\n\tif (is_iso_time_fmt()) {\n\t\tstrftime(cur_time[curr], sizeof(cur_time[curr]), \"%H:%M:%S\", &mp_tstamp[curr]);\n\t}\n\telse {\n\t\tstrftime(cur_time[curr], sizeof(cur_time[curr]), \"%X\", &(mp_tstamp[curr]));\n\t}\n\n\twrite_stats_core(!curr, curr, dis, cur_time[!curr], cur_time[curr]);\n}\n\n/*\n ***************************************************************************\n * Read total number of interrupts from /proc/stat.\n *\n * IN:\n * @st_irq\tStructure where total number of interrupts will be saved.\n *\n * OUT:\n * @st_irq\tStructure with total number of interrupts.\n ***************************************************************************\n */\nvoid read_stat_total_irq(struct stats_global_irq *st_irq)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tunsigned long long irq_nr;\n\n\tif ((fp = fopen(STAT, \"r\")) == NULL)\n\t\treturn;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"intr \", 5)) {\n\t\t\t/* Read total number of interrupts received since system boot */\n\t\t\tsscanf(line + 5, \"%llu\", &irq_nr);\n\t\t\tst_irq->irq_nr = (unsigned int) irq_nr;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n}\n/*\n ***************************************************************************\n * Read stats from /proc/interrupts or /proc/softirqs.\n *\n * IN:\n * @file\t/proc file to read (interrupts or softirqs).\n * @ic_nr\tNumber of interrupts (hard or soft) per CPU.\n * @curr\tPosition in array where current statistics will be saved.\n *\n * OUT:\n * @st_ic\tArray for per-CPU interrupts statistics.\n ***************************************************************************\n */\nvoid read_interrupts_stat(char *file, struct stats_irqcpu *st_ic[], int ic_nr, int curr)\n{\n\tFILE *fp;\n\tstruct stats_global_irq *st_irq_i;\n\tstruct stats_irqcpu *p;\n\tchar *line = NULL, *li;\n\tunsigned long irq = 0;\n\tunsigned int cpu, c = 0;\n\tint cpu_index[cpu_nr], index = 0, len;\n\tchar *cp, *next;\n\n\tif ((fp = fopen(file, \"r\")) != NULL) {\n\n\t\tSREALLOC(line, char, INTERRUPTS_LINE + 11 * cpu_nr);\n\n\t\t/*\n\t\t * Parse header line to see which CPUs are online\n\t\t */\n\t\twhile (fgets(line, INTERRUPTS_LINE + 11 * cpu_nr, fp) != NULL) {\n\n\t\t\tnext = line;\n\t\t\twhile (((cp = strstr(next, \"CPU\")) != NULL) && (index < cpu_nr)) {\n\n\t\t\t\tcpu = strtol(cp + 3, &next, 10);\n\t\t\t\tif (cpu >= cpu_nr)\n\t\t\t\t\tbreak;\n\t\t\t\tcpu_index[index++] = cpu;\n\n\t\t\t\t/*\n\t\t\t\t * Reset total number of interrupts received by a CPU\n\t\t\t\t * only for online CPU. Only needed for st_irq structures.\n\t\t\t\t */\n\t\t\t\tst_irq_i = st_irq[curr] + cpu + 1;\n\t\t\t\tst_irq_i->irq_nr = 0;\n\n\t\t\t\t/*\n\t\t\t\t * For offline CPU, pick up previous values so that when the\n\t\t\t\t * CPU goes back online, values won't jump from zero.\n\t\t\t\t */\n\t\t\t\tfwd_irq_values(st_ic, c, cpu, ic_nr, curr);\n\t\t\t\tc = cpu + 1;\n\t\t\t}\n\t\t\tif (index)\n\t\t\t\t/* Header line found */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Process possible offline CPU at the end of the list */\n\t\tfwd_irq_values(st_ic, c, cpu_nr, ic_nr, curr);\n\n\t\t/* Parse each line of interrupts statistics data */\n\t\twhile ((fgets(line, INTERRUPTS_LINE + 11 * cpu_nr, fp) != NULL) &&\n\t\t       (irq < ic_nr)) {\n\n\t\t\t/* Skip over \"<irq>:\" */\n\t\t\tif ((cp = strchr(line, ':')) == NULL)\n\t\t\t\t/* Chr ':' not found */\n\t\t\t\tcontinue;\n\t\t\tcp++;\n\n\t\t\tp = st_ic[curr] + irq;\n\n\t\t\t/* Remove possible heading spaces in interrupt's name... */\n\t\t\tli = line;\n\t\t\twhile (*li == ' ')\n\t\t\t\tli++;\n\n\t\t\tlen = strcspn(li, \":\");\n\t\t\tif (len >= MAX_IRQ_LEN) {\n\t\t\t\tlen = MAX_IRQ_LEN - 1;\n\t\t\t}\n\t\t\t/* ...then save its name */\n\t\t\tstrncpy(p->irq_name, li, len);\n\t\t\tp->irq_name[len] = '\\0';\n\n\t\t\t/* For each interrupt: Get number received by each CPU */\n\t\t\tfor (cpu = 0; cpu < index; cpu++) {\n\t\t\t\tp = st_ic[curr] + cpu_index[cpu] * ic_nr + irq;\n\t\t\t\tst_irq_i = st_irq[curr] + cpu_index[cpu] + 1;\n\t\t\t\t/*\n\t\t\t\t * No need to set (st_irqcpu + cpu * irqcpu_nr)->irq_name:\n\t\t\t\t * This is the same as st_irqcpu->irq_name.\n\t\t\t\t * Now save current interrupt value for current CPU (in\n\t\t\t\t * stats_irqcpu structure) and total number of interrupts\n\t\t\t\t * received by current CPU (in stats_global_irq structure).\n\t\t\t\t */\n\t\t\t\tp->interrupt = strtoul(cp, &next, 10);\n\t\t\t\tst_irq_i->irq_nr += p->interrupt;\n\t\t\t\tcp = next;\n\t\t\t}\n\t\t\tirq++;\n\t\t}\n\n\t\tfclose(fp);\n\n\t\tfree(line);\n\t}\n\n\twhile (irq < ic_nr) {\n\t\t/* Nb of interrupts per processor has changed */\n\t\tp = st_ic[curr] + irq;\n\t\tp->irq_name[0] = '\\0';\t/* This value means this is a dummy interrupt */\n\t\tirq++;\n\t}\n}\n\n/*\n ***************************************************************************\n * Main loop: Read stats from the relevant sources, and display them.\n *\n * IN:\n * @dis_hdr\tSet to TRUE if the header line must always be printed.\n * @rows\tNumber of rows of screen.\n ***************************************************************************\n */\nvoid rw_mpstat_loop(int dis_hdr, int rows)\n{\n\tstruct stats_cpu *scc;\n\tint new_cpu_nr;\n\tint curr = 1, dis = 1;\n\tunsigned long lines = rows;\n\n\t/* Read system uptime and CPU stats */\n\tread_uptime(&(uptime_cs[0]));\n\tread_stat_cpu(st_cpu[0], cpu_nr + 1);\n\n\t/*\n\t * Calculate global CPU stats as the sum of individual ones.\n\t * Done only on SMP machines. On UP machines, we keep the values\n\t * read from /proc/stat for global CPU stats.\n\t */\n\tif (cpu_nr > 1) {\n\t\tint i;\n\n\t\tmemset(st_cpu[0], 0, STATS_CPU_SIZE);\n\n\t\tfor (i = 1; i <= cpu_nr; i++) {\n\t\t\tscc = st_cpu[0] + i;\n\n\t\t\tst_cpu[0]->cpu_user += scc->cpu_user;\n\t\t\tst_cpu[0]->cpu_nice += scc->cpu_nice;\n\t\t\tst_cpu[0]->cpu_sys += scc->cpu_sys;\n\t\t\tst_cpu[0]->cpu_idle += scc->cpu_idle;\n\t\t\tst_cpu[0]->cpu_iowait += scc->cpu_iowait;\n\t\t\tst_cpu[0]->cpu_hardirq += scc->cpu_hardirq;\n\t\t\tst_cpu[0]->cpu_steal += scc->cpu_steal;\n\t\t\tst_cpu[0]->cpu_softirq += scc->cpu_softirq;\n\t\t\tst_cpu[0]->cpu_guest += scc->cpu_guest;\n\t\t\tst_cpu[0]->cpu_guest_nice += scc->cpu_guest_nice;\n\t\t}\n\t}\n\n\t/* Read system topology */\n\tif (DISPLAY_CPU(actflags) && DISPLAY_TOPOLOGY(flags)) {\n\t\tread_topology(cpu_nr, st_cpu_topology);\n\t}\n\n\t/*\n\t * Read total number of interrupts received among all CPU.\n\t * (this is the first value on the line \"intr:\" in the /proc/stat file).\n\t */\n\tif (DISPLAY_IRQ_SUM(actflags)) {\n\t\tread_stat_total_irq(st_irq[0]);\n\t}\n\n\t/*\n\t * Read number of interrupts received by each CPU, for each interrupt,\n\t * and compute the total number of interrupts received by each CPU.\n\t */\n\tif (DISPLAY_IRQ_SUM(actflags) || DISPLAY_IRQ_CPU(actflags)) {\n\t\t/* Read this file to display int per CPU or total nr of int per CPU */\n\t\tread_interrupts_stat(INTERRUPTS, st_irqcpu, irqcpu_nr, 0);\n\t}\n\tif (DISPLAY_SOFTIRQS(actflags)) {\n\t\tread_interrupts_stat(SOFTIRQS, st_softirqcpu, softirqcpu_nr, 0);\n\t}\n\n\tif (!interval) {\n\t\t/* Display since boot time */\n\t\tmp_tstamp[1] = mp_tstamp[0];\n\t\tmemset(st_cpu[1], 0, STATS_CPU_SIZE * (cpu_nr + 1));\n\t\tmemset(st_node[1], 0, STATS_CPU_SIZE * (cpu_nr + 1));\n\t\tmemset(st_irq[1], 0, STATS_GLOBAL_IRQ_SIZE * (cpu_nr + 1));\n\t\tmemset(st_irqcpu[1], 0, STATS_IRQCPU_SIZE * (cpu_nr + 1) * irqcpu_nr);\n\t\tif (DISPLAY_SOFTIRQS(actflags)) {\n\t\t\tmemset(st_softirqcpu[1], 0, STATS_IRQCPU_SIZE * (cpu_nr + 1) * softirqcpu_nr);\n\t\t}\n\t\twrite_stats(0, DISP_HDR);\n\t\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\tprintf(\"\\n\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}}\\n\");\n\t\t}\n\t\texit(0);\n\t}\n\n\t/* Set a handler for SIGALRM */\n\tmemset(&alrm_act, 0, sizeof(alrm_act));\n\talrm_act.sa_handler = alarm_handler;\n\tsigaction(SIGALRM, &alrm_act, NULL);\n\talarm(interval);\n\n\t/* Save the first stats collected. Will be used to compute the average */\n\tmp_tstamp[2] = mp_tstamp[0];\n\tuptime_cs[2] = uptime_cs[0];\n\tmemcpy(st_cpu[2], st_cpu[0], STATS_CPU_SIZE * (cpu_nr + 1));\n\tmemcpy(st_node[2], st_node[0], STATS_CPU_SIZE * (cpu_nr + 1));\n\tmemcpy(st_irq[2], st_irq[0], STATS_GLOBAL_IRQ_SIZE * (cpu_nr + 1));\n\tmemcpy(st_irqcpu[2], st_irqcpu[0], STATS_IRQCPU_SIZE * (cpu_nr + 1) * irqcpu_nr);\n\tif (DISPLAY_SOFTIRQS(actflags)) {\n\t\tmemcpy(st_softirqcpu[2], st_softirqcpu[0],\n\t\t       STATS_IRQCPU_SIZE * (cpu_nr + 1) * softirqcpu_nr);\n\t}\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\t__pause();\n\n\tif (sigint_caught)\n\t\t/* SIGINT signal caught during first interval: Exit immediately */\n\t\tgoto terminate;\n\n\tdo {\n\t\t/*\n\t\t * Resetting the structure not needed since every fields will be set.\n\t\t * Exceptions are per-CPU structures: Some of them may not be filled\n\t\t * if corresponding processor is disabled (offline). We set them to zero\n\t\t * to be able to distinguish between offline and tickless CPUs.\n\t\t */\n\t\tmemset(st_cpu[curr], 0, STATS_CPU_SIZE * (cpu_nr + 1));\n\n\t\t/* Get time */\n\t\tget_xtime(&(mp_tstamp[curr]), 0, LOCAL_TIME);\n\n\t\t/* Read uptime and CPU stats */\n\t\tread_uptime(&(uptime_cs[curr]));\n\t\tread_stat_cpu(st_cpu[curr], cpu_nr + 1);\n\n\t\t/* Read system topology */\n\t\tif (DISPLAY_CPU(actflags) && DISPLAY_TOPOLOGY(flags)) {\n\t\t\tread_topology(cpu_nr, st_cpu_topology);\n\t\t}\n\n\t\t/* Read total number of interrupts received among all CPU */\n\t\tif (DISPLAY_IRQ_SUM(actflags)) {\n\t\t\tread_stat_total_irq(st_irq[curr]);\n\t\t}\n\n\t\t/*\n\t\t * Read number of interrupts received by each CPU, for each interrupt,\n\t\t * and compute the total number of interrupts received by each CPU.\n\t\t */\n\t\tif (DISPLAY_IRQ_SUM(actflags) || DISPLAY_IRQ_CPU(actflags)) {\n\t\t\tread_interrupts_stat(INTERRUPTS, st_irqcpu, irqcpu_nr, curr);\n\t\t}\n\t\tif (DISPLAY_SOFTIRQS(actflags)) {\n\t\t\tread_interrupts_stat(SOFTIRQS, st_softirqcpu, softirqcpu_nr, curr);\n\t\t}\n\n\t\t/* Write stats */\n\t\tif (!dis_hdr) {\n\t\t\tdis = lines / rows;\n\t\t\tif (dis) {\n\t\t\t\tlines %= rows;\n\t\t\t}\n\t\t\tlines++;\n\t\t}\n\t\twrite_stats(curr, dis);\n\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count) {\n\n\t\t\t__pause();\n\n\t\t\tif (sigint_caught) {\n\t\t\t\t/* SIGINT signal caught => Display average stats */\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\t\t\tprintf(\",\\n\");\n\t\t\t\t}\n\t\t\t\tcurr ^= 1;\n\t\t\t}\n\t\t}\n\n\t\tif (count && USE_OPTION_H(flags)) {\n\t\t\t/* Check if a vCPU has been physically hotplugged */\n\t\t\tnew_cpu_nr = get_cpu_nr(~0, TRUE);\n\t\t\tif (new_cpu_nr > cpu_nr) {\n\n\t\t\t\t/* Recalculate number of interrupts per processor */\n\t\t\t\tirqcpu_nr = get_irqcpu_nr(INTERRUPTS, NR_IRQS, new_cpu_nr) +\n\t\t\t\tNR_IRQCPU_PREALLOC;\n\t\t\t\t/* Recalculate number of soft interrupts per processor */\n\t\t\t\tsoftirqcpu_nr = get_irqcpu_nr(SOFTIRQS, NR_IRQS, new_cpu_nr) +\n\t\t\t\tNR_IRQCPU_PREALLOC;\n\n\t\t\t\t/* Reallocate cpu stats structures */\n\t\t\t\tsalloc_mp_struct(new_cpu_nr + 1, cpu_nr + 1);\n\n\t\t\t\t/* Get NUMA node placement */\n\t\t\t\tnode_nr = get_node_placement(new_cpu_nr, cpu_per_node, cpu2node);\n\n\t\t\t\t/* Update the highest processor number */\n\t\t\t\tcpu_nr = new_cpu_nr;\n\t\t\t}\n\t\t}\n\t}\n\twhile (count);\n\n\t/* Write stats average */\n\tif (!DISPLAY_JSON_OUTPUT(xflags)) {\n\t\twrite_stats_avg(curr, dis_hdr);\n\t}\n\nterminate:\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\n\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}}\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Main entry to the program\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint opt = 0, i, actset = FALSE;\n\tstruct utsname header;\n\tint dis_hdr = -1;\n\tint rows = 23;\n\tchar *t;\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\t/* Init color strings */\n\tinit_colors();\n\n\t/* Get HZ */\n\tget_HZ();\n\n\t/* What is the highest processor number on this machine? */\n\tcpu_nr = get_cpu_nr(~0, TRUE);\n\n\t/* Calculate number of interrupts per processor */\n\tirqcpu_nr = get_irqcpu_nr(INTERRUPTS, NR_IRQS, cpu_nr) +\n\t\t    NR_IRQCPU_PREALLOC;\n\t/* Calculate number of soft interrupts per processor */\n\tsoftirqcpu_nr = get_irqcpu_nr(SOFTIRQS, NR_IRQS, cpu_nr) +\n\t\t\tNR_IRQCPU_PREALLOC;\n\n\t/*\n\t * cpu_nr: a value of 2 means there are 2 processors (0 and 1).\n\t * In this case, we have to allocate 3 structures: global, proc0 and proc1.\n\t */\n\tsalloc_mp_struct(cpu_nr + 1, 0);\n\n\t/* Get NUMA node placement */\n\tnode_nr = get_node_placement(cpu_nr, cpu_per_node, cpu2node);\n\n\twhile (++opt < argc) {\n\n\t\tif (!strncmp(argv[opt], \"--dec=\", 6) && (strlen(argv[opt]) == 7)) {\n\t\t\t/* Check that the argument is a digit */\n\t\t\tif (!isdigit(argv[opt][6])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\n\t\t\t/* Get number of decimal places */\n\t\t\tdplaces_nr = atoi(argv[opt] + 6);\n\t\t\tif ((dplaces_nr < 0) || (dplaces_nr > 2)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-I\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tactset = TRUE;\n\n\t\t\tfor (t = strtok(argv[opt], \",\"); t; t = strtok(NULL, \",\")) {\n\t\t\t\tif (!strcmp(t, K_SUM)) {\n\t\t\t\t\t/* Display total number of interrupts per CPU */\n\t\t\t\t\tactflags |= M_D_IRQ_SUM;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_CPU)) {\n\t\t\t\t\t/* Display interrupts per CPU */\n\t\t\t\t\tactflags |= M_D_IRQ_CPU;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_SCPU)) {\n\t\t\t\t\t/* Display soft interrupts per CPU */\n\t\t\t\t\tactflags |= M_D_SOFTIRQS;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_ALL)) {\n\t\t\t\t\tactflags |= M_D_IRQ_SUM + M_D_IRQ_CPU + M_D_SOFTIRQS;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\t/* Select output format */\n\t\t\tif (argv[++opt] && !strcmp(argv[opt], K_JSON)) {\n\t\t\t\txflags |= X_D_JSON_OUTPUT;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-N\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (node_nr >= 0) {\n\t\t\t\tflags |= F_OPTION_N;\n\t\t\t\tactflags |= M_D_NODE;\n\t\t\t\tactset = TRUE;\n\t\t\t\tdis_hdr = 9;\n\t\t\t\tif (parse_values(argv[opt], node_bitmap, node_nr + 1, K_LOWERALL)) {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-P\")) {\n\t\t\t/* '-P ALL' can be used on UP machines */\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tflags |= F_OPTION_P;\n\t\t\tdis_hdr = 9;\n\n\t\t\tif (parse_values(argv[opt], cpu_bitmap, cpu_nr, K_LOWERALL)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t}\n#endif\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\tfor (i = 1; *(argv[opt] + i); i++) {\n\n\t\t\t\tswitch (*(argv[opt] + i)) {\n\n\t\t\t\tcase 'A':\n\t\t\t\t\tflags |= F_OPTION_A;\n\t\t\t\t\tactflags |= M_D_CPU + M_D_IRQ_SUM + M_D_IRQ_CPU + M_D_SOFTIRQS;\n\t\t\t\t\tif (node_nr >= 0) {\n\t\t\t\t\t\tactflags |= M_D_NODE;\n\t\t\t\t\t}\n\t\t\t\t\tactset = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'H':\n\t\t\t\t\t/* Display physically hotplugged vCPU */\n\t\t\t\t\tflags |= F_OPTION_H;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'n':\n\t\t\t\t\t/* Display CPU stats based on NUMA node placement */\n\t\t\t\t\tif (node_nr >= 0) {\n\t\t\t\t\t\tactflags |= M_D_NODE;\n\t\t\t\t\t\tactset = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'T':\n\t\t\t\t\t/* Display logical topology */\n\t\t\t\t\tflags |= F_TOPOLOGY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* Display CPU */\n\t\t\t\t\tactflags |= M_D_CPU;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'V':\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *mpstat_env[] = {ENV_COLORS,\n\t\t\t\t\t\t\t\t      ENV_COLORS_SGR,\n\t\t\t\t\t\t\t\t      ENV_TIME_FMT};\n#define MPSTAT_ENV_NR\t3\n\t\t\t\t\t\t/* Print environment contents, version number and exit */\n\t\t\t\t\t\tprint_version(mpstat_env, MPSTAT_ENV_NR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (interval < 0) {\n\t\t\t/* Get interval */\n\t\t\tif (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = -1;\n\t\t}\n\n\t\telse if (count <= 0) {\n\t\t\t/* Get count value */\n\t\t\tif ((strspn(argv[opt], DIGITS) != strlen(argv[opt])) ||\n\t\t\t    !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = atol(argv[opt]);\n\t\t\tif (count < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\t/* Default: Display CPU (e.g., \"mpstat\", \"mpstat -P 1\", \"mpstat -P 1 -n\", \"mpstat -P 1 -N 1\"... */\n\tif (!actset ||\n\t    (USE_OPTION_P(flags) && !(actflags & ~M_D_NODE))) {\n\t\tactflags |= M_D_CPU;\n\t}\n\n\tif (count_bits(&actflags, sizeof(actflags)) > 1) {\n\t\tdis_hdr = 9;\n\t}\n\n\tif (USE_OPTION_A(flags)) {\n\t\t/*\n\t\t * Set -P ALL -N ALL only if individual CPU and/or nodes\n\t\t * have not been selected.\n\t\t */\n\t\tif ((node_nr >= 0) && !USE_OPTION_N(flags)) {\n\t\t\tmemset(node_bitmap, ~0, ((cpu_nr + 1) >> 3) + 1);\n\t\t\tflags += F_OPTION_N;\n\t\t}\n\t\tif (!USE_OPTION_P(flags)) {\n\t\t\tmemset(cpu_bitmap, ~0, ((cpu_nr + 1) >> 3) + 1);\n\t\t\tflags += F_OPTION_P;\n\t\t}\n\t}\n\n\tif (!USE_OPTION_P(flags)) {\n\t\t/* Option -P not used: Set bit 0 (global stats among all proc) */\n\t\t*cpu_bitmap = 1;\n\t}\n\tif (!USE_OPTION_N(flags)) {\n\t\t/* Option -N not used: Set bit 0 (global stats among all nodes) */\n\t\t*node_bitmap = 1;\n\t}\n\tif (dis_hdr < 0) {\n\t\tdis_hdr = 0;\n\t}\n\tif (!dis_hdr) {\n\t\t/* Get window size */\n\t\trows = get_win_height();\n\t}\n\tif (interval < 0) {\n\t\t/* Interval not set => display stats since boot time */\n\t\tinterval = 0;\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t/* Use a decimal point to make JSON code compliant with RFC7159 */\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t}\n\n\t/* Get time */\n\tget_xtime(&(mp_tstamp[0]), 0, LOCAL_TIME);\n\n\t/*\n\t * Don't buffer data if redirected to a pipe.\n\t * Note: With musl-c, the behavior of this function is undefined except\n\t * when it is the first operation on the stream.\n\t */\n\tsetbuf(stdout, NULL);\n\n\t/* Get system name, release number and hostname */\n\t__uname(&header);\n\tprint_gal_header(&(mp_tstamp[0]), header.sysname, header.release,\n\t\t\t header.nodename, header.machine, get_cpu_nr(~0, FALSE),\n\t\t\t DISPLAY_JSON_OUTPUT(xflags));\n\n\t/* Main loop */\n\trw_mpstat_loop(dis_hdr, rows);\n\n\t/* Free structures */\n\tsfree_mp_struct();\n\n\treturn 0;\n}\n"
        },
        {
          "name": "mpstat.h",
          "type": "blob",
          "size": 2.9755859375,
          "content": "/*\n * mpstat: per-processor statistics\n * (C) 2000-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _MPSTAT_H\n#define _MPSTAT_H\n\n#include \"common.h\"\n#include \"rd_stats.h\"\n\n/*\n ***************************************************************************\n * mpstat's specific system files.\n ***************************************************************************\n */\n\n#define SOFTIRQS\tPRE \"/proc/softirqs\"\n#define PHYS_PACK_ID\t\"topology/physical_package_id\"\n#define THREAD_SBL_LST\t\"topology/thread_siblings_list\"\n\n/*\n ***************************************************************************\n * Activities definitions.\n ***************************************************************************\n */\n\n#define M_D_CPU\t\t0x0001\n#define M_D_IRQ_SUM\t0x0002\n#define M_D_IRQ_CPU\t0x0004\n#define M_D_SOFTIRQS\t0x0008\n#define M_D_NODE\t0x0010\n\n#define DISPLAY_CPU(m)\t\t(((m) & M_D_CPU) == M_D_CPU)\n#define DISPLAY_IRQ_SUM(m)\t(((m) & M_D_IRQ_SUM) == M_D_IRQ_SUM)\n#define DISPLAY_IRQ_CPU(m)\t(((m) & M_D_IRQ_CPU) == M_D_IRQ_CPU)\n#define DISPLAY_SOFTIRQS(m)\t(((m) & M_D_SOFTIRQS) == M_D_SOFTIRQS)\n#define DISPLAY_NODE(m)\t\t(((m) & M_D_NODE) == M_D_NODE)\n\n/*\n ***************************************************************************\n * Keywords and constants.\n ***************************************************************************\n */\n\n/* Indicate that option -P has been used */\n#define F_OPTION_P\t0x01\n/* Indicate that option -A has been used */\n#define F_OPTION_A\t0x02\n/* Unused\t\t0x04 */\n/* Indicate that option -N has been used */\n#define F_OPTION_N\t0x08\n/* Display topology */\n#define F_TOPOLOGY\t0x10\n/* Indicate that option -H has been used */\n#define F_OPTION_H\t0x20\n\n#define USE_OPTION_P(m)\t\t(((m) & F_OPTION_P) == F_OPTION_P)\n#define USE_OPTION_A(m)\t\t(((m) & F_OPTION_A) == F_OPTION_A)\n#define USE_OPTION_N(m)\t\t(((m) & F_OPTION_N) == F_OPTION_N)\n#define DISPLAY_TOPOLOGY(m)\t(((m) & F_TOPOLOGY) == F_TOPOLOGY)\n#define USE_OPTION_H(m)\t\t(((m) & F_OPTION_H) == F_OPTION_H)\n\n#define K_SUM\t\"SUM\"\n#define K_CPU\t\"CPU\"\n#define K_SCPU\t\"SCPU\"\n\n#define NR_IRQCPU_PREALLOC\t3\n\n#define MAX_IRQ_LEN\t\t16\n\n/*\n ***************************************************************************\n * Structures used to store statistics.\n ***************************************************************************\n */\n\n/*\n * stats_irqcpu->irq_name:  IRQ#-A\n * stats_irqcpu->interrupt: number of IRQ#-A for proc 0\n * stats_irqcpu->irq_name:  IRQ#-B\n * stats_irqcpu->interrupt: number of IRQ#-B for proc 0\n * ...\n * stats_irqcpu->irq_name:  (undef'd)\n * stats_irqcpu->interrupt: number of IRQ#-A for proc 1\n * stats_irqcpu->irq_name:  (undef'd)\n * stats_irqcpu->interrupt: number of IRQ#-B for proc 1\n * ...\n */\nstruct stats_irqcpu {\n\tunsigned int interrupt;\n\tchar         irq_name[MAX_IRQ_LEN];\n};\n\n#define STATS_IRQCPU_SIZE      (sizeof(struct stats_irqcpu))\n\nstruct stats_global_irq {\n\tunsigned long long irq_nr;\n};\n\n#define STATS_GLOBAL_IRQ_SIZE\t(sizeof(struct stats_global_irq))\n\nstruct cpu_topology {\n\tint phys_package_id;\n\tint logical_core_id;\n};\n\n#endif\n"
        },
        {
          "name": "nls",
          "type": "tree",
          "content": null
        },
        {
          "name": "pcp_def_metrics.c",
          "type": "blob",
          "size": 67.548828125,
          "content": "/*\n * pcp_def_metrics.c: Functions used by sadf to define PCP metrics\n * (C) 2019-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include \"common.h\"\n#include \"sa.h\"\n\n#ifdef HAVE_PCP\n#include <pcp/pmapi.h>\n#include <pcp/import.h>\n#ifdef HAVE_PCP_IMPL_H\n#include <pcp/impl.h>\n#endif\n#endif /* HAVE_PCP */\n\n/*\n ***************************************************************************\n * Define PCP metrics for per-CPU interrupts statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @cpu\t\tCPU number (0 is cpu0, 1 is cpu1, etc.)\n ***************************************************************************\n */\nvoid pcp_def_percpu_int_metrics(struct activity *a, int cpu)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct sa_item *list = a->item_list;\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\tstatic int inst = 0;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(60, 40);\n\n\t\t/* Create metric */\n\t\tpmiAddMetric(\"kernel.percpu.interrupts\",\n\t\t\t     pmiID(60, 4, 1), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\t}\n\n\t/* Create instance for each interrupt for the current CPU */\n\twhile (list != NULL) {\n\n\t\tsnprintf(buf, sizeof(buf), \"%s::cpu%d\", list->item_name, cpu);\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tpmiAddInstance(indom, buf, inst++);\n\t\tlist = list->next;\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Define PCP metrics for global CPU statistics.\n ***************************************************************************\n */\nvoid pcp_def_global_cpu_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"kernel.all.cpu.user\",\n\t\t     pmiID(60, 0, 20), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.nice\",\n\t\t     pmiID(60, 0, 21), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.sys\",\n\t\t     pmiID(60, 0, 22), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.idle\",\n\t\t     pmiID(60, 0, 23), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.iowait\",\n\t\t     pmiID(60, 0, 25), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.steal\",\n\t\t     pmiID(60, 0, 55), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.irq.hard\",\n\t\t     pmiID(60, 0, 54), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.irq.soft\",\n\t\t     pmiID(60, 0, 53), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.irq.total\",\n\t\t     pmiID(60, 0, 34), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.guest\",\n\t\t     pmiID(60, 0, 60), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.all.cpu.guest_nice\",\n\t\t     pmiID(60, 0, 81), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n#endif /* HAVE_PCP */\n}\n\n#ifdef HAVE_PCP\n/*\n * **************************************************************************\n * Define PCP metrics for per-CPU statistics.\n *\n * IN\n * @indom\tInstance domain.\n ***************************************************************************\n */\nvoid pcp_def_percpu_metrics(pmInDom indom)\n{\n\tpmiAddMetric(\"kernel.percpu.cpu.user\",\n\t\t     pmiID(60, 0, 0), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.nice\",\n\t\t     pmiID(60, 0, 1), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.sys\",\n\t\t     pmiID(60, 0, 2), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.idle\",\n\t\t     pmiID(60, 0, 3), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.iowait\",\n\t\t     pmiID(60, 0, 30), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.steal\",\n\t\t     pmiID(60, 0, 58), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.irq.hard\",\n\t\t     pmiID(60, 0, 57), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.irq.soft\",\n\t\t     pmiID(60, 0, 56), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.irq.total\",\n\t\t     pmiID(60, 0, 35), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.guest\",\n\t\t     pmiID(60, 0, 61), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"kernel.percpu.cpu.guest_nice\",\n\t\t     pmiID(60, 0, 83), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n}\n#endif /* HAVE_PCP */\n\n/*\n * **************************************************************************\n * Define PCP metrics for global CPU softnet statistics.\n ***************************************************************************\n */\nvoid pcp_def_global_softnet_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.softnet.processed\",\n\t\t     pmiID(60, 57, 0), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.dropped\",\n\t\t     pmiID(60, 57, 1), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.time_squeeze\",\n\t\t     pmiID(60, 57, 2), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.received_rps\",\n\t\t     pmiID(60, 57, 4), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.flow_limit\",\n\t\t     pmiID(60, 57, 5), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.backlog_length\",\n\t\t     pmiID(60, 57, 12), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n#ifdef HAVE_PCP\n/*\n * **************************************************************************\n * Define PCP metrics for per-CPU softnet statistics.\n *\n * IN\n * @indom\tInstance domain.\n ***************************************************************************\n */\nvoid pcp_def_percpu_softnet_metrics(pmInDom indom)\n{\n\tpmiAddMetric(\"network.softnet.percpu.processed\",\n\t\t     pmiID(60, 57, 6), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.percpu.dropped\",\n\t\t     pmiID(60, 57, 7), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.percpu.time_squeeze\",\n\t\t     pmiID(60, 57, 8), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.percpu.received_rps\",\n\t\t     pmiID(60, 57, 10), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.percpu.flow_limit\",\n\t\t     pmiID(60, 57, 11), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.softnet.percpu.backlog_length\",\n\t\t     pmiID(60, 57, 13), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n}\n#endif /* HAVE_PCP */\n\n#ifdef HAVE_PCP\n/*\n * **************************************************************************\n * Define PCP metrics for CPU frequency statistics.\n *\n * IN\n * @indom\tInstance domain.\n ***************************************************************************\n */\nvoid pcp_def_pwr_cpufreq_metrics(pmInDom indom)\n{\n\tpmiAddMetric(\"hinv.cpu.clock\",\n\t\t     pmiID(60, 18, 0), PM_TYPE_FLOAT, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, -1, 0, 0, PM_TIME_USEC, 0));\n}\n#endif /* HAVE_PCP */\n\n/*\n ***************************************************************************\n * Define PCP metrics for CPU related statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_cpu_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tint i, first = TRUE, create = FALSE;\n\tchar buf[64];\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * Should current CPU (including CPU \"all\") be displayed?\n\t\t * NB: Offline not tested (they may be turned off and on within\n\t\t * the same file).\n\t\t */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* CPU not selected */\n\t\t\tcontinue;\n\n\t\tif (!i) {\n\t\t\tif (a->id == A_CPU) {\n\t\t\t\t/* This is CPU \"all\" */\n\t\t\t\tpcp_def_global_cpu_metrics();\n\t\t\t}\n\n\t\t\telse if (a->id == A_NET_SOFT) {\n\t\t\t\t/* Create metrics for A_NET_SOFT */\n\t\t\t\tpcp_def_global_softnet_metrics();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* This is not CPU \"all\" */\n\t\t\tif (indom == PM_INDOM_NULL) {\n\t\t\t\t/* Create domain */\n\t\t\t\tindom = pmInDom_build(60, 0);\n\t\t\t\tcreate = TRUE;\n\t\t\t}\n\t\t\tif (create) {\n\t\t\t\t/* Create instance for current CPU */\n\t\t\t\tsprintf(buf, \"cpu%d\", i - 1);\n\t\t\t\tpmiAddInstance(indom, buf, i - 1);\n\t\t\t}\n\n\t\t\tif (a->id == A_IRQ) {\n\t\t\t\t/* Create per-CPU interrupts metrics */\n\t\t\t\tpcp_def_percpu_int_metrics(a, i - 1);\n\t\t\t}\n\n\t\t\telse if (first) {\n\t\t\t\tif (a->id == A_CPU) {\n\t\t\t\t\t/* Create metrics for A_CPU */\n\t\t\t\t\tpcp_def_percpu_metrics(indom);\n\t\t\t\t}\n\n\t\t\t\telse if (a->id == A_PWR_CPU) {\n\t\t\t\t\t/* Create metric for A_PWR_CPU */\n\t\t\t\t\tpcp_def_pwr_cpufreq_metrics(indom);\n\t\t\t\t}\n\n\t\t\t\telse if (a->id == A_NET_SOFT) {\n\t\t\t\t\t/* Create metrics for A_NET_SOFT */\n\t\t\t\t\tpcp_def_percpu_softnet_metrics(indom);\n\t\t\t\t}\n\n\t\t\t\tfirst = FALSE;\n\t\t\t}\n\t\t}\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for task creation and context switch statistics.\n ***************************************************************************\n */\nvoid pcp_def_pcsw_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"kernel.all.pswitch\",\n\t\t     pmiID(60, 0, 13), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"kernel.all.sysfork\",\n\t\t     pmiID(60, 0, 14), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for interrupts statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_irq_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tint first = TRUE, inst = 0;\n\tstruct sa_item *list = a->item_list;\n\tpmInDom indom;\n\n\tif (!(a->bitmap->b_array[0] & 1))\n\t\t/* CPU \"all\" not selected: Nothing to do here */\n\t\treturn;\n\n\t/* Create domain */\n\tindom = pmiInDom(60, 4);\n\n\t/* Create instances and metrics for each interrupts for CPU \"all\" */\n\twhile (list != NULL) {\n\n\t\tif (!strcmp(list->item_name, K_LOWERSUM)) {\n\t\t\t/*\n\t\t\t * Create metric for interrupt \"sum\" for CPU \"all\".\n\t\t\t * Interrupt \"sum\" appears at most once in list.\n\t\t\t * No need to create an instance for it: It has a specific metric name.\n\t\t\t */\n\t\t\tpmiAddMetric(\"kernel.all.intr\",\n\t\t\t\t     pmiID(60, 0, 12), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\t\t}\n\t\telse {\n\t\t\tif (first) {\n\t\t\t\t/* Create metric for a common interrupt for CPU \"all\" if not already done */\n\t\t\t\tpmiAddMetric(\"kernel.all.interrupts.total\",\n\t\t\t\t\t     pmiID(60, 4, 0), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\t\t\t\tfirst = FALSE;\n\t\t\t}\n\t\t\t/* Create instance */\n\t\t\tpmiAddInstance(indom, list->item_name, inst++);\n\t\t}\n\t\tlist = list->next;\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for swapping statistics.\n ***************************************************************************\n */\nvoid pcp_def_swap_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"swap.pagesin\",\n\t\t     pmiID(60, 0, 8), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"swap.pagesout\",\n\t\t     pmiID(60, 0, 9), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for paging statistics.\n ***************************************************************************\n */\nvoid pcp_def_paging_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"mem.vmstat.pgpgin\",\n\t\t     pmiID(60, 28, 6), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgpgout\",\n\t\t     pmiID(60, 28, 7), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgfault\",\n\t\t     pmiID(60, 28, 16), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgmajfault\",\n\t\t     pmiID(60, 28, 17), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgfree\",\n\t\t     pmiID(60, 28, 13), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgscan_kswapd_total\",\n\t\t     pmiID(60, 28, 177), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgscan_direct_total\",\n\t\t     pmiID(60, 28, 176), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgsteal_total\",\n\t\t     pmiID(60, 28, 178), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgpromote_success\",\n\t\t     pmiID(60, 28, 192), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"mem.vmstat.pgdemote_total\",\n\t\t     pmiID(60, 28, 193), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for I/O and transfer rate statistics.\n ***************************************************************************\n */\nvoid pcp_def_io_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"disk.all.total\",\n\t\t     pmiID(60, 0, 29), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.all.read\",\n\t\t     pmiID(60, 0, 24), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.all.write\",\n\t\t     pmiID(60, 0, 25), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.all.discard\",\n\t\t     pmiID(60, 0, 96), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.all.read_bytes\",\n\t\t     pmiID(60, 0, 41), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"disk.all.write_bytes\",\n\t\t     pmiID(60, 0, 42), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"disk.all.discard_bytes\",\n\t\t     pmiID(60, 0, 98), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Define PCP metrics for RAM memory utilization.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_ram_memory_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"hinv.physmem\",\n\t\t     pmiID(60, 1, 9), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_DISCRETE,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_MBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.physmem\",\n\t\t     pmiID(60, 1, 0), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_DISCRETE,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.free\",\n\t\t     pmiID(60, 1, 2), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.available\",\n\t\t     pmiID(60, 1, 58), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.used\",\n\t\t     pmiID(60, 1, 1), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.bufmem\",\n\t\t     pmiID(60, 1, 4), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.cached\",\n\t\t     pmiID(60, 1, 5), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.committed_AS\",\n\t\t     pmiID(60, 1, 26), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.active\",\n\t\t     pmiID(60, 1, 14), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.inactive\",\n\t\t     pmiID(60, 1, 15), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.dirty\",\n\t\t     pmiID(60, 1, 22), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tif (DISPLAY_MEM_ALL(a->opt_flags)) {\n\n\t\tpmiAddMetric(\"mem.util.anonpages\",\n\t\t\t     pmiID(60, 1, 30), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\t\tpmiAddMetric(\"mem.util.slab\",\n\t\t\t     pmiID(60, 1, 25), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\t\tpmiAddMetric(\"mem.util.kernelStack\",\n\t\t\t     pmiID(60, 1, 43), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\t\tpmiAddMetric(\"mem.util.pageTables\",\n\t\t\t     pmiID(60, 1, 27), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\t\tpmiAddMetric(\"mem.util.vmallocUsed\",\n\t\t\t     pmiID(60, 1, 51), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Define PCP metrics for swap memory utilization.\n ***************************************************************************\n */\nvoid pcp_def_swap_memory_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"mem.util.swapFree\",\n\t\t     pmiID(60, 1, 21), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.swapTotal\",\n\t\t     pmiID(60, 1, 20), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.swapCached\",\n\t\t     pmiID(60, 1, 13), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for memory statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_memory_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\tpcp_def_ram_memory_metrics(a);\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\tpcp_def_swap_memory_metrics();\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for kernel tables statistics.\n ***************************************************************************\n */\nvoid pcp_def_ktables_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"vfs.dentry.count\",\n\t\t     pmiID(60, 27, 5), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"vfs.files.count\",\n\t\t     pmiID(60, 27, 0), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"vfs.inodes.count\",\n\t\t     pmiID(60, 27, 3), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"kernel.all.nptys\",\n\t\t     pmiID(60, 72, 3), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for queue and load statistics.\n ***************************************************************************\n */\nvoid pcp_def_queue_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmInDom indom;\n\n\tpmiAddMetric(\"kernel.all.runnable\",\n\t\t     pmiID(60, 2, 2), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"kernel.all.nprocs\",\n\t\t     pmiID(60, 2, 3), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"kernel.all.blocked\",\n\t\t     pmiID(60, 0, 16), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tindom = pmiInDom(60, 2);\n\tpmiAddMetric(\"kernel.all.load\",\n\t\t     pmiID(60, 2, 0), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\tpmiAddInstance(indom, \"1 minute\", 1);\n\tpmiAddInstance(indom, \"5 minute\", 5);\n\tpmiAddInstance(indom, \"15 minute\", 15);\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for disks statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_disk_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst = 0;\n\t\tstruct sa_item *list = a->item_list;\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(60, 1);\n\n\t\t/* Create instances */\n\t\twhile (list != NULL) {\n\t\t\tpmiAddInstance(indom, list->item_name, inst++);\n\t\t\tlist = list->next;\n\t\t}\n\t}\n\n\tpmiAddMetric(\"disk.dev.read\",\n\t\t     pmiID(60, 0, 4), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.dev.write\",\n\t\t     pmiID(60, 0, 5), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.dev.total\",\n\t\t     pmiID(60, 0, 28), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"disk.dev.total_bytes\",\n\t\t     pmiID(60, 0, 37), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"disk.dev.read_bytes\",\n\t\t     pmiID(60, 0, 38), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"disk.dev.write_bytes\",\n\t\t     pmiID(60, 0, 39), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"disk.dev.discard_bytes\",\n\t\t     pmiID(60, 0, 90), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"disk.dev.read_rawactive\",\n\t\t     pmiID(60, 0, 72), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"disk.dev.write_rawactive\",\n\t\t     pmiID(60, 0, 73), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"disk.dev.total_rawactive\",\n\t\t     pmiID(60, 0, 79), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"disk.dev.discard_rawactive\",\n\t\t     pmiID(60, 0, 92), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"disk.dev.avactive\",\n\t\t     pmiID(60, 0, 46), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n\n\tpmiAddMetric(\"disk.dev.aveq\",\n\t\t     pmiID(60, 0, 47), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_MSEC, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for network interfaces (errors) statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_dev_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst = 0;\n\t\tstruct sa_item *list = a->item_list;\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(60, 3);\n\n\t\t/* Create instances */\n\t\twhile (list != NULL) {\n\t\t\tpmiAddInstance(indom, list->item_name, inst++);\n\t\t\tlist = list->next;\n\t\t}\n\t}\n\n\tif (a->id == A_NET_DEV) {\n\t\t/* Create metrics for A_NET_DEV */\n\t\tpmiAddMetric(\"network.interface.in.packets\",\n\t\t\t     pmiID(60, 3, 1), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.out.packets\",\n\t\t\t     pmiID(60, 3, 9), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.in.bytes\",\n\t\t\t     pmiID(60, 3, 0), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n\n\t\tpmiAddMetric(\"network.interface.out.bytes\",\n\t\t\t     pmiID(60, 3, 8), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n\n\t\tpmiAddMetric(\"network.interface.in.compressed\",\n\t\t\t     pmiID(60, 3, 6), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.out.compressed\",\n\t\t\t     pmiID(60, 3, 15), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.in.mcasts\",\n\t\t\t     pmiID(60, 3, 7), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\t}\n\telse {\n\t\t/* Create metrics for A_NET_EDEV */\n\t\tpmiAddMetric(\"network.interface.in.errors\",\n\t\t\t     pmiID(60, 3, 2), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.out.errors\",\n\t\t\t     pmiID(60, 3, 10), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.collisions\",\n\t\t\t     pmiID(60, 3, 13), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.in.drops\",\n\t\t\t     pmiID(60, 3, 3), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.out.drops\",\n\t\t\t     pmiID(60, 3, 11), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.out.carrier\",\n\t\t\t     pmiID(60, 3, 14), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.in.frame\",\n\t\t\t     pmiID(60, 3, 5), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.in.fifo\",\n\t\t\t     pmiID(60, 3, 4), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\tpmiAddMetric(\"network.interface.out.fifo\",\n\t\t\t     pmiID(60, 3, 12), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for serial lines statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_serial_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tpmInDom indom;\n\tchar buf[64];\n\n\t/* Create domain */\n\tindom = pmInDom_build(60, 35);\n\n\t/* Create metrics */\n\tpmiAddMetric(\"tty.serial.rx\",\n\t\t     pmiID(60, 74, 0), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"tty.serial.tx\",\n\t\t     pmiID(60, 74, 1), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"tty.serial.frame\",\n\t\t     pmiID(60, 74, 2), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"tty.serial.parity\",\n\t\t     pmiID(60, 74, 3), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"tty.serial.brk\",\n\t\t     pmiID(60, 74, 4), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"tty.serial.overrun\",\n\t\t     pmiID(60, 74, 5), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tfor (i = 0; i < a->nr_ini; i++) {\n\t\t/* Create instances */\n\t\tsprintf(buf, \"serial%d\", i);\n\t\tpmiAddInstance(indom, buf, i);\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for NFS client statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_nfs_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmInDom indom;\n\n\tpmiAddMetric(\"rpc.client.rpccnt\",\n\t\t     pmiID(60, 7, 20), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.client.rpcretrans\",\n\t\t     pmiID(60, 7, 21), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tindom = pmiInDom(60, 7);\n\tpmiAddInstance(indom, \"read\", 6);\n\tpmiAddInstance(indom, \"write\", 8);\n\tpmiAddInstance(indom, \"access\", 18);\n\tpmiAddInstance(indom, \"getattr\", 4);\n\n\tpmiAddMetric(\"nfs.client.reqs\",\n\t\t     pmiID(60, 7, 4), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for NFS server statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_nfsd_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmInDom indom;\n\n\tpmiAddMetric(\"rpc.server.rpccnt\",\n\t\t     pmiID(60, 7, 30), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.server.rpcbadclnt\",\n\t\t     pmiID(60, 7, 34), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.server.netcnt\",\n\t\t     pmiID(60, 7, 44), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.server.netudpcnt\",\n\t\t     pmiID(60, 7, 45), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.server.nettcpcnt\",\n\t\t     pmiID(60, 7, 46), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.server.rchits\",\n\t\t     pmiID(60, 7, 35), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"rpc.server.rcmisses\",\n\t\t     pmiID(60, 7, 36), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tindom = pmiInDom(60, 7);\n\tpmiAddInstance(indom, \"read\", 6);\n\tpmiAddInstance(indom, \"write\", 8);\n\tpmiAddInstance(indom, \"access\", 18);\n\tpmiAddInstance(indom, \"getattr\", 4);\n\n\tpmiAddMetric(\"nfs.server.reqs\",\n\t\t     pmiID(60, 7, 12), PM_TYPE_U32, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for network sockets statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_sock_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.sockstat.total\",\n\t\t     pmiID(60, 11, 9), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.tcp.inuse\",\n\t\t     pmiID(60, 11, 0), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.udp.inuse\",\n\t\t     pmiID(60, 11, 3), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.raw.inuse\",\n\t\t     pmiID(60, 11, 6), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.frag.inuse\",\n\t\t     pmiID(60, 11, 15), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.tcp.tw\",\n\t\t     pmiID(60, 11, 11), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for IP network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_ip_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.ip.inreceives\",\n\t\t     pmiID(60, 14, 2), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.forwdatagrams\",\n\t\t     pmiID(60, 14, 5), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.indelivers\",\n\t\t     pmiID(60, 14, 8), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.outrequests\",\n\t\t     pmiID(60, 14, 9), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.reasmreqds\",\n\t\t     pmiID(60, 14, 13), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.reasmoks\",\n\t\t     pmiID(60, 14, 14), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.fragoks\",\n\t\t     pmiID(60, 14, 16), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.fragcreates\",\n\t\t     pmiID(60, 14, 18), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for IP network errors statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_eip_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.ip.inhdrerrors\",\n\t\t     pmiID(60, 14, 3), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.inaddrerrors\",\n\t\t     pmiID(60, 14, 4), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.inunknownprotos\",\n\t\t     pmiID(60, 14, 6), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.indiscards\",\n\t\t     pmiID(60, 14, 7), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.outdiscards\",\n\t\t     pmiID(60, 14, 10), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.outnoroutes\",\n\t\t     pmiID(60, 14, 11), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.reasmfails\",\n\t\t     pmiID(60, 14, 15), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip.fragfails\",\n\t\t     pmiID(60, 14, 17), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for ICMP network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_icmp_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.icmp.inmsgs\",\n\t\t     pmiID(60, 14, 20), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outmsgs\",\n\t\t     pmiID(60, 14, 33), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.inechos\",\n\t\t     pmiID(60, 14, 27), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.inechoreps\",\n\t\t     pmiID(60, 14, 28), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outechos\",\n\t\t     pmiID(60, 14, 40), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outechoreps\",\n\t\t     pmiID(60, 14, 41), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.intimestamps\",\n\t\t     pmiID(60, 14, 29), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.intimestampreps\",\n\t\t     pmiID(60, 14, 30), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outtimestamps\",\n\t\t     pmiID(60, 14, 42), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outtimestampreps\",\n\t\t     pmiID(60, 14, 43), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.inaddrmasks\",\n\t\t     pmiID(60, 14, 31), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.inaddrmaskreps\",\n\t\t     pmiID(60, 14, 32), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outaddrmasks\",\n\t\t     pmiID(60, 14, 44), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outaddrmaskreps\",\n\t\t     pmiID(60, 14, 45), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for ICMP network errors statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_eicmp_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.icmp.inerrors\",\n\t\t     pmiID(60, 14, 21), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outerrors\",\n\t\t     pmiID(60, 14, 34), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.indestunreachs\",\n\t\t     pmiID(60, 14, 22), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outdestunreachs\",\n\t\t     pmiID(60, 14, 35), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.intimeexcds\",\n\t\t     pmiID(60, 14, 23), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outtimeexcds\",\n\t\t     pmiID(60, 14, 36), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.inparmprobs\",\n\t\t     pmiID(60, 14, 24), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outparmprobs\",\n\t\t     pmiID(60, 14, 37), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.insrcquenchs\",\n\t\t     pmiID(60, 14, 25), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outsrcquenchs\",\n\t\t     pmiID(60, 14, 38), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.inredirects\",\n\t\t     pmiID(60, 14, 27), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp.outredirects\",\n\t\t     pmiID(60, 14, 39), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for TCP network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_tcp_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.tcp.activeopens\",\n\t\t     pmiID(60, 14, 54), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.passiveopens\",\n\t\t     pmiID(60, 14, 55), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.insegs\",\n\t\t     pmiID(60, 14, 59), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.outsegs\",\n\t\t     pmiID(60, 14, 60), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for TCP network errors statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_etcp_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.tcp.attemptfails\",\n\t\t     pmiID(60, 14, 56), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.estabresets\",\n\t\t     pmiID(60, 14, 57), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.retranssegs\",\n\t\t     pmiID(60, 14, 61), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.inerrs\",\n\t\t     pmiID(60, 14, 62), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.tcp.outrsts\",\n\t\t     pmiID(60, 14, 63), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for UDP network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_udp_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.udp.indatagrams\",\n\t\t     pmiID(60, 14, 70), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.udp.outdatagrams\",\n\t\t     pmiID(60, 14, 74), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.udp.noports\",\n\t\t     pmiID(60, 14, 71), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.udp.inerrors\",\n\t\t     pmiID(60, 14, 72), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for IPv6 network sockets statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_sock6_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.sockstat.tcp6.inuse\",\n\t\t     pmiID(60, 73, 0), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.udp6.inuse\",\n\t\t     pmiID(60, 73, 1), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.raw6.inuse\",\n\t\t     pmiID(60, 73, 3), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.sockstat.frag6.inuse\",\n\t\t     pmiID(60, 73, 4), PM_TYPE_32, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for IPv6 network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_ip6_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.ip6.inreceives\",\n\t\t     pmiID(60, 58, 0), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.outforwdatagrams\",\n\t\t     pmiID(60, 58, 9), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.indelivers\",\n\t\t     pmiID(60, 58, 8), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.outrequests\",\n\t\t     pmiID(60, 58, 10), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.reasmreqds\",\n\t\t     pmiID(60, 58, 14), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.reasmoks\",\n\t\t     pmiID(60, 58, 15), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.inmcastpkts\",\n\t\t     pmiID(60, 58, 20), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.outmcastpkts\",\n\t\t     pmiID(60, 58, 21), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.fragoks\",\n\t\t     pmiID(60, 58, 17), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.fragcreates\",\n\t\t     pmiID(60, 58, 19), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for IPv6 network errors statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_eip6_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.ip6.inhdrerrors\",\n\t\t     pmiID(60, 58, 1), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.inaddrerrors\",\n\t\t     pmiID(60, 58, 4), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.inunknownprotos\",\n\t\t     pmiID(60, 58, 5), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.intoobigerrors\",\n\t\t     pmiID(60, 58, 2), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.indiscards\",\n\t\t     pmiID(60, 58, 7), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.outdiscards\",\n\t\t     pmiID(60, 58, 11), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.innoroutes\",\n\t\t     pmiID(60, 58, 3), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.outnoroutes\",\n\t\t     pmiID(60, 58, 12), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.reasmfails\",\n\t\t     pmiID(60, 58, 16), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.fragfails\",\n\t\t     pmiID(60, 58, 18), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.ip6.intruncatedpkts\",\n\t\t     pmiID(60, 58, 6), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for ICMPv6 network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_icmp6_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.icmp6.inmsgs\",\n\t\t     pmiID(60, 58, 32), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outmsgs\",\n\t\t     pmiID(60, 58, 34), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inechos\",\n\t\t     pmiID(60, 58, 41), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inechoreplies\",\n\t\t     pmiID(60, 58, 42), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outechoreplies\",\n\t\t     pmiID(60, 58, 57), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.ingroupmembqueries\",\n\t\t     pmiID(60, 58, 43), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.ingroupmembresponses\",\n\t\t     pmiID(60, 58, 44), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outgroupmembresponses\",\n\t\t     pmiID(60, 58, 59), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.ingroupmembreductions\",\n\t\t     pmiID(60, 58, 45), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outgroupmembreductions\",\n\t\t     pmiID(60, 58, 60), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inroutersolicits\",\n\t\t     pmiID(60, 58, 46), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outroutersolicits\",\n\t\t     pmiID(60, 58, 61), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inrouteradvertisements\",\n\t\t     pmiID(60, 58, 47), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inneighborsolicits\",\n\t\t     pmiID(60, 58, 48), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outneighborsolicits\",\n\t\t     pmiID(60, 58, 63), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inneighboradvertisements\",\n\t\t     pmiID(60, 58, 49), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outneighboradvertisements\",\n\t\t     pmiID(60, 58, 64), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for ICMPv6 network errors statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_eicmp6_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.icmp6.inerrors\",\n\t\t     pmiID(60, 58, 33), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.indestunreachs\",\n\t\t     pmiID(60, 58, 37), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outdestunreachs\",\n\t\t     pmiID(60, 58, 52), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.intimeexcds\",\n\t\t     pmiID(60, 58, 39), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outtimeexcds\",\n\t\t     pmiID(60, 58, 54), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inparmproblems\",\n\t\t     pmiID(60, 58, 40), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outparmproblems\",\n\t\t     pmiID(60, 58, 55), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inredirects\",\n\t\t     pmiID(60, 58, 50), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outredirects\",\n\t\t     pmiID(60, 58, 65), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.inpkttoobigs\",\n\t\t     pmiID(60, 58, 38), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.icmp6.outpkttoobigs\",\n\t\t     pmiID(60, 58, 53), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for UDPv6 network statistics.\n ***************************************************************************\n */\nvoid pcp_def_net_udp6_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"network.udp6.indatagrams\",\n\t\t     pmiID(60, 58, 67), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.udp6.outdatagrams\",\n\t\t     pmiID(60, 58, 70), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.udp6.noports\",\n\t\t     pmiID(60, 58, 68), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"network.udp6.inerrors\",\n\t\t     pmiID(60, 58, 69), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for huge pages statistics.\n ***************************************************************************\n */\nvoid pcp_def_huge_metrics(void)\n{\n#ifdef HAVE_PCP\n\tpmiAddMetric(\"mem.util.hugepagesTotalBytes\",\n\t\t     pmiID(60, 1, 60), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.hugepagesFreeBytes\",\n\t\t     pmiID(60, 1, 61), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.hugepagesRsvdBytes\",\n\t\t     pmiID(60, 1, 62), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n\n\tpmiAddMetric(\"mem.util.hugepagesSurpBytes\",\n\t\t     pmiID(60, 1, 63), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for fan statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_pwr_fan_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst;\n\t\tchar buf[16];\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(34, 0);\n\n\t\tfor (inst = 0; inst < a->item_list_sz; inst++) {\n\t\t\tsprintf(buf, \"fan%d\", inst + 1);\n\t\t\tpmiAddInstance(indom, buf, inst);\n\t\t}\n\t}\n\n\tpmiAddMetric(\"power.fan.rpm\",\n\t\t     pmiID(34, 0, 0), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.fan.drpm\",\n\t\t     pmiID(34, 0, 1), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.fan.device\",\n\t\t     pmiID(34, 0, 2), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for temperature statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_pwr_temp_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst;\n\t\tchar buf[16];\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(34, 1);\n\n\t\tfor (inst = 0; inst < a->item_list_sz; inst++) {\n\t\t\tsprintf(buf, \"temp%d\", inst + 1);\n\t\t\tpmiAddInstance(indom, buf, inst);\n\t\t}\n\t}\n\n\tpmiAddMetric(\"power.temp.celsius\",\n\t\t     pmiID(34, 1, 0), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.temp.percent\",\n\t\t     pmiID(34, 1, 1), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.temp.device\",\n\t\t     pmiID(34, 1, 2), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for voltage inputs statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_pwr_in_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst;\n\t\tchar buf[16];\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(34, 2);\n\n\t\tfor (inst = 0; inst < a->item_list_sz; inst++) {\n\t\t\tsprintf(buf, \"in%d\", inst);\n\t\t\tpmiAddInstance(indom, buf, inst);\n\t\t}\n\t}\n\n\tpmiAddMetric(\"power.in.voltage\",\n\t\t     pmiID(34, 2, 0), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.in.percent\",\n\t\t     pmiID(34, 2, 1), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.in.device\",\n\t\t     pmiID(34, 2, 2), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Define PCP metrics for battery statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_pwr_bat_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst = 0;\n\t\tstruct sa_item *list = a->item_list;\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(34, 4);\n\n\t\t/* Create instances */\n\t\twhile (list != NULL) {\n\t\t\tpmiAddInstance(indom, list->item_name, inst++);\n\t\t\tlist = list->next;\n\t\t}\n\t}\n\n\tpmiAddMetric(\"power.bat.capacity\",\n\t\t     pmiID(34, 4, 0), PM_TYPE_U32, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.bat.status\",\n\t\t     pmiID(34, 4, 2), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for USB devices statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_pwr_usb_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst;\n\t\tchar buf[16];\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(34, 3);\n\n\t\tfor (inst = 0; inst < a->item_list_sz; inst++) {\n\t\t\tsprintf(buf, \"usb%d\", inst);\n\t\t\tpmiAddInstance(indom, buf, inst);\n\t\t}\n\t}\n\n\tpmiAddMetric(\"power.usb.bus\",\n\t\t     pmiID(34, 3, 0), PM_TYPE_U32, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.usb.vendorId\",\n\t\t     pmiID(34, 3, 1), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.usb.productId\",\n\t\t     pmiID(34, 3, 2), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.usb.maxpower\",\n\t\t     pmiID(34, 3, 3), PM_TYPE_U32, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.usb.manufacturer\",\n\t\t     pmiID(34, 3, 4), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"power.usb.productName\",\n\t\t     pmiID(34, 3, 5), PM_TYPE_STRING, indom, PM_SEM_DISCRETE,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for filesystem statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_filesystem_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst = 0;\n\t\tstruct sa_item *list = a->item_list;\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(60, 5);\n\n\t\t/* Create instances */\n\t\twhile (list != NULL) {\n\t\t\tpmiAddInstance(indom, list->item_name, inst++);\n\t\t\tlist = list->next;\n\t\t}\n\t}\n\n\tpmiAddMetric(\"filesys.capacity\",\n\t\t     pmiID(60, 5, 1), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"filesys.free\",\n\t\t     pmiID(60, 5, 3), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"filesys.used\",\n\t\t     pmiID(60, 5, 2), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n\n\tpmiAddMetric(\"filesys.full\",\n\t\t     pmiID(60, 5, 8), PM_TYPE_DOUBLE, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"filesys.maxfiles\",\n\t\t     pmiID(60, 5, 4), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"filesys.freefiles\",\n\t\t     pmiID(60, 5, 6), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"filesys.usedfiles\",\n\t\t     pmiID(60, 5, 5), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"filesys.avail\",\n\t\t     pmiID(60, 5, 10), PM_TYPE_U64, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_KBYTE, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Define PCP metrics for Fibre Channel HBA statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_fchost_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\tint inst = 0;\n\t\tstruct sa_item *list = a->item_list;\n\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(60, 39);\n\n\t\t/* Create instances */\n\t\twhile (list != NULL) {\n\t\t\tpmiAddInstance(indom, list->item_name, inst++);\n\t\t\tlist = list->next;\n\t\t}\n\t}\n\n\tpmiAddMetric(\"fchost.in.frames\",\n\t\t     pmiID(60, 91, 0), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"fchost.out.frames\",\n\t\t     pmiID(60, 91, 1), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\tpmiAddMetric(\"fchost.in.bytes\",\n\t\t     pmiID(60, 91, 2), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n\n\tpmiAddMetric(\"fchost.out.bytes\",\n\t\t     pmiID(60, 91, 3), PM_TYPE_U64, indom, PM_SEM_COUNTER,\n\t\t     pmiUnits(1, 0, 0, PM_SPACE_BYTE, 0, 0));\n#endif /* HAVE_PCP */\n}\n\n#ifdef HAVE_PCP\n/*\n * **************************************************************************\n * Define PCP metrics for pressure-stall CPU statistics.\n *\n * IN\n * @indom\tInstance domain.\n ***************************************************************************\n */\nvoid pcp_def_psicpu_metrics(pmInDom indom)\n{\n\tpmiAddMetric(\"kernel.all.pressure.cpu.some.total\",\n\t\t     pmiID(60, 83, 1), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_USEC, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.cpu.some.avg\",\n\t\t     pmiID(60, 83, 0), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n}\n#endif /* HAVE_PCP */\n\n#ifdef HAVE_PCP\n/*\n * **************************************************************************\n * Define PCP metrics for pressure-stall I/O statistics.\n *\n * IN\n * @indom\tInstance domain.\n ***************************************************************************\n */\nvoid pcp_def_psiio_metrics(pmInDom indom)\n{\n\tpmiAddMetric(\"kernel.all.pressure.io.some.total\",\n\t\t     pmiID(60, 85, 1), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_USEC, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.io.some.avg\",\n\t\t     pmiID(60, 85, 0), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.io.full.total\",\n\t\t     pmiID(60, 85, 3), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_USEC, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.io.full.avg\",\n\t\t     pmiID(60, 85, 2), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n}\n#endif /* HAVE_PCP */\n\n#ifdef HAVE_PCP\n/*\n * **************************************************************************\n * Define PCP metrics for pressure-stall memory statistics.\n *\n * IN\n * @indom\tInstance domain.\n ***************************************************************************\n */\nvoid pcp_def_psimem_metrics(pmInDom indom)\n{\n\tpmiAddMetric(\"kernel.all.pressure.memory.some.total\",\n\t\t     pmiID(60, 84, 1), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_USEC, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.memory.some.avg\",\n\t\t     pmiID(60, 84, 0), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.memory.full.total\",\n\t\t     pmiID(60, 84, 3), PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_COUNTER,\n\t\t     pmiUnits(0, 1, 0, 0, PM_TIME_USEC, 0));\n\n\tpmiAddMetric(\"kernel.all.pressure.memory.full.avg\",\n\t\t     pmiID(60, 84, 2), PM_TYPE_FLOAT, indom, PM_SEM_INSTANT,\n\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n}\n#endif /* HAVE_PCP */\n\n/*\n ***************************************************************************\n * Define PCP metrics for pressure-stall statistics.\n *\n * IN:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\nvoid pcp_def_psi_metrics(struct activity *a)\n{\n#ifdef HAVE_PCP\n\tstatic pmInDom indom = PM_INDOM_NULL;\n\n\tif (indom == PM_INDOM_NULL) {\n\t\t/* Create domain */\n\t\tindom = pmInDom_build(60, 37);\n\n\t\tpmiAddInstance(indom, \"10 second\", 10);\n\t\tpmiAddInstance(indom, \"1 minute\", 60);\n\t\tpmiAddInstance(indom, \"5 minute\", 300);\n\t}\n\n\tif (a->id == A_PSI_CPU) {\n\t\t/* Create metrics for A_PSI_CPU */\n\t\tpcp_def_psicpu_metrics(indom);\n\t}\n\telse if (a->id == A_PSI_IO) {\n\t\t/* Create metrics for A_PSI_IO */\n\t\tpcp_def_psiio_metrics(indom);\n\t}\n\telse {\n\t\t/* Create metrics for A_PSI_MEM */\n\t\tpcp_def_psimem_metrics(indom);\n\t}\n#endif /* HAVE_PCP */\n}\n"
        },
        {
          "name": "pcp_def_metrics.h",
          "type": "blob",
          "size": 1.8896484375,
          "content": "/*\n * pcp_def_metrics.h: Include file used to define PCP metrics.\n * (C) 2019-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _PCP_DEF_METRICS_H\n#define _PCP_DEF_METRICS_H\n\n/*\n ***************************************************************************\n * Prototypes for functions used to define PCP metrics.\n ***************************************************************************\n */\n\nvoid pcp_def_cpu_metrics(struct activity *);\nvoid pcp_def_pcsw_metrics(void);\nvoid pcp_def_irq_metrics(struct activity *);\nvoid pcp_def_swap_metrics(void);\nvoid pcp_def_paging_metrics(void);\nvoid pcp_def_io_metrics(void);\nvoid pcp_def_memory_metrics(struct activity *);\nvoid pcp_def_ktables_metrics(void);\nvoid pcp_def_queue_metrics(void);\nvoid pcp_def_serial_metrics(struct activity *);\nvoid pcp_def_disk_metrics(struct activity *);\nvoid pcp_def_net_dev_metrics(struct activity *);\nvoid pcp_def_net_nfs_metrics(void);\nvoid pcp_def_net_nfsd_metrics(void);\nvoid pcp_def_net_sock_metrics(void);\nvoid pcp_def_net_ip_metrics(void);\nvoid pcp_def_net_eip_metrics(void);\nvoid pcp_def_net_icmp_metrics(void);\nvoid pcp_def_net_eicmp_metrics(void);\nvoid pcp_def_net_tcp_metrics(void);\nvoid pcp_def_net_etcp_metrics(void);\nvoid pcp_def_net_udp_metrics(void);\nvoid pcp_def_net_sock6_metrics(void);\nvoid pcp_def_net_ip6_metrics(void);\nvoid pcp_def_net_eip6_metrics(void);\nvoid pcp_def_net_icmp6_metrics(void);\nvoid pcp_def_net_eicmp6_metrics(void);\nvoid pcp_def_net_udp6_metrics(void);\nvoid pcp_def_huge_metrics(void);\nvoid pcp_def_pwr_fan_metrics(struct activity *);\nvoid pcp_def_pwr_temp_metrics(struct activity *);\nvoid pcp_def_pwr_in_metrics(struct activity *);\nvoid pcp_def_pwr_bat_metrics(struct activity *);\nvoid pcp_def_pwr_usb_metrics(struct activity *);\nvoid pcp_def_filesystem_metrics(struct activity *);\nvoid pcp_def_fchost_metrics(struct activity *);\nvoid pcp_def_psi_metrics(struct activity *);\n\n#endif /* _PCP_DEF_METRICS_H */\n"
        },
        {
          "name": "pcp_stats.c",
          "type": "blob",
          "size": 66.2763671875,
          "content": "/*\n * pcp_stats.c: Functions used by sadf to create PCP archive files.\n * (C) 2019-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include \"sa.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nextern uint64_t flags;\nextern char bat_status[][16];\n\n#ifdef HAVE_PCP\n#include <pcp/pmapi.h>\n#include <pcp/import.h>\n#endif\n\n/*\n ***************************************************************************\n * Display CPU statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @record_hdr\tRecord header for current sample.\n ***************************************************************************\n */\n__print_funct_t pcp_print_cpu_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tunsigned long long deltot_jiffies = 1;\n\tchar buf[64], cpuno[64];\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tchar *str;\n\tstruct stats_cpu *scc, *scp;\n\n\t/*\n\t * @nr[curr] cannot normally be greater than @nr_ini.\n\t * Yet we have created PCP metrics only for @nr_ini CPU.\n\t */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/*\n\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t * and look for offline CPU.\n\t */\n\tif (a->nr_ini > 1) {\n\t\tdeltot_jiffies = get_global_cpu_statistics(a, !curr, curr,\n\t\t\t\t\t\t\t   flags, offline_cpu_bitmap);\n\t}\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* Don't display CPU */\n\t\t\tcontinue;\n\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr]  + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstr = NULL;\n\n\t\t\tif (a->nr_ini == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a UP machine. In this case\n\t\t\t\t * interval has still not been calculated.\n\t\t\t\t */\n\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t\t}\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* CPU \"all\" cannot be tickless */\n\t\t\t\tdeltot_jiffies = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"cpu%d\", i - 1);\n\t\t\tstr = cpuno;\n\n\t\t\t/*\n\t\t\t * Recalculate interval for current proc.\n\t\t\t * If result is 0 then current CPU is a tickless one.\n\t\t\t */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* Current CPU is tickless */\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.user\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.nice\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.sys\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.iowait\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.steal\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.hardirq\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.softirq\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.guest\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.guest_nice\", cpuno, \"0\");\n\t\t\t\tpmiPutValue(\"kernel.percpu.cpu.idle\", cpuno, \"100\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_user - scc->cpu_guest);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.user\" : \"kernel.all.cpu.user\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_nice - scc->cpu_guest_nice);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.nice\" : \"kernel.all.cpu.nice\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_sys);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.sys\" : \"kernel.all.cpu.sys\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_iowait);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.iowait\" : \"kernel.all.cpu.iowait\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_steal);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.steal\" : \"kernel.all.cpu.steal\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_hardirq + scc->cpu_softirq);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.irq.total\" : \"kernel.all.cpu.irq.total\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_hardirq);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.irq.hard\" : \"kernel.all.cpu.irq.hard\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_softirq);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.irq.soft\" : \"kernel.all.cpu.irq.soft\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_guest);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.guest\" : \"kernel.all.cpu.guest\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_guest_nice);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.guest_nice\" : \"kernel.all.cpu.guest_nice\", str, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", scc->cpu_idle);\n\t\tpmiPutValue(i ? \"kernel.percpu.cpu.idle\" : \"kernel.all.cpu.idle\", str, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display task creation and context switch statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pcsw_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->context_switch);\n\tpmiPutValue(\"kernel.all.pswitch\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", spc->processes);\n\tpmiPutValue(\"kernel.all.sysfork\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_irq_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i, c;\n\tchar buf[64], name[64];\n\tstruct stats_irq *stc_cpu_irq, *stc_cpuall_irq;\n\tunsigned char masked_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Identify offline and unselected CPU, and keep persistent statistics values */\n\tget_global_int_statistics(a, !curr, curr, flags, masked_cpu_bitmap);\n\n\tfor (i = 0; i < a->nr2; i++) {\n\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of interrupts has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, stc_cpuall_irq->irq_name))\n\t\t\t\t/* Interrupt not found in list */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfor (c = 0; (c < a->nr[curr]) && (c < a->bitmap->b_size + 1); c++) {\n\n\t\t\tstc_cpu_irq = (struct stats_irq *) ((char *) a->buf[curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\n\t\t\t/* Should current CPU (including CPU \"all\") be processed? */\n\t\t\tif (IS_CPU_SET(masked_cpu_bitmap, c))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(buf, sizeof(buf), \"%u\", stc_cpu_irq->irq_nr);\n\n\t\t\tif (!c) {\n\t\t\t\t/* This is CPU \"all\" */\n\t\t\t\tif (!i) {\n\t\t\t\t\t/* This is interrupt \"sum\" */\n\t\t\t\t\tpmiPutValue(\"kernel.all.intr\", NULL, buf);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpmiPutValue(\"kernel.all.interrupts.total\",\n\t\t\t\t\t\t    stc_cpuall_irq->irq_name, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This is a particular CPU */\n\t\t\t\tsnprintf(name, sizeof(name), \"%s::cpu%d\",\n\t\t\t\t\t stc_cpuall_irq->irq_name, c - 1);\n\t\t\t\tname[sizeof(name) - 1] = '\\0';\n\n\t\t\t\tpmiPutValue(\"kernel.percpu.interrupts\", name, buf);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display swapping statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @record_hdr\tRecord header for current sample.\n ***************************************************************************\n */\n__print_funct_t pcp_print_swap_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", ssc->pswpin);\n\tpmiPutValue(\"swap.pagesin\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", ssc->pswpout);\n\tpmiPutValue(\"swap.pagesout\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display paging statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_paging_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgpgin);\n\tpmiPutValue(\"mem.vmstat.pgpgin\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgpgout);\n\tpmiPutValue(\"mem.vmstat.pgpgout\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgfault);\n\tpmiPutValue(\"mem.vmstat.pgfault\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgmajfault);\n\tpmiPutValue(\"mem.vmstat.pgmajfault\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgfree);\n\tpmiPutValue(\"mem.vmstat.pgfree\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgscan_kswapd);\n\tpmiPutValue(\"mem.vmstat.pgscan_kswapd_total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgscan_direct);\n\tpmiPutValue(\"mem.vmstat.pgscan_direct_total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgsteal);\n\tpmiPutValue(\"mem.vmstat.pgsteal_total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgpromote);\n\tpmiPutValue(\"mem.vmstat.pgpromote_success\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) spc->pgdemote);\n\tpmiPutValue(\"mem.vmstat.pgdemote_total\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_io_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sic->dk_drive);\n\tpmiPutValue(\"disk.all.total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sic->dk_drive_rio);\n\tpmiPutValue(\"disk.all.read\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\",sic->dk_drive_wio);\n\tpmiPutValue(\"disk.all.write\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sic->dk_drive_dio);\n\tpmiPutValue(\"disk.all.discard\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sic->dk_drive_rblk);\n\tpmiPutValue(\"disk.all.read_bytes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sic->dk_drive_wblk);\n\tpmiPutValue(\"disk.all.write_bytes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sic->dk_drive_dblk);\n\tpmiPutValue(\"disk.all.discard_bytes\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization in PCP format.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @dispall\tTRUE if all memory fields should be displayed.\n ***************************************************************************\n */\nvoid pcp_print_ram_memory_stats(struct stats_memory *smc, int dispall)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) (smc->tlmkb >> 10));\n\tpmiPutValue(\"hinv.physmem\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->tlmkb);\n\tpmiPutValue(\"mem.physmem\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->frmkb);\n\tpmiPutValue(\"mem.util.free\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->availablekb);\n\tpmiPutValue(\"mem.util.available\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->tlmkb - smc->frmkb);\n\tpmiPutValue(\"mem.util.used\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->bufkb);\n\tpmiPutValue(\"mem.util.bufmem\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->camkb);\n\tpmiPutValue(\"mem.util.cached\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->comkb);\n\tpmiPutValue(\"mem.util.committed_AS\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->activekb);\n\tpmiPutValue(\"mem.util.active\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->inactkb);\n\tpmiPutValue(\"mem.util.inactive\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->dirtykb);\n\tpmiPutValue(\"mem.util.dirty\", NULL, buf);\n\n\tif (dispall) {\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", smc->anonpgkb);\n\t\tpmiPutValue(\"mem.util.anonpages\", NULL, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", smc->slabkb);\n\t\tpmiPutValue(\"mem.util.slab\", NULL, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", smc->kstackkb);\n\t\tpmiPutValue(\"mem.util.kernelStack\", NULL, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", smc->pgtblkb);\n\t\tpmiPutValue(\"mem.util.pageTables\", NULL, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", smc->vmusedkb);\n\t\tpmiPutValue(\"mem.util.vmallocUsed\", NULL, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization in PCP format.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n ***************************************************************************\n */\nvoid pcp_print_swap_memory_stats(struct stats_memory *smc)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->frskb);\n\tpmiPutValue(\"mem.util.swapFree\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->tlskb);\n\tpmiPutValue(\"mem.util.swapTotal\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->caskb);\n\tpmiPutValue(\"mem.util.swapCached\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display memory statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_memory_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\tpcp_print_ram_memory_stats(smc, DISPLAY_MEM_ALL(a->opt_flags));\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\tpcp_print_swap_memory_stats(smc);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_ktables_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) skc->dentry_stat);\n\tpmiPutValue(\"vfs.dentry.count\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) skc->file_used);\n\tpmiPutValue(\"vfs.files.count\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) skc->inode_used);\n\tpmiPutValue(\"vfs.inodes.count\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", skc->pty_nr);\n\tpmiPutValue(\"kernel.all.nptys\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics in PCP format\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_queue_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) sqc->nr_running);\n\tpmiPutValue(\"kernel.all.runnable\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) sqc->nr_threads);\n\tpmiPutValue(\"kernel.all.nprocs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) sqc->procs_blocked);\n\tpmiPutValue(\"kernel.all.blocked\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) sqc->load_avg_1 / 100);\n\tpmiPutValue(\"kernel.all.load\", \"1 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) sqc->load_avg_5 / 100);\n\tpmiPutValue(\"kernel.all.load\", \"5 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) sqc->load_avg_15 / 100);\n\tpmiPutValue(\"kernel.all.load\", \"15 minute\", buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display disks statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_disk_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_disk *sdc;\n\tchar *dev_name;\n\tchar buf[64];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get device name */\n\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sdc->nr_ios);\n\t\tpmiPutValue(\"disk.dev.total\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) (sdc->rd_sect + sdc->wr_sect) / 2);\n\t\tpmiPutValue(\"disk.dev.total_bytes\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sdc->rd_sect / 2);\n\t\tpmiPutValue(\"disk.dev.read_bytes\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sdc->wr_sect / 2);\n\t\tpmiPutValue(\"disk.dev.write_bytes\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sdc->dc_sect / 2);\n\t\tpmiPutValue(\"disk.dev.discard_bytes\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) sdc->rd_ticks + sdc->wr_ticks);\n\t\tpmiPutValue(\"disk.dev.total_rawactive\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) sdc->rd_ticks);\n\t\tpmiPutValue(\"disk.dev.read_rawactive\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long) sdc->wr_ticks);\n\t\tpmiPutValue(\"disk.dev.write_rawactive\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long)sdc->dc_ticks);\n\t\tpmiPutValue(\"disk.dev.discard_rawactive\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long)sdc->tot_ticks);\n\t\tpmiPutValue(\"disk.dev.avactive\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%lu\", (unsigned long)sdc->rq_ticks);\n\t\tpmiPutValue(\"disk.dev.aveq\", dev_name, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_dev_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_net_dev *sndc;\n\tchar buf[64];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No need to look for the previous sample values: PCP displays the raw\n\t\t * counter value, not its variation over the interval.\n\t\t * The whole list of network interfaces present in file has been created\n\t\t * (this is goal of the FO_ITEM_LIST option set for pcp_fmt report format -\n\t\t * see format.c). So no need to wonder if an instance needs to be created\n\t\t * for current interface.\n\t\t */\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->rx_packets);\n\t\tpmiPutValue(\"network.interface.in.packets\", sndc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->tx_packets);\n\t\tpmiPutValue(\"network.interface.out.packets\", sndc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->rx_bytes);\n\t\tpmiPutValue(\"network.interface.in.bytes\", sndc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->tx_bytes);\n\t\tpmiPutValue(\"network.interface.out.bytes\", sndc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->rx_compressed);\n\t\tpmiPutValue(\"network.interface.in.compressed\", sndc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->tx_compressed);\n\t\tpmiPutValue(\"network.interface.out.compressed\", sndc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sndc->multicast);\n\t\tpmiPutValue(\"network.interface.in.mcasts\", sndc->interface, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display network interfaces errors statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_edev_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_net_edev *snedc;\n\tchar buf[64];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->rx_errors);\n\t\tpmiPutValue(\"network.interface.in.errors\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->tx_errors);\n\t\tpmiPutValue(\"network.interface.out.errors\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->collisions);\n\t\tpmiPutValue(\"network.interface.collisions\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->rx_dropped);\n\t\tpmiPutValue(\"network.interface.in.drops\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->tx_dropped);\n\t\tpmiPutValue(\"network.interface.out.drops\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->tx_carrier_errors);\n\t\tpmiPutValue(\"network.interface.out.carrier\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->rx_frame_errors);\n\t\tpmiPutValue(\"network.interface.in.frame\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->rx_fifo_errors);\n\t\tpmiPutValue(\"network.interface.in.fifo\", snedc->interface, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", snedc->tx_fifo_errors);\n\t\tpmiPutValue(\"network.interface.out.fifo\", snedc->interface, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display serial lines statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_serial_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tchar buf[64], serialno[64];\n\tstruct stats_serial *ssc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tssc = (struct stats_serial *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tsnprintf(serialno, sizeof(serialno), \"serial%u\", ssc->line);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", ssc->rx);\n\t\tpmiPutValue(\"tty.serial.rx\", serialno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", ssc->tx);\n\t\tpmiPutValue(\"tty.serial.tx\", serialno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", ssc->frame);\n\t\tpmiPutValue(\"tty.serial.frame\", serialno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", ssc->parity);\n\t\tpmiPutValue(\"tty.serial.parity\", serialno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", ssc->brk);\n\t\tpmiPutValue(\"tty.serial.brk\", serialno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", ssc->overrun);\n\t\tpmiPutValue(\"tty.serial.overrun\", serialno, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_nfs_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snnc->nfs_rpccnt);\n\tpmiPutValue(\"rpc.client.rpccnt\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snnc->nfs_rpcretrans);\n\tpmiPutValue(\"rpc.client.rpcretrans\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snnc->nfs_readcnt);\n\tpmiPutValue(\"nfs.client.reqs\", \"read\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snnc->nfs_writecnt);\n\tpmiPutValue(\"nfs.client.reqs\", \"write\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snnc->nfs_accesscnt);\n\tpmiPutValue(\"nfs.client.reqs\", \"access\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snnc->nfs_getattcnt);\n\tpmiPutValue(\"nfs.client.reqs\", \"getattr\", buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_nfsd_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_rpccnt);\n\tpmiPutValue(\"rpc.server.rpccnt\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_rpcbad);\n\tpmiPutValue(\"rpc.server.rpcbadclnt\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_netcnt);\n\tpmiPutValue(\"rpc.server.netcnt\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_netudpcnt);\n\tpmiPutValue(\"rpc.server.netudpcnt\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_nettcpcnt);\n\tpmiPutValue(\"rpc.server.nettcpcnt\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_rchits);\n\tpmiPutValue(\"rpc.server.rchits\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_rcmisses);\n\tpmiPutValue(\"rpc.server.rcmisses\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_readcnt);\n\tpmiPutValue(\"nfs.server.reqs\", \"read\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_writecnt);\n\tpmiPutValue(\"nfs.server.reqs\", \"write\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_accesscnt);\n\tpmiPutValue(\"nfs.server.reqs\", \"access\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snndc->nfsd_getattcnt);\n\tpmiPutValue(\"nfs.server.reqs\", \"getattr\", buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display network sockets statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_sock_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->sock_inuse);\n\tpmiPutValue(\"network.sockstat.total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->tcp_inuse);\n\tpmiPutValue(\"network.sockstat.tcp.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->udp_inuse);\n\tpmiPutValue(\"network.sockstat.udp.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->raw_inuse);\n\tpmiPutValue(\"network.sockstat.raw.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->frag_inuse);\n\tpmiPutValue(\"network.sockstat.frag.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->tcp_tw);\n\tpmiPutValue(\"network.sockstat.tcp.tw\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display IP network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @record_hdr\tRecord header for current sample.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_ip_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->InReceives);\n\tpmiPutValue(\"network.ip.inreceives\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->ForwDatagrams);\n\tpmiPutValue(\"network.ip.forwdatagrams\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->InDelivers);\n\tpmiPutValue(\"network.ip.indelivers\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->OutRequests);\n\tpmiPutValue(\"network.ip.outrequests\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->ReasmReqds);\n\tpmiPutValue(\"network.ip.reasmreqds\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->ReasmOKs);\n\tpmiPutValue(\"network.ip.reasmoks\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->FragOKs);\n\tpmiPutValue(\"network.ip.fragoks\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->FragCreates);\n\tpmiPutValue(\"network.ip.fragcreates\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display IP network errors statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_eip_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InHdrErrors);\n\tpmiPutValue(\"network.ip.inhdrerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InAddrErrors);\n\tpmiPutValue(\"network.ip.inaddrerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InUnknownProtos);\n\tpmiPutValue(\"network.ip.inunknownprotos\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InDiscards);\n\tpmiPutValue(\"network.ip.indiscards\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->OutDiscards);\n\tpmiPutValue(\"network.ip.outdiscards\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->OutNoRoutes);\n\tpmiPutValue(\"network.ip.outnoroutes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->ReasmFails);\n\tpmiPutValue(\"network.ip.reasmfails\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->FragFails);\n\tpmiPutValue(\"network.ip.fragfails\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display ICMP network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_icmp_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InMsgs);\n\tpmiPutValue(\"network.icmp.inmsgs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutMsgs);\n\tpmiPutValue(\"network.icmp.outmsgs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InEchos);\n\tpmiPutValue(\"network.icmp.inechos\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InEchoReps);\n\tpmiPutValue(\"network.icmp.inechoreps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutEchos);\n\tpmiPutValue(\"network.icmp.outechos\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutEchoReps);\n\tpmiPutValue(\"network.icmp.outechoreps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InTimestamps);\n\tpmiPutValue(\"network.icmp.intimestamps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InTimestampReps);\n\tpmiPutValue(\"network.icmp.intimestampreps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutTimestamps);\n\tpmiPutValue(\"network.icmp.outtimestamps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutTimestampReps);\n\tpmiPutValue(\"network.icmp.outtimestampreps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InAddrMasks);\n\tpmiPutValue(\"network.icmp.inaddrmasks\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InAddrMaskReps);\n\tpmiPutValue(\"network.icmp.inaddrmaskreps\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutAddrMasks);\n\tpmiPutValue(\"network.icmp.outaddrmasks\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutAddrMaskReps);\n\tpmiPutValue(\"network.icmp.outaddrmaskreps\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n\n/*\n ***************************************************************************\n * Display ICMP network errors statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_eicmp_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InErrors);\n\tpmiPutValue(\"network.icmp.inerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutErrors);\n\tpmiPutValue(\"network.icmp.outerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InDestUnreachs);\n\tpmiPutValue(\"network.icmp.indestunreachs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutDestUnreachs);\n\tpmiPutValue(\"network.icmp.outdestunreachs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InTimeExcds);\n\tpmiPutValue(\"network.icmp.intimeexcds\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutTimeExcds);\n\tpmiPutValue(\"network.icmp.outtimeexcds\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InParmProbs);\n\tpmiPutValue(\"network.icmp.inparmprobs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutParmProbs);\n\tpmiPutValue(\"network.icmp.outparmprobs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InSrcQuenchs);\n\tpmiPutValue(\"network.icmp.insrcquenchs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutSrcQuenchs);\n\tpmiPutValue(\"network.icmp.outsrcquenchs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InRedirects);\n\tpmiPutValue(\"network.icmp.inredirects\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutRedirects);\n\tpmiPutValue(\"network.icmp.outredirects\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display TCP network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_tcp_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sntc->ActiveOpens);\n\tpmiPutValue(\"network.tcp.activeopens\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sntc->PassiveOpens);\n\tpmiPutValue(\"network.tcp.passiveopens\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sntc->InSegs);\n\tpmiPutValue(\"network.tcp.insegs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sntc->OutSegs);\n\tpmiPutValue(\"network.tcp.outsegs\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display TCP network errors statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_etcp_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snetc->AttemptFails);\n\tpmiPutValue(\"network.tcp.attemptfails\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snetc->EstabResets);\n\tpmiPutValue(\"network.tcp.estabresets\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snetc->RetransSegs);\n\tpmiPutValue(\"network.tcp.retranssegs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snetc->InErrs);\n\tpmiPutValue(\"network.tcp.inerrs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snetc->OutRsts);\n\tpmiPutValue(\"network.tcp.outrsts\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display UDP network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_udp_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->InDatagrams);\n\tpmiPutValue(\"network.udp.indatagrams\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->OutDatagrams);\n\tpmiPutValue(\"network.udp.outdatagrams\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->NoPorts);\n\tpmiPutValue(\"network.udp.noports\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->InErrors);\n\tpmiPutValue(\"network.udp.inerrors\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network sockets statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_sock6_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->tcp6_inuse);\n\tpmiPutValue(\"network.sockstat.tcp6.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->udp6_inuse);\n\tpmiPutValue(\"network.sockstat.udp6.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->raw6_inuse);\n\tpmiPutValue(\"network.sockstat.raw6.inuse\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", snsc->frag6_inuse);\n\tpmiPutValue(\"network.sockstat.frag6.inuse\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_ip6_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->InReceives6);\n\tpmiPutValue(\"network.ip6.inreceives\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->OutForwDatagrams6);\n\tpmiPutValue(\"network.ip6.outforwdatagrams\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->InDelivers6);\n\tpmiPutValue(\"network.ip6.indelivers\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->OutRequests6);\n\tpmiPutValue(\"network.ip6.outrequests\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->ReasmReqds6);\n\tpmiPutValue(\"network.ip6.reasmreqds\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->ReasmOKs6);\n\tpmiPutValue(\"network.ip6.reasmoks\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->InMcastPkts6);\n\tpmiPutValue(\"network.ip6.inmcastpkts\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->OutMcastPkts6);\n\tpmiPutValue(\"network.ip6.outmcastpkts\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->FragOKs6);\n\tpmiPutValue(\"network.ip6.fragoks\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", snic->FragCreates6);\n\tpmiPutValue(\"network.ip6.fragcreates\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network errors statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_eip6_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InHdrErrors6);\n\tpmiPutValue(\"network.ip6.inhdrerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InAddrErrors6);\n\tpmiPutValue(\"network.ip6.inaddrerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InUnknownProtos6);\n\tpmiPutValue(\"network.ip6.inunknownprotos\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InTooBigErrors6);\n\tpmiPutValue(\"network.ip6.intoobigerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InDiscards6);\n\tpmiPutValue(\"network.ip6.indiscards\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->OutDiscards6);\n\tpmiPutValue(\"network.ip6.outdiscards\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InNoRoutes6);\n\tpmiPutValue(\"network.ip6.innoroutes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->OutNoRoutes6);\n\tpmiPutValue(\"network.ip6.outnoroutes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->ReasmFails6);\n\tpmiPutValue(\"network.ip6.reasmfails\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->FragFails6);\n\tpmiPutValue(\"network.ip6.fragfails\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", sneic->InTruncatedPkts6);\n\tpmiPutValue(\"network.ip6.intruncatedpkts\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_icmp6_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InMsgs6);\n\tpmiPutValue(\"network.icmp6.inmsgs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutMsgs6);\n\tpmiPutValue(\"network.icmp6.outmsgs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InEchos6);\n\tpmiPutValue(\"network.icmp6.inechos\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InEchoReplies6);\n\tpmiPutValue(\"network.icmp6.inechoreplies\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutEchoReplies6);\n\tpmiPutValue(\"network.icmp6.outechoreplies\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InGroupMembQueries6);\n\tpmiPutValue(\"network.icmp6.ingroupmembqueries\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InGroupMembResponses6);\n\tpmiPutValue(\"network.icmp6.ingroupmembresponses\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutGroupMembResponses6);\n\tpmiPutValue(\"network.icmp6.outgroupmembresponses\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InGroupMembReductions6);\n\tpmiPutValue(\"network.icmp6.ingroupmembreductions\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutGroupMembReductions6);\n\tpmiPutValue(\"network.icmp6.outgroupmembreductions\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InRouterSolicits6);\n\tpmiPutValue(\"network.icmp6.inroutersolicits\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutRouterSolicits6);\n\tpmiPutValue(\"network.icmp6.outroutersolicits\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InRouterAdvertisements6);\n\tpmiPutValue(\"network.icmp6.inrouteradvertisements\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InNeighborSolicits6);\n\tpmiPutValue(\"network.icmp6.inneighborsolicits\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutNeighborSolicits6);\n\tpmiPutValue(\"network.icmp6.outneighborsolicits\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->InNeighborAdvertisements6);\n\tpmiPutValue(\"network.icmp6.inneighboradvertisements\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snic->OutNeighborAdvertisements6);\n\tpmiPutValue(\"network.icmp6.outneighboradvertisements\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network errors statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_eicmp6_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InErrors6);\n\tpmiPutValue(\"network.icmp6.inerrors\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InDestUnreachs6);\n\tpmiPutValue(\"network.icmp6.indestunreachs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutDestUnreachs6);\n\tpmiPutValue(\"network.icmp6.outdestunreachs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InTimeExcds6);\n\tpmiPutValue(\"network.icmp6.intimeexcds\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutTimeExcds6);\n\tpmiPutValue(\"network.icmp6.outtimeexcds\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InParmProblems6);\n\tpmiPutValue(\"network.icmp6.inparmproblems\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutParmProblems6);\n\tpmiPutValue(\"network.icmp6.outparmproblems\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InRedirects6);\n\tpmiPutValue(\"network.icmp6.inredirects\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutRedirects6);\n\tpmiPutValue(\"network.icmp6.outredirects\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->InPktTooBigs6);\n\tpmiPutValue(\"network.icmp6.inpkttoobigs\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sneic->OutPktTooBigs6);\n\tpmiPutValue(\"network.icmp6.outpkttoobigs\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display UDPv6 network statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_net_udp6_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->InDatagrams6);\n\tpmiPutValue(\"network.udp6.indatagrams\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->OutDatagrams6);\n\tpmiPutValue(\"network.udp6.outdatagrams\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->NoPorts6);\n\tpmiPutValue(\"network.udp6.noports\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) snuc->InErrors6);\n\tpmiPutValue(\"network.udp6.inerrors\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pwr_cpufreq_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_pwr_cpufreq *spc;\n\tchar buf[64], cpuno[64];\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"cpu%d\", i - 1);\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%f\", ((double) spc->cpufreq) / 100);\n\t\tpmiPutValue(\"hinv.cpu.clock\", cpuno, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display fan statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pwr_fan_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_pwr_fan *spc;\n\tchar buf[64], instance[32];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\t\tsprintf(instance, \"fan%d\", i + 1);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\",\n\t\t\t (unsigned long long) spc->rpm);\n\t\tpmiPutValue(\"power.fan.rpm\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\",\n\t\t\t (unsigned long long) (spc->rpm - spc->rpm_min));\n\t\tpmiPutValue(\"power.fan.drpm\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%s\", spc->device);\n\t\tpmiPutValue(\"power.fan.device\", instance, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pwr_temp_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_pwr_temp *spc;\n\tchar buf[64], instance[32];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\t\tsprintf(instance, \"temp%d\", i + 1);\n\n\t\tsnprintf(buf, sizeof(buf), \"%f\", spc->temp);\n\t\tpmiPutValue(\"power.temp.celsius\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%f\",\n\t\t\t (spc->temp_max - spc->temp_min) ?\n\t\t\t (spc->temp - spc->temp_min) / (spc->temp_max - spc->temp_min) * 100 :\n\t\t\t 0.0);\n\t\tpmiPutValue(\"power.temp.percent\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%s\",\n\t\t\tspc->device);\n\t\tpmiPutValue(\"power.temp.device\", instance, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @record_hdr\tRecord header for current sample.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pwr_in_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_pwr_in *spc;\n\tchar buf[64], instance[32];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\t\tsprintf(instance, \"in%d\", i);\n\n\t\tsnprintf(buf, sizeof(buf), \"%f\",\n\t\t\t spc->in);\n\t\tpmiPutValue(\"power.in.voltage\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%f\",\n\t\t\t (spc->in_max - spc->in_min) ?\n\t\t\t (spc->in - spc->in_min) / (spc->in_max - spc->in_min) * 100 :\n\t\t\t 0.0);\n\t\tpmiPutValue(\"power.in.percent\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%s\",\n\t\t\tspc->device);\n\t\tpmiPutValue(\"power.in.device\", instance, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n * **************************************************************************\n * Display batteries statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pwr_bat_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_pwr_bat *spbc;\n\tchar buf[64], bat_name[16];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tsnprintf(bat_name, sizeof(bat_name), \"BAT%d\", (int) spbc->bat_id);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", (unsigned int) spbc->capacity);\n\t\tpmiPutValue(\"power.bat.capacity\", bat_name, buf);\n\n\t\t/* Battery status code should not be greater than or equal to BAT_STS_NR */\n\t\tif (spbc->status >= BAT_STS_NR) {\n\t\t\tspbc->status = 0;\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%s\", bat_status[(unsigned int) spbc->status]);\n\t\tpmiPutValue(\"power.bat.status\", bat_name, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @record_hdr\tRecord header for current sample.\n ***************************************************************************\n */\n__print_funct_t pcp_print_huge_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->frhkb * 1024);\n\tpmiPutValue(\"mem.util.hugepagesFreeBytes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->tlhkb * 1024);\n\tpmiPutValue(\"mem.util.hugepagesTotalBytes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->rsvdhkb * 1024);\n\tpmiPutValue(\"mem.util.hugepagesRsvdBytes\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", smc->surphkb * 1024);\n\tpmiPutValue(\"mem.util.hugepagesSurpBytes\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display USB devices in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_pwr_usb_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_pwr_usb *suc;\n\tchar buf[64], instance[32];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsuc = (struct stats_pwr_usb *) ((char *) a->buf[curr] + i * a->msize);\n\t\tsprintf(instance, \"usb%d\", i);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", suc->bus_nr);\n\t\tpmiPutValue(\"power.usb.bus\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%x\", suc->vendor_id);\n\t\tpmiPutValue(\"power.usb.vendorId\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%x\", suc->product_id);\n\t\tpmiPutValue(\"power.usb.productId\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\", suc->bmaxpower << 1);\n\t\tpmiPutValue(\"power.usb.maxpower\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%s\", suc->manufacturer);\n\t\tpmiPutValue(\"power.usb.manufacturer\", instance, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%s\", suc->product);\n\t\tpmiPutValue(\"power.usb.productName\", instance, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display filesystem statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_filesystem_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_filesystem *sfc;\n\tchar buf[64];\n\tchar *dev_name;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sfc->f_blocks / 1024);\n\t\tpmiPutValue(\"filesys.capacity\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sfc->f_bfree / 1024);\n\t\tpmiPutValue(\"filesys.free\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\",\n\t\t\t (sfc->f_blocks - sfc->f_bfree) / 1024);\n\t\tpmiPutValue(\"filesys.used\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%f\",\n\t\t\t sfc->f_blocks ? SP_VALUE(sfc->f_bfree, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t       : 0.0);\n\t\tpmiPutValue(\"filesys.full\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sfc->f_files);\n\t\tpmiPutValue(\"filesys.maxfiles\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sfc->f_ffree);\n\t\tpmiPutValue(\"filesys.freefiles\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sfc->f_files - sfc->f_ffree);\n\t\tpmiPutValue(\"filesys.usedfiles\", dev_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", sfc->f_bavail / 1024);\n\t\tpmiPutValue(\"filesys.avail\", dev_name, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_softnet_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_softnet *ssnc;\n\tchar buf[64], cpuno[64];\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\t/*\n\t * @nr[curr] cannot normally be greater than @nr_ini.\n\t * Yet we have created PCP metrics only for @nr_ini CPU.\n\t */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Compute statistics for CPU \"all\" */\n\tget_global_soft_statistics(a, !curr, curr, flags, offline_cpu_bitmap);\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n                ssnc = (struct stats_softnet *) ((char *) a->buf[curr]  + i * a->msize);\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"cpu%d\", i - 1);\n\t\t}\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) ssnc->processed);\n\t\tpmiPutValue(\"network.softnet.percpu.processed\", cpuno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) ssnc->dropped);\n\t\tpmiPutValue(\"network.softnet.percpu.dropped\", cpuno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) ssnc->time_squeeze);\n\t\tpmiPutValue(\"network.softnet.percpu.time_squeeze\", cpuno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) ssnc->received_rps);\n\t\tpmiPutValue(\"network.softnet.percpu.received_rps\", cpuno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) ssnc->flow_limit);\n\t\tpmiPutValue(\"network.softnet.percpu.flow_limit\", cpuno, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) ssnc->backlog_len);\n\t\tpmiPutValue(\"network.softnet.percpu.backlog_length\", cpuno, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics in PCP format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_fchost_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tint i;\n\tstruct stats_fchost *sfcc;\n\tchar buf[64];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sfcc->f_rxframes);\n\t\tpmiPutValue(\"fchost.in.frames\", sfcc->fchost_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sfcc->f_txframes);\n\t\tpmiPutValue(\"fchost.out.frames\", sfcc->fchost_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sfcc->f_rxwords * 4);\n\t\tpmiPutValue(\"fchost.in.bytes\", sfcc->fchost_name, buf);\n\n\t\tsnprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) sfcc->f_txwords * 4);\n\t\tpmiPutValue(\"fchost.out.bytes\", sfcc->fchost_name, buf);\n\t}\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics in PCP format\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_psicpu_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_acpu_10 / 100);\n\tpmiPutValue(\"kernel.all.pressure.cpu.some.avg\", \"10 second\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_acpu_60 / 100);\n\tpmiPutValue(\"kernel.all.pressure.cpu.some.avg\", \"1 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_acpu_300 / 100);\n\tpmiPutValue(\"kernel.all.pressure.cpu.some.avg\", \"5 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", psic->some_cpu_total);\n\tpmiPutValue(\"kernel.all.pressure.cpu.some.total\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics in PCP format\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_psiio_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_aio_10 / 100);\n\tpmiPutValue(\"kernel.all.pressure.io.some.avg\", \"10 second\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_aio_60 / 100);\n\tpmiPutValue(\"kernel.all.pressure.io.some.avg\", \"1 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_aio_300 / 100);\n\tpmiPutValue(\"kernel.all.pressure.io.some.avg\", \"5 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", psic->some_io_total);\n\tpmiPutValue(\"kernel.all.pressure.io.some.total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->full_aio_10 / 100);\n\tpmiPutValue(\"kernel.all.pressure.io.full.avg\", \"10 second\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->full_aio_60 / 100);\n\tpmiPutValue(\"kernel.all.pressure.io.full.avg\", \"1 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->full_aio_300 / 100);\n\tpmiPutValue(\"kernel.all.pressure.io.full.avg\", \"5 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", psic->full_io_total);\n\tpmiPutValue(\"kernel.all.pressure.io.full.total\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics in PCP format\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t pcp_print_psimem_stats(struct activity *a, int curr)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr];\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_amem_10 / 100);\n\tpmiPutValue(\"kernel.all.pressure.memory.some.avg\", \"10 second\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_amem_60 / 100);\n\tpmiPutValue(\"kernel.all.pressure.memory.some.avg\", \"1 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->some_amem_300 / 100);\n\tpmiPutValue(\"kernel.all.pressure.memory.some.avg\", \"5 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", psic->some_mem_total);\n\tpmiPutValue(\"kernel.all.pressure.memory.some.total\", NULL, buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->full_amem_10 / 100);\n\tpmiPutValue(\"kernel.all.pressure.memory.full.avg\", \"10 second\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->full_amem_60 / 100);\n\tpmiPutValue(\"kernel.all.pressure.memory.full.avg\", \"1 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%f\", (double) psic->full_amem_300 / 100);\n\tpmiPutValue(\"kernel.all.pressure.memory.full.avg\", \"5 minute\", buf);\n\n\tsnprintf(buf, sizeof(buf), \"%llu\", psic->full_mem_total);\n\tpmiPutValue(\"kernel.all.pressure.memory.full.total\", NULL, buf);\n#endif\t/* HAVE_PCP */\n}\n"
        },
        {
          "name": "pcp_stats.h",
          "type": "blob",
          "size": 3.236328125,
          "content": "/*\n * pcp_stats.h: Include file used to display system statistics in PCP format.\n * (C) 2019-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _PCP_STATS_H\n#define _PCP_STATS_H\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display system statistics in PCP format\n ***************************************************************************\n */\n\n/* Functions used to display statistics in PCP format */\n__print_funct_t pcp_print_cpu_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pcsw_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_irq_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_swap_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_paging_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_io_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_memory_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_ktables_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_queue_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_disk_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_serial_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_dev_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_edev_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_nfs_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_nfsd_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_sock_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_ip_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_eip_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_icmp_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_eicmp_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_tcp_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_etcp_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_udp_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_sock6_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_ip6_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_eip6_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_icmp6_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_eicmp6_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_net_udp6_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pwr_cpufreq_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pwr_fan_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pwr_temp_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pwr_in_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pwr_bat_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_huge_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_pwr_usb_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_filesystem_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_fchost_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_softnet_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_psicpu_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_psiio_stats\n\t(struct activity *, int);\n__print_funct_t pcp_print_psimem_stats\n\t(struct activity *, int);\n\n#endif /* _PCP_STATS_H */\n"
        },
        {
          "name": "pidstat.c",
          "type": "blob",
          "size": 112.001953125,
          "content": "/*\n * pidstat: Report statistics for Linux tasks\n * (C) 2007-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <regex.h>\n\n#ifdef HAVE_LINUX_SCHED_H\n#include <linux/sched.h>\n#endif\n\n#include \"version.h\"\n#include \"pidstat.h\"\n#include \"rd_stats.h\"\n#include \"count.h\"\n\n#include <locale.h>\t/* For setlocale() */\n#ifdef USE_NLS\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern int __env;\n#endif\n\nunsigned long long tot_jiffies[3] = {0, 0, 0};\nunsigned long long uptime_cs[3] = {0, 0, 0};\nstruct st_pid *pid_list = NULL;\n\nstruct tm ps_tstamp[3];\nchar commstr[MAX_COMM_LEN];\nchar userstr[MAX_USER_LEN];\nchar procstr[MAX_COMM_LEN];\n\nint cpu_nr = 0;\t\t\t/* Nb of processors on the machine */\nunsigned long tlmkb;\t\t/* Total memory in kB */\nlong interval = -1;\nlong count = 0;\nunsigned int pidflag = 0;\t/* General flags */\nunsigned int tskflag = 0;\t/* TASK/CHILD stats */\nunsigned int actflag = 0;\t/* Activity flag */\nuint64_t xflags = 0;\t\t/* Extended flag for options used by multiple commands */\n\nstruct sigaction alrm_act, int_act, chld_act;\nint signal_caught = 0;\nint status = 0;\n\nint dplaces_nr = -1;\t\t/* Number of decimal places */\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ] [ -e <program> <args> ]\\n\"),\n\t\tprogname);\n\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -d ] [ -H ] [ -h ] [ -I ] [ -l ] [ -R ] [ -r ] [ -s ] [ -t ] [ -U [ <username> ] ]\\n\"\n\t\t\t  \"[ -u ] [ -V ] [ -v ] [ -w ] [ -C <command> ] [ -G <process_name> ]\\n\"\n\t\t\t  \"[ -p { <pid> [,...] | SELF | ALL } ] [ -T { TASK | CHILD | ALL } ]\\n\"\n\t\t\t  \"[ --dec={ 0 | 1 | 2 } ] [ --human ] [ -o JSON ]\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * SIGALRM signal handler. No need to reset the handler here.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid alarm_handler(int sig)\n{\n\talarm(interval);\n}\n\n/*\n ***************************************************************************\n * SIGINT and SIGCHLD signals handler.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tint status_code;\n\n\tsignal_caught = TRUE;\n\n\tif (sig == SIGCHLD) {\n\t\t/*\n\t\t * SIGCHLD tells the parent process that it can now\n\t\t * get the exit status of the child via wait().\n\t\t */\n\t\twait(&status_code);\n\t\tstatus = WEXITSTATUS(status_code);\n\t}\n}\n\n/*\n ***************************************************************************\n * Free unused PID structures.\n *\n * IN\n * @plist\tPointer address on the start of the linked list.\n * @force\tSet to TRUE if all PID structures shall be freed.\n ***************************************************************************\n */\nvoid sfree_pid(struct st_pid **plist, int force)\n{\n\tint i;\n\tstruct st_pid *p;\n\n\twhile (*plist != NULL) {\n\n\t\tp = *plist;\n\t\tif (!p->exist || force) {\n\t\t\t*plist = p->next;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif (p->pstats[i]) {\n\t\t\t\t\tfree(p->pstats[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(p);\n\t\t}\n\t\telse {\n\t\t\tplist = &(p->next);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Set every PID in list to nonexistent status.\n *\n * IN:\n * @plist\tPointer on the start of the linked list.\n ***************************************************************************\n */\nvoid set_pid_nonexistent(struct st_pid *plist)\n{\n\twhile (plist != NULL) {\n\t\tplist->exist = FALSE;\n\t\tplist = plist->next;\n\t}\n}\n\n/*\n ***************************************************************************\n * Check flags and set default values.\n ***************************************************************************\n */\nvoid check_flags(void)\n{\n\tunsigned int act = 0;\n\n\t/* Display CPU usage for active tasks by default */\n\tif (!actflag) {\n\t\tactflag |= P_A_CPU;\n\t}\n\n\tif (!DISPLAY_PID(pidflag)) {\n\t\t/*\n\t\t * If no PIDs nor -p ALL entered on the command line then\n\t\t * only active PIDs will be displayed.\n\t\t */\n\t\tpidflag |= P_D_ACTIVE_PID + P_D_ALL_PID;\n\t}\n\n\tif (!tskflag) {\n\t\ttskflag |= P_TASK;\n\t}\n\n\t/* Check that requested activities are available */\n\tif (DISPLAY_TASK_STATS(tskflag)) {\n\t\tact |= P_A_CPU + P_A_MEM + P_A_IO + P_A_CTXSW\n\t\t     + P_A_STACK + P_A_KTAB + P_A_RT;\n\t}\n\tif (DISPLAY_CHILD_STATS(tskflag)) {\n\t\tact |= P_A_CPU + P_A_MEM;\n\t}\n\n\tactflag &= act;\n\n\tif (!actflag) {\n\t\tfprintf(stderr, _(\"Requested activities not available\\n\"));\n\t\texit(1);\n\t}\n}\n\n/*\n ***************************************************************************\n * Look for the PID in the list and store it if necessary.\n *       PID ->  PID -> TGID ->  TID ->  TID ->  TID ->  PID -> NULL\n * Eg.: 1234 -> 1289 -> 1356 -> 1356 -> 1361 -> 4678 -> 1376 -> NULL\n *\n * IN:\n * @plist\tPointer address on the start of the linked list.\n * @pid\t\tPID number.\n * @tgid\tIf PID is a TID then @tgid is its TGID number. 0 otherwise.\n *\n * RETURNS:\n * Pointer on the st_pid structure in the list where the PID is located\n * (whether it was already in the list or if it has been added).\n * NULL if the PID is 0 or it is a TID and its TGID has not been found in\n * list.\n ***************************************************************************\n */\nstruct st_pid *add_list_pid(struct st_pid **plist, pid_t pid, pid_t tgid)\n{\n\tstruct st_pid *p, *ps, *tgid_p = NULL;\n\tint i;\n\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (!tgid) {\n\t\t/*\n\t\t * Add a true PID to the list.\n\t\t * Add it in ascending order, not taking into account\n\t\t * other TIDs.\n\t\t */\n\t\twhile (*plist != NULL) {\n\n\t\t\tp = *plist;\n\t\t\tif (!p->tgid && (p->pid == pid))\n\t\t\t\t/* PID found in list */\n\t\t\t\treturn p;\n\n\t\t\tif (!p->tgid && (p->pid > pid))\n\t\t\t\t/* Stop now to insert PID in list */\n\t\t\t\tbreak;\n\n\t\t\tplist = &(p->next);\n\t\t}\n\t}\n\telse {\n\t\tint tgid_found = FALSE;\n\n\t\t/*\n\t\t * PID is a TID.\n\t\t * It will be inserted in ascending order immediately\n\t\t * following its TGID.\n\t\t */\n\t\twhile (*plist != NULL) {\n\n\t\t\tp = *plist;\n\t\t\tif (p->pid == tgid) {\n\t\t\t\t/* TGID found in list */\n\t\t\t\ttgid_found = TRUE;\n\t\t\t\ttgid_p = p;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tplist = &(p->next);\n\t\t}\n\t\tif (!tgid_found)\n\t\t\t/* TGID not found: Stop now */\n\t\t\treturn NULL;\n\n\t\tplist = &(p->next);\n\t\twhile (*plist != NULL) {\n\n\t\t\tp = *plist;\n\t\t\tif ((p->tgid == tgid_p) && (p->pid == pid))\n\t\t\t\t/* TID found in list */\n\t\t\t\treturn p;\n\n\t\t\tif ((p->tgid == tgid_p) && (p->pid > pid))\n\t\t\t\t/* Stop now to insert TID in list */\n\t\t\t\tbreak;\n\t\t\tif (p->tgid != tgid_p)\n\t\t\t\t/* End of TID list: insert TID here */\n\t\t\t\tbreak;\n\n\t\t\tplist = &(p->next);\n\t\t}\n\t}\n\n\t/* PID not found */\n\tps = *plist;\n\n\t/* Add PID to the list */\n\tif ((*plist = (struct st_pid *) malloc(sizeof(struct st_pid))) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tmemset(*plist, 0, sizeof(struct st_pid));\n\n\tp = *plist;\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((p->pstats[i] = (struct pid_stats *) malloc(sizeof(struct pid_stats))) == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(4);\n\t\t}\n\t\tmemset(p->pstats[i], 0, PID_STATS_SIZE);\n\t}\n\tp->pid = pid;\n\tp->next = ps;\n\tif (tgid_p) {\n\t\tp->tgid = tgid_p;\n\t}\n\n\treturn p;\n}\n\n/*\n ***************************************************************************\n * Get pointer on task's command string.\n * If this is a thread then return the short command name so that threads\n * can still be identified.\n *\n * IN:\n * @plist\tPointer address on the start of the linked list.\n ***************************************************************************\n */\nchar *get_tcmd(struct st_pid *plist)\n{\n\tif (DISPLAY_CMDLINE(pidflag) && strlen(plist->cmdline) && !plist->tgid)\n\t\t/* Option \"-l\" used */\n\t\treturn plist->cmdline;\n\telse\n\t\treturn plist->comm;\n}\n\n/*\n ***************************************************************************\n * Display process command name or command line.\n *\n * IN:\n * @plist\tPointer address on the start of the linked list.\n ***************************************************************************\n */\nvoid print_comm(struct st_pid *plist)\n{\n\tchar *p;\n\n\t/* Get pointer on task's command string */\n\tp = get_tcmd(plist);\n\n\tif (plist->tgid) {\n\t\tif (IS_PID_DISPLAYED(plist->tgid->flags)) {\n\t\t\tcprintf_s(IS_ZERO, \"  |__%s\\n\", p);\n\t\t}\n\t\telse {\n\t\t\t/* Its TGID has not been displayed */\n\t\t\tcprintf_s(IS_STR, \"  (%s)\", plist->tgid->comm);\n\t\t\tcprintf_s(IS_ZERO, \"__%s\\n\", p);\n\n\t\t\t/* We can now consider this has been the case */\n\t\t\tplist->tgid->flags |= F_PID_DISPLAYED;\n\t\t}\n\t}\n\telse {\n\t\tcprintf_s(IS_STR, \"  %s\\n\", p);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display process command name or command line in JSON format.\n *\n * IN:\n * @plist\tPointer address on the start of the linked list.\n ***************************************************************************\n */\nvoid print_json_comm(struct st_pid *plist)\n{\n\tchar *p;\n\n\t/* Get pointer on task's command string */\n\tp = get_tcmd(plist);\n\n\tif (DISPLAY_TID(pidflag)) {\n\t\t/* This is a TID */\n\t\tprintf(\"\\\"leader\\\": \\\"\");\n\t\tif (plist->tgid) {\n\t\t\t/* Print thead group leader command then task one */\n\t\t\tprintf(\"%s\", plist->tgid->comm);\n\t\t} /* else this is a PID (TGID) */\n\n\t\tprintf(\"\\\", \");\n\t}\n\tprintf(\"\\\"cmd\\\": \\\"%s\\\"}\", p);\n}\n\n/*\n ***************************************************************************\n * Read /proc/meminfo.\n ***************************************************************************\n */\nvoid read_proc_meminfo(void)\n{\n\tstruct stats_memory st_mem;\n\n\tmemset(&st_mem, 0, STATS_MEMORY_SIZE);\n\tread_meminfo(&st_mem);\n\ttlmkb = st_mem.tlmkb;\n}\n\n/*\n ***************************************************************************\n * Read stats from /proc/#[/task/##]/stat.\n *\n * IN:\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf !=0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * OUT:\n * @thread_nr\tNumber of threads of the process.\n *\n * RETURNS:\n * 0 if stats have been successfully read, and 1 otherwise.\n ***************************************************************************\n */\nint read_proc_pid_stat(pid_t pid, struct st_pid *plist,\n\t\t       unsigned int *thread_nr, pid_t tgid, int curr)\n{\n\tint fd, sz, rc, commsz;\n\tchar filename[128];\n\tstatic char buffer[1024 + 1];\n\tchar *start, *end;\n\tstruct pid_stats *pst = plist->pstats[curr];\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_STAT, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_STAT, pid);\n\t}\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\t/* No such process */\n\t\treturn 1;\n\n\tsz = read(fd, buffer, 1024);\n\tclose(fd);\n\tif (sz <= 0)\n\t\treturn 1;\n\tbuffer[sz] = '\\0';\n\n\tif ((start = strchr(buffer, '(')) == NULL)\n\t\treturn 1;\n\tstart += 1;\n\tif ((end = strrchr(start, ')')) == NULL)\n\t\treturn 1;\n\tcommsz = end - start;\n\tif (commsz >= MAX_COMM_LEN)\n\t\treturn 1;\n\tmemcpy(plist->comm, start, commsz);\n\tplist->comm[commsz] = '\\0';\n\tstart = end + 2;\n\n\trc = sscanf(start,\n\t\t    \"%*s %*d %*d %*d %*d %*d %*u %llu %llu\"\n\t\t    \" %llu %llu %llu %llu %lld %lld %*d %*d %u %*u %*d %llu %llu\"\n\t\t    \" %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u\"\n\t\t    \" %*u %u %u %u %llu %llu %lld\\n\",\n\t\t    &pst->minflt, &pst->cminflt, &pst->majflt, &pst->cmajflt,\n\t\t    &pst->utime,  &pst->stime, &pst->cutime, &pst->cstime,\n\t\t    thread_nr, &pst->vsz, &pst->rss, &pst->processor,\n\t\t    &pst->priority, &pst->policy,\n\t\t    &pst->blkio_swapin_delays, &pst->gtime, &pst->cgtime);\n\n\tif (rc < 15)\n\t\treturn 1;\n\n\tif (rc < 17) {\n\t\t/* gtime and cgtime fields are unavailable in file */\n\t\tpst->gtime = pst->cgtime = 0;\n\t}\n\n\t/* Convert to kB */\n\tpst->vsz >>= 10;\n\tpst->rss = PG_TO_KB(pst->rss);\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read stats from /proc/#[/task/##]/schedstat.\n *\n * IN:\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf != 0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 0 if stats have been successfully read, and 1 otherwise.\n ***************************************************************************\n */\nint read_proc_pid_sched(pid_t pid, struct st_pid *plist, pid_t tgid, int curr)\n{\n\tint fd, rc = 0;\n\tchar filename[128];\n\tstatic char buffer[1024 + 1];\n\tunsigned long long wtime = 0;\n\tstruct pid_stats *pst = plist->pstats[curr];\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_SCHED, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_SCHED, pid);\n\t}\n\n\tif ((fd = open(filename, O_RDONLY)) >= 0) {\n\t\tint sz;\n\n\t\t/* schedstat file found for process */\n\t\tsz = read(fd, buffer, 1024);\n\t\tclose(fd);\n\t\tif (sz > 0) {\n\t\t\tbuffer[sz] = '\\0';\n\n\t\t\trc = sscanf(buffer, \"%*u %llu %*d\\n\", &wtime);\n\t\t}\n\t}\n\n\t/* Convert ns to jiffies */\n\tpst->wtime = wtime * HZ / 1000000000;\n\n\tif (rc < 1)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n *****************************************************************************\n * Read stats from /proc/#[/task/##]/status.\n *\n * IN:\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf != 0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 0 if stats have been successfully read, and 1 otherwise.\n *****************************************************************************\n */\nint read_proc_pid_status(pid_t pid, struct st_pid *plist, pid_t tgid, int curr)\n{\n\tFILE *fp;\n\tchar filename[128], line[256];\n\tstruct pid_stats *pst = plist->pstats[curr];\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_STATUS, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_STATUS, pid);\n\t}\n\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\t/* No such process */\n\t\treturn 1;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Uid:\", 4)) {\n\t\t\tsscanf(line + 5, \"%u\", &plist->uid);\n\t\t}\n\t\telse if (!strncmp(line, \"Threads:\", 8)) {\n\t\t\tsscanf(line + 9, \"%u\", &pst->threads);\n\t\t}\n\t\telse if (!strncmp(line, \"voluntary_ctxt_switches:\", 24)) {\n\t\t\tsscanf(line + 25, \"%lu\", &pst->nvcsw);\n\t\t}\n\t\telse if (!strncmp(line, \"nonvoluntary_ctxt_switches:\", 27)) {\n\t\t\tsscanf(line + 28, \"%lu\", &pst->nivcsw);\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\n/*\n *****************************************************************************\n * Read information from /proc/#[/task/##}/smaps.\n *\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf != 0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 0 if stats have been successfully read, and 1 otherwise.\n *****************************************************************************\n */\nint read_proc_pid_smap(pid_t pid, struct st_pid *plist, pid_t tgid, int curr)\n{\n\tFILE *fp;\n\tchar filename[128], line[256];\n\tint state = 0;\n\tstruct pid_stats *pst = plist->pstats[curr];\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_SMAP, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_SMAP, pid);\n\t}\n\n\tif ((fp = fopen(filename, \"rt\")) == NULL)\n\t\t/* No such process */\n\t\treturn 1;\n\n\twhile ((state < 3) && (fgets(line, sizeof(line), fp) != NULL)) {\n\n\t\tswitch (state) {\n\t\t\tcase 0:\n\t\t\t\tif (strstr(line, \"[stack]\")) {\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strstr(line, \"Size:\")) {\n\t\t\t\t\tsscanf(line + sizeof(\"Size:\"), \"%lu\", &pst->stack_size);\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strstr(line, \"Referenced:\")) {\n\t\t\t\t\tsscanf(line + sizeof(\"Referenced:\"), \"%lu\", &pst->stack_ref);\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\n/*\n *****************************************************************************\n * Read process command line from /proc/#[/task/##]/cmdline.\n *\n * IN:\n * @pid\t\tProcess whose command line is to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf != 0, thread whose stats are to be read.\n *\n * OUT:\n * @pst\t\tPointer on structure where command line has been saved.\n *\n * RETURNS:\n * 0 if command line has been successfully read (even if the /proc/.../cmdline\n * is just empty), and 1 otherwise (the process has terminated).\n *****************************************************************************\n */\nint read_proc_pid_cmdline(pid_t pid, struct st_pid *plist, pid_t tgid)\n{\n\tFILE *fp;\n\tchar filename[128], line[MAX_CMDLINE_LEN];\n\tsize_t len;\n\tint found = FALSE;\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_CMDLINE, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_CMDLINE, pid);\n\t}\n\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\t/* No such process */\n\t\treturn 1;\n\n\tmemset(line, 0, MAX_CMDLINE_LEN);\n\n\tlen = fread(line, 1, sizeof(line) - 1, fp);\n\tfclose(fp);\n\n\tif (len) {\n\t\tint i;\n\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tif (line[i]) {\n\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\telse if (found) {\n\t\t\t\tline[i] = ' ';\n\t\t\t}\n\t\t}\n\t\tstrncpy(plist->cmdline, line, sizeof(plist->cmdline) - 1);\n\t\tplist->cmdline[sizeof(plist->cmdline) - 1] = '\\0';\n\t}\n\telse {\n\t\t/* proc/.../cmdline was empty */\n\t\tplist->cmdline[0] = '\\0';\n\t}\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read stats from /proc/#[/task/##]/io.\n *\n * IN:\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf != 0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 0 if stats have been successfully read.\n * Also returns 0 if current process has terminated or if its io file\n * doesn't exist, but in this case, set process' F_NO_PID_IO flag to\n * indicate that I/O stats should no longer be read for it.\n ***************************************************************************\n */\nint read_proc_pid_io(pid_t pid, struct st_pid *plist, pid_t tgid, int curr)\n{\n\tFILE *fp;\n\tchar filename[128], line[256];\n\tstruct pid_stats *pst = plist->pstats[curr];\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_IO, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_IO, pid);\n\t}\n\n\tif ((fp = fopen(filename, \"r\")) == NULL) {\n\t\t/* No such process... or file non existent! */\n\t\tplist->flags |= F_NO_PID_IO;\n\t\t/*\n\t\t * Also returns 0 since io stats file doesn't necessarily exist,\n\t\t * depending on the kernel version used.\n\t\t */\n\t\treturn 0;\n\t}\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"read_bytes:\", 11)) {\n\t\t\tsscanf(line + 12, \"%llu\", &pst->read_bytes);\n\t\t}\n\t\telse if (!strncmp(line, \"write_bytes:\", 12)) {\n\t\t\tsscanf(line + 13, \"%llu\", &pst->write_bytes);\n\t\t}\n\t\telse if (!strncmp(line, \"cancelled_write_bytes:\", 22)) {\n\t\t\tsscanf(line + 23, \"%llu\", &pst->cancelled_write_bytes);\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tplist->flags &= ~F_NO_PID_IO;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Count number of file descriptors in /proc/#[/task/##]/fd directory.\n *\n * IN:\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf != 0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 0 if stats have been successfully read.\n * Also returns 0 if current process has terminated or if we cannot read its\n * fd directory, but in this case, set process' F_NO_PID_FD flag to\n * indicate that fd directory couldn't be read.\n ***************************************************************************\n */\nint read_proc_pid_fd(pid_t pid, struct st_pid *plist, pid_t tgid, int curr)\n{\n\tDIR *dir;\n\tstruct dirent *drp;\n\tchar filename[128];\n\tstruct pid_stats *pst = plist->pstats[curr];\n\n\tif (tgid) {\n\t\tsprintf(filename, TASK_FD, tgid, pid);\n\t}\n\telse {\n\t\tsprintf(filename, PID_FD, pid);\n\t}\n\n\tif ((dir = opendir(filename)) == NULL) {\n\t\t/* Cannot read fd directory */\n\t\tplist->flags |= F_NO_PID_FD;\n\t\treturn 0;\n\t}\n\n\tpst->fd_nr = 0;\n\n\t/* Count number of entries if fd directory */\n\twhile ((drp = readdir(dir)) != NULL) {\n\t\tif (isdigit(drp->d_name[0])) {\n\t\t\t(pst->fd_nr)++;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n\tplist->flags &= ~F_NO_PID_FD;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read various stats for given PID.\n *\n * IN:\n * @pid\t\tProcess whose stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @tgid\tIf !=0, thread whose stats are to be read.\n * @curr\tIndex in array for current sample statistics.\n *\n * OUT:\n * @thread_nr\tNumber of threads of the process.\n *\n * RETURNS:\n * 0 if stats have been successfully read, and 1 otherwise.\n ***************************************************************************\n */\nint read_pid_stats(pid_t pid, struct st_pid *plist, unsigned int *thread_nr,\n\t\t   pid_t tgid, int curr)\n{\n\tif (read_proc_pid_stat(pid, plist, thread_nr, tgid, curr))\n\t\treturn 1;\n\n\t/*\n\t * No need to test the return code here: Not finding\n\t * the schedstat files shouldn't make pidstat stop.\n\t */\n\tread_proc_pid_sched(pid, plist, tgid, curr);\n\n\tif (DISPLAY_CMDLINE(pidflag) && !plist->cmdline[0]) {\n\t\tif (read_proc_pid_cmdline(pid, plist, tgid))\n\t\t\treturn 1;\n\t}\n\n\tif (read_proc_pid_status(pid, plist, tgid, curr))\n\t\treturn 1;\n\n\tif (DISPLAY_STACK(actflag)) {\n\t\tif (read_proc_pid_smap(pid, plist, tgid, curr))\n\t\t\treturn 1;\n\t}\n\n\tif (DISPLAY_KTAB(actflag)) {\n\t\tif (read_proc_pid_fd(pid, plist, tgid, curr))\n\t\t\treturn 1;\n\t}\n\n\tif (DISPLAY_IO(actflag))\n\t\t/* Assume that /proc/#/task/#/io exists! */\n\t\treturn (read_proc_pid_io(pid, plist, tgid, curr));\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read stats for threads in /proc/#/task directory.\n *\n * IN:\n * @pid\t\tProcess number whose threads stats are to be read.\n * @plist\tPointer on the linked list where PID is saved.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\nvoid read_task_stats(pid_t pid, struct st_pid *plist, int curr)\n{\n\tDIR *dir;\n\tpid_t tid;\n\tstruct dirent *drp;\n\tchar filename[128];\n\tunsigned int thr_nr;\n\tstruct st_pid *tlist;\n\n\t/* Open /proc/#/task directory */\n\tsprintf(filename, PROC_TASK, pid);\n\tif ((dir = __opendir(filename)) == NULL)\n\t\treturn;\n\n\twhile ((drp = __readdir(dir)) != NULL) {\n\n\t\tif (!isdigit(drp->d_name[0])) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttid = atoi(drp->d_name);\n\n\t\ttlist = add_list_pid(&pid_list, tid, pid);\n\t\tif (!tlist)\n\t\t\tcontinue;\n\t\ttlist->exist = TRUE;\n\n\t\tif (read_pid_stats(tid, tlist, &thr_nr, pid, curr)) {\n\t\t\t/* Thread doesn't exist */\n\t\t\ttlist->exist = FALSE;\n\t\t}\n\t}\n\n\t__closedir(dir);\n}\n\n/*\n ***************************************************************************\n * Read various stats.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\nvoid read_stats(int curr)\n{\n\tunsigned int thr_nr;\n\tpid_t pid;\n\tstruct st_pid *plist;\n\tstruct stats_cpu *st_cpu;\n\n\t/*\n\t * Allocate two structures for CPU statistics.\n\t * No need to init them (done by read_stat_cpu() function).\n\t */\n\tif ((st_cpu = (struct stats_cpu *) malloc(STATS_CPU_SIZE * 2)) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\t/* Read statistics for CPUs \"all\" */\n\tread_stat_cpu(st_cpu, 1);\n\n\t/*\n\t * Compute the total number of jiffies spent by all processors.\n\t * NB: Don't add cpu_guest/cpu_guest_nice because cpu_user/cpu_nice\n\t * already include them.\n\t */\n\ttot_jiffies[curr] = st_cpu->cpu_user + st_cpu->cpu_nice +\n\t\t\t    st_cpu->cpu_sys + st_cpu->cpu_idle +\n\t\t\t    st_cpu->cpu_iowait + st_cpu->cpu_hardirq +\n\t\t\t    st_cpu->cpu_steal + st_cpu->cpu_softirq;\n\tfree(st_cpu);\n\n\tif (DISPLAY_ALL_PID(pidflag)) {\n\t\tDIR *dir;\n\t\tstruct dirent *drp;\n\n\t\t/* Open /proc directory */\n\t\tif ((dir = __opendir(PROC)) == NULL) {\n\t\t\tperror(\"opendir\");\n\t\t\texit(4);\n\t\t}\n\n\t\t/* Get directory entries */\n\t\twhile ((drp = __readdir(dir)) != NULL) {\n\n\t\t\tif (!isdigit(drp->d_name[0])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpid = atoi(drp->d_name);\n\n\t\t\tplist = add_list_pid(&pid_list, pid, 0);\n\t\t\tif (!plist)\n\t\t\t\tcontinue;\n\t\t\tplist->exist = TRUE;\n\n\t\t\tif (read_pid_stats(pid, plist, &thr_nr, 0, curr)) {\n\t\t\t\t/* PID has terminated */\n\t\t\t\tplist->exist = FALSE;\n\n\t\t\t} else if (DISPLAY_TID(pidflag)) {\n\t\t\t\t/* Read stats for threads in task subdirectory */\n\t\t\t\tread_task_stats(pid, plist, curr);\n\t\t\t}\n\t\t}\n\n\t\t/* Close /proc directory */\n\t\t__closedir(dir);\n\t}\n\n\telse {\n\t\t/* Read stats for each PID in the list */\n\t\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\t\tif (plist->tgid)\n\t\t\t\t/*\n\t\t\t\t * Ignore TIDs.\n\t\t\t\t * The user can only enter PIDs on the command line.\n\t\t\t\t * If there is a TID then this is because the user has\n\t\t\t\t * used option -t, and the TID has been inserted in the\n\t\t\t\t * list by read_task_stats() function below.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\n\t\t\tif (read_pid_stats(plist->pid, plist, &thr_nr, 0, curr)) {\n\t\t\t\t/* PID has terminated */\n\t\t\t\tplist->exist = FALSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tplist->exist = TRUE;\n\n\t\t\t\tif (DISPLAY_TID(pidflag)) {\n\t\t\t\t\tread_task_stats(plist->pid, plist, curr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Free unused PID structures */\n\tsfree_pid(&pid_list, FALSE);\n}\n\n/*\n ***************************************************************************\n * Get current PID to display.\n * First, check that PID exists. *Then* check that it's an active process\n * and/or that the string (entered on the command line with option -C)\n * is found in command name, or that the process string (entered on the\n * command line with option -G) is found either in its command name (in case\n * PID is a process) or in command name of its thread leader (in case\n * PID is a thread).\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @activity\tCurrent activity to display (CPU, memory...).\n * \t\tCan be more than one if stats are displayed on one line.\n * @pflag\tFlag indicating whether stats are to be displayed for\n * \t\tindividual tasks or for all their children.\n * @plist\tPointer on the linked list where PID is saved.\n *\n * RETURNS:\n *  0 if PID no longer exists.\n * -1 if PID exists but should not be displayed.\n *  1 if PID can be displayed.\n ***************************************************************************\n */\nint get_pid_to_display(int prev, int curr, unsigned int activity, unsigned int pflag,\n\t\t       struct st_pid *plist)\n{\n\tint rc;\n\tchar *pc;\n\tregex_t regex;\n\tstruct pid_stats *pstc = plist->pstats[curr], *pstp = plist->pstats[prev];\n\n\tif (!plist->exist)\n\t\t/* PID no longer exists */\n\t\treturn 0;\n\n\tif (!plist->tgid) {\n\t\t/* This is group leader: Set it as not displayed by default */\n\t\tplist->flags &= ~F_PID_DISPLAYED;\n\t}\n\n\tif ((DISPLAY_ALL_PID(pidflag) || DISPLAY_TID(pidflag)) &&\n\t\tDISPLAY_ACTIVE_PID(pidflag)) {\n\t\tint isActive = FALSE;\n\n\t\t/* Check that it's an \"active\" process */\n\t\tif (DISPLAY_CPU(activity)) {\n\t\t\t/* User time already includes guest time */\n\t\t\tif ((pstc->utime != pstp->utime) ||\n\t\t\t    (pstc->stime != pstp->stime)) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Process is not active but if we are showing\n\t\t\t\t * child stats then we need to look there.\n\t\t\t\t */\n\t\t\t\tif (DISPLAY_CHILD_STATS(pflag)) {\n\t\t\t\t\t/* User time already includes guest time */\n\t\t\t\t\tif ((pstc->cutime != pstp->cutime) ||\n\t\t\t\t\t    (pstc->cstime != pstp->cstime)) {\n\t\t\t\t\t\tisActive = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_MEM(activity) && !isActive) {\n\t\t\tif ((pstc->minflt != pstp->minflt) ||\n\t\t\t    (pstc->majflt != pstp->majflt)) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (DISPLAY_TASK_STATS(pflag)) {\n\t\t\t\t\tif ((pstc->vsz != pstp->vsz) ||\n\t\t\t\t\t    (pstc->rss != pstp->rss)) {\n\t\t\t\t\t\tisActive = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (DISPLAY_CHILD_STATS(pflag)) {\n\t\t\t\t\tif ((pstc->cminflt != pstp->cminflt) ||\n\t\t\t\t\t    (pstc->cmajflt != pstp->cmajflt)) {\n\t\t\t\t\t\tisActive = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_STACK(activity) && !isActive) {\n\t\t\tif ((pstc->stack_size != pstp->stack_size) ||\n\t\t\t    (pstc->stack_ref != pstp->stack_ref)) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_IO(activity) && !isActive) {\n\t\t\tif (pstc->blkio_swapin_delays !=\n\t\t\t     pstp->blkio_swapin_delays) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t\tif (!(NO_PID_IO(plist->flags)) && !isActive) {\n\t\t\t\t/* /proc/#/io file should exist to check I/O stats */\n\t\t\t\tif ((pstc->read_bytes  != pstp->read_bytes)  ||\n\t\t\t\t    (pstc->write_bytes != pstp->write_bytes) ||\n\t\t\t\t    (pstc->cancelled_write_bytes !=\n\t\t\t\t     pstp->cancelled_write_bytes)) {\n\t\t\t\t\tisActive = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_CTXSW(activity) && !isActive) {\n\t\t\tif ((pstc->nvcsw  != pstp->nvcsw) ||\n\t\t\t    (pstc->nivcsw != pstp->nivcsw)) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_RT(activity) && !isActive) {\n\t\t\tif ((pstc->priority != pstp->priority) ||\n\t\t\t    (pstc->policy != pstp->policy)) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_KTAB(activity) && !isActive &&\n\t\t\t!(NO_PID_FD(plist->flags))) {\t/* /proc/#/fd directory should be readable */\n\t\t\tif ((pstc->threads != pstp->threads) ||\n\t\t\t    (pstc->fd_nr != pstp->fd_nr)) {\n\t\t\t\tisActive = TRUE;\n\t\t\t}\n\t\t}\n\n\t\t/* If PID isn't active for any of the activities then return */\n\t\tif (!isActive)\n\t\t\treturn -1;\n\t}\n\n\tif (COMMAND_STRING(pidflag)) {\n\t\tif (regcomp(&regex, commstr, REG_EXTENDED | REG_NOSUB) != 0)\n\t\t\t/* Error in preparing regex structure */\n\t\t\treturn -1;\n\n\t\tpc = get_tcmd(plist);\t/* Get pointer on task's command string */\n\t\trc = regexec(&regex, pc, 0, NULL, 0);\n\t\tregfree(&regex);\n\n\t\tif (rc)\n\t\t\t/* regex pattern not found in command name */\n\t\t\treturn -1;\n\t}\n\n\tif (PROCESS_STRING(pidflag)) {\n\t\tif (!plist->tgid) {\n\t\t\t/* This PID is a process (\"thread group leader\") */\n\t\t\tif (regcomp(&regex, procstr, REG_EXTENDED | REG_NOSUB) != 0)\n\t\t\t\t/* Error in preparing regex structure */\n\t\t\t\treturn -1;\n\n\t\t\tpc = get_tcmd(plist);\t/* Get pointer on task's command string */\n\t\t\trc = regexec(&regex, pc, 0, NULL, 0);\n\t\t\tregfree(&regex);\n\n\t\t\tif (rc)\n\t\t\t\t/* regex pattern not found in command name */\n\t\t\t\treturn -1;\n\n\t\t}\n\t\telse if (!IS_PID_DISPLAYED(plist->tgid->flags))\n\t\t\t/* This pid is a thread and is not part of a process to display */\n\t\t\treturn -1;\n\t}\n\n\tif (USER_STRING(pidflag)) {\n\t\tstruct passwd *pwdent;\n\n\t\tif ((pwdent = __getpwuid(plist->uid)) != NULL) {\n\t\t\tif (strcmp(pwdent->pw_name, userstr))\n\t\t\t\t/* This PID doesn't belong to user */\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tplist->flags |= F_PID_DISPLAYED;\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Display UID/username, PID and TID.\n *\n * IN:\n * @plist\tPointer on the linked list where PID is saved.\n * @c\t\tNo-op character.\n ***************************************************************************\n */\nvoid __print_line_id(struct st_pid *plist, char c)\n{\n\tchar format[32];\n\tstruct passwd *pwdent;\n\n\tif (DISPLAY_USERNAME(pidflag) && ((pwdent = __getpwuid(plist->uid)) != NULL)) {\n\t\tcprintf_in(IS_STR, \" %8s\", pwdent->pw_name, 0);\n\t}\n\telse {\n\t\tcprintf_in(IS_INT, \" %5d\", \"\", plist->uid);\n\t}\n\n\tif (DISPLAY_TID(pidflag)) {\n\t\tif (plist->tgid) {\n\t\t\t/* This is a TID */\n\t\t\tif (IS_PID_DISPLAYED(plist->tgid->flags)) {\n\t\t\t\t/*\n\t\t\t\t * Its TGID has previously been displayed.\n\t\t\t\t * We can just display a dash for the TGID then\n\t\t\t\t * the TID number, i.e. \"   -     <TID> \"\n\t\t\t\t */\n\t\t\t\tsprintf(format, \"         %c %%9u\", c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Its TGID didn't meet the conditions to be displayed.\n\t\t\t\t * So we have to specify to which TGID the current TID is\n\t\t\t\t * linked, i.e. \" <TGID>   <TID> \"\n\t\t\t\t */\n\t\t\t\tstrcpy(format, \" %9u\");\n\t\t\t\tcprintf_in(IS_INT, format, \"\", plist->tgid->pid);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* This is a PID (TGID) */\n\t\t\tsprintf(format, \" %%9u         %c\", c);\n\t\t}\n\t}\n\telse {\n\t\tstrcpy(format, \" %9u\");\n\t}\n\n\tcprintf_in(IS_INT, format, \"\", plist->pid);\n}\n\n/*\n ***************************************************************************\n * Display timestamp, PID and TID.\n *\n * IN:\n * @timestamp\tCurrent timestamp.\n * @plist\tPointer on the linked list where PID is saved.\n ***************************************************************************\n */\nvoid print_line_id(char *timestamp, struct st_pid *plist)\n{\n\tprintf(\"%-11s\", timestamp);\n\t__print_line_id(plist, '-');\n}\n\n/*\n * **************************************************************************\n * Display UID/username, PID and TID in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @plist\tPointer on the linked list where PID is saved.\n ***************************************************************************\n */\nvoid print_json_line_id(int tab, struct st_pid *plist)\n{\n\tchar format[32];\n\tstruct passwd *pwdent;\n\n\txprintf0(tab, \"{\\\"\");\n\n\tif (DISPLAY_USERNAME(pidflag)) {\n\t\tprintf(\"USER\");\n\t}\n\telse {\n\t\tprintf(\"UID\");\n\t}\n\tprintf(\"\\\": \\\"\");\n\n\tif (DISPLAY_USERNAME(pidflag) && ((pwdent = __getpwuid(plist->uid)) != NULL)) {\n\t\tprintf(\"%s\", pwdent->pw_name);\n\t}\n\telse {\n\t\tprintf(\"%d\", plist->uid);\n\t}\n\tprintf(\"\\\", \\\"\");\n\n\tif (DISPLAY_TID(pidflag)) {\n\t\tprintf(\"TGID\");\n\t}\n\telse {\n\t\tprintf(\"PID\");\n\t}\n\tprintf(\"\\\": \\\"\");\n\n\tstrcpy(format, \"%u\");\n\tif (DISPLAY_TID(pidflag)) {\n\t\tif (plist->tgid) {\n\t\t\t/* This is a TID */\n\t\t\tprintf(\"%u\\\", \\\"TID\\\": \\\"\", plist->tgid->pid);\n\t\t}\n\t\telse {\n\t\t\t/* This is a PID (TGID) */\n\t\t\tstrcpy(format, \"%u\\\", \\\"TID\\\": \\\"\");\n\t\t}\n\t}\n\n\tprintf(format, plist->pid);\n\tprintf(\"\\\", \");\n}\n\n/*\n * **************************************************************************\n * Display CPU statistics data for current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @pstc\tPointer on current statistics data sample for current process.\n * @pstp\tPointer on previous statistics data sampe for current process.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n ***************************************************************************\n */\nvoid write_plain_pid_task_cpu_data(int disp_avg,\n\t\t\t\t   struct pid_stats *pstc, struct pid_stats *pstp,\n\t\t\t\t   unsigned long long itv,\n\t\t\t\t   unsigned long long deltot_jiffies)\n{\n\tcprintf_xpc(DISPLAY_UNIT(pidflag), XHIGH, 5, 7, 2,\n\t\t    (pstc->utime - pstc->gtime) < (pstp->utime - pstp->gtime) ||\n\t\t    (pstc->utime < pstc->gtime) || (pstp->utime < pstp->gtime) ?\n\t\t    0.0 :\n\t\t    SP_VALUE(pstp->utime - pstp->gtime,\n\t\t\t     pstc->utime - pstc->gtime, itv * HZ / 100),\n\t\t    SP_VALUE(pstp->stime, pstc->stime, itv * HZ / 100),\n\t\t    SP_VALUE(pstp->gtime, pstc->gtime, itv * HZ / 100),\n\t\t    SP_VALUE(pstp->wtime, pstc->wtime, itv * HZ / 100),\n\t\t    /* User time already includes guest time */\n\t\t    IRIX_MODE_OFF(pidflag) ?\n\t\t    SP_VALUE(pstp->utime + pstp->stime,\n\t\t\t     pstc->utime + pstc->stime, deltot_jiffies) :\n\t\t\t     SP_VALUE(pstp->utime + pstp->stime,\n\t\t\t\t      pstc->utime + pstc->stime, itv * HZ / 100));\n\n\tif (!disp_avg) {\n\t\tcprintf_in(IS_INT, \"   %3d\", \"\", pstc->processor);\n\t}\n\telse {\n\t\tcprintf_in(IS_STR, \"%s\", \"     -\", 0);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display memory statistics data for current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @plist\tPointer on current process in list.\n * @pstc\tPointer on current statistics data sample for current process.\n * @pstp\tPointer on previous statistics data sampe for current process.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid write_plain_pid_task_memory_data(int disp_avg, struct st_pid *plist,\n\t\t\t\t      struct pid_stats *pstc, struct pid_stats *pstp,\n\t\t\t\t      unsigned long long itv)\n{\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t  S_VALUE(pstp->minflt, pstc->minflt, itv),\n\t\t  S_VALUE(pstp->majflt, pstc->majflt, itv));\n\n\tif (disp_avg) {\n\t\tcprintf_f(DISPLAY_UNIT(pidflag) ? UNIT_KILOBYTE : NO_UNIT, FALSE, 2, 7, 0,\n\t\t\t  (double) plist->total_vsz / plist->rt_asum_count,\n\t\t\t  (double) plist->total_rss / plist->rt_asum_count);\n\n\t\tcprintf_xpc(DISPLAY_UNIT(pidflag), XHIGH, 1, 6, 2,\n\t\t\t    tlmkb ?\n\t\t\t    SP_VALUE(0, plist->total_rss / plist->rt_asum_count, tlmkb)\n\t\t\t    : 0.0);\n\t}\n\telse {\n\t\tcprintf_u64(DISPLAY_UNIT(pidflag) ? UNIT_KILOBYTE : NO_UNIT, 2, 7,\n\t\t\t    (unsigned long long) pstc->vsz,\n\t\t\t    (unsigned long long) pstc->rss);\n\n\t\tcprintf_xpc(DISPLAY_UNIT(pidflag), XHIGH, 1, 6, 2,\n\t\t\t    tlmkb ? SP_VALUE(0, pstc->rss, tlmkb) : 0.0);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display stack size statistics data for current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @plist\tPointer on current process in list.\n * @pstc\tPointer on current statistics data sample for current process.\n ***************************************************************************\n */\nvoid write_plain_pid_stack_data(int disp_avg, struct st_pid *plist,\n\t\t\t\tstruct pid_stats *pstc)\n{\n\tif (disp_avg) {\n\t\tcprintf_f(DISPLAY_UNIT(pidflag) ? UNIT_KILOBYTE : NO_UNIT, FALSE, 2, 7, 0,\n\t\t\t  (double) plist->total_stack_size / plist->sk_asum_count,\n\t\t\t  (double) plist->total_stack_ref  / plist->sk_asum_count);\n\t}\n\telse {\n\t\tcprintf_u64(DISPLAY_UNIT(pidflag) ? UNIT_KILOBYTE : NO_UNIT, 2, 7,\n\t\t\t    (unsigned long long) pstc->stack_size,\n\t\t\t    (unsigned long long) pstc->stack_ref);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display I/O statistics data for current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @plist\tPointer on current process in list.\n * @pstc\tPointer on current statistics data sample for current process.\n * @pstp\tPointer on previous statistics data sampe for current process.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid write_plain_pid_io_data(int disp_avg, struct st_pid *plist,\n\t\t\t     struct pid_stats *pstc, struct pid_stats *pstp,\n\t\t\t     unsigned long long itv)\n{\n\tchar dstr[32];\n\tdouble rbytes, wbytes, cbytes;\n\n\tif (!NO_PID_IO(plist->flags)) {\n\t\trbytes = S_VALUE(pstp->read_bytes,  pstc->read_bytes, itv);\n\t\twbytes = S_VALUE(pstp->write_bytes, pstc->write_bytes, itv);\n\t\tcbytes = S_VALUE(pstp->cancelled_write_bytes,\n\t\t\t\t pstc->cancelled_write_bytes, itv);\n\t\tif (!DISPLAY_UNIT(pidflag)) {\n\t\t\trbytes /= 1024;\n\t\t\twbytes /= 1024;\n\t\t\tcbytes /= 1024;\n\t\t}\n\t\tcprintf_f(DISPLAY_UNIT(pidflag) ? UNIT_BYTE : NO_UNIT, FALSE, 3, 9, 2,\n\t\t\t  rbytes, wbytes, cbytes);\n\t}\n\telse {\n\t\t/* I/O file not readable (permission denied or file non existent) */\n\t\tsprintf(dstr, \" %9.2f %9.2f %9.2f\", -1.0, -1.0, -1.0);\n\t\tcprintf_s(IS_ZERO, \"%s\", dstr);\n\t}\n\t/* I/O delays come from another file (/proc/#/stat) */\n\tif (disp_avg) {\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 7, 0,\n\t\t\t  (double) (pstc->blkio_swapin_delays - pstp->blkio_swapin_delays) /\n\t\t\t  plist->delay_asum_count);\n\t}\n\telse {\n\t\tcprintf_u64(NO_UNIT, 1, 7,\n\t\t\t    (unsigned long long) (pstc->blkio_swapin_delays - pstp->blkio_swapin_delays));\n\t}\n}\n\n/*\n * **************************************************************************\n * Display context switches statistics data for current task.\n *\n * IN:\n * @pstc\tPointer on current statistics data sample for current process.\n * @pstp\tPointer on previous statistics data sampe for current process.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid write_plain_pid_ctxswitch_data(struct pid_stats *pstc, struct pid_stats *pstp,\n\t\t\t\t    unsigned long long itv)\n{\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t  S_VALUE(pstp->nvcsw,  pstc->nvcsw,  itv),\n\t\t  S_VALUE(pstp->nivcsw, pstc->nivcsw, itv));\n}\n\n/*\n * **************************************************************************\n * Display some kernel tables values for current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @plist\tPointer on current process in list.\n * @pstc\tPointer on current statistics data sample for current process.\n ***************************************************************************\n */\nvoid write_plain_pid_ktab_data(int disp_avg, struct st_pid *plist,\n\t\t\t       struct pid_stats *pstc)\n{\n\tif (disp_avg) {\n\t\tcprintf_f(NO_UNIT, FALSE, 2, 7, 0,\n\t\t\t  (double) plist->total_threads / plist->tf_asum_count,\n\t\t\t  NO_PID_FD(plist->flags) ?\n\t\t\t  -1.0 :\n\t\t\t  (double) plist->total_fd_nr / plist->tf_asum_count);\n\t}\n\telse {\n\t\tcprintf_u64(NO_UNIT, 1, 7,\n\t\t\t    (unsigned long long) pstc->threads);\n\t\tif (NO_PID_FD(plist->flags)) {\n\t\t\t/* /proc/#/fd directory not readable */\n\t\t\tcprintf_s(IS_ZERO, \" %7s\", \"-1\");\n\t\t}\n\t\telse {\n\t\t\tcprintf_u64(NO_UNIT, 1, 7,\n\t\t\t\t    (unsigned long long) pstc->fd_nr);\n\t\t}\n\t}\n}\n\n/*\n * **************************************************************************\n * Display scheduling priority and policy information for current task.\n *\n * IN:\n * @pstc\tPointer on current statistics data sample for current process.\n ***************************************************************************\n */\nvoid write_plain_pid_rt_data(struct pid_stats *pstc)\n{\n\tcprintf_u64(NO_UNIT, 1, 4,\n\t\t    (unsigned long long) pstc->priority);\n\tcprintf_s(IS_STR, \" %6s\", GET_POLICY(pstc->policy));\n}\n\n/*\n ***************************************************************************\n * Display all statistics for tasks in one line format.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample.\n * @itv\t\tInterval of time in jiffies.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_task_all_stats(int prev, int curr, int dis,\n\t\t\t     char *prev_string, char *curr_string,\n\t\t\t     unsigned long long itv,\n\t\t\t     unsigned long long deltot_jiffies)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tif (DISPLAY_CPU(actflag)) {\n\t\t\tprintf(\"    %%usr %%system  %%guest   %%wait    %%CPU   CPU\");\n\t\t}\n\t\tif (DISPLAY_MEM(actflag)) {\n\t\t\tprintf(\"  minflt/s  majflt/s     VSZ     RSS   %%MEM\");\n\t\t}\n\t\tif (DISPLAY_STACK(actflag)) {\n\t\t\tprintf(\" StkSize  StkRef\");\n\t\t}\n\t\tif (DISPLAY_IO(actflag)) {\n\t\t\tprintf(\"   kB_rd/s   kB_wr/s kB_ccwr/s iodelay\");\n\t\t}\n\t\tif (DISPLAY_CTXSW(actflag)) {\n\t\t\tprintf(\"   cswch/s nvcswch/s\");\n\t\t}\n\t\tif (DISPLAY_KTAB(actflag)) {\n\t\t\tprintf(\" threads   fd-nr\");\n\t\t}\n\t\tif (DISPLAY_RT(actflag)) {\n\t\t\tprintf(\" prio policy\");\n\t\t}\n\t\tprintf(\"  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, actflag, P_TASK, plist) <= 0)\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tif (DISPLAY_CPU(actflag)) {\n\t\t\twrite_plain_pid_task_cpu_data(FALSE, pstc, pstp, itv,\n\t\t\t\t\t\t      deltot_jiffies);\n\t\t}\n\n\t\tif (DISPLAY_MEM(actflag)) {\n\t\t\twrite_plain_pid_task_memory_data(FALSE, plist,\n\t\t\t\t\t\t\t pstc, pstp, itv);\n\t\t}\n\n\t\tif (DISPLAY_STACK(actflag)) {\n\t\t\twrite_plain_pid_stack_data(FALSE, plist, pstc);\n\t\t}\n\n\t\tif (DISPLAY_IO(actflag)) {\n\t\t\twrite_plain_pid_io_data(FALSE, plist, pstc, pstp, itv);\n\t\t}\n\n\t\tif (DISPLAY_CTXSW(actflag)) {\n\t\t\twrite_plain_pid_ctxswitch_data(pstc, pstp, itv);\n\t\t}\n\n\t\tif (DISPLAY_KTAB(actflag)) {\n\t\t\twrite_plain_pid_ktab_data(FALSE, plist, pstc);\n\t\t}\n\n\t\tif (DISPLAY_RT(actflag)) {\n\t\t\twrite_plain_pid_rt_data(pstc);\n\t\t}\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display CPU statistics for the children of current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @plist\tPointer on current process in list.\n * @pstc\tPointer on current statistics data sample for current process.\n * @pstp\tPointer on previous statistics data sampe for current process.\n ***************************************************************************\n */\nvoid write_plain_pid_child_cpu_data(int disp_avg, struct st_pid *plist,\n\t\t\t\t    struct pid_stats *pstc, struct pid_stats *pstp)\n{\n\tif (disp_avg) {\n\t\tcprintf_f(NO_UNIT, FALSE, 3, 9, 0,\n\t\t\t  (pstc->utime + pstc->cutime - pstc->gtime - pstc->cgtime) <\n\t\t\t  (pstp->utime + pstp->cutime - pstp->gtime - pstp->cgtime) ||\n\t\t\t  (pstc->utime + pstc->cutime < pstc->gtime + pstc->cgtime) ||\n\t\t\t  (pstp->utime + pstp->cutime < pstp->gtime + pstp->cgtime) ?\n\t\t\t  0.0 :\n\t\t\t  (double) ((pstc->utime + pstc->cutime - pstc->gtime - pstc->cgtime) -\n\t\t\t\t    (pstp->utime + pstp->cutime - pstp->gtime - pstp->cgtime)) /\n\t\t\t\t   (HZ * plist->uc_asum_count) * 1000,\n\t\t\t  (double) ((pstc->stime + pstc->cstime) -\n\t\t\t\t    (pstp->stime + pstp->cstime)) /\n\t\t\t\t   (HZ * plist->uc_asum_count) * 1000,\n\t\t\t  (double) ((pstc->gtime + pstc->cgtime) -\n\t\t\t\t    (pstp->gtime + pstp->cgtime)) /\n\t\t\t\t   (HZ * plist->uc_asum_count) * 1000);\n\t}\n\telse {\n\t\tcprintf_f(NO_UNIT, FALSE, 3, 9, 0,\n\t\t\t  (pstc->utime + pstc->cutime - pstc->gtime - pstc->cgtime) <\n\t\t\t  (pstp->utime + pstp->cutime - pstp->gtime - pstp->cgtime) ||\n\t\t\t  (pstc->utime + pstc->cutime < pstc->gtime + pstc->cgtime) ||\n\t\t\t  (pstp->utime + pstp->cutime < pstp->gtime + pstp->cgtime) ?\n\t\t\t  0.0 :\n\t\t\t  (double) ((pstc->utime + pstc->cutime - pstc->gtime - pstc->cgtime) -\n\t\t\t\t    (pstp->utime + pstp->cutime - pstp->gtime - pstp->cgtime)) /\n\t\t\t\t   HZ * 1000,\n\t\t\t  (double) ((pstc->stime + pstc->cstime) -\n\t\t\t\t    (pstp->stime + pstp->cstime)) / HZ * 1000,\n\t\t\t  (double) ((pstc->gtime + pstc->cgtime) -\n\t\t\t\t    (pstp->gtime + pstp->cgtime)) / HZ * 1000);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display memory statistics for the children of current task.\n *\n * IN:\n * @disp_avg\tTRUE if average stats are displayed.\n * @plist\tPointer on current process in list.\n * @pstc\tPointer on current statistics data sample for current process.\n * @pstp\tPointer on previous statistics data sampe for current process.\n ***************************************************************************\n */\nvoid write_plain_pid_child_memory_data(int disp_avg, struct st_pid *plist,\n\t\t\t\t       struct pid_stats *pstc, struct pid_stats *pstp)\n{\n\tif (disp_avg) {\n\t\tcprintf_f(NO_UNIT, FALSE, 2, 9, 0,\n\t\t\t  (double) ((pstc->minflt + pstc->cminflt) -\n\t\t\t\t    (pstp->minflt + pstp->cminflt)) / plist->rc_asum_count,\n\t\t\t  (double) ((pstc->majflt + pstc->cmajflt) -\n\t\t\t\t    (pstp->majflt + pstp->cmajflt)) / plist->rc_asum_count);\n\t}\n\telse {\n\t\tcprintf_u64(NO_UNIT, 2, 9,\n\t\t\t    (unsigned long long) ((pstc->minflt + pstc->cminflt) - (pstp->minflt + pstp->cminflt)),\n\t\t\t    (unsigned long long) ((pstc->majflt + pstc->cmajflt) - (pstp->majflt + pstp->cmajflt)));\n\t}\n}\n\n/*\n ***************************************************************************\n * Display all statistics for tasks' children in one line format.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_child_all_stats(int prev, int curr, int dis,\n\t\t\t      char *prev_string, char *curr_string)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tif (DISPLAY_CPU(actflag))\n\t\t\tprintf(\"    usr-ms system-ms  guest-ms\");\n\t\tif (DISPLAY_MEM(actflag))\n\t\t\tprintf(\" minflt-nr majflt-nr\");\n\t\tprintf(\"  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, actflag, P_CHILD, plist) <= 0)\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tif (DISPLAY_CPU(actflag)) {\n\t\t\twrite_plain_pid_child_cpu_data(FALSE, plist, pstc, pstp);\n\t\t}\n\n\t\tif (DISPLAY_MEM(actflag)) {\n\t\t\twrite_plain_pid_child_memory_data(FALSE, plist, pstc, pstp);\n\t\t}\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_task_cpu_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\t   char *prev_string, char *curr_string,\n\t\t\t\t   unsigned long long itv,\n\t\t\t\t   unsigned long long deltot_jiffies)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\"    %%usr %%system  %%guest   %%wait    %%CPU   CPU  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, P_A_CPU, P_TASK, plist) <= 0)\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\t/* Write current process data */\n\t\twrite_plain_pid_task_cpu_data(disp_avg, pstc, pstp, itv,\n\t\t\t\t\t      deltot_jiffies);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display CPU statistics for tasks.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_task_cpu_stats(int tab, int prev, int curr, unsigned long long itv,\n\t\t\t\t  unsigned long long deltot_jiffies, int *follow)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"task-cpu-load\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, P_A_CPU, P_TASK, plist) <= 0)\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tprintf(\"\\\"usr\\\": %.2f, \\\"system\\\": %.2f, \\\"guest\\\": %.2f, \\\"wait\\\": %.2f, \"\n\t\t       \"\\\"cpu\\\": %.2f, \\\"cpu_nr\\\": %d, \",\n\t\t       (pstc->utime - pstc->gtime) < (pstp->utime - pstp->gtime) ||\n\t\t       (pstc->utime < pstc->gtime) || (pstp->utime < pstp->gtime) ?\n\t\t       0.0 :\n\t\t       SP_VALUE(pstp->utime - pstp->gtime,\n\t\t\t\tpstc->utime - pstc->gtime, itv * HZ / 100),\n\t\t       SP_VALUE(pstp->stime, pstc->stime, itv * HZ / 100),\n\t\t       SP_VALUE(pstp->gtime, pstc->gtime, itv * HZ / 100),\n\t\t       SP_VALUE(pstp->wtime, pstc->wtime, itv * HZ / 100),\n\t\t       /* User time already includes guest time */\n\t\t       IRIX_MODE_OFF(pidflag) ?\n\t\t       SP_VALUE(pstp->utime + pstp->stime,\n\t\t\t\tpstc->utime + pstc->stime, deltot_jiffies) :\n\t\t       SP_VALUE(pstp->utime + pstp->stime,\n\t\t\t\t pstc->utime + pstc->stime, itv * HZ / 100),\n\t\t       pstc->processor);\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display CPU statistics for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @deltot_jiffies\n *\t\tNumber of jiffies spent on the interval by all processors.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_task_cpu_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t     char *prev_string, char *curr_string,\n\t\t\t     unsigned long long itv,\n\t\t\t     unsigned long long deltot_jiffies, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_task_cpu_stats(tab, prev, curr, itv,\n\t\t\t\t\t\t     deltot_jiffies, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_task_cpu_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t      prev_string, curr_string, itv,\n\t\t\t\t\t\t      deltot_jiffies);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics for tasks' children.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_child_cpu_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\t    char *prev_string, char *curr_string)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\"    usr-ms system-ms  guest-ms  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_CPU, P_CHILD, plist)) == 0)\n\t\t\t/* PID no longer exists */\n\t\t\tcontinue;\n\n\t\t/* This will be used to compute average */\n\t\tif (!disp_avg) {\n\t\t\tplist->uc_asum_count += 1;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\t/* PID should not be displayed */\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\t/* Write data for children of current task */\n\t\twrite_plain_pid_child_cpu_data(disp_avg, plist, pstc, pstp);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display CPU statistics for tasks' children in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_child_cpu_stats(int tab, int prev, int curr, int *follow)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"child-cpu-load\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_CPU, P_CHILD, plist)) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tprintf(\"\\\"usr-ms\\\": %.0f, \\\"system-ms\\\": %.0f, \\\"guest-ms\\\": %.0f, \",\n\t\t       (pstc->utime + pstc->cutime - pstc->gtime - pstc->cgtime) <\n\t\t       (pstp->utime + pstp->cutime - pstp->gtime - pstp->cgtime) ||\n\t\t       (pstc->utime + pstc->cutime < pstc->gtime + pstc->cgtime) ||\n\t\t       (pstp->utime + pstp->cutime < pstp->gtime + pstp->cgtime) ?\n\t\t       0.0 :\n\t\t       (double) ((pstc->utime + pstc->cutime - pstc->gtime - pstc->cgtime) -\n\t\t       (pstp->utime + pstp->cutime - pstp->gtime - pstp->cgtime)) /\n\t\t       HZ * 1000,\n\t\t       (double) ((pstc->stime + pstc->cstime) -\n\t\t\t\t (pstp->stime + pstp->cstime)) / HZ * 1000,\n\t\t       (double) ((pstc->gtime + pstc->cgtime) -\n\t\t\t\t (pstp->gtime + pstp->cgtime)) / HZ * 1000);\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display CPU statistics for tasks' children.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_child_cpu_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t      char *prev_string, char *curr_string, int tab,\n\t\t\t      int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_child_cpu_stats(tab, prev, curr, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_child_cpu_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t       prev_string, curr_string);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display memory statistics for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_task_memory_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\t      char *prev_string, char *curr_string,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\"  minflt/s  majflt/s     VSZ     RSS   %%MEM  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_MEM, P_TASK, plist)) == 0)\n\t\t\t/* PID no longer exists */\n\t\t\tcontinue;\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\t/* This will be used to compute average */\n\t\tif (!disp_avg) {\n\t\t\tplist->total_vsz += pstc->vsz;\n\t\t\tplist->total_rss += pstc->rss;\n\t\t\tplist->rt_asum_count += 1;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\t/* PID should not be displayed */\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\t/* Write current process data */\n\t\twrite_plain_pid_task_memory_data(disp_avg, plist,\n\t\t\t\t\t\t pstc, pstp, itv);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display memory statistics for tasks in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_task_memory_stats(int tab, int prev, int curr,\n\t\t\t\t     unsigned long long itv, int *follow)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"task-memory\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_MEM, P_TASK, plist)) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tprintf(\"\\\"minflt/s\\\": %.2f, \\\"majflt/s\\\": %.2f, \"\n\t\t       \"\\\"VSZ\\\": %llu, \\\"RSS\\\": %llu, \\\"MEM\\\": %.2f, \",\n\t\t       S_VALUE(pstp->minflt, pstc->minflt, itv),\n\t\t       S_VALUE(pstp->majflt, pstc->majflt, itv),\n\t\t       (unsigned long long) pstc->vsz,\n\t\t       (unsigned long long) pstc->rss,\n\t\t       tlmkb ? SP_VALUE(0, pstc->rss, tlmkb) : 0.0);\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display memory statistics for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_task_memory_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\tchar *prev_string, char *curr_string,\n\t\t\t\tunsigned long long itv, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_task_memory_stats(tab, prev, curr,\n\t\t\t\t\t\t\titv, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_task_memory_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t\t prev_string, curr_string, itv);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display memory statistics for tasks' children.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_child_memory_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\t       char *prev_string, char *curr_string)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\" minflt-nr majflt-nr  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_MEM, P_CHILD, plist)) == 0)\n\t\t\t/* PID no longer exists */\n\t\t\tcontinue;\n\n\t\t/* This will be used to compute average */\n\t\tif (!disp_avg) {\n\t\t\tplist->rc_asum_count += 1;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\t/* PID should not be displayed */\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\t/* Write data for current task */\n\t\twrite_plain_pid_child_memory_data(disp_avg, plist, pstc, pstp);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display memory statistics for tasks' children in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_child_memory_stats(int tab, int prev, int curr, int *follow)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"child-memory\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_MEM, P_CHILD, plist)) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tprintf(\"\\\"minflt-nr\\\": %llu, \\\"majflt-nr\\\": %llu, \",\n\t\t       (unsigned long long) ((pstc->minflt + pstc->cminflt) - (pstp->minflt + pstp->cminflt)),\n\t\t       (unsigned long long) ((pstc->majflt + pstc->cmajflt) - (pstp->majflt + pstp->cmajflt)));\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display memory statistics for tasks' children.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_child_memory_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\t char *prev_string, char *curr_string, int tab,\n\t\t\t\t int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_child_memory_stats(tab, prev, curr, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_child_memory_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t\t  prev_string, curr_string);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display stack size statistics for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_stack_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t\tchar *prev_string, char *curr_string)\n{\n\tstruct pid_stats *pstc;\n\tstruct st_pid *plist;\n\tint rc, again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\" StkSize  StkRef  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_STACK, P_NULL, plist)) == 0)\n\t\t\t/* PID no longer exists */\n\t\t\tcontinue;\n\n\t\tpstc = plist->pstats[curr];\n\n\t\t/* This will be used to compute average */\n\t\tif (!disp_avg) {\n\t\t\tplist->total_stack_size += pstc->stack_size;\n\t\t\tplist->total_stack_ref  += pstc->stack_ref;\n\t\t\tplist->sk_asum_count += 1;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\t/* PID should not be displayed */\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\t/* Write current process data */\n\t\twrite_plain_pid_stack_data(disp_avg, plist, pstc);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display stack size statistics for tasks in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_stack_stats(int tab, int prev, int curr, int *follow)\n{\n\tstruct pid_stats *pstc;\n\tstruct st_pid *plist;\n\tint rc, again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"stack\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_STACK, P_NULL, plist)) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\n\t\tprintf(\"\\\"StkSize\\\": %llu, \\\"StkRef\\\": %llu, \",\n\t\t       (unsigned long long) pstc->stack_size,\n\t\t       (unsigned long long) pstc->stack_ref);\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display stack size statistics for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_stack_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t  char *prev_string, char *curr_string, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_stack_stats(tab, prev, curr, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_stack_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t   prev_string, curr_string);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display I/O statistics.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_io_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t     char *prev_string, char *curr_string,\n\t\t\t     unsigned long long itv)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\"   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_IO, P_NULL, plist)) == 0)\n\t\t\t/* PID no longer exists */\n\t\t\tcontinue;\n\n\t\t/* This will be used to compute average delays */\n\t\tif (!disp_avg) {\n\t\t\tplist->delay_asum_count += 1;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\t/* PID should not be displayed */\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\t/* Write statistics for current task */\n\t\twrite_plain_pid_io_data(disp_avg, plist, pstc, pstp, itv);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display I/O statistics in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_io_stats(int tab, int prev, int curr, unsigned long long itv,\n\t\t\t    int *follow)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint rc, again = 0,  next = FALSE;\n\tdouble rbytes, wbytes, cbytes;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"io\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_IO, P_NULL, plist)) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tif (!NO_PID_IO(plist->flags)) {\n\t\t\trbytes = S_VALUE(pstp->read_bytes,  pstc->read_bytes, itv);\n\t\t\twbytes = S_VALUE(pstp->write_bytes, pstc->write_bytes, itv);\n\t\t\tcbytes = S_VALUE(pstp->cancelled_write_bytes,\n\t\t\t\t\t pstc->cancelled_write_bytes, itv);\n\t\t\tprintf(\"\\\"kB_rd/s\\\": %.2f, \\\"kB_wr/s\\\": %.2f, \\\"kB_ccwr/s\\\": %.2f, \",\n\t\t\t       rbytes / 1024,\n\t\t\t       wbytes / 1024,\n\t\t\t       cbytes / 1024);\n\t\t}\n\t\telse {\n\t\t\t/* I/O file not readable (permission denied or file non existent) */\n\t\t\tprintf(\"\\\"kB_rd/s\\\": -1.00, \\\"kB_wr/s\\\": -1.00, \\\"kB_ccwr/s\\\": -1.00, \");\n\t\t}\n\t\t/* I/O delays come from another file (/proc/#/stat) */\n\t\tprintf(\"\\\"iodelay\\\": %llu, \",\n\t\t       (unsigned long long) (pstc->blkio_swapin_delays - pstp->blkio_swapin_delays));\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display I/O statistics.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_io_stats(int prev, int curr, int dis, int disp_avg,\n\t\t       char *prev_string, char *curr_string,\n\t\t       unsigned long long itv, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_io_stats(tab, prev, curr, itv, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_io_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\tprev_string, curr_string, itv);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display context switches statistics.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_ctxswitch_stats(int prev, int curr, int dis,\n\t\t\t\t    char *prev_string, char *curr_string,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct pid_stats *pstc, *pstp;\n\n\tstruct st_pid *plist;\n\tint again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\"   cswch/s nvcswch/s  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, P_A_CTXSW, P_NULL, plist) <= 0)\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\t/* Write statistics for current task */\n\t\twrite_plain_pid_ctxswitch_data(pstc, pstp, itv);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display context switches statistics in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_ctxswitch_stats(int tab, int prev, int curr,\n\t\t\t\t   unsigned long long itv, int *follow)\n{\n\tstruct pid_stats *pstc, *pstp;\n\tstruct st_pid *plist;\n\tint again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"context-switch\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, P_A_CTXSW, P_NULL, plist) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\t\tpstp = plist->pstats[prev];\n\n\t\tprintf(\"\\\"cswch/s\\\": %.2f, \\\"nvcswch/s\\\": %.2f, \",\n\t\t       S_VALUE(pstp->nvcsw,  pstc->nvcsw,  itv),\n\t\t       S_VALUE(pstp->nivcsw, pstc->nivcsw, itv));\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display context switches statistics.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_ctxswitch_stats(int prev, int curr, int dis,\n\t\t\t      char *prev_string, char *curr_string,\n\t\t\t      unsigned long long itv, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_ctxswitch_stats(tab, prev, curr, itv, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_ctxswitch_stats(prev, curr, dis,\n\t\t\t\t\t\t       prev_string, curr_string, itv);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display some kernel tables values for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_ktab_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t       char *prev_string, char *curr_string)\n{\n\tstruct pid_stats *pstc;\n\tstruct st_pid *plist;\n\tint rc, again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\" threads   fd-nr\");\n\t\tprintf(\"  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_KTAB, P_NULL, plist)) == 0)\n\t\t\t/* PID no longer exists */\n\t\t\tcontinue;\n\n\t\tpstc = plist->pstats[curr];\n\n\t\t/* This will be used to compute average */\n\t\tif (!disp_avg) {\n\t\t\tplist->total_threads += pstc->threads;\n\t\t\tplist->total_fd_nr   += pstc->fd_nr;\n\t\t\tplist->tf_asum_count += 1;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\t/* PID should not be displayed */\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\t/* Write data for current task */\n\t\twrite_plain_pid_ktab_data(disp_avg, plist, pstc);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display some kernel tables values for tasks in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_ktab_stats(int tab, int prev, int curr, int *follow)\n{\n\tstruct pid_stats *pstc;\n\tstruct st_pid *plist;\n\tint rc, again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"kernel\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif ((rc = get_pid_to_display(prev, curr, P_A_KTAB, P_NULL, plist)) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\n\t\tprintf(\"\\\"threads\\\": %llu, \\\"fd-nr\\\": \",\n\t\t       (unsigned long long) pstc->threads);\n\t\tif (NO_PID_FD(plist->flags)) {\n\t\t\tprintf(\"-1, \");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%llu, \", (unsigned long long) pstc->fd_nr);\n\t\t}\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display some kernel tables values for tasks.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_ktab_stats(int prev, int curr, int dis, int disp_avg,\n\t\t\t char *prev_string, char *curr_string, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_ktab_stats(tab, prev, curr, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_ktab_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t  prev_string, curr_string);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display scheduling priority and policy information.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_plain_pid_rt_stats(int prev, int curr, int dis,\n\t\t\t     char *prev_string, char *curr_string)\n{\n\tstruct pid_stats *pstc;\n\tstruct st_pid *plist;\n\tint again = 0;\n\n\tif (dis) {\n\t\tPRINT_ID_HDR(prev_string, pidflag);\n\t\tprintf(\" prio policy  Command\\n\");\n\t}\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, P_A_RT, P_NULL, plist) <= 0)\n\t\t\tcontinue;\n\n\t\tprint_line_id(curr_string, plist);\n\n\t\tpstc = plist->pstats[curr];\n\n\t\t/* Write data for current task */\n\t\twrite_plain_pid_rt_data(pstc);\n\n\t\tprint_comm(plist);\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display scheduling priority and policy information in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma.\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any).\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_json_pid_rt_stats(int tab, int prev, int curr, int *follow)\n{\n\tstruct pid_stats *pstc;\n\tstruct st_pid *plist;\n\tint again = 0, next = FALSE;\n\n\tif (*follow) {\n\t\tprintf(\",\\n\");\n\t}\n\txprintf(tab++, \"\\\"realtime\\\": [\");\n\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\n\t\tif (get_pid_to_display(prev, curr, P_A_RT, P_NULL, plist) <= 0)\n\t\t\t/* PID no longer exists or should not be displayed */\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\tnext = TRUE;\n\n\t\tprint_json_line_id(tab, plist);\n\n\t\tpstc = plist->pstats[curr];\n\n\t\tprintf(\"\\\"prio\\\": %llu, \\\"policy\\\": \\\"%s\\\", \",\n\t\t       (unsigned long long) pstc->priority,\n\t\t       GET_POLICY(pstc->policy));\n\n\t\tprint_json_comm(plist);\n\t\tagain = 1;\n\t}\n\n\tprintf(\"\\n\");\n\txprintf0(--tab, \"]\");\n\t*follow = TRUE;\n\n\treturn again;\n}\n\n/*\n * **************************************************************************\n * Display scheduling priority and policy information.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n * @tab\t\tNumber of tabs to print (JSON format only).\n * @follow\tTrue if a previous set of stats has been displayed and should\n *\t\tbe followed by a coma (JSON format only).\n *\n * OUT:\n * @follow\tSet to TRUE to indicate that a coma should be displayed\n *\t\tbefore next set of stats (if any). JSON format only.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_pid_rt_stats(int prev, int curr, int dis,\n\t\t       char *prev_string, char *curr_string, int tab, int *follow)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\treturn write_json_pid_rt_stats(tab, prev, curr, follow);\n\t}\n\telse {\n\t\treturn write_plain_pid_rt_stats(prev, curr, dis,\n\t\t\t\t\t\tprev_string, curr_string);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display statistics.\n *\n * IN:\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n * @disp_avg\tTRUE if average stats are displayed.\n * @prev_string\tString displayed at the beginning of a header line. This is\n * \t\tthe timestamp of the previous sample, or \"Average\" when\n * \t\tdisplaying average stats.\n * @curr_string\tString displayed at the beginning of current sample stats.\n * \t\tThis is the timestamp of the current sample, or \"Average\"\n * \t\twhen displaying average stats.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_stats_core(int prev, int curr, int dis, int disp_avg,\n\t\t     char *prev_string, char *curr_string)\n{\n\tunsigned long long itv, deltot_jiffies;\n\tint again = 0, tab = 4, follow = FALSE;\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\t/* Total number of jiffies spent on the interval */\n\tdeltot_jiffies = get_interval(tot_jiffies[prev], tot_jiffies[curr]);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf(tab++, \"{\");\n\t\txprintf(tab, \"\\\"timestamp\\\": \\\"%s\\\",\", curr_string);\n\t}\n\n\titv = get_interval(uptime_cs[prev], uptime_cs[curr]);\n\n\tif (DISPLAY_ONELINE(pidflag)) {\n\t\tif (DISPLAY_TASK_STATS(tskflag)) {\n\t\t\tagain += write_pid_task_all_stats(prev, curr, dis,\n\t\t\t\t\t\t\t  prev_string, curr_string,\n\t\t\t\t\t\t\t  itv, deltot_jiffies);\n\t\t}\n\t\tif (DISPLAY_CHILD_STATS(tskflag)) {\n\t\t\tagain += write_pid_child_all_stats(prev, curr, dis,\n\t\t\t\t\t\t\t   prev_string, curr_string);\n\t\t}\n\t}\n\telse {\n\t\t/* Display CPU stats */\n\t\tif (DISPLAY_CPU(actflag)) {\n\t\t\tif (DISPLAY_TASK_STATS(tskflag)) {\n\t\t\t\tagain += write_pid_task_cpu_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t\t\t  prev_string, curr_string,\n\t\t\t\t\t\t\t\t  itv, deltot_jiffies,\n\t\t\t\t\t\t\t\t  tab, &follow);\n\t\t\t}\n\t\t\tif (DISPLAY_CHILD_STATS(tskflag)) {\n\t\t\t\tagain += write_pid_child_cpu_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t\t\t   prev_string, curr_string,\n\t\t\t\t\t\t\t\t   tab, &follow);\n\t\t\t}\n\t\t}\n\n\t\t/* Display memory stats */\n\t\tif (DISPLAY_MEM(actflag)) {\n\t\t\tif (DISPLAY_TASK_STATS(tskflag)) {\n\t\t\t\tagain += write_pid_task_memory_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t\t\t     prev_string, curr_string,\n\t\t\t\t\t\t\t\t     itv, tab, &follow);\n\t\t\t}\n\t\t\tif (DISPLAY_CHILD_STATS(tskflag)) {\n\t\t\t\tagain += write_pid_child_memory_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t\t\t      prev_string, curr_string,\n\t\t\t\t\t\t\t\t      tab, &follow);\n\t\t\t}\n\t\t}\n\n\t\t/* Display stack stats */\n\t\tif (DISPLAY_STACK(actflag)) {\n\t\t\tagain += write_pid_stack_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t       prev_string, curr_string,\n\t\t\t\t\t\t       tab, &follow);\n\t\t}\n\n\t\t/* Display I/O stats */\n\t\tif (DISPLAY_IO(actflag)) {\n\t\t\tagain += write_pid_io_stats(prev, curr, dis, disp_avg, prev_string,\n\t\t\t\t\t\t    curr_string, itv, tab, &follow);\n\t\t}\n\n\t\t/* Display context switches stats */\n\t\tif (DISPLAY_CTXSW(actflag)) {\n\t\t\tagain += write_pid_ctxswitch_stats(prev, curr, dis, prev_string,\n\t\t\t\t\t\t\t   curr_string, itv,\n\t\t\t\t\t\t\t   tab, &follow);\n\t\t}\n\n\t\t/* Display kernel table stats */\n\t\tif (DISPLAY_KTAB(actflag)) {\n\t\t\tagain += write_pid_ktab_stats(prev, curr, dis, disp_avg,\n\t\t\t\t\t\t      prev_string, curr_string,\n\t\t\t\t\t\t      tab, &follow);\n\t\t}\n\n\t\t/* Display scheduling priority and policy information */\n\t\tif (DISPLAY_RT(actflag)) {\n\t\t\tagain += write_pid_rt_stats(prev, curr, dis, prev_string,\n\t\t\t\t\t\t    curr_string, tab, &follow);\n\t\t}\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\n\");\n\t\txprintf0(--tab, \"}\");\n\t}\n\n\tif (DISPLAY_ALL_PID(pidflag)) {\n\t\tagain = 1;\n\t}\n\n\treturn again;\n}\n\n/*\n ***************************************************************************\n * Print statistics average.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n ***************************************************************************\n */\nvoid write_stats_avg(int curr, int dis)\n{\n\tchar string[16];\n\n\tstrncpy(string, _(\"Average:\"), 16);\n\tstring[15] = '\\0';\n\twrite_stats_core(2, curr, dis, TRUE, string, string);\n}\n\n/*\n ***************************************************************************\n * Get previous and current timestamps, then display statistics.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @dis\t\tTRUE if a header line must be printed.\n *\n * RETURNS:\n * 0 if all the processes to display have terminated.\n * <> 0 if there are still some processes left to display.\n ***************************************************************************\n */\nint write_stats(int curr, int dis)\n{\n\tchar cur_time[2][TIMESTAMP_LEN];\n\n\t/* Get previous timestamp */\n\tif (DISPLAY_ONELINE(pidflag)) {\n\t\tstrcpy(cur_time[!curr], \"# Time     \");\n\t}\n\telse if (PRINT_SEC_EPOCH(pidflag)) {\n\t\tsnprintf(cur_time[!curr], sizeof(cur_time[!curr]), \"%ld\", mktime(&ps_tstamp[!curr]));\n\t\tcur_time[!curr][sizeof(cur_time[!curr]) - 1] = '\\0';\n\t}\n\telse if (is_iso_time_fmt()) {\n\t\tstrftime(cur_time[!curr], sizeof(cur_time[!curr]), \"%H:%M:%S\", &ps_tstamp[!curr]);\n\t}\n\telse {\n\t\tstrftime(cur_time[!curr], sizeof(cur_time[!curr]), \"%X\", &ps_tstamp[!curr]);\n\t}\n\n\t/* Get current timestamp */\n\tif (PRINT_SEC_EPOCH(pidflag)) {\n\t\tsnprintf(cur_time[curr], sizeof(cur_time[curr]), \"%ld\", mktime(&ps_tstamp[curr]));\n\t\tcur_time[curr][sizeof(cur_time[curr]) - 1] = '\\0';\n\t}\n\telse if (is_iso_time_fmt()) {\n\t\tstrftime(cur_time[curr], sizeof(cur_time[curr]), \"%H:%M:%S\", &ps_tstamp[curr]);\n\t}\n\telse {\n\t\tstrftime(cur_time[curr], sizeof(cur_time[curr]), \"%X\", &ps_tstamp[curr]);\n\t}\n\n\treturn (write_stats_core(!curr, curr, dis, FALSE,\n\t\t\t\t cur_time[!curr], cur_time[curr]));\n}\n\n/*\n ***************************************************************************\n * Main loop: Read and display PID stats.\n *\n * IN:\n * @dis_hdr\tSet to TRUE if the header line must always be printed.\n * @rows\tNumber of rows of screen.\n ***************************************************************************\n */\nvoid rw_pidstat_loop(int dis_hdr, int rows)\n{\n\tint curr = 1, dis = 1;\n\tint again;\n\tunsigned long lines = rows;\n\tstruct st_pid *plist;\n\n\t/* Read system uptime */\n\tread_uptime(&uptime_cs[0]);\n\tread_stats(0);\n\n\tif (DISPLAY_MEM(actflag)) {\n\t\t/* Get total memory */\n\t\tread_proc_meminfo();\n\t}\n\n\tif (!interval && !EXEC_PGM(pidflag)) {\n\t\t/* Display since boot time */\n\t\tps_tstamp[1] = ps_tstamp[0];\n\t\twrite_stats(0, DISP_HDR);\n\t\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tgoto terminate;\n\t}\n\n\t/* Set a handler for SIGALRM */\n\tmemset(&alrm_act, 0, sizeof(alrm_act));\n\talrm_act.sa_handler = alarm_handler;\n\tsigaction(SIGALRM, &alrm_act, NULL);\n\tif (interval) {\n\t\talarm(interval);\n\t}\n\n\t/* Save the first stats collected. Will be used to compute the average */\n\tps_tstamp[2] = ps_tstamp[0];\n\ttot_jiffies[2] = tot_jiffies[0];\n\tuptime_cs[2] = uptime_cs[0];\n\tfor (plist = pid_list; plist != NULL; plist = plist->next) {\n\t\tmemcpy(plist->pstats[2], plist->pstats[0], PID_STATS_SIZE);\n\t}\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\t/* Wait for SIGALRM (or possibly SIGINT) signal */\n\t__pause();\n\n\tif (signal_caught && interval)\n\t\t/* SIGINT/SIGCHLD signals caught during first interval: Exit immediately */\n\t\tgoto terminate;\n\n\tdo {\n\t\t/* Every PID is potentially nonexistent */\n\t\tset_pid_nonexistent(pid_list);\n\n\t\t/* Get time */\n\t\tget_xtime(&ps_tstamp[curr], 0, LOCAL_TIME);\n\n\t\t/* Read system uptime (in 1/100th of a second) */\n\t\tread_uptime(&(uptime_cs[curr]));\n\n\t\t/* Read stats */\n\t\tread_stats(curr);\n\n\t\tif (!dis_hdr) {\n\t\t\tdis = lines / rows;\n\t\t\tif (dis) {\n\t\t\t\tlines %= rows;\n\t\t\t}\n\t\t\tlines++;\n\t\t}\n\n\t\t/* Print results */\n\t\tagain = write_stats(curr, dis);\n\n\t\tif (!again)\n\t\t\treturn;\n\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count) {\n\n\t\t\t__pause();\n\n\t\t\tif (signal_caught) {\n\t\t\t\t/* SIGINT/SIGCHLD signals caught => Display average stats */\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\t\t\tprintf(\",\");\n\t\t\t\t}\n\t\t\t\tcurr ^= 1;\n\t\t\t}\n\t\t}\n\t\tif (signal_caught || DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\twhile (count);\n\n\t/*\n\t * The one line format uses a raw time value rather than time strings\n\t * so the average doesn't really fit.\n\t */\n\tif (!DISPLAY_ONELINE(pidflag) && !DISPLAY_JSON_OUTPUT(xflags))\n\t{\n\t\t/* Write stats average */\n\t\twrite_stats_avg(curr, dis_hdr);\n\t}\n\nterminate:\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}}\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Start a program that will be monitored by pidstat.\n *\n * IN:\n * @argc\tNumber of arguments.\n * @argv\tArguments values.\n *\n * RETURNS:\n * The PID of the program executed.\n ***************************************************************************\n */\npid_t exec_pgm(int argc, char **argv)\n{\n\tpid_t child;\n\tchar *args[argc + 1];\n\tint i;\n\n\tchild = __fork();\n\n\tswitch(child) {\n\n\t\tcase -1:\n\t\t\tperror(\"fork\");\n\t\t\texit(4);\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\t/* Child */\n\t\t\tfor (i = 0; i < argc; i++) {\n\t\t\t\targs[i] = argv[i];\n\t\t\t}\n\t\t\targs[argc] = NULL;\n\n\t\t\texecvp(args[0], args);\n\t\t\tperror(\"exec\");\n\t\t\texit(4);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Parent.\n\t\t\t * Set a handler for SIGCHLD (signal that will be received\n\t\t\t * by pidstat when the child program terminates).\n\t\t\t * The handler is the same as for SIGINT: Stop and display\n\t\t\t * average statistics.\n\t\t\t */\n\t\t\tmemset(&chld_act, 0, sizeof(chld_act));\n\t\t\tchld_act.sa_handler = int_handler;\n\t\t\tsigaction(SIGCHLD, &chld_act, NULL);\n\n\t\t\treturn child;\n\t}\n}\n\n/*\n ***************************************************************************\n * Main entry to the pidstat program.\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint opt = 1, dis_hdr = -1, pid_nr = 0;\n\tint i;\n\tunsigned int pid;\n\tstruct utsname header;\n\tint rows = 23;\n\tchar *t;\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\t/* Init color strings */\n\tinit_colors();\n\n\t/* Get HZ */\n\tget_HZ();\n\n\t/* Compute page shift in kB */\n\tget_kb_shift();\n\n\t/* Process args... */\n\twhile (opt < argc) {\n\n\t\tif (!strcmp(argv[opt], \"-e\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tpidflag |= P_D_PID + P_F_EXEC_PGM;\n\t\t\tadd_list_pid(&pid_list, exec_pgm(argc - opt, argv + opt), 0);\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-p\")) {\n\t\t\tpidflag |= P_D_PID;\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\n\t\t\tfor (t = strtok(argv[opt], \",\"); t; t = strtok(NULL, \",\"), pid_nr++) {\n\t\t\t\tif (!strcmp(t, K_ALL)) {\n\t\t\t\t\tpidflag |= P_D_ALL_PID;\n\t\t\t\t\tpid_nr++;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_SELF)) {\n\t\t\t\t\tadd_list_pid(&pid_list, getpid(), 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (strspn(t, DIGITS) != strlen(t)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpid = atoi(t);\n\t\t\t\t\tif (pid < 1) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\tadd_list_pid(&pid_list, pid, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-C\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tstrncpy(commstr, argv[opt++], sizeof(commstr));\n\t\t\tcommstr[sizeof(commstr) - 1] = '\\0';\n\t\t\tpidflag |= P_F_COMMSTR;\n\t\t\tif (!strlen(commstr)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-G\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tstrncpy(procstr, argv[opt++], sizeof(procstr));\n\t\t\tprocstr[sizeof(procstr) - 1] = '\\0';\n\t\t\tpidflag |= P_F_PROCSTR;\n\t\t\tif (!strlen(procstr)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--human\")) {\n\t\t\tpidflag |= P_D_UNIT;\n\t\t\topt++;\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t\topt++;\n\t\t}\n#endif\n\n\t\telse if (!strncmp(argv[opt], \"--dec=\", 6) && (strlen(argv[opt]) == 7)) {\n\t\t\t/* Check that the argument is a digit */\n\t\t\tif (!isdigit(argv[opt][6])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\n\t\t\t/* Get number of decimal places */\n\t\t\tdplaces_nr = atoi(argv[opt] + 6);\n\t\t\tif ((dplaces_nr < 0) || (dplaces_nr > 2)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-T\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (tskflag) {\n\t\t\t\tdis_hdr++;\n\t\t\t}\n\t\t\tif (!strcmp(argv[opt], K_P_TASK)) {\n\t\t\t\ttskflag |= P_TASK;\n\t\t\t}\n\t\t\telse if (!strcmp(argv[opt], K_P_CHILD)) {\n\t\t\t\ttskflag |= P_CHILD;\n\t\t\t}\n\t\t\telse if (!strcmp(argv[opt], K_P_ALL)) {\n\t\t\t\ttskflag |= P_TASK + P_CHILD;\n\t\t\t\tdis_hdr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\t/* Option used individually. See below for grouped option */\n\t\telse if (!strcmp(argv[opt], \"-U\")) {\n\t\t\t/* Display username instead of UID */\n\t\t\tpidflag |= P_D_USERNAME;\n\t\t\tif (argv[++opt] && (argv[opt][0] != '-') &&\n\t\t\t    (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tstrncpy(userstr, argv[opt++], sizeof(userstr));\n\t\t\t\tuserstr[sizeof(userstr) - 1] = '\\0';\n\t\t\t\tpidflag |= P_F_USERSTR;\n\t\t\t\tif (!strlen(userstr)) {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\t/* Select output format */\n\t\t\tif (argv[++opt] && !strcmp(argv[opt], K_JSON)) {\n\t\t\t\txflags |= X_D_JSON_OUTPUT;\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\tfor (i = 1; *(argv[opt] + i); i++) {\n\n\t\t\t\tswitch (*(argv[opt] + i)) {\n\n\t\t\t\tcase 'd':\n\t\t\t\t\t/* Display I/O usage */\n\t\t\t\t\tactflag |= P_A_IO;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'H':\n\t\t\t\t\t/* Display timestamps in sec since the epoch */\n\t\t\t\t\tpidflag |= P_D_SEC_EPOCH;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'h':\n\t\t\t\t\t/* Display stats on one line */\n\t\t\t\t\tpidflag |= P_D_ONELINE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'I':\n\t\t\t\t\t/* IRIX mode off */\n\t\t\t\t\tpidflag |= P_F_IRIX_MODE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\t\t\t\t\t/* Display whole command line */\n\t\t\t\t\tpidflag |= P_D_CMDLINE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\t\t\t\t\t/* Display priority and policy info */\n\t\t\t\t\tactflag |= P_A_RT;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'r':\n\t\t\t\t\t/* Display memory usage */\n\t\t\t\t\tactflag |= P_A_MEM;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 's':\n\t\t\t\t\t/* Display stack sizes */\n\t\t\t\t\tactflag |= P_A_STACK;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 't':\n\t\t\t\t\t/* Display stats for threads */\n\t\t\t\t\tpidflag |= P_D_TID;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'U':\n\t\t\t\t\t/* When option is grouped, it cannot take an arg */\n\t\t\t\t\tpidflag |= P_D_USERNAME;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* Display CPU usage */\n\t\t\t\t\tactflag |= P_A_CPU;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'V':\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *pidstat_env[] = {ENV_COLORS,\n\t\t\t\t\t\t\t\t       ENV_COLORS_SGR,\n\t\t\t\t\t\t\t\t       ENV_TIME_FMT};\n#define PIDSTAT_ENV_NR\t3\n\t\t\t\t\t\t/* Print environment contents, version number and exit */\n\t\t\t\t\t\tprint_version(pidstat_env, PIDSTAT_ENV_NR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase 'v':\n\t\t\t\t\t/* Display some kernel tables values */\n\t\t\t\t\tactflag |= P_A_KTAB;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'w':\n\t\t\t\t\t/* Display context switches */\n\t\t\t\t\tactflag |= P_A_CTXSW;\n\t\t\t\t\tdis_hdr++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (interval < 0) {\t/* Get interval */\n\t\t\tif (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = -1;\n\t\t}\n\n\t\telse if (count <= 0) {\t/* Get count value */\n\t\t\tif ((strspn(argv[opt], DIGITS) != strlen(argv[opt])) ||\n\t\t\t    !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif (count < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (interval < 0) {\n\t\t/* Interval not set => display stats since boot time */\n\t\tinterval = 0;\n\t}\n\n\t/* A non-zero value must be specified for interval when option -e is used */\n\tif (!interval && EXEC_PGM(pidflag))\n\t\tusage(argv[0]);\n\n\tif (!DISPLAY_PID(pidflag)) {\n\t\tdis_hdr = 1;\n\t}\n\n\t/* Check flags and set default values */\n\tcheck_flags();\n\n\t/* Count nb of proc */\n\tcpu_nr = get_cpu_nr(~0, FALSE);\n\n\tif (dis_hdr < 0) {\n\t\tdis_hdr = 0;\n\t}\n\tif (!dis_hdr) {\n\t\tif ((pid_nr > 1)) {\n\t\t\tdis_hdr = 1;\n\t\t}\n\t\telse {\n\t\t\trows = get_win_height();\n\t\t}\n\t}\n\n\t/* Get time */\n\tget_xtime(&(ps_tstamp[0]), 0, LOCAL_TIME);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t/* Use a decimal point to make JSON code compliant with RFC7159 */\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t\t/* Option \"-h\" cannot be used in JSON format */\n\t\tpidflag &= ~P_D_ONELINE;\n\t}\n\n\t/*\n\t * Don't buffer data if redirected to a pipe.\n\t * Note: With musl-c, the behavior of this function is undefined except\n\t * when it is the first operation on the stream.\n\t */\n\tsetbuf(stdout, NULL);\n\n\t/* Get system name, release number and hostname */\n\t__uname(&header);\n\tprint_gal_header(&(ps_tstamp[0]), header.sysname, header.release,\n\t\t\t header.nodename, header.machine, cpu_nr,\n\t\t\t DISPLAY_JSON_OUTPUT(xflags));\n\n\t/* Main loop */\n\trw_pidstat_loop(dis_hdr, rows);\n\n\t/* Free structures */\n\tsfree_pid(&pid_list, TRUE);\n\n\t/*\n\t * @status contains the exit code of the child process monitored with option -e,\n\t * or 0 otherwise.\n\t */\n\treturn status;\n}\n"
        },
        {
          "name": "pidstat.h",
          "type": "blob",
          "size": 6.849609375,
          "content": "/*\n * pidstat: Display per-process statistics.\n * (C) 2007-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n#ifndef _PIDSTAT_H\n#define _PIDSTAT_H\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n/* sys/param.h defines HZ but needed for _POSIX_ARG_MAX and LOGIN_NAME_MAX */\n#undef HZ\n#endif\n#include \"common.h\"\n\n#define K_SELF\t\t\"SELF\"\n\n#define K_P_TASK\t\"TASK\"\n#define K_P_CHILD\t\"CHILD\"\n#define K_P_ALL\t\t\"ALL\"\n\n#ifdef _POSIX_ARG_MAX\n#define MAX_COMM_LEN    _POSIX_ARG_MAX\n#define MAX_CMDLINE_LEN _POSIX_ARG_MAX\n#else\n#define MAX_COMM_LEN    128\n#define MAX_CMDLINE_LEN 128\n#endif\n\n#ifdef LOGIN_NAME_MAX\n#define MAX_USER_LEN    LOGIN_NAME_MAX\n#else\n#define MAX_USER_LEN    32\n#endif\n\n/* Activities */\n#define P_A_CPU\t\t0x01\n#define P_A_MEM\t\t0x02\n#define P_A_IO\t\t0x04\n#define P_A_CTXSW\t0x08\n#define P_A_STACK\t0x10\n#define P_A_KTAB\t0x20\n#define P_A_RT\t\t0x40\n\n#define DISPLAY_CPU(m)\t\t(((m) & P_A_CPU) == P_A_CPU)\n#define DISPLAY_MEM(m)\t\t(((m) & P_A_MEM) == P_A_MEM)\n#define DISPLAY_IO(m)\t\t(((m) & P_A_IO) == P_A_IO)\n#define DISPLAY_CTXSW(m)\t(((m) & P_A_CTXSW) == P_A_CTXSW)\n#define DISPLAY_STACK(m)\t(((m) & P_A_STACK) == P_A_STACK)\n#define DISPLAY_KTAB(m)\t\t(((m) & P_A_KTAB) == P_A_KTAB)\n#define DISPLAY_RT(m)\t\t(((m) & P_A_RT) == P_A_RT)\n\n/* TASK/CHILD */\n#define P_NULL\t\t0x00\n#define P_TASK\t\t0x01\n#define P_CHILD\t\t0x02\n\n#define DISPLAY_TASK_STATS(m)\t(((m) & P_TASK) == P_TASK)\n#define DISPLAY_CHILD_STATS(m)\t(((m) & P_CHILD) == P_CHILD)\n\n#define P_D_PID\t\t0x0001\n#define P_D_ALL_PID\t0x0002\n#define P_F_IRIX_MODE\t0x0004\n#define P_F_COMMSTR\t0x0008\n#define P_D_ACTIVE_PID\t0x0010\n#define P_D_TID\t\t0x0020\n#define P_D_ONELINE\t0x0040\n#define P_D_CMDLINE\t0x0080\n#define P_D_USERNAME\t0x0100\n#define P_F_USERSTR\t0x0200\n#define P_F_PROCSTR\t0x0400\n#define P_D_UNIT\t0x0800\n#define P_D_SEC_EPOCH\t0x1000\n#define P_F_EXEC_PGM\t0x2000\n\n#define DISPLAY_PID(m)\t\t(((m) & P_D_PID) == P_D_PID)\n#define DISPLAY_ALL_PID(m)\t(((m) & P_D_ALL_PID) == P_D_ALL_PID)\n#define IRIX_MODE_OFF(m)\t(((m) & P_F_IRIX_MODE) == P_F_IRIX_MODE)\n#define COMMAND_STRING(m)\t(((m) & P_F_COMMSTR) == P_F_COMMSTR)\n#define DISPLAY_ACTIVE_PID(m)\t(((m) & P_D_ACTIVE_PID) == P_D_ACTIVE_PID)\n#define DISPLAY_TID(m)\t\t(((m) & P_D_TID) == P_D_TID)\n#define DISPLAY_ONELINE(m)\t(((m) & P_D_ONELINE) == P_D_ONELINE)\n#define DISPLAY_CMDLINE(m)\t(((m) & P_D_CMDLINE) == P_D_CMDLINE)\n#define DISPLAY_USERNAME(m)\t(((m) & P_D_USERNAME) == P_D_USERNAME)\n#define USER_STRING(m)\t\t(((m) & P_F_USERSTR) == P_F_USERSTR)\n#define PROCESS_STRING(m)\t(((m) & P_F_PROCSTR) == P_F_PROCSTR)\n#define DISPLAY_UNIT(m)\t\t(((m) & P_D_UNIT) == P_D_UNIT)\n#define PRINT_SEC_EPOCH(m)\t(((m) & P_D_SEC_EPOCH) == P_D_SEC_EPOCH)\n#define EXEC_PGM(m)\t\t(((m) & P_F_EXEC_PGM) == P_F_EXEC_PGM)\n\n/* Per-process flags */\n#define F_NO_PID_IO\t0x01\n#define F_NO_PID_FD\t0x02\n#define F_PID_DISPLAYED\t0x04\n\n#define NO_PID_IO(m)\t\t(((m) & F_NO_PID_IO) == F_NO_PID_IO)\n#define NO_PID_FD(m)\t\t(((m) & F_NO_PID_FD) == F_NO_PID_FD)\n#define IS_PID_DISPLAYED(m)\t(((m) & F_PID_DISPLAYED) == F_PID_DISPLAYED)\n\n\n#define PROC\t\tPRE \"/proc\"\n\n#define PID_STAT\tPRE \"/proc/%u/stat\"\n#define PID_STATUS\tPRE \"/proc/%u/status\"\n#define PID_IO\t\tPRE \"/proc/%u/io\"\n#define PID_CMDLINE\tPRE \"/proc/%u/cmdline\"\n#define PID_SMAP\tPRE \"/proc/%u/smaps\"\n#define PID_FD\t\tPRE \"/proc/%u/fd\"\n#define PID_SCHED\tPRE \"/proc/%u/schedstat\"\n\n#define PROC_TASK\tPRE \"/proc/%u/task\"\n#define TASK_STAT\tPRE \"/proc/%u/task/%u/stat\"\n#define TASK_SCHED\tPRE \"/proc/%u/task/%u/schedstat\"\n#define TASK_STATUS\tPRE \"/proc/%u/task/%u/status\"\n#define TASK_IO\t\tPRE \"/proc/%u/task/%u/io\"\n#define TASK_CMDLINE\tPRE \"/proc/%u/task/%u/cmdline\"\n#define TASK_SMAP\tPRE \"/proc/%u/task/%u/smaps\"\n#define TASK_FD\t\tPRE \"/proc/%u/task/%u/fd\"\n\n#define PRINT_ID_HDR(_timestamp_, _flag_)\tdo {\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tprintf(\"\\n%-11s\", _timestamp_);\t\\\n\t\t\t\t\t\t\tif (DISPLAY_USERNAME(_flag_)) {\t\t\\\n\t\t\t\t\t\t\t\tprintf(\"     USER\");\t\t\\\n\t\t\t\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\t\t\t\telse {\t\t\t\t\t\\\n\t\t\t\t\t\t\t\tprintf(\"   UID\");\t\t\\\n\t\t\t\t\t\t\t}\t\t\t\t\t\\\n   \t\t\t\t\t\t\tif (DISPLAY_TID(_flag_)) {\t\t\\\n\t\t\t\t\t\t\t\tprintf(\"      TGID       TID\");\t\\\n\t\t\t\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\t\t\t\telse {\t\t\t\t\t\\\n\t\t\t\t\t\t\t\tprintf(\"       PID\");\t\t\\\n\t\t\t\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\t\t\t} while (0)\n\n/* Normally defined in <linux/sched.h> */\n#ifndef SCHED_NORMAL\n#define SCHED_NORMAL\t0\n#endif\n#ifndef SCHED_FIFO\n#define SCHED_FIFO\t1\n#endif\n#ifndef SCHED_RR\n#define SCHED_RR\t2\n#endif\n#ifndef SCHED_BATCH\n#define SCHED_BATCH\t3\n#endif\n/* SCHED_ISO not yet implemented */\n#ifndef SCHED_IDLE\n#define SCHED_IDLE\t5\n#endif\n#ifndef SCHED_DEADLINE\n#define SCHED_DEADLINE\t6\n#endif\n\n#define GET_POLICY(p) \\\n\t(p == SCHED_NORMAL   ? \"NORMAL\" : \\\n\t(p == SCHED_FIFO     ? \"FIFO\" : \\\n\t(p == SCHED_RR       ? \"RR\" : \\\n\t(p == SCHED_BATCH    ? \"BATCH\" : \\\n\t(p == SCHED_IDLE     ? \"IDLE\" : \\\n\t(p == SCHED_DEADLINE ? \"DEADLN\" : \\\n\t\"?\"))))))\n\nstruct pid_stats {\n\tunsigned long long read_bytes\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long long write_bytes\t\t\t__attribute__ ((packed));\n\tunsigned long long cancelled_write_bytes\t__attribute__ ((packed));\n\tunsigned long long blkio_swapin_delays\t\t__attribute__ ((packed));\n\tunsigned long long minflt\t\t\t__attribute__ ((packed));\n\tunsigned long long cminflt\t\t\t__attribute__ ((packed));\n\tunsigned long long majflt\t\t\t__attribute__ ((packed));\n\tunsigned long long cmajflt\t\t\t__attribute__ ((packed));\n\tunsigned long long utime\t\t\t__attribute__ ((packed));\n\tlong long          cutime\t\t\t__attribute__ ((packed));\n\tunsigned long long stime\t\t\t__attribute__ ((packed));\n\tlong long          cstime\t\t\t__attribute__ ((packed));\n\tunsigned long long gtime\t\t\t__attribute__ ((packed));\n\tlong long          cgtime\t\t\t__attribute__ ((packed));\n\tunsigned long long wtime\t\t\t__attribute__ ((packed));\n\tunsigned long long vsz\t\t\t\t__attribute__ ((packed));\n\tunsigned long long rss\t\t\t\t__attribute__ ((packed));\n\tunsigned long      nvcsw\t\t\t__attribute__ ((packed));\n\tunsigned long      nivcsw\t\t\t__attribute__ ((packed));\n\tunsigned long      stack_size\t\t\t__attribute__ ((packed));\n\tunsigned long      stack_ref\t\t\t__attribute__ ((packed));\n\tunsigned int       processor\t\t\t__attribute__ ((packed));\n\tunsigned int       priority\t\t\t__attribute__ ((packed));\n\tunsigned int       policy\t\t\t__attribute__ ((packed));\n\tunsigned int       threads\t\t\t__attribute__ ((packed));\n\tunsigned int       fd_nr\t\t\t__attribute__ ((packed));\n};\n\n#define PID_STATS_SIZE\t(sizeof(struct pid_stats))\n\nstruct st_pid {\n\tunsigned long long total_vsz;\n\tunsigned long long total_rss;\n\tunsigned long long total_stack_size;\n\tunsigned long long total_stack_ref;\n\tunsigned long long total_threads;\n\tunsigned long long total_fd_nr;\n\tpid_t\t\t   pid;\n\tuid_t\t\t   uid;\n\tint\t\t   exist;\t/* TRUE if PID exists */\n\tunsigned int\t   flags;\n\tunsigned int\t   rt_asum_count;\n\tunsigned int\t   rc_asum_count;\n\tunsigned int\t   uc_asum_count;\n\tunsigned int\t   tf_asum_count;\n\tunsigned int\t   sk_asum_count;\n\tunsigned int\t   delay_asum_count;\n\tstruct pid_stats  *pstats[3];\n\tstruct st_pid\t  *tgid;\t/* If current task is a TID, pointer to its TGID. NULL otherwise. */\n\tstruct st_pid\t  *next;\n\tchar\t\t   comm[MAX_COMM_LEN];\n\tchar\t\t   cmdline[MAX_CMDLINE_LEN];\n};\n\n#endif  /* _PIDSTAT_H */\n"
        },
        {
          "name": "pr_stats.c",
          "type": "blob",
          "size": 153.9462890625,
          "content": "/*\n * pr_stats.c: Functions used by sar to display statistics\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <float.h>\n\n#include \"sa.h\"\n#include \"ioconf.h\"\n#include \"pr_xstats.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nextern uint64_t flags;\nextern int  dish;\nextern int xinit;\nextern char timestamp[][TIMESTAMP_LEN];\nextern unsigned long avg_count;\n\n/*\n ***************************************************************************\n * Display current activity header line.\n *\n * IN:\n * @p_timestamp\t\tTimestamp for previous stat sample.\n * @a\t\t\tActivity structure.\n * @pos\t\t\tHeader to display, FIRST being the first header (headers\n *\t\t\tare delimited by the '|' character).\n * @iwidth\t\tFirst column width (generally this is the item name).\n *\t\t\tA negative value means that the corresponding field\n *\t\t\tshall be displayed at the end of the line, with no\n *\t\t\tindication of width.\n * @vwidth\t\tColumn width for stats values.\n * @offline_bitmap\tBitmap for offline items (e.g. CPU).\n ***************************************************************************\n */\nvoid print_hdr_line(char *p_timestamp, struct activity *a, int pos, int iwidth, int vwidth,\n\t\t    const unsigned char *offline_bitmap)\n{\n\tchar hline[HEADER_LINE_LEN] = \"\";\n\tchar cfld[16], dfld[16];\n\tchar *hl, *tk, *it = NULL;\n\tint i = -1, j, k;\n\tint p = pos;\n\n\tstrncpy(hline, a->hdr_line, sizeof(hline) - 1);\n\thline[sizeof(hline) - 1] = '\\0';\n\tfor (hl = strtok(hline, \"|\"); hl && (pos > 0); hl = strtok(NULL, \"|\"), pos--);\n\tif (!hl)\n\t\t/* Bad @pos arg given to function */\n\t\treturn;\n\n\tprintf(\"\\n%-11s\", p_timestamp);\n\n\tif (strchr(hl, '&')) {\n\t\tj = strcspn(hl, \"&\");\n\t\tif ((a->opt_flags & 0xff00) & (1 << (8 + p))) {\n\t\t\t/* Display whole header line */\n\t\t\t*(hl + j) = ';';\n\t\t}\n\t\telse {\n\t\t\t/* Display only the first part of the header line */\n\t\t\t*(hl + j) = '\\0';\n\t\t}\n\t}\n\t/* Display each field */\n\tfor (tk = strtok(hl, \";\"); tk; tk = strtok(NULL, \";\"), i--) {\n\n\t\tif (strchr(tk, '*')) {\n\t\t\tstrncpy(cfld, tk, sizeof(cfld) - 1);\n\t\t\tk = strcspn(cfld, \"*\");\n\t\t\tif (k >= strlen(cfld))\n\t\t\t\tcontinue;\t/* Should not happen */\n\t\t\tcfld[k] = '\\0';\n\t\t\tfor (j = 0; (j < a->nr_ini) && (j < a->bitmap->b_size + 1); j++) {\n\t\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, j))\n\t\t\t\t\t/* Don't display current item if not selected */\n\t\t\t\t\tcontinue;\n\t\t\t\tif (offline_bitmap && IS_CPU_OFFLINE(offline_bitmap, j))\n\t\t\t\t\t/* Don't display current item if offline */\n\t\t\t\t\tcontinue;\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tprintf(\" %*s\", vwidth, K_LOWERALL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsnprintf(dfld, sizeof(dfld), \"%s%d%s\", cfld, j - 1, cfld + k + 1);\n\t\t\t\t\tdfld[sizeof(dfld) - 1] = '\\0';\n\t\t\t\t\tprintf(\" %*s\", vwidth, dfld);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (iwidth > 0) {\n\t\t\tprintf(\" %*s\", iwidth, tk);\n\t\t\tiwidth = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((iwidth < 0) && (iwidth == i)) {\n\t\t\tit = tk;\n\t\t\tiwidth = 0;\n\t\t}\n\t\telse {\n\t\t\tprintf(\" %*s\", vwidth, tk);\n\t\t}\n\t}\n\n\tif (it) {\n\t\tprintf(\" %s\", it);\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Save CPU min and max values.\n *\n * IN:\n * @a\t\t\tActivity structure with statistics.\n * @cpu\t\t\tCPU number (0 for CPU \"all\").\n * @deltot_jiffies\tInterval in jiffies.\n * @scc\t\t\tCurrent statistics sample.\n * @scp\t\t\tPrevious statistics sample.\n ***************************************************************************\n */\nvoid save_cpu_xstats(struct activity *a, int cpu, unsigned long long deltot_jiffies,\n\t\t     struct stats_cpu *scc, struct stats_cpu *scp)\n{\n\tif (!cpu && !deltot_jiffies) {\n\t\tint j, k;\n\n\t\t/* Current CPU (which is not CPU \"all\") is tickless */\n\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\tj  = 5;\t/* -u */\n\t\t}\n\t\telse {\t/* DISPLAY_CPU_ALL(a->opt_flags) */\n\t\t\tj = 9;\t/* -u ALL */\n\t\t}\n\t\tfor (k = 0; k < j; k++) {\n\t\t\tsave_minmax(a, cpu * a->xnr + k, 0.0);\n\t\t}\n\t\t/* %idle = 100% */\n\t\tsave_minmax(a, cpu * a->xnr + 9, 100.0);\n\n\t\treturn;\n\t}\n\n\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t/* %user */\n\t\tsave_minmax(a, cpu * a->xnr,\n\t\t\t    ll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies));\n\t\t/* %nice */\n\t\tsave_minmax(a, cpu * a->xnr + 1,\n\t\t\t    ll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies));\n\t\t/* %system */\n\t\tsave_minmax(a, cpu * a->xnr + 2,\n\t\t\t    ll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\tscc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t   deltot_jiffies));\n\t}\n\telse {  /* DISPLAY_CPU_ALL(a->opt_flags) */\n\t\t/* %usr */\n\t\tsave_minmax(a, cpu * a->xnr,\n\t\t\t    (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\tscc->cpu_user - scc->cpu_guest, deltot_jiffies));\n\t\t/* %nice */\n\t\tsave_minmax(a, cpu * a->xnr + 1,\n\t\t\t    (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\tscc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies));\n\t\t/* %sys */\n\t\tsave_minmax(a, cpu * a->xnr + 2,\n\t\t\t    ll_sp_value(scp->cpu_sys, scc->cpu_sys, deltot_jiffies));\n\t\t/* %irq */\n\t\tsave_minmax(a, cpu * a->xnr + 5,\n\t\t\t    ll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies));\n\t\t/* %soft */\n\t\tsave_minmax(a, cpu * a->xnr + 6,\n\t\t\t    ll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies));\n\t\t/* %guest */\n\t\tsave_minmax(a, cpu * a->xnr + 7,\n\t\t\t    ll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies));\n\t\t/* %gnice */\n\t\tsave_minmax(a, cpu * a->xnr + 8,\n\t\t\t    ll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies));\n\t}\n\n\t/* %iowait */\n\tsave_minmax(a, cpu * a->xnr + 3,\n\t\t    ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies));\n\t/* %steal */\n\tsave_minmax(a, cpu * a->xnr + 4,\n\t\t    ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies));\n\t/* %idle */\n\tsave_minmax(a, cpu * a->xnr + 9,\n\t\t    (scc->cpu_idle < scp->cpu_idle ? 0.0 :\n\t\t    ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies)));\n}\n\n/*\n * **************************************************************************\n * Print a line of CPU statistics.\n *\n * IN:\n * @a\t\t\tActivity structure with statistics.\n * @cpu\t\t\tCPU number (0 for CPU \"all\").\n * @deltot_jiffies\tInterval in jiffies.\n * @scc\t\t\tCurrent statistics sample.\n * @scp\t\t\tPrevious statistics sample.\n ***************************************************************************\n */\nvoid print_oneline_cpu_stats(struct activity *a, int cpu, unsigned long long deltot_jiffies,\n\t\t\t     struct stats_cpu *scc, struct stats_cpu *scp)\n{\n\tif (cpu == 0) {\n\t\t/* This is CPU \"all\" */\n\t\tcprintf_in(IS_STR, \" %s\", \"    all\", 0);\n\t}\n\telse {\n\t\tcprintf_in(IS_INT, \" %7d\", \"\", cpu - 1);\n\n\t\tif (!deltot_jiffies) {\n\t\t\t/*\n\t\t\t * If the CPU is tickless then there is no change in CPU values\n\t\t\t * but the sum of values is not zero.\n\t\t\t * %user, %nice, %system, %iowait, %steal, ..., %idle\n\t\t\t */\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), FALSE, 5, 9, 2,\n\t\t\t\t    0.0, 0.0, 0.0, 0.0, 0.0);\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), FALSE, 1, 9, 2, 100.0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Four additional fields to display:\n\t\t\t * %irq, %soft, %guest, %gnice.\n\t\t\t */\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), FALSE, 5, 9, 2,\n\t\t\t\t\t    0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 5, 9, 2,\n\t\t\t    ll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\tscc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t\t\t\tdeltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies));\n\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 2,\n\t\t\t    scc->cpu_idle < scp->cpu_idle ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies));\n\t}\n\telse { /* DISPLAY_CPU_ALL(a->opt_flags) */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 9, 9, 2,\n\t\t\t    (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\tscc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t    (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\tscc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_sys, scc->cpu_sys, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies),\n\t\t\t    ll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies));\n\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 2,\n\t\t\t    scc->cpu_idle < scp->cpu_idle ?\n\t\t\t    0.0 :\n\t\t\t    ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies));\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics.\n * NB: The stats are only calculated over the part of the time interval when\n * the CPU was online. As a consequence, the sum (%user + %nice + ... + %idle)\n * will always be 100% on the time interval even if the CPU has been offline\n * most of the time.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second (independent of the\n *\t\tnumber of processors). Unused here.\n ***************************************************************************\n */\n__print_funct_t print_cpu_stats(struct activity *a, int prev, int curr,\n\t\t\t\tunsigned long long itv)\n{\n\tint i;\n\tunsigned long long deltot_jiffies = 1;\n\tstruct stats_cpu *scc, *scp;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->nr2 * a->xnr);\n\t}\n\n\tif (dish && !((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST + DISPLAY_CPU_ALL(a->opt_flags), 7, 9,\n\t\t\t       NULL);\n\t}\n\n\t/*\n\t * @nr[curr] cannot normally be greater than @nr_ini\n\t * (since @nr_ini counts up all CPU, even those offline).\n\t * If this happens, it may be because the machine has been\n\t * restarted with more CPU and no LINUX_RESTART has been\n\t * inserted in file.\n\t * No problem here with @nr_allocated. Having been able to\n\t * read @nr[curr] structures shows that buffers are large enough.\n\t */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/*\n\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t * and look for offline CPU.\n\t */\n\tif (a->nr_ini > 1) {\n\t\tdeltot_jiffies = get_global_cpu_statistics(a, prev, curr,\n\t\t\t\t\t\t\t   flags, offline_cpu_bitmap);\n\t}\n\n\t/*\n\t * Now display CPU statistics (including CPU \"all\"),\n\t * except for offline CPU or CPU that the user doesn't want to see.\n\t */\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * Should current CPU (including CPU \"all\") be displayed?\n\t\t * Note: @nr[curr] is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* Don't display CPU */\n\t\t\tcontinue;\n\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr] + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[prev] + i * a->msize);\n\n\t\tif (i == 0) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tif (a->nr_ini == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a UP machine. In this case\n\t\t\t\t * interval has still not been calculated.\n\t\t\t\t */\n\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t\t}\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* CPU \"all\" cannot be tickless */\n\t\t\t\tdeltot_jiffies = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Recalculate interval for current proc */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t}\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_cpu_xstats(a, i, deltot_jiffies, scc, scp);\n\t\t\t}\n\t\t\telse if ((*(a->spmin + i * a->xnr) != DBL_MAX) &&\n\t\t\t\t (*(a->spmax + i * a->xnr) != -DBL_MAX)) {\n\t\t\t\t/*\n\t\t\t\t * Display min and max values if available.\n\t\t\t\t * Those values may be unavailable if CPU has always been offline\n\t\t\t\t * except for one sample only.\n\t\t\t\t */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST + DISPLAY_CPU_ALL(a->opt_flags), 7, 9,\n\t\t\t\t\t       NULL);\n\t\t\t\tprint_cpu_xstats(DISPLAY_CPU_DEF(a->opt_flags), i,\n\t\t\t\t\t\t H_MIN, a->spmin + i * a->xnr);\n\t\t\t\tprint_cpu_xstats(DISPLAY_CPU_DEF(a->opt_flags), i,\n\t\t\t\t\t\t H_MAX, a->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\t/* Print CPU stats */\n\t\tprint_oneline_cpu_stats(a, i, deltot_jiffies, scc, scp);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display tasks creation and context switches statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pcsw_stats(struct activity *a, int prev, int curr,\n\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr],\n\t\t*spp = (struct stats_pcsw *) a->buf[prev];\n\tint g_fields[] = {1, 0};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) spc, (void *) spp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t  S_VALUE(spp->processes,      spc->processes,      itv),\n\t\t  S_VALUE(spp->context_switch, spc->context_switch, itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_irq_stats(struct activity *a, int prev, int curr,\n\t\t\t\tunsigned long long itv)\n{\n\tint c, i;\n\tstruct stats_irq *stc_cpu_irq, *stp_cpu_irq, *stc_cpuall_irq, *stp_cpuall_irq;\n\tunsigned char masked_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tdouble val;\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->nr2 * a->xnr);\n\t}\n\n\t/*\n\t * @nr[curr] cannot normally be greater than @nr_ini\n\t * (since @nr_ini counts up all CPU, even those offline).\n\t * If this happens, it may be because the machine has been\n\t * restarted with more CPU and no LINUX_RESTART has been\n\t * inserted in file.\n\t */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Identify offline and unselected CPU, and keep persistent statistics values */\n\tget_global_int_statistics(a, prev, curr, flags, masked_cpu_bitmap);\n\n\t/*\n\t * Always display header line. The columns may vary if e.g. a CPU goes offline\n\t * and/or comes back online.\n\t */\n\tif (!((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, DISPLAY_PRETTY(flags) ? -1 : 0, 9,\n\t\t       masked_cpu_bitmap);\n\t}\n\n\tfor (i = 0; i < a->nr2; i++) {\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, stc_cpuall_irq->irq_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tstp_cpuall_irq = (struct stats_irq *) ((char *) a->buf[prev] + i * a->msize);\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) && (stc_cpuall_irq->irq_nr == stp_cpuall_irq->irq_nr))\n\t\t\tcontinue;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags) && (prev == 2)) {\n\t\t\t/* Display min and max values */\n\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST,\n\t\t\t\t       DISPLAY_PRETTY(flags) ? -1 : 0, 9,\n\t\t\t\t       masked_cpu_bitmap);\n\t\t\tprint_irq_xstats(H_MIN, a, curr, i, stc_cpuall_irq->irq_name,\n\t\t\t\t\t masked_cpu_bitmap, a->spmin);\n\t\t\tprint_irq_xstats(H_MAX, a, curr, i, stc_cpuall_irq->irq_name,\n\t\t\t\t\t masked_cpu_bitmap, a->spmax);\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tif (!DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %9s\", stc_cpuall_irq->irq_name, 0);\n\t\t}\n\n\t\tfor (c = 0; (c < a->nr[curr]) && (c < a->bitmap->b_size + 1); c++) {\n\n\t\t\tstc_cpu_irq = (struct stats_irq *) ((char *) a->buf[curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\t\t\tstp_cpu_irq = (struct stats_irq *) ((char *) a->buf[prev] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (IS_CPU_SET(masked_cpu_bitmap, c))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tif (!c && (stc_cpu_irq->irq_nr < stp_cpu_irq->irq_nr)) {\n\t\t\t\t/*\n\t\t\t\t * Total number among all CPU for a given interrupt may decrease if\n\t\t\t\t * a CPU has gone offline. In this case we display \"0.00\" instead of\n\t\t\t\t * the huge number that would appear otherwise.\n\t\t\t\t */\n\t\t\t\tval = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = S_VALUE(stp_cpu_irq->irq_nr, stc_cpu_irq->irq_nr, itv);\n\t\t\t}\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, val);\n\t\t\tif (DISPLAY_MINMAX(flags) && (prev != 2)) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_minmax(a, (c * a->nr2 + i) * a->xnr, val);\n\t\t\t}\n\t\t}\n\t\tif (DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %s\", stc_cpuall_irq->irq_name, 0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display swapping statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_swap_stats(struct activity *a, int prev, int curr,\n\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr],\n\t\t*ssp = (struct stats_swap *) a->buf[prev];\n\tint g_fields[] = {0, 1};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) ssc, (void *) ssp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t  S_VALUE(ssp->pswpin,  ssc->pswpin,  itv),\n\t\t  S_VALUE(ssp->pswpout, ssc->pswpout, itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display paging statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_paging_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr],\n\t\t*spp = (struct stats_paging *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) spc, (void *) spp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 10, 9, 2,\n\t\t  S_VALUE(spp->pgpgin,        spc->pgpgin,        itv),\n\t\t  S_VALUE(spp->pgpgout,       spc->pgpgout,       itv),\n\t\t  S_VALUE(spp->pgfault,       spc->pgfault,       itv),\n\t\t  S_VALUE(spp->pgmajfault,    spc->pgmajfault,    itv),\n\t\t  S_VALUE(spp->pgfree,        spc->pgfree,        itv),\n\t\t  S_VALUE(spp->pgscan_kswapd, spc->pgscan_kswapd, itv),\n\t\t  S_VALUE(spp->pgscan_direct, spc->pgscan_direct, itv),\n\t\t  S_VALUE(spp->pgsteal,       spc->pgsteal,       itv),\n\t\t  S_VALUE(spp->pgpromote,     spc->pgpromote,     itv),\n\t\t  S_VALUE(spp->pgdemote,      spc->pgdemote,      itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_io_stats(struct activity *a, int prev, int curr,\n\t\t\t       unsigned long long itv)\n{\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr],\n\t\t*sip = (struct stats_io *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 4, 5, 3, 6};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sic, (void *) sip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\t/*\n\t * If we get negative values, this is probably because\n\t * one or more devices/filesystems have been unmounted.\n\t * We display 0.0 in this case though we should rather tell\n\t * the user that the value cannot be calculated here.\n\t */\n\tcprintf_f(NO_UNIT, FALSE, 7, 9, 2,\n\t\t  sic->dk_drive < sip->dk_drive ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive, sic->dk_drive, itv),\n\t\t  sic->dk_drive_rio < sip->dk_drive_rio ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive_rio, sic->dk_drive_rio, itv),\n\t\t  sic->dk_drive_wio < sip->dk_drive_wio ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive_wio, sic->dk_drive_wio, itv),\n\t\t  sic->dk_drive_dio < sip->dk_drive_dio ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive_dio, sic->dk_drive_dio, itv),\n\t\t  sic->dk_drive_rblk < sip->dk_drive_rblk ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive_rblk, sic->dk_drive_rblk, itv),\n\t\t  sic->dk_drive_wblk < sip->dk_drive_wblk ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive_wblk, sic->dk_drive_wblk, itv),\n\t\t  sic->dk_drive_dblk < sip->dk_drive_dblk ? 0.0 :\n\t\t  S_VALUE(sip->dk_drive_dblk, sic->dk_drive_dblk, itv));\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization. This function is used to\n * display instantaneous and average statistics.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @unit\tDefault values unit.\n * @dispall\tTRUE if all memory fields should be displayed.\n ***************************************************************************\n */\nvoid print_ram_memory_stats(struct stats_memory *smc, int dispavg, int unit, int dispall)\n{\n\tstatic unsigned long long\n\t\tavg_frmkb       = 0,\n\t\tavg_bufkb       = 0,\n\t\tavg_camkb       = 0,\n\t\tavg_comkb       = 0,\n\t\tavg_activekb    = 0,\n\t\tavg_inactkb     = 0,\n\t\tavg_dirtykb     = 0,\n\t\tavg_anonpgkb    = 0,\n\t\tavg_slabkb      = 0,\n\t\tavg_kstackkb    = 0,\n\t\tavg_pgtblkb     = 0,\n\t\tavg_vmusedkb    = 0,\n\t\tavg_availablekb = 0;\n\tunsigned long long nousedmem;\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tnousedmem = smc->frmkb + smc->bufkb + smc->camkb + smc->slabkb;\n\t\tif (nousedmem > smc->tlmkb) {\n\t\t\tnousedmem = smc->tlmkb;\n\t\t}\n\t\tcprintf_u64(unit, 3, 9,\n\t\t\t    (unsigned long long) smc->frmkb,\n\t\t\t    (unsigned long long) smc->availablekb,\n\t\t\t    (unsigned long long) (smc->tlmkb - nousedmem));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t    smc->tlmkb ?\n\t\t\t    SP_VALUE(nousedmem, smc->tlmkb, smc->tlmkb)\n\t\t\t    : 0.0);\n\t\tcprintf_u64(unit, 3, 9,\n\t\t\t    (unsigned long long) smc->bufkb,\n\t\t\t    (unsigned long long) smc->camkb,\n\t\t\t    (unsigned long long) smc->comkb);\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t    (smc->tlmkb + smc->tlskb) ?\n\t\t\t    SP_VALUE(0, smc->comkb, smc->tlmkb + smc->tlskb)\n\t\t\t    : 0.0);\n\t\tcprintf_u64(unit, 3, 9,\n\t\t\t    (unsigned long long) smc->activekb,\n\t\t\t    (unsigned long long) smc->inactkb,\n\t\t\t    (unsigned long long) smc->dirtykb);\n\n\t\tif (dispall) {\n\t\t\t/* Display extended memory statistics */\n\t\t\tcprintf_u64(unit, 5, 9,\n\t\t\t\t    (unsigned long long) smc->anonpgkb,\n\t\t\t\t    (unsigned long long) smc->slabkb,\n\t\t\t\t    (unsigned long long) smc->kstackkb,\n\t\t\t\t    (unsigned long long) smc->pgtblkb,\n\t\t\t\t    (unsigned long long) smc->vmusedkb);\n\t\t}\n\n\t\t/*\n\t\t * Will be used to compute the average.\n\t\t * We assume that the total amount of memory installed can not vary\n\t\t * during the interval given on the command line.\n\t\t */\n\t\tavg_frmkb       += smc->frmkb;\n\t\tavg_bufkb       += smc->bufkb;\n\t\tavg_camkb       += smc->camkb;\n\t\tavg_comkb       += smc->comkb;\n\t\tavg_activekb    += smc->activekb;\n\t\tavg_inactkb     += smc->inactkb;\n\t\tavg_dirtykb     += smc->dirtykb;\n\t\tavg_anonpgkb    += smc->anonpgkb;\n\t\tavg_slabkb      += smc->slabkb;\n\t\tavg_kstackkb    += smc->kstackkb;\n\t\tavg_pgtblkb     += smc->pgtblkb;\n\t\tavg_vmusedkb    += smc->vmusedkb;\n\t\tavg_availablekb += smc->availablekb;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tnousedmem = avg_frmkb + avg_bufkb + avg_camkb + avg_slabkb;\n\t\tcprintf_f(unit, FALSE, 3, 9, 0,\n\t\t\t  (double) avg_frmkb / avg_count,\n\t\t\t  (double) avg_availablekb / avg_count,\n\t\t\t  (double) smc->tlmkb - ((double) nousedmem / avg_count));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t    smc->tlmkb ?\n\t\t\t    SP_VALUE((double) (nousedmem / avg_count), smc->tlmkb, smc->tlmkb)\n\t\t\t    : 0.0);\n\t\tcprintf_f(unit, FALSE, 3, 9, 0,\n\t\t\t  (double) avg_bufkb / avg_count,\n\t\t\t  (double) avg_camkb / avg_count,\n\t\t\t  (double) avg_comkb / avg_count);\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t    (smc->tlmkb + smc->tlskb) ?\n\t\t\t    SP_VALUE(0.0, (double) (avg_comkb / avg_count), smc->tlmkb + smc->tlskb)\n\t\t\t    : 0.0);\n\t\tcprintf_f(unit, FALSE, 3, 9, 0,\n\t\t\t  (double) avg_activekb / avg_count,\n\t\t\t  (double) avg_inactkb / avg_count,\n\t\t\t  (double) avg_dirtykb / avg_count);\n\n\t\tif (dispall) {\n\t\t\tcprintf_f(unit, FALSE, 5, 9, 0,\n\t\t\t\t  (double) avg_anonpgkb / avg_count,\n\t\t\t\t  (double) avg_slabkb / avg_count,\n\t\t\t\t  (double) avg_kstackkb / avg_count,\n\t\t\t\t  (double) avg_pgtblkb / avg_count,\n\t\t\t\t  (double) avg_vmusedkb / avg_count);\n\t\t}\n\n\t\t/* Reset average counters */\n\t\tavg_frmkb = avg_bufkb = avg_camkb = avg_comkb = 0;\n\t\tavg_activekb = avg_inactkb = avg_dirtykb = 0;\n\t\tavg_anonpgkb = avg_slabkb = avg_kstackkb = 0;\n\t\tavg_pgtblkb = avg_vmusedkb = avg_availablekb = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @smc\t\tStructure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @unit\tDefault values unit.\n ***************************************************************************\n */\nvoid stub_print_ram_memory_stats(struct activity *a, struct stats_memory *smc,\n\t\t\t\t int curr, int dispavg, int unit)\n{\n\tint g_fields[] = {0, 4, 5, -1, -1, -1, -1, 6, 8, 9, 10, 11, 12, 13, 14, 15, 1};\n\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\tunsigned long long nousedmem;\n\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) smc, NULL,\n\t\t\t\t     0, a->spmin, a->spmax, g_fields);\n\n\t\t\t/* Save min and max values for %memused */\n\t\t\tnousedmem = smc->frmkb + smc->bufkb + smc->camkb + smc->slabkb;\n\t\t\tif (nousedmem > smc->tlmkb) {\n\t\t\t\tnousedmem = smc->tlmkb;\n\t\t\t}\n\t\t\tsave_minmax(a, 3,\n\t\t\t\t    smc->tlmkb ? SP_VALUE(nousedmem, smc->tlmkb, smc->tlmkb) : 0.0);\n\t\t\t/* Save min and max values for %commit */\n\t\t\tsave_minmax(a, 7, (smc->tlmkb + smc->tlskb)\n\t\t\t\t\t  ? SP_VALUE(0, smc->comkb, smc->tlmkb + smc->tlskb)\n\t\t\t\t\t  : 0.0);\n\t\t\t/* Save min and max values for memued */\n\t\t\tsave_minmax(a, 2, (double) (smc->tlmkb - nousedmem));\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_ram_memory_xstats(H_MIN, a->spmin,\n\t\t\t\t\t\tunit, DISPLAY_MEM_ALL(a->opt_flags));\n\t\t\tprint_ram_memory_xstats(H_MAX, a->spmax,\n\t\t\t\t\t\tunit, DISPLAY_MEM_ALL(a->opt_flags));\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tprint_ram_memory_stats(smc, dispavg, unit, DISPLAY_MEM_ALL(a->opt_flags));\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization. This function is used to\n * display instantaneous and average statistics.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @unit\tDefault values unit.\n ***************************************************************************\n */\nvoid print_swap_memory_stats(struct stats_memory *smc, int dispavg, int unit)\n{\n\tstatic unsigned long long\n\tavg_frskb = 0,\n\tavg_tlskb = 0,\n\tavg_caskb = 0;\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_u64(unit, 2, 9,\n\t\t\t    (unsigned long long) smc->frskb,\n\t\t\t    (unsigned long long) (smc->tlskb - smc->frskb));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t    smc->tlskb ?\n\t\t\t    SP_VALUE(smc->frskb, smc->tlskb, smc->tlskb)\n\t\t\t    : 0.0);\n\t\tcprintf_u64(unit, 1, 9,\n\t\t\t    (unsigned long long) smc->caskb);\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), FALSE, 1, 9, 2,\n\t\t\t    (smc->tlskb - smc->frskb) ?\n\t\t\t    SP_VALUE(0, smc->caskb, smc->tlskb - smc->frskb)\n\t\t\t    : 0.0);\n\n\t\t/*\n\t\t * Will be used to compute the average.\n\t\t * We assume that the total amount of swap space may vary.\n\t\t */\n\t\tavg_frskb += smc->frskb;\n\t\tavg_tlskb += smc->tlskb;\n\t\tavg_caskb += smc->caskb;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_f(unit, FALSE, 2, 9, 0,\n\t\t\t  (double) avg_frskb / avg_count,\n\t\t\t  ((double) avg_tlskb / avg_count) -\n\t\t\t  ((double) avg_frskb / avg_count));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t    avg_tlskb ?\n\t\t\t    SP_VALUE((double) avg_frskb / avg_count,\n\t\t\t\t     (double) avg_tlskb / avg_count,\n\t\t\t\t     (double) avg_tlskb / avg_count)\n\t\t\t    : 0.0);\n\t\tcprintf_f(unit, FALSE, 1, 9, 0,\n\t\t\t  (double) avg_caskb / avg_count);\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), FALSE, 1, 9, 2,\n\t\t\t    (avg_tlskb != avg_frskb) ?\n\t\t\t    SP_VALUE(0.0, (double) avg_caskb / avg_count,\n\t\t\t\t     ((double) avg_tlskb / avg_count) -\n\t\t\t\t     ((double) avg_frskb / avg_count))\n\t\t\t    : 0.0);\n\n\t\t/* Reset average counters */\n\t\tavg_frskb = avg_tlskb = avg_caskb = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @smc\t\tStructure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @unit\tDefault values unit.\n ***************************************************************************\n */\nvoid stub_print_swap_memory_stats(struct activity *a, struct stats_memory *smc,\n\t\t\t\t  int curr, int dispavg, int unit)\n{\n\tint g_fields[] = {-1, -1, -1, -1, 16, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, SECOND, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) smc, NULL,\n\t\t\t\t     0, a->spmin, a->spmax, g_fields);\n\n\t\t\t/* Save min and max values for %swpused */\n\t\t\tsave_minmax(a, 18,\n\t\t\t\t    smc->tlskb ? SP_VALUE(smc->frskb, smc->tlskb, smc->tlskb)\n\t\t\t\t\t       : 0.0);\n\t\t\t/* Save min and max values for %swpcad */\n\t\t\tsave_minmax(a, 20,\n\t\t\t\t    (smc->tlskb - smc->frskb) ?\n\t\t\t\t    SP_VALUE(0, smc->caskb, smc->tlskb - smc->frskb) :\n\t\t\t\t    0.0);\n\t\t\t/* Save min and max values for swpused */\n\t\t\tsave_minmax(a, 17, (double) (smc->tlskb - smc->frskb));\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_swap_memory_xstats(H_MIN, a->spmin,\n\t\t\t\t\t\t unit, DISPLAY_MEM_ALL(a->opt_flags));\n\t\t\tprint_swap_memory_xstats(H_MAX, a->spmax,\n\t\t\t\t\t\t unit, DISPLAY_MEM_ALL(a->opt_flags));\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tprint_swap_memory_stats(smc, dispavg, unit);\n}\n\n/*\n ***************************************************************************\n * Display memory and swap utilization. This function is used to\n * display instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_memory_stats(struct activity *a, int curr, int dispavg)\n{\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\tint unit = NO_UNIT;\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\n\tif (DISPLAY_UNIT(flags)) {\n\t\t/* Default values unit is kB */\n\t\tunit = UNIT_KILOBYTE;\n\t}\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\tstub_print_ram_memory_stats(a, smc, curr, dispavg, unit);\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\tstub_print_swap_memory_stats(a, smc, curr, dispavg, unit);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display memory and swap statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_memory_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstub_print_memory_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average memory statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_memory_stats(struct activity *a, int prev, int curr,\n\t\t\t\t       unsigned long long itv)\n{\n\tstub_print_memory_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTrue if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_ktables_stats(struct activity *a, int curr, int dispavg)\n{\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\tint g_fields[] = {1, 2, 0, 3};\n\tstatic unsigned long long\n\t\tavg_dentry_stat = 0,\n\t\tavg_file_used   = 0,\n\t\tavg_inode_used  = 0,\n\t\tavg_pty_nr      = 0;\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) skc, NULL,\n\t\t\t\t     0, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genu64_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genu64_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_u64(NO_UNIT, 4, 9,\n\t\t\t    (unsigned long long) skc->dentry_stat,\n\t\t\t    (unsigned long long) skc->file_used,\n\t\t\t    (unsigned long long) skc->inode_used,\n\t\t\t    (unsigned long long) skc->pty_nr);\n\n\t\t/*\n\t\t * Will be used to compute the average.\n\t\t * Note: Overflow unlikely to happen but not impossible...\n\t\t */\n\t\tavg_dentry_stat += skc->dentry_stat;\n\t\tavg_file_used   += skc->file_used;\n\t\tavg_inode_used  += skc->inode_used;\n\t\tavg_pty_nr      += skc->pty_nr;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_f(NO_UNIT, FALSE, 4, 9, 0,\n\t\t\t  (double) avg_dentry_stat / avg_count,\n\t\t\t  (double) avg_file_used   / avg_count,\n\t\t\t  (double) avg_inode_used  / avg_count,\n\t\t\t  (double) avg_pty_nr      / avg_count);\n\n\t\t/* Reset average counters */\n\t\tavg_dentry_stat = avg_file_used = avg_inode_used = avg_pty_nr = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_ktables_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstub_print_ktables_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average kernel tables statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_ktables_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstub_print_ktables_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_queue_stats(struct activity *a, int curr, int dispavg)\n{\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\tint g_fields[] = {0, 5, 1, 2, 3, 4};\n\tstatic unsigned long long\n\t\tavg_nr_running    = 0,\n\t\tavg_nr_threads    = 0,\n\t\tavg_load_avg_1    = 0,\n\t\tavg_load_avg_5    = 0,\n\t\tavg_load_avg_15   = 0,\n\t\tavg_procs_blocked = 0;\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sqc, NULL,\n\t\t\t\t     0, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_queue_xstats(H_MIN, a->spmin);\n\t\t\tprint_queue_xstats(H_MAX, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_u64(NO_UNIT, 2, 9,\n\t\t\t    (unsigned long long) sqc->nr_running,\n\t\t\t    (unsigned long long) sqc->nr_threads);\n\t\tcprintf_f(NO_UNIT, FALSE, 3, 9, 2,\n\t\t\t  (double) sqc->load_avg_1  / 100,\n\t\t\t  (double) sqc->load_avg_5  / 100,\n\t\t\t  (double) sqc->load_avg_15 / 100);\n\t\tcprintf_u64(NO_UNIT, 1, 9,\n\t\t\t    (unsigned long long) sqc->procs_blocked);\n\n\t\t/* Will be used to compute the average */\n\t\tavg_nr_running    += sqc->nr_running;\n\t\tavg_nr_threads    += sqc->nr_threads;\n\t\tavg_load_avg_1    += sqc->load_avg_1;\n\t\tavg_load_avg_5    += sqc->load_avg_5;\n\t\tavg_load_avg_15   += sqc->load_avg_15;\n\t\tavg_procs_blocked += sqc->procs_blocked;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_f(NO_UNIT, FALSE, 2, 9, 0,\n\t\t\t  (double) avg_nr_running / avg_count,\n\t\t\t  (double) avg_nr_threads / avg_count);\n\t\tcprintf_f(NO_UNIT, FALSE, 3, 9, 2,\n\t\t\t  (double) avg_load_avg_1  / (avg_count * 100),\n\t\t\t  (double) avg_load_avg_5  / (avg_count * 100),\n\t\t\t  (double) avg_load_avg_15 / (avg_count * 100));\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 0,\n\t\t\t  (double) avg_procs_blocked / avg_count);\n\n\t\t/* Reset average counters */\n\t\tavg_nr_running = avg_nr_threads = 0;\n\t\tavg_load_avg_1 = avg_load_avg_5 = avg_load_avg_15 = 0;\n\t\tavg_procs_blocked = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_queue_stats(struct activity *a, int prev, int curr,\n\t\t\t\t  unsigned long long itv)\n{\n\tstub_print_queue_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average queue and load statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_queue_stats(struct activity *a, int prev, int curr,\n\t\t\t\t      unsigned long long itv)\n{\n\tstub_print_queue_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display serial lines statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_serial_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_serial *ssc, *ssp;\n\tint g_fields[] = {0, 1, 2, 3, 4, 5};\n\tunsigned int local_types_nr[] = {0, 6, 0};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\tif ((dish || DISPLAY_ZERO_OMIT(flags)) &&\n\t\t!((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tssc = (struct stats_serial *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (WANT_SINCE_BOOT(flags)) {\n\t\t\t/*\n\t\t\t * We want to display statistics since boot time.\n\t\t\t * Take the first structure from buf[prev]: This is a\n\t\t\t * structure that only contains 0 (it has been set to 0\n\t\t\t * when it has been allocated), and which exists since\n\t\t\t * there is the same number of allocated structures for\n\t\t\t * buf[prev] and bur[curr] (even if nothing has been read).\n\t\t\t */\n\t\t\tssp = (struct stats_serial *) ((char *) a->buf[prev]);\n\t\t\tfound = TRUE;\n\t\t}\n\t\telse {\n\t\t\tfound = FALSE;\n\n\t\t\tif (a->nr[prev] > 0) {\n\t\t\t\t/* Look for corresponding serial line in previous iteration */\n\t\t\t\tj = i;\n\n\t\t\t\tif (j >= a->nr[prev]) {\n\t\t\t\t\tj = a->nr[prev] - 1;\n\t\t\t\t}\n\n\t\t\t\tj0 = j;\n\n\t\t\t\tdo {\n\t\t\t\t\tssp = (struct stats_serial *) ((char *) a->buf[prev] + j * a->msize);\n\t\t\t\t\tif (ssc->line == ssp->line) {\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (++j >= a->nr[prev]) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j != j0);\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) && !memcmp(ssp, ssc, STATS_SERIAL_SIZE))\n\t\t\tcontinue;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tchar name[16];\n\t\t\tint k, pos;\n\n\t\t\tsnprintf(name, sizeof(name), \"%d\", ssc->line);\n\t\t\tname[sizeof(name) - 1] = '\\0';\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), name, sizeof(name), &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_extrema(local_types_nr, (void *) ssc, (void *) ssp,\n\t\t\t\t\t     itv, a->spmin + pos, a->spmax + pos, g_fields);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t\t\t\tprint_serial_xstats(H_MIN, name, a->spmin + pos);\n\t\t\t\tprint_serial_xstats(H_MAX, name, a->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\t\tcprintf_in(IS_INT, \"       %3d\", \"\", ssc->line);\n\n\t\tcprintf_f(NO_UNIT, FALSE, 6, 9, 2,\n\t\t\t  S_VALUE(ssp->rx,      ssc->rx,      itv),\n\t\t\t  S_VALUE(ssp->tx,      ssc->tx,      itv),\n\t\t\t  S_VALUE(ssp->frame,   ssc->frame,   itv),\n\t\t\t  S_VALUE(ssp->parity,  ssc->parity,  itv),\n\t\t\t  S_VALUE(ssp->brk,     ssc->brk,     itv),\n\t\t\t  S_VALUE(ssp->overrun, ssc->overrun, itv));\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display disks statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_disk_stats(struct activity *a, int prev, int curr,\n\t\t\t\t unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_disk *sdc,\t*sdp, sdpzero;\n\tstruct ext_disk_stats xds;\n\tchar *dev_name;\n\tint unit = NO_UNIT;\n\tdouble rkB, wkB, dkB;\n\tint g_fields[] = {0};\n\tunsigned int local_types_nr[] = {1, 0, 0};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\tmemset(&sdpzero, 0, STATS_DISK_SIZE);\n\n\tif (DISPLAY_UNIT(flags)) {\n\t\t/* Default values unit is kB */\n\t\tunit = UNIT_KILOBYTE;\n\t}\n\n\tif ((dish || DISPLAY_ZERO_OMIT(flags)) &&\n\t\t!((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, DISPLAY_PRETTY(flags) ? -1 : 0, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get device name */\n\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!WANT_SINCE_BOOT(flags)) {\n\t\t\tj = check_disk_reg(a, curr, prev, i);\n\t\t}\n\t\telse {\n\t\t\tj = -1;\n\t\t}\n\t\tif (j < 0) {\n\t\t\t/*\n\t\t\t * This is a newly registered device or we want stats since boot time.\n\t\t\t * Previous stats are zero.\n\t\t\t */\n\t\t\tsdp = &sdpzero;\n\t\t}\n\t\telse {\n\t\t\tsdp = (struct stats_disk *) ((char *) a->buf[prev] + j * a->msize);\n\t\t}\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) && !memcmp(sdp, sdc, STATS_DISK_SIZE))\n\t\t\tcontinue;\n\n\t\t/* Compute service time, etc. */\n\t\tcompute_ext_disk_stats(sdc, sdp, itv, &xds);\n\t\trkB = S_VALUE(sdp->rd_sect, sdc->rd_sect, itv) / 2;\n\t\twkB = S_VALUE(sdp->wr_sect, sdc->wr_sect, itv) / 2;\n\t\tdkB = S_VALUE(sdp->dc_sect, sdc->dc_sect, itv) / 2;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tint k, pos;\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), dev_name, MAX_NAME_LEN, &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_extrema(local_types_nr, (void *) sdc, (void *) sdp,\n\t\t\t\t\t     itv, a->spmin + pos, a->spmax + pos, g_fields);\n\n\t\t\t\tsave_minmax(a, pos + 1, rkB);\n\t\t\t\tsave_minmax(a, pos + 2, wkB);\n\t\t\t\tsave_minmax(a, pos + 3, dkB);\n\t\t\t\tsave_minmax(a, pos + 4, xds.arqsz / 2);\n\t\t\t\tsave_minmax(a, pos + 5,\n\t\t\t\t\t    S_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0);\n\t\t\t\tsave_minmax(a, pos + 6, xds.await);\n\t\t\t\tsave_minmax(a, pos + 7, xds.util / 10.0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST,\n\t\t\t\t\t       DISPLAY_PRETTY(flags) ? -1 : 0, 9, NULL);\n\t\t\t\tprint_disk_xstats(H_MIN, unit, dev_name,\n\t\t\t\t\t\t  a->spmin + pos);\n\t\t\t\tprint_disk_xstats(H_MAX, unit, dev_name,\n\t\t\t\t\t\t  a->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tif (!DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %9s\", dev_name, 0);\n\t\t}\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t  S_VALUE(sdp->nr_ios, sdc->nr_ios,  itv));\n\t\tcprintf_f(unit, FALSE, 3, 9, 2, rkB, wkB, dkB);\n\t\t/* See iostat for explanations */\n\t\tcprintf_f(unit, FALSE, 1, 9, 2,\n\t\t\t  xds.arqsz / 2);\n\t\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t\t  S_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0,\n\t\t\t  xds.await);\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t   xds.util / 10.0);\n\t\tif (DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %s\", dev_name, 0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_dev_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_dev *sndc, *sndp, sndzero;\n\tdouble rxkb, txkb, ifutil;\n\tint unit = NO_UNIT;\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6};\n\tunsigned int local_types_nr[] = {7, 0, 0};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\tmemset(&sndzero, 0, STATS_NET_DEV_SIZE);\n\n\tif (DISPLAY_UNIT(flags)) {\n\t\t/* Default values unit is bytes */\n\t\tunit = UNIT_BYTE;\n\t}\n\n\tif ((dish || DISPLAY_ZERO_OMIT(flags)) &&\n\t    !((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, DISPLAY_PRETTY(flags) ? -1 : 0, 9,\n\t\t\t       NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!WANT_SINCE_BOOT(flags)) {\n\t\t\tj = check_net_dev_reg(a, curr, prev, i);\n\t\t}\n\t\telse {\n\t\t\tj = -1;\n\t\t}\n\t\tif (j < 0) {\n\t\t\t/*\n\t\t\t * This is a newly registered interface or we want stats since boot time.\n\t\t\t * Previous stats are zero.\n\t\t\t */\n\t\t\tsndp = &sndzero;\n\t\t}\n\t\telse {\n\t\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[prev] + j * a->msize);\n\t\t}\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) && !memcmp(sndp, sndc, STATS_NET_DEV_SIZE2CMP))\n\t\t\tcontinue;\n\n\t\trxkb = S_VALUE(sndp->rx_bytes, sndc->rx_bytes, itv);\n\t\ttxkb = S_VALUE(sndp->tx_bytes, sndc->tx_bytes, itv);\n\t\tifutil = compute_ifutil(sndc, rxkb, txkb);\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tint k, pos;\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), sndc->interface, MAX_IFACE_LEN, &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_extrema(local_types_nr, (void *) sndc, (void *) sndp,\n\t\t\t\t\t     itv, a->spmin + pos, a->spmax + pos, g_fields);\n\n\t\t\t\t/* Save min and max values for %ifutil */\n\t\t\t\tsave_minmax(a, pos + 7, ifutil);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST,\n\t\t\t\t\t       DISPLAY_PRETTY(flags) ? -1 : 0, 9, NULL);\n\t\t\t\tprint_net_dev_xstats(H_MIN, unit, sndc->interface,\n\t\t\t\t\t\t     a->spmin + pos);\n\t\t\t\tprint_net_dev_xstats(H_MAX, unit, sndc->interface,\n\t\t\t\t\t\t     a->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tif (!DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %9s\", sndc->interface, 0);\n\t\t}\n\n\t\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t\t  S_VALUE(sndp->rx_packets, sndc->rx_packets, itv),\n\t\t\t  S_VALUE(sndp->tx_packets, sndc->tx_packets, itv));\n\t\tcprintf_f(unit, FALSE, 2, 9, 2,\n\t\t\t  unit < 0 ? rxkb / 1024 : rxkb,\n\t\t\t  unit < 0 ? txkb / 1024 : txkb);\n\t\tcprintf_f(NO_UNIT, FALSE, 3, 9, 2,\n\t\t\t  S_VALUE(sndp->rx_compressed, sndc->rx_compressed, itv),\n\t\t\t  S_VALUE(sndp->tx_compressed, sndc->tx_compressed, itv),\n\t\t\t  S_VALUE(sndp->multicast,     sndc->multicast,     itv));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, ifutil);\n\t\tif (DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %s\", sndc->interface, 0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interface errors statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_edev_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_edev *snedc, *snedp, snedzero;\n\tint g_fields[] = {2, 0, 1, 3, 4, 7, 8, 6, 5};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\tmemset(&snedzero, 0, STATS_NET_EDEV_SIZE);\n\n\tif ((dish || DISPLAY_ZERO_OMIT(flags)) &&\n\t\t!((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, DISPLAY_PRETTY(flags) ? -1 : 0, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!WANT_SINCE_BOOT(flags)) {\n\t\t\tj = check_net_edev_reg(a, curr, prev, i);\n\t\t}\n\t\telse {\n\t\t\tj = -1;\n\t\t}\n\t\tif (j < 0) {\n\t\t\t/*\n\t\t\t * This is a newly registered interface or we want stats since boot time.\n\t\t\t * Previous stats are zero.\n\t\t\t */\n\t\t\tsnedp = &snedzero;\n\t\t}\n\t\telse {\n\t\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[prev] + j * a->msize);\n\t\t}\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) && !memcmp(snedp, snedc, STATS_NET_EDEV_SIZE2CMP))\n\t\t\tcontinue;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tint k, pos;\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), snedc->interface, MAX_IFACE_LEN, &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_extrema(a->gtypes_nr, (void *) snedc, (void *) snedp,\n\t\t\t\t\t     itv, a->spmin + pos, a->spmax + pos, g_fields);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST,\n\t\t\t\t\t       DISPLAY_PRETTY(flags) ? -1 : 0, 9, NULL);\n\t\t\t\tprint_net_edev_xstats(H_MIN, snedc->interface,\n\t\t\t\t\t\t      a->spmin + pos);\n\t\t\t\tprint_net_edev_xstats(H_MAX, snedc->interface,\n\t\t\t\t\t\t      a->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tif (!DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %9s\", snedc->interface, 0);\n\t\t}\n\t\tcprintf_f(NO_UNIT, FALSE, 9, 9, 2,\n\t\t\t  S_VALUE(snedp->rx_errors,         snedc->rx_errors,         itv),\n\t\t\t  S_VALUE(snedp->tx_errors,         snedc->tx_errors,         itv),\n\t\t\t  S_VALUE(snedp->collisions,        snedc->collisions,        itv),\n\t\t\t  S_VALUE(snedp->rx_dropped,        snedc->rx_dropped,        itv),\n\t\t\t  S_VALUE(snedp->tx_dropped,        snedc->tx_dropped,        itv),\n\t\t\t  S_VALUE(snedp->tx_carrier_errors, snedc->tx_carrier_errors, itv),\n\t\t\t  S_VALUE(snedp->rx_frame_errors,   snedc->rx_frame_errors,   itv),\n\t\t\t  S_VALUE(snedp->rx_fifo_errors,    snedc->rx_fifo_errors,    itv),\n\t\t\t  S_VALUE(snedp->tx_fifo_errors,    snedc->tx_fifo_errors,    itv));\n\t\tif (DISPLAY_PRETTY(flags)) {\n\t\t\tcprintf_in(IS_STR, \" %s\", snedc->interface, 0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_nfs_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr],\n\t\t*snnp = (struct stats_net_nfs *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snnc, (void *) snnp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 6, 9, 2,\n\t\t  S_VALUE(snnp->nfs_rpccnt,     snnc->nfs_rpccnt,     itv),\n\t\t  S_VALUE(snnp->nfs_rpcretrans, snnc->nfs_rpcretrans, itv),\n\t\t  S_VALUE(snnp->nfs_readcnt,    snnc->nfs_readcnt,    itv),\n\t\t  S_VALUE(snnp->nfs_writecnt,   snnc->nfs_writecnt,   itv),\n\t\t  S_VALUE(snnp->nfs_accesscnt,  snnc->nfs_accesscnt,  itv),\n\t\t  S_VALUE(snnp->nfs_getattcnt,  snnc->nfs_getattcnt,  itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_nfsd_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr],\n\t\t*snndp = (struct stats_net_nfsd *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snndc, (void *) snndp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 11, 9, 2,\n\t\t  S_VALUE(snndp->nfsd_rpccnt,    snndc->nfsd_rpccnt,    itv),\n\t\t  S_VALUE(snndp->nfsd_rpcbad,    snndc->nfsd_rpcbad,    itv),\n\t\t  S_VALUE(snndp->nfsd_netcnt,    snndc->nfsd_netcnt,    itv),\n\t\t  S_VALUE(snndp->nfsd_netudpcnt, snndc->nfsd_netudpcnt, itv),\n\t\t  S_VALUE(snndp->nfsd_nettcpcnt, snndc->nfsd_nettcpcnt, itv),\n\t\t  S_VALUE(snndp->nfsd_rchits,    snndc->nfsd_rchits,    itv),\n\t\t  S_VALUE(snndp->nfsd_rcmisses,  snndc->nfsd_rcmisses,  itv),\n\t\t  S_VALUE(snndp->nfsd_readcnt,   snndc->nfsd_readcnt,   itv),\n\t\t  S_VALUE(snndp->nfsd_writecnt,  snndc->nfsd_writecnt,  itv),\n\t\t  S_VALUE(snndp->nfsd_accesscnt, snndc->nfsd_accesscnt, itv),\n\t\t  S_VALUE(snndp->nfsd_getattcnt, snndc->nfsd_getattcnt, itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display network sockets statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_net_sock_stats(struct activity *a, int curr, int dispavg)\n{\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\tstatic unsigned long long\n\t\tavg_sock_inuse = 0,\n\t\tavg_tcp_inuse  = 0,\n\t\tavg_udp_inuse  = 0,\n\t\tavg_raw_inuse  = 0,\n\t\tavg_frag_inuse = 0,\n\t\tavg_tcp_tw     = 0;\n\tint g_fields[] = {0, 1, 5, 2, 3, 4};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snsc, NULL,\n\t\t\t\t     0, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genu64_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genu64_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_u64(NO_UNIT, 6, 9,\n\t\t\t    (unsigned long long) snsc->sock_inuse,\n\t\t\t    (unsigned long long) snsc->tcp_inuse,\n\t\t\t    (unsigned long long) snsc->udp_inuse,\n\t\t\t    (unsigned long long) snsc->raw_inuse,\n\t\t\t    (unsigned long long) snsc->frag_inuse,\n\t\t\t    (unsigned long long) snsc->tcp_tw);\n\n\t\t/* Will be used to compute the average */\n\t\tavg_sock_inuse += snsc->sock_inuse;\n\t\tavg_tcp_inuse  += snsc->tcp_inuse;\n\t\tavg_udp_inuse  += snsc->udp_inuse;\n\t\tavg_raw_inuse  += snsc->raw_inuse;\n\t\tavg_frag_inuse += snsc->frag_inuse;\n\t\tavg_tcp_tw     += snsc->tcp_tw;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_f(NO_UNIT, FALSE, 6, 9, 0,\n\t\t\t  (double) avg_sock_inuse / avg_count,\n\t\t\t  (double) avg_tcp_inuse  / avg_count,\n\t\t\t  (double) avg_udp_inuse  / avg_count,\n\t\t\t  (double) avg_raw_inuse  / avg_count,\n\t\t\t  (double) avg_frag_inuse / avg_count,\n\t\t\t  (double) avg_tcp_tw     / avg_count);\n\n\t\t/* Reset average counters */\n\t\tavg_sock_inuse = avg_tcp_inuse = avg_udp_inuse = 0;\n\t\tavg_raw_inuse = avg_frag_inuse = avg_tcp_tw = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display network sockets statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_sock_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstub_print_net_sock_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average network sockets statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_net_sock_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstub_print_net_sock_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display IP network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_ip_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 8, 9, 2,\n\t\t  S_VALUE(snip->InReceives,    snic->InReceives,    itv),\n\t\t  S_VALUE(snip->ForwDatagrams, snic->ForwDatagrams, itv),\n\t\t  S_VALUE(snip->InDelivers,    snic->InDelivers,    itv),\n\t\t  S_VALUE(snip->OutRequests,   snic->OutRequests,   itv),\n\t\t  S_VALUE(snip->ReasmReqds,    snic->ReasmReqds,    itv),\n\t\t  S_VALUE(snip->ReasmOKs,      snic->ReasmOKs,      itv),\n\t\t  S_VALUE(snip->FragOKs,       snic->FragOKs,       itv),\n\t\t  S_VALUE(snip->FragCreates,   snic->FragCreates,   itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IP network errors statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_eip_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 8, 9, 2,\n\t\t  S_VALUE(sneip->InHdrErrors,     sneic->InHdrErrors,     itv),\n\t\t  S_VALUE(sneip->InAddrErrors,    sneic->InAddrErrors,    itv),\n\t\t  S_VALUE(sneip->InUnknownProtos, sneic->InUnknownProtos, itv),\n\t\t  S_VALUE(sneip->InDiscards,      sneic->InDiscards,      itv),\n\t\t  S_VALUE(sneip->OutDiscards,     sneic->OutDiscards,     itv),\n\t\t  S_VALUE(sneip->OutNoRoutes,     sneic->OutNoRoutes,     itv),\n\t\t  S_VALUE(sneip->ReasmFails,      sneic->ReasmFails,      itv),\n\t\t  S_VALUE(sneip->FragFails,       sneic->FragFails,       itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMP network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_icmp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 14, 9, 2,\n\t\t  S_VALUE(snip->InMsgs,           snic->InMsgs,           itv),\n\t\t  S_VALUE(snip->OutMsgs,          snic->OutMsgs,          itv),\n\t\t  S_VALUE(snip->InEchos,          snic->InEchos,          itv),\n\t\t  S_VALUE(snip->InEchoReps,       snic->InEchoReps,       itv),\n\t\t  S_VALUE(snip->OutEchos,         snic->OutEchos,         itv),\n\t\t  S_VALUE(snip->OutEchoReps,      snic->OutEchoReps,      itv),\n\t\t  S_VALUE(snip->InTimestamps,     snic->InTimestamps,     itv),\n\t\t  S_VALUE(snip->InTimestampReps,  snic->InTimestampReps,  itv),\n\t\t  S_VALUE(snip->OutTimestamps,    snic->OutTimestamps,    itv),\n\t\t  S_VALUE(snip->OutTimestampReps, snic->OutTimestampReps, itv),\n\t\t  S_VALUE(snip->InAddrMasks,      snic->InAddrMasks,      itv),\n\t\t  S_VALUE(snip->InAddrMaskReps,   snic->InAddrMaskReps,   itv),\n\t\t  S_VALUE(snip->OutAddrMasks,     snic->OutAddrMasks,     itv),\n\t\t  S_VALUE(snip->OutAddrMaskReps,  snic->OutAddrMaskReps,  itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMP network errors statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_eicmp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 12, 9, 2,\n\t\t  S_VALUE(sneip->InErrors,        sneic->InErrors,        itv),\n\t\t  S_VALUE(sneip->OutErrors,       sneic->OutErrors,       itv),\n\t\t  S_VALUE(sneip->InDestUnreachs,  sneic->InDestUnreachs,  itv),\n\t\t  S_VALUE(sneip->OutDestUnreachs, sneic->OutDestUnreachs, itv),\n\t\t  S_VALUE(sneip->InTimeExcds,     sneic->InTimeExcds,     itv),\n\t\t  S_VALUE(sneip->OutTimeExcds,    sneic->OutTimeExcds,    itv),\n\t\t  S_VALUE(sneip->InParmProbs,     sneic->InParmProbs,     itv),\n\t\t  S_VALUE(sneip->OutParmProbs,    sneic->OutParmProbs,    itv),\n\t\t  S_VALUE(sneip->InSrcQuenchs,    sneic->InSrcQuenchs,    itv),\n\t\t  S_VALUE(sneip->OutSrcQuenchs,   sneic->OutSrcQuenchs,   itv),\n\t\t  S_VALUE(sneip->InRedirects,     sneic->InRedirects,     itv),\n\t\t  S_VALUE(sneip->OutRedirects,    sneic->OutRedirects,    itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display TCP network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_tcp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr],\n\t\t*sntp = (struct stats_net_tcp *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sntc, (void *) sntp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 4, 9, 2,\n\t\t  S_VALUE(sntp->ActiveOpens,  sntc->ActiveOpens,  itv),\n\t\t  S_VALUE(sntp->PassiveOpens, sntc->PassiveOpens, itv),\n\t\t  S_VALUE(sntp->InSegs,       sntc->InSegs,       itv),\n\t\t  S_VALUE(sntp->OutSegs,      sntc->OutSegs,      itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display TCP network errors statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_etcp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr],\n\t\t*snetp = (struct stats_net_etcp *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snetc, (void *) snetp,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 5, 9, 2,\n\t\t  S_VALUE(snetp->AttemptFails, snetc->AttemptFails, itv),\n\t\t  S_VALUE(snetp->EstabResets,  snetc->EstabResets,  itv),\n\t\t  S_VALUE(snetp->RetransSegs,  snetc->RetransSegs,  itv),\n\t\t  S_VALUE(snetp->InErrs,       snetc->InErrs,       itv),\n\t\t  S_VALUE(snetp->OutRsts,      snetc->OutRsts,      itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display UDP network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_udp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snuc, (void *) snup,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 4, 9, 2,\n\t\t  S_VALUE(snup->InDatagrams,  snuc->InDatagrams,  itv),\n\t\t  S_VALUE(snup->OutDatagrams, snuc->OutDatagrams, itv),\n\t\t  S_VALUE(snup->NoPorts,      snuc->NoPorts,      itv),\n\t\t  S_VALUE(snup->InErrors,     snuc->InErrors,     itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IPv6 sockets statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_net_sock6_stats(struct activity *a, int curr, int dispavg)\n{\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\tstatic unsigned long long\n\t\tavg_tcp6_inuse  = 0,\n\t\tavg_udp6_inuse  = 0,\n\t\tavg_raw6_inuse  = 0,\n\t\tavg_frag6_inuse = 0;\n\tint g_fields[] = {0, 1, 2, 3};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snsc, NULL,\n\t\t\t\t     0, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genu64_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genu64_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_u64(NO_UNIT, 4, 9,\n\t\t\t    (unsigned long long) snsc->tcp6_inuse,\n\t\t\t    (unsigned long long) snsc->udp6_inuse,\n\t\t\t    (unsigned long long) snsc->raw6_inuse,\n\t\t\t    (unsigned long long) snsc->frag6_inuse);\n\n\t\t/* Will be used to compute the average */\n\t\tavg_tcp6_inuse  += snsc->tcp6_inuse;\n\t\tavg_udp6_inuse  += snsc->udp6_inuse;\n\t\tavg_raw6_inuse  += snsc->raw6_inuse;\n\t\tavg_frag6_inuse += snsc->frag6_inuse;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_f(NO_UNIT, FALSE, 4, 9, 0,\n\t\t\t  (double) avg_tcp6_inuse  / avg_count,\n\t\t\t  (double) avg_udp6_inuse  / avg_count,\n\t\t\t  (double) avg_raw6_inuse  / avg_count,\n\t\t\t  (double) avg_frag6_inuse / avg_count);\n\n\t\t/* Reset average counters */\n\t\tavg_tcp6_inuse = avg_udp6_inuse = avg_raw6_inuse = avg_frag6_inuse = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IPv6 sockets statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_sock6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t      unsigned long long itv)\n{\n\tstub_print_net_sock6_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average IPv6 sockets statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_net_sock6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstub_print_net_sock6_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_ip6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip6 *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 10, 9, 2,\n\t\t  S_VALUE(snip->InReceives6,       snic->InReceives6,       itv),\n\t\t  S_VALUE(snip->OutForwDatagrams6, snic->OutForwDatagrams6, itv),\n\t\t  S_VALUE(snip->InDelivers6,       snic->InDelivers6,       itv),\n\t\t  S_VALUE(snip->OutRequests6,      snic->OutRequests6,      itv),\n\t\t  S_VALUE(snip->ReasmReqds6,       snic->ReasmReqds6,       itv),\n\t\t  S_VALUE(snip->ReasmOKs6,         snic->ReasmOKs6,         itv),\n\t\t  S_VALUE(snip->InMcastPkts6,      snic->InMcastPkts6,      itv),\n\t\t  S_VALUE(snip->OutMcastPkts6,     snic->OutMcastPkts6,     itv),\n\t\t  S_VALUE(snip->FragOKs6,          snic->FragOKs6,          itv),\n\t\t  S_VALUE(snip->FragCreates6,      snic->FragCreates6,      itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network errors statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_eip6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip6 *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 11, 9, 2,\n\t\t  S_VALUE(sneip->InHdrErrors6,     sneic->InHdrErrors6,     itv),\n\t\t  S_VALUE(sneip->InAddrErrors6,    sneic->InAddrErrors6,    itv),\n\t\t  S_VALUE(sneip->InUnknownProtos6, sneic->InUnknownProtos6, itv),\n\t\t  S_VALUE(sneip->InTooBigErrors6,  sneic->InTooBigErrors6,  itv),\n\t\t  S_VALUE(sneip->InDiscards6,      sneic->InDiscards6,      itv),\n\t\t  S_VALUE(sneip->OutDiscards6,     sneic->OutDiscards6,     itv),\n\t\t  S_VALUE(sneip->InNoRoutes6,      sneic->InNoRoutes6,      itv),\n\t\t  S_VALUE(sneip->OutNoRoutes6,     sneic->OutNoRoutes6,     itv),\n\t\t  S_VALUE(sneip->ReasmFails6,      sneic->ReasmFails6,      itv),\n\t\t  S_VALUE(sneip->FragFails6,       sneic->FragFails6,       itv),\n\t\t  S_VALUE(sneip->InTruncatedPkts6, sneic->InTruncatedPkts6, itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_icmp6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp6 *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 17, 9, 2,\n\t\t  S_VALUE(snip->InMsgs6,                    snic->InMsgs6,                    itv),\n\t\t  S_VALUE(snip->OutMsgs6,                   snic->OutMsgs6,                   itv),\n\t\t  S_VALUE(snip->InEchos6,                   snic->InEchos6,                   itv),\n\t\t  S_VALUE(snip->InEchoReplies6,             snic->InEchoReplies6,             itv),\n\t\t  S_VALUE(snip->OutEchoReplies6,            snic->OutEchoReplies6,            itv),\n\t\t  S_VALUE(snip->InGroupMembQueries6,        snic->InGroupMembQueries6,        itv),\n\t\t  S_VALUE(snip->InGroupMembResponses6,      snic->InGroupMembResponses6,      itv),\n\t\t  S_VALUE(snip->OutGroupMembResponses6,     snic->OutGroupMembResponses6,     itv),\n\t\t  S_VALUE(snip->InGroupMembReductions6,     snic->InGroupMembReductions6,     itv),\n\t\t  S_VALUE(snip->OutGroupMembReductions6,    snic->OutGroupMembReductions6,    itv),\n\t\t  S_VALUE(snip->InRouterSolicits6,          snic->InRouterSolicits6,          itv),\n\t\t  S_VALUE(snip->OutRouterSolicits6,         snic->OutRouterSolicits6,         itv),\n\t\t  S_VALUE(snip->InRouterAdvertisements6,    snic->InRouterAdvertisements6,    itv),\n\t\t  S_VALUE(snip->InNeighborSolicits6,        snic->InNeighborSolicits6,        itv),\n\t\t  S_VALUE(snip->OutNeighborSolicits6,       snic->OutNeighborSolicits6,       itv),\n\t\t  S_VALUE(snip->InNeighborAdvertisements6,  snic->InNeighborAdvertisements6,  itv),\n\t\t  S_VALUE(snip->OutNeighborAdvertisements6, snic->OutNeighborAdvertisements6, itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network errors statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_eicmp6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp6 *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 11, 9, 2,\n\t\t  S_VALUE(sneip->InErrors6,        sneic->InErrors6,        itv),\n\t\t  S_VALUE(sneip->InDestUnreachs6,  sneic->InDestUnreachs6,  itv),\n\t\t  S_VALUE(sneip->OutDestUnreachs6, sneic->OutDestUnreachs6, itv),\n\t\t  S_VALUE(sneip->InTimeExcds6,     sneic->InTimeExcds6,     itv),\n\t\t  S_VALUE(sneip->OutTimeExcds6,    sneic->OutTimeExcds6,    itv),\n\t\t  S_VALUE(sneip->InParmProblems6,  sneic->InParmProblems6,  itv),\n\t\t  S_VALUE(sneip->OutParmProblems6, sneic->OutParmProblems6, itv),\n\t\t  S_VALUE(sneip->InRedirects6,     sneic->InRedirects6,     itv),\n\t\t  S_VALUE(sneip->OutRedirects6,    sneic->OutRedirects6,    itv),\n\t\t  S_VALUE(sneip->InPktTooBigs6,    sneic->InPktTooBigs6,    itv),\n\t\t  S_VALUE(sneip->OutPktTooBigs6,   sneic->OutPktTooBigs6,   itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display UDPv6 network traffic statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_net_udp6_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp6 *) a->buf[prev];\n\tint g_fields[] = {0, 1, 2, 3};\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snuc, (void *) snup,\n\t\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_genf_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_genf_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\tcprintf_f(NO_UNIT, FALSE, 4, 9, 2,\n\t\t  S_VALUE(snup->InDatagrams6,  snuc->InDatagrams6,  itv),\n\t\t  S_VALUE(snup->OutDatagrams6, snuc->OutDatagrams6, itv),\n\t\t  S_VALUE(snup->NoPorts6,      snuc->NoPorts6,      itv),\n\t\t  S_VALUE(snup->InErrors6,     snuc->InErrors6,     itv));\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTrue if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_pwr_cpufreq_stats(struct activity *a, int curr, int dispavg)\n{\n\tint i;\n\tstruct stats_pwr_cpufreq *spc;\n\tstatic __nr_t nr_alloc = 0;\n\tstatic unsigned long long\n\t\t*avg_cpufreq = NULL;\n\tchar name[16];\n\n\tif (!avg_cpufreq || (a->nr[curr] > nr_alloc)) {\n\t\t/* Allocate array of CPU frequency */\n\t\tSREALLOC(avg_cpufreq, unsigned long long, sizeof(unsigned long long) * a->nr[curr]);\n\t\tif (a->nr[curr] > nr_alloc) {\n\t\t\t/* Init additional space allocated */\n\t\t\tmemset(avg_cpufreq + nr_alloc, 0,\n\t\t\t       sizeof(unsigned long long) * (a->nr[curr] - nr_alloc));\n\t\t}\n\t\tnr_alloc = a->nr[curr];\n\t}\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\tif (dish && !(dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 7, 9, NULL);\n\t}\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_pwr_cpufreq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * spc = (struct stats_pwr_cpufreq *) a->buf[...] + i;\n\t\t */\n\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (!spc->cpufreq)\n\t\t\t/* This CPU is offline: Don't display it */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note: @nr[curr] is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(name, \"     all\");\n\t\t}\n\t\telse {\n\t\t\tsnprintf(name, sizeof(name), \"     %3d\", i - 1);\n\t\t\tname[sizeof(name) - 1] = '\\0';\n\t\t}\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (!dispavg) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_minmax(a, i * a->xnr, ((double) spc->cpufreq) / 100);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 7, 9, NULL);\n\t\t\t\tprint_pwr_cpufreq_xstats(H_MIN, name, a->spmin + i * a->xnr);\n\t\t\t\tprint_pwr_cpufreq_xstats(H_MAX, name, a->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\t\tcprintf_in(IS_STR, \"%s\", name, 0);\n\n\t\tif (!dispavg) {\n\t\t\t/* Display instantaneous values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  ((double) spc->cpufreq) / 100);\n\n\t\t\t/*\n\t\t\t * Will be used to compute the average.\n\t\t\t * Note: Overflow unlikely to happen but not impossible...\n\t\t\t */\n\t\t\tavg_cpufreq[i] += spc->cpufreq;\n\t\t}\n\t\telse {\n\t\t\t/* Display average values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  (double) avg_cpufreq[i] / (100 * avg_count));\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (dispavg && avg_cpufreq) {\n\t\t/* Array of CPU frequency no longer needed: Free it! */\n\t\tfree(avg_cpufreq);\n\t\tavg_cpufreq = NULL;\n\t\tnr_alloc = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pwr_cpufreq_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstub_print_pwr_cpufreq_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average CPU frequency statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_pwr_cpufreq_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\t    unsigned long long itv)\n{\n\tstub_print_pwr_cpufreq_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display fan statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTrue if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_pwr_fan_stats(struct activity *a, int curr, int dispavg)\n{\n\tint i;\n\tstruct stats_pwr_fan *spc;\n\tstatic __nr_t nr_alloc = 0;\n\tstatic double *avg_fan = NULL;\n\tstatic double *avg_fan_min = NULL;\n\n\t/* Allocate arrays of fan RPMs */\n\tif (!avg_fan || (a->nr[curr] > nr_alloc)) {\n\t\tSREALLOC(avg_fan, double, sizeof(double) * a->nr[curr]);\n\t\tSREALLOC(avg_fan_min, double, sizeof(double) * a->nr[curr]);\n\n\t\tif (a->nr[curr] > nr_alloc) {\n\t\t\t/* Init additional space allocated */\n\t\t\tmemset(avg_fan + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t\tmemset(avg_fan_min + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t}\n\t\tnr_alloc = a->nr[curr];\n\t}\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\tif (dish && !(dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -2, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (!dispavg) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_minmax(a, i * a->xnr, spc->rpm);\n\t\t\t\tsave_minmax(a, i * a->xnr + 1, spc->rpm - spc->rpm_min);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -2, 9, NULL);\n\t\t\t\tprint_pwr_fan_xstats(H_MIN, i, spc->device,\n\t\t\t\t\t\t     a->spmin + i * a->xnr);\n\t\t\t\tprint_pwr_fan_xstats(H_MAX, i, spc->device,\n\t\t\t\t\t\t     a->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\t\tcprintf_in(IS_INT, \"     %5d\", \"\", i + 1);\n\n\t\tif (dispavg) {\n\t\t\t/* Display average values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t\t\t  (double) avg_fan[i] / avg_count,\n\t\t\t\t  (double) (avg_fan[i] - avg_fan_min[i]) / avg_count);\n\t\t}\n\t\telse {\n\t\t\t/* Display instantaneous values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2,\n\t\t\t\t  spc->rpm,\n\t\t\t\t  spc->rpm - spc->rpm_min);\n\t\t\tavg_fan[i]     += spc->rpm;\n\t\t\tavg_fan_min[i] += spc->rpm_min;\n\t\t}\n\n\t\tcprintf_in(IS_STR, \" %s\\n\", spc->device, 0);\n\t}\n\n\tif (dispavg && avg_fan) {\n\t\tfree(avg_fan);\n\t\tfree(avg_fan_min);\n\t\tavg_fan = NULL;\n\t\tavg_fan_min = NULL;\n\t\tnr_alloc = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Display fan statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pwr_fan_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstub_print_pwr_fan_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average fan statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_pwr_fan_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstub_print_pwr_fan_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display device temperature statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTrue if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_pwr_temp_stats(struct activity *a, int curr, int dispavg)\n{\n\tint i;\n\tstruct stats_pwr_temp *spc;\n\tdouble temppct;\n\tstatic __nr_t nr_alloc = 0;\n\tstatic double *avg_temp = NULL;\n\tstatic double *avg_temp_min = NULL, *avg_temp_max = NULL;\n\n\t/* Allocate arrays of temperatures */\n\tif (!avg_temp || (a->nr[curr] > nr_alloc)) {\n\t\tSREALLOC(avg_temp, double, sizeof(double) * a->nr[curr]);\n\t\tSREALLOC(avg_temp_min, double, sizeof(double) * a->nr[curr]);\n\t\tSREALLOC(avg_temp_max, double, sizeof(double) * a->nr[curr]);\n\n\t\tif (a->nr[curr] > nr_alloc) {\n\t\t\t/* Init additional space allocated */\n\t\t\tmemset(avg_temp + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t\tmemset(avg_temp_min + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t\tmemset(avg_temp_max + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t}\n\t\tnr_alloc = a->nr[curr];\n\t}\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\tif (dish && !(dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -2, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\ttemppct = (spc->temp_max - spc->temp_min)\n\t\t\t  ? (spc->temp - spc->temp_min) / (spc->temp_max - spc->temp_min) * 100\n\t\t\t  : 0.0;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (!dispavg) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_minmax(a, i * a->xnr, spc->temp);\n\t\t\t\tsave_minmax(a, i * a->xnr + 1, temppct);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -2, 9, NULL);\n\t\t\t\tprint_pwr_sensor_xstats(H_MIN, i + 1, spc->device,\n\t\t\t\t\t\t\ta->spmin + i * a->xnr);\n\t\t\t\tprint_pwr_sensor_xstats(H_MAX, i + 1, spc->device,\n\t\t\t\t\t\t\ta->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\t\tcprintf_in(IS_INT, \"     %5d\", \"\", i + 1);\n\n\t\tif (dispavg) {\n\t\t\t/* Display average values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, (double) avg_temp[i] / avg_count);\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t\t   (avg_temp_max[i] - avg_temp_min[i]) ?\n\t\t\t\t   ((double) (avg_temp[i] / avg_count) - avg_temp_min[i]) / (avg_temp_max[i] - avg_temp_min[i]) * 100\n\t\t\t\t   : 0.0);\n\t\t}\n\t\telse {\n\t\t\t/* Display instantaneous values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, spc->temp);\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, temppct);\n\t\t\tavg_temp[i] += spc->temp;\n\t\t\t/* Assume that min and max temperatures cannot vary */\n\t\t\tavg_temp_min[i] = spc->temp_min;\n\t\t\tavg_temp_max[i] = spc->temp_max;\n\t\t}\n\n\t\tcprintf_in(IS_STR, \" %s\\n\", spc->device, 0);\n\t}\n\n\tif (dispavg && avg_temp) {\n\t\tfree(avg_temp);\n\t\tfree(avg_temp_min);\n\t\tfree(avg_temp_max);\n\t\tavg_temp = NULL;\n\t\tavg_temp_min = NULL;\n\t\tavg_temp_max = NULL;\n\t\tnr_alloc = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pwr_temp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstub_print_pwr_temp_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average temperature statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_pwr_temp_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstub_print_pwr_temp_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTrue if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_pwr_in_stats(struct activity *a, int curr, int dispavg)\n{\n\tint i;\n\tstruct stats_pwr_in *spc;\n\tdouble inpct;\n\tstatic __nr_t nr_alloc = 0;\n\tstatic double *avg_in = NULL;\n\tstatic double *avg_in_min = NULL, *avg_in_max = NULL;\n\n\t/* Allocate arrays of voltage inputs */\n\tif (!avg_in || (a->nr[curr] > nr_alloc)) {\n\t\tSREALLOC(avg_in, double, sizeof(double) * a->nr[curr]);\n\t\tSREALLOC(avg_in_min, double, sizeof(double) * a->nr[curr]);\n\t\tSREALLOC(avg_in_max, double, sizeof(double) * a->nr[curr]);\n\n\t\tif (a->nr[curr] > nr_alloc) {\n\t\t\t/* Init additional space allocated */\n\t\t\tmemset(avg_in + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t\tmemset(avg_in_min + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t\tmemset(avg_in_max + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t}\n\t\tnr_alloc = a->nr[curr];\n\t}\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\tif (dish && !(dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -2, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tinpct = (spc->in_max - spc->in_min)\n\t\t\t? (spc->in - spc->in_min) / (spc->in_max - spc->in_min) * 100\n\t\t\t: 0.0;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (!dispavg) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_minmax(a, i * a->xnr, spc->in);\n\t\t\t\tsave_minmax(a, i * a->xnr + 1, inpct);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -2, 9, NULL);\n\t\t\t\tprint_pwr_sensor_xstats(H_MIN, i, spc->device,\n\t\t\t\t\t\t\ta->spmin + i * a->xnr);\n\t\t\t\tprint_pwr_sensor_xstats(H_MAX, i, spc->device,\n\t\t\t\t\t\t\ta->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\t\tcprintf_in(IS_INT, \"     %5d\", \"\", i);\n\n\t\tif (dispavg) {\n\t\t\t/* Display average values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, (double) avg_in[i] / avg_count);\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t\t   (avg_in_max[i] - avg_in_min[i]) ?\n\t\t\t\t   ((double) (avg_in[i] / avg_count) - avg_in_min[i]) / (avg_in_max[i] - avg_in_min[i]) * 100\n\t\t\t\t   : 0.0);\n\t\t}\n\t\telse {\n\t\t\t/* Display instantaneous values */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, spc->in);\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, inpct);\n\t\t\tavg_in[i] += spc->in;\n\t\t\t/* Assume that min and max voltage inputs cannot vary */\n\t\t\tavg_in_min[i] = spc->in_min;\n\t\t\tavg_in_max[i] = spc->in_max;\n\t\t}\n\n\t\tcprintf_in(IS_STR, \" %s\\n\", spc->device, 0);\n\t}\n\n\tif (dispavg && avg_in) {\n\t\tfree(avg_in);\n\t\tfree(avg_in_min);\n\t\tfree(avg_in_max);\n\t\tavg_in = NULL;\n\t\tavg_in_min = NULL;\n\t\tavg_in_max = NULL;\n\t\tnr_alloc = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pwr_in_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstub_print_pwr_in_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average voltage inputs statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_pwr_in_stats(struct activity *a, int prev, int curr,\n\t\t\t\t       unsigned long long itv)\n{\n\tstub_print_pwr_in_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics. This function is used to\n * display instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_huge_stats(struct activity *a, int curr, int dispavg)\n{\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\tstatic unsigned long long\n\t\tavg_frhkb = 0,\n\t\tavg_tlhkb = 0,\n\t\tavg_rsvdhkb = 0,\n\t\tavg_surphkb = 0;\n\tint unit = NO_UNIT;\n\tdouble hugpct;\n\tint g_fields[] = {0, -1, 3, 4};\n\n\tif (DISPLAY_UNIT(flags)) {\n\t\t/* Default values unit is kB */\n\t\tunit = UNIT_KILOBYTE;\n\t}\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || (dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\t/* Compute %hugused value */\n\thugpct = smc->tlhkb ? SP_VALUE(smc->frhkb, smc->tlhkb, smc->tlhkb) : 0.0;\n\n\t/* Check if min and max values should be displayed */\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (!dispavg) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) smc, NULL, 0,\n\t\t\t\t     a->spmin, a->spmax, g_fields);\n\n\t\t\t/* Save min and max values for kbhugused and %hugused */\n\t\t\tsave_minmax(a, 1, (double) (smc->tlhkb - smc->frhkb));\n\t\t\tsave_minmax(a, 2, hugpct);\n\t\t}\n\t\telse {\n\t\t\t/* Display min and max values */\n\t\t\tprint_huge_xstats(H_MIN, unit, a->spmin);\n\t\t\tprint_huge_xstats(H_MAX, unit, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_u64(unit, 2, 9,\n\t\t\t    (unsigned long long) smc->frhkb,\n\t\t\t    (unsigned long long) (smc->tlhkb - smc->frhkb));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t   smc->tlhkb ?\n\t\t\t   SP_VALUE(smc->frhkb, smc->tlhkb, smc->tlhkb) : 0.0);\n\t\tcprintf_u64(unit, 2, 9,\n\t\t\t    (unsigned long long) smc->rsvdhkb,\n\t\t\t    (unsigned long long) (smc->surphkb));\n\n\t\t/* Will be used to compute the average */\n\t\tavg_frhkb += smc->frhkb;\n\t\tavg_tlhkb += smc->tlhkb;\n\t\tavg_rsvdhkb += smc->rsvdhkb;\n\t\tavg_surphkb += smc->surphkb;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_f(unit, FALSE, 2, 9, 0,\n\t\t\t  (double) avg_frhkb / avg_count,\n\t\t\t  ((double) avg_tlhkb / avg_count) -\n\t\t\t  ((double) avg_frhkb / avg_count));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2,\n\t\t\t   avg_tlhkb ?\n\t\t\t   SP_VALUE((double) avg_frhkb / avg_count,\n\t\t\t\t    (double) avg_tlhkb / avg_count,\n\t\t\t\t    (double) avg_tlhkb / avg_count) : 0.0);\n\t\tcprintf_f(unit, FALSE, 2, 9, 0,\n\t\t\t  (double) avg_rsvdhkb / avg_count,\n\t\t\t  (double) avg_surphkb / avg_count);\n\n\t\t/* Reset average counters */\n\t\tavg_frhkb = avg_tlhkb = avg_rsvdhkb = avg_surphkb = 0;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_huge_stats(struct activity *a, int prev, int curr,\n\t\t\t\t unsigned long long itv)\n{\n\tstub_print_huge_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_huge_stats(struct activity *a, int prev, int curr,\n\t\t\t\t     unsigned long long itv)\n{\n\tstub_print_huge_stats(a, curr, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display CPU weighted frequency statistics. This function is used to\n * display instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid print_pwr_wghfreq_stats(struct activity *a, int prev, int curr,\n\t\t\t     unsigned long long itv)\n{\n\tint i, k;\n\tstruct stats_pwr_wghfreq *spc, *spp, *spc_k, *spp_k;\n\tunsigned long long tis, tisfreq;\n\tdouble wghmhz;\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\tif (dish && !((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 7, 9, NULL);\n\t}\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_pwr_wghfreq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * spc = (struct stats_pwr_wghfreq *) a->buf[...] + i;\n\t\t */\n\t\tspc = (struct stats_pwr_wghfreq *) ((char *) a->buf[curr] + i * a->msize * a->nr2);\n\t\tspp = (struct stats_pwr_wghfreq *) ((char *) a->buf[prev] + i * a->msize * a->nr2);\n\n\t\t/*\n\t\t * Note: a->nr is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (prev == 2) {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 7, 9, NULL);\n\t\t\t\tprint_pwr_wghfreq_xstats(H_MIN, i, a->spmin + i * a->xnr);\n\t\t\t\tprint_pwr_wghfreq_xstats(H_MAX, i, a->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\t/* Yes: Display it */\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tcprintf_in(IS_STR, \"%s\", \"     all\", 0);\n\t\t}\n\t\telse {\n\t\t\tcprintf_in(IS_INT, \"     %3d\", \"\", i - 1);\n\t\t}\n\n\t\ttisfreq = 0;\n\t\ttis = 0;\n\n\t\tfor (k = 0; k < a->nr2; k++) {\n\n\t\t\tspc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * a->msize);\n\t\t\tif (!spc_k->freq)\n\t\t\t\tbreak;\n\t\t\tspp_k = (struct stats_pwr_wghfreq *) ((char *) spp + k * a->msize);\n\n\t\t\ttisfreq += (spc_k->freq / 1000) *\n\t\t\t           (spc_k->time_in_state - spp_k->time_in_state);\n\t\t\ttis     += (spc_k->time_in_state - spp_k->time_in_state);\n\t\t}\n\n\t\t/* Compute wghMHz value for current CPU */\n\t\twghmhz = tis ? ((double) tisfreq) / tis : 0.0;\n\n\t\tif (DISPLAY_MINMAX(flags) && (prev != 2)) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_minmax(a, i * a->xnr, wghmhz);\n\t\t}\n\n\t\t/* Display weighted frequency for current CPU */\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, wghmhz);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display USB devices statistics. This function is used to\n * display instantaneous and summary statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\nvoid stub_print_pwr_usb_stats(struct activity *a, int curr, int dispavg)\n{\n\tint i, j;\n\tchar fmt[16];\n\tstruct stats_pwr_usb *suc, *sum;\n\n\tif (dish) {\n\t\tprintf(\"\\n%-11s     BUS  idvendor    idprod  maxpower\",\n\t\t       (dispavg ? _(\"Summary:\") : timestamp[!curr]));\n\t\tprintf(\" %-*s product\\n\", MAX_MANUF_LEN - 1, \"manufact\");\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsuc = (struct stats_pwr_usb *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tprintf(\"%-11s\", (dispavg ? _(\"Summary:\") : timestamp[curr]));\n\t\tcprintf_in(IS_INT, \"  %6d\", \"\", suc->bus_nr);\n\t\tcprintf_x(2, 9,\n\t\t\t  suc->vendor_id,\n\t\t\t  suc->product_id);\n\t\tcprintf_u64(NO_UNIT, 1, 9,\n\t\t\t    /* bMaxPower is expressed in 2 mA units */\n\t\t\t    (unsigned long long) (suc->bmaxpower << 1));\n\n\t\tsnprintf(fmt, sizeof(fmt), \" %%-%ds\", MAX_MANUF_LEN - 1);\n\t\tcprintf_s(IS_STR, fmt, suc->manufacturer);\n\t\tcprintf_s(IS_STR, \" %s\\n\", suc->product);\n\n\t\tif (!dispavg) {\n\t\t\t/* Save current USB device in summary list */\n\t\t\tfor (j = 0; j < a->nr_allocated; j++) {\n\t\t\t\tsum = (struct stats_pwr_usb *) ((char *) a->buf[2] + j * a->msize);\n\n\t\t\t\tif ((sum->bus_nr     == suc->bus_nr) &&\n\t\t\t\t    (sum->vendor_id  == suc->vendor_id) &&\n\t\t\t\t    (sum->product_id == suc->product_id))\n\t\t\t\t\t/* USB device found in summary list */\n\t\t\t\t\tbreak;\n\t\t\t\tif (!sum->bus_nr) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Current slot is free:\n\t\t\t\t\t * Save USB device in summary list.\n\t\t\t\t\t */\n\t\t\t\t\t*sum = *suc;\n\t\t\t\t\ta->nr[2] = j + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == a->nr_allocated) {\n\t\t\t\t/*\n\t\t\t\t * No free slot has been found for current device.\n\t\t\t\t * So enlarge buffers then save device in list.\n\t\t\t\t */\n\t\t\t\treallocate_buffers(a, j, flags);\n\t\t\t\tsum = (struct stats_pwr_usb *) ((char *) a->buf[2] + j * a->msize);\n\t\t\t\t*sum = *suc;\n\t\t\t\ta->nr[2] = j + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display USB devices statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pwr_usb_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstub_print_pwr_usb_stats(a, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average USB devices statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_pwr_usb_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstub_print_pwr_usb_stats(a, 2, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display filesystems statistics. This function is used to\n * display instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n ***************************************************************************\n */\n__print_funct_t stub_print_filesystem_stats(struct activity *a, int prev, int curr, int dispavg)\n{\n\tint i, j, j0, found;\n\tstruct stats_filesystem *sfc, *sfp, *sfm;\n\tint unit = NO_UNIT;\n\tchar *dev_name;\n\tdouble mbfsfree, mbfsused, fsusedpct, ufsusedpct, iusedpct;\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\tif (DISPLAY_UNIT(flags)) {\n\t\t/* Default values unit is B */\n\t\tunit = UNIT_BYTE;\n\t}\n\n\tif ((dish || DISPLAY_ZERO_OMIT(flags)) &&\n\t\t!(dispavg && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line((dispavg ? _(\"Summary:\") : timestamp[!curr]),\n\t\t\t\ta, FIRST + DISPLAY_MOUNT(a->opt_flags), -1, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfound = FALSE;\n\t\tif (DISPLAY_ZERO_OMIT(flags) && !dispavg) {\n\n\t\t\tif (a->nr[prev] > 0) {\n\t\t\t\t/* Look for corresponding fs in previous iteration */\n\t\t\t\tj = i;\n\n\t\t\t\tif (j >= a->nr[prev]) {\n\t\t\t\t\tj = a->nr[prev] - 1;\n\t\t\t\t}\n\n\t\t\t\tj0 = j;\n\n\t\t\t\tdo {\n\t\t\t\t\tsfp = (struct stats_filesystem *) ((char *) a->buf[prev] + j * a->msize);\n\t\t\t\t\tif (!strcmp(sfp->fs_name, sfc->fs_name)) {\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (++j >= a->nr[prev]) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j != j0);\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) &&\n\t\t    found &&\n\t\t    !memcmp(sfp, sfc, STATS_FILESYSTEM_SIZE2CMP))\n\t\t\tcontinue;\n\n\t\t/* Compute metrics */\n\t\tmbfsfree = (unit < 0 ? (double) sfc->f_bfree / 1024 / 1024\n\t\t\t\t     : (double) sfc->f_bfree);\n\t\tmbfsused = (unit < 0 ? (double) (sfc->f_blocks - sfc->f_bfree) / 1024 / 1024\n\t\t\t\t     : (double) (sfc->f_blocks - sfc->f_bfree));\n\t\t/* f_blocks is not zero. But test it anyway ;-) */\n\t\tfsusedpct = (sfc->f_blocks ? SP_VALUE(sfc->f_bfree, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t\t   : 0.0);\n\t\tufsusedpct = (sfc->f_blocks ? SP_VALUE(sfc->f_bavail, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t\t    : 0.0);\n\t\tiusedpct = (sfc->f_files ? SP_VALUE(sfc->f_ffree, sfc->f_files, sfc->f_files)\n\t\t\t\t\t : 0.0);\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tint k, pos;\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), dev_name, MAX_FS_LEN, &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (!dispavg) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_minmax(a, pos, mbfsfree);\n\t\t\t\tsave_minmax(a, pos + 1, mbfsused);\n\t\t\t\tsave_minmax(a, pos + 2, fsusedpct);\n\t\t\t\tsave_minmax(a, pos + 3, ufsusedpct);\n\t\t\t\tsave_minmax(a, pos + 4, (double) sfc->f_ffree);\n\t\t\t\tsave_minmax(a, pos + 5, (double) (sfc->f_files - sfc->f_ffree));\n\t\t\t\tsave_minmax(a, pos + 6, iusedpct);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(_(\"Summary:\"), a,\n\t\t\t\t\t       FIRST + DISPLAY_MOUNT(a->opt_flags), -1, 9, NULL);\n\t\t\t\tprint_filesystem_xstats(H_MIN, unit, dev_name,\n\t\t\t\t\t\t\ta->spmin + pos);\n\t\t\t\tprint_filesystem_xstats(H_MAX, unit, dev_name,\n\t\t\t\t\t\t\ta->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * \"Last:\": This corresponds to the last values displayed (collected)\n\t\t * for this filesystem (displayed as \"Summary\" when option -x not used).\n\t\t */\n\t\tprintf(\"%-11s\", (dispavg ? (DISPLAY_MINMAX(flags) ? _(\"Last:\")\n\t\t\t\t\t\t\t\t  : _(\"Summary:\"))\n\t\t\t\t\t : timestamp[curr]));\n\t\tcprintf_f(unit, FALSE, 2, 9, 0, mbfsfree, mbfsused);\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 2, 9, 2,\n\t\t\t    fsusedpct, ufsusedpct);\n\t\tcprintf_u64(NO_UNIT, 2, 9,\n\t\t\t    (unsigned long long) sfc->f_ffree,\n\t\t\t    (unsigned long long) (sfc->f_files - sfc->f_ffree));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, iusedpct);\n\t\tcprintf_in(IS_STR, \" %s\\n\", dev_name, 0);\n\n\t\tif (!dispavg) {\n\t\t\t/* Save current filesystem in summary list */\n\t\t\tfor (j = 0; j < a->nr_allocated; j++) {\n\t\t\t\tsfm = (struct stats_filesystem *) ((char *) a->buf[2] + j * a->msize);\n\n\t\t\t\tif (!strcmp(sfm->fs_name, sfc->fs_name) ||\n\t\t\t\t    !sfm->f_blocks) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Filesystem found in list (then save again its stats)\n\t\t\t\t\t * or free slot (end of list).\n\t\t\t\t\t */\n\t\t\t\t\t*sfm = *sfc;\n\t\t\t\t\tif (j >= a->nr[2]) {\n\t\t\t\t\t\ta->nr[2] = j + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == a->nr_allocated) {\n\t\t\t\t/*\n\t\t\t\t * No free slot has been found for current filesystem.\n\t\t\t\t * So enlarge buffers then save filesystem in list.\n\t\t\t\t */\n\t\t\t\treallocate_buffers(a, j, flags);\n\t\t\t\tsfm = (struct stats_filesystem *) ((char *) a->buf[2] + j * a->msize);\n\t\t\t\t*sfm = *sfc;\n\t\t\t\ta->nr[2] = j + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display filesystems statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_filesystem_stats(struct activity *a, int prev, int curr,\n\t\t\t\t       unsigned long long itv)\n{\n\tstub_print_filesystem_stats(a, prev, curr, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average filesystems statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_filesystem_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\t   unsigned long long itv)\n{\n\tstub_print_filesystem_stats(a, prev, 2, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_fchost_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_fchost *sfcc, *sfcp, sfczero;\n\tint g_fields[] = {0, 1, 2, 3};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\tmemset(&sfczero, 0, sizeof(struct stats_fchost));\n\n\tif (dish && !((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -1, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (WANT_SINCE_BOOT(flags)) {\n\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[prev]);\n\t\t\tfound = TRUE;\n\t\t}\n\t\telse {\n\t\t\tfound = FALSE;\n\n\t\t\tif (a->nr[prev] > 0) {\n\t\t\t\t/* Look for corresponding structure in previous iteration */\n\t\t\t\tj = i;\n\n\t\t\t\tif (j >= a->nr[prev]) {\n\t\t\t\t\tj = a->nr[prev] - 1;\n\t\t\t\t}\n\n\t\t\t\tj0 = j;\n\n\t\t\t\tdo {\n\t\t\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[prev] + j * a->msize);\n\t\t\t\t\tif (!strcmp(sfcc->fchost_name, sfcp->fchost_name)) {\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (++j >= a->nr[prev]) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j != j0);\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\t/* This is a newly registered host */\n\t\t\tsfcp = &sfczero;\n\t\t}\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tint k = 0, pos;\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), sfcc->fchost_name, MAX_FCH_LEN, &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_extrema(a->gtypes_nr, (void *) sfcc, (void *) sfcp,\n\t\t\t\t\t     itv, a->spmin + pos, a->spmax + pos, g_fields);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, -1, 9, NULL);\n\t\t\t\tprint_fchost_xstats(H_MIN, sfcc->fchost_name, a->spmin + pos);\n\t\t\t\tprint_fchost_xstats(H_MAX, sfcc->fchost_name, a->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tcprintf_f(NO_UNIT, FALSE, 4, 9, 2,\n\t\t\t  S_VALUE(sfcp->f_rxframes, sfcc->f_rxframes, itv),\n\t\t\t  S_VALUE(sfcp->f_txframes, sfcc->f_txframes, itv),\n\t\t\t  S_VALUE(sfcp->f_rxwords,  sfcc->f_rxwords,  itv),\n\t\t\t  S_VALUE(sfcp->f_txwords,  sfcc->f_txwords,  itv));\n\t\tcprintf_in(IS_STR, \" %s\\n\", sfcc->fchost_name, 0);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n * @dispavg\tTrue if displaying average statistics.\n ***************************************************************************\n */\n__print_funct_t stub_print_softnet_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\t unsigned long long itv, int dispavg)\n{\n\tint i;\n\tstruct stats_softnet\n\t\t*ssnc = (struct stats_softnet *) a->buf[curr],\n\t\t*ssnp = (struct stats_softnet *) a->buf[prev];\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tstatic __nr_t nr_alloc = 0;\n\tstatic unsigned long long *avg_blg_len = NULL;\n\tunsigned int local_types_nr[] = {0, 0, 5};\n\tint g_fields[] = {0, 1, 2, 3, 4};\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\tif ((dish || DISPLAY_ZERO_OMIT(flags)) &&\n\t    !((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 7, 9, NULL);\n\t}\n\n\t/*\n\t * @nr[curr] cannot normally be greater than @nr_ini\n\t * (since @nr_ini counts up all CPU, even those offline).\n\t * If this happens, it may be because the machine has been\n\t * restarted with more CPU and no LINUX_RESTART has been\n\t * inserted in file.\n\t */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Allocate array for CPU backlog lengths */\n\tif (!avg_blg_len || (a->nr_ini > nr_alloc)) {\n\t\tSREALLOC(avg_blg_len, unsigned long long, sizeof(unsigned long long) * a->nr_ini);\n\n\t\tif (a->nr_ini > nr_alloc) {\n\t\t\t/* Init additional space allocated */\n\t\t\tmemset(avg_blg_len + nr_alloc, 0,\n\t\t\t       sizeof(unsigned long long) * (a->nr_ini - nr_alloc));\n\t\t}\n\t\tnr_alloc = a->nr_ini;\n\t}\n\n\t/* Compute statistics for CPU \"all\" */\n\tget_global_soft_statistics(a, prev, curr, flags, offline_cpu_bitmap);\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * Should current CPU (including CPU \"all\") be displayed?\n\t\t * Note: a->nr is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_pwr_cpufreq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * ssnc = (struct stats_softnet *) a->buf[...] + i;\n                 */\n                ssnc = (struct stats_softnet *) ((char *) a->buf[curr] + i * a->msize);\n                ssnp = (struct stats_softnet *) ((char *) a->buf[prev] + i * a->msize);\n\n\t\tif (DISPLAY_ZERO_OMIT(flags) && !memcmp(ssnp, ssnc, STATS_SOFTNET_SIZE))\n\t\t\tcontinue;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tif (!dispavg) {\n\t\t\t\t/* Save min and max values */\n\t\t\t\tsave_extrema(local_types_nr, (void *) ssnc, (void *) ssnp,\n\t\t\t\t\t     itv, a->spmin + i * a->xnr, a->spmax + i * a->xnr,\n\t\t\t\t\t     g_fields);\n\n\t\t\t\t/* Save min and max values for blg_len */\n\t\t\t\tsave_minmax(a, i * a->xnr + 5, (double) ssnc->backlog_len);\n\t\t\t}\n\t\t\telse if ((*(a->spmin + i * a->xnr) != DBL_MAX) &&\n\t\t\t\t(*(a->spmax + i * a->xnr) != -DBL_MAX)) {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 7, 9, NULL);\n\t\t\t\tprint_softnet_xstats(H_MIN, i, a->spmin + i * a->xnr);\n\t\t\t\tprint_softnet_xstats(H_MAX, i, a->spmax + i * a->xnr);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tcprintf_in(IS_STR, \" %s\", \"    all\", 0);\n\t\t}\n\t\telse {\n\t\t\tcprintf_in(IS_INT, \" %7d\", \"\", i - 1);\n\t\t}\n\n\t\tcprintf_f(NO_UNIT, FALSE, 5, 9, 2,\n\t\t\t  S_VALUE(ssnp->processed,    ssnc->processed,    itv),\n\t\t\t  S_VALUE(ssnp->dropped,      ssnc->dropped,      itv),\n\t\t\t  S_VALUE(ssnp->time_squeeze, ssnc->time_squeeze, itv),\n\t\t\t  S_VALUE(ssnp->received_rps, ssnc->received_rps, itv),\n\t\t\t  S_VALUE(ssnp->flow_limit,   ssnc->flow_limit,   itv));\n\n\t\tif (!dispavg) {\n\t\t\t/* Display instantaneous value */\n\t\t\tcprintf_u64(NO_UNIT, 1, 9,\n\t\t\t\t    (unsigned long long) ssnc->backlog_len);\n\n\t\t\t/* Used to compute average value */\n\t\t\tavg_blg_len[i] += (unsigned long long ) ssnc->backlog_len;\n\t\t}\n\t\telse {\n\t\t\t/* Display average value */\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 0,\n\t\t\t\t  (double) avg_blg_len[i] / avg_count);\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (dispavg && avg_blg_len) {\n\t\tfree(avg_blg_len);\n\t\tavg_blg_len = NULL;\n\t\tnr_alloc = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_softnet_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstub_print_softnet_stats(a, prev, curr, itv, FALSE);\n}\n\n/*\n ***************************************************************************\n * Display average softnet statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_softnet_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstub_print_softnet_stats(a, prev, curr, itv, TRUE);\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid stub_print_psicpu_stats(struct activity *a, int prev, int curr, int dispavg,\n\t\t\t     unsigned long long itv)\n{\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr],\n\t\t*psip = (struct stats_psi_cpu *) a->buf[prev];\n\tstatic unsigned long long\n\t\ts_avg10  = 0,\n\t\ts_avg60  = 0,\n\t\ts_avg300 = 0;\n\tdouble scpupct;\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\t/* Compute %scpu value */\n\tscpupct = ((double) psic->some_cpu_total - psip->some_cpu_total) / (100 * itv);\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_minmax(a, 0, (double) psic->some_acpu_10  / 100);\n\t\t\tsave_minmax(a, 1, (double) psic->some_acpu_60  / 100);\n\t\t\tsave_minmax(a, 2, (double) psic->some_acpu_300 / 100);\n\t\t\tsave_minmax(a, 3, scpupct);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_psi_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_psi_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) psic->some_acpu_10  / 100,\n\t\t\t   (double) psic->some_acpu_60  / 100,\n\t\t\t   (double) psic->some_acpu_300 / 100);\n\n\t\t/* Will be used to compute the average */\n\t\ts_avg10  += psic->some_acpu_10;\n\t\ts_avg60  += psic->some_acpu_60;\n\t\ts_avg300 += psic->some_acpu_300;\n\t}\n\telse {\n\t\t/* Display average values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) s_avg10  / (avg_count * 100),\n\t\t\t   (double) s_avg60  / (avg_count * 100),\n\t\t\t   (double) s_avg300 / (avg_count * 100));\n\n\t\t/* Reset average counters */\n\t\ts_avg10 = s_avg60 = s_avg300 = 0;\n\t}\n\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, scpupct);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_psicpu_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstub_print_psicpu_stats(a, prev, curr, FALSE, itv);\n}\n\n/*\n ***************************************************************************\n * Display average pressure-stall CPU statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_psicpu_stats(struct activity *a, int prev, int curr,\n\t\t\t\t       unsigned long long itv)\n{\n\tstub_print_psicpu_stats(a, prev, curr, TRUE, itv);\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid stub_print_psiio_stats(struct activity *a, int prev, int curr, int dispavg,\n\t\t\t    unsigned long long itv)\n{\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr],\n\t\t*psip = (struct stats_psi_io *) a->buf[prev];\n\tstatic unsigned long long\n\t\ts_avg10  = 0,\n\t\ts_avg60  = 0,\n\t\ts_avg300 = 0,\n\t\tf_avg10  = 0,\n\t\tf_avg60  = 0,\n\t\tf_avg300 = 0;\n\tdouble siopct, fiopct;\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\t/* Compute %sio and %fio values */\n\tsiopct = ((double) psic->some_io_total - psip->some_io_total) / (100 * itv);\n\tfiopct = ((double) psic->full_io_total - psip->full_io_total) / (100 * itv);\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_minmax(a, 0, (double) psic->some_aio_10  / 100);\n\t\t\tsave_minmax(a, 1, (double) psic->some_aio_60  / 100);\n\t\t\tsave_minmax(a, 2, (double) psic->some_aio_300 / 100);\n\t\t\tsave_minmax(a, 3, siopct);\n\t\t\tsave_minmax(a, 4, (double) psic->full_aio_10  / 100);\n\t\t\tsave_minmax(a, 5, (double) psic->full_aio_60  / 100);\n\t\t\tsave_minmax(a, 6, (double) psic->full_aio_300 / 100);\n\t\t\tsave_minmax(a, 7, fiopct);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_psi_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_psi_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous \"some\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) psic->some_aio_10  / 100,\n\t\t\t   (double) psic->some_aio_60  / 100,\n\t\t\t   (double) psic->some_aio_300 / 100);\n\n\t\t/* Will be used to compute the average */\n\t\ts_avg10  += psic->some_aio_10;\n\t\ts_avg60  += psic->some_aio_60;\n\t\ts_avg300 += psic->some_aio_300;\n\t}\n\telse {\n\t\t/* Display average \"some\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) s_avg10  / (avg_count * 100),\n\t\t\t   (double) s_avg60  / (avg_count * 100),\n\t\t\t   (double) s_avg300 / (avg_count * 100));\n\n\t\t/* Reset average counters */\n\t\ts_avg10 = s_avg60 = s_avg300 = 0;\n\t}\n\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, siopct);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous \"full\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) psic->full_aio_10  / 100,\n\t\t\t   (double) psic->full_aio_60  / 100,\n\t\t\t   (double) psic->full_aio_300 / 100);\n\n\t\t/* Will be used to compute the average */\n\t\tf_avg10  += psic->full_aio_10;\n\t\tf_avg60  += psic->full_aio_60;\n\t\tf_avg300 += psic->full_aio_300;\n\t}\n\telse {\n\t\t/* Display average \"full\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) f_avg10  / (avg_count * 100),\n\t\t\t   (double) f_avg60  / (avg_count * 100),\n\t\t\t   (double) f_avg300 / (avg_count * 100));\n\n\t\t/* Reset average counters */\n\t\tf_avg10 = f_avg60 = f_avg300 = 0;\n\t}\n\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, fiopct);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_psiio_stats(struct activity *a, int prev, int curr,\n\t\t\t\t  unsigned long long itv)\n{\n\tstub_print_psiio_stats(a, prev, curr, FALSE, itv);\n}\n\n/*\n ***************************************************************************\n * Display average pressure-stall I/O statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_psiio_stats(struct activity *a, int prev, int curr,\n\t\t\t\t      unsigned long long itv)\n{\n\tstub_print_psiio_stats(a, prev, curr, TRUE, itv);\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTRUE if displaying average statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid stub_print_psimem_stats(struct activity *a, int prev, int curr, int dispavg,\n\t\t\t     unsigned long long itv)\n{\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr],\n\t\t*psip = (struct stats_psi_mem *) a->buf[prev];\n\tstatic unsigned long long\n\t\ts_avg10  = 0,\n\t\ts_avg60  = 0,\n\t\ts_avg300 = 0,\n\t\tf_avg10  = 0,\n\t\tf_avg60  = 0,\n\t\tf_avg300 = 0;\n\tdouble smempct, fmempct;\n\n\tif (xinit) {\n\t\t/* Init min and max values */\n\t\tinit_extrema_values(a, a->xnr);\n\t}\n\tif (dish || ((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\t/* Compute %smem and %fmem values */\n\tsmempct = ((double) psic->some_mem_total - psip->some_mem_total) / (100 * itv);\n\tfmempct = ((double) psic->full_mem_total - psip->full_mem_total) / (100 * itv);\n\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tif (prev != 2) {\n\t\t\t/* Save min and max values */\n\t\t\tsave_minmax(a, 0, (double) psic->some_amem_10  / 100);\n\t\t\tsave_minmax(a, 1, (double) psic->some_amem_60  / 100);\n\t\t\tsave_minmax(a, 2, (double) psic->some_amem_300 / 100);\n\t\t\tsave_minmax(a, 3, smempct);\n\t\t\tsave_minmax(a, 4, (double) psic->full_amem_10  / 100);\n\t\t\tsave_minmax(a, 5, (double) psic->full_amem_60  / 100);\n\t\t\tsave_minmax(a, 6, (double) psic->full_amem_300 / 100);\n\t\t\tsave_minmax(a, 7, fmempct);\n\t\t}\n\t\telse {\n\t\t\t/* Print min and max values */\n\t\t\tprint_psi_xstats(H_MIN, a->xnr, a->spmin);\n\t\t\tprint_psi_xstats(H_MAX, a->xnr, a->spmax);\n\t\t}\n\t}\n\n\tprintf(\"%-11s\", timestamp[curr]);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous \"some\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) psic->some_amem_10  / 100,\n\t\t\t   (double) psic->some_amem_60  / 100,\n\t\t\t   (double) psic->some_amem_300 / 100);\n\n\t\t/* Will be used to compute the average */\n\t\ts_avg10  += psic->some_amem_10;\n\t\ts_avg60  += psic->some_amem_60;\n\t\ts_avg300 += psic->some_amem_300;\n\t}\n\telse {\n\t\t/* Display average \"some\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) s_avg10  / (avg_count * 100),\n\t\t\t   (double) s_avg60  / (avg_count * 100),\n\t\t\t   (double) s_avg300 / (avg_count * 100));\n\n\t\t/* Reset average counters */\n\t\ts_avg10 = s_avg60 = s_avg300 = 0;\n\t}\n\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, smempct);\n\n\tif (!dispavg) {\n\t\t/* Display instantaneous \"full\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) psic->full_amem_10  / 100,\n\t\t\t   (double) psic->full_amem_60  / 100,\n\t\t\t   (double) psic->full_amem_300 / 100);\n\n\t\t/* Will be used to compute the average */\n\t\tf_avg10  += psic->full_amem_10;\n\t\tf_avg60  += psic->full_amem_60;\n\t\tf_avg300 += psic->full_amem_300;\n\t}\n\telse {\n\t\t/* Display average \"full\" values */\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 9, 2,\n\t\t\t   (double) f_avg10  / (avg_count * 100),\n\t\t\t   (double) f_avg60  / (avg_count * 100),\n\t\t\t   (double) f_avg300 / (avg_count * 100));\n\n\t\t/* Reset average counters */\n\t\tf_avg10 = f_avg60 = f_avg300 = 0;\n\t}\n\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, fmempct);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_psimem_stats(struct activity *a, int prev, int curr,\n\t\t\t\t   unsigned long long itv)\n{\n\tstub_print_psimem_stats(a, prev, curr, FALSE, itv);\n}\n\n/*\n ***************************************************************************\n * Display average pressure-stall memory statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_psimem_stats(struct activity *a, int prev, int curr,\n\t\t\t\t       unsigned long long itv)\n{\n\tstub_print_psimem_stats(a, prev, curr, TRUE, itv);\n}\n\n/*\n * **************************************************************************\n * Display battery statistics. This function is used to display\n * instantaneous and average statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @dispavg\tTrue if displaying average statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid stub_print_pwr_bat_stats(struct activity *a, int prev, int curr, int dispavg,\n\t\t\t      unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_bat *spbc, *spbp;\n\tstatic __nr_t nr_alloc = 0;\n\tstatic unsigned long *avg_bat_cap = NULL;\n\tdouble capmin;\n\n\tif (xinit && a->nr_spalloc) {\n\t\t/*\n\t\t * Init min and max values.\n\t\t * Used only when reading from a file: Init happens when there is a\n\t\t * LINUX RESTART message in file. The min and max values are those for\n\t\t * the statistics located between two LINUX RESTART messages.\n\t\t */\n\t\tinit_extrema_values(a, a->nr_spalloc * a->xnr);\n\t}\n\n\t/* Allocate arrays of battery capacities */\n\tif (!avg_bat_cap || (a->nr[curr] > nr_alloc)) {\n\t\tSREALLOC(avg_bat_cap, unsigned long, sizeof(unsigned long) * a->nr[curr]);\n\n\t\tif (a->nr[curr] > nr_alloc) {\n\t\t\t/* Init additional space allocated */\n\t\t\tmemset(avg_bat_cap + nr_alloc, 0,\n\t\t\t       sizeof(double) * (a->nr[curr] - nr_alloc));\n\t\t}\n\t\tnr_alloc = a->nr[curr];\n\t}\n\n\tif (dish && !((prev == 2) && DISPLAY_MINMAX(flags))) {\n\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t}\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\t\tspbp = (struct stats_pwr_bat *) ((char *) a->buf[prev] + i * a->msize);\n\n\t\t/* Compute cap/min value */\n\t\tcapmin = (double) (spbc->capacity - spbp->capacity) * 6000 / itv;\n\n\t\t/* Check if min and max values should be displayed */\n\t\tif (DISPLAY_MINMAX(flags)) {\n\t\t\tchar name[16];\n\t\t\tint k, pos;\n\n\t\t\tsnprintf(name, sizeof(name), \"%d\", spbc->bat_id);\n\t\t\tname[sizeof(name) - 1] = '\\0';\n\n\t\t\t/* Look for item in list or add it to the list if non existent */\n\t\t\tadd_list_item(&(a->xdev_list), name, sizeof(name), &k);\n\t\t\tpos = k * a->xnr;\n\t\t\tif (k >= a->nr_spalloc) {\n\t\t\t\t/* Reallocate buffers for min/max values if necessary */\n\t\t\t\treallocate_minmax_buf(a, k, flags);\n\t\t\t}\n\n\t\t\tif (prev != 2) {\n\t\t\t\t/* Save min and max values for %ifutil */\n\t\t\t\tsave_minmax(a, pos, (double) spbc->capacity);\n\t\t\t\tsave_minmax(a, pos + 1, capmin);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Display min and max values */\n\t\t\t\tprint_hdr_line(timestamp[!curr], a, FIRST, 0, 9, NULL);\n\t\t\t\tprint_pwr_bat_xstats(H_MIN, name, a->spmin + pos);\n\t\t\t\tprint_pwr_bat_xstats(H_MAX, name, a->spmax + pos);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%-11s\", timestamp[curr]);\n\t\tcprintf_in(IS_INT, \"     %5d\", \"\", (int) spbc->bat_id);\n\n\t\tif (dispavg) {\n\t\t\t/* Display average values */\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 2,\n\t\t\t\t    (double) avg_bat_cap[i] / avg_count);\n\t\t}\n\t\telse {\n\t\t\t/* Display instantaneous values */\n\t\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 0,\n\t\t\t\t    (double) spbc->capacity);\n\t\t\tavg_bat_cap[i] += (unsigned int) spbc->capacity;\n\t\t}\n\t\tcprintf_f(NO_UNIT, TRUE, 1, 9, 2, capmin);\n\n\t\tif (!dispavg) {\n\t\t\t/* Print battery status */\n\t\t\tswitch (spbc->status) {\n\n\t\t\t\tcase BAT_STS_CHARGING:\n\t\t\t\t\t/* Unicode for North East Arrow */\n\t\t\t\t\tcprintf_tr(TRUE, \" %11s\", \"\\U00002197\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BAT_STS_DISCHARGING:\n\t\t\t\t\t/* Unicode for South East Arrow */\n\t\t\t\t\tcprintf_tr(FALSE, \" %11s\", \"\\U00002198\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BAT_STS_NOTCHARGING:\n\t\t\t\t\t/* Unicode for East Arrow */\n\t\t\t\t\tcprintf_tr(FALSE, \" %11s\", \"\\U00002192\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BAT_STS_FULL:\n\t\t\t\t\t/* Unicode for North Arrow */\n\t\t\t\t\tcprintf_tr(TRUE, \" %11s\", \"\\U00002191\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\" %9s\", \"?\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (dispavg && avg_bat_cap) {\n\t\tfree(avg_bat_cap);\n\t\tavg_bat_cap = NULL;\n\t\tnr_alloc = 0;\n\t}\n}\n\n/*\n * **************************************************************************\n * Display battery statistics.fan\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_pwr_bat_stats(struct activity *a, int prev, int curr,\n\t\t\t\t    unsigned long long itv)\n{\n\tstub_print_pwr_bat_stats(a, prev, curr, FALSE, itv);\n}\n\n/*\n * **************************************************************************\n * Display average baterry statistics.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t print_avg_pwr_bat_stats(struct activity *a, int prev, int curr,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstub_print_pwr_bat_stats(a, prev, curr, TRUE, itv);\n}\n"
        },
        {
          "name": "pr_stats.h",
          "type": "blob",
          "size": 5.7548828125,
          "content": "/*\n * pr_stats.h: Include file used to display system statistics\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _PR_STATS_H\n#define _PR_STATS_H\n\n#include \"common.h\"\n\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display system statistics\n ***************************************************************************\n */\n\n/* Functions used to display instantaneous statistics */\n__print_funct_t print_cpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pcsw_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_irq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_swap_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_paging_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_io_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_memory_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_ktables_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_queue_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_serial_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_disk_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_dev_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_edev_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_nfs_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_nfsd_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_sock_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_ip_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_eip_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_icmp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_eicmp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_tcp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_etcp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_udp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_sock6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_ip6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_eip6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_icmp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_eicmp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_net_udp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_cpufreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_fan_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_temp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_in_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_huge_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_wghfreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_usb_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_filesystem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_fchost_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_softnet_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_psicpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_psiio_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_psimem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_pwr_bat_stats\n\t(struct activity *, int, int, unsigned long long);\n\n/* Functions used to display average statistics */\n__print_funct_t print_avg_memory_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_ktables_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_queue_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_net_sock_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_net_sock6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_pwr_cpufreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_pwr_fan_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_pwr_temp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_pwr_in_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_huge_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_pwr_usb_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_filesystem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_softnet_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_psicpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_psiio_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_psimem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t print_avg_pwr_bat_stats\n\t(struct activity *, int, int, unsigned long long);\n\n#endif /* _PR_STATS_H */\n"
        },
        {
          "name": "pr_xstats.c",
          "type": "blob",
          "size": 18.755859375,
          "content": "/*\n * pr_xstats.c: Functions used by sar to display extended reports\n * (e.g. minimum and maximum values).\n * (C) 2023 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <float.h>\n\n#include \"sa.h\"\n\nextern uint64_t flags;\n\n/*\n * **************************************************************************\n * Display min or max values for CPU statistics.\n *\n * IN:\n * @display_cpu_def\tTRUE if only main CPU metrics should be displayed.\n * @cpu\t\t\tCPU number.\n * @ismax\t\tTRUE: Display max header - FALSE: Display min header.\n * @spextr\t\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_cpu_xstats(int display_cpu_def, int cpu, int ismax, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (cpu == 0) {\n\t\t/* This is CPU \"all\" */\n\t\tcprintf_in(IS_STR, \" %s\", \"    all\", 0);\n\t}\n\telse {\n\t\tcprintf_in(IS_INT, \" %7d\", \"\", cpu - 1);\n\t}\n\n\tif (display_cpu_def) {\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 5, 9, 2,\n\t\t\t    *spextr, *(spextr + 1), *(spextr + 2),\n\t\t\t    *(spextr + 3), *(spextr + 4));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 2,\n\t\t\t    *(spextr + 9));\n\t}\n\telse {\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 9, 9, 2,\n\t\t\t    *spextr, *(spextr + 1), *(spextr + 2),\n\t\t\t    *(spextr + 3), *(spextr + 4), *(spextr + 5),\n\t\t\t    *(spextr + 6), *(spextr + 7), *(spextr + 8));\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 2,\n\t\t\t    *(spextr + 9));\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values (float values).\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @nr\t\tNumber of values to display.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_genf_xstats(int ismax, int nr, double *spextr)\n{\n\tint i;\n\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, *(spextr + i));\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values (integer values).\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @nr\t\tNumber of values to display.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_genu64_xstats(int ismax, int nr, double *spextr)\n{\n\tint i;\n\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tcprintf_u64(NO_UNIT, 1, 9, (unsigned long long) *(spextr + i));\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for interrupts statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @irq\t\tCurrent interrupt number.\n * @name\tName of current interrupt number.\n * @masked_cpu_bitmap\n *\t\tCPU bitmap for offline and unselected CPU.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_irq_xstats(int ismax, struct activity *a, int curr, int irq, char *name,\n\t\t      unsigned char masked_cpu_bitmap[], double *spextr)\n{\n\tint cpu;\n\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %9s\", name, 0);\n\t}\n\n\tfor (cpu = 0; (cpu < a->nr[curr]) && (cpu < a->bitmap->b_size + 1); cpu++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (IS_CPU_SET(masked_cpu_bitmap, cpu))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/* Print min/max values if available */\n\t\tif ((*(spextr + (cpu * a->nr2 + irq) * a->xnr) != -DBL_MAX) &&\n\t\t    (*(spextr + (cpu * a->nr2 + irq) * a->xnr) !=  DBL_MAX)) {\n\t\t\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2,\n\t\t\t\t  *(spextr + (cpu * a->nr2 + irq) * a->xnr));\n\t\t}\n\t}\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", name, 0);\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for RAM memory utilization.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @spextr\tPointer on array with min or max values.\n * @unit\tDefault values unit.\n * @dispall\tTRUE if all memory fields should be displayed.\n ***************************************************************************\n */\nvoid print_ram_memory_xstats(int ismax, double *spextr, int unit, int dispall)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_u64(unit, 3, 9,\n\t\t    (unsigned long long) *spextr,\n\t\t    (unsigned long long) *(spextr + 1),\n\t\t    (unsigned long long) *(spextr + 2));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 3));\n\tcprintf_u64(unit, 3, 9,\n\t\t    (unsigned long long) *(spextr + 4),\n\t\t    (unsigned long long) *(spextr + 5),\n\t\t    (unsigned long long) *(spextr + 6));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 7));\n\tcprintf_u64(unit, 3, 9,\n\t\t    (unsigned long long) *(spextr + 8),\n\t\t    (unsigned long long) *(spextr + 9),\n\t\t    (unsigned long long) *(spextr + 10));\n\n\tif (dispall) {\n\t\t/* Display extended memory statistics */\n\t\tcprintf_u64(unit, 5, 9,\n\t\t\t    (unsigned long long) *(spextr + 11),\n\t\t\t    (unsigned long long) *(spextr + 12),\n\t\t\t    (unsigned long long) *(spextr + 13),\n\t\t\t    (unsigned long long) *(spextr + 14),\n\t\t\t    (unsigned long long) *(spextr + 15));\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for swap memory utilization.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @spextr\tPointer on array with min or max values.\n * @unit\tDefault values unit.\n * @dispall\tTRUE if all memory fields should be displayed.\n ***************************************************************************\n */\nvoid print_swap_memory_xstats(int ismax, double *spextr, int unit, int dispall)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_u64(unit, 2, 9,\n\t\t    (unsigned long long) *(spextr + 16),\n\t\t    (unsigned long long) *(spextr + 17));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 18));\n\tcprintf_u64(unit, 1, 9,\n\t\t    (unsigned long long) *(spextr + 19));\n\tcprintf_xpc(DISPLAY_UNIT(flags), FALSE, 1, 9, 2, *(spextr + 20));\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min and max values for queue and load statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_queue_xstats(int ismax, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_u64(NO_UNIT, 2, 9,\n\t\t    (unsigned long long) *spextr,\n\t\t    (unsigned long long) *(spextr + 1));\n\tcprintf_f(NO_UNIT, FALSE, 3, 9, 2,\n\t\t  (double) *(spextr + 2) / 100,\n\t\t  (double) *(spextr + 3) / 100,\n\t\t  (double) *(spextr + 4) / 100);\n\tcprintf_u64(NO_UNIT, 1, 9,\n\t\t    (unsigned long long) *(spextr + 5));\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for serial lines statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @name\tSerial line name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_serial_xstats(int ismax, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_in(IS_INT, \"       %3d\", \"\", atoi(name));\n\n\tcprintf_f(NO_UNIT, FALSE, 6, 9, 2,\n\t\t  *spextr, *(spextr + 1), *(spextr + 2),\n\t\t  *(spextr + 3), *(spextr + 4), *(spextr + 5));\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for disks statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @unit\tUnit used to display values.\n * @name\tDisk name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_disk_xstats(int ismax, int unit, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %9s\", name, 0);\n\t}\n\n\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, *spextr);\n\tcprintf_f(unit, FALSE, 4, 9, 2,\n\t\t  *(spextr + 1), *(spextr + 2), *(spextr + 3), *(spextr + 4));\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2, *(spextr + 5), *(spextr + 6));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 7));\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", name, 0);\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for network interfaces.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @unit\tUnit used to display values.\n * @name\tNetwork interface name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_net_dev_xstats(int ismax, int unit, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %9s\", name, 0);\n\t}\n\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2, *spextr, *(spextr + 1));\n\tcprintf_f(unit, FALSE, 2, 9, 2,\n\t\t  unit < 0 ? *(spextr + 2) / 1024 : *(spextr + 2),\n\t\t  unit < 0 ? *(spextr + 3) / 1024 : *(spextr + 3));\n\tcprintf_f(NO_UNIT, FALSE, 3, 9, 2,\n\t\t  *(spextr + 4), *(spextr + 5), *(spextr + 6));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 7));\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", name, 0);\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for network interfaces errors statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @name\tNetwork interface name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_net_edev_xstats(int ismax, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (!DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %9s\", name, 0);\n\t}\n\n\tcprintf_f(NO_UNIT, FALSE, 9, 9, 2,\n\t\t  *spextr, *(spextr + 1), *(spextr + 2),\n\t\t  *(spextr + 3), *(spextr + 4), *(spextr + 5),\n\t\t  *(spextr + 6), *(spextr + 7), *(spextr + 8));\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tcprintf_in(IS_STR, \" %s\", name, 0);\n\t}\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for CPU frequency statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @name\tCPU number\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_pwr_cpufreq_xstats(int ismax, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\tcprintf_in(IS_STR, \"%s\", name, 0);\n\n\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, *spextr);\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for fan statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @fan\t\tFan number.\n * @name\tDevice (fan) name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_pwr_fan_xstats(int ismax, int fan, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_in(IS_INT, \"     %5d\", \"\", fan + 1);\n\tcprintf_f(NO_UNIT, FALSE, 2, 9, 2, *spextr, *(spextr + 1));\n\tcprintf_in(IS_STR, \" %s\\n\", name, 0);\n}\n\n/*\n * **************************************************************************\n * Display min or max values for device temperature statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @sensorid\tSensor id number.\n * @name\tDevice name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_pwr_sensor_xstats(int ismax, int sensorid, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_in(IS_INT, \"     %5d\", \"\", sensorid);\n\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, *spextr);\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 1));\n\tcprintf_in(IS_STR, \" %s\\n\", name, 0);\n}\n\n/*\n * **************************************************************************\n * Display min or max values for huge pages statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @unit\tUnit used to display values.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_huge_xstats(int ismax, int unit, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_u64(unit, 2, 9,\n\t\t    (unsigned long long) *spextr,\n\t\t    (unsigned long long) *(spextr + 1));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 2));\n\tcprintf_u64(unit, 2, 9,\n\t\t    (unsigned long long) *(spextr + 3),\n\t\t    (unsigned long long) *(spextr + 4));\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for CPU weighted frequency statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @cpu\t\tCurrent CPU number.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_pwr_wghfreq_xstats(int ismax, int cpu, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (!cpu) {\n\t\t/* This is CPU \"all\" */\n\t\tcprintf_in(IS_STR, \"%s\", \"     all\", 0);\n\t}\n\telse {\n\t\tcprintf_in(IS_INT, \"     %3d\", \"\", cpu - 1);\n\t}\n\tcprintf_f(NO_UNIT, FALSE, 1, 9, 2, *spextr);\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for filesystems statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @unit\tUnit used to display values.\n * @name\tFilesystem name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_filesystem_xstats(int ismax, int unit, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_f(unit, FALSE, 2, 9, 0, *spextr, *(spextr + 1));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 2, 9, 2,\n\t\t    *(spextr + 2), *(spextr + 3));\n\tcprintf_u64(NO_UNIT, 2, 9,\n\t\t    (unsigned long long) *(spextr + 4),\n\t\t    (unsigned long long) *(spextr + 5));\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + 6));\n\n\tcprintf_in(IS_STR, \" %s\\n\", name, 0);\n}\n\n/*\n * **************************************************************************\n * Display min or max values for Fibre Channel HBA statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @name\tFC name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_fchost_xstats(int ismax, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_f(NO_UNIT, FALSE, 4, 9, 2,\n\t\t  *spextr, *(spextr + 1), *(spextr + 2), *(spextr + 3));\n\tcprintf_in(IS_STR, \" %s\\n\", name, 0);\n}\n\n/*\n * **************************************************************************\n * Display min or max values for softnet statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @cpu\t\tCPU number.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_softnet_xstats(int ismax, int cpu, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tif (!cpu) {\n\t\t/* This is CPU \"all\" */\n\t\tcprintf_in(IS_STR, \" %s\", \"    all\", 0);\n\t}\n\telse {\n\t\tcprintf_in(IS_INT, \" %7d\", \"\", cpu - 1);\n\t}\n\n\tcprintf_f(NO_UNIT, FALSE, 5, 9, 2,\n\t\t  *spextr, *(spextr + 1), *(spextr + 2),\n\t\t  *(spextr + 3), *(spextr + 4));\n\tcprintf_u64(NO_UNIT, 1, 9,\n\t\t    (unsigned long long) *(spextr + 5));\n\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for pressure-stall statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @nr\t\tNumber of values to display.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_psi_xstats(int ismax, int nr, double *spextr)\n{\n\tint i;\n\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 1, 9, 2, *(spextr + i));\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display min or max values for battery statistics.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n * @name\tBattery id name.\n * @spextr\tPointer on array with min or max values.\n ***************************************************************************\n */\nvoid print_pwr_bat_xstats(int ismax, char *name, double *spextr)\n{\n\t/* Print min / max header */\n\tprint_minmax(ismax);\n\n\tcprintf_in(IS_INT, \"     %5d\", \"\", atoi(name));\n\n\tcprintf_xpc(DISPLAY_UNIT(flags), XLOW, 1, 9, 0, *spextr);\n\tcprintf_f(NO_UNIT, TRUE, 1, 9, 2, *(spextr + 1));\n\n\tprintf(\"\\n\");\n}\n"
        },
        {
          "name": "pr_xstats.h",
          "type": "blob",
          "size": 1.5546875,
          "content": "/*\n * pr_xstats.h: Include file used to display extended reports data.\n * (C) 2023 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _PR_XSTATS_H\n#define _PR_XSTATS_H\n\n#include \"common.h\"\n\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display extended reports data\n ***************************************************************************\n */\nvoid print_cpu_xstats\n\t(int, int, int, double *);\nvoid print_genf_xstats\n\t(int, int, double *);\nvoid print_genu64_xstats\n\t(int, int, double *);\nvoid print_irq_xstats\n\t(int, struct activity *, int, int, char *, unsigned char [], double *);\nvoid print_ram_memory_xstats\n\t(int, double *, int, int);\nvoid print_swap_memory_xstats\n\t(int, double *, int, int);\nvoid print_queue_xstats\n\t(int, double *);\nvoid print_serial_xstats\n\t(int, char *, double *);\nvoid print_disk_xstats\n\t(int, int, char *, double *);\nvoid print_net_dev_xstats\n\t(int, int, char *, double *);\nvoid print_net_edev_xstats\n\t(int, char *, double *);\nvoid print_pwr_cpufreq_xstats\n\t(int, char *, double *);\nvoid print_pwr_fan_xstats\n\t(int, int, char *, double *);\nvoid print_pwr_sensor_xstats\n\t(int, int, char *, double *);\nvoid print_huge_xstats\n\t(int, int, double *);\nvoid print_pwr_wghfreq_xstats\n\t(int, int, double *);\nvoid print_filesystem_xstats\n\t(int, int, char *, double *);\nvoid print_fchost_xstats\n\t(int, char *, double *);\nvoid print_softnet_xstats\n\t(int, int, double *);\nvoid print_psi_xstats\n\t(int, int, double *);\nvoid print_pwr_bat_xstats\n\t(int, char *, double *);\n\n#endif /* _PR_XSTATS_H */\n"
        },
        {
          "name": "raw_stats.c",
          "type": "blob",
          "size": 66.431640625,
          "content": "/*\n * raw_stats.c: Functions used by sar to display statistics in raw format.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n\n#include \"sa.h\"\n#include \"ioconf.h\"\n\nextern uint64_t flags;\nextern char bat_status[][16];\n\n/*\n ***************************************************************************\n * Display current field name.\n *\n * IN:\n * @hdr_line\tOn the first call, complete header line, containing all the\n *\t\tmetric names. In each subsequent call, must be NULL.\n * @pos\t\tIndex in @hdr_line string, 0 being the first one (headers\n * \t\tare delimited by the '|' character).\n *\t\tIf @hdr_line is NULL then @pos is the item number for fields\n *\t\tcontaining a '*' character (e.g. \"CPU*\").\n *\n * RETURNS:\n * Pointer on string containing field name.\n ***************************************************************************\n */\nchar *pfield(char *hdr_line, int pos)\n{\n\tstatic char field[HEADER_LINE_LEN] = \"\";\n\tstatic char gen_name[HEADER_LINE_LEN] = \"\";\n\tstatic int idx = 0;\n\tint i, j = 0;\n\n\tif (hdr_line) {\n\t\tchar hline[HEADER_LINE_LEN] = \"\";\n\t\tchar *hl;\n\n\t\tstrncpy(hline, hdr_line, sizeof(hline) - 1);\n\t\thline[sizeof(hline) - 1] = '\\0';\n\t\tidx = 0;\n\n\t\tfor (hl = strtok(hline, \"|\"); hl && (pos > 0); hl = strtok(NULL, \"|\"), pos--);\n\t\tif (!hl) {\n\t\t\t/* Bad @pos arg given to function */\n\t\t\tstrcpy(field, \"\");\n\t\t\treturn field;\n\t\t}\n\t\tif (strchr(hl, '&')) {\n\t\t\tj = strcspn(hl, \"&\");\n\t\t\t*(hl + j) = ';';\n\t\t}\n\t\tstrncpy(field, hl, sizeof(field));\n\t\tfield[sizeof(field) - 1] = '\\0';\n\t}\n\n\tif (strchr(field + idx, ';')) {\n\t\tj = strcspn(field + idx, \";\");\n\t\t*(field + idx + j) = '\\0';\n\t}\n\telse if (strchr(field + idx, '*') || (!hdr_line && pos)) {\n\t\tj = strcspn(field + idx, \"*\");\n\t\tif (j < strlen(field + idx)) {\n\t\t\t*(field + idx + j) = '\\0';\n\t\t}\n\t\tif (!pos) {\n\t\t\tstrcpy(gen_name, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsnprintf(gen_name, sizeof(gen_name), \"%s%d\", field + idx, pos - 1);\n\t\t\tgen_name[sizeof(gen_name) - 1] = '\\0';\n\t\t}\n\n\t\treturn gen_name;\n\t}\n\n\ti = idx;\n\tidx += j + 1;\n\n\treturn field + i;\n}\n\n/*\n ***************************************************************************\n * Display field values.\n *\n * IN:\n * @valp\tField's value from previous statistics sample.\n * @valc\tField's value from current statistics sample.\n ***************************************************************************\n */\nvoid pval(unsigned long long valp, unsigned long long valc)\n{\n\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\tif (valc < valp) {\n\t\t\t/* Field's value has decreased */\n\t\t\tcprintf_s(IS_DEBUG, \"%s\", \" [DEC]\");\n\t\t}\n\t}\n\tprintf(\"; %llu; %llu;\", valp, valc);\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in raw format.\n * Note: Values displayed for CPU \"all\" may slightly differ from those you\n * would get if you were displaying them in pr_stats.c:print_cpu_stats().\n * This is because values for CPU \"all\" are recalculated there as the sum of\n * all individual CPU values (done by a call to get_global_cpu_statistics()\n * function).\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current statistics sample.\n ***************************************************************************\n */\n__print_funct_t raw_print_cpu_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_cpu *scc, *scp;\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_cpu) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * scc = (struct stats_cpu *) a->buf[...] + i;\n\t\t */\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr] + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/* Yes: Display it */\n\t\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, DISPLAY_CPU_ALL(a->opt_flags)));\n\t\tif (DISPLAY_DEBUG_MODE(flags) && i) {\n\t\t\tif ((scc->cpu_user + scc->cpu_nice + scc->cpu_sys +\n\t\t\t     scc->cpu_iowait + scc->cpu_idle + scc->cpu_steal +\n\t\t\t     scc->cpu_hardirq + scc->cpu_softirq) == 0) {\n\t\t\t\t/* CPU is offline */\n\t\t\t\tcprintf_s(IS_DEBUG, \"%s\", \" [OFF]\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!get_per_cpu_interval(scc, scp)) {\n\t\t\t\t\t/* CPU is tickless */\n\t\t\t\t\tcprintf_s(IS_DEBUG, \"%s\", \" [TLS]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"; %d;\", i - 1);\n\n\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_user, scc->cpu_user);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_nice, scc->cpu_nice);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t     scc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_iowait, scc->cpu_iowait);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_steal, scc->cpu_steal);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_idle, scc->cpu_idle);\n\t\t}\n\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_user - scp->cpu_guest, scc->cpu_user - scc->cpu_guest);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_nice - scp->cpu_guest_nice, scc->cpu_nice - scc->cpu_guest_nice);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_sys, scc->cpu_sys);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_iowait, scc->cpu_iowait);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_steal, scc->cpu_steal);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_hardirq, scc->cpu_hardirq);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_softirq, scc->cpu_softirq);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_guest, scc->cpu_guest);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_guest_nice, scc->cpu_guest_nice);\n\t\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\t\tpval(scp->cpu_idle, scc->cpu_idle);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display tasks creation and context switches statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pcsw_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr],\n\t\t*spp = (struct stats_pcsw *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) spp->processes, (unsigned long long) spc->processes);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(spp->context_switch, spc->context_switch);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_irq_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, c;\n\tstruct stats_irq *stc_cpu_irq, *stp_cpu_irq, *stc_cpuall_irq;\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\tfor (i = 0; i < a->nr2; i++) {\n\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, stc_cpuall_irq->irq_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"%s; %s; %s;\", timestr,\n\t\t       pfield(a->hdr_line, FIRST), stc_cpuall_irq->irq_name);\n\n\t\t/* In raw mode, offline CPU (in datafile) are always displayed */\n\t\tfor (c = 0; (c < a->nr[curr]) && (c < a->bitmap->b_size + 1); c++) {\n\n\t\t\tstc_cpu_irq = (struct stats_irq *) ((char *) a->buf[curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\t\t\tstp_cpu_irq = (struct stats_irq *) ((char *) a->buf[!curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\n\t\t\t/* Should current interrupt (including int \"sum\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, c))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tprintf(\" %s\", pfield(NULL, c));\n\t\t\tpval((unsigned long long) stp_cpu_irq->irq_nr,\n\t\t\t     (unsigned long long) stc_cpu_irq->irq_nr);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display swapping statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_swap_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr],\n\t\t*ssp = (struct stats_swap *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) ssp->pswpin, (unsigned long long) ssc->pswpin);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) ssp->pswpout, (unsigned long long) ssc->pswpout);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display paging statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_paging_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr],\n\t\t*spp = (struct stats_paging *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) spp->pgpgin, (unsigned long long) spc->pgpgin);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgpgout, (unsigned long long) spc->pgpgout);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgfault, (unsigned long long) spc->pgfault);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgmajfault, (unsigned long long) spc->pgmajfault);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgfree, (unsigned long long) spc->pgfree);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgscan_kswapd, (unsigned long long) spc->pgscan_kswapd);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgscan_direct, (unsigned long long) spc->pgscan_direct);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgsteal, (unsigned long long) spc->pgsteal);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgpromote, (unsigned long long) spc->pgpromote);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) spp->pgdemote, (unsigned long long) spc->pgdemote);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_io_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr],\n\t\t*sip = (struct stats_io *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval(sip->dk_drive, sic->dk_drive);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sip->dk_drive_rio, sic->dk_drive_rio);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sip->dk_drive_wio, sic->dk_drive_wio);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sip->dk_drive_dio, sic->dk_drive_dio);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sip->dk_drive_rblk, sic->dk_drive_rblk);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sip->dk_drive_wblk, sic->dk_drive_wblk);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sip->dk_drive_dblk, sic->dk_drive_dblk);\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization in raw format.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @dispall\tTRUE if all memory fields should be displayed.\n ***************************************************************************\n */\nvoid raw_print_ram_memory_stats(struct stats_memory *smc, int dispall)\n{\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->availablekb);\n\tprintf(\" kbttlmem; %llu;\", smc->tlmkb);\n\tpfield(NULL, 0); /* Skip kbmemused */\n\tpfield(NULL, 0); /* Skip %memused */\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->bufkb);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->camkb);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->comkb);\n\tpfield(NULL, 0); /* Skip %commit */\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->activekb);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->inactkb);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->dirtykb);\n\n\tif (dispall) {\n\t\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->anonpgkb);\n\t\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->slabkb);\n\t\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->kstackkb);\n\t\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->pgtblkb);\n\t\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->vmusedkb);\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization in raw format.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n ***************************************************************************\n */\nvoid raw_print_swap_memory_stats(struct stats_memory *smc)\n{\n\tprintf(\" kbttlswp; %llu;\", smc->tlskb);\n\tpfield(NULL, 0); /* Skip kbswpused */\n\tpfield(NULL, 0); /* Skip %swpused */\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->caskb);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display memory statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_memory_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\tprintf(\"%s; %s; %llu;\", timestr, pfield(a->hdr_line, FIRST), smc->frmkb);\n\t\traw_print_ram_memory_stats(smc, DISPLAY_MEM_ALL(a->opt_flags));\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\tprintf(\"%s; %s; %llu;\", timestr, pfield(a->hdr_line, SECOND), smc->frskb);\n\t\traw_print_swap_memory_stats(smc);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_ktables_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\n\tprintf(\"%s; %s; %llu;\", timestr, pfield(a->hdr_line, FIRST), skc->dentry_stat);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), skc->file_used);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), skc->inode_used);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), skc->pty_nr);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_queue_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\n\tprintf(\"%s; %s; %llu;\", timestr, pfield(a->hdr_line, FIRST), sqc->nr_running);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), sqc->nr_threads);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), sqc->load_avg_1);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), sqc->load_avg_5);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), sqc->load_avg_15);\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), sqc->procs_blocked);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display serial lines statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_serial_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, j, j0, found;\n\tstruct stats_serial *ssc, *ssp;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\t\tssc = (struct stats_serial *) ((char *) a->buf[curr]  + i * a->msize);\n\n\t\tif (a->nr[!curr] > 0) {\n\n\t\t\t/* Look for corresponding serial line in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tssp = (struct stats_serial *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (ssc->line == ssp->line) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\t\tif (!found && DISPLAY_DEBUG_MODE(flags)) {\n\t\t\tcprintf_s(IS_DEBUG, \"%s\", \" [NEW]\");\n\t\t}\n\t\tprintf(\"; %u;\", ssc->line);\n\t\tif (!found) {\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssp->rx, (unsigned long long)ssc->rx);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssp->tx, (unsigned long long) ssc->tx);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssp->frame, (unsigned long long) ssc->frame);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssp->parity, (unsigned long long) ssc->parity);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssp->brk, (unsigned long long) ssc->brk);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssp->overrun, (unsigned long long) ssc->overrun);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display disks statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_disk_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, j;\n\tstruct stats_disk *sdc,\t*sdp, sdpzero;\n\tchar *dev_name;\n\n\tmemset(&sdpzero, 0, STATS_DISK_SIZE);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get device name */\n\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"%s; major; %u; minor; %u; %s\",\n\t\t       timestr, sdc->major, sdc->minor, pfield(a->hdr_line, FIRST));\n\n\t\tj = check_disk_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsdp = &sdpzero;\n\t\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\t\tcprintf_s(IS_DEBUG, \"%s\",  j == -1 ? \" [NEW]\" : \" [BCK]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsdp = (struct stats_disk *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\tprintf(\"; %s;\", dev_name);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sdp->nr_ios, sdc->nr_ios);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sdp->rd_sect, (unsigned long long) sdc->rd_sect);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sdp->wr_sect, (unsigned long long) sdc->wr_sect);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sdp->dc_sect, (unsigned long long) sdc->dc_sect);\n\t\tprintf(\" rd_ticks\");\n\t\tpval((unsigned long long) sdp->rd_ticks, (unsigned long long) sdc->rd_ticks);\n\t\tprintf(\" wr_ticks\");\n\t\tpval((unsigned long long) sdp->wr_ticks, (unsigned long long) sdc->wr_ticks);\n\t\tprintf(\" dc_ticks\");\n\t\tpval((unsigned long long) sdp->dc_ticks, (unsigned long long) sdc->dc_ticks);\n\t\tprintf(\" tot_ticks\");\n\t\tpval((unsigned long long) sdp->tot_ticks, (unsigned long long) sdc->tot_ticks);\n\t\tpfield(NULL, 0); /* Skip areq-sz */\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sdp->rq_ticks, (unsigned long long) sdc->rq_ticks);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_dev_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, j;\n\tstruct stats_net_dev *sndc, *sndp, sndzero;\n\n\tmemset(&sndzero, 0, STATS_NET_DEV_SIZE);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\t\tj = check_net_dev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsndp = &sndzero;\n\t\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\t\tcprintf_s(IS_DEBUG, \"%s\",  j == -1 ? \" [NEW]\" : \" [BCK]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\t\tprintf(\"; %s;\", sndc->interface);\n\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->rx_packets, sndc->rx_packets);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->tx_packets, sndc->tx_packets);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->rx_bytes, sndc->rx_bytes);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->tx_bytes, sndc->tx_bytes);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->rx_compressed, sndc->rx_compressed);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->tx_compressed, sndc->tx_compressed);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(sndp->multicast, sndc->multicast);\n\t\tprintf(\" speed; %u; duplex; %u;\\n\", sndc->speed, (unsigned int) sndc->duplex);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces errors statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_edev_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, j;\n\tstruct stats_net_edev *snedc, *snedp, snedzero;\n\n\tmemset(&snedzero, 0, STATS_NET_EDEV_SIZE);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\t\tj = check_net_edev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsnedp = &snedzero;\n\t\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\t\tcprintf_s(IS_DEBUG, \"%s\",  j == -1 ? \" [NEW]\" : \" [BCK]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\t\tprintf(\"; %s;\", snedc->interface);\n\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->rx_errors, snedc->rx_errors);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->tx_errors, snedc->tx_errors);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->collisions, snedc->collisions);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->rx_dropped, snedc->rx_dropped);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->tx_dropped, snedc->tx_dropped);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->tx_carrier_errors, snedc->tx_carrier_errors);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->rx_frame_errors, snedc->rx_frame_errors);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->rx_fifo_errors, snedc->rx_fifo_errors);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval(snedp->tx_fifo_errors, snedc->tx_fifo_errors);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_nfs_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr],\n\t\t*snnp = (struct stats_net_nfs *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snnp->nfs_rpccnt, (unsigned long long) snnc->nfs_rpccnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snnp->nfs_rpcretrans, (unsigned long long) snnc->nfs_rpcretrans);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snnp->nfs_readcnt, (unsigned long long) snnc->nfs_readcnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snnp->nfs_writecnt, (unsigned long long) snnc->nfs_writecnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snnp->nfs_accesscnt, (unsigned long long) snnc->nfs_accesscnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snnp->nfs_getattcnt, (unsigned long long) snnc->nfs_getattcnt);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_nfsd_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr],\n\t\t*snndp = (struct stats_net_nfsd *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snndp->nfsd_rpccnt, (unsigned long long) snndc->nfsd_rpccnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_rpcbad, (unsigned long long) snndc->nfsd_rpcbad);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_netcnt, (unsigned long long) snndc->nfsd_netcnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_netudpcnt, (unsigned long long) snndc->nfsd_netudpcnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_nettcpcnt, (unsigned long long) snndc->nfsd_nettcpcnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_rchits, (unsigned long long) snndc->nfsd_rchits);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_rcmisses, (unsigned long long) snndc->nfsd_rcmisses);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_readcnt, (unsigned long long) snndc->nfsd_readcnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_writecnt, (unsigned long long) snndc->nfsd_writecnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_accesscnt, (unsigned long long) snndc->nfsd_accesscnt);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snndp->nfsd_getattcnt, (unsigned long long) snndc->nfsd_getattcnt);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display network socket statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_sock_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\n\tprintf(\"%s; %s; %u;\", timestr, pfield(a->hdr_line, FIRST), snsc->sock_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->tcp_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->udp_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->raw_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->frag_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->tcp_tw);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IP network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_ip_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval(snip->InReceives, snic->InReceives);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->ForwDatagrams, snic->ForwDatagrams);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->InDelivers, snic->InDelivers);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->OutRequests, snic->OutRequests);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->ReasmReqds, snic->ReasmReqds);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->ReasmOKs, snic->ReasmOKs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->FragOKs, snic->FragOKs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->FragCreates, snic->FragCreates);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IP network errors statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_eip_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval(sneip->InHdrErrors, sneic->InHdrErrors);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InAddrErrors, sneic->InAddrErrors);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InUnknownProtos, sneic->InUnknownProtos);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InDiscards, sneic->InDiscards);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->OutDiscards, sneic->OutDiscards);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->OutNoRoutes, sneic->OutNoRoutes);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->ReasmFails, sneic->ReasmFails);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->FragFails, sneic->FragFails);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMP network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_icmp_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snip->InMsgs, (unsigned long long) snic->InMsgs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutMsgs, (unsigned long long) snic->OutMsgs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InEchos, (unsigned long long) snic->InEchos);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InEchoReps, (unsigned long long) snic->InEchoReps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutEchos, (unsigned long long) snic->OutEchos);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutEchoReps, (unsigned long long) snic->OutEchoReps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InTimestamps, (unsigned long long) snic->InTimestamps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InTimestampReps, (unsigned long long) snic->InTimestampReps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutTimestamps, (unsigned long long) snic->OutTimestamps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutTimestampReps, (unsigned long long) snic->OutTimestampReps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InAddrMasks, (unsigned long long) snic->InAddrMasks);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InAddrMaskReps, (unsigned long long) snic->InAddrMaskReps);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutAddrMasks, (unsigned long long) snic->OutAddrMasks);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutAddrMaskReps, (unsigned long long) snic->OutAddrMaskReps);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMP errors message statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_eicmp_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) sneip->InErrors, (unsigned long long) sneic->InErrors);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutErrors, (unsigned long long) sneic->OutErrors);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InDestUnreachs, (unsigned long long) sneic->InDestUnreachs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutDestUnreachs, (unsigned long long) sneic->OutDestUnreachs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InTimeExcds, (unsigned long long) sneic->InTimeExcds);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutTimeExcds, (unsigned long long) sneic->OutTimeExcds);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InParmProbs, (unsigned long long) sneic->InParmProbs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutParmProbs, (unsigned long long) sneic->OutParmProbs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InSrcQuenchs, (unsigned long long) sneic->InSrcQuenchs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutSrcQuenchs, (unsigned long long) sneic->OutSrcQuenchs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InRedirects, (unsigned long long) sneic->InRedirects);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutRedirects, (unsigned long long) sneic->OutRedirects);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display TCP network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_tcp_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr],\n\t\t*sntp = (struct stats_net_tcp *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) sntp->ActiveOpens, (unsigned long long) sntc->ActiveOpens);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sntp->PassiveOpens, (unsigned long long) sntc->PassiveOpens);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sntp->InSegs, (unsigned long long) sntc->InSegs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sntp->OutSegs, (unsigned long long) sntc->OutSegs);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display TCP network errors statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_etcp_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr],\n\t\t*snetp = (struct stats_net_etcp *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snetp->AttemptFails, (unsigned long long) snetc->AttemptFails);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snetp->EstabResets, (unsigned long long) snetc->EstabResets);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snetp->RetransSegs, (unsigned long long) snetc->RetransSegs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snetp->InErrs, (unsigned long long) snetc->InErrs);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snetp->OutRsts, (unsigned long long) snetc->OutRsts);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display UDP network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_udp_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snup->InDatagrams, (unsigned long long) snuc->InDatagrams);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snup->OutDatagrams, (unsigned long long) snuc->OutDatagrams);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snup->NoPorts, (unsigned long long) snuc->NoPorts);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snup->InErrors, (unsigned long long) snuc->InErrors);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network socket statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_sock6_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\n\tprintf(\"%s; %s; %u;\", timestr, pfield(a->hdr_line, FIRST), snsc->tcp6_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->udp6_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->raw6_inuse);\n\tprintf(\" %s; %u;\", pfield(NULL, 0), snsc->frag6_inuse);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_ip6_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip6 *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval(snip->InReceives6, snic->InReceives6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->OutForwDatagrams6, snic->OutForwDatagrams6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->InDelivers6, snic->InDelivers6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->OutRequests6, snic->OutRequests6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->ReasmReqds6, snic->ReasmReqds6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->ReasmOKs6, snic->ReasmOKs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->InMcastPkts6, snic->InMcastPkts6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->OutMcastPkts6, snic->OutMcastPkts6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->FragOKs6, snic->FragOKs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(snip->FragCreates6, snic->FragCreates6);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network errors statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_eip6_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip6 *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval(sneip->InHdrErrors6, sneic->InHdrErrors6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InAddrErrors6, sneic->InAddrErrors6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InUnknownProtos6, sneic->InUnknownProtos6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InTooBigErrors6, sneic->InTooBigErrors6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InDiscards6, sneic->InDiscards6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->OutDiscards6, sneic->OutDiscards6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InNoRoutes6, sneic->InNoRoutes6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->OutNoRoutes6, sneic->OutNoRoutes6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->ReasmFails6, sneic->ReasmFails6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->FragFails6, sneic->FragFails6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval(sneip->InTruncatedPkts6, sneic->InTruncatedPkts6);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_icmp6_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp6 *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snip->InMsgs6,\n\t     (unsigned long long) snic->InMsgs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutMsgs6,\n\t     (unsigned long long) snic->OutMsgs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InEchos6,\n\t     (unsigned long long) snic->InEchos6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InEchoReplies6,\n\t     (unsigned long long) snic->InEchoReplies6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutEchoReplies6,\n\t     (unsigned long long) snic->OutEchoReplies6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InGroupMembQueries6,\n\t     (unsigned long long) snic->InGroupMembQueries6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InGroupMembResponses6,\n\t     (unsigned long long) snic->InGroupMembResponses6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutGroupMembResponses6,\n\t     (unsigned long long) snic->OutGroupMembResponses6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InGroupMembReductions6,\n\t     (unsigned long long) snic->InGroupMembReductions6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutGroupMembReductions6,\n\t     (unsigned long long) snic->OutGroupMembReductions6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InRouterSolicits6,\n\t     (unsigned long long) snic->InRouterSolicits6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutRouterSolicits6,\n\t     (unsigned long long) snic->OutRouterSolicits6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InRouterAdvertisements6,\n\t     (unsigned long long) snic->InRouterAdvertisements6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InNeighborSolicits6,\n\t     (unsigned long long) snic->InNeighborSolicits6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutNeighborSolicits6,\n\t     (unsigned long long) snic->OutNeighborSolicits6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->InNeighborAdvertisements6,\n\t     (unsigned long long) snic->InNeighborAdvertisements6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snip->OutNeighborAdvertisements6,\n\t     (unsigned long long) snic->OutNeighborAdvertisements6);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 error messages statistics in rw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_eicmp6_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp6 *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) sneip->InErrors6, (unsigned long long) sneic->InErrors6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InDestUnreachs6, (unsigned long long) sneic->InDestUnreachs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutDestUnreachs6, (unsigned long long) sneic->OutDestUnreachs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InTimeExcds6, (unsigned long long) sneic->InTimeExcds6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutTimeExcds6, (unsigned long long) sneic->OutTimeExcds6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InParmProblems6, (unsigned long long) sneic->InParmProblems6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutParmProblems6, (unsigned long long) sneic->OutParmProblems6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InRedirects6, (unsigned long long) sneic->InRedirects6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutRedirects6, (unsigned long long) sneic->OutRedirects6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->InPktTooBigs6, (unsigned long long) sneic->InPktTooBigs6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) sneip->OutPktTooBigs6, (unsigned long long) sneic->OutPktTooBigs6);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display UDPv6 network statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_net_udp6_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp6 *) a->buf[!curr];\n\n\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\tpval((unsigned long long) snup->InDatagrams6, (unsigned long long) snuc->InDatagrams6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snup->OutDatagrams6, (unsigned long long) snuc->OutDatagrams6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snup->NoPorts6, (unsigned long long) snuc->NoPorts6);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) snup->InErrors6, (unsigned long long) snuc->InErrors6);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_cpufreq_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_pwr_cpufreq *spc;\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (IS_CPU_SELECTED(a->bitmap->b_array, i)) {\n\t\t\t/* Yes: Display it */\n\t\t\tprintf(\"%s; %s; %d;\", timestr, pfield(a->hdr_line, FIRST), i - 1);\n\t\t\tprintf(\" %s; %lu;\\n\", pfield(NULL, 0), spc->cpufreq);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display fan statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_fan_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_pwr_fan *spc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tprintf(\"%s; %s; %d;\", timestr, pfield(a->hdr_line, FIRST), i + 1);\n\t\tprintf(\" %s; %s;\", pfield(NULL, 0), spc->device);\n\t\tprintf(\" %s; %f;\", pfield(NULL, 0), spc->rpm);\n\t\tprintf(\" rpm_min; %f;\\n\", spc->rpm_min);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_temp_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_pwr_temp *spc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tprintf(\"%s; %s; %d;\", timestr, pfield(a->hdr_line, FIRST), i + 1);\n\t\tprintf(\" %s; %s;\", pfield(NULL, 0), spc->device);\n\t\tprintf(\" %s; %f;\", pfield(NULL, 0), spc->temp);\n\t\tprintf(\" temp_min; %f;\", spc->temp_min);\n\t\tprintf(\" temp_max; %f;\\n\", spc->temp_max);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_in_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_pwr_in *spc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tprintf(\"%s; %s; %d;\", timestr, pfield(a->hdr_line, FIRST), i);\n\t\tprintf(\" %s; %s;\", pfield(NULL, 0), spc->device);\n\t\tprintf(\" %s; %f;\", pfield(NULL, 0), spc->in);\n\t\tprintf(\" in_min; %f;\", spc->in_min);\n\t\tprintf(\" in_max; %f;\\n\", spc->in_max);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_huge_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\n\tprintf(\"%s; %s; %llu;\", timestr, pfield(a->hdr_line, FIRST), smc->frhkb);\n\tprintf(\" hugtotal; %llu;\", smc->tlhkb);\n\tpfield(NULL, 0); /* Skip kbhugused */\n\tpfield(NULL, 0); /* Skip %hugused */\n\tprintf(\" %s; %llu;\", pfield(NULL, 0), smc->rsvdhkb);\n\tprintf(\" %s; %llu;\\n\", pfield(NULL, 0), smc->surphkb);\n}\n\n/*\n ***************************************************************************\n * Display weighted CPU frequency statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_wghfreq_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, k;\n\tstruct stats_pwr_wghfreq *spc, *spp, *spc_k, *spp_k;\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_wghfreq *) ((char *) a->buf[curr]  + i * a->msize * a->nr2);\n\t\tspp = (struct stats_pwr_wghfreq *) ((char *) a->buf[!curr] + i * a->msize * a->nr2);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\tprintf(\"%s; %s; %d;\", timestr, pfield(a->hdr_line, FIRST), i - 1);\n\n\t\tfor (k = 0; k < a->nr2; k++) {\n\n\t\t\tspc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * a->msize);\n\t\t\tif (!spc_k->freq)\n\t\t\t\tbreak;\n\t\t\tspp_k = (struct stats_pwr_wghfreq *) ((char *) spp + k * a->msize);\n\n\t\t\tprintf(\" freq; %lu;\", spc_k->freq);\n\t\t\tprintf(\" tminst\");\n\t\t\tpval(spp_k->time_in_state, spc_k->time_in_state);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display USB devices statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_usb_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_pwr_usb *suc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsuc = (struct stats_pwr_usb *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tprintf(\"%s; %s; \\\"%s\\\";\", timestr, pfield(a->hdr_line, FIRST), suc->manufacturer);\n\t\tprintf(\" %s; \\\"%s\\\";\", pfield(NULL, 0), suc->product);\n\t\tprintf(\" %s; %u;\", pfield(NULL, 0), suc->bus_nr);\n\t\tprintf(\" %s; %x;\", pfield(NULL, 0), suc->vendor_id);\n\t\tprintf(\" %s; %x;\", pfield(NULL, 0), suc->product_id);\n\t\tprintf(\" %s; %u;\\n\", pfield(NULL, 0), suc->bmaxpower);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display filesystems statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_filesystem_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_filesystem *sfc;\n\tchar *dev_name;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"%s; %s; \\\"%s\\\";\", timestr, pfield(a->hdr_line, FIRST + DISPLAY_MOUNT(a->opt_flags)),\n\t\t       dev_name);\n\t\tprintf(\" f_bfree; %llu;\", sfc->f_bfree);\n\t\tprintf(\" f_blocks; %llu;\", sfc->f_blocks);\n\t\tprintf(\" f_bavail; %llu;\", sfc->f_bavail);\n\t\tpfield(NULL, 0); /* Skip MBfsfree */\n\t\tpfield(NULL, 0); /* Skip MBfsused */\n\t\tpfield(NULL, 0); /* Skip %fsused */\n\t\tpfield(NULL, 0); /* Skip %ufsused */\n\t\tprintf(\" %s; %llu;\", pfield(NULL, 0), sfc->f_ffree);\n\t\tprintf(\" f_files; %llu;\\n\", sfc->f_files);\n\n\t}\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_fchost_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i, j, j0, found;\n\tstruct stats_fchost *sfcc, *sfcp, sfczero;\n\n\tmemset(&sfczero, 0, sizeof(struct stats_fchost));\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\t/* Look for corresponding structure in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (!strcmp(sfcc->fchost_name, sfcp->fchost_name)) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\n\t\tif (!found) {\n\t\t\t/* This is a newly registered host. Previous stats are zero */\n\t\t\tsfcp = &sfczero;\n\t\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\t\tcprintf_s(IS_DEBUG, \"%s\", \" [NEW]\");\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"; %s;\", sfcc->fchost_name);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sfcp->f_rxframes, (unsigned long long) sfcc->f_rxframes);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sfcp->f_txframes, (unsigned long long) sfcc->f_txframes);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sfcp->f_rxwords, (unsigned long long) sfcc->f_rxwords);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) sfcp->f_txwords, (unsigned long long) sfcc->f_txwords);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_softnet_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_softnet *ssnc, *ssnp;\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Don't display CPU \"all\" which doesn't exist in file */\n\tfor (i = 1; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_pwr_cpufreq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * ssnc = (struct stats_softnet *) a->buf[...] + i;\n                 */\n                ssnc = (struct stats_softnet *) ((char *) a->buf[curr]  + i * a->msize);\n                ssnp = (struct stats_softnet *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t/*\n\t\t * Note: a->nr is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/* Yes: Display current CPU stats */\n\t\tprintf(\"%s; %s\", timestr, pfield(a->hdr_line, FIRST));\n\t\tif (DISPLAY_DEBUG_MODE(flags) && i) {\n\t\t\tif (ssnc->processed + ssnc->dropped + ssnc->time_squeeze +\n\t\t\t    ssnc->received_rps + ssnc->flow_limit + ssnc->backlog_len == 0) {\n\t\t\t\t/* CPU is considered offline */\n\t\t\t\tcprintf_s(IS_DEBUG, \"%s\", \" [OFF]\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"; %d;\", i - 1);\n\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssnp->processed, (unsigned long long) ssnc->processed);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssnp->dropped, (unsigned long long) ssnc->dropped);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssnp->time_squeeze, (unsigned long long) ssnc->time_squeeze);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssnp->received_rps, (unsigned long long) ssnc->received_rps);\n\t\tprintf(\" %s\", pfield(NULL, 0));\n\t\tpval((unsigned long long) ssnp->flow_limit, (unsigned long long) ssnc->flow_limit);\n\t\tprintf(\" %s; %u;\", pfield(NULL, 0), ssnc->backlog_len);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_psicpu_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr],\n\t\t*psip = (struct stats_psi_cpu *) a->buf[!curr];\n\n\tprintf(\"%s; %s; %lu;\", timestr, pfield(a->hdr_line, FIRST), psic->some_acpu_10);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->some_acpu_60);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->some_acpu_300);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) psip->some_cpu_total, (unsigned long long) psic->some_cpu_total);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_psiio_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr],\n\t\t*psip = (struct stats_psi_io *) a->buf[!curr];\n\n\tprintf(\"%s; %s; %lu;\", timestr, pfield(a->hdr_line, FIRST), psic->some_aio_10);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->some_aio_60);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->some_aio_300);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) psip->some_io_total, (unsigned long long) psic->some_io_total);\n\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->full_aio_10);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->full_aio_60);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->full_aio_300);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) psip->full_io_total, (unsigned long long) psic->full_io_total);\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall mem statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_psimem_stats(struct activity *a, char *timestr, int curr)\n{\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr],\n\t\t*psip = (struct stats_psi_mem *) a->buf[!curr];\n\n\tprintf(\"%s; %s; %lu;\", timestr, pfield(a->hdr_line, FIRST), psic->some_amem_10);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->some_amem_60);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->some_amem_300);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) psip->some_mem_total, (unsigned long long) psic->some_mem_total);\n\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->full_amem_10);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->full_amem_60);\n\tprintf(\" %s; %lu;\", pfield(NULL, 0), psic->full_amem_300);\n\tprintf(\" %s\", pfield(NULL, 0));\n\tpval((unsigned long long) psip->full_mem_total, (unsigned long long) psic->full_mem_total);\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display batteries statistics in raw format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @timestr\tTime for current statistics sample.\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n__print_funct_t raw_print_pwr_bat_stats(struct activity *a, char *timestr, int curr)\n{\n\tint i;\n\tstruct stats_pwr_bat *spbc, *spbp;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\t\tspbp = (struct stats_pwr_bat *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tprintf(\"%s; %s; %d;\", timestr, pfield(a->hdr_line, FIRST), (int) spbc->bat_id);\n\t\tprintf(\" %s; %u; %u;\", pfield(NULL, 0),\n\t\t       (unsigned int) spbp->capacity, (unsigned int) spbc->capacity);\n\t\tprintf(\" status; %d\", (int) spbc->status);\n\n\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\tif (spbc->status >= BAT_STS_NR) {\n\t\t\t\tcprintf_s(IS_DEBUG, \" [%s]\", \"UNDEFINED\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcprintf_s(IS_COMMENT, \" [%s]\",\n\t\t\t\t\t  bat_status[(unsigned int) spbc->status]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\";\\n\");\n\t}\n}\n"
        },
        {
          "name": "raw_stats.h",
          "type": "blob",
          "size": 3.59375,
          "content": "/*\n * raw_stats.h: Include file used to display statistics in raw format.\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _RAW_STATS_H\n#define _RAW_STATS_H\n\n#include \"common.h\"\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display statistics in raw format.\n ***************************************************************************\n */\n\n__print_funct_t raw_print_cpu_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pcsw_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_irq_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_swap_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_paging_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_io_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_memory_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_ktables_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_queue_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_serial_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_disk_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_dev_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_edev_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_nfs_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_nfsd_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_sock_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_ip_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_eip_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_icmp_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_eicmp_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_tcp_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_etcp_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_udp_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_sock6_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_ip6_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_eip6_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_icmp6_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_eicmp6_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_net_udp6_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_cpufreq_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_fan_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_temp_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_in_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_huge_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_wghfreq_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_usb_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_filesystem_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_fchost_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_softnet_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_psicpu_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_psiio_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_psimem_stats\n\t(struct activity *, char *, int);\n__print_funct_t raw_print_pwr_bat_stats\n\t(struct activity *, char *, int);\n\n#endif /* _RAW_STATS_H */\n"
        },
        {
          "name": "rd_sensors.c",
          "type": "blob",
          "size": 9.326171875,
          "content": "/*\n * rd_sensors.c: Read sensors statistics\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"rd_stats.h\"\n#include \"rd_sensors.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n#include \"sensors/sensors.h\"\n#endif\n\n/*\n ***************************************************************************\n * Read fan statistics.\n *\n * IN:\n * @st_pwr_fan\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_pwr_fan Structure with statistics.\n *\n * RETURNS:\n * Number of fans read, or -1 if the buffer was too small and needs to be\n * reallocated.\n ***************************************************************************\n */\n__nr_t read_fan(struct stats_pwr_fan *st_pwr_fan, __nr_t nr_alloc)\n{\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\t__nr_t fan_read = 0;\n\tconst sensors_chip_name *chip;\n\tconst sensors_feature *feature;\n\tconst sensors_subfeature *sub;\n\tstruct stats_pwr_fan *st_pwr_fan_i;\n\tint chip_nr = 0;\n\tint i, j;\n\n\tmemset(st_pwr_fan, 0, STATS_PWR_FAN_SIZE);\n\n\twhile ((chip = sensors_get_detected_chips(NULL, &chip_nr))) {\n\n\t\ti = 0;\n\t\twhile ((feature = sensors_get_features(chip, &i))) {\n\n\t\t\tif (feature->type == SENSORS_FEATURE_FAN) {\n\t\t\t\tj = 0;\n\t\t\t\tif (fan_read + 1 > nr_alloc)\n\t\t\t\t\treturn -1;\n\t\t\t\tst_pwr_fan_i = st_pwr_fan + fan_read++;\n\t\t\t\tsensors_snprintf_chip_name(st_pwr_fan_i->device, MAX_SENSORS_DEV_LEN, chip);\n\n\t\t\t\twhile ((sub = sensors_get_all_subfeatures(chip, feature, &j))) {\n\n\t\t\t\t\tif ((sub->type == SENSORS_SUBFEATURE_FAN_INPUT) &&\n\t\t\t\t\t    (sub->flags & SENSORS_MODE_R)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_fan_i->rpm)) {\n\t\t\t\t\t\t\tst_pwr_fan_i->rpm = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((sub->type == SENSORS_SUBFEATURE_FAN_MIN)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_fan_i->rpm_min)) {\n\t\t\t\t\t\t\tst_pwr_fan_i->rpm_min = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fan_read;\n#else\n\treturn 0;\n#endif /* HAVE_SENSORS */\n}\n\n/*\n ***************************************************************************\n * Read device temperature statistics.\n *\n * IN:\n * @st_pwr_temp\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_pwr_temp\tStructure with statistics.\n *\n * RETURNS:\n * Number of devices read, or -1 if the buffer was too small and needs to be\n * reallocated.\n ***************************************************************************\n */\n__nr_t read_temp(struct stats_pwr_temp *st_pwr_temp, __nr_t nr_alloc)\n{\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\t__nr_t temp_read = 0;\n\tconst sensors_chip_name *chip;\n\tconst sensors_feature *feature;\n\tconst sensors_subfeature *sub;\n\tstruct stats_pwr_temp *st_pwr_temp_i;\n\tint chip_nr = 0;\n\tint i, j;\n\n\tmemset(st_pwr_temp, 0, STATS_PWR_TEMP_SIZE);\n\n\twhile ((chip = sensors_get_detected_chips(NULL, &chip_nr))) {\n\n\t\ti = 0;\n\t\twhile ((feature = sensors_get_features(chip, &i))) {\n\n\t\t\tif (feature->type == SENSORS_FEATURE_TEMP) {\n\t\t\t\tj = 0;\n\t\t\t\tif (temp_read + 1 > nr_alloc)\n\t\t\t\t\treturn -1;\n\t\t\t\tst_pwr_temp_i = st_pwr_temp + temp_read++;\n\t\t\t\tsensors_snprintf_chip_name(st_pwr_temp_i->device, MAX_SENSORS_DEV_LEN, chip);\n\n\t\t\t\twhile ((sub = sensors_get_all_subfeatures(chip, feature, &j))) {\n\n\t\t\t\t\tif ((sub->type == SENSORS_SUBFEATURE_TEMP_INPUT) &&\n\t\t\t\t\t\t(sub->flags & SENSORS_MODE_R)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_temp_i->temp)) {\n\t\t\t\t\t\t\tst_pwr_temp_i->temp = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((sub->type == SENSORS_SUBFEATURE_TEMP_MIN)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_temp_i->temp_min)) {\n\t\t\t\t\t\t\tst_pwr_temp_i->temp_min = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((sub->type == SENSORS_SUBFEATURE_TEMP_MAX)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_temp_i->temp_max)) {\n\t\t\t\t\t\t\tst_pwr_temp_i->temp_max = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn temp_read;\n#else\n\treturn 0;\n#endif /* HAVE_SENSORS */\n}\n\n/*\n ***************************************************************************\n * Read voltage inputs statistics.\n *\n * IN:\n * @st_pwr_in\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_pwr_in\tStructure with statistics.\n *\n * RETURNS:\n * Number of devices read, or -1 if the buffer was too small and needs to be\n * reallocated.\n ***************************************************************************\n */\n__nr_t read_in(struct stats_pwr_in *st_pwr_in, __nr_t nr_alloc)\n{\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\t__nr_t in_read = 0;\n\tconst sensors_chip_name *chip;\n\tconst sensors_feature *feature;\n\tconst sensors_subfeature *sub;\n\tstruct stats_pwr_in *st_pwr_in_i;\n\tint chip_nr = 0;\n\tint i, j;\n\n\tmemset(st_pwr_in, 0, STATS_PWR_IN_SIZE);\n\n\twhile ((chip = sensors_get_detected_chips(NULL, &chip_nr))) {\n\n\t\ti = 0;\n\t\twhile ((feature = sensors_get_features(chip, &i))) {\n\n\t\t\tif (feature->type == SENSORS_FEATURE_IN) {\n\t\t\t\tj = 0;\n\t\t\t\tif (in_read + 1 > nr_alloc)\n\t\t\t\t\treturn -1;\n\t\t\t\tst_pwr_in_i = st_pwr_in + in_read++;\n\t\t\t\tsensors_snprintf_chip_name(st_pwr_in_i->device, MAX_SENSORS_DEV_LEN, chip);\n\n\t\t\t\twhile ((sub = sensors_get_all_subfeatures(chip, feature, &j))) {\n\n\t\t\t\t\tif ((sub->type == SENSORS_SUBFEATURE_IN_INPUT) &&\n\t\t\t\t\t\t(sub->flags & SENSORS_MODE_R)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_in_i->in)) {\n\t\t\t\t\t\t\tst_pwr_in_i->in = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((sub->type == SENSORS_SUBFEATURE_IN_MIN)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_in_i->in_min)) {\n\t\t\t\t\t\t\tst_pwr_in_i->in_min = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((sub->type == SENSORS_SUBFEATURE_IN_MAX)) {\n\t\t\t\t\t\tif (sensors_get_value(chip, sub->number, &st_pwr_in_i->in_max)) {\n\t\t\t\t\t\t\tst_pwr_in_i->in_max = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn in_read;\n#else\n\treturn 0;\n#endif /* HAVE_SENSORS */\n}\n\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n/*\n ***************************************************************************\n * Count the number of sensors of given type on the machine.\n *\n * IN:\n * @type\tType of sensors.\n *\n * RETURNS:\n * Number of sensors.\n ***************************************************************************\n */\n__nr_t get_sensors_nr(sensors_feature_type type) {\n\t__nr_t count = 0;\n\tconst sensors_chip_name *chip;\n\tconst sensors_feature *feature;\n\tint chip_nr = 0;\n\tint i;\n\n\twhile ((chip = sensors_get_detected_chips(NULL, &chip_nr))) {\n\n\t\ti = 0;\n\t\twhile ((feature = sensors_get_features(chip, &i))) {\n\n\t\t\tif (feature->type == type) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n#endif /* HAVE_SENSORS */\n\n/*\n ***************************************************************************\n * Count the number of fans on the machine.\n *\n * RETURNS:\n * Number of fans.\n ***************************************************************************\n */\n__nr_t get_fan_nr(void)\n{\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\treturn get_sensors_nr(SENSORS_FEATURE_FAN);\n#else\n\treturn 0;\n#endif /* HAVE_SENSORS */\n}\n\n/*\n ***************************************************************************\n * Count the number of temperature sensors on the machine.\n *\n * RETURNS:\n * Number of temperature sensors.\n ***************************************************************************\n */\n__nr_t get_temp_nr(void)\n{\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\treturn get_sensors_nr(SENSORS_FEATURE_TEMP);\n#else\n\treturn 0;\n#endif /* HAVE_SENSORS */\n}\n\n/*\n ***************************************************************************\n * Count the number of voltage inputs on the machine.\n *\n * RETURNS:\n * Number of voltage inputs.\n ***************************************************************************\n */\n__nr_t get_in_nr(void)\n{\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\treturn get_sensors_nr(SENSORS_FEATURE_IN);\n#else\n\treturn 0;\n#endif /* HAVE_SENSORS */\n}\n"
        },
        {
          "name": "rd_sensors.h",
          "type": "blob",
          "size": 2.3779296875,
          "content": "/*\n * rd_sensors.h: Include file used to read sensors statistics\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _RD_SENSORS_H\n#define _RD_SENSORS_H\n\n/*\n ***************************************************************************\n * Definitions of structures for sensors statistics\n ***************************************************************************\n */\n\n/*\n * Structure for fan statistics.\n */\nstruct stats_pwr_fan {\n\tdouble  rpm\t\t\t\t__attribute__ ((aligned (8)));\n\tdouble  rpm_min\t\t\t\t__attribute__ ((aligned (8)));\n\tchar    device[MAX_SENSORS_DEV_LEN]\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PWR_FAN_SIZE     (sizeof(struct stats_pwr_fan))\n#define STATS_PWR_FAN_ULL\t2\n#define STATS_PWR_FAN_UL\t0\n#define STATS_PWR_FAN_U\t\t0\n#define STATS_PWR_FAN_XNR\t2\n\n/*\n * Structure for device temperature statistics.\n */\nstruct stats_pwr_temp {\n\tdouble  temp\t\t\t\t__attribute__ ((aligned (8)));\n\tdouble  temp_min\t\t\t__attribute__ ((aligned (8)));\n\tdouble  temp_max\t\t\t__attribute__ ((aligned (8)));\n\tchar    device[MAX_SENSORS_DEV_LEN]\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PWR_TEMP_SIZE    (sizeof(struct stats_pwr_temp))\n#define STATS_PWR_TEMP_ULL\t3\n#define STATS_PWR_TEMP_UL\t0\n#define STATS_PWR_TEMP_U\t0\n#define STATS_PWR_TEMP_XNR\t2\n\n/*\n * Structure for voltage inputs statistics.\n */\nstruct stats_pwr_in {\n\tdouble  in\t\t\t\t__attribute__ ((aligned (8)));\n\tdouble  in_min\t\t\t\t__attribute__ ((aligned (8)));\n\tdouble  in_max\t\t\t\t__attribute__ ((aligned (8)));\n\tchar    device[MAX_SENSORS_DEV_LEN]\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PWR_IN_SIZE\t(sizeof(struct stats_pwr_in))\n#define STATS_PWR_IN_ULL\t3\n#define STATS_PWR_IN_UL\t\t0\n#define STATS_PWR_IN_U\t\t0\n#define STATS_PWR_IN_XNR\t2\n\n/*\n ***************************************************************************\n * Prototypes for functions used to read sensors statistics\n ***************************************************************************\n */\n\n__nr_t read_fan\n\t(struct stats_pwr_fan *, __nr_t);\n__nr_t read_temp\n\t(struct stats_pwr_temp *, __nr_t);\n__nr_t read_in\n\t(struct stats_pwr_in *, __nr_t);\n\n/*\n ***************************************************************************\n * Prototypes for functions used to count number of items\n ***************************************************************************\n */\n\n__nr_t get_fan_nr\n\t(void);\n__nr_t get_temp_nr\n\t(void);\n__nr_t get_in_nr\n\t(void);\n\n#endif /* _RD_SENSORS_H */\n"
        },
        {
          "name": "rd_stats.c",
          "type": "blob",
          "size": 82.19921875,
          "content": "/*\n * rd_stats.c: Read system statistics\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <unistd.h>\n\n#include \"common.h\"\n#include \"rd_stats.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n/* Generic PSI structure */\nstruct stats_psi {\n\tunsigned long long total;\n\tunsigned long\t   avg10;\n\tunsigned long\t   avg60;\n\tunsigned long\t   avg300;\n};\n\n/*\n ***************************************************************************\n * Read CPU statistics.\n * Remember that this function is used by several sysstat commands!\n *\n * IN:\n * @st_cpu\tBuffer where structures containing stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_cpu\tBuffer with statistics.\n *\n * RETURNS:\n * Highest CPU number(*) for which statistics have been read.\n * 1 means CPU \"all\", 2 means CPU 0, 3 means CPU 1, etc.\n * Or -1 if the buffer was too small and needs to be reallocated.\n *\n * (*)This doesn't account for all processors in the machine in the case\n * where some CPU are offline and located at the end of the list.\n *\n * USED BY:\n * sadc, iostat, mpstat, pidstat\n ***************************************************************************\n */\n__nr_t read_stat_cpu(struct stats_cpu *st_cpu, __nr_t nr_alloc)\n{\n\tFILE *fp;\n\tstruct stats_cpu *st_cpu_i;\n\tstruct stats_cpu sc;\n\tchar line[8192];\n\tint proc_nr;\n\t__nr_t cpu_read = 0;\n\n\tif ((fp = fopen(STAT, \"r\")) == NULL) {\n\t\tfprintf(stderr, _(\"Cannot open %s: %s\\n\"), STAT, strerror(errno));\n\t\texit(2);\n\t}\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"cpu \", 4)) {\n\n\t\t\t/*\n\t\t\t * All the fields don't necessarily exist,\n\t\t\t * depending on the kernel version used.\n\t\t\t */\n\t\t\tmemset(st_cpu, 0, STATS_CPU_SIZE);\n\n\t\t\t/*\n\t\t\t * Read the number of jiffies spent in the different modes\n\t\t\t * (user, nice, etc.) among all proc. CPU usage is not reduced\n\t\t\t * to one processor to avoid rounding problems.\n\t\t\t */\n\t\t\tsscanf(line + 5, \"%llu %llu %llu %llu %llu %llu %llu %llu %llu %llu\",\n\t\t\t       &st_cpu->cpu_user,\n\t\t\t       &st_cpu->cpu_nice,\n\t\t\t       &st_cpu->cpu_sys,\n\t\t\t       &st_cpu->cpu_idle,\n\t\t\t       &st_cpu->cpu_iowait,\n\t\t\t       &st_cpu->cpu_hardirq,\n\t\t\t       &st_cpu->cpu_softirq,\n\t\t\t       &st_cpu->cpu_steal,\n\t\t\t       &st_cpu->cpu_guest,\n\t\t\t       &st_cpu->cpu_guest_nice);\n\n\t\t\tif (!cpu_read) {\n\t\t\t\tcpu_read = 1;\n\t\t\t}\n\n\t\t\tif (nr_alloc == 1)\n\t\t\t\t/* We just want to read stats for CPU \"all\" */\n\t\t\t\tbreak;\n\t\t}\n\n\t\telse if (!strncmp(line, \"cpu\", 3)) {\n\t\t\t/* All the fields don't necessarily exist */\n\t\t\tmemset(&sc, 0, STATS_CPU_SIZE);\n\t\t\t/*\n\t\t\t * Read the number of jiffies spent in the different modes\n\t\t\t * (user, nice, etc) for current proc.\n\t\t\t * This is done only on SMP machines.\n\t\t\t */\n\t\t\tsscanf(line + 3, \"%d %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu\",\n\t\t\t       &proc_nr,\n\t\t\t       &sc.cpu_user,\n\t\t\t       &sc.cpu_nice,\n\t\t\t       &sc.cpu_sys,\n\t\t\t       &sc.cpu_idle,\n\t\t\t       &sc.cpu_iowait,\n\t\t\t       &sc.cpu_hardirq,\n\t\t\t       &sc.cpu_softirq,\n\t\t\t       &sc.cpu_steal,\n\t\t\t       &sc.cpu_guest,\n\t\t\t       &sc.cpu_guest_nice);\n\n\t\t\tif (proc_nr + 2 > nr_alloc) {\n\t\t\t\tcpu_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst_cpu_i = st_cpu + proc_nr + 1;\n\t\t\t*st_cpu_i = sc;\n\n\t\t\tif (proc_nr + 2 > cpu_read) {\n\t\t\t\tcpu_read = proc_nr + 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn cpu_read;\n}\n\n/*\n ***************************************************************************\n * Read interrupts statistics from /proc/interrupts.\n *\n * IN:\n * @st_irq\tStructure where stats will be saved.\n * @nr_alloc\tNumber of CPU structures allocated. Value is >= 1.\n * @nr_int\tNumber of interrupts, including sum. value is >= 1.\n *\n * OUT:\n * @st_irq\tStructure with statistics.\n *\n * RETURNS:\n * Highest CPU number for which stats have been successfully read (2 for CPU0,\n * 3 for CPU 1, etc.) Same logic than for softnet statistics. This number will\n * be saved in a->_nr0. See wrap_read_stat_irq().\n * Returns 0 if no statistics have been read.\n * Returns -1 if the buffer was too small and needs to be reallocated (we\n * mean here, too small for all the CPU, not for the interrupts whose number\n * is considered to be a constant. Remember that only the number of items is\n * saved in file preceding each sample, not the number of sub-items).\n ***************************************************************************\n */\n__nr_t read_stat_irq(struct stats_irq *st_irq, __nr_t nr_alloc, __nr_t nr_int)\n{\n\tFILE *fp;\n\tstruct stats_irq *st_cpuall_sum, *st_cpu_irq, *st_cpu_sum, *st_cpuall_irq;\n\tchar *line = NULL, *li;\n\tint rc = 0, irq_read = 0;\n\tint cpu, len;\n\tint cpu_nr = nr_alloc - 1;\n\tint *cpu_index = NULL, index = 0;\n\tchar *cp, *next;\n\n\tif (!cpu_nr) {\n\t\t/* We have only one proc and a non SMP kernel */\n\t\tcpu_nr = 1;\n\t}\n\tSREALLOC(cpu_index, int, sizeof(int) * cpu_nr);\n\n\tif ((fp = fopen(INTERRUPTS, \"r\")) != NULL) {\n\n\t\tSREALLOC(line, char, INTERRUPTS_LINE + 11 * cpu_nr);\n\n\t\t/*\n\t\t * Parse header line to see which CPUs are online\n\t\t */\n\t\twhile (fgets(line, INTERRUPTS_LINE + 11 * cpu_nr, fp) != NULL) {\n\n\t\t\tnext = line;\n\t\t\twhile (((cp = strstr(next, \"CPU\")) != NULL) && (index < cpu_nr)) {\n\t\t\t\tcpu = strtol(cp + 3, &next, 10);\n\n\t\t\t\tif (cpu + 2 > nr_alloc) {\n\t\t\t\t\trc = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcpu_index[index++] = cpu;\n\t\t\t}\n\t\t\tif (index)\n\t\t\t\t/* Header line found */\n\t\t\t\tbreak;\n\t\t}\n\n\t\tst_cpuall_sum = st_irq;\n\t\t/* Save name \"sum\" for total number of interrupts */\n\t\tstrcpy(st_cpuall_sum->irq_name, K_LOWERSUM);\n\n\t\t/* Parse each line of interrupts statistics data */\n\t\twhile ((fgets(line, INTERRUPTS_LINE + 11 * cpu_nr, fp) != NULL) &&\n\t\t       (irq_read < nr_int - 1)) {\n\n\t\t\t/* Skip over \"<irq>:\" */\n\t\t\tif ((cp = strchr(line, ':')) == NULL)\n\t\t\t\t/* Chr ':' not found */\n\t\t\t\tcontinue;\n\t\t\tcp++;\n\n\t\t\tirq_read++;\n\t\t\tst_cpuall_irq = st_irq + irq_read;\n\n\t\t\t/* Remove possible heading spaces in interrupt's name... */\n\t\t\tli = line;\n\t\t\twhile (*li == ' ')\n\t\t\t\tli++;\n\n\t\t\tlen = strcspn(li, \":\");\n\t\t\tif (len >= MAX_SA_IRQ_LEN) {\n\t\t\t\tlen = MAX_SA_IRQ_LEN - 1;\n\t\t\t}\n\t\t\t/* ...then save its name */\n\t\t\tstrncpy(st_cpuall_irq->irq_name, li, len);\n\t\t\tst_cpuall_irq->irq_name[len] = '\\0';\n\n\t\t\t/* For each interrupt: Get number received by each CPU */\n\t\t\tfor (cpu = 0; cpu < index; cpu++) {\n\t\t\t\tst_cpu_sum = st_irq + (cpu_index[cpu] + 1) * nr_int;\n\t\t\t\tst_cpu_irq = st_irq + (cpu_index[cpu] + 1) * nr_int + irq_read;\n\t\t\t\t/*\n\t\t\t\t * Interrupt name is saved only for CPU \"all\".\n\t\t\t\t * Now save current interrupt value for current CPU\n\t\t\t\t * and total number of interrupts received by current CPU\n\t\t\t\t * and number of current interrupt received by all CPU.\n\t\t\t\t */\n\t\t\t\tst_cpu_irq->irq_nr = strtoul(cp, &next, 10);\n\t\t\t\tst_cpuall_irq->irq_nr += st_cpu_irq->irq_nr;\n\t\t\t\tst_cpu_sum->irq_nr += st_cpu_irq->irq_nr;\n\t\t\t\tcp = next;\n\t\t\t}\n\t\t\tst_cpuall_sum->irq_nr += st_cpuall_irq->irq_nr;\n\t\t}\nout:\n\t\tfree(line);\n\t\tfclose(fp);\n\t}\n\n\tif (index && !rc) {\n\t\trc = cpu_index[index - 1] + 2;\n\t}\n\n\tfree(cpu_index);\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Read memory statistics from /proc/meminfo.\n *\n * IN:\n * @st_memory\tStructure where stats will be saved.\n *\n * OUT:\n * @st_memory\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n *\n * USED BY:\n * sadc, pidstat\n ***************************************************************************\n */\n__nr_t read_meminfo(struct stats_memory *st_memory)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(MEMINFO, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"MemTotal:\", 9)) {\n\t\t\t/* Read the total amount of memory in kB */\n\t\t\tsscanf(line + 9, \"%llu\", &st_memory->tlmkb);\n\t\t}\n\t\telse if (!strncmp(line, \"MemFree:\", 8)) {\n\t\t\t/* Read the amount of free memory in kB */\n\t\t\tsscanf(line + 8, \"%llu\", &st_memory->frmkb);\n\t\t}\n\t\telse if (!strncmp(line, \"MemAvailable:\", 13)) {\n\t\t\t/* Read the amount of available memory in kB */\n\t\t\tsscanf(line + 13, \"%llu\", &st_memory->availablekb);\n\t\t}\n\t\telse if (!strncmp(line, \"Buffers:\", 8)) {\n\t\t\t/* Read the amount of buffered memory in kB */\n\t\t\tsscanf(line + 8, \"%llu\", &st_memory->bufkb);\n\t\t}\n\t\telse if (!strncmp(line, \"Cached:\", 7)) {\n\t\t\t/* Read the amount of cached memory in kB */\n\t\t\tsscanf(line + 7, \"%llu\", &st_memory->camkb);\n\t\t}\n\t\telse if (!strncmp(line, \"SwapCached:\", 11)) {\n\t\t\t/* Read the amount of cached swap in kB */\n\t\t\tsscanf(line + 11, \"%llu\", &st_memory->caskb);\n\t\t}\n\t\telse if (!strncmp(line, \"Active:\", 7)) {\n\t\t\t/* Read the amount of active memory in kB */\n\t\t\tsscanf(line + 7, \"%llu\", &st_memory->activekb);\n\t\t}\n\t\telse if (!strncmp(line, \"Inactive:\", 9)) {\n\t\t\t/* Read the amount of inactive memory in kB */\n\t\t\tsscanf(line + 9, \"%llu\", &st_memory->inactkb);\n\t\t}\n\t\telse if (!strncmp(line, \"SwapTotal:\", 10)) {\n\t\t\t/* Read the total amount of swap memory in kB */\n\t\t\tsscanf(line + 10, \"%llu\", &st_memory->tlskb);\n\t\t}\n\t\telse if (!strncmp(line, \"SwapFree:\", 9)) {\n\t\t\t/* Read the amount of free swap memory in kB */\n\t\t\tsscanf(line + 9, \"%llu\", &st_memory->frskb);\n\t\t}\n\t\telse if (!strncmp(line, \"Dirty:\", 6)) {\n\t\t\t/* Read the amount of dirty memory in kB */\n\t\t\tsscanf(line + 6, \"%llu\", &st_memory->dirtykb);\n\t\t}\n\t\telse if (!strncmp(line, \"Committed_AS:\", 13)) {\n\t\t\t/* Read the amount of commited memory in kB */\n\t\t\tsscanf(line + 13, \"%llu\", &st_memory->comkb);\n\t\t}\n\t\telse if (!strncmp(line, \"AnonPages:\", 10)) {\n\t\t\t/* Read the amount of pages mapped into userspace page tables in kB */\n\t\t\tsscanf(line + 10, \"%llu\", &st_memory->anonpgkb);\n\t\t}\n\t\telse if (!strncmp(line, \"Slab:\", 5)) {\n\t\t\t/* Read the amount of in-kernel data structures cache in kB */\n\t\t\tsscanf(line + 5, \"%llu\", &st_memory->slabkb);\n\t\t}\n\t\telse if (!strncmp(line, \"KernelStack:\", 12)) {\n\t\t\t/* Read the kernel stack utilization in kB */\n\t\t\tsscanf(line + 12, \"%llu\", &st_memory->kstackkb);\n\t\t}\n\t\telse if (!strncmp(line, \"PageTables:\", 11)) {\n\t\t\t/* Read the amount of memory dedicated to the lowest level of page tables in kB */\n\t\t\tsscanf(line + 11, \"%llu\", &st_memory->pgtblkb);\n\t\t}\n\t\telse if (!strncmp(line, \"VmallocUsed:\", 12)) {\n\t\t\t/* Read the amount of vmalloc area which is used in kB */\n\t\t\tsscanf(line + 12, \"%llu\", &st_memory->vmusedkb);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read machine uptime, independently of the number of processors.\n *\n * OUT:\n * @uptime\tUptime value in hundredths of a second.\n *\n * USED BY:\n * sadc, cifsiostat, iostat, mpstat, pidstat\n ***************************************************************************\n */\nvoid read_uptime(unsigned long long *uptime)\n{\n\tFILE *fp = NULL;\n\tchar line[128];\n\tunsigned long up_sec, up_cent;\n\tint err = FALSE;\n\n\tif ((fp = fopen(UPTIME, \"r\")) == NULL) {\n\t\terr = TRUE;\n\t}\n\telse if (fgets(line, sizeof(line), fp) == NULL) {\n\t\terr = TRUE;\n\t}\n\telse if (sscanf(line, \"%lu.%lu\", &up_sec, &up_cent) == 2) {\n\t\t*uptime = (unsigned long long) up_sec * 100 +\n\t\t\t  (unsigned long long) up_cent;\n\t}\n\telse {\n\t\terr = TRUE;\n\t}\n\n\tif (fp != NULL) {\n\t\tfclose(fp);\n\t}\n\tif (err) {\n\t\tfprintf(stderr, _(\"Cannot read %s\\n\"), UPTIME);\n\t\texit(2);\n\t}\n}\n\n/*\n ***************************************************************************\n * Compute \"extended\" device statistics (service time, etc.).\n *\n * IN:\n * @sdc\t\tStructure with current device statistics.\n * @sdp\t\tStructure with previous device statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n *\n * OUT:\n * @xds\t\tStructure with extended statistics.\n *\n * USED BY:\n * sar, sadf, iostat\n ***************************************************************************\n*/\nvoid compute_ext_disk_stats(struct stats_disk *sdc, struct stats_disk *sdp,\n\t\t\t    unsigned long long itv, struct ext_disk_stats *xds)\n{\n\txds->util  = sdc->tot_ticks < sdp->tot_ticks ?\n\t\t     0.0 :\n\t\t     S_VALUE(sdp->tot_ticks, sdc->tot_ticks, itv);\n\t/*\n\t * Kernel gives ticks already in milliseconds for all platforms\n\t * => no need for further scaling.\n\t * Origin (unmerged) flush operations are counted as writes.\n\t */\n\txds->await = (sdc->nr_ios > sdp->nr_ios) ?\n\t\t((sdc->rd_ticks - sdp->rd_ticks) + (sdc->wr_ticks - sdp->wr_ticks) + (sdc->dc_ticks - sdp->dc_ticks)) /\n\t\t((double) (sdc->nr_ios - sdp->nr_ios)) : 0.0;\n\txds->arqsz = (sdc->nr_ios > sdp->nr_ios) ?\n\t\t((sdc->rd_sect - sdp->rd_sect) + (sdc->wr_sect - sdp->wr_sect) + (sdc->dc_sect - sdp->dc_sect)) /\n\t\t((double) (sdc->nr_ios - sdp->nr_ios)) : 0.0;\n}\n\n/*\n ***************************************************************************\n * Since ticks may vary slightly from CPU to CPU, we'll want\n * to recalculate itv based on this CPU's tick count, rather\n * than that reported by the \"cpu\" line. Otherwise we\n * occasionally end up with slightly skewed figures, with\n * the skew being greater as the time interval grows shorter.\n *\n * IN:\n * @scc\tCurrent sample statistics for current CPU.\n * @scp\tPrevious sample statistics for current CPU.\n *\n * RETURNS:\n * Interval of time based on current CPU, expressed in jiffies.\n *\n * USED BY:\n * sar, sadf, mpstat\n ***************************************************************************\n */\nunsigned long long get_per_cpu_interval(struct stats_cpu *scc,\n\t\t\t\t\tstruct stats_cpu *scp)\n{\n\tunsigned long long ishift = 0LL;\n\n\tif ((scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest)) {\n\t\t/*\n\t\t * Sometimes the nr of jiffies spent in guest mode given by the guest\n\t\t * counter in /proc/stat is slightly higher than that included in\n\t\t * the user counter. Update the interval value accordingly.\n\t\t */\n\t\tishift += (scp->cpu_user - scp->cpu_guest) -\n\t\t          (scc->cpu_user - scc->cpu_guest);\n\t}\n\tif ((scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice)) {\n\t\t/*\n\t\t * Idem for nr of jiffies spent in guest_nice mode.\n\t\t */\n\t\tishift += (scp->cpu_nice - scp->cpu_guest_nice) -\n\t\t          (scc->cpu_nice - scc->cpu_guest_nice);\n\t}\n\n\t/*\n\t * Workaround for CPU coming back online: With recent kernels\n\t * some fields (user, nice, system) restart from their previous value,\n\t * whereas others (idle, iowait) restart from zero.\n\t * For the latter we need to set their previous value to zero to\n\t * avoid getting an interval value < 0.\n\t * (I don't know how the other fields like hardirq, steal... behave).\n\t * Don't assume the CPU has come back from offline state if previous\n\t * value was greater than ULLONG_MAX - 0x7ffff (the counter probably\n\t * overflew).\n\t */\n\tif ((scc->cpu_iowait < scp->cpu_iowait) && (scp->cpu_iowait < (ULLONG_MAX - 0x7ffff))) {\n\t\t/*\n\t\t * The iowait value reported by the kernel can also decrement as\n\t\t * a result of inaccurate iowait tracking. Waiting on IO can be\n\t\t * first accounted as iowait but then instead as idle.\n\t\t * Therefore if the idle value during the same period did not\n\t\t * decrease then consider this is a problem with the iowait\n\t\t * reporting and correct the previous value according to the new\n\t\t * reading. Otherwise, treat this as CPU coming back online.\n\t\t */\n\t\tif ((scc->cpu_idle > scp->cpu_idle) || (scp->cpu_idle >= (ULLONG_MAX - 0x7ffff))) {\n\t\t\tscp->cpu_iowait = scc->cpu_iowait;\n\t\t}\n\t\telse {\n\t\t\tscp->cpu_iowait = 0;\n\t\t}\n\t}\n\tif ((scc->cpu_idle < scp->cpu_idle) && (scp->cpu_idle < (ULLONG_MAX - 0x7ffff))) {\n\t\tscp->cpu_idle = 0;\n\t}\n\n\t/*\n\t * Don't take cpu_guest and cpu_guest_nice into account\n\t * because cpu_user and cpu_nice already include them.\n\t */\n\treturn ((scc->cpu_user    + scc->cpu_nice   +\n\t\t scc->cpu_sys     + scc->cpu_iowait +\n\t\t scc->cpu_idle    + scc->cpu_steal  +\n\t\t scc->cpu_hardirq + scc->cpu_softirq) -\n\t\t(scp->cpu_user    + scp->cpu_nice   +\n\t\t scp->cpu_sys     + scp->cpu_iowait +\n\t\t scp->cpu_idle    + scp->cpu_steal  +\n\t\t scp->cpu_hardirq + scp->cpu_softirq) +\n\t\t ishift);\n}\n\n#ifdef SOURCE_SADC\n/*---------------- BEGIN: FUNCTIONS USED BY SADC ONLY ---------------------*/\n\n/*\n ***************************************************************************\n * Replace octal codes in string with their corresponding characters.\n *\n * IN:\n * @str\t\tString to parse.\n *\n * OUT:\n * @str\t\tString with octal codes replaced with characters.\n ***************************************************************************\n */\nvoid oct2chr(char *str)\n{\n\tint i = 0;\n\tint j, len;\n\n\tlen = strlen(str);\n\n\twhile (i < len - 3) {\n\n\t\tif ((str[i] == '\\\\') &&\n\t\t    (str[i + 1] >= '0') && (str[i + 1] <= '3') &&\n\t\t    (str[i + 2] >= '0') && (str[i + 2] <= '7') &&\n\t\t    (str[i + 3] >= '0') && (str[i + 3] <= '7')) {\n\t\t\t/* Octal code found */\n\t\t\tstr[i] = (str[i + 1] - 48) * 64 +\n\t\t\t         (str[i + 2] - 48) * 8  +\n\t\t\t         (str[i + 3] - 48);\n\t\t\tfor (j = i + 4; j <= len; j++) {\n\t\t\t\tstr[j - 3] = str[j];\n\t\t\t}\n\t\t\tlen -= 3;\n\t\t}\n\t\ti++;\n\t}\n}\n\n/*\n ***************************************************************************\n * Read processes (tasks) creation and context switches statistics\n * from /proc/stat.\n *\n * IN:\n * @st_pcsw\tStructure where stats will be saved.\n *\n * OUT:\n * @st_pcsw\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_stat_pcsw(struct stats_pcsw *st_pcsw)\n{\n\tFILE *fp;\n\tchar line[8192];\n\n\tif ((fp = fopen(STAT, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"ctxt \", 5)) {\n\t\t\t/* Read number of context switches */\n\t\t\tsscanf(line + 5, \"%llu\", &st_pcsw->context_switch);\n\t\t}\n\n\t\telse if (!strncmp(line, \"processes \", 10)) {\n\t\t\t/* Read number of processes created since system boot */\n\t\t\tsscanf(line + 10, \"%lu\", &st_pcsw->processes);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read queue and load statistics from /proc/loadavg and /proc/stat.\n *\n * IN:\n * @st_queue\tStructure where stats will be saved.\n *\n * OUT:\n * @st_queue\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_loadavg(struct stats_queue *st_queue)\n{\n\tFILE *fp;\n\tchar line[8192];\n\tunsigned int load_tmp[3];\n\tint rc;\n\n\tif ((fp = fopen(LOADAVG, \"r\")) == NULL)\n\t\treturn 0;\n\n\t/* Read load averages and queue length */\n\trc = fscanf(fp, \"%u.%u %u.%u %u.%u %llu/%llu %*d\\n\",\n\t\t    &load_tmp[0], &st_queue->load_avg_1,\n\t\t    &load_tmp[1], &st_queue->load_avg_5,\n\t\t    &load_tmp[2], &st_queue->load_avg_15,\n\t\t    &st_queue->nr_running,\n\t\t    &st_queue->nr_threads);\n\n\tfclose(fp);\n\n\tif (rc < 8)\n\t\treturn 0;\n\n\tst_queue->load_avg_1  += load_tmp[0] * 100;\n\tst_queue->load_avg_5  += load_tmp[1] * 100;\n\tst_queue->load_avg_15 += load_tmp[2] * 100;\n\n\tif (st_queue->nr_running) {\n\t\t/* Do not take current process into account */\n\t\tst_queue->nr_running--;\n\t}\n\n\t/* Read nr of tasks blocked from /proc/stat */\n\tif ((fp = fopen(STAT, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"procs_blocked \", 14)) {\n\t\t\t/* Read number of processes blocked */\n\t\t\tsscanf(line + 14, \"%llu\", &st_queue->procs_blocked);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read swapping statistics from /proc/vmstat.\n *\n * IN:\n * @st_swap\tStructure where stats will be saved.\n *\n * OUT:\n * @st_swap\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_vmstat_swap(struct stats_swap *st_swap)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(VMSTAT, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"pswpin \", 7)) {\n\t\t\t/* Read number of swap pages brought in */\n\t\t\tsscanf(line + 7, \"%lu\", &st_swap->pswpin);\n\t\t}\n\t\telse if (!strncmp(line, \"pswpout \", 8)) {\n\t\t\t/* Read number of swap pages brought out */\n\t\t\tsscanf(line + 8, \"%lu\", &st_swap->pswpout);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read paging statistics from /proc/vmstat.\n *\n * IN:\n * @st_paging\tStructure where stats will be saved.\n *\n * OUT:\n * @st_paging\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_vmstat_paging(struct stats_paging *st_paging)\n{\n\tFILE *fp;\n\tchar line[128];\n\tunsigned long pgtmp;\n\n\tif ((fp = fopen(VMSTAT, \"r\")) == NULL)\n\t\treturn 0;\n\n\tst_paging->pgsteal = 0;\n\tst_paging->pgscan_kswapd = st_paging->pgscan_direct = 0;\n\tst_paging->pgdemote = 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"pgpgin \", 7)) {\n\t\t\t/* Read number of pages the system paged in */\n\t\t\tsscanf(line + 7, \"%lu\", &st_paging->pgpgin);\n\t\t}\n\t\telse if (!strncmp(line, \"pgpgout \", 8)) {\n\t\t\t/* Read number of pages the system paged out */\n\t\t\tsscanf(line + 8, \"%lu\", &st_paging->pgpgout);\n\t\t}\n\t\telse if (!strncmp(line, \"pgfault \", 8)) {\n\t\t\t/* Read number of faults (major+minor) made by the system */\n\t\t\tsscanf(line + 8, \"%lu\", &st_paging->pgfault);\n\t\t}\n\t\telse if (!strncmp(line, \"pgmajfault \", 11)) {\n\t\t\t/* Read number of faults (major only) made by the system */\n\t\t\tsscanf(line + 11, \"%lu\", &st_paging->pgmajfault);\n\t\t}\n\t\telse if (!strncmp(line, \"pgfree \", 7)) {\n\t\t\t/* Read number of pages freed by the system */\n\t\t\tsscanf(line + 7, \"%lu\", &st_paging->pgfree);\n\t\t}\n\t\telse if (!strncmp(line, \"pgsteal_\", 8)) {\n\t\t\t/* Read number of pages stolen by the system */\n\t\t\tsscanf(strchr(line, ' '), \"%lu\", &pgtmp);\n\t\t\tst_paging->pgsteal += pgtmp;\n\t\t}\n\t\telse if (!strncmp(line, \"pgscan_kswapd\", 13)) {\n\t\t\t/* Read number of pages scanned by the kswapd daemon */\n\t\t\tsscanf(strchr(line, ' '), \"%lu\", &pgtmp);\n\t\t\tst_paging->pgscan_kswapd += pgtmp;\n\t\t}\n\t\telse if (!strncmp(line, \"pgscan_direct\", 13)) {\n\t\t\t/* Read number of pages scanned directly */\n\t\t\tsscanf(strchr(line, ' '), \"%lu\", &pgtmp);\n\t\t\tst_paging->pgscan_direct += pgtmp;\n\t\t}\n\t\telse if (!strncmp(line, \"pgpromote_success \", 18)) {\n\t\t\t/* Read number of successful page promotions */\n\t\t\tsscanf(line + 18, \"%lu\", &st_paging->pgpromote);\n\t\t}\n\t\telse if (!strncmp(line, \"pgdemote_\", 9)) {\n\t\t\tsscanf(strchr(line, ' '), \"%lu\", &pgtmp);\n\t\t\tst_paging->pgdemote += pgtmp;\n\t\t}\t\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read I/O and transfer rates statistics from /proc/diskstats.\n *\n * IN:\n * @st_io\tStructure where stats will be saved.\n *\n * OUT:\n * @st_io\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_diskstats_io(struct stats_io *st_io)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tchar dev_name[MAX_NAME_LEN];\n\tunsigned int major, minor;\n\tunsigned long rd_ios, wr_ios, dc_ios;\n\tunsigned long rd_sec, wr_sec, dc_sec;\n\n\tif ((fp = fopen(DISKSTATS, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\t/* Discard I/O stats may be not available */\n\t\tdc_ios = dc_sec = 0;\n\n\t\tif (sscanf(line,\n\t\t\t   \"%u %u %127s \"\n\t\t\t   \"%lu %*u %lu %*u \"\n\t\t\t   \"%lu %*u %lu %*u \"\n\t\t\t   \"%*u %*u %*u \"\n\t\t\t   \"%lu %*u %lu\",\n\t\t\t   &major, &minor, dev_name,\n\t\t\t   &rd_ios, &rd_sec,\n\t\t\t   &wr_ios, &wr_sec,\n\t\t\t   &dc_ios, &dc_sec) >= 7) {\n\n\t\t\tif (is_device(SLASH_SYS, dev_name, IGNORE_VIRTUAL_DEVICES)) {\n\t\t\t\t/*\n\t\t\t\t * OK: It's a (real) device and not a partition.\n\t\t\t\t * Note: Structure should have been initialized first!\n\t\t\t\t */\n\t\t\t\tst_io->dk_drive      += (unsigned long long) rd_ios +\n\t\t\t\t\t\t\t(unsigned long long) wr_ios +\n\t\t\t\t\t\t\t(unsigned long long) dc_ios;\n\t\t\t\tst_io->dk_drive_rio  += rd_ios;\n\t\t\t\tst_io->dk_drive_rblk += rd_sec;\n\t\t\t\tst_io->dk_drive_wio  += wr_ios;\n\t\t\t\tst_io->dk_drive_wblk += wr_sec;\n\t\t\t\tst_io->dk_drive_dio  += dc_ios;\n\t\t\t\tst_io->dk_drive_dblk += dc_sec;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read block devices statistics from /proc/diskstats.\n *\n * IN:\n * @st_disk\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n * @read_part\tTrue if disks *and* partitions should be read; False if only\n * \t\tdisks are read.\n *\n * OUT:\n * @st_disk\tStructure with statistics.\n *\n * RETURNS:\n * Number of block devices read, or -1 if the buffer was too small and\n * needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_diskstats_disk(struct stats_disk *st_disk, __nr_t nr_alloc,\n\t\t\t   int read_part)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tchar dev_name[MAX_NAME_LEN];\n\tstruct stats_disk *st_disk_i;\n\tunsigned int major, minor, rd_ticks, wr_ticks, dc_ticks, tot_ticks, rq_ticks, part_nr;\n\tunsigned long rd_ios, wr_ios, dc_ios, rd_sec, wr_sec, dc_sec;\n\tunsigned long long wwn[2];\n\t__nr_t dsk_read = 0;\n\n\tif ((fp = fopen(DISKSTATS, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\t/* Discard I/O stats may be not available */\n\t\tdc_ios = dc_sec = dc_ticks = 0;\n\n\t\tif (sscanf(line,\n\t\t\t   \"%u %u %127s \"\n\t\t\t   \"%lu %*u %lu %u \"\n\t\t\t   \"%lu %*u %lu %u \"\n\t\t\t   \"%*u %u %u \"\n\t\t\t   \"%lu %*u %lu %u\",\n\t\t\t   &major, &minor, dev_name,\n\t\t\t   &rd_ios, &rd_sec, &rd_ticks,\n\t\t\t   &wr_ios, &wr_sec, &wr_ticks,\n\t\t\t   &tot_ticks, &rq_ticks,\n\t\t\t   &dc_ios, &dc_sec, &dc_ticks) >= 11) {\n\n\t\t\tif (!rd_ios && !wr_ios && !dc_ios)\n\t\t\t\t/* Unused device: Ignore it */\n\t\t\t\tcontinue;\n\t\t\tif (read_part || is_device(SLASH_SYS, dev_name, ACCEPT_VIRTUAL_DEVICES)) {\n\n\t\t\t\tif (dsk_read + 1 > nr_alloc) {\n\t\t\t\t\tdsk_read = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tst_disk_i = st_disk + dsk_read++;\n\t\t\t\tst_disk_i->major     = major;\n\t\t\t\tst_disk_i->minor     = minor;\n\t\t\t\tst_disk_i->nr_ios    = (unsigned long long) rd_ios +\n\t\t\t\t\t\t       (unsigned long long) wr_ios +\n\t\t\t\t\t\t       (unsigned long long) dc_ios;\n\t\t\t\tst_disk_i->rd_sect   = rd_sec;\n\t\t\t\tst_disk_i->wr_sect   = wr_sec;\n\t\t\t\tst_disk_i->dc_sect   = dc_sec;\n\t\t\t\tst_disk_i->rd_ticks  = rd_ticks;\n\t\t\t\tst_disk_i->wr_ticks  = wr_ticks;\n\t\t\t\tst_disk_i->dc_ticks  = dc_ticks;\n\t\t\t\tst_disk_i->tot_ticks = tot_ticks;\n\t\t\t\tst_disk_i->rq_ticks  = rq_ticks;\n\n\t\t\t\tif (get_wwnid_from_pretty(dev_name, wwn, &part_nr) < 0) {\n\t\t\t\t\tst_disk_i->wwn[0] = 0ULL;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tst_disk_i->wwn[0] = wwn[0];\n\t\t\t\t\tst_disk_i->wwn[1] = wwn[1];\n\t\t\t\t\tst_disk_i->part_nr = part_nr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn dsk_read;\n}\n\n/*\n ***************************************************************************\n * Read serial lines statistics from /proc/tty/driver/serial.\n *\n * IN:\n * @st_serial\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_serial\tStructure with statistics.\n *\n * RETURNS:\n * Number of serial lines read, or -1 if the buffer was too small and\n * needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_tty_driver_serial(struct stats_serial *st_serial, __nr_t nr_alloc)\n{\n\tFILE *fp;\n\tstruct stats_serial *st_serial_i;\n\tchar line[256];\n\tchar *p;\n\t__nr_t sl_read = 0;\n\n\tif ((fp = fopen(SERIAL, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL ) {\n\n\t\tif ((p = strstr(line, \"tx:\")) != NULL) {\n\n\t\t\tif (sl_read + 1 > nr_alloc) {\n\t\t\t\tsl_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst_serial_i = st_serial + sl_read++;\n\t\t\t/* Read serial line number */\n\t\t\tsscanf(line, \"%u\", &st_serial_i->line);\n\t\t\t/*\n\t\t\t * Read the number of chars transmitted and received by\n\t\t\t * current serial line.\n\t\t\t */\n\t\t\tsscanf(p + 3, \"%u\", &st_serial_i->tx);\n\t\t\tif ((p = strstr(line, \"rx:\")) != NULL) {\n\t\t\t\tsscanf(p + 3, \"%u\", &st_serial_i->rx);\n\t\t\t}\n\t\t\tif ((p = strstr(line, \"fe:\")) != NULL) {\n\t\t\t\tsscanf(p + 3, \"%u\", &st_serial_i->frame);\n\t\t\t}\n\t\t\tif ((p = strstr(line, \"pe:\")) != NULL) {\n\t\t\t\tsscanf(p + 3, \"%u\", &st_serial_i->parity);\n\t\t\t}\n\t\t\tif ((p = strstr(line, \"brk:\")) != NULL) {\n\t\t\t\tsscanf(p + 4, \"%u\", &st_serial_i->brk);\n\t\t\t}\n\t\t\tif ((p = strstr(line, \"oe:\")) != NULL) {\n\t\t\t\tsscanf(p + 3, \"%u\", &st_serial_i->overrun);\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn sl_read;\n}\n\n/*\n ***************************************************************************\n * Read kernel tables statistics from various system files.\n *\n * IN:\n * @st_ktables\tStructure where stats will be saved.\n *\n * OUT:\n * @st_ktables\tStructure with statistics.\n *\n * RETURNS:\n * 1 (always success).\n ***************************************************************************\n */\n__nr_t read_kernel_tables(struct stats_ktables *st_ktables)\n{\n\tFILE *fp;\n\tunsigned long long parm;\n\tint rc;\n\n\t/* Open /proc/sys/fs/dentry-state file */\n\tif ((fp = fopen(FDENTRY_STATE, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%*d %llu\",\n\t\t\t    &st_ktables->dentry_stat);\n\t\tfclose(fp);\n\t\tif (rc == 0) {\n\t\t\tst_ktables->dentry_stat = 0;\n\t\t}\n\t}\n\n\t/* Open /proc/sys/fs/file-nr file */\n\tif ((fp = fopen(FFILE_NR, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%llu %llu\",\n\t\t\t    &st_ktables->file_used, &parm);\n\t\tfclose(fp);\n\t\t/*\n\t\t * The number of used handles is the number of allocated ones\n\t\t * minus the number of free ones.\n\t\t */\n\t\tif (rc == 2) {\n\t\t\tst_ktables->file_used -= parm;\n\t\t}\n\t\telse {\n\t\t\tst_ktables->file_used = 0;\n\t\t}\n\t}\n\n\t/* Open /proc/sys/fs/inode-state file */\n\tif ((fp = fopen(FINODE_STATE, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%llu %llu\",\n\t\t\t    &st_ktables->inode_used, &parm);\n\t\tfclose(fp);\n\t\t/*\n\t\t * The number of inuse inodes is the number of allocated ones\n\t\t * minus the number of free ones.\n\t\t */\n\t\tif (rc == 2) {\n\t\t\tst_ktables->inode_used -= parm;\n\t\t}\n\t\telse {\n\t\t\tst_ktables->inode_used = 0;\n\t\t}\n\t}\n\n\t/* Open /proc/sys/kernel/pty/nr file */\n\tif ((fp = fopen(PTY_NR, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%llu\",\n\t\t\t    &st_ktables->pty_nr);\n\t\tfclose(fp);\n\t\tif (rc == 0) {\n\t\t\tst_ktables->pty_nr = 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read network interfaces statistics from /proc/net/dev.\n *\n * IN:\n * @st_net_dev\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_net_dev\tStructure with statistics.\n *\n * RETURNS:\n * Number of interfaces read, or -1 if the buffer was too small and\n * needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_net_dev(struct stats_net_dev *st_net_dev, __nr_t nr_alloc)\n{\n\tFILE *fp;\n\tstruct stats_net_dev *st_net_dev_i;\n\tchar line[256];\n\tchar iface[MAX_IFACE_LEN];\n\t__nr_t dev_read = 0;\n\tint pos;\n\n\tif ((fp = fopen(NET_DEV, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tpos = strcspn(line, \":\");\n\t\tif (pos < strlen(line)) {\n\n\t\t\tif (dev_read + 1 > nr_alloc) {\n\t\t\t\tdev_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst_net_dev_i = st_net_dev + dev_read++;\n\t\t\tstrncpy(iface, line, MINIMUM(pos, sizeof(iface) - 1));\n\t\t\tiface[MINIMUM(pos, sizeof(iface) - 1)] = '\\0';\n\t\t\tsscanf(iface, \"%15s\", st_net_dev_i->interface); /* Skip heading spaces */\n\t\t\tsscanf(line + pos + 1, \"%llu %llu %*u %*u %*u %*u %llu %llu %llu %llu \"\n\t\t\t       \"%*u %*u %*u %*u %*u %llu\",\n\t\t\t       &st_net_dev_i->rx_bytes,\n\t\t\t       &st_net_dev_i->rx_packets,\n\t\t\t       &st_net_dev_i->rx_compressed,\n\t\t\t       &st_net_dev_i->multicast,\n\t\t\t       &st_net_dev_i->tx_bytes,\n\t\t\t       &st_net_dev_i->tx_packets,\n\t\t\t       &st_net_dev_i->tx_compressed);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn dev_read;\n}\n\n/*\n ***************************************************************************\n * Read duplex and speed data for network interface cards.\n *\n * IN:\n * @st_net_dev\tStructure where stats will be saved.\n * @nbr\t\tNumber of network interfaces to read.\n *\n * OUT:\n * @st_net_dev\tStructure with statistics.\n ***************************************************************************\n */\nvoid read_if_info(struct stats_net_dev *st_net_dev, int nbr)\n{\n\tFILE *fp;\n\tstruct stats_net_dev *st_net_dev_i;\n\tchar filename[128], duplex[32];\n\tint dev, n;\n\n\tfor (dev = 0; dev < nbr; dev++) {\n\n\t\tst_net_dev_i = st_net_dev + dev;\n\n\t\t/* Read speed info */\n\t\tsprintf(filename, IF_DUPLEX, st_net_dev_i->interface);\n\n\t\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\t\t/* Cannot read NIC duplex */\n\t\t\tcontinue;\n\n\t\tn = fscanf(fp, \"%31s\", duplex);\n\n\t\tfclose(fp);\n\n\t\tif (n != 1)\n\t\t\t/* Cannot read NIC duplex */\n\t\t\tcontinue;\n\n\t\tif (!strcmp(duplex, K_DUPLEX_FULL)) {\n\t\t\tst_net_dev_i->duplex = C_DUPLEX_FULL;\n\t\t}\n\t\telse if (!strcmp(duplex, K_DUPLEX_HALF)) {\n\t\t\tst_net_dev_i->duplex = C_DUPLEX_HALF;\n\t\t}\n\t\telse\n\t\t\tcontinue;\n\n\t\t/* Read speed info */\n\t\tsprintf(filename, IF_SPEED, st_net_dev_i->interface);\n\n\t\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\t\t/* Cannot read NIC speed */\n\t\t\tcontinue;\n\n\t\tn = fscanf(fp, \"%u\", &st_net_dev_i->speed);\n\n\t\tfclose(fp);\n\n\t\tif (n != 1) {\n\t\t\tst_net_dev_i->speed = 0;\n\t\t}\n\t}\n}\n\n\n/*\n ***************************************************************************\n * Read network interfaces errors statistics from /proc/net/dev.\n *\n * IN:\n * @st_net_edev\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_net_edev\tStructure with statistics.\n *\n * RETURNS:\n * Number of interfaces read, or -1 if the buffer was too small and\n * needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_net_edev(struct stats_net_edev *st_net_edev, __nr_t nr_alloc)\n{\n\tFILE *fp;\n\tstruct stats_net_edev *st_net_edev_i;\n\tstatic char line[256];\n\tchar iface[MAX_IFACE_LEN];\n\t__nr_t dev_read = 0;\n\tint pos;\n\n\tif ((fp = fopen(NET_DEV, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tpos = strcspn(line, \":\");\n\t\tif (pos < strlen(line)) {\n\n\t\t\tif (dev_read + 1 > nr_alloc) {\n\t\t\t\tdev_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst_net_edev_i = st_net_edev + dev_read++;\n\t\t\tstrncpy(iface, line, MINIMUM(pos, sizeof(iface) - 1));\n\t\t\tiface[MINIMUM(pos, sizeof(iface) - 1)] = '\\0';\n\t\t\tsscanf(iface, \"%15s\", st_net_edev_i->interface); /* Skip heading spaces */\n\t\t\tsscanf(line + pos + 1, \"%*u %*u %llu %llu %llu %llu %*u %*u %*u %*u \"\n\t\t\t       \"%llu %llu %llu %llu %llu\",\n\t\t\t       &st_net_edev_i->rx_errors,\n\t\t\t       &st_net_edev_i->rx_dropped,\n\t\t\t       &st_net_edev_i->rx_fifo_errors,\n\t\t\t       &st_net_edev_i->rx_frame_errors,\n\t\t\t       &st_net_edev_i->tx_errors,\n\t\t\t       &st_net_edev_i->tx_dropped,\n\t\t\t       &st_net_edev_i->tx_fifo_errors,\n\t\t\t       &st_net_edev_i->collisions,\n\t\t\t       &st_net_edev_i->tx_carrier_errors);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn dev_read;\n}\n\n/*\n ***************************************************************************\n * Read NFS client statistics from /proc/net/rpc/nfs.\n *\n * IN:\n * @st_net_nfs\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_nfs\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_nfs(struct stats_net_nfs *st_net_nfs)\n{\n\tFILE *fp;\n\tchar line[256];\n\tunsigned int getattcnt = 0, accesscnt = 0, readcnt = 0, writecnt = 0;\n\n\tif ((fp = fopen(NET_RPC_NFS, \"r\")) == NULL)\n\t\treturn 0;\n\n\tmemset(st_net_nfs, 0, STATS_NET_NFS_SIZE);\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"rpc \", 4)) {\n\t\t\tsscanf(line + 4, \"%u %u\",\n\t\t\t       &st_net_nfs->nfs_rpccnt, &st_net_nfs->nfs_rpcretrans);\n\t\t}\n\t\telse if (!strncmp(line, \"proc3 \", 6)) {\n\t\t\tsscanf(line + 6, \"%*u %*u %u %*u %*u %u %*u %u %u\",\n\t\t\t       &getattcnt, &accesscnt, &readcnt, &writecnt);\n\n\t\t\tst_net_nfs->nfs_getattcnt += getattcnt;\n\t\t\tst_net_nfs->nfs_accesscnt += accesscnt;\n\t\t\tst_net_nfs->nfs_readcnt   += readcnt;\n\t\t\tst_net_nfs->nfs_writecnt  += writecnt;\n\t\t}\n\t\telse if (!strncmp(line, \"proc4 \", 6)) {\n\t\t\tsscanf(line + 6, \"%*u %*u %u %u \"\n\t\t\t       \"%*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %u %u\",\n\t\t\t       &readcnt, &writecnt, &accesscnt, &getattcnt);\n\n\t\t\tst_net_nfs->nfs_getattcnt += getattcnt;\n\t\t\tst_net_nfs->nfs_accesscnt += accesscnt;\n\t\t\tst_net_nfs->nfs_readcnt   += readcnt;\n\t\t\tst_net_nfs->nfs_writecnt  += writecnt;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read NFS server statistics from /proc/net/rpc/nfsd.\n *\n * IN:\n * @st_net_nfsd\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_nfsd\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_nfsd(struct stats_net_nfsd *st_net_nfsd)\n{\n\tFILE *fp;\n\tchar line[256];\n\tunsigned int getattcnt = 0, accesscnt = 0, readcnt = 0, writecnt = 0;\n\n\tif ((fp = fopen(NET_RPC_NFSD, \"r\")) == NULL)\n\t\treturn 0;\n\n\tmemset(st_net_nfsd, 0, STATS_NET_NFSD_SIZE);\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"rc \", 3)) {\n\t\t\tsscanf(line + 3, \"%u %u\",\n\t\t\t       &st_net_nfsd->nfsd_rchits, &st_net_nfsd->nfsd_rcmisses);\n\t\t}\n\t\telse if (!strncmp(line, \"net \", 4)) {\n\t\t\tsscanf(line + 4, \"%u %u %u\",\n\t\t\t       &st_net_nfsd->nfsd_netcnt, &st_net_nfsd->nfsd_netudpcnt,\n\t\t\t       &st_net_nfsd->nfsd_nettcpcnt);\n\t\t}\n\t\telse if (!strncmp(line, \"rpc \", 4)) {\n\t\t\tsscanf(line + 4, \"%u %u\",\n\t\t\t       &st_net_nfsd->nfsd_rpccnt, &st_net_nfsd->nfsd_rpcbad);\n\t\t}\n\t\telse if (!strncmp(line, \"proc3 \", 6)) {\n\t\t\tsscanf(line + 6, \"%*u %*u %u %*u %*u %u %*u %u %u\",\n\t\t\t       &getattcnt, &accesscnt, &readcnt, &writecnt);\n\n\t\t\tst_net_nfsd->nfsd_getattcnt += getattcnt;\n\t\t\tst_net_nfsd->nfsd_accesscnt += accesscnt;\n\t\t\tst_net_nfsd->nfsd_readcnt   += readcnt;\n\t\t\tst_net_nfsd->nfsd_writecnt  += writecnt;\n\n\t\t}\n\t\telse if (!strncmp(line, \"proc4ops \", 9)) {\n\t\t\tsscanf(line + 9, \"%*u %*u %*u %*u %u \"\n\t\t\t       \"%*u %*u %*u %*u %*u %u \"\n\t\t\t       \"%*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %u \"\n\t\t\t       \"%*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %u\",\n\t\t\t       &accesscnt, &getattcnt, &readcnt, &writecnt);\n\n\t\t\tst_net_nfsd->nfsd_getattcnt += getattcnt;\n\t\t\tst_net_nfsd->nfsd_accesscnt += accesscnt;\n\t\t\tst_net_nfsd->nfsd_readcnt   += readcnt;\n\t\t\tst_net_nfsd->nfsd_writecnt  += writecnt;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read network sockets statistics from /proc/net/sockstat.\n *\n * IN:\n * @st_net_sock\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_sock\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_sock(struct stats_net_sock *st_net_sock)\n{\n\tFILE *fp;\n\tchar line[96];\n\tchar *p;\n\n\tif ((fp = fopen(NET_SOCKSTAT, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"sockets:\", 8)) {\n\t\t\t/* Sockets */\n\t\t\tsscanf(line + 14, \"%u\", &st_net_sock->sock_inuse);\n\t\t}\n\t\telse if (!strncmp(line, \"TCP:\", 4)) {\n\t\t\t/* TCP sockets */\n\t\t\tsscanf(line + 11, \"%u\", &st_net_sock->tcp_inuse);\n\t\t\tif ((p = strstr(line, \"tw\")) != NULL) {\n\t\t\t\tsscanf(p + 2, \"%u\", &st_net_sock->tcp_tw);\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(line, \"UDP:\", 4)) {\n\t\t\t/* UDP sockets */\n\t\t\tsscanf(line + 11, \"%u\", &st_net_sock->udp_inuse);\n\t\t}\n\t\telse if (!strncmp(line, \"RAW:\", 4)) {\n\t\t\t/* RAW sockets */\n\t\t\tsscanf(line + 11, \"%u\", &st_net_sock->raw_inuse);\n\t\t}\n\t\telse if (!strncmp(line, \"FRAG:\", 5)) {\n\t\t\t/* FRAGments */\n\t\t\tsscanf(line + 12, \"%u\", &st_net_sock->frag_inuse);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read IP network traffic statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_ip\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_ip\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_ip(struct stats_net_ip *st_net_ip)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Ip:\", 3)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 3, \"%*u %*u %llu %*u %*u %llu %*u %*u \"\n\t\t\t\t       \"%llu %llu %*u %*u %*u %llu %llu %*u %llu %*u %llu\",\n\t\t\t\t       &st_net_ip->InReceives,\n\t\t\t\t       &st_net_ip->ForwDatagrams,\n\t\t\t\t       &st_net_ip->InDelivers,\n\t\t\t\t       &st_net_ip->OutRequests,\n\t\t\t\t       &st_net_ip->ReasmReqds,\n\t\t\t\t       &st_net_ip->ReasmOKs,\n\t\t\t\t       &st_net_ip->FragOKs,\n\t\t\t\t       &st_net_ip->FragCreates);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read IP network errors statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_eip\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_eip\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_eip(struct stats_net_eip *st_net_eip)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Ip:\", 3)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 3, \"%*u %*u %*u %llu %llu %*u %llu %llu \"\n\t\t\t\t       \"%*u %*u %llu %llu %*u %*u %*u %llu %*u %llu\",\n\t\t\t\t       &st_net_eip->InHdrErrors,\n\t\t\t\t       &st_net_eip->InAddrErrors,\n\t\t\t\t       &st_net_eip->InUnknownProtos,\n\t\t\t\t       &st_net_eip->InDiscards,\n\t\t\t\t       &st_net_eip->OutDiscards,\n\t\t\t\t       &st_net_eip->OutNoRoutes,\n\t\t\t\t       &st_net_eip->ReasmFails,\n\t\t\t\t       &st_net_eip->FragFails);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read ICMP network traffic statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_icmp\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_icmp\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_icmp(struct stats_net_icmp *st_net_icmp)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tstatic char format[256] = \"\";\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Icmp:\", 5)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 5, format,\n\t\t\t\t       &st_net_icmp->InMsgs,\n\t\t\t\t       &st_net_icmp->InEchos,\n\t\t\t\t       &st_net_icmp->InEchoReps,\n\t\t\t\t       &st_net_icmp->InTimestamps,\n\t\t\t\t       &st_net_icmp->InTimestampReps,\n\t\t\t\t       &st_net_icmp->InAddrMasks,\n\t\t\t\t       &st_net_icmp->InAddrMaskReps,\n\t\t\t\t       &st_net_icmp->OutMsgs,\n\t\t\t\t       &st_net_icmp->OutEchos,\n\t\t\t\t       &st_net_icmp->OutEchoReps,\n\t\t\t\t       &st_net_icmp->OutTimestamps,\n\t\t\t\t       &st_net_icmp->OutTimestampReps,\n\t\t\t\t       &st_net_icmp->OutAddrMasks,\n\t\t\t\t       &st_net_icmp->OutAddrMaskReps);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!strlen(format)) {\n\t\t\t\t\tif (strstr(line, \"InCsumErrors\")) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * New format: InCsumErrors field exists at position #3.\n\t\t\t\t\t\t * Capture: 1,9,10,11,12,13,14,15,22,23,24,25,26,27.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstrcpy(format, \"%lu %*u %*u %*u %*u %*u %*u %*u \"\n\t\t\t\t\t\t\t       \"%lu %lu %lu %lu %lu %lu %lu %*u %*u %*u %*u \"\n\t\t\t\t\t\t\t       \"%*u %*u %lu %lu %lu %lu %lu %lu\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Old format: InCsumErrors field doesn't exist.\n\t\t\t\t\t\t * Capture: 1,8,9,10,11,12,13,14,21,22,23,24,25,26.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstrcpy(format, \"%lu %*u %*u %*u %*u %*u %*u \"\n\t\t\t\t\t\t\t       \"%lu %lu %lu %lu %lu %lu %lu %*u %*u %*u %*u \"\n\t\t\t\t\t\t\t       \"%*u %*u %lu %lu %lu %lu %lu %lu\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read ICMP network errors statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_eicmp\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_eicmp\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_eicmp(struct stats_net_eicmp *st_net_eicmp)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tstatic char format[256] = \"\";\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Icmp:\", 5)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 5, format,\n\t\t\t\t       &st_net_eicmp->InErrors,\n\t\t\t\t       &st_net_eicmp->InDestUnreachs,\n\t\t\t\t       &st_net_eicmp->InTimeExcds,\n\t\t\t\t       &st_net_eicmp->InParmProbs,\n\t\t\t\t       &st_net_eicmp->InSrcQuenchs,\n\t\t\t\t       &st_net_eicmp->InRedirects,\n\t\t\t\t       &st_net_eicmp->OutErrors,\n\t\t\t\t       &st_net_eicmp->OutDestUnreachs,\n\t\t\t\t       &st_net_eicmp->OutTimeExcds,\n\t\t\t\t       &st_net_eicmp->OutParmProbs,\n\t\t\t\t       &st_net_eicmp->OutSrcQuenchs,\n\t\t\t\t       &st_net_eicmp->OutRedirects);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!strlen(format)) {\n\t\t\t\t\tif (strstr(line, \"InCsumErrors\")) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * New format: InCsumErrors field exists at position #3.\n\t\t\t\t\t\t * Capture: 2,4,5,6,7,8,16,17,18,19,20,21\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstrcpy(format, \"%*u %lu %*u %lu %lu %lu %lu %lu %*u %*u \"\n\t\t\t\t\t\t\t       \"%*u %*u %*u %*u %*u %lu %lu %lu %lu %lu %lu\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Old format: InCsumErrors field doesn't exist.\n\t\t\t\t\t\t * Capture: 2,3,4,5,6,7,15,16,17,18,19,20\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstrcpy(format, \"%*u %lu %lu %lu %lu %lu %lu %*u %*u \"\n\t\t\t\t\t\t\t       \"%*u %*u %*u %*u %*u %lu %lu %lu %lu %lu %lu\");\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read TCP network traffic statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_tcp\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_tcp\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_tcp(struct stats_net_tcp *st_net_tcp)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Tcp:\", 4)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 4, \"%*u %*u %*u %*d %lu %lu \"\n\t\t\t\t       \"%*u %*u %*u %lu %lu\",\n\t\t\t\t       &st_net_tcp->ActiveOpens,\n\t\t\t\t       &st_net_tcp->PassiveOpens,\n\t\t\t\t       &st_net_tcp->InSegs,\n\t\t\t\t       &st_net_tcp->OutSegs);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read TCP network errors statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_etcp\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_etcp\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_etcp(struct stats_net_etcp *st_net_etcp)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Tcp:\", 4)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 4, \"%*u %*u %*u %*d %*u %*u \"\n\t\t\t\t       \"%lu %lu %*u %*u %*u %lu %lu %lu\",\n\t\t\t\t       &st_net_etcp->AttemptFails,\n\t\t\t\t       &st_net_etcp->EstabResets,\n\t\t\t\t       &st_net_etcp->RetransSegs,\n\t\t\t\t       &st_net_etcp->InErrs,\n\t\t\t\t       &st_net_etcp->OutRsts);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read UDP network traffic statistics from /proc/net/snmp.\n *\n * IN:\n * @st_net_udp\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_udp\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_udp(struct stats_net_udp *st_net_udp)\n{\n\tFILE *fp;\n\tchar line[1024];\n\tint sw = FALSE;\n\n\tif ((fp = fopen(NET_SNMP, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Udp:\", 4)) {\n\t\t\tif (sw) {\n\t\t\t\tsscanf(line + 4, \"%lu %lu %lu %lu\",\n\t\t\t\t       &st_net_udp->InDatagrams,\n\t\t\t\t       &st_net_udp->NoPorts,\n\t\t\t\t       &st_net_udp->InErrors,\n\t\t\t\t       &st_net_udp->OutDatagrams);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsw = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read IPv6 network sockets statistics from /proc/net/sockstat6.\n *\n * IN:\n * @st_net_sock6\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_sock6\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_sock6(struct stats_net_sock6 *st_net_sock6)\n{\n\tFILE *fp;\n\tchar line[96];\n\n\tif ((fp = fopen(NET_SOCKSTAT6, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"TCP6:\", 5)) {\n\t\t\t/* TCPv6 sockets */\n\t\t\tsscanf(line + 12, \"%u\", &st_net_sock6->tcp6_inuse);\n\t\t}\n\t\telse if (!strncmp(line, \"UDP6:\", 5)) {\n\t\t\t/* UDPv6 sockets */\n\t\t\tsscanf(line + 12, \"%u\", &st_net_sock6->udp6_inuse);\n\t\t}\n\t\telse if (!strncmp(line, \"RAW6:\", 5)) {\n\t\t\t/* IPv6 RAW sockets */\n\t\t\tsscanf(line + 12, \"%u\", &st_net_sock6->raw6_inuse);\n\t\t}\n\t\telse if (!strncmp(line, \"FRAG6:\", 6)) {\n\t\t\t/* IPv6 FRAGments */\n\t\t\tsscanf(line + 13, \"%u\", &st_net_sock6->frag6_inuse);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read IPv6 network traffic statistics from /proc/net/snmp6.\n *\n * IN:\n * @st_net_ip6\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_ip6\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_ip6(struct stats_net_ip6 *st_net_ip6)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(NET_SNMP6, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Ip6InReceives \", 14)) {\n\t\t\tsscanf(line + 14, \"%llu\", &st_net_ip6->InReceives6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6OutForwDatagrams \", 20)) {\n\t\t\tsscanf(line + 20, \"%llu\", &st_net_ip6->OutForwDatagrams6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InDelivers \", 14)) {\n\t\t\tsscanf(line + 14, \"%llu\", &st_net_ip6->InDelivers6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6OutRequests \", 15)) {\n\t\t\tsscanf(line + 15, \"%llu\", &st_net_ip6->OutRequests6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6ReasmReqds \", 14)) {\n\t\t\tsscanf(line + 14, \"%llu\", &st_net_ip6->ReasmReqds6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6ReasmOKs \", 12)) {\n\t\t\tsscanf(line + 12, \"%llu\", &st_net_ip6->ReasmOKs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InMcastPkts \", 15)) {\n\t\t\tsscanf(line + 15, \"%llu\", &st_net_ip6->InMcastPkts6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6OutMcastPkts \", 16)) {\n\t\t\tsscanf(line + 16, \"%llu\", &st_net_ip6->OutMcastPkts6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6FragOKs \", 11)) {\n\t\t\tsscanf(line + 11, \"%llu\", &st_net_ip6->FragOKs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6FragCreates \", 15)) {\n\t\t\tsscanf(line + 15, \"%llu\", &st_net_ip6->FragCreates6);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read IPv6 network errors statistics from /proc/net/snmp6.\n *\n * IN:\n * @st_net_eip6\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_eip6\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_eip6(struct stats_net_eip6 *st_net_eip6)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(NET_SNMP6, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Ip6InHdrErrors \", 15)) {\n\t\t\tsscanf(line + 15, \"%llu\", &st_net_eip6->InHdrErrors6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InAddrErrors \", 16)) {\n\t\t\tsscanf(line + 16, \"%llu\", &st_net_eip6->InAddrErrors6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InUnknownProtos \", 19)) {\n\t\t\tsscanf(line + 19, \"%llu\", &st_net_eip6->InUnknownProtos6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InTooBigErrors \", 18)) {\n\t\t\tsscanf(line + 18, \"%llu\", &st_net_eip6->InTooBigErrors6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InDiscards \", 14)) {\n\t\t\tsscanf(line + 14, \"%llu\", &st_net_eip6->InDiscards6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6OutDiscards \", 15)) {\n\t\t\tsscanf(line + 15, \"%llu\", &st_net_eip6->OutDiscards6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InNoRoutes \", 14)) {\n\t\t\tsscanf(line + 14, \"%llu\", &st_net_eip6->InNoRoutes6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6OutNoRoutes \", 15)) {\n\t\t\tsscanf(line + 15, \"%llu\", &st_net_eip6->OutNoRoutes6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6ReasmFails \", 14)) {\n\t\t\tsscanf(line + 14, \"%llu\", &st_net_eip6->ReasmFails6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6FragFails \", 13)) {\n\t\t\tsscanf(line + 13, \"%llu\", &st_net_eip6->FragFails6);\n\t\t}\n\t\telse if (!strncmp(line, \"Ip6InTruncatedPkts \", 19)) {\n\t\t\tsscanf(line + 19, \"%llu\", &st_net_eip6->InTruncatedPkts6);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read ICMPv6 network traffic statistics from /proc/net/snmp6.\n *\n * IN:\n * @st_net_icmp6\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_icmp6\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_icmp6(struct stats_net_icmp6 *st_net_icmp6)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(NET_SNMP6, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Icmp6InMsgs \", 12)) {\n\t\t\tsscanf(line + 12, \"%lu\", &st_net_icmp6->InMsgs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutMsgs \", 13)) {\n\t\t\tsscanf(line + 13, \"%lu\", &st_net_icmp6->OutMsgs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InEchos \", 13)) {\n\t\t\tsscanf(line + 13, \"%lu\", &st_net_icmp6->InEchos6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InEchoReplies \", 19)) {\n\t\t\tsscanf(line + 19, \"%lu\", &st_net_icmp6->InEchoReplies6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutEchoReplies \", 20)) {\n\t\t\tsscanf(line + 20, \"%lu\", &st_net_icmp6->OutEchoReplies6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InGroupMembQueries \", 24)) {\n\t\t\tsscanf(line + 24, \"%lu\", &st_net_icmp6->InGroupMembQueries6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InGroupMembResponses \", 26)) {\n\t\t\tsscanf(line + 26, \"%lu\", &st_net_icmp6->InGroupMembResponses6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutGroupMembResponses \", 27)) {\n\t\t\tsscanf(line + 27, \"%lu\", &st_net_icmp6->OutGroupMembResponses6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InGroupMembReductions \", 27)) {\n\t\t\tsscanf(line + 27, \"%lu\", &st_net_icmp6->InGroupMembReductions6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutGroupMembReductions \", 28)) {\n\t\t\tsscanf(line + 28, \"%lu\", &st_net_icmp6->OutGroupMembReductions6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InRouterSolicits \", 22)) {\n\t\t\tsscanf(line + 22, \"%lu\", &st_net_icmp6->InRouterSolicits6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutRouterSolicits \", 23)) {\n\t\t\tsscanf(line + 23, \"%lu\", &st_net_icmp6->OutRouterSolicits6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InRouterAdvertisements \", 28)) {\n\t\t\tsscanf(line + 28, \"%lu\", &st_net_icmp6->InRouterAdvertisements6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InNeighborSolicits \", 24)) {\n\t\t\tsscanf(line + 24, \"%lu\", &st_net_icmp6->InNeighborSolicits6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutNeighborSolicits \", 25)) {\n\t\t\tsscanf(line + 25, \"%lu\", &st_net_icmp6->OutNeighborSolicits6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InNeighborAdvertisements \", 30)) {\n\t\t\tsscanf(line + 30, \"%lu\", &st_net_icmp6->InNeighborAdvertisements6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutNeighborAdvertisements \", 31)) {\n\t\t\tsscanf(line + 31, \"%lu\", &st_net_icmp6->OutNeighborAdvertisements6);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read ICMPv6 network errors statistics from /proc/net/snmp6.\n *\n * IN:\n * @st_net_eicmp6\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_eicmp6\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_eicmp6(struct stats_net_eicmp6 *st_net_eicmp6)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(NET_SNMP6, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Icmp6InErrors \", 14)) {\n\t\t\tsscanf(line + 14, \"%lu\", &st_net_eicmp6->InErrors6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InDestUnreachs \", 20)) {\n\t\t\tsscanf(line + 20, \"%lu\", &st_net_eicmp6->InDestUnreachs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutDestUnreachs \", 21)) {\n\t\t\tsscanf(line + 21, \"%lu\", &st_net_eicmp6->OutDestUnreachs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InTimeExcds \", 17)) {\n\t\t\tsscanf(line + 17, \"%lu\", &st_net_eicmp6->InTimeExcds6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutTimeExcds \", 18)) {\n\t\t\tsscanf(line + 18, \"%lu\", &st_net_eicmp6->OutTimeExcds6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InParmProblems \", 20)) {\n\t\t\tsscanf(line + 20, \"%lu\", &st_net_eicmp6->InParmProblems6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutParmProblems \", 21)) {\n\t\t\tsscanf(line + 21, \"%lu\", &st_net_eicmp6->OutParmProblems6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InRedirects \", 17)) {\n\t\t\tsscanf(line + 17, \"%lu\", &st_net_eicmp6->InRedirects6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutRedirects \", 18)) {\n\t\t\tsscanf(line + 18, \"%lu\", &st_net_eicmp6->OutRedirects6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6InPktTooBigs \", 18)) {\n\t\t\tsscanf(line + 18, \"%lu\", &st_net_eicmp6->InPktTooBigs6);\n\t\t}\n\t\telse if (!strncmp(line, \"Icmp6OutPktTooBigs \", 19)) {\n\t\t\tsscanf(line + 19, \"%lu\", &st_net_eicmp6->OutPktTooBigs6);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read UDPv6 network traffic statistics from /proc/net/snmp6.\n *\n * IN:\n * @st_net_udp6\tStructure where stats will be saved.\n *\n * OUT:\n * @st_net_udp6\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_net_udp6(struct stats_net_udp6 *st_net_udp6)\n{\n\tFILE *fp;\n\tchar line[128];\n\n\tif ((fp = fopen(NET_SNMP6, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"Udp6InDatagrams \", 16)) {\n\t\t\tsscanf(line + 16, \"%lu\", &st_net_udp6->InDatagrams6);\n\t\t}\n\t\telse if (!strncmp(line, \"Udp6OutDatagrams \", 17)) {\n\t\t\tsscanf(line + 17, \"%lu\", &st_net_udp6->OutDatagrams6);\n\t\t}\n\t\telse if (!strncmp(line, \"Udp6NoPorts \", 12)) {\n\t\t\tsscanf(line + 12, \"%lu\", &st_net_udp6->NoPorts6);\n\t\t}\n\t\telse if (!strncmp(line, \"Udp6InErrors \", 13)) {\n\t\t\tsscanf(line + 13, \"%lu\", &st_net_udp6->InErrors6);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read CPU frequency statistics.\n *\n * IN:\n * @st_pwr_cpufreq\tStructure where stats will be saved.\n * @nr_alloc\t\tTotal number of structures allocated. Value is >= 1.\n *\n * OUT:\n * @st_pwr_cpufreq\tStructure with statistics.\n *\n * RETURNS:\n * Highest CPU number for which statistics have been read.\n * 1 means CPU \"all\", 2 means CPU 0, 3 means CPU 1, etc.\n * Or -1 if the buffer was too small and needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_cpuinfo(struct stats_pwr_cpufreq *st_pwr_cpufreq, __nr_t nr_alloc)\n{\n\tFILE *fp;\n\tstruct stats_pwr_cpufreq *st_pwr_cpufreq_i;\n\tchar line[1024];\n\tint nr = 0;\n\t__nr_t cpu_read = 1;\t/* For CPU \"all\" */\n\tunsigned int proc_nr = 0, ifreq, dfreq;\n\n\tif ((fp = fopen(CPUINFO, \"r\")) == NULL)\n\t\treturn 0;\n\n\tst_pwr_cpufreq->cpufreq = 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"processor\\t\", 10)) {\n\t\t\tsscanf(strchr(line, ':') + 1, \"%u\", &proc_nr);\n\n\t\t\tif (proc_nr + 2 > nr_alloc) {\n\t\t\t\tcpu_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Entry in /proc/cpuinfo is different between Intel and Power architectures */\n\t\telse if (!strncmp(line, \"cpu MHz\\t\", 8) ||\n\t\t\t !strncmp(line, \"clock\\t\", 6)) {\n\t\t\tsscanf(strchr(line, ':') + 1, \"%u.%u\", &ifreq, &dfreq);\n\n\t\t\t/* Save current CPU frequency */\n\t\t\tst_pwr_cpufreq_i = st_pwr_cpufreq + proc_nr + 1;\n\t\t\tst_pwr_cpufreq_i->cpufreq = ifreq * 100 + dfreq / 10;\n\n\t\t\t/* Also save it to compute an average CPU frequency */\n\t\t\tst_pwr_cpufreq->cpufreq += st_pwr_cpufreq_i->cpufreq;\n\t\t\tnr++;\n\n\t\t\tif (proc_nr + 2 > cpu_read) {\n\t\t\t\tcpu_read = proc_nr + 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tif (nr) {\n\t\t/* Compute average CPU frequency for this machine */\n\t\tst_pwr_cpufreq->cpufreq /= nr;\n\t}\n\treturn cpu_read;\n}\n\n/*\n ***************************************************************************\n * Read hugepages statistics from /proc/meminfo.\n *\n * IN:\n * @st_huge\tStructure where stats will be saved.\n *\n * OUT:\n * @st_huge\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_meminfo_huge(struct stats_huge *st_huge)\n{\n\tFILE *fp;\n\tchar line[128];\n\tunsigned long szhkb = 0;\n\n\tif ((fp = fopen(MEMINFO, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"HugePages_Total:\", 16)) {\n\t\t\t/* Read the total number of huge pages */\n\t\t\tsscanf(line + 16, \"%llu\", &st_huge->tlhkb);\n\t\t}\n\t\telse if (!strncmp(line, \"HugePages_Free:\", 15)) {\n\t\t\t/* Read the number of free huge pages */\n\t\t\tsscanf(line + 15, \"%llu\", &st_huge->frhkb);\n\t\t}\n\t\telse if (!strncmp(line, \"HugePages_Rsvd:\", 15)) {\n\t\t\t/* Read the number of reserved huge pages */\n\t\t\tsscanf(line + 15, \"%llu\", &st_huge->rsvdhkb);\n\t\t}\n\t\telse if (!strncmp(line, \"HugePages_Surp:\", 15)) {\n\t\t\t/* Read the number of surplus huge pages */\n\t\t\tsscanf(line + 15, \"%llu\", &st_huge->surphkb);\n\t\t}\n\t\telse if (!strncmp(line, \"Hugepagesize:\", 13)) {\n\t\t\t/* Read the default size of a huge page in kB */\n\t\t\tsscanf(line + 13, \"%lu\", &szhkb);\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\t/* We want huge pages stats in kB and not expressed in a number of pages */\n\tst_huge->tlhkb *= szhkb;\n\tst_huge->frhkb *= szhkb;\n\tst_huge->rsvdhkb *= szhkb;\n\tst_huge->surphkb *= szhkb;\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read CPU average frequencies statistics.\n *\n * IN:\n * @st_pwr_wghfreq\tStructure where stats will be saved.\n * @cpu_nr\t\tCPU number for which time_in_state date will be read.\n * @nbr\t\t\tTotal number of states (frequencies).\n *\n * OUT:\n * @st_pwr_wghfreq\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\nint read_time_in_state(struct stats_pwr_wghfreq *st_pwr_wghfreq, int cpu_nr, int nbr)\n{\n\tFILE *fp;\n\tstruct stats_pwr_wghfreq *st_pwr_wghfreq_j;\n\tchar filename[MAX_PF_NAME];\n\tchar line[128];\n\tint j = 0;\n\tunsigned long freq;\n\tunsigned long long time_in_state;\n\n\tsnprintf(filename, MAX_PF_NAME, \"%s/cpu%d/%s\",\n\t\t SYSFS_DEVCPU, cpu_nr, SYSFS_TIME_IN_STATE);\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tsscanf(line, \"%lu %llu\", &freq, &time_in_state);\n\n\t\tif (j < nbr) {\n\t\t\t/* Save current frequency and time */\n\t\t\tst_pwr_wghfreq_j = st_pwr_wghfreq + j;\n\t\t\tst_pwr_wghfreq_j->freq = freq;\n\t\t\tst_pwr_wghfreq_j->time_in_state = time_in_state;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read weighted CPU frequency statistics.\n *\n * IN:\n * @st_pwr_wghfreq\tStructure where stats will be saved.\n * @nr_alloc\t\tTotal number of structures allocated. Value is >= 0.\n * @nr2\t\t\tNumber of sub-items allocated per structure.\n *\n * OUT:\n * @st_pwr_wghfreq\tStructure with statistics.\n *\n * RETURNS:\n * Number of CPU for which statistics have been read.\n * 1 means CPU \"all\", 2 means CPU \"all\" and 0, etc.\n * Or -1 if the buffer was to small and needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_cpu_wghfreq(struct stats_pwr_wghfreq *st_pwr_wghfreq, __nr_t nr_alloc,\n\t\t\t__nr_t nr2)\n{\n\t__nr_t cpu_read = 0;\n\tint j;\n\tstruct stats_pwr_wghfreq *st_pwr_wghfreq_i, *st_pwr_wghfreq_j, *st_pwr_wghfreq_all_j;\n\n\tdo {\n\t\tif (cpu_read + 2 > nr_alloc)\n\t\t\treturn -1;\n\n\t\t/* Read current CPU time-in-state data */\n\t\tst_pwr_wghfreq_i = st_pwr_wghfreq + (cpu_read + 1) * nr2;\n\t\tif (!read_time_in_state(st_pwr_wghfreq_i, cpu_read, nr2))\n\t\t\tbreak;\n\n\t\t/* Also save data for CPU 'all' */\n\t\tfor (j = 0; j < nr2; j++) {\n\t\t\tst_pwr_wghfreq_j     = st_pwr_wghfreq_i + j;\t/* CPU #cpu, state #j */\n\t\t\tst_pwr_wghfreq_all_j = st_pwr_wghfreq   + j;\t/* CPU #all, state #j */\n\t\t\tif (!cpu_read) {\n\t\t\t\t/* Assume that possible frequencies are the same for all CPUs */\n\t\t\t\tst_pwr_wghfreq_all_j->freq = st_pwr_wghfreq_j->freq;\n\t\t\t}\n\t\t\tst_pwr_wghfreq_all_j->time_in_state += st_pwr_wghfreq_j->time_in_state;\n\t\t}\n\t\tcpu_read++;\n\t}\n\twhile (1);\n\n\tif (cpu_read > 0) {\n\t\tfor (j = 0; j < nr2; j++) {\n\t\t\tst_pwr_wghfreq_all_j = st_pwr_wghfreq + j;\t/* CPU #all, state #j */\n\t\t\tst_pwr_wghfreq_all_j->time_in_state /= cpu_read;\n\t\t}\n\n\t\treturn cpu_read + 1; /* For CPU \"all\" */\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read current USB device data.\n *\n * IN:\n * @st_pwr_usb\t\tStructure where stats will be saved.\n * @usb_device\t\tFile name for current USB device.\n *\n * OUT:\n * @st_pwr_usb\t\tStructure with statistics.\n ***************************************************************************\n */\nvoid read_usb_stats(struct stats_pwr_usb *st_pwr_usb, char *usb_device)\n{\n\tint l, rc;\n\tFILE *fp;\n\tchar * rs;\n\tchar filename[MAX_PF_NAME];\n\n\t/* Get USB device bus number */\n\tsscanf(usb_device, \"%u\", &st_pwr_usb->bus_nr);\n\n\t/* Read USB device vendor ID */\n\tsnprintf(filename, MAX_PF_NAME, \"%s/%s/%s\",\n\t\t SYSFS_USBDEV, usb_device, SYSFS_IDVENDOR);\n\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%x\",\n\t\t\t    &st_pwr_usb->vendor_id);\n\t\tfclose(fp);\n\t\tif (rc == 0) {\n\t\t\tst_pwr_usb->vendor_id = 0;\n\t\t}\n\t}\n\n\t/* Read USB device product ID */\n\tsnprintf(filename, MAX_PF_NAME, \"%s/%s/%s\",\n\t\t SYSFS_USBDEV, usb_device, SYSFS_IDPRODUCT);\n\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%x\",\n\t\t\t    &st_pwr_usb->product_id);\n\t\tfclose(fp);\n\t\tif (rc == 0) {\n\t\t\tst_pwr_usb->product_id = 0;\n\t\t}\n\t}\n\n\t/* Read USB device max power consumption */\n\tsnprintf(filename, MAX_PF_NAME, \"%s/%s/%s\",\n\t\t SYSFS_USBDEV, usb_device, SYSFS_BMAXPOWER);\n\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\trc = fscanf(fp, \"%u\",\n\t\t\t    &st_pwr_usb->bmaxpower);\n\t\tfclose(fp);\n\t\tif (rc == 0) {\n\t\t\tst_pwr_usb->bmaxpower = 0;\n\t\t}\n\t}\n\n\t/* Read USB device manufacturer */\n\tsnprintf(filename, MAX_PF_NAME, \"%s/%s/%s\",\n\t\t SYSFS_USBDEV, usb_device, SYSFS_MANUFACTURER);\n\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\trs = fgets(st_pwr_usb->manufacturer,\n\t\t\t   MAX_MANUF_LEN - 1, fp);\n\t\tfclose(fp);\n\t\tif ((rs != NULL) &&\n\t\t    (l = strlen(st_pwr_usb->manufacturer)) > 0) {\n\t\t\t/* Remove trailing CR */\n\t\t\tst_pwr_usb->manufacturer[l - 1] = '\\0';\n\t\t}\n\t}\n\n\t/* Read USB device product */\n\tsnprintf(filename, MAX_PF_NAME, \"%s/%s/%s\",\n\t\t SYSFS_USBDEV, usb_device, SYSFS_PRODUCT);\n\tif ((fp = fopen(filename, \"r\")) != NULL) {\n\t\trs = fgets(st_pwr_usb->product,\n\t\t\t   MAX_PROD_LEN - 1, fp);\n\t\tfclose(fp);\n\t\tif ((rs != NULL) &&\n\t\t    (l = strlen(st_pwr_usb->product)) > 0) {\n\t\t\t/* Remove trailing CR */\n\t\t\tst_pwr_usb->product[l - 1] = '\\0';\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Read USB devices statistics.\n *\n * IN:\n * @st_pwr_usb\t\tStructure where stats will be saved.\n * @nr_alloc\t\tTotal number of structures allocated. Value is >= 0.\n *\n * OUT:\n * @st_pwr_usb\t\tStructure with statistics.\n *\n * RETURNS:\n * Number of USB devices read, or -1 if the buffer was too small and\n * needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_bus_usb_dev(struct stats_pwr_usb *st_pwr_usb, __nr_t nr_alloc)\n{\n\tDIR *dir;\n\tstruct dirent *drd;\n\tstruct stats_pwr_usb *st_pwr_usb_i;\n\t__nr_t usb_read = 0;\n\n\t/* Open relevant /sys directory */\n\tif ((dir = __opendir(SYSFS_USBDEV)) == NULL)\n\t\treturn 0;\n\n\t/* Get current file entry */\n\twhile ((drd = __readdir(dir)) != NULL) {\n\n\t\tif (isdigit(drd->d_name[0]) && !strchr(drd->d_name, ':')) {\n\n\t\t\tif (usb_read + 1 > nr_alloc) {\n\t\t\t\tusb_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Read current USB device data */\n\t\t\tst_pwr_usb_i = st_pwr_usb + usb_read++;\n\t\t\tread_usb_stats(st_pwr_usb_i, drd->d_name);\n\t\t}\n\t}\n\n\t/* Close directory */\n\t__closedir(dir);\n\treturn usb_read;\n}\n\n/*\n ***************************************************************************\n * Read filesystems statistics.\n *\n * IN:\n * @st_filesystem\tStructure where stats will be saved.\n * @nr_alloc\t\tTotal number of structures allocated. Value is >= 0.\n *\n * OUT:\n * @st_filesystem\tStructure with statistics.\n *\n * RETURNS:\n * Number of filesystems read, or -1 if the buffer was too small and\n * needs to be reallocated.\n ***************************************************************************\n */\n__nr_t read_filesystem(struct stats_filesystem *st_filesystem, __nr_t nr_alloc)\n{\n\tFILE *fp;\n\tchar line[512], fs_name[MAX_FS_LEN], mountp[256], type[128];\n\tint skip, skip_next = 0, fs;\n\tchar *pos = 0, *pos2 = 0;\n\t__nr_t fs_read = 0;\n\tstruct stats_filesystem *st_filesystem_i;\n\tstruct statvfs buf;\n\n\tif ((fp = fopen(MTAB, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\t/*\n\t\t * Ignore line if the preceding line did not contain '\\n'.\n\t\t * (Some very long lines may be found for instance when\n\t\t * overlay2 filesystem with docker is used).\n\t\t */\n\t\tskip = skip_next;\n\t\tskip_next = (strchr(line, '\\n') == NULL);\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tif (line[0] == '/') {\n\t\t\t/* Find field separator position */\n\t\t\tpos = strchr(line, ' ');\n\t\t\tif (pos == NULL)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Find second field separator position,\n\t\t\t * read filesystem type,\n\t\t\t * if filesystem type is autofs, skip it\n\t\t\t*/\n\t\t\tpos2 = strchr(pos + 1, ' ');\n\t\t\tif (pos2 == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tsscanf(pos2 + 1, \"%127s\", type);\n\t\t\tif (strcmp(type, \"autofs\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* Read current filesystem name */\n\t\t\tsscanf(line, \"%127s\", fs_name);\n\t\t\t/*\n\t\t\t * And now read the corresponding mount point.\n\t\t\t * Read fs name and mount point in two distinct operations,\n\t\t\t * using '@pos + 1' position value for the mount point.\n\t\t\t * Indeed, if fs name length is greater than 127 chars,\n\t\t\t * previous scanf() would read only the first 127 chars, and\n\t\t\t * mount point name would be read using the remaining chars\n\t\t\t * from the fs name. This would result in a bogus name\n\t\t\t * and following statvfs() function would always fail.\n\t\t\t */\n\t\t\tsscanf(pos + 1, \"%255s\", mountp);\n\n\t\t\t/* Replace octal codes */\n\t\t\toct2chr(mountp);\n\n\t\t\t/*\n\t\t\t * It's important to have read the whole mount point name\n\t\t\t * for statvfs() to work properly (see above).\n\t\t\t */\n\t\t\tif ((__statvfs(mountp, &buf) < 0) || (!buf.f_blocks))\n\t\t\t\tcontinue;\n\n\t\t\t/* Check if it's a duplicate entry */\n\t\t\tfs = fs_read - 1;\n\t\t\twhile (fs >= 0) {\n\t\t\t\tst_filesystem_i = st_filesystem + fs;\n\t\t\t\tif (!strcmp(st_filesystem_i->fs_name, fs_name))\n\t\t\t\t\tbreak;\n\t\t\t\tfs--;\n\t\t\t}\n\t\t\tif (fs >= 0)\n\t\t\t\t/* Duplicate entry found! Ignore current entry */\n\t\t\t\tcontinue;\n\n\t\t\tif (fs_read + 1 > nr_alloc) {\n\t\t\t\tfs_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst_filesystem_i = st_filesystem + fs_read++;\n\t\t\tst_filesystem_i->f_blocks = (unsigned long long) buf.f_blocks * (unsigned long long) buf.f_frsize;\n\t\t\tst_filesystem_i->f_bfree  = (unsigned long long) buf.f_bfree * (unsigned long long) buf.f_frsize;\n\t\t\tst_filesystem_i->f_bavail = (unsigned long long) buf.f_bavail * (unsigned long long) buf.f_frsize;\n\t\t\tst_filesystem_i->f_files  = (unsigned long long) buf.f_files;\n\t\t\tst_filesystem_i->f_ffree  = (unsigned long long) buf.f_ffree;\n\t\t\tstrncpy(st_filesystem_i->fs_name, fs_name, sizeof(st_filesystem_i->fs_name));\n\t\t\tst_filesystem_i->fs_name[sizeof(st_filesystem_i->fs_name) - 1] = '\\0';\n\t\t\tstrncpy(st_filesystem_i->mountp, mountp, sizeof(st_filesystem_i->mountp));\n\t\t\tst_filesystem_i->mountp[sizeof(st_filesystem_i->mountp) - 1] = '\\0';\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn fs_read;\n}\n\n/*\n ***************************************************************************\n * Read Fibre Channel HBA statistics.\n *\n * IN:\n * @st_fc\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 0.\n *\n * OUT:\n * @st_fc\tStructure with statistics.\n *\n * RETURNS:\n * Number of FC hosts read, or -1 if the buffer was too small and needs to\n * be reallocated.\n ***************************************************************************\n */\n__nr_t read_fchost(struct stats_fchost *st_fc, __nr_t nr_alloc)\n{\n\tDIR *dir;\n\tFILE *fp;\n\tstruct dirent *drd;\n\tstruct stats_fchost *st_fc_i;\n\t__nr_t fch_read = 0;\n\tchar fcstat_filename[MAX_PF_NAME];\n\tchar line[256];\n\tunsigned long rx_frames, tx_frames, rx_words, tx_words;\n\n\t/* Each host, if present, will have its own hostX entry within SYSFS_FCHOST */\n\tif ((dir = __opendir(SYSFS_FCHOST)) == NULL)\n\t\treturn 0; /* No FC hosts */\n\n\t/*\n\t * Read each of the counters via sysfs, where they are\n\t * returned as hex values (e.g. 0x72400).\n\t */\n\twhile ((drd = __readdir(dir)) != NULL) {\n\t\trx_frames = tx_frames = rx_words = tx_words = 0;\n\n\t\tif (!strncmp(drd->d_name, \"host\", 4)) {\n\n\t\t\tif (fch_read + 1 > nr_alloc) {\n\t\t\t\tfch_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsnprintf(fcstat_filename, MAX_PF_NAME, FC_RX_FRAMES,\n\t\t\t\t SYSFS_FCHOST, drd->d_name);\n\t\t\tif ((fp = fopen(fcstat_filename, \"r\"))) {\n\t\t\t\tif (fgets(line, sizeof(line), fp)) {\n\t\t\t\t\tsscanf(line, \"%lx\", &rx_frames);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\n\t\t\tsnprintf(fcstat_filename, MAX_PF_NAME, FC_TX_FRAMES,\n\t\t\t\t SYSFS_FCHOST, drd->d_name);\n\t\t\tif ((fp = fopen(fcstat_filename, \"r\"))) {\n\t\t\t\tif (fgets(line, sizeof(line), fp)) {\n\t\t\t\t\tsscanf(line, \"%lx\", &tx_frames);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\n\t\t\tsnprintf(fcstat_filename, MAX_PF_NAME, FC_RX_WORDS,\n\t\t\t\t SYSFS_FCHOST, drd->d_name);\n\t\t\tif ((fp = fopen(fcstat_filename, \"r\"))) {\n\t\t\t\tif (fgets(line, sizeof(line), fp)) {\n\t\t\t\t\tsscanf(line, \"%lx\", &rx_words);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\n\t\t\tsnprintf(fcstat_filename, MAX_PF_NAME, FC_TX_WORDS,\n\t\t\t\t SYSFS_FCHOST, drd->d_name);\n\t\t\tif ((fp = fopen(fcstat_filename, \"r\"))) {\n\t\t\t\tif (fgets(line, sizeof(line), fp)) {\n\t\t\t\t\tsscanf(line, \"%lx\", &tx_words);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\n\t\t\tst_fc_i = st_fc + fch_read++;\n\t\t\tst_fc_i->f_rxframes = rx_frames;\n\t\t\tst_fc_i->f_txframes = tx_frames;\n\t\t\tst_fc_i->f_rxwords  = rx_words;\n\t\t\tst_fc_i->f_txwords  = tx_words;\n\t\t\tmemcpy(st_fc_i->fchost_name, drd->d_name, sizeof(st_fc_i->fchost_name));\n\t\t\tst_fc_i->fchost_name[sizeof(st_fc_i->fchost_name) - 1] = '\\0';\n\t\t}\n\t}\n\n\t__closedir(dir);\n\treturn fch_read;\n}\n\n/*\n ***************************************************************************\n * Read softnet statistics.\n *\n * IN:\n * @st_softnet\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 0.\n * @online_cpu_bitmap\n *\t\tBitmap listing online CPU.\n *\n * OUT:\n * @st_softnet\tStructure with statistics.\n *\n * RETURNS:\n * 1 if stats have been sucessfully read, or 0 otherwise.\n * Returns -1 if the buffer was too small and needs to be reallocated.\n ***************************************************************************\n */\nint read_softnet(struct stats_softnet *st_softnet, __nr_t nr_alloc,\n\t\t const unsigned char online_cpu_bitmap[])\n{\n\tFILE *fp;\n\tstruct stats_softnet *st_softnet_i, st_softnet_read;\n\tchar line[1024];\n\tint rc = 1, i;\n\tunsigned int cpu = 1, cpu_id;\n\n\t/* Open /proc/net/softnet_stat file */\n\tif ((fp = fopen(NET_SOFTNET, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\t/* Softnet backlog length may be not available */\n\t\tst_softnet_read.backlog_len = 0;\n\n\t\ti = sscanf(line, \"%x %x %x %*x %*x %*x %*x %*x %*x %x %x %x %x\",\n\t\t\t   &(st_softnet_read.processed),\n\t\t\t   &(st_softnet_read.dropped),\n\t\t\t   &(st_softnet_read.time_squeeze),\n\t\t\t   &(st_softnet_read.received_rps),\n\t\t\t   &(st_softnet_read.flow_limit),\n\t\t\t   &(st_softnet_read.backlog_len),\n\t\t\t   &cpu_id);\n\n\t\tif (i == 7) {\n\t\t\t/* Corresponding CPU read in file */\n\t\t\tcpu = cpu_id + 1;\n\t\t}\n\t\telse {\n\t\t\t/* cpu_id not present in file */\n\t\t\twhile (!IS_CPU_SET(online_cpu_bitmap, cpu - 1) && (cpu < nr_alloc)) {\n\t\t\t\tcpu++;\n\t\t\t}\n\t\t}\n\n\t\tif (cpu >= nr_alloc) {\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tst_softnet_i = st_softnet + cpu++;\n\t\t*st_softnet_i = st_softnet_read;\n\t}\n\n\tfclose(fp);\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall information from a file located in /proc/pressure\n * directory.\n *\n * IN:\n * @st_psi\tStructure where stats will be saved.\n * @filename\tFile located in /proc/pressure directory to read.\n * @token\t\"some\" or \"full\". Indicate which line shall be read in file.\n *\n * OUT:\n * @st_psi\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\nint read_psi_stub(struct stats_psi *st_psi, char *filename, char *token)\n{\n\tFILE *fp;\n\tchar line[8192];\n\tunsigned long psi_tmp[3];\n\tint rc = 0, len;\n\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tlen = strlen(token);\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, token, len)) {\n\t\t\t/* Read stats */\n\t\t\trc = sscanf(line + len + 1, \"avg10=%lu.%lu avg60=%lu.%lu avg300=%lu.%lu total=%llu\",\n\t\t\t\t    &psi_tmp[0], &st_psi->avg10,\n\t\t\t\t    &psi_tmp[1], &st_psi->avg60,\n\t\t\t\t    &psi_tmp[2], &st_psi->avg300,\n\t\t\t\t    &st_psi->total);\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tif (rc < 7)\n\t\treturn 0;\n\n\tst_psi->avg10  += psi_tmp[0] * 100;\n\tst_psi->avg60  += psi_tmp[1] * 100;\n\tst_psi->avg300 += psi_tmp[2] * 100;\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall CPU information.\n *\n * IN:\n * @st_psi_cpu\tStructure where stats will be saved.\n *\n * OUT:\n * @st_psi_cpu\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_psicpu(struct stats_psi_cpu *st_psi_cpu)\n{\n\tstruct stats_psi st_psi;\n\n\t/* Read CPU stats */\n\tif (!read_psi_stub(&st_psi, PSI_CPU, \"some\"))\n\t\treturn 0;\n\n\tst_psi_cpu->some_acpu_10   = st_psi.avg10;\n\tst_psi_cpu->some_acpu_60   = st_psi.avg60;\n\tst_psi_cpu->some_acpu_300  = st_psi.avg300;\n\tst_psi_cpu->some_cpu_total = st_psi.total;\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall I/O information.\n *\n * IN:\n * @st_psi_io\tStructure where stats will be saved.\n *\n * OUT:\n * @st_psi_io\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_psiio(struct stats_psi_io *st_psi_io)\n{\n\tstruct stats_psi st_psi;\n\n\t/* Read I/O \"some\" stats */\n\tif (!read_psi_stub(&st_psi, PSI_IO, \"some\"))\n\t\treturn 0;\n\n\tst_psi_io->some_aio_10   = st_psi.avg10;\n\tst_psi_io->some_aio_60   = st_psi.avg60;\n\tst_psi_io->some_aio_300  = st_psi.avg300;\n\tst_psi_io->some_io_total = st_psi.total;\n\n\t/* Read I/O \"full\" stats */\n\tif (!read_psi_stub(&st_psi, PSI_IO, \"full\"))\n\t\treturn 0;\n\n\tst_psi_io->full_aio_10   = st_psi.avg10;\n\tst_psi_io->full_aio_60   = st_psi.avg60;\n\tst_psi_io->full_aio_300  = st_psi.avg300;\n\tst_psi_io->full_io_total = st_psi.total;\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall memory information.\n *\n * IN:\n * @st_psi_mem\tStructure where stats will be saved.\n *\n * OUT:\n * @st_psi_mem\tStructure with statistics.\n *\n * RETURNS:\n * 1 on success, 0 otherwise.\n ***************************************************************************\n */\n__nr_t read_psimem(struct stats_psi_mem *st_psi_mem)\n{\n\tstruct stats_psi st_psi;\n\n\t/* Read memory \"some\" stats */\n\tif (!read_psi_stub(&st_psi, PSI_MEM, \"some\"))\n\t\treturn 0;\n\n\tst_psi_mem->some_amem_10   = st_psi.avg10;\n\tst_psi_mem->some_amem_60   = st_psi.avg60;\n\tst_psi_mem->some_amem_300  = st_psi.avg300;\n\tst_psi_mem->some_mem_total = st_psi.total;\n\n\t/* Read memory \"full\" stats */\n\tif (!read_psi_stub(&st_psi, PSI_MEM, \"full\"))\n\t\treturn 0;\n\n\tst_psi_mem->full_amem_10   = st_psi.avg10;\n\tst_psi_mem->full_amem_60   = st_psi.avg60;\n\tst_psi_mem->full_amem_300  = st_psi.avg300;\n\tst_psi_mem->full_mem_total = st_psi.total;\n\n\treturn 1;\n}\n\n/*\n * **************************************************************************\n * Read batteries statistics.\n *\n * IN:\n * @st_bat\tStructure where stats will be saved.\n * @nr_alloc\tTotal number of structures allocated. Value is >= 0.\n *\n * OUT:\n * @st_bat\tStructure with statistics.\n *\n * RETURNS:\n * Number of batteries read, or -1 if the buffer was too small and needs to\n * be reallocated.\n ***************************************************************************\n */\n__nr_t read_bat(struct stats_pwr_bat *st_bat, __nr_t nr_alloc)\n{\n\tDIR *dir;\n\tFILE *fp;\n\tstruct dirent *drd;\n\tstruct stats_pwr_bat *st_bat_i;\n\t__nr_t bat_read = 0;\n\tunsigned int capacity, bat_id;\n\tchar bat_filename[MAX_PF_NAME];\n\tchar line[256], status[64];\n\n\t/* Each battery, if present, will have its own BATx entry within SYSFS_PWR_SUPPLY */\n\tif ((dir = __opendir(SYSFS_PWR_SUPPLY)) == NULL)\n\t\treturn 0; /* No batteries */\n\n\t/*\n\t * Read each of the counters via sysfs, where they are\n\t * returned as hex values (e.g. 0x72400).\n\t */\n\twhile ((drd = __readdir(dir)) != NULL) {\n\t\tcapacity = 0;\n\t\tstatus[0] = '\\0';\n\n\t\tif (!strncmp(drd->d_name, \"BAT\", 3) && isdigit(drd->d_name[3])) {\n\n\t\t\tif (bat_read + 1 > nr_alloc) {\n\t\t\t\tbat_read = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Get battery id number */\n\t\t\tsscanf(drd->d_name + 3, \"%u\", &bat_id);\n\n\t\t\t/* Read battery capcity */\n\t\t\tsnprintf(bat_filename, MAX_PF_NAME, BAT_CAPACITY,\n\t\t\t\t SYSFS_PWR_SUPPLY, drd->d_name);\n\t\t\tif ((fp = fopen(bat_filename, \"r\"))) {\n\t\t\t\tif (fgets(line, sizeof(line), fp)) {\n\t\t\t\t\tsscanf(line, \"%u\", &capacity);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\n\t\t\t/* Read battery status */\n\t\t\tsnprintf(bat_filename, MAX_PF_NAME, BAT_STATUS,\n\t\t\t\t SYSFS_PWR_SUPPLY, drd->d_name);\n\t\t\tif ((fp = fopen(bat_filename, \"r\"))) {\n\t\t\t\tfgets(status, sizeof(status), fp);\n\t\t\t\tfclose(fp);\n\t\t\t}\n\n\t\t\tst_bat_i = st_bat + bat_read++;\n\t\t\tst_bat_i->bat_id = (char) bat_id;\n\t\t\tst_bat_i->capacity = (char) capacity;\n\n\t\t\tif (!strncmp(status, \"Charging\", 8)) {\n\t\t\t\tst_bat_i->status = BAT_STS_CHARGING;\n\t\t\t}\n\t\t\telse if (!strncmp(status, \"Discharging\", 11)) {\n\t\t\t\tst_bat_i->status = BAT_STS_DISCHARGING;\n\t\t\t}\n\t\t\telse if (!strncmp(status, \"Not charging\", 12)) {\n\t\t\t\tst_bat_i->status = BAT_STS_NOTCHARGING;\n\t\t\t}\n\t\t\telse if (!strncmp(status, \"Full\", 4)) {\n\t\t\t\tst_bat_i->status = BAT_STS_FULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst_bat_i->status = BAT_STS_UNKNOWN;\n\t\t\t}\n\t\t}\n\t}\n\n\t__closedir(dir);\n\treturn bat_read;\n}\n\n/*------------------ END: FUNCTIONS USED BY SADC ONLY ---------------------*/\n#endif /* SOURCE_SADC */\n"
        },
        {
          "name": "rd_stats.h",
          "type": "blob",
          "size": 28.220703125,
          "content": "/*\n * rd_stats.h: Include file used to read system statistics\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _RD_STATS_H\n#define _RD_STATS_H\n\n#include \"common.h\"\n\n/*\n ***************************************************************************\n * Miscellaneous constants\n ***************************************************************************\n */\n\n/* Maximum length of block device name */\n#define MAX_DEV_LEN\t128\n/* Maximum length of network interface name */\n#define MAX_IFACE_LEN\t16\n/* Maximum length of USB manufacturer string */\n#define MAX_MANUF_LEN\t24\n/* Maximum length of USB product string */\n#define MAX_PROD_LEN\t48\n/* Maximum length of filesystem name */\n#define MAX_FS_LEN\t128\n/* Maximum length of FC host name */\n#define MAX_FCH_LEN\t16\n/* Maximum length of interrupt name */\n#define MAX_SA_IRQ_LEN\t8\n\n#define CNT_PART\t1\n#define CNT_ALL_DEV\t0\n#define CNT_USED_DEV\t1\n\n#define K_DUPLEX_HALF\t\"half\"\n#define K_DUPLEX_FULL\t\"full\"\n\n#define C_DUPLEX_HALF\t1\n#define C_DUPLEX_FULL\t2\n\n/* Type for all functions counting items. Value can be negative (-1) */\n#define __nr_t\t\tint\n\n/*\n ***************************************************************************\n * System files containing statistics\n ***************************************************************************\n */\n\n/* Files */\n#define SERIAL\t\t\tPRE \"/proc/tty/driver/serial\"\n#define FDENTRY_STATE\t\tPRE \"/proc/sys/fs/dentry-state\"\n#define FFILE_NR\t\tPRE \"/proc/sys/fs/file-nr\"\n#define FINODE_STATE\t\tPRE \"/proc/sys/fs/inode-state\"\n#define PTY_NR\t\t\tPRE \"/proc/sys/kernel/pty/nr\"\n#define NET_DEV\t\t\tPRE \"/proc/net/dev\"\n#define NET_SOCKSTAT\t\tPRE \"/proc/net/sockstat\"\n#define NET_SOCKSTAT6\t\tPRE \"/proc/net/sockstat6\"\n#define NET_RPC_NFS\t\tPRE \"/proc/net/rpc/nfs\"\n#define NET_RPC_NFSD\t\tPRE \"/proc/net/rpc/nfsd\"\n#define NET_SOFTNET\t\tPRE \"/proc/net/softnet_stat\"\n#define LOADAVG\t\t\tPRE \"/proc/loadavg\"\n#define PRESSURE\t\tPRE \"/proc/pressure\"\n#define PSI_CPU\t\t\tPRESSURE \"/cpu\"\n#define PSI_IO\t\t\tPRESSURE \"/io\"\n#define PSI_MEM\t\t\tPRESSURE \"/memory\"\n#define VMSTAT\t\t\tPRE \"/proc/vmstat\"\n#define NET_SNMP\t\tPRE \"/proc/net/snmp\"\n#define NET_SNMP6\t\tPRE \"/proc/net/snmp6\"\n#define CPUINFO\t\t\tPRE \"/proc/cpuinfo\"\n#define MTAB\t\t\tPRE \"/etc/mtab\"\n#define IF_DUPLEX\t\tPRE \"/sys/class/net/%s/duplex\"\n#define IF_SPEED\t\tPRE \"/sys/class/net/%s/speed\"\n#define FC_RX_FRAMES\t\t\"%s/%s/statistics/rx_frames\"\n#define FC_TX_FRAMES\t\t\"%s/%s/statistics/tx_frames\"\n#define FC_RX_WORDS\t\t\"%s/%s/statistics/rx_words\"\n#define FC_TX_WORDS\t\t\"%s/%s/statistics/tx_words\"\n#define SYSFS_USBDEV\t\tPRE \"/sys/bus/usb/devices\"\n#define SYSFS_TIME_IN_STATE\t\"cpufreq/stats/time_in_state\"\n#define SYSFS_IDVENDOR\t\t\"idVendor\"\n#define SYSFS_IDPRODUCT\t\t\"idProduct\"\n#define SYSFS_BMAXPOWER\t\t\"bMaxPower\"\n#define SYSFS_MANUFACTURER\t\"manufacturer\"\n#define SYSFS_PRODUCT\t\t\"product\"\n#define SYSFS_FCHOST\t\tPRE \"/sys/class/fc_host\"\n#define SYSFS_PWR_SUPPLY\tPRE \"/sys/class/power_supply\"\n#define BAT_CAPACITY\t\t\"%s/%s/capacity\"\n#define BAT_STATUS\t\t\"%s/%s/status\"\n\n/*\n ***************************************************************************\n * Definitions of structures for system statistics.\n * WARNING: Fields order matters for SVG graphs!\n ***************************************************************************\n */\n\n#define SIZEOF_LONG_64BIT\t8\n#define ULL_ALIGNMENT_WIDTH\t8\n#define UL_ALIGNMENT_WIDTH\tSIZEOF_LONG_64BIT\n#define U_ALIGNMENT_WIDTH\t4\n\n#define MAP_SIZE(m)\t((m[0] * ULL_ALIGNMENT_WIDTH) + \\\n\t\t\t (m[1] * UL_ALIGNMENT_WIDTH) +  \\\n\t\t\t (m[2] * U_ALIGNMENT_WIDTH))\n\n/*\n * Structure for CPU statistics.\n * In activity buffer: First structure is for global CPU utilization (\"all\").\n * Following structures are for each individual CPU (0, 1, etc.)\n *\n * Used by: sadc, sar, sadf, iostat, mpstat, pidstat\n */\nstruct stats_cpu {\n\tunsigned long long cpu_user;\n\tunsigned long long cpu_nice;\n\tunsigned long long cpu_sys;\n\tunsigned long long cpu_idle;\n\tunsigned long long cpu_iowait;\n\tunsigned long long cpu_steal;\n\tunsigned long long cpu_hardirq;\n\tunsigned long long cpu_softirq;\n\tunsigned long long cpu_guest;\n\tunsigned long long cpu_guest_nice;\n};\n\n#define STATS_CPU_SIZE\t(sizeof(struct stats_cpu))\n#define STATS_CPU_ULL\t10\n#define STATS_CPU_UL\t0\n#define STATS_CPU_U\t0\n#define STATS_CPU_XNR\t10\n\n/*\n * Structure for task creation and context switch statistics.\n * The attribute (aligned(8)) is necessary so that sizeof(structure) has\n * the same value on 32 and 64-bit architectures.\n */\nstruct stats_pcsw {\n\tunsigned long long context_switch;\n\tunsigned long\t   processes\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PCSW_SIZE\t(sizeof(struct stats_pcsw))\n#define STATS_PCSW_ULL\t1\n#define STATS_PCSW_UL\t1\n#define STATS_PCSW_U\t0\n#define STATS_PCSW_XNR\t2\n\n/*\n * Structure for interrupts statistics.\n * In activity buffer (sadc): First structures are for global CPU utilization (\"all\"):\n * interrupts sum, 0, 1,...\n * Following structures are for each individual CPU (0, 1, etc.)\n *\n * Used by: sadc, sar, sadf\n */\nstruct stats_irq {\n\tunsigned int irq_nr;\n\tchar\t     irq_name[MAX_SA_IRQ_LEN];\n};\n\n#define STATS_IRQ_SIZE\t(sizeof(struct stats_irq))\n#define STATS_IRQ_ULL\t0\n#define STATS_IRQ_UL\t0\n#define STATS_IRQ_U\t1\n#define STATS_IRQ_XNR\t1\n\n/* Structure for swapping statistics */\nstruct stats_swap {\n\tunsigned long pswpin\t__attribute__ ((aligned (8)));\n\tunsigned long pswpout\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_SWAP_SIZE\t(sizeof(struct stats_swap))\n#define STATS_SWAP_ULL\t0\n#define STATS_SWAP_UL\t2\n#define STATS_SWAP_U\t0\n#define STATS_SWAP_XNR\t2\n\n/* Structure for paging statistics */\nstruct stats_paging {\n\tunsigned long pgpgin\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgpgout\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgfault\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgmajfault\t__attribute__ ((aligned (8)));\n\tunsigned long pgfree\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgscan_kswapd\t__attribute__ ((aligned (8)));\n\tunsigned long pgscan_direct\t__attribute__ ((aligned (8)));\n\tunsigned long pgsteal\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgpromote\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgdemote \t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PAGING_SIZE\t(sizeof(struct stats_paging))\n#define STATS_PAGING_ULL\t0\n#define STATS_PAGING_UL\t\t10\n#define STATS_PAGING_U\t\t0\n#define STATS_PAGING_XNR\t10\n\n/* Structure for I/O and transfer rate statistics */\nstruct stats_io {\n\tunsigned long long dk_drive;\n\tunsigned long long dk_drive_rio;\n\tunsigned long long dk_drive_wio;\n\tunsigned long long dk_drive_rblk;\n\tunsigned long long dk_drive_wblk;\n\tunsigned long long dk_drive_dio;\n\tunsigned long long dk_drive_dblk;\n};\n\n#define STATS_IO_SIZE\t(sizeof(struct stats_io))\n#define STATS_IO_ULL\t7\n#define STATS_IO_UL\t0\n#define STATS_IO_U\t0\n#define STATS_IO_XNR\t7\n\n/*\n * Structure for memory and swap space utilization statistics.\n *\n * Used by: sadc, sar, sadf, pidstat\n */\nstruct stats_memory {\n\tunsigned long long frmkb;\n\tunsigned long long bufkb;\n\tunsigned long long camkb;\n\tunsigned long long tlmkb;\n\tunsigned long long frskb;\n\tunsigned long long tlskb;\n\tunsigned long long caskb;\n\tunsigned long long comkb;\n\tunsigned long long activekb;\n\tunsigned long long inactkb;\n\tunsigned long long dirtykb;\n\tunsigned long long anonpgkb;\n\tunsigned long long slabkb;\n\tunsigned long long kstackkb;\n\tunsigned long long pgtblkb;\n\tunsigned long long vmusedkb;\n\tunsigned long long availablekb;\n};\n\n#define STATS_MEMORY_SIZE\t(sizeof(struct stats_memory))\n#define STATS_MEMORY_ULL\t17\n#define STATS_MEMORY_UL\t\t0\n#define STATS_MEMORY_U\t\t0\n#define STATS_MEMORY_XNR\t21\n\n/* Structure for kernel tables statistics */\nstruct stats_ktables {\n\tunsigned long long file_used;\n\tunsigned long long inode_used;\n\tunsigned long long dentry_stat;\n\tunsigned long long pty_nr;\n};\n\n#define STATS_KTABLES_SIZE\t(sizeof(struct stats_ktables))\n#define STATS_KTABLES_ULL\t4\n#define STATS_KTABLES_UL\t0\n#define STATS_KTABLES_U\t\t0\n#define STATS_KTABLES_XNR\t4\n\n/* Structure for queue and load statistics */\nstruct stats_queue {\n\tunsigned long long nr_running;\n\tunsigned long long procs_blocked;\n\tunsigned long long nr_threads;\n\tunsigned int\t   load_avg_1;\n\tunsigned int\t   load_avg_5;\n\tunsigned int\t   load_avg_15;\n};\n\n#define STATS_QUEUE_SIZE\t(sizeof(struct stats_queue))\n#define STATS_QUEUE_ULL\t\t3\n#define STATS_QUEUE_UL\t\t0\n#define STATS_QUEUE_U\t\t3\n#define STATS_QUEUE_XNR\t\t6\n\n/* Structure for serial statistics */\nstruct stats_serial {\n\tunsigned int rx;\n\tunsigned int tx;\n\tunsigned int frame;\n\tunsigned int parity;\n\tunsigned int brk;\n\tunsigned int overrun;\n\tunsigned int line;\n};\n\n#define STATS_SERIAL_SIZE\t(sizeof(struct stats_serial))\n#define STATS_SERIAL_ULL\t0\n#define STATS_SERIAL_UL\t\t0\n#define STATS_SERIAL_U\t\t7\n#define STATS_SERIAL_XNR\t6\n\n/*\n * Structure for block devices statistics.\n *\n * Used by: sadc, sar, sadf, iostat\n */\nstruct stats_disk {\n\tunsigned long long nr_ios;\n\tunsigned long long wwn[2];\n\tunsigned long\t   rd_sect\t__attribute__ ((aligned (8)));\n\tunsigned long\t   wr_sect\t__attribute__ ((aligned (8)));\n\tunsigned long\t   dc_sect\t__attribute__ ((aligned (8)));\n\tunsigned int\t   rd_ticks\t__attribute__ ((aligned (8)));\n\tunsigned int\t   wr_ticks;\n\tunsigned int\t   tot_ticks;\n\tunsigned int\t   rq_ticks;\n\tunsigned int\t   major;\n\tunsigned int\t   minor;\n\tunsigned int\t   dc_ticks;\n\tunsigned int\t   part_nr;\n};\n\n#define STATS_DISK_SIZE\t(sizeof(struct stats_disk))\n#define STATS_DISK_ULL\t3\n#define STATS_DISK_UL\t3\n#define STATS_DISK_U\t8\n#define STATS_DISK_XNR\t8\n\n/* Structure for network interfaces statistics */\nstruct stats_net_dev {\n\tunsigned long long rx_packets;\n\tunsigned long long tx_packets;\n\tunsigned long long rx_bytes;\n\tunsigned long long tx_bytes;\n\tunsigned long long rx_compressed;\n\tunsigned long long tx_compressed;\n\tunsigned long long multicast;\n\tunsigned int\t   speed;\n\tchar\t\t   interface[MAX_IFACE_LEN];\n\tchar\t\t   duplex;\n};\n\n#define STATS_NET_DEV_SIZE\t(sizeof(struct stats_net_dev))\n#define STATS_NET_DEV_SIZE2CMP\t(STATS_NET_DEV_SIZE - MAX_IFACE_LEN - 1)\n#define STATS_NET_DEV_ULL\t7\n#define STATS_NET_DEV_UL\t0\n#define STATS_NET_DEV_U\t\t1\n#define STATS_NET_DEV_XNR\t8\n\n/* Structure for network interface errors statistics */\nstruct stats_net_edev {\n\tunsigned long long collisions;\n\tunsigned long long rx_errors;\n\tunsigned long long tx_errors;\n\tunsigned long long rx_dropped;\n\tunsigned long long tx_dropped;\n\tunsigned long long rx_fifo_errors;\n\tunsigned long long tx_fifo_errors;\n\tunsigned long long rx_frame_errors;\n\tunsigned long long tx_carrier_errors;\n\tchar\t\t   interface[MAX_IFACE_LEN];\n};\n\n#define STATS_NET_EDEV_SIZE\t(sizeof(struct stats_net_edev))\n#define STATS_NET_EDEV_SIZE2CMP\t(STATS_NET_EDEV_SIZE - MAX_IFACE_LEN)\n#define STATS_NET_EDEV_ULL\t9\n#define STATS_NET_EDEV_UL\t0\n#define STATS_NET_EDEV_U\t0\n#define STATS_NET_EDEV_XNR\t9\n\n/* Structure for NFS client statistics */\nstruct stats_net_nfs {\n\tunsigned int nfs_rpccnt;\n\tunsigned int nfs_rpcretrans;\n\tunsigned int nfs_readcnt;\n\tunsigned int nfs_writecnt;\n\tunsigned int nfs_accesscnt;\n\tunsigned int nfs_getattcnt;\n};\n\n#define STATS_NET_NFS_SIZE\t(sizeof(struct stats_net_nfs))\n#define STATS_NET_NFS_ULL\t0\n#define STATS_NET_NFS_UL\t0\n#define STATS_NET_NFS_U\t\t6\n#define STATS_NET_NFS_XNR\t6\n\n/* Structure for NFS server statistics */\nstruct stats_net_nfsd {\n\tunsigned int nfsd_rpccnt;\n\tunsigned int nfsd_rpcbad;\n\tunsigned int nfsd_netcnt;\n\tunsigned int nfsd_netudpcnt;\n\tunsigned int nfsd_nettcpcnt;\n\tunsigned int nfsd_rchits;\n\tunsigned int nfsd_rcmisses;\n\tunsigned int nfsd_readcnt;\n\tunsigned int nfsd_writecnt;\n\tunsigned int nfsd_accesscnt;\n\tunsigned int nfsd_getattcnt;\n};\n\n#define STATS_NET_NFSD_SIZE\t(sizeof(struct stats_net_nfsd))\n#define STATS_NET_NFSD_ULL\t0\n#define STATS_NET_NFSD_UL\t0\n#define STATS_NET_NFSD_U\t11\n#define STATS_NET_NFSD_XNR\t11\n\n/* Structure for IPv4 sockets statistics */\nstruct stats_net_sock {\n\tunsigned int sock_inuse;\n\tunsigned int tcp_inuse;\n\tunsigned int tcp_tw;\n\tunsigned int udp_inuse;\n\tunsigned int raw_inuse;\n\tunsigned int frag_inuse;\n};\n\n#define STATS_NET_SOCK_SIZE\t(sizeof(struct stats_net_sock))\n#define STATS_NET_SOCK_ULL\t0\n#define STATS_NET_SOCK_UL\t0\n#define STATS_NET_SOCK_U\t6\n#define STATS_NET_SOCK_XNR\t6\n\n/* Structure for IP statistics */\nstruct stats_net_ip {\n\tunsigned long long InReceives;\n\tunsigned long long ForwDatagrams;\n\tunsigned long long InDelivers;\n\tunsigned long long OutRequests;\n\tunsigned long long ReasmReqds;\n\tunsigned long long ReasmOKs;\n\tunsigned long long FragOKs;\n\tunsigned long long FragCreates;\n};\n\n#define STATS_NET_IP_SIZE\t(sizeof(struct stats_net_ip))\n#define STATS_NET_IP_ULL\t8\n#define STATS_NET_IP_UL\t\t0\n#define STATS_NET_IP_U\t\t0\n#define STATS_NET_IP_XNR\t8\n\n/* Structure for IP errors statistics */\nstruct stats_net_eip {\n\tunsigned long long InHdrErrors;\n\tunsigned long long InAddrErrors;\n\tunsigned long long InUnknownProtos;\n\tunsigned long long InDiscards;\n\tunsigned long long OutDiscards;\n\tunsigned long long OutNoRoutes;\n\tunsigned long long ReasmFails;\n\tunsigned long long FragFails;\n};\n\n#define STATS_NET_EIP_SIZE\t(sizeof(struct stats_net_eip))\n#define STATS_NET_EIP_ULL\t8\n#define STATS_NET_EIP_UL\t0\n#define STATS_NET_EIP_U\t\t0\n#define STATS_NET_EIP_XNR\t8\n\n/* Structure for ICMP statistics */\nstruct stats_net_icmp {\n\tunsigned long InMsgs\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutMsgs\t\t__attribute__ ((aligned (8)));\n\tunsigned long InEchos\t\t__attribute__ ((aligned (8)));\n\tunsigned long InEchoReps\t__attribute__ ((aligned (8)));\n\tunsigned long OutEchos\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutEchoReps\t__attribute__ ((aligned (8)));\n\tunsigned long InTimestamps\t__attribute__ ((aligned (8)));\n\tunsigned long InTimestampReps\t__attribute__ ((aligned (8)));\n\tunsigned long OutTimestamps\t__attribute__ ((aligned (8)));\n\tunsigned long OutTimestampReps\t__attribute__ ((aligned (8)));\n\tunsigned long InAddrMasks\t__attribute__ ((aligned (8)));\n\tunsigned long InAddrMaskReps\t__attribute__ ((aligned (8)));\n\tunsigned long OutAddrMasks\t__attribute__ ((aligned (8)));\n\tunsigned long OutAddrMaskReps\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_ICMP_SIZE\t(sizeof(struct stats_net_icmp))\n#define STATS_NET_ICMP_ULL\t0\n#define STATS_NET_ICMP_UL\t14\n#define STATS_NET_ICMP_U\t0\n#define STATS_NET_ICMP_XNR\t14\n\n/* Structure for ICMP error message statistics */\nstruct stats_net_eicmp {\n\tunsigned long InErrors\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutErrors\t\t__attribute__ ((aligned (8)));\n\tunsigned long InDestUnreachs\t__attribute__ ((aligned (8)));\n\tunsigned long OutDestUnreachs\t__attribute__ ((aligned (8)));\n\tunsigned long InTimeExcds\t__attribute__ ((aligned (8)));\n\tunsigned long OutTimeExcds\t__attribute__ ((aligned (8)));\n\tunsigned long InParmProbs\t__attribute__ ((aligned (8)));\n\tunsigned long OutParmProbs\t__attribute__ ((aligned (8)));\n\tunsigned long InSrcQuenchs\t__attribute__ ((aligned (8)));\n\tunsigned long OutSrcQuenchs\t__attribute__ ((aligned (8)));\n\tunsigned long InRedirects\t__attribute__ ((aligned (8)));\n\tunsigned long OutRedirects\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_EICMP_SIZE\t(sizeof(struct stats_net_eicmp))\n#define STATS_NET_EICMP_ULL\t0\n#define STATS_NET_EICMP_UL\t12\n#define STATS_NET_EICMP_U\t0\n#define STATS_NET_EICMP_XNR\t12\n\n/* Structure for TCP statistics */\nstruct stats_net_tcp {\n\tunsigned long ActiveOpens\t__attribute__ ((aligned (8)));\n\tunsigned long PassiveOpens\t__attribute__ ((aligned (8)));\n\tunsigned long InSegs\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutSegs\t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_TCP_SIZE\t(sizeof(struct stats_net_tcp))\n#define STATS_NET_TCP_ULL\t0\n#define STATS_NET_TCP_UL\t4\n#define STATS_NET_TCP_U\t\t0\n#define STATS_NET_TCP_XNR\t4\n\n/* Structure for TCP errors statistics */\nstruct stats_net_etcp {\n\tunsigned long AttemptFails\t__attribute__ ((aligned (8)));\n\tunsigned long EstabResets\t__attribute__ ((aligned (8)));\n\tunsigned long RetransSegs\t__attribute__ ((aligned (8)));\n\tunsigned long InErrs\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutRsts\t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_ETCP_SIZE\t(sizeof(struct stats_net_etcp))\n#define STATS_NET_ETCP_ULL\t0\n#define STATS_NET_ETCP_UL\t5\n#define STATS_NET_ETCP_U\t0\n#define STATS_NET_ETCP_XNR\t5\n\n/* Structure for UDP statistics */\nstruct stats_net_udp {\n\tunsigned long InDatagrams\t__attribute__ ((aligned (8)));\n\tunsigned long OutDatagrams\t__attribute__ ((aligned (8)));\n\tunsigned long NoPorts\t\t__attribute__ ((aligned (8)));\n\tunsigned long InErrors\t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_UDP_SIZE\t(sizeof(struct stats_net_udp))\n#define STATS_NET_UDP_ULL\t0\n#define STATS_NET_UDP_UL\t4\n#define STATS_NET_UDP_U\t\t0\n#define STATS_NET_UDP_XNR\t4\n\n/* Structure for IPv6 sockets statistics */\nstruct stats_net_sock6 {\n\tunsigned int tcp6_inuse;\n\tunsigned int udp6_inuse;\n\tunsigned int raw6_inuse;\n\tunsigned int frag6_inuse;\n};\n\n#define STATS_NET_SOCK6_SIZE\t(sizeof(struct stats_net_sock6))\n#define STATS_NET_SOCK6_ULL\t0\n#define STATS_NET_SOCK6_UL\t0\n#define STATS_NET_SOCK6_U\t4\n#define STATS_NET_SOCK6_XNR\t4\n\n/* Structure for IPv6 statistics */\nstruct stats_net_ip6 {\n\tunsigned long long InReceives6;\n\tunsigned long long OutForwDatagrams6;\n\tunsigned long long InDelivers6;\n\tunsigned long long OutRequests6;\n\tunsigned long long ReasmReqds6;\n\tunsigned long long ReasmOKs6;\n\tunsigned long long InMcastPkts6;\n\tunsigned long long OutMcastPkts6;\n\tunsigned long long FragOKs6;\n\tunsigned long long FragCreates6;\n};\n\n#define STATS_NET_IP6_SIZE\t(sizeof(struct stats_net_ip6))\n#define STATS_NET_IP6_ULL\t10\n#define STATS_NET_IP6_UL\t0\n#define STATS_NET_IP6_U\t\t0\n#define STATS_NET_IP6_XNR\t10\n\n/* Structure for IPv6 errors statistics */\nstruct stats_net_eip6 {\n\tunsigned long long InHdrErrors6;\n\tunsigned long long InAddrErrors6;\n\tunsigned long long InUnknownProtos6;\n\tunsigned long long InTooBigErrors6;\n\tunsigned long long InDiscards6;\n\tunsigned long long OutDiscards6;\n\tunsigned long long InNoRoutes6;\n\tunsigned long long OutNoRoutes6;\n\tunsigned long long ReasmFails6;\n\tunsigned long long FragFails6;\n\tunsigned long long InTruncatedPkts6;\n};\n\n#define STATS_NET_EIP6_SIZE\t(sizeof(struct stats_net_eip6))\n#define STATS_NET_EIP6_ULL\t11\n#define STATS_NET_EIP6_UL\t0\n#define STATS_NET_EIP6_U\t0\n#define STATS_NET_EIP6_XNR\t11\n\n/* Structure for ICMPv6 statistics */\nstruct stats_net_icmp6 {\n\tunsigned long InMsgs6\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutMsgs6\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long InEchos6\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long InEchoReplies6\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutEchoReplies6\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long InGroupMembQueries6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InGroupMembResponses6\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutGroupMembResponses6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InGroupMembReductions6\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutGroupMembReductions6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InRouterSolicits6\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutRouterSolicits6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InRouterAdvertisements6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InNeighborSolicits6\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutNeighborSolicits6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InNeighborAdvertisements6\t\t__attribute__ ((aligned (8)));\n\tunsigned long OutNeighborAdvertisements6\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_ICMP6_SIZE\t(sizeof(struct stats_net_icmp6))\n#define STATS_NET_ICMP6_ULL\t0\n#define STATS_NET_ICMP6_UL\t17\n#define STATS_NET_ICMP6_U\t0\n#define STATS_NET_ICMP6_XNR\t17\n\n/* Structure for ICMPv6 error message statistics */\nstruct stats_net_eicmp6 {\n\tunsigned long InErrors6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InDestUnreachs6\t__attribute__ ((aligned (8)));\n\tunsigned long OutDestUnreachs6\t__attribute__ ((aligned (8)));\n\tunsigned long InTimeExcds6\t__attribute__ ((aligned (8)));\n\tunsigned long OutTimeExcds6\t__attribute__ ((aligned (8)));\n\tunsigned long InParmProblems6\t__attribute__ ((aligned (8)));\n\tunsigned long OutParmProblems6\t__attribute__ ((aligned (8)));\n\tunsigned long InRedirects6\t__attribute__ ((aligned (8)));\n\tunsigned long OutRedirects6\t__attribute__ ((aligned (8)));\n\tunsigned long InPktTooBigs6\t__attribute__ ((aligned (8)));\n\tunsigned long OutPktTooBigs6\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_EICMP6_SIZE\t(sizeof(struct stats_net_eicmp6))\n#define STATS_NET_EICMP6_ULL\t0\n#define STATS_NET_EICMP6_UL\t11\n#define STATS_NET_EICMP6_U\t0\n#define STATS_NET_EICMP6_XNR\t11\n\n/* Structure for UDPv6 statistics */\nstruct stats_net_udp6 {\n\tunsigned long InDatagrams6\t__attribute__ ((aligned (8)));\n\tunsigned long OutDatagrams6\t__attribute__ ((aligned (8)));\n\tunsigned long NoPorts6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InErrors6\t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_NET_UDP6_SIZE\t(sizeof(struct stats_net_udp6))\n#define STATS_NET_UDP6_ULL\t0\n#define STATS_NET_UDP6_UL\t4\n#define STATS_NET_UDP6_U\t0\n#define STATS_NET_UDP6_XNR\t4\n\n/*\n * Structure for CPU frequency statistics.\n * In activity buffer: First structure is for global CPU utilization (\"all\").\n * Following structures are for each individual CPU (0, 1, etc.)\n */\nstruct stats_pwr_cpufreq {\n\tunsigned long cpufreq\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PWR_CPUFREQ_SIZE\t(sizeof(struct stats_pwr_cpufreq))\n#define STATS_PWR_CPUFREQ_ULL\t0\n#define STATS_PWR_CPUFREQ_UL\t1\n#define STATS_PWR_CPUFREQ_U\t0\n#define STATS_PWR_CPUFREQ_XNR\t1\n\n/* Structure for hugepages statistics */\nstruct stats_huge {\n\tunsigned long long frhkb;\n\tunsigned long long tlhkb;\n\tunsigned long long rsvdhkb;\n\tunsigned long long surphkb;\n};\n\n#define STATS_HUGE_SIZE\t(sizeof(struct stats_huge))\n#define STATS_HUGE_ULL\t4\n#define STATS_HUGE_UL\t0\n#define STATS_HUGE_U\t0\n#define STATS_HUGE_XNR\t5\n\n/*\n * Structure for weighted CPU frequency statistics.\n * In activity buffer: First structure is for global CPU utilization (\"all\").\n * Following structures are for each individual CPU (0, 1, etc.)\n */\nstruct stats_pwr_wghfreq {\n\tunsigned long long time_in_state;\n\tunsigned long \t   freq\t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PWR_WGHFREQ_SIZE\t(sizeof(struct stats_pwr_wghfreq))\n#define STATS_PWR_WGHFREQ_ULL\t1\n#define STATS_PWR_WGHFREQ_UL\t1\n#define STATS_PWR_WGHFREQ_U\t0\n#define STATS_PWR_WGHFREQ_XNR\t1\n\n/*\n * Structure for USB devices plugged into the system.\n */\nstruct stats_pwr_usb {\n\tunsigned int bus_nr;\n\tunsigned int vendor_id;\n\tunsigned int product_id;\n\tunsigned int bmaxpower;\n\tchar\t     manufacturer[MAX_MANUF_LEN];\n\tchar\t     product[MAX_PROD_LEN];\n};\n\n#define STATS_PWR_USB_SIZE\t(sizeof(struct stats_pwr_usb))\n#define STATS_PWR_USB_ULL\t0\n#define STATS_PWR_USB_UL\t0\n#define STATS_PWR_USB_U\t\t4\n#define STATS_PWR_USB_XNR\t0\n\n/* Structure for filesystems statistics */\nstruct stats_filesystem {\n\tunsigned long long f_blocks;\n\tunsigned long long f_bfree;\n\tunsigned long long f_bavail;\n\tunsigned long long f_files;\n\tunsigned long long f_ffree;\n\tchar \t\t   fs_name[MAX_FS_LEN];\n\tchar \t\t   mountp[MAX_FS_LEN];\n};\n\n#define STATS_FILESYSTEM_SIZE\t\t(sizeof(struct stats_filesystem))\n#define STATS_FILESYSTEM_SIZE2CMP\t(STATS_FILESYSTEM_SIZE - 2 * MAX_FS_LEN)\n#define STATS_FILESYSTEM_ULL\t\t5\n#define STATS_FILESYSTEM_UL\t\t0\n#define STATS_FILESYSTEM_U\t\t0\n#define STATS_FILESYSTEM_XNR\t\t7\n\n/* Structure for Fibre Channel HBA statistics */\nstruct stats_fchost {\n\tunsigned long f_rxframes\t\t__attribute__ ((aligned (8)));\n\tunsigned long f_txframes\t\t__attribute__ ((aligned (8)));\n\tunsigned long f_rxwords\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long f_txwords\t\t\t__attribute__ ((aligned (8)));\n\tchar\t      fchost_name[MAX_FCH_LEN]\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_FCHOST_SIZE\t(sizeof(struct stats_fchost))\n#define STATS_FCHOST_ULL\t0\n#define STATS_FCHOST_UL\t\t4\n#define STATS_FCHOST_U\t\t0\n#define STATS_FCHOST_XNR\t4\n\n/* Structure for softnet statistics */\nstruct stats_softnet {\n\tunsigned int processed;\n\tunsigned int dropped;\n\tunsigned int time_squeeze;\n\tunsigned int received_rps;\n\tunsigned int flow_limit;\n\tunsigned int backlog_len;\n};\n\n#define STATS_SOFTNET_SIZE\t(sizeof(struct stats_softnet))\n#define STATS_SOFTNET_ULL\t0\n#define STATS_SOFTNET_UL\t0\n#define STATS_SOFTNET_U\t\t6\n#define STATS_SOFTNET_XNR\t6\n\n/* Structure for pressure-stall CPU statistics */\nstruct stats_psi_cpu {\n\tunsigned long long some_cpu_total;\n\tunsigned long\t   some_acpu_10\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   some_acpu_60\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   some_acpu_300\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PSI_CPU_SIZE\t(sizeof(struct stats_psi_cpu))\n#define STATS_PSI_CPU_ULL\t1\n#define STATS_PSI_CPU_UL\t3\n#define STATS_PSI_CPU_U\t\t0\n#define STATS_PSI_CPU_XNR\t4\n\n/* Structure for pressure-stall I/O statistics */\nstruct stats_psi_io {\n\tunsigned long long some_io_total;\n\tunsigned long long full_io_total;\n\tunsigned long\t   some_aio_10\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   some_aio_60\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   some_aio_300\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   full_aio_10\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   full_aio_60\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   full_aio_300\t\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PSI_IO_SIZE\t(sizeof(struct stats_psi_io))\n#define STATS_PSI_IO_ULL\t2\n#define STATS_PSI_IO_UL\t\t6\n#define STATS_PSI_IO_U\t\t0\n#define STATS_PSI_IO_XNR\t8\n\n/* Structure for pressure-stall memory statistics */\nstruct stats_psi_mem {\n\tunsigned long long some_mem_total;\n\tunsigned long long full_mem_total;\n\tunsigned long\t   some_amem_10\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   some_amem_60\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   some_amem_300\t__attribute__ ((aligned (8)));\n\tunsigned long\t   full_amem_10\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   full_amem_60\t\t__attribute__ ((aligned (8)));\n\tunsigned long\t   full_amem_300\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_PSI_MEM_SIZE\t(sizeof(struct stats_psi_mem))\n#define STATS_PSI_MEM_ULL\t2\n#define STATS_PSI_MEM_UL\t6\n#define STATS_PSI_MEM_U\t\t0\n#define STATS_PSI_MEM_XNR\t8\n\n/* Structure for batteries statistics */\nstruct stats_pwr_bat {\n\tchar\tbat_id;\n\tchar\tcapacity;\n\tchar\tstatus;\n};\n\n#define STATS_PWR_BAT_SIZE\t(sizeof(struct stats_pwr_bat))\n#define STATS_PWR_BAT_ULL\t0\n#define STATS_PWR_BAT_UL\t0\n#define STATS_PWR_BAT_U\t\t0\n#define STATS_PWR_BAT_XNR\t2\n\n/*\n ***************************************************************************\n * Prototypes for functions used to read system statistics\n ***************************************************************************\n */\n\nvoid compute_ext_disk_stats\n\t(struct stats_disk *, struct stats_disk *, unsigned long long,\n\t struct ext_disk_stats *);\nunsigned long long get_per_cpu_interval\n\t(struct stats_cpu *, struct stats_cpu *);\n__nr_t read_stat_cpu\n\t(struct stats_cpu *, __nr_t);\n__nr_t read_stat_irq\n\t(struct stats_irq *, __nr_t, __nr_t);\n__nr_t read_meminfo\n\t(struct stats_memory *);\nvoid read_uptime\n\t(unsigned long long *);\n#ifdef SOURCE_SADC\nvoid oct2chr\n\t(char *);\n__nr_t read_stat_pcsw\n\t(struct stats_pcsw *);\n__nr_t read_loadavg\n\t(struct stats_queue *);\n__nr_t read_vmstat_swap\n\t(struct stats_swap *);\n__nr_t read_vmstat_paging\n\t(struct stats_paging *);\n__nr_t read_diskstats_io\n\t(struct stats_io *);\n__nr_t read_diskstats_disk\n\t(struct stats_disk *, __nr_t, int);\n__nr_t read_tty_driver_serial\n\t(struct stats_serial *, __nr_t);\n__nr_t read_kernel_tables\n\t(struct stats_ktables *);\n__nr_t read_net_dev\n\t(struct stats_net_dev *, __nr_t);\nvoid read_if_info\n\t(struct stats_net_dev *, int);\n__nr_t read_net_edev\n\t(struct stats_net_edev *, __nr_t);\n__nr_t read_net_nfs\n\t(struct stats_net_nfs *);\n__nr_t read_net_nfsd\n\t(struct stats_net_nfsd *);\n__nr_t read_net_sock\n\t(struct stats_net_sock *);\n__nr_t read_net_ip\n\t(struct stats_net_ip *);\n__nr_t read_net_eip\n\t(struct stats_net_eip *);\n__nr_t read_net_icmp\n\t(struct stats_net_icmp *);\n__nr_t read_net_eicmp\n\t(struct stats_net_eicmp *);\n__nr_t read_net_tcp\n\t(struct stats_net_tcp *);\n__nr_t read_net_etcp\n\t(struct stats_net_etcp *);\n__nr_t read_net_udp\n\t(struct stats_net_udp *);\n__nr_t read_net_sock6\n\t(struct stats_net_sock6 *);\n__nr_t read_net_ip6\n\t(struct stats_net_ip6 *);\n__nr_t read_net_eip6\n\t(struct stats_net_eip6 *);\n__nr_t read_net_icmp6\n\t(struct stats_net_icmp6 *);\n__nr_t read_net_eicmp6\n\t(struct stats_net_eicmp6 *);\n__nr_t read_net_udp6\n\t(struct stats_net_udp6 *);\n__nr_t read_cpuinfo\n\t(struct stats_pwr_cpufreq *, __nr_t);\n__nr_t read_meminfo_huge\n\t(struct stats_huge *);\n__nr_t read_cpu_wghfreq\n\t(struct stats_pwr_wghfreq *, __nr_t, __nr_t);\n__nr_t read_bus_usb_dev\n\t(struct stats_pwr_usb *, __nr_t);\n__nr_t read_filesystem\n\t(struct stats_filesystem *, __nr_t);\n__nr_t read_fchost\n\t(struct stats_fchost *, __nr_t);\nint read_softnet\n\t(struct stats_softnet *, __nr_t, const unsigned char []);\n__nr_t read_psicpu\n\t(struct stats_psi_cpu *);\n__nr_t read_psiio\n\t(struct stats_psi_io *);\n__nr_t read_psimem\n\t(struct stats_psi_mem *);\n__nr_t read_bat\n\t(struct stats_pwr_bat *, __nr_t);\n\n#endif /* SOURCE_SADC */\n\n#endif /* _RD_STATS_H */\n"
        },
        {
          "name": "rndr_stats.c",
          "type": "blob",
          "size": 101.9091796875,
          "content": "/*\n * rndr_stats.c: Functions used by sadf to display statistics in selected format.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"sa.h\"\n#include \"ioconf.h\"\n#include \"rndr_stats.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nchar *seps[] =  {\"\\t\", \";\"};\n\nextern uint64_t flags;\nextern char bat_status[][16];\n\n/*\n ***************************************************************************\n * cons() -\n *   encapsulate a pair of ints or pair of char * into a static Cons and\n *   return a pointer to it.\n *\n * given:   t - type of Cons {iv, sv}\n *\t    arg1 - unsigned long int (if iv), char * (if sv) to become\n *\t\t   element 'a'\n *\t    arg2 - unsigned long int (if iv), char * (if sv) to become\n *\t\t   element 'b'\n *\n * does:    load a static Cons with values using the t parameter to\n *\t    guide pulling values from the arglist\n *\n * return:  the address of its static Cons.  If you need to keep\n *\t    the contents of this Cons, copy it somewhere before calling\n *\t    cons() against to avoid overwrite.\n *\t    ie. don't do this:  f( cons( iv, i, j ), cons( iv, a, b ) );\n ***************************************************************************\n */\nstatic Cons *cons(tcons t, ...)\n{\n\tva_list ap;\n\tstatic Cons c;\n\n\tc.t = t;\n\n\tva_start(ap, t);\n\tif (t == iv) {\n\t\tc.a.i = va_arg(ap, unsigned long int);\n\t\tc.b.i = va_arg(ap, unsigned long int);\n\t}\n\telse {\n\t\tc.a.s = va_arg(ap, char *);\n\t\tc.b.s = va_arg(ap, char *);\n\t}\n\tva_end(ap);\n\treturn(&c);\n}\n\n/*\n ***************************************************************************\n * render():\n *\n * given:    isdb - flag, true if db printing, false if ppc printing\n *\t     pre  - prefix string for output entries\n *\t     rflags - PT_.... rendering flags\n *\t     pptxt - printf-format text required for ppc output (may be null)\n *\t     dbtxt - printf-format text required for db output (may be null)\n *\t     mid - pptxt/dbtxt format args as a Cons.\n *\t     lluval - %llu printable arg (PT_USEINT must be set)\n *\t     dval  - %.2f printable arg (used unless PT_USEINT is set)\n *\t     sval - %s printable arg (PT_USESTR must be set)\n *\n * does:     print [pre<sep>]([dbtxt,arg,arg<sep>]|[pptxt,arg,arg<sep>]) \\\n *                     (luval|dval)(<sep>|\\n)\n *\n * return:   void.\n ***************************************************************************\n */\nstatic void render(int isdb, char *pre, int rflags, const char *pptxt,\n\t\t   const char *dbtxt, Cons *mid, unsigned long long lluval,\n\t\t   double dval, char *sval)\n{\n\tstatic int newline = 1;\n\tconst char *txt[]  = {pptxt, dbtxt};\n\n\t/* Start a new line? */\n\tif (newline && !DISPLAY_HORIZONTALLY(flags)) {\n\t\tprintf(\"%s\", pre);\n\t}\n\n\t/* Terminate this one ? ppc always gets a newline */\n\tnewline = ((rflags & PT_NEWLIN) || !isdb);\n\n\tif (txt[isdb]) {\n\t\t/* pp/dbtxt? */\n\n\t\tprintf(\"%s\", seps[isdb]);\t/* Only if something actually gets printed */\n\n\t\tif (mid) {\n\t\t\t/* Got format args? */\n\t\t\tswitch(mid->t) {\n\t\t\tcase iv:\n\t\t\t\tprintf(txt[isdb], mid->a.i, mid->b.i);\n\t\t\t\tbreak;\n\t\t\tcase sv:\n\t\t\t\tprintf(txt[isdb], mid->a.s, mid->b.s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s\", txt[isdb]);\n\t\t}\n\t}\n\n\tif (rflags & PT_USEINT) {\n\t\tprintf(\"%s%llu\", seps[isdb], lluval);\n\t}\n\telse if (rflags & PT_USESTR) {\n\t\tprintf(\"%s%s\", seps[isdb], sval);\n\t}\n\telse if (rflags & PT_USERND) {\n\t\tprintf(\"%s%.0f\", seps[isdb], dval);\n\t}\n\telse if (rflags & PT_NOFLAG) {\n\t\tprintf(\"%s%.2f\", seps[isdb], dval);\n\t}\n\tif (newline) {\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second (independent of the\n *\t\tnumber of processors). Unused here.\n ***************************************************************************\n */\n__print_funct_t render_cpu_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t int curr, unsigned long long itv)\n{\n\tint i;\n\tunsigned long long deltot_jiffies = 1;\n\tstruct stats_cpu *scc, *scp;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/*\n\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t * and look for offline CPU.\n\t */\n\tif (a->nr_ini > 1) {\n\t\tdeltot_jiffies = get_global_cpu_statistics(a, !curr, curr,\n\t\t\t\t\t\t\t   flags, offline_cpu_bitmap);\n\t}\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* Don't display CPU */\n\t\t\tcontinue;\n\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr]  + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (i == 0) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tif (a->nr_ini == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a UP machine. In this case\n\t\t\t\t * interval has still not been calculated.\n\t\t\t\t */\n\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t\t}\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* CPU \"all\" cannot be tickless */\n\t\t\t\tdeltot_jiffies = 1;\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\trender(isdb, pre,\n\t\t\t\t       PT_NOFLAG,\t/* that's zero but you know what it means */\n\t\t\t\t       \"all\\t%user\",\t/* ppctext */\n\t\t\t\t       \"-1\",\t\t/* look! dbtext */\n\t\t\t\t       NULL,\t\t/* no args */\n\t\t\t\t       NOVAL,\t\t/* another 0, named for readability */\n\t\t\t\t       ll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies),\n\t\t\t\t       NULL);\t\t/* No string arg */\n\t\t\t}\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%usr\", \"-1\", NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\t\t   scc->cpu_user - scc->cpu_guest,\n\t\t\t\t\t\t   deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%nice\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%nice\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\t\t   scc->cpu_nice - scc->cpu_guest_nice,\n\t\t\t\t\t\t   deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%system\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\t\t   scc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t\t\t\t\t   deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%sys\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_sys, scc->cpu_sys, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\t%iowait\", NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\t%steal\", NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t       NULL);\n\n\t\t\tif (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%irq\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies),\n\t\t\t\t       NULL);\n\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%soft\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies),\n\t\t\t\t       NULL);\n\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%guest\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies),\n\t\t\t\t       NULL);\n\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"all\\t%gnice\", NULL, NULL,\n\t\t\t\t       NOVAL,\n\t\t\t\t       ll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t       \"all\\t%idle\", NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       (scc->cpu_idle < scp->cpu_idle) ?\n\t\t\t       0.0 :\n\t\t\t       ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies),\n\t\t\t       NULL);\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * Recalculate itv for current proc.\n\t\t\t * If the result is 0, then current CPU is a tickless one.\n\t\t\t */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%user\",\t\t/* ppc text with formatting */\n\t\t\t\t       \"%d\",\t\t\t/* db text with format char */\n\t\t\t\t       cons(iv, i - 1, NOVAL),\t/* how we pass format args  */\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\t\t\t/* CPU is tickless */\n\t\t\t\t       ll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%usr\", \"%d\", cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       (!deltot_jiffies ||\n\t\t\t\t       ((scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest))) ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\t\t   scc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%nice\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%nice\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       (!deltot_jiffies ||\n\t\t\t\t       ((scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice))) ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\t\t   scc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%system\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\t\t   scc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t\t\t\t\t   deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%sys\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_sys, scc->cpu_sys, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\t%%iowait\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       !deltot_jiffies ?\n\t\t\t       0.0 :\n\t\t\t       ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\t%%steal\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       !deltot_jiffies ?\n\t\t\t       0.0 :\n\t\t\t       ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t       NULL);\n\n\t\t\tif (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%irq\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies),\n\t\t\t\t       NULL);\n\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%soft\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies),\n\t\t\t\t       NULL);\n\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%guest\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies),\n\t\t\t\t       NULL);\n\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"cpu%d\\t%%gnice\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       !deltot_jiffies ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* CPU is tickless */\n\t\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t\t       \"cpu%d\\t%%idle\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       100.0,\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t\t       \"cpu%d\\t%%idle\", NULL, cons(iv, i - 1, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       (scc->cpu_idle < scp->cpu_idle) ?\n\t\t\t\t       0.0 :\n\t\t\t\t       ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies),\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display task creation and context switch statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pcsw_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t  int curr, unsigned long long itv)\n{\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr],\n\t\t*spp = (struct stats_pcsw *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\t/* The first one as an example */\n\trender(isdb,\t\t/* db/ppc flag */\n\t       pre,\t\t/* the preformatted line leader */\n\t       PT_NOFLAG,\t/* is this the end of a db line? */\n\t       \"-\\tproc/s\",\t/* ppc text */\n\t       NULL,\t\t/* db text */\n\t       NULL,\t\t/* db/ppc text format args (Cons *) */\n\t       NOVAL,\t\t/* %lu value (unused unless PT_USEINT) */\n\t       /* and %.2f value, used unless PT_USEINT */\n\t       S_VALUE(spp->processes, spc->processes, itv),\n\t       NULL);\t\t/* %s value */\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tcswch/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->context_switch, spc->context_switch, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_irq_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t int curr, unsigned long long itv)\n{\n\tint i, c, first;\n\tstruct stats_irq *stc_cpu_irq, *stp_cpu_irq, *stc_cpuall_irq;\n\tunsigned char masked_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tchar cpu_name[32], ppc_txt[512];\n\tdouble dval;\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Identify offline and unselected CPU, and keep persistent statistics values */\n\tget_global_int_statistics(a, !curr, curr, flags, masked_cpu_bitmap);\n\n\tfor (i = 0; i < a->nr2; i++) {\n\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, stc_cpuall_irq->irq_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfirst = TRUE;\n\t\tfor (c = 0; (c < a->nr[curr]) && (c < a->bitmap->b_size + 1); c++) {\n\n\t\t\tstc_cpu_irq = (struct stats_irq *) ((char *) a->buf[curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\t\t\tstp_cpu_irq = (struct stats_irq *) ((char *) a->buf[!curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (IS_CPU_SET(masked_cpu_bitmap, c))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\t/* Compute value to be displayed */\n\t\t\tdval = S_VALUE(stp_cpu_irq->irq_nr, stc_cpu_irq->irq_nr, itv);\n\n\t\t\t/* Yes: Display it */\n\t\t\tif (!c) {\n\t\t\t\tstrcpy(cpu_name, \"all\");\n\n\t\t\t\t/* If number of int has decreased for CPU \"all\" then display 0.00 */\n\t\t\t\tif (stc_cpu_irq->irq_nr < stp_cpu_irq->irq_nr) {\n\t\t\t\t\tdval = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsnprintf(cpu_name, sizeof(cpu_name), \"cpu%d\", c - 1);\n\t\t\t\tcpu_name[sizeof(cpu_name) - 1] = '\\0';\n\t\t\t}\n\t\t\tsnprintf(ppc_txt, sizeof(ppc_txt), \"%s\\t%s\", stc_cpuall_irq->irq_name, cpu_name);\n\t\t\tppc_txt[sizeof(ppc_txt) - 1] = '\\0';\n\n\t\t\tif (first) {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"%s\", \"%s\",\n\t\t\t\t       isdb ? cons(sv, stc_cpuall_irq->irq_name, NOVAL)\n\t\t\t\t            : cons(sv, ppc_txt, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       dval,\n\t\t\t\t       NULL);\n\t\t\t\tfirst = FALSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t\t       \"%s\", NULL,\n\t\t\t\t       cons(sv, ppc_txt, NOVAL),\n\t\t\t\t       NOVAL,\n\t\t\t\t       dval,\n\t\t\t\t       NULL);\n\t\t\t}\n\t\t}\n\t\tif (isdb && !DISPLAY_HORIZONTALLY(flags)) {\n\t\t\t/* Print a newline chr and make sure that @pre text will be printed next time */\n\t\t\trender(isdb, pre, PT_NEWLIN, NULL, NULL, NULL, NOVAL, NOVAL, NULL);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display swapping statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_swap_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t  int curr, unsigned long long itv)\n{\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr],\n\t\t*ssp = (struct stats_swap *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpswpin/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(ssp->pswpin, ssc->pswpin, itv),\n\t       NULL);\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tpswpout/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(ssp->pswpout, ssc->pswpout, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display paging statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_paging_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr],\n\t\t*spp = (struct stats_paging *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgpgin/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgpgin, spc->pgpgin, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgpgout/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgpgout, spc->pgpgout, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tfault/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgfault, spc->pgfault, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tmajflt/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgmajfault, spc->pgmajfault, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgfree/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgfree, spc->pgfree, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgscank/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgscan_kswapd, spc->pgscan_kswapd, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgscand/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgscan_direct, spc->pgscan_direct, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgsteal/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgsteal, spc->pgsteal, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpgprom/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgpromote, spc->pgpromote, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tpgdem/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(spp->pgdemote, spc->pgdemote, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_io_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\tint curr, unsigned long long itv)\n{\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr],\n\t\t*sip = (struct stats_io *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\t/*\n\t * If we get negative values, this is probably because\n\t * one or more devices/filesystems have been unmounted.\n\t * We display 0.0 in this case though we should rather tell\n\t * the user that the value cannot be calculated here.\n\t */\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\ttps\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive < sip->dk_drive ? 0.0 :\n\t       S_VALUE(sip->dk_drive, sic->dk_drive, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\trtps\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive_rio < sip->dk_drive_rio ? 0.0 :\n\t       S_VALUE(sip->dk_drive_rio, sic->dk_drive_rio, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\twtps\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive_wio < sip->dk_drive_wio ? 0.0 :\n\t       S_VALUE(sip->dk_drive_wio, sic->dk_drive_wio, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tdtps\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive_dio < sip->dk_drive_dio ? 0.0 :\n\t       S_VALUE(sip->dk_drive_dio, sic->dk_drive_dio, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tbread/s\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive_rblk < sip->dk_drive_rblk ? 0.0 :\n\t       S_VALUE(sip->dk_drive_rblk, sic->dk_drive_rblk, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tbwrtn/s\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive_wblk < sip->dk_drive_wblk ? 0.0 :\n\t       S_VALUE(sip->dk_drive_wblk, sic->dk_drive_wblk, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tbdscd/s\", NULL, NULL,\n\t       NOVAL,\n\t       sic->dk_drive_dblk < sip->dk_drive_dblk ? 0.0 :\n\t       S_VALUE(sip->dk_drive_dblk, sic->dk_drive_dblk, itv),\n\t       NULL);\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization in selected format.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries.\n * @dispall\tTRUE if all memory fields should be displayed.\n * @pt_newlin\tRendering flag for last displayed field.\n ***************************************************************************\n */\nvoid render_ram_memory_stats(struct stats_memory *smc, int isdb, char *pre,\n\t\t\t     int dispall, int pt_newlin)\n{\n\tunsigned long long nousedmem;\n\tint ptn;\n\n\tnousedmem = smc->frmkb + smc->bufkb + smc->camkb + smc->slabkb;\n\tif (nousedmem > smc->tlmkb) {\n\t\tnousedmem = smc->tlmkb;\n\t}\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbmemfree\", NULL, NULL, smc->frmkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbavail\", NULL, NULL, smc->availablekb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbmemused\", NULL, NULL, smc->tlmkb - nousedmem, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%memused\", NULL, NULL, NOVAL,\n\t       smc->tlmkb ? SP_VALUE(nousedmem, smc->tlmkb, smc->tlmkb)\n\t\t\t  : 0.0,\n\t       NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbbuffers\", NULL, NULL, smc->bufkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbcached\", NULL, NULL, smc->camkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbcommit\", NULL, NULL, smc->comkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%commit\", NULL, NULL, NOVAL,\n\t       (smc->tlmkb + smc->tlskb) ? SP_VALUE(0, smc->comkb, smc->tlmkb + smc->tlskb)\n\t\t\t\t\t : 0.0,\n\t       NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbactive\", NULL, NULL, smc->activekb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbinact\", NULL, NULL, smc->inactkb, DNOVAL, NULL);\n\n\tptn = dispall ? 0 : pt_newlin;\n\trender(isdb, pre, PT_USEINT | ptn,\n\t       \"-\\tkbdirty\", NULL, NULL, smc->dirtykb, DNOVAL, NULL);\n\n\tif (dispall) {\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"-\\tkbanonpg\", NULL, NULL, smc->anonpgkb, DNOVAL, NULL);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"-\\tkbslab\", NULL, NULL, smc->slabkb, DNOVAL, NULL);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"-\\tkbkstack\", NULL, NULL, smc->kstackkb, DNOVAL, NULL);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"-\\tkbpgtbl\", NULL, NULL, smc->pgtblkb, DNOVAL, NULL);\n\n\t\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t\t       \"-\\tkbvmused\", NULL, NULL, smc->vmusedkb, DNOVAL, NULL);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization in selected format.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries.\n * @pt_newlin\tRendering flag for last displayed field.\n ***************************************************************************\n */\nvoid render_swap_memory_stats(struct stats_memory *smc, int isdb, char *pre,\n\t\t\t      int pt_newlin)\n{\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbswpfree\", NULL, NULL, smc->frskb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbswpused\", NULL, NULL, smc->tlskb - smc->frskb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%swpused\", NULL, NULL, NOVAL,\n\t       smc->tlskb ? SP_VALUE(smc->frskb, smc->tlskb, smc->tlskb)\n\t\t\t  : 0.0,\n\t       NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbswpcad\", NULL, NULL, smc->caskb, DNOVAL, NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\t%swpcad\", NULL, NULL, NOVAL,\n\t       (smc->tlskb - smc->frskb) ? SP_VALUE(0, smc->caskb, smc->tlskb - smc->frskb)\n\t\t\t\t\t : 0.0,\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display memory and swap statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_memory_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\trender_ram_memory_stats(smc, isdb, pre, DISPLAY_MEM_ALL(a->opt_flags), pt_newlin);\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\trender_swap_memory_stats(smc, isdb, pre, pt_newlin);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_ktables_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tdentunusd\", NULL, NULL,\n\t       skc->dentry_stat, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tfile-nr\", NULL, NULL,\n\t       skc->file_used, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tinode-nr\", NULL, NULL,\n\t       skc->inode_used, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t       \"-\\tpty-nr\", NULL, NULL,\n\t       skc->pty_nr, DNOVAL, NULL);\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_queue_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t   int curr, unsigned long long itv)\n{\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\trunq-sz\", NULL, NULL,\n\t       sqc->nr_running, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tplist-sz\", NULL, NULL,\n\t       sqc->nr_threads, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tldavg-1\", NULL, NULL,\n\t       NOVAL,\n\t       (double) sqc->load_avg_1 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tldavg-5\", NULL, NULL,\n\t       NOVAL,\n\t       (double) sqc->load_avg_5 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tldavg-15\", NULL, NULL,\n\t       NOVAL,\n\t       (double) sqc->load_avg_15 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t       \"-\\tblocked\", NULL, NULL,\n\t       sqc->procs_blocked, DNOVAL, NULL);\n}\n\n/*\n ***************************************************************************\n * Display serial lines statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_serial_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_serial *ssc, *ssp;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\tssc = (struct stats_serial *) ((char *) a->buf[curr]  + i * a->msize);\n\n\t\t\t/* Look for corresponding serial line in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tssp = (struct stats_serial *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (ssc->line == ssp->line) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"ttyS%d\\trcvin/s\", \"%d\",\n\t\t       cons(iv, ssc->line, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(ssp->rx, ssc->rx, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"ttyS%d\\txmtin/s\", NULL,\n\t\t       cons(iv, ssc->line, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(ssp->tx, ssc->tx, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"ttyS%d\\tframerr/s\", NULL,\n\t\t       cons(iv, ssc->line, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(ssp->frame, ssc->frame, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"ttyS%d\\tprtyerr/s\", NULL,\n\t\t       cons(iv, ssc->line, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(ssp->parity, ssc->parity, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"ttyS%d\\tbrk/s\", NULL,\n\t\t       cons(iv, ssc->line, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(ssp->brk, ssc->brk, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"ttyS%d\\tovrun/s\", NULL,\n\t\t       cons(iv, ssc->line, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(ssp->overrun, ssc->overrun, itv),\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display disks statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_disk_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t  int curr, unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_disk *sdc,\t*sdp, sdpzero;\n\tstruct ext_disk_stats xds;\n\tchar *dev_name;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tmemset(&sdpzero, 0, STATS_DISK_SIZE);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tj = check_disk_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsdp = &sdpzero;\n\t\t}\n\t\telse {\n\t\t\tsdp = (struct stats_disk *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\t/* Get device name */\n\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Compute extended stats (service time, etc.) */\n\t\tcompute_ext_disk_stats(sdc, sdp, itv, &xds);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttps\", \"%s\",\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sdp->nr_ios, sdc->nr_ios, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trkB/s\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sdp->rd_sect, sdc->rd_sect, itv) / 2,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\twkB/s\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sdp->wr_sect, sdc->wr_sect, itv) / 2,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\tdkB/s\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sdp->dc_sect, sdc->dc_sect, itv) / 2,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\tareq-sz\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       xds.arqsz / 2,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\taqu-sz\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\tawait\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       xds.await,\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"%s\\t%%util\", NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       xds.util / 10.0,\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_dev_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_dev *sndc, *sndp, sndzero;\n\tdouble rxkb, txkb, ifutil;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tmemset(&sndzero, 0, STATS_NET_DEV_SIZE);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tj = check_net_dev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsndp = &sndzero;\n\t\t}\n\t\telse {\n\t\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxpck/s\", \"%s\",\n\t\t       cons(sv, sndc->interface, NOVAL), /* What if the format args are strings? */\n\t\t       NOVAL,\n\t\t       S_VALUE(sndp->rx_packets, sndc->rx_packets, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttxpck/s\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sndp->tx_packets, sndc->tx_packets, itv),\n\t\t       NULL);\n\n\t\trxkb = S_VALUE(sndp->rx_bytes, sndc->rx_bytes, itv);\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxkB/s\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       rxkb / 1024,\n\t\t       NULL);\n\n\t\ttxkb = S_VALUE(sndp->tx_bytes, sndc->tx_bytes, itv);\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttxkB/s\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       txkb / 1024,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxcmp/s\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sndp->rx_compressed, sndc->rx_compressed, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttxcmp/s\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sndp->tx_compressed, sndc->tx_compressed, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxmcst/s\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sndp->multicast, sndc->multicast, itv),\n\t\t       NULL);\n\n\t\tifutil = compute_ifutil(sndc, rxkb, txkb);\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"%s\\t%%ifutil\", NULL,\n\t\t       cons(sv, sndc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       ifutil,\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interface errors statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_edev_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_edev *snedc, *snedp, snedzero;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tmemset(&snedzero, 0, STATS_NET_EDEV_SIZE);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tj = check_net_edev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsnedp = &snedzero;\n\t\t}\n\t\telse {\n\t\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxerr/s\", \"%s\",\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->rx_errors, snedc->rx_errors, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttxerr/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->tx_errors, snedc->tx_errors, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\tcoll/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->collisions, snedc->collisions, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxdrop/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->rx_dropped, snedc->rx_dropped, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttxdrop/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->tx_dropped, snedc->tx_dropped, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\ttxcarr/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->tx_carrier_errors, snedc->tx_carrier_errors, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxfram/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->rx_frame_errors, snedc->rx_frame_errors, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\trxfifo/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->rx_fifo_errors, snedc->rx_fifo_errors, itv),\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"%s\\ttxfifo/s\", NULL,\n\t\t       cons(sv, snedc->interface, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(snedp->tx_fifo_errors, snedc->tx_fifo_errors, itv),\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_nfs_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr],\n\t\t*snnp = (struct stats_net_nfs *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tcall/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snnp->nfs_rpccnt, snnc->nfs_rpccnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tretrans/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snnp->nfs_rpcretrans, snnc->nfs_rpcretrans, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tread/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snnp->nfs_readcnt, snnc->nfs_readcnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\twrite/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snnp->nfs_writecnt, snnc->nfs_writecnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\taccess/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snnp->nfs_accesscnt, snnc->nfs_accesscnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tgetatt/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snnp->nfs_getattcnt, snnc->nfs_getattcnt, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_nfsd_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr],\n\t\t*snndp = (struct stats_net_nfsd *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tscall/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_rpccnt, snndc->nfsd_rpccnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tbadcall/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_rpcbad, snndc->nfsd_rpcbad, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpacket/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_netcnt, snndc->nfsd_netcnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tudp/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_netudpcnt, snndc->nfsd_netudpcnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\ttcp/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_nettcpcnt, snndc->nfsd_nettcpcnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\thit/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_rchits, snndc->nfsd_rchits, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tmiss/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_rcmisses, snndc->nfsd_rcmisses, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tsread/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_readcnt, snndc->nfsd_readcnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tswrite/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_writecnt, snndc->nfsd_writecnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tsaccess/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_accesscnt, snndc->nfsd_accesscnt, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tsgetatt/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snndp->nfsd_getattcnt, snndc->nfsd_getattcnt, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display network sockets statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_sock_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\ttotsck\", NULL, NULL,\n\t       (unsigned long long) snsc->sock_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\ttcpsck\", NULL, NULL,\n\t       (unsigned long long) snsc->tcp_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tudpsck\",  NULL, NULL,\n\t       (unsigned long long) snsc->udp_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\trawsck\", NULL, NULL,\n\t       (unsigned long long) snsc->raw_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tip-frag\", NULL, NULL,\n\t       (unsigned long long) snsc->frag_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t       \"-\\ttcp-tw\", NULL, NULL,\n\t       (unsigned long long) snsc->tcp_tw, DNOVAL, NULL);\n}\n\n/*\n ***************************************************************************\n * Display IP network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_ip_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tirec/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InReceives, snic->InReceives, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tfwddgm/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->ForwDatagrams, snic->ForwDatagrams, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidel/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InDelivers, snic->InDelivers, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\torq/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutRequests, snic->OutRequests, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tasmrq/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->ReasmReqds, snic->ReasmReqds, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tasmok/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->ReasmOKs, snic->ReasmOKs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tfragok/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->FragOKs, snic->FragOKs, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tfragcrt/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->FragCreates, snic->FragCreates, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display IP network errors statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_eip_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tihdrerr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InHdrErrors, sneic->InHdrErrors, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiadrerr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InAddrErrors, sneic->InAddrErrors, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiukwnpr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InUnknownProtos, sneic->InUnknownProtos, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidisc/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InDiscards, sneic->InDiscards, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\todisc/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutDiscards, sneic->OutDiscards, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tonort/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutNoRoutes, sneic->OutNoRoutes, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tasmf/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->ReasmFails, sneic->ReasmFails, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tfragf/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->FragFails, sneic->FragFails, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display ICMP network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_icmp_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\timsg/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InMsgs, snic->InMsgs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tomsg/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutMsgs, snic->OutMsgs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiech/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InEchos, snic->InEchos, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiechr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InEchoReps, snic->InEchoReps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toech/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutEchos, snic->OutEchos, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toechr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutEchoReps, snic->OutEchoReps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\titm/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InTimestamps, snic->InTimestamps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\titmr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InTimestampReps, snic->InTimestampReps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\totm/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutTimestamps, snic->OutTimestamps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\totmr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutTimestampReps, snic->OutTimestampReps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiadrmk/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InAddrMasks, snic->InAddrMasks, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiadrmkr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InAddrMaskReps, snic->InAddrMaskReps, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toadrmk/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutAddrMasks, snic->OutAddrMasks, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\toadrmkr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutAddrMaskReps, snic->OutAddrMaskReps, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display ICMP error messages statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_eicmp_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t       int curr, unsigned long long itv)\n{\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tierr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InErrors, sneic->InErrors, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toerr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutErrors, sneic->OutErrors, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidstunr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InDestUnreachs, sneic->InDestUnreachs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\todstunr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutDestUnreachs, sneic->OutDestUnreachs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\titmex/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InTimeExcds, sneic->InTimeExcds, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\totmex/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutTimeExcds, sneic->OutTimeExcds, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiparmpb/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InParmProbs, sneic->InParmProbs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toparmpb/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutParmProbs, sneic->OutParmProbs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tisrcq/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InSrcQuenchs, sneic->InSrcQuenchs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tosrcq/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutSrcQuenchs, sneic->OutSrcQuenchs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiredir/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InRedirects, sneic->InRedirects, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\toredir/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutRedirects, sneic->OutRedirects, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display TCP network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_tcp_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr],\n\t\t*sntp = (struct stats_net_tcp *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tactive/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sntp->ActiveOpens, sntc->ActiveOpens, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tpassive/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sntp->PassiveOpens, sntc->PassiveOpens, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiseg/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sntp->InSegs, sntc->InSegs, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\toseg/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sntp->OutSegs, sntc->OutSegs, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display TCP network errors statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_etcp_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr],\n\t\t*snetp = (struct stats_net_etcp *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tatmptf/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snetp->AttemptFails, snetc->AttemptFails, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\testres/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snetp->EstabResets, snetc->EstabResets, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tretrseg/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snetp->RetransSegs, snetc->RetransSegs, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tisegerr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snetp->InErrs, snetc->InErrs, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\torsts/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snetp->OutRsts, snetc->OutRsts, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display UDP network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_udp_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidgm/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->InDatagrams, snuc->InDatagrams, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\todgm/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->OutDatagrams, snuc->OutDatagrams, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tnoport/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->NoPorts, snuc->NoPorts, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tidgmerr/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->InErrors, snuc->InErrors, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network sockets statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_sock6_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t       int curr, unsigned long long itv)\n{\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\ttcp6sck\", NULL, NULL,\n\t       (unsigned long long) snsc->tcp6_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tudp6sck\",  NULL, NULL,\n\t       (unsigned long long) snsc->udp6_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\traw6sck\", NULL, NULL,\n\t       (unsigned long long) snsc->raw6_inuse, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t       \"-\\tip6-frag\", NULL, NULL,\n\t       (unsigned long long) snsc->frag6_inuse, DNOVAL, NULL);\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_ip6_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip6 *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tirec6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InReceives6, snic->InReceives6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tfwddgm6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutForwDatagrams6, snic->OutForwDatagrams6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidel6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InDelivers6, snic->InDelivers6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\torq6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutRequests6, snic->OutRequests6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tasmrq6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->ReasmReqds6, snic->ReasmReqds6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tasmok6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->ReasmOKs6, snic->ReasmOKs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\timcpck6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InMcastPkts6, snic->InMcastPkts6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tomcpck6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutMcastPkts6, snic->OutMcastPkts6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tfragok6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->FragOKs6, snic->FragOKs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tfragcr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->FragCreates6, snic->FragCreates6, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network errors statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_eip6_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip6 *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tihdrer6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InHdrErrors6, sneic->InHdrErrors6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiadrer6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InAddrErrors6, sneic->InAddrErrors6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiukwnp6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InUnknownProtos6, sneic->InUnknownProtos6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\ti2big6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InTooBigErrors6, sneic->InTooBigErrors6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidisc6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InDiscards6, sneic->InDiscards6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\todisc6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutDiscards6, sneic->OutDiscards6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tinort6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InNoRoutes6, sneic->InNoRoutes6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tonort6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutNoRoutes6, sneic->OutNoRoutes6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tasmf6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->ReasmFails6, sneic->ReasmFails6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tfragf6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->FragFails6, sneic->FragFails6, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\titrpck6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InTruncatedPkts6, sneic->InTruncatedPkts6, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_icmp6_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t       int curr, unsigned long long itv)\n{\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp6 *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\timsg6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InMsgs6, snic->InMsgs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tomsg6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutMsgs6, snic->OutMsgs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiech6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InEchos6, snic->InEchos6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiechr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InEchoReplies6, snic->InEchoReplies6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toechr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutEchoReplies6, snic->OutEchoReplies6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tigmbq6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InGroupMembQueries6, snic->InGroupMembQueries6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tigmbr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InGroupMembResponses6, snic->InGroupMembResponses6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\togmbr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutGroupMembResponses6, snic->OutGroupMembResponses6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tigmbrd6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InGroupMembReductions6, snic->InGroupMembReductions6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\togmbrd6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutGroupMembReductions6, snic->OutGroupMembReductions6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tirtsol6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InRouterSolicits6, snic->InRouterSolicits6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tortsol6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutRouterSolicits6, snic->OutRouterSolicits6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tirtad6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InRouterAdvertisements6, snic->InRouterAdvertisements6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tinbsol6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InNeighborSolicits6, snic->InNeighborSolicits6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tonbsol6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutNeighborSolicits6, snic->OutNeighborSolicits6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tinbad6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->InNeighborAdvertisements6, snic->InNeighborAdvertisements6, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tonbad6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snip->OutNeighborAdvertisements6, snic->OutNeighborAdvertisements6, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 error messages statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_eicmp6_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t\tint curr, unsigned long long itv)\n{\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp6 *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tierr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InErrors6, sneic->InErrors6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidtunr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InDestUnreachs6, sneic->InDestUnreachs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\todtunr6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutDestUnreachs6, sneic->OutDestUnreachs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\titmex6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InTimeExcds6, sneic->InTimeExcds6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\totmex6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutTimeExcds6, sneic->OutTimeExcds6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiprmpb6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InParmProblems6, sneic->InParmProblems6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toprmpb6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutParmProblems6, sneic->OutParmProblems6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tiredir6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InRedirects6, sneic->InRedirects6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\toredir6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutRedirects6, sneic->OutRedirects6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tipck2b6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->InPktTooBigs6, sneic->InPktTooBigs6, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\topck2b6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(sneip->OutPktTooBigs6, sneic->OutPktTooBigs6, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display UDP6 network statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_net_udp6_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp6 *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tidgm6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->InDatagrams6, snuc->InDatagrams6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\todgm6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->OutDatagrams6, snuc->OutDatagrams6, itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\tnoport6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->NoPorts6, snuc->NoPorts6, itv),\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\tidgmer6/s\", NULL, NULL,\n\t       NOVAL,\n\t       S_VALUE(snup->InErrors6, snuc->InErrors6, itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_cpufreq_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t\t int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_cpufreq *spc;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (!spc->cpufreq)\n\t\t\t/* This CPU is offline: Don't display it */\n\t\t\tcontinue;\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t       \"all\\tMHz\",\n\t\t\t       \"-1\", NULL,\n\t\t\t       NOVAL,\n\t\t\t       ((double) spc->cpufreq) / 100,\n\t\t\t       NULL);\n\t\t}\n\t\telse {\n\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t       \"cpu%d\\tMHz\",\n\t\t\t       \"%d\", cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       ((double) spc->cpufreq) / 100,\n\t\t\t       NULL);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display fan statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_fan_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_fan *spc;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\trender(isdb, pre, PT_USESTR,\n\t\t       \"fan%d\\tDEVICE\",\n\t\t       \"%d\",\n\t\t       cons(iv, i + 1, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       spc->device);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"fan%d\\trpm\",\n\t\t       NULL,\n\t\t       cons(iv, i + 1, NOVAL),\n\t\t       NOVAL,\n\t\t       spc->rpm,\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"fan%d\\tdrpm\",\n\t\t       NULL,\n\t\t       cons(iv, i + 1, NOVAL),\n\t\t       NOVAL,\n\t\t       spc->rpm - spc->rpm_min,\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_temp_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t      int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_temp *spc;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\trender(isdb, pre, PT_USESTR,\n\t\t       \"temp%d\\tDEVICE\",\n\t\t       \"%d\",\n\t\t       cons(iv, i + 1, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       spc->device);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"temp%d\\tdegC\",\n\t\t       NULL,\n\t\t       cons(iv, i + 1, NOVAL),\n\t\t       NOVAL,\n\t\t       spc->temp,\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"temp%d\\t%%temp\",\n\t\t       NULL,\n\t\t       cons(iv, i + 1, NOVAL),\n\t\t       NOVAL,\n\t\t       (spc->temp_max - spc->temp_min) ?\n\t\t       (spc->temp - spc->temp_min) / (spc->temp_max - spc->temp_min) * 100 :\n\t\t       0.0,\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_in_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_in *spc;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\trender(isdb, pre, PT_USESTR,\n\t\t       \"in%d\\tDEVICE\",\n\t\t       \"%d\",\n\t\t       cons(iv, i, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       spc->device);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"in%d\\tinV\",\n\t\t       NULL,\n\t\t       cons(iv, i, NOVAL),\n\t\t       NOVAL,\n\t\t       spc->in,\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"in%d\\t%%in\",\n\t\t       NULL,\n\t\t       cons(iv, i, NOVAL),\n\t\t       NOVAL,\n\t\t       (spc->in_max - spc->in_min) ?\n\t\t       (spc->in - spc->in_min) / (spc->in_max - spc->in_min) * 100 :\n\t\t       0.0,\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_huge_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t  int curr, unsigned long long itv)\n{\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbhugfree\", NULL, NULL,\n\t       smc->frhkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbhugused\", NULL, NULL,\n\t       smc->tlhkb - smc->frhkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%hugused\", NULL, NULL, NOVAL,\n\t       smc->tlhkb ?\n\t       SP_VALUE(smc->frhkb, smc->tlhkb, smc->tlhkb) :\n\t       0.0, NULL);\n\n\trender(isdb, pre, PT_USEINT,\n\t       \"-\\tkbhugrsvd\", NULL, NULL,\n\t       smc->rsvdhkb, DNOVAL, NULL);\n\n\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t       \"-\\tkbhugsurp\", NULL, NULL,\n\t       smc->surphkb, DNOVAL, NULL);\n}\n\n/*\n ***************************************************************************\n * Display weighted CPU frequency statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_wghfreq_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t\t int curr, unsigned long long itv)\n{\n\tint i, k;\n\tstruct stats_pwr_wghfreq *spc, *spp, *spc_k, *spp_k;\n\tunsigned long long tis, tisfreq;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_wghfreq *) ((char *) a->buf[curr]  + i * a->msize * a->nr2);\n\t\tspp = (struct stats_pwr_wghfreq *) ((char *) a->buf[!curr] + i * a->msize * a->nr2);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\ttisfreq = 0;\n\t\ttis = 0;\n\n\t\tfor (k = 0; k < a->nr2; k++) {\n\n\t\t\tspc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * a->msize);\n\t\t\tif (!spc_k->freq)\n\t\t\t\tbreak;\n\t\t\tspp_k = (struct stats_pwr_wghfreq *) ((char *) spp + k * a->msize);\n\n\t\t\ttisfreq += (spc_k->freq / 1000) *\n\t\t\t           (spc_k->time_in_state - spp_k->time_in_state);\n\t\t\ttis     += (spc_k->time_in_state - spp_k->time_in_state);\n\t\t}\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t       \"all\\twghMHz\",\n\t\t\t       \"-1\", NULL,\n\t\t\t       NOVAL,\n\t\t\t       tis ? ((double) tisfreq) / tis : 0.0,\n\t\t\t       NULL);\n\t\t}\n\t\telse {\n\t\t\trender(isdb, pre, pt_newlin,\n\t\t\t       \"cpu%d\\twghMHz\",\n\t\t\t       \"%d\", cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       tis ? ((double) tisfreq) / tis : 0.0,\n\t\t\t       NULL);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display USB devices statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_usb_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_usb *suc;\n\tchar id[9];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsuc = (struct stats_pwr_usb *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tsprintf(id, \"%x\", suc->vendor_id);\n\t\trender(isdb, pre, PT_USESTR,\n\t\t       \"bus%d\\tidvendor\",\n\t\t       \"%d\",\n\t\t       cons(iv, suc->bus_nr, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       id);\n\n\t\tsprintf(id, \"%x\", suc->product_id);\n\t\trender(isdb, pre, PT_USESTR,\n\t\t       \"bus%d\\tidprod\",\n\t\t       NULL,\n\t\t       cons(iv, suc->bus_nr, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       id);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"bus%d\\tmaxpower\",\n\t\t       NULL,\n\t\t       cons(iv, suc->bus_nr, NOVAL),\n\t\t       (unsigned long long) (suc->bmaxpower << 1),\n\t\t       NOVAL,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_USESTR,\n\t\t       \"bus%d\\tmanufact\",\n\t\t       NULL,\n\t\t       cons(iv, suc->bus_nr, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       suc->manufacturer);\n\n\t\trender(isdb, pre,\n\t\t       (DISPLAY_HORIZONTALLY(flags) ? PT_USESTR : PT_USESTR | PT_NEWLIN),\n\t\t       \"bus%d\\tproduct\",\n\t\t       NULL,\n\t\t       cons(iv, suc->bus_nr, NOVAL),\n\t\t       NOVAL,\n\t\t       NOVAL,\n\t\t       suc->product);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display filesystems statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_filesystem_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t\tint curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_filesystem *sfc;\n\tchar *dev_name;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\trender(isdb, pre, PT_USERND,\n\t\t       \"%s\\tMBfsfree\",\n\t\t       \"%s\",\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       (double) sfc->f_bfree / 1024 / 1024,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_USERND,\n\t\t       \"%s\\tMBfsused\",\n\t\t       NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       (double) (sfc->f_blocks - sfc->f_bfree) / 1024 / 1024,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\t%%fsused\",\n\t\t       NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       sfc->f_blocks ? SP_VALUE(sfc->f_bfree, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t     : 0.0,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\t%%ufsused\",\n\t\t       NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       sfc->f_blocks ? SP_VALUE(sfc->f_bavail, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t     : 0.0,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"%s\\tIfree\",\n\t\t       NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       sfc->f_ffree,\n\t\t       NOVAL,\n\t\t       NULL);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"%s\\tIused\",\n\t\t       NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       sfc->f_files - sfc->f_ffree,\n\t\t       NOVAL,\n\t\t       NULL);\n\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"%s\\t%%Iused\",\n\t\t       NULL,\n\t\t       cons(sv, dev_name, NOVAL),\n\t\t       NOVAL,\n\t\t       sfc->f_files ? SP_VALUE(sfc->f_ffree, sfc->f_files, sfc->f_files)\n\t\t\t\t    : 0.0,\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_fchost_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_fchost *sfcc, *sfcp, sfczero;\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tmemset(&sfczero, 0, sizeof(struct stats_fchost));\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\t/* Look for corresponding structure in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (!strcmp(sfcc->fchost_name, sfcp->fchost_name)) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tif (!found) {\n\t\t\t/* This is a newly registered host */\n\t\t\tsfcp = &sfczero;\n\t\t}\n\n\t\trender(isdb, pre, PT_NOFLAG ,\n\t\t       \"%s\\tfch_rxf/s\",\n\t\t       \"%s\",\n\t\t       cons(sv, sfcc->fchost_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sfcp->f_rxframes, sfcc->f_rxframes, itv),\n\t               NULL);\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\tfch_txf/s\", NULL,\n\t\t       cons(sv, sfcc->fchost_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sfcp->f_txframes, sfcc->f_txframes, itv),\n\t\t       NULL);\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"%s\\tfch_rxw/s\", NULL,\n\t\t       cons(sv, sfcc->fchost_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sfcp->f_rxwords, sfcc->f_rxwords, itv),\n\t\t       NULL);\n\t\trender(isdb, pre, pt_newlin,\n\t\t       \"%s\\tfch_txw/s\", NULL,\n\t\t       cons(sv, sfcc->fchost_name, NOVAL),\n\t\t       NOVAL,\n\t\t       S_VALUE(sfcp->f_txwords, sfcc->f_txwords, itv),\n\t\t       NULL);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_softnet_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_softnet *ssnc, *ssnp;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Compute statistics for CPU \"all\" */\n\tget_global_soft_statistics(a, !curr, curr, flags, offline_cpu_bitmap);\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * Note: a->nr is in [1, NR_CPUS + 1].\n\t\t * Bitmap size is provided for (NR_CPUS + 1) CPUs.\n\t\t * Anyway, NR_CPUS may vary between the version of sysstat\n\t\t * used by sadc to create a file, and the version of sysstat\n\t\t * used by sar to read it...\n\t\t */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_pwr_cpufreq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * ssnc = (struct stats_softnet *) a->buf[...] + i;\n                 */\n                ssnc = (struct stats_softnet *) ((char *) a->buf[curr]  + i * a->msize);\n                ssnp = (struct stats_softnet *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\ttotal/s\",\n\t\t\t       \"-1\", NULL,\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->processed, ssnc->processed, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\tdropd/s\",\n\t\t\t       NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->dropped, ssnc->dropped, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\tsqueezd/s\",\n\t\t\t       NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->time_squeeze, ssnc->time_squeeze, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\trx_rps/s\",\n\t\t\t       NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->received_rps, ssnc->received_rps, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"all\\tflw_lim/s\",\n\t\t\t       NULL, NULL,\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->flow_limit, ssnc->flow_limit, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t\t\t       \"all\\tblg_len\",\n\t\t\t       NULL, NULL,\n\t\t\t       ssnc->backlog_len,\n\t\t\t       DNOVAL,\n\t\t\t       NULL);\n\t\t}\n\t\telse {\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\ttotal/s\",\n\t\t\t       \"%d\", cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->processed, ssnc->processed, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\tdropd/s\",\n\t\t\t       NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->dropped, ssnc->dropped, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\tsqueezd/s\",\n\t\t\t       NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->time_squeeze, ssnc->time_squeeze, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\trx_rps/s\",\n\t\t\t       NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->received_rps, ssnc->received_rps, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_NOFLAG,\n\t\t\t       \"cpu%d\\tflw_lim/s\",\n\t\t\t       NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       NOVAL,\n\t\t\t       S_VALUE(ssnp->flow_limit, ssnc->flow_limit, itv),\n\t\t\t       NULL);\n\n\t\t\trender(isdb, pre, PT_USEINT | pt_newlin,\n\t\t\t       \"cpu%d\\tblg_len\",\n\t\t\t       NULL, cons(iv, i - 1, NOVAL),\n\t\t\t       ssnc->backlog_len,\n\t\t\t       DNOVAL,\n\t\t\t       NULL);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_psicpu_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr],\n\t\t*psip = (struct stats_psi_cpu *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%scpu-10\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_acpu_10 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%scpu-60\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_acpu_60 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%scpu-300\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_acpu_300 / 100,\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\t%scpu\", NULL, NULL,\n\t       NOVAL,\n\t       ((double) psic->some_cpu_total - psip->some_cpu_total) / (100 * itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_psiio_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t   int curr, unsigned long long itv)\n{\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr],\n\t\t*psip = (struct stats_psi_io *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%sio-10\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_aio_10 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%sio-60\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_aio_60 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%sio-300\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_aio_300 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%sio\", NULL, NULL,\n\t       NOVAL,\n\t       ((double) psic->some_io_total - psip->some_io_total) / (100 * itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%fio-10\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->full_aio_10 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%fio-60\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->full_aio_60 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%fio-300\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->full_aio_300 / 100,\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\t%fio\", NULL, NULL,\n\t       NOVAL,\n\t       ((double) psic->full_io_total - psip->full_io_total) / (100 * itv),\n\t       NULL);\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_psimem_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t    int curr, unsigned long long itv)\n{\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr],\n\t\t*psip = (struct stats_psi_mem *) a->buf[!curr];\n\tint pt_newlin\n\t\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%smem-10\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_amem_10 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%smem-60\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_amem_60 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%smem-300\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->some_amem_300 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%smem\", NULL, NULL,\n\t       NOVAL,\n\t       ((double) psic->some_mem_total - psip->some_mem_total) / (100 * itv),\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%fmem-10\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->full_amem_10 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%fmem-60\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->full_amem_60 / 100,\n\t       NULL);\n\n\trender(isdb, pre, PT_NOFLAG,\n\t       \"-\\t%fmem-300\", NULL, NULL,\n\t       NOVAL,\n\t       (double) psic->full_amem_300 / 100,\n\t       NULL);\n\n\trender(isdb, pre, pt_newlin,\n\t       \"-\\t%fmem\", NULL, NULL,\n\t       NOVAL,\n\t       ((double) psic->full_mem_total - psip->full_mem_total) / (100 * itv),\n\t       NULL);\n}\n\n/*\n * **************************************************************************\n * Display battery statistics in selected format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @isdb\tFlag, true if db printing, false if ppc printing.\n * @pre\t\tPrefix string for output entries\n * @curr\tIndex in array for current sample statistics.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t render_pwr_bat_stats(struct activity *a, int isdb, char *pre,\n\t\t\t\t     int curr, unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_bat *spbc, *spbp;\n\tint pt_newlin\n\t= PT_NOFLAG + (DISPLAY_HORIZONTALLY(flags) ? 0 : PT_NEWLIN);\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\t\tspbp = (struct stats_pwr_bat *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\trender(isdb, pre, PT_USEINT,\n\t\t       \"BAT%d\\t%%cap\", \"%d\",\n\t\t       cons(iv, spbc->bat_id, NOVAL),\n\t\t       (unsigned int) spbc->capacity,\n\t\t       NOVAL, NULL);\n\n\t\trender(isdb, pre, PT_NOFLAG,\n\t\t       \"BAT%d\\tcap/min\", NULL,\n\t\t       cons(iv, spbc->bat_id, NOVAL),\n\t\t       NOVAL,\n\t\t       (double) (spbc->capacity - spbp->capacity) * 6000 / itv,\n\t\t       NULL);\n\n\t\t/* Battery status code should not be greater than or equal to BAT_STS_NR */\n\t\tif (spbc->status >= BAT_STS_NR) {\n\t\t\tspbc->status = 0;\n\t\t}\n\t\trender(isdb, pre, PT_USESTR | pt_newlin,\n\t\t       \"BAT%d\\tstatus\", NULL,\n\t\t       cons(iv, spbc->bat_id, NOVAL),\n\t\t       NOVAL, NOVAL,\n\t\t       bat_status[(unsigned int) spbc->status]);\n\t}\n}\n"
        },
        {
          "name": "rndr_stats.h",
          "type": "blob",
          "size": 5.541015625,
          "content": "/*\n * rndr_stats.h: Include file used to display system statistics in selected format.\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _RNDR_STATS_H\n#define _RNDR_STATS_H\n\n#include \"common.h\"\n\n/*\n ***************************************************************************\n * Definitions for functions used by sadf.\n ***************************************************************************\n */\n\n#define PT_USEINT  0x0001\t/* Use the integer arg, not double nor string */\n#define PT_NEWLIN  0x0002\t/* Terminate the current output line */\n#define PT_USESTR  0x0004\t/* Use the string arg */\n#define PT_USERND  0x0008\t/* Double value, format %.0f */\n#define PT_NOFLAG  0x0010\t/* Prevent undescribed '0' in render calls */\n\n#define NOVAL      0\t\t/* For placeholder zeros */\n#define DNOVAL     0.0\t\t/* Wilma!  */\n\n/*\n * Conses are used to type independent passing\n * of variable optional data into our rendering routine.\n */\n\ntypedef enum e_tcons {iv, sv} tcons; /* Types of conses */\n\ntypedef struct {\n\ttcons t;\t\t/* Type in {iv,sv} */\n\tunion {\n\t\tunsigned long int i;\n\t\tchar *s;\n\t} a, b;\t\t\t/* Value pair, either ints or char *s */\n} Cons;\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display system statistics in selected\n * format.\n ***************************************************************************\n */\n\n/* Functions used to display statistics in the format selected by sadf */\n__print_funct_t render_pcsw_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_cpu_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_irq_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_swap_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_paging_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_io_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_memory_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_ktables_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_queue_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_serial_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_disk_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_dev_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_edev_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_nfs_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_nfsd_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_sock_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_ip_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_eip_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_icmp_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_eicmp_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_tcp_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_etcp_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_udp_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_sock6_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_ip6_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_eip6_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_icmp6_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_eicmp6_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_net_udp6_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_cpufreq_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_fan_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_temp_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_in_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_huge_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_wghfreq_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_usb_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_filesystem_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_fchost_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_softnet_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_psicpu_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_psiio_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_psimem_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n__print_funct_t render_pwr_bat_stats\n\t(struct activity *, int, char *, int, unsigned long long);\n\n#endif /* _RNDR_STATS_H */\n"
        },
        {
          "name": "sa.h",
          "type": "blob",
          "size": 51.58203125,
          "content": "/*\n * sar/sadc: Report system activity\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _SA_H\n#define _SA_H\n\n#include <stdio.h>\n\n#include \"common.h\"\n#include \"rd_stats.h\"\n#include \"rd_sensors.h\"\n\n/*\n ***************************************************************************\n * Activity identification values.\n ***************************************************************************\n */\n\n/* Number of activities */\n#define NR_ACT\t\t43\n/* The value below is used for sanity check */\n#define MAX_NR_ACT\t256\n\n/* Number of functions used to count items */\n#define NR_F_COUNT\t14\n\n/* Activities */\nenum {\n\tA_CPU \t\t= 1,\n\tA_PCSW\t\t= 2,\n\tA_IRQ\t\t= 3,\n\tA_SWAP\t\t= 4,\n\tA_PAGE\t\t= 5,\n\tA_IO\t\t= 6,\n\tA_MEMORY\t= 7,\n\tA_KTABLES\t= 8,\n\tA_QUEUE\t\t= 9,\n\tA_SERIAL\t= 10,\n\tA_DISK\t\t= 11,\n\tA_NET_DEV\t= 12,\n\tA_NET_EDEV\t= 13,\n\tA_NET_NFS\t= 14,\n\tA_NET_NFSD\t= 15,\n\tA_NET_SOCK\t= 16,\n\tA_NET_IP\t= 17,\n\tA_NET_EIP\t= 18,\n\tA_NET_ICMP\t= 19,\n\tA_NET_EICMP\t= 20,\n\tA_NET_TCP\t= 21,\n\tA_NET_ETCP\t= 22,\n\tA_NET_UDP\t= 23,\n\tA_NET_SOCK6\t= 24,\n\tA_NET_IP6\t= 25,\n\tA_NET_EIP6\t= 26,\n\tA_NET_ICMP6\t= 27,\n\tA_NET_EICMP6\t= 28,\n\tA_NET_UDP6\t= 29,\n\tA_PWR_CPU\t= 30,\n\tA_PWR_FAN\t= 31,\n\tA_PWR_TEMP\t= 32,\n\tA_PWR_IN\t= 33,\n\tA_HUGE\t\t= 34,\n\tA_PWR_FREQ\t= 35,\n\tA_PWR_USB\t= 36,\n\tA_FS\t\t= 37,\n\tA_NET_FC\t= 38,\n\tA_NET_SOFT\t= 39,\n\tA_PSI_CPU\t= 40,\n\tA_PSI_IO\t= 41,\n\tA_PSI_MEM\t= 42,\n\tA_PWR_BAT\t= 43\n};\n\n/* Macro used to flag an activity that should be collected */\n#define COLLECT_ACTIVITY(m)\tact[get_activity_position(act, m, EXIT_IF_NOT_FOUND)]->options |= AO_COLLECTED\n\n/* Macro used to flag an activity that should be selected */\n#define SELECT_ACTIVITY(m)\tact[get_activity_position(act, m, EXIT_IF_NOT_FOUND)]->options |= AO_SELECTED\n\n\n/*\n ***************************************************************************\n * Flags.\n ***************************************************************************\n */\n\n#define S_F_SINCE_BOOT\t\t0x00000001\n#define S_F_SA_ROTAT      \t0x00000002\t/* Only used by sadc */\n#define S_F_DEV_SID\t\t0x00000002\t/* Only used by sar/sadf */\n#define S_F_PRETTY\t\t0x00000004\n#define S_F_FORCE_FILE\t\t0x00000008\n#define S_F_INTERVAL_SET\t0x00000010\n#define S_F_TRUE_TIME\t\t0x00000020\n#define S_F_LOCK_FILE\t\t0x00000040\n#define S_F_SEC_EPOCH\t\t0x00000080\n#define S_F_HDR_ONLY\t\t0x00000100\n#define S_F_FILE_LOCKED\t\t0x00000200\n#define S_F_SA_YYYYMMDD\t\t0x00000400\n#define S_F_HORIZONTALLY\t0x00000800\n#define S_F_COMMENT\t\t0x00001000\n#define S_F_PERSIST_NAME\t0x00002000\n#define S_F_LOCAL_TIME\t\t0x00004000\n#define S_F_PREFD_TIME_OUTPUT\t0x00008000\n#define S_F_SVG_SKIP\t\t0x00010000\n#define S_F_SVG_AUTOSCALE\t0x00020000\n#define S_F_SVG_ONE_DAY\t\t0x00040000\n#define S_F_SVG_SHOW_IDLE\t0x00080000\n#define S_F_UNIT\t\t0x00100000\n#define S_F_SVG_HEIGHT\t\t0x00200000\n#define S_F_SVG_PACKED\t\t0x00400000\n#define S_F_SVG_SHOW_INFO\t0x00800000\n#define S_F_MINMAX\t\t0x01000000\n#define S_F_ZERO_OMIT\t\t0x02000000\n#define S_F_SVG_SHOW_TOC\t0x04000000\n#define S_F_FDATASYNC\t\t0x08000000\n#define S_F_OPTION_A\t\t0x10000000\n#define S_F_OPTION_P\t\t0x20000000\n#define S_F_OPTION_I\t\t0x40000000\n#define S_F_DEBUG_MODE\t\t0x80000000\n\n#define WANT_SINCE_BOOT(m)\t\t(((m) & S_F_SINCE_BOOT)   == S_F_SINCE_BOOT)\n#define WANT_SA_ROTAT(m)\t\t(((m) & S_F_SA_ROTAT)     == S_F_SA_ROTAT)\n#define USE_STABLE_ID(m)\t\t(((m) & S_F_DEV_SID)      == S_F_DEV_SID)\n#define DISPLAY_PRETTY(m)\t\t(((m) & S_F_PRETTY)       == S_F_PRETTY)\n#define FORCE_FILE(m)\t\t\t(((m) & S_F_FORCE_FILE)   == S_F_FORCE_FILE)\n#define INTERVAL_SET(m)\t\t\t(((m) & S_F_INTERVAL_SET) == S_F_INTERVAL_SET)\n#define PRINT_TRUE_TIME(m)\t\t(((m) & S_F_TRUE_TIME)    == S_F_TRUE_TIME)\n#define LOCK_FILE(m)\t\t\t(((m) & S_F_LOCK_FILE)    == S_F_LOCK_FILE)\n#define PRINT_SEC_EPOCH(m)\t\t(((m) & S_F_SEC_EPOCH)    == S_F_SEC_EPOCH)\n#define DISPLAY_HDR_ONLY(m)\t\t(((m) & S_F_HDR_ONLY)     == S_F_HDR_ONLY)\n#define FILE_LOCKED(m)\t\t\t(((m) & S_F_FILE_LOCKED)  == S_F_FILE_LOCKED)\n#define USE_SA_YYYYMMDD(m)\t\t(((m) & S_F_SA_YYYYMMDD)  == S_F_SA_YYYYMMDD)\n#define DISPLAY_HORIZONTALLY(m)\t\t(((m) & S_F_HORIZONTALLY) == S_F_HORIZONTALLY)\n#define DISPLAY_COMMENT(m)\t\t(((m) & S_F_COMMENT)      == S_F_COMMENT)\n#define DISPLAY_PERSIST_NAME_S(m)\t(((m) & S_F_PERSIST_NAME) == S_F_PERSIST_NAME)\n#define PRINT_LOCAL_TIME(m)\t\t(((m) & S_F_LOCAL_TIME)   == S_F_LOCAL_TIME)\n#define USE_PREFD_TIME_OUTPUT(m)\t(((m) & S_F_PREFD_TIME_OUTPUT)   == S_F_PREFD_TIME_OUTPUT)\n#define SKIP_EMPTY_VIEWS(m)\t\t(((m) & S_F_SVG_SKIP)     == S_F_SVG_SKIP)\n#define DISPLAY_ZERO_OMIT(m)\t\t(((m) & S_F_ZERO_OMIT)    == S_F_ZERO_OMIT)\n#define DISPLAY_DEBUG_MODE(m)\t\t(((m) & S_F_DEBUG_MODE)   == S_F_DEBUG_MODE)\n#define AUTOSCALE_ON(m)\t\t\t(((m) & S_F_SVG_AUTOSCALE) == S_F_SVG_AUTOSCALE)\n#define DISPLAY_ONE_DAY(m)\t\t(((m) & S_F_SVG_ONE_DAY)  == S_F_SVG_ONE_DAY)\n#define DISPLAY_IDLE(m)\t\t\t(((m) & S_F_SVG_SHOW_IDLE) == S_F_SVG_SHOW_IDLE)\n#define DISPLAY_INFO(m)\t\t\t(((m) & S_F_SVG_SHOW_INFO) == S_F_SVG_SHOW_INFO)\n#define DISPLAY_UNIT(m)\t\t\t(((m) & S_F_UNIT)         == S_F_UNIT)\n#define SET_CANVAS_HEIGHT(m)\t\t(((m) & S_F_SVG_HEIGHT)   == S_F_SVG_HEIGHT)\n#define PACK_VIEWS(m)\t\t\t(((m) & S_F_SVG_PACKED)   == S_F_SVG_PACKED)\n#define DISPLAY_TOC(m)\t\t\t(((m) & S_F_SVG_SHOW_TOC) == S_F_SVG_SHOW_TOC)\n#define FDATASYNC(m)\t\t\t(((m) & S_F_FDATASYNC)    == S_F_FDATASYNC)\n#define USE_OPTION_A(m)\t\t\t(((m) & S_F_OPTION_A)     == S_F_OPTION_A)\n#define USE_OPTION_P(m)\t\t\t(((m) & S_F_OPTION_P)     == S_F_OPTION_P)\n#define USE_OPTION_I(m)\t\t\t(((m) & S_F_OPTION_I)     == S_F_OPTION_I)\n#define DISPLAY_MINMAX(m)\t\t(((m) & S_F_MINMAX)       == S_F_MINMAX)\n\n#define AO_F_NULL\t\t0x00000000\n\n/* Output flags for options -r / -S */\n#define AO_F_MEMORY\t\t0x00000001\n#define AO_F_SWAP\t\t0x00000002\n/* AO_F_MEM_ALL: See opt_flags in struct activity below */\n#define AO_F_MEM_ALL\t\t(AO_F_MEMORY << 8)\n\n#define DISPLAY_MEMORY(m)\t(((m) & AO_F_MEMORY)\t== AO_F_MEMORY)\n#define DISPLAY_SWAP(m)\t\t(((m) & AO_F_SWAP)\t== AO_F_SWAP)\n#define DISPLAY_MEM_ALL(m)\t(((m) & AO_F_MEM_ALL)\t== AO_F_MEM_ALL)\n\n/* Output flags for option -u [ ALL ] */\n#define AO_F_CPU_DEF\t\t0x00000001\n#define AO_F_CPU_ALL\t\t0x00000002\n\n#define DISPLAY_CPU_DEF(m)\t(((m) & AO_F_CPU_DEF)     == AO_F_CPU_DEF)\n#define DISPLAY_CPU_ALL(m)\t(((m) & AO_F_CPU_ALL)     == AO_F_CPU_ALL)\n\n/* Output flags for option -d */\n#define AO_F_DISK_PART\t\t0x00000001\n\n#define COLLECT_PARTITIONS(m)\t(((m) & AO_F_DISK_PART)   == AO_F_DISK_PART)\n\n/* Output flags for option -F */\n#define AO_F_FILESYSTEM\t\t0x00000001\n#define AO_F_MOUNT\t\t0x00000002\n\n#define DISPLAY_MOUNT(m)\t(((m) & AO_F_MOUNT)       == AO_F_MOUNT)\n\n/*\n ***************************************************************************\n * Various keywords and constants.\n ***************************************************************************\n */\n\n/* Keywords */\n#define K_A_NULL\t\"A_NULL\"\n#define K_CPU\t\t\"CPU\"\n#define K_PSI_CPU\t\"CPU\"\n#define K_DEV\t\t\"DEV\"\n#define K_EDEV\t\t\"EDEV\"\n#define K_EICMP\t\t\"EICMP\"\n#define K_EICMP6\t\"EICMP6\"\n#define K_EIP\t\t\"EIP\"\n#define K_EIP6\t\t\"EIP6\"\n#define K_ETCP\t\t\"ETCP\"\n#define K_FAN\t\t\"FAN\"\n#define K_FC\t\t\"FC\"\n#define K_FREQ\t\t\"FREQ\"\n#define K_ICMP\t\t\"ICMP\"\n#define K_ICMP6\t\t\"ICMP6\"\n#define K_IN\t\t\"IN\"\n#define K_PSI_IO\t\"IO\"\n#define K_IP\t\t\"IP\"\n#define K_IP6\t\t\"IP6\"\n#define K_LOAD\t\t\"LOAD\"\n#define K_PSI_MEM\t\"MEM\"\n#define K_MOUNT\t\t\"MOUNT\"\n#define K_NFS\t\t\"NFS\"\n#define K_NFSD\t\t\"NFSD\"\n#define K_PSI\t\t\"PSI\"\n#define K_SID\t\t\"SID\"\n#define K_SOCK\t\t\"SOCK\"\n#define K_SOCK6\t\t\"SOCK6\"\n#define K_SOFT\t\t\"SOFT\"\n#define K_SUM\t\t\"SUM\"\n#define K_TCP\t\t\"TCP\"\n#define K_TEMP\t\t\"TEMP\"\n#define K_UDP\t\t\"UDP\"\n#define K_UDP6\t\t\"UDP6\"\n#define K_XALL\t\t\"XALL\"\n\n#define K_INT\t\t\"INT\"\n#define K_DISK\t\t\"DISK\"\n#define K_XDISK\t\t\"XDISK\"\n#define K_SNMP\t\t\"SNMP\"\n#define K_IPV6\t\t\"IPV6\"\n#define K_POWER\t\t\"POWER\"\n#define K_USB\t\t\"USB\"\n#define K_BAT\t\t\"BAT\"\n\n#define K_SKIP_EMPTY\t\"skipempty\"\n#define K_AUTOSCALE\t\"autoscale\"\n#define K_ONEDAY\t\"oneday\"\n#define K_SHOWIDLE\t\"showidle\"\n#define K_SHOWINFO\t\"showinfo\"\n#define K_DEBUG\t\t\"debug\"\n#define K_HEIGHT\t\"height=\"\n#define K_PACKED\t\"packed\"\n#define K_SHOWTOC\t\"showtoc\"\n#define K_CUSTOMCOL\t\"customcol\"\n#define K_BWCOL\t\t\"bwcol\"\n#define K_PCPARCHIVE\t\"pcparchive=\"\n#define K_HZ\t\t\"hz=\"\n\n/* Environment variables */\n#define ENV_COLORS_PALETTE\t\"S_COLORS_PALETTE\"\n\n/* Groups of activities */\n#define G_DEFAULT\t0x00\n#define G_INT\t\t0x01\n#define G_DISK\t\t0x02\n#define G_SNMP\t\t0x04\n#define G_IPV6\t\t0x08\n#define G_POWER\t\t0x10\n#define G_XDISK\t\t0x20\n\n/* sadc program */\n#define SADC\t\t\"sadc\"\n\n/* Time must have the format HH:MM:SS with HH in 24-hour format */\n#define DEF_TMSTART\t\"08:00:00\"\n#define DEF_TMEND\t\"18:00:00\"\n\n#define UTSNAME_LEN\t65\n#define TZNAME_LEN\t8\n#define HEADER_LINE_LEN\t512\n\n/*\n * Define upper limit for various items.\n * Made necessary because we have to check the number of\n * items for each activity when we read a (possibly tainted)\n * sa data file.\n */\n#define MAX_NR_SERIAL_LINES\t65536\n#define MAX_NR_DISKS\t\t(65536 * 4096)\n#define MAX_NR_IFACES\t\t65536\n#define MAX_NR_FANS\t\t4096\n#define MAX_NR_TEMP_SENSORS\t4096\n#define MAX_NR_IN_SENSORS\t4096\n#define MAX_NR_USB\t\t65536\n#define MAX_NR_FS\t\t(65536 * 4096)\n#define MAX_NR_FCHOSTS\t\t65536\n#define MAX_NR_BATS\t\t4096\n\n/* NR_MAX is the upper limit used for unknown activities */\n#define NR_MAX\t\t(65536 * 4096)\n#define NR2_MAX\t\t4096\n\n/* Maximum number of args that can be passed to sadc */\n#define MAX_ARGV_NR\t32\n\n/* Miscellaneous constants */\n#define USE_SADC\t\t0\n#define USE_SA_FILE\t\t1\n#define NO_RESET\t\t0\n#define NO_RANGE\t\t0\n#define NON_FATAL\t\t0\n#define FATAL\t\t\t1\n#define H_MIN\t\t\t0\n#define H_MAX\t\t\t1\n#define C_SAR\t\t\t0\n#define C_SADF\t\t\t1\n#define ALL_ACTIVITIES\t\t~0U\n#define EXIT_IF_NOT_FOUND\t1\n#define RESUME_IF_NOT_FOUND\t0\n\nenum size_mode {\n\tSOFT_SIZE = 0,\n\tHARD_SIZE = 1\n};\n\nenum {\n\tFIRST\t= 0,\n\tSECOND\t= 1\n};\n\nenum sa_err_codes {\n\tEND_OF_DATA_UNEXPECTED\t= 1,\n\tINCONSISTENT_INPUT_DATA\t= 2\n};\n\nenum on_eof {\n\tUEOF_STOP = 0,\n\tUEOF_CONT = 1\n};\n\nenum xml_action {\n\tCLOSE_XML_MARKUP = 0,\n\tOPEN_XML_MARKUP  = 1\n};\n\nenum json_action {\n\tCLOSE_JSON_MARKUP = 0,\n\tOPEN_JSON_MARKUP  = 1\n};\n\nenum count_mode {\n\tCOUNT_ACTIVITIES = 0,\n\tCOUNT_OUTPUTS    = 1\n};\n\n/* Type for all functions reading statistics */\n#define __read_funct_t\tvoid\n/* Type for all functions displaying statistics */\n#define __print_funct_t void\n\n/*\n * **************************************************************************\n * Various structure definitions.\n ***************************************************************************\n */\n\nenum time_mode {\n\tNO_TIME = 0,\n\tUSE_HHMMSS_T = 1,\n\tUSE_EPOCH_T = 2\n};\n\n/*\n * Structure for timestamps.\n * @tm_time has the GMT or local broken time representation of @epoch_time.\n * Exception is when the structure is used to save the timestamp given by the\n * user on the command line with options -s/-e. In this case, it includes either\n * the number of seconds since the epoch *or* the broken time entered by the user.\n */\nstruct tstamp_ext {\n\tunsigned long long epoch_time;\n\tstruct tm tm_time;\n\tenum time_mode use;\n};\n\n/* Structure for items in list */\nstruct sa_item {\n\tchar *item_name;\n\tstruct sa_item *next;\n};\n\n/*\n ***************************************************************************\n * Output formats for sadf\n ***************************************************************************\n */\n\n/* Number of output formats */\n#define NR_FMT\t9\n\n/* Output formats */\nenum {\n\tF_SAR_OUTPUT\t= 0,\n\tF_DB_OUTPUT\t= 1,\n\tF_HEADER_OUTPUT\t= 2,\n\tF_PPC_OUTPUT\t= 3,\n\tF_XML_OUTPUT\t= 4,\n\tF_JSON_OUTPUT\t= 5,\n\tF_CONV_OUTPUT\t= 6,\n\tF_SVG_OUTPUT\t= 7,\n\tF_RAW_OUTPUT\t= 8,\n\tF_PCP_OUTPUT\t= 9\n};\n\n/* Structure for SVG specific parameters */\nstruct svg_parm {\n\tunsigned long long dt;\t\t\t/* Interval of time for current sample */\n\tunsigned long long ust_time_ref;\t/* X axis start time in seconds since the epoch */\n\tunsigned long long ust_time_end;\t/* X axis end time in seconds since the epoch */\n\tunsigned long long ust_time_first;\t/* Time (in seconds since the epoch) for first sample */\n\tint graph_no;\t\t\t\t/* Total number of views already displayed */\n\tint restart;\t\t\t\t/* TRUE if we have just met a RESTART record */\n\tint nr_act_dispd;\t\t\t/* Number of activities that will be displayed */\n\tint mock;\t\t\t\t/* TRUE if no data shall be actually printed */\n\tchar hour;\t\t\t\t/* Hour, minute and second (expressed in the */\n\tchar minute;\t\t\t\t/* locale of the datafile creator) for first */\n\tchar second;\t\t\t\t/* sample */\n\tstruct file_header *file_hdr;\t\t/* Pointer on file header structure */\n\tchar my_tzname[TZNAME_LEN];\t\t/* Current timezone */\n};\n\n/* Structure used when displaying SVG header */\nstruct svg_hdr_parm {\n\tint graph_nr;\t   /* Number of rows of views to display or canvas height entered on the command line */\n\tint views_per_row; /* Maximum number of views on a single row */\n\tint nr_act_dispd;  /* Number of activities that will be displayed */\n};\n\n/*\n ***************************************************************************\n * System activity data files\n *\n * The rule is: \"strict writing, read any\", meaning that sar/sadc can\n * only append data to a datafile whose format is strictly the same as that\n * of current version (checking FORMAT_MAGIC is not enough), but sar/sadf\n * can read data from different versions, providing that FORMAT_MAGIC value\n * has not changed (note that we are talking here of data read from a file,\n * not data that sar reads from sadc, in which case the \"strict\" rule applies).\n *\n * Format of system activity data files:\n *\t __\n *\t|\n *\t| file_magic structure\n *\t|\n * \t|--\n *\t|\n * \t| file_header structure\n * \t|\n * \t|--                         --|\n * \t|                             |\n * \t| file_activity structure     | x file_header:sa_act_nr\n * \t|                             |\n * \t|---------                  --|\n *\t\t|\n * \t\t| extra_desc structure (exists only if file_header:extra_next != 0)\n * \t\t|\n * \t\t|--                         --|\n *\t\t|                             |\n * \t\t| unknown extra structure(s)  | x extra_desc:extra_nr\n * \t\t|                             |\n * \t\t|--                         --|\n *\t\t|\n * \t\t| (extra_desc structure (exists only if previous extra_desc:extra_next != 0))\n * \t\t|\n * \t\t|--\n *\t\t|\n * \t\t| (...)\n * \t\t|\n * \t|---------                  --|\n * \t|                             |\n * \t| record_header structure     |\n * \t|                             |\n * \t|---------                  --|\n *\t\t|\n * \t\t| extra_desc structure (exists only if record_header:extra_next != 0)\n * \t\t|\n * \t\t|--                         --|\n *\t\t|                             |\n * \t\t| unknown extra structure(s)  | x extra_desc:extra_nr\n * \t\t|                             |\n * \t\t|--                         --|\n *\t\t|\n * \t\t| (extra_desc structure (exists only if previous extra_desc:extra_next != 0))\n * \t\t|\n * \t\t|--\n *\t\t|\n * \t\t| (...)\n * \t\t|\n * \t|---------                  --|\n * \t|(__nr_t)                     |\n * \t|--                           |\n * \t|                             |\n * \t| Statistics structure(s)     | x <count>\n * \t|                             |\n * \t|--                           |\n * \t|(__nr_t)                     |\n * \t|--                           |\n * \t|                             |\n * \t| Statistics structure(s)...  |\n * \t|                             |\n * \t|--                         --|\n *\n * Note: For activities with varying number of items, a __nr_t value, giving\n * the number of items, arrives before the statistics structures so that\n * we know how many of them have to be read.\n * NB: This value exists for all the activities even if they share the same\n * count function (e.g. A_NET_DEV and A_NET_EDEV). Indeed, statistics are not\n * read atomically and the number of items (e.g. network interfaces) may have\n * varied in between.\n *\n * If the record header's type is R_COMMENT then we find only a comment\n * following the record_header structure.\n *\n * If the record_header's type is R_RESTART then we find only the number of CPU\n * (of type __nr_t) of the machine following the record_header structure.\n * This number is 1 for 1 CPU and not an SMP kernel (CPU \"all\"),\n * 2 for 1 CPU and SMP kernel (CPU \"all\" and CPU 0), etc.\n * Of course we display the real number of CPU (e.g. \"1\" for 1 CPU and SMP\n * kernel) with the LINUX RESTART message.\n *\n * If the record_header's type is R_EXTRA* then we find only a list of extra\n * structures following the record_header structure but no statistics ones.\n * Note that extra structures may exist for all record_header types\n * (R_STATS, R_COMMENT, R_RESTART...). For R_COMMENT and R_RESTART records,\n * the extra structures will be found after the comment or the number of CPU.\n ***************************************************************************\n */\n\n/*\n * Sysstat magic number. Should never be modified.\n * Indicate that the file was created by sysstat.\n */\n#define SYSSTAT_MAGIC\t0xd596\n#define SYSSTAT_MAGIC_SWAPPED\t(((SYSSTAT_MAGIC << 8) | (SYSSTAT_MAGIC >> 8)) & 0xffff)\n\n/*\n * Datafile format magic number.\n * Modified to indicate that the format of the file is\n * no longer compatible with that of previous sysstat versions.\n */\n#define FORMAT_MAGIC\t0x2175\n#define FORMAT_MAGIC_SWAPPED\t(((FORMAT_MAGIC << 8) | (FORMAT_MAGIC >> 8)) & 0xffff)\n\n/* Previous datafile format magic numbers used by older sysstat versions */\n#define FORMAT_MAGIC_2171\t\t0x2171\n#define FORMAT_MAGIC_2171_SWAPPED\t(((FORMAT_MAGIC_2171 << 8) | (FORMAT_MAGIC_2171 >> 8)) & 0xffff)\n#define FORMAT_MAGIC_2173\t\t0x2173\n#define FORMAT_MAGIC_2173_SWAPPED\t(((FORMAT_MAGIC_2173 << 8) | (FORMAT_MAGIC_2173 >> 8)) & 0xffff)\n\n/* Padding in file_magic structure. See below. */\n#define FILE_MAGIC_PADDING\t48\n\n/* Structure for file magic header data */\nstruct file_magic {\n\t/*\n\t * This field identifies the file as a file created by sysstat.\n\t */\n\tunsigned short sysstat_magic;\n\t/*\n\t * The value of this field varies whenever datafile format changes.\n\t */\n\tunsigned short format_magic;\n\t/*\n\t * Sysstat version used to create the file.\n\t */\n\tunsigned char sysstat_version;\n\tunsigned char sysstat_patchlevel;\n\tunsigned char sysstat_sublevel;\n\tunsigned char sysstat_extraversion;\n#define FILE_MAGIC_ULL_NR\t0\t/* Nr of unsigned long long below */\n#define FILE_MAGIC_UL_NR\t0\t/* Nr of unsigned long below */\n#define FILE_MAGIC_U_NR\t\t5\t/* Nr of [unsigned] int below */\n\t/*\n\t * Size of file's header (size of file_header structure used by file).\n\t */\n\tunsigned int header_size;\n\t/*\n\t * Set to non zero if data file has been converted with \"sadf -c\" from\n\t * an old format (version x.y.z) to a newest format (version X.Y.Z).\n\t * In this case, the value is: Y*256 + Z + 1.\n\t * The FORMAT_MAGIC value of the file can be used to determine X.\n\t */\n\tunsigned int upgraded;\n\t/*\n\t * Description of the file_header structure\n\t * (nr of \"long long\", nr of \"long\" and nr of \"int\").\n\t */\n\tunsigned int hdr_types_nr[3];\n\t/*\n\t * Padding. Reserved for future use while avoiding a format change.\n\t * sysstat always reads a number of bytes which is that expected for\n\t * current sysstat version (FILE_MAGIC_SIZE). We cannot guess if we\n\t * are going to read a file from current, an older or a newer version.\n\t */\n\tunsigned char pad[FILE_MAGIC_PADDING];\n};\n\n#define FILE_MAGIC_SIZE\t(sizeof(struct file_magic))\n\n/* Header structure for system activity data file */\nstruct file_header {\n\t/*\n\t * Timestamp in seconds since the epoch.\n\t */\n\tunsigned long long sa_ust_time;\n\t/*\n\t * Number of jiffies per second.\n\t */\n\tunsigned long sa_hz\t\t__attribute__ ((aligned (8)));\n\t/*\n\t * Number of [online or offline] CPU (1 .. CPU_NR + 1)\n\t * when the datafile has been created.\n\t * When reading a datafile, this value is updated (in memory)\n\t * whenever a RESTART record is found.\n\t * When writing or appending data to a file, this field is updated\n\t * neither in file nor in memory.\n\t */\n\tunsigned int sa_cpu_nr\t\t__attribute__ ((aligned (8)));\n\t/*\n\t * Number of activities saved in file.\n\t */\n\tunsigned int sa_act_nr;\n\t/*\n\t * Current year.\n\t */\n\tint sa_year;\n\t/*\n\t * Description of the file_activity and record_header structures\n\t * (nr of \"long long\", nr of \"long\" and nr of \"int\").\n\t */\n\tunsigned int act_types_nr[3];\n\tunsigned int rec_types_nr[3];\n\t/*\n\t * Size of file_activity and record_header structures used by file.\n\t */\n\tunsigned int act_size;\n\tunsigned int rec_size;\n\t/*\n\t * TRUE if an extra_desc structure exists.\n\t */\n\tunsigned int extra_next;\n\t/*\n\t * Current day and month.\n\t * No need to save DST (Daylight Saving Time) flag, since it is not taken\n\t * into account by the strftime() function used to print the timestamp.\n\t */\n\tunsigned char sa_day;\n\tunsigned char sa_month;\n\t/*\n\t * Size of a long integer. Useful to know the architecture on which\n\t * the datafile was created.\n\t */\n\tchar sa_sizeof_long;\n\t/*\n\t * Operating system name.\n\t */\n\tchar sa_sysname[UTSNAME_LEN];\n\t/*\n\t * Machine hostname.\n\t */\n\tchar sa_nodename[UTSNAME_LEN];\n\t/*\n\t * Operating system release number.\n\t */\n\tchar sa_release[UTSNAME_LEN];\n\t/*\n\t * Machine architecture.\n\t */\n\tchar sa_machine[UTSNAME_LEN];\n\t/*\n\t * Timezone value.\n\t */\n\tchar sa_tzname[TZNAME_LEN];\n};\n\n#define FILE_HEADER_SIZE\t(sizeof(struct file_header))\n#define FILE_HEADER_ULL_NR\t1\t/* Nr of unsigned long long in file_header structure */\n#define FILE_HEADER_UL_NR\t1\t/* Nr of unsigned long in file_header structure */\n#define FILE_HEADER_U_NR\t12\t/* Nr of [unsigned] int in file_header structure */\n/* The values below are used for sanity check */\n#define MIN_FILE_HEADER_SIZE\t0\n#define MAX_FILE_HEADER_SIZE\t8192\n\n\n/*\n * Base magical number for activities.\n */\n#define ACTIVITY_MAGIC_BASE\t0x8a\n\n/* List of activities saved in file */\nstruct file_activity {\n\t/*\n\t * Identification value of activity.\n\t */\n\tunsigned int id;\n\t/*\n\t * Activity magical number.\n\t */\n\tunsigned int magic;\n\t/*\n\t * Number of items for this activity\n\t * when the data file has been created.\n\t */\n\t__nr_t nr;\n\t/*\n\t * Number of sub-items for this activity.\n\t */\n\t__nr_t nr2;\n\t/*\n\t * Set to TRUE if statistics are preceded by\n\t * a value giving the number of structures to read.\n\t */\n\tint has_nr;\n\t/*\n\t * Size of an item structure.\n\t */\n\tint size;\n\t/*\n\t * Description of the structure containing statistics for the\n\t * given activity (nr of \"long long\", nr of \"long\" and nr of \"int\").\n\t */\n\tunsigned int types_nr[3];\n};\n\n#define FILE_ACTIVITY_SIZE\t(sizeof(struct file_activity))\n#define MAX_FILE_ACTIVITY_SIZE\t1024\t/* Used for sanity check */\n#define FILE_ACTIVITY_ULL_NR\t0\t/* Nr of unsigned long long in file_activity structure */\n#define FILE_ACTIVITY_UL_NR\t0\t/* Nr of unsigned long in file_activity structure */\n#define FILE_ACTIVITY_U_NR\t9\t/* Nr of [unsigned] int in file_activity structure */\n\n#define MAX_ITEM_STRUCT_SIZE\t1024\t/* Used for sanity check */\n\n/*\n * Description of an extra structure.\n * The composition of this structure should not change in time.\n */\nstruct extra_desc {\n\t/*\n\t * Number of extra structures to read.\n\t */\n\tunsigned int extra_nr;\n\t/*\n\t * Size of an extra structure.\n\t */\n\tunsigned int extra_size;\n\t/*\n\t * TRUE if another extra_desc structure exists after\n\t * all the extra structures.\n\t */\n\tunsigned int extra_next;\n\t/*\n\t * Description of an extra structure\n\t * (nr of \"long long\", nr of \"long\" and nr of \"int\").\n\t */\n\tunsigned int extra_types_nr[3];\n};\n\n#define EXTRA_DESC_SIZE\t\t(sizeof(struct extra_desc))\n#define EXTRA_DESC_ULL_NR\t0\t/* Nr of unsigned long long in extra_desc structure */\n#define EXTRA_DESC_UL_NR\t0\t/* Nr of unsigned long in extra_desc structure */\n#define EXTRA_DESC_U_NR\t\t6\t/* Nr of [unsigned] int in extra_desc structure */\n#define MAX_EXTRA_NR\t\t8192\n#define MAX_EXTRA_SIZE\t\t1024\n\n/* Record type */\nenum {\n\t/*\n\t * R_STATS means that this is a record of statistics.\n\t*/\n\tR_STATS\t\t= 1,\n\t/*\n\t * R_RESTART means that this is a special record containing\n\t * a LINUX RESTART message.\n\t*/\n\tR_RESTART\t= 2,\n\t/*\n\t * R_LAST_STATS warns sar that this is the last record to be written\n\t * to file before a file rotation, and that the next data to come will\n\t * be a header file.\n\t * Such a record is tagged R_STATS anyway before being written to file.\n\t */\n\tR_LAST_STATS\t= 3,\n\t/*\n\t * R_COMMENT means that this is a special record containing\n\t * a comment.\n\t */\n\tR_COMMENT\t= 4,\n\t/*\n\t * R_EXTRA* records means that extra structures are following current\n\t * record_header structure, but no statistics structures.\n\t*/\n\tR_EXTRA_MIN\t= 5,\n\tR_EXTRA_MAX\t= 15\n};\n\n/* Maximum length of a comment */\n#define MAX_COMMENT_LEN\t64\n\n/* Header structure for every record */\nstruct record_header {\n\t/*\n\t * Machine uptime in 1/100th of a second.\n\t */\n\tunsigned long long uptime_cs;\n\t/*\n\t * Timestamp (number of seconds since the epoch).\n\t */\n\tunsigned long long ust_time;\n\t/*\n\t * TRUE if an extra_desc structure exists.\n\t */\n\tunsigned int extra_next;\n\t/*\n\t * Record type: R_STATS, R_RESTART,...\n\t */\n\tunsigned char record_type;\n\t/*\n\t * Timestamp: Hour (0-23), minute (0-59) and second (0-60).\n\t * Used to determine TRUE time.\n\t * Hour value depends in fact on timezone (TZ variable) value.\n\t */\n\tunsigned char hour;\n\tunsigned char minute;\n\tunsigned char second;\n};\n\n#define RECORD_HEADER_SIZE\t(sizeof(struct record_header))\n#define MAX_RECORD_HEADER_SIZE\t512\t/* Used for sanity check */\n#define RECORD_HEADER_ULL_NR\t2\t/* Nr of unsigned long long in record_header structure */\n#define RECORD_HEADER_UL_NR\t0\t/* Nr of unsigned long in record_header structure */\n#define RECORD_HEADER_U_NR\t1\t/* Nr of unsigned int in record_header structure */\n\n\n/*\n ***************************************************************************\n * Generic description of an activity.\n ***************************************************************************\n */\n\n/* Activity options */\n#define AO_NULL\t\t\t0x00\n/*\n * Indicate that corresponding activity should be collected by sadc.\n */\n#define AO_COLLECTED\t\t0x01\n/*\n * Indicate that corresponding activity should be displayed by sar.\n */\n#define AO_SELECTED\t\t0x02\n/*\n * Indicate that corresponding activity has items that need to be counted.\n * This means that its @f_count_index values is >= 0.\n * (We use AO_COUNTED instead of @f_count_index because @f_count_index\n * is available (initialized) only for sadc).\n */\n#define AO_COUNTED\t\t0x04\n/*\n * Indicate that activity's metrics have persistent values when devices\n * are registered again (this means that when the device is registered again,\n * the metrics pick the values they had when they had been unregistered).\n * Exclusively used for CPU related statistics at the present time\n * (e.g. A_CPU and A_NET_SOFT).\n */\n#define AO_PERSISTENT\t\t0x08\n/*\n * This flag should be set for every activity closing a markup used\n * by several activities. Used by sadf f_xml_print() functions to\n * display XML output, and also by f_json_print() functions to display JSON output.\n */\n#define AO_CLOSE_MARKUP\t\t0x10\n/*\n * Indicate that corresponding activity has multiple different\n * output formats. This is the case for example for memory activity\n * with options -r and -R.\n * PS: Such an activity should appear in the list of activities that\n * sar -A is supposed to display.\n */\n#define AO_MULTIPLE_OUTPUTS\t0x20\n/*\n * Indicate that one (SVG) graph will be displayed for each\n * distinct item for this activity (sadf -g).\n */\n#define AO_GRAPH_PER_ITEM\t0x40\n/*\n * Indicate that this activity may have sub-items.\n */\n#define AO_MATRIX\t\t0x80\n/*\n * Indicate that a list of devices has been entered on the command\n * line for this activity (see options --dev=, --iface=, ...)\n */\n#define AO_LIST_ON_CMDLINE\t0x100\n/*\n * Indicate that the number of items for this activity should always\n * be counted, even if the activity is not collected.\n */\n#define AO_ALWAYS_COUNTED\t0x200\n/*\n * Indicate that corresponding activity should be collected only\n * if a test has been successfully passed before.\n * The test corresponds to the count() function (see @f_count_index).\n * This is intended for activities with a fixed number of items but\n * whose {/proc|/sys} files are not necessarily available, e.g. depending\n * on the kernel version used. Unlike activities with AO_COUNTED flag,\n * those having AO_DETECTED flag won't have a @has_nr number preceding\n * their statistics structures in datafile.\n */\n#define AO_DETECTED\t\t0x400\n\n#define IS_COLLECTED(m)\t\t(((m) & AO_COLLECTED)        == AO_COLLECTED)\n#define IS_SELECTED(m)\t\t(((m) & AO_SELECTED)         == AO_SELECTED)\n#define HAS_COUNT_FUNCTION(m)\t(((m) & AO_COUNTED)          == AO_COUNTED)\n#define HAS_DETECT_FUNCTION(m)\t(((m) & AO_DETECTED)         == AO_DETECTED)\n#define HAS_PERSISTENT_VALUES(m) (((m) & AO_PERSISTENT)      == AO_PERSISTENT)\n#define CLOSE_MARKUP(m)\t\t(((m) & AO_CLOSE_MARKUP)     == AO_CLOSE_MARKUP)\n#define HAS_MULTIPLE_OUTPUTS(m)\t(((m) & AO_MULTIPLE_OUTPUTS) == AO_MULTIPLE_OUTPUTS)\n#define ONE_GRAPH_PER_ITEM(m)\t(((m) & AO_GRAPH_PER_ITEM)   == AO_GRAPH_PER_ITEM)\n#define IS_MATRIX(m)\t\t(((m) & AO_MATRIX)           == AO_MATRIX)\n#define HAS_LIST_ON_CMDLINE(m)\t(((m) & AO_LIST_ON_CMDLINE)  == AO_LIST_ON_CMDLINE)\n#define ALWAYS_COUNT_ITEMS(m)\t(((m) & AO_ALWAYS_COUNTED)   == AO_ALWAYS_COUNTED)\n\n#define _buf0\tbuf[0]\n#define _nr0\tnr[0]\n\n/* Structure used to define a bitmap needed by an activity */\nstruct act_bitmap {\n\t/*\n\t * Bitmap for activities that need one. Remember to allocate it\n\t * before use!\n\t */\n\tunsigned char *b_array;\n\t/*\n\t * Size of the bitmap in bits. In fact, bitmap is sized to b_size + 1\n\t * to take into account CPU \"all\"\n\t */\n\tint b_size;\n};\n\n/*\n * Structure used to define an activity.\n * Note: This structure can be modified without changing the format of data files.\n */\nstruct activity {\n\t/*\n\t * This variable contains the identification value (A_...) for this activity.\n\t */\n\tunsigned int id;\n\t/*\n\t * Activity options (AO_...)\n\t */\n\tunsigned int options;\n\t/*\n\t * Activity magical number. This number changes when activity format in file\n\t * is no longer compatible with the format of that same activity from\n\t * previous versions.\n\t */\n\tunsigned int magic;\n\t/*\n\t * An activity belongs to a group (and only one).\n\t * Groups are those selected with option -S of sadc.\n\t */\n\tunsigned int group;\n\t/*\n\t * Index in f_count[] array to determine function used to count\n\t * the number of items (serial lines, network interfaces, etc.) for\n\t * activities with AO_COUNTED flag. Determine @nr value.\n\t * Such a function should _always_ return a value greater than\n\t * or equal to 0.\n\t *\n\t * A value of -1 indicates that the number of items\n\t * is a constant (and @nr_ini is set to this value).\n\t *\n\t * This function may be called even if corresponding activity has not\n\t * been selected if flag AO_ALWAYS_COUNTED is set, to make sure that\n\t * all items have been calculated (e.g. #CPU)\n\t *\n\t * The count() function may also be used to know if an activity (with\n\t * AO_DETECTED flag) can actually be collected based on the presence of\n\t * {/proc|/sys} files.\n\t */\n\tint f_count_index;\n\t/*\n\t * Index in f_count[] array to determine function used to count the\n\t * number of sub-items -> @nr2\n\t * Such a function should _always_ return a value greater than\n\t * or equal to 0.\n\t *\n\t * A value of -1 indicates that the number of items is a constant\n\t * (and @nr2 is set to this value).\n\t */\n\tint f_count2_index;\n\t/*\n\t * This function reads the relevant file and fill the buffer\n\t * with statistics corresponding to given activity.\n\t */\n\t__read_funct_t (*f_read) (struct activity *);\n\t/*\n\t * This function displays activity statistics onto the screen.\n\t */\n\t__print_funct_t (*f_print) (struct activity *, int, int, unsigned long long);\n\t/*\n\t * This function displays average activity statistics onto the screen.\n\t */\n\t__print_funct_t (*f_print_avg) (struct activity *, int, int, unsigned long long);\n\t/*\n\t * This function is used by sadf to display activity in a format that can\n\t * easily be ingested by a relational database, or a format that can be\n\t * handled by pattern processing commands like \"awk\".\n\t */\n\t__print_funct_t (*f_render) (struct activity *, int, char *, int, unsigned long long);\n\t/*\n\t * This function is used by sadf to display activity statistics in XML.\n\t */\n\t__print_funct_t (*f_xml_print) (struct activity *, int, int, unsigned long long);\n\t/*\n\t * This function is used by sadf to display activity statistics in JSON.\n\t */\n\t__print_funct_t (*f_json_print) (struct activity *, int, int, unsigned long long);\n\t/*\n\t * This function is used by sadf to display activity statistics in SVG.\n\t */\n\t__print_funct_t (*f_svg_print) (struct activity *, int, int, struct svg_parm *,\n\t\t\t\t\tunsigned long long, struct record_header *);\n\t/*\n\t * This function is used by sadf to display activity statistics in raw format.\n\t */\n\t__print_funct_t (*f_raw_print) (struct activity *, char *, int);\n\t/*\n\t * This function is used by sadf to display activity statistics in PCP format.\n\t */\n\t__print_funct_t (*f_pcp_print) (struct activity *, int);\n\t/*\n\t * This function is used by sadf to count the number of new items in current\n\t * sample and add them to the linked list @item_list.\n\t */\n\t__nr_t (*f_count_new) (struct activity *, int);\n\t/*\n\t * Linked list containing item names. This is either all the different items\n\t * found in a file for activities that have a @f_count_new() function (used by sadf),\n\t * or a list entered on the command line (used by sadf and sar).\n\t */\n\tstruct sa_item *item_list;\n\t/*\n\t * Number of different items found in file (calculated by sadf).\n\t * This is also the number of items in @item_list if this list exists.\n\t */\n\t__nr_t item_list_sz;\n\t/*\n\t * Header string displayed by sadf -d.\n\t * Header lines for each output (for activities with multiple outputs) are\n\t * separated with a '|' character.\n\t * For a given output, the first field corresponding to extended statistics\n\t * (eg. -r ALL) begins with a '&' character.\n\t * A field having '*' in its name means that all items will have its own column\n\t * (the first one will be displayed as \"all\", the following ones will get the '*'\n\t * character replaced with their item number (0, 1, etc.)\n\t */\n\tchar *hdr_line;\n\t/*\n\t * Description of activity.\n\t */\n\tchar *desc;\n\t/*\n\t * Name of activity.\n\t */\n\tchar *name;\n\t/*\n\t * Description of the corresponding structure containing statistics (as defined\n\t * in rd_stats.h or rd_sensors.h). Such a structure has 0+ fields of type\n\t * \"long long\", followed by 0+ fields of type \"long\", followed by 0+ fields of\n\t * type \"int\", followed by 0+ other fields (e.g. of type char). The array below\n\t * gives the number of \"long long\" fields composing the structure, then the number\n\t * of \"long\" fields, then the number of \"int\" fields.\n\t */\n\tunsigned int gtypes_nr[3];\n\t/*\n\t * This array has the same meaning as @gtypes_nr[] above, but the values are those\n\t * read from current data file. They may be different from those of @gtypes_nr[]\n\t * because we can read data from a different sysstat version (older or newer).\n\t */\n\tunsigned int ftypes_nr[3];\n\t/*\n\t * Number of SVG graphs for this activity. The total number of graphs for\n\t * the activity can be greater though if flag AO_GRAPH_PER_ITEM is set, in\n\t * which case the total number will  be @g_nr * @nr.\n\t */\n\tint g_nr;\n\t/*\n\t * Number of items on the system, as counted when the system is initialized.\n\t * A negative value (-1) is the default value and indicates that this number\n\t * has still not been calculated by the function whose index is in @f_count_index.\n\t * A value of 0 means that this number has been calculated, but no items have\n\t * been found.\n\t * A positive value (>0) has either been calculated or is a constant.\n\t */\n\t__nr_t nr_ini;\n\t/*\n\t * Number of sub-items on the system.\n\t * @nr2 is in fact the second dimension of a matrix of items, the first\n\t * one being @nr. @nr is the number of lines, and @nr2 the number of columns.\n\t * A negative value (-1) is the default value and indicates that this number\n\t * has still not been calculated by the f_count2() function.\n\t * A value of 0 means that this number has been calculated, but no sub-items have\n\t * been found.\n\t * A positive value (>0) has either been calculated or is a constant.\n\t * Rules:\n\t * 1) IF @nr2 = 0 THEN @nr_ini = 0\n\t *    Note: If @nr_ini = 0, then @nr2 is undetermined (may be -1, 0 or >0).\n\t * 2) IF @nr_ini > 0 THEN @nr2 > 0.\n\t *    Note: If @nr2 > 0 then @nr_ini is undetermined (may be -1, 0 or >0).\n\t * 3) IF @nr_ini <= 0 THEN @nr2 = -1 (this is the default value for @nr2,\n\t * meaning that it has not been calculated).\n\t */\n\t__nr_t nr2;\n\t/*\n\t * Maximum number of elements that sar can handle for this item.\n\t * NB: The maximum number of elements that sar can handle for sub-items\n\t * is NR2_MAX.\n\t */\n\t__nr_t nr_max;\n\t/*\n\t * Number of items, as read and saved in corresponding buffer (@buf: See below).\n\t * The value may be zero for a particular sample if no items have been found.\n\t */\n\t__nr_t nr[3];\n\t/*\n\t * Number of structures allocated in @buf[*]. This number should be greater\n\t * than or equal to @nr[*].\n\t * This also is the number of entries allocated for @spmin and @spmax. An entry\n\t * can contain several min or max values.\n\t */\n\t__nr_t nr_allocated;\n\t/*\n\t * Number of min and max values that will be saved for each item.\n\t * This will be used to size @spmin / @spmax areas (see below).\n\t */\n\tint xnr;\n\t/*\n\t * Size of an item.\n\t * This is the size of the corresponding structure, as read from or written\n\t * to a file, or read from or written by the data collector.\n\t */\n\tint fsize;\n\t/*\n\t * Size of an item.\n\t * This is the size of the corresponding structure as mapped into memory.\n\t * @msize can be different from @fsize when data are read from or written to\n\t * a data file from a different sysstat version.\n\t */\n\tint msize;\n\t/*\n\t * Optional flags for activity. This is eg. used when AO_MULTIPLE_OUTPUTS\n\t * option is set.\n\t * 0x0001 - 0x0080 : Multiple outputs (eg. AO_F_MEMORY, AO_F_SWAP...)\n\t * 0x0100 - 0x8000 : If bit set then display complete header (@hdr_line) for\n\t *                   corresponding output\n\t * 0x010000+       : Optional flags\n\t */\n\tunsigned int opt_flags;\n\t/*\n\t * Buffers that will contain the statistics read. Its size is @nr * @nr2 * @size each.\n\t * [0]: used by sadc.\n\t * [0] and [1]: current/previous statistics values (used by sar).\n\t * [2]: Used by sar to save first collected stats (used later to\n\t * compute average).\n\t */\n\tvoid *buf[3];\n\t/*\n\t * Pointer on area where minimum and maximum values will be saved.\n\t * The size of each area is @nr * @nr2 * @xnr * sizeof(double).\n\t */\n\tdouble *spmin;\n\tdouble *spmax;\n\t/*\n\t * Number of slots allocated in @spmin and @spmax buffers.\n\t * A slot can contain several values.\n\t * This number of slots is always greater than or equal to @nr_allocated.\n\t */\n\t__nr_t nr_spalloc;\n\t/*\n\t * Linked list containing the name of the devices in the order in which their\n\t * min and max values have been saved in @spmin and @spmax.\n\t */\n\tstruct sa_item *xdev_list;\n\t/*\n\t * Bitmap for activities that need one. Such a bitmap is needed by activity\n\t * if @bitmap is not NULL.\n\t */\n\tstruct act_bitmap *bitmap;\n};\n\n\n/*\n ***************************************************************************\n * Generic description of an output format for sadf (and sar).\n ***************************************************************************\n */\n\n/* Type for all functions used by sadf to display stats in various formats */\n#define __printf_funct_t void\n#define __tm_funct_t char *\n\n/*\n * Structure used to define a report.\n * A XML-like report has the following format:\n *       __\n *      |\n *      | Header block\n *      |  __\n *      | |\n *      | | Statistics block\n *      | |  __\n *      | | |\n *      | | | Timestamp block\n *      | | |  __\n *      | | | |\n *      | | | | Activity #1\n *      | | | |__\n *      | | | |\n *      | | | | ...\n *      | | | |__\n *      | | | |\n *      | | | | Activity #n\n *      | | | |__\n *      | | |__\n *      | |__\n *      | |\n *      | | Restart messages block\n *      | |__\n *      | |\n *      | | Comments block\n *      | |__\n *      |__\n */\nstruct report_format {\n\t/*\n\t * This variable contains the identification value (F_...) for this report format.\n\t */\n\tunsigned int id;\n\t/*\n\t * Format options (FO_...).\n\t */\n\tunsigned int options;\n\t/*\n\t * This function displays the report header\n\t * (data displayed once at the beginning of the report).\n\t */\n\t__printf_funct_t (*f_header) (void *, int, char *, char *, struct file_magic *,\n\t\t\t\t      struct file_header *, struct activity * [], unsigned int [],\n\t\t\t\t      struct file_activity *);\n\t/*\n\t * This function defines the statistics part of the report.\n\t * Used only with textual (XML-like) reports and PCP archives.\n\t */\n\t__printf_funct_t (*f_statistics) (int *, int, struct activity * [], unsigned int []);\n\t/*\n\t * This function defines the timestamp part of the report.\n\t * Used only with textual (XML-like) reports, PCP archives and RAW output format.\n\t */\n\t__tm_funct_t (*f_timestamp) (void *, int, char *, char *, char *, unsigned long long,\n\t\t\t\t     struct record_header *, struct file_header *, unsigned int);\n\t/*\n\t * This function displays the restart messages.\n\t */\n\t__printf_funct_t (*f_restart) (int *, int, char *, char *, char *,\n\t\t\t\t       struct file_header *, struct record_header *);\n\t/*\n\t * This function displays the comments.\n\t */\n\t__printf_funct_t (*f_comment) (int *, int, char *, char *, char *, char *,\n\t\t\t\t       struct file_header *, struct record_header *);\n\t/*\n\t * This is the main function used to display all the statistics for current format.\n\t */\n\tvoid (*f_display) (int, char *, struct file_activity *, struct file_magic *,\n\t\t\t   struct tstamp_ext *, void *);\n};\n\n\n/* Possible actions for functions used to display reports */\n#define F_BEGIN\t0x01\n#define F_MAIN\t0x02\n#define F_END\t0x04\n\n/*\n ***************************************************************************\n * SVG output definitions\n ***************************************************************************\n */\n\n/*\n *   ^\n * 1 | General header\n *   v\n *   ^\n * 9 | One line from table of contents (if any)\n *   v\n *   ^   ^   ^\n *   |   | 4 | Graph title\n *   |   |   v\n *   |   |   ^    |                                Caption\n *   | 3 |   |    |\n *   |   |   |  G |Y\n * 2 |   | 5 |  r |\n *   |   |   |  a |A\n *   |   |   |  d |x\n *   |   |   |  . |i\n *   |   |   |    |s          X Axis\n *   |   |   v    |-------------------------------\n *   |   |              Grad.\n *   |   v   <---><------------------------------>\n *   |         6                8\n *   | Gap\n *   v<---------------------------------------------------------------> Gap\n *                                    7\n *    <--------------------------------------------------------------------->\n *                                      8\n */\n\n/* #8 */\n#define SVG_G_XSIZE\t720\n/* #6 */\n#define SVG_M_XSIZE\t70\n/* #7 */\n#define SVG_V_XSIZE\t1050\n/* #8 */\n#define SVG_T_XSIZE\t1060\n\n/* #5 */\n#define SVG_G_YSIZE\t200\n/* #1 */\n#define SVG_H_YSIZE\t60\n/* #4 */\n#define SVG_M_YSIZE\t50\n/* #2 */\n#define SVG_T_YSIZE\t310\n/* #3 */\n#define SVG_V_YSIZE\t300\n/* #9 */\n#define SVG_C_YSIZE\t20\n\n/* Grid: Nr of horizontal lines */\n#define SVG_H_GRIDNR\t3\n/* Grid: Nr of vertical lines */\n#define SVG_V_GRIDNR\t10\n\n/* Block size used to allocate arrays for graphs data */\n#define CHUNKSIZE\t4096\n\n/* Maximum number of views on a single row */\n#define MAX_VIEWS_ON_A_ROW\t6\n\nenum svg_graph_type {\n\tSVG_LINE_GRAPH \t= 1,\n\tSVG_BAR_GRAPH\t= 2\n};\n\n#define MOCK_MODE\tTRUE\n#define REAL_MODE\tFALSE\n\n/* Maximum number of horizontal lines for the background grid */\n#define MAX_HLINES_NR\t10\n\n/* Minimum SVG canvas height (in pixels) */\n#define MIN_CANVAS_HEIGHT\t100\n\n/* Color palette constants */\n#define SVG_COLORS_IDX_MASK\t0x0f\n#define SVG_COL_PALETTE_SIZE\t24\n#define SVG_COL_PALETTE_NR\t3\n#define SVG_COL_BCKGRD_IDX\t16\n#define SVG_COL_AXIS_IDX\t17\n#define SVG_COL_GRID_IDX\t18\n#define SVG_COL_TITLE_IDX\t19\n#define SVG_COL_INFO_IDX\t20\n#define SVG_COL_DEFAULT_IDX\t21\n#define SVG_COL_HEADER_IDX\t22\n#define SVG_COL_ERROR_IDX\t23\n\nenum {\n\tSVG_DEFAULT_COL_PALETTE\t= 0,\n\tSVG_CUSTOM_COL_PALETTE\t= 1,\n\tSVG_BW_COL_PALETTE\t= 2\n};\n\n#define MAYBE\t0x80\n\n/*\n ***************************************************************************\n * Macro functions definitions.\n *\n * Note: Using 'do ... while' makes the macros safer to use\n * (remember that macro use is followed by a semicolon).\n ***************************************************************************\n */\n\n/* Close file descriptors */\n#define CLOSE_ALL(_fd_)\t\tdo {\t\t\t\\\n\t\t\t\t\tclose(_fd_[0]); \\\n\t\t\t\t\tclose(_fd_[1]); \\\n\t\t\t\t} while (0)\n\n#define CLOSE(_fd_)\t\tif (_fd_ >= 0)\t\t\\\n\t\t\t\t\tclose(_fd_)\n\n/*\n ***************************************************************************\n * Functions prototypes.\n ***************************************************************************\n */\n\n/*\n * Prototypes used to count new items\n */\n__nr_t count_new_int\n\t(struct activity *, int);\n__nr_t count_new_net_dev\n\t(struct activity *, int);\n__nr_t count_new_net_edev\n\t(struct activity *, int);\n__nr_t count_new_filesystem\n\t(struct activity *, int);\n__nr_t count_new_fchost\n\t(struct activity *, int);\n__nr_t count_new_disk\n\t(struct activity *, int);\n__nr_t count_new_bat\n\t(struct activity *, int);\n\n/* Functions used to count number of items */\n__nr_t wrap_get_cpu_nr\n\t(struct activity *);\n__nr_t wrap_get_irq_nr\n\t(struct activity *);\n__nr_t wrap_get_serial_nr\n\t(struct activity *);\n__nr_t wrap_get_disk_nr\n\t(struct activity *);\n__nr_t wrap_get_iface_nr\n\t(struct activity *);\n__nr_t wrap_get_fan_nr\n\t(struct activity *);\n__nr_t wrap_get_temp_nr\n\t(struct activity *);\n__nr_t wrap_get_in_nr\n\t(struct activity *);\n__nr_t wrap_get_freq_nr\n\t(struct activity *);\n__nr_t wrap_get_usb_nr\n\t(struct activity *);\n__nr_t wrap_get_filesystem_nr\n\t(struct activity *);\n__nr_t wrap_get_fchost_nr\n\t(struct activity *);\n__nr_t wrap_detect_psi\n\t(struct activity *);\n__nr_t wrap_get_bat_nr\n\t(struct activity *);\n\n/* Functions used to read activities statistics */\n__read_funct_t wrap_read_stat_cpu\n\t(struct activity *);\n__read_funct_t wrap_read_stat_pcsw\n\t(struct activity *);\n__read_funct_t wrap_read_stat_irq\n\t(struct activity *);\n__read_funct_t wrap_read_swap\n\t(struct activity *);\n__read_funct_t wrap_read_paging\n\t(struct activity *);\n__read_funct_t wrap_read_io\n\t(struct activity *);\n__read_funct_t wrap_read_meminfo\n\t(struct activity *);\n__read_funct_t wrap_read_kernel_tables\n\t(struct activity *);\n__read_funct_t wrap_read_loadavg\n\t(struct activity *);\n__read_funct_t wrap_read_tty_driver_serial\n\t(struct activity *);\n__read_funct_t wrap_read_disk\n\t(struct activity *);\n__read_funct_t wrap_read_net_dev\n\t(struct activity *);\n__read_funct_t wrap_read_net_edev\n\t(struct activity *);\n__read_funct_t wrap_read_net_nfs\n\t(struct activity *);\n__read_funct_t wrap_read_net_nfsd\n\t(struct activity *);\n__read_funct_t wrap_read_net_sock\n\t(struct activity *);\n__read_funct_t wrap_read_net_ip\n\t(struct activity *);\n__read_funct_t wrap_read_net_eip\n\t(struct activity *);\n__read_funct_t wrap_read_net_icmp\n\t(struct activity *);\n__read_funct_t wrap_read_net_eicmp\n\t(struct activity *);\n__read_funct_t wrap_read_net_tcp\n\t(struct activity *);\n__read_funct_t wrap_read_net_etcp\n\t(struct activity *);\n__read_funct_t wrap_read_net_udp\n\t(struct activity *);\n__read_funct_t wrap_read_net_sock6\n\t(struct activity *);\n__read_funct_t wrap_read_net_ip6\n\t(struct activity *);\n__read_funct_t wrap_read_net_eip6\n\t(struct activity *);\n__read_funct_t wrap_read_net_icmp6\n\t(struct activity *);\n__read_funct_t wrap_read_net_eicmp6\n\t(struct activity *);\n__read_funct_t wrap_read_net_udp6\n\t(struct activity *);\n__read_funct_t wrap_read_cpuinfo\n\t(struct activity *);\n__read_funct_t wrap_read_fan\n\t(struct activity *);\n__read_funct_t wrap_read_temp\n\t(struct activity *);\n__read_funct_t wrap_read_in\n\t(struct activity *);\n__read_funct_t wrap_read_meminfo_huge\n\t(struct activity *);\n__read_funct_t wrap_read_cpu_wghfreq\n\t(struct activity *);\n__read_funct_t wrap_read_bus_usb_dev\n\t(struct activity *);\n__read_funct_t wrap_read_filesystem\n\t(struct activity *);\n__read_funct_t wrap_read_fchost\n\t(struct activity *);\n__read_funct_t wrap_read_softnet\n\t(struct activity *);\n__read_funct_t wrap_read_psicpu\n\t(struct activity *);\n__read_funct_t wrap_read_psiio\n\t(struct activity *);\n__read_funct_t wrap_read_psimem\n\t(struct activity *);\n__read_funct_t wrap_read_bat\n\t(struct activity *);\n\n/* Other functions */\nint check_alt_sa_dir\n\t(char *, int, int);\nvoid enum_version_nr\n\t(struct file_magic *);\nint get_activity_nr\n\t(struct activity * [], unsigned int, enum count_mode);\nint get_activity_position\n\t(struct activity * [], unsigned int, int);\nvoid handle_invalid_sa_file\n\t(int, struct file_magic *, char *, int);\nvoid print_collect_error\n\t(void);\nvoid set_default_file\n\t(char *, int, int);\nint skip_extra_struct\n\t(int, int, int);\nint write_all\n\t(int, const void *, int);\n\n#ifndef SOURCE_SADC\nint add_list_item\n\t(struct sa_item **, char *, int, int *);\nvoid allocate_bitmaps\n\t(struct activity * []);\nvoid allocate_buffers\n\t(struct activity *, size_t, uint64_t);\nvoid allocate_minmax_buf\n\t(struct activity *, size_t, uint64_t);\nvoid allocate_structures\n\t(struct activity * [], uint64_t);\nint check_disk_reg\n\t(struct activity *, int, int, int);\nvoid check_file_actlst\n\t(int *, char *, struct activity * [], uint64_t, struct file_magic *,\n\t struct file_header *, struct file_activity **, unsigned int [], int *, int *);\nint check_net_dev_reg\n\t(struct activity *, int, int, int);\nint check_net_edev_reg\n\t(struct activity *, int, int, int);\nint check_time_limits\n\t(struct tstamp_ext *, struct tstamp_ext *);\ndouble compute_ifutil\n\t(struct stats_net_dev *, double, double);\nvoid copy_structures\n\t(struct activity * [], unsigned int [],\tstruct record_header [], int, int);\nint datecmp\n\t(struct tstamp_ext *, struct tstamp_ext *, int);\nvoid display_sa_file_version\n\t(FILE *, struct file_magic *);\nvoid free_bitmaps\n\t(struct activity * []);\nvoid free_structures\n\t(struct activity * []);\nchar *get_devname\n\t(unsigned int, unsigned int);\nchar *get_sa_devname\n\t(unsigned int, unsigned int, unsigned long long [], unsigned int, uint64_t);\nvoid get_file_timestamp_struct\n\t(uint64_t, struct tm *, struct file_header *);\nchar *get_fs_name_to_display\n\t(struct activity *, uint64_t, struct stats_filesystem *);\nunsigned long long get_global_cpu_statistics\n\t(struct activity *, int, int, uint64_t, unsigned char []);\nvoid get_global_int_statistics\n\t(struct activity *, int, int, uint64_t, unsigned char []);\nvoid get_global_soft_statistics\n\t(struct activity *, int, int, uint64_t, unsigned char []);\nvoid get_itv_value\n\t(struct record_header *, struct record_header *, unsigned long long *);\nvoid init_custom_color_palette\n\t(void);\nvoid init_extrema_values\n\t(struct activity *, int);\nvoid init_minmax_buf\n\t(struct activity *, size_t, size_t);\nint next_slice\n\t(unsigned long long, unsigned long long, int, long);\nvoid parse_sa_devices\n\t(char *, struct activity *, int, int *, int, int);\nint parse_sar_opt\n\t(char * [], int *, struct activity * [], uint64_t *, int);\nint parse_sa_P_opt\n\t(char * [], int *, uint64_t *, struct activity * []);\nint parse_sar_m_opt\n\t(char * [], int *, struct activity * []);\nint parse_sar_n_opt\n\t(char * [], int *, struct activity * []);\nint parse_sar_q_opt\n\t(char * [], int *, struct activity * []);\nint parse_timestamp\n\t(char * [], int *, struct tstamp_ext *, const char *, uint64_t);\nvoid print_minmax\n\t(int);\nvoid print_report_hdr\n\t(uint64_t, struct tm *, struct file_header *);\nvoid print_sar_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *,\n\t struct record_header *);\n__printf_funct_t print_sar_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\nint print_special_record\n\t(struct record_header *, uint64_t, struct tstamp_ext *, struct tstamp_ext *,\n\t int, int, struct tstamp_ext *, char *, int, char *, struct file_magic *,\n\t struct file_header *, struct activity * [], struct report_format *, int, int);\nint read_file_stat_bunch\n\t(struct activity * [], int, int, int, struct file_activity *, int, int,\n\t char *, struct file_magic *, enum on_eof, uint64_t);\n__nr_t read_nr_value\n\t(int, char *, struct file_magic *, int, int, int, __nr_t);\nint read_record_hdr\n\t(int, void *, struct record_header *, struct file_header *, int, int,\n\t int, size_t, uint64_t, struct report_format *);\nvoid reallocate_buffers\n\t(struct activity *, __nr_t, uint64_t);\nvoid reallocate_minmax_buf\n\t(struct activity *, __nr_t, uint64_t);\nvoid replace_nonprintable_char\n\t(int, char *);\nint sa_fread\n\t(int, void *, size_t, enum size_mode, enum on_eof);\nint sa_get_record_timestamp_struct\n\t(uint64_t, struct record_header *, struct tstamp_ext *);\nint sa_open_read_magic\n\t(int *, char *, struct file_magic *, int, int *, int);\nvoid save_extrema\n\t(const unsigned int [], void *, void *, unsigned long long,\n\t double *, double *, int []);\nvoid save_minmax\n\t(struct activity *, int, double);\nstruct sa_item *search_list_item\n\t(struct sa_item *, char *);\nvoid select_all_activities\n\t(struct activity * []);\nvoid select_default_activity\n\t(struct activity * []);\nvoid set_bitmaps\n\t(struct activity * [], uint64_t *);\nvoid set_hdr_rectime\n\t(unsigned int, struct tm *, struct file_header *);\nvoid set_record_timestamp_string\n\t(uint64_t, char *, char *, int, struct tstamp_ext *);\nvoid swap_struct\n\t(const unsigned int [], void *, int);\n#endif /* SOURCE_SADC undefined */\n#endif  /* _SA_H */\n"
        },
        {
          "name": "sa1.in",
          "type": "blob",
          "size": 1.6953125,
          "content": "#!/bin/sh\n# @SA_LIB_DIR@/sa1\n# (C) 1999-2024 Sebastien Godard (sysstat <at> orange.fr)\n#\n#@(#) @PACKAGE_NAME@-@PACKAGE_VERSION@\n#@(#) sa1: Collect and store binary data in system activity data file.\n#\n\n# Set default value for some variables.\n# Used only if ${SYSCONFIG_DIR}/${SYSCONFIG_FILE} doesn't exist!\nHISTORY=0\nSADC_OPTIONS=\"\"\nSA_DIR=@SA_DIR@\nSYSCONFIG_DIR=@SYSCONFIG_DIR@\nSYSCONFIG_FILE=@SYSCONFIG_FILE@\nUMASK=0022\nLONG_NAME=n\n\n[ -r ${SYSCONFIG_DIR}/${SYSCONFIG_FILE} ] && . ${SYSCONFIG_DIR}/${SYSCONFIG_FILE}\n\numask ${UMASK}\n\n# If the user-supplied value for SA_DIR in sysconfig file is not a directory\n# then fall back on default directory. Create this default directory if it doesn't exist.\n[ -d ${SA_DIR} ] || SA_DIR=@SA_DIR@\n[ -d @SA_DIR@ ] || mkdir @SA_DIR@\n\nif [ ${HISTORY} -gt 28 ]\nthen\n\tSADC_OPTIONS=\"${SADC_OPTIONS} -D\"\n\tLONG_NAME=y\nfi\n\nENDIR=@SA_LIB_DIR@\ncd ${ENDIR}\n[ \"$1\" = \"--boot\" ] && shift && BOOT=y || BOOT=n\n[ \"$1\" = \"--sleep\" ] && shift && SLEEP=y || SLEEP=n\n\nROTATE=n\n[ \"$1\" = \"--rotate\" ] && shift && ROTATE=y && [ \"$1\" = \"iso\" ] && shift && LONG_NAME=y\nif [ \"${ROTATE}\" = \"y\" ]\nthen\n\tif [ \"${LONG_NAME}\" = \"y\" ]\n\tthen\n\t\tDATE=`date --date=yesterday +%Y%m%d`\n\telse\n\t\tDATE=`date --date=yesterday +%d`\n\tfi\n\tSA_DIR=${SA_DIR}/sa${DATE}\nfi\n\nif [ \"${SLEEP}\" = \"y\" ]\nthen\n\texec ${ENDIR}/sadc -F -L ${SADC_OPTIONS} -C \"LINUX SLEEP MODE ($*)\" ${SA_DIR}\nelif [ $# = 0 ] && [ \"${BOOT}\" = \"n\" ]\nthen\n# Note: Stats are written at the end of previous file *and* at the\n# beginning of the new one (when there is a file rotation) only if\n# outfile has not been explicitly specified on the command line...\n\texec ${ENDIR}/sadc -F -L ${SADC_OPTIONS} 1 1 ${SA_DIR}\nelse\n\texec ${ENDIR}/sadc -F -L ${SADC_OPTIONS} $* ${SA_DIR}\nfi\n"
        },
        {
          "name": "sa2.in",
          "type": "blob",
          "size": 1.61328125,
          "content": "#!/bin/sh\n# @SA_LIB_DIR@/sa2\n# (C) 1999-2024 Sebastien Godard (sysstat <at> orange.fr)\n#\n#@(#) @PACKAGE_NAME@-@PACKAGE_VERSION@\n#@(#) sa2: Write a daily report\n#\nS_TIME_FORMAT=ISO ; export S_TIME_FORMAT\nprefix=@prefix@\nexec_prefix=@exec_prefix@\nSA_DIR=@SA_DIR@\nSYSCONFIG_DIR=@SYSCONFIG_DIR@\nSYSCONFIG_FILE=@SYSCONFIG_FILE@\nHISTORY=@HISTORY@\nCOMPRESSAFTER=@COMPRESSAFTER@\nZIP=\"@ZIP@\"\nUMASK=0022\nENDIR=@SAR_DIR@\nDELAY_RANGE=@DELAY_RANGE@\n\n# Read configuration file, overriding variables set above\n[ -r ${SYSCONFIG_DIR}/${SYSCONFIG_FILE} ] && . ${SYSCONFIG_DIR}/${SYSCONFIG_FILE}\n\numask ${UMASK}\n\n# Wait for a random delay if requested\nif [ ${DELAY_RANGE} -gt 0 ]\nthen\n\tRANDOM=$$\n\tDELAY=$((${RANDOM}%${DELAY_RANGE}))\n\tsleep ${DELAY}\nfi\n\n[ -d ${SA_DIR} ] || SA_DIR=@SA_DIR@\n\n# if YESTERDAY=no then today's summary is generated\nif [ x$YESTERDAY = xno ]\nthen\n\tDATE_OPTS=\nelse\n\tDATE_OPTS=\"--date=yesterday\"\nfi\n\nif [ ${HISTORY} -gt 28 ]\nthen\n\tDATE=`date ${DATE_OPTS} +%Y%m%d`\nelse\n\tDATE=`date ${DATE_OPTS} +%d`\nfi\nCURRENTFILE=sa${DATE}\nCURRENTRPT=sar${DATE}\n\nRPT=${SA_DIR}/${CURRENTRPT}\nDFILE=${SA_DIR}/${CURRENTFILE}\nif [ -z \"${ENDIR}\" ];\nthen\n       ENDIR=@bindir@\nfi\n\n[ -f \"${DFILE}\" ] || exit 0\ncd ${ENDIR}\nif [ x${REPORTS} != xfalse ]\nthen\n\tS_REPEAT_HEADER=${REPEAT_HEADER} ${ENDIR}/sar $* -f ${DFILE} > ${RPT}\nfi\n\nSAFILES_REGEX='/sar?[0-9]{2,8}(\\.(Z|gz|bz2|xz|lz|lzo))?$'\n\nfind \"${SA_DIR}\" -type f -mtime +${HISTORY} \\\n\t| grep -E \"${SAFILES_REGEX}\" \\\n\t| xargs   rm -f\n\nUNCOMPRESSED_SAFILES_REGEX='/sar?[0-9]{2,8}$'\n\nfind \"${SA_DIR}\" -type f -mtime +${COMPRESSAFTER} \\\n\t| grep -E \"${UNCOMPRESSED_SAFILES_REGEX}\" \\\n\t| xargs -r \"${ZIP}\" > /dev/null\n\nexit 0\n"
        },
        {
          "name": "sa_common.c",
          "type": "blob",
          "size": 111.38671875,
          "content": "/*\n * sar and sadf common routines.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\t/* For STDOUT_FILENO, among others */\n#include <dirent.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <libgen.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <float.h>\n\n#include \"version.h\"\n#include \"sa.h\"\n#include \"ioconf.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nint default_file_used = FALSE;\nextern struct act_bitmap cpu_bitmap;\nextern unsigned int dm_major;\n\nunsigned int hdr_types_nr[] = {FILE_HEADER_ULL_NR, FILE_HEADER_UL_NR, FILE_HEADER_U_NR};\nunsigned int act_types_nr[] = {FILE_ACTIVITY_ULL_NR, FILE_ACTIVITY_UL_NR, FILE_ACTIVITY_U_NR};\nunsigned int rec_types_nr[] = {RECORD_HEADER_ULL_NR, RECORD_HEADER_UL_NR, RECORD_HEADER_U_NR};\nunsigned int extra_desc_types_nr[] = {EXTRA_DESC_ULL_NR, EXTRA_DESC_UL_NR, EXTRA_DESC_U_NR};\n\n/*\n ***************************************************************************\n * Look for activity in array.\n *\n * IN:\n * @act\t\tArray of activities.\n * @act_flag\tActivity flag to look for.\n * @stop\tTRUE if sysstat should exit when activity is not found.\n *\n * RETURNS:\n * Position of activity in array, or -1 if not found (this may happen when\n * reading data from a system activity file created by another version of\n * sysstat).\n ***************************************************************************\n */\nint get_activity_position(struct activity *act[], unsigned int act_flag, int stop)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (act[i]->id == act_flag)\n\t\t\treturn i;\n\t}\n\n\tif (stop) {\n\t\tPANIC((int) act_flag);\n\t}\n\n\treturn -1;\n}\n\n/*\n ***************************************************************************\n * Count number of activities with given option.\n *\n * IN:\n * @act\t\tArray of activities.\n * @option\tOption that activities should have to be counted\n *\t\t(eg. AO_COLLECTED...)\n * @count\tSet to COUNT_OUTPUTS if each output should be counted for\n *\t\tactivities with\tmultiple outputs.\n *\n * RETURNS:\n * Number of selected activities\n ***************************************************************************\n */\nint get_activity_nr(struct activity *act[], unsigned int option, enum count_mode count)\n{\n\tint i, n = 0;\n\tunsigned int msk;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif ((act[i]->options & option) == option) {\n\n\t\t\tif (HAS_MULTIPLE_OUTPUTS(act[i]->options) && (count == COUNT_OUTPUTS)) {\n\t\t\t\tfor (msk = 1; msk < 0x100; msk <<= 1) {\n\t\t\t\t\tif ((act[i]->opt_flags & 0xff) & msk) {\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n;\n}\n\n/*\n ***************************************************************************\n * Look for the most recent of saDD and saYYYYMMDD to decide which one to\n * use. If neither exists then use saDD by default.\n *\n * IN:\n * @sa_dir\tDirectory where standard daily data files are saved.\n * @rectime\tStructure containing the current date.\n *\n * OUT:\n * @sa_name\t0 to use saDD data files,\n * \t\t1 to use saYYYYMMDD data files.\n ***************************************************************************\n */\nvoid guess_sa_name(char *sa_dir, struct tm *rectime, int *sa_name)\n{\n\tchar filename[MAX_FILE_LEN];\n\tstruct stat sb;\n\ttime_t sa_mtime;\n\tlong nsec;\n\n\t/* Use saDD by default */\n\t*sa_name = 0;\n\n\t/* Look for saYYYYMMDD */\n\tsnprintf(filename, sizeof(filename),\n\t\t \"%s/sa%04d%02d%02d\", sa_dir,\n\t\t rectime->tm_year + 1900,\n\t\t rectime->tm_mon + 1,\n\t\t rectime->tm_mday);\n\tfilename[sizeof(filename) - 1] = '\\0';\n\n\tif (stat(filename, &sb) < 0)\n\t\t/* Cannot find or access saYYYYMMDD, so use saDD */\n\t\treturn;\n\tsa_mtime = sb.st_mtime;\n#ifndef __APPLE__\n\tnsec = sb.st_mtim.tv_nsec;\n#else\n\tnsec = sb.st_mtimespec.tv_nsec;\n#endif\n\n\t/* Look for saDD */\n\tsnprintf(filename, sizeof(filename),\n\t\t \"%s/sa%02d\", sa_dir,\n\t\t rectime->tm_mday);\n\tfilename[sizeof(filename) - 1] = '\\0';\n\n\tif (stat(filename, &sb) < 0) {\n\t\t/* Cannot find or access saDD, so use saYYYYMMDD */\n\t\t*sa_name = 1;\n\t\treturn;\n\t}\n\n\tif ((sa_mtime > sb.st_mtime) ||\n#ifndef __APPLE__\n\t    ((sa_mtime == sb.st_mtime) && (nsec > sb.st_mtim.tv_nsec))\n#else\n\t    ((sa_mtime == sb.st_mtime) && (nsec > sb.st_mtimespec.tv_nsec))\n#endif\n\t) {\n\t\t/* saYYYYMMDD is more recent than saDD, so use it */\n\t\t*sa_name = 1;\n\t}\n}\n\n/*\n ***************************************************************************\n * Set current daily data file name.\n *\n * IN:\n * @datafile\tIf not an empty string then this is the alternate directory\n *\t\tlocation where daily data files will be saved.\n * @d_off\tDay offset (number of days to go back in the past).\n * @sa_name\t0 for saDD data files,\n * \t\t1 for saYYYYMMDD data files,\n * \t\t-1 if unknown. In this case, will look for the most recent\n * \t\tof saDD and saYYYYMMDD and use it.\n *\n * OUT:\n * @datafile\tName of daily data file.\n ***************************************************************************\n */\nvoid set_default_file(char *datafile, int d_off, int sa_name)\n{\n\tchar sa_dir[MAX_FILE_LEN];\n\tstruct tm rectime = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL};\n\tint err = 0;\n\n\t/* Set directory where daily data files will be saved */\n\tif (datafile[0]) {\n\t\tstrncpy(sa_dir, datafile, sizeof(sa_dir));\n\t}\n\telse {\n\t\tstrncpy(sa_dir, SA_DIR, sizeof(sa_dir));\n\t}\n\tsa_dir[sizeof(sa_dir) - 1] = '\\0';\n\n\tget_time(&rectime, d_off);\n\tif (sa_name < 0) {\n\t\t/*\n\t\t * Look for the most recent of saDD and saYYYYMMDD\n\t\t * and use it. If neither exists then use saDD.\n\t\t * sa_name is set accordingly.\n\t\t */\n\t\tguess_sa_name(sa_dir, &rectime, &sa_name);\n\t}\n\tif (sa_name) {\n\t\t/* Using saYYYYMMDD data files */\n\t\terr = snprintf(datafile, MAX_FILE_LEN,\n\t\t\t       \"%s/sa%04d%02d%02d\", sa_dir,\n\t\t\t       rectime.tm_year + 1900,\n\t\t\t       rectime.tm_mon + 1,\n\t\t\t       rectime.tm_mday);\n\t}\n\telse {\n\t\t/* Using saDD data files */\n\t\terr = snprintf(datafile, MAX_FILE_LEN,\n\t\t\t       \"%s/sa%02d\", sa_dir,\n\t\t\t       rectime.tm_mday);\n\t}\n\tdatafile[MAX_FILE_LEN - 1] = '\\0';\n\n\tif ((err < 0) || (err >= MAX_FILE_LEN)) {\n\t\tfprintf(stderr, \"%s: %s\\n\", __FUNCTION__, datafile);\n\t\texit(1);\n\t}\n\n\tdefault_file_used = TRUE;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"%s: Datafile: %s\\n\", __FUNCTION__, datafile);\n#endif\n}\n\n/*\n ***************************************************************************\n * Check data file type. If it is a directory then this is the alternate\n * location where daily data files will be saved.\n *\n * IN:\n * @datafile\tName of the daily data file. May be a directory.\n * @d_off\tDay offset (number of days to go back in the past).\n * @sa_name\t0 for saDD data files,\n * \t\t1 for saYYYYMMDD data files,\n * \t\t-1 if unknown. In this case, will look for the most recent\n * \t\tof saDD and saYYYYMMDD and use it.\n *\n *\n * OUT:\n * @datafile\tName of the daily data file. This is now a plain file, not\n * \t\ta directory.\n *\n * RETURNS:\n * 1 if @datafile was a directory, and 0 otherwise.\n ***************************************************************************\n */\nint check_alt_sa_dir(char *datafile, int d_off, int sa_name)\n{\n\tif (check_dir(datafile)) {\n\t\t/*\n\t\t * This is a directory: So append\n\t\t * the default file name to it.\n\t\t */\n\t\tset_default_file(datafile, d_off, sa_name);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Display sysstat version used to create system activity data file.\n *\n * IN:\n * @st\t\tOutput stream (stderr or stdout).\n * @file_magic\tFile magic header.\n ***************************************************************************\n */\nvoid display_sa_file_version(FILE *st, struct file_magic *file_magic)\n{\n\tfprintf(st, _(\"File created by sar/sadc from sysstat version %d.%d.%d\"),\n\t\tfile_magic->sysstat_version,\n\t\tfile_magic->sysstat_patchlevel,\n\t\tfile_magic->sysstat_sublevel);\n\n\tif (file_magic->sysstat_extraversion) {\n\t\tfprintf(st, \".%d\", file_magic->sysstat_extraversion);\n\t}\n\tfprintf(st, \"\\n\");\n}\n\n/*\n ***************************************************************************\n * An invalid system activity file has been opened for reading.\n * If this file was created by an old version of sysstat, tell it to the\n * user...\n *\n * IN:\n * @fd\t\tDescriptor of the file that has been opened.\n * @file_magic\tfile_magic structure filled with file magic header data.\n *\t\tMay contain invalid data.\n * @file\tName of the file being read.\n * @n\t\tNumber of bytes read while reading file magic header.\n * \t\tThis function may also be called after failing to read file\n *\t\tstandard header, or if CPU activity has not been found in\n *\t\tfile. In this case, n is set to 0.\n ***************************************************************************\n */\nvoid handle_invalid_sa_file(int fd, struct file_magic *file_magic, char *file,\n\t\t\t    int n)\n{\n\tfprintf(stderr, _(\"Invalid system activity file: %s\\n\"), file);\n\n\tif (n == FILE_MAGIC_SIZE) {\n\t\tif ((file_magic->sysstat_magic == SYSSTAT_MAGIC) || (file_magic->sysstat_magic == SYSSTAT_MAGIC_SWAPPED)) {\n\t\t\tunsigned short fmt_magic;\n\n\t\t\t/* This is a sysstat file, but this file has an old format */\n\t\t\tdisplay_sa_file_version(stderr, file_magic);\n\n\t\t\tfmt_magic = file_magic->sysstat_magic == SYSSTAT_MAGIC ?\n\t\t\t\t    file_magic->format_magic : __builtin_bswap16(file_magic->format_magic);\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Current sysstat version cannot read the format of this file (%#x)\\n\"),\n\t\t\t\tfmt_magic);\n\t\t\tif (fmt_magic >= FORMAT_MAGIC_2171) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"Try to convert it to current format. Enter:\\n\\n\"));\n\t\t\t\tfprintf(stderr, \"sadf -c %s > %s.new\\n\\n\", file, file);\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"You should then be able to read the new file created (%s.new)\\n\"),\n\t\t\t\t\tfile);\n\t\t\t}\n\t\t}\n\t}\n\n\tclose (fd);\n\texit(3);\n}\n\n/*\n ***************************************************************************\n * Display an error message then exit.\n ***************************************************************************\n */\nvoid print_collect_error(void)\n{\n\tfprintf(stderr, _(\"Requested activities not available\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * Fill system activity file magic header.\n *\n * IN:\n * @file_magic\tSystem activity file magic header.\n ***************************************************************************\n */\nvoid enum_version_nr(struct file_magic *fm)\n{\n\tchar *v;\n\tchar version[16];\n\n\tfm->sysstat_extraversion = 0;\n\n\tstrcpy(version, VERSION);\n\n\t/* Get version number */\n\tif ((v = strtok(version, \".\")) == NULL)\n\t\treturn;\n\tfm->sysstat_version = atoi(v) & 0xff;\n\n\t/* Get patchlevel number */\n\tif ((v = strtok(NULL, \".\")) == NULL)\n\t\treturn;\n\tfm->sysstat_patchlevel = atoi(v) & 0xff;\n\n\t/* Get sublevel number */\n\tif ((v = strtok(NULL, \".\")) == NULL)\n\t\treturn;\n\tfm->sysstat_sublevel = atoi(v) & 0xff;\n\n\t/* Get extraversion number. Don't necessarily exist */\n\tif ((v = strtok(NULL, \".\")) == NULL)\n\t\treturn;\n\tfm->sysstat_extraversion = atoi(v) & 0xff;\n}\n\n/*\n ***************************************************************************\n * Write data to file. If the write() call was interrupted by a signal, try\n * again so that the whole buffer can be written.\n *\n * IN:\n * @fd\t\tOutput file descriptor.\n * @buf\t\tData buffer.\n * @nr_bytes\tNumber of bytes to write.\n *\n * RETURNS:\n * Number of bytes written to file, or -1 on error.\n ***************************************************************************\n */\nint write_all(int fd, const void *buf, int nr_bytes)\n{\n\tint block, offset = 0;\n\tchar *buffer = (char *) buf;\n\n\twhile (nr_bytes > 0) {\n\n\t\tblock = write(fd, &buffer[offset], nr_bytes);\n\n\t\tif (block < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn block;\n\t\t}\n\t\tif (block == 0)\n\t\t\treturn offset;\n\n\t\toffset += block;\n\t\tnr_bytes -= block;\n\t}\n\n\treturn offset;\n}\n\n#ifndef SOURCE_SADC\n/*\n * **************************************************************************\n * Init buffers for min and max values.\n *\n * IN:\n * @a\t\tActivity for which buffers are to be initialized.\n * @start_slot\tFirst slot to init.\n * @nr_alloc\tNumber of slots to init.\n ***************************************************************************\n */\nvoid init_minmax_buf(struct activity *a, size_t start_slot, size_t nr_alloc)\n{\n\tint j;\n\tdouble *val;\n\n\tfor (j = start_slot * a->nr2 * a->xnr;\n\t     j < nr_alloc * a->nr2 * a->xnr; j++) {\n\t\tval = (double *) (a->spmin + j);\n\t\t*val = DBL_MAX;\n\t\tval = (double *) (a->spmax + j);\n\t\t*val = -DBL_MAX;\n\t     }\n}\n\n/*\n * **************************************************************************\n * Allocate buffers for min and max values.\n *\n * IN:\n * @a\t\tActivity for which buffers are to be initialized.\n * @nr_alloc\tNumber of slots to allocate.\n * @flags\tFlags for common options and system state.\n ***************************************************************************\n */\nvoid allocate_minmax_buf(struct activity *a, size_t nr_alloc, uint64_t flags)\n{\n\t/* nr_alloc should be greater than a->nr_spalloc */\n\tif (nr_alloc <= a->nr_spalloc) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: %s: alloc=%zu allocated=%d\\n\",\n\t\t\t__FUNCTION__, a->name, nr_alloc, a->nr_spalloc);\n#endif\n\t\treturn;\n\t}\n\n#ifdef DEBUG\n\tif (nr_alloc < a->nr_allocated) {\n\t\t/* Should never happen */\n\t\tfprintf(stderr, \"%s: %s: spalloc=%zu allocated=%d\\n\",\n\t\t\t__FUNCTION__, a->name, nr_alloc, a->nr_allocated);\n\t\texit(4);\n\t}\n#endif\n\n\tif (DISPLAY_MINMAX(flags) && a->xnr) {\n\n\t\t/* Look for a possible overflow */\n\t\tcheck_overflow((unsigned int) a->xnr,\n\t\t\t       (unsigned int) nr_alloc,\n\t\t\t       (unsigned int) a->nr2,\n\t\t\t       (unsigned int) sizeof(double));\n\n\t\t/* Allocate arrays for min and max values... */\n\t\tSREALLOC(a->spmin, void,\n\t\t\t nr_alloc * (size_t) a->nr2 * (size_t) a->xnr * sizeof(double));\n\t\tSREALLOC(a->spmax, void,\n\t\t\t nr_alloc * (size_t) a->nr2 * (size_t) a->xnr * sizeof(double));\n\n\t\t/* ... and init them */\n\t\tinit_minmax_buf(a, a->nr_spalloc, nr_alloc);\n\t\ta->nr_spalloc = nr_alloc;\n\t}\n}\n\n/*\n ***************************************************************************\n * Allocate buffers for one activity.\n *\n * IN:\n * @a\t\tActivity for which buffers are to be initialized.\n * @nr_alloc\tNumber of structures to allocate.\n * @flags\tFlags for common options and system state.\n ***************************************************************************\n */\nvoid allocate_buffers(struct activity *a, size_t nr_alloc, uint64_t flags)\n{\n\tint j;\n\n\t/* nr_alloc should always be greater than a->nr_allocated */\n\tif (nr_alloc <= a->nr_allocated) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: %s: alloc=%zu allocated=%d\\n\",\n\t\t\t__FUNCTION__, a->name, nr_alloc, a->nr_allocated);\n#endif\n\t\treturn;\n\t}\n\n\t/* Look for a possible overflow */\n\tcheck_overflow((unsigned int) a->msize,\n\t\t       (unsigned int) nr_alloc,\n\t\t       (unsigned int) a->nr2, 0);\n\n\tfor (j = 0; j < 3; j++) {\n\t\tSREALLOC(a->buf[j], void,\n\t\t\t (size_t) a->msize * nr_alloc * (size_t) a->nr2);\n\n\t\t/* If its a reallocation then init additional space which has been allocated */\n\t\tif (a->nr_allocated) {\n\t\t\tmemset((char *) a->buf[j] + a->msize * a->nr_allocated * a->nr2, 0,\n\t\t\t       (size_t) a->msize * (size_t) (nr_alloc - a->nr_allocated) * (size_t) a->nr2);\n\t\t}\n\t}\n\ta->nr_allocated = nr_alloc;\n\n\t/* Allocate buffers for min and max values if necessary */\n\tallocate_minmax_buf(a, nr_alloc, flags);\n}\n\n/*\n * **************************************************************************\n * Allocate structures for all activities.\n *\n * IN:\n * @act\t\tArray of activities.\n * @flags\tFlags for common options and system state.\n ***************************************************************************\n */\nvoid allocate_structures(struct activity *act[], uint64_t flags)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (act[i]->nr_ini > 0) {\n\t\t\tallocate_buffers(act[i], (size_t) act[i]->nr_ini, flags);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Free structures.\n *\n * IN:\n * @act\tArray of activities.\n ***************************************************************************\n */\nvoid free_structures(struct activity *act[])\n{\n\tint i, j;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (act[i]->nr_allocated > 0) {\n\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\tif (act[i]->buf[j]) {\n\t\t\t\t\tfree(act[i]->buf[j]);\n\t\t\t\t\tact[i]->buf[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tact[i]->nr_allocated = 0;\n\t\t}\n\n\t\tif (act[i]->nr_spalloc > 0) {\n\t\t\tif (act[i]->spmin) {\n\t\t\t\tfree(act[i]->spmin);\n\t\t\t\tact[i]->spmin = NULL;\n\t\t\t}\n\t\t\tif (act[i]->spmax) {\n\t\t\t\tfree(act[i]->spmax);\n\t\t\t\tact[i]->spmax = NULL;\n\t\t\t}\n\t\t\tact[i]->nr_spalloc = 0;\n\t\t}\n\t}\n}\n\n/*\n * **************************************************************************\n * Reallocate buffers for min/max values.\n *\n * IN:\n * @a\t\tActivity whose buffers need to be reallocated.\n * @nr_min\tMinimum number of items that the new buffers should be able\n *\t\tto receive.\n * @flags\tFlags for common options and system state.\n ***************************************************************************\n */\nvoid reallocate_minmax_buf(struct activity *a, __nr_t nr_min, uint64_t flags)\n{\n\tsize_t nr_realloc;\n\n\tif (nr_min <= 0) {\n\t\tnr_min = 1;\n\t}\n\tif (!a->nr_spalloc) {\n\t\tnr_realloc = nr_min;\n\t}\n\telse {\n\t\tnr_realloc = a->nr_spalloc;\n\t\tdo {\n\t\t\tnr_realloc = nr_realloc * 2;\n\t\t}\n\t\twhile (nr_realloc < nr_min);\n\t}\n\n\t/* Reallocate buffers for current activity */\n\tallocate_minmax_buf(a, nr_realloc, flags);\n}\n\n/*\n ***************************************************************************\n * Reallocate all the buffers for a given activity (main buffers and\n * spmin/spmax buffers).\n *\n * IN:\n * @a\t\tActivity whose buffers need to be reallocated.\n * @nr_min\tMinimum number of items that the new buffers should be able\n *\t\tto receive.\n * @flags\tFlags for common options and system state.\n ***************************************************************************\n */\nvoid reallocate_buffers(struct activity *a, __nr_t nr_min, uint64_t flags)\n{\n\tsize_t nr_realloc;\n\n\tif (nr_min <= 0) {\n\t\tnr_min = 1;\n\t}\n\tif (!a->nr_allocated) {\n\t\tnr_realloc = nr_min;\n\t}\n\telse {\n\t\tnr_realloc = a->nr_allocated;\n\t\tdo {\n\t\t\tnr_realloc = nr_realloc * 2;\n\t\t}\n\t\twhile (nr_realloc < nr_min);\n\t}\n\n\t/* Reallocate buffers for current activity */\n\tallocate_buffers(a, nr_realloc, flags);\n}\n\n/*\n ***************************************************************************\n * Check if we are close enough to desired interval.\n *\n * IN:\n * @uptime_ref\tUptime used as reference. This is the system uptime for the\n *\t\tfirst sample statistics, or the first system uptime after a\n *\t\tLINUX RESTART (in 1/100th of a second).\n * @uptime\tCurrent system uptime (in 1/100th of a second).\n * @reset\tTRUE if @last_uptime should be reset with @uptime_ref.\n * @interval\tInterval of time.\n *\n * RETURNS:\n * TRUE if we are actually close enough to desired interval, FALSE otherwise.\n ***************************************************************************\n*/\nint next_slice(unsigned long long uptime_ref, unsigned long long uptime,\n\t       int reset, long interval)\n{\n\tunsigned long file_interval, entry;\n\tstatic unsigned long long last_uptime = 0;\n\tint min, max, pt1, pt2;\n\tdouble f;\n\n\t/* uptime is expressed in 1/100th of a second */\n\tif (!last_uptime || reset) {\n\t\tlast_uptime = uptime_ref;\n\t}\n\n\t/* Interval cannot be greater than 0xffffffff here */\n\tf = ((double) ((uptime - last_uptime) & 0xffffffff)) / 100;\n\tfile_interval = (unsigned long) f;\n\tif ((f * 10) - (file_interval * 10) >= 5) {\n\t\tfile_interval++; /* Rounding to correct value */\n\t}\n\n\tlast_uptime = uptime;\n\n\tif (interval == 1)\n\t\t/* Smallest time interval: Always close enough to desired interval */\n\t\treturn TRUE;\n\n\t/*\n\t * A few notes about the \"algorithm\" used here to display selected entries\n\t * from the system activity file (option -f with -i flag):\n\t * Let Iu be the interval value given by the user on the command line,\n\t *     In the interval between current and previous sample,\n\t * and En the current sample (identified by its time stamp) in the file.\n\t * En will ne displayed if there is an integer p so that:\n\t * p * Iu belongs to [En - In/2, En + In/2[.\n\t */\n\tf = ((double) ((uptime - uptime_ref) & 0xffffffff)) / 100;\n\tentry = (unsigned long) f;\n\tif ((f * 10) - (entry * 10) >= 5) {\n\t\tentry++;\n\t}\n\n\tmin = entry - (file_interval / 2);\n\tmax = entry + (file_interval / 2) + (file_interval & 0x1);\n\tpt1 = (entry / interval) * interval;\n\tpt2 = ((entry / interval) + 1) * interval;\n\n\treturn (((pt1 >= min) && (pt1 < max)) || ((pt2 >= min) && (pt2 < max)));\n}\n\n/*\n ***************************************************************************\n * Use time stamp to fill tstamp_ext structure.\n *\n * IN:\n * @timestamp\tTimestamp to decode (format: HH:MM:SS).\n *\n * OUT:\n * @tse\t\tStructure containing the decoded timestamp.\n *\n * RETURNS:\n * 0 if the timestamp has been successfully decoded, 1 otherwise.\n ***************************************************************************\n */\nint decode_timestamp(char timestamp[], struct tstamp_ext *tse)\n{\n\ttimestamp[2] = timestamp[5] = '\\0';\n\n\tif ((strspn(timestamp, DIGITS) != 2) ||\n\t    (strspn(&timestamp[3], DIGITS) != 2) ||\n\t    (strspn(&timestamp[6], DIGITS) != 2))\n\t\treturn 1;\n\n\ttse->tm_time.tm_sec  = atoi(&timestamp[6]);\n\ttse->tm_time.tm_min  = atoi(&timestamp[3]);\n\ttse->tm_time.tm_hour = atoi(timestamp);\n\n\tif ((tse->tm_time.tm_sec < 0) || (tse->tm_time.tm_sec > 59) ||\n\t    (tse->tm_time.tm_min < 0) || (tse->tm_time.tm_min > 59) ||\n\t    (tse->tm_time.tm_hour < 0) || (tse->tm_time.tm_hour > 23)) {\n\t\ttse->use = NO_TIME;\n\t\treturn 1;\n\t}\n\n\ttse->use = USE_HHMMSS_T;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Use time stamp to fill tstamp_ext structure.\n *\n * IN:\n * @timestamp\tEpoch time to decode (format: number of seconds since\n *\t\tJanuray 1st 1970 00:00:00 UTC).\n * @flags\tFlags for common options and system state.\n *\n * OUT:\n * @tse\t\tStructure containing the decoded epoch time.\n *\n * RETURNS:\n * 0 if the epoch time has been successfully decoded, 1 otherwise.\n ***************************************************************************\n */\nint decode_epoch(char timestamp[], struct tstamp_ext *tse, uint64_t flags)\n{\n\ttse->epoch_time = atol(timestamp);\n\n\tif (!tse->epoch_time) {\n\t\ttse->use = NO_TIME;\n\t\treturn 1;\n\t}\n\n\ttse->use = USE_EPOCH_T;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Compare two timestamps.\n *\n * IN:\n * @rectime\tDate and time for current sample.\n * @tse\t\tTimestamp used as reference.\n * @cross_day\tTRUE if a new day has been started.\n *\n * RETURNS:\n * A positive value if @rectime is greater than @tse,\n * a negative one otherwise.\n * Also returns 0 if no valid time is saved in @tse.\n ***************************************************************************\n */\nint datecmp(struct tstamp_ext *rectime, struct tstamp_ext *tse, int cross_day)\n{\n\tint tm_hour;\n\n\tswitch (tse->use) {\n\n\t\tcase USE_HHMMSS_T:\n\t\t\t/*\n\t\t\t * This is necessary if we want to properly handle something like:\n\t\t\t * sar -s time_start -e time_end with\n\t\t\t * time_start(day D) > time_end(day D+1)\n\t\t\t*/\n\t\t\ttm_hour = rectime->tm_time.tm_hour + (24 * (cross_day != 0));\n\n\t\t\tif (tm_hour == tse->tm_time.tm_hour) {\n\t\t\t\tif (rectime->tm_time.tm_min == tse->tm_time.tm_min)\n\t\t\t\treturn (rectime->tm_time.tm_sec - tse->tm_time.tm_sec);\n\t\t\t\telse\n\t\t\t\t\treturn (rectime->tm_time.tm_min - tse->tm_time.tm_min);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (tm_hour - tse->tm_time.tm_hour);\n\n\t\tcase USE_EPOCH_T:\n\t\t\treturn (rectime->epoch_time - tse->epoch_time);\n\n\t\tdefault:\t/* NO_TIME */\n\t\t\treturn 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Parse a timestamp entered on the command line (hh:mm[:ss] or number of\n * seconds since the Epoch) and decode it.\n *\n * IN:\n * @argv\t\tArguments list.\n * @opt\t\t\tIndex in the arguments list.\n * @def_timestamp\tDefault timestamp to use.\n * @flags\t\tFlags for common options and system state.\n *\n * OUT:\n * @tse\t\t\tStructure containing the decoded timestamp.\n *\n * RETURNS:\n * 0 if the timestamp has been successfully decoded, 1 otherwise.\n ***************************************************************************\n */\nint parse_timestamp(char *argv[], int *opt, struct tstamp_ext *tse,\n\t\t    const char *def_timestamp, uint64_t flags)\n{\n\tchar timestamp[11];\n\tint ok = FALSE;\n\n\tif (argv[++(*opt)] && strncmp(argv[*opt], \"-\", 1)) {\n\t\tswitch (strlen(argv[*opt])) {\n\n\t\t\tcase 5:\n\t\t\t\tif (argv[*opt][2] != ':')\n\t\t\t\t\tbreak;\n\t\t\t\tstrncpy(timestamp, argv[(*opt)++], 5);\n\t\t\t\ttimestamp[5] = '\\0';\n\t\t\t\tstrcat(timestamp, \":00\");\n\t\t\t\tok = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tif ((argv[*opt][2] != ':') || (argv[*opt][5] != ':'))\n\t\t\t\t\tbreak;\n\t\t\t\tstrncpy(timestamp, argv[(*opt)++], 8);\n\t\t\t\tok = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tif (strspn(argv[*opt], DIGITS) == 10) {\n\t\t\t\t\t/* This is actually a timestamp */\n\t\t\t\t\tstrncpy(timestamp, argv[(*opt)++], 10);\n\t\t\t\t\ttimestamp[10] = '\\0';\n\n\t\t\t\t\treturn decode_epoch(timestamp, tse, flags);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\tstrncpy(timestamp, def_timestamp, 8);\n\t}\n\ttimestamp[8] = '\\0';\n\n\treturn decode_timestamp(timestamp, tse);\n}\n\n/*\n ***************************************************************************\n * Set interval value.\n *\n * IN:\n * @record_hdr_curr\tRecord with current sample statistics.\n * @record_hdr_prev\tRecord with previous sample statistics.\n *\n * OUT:\n * @itv\t\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\nvoid get_itv_value(struct record_header *record_hdr_curr,\n\t\t   struct record_header *record_hdr_prev,\n\t\t   unsigned long long *itv)\n{\n\t/* Interval value in jiffies */\n\t*itv = get_interval(record_hdr_prev->uptime_cs,\n\t\t\t    record_hdr_curr->uptime_cs);\n}\n\n/*\n ***************************************************************************\n * Fill the tm_time structure with the file's creation date, based on file's\n * time data saved in file header.\n * The resulting timestamp is expressed in the locale of the file creator or\n * in the user's own locale, depending on whether option -t has been used\n * or not.\n *\n * IN:\n * @flags\tFlags for common options and system state.\n * @file_hdr\tSystem activity file standard header.\n *\n * OUT:\n * @tm_time\tDate (and possibly time) from file header. Only the date,\n * \t\tnot the time, should be used by the caller.\n ***************************************************************************\n */\nvoid get_file_timestamp_struct(uint64_t flags, struct tm *tm_time,\n\t\t\t       struct file_header *file_hdr)\n{\n\ttime_t t = file_hdr->sa_ust_time;\n\n\tif (PRINT_TRUE_TIME(flags)) {\n\t\t/* Get local time. This is just to fill fields with a default value. */\n\t\tget_time(tm_time, 0);\n\n\t\ttm_time->tm_mday = file_hdr->sa_day;\n\t\ttm_time->tm_mon  = file_hdr->sa_month;\n\t\ttm_time->tm_year = file_hdr->sa_year;\n\t\t/*\n\t\t * Call mktime() to set DST (Daylight Saving Time) flag.\n\t\t * Has anyone a better way to do it?\n\t\t */\n\t\ttm_time->tm_hour = tm_time->tm_min = tm_time->tm_sec = 0;\n\t\tmktime(tm_time);\n\t}\n\telse {\n\t\tlocaltime_r(&t, tm_time);\n\t}\n}\n\n/*\n ***************************************************************************\n * Print report header.\n *\n * IN:\n * @flags\tFlags for common options and system state.\n * @file_hdr\tSystem activity file standard header.\n *\n * OUT:\n * @tm_time\tDate and time from file header.\n ***************************************************************************\n */\nvoid print_report_hdr(uint64_t flags, struct tm *tm_time,\n\t\t      struct file_header *file_hdr)\n{\n\n\t/* Get date of file creation */\n\tget_file_timestamp_struct(flags, tm_time, file_hdr);\n\n\t/*\n\t * Display the header.\n\t * NB: Number of CPU (value in [1, NR_CPUS + 1]).\n\t * \t1 means that there is only one proc and non SMP kernel.\n\t *\t2 means one proc and SMP kernel. Etc.\n\t */\n\tprint_gal_header(tm_time, file_hdr->sa_sysname, file_hdr->sa_release,\n\t\t\t file_hdr->sa_nodename, file_hdr->sa_machine,\n\t\t\t file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1,\n\t\t\t PLAIN_OUTPUT);\n}\n\n/*\n ***************************************************************************\n * Network interfaces may now be registered (and unregistered) dynamically.\n * This is what we try to guess here.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @ref\t\tIndex in array for sample statistics used as reference.\n * @pos\t\tIndex on current network interface.\n *\n * RETURNS:\n * Position of current network interface in array of sample statistics used\n * as reference.\n * -1 if it is a new interface (it was not present in array of stats used\n * as reference).\n * -2 if it is a known interface but which has been unregistered then\n * registered again on the interval.\n ***************************************************************************\n */\nint check_net_dev_reg(struct activity *a, int curr, int ref, int pos)\n{\n\tstruct stats_net_dev *sndc, *sndp;\n\tint j0, j = pos;\n\n\tif (!a->nr[ref])\n\t\t/*\n\t\t * No items found in previous iteration:\n\t\t * Current interface is necessarily new.\n\t\t */\n\t\treturn -1;\n\n\tif (j >= a->nr[ref]) {\n\t\tj = a->nr[ref] - 1;\n\t}\n\tj0 = j;\n\n\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + pos * a->msize);\n\n\tdo {\n\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[ref] + j * a->msize);\n\n\t\tif (!strcmp(sndc->interface, sndp->interface)) {\n\t\t\t/*\n\t\t\t * Network interface found.\n\t\t\t * If a counter has decreased, then we may assume that the\n\t\t\t * corresponding interface was unregistered, then registered again.\n\t\t\t */\n\t\t\tif ((sndc->rx_packets    < sndp->rx_packets)    ||\n\t\t\t    (sndc->tx_packets    < sndp->tx_packets)    ||\n\t\t\t    (sndc->rx_bytes      < sndp->rx_bytes)      ||\n\t\t\t    (sndc->tx_bytes      < sndp->tx_bytes)      ||\n\t\t\t    (sndc->rx_compressed < sndp->rx_compressed) ||\n\t\t\t    (sndc->tx_compressed < sndp->tx_compressed) ||\n\t\t\t    (sndc->multicast     < sndp->multicast)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special processing for rx_bytes (_packets) and\n\t\t\t\t * tx_bytes (_packets) counters: If the number of\n\t\t\t\t * bytes (packets) has decreased, whereas the number of\n\t\t\t\t * packets (bytes) has increased, then assume that the\n\t\t\t\t * relevant counter has met an overflow condition, and that\n\t\t\t\t * the interface was not unregistered, which is all the\n\t\t\t\t * more plausible that the previous value for the counter\n\t\t\t\t * was > ULLONG_MAX/2.\n\t\t\t\t * NB: the average value displayed will be wrong in this case...\n\t\t\t\t *\n\t\t\t\t * If such an overflow is detected, just set the flag. There is no\n\t\t\t\t * need to handle this in a special way: the difference is still\n\t\t\t\t * properly calculated if the result is of the same type (i.e.\n\t\t\t\t * unsigned long) as the two values.\n\t\t\t\t */\n\t\t\t\tint ovfw = FALSE;\n\n\t\t\t\tif ((sndc->rx_bytes   < sndp->rx_bytes)   &&\n\t\t\t\t    (sndc->rx_packets > sndp->rx_packets) &&\n\t\t\t\t    (sndp->rx_bytes   > (~0ULL >> 1))) {\n\t\t\t\t\tovfw = TRUE;\n\t\t\t\t}\n\t\t\t\tif ((sndc->tx_bytes   < sndp->tx_bytes)   &&\n\t\t\t\t    (sndc->tx_packets > sndp->tx_packets) &&\n\t\t\t\t    (sndp->tx_bytes   > (~0ULL >> 1))) {\n\t\t\t\t\tovfw = TRUE;\n\t\t\t\t}\n\t\t\t\tif ((sndc->rx_packets < sndp->rx_packets) &&\n\t\t\t\t    (sndc->rx_bytes   > sndp->rx_bytes)   &&\n\t\t\t\t    (sndp->rx_packets > (~0ULL >> 1))) {\n\t\t\t\t\tovfw = TRUE;\n\t\t\t\t}\n\t\t\t\tif ((sndc->tx_packets < sndp->tx_packets) &&\n\t\t\t\t    (sndc->tx_bytes   > sndp->tx_bytes)   &&\n\t\t\t\t    (sndp->tx_packets > (~0ULL >> 1))) {\n\t\t\t\t\tovfw = TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!ovfw)\n\t\t\t\t\t/*\n\t\t\t\t\t * OK: Assume here that the device was\n\t\t\t\t\t * actually unregistered.\n\t\t\t\t\t */\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t\treturn j;\n\t\t}\n\t\tif (++j >= a->nr[ref]) {\n\t\t\tj = 0;\n\t\t}\n\t}\n\twhile (j != j0);\n\n\t/* This is a newly registered interface */\n\treturn -1;\n}\n\n/*\n ***************************************************************************\n * Network interfaces may now be registered (and unregistered) dynamically.\n * This is what we try to guess here.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @ref\t\tIndex in array for sample statistics used as reference.\n * @pos\t\tIndex on current network interface.\n *\n * RETURNS:\n * Position of current network interface in array of sample statistics used\n * as reference.\n * -1 if it is a newly registered interface.\n * -2 if it is a known interface but which has been unregistered then\n * registered again on the interval.\n ***************************************************************************\n */\nint check_net_edev_reg(struct activity *a, int curr, int ref, int pos)\n{\n\tstruct stats_net_edev *snedc, *snedp;\n\tint j0, j = pos;\n\n\tif (!a->nr[ref])\n\t\t/*\n\t\t * No items found in previous iteration:\n\t\t * Current interface is necessarily new.\n\t\t */\n\t\treturn -1;\n\n\tif (j >= a->nr[ref]) {\n\t\tj = a->nr[ref] - 1;\n\t}\n\tj0 = j;\n\n\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + pos * a->msize);\n\n\tdo {\n\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[ref] + j * a->msize);\n\n\t\tif (!strcmp(snedc->interface, snedp->interface)) {\n\t\t\t/*\n\t\t\t * Network interface found.\n\t\t\t * If a counter has decreased, then we may assume that the\n\t\t\t * corresponding interface was unregistered, then registered again.\n\t\t\t */\n\t\t\tif ((snedc->tx_errors         < snedp->tx_errors)         ||\n\t\t\t    (snedc->collisions        < snedp->collisions)        ||\n\t\t\t    (snedc->rx_dropped        < snedp->rx_dropped)        ||\n\t\t\t    (snedc->tx_dropped        < snedp->tx_dropped)        ||\n\t\t\t    (snedc->tx_carrier_errors < snedp->tx_carrier_errors) ||\n\t\t\t    (snedc->rx_frame_errors   < snedp->rx_frame_errors)   ||\n\t\t\t    (snedc->rx_fifo_errors    < snedp->rx_fifo_errors)    ||\n\t\t\t    (snedc->tx_fifo_errors    < snedp->tx_fifo_errors))\n\t\t\t\t/*\n\t\t\t\t * OK: assume here that the device was\n\t\t\t\t * actually unregistered.\n\t\t\t\t */\n\t\t\t\treturn -2;\n\n\t\t\treturn j;\n\t\t}\n\t\tif (++j >= a->nr[ref]) {\n\t\t\tj = 0;\n\t\t}\n\t}\n\twhile (j != j0);\n\n\t/* This is a newly registered interface */\n\treturn -1;\n}\n\n/*\n ***************************************************************************\n * Disks may be registered dynamically (true in /proc/diskstats file).\n * This is what we try to guess here.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @ref\t\tIndex in array for sample statistics used as reference.\n * @pos\t\tIndex on current disk.\n *\n * RETURNS:\n * Position of current disk in array of sample statistics used as reference\n * -1 if it is a newly registered device.\n * -2 if it is a known device but which has been unregistered then registered\n * again on the interval.\n ***************************************************************************\n */\nint check_disk_reg(struct activity *a, int curr, int ref, int pos)\n{\n\tstruct stats_disk *sdc, *sdp;\n\tint j0, j = pos;\n\n\tif (!a->nr[ref])\n\t\t/*\n\t\t * No items found in previous iteration:\n\t\t * Current interface is necessarily new.\n\t\t */\n\t\treturn -1;\n\n\tif (j >= a->nr[ref]) {\n\t\tj = a->nr[ref] - 1;\n\t}\n\tj0 = j;\n\n\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + pos * a->msize);\n\n\tdo {\n\t\tsdp = (struct stats_disk *) ((char *) a->buf[ref] + j * a->msize);\n\n\t\tif ((sdc->major == sdp->major) &&\n\t\t    (sdc->minor == sdp->minor)) {\n\t\t\t/*\n\t\t\t * Disk found.\n\t\t\t * If all the counters have decreased then the likelyhood\n\t\t\t * is that the disk has been unregistered and a new disk inserted.\n\t\t\t * If only one or two have decreased then the likelyhood\n\t\t\t * is that the counter has simply wrapped.\n\t\t\t * Don't take into account a counter if its previous value was 0\n\t\t\t * (this may be a read-only device, or a kernel that doesn't\n\t\t\t * support discard stats yet...)\n\t\t\t */\n\t\t\tif ((sdc->nr_ios < sdp->nr_ios) &&\n\t\t\t    (!sdp->rd_sect || (sdc->rd_sect < sdp->rd_sect)) &&\n\t\t\t    (!sdp->wr_sect || (sdc->wr_sect < sdp->wr_sect)) &&\n\t\t\t    (!sdp->dc_sect || (sdc->dc_sect < sdp->dc_sect)))\n\t\t\t\t/* Same device registered again */\n\t\t\t\treturn -2;\n\n\t\t\treturn j;\n\t\t}\n\t\tif (++j >= a->nr[ref]) {\n\t\t\tj = 0;\n\t\t}\n\t}\n\twhile (j != j0);\n\n\t/* This is a newly registered device */\n\treturn -1;\n}\n\n/*\n ***************************************************************************\n * Allocate bitmaps for activities that have one.\n *\n * IN:\n * @act\t\tArray of activities.\n ***************************************************************************\n */\nvoid allocate_bitmaps(struct activity *act[])\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\t/*\n\t\t * If current activity has a bitmap which has not already\n\t\t * been allocated, then allocate it.\n\t\t * Note that a same bitmap may be used by several activities.\n\t\t */\n\t\tif (act[i]->bitmap && !act[i]->bitmap->b_array) {\n\t\t\tSREALLOC(act[i]->bitmap->b_array, unsigned char,\n\t\t\t\t BITMAP_SIZE(act[i]->bitmap->b_size));\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Free bitmaps for activities that have one.\n *\n * IN:\n * @act\t\tArray of activities.\n ***************************************************************************\n */\nvoid free_bitmaps(struct activity *act[])\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (act[i]->bitmap && act[i]->bitmap->b_array) {\n\t\t\tfree(act[i]->bitmap->b_array);\n\t\t\t/* Set pointer to NULL to prevent it from being freed again */\n\t\t\tact[i]->bitmap->b_array = NULL;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Select all activities, even if they have no associated items.\n *\n * IN:\n * @act\t\tArray of activities.\n *\n * OUT:\n * @act\t\tArray of activities, all of the being selected.\n ***************************************************************************\n */\nvoid select_all_activities(struct activity *act[])\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tact[i]->options |= AO_SELECTED;\n\t}\n}\n\n/*\n ***************************************************************************\n * Select CPU activity if no other activities have been explicitly selected.\n * Also select CPU \"all\" if no other CPU has been selected.\n *\n * IN:\n * @act\t\tArray of activities.\n *\n * OUT:\n * @act\t\tArray of activities with CPU activity selected if needed.\n ***************************************************************************\n */\nvoid select_default_activity(struct activity *act[])\n{\n\tint p;\n\n\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\n\t/* Default is CPU activity... */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES)) {\n\t\t/*\n\t\t * Yet A_CPU activity may not be available in file\n\t\t * since the user can choose not to collect it.\n\t\t */\n\t\tact[p]->options |= AO_SELECTED;\n\t}\n\n\t/*\n\t * If no CPU's have been selected then select CPU \"all\".\n\t * cpu_bitmap bitmap may be used by several activities (A_CPU, A_PWR_CPU...)\n\t */\n\tif (!count_bits(cpu_bitmap.b_array, BITMAP_SIZE(cpu_bitmap.b_size))) {\n\t\tcpu_bitmap.b_array[0] |= 0x01;\n\t}\n}\n\n/*\n ***************************************************************************\n * Swap bytes for every numerical field in structure. Used to convert from\n * one endianness type (big-endian or little-endian) to the other.\n *\n * IN:\n * @types_nr\tNumber of fields in structure for each following types:\n *\t\tunsigned long long, unsigned long and int.\n * @ps\t\tPointer on structure.\n * @is64bit\tTRUE if data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid swap_struct(const unsigned int types_nr[], void *ps, int is64bit)\n{\n\tint i;\n\tuint64_t *x;\n\tuint32_t *y;\n\n\tx = (uint64_t *) ps;\n\t/* For each field of type long long (or double) */\n\tfor (i = 0; i < types_nr[0]; i++) {\n\t\t*x = __builtin_bswap64(*x);\n\t\tx = (uint64_t *) ((char *) x + ULL_ALIGNMENT_WIDTH);\n\t}\n\n\ty = (uint32_t *) x;\n\t/* For each field of type long */\n\tfor (i = 0; i < types_nr[1]; i++) {\n\t\tif (is64bit) {\n\t\t\t*x = __builtin_bswap64(*x);\n\t\t\tx = (uint64_t *) ((char *) x + UL_ALIGNMENT_WIDTH);\n\t\t}\n\t\telse {\n\t\t\t*y = __builtin_bswap32(*y);\n\t\t\ty = (uint32_t *) ((char *) y + UL_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n\n\tif (is64bit) {\n\t\ty = (uint32_t *) x;\n\t}\n\t/* For each field of type int */\n\tfor (i = 0; i < types_nr[2]; i++) {\n\t\t*y = __builtin_bswap32(*y);\n\t\ty = (uint32_t *) ((char *) y + U_ALIGNMENT_WIDTH);\n\t}\n}\n\n/*\n ***************************************************************************\n * Map the fields of a structure containing statistics read from a file to\n * those of the structure known by current sysstat version.\n * Each structure (either read from file or from current sysstat version)\n * is described by 3 values: The number of [unsigned] long long integers,\n * the number of [unsigned] long integers following in the structure, and\n * last the number of [unsigned] integers.\n * We assume that those numbers will *never* decrease with newer sysstat\n * versions.\n *\n * IN:\n * @gtypes_nr\tStructure description as expected for current sysstat version.\n * @ftypes_nr\tStructure description as read from file.\n * @ps\t\tPointer on structure containing statistics.\n * @f_size\tSize of the structure containing statistics. This is the\n *\t\tsize of the structure *read from file*.\n * @g_size\tSize of the structure expected by current sysstat version.\n * @b_size\tSize of the buffer pointed by @ps.\n *\n * RETURNS:\n * -1 if an error has been encountered, or 0 otherwise.\n ***************************************************************************\n */\nint remap_struct(const unsigned int gtypes_nr[], const unsigned int ftypes_nr[],\n\t\t void *ps, unsigned int f_size, unsigned int g_size, size_t b_size)\n{\n\tint d;\n\tsize_t n;\n\n\t/* Sanity check */\n\tif (MAP_SIZE(ftypes_nr) > f_size)\n\t\treturn -1;\n\n\t/* Remap [unsigned] long fields */\n\td = gtypes_nr[0] - ftypes_nr[0];\n\tif (d) {\n\t\tif (ftypes_nr[0] * ULL_ALIGNMENT_WIDTH < ftypes_nr[0])\n\t\t\t/* Overflow */\n\t\t\treturn -1;\n\n\t\tn = MINIMUM(f_size - ftypes_nr[0] * ULL_ALIGNMENT_WIDTH,\n\t\t\t    g_size - gtypes_nr[0] * ULL_ALIGNMENT_WIDTH);\n\t\tif ((ftypes_nr[0] * ULL_ALIGNMENT_WIDTH >= b_size) ||\n\t\t    (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + n > b_size) ||\n\t\t    (ftypes_nr[0] * ULL_ALIGNMENT_WIDTH + n > b_size))\n\t\t\treturn -1;\n\n\t\tmemmove(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH,\n\t\t\t((char *) ps) + ftypes_nr[0] * ULL_ALIGNMENT_WIDTH, n);\n\t\tif (d > 0) {\n\t\t\tmemset(((char *) ps) + ftypes_nr[0] * ULL_ALIGNMENT_WIDTH,\n\t\t\t       0, d * ULL_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n\t/* Remap [unsigned] int fields */\n\td = gtypes_nr[1] - ftypes_nr[1];\n\tif (d) {\n\t\tif (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t    ftypes_nr[1] * UL_ALIGNMENT_WIDTH < ftypes_nr[1])\n\t\t\t/* Overflow */\n\t\t\treturn -1;\n\n\t\tn = MINIMUM(f_size - ftypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t   - ftypes_nr[1] * UL_ALIGNMENT_WIDTH,\n\t\t\t    g_size - gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t   - gtypes_nr[1] * UL_ALIGNMENT_WIDTH);\n\t\tif ((gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t     ftypes_nr[1] * UL_ALIGNMENT_WIDTH >= b_size) ||\n\t\t    (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t     gtypes_nr[1] * UL_ALIGNMENT_WIDTH + n > b_size) ||\n\t\t    (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t     ftypes_nr[1] * UL_ALIGNMENT_WIDTH + n > b_size))\n\t\t\treturn -1;\n\n\t\tmemmove(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t      + gtypes_nr[1] * UL_ALIGNMENT_WIDTH,\n\t\t\t((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t      + ftypes_nr[1] * UL_ALIGNMENT_WIDTH, n);\n\t\tif (d > 0) {\n\t\t\tmemset(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t\t     + ftypes_nr[1] * UL_ALIGNMENT_WIDTH,\n\t\t\t       0, d * UL_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n\t/* Remap possible fields (like strings of chars) following int fields */\n\td = gtypes_nr[2] - ftypes_nr[2];\n\tif (d) {\n\t\tif (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t    gtypes_nr[1] * UL_ALIGNMENT_WIDTH +\n\t\t    ftypes_nr[2] * U_ALIGNMENT_WIDTH < ftypes_nr[2])\n\t\t\t/* Overflow */\n\t\t\treturn -1;\n\n\t\tn = MINIMUM(f_size - ftypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t   - ftypes_nr[1] * UL_ALIGNMENT_WIDTH\n\t\t\t\t   - ftypes_nr[2] * U_ALIGNMENT_WIDTH,\n\t\t\t    g_size - gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t   - gtypes_nr[1] * UL_ALIGNMENT_WIDTH\n\t\t\t\t   - gtypes_nr[2] * U_ALIGNMENT_WIDTH);\n\t\tif ((gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t     gtypes_nr[1] * UL_ALIGNMENT_WIDTH +\n\t\t     ftypes_nr[2] * U_ALIGNMENT_WIDTH >= b_size) ||\n\t\t    (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t     gtypes_nr[1] * UL_ALIGNMENT_WIDTH +\n\t\t     gtypes_nr[2] * U_ALIGNMENT_WIDTH + n > b_size) ||\n\t\t    (gtypes_nr[0] * ULL_ALIGNMENT_WIDTH +\n\t\t     gtypes_nr[1] * UL_ALIGNMENT_WIDTH +\n\t\t     ftypes_nr[2] * U_ALIGNMENT_WIDTH + n > b_size))\n\t\t\treturn -1;\n\n\t\tmemmove(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t      + gtypes_nr[1] * UL_ALIGNMENT_WIDTH\n\t\t\t\t      + gtypes_nr[2] * U_ALIGNMENT_WIDTH,\n\t\t\t((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t      + gtypes_nr[1] * UL_ALIGNMENT_WIDTH\n\t\t\t\t      + ftypes_nr[2] * U_ALIGNMENT_WIDTH, n);\n\t\tif (d > 0) {\n\t\t\tmemset(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH\n\t\t\t\t\t     + gtypes_nr[1] * UL_ALIGNMENT_WIDTH\n\t\t\t\t\t     + ftypes_nr[2] * U_ALIGNMENT_WIDTH,\n\t\t\t       0, d * U_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read data from a system activity data file.\n *\n * IN:\n * @ifd\t\tInput file descriptor.\n * @buffer\tBuffer where data are read.\n * @size\tNumber of bytes to read.\n * @mode\tIf set to HARD_SIZE, indicate that an EOF should be considered\n * \t\tas an error.\n * @oneof\tSet to UEOF_CONT if an unexpected end of file should not make\n *\t\tsadf stop. Default behavior is to stop on unexpected EOF.\n *\n * RETURNS:\n * 1 if EOF has been reached,\n * 2 if an unexpected EOF has been reached (and sadf was told to continue),\n * 0 otherwise.\n ***************************************************************************\n */\nint sa_fread(int ifd, void *buffer, size_t size, enum size_mode mode, enum on_eof oneof)\n{\n\tssize_t n;\n\n\tif ((n = read(ifd, buffer, size)) < 0) {\n\t\tfprintf(stderr, _(\"Error while reading system activity file: %s\\n\"),\n\t\t\tstrerror(errno));\n\t\tclose(ifd);\n\t\texit(2);\n\t}\n\n\tif (!n && (mode == SOFT_SIZE))\n\t\treturn 1;\t/* EOF */\n\n\tif (n < size) {\n\t\tfprintf(stderr, _(\"End of system activity file unexpected\\n\"));\n\t\tif (oneof == UEOF_CONT)\n\t\t\treturn 2;\n\t\tclose(ifd);\n\t\texit(2);\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Skip unknown extra structures present in file.\n *\n * IN:\n * @ifd\t\tSystem activity data file descriptor.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @arch_64\tTRUE if file's data come from a 64 bit machine.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n ***************************************************************************\n */\nint skip_extra_struct(int ifd, int endian_mismatch, int arch_64)\n{\n\tint i;\n\tstruct extra_desc xtra_d;\n\n\tdo {\n\t\t/* Read extra structure description */\n\t\tsa_fread(ifd, &xtra_d, EXTRA_DESC_SIZE, HARD_SIZE, UEOF_STOP);\n\n\t\t/*\n\t\t * We don't need to remap as the extra_desc structure won't change,\n\t\t * but we may need to normalize endianness anyway.\n\t\t */\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(extra_desc_types_nr, &xtra_d, arch_64);\n\t\t}\n\n\t\t/* Check values consistency */\n\t\tif (MAP_SIZE(xtra_d.extra_types_nr) > xtra_d.extra_size) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: extra_size=%u types=%u,%u,%u\\n\",\n\t\t\t\t__FUNCTION__, xtra_d.extra_size,\n\t\t\t\txtra_d.extra_types_nr[0], xtra_d.extra_types_nr[1], xtra_d.extra_types_nr[2]);\n#endif\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((xtra_d.extra_nr > MAX_EXTRA_NR) || (xtra_d.extra_size > MAX_EXTRA_SIZE)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: extra_size=%u extra_nr=%u\\n\",\n\t\t\t\t__FUNCTION__, xtra_d.extra_size, xtra_d.extra_size);\n#endif\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Ignore current unknown extra structures */\n\t\tfor (i = 0; i < xtra_d.extra_nr; i++) {\n\t\t\tif (lseek(ifd, xtra_d.extra_size, SEEK_CUR) < xtra_d.extra_size)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\twhile (xtra_d.extra_next);\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read the record header of current sample and process it.\n *\n * IN:\n * @ifd\t\tInput file descriptor.\n * @buffer\tBuffer where data will be read.\n * @record_hdr\tStructure where record header will be saved.\n * @file_hdr\tfile_hdr structure containing data read from file standard\n *\t\theader.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current machine's\n *\t\tendianness.\n * @oneof\tSet to EOF_CONT if an unexpected end of file should not make\n *\t\tsadf stop. Default behavior is to stop on unexpected EOF.\n * @b_size\t@buffer size.\n * @flags\tFlags for common options and system state.\n * @ofmt\tPointer on report output format structure.\n *\n * OUT:\n * @record_hdr\tRecord header for current sample.\n *\n * RETURNS:\n * 1 if EOF has been reached, 0 otherwise.\n ***************************************************************************\n */\nint read_record_hdr(int ifd, void *buffer, struct record_header *record_hdr,\n\t\t    struct file_header *file_hdr, int arch_64, int endian_mismatch,\n\t\t    int oneof, size_t b_size, uint64_t flags, struct report_format *ofmt)\n{\n\tint rc;\n\n\tdo {\n\t\tif ((rc = sa_fread(ifd, buffer, (size_t) file_hdr->rec_size, SOFT_SIZE, oneof)) != 0)\n\t\t\t/* End of sa data file */\n\t\t\treturn rc;\n\n\t\t/* Remap record header structure to that expected by current version */\n\t\tif (remap_struct(rec_types_nr, file_hdr->rec_types_nr, buffer,\n\t\t\t\t file_hdr->rec_size, RECORD_HEADER_SIZE, b_size) < 0)\n\t\t\tgoto invalid_data;\n\t\tmemcpy(record_hdr, buffer, RECORD_HEADER_SIZE);\n\n\t\t/* Normalize endianness */\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(rec_types_nr, record_hdr, arch_64);\n\t\t}\n\n\t\t/* Raw output in debug mode */\n\t\tif (DISPLAY_DEBUG_MODE(flags) && (ofmt->id == F_RAW_OUTPUT)) {\n\t\t\tchar out[128];\n\n\t\t\tsprintf(out, \"# uptime_cs; %llu; ust_time; %llu; extra_next; %u; record_type; %d; HH:MM:SS; %02d:%02d:%02d\\n\",\n\t\t\t       record_hdr->uptime_cs, record_hdr->ust_time,\n\t\t\t       record_hdr->extra_next, record_hdr->record_type,\n\t\t\t       record_hdr->hour, record_hdr->minute, record_hdr->second);\n\t\t\tcprintf_s(IS_COMMENT, \"%s\", out);\n\t\t}\n\n\t\t/* Sanity checks */\n\t\tif (!record_hdr->record_type || (record_hdr->record_type > R_EXTRA_MAX) ||\n\t\t    (record_hdr->hour > 23) || (record_hdr->minute > 59) || (record_hdr->second > 60) || (record_hdr->ust_time < 1000000000)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: record_type=%d HH:MM:SS=%02d:%02d:%02d (%llu)\\n\",\n\t\t\t\t__FUNCTION__, record_hdr->record_type,\n\t\t\t\trecord_hdr->hour, record_hdr->minute, record_hdr->second,\n\t\t\t\trecord_hdr->ust_time);\n#endif\n\t\t\tgoto invalid_data;\n\t\t}\n\n\t\t/*\n\t\t * Skip unknown extra structures if present.\n\t\t * This will be done later for R_COMMENT and R_RESTART records, as extra structures\n\t\t * are saved after the comment or the number of CPU.\n\t\t */\n\t\tif ((record_hdr->record_type != R_COMMENT) && (record_hdr->record_type != R_RESTART) &&\n\t\t    record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\tgoto invalid_data;\n\t}\n\twhile ((record_hdr->record_type >= R_EXTRA_MIN) && (record_hdr->record_type <= R_EXTRA_MAX)) ;\n\n\treturn 0;\n\ninvalid_data:\n\tfprintf(stderr, _(\"Invalid data read\\n\"));\n\texit(2);\n}\n\n/*\n ***************************************************************************\n * Move structures data.\n *\n * IN:\n * @act\t\tArray of activities.\n * @id_seq\tActivity sequence in file.\n * @record_hdr\tCurrent record header.\n * @dest\tIndex in array where stats have to be copied to.\n * @src\t\tIndex in array where stats to copy are.\n ***************************************************************************\n */\nvoid copy_structures(struct activity *act[], unsigned int id_seq[],\n\t\t     struct record_header record_hdr[], int dest, int src)\n{\n\tint i, p;\n\n\tmemcpy(&record_hdr[dest], &record_hdr[src], RECORD_HEADER_SIZE);\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\n\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\n\t\tmemcpy(act[p]->buf[dest], act[p]->buf[src],\n\t\t       (size_t) act[p]->msize * (size_t) act[p]->nr_allocated * (size_t) act[p]->nr2);\n\t\tact[p]->nr[dest] = act[p]->nr[src];\n\t}\n}\n\n/*\n ***************************************************************************\n * Read an __nr_t value from file.\n * Such a value can be the new number of CPU saved after a RESTART record,\n * or the number of structures to read saved before the structures containing\n * statistics for an activity with a varying number of items in file.\n *\n * IN:\n * @ifd\t\tInput file descriptor.\n * @file\tName of file being read.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @arch_64\tTRUE if file's data come from a 64 bit machine.\n * @non_zero\tTRUE if value should not be zero.\n * @maxv\tMaximum value allowed.\n *\n * RETURNS:\n * __nr_t value, as read from file.\n ***************************************************************************\n */\n__nr_t read_nr_value(int ifd, char *file, struct file_magic *file_magic,\n\t\t     int endian_mismatch, int arch_64, int non_zero, __nr_t maxv)\n{\n\t__nr_t value;\n\tunsigned int nr_types_nr[]  = {0, 0, 1};\n\n\tsa_fread(ifd, &value, sizeof(__nr_t), HARD_SIZE, UEOF_STOP);\n\n\t/* Normalize endianness for file_activity structures */\n\tif (endian_mismatch) {\n\t\tswap_struct(nr_types_nr, &value, arch_64);\n\t}\n\n\tif ((non_zero && !value) || (value < 0) || (value > maxv)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: Value=%d Max=%d\\n\",\n\t\t\t__FUNCTION__, value, maxv);\n#endif\n\t\t/* Value number cannot be zero or negative */\n\t\thandle_invalid_sa_file(ifd, file_magic, file, 0);\n\t}\n\n\treturn value;\n}\n\n/*\n ***************************************************************************\n * Read varying part of the statistics from a daily data file.\n *\n * IN:\n * @act\t\tArray of activities.\n * @curr\tIndex in array for current sample statistics.\n * @ifd\t\tInput file descriptor.\n * @act_nr\tNumber of activities in file.\n * @file_actlst\tActivity list in file.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @arch_64\tTRUE if file's data come from a 64 bit machine.\n * @dfile\tName of system activity data file.\n * @file_magic\tfile_magic structure containing data read from file magic\n *\t\theader.\n * @oneof\tSet to UEOF_CONT if an unexpected end of file should not make\n *\t\tsadf stop. Default behavior is to stop on unexpected EOF.\n * @flags\tFlags for common options and system state.\n *\n * RETURNS:\n * 2 if an error has been encountered (e.g. unexpected EOF),\n * 0 otherwise.\n ***************************************************************************\n */\nint read_file_stat_bunch(struct activity *act[], int curr, int ifd, int act_nr,\n\t\t\t struct file_activity *file_actlst, int endian_mismatch,\n\t\t\t int arch_64, char *dfile, struct file_magic *file_magic,\n\t\t\t enum on_eof oneof, uint64_t flags)\n{\n\tint i, j, p;\n\tstruct file_activity *fal = file_actlst;\n\toff_t offset;\n\t__nr_t nr_value;\n\n\tfor (i = 0; i < act_nr; i++, fal++) {\n\n\t\t/* Read __nr_t value preceding statistics structures if it exists */\n\t\tif (fal->has_nr) {\n\t\t\tnr_value = read_nr_value(ifd, dfile, file_magic,\n\t\t\t\t\t\t endian_mismatch, arch_64, FALSE, NR_MAX);\n\t\t}\n\t\telse {\n\t\t\tnr_value = fal->nr;\n\t\t}\n\n\t\tif (nr_value > NR_MAX) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: Value=%d Max=%d\\n\", __FUNCTION__, nr_value, NR_MAX);\n#endif\n\t\t\thandle_invalid_sa_file(ifd, file_magic, dfile, 0);\n\t\t}\n\n\t\tif (((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0) ||\n\t\t    (act[p]->magic != fal->magic)) {\n\t\t\t/*\n\t\t\t * Ignore current activity in file, which is unknown to\n\t\t\t * current sysstat version or has an unknown format.\n\t\t\t */\n\t\t\tif (nr_value) {\n\t\t\t\toffset = (off_t) fal->size * (off_t) nr_value * (off_t) fal->nr2;\n\t\t\t\tif (lseek(ifd, offset, SEEK_CUR) < offset) {\n\t\t\t\t\tclose(ifd);\n\t\t\t\t\tperror(\"lseek\");\n\t\t\t\t\tif (oneof == UEOF_CONT)\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\texit(2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nr_value > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: %s: Value=%d Max=%d\\n\",\n\t\t\t\t__FUNCTION__, act[p]->name, nr_value, act[p]->nr_max);\n#endif\n\t\t\thandle_invalid_sa_file(ifd, file_magic, dfile, 0);\n\t\t}\n\t\tact[p]->nr[curr] = nr_value;\n\n\t\t/* Reallocate buffers if needed */\n\t\tif (nr_value > act[p]->nr_allocated) {\n\t\t\treallocate_buffers(act[p], nr_value, flags);\n\t\t}\n\n\t\t/*\n                 * For persistent activities, we must make sure that no statistics\n                 * from a previous iteration remain, especially if the number\n                 * of structures read is smaller than @nr_ini.\n                 */\n\t\tif (HAS_PERSISTENT_VALUES(act[p]->options)) {\n                    memset(act[p]->buf[curr], 0,\n                           (size_t) act[p]->msize * (size_t) act[p]->nr_ini * (size_t) act[p]->nr2);\n                }\n\n\t\t/* OK, this is a known activity: Read the stats structures */\n\t\tif ((nr_value > 0) &&\n\t\t    ((nr_value > 1) || (act[p]->nr2 > 1)) &&\n\t\t    (act[p]->msize > act[p]->fsize)) {\n\n\t\t\tfor (j = 0; j < (nr_value * act[p]->nr2); j++) {\n\t\t\t\tif (sa_fread(ifd, (char *) act[p]->buf[curr] + j * act[p]->msize,\n\t\t\t\t\t (size_t) act[p]->fsize, HARD_SIZE, oneof) > 0)\n\t\t\t\t\t/* Unexpected EOF */\n\t\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t\telse if (nr_value > 0) {\n\t\t\t/*\n\t\t\t * Note: If msize was smaller than fsize,\n\t\t\t * then it has been set to fsize in check_file_actlst().\n\t\t\t */\n\t\t\tif (sa_fread(ifd, act[p]->buf[curr],\n\t\t\t\t (size_t) act[p]->fsize * (size_t) nr_value * (size_t) act[p]->nr2,\n\t\t\t\t HARD_SIZE, oneof) > 0)\n\t\t\t\t/* Unexpected EOF */\n\t\t\t\treturn 2;\n\t\t}\n\t\telse {\n\t\t\t/* nr_value == 0: Nothing to read */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Normalize endianness for current activity's structures */\n\t\tif (endian_mismatch) {\n\t\t\tfor (j = 0; j < (nr_value * act[p]->nr2); j++) {\n\t\t\t\tswap_struct(act[p]->ftypes_nr, (char *) act[p]->buf[curr] + j * act[p]->msize,\n\t\t\t\t\t    arch_64);\n\t\t\t}\n\t\t}\n\n\t\t/* Remap structure's fields to those known by current sysstat version */\n\t\tfor (j = 0; j < (nr_value * act[p]->nr2); j++) {\n\t\t\tif (remap_struct(act[p]->gtypes_nr, act[p]->ftypes_nr,\n\t\t\t\t\t (char *) act[p]->buf[curr] + j * act[p]->msize,\n\t\t\t\t\t act[p]->fsize, act[p]->msize, act[p]->msize) < 0)\n\t\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Open a sysstat activity data file and read its magic structure.\n *\n * IN:\n * @dfile\tName of system activity data file.\n * @ignore\tSet to 1 if a true sysstat activity file but with a bad\n *\t\tformat should not yield an error message. Useful with\n *\t\tsadf -H and sadf -c.\n *\n * OUT:\n * @fd\t\tSystem activity data file descriptor.\n * @file_magic\tfile_magic structure containing data read from file magic\n *\t\theader.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @do_swap\tTRUE if endianness should be normalized for sysstat_magic\n *\t\tand format_magic numbers.\n *\n * RETURNS:\n * -1 if data file is a sysstat file with an old format (which we cannot\n * read), 0 otherwise.\n ***************************************************************************\n */\nint sa_open_read_magic(int *fd, char *dfile, struct file_magic *file_magic,\n\t\t       int ignore, int *endian_mismatch, int do_swap)\n{\n\tint n;\n\tunsigned int fm_types_nr[] = {FILE_MAGIC_ULL_NR, FILE_MAGIC_UL_NR, FILE_MAGIC_U_NR};\n\n\t/* Open sa data file */\n\tif ((*fd = open(dfile, O_RDONLY)) < 0) {\n\t\tint saved_errno = errno;\n\n\t\tfprintf(stderr, _(\"Cannot open %s: %s\\n\"), dfile, strerror(errno));\n\n\t\tif ((saved_errno == ENOENT) && default_file_used) {\n\t\t\tfprintf(stderr, _(\"Please check if data collecting is enabled\\n\"));\n\t\t}\n\t\texit(2);\n\t}\n\n\t/* Read file magic data */\n\tn = read(*fd, file_magic, FILE_MAGIC_SIZE);\n\n\tif ((n != FILE_MAGIC_SIZE) ||\n\t    ((file_magic->sysstat_magic != SYSSTAT_MAGIC) && (file_magic->sysstat_magic != SYSSTAT_MAGIC_SWAPPED)) ||\n\t    ((file_magic->format_magic != FORMAT_MAGIC) && (file_magic->format_magic != FORMAT_MAGIC_SWAPPED) && !ignore)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: Bytes read=%d sysstat_magic=%x format_magic=%x\\n\",\n\t\t\t__FUNCTION__, n, file_magic->sysstat_magic, file_magic->format_magic);\n#endif\n\t\t/* Display error message and exit */\n\t\thandle_invalid_sa_file(*fd, file_magic, dfile, n);\n\t}\n\n\t*endian_mismatch = (file_magic->sysstat_magic != SYSSTAT_MAGIC);\n\tif (*endian_mismatch) {\n\t\tif (do_swap) {\n\t\t\t/* Swap bytes for file_magic fields */\n\t\t\tfile_magic->sysstat_magic = SYSSTAT_MAGIC;\n\t\t\tfile_magic->format_magic  = __builtin_bswap16(file_magic->format_magic);\n\t\t}\n\t\t/*\n\t\t * Start swapping at field \"header_size\" position.\n\t\t * May not exist for older versions but in this case, it won't be used.\n\t\t */\n\t\tswap_struct(fm_types_nr, &file_magic->header_size, 0);\n\t}\n\n\tif ((file_magic->sysstat_version > 10) ||\n\t    ((file_magic->sysstat_version == 10) && (file_magic->sysstat_patchlevel >= 3))) {\n\t\t/* header_size field exists only for sysstat versions 10.3.1 and later */\n\t\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\t\t/* Display error message and exit */\n\t\t\thandle_invalid_sa_file(*fd, file_magic, dfile, n);\n\t\t}\n\t}\n\tif ((file_magic->sysstat_version > 11) ||\n\t    ((file_magic->sysstat_version == 11) && (file_magic->sysstat_patchlevel >= 7))) {\n\t\t/* hdr_types_nr field exists only for sysstat versions 11.7.1 and later */\n\t\tif (MAP_SIZE(file_magic->hdr_types_nr) > file_magic->header_size) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: map_size=%u header_size=%u\\n\",\n\t\t\t\t__FUNCTION__, MAP_SIZE(file_magic->hdr_types_nr), file_magic->header_size);\n#endif\n\t\t\thandle_invalid_sa_file(*fd, file_magic, dfile, n);\n\t\t}\n\t}\n\n\tif ((file_magic->format_magic != FORMAT_MAGIC) &&\n\t    (file_magic->format_magic != FORMAT_MAGIC_SWAPPED))\n\t\t/*\n\t\t * This is an old (or new) sa datafile format to\n\t\t * be read by sadf (since @ignore was set to TRUE).\n\t\t */\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Open a data file, and perform various checks before reading.\n * NB: This is called only when reading a datafile (sar and sadf), never\n * when writing or appending data to a datafile.\n *\n * IN:\n * @dfile\tName of system activity data file.\n * @act\t\tArray of activities.\n * @flags\tFlags for common options and system state.\n *\n * OUT:\n * @ifd\t\tSystem activity data file descriptor.\n * @file_magic\tfile_magic structure containing data read from file magic\n *\t\theader.\n * @file_hdr\tfile_hdr structure containing data read from file standard\n *\t\theader.\n * @file_actlst\tAcvtivity list in file.\n * @id_seq\tActivity sequence.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @arch_64\tTRUE if file's data come from a 64 bit machine.\n ***************************************************************************\n */\nvoid check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p, skip;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic,\n\t\t\t       DISPLAY_HDR_ONLY(flags), endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%u act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \"false positive\" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\n\t\t/*\n\t\t * Data file_activity size (file_hdr->act_size) may be greater or\n\t\t * smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t * then copy its contents to the expected structure.\n\t\t */\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a size value in\n\t\t * a defined range.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0) || (fal->size > MAX_ITEM_STRUCT_SIZE)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%u nr=%d nr2=%d size=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2, fal->size);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif ((fal->magic != act[p]->magic) && !DISPLAY_HDR_ONLY(flags)) {\n\t\t\tskip = TRUE;\n\t\t}\n\t\telse {\n\t\t\tskip = FALSE;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%u nr=%d nr_max=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\"long long\", or \"long\"\n\t\t * or \"int\") composing the structure with statistics may\n\t\t * only increase with new sysstat versions, unless we change\n\t\t * the activity's magic number. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) &&\n\t\t     (fal->magic == act[p]->magic) && !DISPLAY_HDR_ONLY(flags)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%u file=%u,%u,%u activity=%u,%u,%u\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: id=%u size=%d map_size=%u\\n\",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tif (!skip) {\n\t\t\tid_seq[j++] = fal->id;\n\t\t}\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\"Requested activities not available in file %s\\n\"),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}\n\n/*\n ***************************************************************************\n * Look for item in list.\n *\n * IN:\n * @list\tPointer on the start of the linked list.\n * @item_name\tItem name to look for.\n *\n * RETURNS:\n * Pointer on item in list if found, or NULL otherwise.\n ***************************************************************************\n */\nstruct sa_item *search_list_item(struct sa_item *list, char *item_name)\n{\n\twhile (list != NULL) {\n\t\tif (!strcmp(list->item_name, item_name))\n\t\t\treturn list;\t/* Item found in list */\n\t\tlist = list->next;\n\t}\n\n\t/* Item not found */\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Add item to the list.\n *\n * IN:\n * @list\tAddress of pointer on the start of the linked list.\n * @item_name\tName of the item.\n * @max_len\tMax length of an item.\n *\n * OUT:\n * @pos\t\tIf not NULL, contains the position of the item in list.\n *\t\tNot modified if item name was too long.\n *\n * RETURNS:\n * 1 if item has been added to the list (since it was not previously there),\n * and 0 otherwise (item already in list or item name too long).\n ***************************************************************************\n */\nint add_list_item(struct sa_item **list, char *item_name, int max_len, int *pos)\n{\n\tstruct sa_item *e;\n\tint len;\n\n\tif ((len = strnlen(item_name, max_len)) == max_len)\n\t\t/* Item too long */\n\t\treturn 0;\n\n\tif (pos) {\n\t\t*pos = 0;\n\t}\n\n\twhile (*list != NULL) {\n\t\te = *list;\n\t\tif (!strcmp(e->item_name, item_name))\n\t\t\treturn 0;\t/* Item found in list */\n\t\tlist = &(e->next);\n\t\tif (pos) {\n\t\t\t(*pos)++;\n\t\t}\n\t}\n\n\t/* Item not found: Add it to the list */\n\tSREALLOC(*list, struct sa_item, sizeof(struct sa_item));\n\te = *list;\n\tif ((e->item_name = (char *) malloc(len + 1)) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tstrcpy(e->item_name, item_name);\n\n\treturn 1;\n}\n\n/*\n * **************************************************************************\n * Free a linked list.\n *\n * IN:\n * @list\tAddress of the pointer on the start of the linked list.\n ***************************************************************************\n */\nvoid free_item_list(struct sa_item **item_list)\n{\n\tstruct sa_item *l, *list = *item_list;\n\n\twhile (list) {\n\t\tl = list->next;\n\t\tif (list->item_name) {\n\t\t\tfree(list->item_name);\n\t\t}\n\t\tfree(list);\n\t\tlist = l;\n\t}\n\t*item_list = NULL;\n}\n\n/*\n ***************************************************************************\n * Parse sar activities options (also used by sadf).\n *\n * IN:\n * @argv\tArguments list.\n * @opt\t\tIndex in list of arguments.\n * @caller\tIndicate whether it's sar or sadf that called this function.\n *\n * OUT:\n * @act\t\tArray of selected activities.\n * @flags\tCommon flags and system state.\n *\n * RETURNS:\n * 0 on success.\n ***************************************************************************\n */\nint parse_sar_opt(char *argv[], int *opt, struct activity *act[],\n\t\t  uint64_t *flags, int caller)\n{\n\tint i, p;\n\n\tfor (i = 1; *(argv[*opt] + i); i++) {\n\t\t/*\n\t\t * Note: argv[*opt] contains something like \"-BruW\"\n\t\t *     *(argv[*opt] + i) will contain 'B', 'r', etc.\n\t\t */\n\n\t\tswitch (*(argv[*opt] + i)) {\n\n\t\tcase 'A':\n\t\t\tselect_all_activities(act);\n\t\t\t*flags |= S_F_OPTION_A;\n\n\t\t\t/*\n\t\t\t * Force '-r ALL -u ALL -F'.\n\t\t\t * Setting -F is compulsory because corresponding activity\n\t\t\t * has AO_MULTIPLE_OUTPUTS flag set.\n\t\t\t * -P ALL will be set only if corresponding option has\n\t\t\t * not been exlicitly entered on the command line.\n\t\t\t */\n\t\t\tp = get_activity_position(act, A_MEMORY, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->opt_flags |= AO_F_MEMORY + AO_F_SWAP + AO_F_MEM_ALL;\n\n\t\t\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->opt_flags = AO_F_CPU_ALL;\n\n\t\t\tp = get_activity_position(act, A_FS, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->opt_flags = AO_F_FILESYSTEM;\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tSELECT_ACTIVITY(A_PAGE);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tSELECT_ACTIVITY(A_IO);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\t*flags |= S_F_COMMENT;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tSELECT_ACTIVITY(A_DISK);\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tp = get_activity_position(act, A_FS, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->options |= AO_SELECTED;\n\t\t\tif (!*(argv[*opt] + i + 1) && argv[*opt + 1] && !strcmp(argv[*opt + 1], K_MOUNT)) {\n\t\t\t\t(*opt)++;\n\t\t\t\tact[p]->opt_flags |= AO_F_MOUNT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tact[p]->opt_flags |= AO_F_FILESYSTEM;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\tSELECT_ACTIVITY(A_HUGE);\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t/* Option -h is equivalent to --pretty --human */\n\t\t\t*flags |= S_F_PRETTY + S_F_UNIT;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\tp = get_activity_position(act, A_IRQ, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->options |= AO_SELECTED;\n\n\t\t\tif (!*(argv[*opt] + i + 1) && argv[*opt + 1] &&\n\t\t\t    (!strcmp(argv[*opt + 1], K_ALL) || !strcmp(argv[*opt + 1], K_SUM))) {\n\t\t\t\t(*opt)++;\n\t\t\t\t/* Select int \"sum\". Keyword ALL is ignored */\n\t\t\t\tif (!strcmp(argv[*opt], K_SUM)) {\n\t\t\t\t\tact[p]->item_list_sz += add_list_item(&(act[p]->item_list), K_LOWERSUM, MAX_SA_IRQ_LEN, NULL);\n\t\t\t\t\tact[p]->options |= AO_LIST_ON_CMDLINE;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'j':\n\t\t\tif (!argv[*opt + 1]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t(*opt)++;\n\t\t\tif (!strcmp(argv[*opt], K_SID)) {\n\t\t\t\t*flags |= S_F_DEV_SID + S_F_PRETTY;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (strnlen(argv[*opt], sizeof(persistent_name_type)) >= sizeof(persistent_name_type) - 1)\n\t\t\t\treturn 1;\n\n\t\t\tstrncpy(persistent_name_type, argv[*opt], sizeof(persistent_name_type) - 1);\n\t\t\tpersistent_name_type[sizeof(persistent_name_type) - 1] = '\\0';\n\t\t\tstrtolower(persistent_name_type);\n\t\t\tif (!get_persistent_type_dir(persistent_name_type)) {\n\t\t\t\tfprintf(stderr, _(\"Invalid type of persistent device name\\n\"));\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t/* Pretty print report (option -j implies option -p) */\n\t\t\t*flags |= S_F_PERSIST_NAME + S_F_PRETTY;\n\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t*flags |= S_F_PRETTY;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\t/* Option -q grouped with other ones */\n\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\tp = get_activity_position(act, A_MEMORY, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->options   |= AO_SELECTED;\n\t\t\tact[p]->opt_flags |= AO_F_MEMORY;\n\t\t\tif (!*(argv[*opt] + i + 1) && argv[*opt + 1] && !strcmp(argv[*opt + 1], K_ALL)) {\n\t\t\t\t(*opt)++;\n\t\t\t\tact[p]->opt_flags |= AO_F_MEM_ALL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tp = get_activity_position(act, A_MEMORY, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->options   |= AO_SELECTED;\n\t\t\tact[p]->opt_flags |= AO_F_SWAP;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t/*\n\t\t\t * Check sar option -t here (as it can be combined\n\t\t\t * with other ones, eg. \"sar -rtu ...\"\n\t\t\t * But sadf option -t is checked in sadf.c as it won't\n\t\t\t * be entered as a sar option after \"--\".\n\t\t\t */\n\t\t\tif (caller != C_SAR) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t*flags |= S_F_TRUE_TIME;\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\t\t\tact[p]->options |= AO_SELECTED;\n\t\t\tif (!*(argv[*opt] + i + 1) && argv[*opt + 1] && !strcmp(argv[*opt + 1], K_ALL)) {\n\t\t\t\t(*opt)++;\n\t\t\t\tact[p]->opt_flags = AO_F_CPU_ALL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tact[p]->opt_flags = AO_F_CPU_DEF;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tSELECT_ACTIVITY(A_KTABLES);\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tSELECT_ACTIVITY(A_PCSW);\n\t\t\tbreak;\n\n\t\tcase 'W':\n\t\t\tSELECT_ACTIVITY(A_SWAP);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\t/*\n\t\t\t * Check sar option -x here (as it can be combined\n\t\t\t * with other ones. This options is not used by sadf.\n\t\t\t * Display min and max values.\n\t\t\t */\n\t\t\tif (caller == C_SAR) {\n\t\t\t\t*flags |= S_F_MINMAX;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tSELECT_ACTIVITY(A_SERIAL);\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\t\t*flags |= S_F_ZERO_OMIT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Parse sar \"-m\" option.\n *\n * IN:\n * @argv\tArguments list.\n * @opt\t\tIndex in list of arguments.\n *\n * OUT:\n * @act\t\tArray of selected activities.\n *\n * RETURNS:\n * 0 on success, 1 otherwise.\n ***************************************************************************\n */\nint parse_sar_m_opt(char *argv[], int *opt, struct activity *act[])\n{\n\tchar *t;\n\n\tfor (t = strtok(argv[*opt], \",\"); t; t = strtok(NULL, \",\")) {\n\t\tif (!strcmp(t, K_CPU)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_CPU);\n\t\t}\n\t\telse if (!strcmp(t, K_FAN)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_FAN);\n\t\t}\n\t\telse if (!strcmp(t, K_IN)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_IN);\n\t\t}\n\t\telse if (!strcmp(t, K_TEMP)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_TEMP);\n\t\t}\n\t\telse if (!strcmp(t, K_FREQ)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_FREQ);\n\t\t}\n\t\telse if (!strcmp(t, K_USB)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_USB);\n\t\t}\n\t\telse if (!strcmp(t, K_BAT)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_BAT);\n\t\t}\n\t\telse if (!strcmp(t, K_ALL)) {\n\t\t\tSELECT_ACTIVITY(A_PWR_CPU);\n\t\t\tSELECT_ACTIVITY(A_PWR_FAN);\n\t\t\tSELECT_ACTIVITY(A_PWR_IN);\n\t\t\tSELECT_ACTIVITY(A_PWR_TEMP);\n\t\t\tSELECT_ACTIVITY(A_PWR_FREQ);\n\t\t\tSELECT_ACTIVITY(A_PWR_USB);\n\t\t\tSELECT_ACTIVITY(A_PWR_BAT);\n\t\t}\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t(*opt)++;\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Parse sar \"-n\" option.\n *\n * IN:\n * @argv\tArguments list.\n * @opt\t\tIndex in list of arguments.\n *\n * OUT:\n * @act\t\tArray of selected activities.\n *\n * RETURNS:\n * 0 on success, 1 otherwise.\n ***************************************************************************\n */\nint parse_sar_n_opt(char *argv[], int *opt, struct activity *act[])\n{\n\tchar *t;\n\n\tfor (t = strtok(argv[*opt], \",\"); t; t = strtok(NULL, \",\")) {\n\t\tif (!strcmp(t, K_DEV)) {\n\t\t\tSELECT_ACTIVITY(A_NET_DEV);\n\t\t}\n\t\telse if (!strcmp(t, K_EDEV)) {\n\t\t\tSELECT_ACTIVITY(A_NET_EDEV);\n\t\t}\n\t\telse if (!strcmp(t, K_SOCK)) {\n\t\t\tSELECT_ACTIVITY(A_NET_SOCK);\n\t\t}\n\t\telse if (!strcmp(t, K_NFS)) {\n\t\t\tSELECT_ACTIVITY(A_NET_NFS);\n\t\t}\n\t\telse if (!strcmp(t, K_NFSD)) {\n\t\t\tSELECT_ACTIVITY(A_NET_NFSD);\n\t\t}\n\t\telse if (!strcmp(t, K_IP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_IP);\n\t\t}\n\t\telse if (!strcmp(t, K_EIP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_EIP);\n\t\t}\n\t\telse if (!strcmp(t, K_ICMP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_ICMP);\n\t\t}\n\t\telse if (!strcmp(t, K_EICMP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_EICMP);\n\t\t}\n\t\telse if (!strcmp(t, K_TCP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_TCP);\n\t\t}\n\t\telse if (!strcmp(t, K_ETCP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_ETCP);\n\t\t}\n\t\telse if (!strcmp(t, K_UDP)) {\n\t\t\tSELECT_ACTIVITY(A_NET_UDP);\n\t\t}\n\t\telse if (!strcmp(t, K_SOCK6)) {\n\t\t\tSELECT_ACTIVITY(A_NET_SOCK6);\n\t\t}\n\t\telse if (!strcmp(t, K_IP6)) {\n\t\t\tSELECT_ACTIVITY(A_NET_IP6);\n\t\t}\n\t\telse if (!strcmp(t, K_EIP6)) {\n\t\t\tSELECT_ACTIVITY(A_NET_EIP6);\n\t\t}\n\t\telse if (!strcmp(t, K_ICMP6)) {\n\t\t\tSELECT_ACTIVITY(A_NET_ICMP6);\n\t\t}\n\t\telse if (!strcmp(t, K_EICMP6)) {\n\t\t\tSELECT_ACTIVITY(A_NET_EICMP6);\n\t\t}\n\t\telse if (!strcmp(t, K_UDP6)) {\n\t\t\tSELECT_ACTIVITY(A_NET_UDP6);\n\t\t}\n\t\telse if (!strcmp(t, K_FC)) {\n\t\t\tSELECT_ACTIVITY(A_NET_FC);\n\t\t}\n\t\telse if (!strcmp(t, K_SOFT)) {\n\t\t\tSELECT_ACTIVITY(A_NET_SOFT);\n\t\t}\n\t\telse if (!strcmp(t, K_ALL)) {\n\t\t\tSELECT_ACTIVITY(A_NET_DEV);\n\t\t\tSELECT_ACTIVITY(A_NET_EDEV);\n\t\t\tSELECT_ACTIVITY(A_NET_SOCK);\n\t\t\tSELECT_ACTIVITY(A_NET_NFS);\n\t\t\tSELECT_ACTIVITY(A_NET_NFSD);\n\t\t\tSELECT_ACTIVITY(A_NET_IP);\n\t\t\tSELECT_ACTIVITY(A_NET_EIP);\n\t\t\tSELECT_ACTIVITY(A_NET_ICMP);\n\t\t\tSELECT_ACTIVITY(A_NET_EICMP);\n\t\t\tSELECT_ACTIVITY(A_NET_TCP);\n\t\t\tSELECT_ACTIVITY(A_NET_ETCP);\n\t\t\tSELECT_ACTIVITY(A_NET_UDP);\n\t\t\tSELECT_ACTIVITY(A_NET_SOCK6);\n\t\t\tSELECT_ACTIVITY(A_NET_IP6);\n\t\t\tSELECT_ACTIVITY(A_NET_EIP6);\n\t\t\tSELECT_ACTIVITY(A_NET_ICMP6);\n\t\t\tSELECT_ACTIVITY(A_NET_EICMP6);\n\t\t\tSELECT_ACTIVITY(A_NET_UDP6);\n\t\t\tSELECT_ACTIVITY(A_NET_FC);\n\t\t\tSELECT_ACTIVITY(A_NET_SOFT);\n\t\t}\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t(*opt)++;\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Parse sar \"-q\" option.\n *\n * IN:\n * @argv\tArguments list.\n * @opt\t\tIndex in list of arguments.\n *\n * OUT:\n * @act\t\tArray of selected activities.\n *\n * RETURNS:\n * 0 on success, 1 otherwise.\n ***************************************************************************\n */\nint parse_sar_q_opt(char *argv[], int *opt, struct activity *act[])\n{\n\tchar *t;\n\n\tfor (t = strtok(argv[*opt], \",\"); t; t = strtok(NULL, \",\")) {\n\t\tif (!strcmp(t, K_LOAD)) {\n\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t}\n\t\telse if (!strcmp(t, K_PSI_CPU)) {\n\t\t\tSELECT_ACTIVITY(A_PSI_CPU);\n\t\t}\n\t\telse if (!strcmp(t, K_PSI_IO)) {\n\t\t\tSELECT_ACTIVITY(A_PSI_IO);\n\t\t}\n\t\telse if (!strcmp(t, K_PSI_MEM)) {\n\t\t\tSELECT_ACTIVITY(A_PSI_MEM);\n\t\t}\n\t\telse if (!strcmp(t, K_PSI)) {\n\t\t\tSELECT_ACTIVITY(A_PSI_CPU);\n\t\t\tSELECT_ACTIVITY(A_PSI_IO);\n\t\t\tSELECT_ACTIVITY(A_PSI_MEM);\n\t\t}\n\t\telse if (!strcmp(t, K_ALL)) {\n\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t\tSELECT_ACTIVITY(A_PSI_CPU);\n\t\t\tSELECT_ACTIVITY(A_PSI_IO);\n\t\t\tSELECT_ACTIVITY(A_PSI_MEM);\n\t\t}\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t(*opt)++;\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Parse sar and sadf \"-P\" option.\n *\n * IN:\n * @argv\tArguments list.\n * @opt\t\tIndex in list of arguments.\n * @act\t\tArray of activities.\n *\n * OUT:\n * @flags\tCommon flags and system state.\n * @act\t\tArray of activities, with CPUs selected.\n *\n * RETURNS:\n * 0 on success, 1 otherwise.\n ***************************************************************************\n */\nint parse_sa_P_opt(char *argv[], int *opt, uint64_t *flags, struct activity *act[])\n{\n\tint p;\n\n\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\n\tif (argv[++(*opt)]) {\n\t\tif (parse_values(argv[*opt], act[p]->bitmap->b_array,\n\t\t\t     act[p]->bitmap->b_size, K_LOWERALL))\n\t\t\treturn 1;\n\t\t(*opt)++;\n\t\t*flags |= S_F_OPTION_P;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * If option -A has been used, force -P ALL only if corresponding\n * option has not been explicitly entered on the command line.\n *\n * IN:\n * @flags\tCommon flags and system state.\n *\n * OUT:\n * @act\t\tArray of selected activities.\n ***************************************************************************\n */\nvoid set_bitmaps(struct activity *act[], uint64_t *flags)\n{\n\tif (!USE_OPTION_P(*flags)) {\n\t\t/* Force -P ALL */\n\t\tint p = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\t\tmemset(act[p]->bitmap->b_array, ~0,\n\t\t       BITMAP_SIZE(act[p]->bitmap->b_size));\n\t}\n}\n\n/*\n ***************************************************************************\n * Parse devices entered on the command line and save them in activity's\n * list.\n *\n * IN:\n * @argv\tArgument with list of devices.\n * @a\t\tActivity for which devices are entered on the command line.\n * @max_len\tMax length of a device name.\n * @opt\t\tIndex in list of arguments.\n * @pos\t\tPosition is string where is located the first device.\n * @max_val\tIf > 0 then ranges of values are allowed (e.g. 3-5,9-, etc.)\n *\t\tValues are in range [0..@max_val].\n *\n * OUT:\n * @opt\t\tIndex on next argument.\n ***************************************************************************\n */\nvoid parse_sa_devices(char *argv, struct activity *a, int max_len, int *opt, int pos,\n\t\t      int max_val)\n{\n\tint i, val_low, val;\n\tchar *t;\n\tchar svalue[9];\n\n\tfor (t = strtok(argv + pos, \",\"); t; t = strtok(NULL, \",\")) {\n\n\t\t/* Test ranges of values, if allowed */\n\t\tif ((max_val > 0) && (strlen(t) <= 16) && (strspn(t, XDIGITS) == strlen(t))) {\n\t\t\tif (parse_range_values(t, max_val, &val_low, &val) == 0) {\n\t\t\t\t/* This is a real range of values: Save each if its values */\n\t\t\t\tfor (i = val_low; i <= val; i++) {\n\t\t\t\t\tsnprintf(svalue, sizeof(svalue), \"%d\", i);\n\t\t\t\t\tsvalue[sizeof(svalue) - 1] = '\\0';\n\t\t\t\t\ta->item_list_sz += add_list_item(&(a->item_list), svalue, max_len, NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\ta->item_list_sz += add_list_item(&(a->item_list), t, max_len, NULL);\n\t}\n\tif (a->item_list_sz) {\n\t\ta->options |= AO_LIST_ON_CMDLINE;\n\t}\n\t(*opt)++;\n}\n\n/*\n ***************************************************************************\n * Compute network interface utilization.\n *\n * IN:\n * @st_net_dev\tStructure with network interface stats.\n * @rx\t\tNumber of bytes received per second.\n * @tx\t\tNumber of bytes transmitted per second.\n *\n * RETURNS:\n * NIC utilization (0-100%).\n ***************************************************************************\n */\ndouble compute_ifutil(struct stats_net_dev *st_net_dev, double rx, double tx)\n{\n\tif (st_net_dev->speed) {\n\t\tunsigned long long speed = (unsigned long long) st_net_dev->speed * 1000000;\n\n\t\tif (st_net_dev->duplex == C_DUPLEX_FULL) {\n\t\t\t/* Full duplex */\n\t\t\tif (rx > tx) {\n\t\t\t\treturn (rx * 800 / speed);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (tx * 800 / speed);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Half duplex */\n\t\t\treturn ((rx + tx) * 800 / speed);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Read and replace unprintable characters in comment with \".\".\n *\n * IN:\n * @ifd\t\tInput file descriptor.\n * @comment\tComment.\n ***************************************************************************\n */\nvoid replace_nonprintable_char(int ifd, char *comment)\n{\n\tint i;\n\n\t/* Read comment */\n\tsa_fread(ifd, comment, MAX_COMMENT_LEN, HARD_SIZE, UEOF_STOP);\n\tcomment[MAX_COMMENT_LEN - 1] = '\\0';\n\n\t/* Replace non printable chars */\n\tfor (i = 0; i < strlen(comment); i++) {\n\t\tif (!isprint(comment[i]))\n\t\t\tcomment[i] = '.';\n\t}\n}\n\n/*\n ***************************************************************************\n * Fill the rectime and loctime structures with current record's date and\n * time, based on current record's \"number of seconds since the epoch\" saved\n * in file.\n * For loctime (if given): The timestamp is expressed in local time.\n * For rectime: The timestamp is expressed in UTC, in local time, or in the\n * time of the file's creator depending on options entered by the user on the\n * command line.\n *\n * IN:\n * @l_flags\tFlags indicating the type of time expected by the user.\n * \t\tS_F_LOCAL_TIME means time should be expressed in local time.\n * \t\tS_F_TRUE_TIME means time should be expressed in time of\n * \t\tfile's creator.\n * \t\tDefault is time expressed in UTC (except for sar, where it\n * \t\tis local time).\n * @record_hdr\tRecord header containing the number of seconds since the\n * \t\tepoch, and the HH:MM:SS of the file's creator.\n *\n * OUT:\n * @rectime\tStructure where timestamp for current record has been saved\n * \t\t(in local time, in UTC or in time of file's creator\n * \t\tdepending on options used).\n *\n * RETURNS:\n * 1 if an error was detected, or 0 otherwise.\n ***************************************************************************\n*/\nint sa_get_record_timestamp_struct(uint64_t l_flags, struct record_header *record_hdr,\n\t\t\t\t   struct tstamp_ext *rectime)\n{\n\tstruct tm *ltm;\n\ttime_t t = (time_t) record_hdr->ust_time;\n\tint rc = 0;\n\n\trectime->epoch_time = record_hdr->ust_time;\n\n\tif (!PRINT_LOCAL_TIME(l_flags) && !PRINT_TRUE_TIME(l_flags)) {\n\t\t/*\n\t\t * Get time in UTC\n\t\t * (the user doesn't want local time nor time of file's creator).\n\t\t */\n\t\tltm = gmtime_r(&t, &(rectime->tm_time));\n\t}\n\telse {\n\t\t/*\n\t\t* Fill generic rectime structure in local time.\n\t\t* Done so that we have some default values.\n\t\t*/\n\t\tltm = localtime_r(&t, &(rectime->tm_time));\n\t\trectime->tm_time.tm_gmtoff = TRUE;\n\t}\n\n\tif (!ltm) {\n\t\trc = 1;\n\t}\n\n\tif (PRINT_TRUE_TIME(l_flags)) {\n\t\t/* Time of file's creator */\n\t\trectime->tm_time.tm_hour = record_hdr->hour;\n\t\trectime->tm_time.tm_min  = record_hdr->minute;\n\t\trectime->tm_time.tm_sec  = record_hdr->second;\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Set current record's timestamp strings (date and time) using the time\n * data saved in @rectime structure. The string may be the number of seconds\n * since the epoch if flag S_F_SEC_EPOCH has been set.\n *\n * IN:\n * @l_flags\tFlags indicating the type of time expected by the user.\n * \t\tS_F_SEC_EPOCH means the time should be expressed in seconds\n * \t\tsince the epoch (01/01/1970).\n * @cur_date\tString where timestamp's date will be saved. May be NULL.\n * @cur_time\tString where timestamp's time will be saved.\n * @len\t\tMaximum length of timestamp strings.\n * @rectime\tStructure with current timestamp (expressed in local time or\n *\t\tin UTC depending on whether options -T or -t have been used\n * \t\tor not) that should be broken down in date and time strings.\n *\n * OUT:\n * @cur_date\tTimestamp's date string (if expected).\n * @cur_time\tTimestamp's time string. May contain the number of seconds\n *\t\tsince the epoch (01-01-1970) if corresponding option has\n * \t\tbeen used.\n ***************************************************************************\n*/\nvoid set_record_timestamp_string(uint64_t l_flags, char *cur_date, char *cur_time, int len,\n\t\t\t\t struct tstamp_ext *rectime)\n{\n\t/* Set cur_time date value */\n\tif (PRINT_SEC_EPOCH(l_flags) && cur_date) {\n\t\tsprintf(cur_time, \"%llu\", rectime->epoch_time);\n\t\tstrcpy(cur_date, \"\");\n\t}\n\telse {\n\t\t/*\n\t\t * If options -T or -t have been used then cur_time is\n\t\t * expressed in local time. Else it is expressed in UTC.\n\t\t */\n\t\tif (cur_date) {\n\t\t\tstrftime(cur_date, len, \"%Y-%m-%d\", &(rectime->tm_time));\n\t\t}\n\t\tif (USE_PREFD_TIME_OUTPUT(l_flags)) {\n\t\t\tstrftime(cur_time, len, \"%X\", &(rectime->tm_time));\n\t\t}\n\t\telse {\n\t\t\tstrftime(cur_time, len, \"%H:%M:%S\", &(rectime->tm_time));\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Print contents of a special (RESTART or COMMENT) record.\n * Note: This function is called only when reading a file.\n *\n * IN:\n * @record_hdr\tCurrent record header.\n * @l_flags\tFlags for common options.\n * @tm_start\tStructure filled when option -s has been used.\n * @tm_end\tStructure filled when option -e has been used.\n * @rtype\tRecord type (R_RESTART or R_COMMENT).\n * @ifd\t\tInput file descriptor.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @file\tName of file being read.\n * @tab\t\tNumber of tabulations to print.\n * @my_tz\tCurrent timezone.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @file_hdr\tSystem activity file standard header.\n * @act\t\tArray of activities.\n * @ofmt\tPointer on report output format structure.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @arch_64\tTRUE if file's data come from a 64 bit machine.\n *\n * OUT:\n * @rectime\tStructure where timestamp (expressed in local time or in UTC)\n *\t\thas been saved.\n *\n * RETURNS:\n * 1 if the record has been successfully displayed, and 0 otherwise.\n ***************************************************************************\n */\nint print_special_record(struct record_header *record_hdr, uint64_t l_flags,\n\t\t\t struct tstamp_ext *tm_start, struct tstamp_ext *tm_end, int rtype,\n\t\t\t int ifd, struct tstamp_ext *rectime, char *file, int tab, char *my_tz,\n\t\t\t struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t\t struct activity *act[], struct report_format *ofmt,\n\t\t\t int endian_mismatch, int arch_64)\n{\n\tchar cur_date[TIMESTAMP_LEN], cur_time[TIMESTAMP_LEN];\n\tint dp = 1;\n\n\t/* Fill timestamp structure (rectime) for current record */\n\tif (sa_get_record_timestamp_struct(l_flags, record_hdr, rectime))\n\t\treturn 0;\n\n\t/* The record must be in the interval specified by -s/-e options */\n\tif ((datecmp(rectime, tm_start, FALSE) < 0) ||\n\t    (datecmp(rectime, tm_end, FALSE) > 0)) {\n\t\t/* Will not display the special record */\n\t\tdp = 0;\n\t}\n\telse {\n\t\t/* Set date and time strings to be displayed for current record */\n\t\tset_record_timestamp_string(l_flags, cur_date, cur_time, TIMESTAMP_LEN,\n\t\t\t\t\t    rectime);\n\t}\n\n\tif (rtype == R_RESTART) {\n\t\tint p;\n\n\t\t/* Read new cpu number following RESTART record */\n\t\tfile_hdr->sa_cpu_nr = read_nr_value(ifd, file, file_magic,\n\t\t\t\t\t\t    endian_mismatch, arch_64, TRUE, NR_CPUS + 1);\n\n\t\t/*\n\t\t * We don't know if CPU related activities will be displayed or not.\n\t\t * But if it is the case, @nr_ini will be used in the loop\n\t\t * to process all CPUs. So update their value here and\n\t\t * reallocate buffers if needed.\n\t\t * NB: We may have nr_allocated=0 here if the activity has\n\t\t * not been collected in file (or if it has an unknown format).\n\t\t */\n\t\tfor (p = 0; p < NR_ACT; p++) {\n\t\t\tif (HAS_PERSISTENT_VALUES(act[p]->options) && (act[p]->nr_ini > 0)) {\n\t\t\t\tact[p]->nr_ini = file_hdr->sa_cpu_nr;\n\t\t\t\tif (act[p]->nr_ini > act[p]->nr_allocated) {\n\t\t\t\t\treallocate_buffers(act[p], act[p]->nr_ini, l_flags);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Ignore unknown extra structures if present */\n\t\tif (record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 0;\n\n\t\tif (!dp)\n\t\t\treturn 0;\n\n\t\tif (*ofmt->f_restart) {\n\t\t\t(*ofmt->f_restart)(&tab, F_MAIN, cur_date, cur_time, my_tz, file_hdr, record_hdr);\n\t\t}\n\t}\n\telse if (rtype == R_COMMENT) {\n\t\tchar file_comment[MAX_COMMENT_LEN];\n\n\t\t/* Read and replace non printable chars in comment */\n\t\treplace_nonprintable_char(ifd, file_comment);\n\n\t\t/* Ignore unknown extra structures if present */\n\t\tif (record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 0;\n\n\t\tif (!dp || !DISPLAY_COMMENT(l_flags))\n\t\t\treturn 0;\n\n\t\tif (*ofmt->f_comment) {\n\t\t\t(*ofmt->f_comment)(&tab, F_MAIN, cur_date, cur_time, my_tz,\n\t\t\t\t\t   file_comment, file_hdr, record_hdr);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Compute global CPU statistics as the sum of individual CPU ones, and\n * calculate interval for global CPU.\n * Also identify offline CPU.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @flags\tFlags for common options and system state.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n *\n * OUT:\n * @a\t\tActivity structure with updated statistics (those for global\n *\t\tCPU, and also those for offline CPU).\n * @offline_cpu_bitmap\n *\t\tCPU bitmap with offline CPU.\n *\n * RETURNS:\n * Interval for global CPU.\n ***************************************************************************\n */\nunsigned long long get_global_cpu_statistics(struct activity *a, int prev, int curr,\n\t\t\t\t\t     uint64_t flags, unsigned char offline_cpu_bitmap[])\n{\n\tint i;\n\tunsigned long long tot_jiffies_c, tot_jiffies_p;\n\tunsigned long long deltot_jiffies = 0;\n\tstruct stats_cpu *scc, *scp;\n\tstruct stats_cpu *scc_all = (struct stats_cpu *) ((char *) a->buf[curr]);\n\tstruct stats_cpu *scp_all = (struct stats_cpu *) ((char *) a->buf[prev]);\n\n\t/*\n\t * Initial processing.\n\t * Compute CPU \"all\" as sum of all individual CPU. Done only on SMP machines (a->nr_ini > 1).\n\t * For UP machines we keep the values read from global CPU line in /proc/stat.\n\t * Also look for offline CPU: They won't be displayed, and some of their values may\n\t * have to be modified.\n\t */\n\tif (a->nr_ini > 1) {\n\t\tmemset(scc_all, 0, sizeof(struct stats_cpu));\n\t\tmemset(scp_all, 0, sizeof(struct stats_cpu));\n\t}\n\n\tfor (i = 1; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_cpu) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * scc = (struct stats_cpu *) a->buf[...] + i;\n\t\t */\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr] + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[prev] + i * a->msize);\n\n\t\t/*\n\t\t * Compute the total number of jiffies spent by current processor.\n\t\t * NB: Don't add cpu_guest/cpu_guest_nice because cpu_user/cpu_nice\n\t\t * already include them.\n\t\t */\n\t\ttot_jiffies_c = scc->cpu_user + scc->cpu_nice +\n\t\t\t\tscc->cpu_sys + scc->cpu_idle +\n\t\t\t\tscc->cpu_iowait + scc->cpu_hardirq +\n\t\t\t\tscc->cpu_steal + scc->cpu_softirq;\n\t\ttot_jiffies_p = scp->cpu_user + scp->cpu_nice +\n\t\t\t\tscp->cpu_sys + scp->cpu_idle +\n\t\t\t\tscp->cpu_iowait + scp->cpu_hardirq +\n\t\t\t\tscp->cpu_steal + scp->cpu_softirq;\n\n\t\t/*\n\t\t * If the CPU is offline then it is omited from /proc/stat:\n\t\t * All the fields couldn't have been read and the sum of them is zero.\n\t\t */\n\t\tif (tot_jiffies_c == 0) {\n\t\t\t/*\n\t\t\t * CPU is currently offline.\n\t\t\t * Set current struct fields (which have been set to zero)\n\t\t\t * to values from previous iteration. Hence their values won't\n\t\t\t * jump from zero when the CPU comes back online.\n\t\t\t * Note that this workaround no longer fully applies with recent kernels,\n\t\t\t * as I have noticed that when a CPU comes back online, some fields\n\t\t\t * restart from their previous value (e.g. user, nice, system)\n\t\t\t * whereas others restart from zero (idle, iowait)! To deal with this,\n\t\t\t * the get_per_cpu_interval() function will set these previous values\n\t\t\t * to zero if necessary.\n\t\t\t */\n\t\t\t*scc = *scp;\n\n\t\t\t/*\n\t\t\t * Mark CPU as offline to not display it\n\t\t\t * (and thus it will not be confused with a tickless CPU).\n\t\t\t */\n\t\t\tMARK_CPU_OFFLINE(offline_cpu_bitmap, i);\n\t\t}\n\n\t\tif ((tot_jiffies_p == 0) && !WANT_SINCE_BOOT(flags)) {\n\t\t\t/*\n\t\t\t * CPU has just come back online.\n\t\t\t * Unfortunately, no reference values are available\n\t\t\t * from a previous iteration, probably because it was\n\t\t\t * already offline when the first sample has been taken.\n\t\t\t * So don't display that CPU to prevent \"jump-from-zero\"\n\t\t\t * output syndrome, and don't take it into account for CPU \"all\".\n\t\t\t */\n\t\t\tMARK_CPU_OFFLINE(offline_cpu_bitmap, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get interval for current CPU and add it to global CPU.\n\t\t * Note: Previous idle and iowait values (saved in scp) may be modified here.\n\t\t */\n\t\tdeltot_jiffies += get_per_cpu_interval(scc, scp);\n\n\t\tscc_all->cpu_user += scc->cpu_user;\n\t\tscp_all->cpu_user += scp->cpu_user;\n\n\t\tscc_all->cpu_nice += scc->cpu_nice;\n\t\tscp_all->cpu_nice += scp->cpu_nice;\n\n\t\tscc_all->cpu_sys += scc->cpu_sys;\n\t\tscp_all->cpu_sys += scp->cpu_sys;\n\n\t\tscc_all->cpu_idle += scc->cpu_idle;\n\t\tscp_all->cpu_idle += scp->cpu_idle;\n\n\t\tscc_all->cpu_iowait += scc->cpu_iowait;\n\t\tscp_all->cpu_iowait += scp->cpu_iowait;\n\n\t\tscc_all->cpu_hardirq += scc->cpu_hardirq;\n\t\tscp_all->cpu_hardirq += scp->cpu_hardirq;\n\n\t\tscc_all->cpu_steal += scc->cpu_steal;\n\t\tscp_all->cpu_steal += scp->cpu_steal;\n\n\t\tscc_all->cpu_softirq += scc->cpu_softirq;\n\t\tscp_all->cpu_softirq += scp->cpu_softirq;\n\n\t\tscc_all->cpu_guest += scc->cpu_guest;\n\t\tscp_all->cpu_guest += scp->cpu_guest;\n\n\t\tscc_all->cpu_guest_nice += scc->cpu_guest_nice;\n\t\tscp_all->cpu_guest_nice += scp->cpu_guest_nice;\n\t}\n\n\treturn deltot_jiffies;\n}\n\n/*\n ***************************************************************************\n * Compute softnet statistics for CPU \"all\" as the sum of individual CPU\n * ones.\n * Also identify offline CPU.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @flags\tFlags for common options and system state.\n * @offline_cpu_bitmap\n *\t\tCPU bitmap for offline CPU.\n *\n * OUT:\n * @a\t\tActivity structure with updated statistics (those for global\n *\t\tCPU, and also those for offline CPU).\n * @offline_cpu_bitmap\n *\t\tCPU bitmap with offline CPU.\n ***************************************************************************\n */\nvoid get_global_soft_statistics(struct activity *a, int prev, int curr,\n\t\t\t\tuint64_t flags, unsigned char offline_cpu_bitmap[])\n{\n\tint i;\n\tstruct stats_softnet *ssnc, *ssnp;\n\tstruct stats_softnet *ssnc_all = (struct stats_softnet *) ((char *) a->buf[curr]);\n\tstruct stats_softnet *ssnp_all = (struct stats_softnet *) ((char *) a->buf[prev]);\n\n\t/*\n\t * Init structures that will contain values for CPU \"all\".\n\t * CPU \"all\" doesn't exist in /proc/net/softnet_stat file, so\n\t * we compute its values as the sum of the values of each CPU.\n\t */\n\tmemset(ssnc_all, 0, sizeof(struct stats_softnet));\n\tmemset(ssnp_all, 0, sizeof(struct stats_softnet));\n\n\tfor (i = 1; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_softnet) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * ssnc = (struct stats_softnet *) a->buf[...] + i;\n                 */\n                ssnc = (struct stats_softnet *) ((char *) a->buf[curr] + i * a->msize);\n                ssnp = (struct stats_softnet *) ((char *) a->buf[prev] + i * a->msize);\n\n\t\tif ((ssnp->processed + ssnp->dropped + ssnp->time_squeeze +\n\t\t    ssnp->received_rps + ssnp->flow_limit + ssnp->backlog_len == 0) &&\n\t\t    !WANT_SINCE_BOOT(flags)) {\n\t\t\t/*\n\t\t\t * No previous sample for current CPU: Don't display it unless\n\t\t\t * we want stats since last boot time.\n\t\t\t * (CPU may be online but we don't display it because all\n\t\t\t * its counters would appear to jump from zero...)\n\t\t\t */\n\t\t\tMARK_CPU_OFFLINE(offline_cpu_bitmap, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ssnc->processed + ssnc->dropped + ssnc->time_squeeze +\n\t\t    ssnc->received_rps + ssnc->flow_limit + ssnc->backlog_len == 0) {\n\t\t\t/* Assume current CPU is offline */\n\t\t\t*ssnc = *ssnp;\n\t\t\tMARK_CPU_OFFLINE(offline_cpu_bitmap, i);\n\t\t}\n\n\t\tssnc_all->processed += ssnc->processed;\n\t\tssnc_all->dropped += ssnc->dropped;\n\t\tssnc_all->time_squeeze += ssnc->time_squeeze;\n\t\tssnc_all->received_rps += ssnc->received_rps;\n\t\tssnc_all->flow_limit += ssnc->flow_limit;\n\t\tssnc_all->backlog_len += ssnc->backlog_len;\n\n\t\tssnp_all->processed += ssnp->processed;\n\t\tssnp_all->dropped += ssnp->dropped;\n\t\tssnp_all->time_squeeze += ssnp->time_squeeze;\n\t\tssnp_all->received_rps += ssnp->received_rps;\n\t\tssnp_all->flow_limit += ssnp->flow_limit;\n\t\tssnp_all->backlog_len += ssnp->backlog_len;\n\t}\n}\n\n/*\n ***************************************************************************\n * Identify offline CPU (those for which all interrupts are 0) and keep\n * interrupts statistics (their values are persistent). Include also CPU\n * which have not been selected (this is necessary so that the header of the\n * interrupts statistics report can be displayed).\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @prev\tIndex in array where stats used as reference are.\n * @curr\tIndex in array for current sample statistics.\n * @flags\tFlags for common options and system state.\n * @masked_cpu_bitmap\n *\t\tCPU bitmap for offline and unselected CPU.\n *\n * OUT:\n * @a\t\tActivity structure with updated statistics (those for global\n *\t\tCPU, and also those for offline CPU).\n * @masked_cpu_bitmap\n *\t\tCPU bitmap with offline and unselected CPU.\n ***************************************************************************\n */\nvoid get_global_int_statistics(struct activity *a, int prev, int curr,\n\t\t\t       uint64_t flags, unsigned char masked_cpu_bitmap[])\n{\n\tint i;\n\tstruct stats_irq *stc_cpu_sum, *stp_cpu_sum;\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/*\n\t\t * The size of a->buf[...] CPU structure may be different from the default\n\t\t * sizeof(struct stats_irq) value if data have been read from a file!\n\t\t * That's why we don't use a syntax like:\n\t\t * stc_cpu_sum = (struct stats_irq *) a->buf[...] + i;\n                 */\n\t\tstc_cpu_sum = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize * a->nr2);\n\t\tstp_cpu_sum = (struct stats_irq *) ((char *) a->buf[prev] + i * a->msize * a->nr2);\n\n\t\t/*\n\t\t * Check if current CPU is back online but with no previous sample for it,\n\t\t * or if it has not been selected.\n\t\t */\n\t\tif (((stp_cpu_sum->irq_nr == 0) && !WANT_SINCE_BOOT(flags)) ||\n\t\t    !IS_CPU_SELECTED(a->bitmap->b_array, i)) {\n\t\t\t/* CPU should not be displayed */\n\t\t\tSET_CPU_BITMAP(masked_cpu_bitmap, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stc_cpu_sum->irq_nr == 0) {\n\t\t\t/* Assume current CPU is offline */\n\t\t\tSET_CPU_BITMAP(masked_cpu_bitmap, i);\n\t\t\tmemcpy(stc_cpu_sum, stp_cpu_sum, (size_t) a->msize * a->nr2);\n\t\t}\n\n\t}\n}\n\n/*\n ***************************************************************************\n * Get filesystem name to display. This may be either the persistent name\n * if requested by the user, the standard filesystem name (e.g. /dev/sda1,\n * /dev/sdb3, etc.) or the mount point. This is used when displaying\n * filesystem statistics: sar -F or sadf -- -F).\n *\n * IN:\n * @a\t\tActivity structure.\n * @flags\tFlags for common options and system state.\n * @st_fs\tStatistics for current filesystem.\n *\n * RETURNS:\n * Filesystem name to display.\n ***************************************************************************\n */\nchar *get_fs_name_to_display(struct activity *a, uint64_t flags, struct stats_filesystem *st_fs)\n{\n\tchar *pname = NULL, *persist_dev_name;\n\n\tif (DISPLAY_PERSIST_NAME_S(flags) && !DISPLAY_MOUNT(a->opt_flags)) {\n\t\tchar fname[MAX_FS_LEN];\n\n\t\tstrncpy(fname, st_fs->fs_name, sizeof(fname));\n\t\tfname[sizeof(fname) - 1] = '\\0';\n\t\tif ((persist_dev_name = get_persistent_name_from_pretty(basename(fname))) != NULL) {\n\t\t\tpname = persist_dev_name;\n\t\t}\n\t}\n\tif (!pname) {\n\t\tpname = DISPLAY_MOUNT(a->opt_flags) ? st_fs->mountp : st_fs->fs_name;\n\t}\n\treturn pname;\n}\n\n/*\n * **************************************************************************\n * Make a few checks on timestamps entered with options -s/-e.\n *\n * IN:\n * @tm_start\tTimestamp entered with option -s.\n * @tm_end\tTimestamp entered with option -e.\n *\n * RETURNS:\n * 1 if an error has been detected.\n ***************************************************************************\n */\nint check_time_limits(struct tstamp_ext *tm_start, struct tstamp_ext *tm_end)\n{\n\tif ((tm_start->use == USE_HHMMSS_T) && (tm_end->use == USE_HHMMSS_T) &&\n\t    (tm_end->tm_time.tm_hour < tm_start->tm_time.tm_hour)) {\n\t\ttm_end->tm_time.tm_hour += 24;\n\t}\n\n\tif ((tm_start->use == USE_EPOCH_T) && (tm_end->use == USE_EPOCH_T) &&\n\t    (tm_end->epoch_time < tm_start->epoch_time))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n * **************************************************************************\n * Check for min and max values.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @idx\t\tIndex in min/max buffers.\n * @val\t\tValue to check.\n ***************************************************************************\n */\nvoid save_minmax(struct activity *a, int idx, double val)\n{\n\tif (val < *(a->spmin + idx)) {\n\t\t*(a->spmin + idx) = val;\n\t}\n\tif (val > *(a->spmax + idx)) {\n\t\t*(a->spmax + idx) = val;\n\t}\n}\n\n/*\n * **************************************************************************\n * Compare the values of a statistics sample with the max and min values\n * already found in previous samples for this same activity. If some new\n * min or max values are found, then save them.\n * Assume values cannot be negative.\n * The structure containing the statistics sample is composed of @llu_nr\n * unsigned long long fields, followed by @lu_nr unsigned long fields, then\n * followed by @u_nr unsigned int fields.\n *\n * IN:\n * @types_nr\tNumber of fields whose type is \"long long\", \"long\" and \"int\"\n * \t\tcomposing the structure.\n * @cs\t\tPointer on current sample statistics structure.\n * @ps\t\tPointer on previous sample statistics structure (may be NULL).\n * @itv\t\tInterval of time in 1/100th of a second.\n * @spmin\tArray containing min values already found for this activity.\n * @spmax\tArray containing max values already found for this activity.\n * @g_fields\tIndex in spmin/spmax arrays where extrema values for each\n *\t\tactivity metric will be saved. As a consequence spmin/spmax\n *\t\tarrays may contain values in a different order than that of\n *\t\tthe fields in the statistics structure.\n *\n * OUT:\n * @spmin\tArray containing the possible new min values for current activity.\n * @spmax\tArray containing the possible new max values for current activity.\n ***************************************************************************\n */\nvoid save_extrema(const unsigned int types_nr[], void *cs, void *ps, unsigned long long itv,\n\t\t  double *spmin, double *spmax, int g_fields[])\n{\n\tunsigned long long *lluc, *llup;\n\tunsigned long *luc, *lup;\n\tunsigned int *uc, *up;\n\tdouble val;\n\tint i, m = 0;\n\n\t/* Compare unsigned long long fields */\n\tlluc = (unsigned long long *) cs;\n\tllup = (unsigned long long *) ps;\n\tfor (i = 0; i < types_nr[0]; i++, m++) {\n\t\tif (g_fields[m] >= 0) {\n\t\t\tif (ps) {\n\t\t\t\tval = *lluc < *llup ? 0.0 : S_VALUE(*llup, *lluc, itv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * If no pointer on previous sample has been given\n\t\t\t\t * then the value is not a per-second one.\n\t\t\t\t */\n\t\t\t\tval = (double) *lluc;\n\t\t\t}\n\t\t\tif (val < *(spmin + g_fields[m])) {\n\t\t\t\t*(spmin + g_fields[m]) = val;\n\t\t\t}\n\t\t\tif (val > *(spmax + g_fields[m])) {\n\t\t\t\t*(spmax + g_fields[m]) = val;\n\t\t\t}\n\t\t}\n\t\tlluc = (unsigned long long *) ((char *) lluc + ULL_ALIGNMENT_WIDTH);\n\t\tif (ps) {\n\t\t\tllup = (unsigned long long *) ((char *) llup + ULL_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n\n\t/* Compare unsigned long fields */\n\tluc = (unsigned long *) lluc;\n\tlup = (unsigned long *) llup;\n\tfor (i = 0; i < types_nr[1]; i++, m++) {\n\t\tif (g_fields[m] >= 0) {\n\t\t\tif (ps) {\n\t\t\t\tval = *luc < *lup ? 0.0 : S_VALUE(*lup, *luc, itv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = (double) *luc;\n\t\t\t}\n\t\t\tif (val < *(spmin + g_fields[m])) {\n\t\t\t\t*(spmin + g_fields[m]) = val;\n\t\t\t}\n\t\t\tif (val > *(spmax + g_fields[m])) {\n\t\t\t\t*(spmax + g_fields[m]) = val;\n\t\t\t}\n\t\t}\n\t\tluc = (unsigned long *) ((char *) luc + UL_ALIGNMENT_WIDTH);\n\t\tif (ps) {\n\t\t\tlup = (unsigned long *) ((char *) lup + UL_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n\n\t/* Compare unsigned int fields */\n\tuc = (unsigned int *) luc;\n\tup = (unsigned int *) lup;\n\tfor (i = 0; i < types_nr[2]; i++, m++) {\n\t\tif (g_fields[m] >= 0) {\n\t\t\tif (ps) {\n\t\t\t\tval = *uc < *up ? 0.0 : S_VALUE(*up, *uc, itv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = (double) *uc;\n\t\t\t}\n\t\t\tif (val < *(spmin + g_fields[m])) {\n\t\t\t\t*(spmin + g_fields[m]) = val;\n\t\t\t}\n\t\t\tif (val > *(spmax + g_fields[m])) {\n\t\t\t\t*(spmax + g_fields[m]) = val;\n\t\t\t}\n\t\t}\n\t\tuc = (unsigned int *) ((char *) uc + U_ALIGNMENT_WIDTH);\n\t\tif (ps) {\n\t\t\tup = (unsigned int *) ((char *) up + U_ALIGNMENT_WIDTH);\n\t\t}\n\t}\n}\n\n/*\n * **************************************************************************\n * Init min and max values. Also free linked list with device names.\n *\n * IN:\n * @a\tActivity structure.\n * @nr\tNumber of slots for min and max values that shall be initialized.\n *\n * OUT:\n * @a\tActivity structure with min/max values initialized.\n ***************************************************************************\n */\nvoid init_extrema_values(struct activity *a, int nr)\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\t*(a->spmin + i) = DBL_MAX;\n\t\t*(a->spmax + i) = -DBL_MAX;\n\t}\n\n\tfree_item_list(&(a->xdev_list));\n}\n\n/*\n * **************************************************************************\n * Print min and max header.\n *\n * IN:\n * @ismax\tTRUE: Display max header - FALSE: Display min header.\n ***************************************************************************\n */\nvoid print_minmax(int ismax)\n{\n\tprintf(\"%-11s\", ismax ? _(\"Maximum:\")\n\t\t\t      : _(\"Minimum:\"));\n}\n\n#endif /* SOURCE_SADC undefined */\n"
        },
        {
          "name": "sa_conv.c",
          "type": "blob",
          "size": 67.158203125,
          "content": "/*\n * sa_conv.c: Convert an old format sa file to the up-to-date format.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"version.h\"\n#include \"sadf.h\"\n#include \"sa_conv.h\"\n\n#ifdef USE_NLS\n# include <locale.h>\n# include <libintl.h>\n# define _(string) gettext(string)\n#else\n# define _(string) (string)\n#endif\n\nextern int endian_mismatch;\nextern unsigned int user_hz;\nextern unsigned int act_types_nr[];\nextern unsigned int rec_types_nr[];\nextern unsigned int hdr_types_nr[];\n\nunsigned int oact_types_nr[] = {OLD_FILE_ACTIVITY_ULL_NR, OLD_FILE_ACTIVITY_UL_NR, OLD_FILE_ACTIVITY_U_NR};\n\n/*\n ***************************************************************************\n * Read and upgrade file's magic data section.\n *\n * IN:\n * @dfile\tSystem activity data file name.\n * @stdfd\tFile descriptor for STDOUT.\n *\n * OUT:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @file_magic\tFile's magic structure.\n * @hdr_size\tSize of header structure read from file.\n * @previous_format\n *\t\tFormat magic number of file to convert, converted to\n *\t\tcurrent endianness.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n ***************************************************************************\n */\nint upgrade_magic_section(char dfile[], int *fd, int stdfd, struct file_magic *file_magic,\n\t\t\t  unsigned int *hdr_size, int *previous_format, int *endian_mismatch)\n{\n\tstruct file_magic fm;\n\tunsigned int fm_types_nr[] = {FILE_MAGIC_ULL_NR, FILE_MAGIC_UL_NR, FILE_MAGIC_U_NR};\n\n\t/* Open and read sa magic structure */\n\tsa_open_read_magic(fd, dfile, file_magic, TRUE, endian_mismatch, FALSE);\n\n\tswitch (file_magic->format_magic) {\n\n\t\tcase FORMAT_MAGIC:\n\t\tcase FORMAT_MAGIC_SWAPPED:\n\t\t\t*previous_format = FORMAT_MAGIC;\n\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase FORMAT_MAGIC_2171:\n\t\tcase FORMAT_MAGIC_2171_SWAPPED:\n\t\t\t*previous_format = FORMAT_MAGIC_2171;\n\t\t\tbreak;\n\n\t\tcase FORMAT_MAGIC_2173:\n\t\tcase FORMAT_MAGIC_2173_SWAPPED:\n\t\t\t*previous_format = FORMAT_MAGIC_2173;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, _(\"Cannot convert the format of this file\\n\"));\n\t\t\treturn -1;\n\t\t\tbreak;\n\t}\n\n\tfprintf(stderr, \"file_magic: \");\n\tif (*previous_format == FORMAT_MAGIC_2171) {\n\t\t/*\n\t\t * We have read too many bytes: file_magic structure\n\t\t * was smaller with previous sysstat versions.\n\t\t * Go back 4 (unsigned int header_size) + 64 (char pad[64]) bytes.\n\t\t */\n\t\tif (lseek(*fd, -68, SEEK_CUR) < 0) {\n\t\t\tfprintf(stderr, \"\\nlseek: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Set format magic number to that of current version */\n\tfile_magic->format_magic = (*endian_mismatch ? FORMAT_MAGIC_SWAPPED\n\t\t\t\t\t\t     : FORMAT_MAGIC);\n\n\t/* Save original header structure's size */\n\t*hdr_size = file_magic->header_size;\n\n\t/* Fill new structure members */\n\tfile_magic->header_size = FILE_HEADER_SIZE;\n\tfile_magic->hdr_types_nr[0] = FILE_HEADER_ULL_NR;\n\tfile_magic->hdr_types_nr[1] = FILE_HEADER_UL_NR;\n\tfile_magic->hdr_types_nr[2] = FILE_HEADER_U_NR;\n\tmemset(file_magic->pad, 0, sizeof(unsigned char) * FILE_MAGIC_PADDING);\n\n\t/* Indicate that file has been upgraded */\n\tenum_version_nr(&fm);\n\tfile_magic->upgraded = (fm.sysstat_patchlevel << 8) +\n\t\t\t       fm.sysstat_sublevel + 1;\n\n\tmemcpy(&fm, file_magic, FILE_MAGIC_SIZE);\n\t/* Restore endianness before writing */\n\tif (*endian_mismatch) {\n\t\t/* Start swapping at field \"header_size\" position */\n\t\tswap_struct(fm_types_nr, &(fm.header_size), 0);\n\t}\n\n\t/* Write file's magic structure */\n\tif (write_all(stdfd, &fm, FILE_MAGIC_SIZE) != FILE_MAGIC_SIZE) {\n\t\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(stderr, \"OK\\n\");\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Upgrade file_header structure (from 0x2171 format to current format).\n *\n * IN:\n * @buffer\tFile's header structure (as read from file).\n * @previous_format\n *\t\tFormat magic number of file to convert.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\n *\t\tmachine's endianness.\n *\n * OUT:\n * @file_hdr\tFile's header structure (up-to-date format).\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n * @vol_act_nr\tNumber of volatile activity structures following a restart\n *\t\trecord for 0x2173 file format.\n ***************************************************************************\n */\nvoid upgrade_file_header(void *buffer, struct file_header *file_hdr, int previous_format,\n\t\t\t int endian_mismatch, int *arch_64, unsigned int *vol_act_nr)\n{\n\tstruct file_header_2171 *f_hdr_2171 = (struct file_header_2171 *) buffer;\n\tstruct file_header_2173 *f_hdr_2173 = (struct file_header_2173 *) buffer;\n\tunsigned int hdr_2171_types_nr[] = {FILE_HEADER_2171_ULL_NR, FILE_HEADER_2171_UL_NR, FILE_HEADER_2171_U_NR};\n\tunsigned int hdr_2173_types_nr[] = {FILE_HEADER_2173_ULL_NR, FILE_HEADER_2173_UL_NR, FILE_HEADER_2173_U_NR};\n\tint i;\n\n\tmemset(file_hdr, 0, FILE_HEADER_SIZE);\n\tfile_hdr->sa_hz = HZ;\n\n\tif (previous_format == FORMAT_MAGIC_2171) {\n\t\t*arch_64 = (f_hdr_2171->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t\t/* Normalize endianness for f_hdr_2171 structure */\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(hdr_2171_types_nr, f_hdr_2171, *arch_64);\n\t\t}\n\n\t\tfile_hdr->sa_ust_time = (unsigned long long) f_hdr_2171->sa_ust_time;\n\t\t/* sa_cpu_nr field will be updated later */\n\t\tfile_hdr->sa_act_nr = f_hdr_2171->sa_act_nr;\n\t\tfile_hdr->sa_year = (int) f_hdr_2171->sa_year;\n\t\tfile_hdr->sa_day = f_hdr_2171->sa_day;\n\t\tfile_hdr->sa_month = f_hdr_2171->sa_month;\n\t\tfile_hdr->sa_sizeof_long = f_hdr_2171->sa_sizeof_long;\n\t\tstrncpy(file_hdr->sa_sysname, f_hdr_2171->sa_sysname, sizeof(file_hdr->sa_sysname));\n\t\tfile_hdr->sa_sysname[sizeof(file_hdr->sa_sysname) - 1] = '\\0';\n\t\tstrncpy(file_hdr->sa_nodename, f_hdr_2171->sa_nodename, sizeof(file_hdr->sa_nodename));\n\t\tfile_hdr->sa_nodename[sizeof(file_hdr->sa_nodename) - 1] = '\\0';\n\t\tstrncpy(file_hdr->sa_release, f_hdr_2171->sa_release, sizeof(file_hdr->sa_release));\n\t\tfile_hdr->sa_release[sizeof(file_hdr->sa_release) - 1] = '\\0';\n\t\tstrncpy(file_hdr->sa_machine, f_hdr_2171->sa_machine, sizeof(file_hdr->sa_machine));\n\t\tfile_hdr->sa_machine[sizeof(file_hdr->sa_machine) - 1] = '\\0';\n\t}\n\n\telse if (previous_format == FORMAT_MAGIC_2173) {\n\t\t*arch_64 = (f_hdr_2173->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t\t/* Normalize endianness for f_hdr_2171 structure */\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(hdr_2173_types_nr, f_hdr_2173, *arch_64);\n\t\t}\n\n\t\tfile_hdr->sa_ust_time = (unsigned long long) f_hdr_2173->sa_ust_time;\n\t\t/* sa_cpu_nr field will be updated later */\n\t\tfile_hdr->sa_act_nr = f_hdr_2173->sa_act_nr;\n\t\tfile_hdr->sa_year = (int) f_hdr_2173->sa_year;\n\t\tfile_hdr->sa_day = f_hdr_2173->sa_day;\n\t\tfile_hdr->sa_month = f_hdr_2173->sa_month;\n\t\tfile_hdr->sa_sizeof_long = f_hdr_2173->sa_sizeof_long;\n\t\tstrncpy(file_hdr->sa_sysname, f_hdr_2173->sa_sysname, sizeof(file_hdr->sa_sysname));\n\t\tfile_hdr->sa_sysname[sizeof(file_hdr->sa_sysname) - 1] = '\\0';\n\t\tstrncpy(file_hdr->sa_nodename, f_hdr_2173->sa_nodename, sizeof(file_hdr->sa_nodename));\n\t\tfile_hdr->sa_nodename[sizeof(file_hdr->sa_nodename) - 1] = '\\0';\n\t\tstrncpy(file_hdr->sa_release, f_hdr_2173->sa_release, sizeof(file_hdr->sa_release));\n\t\tfile_hdr->sa_release[sizeof(file_hdr->sa_release) - 1] = '\\0';\n\t\tstrncpy(file_hdr->sa_machine, f_hdr_2173->sa_machine, sizeof(file_hdr->sa_machine));\n\t\tfile_hdr->sa_machine[sizeof(file_hdr->sa_machine) - 1] = '\\0';\n\n\t\t*vol_act_nr = f_hdr_2173->sa_vol_act_nr;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfile_hdr->act_types_nr[i] = act_types_nr[i];\n\t\tfile_hdr->rec_types_nr[i] = rec_types_nr[i];\n\t}\n\tfile_hdr->act_size = FILE_ACTIVITY_SIZE;\n\tfile_hdr->rec_size = RECORD_HEADER_SIZE;\n\n\t/*\n\t * Note: @extra_next and @sa_tzname[] members are set to zero\n\t * because file_hdr has been memset'd to zero.\n\t */\n}\n\n/*\n ***************************************************************************\n * Read and upgrade file's header section.\n *\n * IN:\n * @dfile\tSystem activity data file name.\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n * @act\t\tArray of activities.\n * @file_magic\tFile's magic structure.\n * @hdr_size\tSize of header structure read from file.\n * @previous_format\n *\t\tFormat magic number of file to convert.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n *\n * OUT:\n * @file_hdr\tFile's header structure (up-to-date format).\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n * @vol_act_nr\tNumber of volatile activity structures following a restart\n *\t\trecord for 0x2173 file format.\n * @ofile_actlst\n *\t\tActivity list in file.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_header_section(char dfile[], int fd, int stdfd, struct activity *act[],\n\t\t\t   struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t\t   unsigned int hdr_size, int previous_format, int *arch_64,\n\t\t\t   int endian_mismatch, unsigned int *vol_act_nr,\n\t\t\t   struct old_file_activity **ofile_actlst)\n{\n\tstruct old_file_activity *ofal;\n\tstruct file_header fh;\n\tint i, n, p;\n\tunsigned int a_cpu = FALSE;\n\tvoid *buffer = NULL;\n\n\tfprintf(stderr, \"file_header: \");\n\n\t/* Read file header structure */\n\tn = (previous_format == FORMAT_MAGIC_2171 ? FILE_HEADER_SIZE_2171\n\t\t\t\t\t\t  : hdr_size);\n\tSREALLOC(buffer, char, n);\n\tsa_fread(fd, buffer, (size_t) n, HARD_SIZE, UEOF_STOP);\n\n\t/* Upgrade file_header structure */\n\tupgrade_file_header(buffer, file_hdr, previous_format,\n\t\t\t    endian_mismatch, arch_64, vol_act_nr);\n\n\tfree(buffer);\n\n\t/* Sanity check */\n\tif (file_hdr->sa_act_nr > MAX_NR_ACT)\n\t\tgoto invalid_header;\n\n\t/* Read file activity list */\n\tSREALLOC(*ofile_actlst, struct old_file_activity, OLD_FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tofal = *ofile_actlst;\n\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, ofal++) {\n\n\t\tsa_fread(fd, ofal, OLD_FILE_ACTIVITY_SIZE, HARD_SIZE, UEOF_STOP);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(oact_types_nr, ofal, *arch_64);\n\t\t}\n\n\t\tif ((ofal->nr < 1) || (ofal->nr2 < 1) ||\n\t\t    (ofal->nr > NR_MAX) || (ofal->nr2 > NR2_MAX))\n\t\t\t/*\n\t\t\t * Every activity, known or unknown,\n\t\t\t * should have at least one item and sub-item.\n\t\t\t */\n\t\t\tgoto invalid_header;\n\n\t\tif ((p = get_activity_position(act, ofal->id, RESUME_IF_NOT_FOUND)) >= 0) {\n\t\t\t/* This is a known activity, maybe with an unknown format */\n\n\t\t\tif ((ofal->id == A_CPU) && !a_cpu) {\n\t\t\t\t/*\n\t\t\t\t * We have found the CPU activity: Set sa_cpu_nr field\n\t\t\t\t * in file_header structure that should contains the\n\t\t\t\t * number of CPU when the file was created.\n\t\t\t\t */\n\t\t\t\tfile_hdr->sa_cpu_nr = ofal->nr;\n\t\t\t\ta_cpu = TRUE;\n\t\t\t}\n\n\t\t\t/* Sanity checks */\n\t\t\tif (!ofal->size || (ofal->size > MAX_ITEM_STRUCT_SIZE))\n\t\t\t\tgoto invalid_header;\n\n\t\t\t/*\n\t\t\t * When upgrading a file:\n\t\t\t * ofal->size\t: Size of an item for current activity, as\n\t\t\t * \t\t  read from the file.\n\t\t\t * act[p]->msize: Size of the buffer in memory where an item\n\t\t\t * \t\t  for current activity, as read from the file,\n\t\t\t * \t\t  will be saved. We have:\n\t\t\t * \t\t  act[p]->msize >= {ofal->size ; act[p]->fsize}\n\t\t\t * act[p]->fsize: Size of an item for current activity with\n\t\t\t * \t\t  up-to-date format.\n\t\t\t */\n\n\t\t\t/* Size of activity in file is larger than up-to-date activity size */\n\t\t\tif (ofal->size > act[p]->msize) {\n\t\t\t\tact[p]->msize = ofal->size;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Don't set act[p]->fsize! Should retain the size of an item\n\t\t\t * for up-to-date format!\n\t\t\t */\n\n\t\t\tif ((ofal->id == A_IRQ) && (ofal->magic < ACTIVITY_MAGIC_BASE + 2)) {\n\t\t\t\t/* Special processing for A_IRQ activity */\n\t\t\t\tact[p]->nr_ini = 1;\t/* Only CPU \"all\" */\n\t\t\t\tact[p]->nr2    = ofal->nr;\t/* Number of interrupts in file */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tact[p]->nr_ini = ofal->nr;\n\t\t\t\tact[p]->nr2    = ofal->nr2;\n\t\t\t}\n\t\t}\n\t\t/* else: Unknown activity. Maybe an old one which has been made obsolete? */\n\t}\n\n\tif (!a_cpu) {\n\t\t/*\n\t\t * CPU activity should always be in file for versions older than 11.7.1\n\t\t * and have a known format (expected magical number).\n\t\t */\n\t\tfprintf(stderr, _(\"\\nCPU activity not found in file. Aborting...\\n\"));\n\t\treturn -1;\n\t}\n\n\tmemcpy(&fh, file_hdr, FILE_HEADER_SIZE);\n\t/* Restore endianness before writing */\n\tif (endian_mismatch) {\n\t\t/* Start swapping at field \"header_size\" position */\n\t\tswap_struct(hdr_types_nr, &fh, *arch_64);\n\t}\n\n\t/* Write file_header structure */\n\tif ((n = write_all(stdfd, &fh, FILE_HEADER_SIZE)) != FILE_HEADER_SIZE) {\n\t\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfprintf(stderr, \"OK\\n\");\n\n\treturn 0;\n\ninvalid_header:\n\n\tfprintf(stderr, _(\"\\n%s: Invalid data found. Aborting...\\n\"),\n\t\t__FUNCTION__);\n\n\treturn -1;\n\n}\n\n/*\n ***************************************************************************\n * Convert a long integer value to a long long integer value.\n * The long integer value may be 32 or 64-bit wide and come from a 32 or\n * 64-bit architecture.\n *\n * Note: Consider the value 0x01020304 read on a 32-bit machine.\n * Big-endian, saved as:   01 02 03 04\n * Lille-endian, saved as: 04 03 02 01\n * The value should be saved as a 64-bit value and endianness should be\n * preserved:\n * Big-endian:    00 00 00 00 01 02 03 04\n * Little-endian: 04 03 02 01 00 00 00 00\n *\n * IN:\n * @buffer\tAddress of value to convert.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nunsigned long long moveto_long_long(void *buffer, int endian_mismatch, int arch_64)\n{\n\tunsigned int *u_int;\n\n\tif (arch_64) {\n\t\tunsigned long long *ull_int = (unsigned long long *) buffer;\n\t\treturn *ull_int;\n\t}\n\n\tu_int = (unsigned int *) buffer;\n\tif (endian_mismatch) {\n\t\tunsigned long long ull_i = (unsigned long long) *u_int;\n\t\treturn (ull_i >> 32) | (ull_i << 32);\n\t}\n\telse {\n\t\treturn (unsigned long long) *u_int;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_cpu structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @st_size\tSize of the structure read from file.\n ***************************************************************************\n */\nvoid upgrade_stats_cpu(struct activity *act[], int p, int st_size)\n{\n\tint i;\n\tstruct stats_cpu *scc;\n\tstruct stats_cpu_8a *scp;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t/*\n\t\t * For previous structure's format: Use msize (which has possibly been set to\n\t\t * the size of the structure read from disk if it's greater than that of\n\t\t * current format: See upgrade_header_section()).\n\t\t * For current structure format: Use fsize. This is the normal size of\n\t\t * structure's up-to-date format that will be written to file.\n\t\t */\n\t\tscp = (struct stats_cpu_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\tscc = (struct stats_cpu *)    ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\tscc->cpu_user = scp->cpu_user;\n\t\tscc->cpu_nice = scp->cpu_nice;\n\t\tscc->cpu_sys = scp->cpu_sys;\n\t\tscc->cpu_idle = scp->cpu_idle;\n\t\tscc->cpu_iowait = scp->cpu_iowait;\n\t\tscc->cpu_steal = scp->cpu_steal;\n\t\tscc->cpu_hardirq = scp->cpu_hardirq;\n\t\tscc->cpu_softirq = scp->cpu_softirq;\n\t\tscc->cpu_guest = scp->cpu_guest;\n\n\t\tif (st_size >= STATS_CPU_8A_SIZE) {\n\t\t\t/* guest_nice field has been added without a structure format change */\n\t\t\tscc->cpu_guest_nice = scp->cpu_guest_nice;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_pcsw structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\nvoid upgrade_stats_pcsw(struct activity *act[], int p)\n{\n\tstruct stats_pcsw *spc = (struct stats_pcsw *) act[p]->buf[1];\n\tstruct stats_pcsw_8a *spp = (struct stats_pcsw_8a *) act[p]->buf[0];\n\n\tspc->context_switch = spp->context_switch;\n\t/*\n\t * Copy a long into a long. Take into account that file may have been\n\t * created on a 64-bit machine and we may be converting on a 32-bit machine.\n\t */\n\tmemcpy(&spc->processes, &spp->processes, 8);\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_irq structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n ***************************************************************************\n */\nvoid upgrade_stats_irq(struct activity *act[], int p, unsigned int magic)\n{\n\tint i;\n\tstruct stats_irq *sic;\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_irq_8a *sip;\n\n\t\t/* For each interrupt saved in the file to convert */\n\t\tfor (i = 0; i < act[p]->nr2; i++) {\n\t\t\tsip = (struct stats_irq_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsic = (struct stats_irq *)    ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\t/* Hum... Probably something to do if there is an endian mismatch... */\n\t\t\tsic->irq_nr = (unsigned int) sip->irq_nr;\n\t\t\tif (!i) {\n\t\t\t\t/* This is interrupts \"sum\" */\n\t\t\t\tstrcpy(sic->irq_name, K_LOWERSUM);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsnprintf(sic->irq_name, sizeof(sic->irq_name), \"%d\", i - 1 > NR2_MAX ? NR2_MAX : i - 1);\n\t\t\t\tsic->irq_name[sizeof(sic->irq_name) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tstruct stats_irq_8b *sip;\n\n\t\tfor (i = 0; i < act[p]->nr2; i++) {\n\t\t\tsip = (struct stats_irq_8b *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsic = (struct stats_irq *)    ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\t/* Endian mismatch should be tested before... */\n\t\t\tsic->irq_nr = (unsigned int) sip->irq_nr;\n\t\t\tif (!i) {\n\t\t\t\t/* This is interrupts \"sum\" */\n\t\t\t\tstrcpy(sic->irq_name, K_LOWERSUM);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsnprintf(sic->irq_name, sizeof(sic->irq_name), \"%d\", i - 1 > NR2_MAX ? NR2_MAX : i - 1);\n\t\t\t\tsic->irq_name[sizeof(sic->irq_name) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_io structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n ***************************************************************************\n */\nvoid upgrade_stats_io(struct activity *act[], int p, int endian_mismatch)\n{\n\tstruct stats_io *sic = (struct stats_io *) act[p]->buf[1];\n\tstruct stats_io_8a *sip = (struct stats_io_8a *) act[p]->buf[0];\n\n\tsic->dk_drive = moveto_long_long(&sip->dk_drive, endian_mismatch, FALSE);\n\tsic->dk_drive_rio = moveto_long_long(&sip->dk_drive_rio, endian_mismatch, FALSE);\n\tsic->dk_drive_wio = moveto_long_long(&sip->dk_drive_wio, endian_mismatch, FALSE);\n\tsic->dk_drive_rblk = moveto_long_long(&sip->dk_drive_rblk, endian_mismatch, FALSE);\n\tsic->dk_drive_wblk = moveto_long_long(&sip->dk_drive_wblk, endian_mismatch, FALSE);\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_memory structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @st_size\tSize of the structure read from file.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_memory(struct activity *act[], int p, int st_size,\n\t\t\t  int endian_mismatch, int arch_64)\n{\n\tstruct stats_memory *smc = (struct stats_memory *) act[p]->buf[1];\n\tstruct stats_memory_8a *smp = (struct stats_memory_8a *) act[p]->buf[0];\n\n\tsmc->frmkb = moveto_long_long(&smp->frmkb, endian_mismatch, arch_64);\n\tsmc->bufkb = moveto_long_long(&smp->bufkb, endian_mismatch, arch_64);\n\tsmc->camkb = moveto_long_long(&smp->camkb, endian_mismatch, arch_64);\n\tsmc->tlmkb = moveto_long_long(&smp->tlmkb, endian_mismatch, arch_64);\n\tsmc->frskb = moveto_long_long(&smp->frskb, endian_mismatch, arch_64);\n\tsmc->tlskb = moveto_long_long(&smp->tlskb, endian_mismatch, arch_64);\n\tsmc->caskb = moveto_long_long(&smp->caskb, endian_mismatch, arch_64);\n\tsmc->comkb = moveto_long_long(&smp->comkb, endian_mismatch, arch_64);\n\tsmc->activekb = moveto_long_long(&smp->activekb, endian_mismatch, arch_64);\n\tsmc->inactkb = moveto_long_long(&smp->inactkb, endian_mismatch, arch_64);\n\n\t/* Some fields have been added without a structure format change */\n\tif (st_size >= STATS_MEMORY_8A_1_SIZE) {\n\t\t\t\tsmc->dirtykb = moveto_long_long(&smp->dirtykb, endian_mismatch, arch_64);\n\t}\n\tif (st_size >= STATS_MEMORY_8A_2_SIZE) {\n\t\tsmc->anonpgkb = moveto_long_long(&smp->anonpgkb, endian_mismatch, arch_64);\n\t\tsmc->slabkb = moveto_long_long(&smp->slabkb, endian_mismatch, arch_64);\n\t\tsmc->kstackkb = moveto_long_long(&smp->kstackkb, endian_mismatch, arch_64);\n\t\tsmc->pgtblkb = moveto_long_long(&smp->pgtblkb, endian_mismatch, arch_64);\n\t\tsmc->vmusedkb = moveto_long_long(&smp->vmusedkb, endian_mismatch, arch_64);\n\t}\n\tif (st_size >= STATS_MEMORY_8A_SIZE) {\n\t\tsmc->availablekb = moveto_long_long(&(smp->availablekb), endian_mismatch, arch_64);;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_ktables structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n ***************************************************************************\n */\nvoid upgrade_stats_ktables(struct activity *act[], int p, int endian_mismatch)\n{\n\tstruct stats_ktables *skc = (struct stats_ktables *) act[p]->buf[1];\n\tstruct stats_ktables_8a *skp = (struct stats_ktables_8a *) act[p]->buf[0];\n\n\tskc->file_used = moveto_long_long(&skp->file_used, endian_mismatch, FALSE);\n\tskc->inode_used = moveto_long_long(&skp->inode_used, endian_mismatch, FALSE);\n\tskc->dentry_stat = moveto_long_long(&skp->dentry_stat, endian_mismatch, FALSE);\n\tskc->pty_nr = moveto_long_long(&skp->pty_nr, endian_mismatch, FALSE);\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_queue structure (from ACTIVITY_MAGIC_BASE or\n * ACTIVITY_MAGIC_BASE + 1 format to ACTIVITY_MAGIC_BASE + 2 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_queue(struct activity *act[], int p, unsigned int magic,\n\t\t\t int endian_mismatch, int arch_64)\n{\n\tstruct stats_queue *sqc = (struct stats_queue *) act[p]->buf[1];\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_queue_8a *sqp = (struct stats_queue_8a *) act[p]->buf[0];\n\n\t\tsqc->nr_running = moveto_long_long(&sqp->nr_running, endian_mismatch, arch_64);\n\t\tsqc->procs_blocked = 0ULL;\t/* New field */\n\t\tsqc->nr_threads = moveto_long_long(&sqp->nr_threads, endian_mismatch, FALSE);\n\t\tsqc->load_avg_1 = sqp->load_avg_1;\n\t\tsqc->load_avg_5 = sqp->load_avg_5;\n\t\tsqc->load_avg_15 = sqp->load_avg_15;\n\t}\n\telse {\n\t\tstruct stats_queue_8b *sqp = (struct stats_queue_8b *) act[p]->buf[0];\n\n\t\tsqc->nr_running = moveto_long_long(&sqp->nr_running, endian_mismatch, arch_64);\n\t\tsqc->procs_blocked = moveto_long_long(&sqp->procs_blocked, endian_mismatch, arch_64);\n\t\tsqc->nr_threads = moveto_long_long(&sqp->nr_threads, endian_mismatch, FALSE);\n\t\tsqc->load_avg_1 = sqp->load_avg_1;\n\t\tsqc->load_avg_5 = sqp->load_avg_5;\n\t\tsqc->load_avg_15 = sqp->load_avg_15;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_serial structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @st_size\tSize of the structure read from file.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n *\n * RETURNS:\n * Number of serial line structures that actually need to be written to\n * disk.\n ***************************************************************************\n */\nint upgrade_stats_serial(struct activity *act[], int p, size_t st_size, int endian_mismatch)\n{\n\tint i;\n\tunsigned int line;\n\tstruct stats_serial *ssc;\n\n\t/* Copy TTY stats to target structure */\n\tmemcpy(act[p]->buf[1], act[p]->buf[0], (size_t) act[p]->nr_ini * st_size);\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tssc = (struct stats_serial *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t/* Line number now starts at 0 instead of 1 */\n\t\tline = (endian_mismatch ? __builtin_bswap32(ssc->line) : ssc->line);\n\t\tif (!line)\n\t\t\tbreak;\n\t\tline--;\n\t\tssc->line = (endian_mismatch ? __builtin_bswap32(line) : line);\n\t}\n\n\treturn i;\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_disk structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_disk(struct activity *act[], int p, unsigned int magic,\n\t\t\tint endian_mismatch, int arch_64)\n{\n\tint i;\n\tstruct stats_disk *sdc;\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_disk_8a *sdp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsdp = (struct stats_disk_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsdc = (struct stats_disk *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsdc->nr_ios = moveto_long_long(&sdp->nr_ios, endian_mismatch, arch_64);\n\t\t\tsdc->rd_sect = (unsigned long) sdp->rd_sect;\n\t\t\tsdc->wr_sect = (unsigned long) sdp->wr_sect;\n\t\t\tsdc->rd_ticks = (unsigned int) sdp->rd_ticks;\n\t\t\tsdc->wr_ticks = (unsigned int) sdp->wr_ticks;\n\t\t\tsdc->tot_ticks = (unsigned int) sdp->tot_ticks;\n\t\t\tsdc->rq_ticks = (unsigned int) sdp->rq_ticks;\n\t\t\tsdc->major = sdp->major;\n\t\t\tsdc->minor = sdp->minor;\n\t\t}\n\t}\n\telse {\n\t\tstruct stats_disk_8b *sdp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsdp = (struct stats_disk_8b *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsdc = (struct stats_disk *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsdc->nr_ios = sdp->nr_ios;\n\t\t\tmemcpy(&sdc->rd_sect, &sdp->rd_sect, 8);\n\t\t\tmemcpy(&sdc->wr_sect, &sdp->wr_sect, 8);\n\t\t\tsdc->rd_ticks = sdp->rd_ticks;\n\t\t\tsdc->wr_ticks = sdp->wr_ticks;\n\t\t\tsdc->tot_ticks = sdp->tot_ticks;\n\t\t\tsdc->rq_ticks = sdp->rq_ticks;\n\t\t\tsdc->major = sdp->major;\n\t\t\tsdc->minor = sdp->minor;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_net_dev structure (from ACTIVITY_MAGIC_BASE or\n * ACTIVITY_MAGIC_BASE + 1 format to ACTIVITY_MAGIC_BASE + 3 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_net_dev(struct activity *act[], int p, unsigned int magic,\n\t\t\t   int endian_mismatch, int arch_64)\n{\n\tint i;\n\tstruct stats_net_dev *sndc;\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_net_dev_8a *sndp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsndp = (struct stats_net_dev_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsndc = (struct stats_net_dev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsndc->rx_packets = moveto_long_long(&sndp->rx_packets, endian_mismatch, arch_64);\n\t\t\tsndc->tx_packets = moveto_long_long(&sndp->tx_packets, endian_mismatch, arch_64);\n\t\t\tsndc->rx_bytes = moveto_long_long(&sndp->rx_bytes, endian_mismatch, arch_64);\n\t\t\tsndc->tx_bytes = moveto_long_long(&sndp->tx_bytes, endian_mismatch, arch_64);\n\t\t\tsndc->rx_compressed = moveto_long_long(&sndp->rx_compressed, endian_mismatch, arch_64);\n\t\t\tsndc->tx_compressed = moveto_long_long(&sndp->tx_compressed, endian_mismatch, arch_64);\n\t\t\tsndc->multicast = moveto_long_long(&sndp->multicast, endian_mismatch, arch_64);\n\t\t\tsndc->speed = 0; /* New field */\n\t\t\tstrncpy(sndc->interface, sndp->interface, sizeof(sndc->interface));\n\t\t\tsndc->interface[sizeof(sndc->interface) - 1] = '\\0';\n\t\t\tsndc->duplex = '\\0'; /* New field */\n\t\t}\n\t}\n\telse if (magic == ACTIVITY_MAGIC_BASE + 1) {\n\t\tstruct stats_net_dev_8b *sndp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsndp = (struct stats_net_dev_8b *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsndc = (struct stats_net_dev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsndc->rx_packets = sndp->rx_packets;\n\t\t\tsndc->tx_packets = sndp->tx_packets;\n\t\t\tsndc->rx_bytes = sndp->rx_bytes;\n\t\t\tsndc->tx_bytes = sndp->tx_bytes;\n\t\t\tsndc->rx_compressed = sndp->rx_compressed;\n\t\t\tsndc->tx_compressed = sndp->tx_compressed;\n\t\t\tsndc->multicast = sndp->multicast;\n\t\t\tsndc->speed = 0; /* New field */\n\t\t\tstrncpy(sndc->interface, sndp->interface, sizeof(sndc->interface));\n\t\t\tsndc->interface[sizeof(sndc->interface) - 1] = '\\0';\n\t\t\tsndc->duplex = '\\0'; /* New field */\n\t\t}\n\t}\n\telse {\n\t\tstruct stats_net_dev_8c *sndp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsndp = (struct stats_net_dev_8c *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsndc = (struct stats_net_dev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsndc->rx_packets = sndp->rx_packets;\n\t\t\tsndc->tx_packets = sndp->tx_packets;\n\t\t\tsndc->rx_bytes = sndp->rx_bytes;\n\t\t\tsndc->tx_bytes = sndp->tx_bytes;\n\t\t\tsndc->rx_compressed = sndp->rx_compressed;\n\t\t\tsndc->tx_compressed = sndp->tx_compressed;\n\t\t\tsndc->multicast = sndp->multicast;\n\t\t\tsndc->speed = sndp->speed;\n\t\t\tstrncpy(sndc->interface, sndp->interface, sizeof(sndc->interface));\n\t\t\tsndc->interface[sizeof(sndc->interface) - 1] = '\\0';\n\t\t\tsndc->duplex = sndp->duplex;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_net_edev structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_net_edev(struct activity *act[], int p, unsigned int magic,\n\t\t\t    int endian_mismatch, int arch_64)\n{\n\tint i;\n\tstruct stats_net_edev *snedc;\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_net_edev_8a *snedp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsnedp = (struct stats_net_edev_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsnedc = (struct stats_net_edev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsnedc->collisions = moveto_long_long(&snedp->collisions, endian_mismatch, arch_64);\n\t\t\tsnedc->rx_errors = moveto_long_long(&snedp->rx_errors, endian_mismatch, arch_64);\n\t\t\tsnedc->tx_errors = moveto_long_long(&snedp->tx_errors, endian_mismatch, arch_64);\n\t\t\tsnedc->rx_dropped = moveto_long_long(&snedp->rx_dropped, endian_mismatch, arch_64);\n\t\t\tsnedc->tx_dropped = moveto_long_long(&snedp->tx_dropped, endian_mismatch, arch_64);\n\t\t\tsnedc->rx_fifo_errors = moveto_long_long(&snedp->rx_fifo_errors, endian_mismatch, arch_64);\n\t\t\tsnedc->tx_fifo_errors = moveto_long_long(&snedp->tx_fifo_errors, endian_mismatch, arch_64);\n\t\t\tsnedc->rx_frame_errors = moveto_long_long(&snedp->rx_frame_errors, endian_mismatch, arch_64);\n\t\t\tsnedc->tx_carrier_errors = moveto_long_long(&snedp->tx_carrier_errors, endian_mismatch, arch_64);\n\t\t\tstrncpy(snedc->interface, snedp->interface, sizeof(snedc->interface));\n\t\t\tsnedc->interface[sizeof(snedc->interface) - 1] = '\\0';\n\t\t}\n\t}\n\telse {\n\t\tstruct stats_net_edev_8b *snedp;\n\n\t\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\t\tsnedp = (struct stats_net_edev_8b *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\t\tsnedc = (struct stats_net_edev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\t\tsnedc->collisions = snedp->collisions;\n\t\t\tsnedc->rx_errors = snedp->rx_errors;\n\t\t\tsnedc->tx_errors = snedp->tx_errors;\n\t\t\tsnedc->rx_dropped = snedp->rx_dropped;\n\t\t\tsnedc->tx_dropped = snedp->tx_dropped;\n\t\t\tsnedc->rx_fifo_errors = snedp->rx_fifo_errors;\n\t\t\tsnedc->tx_fifo_errors = snedp->tx_fifo_errors;\n\t\t\tsnedc->rx_frame_errors = snedp->rx_frame_errors;\n\t\t\tsnedc->tx_carrier_errors = snedp->tx_carrier_errors;\n\t\t\tstrncpy(snedc->interface, snedp->interface, sizeof(snedc->interface));\n\t\t\tsnedc->interface[sizeof(snedc->interface) - 1] = '\\0';\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_net_ip structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_net_ip(struct activity *act[], int p, unsigned int magic,\n\t\t\t  int endian_mismatch, int arch_64)\n{\n\tstruct stats_net_ip *snic = (struct stats_net_ip *) act[p]->buf[1];\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_net_ip_8a *snip = (struct stats_net_ip_8a *) act[p]->buf[0];\n\n\t\tsnic->InReceives = moveto_long_long(&snip->InReceives, endian_mismatch, arch_64);\n\t\tsnic->ForwDatagrams = moveto_long_long(&snip->ForwDatagrams, endian_mismatch, arch_64);\n\t\tsnic->InDelivers = moveto_long_long(&snip->InDelivers, endian_mismatch, arch_64);\n\t\tsnic->OutRequests = moveto_long_long(&snip->OutRequests, endian_mismatch, arch_64);\n\t\tsnic->ReasmReqds = moveto_long_long(&snip->ReasmReqds, endian_mismatch, arch_64);\n\t\tsnic->ReasmOKs = moveto_long_long(&snip->ReasmOKs, endian_mismatch, arch_64);\n\t\tsnic->FragOKs = moveto_long_long(&snip->FragOKs, endian_mismatch, arch_64);\n\t\tsnic->FragCreates = moveto_long_long(&snip->FragCreates, endian_mismatch, arch_64);\n\t}\n\telse {\n\t\tstruct stats_net_ip_8b *snip = (struct stats_net_ip_8b *) act[p]->buf[0];\n\n\t\tsnic->InReceives = snip->InReceives;\n\t\tsnic->ForwDatagrams = snip->ForwDatagrams;\n\t\tsnic->InDelivers = snip->InDelivers;\n\t\tsnic->OutRequests = snip->OutRequests;\n\t\tsnic->ReasmReqds = snip->ReasmReqds;\n\t\tsnic->ReasmOKs = snip->ReasmOKs;\n\t\tsnic->FragOKs = snip->FragOKs;\n\t\tsnic->FragCreates = snip->FragCreates;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_net_eip structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_net_eip(struct activity *act[], int p, unsigned int magic,\n\t\t\t   int endian_mismatch, int arch_64)\n{\n\tstruct stats_net_eip *sneic = (struct stats_net_eip *) act[p]->buf[1];\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_net_eip_8a *sneip = (struct stats_net_eip_8a *) act[p]->buf[0];\n\n\t\tsneic->InHdrErrors = moveto_long_long(&sneip->InHdrErrors, endian_mismatch, arch_64);\n\t\tsneic->InAddrErrors = moveto_long_long(&sneip->InAddrErrors, endian_mismatch, arch_64);\n\t\tsneic->InUnknownProtos = moveto_long_long(&sneip->InUnknownProtos, endian_mismatch, arch_64);\n\t\tsneic->InDiscards = moveto_long_long(&sneip->InDiscards, endian_mismatch, arch_64);\n\t\tsneic->OutDiscards = moveto_long_long(&sneip->OutDiscards, endian_mismatch, arch_64);\n\t\tsneic->OutNoRoutes = moveto_long_long(&sneip->OutNoRoutes, endian_mismatch, arch_64);\n\t\tsneic->ReasmFails = moveto_long_long(&sneip->ReasmFails, endian_mismatch, arch_64);\n\t\tsneic->FragFails = moveto_long_long(&sneip->FragFails, endian_mismatch, arch_64);\n\t}\n\telse {\n\t\tstruct stats_net_eip_8b *sneip = (struct stats_net_eip_8b *) act[p]->buf[0];\n\n\t\tsneic->InHdrErrors = sneip->InHdrErrors;\n\t\tsneic->InAddrErrors = sneip->InAddrErrors;\n\t\tsneic->InUnknownProtos = sneip->InUnknownProtos;\n\t\tsneic->InDiscards = sneip->InDiscards;\n\t\tsneic->OutDiscards = sneip->OutDiscards;\n\t\tsneic->OutNoRoutes = sneip->OutNoRoutes;\n\t\tsneic->ReasmFails = sneip->ReasmFails;\n\t\tsneic->FragFails = sneip->FragFails;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_net_ip6 structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_net_ip6(struct activity *act[], int p, unsigned int magic,\n\t\t\t   int endian_mismatch, int arch_64)\n{\n\tstruct stats_net_ip6 *snic6 = (struct stats_net_ip6 *) act[p]->buf[1];\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_net_ip6_8a *snip6 = (struct stats_net_ip6_8a *) act[p]->buf[0];\n\n\t\tsnic6->InReceives6 = moveto_long_long(&snip6->InReceives6, endian_mismatch, arch_64);\n\t\tsnic6->OutForwDatagrams6 = moveto_long_long(&snip6->OutForwDatagrams6, endian_mismatch, arch_64);\n\t\tsnic6->InDelivers6 = moveto_long_long(&snip6->InDelivers6, endian_mismatch, arch_64);\n\t\tsnic6->OutRequests6 = moveto_long_long(&snip6->OutRequests6, endian_mismatch, arch_64);\n\t\tsnic6->ReasmReqds6 = moveto_long_long(&snip6->ReasmReqds6, endian_mismatch, arch_64);\n\t\tsnic6->ReasmOKs6 = moveto_long_long(&snip6->ReasmOKs6, endian_mismatch, arch_64);\n\t\tsnic6->InMcastPkts6 = moveto_long_long(&snip6->InMcastPkts6, endian_mismatch, arch_64);\n\t\tsnic6->OutMcastPkts6 = moveto_long_long(&snip6->OutMcastPkts6, endian_mismatch, arch_64);\n\t\tsnic6->FragOKs6 = moveto_long_long(&snip6->FragOKs6, endian_mismatch, arch_64);\n\t\tsnic6->FragCreates6 = moveto_long_long(&snip6->FragCreates6, endian_mismatch, arch_64);\n\t}\n\telse {\n\t\tstruct stats_net_ip6_8b *snip6 = (struct stats_net_ip6_8b *) act[p]->buf[0];\n\n\t\tsnic6->InReceives6 = snip6->InReceives6;\n\t\tsnic6->OutForwDatagrams6 = snip6->OutForwDatagrams6;\n\t\tsnic6->InDelivers6 = snip6->InDelivers6;\n\t\tsnic6->OutRequests6 = snip6->OutRequests6;\n\t\tsnic6->ReasmReqds6 = snip6->ReasmReqds6;\n\t\tsnic6->ReasmOKs6 = snip6->ReasmOKs6;\n\t\tsnic6->InMcastPkts6 = snip6->InMcastPkts6;\n\t\tsnic6->OutMcastPkts6 = snip6->OutMcastPkts6;\n\t\tsnic6->FragOKs6 = snip6->FragOKs6;\n\t\tsnic6->FragCreates6 = snip6->FragCreates6;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_net_eip6 structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @magic\tStructure format magic value.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_net_eip6(struct activity *act[], int p, unsigned int magic,\n\t\t\t    int endian_mismatch, int arch_64)\n{\n\tstruct stats_net_eip6 *sneic6 = (struct stats_net_eip6 *) act[p]->buf[1];\n\n\tif (magic == ACTIVITY_MAGIC_BASE) {\n\t\tstruct stats_net_eip6_8a *sneip6 = (struct stats_net_eip6_8a *) act[p]->buf[0];\n\n\t\tsneic6->InHdrErrors6 = moveto_long_long(&sneip6->InHdrErrors6, endian_mismatch, arch_64);\n\t\tsneic6->InAddrErrors6 = moveto_long_long(&sneip6->InAddrErrors6, endian_mismatch, arch_64);\n\t\tsneic6->InUnknownProtos6 = moveto_long_long(&sneip6->InUnknownProtos6, endian_mismatch, arch_64);\n\t\tsneic6->InTooBigErrors6 = moveto_long_long(&sneip6->InTooBigErrors6, endian_mismatch, arch_64);\n\t\tsneic6->InDiscards6 = moveto_long_long(&sneip6->InDiscards6, endian_mismatch, arch_64);\n\t\tsneic6->OutDiscards6 = moveto_long_long(&sneip6->OutDiscards6, endian_mismatch, arch_64);\n\t\tsneic6->InNoRoutes6 = moveto_long_long(&sneip6->InNoRoutes6, endian_mismatch, arch_64);\n\t\tsneic6->OutNoRoutes6 = moveto_long_long(&sneip6->OutNoRoutes6, endian_mismatch, arch_64);\n\t\tsneic6->ReasmFails6 = moveto_long_long(&sneip6->ReasmFails6, endian_mismatch, arch_64);\n\t\tsneic6->FragFails6 = moveto_long_long(&sneip6->FragFails6, endian_mismatch, arch_64);\n\t\tsneic6->InTruncatedPkts6 = moveto_long_long(&sneip6->InTruncatedPkts6, endian_mismatch, arch_64);\n\t}\n\telse {\n\t\tstruct stats_net_eip6_8b *sneip6 = (struct stats_net_eip6_8b *) act[p]->buf[0];\n\n\t\tsneic6->InHdrErrors6 = sneip6->InHdrErrors6;\n\t\tsneic6->InAddrErrors6 = sneip6->InAddrErrors6;\n\t\tsneic6->InUnknownProtos6 = sneip6->InUnknownProtos6;\n\t\tsneic6->InTooBigErrors6 = sneip6->InTooBigErrors6;\n\t\tsneic6->InDiscards6 = sneip6->InDiscards6;\n\t\tsneic6->OutDiscards6 = sneip6->OutDiscards6;\n\t\tsneic6->InNoRoutes6 = sneip6->InNoRoutes6;\n\t\tsneic6->OutNoRoutes6 = sneip6->OutNoRoutes6;\n\t\tsneic6->ReasmFails6 = sneip6->ReasmFails6;\n\t\tsneic6->FragFails6 = sneip6->FragFails6;\n\t\tsneic6->InTruncatedPkts6 = sneip6->InTruncatedPkts6;\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_huge structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n ***************************************************************************\n */\nvoid upgrade_stats_huge(struct activity *act[], int p,\n\t\t\tint endian_mismatch, int arch_64)\n{\n\tstruct stats_huge *shc = (struct stats_huge *) act[p]->buf[1];\n\tstruct stats_huge_8a *shp = (struct stats_huge_8a *) act[p]->buf[0];\n\n\tshc->frhkb = moveto_long_long(&shp->frhkb, endian_mismatch, arch_64);\n\tshc->tlhkb = moveto_long_long(&shp->tlhkb, endian_mismatch, arch_64);\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_pwr_wghfreq structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\nvoid upgrade_stats_pwr_wghfreq(struct activity *act[], int p)\n{\n\tint i, k;\n\n\tstruct stats_pwr_wghfreq *spc, *spc_k;\n\tstruct stats_pwr_wghfreq_8a *spp, *spp_k;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tspp = (struct stats_pwr_wghfreq_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize * act[p]->nr2);\n\t\tspc = (struct stats_pwr_wghfreq *) ((char *) act[p]->buf[1] + i * act[p]->fsize * act[p]->nr2);\n\n\t\tfor (k = 0; k < act[p]->nr2; k++) {\n\t\t\tspp_k = (struct stats_pwr_wghfreq_8a *) ((char *) spp + k * act[p]->msize);\n\t\t\tif (!spp_k->freq)\n\t\t\t\tbreak;\n\t\t\tspc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * act[p]->fsize);\n\n\t\t\tspc_k->time_in_state = spp_k->time_in_state;\n\t\t\tmemcpy(&spc_k->freq, &spp_k->freq, 8);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Upgrade stats_filesystem structure (from ACTIVITY_MAGIC_BASE format to\n * ACTIVITY_MAGIC_BASE + 1 format).\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n * @st_size\tSize of the structure read from file.\n ***************************************************************************\n */\nvoid upgrade_stats_filesystem(struct activity *act[], int p, int st_size)\n{\n\tint i;\n\tstruct stats_filesystem *sfc;\n\tstruct stats_filesystem_8a *sfp;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsfp = (struct stats_filesystem_8a *) ((char *) act[p]->buf[0] + i * act[p]->msize);\n\t\tsfc = (struct stats_filesystem *)    ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\n\t\tsfc->f_blocks = sfp->f_blocks;\n\t\tsfc->f_bfree = sfp->f_bfree;\n\t\tsfc->f_bavail = sfp->f_bavail;\n\t\tsfc->f_files = sfp->f_files;\n\t\tsfc->f_ffree = sfp->f_ffree;\n\t\tstrncpy(sfc->fs_name, sfp->fs_name, sizeof(sfc->fs_name));\n\t\tsfc->fs_name[sizeof(sfc->fs_name) - 1] = '\\0';\n\n\t\tif (st_size <= STATS_FILESYSTEM_8A_1_SIZE) {\n\t\t\t/* mountp didn't exist with older versions */\n\t\t\tsfc->mountp[0] = '\\0';\n\t\t}\n\t\telse {\n\t\t\tstrncpy(sfc->mountp, sfp->mountp, sizeof(sfc->mountp));\n\t\t\tsfc->mountp[sizeof(sfc->mountp) - 1] = '\\0';\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Count number of stats_disk structures that need to be written.\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\n__nr_t count_stats_disk(struct activity *act[], int p)\n{\n\tint i;\n\t__nr_t nr_dsk = 0;\n\tstruct stats_disk *sdc;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsdc = (struct stats_disk *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\t\tif (!(sdc->major + sdc->minor))\n\t\t\tbreak;\n\n\t\tnr_dsk++;\n\t}\n\n\treturn nr_dsk;\n}\n\n/*\n ***************************************************************************\n * Count number of stats_net_dev structures that need to be written.\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\n__nr_t count_stats_net_dev(struct activity *act[], int p)\n{\n\tint i;\n\t__nr_t nr_dev = 0;\n\tstruct stats_net_dev *sndc;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsndc = (struct stats_net_dev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\t\tif (!strcmp(sndc->interface, \"\"))\n\t\t\tbreak;\n\n\t\tnr_dev++;\n\t}\n\n\treturn nr_dev;\n}\n\n/*\n ***************************************************************************\n * Count number of stats_net_edev structures that need to be written.\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\n__nr_t count_stats_net_edev(struct activity *act[], int p)\n{\n\tint i;\n\t__nr_t nr_edev = 0;\n\tstruct stats_net_edev *snedc;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsnedc = (struct stats_net_edev *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\t\tif (!strcmp(snedc->interface, \"\"))\n\t\t\tbreak;\n\n\t\tnr_edev++;\n\t}\n\n\treturn nr_edev;\n}\n\n/*\n ***************************************************************************\n * Count number of stats_pwr_usb structures that need to be written.\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\n__nr_t count_stats_pwr_usb(struct activity *act[], int p)\n{\n\tint i;\n\t__nr_t nr_usb = 0;\n\tstruct stats_pwr_usb *suc;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsuc = (struct stats_pwr_usb *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\t\tif (!suc->bus_nr)\n\t\t\tbreak;\n\n\t\tnr_usb++;\n\t}\n\n\treturn nr_usb;\n}\n\n/*\n ***************************************************************************\n * Count number of stats_filesystem structures that need to be written.\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\n__nr_t count_stats_filesystem(struct activity *act[], int p)\n{\n\tint i;\n\t__nr_t nr_fs = 0;\n\tstruct stats_filesystem *sfc;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\t\tif (!sfc->f_blocks)\n\t\t\tbreak;\n\n\t\tnr_fs++;\n\t}\n\n\treturn nr_fs;\n}\n\n/*\n ***************************************************************************\n * Count number of stats_fchost structures that need to be written.\n *\n * IN:\n * @act\t\tArray of activities.\n * @p\t\tPosition of activity in array.\n ***************************************************************************\n */\n__nr_t count_stats_fchost(struct activity *act[], int p)\n{\n\tint i;\n\t__nr_t nr_fc = 0;\n\tstruct stats_fchost *sfcc;\n\n\tfor (i = 0; i < act[p]->nr_ini; i++) {\n\t\tsfcc = (struct stats_fchost *) ((char *) act[p]->buf[1] + i * act[p]->fsize);\n\t\tif (!sfcc->fchost_name[0])\n\t\t\tbreak;\n\n\t\tnr_fc++;\n\t}\n\n\treturn nr_fc;\n}\n\n/*\n ***************************************************************************\n * Upgrade file's activity list section.\n *\n * IN:\n * @stdfd\t\tFile descriptor for STDOUT.\n * @act\t\t\tArray of activities.\n * @file_hdr\t\tPointer on file_header structure.\n * @ofile_actlst\tActivity list in file.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n *\n * OUT:\n * @file_actlst\t\tActivity list with up-to-date format.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_activity_section(int stdfd, struct activity *act[],\n\t\t\t     struct file_header *file_hdr,\n\t\t\t     struct old_file_activity *ofile_actlst,\n\t\t\t     struct file_activity **file_actlst,\n\t\t\t     int endian_mismatch, int arch_64)\n{\n\tint i, j, p;\n\tstruct old_file_activity *ofal;\n\tstruct file_activity *fal, fa;\n\n\tfprintf(stderr, \"file_activity: \");\n\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\tofal = ofile_actlst;\n\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, ofal++, fal++) {\n\n\t\t/* Every activity should be known at the moment (may change in the future) */\n\t\tp = get_activity_position(act, ofal->id, EXIT_IF_NOT_FOUND);\n\t\tfal->id = ofal->id;\n\n\t\tif ((ofal->id == A_IRQ) && (ofal->magic < ACTIVITY_MAGIC_BASE + 2)) {\n\t\t\t/* Special processing for A_IRQ activity */\n\t\t\tfal->nr = 1;\t/* Only CPU \"all\" */\n\t\t\t/* The number of interrupts is the 2nd dimension of the matrix */\n\t\t\tfal->nr2 = ofal->nr;\n\t\t}\n\t\telse {\n\t\t\tfal->nr = ofal->nr;\n\t\t\tfal->nr2 = ofal->nr2;\n\t\t}\n\t\tfal->magic = act[p]->magic;\t/* Update activity magic number */\n\t\tfal->has_nr = HAS_COUNT_FUNCTION(act[p]->options);\n\t\t/* Also update its size, which may have changed with recent versions */\n\t\tfal->size = act[p]->fsize;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tfal->types_nr[j] = act[p]->gtypes_nr[j];\n\t\t}\n\n\t\tmemcpy(&fa, fal, FILE_ACTIVITY_SIZE);\n\t\t/* Restore endianness before writing */\n\t\tif (endian_mismatch) {\n\t\t\t/* Start swapping at field \"header_size\" position */\n\t\t\tswap_struct(act_types_nr, &fa, arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Even unknown activities must be written\n\t\t * (they are counted in sa_act_nr).\n\t\t */\n\t\tif (write_all(stdfd, &fa, FILE_ACTIVITY_SIZE) != FILE_ACTIVITY_SIZE) {\n\t\t\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tfprintf(stderr, \"%s \", act[p]->name);\n\t}\n\n\tfprintf(stderr, \"OK\\n\");\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Upgrade a record header.\n *\n * IN:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n * @orec_hdr\tRecord's header structure to convert.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_record_header(int fd, int stdfd, struct old_record_header *orec_hdr,\n\t\t\t  int endian_mismatch, int arch_64)\n{\n\tstruct record_header rec_hdr;\n\n\tmemset(&rec_hdr, 0, sizeof(struct record_header));\n\n\t/* Convert current record header */\n\trec_hdr.uptime_cs = orec_hdr->uptime0 * 100 / HZ;\t/* Uptime in cs, not jiffies */\n\trec_hdr.ust_time = (unsigned long long) orec_hdr->ust_time;\n\trec_hdr.record_type = orec_hdr->record_type;\n\trec_hdr.hour = orec_hdr->hour;\n\trec_hdr.minute = orec_hdr->minute;\n\trec_hdr.second = orec_hdr->second;\n\n\t/* Restore endianness before writing */\n\tif (endian_mismatch) {\n\t\tswap_struct(rec_types_nr, &rec_hdr, arch_64);\n\t}\n\n\t/* Write record header */\n\tif (write_all(stdfd, &rec_hdr, RECORD_HEADER_SIZE) != RECORD_HEADER_SIZE) {\n\t\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfprintf(stderr, \"H\");\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Upgrade a COMMENT record.\n *\n * IN:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_comment_record(int fd, int stdfd)\n{\n\tchar file_comment[MAX_COMMENT_LEN];\n\n\t/* Read the COMMENT record */\n\tsa_fread(fd, file_comment, sizeof(file_comment), HARD_SIZE, UEOF_STOP);\n\tfile_comment[sizeof(file_comment) - 1] = '\\0';\n\n\t/* Then write it. No changes at this time */\n\tif (write_all(stdfd, file_comment, sizeof(file_comment)) != sizeof(file_comment)) {\n\t\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfprintf(stderr, \"C\");\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Upgrade a RESTART record.\n *\n * IN:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n * @act\t\tArray of activities.\n * @file_hdr\tPointer on file_header structure.\n * @previous_format\n *\t\tTRUE is sa datafile has an old format which is no longer\n *\t\tcompatible with current one.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n * @vol_act_nr\tNumber of volatile activity structures.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_restart_record(int fd, int stdfd, struct activity *act[],\n\t\t\t   struct file_header *file_hdr, int previous_format,\n\t\t\t   int endian_mismatch, int arch_64, unsigned int vol_act_nr)\n{\n\n\tint p;\n\tstruct old_file_activity ofile_act;\n\t/* Number of cpu read in the activity list. See upgrade_header_section() */\n\t__nr_t cpu_nr = file_hdr->sa_cpu_nr;\n\n\tif (previous_format == FORMAT_MAGIC_2173) {\n\t\tint i;\n\n\t\t/*\n\t\t * For versions from 10.3.1 to 11.6.x,\n\t\t * the restart record is followed by a list\n\t\t * of volatile activity structures. Among them is A_CPU activity.\n\t\t */\n\t\tfor (i = 0; i < vol_act_nr; i++) {\n\t\t\tsa_fread(fd, &ofile_act, OLD_FILE_ACTIVITY_SIZE, HARD_SIZE, UEOF_STOP);\n\n\t\t\t/* Normalize endianness for file_activity structures */\n\t\t\tif (endian_mismatch) {\n\t\t\t\tswap_struct(oact_types_nr, &ofile_act, arch_64);\n\t\t\t}\n\n\t\t\tif (ofile_act.id && (ofile_act.nr > 0)) {\n\t\t\t\tp = get_activity_position(act, ofile_act.id, EXIT_IF_NOT_FOUND);\n\t\t\t\t/* Check upper bounds */\n\t\t\t\tif (ofile_act.nr > act[p]->nr_max) {\n\t\t\t\t\tfprintf(stderr, _(\"\\n%s: Invalid data found. Aborting...\\n\"),\n\t\t\t\t\t\t__FUNCTION__);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tact[p]->nr_ini = ofile_act.nr;\n\n\t\t\t\t/* Reallocate structures if needed */\n\t\t\t\tif (act[p]->nr_ini > act[p]->nr_allocated) {\n\t\t\t\t\tallocate_buffers(act[p], (size_t) act[p]->nr_ini, 0);\n\t\t\t\t}\n\t\t\t\tif (ofile_act.id == A_CPU) {\n\t\t\t\t\tcpu_nr = ofile_act.nr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore endianness before writing */\n\tif (endian_mismatch) {\n\t\tcpu_nr = __builtin_bswap32(cpu_nr);\n\t}\n\n\t/* Write new number of CPU following the restart record */\n\tif (write_all(stdfd, &cpu_nr, sizeof(__nr_t)) != sizeof(__nr_t)) {\n\t\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfprintf(stderr, \"R\");\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Upgrade a record which is not a COMMENT or a RESTART one.\n *\n * IN:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n * @act\t\tArray of activities.\n * @file_hdr\tPointer on file_header structure (up-to-date format).\n * @ofile_actlst\n *\t\tActivity list in file.\n * @file_actlst\tActivity list in file (up-to-date format).\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_common_record(int fd, int stdfd, struct activity *act[], struct file_header *file_hdr,\n\t\t\t  struct old_file_activity *ofile_actlst, struct file_activity *file_actlst,\n\t\t\t  int endian_mismatch, int arch_64)\n{\n\tint i, j, k, p;\n\t__nr_t nr_struct, nr;\n\tstruct old_file_activity *ofal = ofile_actlst;\n\tstruct file_activity *fal = file_actlst;\n\tchar cc;\n\n\t/*\n\t * This is not a special record, so read the extra fields,\n\t * even if the format of the activity is unknown.\n\t */\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, ofal++, fal++) {\n\n\t\t/* Every activity should be known at the moment (may change in the future) */\n\t\tp = get_activity_position(act, fal->id, EXIT_IF_NOT_FOUND);\n\n\t\t/* Warning: Stats structures keep their original endianness here */\n\t\tif ((act[p]->nr_ini > 0) &&\n\t\t    ((act[p]->nr_ini > 1) || (act[p]->nr2 > 1)) &&\n\t\t    (act[p]->msize > ofal->size)) {\n\t\t\tfor (j = 0; j < act[p]->nr_ini; j++) {\n\t\t\t\tfor (k = 0; k < act[p]->nr2; k++) {\n\t\t\t\t\tsa_fread(fd,\n\t\t\t\t\t\t (char *) act[p]->buf[0] + (j * act[p]->nr2 + k) * act[p]->msize,\n\t\t\t\t\t\t (size_t) ofal->size, HARD_SIZE, UEOF_STOP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (act[p]->nr_ini > 0) {\n\t\t\tsa_fread(fd, act[p]->buf[0],\n\t\t\t\t (size_t) ofal->size * (size_t) act[p]->nr_ini * (size_t) act[p]->nr2,\n\t\t\t\t HARD_SIZE, UEOF_STOP);\n\t\t}\n\n\t\tnr_struct = act[p]->nr_ini;\n\t\t/*\n\t\t * NB: Cannot upgrade a stats structure with\n\t\t * a magic number higher than currently known.\n\t\t */\n\t\tif (ofal->magic < act[p]->magic) {\n\t\t\tcc = 'u';\n\n\t\t\t/* Known activity but old format */\n\t\t\tswitch (fal->id) {\n\n\t\t\t\tcase A_CPU:\n\t\t\t\t\tupgrade_stats_cpu(act, p, ofal->size);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PCSW:\n\t\t\t\t\tupgrade_stats_pcsw(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_IRQ:\n\t\t\t\t\tupgrade_stats_irq(act, p, ofal->magic);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_IO:\n\t\t\t\t\tupgrade_stats_io(act, p, endian_mismatch);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_QUEUE:\n\t\t\t\t\tupgrade_stats_queue(act, p, ofal->magic,\n\t\t\t\t\t\t\t    endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_MEMORY:\n\t\t\t\t\tupgrade_stats_memory(act, p, ofal->size,\n\t\t\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_KTABLES:\n\t\t\t\t\tupgrade_stats_ktables(act, p, endian_mismatch);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_SERIAL:\n\t\t\t\t\tnr_struct = upgrade_stats_serial(act, p, ofal->size,\n\t\t\t\t\t\t\t\t\t endian_mismatch);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_DISK:\n\t\t\t\t\tupgrade_stats_disk(act, p, ofal->magic,\n\t\t\t\t\t\t\t   endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_DEV:\n\t\t\t\t\tupgrade_stats_net_dev(act, p, ofal->magic,\n\t\t\t\t\t\t\t      endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EDEV:\n\t\t\t\t\tupgrade_stats_net_edev(act, p, ofal->magic,\n\t\t\t\t\t\t\t       endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_IP:\n\t\t\t\t\tupgrade_stats_net_ip(act, p, ofal->magic,\n\t\t\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EIP:\n\t\t\t\t\tupgrade_stats_net_eip(act, p, ofal->magic,\n\t\t\t\t\t\t\t      endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_IP6:\n\t\t\t\t\tupgrade_stats_net_ip6(act, p, ofal->magic,\n\t\t\t\t\t\t\t      endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EIP6:\n\t\t\t\t\tupgrade_stats_net_eip6(act, p, ofal->magic,\n\t\t\t\t\t\t\t       endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_HUGE:\n\t\t\t\t\tupgrade_stats_huge(act, p, endian_mismatch, arch_64);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_FREQ:\n\t\t\t\t\tupgrade_stats_pwr_wghfreq(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_FS:\n\t\t\t\t\tupgrade_stats_filesystem(act, p, ofal->size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcc = '.';\n\t\t\t/* Known activity with current up-to-date format */\n\t\t\tfor (j = 0; j < act[p]->nr_ini; j++) {\n\t\t\t\tfor (k = 0; k < act[p]->nr2; k++) {\n\t\t\t\t\tmemcpy((char *) act[p]->buf[1] + (j * act[p]->nr2 + k) * act[p]->msize,\n\t\t\t\t\t       (char *) act[p]->buf[0] + (j * act[p]->nr2 + k) * act[p]->msize,\n\t\t\t\t\t       fal->size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fal->has_nr) {\n\n\t\t\tswitch (fal->id) {\n\n\t\t\t\tcase A_IRQ:\n\t\t\t\t\t/*\n\t\t\t\t\t * Nothing to do: Use current nr_struct value set to\n\t\t\t\t\t * act[p]->nr_ini above (value is \"1\" for A_IRQ: See\n\t\t\t\t\t * upgrade_header_section()).\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_SERIAL:\n\t\t\t\t\t/* Nothing to do: Already done in upgrade_stats_serial() */\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_DISK:\n\t\t\t\t\tnr_struct = count_stats_disk(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_DEV:\n\t\t\t\t\tnr_struct = count_stats_net_dev(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EDEV:\n\t\t\t\t\tnr_struct = count_stats_net_edev(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_USB:\n\t\t\t\t\tnr_struct = count_stats_pwr_usb(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_FS:\n\t\t\t\t\tnr_struct = count_stats_filesystem(act, p);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_FC:\n\t\t\t\t\tnr_struct = count_stats_fchost(act, p);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Restore endianness before writing */\n\t\t\tif (endian_mismatch) {\n\t\t\t\tnr = __builtin_bswap32(nr_struct);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnr = nr_struct;\n\t\t\t}\n\n\t\t\t/* Write number of structures for current activity */\n\t\t\tif (write_all(stdfd, &nr, sizeof(__nr_t)) != sizeof(__nr_t))\n\t\t\t\tgoto write_error;\n\n\t\t\tfprintf(stderr, \"n\");\n\t\t}\n\n\t\tfor (j = 0; j < nr_struct; j++) {\n\t\t\tfor (k = 0; k < act[p]->nr2; k++) {\n\t\t\t\tif (write_all(stdfd,\n\t\t\t\t\t      (char *) act[p]->buf[1] + (j * act[p]->nr2 + k) * act[p]->fsize,\n\t\t\t\t\t       act[p]->fsize) != act[p]->fsize)\n\t\t\t\t\tgoto write_error;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"%c\", cc);\n\t}\n\n\treturn 0;\n\nwrite_error:\n\n\tfprintf(stderr, \"\\nwrite: %s\\n\", strerror(errno));\n\n\treturn -1;\n\n}\n\n/*\n ***************************************************************************\n * Upgrade statistics records.\n *\n * IN:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n * @act\t\tArray of activities.\n * @file_hdr\tPointer on file_header structure.\n * @ofile_actlst\n *\t\tActivity list in file.\n * @file_actlst\tActivity list with up-to-date format.\n * @previous_format\n *\t\tTRUE is sa datafile has an old format which is no longer * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n\n *\t\tcompatible with current one.\n * @endian_mismatch\n *\t\tTRUE if data read from file don't match current\tmachine's\n *\t\tendianness.\n * @arch_64\tTRUE if file's data come from a 64-bit machine.\n * @vol_act_nr\tNumber of volatile activity structures.\n *\n * RETURNS:\n * -1 on error, 0 otherwise.\n***************************************************************************\n */\nint upgrade_stat_records(int fd, int stdfd, struct activity *act[], struct file_header *file_hdr,\n\t\t\t struct old_file_activity *ofile_actlst, struct file_activity *file_actlst,\n\t\t\t int previous_format, int endian_mismatch, int arch_64,\n\t\t\t unsigned int vol_act_nr)\n{\n\tint rtype;\n\tint eosaf;\n\tstruct old_record_header orec_hdr;\n\tunsigned int orec_types_nr[] = {OLD_RECORD_HEADER_ULL_NR, OLD_RECORD_HEADER_UL_NR, OLD_RECORD_HEADER_U_NR};\n\n\tfprintf(stderr, _(\"Statistics:\\n\"));\n\n\tdo {\n\t\teosaf = sa_fread(fd, &orec_hdr, OLD_RECORD_HEADER_SIZE, SOFT_SIZE, UEOF_STOP);\n\n\t\t/* Normalize endianness */\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(orec_types_nr, &orec_hdr, arch_64);\n\t\t}\n\t\trtype = orec_hdr.record_type;\n\n\t\tif (!eosaf) {\n\t\t\t/* Upgrade current record header */\n\t\t\tif (upgrade_record_header(fd, stdfd, &orec_hdr,\n\t\t\t\t\t\t  endian_mismatch, arch_64) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (rtype == R_COMMENT) {\n\t\t\t\t/* Upgrade the COMMENT record */\n\t\t\t\tif (upgrade_comment_record(fd, stdfd) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (rtype == R_RESTART) {\n\t\t\t\t/* Upgrade the RESTART record */\n\t\t\t\tif (upgrade_restart_record(fd, stdfd, act, file_hdr,\n\t\t\t\t\t\t\t   previous_format, endian_mismatch,\n\t\t\t\t\t\t\t   arch_64, vol_act_nr) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Upgrade current statistics record */\n\t\t\t\tif (upgrade_common_record(fd, stdfd, act, file_hdr, ofile_actlst,\n\t\t\t\t\t\t\t  file_actlst, endian_mismatch, arch_64) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (!eosaf);\n\n\tfprintf(stderr, \"\\n\");\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Close file descriptors and exit.\n *\n * IN:\n * @fd\t\tFile descriptor for sa datafile to convert.\n * @stdfd\tFile descriptor for STDOUT.\n * @exit_code\tExit code.\n ***************************************************************************\n */\nvoid upgrade_exit(int fd, int stdfd, int exit_code)\n{\n\tif (fd) {\n\t\tclose(fd);\n\t}\n\tif (stdfd) {\n\t\tclose(stdfd);\n\t}\n\tif (exit_code) {\n\t\texit(exit_code);\n\t}\n}\n\n/*\n ***************************************************************************\n * Convert a sysstat activity data file from a previous version to the\n * up-to-date format. Presently data files from sysstat version 9.1.6 and\n * later are converted to current sysstat version format.\n *\n * IN:\n * @dfile\tSystem activity data file name.\n * @act\t\tArray of activities.\n ***************************************************************************\n */\nvoid convert_file(char dfile[], struct activity *act[])\n{\n\tint fd = 0, stdfd = 0, previous_format = 0;\n\tint arch_64 = TRUE;\n\tunsigned int vol_act_nr = 0, hdr_size;\n\tstruct file_magic file_magic;\n\tstruct file_header file_hdr;\n\tstruct file_activity *file_actlst = NULL;\n\tstruct old_file_activity *ofile_actlst = NULL;\n\n\t/* Open stdout */\n\tif ((stdfd = dup(STDOUT_FILENO)) < 0) {\n\t\tperror(\"dup\");\n\t\tupgrade_exit(0, 0, 2);\n\t}\n\n\t/* Upgrade file's magic section */\n\tif (upgrade_magic_section(dfile, &fd, stdfd, &file_magic, &hdr_size,\n\t\t\t\t  &previous_format, &endian_mismatch) < 0) {\n\t\tupgrade_exit(fd, stdfd, 2);\n\t}\n\tif (previous_format == FORMAT_MAGIC) {\n\t\t/* Nothing to do at the present time */\n\t\tfprintf(stderr, _(\"\\nFile format already up-to-date\\n\"));\n\t\tgoto success;\n\t}\n\n\tif (!user_hz) {\n\t\t/* Get HZ */\n\t\tget_HZ();\n\t}\n\telse {\n\t\t/* HZ set on the command line with option -O */\n\t\thz = user_hz;\n\t}\n\tfprintf(stderr, _(\"HZ: Using current value: %lu\\n\"), HZ);\n\n\t/* Upgrade file's header section */\n\tif (upgrade_header_section(dfile, fd, stdfd, act, &file_magic,\n\t\t\t\t   &file_hdr, hdr_size, previous_format, &arch_64,\n\t\t\t\t   endian_mismatch, &vol_act_nr, &ofile_actlst) < 0) {\n\t\tupgrade_exit(fd, stdfd, 2);\n\t}\n\n\t/* Upgrade file's activity list section */\n\tif (upgrade_activity_section(stdfd, act, &file_hdr,\n\t\t\t\t     ofile_actlst, &file_actlst,\n\t\t\t\t     endian_mismatch, arch_64) < 0) {\n\t\tupgrade_exit(fd, stdfd, 2);\n\t}\n\n\t/* Perform required allocations */\n\tallocate_structures(act, 0);\n\n\t/* Upgrade statistics records */\n\tif (upgrade_stat_records(fd, stdfd, act, &file_hdr, ofile_actlst, file_actlst,\n\t\t\t\t previous_format, endian_mismatch, arch_64,\n\t\t\t\t vol_act_nr) < 0) {\n\t\tupgrade_exit(fd, stdfd, 2);\n\t}\n\n\tfree(file_actlst);\n\tfree(ofile_actlst);\n\tfree_structures(act);\n\n\tfprintf(stderr,\n\t\t_(\"File successfully converted to sysstat format version %s\\n\"),\n\t\tVERSION);\n\nsuccess:\n\tupgrade_exit(fd, stdfd, 0);\n}\n"
        },
        {
          "name": "sa_conv.h",
          "type": "blob",
          "size": 16.876953125,
          "content": "/*\n * sa_conv.h: Include file for \"sadf -c\" command.\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _SA_CONV_H\n#define _SA_CONV_H\n\n/*\n * Header structure for previous system activity data file formats.\n * 2171: v9.1.6 -> 10.2.1\n * 2173: 10.3.1 -> 11.6.x\n */\n#define UTSNAME_LEN_2171\t65\n\nstruct file_header_2171 {\n\tunsigned long sa_ust_time\t__attribute__ ((aligned (8)));\n\tunsigned int sa_act_nr\t\t__attribute__ ((aligned (8)));\n\tunsigned char sa_day;\n\tunsigned char sa_month;\n\tunsigned char sa_year;\n\tchar sa_sizeof_long;\n\tchar sa_sysname[UTSNAME_LEN_2171];\n\tchar sa_nodename[UTSNAME_LEN_2171];\n\tchar sa_release[UTSNAME_LEN_2171];\n\tchar sa_machine[UTSNAME_LEN_2171];\n};\n\n#define FILE_HEADER_SIZE_2171\t(sizeof(struct file_header_2171))\n#define FILE_HEADER_2171_ULL_NR\t0\n#define FILE_HEADER_2171_UL_NR\t1\n#define FILE_HEADER_2171_U_NR\t1\n\n#define UTSNAME_LEN_2173\t65\n\nstruct file_header_2173 {\n\tunsigned long sa_ust_time\t__attribute__ ((aligned (8)));\n\tunsigned int sa_last_cpu_nr\t__attribute__ ((aligned (8)));\n\tunsigned int sa_act_nr;\n\tunsigned int sa_vol_act_nr;\n\tunsigned char sa_day;\n\tunsigned char sa_month;\n\tunsigned char sa_year;\n\tchar sa_sizeof_long;\n\tchar sa_sysname[UTSNAME_LEN_2173];\n\tchar sa_nodename[UTSNAME_LEN_2173];\n\tchar sa_release[UTSNAME_LEN_2173];\n\tchar sa_machine[UTSNAME_LEN_2173];\n};\n\n#define FILE_HEADER_2173_ULL_NR\t0\n#define FILE_HEADER_2173_UL_NR\t1\n#define FILE_HEADER_2173_U_NR\t3\n\n/* file_activity structure for versions older than 11.7.1 */\nstruct old_file_activity {\n\tunsigned int id;\n\tunsigned int magic;\n\tint nr;\n\tint nr2;\n\tint size;\n};\n\n#define OLD_FILE_ACTIVITY_SIZE\t(sizeof(struct old_file_activity))\n#define OLD_FILE_ACTIVITY_ULL_NR\t0\n#define OLD_FILE_ACTIVITY_UL_NR\t\t0\n#define OLD_FILE_ACTIVITY_U_NR\t\t5\n\n/* File record header structure for versions older than 11.7.1 */\nstruct old_record_header {\n\tunsigned long long uptime\t__attribute__ ((aligned (16)));\n\tunsigned long long uptime0\t__attribute__ ((aligned (16)));\n\tunsigned long ust_time\t\t__attribute__ ((aligned (16)));\n\tunsigned char record_type\t__attribute__ ((aligned (8)));\n\tunsigned char hour;\n\tunsigned char minute;\n\tunsigned char second;\n};\n\n#define OLD_RECORD_HEADER_SIZE\t(sizeof(struct old_record_header))\n#define OLD_RECORD_HEADER_ULL_NR\t2\n#define OLD_RECORD_HEADER_UL_NR\t\t1\n#define OLD_RECORD_HEADER_U_NR\t\t0\n\n/* Structure stats_cpu for ACTIVITY_MAGIC_BASE format */\nstruct stats_cpu_8a {\n\tunsigned long long cpu_user\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_nice\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_sys\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_idle\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_iowait\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_steal\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_hardirq\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_softirq\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_guest\t\t__attribute__ ((aligned (16)));\n\tunsigned long long cpu_guest_nice\t__attribute__ ((aligned (16)));\n};\n\n#define STATS_CPU_8A_SIZE\t(sizeof(struct stats_cpu_8a))\n\n/* Structure stats_pcsw for ACTIVITY_MAGIC_BASE format */\nstruct stats_pcsw_8a {\n\tunsigned long long context_switch\t__attribute__ ((aligned (16)));\n\tunsigned long processes\t\t\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_irq for ACTIVITY_MAGIC_BASE format */\nstruct stats_irq_8a {\n\tunsigned long long irq_nr\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_irq for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_irq_8b {\n\tunsigned long long irq_nr;\n};\n\n/* Structure stats_io for ACTIVITY_MAGIC_BASE format */\nstruct stats_io_8a {\n\tunsigned int dk_drive\t\t__attribute__ ((aligned (4)));\n\tunsigned int dk_drive_rio\t__attribute__ ((packed));\n\tunsigned int dk_drive_wio\t__attribute__ ((packed));\n\tunsigned int dk_drive_rblk\t__attribute__ ((packed));\n\tunsigned int dk_drive_wblk\t__attribute__ ((packed));\n};\n\n/* Structure stats_memory for ACTIVITY_MAGIC_BASE format */\nstruct stats_memory_8a {\n\tunsigned long frmkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long bufkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long camkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long tlmkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long frskb\t\t__attribute__ ((aligned (8)));\n\tunsigned long tlskb\t\t__attribute__ ((aligned (8)));\n\tunsigned long caskb\t\t__attribute__ ((aligned (8)));\n\tunsigned long comkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long activekb\t\t__attribute__ ((aligned (8)));\n\tunsigned long inactkb\t\t__attribute__ ((aligned (8)));\n#define STATS_MEMORY_8A_1_SIZE\t80\n\tunsigned long dirtykb\t\t__attribute__ ((aligned (8)));\n#define STATS_MEMORY_8A_2_SIZE\t88\n\tunsigned long anonpgkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long slabkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long kstackkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long pgtblkb\t\t__attribute__ ((aligned (8)));\n\tunsigned long vmusedkb\t\t__attribute__ ((aligned (8)));\n#define STATS_MEMORY_8A_3_SIZE\t128\n\tunsigned long availablekb\t__attribute__ ((aligned (8)));\n};\n\n#define STATS_MEMORY_8A_SIZE\t(sizeof(struct stats_memory_8a))\n\n/* Structure stats_ktables for ACTIVITY_MAGIC_BASE */\nstruct stats_ktables_8a {\n\tunsigned int file_used\t\t__attribute__ ((aligned (4)));\n\tunsigned int inode_used\t\t__attribute__ ((packed));\n\tunsigned int dentry_stat\t__attribute__ ((packed));\n\tunsigned int pty_nr\t\t__attribute__ ((packed));\n};\n\n/* Structure stats_queue for ACTIVITY_MAGIC_BASE format */\nstruct stats_queue_8a {\n\tunsigned long nr_running\t__attribute__ ((aligned (8)));\n\tunsigned int  load_avg_1\t__attribute__ ((aligned (8)));\n\tunsigned int  load_avg_5\t__attribute__ ((packed));\n\tunsigned int  load_avg_15\t__attribute__ ((packed));\n\tunsigned int  nr_threads\t__attribute__ ((packed));\n};\n\n/* Structure stats_queue for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_queue_8b {\n\tunsigned long nr_running\t__attribute__ ((aligned (8)));\n\tunsigned long procs_blocked\t__attribute__ ((aligned (8)));\n\tunsigned int  load_avg_1\t__attribute__ ((aligned (8)));\n\tunsigned int  load_avg_5\t__attribute__ ((packed));\n\tunsigned int  load_avg_15\t__attribute__ ((packed));\n\tunsigned int  nr_threads\t__attribute__ ((packed));\n};\n\n/* Structure stats_disk for ACTIVITY_MAGIC_BASE format */\nstruct stats_disk_8a {\n\tunsigned long long rd_sect\t__attribute__ ((aligned (16)));\n\tunsigned long long wr_sect\t__attribute__ ((aligned (16)));\n\tunsigned long rd_ticks\t\t__attribute__ ((aligned (16)));\n\tunsigned long wr_ticks\t\t__attribute__ ((aligned (8)));\n\tunsigned long tot_ticks\t\t__attribute__ ((aligned (8)));\n\tunsigned long rq_ticks\t\t__attribute__ ((aligned (8)));\n\tunsigned long nr_ios\t\t__attribute__ ((aligned (8)));\n\tunsigned int  major\t\t__attribute__ ((aligned (8)));\n\tunsigned int  minor\t\t__attribute__ ((packed));\n};\n\n/* Structure stats_disk for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_disk_8b {\n\tunsigned long long nr_ios\t__attribute__ ((aligned (16)));\n\tunsigned long rd_sect\t\t__attribute__ ((aligned (16)));\n\tunsigned long wr_sect\t\t__attribute__ ((aligned (8)));\n\tunsigned int rd_ticks\t\t__attribute__ ((aligned (8)));\n\tunsigned int wr_ticks\t\t__attribute__ ((packed));\n\tunsigned int tot_ticks\t\t__attribute__ ((packed));\n\tunsigned int rq_ticks\t\t__attribute__ ((packed));\n\tunsigned int major\t\t__attribute__ ((packed));\n\tunsigned int minor\t\t__attribute__ ((packed));\n};\n\n/* Structure stats_net_dev for ACTIVITY_MAGIC_BASE format */\n#define MAX_IFACE_LEN_8A\t16\n\nstruct stats_net_dev_8a {\n\tunsigned long rx_packets\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_packets\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long rx_bytes\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_bytes\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long rx_compressed\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_compressed\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long multicast\t\t\t\t__attribute__ ((aligned (8)));\n\tchar\t      interface[MAX_IFACE_LEN_8A]\t__attribute__ ((aligned (8)));\n};\n\n/* Structure stats_net_dev for ACTIVITY_MAGIC_BASE + 1 format */\n#define MAX_IFACE_LEN_8B\t16\n\nstruct stats_net_dev_8b {\n\tunsigned long long rx_packets\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_packets\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_bytes\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_bytes\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_compressed\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_compressed\t\t__attribute__ ((aligned (16)));\n\tunsigned long long multicast\t\t\t__attribute__ ((aligned (16)));\n\tchar\t\t   interface[MAX_IFACE_LEN_8B]\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_net_dev for ACTIVITY_MAGIC_BASE + 2 format */\n#define MAX_IFACE_LEN_8C\t16\n\nstruct stats_net_dev_8c {\n\tunsigned long long rx_packets\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_packets\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_bytes\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_bytes\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_compressed\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_compressed\t\t__attribute__ ((aligned (16)));\n\tunsigned long long multicast\t\t\t__attribute__ ((aligned (16)));\n\tunsigned int\t   speed\t\t\t__attribute__ ((aligned (16)));\n\tchar\t\t   interface[MAX_IFACE_LEN_8C]\t__attribute__ ((aligned (4)));\n\tchar\t\t   duplex;\n};\n\n/* Structure stats_net_edev for ACTIVITY_MAGIC_BASE format */\n#define MAX_IFACE_LEN_8A\t16\n\nstruct stats_net_edev_8a {\n\tunsigned long collisions\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long rx_errors\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_errors\t\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long rx_dropped\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_dropped\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long rx_fifo_errors\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_fifo_errors\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long rx_frame_errors\t\t\t__attribute__ ((aligned (8)));\n\tunsigned long tx_carrier_errors\t\t\t__attribute__ ((aligned (8)));\n\tchar\t      interface[MAX_IFACE_LEN_8A]\t__attribute__ ((aligned (8)));\n};\n\n/* Structure stats_net_edev for ACTIVITY_MAGIC_BASE + 1 format */\n#define MAX_IFACE_LEN_8B\t16\n\nstruct stats_net_edev_8b {\n\tunsigned long long collisions\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_errors\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_errors\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_dropped\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_dropped\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_fifo_errors\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_fifo_errors\t\t__attribute__ ((aligned (16)));\n\tunsigned long long rx_frame_errors\t\t__attribute__ ((aligned (16)));\n\tunsigned long long tx_carrier_errors\t\t__attribute__ ((aligned (16)));\n\tchar\t\t   interface[MAX_IFACE_LEN_8B]\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_net_ip for ACTIVITY_MAGIC_BASE format */\nstruct stats_net_ip_8a {\n\tunsigned long InReceives\t__attribute__ ((aligned (8)));\n\tunsigned long ForwDatagrams\t__attribute__ ((aligned (8)));\n\tunsigned long InDelivers\t__attribute__ ((aligned (8)));\n\tunsigned long OutRequests\t__attribute__ ((aligned (8)));\n\tunsigned long ReasmReqds\t__attribute__ ((aligned (8)));\n\tunsigned long ReasmOKs\t\t__attribute__ ((aligned (8)));\n\tunsigned long FragOKs\t\t__attribute__ ((aligned (8)));\n\tunsigned long FragCreates\t__attribute__ ((aligned (8)));\n};\n\n/* Structure stats_net_ip for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_net_ip_8b {\n\tunsigned long long InReceives\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ForwDatagrams\t__attribute__ ((aligned (16)));\n\tunsigned long long InDelivers\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutRequests\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ReasmReqds\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ReasmOKs\t\t__attribute__ ((aligned (16)));\n\tunsigned long long FragOKs\t\t__attribute__ ((aligned (16)));\n\tunsigned long long FragCreates\t\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_net_eip for ACTIVITY_MAGIC_BASE format */\nstruct stats_net_eip_8a {\n\tunsigned long InHdrErrors\t__attribute__ ((aligned (8)));\n\tunsigned long InAddrErrors\t__attribute__ ((aligned (8)));\n\tunsigned long InUnknownProtos\t__attribute__ ((aligned (8)));\n\tunsigned long InDiscards\t__attribute__ ((aligned (8)));\n\tunsigned long OutDiscards\t__attribute__ ((aligned (8)));\n\tunsigned long OutNoRoutes\t__attribute__ ((aligned (8)));\n\tunsigned long ReasmFails\t__attribute__ ((aligned (8)));\n\tunsigned long FragFails\t\t__attribute__ ((aligned (8)));\n};\n\n/* Structure stats_net_eip for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_net_eip_8b {\n\tunsigned long long InHdrErrors\t\t__attribute__ ((aligned (16)));\n\tunsigned long long InAddrErrors\t\t__attribute__ ((aligned (16)));\n\tunsigned long long InUnknownProtos\t__attribute__ ((aligned (16)));\n\tunsigned long long InDiscards\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutDiscards\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutNoRoutes\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ReasmFails\t\t__attribute__ ((aligned (16)));\n\tunsigned long long FragFails\t\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_net_ip6 for ACTIVITY_MAGIC_BASE format */\nstruct stats_net_ip6_8a {\n\tunsigned long InReceives6\t__attribute__ ((aligned (8)));\n\tunsigned long OutForwDatagrams6\t__attribute__ ((aligned (8)));\n\tunsigned long InDelivers6\t__attribute__ ((aligned (8)));\n\tunsigned long OutRequests6\t__attribute__ ((aligned (8)));\n\tunsigned long ReasmReqds6\t__attribute__ ((aligned (8)));\n\tunsigned long ReasmOKs6\t\t__attribute__ ((aligned (8)));\n\tunsigned long InMcastPkts6\t__attribute__ ((aligned (8)));\n\tunsigned long OutMcastPkts6\t__attribute__ ((aligned (8)));\n\tunsigned long FragOKs6\t\t__attribute__ ((aligned (8)));\n\tunsigned long FragCreates6\t__attribute__ ((aligned (8)));\n};\n\n/* Structure stats_net_ip6 for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_net_ip6_8b {\n\tunsigned long long InReceives6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutForwDatagrams6\t__attribute__ ((aligned (16)));\n\tunsigned long long InDelivers6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutRequests6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ReasmReqds6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ReasmOKs6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long InMcastPkts6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutMcastPkts6\t__attribute__ ((aligned (16)));\n\tunsigned long long FragOKs6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long FragCreates6\t\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_net_eip6 for ACTIVITY_MAGIC_BASE format */\nstruct stats_net_eip6_8a {\n        unsigned long InHdrErrors6      __attribute__ ((aligned (8)));\n        unsigned long InAddrErrors6     __attribute__ ((aligned (8)));\n        unsigned long InUnknownProtos6  __attribute__ ((aligned (8)));\n        unsigned long InTooBigErrors6   __attribute__ ((aligned (8)));\n        unsigned long InDiscards6       __attribute__ ((aligned (8)));\n        unsigned long OutDiscards6      __attribute__ ((aligned (8)));\n        unsigned long InNoRoutes6       __attribute__ ((aligned (8)));\n        unsigned long OutNoRoutes6      __attribute__ ((aligned (8)));\n        unsigned long ReasmFails6       __attribute__ ((aligned (8)));\n        unsigned long FragFails6        __attribute__ ((aligned (8)));\n        unsigned long InTruncatedPkts6  __attribute__ ((aligned (8)));\n};\n\n/* Structure stats_net_eip6 for ACTIVITY_MAGIC_BASE + 1 format */\nstruct stats_net_eip6_8b {\n\tunsigned long long InHdrErrors6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long InAddrErrors6\t__attribute__ ((aligned (16)));\n\tunsigned long long InUnknownProtos6\t__attribute__ ((aligned (16)));\n\tunsigned long long InTooBigErrors6\t__attribute__ ((aligned (16)));\n\tunsigned long long InDiscards6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutDiscards6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long InNoRoutes6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long OutNoRoutes6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long ReasmFails6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long FragFails6\t\t__attribute__ ((aligned (16)));\n\tunsigned long long InTruncatedPkts6\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_huge for ACTIVITY_MAGIC_BASE */\nstruct stats_huge_8a {\n\tunsigned long frhkb\t__attribute__ ((aligned (8)));\n\tunsigned long tlhkb\t__attribute__ ((aligned (8)));\n};\n\n/* Structure stats_pwr_wghfreq for ACTIVITY_MAGIC_BASE */\nstruct stats_pwr_wghfreq_8a {\n\tunsigned long long time_in_state\t__attribute__ ((aligned (16)));\n\tunsigned long      freq\t\t\t__attribute__ ((aligned (16)));\n};\n\n/* Structure stats_filesystem for ACTIVITY_MAGIC_BASE */\n#define MAX_FS_LEN_8A\t128\n\nstruct stats_filesystem_8a {\n\tunsigned long long f_blocks\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long f_bfree\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long f_bavail\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long f_files\t\t\t__attribute__ ((aligned (16)));\n\tunsigned long long f_ffree\t\t\t__attribute__ ((aligned (16)));\n\tchar \t\t   fs_name[MAX_FS_LEN_8A]\t__attribute__ ((aligned (16)));\n#define STATS_FILESYSTEM_8A_1_SIZE\t160\n\tchar \t\t   mountp[MAX_FS_LEN_8A];\n};\n\n#endif  /* _SA_CONV_H */\n"
        },
        {
          "name": "sa_wrap.c",
          "type": "blob",
          "size": 35.466796875,
          "content": "/*\n * sysstat - sa_wrap.c: Functions used in activity.c\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <dirent.h>\n#include <string.h>\n\n#include \"sa.h\"\n#include \"count.h\"\n\nextern unsigned int flags;\nextern struct record_header record_hdr;\n\n/*\n ***************************************************************************\n * Reallocate buffer where statistics will be saved. The new size is the\n * double of the original one.\n * This is typically called when we find that current buffer is too small\n * to save all the data.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * New pointer address on buffer.\n ***************************************************************************\n */\nvoid *reallocate_buffer(struct activity *a)\n{\n\tSREALLOC(a->_buf0, void,\n\t\t (size_t) a->msize * (size_t) a->nr_allocated * 2);\t/* a->nr2 value is 1 */\n\tmemset(a->_buf0, 0, (size_t) a->msize * (size_t) a->nr_allocated * 2);\n\n\ta->nr_allocated *= 2;\t/* NB: nr_allocated > 0 */\n\n\treturn a->_buf0;\n}\n\n/*\n ***************************************************************************\n * Read CPU statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_stat_cpu(struct activity *a)\n{\n\tstruct stats_cpu *st_cpu\n\t\t= (struct stats_cpu *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read CPU statistics */\n\tdo {\n\t\tnr_read = read_stat_cpu(st_cpu, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_cpu = (struct stats_cpu *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read process (task) creation and context switch statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_stat_pcsw(struct activity *a)\n{\n\tstruct stats_pcsw *st_pcsw\n\t\t= (struct stats_pcsw *) a->_buf0;\n\n\t/* Read process and context switch stats */\n\tread_stat_pcsw(st_pcsw);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read interrupt statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_stat_irq(struct activity *a)\n{\n\tstruct stats_irq *st_irq\n\t\t= (struct stats_irq *) a->_buf0;\n\t__nr_t nr_read;\n\n\t/* Read interrupts stats */\n\tdo {\n\t\tnr_read = read_stat_irq(st_irq, a->nr_allocated, a->nr2);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated (for CPU, not interrupts) */\n\t\t\tst_irq = (struct stats_irq *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read queue and load statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_loadavg(struct activity *a)\n{\n\tstruct stats_queue *st_queue\n\t\t= (struct stats_queue *) a->_buf0;\n\n\t/* Read queue and load stats */\n\tread_loadavg(st_queue);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read memory statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_meminfo(struct activity *a)\n{\n\tstruct stats_memory *st_memory\n\t\t= (struct stats_memory *) a->_buf0;\n\n\t/* Read memory stats */\n\tread_meminfo(st_memory);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read swapping statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_swap(struct activity *a)\n{\n\tstruct stats_swap *st_swap\n\t\t= (struct stats_swap *) a->_buf0;\n\n\t/* Read stats from /proc/vmstat */\n\tread_vmstat_swap(st_swap);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read paging statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_paging(struct activity *a)\n{\n\tstruct stats_paging *st_paging\n\t\t= (struct stats_paging *) a->_buf0;\n\n\t/* Read stats from /proc/vmstat */\n\tread_vmstat_paging(st_paging);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read I/O and transfer rates statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_io(struct activity *a)\n{\n\tstruct stats_io *st_io\n\t\t= (struct stats_io *) a->_buf0;\n\n\t/* Read stats from /proc/diskstats */\n\tread_diskstats_io(st_io);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read block devices statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_disk(struct activity *a)\n{\n\tstruct stats_disk *st_disk\n\t\t= (struct stats_disk *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read stats from /proc/diskstats */\n\tdo {\n\t\tnr_read = read_diskstats_disk(st_disk, a->nr_allocated,\n\t\t\t\t\t      COLLECT_PARTITIONS(a->opt_flags));\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_disk = (struct stats_disk *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read serial lines statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_tty_driver_serial(struct activity *a)\n{\n\tstruct stats_serial *st_serial\n\t\t= (struct stats_serial *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read serial lines stats */\n\tdo {\n\t\tnr_read = read_tty_driver_serial(st_serial, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_serial = (struct stats_serial *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read kernel tables statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_kernel_tables(struct activity *a)\n{\n\tstruct stats_ktables *st_ktables\n\t\t= (struct stats_ktables *) a->_buf0;\n\n\t/* Read kernel tables stats */\n\tread_kernel_tables(st_ktables);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read network interfaces statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_dev(struct activity *a)\n{\n\tstruct stats_net_dev *st_net_dev\n\t\t= (struct stats_net_dev *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read network interfaces stats */\n\tdo {\n\t\tnr_read = read_net_dev(st_net_dev, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_net_dev = (struct stats_net_dev *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\tif (!nr_read)\n\t\t/* No data read. Exit */\n\t\treturn;\n\n\t/* Read duplex and speed info for each interface */\n\tread_if_info(st_net_dev, nr_read);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read network interfaces errors statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_edev(struct activity *a)\n{\n\tstruct stats_net_edev *st_net_edev\n\t\t= (struct stats_net_edev *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read network interfaces errors stats */\n\tdo {\n\t\tnr_read = read_net_edev(st_net_edev, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_net_edev = (struct stats_net_edev *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read NFS client statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_nfs(struct activity *a)\n{\n\tstruct stats_net_nfs *st_net_nfs\n\t\t= (struct stats_net_nfs *) a->_buf0;\n\n\t/* Read NFS client stats */\n\tread_net_nfs(st_net_nfs);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read NFS server statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_nfsd(struct activity *a)\n{\n\tstruct stats_net_nfsd *st_net_nfsd\n\t\t= (struct stats_net_nfsd *) a->_buf0;\n\n\t/* Read NFS server stats */\n\tread_net_nfsd(st_net_nfsd);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read network sockets statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_sock(struct activity *a)\n{\n\tstruct stats_net_sock *st_net_sock\n\t\t= (struct stats_net_sock *) a->_buf0;\n\n\t/* Read network sockets stats */\n\tread_net_sock(st_net_sock);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read IP statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_ip(struct activity *a)\n{\n\tstruct stats_net_ip *st_net_ip\n\t\t= (struct stats_net_ip *) a->_buf0;\n\n\t/* Read IP stats */\n\tread_net_ip(st_net_ip);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read IP error statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_eip(struct activity *a)\n{\n\tstruct stats_net_eip *st_net_eip\n\t\t= (struct stats_net_eip *) a->_buf0;\n\n\t/* Read IP error stats */\n\tread_net_eip(st_net_eip);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read ICMP statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_icmp(struct activity *a)\n{\n\tstruct stats_net_icmp *st_net_icmp\n\t\t= (struct stats_net_icmp *) a->_buf0;\n\n\t/* Read ICMP stats */\n\tread_net_icmp(st_net_icmp);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read ICMP error statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_eicmp(struct activity *a)\n{\n\tstruct stats_net_eicmp *st_net_eicmp\n\t\t= (struct stats_net_eicmp *) a->_buf0;\n\n\t/* Read ICMP error stats */\n\tread_net_eicmp(st_net_eicmp);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read TCP statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_tcp(struct activity *a)\n{\n\tstruct stats_net_tcp *st_net_tcp\n\t\t= (struct stats_net_tcp *) a->_buf0;\n\n\t/* Read TCP stats */\n\tread_net_tcp(st_net_tcp);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read TCP error statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_etcp(struct activity *a)\n{\n\tstruct stats_net_etcp *st_net_etcp\n\t\t= (struct stats_net_etcp *) a->_buf0;\n\n\t/* Read TCP error stats */\n\tread_net_etcp(st_net_etcp);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read UDP statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_udp(struct activity *a)\n{\n\tstruct stats_net_udp *st_net_udp\n\t\t= (struct stats_net_udp *) a->_buf0;\n\n\t/* Read UDP stats */\n\tread_net_udp(st_net_udp);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read IPv6 network sockets statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_sock6(struct activity *a)\n{\n\tstruct stats_net_sock6 *st_net_sock6\n\t\t= (struct stats_net_sock6 *) a->_buf0;\n\n\t/* Read IPv6 network sockets stats */\n\tread_net_sock6(st_net_sock6);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read IPv6 statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_ip6(struct activity *a)\n{\n\tstruct stats_net_ip6 *st_net_ip6\n\t\t= (struct stats_net_ip6 *) a->_buf0;\n\n\t/* Read IPv6 stats */\n\tread_net_ip6(st_net_ip6);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read IPv6 error statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_eip6(struct activity *a)\n{\n\tstruct stats_net_eip6 *st_net_eip6\n\t\t= (struct stats_net_eip6 *) a->_buf0;\n\n\t/* Read IPv6 error stats */\n\tread_net_eip6(st_net_eip6);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read ICMPv6 statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_icmp6(struct activity *a)\n{\n\tstruct stats_net_icmp6 *st_net_icmp6\n\t\t= (struct stats_net_icmp6 *) a->_buf0;\n\n\t/* Read ICMPv6 stats */\n\tread_net_icmp6(st_net_icmp6);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read ICMPv6 error statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_eicmp6(struct activity *a)\n{\n\tstruct stats_net_eicmp6 *st_net_eicmp6\n\t\t= (struct stats_net_eicmp6 *) a->_buf0;\n\n\t/* Read ICMPv6 error stats */\n\tread_net_eicmp6(st_net_eicmp6);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read UDPv6 statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_net_udp6(struct activity *a)\n{\n\tstruct stats_net_udp6 *st_net_udp6\n\t\t= (struct stats_net_udp6 *) a->_buf0;\n\n\t/* Read UDPv6 stats */\n\tread_net_udp6(st_net_udp6);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read CPU frequency statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_cpuinfo(struct activity *a)\n{\n\tstruct stats_pwr_cpufreq *st_pwr_cpufreq\n\t\t= (struct stats_pwr_cpufreq *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read CPU frequency stats */\n\tdo {\n\t\tnr_read = read_cpuinfo(st_pwr_cpufreq, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_pwr_cpufreq = (struct stats_pwr_cpufreq *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read fan statistics.\n *\n * IN:\n * @a  Activity structure.\n *\n * OUT:\n * @a  Activity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_fan(struct activity *a)\n{\n\tstruct stats_pwr_fan *st_pwr_fan\n\t\t= (struct stats_pwr_fan *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read fan stats */\n\tdo {\n\t\tnr_read = read_fan(st_pwr_fan, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_pwr_fan = (struct stats_pwr_fan *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read temperature statistics.\n *\n * IN:\n * @a  Activity structure.\n *\n * OUT:\n * @a  Activity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_temp(struct activity *a)\n{\n\tstruct stats_pwr_temp *st_pwr_temp\n\t\t= (struct stats_pwr_temp *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read temperature stats */\n\tdo {\n\t\tnr_read = read_temp(st_pwr_temp, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_pwr_temp = (struct stats_pwr_temp *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read voltage input statistics.\n *\n * IN:\n * @a  Activity structure.\n *\n * OUT:\n * @a  Activity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_in(struct activity *a)\n{\n\tstruct stats_pwr_in *st_pwr_in\n\t\t= (struct stats_pwr_in *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read voltage input stats */\n\tdo {\n\t\tnr_read = read_in(st_pwr_in, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_pwr_in = (struct stats_pwr_in *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read hugepages statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_meminfo_huge(struct activity *a)\n{\n\tstruct stats_huge *st_huge\n\t\t= (struct stats_huge *) a->_buf0;\n\n\t/* Read hugepages stats */\n\tread_meminfo_huge(st_huge);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read weighted CPU frequency statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_cpu_wghfreq(struct activity *a)\n{\n\tstruct stats_pwr_wghfreq *st_pwr_wghfreq\n\t\t= (struct stats_pwr_wghfreq *) a->_buf0;\n\t__nr_t\tnr_read = 0;\n\n\t/* Read weighted CPU frequency statistics */\n\tdo {\n\t\tnr_read = read_cpu_wghfreq(st_pwr_wghfreq, a->nr_allocated, a->nr2);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tSREALLOC(a->_buf0, void,\n\t\t\t\t (size_t) a->msize * (size_t) a->nr2 * (size_t) a->nr_allocated * 2);\n\t\t\tmemset(a->_buf0, 0,\n\t\t\t       (size_t) a->msize * (size_t) a->nr2 * (size_t) a->nr_allocated * 2);\n\n\t\t\t/* NB: nr_allocated > 0 */\n\t\t\ta->nr_allocated *= 2;\n\t\t\tst_pwr_wghfreq = (struct stats_pwr_wghfreq *) a->_buf0;\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read USB devices statistics.\n *\n * IN:\n * @a  Activity structure.\n *\n * OUT:\n * @a  Activity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_bus_usb_dev(struct activity *a)\n{\n\tstruct stats_pwr_usb *st_pwr_usb\n\t\t= (struct stats_pwr_usb *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read USB devices stats */\n\tdo {\n\t\tnr_read = read_bus_usb_dev(st_pwr_usb, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_pwr_usb = (struct stats_pwr_usb *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read filesystem statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_filesystem(struct activity *a)\n{\n\tstruct stats_filesystem *st_filesystem\n\t\t= (struct stats_filesystem *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read filesystems from /etc/mtab */\n\tdo {\n\t\tnr_read = read_filesystem(st_filesystem, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_filesystem = (struct stats_filesystem *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read Fibre Channel HBA statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_fchost(struct activity *a)\n{\n\tstruct stats_fchost *st_fc\n\t\t= (struct stats_fchost *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read FC hosts statistics */\n\tdo {\n\t\tnr_read = read_fchost(st_fc, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_fc = (struct stats_fchost *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n * **************************************************************************\n * Read batteries statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_bat(struct activity *a)\n{\n\tstruct stats_pwr_bat *st_bat\n\t= (struct stats_pwr_bat *) a->_buf0;\n\t__nr_t nr_read = 0;\n\n\t/* Read batteries statistics */\n\tdo {\n\t\tnr_read = read_bat(st_bat, a->nr_allocated);\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_bat = (struct stats_pwr_bat *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Look for online CPU and fill corresponding bitmap.\n *\n * IN:\n * @bitmap_size\tSize of the CPU bitmap.\n *\n * OUT:\n * @online_cpu_bitmap\n *\t\tCPU bitmap which has been filled.\n *\n * RETURNS:\n * Number of CPU for which statistics have to be read.\n * 1 means CPU \"all\", 2 means CPU \"all\" and CPU 0, etc.\n * Or -1 if the buffer was too small and needs to be reallocated.\n ***************************************************************************\n */\nint get_online_cpu_list(unsigned char online_cpu_bitmap[], int bitmap_size)\n{\n\tFILE *fp;\n\tchar line[8192];\n\tint proc_nr = -2;\n\n\tif ((fp = fopen(STAT, \"r\")) == NULL)\n\t\treturn 0;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\tif (!strncmp(line, \"cpu \", 4))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(line, \"cpu\", 3)) {\n\t\t\tsscanf(line + 3, \"%d\", &proc_nr);\n\n\t\t\tif ((proc_nr + 1 > bitmap_size) || (proc_nr < 0)) {\n\t\t\t\tfclose(fp);\n\t\t\t\t/* Return -1 or 0 */\n\t\t\t\treturn ((proc_nr >= 0) * -1);\n\t\t\t}\n\t\t\tSET_CPU_BITMAP(online_cpu_bitmap, proc_nr);\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn proc_nr + 2;\n}\n\n/*\n ***************************************************************************\n * Read softnet statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_softnet(struct activity *a)\n{\n\tstruct stats_softnet *st_softnet\n\t\t= (struct stats_softnet *) a->_buf0;\n\t__nr_t nr_read = 0;\n\tstatic unsigned char *online_cpu_bitmap = NULL;\n\tstatic int bitmap_size = 0;\n\n\t/* Read softnet stats */\n\tdo {\n\t\t/* Allocate bitmap for online CPU */\n\t\tif (bitmap_size < a->nr_allocated) {\n\t\t\tunsigned char *p = (unsigned char *) realloc(online_cpu_bitmap,\n\t\t\t\t\t\t\t\t     BITMAP_SIZE(a->nr_allocated));\n\t\t\tif (p == NULL) {\n\t\t\t\tnr_read = 0;\n\t\t\t\tif (online_cpu_bitmap) {\n\t\t\t\t\tfree(online_cpu_bitmap);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tonline_cpu_bitmap = p;\n\t\t\tbitmap_size = a->nr_allocated;\n\t\t}\n\t\tmemset(online_cpu_bitmap, 0, BITMAP_SIZE(a->nr_allocated));\n\n\t\t/* Get online CPU list */\n\t\tnr_read = get_online_cpu_list(online_cpu_bitmap, bitmap_size);\n\n\t\tif (nr_read > 0) {\n\t\t\t/* Read /proc/net/softnet stats */\n\t\t\tnr_read *= read_softnet(st_softnet, a->nr_allocated, online_cpu_bitmap);\n\t\t}\n\n\t\tif (nr_read < 0) {\n\t\t\t/* Buffer needs to be reallocated */\n\t\t\tst_softnet = (struct stats_softnet *) reallocate_buffer(a);\n\t\t}\n\t}\n\twhile (nr_read < 0);\n\n\ta->_nr0 = nr_read;\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall CPU statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_psicpu(struct activity *a)\n{\n\tstruct stats_psi_cpu *st_psicpu\n\t\t= (struct stats_psi_cpu *) a->_buf0;\n\n\t/* Read pressure-stall CPU stats */\n\tread_psicpu(st_psicpu);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall I/O statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_psiio(struct activity *a)\n{\n\tstruct stats_psi_io *st_psiio\n\t\t= (struct stats_psi_io *) a->_buf0;\n\n\t/* Read pressure-stall I/O stats */\n\tread_psiio(st_psiio);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read pressure-stall memory statistics.\n *\n * IN:\n * @a\tActivity structure.\n *\n * OUT:\n * @a\tActivity structure with statistics.\n ***************************************************************************\n */\n__read_funct_t wrap_read_psimem(struct activity *a)\n{\n\tstruct stats_psi_mem *st_psimem\n\t\t= (struct stats_psi_mem *) a->_buf0;\n\n\t/* Read pressure-stall memory stats */\n\tread_psimem(st_psimem);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Count number of interrupts that are in /proc/interrupts file, including\n * total number of interrupts.\n * Truncate the number of different individual interrupts to NR_IRQS.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of interrupts, including total number of interrupts.\n * Value in [0, NR_IRQS + 1].\n ***************************************************************************\n */\n__nr_t wrap_get_irq_nr(struct activity *a)\n{\n\t__nr_t n;\n\n\t/*\n\t * Get number of different interrupts.\n\t * Number of CPU (including CPU \"all\") has already been calculated and saved in a->nr_ini.\n\t */\n\tn = get_irqcpu_nr(INTERRUPTS, a->bitmap->b_size, a->nr_ini - 1);\n\tif (n > 0) {\n\t\tn++;\t/* Add 1 for total number of interrupts. A value of bitmap->b_size + 1 is OK. */\n\t}\n\n\treturn n;\n}\n\n/*\n ***************************************************************************\n * Find number of serial lines that support tx/rx accounting\n * in /proc/tty/driver/serial file.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of serial lines supporting tx/rx accouting.\n * Number cannot exceed MAX_NR_SERIAL_LINES.\n ***************************************************************************\n */\n__nr_t wrap_get_serial_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_serial_nr()) > 0) {\n\t\tif (n > MAX_NR_SERIAL_LINES)\n\t\t\treturn MAX_NR_SERIAL_LINES;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Find number of interfaces (network devices) that are in /proc/net/dev\n * file.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of network interfaces. Number cannot exceed MAX_NR_IFACES.\n ***************************************************************************\n */\n__nr_t wrap_get_iface_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_iface_nr()) > 0) {\n\t\tif (n > MAX_NR_IFACES)\n\t\t\treturn MAX_NR_IFACES;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Compute number of CPU structures to allocate.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of structures (value in [1, NR_CPUS + 1]).\n * 1 means that there is only one proc and non SMP kernel (CPU \"all\").\n * 2 means one proc and SMP kernel (CPU \"all\" and CPU 0).\n * Etc.\n ***************************************************************************\n */\n__nr_t wrap_get_cpu_nr(struct activity *a)\n{\n\treturn (get_cpu_nr(a->bitmap->b_size, FALSE) + 1);\n}\n\n/*\n ***************************************************************************\n * Get number of devices in /proc/diskstats.\n * Always done, since disk stats must be read at least for sar -b\n * if not for sar -d.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of devices. Number cannot exceed MAX_NR_DISKS.\n ***************************************************************************\n */\n__nr_t wrap_get_disk_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\tunsigned int f = COLLECT_PARTITIONS(a->opt_flags);\n\n\tif ((n = get_disk_nr(f)) > 0) {\n\t\tif (n > MAX_NR_DISKS)\n\t\t\treturn MAX_NR_DISKS;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Get number of fan sensors.\n *\n * IN:\n * @a  Activity structure.\n *\n * RETURNS:\n * Number of fan sensors. Number cannot exceed MAX_NR_FANS.\n ***************************************************************************\n */\n__nr_t wrap_get_fan_nr(struct activity *a)\n{\n\t__nr_t n;\n\n\tif ((n = get_fan_nr()) > MAX_NR_FANS)\n\t\treturn MAX_NR_FANS;\n\telse\n\t\treturn n;\n}\n\n/*\n ***************************************************************************\n * Get number of temp sensors.\n *\n * IN:\n * @a  Activity structure.\n *\n * RETURNS:\n * Number of temp sensors. Number cannot exceed MAX_NR_TEMP_SENSORS.\n ***************************************************************************\n */\n__nr_t wrap_get_temp_nr(struct activity *a)\n{\n\t__nr_t n;\n\n\tif ((n = get_temp_nr()) > MAX_NR_TEMP_SENSORS)\n\t\treturn MAX_NR_TEMP_SENSORS;\n\telse\n\t\treturn n;\n}\n\n/*\n ***************************************************************************\n * Get number of voltage input sensors.\n *\n * IN:\n * @a  Activity structure.\n *\n * RETURNS:\n * Number of voltage input sensors. Number cannot exceed MAX_NR_IN_SENSORS.\n ***************************************************************************\n */\n__nr_t wrap_get_in_nr(struct activity *a)\n{\n\t__nr_t n;\n\n\tif ((n = get_in_nr()) > MAX_NR_IN_SENSORS)\n\t\treturn MAX_NR_IN_SENSORS;\n\telse\n\t\treturn n;\n}\n\n/*\n ***************************************************************************\n * Count number of possible frequencies for CPU#0.\n *\n * IN:\n * @a   Activity structure.\n *\n * RETURNS:\n * Number of CPU frequencies.\n ***************************************************************************\n */\n__nr_t wrap_get_freq_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_freq_nr()) > 0)\n\t\treturn n;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Count number of USB devices plugged into the system.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of USB devices. Number cannot exceed MAX_NR_USB.\n ***************************************************************************\n */\n__nr_t wrap_get_usb_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_usb_nr()) > 0) {\n\t\tif (n > MAX_NR_USB)\n\t\t\treturn MAX_NR_USB;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Get number of mounted filesystems from /etc/mtab. Don't take into account\n * pseudo-filesystems.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of filesystems. Number cannot exceed MAX_NR_FS.\n ***************************************************************************\n */\n__nr_t wrap_get_filesystem_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_filesystem_nr()) > 0) {\n\t\tif (n > MAX_NR_FS)\n\t\t\treturn MAX_NR_FS;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Get number of FC hosts.\n *\n * IN:\n * @a\tActivity structure.\n *\n * RETURNS:\n * Number of FC hosts. Number cannot exceed MAX_NR_FCHOSTS.\n ***************************************************************************\n */\n__nr_t wrap_get_fchost_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_fchost_nr()) > 0) {\n\t\tif (n > MAX_NR_FCHOSTS)\n\t\t\treturn MAX_NR_FCHOSTS;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Check that /proc/pressure directory exists.\n *\n * IN:\n * @a  Activity structure.\n *\n * RETURNS:\n * TRUE if directory exists.\n ***************************************************************************\n */\n__nr_t wrap_detect_psi(struct activity *a)\n{\n\treturn (check_dir(PRESSURE));\n}\n\n/*\n * **************************************************************************\n * Get number of batteries.\n *\n * IN:\n * @a  Activity structure.\n *\n * RETURNS:\n * Number of batteries installed. Number cannot exceed MAX_NR_BAT.\n ***************************************************************************\n */\n__nr_t wrap_get_bat_nr(struct activity *a)\n{\n\t__nr_t n = 0;\n\n\tif ((n = get_bat_nr()) > 0) {\n\t\tif (n > MAX_NR_BATS)\n\t\t\treturn MAX_NR_BATS;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "sadc.c",
          "type": "blob",
          "size": 38.8544921875,
          "content": "/*\n * sadc: system activity data collector\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <dirent.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n\n#include \"version.h\"\n#include \"sa.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n#include \"sensors/sensors.h\"\n#include \"sensors/error.h\"\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern time_t __unix_time;\nextern int __env;\n#endif\n\nextern char *tzname[2];\n\nlong interval = -1;\nuint64_t flags = 0;\n\nint optz = 0;\nchar timestamp[2][TIMESTAMP_LEN];\n\nstruct file_header file_hdr;\nstruct record_header record_hdr;\n\nchar comment[MAX_COMMENT_LEN];\n\nunsigned int id_seq[NR_ACT];\n\nextern unsigned int hdr_types_nr[];\nextern unsigned int act_types_nr[];\nextern unsigned int rec_types_nr[];\n\nextern struct activity *act[];\nextern __nr_t (*f_count[]) (struct activity *);\n\nstruct sigaction alrm_act, int_act;\nint sigint_caught = 0;\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ] [ <outfile> ]\\n\"),\n\t\tprogname);\n\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -C <comment> ] [ -D ] [ -F ] [ -f ] [ -L ] [ -V ]\\n\"\n\t\t\t  \"[ -S { INT | DISK | IPV6 | POWER | SNMP | XDISK | ALL | XALL } ]\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * Collect all activities belonging to a group.\n *\n * IN:\n * @group_id\tGroup identification number.\n * @opt_f\tOptional flag to set.\n ***************************************************************************\n */\nvoid collect_group_activities(unsigned int group_id, unsigned int opt_f)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (act[i]->group & group_id) {\n\t\t\tact[i]->options |= AO_COLLECTED;\n\t\t\tif (opt_f) {\n\t\t\t\tact[i]->opt_flags |= opt_f;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Parse option -S, indicating which activities are to be collected.\n *\n * IN:\n * @argv\tArguments list.\n * @opt\t\tIndex in list of arguments.\n ***************************************************************************\n */\nvoid parse_sadc_S_option(char *argv[], int opt)\n{\n\tchar *p;\n\tint i;\n\n\tfor (p = strtok(argv[opt], \",\"); p; p = strtok(NULL, \",\")) {\n\t\tif (!strcmp(p, K_INT)) {\n\t\t\t/* Select group of interrupt activities */\n\t\t\tcollect_group_activities(G_INT, AO_F_NULL);\n\t\t}\n\t\telse if (!strcmp(p, K_DISK)) {\n\t\t\t/* Select group of disk activities */\n\t\t\tcollect_group_activities(G_DISK, AO_F_NULL);\n\t\t}\n\t\telse if (!strcmp(p, K_XDISK)) {\n\t\t\t/* Select group of disk and partition/filesystem activities */\n\t\t\tcollect_group_activities(G_DISK + G_XDISK, AO_F_DISK_PART);\n\t\t}\n\t\telse if (!strcmp(p, K_SNMP)) {\n\t\t\t/* Select group of SNMP activities */\n\t\t\tcollect_group_activities(G_SNMP, AO_F_NULL);\n\t\t}\n\t\telse if (!strcmp(p, K_IPV6)) {\n\t\t\t/* Select group of IPv6 activities */\n\t\t\tcollect_group_activities(G_IPV6, AO_F_NULL);\n\t\t}\n\t\telse if (!strcmp(p, K_POWER)) {\n\t\t\t/* Select group of activities related to power management */\n\t\t\tcollect_group_activities(G_POWER, AO_F_NULL);\n\t\t}\n\t\telse if (!strcmp(p, K_ALL) || !strcmp(p, K_XALL)) {\n\t\t\t/* Select all activities */\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\t\t\tif (!strcmp(p, K_ALL) && (act[i]->group & G_XDISK))\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't select G_XDISK activities\n\t\t\t\t\t * when option -S ALL is used.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tact[i]->options |= AO_COLLECTED;\n\t\t\t}\n\t\t\tif (!strcmp(p, K_XALL)) {\n\t\t\t\t/* Tell sadc to also collect partition statistics */\n\t\t\t\tcollect_group_activities(G_DISK + G_XDISK, AO_F_DISK_PART);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(p, K_A_NULL)) {\n\t\t\t/* Unselect all activities */\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\t\tact[i]->options &= ~AO_COLLECTED;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(p, \"A_\", 2)) {\n\t\t\t/* Select activity by name */\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\t\tif (!strcmp(p, act[i]->name)) {\n\t\t\t\t\tact[i]->options |= AO_COLLECTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == NR_ACT) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(p, \"-A_\", 3)) {\n\t\t\t/* Unselect activity by name */\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\t\tif (!strcmp(p + 1, act[i]->name)) {\n\t\t\t\t\tact[i]->options &= ~AO_COLLECTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == NR_ACT) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * SIGALRM signal handler. No need to reset handler here.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid alarm_handler(int sig)\n{\n\t__alarm(interval);\n}\n\n/*\n ***************************************************************************\n * SIGINT signal handler.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tpid_t ppid = getppid();\n\n\tsigint_caught = 1;\n\n\tif (!optz || (ppid == 1)) {\n\t\t/* sadc hasn't been called by sar or sar process is already dead */\n\t\texit(1);\n\t}\n\n\t/*\n\t * When starting sar then pressing ctrl/c, SIGINT is received\n\t * by sadc, not sar. So send SIGINT to sar so that average stats\n\t * can be displayed.\n\t */\n\tif (kill(ppid, SIGINT) < 0) {\n\t\texit(1);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display an error message.\n ***************************************************************************\n */\nvoid p_write_error(void)\n{\n\tfprintf(stderr, _(\"Cannot write data to system activity file: %s\\n\"),\n\t\tstrerror(errno));\n\texit(2);\n}\n\n/*\n ***************************************************************************\n * Init structures. All of them are init'ed first when they are allocated\n * (done by SREALLOC() macro in sa_sys_init() function).\n * Then, they are init'ed again each time before reading the various system\n * stats to make sure that no stats from a previous reading will remain.\n * This is useful mainly for non sequential activities where some structures\n * may remain unchanged. Such an activity is A_CPU, for which statistics\n * for offline CPU won't be read and their corresponding stats structure\n * won't be overwritten, giving the idea they are still online if we don't\n * reset their structures to zero.\n * Other activities may also assume that structure's fields are initialized\n * when their stats are read.\n ***************************************************************************\n */\nvoid reset_stats(void)\n{\n\tint i;\n\n        for (i = 0; i < NR_ACT; i++) {\n\t\tif ((act[i]->_nr0 > 0) && act[i]->_buf0) {\n\t\t\tmemset(act[i]->_buf0, 0,\n\t\t\t       (size_t) act[i]->msize * (size_t) act[i]->nr_allocated * (size_t) act[i]->nr2);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Count activities items then allocate and init corresponding structures.\n * Activities such as A_CPU with AO_ALWAYS_COUNTED flag set are always\n * counted (thus the number of CPU will always be counted even if CPU\n * activity is not collected), but ONLY those that will be collected have\n * allocated structures.\n * This function is called when sadc is started, and when a file is rotated.\n * If a file is rotated and structures are reallocated with a larger size,\n * additional space is not initialized: It doesn't matter as reset_stats()\n * will do it later.\n ***************************************************************************\n */\nvoid sa_sys_init(void)\n{\n\tint i, idx;\n\t__nr_t f_count_results[NR_F_COUNT];\n\n\t/* Init array. Means that no items have been counted yet */\n\tfor (i = 0; i < NR_F_COUNT; i++) {\n\t\tf_count_results[i] = -1;\n\t}\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif ((HAS_COUNT_FUNCTION(act[i]->options) && IS_COLLECTED(act[i]->options)) ||\n\t\t    ALWAYS_COUNT_ITEMS(act[i]->options)) {\n\t\t\tidx = act[i]->f_count_index;\n\n\t\t\t/* Number of items is not a constant and should be calculated */\n\t\t\tif (f_count_results[idx] >= 0) {\n\t\t\t\tact[i]->nr_ini = f_count_results[idx];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tact[i]->nr_ini = (f_count[idx])(act[i]);\n\t\t\t\tf_count_results[idx] = act[i]->nr_ini;\n\t\t\t}\n\t\t}\n\n\t\tif (act[i]->nr_ini > 0) {\n\t\t\tif (act[i]->f_count2_index >= 0) {\n\t\t\t\tidx = act[i]->f_count2_index;\n\n\t\t\t\tif (f_count_results[idx] >= 0) {\n\t\t\t\t\tact[i]->nr2 = f_count_results[idx];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tact[i]->nr2 = (f_count[idx])(act[i]);\n\t\t\t\t\tf_count_results[idx] = act[i]->nr2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* else act[i]->nr2 is a constant and doesn't need to be calculated */\n\n\t\t\tif (!act[i]->nr2) {\n\t\t\t\tact[i]->nr_ini = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (IS_COLLECTED(act[i]->options) && (act[i]->nr_ini > 0)) {\n\n\t\t\t/* Look for a possible overflow */\n\t\t\tcheck_overflow((unsigned int) act[i]->msize,\n\t\t\t\t       (unsigned int) act[i]->nr_ini,\n\t\t\t\t       (unsigned int) act[i]->nr2, 0);\n\n\t\t\t/* Allocate structures for current activity (using nr_ini and nr2 results) */\n\t\t\tSREALLOC(act[i]->_buf0, void,\n\t\t\t\t (size_t) act[i]->msize * (size_t) act[i]->nr_ini * (size_t) act[i]->nr2);\n\t\t\tact[i]->nr_allocated = act[i]->nr_ini;\n\t\t}\n\n\t\tif (act[i]->nr_ini <= 0) {\n\t\t\t/* No items found: Invalidate current activity */\n\t\t\tact[i]->options &= ~AO_COLLECTED;\n\t\t}\n\n\t\tif (HAS_DETECT_FUNCTION(act[i]->options) && IS_COLLECTED(act[i]->options)) {\n\t\t\tidx = act[i]->f_count_index;\n\n\t\t\t/* Detect if files needed by activity exist */\n\t\t\tif (f_count_results[idx] < 0) {\n\t\t\t\tf_count_results[idx] = (f_count[idx])(act[i]);\n\t\t\t}\n\t\t\tif (f_count_results[idx] == 0) {\n\t\t\t\t/* Files not present */\n\t\t\t\tact[i]->options &= ~AO_COLLECTED;\n\t\t\t}\n\t\t}\n\n\t\t/* Set default activity list */\n\t\tid_seq[i] = act[i]->id;\n\t}\n}\n\n/*\n ***************************************************************************\n * Free structures.\n ***************************************************************************\n */\nvoid sa_sys_free(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (act[i]->nr_allocated > 0) {\n\t\t\tif (act[i]->_buf0) {\n\t\t\t\tfree(act[i]->_buf0);\n\t\t\t\tact[i]->_buf0 = NULL;\n\t\t\t\tact[i]->nr_allocated = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * If -L option used, request a non-blocking, exclusive lock on the file.\n * If lock would block, then another process (possibly sadc) has already\n * opened that file => exit.\n *\n * IN:\n * @fd\t\tOutput file descriptor.\n * @fatal\tIndicate if failing to lock file should be fatal or not.\n * \t\tIf it's not fatal then we'll wait for next iteration and\n * \t\ttry again.\n *\n * RETURNS:\n * 0 on success, or 1 if file couldn't be locked.\n ***************************************************************************\n */\nint ask_for_flock(int fd, int fatal)\n{\n\t/* Option -L may be used only if an outfile was specified on the command line */\n\tif (LOCK_FILE(flags)) {\n\t\t/*\n\t\t * Yes: Try to lock file. To make code portable, check for both EWOULDBLOCK\n\t\t * and EAGAIN return codes, and treat them the same (glibc documentation).\n\t\t * Indeed, some Linux ports (e.g. hppa-linux) do not equate EWOULDBLOCK and\n\t\t * EAGAIN like every other Linux port.\n\t\t */\n\t\tif (flock(fd, LOCK_EX | LOCK_NB) < 0) {\n\t\t\tif ((((errno == EWOULDBLOCK) || (errno == EAGAIN)) && (fatal == FATAL)) ||\n\t\t\t    ((errno != EWOULDBLOCK) && (errno != EAGAIN))) {\n\t\t\t\tperror(\"flock\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t/* Was unable to lock file: Lock would have blocked... */\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\t/* File successfully locked */\n\t\t\tflags |= S_F_FILE_LOCKED;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Fill system activity file magic header.\n *\n * IN:\n * @file_magic\tSystem activity file magic header.\n ***************************************************************************\n */\nvoid fill_magic_header(struct file_magic *file_magic)\n{\n\tint i;\n\n\tmemset(file_magic, 0, FILE_MAGIC_SIZE);\n\n\tfile_magic->sysstat_magic = SYSSTAT_MAGIC;\n\tfile_magic->format_magic  = FORMAT_MAGIC;\n\n\tenum_version_nr(file_magic);\n\n\tfile_magic->header_size = FILE_HEADER_SIZE;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfile_magic->hdr_types_nr[i] = hdr_types_nr[i];\n\t}\n}\n\n/*\n ***************************************************************************\n * Fill system activity file header, then write it (or print it if stdout).\n *\n * IN:\n * @fd\tOutput file descriptor. May be stdout.\n ***************************************************************************\n */\nvoid setup_file_hdr(int fd)\n{\n\tint i, j, p;\n\tstruct tm rectime;\n\tstruct utsname header;\n\tstruct file_magic file_magic;\n\tstruct file_activity file_act;\n\n\t/* Fill then write file magic header */\n\tfill_magic_header(&file_magic);\n\n\tif (write_all(fd, &file_magic, FILE_MAGIC_SIZE) != FILE_MAGIC_SIZE) {\n\t\tp_write_error();\n\t}\n\n\t/* First reset the structure */\n\tmemset(&file_hdr, 0, FILE_HEADER_SIZE);\n\n\t/* Then get current date */\n\tfile_hdr.sa_ust_time = (unsigned long long) get_time(&rectime, 0);\n\n\t/* OK, now fill the header */\n\tfile_hdr.sa_act_nr      = get_activity_nr(act, AO_COLLECTED, COUNT_ACTIVITIES);\n\tfile_hdr.sa_day         = rectime.tm_mday;\n\tfile_hdr.sa_month       = rectime.tm_mon;\n\tfile_hdr.sa_year        = rectime.tm_year;\n\tfile_hdr.sa_sizeof_long = sizeof(long);\n\tfile_hdr.sa_hz\t\t= HZ;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfile_hdr.act_types_nr[i] = act_types_nr[i];\n\t\tfile_hdr.rec_types_nr[i] = rec_types_nr[i];\n\t}\n\tfile_hdr.act_size = FILE_ACTIVITY_SIZE;\n\tfile_hdr.rec_size = RECORD_HEADER_SIZE;\n\n\t/*\n\t * This is a new file (or stdout): Set sa_cpu_nr field to the number\n\t * of CPU of the machine (1 .. CPU_NR + 1). This is the number of CPU, whether\n\t * online or offline, when sadc was started.\n\t * A_CPU activity is always counted in sa_sys_init(), even if it's not collected.\n\t */\n\tfile_hdr.sa_cpu_nr = act[get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND)]->nr_ini;\n\n\t/* Get system name, release number, hostname and machine architecture */\n\t__uname(&header);\n\tstrncpy(file_hdr.sa_sysname, header.sysname, sizeof(file_hdr.sa_sysname));\n\tfile_hdr.sa_sysname[sizeof(file_hdr.sa_sysname) - 1]  = '\\0';\n\tstrncpy(file_hdr.sa_nodename, header.nodename, sizeof(file_hdr.sa_nodename));\n\tfile_hdr.sa_nodename[sizeof(file_hdr.sa_nodename) - 1] = '\\0';\n\tstrncpy(file_hdr.sa_release, header.release, sizeof(file_hdr.sa_release));\n\tfile_hdr.sa_release[sizeof(file_hdr.sa_release) - 1]  = '\\0';\n\tstrncpy(file_hdr.sa_machine, header.machine, sizeof(file_hdr.sa_machine));\n\tfile_hdr.sa_machine[sizeof(file_hdr.sa_machine) - 1]  = '\\0';\n\n\t/* Get timezone value and save it */\n\ttzset();\n\tstrncpy(file_hdr.sa_tzname, tzname[0], TZNAME_LEN);\n\tfile_hdr.sa_tzname[TZNAME_LEN - 1] = '\\0';\n\n\t/* Write file header */\n\tif (write_all(fd, &file_hdr, FILE_HEADER_SIZE) != FILE_HEADER_SIZE) {\n\t\tp_write_error();\n\t}\n\n\t/* Reset file_activity structure (in case some unknown extra fields exist) */\n\tmemset(&file_act, 0, FILE_ACTIVITY_SIZE);\n\n\t/* Write activity list */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\t/*\n\t\t * Activity sequence given by id_seq array.\n\t\t * Sequence must be the same for stdout as for output file.\n\t\t */\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\t\tif ((p = get_activity_position(act, id_seq[i], RESUME_IF_NOT_FOUND)) < 0)\n\t\t\tcontinue;\n\n\t\tif (IS_COLLECTED(act[p]->options)) {\n\t\t\tfile_act.id    = act[p]->id;\n\t\t\tfile_act.magic = act[p]->magic;\n\t\t\tfile_act.nr    = act[p]->nr_ini;\n\t\t\tfile_act.nr2   = act[p]->nr2;\n\t\t\tfile_act.size  = act[p]->fsize;\n\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\tfile_act.types_nr[j] = act[p]->gtypes_nr[j];\n\t\t\t}\n\n\t\t\tfile_act.has_nr = HAS_COUNT_FUNCTION(act[p]->options);\n\n\t\t\tif (write_all(fd, &file_act, FILE_ACTIVITY_SIZE) != FILE_ACTIVITY_SIZE) {\n\t\t\t\tp_write_error();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Write the new number of CPU after the RESTART record in file.\n *\n * IN:\n * @ofd\t\tOutput file descriptor.\n ***************************************************************************\n */\nvoid write_new_cpu_nr(int ofd)\n{\n\tint p;\n\n\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\n\tif (write_all(ofd, &(act[p]->nr_ini), sizeof(__nr_t)) != sizeof(__nr_t)) {\n\t\tp_write_error();\n\t}\n}\n\n/*\n ***************************************************************************\n * sadc called with interval and count parameters not set:\n * Write a dummy record notifying a system restart, or insert a comment in\n * binary data file if option -C has been used.\n * Writing a dummy record should typically be done at boot time,\n * before the cron daemon is started to avoid conflict with sa1/sa2 scripts.\n *\n * IN:\n * @ofd\t\tOutput file descriptor.\n * @rtype\tRecord type to write (restart or comment).\n ***************************************************************************\n */\nvoid write_special_record(int ofd, int rtype)\n{\n\tstruct tm rectime = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL};\n\n\t/* Check if file is locked */\n\tif (!FILE_LOCKED(flags)) {\n\t\task_for_flock(ofd, FATAL);\n\t}\n\n\t/* Reset the structure (sane to do it, as other fields may be added in the future) */\n\tmemset(&record_hdr, 0, RECORD_HEADER_SIZE);\n\n\t/* Set record type */\n\trecord_hdr.record_type = rtype;\n\n\t/* Save time */\n\trecord_hdr.ust_time = (unsigned long long) get_time(&rectime, 0);\n\n\trecord_hdr.hour   = rectime.tm_hour;\n\trecord_hdr.minute = rectime.tm_min;\n\trecord_hdr.second = rectime.tm_sec;\n\n\t/* Write record now */\n\tif (write_all(ofd, &record_hdr, RECORD_HEADER_SIZE) != RECORD_HEADER_SIZE) {\n\t\tp_write_error();\n\t}\n\n\tif (rtype == R_RESTART) {\n\t\t/* Also write the new number of CPU */\n\t\twrite_new_cpu_nr(ofd);\n\t}\n\telse if (rtype == R_COMMENT) {\n\t\t/* Also write the comment */\n\t\tif (write_all(ofd, comment, MAX_COMMENT_LEN) != MAX_COMMENT_LEN) {\n\t\t\tp_write_error();\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Write stats (or print them if stdout).\n *\n * IN:\n * @ofd\t\tOutput file descriptor. May be stdout.\n ***************************************************************************\n */\nvoid write_stats(int ofd)\n{\n\tint i, p;\n\n\t/* Try to lock file */\n\tif (!FILE_LOCKED(flags)) {\n\t\tif (ask_for_flock(ofd, NON_FATAL))\n\t\t\t/*\n\t\t\t * Unable to lock file:\n\t\t\t * Wait for next iteration to try again to save data.\n\t\t\t */\n\t\t\treturn;\n\t}\n\n\t/* Write record header */\n\tif (write_all(ofd, &record_hdr, RECORD_HEADER_SIZE) != RECORD_HEADER_SIZE) {\n\t\tp_write_error();\n\t}\n\n\t/* Then write all statistics */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\t\tif ((p = get_activity_position(act, id_seq[i], RESUME_IF_NOT_FOUND)) < 0)\n\t\t\tcontinue;\n\n\t\tif (IS_COLLECTED(act[p]->options)) {\n\t\t\tif (HAS_COUNT_FUNCTION(act[p]->options) && (act[p]->f_count_index >= 0)) {\n\t\t\t\tif (write_all(ofd, &(act[p]->_nr0), sizeof(__nr_t)) != sizeof(__nr_t)) {\n\t\t\t\t\tp_write_error();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (write_all(ofd, act[p]->_buf0, act[p]->fsize * act[p]->_nr0 * act[p]->nr2) !=\n\t\t\t    (act[p]->fsize * act[p]->_nr0 * act[p]->nr2)) {\n\t\t\t\tp_write_error();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Create a system activity daily data file.\n *\n * IN:\n * @ofile\tName of output file.\n *\n * OUT:\n * @ofd\t\tOutput file descriptor.\n ***************************************************************************\n */\nvoid create_sa_file(int *ofd, char *ofile)\n{\n\tif ((*ofd = open(ofile, O_CREAT | O_WRONLY,\n\t\t\t S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0)\n\t\tgoto create_error;\n\n\t/* Try to lock file */\n\task_for_flock(*ofd, FATAL);\n\n\t/* Truncate file */\n\tif (ftruncate(*ofd, 0) >= 0) {\n\n\t\t/* Write file header */\n\t\tsetup_file_hdr(*ofd);\n\n\t\treturn;\n\t}\n\ncreate_error:\n\tfprintf(stderr, _(\"Cannot open %s: %s\\n\"), ofile, strerror(errno));\n\texit(2);\n}\n\n/*\n ***************************************************************************\n * Get descriptor for stdout.\n *\n * IN:\n * @stdfd\tA value >= 0 indicates that stats data should also\n *\t\tbe written to stdout.\n *\n * OUT:\n * @stdfd\tStdout file descriptor.\n ***************************************************************************\n */\nvoid open_stdout(int *stdfd)\n{\n\tif (*stdfd >= 0) {\n\t\tif ((*stdfd = dup(STDOUT_FILENO)) < 0) {\n\t\t\tperror(\"dup\");\n\t\t\texit(4);\n\t\t}\n\t\t/* Write file header on STDOUT */\n\t\tsetup_file_hdr(*stdfd);\n\t}\n}\n\n/*\n ***************************************************************************\n * Get descriptor for output file and write its header.\n * We may enter this function several times (when we rotate a file).\n * NB: If data are appended to an existing file then the format must be\n * strictly that expected by current version.\n *\n * IN:\n * @ofile\t\tName of output file.\n * @restart_mark\tTRUE if sadc called with interval (and count) not\n * \t\t\tset, and no comment given (so we are going to insert\n * \t\t\ta restart mark into the file).\n *\n * OUT:\n * @ofd\t\t\tOutput file descriptor.\n ***************************************************************************\n */\nvoid open_ofile(int *ofd, char ofile[], int restart_mark)\n{\n\tstruct file_magic file_magic;\n\tstruct file_activity file_act[NR_ACT];\n\tstruct tm rectime = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL};\n\tssize_t sz;\n\tint i, p;\n\n\tif (!ofile[0])\n\t\treturn;\n\n\t/* Try to open file and check that data can be appended to it */\n\tif ((*ofd = open(ofile, O_APPEND | O_RDWR)) < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\t/* File doesn't exist: Create it */\n\t\t\tcreate_sa_file(ofd, ofile);\n\t\t\treturn;\n\t\t}\n\t\tfprintf(stderr, _(\"Cannot open %s: %s\\n\"), ofile, strerror(errno));\n\t\texit(2);\n\t}\n\n\t/* Read file magic header */\n\tsz = read(*ofd, &file_magic, FILE_MAGIC_SIZE);\n\tif (!sz) {\n\t\tclose(*ofd);\n\t\t/* This is an empty file: Create it again */\n\t\tcreate_sa_file(ofd, ofile);\n\t\treturn;\n\t}\n\n\t/* Test various values (\"strict writing\" rule) */\n\tif ((sz != FILE_MAGIC_SIZE) ||\n\t    (file_magic.sysstat_magic != SYSSTAT_MAGIC) ||\n\t    (file_magic.format_magic != FORMAT_MAGIC) ||\n\t    (file_magic.header_size != FILE_HEADER_SIZE) ||\n\t    (file_magic.hdr_types_nr[0] != FILE_HEADER_ULL_NR) ||\n\t    (file_magic.hdr_types_nr[1] != FILE_HEADER_UL_NR) ||\n\t    (file_magic.hdr_types_nr[2] != FILE_HEADER_U_NR)) {\n\t\tif (FORCE_FILE(flags)) {\n\t\t\tclose(*ofd);\n\t\t\t/* -F option used: Truncate file */\n\t\t\tcreate_sa_file(ofd, ofile);\n\t\t\treturn;\n\t\t}\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: Size read=%zd sysstat_magic=%x format_magic=%x header_size=%u header=%u,%u,%u\\n\",\n\t\t\t__FUNCTION__, sz, file_magic.sysstat_magic, file_magic.format_magic, file_magic.header_size,\n\t\t\tfile_magic.hdr_types_nr[0], file_magic.hdr_types_nr[1], file_magic.hdr_types_nr[2]);\n#endif\n\t\t/* Display error message and exit */\n\t\thandle_invalid_sa_file(*ofd, &file_magic, ofile, sz);\n\t}\n\n\t/* Read file standard header */\n\tif ((sz = read(*ofd, &file_hdr, FILE_HEADER_SIZE)) != FILE_HEADER_SIZE) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: Size read=%zd\\n\",\n\t\t\t__FUNCTION__, sz);\n#endif\n\t\tgoto append_error;\n\t}\n\n\t/*\n\t * If we are using the standard daily data file (file specified\n\t * as \"-\" on the command line) and it is from a past month,\n\t * then overwrite (truncate) it.\n\t */\n\tget_time(&rectime, 0);\n\n\tif (((file_hdr.sa_month != rectime.tm_mon) ||\n\t    (file_hdr.sa_year != rectime.tm_year)) &&\n\t    WANT_SA_ROTAT(flags)) {\n\t\tclose(*ofd);\n\t\tcreate_sa_file(ofd, ofile);\n\t\treturn;\n\t}\n\n\t/* OK: It's a true system activity file */\n\tif (!file_hdr.sa_act_nr || (file_hdr.sa_act_nr > NR_ACT)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr.sa_act_nr);\n#endif\n\t\t/*\n\t\t * No activities at all or at least one unknown activity:\n\t\t * Cannot append data to such a file.\n\t\t */\n\t\tgoto append_error;\n\t}\n\n\t/* Other sanity checks (\"strict writing\" rule) */\n\tif ((file_hdr.act_size != FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr.act_types_nr[0] != FILE_ACTIVITY_ULL_NR) ||\n\t    (file_hdr.act_types_nr[1] != FILE_ACTIVITY_UL_NR) ||\n\t    (file_hdr.act_types_nr[2] != FILE_ACTIVITY_U_NR) ||\n\t    (file_hdr.rec_size != RECORD_HEADER_SIZE) ||\n\t    (file_hdr.rec_types_nr[0] != RECORD_HEADER_ULL_NR) ||\n\t    (file_hdr.rec_types_nr[1] != RECORD_HEADER_UL_NR) ||\n\t    (file_hdr.rec_types_nr[2] != RECORD_HEADER_U_NR)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: act_size=%u act=%u,%u,%u rec_size=%u rec=%u,%u,%u\\n\",\n\t\t\t__FUNCTION__, file_hdr.act_size,\n\t\t\tfile_hdr.act_types_nr[0], file_hdr.act_types_nr[1], file_hdr.act_types_nr[2],\n\t\t\tfile_hdr.rec_size,\n\t\t\tfile_hdr.rec_types_nr[0], file_hdr.rec_types_nr[1], file_hdr.rec_types_nr[2]);\n#endif\n\t\tgoto append_error;\n\t}\n\n\tfor (i = 0; i < file_hdr.sa_act_nr; i++) {\n\n\t\t/* Read current activity in list */\n\t\tif (read(*ofd, &file_act[i], FILE_ACTIVITY_SIZE) != FILE_ACTIVITY_SIZE) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: Wrong size for file_activity\\n\",\n\t\t\t\t__FUNCTION__);\n#endif\n\t\t\thandle_invalid_sa_file(*ofd, &file_magic, ofile, 0);\n\t\t}\n\n\t\tp = get_activity_position(act, file_act[i].id, RESUME_IF_NOT_FOUND);\n\n\t\tif ((p < 0) || (act[p]->fsize != file_act[i].size) ||\n\t\t    (act[p]->magic != file_act[i].magic)) {\n#ifdef DEBUG\n\t\t\tif (p < 0) {\n\t\t\t\tfprintf(stderr, \"%s: p=%d\\n\", __FUNCTION__, p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"%s: %s: size=%d/%d magic=%x/%x\\n\",\n\t\t\t\t\t__FUNCTION__, act[p]->name, act[p]->fsize, file_act[i].size,\n\t\t\t\t\tact[p]->magic, file_act[i].magic);\n\t\t\t}\n#endif\n\t\t\t/*\n\t\t\t * Unknown activity in list or item size has changed or\n\t\t\t * unknown activity format: Cannot append data to such a file\n\t\t\t * (\"strict writing\" rule).\n\t\t\t */\n\t\t\tgoto append_error;\n\t\t}\n\n\t\tif ((file_act[i].nr <= 0) || (file_act[i].nr2 <= 0) ||\n\t\t    (file_act[i].nr > act[p]->nr_max) ||\n\t\t    (file_act[i].nr2 > NR2_MAX)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: %s: nr=%d nr_max=%d nr2=%d\\n\",\n\t\t\t\t__FUNCTION__, act[p]->name, file_act[i].nr,\n\t\t\t\tact[p]->nr_max, file_act[i].nr2);\n#endif\n\t\t\t/*\n\t\t\t * Number of items and subitems should never be zero (or negative)\n\t\t\t * or greater than their upper limit.\n\t\t\t */\n\t\t\tgoto append_error;\n\t\t}\n\n\t\tif ((file_act[i].types_nr[0] != act[p]->gtypes_nr[0]) ||\n\t\t    (file_act[i].types_nr[1] != act[p]->gtypes_nr[1]) ||\n\t\t    (file_act[i].types_nr[2] != act[p]->gtypes_nr[2])) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: %s: types=%u,%u,%u/%u,%u,%u\\n\",\n\t\t\t\t__FUNCTION__, act[p]->name,\n\t\t\t\tfile_act[i].types_nr[0], file_act[i].types_nr[1], file_act[i].types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\t/*\n\t\t\t * Composition of structure containing statsitics cannot\n\t\t\t * be different from that known by current version.\n\t\t\t */\n\t\t\tgoto append_error;\n\t\t}\n\n\t\tif ((file_act[i].has_nr && (act[p]->f_count_index < 0)) ||\n\t\t    (!file_act[i].has_nr && (act[p]->f_count_index >= 0) && HAS_COUNT_FUNCTION(act[p]->options))) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: %s: has_nr=%d count_index=%d\\n\",\n\t\t\t\t__FUNCTION__, act[p]->name, file_act[i].has_nr, act[p]->f_count_index);\n#endif\n\t\t\t/*\n\t\t\t * For every activity whose number of items is not a constant,\n\t\t\t * a value giving the number of structures to read should exist.\n\t\t\t */\n\t\t\tgoto append_error;\n\t\t}\n\t}\n\n\t/*\n\t * OK: (Almost) all tests successfully passed.\n\t * List of activities from the file prevails over that of the user.\n\t * So unselect all of them. And reset activity sequence.\n\t */\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tact[i]->options &= ~AO_COLLECTED;\n\t\tid_seq[i] = 0;\n\t}\n\n\tfor (i = 0; i < file_hdr.sa_act_nr; i++) {\n\n\t\tp = get_activity_position(act, file_act[i].id, EXIT_IF_NOT_FOUND);\n\n\t\t/*\n\t\t * sar doesn't expect a number of items equal to 0.\n\t\t * Yet @nr_ini may be 0 if no items have been found on current machine.\n\t\t * Since we are appending data to a file, set @nr_ini to the value of the file.\n\t\t * Stats saved in file will all be 0 for that activity if no items exist on\n\t\t * the machine.\n\t\t * NB: We must preserve the value read for A_CPU when a LINUX RESTART is inserted.\n\t\t */\n\t\tif (!ALWAYS_COUNT_ITEMS(act[p]->options) || !act[p]->nr_ini) {\n\t\t\tact[p]->nr_ini = file_act[i].nr;\n\t\t}\n\n\t\t/*\n\t\t * Force number of sub-items to that of the file, and reallocate structures.\n\t\t * Note: Structures have been allocated in sa_sys_init() only for activities\n\t\t * that are collected. But since activities from file now prevail over them,\n\t\t * we need to reallocate.\n\t\t */\n\t\tact[p]->nr2 = file_act[i].nr2;\n\t\tif (act[p]->nr_ini > act[p]->nr_allocated) {\n\t\t\tact[p]->nr_allocated = act[p]->nr_ini;\n\t\t}\n\n\t\t/* Look for a possible overflow */\n\t\tcheck_overflow((unsigned int) act[p]->msize,\n\t\t\t       (unsigned int) act[p]->nr_allocated,\n\t\t\t       (unsigned int) act[p]->nr2, 0);\n\n\t\tSREALLOC(act[p]->_buf0, void,\n\t\t\t (size_t) act[p]->msize * (size_t) act[p]->nr_allocated * (size_t) act[p]->nr2);\n\n\t\t/* Save activity sequence */\n\t\tid_seq[i] = file_act[i].id;\n\t\tact[p]->options |= AO_COLLECTED;\n\t}\n\n\treturn;\n\nappend_error:\n\n\tclose(*ofd);\n\tif (FORCE_FILE(flags)) {\n\t\t/* Truncate file */\n\t\tcreate_sa_file(ofd, ofile);\n\t}\n\telse {\n\t\tfprintf(stderr, _(\"Cannot append data to that file (%s)\\n\"), ofile);\n\t\texit(1);\n\t}\n}\n\n/*\n ***************************************************************************\n * Read statistics from various system files.\n ***************************************************************************\n */\nvoid read_stats(void)\n{\n\tint i;\n\n\t/* Read system uptime in 1/100th of a second */\n\tread_uptime(&(record_hdr.uptime_cs));\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (IS_COLLECTED(act[i]->options)) {\n\t\t\t/* Read statistics for current activity */\n\t\t\t(*act[i]->f_read)(act[i]);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Main loop: Read stats from the relevant sources and display them.\n *\n * IN:\n * @count\tNumber of lines of stats to display.\n * @stdfd\tStdout file descriptor.\n * @ofd\t\tOutput file descriptor.\n * @ofile\tName of output file.\n * @sa_dir\tIf not an empty string, contains the alternate location of\n * \t\tdaily data files.\n ***************************************************************************\n */\nvoid rw_sa_stat_loop(long count, int stdfd, int ofd, char ofile[],\n\t\t     char sa_dir[])\n{\n\tint do_sa_rotat = 0;\n\tuint64_t save_flags;\n\tchar new_ofile[MAX_FILE_LEN] = \"\";\n\tstruct tm rectime = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL};\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\t/* Main loop */\n\tdo {\n\t\t/* Init all structures */\n\t\treset_stats();\n\t\tmemset(&record_hdr, 0, RECORD_HEADER_SIZE);\n\n\t\t/* Save time */\n\t\trecord_hdr.ust_time = (unsigned long long) get_time(&rectime, 0);\n\t\trecord_hdr.hour     = rectime.tm_hour;\n\t\trecord_hdr.minute   = rectime.tm_min;\n\t\trecord_hdr.second   = rectime.tm_sec;\n\n\t\t/* Set record type */\n\t\tif (do_sa_rotat) {\n\t\t\trecord_hdr.record_type = R_LAST_STATS;\n\t\t}\n\t\telse {\n\t\t\trecord_hdr.record_type = R_STATS;\n\t\t}\n\n\t\t/* Read then write stats */\n\t\tread_stats();\n\n\t\tif (stdfd >= 0) {\n\t\t\tsave_flags = flags;\n\t\t\tflags &= ~S_F_LOCK_FILE;\n\t\t\twrite_stats(stdfd);\n\t\t\tflags = save_flags;\n\t\t}\n\n\t\t/* If the record type was R_LAST_STATS, tag it R_STATS before writing it */\n\t\trecord_hdr.record_type = R_STATS;\n\t\tif (ofile[0]) {\n\t\t\twrite_stats(ofd);\n\t\t}\n\n\t\tif (do_sa_rotat) {\n\t\t\t/*\n\t\t\t * Stats are written at the end of previous file *and* at the\n\t\t\t * beginning of the new one (outfile must have been specified\n\t\t\t * as '-' on the command line).\n\t\t\t */\n\t\t\tdo_sa_rotat = FALSE;\n\n\t\t\tif (fdatasync(ofd) < 0) {\n\t\t\t\t/* Flush previous file */\n\t\t\t\tperror(\"fdatasync\");\n\t\t\t\texit(4);\n\t\t\t}\n\t\t\tclose(ofd);\n\t\t\tstrcpy(ofile, new_ofile);\n\n\t\t\t/* Recalculate number of system items and reallocate structures */\n\t\t\tsa_sys_init();\n\n\t\t\t/*\n\t\t\t * Open and init new file.\n\t\t\t * This is also used to set activity sequence to that of the file\n\t\t\t * if the file already exists.\n\t\t\t */\n\t\t\topen_ofile(&ofd, ofile, FALSE);\n\n\t\t\t/*\n\t\t\t * Rewrite header and activity sequence to stdout since\n\t\t\t * number of items may have changed.\n\t\t\t */\n\t\t\tif (stdfd >= 0) {\n\t\t\t\tsetup_file_hdr(stdfd);\n\t\t\t}\n\n\t\t\t/* Write stats to file again */\n\t\t\twrite_stats(ofd);\n\t\t}\n\n\t\t/* Flush data */\n\t\tfflush(stdout);\n\t\tif (FDATASYNC(flags)) {\n\t\t\t/* If indicated, sync the data to media */\n\t\t\tif (fdatasync(ofd) < 0) {\n\t\t\t\tperror(\"fdatasync\");\n\t\t\t\texit(4);\n\t\t\t}\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count) {\n\t\t\t/* Wait for a signal (probably SIGALRM or SIGINT) */\n\t\t\t__pause();\n\t\t}\n\n\t\tif (sigint_caught)\n\t\t\t/* SIGINT caught: Stop now */\n\t\t\tbreak;\n\n\t\t/* Rotate activity file if necessary */\n\t\tif (WANT_SA_ROTAT(flags)) {\n\t\t\t/* The user specified '-' as the filename to use */\n\t\t\tstrncpy(new_ofile, sa_dir, sizeof(new_ofile) - 1);\n\t\t\tnew_ofile[sizeof(new_ofile) - 1] = '\\0';\n\t\t\tset_default_file(new_ofile, 0, USE_SA_YYYYMMDD(flags));\n\n\t\t\tif (strcmp(ofile, new_ofile)) {\n\t\t\t\tdo_sa_rotat = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\twhile (count);\n\n\t/* Close file descriptors if they have actually been used */\n\tCLOSE(stdfd);\n\tCLOSE(ofd);\n}\n\n/*\n ***************************************************************************\n * Main entry to the program.\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint opt = 0;\n\tchar ofile[MAX_FILE_LEN], sa_dir[MAX_FILE_LEN];\n\tint stdfd = 0, ofd = -1;\n\tint restart_mark;\n\tlong count = 0;\n\n#ifdef TEST\n\tfprintf(stderr, \"TEST MODE\\n\");\n#endif\n\n\t/* Get HZ */\n\tget_HZ();\n\n\t/* Compute page shift in kB */\n\tget_kb_shift();\n\n\tofile[0] = sa_dir[0] = comment[0] = '\\0';\n\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\t/* Initialize sensors, let it use the default cfg file */\n\tint err = sensors_init(NULL);\n\tif (err) {\n\t\tfprintf(stderr, \"sensors_init: %s\\n\", sensors_strerror(err));\n\t}\n#endif /* HAVE_SENSORS */\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\twhile (++opt < argc) {\n\n\t\tif (!strcmp(argv[opt], \"-S\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tparse_sadc_S_option(argv, opt);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-D\")) {\n\t\t\tflags |= S_F_SA_YYYYMMDD;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-F\")) {\n\t\t\tflags |= S_F_FORCE_FILE;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-L\")) {\n\t\t\tflags |= S_F_LOCK_FILE;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-V\")) {\n\t\t\tchar *sadc_env[] = {ENV_TIME_DEFTM};\n#define SADC_ENV_NR\t1\n\t\t\tprint_version(sadc_env, SADC_ENV_NR);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-Z\")) {\n\t\t\t/* Set by sar command */\n\t\t\toptz = 1;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-f\")) {\n\t\t\tflags |= S_F_FDATASYNC;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-C\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tstrncpy(comment, argv[opt], sizeof(comment));\n\t\t\tcomment[sizeof(comment) - 1] = '\\0';\n\t\t\tif (!strlen(comment)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--unix_time=\", 12)) {\n\t\t\tif (strspn(argv[opt] + 12, DIGITS) != strlen(argv[opt] + 12)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t__unix_time = atoll(argv[opt] + 12);\n\t\t}\n#endif\n\n\t\telse if (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\tif (ofile[0] || WANT_SA_ROTAT(flags)) {\n\t\t\t\t/* Outfile already specified */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tstdfd = -1;\t/* Don't write to STDOUT */\n\t\t\tif (!strcmp(argv[opt], \"-\")) {\n\t\t\t\t/* File name set to '-' */\n\t\t\t\tflags |= S_F_SA_ROTAT;\n\t\t\t}\n\t\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\t\t/* Bad option */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Write data to file */\n\t\t\t\tstrncpy(ofile, argv[opt], sizeof(ofile));\n\t\t\t\tofile[sizeof(ofile) - 1] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\telse if (interval < 0) {\n\t\t\t/* Get interval */\n\t\t\tinterval = atol(argv[opt]);\n\t\t\tif (interval < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = -1;\n\t\t}\n\n\t\telse if (count <= 0) {\n\t\t\t/* Get count value */\n\t\t\tcount = atol(argv[opt]);\n\t\t\tif (count < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\t/* Process file entered on the command line */\n\tif (WANT_SA_ROTAT(flags)) {\n\t\t/* File name set to '-' */\n\t\tset_default_file(ofile, 0, USE_SA_YYYYMMDD(flags));\n\t}\n\telse if (ofile[0]) {\n\t\t/*\n\t\t * A file (or directory) has been explicitly entered\n\t\t * on the command line.\n\t\t * Should ofile be a directory, it will be the alternate\n\t\t * location for sa files. So save it.\n\t\t */\n\t\tstrcpy(sa_dir, ofile);\n\t\t/* Check if this is an alternate directory for sa files */\n\t\tif (check_alt_sa_dir(ofile, 0, USE_SA_YYYYMMDD(flags))) {\n\t\t\t/*\n\t\t\t * Yes, it was a directory.\n\t\t\t * ofile now contains the full path to current\n\t\t\t * standard daily data file.\n\t\t\t */\n\t\t\tflags |= S_F_SA_ROTAT;\n\t\t}\n\t\telse {\n\t\t\t/* No: So we can clear sa_dir */\n\t\t\tsa_dir[0] = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * If option -Z used, write to STDOUT even if a filename\n\t * has been entered on the command line.\n\t */\n\tif (optz) {\n\t\tstdfd = 0;\n\t}\n\n\tif (!ofile[0]) {\n\t\t/* -L option ignored when writing to STDOUT */\n\t\tflags &= ~S_F_LOCK_FILE;\n\t}\n\n\t/* Init structures according to machine architecture */\n\tsa_sys_init();\n\n\t/* At least one activity must be collected */\n\tif (!get_activity_nr(act, AO_COLLECTED, COUNT_ACTIVITIES)) {\n\t\t/* Requested activities not available: Exit */\n\t\tprint_collect_error();\n\t}\n\n\tif ((interval < 0) && !comment[0]) {\n\t\t/*\n\t\t * Interval (and count) not set, and no comment given\n\t\t * => We are going to insert a restart mark.\n\t\t */\n\t\trestart_mark = TRUE;\n\t}\n\telse {\n\t\trestart_mark = FALSE;\n\t}\n\n\t/*\n\t * Open output file then STDOUT. Write header for each of them.\n\t * NB: Output file must be opened first, because we may change\n\t * the activities collected AND the activity sequence to that\n\t * of the file, and the activities collected and activity sequence\n\t * written on STDOUT must be consistent to those of the file.\n\t */\n\topen_ofile(&ofd, ofile, restart_mark);\n\topen_stdout(&stdfd);\n\n\tif (interval < 0) {\n\t\tif (ofd >= 0) {\n\t\t\t/*\n\t\t\t * Interval (and count) not set:\n\t\t\t * Write a dummy record, or insert a comment, then exit.\n\t\t\t * NB: Never write such a dummy record on stdout since\n\t\t\t * sar never expects it.\n\t\t\t */\n\t\t\tif (comment[0]) {\n\t\t\t\twrite_special_record(ofd, R_COMMENT);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twrite_special_record(ofd, R_RESTART);\n\t\t\t}\n\n\t\t\t/* Close file descriptor */\n\t\t\tCLOSE(ofd);\n\t\t}\n\n\t\t/* Free structures */\n\t\tsa_sys_free();\n\t\texit(0);\n\t}\n\n\t/* Set a handler for SIGALRM */\n\tmemset(&alrm_act, 0, sizeof(alrm_act));\n\talrm_act.sa_handler = alarm_handler;\n\tsigaction(SIGALRM, &alrm_act, NULL);\n\t__alarm(interval);\n\n\t/* Main loop */\n\trw_sa_stat_loop(count, stdfd, ofd, ofile, sa_dir);\n\n#if (defined(HAVE_SENSORS) && !defined(ARCH32)) || (defined(ARCH32) && defined(HAVE_SENSORS32))\n\t/* Cleanup sensors */\n\tsensors_cleanup();\n#endif /* HAVE_SENSORS */\n\n\t/* Free structures */\n\tsa_sys_free();\n\n\treturn 0;\n}\n"
        },
        {
          "name": "sadf.c",
          "type": "blob",
          "size": 59.888671875,
          "content": "/*\n * sadf: system activity data formatter\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <errno.h>\n\n#include \"version.h\"\n#include \"sadf.h\"\n\n# include <locale.h>\t/* For setlocale() */\n#ifdef USE_NLS\n# include <libintl.h>\n# define _(string) gettext(string)\n#else\n# define _(string) (string)\n#endif\n\n#ifdef HAVE_PCP\n#include <pcp/pmapi.h>\n#include <pcp/import.h>\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern int __env;\nvoid int_handler(int n) { return; }\n#endif\n\nextern char *tzname[2];\n\nlong interval = -1, count = 0;\n\n/* TRUE if data read from file don't match current machine's endianness */\nint endian_mismatch = FALSE;\n/* TRUE if file's data come from a 64 bit machine */\nint arch_64 = FALSE;\n/* Number of decimal places */\nint dplaces_nr = -1;\n/* Color palette number */\nint palette = SVG_DEFAULT_COL_PALETTE;\n\nuint64_t flags = 0;\nunsigned int dm_major;\t\t/* Device-mapper major number */\nunsigned int format = 0;\t/* Output format */\nunsigned int f_position = 0;\t/* Output format position in array */\nunsigned int canvas_height = 0; /* SVG canvas height value set with option -O */\nunsigned int user_hz = 0;\t/* HZ value set with option -O */\n\n/* File header */\nstruct file_header file_hdr;\n\n/*\n * Activity sequence.\n * This array must always be entirely filled (even with trailing zeros).\n */\nunsigned int id_seq[NR_ACT];\n\n/* Current record header */\nstruct record_header record_hdr[3];\n\n/* Contain the date specified by -s and -e options */\nstruct tstamp_ext tm_start, tm_end;\nchar *args[MAX_ARGV_NR];\n\n/* Current timezone */\nchar my_tzname[TZNAME_LEN];\n\nextern struct activity *act[];\nextern struct report_format *fmt[];\n\n/* Battery status */\nchar bat_status[][16] = {\n\t\"Unknown\",\n\t\"Charging\",\n\t\"Discharging\",\n\t\"NotCharging\",\n\t\"Full\"\n};\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command.\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr,\n\t\t_(\"Usage: %s [ options ] [ <interval> [ <count> ] ] [ <datafile> | -[0-9]+ ]\\n\"),\n\t\tprogname);\n\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -C ] [ -c | -d | -g | -j | -l | -p | -r | -x ] [ -H ] [ -h ] [ -T | -t | -U ] [ -V ]\\n\"\n\t\t\t  \"[ -O <opts> [,...] ] [ -P { <cpu> [,...] | ALL } ]\\n\"\n\t\t\t  \"[ --dev=<dev_list> ] [ --fs=<fs_list> ] [ --iface=<iface_list> ] [ --int=<int_list> ]\\n\"\n\t\t\t  \"[ -s [ <start_time> ] ] [ -e [ <end_time> ] ]\\n\"\n\t\t\t  \"[ -- <sar_options> ]\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * Init structures.\n ***************************************************************************\n */\nvoid init_structures(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tmemset(&record_hdr[i], 0, RECORD_HEADER_SIZE);\n\t}\n}\n\n/*\n ***************************************************************************\n * Look for output format in array.\n *\n * IN:\n * @oformat\tOutput format to look for.\n *\n * RETURNS:\n * Position of output format in array.\n ***************************************************************************\n */\nint get_format_position(unsigned int oformat)\n{\n        int i;\n\n        for (i = 0; i < NR_FMT; i++) {\n                if (fmt[i]->id == oformat)\n                        break;\n        }\n\n        if (i == NR_FMT)\n\t\t/* Should never happen */\n                return 0;\n\n        return i;\n}\n\n/*\n ***************************************************************************\n * Check that options entered on the command line are consistent with\n * selected output format. If no output format has been explicitly entered,\n * then select a default one.\n ***************************************************************************\n */\nvoid check_format_options(void)\n{\n\tif (!format) {\n\t\t/* Select output format if none has been selected */\n\t\tif (DISPLAY_HDR_ONLY(flags)) {\n\t\t\tformat = F_HEADER_OUTPUT;\n\t\t}\n\t\telse {\n\t\t\tformat = F_PPC_OUTPUT;\n\t\t}\n\t}\n\n\t/* Get format position in array */\n\tf_position = get_format_position(format);\n\n\t/* Check options consistency wrt output format */\n\tif (!ACCEPT_HEADER_ONLY(fmt[f_position]->options)) {\n\t\t/* Remove option -H */\n\t\tflags &= ~S_F_HDR_ONLY;\n\t}\n\tif (!ACCEPT_HORIZONTALLY(fmt[f_position]->options)) {\n\t\t/* Remove option -h */\n\t\tflags &= ~S_F_HORIZONTALLY;\n\t}\n\tif (!ACCEPT_LOCAL_TIME(fmt[f_position]->options)) {\n\t\t/* Remove option -T */\n\t\tflags &= ~S_F_LOCAL_TIME;\n\t}\n\tif (!ACCEPT_SEC_EPOCH(fmt[f_position]->options)) {\n\t\t/* Remove option -U */\n\t\tflags &= ~S_F_SEC_EPOCH;\n\t}\n\tif (REJECT_TRUE_TIME(fmt[f_position]->options)) {\n\t\t/* Remove option -t */\n\t\tflags &= ~S_F_TRUE_TIME;\n\t}\n}\n\n/*\n ***************************************************************************\n * Read next sample statistics. If it's a special record (R_RESTART or\n * R_COMMENT) then display it if requested. Also fill timestamps structures.\n *\n * IN:\n * @ifd\t\tFile descriptor\n * @action\tFlags indicating if special records should be displayed or\n * \t\tnot.\n * @curr\tIndex in array for current sample statistics.\n * @file\tSystem activity data file name (name of file being read).\n * @tab\t\tNumber of tabulations to print.\n * @file_magic\tSystem activity file magic header.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @oneof\tSet to UEOF_CONT if an unexpected end of file should not make\n *\t\tsadf stop. Default behavior is to stop on unexpected EOF.\n *\n * OUT:\n * @rtype\tType of record read (R_RESTART, R_COMMENT, etc.)\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on options used) has been saved for current record.\n *\t\tIf current record was a special one (RESTART or COMMENT) and\n *\t\tnoted to be ignored, then the timestamp is saved only if\n *\t\texplicitly told to do so with the SET_TIMESTAMPS action flag.\n *\n * RETURNS:\n * 1 if EOF has been reached,\n * 2 if an unexpected EOF has been reached, or an error occurred.\n * 0 otherwise.\n ***************************************************************************\n */\nint read_next_sample(int ifd, int action, int curr, char *file, int *rtype, int tab,\n\t\t     struct file_magic *file_magic, struct file_activity *file_actlst,\n\t\t     struct tstamp_ext *rectime, enum on_eof oneof)\n{\n\tint rc;\n\tchar rec_hdr_tmp[MAX_RECORD_HEADER_SIZE];\n\n\t/* Read current record */\n\tif ((rc = read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[curr], &file_hdr,\n\t\t\t\t  arch_64, endian_mismatch, oneof, sizeof(rec_hdr_tmp), flags,\n\t\t\t\t  fmt[f_position])) != 0)\n\t\t/* End of sa file */\n\t\treturn rc;\n\n\t*rtype = record_hdr[curr].record_type;\n\n\tif (*rtype == R_COMMENT) {\n\t\tif (action & IGNORE_COMMENT) {\n\t\t\t/* Ignore COMMENT record */\n\t\t\tif (lseek(ifd, MAX_COMMENT_LEN, SEEK_CUR) < MAX_COMMENT_LEN) {\n\t\t\t\tif (oneof == UEOF_CONT)\n\t\t\t\t\treturn 2;\n\t\t\t\tclose(ifd);\n\t\t\t\texit(2);\n\t\t\t}\n\n\t\t\t/* Ignore unknown extra structures if present */\n\t\t\tif (record_hdr[curr].extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\t\treturn 2;\n\n\t\t\tif (action & SET_TIMESTAMPS) {\n\t\t\t\tif (sa_get_record_timestamp_struct(flags, &record_hdr[curr],\n\t\t\t\t\t\t\t\t   rectime))\n\t\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Display COMMENT record */\n\t\t\tprint_special_record(&record_hdr[curr], flags, &tm_start, &tm_end,\n\t\t\t\t\t     *rtype, ifd, rectime, file, tab, my_tzname,\n\t\t\t\t\t     file_magic, &file_hdr, act, fmt[f_position],\n\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t}\n\t}\n\telse if (*rtype == R_RESTART) {\n\t\tif (action & IGNORE_RESTART) {\n\t\t\t/*\n\t\t\t * Ignore RESTART record (don't display it)\n\t\t\t * but anyway we have to read the CPU number that follows it\n\t\t\t * (unless we don't want to do it now).\n\t\t\t */\n\t\t\tif (!(action & DONT_READ_CPU_NR)) {\n\t\t\t\tfile_hdr.sa_cpu_nr = read_nr_value(ifd, file, file_magic,\n\t\t\t\t\t\t\t\t   endian_mismatch, arch_64, TRUE,\n\t\t\t\t\t\t\t\t   NR_CPUS + 1);\n\n\t\t\t\t/* Ignore unknown extra structures if present */\n\t\t\t\tif (record_hdr[curr].extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (action & SET_TIMESTAMPS) {\n\t\t\t\tif (sa_get_record_timestamp_struct(flags, &record_hdr[curr], rectime))\n\t\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Display RESTART record */\n\t\t\tprint_special_record(&record_hdr[curr], flags, &tm_start, &tm_end,\n\t\t\t\t\t     *rtype, ifd, rectime, file, tab, my_tzname,\n\t\t\t\t\t     file_magic, &file_hdr, act, fmt[f_position],\n\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t}\n\t}\n\telse {\n\t\t/*\n\t\t * OK: Previous record was not a special one.\n\t\t * So read now the extra fields.\n\t\t */\n\t\tif (read_file_stat_bunch(act, curr, ifd, file_hdr.sa_act_nr, file_actlst,\n\t\t\t\t\t endian_mismatch, arch_64, file, file_magic, oneof,\n\t\t\t\t\t flags) > 0)\n\t\t\treturn 2;\n\t\tif (sa_get_record_timestamp_struct(flags, &record_hdr[curr], rectime))\n\t\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Display the field list (used eg. in database format).\n *\n * IN:\n * @act_id\tActivity to display, or ~0 for all.\n ***************************************************************************\n */\nvoid list_fields(unsigned int act_id)\n{\n\tint i, j;\n\tunsigned int msk;\n\tchar *hl;\n\tchar hline[HEADER_LINE_LEN] = \"\";\n\tchar out[256];\n\n\tcprintf_s(IS_COMMENT, \"%s\", \"# hostname;interval;timestamp\");\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif ((act_id != ALL_ACTIVITIES) && (act[i]->id != act_id))\n\t\t\tcontinue;\n\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr_ini > 0)) {\n\t\t\tif (!HAS_MULTIPLE_OUTPUTS(act[i]->options)) {\n\t\t\t\tsprintf(out, \";%s\", act[i]->hdr_line);\n\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", out);\n\t\t\t\tif ((act[i]->nr_ini > 1) && DISPLAY_HORIZONTALLY(flags)) {\n\t\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", \"[...]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmsk = 1;\n\t\t\t\tstrncpy(hline, act[i]->hdr_line, sizeof(hline) - 1);\n\t\t\t\thline[sizeof(hline) - 1] = '\\0';\n\t\t\t\tfor (hl = strtok(hline, \"|\"); hl; hl = strtok(NULL, \"|\"), msk <<= 1) {\n\t\t\t\t\tif ((hl != NULL) && ((act[i]->opt_flags & 0xff) & msk)) {\n\t\t\t\t\t\tif (strchr(hl, '&')) {\n\t\t\t\t\t\t\tj = strcspn(hl, \"&\");\n\t\t\t\t\t\t\tif ((act[i]->opt_flags & 0xff00) & (msk << 8)) {\n\t\t\t\t\t\t\t\t/* Display whole header line */\n\t\t\t\t\t\t\t\t*(hl + j) = ';';\n\t\t\t\t\t\t\t\tsprintf(out, \";%s\", hl);\n\t\t\t\t\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t/* Display only the first part of the header line */\n\t\t\t\t\t\t\t\t*(hl + j) = '\\0';\n\t\t\t\t\t\t\t\tsprintf(out, \";%s\", hl);\n\t\t\t\t\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*(hl + j) = '&';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsprintf(out, \";%s\", hl);\n\t\t\t\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((act[i]->nr_ini > 1) && DISPLAY_HORIZONTALLY(flags)) {\n\t\t\t\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", \"[...]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\n/*\n ***************************************************************************\n * Determine the time (expressed in seconds since the epoch) used as the\n * origin on X axis for SVG graphs. If S_F_SVG_ONE_DAY is set, then origin\n * will be the beginning of current day (00:00:00) else it will be the time\n * of the first sample collected.\n *\n * RETURNS:\n * Time origin on X axis (expressed in seconds since the epoch).\n ***************************************************************************\n */\ntime_t get_time_ref(void)\n{\n\tstruct tm ltm;\n\ttime_t t = record_hdr[2].ust_time;\n\n\tif (DISPLAY_ONE_DAY(flags)) {\n\t\tlocaltime_r(&t, &ltm);\n\n\t\t/* Move back to midnight */\n\t\tltm.tm_sec = ltm.tm_min = ltm.tm_hour = 0;\n\n\t\tt = mktime(&ltm);\n\t\tif (t != -1)\n\t\t\treturn t;\n\t}\n\n\treturn (time_t) record_hdr[2].ust_time;\n}\n\n/*\n ***************************************************************************\n * Save or restore position in file.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @action\tDO_SAVE to save position or DO_RESTORE to restore it.\n ***************************************************************************\n */\nvoid seek_file_position(int ifd, int action)\n{\n\tstatic off_t fpos = -1;\n\tstatic unsigned int save_cpu_nr = 0;\n\n\tif (action == DO_SAVE) {\n\t\t/* Save current file position */\n\t\tif ((fpos = lseek(ifd, 0, SEEK_CUR)) < 0) {\n\t\t\tperror(\"lseek\");\n\t\t\texit(2);\n\t\t}\n\t\tsave_cpu_nr = file_hdr.sa_cpu_nr;\n\t}\n\telse if (action == DO_RESTORE) {\n\t\t/* Rewind file */\n\t\tif ((fpos < 0) || (lseek(ifd, fpos, SEEK_SET) < fpos)) {\n\t\t\tperror(\"lseek\");\n\t\t\texit(2);\n\t\t}\n\t\tfile_hdr.sa_cpu_nr = save_cpu_nr;\n\t}\n}\n\n/*\n ***************************************************************************\n * Count number of different items in file. Save these numbers in fields\n * @item_list_sz of structure activity, and create the corresponding list\n * in field @item_list.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @file\tName of file being read.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @rectime\tStructure where timestamp (expressed in local time or\n *\t\tin UTC depending on whether options -T/-t have been\n *\t\tused or not) can be saved for current record.\n *\n * RETURNS:\n * 0 if no records are concerned in file, and 1 otherwise.\n ***************************************************************************\n */\nint count_file_items(int ifd, char *file, struct file_magic *file_magic,\n\t\t      struct file_activity *file_actlst, struct tstamp_ext *rectime)\n{\n\tint i, eosaf, rtype;\n\n\t/* Save current file position */\n\tseek_file_position(ifd, DO_SAVE);\n\n\t/* Init maximum number of items for each activity */\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (!HAS_LIST_ON_CMDLINE(act[i]->options)) {\n\t\t\tact[i]->item_list_sz = 0;\n\t\t}\n\t}\n\n\t/* Look for the first record that will be displayed */\n\tdo {\n\t\teosaf = read_next_sample(ifd, IGNORE_RESTART | IGNORE_COMMENT | SET_TIMESTAMPS,\n\t\t\t\t\t 0, file, &rtype, 0, file_magic, file_actlst,\n\t\t\t\t\t rectime, UEOF_CONT);\n\t\tif (eosaf)\n\t\t\t/* No record to display */\n\t\t\treturn 0;\n\t}\n\twhile ((datecmp(rectime, &tm_start, FALSE) < 0) ||\n\t       (datecmp(rectime, &tm_end, FALSE) > 0));\n\n\t/*\n\t * Read all the file and determine the maximum number\n\t * of items for each activity.\n\t */\n\tdo {\n\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\tif (!HAS_LIST_ON_CMDLINE(act[i]->options)) {\n\t\t\t\tif (act[i]->f_count_new) {\n\t\t\t\t\tact[i]->item_list_sz += (*act[i]->f_count_new)(act[i], 0);\n\t\t\t\t}\n\t\t\t\telse if (act[i]->nr[0] > act[i]->item_list_sz) {\n\t\t\t\t\tact[i]->item_list_sz = act[i]->nr[0];\n\t\t\t\t}\n\t\t\t\tif (HAS_PERSISTENT_VALUES(act[i]->options) &&\n\t\t\t\t\t(act[i]->item_list_sz < act[i]->nr_ini)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * For persistent (i.e. CPU related) activities,\n\t\t\t\t\t * structures must be allocated for every installed CPU,\n\t\t\t\t\t * even for offline CPU.\n\t\t\t\t\t * So item_list_sz cannot be smaller than nr_ini.\n\t\t\t\t\t */\n\t\t\t\t\tact[i]->item_list_sz = act[i]->nr_ini;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdo {\n\t\t\teosaf = read_next_sample(ifd, IGNORE_RESTART | IGNORE_COMMENT | SET_TIMESTAMPS,\n\t\t\t\t\t\t 0, file, &rtype, 0, file_magic, file_actlst,\n\t\t\t\t\t\t rectime, UEOF_CONT);\n\t\t\tif (eosaf || (datecmp(rectime, &tm_end, FALSE) > 0))\n\t\t\t\t/* End of data file or end time exceeded */\n\t\t\t\tbreak;\n\t\t}\n\t\twhile ((rtype == R_RESTART) || (rtype == R_COMMENT));\n\t}\n\twhile (!eosaf && !(datecmp(rectime, &tm_end, FALSE) > 0));\n\n\t/* Rewind file */\n\tseek_file_position(ifd, DO_RESTORE);\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Compute the number of rows that will contain SVG views. Usually only one\n * view is displayed on a row, unless the \"packed\" option has been entered.\n * Each activity selected may have several views. Moreover some activities\n * may have a number of items that varies within the file: In this case,\n * the number of views will depend on the highest number of items saved in\n * the file.\n *\n * IN:\n * @ifd\t\t\tFile descriptor of input file.\n * @file\t\tName of file being read.\n * @file_magic\t\tfile_magic structure filled with file magic header data.\n * @file_actlst\t\tList of (known or unknown) activities in file.\n * @rectime\t\tStructure where timestamp (expressed in local time or\n *\t\t\tin UTC depending on whether options -T/-t have been\n *\t\t\tused or not) can be saved for current record.\n * @views_per_row\tDefault number of views displayed on a single row.\n *\n * OUT:\n * @views_per_row\tMaximum number of views that will be displayed on a\n *\t\t\tsingle row (useful only if \"packed\" option entered).\n * @nr_act_dispd\tNumber of activities that will be displayed.\n *\t\t\tMay be 0.\n *\n * RETURNS:\n * Number of rows containing views, taking into account only activities\n * to be displayed, and selected period of time (options -s/-e).\n * Result may be 0.\n ***************************************************************************\n */\nint get_svg_graph_nr(int ifd, char *file, struct file_magic *file_magic,\n\t\t     struct file_activity *file_actlst, struct tstamp_ext *rectime,\n\t\t     int *views_per_row, int *nr_act_dispd)\n{\n\tint i, n, p, tot_g_nr = 0;\n\n\t*nr_act_dispd = 0;\n\n\t/* Count items in file */\n\tif (!count_file_items(ifd, file, file_magic, file_actlst, rectime))\n\t\t/* No record to display => No graph */\n\t\treturn 0;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\n\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\t\tif (!IS_SELECTED(act[p]->options) || !act[p]->g_nr)\n\t\t\tcontinue;\n\n\t\t(*nr_act_dispd)++;\n\n\t\tif (PACK_VIEWS(flags)) {\n\t\t\t/*\n\t\t\t * One activity = one row with multiple views.\n\t\t\t * Exception is A_MEMORY, for which one activity may be\n\t\t\t * displayed in two rows if both memory *and* swap utilization\n\t\t\t * have been selected.\n\t\t\t */\n\t\t\tif ((act[p]->id == A_MEMORY) &&\n\t\t\t    (DISPLAY_MEMORY(act[p]->opt_flags) && DISPLAY_SWAP(act[p]->opt_flags))) {\n\t\t\t\tn = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* One activity = multiple rows with only one view */\n\t\t\tn = act[p]->g_nr;\n\t\t}\n\t\tif (ONE_GRAPH_PER_ITEM(act[p]->options)) {\n\t\t\t n = n * act[p]->item_list_sz;\n\t\t}\n\t\tif (act[p]->g_nr > *views_per_row) {\n\t\t\t*views_per_row = act[p]->g_nr;\n\t\t}\n\n\t\ttot_g_nr += n;\n\t}\n\n\tif (*views_per_row > MAX_VIEWS_ON_A_ROW) {\n\t\t*views_per_row = MAX_VIEWS_ON_A_ROW;\n\t}\n\n\treturn tot_g_nr;\n}\n/*\n ***************************************************************************\n * Display *one* sample of statistics for one or several activities,\n * checking that all conditions are met before printing (time start, time\n * end, interval). Current record should be a record of statistics (R_STATS),\n * not a special one (R_RESTART or R_COMMENT).\n *\n * IN:\n * @curr\t\tIndex in array for current sample statistics.\n * @use_tm_start\tSet to non-zero if option -s has been used.\n * @use_tm_end\t\tSet to non-zero if option -e has been used.\n * @reset\t\tSet to TRUE if last_uptime should be reinitialized\n *\t\t\t(used in next_slice() function).\n * @parm\t\tPointer on parameters depending on output format\n * \t\t\t(eg.: number of tabulations to print).\n * @rectime\t\tStructure where timestamp (expressed in local time\n *\t\t\tor in UTC depending on whether options -T/-t have\n * \t\t\tbeen used or not) has been saved for current record.\n * @reset_cd\t\tTRUE if static cross_day variable should be reset.\n * @act_id\t\tActivity to display (only for formats where\n * \t\t\tactivities are displayed one at a time) or\n *\t\t\tALL_ACTIVITIES for all.\n *\n * OUT:\n * @cnt\t\t\tSet to 0 to indicate that no other lines of stats\n * \t\t\tshould be displayed.\n *\n * RETURNS:\n * 1 if stats have been successfully displayed.\n ***************************************************************************\n */\nint generic_write_stats(int curr, enum time_mode use_tm_start, enum time_mode use_tm_end,\n\t\t\tint reset, long *cnt, void *parm, struct tstamp_ext *rectime,\n\t\t\tint reset_cd, unsigned int act_id)\n{\n\tint i;\n\tunsigned long long dt, itv;\n\tchar cur_date[TIMESTAMP_LEN], cur_time[TIMESTAMP_LEN], *pre = NULL;\n\tstatic int cross_day = FALSE;\n\n\tif (reset_cd) {\n\t\t/*\n\t\t * See note in sar.c.\n\t\t * NB: Resetting cross_day is needed only if datafile\n\t\t * may be rewinded (eg. in db or ppc output formats).\n\t\t */\n\t\tcross_day = 0;\n\t}\n\n\t/*\n\t * Check time (1).\n\t * For this first check, we use the time interval entered on\n\t * the command line. This is equivalent to sar's option -i which\n\t * selects records at seconds as close as possible to the number\n\t * specified by the interval parameter.\n\t */\n\tif (!next_slice(record_hdr[2].uptime_cs, record_hdr[curr].uptime_cs,\n\t\t\treset, interval))\n\t\t/* Not close enough to desired interval */\n\t\treturn 0;\n\n\t/* Check if we are beginning a new day */\n\tif (use_tm_start && record_hdr[!curr].ust_time &&\n\t    (record_hdr[curr].ust_time > record_hdr[!curr].ust_time) &&\n\t    (record_hdr[curr].hour < record_hdr[!curr].hour)) {\n\t\tcross_day = TRUE;\n\t}\n\n\t/* Check time (2) */\n\tif (use_tm_end && (datecmp(rectime, &tm_end, cross_day) > 0)) {\n\t\t/* End time exceeded */\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\n\t/* Get interval values in 1/100th of a second */\n\tget_itv_value(&record_hdr[curr], &record_hdr[!curr], &itv);\n\n\tdt = itv / 100;\n\t/* Correct rounding error for dt */\n\tif ((itv % 100) >= 50) {\n\t\tdt++;\n\t}\n\n\t/* Set date and time strings for current record */\n\tset_record_timestamp_string(flags, cur_date, cur_time, TIMESTAMP_LEN, rectime);\n\n\tif (*fmt[f_position]->f_timestamp) {\n\t\tpre = (char *) (*fmt[f_position]->f_timestamp)(parm, F_BEGIN, cur_date, cur_time,\n\t\t\t\t\t\t\t       my_tzname, dt, &record_hdr[curr],\n\t\t\t\t\t\t\t       &file_hdr, flags);\n\t}\n\n\t/* Display statistics */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif ((act_id != ALL_ACTIVITIES) && (act[i]->id != act_id))\n\t\t\tcontinue;\n\n\t\tif ((TEST_MARKUP(fmt[f_position]->options) && CLOSE_MARKUP(act[i]->options)) ||\n\t\t    (IS_SELECTED(act[i]->options) && (act[i]->nr[curr] > 0)) ||\n\t\t    (format == F_RAW_OUTPUT)) {\n\n\t\t\tif (format == F_JSON_OUTPUT) {\n\t\t\t\t/* JSON output */\n\t\t\t\tint *tab = (int *) parm;\n\n\t\t\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr[curr] > 0)) {\n\n\t\t\t\t\tif (*fmt[f_position]->f_timestamp) {\n\t\t\t\t\t\t(*fmt[f_position]->f_timestamp)(tab, F_MAIN, cur_date, cur_time, NULL,\n\t\t\t\t\t\t\t\t\t\tdt, &record_hdr[curr],\n\t\t\t\t\t\t\t\t\t\t&file_hdr, flags);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*act[i]->f_json_print)(act[i], curr, *tab, itv);\n\t\t\t}\n\n\t\t\telse if (format == F_XML_OUTPUT) {\n\t\t\t\t/* XML output */\n\t\t\t\tint *tab = (int *) parm;\n\n\t\t\t\t(*act[i]->f_xml_print)(act[i], curr, *tab, itv);\n\t\t\t}\n\n\t\t\telse if (format == F_SVG_OUTPUT) {\n\t\t\t\t/* SVG output */\n\t\t\t\tstruct svg_parm *svg_p = (struct svg_parm *) parm;\n\n\t\t\t\tsvg_p->dt = (unsigned long) dt;\n\t\t\t\t(*act[i]->f_svg_print)(act[i], curr, F_MAIN, svg_p, itv, &record_hdr[curr]);\n\t\t\t}\n\n\t\t\telse if (format == F_RAW_OUTPUT) {\n\t\t\t\t/* Raw output */\n\t\t\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\t\t\tchar out[128];\n\n\t\t\t\t\tsprintf(out, \"# name; %s; nr_curr; %d; nr_alloc; %d; nr_ini; %d\\n\",\n\t\t\t\t\t\tact[i]->name, act[i]->nr[curr], act[i]->nr_allocated,\n\t\t\t\t\t\tact[i]->nr_ini);\n\t\t\t\t\tcprintf_s(IS_COMMENT, \"%s\", out);\n\t\t\t\t}\n\n\t\t\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr[curr] > 0)) {\n\t\t\t\t\t(*act[i]->f_raw_print)(act[i], pre, curr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (format == F_PCP_OUTPUT) {\n\t\t\t\t/* PCP archive */\n\t\t\t\tif (*act[i]->f_pcp_print) {\n\t\t\t\t\t(*act[i]->f_pcp_print)(act[i], curr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t/* Other output formats: db, ppc */\n\t\t\t\t(*act[i]->f_render)(act[i], (format == F_DB_OUTPUT), pre, curr, itv);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*fmt[f_position]->f_timestamp) {\n\t\t(*fmt[f_position]->f_timestamp)(parm, F_END, cur_date, cur_time, NULL, dt,\n\t\t\t\t\t\t&record_hdr[curr], &file_hdr, flags);\n\t}\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Read stats for current activity from file and print them.\n * Display at most <count> lines of stats (and possibly comments inserted\n * in file) located between two LINUX RESTART messages.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @curr\tIndex in array for current sample statistics.\n * @act_id\tActivity to display, or ~0 for all.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @file\tName of file being read.\n * @file_magic\tfile_magic structure filled with file magic header data.\n *\n * OUT:\n * @curr\tIndex in array for next sample statistics.\n * @cnt\t\tNumber of lines of stats remaining to write.\n * @eosaf\tSet to TRUE if EOF (end of file) has been reached.\n * @reset\tSet to TRUE if last_uptime variable should be\n * \t\treinitialized (used in next_slice() function).\n ***************************************************************************\n */\nvoid rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,\n\t\t       unsigned int act_id, int *reset, struct file_activity *file_actlst,\n\t\t       struct tstamp_ext *rectime, char *file,\n\t\t       struct file_magic *file_magic)\n{\n\tint rtype;\n\tint next, reset_cd;\n\n\t/* Rewind file */\n\tseek_file_position(ifd, DO_RESTORE);\n\n\tif (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {\n\t\t/* Print field list */\n\t\tlist_fields(act_id);\n\t}\n\n\t/*\n\t * Restore the first stats collected.\n\t * Used to compute the rate displayed on the first line.\n\t */\n\tcopy_structures(act, id_seq, record_hdr, !*curr, 2);\n\n\t*cnt  = count;\n\treset_cd = 1;\n\n\tdo {\n\t\t/* Display <count> lines of stats */\n\t\t*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,\n\t\t\t\t\t  *curr, file, &rtype, 0, file_magic,\n\t\t\t\t\t  file_actlst, rectime, UEOF_STOP);\n\n\t\tif (*eosaf || (rtype == R_RESTART))\n\t\t\tbreak;\n\n\t\tif (rtype != R_COMMENT) {\n\t\t\tnext = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,\n\t\t\t\t\t\t   NULL, rectime, reset_cd, act_id);\n\t\t\treset_cd = 0;\n\n\t\t\tif (next) {\n\t\t\t\t/*\n\t\t\t\t * next is set to 1 when we were close enough to desired interval.\n\t\t\t\t * In this case, the call to generic_write_stats() has actually\n\t\t\t\t * displayed a line of stats.\n\t\t\t\t */\n\t\t\t\t*curr ^= 1;\n\t\t\t\tif (*cnt > 0) {\n\t\t\t\t\t(*cnt)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*reset = FALSE;\n\t\t}\n\t}\n\twhile (*cnt);\n\n\t*reset = TRUE;\n}\n\n/*\n * **************************************************************************\n * Read stats for current activity from file and fill the buffers with SVG\n * code that will be output later.\n * At most <count> lines of stats are taken into account.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @curr\tIndex in array for current sample statistics.\n * @a\t\tCurrent activity.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @file\tName of file being read.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @parm\tSVG specific parameters.\n *\n * OUT:\n * @cnt\t\tNumber of lines of stats remaining to write.\n * @eosaf\tSet to TRUE if EOF (end of file) has been reached.\n * @reset\tSet to TRUE if last_uptime variable should be\n *\t\treinitialized (used in next_slice() function).\n * @parm\tSome members are updated.\n ***************************************************************************\n */\nvoid gen_curr_act_svg_code(int ifd, int *curr, long *cnt, int *eosaf, struct activity *a,\n\t\t\t   int *reset, struct file_activity *file_actlst,\n\t\t\t   struct tstamp_ext *rectime, char *file,\n\t\t\t   struct file_magic *file_magic, struct svg_parm *parm)\n{\n\tint rtype;\n\tint next, reset_cd;\n\n\t*cnt  = count;\n\treset_cd = 1;\n\n\tdo {\n\t\t*eosaf = read_next_sample(ifd, IGNORE_RESTART | IGNORE_COMMENT | SET_TIMESTAMPS,\n\t\t\t\t\t  *curr, file, &rtype, 0, file_magic,\n\t\t\t\t\t  file_actlst, rectime, UEOF_CONT);\n\t\tif (*eosaf)\n\t\t\tbreak;\n\n\t\tif (rtype == R_RESTART) {\n\t\t\tparm->restart = TRUE;\n\t\t\t*reset = TRUE;\n\t\t\t/* Go to next statistics record, if possible */\n\t\t\tdo {\n\t\t\t\t*eosaf = read_next_sample(ifd, IGNORE_RESTART | IGNORE_COMMENT | SET_TIMESTAMPS,\n\t\t\t\t\t\t\t  *curr, file, &rtype, 0, file_magic,\n\t\t\t\t\t\t\t  file_actlst, rectime, UEOF_CONT);\n\t\t\t}\n\t\t\twhile (!*eosaf && ((rtype == R_RESTART) || (rtype == R_COMMENT)));\n\n\t\t\t*curr ^= 1;\n\t\t}\n\t\telse if (rtype != R_COMMENT) {\n\n\t\t\tnext = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,\n\t\t\t\t\t\t   parm, rectime, reset_cd, a->id);\n\t\t\treset_cd = 0;\n\t\t\tif (next) {\n\t\t\t\t/*\n\t\t\t\t * next is set to 1 when we were close enough to desired interval.\n\t\t\t\t * In this case, the call to generic_write_stats() has actually\n\t\t\t\t * displayed a line of stats.\n\t\t\t\t */\n\t\t\t\tparm->restart = FALSE;\n\t\t\t\tparm->ust_time_end = record_hdr[*curr].ust_time;\n\t\t\t\t*curr ^= 1;\n\t\t\t\tif (*cnt > 0) {\n\t\t\t\t\t(*cnt)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*reset = FALSE;\n\t\t}\n\t}\n\twhile (!*eosaf && *cnt);\n\n\t*reset = TRUE;\n}\n\n/*\n ***************************************************************************\n * Read stats for current activity from file and output its SVG code.\n * At most <count> lines of stats are taken into account.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @curr\tIndex in array for current sample statistics.\n * @a\t\tCurrent activity.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @file\tName of file being read.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @g_nr\tNumber of graphs already displayed (for all activities).\n * @nr_act_dispd\n *\t\tTotal number of activities that will be displayed.\n * @mock_m\tSet to TRUE (MOCK_MODE) to prevent data from being printed\n *\t\tonto the screen. Used to compute the real SVG canvas height.\n *\t\tSet to FALSE (REAL_MODE) to indicate that SVG data can be\n *\t\tprinted (canvas height is now known).\n *\n * OUT:\n * @cnt\t\tNumber of lines of stats remaining to write.\n * @eosaf\tSet to TRUE if EOF (end of file) has been reached.\n * @reset\tSet to TRUE if last_uptime variable should be\n *\t\treinitialized (used in next_slice() function).\n * @g_nr\tTotal number of rows displayed (including current activity).\n *\t\tThis is the same as the number of views unless \"-O packed\"\n *\t\toption has been used.\n ***************************************************************************\n */\nvoid display_curr_act_graphs(int ifd, int *curr, long *cnt, int *eosaf,\n\t\t\t     struct activity *a, int *reset, struct file_activity *file_actlst,\n\t\t\t     struct tstamp_ext *rectime, char *file,\n\t\t\t     struct file_magic *file_magic, int *g_nr, int nr_act_dispd,\n\t\t\t     int mock_m)\n{\n\tstruct svg_parm parm;\n\n\t/* Rewind file */\n\tseek_file_position(ifd, DO_RESTORE);\n\n\t/*\n\t * Restore the first stats collected.\n\t * Originally used to compute the rate displayed on the first line.\n\t * Here, this is to plot the first point and start the graph.\n\t */\n\tcopy_structures(act, id_seq, record_hdr, !*curr, 2);\n\n\tparm.graph_no = *g_nr;\n\tparm.ust_time_ref = (unsigned long long) get_time_ref();\n\tparm.ust_time_first = record_hdr[2].ust_time;\n\tparm.restart = TRUE;\n\tparm.file_hdr = &file_hdr;\n\tparm.nr_act_dispd = nr_act_dispd;\n\tparm.hour = record_hdr[2].hour;\n\tparm.minute = record_hdr[2].minute;\n\tparm.second = record_hdr[2].second;\n\tstrcpy(parm.my_tzname, my_tzname);\n\tparm.mock = mock_m;\n\n\t/* Allocate graphs arrays */\n\t(*a->f_svg_print)(a, !*curr, F_BEGIN, &parm, 0, &record_hdr[!*curr]);\n\n\t/* Generate SVG code for current activity */\n\tgen_curr_act_svg_code(ifd, curr, cnt, eosaf, a, reset, file_actlst,\n\t\t\t      rectime, file, file_magic, &parm);\n\n\t/* Determine X axis end value */\n\tif (DISPLAY_ONE_DAY(flags) &&\n\t    (parm.ust_time_ref + (3600 * 24) > parm.ust_time_end)) {\n\t\tparm.ust_time_end = parm.ust_time_ref + (3600 * 24);\n\t}\n\n\t/*\n\t * Actually display graphs for current activity unless we are in MOCK_MODE,\n\t * in which case no data are printed but canvas height is calculated.\n\t */\n\t(*a->f_svg_print)(a, *curr, F_END, &parm, 0, &record_hdr[!*curr]);\n\n\t/* Update total number of rows already displayed */\n\t*g_nr = parm.graph_no;\n}\n\n/*\n * **************************************************************************\n * Generate SVG code for current file contents.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @file\tName of file being read.\n * @curr\tIndex in array for current sample statistics.\n * @g_nr\tNumber of rows already displayed (for all activities).\n * @nr_act_dispd\n *\t\tTotal number of activities that will be displayed.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @mock_m\tSet to TRUE (MOCK_MODE) to prevent data from being printed\n *\t\tonto the screen. Used to compute the real SVG canvas height.\n *\t\tSet to FALSE (REAL_MODE) to indicate that SVG data can be\n *\t\tprinted (canvas height is now known).\n *\n * OUT:\n * @cnt\t\tNumber of lines of stats remaining to write.\n * @eosaf\tSet to TRUE if EOF (end of file) has been reached.\n * @reset\tSet to TRUE if last_uptime variable should be\n *\t\treinitialized (used in next_slice() function).\n * @g_nr\tTotal number of rows displayed (including current activity).\n *\t\tThis is the same as the number of views unless \"-O packed\"\n *\t\toption has been used.\n ***************************************************************************\n */\nvoid gen_curr_file_svg_code(int ifd, char *file, int *curr, long *cnt, int *eosaf, int *reset,\n\t\t\t    int *g_nr, int nr_act_dispd, struct file_activity *file_actlst,\n\t\t\t    struct file_magic *file_magic, struct tstamp_ext *rectime, int mock_m)\n{\n\tint i, p;\n\n\t/* For each requested activity, generate SVG code */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\n\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\t\tif (!IS_SELECTED(act[p]->options) || !act[p]->g_nr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Reinitialize spmin/spmax buffers in REAL_MODE.\n\t\t * NB: In MOCK_MODE, this has already been done in allocate_structures().\n\t\t */\n\t\tif (mock_m == REAL_MODE) {\n\t\t\tinit_minmax_buf(act[p], 0, act[p]->nr_spalloc);\n\t\t}\n\n\t\tif (!HAS_MULTIPLE_OUTPUTS(act[p]->options)) {\n\t\t\tdisplay_curr_act_graphs(ifd, curr, cnt, eosaf, act[p], reset, file_actlst,\n\t\t\t\t\t\trectime, file, file_magic, g_nr, nr_act_dispd,\n\t\t\t\t\t\tmock_m);\n\t\t}\n\t\telse {\n\t\t\tunsigned int optf, msk;\n\n\t\t\toptf = act[p]->opt_flags;\n\n\t\t\tfor (msk = 1; msk < 0x100; msk <<= 1) {\n\t\t\t\tif ((act[p]->opt_flags & 0xff) & msk) {\n\t\t\t\t\tact[p]->opt_flags &= (0xffffff00 + msk);\n\t\t\t\t\tdisplay_curr_act_graphs(ifd, curr, cnt, eosaf, act[p],\n\t\t\t\t\t\t\t\treset, file_actlst, rectime, file,\n\t\t\t\t\t\t\t\tfile_magic, g_nr, nr_act_dispd,\n\t\t\t\t\t\t\t\tmock_m);\n\t\t\t\t\tact[p]->opt_flags = optf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display file contents in selected format (logic #1).\n * Logic #1:\tGrouped by record type. Sorted by timestamp.\n * Formats:\tXML, JSON, PCP\n *\n * NB: all statistics data will be sorted by timestamp.\n * Example: If stats for activities A and B at time t and t' have been collected,\n * the output will be:\n * stats for activity A at t\n * stats for activity B at t\n * stats for activity A at t'\n * stats for activity B at t'\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @file\tSystem activity data file name (name of file being read).\n * @file_actlst\tList of (known or unknown) activities in file.\n * @file_magic\tSystem activity file magic header.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @dparm\tPCP archive file name.\n ***************************************************************************\n */\nvoid logic1_display_loop(int ifd, char *file, struct file_activity *file_actlst,\n\t\t\t struct file_magic *file_magic, struct tstamp_ext *rectime, void *dparm)\n{\n\tint curr, rtype, tab = 0;\n\tint eosaf, next, reset = FALSE;\n\tint ign_flag = IGNORE_COMMENT + IGNORE_RESTART;\n\tlong cnt = 1;\n\tchar *pcparchive = (char *) dparm;\n\n\tif (CREATE_ITEM_LIST(fmt[f_position]->options)) {\n\t\t/* Count items in file (e.g. for PCP output) */\n\t\tif (!count_file_items(ifd, file, file_magic, file_actlst, rectime))\n\t\t\t/* No record to display */\n\t\t\treturn;\n\t}\n\t/* Save current file position */\n\tseek_file_position(ifd, DO_SAVE);\n\n\t/* Print header (eg. XML file header) */\n\tif (*fmt[f_position]->f_header) {\n\t\t(*fmt[f_position]->f_header)(&tab, F_BEGIN, pcparchive, my_tzname, file_magic,\n\t\t\t\t\t     &file_hdr, act, id_seq, file_actlst);\n\t}\n\n\tif (ORDER_ALL_RECORDS(fmt[f_position]->options)) {\n\t\tign_flag = IGNORE_NOTHING;\n\n\t\t/* RESTART and COMMENTS records will be immediately processed */\n\t\tif (*fmt[f_position]->f_restart) {\n\t\t\t(*fmt[f_position]->f_restart)(&tab, F_BEGIN, NULL, NULL, NULL,\n\t\t\t\t\t\t      &file_hdr, NULL);\n\t\t}\n\t\tif (DISPLAY_COMMENT(flags) && (*fmt[f_position]->f_comment)) {\n\t\t\t(*fmt[f_position]->f_comment)(&tab, F_BEGIN, NULL, NULL, NULL, NULL,\n\t\t\t\t\t\t      &file_hdr, NULL);\n\t\t}\n\t}\n\n\t/* Process activities */\n\tif (*fmt[f_position]->f_statistics) {\n\t\t(*fmt[f_position]->f_statistics)(&tab, F_BEGIN, act, id_seq);\n\t}\n\n\tdo {\n\t\t/*\n\t\t * If this record is a special (RESTART or COMMENT) one,\n\t\t * process it then try to read the next record in file.\n\t\t */\n\t\tdo {\n\t\t\teosaf = read_next_sample(ifd, ign_flag, 0, file,\n\t\t\t\t\t\t &rtype, tab, file_magic, file_actlst,\n\t\t\t\t\t\t rectime, UEOF_STOP);\n\t\t}\n\t\twhile (!eosaf && ((rtype == R_RESTART) || (rtype == R_COMMENT) ||\n\t\t\t(datecmp(rectime, &tm_start, FALSE) < 0) ||\n\t\t\t(datecmp(rectime, &tm_end, FALSE) > 0)));\n\n\t\tcurr = 1;\n\t\tcnt = count;\n\t\treset = TRUE;\n\n\t\tif (eosaf)\n\t\t\tbreak;\n\n\t\t/* Save the first stats collected. Used for example in next_slice() function */\n\t\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t\tdo {\n\t\t\teosaf = read_next_sample(ifd, ign_flag, curr, file,\n\t\t\t\t\t\t &rtype, tab, file_magic, file_actlst,\n\t\t\t\t\t\t rectime, UEOF_CONT);\n\n\t\t\tif (!eosaf && (rtype != R_COMMENT) && (rtype != R_RESTART)) {\n\t\t\t\tif (*fmt[f_position]->f_statistics) {\n\t\t\t\t\t(*fmt[f_position]->f_statistics)(&tab, F_MAIN, act, id_seq);\n\t\t\t\t}\n\n\t\t\t\t/* next is set to 1 when we were close enough to desired interval */\n\t\t\t\tnext = generic_write_stats(curr, tm_start.use, tm_end.use, reset,\n\t\t\t\t\t\t\t  &cnt, &tab, rectime, FALSE, ALL_ACTIVITIES);\n\n\t\t\t\tif (next) {\n\t\t\t\t\tcurr ^= 1;\n\t\t\t\t\tif (cnt > 0) {\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset = FALSE;\n\t\t\t}\n\t\t}\n\t\twhile (cnt && !eosaf && (rtype != R_RESTART));\n\n\t\tif (!cnt) {\n\t\t\t/* Go to next Linux restart, if possible */\n\t\t\tdo {\n\t\t\t\teosaf = read_next_sample(ifd, ign_flag, curr, file,\n\t\t\t\t\t\t\t &rtype, tab, file_magic, file_actlst,\n\t\t\t\t\t\t\t rectime, UEOF_CONT);\n\t\t\t}\n\t\t\twhile (!eosaf && (rtype != R_RESTART));\n\t\t}\n\t\treset = TRUE;\n\t}\n\twhile (!eosaf);\n\n\tif (*fmt[f_position]->f_statistics) {\n\t\t(*fmt[f_position]->f_statistics)(&tab, F_END, act, id_seq);\n\t}\n\n\tif (ign_flag == IGNORE_NOTHING) {\n\t\t/*\n\t\t * RESTART and COMMENT records have already been processed.\n\t\t * Display possible trailing data then terminate.\n\t\t */\n\t\tif (*fmt[f_position]->f_restart) {\n\t\t\t(*fmt[f_position]->f_restart)(&tab, F_END, NULL, NULL, NULL,\n\t\t\t\t\t\t      &file_hdr, NULL);\n\t\t}\n\t\tif (DISPLAY_COMMENT(flags) && (*fmt[f_position]->f_comment)) {\n\t\t\t(*fmt[f_position]->f_comment)(&tab, F_END, NULL, NULL, NULL, NULL,\n\t\t\t\t\t\t      &file_hdr, NULL);\n\t\t}\n\t\tgoto terminate;\n\t}\n\n\t/* Rewind file */\n\tseek_file_position(ifd, DO_RESTORE);\n\n\t/* Process now RESTART entries to display restart messages */\n\tif (*fmt[f_position]->f_restart) {\n\t\t(*fmt[f_position]->f_restart)(&tab, F_BEGIN, NULL, NULL, NULL, &file_hdr, NULL);\n\t}\n\n\tdo {\n\t\teosaf = read_next_sample(ifd, IGNORE_COMMENT, 0,\n\t\t\t\t\t file, &rtype, tab, file_magic, file_actlst,\n\t\t\t\t\t rectime, UEOF_CONT);\n\t}\n\twhile (!eosaf);\n\n\tif (*fmt[f_position]->f_restart) {\n\t\t(*fmt[f_position]->f_restart)(&tab, F_END, NULL, NULL, NULL, &file_hdr, NULL);\n\t}\n\n\t/* Rewind file */\n\tseek_file_position(ifd, DO_RESTORE);\n\n\t/* Last, process COMMENT entries to display comments */\n\tif (DISPLAY_COMMENT(flags)) {\n\t\tif (*fmt[f_position]->f_comment) {\n\t\t\t(*fmt[f_position]->f_comment)(&tab, F_BEGIN, NULL, NULL, NULL, NULL,\n\t\t\t\t\t\t      &file_hdr, NULL);\n\t\t}\n\t\tdo {\n\t\t\teosaf = read_next_sample(ifd, IGNORE_RESTART, 0,\n\t\t\t\t\t\t file, &rtype, tab, file_magic, file_actlst,\n\t\t\t\t\t\t rectime, UEOF_CONT);\n\t\t}\n\t\twhile (!eosaf);\n\n\t\tif (*fmt[f_position]->f_comment) {\n\t\t\t(*fmt[f_position]->f_comment)(&tab, F_END, NULL, NULL, NULL, NULL,\n\t\t\t\t\t\t      &file_hdr, NULL);\n\t\t}\n\t}\n\nterminate:\n\t/* Print header trailer */\n\tif (*fmt[f_position]->f_header) {\n\t\t(*fmt[f_position]->f_header)(&tab, F_END, pcparchive, my_tzname, file_magic,\n\t\t\t\t\t     &file_hdr, act, id_seq, file_actlst);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display file contents in selected format (logic #2).\n * Logic #2:\tGrouped by activity. Sorted by timestamp. Stop on RESTART\n * \t\trecords.\n * Formats:\tppc, CSV, raw\n *\n * NB: All statistics data for one activity will be displayed before\n * displaying stats for next activity. This is what sar does in its report.\n * Example: If stats for activities A and B at time t and t' have been collected,\n * the output will be:\n * stats for activity A at t\n * stats for activity A at t'\n * stats for activity B at t\n * stats for activity B at t'\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @file\tName of file being read.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @dparm\tUnused here.\n ***************************************************************************\n */\nvoid logic2_display_loop(int ifd, char *file, struct file_activity *file_actlst,\n\t\t\t struct file_magic *file_magic, struct tstamp_ext *rectime, void *dparm)\n{\n\tint i, p;\n\tint curr = 1, rtype;\n\tint eosaf = TRUE, reset;\n\tlong cnt = 1;\n\n\t/* Read system statistics from file */\n\tdo {\n\t\t/*\n\t\t * If this record is a special (RESTART or COMMENT) one, print it and\n\t\t * (try to) get another one.\n\t\t */\n\t\tdo {\n\t\t\tif (read_next_sample(ifd, IGNORE_NOTHING, 0,\n\t\t\t\t\t     file, &rtype, 0, file_magic, file_actlst,\n\t\t\t\t\t     rectime, UEOF_STOP))\n\t\t\t\t/* End of sa data file */\n\t\t\t\treturn;\n\t\t}\n\t\twhile ((rtype == R_RESTART) || (rtype == R_COMMENT) ||\n\t\t       (datecmp(rectime, &tm_start, FALSE) < 0) ||\n\t\t       (datecmp(rectime, &tm_end, FALSE) > 0));\n\n\t\t/* Save the first stats collected. Used for example in next_slice() function */\n\t\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t\t/* Set flag to reset last_uptime variable. Should be done after a LINUX RESTART record */\n\t\treset = TRUE;\n\n\t\t/* Save current file position */\n\t\tseek_file_position(ifd, DO_SAVE);\n\n\t\t/* Read and write stats located between two possible Linux restarts */\n\n\t\tif (DISPLAY_HORIZONTALLY(flags)) {\n\t\t\t/*\n\t\t\t * If stats are displayed horizontally, then all activities\n\t\t\t * are printed on the same line.\n\t\t\t */\n\t\t\trw_curr_act_stats(ifd, &curr, &cnt, &eosaf,\n\t\t\t\t\t  ALL_ACTIVITIES, &reset, file_actlst,\n\t\t\t\t\t  rectime, file, file_magic);\n\t\t}\n\t\telse {\n\t\t\t/* For each requested activity... */\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\t\t\tif (!id_seq[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\t\t\t\tif (!IS_SELECTED(act[p]->options))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!HAS_MULTIPLE_OUTPUTS(act[p]->options)) {\n\t\t\t\t\trw_curr_act_stats(ifd, &curr, &cnt, &eosaf,\n\t\t\t\t\t\t\t  act[p]->id, &reset, file_actlst,\n\t\t\t\t\t\t\t  rectime, file, file_magic);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tunsigned int optf, msk;\n\n\t\t\t\t\toptf = act[p]->opt_flags;\n\n\t\t\t\t\tfor (msk = 1; msk < 0x100; msk <<= 1) {\n\t\t\t\t\t\tif ((act[p]->opt_flags & 0xff) & msk) {\n\t\t\t\t\t\t\tact[p]->opt_flags &= (0xffffff00 + msk);\n\n\t\t\t\t\t\t\trw_curr_act_stats(ifd, &curr, &cnt, &eosaf,\n\t\t\t\t\t\t\t\t\t  act[p]->id, &reset, file_actlst,\n\t\t\t\t\t\t\t\t\t  rectime, file,\n\t\t\t\t\t\t\t\t\t  file_magic);\n\t\t\t\t\t\t\tact[p]->opt_flags = optf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!cnt) {\n\t\t\t/* Go to next Linux restart, if possible */\n\t\t\tdo {\n\t\t\t\teosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,\n\t\t\t\t\t\t\t curr, file, &rtype, 0, file_magic,\n\t\t\t\t\t\t\t file_actlst, rectime, UEOF_STOP);\n\t\t\t}\n\t\t\twhile (!eosaf && (rtype != R_RESTART));\n\t\t}\n\n\t\t/*\n\t\t * The last record we read was a RESTART one: Print it.\n\t\t * NB: Unlike COMMENTS records (which are displayed for each\n\t\t * activity), RESTART ones are only displayed once.\n\t\t */\n\t\tif (!eosaf && (record_hdr[curr].record_type == R_RESTART)) {\n\t\t\tprint_special_record(&record_hdr[curr], flags, &tm_start, &tm_end,\n\t\t\t\t\t     R_RESTART, ifd, rectime, file, 0, my_tzname,\n\t\t\t\t\t     file_magic, &file_hdr, act, fmt[f_position],\n\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t}\n\t}\n\twhile (!eosaf);\n}\n\n/*\n ***************************************************************************\n * Display file contents in SVG format.\n *\n * IN:\n * @ifd\t\tFile descriptor of input file.\n * @file\tName of file being read.\n * @file_actlst\tList of (known or unknown) activities in file.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @rectime\tStructure where timestamp (expressed in local time or in UTC\n *\t\tdepending on whether options -T/-t have been used or not) can\n *\t\tbe saved for current record.\n * @dparm\tUnused here.\n ***************************************************************************\n */\nvoid svg_display_loop(int ifd, char *file, struct file_activity *file_actlst,\n\t\t      struct file_magic *file_magic, struct tstamp_ext *rectime, void *dparm)\n{\n\tstruct svg_hdr_parm parm;\n\tint i, curr = 1, rtype, g_nr = 0, views_per_row = 1, nr_act_dispd;\n\tint eosaf = TRUE, reset = TRUE;\n\tlong cnt = 1;\n\tint action = F_END;\n\tint save_cpu_nr = file_hdr.sa_cpu_nr;\n\n\t/* Init custom colors palette */\n\tinit_custom_color_palette();\n\n\t/* Print SVG header */\n\tif (*fmt[f_position]->f_header) {\n\t\t(*fmt[f_position]->f_header)(&parm, F_BEGIN, file, NULL, file_magic,\n\t\t\t\t\t     &file_hdr, act, id_seq, file_actlst);\n\t}\n\n\t/*\n\t * Calculate the number of rows and the max number of views per row to display.\n\t * Result may be 0. In this case, \"No data\" will be displayed instead of the graphs.\n\t */\n\tget_svg_graph_nr(ifd, file, file_magic,\n\t\t         file_actlst, rectime, &views_per_row, &nr_act_dispd);\n\n\tparm.views_per_row = PACK_VIEWS(flags) ? views_per_row : 1;\n\tparm.nr_act_dispd = nr_act_dispd;\n\n\t/*\n\t* If this record is a special (RESTART or COMMENT) one, ignore it and\n\t* (try to) get another one.\n\t*/\n\tdo {\n\t\tif (read_next_sample(ifd, IGNORE_RESTART | IGNORE_COMMENT, 0,\n\t\t\t\t     file, &rtype, 0, file_magic, file_actlst,\n\t\t\t\t     rectime, UEOF_CONT))\n\t\t{\n\t\t\t/* End of sa data file: No views displayed */\n\t\t\tparm.graph_nr = 0;\n\t\t\taction += F_MAIN;\n\t\t\tgoto close_svg;\n\t\t}\n\t}\n\twhile ((rtype == R_RESTART) || (rtype == R_COMMENT) ||\n\t       (datecmp(rectime, &tm_start, FALSE) < 0) ||\n\t       (datecmp(rectime, &tm_end, FALSE) > 0));\n\n\t/* Save the first stats collected. Used for example in next_slice() function */\n\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t/* Save current file position */\n\tseek_file_position(ifd, DO_SAVE);\n\n\t/* Generate mock SVG file. Used to determine real canvas height */\n\tgen_curr_file_svg_code(ifd, file, &curr, &cnt, &eosaf, &reset, &g_nr, nr_act_dispd,\n\t\t\t       file_actlst, file_magic, rectime, MOCK_MODE);\n\n\t/*\n\t * If option \"-O height=...\" has been used then @graph_nr is NO LONGER a number\n\t * of rows but the SVG canvas height set on the command line.\n\t * Else use @g_nr, the real number of rows that have been displayed.\n\t */\n\tparm.graph_nr = SET_CANVAS_HEIGHT(flags) ? canvas_height : g_nr;\n\n\t/*\n\t * Restore nr of CPU that will be displayed in SVG title.\n\t * Indeed, during the first file reading in MOCK_MODE,\n\t * a RESTART record with a different nr of CPU may exist.\n\t * When we read it, we will overwrite previous value saved in file_hdr.\n\t */\n\tfile_hdr.sa_cpu_nr = save_cpu_nr;\n\n\t/*\n\t * We don't know if CPU related activities will be displayed or not.\n\t * But if it is the case, @nr_ini will be used in the loop\n\t * to process all CPUs. So reset their value to their original one.\n\t * Buffers should already be allocated.\n\t */\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (HAS_PERSISTENT_VALUES(act[i]->options) && (act[i]->nr_ini > 0)\n\t\t    && (act[i]->nr_ini > file_hdr.sa_cpu_nr)) {\n\t\t\tact[i]->nr_ini = file_hdr.sa_cpu_nr;\n\t\t}\n\t}\n\n\t/* Complete SVG header with real canvas height */\n\tif (*fmt[f_position]->f_header) {\n\t\t(*fmt[f_position]->f_header)(&parm, F_MAIN, file, NULL, file_magic,\n\t\t\t\t\t     &file_hdr, act, id_seq, file_actlst);\n\t}\n\n\t/* Reset variables to their original value */\n\tcurr = 1; g_nr = 0;\n\teosaf = TRUE, reset = TRUE;\n\tcnt = 1;\n\n\t/* Now really generate SVG code */\n\tgen_curr_file_svg_code(ifd, file, &curr, &cnt, &eosaf, &reset, &g_nr, nr_act_dispd,\n\t\t\t       file_actlst, file_magic, rectime, REAL_MODE);\n\n\t/* Real number of rows that have been displayed */\n\tparm.graph_nr = g_nr;\n\nclose_svg:\n\t/* Print SVG trailer */\n\tif (*fmt[f_position]->f_header) {\n\t\t(*fmt[f_position]->f_header)(&parm, action, file, NULL, file_magic,\n\t\t\t\t\t     &file_hdr, act, id_seq, file_actlst);\n\t}\n}\n\n/*\n ***************************************************************************\n * Check system activity datafile contents before displaying stats.\n * Display file header if option -H has been entered, else call function\n * corresponding to selected output format.\n *\n * IN:\n * @dfile\tSystem activity data file name.\n * @pcparchive\tPCP archive file name.\n ***************************************************************************\n */\nvoid read_stats_from_file(char dfile[], char pcparchive[])\n{\n\tstruct file_magic file_magic;\n\tstruct file_activity *file_actlst = NULL;\n\tstruct tstamp_ext rectime;\n\tint ifd, tab = 0;\n\n\t/* Prepare file for reading and read its headers */\n\tcheck_file_actlst(&ifd, dfile, act, flags, &file_magic, &file_hdr,\n\t\t\t  &file_actlst, id_seq, &endian_mismatch, &arch_64);\n\n\tif (DISPLAY_HDR_ONLY(flags)) {\n\t\tif (*fmt[f_position]->f_header) {\n\t\t\tif (format == F_PCP_OUTPUT) {\n\t\t\t\tdfile = pcparchive;\n\t\t\t}\n\t\t\t/* Display only data file header then exit */\n\t\t\t(*fmt[f_position]->f_header)(&tab, F_BEGIN + F_END, dfile, my_tzname,\n\t\t\t\t\t\t     &file_magic, &file_hdr, act, id_seq,\n\t\t\t\t\t\t     file_actlst);\n\t\t}\n\t\texit(0);\n\t}\n\n\t/* Perform required allocations */\n\tallocate_structures(act, flags);\n\n\tif (SET_LC_NUMERIC_C(fmt[f_position]->options)) {\n\t\t/* Use a decimal point */\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t}\n\n\t/* Call function corresponding to selected output format */\n\tif (*fmt[f_position]->f_display) {\n\t\t(*fmt[f_position]->f_display)(ifd, dfile, file_actlst, &file_magic,\n\t\t\t\t\t      &rectime, pcparchive);\n\t}\n\n\tclose(ifd);\n\n\tfree(file_actlst);\n\tfree_structures(act);\n}\n\n/*\n ***************************************************************************\n * Main entry to the sadf program\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint opt = 1, sar_options = 0;\n\tint day_offset = 0;\n\tint i, rc, p, q;\n\tchar dfile[MAX_FILE_LEN], pcparchive[MAX_FILE_LEN];\n\tchar *t, *v;\n\n\t/* Compute page shift in kB */\n\tget_kb_shift();\n\n\tdfile[0] = pcparchive[0] = '\\0';\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\ttm_start.use = tm_end.use = NO_TIME;\n\n\t/* Allocate and init activity bitmaps */\n\tallocate_bitmaps(act);\n\n\t/* Init some structures */\n\tinit_structures();\n\n\t/* Process options */\n\twhile (opt < argc) {\n\n\t\tif (!strcmp(argv[opt], \"-P\")) {\n\t\t\tif (parse_sa_P_opt(argv, &opt, &flags, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--dev=\", 6)) {\n\t\t\t/* Parse devices entered on the command line */\n\t\t\tp = get_activity_position(act, A_DISK, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_DEV_LEN, &opt, 6, NO_RANGE);\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--fs=\", 5)) {\n\t\t\t/* Parse devices entered on the command line */\n\t\t\tp = get_activity_position(act, A_FS, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_FS_LEN, &opt, 5, NO_RANGE);\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--iface=\", 8)) {\n\t\t\t/* Parse devices entered on the command line */\n\t\t\tp = get_activity_position(act, A_NET_DEV, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_IFACE_LEN, &opt, 8, NO_RANGE);\n\t\t\tq = get_activity_position(act, A_NET_EDEV, EXIT_IF_NOT_FOUND);\n\t\t\tact[q]->item_list = act[p]->item_list;\n\t\t\tact[q]->item_list_sz = act[p]->item_list_sz;\n\t\t\tact[q]->options |= AO_LIST_ON_CMDLINE;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--int=\", 6)) {\n\t\t\t/* Parse interrupts names entered on the command line */\n\t\t\tp = get_activity_position(act, A_IRQ, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_SA_IRQ_LEN, &opt, 6, NR_IRQS);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-s\")) {\n\t\t\t/* Get time start */\n\t\t\tif (parse_timestamp(argv, &opt, &tm_start, DEF_TMSTART, flags)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-e\")) {\n\t\t\t/* Get time end */\n\t\t\tif (parse_timestamp(argv, &opt, &tm_end, DEF_TMEND, flags)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t\topt++;\n\t\t}\n#endif\n\n\t\telse if (!strcmp(argv[opt], \"-O\")) {\n\t\t\t/* Parse output options */\n\t\t\tif (!argv[++opt] || sar_options) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tfor (t = strtok(argv[opt], \",\"); t; t = strtok(NULL, \",\")) {\n\t\t\t\tif (!strcmp(t, K_SKIP_EMPTY)) {\n\t\t\t\t\tflags |= S_F_SVG_SKIP;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_AUTOSCALE)) {\n\t\t\t\t\tflags |= S_F_SVG_AUTOSCALE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_ONEDAY)) {\n\t\t\t\t\tflags |= S_F_SVG_ONE_DAY;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_SHOWIDLE)) {\n\t\t\t\t\tflags |= S_F_SVG_SHOW_IDLE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_SHOWINFO)) {\n\t\t\t\t\tflags |= S_F_SVG_SHOW_INFO;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_DEBUG)) {\n\t\t\t\t\tflags |= S_F_DEBUG_MODE;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(t, K_HEIGHT, strlen(K_HEIGHT))) {\n\t\t\t\t\tv = t + strlen(K_HEIGHT);\n\t\t\t\t\tif (!strlen(v) || (strspn(v, DIGITS) != strlen(v))) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas_height = atoi(v);\n\t\t\t\t\tflags |= S_F_SVG_HEIGHT;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_PACKED)) {\n\t\t\t\t\tflags |= S_F_SVG_PACKED;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_SHOWTOC)) {\n\t\t\t\t\tflags |= S_F_SVG_SHOW_TOC;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_CUSTOMCOL)) {\n\t\t\t\t\tpalette = SVG_CUSTOM_COL_PALETTE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(t, K_BWCOL)) {\n\t\t\t\t\tpalette = SVG_BW_COL_PALETTE;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(t, K_PCPARCHIVE, strlen(K_PCPARCHIVE))) {\n\t\t\t\t\tv = t + strlen(K_PCPARCHIVE);\n\t\t\t\t\tstrncpy(pcparchive, v, sizeof(pcparchive));\n\t\t\t\t\tpcparchive[sizeof(pcparchive) - 1] = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(t, K_HZ, strlen(K_HZ))) {\n\t\t\t\t\tv = t + strlen(K_HZ);\n\t\t\t\t\tif (!strlen(v) || (strspn(v, DIGITS) != strlen(v))) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\tuser_hz = atoi(v);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if ((strlen(argv[opt]) > 1) &&\n\t\t\t (strlen(argv[opt]) < 4) &&\n\t\t\t !strncmp(argv[opt], \"-\", 1) &&\n\t\t\t (strspn(argv[opt] + 1, DIGITS) == (strlen(argv[opt]) - 1))) {\n\t\t\tif (dfile[0] || day_offset) {\n\t\t\t\t/* File already specified */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tday_offset = atoi(argv[opt++] + 1);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--\")) {\n\t\t\tsar_options = 1;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-m\")) {\n\t\t\tif (!argv[++opt] || !sar_options) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Parse sar's option -m */\n\t\t\tif (parse_sar_m_opt(argv, &opt, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-n\")) {\n\t\t\tif (!argv[++opt] || !sar_options) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Parse sar's option -n */\n\t\t\tif (parse_sar_n_opt(argv, &opt, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-q\")) {\n\t\t\tif (!sar_options) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\telse if (!argv[++opt]) {\n\t\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t\t}\n\t\t\t/* Parse option -q */\n\t\t\telse if (parse_sar_q_opt(argv, &opt, act)) {\n\t\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\t/* Other options not previously tested */\n\t\t\tif (sar_options) {\n\t\t\t\tif ((rc = parse_sar_opt(argv, &opt, act, &flags, C_SADF)) != 0) {\n\t\t\t\t\tif (rc == 1) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tfor (i = 1; *(argv[opt] + i); i++) {\n\n\t\t\t\t\tswitch (*(argv[opt] + i)) {\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tflags |= S_F_COMMENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_CONV_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_DB_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'g':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_SVG_OUTPUT;\n\t\t\t\t\t\tflags |= S_F_MINMAX;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tflags |= S_F_HORIZONTALLY;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tflags |= S_F_HDR_ONLY;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'j':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_JSON_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_PCP_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_PPC_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_RAW_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tflags |= S_F_LOCAL_TIME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tflags |= S_F_TRUE_TIME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tflags |= S_F_SEC_EPOCH;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tif (format) {\n\t\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat = F_XML_OUTPUT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *sadf_env[] = {ENV_COLORS_PALETTE,\n\t\t\t\t\t\t\t\t\t    ENV_TIME_DEFTM};\n#define SADF_ENV_NR\t2\n\t\t\t\t\t\t\t\tprint_version(sadf_env, SADF_ENV_NR);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\t/* Get data file name */\n\t\telse if (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\tif (dfile[0] || day_offset) {\n\t\t\t\t/* File already specified */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Write data to file */\n\t\t\tstrncpy(dfile, argv[opt++], sizeof(dfile));\n\t\t\tdfile[sizeof(dfile) - 1] = '\\0';\n\t\t\t/* Check if this is an alternate directory for sa files */\n\t\t\tcheck_alt_sa_dir(dfile, 0, -1);\n\t\t}\n\n\t\telse if (interval < 0) {\n\t\t\t/* Get interval */\n\t\t\tif (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t/* Get count value */\n\t\t\tif (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\t/* Count parameter already set */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif (count < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\telse if (!count) {\n\t\t\t\tcount = -1;\t/* To generate a report continuously */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Init color strings */\n\tinit_colors();\n\n\tif (USE_OPTION_A(flags)) {\n\t\t/* Set -P ALL -I ALL if needed */\n\t\tset_bitmaps(act, &flags);\n\t}\n\n\t/* sadf reads current daily data file by default */\n\tif (!dfile[0]) {\n\t\tset_default_file(dfile, day_offset, -1);\n\t}\n\n\t/* PCP mode: If no archive file specified then use the name of the daily data file */\n\tif (!pcparchive[0] && (format == F_PCP_OUTPUT)) {\n\t\tstrcpy(pcparchive, dfile);\n\t}\n\n#ifndef HAVE_PCP\n\tif (format == F_PCP_OUTPUT) {\n\t\tfprintf(stderr, _(\"PCP support not compiled in\\n\"));\n\t\texit(1);\n\t}\n#endif\n\n\tif (check_time_limits(&tm_start, &tm_end)) {\n\t\tusage(argv[0]);\n\t}\n\n\tif (DISPLAY_PRETTY(flags)) {\n\t\tdm_major = get_devmap_major();\n\t}\n\n\t/* Options -T, -t and -U are mutually exclusive */\n\tif ((PRINT_LOCAL_TIME(flags) + PRINT_TRUE_TIME(flags) +\n\t    PRINT_SEC_EPOCH(flags)) > 1) {\n\t\tusage(argv[0]);\n\t}\n\n\t/* Get timezone */\n\tif (PRINT_LOCAL_TIME(flags)) {\n\t\ttzset();\n\t\tstrncpy(my_tzname, tzname[0], TZNAME_LEN);\n\t\tmy_tzname[TZNAME_LEN - 1] = '\\0';\n\t}\n\n\t/*\n\t * Display all the contents of the daily data file if the count parameter\n\t * was not set on the command line.\n\t */\n\tif (!count) {\n\t\tcount = -1;\n\t}\n\n\t/* Default is CPU activity */\n\tselect_default_activity(act);\n\n\t/* Check options consistency with selected output format. Default is PPC display */\n\tcheck_format_options();\n\n\tif (interval < 0) {\n\t\tinterval = 1;\n\t}\n\n\tif (format == F_CONV_OUTPUT) {\n\t\t/* Convert file to current format */\n\t\tconvert_file(dfile, act);\n\t}\n\telse {\n\t\t/* Read stats from file */\n\t\tread_stats_from_file(dfile, pcparchive);\n\t}\n\n\t/* Free bitmaps */\n\tfree_bitmaps(act);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "sadf.h",
          "type": "blob",
          "size": 7.16015625,
          "content": "/*\n * sadf: System activity data formatter\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _SADF_H\n#define _SADF_H\n\n#include \"sa.h\"\n\n/* DTD version for XML output */\n#define XML_DTD_VERSION\t\"3.17\"\n\n/* Various constants */\nenum {\n\tDO_SAVE\t\t= 0,\n\tDO_RESTORE\t= 1\n};\n\n#define IGNORE_NOTHING\t\t0\n#define IGNORE_RESTART\t\t1\n#define DONT_READ_CPU_NR\t2\n#define IGNORE_COMMENT\t\t4\n#define SET_TIMESTAMPS\t\t8\n\n/*\n ***************************************************************************\n * Output format identification values.\n ***************************************************************************\n */\n\n/*\n * Indicate that a decimal point should be used to make output\n * locale independent.\n */\n#define FO_LC_NUMERIC_C\t\t0x01\n\n/*\n * Indicate that option -H may be used with corresponding format\n * so that only the header is displayed.\n */\n#define FO_HEADER_ONLY\t\t0x02\n\n/* Unused: 0x04 */\n\n/*\n * Indicate that timestamp can be displayed in local time instead of UTC\n * if option -T or -t has been used.\n */\n#define FO_LOCAL_TIME\t\t0x08\n\n/*\n * Indicate that all activities will be displayed horizontally\n * if option -h is used.\n */\n#define FO_HORIZONTALLY\t\t0x10\n\n/*\n * Indicate that the timestamp can be displayed in seconds since the epoch\n * if option -U has been used.\n */\n#define FO_SEC_EPOCH\t\t0x20\n\n/*\n * Indicate that the list of fields should be displayed before the first\n * line of statistics.\n */\n#define FO_FIELD_LIST\t\t0x40\n\n/*\n * Indicate that flag AO_CLOSE_MARKUP (set for activities that need it)\n * should be taken into account for this output format.\n */\n#define FO_TEST_MARKUP\t\t0x80\n\n/*\n * Indicate that timestamp cannot be displayed in the original local time\n * of the data file creator.\n */\n#define FO_NO_TRUE_TIME\t\t0x100\n\n/*\n * Indicate that the number of different items should be counted and\n * a list created (see @item_list and @item_list_sz in struct activity).\n */\n#define FO_ITEM_LIST\t\t0x200\n\n/*\n * Indicate that all the records, including RESTART and COMMENT ones,\n * should be displayed in order of time.\n */\n#define FO_FULL_ORDER\t\t0x400\n\n#define SET_LC_NUMERIC_C(m)\t\t(((m) & FO_LC_NUMERIC_C)\t== FO_LC_NUMERIC_C)\n#define ACCEPT_HEADER_ONLY(m)\t\t(((m) & FO_HEADER_ONLY)\t\t== FO_HEADER_ONLY)\n#define ACCEPT_LOCAL_TIME(m)\t\t(((m) & FO_LOCAL_TIME)\t\t== FO_LOCAL_TIME)\n#define ACCEPT_HORIZONTALLY(m)\t\t(((m) & FO_HORIZONTALLY)\t== FO_HORIZONTALLY)\n#define ACCEPT_SEC_EPOCH(m)\t\t(((m) & FO_SEC_EPOCH)\t\t== FO_SEC_EPOCH)\n#define DISPLAY_FIELD_LIST(m)\t\t(((m) & FO_FIELD_LIST)\t\t== FO_FIELD_LIST)\n#define TEST_MARKUP(m)\t\t\t(((m) & FO_TEST_MARKUP)\t\t== FO_TEST_MARKUP)\n#define REJECT_TRUE_TIME(m)\t\t(((m) & FO_NO_TRUE_TIME)\t== FO_NO_TRUE_TIME)\n#define CREATE_ITEM_LIST(m)\t\t(((m) & FO_ITEM_LIST)\t\t== FO_ITEM_LIST)\n#define ORDER_ALL_RECORDS(m)\t\t(((m) & FO_FULL_ORDER)\t\t== FO_FULL_ORDER)\n\n\n/*\n ***************************************************************************\n * Various function prototypes\n ***************************************************************************\n */\n\nvoid convert_file\n\t(char [], struct activity *[]);\n\n/*\n * Prototypes used to display restart messages\n */\n__printf_funct_t print_db_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_ppc_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_xml_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_json_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_raw_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_pcp_restart\n\t(int *, int, char *, char *, char *, struct file_header *, struct record_header *);\n\n/*\n * Prototypes used to display comments\n */\n__printf_funct_t print_db_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_ppc_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_xml_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_json_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_raw_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *, struct record_header *);\n__printf_funct_t print_pcp_comment\n\t(int *, int, char *, char *, char *, char *, struct file_header *, struct record_header *);\n\n/*\n * Prototypes used to display the statistics part of the report\n */\n__printf_funct_t print_xml_statistics\n\t(int *, int, struct activity * [], unsigned int []);\n__printf_funct_t print_json_statistics\n\t(int *, int, struct activity * [], unsigned int []);\n__printf_funct_t print_pcp_statistics\n\t(int *, int, struct activity * [], unsigned int []);\n\n/*\n * Prototypes used to display the timestamp part of the report\n */\n__tm_funct_t print_db_timestamp\n\t(void *, int, char *, char *, char *, unsigned long long,\n\t struct record_header *, struct file_header *, unsigned int);\n__tm_funct_t print_ppc_timestamp\n\t(void *, int, char *, char *, char *, unsigned long long,\n\t struct record_header *, struct file_header *, unsigned int);\n__tm_funct_t print_xml_timestamp\n\t(void *, int, char *, char *, char *, unsigned long long,\n\t struct record_header *, struct file_header *, unsigned int);\n__tm_funct_t print_json_timestamp\n\t(void *, int, char *, char *, char *, unsigned long long,\n\t struct record_header *, struct file_header *, unsigned int);\n__tm_funct_t print_raw_timestamp\n\t(void *, int, char *, char *, char *, unsigned long long,\n\t struct record_header *, struct file_header *, unsigned int);\n__tm_funct_t print_pcp_timestamp\n\t(void *, int, char *, char *, char *, unsigned long long,\n\t struct record_header *, struct file_header *, unsigned int);\n\n/*\n * Prototypes used to display the report header\n */\n__printf_funct_t print_xml_header\n\t(void *, int, char *, char *, struct file_magic *, struct file_header *,\n\t struct activity * [], unsigned int [], struct file_activity *);\n__printf_funct_t print_json_header\n\t(void *, int, char *, char *, struct file_magic *, struct file_header *,\n\t struct activity * [], unsigned int [], struct file_activity *);\n__printf_funct_t print_hdr_header\n\t(void *, int, char *, char *, struct file_magic *, struct file_header *,\n\t struct activity * [], unsigned int [], struct file_activity *);\n__printf_funct_t print_svg_header\n\t(void *, int, char *, char *, struct file_magic *, struct file_header *,\n\t struct activity * [], unsigned int [], struct file_activity *);\n__printf_funct_t print_pcp_header\n\t(void *, int, char *, char *, struct file_magic *, struct file_header *,\n\t struct activity * [], unsigned int [], struct file_activity *);\n\n/*\n * Main display functions\n */\nvoid logic1_display_loop\n\t(int, char *, struct file_activity *, struct file_magic *,\n\t struct tstamp_ext *, void *);\nvoid logic2_display_loop\n\t(int, char *, struct file_activity *, struct file_magic *,\n\t struct tstamp_ext *, void *);\nvoid svg_display_loop\n\t(int, char *, struct file_activity *, struct file_magic *,\n\t struct tstamp_ext *, void *);\n\n#endif  /* _SADF_H */\n"
        },
        {
          "name": "sadf_misc.c",
          "type": "blob",
          "size": 53.64453125,
          "content": "/*\n * sadf_misc.c: Functions used by sadf to display special records\n * (C) 2011-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\n#include \"sadf.h\"\n#include \"pcp_def_metrics.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef HAVE_PCP\n#include <pcp/pmapi.h>\n#include <pcp/import.h>\n#endif\n\nextern uint64_t flags;\nextern char *seps[];\n\nextern int palette;\nextern unsigned int svg_colors[][SVG_COL_PALETTE_SIZE];\n\n/*\n ***************************************************************************\n * Flush data to PCP archive.\n *\n * IN:\n * @record_hdr\tRecord header for current sample.\n * @flags\tFlags for common options.\n ***************************************************************************\n */\nvoid pcp_write_data(struct record_header *record_hdr, unsigned int flags)\n{\n#ifdef HAVE_PCP\n\tint rc;\n\tunsigned long long utc_sec = record_hdr->ust_time;\n\n\t/* Write data to PCP archive */\n\tif ((rc = pmiWrite(utc_sec, 0)) < 0) {\n\t\tfprintf(stderr, \"PCP: pmiWrite: %s\\n\", pmiErrStr(rc));\n\t\texit(4);\n\t}\n#endif\n}\n\n/*\n ***************************************************************************\n * Display restart messages (database and ppc formats).\n *\n * IN:\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @sep\t\tCharacter used as separator.\n * @file_hdr\tSystem activity file standard header.\n ***************************************************************************\n */\nvoid print_dbppc_restart(char *cur_date, char *cur_time, char *my_tz, char sep,\n\t\t\t struct file_header *file_hdr)\n{\n\tprintf(\"%s%c-1%c\", file_hdr->sa_nodename, sep, sep);\n\tif (strlen(cur_date)) {\n\t\tprintf(\"%s \", cur_date);\n\t}\n\tprintf(\"%s\", cur_time);\n\tif (strlen(cur_date)) {\n\t\tprintf(\" %s\", PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t      : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t\t: \"UTC\"));\n\t}\n\tprintf(\"%cLINUX-RESTART\\t(%u CPU)\\n\",\n\t       sep, file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n}\n\n/*\n ***************************************************************************\n * Display restart messages (ppc format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_db_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t  char *my_tz, struct file_header *file_hdr,\n\t\t\t\t  struct record_header *record_hdr)\n{\n\t/* Actions F_BEGIN and F_END ignored */\n\tif (action == F_MAIN) {\n\t\tprint_dbppc_restart(cur_date, cur_time, my_tz, ';', file_hdr);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display restart messages (database format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_ppc_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\t/* Actions F_BEGIN and F_END ignored */\n\tif (action == F_MAIN) {\n\t\tprint_dbppc_restart(cur_date, cur_time, my_tz, '\\t', file_hdr);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display restart messages (XML format).\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n *\n * OUT:\n * @tab\t\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_xml_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\tif (action & F_BEGIN) {\n\t\txprintf((*tab)++, \"<restarts>\");\n\t}\n\tif (action & F_MAIN) {\n\t\txprintf(*tab, \"<boot date=\\\"%s\\\" time=\\\"%s\\\" tz=\\\"%s\\\" cpu_count=\\\"%d\\\"/>\",\n\t\t\tcur_date, cur_time,\n\t\t\tPRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t: (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t  : \"UTC\"),\n\t\t\tfile_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\t}\n\tif (action & F_END) {\n\t\txprintf(--(*tab), \"</restarts>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display restart messages (JSON format).\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n *\n * OUT:\n * @tab\t\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_json_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t    char *my_tz, struct file_header *file_hdr,\n\t\t\t\t    struct record_header *record_hdr)\n{\n\tstatic int sep = FALSE;\n\n\tif (action & F_BEGIN) {\n\t\tprintf(\",\\n\");\n\t\txprintf((*tab)++, \"\\\"restarts\\\": [\");\n\t}\n\tif (action & F_MAIN) {\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\txprintf((*tab)++, \"{\");\n\t\txprintf(*tab, \"\\\"boot\\\": {\\\"date\\\": \\\"%s\\\", \\\"time\\\": \\\"%s\\\", \\\"tz\\\": \\\"%s\\\", \\\"cpu_count\\\": %d}\",\n\t\t\tcur_date, cur_time,\n\t\t\tPRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t: (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t  : \"UTC\"),\n\t\t\tfile_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\t\txprintf0(--(*tab), \"}\");\n\t\tsep = TRUE;\n\t}\n\tif (action & F_END) {\n\t\tif (sep) {\n\t\t\tprintf(\"\\n\");\n\t\t\tsep = FALSE;\n\t\t}\n\t\txprintf0(--(*tab), \"]\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display restart messages (raw format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_raw_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\t/* Actions F_BEGIN and F_END ignored */\n\tif (action == F_MAIN) {\n\t\tprintf(\"%s\", cur_time);\n\t\tif (strlen(cur_date)) {\n\t\t\tprintf(\" %s\", PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t\t      : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t\t\t: \"UTC\"));\n\t\t}\n\t\tprintf(\"; LINUX-RESTART (%u CPU)\\n\",\n\t\t       file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display restart messages (PCP format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message (unused here).\n * @cur_time\tTime string of current restart message (unused here).\n * @my_tz\tCurrent timezone (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header.\n ***************************************************************************\n */\n__printf_funct_t print_pcp_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n#ifdef HAVE_PCP\n\tstatic int def_metrics = FALSE;\n\tchar buf[64];\n\n\tif (action & F_BEGIN) {\n\t\tif (!def_metrics) {\n\t\t\tpmiAddMetric(\"system.restart.count\",\n\t\t\t\t     PM_IN_NULL, PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_DISCRETE,\n\t\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\t\tpmiAddMetric(\"system.restart.ncpu\",\n\t\t\t\t     PM_IN_NULL, PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_DISCRETE,\n\t\t\t\t     pmiUnits(0, 0, 1, 0, 0, PM_COUNT_ONE));\n\n\t\t\tdef_metrics = TRUE;\n\t\t}\n\t}\n\tif (action & F_MAIN) {\n\t\tpmiPutValue(\"system.restart.count\", NULL, \"1\");\n\n\t\tsnprintf(buf, sizeof(buf), \"%u\",\n\t\t\t file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\t\tpmiPutValue(\"system.restart.ncpu\", NULL, buf);\n\n\t\t/* Write data to PCP archive */\n\t\tpcp_write_data(record_hdr, flags);\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display comments (database and ppc formats).\n *\n * IN:\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @comment\tComment to display.\n * @sep\t\tCharacter used as separator.\n * @file_hdr\tSystem activity file standard header.\n ***************************************************************************\n */\nvoid print_dbppc_comment(char *cur_date, char *cur_time, char *my_tz, char *comment,\n\t\t\t char sep, struct file_header *file_hdr)\n{\n\tprintf(\"%s%c-1%c\", file_hdr->sa_nodename, sep, sep);\n\tif (strlen(cur_date)) {\n\t\tprintf(\"%s \", cur_date);\n\t}\n\tprintf(\"%s\", cur_time);\n\tif (strlen(cur_date)) {\n\t\tprintf(\" %s\", PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t      : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t                                : \"UTC\"));\n\t}\n\tprintf(\"%cCOM %s\\n\", sep, comment);\n}\n\n/*\n ***************************************************************************\n * Display comments (database format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_db_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t  char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t  struct record_header *record_hdr)\n{\n\t/* Actions F_BEGIN and F_END ignored */\n\tif (action & F_MAIN) {\n\t\tprint_dbppc_comment(cur_date, cur_time, my_tz, comment, ';', file_hdr);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display comments (ppc format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_ppc_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\t/* Actions F_BEGIN and F_END ignored */\n\tif (action & F_MAIN) {\n\t\tprint_dbppc_comment(cur_date, cur_time, my_tz, comment, '\\t', file_hdr);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display comments (XML format).\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current comment.\n * @cur_time\tTime string of current comment.\n * @my_tz\tCurrent timezone.\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header (unused here).\n * @record_hdr\tCurrent record header (unused here).\n *\n * OUT:\n * @tab\t\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_xml_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\tif (action & F_BEGIN) {\n\t\txprintf((*tab)++, \"<comments>\");\n\t}\n\tif (action & F_MAIN) {\n\t\txprintf(*tab, \"<comment date=\\\"%s\\\" time=\\\"%s\\\" tz=\\\"%s\\\" com=\\\"%s\\\"/>\",\n\t\t\tcur_date, cur_time,\n\t\t\tPRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t: (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t  : \"UTC\"),\n\t\t\tcomment);\n\t}\n\tif (action & F_END) {\n\t\txprintf(--(*tab), \"</comments>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display comments (JSON format).\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current comment.\n * @cur_time\tTime string of current comment.\n * @my_tz\tCurrent timezone.\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header (unused here).\n * @record_hdr\tCurrent record header (unused here).\n *\n * OUT:\n * @tab\t\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_json_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t    char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t    struct record_header *record_hdr)\n{\n\tstatic int sep = FALSE;\n\n\tif (action & F_BEGIN) {\n\t\tprintf(\",\\n\");\n\t\txprintf((*tab)++, \"\\\"comments\\\": [\");\n\t}\n\tif (action & F_MAIN) {\n\t\tif (sep) {\n\t\t\tprintf(\",\\n\");\n\t\t}\n\t\txprintf((*tab)++, \"{\");\n\t\txprintf(*tab,\n\t\t\t\"\\\"comment\\\": {\\\"date\\\": \\\"%s\\\", \\\"time\\\": \\\"%s\\\", \"\n\t\t\t\"\\\"tz\\\": \\\"%s\\\", \\\"com\\\": \\\"%s\\\"}\",\n\t\t\tcur_date, cur_time,\n\t\t\tPRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t: (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t  : \"UTC\"),\n\t\t\tcomment);\n\t\txprintf0(--(*tab), \"}\");\n\t\tsep = TRUE;\n\t}\n\tif (action & F_END) {\n\t\tif (sep) {\n\t\t\tprintf(\"\\n\");\n\t\t\tsep = FALSE;\n\t\t}\n\t\txprintf0(--(*tab), \"]\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display comments (raw format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message.\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone.\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header (unused here).\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_raw_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\t/* Actions F_BEGIN and F_END ignored */\n\tif (action & F_MAIN) {\n\t\tprintf(\"%s\", cur_time);\n\t\tif (strlen(cur_date)) {\n\t\t\tprintf(\" %s\",\n\t\t\t       PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t       : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t\t : \"UTC\"));\n\t\t}\n\t\tprintf(\"; COM %s\\n\", comment);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display comments (PCP format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current restart message (unused here).\n * @cur_time\tTime string of current restart message (unused here).\n * @my_tz\tCurrent timezone (unused here).\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header (unused here).\n * @record_hdr\tCurrent record header.\n ***************************************************************************\n */\n__printf_funct_t print_pcp_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n#ifdef HAVE_PCP\n\tstatic int def_metrics = FALSE;\n\n\tif (action & F_BEGIN) {\n\t\tif (!def_metrics) {\n\t\t\tpmiAddMetric(\"system.comment.value\",\n\t\t\t\t     PM_IN_NULL, PM_TYPE_STRING, PM_INDOM_NULL, PM_SEM_DISCRETE,\n\t\t\t\t     pmiUnits(0, 0, 0, 0, 0, 0));\n\n\t\t\tdef_metrics = TRUE;\n\t\t}\n\t}\n\tif (action & F_MAIN) {\n\t\tpmiPutValue(\"system.comment.value\", NULL, comment);\n\n\t\t/* Write data to PCP archive */\n\t\tpcp_write_data(record_hdr, flags);\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display the \"statistics\" part of the report (XML format).\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tAction expected from current function.\n * @act\t\tArray of activities (unused here).\n * @id_seq\tActivity sequence (unused here).\n *\n * OUT:\n * @tab\t\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_xml_statistics(int *tab, int action, struct activity *act[],\n\t\t\t\t      unsigned int id_seq[])\n{\n\tif (action & F_BEGIN) {\n\t\txprintf((*tab)++, \"<statistics>\");\n\t}\n\tif (action & F_END) {\n\t\txprintf(--(*tab), \"</statistics>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display the \"statistics\" part of the report (JSON format).\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tAction expected from current function.\n * @act\t\tArray of activities (unused here).\n * @id_seq\tActivity sequence (unused here).\n *\n * OUT:\n * @tab\t\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_json_statistics(int *tab, int action, struct activity *act[],\n\t\t\t\t       unsigned int id_seq[])\n{\n\tstatic int sep = FALSE;\n\n\tif (action & F_BEGIN) {\n\t\tprintf(\",\\n\");\n\t\txprintf((*tab)++, \"\\\"statistics\\\": [\");\n\t}\n\tif (action & F_MAIN) {\n\t\tif (sep) {\n\t\t\txprintf(--(*tab), \"},\");\n\t\t}\n\t\txprintf((*tab)++, \"{\");\n\t\tsep = TRUE;\n\t}\n\tif (action & F_END) {\n\t\tif (sep) {\n\t\t\txprintf(--(*tab), \"}\");\n\t\t\tsep = FALSE;\n\t\t}\n\t\txprintf0(--(*tab), \"]\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display the \"statistics\" part of the report (PCP format).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function.\n * @act\t\tArray of activities.\n * @id_seq\tActivity sequence.\n ***************************************************************************\n */\n__printf_funct_t print_pcp_statistics(int *tab, int action, struct activity *act[],\n\t\t\t\t      unsigned int id_seq[])\n{\n#ifdef HAVE_PCP\n\tif (action & F_BEGIN) {\n\t\tint i, p;\n\n\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\tif (!id_seq[i])\n\t\t\t\tcontinue;\t/* Activity not in file */\n\n\t\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\t\t\tif (!IS_SELECTED(act[p]->options))\n\t\t\t\tcontinue;\t/* Activity not selected */\n\n\t\t\tswitch (act[p]->id) {\n\n\t\t\t\tcase A_CPU:\n\t\t\t\tcase A_PWR_CPU:\n\t\t\t\tcase A_NET_SOFT:\n\t\t\t\t\tpcp_def_cpu_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PCSW:\n\t\t\t\t\tpcp_def_pcsw_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_IRQ:\n\t\t\t\t\tpcp_def_irq_metrics(act[p]);\n\t\t\t\t\tpcp_def_cpu_metrics(act[p]);\t/* For per_CPU int metrics */\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_SWAP:\n\t\t\t\t\tpcp_def_swap_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PAGE:\n\t\t\t\t\tpcp_def_paging_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_IO:\n\t\t\t\t\tpcp_def_io_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_MEMORY:\n\t\t\t\t\tpcp_def_memory_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_KTABLES:\n\t\t\t\t\tpcp_def_ktables_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_QUEUE:\n\t\t\t\t\tpcp_def_queue_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_SERIAL:\n\t\t\t\t\tpcp_def_serial_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_DISK:\n\t\t\t\t\tpcp_def_disk_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_DEV:\n\t\t\t\tcase A_NET_EDEV:\n\t\t\t\t\tpcp_def_net_dev_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_NFS:\n\t\t\t\t\tpcp_def_net_nfs_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_NFSD:\n\t\t\t\t\tpcp_def_net_nfsd_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_SOCK:\n\t\t\t\t\tpcp_def_net_sock_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_IP:\n\t\t\t\t\tpcp_def_net_ip_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EIP:\n\t\t\t\t\tpcp_def_net_eip_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_ICMP:\n\t\t\t\t\tpcp_def_net_icmp_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EICMP:\n\t\t\t\t\tpcp_def_net_eicmp_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_TCP:\n\t\t\t\t\tpcp_def_net_tcp_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_ETCP:\n\t\t\t\t\tpcp_def_net_etcp_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_UDP:\n\t\t\t\t\tpcp_def_net_udp_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_SOCK6:\n\t\t\t\t\tpcp_def_net_sock6_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_IP6:\n\t\t\t\t\tpcp_def_net_ip6_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EIP6:\n\t\t\t\t\tpcp_def_net_eip6_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_ICMP6:\n\t\t\t\t\tpcp_def_net_icmp6_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_EICMP6:\n\t\t\t\t\tpcp_def_net_eicmp6_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_UDP6:\n\t\t\t\t\tpcp_def_net_udp6_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_HUGE:\n\t\t\t\t\tpcp_def_huge_metrics();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_FAN:\n\t\t\t\t\tpcp_def_pwr_fan_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_TEMP:\n\t\t\t\t\tpcp_def_pwr_temp_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_IN:\n\t\t\t\t\tpcp_def_pwr_in_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_BAT:\n\t\t\t\t\tpcp_def_pwr_bat_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PWR_USB:\n\t\t\t\t\tpcp_def_pwr_usb_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_FS:\n\t\t\t\t\tpcp_def_filesystem_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_NET_FC:\n\t\t\t\t\tpcp_def_fchost_metrics(act[p]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase A_PSI_CPU:\n\t\t\t\tcase A_PSI_IO:\n\t\t\t\tcase A_PSI_MEM:\n\t\t\t\t\tpcp_def_psi_metrics(act[p]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* HAVE_PCP */\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (db and ppc format).\n *\n * IN:\n * @fmt\t\tOutput format (F_DB_OUTPUT or F_PPC_OUTPUT).\n * @file_hdr\tSystem activity file standard header.\n * @cur_date\tDate string of current record.\n * @cur_time\tTime string of current record.\n * @my_tz\tCurrent timezone.\n * @itv\t\tInterval of time with preceding record.\n *\n * RETURNS:\n * Pointer on the \"timestamp\" string.\n ***************************************************************************\n */\nchar *print_dbppc_timestamp(int fmt, struct file_header *file_hdr, char *cur_date,\n\t\t\t    char *cur_time, char *my_tz, unsigned long long itv)\n{\n\tint isdb = (fmt == F_DB_OUTPUT);\n\tstatic char pre[512];\n\tchar temp1[128], temp2[256];\n\n\t/* This substring appears on every output line, preformat it here */\n\tsnprintf(temp1, sizeof(temp1), \"%s%s%llu%s\",\n\t\t file_hdr->sa_nodename, seps[isdb], itv, seps[isdb]);\n\tif (strlen(cur_date)) {\n\t\tsnprintf(temp2, sizeof(temp2), \"%s%s \", temp1, cur_date);\n\t}\n\telse {\n\t\tstrcpy(temp2, temp1);\n\t}\n\n\tif (strlen(cur_date) && (!PRINT_TRUE_TIME(flags) ||\n\t\t\t\t (PRINT_TRUE_TIME(flags) && strlen(file_hdr->sa_tzname)))) {\n\t\tsnprintf(pre, sizeof(pre), \"%s%s %s\", temp2, cur_time,\n\t\t\t PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t   : \"UTC\"));\n\t}\n\telse {\n\t\tsnprintf(pre, sizeof(pre), \"%s%s\", temp2, cur_time);\n\t}\n\n\n\t\n\tpre[sizeof(pre) - 1] = '\\0';\n\n\tif (DISPLAY_HORIZONTALLY(flags)) {\n\t\tprintf(\"%s\", pre);\n\t}\n\n\treturn pre;\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (ppc format).\n *\n * IN:\n * @parm\tPointer on specific parameters (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current record.\n * @cur_time\tTime string of current record.\n * @my_tz\tCurrent timezone.\n * @itv\t\tInterval of time with preceding record.\n * @record_hdr\tRecord header for current sample (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @flags\tFlags for common options (unused here).\n *\n * RETURNS:\n * Pointer on the \"timestamp\" string.\n ***************************************************************************\n */\n__tm_funct_t print_ppc_timestamp(void *parm, int action, char *cur_date,\n\t\t\t\t char *cur_time, char *my_tz, unsigned long long itv,\n\t\t\t\t struct record_header *record_hdr,\n\t\t\t\t struct file_header *file_hdr, unsigned int flags)\n{\n\tif (action & F_BEGIN) {\n\t\treturn print_dbppc_timestamp(F_PPC_OUTPUT, file_hdr, cur_date, cur_time,\n\t\t\t\t\t     my_tz, itv);\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (db format).\n *\n * IN:\n * @parm\tPointer on specific parameters (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current record.\n * @cur_time\tTime string of current record.\n * @my_tz\tCurrent timezone.\n * @itv\t\tInterval of time with preceding record.\n * @record_hdr\tRecord header for current sample (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @flags\tFlags for common options.\n *\n * RETURNS:\n * Pointer on the \"timestamp\" string.\n ***************************************************************************\n */\n__tm_funct_t print_db_timestamp(void *parm, int action, char *cur_date,\n\t\t\t\tchar *cur_time, char *my_tz, unsigned long long itv,\n\t\t\t\tstruct record_header *record_hdr,\n\t\t\t\tstruct file_header *file_hdr, unsigned int flags)\n{\n\tif (action & F_BEGIN) {\n\t\treturn print_dbppc_timestamp(F_DB_OUTPUT, file_hdr, cur_date, cur_time,\n\t\t\t\t\t     my_tz, itv);\n\t}\n\tif (action & F_END) {\n\t\tif (DISPLAY_HORIZONTALLY(flags)) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (XML format).\n *\n * IN:\n * @parm\tSpecific parameter. Here: number of tabulations.\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current comment.\n * @cur_time\tTime string of current comment.\n * @my_tz\tCurrent timezone.\n * @itv\t\tInterval of time with preceding record.\n * @record_hdr\tRecord header for current sample (unused here).\n * @file_hdr\tSystem activity file standard header (unused here).\n * @flags\tFlags for common options.\n ***************************************************************************\n */\n__tm_funct_t print_xml_timestamp(void *parm, int action, char *cur_date,\n\t\t\t\t char *cur_time, char *my_tz, unsigned long long itv,\n\t\t\t\t struct record_header *record_hdr,\n\t\t\t\t struct file_header *file_hdr, unsigned int flags)\n{\n\tint *tab = (int *) parm;\n\n\tif (action & F_BEGIN) {\n\t\txprintf((*tab)++, \"<timestamp date=\\\"%s\\\" time=\\\"%s\\\" tz=\\\"%s\\\" interval=\\\"%llu\\\">\",\n\t\t\tcur_date, cur_time,\n\t\t\tPRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t: (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t  : \"UTC\"),\n\t\t\titv);\n\t}\n\tif (action & F_END) {\n\t\txprintf(--(*tab), \"</timestamp>\");\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (JSON format).\n *\n * IN:\n * @parm\tSpecific parameter. Here: number of tabulations.\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current comment.\n * @cur_time\tTime string of current comment.\n * @my_tz\tCurrent timezone.\n * @itv\t\tInterval of time with preceding record.\n * @record_hdr\tRecord header for current sample (unused here).\n * @file_hdr\tSystem activity file standard header (unused here).\n * @flags\tFlags for common options.\n ***************************************************************************\n */\n__tm_funct_t print_json_timestamp(void *parm, int action, char *cur_date,\n\t\t\t\t  char *cur_time, char *my_tz, unsigned long long itv,\n\t\t\t\t  struct record_header *record_hdr,\n\t\t\t\t  struct file_header *file_hdr, unsigned int flags)\n{\n\tint *tab = (int *) parm;\n\n\tif (action & F_BEGIN) {\n\t\txprintf0(*tab,\n\t\t\t \"\\\"timestamp\\\": {\\\"date\\\": \\\"%s\\\", \\\"time\\\": \\\"%s\\\", \"\n\t\t\t \"\\\"tz\\\": \\\"%s\\\", \\\"interval\\\": %llu}\",\n\t\t\t cur_date, cur_time,\n\t\t\t PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t   : \"UTC\"),\n\t\t\titv);\n\t}\n\tif (action & F_MAIN) {\n\t\tprintf(\",\\n\");\n\t}\n\tif (action & F_END) {\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (raw format).\n *\n * IN:\n * @parm\tPointer on specific parameters (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current record.\n * @cur_time\tTime string of current record.\n * @my_tz\tCurrent timezone.\n * @itv\t\tInterval of time with preceding record (unused here).\n * @record_hdr\tRecord header for current sample (unused here).\n * @file_hdr\tSystem activity file standard header (unused here).\n * @flags\tFlags for common options.\n *\n * RETURNS:\n * Pointer on the \"timestamp\" string.\n ***************************************************************************\n */\n__tm_funct_t print_raw_timestamp(void *parm, int action, char *cur_date,\n\t\t\t\t char *cur_time, char *my_tz, unsigned long long itv,\n\t\t\t\t struct record_header *record_hdr,\n\t\t\t\t struct file_header *file_hdr, unsigned int flags)\n{\n\tstatic char pre[80];\n\n\tif (action & F_BEGIN) {\n\t\tif (strlen(cur_date) && (!PRINT_TRUE_TIME(flags) ||\n\t\t\t\t\t (PRINT_TRUE_TIME(flags) && strlen(file_hdr->sa_tzname)))) {\n\t\t\tsnprintf(pre, sizeof(pre), \"%s %s\", cur_time,\n\t\t\t\t PRINT_LOCAL_TIME(flags) ? my_tz\n\t\t\t\t\t\t\t : (PRINT_TRUE_TIME(flags) ? file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t\t\t   : \"UTC\"));\n\t\t}\n\t\telse {\n\t\t\tsnprintf(pre, sizeof(pre), \"%s\", cur_time);\n\t\t}\n\t\tpre[sizeof(pre) - 1] = '\\0';\n\n\t\treturn pre;\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Display the \"timestamp\" part of the report (PCP format).\n *\n * IN:\n * @parm\tPointer on specific parameters (unused here).\n * @action\tAction expected from current function.\n * @cur_date\tDate string of current record (unused here).\n * @cur_time\tTime string of current record (unused here).\n * @my_tz\tCurrent timezone (unused here).\n * @itv\t\tInterval of time with preceding record (unused here).\n * @record_hdr\tRecord header for current sample.\n * @file_hdr\tSystem activity file standard header (unused here).\n * @flags\tFlags for common options.\n *\n * RETURNS:\n * Pointer on the \"timestamp\" string.\n ***************************************************************************\n */\n__tm_funct_t print_pcp_timestamp(void *parm, int action, char *cur_date,\n\t\t\t\t char *cur_time, char *my_tz, unsigned long long itv,\n\t\t\t\t struct record_header *record_hdr,\n\t\t\t\t struct file_header *file_hdr, unsigned int flags)\n{\n\tif (action & F_END) {\n\t\tpcp_write_data(record_hdr, flags);\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Display the header of the report (XML format).\n *\n * IN:\n * @parm\tSpecific parameter. Here: number of tabulations.\n * @action\tAction expected from current function.\n * @dfile\tUnused here (PCP archive file).\n * @my_tz\tCurrent timezone (unused here).\n * @file_magic\tSystem activity file magic header.\n * @file_hdr\tSystem activity file standard header.\n * @act\t\tArray of activities (unused here).\n * @id_seq\tActivity sequence (unused here).\n * @file_actlst\tList of (known or unknown) activities in file (unused here).\n *\n * OUT:\n * @parm\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_xml_header(void *parm, int action, char *dfile, char *my_tz,\n\t\t\t\t  struct file_magic *file_magic,\n\t\t\t\t  struct file_header *file_hdr,\n\t\t\t\t  struct activity *act[], unsigned int id_seq[],\n\t\t\t\t  struct file_activity *file_actlst)\n{\n\tstruct tm rectime, loc_t;\n\ttime_t t = file_hdr->sa_ust_time;\n\tint *tab = (int *) parm;\n\n\tif (action & F_BEGIN) {\n\t\tchar cur_time[TIMESTAMP_LEN];\n\n\t\tprintf(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\t\txprintf(*tab, \"<sysstat\\n\"\n\t\t\t      \"xmlns=\\\"https://sysstat.github.io\\\"\\n\"\n\t\t\t      \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n\t\t\t      \"xsi:schemaLocation=\\\"https://sysstat.github.io https://sysstat.github.io/sysstat.xsd\\\">\");\n\n\t\txprintf(++(*tab), \"<sysdata-version>%s</sysdata-version>\",\n\t\t\tXML_DTD_VERSION);\n\n\t\txprintf(*tab, \"<host nodename=\\\"%s\\\">\", file_hdr->sa_nodename);\n\t\txprintf(++(*tab), \"<sysname>%s</sysname>\", file_hdr->sa_sysname);\n\t\txprintf(*tab, \"<release>%s</release>\", file_hdr->sa_release);\n\n\t\txprintf(*tab, \"<machine>%s</machine>\", file_hdr->sa_machine);\n\t\txprintf(*tab, \"<number-of-cpus>%d</number-of-cpus>\",\n\t\t\tfile_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\n\t\t/* Fill file timestmap structure (rectime) */\n\t\tget_file_timestamp_struct(flags, &rectime, file_hdr);\n\t\tstrftime(cur_time, sizeof(cur_time), \"%Y-%m-%d\", &rectime);\n\t\txprintf(*tab, \"<file-date>%s</file-date>\", cur_time);\n\n\t\tif (gmtime_r(&t, &loc_t) != NULL) {\n\t\t\tstrftime(cur_time, sizeof(cur_time), \"%T\", &loc_t);\n\t\t\txprintf(*tab, \"<file-utc-time>%s</file-utc-time>\", cur_time);\n\t\t}\n\n\t\txprintf(*tab, \"<timezone>%s</timezone>\", file_hdr->sa_tzname);\n\t}\n\tif (action & F_END) {\n\t\txprintf(--(*tab), \"</host>\");\n\t\txprintf(--(*tab), \"</sysstat>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display the header of the report (JSON format).\n *\n * IN:\n * @parm\tSpecific parameter. Here: number of tabulations.\n * @action\tAction expected from current function.\n * @dfile\tUnused here (PCP archive file).\n * @my_tz\tCurrent timezone (unused here).\n * @file_magic\tSystem activity file magic header.\n * @file_hdr\tSystem activity file standard header.\n * @act\t\tArray of activities (unused here).\n * @id_seq\tActivity sequence (unused here).\n * @file_actlst\tList of (known or unknown) activities in file (unused here).\n *\n * OUT:\n * @parm\tNumber of tabulations.\n ***************************************************************************\n */\n__printf_funct_t print_json_header(void *parm, int action, char *dfile, char *my_tz,\n\t\t\t\t   struct file_magic *file_magic,\n\t\t\t\t   struct file_header *file_hdr,\n\t\t\t\t   struct activity *act[], unsigned int id_seq[],\n\t\t\t\t   struct file_activity *file_actlst)\n{\n\tstruct tm rectime, loc_t;\n\ttime_t t = file_hdr->sa_ust_time;\n\tint *tab = (int *) parm;\n\n\tif (action & F_BEGIN) {\n\t\tchar cur_time[TIMESTAMP_LEN];\n\n\t\txprintf(*tab, \"{\\\"sysstat\\\": {\");\n\n\t\txprintf(++(*tab), \"\\\"hosts\\\": [\");\n\t\txprintf(++(*tab), \"{\");\n\t\txprintf(++(*tab), \"\\\"nodename\\\": \\\"%s\\\",\", file_hdr->sa_nodename);\n\t\txprintf(*tab, \"\\\"sysname\\\": \\\"%s\\\",\", file_hdr->sa_sysname);\n\t\txprintf(*tab, \"\\\"release\\\": \\\"%s\\\",\", file_hdr->sa_release);\n\n\t\txprintf(*tab, \"\\\"machine\\\": \\\"%s\\\",\", file_hdr->sa_machine);\n\t\txprintf(*tab, \"\\\"number-of-cpus\\\": %d,\",\n\t\t\tfile_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\n\t\t/* Fill file timestmap structure (rectime) */\n\t\tget_file_timestamp_struct(flags, &rectime, file_hdr);\n\t\tstrftime(cur_time, sizeof(cur_time), \"%Y-%m-%d\", &rectime);\n\t\txprintf(*tab, \"\\\"file-date\\\": \\\"%s\\\",\", cur_time);\n\n\t\tif (gmtime_r(&t, &loc_t) != NULL) {\n\t\t\tstrftime(cur_time, sizeof(cur_time), \"%T\", &loc_t);\n\t\t\txprintf(*tab, \"\\\"file-utc-time\\\": \\\"%s\\\",\", cur_time);\n\t\t}\n\n\t\txprintf0(*tab, \"\\\"timezone\\\": \\\"%s\\\"\", file_hdr->sa_tzname);\n\t}\n\tif (action & F_END) {\n\t\tprintf(\"\\n\");\n\t\txprintf(--(*tab), \"}\");\n\t\txprintf(--(*tab), \"]\");\n\t\txprintf(--(*tab), \"}}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display data file header.\n *\n * IN:\n * @parm\tSpecific parameter (unused here).\n * @action\tAction expected from current function.\n * @dfile\tName of system activity data file (unused here).\n * @my_tz\tCurrent timezone (unused here).\n * @file_magic\tSystem activity file magic header.\n * @file_hdr\tSystem activity file standard header.\n * @act\t\tArray of activities.\n * @id_seq\tActivity sequence.\n * @file_actlst\tList of (known or unknown) activities in file.\n ***************************************************************************\n */\n__printf_funct_t print_hdr_header(void *parm, int action, char *dfile, char *my_tz,\n\t\t\t\t  struct file_magic *file_magic,\n\t\t\t\t  struct file_header *file_hdr,\n\t\t\t\t  struct activity *act[], unsigned int id_seq[],\n\t\t\t\t  struct file_activity *file_actlst)\n{\n\t/* Actions F_MAIN and F_END ignored */\n\tif (action & F_BEGIN) {\n\t\tstruct tm rectime, loc_t;\n\t\ttime_t t = file_hdr->sa_ust_time;\n\t\tint i, p;\n\t\tchar cur_time[TIMESTAMP_LEN];\n\t\tstruct file_activity *fal;\n\n\t\tprintf(_(\"System activity data file: %s (%#x)\\n\"),\n\t\t       dfile, file_magic->format_magic);\n\n\t\tdisplay_sa_file_version(stdout, file_magic);\n\n\t\tif (file_magic->format_magic != FORMAT_MAGIC) {\n\t\t\treturn;\n\t\t}\n\n\t\tprintf(_(\"Genuine sa datafile: %s (%x)\\n\"),\n\t\t       file_magic->upgraded ? _(\"no\") : _(\"yes\"),\n\t\t       file_magic->upgraded);\n\n\t\tprintf(_(\"Host: \"));\n\t\tprint_gal_header(localtime_r(&t, &rectime),\n\t\t\t\t file_hdr->sa_sysname, file_hdr->sa_release,\n\t\t\t\t file_hdr->sa_nodename, file_hdr->sa_machine,\n\t\t\t\t file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1,\n\t\t\t\t PLAIN_OUTPUT);\n\n\t\t/* Fill file timestamp structure (rectime) */\n\t\tget_file_timestamp_struct(flags, &rectime, file_hdr);\n\t\tstrftime(cur_time, sizeof(cur_time), \"%Y-%m-%d\", &rectime);\n\t\tprintf(_(\"File date: %s\\n\"), cur_time);\n\n\t\tif (gmtime_r(&t, &loc_t) != NULL) {\n\t\t\tprintf(_(\"File time: \"));\n\t\t\tstrftime(cur_time, sizeof(cur_time), \"%T\", &loc_t);\n\t\t\tprintf(\"%s UTC (%llu)\\n\", cur_time, file_hdr->sa_ust_time);\n\t\t}\n\n\t\tprintf(_(\"Timezone: %s\\n\"), file_hdr->sa_tzname);\n\n\t\t/* File composition: file_header, file_activity, record_header */\n\t\tprintf(_(\"File composition: (%u,%u,%u),(%u,%u,%u),(%u,%u,%u)\\n\"),\n\t\t       file_magic->hdr_types_nr[0], file_magic->hdr_types_nr[1], file_magic->hdr_types_nr[2],\n\t\t       file_hdr->act_types_nr[0], file_hdr->act_types_nr[1], file_hdr->act_types_nr[2],\n\t\t       file_hdr->rec_types_nr[0], file_hdr->rec_types_nr[1], file_hdr->rec_types_nr[2]);\n\n\t\tprintf(_(\"Size of a long int: %d\\n\"), file_hdr->sa_sizeof_long);\n\t\tprintf(\"HZ = %lu\\n\", file_hdr->sa_hz);\n\t\tprintf(_(\"Number of activities in file: %u\\n\"),\n\t\t       file_hdr->sa_act_nr);\n\t\tprintf(_(\"Extra structures available: %c\\n\"),\n\t\t       file_hdr->extra_next ? 'Y' : 'N');\n\n\t\tprintf(_(\"List of activities:\\n\"));\n\t\tfal = file_actlst;\n\t\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t\tp = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND);\n\n\t\t\tprintf(\"%02u: [%02x] \", fal->id, fal->magic);\n\t\t\tif (p >= 0) {\n\t\t\t\tprintf(\"%-20s\", act[p]->name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%-20s\", _(\"Unknown activity\"));\n\t\t\t}\n\t\t\tprintf(\" %c:%4d\", fal->has_nr ? 'Y' : 'N', fal->nr);\n\t\t\tif (fal->nr2 > 1) {\n\t\t\t\tprintf(\"x%d\", fal->nr2);\n\t\t\t}\n\t\t\tprintf(\"\\t(%u,%u,%u)\", fal->types_nr[0], fal->types_nr[1], fal->types_nr[2]);\n\t\t\tif ((p >= 0) && (act[p]->magic != fal->magic)) {\n\t\t\t\tprintf(_(\" \\t[Unknown format]\"));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display the header of the report (SVG format).\n *\n * IN:\n * @parm\tSpecific parameters. Here: number of rows of views to display\n *\t\tor canvas height entered on the command line (@graph_nr), and\n *\t\tmax number of views on a single row (@views_per_row).\n * @action\tAction expected from current function.\n * @dfile\tName of system activity data file (unused here).\n * @my_tz\tCurrent timezone (unused here).\n * @file_magic\tSystem activity file magic header (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @act\t\tArray of activities (unused here).\n * @id_seq\tActivity sequence (unused here).\n * @file_actlst\tList of (known or unknown) activities in file (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_svg_header(void *parm, int action, char *dfile, char *my_tz,\n\t\t\t\t  struct file_magic *file_magic,\n\t\t\t\t  struct file_header *file_hdr,\n\t\t\t\t  struct activity *act[], unsigned int id_seq[],\n\t\t\t\t  struct file_activity *file_actlst)\n{\n\tstruct svg_hdr_parm *hdr_parm = (struct svg_hdr_parm *) parm;\n\tstruct tm rectime;\n\ttime_t t = file_hdr->sa_ust_time;\n\n\tif (action & F_BEGIN) {\n\t\tprintf(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\t\tprintf(\"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \");\n\t\tprintf(\"\\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\");\n\t\tprintf(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\");\n\t\tif (DISPLAY_TOC(flags)) {\n\t\t\tprintf(\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\");\n\t\t}\n\t\tif (action & F_END) {\n\t\t\tprintf(\">\\n\");\n\t\t}\n\t}\n\n\tif (action & F_MAIN) {\n\t\tunsigned int height;\n\n\t\tif (SET_CANVAS_HEIGHT(flags)) {\n\t\t\t/*\n\t\t\t * Option \"-O height=...\" used: @graph_nr is\n\t\t\t * the SVG canvas height set on the command line.\n\t\t\t */\n\t\t\theight = hdr_parm->graph_nr;\n\t\t}\n\t\telse {\n\t\t\theight = SVG_H_YSIZE +\n\t\t\t\t SVG_C_YSIZE * (DISPLAY_TOC(flags) ? hdr_parm->nr_act_dispd : 0) +\n\t\t\t\t SVG_T_YSIZE * hdr_parm->graph_nr;\n\t\t}\n\t\tif (height < MIN_CANVAS_HEIGHT) {\n\t\t\t/* There is a min canvas height (at least to display \"No data\") */\n\t\t\theight = MIN_CANVAS_HEIGHT;\n\t\t}\n\t\tprintf(\" width=\\\"%d\\\" height=\\\"%u\\\"\"\n\t\t       \" fill=\\\"black\\\" stroke=\\\"#%06x\\\" stroke-width=\\\"1\\\">\\n\",\n\t\t       SVG_T_XSIZE * (hdr_parm->views_per_row), height,\n\t\t       svg_colors[palette][SVG_COL_DEFAULT_IDX]);\n\t\tprintf(\"<text x=\\\"0\\\" y=\\\"30\\\" text-anchor=\\\"start\\\" stroke=\\\"#%06x\\\">\",\n\t\t       svg_colors[palette][SVG_COL_HEADER_IDX]);\n\t\tprint_gal_header(localtime_r(&t, &rectime),\n\t\t\t\t file_hdr->sa_sysname, file_hdr->sa_release,\n\t\t\t\t file_hdr->sa_nodename, file_hdr->sa_machine,\n\t\t\t\t file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1,\n\t\t\t\t PLAIN_OUTPUT);\n\t\tprintf(\"</text>\\n\");\n\t\tif (DISPLAY_TOC(flags)) {\n\t\t\tunsigned int ht = 0;\n\t\t\tint i, p;\n\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\t\tif (!id_seq[i])\n\t\t\t\t\tcontinue;\t/* Activity not in file */\n\n\t\t\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\t\t\t\tif (!IS_SELECTED(act[p]->options) || !act[p]->g_nr)\n\t\t\t\t\tcontinue;\t/* Activity not selected or no graph available */\n\n\t\t\t\tprintf(\"<a xlink:href=\\\"#g%u-0\\\" xlink:title=\\\"%s\\\">\\n\",\n\t\t\t\t       act[p]->id, act[p]->name);\n\t\t\t\tprintf(\"<text x=\\\"10\\\" y=\\\"%u\\\">%s</text></a>\\n\",\n\t\t\t\t       SVG_H_YSIZE + ht, act[p]->desc);\n\t\t\t\tht += SVG_C_YSIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tif (!(action & F_BEGIN)) {\n\t\t\tif (!hdr_parm->graph_nr) {\n\t\t\t\t/* No views displayed */\n\t\t\t\tprintf(\"<text x= \\\"0\\\" y=\\\"%d\\\" text-anchor=\\\"start\\\" stroke=\\\"#%06x\\\">\",\n\t\t\t\t       SVG_H_YSIZE +\n\t\t\t\t       SVG_C_YSIZE * (DISPLAY_TOC(flags) ? hdr_parm->nr_act_dispd : 0),\n\t\t\t\t       svg_colors[palette][SVG_COL_ERROR_IDX]);\n\t\t\t\tprintf(\"No data!</text>\\n\");\n\t\t\t}\n\t\t\t/* Give actual SVG height */\n\t\t\tprintf(\"<!-- Actual canvas height: %d -->\\n\",\n\t\t\t       SVG_H_YSIZE +\n\t\t\t       SVG_C_YSIZE * (DISPLAY_TOC(flags) ? hdr_parm->nr_act_dispd : 0) +\n\t\t\t       SVG_T_YSIZE * hdr_parm->graph_nr);\n\t\t}\n\t\tprintf(\"</svg>\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * PCP header function.\n *\n * IN:\n * @parm\tSpecific parameter (unused here).\n * @action\tAction expected from current function.\n * @dfile\tName of PCP archive file.\n * @my_tz\tCurrent timezone (unused here).\n * @file_magic\tSystem activity file magic header (unused here).\n * @file_hdr\tSystem activity file standard header (unused here).\n * @act\t\tArray of activities (unused here).\n * @id_seq\tActivity sequence (unused here).\n * @file_actlst\tList of (known or unknown) activities in file (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_pcp_header(void *parm, int action, char *dfile, char *my_tz,\n\t\t\t\t  struct file_magic *file_magic,\n\t\t\t\t  struct file_header *file_hdr,\n\t\t\t\t  struct activity *act[], unsigned int id_seq[],\n\t\t\t\t  struct file_activity *file_actlst)\n{\n#ifdef HAVE_PCP\n\tchar buf[64];\n\tunsigned long long utc_sec = file_hdr->sa_ust_time;\n\n\tif (action & F_BEGIN) {\n\t\t/* Create new PCP context */\n\t\tpmiStart(dfile, FALSE);\n\n\t\t/* Set timezone */\n\t\tpmiSetTimezone(file_hdr->sa_tzname);\n\n\t\t/* Save hostname */\n\t\tpmiSetHostname(file_hdr->sa_nodename);\n\n\t\t/* Save number of CPU in PCP archive */\n\t\tpmiAddMetric(\"hinv.ncpu\",\n\t\t\t     pmiID(60, 0, 32), PM_TYPE_U32, PM_INDOM_NULL,\n\t\t\t     PM_SEM_DISCRETE, pmiUnits(0, 0, 0, 0, 0, 0));\n\t\tsnprintf(buf, sizeof(buf), \"%u\",\n\t\t\t file_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\t\tpmiPutValue(\"hinv.ncpu\", NULL, buf);\n\n\t\t/* Save uname(2) information */\n\t\tpmiAddMetric(\"kernel.uname.release\",\n\t\t\t     pmiID(60, 12, 0), PM_TYPE_STRING, PM_INDOM_NULL,\n\t\t\t     PM_SEM_DISCRETE, pmiUnits(0, 0, 0, 0, 0, 0));\n\t\tpmiPutValue(\"kernel.uname.release\", NULL, file_hdr->sa_release);\n\t\tpmiAddMetric(\"kernel.uname.sysname\",\n\t\t\t     pmiID(60, 12, 2), PM_TYPE_STRING, PM_INDOM_NULL,\n\t\t\t     PM_SEM_DISCRETE, pmiUnits(0, 0, 0, 0, 0, 0));\n\t\tpmiPutValue(\"kernel.uname.sysname\", NULL, file_hdr->sa_sysname);\n\t\tpmiAddMetric(\"kernel.uname.machine\",\n\t\t\t     pmiID(60, 12, 3), PM_TYPE_STRING, PM_INDOM_NULL,\n\t\t\t     PM_SEM_DISCRETE, pmiUnits(0, 0, 0, 0, 0, 0));\n\t\tpmiPutValue(\"kernel.uname.machine\", NULL, file_hdr->sa_machine);\n\t\tpmiAddMetric(\"kernel.uname.nodename\",\n\t\t\t     pmiID(60, 12, 4), PM_TYPE_STRING, PM_INDOM_NULL,\n\t\t\t     PM_SEM_DISCRETE, pmiUnits(0, 0, 0, 0, 0, 0));\n\t\tpmiPutValue(\"kernel.uname.nodename\", NULL, file_hdr->sa_nodename);\n\t}\n\n\tif (action & F_END) {\n\t\tif (action & F_BEGIN) {\n\t\t\tint rc;\n\n\t\t\tif ((rc = pmiWrite(utc_sec, 0)) < 0) {\n\t\t\t\tfprintf(stderr, \"PCP: pmiWrite: %s\\n\", pmiErrStr(rc));\n\t\t\t\texit(4);\n\t\t\t}\n\t\t}\n\t\tpmiEnd();\n\t}\n#endif\n}\n\n/*\n ***************************************************************************\n * Count the number of new network interfaces in current sample. If a new\n * interface is found then add it to the linked list starting at\n * @a->item_list.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of new interfaces identified in current sample that were not\n * previously in the list.\n ***************************************************************************\n */\n__nr_t count_new_net_dev(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_net_dev *sndc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tnr += add_list_item(&(a->item_list), sndc->interface, MAX_IFACE_LEN, NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Count the number of new network interfaces in current sample. If a new\n * interface is found then add it to the linked list starting at\n * @a->item_list.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of new interfaces identified in current sample that were not\n * previously in the list.\n ***************************************************************************\n */\n__nr_t count_new_net_edev(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_net_edev *snedc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tnr += add_list_item(&(a->item_list), snedc->interface, MAX_IFACE_LEN, NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Count the number of new filesystems in current sample. If a new\n * filesystem is found then add it to the linked list starting at\n * @a->item_list.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of new filesystems identified in current sample that were not\n * previously in the list.\n ***************************************************************************\n */\n__nr_t count_new_filesystem(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_filesystem *sfc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tnr += add_list_item(&(a->item_list),\n\t\t\t\t    get_fs_name_to_display(a, flags, sfc),\n\t\t\t\t    MAX_FS_LEN, NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Count the number of new fchosts in current sample. If a new\n * fchost is found then add it to the linked list starting at\n * @a->item_list.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of new fchosts identified in current sample that were not\n * previously in the list.\n ***************************************************************************\n */\n__nr_t count_new_fchost(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_fchost *sfcc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tnr += add_list_item(&(a->item_list), sfcc->fchost_name, MAX_FCH_LEN, NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Count the number of new block devices in current sample. If a new\n * block device is found then add it to the linked list starting at\n * @a->item_list.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of new block devices identified in current sample that were not\n * previously in the list.\n ***************************************************************************\n */\n__nr_t count_new_disk(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_disk *sdc;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tnr += add_list_item(&(a->item_list),\n\t\t\t\t    get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t\t    DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t\t    USE_STABLE_ID(flags), NULL),\n\t\t\t\t    MAX_DEV_LEN, NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Count the number of interrupts in current sample. Add each interrupt name\n * to the linked list starting at @a->item_list.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of interrupts added to the list.\n ***************************************************************************\n */\n__nr_t count_new_int(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_irq *stc_cpuall_irq;\n\n\tif (a->item_list)\n\t\t/*\n\t\t * If a list already exists, do nothing. This means that a list has been\n\t\t * explicitly entered on the command line using option \"--int=\", or that\n\t\t * the list has already been created here (remember that the number of\n\t\t * interrupts cannot change in file: @nr2, the second matrix dimension,\n\t\t * is a constant).\n\t\t */\n\t\treturn 0;\n\n\tfor (i = 0; i < a->nr2; i++) {\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tnr += add_list_item(&(a->item_list), stc_cpuall_irq->irq_name,\n\t\t\t\t    MAX_SA_IRQ_LEN, NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n * **************************************************************************\n * Count the number of new batteries in current sample. If a new\n * battery is found then add it to the linked list starting at\n * @a->item_list.\n * Mainly useful to create a list of battery names (BATx) that will be used\n * as instance names for sadf PCP output format.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * Number of new batteries identified in current sample that were not\n * previously in the list.\n ***************************************************************************\n */\n__nr_t count_new_bat(struct activity *a, int curr)\n{\n\tint i, nr = 0;\n\tstruct stats_pwr_bat *spbc;\n\tchar bat_name[16];\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tsnprintf(bat_name, sizeof(bat_name), \"BAT%d\", (int) spbc->bat_id);\n\t\tnr += add_list_item(&(a->item_list), bat_name, sizeof(bat_name), NULL);\n\t}\n\n\treturn nr;\n}\n\n/*\n ***************************************************************************\n * Init custom color palette used to draw graphs (sadf -g).\n ***************************************************************************\n */\nvoid init_custom_color_palette(void)\n{\n\tchar *e, *p;\n\tint len;\n\tunsigned int val;\n\n\t/* Read S_COLORS_PALETTE environment variable */\n\tif ((e = __getenv(ENV_COLORS_PALETTE)) == NULL)\n\t\t/* Environment variable not set */\n\t\treturn;\n\n\tfor (p = strtok(e, \":\"); p; p =strtok(NULL, \":\")) {\n\n\t\tlen = strlen(p);\n\t\tif ((len > 8) || (len < 3) || (*(p + 1) != '=') ||\n\t\t    (strspn(p + 2, \"0123456789ABCDEFabcdef\") != (len - 2)))\n\t\t\t/* Ignore malformed codes */\n\t\t\tcontinue;\n\n\t\tsscanf(p + 2, \"%x\", &val);\n\n\t\tif ((*p >= '0') && (*p <= '9')) {\n\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][*p & 0xf] = val;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (((*p >= 'A') && (*p <= 'F')) ||\n\t\t\t ((*p >= 'a') && (*p <= 'f'))) {\n\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][9 + (*p & 0xf)] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (*p) {\n\t\t\tcase 'G':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_GRID_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_HEADER_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_INFO_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_BCKGRD_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_DEFAULT_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_TITLE_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_ERROR_IDX] = val;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tsvg_colors[SVG_CUSTOM_COL_PALETTE][SVG_COL_AXIS_IDX] = val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sar.c",
          "type": "blob",
          "size": 49.2548828125,
          "content": "/*\n * sar: report system activity\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <ctype.h>\n\n#include \"version.h\"\n#include \"sa.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern time_t __unix_time;\nextern int __env;\n#endif\n\n/* Interval and count parameters */\nlong interval = -1, count = 0;\n\n/* TRUE if a header line must be printed */\nint dish = TRUE;\n/*\n * TRUE if min/max values should be initialized.\n * Note: Never set to TRUE if option -x has not been used with sar.\n */\nint xinit = FALSE;\n/* TRUE if data read from file don't match current machine's endianness */\nint endian_mismatch = FALSE;\n/* TRUE if file's data come from a 64 bit machine */\nint arch_64 = FALSE;\n/* Number of decimal places */\nint dplaces_nr = -1;\n\n/* sar always displays timestamps in local time */\nuint64_t flags = S_F_LOCAL_TIME;\n\nchar timestamp[2][TIMESTAMP_LEN];\nextern unsigned int rec_types_nr[];\n\nunsigned long avg_count = 0;\n\n/* File header */\nstruct file_header file_hdr;\n\n/* Current record header */\nstruct record_header record_hdr[3];\n\n/*\n * Activity sequence.\n * This array must always be entirely filled (even with trailing zeros).\n */\nunsigned int id_seq[NR_ACT];\n\nstruct tstamp_ext rectime;\n\n/* Contain the date specified by -s and -e options */\nstruct tstamp_ext tm_start, tm_end;\n\nchar *args[MAX_ARGV_NR];\n\nextern struct activity *act[];\nextern struct report_format sar_fmt;\n\nstruct sigaction int_act;\nint sigint_caught = 0;\n\n/*\n ***************************************************************************\n * Print usage title message.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\nvoid print_usage_title(FILE *fp, char *progname)\n{\n\tfprintf(fp, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ]\\n\"),\n\t\tprogname);\n}\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tprint_usage_title(stderr, progname);\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -A ] [ -B ] [ -b ] [ -C ] [ -D ] [ -d ] [ -F [ MOUNT ] ] [ -H ] [ -h ]\\n\"\n\t\t\t  \"[ -p ] [ -r [ ALL ] ] [ -S ] [ -t ] [ -u [ ALL ] ] [ -V ]\\n\"\n\t\t\t  \"[ -v ] [ -W ] [ -w ] [ -x ] [ -y ] [ -z ]\\n\"\n\t\t\t  \"[ -I [ SUM | ALL ] ] [ -P { <cpu_list> | ALL } ]\\n\"\n\t\t\t  \"[ -m { <keyword> [,...] | ALL } ] [ -n { <keyword> [,...] | ALL } ]\\n\"\n\t\t\t  \"[ -q [ <keyword> [,...] | ALL ] ]\\n\"\n\t\t\t  \"[ --dev=<dev_list> ] [ --fs=<fs_list> ] [ --iface=<iface_list> ] \"\n\t\t\t  \"[ --int=<int_list> ]\\n\"\n\t\t\t  \"[ --dec={ 0 | 1 | 2 } ] [ --help ] [ --human ] [ --pretty ] [ --sadc ]\\n\"\n\t\t\t  \"[ -j { SID | ID | LABEL | PATH | UUID | ... } ]\\n\"\n\t\t\t  \"[ -f [ <filename> ] | -o [ <filename> ] | -[0-9]+ ]\\n\"\n\t\t\t  \"[ -i <interval> ] [ -s [ <start_time> ] ] [ -e [ <end_time> ] ]\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * Display a short help message and exit.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\nvoid display_help(char *progname)\n{\n\tprint_usage_title(stdout, progname);\n\tprintf(_(\"Main options and reports (report name between square brackets):\\n\"));\n\tprintf(_(\"\\t-B\\tPaging statistics [A_PAGE]\\n\"));\n\tprintf(_(\"\\t-b\\tI/O and transfer rate statistics [A_IO]\\n\"));\n\tprintf(_(\"\\t-d\\tBlock devices statistics [A_DISK]\\n\"));\n\tprintf(_(\"\\t-F [ MOUNT ]\\n\"));\n\tprintf(_(\"\\t\\tFilesystems statistics [A_FS]\\n\"));\n\tprintf(_(\"\\t-H\\tHugepages utilization statistics [A_HUGE]\\n\"));\n\tprintf(_(\"\\t-I [ SUM | ALL ]\\n\"\n\t\t \"\\t\\tInterrupts statistics [A_IRQ]\\n\"));\n\tprintf(_(\"\\t-m { <keyword> [,...] | ALL }\\n\"\n\t\t \"\\t\\tPower management statistics [A_PWR_...]\\n\"\n\t\t \"\\t\\tKeywords are:\\n\"\n\t\t \"\\t\\tBAT\\tBatteries capacity\\n\"\n\t\t \"\\t\\tCPU\\tCPU instantaneous clock frequency\\n\"\n\t\t \"\\t\\tFAN\\tFans speed\\n\"\n\t\t \"\\t\\tFREQ\\tCPU average clock frequency\\n\"\n\t\t \"\\t\\tIN\\tVoltage inputs\\n\"\n\t\t \"\\t\\tTEMP\\tDevices temperature\\n\"\n\t\t \"\\t\\tUSB\\tUSB devices plugged into the system\\n\"));\n\tprintf(_(\"\\t-n { <keyword> [,...] | ALL }\\n\"\n\t\t \"\\t\\tNetwork statistics [A_NET_...]\\n\"\n\t\t \"\\t\\tKeywords are:\\n\"\n\t\t \"\\t\\tDEV\\tNetwork interfaces\\n\"\n\t\t \"\\t\\tEDEV\\tNetwork interfaces (errors)\\n\"\n\t\t \"\\t\\tNFS\\tNFS client\\n\"\n\t\t \"\\t\\tNFSD\\tNFS server\\n\"\n\t\t \"\\t\\tSOCK\\tSockets\\t(v4)\\n\"\n\t\t \"\\t\\tIP\\tIP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tEIP\\tIP traffic\\t(v4) (errors)\\n\"\n\t\t \"\\t\\tICMP\\tICMP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tEICMP\\tICMP traffic\\t(v4) (errors)\\n\"\n\t\t \"\\t\\tTCP\\tTCP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tETCP\\tTCP traffic\\t(v4) (errors)\\n\"\n\t\t \"\\t\\tUDP\\tUDP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tSOCK6\\tSockets\\t(v6)\\n\"\n\t\t \"\\t\\tIP6\\tIP traffic\\t(v6)\\n\"\n\t\t \"\\t\\tEIP6\\tIP traffic\\t(v6) (errors)\\n\"\n\t\t \"\\t\\tICMP6\\tICMP traffic\\t(v6)\\n\"\n\t\t \"\\t\\tEICMP6\\tICMP traffic\\t(v6) (errors)\\n\"\n\t\t \"\\t\\tUDP6\\tUDP traffic\\t(v6)\\n\"\n\t\t \"\\t\\tFC\\tFibre channel HBAs\\n\"\n\t\t \"\\t\\tSOFT\\tSoftware-based network processing\\n\"));\n\tprintf(_(\"\\t-q [ <keyword> [,...] | PSI | ALL ]\\n\"\n\t\t \"\\t\\tSystem load and pressure-stall statistics\\n\"\n\t\t \"\\t\\tKeywords are:\\n\"\n\t\t \"\\t\\tLOAD\\tQueue length and load average statistics [A_QUEUE]\\n\"\n\t\t \"\\t\\tCPU\\tPressure-stall CPU statistics [A_PSI_CPU]\\n\"\n\t\t \"\\t\\tIO\\tPressure-stall I/O statistics [A_PSI_IO]\\n\"\n\t\t \"\\t\\tMEM\\tPressure-stall memory statistics [A_PSI_MEM]\\n\"));\n\tprintf(_(\"\\t-r [ ALL ]\\n\"\n\t\t \"\\t\\tMemory utilization statistics [A_MEMORY]\\n\"));\n\tprintf(_(\"\\t-S\\tSwap space utilization statistics [A_MEMORY]\\n\"));\n\tprintf(_(\"\\t-u [ ALL ]\\n\"\n\t\t \"\\t\\tCPU utilization statistics [A_CPU]\\n\"));\n\tprintf(_(\"\\t-v\\tKernel tables statistics [A_KTABLES]\\n\"));\n\tprintf(_(\"\\t-W\\tSwapping statistics [A_SWAP]\\n\"));\n\tprintf(_(\"\\t-w\\tTask creation and system switching statistics [A_PCSW]\\n\"));\n\tprintf(_(\"\\t-y\\tTTY devices statistics [A_SERIAL]\\n\"));\n\texit(0);\n}\n\n/*\n ***************************************************************************\n * Give a hint to the user about where is located the data collector.\n ***************************************************************************\n */\nvoid which_sadc(void)\n{\n\tstruct stat buf;\n\n\tif (stat(SADC_PATH, &buf) < 0) {\n\t\tprintf(_(\"Data collector will be sought in PATH\\n\"));\n\t}\n\telse {\n\t\tprintf(_(\"Data collector found: %s\\n\"), SADC_PATH);\n\t}\n\texit(0);\n}\n\n/*\n ***************************************************************************\n * SIGINT signal handler.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tsigint_caught = 1;\n\tprintf(\"\\n\");\t/* Skip \"^C\" displayed on screen */\n\n}\n\n/*\n ***************************************************************************\n * Init some structures.\n ***************************************************************************\n */\nvoid init_structures(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tmemset(&record_hdr[i], 0, RECORD_HEADER_SIZE);\n}\n\n/*\n ***************************************************************************\n * Allocate memory for sadc args.\n *\n * IN:\n * @i\t\tArgument number.\n * @ltemp\tArgument value.\n ***************************************************************************\n */\nvoid salloc(int i, char *ltemp)\n{\n\tif ((args[i] = (char *) malloc(strlen(ltemp) + 1)) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tstrcpy(args[i], ltemp);\n}\n\n/*\n ***************************************************************************\n * Display an error message.\n *\n * IN:\n * @error_code\tCode of error message to display.\n ***************************************************************************\n */\nvoid print_read_error(enum sa_err_codes error_code)\n{\n\tswitch (error_code) {\n\n\t\tcase END_OF_DATA_UNEXPECTED:\n\t\t\t/* Happens when the data collector doesn't send enough data */\n\t\t\tfprintf(stderr, _(\"End of data collecting unexpected\\n\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Strange data sent by sadc...! */\n\t\t\tfprintf(stderr, _(\"Inconsistent input data\\n\"));\n\t\t\tbreak;\n\t}\n\texit(3);\n}\n\n/*\n ***************************************************************************\n * Check that every selected activity actually belongs to the sequence list.\n * If not, then the activity should be unselected since it will not be sent\n * by sadc. An activity can be not sent if its number of items is zero.\n *\n * IN:\n * @act_nr\tSize of sequence list.\n ***************************************************************************\n */\nvoid reverse_check_act(unsigned int act_nr)\n{\n\tint i, j;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (IS_SELECTED(act[i]->options)) {\n\n\t\t\tfor (j = 0; j < act_nr; j++) {\n\t\t\t\tif (id_seq[j] == act[i]->id)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == act_nr)\n\t\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Determine if a stat header line has to be displayed.\n *\n * RETURNS:\n * TRUE if a header line has to be displayed.\n ***************************************************************************\n*/\nint check_line_hdr(void)\n{\n\tint i, rc = FALSE;\n\n\t/* Get number of options entered on the command line */\n\tif (get_activity_nr(act, AO_SELECTED, COUNT_OUTPUTS) > 1)\n\t\treturn TRUE;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (IS_SELECTED(act[i]->options)) {\n\t\t\t/* Special processing for activities using a bitmap */\n\t\t\tif (act[i]->bitmap) {\n\t\t\t\tif (count_bits(act[i]->bitmap->b_array,\n\t\t\t\t\t       BITMAP_SIZE(act[i]->bitmap->b_size)) > 1) {\n\t\t\t\t\trc = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (act[i]->nr_ini > 1) {\n\t\t\t\trc = TRUE;\n\t\t\t}\n\t\t\t/* Stop now since we have only one selected activity */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Print statistics average.\n *\n * IN:\n * @curr\t\tIndex in array for current sample statistics.\n * @read_from_file\tSet to TRUE if stats are read from a system activity\n * \t\t\tdata file.\n * @act_id\t\tActivity that can be displayed, or ~0 for all.\n *\t\t\tRemember that when reading stats from a file, only\n *\t\t\tone activity can be displayed at a time.\n ***************************************************************************\n */\nvoid write_stats_avg(int curr, int read_from_file, unsigned int act_id)\n{\n\tint i;\n\tunsigned long long itv;\n\n\t/* Interval value in 1/100th of a second */\n\titv = get_interval(record_hdr[2].uptime_cs, record_hdr[curr].uptime_cs);\n\n\tstrncpy(timestamp[curr], _(\"Average:\"), sizeof(timestamp[curr]));\n\ttimestamp[curr][sizeof(timestamp[curr]) - 1] = '\\0';\n\tif (DISPLAY_MINMAX(flags)) {\n\t\tstrncpy(timestamp[!curr], _(\"Summary:\"), sizeof(timestamp[!curr]));\n\t\ttimestamp[!curr][sizeof(timestamp[!curr]) - 1] = '\\0';\n\t}\n\telse {\n\t\tmemcpy(timestamp[!curr], timestamp[curr], sizeof(timestamp[!curr]));\n\t}\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif ((act_id != ALL_ACTIVITIES) && (act[i]->id != act_id))\n\t\t\tcontinue;\n\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr[curr] > 0)) {\n\t\t\t/* Display current average activity statistics */\n\t\t\t(*act[i]->f_print_avg)(act[i], 2, curr, itv);\n\t\t}\n\t}\n\n\tif (read_from_file) {\n\t\t/*\n\t\t * Reset number of lines printed only if we read stats\n\t\t * from a system activity file.\n\t\t */\n\t\tavg_count = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Print system statistics.\n * This is called when we read stats either from a file or from sadc.\n *\n * IN:\n * @curr\t\tIndex in array for current sample statistics.\n * @read_from_file\tSet to TRUE if stats are read from a system activity\n * \t\t\tdata file.\n * @use_tm_start\tSet to non-zero (USE_HHMMSS_T or USE_EPOCH_T) if\n *\t\t\toption -s has been used.\n * @use_tm_end\t\tSet to non-zero (USE_HHMMSS_T or USE_EPOCH_T) if\n *\t\t\toption -e has been used.\n * @reset\t\tSet to TRUE if last_uptime variable should be\n * \t\t\treinitialized (used in next_slice() function).\n * @act_id\t\tActivity that can be displayed or ~0 for all.\n *\t\t\tRemember that when reading stats from a file, only\n *\t\t\tone activity can be displayed at a time.\n * @reset_cd\t\tTRUE if static cross_day variable should be reset\n * \t\t\t(see below).\n *\n * OUT:\n * @cnt\t\t\tNumber of remaining lines to display.\n *\n * RETURNS:\n * 1 if stats have been successfully displayed, and 0 otherwise.\n ***************************************************************************\n */\nint write_stats(int curr, int read_from_file, long *cnt, enum time_mode use_tm_start,\n\t\tenum time_mode use_tm_end, int reset, unsigned int act_id, int reset_cd)\n{\n\tint i, prev_hour, rc = 0;\n\tunsigned long long itv;\n\tstatic int cross_day = FALSE;\n\n\tif (reset_cd) {\n\t\t/*\n\t\t * cross_day is a static variable that is set to 1 when the first\n\t\t * record of stats from a new day is read from a unique data file\n\t\t * (in the case where the file contains data from two consecutive\n\t\t * days). When set to TRUE, every following records timestamp will\n\t\t * have its hour value increased by 24.\n\t\t * Yet when a new activity (being read from the file) is going to\n\t\t * be displayed, we start reading the file from the beginning\n\t\t * again, and so cross_day should be reset in this case.\n\t\t */\n\t\tcross_day = FALSE;\n\t}\n\n\t/* Check time (1) */\n\tif (read_from_file && !next_slice(record_hdr[2].uptime_cs, record_hdr[curr].uptime_cs,\n\t\t\t\t\t  reset, interval))\n\t\t/* Not close enough to desired interval */\n\t\treturn 0;\n\n\t/* Get then set previous timestamp */\n\tif (sa_get_record_timestamp_struct(flags, &record_hdr[!curr], &rectime))\n\t\treturn 0;\n\tprev_hour = rectime.tm_time.tm_hour;\n\tset_record_timestamp_string(flags, NULL, timestamp[!curr], TIMESTAMP_LEN, &rectime);\n\n\t/* Get then set current timestamp */\n\tif (sa_get_record_timestamp_struct(flags, &record_hdr[curr], &rectime))\n\t\treturn 0;\n\tset_record_timestamp_string(flags, NULL, timestamp[curr], TIMESTAMP_LEN, &rectime);\n\n\t/*\n\t * Check if we are beginning a new day.\n\t * Use rectime.tm_hour and prev_hour instead of record_hdr[].hour for comparison\n\t * to take into account the current timezone (hours displayed will depend on the\n\t * TZ variable value).\n\t */\n\tif ((use_tm_start == USE_HHMMSS_T) && record_hdr[!curr].ust_time &&\n\t    (record_hdr[curr].ust_time > record_hdr[!curr].ust_time) &&\n\t    (rectime.tm_time.tm_hour < prev_hour)) {\n\t\tcross_day = TRUE;\n\t}\n\n\t/* Check time (2) */\n\tif ((use_tm_end != NO_TIME) && datecmp(&rectime, &tm_end, cross_day) > 0) {\n\t\t/* End time exceeded */\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\n\t/* Get interval value in 1/100th of a second */\n\tget_itv_value(&record_hdr[curr], &record_hdr[!curr], &itv);\n\n\tavg_count++;\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif ((act_id != ALL_ACTIVITIES) && (act[i]->id != act_id))\n\t\t\tcontinue;\n\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr[curr] > 0)) {\n\t\t\t/* Display current activity statistics */\n\t\t\t(*act[i]->f_print)(act[i], !curr, curr, itv);\n\t\t\trc = 1;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/*\n ***************************************************************************\n * Display stats since system startup.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\nvoid write_stats_startup(int curr)\n{\n\tint i;\n\n\t/* Set to 0 previous structures corresponding to boot time */\n\tmemset(&record_hdr[!curr], 0, RECORD_HEADER_SIZE);\n\trecord_hdr[!curr].record_type = R_STATS;\n\trecord_hdr[!curr].hour        = record_hdr[curr].hour;\n\trecord_hdr[!curr].minute      = record_hdr[curr].minute;\n\trecord_hdr[!curr].second      = record_hdr[curr].second;\n\trecord_hdr[!curr].ust_time    = record_hdr[curr].ust_time;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr[curr] > 0)) {\n\t\t\t/*\n\t\t\t * Using nr[curr] and not nr[!curr] below because we initialize\n\t\t\t * reference structures for each structure that has been\n\t\t\t * currently read in memory.\n\t\t\t * No problem with buffers allocation since they all have the\n\t\t\t * same size.\n\t\t\t */\n\t\t\tmemset(act[i]->buf[!curr], 0,\n\t\t\t       (size_t) act[i]->msize * (size_t) act[i]->nr[curr] * (size_t) act[i]->nr2);\n\t\t}\n\t}\n\n\tflags |= S_F_SINCE_BOOT;\n\tdish = TRUE;\n\n\twrite_stats(curr, USE_SADC, &count, NO_TIME, NO_TIME, NO_RESET,\n\t\t    ALL_ACTIVITIES, TRUE);\n\n\texit(0);\n}\n\n/*\n ***************************************************************************\n * Read data sent by the data collector.\n *\n * IN:\n * @size\tNumber of bytes of data to read.\n *\n * OUT:\n * @buffer\tBuffer where data will be saved.\n *\n * RETURNS:\n * 0 if all the data have been successfully read.\n * Otherwise, return the number of bytes left to be read.\n ***************************************************************************\n */\nsize_t sa_read(void *buffer, size_t size)\n{\n\tssize_t n;\n\n\twhile (size) {\n\n\t\tif ((n = read(STDIN_FILENO, buffer, size)) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(2);\n\t\t}\n\n\t\tif (!n)\n\t\t\treturn size;\t/* EOF */\n\n\t\tsize -= n;\n\t\tbuffer = (char *) buffer + n;\n\t}\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Display a restart message (contents of a R_RESTART record).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function (unused here).\n * @cur_date\tDate string of current restart message (unused here).\n * @cur_time\tTime string of current restart message.\n * @my_tz\tCurrent timezone (unused here).\n * @file_hdr\tSystem activity file standard header.\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__printf_funct_t print_sar_restart(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t   char *my_tz, struct file_header *file_hdr,\n\t\t\t\t   struct record_header *record_hdr)\n{\n\tchar restart[64];\n\n\tprintf(\"\\n%-11s\", cur_time);\n\tsprintf(restart, \"  LINUX RESTART\\t(%u CPU)\\n\",\n\t\tfile_hdr->sa_cpu_nr > 1 ? file_hdr->sa_cpu_nr - 1 : 1);\n\tcprintf_s(IS_RESTART, \"%s\", restart);\n\n}\n\n/*\n ***************************************************************************\n * Display a comment (contents of R_COMMENT record).\n *\n * IN:\n * @tab\t\tNumber of tabulations (unused here).\n * @action\tAction expected from current function (unused here).\n * @cur_date\tDate string of current comment (unused here).\n * @cur_time\tTime string of current comment.\n * @my_tz\tCurrent timezone (unused here).\n * @comment\tComment to display.\n * @file_hdr\tSystem activity file standard header (unused here).\n * @record_hdr\tCurrent record header (unused here).\n ***************************************************************************\n */\n__print_funct_t print_sar_comment(int *tab, int action, char *cur_date, char *cur_time,\n\t\t\t\t  char *my_tz, char *comment, struct file_header *file_hdr,\n\t\t\t\t  struct record_header *record_hdr)\n{\n\tprintf(\"%-11s\", cur_time);\n\tcprintf_s(IS_COMMENT, \"  COM %s\\n\", comment);\n}\n\n/*\n ***************************************************************************\n * Read the various statistics sent by the data collector (sadc).\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\nvoid read_sadc_stat_bunch(int curr)\n{\n\tint i, p;\n\n\t/* Read record header (type is always R_STATS since it is read from sadc) */\n\tif (sa_read(&record_hdr[curr], RECORD_HEADER_SIZE)) {\n\t\t/*\n\t\t * SIGINT (sent by sadc) is likely to be received\n\t\t * while we are stuck in sa_read().\n\t\t * If this happens then no data have to be read.\n\t\t */\n\t\tif (sigint_caught)\n\t\t\treturn;\n\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: Record header\\n\", __FUNCTION__);\n#endif\n\t\tprint_read_error(END_OF_DATA_UNEXPECTED);\n\t}\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\n\t\tif (HAS_COUNT_FUNCTION(act[p]->options)) {\n\t\t\tif (sa_read(&(act[p]->nr[curr]), sizeof(__nr_t))) {\n#ifdef DEBUG\n\t\t\t\tfprintf(stderr, \"%s: Nb of items\\n\", __FUNCTION__);\n#endif\n\t\t\t\tprint_read_error(END_OF_DATA_UNEXPECTED);\n\t\t\t}\n\t\t\tif ((act[p]->nr[curr] > act[p]->nr_max) || (act[p]->nr[curr] < 0)) {\n#ifdef DEBUG\n\t\t\t\tfprintf(stderr, \"%s: %s: nr=%d nr_max=%d\\n\",\n\t\t\t\t\t__FUNCTION__, act[p]->name, act[p]->nr[curr], act[p]->nr_max);\n#endif\n\t\t\t\tprint_read_error(INCONSISTENT_INPUT_DATA);\n\t\t\t}\n\t\t\tif (act[p]->nr[curr] > act[p]->nr_allocated) {\n\t\t\t\treallocate_buffers(act[p], act[p]->nr[curr], flags);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * For persistent activities, we must make sure that no statistics\n                         * from a previous iteration remain, especially if the number\n                         * of structures read is smaller than @nr_ini.\n                         */\n                        if (HAS_PERSISTENT_VALUES(act[p]->options)) {\n                            memset(act[p]->buf[curr], 0,\n                                   (size_t) act[p]->fsize * (size_t) act[p]->nr_ini * (size_t) act[p]->nr2);\n                        }\n                }\n\t\tif (sa_read(act[p]->buf[curr],\n\t\t\t    (size_t) act[p]->fsize * (size_t) act[p]->nr[curr] * (size_t) act[p]->nr2)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: Statistics\\n\", __FUNCTION__);\n#endif\n\t\t\tprint_read_error(END_OF_DATA_UNEXPECTED);\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Read current activity's statistics (located between two consecutive\n * LINUX RESTART messages) from file and display them.\n *\n * IN:\n * @ifd\t\tInput file descriptor.\n * @fpos\tPosition in file where reading must start.\n * @curr\tIndex in array for current sample statistics.\n * @rows\tNumber of rows of screen.\n * @act_id\tActivity to display.\n * @file_actlst\tList of activities in file.\n * @file\tName of file being read.\n * @file_magic\tfile_magic structure filled with file magic header data.\n * @rec_hdr_tmp\tTemporary buffer where current record header will be saved.\n * @endian_mismatch\n *\t\tTRUE if file's data don't match current machine's endianness.\n * @arch_64\tTRUE if file's data come from a 64 bit machine.\n * @b_size\tSize of @rec_hdr_tmp buffer.\n *\n * OUT:\n * @curr\tIndex in array for next sample statistics.\n * @cnt\t\tNumber of remaining lines of stats to write.\n * @eosaf\tSet to TRUE if EOF (end of file) has been reached.\n * @reset\tSet to TRUE if last_uptime variable should be reinitialized\n *\t\t(used in next_slice() function).\n ***************************************************************************\n */\nvoid handle_curr_act_stats(int ifd, off_t fpos, int *curr, long *cnt, int *eosaf,\n\t\t\t   int rows, unsigned int act_id, int *reset,\n\t\t\t   struct file_activity *file_actlst, char *file,\n\t\t\t   struct file_magic *file_magic, void *rec_hdr_tmp,\n\t\t\t   int endian_mismatch, int arch_64, size_t b_size)\n{\n\tint p, reset_cd;\n\tunsigned long lines = 0;\n\tunsigned char rtype;\n\tint davg = 0, next, inc = 0;\n\n\tif (lseek(ifd, fpos, SEEK_SET) < fpos) {\n\t\tperror(\"lseek\");\n\t\texit(2);\n\t}\n\n\t/*\n\t * Restore the first stats collected.\n\t * Used to compute the rate displayed on the first line.\n\t */\n\tcopy_structures(act, id_seq, record_hdr, !*curr, 2);\n\n\t*cnt  = count;\n\n\t/* Assess number of lines printed when a bitmap is used */\n\tp = get_activity_position(act, act_id, EXIT_IF_NOT_FOUND);\n\tif (act[p]->bitmap) {\n\t\tinc = count_bits(act[p]->bitmap->b_array,\n\t\t\t\t BITMAP_SIZE(act[p]->bitmap->b_size));\n\t}\n\treset_cd = 1;\n\n\t/* Min/max values should be initialized the first time */\n\tif (DISPLAY_MINMAX(flags)) {\n\t\txinit = TRUE;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Display <count> lines of stats.\n\t\t * Start with reading current sample's record header.\n\t\t */\n\t\t*eosaf = read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[*curr],\n\t\t\t\t\t &file_hdr, arch_64, endian_mismatch, UEOF_STOP, b_size,\n\t\t\t\t\t flags, &sar_fmt);\n\t\trtype = record_hdr[*curr].record_type;\n\n\t\tif ((lines >= rows) || !lines) {\n\t\t\tlines = 0;\n\t\t\tdish = TRUE;\n\t\t}\n\t\telse\n\t\t\tdish = FALSE;\n\n\t\tif (*eosaf || (rtype == R_RESTART))\n\t\t\t/* This is EOF or we have met a LINUX RESTART record: Stop now */\n\t\t\tbreak;\n\n\t\tif (rtype != R_COMMENT) {\n\t\t\t/* Read the extra fields since it's not a special record */\n\t\t\tif (read_file_stat_bunch(act, *curr, ifd, file_hdr.sa_act_nr, file_actlst,\n\t\t\t\t\t\t endian_mismatch, arch_64, file, file_magic, UEOF_STOP, flags))\n\t\t\t\t/* Error or unexpected EOF */\n\t\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\t/* Display comment */\n\t\t\tnext = print_special_record(&record_hdr[*curr], flags,\n\t\t\t\t\t\t    &tm_start, &tm_end, R_COMMENT, ifd,\n\t\t\t\t\t\t    &rectime, file, 0, NULL,\n\t\t\t\t\t\t    file_magic, &file_hdr, act, &sar_fmt,\n\t\t\t\t\t\t    endian_mismatch, arch_64);\n\t\t\tif (next && lines) {\n\t\t\t\t/*\n\t\t\t\t * A line of comment was actually displayed: Count it in the\n\t\t\t\t * total number of displayed lines.\n\t\t\t\t * If no lines of stats had been previously displayed, ignore it\n\t\t\t\t * to make sure the header line will be displayed.\n\t\t\t\t */\n\t\t\t\tlines++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* next is set to 1 when we were close enough to desired interval */\n\t\tnext = write_stats(*curr, USE_SA_FILE, cnt, tm_start.use, tm_end.use,\n\t\t\t\t   *reset, act_id, reset_cd);\n\t\treset_cd = 0;\n\t\tif (next) {\n\t\t\tif (*cnt > 0) {\n\t\t\t\t(*cnt)--;\n\t\t\t}\n\t\t\txinit = FALSE;\n\t\t}\n\n\t\tif (next) {\n\t\t\tdavg++;\n\t\t\t*curr ^= 1;\n\n\t\t\tif (inc) {\n\t\t\t\tlines += inc;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlines += act[p]->nr[*curr];\n\t\t\t}\n\t\t}\n\t\t*reset = FALSE;\n\t}\n\twhile (*cnt);\n\n\t/*\n\t * At this moment, if we had a R_RESTART record, we still haven't read\n\t * the number of CPU following it (nor the possible extra structures).\n\t * But in this case, we always have @cnt != 0.\n\t */\n\n\tif (davg) {\n\t\twrite_stats_avg(!*curr, USE_SA_FILE, act_id);\n\t}\n\n\t*reset = TRUE;\n}\n\n/*\n ***************************************************************************\n * Read header data sent by sadc.\n ***************************************************************************\n */\nvoid read_header_data(void)\n{\n\tstruct file_magic file_magic;\n\tstruct file_activity file_act;\n\tint rc, i, p;\n\tchar version[16];\n\n\t/* Read magic header */\n\trc = sa_read(&file_magic, FILE_MAGIC_SIZE);\n\n\tsprintf(version, \"%d.%d.%d.%d\",\n\t\tfile_magic.sysstat_version,\n\t\tfile_magic.sysstat_patchlevel,\n\t\tfile_magic.sysstat_sublevel,\n\t\tfile_magic.sysstat_extraversion);\n\tif (!file_magic.sysstat_extraversion) {\n\t\tversion[strlen(version) - 2] = '\\0';\n\t}\n\n\tif (rc || (file_magic.sysstat_magic != SYSSTAT_MAGIC) ||\n\t    (file_magic.format_magic != FORMAT_MAGIC) ||\n\t    strcmp(version, VERSION)) {\n\n\t\t/* sar and sadc commands are not consistent */\n\t\tif (!rc && (file_magic.sysstat_magic == SYSSTAT_MAGIC)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Using a wrong data collector from a different sysstat version\\n\"));\n\t\t}\n\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sysstat_magic=%x format_magic=%x version=%s\\n\",\n\t\t\t__FUNCTION__, file_magic.sysstat_magic, file_magic.format_magic, version);\n#endif\n\t\tif (rc == FILE_MAGIC_SIZE) {\n\t\t\t/*\n\t\t\t * No data (0 byte) have been sent by sadc.\n\t\t\t * This is probably because no activities have been collected\n\t\t\t * (\"Requested activities not available\"). In this case, don't\n\t\t\t * display an error message: Exit now.\n\t\t\t */\n\t\t\texit(3);\n\t\t}\n\t\tprint_read_error(INCONSISTENT_INPUT_DATA);\n\t}\n\n\t/*\n\t * Read header data.\n\t * No need to take into account file_magic.header_size. We are sure that\n\t * sadc and sar are from the same version (we have checked FORMAT_MAGIC\n\t * but also VERSION above) and thus the size of file_header is FILE_HEADER_SIZE.\n\t */\n\tif (sa_read(&file_hdr, FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: File header\\n\", __FUNCTION__);\n#endif\n\t\tprint_read_error(END_OF_DATA_UNEXPECTED);\n\t}\n\n\t/* All activities are not necessarily selected, but NR_ACT is a max */\n\tif (file_hdr.sa_act_nr > NR_ACT) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%u\\n\", __FUNCTION__, file_hdr.sa_act_nr);\n#endif\n\t\tprint_read_error(INCONSISTENT_INPUT_DATA);\n\t}\n\n\tif ((file_hdr.act_size != FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr.rec_size != RECORD_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: act_size=%u/%zu rec_size=%u/%zu\\n\", __FUNCTION__,\n\t\t\tfile_hdr.act_size, FILE_ACTIVITY_SIZE, file_hdr.rec_size, RECORD_HEADER_SIZE);\n#endif\n\t\tprint_read_error(INCONSISTENT_INPUT_DATA);\n\t}\n\n\t/* Read activity list */\n\tfor (i = 0; i < file_hdr.sa_act_nr; i++) {\n\n\t\tif (sa_read(&file_act, FILE_ACTIVITY_SIZE)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: File activity (%d)\\n\", __FUNCTION__, i);\n#endif\n\t\t\tprint_read_error(END_OF_DATA_UNEXPECTED);\n\t\t}\n\n\t\tp = get_activity_position(act, file_act.id, RESUME_IF_NOT_FOUND);\n\n\t\tif ((p < 0) || (act[p]->fsize != file_act.size)\n\t\t\t    || (act[p]->gtypes_nr[0] != file_act.types_nr[0])\n\t\t\t    || (act[p]->gtypes_nr[1] != file_act.types_nr[1])\n\t\t\t    || (act[p]->gtypes_nr[2] != file_act.types_nr[2])\n\t\t\t    || (file_act.nr <= 0)\n\t\t\t    || (file_act.nr2 <= 0)\n\t\t\t    || (act[p]->magic != file_act.magic)) {\n#ifdef DEBUG\n\t\t\tif (p < 0) {\n\t\t\t\tfprintf(stderr, \"%s: p=%d\\n\", __FUNCTION__, p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"%s: %s: size=%d/%d magic=%x/%x nr=%d nr2=%d types=%u,%u,%u/%u,%u,%u\\n\",\n\t\t\t\t\t__FUNCTION__, act[p]->name, act[p]->fsize, file_act.size,\n\t\t\t\t\tact[p]->magic, file_act.magic, file_act.nr, file_act.nr2,\n\t\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2],\n\t\t\t\t\tfile_act.types_nr[0], file_act.types_nr[1], file_act.types_nr[2]);\n\t\t\t}\n#endif\n\t\t\t/* Remember that we are reading data from sadc and not from a file... */\n\t\t\tprint_read_error(INCONSISTENT_INPUT_DATA);\n\t\t}\n\n\t\tid_seq[i]      = file_act.id;\t/* We necessarily have \"i < NR_ACT\" */\n\t\tact[p]->nr_ini = file_act.nr;\n\t\tact[p]->nr2    = file_act.nr2;\n\t}\n\n\twhile (i < NR_ACT) {\n\t\tid_seq[i++] = 0;\n\t}\n\n\t/* Check that all selected activties are actually sent by sadc */\n\treverse_check_act(file_hdr.sa_act_nr);\n\n\treturn;\n}\n\n/*\n ***************************************************************************\n * Read statistics from a system activity data file.\n *\n * IN:\n * @from_file\tInput file name.\n ***************************************************************************\n */\nvoid read_stats_from_file(char from_file[])\n{\n\tstruct file_magic file_magic;\n\tstruct file_activity *file_actlst = NULL;\n\tchar rec_hdr_tmp[MAX_RECORD_HEADER_SIZE];\n\tint curr = 1, i, p;\n\tint ifd, rtype;\n\tint rows, eosaf = TRUE, reset = FALSE;\n\tlong cnt = 1;\n\toff_t fpos;\n\n\t/* Get window size */\n\trows = get_win_height();\n\n\t/* Read file headers and activity list */\n\tcheck_file_actlst(&ifd, from_file, act, flags, &file_magic, &file_hdr,\n\t\t\t  &file_actlst, id_seq, &endian_mismatch, &arch_64);\n\n\t/* Perform required allocations */\n\tallocate_structures(act, flags);\n\n\t/* Print report header */\n\tprint_report_hdr(flags, &(rectime.tm_time), &file_hdr);\n\n\t/* Read system statistics from file */\n\tdo {\n\t\t/*\n\t\t * If this record is a special (RESTART or COMMENT) one, print it and\n\t\t * (try to) get another one.\n\t\t */\n\t\tdo {\n\t\t\tif (read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[0], &file_hdr,\n\t\t\t\t\t    arch_64, endian_mismatch, UEOF_STOP, sizeof(rec_hdr_tmp), flags, &sar_fmt)) {\n\t\t\t\t/* End of sa data file */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trtype = record_hdr[0].record_type;\n\t\t\tif ((rtype == R_RESTART) || (rtype == R_COMMENT)) {\n\t\t\t\tprint_special_record(&record_hdr[0], flags,\n\t\t\t\t\t\t     &tm_start, &tm_end, rtype, ifd,\n\t\t\t\t\t\t     &rectime, from_file, 0, NULL, &file_magic,\n\t\t\t\t\t\t     &file_hdr, act, &sar_fmt, endian_mismatch, arch_64);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * OK: Previous record was not a special one.\n\t\t\t\t * So read now the extra fields.\n\t\t\t\t */\n\t\t\t\tif (read_file_stat_bunch(act, 0, ifd, file_hdr.sa_act_nr,\n\t\t\t\t\t\t\t file_actlst, endian_mismatch, arch_64,\n\t\t\t\t\t\t\t from_file, &file_magic, UEOF_STOP, flags))\n\t\t\t\t\t/* Possible unexpected EOF */\n\t\t\t\t\treturn;\n\n\t\t\t\tif (sa_get_record_timestamp_struct(flags,\n\t\t\t\t\t\t\t\t   &record_hdr[0], &rectime))\n\t\t\t\t\t/*\n\t\t\t\t\t * An error was detected.\n\t\t\t\t\t * The timestamp hasn't been updated.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\twhile ((rtype == R_RESTART) || (rtype == R_COMMENT) ||\n\t\t       (datecmp(&rectime, &tm_start, FALSE) < 0) ||\n\t\t       (datecmp(&rectime, &tm_end, FALSE) > 0));\n\n\t\t/* Save the first stats collected. Will be used to compute the average */\n\t\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t\treset = TRUE;\t/* Set flag to reset last_uptime variable */\n\n\t\t/* Save current file position */\n\t\tif ((fpos = lseek(ifd, 0, SEEK_CUR)) < 0) {\n\t\t\tperror(\"lseek\");\n\t\t\texit(2);\n\t\t}\n\n\t\t/*\n\t\t * Read and write stats located between two possible Linux restarts.\n\t\t * Activities that should be displayed are saved in id_seq[] array.\n\t\t * Since we are reading from a file, we print all the stats for an\n\t\t * activity before displaying the next activity.\n\t\t * id_seq[] has been created in check_file_actlst(), retaining only\n\t\t * activities known by current sysstat version.\n\t\t */\n\t\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\t\tif (!id_seq[i])\n\t\t\t\tcontinue;\n\n\t\t\tp = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND);\n\t\t\tif (!IS_SELECTED(act[p]->options))\n\t\t\t\tcontinue;\n\n\t\t\tif (!HAS_MULTIPLE_OUTPUTS(act[p]->options)) {\n\t\t\t\thandle_curr_act_stats(ifd, fpos, &curr, &cnt, &eosaf, rows,\n\t\t\t\t\t\t      act[p]->id, &reset, file_actlst,\n\t\t\t\t\t\t      from_file, &file_magic, rec_hdr_tmp,\n\t\t\t\t\t\t      endian_mismatch, arch_64, sizeof(rec_hdr_tmp));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunsigned int optf, msk;\n\n\t\t\t\toptf = act[p]->opt_flags;\n\n\t\t\t\tfor (msk = 1; msk < 0x100; msk <<= 1) {\n\t\t\t\t\tif ((act[p]->opt_flags & 0xff) & msk) {\n\t\t\t\t\t\tact[p]->opt_flags &= (0xffffff00 + msk);\n\n\t\t\t\t\t\thandle_curr_act_stats(ifd, fpos, &curr, &cnt, &eosaf,\n\t\t\t\t\t\t\t\t      rows, act[p]->id, &reset, file_actlst,\n\t\t\t\t\t\t\t\t      from_file, &file_magic, rec_hdr_tmp,\n\t\t\t\t\t\t\t\t      endian_mismatch, arch_64, sizeof(rec_hdr_tmp));\n\t\t\t\t\t\tact[p]->opt_flags = optf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0) {\n\t\t\t/*\n\t\t\t * Go to next Linux restart, if possible.\n\t\t\t * Note: If we have @cnt == 0 then the last record we read was not a R_RESTART one\n\t\t\t * (else we would have had @cnt != 0, i.e. we would have stopped reading previous activity\n\t\t\t * because such a R_RESTART record would have been read, not because all the <count> lines\n\t\t\t * had been printed).\n\t\t\t * Remember @cnt is decremented only when a real line of stats have been displayed\n\t\t\t * (not when a special record has been read).\n\t\t\t */\n\t\t\tdo {\n\t\t\t\t/* Read next record header */\n\t\t\t\teosaf = read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[curr],\n\t\t\t\t\t\t\t&file_hdr, arch_64, endian_mismatch, UEOF_STOP, sizeof(rec_hdr_tmp), flags, &sar_fmt);\n\t\t\t\trtype = record_hdr[curr].record_type;\n\n\t\t\t\tif (eosaf || (rtype == R_RESTART))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (rtype != R_COMMENT) {\n\t\t\t\t\tif (read_file_stat_bunch(act, curr, ifd, file_hdr.sa_act_nr,\n\t\t\t\t\t\t\t\t file_actlst, endian_mismatch, arch_64,\n\t\t\t\t\t\t\t\t from_file, &file_magic, UEOF_STOP, flags))\n\t\t\t\t\t\t/* Possible unexpected EOF */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* This was a COMMENT record: Print it */\n\t\t\t\t\tprint_special_record(&record_hdr[curr], flags,\n\t\t\t\t\t\t\t     &tm_start, &tm_end, R_COMMENT, ifd,\n\t\t\t\t\t\t\t     &rectime, from_file, 0, NULL,\n\t\t\t\t\t\t\t     &file_magic, &file_hdr, act, &sar_fmt,\n\t\t\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (1);\n\t\t}\n\n\t\t/* The last record we read was a RESTART one: Print it */\n\t\tif (!eosaf && (record_hdr[curr].record_type == R_RESTART)) {\n\t\t\tprint_special_record(&record_hdr[curr], flags,\n\t\t\t\t\t     &tm_start, &tm_end, R_RESTART, ifd,\n\t\t\t\t\t     &rectime, from_file, 0, NULL,\n\t\t\t\t\t     &file_magic, &file_hdr, act, &sar_fmt,\n\t\t\t\t\t     endian_mismatch, arch_64);\n\t\t}\n\t}\n\twhile (!eosaf);\n\n\tclose(ifd);\n\n\tfree(file_actlst);\n}\n\n/*\n ***************************************************************************\n * Read statistics sent by sadc, the data collector.\n ***************************************************************************\n */\nvoid read_stats(void)\n{\n\tint curr = 1;\n\tunsigned long lines;\n\tunsigned int rows;\n\tint dis_hdr = 0;\n\n\t/* Don't buffer data if redirected to a pipe... */\n\tsetbuf(stdout, NULL);\n\n\t/* Read stats header */\n\tread_header_data();\n\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES)) {\n\t\t/* Requested activities not available: Exit */\n\t\tprint_collect_error();\n\t}\n\n\t/* Determine if a stat line header has to be displayed */\n\tdis_hdr = check_line_hdr();\n\n\tlines = rows = get_win_height();\n\n\t/* Perform required allocations */\n\tallocate_structures(act, flags);\n\n\t/* No need to init min/max values. Already done in allocate_structures() */\n\txinit = FALSE;\n\n\t/* Print report header */\n\tprint_report_hdr(flags, &(rectime.tm_time), &file_hdr);\n\n\t/* Read system statistics sent by the data collector */\n\tread_sadc_stat_bunch(0);\n\n\tif (!interval) {\n\t\t/* Display stats since boot time and exit */\n\t\twrite_stats_startup(0);\n\t}\n\n\t/* Save the first stats collected. Will be used to compute the average */\n\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tint_act.sa_flags = SA_RESTART;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\t/* Main loop */\n\tdo {\n\n\t\t/* Get stats */\n\t\tread_sadc_stat_bunch(curr);\n\t\tif (sigint_caught) {\n\t\t\t/*\n\t\t\t * SIGINT signal caught (it is sent by sadc).\n\t\t\t * => Display average stats.\n\t\t\t */\n\t\t\tcurr ^= 1; /* No data retrieved from last read */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Print results */\n\t\tif (!dis_hdr) {\n\t\t\tdish = lines / rows;\n\t\t\tif (dish) {\n\t\t\t\tlines %= rows;\n\t\t\t}\n\t\t\tlines++;\n\t\t}\n\t\twrite_stats(curr, USE_SADC, &count, NO_TIME, tm_end.use,\n\t\t\t    NO_RESET, ALL_ACTIVITIES, TRUE);\n\n\t\tif ((tm_end.use != NO_TIME) && (datecmp(&rectime, &tm_end, FALSE) == 0)) {\n\t\t\t/*\n\t\t\t * The last record displayed has reached ending time.\n\t\t\t * Set @count to 0 to keep sadc from saving an additional\n\t\t\t * record on next loop and stop now.\n\t\t\t * This is not perfect anyway: If the last displayed record hasn't\n\t\t\t * reached ending time, but the next one exceeds it, it will not be\n\t\t\t * displayed but will still have been saved in datafile by sadc since\n\t\t\t * the test is made later at display time.\n\t\t\t */\n\t\t\tcount = 0;\n\t\t}\n\n\t\tif (record_hdr[curr].record_type == R_LAST_STATS) {\n\t\t\t/* File rotation is happening: Re-read header data sent by sadc */\n\t\t\tread_header_data();\n\t\t\tallocate_structures(act, flags);\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t}\n\t\tif (count) {\n\t\t\tcurr ^= 1;\n\t\t}\n\t}\n\twhile (count);\n\n\t/*\n\t * Print statistics average.\n\t * At least one line of stats must have been displayed for this.\n\t * (There may be no lines at all if we press Ctrl/C immediately).\n\t */\n\tdish = dis_hdr;\n\tif (avg_count) {\n\t\twrite_stats_avg(curr, USE_SADC, ALL_ACTIVITIES);\n\t}\n}\n\n/*\n ***************************************************************************\n * Main entry to the sar program.\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint i, rc, opt = 1, args_idx = 1, p, q;\n\tint fd[2];\n\tint day_offset = 0;\n\tchar from_file[MAX_FILE_LEN], to_file[MAX_FILE_LEN];\n\tchar ltemp[1024];\n\n\t/* Compute page shift in kB */\n\tget_kb_shift();\n\n\tfrom_file[0] = to_file[0] = '\\0';\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\ttm_start.use = tm_end.use = NO_TIME;\n\n\t/* Allocate and init activity bitmaps */\n\tallocate_bitmaps(act);\n\n\tinit_structures();\n\n\t/* Process options */\n\twhile (opt < argc) {\n\n\t\tif (!strcmp(argv[opt], \"--sadc\")) {\n\t\t\t/* Locate sadc */\n\t\t\twhich_sadc();\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--dev=\", 6)) {\n\t\t\t/* Parse devices entered on the command line */\n\t\t\tp = get_activity_position(act, A_DISK, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_DEV_LEN, &opt, 6, NO_RANGE);\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--fs=\", 5)) {\n\t\t\t/* Parse devices entered on the command line */\n\t\t\tp = get_activity_position(act, A_FS, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_FS_LEN, &opt, 5, NO_RANGE);\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--iface=\", 8)) {\n\t\t\t/* Parse devices entered on the command line */\n\t\t\tp = get_activity_position(act, A_NET_DEV, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_IFACE_LEN, &opt, 8, NO_RANGE);\n\t\t\tq = get_activity_position(act, A_NET_EDEV, EXIT_IF_NOT_FOUND);\n\t\t\tact[q]->item_list = act[p]->item_list;\n\t\t\tact[q]->item_list_sz = act[p]->item_list_sz;\n\t\t\tact[q]->options |= AO_LIST_ON_CMDLINE;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--int=\", 6)) {\n\t\t\t/* Parse interrupts names entered on the command line */\n\t\t\tp = get_activity_position(act, A_IRQ, EXIT_IF_NOT_FOUND);\n\t\t\tparse_sa_devices(argv[opt], act[p], MAX_SA_IRQ_LEN, &opt, 6, NR_IRQS);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--help\")) {\n\t\t\t/* Display help message */\n\t\t\tdisplay_help(argv[0]);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--human\")) {\n\t\t\t/* Display sizes in a human readable format */\n\t\t\tflags |= S_F_UNIT;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"--pretty\")) {\n\t\t\t/* Display an easy-to-read report */\n\t\t\tflags |= S_F_PRETTY;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--dec=\", 6) && (strlen(argv[opt]) == 7)) {\n\t\t\t/* Check that the argument is a digit */\n\t\t\tif (!isdigit(argv[opt][6])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\n\t\t\t/* Get number of decimal places */\n\t\t\tdplaces_nr = atoi(argv[opt] + 6);\n\t\t\tif ((dplaces_nr < 0) || (dplaces_nr > 2)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-D\")) {\n\t\t\t/* Option to tell sar to write to saYYYYMMDD data files */\n\t\t\tflags |= S_F_SA_YYYYMMDD;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-P\")) {\n\t\t\t/* Parse -P option */\n\t\t\tif (parse_sa_P_opt(argv, &opt, &flags, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-V\")) {\n\t\t\tchar *sar_env[] = {ENV_COLORS,\n\t\t\t\t\t   ENV_COLORS_SGR,\n\t\t\t\t\t   ENV_REPEAT_HEADER,\n\t\t\t\t\t   ENV_TIME_DEFTM,\n\t\t\t\t\t   ENV_TIME_FMT};\n#define SAR_ENV_NR\t5\n\t\t\tprint_version(sar_env, SAR_ENV_NR);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\tif (to_file[0]) {\n\t\t\t\t/* Output file already specified */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Save stats to a file */\n\t\t\tif ((argv[++opt]) && strncmp(argv[opt], \"-\", 1) &&\n\t\t\t    (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tstrncpy(to_file, argv[opt++], sizeof(to_file));\n\t\t\t\tto_file[sizeof(to_file) - 1] = '\\0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrcpy(to_file, \"-\");\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-f\")) {\n\t\t\tif (from_file[0] || day_offset) {\n\t\t\t\t/* Input file already specified */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Read stats from a file */\n\t\t\tif ((argv[++opt]) && strncmp(argv[opt], \"-\", 1) &&\n\t\t\t    (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tstrncpy(from_file, argv[opt++], sizeof(from_file));\n\t\t\t\tfrom_file[sizeof(from_file) - 1] = '\\0';\n\t\t\t\t/* Check if this is an alternate directory for sa files */\n\t\t\t\tcheck_alt_sa_dir(from_file, day_offset, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset_default_file(from_file, day_offset, -1);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-s\")) {\n\t\t\t/* Get time start */\n\t\t\tif (parse_timestamp(argv, &opt, &tm_start, DEF_TMSTART, flags)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-e\")) {\n\t\t\t/* Get time end */\n\t\t\tif (parse_timestamp(argv, &opt, &tm_end, DEF_TMEND, flags)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-i\")) {\n\t\t\tif (!argv[++opt] || (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tflags |= S_F_INTERVAL_SET;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-m\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Parse option -m */\n\t\t\tif (parse_sar_m_opt(argv, &opt, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-n\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t/* Parse option -n */\n\t\t\tif (parse_sar_n_opt(argv, &opt, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-q\")) {\n\t\t\tif (!argv[++opt]) {\n\t\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t\t}\n\t\t\t/* Parse option -q */\n\t\t\telse if (parse_sar_q_opt(argv, &opt, act)) {\n\t\t\t\tSELECT_ACTIVITY(A_QUEUE);\n\t\t\t}\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"--unix_time=\", 12)) {\n\t\t\tif (strspn(argv[opt] + 12, DIGITS) != strlen(argv[opt] + 12)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\t__unix_time = atoll(argv[opt++] + 12);\n\t\t}\n#endif\n\t\telse if ((strlen(argv[opt]) > 1) &&\n\t\t\t (strlen(argv[opt]) < 4) &&\n\t\t\t !strncmp(argv[opt], \"-\", 1) &&\n\t\t\t (strspn(argv[opt] + 1, DIGITS) == (strlen(argv[opt]) - 1))) {\n\t\t\tif (from_file[0] || day_offset) {\n\t\t\t\t/* Input file already specified */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tday_offset = atoi(argv[opt++] + 1);\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\t/* Other options not previously tested */\n\t\t\tif ((rc = parse_sar_opt(argv, &opt, act, &flags, C_SAR)) != 0) {\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (interval < 0) {\n\t\t\t/* Get interval */\n\t\t\tif (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t/* Get count value */\n\t\t\tif ((strspn(argv[opt], DIGITS) != strlen(argv[opt])) ||\n\t\t\t    !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\t/* Count parameter already set */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif (count < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Init color strings */\n\tinit_colors();\n\n\t/* 'sar' is equivalent to 'sar -f' */\n\tif ((argc == 1) ||\n\t    (((interval < 0) || INTERVAL_SET(flags)) && !from_file[0] && !to_file[0])) {\n\t\tset_default_file(from_file, day_offset, -1);\n\t}\n\n\tif (check_time_limits(&tm_start, &tm_end)) {\n\t\tusage(argv[0]);\n\t}\n\n\t/*\n\t * Check option dependencies.\n\t */\n\t/* You read from a file OR you write to it... */\n\tif (from_file[0] && to_file[0]) {\n\t\tfprintf(stderr, _(\"-f and -o options are mutually exclusive\\n\"));\n\t\texit(1);\n\t}\n\tif (USE_OPTION_A(flags)) {\n\t\t/* Set -P ALL if needed */\n\t\tset_bitmaps(act, &flags);\n\t}\n\t/* Use time start or option -i only when reading stats from a file */\n\tif (((tm_start.use != NO_TIME) || INTERVAL_SET(flags)) && !from_file[0]) {\n\t\tfprintf(stderr,\n\t\t\t_(\"Not reading from a system activity file (use -f option)\\n\"));\n\t\texit(1);\n\t}\n\t/* Don't print stats since boot time if -o or -f options are used */\n\tif (!interval && (from_file[0] || to_file[0])) {\n\t\tusage(argv[0]);\n\t}\n\n\t/* Cannot enter a day shift with -o option */\n\tif (to_file[0] && day_offset) {\n\t\tusage(argv[0]);\n\t}\n\n\tif (!count) {\n\t\t/*\n\t\t * count parameter not set: Display all the contents of the file\n\t\t * or generate a report continuously.\n\t\t */\n\t\tcount = -1;\n\t}\n\n\t/* Default is CPU activity... */\n\tselect_default_activity(act);\n\n\t/* Check S_TIME_FORMAT variable contents */\n\tif (!is_iso_time_fmt())\n\t\tflags |= S_F_PREFD_TIME_OUTPUT;\n\n\t/* Reading stats from file: */\n\tif (from_file[0]) {\n\t\tif (interval < 0) {\n\t\t\tinterval = 1;\n\t\t}\n\n\t\t/* Read stats from file */\n\t\tread_stats_from_file(from_file);\n\n\t\t/* Free structures and activity bitmaps */\n\t\tfree_bitmaps(act);\n\t\tfree_structures(act);\n\n\t\treturn 0;\n\t}\n\n\t/* Reading stats from sadc: */\n\n\t/* Create anonymous pipe */\n\tif (pipe(fd) == -1) {\n\t\tperror(\"pipe\");\n\t\texit(4);\n\t}\n\n\tswitch (fork()) {\n\n\tcase -1:\n\t\tperror(\"fork\");\n\t\texit(4);\n\t\tbreak;\n\n\tcase 0: /* Child */\n\t\tif (dup2(fd[1], STDOUT_FILENO) < 0) {\n\t\t\tperror(\"dup2\");\n\t\t\texit(4);\n\t\t}\n\t\tCLOSE_ALL(fd);\n\n\t\t/*\n\t\t * Prepare options for sadc.\n\t\t */\n\t\t/* Program name */\n\t\tsalloc(0, SADC);\n\n\t\t/* Interval value */\n\t\tif (interval < 0) {\n\t\t\tusage(argv[0]);\n\t\t}\n\t\telse if (!interval) {\n\t\t\tstrcpy(ltemp, \"1\");\n\t\t\t/*\n\t\t\t * Display stats since system startup: Set <interval> to 1.\n\t\t\t * <count> arg will also be set to 1 below.\n\t\t\t */\n\t\t\tsalloc(args_idx++, ltemp);\n\t\t}\n\t\telse {\n\t\t\tsprintf(ltemp, \"%ld\", interval);\n\t\t}\n\t\tsalloc(args_idx++, ltemp);\n\n\t\t/* Count number */\n\t\tif (count >= 0) {\n\t\t\tsprintf(ltemp, \"%ld\", count + 1);\n\t\t\tsalloc(args_idx++, ltemp);\n\t\t}\n\n#ifdef TEST\n\t\tif (__unix_time) {\n\t\t\tsprintf(ltemp, \"--unix_time=%ld\", __unix_time);\n\t\t\tsalloc(args_idx++, ltemp);\n\t\t}\n#endif\n\t\t/* Flags to be passed to sadc */\n\t\tsalloc(args_idx++, \"-Z\");\n\n\t\t/* Writing data to a file (option -o) */\n\t\tif (to_file[0]) {\n\t\t\t/* Set option -D if entered */\n\t\t\tif (USE_SA_YYYYMMDD(flags)) {\n\t\t\t\tsalloc(args_idx++, \"-D\");\n\t\t\t}\n\t\t\t/* Collect all possible activities (option -S XALL for sadc) */\n\t\t\tsalloc(args_idx++, \"-S\");\n\t\t\tsalloc(args_idx++, K_XALL);\n\t\t\t/* Outfile arg */\n\t\t\tsalloc(args_idx++, to_file);\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * If option -o hasn't been used, then tell sadc\n\t\t\t * to collect only activities that will be displayed.\n\t\t\t */\n\t\t\tsalloc(args_idx++, \"-S\");\n\t\t\tstrcpy(ltemp, K_A_NULL);\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\t\tif (IS_SELECTED(act[i]->options)) {\n\t\t\t\t\tstrcat(ltemp, \",\");\n\t\t\t\t\tstrcat(ltemp, act[i]->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsalloc(args_idx++, ltemp);\n\t\t}\n\n\t\t/* Last arg is NULL */\n\t\targs[args_idx] = NULL;\n\n\t\t/* Call now the data collector */\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: 1.sadc: %s\\n\", __FUNCTION__, SADC_PATH);\n#endif\n\n\t\texecv(SADC_PATH, args);\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: 2.sadc: %s\\n\", __FUNCTION__, SADC);\n#endif\n\t\texecvp(SADC, args);\n\t\t/*\n\t\t * Note: Don't use execl/execlp since we don't have a fixed number of\n\t\t * args to give to sadc.\n\t\t */\n\t\tfprintf(stderr, _(\"Cannot find the data collector (%s)\\n\"), SADC);\n\t\tperror(\"exec\");\n\t\texit(4);\n\t\tbreak;\n\n\tdefault: /* Parent */\n\t\tif (dup2(fd[0], STDIN_FILENO) < 0) {\n\t\t\tperror(\"dup2\");\n\t\t\texit(4);\n\t\t}\n\t\tCLOSE_ALL(fd);\n\n\t\t/* Get now the statistics */\n\t\tread_stats();\n\n\t\tbreak;\n\t}\n\n\t/* Free structures and activity bitmaps */\n\tfree_bitmaps(act);\n\tfree_structures(act);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "svg_stats.c",
          "type": "blob",
          "size": 185.623046875,
          "content": "/*\n * svg_stats.c: Functions used by sadf to display statistics in SVG format.\n * (C) 2016-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <float.h>\n\n#include \"sa.h\"\n#include \"ioconf.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nextern uint64_t flags;\nextern int palette;\n\nunsigned int svg_colors[SVG_COL_PALETTE_NR][SVG_COL_PALETTE_SIZE] =\n\t{{0x00cc00, 0xff00bf, 0x00ffff, 0xff0000,\t/* Default palette */\n\t  0xe85f00, 0x0000ff, 0x006020, 0x7030a0,\n\t  0xffff00, 0x666635, 0xd60093, 0x00bfbf,\n\t  0xcc3300, 0x50040f, 0xffffbf, 0x193d55,\n\t  0x000000, 0xffffff, 0x202020, 0xffff00,\n\t  0xffff00, 0x808080, 0xa52a2a, 0xff0000},\n\n\t {0x000000, 0x1a1aff, 0x1affb2, 0xb21aff,\t/* Custom color palette */\n\t  0x1ab2ff, 0xff1a1a, 0xffb31a, 0xb2ff1a,\n\t  0xefefef, 0x000000, 0x1a1aff, 0x1affb2,\n\t  0xb21aff, 0x1ab2ff, 0xff1a1a, 0xffb31a,\n\t  0xffffff, 0x000000, 0xbebebe, 0x000000,\n\t  0x000000, 0x000000, 0x000000, 0x000000},\n\n\t {0x696969, 0xbebebe, 0x000000, 0xa9a9a9,\t/* Black & white palette */\n\t  0x708090, 0xc0c0c0, 0x808080, 0xd3d3d3,\n\t  0x909090, 0x696969, 0xbebebe, 0x000000,\n\t  0x000000, 0xa9a9a9, 0xc0c0c0, 0x808080,\n\t  0xffffff, 0x000000, 0xbebebe, 0x000000,\n\t  0x000000, 0x000000, 0x000000, 0x000000}};\n\n/*\n ***************************************************************************\n * Find the min and max values of all the graphs that will be drawn in the\n * same view. The graphs have their own min and max values in\n * spmin[pos...pos+n-1] and spmax[pos...pos+n-1].\n *\n * IN:\n * @pos\t\tPosition in array for the first graph extrema value.\n * @n\t\tNumber of graphs to scan (number of metrics in current view).\n * @spmin\tBuffer with min values.\n * @spmax\tBuffer with max values.\n *\n * OUT:\n * @gmin\tGlobal min value found.\n * @gmax\tGlobal max value found.\n ***************************************************************************\n */\nvoid get_global_extrema(int pos, int n, double *spmin, double *spmax,\n\t\t\tdouble *gmin, double *gmax)\n{\n\tint i;\n\n\t/*\n\t * Init global min and max values for current view with\n\t * min and max values for first metric in view.\n\t */\n\t*gmin = *(spmin + pos);\n\t*gmax = *(spmax + pos);\n\n\t/* Now check min and max values of other metrics in current view */\n\tfor (i = 1; i < n; i++) {\n\t\tif (*(spmin + pos + i) < *gmin) {\n\t\t\t*gmin = *(spmin + pos + i);\n\t\t}\n\t\tif (*(spmax + pos + i) > *gmax) {\n\t\t\t*gmax = *(spmax + pos + i);\n\t\t}\n\t}\n}\n\n\n/*\n ***************************************************************************\n * Allocate arrays used to save graphs data.\n * Buffers for min and max values may also be reallocated.\n * @n arrays of chars are allocated for @n graphs to draw. A pointer on this\n * array is returned. This is equivalent to \"char data[][n]\" where each\n * element is of indeterminate size and will contain the graph data (eg.\n * << path d=\"M12,14 L13,16...\" ... >>.\n * The size of element data[i] is given by outsize[i].\n *\n * IN:\n * @a\t\tActivity structure.\n * @n\t\tNumber of graphs to draw for current activity.\n *\n * OUT:\n * @outsize\tArray that will contain the sizes of each element in array\n *\t\tof chars. Equivalent to \"int outsize[n]\" with\n * \t\toutsize[n] = sizeof(data[][n]).\n *\n * RETURNS:\n * Pointer on array of arrays of chars that will contain the graphs data.\n *\n * NB: @min and @max arrays contain values in the same order as the fields\n * in the statistics structure.\n ***************************************************************************\n */\nchar **allocate_graph_lines(struct activity *a, int n, int **outsize)\n{\n\tchar **out;\n\tchar *out_p;\n\tint i;\n\n\t/*\n\t * Allocate an array of pointers. Each of these pointers will\n\t * be an array of chars.\n\t */\n\tif ((out = (char **) malloc(n * sizeof(char *))) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\t/* Allocate array that will contain the size of each array of chars */\n\tif ((*outsize = (int *) malloc(n * sizeof(int))) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\t/* Allocate arrays of chars that will contain graphs data */\n\tfor (i = 0; i < n; i++) {\n\t\tif ((out_p = (char *) malloc(CHUNKSIZE * sizeof(char))) == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(4);\n\t\t}\n\t\t*(out + i) = out_p;\n\t\t*out_p = '\\0';\t\t\t/* Reset string so that it can be safely strncat()'d later */\n\t\t*(*outsize + i) = CHUNKSIZE;\t/* Each array of chars has a default size of CHUNKSIZE */\n\t}\n\n\t/* Reallocate buffers for min and max values if necessary */\n\tif (a->item_list_sz > a->nr_allocated) {\n\t\tallocate_minmax_buf(a, a->item_list_sz, flags);\n\t}\n\n\treturn out;\n}\n\n/*\n ***************************************************************************\n * Save SVG code for current graph.\n *\n * IN:\n * @data\tSVG code to append to current graph definition.\n * @out\t\tPointer on array of chars for current graph definition.\n * @outsize\tSize of array of chars for current graph definition.\n *\n * OUT:\n * @out\t\tPointer on array of chars for current graph definition that\n *\t\thas been updated with the addition of current sample data.\n * @outsize\tArray that containing the (possibly new) sizes of each\n *\t\telement in array of chars.\n ***************************************************************************\n */\nvoid save_svg_data(char *data, char **out, int *outsize)\n{\n\tchar *out_p;\n\tint len;\n\n\tout_p = *out;\n\t/* Determine space left in array */\n\tlen = *outsize - strlen(out_p) - 1;\n\tif (strlen(data) >= len) {\n\t\t/*\n\t\t * If current array of chars doesn't have enough space left\n\t\t * then reallocate it with CHUNKSIZE more bytes.\n\t\t */\n\t\tSREALLOC(out_p, char, *outsize + CHUNKSIZE);\n\t\t*out = out_p;\n\t\t*outsize += CHUNKSIZE;\n\t\tlen += CHUNKSIZE;\n\t}\n\tstrncat(out_p, data, len);\n}\n\n/*\n ***************************************************************************\n * Update line graph definition by appending current X,Y coordinates.\n *\n * IN:\n * @timetag\tTimestamp in seconds since the epoch for current sample\n *\t\tstats. Will be used as X coordinate.\n * @value\tValue of current sample metric. Will be used as Y coordinate.\n * @out\t\tPointer on array of chars for current graph definition.\n * @outsize\tSize of array of chars for current graph definition.\n * @restart\tSet to TRUE if a RESTART record has been read since the last\n * \t\tstatistics sample.\n *\n * OUT:\n * @out\t\tPointer on array of chars for current graph definition that\n *\t\thas been updated with the addition of current sample data.\n * @outsize\tArray that containing the (possibly new) sizes of each\n *\t\telement in array of chars.\n ***************************************************************************\n */\nvoid lnappend(unsigned long long timetag, double value, char **out, int *outsize,\n\t      int restart)\n{\n\tchar data[128];\n\n\t/* Prepare additional graph definition data */\n\tsnprintf(data, sizeof(data), \" %c%llu,%.2f\", restart ? 'M' : 'L', timetag, value);\n\tdata[sizeof(data) - 1] = '\\0';\n\n\tsave_svg_data(data, out, outsize);\n}\n\n/*\n ***************************************************************************\n * Update line graph definition by appending current X,Y coordinates. Use\n * (unsigned long) integer values here.\n *\n * IN:\n * @timetag\tTimestamp in seconds since the epoch for current sample\n *\t\tstats. Will be used as X coordinate.\n * @value\tValue of current sample metric. Will be used as Y coordinate.\n * @out\t\tPointer on array of chars for current graph definition.\n * @outsize\tSize of array of chars for current graph definition.\n * @restart\tSet to TRUE if a RESTART record has been read since the last\n * \t\tstatistics sample.\n *\n * OUT:\n * @out\t\tPointer on array of chars for current graph definition that\n *\t\thas been updated with the addition of current sample data.\n * @outsize\tArray that containing the (possibly new) sizes of each\n *\t\telement in array of chars.\n ***************************************************************************\n */\nvoid lniappend(unsigned long long timetag, unsigned long long value, char **out,\n\t       int *outsize, int restart)\n{\n\tchar data[128];\n\n\t/* Prepare additional graph definition data */\n\tsnprintf(data, sizeof(data), \" %c%llu,%llu\", restart ? 'M' : 'L', timetag, value);\n\tdata[sizeof(data) - 1] = '\\0';\n\n\tsave_svg_data(data, out, outsize);\n}\n\n/*\n ***************************************************************************\n * Update bar graph definition by adding a new rectangle.\n *\n * IN:\n * @timetag\tTimestamp in seconds since the epoch for current sample\n *\t\tstats. Will be used as X coordinate.\n * @value\tValue of current sample metric. Will be used as rectangle\n *\t\theight.\n * @offset\tOffset for Y coordinate.\n * @out\t\tPointer on array of chars for current graph definition.\n * @outsize\tSize of array of chars for current graph definition.\n * @dt\t\tInterval of time in seconds between current and previous\n * \t\tsample.\n * @hval\tTRUE if value may be greater than 100%.\n *\n * OUT:\n * @out\t\tPointer on array of chars for current graph definition that\n *\t\thas been updated with the addition of current sample data.\n * @outsize\tArray that containing the (possibly new) sizes of each\n *\t\telement in array of chars.\n ***************************************************************************\n */\nvoid brappend(unsigned long long timetag, double offset, double value, char **out,\n\t      int *outsize, unsigned long long dt, int hval)\n{\n\tchar data[128];\n\tunsigned long long t = 0;\n\n\t/* Prepare additional graph definition data */\n\tif ((value == 0.0) || (dt == 0))\n\t\t/* Don't draw a flat rectangle! */\n\t\treturn;\n\tif (dt < timetag) {\n\t\tt = timetag - dt;\n\t}\n\n\tsnprintf(data, sizeof(data), \"<rect x=\\\"%llu\\\" y=\\\"%.2f\\\" height=\\\"%.2f\\\" width=\\\"%llu\\\"/>\",\n\t\t t,\n\t\t hval ? offset : MINIMUM(offset, 100.0),\n\t\t hval ? value : MINIMUM(value, (100.0 - offset)),\n\t\t dt);\n\tdata[sizeof(data) - 1] = '\\0';\n\n\tsave_svg_data(data, out, outsize);\n}\n\n/*\n ***************************************************************************\n * Update CPU graph and min/max values for each metric.\n *\n * IN:\n * @timetag\tTimestamp in seconds since the epoch for current sample\n *\t\tstats. Will be used as X coordinate.\n * @offset\tOffset for Y coordinate.\n * @value\tValue of current CPU metric. Will be used as rectangle\n *\t\theight.\n * @out\t\tPointer on array of chars for current graph definition.\n * @outsize\tSize of array of chars for current graph definition.\n * @dt\t\tInterval of time in seconds between current and previous\n * \t\tsample.\n * @spmin\tMin value already found for this CPU metric.\n * @spmax\tMax value already found for this CPU metric.\n *\n * OUT:\n * @offset\tNew offset value, to use to draw next rectangle\n * @out\t\tPointer on array of chars for current graph definition that\n *\t\thas been updated with the addition of current sample data.\n * @outsize\tArray that containing the (possibly new) sizes of each\n *\t\telement in array of chars.\n ***************************************************************************\n */\nvoid cpuappend(unsigned long long timetag, double *offset, double value, char **out,\n\t       int *outsize, unsigned long long dt, double *spmin, double *spmax)\n{\n\t/* Save min and max values */\n\tif (value < *spmin) {\n\t\t*spmin = value;\n\t}\n\tif (value > *spmax) {\n\t\t*spmax = value;\n\t}\n\t/* Prepare additional graph definition data */\n\tbrappend(timetag, *offset, value, out, outsize, dt, FALSE);\n\n\t*offset += value;\n}\n\n/*\n ***************************************************************************\n * Update rectangular graph and min/max values.\n *\n * IN:\n * @timetag\tTimestamp in seconds since the epoch for current sample\n *\t\tstats. Will be used as X coordinate.\n * @p_value\tMetric value for previous sample\n * @value\tMetric value for current sample.\n * @out\t\tPointer on array of chars for current graph definition.\n * @outsize\tSize of array of chars for current graph definition.\n * @restart\tSet to TRUE if a RESTART record has been read since the last\n * \t\tstatistics sample.\n * @dt\t\tInterval of time in seconds between current and previous\n * \t\tsample.\n * @spmin\tMin value already found for this metric.\n * @spmax\tMax value already found for this metric.\n *\n * OUT:\n * @out\t\tPointer on array of chars for current graph definition that\n *\t\thas been updated with the addition of current sample data.\n * @outsize\tArray that containing the (possibly new) sizes of each\n *\t\telement in array of chars.\n * @spmin\tMin value for this metric.\n * @spmax\tMax value for this metric.\n ***************************************************************************\n */\nvoid recappend(unsigned long long timetag, double p_value, double value, char **out,\n\t       int *outsize, int restart, unsigned long long dt,\n\t       double *spmin, double *spmax)\n{\n\tchar data[512], data1[128], data2[128];\n\tunsigned long long t = 0;\n\n\t/* Save min and max values */\n\tif (value < *spmin) {\n\t\t*spmin = value;\n\t}\n\tif (value > *spmax) {\n\t\t*spmax = value;\n\t}\n\tif (dt < timetag) {\n\t\tt = timetag -dt;\n\t}\n\t/* Prepare additional graph definition data */\n\tif (restart) {\n\t\tsnprintf(data1, sizeof(data1), \" M%llu,%.2f\", t, p_value);\n\t\tdata1[sizeof(data1) - 1] = '\\0';\n\t}\n\tif (p_value != value) {\n\t\tsnprintf(data2, sizeof(data2), \" L%llu,%.2f\", timetag, value);\n\t\tdata2[sizeof(data2) - 1] = '\\0';\n\t}\n\tsnprintf(data, sizeof(data), \"%s L%llu,%.2f%s\", restart ? data1 : \"\", timetag, p_value,\n\t\t p_value != value ? data2 : \"\");\n\tdata[sizeof(data) - 1] = '\\0';\n\n\tsave_svg_data(data, out, outsize);\n}\n\n/*\n ***************************************************************************\n * Calculate 10 raised to the power of n.\n *\n * IN:\n * @n\tPower number to use.\n *\n * RETURNS:\n * 10 raised to the power of n.\n ***************************************************************************\n */\nunsigned int pwr10(int n)\n{\n\tint i;\n\tunsigned int e = 1;\n\n\tfor (i = 0; i < n; i++) {\n\t\te = e * 10;\n\t}\n\n\treturn e;\n}\n\n/*\n ***************************************************************************\n * Compute timestamp for next graduation on the X axis.\n *\n * IN:\n * @stamp\tRecord header with timestamp for current graduation.\n * @xpos\tNumber of seconds between two consecutive graduations.\n *\n * OUT:\n * @stamp\tRecord header with timestamp for next graduation that will\n *\t\tbe displayed on the X axis of the graph.\n ***************************************************************************\n */\nvoid compute_next_graduation_timestamp(struct record_header *stamp, long int xpos)\n{\n\tstamp->ust_time += xpos;\n\n\tif (PRINT_TRUE_TIME(flags)) {\n\t\tunsigned int h = stamp->hour,\n\t\t\t     m = stamp->minute,\n\t\t\t     s = stamp->second;\n\n\t\t/* Lines below useful only when option -t used */\n\t\ts += xpos;\n\t\tm += s / 60;\n\t\tstamp->second = s % 60;\n\t\th += m / 60;\n\t\tstamp->minute = m % 60;\n\t\tstamp->hour = h % 24;\n\t}\n}\n\n/*\n ***************************************************************************\n * Autoscale graphs of a given view.\n *\n * IN:\n * @asf_nr\t(Maximum) number of autoscale factors.\n * @group\tNumber of graphs in current view.\n * @g_type\tType of graph (SVG_LINE_GRAPH, SVG_BAR_GRAPH).\n * @pos\t\tPosition in array for the first graph in view.\n * @gmax\tGlobal max value for all graphs in view.\n * @spmax\tArray containing max values for graphs.\n *\n * OUT:\n * @asfactor\tAutoscale factors (one for each graph).\n ***************************************************************************\n */\nvoid gr_autoscaling(unsigned int asfactor[], int asf_nr, int group, enum svg_graph_type g_type,\n\t\t    int pos, double gmax, double *spmax)\n{\n\tint j;\n\n\tfor (j = 0; j < asf_nr; j++) {\n\t\t/* Init autoscale factors */\n\t\tasfactor[j] = 1;\n\t}\n\n\tif (AUTOSCALE_ON(flags) && (group > 1) && gmax && (g_type == SVG_LINE_GRAPH)) {\n\t\tchar val[32];\n\n\t\t/* Autoscaling... */\n\t\tfor (j = 0; (j < group) && (j < asf_nr); j++) {\n\t\t\tif (!*(spmax + pos + j) || (*(spmax + pos + j) == gmax))\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(val, sizeof(val), \"%u\", (unsigned int) (gmax / *(spmax + pos + j)));\n\t\t\tif (strlen(val) > 0) {\n\t\t\t\tasfactor[j] = pwr10(strlen(val) - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display background grid (horizontal lines) and corresponding graduations.\n *\n * IN:\n * @ypos\tGap between two horizontal lines.\n * @yfactor\tScaling factor on Y axis.\n * @lmax\tMax value for current view.\n * @dp\t\tNumber of decimal places for graduations.\n ***************************************************************************\n */\nvoid display_hgrid(double ypos, double yfactor, double lmax, int dp)\n{\n\tint j = 0;\n\tchar stmp[32];\n\n\t/* Print marker in debug mode */\n\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\tprintf(\"<!-- Hgrid -->\\n\");\n\t}\n\n\tdo {\n\t\t/* Display horizontal lines (except on X axis) */\n\t\tif (j > 0) {\n\t\t\tprintf(\"<polyline points=\\\"0,%.2f %d,%.2f\\\" style=\\\"vector-effect: non-scaling-stroke; \"\n\t\t\t       \"stroke: #%06x\\\" transform=\\\"scale(1,%f)\\\"/>\\n\",\n\t\t\t       ypos * j, SVG_G_XSIZE, ypos * j,\n\t\t\t       svg_colors[palette][SVG_COL_GRID_IDX],\n\t\t\t       yfactor);\n\t\t}\n\n\t\t/*\n\t\t * Display graduations.\n\t\t * Use same rounded value for graduation numbers as for grid lines\n\t\t * to make sure they are properly aligned.\n\t\t */\n\t\tsprintf(stmp, \"%.2f\", ypos * j);\n\t\tprintf(\"<text x=\\\"0\\\" y=\\\"%ld\\\" style=\\\"fill: #%06x; stroke: none; font-size: 12px; \"\n\t\t       \"text-anchor: end\\\">%.*f.</text>\\n\",\n\t\t       (long) (atof(stmp) * yfactor),\n\t\t       svg_colors[palette][SVG_COL_AXIS_IDX],\n\t\t       dp, ypos * j);\n\t\tj++;\n\t}\n\twhile ((ypos * j <= lmax) && (j < MAX_HLINES_NR));\n}\n\n/*\n ***************************************************************************\n * Display background grid (vertical lines) and corresponding graduations.\n *\n * IN:\n * @xpos\tGap between two vertical lines.\n * @xfactor\tScaling factor on X axis.\n * @v_gridnr\tDefault number of vertical lines to display. The actual\n *\t\tnumber may vary between this value and 2 times this value.\n * @svg_p\tSVG specific parameters (see draw_activity_graphs() function).\n ***************************************************************************\n */\nvoid display_vgrid(long int xpos, double xfactor, int v_gridnr, struct svg_parm *svg_p)\n{\n\tstruct record_header stamp;\n\tstruct tstamp_ext rectime;\n\tchar cur_time[TIMESTAMP_LEN];\n\tint j;\n\n\tstamp.ust_time = svg_p->ust_time_ref;\n\t/* Also set hour, minute and second in case TRUE_TIME (option -t) requested by user */\n\tstamp.hour = svg_p->hour;\n\tstamp.minute = svg_p->minute;\n\tstamp.second = svg_p->second;\n\n\t/* Print marker in debug mode */\n\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\tprintf(\"<!-- Vgrid -->\\n\");\n\t}\n\n\t/*\n\t * What really matters to know when we should stop drawing vertical lines\n\t * is the time end. v_gridnr is only informative and used to calculate\n\t * the gap between two lines.\n\t */\n\tfor (j = 0; (j <= (2 * v_gridnr)) && (stamp.ust_time <= svg_p->ust_time_end); j++) {\n\n\t\t/* Display vertical lines */\n\t\tif (sa_get_record_timestamp_struct(flags, &stamp, &rectime)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: ust_time: %llu\\n\", __FUNCTION__, stamp.ust_time);\n#endif\n\t\t\texit(1);\n\t\t}\n\t\tset_record_timestamp_string(flags, NULL, cur_time, TIMESTAMP_LEN, &rectime);\n\t\tprintf(\"<polyline points=\\\"%ld,0 %ld,%d\\\" style=\\\"vector-effect: non-scaling-stroke; \"\n\t\t       \"stroke: #%06x\\\" transform=\\\"scale(%f,1)\\\"/>\\n\",\n\t\t       xpos * j, xpos * j, -SVG_G_YSIZE,\n\t\t       svg_colors[palette][SVG_COL_GRID_IDX],\n\t\t       xfactor);\n\t\t/*\n\t\t * Display graduations.\n\t\t * NB: We may have tm_min != 0 if we have more than 24H worth of data in one datafile.\n\t\t * In this case, we should rather display the exact time instead of only the hour.\n\t\t */\n\t\tif (DISPLAY_ONE_DAY(flags) && (rectime.tm_time.tm_min == 0)) {\n\t\t\tprintf(\"<text x=\\\"%ld\\\" y=\\\"15\\\" style=\\\"fill: #%06x; stroke: none; font-size: 14px; \"\n\t\t\t       \"text-anchor: start\\\">%2d:00</text>\\n\",\n\t\t\t       (long) (xpos * j * xfactor) - 15,\n\t\t\t       svg_colors[palette][SVG_COL_AXIS_IDX],\n\t\t\t       rectime.tm_time.tm_hour);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"<text x=\\\"%ld\\\" y=\\\"10\\\" style=\\\"fill: #%06x; stroke: none; font-size: 12px; \"\n\t\t\t       \"text-anchor: start\\\" transform=\\\"rotate(45,%ld,0)\\\">%s</text>\\n\",\n\t\t\t       (long) (xpos * j * xfactor),\n\t\t\t       svg_colors[palette][SVG_COL_AXIS_IDX],\n\t\t\t       (long) (xpos * j * xfactor), cur_time);\n\t\t}\n\n\t\t/* Compute timestamp for next graduation */\n\t\tcompute_next_graduation_timestamp(&stamp, xpos);\n\t}\n\n\tprintf(\"<text x=\\\"-10\\\" y=\\\"30\\\" style=\\\"fill: #%06x; stroke: none; font-size: 12px; \"\n\t       \"text-anchor: end\\\">%s</text>\\n\",\n\t       svg_colors[palette][SVG_COL_INFO_IDX],\n\t       PRINT_LOCAL_TIME(flags) ? svg_p->my_tzname\n\t\t\t\t       : (PRINT_TRUE_TIME(flags) ? svg_p->file_hdr->sa_tzname\n\t\t\t\t\t\t\t\t : \"UTC\"));\n}\n\n/*\n ***************************************************************************\n * Calculate the value on the Y axis between two horizontal lines that will\n * make the graph background grid.\n *\n * IN:\n * @lmax\tMax value reached for this graph.\n *\n * OUT:\n * @dp\t\tNumber of decimal places for Y graduations.\n *\n * RETURNS:\n * Value between two horizontal lines.\n ***************************************************************************\n */\ndouble ygrid(double lmax, int *dp)\n{\n\tchar val[32];\n\tint l;\n\tunsigned int e;\n\tlong n = 0;\n\n\t*dp = 0;\n\tif (lmax == 0) {\n\t\tlmax = 1;\n\t}\n\tn = (long) (lmax / SVG_H_GRIDNR);\n\tif (!n) {\n\t\t*dp = 2;\n\t\treturn (lmax / SVG_H_GRIDNR);\n\t}\n\tsnprintf(val, sizeof(val), \"%ld\", n);\n\tval[sizeof(val) - 1] = '\\0';\n\tl = strlen(val);\n\tif (l < 2)\n\t\treturn n;\n\te = pwr10(l - 1);\n\n\treturn ((double) (((long) (n / e)) * e));\n}\n\n/*\n ***************************************************************************\n * Calculate the value on the X axis between two vertical lines that will\n * make the graph background grid.\n *\n * IN:\n * @timestart\tFirst data timestamp (X coordinate of the first data point).\n * @timeend\tLast data timestamp (X coordinate of the last data point).\n * @v_gridnr\tNumber of vertical lines to display. Its value is normally\n *\t\tSVG_V_GRIDNR, except when option \"oneday\" is used, in which\n *\t\tcase it is set to 12.\n *\n * RETURNS:\n * Value between two vertical lines.\n ***************************************************************************\n */\nlong int xgrid(unsigned long timestart, unsigned long timeend, int v_gridnr)\n{\n\tif ((timeend - timestart) <= v_gridnr)\n\t\treturn 1;\n\telse\n\t\treturn ((timeend - timestart) / v_gridnr);\n}\n\n/*\n ***************************************************************************\n * Free global graphs structures.\n *\n * IN:\n * @out\t\tPointer on array of chars for each graph definition.\n * @outsize\tSize of array of chars for each graph definition.\n ***************************************************************************\n */\nvoid free_graphs(char **out, int *outsize)\n{\n\tif (out) {\n\t\tfree(out);\n\t}\n\tif (outsize) {\n\t\tfree(outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Skip current view where all graphs have only zero values. This function\n * is called when option \"skipempty\" has been used, or when \"No data\" have\n * been found for current view.\n *\n * IN:\n * @out\t\tPointer on array of chars for each graph definition.\n * @pos\t\tPosition of current view in the array of graphs definitions.\n * @group\tNumber of graphs in current view.\n *\n * OUT:\n * @pos\t\tPosition of next view in the array of graphs definitions.\n ***************************************************************************\n */\nvoid skip_current_view(char **out, int *pos, int group)\n{\n\tint j;\n\tchar *out_p;\n\n\tfor (j = 0; j < group; j++) {\n\t\tout_p = *(out + *pos + j);\n\t\tif (out_p) {\n\t\t\t/* Even if not displayed, current graph data have to be freed */\n\t\t\tfree(out_p);\n\t\t}\n\t}\n\t*pos += group;\n}\n\n/*\n * **************************************************************************\n * Display all graphs for current activity.\n *\n * IN:\n * @g_nr\tNumber of views to display.\n * @g_type\tType of graph (SVG_LINE_GRAPH, SVG_BAR_GRAPH) for each view.\n * @title\tTitles for each set of graphs.\n * @g_title\tTitles for each graph.\n * @item_name\tItem (network interface, etc.) name.\n * @group\tIndicate how graphs are grouped together to make sets.\n * @spmin\tArray containing min values for graphs.\n * @spmax\tArray containing max values for graphs.\n * @out\t\tPointer on array of chars for each graph definition.\n * @outsize\tSize of array of chars for each graph definition.\n * @svg_p\tSVG specific parameters: Current views row number (.@graph_no),\n *\t\ttime for the first sample of stats (.@ust_time_first), and\n *\t\ttimes used as start and end values on the X axis\n *\t\t(.@ust_time_ref and .@ust_time_end).\n * @record_hdr\tPointer on record header of current stats sample.\n * @skip_void\tSet to <> 0 if graphs with no data should be skipped.\n *\t\tThis is typicallly used to not display CPU offline on the\n *\t\twhole period.\n * @a\t\tCurrent activity structure.\n * @xid\t\tCurrent activity extra id number.\n *\n * RETURNS:\n * TRUE if at least one graph has been displayed.\n ***************************************************************************\n */\nint draw_activity_graphs(int g_nr, int g_type[], char *title[], char *g_title[], char *item_name,\n\t\t\t int group[], double *spmin, double *spmax, char **out, int *outsize,\n\t\t\t struct svg_parm *svg_p, struct record_header *record_hdr, int skip_void,\n\t\t\t struct activity *a, unsigned int xid)\n{\n\tchar *out_p;\n\tint i, j, dp, pos = 0, views_nr = 0, displayed = FALSE, palpos;\n\tint v_gridnr, xv, yv;\n\tunsigned int asfactor[16];\n\tlong int xpos;\n\tdouble lmax, xfactor, yfactor, ypos, gmin, gmax;\n\tchar val[32], cur_date[TIMESTAMP_LEN];\n\tstruct tm rectime;\n\ttime_t t = svg_p->file_hdr->sa_ust_time;\n\n\t/* Print activity name in debug mode */\n\tif (DISPLAY_DEBUG_MODE(flags) && !svg_p->mock) {\n\t\tprintf(\"<!-- Name: %s -->\\n\", a->name);\n\t}\n\n\t/* For each view which is part of current activity */\n\tfor (i = 0; i < g_nr; i++) {\n\n\t\t/* Print view number in debug mode */\n\t\tif (DISPLAY_DEBUG_MODE(flags) && !svg_p->mock) {\n\t\t\tprintf(\"<!-- View %d -->\\n\", i + 1);\n\t\t}\n\n\t\t/* Get global min and max value for current view */\n\t\tget_global_extrema(pos, group[i], spmin, spmax, &gmin, &gmax);\n\n\t\t/* Don't display empty views if requested */\n\t\tif (SKIP_EMPTY_VIEWS(flags) && (gmax < 0.005)) {\n\t\t\t/* Free graph data and update @pos to go to next view */\n\t\t\tskip_current_view(out, &pos, group[i]);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Skip void graphs.\n\t\t * At present time, this is only used by A_CPU and A_NET_SOFT activities to not\n\t\t * display CPU which are offline on the whole period. We assume that the first\n\t\t * metric in view is enough to determine if the whole view has to be skipped.\n\t\t */\n\t\tif (skip_void && ((*(spmin + pos) == DBL_MAX) || (*(spmax + pos) == -DBL_MAX))) {\n\t\t\tpos += group[i];\t/* Maybe one day, A_CPU will have several views */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!displayed && !svg_p->mock) {\n\t\t\t/* Translate to proper position for current activity */\n\t\t\tprintf(\"<g id=\\\"g%u-%u\\\" transform=\\\"translate(0,%d)\\\">\\n\",\n\t\t\t       a->id, xid,\n\t\t\t       SVG_H_YSIZE + SVG_C_YSIZE * (DISPLAY_TOC(flags)\n\t\t\t       ? svg_p->nr_act_dispd : 0) + SVG_T_YSIZE * svg_p->graph_no);\n\t\t}\n\n\t\t/*\n\t\t * Set @displayed to TRUE even in MOCK mode.\n\t\t * Means that a view would have actually been displayed.\n\t\t * @displayed will be set to 0 before leaving current function in\n\t\t * MOCK mode.\n\t\t */\n\t\tdisplayed = TRUE;\n\n\t\t/* Increment number of views actually displayed */\n\t\tviews_nr++;\n\n\t\tif (svg_p->mock) {\n\t\t\t/* Stop now in MOCK mode: Don't print anything onto the screen */\n\t\t\tpos += group[i];\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Compute top left position of view */\n\t\tif (PACK_VIEWS(flags)) {\n\t\t\txv = (views_nr - 1) * SVG_T_XSIZE;\n\t\t\tyv = 0;\n\t\t}\n\t\telse {\n\t\t\txv = 0;\n\t\t\tyv = (views_nr - 1) * SVG_T_YSIZE;\n\t\t}\n\n\t\t/* Used as index in color palette */\n\t\tpalpos = (palette == SVG_BW_COL_PALETTE ? 0 : pos);\n\n\t\t/* Graph background */\n\t\tprintf(\"<rect x=\\\"%d\\\" y=\\\"%d\\\" height=\\\"%d\\\" width=\\\"%d\\\" fill=\\\"#%06x\\\"/>\\n\",\n\t\t       xv, yv, SVG_V_YSIZE, SVG_V_XSIZE,\n\t\t       svg_colors[palette][SVG_COL_BCKGRD_IDX]);\n\n\t\t/* Graph title */\n\t\tprintf(\"<text x=\\\"%d\\\" y=\\\"%d\\\" style=\\\"fill: #%06x; stroke: none\\\">%s\",\n\t\t       xv, 20 + yv,\n\t\t       svg_colors[palette][SVG_COL_TITLE_IDX],\n\t\t       title[i]);\n\t\tif (item_name) {\n\t\t\tprintf(\" [%s]\", item_name);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"<tspan x=\\\"%d\\\" y=\\\"%d\\\" style=\\\"fill: #%06x; stroke: none; font-size: 12px\\\">\"\n\t\t       \"(Min, Max values)</tspan>\\n</text>\\n\",\n\t\t       xv + 5 + SVG_M_XSIZE + SVG_G_XSIZE, yv + 25,\n\t\t       svg_colors[palette][SVG_COL_INFO_IDX]);\n\n\t\t/*\n\t\t * At least two samples are needed.\n\t\t * And a min and max value should have been found.\n\t\t */\n\t\tif ((record_hdr->ust_time == svg_p->ust_time_first) ||\n\t\t\t(*(spmin + pos) == DBL_MAX) || (*(spmax + pos) == -DBL_MAX)) {\n\t\t\t/* No data found */\n\t\t\tprintf(\"<text x=\\\"%d\\\" y=\\\"%d\\\" style=\\\"fill: #%06x; stroke: none\\\">No data</text>\\n\",\n\t\t\t       xv, yv + SVG_M_YSIZE,\n\t\t\t       svg_colors[palette][SVG_COL_ERROR_IDX]);\n\t\t\tskip_current_view(out, &pos, group[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* X and Y axis */\n\t\tprintf(\"<polyline points=\\\"%d,%d %d,%d %d,%d\\\" style=\\\"fill: #%06x; stroke: #%06x; stroke-width: 2\\\"/>\\n\",\n\t\t       xv + SVG_M_XSIZE, yv + SVG_M_YSIZE,\n\t\t       xv + SVG_M_XSIZE, yv + SVG_M_YSIZE + SVG_G_YSIZE,\n\t\t       xv + SVG_M_XSIZE + SVG_G_XSIZE, yv + SVG_M_YSIZE + SVG_G_YSIZE,\n\t\t       svg_colors[palette][SVG_COL_BCKGRD_IDX],\n\t\t       svg_colors[palette][SVG_COL_AXIS_IDX]);\n\n\t\t/* Autoscaling graphs if needed */\n\t\tgr_autoscaling(asfactor, 16, group[i], g_type[i], pos, gmax, spmax);\n\n\t\t/* Caption */\n\t\tfor (j = 0; j < group[i]; j++) {\n\t\t\t/* Set dp to TRUE (1) if current metric is based on integer values */\n\t\t\tdp = (g_title[pos + j][0] == '~');\n\t\t\tsnprintf(val, sizeof(val), \"x%u \", asfactor[j]);\n\t\t\tprintf(\"<text x=\\\"%d\\\" y=\\\"%d\\\" style=\\\"fill: #%06x; stroke: none; font-size: 12px\\\">\"\n\t\t\t       \"%s %s(%.*f, %.*f)</text>\\n\",\n\t\t\t       xv + 5 + SVG_M_XSIZE + SVG_G_XSIZE, yv + SVG_M_YSIZE + j * 15,\n\t\t\t       svg_colors[palette][(palpos + j) & SVG_COLORS_IDX_MASK], g_title[pos + j] + dp,\n\t\t\t       asfactor[j] == 1 ? \"\" : val,\n\t\t\t       !dp * 2, *(spmin + pos + j) * asfactor[j],\n\t\t\t       !dp * 2, *(spmax + pos + j) * asfactor[j]);\n\t\t}\n\n\t\tif (DISPLAY_INFO(flags)) {\n\t\t\t/* Display additional info (hostname, date) */\n\t\t\tprintf(\"<text x=\\\"%d\\\" y=\\\"%d\\\" \"\n\t\t\t       \"style=\\\"fill: #%06x; text-anchor: end; stroke: none; font-size: 14px\\\">\"\n\t\t\t       \"%s\\n\",\n\t\t\t       xv + SVG_V_XSIZE - 5, yv + SVG_M_YSIZE + SVG_G_YSIZE,\n\t\t\t       svg_colors[palette][SVG_COL_INFO_IDX],\n\t\t\t       svg_p->file_hdr->sa_nodename);\n\n\t\t\t/* Get report date */\n\t\t\tset_report_date(localtime_r(&t, &rectime),\n\t\t\t\t\tcur_date, sizeof(cur_date));\n\t\t\tprintf(\"<tspan x=\\\"%d\\\" y=\\\"%d\\\" \"\n\t\t\t       \"style=\\\"fill: #%06x; text-anchor: end; stroke: none; font-size: 14px\\\">\"\n\t\t\t       \"%s</tspan>\\n</text>\\n\",\n\t\t\t       xv + SVG_V_XSIZE - 5, yv + SVG_M_YSIZE + SVG_G_YSIZE + 14,\n\t\t\t       svg_colors[palette][SVG_COL_INFO_IDX],\n\t\t\t       cur_date);\n\t\t}\n\n\t\t/* Translate to proper position for current graph within current activity */\n\t\tprintf(\"<g transform=\\\"translate(%d,%d)\\\">\\n\",\n\t\t       xv + SVG_M_XSIZE, yv + SVG_M_YSIZE + SVG_G_YSIZE);\n\n\t\t/* Grid */\n\t\tif (g_type[i] == SVG_LINE_GRAPH) {\n\t\t\t/* For line graphs */\n\t\t\tif (!gmax) {\n\t\t\t\t/* If all values are zero then set current max value to 1 */\n\t\t\t\tlmax = 1.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlmax = gmax;\n\t\t\t}\n\t\t\t/* Max value cannot be too small, else Y graduations will be meaningless */\n\t\t\tif (lmax < SVG_H_GRIDNR * 0.01) {\n\t\t\t\tlmax = SVG_H_GRIDNR * 0.01;\n\t\t\t}\n\t\t\typos = ygrid(lmax, &dp);\n\t\t}\n\t\telse {\n\t\t\t/* For bar graphs (used for %values) */\n\t\t\typos = 25.0; \t/* Draw lines at 25%, 50%, 75% and 100% */\n\t\t\tdp = 0;\t\t/* No decimals */\n\n\t\t\t/* Max should be always 100% except for percentage values greater than 100% */\n\t\t\tif (gmax > 100.0) {\n\t\t\t\tlmax = gmax;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlmax = 100.0;\n\t\t\t}\n\t\t}\n\t\tyfactor = (double) -SVG_G_YSIZE / lmax;\n\n\t\t/* Display horizontal lines and graduations */\n\t\tdisplay_hgrid(ypos, yfactor, lmax, dp);\n\n\t\t/* Set number of vertical lines to 12 when option \"oneday\" is used */\n\t\tv_gridnr = DISPLAY_ONE_DAY(flags) ? 12 : SVG_V_GRIDNR;\n\n\t\txpos = xgrid(svg_p->ust_time_ref, svg_p->ust_time_end, v_gridnr);\n\t\txfactor = (double) SVG_G_XSIZE / (svg_p->ust_time_end - svg_p->ust_time_ref);\n\n\t\t/* Display vertical lines and graduations */\n\t\tdisplay_vgrid(xpos, xfactor, v_gridnr, svg_p);\n\n\t\t/* Print marker in debug mode */\n\t\tif (DISPLAY_DEBUG_MODE(flags)) {\n\t\t\tprintf(\"<!-- Graphs -->\\n\");\n\t\t}\n\n\t\t/* Draw current graphs set */\n\t\tfor (j = 0; j < group[i]; j++) {\n\t\t\tout_p = *(out + pos + j);\n\t\t\tif (g_type[i] == SVG_LINE_GRAPH) {\n\t\t\t\t/* Line graphs */\n\t\t\t\tprintf(\"<path d=\\\"%s\\\" \"\n\t\t\t\t       \"style=\\\"vector-effect: non-scaling-stroke; \"\n\t\t\t\t       \"stroke: #%06x; stroke-width: 1; fill-opacity: 0\\\" \"\n\t\t\t\t       \"transform=\\\"scale(%f,%f)\\\"/>\\n\",\n\t\t\t\t       out_p,\n\t\t\t\t       svg_colors[palette][(palpos + j) & SVG_COLORS_IDX_MASK],\n\t\t\t\t       xfactor,\n\t\t\t\t       yfactor * asfactor[j]);\n\t\t\t}\n\t\t\telse if (*out_p) {\t/* Ignore flat bars */\n\t\t\t\t/* Bar graphs */\n\t\t\t\tprintf(\"<g style=\\\"fill: #%06x; stroke: none\\\" transform=\\\"scale(%f,%f)\\\">\\n\",\n\t\t\t\t       svg_colors[palette][(palpos + j) & SVG_COLORS_IDX_MASK], xfactor, yfactor);\n\t\t\t\tprintf(\"%s\\n\", out_p);\n\t\t\t\tprintf(\"</g>\\n\");\n\t\t\t}\n\t\t\tfree(out_p);\n\t\t}\n\t\tprintf(\"</g>\\n\");\n\t\tpos += group[i];\n\t}\n\tif (displayed) {\n\t\tif (!svg_p->mock) {\n\t\t\tprintf(\"</g>\\n\");\n\t\t}\n\t\telse {\n\t\t\tdisplayed = FALSE;\n\t\t}\n\n\t\t/* For next row of views */\n\t\t(svg_p->graph_no) += PACK_VIEWS(flags) ? 1 : views_nr;\n\t}\n\n\treturn displayed;\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart), and time used for the X axis origin\n *\t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n *\t\tUnused here.\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define CPU_ARRAY_SZ\t10\n__print_funct_t svg_print_cpu_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t    unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_cpu *scc, *scp;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tint group1[] = {5};\n\tint group2[] = {9};\n\tint g_type[] = {SVG_BAR_GRAPH};\n\tchar *title[] = {\"CPU utilization\"};\n\tchar *g_title1[] = {\"%user\", \"%nice\", \"%system\", \"%iowait\", \"%steal\", \"%idle\"};\n\tchar *g_title2[] = {\"%usr\", \"%nice\", \"%sys\", \"%iowait\", \"%steal\", \"%irq\", \"%soft\", \"%guest\", \"%gnice\", \"%idle\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tdouble offset;\n\tint i, pos;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, CPU_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tunsigned long long deltot_jiffies = 1;\n\t\tint j, k;\n\n\t\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\t\tif (a->nr[curr] > a->nr_ini) {\n\t\t\ta->nr_ini = a->nr[curr];\n\t\t}\n\n\t\t/*\n\t\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t\t * and look for offline CPU.\n\t\t */\n\t\tif (a->nr_ini > 1) {\n\t\t\tdeltot_jiffies = get_global_cpu_statistics(a, !curr, curr,\n\t\t\t\t\t\t\t\t   flags, offline_cpu_bitmap);\n\t\t}\n\n\t\t/* For each CPU */\n\t\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t\t/* Don't display CPU */\n\t\t\t\tcontinue;\n\n\t\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr]  + i * a->msize);\n\t\t\tscp = (struct stats_cpu *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t\tpos = i * CPU_ARRAY_SZ;\n\t\t\toffset = 0.0;\n\n\t\t\tif (i == 0) {\n\t\t\t\t/* This is CPU \"all\" */\n\t\t\t\tif (a->nr_ini == 1) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is a UP machine. In this case\n\t\t\t\t\t * interval has still not been calculated.\n\t\t\t\t\t */\n\t\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t\t\t}\n\t\t\t\tif (!deltot_jiffies) {\n\t\t\t\t\t/* CPU \"all\" cannot be tickless */\n\t\t\t\t\tdeltot_jiffies = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Recalculate interval for current proc.\n\t\t\t\t * If result is 0 then current CPU is a tickless one.\n\t\t\t\t */\n\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\t\tif (!deltot_jiffies) {\t/* Current CPU is tickless */\n\n\t\t\t\t\tdouble val = 100.0;\t/* Tickless CPU: %idle = 100% */\n\n\t\t\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\t\t\tj  = 5;\t/* -u */\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* DISPLAY_CPU_ALL(a->opt_flags) */\n\t\t\t\t\t\tj = 9;\t/* -u ALL */\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check min/max values for %user, etc. */\n\t\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\t\tsave_minmax(a, pos + k, 0.0);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* %idle */\n\t\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t\t  &offset, val,\n\t\t\t\t\t\t  out + pos + j, outsize + pos + j, svg_p->dt,\n\t\t\t\t\t\t  a->spmin + pos + j, a->spmax + pos + j);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\t/* %user */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies),\n\t\t\t\t\t  out + pos, outsize + pos, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos, a->spmax + pos);\n\n\t\t\t\t/* %nice */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies),\n\t\t\t\t\t  out + pos + 1, outsize + pos + 1, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 1, a->spmax + pos + 1);\n\n\t\t\t\t/* %system */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset,\n\t\t\t\t\t  ll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\t\t      scc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t\t\t\t\t      deltot_jiffies),\n\t\t\t\t\t out + pos + 2, outsize + pos + 2, svg_p->dt,\n\t\t\t\t\t a->spmin + pos + 2, a->spmax + pos + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* %usr */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset,\n\t\t\t\t\t  (scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t\t\t   0.0 :\n\t\t\t\t\t   ll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\t\t       scc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t\t\t  out + pos, outsize + pos, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos, a->spmax + pos);\n\n\t\t\t\t/* %nice */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset,\n\t\t\t\t\t  (scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t\t\t  0.0 :\n\t\t\t\t\t  ll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\t\t      scc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t\t  out + pos + 1, outsize + pos + 1, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 1, a->spmax + pos + 1);\n\n\t\t\t\t/* %sys */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_sys,\n\t\t\t\t\t\t\t       scc->cpu_sys, deltot_jiffies),\n\t\t\t\t\t  out + pos + 2, outsize + pos + 2, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 2, a->spmax + pos + 2);\n\t\t\t}\n\n\t\t\t/* %iowait */\n\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t  &offset, ll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t\t  out + pos + 3, outsize + pos + 3, svg_p->dt,\n\t\t\t\t  a->spmin + pos + 3, a->spmax + pos + 3);\n\t\t\t/* %steal */\n\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t  &offset, ll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t\t  out + pos + 4, outsize + pos + 4, svg_p->dt,\n\t\t\t\t  a->spmin + pos + 4, a->spmax + pos + 4);\n\n\t\t\tif (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\t/* %irq */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies),\n\t\t\t\t\t  out + pos + 5, outsize + pos + 5, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 5, a->spmax + pos + 5);\n\t\t\t\t/* %soft */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies),\n\t\t\t\t\t  out + pos + 6, outsize + pos + 6, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 6, a->spmax + pos + 6);\n\t\t\t\t/* %guest */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies),\n\t\t\t\t\t  out + pos + 7, outsize + pos + 7, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 7, a->spmax + pos + 7);\n\t\t\t\t/* %gnice */\n\t\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t\t  &offset, ll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\t\t  out + pos + 8, outsize + pos + 8, svg_p->dt,\n\t\t\t\t\t  a->spmin + pos + 8, a->spmax + pos + 8);\n\n\t\t\t\tj = 9;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tj = 5;\n\t\t\t}\n\n\t\t\t/* %idle */\n\t\t\tcpuappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t  &offset,\n\t\t\t\t  (scc->cpu_idle < scp->cpu_idle ? 0.0 :\n\t\t\t\t   ll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies)),\n\t\t\t\t  out + pos + j, outsize + pos + j, svg_p->dt,\n\t\t\t\t  a->spmin + pos + j, a->spmax + pos + j);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tint xid = 0, displayed;\n\t\tchar item_name[16];\n\n\t\tif (DISPLAY_IDLE(flags)) {\n\t\t\t/* Include additional %idle field */\n\t\t\tgroup1[0]++;\n\t\t\tgroup2[0]++;\n\t\t}\n\n\t\tfor (i = 0; (i < a->item_list_sz) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tpos = i * CPU_ARRAY_SZ;\n\t\t\tif (!i) {\n\t\t\t\t/* This is CPU \"all\" */\n\t\t\t\tstrcpy(item_name, K_LOWERALL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(item_name, \"%d\", i - 1);\n\t\t\t}\n\n\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\tdisplayed = draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t\t\t title, g_title1, item_name, group1,\n\t\t\t\t\t\t\t\t a->spmin + pos, a->spmax + pos,\n\t\t\t\t\t\t\t\t out + pos, outsize + pos,\n\t\t\t\t\t\t\t\t svg_p, record_hdr, i, a, xid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisplayed = draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t\t\t title, g_title2, item_name, group2,\n\t\t\t\t\t\t\t\t a->spmin + pos, a->spmax + pos,\n\t\t\t\t\t\t\t\t out + pos, outsize + pos,\n\t\t\t\t\t\t\t\t svg_p, record_hdr, i, a, xid);\n\t\t\t}\n\t\t\tif (displayed) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display task creation and context switch statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_pcsw_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t     unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr],\n\t\t*spp = (struct stats_pcsw *) a->buf[!curr];\n\tint group[] = {1, 1};\n\tint g_fields[] = {1, 0};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Task creation\", \"Switching activity\"};\n\tchar *g_title[] = {\"proc/s\",\n\t\t\t   \"cswch/s\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 2, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) spc, (void *) spp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* proc/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->processes, spc->processes, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* cswch/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->context_switch, spc->context_switch, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display swap statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_swap_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t     unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr],\n\t\t*ssp = (struct stats_swap *) a->buf[!curr];\n\tint group[] = {2};\n\tint g_type[] = {SVG_LINE_GRAPH};\n\tchar *title[] = {\"Swap activity\"};\n\tchar *g_title[] = {\"pswpin/s\", \"pswpout/s\" };\n\tint g_fields[] = {0, 1};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 2, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) ssc, (void *) ssp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* pswpin/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(ssp->pswpin, ssc->pswpin, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* pswpout/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(ssp->pswpout, ssc->pswpout, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display paging statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_paging_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr],\n\t\t*spp = (struct stats_paging *) a->buf[!curr];\n\tint group[] = {2, 2, 4, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Paging activity (1)\", \"Paging activity (2)\", \"Paging activity (3)\",\n\t\t\t \"Paging activity (4)\"};\n\tchar *g_title[] = {\"pgpgin/s\", \"pgpgout/s\",\n\t\t\t   \"fault/s\", \"majflt/s\",\n\t\t\t   \"pgfree/s\", \"pgscank/s\", \"pgscand/s\", \"pgsteal/s\",\n\t\t\t   \"pgprom/s\", \"pgdem/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 10, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) spc, (void *) spp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* pgpgin/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgpgin, spc->pgpgin, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* pgpgout/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgpgout, spc->pgpgout, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* fault/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgfault, spc->pgfault, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* majflt/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgmajfault, spc->pgmajfault, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* pgfree/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgfree, spc->pgfree, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* pgscank/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgscan_kswapd, spc->pgscan_kswapd, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* pgscand/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgscan_direct, spc->pgscan_direct, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* pgsteal/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgsteal, spc->pgsteal, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* pgprom/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgpromote, spc->pgpromote, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* pgdem/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(spp->pgdemote, spc->pgdemote, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_io_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t   unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr],\n\t\t*sip = (struct stats_io *) a->buf[!curr];\n\tint group[] = {4, 3};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"I/O and transfer rate statistics (1)\", \"I/O and transfer rate statistics (2)\"};\n\tchar *g_title[] = {\"tps\", \"rtps\", \"wtps\", \"dtps\",\n\t\t\t   \"bread/s\", \"bwrtn/s\", \"bdscd/s\"};\n\t/*\n\t * tps:0, rtps:1, wtps:2, dtps:3, bread/s:4, bwrtn/s:5, bdscd/s:6\n\t * g_fields[]:\n\t *\tdk_drive=0\n\t *\tdk_drive_rio:1\n\t *\tdk_drive_wio:2\n\t *\tdk_drive_rblk:4\n\t *\tdk_drive_wblk:5\n\t *\tdk_drive_dio:3\n\t *\tdk_drive_dblk:6\n\t */\n\tint g_fields[] = {0, 1, 2, 4, 5, 3, 6};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 7, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sic, (void *) sip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/*\n\t\t * If we get negative values, this is probably because\n\t\t * one or more devices/filesystems have been unmounted.\n\t\t * We display 0.0 in this case though we should rather tell\n\t\t * the user that the value cannot be calculated here.\n\t\t */\n\t\t/* tps */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive < sip->dk_drive ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive, sic->dk_drive, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* rtps */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive_rio < sip->dk_drive_rio ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive_rio, sic->dk_drive_rio, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* wtps */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive_wio < sip->dk_drive_wio ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive_wio, sic->dk_drive_wio, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* dtps */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive_dio < sip->dk_drive_dio ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive_dio, sic->dk_drive_dio, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* bread/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive_rblk < sip->dk_drive_rblk ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive_rblk, sic->dk_drive_rblk, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* bwrtn/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive_wblk < sip->dk_drive_wblk ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive_wblk, sic->dk_drive_wblk, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* bdscd/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t sic->dk_drive_dblk < sip->dk_drive_dblk ? 0.0 :\n\t\t\t S_VALUE(sip->dk_drive_dblk, sic->dk_drive_dblk, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @smc\t\tStructure with statistics.\n * @action\tAction expected from current function.\n * @dispall\tTRUE if all memory fields should be displayed.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @record_hdr\tPointer on record header of current stats sample.\n * @xid\t\tCurrent SVG graph number.\n *\n * OUT:\n * @xid\t\tNext SVG graph number.\n ***************************************************************************\n */\nvoid svg_print_ram_memory_stats(struct activity *a, struct stats_memory *smc, int action, int dispall,\n\t\t\t\tstruct svg_parm *svg_p, struct record_header *record_hdr, int *xid)\n{\n\tint group[] = {3, 1, 3, 1, 3, 5};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_BAR_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Memory utilization (1)\", \"Memory utilization (2)\",\n\t\t\t \"Memory utilization (3)\", \"Memory utilization (4)\",\n\t\t\t \"Memory utilization (5)\", \"Memory utilization (6)\"};\n\tchar *g_title[] = {\"MBmemfree\", \"MBavail\", \"MBmemused\", \"%memused\", \"MBbuffers\",\n\t\t\t   \"MBcached\", \"MBcommit\", \"%commit\", \"MBactive\", \"MBinact\",\n\t\t\t   \"MBdirty\", \"MBanonpg\", \"MBslab\", \"MBkstack\", \"MBpgtbl\",\n\t\t\t   \"MBvmused\"};\n\tint g_fields[] = {0, 4, 5, -1, -1, -1, -1, 6, 8, 9, 10, 11, 12, 13, 14, 15, 1};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 16, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tunsigned long long nousedmem;\n\t\tdouble mupct, copct, mu;\n\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) smc, NULL, 0,\n\t\t\t     a->spmin, a->spmax, g_fields);\n\n\t\t/* Compute %memused min/max values */\n\t\tnousedmem = smc->frmkb + smc->bufkb + smc->camkb + smc->slabkb;\n\t\tif (nousedmem > smc->tlmkb) {\n\t\t\tnousedmem = smc->tlmkb;\n\t\t}\n\t\tmupct = smc->tlmkb ? SP_VALUE(nousedmem, smc->tlmkb, smc->tlmkb) : 0.0;\n\t\tsave_minmax(a, 3, mupct);\n\n\t\t/* Compute %commit min/max values */\n\t\tcopct = (smc->tlmkb + smc->tlskb) ?\n\t\t\tSP_VALUE(0, smc->comkb, smc->tlmkb + smc->tlskb) : 0.0;\n\t\tsave_minmax(a, 7, copct);\n\n\t\t/* Compute memused min/max values in MB */\n\t\tmu = ((double) (smc->tlmkb - nousedmem)) / 1024;\n\t\tsave_minmax(a, 2, mu);\n\n\t\t/* MBmemfree */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->frmkb) / 1024,\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* MBmemused */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t mu,\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* MBavail */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->availablekb) / 1024,\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* MBbuffers */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->bufkb) / 1024,\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* MBcached */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->camkb) / 1024,\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* MBcommit */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->comkb) / 1024,\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* MBactive */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->activekb) / 1024,\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* MBinact */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->inactkb) / 1024,\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* MBdirty */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->dirtykb) / 1024,\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t\t/* MBanonpg */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->anonpgkb) / 1024,\n\t\t\t out + 11, outsize + 11, svg_p->restart);\n\t\t/* MBslab */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->slabkb) / 1024,\n\t\t\t out + 12, outsize + 12, svg_p->restart);\n\t\t/* MBkstack */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->kstackkb) / 1024,\n\t\t\t out + 13, outsize + 13, svg_p->restart);\n\t\t/* MBpgtbl */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->pgtblkb) / 1024,\n\t\t\t out + 14, outsize + 14, svg_p->restart);\n\t\t/* MBvmused */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->vmusedkb) / 1024,\n\t\t\t out + 15, outsize + 15, svg_p->restart);\n\t\t/* %memused */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, mupct,\n\t\t\t out + 3, outsize + 3, svg_p->dt, FALSE);\n\t\t/* %commit */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, copct,\n\t\t\t out + 7, outsize + 7, svg_p->dt, TRUE);\n\t}\n\n\tif (action & F_END) {\n\t\tint i;\n\n\t\t/* Conversion kB -> MB */\n\t\tfor (i = 0; i < 17; i++) {\n\t\t\tif (g_fields[i] >= 0) {\n\t\t\t\t*(a->spmin + g_fields[i]) /= 1024;\n\t\t\t\t*(a->spmax + g_fields[i]) /= 1024;\n\t\t\t}\n\t\t}\n\n\t\tif (draw_activity_graphs(dispall ? 6 : 5,\n\t\t\t\t\t g_type, title, g_title, NULL, group,\n\t\t\t\t\t a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t\t FALSE, a, *xid)) {\n\t\t\t(*xid)++;\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @smc\t\tStructure with statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @record_hdr\tPointer on record header of current stats sample.\n * @xid\t\tSVG graph number.\n ***************************************************************************\n */\n__print_funct_t svg_print_swap_memory_stats(struct activity *a, struct stats_memory *smc,\n\t\t\t\t\t    int action, struct svg_parm *svg_p,\n\t\t\t\t\t    struct record_header *record_hdr, int xid)\n{\n\tint group[] = {3, 1, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Swap utilization (1)\", \"Swap utilization (2)\",\n\t\t\t  \"Swap utilization (3)\"};\n\tchar *g_title[] = {\"MBswpfree\", \"MBswpused\", \"MBswpcad\", \"%swpused\",\n\t\t\t    \"%swpcad\"};\n\tint g_fields[] = {-1, -1, -1, -1, 16, -1, 18,\n\t\t\t  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 5, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble supct, scpct, su;\n\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) smc, NULL, 0,\n\t\t\t     a->spmin, a->spmax, g_fields);\n\n\t\t/* Compute %swpused min/max values */\n\t\tsupct = smc->tlskb ?\n\t\t\tSP_VALUE(smc->frskb, smc->tlskb, smc->tlskb) : 0.0;\n\t\tsave_minmax(a, 19, supct);\n\n\t\t/* Compute %swpcad min/max values */\n\t\tscpct = (smc->tlskb - smc->frskb) ?\n\t\t\tSP_VALUE(0, smc->caskb, smc->tlskb - smc->frskb) : 0.0;\n\t\tsave_minmax(a, 20, scpct);\n\n\t\t/* Compute swpused min/max values in MB */\n\t\tsu = ((double) (smc->tlskb - smc->frskb)) / 1024;\n\t\tsave_minmax(a, 17, su);\n\n\t\t/* MBswpfree */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->frskb) / 1024,\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* MBswpused */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t su,\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* MBswpcad */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t ((double) smc->caskb) / 1024,\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* %swpused */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, supct,\n\t\t\t out + 3, outsize + 3, svg_p->dt, FALSE);\n\t\t/* %swpcad */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, scpct,\n\t\t\t out + 4, outsize + 4, svg_p->dt, FALSE);\n\t}\n\n\tif (action & F_END) {\n\t\t/* Conversion kB -> MB */\n\t\t*(a->spmin + 16) /= 1024;\n\t\t*(a->spmax + 16) /= 1024;\n\t\t*(a->spmin + 18) /= 1024;\n\t\t*(a->spmax + 18) /= 1024;\n\n\t\tdraw_activity_graphs(3, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin + 16, a->spmax + 16, out, outsize,\n\t\t\t\t     svg_p, record_hdr, FALSE, a, xid);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display memory statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_memory_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\tstatic int xid = 0;\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\tsvg_print_ram_memory_stats(a, smc, action, DISPLAY_MEM_ALL(a->opt_flags),\n\t\t\t\t\t   svg_p, record_hdr, &xid);\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\tsvg_print_swap_memory_stats(a, smc, action, svg_p, record_hdr, xid);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_ktables_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\tint group[] = {3, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Kernel tables statistics (1)\", \"Kernel tables statistics (2)\"};\n\tchar *g_title[] = {\"~dentunusd\", \"~file-nr\", \"~inode-nr\",\n\t\t\t   \"~pty-nr\"};\n\tint g_fields[] = {1, 2, 0, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 4, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) skc, NULL,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* dentunusd */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) skc->dentry_stat,\n\t\t\t  out, outsize, svg_p->restart);\n\t\t/* file-nr */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) skc->file_used,\n\t\t\t  out + 1, outsize + 1, svg_p->restart);\n\t\t/* inode-nr */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) skc->inode_used,\n\t\t\t  out + 2, outsize + 2, svg_p->restart);\n\t\t/* pty-nr */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) skc->pty_nr,\n\t\t\t  out + 3, outsize + 3, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_queue_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t      unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\tint group[] = {2, 1, 3};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Queue length\", \"Task list statistics\", \"Load average statistics\"};\n\tchar *g_title[] = {\"~runq-sz\", \"~blocked\",\n\t\t\t   \"~plist-sz\",\n\t\t\t   \"ldavg-1\", \"ldavg-5\", \"ldavg-15\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 6, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sqc, NULL,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* runq-sz */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) sqc->nr_running,\n\t\t\t  out, outsize, svg_p->restart);\n\t\t/* blocked */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) sqc->procs_blocked,\n\t\t\t  out + 1, outsize + 1, svg_p->restart);\n\t\t/* plist-sz */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) sqc->nr_threads,\n\t\t\t  out + 2, outsize + 2, svg_p->restart);\n\t\t/* ldavg-1 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) sqc->load_avg_1 / 100,\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* ldavg-5 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) sqc->load_avg_5 / 100,\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* ldavg-15 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) sqc->load_avg_15 / 100,\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\t/* Fix min/max values for load average */\n\t\t*(a->spmin + 3) /= 100; *(a->spmax + 3) /= 100;\n\t\t*(a->spmin + 4) /= 100; *(a->spmax + 4) /= 100;\n\t\t*(a->spmin + 5) /= 100; *(a->spmax + 5) /= 100;\n\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display disk statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define DISK_ARRAY_SZ\t9\n__print_funct_t svg_print_disk_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t     unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_disk *sdc, *sdp, sdpzero;\n\tstruct ext_disk_stats xds;\n\tint group[] = {1, 3, 2, 1, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Block devices statistics (1)\", \"Block devices statistics (2)\",\n\t\t\t \"Block devices statistics (3)\", \"Block devices statistics (4)\",\n\t\t\t \"Block devices statistics (5)\"};\n\tchar *g_title[] = {\"tps\",\n\t\t\t   \"rkB/s\", \"wkB/s\", \"dkB/s\",\n\t\t\t   \"areq-sz\", \"aqu-sz\",\n\t\t\t   \"await\",\n\t\t\t   \"%util\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tchar *dev_name, *item_name;\n\tdouble rkB, wkB, dkB, aqusz;\n\tint i, j, k, pos, posp, restart, *unregistered;\n\n\tif (action & F_BEGIN) {\n\t\t/*\n\t\t * Allocate arrays (#0..7) that will contain the graphs data\n\t\t * Also allocate one additional array (#8) for each disk device:\n\t\t * out + 8 will contain the device name (WWN id, pretty name or devm-n),\n\t\t * outsize + 8 will contain a positive value (TRUE) if the device\n\t\t * has either still not been registered, or has been unregistered.\n\t\t */\n\t\tout = allocate_graph_lines(a, DISK_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tmemset(&sdpzero, 0, STATS_DISK_SIZE);\n\t\t/*\n\t\t * Mark previously registered devices as now\n\t\t * possibly unregistered for all graphs.\n\t\t */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * DISK_ARRAY_SZ + 8;\n\t\t\tif (*unregistered == FALSE) {\n\t\t\t\t*unregistered = MAYBE;\n\t\t\t}\n\t\t}\n\n\t\t/* For each device structure */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\t\t\trestart = svg_p->restart;\n\n\t\t\t/* Get device name  */\n\t\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\t\tif (a->item_list != NULL) {\n\t\t\t\t/* A list of devices has been entered on the command line */\n\t\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t\t/* Device not found */\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Look for corresponding graph */\n\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\titem_name = *(out + k * DISK_ARRAY_SZ + 8);\n\t\t\t\tif (!strcmp(dev_name, item_name))\n\t\t\t\t\t/* Graph found! */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t/* Graph not found: Look for first free entry */\n\t\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\t\titem_name = *(out + k * DISK_ARRAY_SZ + 8);\n\t\t\t\t\tif (!strcmp(item_name, \"\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t\t/* No free graph entry: Ignore it (should never happen) */\n#ifdef DEBUG\n\t\t\t\t\tfprintf(stderr, \"%s: Name=%s major=%u minor=%u\\n\",\n\t\t\t\t\t\t__FUNCTION__, dev_name, sdc->major, sdc->minor);\n#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = k * DISK_ARRAY_SZ;\n\t\t\tunregistered = outsize + pos + 8;\n\t\t\tposp = k * a->xnr;\n\n\t\t\t/*\n\t\t\t * If current device was marked as previously unregistered,\n\t\t\t * then set restart variable to TRUE so that the graph will be\n\t\t\t * discontinuous, and mark it as now registered.\n\t\t\t */\n\t\t\tif (*unregistered == TRUE) {\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\t*unregistered = FALSE;\n\n\t\t\titem_name = *(out + pos + 8);\n\t\t\tif (!item_name[0]) {\n\t\t\t\t/* Save device name (WWN id or pretty name) if not already done */\n\t\t\t\tstrncpy(item_name, dev_name, CHUNKSIZE);\n\t\t\t\titem_name[CHUNKSIZE - 1] = '\\0';\n\t\t\t}\n\n\t\t\tj = check_disk_reg(a, curr, !curr, i);\n\t\t\tif (j < 0) {\n\t\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\t\tsdp = &sdpzero;\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsdp = (struct stats_disk *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t}\n\n\t\t\t/* Check for min/max values */\n\t\t\tsave_minmax(a, posp, sdc->nr_ios < sdp->nr_ios ? 0.0\n\t\t\t\t             : S_VALUE(sdp->nr_ios, sdc->nr_ios, itv));\n\n\t\t\trkB = S_VALUE(sdp->rd_sect, sdc->rd_sect, itv) / 2;\n\t\t\twkB = S_VALUE(sdp->wr_sect, sdc->wr_sect, itv) / 2;\n\t\t\tdkB = S_VALUE(sdp->dc_sect, sdc->dc_sect, itv) / 2;\n\n\t\t\tsave_minmax(a, posp + 1, rkB);\n\t\t\tsave_minmax(a, posp + 2, wkB);\n\t\t\tsave_minmax(a, posp + 3, dkB);\n\n\t\t\tcompute_ext_disk_stats(sdc, sdp, itv, &xds);\n\t\t\tsave_minmax(a, posp + 4, xds.arqsz / 2);\n\n\t\t\taqusz = S_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0;\n\t\t\tsave_minmax(a, posp + 5, aqusz);\n\t\t\tsave_minmax(a, posp + 6, xds.await);\n\t\t\tsave_minmax(a, posp + 7, xds.util / 10.0);\n\n\t\t\t/* tps */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sdp->nr_ios, sdc->nr_ios, itv),\n\t\t\t\t out + pos, outsize + pos, restart);\n\t\t\t/* rkB/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t rkB,\n\t\t\t\t out + pos + 1, outsize + pos + 1, restart);\n\t\t\t/* wkB/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t wkB,\n\t\t\t\t out + pos + 2, outsize + pos + 2, restart);\n\t\t\t/* dkB/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t dkB,\n\t\t\t\t out + pos + 3, outsize + pos + 3, restart);\n\t\t\t/* areq-sz */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t xds.arqsz / 2,\n\t\t\t\t out + pos + 4, outsize + pos + 4, restart);\n\t\t\t/* aqu-sz */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t aqusz,\n\t\t\t\t out + pos + 5, outsize + pos + 5, restart);\n\t\t\t/* await */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t xds.await,\n\t\t\t\t out + pos + 6, outsize + pos + 6, restart);\n\t\t\t/* %util */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, xds.util / 10.0,\n\t\t\t\t out + pos + 7, outsize + pos + 7, svg_p->dt, FALSE);\n\t\t}\n\n\t\t/* Mark devices not seen here as now unregistered */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * DISK_ARRAY_SZ + 8;\n\t\t\tif (*unregistered != FALSE) {\n\t\t\t\t*unregistered = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\t\t\t/* Check if there is something to display */\n\t\t\tpos = i * DISK_ARRAY_SZ;\n\t\t\tif (!**(out + pos))\n\t\t\t\tcontinue;\n\t\t\tposp = i * a->xnr;\n\n\t\t\titem_name = *(out + pos + 8);\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + posp, a->spmax + posp,\n\t\t\t\t\t\t out + pos, outsize + pos,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define NET_DEV_ARRAY_SZ\t9\n__print_funct_t svg_print_net_dev_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_dev *sndc, *sndp, sndzero;\n\tint group[] = {2, 2, 3, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_BAR_GRAPH};\n\tchar *title[] = {\"Network interfaces statistics (1)\", \"Network interfaces statistics (2)\",\n\t\t\t \"Network interfaces statistics (3)\", \"Network interfaces statistics (4)\"};\n\tchar *g_title[] = {\"rxpck/s\", \"txpck/s\",\n\t\t\t   \"rxkB/s\", \"txkB/s\",\n\t\t\t   \"rxcmp/s\", \"txcmp/s\", \"rxmcst/s\",\n\t\t\t   \"%ifutil\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6};\n\tunsigned int local_types_nr[] = {7, 0, 0};\n\tstatic char **out;\n\tstatic int *outsize;\n\tchar *item_name;\n\tint i, j, k, pos, posp, restart, *unregistered;\n\n\tif (action & F_BEGIN) {\n\t\t/*\n\t\t * Allocate arrays (#0..7) that will contain the graphs data\n\t\t * Also allocate one additional array (#8) for each interface:\n\t\t * out + 8 will contain the interface name,\n\t\t * outsize + 8 will contain a positive value (TRUE) if the interface\n\t\t * has either still not been registered, or has been unregistered.\n\t\t */\n\t\tout = allocate_graph_lines(a, NET_DEV_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble rxkb, txkb, ifutil;\n\n\t\tmemset(&sndzero, 0, STATS_NET_DEV_SIZE);\n\t\t/*\n\t\t * Mark previously registered interfaces as now\n\t\t * possibly unregistered for all graphs.\n\t\t */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * NET_DEV_ARRAY_SZ + 8;\n\t\t\tif (*unregistered == FALSE) {\n\t\t\t\t*unregistered = MAYBE;\n\t\t\t}\n\t\t}\n\n\t\t/* For each network interfaces structure */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\t\t\trestart = svg_p->restart;\n\n\t\t\tif (a->item_list != NULL) {\n\t\t\t\t/* A list of devices has been entered on the command line */\n\t\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t\t/* Device not found */\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Look for corresponding graph */\n\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\titem_name = *(out + k * NET_DEV_ARRAY_SZ + 8);\n\t\t\t\tif (!strcmp(sndc->interface, item_name))\n\t\t\t\t\t/* Graph found! */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t/* Graph not found: Look for first free entry */\n\t\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\t\titem_name = *(out + k * NET_DEV_ARRAY_SZ + 8);\n\t\t\t\t\tif (!strcmp(item_name, \"\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t\t/* No free graph entry: Ignore it (should never happen) */\n#ifdef DEBUG\n\t\t\t\t\tfprintf(stderr, \"%s: Name=%s\\n\",\n\t\t\t\t\t\t__FUNCTION__, sndc->interface);\n#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = k * NET_DEV_ARRAY_SZ;\n\t\t\tposp = k * a->xnr;\n\t\t\tunregistered = outsize + pos + 8;\n\n\t\t\tj = check_net_dev_reg(a, curr, !curr, i);\n\t\t\tif (j < 0) {\n\t\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\t\tsndp = &sndzero;\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If current interface was marked as previously unregistered,\n\t\t\t * then set restart variable to TRUE so that the graph will be\n\t\t\t * discontinuous, and mark it as now registered.\n\t\t\t */\n\t\t\tif (*unregistered == TRUE) {\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\t*unregistered = FALSE;\n\n\t\t\titem_name = *(out + pos + 8);\n\t\t\tif (!item_name[0]) {\n\t\t\t\t/* Save network interface name (if not already done) */\n\t\t\t\tstrncpy(item_name, sndc->interface, CHUNKSIZE);\n\t\t\t\titem_name[CHUNKSIZE - 1] = '\\0';\n\t\t\t}\n\n\t\t\t/* Check for min/max values */\n\t\t\tsave_extrema(local_types_nr, (void *) sndc, (void *) sndp,\n\t\t\t\t     itv, a->spmin + posp, a->spmax + posp, g_fields);\n\n\t\t\trxkb = S_VALUE(sndp->rx_bytes, sndc->rx_bytes, itv);\n\t\t\ttxkb = S_VALUE(sndp->tx_bytes, sndc->tx_bytes, itv);\n\n\t\t\tifutil = compute_ifutil(sndc, rxkb, txkb);\n\t\t\tsave_minmax(a, posp + 7, ifutil);\n\n\t\t\t/* rxpck/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sndp->rx_packets, sndc->rx_packets, itv),\n\t\t\t\t out + pos, outsize + pos, restart);\n\t\t\t/* txpck/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sndp->tx_packets, sndc->tx_packets, itv),\n\t\t\t\t out + pos + 1, outsize + pos + 1, restart);\n\t\t\t/* rxkB/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t rxkb / 1024,\n\t\t\t\t out + pos + 2, outsize + pos + 2, restart);\n\t\t\t/* txkB/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t txkb / 1024,\n\t\t\t\t out + pos + 3, outsize + pos + 3, restart);\n\t\t\t/* rxcmp/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sndp->rx_compressed, sndc->rx_compressed, itv),\n\t\t\t\t out + pos + 4, outsize + pos + 4, restart);\n\t\t\t/* txcmp/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sndp->tx_compressed, sndc->tx_compressed, itv),\n\t\t\t\t out + pos + 5, outsize + pos + 5, restart);\n\t\t\t/* rxmcst/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sndp->multicast, sndc->multicast, itv),\n\t\t\t\t out + pos + 6, outsize + pos + 6, restart);\n\t\t\t/* %ifutil */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, ifutil,\n\t\t\t\t out + pos + 7, outsize + pos + 7, svg_p->dt, FALSE);\n\t\t}\n\n\t\t/* Mark interfaces not seen here as now unregistered */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * NET_DEV_ARRAY_SZ + 8;\n\t\t\tif (*unregistered != FALSE) {\n\t\t\t\t*unregistered = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\t\t\t/*\n\t\t\t * Check if there is something to display.\n\t\t\t * Don't test sndc->interface because maybe the network\n\t\t\t * interface has been registered later.\n\t\t\t */\n\t\t\tpos = i * NET_DEV_ARRAY_SZ;\n\t\t\tif (!**(out + pos))\n\t\t\t\tcontinue;\n\t\t\tposp = i * a->xnr;\n\n\t\t\t/* Recalculate min and max values in kB, not in B */\n\t\t\t*(a->spmin + posp + 2) /= 1024;\n\t\t\t*(a->spmax + posp + 2) /= 1024;\n\t\t\t*(a->spmin + posp + 3) /= 1024;\n\t\t\t*(a->spmax + posp + 3) /= 1024;\n\n\t\t\titem_name = *(out + pos + 8);\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + posp, a->spmax + posp,\n\t\t\t\t\t\t out + pos, outsize + pos,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces errors statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define NET_EDEV_ARRAY_SZ\t10\n__print_funct_t svg_print_net_edev_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_edev *snedc, *snedp, snedzero;\n\tint group[] = {2, 2, 2, 3};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH};\n\tchar *title[] = {\"Network interfaces errors statistics (1)\", \"Network interfaces errors statistics (2)\",\n\t\t\t \"Network interfaces errors statistics (3)\", \"Network interfaces errors statistics (4)\"};\n\tchar *g_title[] = {\"rxerr/s\", \"txerr/s\",\n\t\t\t    \"rxdrop/s\", \"txdrop/s\",\n\t\t\t    \"rxfifo/s\", \"txfifo/s\",\n\t\t\t    \"coll/s\", \"txcarr/s\", \"rxfram/s\"};\n\tint g_fields[] = {6, 0, 1, 2, 3, 4, 5, 8, 7};\n\tstatic char **out;\n\tstatic int *outsize;\n\tchar *item_name;\n\tint i, j, k, pos, posp, restart, *unregistered;\n\n\tif (action & F_BEGIN) {\n\t\t/*\n\t\t * Allocate arrays (#0..8) that will contain the graphs data\n\t\t * Also allocate one additional array (#9) for each interface:\n\t\t * out + 9 will contain the interface name,\n\t\t * outsize + 9 will contain a positive value (TRUE) if the interface\n\t\t * has either still not been registered, or has been unregistered.\n\t\t */\n\t\tout = allocate_graph_lines(a, NET_EDEV_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tmemset(&snedzero, 0, STATS_NET_EDEV_SIZE);\n\t\t/*\n\t\t * Mark previously registered interfaces as now\n\t\t * possibly unregistered for all graphs.\n\t\t */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * NET_EDEV_ARRAY_SZ + 9;\n\t\t\tif (*unregistered == FALSE) {\n\t\t\t\t*unregistered = MAYBE;\n\t\t\t}\n\t\t}\n\n\t\t/* For each network interfaces structure */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\t\t\trestart = svg_p->restart;\n\n\t\t\tif (a->item_list != NULL) {\n\t\t\t\t/* A list of devices has been entered on the command line */\n\t\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t\t/* Device not found */\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Look for corresponding graph */\n\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\titem_name = *(out + k * NET_EDEV_ARRAY_SZ + 9);\n\t\t\t\tif (!strcmp(snedc->interface, item_name))\n\t\t\t\t\t/* Graph found! */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t/* Graph not found: Look for first free entry */\n\t\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\t\titem_name = *(out + k * NET_EDEV_ARRAY_SZ + 9);\n\t\t\t\t\tif (!strcmp(item_name, \"\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t\t/* No free graph entry: Ignore it (should never happen) */\n#ifdef DEBUG\n\t\t\t\t\tfprintf(stderr, \"%s: Name=%s\\n\",\n\t\t\t\t\t\t__FUNCTION__, snedc->interface);\n#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = k * NET_EDEV_ARRAY_SZ;\n\t\t\tposp = k * a->xnr;\n\t\t\tunregistered = outsize + pos + 9;\n\n\t\t\tj = check_net_edev_reg(a, curr, !curr, i);\n\t\t\tif (j < 0) {\n\t\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\t\tsnedp = &snedzero;\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If current interface was marked as previously unregistered,\n\t\t\t * then set restart variable to TRUE so that the graph will be\n\t\t\t * discontinuous, and mark it as now registered.\n\t\t\t */\n\t\t\tif (*unregistered == TRUE) {\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\t*unregistered = FALSE;\n\n\t\t\titem_name = *(out + pos + 9);\n\t\t\tif (!item_name[0]) {\n\t\t\t\t/* Save network interface name (if not already done) */\n\t\t\t\tstrncpy(item_name, snedc->interface, CHUNKSIZE);\n\t\t\t\titem_name[CHUNKSIZE - 1] = '\\0';\n\t\t\t}\n\n\t\t\t/* Check for min/max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) snedc, (void *) snedp,\n\t\t\t\t     itv, a->spmin + posp, a->spmax + posp, g_fields);\n\n\t\t\t/* rxerr/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->rx_errors, snedc->rx_errors, itv),\n\t\t\t\t out + pos, outsize + pos, restart);\n\t\t\t/* txerr/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->tx_errors, snedc->tx_errors, itv),\n\t\t\t\t out + pos + 1, outsize + pos + 1, restart);\n\t\t\t/* rxdrop/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->rx_dropped, snedc->rx_dropped, itv),\n\t\t\t\t out + pos + 2, outsize + pos + 2, restart);\n\t\t\t/* txdrop/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->tx_dropped, snedc->tx_dropped, itv),\n\t\t\t\t out + pos + 3, outsize + pos + 3, restart);\n\t\t\t/* rxfifo/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->rx_fifo_errors, snedc->rx_fifo_errors, itv),\n\t\t\t\t out + pos + 4, outsize + pos + 4, restart);\n\t\t\t/* txfifo/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->tx_fifo_errors, snedc->tx_fifo_errors, itv),\n\t\t\t\t out + pos + 5, outsize + pos + 5, restart);\n\t\t\t/* coll/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->collisions, snedc->collisions, itv),\n\t\t\t\t out + pos + 6, outsize + pos + 6, restart);\n\t\t\t/* txcarr/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->tx_carrier_errors, snedc->tx_carrier_errors, itv),\n\t\t\t\t out + pos + 7, outsize + pos + 7, restart);\n\t\t\t/* rxfram/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(snedp->rx_frame_errors, snedc->rx_frame_errors, itv),\n\t\t\t\t out + pos + 8, outsize + pos + 8, restart);\n\t\t}\n\n\t\t/* Mark interfaces not seen here as now unregistered */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * NET_EDEV_ARRAY_SZ + 9;\n\t\t\tif (*unregistered != FALSE) {\n\t\t\t\t*unregistered = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\t\t\t/*\n\t\t\t * Check if there is something to display.\n\t\t\t * Don't test snedc->interface because maybe the network\n\t\t\t * interface has been registered later.\n\t\t\t */\n\t\t\tpos = i * NET_EDEV_ARRAY_SZ;\n\t\t\tif (!**(out + pos))\n\t\t\t\tcontinue;\n\t\t\tposp = i * a->xnr;\n\n\t\t\titem_name = *(out + pos + 9);\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + posp, a->spmax + posp,\n\t\t\t\t\t\t out + pos, outsize + pos,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_nfs_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr],\n\t\t*snnp = (struct stats_net_nfs *) a->buf[!curr];\n\tint group[] = {2, 2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"NFS client statistics (1)\", \"NFS client statistics (2)\",\n\t\t\t \"NFS client statistics (3)\"};\n\tchar *g_title[] = {\"call/s\", \"retrans/s\",\n\t\t\t   \"read/s\", \"write/s\",\n\t\t\t   \"access/s\", \"getatt/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 6, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snnc, (void *) snnp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* call/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snnp->nfs_rpccnt, snnc->nfs_rpccnt, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* retrans/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snnp->nfs_rpcretrans, snnc->nfs_rpcretrans, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* read/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snnp->nfs_readcnt, snnc->nfs_readcnt, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* write/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snnp->nfs_writecnt, snnc->nfs_writecnt, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* access/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snnp->nfs_accesscnt, snnc->nfs_accesscnt, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* getatt/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snnp->nfs_getattcnt, snnc->nfs_getattcnt, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_nfsd_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr],\n\t\t*snndp = (struct stats_net_nfsd *) a->buf[!curr];\n\tint group[] = {2, 3, 2, 2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"NFS server statistics (1)\", \"NFS server statistics (2)\",\n\t\t\t \"NFS server statistics (3)\", \"NFS server statistics (4)\",\n\t\t\t \"NFS server statistics (5)\"};\n\tchar *g_title[] = {\"scall/s\", \"badcall/s\",\n\t\t\t   \"packet/s\", \"udp/s\", \"tcp/s\",\n\t\t\t   \"hit/s\", \"miss/s\",\n\t\t\t   \"sread/s\", \"swrite/s\",\n\t\t\t   \"saccess/s\", \"sgetatt/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 11, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snndc, (void *) snndp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* scall/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_rpccnt, snndc->nfsd_rpccnt, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* badcall/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_rpcbad, snndc->nfsd_rpcbad, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* packet/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_netcnt, snndc->nfsd_netcnt, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* udp/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_netudpcnt, snndc->nfsd_netudpcnt, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* tcp/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_nettcpcnt, snndc->nfsd_nettcpcnt, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* hit/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_rchits, snndc->nfsd_rchits, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* miss/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_rcmisses, snndc->nfsd_rcmisses, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* sread/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_readcnt, snndc->nfsd_readcnt, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* swrite/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_writecnt, snndc->nfsd_writecnt, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* saccess/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_accesscnt, snndc->nfsd_accesscnt, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* sgetatt/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snndp->nfsd_getattcnt, snndc->nfsd_getattcnt, itv),\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display socket statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_sock_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\tint group[] = {1, 5};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"IPv4 sockets statistics (1)\", \"IPv4 sockets statistics (2)\"};\n\tchar *g_title[] = {\"~totsck\",\n\t\t\t   \"~tcpsck\", \"~udpsck\", \"~rawsck\", \"~ip-frag\", \"~tcp-tw\"};\n\tint g_fields[] = {0, 1, 5, 2, 3, 4};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 6, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snsc, NULL,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* totsck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->sock_inuse,\n\t\t\t  out, outsize, svg_p->restart);\n\t\t/* tcpsck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->tcp_inuse,\n\t\t\t  out + 1, outsize + 1, svg_p->restart);\n\t\t/* udpsck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->udp_inuse,\n\t\t\t  out + 2, outsize + 2, svg_p->restart);\n\t\t/* rawsck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->raw_inuse,\n\t\t\t  out + 3, outsize + 3, svg_p->restart);\n\t\t/* ip-frag */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->frag_inuse,\n\t\t\t  out + 4, outsize + 4, svg_p->restart);\n\t\t/* tcp-tw */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->tcp_tw,\n\t\t\t  out + 5, outsize + 5, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv4 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_ip_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip *) a->buf[!curr];\n\tint group[] = {4, 2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"IPv4 traffic statistics (1)\", \"IPv4 traffic statistics (2)\", \"IPv4 traffic statistics (3)\"};\n\tchar *g_title[] = {\"irec/s\", \"fwddgm/s\", \"idel/s\", \"orq/s\",\n\t\t\t   \"asmrq/s\", \"asmok/s\",\n\t\t\t   \"fragok/s\", \"fragcrt/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 8, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* irec/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InReceives, snic->InReceives, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* fwddgm/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->ForwDatagrams, snic->ForwDatagrams, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* idel/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InDelivers, snic->InDelivers, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* orq/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutRequests, snic->OutRequests, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* asmrq/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->ReasmReqds, snic->ReasmReqds, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* asmok/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->ReasmOKs, snic->ReasmOKs, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* fragok/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->FragOKs, snic->FragOKs, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* fragcrt/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->FragCreates, snic->FragCreates, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv4 traffic errors statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_eip_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip *) a->buf[!curr];\n\tint group[] = {3, 2, 3};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"IPv4 traffic errors statistics (1)\", \"IPv4 traffic errors statistics (2)\",\n\t\t\t \"IPv4 traffic errors statistics (3)\"};\n\tchar *g_title[] = {\"ihdrerr/s\", \"iadrerr/s\", \"iukwnpr/s\",\n\t\t\t   \"idisc/s\", \"odisc/s\",\n\t\t\t   \"onort/s\", \"asmf/s\", \"fragf/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 8, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* ihdrerr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InHdrErrors, sneic->InHdrErrors, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* iadrerr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InAddrErrors, sneic->InAddrErrors, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* iukwnpr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InUnknownProtos, sneic->InUnknownProtos, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* idisc/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InDiscards, sneic->InDiscards, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* odisc/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutDiscards, sneic->OutDiscards, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* onort/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutNoRoutes, sneic->OutNoRoutes, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* asmf/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->ReasmFails, sneic->ReasmFails, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* fragf/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->FragFails, sneic->FragFails, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv4 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_icmp_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp *) a->buf[!curr];\n\tint group[] = {2, 4, 4, 4};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH};\n\tchar *title[] = {\"ICMPv4 traffic statistics (1)\", \"ICMPv4 traffic statistics (2)\",\n\t\t\t \"ICMPv4 traffic statistics (3)\", \"ICMPv4 traffic statistics (4)\"};\n\tchar *g_title[] = {\"imsg/s\", \"omsg/s\",\n\t\t\t   \"iech/s\", \"iechr/s\", \"oech/s\", \"oechr/s\",\n\t\t\t   \"itm/s\", \"itmr/s\", \"otm/s\", \"otmr/s\",\n\t\t\t   \"iadrmk/s\", \"iadrmkr/s\", \"oadrmk/s\", \"oadrmkr/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 14, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* imsg/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InMsgs, snic->InMsgs, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* omsg/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutMsgs, snic->OutMsgs, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* iech/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InEchos, snic->InEchos, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* iechr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InEchoReps, snic->InEchoReps, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* oech/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutEchos, snic->OutEchos, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* oechr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutEchoReps, snic->OutEchoReps, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* itm/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InTimestamps, snic->InTimestamps, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* itmr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InTimestampReps, snic->InTimestampReps, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* otm/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutTimestamps, snic->OutTimestamps, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* otmr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutTimestampReps, snic->OutTimestampReps, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* iadrmk/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InAddrMasks, snic->InAddrMasks, itv),\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t\t/* iadrmkr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InAddrMaskReps, snic->InAddrMaskReps, itv),\n\t\t\t out + 11, outsize + 11, svg_p->restart);\n\t\t/* oadrmk/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutAddrMasks, snic->OutAddrMasks, itv),\n\t\t\t out + 12, outsize + 12, svg_p->restart);\n\t\t/* oadrmkr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutAddrMaskReps, snic->OutAddrMaskReps, itv),\n\t\t\t out + 13, outsize + 13, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv4 traffic errors statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_eicmp_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t  unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp *) a->buf[!curr];\n\tint group[] = {2, 2, 2, 2, 2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"ICMPv4 traffic errors statistics (1)\", \"ICMPv4 traffic errors statistics (2)\",\n\t\t\t \"ICMPv4 traffic errors statistics (3)\", \"ICMPv4 traffic errors statistics (4)\",\n\t\t\t \"ICMPv4 traffic errors statistics (5)\", \"ICMPv4 traffic errors statistics (6)\"};\n\tchar *g_title[] = {\"ierr/s\", \"oerr/s\",\n\t\t\t   \"idstunr/s\", \"odstunr/s\",\n\t\t\t   \"itmex/s\", \"otmex/s\",\n\t\t\t   \"iparmpb/s\", \"oparmpb/s\",\n\t\t\t   \"isrcq/s\", \"osrcq/s\",\n\t\t\t   \"iredir/s\", \"oredir/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 12, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* ierr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InErrors, sneic->InErrors, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* oerr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutErrors, sneic->OutErrors, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* idstunr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InDestUnreachs, sneic->InDestUnreachs, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* odstunr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutDestUnreachs, sneic->OutDestUnreachs, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* itmex/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InTimeExcds, sneic->InTimeExcds, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* otmex/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutTimeExcds, sneic->OutTimeExcds, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* iparmpb/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InParmProbs, sneic->InParmProbs, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* oparmpb/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutParmProbs, sneic->OutParmProbs, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* isrcq/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InSrcQuenchs, sneic->InSrcQuenchs, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* osrcq/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutSrcQuenchs, sneic->OutSrcQuenchs, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* iredir/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InRedirects, sneic->InRedirects, itv),\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t\t/* oredir/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutRedirects, sneic->OutRedirects, itv),\n\t\t\t out + 11, outsize + 11, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display TCPv4 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_tcp_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr],\n\t\t*sntp = (struct stats_net_tcp *) a->buf[!curr];\n\tint group[] = {2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"TCPv4 traffic statistics (1)\", \"TCPv4 traffic statistics (2)\"};\n\tchar *g_title[] = {\"active/s\", \"passive/s\",\n\t\t\t   \"iseg/s\", \"oseg/s\"};\n\tint g_fields[] = {0, 1, 2, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 4, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sntc, (void *) sntp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* active/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sntp->ActiveOpens, sntc->ActiveOpens, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* passive/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sntp->PassiveOpens, sntc->PassiveOpens, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* iseg/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sntp->InSegs, sntc->InSegs, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* oseg/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sntp->OutSegs, sntc->OutSegs, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display TCPv4 traffic errors statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_etcp_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr],\n\t\t*snetp = (struct stats_net_etcp *) a->buf[!curr];\n\tint group[] = {2, 3};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"TCPv4 traffic errors statistics (1)\", \"TCPv4 traffic errors statistics (2)\"};\n\tchar *g_title[] = {\"atmptf/s\", \"estres/s\",\n\t\t\t   \"retrseg/s\", \"isegerr/s\", \"orsts/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 5, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snetc, (void *) snetp,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* atmptf/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snetp->AttemptFails, snetc->AttemptFails, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* estres/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snetp->EstabResets, snetc->EstabResets, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* retrseg/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snetp->RetransSegs, snetc->RetransSegs, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* isegerr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snetp->InErrs, snetc->InErrs, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* orsts/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snetp->OutRsts, snetc->OutRsts, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display UDPv4 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_udp_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp *) a->buf[!curr];\n\tint group[] = {2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"UDPv4 traffic statistics (1)\", \"UDPv4 traffic statistics (2)\"};\n\tchar *g_title[] = {\"idgm/s\", \"odgm/s\",\n\t\t\t   \"noport/s\", \"idgmerr/s\"};\n\tint g_fields[] = {0, 1, 2, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 4, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snuc, (void *) snup,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* idgm/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->InDatagrams, snuc->InDatagrams, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* odgm/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->OutDatagrams, snuc->OutDatagrams, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* noport/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->NoPorts, snuc->NoPorts, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* idgmerr/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->InErrors, snuc->InErrors, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPV6 socket statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_sock6_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t  unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\tint group[] = {4};\n\tint g_type[] = {SVG_LINE_GRAPH};\n\tchar *title[] = {\"IPv6 sockets statistics\"};\n\tchar *g_title[] = {\"~tcp6sck\", \"~udp6sck\", \"~raw6sck\", \"~ip6-frag\"};\n\tint g_fields[] = {0, 1, 2, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 4, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snsc, NULL,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\t/* tcp6sck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->tcp6_inuse,\n\t\t\t  out, outsize, svg_p->restart);\n\t\t/* udp6sck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->udp6_inuse,\n\t\t\t  out + 1, outsize + 1, svg_p->restart);\n\t\t/* raw6sck */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->raw6_inuse,\n\t\t\t  out + 2, outsize + 2, svg_p->restart);\n\t\t/* ip6-frag */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) snsc->frag6_inuse,\n\t\t\t  out + 3, outsize + 3, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_ip6_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip6 *) a->buf[!curr];\n\tint group[] = {4, 2, 2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH};\n\tchar *title[] = {\"IPv6 traffic statistics (1)\", \"IPv6 traffic statistics (2)\",\n\t\t\t \"IPv6 traffic statistics (3)\", \"IPv6 traffic statistics (4)\"};\n\tchar *g_title[] = {\"irec6/s\", \"fwddgm6/s\", \"idel6/s\", \"orq6/s\",\n\t\t\t   \"asmrq6/s\", \"asmok6/s\",\n\t\t\t   \"imcpck6/s\", \"omcpck6/s\",\n\t\t\t   \"fragok6/s\", \"fragcr6/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 10, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* irec6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InReceives6, snic->InReceives6, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* fwddgm6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutForwDatagrams6, snic->OutForwDatagrams6, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* idel6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InDelivers6, snic->InDelivers6, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* orq6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutRequests6, snic->OutRequests6, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* asmrq6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->ReasmReqds6, snic->ReasmReqds6, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* asmok6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->ReasmOKs6, snic->ReasmOKs6, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* imcpck6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InMcastPkts6, snic->InMcastPkts6, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* omcpck6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutMcastPkts6, snic->OutMcastPkts6, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* fragok6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->FragOKs6, snic->FragOKs6, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* fragcr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->FragCreates6, snic->FragCreates6, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 traffic errors statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_eip6_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip6 *) a->buf[!curr];\n\tint group[] = {4, 2, 2, 3};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH};\n\tchar *title[] = {\"IPv6 traffic errors statistics (1)\", \"IPv6 traffic errors statistics (2)\",\n\t\t\t \"IPv6 traffic errors statistics (3)\", \"IPv6 traffic errors statistics (4)\",\n\t\t\t \"IPv6 traffic errors statistics (5)\"};\n\tchar *g_title[] = {\"ihdrer6/s\", \"iadrer6/s\", \"iukwnp6/s\", \"i2big6/s\",\n\t\t\t   \"idisc6/s\", \"odisc6/s\",\n\t\t\t   \"inort6/s\", \"onort6/s\",\n\t\t\t   \"asmf6/s\", \"fragf6/s\", \"itrpck6/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 11, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* ihdrer6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InHdrErrors6, sneic->InHdrErrors6, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* iadrer6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InAddrErrors6, sneic->InAddrErrors6, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* iukwnp6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InUnknownProtos6, sneic->InUnknownProtos6, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* i2big6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InTooBigErrors6, sneic->InTooBigErrors6, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* idisc6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InDiscards6, sneic->InDiscards6, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* odisc6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutDiscards6, sneic->OutDiscards6, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* inort6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InNoRoutes6, sneic->InNoRoutes6, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* onort6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutNoRoutes6, sneic->OutNoRoutes6, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* asmf6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->ReasmFails6, sneic->ReasmFails6, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* fragf6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->FragFails6, sneic->FragFails6, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* itrpck6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InTruncatedPkts6, sneic->InTruncatedPkts6, itv),\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_icmp6_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t  unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp6 *) a->buf[!curr];\n\tint group[] = {2, 3, 5, 3, 4};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"ICMPv6 traffic statistics (1)\", \"ICMPv6 traffic statistics (2)\",\n\t\t\t \"ICMPv6 traffic statistics (3)\", \"ICMPv6 traffic statistics (4)\",\n\t\t\t \"ICMPv6 traffic statistics (5)\"};\n\tchar *g_title[] = {\"imsg6/s\", \"omsg6/s\",\n\t\t\t   \"iech6/s\", \"iechr6/s\", \"oechr6/s\",\n\t\t\t   \"igmbq6/s\", \"igmbr6/s\", \"ogmbr6/s\", \"igmbrd6/s\", \"ogmbrd6/s\",\n\t\t\t   \"irtsol6/s\", \"ortsol6/s\", \"irtad6/s\",\n\t\t\t   \"inbsol6/s\", \"onbsol6/s\", \"inbad6/s\", \"onbad6/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 17, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snic, (void *) snip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* imsg6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InMsgs6, snic->InMsgs6, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* omsg6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutMsgs6, snic->OutMsgs6, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* iech6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InEchos6, snic->InEchos6, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* iechr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InEchoReplies6, snic->InEchoReplies6, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* oechr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutEchoReplies6, snic->OutEchoReplies6, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* igmbq6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InGroupMembQueries6, snic->InGroupMembQueries6, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* igmbr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InGroupMembResponses6, snic->InGroupMembResponses6, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* ogmbr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutGroupMembResponses6, snic->OutGroupMembResponses6, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* igmbrd6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InGroupMembReductions6, snic->InGroupMembReductions6, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* ogmbrd6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutGroupMembReductions6, snic->OutGroupMembReductions6, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* irtsol6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InRouterSolicits6, snic->InRouterSolicits6, itv),\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t\t/* ortsol6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutRouterSolicits6, snic->OutRouterSolicits6, itv),\n\t\t\t out + 11, outsize + 11, svg_p->restart);\n\t\t/* irtad6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InRouterAdvertisements6, snic->InRouterAdvertisements6, itv),\n\t\t\t out + 12, outsize + 12, svg_p->restart);\n\t\t/* inbsol6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InNeighborSolicits6, snic->InNeighborSolicits6, itv),\n\t\t\t out + 13, outsize + 13, svg_p->restart);\n\t\t/* onbsol6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutNeighborSolicits6, snic->OutNeighborSolicits6, itv),\n\t\t\t out + 14, outsize + 14, svg_p->restart);\n\t\t/* inbad6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->InNeighborAdvertisements6, snic->InNeighborAdvertisements6, itv),\n\t\t\t out + 15, outsize + 15, svg_p->restart);\n\t\t/* onbad6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snip->OutNeighborAdvertisements6, snic->OutNeighborAdvertisements6, itv),\n\t\t\t out + 16, outsize + 16, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 traffic errors statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_eicmp6_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t   unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp6 *) a->buf[!curr];\n\tint group[] = {1, 2, 2, 2, 2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH,\n\t\t\tSVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"ICMPv6 traffic errors statistics (1)\", \"ICMPv6 traffic errors statistics (2)\",\n\t\t\t \"ICMPv6 traffic errors statistics (3)\", \"ICMPv6 traffic errors statistics (4)\",\n\t\t\t \"ICMPv6 traffic errors statistics (5)\", \"ICMPv6 traffic errors statistics (6)\"};\n\tchar *g_title[] = {\"ierr6/s\",\n\t\t\t   \"idtunr6/s\", \"odtunr6/s\",\n\t\t\t   \"itmex6/s\", \"otmex6/s\",\n\t\t\t   \"iprmpb6/s\", \"oprmpb6/s\",\n\t\t\t   \"iredir6/s\", \"oredir6/s\",\n\t\t\t   \"ipck2b6/s\", \"opck2b6/s\"};\n\tint g_fields[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 11, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) sneic, (void *) sneip,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* ierr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InErrors6, sneic->InErrors6, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* idtunr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InDestUnreachs6, sneic->InDestUnreachs6, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* odtunr6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutDestUnreachs6, sneic->OutDestUnreachs6, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* itmex6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InTimeExcds6, sneic->InTimeExcds6, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t\t/* otmex6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutTimeExcds6, sneic->OutTimeExcds6, itv),\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* iprmpb6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InParmProblems6, sneic->InParmProblems6, itv),\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* oprmpb6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutParmProblems6, sneic->OutParmProblems6, itv),\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* iredir6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InRedirects6, sneic->InRedirects6, itv),\n\t\t\t out + 7, outsize + 7, svg_p->restart);\n\t\t/* oredir6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutRedirects6, sneic->OutRedirects6, itv),\n\t\t\t out + 8, outsize + 8, svg_p->restart);\n\t\t/* ipck2b6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->InPktTooBigs6, sneic->InPktTooBigs6, itv),\n\t\t\t out + 9, outsize + 9, svg_p->restart);\n\t\t/* opck2b6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(sneip->OutPktTooBigs6, sneic->OutPktTooBigs6, itv),\n\t\t\t out + 10, outsize + 10, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display UDPv6 traffic statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_net_udp6_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp6 *) a->buf[!curr];\n\tint group[] = {2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"UDPv6 traffic statistics (1)\", \"UDPv6 traffic statistics (2)\"};\n\tchar *g_title[] = {\"idgm6/s\", \"odgm6/s\",\n\t\t\t   \"noport6/s\", \"idgmer6/s\"};\n\tint g_fields[] = {0, 1, 2, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 4, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) snuc, (void *) snup,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\n\t\t/* idgm6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->InDatagrams6, snuc->InDatagrams6, itv),\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* odgm6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->OutDatagrams6, snuc->OutDatagrams6, itv),\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* noport6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->NoPorts6, snuc->NoPorts6, itv),\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* idgmer6/s */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t S_VALUE(snup->InErrors6, snuc->InErrors6, itv),\n\t\t\t out + 3, outsize + 3, svg_p->restart);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (unused here).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_pwr_cpufreq_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t    unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_pwr_cpufreq *spc, *spp;\n\tint group[] = {1};\n\tint g_type[] = {SVG_LINE_GRAPH};\n\tchar *title[] = {\"CPU clock frequency\"};\n\tchar *g_title[] = {\"MHz\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tint i;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* For each CPU */\n\t\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr]  + i * a->msize);\n\t\t\tspp = (struct stats_pwr_cpufreq *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Note: Don't skip offline CPU here as it is needed\n\t\t\t * to make the graph go though 0.\n\t\t\t */\n\n\t\t\t/* MHz */\n\t\t\trecappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t  ((double) spp->cpufreq) / 100,\n\t\t\t\t  ((double) spc->cpufreq) / 100,\n\t\t\t\t  out + i, outsize + i, svg_p->restart, svg_p->dt,\n\t\t\t\t  a->spmin + i, a->spmax + i);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tint xid = 0;\n\t\tchar item_name[16];\n\n\t\tfor (i = 0; (i < a->item_list_sz) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tif (!i) {\n\t\t\t\t/* This is CPU \"all\" */\n\t\t\t\tstrcpy(item_name, K_LOWERALL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * If the maximum frequency reached by the CPU is 0, then\n\t\t\t\t * the CPU has been offline on the whole period.\n\t\t\t\t * => Don't display it.\n\t\t\t\t */\n\t\t\t\tif (*(a->spmax + i) == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsprintf(item_name, \"%d\", i - 1);\n\t\t\t}\n\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + i, a->spmax + i,\n\t\t\t\t\t\t out + i, outsize + i,\n\t\t\t\t\t\t svg_p, record_hdr, i, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display fan statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (unused here).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_pwr_fan_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_pwr_fan *spc, *spp;\n\tint group[] = {1};\n\tint g_type[] = {SVG_LINE_GRAPH};\n\tchar *title[] = {\"Fans speed\"};\n\tchar *g_title[] = {\"~rpm\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tint i;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* For each fan */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr]  + i * a->msize);\n\t\t\tspp = (struct stats_pwr_fan *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t\t/* rpm */\n\t\t\trecappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t  (double) spp->rpm,\n\t\t\t\t  (double) spc->rpm,\n\t\t\t\t  out + i, outsize + i, svg_p->restart, svg_p->dt,\n\t\t\t\t  a->spmin + i, a->spmax + i);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tchar item_name[MAX_SENSORS_DEV_LEN + 16];\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\n\t\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\tsnprintf(item_name, sizeof(item_name), \"%d: %s\", i + 1, spc->device);\n\t\t\titem_name[sizeof(item_name) - 1] = '\\0';\n\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + i, a->spmax + i,\n\t\t\t\t\t\t out + i, outsize + i,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (unused here).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define TEMP_ARRAY_SZ\t2\n__print_funct_t svg_print_pwr_temp_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_pwr_temp *spc;\n\tint group[] = {1, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Devices temperature (1)\",\n\t\t\t \"Devices temperature (2)\"};\n\tchar *g_title[] = {\"~degC\",\n\t\t\t   \"%temp\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tint i;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, TEMP_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tval;\n\n\t\t/* For each temperature sensor */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\t/* Look for min/max values */\n\t\t\tsave_minmax(a, TEMP_ARRAY_SZ * i, spc->temp);\n\t\t\ttval = (spc->temp_max - spc->temp_min) ?\n\t\t\t       (spc->temp - spc->temp_min) / (spc->temp_max - spc->temp_min) * 100 :\n\t\t\t       0.0;\n\t\t\tsave_minmax(a, TEMP_ARRAY_SZ * i + 1, tval);\n\n\t\t\t/* degC */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t (double) spc->temp,\n\t\t\t\t out + TEMP_ARRAY_SZ * i, outsize + TEMP_ARRAY_SZ * i, svg_p->restart);\n\t\t\t/* %temp */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, tval,\n\t\t\t\t out + TEMP_ARRAY_SZ * i + 1, outsize + TEMP_ARRAY_SZ * i + 1, svg_p->dt, FALSE);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tchar item_name[MAX_SENSORS_DEV_LEN + 16];\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\n\t\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\tsnprintf(item_name, sizeof(item_name), \"%d: %s\", i + 1, spc->device);\n\t\t\titem_name[sizeof(item_name) - 1] = '\\0';\n\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + TEMP_ARRAY_SZ * i,\n\t\t\t\t\t\t a->spmax + TEMP_ARRAY_SZ * i,\n\t\t\t\t\t\t out + TEMP_ARRAY_SZ * i,\n\t\t\t\t\t\t outsize + TEMP_ARRAY_SZ * i,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define IN_ARRAY_SZ\t2\n__print_funct_t svg_print_pwr_in_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_pwr_in *spc;\n\tint group[] = {1, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Voltage inputs statistics (1)\",\n\t\t\t \"Voltage inputs statistics (2)\"};\n\tchar *g_title[] = {\"inV\",\n\t\t\t   \"%in\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tint i;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, IN_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tval;\n\n\t\t/* For each voltage input sensor */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\t/* Look for min/max values */\n\t\t\tsave_minmax(a, IN_ARRAY_SZ * i, spc->in);\n\t\t\ttval = (spc->in_max - spc->in_min) ?\n\t\t\t       (spc->in - spc->in_min) / (spc->in_max - spc->in_min) * 100 :\n\t\t\t       0.0;\n\t\t\tsave_minmax(a, IN_ARRAY_SZ * i + 1, tval);\n\n\t\t\t/* inV */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t (double) spc->in,\n\t\t\t\t out + IN_ARRAY_SZ * i, outsize + IN_ARRAY_SZ * i, svg_p->restart);\n\t\t\t/* %in */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, tval,\n\t\t\t\t out + IN_ARRAY_SZ * i + 1, outsize + IN_ARRAY_SZ * i + 1, svg_p->dt, FALSE);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tchar item_name[MAX_SENSORS_DEV_LEN + 16];\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\n\t\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr]  + i * a->msize);\n\n\t\t\tsnprintf(item_name, sizeof(item_name), \"%d: %s\", i + 1, spc->device);\n\t\t\titem_name[sizeof(item_name) - 1] = '\\0';\n\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + IN_ARRAY_SZ * i,\n\t\t\t\t\t\t a->spmax + IN_ARRAY_SZ * i,\n\t\t\t\t\t\t out + IN_ARRAY_SZ * i,\n\t\t\t\t\t\t outsize + IN_ARRAY_SZ * i,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display batteries statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second.\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_pwr_bat_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t        unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_pwr_bat *spbc;\n\tint group[] = {1};\n\tint g_type[] = {SVG_BAR_GRAPH};\n\tchar *title[] = {\"Batteries capacity\"};\n\tchar *g_title[] = {\"~%cap\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tint i;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\t/* For each battery */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\t/* Look for min/max values */\n\t\t\tsave_minmax(a, i, spbc->capacity);\n\n\t\t\t/* %cap */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0,\n\t\t\t\t (unsigned int) spbc->capacity,\n\t\t\t\t out + i, outsize + i,\n\t\t\t\t svg_p->dt, FALSE);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tchar item_name[16];\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\n\t\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\tsnprintf(item_name, sizeof(item_name), \"BAT%d\", (int) spbc->bat_id);\n\t\t\titem_name[sizeof(item_name) - 1] = '\\0';\n\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t\t title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + i, a->spmax + i,\n\t\t\t\t\t\t out + i, outsize + i,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_huge_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t     unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\tint group[] = {4, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Huge pages utilization (1)\",\n\t\t\t \"Huge pages utilization (2)\"};\n\tchar *g_title[] = {\"~kbhugfree\", \"~kbhugused\", \"~kbhugrsvd\", \"~kbhugsurp\",\n\t\t\t   \"%hugused\"};\n\tint g_fields[] = {0, -1, 2, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/*\n\t\t * Allocate arrays that will contain the graphs data\n\t\t * Allocate one additional array (#5) to save min/max\n\t\t * values for tlhkb (unused).\n\t\t */\n\t\tout = allocate_graph_lines(a, 5, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tval;\n\n\t\t/* Check for min/max values */\n\t\tsave_extrema(a->gtypes_nr, (void *) smc, NULL,\n\t\t\t     itv, a->spmin, a->spmax, g_fields);\n\t\tsave_minmax(a, 1, smc->tlhkb - smc->frhkb);\n\t\ttval = smc->tlhkb ? SP_VALUE(smc->frhkb, smc->tlhkb, smc->tlhkb) : 0.0;\n\t\tsave_minmax(a, 4, tval);\n\n\t\t/* kbhugfree */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) smc->frhkb,\n\t\t\t  out, outsize, svg_p->restart);\n\t\t/* hugused */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) smc->tlhkb - smc->frhkb,\n\t\t\t  out + 1, outsize + 1, svg_p->restart);\n\t\t/* kbhugrsvd */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) smc->rsvdhkb,\n\t\t\t  out + 2, outsize + 2, svg_p->restart);\n\t\t/* kbhugsurp */\n\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t  (unsigned long long) smc->surphkb,\n\t\t\t  out + 3, outsize + 3, svg_p->restart);\n\t\t/* %hugused */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, tval,\n\t\t\t out + 4, outsize + 4, svg_p->dt, FALSE);\n\t}\n\n\tif (action & F_END) {\n\t\tdraw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t     title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display filesystem statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (unused here).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define FS_ARRAY_SZ\t8\n__print_funct_t svg_print_filesystem_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\t   unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_filesystem\t*sfc, *sfp;\n\tint group[] = {2, 2, 2, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH,\n\t\t\tSVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Filesystems statistics (1)\", \"Filesystems statistics (2)\",\n\t\t\t \"Filesystems statistics (3)\", \"Filesystems statistics (4)\"};\n\tchar *g_title[] = {\"~MBfsfree\", \"~MBfsused\",\n\t\t\t   \"%ufsused\", \"%fsused\",\n\t\t\t   \"Ifree/1000\", \"Iused/1000\",\n\t\t\t   \"%Iused\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\tchar *dev_name, *item_name;\n\tint i, k, pos, posp, restart;\n\n\tif (action & F_BEGIN) {\n\t\t/*\n\t\t * Allocate arrays (#0..6) that will contain the graphs data\n\t\t * Also allocate an additional arrays (#7) for each filesystem:\n                 * out + 7 will contain the persistent or standard fs name, or mount point.\n\t\t */\n\t\tout = allocate_graph_lines(a, FS_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tval, uupct, fupct, iupct;\n\n\t\t/* For each filesystem structure */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\t\tif (a->item_list != NULL) {\n\t\t\t\t/* A list of devices has been entered on the command line */\n\t\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t\t/* Device not found */\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Look for corresponding graph */\n\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\titem_name = *(out + k * FS_ARRAY_SZ + 7);\n\t\t\t\tif (!strcmp(dev_name, item_name))\n\t\t\t\t\t/* Graph found! */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t/* Graph not found: Look for first free entry */\n\t\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\t\titem_name = *(out + k * FS_ARRAY_SZ + 7);\n\t\t\t\t\tif (!strcmp(item_name, \"\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t\t/* No free graph entry: Ignore it (should never happen) */\n#ifdef DEBUG\n\t\t\t\t\tfprintf(stderr, \"%s: Name=%s\\n\",\n\t\t\t\t\t\t__FUNCTION__, sfc->fs_name);\n#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = k * FS_ARRAY_SZ;\n\t\t\tposp = k * a->xnr;\n\n\t\t\titem_name = *(out + pos + 7);\n\t\t\tif (!item_name[0]) {\n\t\t\t\t/* Save filesystem name and mount point (if not already done) */\n\t\t\t\tstrncpy(item_name, dev_name, CHUNKSIZE);\n\t\t\t\titem_name[CHUNKSIZE - 1] = '\\0';\n\t\t\t}\n\n\t\t\trestart = TRUE;\n\t\t\tfor (k = 0; k < a->nr[!curr]; k++) {\n\t\t\t\tsfp = (struct stats_filesystem *) ((char *) a->buf[!curr] + k * a->msize);\n\t\t\t\tif (!strcmp(sfc->fs_name, sfp->fs_name)) {\n\t\t\t\t\t/* Filesystem found in previous sample */\n\t\t\t\t\trestart = svg_p->restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check for min/max values */\n\n\t\t\t/* Compute fsfree min/max values */\n\t\t\ttval = (double) sfc->f_bfree;\n\t\t\tsave_minmax(a, posp, tval);\n\n\t\t\t/* Compute fsused min/max values */\n\t\t\ttval = (double) (sfc->f_blocks - sfc->f_bfree);\n\t\t\tsave_minmax(a, posp + 1, tval);\n\n\t\t\t/* Compute %ufsused min/max values */\n\t\t\tuupct = sfc->f_blocks ?\n\t\t\t\tSP_VALUE(sfc->f_bavail, sfc->f_blocks, sfc->f_blocks) : 0.0;\n\t\t\tsave_minmax(a, posp + 2, uupct);\n\n\t\t\t/* Compute %fsused min/max values */\n\t\t\tfupct = sfc->f_blocks ?\n\t\t\t\tSP_VALUE(sfc->f_bfree, sfc->f_blocks, sfc->f_blocks) : 0.0;\n\t\t\tsave_minmax(a, posp + 3, fupct);\n\n\t\t\t/* Compute Ifree min/max values */\n\t\t\ttval = (double) sfc->f_ffree;\n\t\t\tsave_minmax(a, posp + 4, tval);\n\n\t\t\t/* Compute Iused min/max values */\n\t\t\ttval = (double) (sfc->f_files - sfc->f_ffree);\n\t\t\tsave_minmax(a, posp + 5, tval);\n\n\t\t\t/* Compute %Iused min/max values */\n\t\t\tiupct = sfc->f_files ?\n\t\t\t\tSP_VALUE(sfc->f_ffree, sfc->f_files, sfc->f_files) : 0.0;\n\t\t\tsave_minmax(a, posp + 6, iupct);\n\n\t\t\t/* MBfsfree */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t (double) sfc->f_bfree / 1024 / 1024,\n\t\t\t\t out + pos, outsize + pos, restart);\n\t\t\t/* MBfsused */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t (double) (sfc->f_blocks - sfc->f_bfree) / 1024 / 1024,\n\t\t\t\t out + pos + 1, outsize + pos + 1, restart);\n\t\t\t/* %ufsused */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, uupct,\n\t\t\t\t out + pos + 2, outsize + pos + 2, svg_p->dt, FALSE);\n\t\t\t/* %fsused */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, fupct,\n\t\t\t\t out + pos + 3, outsize + pos + 3, svg_p->dt, FALSE);\n\t\t\t/* Ifree */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t ((double) sfc->f_ffree) / 1000,\n\t\t\t\t out + pos + 4, outsize + pos + 4, restart);\n\t\t\t/* Iused */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t ((double) (sfc->f_files - sfc->f_ffree)) / 1000,\n\t\t\t\t out + pos + 5, outsize + pos + 5, restart);\n\t\t\t/* %Iused */\n\t\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t 0.0, iupct,\n\t\t\t\t out + pos + 6, outsize + pos + 6, svg_p->dt, FALSE);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tint xid = 0;\n\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\n\t\t\t/* Check if there is something to display */\n\t\t\tpos = i * FS_ARRAY_SZ;\n\t\t\tif (!**(out + pos))\n\t\t\t\tcontinue;\n\t\t\tposp = i * a->xnr;\n\n\t\t\t/* Conversion B -> MiB and inodes/1000 */\n\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\t*(a->spmin + posp + k) /= (1024 * 1024);\n\t\t\t\t*(a->spmax + posp + k) /= (1024 * 1024);\n\t\t\t\t*(a->spmin + posp + 4 + k) /= 1000;\n\t\t\t\t*(a->spmax + posp + 4 + k) /= 1000;\n\t\t\t}\n\n\t\t\titem_name = *(out + pos + 7);\n\n\t\t\tif (draw_activity_graphs(a->g_nr, g_type, title, g_title, item_name, group,\n\t\t\t\t\t\t a->spmin + posp, a->spmax + posp,\n\t\t\t\t\t\t out + pos, outsize + pos,\n\t\t\t\t\t\t svg_p, record_hdr, FALSE, a, xid)) {\n\t\t\t\txid++;\n\t\t\t}\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define FC_ARRAY_SZ\t5\n__print_funct_t svg_print_fchost_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_fchost *sfcc, *sfcp, sfczero;\n\tint group[] = {2, 2};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Fibre Channel HBA statistics (1)\", \"Fibre Channel HBA statistics (2)\"};\n\tchar *g_title[] = {\"fch_rxf/s\", \"fch_txf/s\",\n\t\t\t   \"fch_rxw/s\", \"fch_txw/s\"};\n\tint g_fields[] = {0, 1, 2, 3};\n\tstatic char **out;\n\tstatic int *outsize;\n\tchar *item_name;\n\tint i, j, j0, k, found, pos, posp, restart, *unregistered;\n\n\tif (action & F_BEGIN) {\n\t\t/*\n\t\t * Allocate arrays (#0..3) that will contain the graphs data\n\t\t * Also allocate one additional array (#4) that will contain\n\t\t * FC HBA name (out + 4) and a positive value (TRUE) if the interface\n\t\t * has either still not been registered, or has been unregistered\n\t\t * (outsize + 4).\n\t\t */\n\t\tout = allocate_graph_lines(a, FC_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tmemset(&sfczero, 0, sizeof(struct stats_fchost));\n\t\t/*\n\t\t * Mark previously registered interfaces as now\n\t\t * possibly unregistered for all graphs.\n\t\t */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * FC_ARRAY_SZ + 4;\n\t\t\tif (*unregistered == FALSE) {\n\t\t\t\t*unregistered = MAYBE;\n\t\t\t}\n\t\t}\n\n\t\t/* For each FC HBA */\n\t\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\t\tfound = FALSE;\n\t\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\t\t\trestart = svg_p->restart;\n\n\t\t\t/* Look for corresponding graph */\n\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\titem_name = *(out + k * FC_ARRAY_SZ + 4);\n\t\t\t\tif (!strcmp(sfcc->fchost_name, item_name))\n\t\t\t\t\t/* Graph found! */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t/* Graph not found: Look for first free entry */\n\t\t\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\t\t\titem_name = *(out + k * FC_ARRAY_SZ + 4);\n\t\t\t\t\tif (!strcmp(item_name, \"\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == a->item_list_sz) {\n\t\t\t\t\t/* No free graph entry: Ignore it (should never happen) */\n#ifdef DEBUG\n\t\t\t\t\tfprintf(stderr, \"%s: Name=%s\\n\",\n\t\t\t\t\t\t__FUNCTION__, sfcc->fchost_name);\n#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = k * FC_ARRAY_SZ;\n\t\t\tposp = k * a->xnr;\n\t\t\tunregistered = outsize + pos + 4;\n\n\t\t\tif (a->nr[!curr] > 0) {\n\t\t\t\t/* Look for corresponding structure in previous iteration */\n\t\t\t\tj = i;\n\n\t\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t\t}\n\n\t\t\t\tj0 = j;\n\n\t\t\t\tdo {\n\t\t\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\t\tif (!strcmp(sfcc->fchost_name, sfcp->fchost_name)) {\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j != j0);\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\t/* This is a newly registered host */\n\t\t\t\tsfcp = &sfczero;\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If current interface was marked as previously unregistered,\n\t\t\t * then set restart variable to TRUE so that the graph will be\n\t\t\t * discontinuous, and mark it as now registered.\n\t\t\t */\n\t\t\tif (*unregistered == TRUE) {\n\t\t\t\trestart = TRUE;\n\t\t\t}\n\t\t\t*unregistered = FALSE;\n\n\t\t\titem_name = *(out + pos + 4);\n\t\t\tif (!item_name[0]) {\n\t\t\t\t/* Save FC HBA name */\n\t\t\t\tstrncpy(item_name, sfcc->fchost_name, CHUNKSIZE);\n\t\t\t\titem_name[CHUNKSIZE - 1] = '\\0';\n\t\t\t}\n\n\t\t\t/* Look for min/max values */\n\t\t\tsave_extrema(a->gtypes_nr, (void *) sfcc, (void *) sfcp,\n\t\t\t\titv, a->spmin + posp, a->spmax + posp, g_fields);\n\n\t\t\t/* fch_rxf/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sfcp->f_rxframes, sfcc->f_rxframes, itv),\n\t\t\t\t out + pos, outsize + pos, restart);\n\t\t\t/* fch_txf/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sfcp->f_txframes, sfcc->f_txframes, itv),\n\t\t\t\t out + pos + 1, outsize + pos + 1, restart);\n\t\t\t/* fch_rxw/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sfcp->f_rxwords, sfcc->f_rxwords, itv),\n\t\t\t\t out + pos + 2, outsize + pos + 2, restart);\n\t\t\t/* fch_txw/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(sfcp->f_txwords, sfcc->f_txwords, itv),\n\t\t\t\t out + pos + 3, outsize + pos + 3, restart);\n\t\t}\n\n\t\t/* Mark interfaces not seen here as now unregistered */\n\t\tfor (k = 0; k < a->item_list_sz; k++) {\n\t\t\tunregistered = outsize + k * FC_ARRAY_SZ + 4;\n\t\t\tif (*unregistered != FALSE) {\n\t\t\t\t*unregistered = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tfor (i = 0; i < a->item_list_sz; i++) {\n\n\t\t\t/* Check if there is something to display */\n\t\t\tpos = i * FC_ARRAY_SZ;\n\t\t\tif (!**(out + pos))\n\t\t\t\tcontinue;\n\t\t\tposp = i * a->xnr;\n\n\t\t\titem_name = *(out + pos + 4);\n\t\t\tdraw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t     title, g_title, item_name, group,\n\t\t\t\t\t     a->spmin + posp, a->spmax + posp,\n\t\t\t\t\t     out + pos, outsize + pos,\n\t\t\t\t\t     svg_p, record_hdr, FALSE, a, i);\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n#define SOFT_ARRAY_SZ\t6\n__print_funct_t svg_print_softnet_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t\tunsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_softnet *ssnc, *ssnp, ssnczero;\n\tint group[] = {2, 3, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_LINE_GRAPH, SVG_LINE_GRAPH};\n\tchar *title[] = {\"Software-based network processing statistics (1)\",\n\t\t\t \"Software-based network processing statistics (2)\",\n\t\t\t \"Software-based network processing statistics (3)\"};\n\tchar *g_title[] = {\"total/s\", \"dropd/s\",\n\t\t\t   \"squeezd/s\", \"rx_rps/s\", \"flw_lim/s\",\n\t\t\t   \"~blg_len\"};\n\tint g_fields[] = {0, 1, 2, 3, 4};\n\tunsigned int local_types_nr[] = {0, 0, 5};\n\tstatic char **out;\n\tstatic int *outsize;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tint i, pos, posp;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, SOFT_ARRAY_SZ * a->item_list_sz, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tint restart;\n\n\t\tmemset(&ssnczero, 0, STATS_SOFTNET_SIZE);\n\n\t\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\t\tif (a->nr[curr] > a->nr_ini) {\n\t\t\ta->nr_ini = a->nr[curr];\n\t\t}\n\n\t\t/* Compute statistics for CPU \"all\" */\n\t\tget_global_soft_statistics(a, !curr, curr, flags, offline_cpu_bitmap);\n\n\t\t/* For each CPU */\n\t\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\t\t\trestart = svg_p->restart;\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tssnc = (struct stats_softnet *) ((char *) a->buf[curr]  + i * a->msize);\n\t\t\tssnp = (struct stats_softnet *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t\tpos = i * SOFT_ARRAY_SZ;\n\t\t\tposp = i * a->xnr;\n\n\t\t\t/* Is current CPU marked offline? */\n\t\t\tif (IS_CPU_OFFLINE(offline_cpu_bitmap, i)) {\n\t\t\t\t/*\n\t\t\t\t * Yes and it doesn't follow a RESTART record.\n\t\t\t\t * To add a discontinuity in graph, we simulate\n\t\t\t\t * a RESTART mark.\n\t\t\t\t */\n\t\t\t\trestart = TRUE;\n\t\t\t\tif (svg_p->restart) {\n\t\t\t\t\t/*\n\t\t\t\t\t * CPU is offline and it follows a real\n\t\t\t\t\t * RESTART record. Ignore its current value\n\t\t\t\t\t * (no previous sample).\n\t\t\t\t\t * Don't reset ssnc structure (we need the values for\n\t\t\t\t\t * next iteration). Only make it point at a zero\n\t\t\t\t\t * structrure: With @restart set to TRUE, it will go\n\t\t\t\t\t * unnoticed on the graph.\n\t\t\t\t\t */\n\t\t\t\t\tssnc = &ssnczero;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Check for min/max values for online CPU only */\n\t\t\t\tsave_extrema(local_types_nr, (void *) ssnc, (void *) ssnp,\n\t\t\t\t\t     itv, a->spmin + posp, a->spmax + posp, g_fields);\n\t\t\t\tsave_minmax(a, posp + 5, ssnc->backlog_len);\n\t\t\t}\n\n\t\t\t/* total/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(ssnp->processed, ssnc->processed, itv),\n\t\t\t\t out + pos, outsize + pos, restart);\n\t\t\t/* dropd/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(ssnp->dropped, ssnc->dropped, itv),\n\t\t\t\t out + pos + 1, outsize + pos + 1, restart);\n\t\t\t/* squeezd/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(ssnp->time_squeeze, ssnc->time_squeeze, itv),\n\t\t\t\t out + pos + 2, outsize + pos + 2, restart);\n\t\t\t/* rx_rps/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(ssnp->received_rps, ssnc->received_rps, itv),\n\t\t\t\t out + pos + 3, outsize + pos + 3, restart);\n\t\t\t/* flw_lim/s */\n\t\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t S_VALUE(ssnp->flow_limit, ssnc->flow_limit, itv),\n\t\t\t\t out + pos + 4, outsize + pos + 4, restart);\n\t\t\t/* blg_len */\n\t\t\tlniappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t\t  (unsigned long long) ssnc->backlog_len,\n\t\t\t\t  out + pos + 5, outsize + pos + 5, restart);\n\t\t}\n\t}\n\n\tif (action & F_END) {\n\t\tchar item_name[16];\n\n\t\tfor (i = 0; (i < a->item_list_sz) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\tpos = i * SOFT_ARRAY_SZ;\n\t\t\tposp = i * a->xnr;\n\n\t\t\tif (!i) {\n\t\t\t\t/* This is CPU \"all\" */\n\t\t\t\tstrcpy(item_name, K_LOWERALL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(item_name, \"%d\", i - 1);\n\t\t\t}\n\n\t\t\tdraw_activity_graphs(a->g_nr, g_type,\n\t\t\t\t\t     title, g_title, item_name, group,\n\t\t\t\t\t     a->spmin + posp, a->spmax + posp,\n\t\t\t\t\t     out + pos, outsize + pos,\n\t\t\t\t\t     svg_p, record_hdr, i, a, i);\n\t\t}\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_psicpu_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr],\n\t\t*psip = (struct stats_psi_cpu *) a->buf[!curr];\n\tint group[] = {3, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"CPU pressure trends (some tasks)\", \"CPU stall time (some tasks)\"};\n\tchar *g_title[] = {\"%scpu-10\", \"%scpu-60\", \"%scpu-300\",\n\t\t\t   \"%scpu\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 4, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tval;\n\n\t\t/* Check for min/max values */\n\t\tsave_minmax(a, 0, psic->some_acpu_10);\n\t\tsave_minmax(a, 1, psic->some_acpu_60);\n\t\tsave_minmax(a, 2, psic->some_acpu_300);\n\t\ttval = ((double) psic->some_cpu_total - psip->some_cpu_total) / (100 * itv);\n\t\tsave_minmax(a, 3, tval);\n\n\t\t/* %scpu-10 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_acpu_10 / 100,\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* %scpu-60 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_acpu_60 / 100,\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* %scpu-300 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_acpu_300 / 100,\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* %scpu */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, tval,\n\t\t\t out + 3, outsize + 3, svg_p->dt, FALSE);\n\t}\n\n\tif (action & F_END) {\n\t\t/* Fix min/max values for pressure ratios */\n\t\t*(a->spmin) /= 100; *(a->spmax) /= 100;\n\t\t*(a->spmin + 1) /= 100; *(a->spmax + 1) /= 100;\n\t\t*(a->spmin + 2) /= 100; *(a->spmax + 2) /= 100;\n\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_psiio_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t      unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr],\n\t\t*psip = (struct stats_psi_io *) a->buf[!curr];\n\tint group[] = {3, 1, 3, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH, SVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"I/O pressure trends (some tasks)\", \"I/O stall time (some tasks)\",\n\t\t\t \"I/O pressure trends (full)\", \"I/O stall time (full)\"};\n\tchar *g_title[] = {\"%sio-10\", \"%sio-60\", \"%sio-300\",\n\t\t\t   \"%sio\",\n\t\t\t   \"%fio-10\", \"%fio-60\", \"%fio-300\",\n\t\t\t   \"%fio\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 8, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tvals, tvalf;\n\n\t\t/* Check for min/max values */\n\t\tsave_minmax(a, 0, psic->some_aio_10);\n\t\tsave_minmax(a, 1, psic->some_aio_60);\n\t\tsave_minmax(a, 2, psic->some_aio_300);\n\t\ttvals = ((double) psic->some_io_total - psip->some_io_total) / (100 * itv);\n\t\tsave_minmax(a, 3, tvals);\n\n\t\tsave_minmax(a, 4, psic->full_aio_10);\n\t\tsave_minmax(a, 5, psic->full_aio_60);\n\t\tsave_minmax(a, 6, psic->full_aio_300);\n\t\ttvalf = ((double) psic->full_io_total - psip->full_io_total) / (100 * itv);\n\t\tsave_minmax(a, 7, tvalf);\n\n\t\t/* %sio-10 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_aio_10 / 100,\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* %sio-60 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_aio_60 / 100,\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* %sio-300 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_aio_300 / 100,\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* %sio */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, tvals,\n\t\t\t out + 3, outsize + 3, svg_p->dt, FALSE);\n\n\t\t/* %fio-10 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->full_aio_10 / 100,\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* %fio-60 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->full_aio_60 / 100,\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* %fio-300 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->full_aio_300 / 100,\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* %fio */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, tvalf,\n\t\t\t out + 7, outsize + 7, svg_p->dt, FALSE);\n\t}\n\n\tif (action & F_END) {\n\t\t/* Fix min/max values for pressure ratios */\n\t\t*(a->spmin) /= 100; *(a->spmax) /= 100;\n\t\t*(a->spmin + 1) /= 100; *(a->spmax + 1) /= 100;\n\t\t*(a->spmin + 2) /= 100; *(a->spmax + 2) /= 100;\n\n\t\t*(a->spmin + 4) /= 100; *(a->spmax + 4) /= 100;\n\t\t*(a->spmin + 5) /= 100; *(a->spmax + 5) /= 100;\n\t\t*(a->spmin + 6) /= 100; *(a->spmax + 6) /= 100;\n\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics in SVG.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @action\tAction expected from current function.\n * @svg_p\tSVG specific parameters: Current graph number (.@graph_no),\n * \t\tflag indicating that a restart record has been previously\n * \t\tfound (.@restart) and time used for the X axis origin\n * \t\t(@ust_time_ref).\n * @itv\t\tInterval of time in 1/100th of a second (only with F_MAIN action).\n * @record_hdr\tPointer on record header of current stats sample.\n ***************************************************************************\n */\n__print_funct_t svg_print_psimem_stats(struct activity *a, int curr, int action, struct svg_parm *svg_p,\n\t\t\t\t       unsigned long long itv, struct record_header *record_hdr)\n{\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr],\n\t\t*psip = (struct stats_psi_mem *) a->buf[!curr];\n\tint group[] = {3, 1, 3, 1};\n\tint g_type[] = {SVG_LINE_GRAPH, SVG_BAR_GRAPH, SVG_LINE_GRAPH, SVG_BAR_GRAPH};\n\tchar *title[] = {\"Memory pressure trends (some tasks)\", \"Memory stall time (some tasks)\",\n\t\t\t \"Memory pressure trends (full)\", \"Memory stall time (full)\"};\n\tchar *g_title[] = {\"%smem-10\", \"%smem-60\", \"%smem-300\",\n\t\t\t   \"%smem\",\n\t\t\t   \"%fmem-10\", \"%fmem-60\", \"%fmem-300\",\n\t\t\t   \"%fmem\"};\n\tstatic char **out;\n\tstatic int *outsize;\n\n\tif (action & F_BEGIN) {\n\t\t/* Allocate arrays that will contain the graphs data */\n\t\tout = allocate_graph_lines(a, 8, &outsize);\n\t}\n\n\tif (action & F_MAIN) {\n\t\tdouble tvals, tvalf;\n\n\t\t/* Check for min/max values */\n\t\tsave_minmax(a, 0, psic->some_amem_10);\n\t\tsave_minmax(a, 1, psic->some_amem_60);\n\t\tsave_minmax(a, 2, psic->some_amem_300);\n\t\ttvals = ((double) psic->some_mem_total - psip->some_mem_total) / (100 * itv);\n\t\tsave_minmax(a, 3, tvals);\n\n\t\tsave_minmax(a, 4, psic->full_amem_10);\n\t\tsave_minmax(a, 5, psic->full_amem_60);\n\t\tsave_minmax(a, 6, psic->full_amem_300);\n\t\ttvalf = ((double) psic->full_mem_total - psip->full_mem_total) / (100 * itv);\n\t\tsave_minmax(a, 7, tvalf);\n\n\t\t/* %smem-10 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_amem_10 / 100,\n\t\t\t out, outsize, svg_p->restart);\n\t\t/* %smem-60 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_amem_60 / 100,\n\t\t\t out + 1, outsize + 1, svg_p->restart);\n\t\t/* %smem-300 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->some_amem_300 / 100,\n\t\t\t out + 2, outsize + 2, svg_p->restart);\n\t\t/* %smem */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, tvals,\n\t\t\t out + 3, outsize + 3, svg_p->dt, FALSE);\n\n\t\t/* %fmem-10 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->full_amem_10 / 100,\n\t\t\t out + 4, outsize + 4, svg_p->restart);\n\t\t/* %fmem-60 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->full_amem_60 / 100,\n\t\t\t out + 5, outsize + 5, svg_p->restart);\n\t\t/* %fmem-300 */\n\t\tlnappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t (double) psic->full_amem_300 / 100,\n\t\t\t out + 6, outsize + 6, svg_p->restart);\n\t\t/* %fmem */\n\t\tbrappend(record_hdr->ust_time - svg_p->ust_time_ref,\n\t\t\t 0.0, tvalf,\n\t\t\t out + 7, outsize + 7, svg_p->dt, FALSE);\n\t}\n\n\tif (action & F_END) {\n\t\t/* Fix min/max values for pressure ratios */\n\t\t*(a->spmin) /= 100; *(a->spmax) /= 100;\n\t\t*(a->spmin + 1) /= 100; *(a->spmax + 1) /= 100;\n\t\t*(a->spmin + 2) /= 100; *(a->spmax + 2) /= 100;\n\n\t\t*(a->spmin + 4) /= 100; *(a->spmax + 4) /= 100;\n\t\t*(a->spmin + 5) /= 100; *(a->spmax + 5) /= 100;\n\t\t*(a->spmin + 6) /= 100; *(a->spmax + 6) /= 100;\n\n\t\tdraw_activity_graphs(a->g_nr, g_type, title, g_title, NULL, group,\n\t\t\t\t     a->spmin, a->spmax, out, outsize, svg_p, record_hdr,\n\t\t\t\t     FALSE, a, 0);\n\n\t\t/* Free remaining structures */\n\t\tfree_graphs(out, outsize);\n\t}\n}\n"
        },
        {
          "name": "svg_stats.h",
          "type": "blob",
          "size": 5.6982421875,
          "content": "/*\n * svg_stats.h: Include file used to display system statistics in SVG format.\n * (C) 2016-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _SVG_STATS_H\n#define _SVG_STATS_H\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display system statistics in SVG.\n ***************************************************************************\n */\n\n/* Functions used to display statistics in SVG */\n__print_funct_t svg_print_cpu_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_pcsw_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_swap_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_paging_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_io_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_memory_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_ktables_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_queue_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_disk_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_dev_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_edev_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_nfs_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_nfsd_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_sock_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_ip_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_eip_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_icmp_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_eicmp_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_tcp_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_etcp_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_udp_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_sock6_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_ip6_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_eip6_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_icmp6_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_eicmp6_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_net_udp6_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_pwr_cpufreq_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_pwr_fan_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_pwr_temp_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_pwr_in_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_huge_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_filesystem_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_fchost_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_softnet_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_psicpu_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_psiio_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_psimem_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n__print_funct_t svg_print_pwr_bat_stats\n\t(struct activity *, int, int, struct svg_parm *, unsigned long long,\n\t struct record_header *);\n\n#endif /* _SVG_STATS_H */\n"
        },
        {
          "name": "sysconfig.in",
          "type": "blob",
          "size": 0.3076171875,
          "content": "/*\n * sysstat: System performance tools for Linux\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _SYSCONFIG_H\n#define _SYSCONFIG_H\n\n/* sysstat configuration directory */\n#define IOCONF\t\t\"@SYSCONFIG_DIR@/sysstat.ioconf\"\n#define LOCAL_IOCONF\t\"./sysstat.ioconf\"\n\n#endif  /* _SYSCONFIG_H */\n"
        },
        {
          "name": "sysstat-12.7.6.spec",
          "type": "blob",
          "size": 3.02734375,
          "content": "Summary: \tSAR, SADF, MPSTAT, IOSTAT, TAPESTAT, PIDSTAT and CIFSIOSTAT for Linux\nName: \t\tsysstat\nVersion: \t12.7.6\nRelease: \t1\nLicense: \tGPL\nGroup: \t\tApplications/System\nSource0: \t%{name}-%{version}.tar.gz\nURL:\t\thttp://pagesperso-orange.fr/sebastien.godard/\nPackager:\tSebastien Godard <sysstat _at_ orange.fr>\nBuildRoot:\t%{_tmppath}/%{name}-%{version}-root-%(id -u -n)\nRequires:\tgettext\n\n%description\nThe sysstat package contains the sar, sadf, mpstat, iostat, tapestat,\npidstat, cifsiostat and sa tools for Linux.\nThe sar command collects and reports system activity information.\nThe information collected by sar can be saved in a file in a binary\nformat for future inspection. The statistics reported by sar concern\nI/O transfer rates, paging activity, process-related activities,\ninterrupts, network activity, memory and swap space utilization, CPU\nutilization, kernel activities and TTY statistics, among others. Both\nUP and SMP machines are fully supported.\nThe sadf command may be used to display data collected by sar in\nvarious formats (CSV, XML, etc.) and to draw graphs (SVG).\nThe iostat command reports CPU utilization and I/O statistics for disks.\nThe tapestat command reports statistics for tapes connected to the system.\nThe mpstat command reports global and per-processor statistics.\nThe pidstat command reports statistics for Linux tasks (processes).\nThe cifsiostat command reports I/O statistics for CIFS filesystems.\n\n%define debug_package %{nil}\n\n%prep\n%setup\n\n%build\n# To include cron installation, add options --enable-install-cron and --enable-copy-only\n./configure --prefix=%{_prefix} \\\n\t--disable-file-attr \\\n\tsa_lib_dir=%{_libdir}/sa \\\n\t--mandir=%{_mandir} \\\n\tDESTDIR=$RPM_BUILD_ROOT\nmake\n\n%install\nrm -rf $RPM_BUILD_ROOT\ninstall -d $RPM_BUILD_ROOT/var/log/sa\n\nmake install\n\nmkdir -p $RPM_BUILD_ROOT/etc/rc.d/init.d\ninstall -m 755  sysstat $RPM_BUILD_ROOT/etc/rc.d/init.d/sysstat\nmkdir -p $RPM_BUILD_ROOT/etc/sysconfig\ninstall -m 644 sysstat.sysconfig $RPM_BUILD_ROOT/etc/sysconfig/sysstat\ninstall -m 644 sysstat.ioconf $RPM_BUILD_ROOT/etc/sysconfig/sysstat.ioconf\nmkdir -p $RPM_BUILD_ROOT/etc/cron.d\ninstall -m 644 cron/sysstat.crond.sample $RPM_BUILD_ROOT/etc/cron.d/sysstat\nmkdir -p $RPM_BUILD_ROOT/etc/rc2.d\ncd $RPM_BUILD_ROOT/etc/rc2.d && ln -sf ../init.d/sysstat S01sysstat\nmkdir -p $RPM_BUILD_ROOT/etc/rc3.d\ncd $RPM_BUILD_ROOT/etc/rc3.d && ln -sf ../init.d/sysstat S01sysstat\nmkdir -p $RPM_BUILD_ROOT/etc/rc5.d\ncd $RPM_BUILD_ROOT/etc/rc5.d && ln -sf ../init.d/sysstat S01sysstat\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n\n%files\n%defattr(644,root,root,755)\n%doc %{_datadir}/doc/sysstat-%{version}/*\n%attr(755,root,root) %{_bindir}/*\n%attr(755,root,root) %{_libdir}/sa/*\n%attr(644,root,root) %{_mandir}/man*/*\n%attr(644,root,root) %{_datadir}/locale/*/LC_MESSAGES/sysstat.mo\n%attr(755,root,root) %dir /var/log/sa\n%attr(755,root,root) /etc/rc.d/init.d/sysstat\n%attr(644,root,root) /etc/sysconfig/sysstat\n%attr(644,root,root) /etc/sysconfig/sysstat.ioconf\n/etc/rc2.d/S01sysstat\n/etc/rc3.d/S01sysstat\n/etc/rc5.d/S01sysstat\n%config(noreplace) %attr(0644,root,root) /etc/cron.d/sysstat\n\n"
        },
        {
          "name": "sysstat.in",
          "type": "blob",
          "size": 1.251953125,
          "content": "#!/bin/sh\n#\n# chkconfig: 12345 01 99\n# description: Reset the system activity logs\n#\n# @INIT_DIR@/sysstat\n# (C) 2000-2024 Sebastien Godard (sysstat <at> orange.fr)\n#\n### BEGIN INIT INFO\n# Provides:\t\tsysstat\n# Required-Start:\n# Required-Stop:\n# Default-Start: 1 2 3 4 5\n# Default-Stop: 0 6\n# Description: Reset the system activity logs\n# Short-Description: Reset the system activity logs\n### END INIT INFO\n#@(#) @PACKAGE_NAME@-@PACKAGE_VERSION@ startup script:\n#@(#)\t Insert a dummy record in current daily data file.\n#@(#)\t This indicates that the counters have restarted from 0.\n\n# Source functions library\n[ -r @INIT_DIR@/functions ] && . @INIT_DIR@/functions\n\nRETVAL=0\nPIDFILE=/var/run/sysstat.pid\n[ -z \"$UID\" ] && UID=`id -u`\n\n# See how we were called.\ncase \"$1\" in\n  start)\n\t[ $UID -eq 0 ] || exit 4\n\techo $$ > $PIDFILE || exit 1\n\techo -n \"Calling the system activity data collector (sadc)... \"\n\t@SU_C_OWNER@ @QUOTE@ @SA_LIB_DIR@/sa1 --boot @QUOTE@\n\t[ $? -eq 0 ] || RETVAL=1\n\trm -f $PIDFILE\n\techo\n\t;;\n\n  status)\n\t[ -f $PIDFILE ] || RETVAL=3\n\t;;\n\n  stop)\n\t[ $UID -eq 0 ] || exit 4\n\t;;\n\n  restart|reload|force-reload|condrestart|try-restart)\n\t;;\n\n  *)\n\techo \"Usage: sysstat {start|stop|status|restart|reload|force-reload|condrestart|try-restart}\"\n\tRETVAL=2\nesac\n\nexit ${RETVAL}\n\n"
        },
        {
          "name": "sysstat.ioconf",
          "type": "blob",
          "size": 6.3125,
          "content": "#\n# sysstat.ioconf\n#\n#  Copyright (C) 2004, Red Hat, Inc.\n#\n#  Maintained by Sebastien Godard (sysstat [at] orange.fr)\n#\n#  This file gives iostat, sar, and sadf a clue about how to find whole\n#  disk devices in /proc/diskstats.\n#  Authoritative source is: linux/Documentation/devices.txt or\n#  linux/Documentation/admin-guide/devices.txt\n#\n# line format, general record:\n#   major:name:ctrlpre:ctrlno:devfmt:devcnt:partpre:partcnt:description\n#\n#  major:\t\tmajor # for device\n#  name:\t\tbase of device name\n#  ctrlpre:\t\tstring to use in generating controller designators\n#\t\t\t eg: the c in c0d2p6, decimal formatting implied\n#\t\t\t'*' means none or irrelevant\n#\t\t\t'x': exception... record contains a specific name\n#                       for a specific minor #, stored in the ctrlno field\n#  ctrlno:\t\twhich controller of this type is this\n#  devfmt:\t\ttype of device naming convention\n#\ta:\t\talpha: xxa, xxb, ... xxaa, xxab, ... xxzz\n#\t%string:\tstring to use in generating drive designators,\n#\t\t\t eg: the 'd' in c0d2p6 , decimal formatting implied\n#\td:\t\tno special translations (decimal formatting)\n#  devcnt:\t\thow many whole devs per major number\n#  partpre:         \tappended to whole dev before part designator\n#                        eg. the p in c0d2p6, decimal formatting implied\n#\t\t\t '*' means none\n#  partcnt:\t\tnumber of partitions per volume\n#\t\t\t or minor # for exception records\n#  description:\t\tinformative text\n#\n# line format, indirect record:\n#   major:base_major:ctrlno[:[desc]]\n#\n#  major:\t\tmajor number of the device\n#  base_major:\t\tmajor number of the template for this type,\n#\t\t\t 0 for not supported\n#  ctrlno:\t\tcontroller number of this type\n#  desc:\t\tcontroller-specific description\n#\t\t\tif absent the desc from base_major will be\n#\t\t\t used in sprintf( buf, desc, ctrlno )\n\n\n1:ram:*:0:d:256:*:1:RAM disks (ram0..ram255)\n1:initrd:x:250:d:256:*:1:Initial RAM Disk (initrd)\n\n#2:0:0:Floppy Devices\n2:fd:*:0:d:4:*:1:Floppy Devices fd0,fd1,fd2,fd3\n\n3:hd:*:0:a:2:*:64:IDE - Controller %d\n22:3:1:\n33:3:2:\n34:3:3:\n56:3:4:\n57:3:5:\n88:3:6:\n89:3:7:\n90:3:8:\n91:3:9:\n\n#4:0:0:NODEV\n#5:0:0:NODEV\n#6:0:0:NODEV\n7:loop:*:0:d:256:*:1:Loop Devices\n\n8:sd:*:0:a:16:*:16:SCSI - Controller %d\n65:8:1:\n66:8:2:\n67:8:3:\n68:8:4:\n69:8:5:\n70:8:6:\n71:8:7:\n128:8:8:\n129:8:9:\n130:8:10:\n131:8:11:\n132:8:12:\n133:8:13:\n134:8:14:\n135:8:15:\n\n9:md:*:0:d:256:*:1:Metadisk (Software RAID) devices  (md0..md255)\n\n#10:0:0:NODEV\n\n#11:sr:*:0:d:256:*:1:CDROM - CDROM (sr0..sr255) (deprecated)\n11:scd:*:0:d:256:*:1:CDROM - CDROM (scd0..scd255)\n\n#12:0:0:MSCDEX CD-ROM Callback\n\n13:xd:*:0:a:2:*:64:8-bit MFM/RLL/IDE controller (xda, xdb)\n\n#14:0:0:BIOS Hard Drive Callback\n#15:0:0:CDROM - Sony CDU-31A/CDU-33A\n#16:0:0:CDROM - Goldstar\n#17:0:0:CDROM - Optics Storage\n#18:0:0:CDROM - Sanyo\n\n19:double:*:0:d:256:*:1:Compressed Disk (double0..double255)\n\n#20:0:0:CDROM - Hitachi\n\n21:mfm:*:0:a:2:*:64:Acorn MFM Hard Drive (mfma, mfmb)\n\n# 22: see IDE, dev 3\n\n#23:0:0:CDROM - Mistumi Proprietary\n#24:0:0:CDROM - Sony CDU-535\n#25:0:0:CDROM - Matsushita (Panasonic/Soundblaster) #1\n#26:0:1:CDROM - Matsushita (Panasonic/Soundblaster) #2\n#27:0:2:CDROM - Matsushita (Panasonic/Soundblaster) #3\n#28:0:3:CDROM - Matsushita (Panasonic/Soundblaster) #4\n# 28:0:0:! ACSI (Atari) Disk Not Supported\n#29:0:0:CDROM - Aztech/Orchid/Okano/Wearnes\n#30:0:0:CDROM - Philips LMS CM-205\n#31:0:0:ROM/flash Memory Card\n#32:0:0:CDROM -  Phillips LMS CM-206\n\n# 33: See IDE, dev 3\n# 34: See IDE, dev 3\n\n#35:0:0:Slow Memory RAM Disk\n\n36:ed:*:0:a:2:*:64:MCA ESDI Hard Disk (eda, edb)\n\n#37:0:0:Zorro II Ram Disk\n#38:0:0:Reserved For Linux/AP+\n#39:0:0:Reserved For Linux/AP+\n#40:0:0:Syquest EZ135 Parallel Port Drive\n#41:0:0:CDROM -  MicroSolutions Parallel Port BackPack\n#42:0:0:For DEMO Use Only\n\n43:nb:*:0:d:256:*:1:Network Block devices (nb0..nb255)\n44:ftl:*:0:a:16:*:16:Flash Translation Layer (ftla..ftlp)\n45:pd:*:0:a:4:*:16:Parallel Port IDE (pda..pdd)\n\n#46:0:0:CDROM - Parallel Port ATAPI\n\n47:pf:*:0:d:256:*:1:Parallel Port ATAPI Disk Devices (pf0..pf255)\n\n48:rd:/c:0:%d:32:p:8:Mylex DAC960 RAID, Controller %d\n49:48:1:\n50:48:2:\n51:48:3:\n52:48:4:\n53:48:5:\n54:48:6:\n55:48:7:\n136:48:8:\n137:48:9:\n138:48:10:\n139:48:11:\n140:48:12:\n141:48:13:\n142:48:14:\n143:48:15:\n\n# 56, 57: see IDE, dev 3:\n\n58:lvm:*:0:d:256:*:1:Logical Volume Manager (lvm0..lvm255)\n\n#59:0:0:PDA Filesystem Device\n#60:0:0:Local/Experimental Use\n#61:0:0:Local/Experimental Use\n#62:0:0:Local/Experimental Use\n#63:0:0:Local/Experimental Use\n#64:0:0:NODEV\n\n# 65..71: See SCSI, dev 8:\n\n72:ida/:c:0:%d:16:p:16:Compaq Intelligent Drive Array - Controller %d\n73:72:1:\n74:72:2:\n75:72:3:\n76:72:4:\n77:72:5:\n78:72:6:\n79:72:7:\n\n80:i2o/hd:*:0:a:16:*:16:I2O Disk - Controller %d\n81:80:1:\n82:80:2:\n83:80:3:\n84:80:4:\n85:80:5:\n86:80:6:\n87:80:7:\n\n# 88..91: see IDE, dev 3:\n\n#92:0:0:PPDD Encrypted Disk\n#93:0:0:NAND Flash Translation Layer not supported\n\n94:dasd:*:0:a:64:*:4:IBM S/390 DASD Block Storage (dasda, dasdb, ...)\n\n#95:0:0:IBM S/390 VM/ESA Minidisk\n#96:0:0:NODEV\n#97:0:0:CD/DVD packed writing devices not supported\n\n98:ubd:*:0:d:256:*:1:User-mode Virtual Block Devices (ubd0..ubd256)\n\n#99:0:0:JavaStation Flash Disk\n#100:0:0:NODEV\n\n101:amiraid/ar:*:0:d:16:p:16:AMI HyperDisk RAID (amiraid/ar0 - amiraid/ar15)\n\n#102:0:0:Compressed Block Device\n#103:0:0:Audit Block Device\n\n104:cciss:/c:0:%d:16:p:16:HP SA 5xxx/6xxx (cciss) Controller %d\n105:104:1:\n106:104:2:\n107:104:3:\n108:104:4:\n109:104:5:\n110:104:6:\n111:104:7:\n\n112:iseries/vd:*:0:a:32:*:8:IBM iSeries Virtual Disk (.../vda - .../vdaf)\n\n#113:0:0:CDROM - IBM iSeries Virtual\n\n# 114..159 NODEV\n\n120:emcpower:*:0:a:16:*:16:EMC PowerPath Unit %d\n\n#160:sx8/:*:0:d:8:p:32:Promise SATA SX8 Unit %d\n#161:160:1:\n160:carmel/:*:0:d:8:p:32:Carmel 8-port SATA Disks (carmel/0 - carmel/7)\n161:160:1:\n\n# 162..198 UNUSED\n\n180:ub:*:0:a:32:p:8:USB block devices\n\n#199:0:0:Veritas Volume Manager (VxVM) Volumes\n#200:0:0:NODEV\n#201:0:0:Veritas VxVM Dynamic Multipathing Driver\n\n202:xvd:*:0:a:16:p:16:Xen Virtual Block Device\n\n# 203..230: UNUSED\n\n232:emcpower:*:0:a:16:*:16:EMC PowerPath Unit %d\n233:232:1:\n234:232:2:\n235:232:3:\n236:232:4:\n237:232:5:\n238:232:6:\n239:232:7:\n240:232:8:\n241:232:9:\n242:232:10:\n243:232:11:\n244:232:12:\n245:232:13:\n246:232:14:\n247:232:15:\n\n# 240..254: LOCAL/Experimental\n\n256:rfd:*:0:a:16:*:16:Resident Flash Disk Flash Translation Layer (rfda..rfdp)\n\n257:ssfdc:*:0:a:8:*:8:SSFDC Flash Translation Layer filesystem (ssfdca..ssfdch)\n\n258:blockrom:*:0:d:256:*:1:ROM/Flash Read-Only Translation Layer (blockrom0...)\n\n"
        },
        {
          "name": "sysstat.service.in",
          "type": "blob",
          "size": 0.5087890625,
          "content": "# @SYSTEMD_UNIT_DIR@/sysstat.service\n# (C) 2012 Peter Schiffer (pschiffe <at> redhat.com)\n#\n# @PACKAGE_NAME@-@PACKAGE_VERSION@ systemd unit file:\n#\t Insert a dummy record in current daily data file.\n#\t This indicates that the counters have restarted from 0.\n\n[Unit]\nDescription=Resets System Activity Logs\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nUser=@CRON_OWNER@\nExecStart=@SA_LIB_DIR@/sa1 --boot\n\n[Install]\nWantedBy=multi-user.target\nAlso=sysstat-collect.timer\nAlso=sysstat-summary.timer\nAlso=sysstat-rotate.timer\n\n"
        },
        {
          "name": "sysstat.sysconfig.in",
          "type": "blob",
          "size": 1.9111328125,
          "content": "# @PACKAGE_NAME@-@PACKAGE_VERSION@ configuration file.\n\n# How long to keep log files (in days).\n# If value is greater than 28, then use sadc's option -D to prevent older\n# data files from being overwritten. See sadc(8) and sysstat(5) manual pages.\nHISTORY=@HISTORY@\n\n# Compress (using xz, gzip or bzip2) sa and sar files older than (in days):\nCOMPRESSAFTER=@COMPRESSAFTER@\n\n# Parameters for the system activity data collector (see sadc manual page)\n# which are used for the generation of log files.\nSADC_OPTIONS=\"@COLLECT_ALL@ @SADC_OPT@\"\n\n# Directory where sa and sar files are saved. The directory must exist.\nSA_DIR=@SA_DIR@\n\n# Compression program to use.\nZIP=\"@ZIP@\"\n\n# By default sa2 script generates yesterday's summary, since the cron job\n# usually runs right after midnight. If you want sa2 to generate the summary\n# of the same day (for example when cron job runs at 23:53) set this variable.\n#YESTERDAY=no\n\n# By default sa2 script generates reports files (the so called sarDD files).\n# Set this variable to false to disable reports generation.\n#REPORTS=false\n\n# Tell sa2 to wait for a random delay in the range 0 .. ${DELAY_RANGE} before\n# executing. This delay is expressed in seconds, and is aimed at preventing\n# a massive I/O burst at the same time on VM sharing the same storage area.\n# Set this variable to 0 to make sa2 generate reports files immediately.\nDELAY_RANGE=@DELAY_RANGE@\n\n# The sa1 and sa2 scripts generate system activity data and report files in\n# the @SA_DIR@ directory. By default the files are created with umask 0022\n# and are therefore readable for all users. Change this variable to restrict\n# the permissions on the files (e.g. use 0027 to adhere to more strict\n# security standards).\nUMASK=0022\n\n# The sa2 script uses the value below to set environment variable S_REPEAT_HEADER\n# which is used by sar as the maximum number of lines after which a header has to\n# be displayed (see sar(1) manual page).\n#REPEAT_HEADER=25\n"
        },
        {
          "name": "systest.c",
          "type": "blob",
          "size": 9.7666015625,
          "content": "/*\n * sysstat test functions.\n * (C) 2019-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#ifdef TEST\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <sys/types.h>\n\n#include \"systest.h\"\n\ntime_t __unix_time = 1591016000;\t/* Mon Jun  1 12:53:20 2020 UTC */\nint __env = 0;\n\nextern long interval;\nextern int sigint_caught;\n\n/*\n ***************************************************************************\n * Test mode: Instead of reading system time, use time given on the command\n * line.\n *\n * RETURNS:\n * Number of seconds since the epoch, as given on the command line.\n ***************************************************************************\n */\ntime_t get_unix_time(time_t *t)\n{\n\treturn __unix_time;\n}\n\n/*\n ***************************************************************************\n * Test mode: Get time of the day using __unix_time variable contents.\n *\n * OUT:\n * @tv\tNumber of seconds since the Epoch.\n ***************************************************************************\n */\nvoid get_day_time(struct timeval *tv)\n{\n\t__unix_time += interval;\n\ttv->tv_sec = __unix_time;\n\ttv->tv_usec = 0;\n}\n\n/*\n ***************************************************************************\n * Test mode: Send bogus information about current kernel.\n *\n * OUT:\n * @h\tStructure with kernel information.\n ***************************************************************************\n */\nvoid get_uname(struct utsname *h)\n{\n\tstrcpy(h->sysname, \"Linux\");\n\tstrcpy(h->nodename, \"SYSSTAT.TEST\");\n\tstrcpy(h->release, \"1.2.3-TEST\");\n\tstrcpy(h->machine, \"x86_64\");\n}\n\n/*\n ***************************************************************************\n * Test mode: Send bogus information about current filesystem.\n *\n * OUT:\n * @buf\tStructure with filesystem information.\n ***************************************************************************\n */\nint get_fs_stat(char *c, struct statvfs *buf)\n{\n\tstatic int p = 0;\n\t/*\n\t * f_bfree, f_blocks and f_bavail used to be unsigned long.\n\t * So don't use values greater then UINT_MAX to make sure that values\n\t * won't overflow on 32-bit systems.\n\t */\n\tconst unsigned long long bfree[4]  = {739427840, 286670336, 1696156672, 2616732672};\n\tconst unsigned long long blocks[4] = {891291136, 502345216, 1829043712, 3502345216};\n\tconst unsigned long long bavail[4] = {722675712, 241253120, 1106515456, 1871315456};\n\tconst unsigned long long files[4]  = {6111232, 19202048, 1921360, 19202048};\n\tconst unsigned long long ffree[4]  = {6008414, 19201593, 1621550, 19051710};\n\n\tbuf->f_bfree = bfree[p];\n\tbuf->f_blocks = blocks[p];\n\tbuf->f_bavail = bavail[p];\n\tbuf->f_frsize = 1;\n\tbuf->f_files = files[p];\n\tbuf->f_ffree = ffree[p];\n\n\tp = (p + 1) & 0x3;\n\n\treturn 0;\n}\n\n/*\n ***************************************************************************\n * Test mode: Ignore environment variable value.\n ***************************************************************************\n */\nchar *get_env_value(const char *c)\n{\n\tif (!__env)\n\t\treturn NULL;\n\n\tfprintf(stderr, \"Reading contents of %s\\n\", c);\n\treturn getenv(c);\n}\n\n/*\n ***************************************************************************\n * Test mode: Go to next time period.\n ***************************************************************************\n */\nvoid next_time_step(void)\n{\n\tint root_nr = 1;\n\tchar rootf[64], testf[128];\n\tchar *resolved_name;\n\n\t__unix_time += interval;\n\n\t/* Get root directory name (root1, root2, etc.) at which the \"root\" symlink points */\n\tif ((resolved_name = realpath(ROOTDIR, NULL)) != NULL) {\n\t\tif (strlen(resolved_name) > 4) {\n\t\t\t/* Set root_nr to the root directory number (1, 2, etc.) */\n\t\t\troot_nr = atoi(resolved_name + strlen(resolved_name) - 1);\n\t\t}\n\t\tfree(resolved_name);\n\t}\n\tif ((unlink(ROOTDIR) < 0) && (errno != ENOENT)) {\n\t\tperror(\"unlink\");\n\t\texit(1);\n\t}\n\n\t/* Set next root directory name (root2, root3, etc.). Directories like root1b are unreachable */\n\tsnprintf(rootf, sizeof(rootf), \"%s%d\", ROOTFILE, ++root_nr);\n\trootf[sizeof(rootf) - 1] = '\\0';\n\tsnprintf(testf, sizeof(testf), \"%s/%s\", TESTDIR, rootf);\n\ttestf[sizeof(testf) - 1] = '\\0';\n\n\t/* Make sure that new root directory exists */\n\tif (access(testf, F_OK) < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\t/* No more root directories: Simulate a Ctrl/C */\n\t\t\tint_handler(0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Create \"root\" symlink pointing at the new root directory */\n\tif (symlink(rootf, ROOTDIR) < 0) {\n\t\tperror(\"link\");\n\t\texit(1);\n\t}\n}\n\n/*\n ***************************************************************************\n * If current file is considered as a virtual one (\"virtualhd\"), then set\n * its device ID (major 253, minor 2, corresponding here to dm-2) in the\n * stat structure normally filled by the stat() system call.\n * Otherwise, open file and read its major and minor numbers.\n *\n * IN:\n * @name\tPathname to file.\n *\n * OUT:\n * @statbuf\tStructure containing device ID.\n *\n * RETURNS:\n * 0 if it actually was the virtual device, 1 otherwise, and -1 on failure.\n ***************************************************************************\n */\nint virtual_stat(const char *name, struct stat *statbuf)\n{\n\tFILE *fp;\n\tchar line[128];\n\tint major, minor;\n\n\tif (!strcmp(name, VIRTUALHD)) {\n\t\tstatbuf->st_rdev = (253 << MINORBITS) + 2;\n\t\treturn 0;\n\t}\n\n\tstatbuf->st_rdev = 0;\n\n\tif ((fp = fopen(name, \"r\")) == NULL)\n\t\treturn -1;\n\n\tif (fgets(line, sizeof(line), fp) != NULL) {\n\t\tsscanf(line, \"%d %d\", &major, &minor);\n\t\tstatbuf->st_rdev = (major << MINORBITS) + minor;\n\t}\n\n\tfclose(fp);\n\n\treturn 1;\n}\n\n/*\n ***************************************************************************\n * Open a \"_list\" file containing a list of files enumerated in a known\n * order contained in current directory.\n *\n * IN:\n * @name\tPathname to directory containing the \"_list\" file.\n *\n * RETURNS:\n * A pointer on current \"_list\" file.\n ***************************************************************************\n */\nDIR *open_list(const char *name)\n{\n\tFILE *fp;\n\tchar filename[1024];\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\", name, _LIST);\n\tfilename[sizeof(filename) - 1] = '\\0';\n\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\treturn NULL;\n\n\treturn (DIR *) fp;\n}\n\n/*\n ***************************************************************************\n * Read next file name contained in a \"_list\" file.\n *\n * IN:\n * @dir\tPointer on current \"_list\" file.\n *\n * RETURNS:\n * A structure containing the name of the next file to read.\n ***************************************************************************\n */\nstruct dirent *read_list(DIR *dir)\n{\n\tFILE *fp = (FILE *) dir;\n\tstatic struct dirent drd;\n\tchar line[1024];\n\n\n\tif ((fgets(line, sizeof(line), fp) != NULL) && (strlen(line) > 1) &&\n\t\t(strlen(line) < sizeof(drd.d_name))) {\n\t\tstrcpy(drd.d_name, line);\n\t\tdrd.d_name[strlen(line) - 1] = '\\0';\n\t\treturn &drd;\n\t}\n\n\treturn NULL;\n}\n\n/*\n ***************************************************************************\n * Close a \"_list\" file.\n *\n * IN:\n * @dir\tPointer on \"_list\" file to close.\n ***************************************************************************\n */\nvoid close_list(DIR *dir)\n{\n\tFILE *fp = (FILE *) dir;\n\n\tfclose(fp);\n}\n\n/*\n ***************************************************************************\n * Replacement function for realpath() system call. Do nothing here.\n *\n * IN:\n * @name\tPathname to process.\n * @c\t\tUnused here.\n *\n * RETURNS:\n * Pathname (unchanged).\n ***************************************************************************\n */\nchar *get_realname(char *name, char *c)\n{\n\tchar *resolved_name;\n\n\tif ((resolved_name = (char *) malloc(1024)) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tstrncpy(resolved_name, name, 1024);\n\tresolved_name[1023] = '\\0';\n\n\treturn resolved_name;\n}\n\n/*\n ***************************************************************************\n * Replacement function for getpwuid() system call. Fill a dummy passwd\n * structure containing the name of a user.\n *\n * IN:\n * @uid\t\tUID of the user\n *\n * RETURNS:\n * Pointer on the passwd structure.\n ***************************************************************************\n */\nstruct passwd *get_usrname(uid_t uid)\n{\n\tstatic struct passwd pwd_ent;\n\tstatic char pw_name[16];\n\n\tpwd_ent.pw_name = pw_name;\n\tif (!uid) {\n\t\tstrcpy(pwd_ent.pw_name, \"root\");\n\t}\n\telse {\n\t\tstrcpy(pwd_ent.pw_name, \"testusr\");\n\t}\n\n\treturn &pwd_ent;\n}\n\n/*\n ***************************************************************************\n * Replacement function for fork() system call. Don't fork really but return\n * a known PID number.\n *\n * RETURNS:\n * Known PID number.\n ***************************************************************************\n */\npid_t get_known_pid(void)\n{\n\treturn 8741;\n}\n\n#endif\t/* TEST */\n\n"
        },
        {
          "name": "systest.h",
          "type": "blob",
          "size": 2.478515625,
          "content": "/*\n * sysstat: System performance tools for Linux\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _SYSTEST_H\n#define _SYSTEST_H\n\n#include <time.h>\n#include <dirent.h>\n#include <sys/utsname.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n\n#ifndef MINORBITS\n#define MINORBITS\t20\n#endif\n#define S_MAXMINOR\t((1U << MINORBITS) - 1)\n#define S_MAXMAJOR\t((1U << (32 - MINORBITS)) - 1)\n\n/* Test mode: Use alternate files and syscalls */\n#ifdef TEST\n\n#define PRE\t\t\t\"./tests/root\"\n#define __time(m)\t\tget_unix_time(m)\n#define __uname(m)\t\tget_uname(m)\n#define __statvfs(m,n)\t\tget_fs_stat(m,n)\n#define __getenv(m)\t\tget_env_value(m)\n#define __alarm(m)\n#define __pause()\t\tnext_time_step()\n#define __stat(m,n)\t\tvirtual_stat(m,n)\n#define __opendir(m)\t\topen_list(m)\n#define __readdir(m)\t\tread_list(m)\n#define __closedir(m)\t\tclose_list(m)\n#define __realpath(m,n)\t\tget_realname(m,n)\n#define __gettimeofday(m,n)\tget_day_time(m)\n#define __getpwuid(m)\t\tget_usrname(m)\n#define __fork(m)\t\tget_known_pid(m)\n#define __major(m)\t\t(m >> MINORBITS)\n#define __minor(m)\t\t(m & S_MAXMINOR)\n\n#define ROOTDIR\t\t\"./tests/root\"\n#define ROOTFILE\t\"root\"\n#define TESTDIR\t\t\"./tests\"\n#define VIRTUALHD\t\"./tests/root/dev/mapper/virtualhd\"\n#define _LIST\t\t\"_list\"\n\n#else\n\n#define PRE\t\"\"\n\n#define __time(m)\t\ttime(m)\n#define __uname(m)\t\tuname(m)\n#define __statvfs(m,n)\t\tstatvfs(m,n)\n#define __getenv(m)\t\tgetenv(m)\n#define __alarm(m)\t\talarm(m)\n#define __pause()\t\tpause()\n#define __stat(m,n)\t\tstat(m,n)\n#define __opendir(m)\t\topendir(m)\n#define __readdir(m)\t\treaddir(m)\n#define __closedir(m)\t\tclosedir(m)\n#define __realpath(m,n)\t\trealpath(m,n)\n#define __gettimeofday(m,n)\tgettimeofday(m,n)\n#define __getpwuid(m)\t\tgetpwuid(m)\n#define __fork(m)\t\tfork(m)\n#define __major(m)\t\tmajor(m)\n#define __minor(m)\t\tminor(m)\n\n#endif\t/* TEST */\n\n/*\n ***************************************************************************\n * Functions prototypes\n ***************************************************************************\n */\n#ifdef TEST\nvoid close_list\n\t(DIR *);\nvoid get_day_time\n\t(struct timeval *);\nchar *get_env_value\n\t(const char *);\nint get_fs_stat\n\t(char *, struct statvfs *);\npid_t get_known_pid\n\t(void);\nchar *get_realname\n\t(char *, char *);\nvoid get_uname\n\t(struct utsname *);\ntime_t get_unix_time\n\t(time_t *);\nstruct passwd *get_usrname\n\t(uid_t);\nvoid next_time_step\n\t(void);\nDIR *open_list\n\t(const char *);\nstruct dirent *read_list\n\t(DIR *);\nint virtual_stat\n\t(const char *, struct stat *);\n\nvoid int_handler\n\t(int);\n#endif /* TEST */\n\n#endif  /* _SYSTEST_H */\n"
        },
        {
          "name": "tapestat.c",
          "type": "blob",
          "size": 23.212890625,
          "content": "/*\n * tapestat: report tape statistics\n * (C) 2015 Hewlett-Packard Development Company, L.P.\n *\n * Initial revision by Shane M. SEYMOUR (shane.seymour <at> hpe.com)\n * Modified for sysstat by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <dirent.h>\n#define __DO_NOT_DEFINE_COMPILE\n#include <regex.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#undef HZ /* sys/param.h defines HZ but needed for MAXPATHLEN */\n#endif\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 256\n#endif\n\n#include \"version.h\"\n#include \"tapestat.h\"\n#include \"rd_stats.h\"\n#include \"count.h\"\n\n#include <locale.h>\t/* For setlocale() */\n#ifdef USE_NLS\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\n#ifdef USE_SCCSID\n#define SCCSID \"@(#)sysstat-\" VERSION \": \" __FILE__ \" compiled \" __DATE__ \" \" __TIME__\nchar *sccsid(void) { return (SCCSID); }\n#endif\n\n#ifdef TEST\nextern int __env;\n#endif\n\nint cpu_nr = 0;\t\t/* Nb of processors on the machine */\nuint64_t flags = 0;\t/* Flag for common options and system state */\nuint64_t xflags = 0;\t/* Extended flag for options used by multiple commands */\n\nlong interval = 0;\nchar timestamp[TIMESTAMP_LEN];\n\nstruct sigaction alrm_act, int_act;\nint sigint_caught = 0;\n\n/* Number of decimal places */\nint dplaces_nr = -1;\n\n/*\n * For tape stats - it would be extremely rare for there to be a very large\n * number of tape drives attached to a system. I wouldn't expect to see more\n * than 20-30 in a very large configuration and discontinguous ones should\n * be even more rare. Because of this we keep the old and new data in a\n * simple data structure with the tape index being the number after the tape\n * drive, st0 at index 0, etc.\n */\nint max_tape_drives = 0;\nstruct tape_stats *tape_new_stats = { NULL };\nstruct tape_stats *tape_old_stats = { NULL };\nregex_t tape_reg;\n\n/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command.\n ***************************************************************************\n */\nvoid usage(char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [ options ] [ <interval> [ <count> ] ]\\n\"),\n\t\tprogname);\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ --human ] [ -k | -m ] [ -o JSON ] [ -t ] [ -V ] [ -y ] [ -z ]\\n\"));\n\texit(1);\n}\n\n/*\n ***************************************************************************\n * SIGALRM signal handler. No need to reset the handler here.\n *\n * IN:\n * @sig\tSignal number.\n ***************************************************************************\n */\nvoid alarm_handler(int sig)\n{\n\talarm(interval);\n}\n\n/*\n * **************************************************************************\n * SIGINT signal handler.\n *\n * IN:\n * @sig\tSignal number.\n **************************************************************************\n */\nvoid int_handler(int sig)\n{\n\tsigint_caught = 1;\n}\n\n/*\n ***************************************************************************\n * Initialization.\n ***************************************************************************\n */\nvoid tape_initialise(void)\n{\n\t/* How many processors on this machine? */\n\tcpu_nr = get_cpu_nr(~0, FALSE);\n\n\t/* Compile regular expression for tape names */\n        if (regcomp(&tape_reg, \"^st[0-9]+$\", REG_EXTENDED) != 0) {\n\t\texit(1);\n        }\n}\n\n/*\n ***************************************************************************\n * Free structures.\n ***************************************************************************\n */\nvoid tape_uninitialise(void)\n{\n\tregfree(&tape_reg);\n\tif (tape_old_stats != NULL) {\n\t\tfree(tape_old_stats);\n\t}\n\tif (tape_new_stats != NULL) {\n\t\tfree(tape_new_stats);\n\t}\n}\n\n/*\n ***************************************************************************\n * Get maximum number of tapes in the system.\n *\n * RETURNS:\n * Number of tapes found.\n ***************************************************************************\n */\nint get_max_tape_drives(void)\n{\n\tDIR *dir;\n\tstruct dirent *entry;\n\tint new_max_tape_drives, tmp, num_stats_dir = 0;\n\tregmatch_t match;\n\tchar stats_dir[MAXPATHLEN + 1];\n\tstruct stat stat_buf;\n\n\tnew_max_tape_drives = max_tape_drives;\n\n\t/* Open sysfs tree */\n\tdir = opendir(SYSFS_CLASS_TAPE_DIR);\n\tif (dir == NULL)\n\t\treturn 0;\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\n\t\tif (regexec(&tape_reg, &entry->d_name[0], 1, &match, 0) == 0) {\n\t\t\t/* d_name[2] to skip the st at the front */\n\t\t\ttmp = atoi(&entry->d_name[2]) + 1;\n\t\t\tif (tmp > new_max_tape_drives) {\n\t\t\t\tnew_max_tape_drives = tmp;\n\t\t\t}\n\t\t}\n\t\tsnprintf(stats_dir, MAXPATHLEN, \"%s/%s/%s\",\n\t\t\tSYSFS_CLASS_TAPE_DIR, &entry->d_name[0], \"stats\");\n\t\tif (stat(stats_dir, &stat_buf) == 0) {\n\t\t\tif (S_ISDIR(stat_buf.st_mode)) {\n\t\t\t\tnum_stats_dir++;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dir);\n\n\t/* If there are no stats directories make the new number of tape drives 0 */\n\tif (num_stats_dir == 0) {\n\t\tnew_max_tape_drives = 0;\n\t}\n\n\treturn new_max_tape_drives;\n}\n\n/*\n ***************************************************************************\n * Check if new tapes have been added and reallocate structures accordingly.\n ***************************************************************************\n */\nvoid tape_check_tapes_and_realloc(void)\n{\n\tint new_max_tape_drives;\n\n\t/* Count again number of tapes */\n\tnew_max_tape_drives = get_max_tape_drives();\n\n\tif (new_max_tape_drives > max_tape_drives && new_max_tape_drives > 0) {\n\t\tint i;\n\n\t\t/* New tapes found: Realloc structures */\n\t\tstruct tape_stats *tape_old_stats_t = (struct tape_stats *)\n\t\t\trealloc(tape_old_stats,\tsizeof(struct tape_stats) * new_max_tape_drives);\n\t\tstruct tape_stats *tape_new_stats_t = (struct tape_stats *)\n\t\t\trealloc(tape_new_stats,\tsizeof(struct tape_stats) * new_max_tape_drives);\n\t\tif ((tape_old_stats_t == NULL) || (tape_new_stats_t == NULL)) {\n\t\t\tif (tape_old_stats_t != NULL) {\n\t\t\t\tfree(tape_old_stats_t);\n\t\t\t\ttape_old_stats_t = NULL;\n\t\t\t} else {\n\t\t\t\tfree(tape_old_stats);\n\t\t\t\ttape_old_stats = NULL;\n\t\t\t}\n\t\t\tif (tape_new_stats_t != NULL) {\n\t\t\t\tfree(tape_new_stats_t);\n\t\t\t\ttape_new_stats_t = NULL;\n\t\t\t} else {\n\t\t\t\tfree(tape_new_stats);\n\t\t\t\ttape_new_stats = NULL;\n\t\t\t}\n\n\t\t\tperror(\"realloc\");\n\t\t\texit(4);\n\t\t}\n\n\t\ttape_old_stats = tape_old_stats_t;\n\t\ttape_new_stats = tape_new_stats_t;\n\n\t\tfor (i = max_tape_drives; i < new_max_tape_drives; i++) {\n\t\t\ttape_old_stats[i].valid = TAPE_STATS_INVALID;\n\t\t\ttape_new_stats[i].valid = TAPE_STATS_INVALID;\n\t\t}\n\t\tmax_tape_drives = new_max_tape_drives;\n\t}\n}\n\n/*\n ***************************************************************************\n * Collect initial statistics for all existing tapes in the system.\n * This function should be called only once.\n ***************************************************************************\n */\nvoid tape_gather_initial_stats(void)\n{\n\tint new_max_tape_drives, i;\n\tFILE *fp;\n\tchar filename[MAXPATHLEN + 1];\n\n\t/* Get number of tapes in the system */\n\tnew_max_tape_drives = get_max_tape_drives();\n\n\tif (new_max_tape_drives == 0) {\n\t\t/* No tapes found */\n\t\tif (!DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t\tfprintf(stderr, _(\"No tape drives with statistics found\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\t/*\n\t\t * Don't exit now if displaying stats in JSON format so that\n\t\t * JSON file can be properly terminated.\n\t\t */\n\t}\n\telse {\n\t\t/* Allocate structures */\n\t\tif (tape_old_stats == NULL) {\n\t\t\ttape_old_stats = (struct tape_stats *)\n\t\t\t\tmalloc(sizeof(struct tape_stats) * new_max_tape_drives);\n\t\t\ttape_new_stats = (struct tape_stats *)\n\t\t\t\tmalloc(sizeof(struct tape_stats) * new_max_tape_drives);\n\t\t\tfor (i = 0; i < new_max_tape_drives; i++) {\n\t\t\t\ttape_old_stats[i].valid = TAPE_STATS_INVALID;\n\t\t\t\ttape_new_stats[i].valid = TAPE_STATS_INVALID;\n\t\t\t}\n\t\t} else\n\t\t\t/* This should only be called once */\n\t\t\treturn;\n\t}\n\n\tmax_tape_drives = new_max_tape_drives;\n\n\t/* Read stats for each tape */\n\tfor (i = 0; i < max_tape_drives; i++) {\n\t\t/*\n\t\t * Everything starts out valid but failing to open\n\t\t * a file gets the tape drive marked invalid.\n\t\t */\n\t\ttape_new_stats[i].valid = TAPE_STATS_VALID;\n\t\ttape_old_stats[i].valid = TAPE_STATS_VALID;\n\n\t\t__gettimeofday(&tape_old_stats[i].tv, NULL);\n\n\t\ttape_new_stats[i].tv.tv_sec = tape_old_stats[i].tv.tv_sec;\n\t\ttape_new_stats[i].tv.tv_usec = tape_old_stats[i].tv.tv_usec;\n\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"read_ns\", read_time)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"write_ns\", write_time)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"io_ns\", other_time)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"read_byte_cnt\", read_bytes)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"write_byte_cnt\", write_bytes)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"read_cnt\", read_count)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"write_cnt\", write_count)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"other_cnt\", other_count)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"resid_cnt\", resid_count)\n\n\t\ttape_old_stats[i].read_time = 0;\n\t\ttape_old_stats[i].write_time = 0;\n\t\ttape_old_stats[i].other_time = 0;\n\t\ttape_old_stats[i].read_bytes = 0;\n\t\ttape_old_stats[i].write_bytes = 0;\n\t\ttape_old_stats[i].read_count = 0;\n\t\ttape_old_stats[i].write_count = 0;\n\t\ttape_old_stats[i].other_count = 0;\n\t\ttape_old_stats[i].resid_count = 0;\n\t}\n}\n\n/*\n ***************************************************************************\n * Collect a new sample of statistics for all existing tapes in the system.\n ***************************************************************************\n */\nvoid tape_get_updated_stats(void)\n{\n\tint i;\n\tFILE *fp;\n\tchar filename[MAXPATHLEN + 1] = { 0 };\n\n\t/* Check tapes and realloc structures if  needed */\n\ttape_check_tapes_and_realloc();\n\n\tfor (i = 0; i < max_tape_drives; i++) {\n\t\t/*\n\t\t * Everything starts out valid but failing\n\t\t * to open a file gets the tape drive marked invalid.\n\t\t */\n\t\ttape_new_stats[i].valid = TAPE_STATS_VALID;\n\t\t__gettimeofday(&tape_new_stats[i].tv, NULL);\n\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"read_ns\", read_time)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"write_ns\", write_time)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"io_ns\", other_time)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"read_byte_cnt\", read_bytes)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"write_byte_cnt\", write_bytes)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"read_cnt\", read_count)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"write_cnt\", write_count)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"other_cnt\", other_count)\n\t\tTAPE_STAT_FILE_VAL(TAPE_STAT_PATH \"resid_cnt\", resid_count)\n\n\t\tif ((tape_new_stats[i].read_time < tape_old_stats[i].read_time) ||\n\t\t    (tape_new_stats[i].write_time < tape_old_stats[i].write_time) ||\n\t\t    (tape_new_stats[i].other_time < tape_old_stats[i].other_time)) {\n\t\t\ttape_new_stats[i].valid = TAPE_STATS_INVALID;\n\t\t}\n\t}\n}\n\n/*\n ***************************************************************************\n * Display tapes statistics headings.\n ***************************************************************************\n */\nvoid write_tape_headings(int *tab)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf((*tab)++, \"\\\"tape\\\": [\");\n\t\treturn;\n\t}\n\n\tprintf(\"Tape:     r/s     w/s   \");\n\tif (DISPLAY_MEGABYTES(flags)) {\n\t\tprintf(\"MB_read/s   MB_wrtn/s\");\n\t} else {\n\t\tprintf(\"kB_read/s   kB_wrtn/s\");\n\t}\n\tprintf(\"  %%Rd  %%Wr  %%Oa    Rs/s    Ot/s\\n\");\n}\n\n/*\n ***************************************************************************\n * Calculate statistics for current tape.\n *\n * IN:\n * @i\t\tIndex in array for current tape.\n *\n * OUT:\n * @stats\tStatistics for current tape.\n ***************************************************************************\n */\nvoid tape_calc_one_stats(struct calc_stats *stats, int i)\n{\n\tuint64_t duration;\n\tdouble temp;\n\tFILE *fp;\n\n\t/* Duration in ms done in ms to prevent rounding issues with using seconds */\n\tduration = (tape_new_stats[i].tv.tv_sec -\n\t\ttape_old_stats[i].tv.tv_sec) * 1000;\n\tduration -= tape_old_stats[i].tv.tv_usec / 1000;\n\tduration += tape_new_stats[i].tv.tv_usec / 1000;\n\n\t/* If duration is zero we need to calculate the ms since boot time */\n\tif (duration == 0) {\n\t\tfp = fopen(UPTIME, \"r\");\n\n\t\t/*\n\t\t * Get uptime from /proc/uptime and if we can't then just set duration to\n\t\t * be 0 - it will mean that we don't calculate stats.\n\t\t */\n\t\tif (fp == NULL) {\n\t\t\tduration = 0;\n\t\t} else {\n\t\t\tif (fscanf(fp, \"%lf\", &temp) != 1) {\n\t\t\t\ttemp = 0;\n\t\t\t}\n\t\t\tduration = (uint64_t) (temp * 1000);\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\n\t/* The second value passed into the macro is the thing being calculated */\n\tCALC_STAT_CNT(read_count, reads_per_second)\n\tCALC_STAT_CNT(write_count, writes_per_second)\n\tCALC_STAT_CNT(other_count, other_per_second)\n\tCALC_STAT_KB(read_bytes, kbytes_read_per_second)\n\tCALC_STAT_KB(write_bytes, kbytes_written_per_second)\n\tCALC_STAT_PCT(read_time, read_pct_wait)\n\tCALC_STAT_PCT(write_time, write_pct_wait)\n\tCALC_STAT_PCT(other_time, all_pct_wait)\n\tCALC_STAT_CNT(resid_count, resids_per_second)\n}\n\n/*\n ***************************************************************************\n * Display statistics for current tape in plain format.\n *\n * IN:\n * @tape\tStatistics for current tape.\n * @i\t\tIndex in array for current tape.\n ***************************************************************************\n */\nvoid write_plain_tape_stats(struct calc_stats *tape, int i)\n{\n\tchar buffer[32];\n\tuint64_t divisor = 1;\n\n\tif (DISPLAY_MEGABYTES(flags))\n\t\tdivisor = 1024;\n\n\tsprintf(buffer, \"st%i        \", i);\n\tbuffer[5] = 0;\n\tcprintf_in(IS_STR, \"%s\", buffer, 0);\n\tcprintf_u64(NO_UNIT, 2, 7,\n\t\t    tape->reads_per_second,\n\t\t    tape->writes_per_second);\n\tcprintf_u64(DISPLAY_UNIT(flags) ? UNIT_KILOBYTE : NO_UNIT, 2, 11,\n\t\t    DISPLAY_UNIT(flags) ? tape->kbytes_read_per_second\n\t\t\t\t\t: tape->kbytes_read_per_second / divisor,\n\t\t    DISPLAY_UNIT(flags) ? tape->kbytes_written_per_second\n\t\t\t\t\t: tape->kbytes_written_per_second / divisor);\n\tcprintf_xpc(DISPLAY_UNIT(flags), XHIGH, 3, 4, 0,\n\t\t   (double) tape->read_pct_wait,\n\t\t   (double) tape->write_pct_wait,\n\t\t   (double) tape->all_pct_wait);\n\tcprintf_u64(NO_UNIT, 2, 7,\n\t\t    tape->resids_per_second,\n\t\t    tape->other_per_second);\n\tprintf(\"\\n\");\n}\n\n/*\n * **************************************************************************\n * Display statistics for current tape in JSON format.\n *\n * IN:\n * @tab\t\tNumber of tabs to print.\n * @tape\tStatistics for current tape.\n * @i\t\tIndex in array for current tape.\n ***************************************************************************\n */\nvoid write_json_tape_stats(int tab, struct calc_stats *tape, int i)\n{\n\n\tchar line[256];\n\tuint64_t divisor = 1;\n\n\txprintf0(tab,\n\t\t \"{\\\"tape_device\\\": \\\"st%i\\\", \"\n\t\t \"\\\"r/s\\\": %\" PRIu64 \", \\\"w/s\\\": %\" PRIu64 \", \",\n\t\t i, tape->reads_per_second, tape->writes_per_second);\n\n\tif (DISPLAY_MEGABYTES(flags)) {\n\t\tdivisor = 1024;\n\t\tsprintf(line, \"\\\"MB_read/s\\\": %%%s, \\\"MB_wrtn/s\\\": %%%s, \",\n\t\t\tPRIu64, PRIu64);\n\t}\n\telse {\n\t\tsprintf(line, \"\\\"kB_read/s\\\": %%%s, \\\"kB_wrtn/s\\\": %%%s, \",\n\t\t\tPRIu64, PRIu64);\n\t}\n\n\tprintf(line,\n\t       tape->kbytes_read_per_second / divisor,\n\t       tape->kbytes_written_per_second / divisor);\n\tprintf(\"\\\"Rd\\\": %\" PRIu64 \", \\\"Wr\\\": %\" PRIu64 \", \\\"Oa\\\": %\" PRIu64 \", \"\n\t       \"\\\"Rs/s\\\": %\" PRIu64 \", \\\"Ot/s\\\": %\" PRIu64 \"}\",\n\t       tape->read_pct_wait,\n\t       tape->write_pct_wait,\n\t       tape->all_pct_wait,\n\t       tape->resids_per_second,\n\t       tape->other_per_second);\n}\n\n/*\n * **************************************************************************\n * Display statistics for current tape in plain or JSON format.\n *\n * IN:\n * @tape\tStatistics for current tape.\n * @i\t\tIndex in array for current tape.\n * @tab\t\tNumber of tabs to print (JSON format only).\n ***************************************************************************\n */\nvoid write_tape_stats(struct calc_stats *tape, int i, int tab)\n{\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\twrite_json_tape_stats(tab, tape, i);\n\t}\n\telse {\n\t\twrite_plain_tape_stats(tape, i);\n\t}\n}\n\n/*\n ***************************************************************************\n * Print everything now (stats and uptime).\n *\n * IN:\n * @rectime\tCurrent date and time.\n ***************************************************************************\n */\nvoid write_stats(struct tm *rectime)\n{\n\tint tab = 4, next = FALSE;\n\tstruct calc_stats tape;\n\tstruct tape_stats *tmp;\n\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\txprintf(tab++, \"{\");\n\t}\n\n\t/* Print time stamp */\n\tif (DISPLAY_TIMESTAMP(flags)) {\n\t\twrite_sample_timestamp(tab, rectime, xflags);\n\t}\n\n\t/* Print the headings */\n\twrite_tape_headings(&tab);\n\n\t/*\n\t * If either new or old is invalid or the I/Os per second is 0 and\n\t * zero omit is true then we print nothing.\n\t */\n\tif (max_tape_drives > 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < max_tape_drives; i++) {\n\t\t\tif ((tape_new_stats[i].valid == TAPE_STATS_VALID) &&\n\t\t\t\t(tape_old_stats[i].valid == TAPE_STATS_VALID)) {\n\t\t\t\ttape_calc_one_stats(&tape, i);\n\n\t\t\t\tif (!(DISPLAY_ZERO_OMIT(flags)\n\t\t\t\t\t&& (tape.other_per_second == 0)\n\t\t\t\t\t&& (tape.reads_per_second == 0)\n\t\t\t\t\t&& (tape.writes_per_second == 0)\n\t\t\t\t\t&& (tape.kbytes_read_per_second == 0)\n\t\t\t\t\t&& (tape.kbytes_written_per_second == 0)\n\t\t\t\t\t&& (tape.read_pct_wait == 0)\n\t\t\t\t\t&& (tape.write_pct_wait == 0)\n\t\t\t\t\t&& (tape.all_pct_wait == 0)\n\t\t\t\t\t&& (tape.resids_per_second == 0))) {\n\n\t\t\t\t\tif (DISPLAY_JSON_OUTPUT(xflags) && next) {\n\t\t\t\t\t\tprintf(\",\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tnext = TRUE;\n\n\t\t\t\t\twrite_tape_stats(&tape, i, tab);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Swap new and old so next time we compare against the new old stats.\n\t\t * If a new tape drive appears it won't appear in the output until after\n\t\t * the second time we gather information about it.\n\t\t */\n\t\ttmp = tape_old_stats;\n\t\ttape_old_stats = tape_new_stats;\n\t\ttape_new_stats = tmp;\n\t}\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\n\");\n\t\txprintf(--tab, \"]\");\n\t\txprintf0(--tab, \"}\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Main loop: Read tape stats from the relevant sources and display them.\n *\n * IN:\n * @count\tNumber of lines of stats to print.\n * @rectime\tCurrent date and time.\n ***************************************************************************\n */\nvoid rw_tape_stat_loop(long int count, struct tm *rectime)\n{\n\tstruct tape_stats *tmp;\n\tint skip = 0;\n\n\t/* Should we skip first report? */\n\tif (DISPLAY_OMIT_SINCE_BOOT(flags) && interval > 0) {\n\t\tskip = 1;\n\t}\n\n\t/* Set a handler for SIGALRM */\n\tmemset(&alrm_act, 0, sizeof(alrm_act));\n\talrm_act.sa_handler = alarm_handler;\n\tsigaction(SIGALRM, &alrm_act, NULL);\n\talarm(interval);\n\n\t/* Set a handler for SIGINT */\n\tmemset(&int_act, 0, sizeof(int_act));\n\tint_act.sa_handler = int_handler;\n\tsigaction(SIGINT, &int_act, NULL);\n\n\tdo {\n\n\t\tif (tape_new_stats == NULL) {\n\t\t\ttape_gather_initial_stats();\n\t\t\tif (!max_tape_drives) {\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttape_get_updated_stats();\n\t\t}\n\n\t\t/* Get time */\n\t\tget_xtime(rectime, 0, LOCAL_TIME);\n\n\t\t/* Check whether we should skip first report */\n\t\tif (!skip) {\n\t\t\t/* Print results */\n\t\t\twrite_stats(rectime);\n\n\t\t\tif (count > 0) {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttmp = tape_old_stats;\n\t\t\ttape_old_stats = tape_new_stats;\n\t\t\ttape_new_stats = tmp;\n\t\t}\n\n\t\tif (count) {\n\t\t\t__pause();\n\n\t\t\tif (sigint_caught) {\n\t\t\t\t/* SIGINT signal caught => Terminate JSON output properly */\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse if (DISPLAY_JSON_OUTPUT(xflags) && !skip) {\t/* count != 0 */\n\t\t\t\tprintf(\",\");\n\t\t\t}\n\t\t}\n\t\tskip = 0;\n\t\tprintf(\"\\n\");\n\t}\n\twhile (count);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\tprintf(\"\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}}\\n\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Main entry to the tapestat program.\n ***************************************************************************\n */\nint main(int argc, char **argv)\n{\n\tint it = 0;\n\tint opt = 1;\n\tint i;\n\tlong count = 1;\n\tstruct utsname header;\n\tstruct tm rectime;\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\t/* Init color strings */\n\tinit_colors();\n\n\t/* Process args... */\n\twhile (opt < argc) {\n\n\t\tif (!strcmp(argv[opt], \"--human\")) {\n\t\t\tflags |= T_D_UNIT;\n\t\t\topt++;\n\t\t}\n\n#ifdef TEST\n\t\telse if (!strncmp(argv[opt], \"--getenv\", 8)) {\n\t\t\t__env = TRUE;\n\t\t\topt++;\n\t\t}\n#endif\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\t/* Select output format */\n\t\t\tif (argv[++opt] && !strcmp(argv[opt], K_JSON)) {\n\t\t\t\txflags |= X_D_JSON_OUTPUT;\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\tfor (i = 1; *(argv[opt] + i); i++) {\n\n\t\t\t\tswitch (*(argv[opt] + i)) {\n\n\t\t\t\tcase 'k':\n\t\t\t\t\tif (DISPLAY_MEGABYTES(flags)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\t/* Display stats in kB/s */\n\t\t\t\t\tflags |= T_D_KILOBYTES;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'm':\n\t\t\t\t\tif (DISPLAY_KILOBYTES(flags)) {\n\t\t\t\t\t\tusage(argv[0]);\n\t\t\t\t\t}\n\t\t\t\t\t/* Display stats in MB/s */\n\t\t\t\t\tflags |= T_D_MEGABYTES;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 't':\n\t\t\t\t\t/* Display timestamp */\n\t\t\t\t\tflags |= T_D_TIMESTAMP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'y':\n\t\t\t\t\t/* Don't display stats since system restart */\n\t\t\t\t\tflags |= T_D_OMIT_SINCE_BOOT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'z':\n\t\t\t\t\t/* Omit output for devices with no activity */\n\t\t\t\t\tflags |= T_D_ZERO_OMIT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'V':\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *tapestat_env[] = {ENV_COLORS,\n\t\t\t\t\t\t\t\t\tENV_COLORS_SGR,\n\t\t\t\t\t\t\t\t\tENV_TIME_FMT};\n#define TAPESTAT_ENV_NR\t3\n\t\t\t\t\t\t/* Print environment contents, version number and exit */\n\t\t\t\t\t\tprint_version(tapestat_env, TAPESTAT_ENV_NR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (!it) {\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = -1;\n\t\t\tit = 1;\n\t\t}\n\n\t\telse if (it > 0) {\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif ((count < 1) || !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tit = -1;\n\t\t}\n\t\telse {\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!interval) {\n\t\tcount = 1;\n\t}\n\n\ttape_initialise();\n\n\tget_xtime(&rectime, 0, LOCAL_TIME);\n\n\t/*\n\t * Don't buffer data if redirected to a pipe.\n\t * Note: With musl-c, the behavior of this function is undefined except\n\t * when it is the first operation on the stream.\n\t */\n\tsetbuf(stdout, NULL);\n\n\tif (DISPLAY_JSON_OUTPUT(xflags)) {\n\t\t/* Use a decimal point to make JSON code compliant with RFC7159 */\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t}\n\n\t/* Get system name, release number and hostname */\n\t__uname(&header);\n\tif (print_gal_header(&rectime, header.sysname, header.release,\n\t\t\t     header.nodename, header.machine, cpu_nr,\n\t\t\t     DISPLAY_JSON_OUTPUT(xflags))) {\n\t\txflags |= X_D_ISO;\n\t}\n\tif (!DISPLAY_JSON_OUTPUT(xflags) &&\n\t\t(!DISPLAY_OMIT_SINCE_BOOT(flags) || (interval == 0))) {\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* Main loop */\n\trw_tape_stat_loop(count, &rectime);\n\n\t/* Free structures */\n\ttape_uninitialise();\n\n\treturn 0;\n}\n"
        },
        {
          "name": "tapestat.h",
          "type": "blob",
          "size": 3.50390625,
          "content": "/*\n * tapestat: report tape statistics\n * (C) 2015 Hewlett-Packard Development Company, L.P.\n *\n * Initial revision by Shane M. SEYMOUR (shane.seymour <at> hpe.com)\n * Modified for sysstat by Sebastien GODARD (sysstat <at> orange.fr)\n */\n\n#ifndef _TAPESTAT_H\n#define _TAPESTAT_H\n\n#include \"common.h\"\n\n/* T_: tapestat - D_: Display - F_: Flag */\n#define T_D_TIMESTAMP\t\t0x00001\n#define T_D_KILOBYTES\t\t0x00002\n#define T_D_MEGABYTES\t\t0x00004\n#define T_D_OMIT_SINCE_BOOT\t0x00008\n/* Unused\t\t\t0x00010 */\n#define T_D_ZERO_OMIT\t\t0x00020\n#define T_D_UNIT\t\t0x00040\n\n#define DISPLAY_TIMESTAMP(m)\t\t(((m) & T_D_TIMESTAMP)       == T_D_TIMESTAMP)\n#define DISPLAY_KILOBYTES(m)\t\t(((m) & T_D_KILOBYTES)       == T_D_KILOBYTES)\n#define DISPLAY_MEGABYTES(m)\t\t(((m) & T_D_MEGABYTES)       == T_D_MEGABYTES)\n#define DISPLAY_OMIT_SINCE_BOOT(m)\t(((m) & T_D_OMIT_SINCE_BOOT) == T_D_OMIT_SINCE_BOOT)\n#define DISPLAY_ZERO_OMIT(m)\t\t(((m) & T_D_ZERO_OMIT)       == T_D_ZERO_OMIT)\n#define DISPLAY_UNIT(m)\t\t\t(((m) & T_D_UNIT)\t     == T_D_UNIT)\n\nenum {\n\tTAPE_STATS_INVALID = 0,\n\tTAPE_STATS_VALID   = 1\n};\n\n#define SYSFS_CLASS_TAPE_DIR \tPRE \"/sys/class/scsi_tape\"\n#define TAPE_STAT_PATH\t\tPRE \"/sys/class/scsi_tape/st%i/stats/\"\n\n#define TAPE_STAT_FILE_VAL(A, B)\t\t\t\t\t\\\n\tsnprintf(filename, MAXPATHLEN, A, i);\t\t\t\t\\\n\tif ((fp = fopen(filename, \"r\")) != NULL) {\t\t\t\\\n\t\tif (fscanf(fp, \"%\"PRId64, &tape_new_stats[i].B) != 1) {\t\\\n\t\t\ttape_new_stats[i].valid = TAPE_STATS_INVALID;\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tfclose(fp);\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\ttape_new_stats[i].valid = TAPE_STATS_INVALID;\t\t\\\n\t\tcontinue;\t\t\t\t\t\t\\\n\t}\n\n\n/*\n * A - tape_stats structure member name, e.g. read_count\n * B - calc_stats structure member name, e.g. reads_per_second\n *\n * These macros are not selfcontained they depend on some other\n * variables defined either as global or local to the function.\n */\n\n#define CALC_STAT_CNT(A, B)\t\t\t\t\t\\\n\tif ((tape_new_stats[i].A == tape_old_stats[i].A) ||\t\\\n\t\t(duration <= 0)) {\t\t\t\t\\\n\t\tstats->B = 0;\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\\\n                temp = (double) (tape_new_stats[i].A -\t\t\\\n\t\t\ttape_old_stats[i].A)\t\t\t\\\n\t\t\t/ (((double) duration) / 1000);\t\t\\\n\t\tstats->B = (uint64_t) temp;\t\t\t\\\n\t}\n#define CALC_STAT_KB(A, B)\t\t\t\t\t\\\n        if ((tape_new_stats[i].A == tape_old_stats[i].A) ||\t\\\n\t\t(duration <= 0)) {\t\t\t\t\\\n\t\tstats->B = 0;\t\t\t\t\t\\\n        } else {\t\t\t\t\t\t\\\n\t\ttemp = (double) (tape_new_stats[i].A -\t\t\\\n\t\t\ttape_old_stats[i].A)\t\t\t\\\n\t\t\t/ (((double) duration) / 1000.0);\t\\\n\t\tstats->B = (uint64_t) (temp / 1024.0);\t\t\\\n\t}\n\n#define TAPE_MAX_PCT 999\n\n#define CALC_STAT_PCT(A, B)\t\t\t\t\t\t\\\n\tif ((tape_new_stats[i].A == tape_old_stats[i].A) ||\t\t\\\n\t\t(duration <= 0)) {\t\t\t\t\t\\\n\t\tstats->B = 0;\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\ttemp = (double) (tape_new_stats[i].A -\t\t\t\\\n\t\t\ttape_old_stats[i].A)\t\t\t\t\\\n\t\t\t/ (((double) duration));\t\t\t\\\n\t\tstats->B = (uint64_t) (100.0 * temp / 1000000.0);\t\\\n\t\tif (stats->B > TAPE_MAX_PCT)\t\t\t\t\\\n\t\t\tstats->B = TAPE_MAX_PCT;\t\t\t\t\\\n\t}\n\nstruct tape_stats {\n        uint64_t read_time;\n        uint64_t write_time;\n        uint64_t other_time;\n        uint64_t read_bytes;\n        uint64_t write_bytes;\n        uint64_t read_count;\n        uint64_t write_count;\n        uint64_t other_count;\n        uint64_t resid_count;\n        char valid;\n        struct timeval tv;\n};\nstruct calc_stats {\n        uint64_t reads_per_second;\n        uint64_t writes_per_second;\n        uint64_t other_per_second;\n        uint64_t kbytes_read_per_second;\n        uint64_t kbytes_written_per_second;\n        uint64_t read_pct_wait;\n        uint64_t write_pct_wait;\n        uint64_t all_pct_wait;\n        uint64_t resids_per_second;\n};\n\n#endif  /* _TAPESTAT_H */\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.in",
          "type": "blob",
          "size": 0.3017578125,
          "content": "/*\n * sysstat: System performance tools for Linux\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _VERSION_H\n#define _VERSION_H\n\n#ifndef TEST\n/* sysstat version number */\n#define VERSION\t\"@PACKAGE_VERSION@\"\n#else\n#define VERSION \"99.9.9\"\n#endif\t/* TEST */\n\n#endif  /* _VERSION_H */\n"
        },
        {
          "name": "xml",
          "type": "tree",
          "content": null
        },
        {
          "name": "xml_stats.c",
          "type": "blob",
          "size": 74.1884765625,
          "content": "/*\n * xml_stats.c: Functions used by sadf to display statistics in XML.\n * (C) 1999-2024 by Sebastien GODARD (sysstat <at> orange.fr)\n *\n ***************************************************************************\n * This program is free software; you can redistribute it and/or modify it *\n * under the terms of the GNU General Public License as published  by  the *\n * Free Software Foundation; either version 2 of the License, or (at  your *\n * option) any later version.                                              *\n *                                                                         *\n * This program is distributed in the hope that it  will  be  useful,  but *\n * WITHOUT ANY WARRANTY; without the implied warranty  of  MERCHANTABILITY *\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License *\n * for more details.                                                       *\n *                                                                         *\n * You should have received a copy of the GNU General Public License along *\n * with this program; if not, write to the Free Software Foundation, Inc., *\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA              *\n ***************************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"sa.h\"\n#include \"ioconf.h\"\n\n#ifdef USE_NLS\n#include <locale.h>\n#include <libintl.h>\n#define _(string) gettext(string)\n#else\n#define _(string) (string)\n#endif\n\nextern uint64_t flags;\nextern char bat_status[][16];\n\n/*\n ***************************************************************************\n * Open or close <network> markup.\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tOpen or close action.\n ***************************************************************************\n */\nvoid xml_markup_network(int tab, enum xml_action action)\n{\n\tstatic int markup_state = CLOSE_XML_MARKUP;\n\n\tif (action == markup_state)\n\t\treturn;\n\tmarkup_state = action;\n\n\tif (action == OPEN_XML_MARKUP) {\n\t\t/* Open markup */\n\t\txprintf(tab, \"<network per=\\\"second\\\">\");\n\t}\n\telse {\n\t\t/* Close markup */\n\t\txprintf(tab, \"</network>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Open or close <power-management> markup.\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tOpen or close action.\n ***************************************************************************\n */\nvoid xml_markup_power_management(int tab, enum xml_action action)\n{\n\tstatic int markup_state = CLOSE_XML_MARKUP;\n\n\tif (action == markup_state)\n\t\treturn;\n\tmarkup_state = action;\n\n\tif (action == OPEN_XML_MARKUP) {\n\t\t/* Open markup */\n\t\txprintf(tab, \"<power-management>\");\n\t}\n\telse {\n\t\t/* Close markup */\n\t\txprintf(tab, \"</power-management>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Open or close <psi> markup.\n *\n * IN:\n * @tab\t\tNumber of tabulations.\n * @action\tOpen or close action.\n ***************************************************************************\n */\nvoid xml_markup_psi(int tab, enum xml_action action)\n{\n\tstatic int markup_state = CLOSE_XML_MARKUP;\n\n\tif (action == markup_state)\n\t\treturn;\n\tmarkup_state = action;\n\n\tif (action == OPEN_XML_MARKUP) {\n\t\t/* Open markup */\n\t\txprintf(tab, \"<psi per=\\\"second\\\">\");\n\t}\n\telse {\n\t\t/* Close markup */\n\t\txprintf(tab, \"</psi>\");\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second (independent of the\n *\t\tnumber of processors). Unused here.\n ***************************************************************************\n */\n__print_funct_t xml_print_cpu_stats(struct activity *a, int curr, int tab,\n\t\t\t\t    unsigned long long itv)\n{\n\tint i;\n\tunsigned long long deltot_jiffies = 1;\n\tstruct stats_cpu *scc, *scp;\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\tchar cpuno[16];\n\n\txprintf(tab++, \"<cpu-load>\");\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/*\n\t * Compute CPU \"all\" as sum of all individual CPU (on SMP machines)\n\t * and look for offline CPU.\n\t */\n\tif (a->nr_ini > 1) {\n\t\tdeltot_jiffies = get_global_cpu_statistics(a, !curr, curr,\n\t\t\t\t\t\t\t   flags, offline_cpu_bitmap);\n\t}\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* Don't display CPU */\n\t\t\tcontinue;\n\n\t\tscc = (struct stats_cpu *) ((char *) a->buf[curr]  + i * a->msize);\n\t\tscp = (struct stats_cpu *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\tif (i == 0) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\n\t\t\tif (a->nr_ini == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a UP machine. In this case\n\t\t\t\t * interval has still not been calculated.\n\t\t\t\t */\n\t\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\t\t\t}\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* CPU \"all\" cannot be tickless */\n\t\t\t\tdeltot_jiffies = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\n\t\t\t/*\n\t\t\t * Recalculate interval for current proc.\n\t\t\t * If result is 0 then current CPU is a tickless one.\n\t\t\t */\n\t\t\tdeltot_jiffies = get_per_cpu_interval(scc, scp);\n\n\t\t\tif (!deltot_jiffies) {\n\t\t\t\t/* Current CPU is tickless */\n\t\t\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\t\t\txprintf(tab, \"<cpu number=\\\"%d\\\" \"\n\t\t\t\t\t\t\"user=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"nice=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"system=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"iowait=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"steal=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"idle=\\\"%.2f\\\"/>\",\n\t\t\t\t\t\ti - 1, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t\t}\n\t\t\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\t\t\txprintf(tab, \"<cpu number=\\\"%d\\\" \"\n\t\t\t\t\t\t\"usr=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"nice=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"sys=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"iowait=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"steal=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"irq=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"soft=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"guest=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"gnice=\\\"%.2f\\\" \"\n\t\t\t\t\t\t\"idle=\\\"%.2f\\\"/>\",\n\t\t\t\t\t\ti - 1, 0.0, 0.0, 0.0, 0.0,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 0.0, 0.0, 100.0);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (DISPLAY_CPU_DEF(a->opt_flags)) {\n\t\t\txprintf(tab, \"<cpu number=\\\"%s\\\" \"\n\t\t\t\t\"user=\\\"%.2f\\\" \"\n\t\t\t\t\"nice=\\\"%.2f\\\" \"\n\t\t\t\t\"system=\\\"%.2f\\\" \"\n\t\t\t\t\"iowait=\\\"%.2f\\\" \"\n\t\t\t\t\"steal=\\\"%.2f\\\" \"\n\t\t\t\t\"idle=\\\"%.2f\\\"/>\",\n\t\t\t\tcpuno,\n\t\t\t\tll_sp_value(scp->cpu_user, scc->cpu_user, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_nice, scc->cpu_nice, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_sys + scp->cpu_hardirq + scp->cpu_softirq,\n\t\t\t\t\t    scc->cpu_sys + scc->cpu_hardirq + scc->cpu_softirq,\n\t\t\t\t\t    deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_steal,  scc->cpu_steal, deltot_jiffies),\n\t\t\t\tscc->cpu_idle < scp->cpu_idle ?\n\t\t\t\t0.0 :\n\t\t\t\tll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies));\n\t\t}\n\t\telse if (DISPLAY_CPU_ALL(a->opt_flags)) {\n\t\t\txprintf(tab, \"<cpu number=\\\"%s\\\" \"\n\t\t\t\t\"usr=\\\"%.2f\\\" \"\n\t\t\t\t\"nice=\\\"%.2f\\\" \"\n\t\t\t\t\"sys=\\\"%.2f\\\" \"\n\t\t\t\t\"iowait=\\\"%.2f\\\" \"\n\t\t\t\t\"steal=\\\"%.2f\\\" \"\n\t\t\t\t\"irq=\\\"%.2f\\\" \"\n\t\t\t\t\"soft=\\\"%.2f\\\" \"\n\t\t\t\t\"guest=\\\"%.2f\\\" \"\n\t\t\t\t\"gnice=\\\"%.2f\\\" \"\n\t\t\t\t\"idle=\\\"%.2f\\\"/>\",\n\t\t\t\tcpuno,\n\t\t\t\t(scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest) ?\n\t\t\t\t0.0 :\n\t\t\t\tll_sp_value(scp->cpu_user - scp->cpu_guest,\n\t\t\t\t\t    scc->cpu_user - scc->cpu_guest, deltot_jiffies),\n\t\t\t\t(scc->cpu_nice - scc->cpu_guest_nice) < (scp->cpu_nice - scp->cpu_guest_nice) ?\n\t\t\t\t0.0 :\n\t\t\t\tll_sp_value(scp->cpu_nice - scp->cpu_guest_nice,\n\t\t\t\t\t    scc->cpu_nice - scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_sys, scc->cpu_sys, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_iowait, scc->cpu_iowait, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_steal, scc->cpu_steal, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_hardirq, scc->cpu_hardirq, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_softirq, scc->cpu_softirq, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_guest, scc->cpu_guest, deltot_jiffies),\n\t\t\t\tll_sp_value(scp->cpu_guest_nice, scc->cpu_guest_nice, deltot_jiffies),\n\t\t\t\tscc->cpu_idle < scp->cpu_idle ?\n\t\t\t\t0.0 :\n\t\t\t\tll_sp_value(scp->cpu_idle, scc->cpu_idle, deltot_jiffies));\n\t\t}\n\t}\n\n\txprintf(--tab, \"</cpu-load>\");\n}\n\n/*\n ***************************************************************************\n * Display task creation and context switch statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pcsw_stats(struct activity *a, int curr, int tab,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_pcsw\n\t\t*spc = (struct stats_pcsw *) a->buf[curr],\n\t\t*spp = (struct stats_pcsw *) a->buf[!curr];\n\n\t/* proc/s and cswch/s */\n\txprintf(tab, \"<process-and-context-switch per=\\\"second\\\" \"\n\t\t\"proc=\\\"%.2f\\\" \"\n\t\t\"cswch=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(spp->processes, spc->processes, itv),\n\t\tS_VALUE(spp->context_switch, spc->context_switch, itv));\n}\n\n/*\n ***************************************************************************\n * Display interrupts statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_irq_stats(struct activity *a, int curr, int tab,\n\t\t\t\t    unsigned long long itv)\n{\n\tint i, c;\n\tstruct stats_irq *stc_cpu_irq, *stp_cpu_irq, *stc_cpuall_irq;\n\tunsigned char masked_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\txprintf(tab++, \"<interrupts>\");\n\txprintf(tab++, \"<int-global per=\\\"second\\\">\");\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Identify offline and unselected CPU, and keep persistent statistics values */\n\tget_global_int_statistics(a, !curr, curr, flags, masked_cpu_bitmap);\n\n\tfor (i = 0; i < a->nr2; i++) {\n\n\t\tstc_cpuall_irq = (struct stats_irq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, stc_cpuall_irq->irq_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfor (c = 0; (c < a->nr[curr]) && (c < a->bitmap->b_size + 1); c++) {\n\n\t\t\tstc_cpu_irq = (struct stats_irq *) ((char *) a->buf[curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\t\t\tstp_cpu_irq = (struct stats_irq *) ((char *) a->buf[!curr] + c * a->msize * a->nr2\n\t\t\t\t\t\t\t\t\t\t  + i * a->msize);\n\n\t\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\t\tif (IS_CPU_SET(masked_cpu_bitmap, c))\n\t\t\t\t/* No */\n\t\t\t\tcontinue;\n\n\t\t\t/* Yes: Display it */\n\t\t\tif (!c) {\n\t\t\t\txprintf(tab, \"<irq intr=\\\"%s\\\" cpu=\\\"all\\\" value=\\\"%.2f\\\"/>\",\n\t\t\t\t\tstc_cpuall_irq->irq_name,\n\t\t\t\t\t(stc_cpu_irq->irq_nr < stp_cpu_irq->irq_nr) ? 0.0 :\n\t\t\t\t\tS_VALUE(stp_cpu_irq->irq_nr, stc_cpu_irq->irq_nr, itv));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txprintf(tab, \"<irq intr=\\\"%s\\\" cpu=\\\"%d\\\" value=\\\"%.2f\\\"/>\",\n\t\t\t\t\tstc_cpuall_irq->irq_name,\n\t\t\t\t\tc - 1,\n\t\t\t\t\tS_VALUE(stp_cpu_irq->irq_nr, stc_cpu_irq->irq_nr, itv));\n\t\t\t}\n\t\t}\n\t}\n\n\txprintf(--tab, \"</int-global>\");\n\txprintf(--tab, \"</interrupts>\");\n}\n\n/*\n ***************************************************************************\n * Display swapping statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_swap_stats(struct activity *a, int curr, int tab,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_swap\n\t\t*ssc = (struct stats_swap *) a->buf[curr],\n\t\t*ssp = (struct stats_swap *) a->buf[!curr];\n\n\txprintf(tab, \"<swap-pages per=\\\"second\\\" \"\n\t\t\"pswpin=\\\"%.2f\\\" \"\n\t\t\"pswpout=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(ssp->pswpin,  ssc->pswpin,  itv),\n\t\tS_VALUE(ssp->pswpout, ssc->pswpout, itv));\n}\n\n/*\n ***************************************************************************\n * Display paging statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_paging_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_paging\n\t\t*spc = (struct stats_paging *) a->buf[curr],\n\t\t*spp = (struct stats_paging *) a->buf[!curr];\n\n\txprintf(tab, \"<paging per=\\\"second\\\" \"\n\t\t\"pgpgin=\\\"%.2f\\\" \"\n\t\t\"pgpgout=\\\"%.2f\\\" \"\n\t\t\"fault=\\\"%.2f\\\" \"\n\t\t\"majflt=\\\"%.2f\\\" \"\n\t\t\"pgfree=\\\"%.2f\\\" \"\n\t\t\"pgscank=\\\"%.2f\\\" \"\n\t\t\"pgscand=\\\"%.2f\\\" \"\n\t\t\"pgsteal=\\\"%.2f\\\" \"\n\t\t\"pgprom=\\\"%.2f\\\" \"\n\t\t\"pgdem=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(spp->pgpgin,        spc->pgpgin,        itv),\n\t\tS_VALUE(spp->pgpgout,       spc->pgpgout,       itv),\n\t\tS_VALUE(spp->pgfault,       spc->pgfault,       itv),\n\t\tS_VALUE(spp->pgmajfault,    spc->pgmajfault,    itv),\n\t\tS_VALUE(spp->pgfree,        spc->pgfree,        itv),\n\t\tS_VALUE(spp->pgscan_kswapd, spc->pgscan_kswapd, itv),\n\t\tS_VALUE(spp->pgscan_direct, spc->pgscan_direct, itv),\n\t\tS_VALUE(spp->pgsteal,       spc->pgsteal,       itv),\n\t\tS_VALUE(spp->pgpromote,     spc->pgpromote,     itv),\n\t\tS_VALUE(spp->pgdemote,      spc->pgdemote,      itv));\n}\n\n/*\n ***************************************************************************\n * Display I/O and transfer rate statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_io_stats(struct activity *a, int curr, int tab,\n\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_io\n\t\t*sic = (struct stats_io *) a->buf[curr],\n\t\t*sip = (struct stats_io *) a->buf[!curr];\n\n\txprintf(tab, \"<io per=\\\"second\\\">\");\n\n\t/*\n\t * If we get negative values, this is probably because\n\t * one or more devices/filesystems have been unmounted.\n\t * We display 0.0 in this case though we should rather tell\n\t * the user that the value cannot be calculated here.\n\t */\n\txprintf(++tab, \"<tps>%.2f</tps>\",\n\t\tsic->dk_drive < sip->dk_drive ? 0.0 :\n\t\tS_VALUE(sip->dk_drive, sic->dk_drive, itv));\n\n\txprintf(tab, \"<io-reads rtps=\\\"%.2f\\\" bread=\\\"%.2f\\\"/>\",\n\t\tsic->dk_drive_rio < sip->dk_drive_rio ? 0.0 :\n\t\tS_VALUE(sip->dk_drive_rio, sic->dk_drive_rio, itv),\n\t\tsic->dk_drive_rblk < sip->dk_drive_rblk ? 0.0 :\n\t\tS_VALUE(sip->dk_drive_rblk, sic->dk_drive_rblk, itv));\n\n\txprintf(tab, \"<io-writes wtps=\\\"%.2f\\\" bwrtn=\\\"%.2f\\\"/>\",\n\t\tsic->dk_drive_wio < sip->dk_drive_wio ? 0.0 :\n\t\tS_VALUE(sip->dk_drive_wio, sic->dk_drive_wio, itv),\n\t\tsic->dk_drive_wblk < sip->dk_drive_wblk ? 0.0 :\n\t\tS_VALUE(sip->dk_drive_wblk, sic->dk_drive_wblk, itv));\n\n\txprintf(tab, \"<io-discard dtps=\\\"%.2f\\\" bdscd=\\\"%.2f\\\"/>\",\n\t\tsic->dk_drive_dio < sip->dk_drive_dio ? 0.0 :\n\t\tS_VALUE(sip->dk_drive_dio, sic->dk_drive_dio, itv),\n\t\tsic->dk_drive_dblk < sip->dk_drive_dblk ? 0.0 :\n\t\tS_VALUE(sip->dk_drive_dblk, sic->dk_drive_dblk, itv));\n\n\txprintf(--tab, \"</io>\");\n}\n\n/*\n * **************************************************************************\n * Display RAM memory utilization in XML.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @dispall\tTRUE if all memory fields should be displayed.\n * @tab\t\tIndentation in XML output.\n ***************************************************************************\n */\nvoid xml_print_ram_memory_stats(struct stats_memory *smc, int dispall, int *tab)\n{\n\tunsigned long long nousedmem;\n\n\tnousedmem = smc->frmkb + smc->bufkb + smc->camkb + smc->slabkb;\n\tif (nousedmem > smc->tlmkb) {\n\t\tnousedmem = smc->tlmkb;\n\t}\n\n\txprintf(++(*tab), \"<memfree>%llu</memfree>\", smc->frmkb);\n\n\txprintf(*tab, \"<avail>%llu</avail>\", smc->availablekb);\n\n\txprintf(*tab, \"<memused>%llu</memused>\", smc->tlmkb - nousedmem);\n\n\txprintf(*tab, \"<memused-percent>%.2f</memused-percent>\",\n\t\tsmc->tlmkb ? SP_VALUE(nousedmem, smc->tlmkb, smc->tlmkb)\n\t\t\t   : 0.0);\n\n\txprintf(*tab, \"<buffers>%llu</buffers>\", smc->bufkb);\n\n\txprintf(*tab, \"<cached>%llu</cached>\", smc->camkb);\n\n\txprintf(*tab, \"<commit>%llu</commit>\", smc->comkb);\n\n\txprintf(*tab, \"<commit-percent>%.2f</commit-percent>\",\n\t\t(smc->tlmkb + smc->tlskb) ? SP_VALUE(0, smc->comkb, smc->tlmkb + smc->tlskb)\n\t\t\t\t\t  : 0.0);\n\n\txprintf(*tab, \"<active>%llu</active>\", smc->activekb);\n\n\txprintf(*tab, \"<inactive>%llu</inactive>\", smc->inactkb);\n\n\txprintf((*tab)--, \"<dirty>%llu</dirty>\", smc->dirtykb);\n\n\tif (dispall) {\n\t\txprintf(++(*tab), \"<anonpg>%llu</anonpg>\", smc->anonpgkb);\n\n\t\txprintf(*tab, \"<slab>%llu</slab>\", smc->slabkb);\n\n\t\txprintf(*tab, \"<kstack>%llu</kstack>\", smc->kstackkb);\n\n\t\txprintf(*tab, \"<pgtbl>%llu</pgtbl>\", smc->pgtblkb);\n\n\t\txprintf((*tab)--, \"<vmused>%llu</vmused>\", smc->vmusedkb);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display swap memory utilization in XML.\n *\n * IN:\n * @smc\t\tStructure with statistics.\n * @tab\t\tIndentation in XML output.\n ***************************************************************************\n */\nvoid xml_print_swap_memory_stats(struct stats_memory *smc, int *tab)\n{\n\txprintf(++(*tab), \"<swpfree>%llu</swpfree>\", smc->frskb);\n\n\txprintf(*tab, \"<swpused>%llu</swpused>\", smc->tlskb - smc->frskb);\n\n\txprintf(*tab, \"<swpused-percent>%.2f</swpused-percent>\",\n\t\tsmc->tlskb ? SP_VALUE(smc->frskb, smc->tlskb, smc->tlskb)\n\t\t\t   : 0.0);\n\n\txprintf(*tab, \"<swpcad>%llu</swpcad>\", smc->caskb);\n\n\txprintf((*tab)--, \"<swpcad-percent>%.2f</swpcad-percent>\",\n\t\t(smc->tlskb - smc->frskb) ? SP_VALUE(0, smc->caskb, smc->tlskb - smc->frskb)\n\t\t\t\t\t  : 0.0);\n}\n\n/*\n ***************************************************************************\n * Display memory statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_memory_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_memory\n\t\t*smc = (struct stats_memory *) a->buf[curr];\n\n\txprintf(tab, \"<memory unit=\\\"kB\\\">\");\n\n\tif (DISPLAY_MEMORY(a->opt_flags)) {\n\t\txml_print_ram_memory_stats(smc, DISPLAY_MEM_ALL(a->opt_flags), &tab);\n\t}\n\n\tif (DISPLAY_SWAP(a->opt_flags)) {\n\t\txml_print_swap_memory_stats(smc, &tab);\n\t}\n\n\txprintf(tab, \"</memory>\");\n}\n\n/*\n ***************************************************************************\n * Display kernel tables statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_ktables_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_ktables\n\t\t*skc = (struct stats_ktables *) a->buf[curr];\n\n\txprintf(tab, \"<kernel \"\n\t\t\"dentunusd=\\\"%llu\\\" \"\n\t\t\"file-nr=\\\"%llu\\\" \"\n\t\t\"inode-nr=\\\"%llu\\\" \"\n\t\t\"pty-nr=\\\"%llu\\\"/>\",\n\t\tskc->dentry_stat,\n\t\tskc->file_used,\n\t\tskc->inode_used,\n\t\tskc->pty_nr);\n}\n\n/*\n ***************************************************************************\n * Display queue and load statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_queue_stats(struct activity *a, int curr, int tab,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_queue\n\t\t*sqc = (struct stats_queue *) a->buf[curr];\n\n\txprintf(tab, \"<queue \"\n\t\t\"runq-sz=\\\"%llu\\\" \"\n\t\t\"plist-sz=\\\"%llu\\\" \"\n\t\t\"ldavg-1=\\\"%.2f\\\" \"\n\t\t\"ldavg-5=\\\"%.2f\\\" \"\n\t\t\"ldavg-15=\\\"%.2f\\\" \"\n\t\t\"blocked=\\\"%llu\\\"/>\",\n\t\tsqc->nr_running,\n\t\tsqc->nr_threads,\n\t\t(double) sqc->load_avg_1 / 100,\n\t\t(double) sqc->load_avg_5 / 100,\n\t\t(double) sqc->load_avg_15 / 100,\n\t\tsqc->procs_blocked);\n}\n\n/*\n ***************************************************************************\n * Display serial lines statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_serial_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_serial *ssc, *ssp;\n\n\txprintf(tab++, \"<serial per=\\\"second\\\">\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\tssc = (struct stats_serial *) ((char *) a->buf[curr]  + i * a->msize);\n\n\t\t\t/* Look for corresponding serial line in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tssp = (struct stats_serial *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (ssc->line == ssp->line) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\txprintf(tab, \"<tty line=\\\"%d\\\" \"\n\t\t\t\"rcvin=\\\"%.2f\\\" \"\n\t\t\t\"xmtin=\\\"%.2f\\\" \"\n\t\t\t\"framerr=\\\"%.2f\\\" \"\n\t\t\t\"prtyerr=\\\"%.2f\\\" \"\n\t\t\t\"brk=\\\"%.2f\\\" \"\n\t\t\t\"ovrun=\\\"%.2f\\\"/>\",\n\t\t\tssc->line,\n\t\t\tS_VALUE(ssp->rx,      ssc->rx,      itv),\n\t\t\tS_VALUE(ssp->tx,      ssc->tx,      itv),\n\t\t\tS_VALUE(ssp->frame,   ssc->frame,   itv),\n\t\t\tS_VALUE(ssp->parity,  ssc->parity,  itv),\n\t\t\tS_VALUE(ssp->brk,     ssc->brk,     itv),\n\t\t\tS_VALUE(ssp->overrun, ssc->overrun, itv));\n\t}\n\n\txprintf(--tab, \"</serial>\");\n}\n\n/*\n ***************************************************************************\n * Display disks statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_disk_stats(struct activity *a, int curr, int tab,\n\t\t\t\t     unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_disk *sdc,\t*sdp, sdpzero;\n\tstruct ext_disk_stats xds;\n\tchar *dev_name;\n\n\tmemset(&sdpzero, 0, STATS_DISK_SIZE);\n\n\txprintf(tab++, \"<disk per=\\\"second\\\">\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsdc = (struct stats_disk *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tj = check_disk_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsdp = &sdpzero;\n\t\t}\n\t\telse {\n\t\t\tsdp = (struct stats_disk *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\t/* Get device name */\n\t\tdev_name = get_device_name(sdc->major, sdc->minor, sdc->wwn, sdc->part_nr,\n\t\t\t\t\t   DISPLAY_PRETTY(flags), DISPLAY_PERSIST_NAME_S(flags),\n\t\t\t\t\t   USE_STABLE_ID(flags), NULL);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Compute extended statistics values */\n\t\tcompute_ext_disk_stats(sdc, sdp, itv, &xds);\n\n\t\txprintf(tab, \"<disk-device dev=\\\"%s\\\" \"\n\t\t\t\"tps=\\\"%.2f\\\" \"\n\t\t\t\"rd_sec=\\\"%.2f\\\" \"\n\t\t\t\"wr_sec=\\\"%.2f\\\" \"\n\t\t\t\"dc_sec=\\\"%.2f\\\" \"\n\t\t\t\"rkB=\\\"%.2f\\\" \"\n\t\t\t\"wkB=\\\"%.2f\\\" \"\n\t\t\t\"dkB=\\\"%.2f\\\" \"\n\t\t\t\"avgrq-sz=\\\"%.2f\\\" \"\n\t\t\t\"areq-sz=\\\"%.2f\\\" \"\n\t\t\t\"avgqu-sz=\\\"%.2f\\\" \"\n\t\t\t\"aqu-sz=\\\"%.2f\\\" \"\n\t\t\t\"await=\\\"%.2f\\\" \"\n\t\t\t\"util-percent=\\\"%.2f\\\"/>\",\n\t\t\t/* Confusion possible here between index and minor numbers */\n\t\t\tdev_name,\n\t\t\tS_VALUE(sdp->nr_ios, sdc->nr_ios, itv),\n\t\t\tS_VALUE(sdp->rd_sect, sdc->rd_sect, itv), /* Unit = sectors (for backward compatibility) */\n\t\t\tS_VALUE(sdp->wr_sect, sdc->wr_sect, itv),\n\t\t\tS_VALUE(sdp->dc_sect, sdc->dc_sect, itv),\n\t\t\tS_VALUE(sdp->rd_sect, sdc->rd_sect, itv) / 2,\n\t\t\tS_VALUE(sdp->wr_sect, sdc->wr_sect, itv) / 2,\n\t\t\tS_VALUE(sdp->dc_sect, sdc->dc_sect, itv) / 2,\n\t\t\t/* See iostat for explanations */\n\t\t\txds.arqsz,\t/* Unit = sectors (for backward compatibility) */\n\t\t\txds.arqsz / 2,\n\t\t\tS_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0,\t/* For backward compatibility */\n\t\t\tS_VALUE(sdp->rq_ticks, sdc->rq_ticks, itv) / 1000.0,\n\t\t\txds.await,\n\t\t\txds.util / 10.0);\n\t}\n\n\txprintf(--tab, \"</disk>\");\n}\n\n/*\n ***************************************************************************\n * Display network interfaces statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_dev_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_dev *sndc, *sndp, sndzero;\n\tdouble rxkb, txkb, ifutil;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\tmemset(&sndzero, 0, STATS_NET_DEV_SIZE);\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsndc = (struct stats_net_dev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, sndc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tj = check_net_dev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsndp = &sndzero;\n\t\t}\n\t\telse {\n\t\t\tsndp = (struct stats_net_dev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\trxkb = S_VALUE(sndp->rx_bytes, sndc->rx_bytes, itv);\n\t\ttxkb = S_VALUE(sndp->tx_bytes, sndc->tx_bytes, itv);\n\t\tifutil = compute_ifutil(sndc, rxkb, txkb);\n\n\t\txprintf(tab, \"<net-dev iface=\\\"%s\\\" \"\n\t\t\t\"rxpck=\\\"%.2f\\\" \"\n\t\t\t\"txpck=\\\"%.2f\\\" \"\n\t\t\t\"rxkB=\\\"%.2f\\\" \"\n\t\t\t\"txkB=\\\"%.2f\\\" \"\n\t\t\t\"rxcmp=\\\"%.2f\\\" \"\n\t\t\t\"txcmp=\\\"%.2f\\\" \"\n\t\t\t\"rxmcst=\\\"%.2f\\\" \"\n\t\t\t\"ifutil-percent=\\\"%.2f\\\"/>\",\n\t\t\tsndc->interface,\n\t\t\tS_VALUE(sndp->rx_packets,    sndc->rx_packets,    itv),\n\t\t\tS_VALUE(sndp->tx_packets,    sndc->tx_packets,    itv),\n\t\t\trxkb / 1024,\n\t\t\ttxkb / 1024,\n\t\t\tS_VALUE(sndp->rx_compressed, sndc->rx_compressed, itv),\n\t\t\tS_VALUE(sndp->tx_compressed, sndc->tx_compressed, itv),\n\t\t\tS_VALUE(sndp->multicast,     sndc->multicast,     itv),\n\t\t\tifutil);\n\t}\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network interfaces errors statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_edev_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i, j;\n\tstruct stats_net_edev *snedc, *snedp, snedzero;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\tmemset(&snedzero, 0, STATS_NET_EDEV_SIZE);\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tsnedc = (struct stats_net_edev *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, snedc->interface))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tj = check_net_edev_reg(a, curr, !curr, i);\n\t\tif (j < 0) {\n\t\t\t/* This is a newly registered interface. Previous stats are zero */\n\t\t\tsnedp = &snedzero;\n\t\t}\n\t\telse {\n\t\t\tsnedp = (struct stats_net_edev *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t}\n\n\t\txprintf(tab, \"<net-edev iface=\\\"%s\\\" \"\n\t\t\t\"rxerr=\\\"%.2f\\\" \"\n\t\t\t\"txerr=\\\"%.2f\\\" \"\n\t\t\t\"coll=\\\"%.2f\\\" \"\n\t\t\t\"rxdrop=\\\"%.2f\\\" \"\n\t\t\t\"txdrop=\\\"%.2f\\\" \"\n\t\t\t\"txcarr=\\\"%.2f\\\" \"\n\t\t\t\"rxfram=\\\"%.2f\\\" \"\n\t\t\t\"rxfifo=\\\"%.2f\\\" \"\n\t\t\t\"txfifo=\\\"%.2f\\\"/>\",\n\t\t\tsnedc->interface,\n\t\t\tS_VALUE(snedp->rx_errors,         snedc->rx_errors,         itv),\n\t\t\tS_VALUE(snedp->tx_errors,         snedc->tx_errors,         itv),\n\t\t\tS_VALUE(snedp->collisions,        snedc->collisions,        itv),\n\t\t\tS_VALUE(snedp->rx_dropped,        snedc->rx_dropped,        itv),\n\t\t\tS_VALUE(snedp->tx_dropped,        snedc->tx_dropped,        itv),\n\t\t\tS_VALUE(snedp->tx_carrier_errors, snedc->tx_carrier_errors, itv),\n\t\t\tS_VALUE(snedp->rx_frame_errors,   snedc->rx_frame_errors,   itv),\n\t\t\tS_VALUE(snedp->rx_fifo_errors,    snedc->rx_fifo_errors,    itv),\n\t\t\tS_VALUE(snedp->tx_fifo_errors,    snedc->tx_fifo_errors,    itv));\n\t}\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS client statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_nfs_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_net_nfs\n\t\t*snnc = (struct stats_net_nfs *) a->buf[curr],\n\t\t*snnp = (struct stats_net_nfs *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-nfs \"\n\t\t\"call=\\\"%.2f\\\" \"\n\t\t\"retrans=\\\"%.2f\\\" \"\n\t\t\"read=\\\"%.2f\\\" \"\n\t\t\"write=\\\"%.2f\\\" \"\n\t\t\"access=\\\"%.2f\\\" \"\n\t\t\"getatt=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snnp->nfs_rpccnt,     snnc->nfs_rpccnt,     itv),\n\t\tS_VALUE(snnp->nfs_rpcretrans, snnc->nfs_rpcretrans, itv),\n\t\tS_VALUE(snnp->nfs_readcnt,    snnc->nfs_readcnt,    itv),\n\t\tS_VALUE(snnp->nfs_writecnt,   snnc->nfs_writecnt,   itv),\n\t\tS_VALUE(snnp->nfs_accesscnt,  snnc->nfs_accesscnt,  itv),\n\t\tS_VALUE(snnp->nfs_getattcnt,  snnc->nfs_getattcnt,  itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display NFS server statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_nfsd_stats(struct activity *a, int curr, int tab,\n       \t\t\t\t   \t unsigned long long itv)\n{\n\tstruct stats_net_nfsd\n\t\t*snndc = (struct stats_net_nfsd *) a->buf[curr],\n\t\t*snndp = (struct stats_net_nfsd *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-nfsd \"\n\t\t\"scall=\\\"%.2f\\\" \"\n\t\t\"badcall=\\\"%.2f\\\" \"\n\t\t\"packet=\\\"%.2f\\\" \"\n\t\t\"udp=\\\"%.2f\\\" \"\n\t\t\"tcp=\\\"%.2f\\\" \"\n\t\t\"hit=\\\"%.2f\\\" \"\n\t\t\"miss=\\\"%.2f\\\" \"\n\t\t\"sread=\\\"%.2f\\\" \"\n\t\t\"swrite=\\\"%.2f\\\" \"\n\t\t\"saccess=\\\"%.2f\\\" \"\n\t\t\"sgetatt=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snndp->nfsd_rpccnt,    snndc->nfsd_rpccnt,    itv),\n\t\tS_VALUE(snndp->nfsd_rpcbad,    snndc->nfsd_rpcbad,    itv),\n\t\tS_VALUE(snndp->nfsd_netcnt,    snndc->nfsd_netcnt,    itv),\n\t\tS_VALUE(snndp->nfsd_netudpcnt, snndc->nfsd_netudpcnt, itv),\n\t\tS_VALUE(snndp->nfsd_nettcpcnt, snndc->nfsd_nettcpcnt, itv),\n\t\tS_VALUE(snndp->nfsd_rchits,    snndc->nfsd_rchits,    itv),\n\t\tS_VALUE(snndp->nfsd_rcmisses,  snndc->nfsd_rcmisses,  itv),\n\t\tS_VALUE(snndp->nfsd_readcnt,   snndc->nfsd_readcnt,   itv),\n\t\tS_VALUE(snndp->nfsd_writecnt,  snndc->nfsd_writecnt,  itv),\n\t\tS_VALUE(snndp->nfsd_accesscnt, snndc->nfsd_accesscnt, itv),\n\t\tS_VALUE(snndp->nfsd_getattcnt, snndc->nfsd_getattcnt, itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display network socket statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_sock_stats(struct activity *a, int curr, int tab,\n       \t\t\t\t   \t unsigned long long itv)\n{\n\tstruct stats_net_sock\n\t\t*snsc = (struct stats_net_sock *) a->buf[curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-sock \"\n\t\t\"totsck=\\\"%u\\\" \"\n\t\t\"tcpsck=\\\"%u\\\" \"\n\t\t\"udpsck=\\\"%u\\\" \"\n\t\t\"rawsck=\\\"%u\\\" \"\n\t\t\"ip-frag=\\\"%u\\\" \"\n\t\t\"tcp-tw=\\\"%u\\\"/>\",\n\t\tsnsc->sock_inuse,\n\t       \tsnsc->tcp_inuse,\n\t       \tsnsc->udp_inuse,\n       \t\tsnsc->raw_inuse,\n\t       \tsnsc->frag_inuse,\n\t       \tsnsc->tcp_tw);\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IP network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_ip_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_net_ip\n\t\t*snic = (struct stats_net_ip *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-ip \"\n\t\t\"irec=\\\"%.2f\\\" \"\n\t\t\"fwddgm=\\\"%.2f\\\" \"\n\t\t\"idel=\\\"%.2f\\\" \"\n\t\t\"orq=\\\"%.2f\\\" \"\n\t\t\"asmrq=\\\"%.2f\\\" \"\n\t\t\"asmok=\\\"%.2f\\\" \"\n\t\t\"fragok=\\\"%.2f\\\" \"\n\t\t\"fragcrt=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snip->InReceives,    snic->InReceives,    itv),\n\t\tS_VALUE(snip->ForwDatagrams, snic->ForwDatagrams, itv),\n\t\tS_VALUE(snip->InDelivers,    snic->InDelivers,    itv),\n\t\tS_VALUE(snip->OutRequests,   snic->OutRequests,   itv),\n\t\tS_VALUE(snip->ReasmReqds,    snic->ReasmReqds,    itv),\n\t\tS_VALUE(snip->ReasmOKs,      snic->ReasmOKs,      itv),\n\t\tS_VALUE(snip->FragOKs,       snic->FragOKs,       itv),\n\t\tS_VALUE(snip->FragCreates,   snic->FragCreates,   itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IP network errors statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_eip_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_net_eip\n\t\t*sneic = (struct stats_net_eip *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-eip \"\n\t\t\"ihdrerr=\\\"%.2f\\\" \"\n\t\t\"iadrerr=\\\"%.2f\\\" \"\n\t\t\"iukwnpr=\\\"%.2f\\\" \"\n\t\t\"idisc=\\\"%.2f\\\" \"\n\t\t\"odisc=\\\"%.2f\\\" \"\n\t\t\"onort=\\\"%.2f\\\" \"\n\t\t\"asmf=\\\"%.2f\\\" \"\n\t\t\"fragf=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(sneip->InHdrErrors,     sneic->InHdrErrors,     itv),\n\t\tS_VALUE(sneip->InAddrErrors,    sneic->InAddrErrors,    itv),\n\t\tS_VALUE(sneip->InUnknownProtos, sneic->InUnknownProtos, itv),\n\t\tS_VALUE(sneip->InDiscards,      sneic->InDiscards,      itv),\n\t\tS_VALUE(sneip->OutDiscards,     sneic->OutDiscards,     itv),\n\t\tS_VALUE(sneip->OutNoRoutes,     sneic->OutNoRoutes,     itv),\n\t\tS_VALUE(sneip->ReasmFails,      sneic->ReasmFails,      itv),\n\t\tS_VALUE(sneip->FragFails,       sneic->FragFails,       itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMP network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_icmp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_icmp\n\t\t*snic = (struct stats_net_icmp *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-icmp \"\n\t\t\"imsg=\\\"%.2f\\\" \"\n\t\t\"omsg=\\\"%.2f\\\" \"\n\t\t\"iech=\\\"%.2f\\\" \"\n\t\t\"iechr=\\\"%.2f\\\" \"\n\t\t\"oech=\\\"%.2f\\\" \"\n\t\t\"oechr=\\\"%.2f\\\" \"\n\t\t\"itm=\\\"%.2f\\\" \"\n\t\t\"itmr=\\\"%.2f\\\" \"\n\t\t\"otm=\\\"%.2f\\\" \"\n\t\t\"otmr=\\\"%.2f\\\" \"\n\t\t\"iadrmk=\\\"%.2f\\\" \"\n\t\t\"iadrmkr=\\\"%.2f\\\" \"\n\t\t\"oadrmk=\\\"%.2f\\\" \"\n\t\t\"oadrmkr=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snip->InMsgs,           snic->InMsgs,           itv),\n\t\tS_VALUE(snip->OutMsgs,          snic->OutMsgs,          itv),\n\t\tS_VALUE(snip->InEchos,          snic->InEchos,          itv),\n\t\tS_VALUE(snip->InEchoReps,       snic->InEchoReps,       itv),\n\t\tS_VALUE(snip->OutEchos,         snic->OutEchos,         itv),\n\t\tS_VALUE(snip->OutEchoReps,      snic->OutEchoReps,      itv),\n\t\tS_VALUE(snip->InTimestamps,     snic->InTimestamps,     itv),\n\t\tS_VALUE(snip->InTimestampReps,  snic->InTimestampReps,  itv),\n\t\tS_VALUE(snip->OutTimestamps,    snic->OutTimestamps,    itv),\n\t\tS_VALUE(snip->OutTimestampReps, snic->OutTimestampReps, itv),\n\t\tS_VALUE(snip->InAddrMasks,      snic->InAddrMasks,      itv),\n\t\tS_VALUE(snip->InAddrMaskReps,   snic->InAddrMaskReps,   itv),\n\t\tS_VALUE(snip->OutAddrMasks,     snic->OutAddrMasks,     itv),\n\t\tS_VALUE(snip->OutAddrMaskReps,  snic->OutAddrMaskReps,  itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMP error messages statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_eicmp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_eicmp\n\t\t*sneic = (struct stats_net_eicmp *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-eicmp \"\n\t\t\"ierr=\\\"%.2f\\\" \"\n\t\t\"oerr=\\\"%.2f\\\" \"\n\t\t\"idstunr=\\\"%.2f\\\" \"\n\t\t\"odstunr=\\\"%.2f\\\" \"\n\t\t\"itmex=\\\"%.2f\\\" \"\n\t\t\"otmex=\\\"%.2f\\\" \"\n\t\t\"iparmpb=\\\"%.2f\\\" \"\n\t\t\"oparmpb=\\\"%.2f\\\" \"\n\t\t\"isrcq=\\\"%.2f\\\" \"\n\t\t\"osrcq=\\\"%.2f\\\" \"\n\t\t\"iredir=\\\"%.2f\\\" \"\n\t\t\"oredir=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(sneip->InErrors,        sneic->InErrors,        itv),\n\t\tS_VALUE(sneip->OutErrors,       sneic->OutErrors,       itv),\n\t\tS_VALUE(sneip->InDestUnreachs,  sneic->InDestUnreachs,  itv),\n\t\tS_VALUE(sneip->OutDestUnreachs, sneic->OutDestUnreachs, itv),\n\t\tS_VALUE(sneip->InTimeExcds,     sneic->InTimeExcds,     itv),\n\t\tS_VALUE(sneip->OutTimeExcds,    sneic->OutTimeExcds,    itv),\n\t\tS_VALUE(sneip->InParmProbs,     sneic->InParmProbs,     itv),\n\t\tS_VALUE(sneip->OutParmProbs,    sneic->OutParmProbs,    itv),\n\t\tS_VALUE(sneip->InSrcQuenchs,    sneic->InSrcQuenchs,    itv),\n\t\tS_VALUE(sneip->OutSrcQuenchs,   sneic->OutSrcQuenchs,   itv),\n\t\tS_VALUE(sneip->InRedirects,     sneic->InRedirects,     itv),\n\t\tS_VALUE(sneip->OutRedirects,    sneic->OutRedirects,    itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display TCP network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_tcp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_net_tcp\n\t\t*sntc = (struct stats_net_tcp *) a->buf[curr],\n\t\t*sntp = (struct stats_net_tcp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-tcp \"\n\t\t\"active=\\\"%.2f\\\" \"\n\t\t\"passive=\\\"%.2f\\\" \"\n\t\t\"iseg=\\\"%.2f\\\" \"\n\t\t\"oseg=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(sntp->ActiveOpens,  sntc->ActiveOpens,  itv),\n\t\tS_VALUE(sntp->PassiveOpens, sntc->PassiveOpens, itv),\n\t\tS_VALUE(sntp->InSegs,       sntc->InSegs,       itv),\n\t\tS_VALUE(sntp->OutSegs,      sntc->OutSegs,      itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display TCP network errors statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_etcp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_etcp\n\t\t*snetc = (struct stats_net_etcp *) a->buf[curr],\n\t\t*snetp = (struct stats_net_etcp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-etcp \"\n\t\t\"atmptf=\\\"%.2f\\\" \"\n\t\t\"estres=\\\"%.2f\\\" \"\n\t\t\"retrseg=\\\"%.2f\\\" \"\n\t\t\"isegerr=\\\"%.2f\\\" \"\n\t\t\"orsts=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snetp->AttemptFails, snetc->AttemptFails,  itv),\n\t\tS_VALUE(snetp->EstabResets,  snetc->EstabResets,  itv),\n\t\tS_VALUE(snetp->RetransSegs,  snetc->RetransSegs,  itv),\n\t\tS_VALUE(snetp->InErrs,       snetc->InErrs,  itv),\n\t\tS_VALUE(snetp->OutRsts,      snetc->OutRsts,  itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display UDP network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_udp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_net_udp\n\t\t*snuc = (struct stats_net_udp *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-udp \"\n\t\t\"idgm=\\\"%.2f\\\" \"\n\t\t\"odgm=\\\"%.2f\\\" \"\n\t\t\"noport=\\\"%.2f\\\" \"\n\t\t\"idgmerr=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snup->InDatagrams,  snuc->InDatagrams,  itv),\n\t\tS_VALUE(snup->OutDatagrams, snuc->OutDatagrams, itv),\n\t\tS_VALUE(snup->NoPorts,      snuc->NoPorts,      itv),\n\t\tS_VALUE(snup->InErrors,     snuc->InErrors,     itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network socket statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_sock6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_sock6\n\t\t*snsc = (struct stats_net_sock6 *) a->buf[curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-sock6 \"\n\t\t\"tcp6sck=\\\"%u\\\" \"\n\t\t\"udp6sck=\\\"%u\\\" \"\n\t\t\"raw6sck=\\\"%u\\\" \"\n\t\t\"ip6-frag=\\\"%u\\\"/>\",\n\t\tsnsc->tcp6_inuse,\n\t\tsnsc->udp6_inuse,\n\t\tsnsc->raw6_inuse,\n\t\tsnsc->frag6_inuse);\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_ip6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tstruct stats_net_ip6\n\t\t*snic = (struct stats_net_ip6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_ip6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-ip6 \"\n\t\t\"irec6=\\\"%.2f\\\" \"\n\t\t\"fwddgm6=\\\"%.2f\\\" \"\n\t\t\"idel6=\\\"%.2f\\\" \"\n\t\t\"orq6=\\\"%.2f\\\" \"\n\t\t\"asmrq6=\\\"%.2f\\\" \"\n\t\t\"asmok6=\\\"%.2f\\\" \"\n\t\t\"imcpck6=\\\"%.2f\\\" \"\n\t\t\"omcpck6=\\\"%.2f\\\" \"\n\t\t\"fragok6=\\\"%.2f\\\" \"\n\t\t\"fragcr6=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snip->InReceives6,       snic->InReceives6,       itv),\n\t\tS_VALUE(snip->OutForwDatagrams6, snic->OutForwDatagrams6, itv),\n\t\tS_VALUE(snip->InDelivers6,       snic->InDelivers6,       itv),\n\t\tS_VALUE(snip->OutRequests6,      snic->OutRequests6,      itv),\n\t\tS_VALUE(snip->ReasmReqds6,       snic->ReasmReqds6,       itv),\n\t\tS_VALUE(snip->ReasmOKs6,         snic->ReasmOKs6,         itv),\n\t\tS_VALUE(snip->InMcastPkts6,      snic->InMcastPkts6,      itv),\n\t\tS_VALUE(snip->OutMcastPkts6,     snic->OutMcastPkts6,     itv),\n\t\tS_VALUE(snip->FragOKs6,          snic->FragOKs6,          itv),\n\t\tS_VALUE(snip->FragCreates6,      snic->FragCreates6,      itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display IPv6 network errors statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_eip6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_eip6\n\t\t*sneic = (struct stats_net_eip6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eip6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-eip6 \"\n\t\t\"ihdrer6=\\\"%.2f\\\" \"\n\t\t\"iadrer6=\\\"%.2f\\\" \"\n\t\t\"iukwnp6=\\\"%.2f\\\" \"\n\t\t\"i2big6=\\\"%.2f\\\" \"\n\t\t\"idisc6=\\\"%.2f\\\" \"\n\t\t\"odisc6=\\\"%.2f\\\" \"\n\t\t\"inort6=\\\"%.2f\\\" \"\n\t\t\"onort6=\\\"%.2f\\\" \"\n\t\t\"asmf6=\\\"%.2f\\\" \"\n\t\t\"fragf6=\\\"%.2f\\\" \"\n\t\t\"itrpck6=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(sneip->InHdrErrors6,     sneic->InHdrErrors6,     itv),\n\t\tS_VALUE(sneip->InAddrErrors6,    sneic->InAddrErrors6,    itv),\n\t\tS_VALUE(sneip->InUnknownProtos6, sneic->InUnknownProtos6, itv),\n\t\tS_VALUE(sneip->InTooBigErrors6,  sneic->InTooBigErrors6,  itv),\n\t\tS_VALUE(sneip->InDiscards6,      sneic->InDiscards6,      itv),\n\t\tS_VALUE(sneip->OutDiscards6,     sneic->OutDiscards6,     itv),\n\t\tS_VALUE(sneip->InNoRoutes6,      sneic->InNoRoutes6,      itv),\n\t\tS_VALUE(sneip->OutNoRoutes6,     sneic->OutNoRoutes6,     itv),\n\t\tS_VALUE(sneip->ReasmFails6,      sneic->ReasmFails6,      itv),\n\t\tS_VALUE(sneip->FragFails6,       sneic->FragFails6,       itv),\n\t\tS_VALUE(sneip->InTruncatedPkts6, sneic->InTruncatedPkts6, itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_icmp6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t  unsigned long long itv)\n{\n\tstruct stats_net_icmp6\n\t\t*snic = (struct stats_net_icmp6 *) a->buf[curr],\n\t\t*snip = (struct stats_net_icmp6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-icmp6 \"\n\t\t\"imsg6=\\\"%.2f\\\" \"\n\t\t\"omsg6=\\\"%.2f\\\" \"\n\t\t\"iech6=\\\"%.2f\\\" \"\n\t\t\"iechr6=\\\"%.2f\\\" \"\n\t\t\"oechr6=\\\"%.2f\\\" \"\n\t\t\"igmbq6=\\\"%.2f\\\" \"\n\t\t\"igmbr6=\\\"%.2f\\\" \"\n\t\t\"ogmbr6=\\\"%.2f\\\" \"\n\t\t\"igmbrd6=\\\"%.2f\\\" \"\n\t\t\"ogmbrd6=\\\"%.2f\\\" \"\n\t\t\"irtsol6=\\\"%.2f\\\" \"\n\t\t\"ortsol6=\\\"%.2f\\\" \"\n\t\t\"irtad6=\\\"%.2f\\\" \"\n\t\t\"inbsol6=\\\"%.2f\\\" \"\n\t\t\"onbsol6=\\\"%.2f\\\" \"\n\t\t\"inbad6=\\\"%.2f\\\" \"\n\t\t\"onbad6=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snip->InMsgs6,                    snic->InMsgs6,                    itv),\n\t\tS_VALUE(snip->OutMsgs6,                   snic->OutMsgs6,                   itv),\n\t\tS_VALUE(snip->InEchos6,                   snic->InEchos6,                   itv),\n\t\tS_VALUE(snip->InEchoReplies6,             snic->InEchoReplies6,             itv),\n\t\tS_VALUE(snip->OutEchoReplies6,            snic->OutEchoReplies6,            itv),\n\t\tS_VALUE(snip->InGroupMembQueries6,        snic->InGroupMembQueries6,        itv),\n\t\tS_VALUE(snip->InGroupMembResponses6,      snic->InGroupMembResponses6,      itv),\n\t\tS_VALUE(snip->OutGroupMembResponses6,     snic->OutGroupMembResponses6,     itv),\n\t\tS_VALUE(snip->InGroupMembReductions6,     snic->InGroupMembReductions6,     itv),\n\t\tS_VALUE(snip->OutGroupMembReductions6,    snic->OutGroupMembReductions6,    itv),\n\t\tS_VALUE(snip->InRouterSolicits6,          snic->InRouterSolicits6,          itv),\n\t\tS_VALUE(snip->OutRouterSolicits6,         snic->OutRouterSolicits6,         itv),\n\t\tS_VALUE(snip->InRouterAdvertisements6,    snic->InRouterAdvertisements6,    itv),\n\t\tS_VALUE(snip->InNeighborSolicits6,        snic->InNeighborSolicits6,        itv),\n\t\tS_VALUE(snip->OutNeighborSolicits6,       snic->OutNeighborSolicits6,       itv),\n\t\tS_VALUE(snip->InNeighborAdvertisements6,  snic->InNeighborAdvertisements6,  itv),\n\t\tS_VALUE(snip->OutNeighborAdvertisements6, snic->OutNeighborAdvertisements6, itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display ICMPv6 error messages statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_eicmp6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t   unsigned long long itv)\n{\n\tstruct stats_net_eicmp6\n\t\t*sneic = (struct stats_net_eicmp6 *) a->buf[curr],\n\t\t*sneip = (struct stats_net_eicmp6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-eicmp6 \"\n\t\t\"ierr6=\\\"%.2f\\\" \"\n\t\t\"idtunr6=\\\"%.2f\\\" \"\n\t\t\"odtunr6=\\\"%.2f\\\" \"\n\t\t\"itmex6=\\\"%.2f\\\" \"\n\t\t\"otmex6=\\\"%.2f\\\" \"\n\t\t\"iprmpb6=\\\"%.2f\\\" \"\n\t\t\"oprmpb6=\\\"%.2f\\\" \"\n\t\t\"iredir6=\\\"%.2f\\\" \"\n\t\t\"oredir6=\\\"%.2f\\\" \"\n\t\t\"ipck2b6=\\\"%.2f\\\" \"\n\t\t\"opck2b6=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(sneip->InErrors6,        sneic->InErrors6,        itv),\n\t\tS_VALUE(sneip->InDestUnreachs6,  sneic->InDestUnreachs6,  itv),\n\t\tS_VALUE(sneip->OutDestUnreachs6, sneic->OutDestUnreachs6, itv),\n\t\tS_VALUE(sneip->InTimeExcds6,     sneic->InTimeExcds6,     itv),\n\t\tS_VALUE(sneip->OutTimeExcds6,    sneic->OutTimeExcds6,    itv),\n\t\tS_VALUE(sneip->InParmProblems6,  sneic->InParmProblems6,  itv),\n\t\tS_VALUE(sneip->OutParmProblems6, sneic->OutParmProblems6, itv),\n\t\tS_VALUE(sneip->InRedirects6,     sneic->InRedirects6,     itv),\n\t\tS_VALUE(sneip->OutRedirects6,    sneic->OutRedirects6,    itv),\n\t\tS_VALUE(sneip->InPktTooBigs6,    sneic->InPktTooBigs6,    itv),\n\t\tS_VALUE(sneip->OutPktTooBigs6,   sneic->OutPktTooBigs6,   itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display UDPv6 network statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_net_udp6_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tstruct stats_net_udp6\n\t\t*snuc = (struct stats_net_udp6 *) a->buf[curr],\n\t\t*snup = (struct stats_net_udp6 *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<net-udp6 \"\n\t\t\"idgm6=\\\"%.2f\\\" \"\n\t\t\"odgm6=\\\"%.2f\\\" \"\n\t\t\"noport6=\\\"%.2f\\\" \"\n\t\t\"idgmer6=\\\"%.2f\\\"/>\",\n\t\tS_VALUE(snup->InDatagrams6,  snuc->InDatagrams6,  itv),\n\t\tS_VALUE(snup->OutDatagrams6, snuc->OutDatagrams6, itv),\n\t\tS_VALUE(snup->NoPorts6,      snuc->NoPorts6,      itv),\n\t\tS_VALUE(snup->InErrors6,     snuc->InErrors6,     itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display CPU frequency statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_cpufreq_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t    unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_cpufreq *spc;\n\tchar cpuno[16];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<cpu-frequency unit=\\\"MHz\\\">\");\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\t/* Yes: Display it */\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\t\t}\n\n\t\txprintf(tab, \"<cpufreq number=\\\"%s\\\" \"\n\t\t\t\"frequency=\\\"%.2f\\\"/>\",\n\t\t\tcpuno,\n\t\t\t((double) spc->cpufreq) / 100);\n\t}\n\n\txprintf(--tab, \"</cpu-frequency>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display fan statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_fan_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_fan *spc;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<fan-speed unit=\\\"rpm\\\">\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_fan *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\txprintf(tab, \"<fan number=\\\"%d\\\" rpm=\\\"%llu\\\" drpm=\\\"%llu\\\" device=\\\"%s\\\"/>\",\n\t\t\ti + 1,\n\t\t\t(unsigned long long) spc->rpm,\n\t\t\t(unsigned long long) (spc->rpm - spc->rpm_min),\n\t\t\tspc->device);\n\t}\n\n\txprintf(--tab, \"</fan-speed>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display temperature statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_temp_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_temp *spc;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<temperature unit=\\\"degree Celsius\\\">\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_temp *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\txprintf(tab, \"<temp number=\\\"%d\\\" degC=\\\"%.2f\\\" percent-temp=\\\"%.2f\\\" device=\\\"%s\\\"/>\",\n\t\t\ti + 1,\n\t\t\tspc->temp,\n\t\t\t(spc->temp_max - spc->temp_min) ?\n\t\t\t(spc->temp - spc->temp_min) / (spc->temp_max - spc->temp_min) * 100 :\n\t\t\t0.0,\n\t\t\tspc->device);\n\t}\n\n\txprintf(--tab, \"</temperature>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display voltage inputs statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_in_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_in *spc;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<voltage-input unit=\\\"V\\\">\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tspc = (struct stats_pwr_in *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\txprintf(tab, \"<in number=\\\"%d\\\" inV=\\\"%.2f\\\" percent-in=\\\"%.2f\\\" device=\\\"%s\\\"/>\",\n\t\t\ti,\n\t\t\tspc->in,\n\t\t\t(spc->in_max - spc->in_min) ?\n\t\t\t(spc->in - spc->in_min) / (spc->in_max - spc->in_min) * 100 :\n\t\t\t0.0,\n\t\t\tspc->device);\n\t}\n\n\txprintf(--tab, \"</voltage-input>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display huge pages statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_huge_stats(struct activity *a, int curr, int tab,\n\t\t\t\t     unsigned long long itv)\n{\n\tstruct stats_huge\n\t\t*smc = (struct stats_huge *) a->buf[curr];\n\n\txprintf(tab, \"<hugepages unit=\\\"kB\\\">\");\n\n\txprintf(++tab, \"<hugfree>%llu</hugfree>\",\n\t\tsmc->frhkb);\n\n\txprintf(tab, \"<hugused>%llu</hugused>\",\n\t\tsmc->tlhkb - smc->frhkb);\n\n\txprintf(tab, \"<hugused-percent>%.2f</hugused-percent>\",\n\t\tsmc->tlhkb ?\n\t\tSP_VALUE(smc->frhkb, smc->tlhkb, smc->tlhkb) :\n\t\t0.0);\n\n\txprintf(tab, \"<hugrsvd>%llu</hugrsvd>\",\n\t\tsmc->rsvdhkb);\n\n\txprintf(tab--, \"<hugsurp>%llu</hugsurp>\",\n\t\tsmc->surphkb);\n\n\txprintf(tab, \"</hugepages>\");\n}\n\n/*\n ***************************************************************************\n * Display weighted CPU frequency statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_wghfreq_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t    unsigned long long itv)\n{\n\tint i, k;\n\tstruct stats_pwr_wghfreq *spc, *spp, *spc_k, *spp_k;\n\tunsigned long long tis, tisfreq;\n\tchar cpuno[16];\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<cpu-weighted-frequency unit=\\\"MHz\\\">\");\n\n\tfor (i = 0; (i < a->nr[curr]) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\tspc = (struct stats_pwr_wghfreq *) ((char *) a->buf[curr]  + i * a->msize * a->nr2);\n\t\tspp = (struct stats_pwr_wghfreq *) ((char *) a->buf[!curr] + i * a->msize * a->nr2);\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\ttisfreq = 0;\n\t\ttis = 0;\n\n\t\tfor (k = 0; k < a->nr2; k++) {\n\n\t\t\tspc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * a->msize);\n\t\t\tif (!spc_k->freq)\n\t\t\t\tbreak;\n\t\t\tspp_k = (struct stats_pwr_wghfreq *) ((char *) spp + k * a->msize);\n\n\t\t\ttisfreq += (spc_k->freq / 1000) *\n\t\t\t           (spc_k->time_in_state - spp_k->time_in_state);\n\t\t\ttis     += (spc_k->time_in_state - spp_k->time_in_state);\n\t\t}\n\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\t\t}\n\n\t\txprintf(tab, \"<cpuwfreq number=\\\"%s\\\" \"\n\t\t\t\"weighted-frequency=\\\"%.2f\\\"/>\",\n\t\t\tcpuno,\n\t\t\ttis ? ((double) tisfreq) / tis : 0.0);\n\t}\n\n\txprintf(--tab, \"</cpu-weighted-frequency>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display USB devices statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_usb_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_usb *suc;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<usb-devices>\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsuc = (struct stats_pwr_usb *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\txprintf(tab, \"<usb bus_number=\\\"%d\\\" idvendor=\\\"%x\\\" idprod=\\\"%x\\\" \"\n\t\t\t     \"maxpower=\\\"%u\\\" manufact=\\\"%s\\\" product=\\\"%s\\\"/>\",\n\t\t\tsuc->bus_nr,\n\t\t\tsuc->vendor_id,\n\t\t\tsuc->product_id,\n\t\t\tsuc->bmaxpower << 1,\n\t\t\tsuc->manufacturer,\n\t\t\tsuc->product);\n\t}\n\n\txprintf(--tab, \"</usb-devices>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display filesystems statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_filesystem_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\t   unsigned long long itv)\n{\n\tint i;\n\tstruct stats_filesystem *sfc;\n\tchar *dev_name;\n\n\txprintf(tab++, \"<filesystems>\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\t\tsfc = (struct stats_filesystem *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\t/* Get name to display (persistent or standard fs name, or mount point) */\n\t\tdev_name = get_fs_name_to_display(a, flags, sfc);\n\n\t\tif (a->item_list != NULL) {\n\t\t\t/* A list of devices has been entered on the command line */\n\t\t\tif (!search_list_item(a->item_list, dev_name))\n\t\t\t\t/* Device not found */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\txprintf(tab, \"<filesystem %s=\\\"%s\\\" \"\n\t\t\t\"MBfsfree=\\\"%.0f\\\" \"\n\t\t\t\"MBfsused=\\\"%.0f\\\" \"\n\t\t\t\"fsused-percent=\\\"%.2f\\\" \"\n\t\t\t\"ufsused-percent=\\\"%.2f\\\" \"\n\t\t\t\"Ifree=\\\"%llu\\\" \"\n\t\t\t\"Iused=\\\"%llu\\\" \"\n\t\t\t\"Iused-percent=\\\"%.2f\\\"/>\",\n\t\t\tDISPLAY_MOUNT(a->opt_flags) ? \"mountp\" : \"fsname\",\n\t\t\tdev_name,\n\t\t\t(double) sfc->f_bfree / 1024 / 1024,\n\t\t\t(double) (sfc->f_blocks - sfc->f_bfree) / 1024 / 1024,\n\t\t\t/* f_blocks is not zero. But test it anyway ;-) */\n\t\t\tsfc->f_blocks ? SP_VALUE(sfc->f_bfree, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t      : 0.0,\n\t\t\tsfc->f_blocks ? SP_VALUE(sfc->f_bavail, sfc->f_blocks, sfc->f_blocks)\n\t\t\t\t      : 0.0,\n\t\t\tsfc->f_ffree,\n\t\t\tsfc->f_files - sfc->f_ffree,\n\t\t\tsfc->f_files ? SP_VALUE(sfc->f_ffree, sfc->f_files, sfc->f_files)\n\t\t\t\t     : 0.0);\n\t}\n\n\txprintf(--tab, \"</filesystems>\");\n}\n\n/*\n ***************************************************************************\n * Display Fibre Channel HBA statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_fchost_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tint i, j, j0, found;\n\tstruct stats_fchost *sfcc, *sfcp, sfczero;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\tmemset(&sfczero, 0, sizeof(struct stats_fchost));\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tfound = FALSE;\n\t\tsfcc = (struct stats_fchost *) ((char *) a->buf[curr] + i * a->msize);\n\n\t\tif (a->nr[!curr] > 0) {\n\t\t\t/* Look for corresponding structure in previous iteration */\n\t\t\tj = i;\n\n\t\t\tif (j >= a->nr[!curr]) {\n\t\t\t\tj = a->nr[!curr] - 1;\n\t\t\t}\n\n\t\t\tj0 = j;\n\n\t\t\tdo {\n\t\t\t\tsfcp = (struct stats_fchost *) ((char *) a->buf[!curr] + j * a->msize);\n\t\t\t\tif (!strcmp(sfcc->fchost_name, sfcp->fchost_name)) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++j >= a->nr[!curr]) {\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j != j0);\n\t\t}\n\n\t\tif (!found) {\n\t\t\t/* This is a newly registered host */\n\t\t\tsfcp = &sfczero;\n\t\t}\n\n\t\txprintf(tab, \"<fchost name=\\\"%s\\\" \"\n\t\t\t\"fch_rxf=\\\"%.2f\\\" \"\n\t\t\t\"fch_txf=\\\"%.2f\\\" \"\n\t\t\t\"fch_rxw=\\\"%.2f\\\" \"\n\t\t\t\"fch_txw=\\\"%.2f\\\"/>\",\n\t\t\tsfcc->fchost_name,\n\t\t\tS_VALUE(sfcp->f_rxframes, sfcc->f_rxframes, itv),\n\t\t\tS_VALUE(sfcp->f_txframes, sfcc->f_txframes, itv),\n\t\t\tS_VALUE(sfcp->f_rxwords,  sfcc->f_rxwords,  itv),\n\t\t\tS_VALUE(sfcp->f_txwords,  sfcc->f_txwords,  itv));\n\t}\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display softnet statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_softnet_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i;\n\tstruct stats_softnet *ssnc, *ssnp;\n\tchar cpuno[16];\n\tunsigned char offline_cpu_bitmap[BITMAP_SIZE(NR_CPUS)] = {0};\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_network(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\t/* @nr[curr] cannot normally be greater than @nr_ini */\n\tif (a->nr[curr] > a->nr_ini) {\n\t\ta->nr_ini = a->nr[curr];\n\t}\n\n\t/* Compute statistics for CPU \"all\" */\n\tget_global_soft_statistics(a, !curr, curr, flags, offline_cpu_bitmap);\n\n\tfor (i = 0; (i < a->nr_ini) && (i < a->bitmap->b_size + 1); i++) {\n\n\t\t/* Should current CPU (including CPU \"all\") be displayed? */\n\t\tif (!IS_CPU_SELECTED(a->bitmap->b_array, i) ||\n\t\t    IS_CPU_OFFLINE(offline_cpu_bitmap, i))\n\t\t\t/* No */\n\t\t\tcontinue;\n\n\t\tssnc = (struct stats_softnet *) ((char *) a->buf[curr]  + i * a->msize);\n\t\tssnp = (struct stats_softnet *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t/* Yes: Display it */\n\t\tif (!i) {\n\t\t\t/* This is CPU \"all\" */\n\t\t\tstrcpy(cpuno, K_LOWERALL);\n\t\t}\n\t\telse {\n\t\t\tsprintf(cpuno, \"%d\", i - 1);\n\t\t}\n\n\t\txprintf(tab, \"<softnet cpu=\\\"%s\\\" \"\n\t\t\t\"total=\\\"%.2f\\\" \"\n\t\t\t\"dropd=\\\"%.2f\\\" \"\n\t\t\t\"squeezd=\\\"%.2f\\\" \"\n\t\t\t\"rx_rps=\\\"%.2f\\\" \"\n\t\t\t\"flw_lim=\\\"%.2f\\\" \"\n\t\t\t\"blg_len=\\\"%u\\\"/>\",\n\t\t\t cpuno,\n\t\t\t S_VALUE(ssnp->processed,    ssnc->processed,    itv),\n\t\t\t S_VALUE(ssnp->dropped,      ssnc->dropped,      itv),\n\t\t\t S_VALUE(ssnp->time_squeeze, ssnc->time_squeeze, itv),\n\t\t\t S_VALUE(ssnp->received_rps, ssnc->received_rps, itv),\n\t\t\t S_VALUE(ssnp->flow_limit,   ssnc->flow_limit,   itv),\n\t\t\t ssnc->backlog_len);\n\t}\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_network(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall CPU statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_psicpu_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_psi_cpu\n\t\t*psic = (struct stats_psi_cpu *) a->buf[curr],\n\t\t*psip = (struct stats_psi_cpu *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options))\n\t\tgoto close_xml_markup;\n\n\txml_markup_psi(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<psi-cpu \"\n\t\t\"some_avg10=\\\"%.2f\\\" \"\n\t\t\"some_avg60=\\\"%.2f\\\" \"\n\t\t\"some_avg300=\\\"%.2f\\\" \"\n\t\t\"some_avg=\\\"%.2f\\\"/>\",\n\t\t(double) psic->some_acpu_10  / 100,\n\t\t(double) psic->some_acpu_60  / 100,\n\t\t(double) psic->some_acpu_300 / 100,\n\t\t((double) psic->some_cpu_total - psip->some_cpu_total) / (100 * itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_psi(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall I/O statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_psiio_stats(struct activity *a, int curr, int tab,\n\t\t\t\t      unsigned long long itv)\n{\n\tstruct stats_psi_io\n\t\t*psic = (struct stats_psi_io *) a->buf[curr],\n\t\t*psip = (struct stats_psi_io *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options))\n\t\tgoto close_xml_markup;\n\n\txml_markup_psi(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<psi-io \"\n\t\t\"some_avg10=\\\"%.2f\\\" \"\n\t\t\"some_avg60=\\\"%.2f\\\" \"\n\t\t\"some_avg300=\\\"%.2f\\\" \"\n\t\t\"some_avg=\\\"%.2f\\\" \"\n\t\t\"full_avg10=\\\"%.2f\\\" \"\n\t\t\"full_avg60=\\\"%.2f\\\" \"\n\t\t\"full_avg300=\\\"%.2f\\\" \"\n\t\t\"full_avg=\\\"%.2f\\\"/>\",\n\t\t(double) psic->some_aio_10  / 100,\n\t\t(double) psic->some_aio_60  / 100,\n\t\t(double) psic->some_aio_300 / 100,\n\t\t((double) psic->some_io_total - psip->some_io_total) / (100 * itv),\n\t\t(double) psic->full_aio_10  / 100,\n\t\t(double) psic->full_aio_60  / 100,\n\t\t(double) psic->full_aio_300 / 100,\n\t\t((double) psic->full_io_total - psip->full_io_total) / (100 * itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_psi(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n ***************************************************************************\n * Display pressure-stall memory statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_psimem_stats(struct activity *a, int curr, int tab,\n\t\t\t\t       unsigned long long itv)\n{\n\tstruct stats_psi_mem\n\t\t*psic = (struct stats_psi_mem *) a->buf[curr],\n\t\t*psip = (struct stats_psi_mem *) a->buf[!curr];\n\n\tif (!IS_SELECTED(a->options))\n\t\tgoto close_xml_markup;\n\n\txml_markup_psi(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab, \"<psi-mem \"\n\t\t\"some_avg10=\\\"%.2f\\\" \"\n\t\t\"some_avg60=\\\"%.2f\\\" \"\n\t\t\"some_avg300=\\\"%.2f\\\" \"\n\t\t\"some_avg=\\\"%.2f\\\" \"\n\t\t\"full_avg10=\\\"%.2f\\\" \"\n\t\t\"full_avg60=\\\"%.2f\\\" \"\n\t\t\"full_avg300=\\\"%.2f\\\" \"\n\t\t\"full_avg=\\\"%.2f\\\"/>\",\n\t\t(double) psic->some_amem_10  / 100,\n\t\t(double) psic->some_amem_60  / 100,\n\t\t(double) psic->some_amem_300 / 100,\n\t\t((double) psic->some_mem_total - psip->some_mem_total) / (100 * itv),\n\t\t(double) psic->full_amem_10  / 100,\n\t\t(double) psic->full_amem_60  / 100,\n\t\t(double) psic->full_amem_300 / 100,\n\t\t((double) psic->full_mem_total - psip->full_mem_total) / (100 * itv));\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_psi(tab, CLOSE_XML_MARKUP);\n\t}\n}\n\n/*\n * **************************************************************************\n * Display battery statistics in XML.\n *\n * IN:\n * @a\t\tActivity structure with statistics.\n * @curr\tIndex in array for current sample statistics.\n * @tab\t\tIndentation in XML output.\n * @itv\t\tInterval of time in 1/100th of a second.\n ***************************************************************************\n */\n__print_funct_t xml_print_pwr_bat_stats(struct activity *a, int curr, int tab,\n\t\t\t\t\tunsigned long long itv)\n{\n\tint i;\n\tstruct stats_pwr_bat *spbc, *spbp;\n\n\tif (!IS_SELECTED(a->options) || (a->nr[curr] <= 0))\n\t\tgoto close_xml_markup;\n\n\txml_markup_power_management(tab, OPEN_XML_MARKUP);\n\ttab++;\n\n\txprintf(tab++, \"<battery unit=\\\"minute\\\">\");\n\n\tfor (i = 0; i < a->nr[curr]; i++) {\n\n\t\tspbc = (struct stats_pwr_bat *) ((char *) a->buf[curr] + i * a->msize);\n\t\tspbp = (struct stats_pwr_bat *) ((char *) a->buf[!curr] + i * a->msize);\n\n\t\t/* Battery status code should not be greater than or equal to BAT_STS_NR */\n\t\tif (spbc->status >= BAT_STS_NR) {\n\t\t\tspbc->status = 0;\n\t\t}\n\t\txprintf(tab, \"<bat number=\\\"%d\\\" \"\n\t\t\t     \"percent-capacity=\\\"%u\\\" \"\n\t\t\t     \"variation=\\\"%.2f\\\" \"\n\t\t\t     \"status=\\\"%s\\\"/>\",\n\t\t\tspbc->bat_id,\n\t\t\t(unsigned int) spbc->capacity,\n\t\t\t(double) (spbc->capacity - spbp->capacity) * 6000 / itv,\n\t\t\tbat_status[(unsigned int) spbc->status]);\n\t}\n\n\txprintf(--tab, \"</battery>\");\n\ttab--;\n\nclose_xml_markup:\n\tif (CLOSE_MARKUP(a->options)) {\n\t\txml_markup_power_management(tab, CLOSE_XML_MARKUP);\n\t}\n}\n"
        },
        {
          "name": "xml_stats.h",
          "type": "blob",
          "size": 4.3564453125,
          "content": "/*\n * xml_stats.h: Include file used to display system statistics in XML.\n * (C) 1999-2024 by Sebastien Godard (sysstat <at> orange.fr)\n */\n\n#ifndef _XML_STATS_H\n#define _XML_STATS_H\n\n#include \"common.h\"\n\n/*\n ***************************************************************************\n * Prototypes for functions used to display system statistics in XML.\n ***************************************************************************\n */\n\n/* Functions used to display statistics in XML */\n__print_funct_t xml_print_cpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pcsw_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_irq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_swap_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_paging_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_io_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_memory_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_ktables_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_queue_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_serial_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_disk_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_dev_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_edev_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_nfs_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_nfsd_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_sock_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_ip_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_eip_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_icmp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_eicmp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_tcp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_etcp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_udp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_sock6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_ip6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_eip6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_icmp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_eicmp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_net_udp6_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_cpufreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_fan_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_temp_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_in_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_huge_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_wghfreq_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_usb_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_filesystem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_fchost_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_softnet_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_psicpu_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_psiio_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_psimem_stats\n\t(struct activity *, int, int, unsigned long long);\n__print_funct_t xml_print_pwr_bat_stats\n\t(struct activity *, int, int, unsigned long long);\n\n#endif /* _XML_STATS_H */\n"
        }
      ]
    }
  ]
}