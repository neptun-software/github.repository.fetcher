{
  "metadata": {
    "timestamp": 1736709688739,
    "page": 57,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nanopb/nanopb",
      "stars": 4442,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".bazelignore",
          "type": "blob",
          "size": 0.0283203125,
          "content": "tests/bazel_workspace_support"
        },
        {
          "name": ".bazelversion",
          "type": "blob",
          "size": 0.005859375,
          "content": "7.4.1\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1435546875,
          "content": "# Auto-generated files that don't need human review.\nMODULE.bazel.lock linguist-generated=true\nextra/requirements_lock.txt linguist-generated=true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5458984375,
          "content": "*.gcda\n*.gcno\n*.gcov\n*.o\n*.pb.c\n*.pb.h\n*.pb\n*.pyc\n*_pb2.py\n*~\n*.tar.gz\n*.swp\n.sconsign.dblite\nconfig.log\n.sconf_temp\ntests/build\njulkaisu.txt\ndist\ndocs/*.html\ndocs/generator_flow.png\nexamples/simple/simple\nexamples/network_server/client\nexamples/network_server/server\nexamples/using_double_on_avr/decode_double\nexamples/using_double_on_avr/encode_double\nexamples/using_double_on_avr/test_conversions\nexamples/using_union_messages/decode\nexamples/using_union_messages/encode\ngenerator/nanopb_pb2.pyc\n!generator-bin/**/*\nbazel-*\nextra/poetry/build\nbuild/\n.idea\n"
        },
        {
          "name": "AUTHORS.txt",
          "type": "blob",
          "size": 5.6650390625,
          "content": "Petteri Aimonen <jpa@npb.mail.kapsi.fi>\nMichael Poole <mdpoole@troilus.org>\nDaniel Kan <extremeblue99@gmail.com>\nStan Hu <stanhu@aclimalabs.com>\nDavid Hotham <david.hotham@blueyonder.co.uk>\nSteffen Siering <steffen siering gmail com>\nJens Steinhauser <jens.steinhauser@gmail.com>\nPavel Ilin <ilin.pa@gmail.com>\nKent Ryhorchuk <kryhorchuk@xeralux.com>\nMartin Donath <scifish@gmail.com>\nOliver Lee <oliverzlee@gmail.com>\nMichael Haberler <git@mah.priv.at>\nNicolas Colomer <ncolomer@viadeoteam.com>\nIvan Kravets <me@ikravets.com>\nKyle Manna <kyle@kylemanna.com>\nBenjamin Kamath <ben.kamath@synapse.com>\nAndrew Ruder <andrew.ruder@elecsyscorp.com>\nKenshi Kawaguchi <kenshi@recurse.ca>\nisotes <isotes@gmail.com>\nMaxim Khitrov <max@mxcrypt.com>\nYaniv Mordekhay <yanivmo@users.noreply.github.com>\nMing Zhao <mzhao@luminatewireless.com>\nGoogle, Inc.\nTom Roeder <tmroeder@google.com>\nPiotr Sikora <piotrsikora@google.com>\nBernhard Krämer <bdkrae@gmail.com>\nKonstantin Podsvirov <konstantin@podsvirov.pro>\nWilliam A. Kennington III <wak@google.com>\nGuillaume Lager <g.lager@innoseis.com>\nTobias Haegermarck <tobias.haegermarck@gmail.com>\nJustin DeMartino <jdemarti@gmail.com>\nConstantine Grantcharov <cgrantcharov@trustpointinnovation.com>\nNick Ewalt <nicholasewalt@google.com>\nHarald Fernengel <harryf@gmx.com>\nAlice Wang <aw@squareup.com>\nKevin Fitch <kfitch42@gmail.com>\nKamal Marhubi <kamal@marhubi.com>\nElco Jacobs <elco@brewpi.com>\nSébastien Morin <sebastien.morin@primerogames.com>\nDave Flogeras <dflogeras2@gmail.com>\nEdward Z. Yang <ezyang@mit.edu>\nRobbie Shade <rjshade@google.com>\nAndrew Ballinger <andrewballinger@stratisopt.com>\nHamina, Juha-Pekka <Juha-Pekka.Hamina@nordicsemi.no>\nJason Bishop <jason.bishop@bigassfans.com>\nmatejcik <ja@matejcik.cz>\nTobias Müller <Tobias_Mueller@twam.info>\nJari Vetoniemi <mailroxas@gmail.com>\nGabriel Staples <ercaguy@gmail.com>\nAmarnath <amarnath.h.96@gmail.com>\nMichal Rostecki <mrostecki@suse.de>\nPei Wang <wangpei10@baidu.com>\nNoah Pendleton <2538614+noahp@users.noreply.github.com>\nPavol Rusnak <pavol@rusnak.io>\nder-imp <falkjan@msn.com>\nMark Hill <markleehill@gmail.com>\nTorfinn Berset <torfinn@bloom-life.com>\nBo Langgaard Lind <bo.langgaard.lind@gmail.com>\nStephane Dorre <stephane.dorre@cobi.bike>\nPhillip Cao <Phillip.Cao@fphcare.co.nz>\nMelvin Wang <melvin.mc.wang@gmail.com>\nJoshua Salzedo <thHunkn0WNd@gmail.com>\nAdam Klama <klama.adam@gmail.com>\nAnton Matosov <amatosov@roblox.com>\nberni155 <bdkrae@gmail.com>\nDavid Lin <dtwlin@google.com>\ndevjoa <devjoa@gmail.com>\nEvan Fisher <schleb@gmail.com>\nFay <fay2003hiend@gmail.com>\nFlorian Märkl <info@florianmaerkl.de>\nFranck <franck.sehedic@ledger.fr>\nIlya Averyanov <i.averyanov@geoscan.aero>\nJohn Ullman <jrullman@google.com>\nKet3r <peter.kempter@gmail.com>\nmaciej <maciej.matuszak@gmail.com>\nMarek Zukal <marek.zukal@gmail.com>\nPaul Beusterien <paulbeusterien@google.com>\nRogers Guedes <rogers.guedes@smdautomacao.com>\nStefan R. Filipek <srfilipek@gmail.com>\nT. Carl Beery <beeryt@users.noreply.github.com>\nVitali Lovich <vlovich@google.com>\nVojtěch Boček <vbocek@gmail.com>\nWael Nasreddine <wael.nasreddine@gmail.com>\nwangli28 <wangli28@beyondsoft.com>\nGediminas Žukaitis <gediminas.zukaitis@protonmail.com>\nAlex Pacini <alexpacini90@gmail.com>\nCong <congusbongus@gmail.com>\nkurddt <kurddt@users.noreply.github.com>\notopetrik <oto.petrik@gmail.com>\nPsy-Kai <psykai1993@googlemail.com>\na1lu <a1lu@users.noreply.github.com>\nL <46594312+WakandaO2@users.noreply.github.com>\nMelvin Wang <mwang@sibros.tech>\nTim Gates <tim.gates@iress.com>\nleabut <leabut@users.noreply.github.com>\nAngel ILIEV <a.v.iliev13@gmail.com>\nJakub Tymejczyk <jakub@tymejczyk.pl>\nMatthew Simmons <simmonmt@acm.org>\nAnthony Pesch <inolen@gmail.com>\nAvik De <avikde@gmail.com>\nConrad Wood <github@conradwood.net>\nDavid Sabatie <david.sabatie@notrenet.com>\nSebastian Stockhammer <sebastian.stockhammer@rosenberger.de>\nGil Shapira <gil.shapira@intusurg.com>\nIan Frosst <ianjfrosst@gmail.com>\nIngo Kresse <ingo.kresse@kuka.com>\nIvan Zrno <ivan.zrno2@gmail.com>\nJonathan Seilkopf <j.seilkopf@isatech.de>\nKarl Ljungkvist <k.ljungkvist@gmail.com>\nMathis Logemann <mathisloge@gmail.com>\nOleg Dolgy <60554929+odolgy@users.noreply.github.com>\nPavel Sokolov <pavel@sokolov.me>\nSlavey Karadzhov <slav@attachix.com>\nTobias Nießen <tniessen@tnie.de>\nChristian Balcom <robot.inventor@gmail.com>\nChristopher Hughes <67643395+chughes-pika@users.noreply.github.com>\nGreg Balke <gbalke@berkeley.edu>\nJussi Keränen <jussike@gmail.com>\nKrzysztof Rosinski <krzysiek@jrdltd.co.uk>\nNathaniel Brough <nathaniel.brough@gmail.com>\nSean Kahler <itsbattledash@gmail.com>\nValerii Koval <valeros@users.noreply.github.com>\nArmando Montanez <amontanez@google.com>\nBrian Yuan <bayuan@purdue.edu>\nHans Binderup <habi@bang-olufsen.dk>\nIsaac Torres <isaac@isaactorz.dev>\nJerry Chen <jerry.chen@touchgui.com>\njheaff1 <jheaff1@outlook.com>\nJoseph Duchesne <joseph@avidbots.com>\nJosh Strohminger <joshstrohminger@users.noreply.github.com>\nKrishna Ersson <2743723+kersson@users.noreply.github.com>\nMark <mark@astranis.com>\nNick St.Pierre <120039901+nicholas-stpierre-simplisafe@users.noreply.github.com>\nphilippe44 <philippe44@users.noreply.github.com>\nRichard Patel <ripatel@jumptrading.com>\nTilen Majerle <tilen.majerle@gmail.com>\nTobias Thiel <tobias011@gmail.com>\nAdrian Böckenkamp <adrian.boeckenkamp@iml.fraunhofer.de>\nAntony Male <antony.male@gmail.com>\nChi-Ju Wu <sayter99@gmail.com>\nGeorgii Surkov <georgii.surkov@outlook.com>\nJan Dorniak <jaskij@gmail.com>\nJoseph Chen <joseph@baoruh.com.tw>\nMarco Nilsson <marco@zyax.se>\nNick Cooke <nickcooke@google.com>\nPieter De Gendt <pieter.degendt@gmail.com>\nReinis Veips <reinis.veips@atlasaero.space>\nRobin Kastberg <robin.kastberg@iar.com>\nTed Pudlik <tpudlik@gmail.com>\nZach Deibert <zachdeibert@gmail.com>\n"
        },
        {
          "name": "BUILD.bazel",
          "type": "blob",
          "size": 2.9599609375,
          "content": "load(\"@bazel_skylib//rules:copy_file.bzl\", \"copy_file\")\n\n# Note: if you are still using WORKSPACE, you will need to patch this file to use the following instead\n# load(\"@python_3_11//:defs.bzl\", \"py_binary\")\nload(\"@python_versions//3.11:defs.bzl\", \"py_binary\")\nload(\"@rules_proto//proto:defs.bzl\", \"proto_library\")\nload(\"@rules_proto_grpc//:defs.bzl\", \"proto_plugin\")\nload(\"@rules_python//python:proto.bzl\", \"py_proto_library\")\nload(\"@rules_python//python/pip_install:requirements.bzl\", \"compile_pip_requirements\")\nload(\"//extra/bazel:nanopb_cc_proto_library.bzl\", \"cc_nanopb_proto_library\")\n\npackage(default_visibility = [\"//visibility:public\"])\n\nlicenses([\"notice\"])\n\nexports_files([\"LICENSE.txt\"])\n\ncc_library(\n    name = \"nanopb\",\n    srcs = [\n        \"pb_common.c\",\n        \"pb_decode.c\",\n        \"pb_encode.c\",\n    ],\n    hdrs = [\n        \"pb.h\",\n        \"pb_common.h\",\n        \"pb_decode.h\",\n        \"pb_encode.h\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n\ncopy_file(\n    name = \"protoc-gen-nanopb.py\",\n    src = \"generator/protoc-gen-nanopb\",\n    out = \"generator/protoc-gen-nanopb.py\",\n    allow_symlink = True,\n)\n\npy_binary(\n    name = \"protoc-gen-nanopb\",\n    srcs = glob([\n        \"generator/**/*.py\",\n    ]) + [\n        \":protoc-gen-nanopb.py\",\n    ],\n    data = glob([\n        \"generator/**/*.proto\",\n    ]),\n    env = {\n        \"NANOPB_PB2_NO_REBUILD\": \"1\",\n    },\n    imports = [\n        \"generator\",\n    ],\n    deps = [\n        \":nanopb_py_proto\",\n    ],\n)\n\nproto_plugin(\n    name = \"nanopb_plugin\",\n    env = {\n        \"NANOPB_PB2_NO_REBUILD\": \"1\",\n    },\n    options = [\n        \"--library-include-format=quote\",\n    ],\n    outputs = [\n        \"{protopath}.pb.h\",\n        \"{protopath}.pb.c\",\n    ],\n    separate_options_flag = True,\n    tool = \":protoc-gen-nanopb\",\n    use_built_in_shell_environment = False,\n    visibility = [\"//visibility:public\"],\n)\n\nproto_library(\n    name = \"nanopb_proto\",\n    srcs = [\n        \"generator/proto/nanopb.proto\",\n    ],\n    strip_import_prefix = \"generator/proto/\",\n    deps = [\"@protobuf//:descriptor_proto\"],\n)\n\npy_proto_library(\n    name = \"nanopb_py_proto\",\n    deps = [\":nanopb_proto\"],\n)\n\ncc_nanopb_proto_library(\n    name = \"test_compilation\",\n    protos = [\"@protobuf//:descriptor_proto\"],\n    visibility = [\"//visibility:private\"],\n)\n\nproto_library(\n    name = \"all_types_proto\",\n    srcs = [\"tests/alltypes/alltypes.proto\"],\n)\n\ncc_nanopb_proto_library(\n    name = \"all_types_nanopb\",\n    nanopb_options_files = [\"tests/alltypes/alltypes.options\"],\n    protos = [\":all_types_proto\"],\n    visibility = [\"//visibility:private\"],\n)\n\ncc_test(\n    name = \"bazel_options_support\",\n    srcs = [\"tests/bazel_options_support/bazel_options_support.cc\"],\n    deps = [\":all_types_nanopb\"],\n)\n\n# Run `bazel run //:requirements.update` if you want to update the requirements.\ncompile_pip_requirements(\n    name = \"requirements\",\n    extra_args = [\"--allow-unsafe\"],\n    requirements_in = \"extra/requirements.txt\",\n    requirements_txt = \"extra/requirements_lock.txt\",\n)\n"
        },
        {
          "name": "CHANGELOG.txt",
          "type": "blob",
          "size": 29.302734375,
          "content": "nanopb-0.4.9.1 (2024-12-01)\n Fix memory not released on error return from pb_decode_ex() (GHSA-xwqq-qxmw-hj5r)\n Fix deprecated MakeClass() call in generator (#1015)\n Fix compiler error with enums and --c-style (#1014)\n Fix version conflict with bazel build rules (#1034)\n\nnanopb-0.4.9 (2024-09-19)\n Fix problems with enum intsize introduced in 0.4.8 (#961)\n Fix Python pkg_resources deprecation (#887)\n Add option to discard deprecated fields (#997)\n Use fallback_type when breaking circular dependencies (#996)\n Discard autogenerated map entry types if the field is skipped (#956)\n Use pb_byte_t = uint8_t when available (#916)\n Add enum_validate option (#988, #991)\n Add check_return attribute for IAR compiler (#965)\n Add label_override field option (#962, #963)\n Add Zephyr module specification (#946)\n Add Apple privacy manifest (#938)\n Bazel rule improvements, including bzlmod migration (#927, #950)\n CMake build rule improvements (#936, #939, #942, #958, #968, #971, #974, #978, #1003)\n Improve C++ descriptors (#931, #933)\n Test case improvements (#928)\n Update dependency package versions (#924, #959, #986, #998, #1010)\n Documentation improvements (#319, #710, #999)\n\nnanopb-0.4.8 (2023-11-11)\n Fix name mangling with dependent proto files (#892, #899)\n Fix initializer macros for custom callback datatype (#806)\n Use UTF-8 encoding for generated files irrespective of locale (#868)\n Add integer size overrides for fixed width types (#897)\n Add ability to specify size of generated enums (#867)\n Provide define for largest message in file (#893)\n Automatically break circular dependencies (#881)\n Remove pkg_resources import to avoid deprecation warning (#887)\n Use static_assert keyword on MSVC in C89 mode (#843)\n platformio: Allow substitutions in custom_nanopb_protos (#882)\n CMakeLists: Add missing __init__.py to generator install (#841)\n CMakeLists: Add nanopb_PYTHON_INSTDIR_OVERRIDE (#875)\n CMakeLists: Rename installation directories (#845, #907)\n FindNanopb.cmake: Fix regression bug with relative include path (#888)\n FindNanopb.cmake: Ensure generator files are updated when cached (#847)\n FindNanopb.cmake: Fix generator call on Windows (#874)\n Bazel: multiple build rule fixes and updates (#855, #891, #904, #906, #919)\n\nnanopb-0.4.7 (2022-12-11)\n Fix comments generation for submessages (#788)\n Fix handling of spaces in arguments passed through protoc (#810)\n Fix problems with multiple files and mangle_names option (#783, #820)\n Fix generator error when using M_STRIP_PACKAGE without package name (#795)\n Fix compilation error with fixed size array and FT_POINTER (#630)\n Fix wrong format in Python Poetry project file (#811)\n Fix unnecessary generator message when using --quiet (#831)\n Fix enum_to_string with C++ (#838)\n Fix /* */ inside .proto file comment\n Workaround python-protobuf version issues (#787)\n Safeguard substraction in pb_read() with custom streams (#697)\n Always include pb_release() as function, instead of macro. (#802)\n Allow using = instead of : with generator option -s\n Allow specifying include format without special characters (#810)\n Allow including headers from inside of extern C (#814)\n Add option NANOPB_PB2_TEMP_DIR to store nanopb_pb2.py in a temporary dir (#601)\n Add compile-time error message for when PB_FIELD_32BIT is needed (#680, #827)\n Add --c-style command line option for naming style (#199, #533, #791)\n Add --protoc-opt to nanopb_generator.py (#628)\n Add ENUMTYPE convenience macros (#803)\n Add Bazel build rules (#360, #500)\n Generator: keep order of messages when possible\n Test case improvements (#792)\n PlatformIO build rule improvements (#808, #809, #819, #834, #839, #840)\n CMake build rule improvements (#822)\n CMakeLists: use protoc wrapper script by default (#769)\n\nnanopb-0.4.6 (2022-05-30)\n Fix passing of error message from substream callback (#703)\n Fix comments going to wrong member variables (#701)\n Fix regression in 0.4.3 where generator did not find all dependencies (#720)\n Fix FindNanopb.cmake not finding options file (#659)\n Fix double-definition errors with size_union (#692)\n Fix generator error with same inner message name (#746)\n Fix infinite recursion in generator/protoc script (#762)\n Fix unicode comment handling for Python 2 (#740)\n Fix compiler warnings with PB_BUFFER_ONLY (#717)\n Fix options dependency in nanopb.mk (#666)\n Fix handling of filenames with dot in them in FindNanopb.cmake (#756)\n Add fallback_type option (#772, #773)\n Use C11 static assert mechanism by default (#761, #766)\n Use 'static_assert'  keyword for iar (#679)\n Explicitly check for pItem == NULL to satisfy Xcode analyzer (#667, #674)\n Support --proto-path as alias to -I (#749)\n Refactor name mangling to separate class, improve error messages (#735)\n Move PB_WT_PACKED definition to the header to fix compiler warnings (#671)\n FindNanopb.cmake: use --nanopb_opt for option passing by default (#752)\n FindNanopb.cmake: Add option NANOPB_GENERATE_CPP_STANDALONE (#741)\n FindNanopb.cmake: Add PROTOC_OPTIONS variable (#768, #771)\n CMakeLists: add build interface for using as a submodule (#669)\n CMakeLists: fix error with nanopb_BUILD_GENERATOR=OFF (#764)\n CMakeLists: make more uniform (#676)\n CMakeLists: Fix uninitialized PYTHON_INSTDIR (#652)\n Clean up CMake examples (#741)\n Rebuild nanopb_pb2.py and print version numbers on import failure (#733, #742)\n Use memcpy instead of iterating on buf_read/write (#751)\n Add generator support for PlatformIO (#718)\n Add clean target to generator/proto/Makefile (#681)\n Windows .bats: use standard python invocation instead of py.exe launcher (#657)\n Fix problems running tests with newer SCons version\n Improve handling of varint overflows\n Improve optimization for little-endian platforms\n\nNOTE: During development, prereleases were published on PlatformIO registry\nas versions 0.4.6 - 0.4.6.3. The version 0.4.6.4 on PlatformIO corresponds\nto the real final 0.4.6 release.\n\nnanopb-0.4.5 (2021-03-22)\n Fix invalid free() with oneof (#647, GHSA-7mv5-5mxh-qg88)\n Fix unordered field numbers inside oneof causing fields to be ignored (#617)\n Fix pb_decode() not initializing fields inside oneof (#635\n Fix compiler errors with complex oneof hierarchy and sizeof() (#610)\n Fix descriptor width calculation for 64-bit types (#644)\n Fix compiler error in generated initializer for submessage callback (#631)\n Fix duplicate union definition in generated file (#637)\n Fix test case build error on SCons 4.1.0\n Pip package: include nanopb_pb2.py (#629)\n Make generator consider dependencies recursively (#610)\n Bazel build system updates (#633)\n Add support for including comments from .proto file (#85, #645)\n\nnanopb-0.4.4 (2020-11-25)\n Fix memory leak with oneofs and PB_ENABLE_MALLOC (#615, GHSA-85rr-4rh9-hhwh)\n Fix generator error when oneof contains a single unresolved field size (#610)\n Fix unsigned enums not working correctly inside OneOf (#611)\n Fix recursion depth exceeded error in generator (#493)\n Add '--version' option to nanopb_generator.py (#607)\n Add support for proto3 optional fields introduced in protoc 3.12 (#591)\n Add better error message when enum type is not found (#592)\n Allow specifying descriptorsize on field level also (#546)\n Allow multiple targets to be created by calling NANOPB_GENERATE_CPP() (#596)\n Conanfile: Add protobuf-nanopb library to cpp_info.libs (#605)\n Include version number in generator verbose output\n Convert documentation to markdown format (#587)\n Remove outdated transitional generator/nanopb/options.proto.\n Test case improvements\n Documentation improvements\n\nnanopb-0.4.3 (2020-09-21)\n Fix generator error when output is in current directory (#553)\n Fix issue with unknown message sizes being referred inside oneof encoded size calculation (#569)\n Fix problem with [default=xxxx, (nanopb).proto3=true] field option combination (#558)\n Fix cross compilation with Conan build system (#568)\n Better support C++ types in generated structs (#577)\n CMake rule improvements (#554, #555, #556, #561, #564)\n Generator: fix compatibility bug with Python 3.1 and earlier\n Make Linux and Mac packages use grpcio protoc\n Make pb_decode_varint32() reject overlong varint encodings.\n Performance optimizations\n Test case improvements\n Documentation improvements\n\nNOTE: version 0.4.3 changes layout of pb_msgdesc_t. It requires recompiling .pb.c files and\nthus breaks ABI compatibility. In general, ABI compatibility is not currently maintained\nbetween any nanopb versions.\n\nNOTE: There was an apparent false positive virus identification by Windows Defender of the\nPyInstaller 3.6 based Windows package nanopb-0.4.3-windows-x86.zip. The package was replaced\nby nanopb-0.4.3-p1-windows-x86.zip with rebuilt PyInstaller 4.0, which seems to avoid the problem.\nActual nanopb code is unchanged between the packages.\n\nnanopb-0.4.2 (2020-06-23)\n Fix buffer overflow when encoding bytes with size set to 65535 (#547, GHSA-3p39-mfxg-hrq4)\n Fix segfault with pointer fields and proto3_singular_msgs = true. (#504,#505)\n Fix Windows 10 temp file handling (#486)\n Fix macro name conflicts (ATMEGA32U4 UENUM and more) (#522)\n Fix generator error with nested messages and default values (#487)\n Fix nanopb_generator exception on enums with aliases (#535)\n Fix compile error when struct members are called X or a (#492)\n Fix sizeof(union ...) fallback not compiling with C++ (#415, #494)\n Fix \"missing required field\" error with submessage callback (#544)\n Fix field descriptor sizing with submsg_callback option (#545)\n Fix protoc calling on Python 2 (#503)\n Fix handling of varying NaN representations in PB_CONVERT_DOUBLE_FLOAT (#543)\n Fix clang undefined behavior sanitizer errors.\n Change generator to use Python 3 by default (#441, #509)\n Binary packages updated to use Python 3 and grpcio-tools\n Add support for infinity and nan floating-point defaults (#530, #538)\n Add generator option sort_by_tag (#542)\n Add type_override option to override type defined in .proto (#497)\n Set proto2 enum fields to first value when no default is given, even if nonzero (#532,#539)\n Include protoc-gen-nanopb in path in protoc wrapper script\n Properly pass error status from protoc wrapper when calling binary protoc\n Generator: pass --include_imports when calling protoc (#494)\n Create intermediate directories when writing files to relative path (#512)\n Add current directory to include path for protoc (#499)\n Update readme to use nanopb_generator.py directly\n Regression test for proto3 incorrectly considered empty (#504)\n CMake: change package name to Nanopb for cmake 3.17 compatibility (#506)\n CMake: remove find_package(PythonInterp) (#508)\n CMake: use split --nanopb_opt only on protoc >= 3.6 (#515)\n CMake: Relax python version spec, allowing Python3. (#534)\n Swift package manager (#549)\n Rename BUILD as BUILD.bazel (#537)\n\nNote: Windows binary packages in 0.4.2 and later require Windows 7 or newer.\n\nnanopb-0.4.1 (2020-02-02)\n Fix invalid free() after failed realloc() (GHSA-gcx3-7m76-287p)\n Avoid overflows in allocation for packed fields.\n Verify stream size before allocating string / bytes.\n Add workaround for avr-libc realloc() bug (#475)\n Fix bug with field numbers >255 (#407)\n Fix compilation error on platforms without uint8_t (#485)\n Fix warnings on Python3.8 (#399, #467)\n Make fixed_count option work when combined with FT_POINTER.\n Add missing #define for submsg callbacks, add regression test (#472)\n Fix ImportError when using generator/protoc with Python 3\n Remove accidental debug code in generator\n Reduce stack usage (#484)\n Remove PB_FIELDINFO_WIDTH option (#473)\n Add nanopb-specific package name option (#422)\n Add testcase for Any type (#163)\n Add exclude option also from .proto/.options\n Set default include path in the grpc_tools protoc wrapper.\n Add workaround for python-protobuf 3.6.1 bug (#478)\n Detect invalid wire type when decoding fields.\n Improved fuzz testing\n\nnanopb-0.4.0 (2019-12-20)\n New field descriptor format.\n Make nanopb_generator automatically compile .proto files (#462)\n Allow installing as Python package from pip (#460)\n Use protoc from grpcio-tools Python package if available (#463)\n Change proto3 message types to be optional (#308, #452)\n Add pb_decode_ex(), pb_encode_ex() functions.\n Automatically rebuild nanopb_pb2.py\n Use plugin.proto that comes with python-protobuf (#234)\n\n Allow specifying a per-message callback. (#175)\n Improve callback handling inside oneofs. (#175)\n\n Introduce new compile time flag: PB_VALIDATE_UTF8 (#437)\n Add TypenameMangling.M_PACKAGE_INITIALS (#394)\n Introduce new compile time flag: PB_ENCODE_ARRAYS_UNPACKED (#427)\n Add default_has option (#423)\n Add option for including extra files from .pb.h\n Add generator option to error out on unmatched options (#458)\n Generator: Allow comma separated options in plugin mode (#343)\n Allow comma-separated option parsing to handle `#include` (#450)\n Remove timestamp from generated files by default, add -t to keep it.\n Make --no-strip-path default (#326)\n Fix .options file case sensitivity on Windows.\n Fix generator error with mangle_names option (#380)\n Take int_size setting into account in calculating message sizes (#373)\n .gitignore: don't ignore generator-bin files (#419)\n Cleanup .pb.h header format\n\n Make tests run on AVR and STM32\n Add PB_CONVERT_DOUBLE_FLOAT setting to convert doubles on AVR.\n Store field descriptor constants in flash on AVR (#464)\n Added \"f\" suffix to const float declarations. (#453)\n Fix clang-tidy warnings about using signed integers in binary bitwise operations (#451)\n Add C++ message descriptors helper (#384)\n Implement conan recipe (#378)\n CMake: Split nanopb_out command (#454)\n CMake: install created shared library(dll) in windows to the binary folder (#447)\n\nnanopb-0.3.9.9 (2022-04-23)\n Fix Xcode analyzer warnings (#667, #674)\n Fix clang sanitizer warnings\n\nNote: there are no known functional differences between 0.3.9.8 and 0.3.9.9.\nThe changes are merely to fix warnings introduced by new compiler versions.\n\nnanopb-0.3.9.8 (2021-03-22)\n Fix invalid free() with oneof (#647, GHSA-7mv5-5mxh-qg88)\n Don't generate lines with trailing spaces (#622)\n Verify stream size before allocating string / bytes (#620)\n\nnanopb-0.3.9.7 (2020-11-25)\n Fix memory leak with oneofs and PB_ENABLE_MALLOC (#615, GHSA-85rr-4rh9-hhwh)\n Fix unsigned enums not working correctly inside OneOf (#611)\n Add '--version' option to nanopb_generator.py (#607)\n SwiftPM rule updates (#567, #585)\n\nnanopb-0.3.9.6 (2020-06-23)\n Fix buffer overflow when encoding bytes with size set to 65535 (#547, GHSA-3p39-mfxg-hrq4)\n Fix proto3 submessage improperly considered empty (#504)\n Fix ImportError when using generator/protoc with Python 3\n Add build rules for Swift package manager (#549)\n\nnanopb-0.3.9.5 (2020-02-02)\n Fix invalid free() after failed realloc() (GHSA-gcx3-7m76-287p)\n Add workaround for avr-libc realloc() bug (#475)\n Fix empty submessages getting encoded in proto3 mode (#395)\n Avoid overflows in allocation for packed fields.\n\nnanopb-0.3.9.4 (2019-10-13)\n Fix undefined behavior with bool fields (#434)\n Fix enum min/max defines when values are not in order (#405)\n Fix network_server socket example with zero-length strings (#421)\n Don't call stream read callback with count=0 (#421)\n Add compile time flag PB_ENCODE_ARRAYS_UNPACKED (#427)\n\nnanopb-0.3.9.3 (2019-03-08)\n NOTE: nanopb-0.3.9.3.tar.gz before 2019-03-21 was accidentally from 0.4 branch (#388)\n Fix fixed size and callback repeated fields inside proto3 submessages (#376, #382, #386)\n Fix incorrect PB_STATIC_ASSERT for bytes inside oneof (#363)\n Fix generator error with mangle_names option (#380)\n Generator: Allow comma separated options in plugin mode (#343)\n\nnanopb-0.3.9.2 (2018-11-10)\n Erroneous free() when using callbacks combined with PB_ENABLE_MALLOC (#346)\n Fix possible null-pointer dereference in decode_callback_field (#342)\n Fix FindNanopb.cmake on Windows (#335)\n Fix large generator memory usage with oneof fields (#338)\n Fix error in splint test (#359)\n Allow cmake to build as a shared library (#352, #353)\n Add --no-strip-path command line option (#326)\n Option for flattening nested protobuf names (#333)\n Documentation fixes (#329, #350, #358)\n Better error messages (#351)\n\nnanopb-0.3.9.1 (2018-04-14)\n Fix handling of special characters in string/bytes default values (issue #322)\n Fix encoding of negative numbers with PB_WITHOUT_64BIT (#285)\n Fix _zero initializer for enums that don't begin at 0. (#295)\n Multiple CMake fixes (#296, #299, #304, #312, #320)\n Fix compiler warnings (#305)\n Fix scons rules for Python 3\n Add check for large extension field number (issue #306)\n Updated included descriptor.proto version (#314)\n Resolve oneof sizes symbolically when needed (#311)\n Add fixed_count option (#260)\n Add some verbose prints in generator (issue #238)\n Add test/example of using 'map' type. (#289)\n\nnanopb-0.3.9 (2017-09-23)\n Fix bugs in proto3 encoding of submessages (#256)\n Fix message size calculation for arrays of size 1 (#253)\n Fix segfault with FT_CALLBACK inside FT_POINTER (#259)\n Properly detect truncated tags in corrupted messages (#277)\n Make pb_decode_varint32 overflow checks exact (#258)\n Add option to build without 64-bit support (#86)\n Add options to define source and header file extensions (#264)\n Add pb_en/decode_nullterminated() (part of #278)\n Add pb_decode_delimited_noinit (#284)\n CMake: add dependency for .options file (#265)\n CMake: change use of relative paths (#250,#271,#273)\n Better error message for missing max_size option (#281)\n Travis-CI build fixes (#283)\n Add Bazel build system file (#266)\n\nnanopb-0.3.8 (2017-03-05)\n Fix problems with multiple oneofs in same message (#229)\n Zero-valued extension fields were mistakenly ignored by encoder (#242)\n Multiple fixes related to proto3 mode (#242, #245, #247, #249)\n Fix potential unaligned access (#226, #227)\n Fix documentation for protoc --plugin argument (#239)\n Extend inline / fixed length bytes array support (#244)\n Add new option max_length for strings (#107)\n Make string substream API more robust (#230)\n Make pb_decode_varint32 public API (#231)\n Allow overriding proto3 mode (#228)\n Add optional enum->string mapping function (#223)\n Add transitional options.proto file (#241)\n Add better error message on Python library version incompatibility (#240)\n Include version number in PlatformIO library.json (#222)\n CMake build script changes (#236, #237)\n Change download links to https\n Improvements to test cases.\n\nnanopb-0.3.7 (2016-10-30)\n Add support for proto3-style singular fields (#182, #206, #216)\n Updated binary package protoc to version 3.1.0\n Add FT_INLINE allocation of bytes fields (#211)\n Include package name in include guard (#207)\n Fix missing warning with large bytes fields (issue #220)\n Added CMake project (#208)\n Add bazel BUILD file for nanopb (#209)\n Added an AUTHORS file (#211)\n Documentation updates\n Improvements to test cases.\n\nnanopb-0.3.6 (2016-06-19)\n Protect against corrupted _count fields in pb_release (#205)\n Fix error in STATIC_ASSERT with multiple files (#203)\n Add -D option to specify output directory (#193)\n Generate MIN/MAX/ARRAYSIZE defines for enums (#194)\n Generate comments about uncalculable message sizes (#195)\n Documentation updates (#196, #201)\n Improvements to test cases.\n\nnanopb-0.3.5 (2016-02-13)\n NOTE: If you are using pb_syshdr.h, you will need to add uint_least8_t\n definition. See docs/migration.rst for details.\n\n Fix generator crash with Enum inside Oneof (#188)\n Fix some generator regressions related to .options file path (#172)\n Add support for platforms without uint8_t (#191)\n Allow const parameter to pb_istream_from_buffer (#152)\n Ignore null pointers in pb_release() (#183)\n Add support for anonymous unions (#184)\n Add Python3 support to the generator (#169)\n Add code generator insertion points to generated files (#178)\n Improvements to CMake script (#181)\n Improvements to test cases.\n\nnanopb-0.3.4 (2015-09-26)\n Fix handling of unsigned 8- and 16-bit enums (issue 164)\n Fix generator on systems where python = python3. (issue 155)\n Fix compiler warning on GCC 5.x (issue 171)\n Make the generator better handle imported .protos (issue 165)\n Add packed_enum option to generator.\n Add syntax= line to .proto files (issue 167)\n Add PlatformIO registry manifest file. (pr 156)\n\nnanopb-0.3.3 (2015-04-10)\n Fix missing files in Linux binary package (issue 146)\n Fix generator bug when oneof is first field in a message. (issue 142)\n Fix generator error when long_names:false is combined with Oneofs. (issue 147)\n Fix oneof submessage initialization bug. (issue 149)\n Fix problem with plugin options on Python 2.7.2 and older. (issue 153)\n Fix crash when callback is inside oneof field. (issue 148)\n Switch to .tar.gz format for Mac OS X packages. (issue 154)\n Always define enum long names so that cross-file references work. (issue 118)\n Add msgid generator option. (issue 151)\n Improve comment support in .options files. (issue 145)\n Updates for the CMake rule file, add cmake example.\n Better error messages for syntax errors in .options file\n\nnanopb-0.3.2 (2015-01-24)\n Fix memory leaks with PB_ENABLE_MALLOC with some submessage hierarchies (issue 138)\n Implement support for oneofs (C unions). (issues 131, 141)\n Add int_size option for generator (issue 139)\n Add compilation option to disable struct packing. (issue 136)\n Change PB_RETURN_ERROR() macro to avoid compiler warnings (issue 140)\n Fix build problems with protoc 3.0.0\n Add support for POINTER type in extensions\n Initialize also extension fields to defaults in pb_decode().\n Detect too large varint values when decoding.\n\nnanopb-0.3.1 (2014-09-11)\n Fix security issue due to size_t overflows. (issue 132)\n Fix memory leak with duplicated fields and PB_ENABLE_MALLOC\n Fix crash if pb_release() is called twice.\n Fix cyclic message support (issue 130)\n Fix error in generated initializers for repeated pointer fields.\n Improve tests (issues 113, 126)\n\nnanopb-0.3.0 (2014-08-26)\n NOTE: See docs/migration.html or online at\n http://koti.kapsi.fi/~jpa/nanopb/docs/migration.html\n for changes in this version. Most importantly, you need to add\n pb_common.c to the list of files to compile.\n\n Separated field iterator logic to pb_common.c (issue 128)\n Change the _count fields to use pb_size_t datatype (issue 82)\n Added PB_ prefix to macro names (issue 106)\n Added #if version guard to generated files (issue 129)\n Added migration document\n\nnanopb-0.2.9.5 (2020-06-23)\n Fix buffer overflow when encoding bytes with size set to 65535 (#547, GHSA-3p39-mfxg-hrq4)\n Backport Python 3 and protoc 3.x fixes to test cases\n\nnanopb-0.2.9.4 (2020-02-02)\n Fix invalid free() after failed realloc() (GHSA-gcx3-7m76-287p)\n Add workaround for avr-libc realloc() bug (#475)\n\nnanopb-0.2.9.3 (2016-06-19)\n Protect against corrupted _count fields in pb_release (#205)\n\nnanopb-0.2.9.2 (2015-01-24)\n Fix memory leaks with PB_ENABLE_MALLOC with some submessage hierarchies (issue 138)\n Fix compilation error with generated initializers for repeated pointer fields\n\nnanopb-0.2.9.1 (2014-09-11)\n Fix security issue due to size_t overflows. (issue 132)\n Fix memory leak with duplicated fields and PB_ENABLE_MALLOC\n Fix crash if pb_release() is called twice.\n\nnanopb-0.2.9 (2014-08-09)\n NOTE: If you are using the -e option with the generator, you have\n to prepend . to the argument to get the same behaviour as before.\n\n Do not automatically add a dot with generator -e option. (issue 122)\n Fix problem with .options file and extension fields. (issue 125)\n Don't use SIZE_MAX macro, as it is not in C89. (issue 120)\n Generate #defines for initializing message structures. (issue 79)\n Add skip_message option to generator. (issue 121)\n Add PB_PACKED_STRUCT support for Keil MDK-ARM toolchain (issue 119)\n Give better messages about the .options file path. (issue 124)\n Improved tests\n\nnanopb-0.2.8 (2014-05-20)\n Fix security issue with PB_ENABLE_MALLOC. (issue 117)\n Add option to not add timestamps to .pb.h and .pb.c preambles. (issue 115)\n Documentation updates\n Improved tests\n\nnanopb-0.2.7 (2014-04-07)\n Fix bug with default values for extension fields (issue 111)\n Fix some MISRA-C warnings (issue 91)\n Implemented optional malloc() support (issue 80)\n Changed pointer-type bytes field datatype\n Add a \"found\" field to pb_extension_t (issue 112)\n Add convenience function pb_get_encoded_size() (issue 16)\n\nnanopb-0.2.6 (2014-02-15)\n Fix generator error with bytes callback fields (issue 99)\n Fix warnings about large integer constants (issue 102)\n Add comments to where STATIC_ASSERT is used (issue 96)\n Add warning about unknown field names on .options (issue 105)\n Move descriptor.proto to google/protobuf subdirectory (issue 104)\n Improved tests\n\nnanopb-0.2.5 (2014-01-01)\n Fix a bug with encoding negative values in int32 fields (issue 97)\n Create binary packages of the generator + dependencies (issue 47)\n Add support for pointer-type fields to the encoder (part of issue 80)\n Fixed path in FindNanopb.cmake (issue 94)\n Improved tests\n\nnanopb-0.2.4 (2013-11-07)\n Remove the deprecated NANOPB_INTERNALS functions from public API.\n Document the security model.\n Check array and bytes max sizes when encoding (issue 90)\n Add #defines for maximum encoded message size (issue 89)\n Add #define tags for extension fields (issue 93)\n Fix MISRA C violations (issue 91)\n Clean up pb_field_t definition with typedefs.\n\nnanopb-0.2.3 (2013-09-18)\n Improve compatibility by removing ternary operator from initializations (issue 88)\n Fix build error on Visual C++ (issue 84, patch by Markus Schwarzenberg)\n Don't stop on unsupported extension fields (issue 83)\n Add an example pb_syshdr.h file for non-C99 compilers\n Reorganize tests and examples into subfolders (issue 63)\n Switch from Makefiles to scons for building the tests\n Make the tests buildable on Windows\n\nnanopb-0.2.2 (2013-08-18)\n Add support for extension fields (issue 17)\n Fix unknown fields in empty message (issue 78)\n Include the field tags in the generated .pb.h file.\n Add pb_decode_delimited and pb_encode_delimited wrapper functions (issue 74)\n Add a section in top of pb.h for changing compilation settings (issue 76)\n Documentation improvements (issues 12, 77 and others)\n Improved tests\n\nnanopb-0.2.1 (2013-04-14)\n NOTE: The default callback function signature has changed.\n       If you don't want to update your code, define PB_OLD_CALLBACK_STYLE.\n \n Change the callback function to use void** (issue 69)\n Add support for defining the nanopb options in a separate file (issue 12)\n Add support for packed structs in IAR and MSVC (in addition to GCC) (issue 66)\n Implement error message support for the encoder side (issue 7)\n Handle unterminated strings when encoding (issue 68)\n Fix bug with empty strings in repeated string callbacks (issue 73)\n Fix regression in 0.2.0 with optional callback fields (issue 70)\n Fix bugs with empty message types (issues 64, 65)\n Fix some compiler warnings on clang (issue 67)\n Some portability improvements (issues 60, 62)\n Various new generator options\n Improved tests\n\nnanopb-0.2.0 (2013-03-02)\n NOTE: This release requires you to regenerate all .pb.c\n       files. Files generated by older versions will not\n       compile anymore.\n\n Reformat generated .pb.c files using macros (issue 58)\n Rename PB_HTYPE_ARRAY -> PB_HTYPE_REPEATED\n Separate PB_HTYPE to PB_ATYPE and PB_HTYPE\n Move STATIC_ASSERTs to .pb.c file\n Added CMake file (by Pavel Ilin)\n Add option to give file extension to generator (by Michael Haberler)\n Documentation updates\n\nnanopb-0.1.9 (2013-02-13)\n Fixed error message bugs (issues 52, 56)\n Sanitize #ifndef filename (issue 50)\n Performance improvements\n Add compile-time option PB_BUFFER_ONLY\n Add Java package name to nanopb.proto\n Check for sizeof(double) == 8 (issue 54)\n Added generator option to ignore some fields. (issue 51)\n Added generator option to make message structs packed. (issue 49)\n Add more test cases.\n\nnanopb-0.1.8 (2012-12-13)\n Fix bugs in the enum short names introduced in 0.1.7 (issues 42, 43)\n Fix STATIC_ASSERT macro when using multiple .proto files. (issue 41)\n Fix missing initialization of istream.errmsg\n Make tests/Makefile work for non-gcc compilers (issue 40)\n\nnanopb-0.1.7 (2012-11-11)\n Remove \"skip\" mode from pb_istream_t callbacks. Example implementation had a bug. (issue 37)\n Add option to use shorter names for enum values (issue 38)\n Improve options support in generator (issues 12, 30)\n Add nanopb version number to generated files (issue 36)\n Add extern \"C\" to generated headers (issue 35)\n Add names for structs to allow forward declaration (issue 39)\n Add buffer size check in example (issue 34)\n Fix build warnings on MS compilers (issue 33)\n\nnanopb-0.1.6 (2012-09-02)\n Reorganize the field decoder interface (issue 2)\n Improve performance in submessage decoding (issue 28)\n Implement error messages in the decoder side (issue 7)\n Extended testcases (alltypes test is now complete).\n Fix some compiler warnings (issues 25, 26, 27, 32).\n\nnanopb-0.1.5 (2012-08-04)\n Fix bug in decoder with packed arrays (issue 23).\n Extended testcases.\n Fix some compiler warnings.\n\nnanopb-0.1.4 (2012-07-05)\n Add compile-time options for easy-to-use >255 field support.\n Improve the detection of missing required fields.\n Added example on how to handle union messages.\n Fix generator error with .proto without messages.\n Fix problems that stopped the code from compiling with some compilers.\n Fix some compiler warnings.\n\nnanopb-0.1.3 (2012-06-12)\n Refactor the field encoder interface.\n Improve generator error messages (issue 5)\n Add descriptor.proto into the #include exclusion list\n Fix some compiler warnings.\n\nnanopb-0.1.2 (2012-02-15)\n Make the generator to generate include for other .proto files (issue 4).\n Fixed generator not working on Windows (issue 3)\n\nnanopb-0.1.1 (2012-01-14)\n Fixed bug in encoder with 'bytes' fields (issue 1).\n Fixed a bug in the generator that caused a compiler error on sfixed32 and sfixed64 fields.\n Extended testcases.\n\nnanopb-0.1.0 (2012-01-06)\n First stable release.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 6.7216796875,
          "content": "cmake_minimum_required(VERSION 3.14.0)\n\nproject(nanopb VERSION 1.0.0 LANGUAGES C)\n\nset(nanopb_VERSION_STRING ${PROJECT_NAME}-${${PROJECT_NAME}_VERSION}-dev)\nset(nanopb_SOVERSION 0)\n\nstring(REPLACE \"nanopb-\" \"\" nanopb_VERSION ${nanopb_VERSION_STRING})\n\noption(BUILD_SHARED_LIBS \"Build shared libraries\" OFF)\noption(BUILD_STATIC_LIBS \"Build static libraries\" ON)\n\noption(nanopb_BUILD_RUNTIME \"Build the headers and libraries needed at runtime\" ON)\noption(nanopb_BUILD_GENERATOR \"Build the protoc plugin for code generation\" ON)\noption(nanopb_MSVC_STATIC_RUNTIME \"Link static runtime libraries\" ON)\n\nset(nanopb_PYTHON_INSTDIR_OVERRIDE \"\" CACHE PATH \"Override the default python installation directory with the given path\")\n\nfind_program(nanopb_PROTOC_PATH protoc PATHS generator-bin generator NO_DEFAULT_PATH)\nfind_program(nanopb_PROTOC_PATH protoc)\nif(NOT EXISTS ${nanopb_PROTOC_PATH})\n    message(FATAL_ERROR \"protoc compiler not found\")\nendif()\n\nif(NOT DEFINED CMAKE_DEBUG_POSTFIX)\n    set(CMAKE_DEBUG_POSTFIX \"d\")\nendif()\n\ninclude(GNUInstallDirs)\n\nif(MSVC AND nanopb_MSVC_STATIC_RUNTIME)\n    foreach(flag_var\n            CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE\n            CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO)\n        if(${flag_var} MATCHES \"/MD\")\n            string(REGEX REPLACE \"/MD\" \"/MT\" ${flag_var} \"${${flag_var}}\")\n        endif(${flag_var} MATCHES \"/MD\")\n    endforeach(flag_var)\nendif()\n\nif(NOT DEFINED CMAKE_INSTALL_CMAKEDIR)\n    set(CMAKE_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/nanopb\")\nendif()\n\n# Determine Python module installation path\nif (NOT nanopb_PYTHON_INSTDIR_OVERRIDE)\n    find_package(Python REQUIRED COMPONENTS Interpreter)\n    file(TO_CMAKE_PATH \"${Python_SITELIB}\" PYTHON_INSTDIR)\nelse()\n    set(PYTHON_INSTDIR ${nanopb_PYTHON_INSTDIR_OVERRIDE})\nendif()\nmessage(STATUS \"Python install dir: ${PYTHON_INSTDIR}\")\n\n# Package nanopb generator as Python module 'nanopb'\nif(nanopb_BUILD_GENERATOR)\n    # Copy Python code files related to the generator\n    add_custom_target(nanopb_generator ALL\n        COMMAND ${CMAKE_COMMAND} -E make_directory\n            ${PROJECT_BINARY_DIR}/nanopb/generator/proto\n\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n            ${PROJECT_SOURCE_DIR}/generator/proto/_utils.py\n            ${PROJECT_SOURCE_DIR}/generator/proto/__init__.py\n            ${PROJECT_SOURCE_DIR}/generator/proto/nanopb.proto\n            ${PROJECT_BINARY_DIR}/nanopb/generator/proto\n\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n            ${PROJECT_SOURCE_DIR}/generator/nanopb_generator.py\n            ${PROJECT_SOURCE_DIR}/generator/__init__.py\n            ${PROJECT_BINARY_DIR}/nanopb/generator\n\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n            ${PROJECT_SOURCE_DIR}/generator/__init__.py\n            ${PROJECT_BINARY_DIR}/nanopb\n\n        COMMAND ${nanopb_PROTOC_PATH}\n            --python_out=${PROJECT_BINARY_DIR}/nanopb/generator/proto\n            -I${PROJECT_SOURCE_DIR}/generator/proto\n            ${PROJECT_SOURCE_DIR}/generator/proto/nanopb.proto\n    )\n\n\n\n    # Install Python module files\n    install(\n        DIRECTORY ${PROJECT_BINARY_DIR}/nanopb\n        DESTINATION ${PYTHON_INSTDIR}\n        FILES_MATCHING\n        PATTERN *.py\n        PATTERN *.proto\n        PATTERN __pycache__ EXCLUDE\n    )\n\n    # Generate a wrapper script that calls nanopb.generator Python module when invoked\n    configure_file(\n        extra/script_wrappers/nanopb_generator.py.in\n        ${PROJECT_BINARY_DIR}/nanopb_generator.py\n    )\n    install(\n        PROGRAMS ${PROJECT_BINARY_DIR}/nanopb_generator.py\n        DESTINATION ${CMAKE_INSTALL_BINDIR}\n    )\n\n    # Install shell/bat script wrappers for invoking nanopb_generator.py.\n    # protoc-gen-nanopb is automatically used by protoc when --nanopb_out= option is used.\n    if(WIN32)\n        # Include the full path to Python executable in Windows .bat scripts, as it is not in PATH on all systems\n        file(READ generator/protoc-gen-nanopb.bat FILE_CONTENTS)\n        string(REPLACE \"python\" ${Python_EXECUTABLE} FILE_CONTENTS \"${FILE_CONTENTS}\")\n        file(WRITE ${PROJECT_BINARY_DIR}/protoc-gen-nanopb.bat \"${FILE_CONTENTS}\")\n\n        file(READ generator/nanopb_generator.bat FILE_CONTENTS)\n        string(REPLACE \"python\" ${Python_EXECUTABLE} FILE_CONTENTS \"${FILE_CONTENTS}\")\n        file(WRITE ${PROJECT_BINARY_DIR}/nanopb_generator.bat \"${FILE_CONTENTS}\")\n\n        install(\n            PROGRAMS\n                ${PROJECT_BINARY_DIR}/protoc-gen-nanopb.bat\n                ${PROJECT_BINARY_DIR}/nanopb_generator.bat\n            DESTINATION ${CMAKE_INSTALL_BINDIR}\n        )\n    else()\n        # Linux/Mac scripts currently use python3 from PATH\n        install(\n            PROGRAMS\n                generator/protoc-gen-nanopb\n                generator/nanopb_generator\n            DESTINATION ${CMAKE_INSTALL_BINDIR}\n        )\n    endif()\nendif()\n\nif(nanopb_BUILD_RUNTIME)\n    if(BUILD_SHARED_LIBS)\n        add_library(protobuf-nanopb SHARED\n            pb.h\n            pb_common.h\n            pb_common.c\n            pb_encode.h\n            pb_encode.c\n            pb_decode.h\n            pb_decode.c)\n        set_target_properties(protobuf-nanopb PROPERTIES\n            SOVERSION ${nanopb_SOVERSION})\n        install(TARGETS protobuf-nanopb EXPORT nanopb-targets\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n        target_include_directories(protobuf-nanopb INTERFACE\n            $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/nanopb>\n            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n        )\n    endif()\n\n    if(BUILD_STATIC_LIBS)\n        add_library(protobuf-nanopb-static STATIC\n            pb.h\n            pb_common.h\n            pb_common.c\n            pb_encode.h\n            pb_encode.c\n            pb_decode.h\n            pb_decode.c)\n        set_target_properties(protobuf-nanopb-static PROPERTIES\n            OUTPUT_NAME protobuf-nanopb)\n        install(TARGETS protobuf-nanopb-static EXPORT nanopb-targets\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})\n        target_include_directories(protobuf-nanopb-static INTERFACE\n            $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/nanopb>\n            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n        )\n    endif()\n\n    configure_file(extra/nanopb-config-version.cmake.in\n        nanopb-config-version.cmake @ONLY)\n\n    install(EXPORT nanopb-targets\n        DESTINATION ${CMAKE_INSTALL_CMAKEDIR}\n        NAMESPACE nanopb::)\n\n    install(FILES extra/nanopb-config.cmake\n        ${CMAKE_CURRENT_BINARY_DIR}/nanopb-config-version.cmake\n        DESTINATION ${CMAKE_INSTALL_CMAKEDIR})\n\n    install(FILES pb.h pb_common.h pb_encode.h pb_decode.h\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/nanopb)\nendif()\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.1982421875,
          "content": "Contributing to Nanopb development\n==================================\n\nReporting issues and requesting features\n----------------------------------------\n\nFeel free to report any issues you see or features you would like\nto see in the future to the Github issue tracker. Using the templates\nbelow is preferred:\n\n* [Report a bug](https://github.com/nanopb/nanopb/issues/new?body=**Steps%20to%20reproduce%20the%20issue**%0a%0a1.%0a2.%0a3.%0a%0a**What%20happens?**%0A%0A**What%20should%20happen?**&labels=Type-Defect)\n* [Request a feature](https://github.com/nanopb/nanopb/issues/new?body=**What%20should%20the%20feature%20do?**%0A%0A**In%20what%20situation%20would%20the%20feature%20be%20useful?**&labels=Type-Enhancement)\n\nRequesting help\n---------------\n\nIf there is something strange going on, but you do not know if\nit is actually a bug in nanopb, try asking first on the\n[discussion forum](https://groups.google.com/forum/#!forum/nanopb).\n\nPull requests\n-------------\n\nPull requests are welcome!\n\nIf it is not obvious from the commit message, please indicate the\nsame information as you would for an issue report:\n\n* What functionality it fixes/adds.\n* How can the problem be reproduced / when would the feature be useful.\n\n\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 0.876953125,
          "content": "Copyright (c) 2011 Petteri Aimonen <jpa at nanopb.mail.kapsi.fi>\n\nThis software is provided 'as-is', without any express or \nimplied warranty. In no event will the authors be held liable \nfor any damages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any \npurpose, including commercial applications, and to alter it and \nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you \n   must not claim that you wrote the original software. If you use \n   this software in a product, an acknowledgment in the product \n   documentation would be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and \n   must not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source \n   distribution.\n"
        },
        {
          "name": "MODULE.bazel",
          "type": "blob",
          "size": 0.8515625,
          "content": "module(\n    name = \"nanopb\",\n    version = \"0.4.9\",\n)\n\nbazel_dep(name = \"bazel_skylib\", version = \"1.7.1\")\nbazel_dep(name = \"rules_cc\", version = \"0.0.10\")\nbazel_dep(name = \"rules_python\", version = \"0.35.0\")\nbazel_dep(name = \"rules_proto\", version = \"6.0.2\")\nbazel_dep(name = \"protobuf\", version = \"28.2\")\nbazel_dep(name = \"rules_proto_grpc\", version = \"5.0.0\")\n\npip = use_extension(\"@rules_python//python/extensions:pip.bzl\", \"pip\")\n\npython = use_extension(\"@rules_python//python/extensions:python.bzl\", \"python\")\n\nPYTHON_VERSION = \"3.11\"\n\n# No need for this since rules_python already creates our version.\n# python.toolchain(python_version = PYTHON_VERSION)\nuse_repo(python, \"python_versions\")\n\nuse_repo(pip, \"nanopb_pypi\")\npip.parse(\n    hub_name = \"nanopb_pypi\",\n    python_version = PYTHON_VERSION,\n    requirements_lock = \"@nanopb//:extra/requirements_lock.txt\",\n)\n"
        },
        {
          "name": "MODULE.bazel.lock",
          "type": "blob",
          "size": 14.0205078125,
          "content": "{\n  \"lockFileVersion\": 11,\n  \"registryFileHashes\": {\n    \"https://bcr.bazel.build/bazel_registry.json\": \"8a28e4aff06ee60aed2a8c281907fb8bcbf3b753c91fb5a5c57da3215d5b3497\",\n    \"https://bcr.bazel.build/modules/abseil-cpp/20210324.2/MODULE.bazel\": \"7cd0312e064fde87c8d1cd79ba06c876bd23630c83466e9500321be55c96ace2\",\n    \"https://bcr.bazel.build/modules/abseil-cpp/20211102.0/MODULE.bazel\": \"70390338f7a5106231d20620712f7cccb659cd0e9d073d1991c038eb9fc57589\",\n    \"https://bcr.bazel.build/modules/abseil-cpp/20230125.1/MODULE.bazel\": \"89047429cb0207707b2dface14ba7f8df85273d484c2572755be4bab7ce9c3a0\",\n    \"https://bcr.bazel.build/modules/abseil-cpp/20230802.0.bcr.1/MODULE.bazel\": \"1c8cec495288dccd14fdae6e3f95f772c1c91857047a098fad772034264cc8cb\",\n    \"https://bcr.bazel.build/modules/abseil-cpp/20230802.0.bcr.1/source.json\": \"14892cc698e02ffedf4967546e6bedb7245015906888d3465fcf27c90a26da10\",\n    \"https://bcr.bazel.build/modules/apple_support/1.5.0/MODULE.bazel\": \"50341a62efbc483e8a2a6aec30994a58749bd7b885e18dd96aa8c33031e558ef\",\n    \"https://bcr.bazel.build/modules/apple_support/1.5.0/source.json\": \"eb98a7627c0bc486b57f598ad8da50f6625d974c8f723e9ea71bd39f709c9862\",\n    \"https://bcr.bazel.build/modules/bazel_features/1.11.0/MODULE.bazel\": \"f9382337dd5a474c3b7d334c2f83e50b6eaedc284253334cf823044a26de03e8\",\n    \"https://bcr.bazel.build/modules/bazel_features/1.11.0/source.json\": \"c9320aa53cd1c441d24bd6b716da087ad7e4ff0d9742a9884587596edfe53015\",\n    \"https://bcr.bazel.build/modules/bazel_features/1.4.1/MODULE.bazel\": \"e45b6bb2350aff3e442ae1111c555e27eac1d915e77775f6fdc4b351b758b5d7\",\n    \"https://bcr.bazel.build/modules/bazel_features/1.9.0/MODULE.bazel\": \"885151d58d90d8d9c811eb75e3288c11f850e1d6b481a8c9f766adee4712358b\",\n    \"https://bcr.bazel.build/modules/bazel_features/1.9.1/MODULE.bazel\": \"8f679097876a9b609ad1f60249c49d68bfab783dd9be012faf9d82547b14815a\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.0.3/MODULE.bazel\": \"bcb0fd896384802d1ad283b4e4eb4d718eebd8cb820b0a2c3a347fb971afd9d8\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.2.0/MODULE.bazel\": \"44fe84260e454ed94ad326352a698422dbe372b21a1ac9f3eab76eb531223686\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.2.1/MODULE.bazel\": \"f35baf9da0efe45fa3da1696ae906eea3d615ad41e2e3def4aeb4e8bc0ef9a7a\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.3.0/MODULE.bazel\": \"20228b92868bf5cfc41bda7afc8a8ba2a543201851de39d990ec957b513579c5\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.4.1/MODULE.bazel\": \"a0dcb779424be33100dcae821e9e27e4f2901d9dfd5333efe5ac6a8d7ab75e1d\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.5.0/MODULE.bazel\": \"32880f5e2945ce6a03d1fbd588e9198c0a959bb42297b2cfaf1685b7bc32e138\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.6.1/MODULE.bazel\": \"8fdee2dbaace6c252131c00e1de4b165dc65af02ea278476187765e1a617b917\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.7.1/MODULE.bazel\": \"3120d80c5861aa616222ec015332e5f8d3171e062e3e804a2a0253e1be26e59b\",\n    \"https://bcr.bazel.build/modules/bazel_skylib/1.7.1/source.json\": \"f121b43eeefc7c29efbd51b83d08631e2347297c95aac9764a701f2a6a2bb953\",\n    \"https://bcr.bazel.build/modules/buildozer/7.1.2/MODULE.bazel\": \"2e8dd40ede9c454042645fd8d8d0cd1527966aa5c919de86661e62953cd73d84\",\n    \"https://bcr.bazel.build/modules/buildozer/7.1.2/source.json\": \"c9028a501d2db85793a6996205c8de120944f50a0d570438fcae0457a5f9d1f8\",\n    \"https://bcr.bazel.build/modules/googletest/1.11.0/MODULE.bazel\": \"3a83f095183f66345ca86aa13c58b59f9f94a2f81999c093d4eeaa2d262d12f4\",\n    \"https://bcr.bazel.build/modules/googletest/1.14.0/MODULE.bazel\": \"cfbcbf3e6eac06ef9d85900f64424708cc08687d1b527f0ef65aa7517af8118f\",\n    \"https://bcr.bazel.build/modules/googletest/1.14.0/source.json\": \"2478949479000fdd7de9a3d0107ba2c85bb5f961c3ecb1aa448f52549ce310b5\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.10/MODULE.bazel\": \"8cb8efaf200bdeb2150d93e162c40f388529a25852b332cec879373771e48ed5\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.10/source.json\": \"f22828ff4cf021a6b577f1bf6341cb9dcd7965092a439f64fc1bb3b7a5ae4bd5\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.4/MODULE.bazel\": \"9b328e31ee156f53f3c416a64f8491f7eb731742655a47c9eec4703a71644aee\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.5/MODULE.bazel\": \"5733b54ea419d5eaf7997054bb55f6a1d0b5ff8aedf0176fef9eea44f3acda37\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.6/MODULE.bazel\": \"ad6eeef431dc52aefd2d77ed20a4b353f8ebf0f4ecdd26a807d2da5aa8cd0615\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.7/MODULE.bazel\": \"72fd4a0ede9ee5c021f6a8dd92b503e089f46c227ba2813ff183b71616034814\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.8/MODULE.bazel\": \"9f142c03e348f6d263719f5074b21ef3adf0b139ee4c5133e2aa35664da9eb2d\",\n    \"https://bcr.bazel.build/modules/platforms/0.0.9/MODULE.bazel\": \"4a87a60c927b56ddd67db50c89acaa62f4ce2a1d2149ccb63ffd871d5ce29ebc\",\n    \"https://bcr.bazel.build/modules/protobuf/21.7/MODULE.bazel\": \"a5a29bb89544f9b97edce05642fac225a808b5b7be74038ea3640fae2f8e66a7\",\n    \"https://bcr.bazel.build/modules/protobuf/23.1/MODULE.bazel\": \"88b393b3eb4101d18129e5db51847cd40a5517a53e81216144a8c32dfeeca52a\",\n    \"https://bcr.bazel.build/modules/protobuf/24.4/MODULE.bazel\": \"7bc7ce5f2abf36b3b7b7c8218d3acdebb9426aeb35c2257c96445756f970eb12\",\n    \"https://bcr.bazel.build/modules/protobuf/24.4/source.json\": \"ace4b8c65d4cfe64efe544f09fc5e5df77faf3a67fbb29c5341e0d755d9b15d6\",\n    \"https://bcr.bazel.build/modules/protobuf/3.19.0/MODULE.bazel\": \"6b5fbb433f760a99a22b18b6850ed5784ef0e9928a72668b66e4d7ccd47db9b0\",\n    \"https://bcr.bazel.build/modules/protobuf/3.19.6/MODULE.bazel\": \"9233edc5e1f2ee276a60de3eaa47ac4132302ef9643238f23128fea53ea12858\",\n    \"https://bcr.bazel.build/modules/rules_cc/0.0.1/MODULE.bazel\": \"cb2aa0747f84c6c3a78dad4e2049c154f08ab9d166b1273835a8174940365647\",\n    \"https://bcr.bazel.build/modules/rules_cc/0.0.2/MODULE.bazel\": \"6915987c90970493ab97393024c156ea8fb9f3bea953b2f3ec05c34f19b5695c\",\n    \"https://bcr.bazel.build/modules/rules_cc/0.0.6/MODULE.bazel\": \"abf360251023dfe3efcef65ab9d56beefa8394d4176dd29529750e1c57eaa33f\",\n    \"https://bcr.bazel.build/modules/rules_cc/0.0.8/MODULE.bazel\": \"964c85c82cfeb6f3855e6a07054fdb159aced38e99a5eecf7bce9d53990afa3e\",\n    \"https://bcr.bazel.build/modules/rules_cc/0.0.9/MODULE.bazel\": \"836e76439f354b89afe6a911a7adf59a6b2518fafb174483ad78a2a2fde7b1c5\",\n    \"https://bcr.bazel.build/modules/rules_cc/0.0.9/source.json\": \"1f1ba6fea244b616de4a554a0f4983c91a9301640c8fe0dd1d410254115c8430\",\n    \"https://bcr.bazel.build/modules/rules_java/4.0.0/MODULE.bazel\": \"5a78a7ae82cd1a33cef56dc578c7d2a46ed0dca12643ee45edbb8417899e6f74\",\n    \"https://bcr.bazel.build/modules/rules_java/7.1.0/MODULE.bazel\": \"30d9135a2b6561c761bd67bd4990da591e6bdc128790ce3e7afd6a3558b2fb64\",\n    \"https://bcr.bazel.build/modules/rules_java/7.6.1/MODULE.bazel\": \"2f14b7e8a1aa2f67ae92bc69d1ec0fa8d9f827c4e17ff5e5f02e91caa3b2d0fe\",\n    \"https://bcr.bazel.build/modules/rules_java/7.6.1/source.json\": \"8f3f3076554e1558e8e468b2232991c510ecbcbed9e6f8c06ac31c93bcf38362\",\n    \"https://bcr.bazel.build/modules/rules_jvm_external/4.4.2/MODULE.bazel\": \"a56b85e418c83eb1839819f0b515c431010160383306d13ec21959ac412d2fe7\",\n    \"https://bcr.bazel.build/modules/rules_jvm_external/5.1/MODULE.bazel\": \"33f6f999e03183f7d088c9be518a63467dfd0be94a11d0055fe2d210f89aa909\",\n    \"https://bcr.bazel.build/modules/rules_jvm_external/5.1/source.json\": \"5abb45cc9beb27b77aec6a65a11855ef2b55d95dfdc358e9f312b78ae0ba32d5\",\n    \"https://bcr.bazel.build/modules/rules_license/0.0.3/MODULE.bazel\": \"627e9ab0247f7d1e05736b59dbb1b6871373de5ad31c3011880b4133cafd4bd0\",\n    \"https://bcr.bazel.build/modules/rules_license/0.0.7/MODULE.bazel\": \"088fbeb0b6a419005b89cf93fe62d9517c0a2b8bb56af3244af65ecfe37e7d5d\",\n    \"https://bcr.bazel.build/modules/rules_license/0.0.7/source.json\": \"355cc5737a0f294e560d52b1b7a6492d4fff2caf0bef1a315df5a298fca2d34a\",\n    \"https://bcr.bazel.build/modules/rules_pkg/0.7.0/MODULE.bazel\": \"df99f03fc7934a4737122518bb87e667e62d780b610910f0447665a7e2be62dc\",\n    \"https://bcr.bazel.build/modules/rules_pkg/0.7.0/source.json\": \"c2557066e0c0342223ba592510ad3d812d4963b9024831f7f66fd0584dd8c66c\",\n    \"https://bcr.bazel.build/modules/rules_proto/4.0.0/MODULE.bazel\": \"a7a7b6ce9bee418c1a760b3d84f83a299ad6952f9903c67f19e4edd964894e06\",\n    \"https://bcr.bazel.build/modules/rules_proto/5.3.0-21.7/MODULE.bazel\": \"e8dff86b0971688790ae75528fe1813f71809b5afd57facb44dad9e8eca631b7\",\n    \"https://bcr.bazel.build/modules/rules_proto/6.0.0-rc1/MODULE.bazel\": \"1e5b502e2e1a9e825eef74476a5a1ee524a92297085015a052510b09a1a09483\",\n    \"https://bcr.bazel.build/modules/rules_proto/6.0.0/MODULE.bazel\": \"b531d7f09f58dce456cd61b4579ce8c86b38544da75184eadaf0a7cb7966453f\",\n    \"https://bcr.bazel.build/modules/rules_proto/6.0.2/MODULE.bazel\": \"ce916b775a62b90b61888052a416ccdda405212b6aaeb39522f7dc53431a5e73\",\n    \"https://bcr.bazel.build/modules/rules_proto/6.0.2/source.json\": \"17a2e195f56cb28d6bbf763e49973d13890487c6945311ed141e196fb660426d\",\n    \"https://bcr.bazel.build/modules/rules_proto_grpc/5.0.0/MODULE.bazel\": \"aad0151be788911f9736f413c423342d781a9dc19f35d3373c8581c828a387f4\",\n    \"https://bcr.bazel.build/modules/rules_proto_grpc/5.0.0/source.json\": \"f35378dee74074450e6bb0755febb17879bddb705fe57270a213c8ee9c658a46\",\n    \"https://bcr.bazel.build/modules/rules_python/0.10.2/MODULE.bazel\": \"cc82bc96f2997baa545ab3ce73f196d040ffb8756fd2d66125a530031cd90e5f\",\n    \"https://bcr.bazel.build/modules/rules_python/0.22.1/MODULE.bazel\": \"26114f0c0b5e93018c0c066d6673f1a2c3737c7e90af95eff30cfee38d0bbac7\",\n    \"https://bcr.bazel.build/modules/rules_python/0.34.0/MODULE.bazel\": \"1d623d026e075b78c9fde483a889cda7996f5da4f36dffb24c246ab30f06513a\",\n    \"https://bcr.bazel.build/modules/rules_python/0.34.0/source.json\": \"113116e287eec64a7d005a9db44865d810499fdc4f621e352aff58214f5ea2d8\",\n    \"https://bcr.bazel.build/modules/rules_python/0.4.0/MODULE.bazel\": \"9208ee05fd48bf09ac60ed269791cf17fb343db56c8226a720fbb1cdf467166c\",\n    \"https://bcr.bazel.build/modules/stardoc/0.5.1/MODULE.bazel\": \"1a05d92974d0c122f5ccf09291442580317cdd859f07a8655f1db9a60374f9f8\",\n    \"https://bcr.bazel.build/modules/stardoc/0.5.3/MODULE.bazel\": \"c7f6948dae6999bf0db32c1858ae345f112cacf98f174c7a8bb707e41b974f1c\",\n    \"https://bcr.bazel.build/modules/stardoc/0.5.3/source.json\": \"cd53fe968dc8cd98197c052db3db6d82562960c87b61e7a90ee96f8e4e0dda97\",\n    \"https://bcr.bazel.build/modules/toolchains_protoc/0.3.1/MODULE.bazel\": \"b6574a2a314cbd40cafb5ed87b03d1996e015315f80a7e33116c8b2e209cb5cf\",\n    \"https://bcr.bazel.build/modules/toolchains_protoc/0.3.1/source.json\": \"b589ee1faec4c789c680afa9d500b5ccbea25422560b8b9dc4e0e6b26471f13b\",\n    \"https://bcr.bazel.build/modules/upb/0.0.0-20220923-a547704/MODULE.bazel\": \"7298990c00040a0e2f121f6c32544bab27d4452f80d9ce51349b1a28f3005c43\",\n    \"https://bcr.bazel.build/modules/upb/0.0.0-20230516-61a97ef/MODULE.bazel\": \"c0df5e35ad55e264160417fd0875932ee3c9dda63d9fccace35ac62f45e1b6f9\",\n    \"https://bcr.bazel.build/modules/upb/0.0.0-20230516-61a97ef/source.json\": \"b2150404947339e8b947c6b16baa39fa75657f4ddec5e37272c7b11c7ab533bc\",\n    \"https://bcr.bazel.build/modules/zlib/1.2.11/MODULE.bazel\": \"07b389abc85fdbca459b69e2ec656ae5622873af3f845e1c9d80fe179f3effa0\",\n    \"https://bcr.bazel.build/modules/zlib/1.2.12/MODULE.bazel\": \"3b1a8834ada2a883674be8cbd36ede1b6ec481477ada359cd2d3ddc562340b27\",\n    \"https://bcr.bazel.build/modules/zlib/1.3/MODULE.bazel\": \"6a9c02f19a24dcedb05572b2381446e27c272cd383aed11d41d99da9e3167a72\",\n    \"https://bcr.bazel.build/modules/zlib/1.3/source.json\": \"b6b43d0737af846022636e6e255fd4a96fee0d34f08f3830e6e0bac51465c37c\"\n  },\n  \"selectedYankedVersions\": {},\n  \"moduleExtensions\": {\n    \"@@apple_support~//crosstool:setup.bzl%apple_cc_configure_extension\": {\n      \"general\": {\n        \"bzlTransitiveDigest\": \"PjIds3feoYE8SGbbIq2SFTZy3zmxeO2tQevJZNDo7iY=\",\n        \"usagesDigest\": \"aLmqbvowmHkkBPve05yyDNGN7oh7QE9kBADr3QIZTZs=\",\n        \"recordedFileInputs\": {},\n        \"recordedDirentsInputs\": {},\n        \"envVariables\": {},\n        \"generatedRepoSpecs\": {\n          \"local_config_apple_cc\": {\n            \"bzlFile\": \"@@apple_support~//crosstool:setup.bzl\",\n            \"ruleClassName\": \"_apple_cc_autoconf\",\n            \"attributes\": {}\n          },\n          \"local_config_apple_cc_toolchains\": {\n            \"bzlFile\": \"@@apple_support~//crosstool:setup.bzl\",\n            \"ruleClassName\": \"_apple_cc_autoconf_toolchains\",\n            \"attributes\": {}\n          }\n        },\n        \"recordedRepoMappingEntries\": [\n          [\n            \"apple_support~\",\n            \"bazel_tools\",\n            \"bazel_tools\"\n          ]\n        ]\n      }\n    },\n    \"@@platforms//host:extension.bzl%host_platform\": {\n      \"general\": {\n        \"bzlTransitiveDigest\": \"xelQcPZH8+tmuOHVjL9vDxMnnQNMlwj0SlvgoqBkm4U=\",\n        \"usagesDigest\": \"V1R2Y2oMxKNfx2WCWpSCaUV1WefW1o8HZGm3v1vHgY4=\",\n        \"recordedFileInputs\": {},\n        \"recordedDirentsInputs\": {},\n        \"envVariables\": {},\n        \"generatedRepoSpecs\": {\n          \"host_platform\": {\n            \"bzlFile\": \"@@platforms//host:extension.bzl\",\n            \"ruleClassName\": \"host_platform_repo\",\n            \"attributes\": {}\n          }\n        },\n        \"recordedRepoMappingEntries\": []\n      }\n    },\n    \"@@protobuf~//:non_module_deps.bzl%non_module_deps\": {\n      \"general\": {\n        \"bzlTransitiveDigest\": \"jsbfONl9OksDWiAs7KDFK5chH/tYI3DngdM30NKdk5Y=\",\n        \"usagesDigest\": \"eVrT3hFCIZNRuTKpfWDzSIwTi2p6U6PWbt+tNWl/Tqk=\",\n        \"recordedFileInputs\": {},\n        \"recordedDirentsInputs\": {},\n        \"envVariables\": {},\n        \"generatedRepoSpecs\": {\n          \"utf8_range\": {\n            \"bzlFile\": \"@@bazel_tools//tools/build_defs/repo:http.bzl\",\n            \"ruleClassName\": \"http_archive\",\n            \"attributes\": {\n              \"urls\": [\n                \"https://github.com/protocolbuffers/utf8_range/archive/de0b4a8ff9b5d4c98108bdfe723291a33c52c54f.zip\"\n              ],\n              \"strip_prefix\": \"utf8_range-de0b4a8ff9b5d4c98108bdfe723291a33c52c54f\",\n              \"sha256\": \"5da960e5e5d92394c809629a03af3c7709d2d3d0ca731dacb3a9fb4bf28f7702\"\n            }\n          }\n        },\n        \"recordedRepoMappingEntries\": [\n          [\n            \"protobuf~\",\n            \"bazel_tools\",\n            \"bazel_tools\"\n          ]\n        ]\n      }\n    }\n  }\n}\n"
        },
        {
          "name": "Package.swift",
          "type": "blob",
          "size": 1.4365234375,
          "content": "// swift-tools-version:5.3\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n  name: \"nanopb\",\n  products: [\n    .library(\n      name: \"nanopb\",\n      targets: [\"nanopb\"]\n    )\n  ],\n\n  targets: [\n    .target(\n      name: \"nanopb\",\n      path: \".\",\n      sources: [\n        \"pb.h\",\n        \"pb_common.h\",\n        \"pb_common.c\",\n        \"pb_decode.h\",\n        \"pb_decode.c\",\n        \"pb_encode.h\",\n        \"pb_encode.c\"\n      ],\n      resources: [.process(\"spm_resources/PrivacyInfo.xcprivacy\")],\n      publicHeadersPath: \"spm_headers\",\n      cSettings: [\n        .define(\"PB_FIELD_32BIT\", to: \"1\"),\n        .define(\"PB_NO_PACKED_STRUCTS\", to: \"1\"),\n        .define(\"PB_ENABLE_MALLOC\", to: \"1\"),\n      ]\n    ),\n    .testTarget(\n      name: \"swift-test\",\n      dependencies: [\n        \"nanopb\",\n      ],\n      path: \"spm-test/swift\",\n      cSettings: [\n        .headerSearchPath(\"../\"),\n        .define(\"PB_FIELD_32BIT\", to: \"1\"),\n        .define(\"PB_NO_PACKED_STRUCTS\", to: \"1\"),\n        .define(\"PB_ENABLE_MALLOC\", to: \"1\"),\n      ]\n    ),\n    .testTarget(\n      name: \"objc-test\",\n      dependencies: [\n        \"nanopb\",\n      ],\n      path: \"spm-test/objc\",\n      cSettings: [\n        .headerSearchPath(\"../\"),\n        .define(\"PB_FIELD_32BIT\", to: \"1\"),\n        .define(\"PB_NO_PACKED_STRUCTS\", to: \"1\"),\n        .define(\"PB_ENABLE_MALLOC\", to: \"1\"),\n      ]\n    )\n  ]\n)\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.3603515625,
          "content": "Nanopb - Protocol Buffers for Embedded Systems\n==============================================\n\n![Latest change](https://github.com/nanopb/nanopb/actions/workflows/trigger_on_code_change.yml/badge.svg)\n![Weekly build](https://github.com/nanopb/nanopb/actions/workflows/trigger_on_schedule.yml/badge.svg)\n\nNanopb is a small code-size Protocol Buffers implementation in ansi C. It is\nespecially suitable for use in microcontrollers, but fits any memory\nrestricted system.\n\n* **Homepage:** https://jpa.kapsi.fi/nanopb/\n* **Git repository:** https://github.com/nanopb/nanopb/\n* **Documentation:** https://jpa.kapsi.fi/nanopb/docs/\n* **Forum:** https://groups.google.com/forum/#!forum/nanopb\n* **Stable version downloads:** https://jpa.kapsi.fi/nanopb/download/\n* **Pre-release binary packages:** https://github.com/nanopb/nanopb/actions/workflows/binary_packages.yml\n\n\nUsing the nanopb library\n------------------------\nTo use the nanopb library, you need to do two things:\n\n1. Compile your .proto files for nanopb, using `protoc`.\n2. Include *pb_encode.c*, *pb_decode.c* and *pb_common.c* in your project.\n\nThe easiest way to get started is to study the project in \"examples/simple\".\nIt contains a Makefile, which should work directly under most Linux systems.\nHowever, for any other kind of build system, see the manual steps in\nREADME.txt in that folder.\n\n\nGenerating the headers\n----------------------\nProtocol Buffers messages are defined in a `.proto` file, which follows a standard\nformat that is compatible with all Protocol Buffers libraries. To use it with nanopb,\nyou need to generate `.pb.c` and `.pb.h` files from it:\n\n    python generator/nanopb_generator.py myprotocol.proto  # For source checkout\n    generator-bin/nanopb_generator myprotocol.proto        # For binary package\n\n(Note: For instructions for nanopb-0.3.9.x and older, see the documentation\nof that particular version [here](https://github.com/nanopb/nanopb/blob/maintenance_0.3/README.md))\n\nThe binary packages for Windows, Linux and Mac OS X should contain all necessary\ndependencies, including Python, python-protobuf library and protoc. If you are\nusing a git checkout or a plain source distribution, you will need to install\nPython separately. Once you have Python, you can install the other dependencies\nwith `pip install --upgrade protobuf grpcio-tools`.\n\nYou can further customize the header generation by creating an `.options` file.\nSee [documentation](https://jpa.kapsi.fi/nanopb/docs/concepts.html#modifying-generator-behaviour) for details.\n\n\nRunning the tests\n-----------------\nIf you want to perform further development of the nanopb core, or to verify\nits functionality using your compiler and platform, you'll want to run the\ntest suite. The build rules for the test suite are implemented using Scons,\nso you need to have that installed (ex: `sudo apt install scons` or `pip install scons`).\nTo run the tests:\n\n    cd tests\n    scons\n\nThis will show the progress of various test cases. If the output does not\nend in an error, the test cases were successful.\n\nNote: Mac OS X by default aliases 'clang' as 'gcc', while not actually\nsupporting the same command line options as gcc does. To run tests on\nMac OS X, use: `scons CC=clang CXX=clang++`. Same way can be used to run\ntests with different compilers on any platform.\n\nFor embedded platforms, there is currently support for running the tests\non STM32 discovery board and [simavr](https://github.com/buserror/simavr)\nAVR simulator. Use `scons PLATFORM=STM32` and `scons PLATFORM=AVR` to run\nthese tests.\n\n\nBuild systems and integration\n-----------------------------\nNanopb C code itself is designed to be portable and easy to build\non any platform. Often the bigger hurdle is running the generator which\ntakes in the `.proto` files and outputs `.pb.c` definitions.\n\nThere exist build rules for several systems:\n\n* **Makefiles**: `extra/nanopb.mk`, see `examples/simple`\n* **CMake**: `extra/FindNanopb.cmake`, see `examples/cmake`\n* **SCons**: `tests/site_scons` (generator only)\n* **Bazel**: `BUILD.bazel` in source root\n* **Conan**: `conanfile.py` in source root\n* **PlatformIO**: https://platformio.org/lib/show/431/Nanopb\n* **PyPI/pip**: https://pypi.org/project/nanopb/\n* **vcpkg**: https://vcpkg.io/en/package/nanopb\n\nAnd also integration to platform interfaces:\n\n* **Arduino**: http://platformio.org/lib/show/1385/nanopb-arduino\n* **Zephyr**: https://docs.zephyrproject.org/latest/services/serialization/nanopb.html\n\n"
        },
        {
          "name": "WORKSPACE",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "build-tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.py",
          "type": "blob",
          "size": 0.2001953125,
          "content": "from conan.packager import ConanMultiPackager\n\nif __name__ == \"__main__\":\n    builder = ConanMultiPackager(build_policy=\"outdated\")\n    builder.add_common_builds(shared_option_name=None)\n    builder.run()\n"
        },
        {
          "name": "conan-wrapper",
          "type": "tree",
          "content": null
        },
        {
          "name": "conanfile.py",
          "type": "blob",
          "size": 0.947265625,
          "content": "from conans import ConanFile, CMake, tools\nfrom os import path\n\nclass NanoPbConan(ConanFile):\n    name = \"nanopb\"\n    version = \"1.0.0-dev\"\n    license = \"zlib\"\n    url = \"https://jpa.kapsi.fi/nanopb/\"\n    description = \"Protocol Buffers with small code size\"\n    settings = \"os_build\", \"compiler\", \"build_type\", \"arch\"\n    generators = \"cmake\"\n    exports = '*'\n    options = {\n        \"fPIC\": [True, False],\n    }\n    default_options = {\n        \"fPIC\": True,\n    }\n\n    def configure(self):\n        if self.settings.os_build == \"Windows\" and self.settings.compiler == \"Visual Studio\":\n            del self.options.fPIC\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure(source_folder=path.join(self.source_folder, \"conan-wrapper\"))\n        cmake.build()\n        cmake.install()\n\n    def package_info(self):\n        self.cpp_info.includedirs = [\"include\"]\n        self.cpp_info.libdirs = [\"lib\"]\n        self.cpp_info.libs = [\"protobuf-nanopb\"]\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "generator",
          "type": "tree",
          "content": null
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 1.0712890625,
          "content": "{\n  \"name\": \"Nanopb\",\n  \"version\": \"0.4.9\",\n  \"keywords\": \"protocol buffers, protobuf, google\",\n  \"description\": \"Nanopb is a plain-C implementation of Google's Protocol Buffers data format. It is targeted at 32 bit microcontrollers, but is also fit for other embedded systems with tight (<10 kB ROM, <1 kB RAM) memory constraints.\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/nanopb/nanopb.git\"\n  },\n  \"authors\": [{\n    \"name\": \"Petteri Aimonen\",\n    \"email\": \"jpa@nanopb.mail.kapsi.fi\",\n    \"url\": \"http://koti.kapsi.fi/jpa/nanopb/\"\n  }],\n  \"export\": {\n    \"include\": [\n      \"*.c\",\n      \"*.cpp\",\n      \"*.h\",\n      \"examples\",\n      \"generator\"\n    ],\n    \"exclude\": [\n      \"generator/**/__pycache__\",\n      \"examples/platformio/.gitignore\"\n    ]\n  },\n  \"build\": {\n    \"extraScript\": \"generator/platformio_generator.py\",\n    \"includeDir\": \"\",\n    \"srcDir\": \"\",\n    \"srcFilter\": [\n      \"+<*.c>\"\n    ]\n  },\n  \"examples\": [\n    \"examples/platformio/platformio.ini\",\n    \"examples/platformio/src/*.c\",\n    \"examples/*/*.c\"\n  ],\n  \"frameworks\": \"*\",\n  \"platforms\": \"*\"\n}\n"
        },
        {
          "name": "pb.h",
          "type": "blob",
          "size": 43.68359375,
          "content": "/* Common parts of the nanopb library. Most of these are quite low-level\n * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.\n */\n\n#ifndef PB_H_INCLUDED\n#define PB_H_INCLUDED\n\n/*****************************************************************\n * Nanopb compilation time options. You can change these here by *\n * uncommenting the lines, or on the compiler command line.      *\n *****************************************************************/\n\n/* Enable support for dynamically allocated fields */\n/* #define PB_ENABLE_MALLOC 1 */\n\n/* Define this if your CPU / compiler combination does not support\n * unaligned memory access to packed structures. Note that packed\n * structures are only used when requested in .proto options. */\n/* #define PB_NO_PACKED_STRUCTS 1 */\n\n/* Increase the number of required fields that are tracked.\n * A compiler warning will tell if you need this. */\n/* #define PB_MAX_REQUIRED_FIELDS 256 */\n\n/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */\n/* #define PB_FIELD_32BIT 1 */\n\n/* Disable support for error messages in order to save some code space. */\n/* #define PB_NO_ERRMSG 1 */\n\n/* Disable checks to ensure sub-message encoded size is consistent when re-run. */\n/* #define PB_NO_ENCODE_SIZE_CHECK 1 */\n\n/* Disable support for custom streams (support only memory buffers). */\n/* #define PB_BUFFER_ONLY 1 */\n\n/* Disable support for 64-bit datatypes, for compilers without int64_t\n   or to save some code space. */\n/* #define PB_WITHOUT_64BIT 1 */\n\n/* Don't encode scalar arrays as packed. This is only to be used when\n * the decoder on the receiving side cannot process packed scalar arrays.\n * Such example is older protobuf.js. */\n/* #define PB_ENCODE_ARRAYS_UNPACKED 1 */\n\n/* Enable conversion of doubles to floats for platforms that do not\n * support 64-bit doubles. Most commonly AVR. */\n/* #define PB_CONVERT_DOUBLE_FLOAT 1 */\n\n/* Check whether incoming strings are valid UTF-8 sequences. Slows down\n * the string processing slightly and slightly increases code size. */\n/* #define PB_VALIDATE_UTF8 1 */\n\n/* This can be defined if the platform is little-endian and has 8-bit bytes.\n * Normally it is automatically detected based on __BYTE_ORDER__ macro. */\n/* #define PB_LITTLE_ENDIAN_8BIT 1 */\n\n/* Configure static assert mechanism. Instead of changing these, set your\n * compiler to C11 standard mode if possible. */\n/* #define PB_C99_STATIC_ASSERT 1 */\n/* #define PB_NO_STATIC_ASSERT 1 */\n\n/******************************************************************\n * You usually don't need to change anything below this line.     *\n * Feel free to look around and use the defined macros, though.   *\n ******************************************************************/\n\n\n/* Version of the nanopb library. Just in case you want to check it in\n * your own program. */\n#define NANOPB_VERSION \"nanopb-1.0.0-dev\"\n\n/* Include all the system headers needed by nanopb. You will need the\n * definitions of the following:\n * - strlen, memcpy, memset functions\n * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t\n * - size_t\n * - bool\n *\n * If you don't have the standard header files, you can instead provide\n * a custom header that defines or includes all this. In that case,\n * define PB_SYSTEM_HEADER to the path of this file.\n */\n#ifdef PB_SYSTEM_HEADER\n#include PB_SYSTEM_HEADER\n#else\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n\n#ifdef PB_ENABLE_MALLOC\n#include <stdlib.h>\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Macro for defining packed structures (compiler dependent).\n * This just reduces memory requirements, but is not required.\n */\n#if defined(PB_NO_PACKED_STRUCTS)\n    /* Disable struct packing */\n#   define PB_PACKED_STRUCT_START\n#   define PB_PACKED_STRUCT_END\n#   define pb_packed\n#elif defined(__GNUC__) || defined(__clang__)\n    /* For GCC and clang */\n#   define PB_PACKED_STRUCT_START\n#   define PB_PACKED_STRUCT_END\n#   define pb_packed __attribute__((packed))\n#elif defined(__ICCARM__) || defined(__CC_ARM)\n    /* For IAR ARM and Keil MDK-ARM compilers */\n#   define PB_PACKED_STRUCT_START _Pragma(\"pack(push, 1)\")\n#   define PB_PACKED_STRUCT_END _Pragma(\"pack(pop)\")\n#   define pb_packed\n#elif defined(_MSC_VER) && (_MSC_VER >= 1500)\n    /* For Microsoft Visual C++ */\n#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))\n#   define PB_PACKED_STRUCT_END __pragma(pack(pop))\n#   define pb_packed\n#else\n    /* Unknown compiler */\n#   define PB_PACKED_STRUCT_START\n#   define PB_PACKED_STRUCT_END\n#   define pb_packed\n#endif\n\n/* Define for explicitly not inlining a given function */\n#if defined(__GNUC__) || defined(__clang__)\n    /* For GCC and clang */\n#   define pb_noinline __attribute__((noinline))\n#elif defined(__ICCARM__) || defined(__CC_ARM)\n    /* For IAR ARM and Keil MDK-ARM compilers */\n#   define pb_noinline\n#elif defined(_MSC_VER) && (_MSC_VER >= 1500)\n#   define pb_noinline __declspec(noinline)\n#else\n#   define pb_noinline\n#endif\n\n/* Detect endianness */\n#if !defined(CHAR_BIT) && defined(__CHAR_BIT__)\n#define CHAR_BIT __CHAR_BIT__\n#endif\n\n#ifndef PB_LITTLE_ENDIAN_8BIT\n#if ((defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n     (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \\\n      defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || \\\n      defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || \\\n      defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM)) \\\n     && defined(CHAR_BIT) && CHAR_BIT == 8\n#define PB_LITTLE_ENDIAN_8BIT 1\n#endif\n#endif\n\n/* Handly macro for suppressing unreferenced-parameter compiler warnings. */\n#ifndef PB_UNUSED\n#define PB_UNUSED(x) (void)(x)\n#endif\n\n/* Harvard-architecture processors may need special attributes for storing\n * field information in program memory. */\n#ifndef PB_PROGMEM\n#ifdef __AVR__\n#include <avr/pgmspace.h>\n#define PB_PROGMEM             PROGMEM\n#define PB_PROGMEM_READU32(x)  pgm_read_dword(&x)\n#else\n#define PB_PROGMEM\n#define PB_PROGMEM_READU32(x)  (x)\n#endif\n#endif\n\n/* Compile-time assertion, used for checking compatible compilation options.\n * If this does not work properly on your compiler, use\n * #define PB_NO_STATIC_ASSERT to disable it.\n *\n * But before doing that, check carefully the error message / place where it\n * comes from to see if the error has a real cause. Unfortunately the error\n * message is not always very clear to read, but you can see the reason better\n * in the place where the PB_STATIC_ASSERT macro was called.\n */\n#ifndef PB_NO_STATIC_ASSERT\n#  ifndef PB_STATIC_ASSERT\n#    if defined(__ICCARM__)\n       /* IAR has static_assert keyword but no _Static_assert */\n#      define PB_STATIC_ASSERT(COND,MSG) static_assert(COND,#MSG);\n#    elif defined(_MSC_VER) && (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 201112)\n       /* MSVC in C89 mode supports static_assert() keyword anyway */\n#      define PB_STATIC_ASSERT(COND,MSG) static_assert(COND,#MSG);\n#    elif defined(PB_C99_STATIC_ASSERT)\n       /* Classic negative-size-array static assert mechanism */\n#      define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];\n#      define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)\n#      define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##_##LINE##_##COUNTER\n#    elif defined(__cplusplus)\n       /* C++11 standard static_assert mechanism */\n#      define PB_STATIC_ASSERT(COND,MSG) static_assert(COND,#MSG);\n#    else\n       /* C11 standard _Static_assert mechanism */\n#      define PB_STATIC_ASSERT(COND,MSG) _Static_assert(COND,#MSG);\n#    endif\n#  endif\n#else\n   /* Static asserts disabled by PB_NO_STATIC_ASSERT */\n#  define PB_STATIC_ASSERT(COND,MSG)\n#endif\n\n/* Test that PB_STATIC_ASSERT works\n * If you get errors here, you may need to do one of these:\n * - Enable C11 standard support in your compiler\n * - Define PB_C99_STATIC_ASSERT to enable C99 standard support\n * - Define PB_NO_STATIC_ASSERT to disable static asserts altogether\n */\nPB_STATIC_ASSERT(1, STATIC_ASSERT_IS_NOT_WORKING)\n\n/* Number of required fields to keep track of. */\n#ifndef PB_MAX_REQUIRED_FIELDS\n#define PB_MAX_REQUIRED_FIELDS 64\n#endif\n\n#if PB_MAX_REQUIRED_FIELDS < 64\n#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n/* Cannot use doubles without 64-bit types */\n#undef PB_CONVERT_DOUBLE_FLOAT\n#endif\n#endif\n\n/* Data type for storing encoded data and other byte streams.\n * This typedef exists to support platforms where uint8_t does not exist.\n * You can regard it as equivalent on uint8_t on other platforms.\n */\n#if defined(PB_BYTE_T_OVERRIDE)\ntypedef PB_BYTE_T_OVERRIDE pb_byte_t;\n#elif defined(UINT8_MAX)\ntypedef uint8_t pb_byte_t;\n#else\ntypedef uint_least8_t pb_byte_t;\n#endif\n\n/* List of possible field types. These are used in the autogenerated code.\n * Least-significant 4 bits tell the scalar type\n * Most-significant 4 bits specify repeated/required/packed etc.\n */\ntypedef pb_byte_t pb_type_t;\n\n/**** Field data types ****/\n\n/* Numeric types */\n#define PB_LTYPE_BOOL    0x00U /* bool */\n#define PB_LTYPE_VARINT  0x01U /* int32, int64, enum, bool */\n#define PB_LTYPE_UVARINT 0x02U /* uint32, uint64 */\n#define PB_LTYPE_SVARINT 0x03U /* sint32, sint64 */\n#define PB_LTYPE_FIXED32 0x04U /* fixed32, sfixed32, float */\n#define PB_LTYPE_FIXED64 0x05U /* fixed64, sfixed64, double */\n\n/* Marker for last packable field type. */\n#define PB_LTYPE_LAST_PACKABLE 0x05U\n\n/* Byte array with pre-allocated buffer.\n * data_size is the length of the allocated PB_BYTES_ARRAY structure. */\n#define PB_LTYPE_BYTES 0x06U\n\n/* String with pre-allocated buffer.\n * data_size is the maximum length. */\n#define PB_LTYPE_STRING 0x07U\n\n/* Submessage\n * submsg_fields is pointer to field descriptions */\n#define PB_LTYPE_SUBMESSAGE 0x08U\n\n/* Submessage with pre-decoding callback\n * The pre-decoding callback is stored as pb_callback_t right before pSize.\n * submsg_fields is pointer to field descriptions */\n#define PB_LTYPE_SUBMSG_W_CB 0x09U\n\n/* Extension pseudo-field\n * The field contains a pointer to pb_extension_t */\n#define PB_LTYPE_EXTENSION 0x0AU\n\n/* Byte array with inline, pre-allocated byffer.\n * data_size is the length of the inline, allocated buffer.\n * This differs from PB_LTYPE_BYTES by defining the element as\n * pb_byte_t[data_size] rather than pb_bytes_array_t. */\n#define PB_LTYPE_FIXED_LENGTH_BYTES 0x0BU\n\n/* Number of declared LTYPES */\n#define PB_LTYPES_COUNT 0x0CU\n#define PB_LTYPE_MASK 0x0FU\n\n/**** Field repetition rules ****/\n\n#define PB_HTYPE_REQUIRED 0x00U\n#define PB_HTYPE_OPTIONAL 0x10U\n#define PB_HTYPE_SINGULAR 0x10U\n#define PB_HTYPE_REPEATED 0x20U\n#define PB_HTYPE_FIXARRAY 0x20U\n#define PB_HTYPE_ONEOF    0x30U\n#define PB_HTYPE_MASK     0x30U\n\n/**** Field allocation types ****/\n\n#define PB_ATYPE_STATIC   0x00U\n#define PB_ATYPE_POINTER  0x80U\n#define PB_ATYPE_CALLBACK 0x40U\n#define PB_ATYPE_MASK     0xC0U\n\n#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)\n#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)\n#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)\n#define PB_LTYPE_IS_SUBMSG(x) (PB_LTYPE(x) == PB_LTYPE_SUBMESSAGE || \\\n                               PB_LTYPE(x) == PB_LTYPE_SUBMSG_W_CB)\n\n/* Data type used for storing sizes of struct fields\n * and array counts.\n */\n#if defined(PB_FIELD_32BIT)\n    typedef uint32_t pb_size_t;\n    typedef int32_t pb_ssize_t;\n#else\n    typedef uint_least16_t pb_size_t;\n    typedef int_least16_t pb_ssize_t;\n#endif\n#define PB_SIZE_MAX ((pb_size_t)-1)\n\n/* Forward declaration of struct types */\ntypedef struct pb_istream_s pb_istream_t;\ntypedef struct pb_ostream_s pb_ostream_t;\ntypedef struct pb_field_iter_s pb_field_iter_t;\n\n/* This structure is used in auto-generated constants\n * to specify struct fields.\n */\ntypedef struct pb_msgdesc_s pb_msgdesc_t;\nstruct pb_msgdesc_s {\n    const uint32_t *field_info;\n    const pb_msgdesc_t * const * submsg_info;\n    const pb_byte_t *default_value;\n\n    bool (*field_callback)(pb_istream_t *istream, pb_ostream_t *ostream, const pb_field_iter_t *field);\n\n    pb_size_t field_count;\n    pb_size_t required_field_count;\n    pb_size_t largest_tag;\n};\n\n/* Iterator for message descriptor */\nstruct pb_field_iter_s {\n    const pb_msgdesc_t *descriptor;  /* Pointer to message descriptor constant */\n    void *message;                   /* Pointer to start of the structure */\n\n    pb_size_t index;                 /* Index of the field */\n    pb_size_t field_info_index;      /* Index to descriptor->field_info array */\n    pb_size_t required_field_index;  /* Index that counts only the required fields */\n    pb_size_t submessage_index;      /* Index that counts only submessages */\n\n    pb_size_t tag;                   /* Tag of current field */\n    pb_size_t data_size;             /* sizeof() of a single item */\n    pb_size_t array_size;            /* Number of array entries */\n    pb_type_t type;                  /* Type of current field */\n\n    void *pField;                    /* Pointer to current field in struct */\n    void *pData;                     /* Pointer to current data contents. Different than pField for arrays and pointers. */\n    void *pSize;                     /* Pointer to count/has field */\n\n    const pb_msgdesc_t *submsg_desc; /* For submessage fields, pointer to field descriptor for the submessage. */\n};\n\n/* For compatibility with legacy code */\ntypedef pb_field_iter_t pb_field_t;\n\n/* Make sure that the standard integer types are of the expected sizes.\n * Otherwise fixed32/fixed64 fields can break.\n *\n * If you get errors here, it probably means that your stdint.h is not\n * correct for your platform.\n */\n#ifndef PB_WITHOUT_64BIT\nPB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)\nPB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)\n#endif\n\n/* This structure is used for 'bytes' arrays.\n * It has the number of bytes in the beginning, and after that an array.\n * Note that actual structs used will have a different length of bytes array.\n */\n#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }\n#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))\n\nstruct pb_bytes_array_s {\n    pb_size_t size;\n    pb_byte_t bytes[1];\n};\ntypedef struct pb_bytes_array_s pb_bytes_array_t;\n\n/* This structure is used for giving the callback function.\n * It is stored in the message structure and filled in by the method that\n * calls pb_decode.\n *\n * The decoding callback will be given a limited-length stream\n * If the wire type was string, the length is the length of the string.\n * If the wire type was a varint/fixed32/fixed64, the length is the length\n * of the actual value.\n * The function may be called multiple times (especially for repeated types,\n * but also otherwise if the message happens to contain the field multiple\n * times.)\n *\n * The encoding callback will receive the actual output stream.\n * It should write all the data in one call, including the field tag and\n * wire type. It can write multiple fields.\n *\n * The callback can be null if you want to skip a field.\n */\ntypedef struct pb_callback_s pb_callback_t;\nstruct pb_callback_s {\n    /* Callback functions receive a pointer to the arg field.\n     * You can access the value of the field as *arg, and modify it if needed.\n     */\n    union {\n        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);\n        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);\n    } funcs;\n\n    /* Free arg for use by callback */\n    void *arg;\n};\n\nextern bool pb_default_field_callback(pb_istream_t *istream, pb_ostream_t *ostream, const pb_field_t *field);\n\n/* Wire types. Library user needs these only in encoder callbacks. */\ntypedef enum {\n    PB_WT_VARINT = 0,\n    PB_WT_64BIT  = 1,\n    PB_WT_STRING = 2,\n    PB_WT_32BIT  = 5,\n    PB_WT_PACKED = 255 /* PB_WT_PACKED is internal marker for packed arrays. */\n} pb_wire_type_t;\n\n/* Structure for defining the handling of unknown/extension fields.\n * Usually the pb_extension_type_t structure is automatically generated,\n * while the pb_extension_t structure is created by the user. However,\n * if you want to catch all unknown fields, you can also create a custom\n * pb_extension_type_t with your own callback.\n */\ntypedef struct pb_extension_type_s pb_extension_type_t;\ntypedef struct pb_extension_s pb_extension_t;\nstruct pb_extension_type_s {\n    /* Called for each unknown field in the message.\n     * If you handle the field, read off all of its data and return true.\n     * If you do not handle the field, do not read anything and return true.\n     * If you run into an error, return false.\n     * Set to NULL for default handler.\n     */\n    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,\n                   uint32_t tag, pb_wire_type_t wire_type);\n\n    /* Called once after all regular fields have been encoded.\n     * If you have something to write, do so and return true.\n     * If you do not have anything to write, just return true.\n     * If you run into an error, return false.\n     * Set to NULL for default handler.\n     */\n    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);\n\n    /* Free field for use by the callback. */\n    const void *arg;\n};\n\nstruct pb_extension_s {\n    /* Type describing the extension field. Usually you'll initialize\n     * this to a pointer to the automatically generated structure. */\n    const pb_extension_type_t *type;\n\n    /* Destination for the decoded data. This must match the datatype\n     * of the extension field. */\n    void *dest;\n\n    /* Pointer to the next extension handler, or NULL.\n     * If this extension does not match a field, the next handler is\n     * automatically called. */\n    pb_extension_t *next;\n\n    /* The decoder sets this to true if the extension was found.\n     * Ignored for encoding. */\n    bool found;\n};\n\n#define pb_extension_init_zero {NULL,NULL,NULL,false}\n\n/* Memory allocation functions to use. You can define pb_realloc and\n * pb_free to custom functions if you want. */\n#ifdef PB_ENABLE_MALLOC\n#   ifndef pb_realloc\n#       define pb_realloc(ptr, size) realloc(ptr, size)\n#   endif\n#   ifndef pb_free\n#       define pb_free(ptr) free(ptr)\n#   endif\n#endif\n\n/* This is used to inform about need to regenerate .pb.h/.pb.c files. */\n#define PB_PROTO_HEADER_VERSION 40\n\n/* These macros are used to declare pb_field_t's in the constant array. */\n/* Size of a structure member, in bytes. */\n#define pb_membersize(st, m) (sizeof ((st*)0)->m)\n/* Number of entries in an array. */\n#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))\n/* Delta from start of one member to the start of another member. */\n#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))\n\n/* Force expansion of macro value */\n#define PB_EXPAND(x) x\n\n/* Binding of a message field set into a specific structure */\n#define PB_BIND(msgname, structname, width) \\\n    const uint32_t structname ## _field_info[] PB_PROGMEM = \\\n    { \\\n        msgname ## _FIELDLIST(PB_GEN_FIELD_INFO_ ## width, structname) \\\n        0 \\\n    }; \\\n    const pb_msgdesc_t* const structname ## _submsg_info[] = \\\n    { \\\n        msgname ## _FIELDLIST(PB_GEN_SUBMSG_INFO, structname) \\\n        NULL \\\n    }; \\\n    const pb_msgdesc_t structname ## _msg = \\\n    { \\\n       structname ## _field_info, \\\n       structname ## _submsg_info, \\\n       msgname ## _DEFAULT, \\\n       msgname ## _CALLBACK, \\\n       0 msgname ## _FIELDLIST(PB_GEN_FIELD_COUNT, structname), \\\n       0 msgname ## _FIELDLIST(PB_GEN_REQ_FIELD_COUNT, structname), \\\n       0 msgname ## _FIELDLIST(PB_GEN_LARGEST_TAG, structname), \\\n    }; \\\n    msgname ## _FIELDLIST(PB_GEN_FIELD_INFO_ASSERT_ ## width, structname)\n\n#define PB_GEN_FIELD_COUNT(structname, atype, htype, ltype, fieldname, tag) +1\n#define PB_GEN_REQ_FIELD_COUNT(structname, atype, htype, ltype, fieldname, tag) \\\n    + (PB_HTYPE_ ## htype == PB_HTYPE_REQUIRED)\n#define PB_GEN_LARGEST_TAG(structname, atype, htype, ltype, fieldname, tag) \\\n    * 0 + tag\n\n/* X-macro for generating the entries in struct_field_info[] array. */\n#define PB_GEN_FIELD_INFO_1(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_1(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_2(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_2(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_4(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_4(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_8(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_8(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_AUTO(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_AUTO2(PB_FIELDINFO_WIDTH_AUTO(_PB_ATYPE_ ## atype, _PB_HTYPE_ ## htype, _PB_LTYPE_ ## ltype), \\\n                   tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_FIELDINFO_AUTO2(width, tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_FIELDINFO_AUTO3(width, tag, type, data_offset, data_size, size_offset, array_size)\n\n#define PB_FIELDINFO_AUTO3(width, tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_FIELDINFO_ ## width(tag, type, data_offset, data_size, size_offset, array_size)\n\n/* X-macro for generating asserts that entries fit in struct_field_info[] array.\n * The structure of macros here must match the structure above in PB_GEN_FIELD_INFO_x(),\n * but it is not easily reused because of how macro substitutions work. */\n#define PB_GEN_FIELD_INFO_ASSERT_1(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_ASSERT_1(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_ASSERT_2(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_ASSERT_2(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_ASSERT_4(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_ASSERT_4(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_ASSERT_8(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_ASSERT_8(tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_GEN_FIELD_INFO_ASSERT_AUTO(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_FIELDINFO_ASSERT_AUTO2(PB_FIELDINFO_WIDTH_AUTO(_PB_ATYPE_ ## atype, _PB_HTYPE_ ## htype, _PB_LTYPE_ ## ltype), \\\n                   tag, PB_ATYPE_ ## atype | PB_HTYPE_ ## htype | PB_LTYPE_MAP_ ## ltype, \\\n                   PB_DATA_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_DATA_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_SIZE_OFFSET_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname), \\\n                   PB_ARRAY_SIZE_ ## atype(_PB_HTYPE_ ## htype, structname, fieldname))\n\n#define PB_FIELDINFO_ASSERT_AUTO2(width, tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_FIELDINFO_ASSERT_AUTO3(width, tag, type, data_offset, data_size, size_offset, array_size)\n\n#define PB_FIELDINFO_ASSERT_AUTO3(width, tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_FIELDINFO_ASSERT_ ## width(tag, type, data_offset, data_size, size_offset, array_size)\n\n#define PB_DATA_OFFSET_STATIC(htype, structname, fieldname) PB_DO ## htype(structname, fieldname)\n#define PB_DATA_OFFSET_POINTER(htype, structname, fieldname) PB_DO ## htype(structname, fieldname)\n#define PB_DATA_OFFSET_CALLBACK(htype, structname, fieldname) PB_DO ## htype(structname, fieldname)\n#define PB_DO_PB_HTYPE_REQUIRED(structname, fieldname) offsetof(structname, fieldname)\n#define PB_DO_PB_HTYPE_SINGULAR(structname, fieldname) offsetof(structname, fieldname)\n#define PB_DO_PB_HTYPE_ONEOF(structname, fieldname) offsetof(structname, PB_ONEOF_NAME(FULL, fieldname))\n#define PB_DO_PB_HTYPE_OPTIONAL(structname, fieldname) offsetof(structname, fieldname)\n#define PB_DO_PB_HTYPE_REPEATED(structname, fieldname) offsetof(structname, fieldname)\n#define PB_DO_PB_HTYPE_FIXARRAY(structname, fieldname) offsetof(structname, fieldname)\n\n#define PB_SIZE_OFFSET_STATIC(htype, structname, fieldname) PB_SO ## htype(structname, fieldname)\n#define PB_SIZE_OFFSET_POINTER(htype, structname, fieldname) PB_SO_PTR ## htype(structname, fieldname)\n#define PB_SIZE_OFFSET_CALLBACK(htype, structname, fieldname) PB_SO_CB ## htype(structname, fieldname)\n#define PB_SO_PB_HTYPE_REQUIRED(structname, fieldname) 0\n#define PB_SO_PB_HTYPE_SINGULAR(structname, fieldname) 0\n#define PB_SO_PB_HTYPE_ONEOF(structname, fieldname) PB_SO_PB_HTYPE_ONEOF2(structname, PB_ONEOF_NAME(FULL, fieldname), PB_ONEOF_NAME(UNION, fieldname))\n#define PB_SO_PB_HTYPE_ONEOF2(structname, fullname, unionname) PB_SO_PB_HTYPE_ONEOF3(structname, fullname, unionname)\n#define PB_SO_PB_HTYPE_ONEOF3(structname, fullname, unionname) pb_delta(structname, fullname, which_ ## unionname)\n#define PB_SO_PB_HTYPE_OPTIONAL(structname, fieldname) pb_delta(structname, fieldname, has_ ## fieldname)\n#define PB_SO_PB_HTYPE_REPEATED(structname, fieldname) pb_delta(structname, fieldname, fieldname ## _count)\n#define PB_SO_PB_HTYPE_FIXARRAY(structname, fieldname) 0\n#define PB_SO_PTR_PB_HTYPE_REQUIRED(structname, fieldname) 0\n#define PB_SO_PTR_PB_HTYPE_SINGULAR(structname, fieldname) 0\n#define PB_SO_PTR_PB_HTYPE_ONEOF(structname, fieldname) PB_SO_PB_HTYPE_ONEOF(structname, fieldname)\n#define PB_SO_PTR_PB_HTYPE_OPTIONAL(structname, fieldname) 0\n#define PB_SO_PTR_PB_HTYPE_REPEATED(structname, fieldname) PB_SO_PB_HTYPE_REPEATED(structname, fieldname)\n#define PB_SO_PTR_PB_HTYPE_FIXARRAY(structname, fieldname) 0\n#define PB_SO_CB_PB_HTYPE_REQUIRED(structname, fieldname) 0\n#define PB_SO_CB_PB_HTYPE_SINGULAR(structname, fieldname) 0\n#define PB_SO_CB_PB_HTYPE_ONEOF(structname, fieldname) PB_SO_PB_HTYPE_ONEOF(structname, fieldname)\n#define PB_SO_CB_PB_HTYPE_OPTIONAL(structname, fieldname) 0\n#define PB_SO_CB_PB_HTYPE_REPEATED(structname, fieldname) 0\n#define PB_SO_CB_PB_HTYPE_FIXARRAY(structname, fieldname) 0\n\n#define PB_ARRAY_SIZE_STATIC(htype, structname, fieldname) PB_AS ## htype(structname, fieldname)\n#define PB_ARRAY_SIZE_POINTER(htype, structname, fieldname) PB_AS_PTR ## htype(structname, fieldname)\n#define PB_ARRAY_SIZE_CALLBACK(htype, structname, fieldname) 1\n#define PB_AS_PB_HTYPE_REQUIRED(structname, fieldname) 1\n#define PB_AS_PB_HTYPE_SINGULAR(structname, fieldname) 1\n#define PB_AS_PB_HTYPE_OPTIONAL(structname, fieldname) 1\n#define PB_AS_PB_HTYPE_ONEOF(structname, fieldname) 1\n#define PB_AS_PB_HTYPE_REPEATED(structname, fieldname) pb_arraysize(structname, fieldname)\n#define PB_AS_PB_HTYPE_FIXARRAY(structname, fieldname) pb_arraysize(structname, fieldname)\n#define PB_AS_PTR_PB_HTYPE_REQUIRED(structname, fieldname) 1\n#define PB_AS_PTR_PB_HTYPE_SINGULAR(structname, fieldname) 1\n#define PB_AS_PTR_PB_HTYPE_OPTIONAL(structname, fieldname) 1\n#define PB_AS_PTR_PB_HTYPE_ONEOF(structname, fieldname) 1\n#define PB_AS_PTR_PB_HTYPE_REPEATED(structname, fieldname) 1\n#define PB_AS_PTR_PB_HTYPE_FIXARRAY(structname, fieldname) pb_arraysize(structname, fieldname[0])\n\n#define PB_DATA_SIZE_STATIC(htype, structname, fieldname) PB_DS ## htype(structname, fieldname)\n#define PB_DATA_SIZE_POINTER(htype, structname, fieldname) PB_DS_PTR ## htype(structname, fieldname)\n#define PB_DATA_SIZE_CALLBACK(htype, structname, fieldname) PB_DS_CB ## htype(structname, fieldname)\n#define PB_DS_PB_HTYPE_REQUIRED(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_PB_HTYPE_SINGULAR(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_PB_HTYPE_OPTIONAL(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_PB_HTYPE_ONEOF(structname, fieldname) pb_membersize(structname, PB_ONEOF_NAME(FULL, fieldname))\n#define PB_DS_PB_HTYPE_REPEATED(structname, fieldname) pb_membersize(structname, fieldname[0])\n#define PB_DS_PB_HTYPE_FIXARRAY(structname, fieldname) pb_membersize(structname, fieldname[0])\n#define PB_DS_PTR_PB_HTYPE_REQUIRED(structname, fieldname) pb_membersize(structname, fieldname[0])\n#define PB_DS_PTR_PB_HTYPE_SINGULAR(structname, fieldname) pb_membersize(structname, fieldname[0])\n#define PB_DS_PTR_PB_HTYPE_OPTIONAL(structname, fieldname) pb_membersize(structname, fieldname[0])\n#define PB_DS_PTR_PB_HTYPE_ONEOF(structname, fieldname) pb_membersize(structname, PB_ONEOF_NAME(FULL, fieldname)[0])\n#define PB_DS_PTR_PB_HTYPE_REPEATED(structname, fieldname) pb_membersize(structname, fieldname[0])\n#define PB_DS_PTR_PB_HTYPE_FIXARRAY(structname, fieldname) pb_membersize(structname, fieldname[0][0])\n#define PB_DS_CB_PB_HTYPE_REQUIRED(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_CB_PB_HTYPE_SINGULAR(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_CB_PB_HTYPE_OPTIONAL(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_CB_PB_HTYPE_ONEOF(structname, fieldname) pb_membersize(structname, PB_ONEOF_NAME(FULL, fieldname))\n#define PB_DS_CB_PB_HTYPE_REPEATED(structname, fieldname) pb_membersize(structname, fieldname)\n#define PB_DS_CB_PB_HTYPE_FIXARRAY(structname, fieldname) pb_membersize(structname, fieldname)\n\n#define PB_ONEOF_NAME(type, tuple) PB_EXPAND(PB_ONEOF_NAME_ ## type tuple)\n#define PB_ONEOF_NAME_UNION(unionname,membername,fullname) unionname\n#define PB_ONEOF_NAME_MEMBER(unionname,membername,fullname) membername\n#define PB_ONEOF_NAME_FULL(unionname,membername,fullname) fullname\n\n#define PB_GEN_SUBMSG_INFO(structname, atype, htype, ltype, fieldname, tag) \\\n    PB_SUBMSG_INFO_ ## htype(_PB_LTYPE_ ## ltype, structname, fieldname)\n\n#define PB_SUBMSG_INFO_REQUIRED(ltype, structname, fieldname) PB_SI ## ltype(structname ## _ ## fieldname ## _MSGTYPE)\n#define PB_SUBMSG_INFO_SINGULAR(ltype, structname, fieldname) PB_SI ## ltype(structname ## _ ## fieldname ## _MSGTYPE)\n#define PB_SUBMSG_INFO_OPTIONAL(ltype, structname, fieldname) PB_SI ## ltype(structname ## _ ## fieldname ## _MSGTYPE)\n#define PB_SUBMSG_INFO_ONEOF(ltype, structname, fieldname) PB_SUBMSG_INFO_ONEOF2(ltype, structname, PB_ONEOF_NAME(UNION, fieldname), PB_ONEOF_NAME(MEMBER, fieldname))\n#define PB_SUBMSG_INFO_ONEOF2(ltype, structname, unionname, membername) PB_SUBMSG_INFO_ONEOF3(ltype, structname, unionname, membername)\n#define PB_SUBMSG_INFO_ONEOF3(ltype, structname, unionname, membername) PB_SI ## ltype(structname ## _ ## unionname ## _ ## membername ## _MSGTYPE)\n#define PB_SUBMSG_INFO_REPEATED(ltype, structname, fieldname) PB_SI ## ltype(structname ## _ ## fieldname ## _MSGTYPE)\n#define PB_SUBMSG_INFO_FIXARRAY(ltype, structname, fieldname) PB_SI ## ltype(structname ## _ ## fieldname ## _MSGTYPE)\n#define PB_SI_PB_LTYPE_BOOL(t)\n#define PB_SI_PB_LTYPE_BYTES(t)\n#define PB_SI_PB_LTYPE_DOUBLE(t)\n#define PB_SI_PB_LTYPE_ENUM(t)\n#define PB_SI_PB_LTYPE_UENUM(t)\n#define PB_SI_PB_LTYPE_FIXED32(t)\n#define PB_SI_PB_LTYPE_FIXED64(t)\n#define PB_SI_PB_LTYPE_FLOAT(t)\n#define PB_SI_PB_LTYPE_INT32(t)\n#define PB_SI_PB_LTYPE_INT64(t)\n#define PB_SI_PB_LTYPE_MESSAGE(t)  PB_SUBMSG_DESCRIPTOR(t)\n#define PB_SI_PB_LTYPE_MSG_W_CB(t) PB_SUBMSG_DESCRIPTOR(t)\n#define PB_SI_PB_LTYPE_SFIXED32(t)\n#define PB_SI_PB_LTYPE_SFIXED64(t)\n#define PB_SI_PB_LTYPE_SINT32(t)\n#define PB_SI_PB_LTYPE_SINT64(t)\n#define PB_SI_PB_LTYPE_STRING(t)\n#define PB_SI_PB_LTYPE_UINT32(t)\n#define PB_SI_PB_LTYPE_UINT64(t)\n#define PB_SI_PB_LTYPE_EXTENSION(t)\n#define PB_SI_PB_LTYPE_FIXED_LENGTH_BYTES(t)\n#define PB_SUBMSG_DESCRIPTOR(t)    &(t ## _msg),\n\n/* The field descriptors use a variable width format, with width of either\n * 1, 2, 4 or 8 of 32-bit words. The two lowest bytes of the first byte always\n * encode the descriptor size, 6 lowest bits of field tag number, and 8 bits\n * of the field type.\n *\n * Descriptor size is encoded as 0 = 1 word, 1 = 2 words, 2 = 4 words, 3 = 8 words.\n *\n * Formats, listed starting with the least significant bit of the first word.\n * 1 word:  [2-bit len] [6-bit tag] [8-bit type] [8-bit data_offset] [4-bit size_offset] [4-bit data_size]\n *\n * 2 words: [2-bit len] [6-bit tag] [8-bit type] [12-bit array_size] [4-bit size_offset]\n *          [16-bit data_offset] [12-bit data_size] [4-bit tag>>6]\n *\n * 4 words: [2-bit len] [6-bit tag] [8-bit type] [16-bit array_size]\n *          [8-bit size_offset] [24-bit tag>>6]\n *          [32-bit data_offset]\n *          [32-bit data_size]\n *\n * 8 words: [2-bit len] [6-bit tag] [8-bit type] [16-bit reserved]\n *          [8-bit size_offset] [24-bit tag>>6]\n *          [32-bit data_offset]\n *          [32-bit data_size]\n *          [32-bit array_size]\n *          [32-bit reserved]\n *          [32-bit reserved]\n *          [32-bit reserved]\n */\n\n#define PB_FIELDINFO_1(tag, type, data_offset, data_size, size_offset, array_size) \\\n    (0 | (((tag) << 2) & 0xFF) | ((type) << 8) | (((uint32_t)(data_offset) & 0xFF) << 16) | \\\n     (((uint32_t)(size_offset) & 0x0F) << 24) | (((uint32_t)(data_size) & 0x0F) << 28)),\n\n#define PB_FIELDINFO_2(tag, type, data_offset, data_size, size_offset, array_size) \\\n    (1 | (((tag) << 2) & 0xFF) | ((type) << 8) | (((uint32_t)(array_size) & 0xFFF) << 16) | (((uint32_t)(size_offset) & 0x0F) << 28)), \\\n    (((uint32_t)(data_offset) & 0xFFFF) | (((uint32_t)(data_size) & 0xFFF) << 16) | (((uint32_t)(tag) & 0x3c0) << 22)),\n\n#define PB_FIELDINFO_4(tag, type, data_offset, data_size, size_offset, array_size) \\\n    (2 | (((tag) << 2) & 0xFF) | ((type) << 8) | (((uint32_t)(array_size) & 0xFFFF) << 16)), \\\n    ((uint32_t)(int_least8_t)(size_offset) | (((uint32_t)(tag) << 2) & 0xFFFFFF00)), \\\n    (data_offset), (data_size),\n\n#define PB_FIELDINFO_8(tag, type, data_offset, data_size, size_offset, array_size) \\\n    (3 | (((tag) << 2) & 0xFF) | ((type) << 8)), \\\n    ((uint32_t)(int_least8_t)(size_offset) | (((uint32_t)(tag) << 2) & 0xFFFFFF00)), \\\n    (data_offset), (data_size), (array_size), 0, 0, 0,\n\n/* These assertions verify that the field information fits in the allocated space.\n * The generator tries to automatically determine the correct width that can fit all\n * data associated with a message. These asserts will fail only if there has been a\n * problem in the automatic logic - this may be worth reporting as a bug. As a workaround,\n * you can increase the descriptor width by defining PB_FIELDINFO_WIDTH or by setting\n * descriptorsize option in .options file.\n */\n#define PB_FITS(value,bits) ((uint32_t)(value) < ((uint32_t)1<<bits))\n#define PB_FIELDINFO_ASSERT_1(tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_STATIC_ASSERT(PB_FITS(tag,6) && PB_FITS(data_offset,8) && PB_FITS(size_offset,4) && PB_FITS(data_size,4) && PB_FITS(array_size,1), FIELDINFO_DOES_NOT_FIT_width1_field ## tag)\n\n#define PB_FIELDINFO_ASSERT_2(tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_STATIC_ASSERT(PB_FITS(tag,10) && PB_FITS(data_offset,16) && PB_FITS(size_offset,4) && PB_FITS(data_size,12) && PB_FITS(array_size,12), FIELDINFO_DOES_NOT_FIT_width2_field ## tag)\n\n#ifndef PB_FIELD_32BIT\n/* Maximum field sizes are still 16-bit if pb_size_t is 16-bit */\n#define PB_FIELDINFO_ASSERT_4(tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_STATIC_ASSERT(PB_FITS(tag,16) && PB_FITS(data_offset,16) && PB_FITS((int_least8_t)size_offset,8) && PB_FITS(data_size,16) && PB_FITS(array_size,16), FIELDINFO_DOES_NOT_FIT_width4_field ## tag)\n\n#define PB_FIELDINFO_ASSERT_8(tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_STATIC_ASSERT(PB_FITS(tag,16) && PB_FITS(data_offset,16) && PB_FITS((int_least8_t)size_offset,8) && PB_FITS(data_size,16) && PB_FITS(array_size,16), FIELDINFO_DOES_NOT_FIT_width8_field ## tag)\n#else\n/* Up to 32-bit fields supported.\n * Note that the checks are against 31 bits to avoid compiler warnings about shift wider than type in the test.\n * I expect that there is no reasonable use for >2GB messages with nanopb anyway.\n */\n#define PB_FIELDINFO_ASSERT_4(tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_STATIC_ASSERT(PB_FITS(tag,30) && PB_FITS(data_offset,31) && PB_FITS(size_offset,8) && PB_FITS(data_size,31) && PB_FITS(array_size,16), FIELDINFO_DOES_NOT_FIT_width4_field ## tag)\n\n#define PB_FIELDINFO_ASSERT_8(tag, type, data_offset, data_size, size_offset, array_size) \\\n    PB_STATIC_ASSERT(PB_FITS(tag,30) && PB_FITS(data_offset,31) && PB_FITS(size_offset,8) && PB_FITS(data_size,31) && PB_FITS(array_size,31), FIELDINFO_DOES_NOT_FIT_width8_field ## tag)\n#endif\n\n\n/* Automatic picking of FIELDINFO width:\n * Uses width 1 when possible, otherwise resorts to width 2.\n * This is used when PB_BIND() is called with \"AUTO\" as the argument.\n * The generator will give explicit size argument when it knows that a message\n * structure grows beyond 1-word format limits.\n */\n#define PB_FIELDINFO_WIDTH_AUTO(atype, htype, ltype) PB_FI_WIDTH ## atype(htype, ltype)\n#define PB_FI_WIDTH_PB_ATYPE_STATIC(htype, ltype) PB_FI_WIDTH ## htype(ltype)\n#define PB_FI_WIDTH_PB_ATYPE_POINTER(htype, ltype) PB_FI_WIDTH ## htype(ltype)\n#define PB_FI_WIDTH_PB_ATYPE_CALLBACK(htype, ltype) 2\n#define PB_FI_WIDTH_PB_HTYPE_REQUIRED(ltype) PB_FI_WIDTH ## ltype\n#define PB_FI_WIDTH_PB_HTYPE_SINGULAR(ltype) PB_FI_WIDTH ## ltype\n#define PB_FI_WIDTH_PB_HTYPE_OPTIONAL(ltype) PB_FI_WIDTH ## ltype\n#define PB_FI_WIDTH_PB_HTYPE_ONEOF(ltype) PB_FI_WIDTH ## ltype\n#define PB_FI_WIDTH_PB_HTYPE_REPEATED(ltype) 2\n#define PB_FI_WIDTH_PB_HTYPE_FIXARRAY(ltype) 2\n#define PB_FI_WIDTH_PB_LTYPE_BOOL      1\n#define PB_FI_WIDTH_PB_LTYPE_BYTES     2\n#define PB_FI_WIDTH_PB_LTYPE_DOUBLE    1\n#define PB_FI_WIDTH_PB_LTYPE_ENUM      1\n#define PB_FI_WIDTH_PB_LTYPE_UENUM     1\n#define PB_FI_WIDTH_PB_LTYPE_FIXED32   1\n#define PB_FI_WIDTH_PB_LTYPE_FIXED64   1\n#define PB_FI_WIDTH_PB_LTYPE_FLOAT     1\n#define PB_FI_WIDTH_PB_LTYPE_INT32     1\n#define PB_FI_WIDTH_PB_LTYPE_INT64     1\n#define PB_FI_WIDTH_PB_LTYPE_MESSAGE   2\n#define PB_FI_WIDTH_PB_LTYPE_MSG_W_CB  2\n#define PB_FI_WIDTH_PB_LTYPE_SFIXED32  1\n#define PB_FI_WIDTH_PB_LTYPE_SFIXED64  1\n#define PB_FI_WIDTH_PB_LTYPE_SINT32    1\n#define PB_FI_WIDTH_PB_LTYPE_SINT64    1\n#define PB_FI_WIDTH_PB_LTYPE_STRING    2\n#define PB_FI_WIDTH_PB_LTYPE_UINT32    1\n#define PB_FI_WIDTH_PB_LTYPE_UINT64    1\n#define PB_FI_WIDTH_PB_LTYPE_EXTENSION 1\n#define PB_FI_WIDTH_PB_LTYPE_FIXED_LENGTH_BYTES 2\n\n/* The mapping from protobuf types to LTYPEs is done using these macros. */\n#define PB_LTYPE_MAP_BOOL               PB_LTYPE_BOOL\n#define PB_LTYPE_MAP_BYTES              PB_LTYPE_BYTES\n#define PB_LTYPE_MAP_DOUBLE             PB_LTYPE_FIXED64\n#define PB_LTYPE_MAP_ENUM               PB_LTYPE_VARINT\n#define PB_LTYPE_MAP_UENUM              PB_LTYPE_UVARINT\n#define PB_LTYPE_MAP_FIXED32            PB_LTYPE_FIXED32\n#define PB_LTYPE_MAP_FIXED64            PB_LTYPE_FIXED64\n#define PB_LTYPE_MAP_FLOAT              PB_LTYPE_FIXED32\n#define PB_LTYPE_MAP_INT32              PB_LTYPE_VARINT\n#define PB_LTYPE_MAP_INT64              PB_LTYPE_VARINT\n#define PB_LTYPE_MAP_MESSAGE            PB_LTYPE_SUBMESSAGE\n#define PB_LTYPE_MAP_MSG_W_CB           PB_LTYPE_SUBMSG_W_CB\n#define PB_LTYPE_MAP_SFIXED32           PB_LTYPE_FIXED32\n#define PB_LTYPE_MAP_SFIXED64           PB_LTYPE_FIXED64\n#define PB_LTYPE_MAP_SINT32             PB_LTYPE_SVARINT\n#define PB_LTYPE_MAP_SINT64             PB_LTYPE_SVARINT\n#define PB_LTYPE_MAP_STRING             PB_LTYPE_STRING\n#define PB_LTYPE_MAP_UINT32             PB_LTYPE_UVARINT\n#define PB_LTYPE_MAP_UINT64             PB_LTYPE_UVARINT\n#define PB_LTYPE_MAP_EXTENSION          PB_LTYPE_EXTENSION\n#define PB_LTYPE_MAP_FIXED_LENGTH_BYTES PB_LTYPE_FIXED_LENGTH_BYTES\n\n/* These macros are used for giving out error messages.\n * They are mostly a debugging aid; the main error information\n * is the true/false return value from functions.\n * Some code space can be saved by disabling the error\n * messages if not used.\n *\n * PB_SET_ERROR() sets the error message if none has been set yet.\n *                msg must be a constant string literal.\n * PB_GET_ERROR() always returns a pointer to a string.\n * PB_RETURN_ERROR() sets the error and returns false from current\n *                   function.\n */\n#ifdef PB_NO_ERRMSG\n#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)\n#define PB_GET_ERROR(stream) \"(errmsg disabled)\"\n#else\n#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))\n#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : \"(none)\")\n#endif\n\n#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#ifdef __cplusplus\n#if __cplusplus >= 201103L\n#define PB_CONSTEXPR constexpr\n#else  // __cplusplus >= 201103L\n#define PB_CONSTEXPR\n#endif  // __cplusplus >= 201103L\n\n#if __cplusplus >= 201703L\n#define PB_INLINE_CONSTEXPR inline constexpr\n#else  // __cplusplus >= 201703L\n#define PB_INLINE_CONSTEXPR PB_CONSTEXPR\n#endif  // __cplusplus >= 201703L\n\nextern \"C++\"\n{\nnamespace nanopb {\n// Each type will be partially specialized by the generator.\ntemplate <typename GenMessageT> struct MessageDescriptor;\n}  // namespace nanopb\n}\n#endif  /* __cplusplus */\n\n#endif\n"
        },
        {
          "name": "pb_common.c",
          "type": "blob",
          "size": 11.8564453125,
          "content": "/* pb_common.c: Common support functions for pb_encode.c and pb_decode.c.\n *\n * 2014 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n#include \"pb_common.h\"\n\nstatic bool load_descriptor_values(pb_field_iter_t *iter)\n{\n    uint32_t word0;\n    uint32_t data_offset;\n    int_least8_t size_offset;\n\n    if (iter->index >= iter->descriptor->field_count)\n        return false;\n\n    word0 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index]);\n    iter->type = (pb_type_t)((word0 >> 8) & 0xFF);\n\n    switch(word0 & 3)\n    {\n        case 0: {\n            /* 1-word format */\n            iter->array_size = 1;\n            iter->tag = (pb_size_t)((word0 >> 2) & 0x3F);\n            size_offset = (int_least8_t)((word0 >> 24) & 0x0F);\n            data_offset = (word0 >> 16) & 0xFF;\n            iter->data_size = (pb_size_t)((word0 >> 28) & 0x0F);\n            break;\n        }\n\n        case 1: {\n            /* 2-word format */\n            uint32_t word1 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 1]);\n\n            iter->array_size = (pb_size_t)((word0 >> 16) & 0x0FFF);\n            iter->tag = (pb_size_t)(((word0 >> 2) & 0x3F) | ((word1 >> 28) << 6));\n            size_offset = (int_least8_t)((word0 >> 28) & 0x0F);\n            data_offset = word1 & 0xFFFF;\n            iter->data_size = (pb_size_t)((word1 >> 16) & 0x0FFF);\n            break;\n        }\n\n        case 2: {\n            /* 4-word format */\n            uint32_t word1 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 1]);\n            uint32_t word2 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 2]);\n            uint32_t word3 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 3]);\n\n            iter->array_size = (pb_size_t)(word0 >> 16);\n            iter->tag = (pb_size_t)(((word0 >> 2) & 0x3F) | ((word1 >> 8) << 6));\n            size_offset = (int_least8_t)(word1 & 0xFF);\n            data_offset = word2;\n            iter->data_size = (pb_size_t)word3;\n            break;\n        }\n\n        default: {\n            /* 8-word format */\n            uint32_t word1 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 1]);\n            uint32_t word2 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 2]);\n            uint32_t word3 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 3]);\n            uint32_t word4 = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index + 4]);\n\n            iter->array_size = (pb_size_t)word4;\n            iter->tag = (pb_size_t)(((word0 >> 2) & 0x3F) | ((word1 >> 8) << 6));\n            size_offset = (int_least8_t)(word1 & 0xFF);\n            data_offset = word2;\n            iter->data_size = (pb_size_t)word3;\n            break;\n        }\n    }\n\n    if (!iter->message)\n    {\n        /* Avoid doing arithmetic on null pointers, it is undefined */\n        iter->pField = NULL;\n        iter->pSize = NULL;\n    }\n    else\n    {\n        iter->pField = (char*)iter->message + data_offset;\n\n        if (size_offset)\n        {\n            iter->pSize = (char*)iter->pField - size_offset;\n        }\n        else if (PB_HTYPE(iter->type) == PB_HTYPE_REPEATED &&\n                 (PB_ATYPE(iter->type) == PB_ATYPE_STATIC ||\n                  PB_ATYPE(iter->type) == PB_ATYPE_POINTER))\n        {\n            /* Fixed count array */\n            iter->pSize = &iter->array_size;\n        }\n        else\n        {\n            iter->pSize = NULL;\n        }\n\n        if (PB_ATYPE(iter->type) == PB_ATYPE_POINTER && iter->pField != NULL)\n        {\n            iter->pData = *(void**)iter->pField;\n        }\n        else\n        {\n            iter->pData = iter->pField;\n        }\n    }\n\n    if (PB_LTYPE_IS_SUBMSG(iter->type))\n    {\n        iter->submsg_desc = iter->descriptor->submsg_info[iter->submessage_index];\n    }\n    else\n    {\n        iter->submsg_desc = NULL;\n    }\n\n    return true;\n}\n\nstatic void advance_iterator(pb_field_iter_t *iter)\n{\n    iter->index++;\n\n    if (iter->index >= iter->descriptor->field_count)\n    {\n        /* Restart */\n        iter->index = 0;\n        iter->field_info_index = 0;\n        iter->submessage_index = 0;\n        iter->required_field_index = 0;\n    }\n    else\n    {\n        /* Increment indexes based on previous field type.\n         * All field info formats have the following fields:\n         * - lowest 2 bits tell the amount of words in the descriptor (2^n words)\n         * - bits 2..7 give the lowest bits of tag number.\n         * - bits 8..15 give the field type.\n         */\n        uint32_t prev_descriptor = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index]);\n        pb_type_t prev_type = (prev_descriptor >> 8) & 0xFF;\n        pb_size_t descriptor_len = (pb_size_t)(1 << (prev_descriptor & 3));\n\n        /* Add to fields.\n         * The cast to pb_size_t is needed to avoid -Wconversion warning.\n         * Because the data is is constants from generator, there is no danger of overflow.\n         */\n        iter->field_info_index = (pb_size_t)(iter->field_info_index + descriptor_len);\n        iter->required_field_index = (pb_size_t)(iter->required_field_index + (PB_HTYPE(prev_type) == PB_HTYPE_REQUIRED));\n        iter->submessage_index = (pb_size_t)(iter->submessage_index + PB_LTYPE_IS_SUBMSG(prev_type));\n    }\n}\n\nbool pb_field_iter_begin(pb_field_iter_t *iter, const pb_msgdesc_t *desc, void *message)\n{\n    memset(iter, 0, sizeof(*iter));\n\n    iter->descriptor = desc;\n    iter->message = message;\n\n    return load_descriptor_values(iter);\n}\n\nbool pb_field_iter_begin_extension(pb_field_iter_t *iter, pb_extension_t *extension)\n{\n    const pb_msgdesc_t *msg = (const pb_msgdesc_t*)extension->type->arg;\n    bool status;\n\n    uint32_t word0 = PB_PROGMEM_READU32(msg->field_info[0]);\n    if (PB_ATYPE(word0 >> 8) == PB_ATYPE_POINTER)\n    {\n        /* For pointer extensions, the pointer is stored directly\n         * in the extension structure. This avoids having an extra\n         * indirection. */\n        status = pb_field_iter_begin(iter, msg, &extension->dest);\n    }\n    else\n    {\n        status = pb_field_iter_begin(iter, msg, extension->dest);\n    }\n\n    iter->pSize = &extension->found;\n    return status;\n}\n\nbool pb_field_iter_next(pb_field_iter_t *iter)\n{\n    advance_iterator(iter);\n    (void)load_descriptor_values(iter);\n    return iter->index != 0;\n}\n\nbool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag)\n{\n    if (iter->tag == tag)\n    {\n        return true; /* Nothing to do, correct field already. */\n    }\n    else if (tag > iter->descriptor->largest_tag)\n    {\n        return false;\n    }\n    else\n    {\n        pb_size_t start = iter->index;\n        uint32_t fieldinfo;\n\n        if (tag < iter->tag)\n        {\n            /* Fields are in tag number order, so we know that tag is between\n             * 0 and our start position. Setting index to end forces\n             * advance_iterator() call below to restart from beginning. */\n            iter->index = iter->descriptor->field_count;\n        }\n\n        do\n        {\n            /* Advance iterator but don't load values yet */\n            advance_iterator(iter);\n\n            /* Do fast check for tag number match */\n            fieldinfo = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index]);\n\n            if (((fieldinfo >> 2) & 0x3F) == (tag & 0x3F))\n            {\n                /* Good candidate, check further */\n                (void)load_descriptor_values(iter);\n\n                if (iter->tag == tag &&\n                    PB_LTYPE(iter->type) != PB_LTYPE_EXTENSION)\n                {\n                    /* Found it */\n                    return true;\n                }\n            }\n        } while (iter->index != start);\n\n        /* Searched all the way back to start, and found nothing. */\n        (void)load_descriptor_values(iter);\n        return false;\n    }\n}\n\nbool pb_field_iter_find_extension(pb_field_iter_t *iter)\n{\n    if (PB_LTYPE(iter->type) == PB_LTYPE_EXTENSION)\n    {\n        return true;\n    }\n    else\n    {\n        pb_size_t start = iter->index;\n        uint32_t fieldinfo;\n\n        do\n        {\n            /* Advance iterator but don't load values yet */\n            advance_iterator(iter);\n\n            /* Do fast check for field type */\n            fieldinfo = PB_PROGMEM_READU32(iter->descriptor->field_info[iter->field_info_index]);\n\n            if (PB_LTYPE((fieldinfo >> 8) & 0xFF) == PB_LTYPE_EXTENSION)\n            {\n                return load_descriptor_values(iter);\n            }\n        } while (iter->index != start);\n\n        /* Searched all the way back to start, and found nothing. */\n        (void)load_descriptor_values(iter);\n        return false;\n    }\n}\n\nstatic void *pb_const_cast(const void *p)\n{\n    /* Note: this casts away const, in order to use the common field iterator\n     * logic for both encoding and decoding. The cast is done using union\n     * to avoid spurious compiler warnings. */\n    union {\n        void *p1;\n        const void *p2;\n    } t;\n    t.p2 = p;\n    return t.p1;\n}\n\nbool pb_field_iter_begin_const(pb_field_iter_t *iter, const pb_msgdesc_t *desc, const void *message)\n{\n    return pb_field_iter_begin(iter, desc, pb_const_cast(message));\n}\n\nbool pb_field_iter_begin_extension_const(pb_field_iter_t *iter, const pb_extension_t *extension)\n{\n    return pb_field_iter_begin_extension(iter, (pb_extension_t*)pb_const_cast(extension));\n}\n\nbool pb_default_field_callback(pb_istream_t *istream, pb_ostream_t *ostream, const pb_field_t *field)\n{\n    if (field->data_size == sizeof(pb_callback_t))\n    {\n        pb_callback_t *pCallback = (pb_callback_t*)field->pData;\n\n        if (pCallback != NULL)\n        {\n            if (istream != NULL && pCallback->funcs.decode != NULL)\n            {\n                return pCallback->funcs.decode(istream, field, &pCallback->arg);\n            }\n\n            if (ostream != NULL && pCallback->funcs.encode != NULL)\n            {\n                return pCallback->funcs.encode(ostream, field, &pCallback->arg);\n            }\n        }\n    }\n\n    return true; /* Success, but didn't do anything */\n\n}\n\n#ifdef PB_VALIDATE_UTF8\n\n/* This function checks whether a string is valid UTF-8 text.\n *\n * Algorithm is adapted from https://www.cl.cam.ac.uk/~mgk25/ucs/utf8_check.c\n * Original copyright: Markus Kuhn <http://www.cl.cam.ac.uk/~mgk25/> 2005-03-30\n * Licensed under \"Short code license\", which allows use under MIT license or\n * any compatible with it.\n */\n\nbool pb_validate_utf8(const char *str)\n{\n    const pb_byte_t *s = (const pb_byte_t*)str;\n    while (*s)\n    {\n        if (*s < 0x80)\n        {\n            /* 0xxxxxxx */\n            s++;\n        }\n        else if ((s[0] & 0xe0) == 0xc0)\n        {\n            /* 110XXXXx 10xxxxxx */\n            if ((s[1] & 0xc0) != 0x80 ||\n                (s[0] & 0xfe) == 0xc0)                        /* overlong? */\n                return false;\n            else\n                s += 2;\n        }\n        else if ((s[0] & 0xf0) == 0xe0)\n        {\n            /* 1110XXXX 10Xxxxxx 10xxxxxx */\n            if ((s[1] & 0xc0) != 0x80 ||\n                (s[2] & 0xc0) != 0x80 ||\n                (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) ||    /* overlong? */\n                (s[0] == 0xed && (s[1] & 0xe0) == 0xa0) ||    /* surrogate? */\n                (s[0] == 0xef && s[1] == 0xbf &&\n                (s[2] & 0xfe) == 0xbe))                 /* U+FFFE or U+FFFF? */\n                return false;\n            else\n                s += 3;\n        }\n        else if ((s[0] & 0xf8) == 0xf0)\n        {\n            /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */\n            if ((s[1] & 0xc0) != 0x80 ||\n                (s[2] & 0xc0) != 0x80 ||\n                (s[3] & 0xc0) != 0x80 ||\n                (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) ||    /* overlong? */\n                (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4) /* > U+10FFFF? */\n                return false;\n            else\n                s += 4;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n#endif\n\n"
        },
        {
          "name": "pb_common.h",
          "type": "blob",
          "size": 1.6376953125,
          "content": "/* pb_common.h: Common support functions for pb_encode.c and pb_decode.c.\n * These functions are rarely needed by applications directly.\n */\n\n#ifndef PB_COMMON_H_INCLUDED\n#define PB_COMMON_H_INCLUDED\n\n#include \"pb.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Initialize the field iterator structure to beginning.\n * Returns false if the message type is empty. */\nbool pb_field_iter_begin(pb_field_iter_t *iter, const pb_msgdesc_t *desc, void *message);\n\n/* Get a field iterator for extension field. */\nbool pb_field_iter_begin_extension(pb_field_iter_t *iter, pb_extension_t *extension);\n\n/* Same as pb_field_iter_begin(), but for const message pointer.\n * Note that the pointers in pb_field_iter_t will be non-const but shouldn't\n * be written to when using these functions. */\nbool pb_field_iter_begin_const(pb_field_iter_t *iter, const pb_msgdesc_t *desc, const void *message);\nbool pb_field_iter_begin_extension_const(pb_field_iter_t *iter, const pb_extension_t *extension);\n\n/* Advance the iterator to the next field.\n * Returns false when the iterator wraps back to the first field. */\nbool pb_field_iter_next(pb_field_iter_t *iter);\n\n/* Advance the iterator until it points at a field with the given tag.\n * Returns false if no such field exists. */\nbool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag);\n\n/* Find a field with type PB_LTYPE_EXTENSION, or return false if not found.\n * There can be only one extension range field per message. */\nbool pb_field_iter_find_extension(pb_field_iter_t *iter);\n\n#ifdef PB_VALIDATE_UTF8\n/* Validate UTF-8 text string */\nbool pb_validate_utf8(const char *s);\n#endif\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif\n\n"
        },
        {
          "name": "pb_decode.c",
          "type": "blob",
          "size": 53.689453125,
          "content": "/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers, gcc before 3.4.0 and iar\n * before 9.40.1 just ignore the annotation.\n */\n#if (defined(__GNUC__) && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))) || \\\n    (defined(__IAR_SYSTEMS_ICC__) && (__VER__ >= 9040001))\n    #define checkreturn __attribute__((warn_unused_result))\n#else\n    #define checkreturn\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);\nstatic bool checkreturn decode_basic_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_extension_t *extension);\nstatic bool pb_field_set_to_default(pb_field_iter_t *field);\nstatic bool pb_message_set_to_defaults(pb_field_iter_t *iter);\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *field);\nstatic bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field);\nstatic void pb_release_single_field(pb_field_iter_t *field);\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n#define pb_int64_t int32_t\n#define pb_uint64_t uint32_t\n#else\n#define pb_int64_t int64_t\n#define pb_uint64_t uint64_t\n#endif\n\ntypedef struct {\n    uint32_t bitfield[(PB_MAX_REQUIRED_FIELDS + 31) / 32];\n} pb_fields_seen_t;\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    const pb_byte_t *source = (const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + count;\n    \n    if (buf != NULL)\n    {\n        memcpy(buf, source, count * sizeof(pb_byte_t));\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    if (count == 0)\n        return true;\n\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tpb_byte_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    if (stream->bytes_left < count)\n        stream->bytes_left = 0;\n    else\n        stream->bytes_left -= count;\n\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t msglen)\n{\n    pb_istream_t stream;\n    /* Cast away the const from buf without a compiler error.  We are\n     * careful to use it only in a const manner in the callbacks.\n     */\n    union {\n        void *state;\n        const void *c_state;\n    } state;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    state.c_state = buf;\n    stream.state = state.state;\n    stream.bytes_left = msglen;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n\n/********************\n * Helper functions *\n ********************/\n\nbool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    pb_byte_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n    {\n        return false;\n    }\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint_fast8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            if (bitpos >= 32)\n            {\n                /* Note: The varint could have trailing 0x80 bytes, or 0xFF for negative. */\n                pb_byte_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;\n                bool valid_extension = ((byte & 0x7F) == 0x00 ||\n                         ((result >> 31) != 0 && byte == sign_extension));\n\n                if (bitpos >= 64 || !valid_extension)\n                {\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n                }\n            }\n            else if (bitpos == 28)\n            {\n                if ((byte & 0x70) != 0 && (byte & 0x78) != 0x78)\n                {\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n                }\n                result |= (uint32_t)(byte & 0x0F) << bitpos;\n            }\n            else\n            {\n                result |= (uint32_t)(byte & 0x7F) << bitpos;\n            }\n            bitpos = (uint_fast8_t)(bitpos + 7);\n        } while (byte & 0x80);\n   }\n   \n   *dest = result;\n   return true;\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    pb_byte_t byte;\n    uint_fast8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        if (bitpos >= 63 && (byte & 0xFE) != 0)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint_fast8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n#endif\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    pb_byte_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    if ((size_t)length != length)\n    {\n        PB_RETURN_ERROR(stream, \"size too large\");\n    }\n\n    return pb_read(stream, NULL, (size_t)length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n\n    if (stream->bytes_left == 0)\n    {\n        *eof = true;\n        return false;\n    }\n\n    if (!pb_decode_varint32(stream, &temp))\n    {\n#ifndef PB_BUFFER_ONLY\n        /* Workaround for issue #1017\n         *\n         * Callback streams don't set bytes_left to 0 on eof until after being called by pb_decode_varint32,\n         * which results in \"io error\" being raised. This contrasts the behavior of buffer streams who raise\n         * no error on eof as bytes_left is already 0 on entry. This causes legitimate errors (e.g. missing\n         * required fields) to be incorrectly reported by callback streams.\n         */\n        if (stream->callback != buf_read && stream->bytes_left == 0)\n        {\n#ifndef PB_NO_ERRMSG\n            if (strcmp(stream->errmsg, \"io error\") == 0)\n                stream->errmsg = NULL;\n#endif\n            *eof = true;\n        }\n#endif\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n\tcase PB_WT_PACKED: \n            /* Calling pb_skip_field with a PB_WT_PACKED is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size)\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n\n                if (!pb_read(stream, buf, 1))\n                    return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        case PB_WT_STRING:\n            /* Calling read_raw_value with a PB_WT_STRING is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n\n\tcase PB_WT_PACKED: \n            /* Calling read_raw_value with a PB_WT_PACKED is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = (size_t)size;\n    stream->bytes_left -= (size_t)size;\n    return true;\n}\n\nbool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    if (substream->bytes_left) {\n        if (!pb_read(substream, NULL, substream->bytes_left))\n            return false;\n    }\n\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n    return true;\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_basic_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    switch (PB_LTYPE(field->type))\n    {\n        case PB_LTYPE_BOOL:\n            if (wire_type != PB_WT_VARINT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_bool(stream, field);\n\n        case PB_LTYPE_VARINT:\n        case PB_LTYPE_UVARINT:\n        case PB_LTYPE_SVARINT:\n            if (wire_type != PB_WT_VARINT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_varint(stream, field);\n\n        case PB_LTYPE_FIXED32:\n            if (wire_type != PB_WT_32BIT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_decode_fixed32(stream, field->pData);\n\n        case PB_LTYPE_FIXED64:\n            if (wire_type != PB_WT_64BIT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n            if (field->data_size == sizeof(float))\n            {\n                return pb_decode_double_as_float(stream, (float*)field->pData);\n            }\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n#else\n            return pb_decode_fixed64(stream, field->pData);\n#endif\n\n        case PB_LTYPE_BYTES:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_bytes(stream, field);\n\n        case PB_LTYPE_STRING:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_string(stream, field);\n\n        case PB_LTYPE_SUBMESSAGE:\n        case PB_LTYPE_SUBMSG_W_CB:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_submessage(stream, field);\n\n        case PB_LTYPE_FIXED_LENGTH_BYTES:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_fixed_length_bytes(stream, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return decode_basic_field(stream, wire_type, field);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (field->pSize != NULL)\n                *(bool*)field->pSize = true;\n            return decode_basic_field(stream, wire_type, field);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_istream_t substream;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                field->pData = (char*)field->pField + field->data_size * (*size);\n\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < field->array_size)\n                {\n                    if (!decode_basic_field(&substream, PB_WT_PACKED, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                    field->pData = (char*)field->pData + field->data_size;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                field->pData = (char*)field->pField + field->data_size * (*size);\n\n                if ((*size)++ >= field->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return decode_basic_field(stream, wire_type, field);\n            }\n\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE_IS_SUBMSG(field->type) &&\n                *(pb_size_t*)field->pSize != field->tag)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * This is because the callbacks might otherwise have values\n                 * from some other union field.\n                 * If callbacks are needed inside oneof field, use .proto\n                 * option submsg_callback to have a separate callback function\n                 * that can set the fields before submessage is decoded.\n                 * pb_dec_submessage() will set any default values. */\n                memset(field->pData, 0, (size_t)field->data_size);\n\n                /* Set default values for the submessage fields. */\n                if (field->submsg_desc->default_value != NULL ||\n                    field->submsg_desc->field_callback != NULL ||\n                    field->submsg_desc->submsg_info[0] != NULL)\n                {\n                    pb_field_iter_t submsg_iter;\n                    if (pb_field_iter_begin(&submsg_iter, field->submsg_desc, field->pData))\n                    {\n                        if (!pb_message_set_to_defaults(&submsg_iter))\n                            PB_RETURN_ERROR(stream, \"failed to set defaults\");\n                    }\n                }\n            }\n            *(pb_size_t*)field->pSize = field->tag;\n\n            return decode_basic_field(stream, wire_type, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n#ifdef __AVR__\n    /* Workaround for AVR libc bug 53284: http://savannah.nongnu.org/bugs/?53284\n     * Realloc to size of 1 byte can cause corruption of the malloc structures.\n     */\n    if (data_size == 1 && array_size == 1)\n    {\n        data_size = 2;\n    }\n#endif\n\n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE_IS_SUBMSG(field->type))\n    {\n        /* We memset to zero so that any callbacks are set to NULL.\n         * Default values will be set by pb_dec_submessage(). */\n        memset(pItem, 0, field->data_size);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(field);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE_IS_SUBMSG(field->type) && *(void**)field->pField != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                /* FIXME: Does this work correctly for oneofs? */\n                pb_release_single_field(field);\n            }\n        \n            if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n            {\n                *(pb_size_t*)field->pSize = field->tag;\n            }\n\n            if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n                PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n            {\n                /* pb_dec_string and pb_dec_bytes handle allocation themselves */\n                field->pData = field->pField;\n                return decode_basic_field(stream, wire_type, field);\n            }\n            else\n            {\n                if (!allocate_field(stream, field->pField, field->data_size, 1))\n                    return false;\n                \n                field->pData = *(void**)field->pField;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, wire_type, field);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                size_t allocated_size = *size;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        size_t remain = (substream.bytes_left - 1) / field->data_size + 1;\n                        if (remain < PB_SIZE_MAX - allocated_size)\n                            allocated_size += remain;\n                        else\n                            allocated_size += 1;\n                        \n                        if (!allocate_field(&substream, field->pField, field->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    field->pData = *(char**)field->pField + field->data_size * (*size);\n                    if (field->pData == NULL)\n                    {\n                        /* Shouldn't happen, but satisfies static analyzers */\n                        status = false;\n                        break;\n                    }\n                    initialize_pointer_field(field->pData, field);\n                    if (!decode_basic_field(&substream, PB_WT_PACKED, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n\n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                if (!allocate_field(stream, field->pField, field->data_size, (size_t)(*size + 1)))\n                    return false;\n            \n                field->pData = *(char**)field->pField + field->data_size * (*size);\n                (*size)++;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, wire_type, field);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    if (!field->descriptor->field_callback)\n        return pb_skip_field(stream, wire_type);\n\n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        size_t prev_bytes_left;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            prev_bytes_left = substream.bytes_left;\n            if (!field->descriptor->field_callback(&substream, NULL, field))\n            {\n                PB_SET_ERROR(stream, substream.errmsg ? substream.errmsg : \"callback failed\");\n                return false;\n            }\n        } while (substream.bytes_left > 0 && substream.bytes_left < prev_bytes_left);\n        \n        if (!pb_close_string_substream(stream, &substream))\n            return false;\n\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        pb_byte_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return field->descriptor->field_callback(&substream, NULL, field);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifdef PB_ENABLE_MALLOC\n    /* When decoding an oneof field, check if there is old data that must be\n     * released first. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n    {\n        if (!pb_release_union_field(stream, field))\n            return false;\n    }\n#endif\n\n    switch (PB_ATYPE(field->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, field);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, field);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, field);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n/* Default handler for extension fields. Expects to have a pb_msgdesc_t\n * pointer in the extension->type->arg field, pointing to a message with\n * only one field in it.  */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin_extension(&iter, extension))\n        PB_RETURN_ERROR(stream, \"invalid extension\");\n\n    if (iter.tag != tag || !iter.message)\n        return true;\n\n    extension->found = true;\n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_extension_t *extension)\n{\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic bool pb_field_set_to_default(pb_field_iter_t *field)\n{\n    pb_type_t type;\n    type = field->type;\n\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        pb_extension_t *ext = *(pb_extension_t* const *)field->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            if (pb_field_iter_begin_extension(&ext_iter, ext))\n            {\n                ext->found = false;\n                if (!pb_message_set_to_defaults(&ext_iter))\n                    return false;\n            }\n            ext = ext->next;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n    {\n        bool init_data = true;\n        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && field->pSize != NULL)\n        {\n            /* Set has_field to false. Still initialize the optional field\n             * itself also. */\n            *(bool*)field->pSize = false;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n                 PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            /* REPEATED: Set array count to 0, no need to initialize contents.\n               ONEOF: Set which_field to 0. */\n            *(pb_size_t*)field->pSize = 0;\n            init_data = false;\n        }\n\n        if (init_data)\n        {\n            if (PB_LTYPE_IS_SUBMSG(field->type) &&\n                (field->submsg_desc->default_value != NULL ||\n                 field->submsg_desc->field_callback != NULL ||\n                 field->submsg_desc->submsg_info[0] != NULL))\n            {\n                /* Initialize submessage to defaults.\n                 * Only needed if it has default values\n                 * or callback/submessage fields. */\n                pb_field_iter_t submsg_iter;\n                if (pb_field_iter_begin(&submsg_iter, field->submsg_desc, field->pData))\n                {\n                    if (!pb_message_set_to_defaults(&submsg_iter))\n                        return false;\n                }\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(field->pData, 0, (size_t)field->data_size);\n            }\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL. */\n        *(void**)field->pField = NULL;\n\n        /* Initialize array count to 0. */\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n            PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            *(pb_size_t*)field->pSize = 0;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n    {\n        /* Don't overwrite callback */\n    }\n\n    return true;\n}\n\nstatic bool pb_message_set_to_defaults(pb_field_iter_t *iter)\n{\n    pb_istream_t defstream = PB_ISTREAM_EMPTY;\n    uint32_t tag = 0;\n    pb_wire_type_t wire_type = PB_WT_VARINT;\n    bool eof;\n\n    if (iter->descriptor->default_value)\n    {\n        defstream = pb_istream_from_buffer(iter->descriptor->default_value, (size_t)-1);\n        if (!pb_decode_tag(&defstream, &wire_type, &tag, &eof))\n            return false;\n    }\n\n    do\n    {\n        if (!pb_field_set_to_default(iter))\n            return false;\n\n        if (tag != 0 && iter->tag == tag)\n        {\n            /* We have a default value for this field in the defstream */\n            if (!decode_field(&defstream, wire_type, iter))\n                return false;\n            if (!pb_decode_tag(&defstream, &wire_type, &tag, &eof))\n                return false;\n\n            if (iter->pSize)\n                *(bool*)iter->pSize = false;\n        }\n    } while (pb_field_iter_next(iter));\n\n    return true;\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nstatic bool checkreturn pb_decode_inner(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags)\n{\n    /* If the message contains extension fields, the extension handlers\n     * are called when tag number is >= extension_range_start. This precheck\n     * is just for speed, and the handlers will check for precise match.\n     */\n    uint32_t extension_range_start = 0;\n    pb_extension_t *extensions = NULL;\n\n    /* 'fixed_count_field' and 'fixed_count_size' track position of a repeated fixed\n     * count field. This can only handle _one_ repeated fixed count field that\n     * is unpacked and unordered among other (non repeated fixed count) fields.\n     */\n    pb_size_t fixed_count_field = PB_SIZE_MAX;\n    pb_size_t fixed_count_size = 0;\n    pb_size_t fixed_count_total_size = 0;\n\n    /* Tag and wire type of next field from the input stream */\n    uint32_t tag;\n    pb_wire_type_t wire_type;\n    bool eof;\n\n    /* Track presence of required fields */\n    pb_fields_seen_t fields_seen = {{0, 0}};\n    const uint32_t allbits = ~(uint32_t)0;\n\n    /* Descriptor for the structure field matching the tag decoded from stream */\n    pb_field_iter_t iter;\n\n    if (pb_field_iter_begin(&iter, fields, dest_struct))\n    {\n        if ((flags & PB_DECODE_NOINIT) == 0)\n        {\n            if (!pb_message_set_to_defaults(&iter))\n                PB_RETURN_ERROR(stream, \"failed to set defaults\");\n        }\n    }\n\n    while (pb_decode_tag(stream, &wire_type, &tag, &eof))\n    {\n        if (tag == 0)\n        {\n          if (flags & PB_DECODE_NULLTERMINATED)\n          {\n            eof = true;\n            break;\n          }\n          else\n          {\n            PB_RETURN_ERROR(stream, \"zero tag\");\n          }\n        }\n\n        if (!pb_field_iter_find(&iter, tag) || PB_LTYPE(iter.type) == PB_LTYPE_EXTENSION)\n        {\n            /* No match found, check if it matches an extension. */\n            if (extension_range_start == 0)\n            {\n                if (pb_field_iter_find_extension(&iter))\n                {\n                    extensions = *(pb_extension_t* const *)iter.pData;\n                    extension_range_start = iter.tag;\n                }\n\n                if (!extensions)\n                {\n                    extension_range_start = (uint32_t)-1;\n                }\n            }\n\n            if (tag >= extension_range_start)\n            {\n                size_t pos = stream->bytes_left;\n\n                if (!decode_extension(stream, tag, wire_type, extensions))\n                    return false;\n\n                if (pos != stream->bytes_left)\n                {\n                    /* The field was handled */\n                    continue;\n                }\n            }\n\n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n\n        /* If a repeated fixed count field was found, get size from\n         * 'fixed_count_field' as there is no counter contained in the struct.\n         */\n        if (PB_HTYPE(iter.type) == PB_HTYPE_REPEATED && iter.pSize == &iter.array_size)\n        {\n            if (fixed_count_field != iter.index) {\n                /* If the new fixed count field does not match the previous one,\n                 * check that the previous one is NULL or that it finished\n                 * receiving all the expected data.\n                 */\n                if (fixed_count_field != PB_SIZE_MAX &&\n                    fixed_count_size != fixed_count_total_size)\n                {\n                    PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n                }\n\n                fixed_count_field = iter.index;\n                fixed_count_size = 0;\n                fixed_count_total_size = iter.array_size;\n            }\n\n            iter.pSize = &fixed_count_size;\n        }\n\n        if (PB_HTYPE(iter.type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));\n            fields_seen.bitfield[iter.required_field_index >> 5] |= tmp;\n        }\n\n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n\n    if (!eof)\n    {\n        /* pb_decode_tag() returned error before end of stream */\n        return false;\n    }\n\n    /* Check that all elements of the last decoded fixed count field were present. */\n    if (fixed_count_field != PB_SIZE_MAX &&\n        fixed_count_size != fixed_count_total_size)\n    {\n        PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n    }\n\n    /* Check that all required fields were present. */\n    {\n        pb_size_t req_field_count = iter.descriptor->required_field_count;\n\n        if (req_field_count > 0)\n        {\n            pb_size_t i;\n\n            if (req_field_count > PB_MAX_REQUIRED_FIELDS)\n                req_field_count = PB_MAX_REQUIRED_FIELDS;\n\n            /* Check the whole words */\n            for (i = 0; i < (req_field_count >> 5); i++)\n            {\n                if (fields_seen.bitfield[i] != allbits)\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n            }\n\n            /* Check the remaining bits (if any) */\n            if ((req_field_count & 31) != 0)\n            {\n                if (fields_seen.bitfield[req_field_count >> 5] !=\n                    (allbits >> (uint_least8_t)(32 - (req_field_count & 31))))\n                {\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nbool checkreturn pb_decode_ex(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags)\n{\n    bool status;\n\n    if ((flags & PB_DECODE_DELIMITED) == 0)\n    {\n      status = pb_decode_inner(stream, fields, dest_struct, flags);\n    }\n    else\n    {\n      pb_istream_t substream;\n      if (!pb_make_string_substream(stream, &substream))\n        return false;\n\n      status = pb_decode_inner(&substream, fields, dest_struct, flags);\n\n      if (!pb_close_string_substream(stream, &substream))\n        status = false;\n    }\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct)\n{\n    return pb_decode_ex(stream, fields, dest_struct, 0);\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Given an oneof field, if there has already been a field inside this oneof,\n * release it before overwriting with a different one. */\nstatic bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */\n    pb_size_t new_tag = field->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(&old_field);\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL to make sure it is valid\n         * even in case of error return. */\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n\n    return true;\n}\n\nstatic void pb_release_single_field(pb_field_iter_t *field)\n{\n    pb_type_t type;\n    type = field->type;\n\n    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n    {\n        if (*(pb_size_t*)field->pSize != field->tag)\n            return; /* This is not the current field in the union */\n    }\n\n    /* Release anything contained inside an extension or submsg.\n     * This has to be done even if the submsg itself is statically\n     * allocated. */\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        /* Release fields from all extensions in the linked list */\n        pb_extension_t *ext = *(pb_extension_t**)field->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            if (pb_field_iter_begin_extension(&ext_iter, ext))\n            {\n                pb_release_single_field(&ext_iter);\n            }\n            ext = ext->next;\n        }\n    }\n    else if (PB_LTYPE_IS_SUBMSG(type) && PB_ATYPE(type) != PB_ATYPE_CALLBACK)\n    {\n        /* Release fields in submessage or submsg array */\n        pb_size_t count = 1;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            field->pData = *(void**)field->pField;\n        }\n        else\n        {\n            field->pData = field->pField;\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            count = *(pb_size_t*)field->pSize;\n\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > field->array_size)\n            {\n                /* Protect against corrupted _count fields */\n                count = field->array_size;\n            }\n        }\n        \n        if (field->pData)\n        {\n            for (; count > 0; count--)\n            {\n                pb_release(field->submsg_desc, field->pData);\n                field->pData = (char*)field->pData + field->data_size;\n            }\n        }\n    }\n    \n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)field->pField;\n            pb_size_t count = *(pb_size_t*)field->pSize;\n            for (; count > 0; count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            /* We are going to release the array, so set the size to 0 */\n            *(pb_size_t*)field->pSize = 0;\n        }\n        \n        /* Release main pointer */\n        pb_free(*(void**)field->pField);\n        *(void**)field->pField = NULL;\n    }\n}\n\nvoid pb_release(const pb_msgdesc_t *fields, void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!dest_struct)\n        return; /* Ignore NULL pointers, similar to free() */\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#else\nvoid pb_release(const pb_msgdesc_t *fields, void *dest_struct)\n{\n    /* Nothing to release without PB_ENABLE_MALLOC. */\n    PB_UNUSED(fields);\n    PB_UNUSED(dest_struct);\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_bool(pb_istream_t *stream, bool *dest)\n{\n    uint32_t value;\n    if (!pb_decode_varint32(stream, &value))\n        return false;\n\n    *(bool*)dest = (value != 0);\n    return true;\n}\n\nbool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)\n{\n    pb_uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (pb_int64_t)(~(value >> 1));\n    else\n        *dest = (pb_int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    union {\n        uint32_t fixed32;\n        pb_byte_t bytes[4];\n    } u;\n\n    if (!pb_read(stream, u.bytes, 4))\n        return false;\n\n#if defined(PB_LITTLE_ENDIAN_8BIT) && PB_LITTLE_ENDIAN_8BIT == 1\n    /* fast path - if we know that we're on little endian, assign directly */\n    *(uint32_t*)dest = u.fixed32;\n#else\n    *(uint32_t*)dest = ((uint32_t)u.bytes[0] << 0) |\n                       ((uint32_t)u.bytes[1] << 8) |\n                       ((uint32_t)u.bytes[2] << 16) |\n                       ((uint32_t)u.bytes[3] << 24);\n#endif\n    return true;\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    union {\n        uint64_t fixed64;\n        pb_byte_t bytes[8];\n    } u;\n\n    if (!pb_read(stream, u.bytes, 8))\n        return false;\n\n#if defined(PB_LITTLE_ENDIAN_8BIT) && PB_LITTLE_ENDIAN_8BIT == 1\n    /* fast path - if we know that we're on little endian, assign directly */\n    *(uint64_t*)dest = u.fixed64;\n#else\n    *(uint64_t*)dest = ((uint64_t)u.bytes[0] << 0) |\n                       ((uint64_t)u.bytes[1] << 8) |\n                       ((uint64_t)u.bytes[2] << 16) |\n                       ((uint64_t)u.bytes[3] << 24) |\n                       ((uint64_t)u.bytes[4] << 32) |\n                       ((uint64_t)u.bytes[5] << 40) |\n                       ((uint64_t)u.bytes[6] << 48) |\n                       ((uint64_t)u.bytes[7] << 56);\n#endif\n    return true;\n}\n#endif\n\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    return pb_decode_bool(stream, (bool*)field->pData);\n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_UVARINT)\n    {\n        pb_uint64_t value, clamped;\n        if (!pb_decode_varint(stream, &value))\n            return false;\n\n        /* Cast to the proper field size, while checking for overflows */\n        if (field->data_size == sizeof(pb_uint64_t))\n            clamped = *(pb_uint64_t*)field->pData = value;\n        else if (field->data_size == sizeof(uint32_t))\n            clamped = *(uint32_t*)field->pData = (uint32_t)value;\n        else if (field->data_size == sizeof(uint_least16_t))\n            clamped = *(uint_least16_t*)field->pData = (uint_least16_t)value;\n        else if (field->data_size == sizeof(uint_least8_t))\n            clamped = *(uint_least8_t*)field->pData = (uint_least8_t)value;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (clamped != value)\n            PB_RETURN_ERROR(stream, \"integer too large\");\n\n        return true;\n    }\n    else\n    {\n        pb_uint64_t value;\n        pb_int64_t svalue;\n        pb_int64_t clamped;\n\n        if (PB_LTYPE(field->type) == PB_LTYPE_SVARINT)\n        {\n            if (!pb_decode_svarint(stream, &svalue))\n                return false;\n        }\n        else\n        {\n            if (!pb_decode_varint(stream, &value))\n                return false;\n\n            /* See issue 97: Google's C++ protobuf allows negative varint values to\n            * be cast as int32_t, instead of the int64_t that should be used when\n            * encoding. Nanopb versions before 0.2.5 had a bug in encoding. In order to\n            * not break decoding of such messages, we cast <=32 bit fields to\n            * int32_t first to get the sign correct.\n            */\n            if (field->data_size == sizeof(pb_int64_t))\n                svalue = (pb_int64_t)value;\n            else\n                svalue = (int32_t)value;\n        }\n\n        /* Cast to the proper field size, while checking for overflows */\n        if (field->data_size == sizeof(pb_int64_t))\n            clamped = *(pb_int64_t*)field->pData = svalue;\n        else if (field->data_size == sizeof(int32_t))\n            clamped = *(int32_t*)field->pData = (int32_t)svalue;\n        else if (field->data_size == sizeof(int_least16_t))\n            clamped = *(int_least16_t*)field->pData = (int_least16_t)svalue;\n        else if (field->data_size == sizeof(int_least8_t))\n            clamped = *(int_least8_t*)field->pData = (int_least8_t)svalue;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (clamped != svalue)\n            PB_RETURN_ERROR(stream, \"integer too large\");\n\n        return true;\n    }\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_bytes_array_t *dest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    \n    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);\n    if (size > alloc_size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (stream->bytes_left < size)\n            PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n        if (!allocate_field(stream, field->pData, alloc_size, 1))\n            return false;\n        dest = *(pb_bytes_array_t**)field->pData;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        dest = (pb_bytes_array_t*)field->pData;\n    }\n\n    dest->size = (pb_size_t)size;\n    return pb_read(stream, dest->bytes, (size_t)size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_byte_t *dest = (pb_byte_t*)field->pData;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size == (uint32_t)-1)\n        PB_RETURN_ERROR(stream, \"size too large\");\n\n    /* Space for null terminator */\n    alloc_size = (size_t)(size + 1);\n\n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (stream->bytes_left < size)\n            PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n        if (!allocate_field(stream, field->pData, alloc_size, 1))\n            return false;\n        dest = *(pb_byte_t**)field->pData;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    dest[size] = 0;\n\n    if (!pb_read(stream, dest, (size_t)size))\n        return false;\n\n#ifdef PB_VALIDATE_UTF8\n    if (!pb_validate_utf8((const char*)dest))\n        PB_RETURN_ERROR(stream, \"invalid utf8\");\n#endif\n\n    return true;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    bool status = true;\n    bool submsg_consumed = false;\n    pb_istream_t substream;\n\n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->submsg_desc == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* Submessages can have a separate message-level callback that is called\n     * before decoding the message. Typically it is used to set callback fields\n     * inside oneofs. */\n    if (PB_LTYPE(field->type) == PB_LTYPE_SUBMSG_W_CB && field->pSize != NULL)\n    {\n        /* Message callback is stored right before pSize. */\n        pb_callback_t *callback = (pb_callback_t*)field->pSize - 1;\n        if (callback->funcs.decode)\n        {\n            status = callback->funcs.decode(&substream, field, &callback->arg);\n\n            if (substream.bytes_left == 0)\n            {\n                submsg_consumed = true;\n            }\n        }\n    }\n\n    /* Now decode the submessage contents */\n    if (status && !submsg_consumed)\n    {\n        unsigned int flags = 0;\n\n        /* Static required/optional fields are already initialized by top-level\n         * pb_decode(), no need to initialize them again. */\n        if (PB_ATYPE(field->type) == PB_ATYPE_STATIC &&\n            PB_HTYPE(field->type) != PB_HTYPE_REPEATED)\n        {\n            flags = PB_DECODE_NOINIT;\n        }\n\n        status = pb_decode_inner(&substream, field->submsg_desc, field->pData, flags);\n    }\n    \n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n\n    return status;\n}\n\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n\n    if (size == 0)\n    {\n        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */\n        memset(field->pData, 0, (size_t)field->data_size);\n        return true;\n    }\n\n    if (size != field->data_size)\n        PB_RETURN_ERROR(stream, \"incorrect fixed length bytes size\");\n\n    return pb_read(stream, (pb_byte_t*)field->pData, (size_t)field->data_size);\n}\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\nbool pb_decode_double_as_float(pb_istream_t *stream, float *dest)\n{\n    uint_least8_t sign;\n    int exponent;\n    uint32_t mantissa;\n    uint64_t value;\n    union { float f; uint32_t i; } out;\n\n    if (!pb_decode_fixed64(stream, &value))\n        return false;\n\n    /* Decompose input value */\n    sign = (uint_least8_t)((value >> 63) & 1);\n    exponent = (int)((value >> 52) & 0x7FF) - 1023;\n    mantissa = (value >> 28) & 0xFFFFFF; /* Highest 24 bits */\n\n    /* Figure if value is in range representable by floats. */\n    if (exponent == 1024)\n    {\n        /* Special value */\n        exponent = 128;\n        mantissa >>= 1;\n    }\n    else\n    {\n        if (exponent > 127)\n        {\n            /* Too large, convert to infinity */\n            exponent = 128;\n            mantissa = 0;\n        }\n        else if (exponent < -150)\n        {\n            /* Too small, convert to zero */\n            exponent = -127;\n            mantissa = 0;\n        }\n        else if (exponent < -126)\n        {\n            /* Denormalized */\n            mantissa |= 0x1000000;\n            mantissa >>= (-126 - exponent);\n            exponent = -127;\n        }\n\n        /* Round off mantissa */\n        mantissa = (mantissa + 1) >> 1;\n\n        /* Check if mantissa went over 2.0 */\n        if (mantissa & 0x800000)\n        {\n            exponent += 1;\n            mantissa &= 0x7FFFFF;\n            mantissa >>= 1;\n        }\n    }\n\n    /* Combine fields */\n    out.i = mantissa;\n    out.i |= (uint32_t)(exponent + 127) << 23;\n    out.i |= (uint32_t)sign << 31;\n\n    *dest = out.f;\n    return true;\n}\n#endif\n"
        },
        {
          "name": "pb_decode.h",
          "type": "blob",
          "size": 7.685546875,
          "content": "/* pb_decode.h: Functions to decode protocol buffers. Depends on pb_decode.c.\n * The main function is pb_decode. You also need an input stream, and the\n * field descriptions created by nanopb_generator.py.\n */\n\n#ifndef PB_DECODE_H_INCLUDED\n#define PB_DECODE_H_INCLUDED\n\n#include \"pb.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Structure for defining custom input streams. You will need to provide\n * a callback function to read the bytes from your storage, which can be\n * for example a file or a network socket.\n * \n * The callback must conform to these rules:\n *\n * 1) Return false on IO errors. This will cause decoding to abort.\n * 2) You can use state to store your own data (e.g. buffer pointer),\n *    and rely on pb_read to verify that no-body reads past bytes_left.\n * 3) Your callback may be used with substreams, in which case bytes_left\n *    is different than from the main stream. Don't use bytes_left to compute\n *    any pointers.\n */\nstruct pb_istream_s\n{\n#ifdef PB_BUFFER_ONLY\n    /* Callback pointer is not used in buffer-only configuration.\n     * Having an int pointer here allows binary compatibility but\n     * gives an error if someone tries to assign callback function.\n     */\n    int *callback;\n#else\n    bool (*callback)(pb_istream_t *stream, pb_byte_t *buf, size_t count);\n#endif\n\n    /* state is a free field for use of the callback function defined above.\n     * Note that when pb_istream_from_buffer() is used, it reserves this field\n     * for its own use.\n     */\n    void *state;\n\n    /* Maximum number of bytes left in this stream. Callback can report\n     * EOF before this limit is reached. Setting a limit is recommended\n     * when decoding directly from file or network streams to avoid\n     * denial-of-service by excessively long messages.\n     */\n    size_t bytes_left;\n    \n#ifndef PB_NO_ERRMSG\n    /* Pointer to constant (ROM) string when decoding function returns error */\n    const char *errmsg;\n#endif\n};\n\n#ifndef PB_NO_ERRMSG\n#define PB_ISTREAM_EMPTY {0,0,0,0}\n#else\n#define PB_ISTREAM_EMPTY {0,0,0}\n#endif\n\n/***************************\n * Main decoding functions *\n ***************************/\n \n/* Decode a single protocol buffers message from input stream into a C structure.\n * Returns true on success, false on any failure.\n * The actual struct pointed to by dest must match the description in fields.\n * Callback fields of the destination structure must be initialized by caller.\n * All other fields will be initialized by this function.\n *\n * Example usage:\n *    MyMessage msg = {};\n *    uint8_t buffer[64];\n *    pb_istream_t stream;\n *    \n *    // ... read some data into buffer ...\n *\n *    stream = pb_istream_from_buffer(buffer, count);\n *    pb_decode(&stream, MyMessage_fields, &msg);\n */\nbool pb_decode(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct);\n\n/* Extended version of pb_decode, with several options to control\n * the decoding process:\n *\n * PB_DECODE_NOINIT:         Do not initialize the fields to default values.\n *                           This is slightly faster if you do not need the default\n *                           values and instead initialize the structure to 0 using\n *                           e.g. memset(). This can also be used for merging two\n *                           messages, i.e. combine already existing data with new\n *                           values.\n *\n * PB_DECODE_DELIMITED:      Input message starts with the message size as varint.\n *                           Corresponds to parseDelimitedFrom() in Google's\n *                           protobuf API.\n *\n * PB_DECODE_NULLTERMINATED: Stop reading when field tag is read as 0. This allows\n *                           reading null terminated messages.\n *                           NOTE: Until nanopb-0.4.0, pb_decode() also allows\n *                           null-termination. This behaviour is not supported in\n *                           most other protobuf implementations, so PB_DECODE_DELIMITED\n *                           is a better option for compatibility.\n *\n * Multiple flags can be combined with bitwise or (| operator)\n */\n#define PB_DECODE_NOINIT          0x01U\n#define PB_DECODE_DELIMITED       0x02U\n#define PB_DECODE_NULLTERMINATED  0x04U\nbool pb_decode_ex(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags);\n\n/* Defines for backwards compatibility with code written before nanopb-0.4.0 */\n#define pb_decode_noinit(s,f,d) pb_decode_ex(s,f,d, PB_DECODE_NOINIT)\n#define pb_decode_delimited(s,f,d) pb_decode_ex(s,f,d, PB_DECODE_DELIMITED)\n#define pb_decode_delimited_noinit(s,f,d) pb_decode_ex(s,f,d, PB_DECODE_DELIMITED | PB_DECODE_NOINIT)\n#define pb_decode_nullterminated(s,f,d) pb_decode_ex(s,f,d, PB_DECODE_NULLTERMINATED)\n\n/* Release any allocated pointer fields. If you use dynamic allocation, you should\n * call this for any successfully decoded message when you are done with it. If\n * pb_decode() returns with an error, the message is already released.\n */\nvoid pb_release(const pb_msgdesc_t *fields, void *dest_struct);\n\n/**************************************\n * Functions for manipulating streams *\n **************************************/\n\n/* Create an input stream for reading from a memory buffer.\n *\n * msglen should be the actual length of the message, not the full size of\n * allocated buffer.\n *\n * Alternatively, you can use a custom stream that reads directly from e.g.\n * a file or a network socket.\n */\npb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t msglen);\n\n/* Function to read from a pb_istream_t. You can use this if you need to\n * read some custom header data, or to read data in field callbacks.\n */\nbool pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);\n\n\n/************************************************\n * Helper functions for writing field callbacks *\n ************************************************/\n\n/* Decode the tag for the next field in the stream. Gives the wire type and\n * field tag. At end of the message, returns false and sets eof to true. */\nbool pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof);\n\n/* Skip the field payload data, given the wire type. */\nbool pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type);\n\n/* Decode an integer in the varint format. This works for enum, int32,\n * int64, uint32 and uint64 field types. */\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_varint(pb_istream_t *stream, uint64_t *dest);\n#else\n#define pb_decode_varint pb_decode_varint32\n#endif\n\n/* Decode an integer in the varint format. This works for enum, int32,\n * and uint32 field types. */\nbool pb_decode_varint32(pb_istream_t *stream, uint32_t *dest);\n\n/* Decode a bool value in varint format. */\nbool pb_decode_bool(pb_istream_t *stream, bool *dest);\n\n/* Decode an integer in the zig-zagged svarint format. This works for sint32\n * and sint64. */\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_svarint(pb_istream_t *stream, int64_t *dest);\n#else\nbool pb_decode_svarint(pb_istream_t *stream, int32_t *dest);\n#endif\n\n/* Decode a fixed32, sfixed32 or float value. You need to pass a pointer to\n * a 4-byte wide C variable. */\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest);\n\n#ifndef PB_WITHOUT_64BIT\n/* Decode a fixed64, sfixed64 or double value. You need to pass a pointer to\n * a 8-byte wide C variable. */\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest);\n#endif\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n/* Decode a double value into float variable. */\nbool pb_decode_double_as_float(pb_istream_t *stream, float *dest);\n#endif\n\n/* Make a limited-length substream for reading a PB_WT_STRING field. */\nbool pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream);\nbool pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif\n"
        },
        {
          "name": "pb_encode.c",
          "type": "blob",
          "size": 29.986328125,
          "content": "/* pb_encode.c -- encode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n#include \"pb.h\"\n#include \"pb_encode.h\"\n#include \"pb_common.h\"\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers, gcc before 3.4.0 and iar\n * before 9.40.1 just ignore the annotation.\n */\n#if (defined(__GNUC__) && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))) || \\\n    (defined(__IAR_SYSTEMS_ICC__) && (__VER__ >= 9040001))\n    #define checkreturn __attribute__((warn_unused_result))\n#else\n    #define checkreturn\n#endif\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\nstatic bool checkreturn buf_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);\nstatic bool checkreturn encode_array(pb_ostream_t *stream, pb_field_iter_t *field);\nstatic bool checkreturn pb_check_proto3_default_value(const pb_field_iter_t *field);\nstatic bool checkreturn encode_basic_field(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn encode_callback_field(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn encode_field(pb_ostream_t *stream, pb_field_iter_t *field);\nstatic pb_noinline bool checkreturn encode_extension_field(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn default_extension_encoder(pb_ostream_t *stream, const pb_extension_t *extension);\nstatic bool checkreturn pb_encode_varint_32(pb_ostream_t *stream, uint32_t low, uint32_t high);\nstatic bool checkreturn pb_enc_bool(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_enc_varint(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_enc_fixed(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_enc_bytes(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_enc_string(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_enc_submessage(pb_ostream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_enc_fixed_length_bytes(pb_ostream_t *stream, const pb_field_iter_t *field);\n\n#ifdef PB_WITHOUT_64BIT\n#define pb_int64_t int32_t\n#define pb_uint64_t uint32_t\n#else\n#define pb_int64_t int64_t\n#define pb_uint64_t uint64_t\n#endif\n\n/*******************************\n * pb_ostream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count)\n{\n    pb_byte_t *dest = (pb_byte_t*)stream->state;\n    stream->state = dest + count;\n    \n    memcpy(dest, buf, count * sizeof(pb_byte_t));\n    \n    return true;\n}\n\npb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize)\n{\n    pb_ostream_t stream;\n#ifdef PB_BUFFER_ONLY\n    /* In PB_BUFFER_ONLY configuration the callback pointer is just int*.\n     * NULL pointer marks a sizing field, so put a non-NULL value to mark a buffer stream.\n     */\n    static const int marker = 0;\n    stream.callback = &marker;\n#else\n    stream.callback = &buf_write;\n#endif\n    stream.state = buf;\n    stream.max_size = bufsize;\n    stream.bytes_written = 0;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\nbool checkreturn pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count)\n{\n    if (count > 0 && stream->callback != NULL)\n    {\n        if (stream->bytes_written + count < stream->bytes_written ||\n            stream->bytes_written + count > stream->max_size)\n        {\n            PB_RETURN_ERROR(stream, \"stream full\");\n        }\n\n#ifdef PB_BUFFER_ONLY\n        if (!buf_write(stream, buf, count))\n            PB_RETURN_ERROR(stream, \"io error\");\n#else        \n        if (!stream->callback(stream, buf, count))\n            PB_RETURN_ERROR(stream, \"io error\");\n#endif\n    }\n    \n    stream->bytes_written += count;\n    return true;\n}\n\n/*************************\n * Encode a single field *\n *************************/\n\n/* Read a bool value without causing undefined behavior even if the value\n * is invalid. See issue #434 and\n * https://stackoverflow.com/questions/27661768/weird-results-for-conditional\n */\nstatic bool safe_read_bool(const void *pSize)\n{\n    const char *p = (const char *)pSize;\n    size_t i;\n    for (i = 0; i < sizeof(bool); i++)\n    {\n        if (p[i] != 0)\n            return true;\n    }\n    return false;\n}\n\n/* Encode a static array. Handles the size calculations and possible packing. */\nstatic bool checkreturn encode_array(pb_ostream_t *stream, pb_field_iter_t *field)\n{\n    pb_size_t i;\n    pb_size_t count;\n#ifndef PB_ENCODE_ARRAYS_UNPACKED\n    size_t size;\n#endif\n\n    count = *(pb_size_t*)field->pSize;\n\n    if (count == 0)\n        return true;\n\n    if (PB_ATYPE(field->type) != PB_ATYPE_POINTER && count > field->array_size)\n        PB_RETURN_ERROR(stream, \"array max size exceeded\");\n    \n#ifndef PB_ENCODE_ARRAYS_UNPACKED\n    /* We always pack arrays if the datatype allows it. */\n    if (PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n    {\n        if (!pb_encode_tag(stream, PB_WT_STRING, field->tag))\n            return false;\n        \n        /* Determine the total size of packed array. */\n        if (PB_LTYPE(field->type) == PB_LTYPE_FIXED32)\n        {\n            size = 4 * (size_t)count;\n        }\n        else if (PB_LTYPE(field->type) == PB_LTYPE_FIXED64)\n        {\n            size = 8 * (size_t)count;\n        }\n        else\n        { \n            pb_ostream_t sizestream = PB_OSTREAM_SIZING;\n            void *pData_orig = field->pData;\n            for (i = 0; i < count; i++)\n            {\n                if (!pb_enc_varint(&sizestream, field))\n                    PB_RETURN_ERROR(stream, PB_GET_ERROR(&sizestream));\n                field->pData = (char*)field->pData + field->data_size;\n            }\n            field->pData = pData_orig;\n            size = sizestream.bytes_written;\n        }\n        \n        if (!pb_encode_varint(stream, (pb_uint64_t)size))\n            return false;\n        \n        if (stream->callback == NULL)\n            return pb_write(stream, NULL, size); /* Just sizing.. */\n        \n        /* Write the data */\n        for (i = 0; i < count; i++)\n        {\n            if (PB_LTYPE(field->type) == PB_LTYPE_FIXED32 || PB_LTYPE(field->type) == PB_LTYPE_FIXED64)\n            {\n                if (!pb_enc_fixed(stream, field))\n                    return false;\n            }\n            else\n            {\n                if (!pb_enc_varint(stream, field))\n                    return false;\n            }\n\n            field->pData = (char*)field->pData + field->data_size;\n        }\n    }\n    else /* Unpacked fields */\n#endif\n    {\n        for (i = 0; i < count; i++)\n        {\n            /* Normally the data is stored directly in the array entries, but\n             * for pointer-type string and bytes fields, the array entries are\n             * actually pointers themselves also. So we have to dereference once\n             * more to get to the actual data. */\n            if (PB_ATYPE(field->type) == PB_ATYPE_POINTER &&\n                (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n                 PB_LTYPE(field->type) == PB_LTYPE_BYTES))\n            {\n                bool status;\n                void *pData_orig = field->pData;\n                field->pData = *(void* const*)field->pData;\n\n                if (!field->pData)\n                {\n                    /* Null pointer in array is treated as empty string / bytes */\n                    status = pb_encode_tag_for_field(stream, field) &&\n                             pb_encode_varint(stream, 0);\n                }\n                else\n                {\n                    status = encode_basic_field(stream, field);\n                }\n\n                field->pData = pData_orig;\n\n                if (!status)\n                    return false;\n            }\n            else\n            {\n                if (!encode_basic_field(stream, field))\n                    return false;\n            }\n            field->pData = (char*)field->pData + field->data_size;\n        }\n    }\n    \n    return true;\n}\n\n/* In proto3, all fields are optional and are only encoded if their value is \"non-zero\".\n * This function implements the check for the zero value. */\nstatic bool checkreturn pb_check_proto3_default_value(const pb_field_iter_t *field)\n{\n    pb_type_t type = field->type;\n\n    if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REQUIRED)\n        {\n            /* Required proto2 fields inside proto3 submessage, pretty rare case */\n            return false;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            /* Repeated fields inside proto3 submessage: present if count != 0 */\n            return *(const pb_size_t*)field->pSize == 0;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            /* Oneof fields */\n            return *(const pb_size_t*)field->pSize == 0;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && field->pSize != NULL)\n        {\n            /* Proto2 optional fields inside proto3 message, or proto3\n             * submessage fields. */\n            return safe_read_bool(field->pSize) == false;\n        }\n        else if (field->descriptor->default_value)\n        {\n            /* Proto3 messages do not have default values, but proto2 messages\n             * can contain optional fields without has_fields (generator option 'proto3').\n             * In this case they must always be encoded, to make sure that the\n             * non-zero default value is overwritten.\n             */\n            return false;\n        }\n\n        /* Rest is proto3 singular fields */\n        if (PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n        {\n            /* Simple integer / float fields */\n            pb_size_t i;\n            const char *p = (const char*)field->pData;\n            for (i = 0; i < field->data_size; i++)\n            {\n                if (p[i] != 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n        else if (PB_LTYPE(type) == PB_LTYPE_BYTES)\n        {\n            const pb_bytes_array_t *bytes = (const pb_bytes_array_t*)field->pData;\n            return bytes->size == 0;\n        }\n        else if (PB_LTYPE(type) == PB_LTYPE_STRING)\n        {\n            return *(const char*)field->pData == '\\0';\n        }\n        else if (PB_LTYPE(type) == PB_LTYPE_FIXED_LENGTH_BYTES)\n        {\n            /* Fixed length bytes is only empty if its length is fixed\n             * as 0. Which would be pretty strange, but we can check\n             * it anyway. */\n            return field->data_size == 0;\n        }\n        else if (PB_LTYPE_IS_SUBMSG(type))\n        {\n            /* Check all fields in the submessage to find if any of them\n             * are non-zero. The comparison cannot be done byte-per-byte\n             * because the C struct may contain padding bytes that must\n             * be skipped. Note that usually proto3 submessages have\n             * a separate has_field that is checked earlier in this if.\n             */\n            pb_field_iter_t iter;\n            if (pb_field_iter_begin(&iter, field->submsg_desc, field->pData))\n            {\n                do\n                {\n                    if (!pb_check_proto3_default_value(&iter))\n                    {\n                        return false;\n                    }\n                } while (pb_field_iter_next(&iter));\n            }\n            return true;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        return field->pData == NULL;\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n    {\n        if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n        {\n            const pb_extension_t *extension = *(const pb_extension_t* const *)field->pData;\n            return extension == NULL;\n        }\n        else if (field->descriptor->field_callback == pb_default_field_callback)\n        {\n            pb_callback_t *pCallback = (pb_callback_t*)field->pData;\n            return pCallback->funcs.encode == NULL;\n        }\n        else\n        {\n            return field->descriptor->field_callback == NULL;\n        }\n    }\n\n    return false; /* Not typically reached, safe default for weird special cases. */\n}\n\n/* Encode a field with static or pointer allocation, i.e. one whose data\n * is available to the encoder directly. */\nstatic bool checkreturn encode_basic_field(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    if (!field->pData)\n    {\n        /* Missing pointer field */\n        return true;\n    }\n\n    if (!pb_encode_tag_for_field(stream, field))\n        return false;\n\n    switch (PB_LTYPE(field->type))\n    {\n        case PB_LTYPE_BOOL:\n            return pb_enc_bool(stream, field);\n\n        case PB_LTYPE_VARINT:\n        case PB_LTYPE_UVARINT:\n        case PB_LTYPE_SVARINT:\n            return pb_enc_varint(stream, field);\n\n        case PB_LTYPE_FIXED32:\n        case PB_LTYPE_FIXED64:\n            return pb_enc_fixed(stream, field);\n\n        case PB_LTYPE_BYTES:\n            return pb_enc_bytes(stream, field);\n\n        case PB_LTYPE_STRING:\n            return pb_enc_string(stream, field);\n\n        case PB_LTYPE_SUBMESSAGE:\n        case PB_LTYPE_SUBMSG_W_CB:\n            return pb_enc_submessage(stream, field);\n\n        case PB_LTYPE_FIXED_LENGTH_BYTES:\n            return pb_enc_fixed_length_bytes(stream, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n/* Encode a field with callback semantics. This means that a user function is\n * called to provide and encode the actual data. */\nstatic bool checkreturn encode_callback_field(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    if (field->descriptor->field_callback != NULL)\n    {\n        if (!field->descriptor->field_callback(NULL, stream, field))\n            PB_RETURN_ERROR(stream, \"callback error\");\n    }\n    return true;\n}\n\n/* Encode a single field of any callback, pointer or static type. */\nstatic bool checkreturn encode_field(pb_ostream_t *stream, pb_field_iter_t *field)\n{\n    /* Check field presence */\n    if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n    {\n        if (*(const pb_size_t*)field->pSize != field->tag)\n        {\n            /* Different type oneof field */\n            return true;\n        }\n    }\n    else if (PB_HTYPE(field->type) == PB_HTYPE_OPTIONAL)\n    {\n        if (field->pSize)\n        {\n            if (safe_read_bool(field->pSize) == false)\n            {\n                /* Missing optional field */\n                return true;\n            }\n        }\n        else if (PB_ATYPE(field->type) == PB_ATYPE_STATIC)\n        {\n            /* Proto3 singular field */\n            if (pb_check_proto3_default_value(field))\n                return true;\n        }\n    }\n\n    if (!field->pData)\n    {\n        if (PB_HTYPE(field->type) == PB_HTYPE_REQUIRED)\n            PB_RETURN_ERROR(stream, \"missing required field\");\n\n        /* Pointer field set to NULL */\n        return true;\n    }\n\n    /* Then encode field contents */\n    if (PB_ATYPE(field->type) == PB_ATYPE_CALLBACK)\n    {\n        return encode_callback_field(stream, field);\n    }\n    else if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)\n    {\n        return encode_array(stream, field);\n    }\n    else\n    {\n        return encode_basic_field(stream, field);\n    }\n}\n\n/* Default handler for extension fields. Expects to have a pb_msgdesc_t\n * pointer in the extension->type->arg field, pointing to a message with\n * only one field in it.  */\nstatic bool checkreturn default_extension_encoder(pb_ostream_t *stream, const pb_extension_t *extension)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin_extension_const(&iter, extension))\n        PB_RETURN_ERROR(stream, \"invalid extension\");\n\n    return encode_field(stream, &iter);\n}\n\n\n/* Walk through all the registered extensions and give them a chance\n * to encode themselves. */\nstatic pb_noinline bool checkreturn encode_extension_field(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    const pb_extension_t *extension = *(const pb_extension_t* const *)field->pData;\n\n    while (extension)\n    {\n        bool status;\n        if (extension->type->encode)\n            status = extension->type->encode(stream, extension);\n        else\n            status = default_extension_encoder(stream, extension);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/*********************\n * Encode all fields *\n *********************/\n\nbool checkreturn pb_encode(pb_ostream_t *stream, const pb_msgdesc_t *fields, const void *src_struct)\n{\n    pb_field_iter_t iter;\n    if (!pb_field_iter_begin_const(&iter, fields, src_struct))\n        return true; /* Empty message type */\n    \n    do {\n        if (PB_LTYPE(iter.type) == PB_LTYPE_EXTENSION)\n        {\n            /* Special case for the extension field placeholder */\n            if (!encode_extension_field(stream, &iter))\n                return false;\n        }\n        else\n        {\n            /* Regular field */\n            if (!encode_field(stream, &iter))\n                return false;\n        }\n    } while (pb_field_iter_next(&iter));\n    \n    return true;\n}\n\nbool checkreturn pb_encode_ex(pb_ostream_t *stream, const pb_msgdesc_t *fields, const void *src_struct, unsigned int flags)\n{\n  if ((flags & PB_ENCODE_DELIMITED) != 0)\n  {\n    return pb_encode_submessage(stream, fields, src_struct);\n  }\n  else if ((flags & PB_ENCODE_NULLTERMINATED) != 0)\n  {\n    const pb_byte_t zero = 0;\n\n    if (!pb_encode(stream, fields, src_struct))\n        return false;\n\n    return pb_write(stream, &zero, 1);\n  }\n  else\n  {\n    return pb_encode(stream, fields, src_struct);\n  }\n}\n\nbool pb_get_encoded_size(size_t *size, const pb_msgdesc_t *fields, const void *src_struct)\n{\n    pb_ostream_t stream = PB_OSTREAM_SIZING;\n    \n    if (!pb_encode(&stream, fields, src_struct))\n        return false;\n    \n    *size = stream.bytes_written;\n    return true;\n}\n\n/********************\n * Helper functions *\n ********************/\n\n/* This function avoids 64-bit shifts as they are quite slow on many platforms. */\nstatic bool checkreturn pb_encode_varint_32(pb_ostream_t *stream, uint32_t low, uint32_t high)\n{\n    size_t i = 0;\n    pb_byte_t buffer[10];\n    pb_byte_t byte = (pb_byte_t)(low & 0x7F);\n    low >>= 7;\n\n    while (i < 4 && (low != 0 || high != 0))\n    {\n        byte |= 0x80;\n        buffer[i++] = byte;\n        byte = (pb_byte_t)(low & 0x7F);\n        low >>= 7;\n    }\n\n    if (high)\n    {\n        byte = (pb_byte_t)(byte | ((high & 0x07) << 4));\n        high >>= 3;\n\n        while (high)\n        {\n            byte |= 0x80;\n            buffer[i++] = byte;\n            byte = (pb_byte_t)(high & 0x7F);\n            high >>= 7;\n        }\n    }\n\n    buffer[i++] = byte;\n\n    return pb_write(stream, buffer, i);\n}\n\nbool checkreturn pb_encode_varint(pb_ostream_t *stream, pb_uint64_t value)\n{\n    if (value <= 0x7F)\n    {\n        /* Fast path: single byte */\n        pb_byte_t byte = (pb_byte_t)value;\n        return pb_write(stream, &byte, 1);\n    }\n    else\n    {\n#ifdef PB_WITHOUT_64BIT\n        return pb_encode_varint_32(stream, value, 0);\n#else\n        return pb_encode_varint_32(stream, (uint32_t)value, (uint32_t)(value >> 32));\n#endif\n    }\n}\n\nbool checkreturn pb_encode_svarint(pb_ostream_t *stream, pb_int64_t value)\n{\n    pb_uint64_t zigzagged;\n    pb_uint64_t mask = ((pb_uint64_t)-1) >> 1; /* Satisfy clang -fsanitize=integer */\n    if (value < 0)\n        zigzagged = ~(((pb_uint64_t)value & mask) << 1);\n    else\n        zigzagged = (pb_uint64_t)value << 1;\n    \n    return pb_encode_varint(stream, zigzagged);\n}\n\nbool checkreturn pb_encode_fixed32(pb_ostream_t *stream, const void *value)\n{\n#if defined(PB_LITTLE_ENDIAN_8BIT) && PB_LITTLE_ENDIAN_8BIT == 1\n    /* Fast path if we know that we're on little endian */\n    return pb_write(stream, (const pb_byte_t*)value, 4);\n#else\n    uint32_t val = *(const uint32_t*)value;\n    pb_byte_t bytes[4];\n    bytes[0] = (pb_byte_t)(val & 0xFF);\n    bytes[1] = (pb_byte_t)((val >> 8) & 0xFF);\n    bytes[2] = (pb_byte_t)((val >> 16) & 0xFF);\n    bytes[3] = (pb_byte_t)((val >> 24) & 0xFF);\n    return pb_write(stream, bytes, 4);\n#endif\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool checkreturn pb_encode_fixed64(pb_ostream_t *stream, const void *value)\n{\n#if defined(PB_LITTLE_ENDIAN_8BIT) && PB_LITTLE_ENDIAN_8BIT == 1\n    /* Fast path if we know that we're on little endian */\n    return pb_write(stream, (const pb_byte_t*)value, 8);\n#else\n    uint64_t val = *(const uint64_t*)value;\n    pb_byte_t bytes[8];\n    bytes[0] = (pb_byte_t)(val & 0xFF);\n    bytes[1] = (pb_byte_t)((val >> 8) & 0xFF);\n    bytes[2] = (pb_byte_t)((val >> 16) & 0xFF);\n    bytes[3] = (pb_byte_t)((val >> 24) & 0xFF);\n    bytes[4] = (pb_byte_t)((val >> 32) & 0xFF);\n    bytes[5] = (pb_byte_t)((val >> 40) & 0xFF);\n    bytes[6] = (pb_byte_t)((val >> 48) & 0xFF);\n    bytes[7] = (pb_byte_t)((val >> 56) & 0xFF);\n    return pb_write(stream, bytes, 8);\n#endif\n}\n#endif\n\nbool checkreturn pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number)\n{\n    pb_uint64_t tag = ((pb_uint64_t)field_number << 3) | wiretype;\n    return pb_encode_varint(stream, tag);\n}\n\nbool pb_encode_tag_for_field ( pb_ostream_t* stream, const pb_field_iter_t* field )\n{\n    pb_wire_type_t wiretype;\n    switch (PB_LTYPE(field->type))\n    {\n        case PB_LTYPE_BOOL:\n        case PB_LTYPE_VARINT:\n        case PB_LTYPE_UVARINT:\n        case PB_LTYPE_SVARINT:\n            wiretype = PB_WT_VARINT;\n            break;\n        \n        case PB_LTYPE_FIXED32:\n            wiretype = PB_WT_32BIT;\n            break;\n        \n        case PB_LTYPE_FIXED64:\n            wiretype = PB_WT_64BIT;\n            break;\n        \n        case PB_LTYPE_BYTES:\n        case PB_LTYPE_STRING:\n        case PB_LTYPE_SUBMESSAGE:\n        case PB_LTYPE_SUBMSG_W_CB:\n        case PB_LTYPE_FIXED_LENGTH_BYTES:\n            wiretype = PB_WT_STRING;\n            break;\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n    \n    return pb_encode_tag(stream, wiretype, field->tag);\n}\n\nbool checkreturn pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size)\n{\n    if (!pb_encode_varint(stream, (pb_uint64_t)size))\n        return false;\n    \n    return pb_write(stream, buffer, size);\n}\n\nbool checkreturn pb_encode_submessage(pb_ostream_t *stream, const pb_msgdesc_t *fields, const void *src_struct)\n{\n    /* First calculate the message size using a non-writing substream. */\n    pb_ostream_t substream = PB_OSTREAM_SIZING;\n#if !defined(PB_NO_ENCODE_SIZE_CHECK) || PB_NO_ENCODE_SIZE_CHECK == 0\n    bool status;\n    size_t size;\n#endif\n    \n    if (!pb_encode(&substream, fields, src_struct))\n    {\n#ifndef PB_NO_ERRMSG\n        stream->errmsg = substream.errmsg;\n#endif\n        return false;\n    }\n    \n    if (!pb_encode_varint(stream, (pb_uint64_t)substream.bytes_written))\n        return false;\n    \n    if (stream->callback == NULL)\n        return pb_write(stream, NULL, substream.bytes_written); /* Just sizing */\n    \n    if (stream->bytes_written + substream.bytes_written > stream->max_size)\n        PB_RETURN_ERROR(stream, \"stream full\");\n        \n#if defined(PB_NO_ENCODE_SIZE_CHECK) && PB_NO_ENCODE_SIZE_CHECK == 1\n    return pb_encode(stream, fields, src_struct);\n#else\n    size = substream.bytes_written;\n    /* Use a substream to verify that a callback doesn't write more than\n     * what it did the first time. */\n    substream.callback = stream->callback;\n    substream.state = stream->state;\n    substream.max_size = size;\n    substream.bytes_written = 0;\n#ifndef PB_NO_ERRMSG\n    substream.errmsg = NULL;\n#endif\n    \n    status = pb_encode(&substream, fields, src_struct);\n    \n    stream->bytes_written += substream.bytes_written;\n    stream->state = substream.state;\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream.errmsg;\n#endif\n    \n    if (substream.bytes_written != size)\n        PB_RETURN_ERROR(stream, \"submsg size changed\");\n\n    return status;\n#endif\n}\n\n/* Field encoders */\n\nstatic bool checkreturn pb_enc_bool(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t value = safe_read_bool(field->pData) ? 1 : 0;\n    PB_UNUSED(field);\n    return pb_encode_varint(stream, value);\n}\n\nstatic bool checkreturn pb_enc_varint(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_UVARINT)\n    {\n        /* Perform unsigned integer extension */\n        pb_uint64_t value = 0;\n\n        if (field->data_size == sizeof(uint_least8_t))\n            value = *(const uint_least8_t*)field->pData;\n        else if (field->data_size == sizeof(uint_least16_t))\n            value = *(const uint_least16_t*)field->pData;\n        else if (field->data_size == sizeof(uint32_t))\n            value = *(const uint32_t*)field->pData;\n        else if (field->data_size == sizeof(pb_uint64_t))\n            value = *(const pb_uint64_t*)field->pData;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        return pb_encode_varint(stream, value);\n    }\n    else\n    {\n        /* Perform signed integer extension */\n        pb_int64_t value = 0;\n\n        if (field->data_size == sizeof(int_least8_t))\n            value = *(const int_least8_t*)field->pData;\n        else if (field->data_size == sizeof(int_least16_t))\n            value = *(const int_least16_t*)field->pData;\n        else if (field->data_size == sizeof(int32_t))\n            value = *(const int32_t*)field->pData;\n        else if (field->data_size == sizeof(pb_int64_t))\n            value = *(const pb_int64_t*)field->pData;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (PB_LTYPE(field->type) == PB_LTYPE_SVARINT)\n            return pb_encode_svarint(stream, value);\n#ifdef PB_WITHOUT_64BIT\n        else if (value < 0)\n            return pb_encode_varint_32(stream, (uint32_t)value, (uint32_t)-1);\n#endif\n        else\n            return pb_encode_varint(stream, (pb_uint64_t)value);\n\n    }\n}\n\nstatic bool checkreturn pb_enc_fixed(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n    if (field->data_size == sizeof(float) && PB_LTYPE(field->type) == PB_LTYPE_FIXED64)\n    {\n        return pb_encode_float_as_double(stream, *(float*)field->pData);\n    }\n#endif\n\n    if (field->data_size == sizeof(uint32_t))\n    {\n        return pb_encode_fixed32(stream, field->pData);\n    }\n#ifndef PB_WITHOUT_64BIT\n    else if (field->data_size == sizeof(uint64_t))\n    {\n        return pb_encode_fixed64(stream, field->pData);\n    }\n#endif\n    else\n    {\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n    }\n}\n\nstatic bool checkreturn pb_enc_bytes(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    const pb_bytes_array_t *bytes = NULL;\n\n    bytes = (const pb_bytes_array_t*)field->pData;\n    \n    if (bytes == NULL)\n    {\n        /* Treat null pointer as an empty bytes field */\n        return pb_encode_string(stream, NULL, 0);\n    }\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_STATIC &&\n        bytes->size > field->data_size - offsetof(pb_bytes_array_t, bytes))\n    {\n        PB_RETURN_ERROR(stream, \"bytes size exceeded\");\n    }\n    \n    return pb_encode_string(stream, bytes->bytes, (size_t)bytes->size);\n}\n\nstatic bool checkreturn pb_enc_string(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    size_t size = 0;\n    size_t max_size = (size_t)field->data_size;\n    const char *str = (const char*)field->pData;\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        max_size = (size_t)-1;\n    }\n    else\n    {\n        /* pb_dec_string() assumes string fields end with a null\n         * terminator when the type isn't PB_ATYPE_POINTER, so we\n         * shouldn't allow more than max-1 bytes to be written to\n         * allow space for the null terminator.\n         */\n        if (max_size == 0)\n            PB_RETURN_ERROR(stream, \"zero-length string\");\n\n        max_size -= 1;\n    }\n\n\n    if (str == NULL)\n    {\n        size = 0; /* Treat null pointer as an empty string */\n    }\n    else\n    {\n        const char *p = str;\n\n        /* strnlen() is not always available, so just use a loop */\n        while (size < max_size && *p != '\\0')\n        {\n            size++;\n            p++;\n        }\n\n        if (*p != '\\0')\n        {\n            PB_RETURN_ERROR(stream, \"unterminated string\");\n        }\n    }\n\n#ifdef PB_VALIDATE_UTF8\n    if (!pb_validate_utf8(str))\n        PB_RETURN_ERROR(stream, \"invalid utf8\");\n#endif\n\n    return pb_encode_string(stream, (const pb_byte_t*)str, size);\n}\n\nstatic bool checkreturn pb_enc_submessage(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    if (field->submsg_desc == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n\n    if (PB_LTYPE(field->type) == PB_LTYPE_SUBMSG_W_CB && field->pSize != NULL)\n    {\n        /* Message callback is stored right before pSize. */\n        pb_callback_t *callback = (pb_callback_t*)field->pSize - 1;\n        if (callback->funcs.encode)\n        {\n            if (!callback->funcs.encode(stream, field, &callback->arg))\n                return false;\n        }\n    }\n    \n    return pb_encode_submessage(stream, field->submsg_desc, field->pData);\n}\n\nstatic bool checkreturn pb_enc_fixed_length_bytes(pb_ostream_t *stream, const pb_field_iter_t *field)\n{\n    return pb_encode_string(stream, (const pb_byte_t*)field->pData, (size_t)field->data_size);\n}\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\nbool pb_encode_float_as_double(pb_ostream_t *stream, float value)\n{\n    union { float f; uint32_t i; } in;\n    uint_least8_t sign;\n    int exponent;\n    uint64_t mantissa;\n\n    in.f = value;\n\n    /* Decompose input value */\n    sign = (uint_least8_t)((in.i >> 31) & 1);\n    exponent = (int)((in.i >> 23) & 0xFF) - 127;\n    mantissa = in.i & 0x7FFFFF;\n\n    if (exponent == 128)\n    {\n        /* Special value (NaN etc.) */\n        exponent = 1024;\n    }\n    else if (exponent == -127)\n    {\n        if (!mantissa)\n        {\n            /* Zero */\n            exponent = -1023;\n        }\n        else\n        {\n            /* Denormalized */\n            mantissa <<= 1;\n            while (!(mantissa & 0x800000))\n            {\n                mantissa <<= 1;\n                exponent--;\n            }\n            mantissa &= 0x7FFFFF;\n        }\n    }\n\n    /* Combine fields */\n    mantissa <<= 29;\n    mantissa |= (uint64_t)(exponent + 1023) << 52;\n    mantissa |= (uint64_t)sign << 63;\n\n    return pb_encode_fixed64(stream, &mantissa);\n}\n#endif\n"
        },
        {
          "name": "pb_encode.h",
          "type": "blob",
          "size": 7.0078125,
          "content": "/* pb_encode.h: Functions to encode protocol buffers. Depends on pb_encode.c.\n * The main function is pb_encode. You also need an output stream, and the\n * field descriptions created by nanopb_generator.py.\n */\n\n#ifndef PB_ENCODE_H_INCLUDED\n#define PB_ENCODE_H_INCLUDED\n\n#include \"pb.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Structure for defining custom output streams. You will need to provide\n * a callback function to write the bytes to your storage, which can be\n * for example a file or a network socket.\n *\n * The callback must conform to these rules:\n *\n * 1) Return false on IO errors. This will cause encoding to abort.\n * 2) You can use state to store your own data (e.g. buffer pointer).\n * 3) pb_write will update bytes_written after your callback runs.\n * 4) Substreams will modify max_size and bytes_written. Don't use them\n *    to calculate any pointers.\n */\nstruct pb_ostream_s\n{\n#ifdef PB_BUFFER_ONLY\n    /* Callback pointer is not used in buffer-only configuration.\n     * Having an int pointer here allows binary compatibility but\n     * gives an error if someone tries to assign callback function.\n     * Also, NULL pointer marks a 'sizing stream' that does not\n     * write anything.\n     */\n    const int *callback;\n#else\n    bool (*callback)(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);\n#endif\n\n    /* state is a free field for use of the callback function defined above.\n     * Note that when pb_ostream_from_buffer() is used, it reserves this field\n     * for its own use.\n     */\n    void *state;\n\n    /* Limit number of output bytes written. Can be set to SIZE_MAX. */\n    size_t max_size;\n\n    /* Number of bytes written so far. */\n    size_t bytes_written;\n    \n#ifndef PB_NO_ERRMSG\n    /* Pointer to constant (ROM) string when decoding function returns error */\n    const char *errmsg;\n#endif\n};\n\n/***************************\n * Main encoding functions *\n ***************************/\n\n/* Encode a single protocol buffers message from C structure into a stream.\n * Returns true on success, false on any failure.\n * The actual struct pointed to by src_struct must match the description in fields.\n * All required fields in the struct are assumed to have been filled in.\n *\n * Example usage:\n *    MyMessage msg = {};\n *    uint8_t buffer[64];\n *    pb_ostream_t stream;\n *\n *    msg.field1 = 42;\n *    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));\n *    pb_encode(&stream, MyMessage_fields, &msg);\n */\nbool pb_encode(pb_ostream_t *stream, const pb_msgdesc_t *fields, const void *src_struct);\n\n/* Extended version of pb_encode, with several options to control the\n * encoding process:\n *\n * PB_ENCODE_DELIMITED:      Prepend the length of message as a varint.\n *                           Corresponds to writeDelimitedTo() in Google's\n *                           protobuf API.\n *\n * PB_ENCODE_NULLTERMINATED: Append a null byte to the message for termination.\n *                           NOTE: This behaviour is not supported in most other\n *                           protobuf implementations, so PB_ENCODE_DELIMITED\n *                           is a better option for compatibility.\n */\n#define PB_ENCODE_DELIMITED       0x02U\n#define PB_ENCODE_NULLTERMINATED  0x04U\nbool pb_encode_ex(pb_ostream_t *stream, const pb_msgdesc_t *fields, const void *src_struct, unsigned int flags);\n\n/* Defines for backwards compatibility with code written before nanopb-0.4.0 */\n#define pb_encode_delimited(s,f,d) pb_encode_ex(s,f,d, PB_ENCODE_DELIMITED)\n#define pb_encode_nullterminated(s,f,d) pb_encode_ex(s,f,d, PB_ENCODE_NULLTERMINATED)\n\n/* Encode the message to get the size of the encoded data, but do not store\n * the data. */\nbool pb_get_encoded_size(size_t *size, const pb_msgdesc_t *fields, const void *src_struct);\n\n/**************************************\n * Functions for manipulating streams *\n **************************************/\n\n/* Create an output stream for writing into a memory buffer.\n * The number of bytes written can be found in stream.bytes_written after\n * encoding the message.\n *\n * Alternatively, you can use a custom stream that writes directly to e.g.\n * a file or a network socket.\n */\npb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);\n\n/* Pseudo-stream for measuring the size of a message without actually storing\n * the encoded data.\n * \n * Example usage:\n *    MyMessage msg = {};\n *    pb_ostream_t stream = PB_OSTREAM_SIZING;\n *    pb_encode(&stream, MyMessage_fields, &msg);\n *    printf(\"Message size is %d\\n\", stream.bytes_written);\n */\n#ifndef PB_NO_ERRMSG\n#define PB_OSTREAM_SIZING {0,0,0,0,0}\n#else\n#define PB_OSTREAM_SIZING {0,0,0,0}\n#endif\n\n/* Function to write into a pb_ostream_t stream. You can use this if you need\n * to append or prepend some custom headers to the message.\n */\nbool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);\n\n\n/************************************************\n * Helper functions for writing field callbacks *\n ************************************************/\n\n/* Encode field header based on type and field number defined in the field\n * structure. Call this from the callback before writing out field contents. */\nbool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_iter_t *field);\n\n/* Encode field header by manually specifying wire type. You need to use this\n * if you want to write out packed arrays from a callback field. */\nbool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);\n\n/* Encode an integer in the varint format.\n * This works for bool, enum, int32, int64, uint32 and uint64 field types. */\n#ifndef PB_WITHOUT_64BIT\nbool pb_encode_varint(pb_ostream_t *stream, uint64_t value);\n#else\nbool pb_encode_varint(pb_ostream_t *stream, uint32_t value);\n#endif\n\n/* Encode an integer in the zig-zagged svarint format.\n * This works for sint32 and sint64. */\n#ifndef PB_WITHOUT_64BIT\nbool pb_encode_svarint(pb_ostream_t *stream, int64_t value);\n#else\nbool pb_encode_svarint(pb_ostream_t *stream, int32_t value);\n#endif\n\n/* Encode a string or bytes type field. For strings, pass strlen(s) as size. */\nbool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);\n\n/* Encode a fixed32, sfixed32 or float value.\n * You need to pass a pointer to a 4-byte wide C variable. */\nbool pb_encode_fixed32(pb_ostream_t *stream, const void *value);\n\n#ifndef PB_WITHOUT_64BIT\n/* Encode a fixed64, sfixed64 or double value.\n * You need to pass a pointer to a 8-byte wide C variable. */\nbool pb_encode_fixed64(pb_ostream_t *stream, const void *value);\n#endif\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n/* Encode a float value so that it appears like a double in the encoded\n * message. */\nbool pb_encode_float_as_double(pb_ostream_t *stream, float value);\n#endif\n\n/* Encode a submessage field.\n * You need to pass the pb_field_t array and pointer to struct, just like\n * with pb_encode(). This internally encodes the submessage twice, first to\n * calculate message size and then to actually write it out.\n */\nbool pb_encode_submessage(pb_ostream_t *stream, const pb_msgdesc_t *fields, const void *src_struct);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.021484375,
          "content": "protobuf\r\ngrpcio-tools"
        },
        {
          "name": "spm-test",
          "type": "tree",
          "content": null
        },
        {
          "name": "spm_headers",
          "type": "tree",
          "content": null
        },
        {
          "name": "spm_resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "zephyr",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}