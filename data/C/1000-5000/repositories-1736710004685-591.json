{
  "metadata": {
    "timestamp": 1736710004685,
    "page": 591,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TinyCC/tinycc",
      "stars": 2123,
      "defaultBranch": "mob",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.8251953125,
          "content": "*~\n\\#*\n.#*\n*.o\n*.a\n*.exe\n*.dll\n*.obj\n*.pdb\n*.lib\n*.exp\n*.log\n*.bz2\n*.zip\n.gdb_history\na.out\ntcc_g\ntcc\ntcc_c\ntcc_p\n*-tcc\nlibtcc*.def\n\nconfig*.h\n*_.h\nconfig*.mak\nconfig.texi\nconftest*\nc2str\ntags\nTAGS\ntcc.1\n*.pod\n*.tcov\ntcc-doc.html\ntcc-doc.info\n\nwin32/doc\nwin32/examples/libtcc_test.c\nwin32/libtcc\nwin32/lib/32\nwin32/lib/64\nwin32/include/float.h\nwin32/include/stdalign.h\nwin32/include/stdarg.h\nwin32/include/stdbool.h\nwin32/include/stddef.h\nwin32/include/stdnoreturn.h\nwin32/include/varargs.h\nwin32/include/tcclib.h\nwin32/include/tccdefs.h\nwin32/include/stdatomic.h\nwin32/include/tgmath.h\n\ntests/tcctest[1234]\ntests/tcctest.gcc\ntests/*.out*\ntests/*.ref\ntests/*.txt\ntests/*.gcc\ntests/*-cc*\ntests/*-tcc*\ntests/libtcc_test\ntests/libtcc_test_mt\ntests/asm-c-connect\ntests/asm-c-connect-sep\ntests/vla_test\ntests/hello\ntests/tests2/fred.txt\nlibtcc.dylib\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 25.80859375,
          "content": "\t\t  GNU LESSER GENERAL PUBLIC LICENSE\n\t\t       Version 2.1, February 1999\n\n Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicenses are intended to guarantee your freedom to share and change\nfree software--to make sure the software is free for all its users.\n\n  This license, the Lesser General Public License, applies to some\nspecially designated software packages--typically libraries--of the\nFree Software Foundation and other authors who decide to use it.  You\ncan use it too, but we suggest you first think carefully about whether\nthis license or the ordinary General Public License is the better\nstrategy to use in any particular case, based on the explanations below.\n\n  When we speak of free software, we are referring to freedom of use,\nnot price.  Our General Public Licenses are designed to make sure that\nyou have the freedom to distribute copies of free software (and charge\nfor this service if you wish); that you receive source code or can get\nit if you want it; that you can change the software and use pieces of\nit in new free programs; and that you are informed that you can do\nthese things.\n\n  To protect your rights, we need to make restrictions that forbid\ndistributors to deny you these rights or to ask you to surrender these\nrights.  These restrictions translate to certain responsibilities for\nyou if you distribute copies of the library or if you modify it.\n\n  For example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou.  You must make sure that they, too, receive or can get the source\ncode.  If you link other code with the library, you must provide\ncomplete object files to the recipients, so that they can relink them\nwith the library after making changes to the library and recompiling\nit.  And you must show them these terms so they know their rights.\n\n  We protect your rights with a two-step method: (1) we copyright the\nlibrary, and (2) we offer you this license, which gives you legal\npermission to copy, distribute and/or modify the library.\n\n  To protect each distributor, we want to make it very clear that\nthere is no warranty for the free library.  Also, if the library is\nmodified by someone else and passed on, the recipients should know\nthat what they have is not the original version, so that the original\nauthor's reputation will not be affected by problems that might be\nintroduced by others.\n\f\n  Finally, software patents pose a constant threat to the existence of\nany free program.  We wish to make sure that a company cannot\neffectively restrict the users of a free program by obtaining a\nrestrictive license from a patent holder.  Therefore, we insist that\nany patent license obtained for a version of the library must be\nconsistent with the full freedom of use specified in this license.\n\n  Most GNU software, including some libraries, is covered by the\nordinary GNU General Public License.  This license, the GNU Lesser\nGeneral Public License, applies to certain designated libraries, and\nis quite different from the ordinary General Public License.  We use\nthis license for certain libraries in order to permit linking those\nlibraries into non-free programs.\n\n  When a program is linked with a library, whether statically or using\na shared library, the combination of the two is legally speaking a\ncombined work, a derivative of the original library.  The ordinary\nGeneral Public License therefore permits such linking only if the\nentire combination fits its criteria of freedom.  The Lesser General\nPublic License permits more lax criteria for linking other code with\nthe library.\n\n  We call this license the \"Lesser\" General Public License because it\ndoes Less to protect the user's freedom than the ordinary General\nPublic License.  It also provides other free software developers Less\nof an advantage over competing non-free programs.  These disadvantages\nare the reason we use the ordinary General Public License for many\nlibraries.  However, the Lesser license provides advantages in certain\nspecial circumstances.\n\n  For example, on rare occasions, there may be a special need to\nencourage the widest possible use of a certain library, so that it becomes\na de-facto standard.  To achieve this, non-free programs must be\nallowed to use the library.  A more frequent case is that a free\nlibrary does the same job as widely used non-free libraries.  In this\ncase, there is little to gain by limiting the free library to free\nsoftware only, so we use the Lesser General Public License.\n\n  In other cases, permission to use a particular library in non-free\nprograms enables a greater number of people to use a large body of\nfree software.  For example, permission to use the GNU C Library in\nnon-free programs enables many more people to use the whole GNU\noperating system, as well as its variant, the GNU/Linux operating\nsystem.\n\n  Although the Lesser General Public License is Less protective of the\nusers' freedom, it does ensure that the user of a program that is\nlinked with the Library has the freedom and the wherewithal to run\nthat program using a modified version of the Library.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.  Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\".  The\nformer contains code derived from the library, whereas the latter must\nbe combined with the library in order to run.\n\f\n\t\t  GNU LESSER GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License Agreement applies to any software library or other\nprogram which contains a notice placed by the copyright holder or\nother authorized party saying it may be distributed under the terms of\nthis Lesser General Public License (also called \"this License\").\nEach licensee is addressed as \"you\".\n\n  A \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\n  The \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms.  A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language.  (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n  \"Source code\" for a work means the preferred form of the work for\nmaking modifications to it.  For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control compilation\nand installation of the library.\n\n  Activities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it).  Whether that is true depends on what the Library does\nand what the program that uses the Library does.\n  \n  1. You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\n  You may charge a fee for the physical act of transferring a copy,\nand you may at your option offer warranty protection in exchange for a\nfee.\n\f\n  2. You may modify your copy or copies of the Library or any portion\nof it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) The modified work must itself be a software library.\n\n    b) You must cause the files modified to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    c) You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n\n    d) If a facility in the modified Library refers to a function or a\n    table of data to be supplied by an application program that uses\n    the facility, other than as an argument passed when the facility\n    is invoked, then you must make a good faith effort to ensure that,\n    in the event an application does not supply such function or\n    table, the facility still operates, and performs whatever part of\n    its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of the\n    application.  Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may opt to apply the terms of the ordinary GNU General Public\nLicense instead of this License to a given copy of the Library.  To do\nthis, you must alter all the notices that refer to this License, so\nthat they refer to the ordinary GNU General Public License, version 2,\ninstead of to this License.  (If a newer version than version 2 of the\nordinary GNU General Public License has appeared, then you can specify\nthat version instead if you wish.)  Do not make any other change in\nthese notices.\n\f\n  Once this change is made in a given copy, it is irreversible for\nthat copy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\n  This option is useful when you wish to copy part of the code of\nthe Library into a program that is not a library.\n\n  4. You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\n  If distribution of object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the\nsource code from the same place satisfies the requirement to\ndistribute the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  5. A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\".  Such a\nwork, in isolation, is not a derivative work of the Library, and\ntherefore falls outside the scope of this License.\n\n  However, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\".  The executable is therefore covered by this License.\nSection 6 states terms for distribution of such executables.\n\n  When a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library.  The\nthreshold for this to be true is not precisely defined by law.\n\n  If such an object file uses only numerical parameters, data\nstructure layouts and accessors, and small macros and small inline\nfunctions (ten lines or less in length), then the use of the object\nfile is unrestricted, regardless of whether it is legally a derivative\nwork.  (Executables containing this object code plus portions of the\nLibrary will still fall under Section 6.)\n\n  Otherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\f\n  6. As an exception to the Sections above, you may also combine or\nlink a \"work that uses the Library\" with the Library to produce a\nwork containing portions of the Library, and distribute that work\nunder terms of your choice, provided that the terms permit\nmodification of the work for the customer's own use and reverse\nengineering for debugging such modifications.\n\n  You must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License.  You must supply a copy of this License.  If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License.  Also, you must do one\nof these things:\n\n    a) Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library.  (It is understood\n    that the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n\n    b) Use a suitable shared library mechanism for linking with the\n    Library.  A suitable mechanism is one that (1) uses at run time a\n    copy of the library already present on the user's computer system,\n    rather than copying library functions into the executable, and (2)\n    will operate properly with a modified version of the library, if\n    the user installs one, as long as the modified version is\n    interface-compatible with the version that the work was made with.\n\n    c) Accompany the work with a written offer, valid for at\n    least three years, to give the same user the materials\n    specified in Subsection 6a, above, for a charge no more\n    than the cost of performing this distribution.\n\n    d) If distribution of the work is made by offering access to copy\n    from a designated place, offer equivalent access to copy the above\n    specified materials from the same place.\n\n    e) Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\n  For an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it.  However, as a special exception,\nthe materials to be distributed need not include anything that is\nnormally distributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\n  It may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system.  Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\f\n  7. You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n    a) Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other library\n    facilities.  This must be distributed under the terms of the\n    Sections above.\n\n    b) Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n  8. You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License.  Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License.  However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n  9. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n  10. Each time you redistribute the Library (or any work based on the\nLibrary), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties with\nthis License.\n\f\n  11. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Library at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Library by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Library.\n\nIf any portion of this section is held invalid or unenforceable under any\nparticular circumstance, the balance of the section is intended to apply,\nand the section as a whole is intended to apply in other circumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  12. If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License may add\nan explicit geographical distribution limitation excluding those countries,\nso that distribution is permitted only in or among countries not thus\nexcluded.  In such case, this License incorporates the limitation as if\nwritten in the body of this License.\n\n  13. The Free Software Foundation may publish revised and/or new\nversions of the Lesser General Public License from time to time.\nSuch new versions will be similar in spirit to the present version,\nbut may differ in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation.  If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\f\n  14. If you wish to incorporate parts of the Library into other free\nprograms whose distribution conditions are incompatible with these,\nwrite to the author to ask for permission.  For software which is\ncopyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this.  Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\f\n           How to Apply These Terms to Your New Libraries\n\n  If you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change.  You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms of the\nordinary General Public License).\n\n  To apply these terms, attach the following notices to the library.  It is\nsafest to attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the library's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\nAlso add information on how to contact you by electronic and paper mail.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the library, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n\n  <signature of Ty Coon>, 1 April 1990\n  Ty Coon, President of Vice\n\nThat's all there is to it!\n\n\n"
        },
        {
          "name": "Changelog",
          "type": "blob",
          "size": 17.9033203125,
          "content": "version 0.9.28:\n\nUser interface:\n- -b : bounds checker much improved (herman ten brugge)\n- -bt : support for standalone backtraces also (grischka)\n- -gdwarf : debug format (herman ten brugge)\n- -M, -MM, and -MMD (Arthur Williams)\n- -W[no-]error=<option> (Steffen Nurpmeso)\n\nPlatforms:\n- new RISC-V (riscv64) target (Michael Matz)\n- native macOS support for x86_64 (Michael Matz, Herman ten Brugge)\n- arm and riscv64 assemblers (Danny Milosavljevic)\n- Android support with position independent executables (grischka)\n\nFeatures:\n- _Static_assert() (matthias)\n- __attribute__ ((cleanup(func))) (matthias)\n- stdatomic (Dmitry Selyutin)\n- asm goto (\"jmp %l[label]\" : : : : label) (Michael Matz)\n\nFixes:\n- ... many, see git shortlog release_0_9_27...release_0_9_27\n\nVersion 0.9.27:\n\nUser interface:\n- -x[c|a|n] filetype option (Sergey Korshunoff)\n- -P[1], -dD, -dM preprocessor options (Sergey Korshunoff)\n- -Wl,-(no-)whole-archive linker option (Reuben Thomas)\n- -mms-bitfields option (David Mertens)\n- -include <file> option (Michael Matz)\n- -mno-sse on x86-64 disables use of SSE instructions\n- @listfile support (Vlad Vissoultchev)\n- tcc -ar/-impdef - formerly tiny_xxx tools integrated (grischka)\n- CPATH, C_INCLUDE_PATH and LIBRARY_PATH environment variables support\n  (Andrew Aladjev, Urs Janssen)\n\nPlatforms:\n- new AARCH64 (arm64) target (Edmund Grimley Evans)\n- vastly improved support for ARM hard float calling convention\n   (Thomas Preud'homme, Daniel Glöckner)\n- provide a runtime library for ARM (Thomas Preud'homme)\n- many x86_64 ABI fixes incl. XMM register passing and tests (James Lyon)\n- ABI tests with native compiler using libtcc (James Lyon)\n- UNICODE startup code supports wmain and wWinMain (YX Hao)\n- shared libraries for x86_64 (Michael Matz)\n- Bootstrap native Windows 32/64 compiler using Cygwin+gcc (Christian Jullien)\n\nFeatures:\n- VLA (variable length array) improved (James Lyon, Pip Cet)\n- import functions by ordinal in .def files on windows (YX Hao)\n- x86/x86_64 assembler much improved (Michael Matz)\n- simple dead code suppression (Edmund Grimley Evans, Michael Matz, grischka)\n- implement round/fmin/fmax etc. math on windows (Avi Halachmi)\n- #pragma once support (Sergey Korshunoff, Vlad Vissoultchev, ...)\n- switch/case code improved (Zdenek Pavlas)\n- ~15% faster by TinyAlloc fast memory allocator (Vlad Vissoultchev)\n- standard conforming (and GCC compatible) struct initialization\n   (Michael Matz)\n- bit-field layout made compatible with GCC (Michael Matz)\n- UTF8 in string literals supported (Zdenek Pavlas)\n_ _Generic(...) supported (Matthias Gatto)\n\nLicensing:\n- TinyCC partly relicensed to MIT license (See RELICENSING file).\n\nversion 0.9.26:\n\nUser interface:\n- -MD/-MF (automatically generate dependencies for make)\n- -pthread option (same as -D_REENTRANT -lpthread) (Henry Kroll III)\n- -m32/-m64 to re-exec cross compiler (Henry Kroll III)\n- -Wl, Mimic all GNU -option forms supported by ld (Kirill Smelkov)\n- new LIBTCCAPI tcc_set_options() (grischka)\n\nPlatforms:\n- Many improvements for x86-64 target (Shinichiro Hamaji, Michael Matz, grischka)\n- x86-64 assembler (Frederic Feret)\n- Many improvements for ARM target (Daniel Glöckner, Thomas Preud'homme)\n- Support WinCE PE ARM (Timo VJ Lahde)\n- Support ARM hardfloat calling convention (Thomas Preud'homme)\n- Support SELinux (Security-Enhanced Linux) (Henry Kroll III)\n- Support Debian GNU/kFreeBSD kernels (Pierre Chifflier)\n- Support GNU/Hurd kernels (Thomas Preud'homme)\n- Support OSX (tcc -run only) (Milutin Jovanovic)\n- Support multiarch configuration (Thomas Preud'homme)\n- Support out-of-tree build (Akim Demaille)\n\nFeatures:\n- C99 variable length arrays (Thomas Preud'homme & Joe Soroka)\n- Asm labels for variables and functions (Thomas Preud'homme)\n- STT_GNU_IFUNC (Indirect functions as externals) (Thomas Preud'homme)\n- More tests (tests2) (Milutin Jovanovic)\n\nversion 0.9.25:\n\n- first support for x86-64 target (Shinichiro Hamaji)\n- support µClibc\n- split tcc.c into tcc.h libtcc.c tccpp.c tccgen.c tcc.c\n- improved preprocess output with linenumbers and spaces preserved\n- tcc_relocate now copies code into user buffer\n- fix bitfields with non-int types and in unions\n- improve ARM cross-compiling (Daniel Glöckner)\n- link stabstr sections from multiple objects\n- better (still limited) support for multiple TCCStates\n\nversion 0.9.24:\n\n- added verbosity levels -v, -vv, -vvv\n- Accept standard input as an inputstream (Hanzac Chen)\n- Support c89 compilers other than gcc (Hanzac Chen)\n- -soname linker option (Marc Andre Tanner)\n- Just warn about unknown directives, ignore quotes in #error/#warning\n- Define __STDC_VERSION__=199901L (477)\n- Switch to newer tccpe.c (includes support for resources)\n- Handle backslashes within #include/#error/#warning\n- Import changesets (part 4) 428,457,460,467: defines for openbsd etc.\n- Use _WIN32 for a windows hosted tcc and define it for the PE target,\n  otherwise define __unix / __linux (Detlef Riekenberg)\n- Import changesets (part 3) 409,410: ARM EABI by Daniel Glöckner\n- Some in-between fixes:\n  TCC -E no longer hangs with macro calls involving newlines.\n  (next_nomacro1 now advances the read-pointer with TOK_LINEFEED)\n  Global cast (int g_i = 1LL;) no longer crashes tcc.\n  (nocode_wanted is initially 1, and only 0 for gen_function)\n  On win32 now tcc.exe finds 'include' & 'lib' even if itself is in 'bin'.\n  (new function w32_tcc_lib_path removes 'bin' if detected)\n  Added quick build batch file for mingw (win32/build-tcc.bat)\n  Last added case label optimization (455) produced wrong code. Reverted.\n\n- Import more changesets from Rob Landley's fork (part 2):\n  487: Handle long long constants in gen_opic() (Rob Landley)\n  484: Handle parentheses within __attribute__((...)) (Rob Landley)\n  480: Remove a goto in decl_initializer_alloc (Rob Landley)\n  475: Fix dereferences in inline assembly output (Joshua Phillips)\n  474: Cast ptrs to ints of different sizes correctly (Joshua Phillips)\n  473: Fix size of structs with empty array member (Joshua Phillips)\n  470: No warning for && and || with mixed pointers/integers (Rob Landley)\n  469: Fix symbol visibility problems in the linker (Vincent Pit)\n  468: Allow && and || involving pointer arguments (Rob Landley)\n  455: Optimize case labels with no code in between (Zdenek Pavlas)\n  450: Implement alloca for x86 (grischka)\n  415: Parse unicode escape sequences (Axel Liljencrantz)\n  407: Add a simple va_copy() in stdarg.h (Hasso Tepper)\n  400: Allow typedef names as symbols (Dave Dodge)\n\n- Import some changesets from Rob Landley's fork (part 1):\n  462: Use LGPL with bcheck.c and il-gen.c\n  458: Fix global compound literals (in unary: case '&':) (Andrew Johnson)\n  456: Use return code from tcc_output_file in main() (Michael Somos)\n  442: Fix indirections with function pointers (***fn)() (grischka)\n  441: Fix LL left shift in libtcc1.c:__shldi3 (grischka)\n  440: Pass structures and function ptrs through ?: (grischka)\n  439: Keep rvalue in bit assignment (bit2 = bit1 = x) (grischka)\n  438: Degrade nonportable pointer assignment to warning (grischka)\n  437: Call 'saveregs()' before jumping with logical and/or/not (grischka)\n  435: Put local static variables into global memory (grischka)\n  432/434: Cast double and ptr to bool (grischka)\n  420: Zero pad x87 tenbyte long doubles (Felix Nawothnig)\n  417: Make 'sizeof' unsigned (Rob Landley)\n  397: Fix save_reg for longlongs (Daniel Glöckner)\n  396: Fix \"invalid relocation entry\" problem on ubuntu - (Bernhard Fischer)\n\n- ignore AS_NEEDED ld command\n- mark executable sections as executable when running in memory\n- added support for win32 wchar_t (Filip Navara)\n- segment override prefix support (Filip Navara)\n- normalized slashes in paths (Filip Navara)\n- windows style fastcall (Filip Navara)\n- support for empty input register section in asm (Filip Navara)\n- anonymous union/struct support (Filip Navara)\n- fixed parsing of function parameters\n- workaround for function pointers in conditional expressions (Dave Dodge)\n- initial '-E' option support to use the C preprocessor alone\n- discard type qualifiers when comparing function parameters (Dave Dodge)\n- Bug fix: A long long value used as a test expression ignores the\n  upper 32 bits at runtime (Dave Dodge)\n- fixed multiple concatenation of PPNUM tokens (initial patch by Dave Dodge)\n- fixed multiple typedef specifiers handling\n- fixed sign extension in some type conversions (Dave Dodge)\n\nversion 0.9.23:\n\n- initial PE executable format for windows version (grischka)\n- '#pragma pack' support (grischka)\n- '#include_next' support (Bernhard Fischer)\n- ignore '-pipe' option\n- added -f[no-]leading-underscore\n- preprocessor function macro parsing fix (grischka)\n\nversion 0.9.22:\n\n- simple memory optimisations: kernel compilation is 30% faster\n- linker symbol definitions fixes\n- gcc 3.4 fixes\n- fixed value stack full error\n- 'packed' attribute support for variables and structure fields\n- ignore 'const' and 'volatile' in function prototypes\n- allow '_Bool' in bit fields\n\nversion 0.9.21:\n\n- ARM target support (Daniel Glöckner)\n- added '-funsigned-char, '-fsigned-char' and\n  '-Wimplicit-function-declaration'\n- fixed assignment of const struct in struct\n- line comment fix (reported by Bertram Felgenhauer)\n- initial TMS320C67xx target support (TK)\n- win32 configure\n- regparm() attribute\n- many built-in assembler fixes\n- added '.org', '.fill' and '.previous' assembler directives\n- '-fno-common' option\n- '-Ttext' linker option\n- section alignment fixes\n- bit fields fixes\n- do not generate code for unused inline functions\n- '-oformat' linker option. \n- added 'binary' output format.\n\nversion 0.9.20:\n\n- added '-w' option\n- added '.gnu.linkonce' ELF sections support\n- fixed libc linking when running in memory (avoid 'stat' function\n  errors).\n- extended '-run' option to be able to give several arguments to a C\n  script.\n\nversion 0.9.19:\n\n- \"alacarte\" linking (Dave Long)\n- simpler function call\n- more strict type checks\n- added 'const' and 'volatile' support and associated warnings\n- added -Werror, -Wunsupported, -Wwrite-strings, -Wall.\n- added __builtin_types_compatible_p() and __builtin_constant_p()\n- chars support in assembler (Dave Long)\n- .string, .globl, .section, .text, .data and .bss asm directive\n  support (Dave Long)\n- man page generated from tcc-doc.texi\n- fixed macro argument substitution\n- fixed zero argument macro parsing\n- changed license to LGPL\n- added -rdynamic option support\n\nversion 0.9.18:\n\n- header fix (time.h)\n- fixed inline asm without operand case\n- fixed 'default:' or 'case x:' with '}' after (incorrect C construct accepted\n  by gcc)\n- added 'A' inline asm constraint.\n\nversion 0.9.17:\n\n- PLT generation fix\n- tcc doc fixes (Peter Lund)\n- struct parse fix (signaled by Pedro A. Aranda Gutierrez)\n- better _Bool lvalue support (signaled by Alex Measday)\n- function parameters must be converted to pointers (signaled by Neil Brown)\n- sanitized string and character constant parsing\n- fixed comment parse (signaled by Damian M Gryski)\n- fixed macro function bug (signaled by Philippe Ribet)\n- added configure (initial patch by Mitchell N Charity)\n- added '-run' and '-v' options (initial patch by vlindos)\n- added real date report in __DATE__ and __TIME__ macros\n\nversion 0.9.16:\n\n- added assembler language support\n- added GCC inline asm() support\n- fixed multiple variable definitions : uninitialized variables are\n  created as COMMON symbols.\n- optimized macro processing\n- added GCC statement expressions support\n- added GCC local labels support\n- fixed array declaration in old style function parameters\n- support casts in static structure initializations\n- added various __xxx[__] keywords for GCC compatibility\n- ignore __extension__ GCC in an expression or in a type (still not perfect)\n- added '? :' GCC extension support\n\nversion 0.9.15:\n\n- compilation fixes for glibc 2.2, gcc 2.95.3 and gcc 3.2.\n- FreeBSD compile fixes. Makefile patches still missing (Carl Drougge).\n- fixed file type guessing if '.' is in the path.\n- fixed tcc_compile_string()\n- add a dummy page in ELF files to fix RX/RW accesses (pageexec at\n  freemail dot hu).\n\nversion 0.9.14:\n\n- added #warning. error message if invalid preprocessing directive.\n- added CType structure to ease typing (faster parse).\n- suppressed secondary hash tables (faster parse).\n- rewrote parser by optimizing common cases (faster parse).\n- fixed signed long long comparisons.\n- fixed 'int a(), b();' declaration case.\n- fixed structure init without '{}'.\n- correct alignment support in structures.\n- empty structures support.\n- gcc testsuite now supported.\n- output only warning if implicit integer/pointer conversions.\n- added static bitfield init.\n\nversion 0.9.13:\n\n- correct preprocessing token pasting (## operator) in all cases (added\n  preprocessing number token).\n- fixed long long register spill.\n- fixed signed long long '>>'.\n- removed memory leaks.\n- better error handling : processing can continue on link errors. A\n  custom callback can be added to display error messages. Most\n  errors do not call exit() now.\n- ignore -O, -W, -m and -f options\n- added old style function declarations\n- added GCC __alignof__ support.\n- added GCC typeof support.\n- added GCC computed gotos support.\n- added stack backtrace in runtime error message. Improved runtime\n  error position display.\n\nversion 0.9.12:\n\n- more fixes for || and && handling.\n- improved '? :' type handling.\n- fixed bound checking generation with structures\n- force '#endif' to be in same file as matching '#if'\n- #include file optimization with '#ifndef #endif' construct detection\n- macro handling optimization\n- added tcc_relocate() and tcc_get_symbol() in libtcc.\n\nversion 0.9.11:\n\n- stdarg.h fix for double type (thanks to Philippe Ribet).\n- correct white space characters and added MSDOS newline support.\n- fixed invalid implicit function call type declaration.\n- special macros such as __LINE__ are defined if tested with defined().\n- fixed '!' operator with relocated address.\n- added symbol + offset relocation (fixes some static variable initializers)\n- '-l' option can be specified anywhere. '-c' option yields default\n  output name. added '-r' option for relocatable output.\n- fixed '\\nnn' octal parsing.\n- fixed local extern variables declarations.\n\nversion 0.9.10:\n\n- fixed lvalue type when saved in local stack.\n- fixed '#include' syntax when using macros.\n- fixed '#line' bug.\n- removed size limit on strings. Unified string constants handling\n  with variable declarations.\n- added correct support for '\\xX' in wchar_t strings.\n- added support for bound checking in generated executables\n- fixed -I include order.\n- fixed incorrect function displayed in runtime error.\n\nversion 0.9.9:\n\n- fixed preprocessor expression parsing for #if/#elif.\n- relocated debug info (.stab section).\n- relocated bounds info (.bounds section).\n- fixed cast to char of char constants ('\\377' is -1 instead of 255)\n- fixed implicit cast for unary plus.\n- strings and '__func__' have now 'char[]' type instead of 'char *'\n  (fixes sizeof() return value).\n- added __start_xxx and __stop_xxx symbols in linker.\n- better DLL creation support (option -shared begins to work).\n- ELF sections and hash tables are resized dynamically.\n- executables and DLLs are stripped by default.\n\nversion 0.9.8:\n\n- First version of full ELF linking support (generate objects, static\n  executable, dynamic executable, dynamic libraries). Dynamic library\n  support is not finished (need PIC support in compiler and some\n  patches in symbol exporting).\n- First version of ELF loader for object (.o) and archive (.a) files.\n- Support of simple GNU ld scripts (GROUP and FILE commands)\n- Separated runtime library and bound check code from TCC (smaller\n  compiler core).\n- fixed register reload in float compare.\n- fixed implicit char/short to int casting.\n- allow array type for address of ('&') operator.\n- fixed unused || or && result.\n- added GCC style variadic macro support.\n- optimized bound checking code for array access.\n- tcc includes are now in $(prefix)/lib/tcc/include.\n- more command line options - more consistent handling of multiple\n  input files.\n- added tcc man page (thanks to Cyril Bouthors).\n- uClibc Makefile update\n- converted documentation to texinfo format.\n- added developper's guide in documentation.\n\nversion 0.9.7:\n\n- added library API for easy dynamic compilation (see libtcc.h - first\n  draft).\n- fixed long long register spill bug.\n- fixed '? :' register spill bug.\n\nversion 0.9.6:\n\n- added floating point constant propagation (fixes negative floating\n  point constants bug).\n\nversion 0.9.5:\n\n - uClibc patches (submitted by Alfonso Martone).\n - error reporting fix\n - added CONFIG_TCC_BCHECK to get smaller code if needed.\n\nversion 0.9.4:\n\n - windows port (currently cannot use -g, -b and dll functions).\n - faster and simpler I/O handling.\n - '-D' option works in all cases.\n - preprocessor fixes (#elif and empty macro args)\n - floating point fixes\n - first code for CIL generation (does not work yet)\n\nversion 0.9.3:\n\n - better and smaller code generator.\n - full ISOC99 64 bit 'long long' support.\n - full 32 bit 'float', 64 bit 'double' and 96 bit 'long double' support.\n - added '-U' option.\n - added assembly sections support. \n - even faster startup time by mmaping sections instead of mallocing them.\n - added GNUC __attribute__ keyword support (currently supports\n    'section' and 'aligned' attributes).\n - added ELF file output (only usable for debugging now)\n - added debug symbol generation (STAB format).\n - added integrated runtime error analysis ('-g' option: print clear\n   run time error messages instead of \"Segmentation fault\").\n - added first version of tiny memory and bound checker ('-b' option).\n\nversion 0.9.2:\n\n - even faster parsing.\n - various syntax parsing fixes.\n - fixed external relocation handling for variables or functions pointers.\n - better function pointers type handling.\n - can compile multiple files (-i option).\n - ANSI C bit fields are supported.\n - beginning of float/double/long double support.\n - beginning of long long support.\n\nversion 0.9.1:\n\n - full ISOC99 initializers handling.\n - compound literals.\n - structures handle in assignments and as function param or return value.\n - wide chars and strings.\n - macro bug fix\n\nversion 0.9:\n - initial version.\n"
        },
        {
          "name": "CodingStyle",
          "type": "blob",
          "size": 2.0625,
          "content": "\nIn general, use the same coding style as the surrounding code.\n\nHowever, do not make any unnecessary changes as that complicates\nthe VCS (git) history and makes it harder to merge patches. So\ndo not modify code just to make it conform to a coding style.\n\n    Indentation\n\nTurn on a \"fill tabs with spaces\" option in your editor.\n\nRemove tabs and trailing spaces from any lines that are modified.\n\nNote that some files are indented with 2 spaces (when they\nhave large indentation) while most are indented with 4 spaces.\n\n    Language\n\nTCC is mostly implemented in C90. Do not use any non-C90 features\nthat are not already in use.\n\nNon-C90 features currently in use, as revealed by\n./configure --extra-cflags=\"-std=c90 -Wpedantic\":\n\n- long long (including \"LL\" constants)\n- inline\n- very long string constants\n- assignment between function pointer and 'void *'\n- \"//\" comments\n- empty macro arguments (DEF_ASMTEST in i386-tok.h)\n- unnamed struct and union fields (in struct Sym), a C11 feature\n\n    Testing\n\nA simple \"make test\" is sufficient for some simple changes. However,\nbefore committing a change consider performing some of the following\nadditional tests:\n\n- Build and run \"make test\" on several architectures.\n\n- Build with ./configure --enable-cross.\n\n- If the generation of relocations has been changed, try compiling\n  with TCC and linking with GCC/Clang. If the linker has been\n  modified, try compiling with GCC/Clang and linking with TCC.\n\n- Test with ASan/UBSan to detect memory corruption and undefined behaviour:\n\nmake clean\n./configure\nmake\nmake test\ncp libtcc.a libtcc.a.hide\n\nmake clean\n./configure --extra-cflags=\"-fsanitize=address,undefined -g\"\nmake\ncp libtcc.a.hide libtcc.a\nmake test\n\n- Test with Valgrind to detect some uses of uninitialised values:\n\nmake clean\n./configure\nmake\n# On Intel, because Valgrind does floating-point arithmetic differently:\n( cd tests && gcc -I.. tcctest.c && valgrind -q ./a.out > test.ref )\nmake test TCC=\"valgrind -q --leak-check=full `pwd`/tcc -B`pwd` -I`pwd`\"\n\n  (Because of how VLAs are implemented, invalid reads are expected\n  with 79_vla_continue.)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 17.3798828125,
          "content": "# --------------------------------------------------------------------------\n#\n# Tiny C Compiler Makefile\n#\n\nifndef TOP\n TOP = .\n INCLUDED = no\nendif\n\nifeq ($(findstring $(MAKECMDGOALS),clean distclean),)\n include $(TOP)/config.mak\nendif\n\nifeq (-$(GCC_MAJOR)-$(findstring $(GCC_MINOR),56789)-,-4--)\n CFLAGS += -D_FORTIFY_SOURCE=0\nendif\n\nLIBTCC = libtcc.a\nLIBTCC1 = libtcc1.a\nLINK_LIBTCC =\nLIBS =\nCFLAGS += $(CPPFLAGS)\nVPATH = $(TOPSRC)\n-LTCC = $(TOP)/$(LIBTCC)\n\nifdef CONFIG_WIN32\n CFG = -win\n ifneq ($(CONFIG_static),yes)\n  LIBTCC = libtcc$(DLLSUF)\n  LIBTCCDEF = libtcc.def\n endif\n ifneq ($(CONFIG_debug),yes)\n  LDFLAGS += -s\n endif\n NATIVE_TARGET = $(ARCH)-win$(if $(findstring arm,$(ARCH)),ce,32)\nelse\n CFG = -unx\n LIBS+=-lm\n ifneq ($(CONFIG_ldl),no)\n  LIBS+=-ldl\n endif\n ifneq ($(CONFIG_pthread),no)\n  LIBS+=-lpthread\n endif\n # make libtcc as static or dynamic library?\n ifeq ($(CONFIG_static),no)\n  LIBTCC=libtcc$(DLLSUF)\n  export LD_LIBRARY_PATH := $(CURDIR)/$(TOP)\n  ifneq ($(CONFIG_rpath),no)\n    ifndef CONFIG_OSX\n      LINK_LIBTCC += -Wl,-rpath,\"$(libdir)\"\n    else\n      # macOS doesn't support env-vars libdir out of the box - which we need for\n      # `make test' when libtcc.dylib is used (configure --disable-static), so\n      # we bake a relative path into the binary. $libdir is used after install.\n      LINK_LIBTCC += -Wl,-rpath,\"@executable_path/$(TOP)\" -Wl,-rpath,\"$(libdir)\"\n      # -current/compatibility_version must not contain letters.\n      MACOS_DYLIB_VERSION := $(firstword $(subst rc, ,$(VERSION)))\n      DYLIBVER += -current_version $(MACOS_DYLIB_VERSION)\n      DYLIBVER += -compatibility_version $(MACOS_DYLIB_VERSION)\n    endif\n  endif\n endif\n NATIVE_TARGET = $(ARCH)\n ifdef CONFIG_OSX\n  NATIVE_TARGET = $(ARCH)-osx\n  ifneq ($(CC_NAME),tcc)\n    LDFLAGS += -flat_namespace\n    ifneq (1,$(shell expr $(GCC_MAJOR) \">=\" 15))\n      LDFLAGS += -undefined warning # depreciated in clang >= 15.0\n    endif\n  endif\n  export MACOSX_DEPLOYMENT_TARGET := 10.6\n endif\nendif\n\n# run local version of tcc with local libraries and includes\nTCCFLAGS-unx = -B$(TOP) -I$(TOPSRC)/include -I$(TOPSRC) -I$(TOP)\nTCCFLAGS-win = -B$(TOPSRC)/win32 -I$(TOPSRC)/include -I$(TOPSRC) -I$(TOP) -L$(TOP)\nTCCFLAGS = $(TCCFLAGS$(CFG))\nTCC_LOCAL = $(TOP)/tcc$(EXESUF)\nTCC = $(TCC_LOCAL) $(TCCFLAGS)\n\n# run tests with the installed tcc instead\nifdef TESTINSTALL\n  TCC_LOCAL = $(bindir)/tcc\n  TCCFLAGS-unx = -I$(TOP)\n  TCCFLAGS-win = -B$(bindir) -I$(TOP)\n  -LTCC = $(libdir)/$(LIBTCC) $(LINK_LIBTCC)\nendif\n\nCFLAGS_P = $(CFLAGS) -pg -static -DCONFIG_TCC_STATIC -DTCC_PROFILE\nLIBS_P = $(LIBS)\nLDFLAGS_P = $(LDFLAGS)\n\nDEF-i386           = -DTCC_TARGET_I386\nDEF-i386-win32     = -DTCC_TARGET_I386 -DTCC_TARGET_PE\nDEF-i386-OpenBSD   = $(DEF-i386) -DTARGETOS_OpenBSD\nDEF-x86_64         = -DTCC_TARGET_X86_64\nDEF-x86_64-win32   = -DTCC_TARGET_X86_64 -DTCC_TARGET_PE\nDEF-x86_64-osx     = -DTCC_TARGET_X86_64 -DTCC_TARGET_MACHO\nDEF-arm-fpa        = -DTCC_TARGET_ARM\nDEF-arm-fpa-ld     = -DTCC_TARGET_ARM -DLDOUBLE_SIZE=12\nDEF-arm-vfp        = -DTCC_TARGET_ARM -DTCC_ARM_VFP\nDEF-arm-eabi       = -DTCC_TARGET_ARM -DTCC_ARM_VFP -DTCC_ARM_EABI\nDEF-arm-eabihf     = $(DEF-arm-eabi) -DTCC_ARM_HARDFLOAT\nDEF-arm            = $(DEF-arm-eabihf)\nDEF-arm-NetBSD     = $(DEF-arm-eabihf) -DTARGETOS_NetBSD\nDEF-arm-wince      = $(DEF-arm-eabihf) -DTCC_TARGET_PE\nDEF-arm64          = -DTCC_TARGET_ARM64\nDEF-arm64-osx      = $(DEF-arm64) -DTCC_TARGET_MACHO\nDEF-arm64-FreeBSD  = $(DEF-arm64) -DTARGETOS_FreeBSD\nDEF-arm64-NetBSD   = $(DEF-arm64) -DTARGETOS_NetBSD\nDEF-arm64-OpenBSD  = $(DEF-arm64) -DTARGETOS_OpenBSD\nDEF-riscv64        = -DTCC_TARGET_RISCV64\nDEF-c67            = -DTCC_TARGET_C67 -w # disable warnigs\nDEF-x86_64-FreeBSD = $(DEF-x86_64) -DTARGETOS_FreeBSD\nDEF-x86_64-NetBSD  = $(DEF-x86_64) -DTARGETOS_NetBSD\nDEF-x86_64-OpenBSD = $(DEF-x86_64) -DTARGETOS_OpenBSD\n\nifeq ($(INCLUDED),no)\n# --------------------------------------------------------------------------\n# running top Makefile\n\nPROGS = tcc$(EXESUF)\nTCCLIBS = $(LIBTCCDEF) $(LIBTCC) $(LIBTCC1)\nTCCDOCS = tcc.1 tcc-doc.html tcc-doc.info\n\nall: $(PROGS) $(TCCLIBS) $(TCCDOCS)\n\n# cross compiler targets to build\nTCC_X = i386 x86_64 i386-win32 x86_64-win32 x86_64-osx arm arm64 arm-wince c67\nTCC_X += riscv64 arm64-osx\n# TCC_X += arm-fpa arm-fpa-ld arm-vfp arm-eabi\n\n# cross libtcc1.a targets to build\nLIBTCC1_X = $(filter-out c67,$(TCC_X))\n\nPROGS_CROSS = $(foreach X,$(TCC_X),$X-tcc$(EXESUF))\nLIBTCC1_CROSS = $(foreach X,$(LIBTCC1_X),$X-libtcc1.a)\n\n# build cross compilers & libs\ncross: $(LIBTCC1_CROSS) $(PROGS_CROSS)\n\n# build specific cross compiler & lib\ncross-%: %-tcc$(EXESUF) %-libtcc1.a ;\n\ninstall: ; @$(MAKE) --no-print-directory  install$(CFG)\ninstall-strip: ; @$(MAKE) --no-print-directory  install$(CFG) CONFIG_strip=yes\nuninstall: ; @$(MAKE) --no-print-directory uninstall$(CFG)\n\nifdef CONFIG_cross\nall : cross\nendif\n\n# --------------------------------------------\n\nT = $(or $(CROSS_TARGET),$(NATIVE_TARGET),unknown)\nX = $(if $(CROSS_TARGET),$(CROSS_TARGET)-)\n\nDEFINES += $(DEF-$T)\nDEFINES += $(if $(ROOT-$T),-DCONFIG_SYSROOT=\"\\\"$(ROOT-$T)\\\"\")\nDEFINES += $(if $(CRT-$T),-DCONFIG_TCC_CRTPREFIX=\"\\\"$(CRT-$T)\\\"\")\nDEFINES += $(if $(LIB-$T),-DCONFIG_TCC_LIBPATHS=\"\\\"$(LIB-$T)\\\"\")\nDEFINES += $(if $(INC-$T),-DCONFIG_TCC_SYSINCLUDEPATHS=\"\\\"$(INC-$T)\\\"\")\nDEFINES += $(if $(ELF-$T),-DCONFIG_TCC_ELFINTERP=\"\\\"$(ELF-$T)\\\"\")\nDEFINES += $(DEF-$(or $(findstring win,$T),unx))\n\nifneq ($(X),)\n$(if $(DEF-$T),,$(error error: unknown target: '$T'))\nDEF-$(NATIVE_TARGET) =\nDEF-$T += -DCONFIG_TCC_CROSSPREFIX=\"\\\"$X\\\"\"\nifneq ($(CONFIG_WIN32),yes)\nDEF-win += -DCONFIG_TCCDIR=\"\\\"$(tccdir)/win32\\\"\"\nendif\nelse\n# using values from config.h\nDEF-$(NATIVE_TARGET) =\nendif\n\n# include custom configuration (see make help)\n-include config-extra.mak\n\nifneq ($(T),$(NATIVE_TARGET))\n# assume support files for cross-targets in \"/usr/<triplet>\" by default\nTRIPLET-i386 ?= i686-linux-gnu\nTRIPLET-x86_64 ?= x86_64-linux-gnu\nTRIPLET-arm ?= arm-linux-gnueabi\nTRIPLET-arm64 ?= aarch64-linux-gnu\nTRIPLET-riscv64 ?= riscv64-linux-gnu\nMARCH-i386 ?= i386-linux-gnu\nMARCH-$T ?= $(TRIPLET-$T)\nTR = $(if $(TRIPLET-$T),$T,ignored)\nCRT-$(TR) ?= /usr/$(TRIPLET-$T)/lib\nLIB-$(TR) ?= {B}:/usr/$(TRIPLET-$T)/lib:/usr/lib/$(MARCH-$T)\nINC-$(TR) ?= {B}/include:/usr/$(TRIPLET-$T)/include:/usr/include\nendif\n\nCORE_FILES = tcc.c tcctools.c libtcc.c tccpp.c tccgen.c tccdbg.c tccelf.c tccasm.c tccrun.c\nCORE_FILES += tcc.h config.h libtcc.h tcctok.h\ni386_FILES = $(CORE_FILES) i386-gen.c i386-link.c i386-asm.c i386-asm.h i386-tok.h\ni386-win32_FILES = $(i386_FILES) tccpe.c\nx86_64_FILES = $(CORE_FILES) x86_64-gen.c x86_64-link.c i386-asm.c x86_64-asm.h\nx86_64-win32_FILES = $(x86_64_FILES) tccpe.c\nx86_64-osx_FILES = $(x86_64_FILES) tccmacho.c\narm_FILES = $(CORE_FILES) arm-gen.c arm-link.c arm-asm.c arm-tok.h\narm-wince_FILES = $(arm_FILES) tccpe.c\narm-eabihf_FILES = $(arm_FILES)\narm-fpa_FILES     = $(arm_FILES)\narm-fpa-ld_FILES  = $(arm_FILES)\narm-vfp_FILES     = $(arm_FILES)\narm-eabi_FILES    = $(arm_FILES)\narm-eabihf_FILES  = $(arm_FILES)\narm64_FILES = $(CORE_FILES) arm64-gen.c arm64-link.c arm64-asm.c\narm64-osx_FILES = $(arm64_FILES) tccmacho.c\nc67_FILES = $(CORE_FILES) c67-gen.c c67-link.c tcccoff.c\nriscv64_FILES = $(CORE_FILES) riscv64-gen.c riscv64-link.c riscv64-asm.c\n\nTCCDEFS_H$(subst yes,,$(CONFIG_predefs)) = tccdefs_.h\n\n# libtcc sources\nLIBTCC_SRC = $(filter-out tcc.c tcctools.c,$(filter %.c,$($T_FILES)))\n\nifeq ($(ONE_SOURCE),yes)\nLIBTCC_OBJ = $(X)libtcc.o\nLIBTCC_INC = $($T_FILES)\nTCC_FILES = $(X)tcc.o\n$(X)tcc.o $(X)libtcc.o : $(TCCDEFS_H)\nelse\nLIBTCC_OBJ = $(patsubst %.c,$(X)%.o,$(LIBTCC_SRC))\nLIBTCC_INC = $(filter %.h %-gen.c %-link.c,$($T_FILES))\nTCC_FILES = $(X)tcc.o $(LIBTCC_OBJ)\n$(X)tccpp.o : $(TCCDEFS_H)\n$(X)libtcc.o : DEFINES += -DONE_SOURCE=0\n$(CROSS_TARGET)-tcc.o : DEFINES += -DONE_SOURCE=0\nendif\n# native tcc always made from tcc.o and libtcc.[so|a]\ntcc.o : DEFINES += -DONE_SOURCE=0\nDEFINES += -I$(TOP)\n\nGITHASH:=$(shell git rev-parse --abbrev-ref HEAD 2>/dev/null || echo no)\nifneq ($(GITHASH),no)\nGITHASH:=$(shell git log -1 --date=short --pretty='format:%cd $(GITHASH)@%h')\nGITMODF:=$(shell git diff --quiet || echo '*')\nDEF_GITHASH:= -DTCC_GITHASH=\"\\\"$(GITHASH)$(GITMODF)\\\"\"\nendif\n\nifeq ($(CONFIG_debug),yes)\nCFLAGS += -g\nLDFLAGS += -g\nendif\n\n# convert \"include/tccdefs.h\" to \"tccdefs_.h\"\n%_.h : include/%.h conftest.c\n\t$S$(CC) -DC2STR $(filter %.c,$^) -o c2str.exe && ./c2str.exe $< $@\n\n# target specific object rule\n$(X)%.o : %.c $(LIBTCC_INC)\n\t$S$(CC) -o $@ -c $< $(addsuffix ,$(DEFINES) $(CFLAGS))\n\n# additional dependencies\n$(X)tcc.o : tcctools.c\n$(X)tcc.o : DEFINES += $(DEF_GITHASH)\n\n# Host Tiny C Compiler\ntcc$(EXESUF): tcc.o $(LIBTCC)\n\t$S$(CC) -o $@ $^ $(addsuffix ,$(LIBS) $(LDFLAGS) $(LINK_LIBTCC))\n\n# Cross Tiny C Compilers\n# (the TCCDEFS_H dependency is only necessary for parallel makes,\n# ala 'make -j x86_64-tcc i386-tcc tcc', which would create multiple\n# c2str.exe and tccdefs_.h files in parallel, leading to access errors.\n# This forces it to be made only once.  Make normally tracks multiple paths\n# to the same goals and only remakes it once, but that doesn't work over\n# sub-makes like in this target)\n%-tcc$(EXESUF): $(TCCDEFS_H) FORCE\n\t@$(MAKE) --no-print-directory $@ CROSS_TARGET=$* ONE_SOURCE=$(or $(ONE_SOURCE),yes)\n\n$(CROSS_TARGET)-tcc$(EXESUF): $(TCC_FILES)\n\t$S$(CC) -o $@ $^ $(LIBS) $(LDFLAGS)\n\n# profiling version\ntcc_p$(EXESUF): $($T_FILES)\n\t$S$(CC) -o $@ $< $(DEFINES) $(CFLAGS_P) $(LIBS_P) $(LDFLAGS_P)\n\n# static libtcc library\nlibtcc.a: $(LIBTCC_OBJ)\n\t$S$(AR) rcs $@ $^\n\n# dynamic libtcc library\nlibtcc.so: $(LIBTCC_OBJ)\n\t$S$(CC) -shared -Wl,-soname,$@ -o $@ $^ $(LIBS) $(LDFLAGS)\n\nlibtcc.so: override CFLAGS += -fPIC\nlibtcc.so: override LDFLAGS += -fPIC\n\n# OSX dynamic libtcc library\nlibtcc.dylib: $(LIBTCC_OBJ)\n\t$S$(CC) -dynamiclib $(DYLIBVER) -install_name @rpath/$@ -o $@ $^ $(LDFLAGS) \n\n# OSX libtcc.dylib (without rpath/ prefix)\nlibtcc.osx: $(LIBTCC_OBJ)\n\t$S$(CC) -shared -install_name libtcc.dylib -o libtcc.dylib $^ $(LDFLAGS) \n\n# windows dynamic libtcc library\nlibtcc.dll : $(LIBTCC_OBJ)\n\t$S$(CC) -shared -o $@ $^ $(LDFLAGS)\nlibtcc.dll : DEFINES += -DLIBTCC_AS_DLL\n\n# import file for windows libtcc.dll\nlibtcc.def : libtcc.dll tcc$(EXESUF)\n\t$S$(XTCC) -impdef $< -o $@\nXTCC ?= ./tcc$(EXESUF)\n\n# TinyCC runtime libraries\nlibtcc1.a : tcc$(EXESUF) FORCE\n\t@$(MAKE) -C lib\n\n# Cross libtcc1.a\n%-libtcc1.a : %-tcc$(EXESUF) FORCE\n\t@$(MAKE) -C lib CROSS_TARGET=$*\n\n.PRECIOUS: %-libtcc1.a\nFORCE:\n\n# WHICH = which $1 2>/dev/null\n# some versions of gnu-make do not recognize 'command' as a shell builtin\nWHICH = sh -c 'command -v $1'\n\nrun-if = $(if $(shell $(call WHICH,$1)),$S $1 $2)\nS = $(if $(findstring yes,$(SILENT)),@$(info * $@))\n\n# --------------------------------------------------------------------------\n# documentation and man page\ntcc-doc.html: tcc-doc.texi\n\t$(call run-if,makeinfo,--no-split --html --number-sections -o $@ $<)\n\ntcc-doc.info: tcc-doc.texi\n\t$(call run-if,makeinfo,$< || true)\n\ntcc.1 : tcc-doc.pod\n\t$(call run-if,pod2man,--section=1 --center=\"Tiny C Compiler\" \\\n\t\t--release=\"$(VERSION)\" $< >$@)\n%.pod : %.texi\n\t$(call run-if,perl,$(TOPSRC)/texi2pod.pl $< $@)\n\ndoc : $(TCCDOCS)\n\n# --------------------------------------------------------------------------\n# install\n\nINSTALL = install -m644\nINSTALLBIN = install -m755 $(STRIP_$(CONFIG_strip))\nSTRIP_yes = -s\n\nLIBTCC1_W = $(filter %-win32-libtcc1.a %-wince-libtcc1.a,$(LIBTCC1_CROSS))\nLIBTCC1_U = $(filter-out $(LIBTCC1_W),$(wildcard *-libtcc1.a))\nIB = $(if $1,$(IM) mkdir -p $2 && $(INSTALLBIN) $1 $2)\nIBw = $(call IB,$(wildcard $1),$2)\nIF = $(if $1,$(IM) mkdir -p $2 && $(INSTALL) $1 $2)\nIFw = $(call IF,$(wildcard $1),$2)\nIR = $(IM) mkdir -p $2 && cp -r $1/. $2\nIM = @echo \"-> $2 : $1\" ;\nBINCHECK = $(if $(wildcard $(PROGS) *-tcc$(EXESUF)),,@echo \"Makefile: nothing found to install\" && exit 1)\n\nEXTRA_O = runmain.o bt-exe.o bt-dll.o bt-log.o bcheck.o\n\n# install progs & libs\ninstall-unx:\n\t$(call BINCHECK)\n\t$(call IBw,$(PROGS) *-tcc,\"$(bindir)\")\n\t$(call IFw,$(LIBTCC1) $(EXTRA_O) $(LIBTCC1_U),\"$(tccdir)\")\n\t$(call IF,$(TOPSRC)/include/*.h $(TOPSRC)/tcclib.h,\"$(tccdir)/include\")\n\t$(call $(if $(findstring .so,$(LIBTCC)),IBw,IFw),$(LIBTCC),\"$(libdir)\")\n\t$(call IF,$(TOPSRC)/libtcc.h,\"$(includedir)\")\n\t$(call IFw,tcc.1,\"$(mandir)/man1\")\n\t$(call IFw,tcc-doc.info,\"$(infodir)\")\n\t$(call IFw,tcc-doc.html,\"$(docdir)\")\nifneq \"$(wildcard $(LIBTCC1_W))\" \"\"\n\t$(call IFw,$(TOPSRC)/win32/lib/*.def $(LIBTCC1_W),\"$(tccdir)/win32/lib\")\n\t$(call IR,$(TOPSRC)/win32/include,\"$(tccdir)/win32/include\")\n\t$(call IF,$(TOPSRC)/include/*.h $(TOPSRC)/tcclib.h,\"$(tccdir)/win32/include\")\nendif\n\n# uninstall\nuninstall-unx:\n\t@rm -fv $(addprefix \"$(bindir)/\",$(PROGS) $(PROGS_CROSS))\n\t@rm -fv $(addprefix \"$(libdir)/\", libtcc*.a libtcc*.so libtcc.dylib,$P)\n\t@rm -fv $(addprefix \"$(includedir)/\", libtcc.h)\n\t@rm -fv \"$(mandir)/man1/tcc.1\" \"$(infodir)/tcc-doc.info\"\n\t@rm -fv \"$(docdir)/tcc-doc.html\"\n\t@rm -frv \"$(tccdir)\"\n\n# install progs & libs on windows\ninstall-win:\n\t$(call BINCHECK)\n\t$(call IBw,$(PROGS) *-tcc.exe libtcc.dll,\"$(bindir)\")\n\t$(call IF,$(TOPSRC)/win32/lib/*.def,\"$(tccdir)/lib\")\n\t$(call IFw,libtcc1.a $(EXTRA_O) $(LIBTCC1_W),\"$(tccdir)/lib\")\n\t$(call IF,$(TOPSRC)/include/*.h $(TOPSRC)/tcclib.h,\"$(tccdir)/include\")\n\t$(call IR,$(TOPSRC)/win32/include,\"$(tccdir)/include\")\n\t$(call IR,$(TOPSRC)/win32/examples,\"$(tccdir)/examples\")\n\t$(call IF,$(TOPSRC)/tests/libtcc_test.c,\"$(tccdir)/examples\")\n\t$(call IFw,$(TOPSRC)/libtcc.h libtcc.def libtcc.a,\"$(libdir)\")\n\t$(call IFw,$(TOPSRC)/win32/tcc-win32.txt tcc-doc.html,\"$(docdir)\")\nifneq \"$(wildcard $(LIBTCC1_U))\" \"\"\n\t$(call IFw,$(LIBTCC1_U),\"$(tccdir)/lib\")\n\t$(call IF,$(TOPSRC)/include/*.h $(TOPSRC)/tcclib.h,\"$(tccdir)/lib/include\")\nendif\n\n# uninstall on windows\nuninstall-win:\n\t@rm -fv $(foreach P,libtcc*.dll $(PROGS) *-tcc.exe,\"$(bindir)\"/$P)\n\t@rm -fr $(foreach P,doc examples include lib libtcc,\"$(tccdir)\"/$P/*)\n\t@rm -frv $(foreach P,doc examples include lib libtcc,\"$(tccdir)\"/$P)\n\n# the msys-git shell works to configure && make except it does not have install\nifeq ($(OS),Windows_NT)\nifeq ($(shell $(call WHICH,install) || echo no),no)\nINSTALL = cp\nINSTALLBIN = cp\nendif\nendif\n\n# --------------------------------------------------------------------------\n# other stuff\n\nTAGFILES = *.[ch] include/*.h lib/*.[chS]\ntags : ; ctags $(TAGFILES)\n# cannot have both tags and TAGS on windows\nETAGS : ; etags $(TAGFILES)\n\n# create release tarball from *current* git branch (including tcc-doc.html\n# and converting two files to CRLF)\nTCC-VERSION = tcc-$(VERSION)\nTCC-VERSION = tinycc-mob-$(shell git rev-parse --short=7 HEAD)\ntar:    tcc-doc.html\n\tmkdir -p $(TCC-VERSION)\n\t( cd $(TCC-VERSION) && git --git-dir ../.git checkout -f )\n\tcp tcc-doc.html $(TCC-VERSION)\n\tfor f in tcc-win32.txt build-tcc.bat ; do \\\n\t    cat win32/$$f | sed 's,\\(.*\\),\\1\\r,g' > $(TCC-VERSION)/win32/$$f ; \\\n\tdone\n\ttar cjf $(TCC-VERSION).tar.bz2 $(TCC-VERSION)\n\trm -rf $(TCC-VERSION)\n\tgit reset\n\nconfig.mak:\n\t$(if $(wildcard $@),,@echo \"Please run ./configure.\" && exit 1)\n\n# run all tests\ntest:\n\t@$(MAKE) -C tests\n# run test(s) from tests2 subdir (see make help)\ntests2.%:\n\t@$(MAKE) -C tests/tests2 $@\n# run test(s) from testspp subdir (see make help)\ntestspp.%:\n\t@$(MAKE) -C tests/pp $@\n# run tests with code coverage\ntcov-tes% : tcc_c$(EXESUF)\n\t@rm -f $<.tcov\n\t@$(MAKE) --no-print-directory TCC_LOCAL=$(CURDIR)/$< tes$*\ntcc_c$(EXESUF): $($T_FILES)\n\t$S$(TCC) tcc.c -o $@ -ftest-coverage $(DEFINES) $(LIBS)\n# test the installed tcc instead\ntest-install: $(TCCDEFS_H)\n\t@$(MAKE) -C tests TESTINSTALL=yes #_all\n\nclean:\n\t@rm -f tcc *-tcc tcc_p tcc_c\n\t@rm -f tags ETAGS *.o *.a *.so* *.out *.log lib*.def *.exe *.dll\n\t@rm -f a.out *.dylib *_.h *.pod *.tcov\n\t@$(MAKE) -s -C lib $@\n\t@$(MAKE) -s -C tests $@\n\ndistclean: clean\n\t@rm -vf config.h config.mak config.texi\n\t@rm -vf $(TCCDOCS)\n\n.PHONY: all clean test tar tags ETAGS doc distclean install uninstall FORCE\n\nhelp:\n\t@echo \"make\"\n\t@echo \"   build native compiler (from separate objects)\"\n\t@echo \"make cross\"\n\t@echo \"   build cross compilers (from one source)\"\n\t@echo \"make ONE_SOURCE=no/yes SILENT=no/yes\"\n\t@echo \"   force building from separate/one object(s), less/more silently\"\n\t@echo \"make cross-TARGET\"\n\t@echo \"   build one specific cross compiler for 'TARGET'. Currently supported:\"\n\t@echo \"   $(wordlist 1,8,$(TCC_X))\"\n\t@echo \"   $(wordlist 9,99,$(TCC_X))\"\n\t@echo \"make test\"\n\t@echo \"   run all tests\"\n\t@echo \"make tests2.all / make tests2.37 / make tests2.37+\"\n\t@echo \"   run all/single test(s) from tests2, optionally update .expect\"\n\t@echo \"make testspp.all / make testspp.17\"\n\t@echo \"   run all/single test(s) from tests/pp\"\n\t@echo \"make tcov-test / tcov-tests2... / tcov-testspp...\"\n\t@echo \"   run tests as above with code coverage. After test(s) see tcc_c$(EXESUF).tcov\"\n\t@echo \"make test-install\"\n\t@echo \"   run tests with the installed tcc\"\n\t@echo \"Other supported make targets:\"\n\t@echo \"   install install-strip uninstall doc [dist]clean tags ETAGS tar help\"\n\t@echo \"Custom configuration:\"\n\t@echo \"   The makefile includes a file 'config-extra.mak' if it is present.\"\n\t@echo \"   This file may contain some custom configuration.  For example to\"\n\t@echo \"   configure the search paths for a cross-compiler, assuming the\"\n\t@echo \"   support files in /usr/i686-linux-gnu:\"\n\t@echo \"      ROOT-i386 = /usr/i686-linux-gnu\"\n\t@echo \"      CRT-i386  = {R}/lib\"\n\t@echo \"      LIB-i386  = {B}:{R}/lib\"\n\t@echo \"      INC-i386  = {B}/include:{R}/include (*)\"\n\t@echo \"      DEF-i386  += -D__linux__\"\n\t@echo \"   Or also, for the cross platform files in /usr/<triplet>\"\n\t@echo \"      TRIPLET-i386 = i686-linux-gnu\"\n\t@echo \"   (*) tcc replaces {B} by 'tccdir' and {R} by 'CONFIG_SYSROOT'\"\n\n# --------------------------------------------------------------------------\nendif # ($(INCLUDED),no)\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.841796875,
          "content": "Tiny C Compiler - C Scripting Everywhere - The Smallest ANSI C compiler\n-----------------------------------------------------------------------\n\nFeatures:\n--------\n\n- SMALL! You can compile and execute C code everywhere, for example on\n  rescue disks.\n\n- FAST! tcc generates optimized x86 code. No byte code\n  overhead. Compile, assemble and link about 7 times faster than 'gcc\n  -O0'.\n\n- UNLIMITED! Any C dynamic library can be used directly. TCC is\n  heading toward full ISOC99 compliance. TCC can of course compile\n  itself.\n\n- SAFE! tcc includes an optional memory and bound checker. Bound\n  checked code can be mixed freely with standard code.\n\n- Compile and execute C source directly. No linking or assembly\n  necessary. Full C preprocessor included.\n\n- C script supported : just add '#!/usr/local/bin/tcc -run' at the first\n  line of your C source, and execute it directly from the command\n  line.\n\nDocumentation:\n-------------\n\n1) Installation on a i386/x86_64/arm/aarch64/riscv64\n   Linux/macOS/FreeBSD/NetBSD/OpenBSD hosts.\n\n   ./configure\n   make\n   make test\n   make install\n\n   Notes: For FreeBSD, NetBSD and OpenBSD, gmake should be used instead of make.\n   For Windows read tcc-win32.txt.\n\nmakeinfo must be installed to compile the doc.  By default, tcc is\ninstalled in /usr/local/bin.  ./configure --help  shows configuration\noptions.\n\n\n2) Introduction\n\nWe assume here that you know ANSI C. Look at the example ex1.c to know\nwhat the programs look like.\n\nThe include file <tcclib.h> can be used if you want a small basic libc\ninclude support (especially useful for floppy disks). Of course, you\ncan also use standard headers, although they are slower to compile.\n\nYou can begin your C script with '#!/usr/local/bin/tcc -run' on the first\nline and set its execute bits (chmod a+x your_script). Then, you can\nlaunch the C code as a shell or perl script :-) The command line\narguments are put in 'argc' and 'argv' of the main functions, as in\nANSI C.\n\n3) Examples\n\nex1.c: simplest example (hello world). Can also be launched directly\nas a script: './ex1.c'.\n\nex2.c: more complicated example: find a number with the four\noperations given a list of numbers (benchmark).\n\nex3.c: compute fibonacci numbers (benchmark).\n\nex4.c: more complicated: X11 program. Very complicated test in fact\nbecause standard headers are being used ! As for ex1.c, can also be launched\ndirectly as a script: './ex4.c'.\n\nex5.c: 'hello world' with standard glibc headers.\n\ntcc.c: TCC can of course compile itself. Used to check the code\ngenerator.\n\ntcctest.c: auto test for TCC which tests many subtle possible bugs. Used\nwhen doing 'make test'.\n\n4) Full Documentation\n\nPlease read tcc-doc.html to have all the features of TCC.\n\nAdditional information is available for the Windows port in tcc-win32.txt.\n\nLicense:\n-------\n\nTCC is distributed under the GNU Lesser General Public License (see\nCOPYING file).\n\nFabrice Bellard.\n"
        },
        {
          "name": "RELICENSING",
          "type": "blob",
          "size": 2.9140625,
          "content": "\n Relicensing TinyCC\n ------------------\n\n The authors listed below hereby confirm their agreement to relicense TinyCC\n including their past contributions under the following terms:\n\n\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n\n\n Author (name)              I agree (YES/NO)    Files/Features (optional)\n ------------------------------------------------------------------------------\n Adam Sampson               YES                 makefiles\n Daniel Glöckner            NO                  arm-gen.c\n Daniel Glöckner            YES                 not arm-gen.c\n Danny Milosavljevic        YES                 arm-asm.c riscv64-asm.c\n Edmund Grimley Evans       YES                 arm64\n Fabrice Bellard            YES                 original author\n Frédéric Féret             YES                 x86 64/16 bit asm\n grischka                   YES                 tccpe.c\n Henry Kroll                YES\n Herman ten Brugge\t    YES\n Joe Soroka                 YES\n Kirill Smelkov             YES\n mingodad                   YES\n Pip Cet                    YES\n Shinichiro Hamaji          YES                 x86_64-gen.c\n Steffen Nurpmeso           YES\n Vincent Lefèvre            YES\n Thomas Preud'homme         YES                 arm-gen.c\n Timo VJ Lähde (Timppa)     ?                   tiny_libmaker.c\n TK                         ?                   tcccoff.c c67-gen.c\n Tyge Løvset                YES                 tgmath.h, Windows tcc_libm.h math.h\n Urs Janssen                YES\n waddlesplash               YES\n Christian Jullien          YES                 Windows Cygwin build and tests\n Reimar Döffinger           YES\n noneofyourbusiness         YES\n\n\n ------------------------------------------------------------------------------\n\n Please add yourself to the list above (rsp. replace the question mark)\n and (after fetching the latest version) commit to the \"mob\" branch with\n commit message:\n\n     Relicensing TinyCC\n\n Thanks.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 3.7978515625,
          "content": "TODO list:\n\nReleases:\n\n- release tcc on a regular basis\n\nBugs:\n\n- i386 fastcall is mostly wrong\n- FPU st(0) is left unclean (kwisatz haderach). Incompatible with\n  optimized gcc/msc code\n- see transparent union pb in /urs/include/sys/socket.h\n- precise behaviour of typeof with arrays ? (__put_user macro)\n  but should suffice for most cases)\n- handle '? x, y : z' in unsized variable initialization (',' is\n  considered incorrectly as separator in preparser)\n- transform functions to function pointers in function parameters\n  (net/ipv4/ip_output.c)\n- fix function pointer type display\n- check section alignment in C\n- fix invalid cast in comparison 'if (v == (int8_t)v)'\n- finish varargs.h support (gcc 3.2 testsuite issue)\n- fix static functions declared inside block\n- fix multiple unions init\n- make libtcc fully reentrant (except for the compilation stage itself).\n- struct/union/enum definitions in nested scopes (see also Debian bug #770657)\n- __STDC_IEC_559__: float f(void) { static float x = 0.0 / 0.0; return x; }\n- memory may be leaked after errors (longjmp).\n\nPortability:\n\n- it is assumed that int is 32-bit and sizeof(int) == 4\n- int is used when host or target size_t would make more sense\n- TCC handles target floating-point (fp) values using the host's fp\n  arithmetic, which is simple and fast but may lead to exceptions\n  and inaccuracy and wrong representations when cross-compiling\n\nLinking:\n\n- static linking (-static) does sort of work\n\tworks with musl libc\n\tglibc requires libc.so even when statically linked (very bad, but not\n\tup to tcc)\n\nBound checking:\n\n- fix bound exit on RedHat 7.3\n- setjmp is not supported properly in bound checking.\n- fix bound check code with '&' on local variables (currently done\n  only for local arrays).\n- bound checking and float/long long/struct copy code. bound\n  checking and symbol + offset optimization\n\nMissing features:\n\n- disable-asm and disable-bcheck options\n- __builtin_expect()\n- atexit (Nigel Horne)\n- C99: add complex types (gcc 3.2 testsuite issue)\n- postfix compound literals (see 20010124-1.c)\n- interactive mode / integrated debugger\n\nOptimizations:\n\n- suppress specific anonymous symbol handling\n- more parse optimizations (=even faster compilation)\n- memory alloc optimizations (=even faster compilation)\n- optimize VT_LOCAL + const\n- better local variables handling (needed for other targets)\n\nNot critical:\n\n- C99: fix multiple compound literals inits in blocks (ISOC99\n  normative example - only relevant when using gotos! -> must add\n  boolean variable to tell if compound literal was already\n  initialized).\n- add PowerPC generator and improve codegen for RISC (need\n  to suppress VT_LOCAL and use a base register instead).\n- fix preprocessor symbol redefinition\n- add portable byte code generator and interpreter for other\n  unsupported architectures.\n- C++: variable declaration in for, minimal 'class' support.\n- win32: __intxx. use resolve for bchecked malloc et al.\n  check exception code (exception filter func).\n- handle void (__attribute__() *ptr)()\n- VLAs are implemented in a way that is not compatible with signals:\n  http://lists.gnu.org/archive/html/tinycc-devel/2015-11/msg00018.html\n\nFixed (probably):\n\n- bug with defines:\n    #define spin_lock(lock) do { } while (0)\n    #define wq_spin_lock spin_lock\n    #define TEST() wq_spin_lock(a)\n- typedefs can be structure fields\n- see bugfixes.diff + improvement.diff from Daniel Glockner\n- long long constant evaluation\n- add alloca()\n- gcc '-E' option.\n- #include_next support for /usr/include/limits ?\n- function pointers/lvalues in ? : (linux kernel net/core/dev.c)\n- win32: add __stdcall, check GetModuleHandle for dlls.\n- macro substitution with nested definitions (ShangHongzhang)\n- with \"-run\" and libtcc, a PLT is now built.\n- '-E' option was improved\n- packed attribute is now supported\n- ARM and ARM64 code generators have been added.\n"
        },
        {
          "name": "USES",
          "type": "blob",
          "size": 2.2138671875,
          "content": "The following software are known to use or support tcc builds.\nFeel free to complete this list (*).\n\nName                   Short Description\n----                   -----------------\nbigz                   An infinite precision Z & Q library.\ngawk                   GNU awk.\ngmp                    Library for arbitrary precision arithmetic.\ngnumake                GNU makefile.\ngnu mes                using tinycc to bootstrap a system\nmpfr                   Multiple-precision floating-point library.\nmpc                    Complex floating-point library with exact rounding.\nmpv                    A free, open source, and cross-platform media player.\nopenlisp               ISLISP ISO/IEC 13816 Lisp interpreter and compiler.\ns-nail                 BSD Mail/POSIX mailx: send and receive Internet mail.\nsqlite                 Embbedable SQL engine.\nst                     Simple Terminal.\ntcc                    Tiny CC which compiles itself.\nzlib                   Lossless data-compression library.\n\n(*) This list is ordered by name.\n\n\n\nForks & Experiments\n-------------------\n\narm-thumb target\n by Erlend Sveen <erlend.sveen@hotmail.com>\n https://git.erlendjs.no/erlendjs/tinycc.git\n\nriscv32 target\n by Sam Ellicott <sellicott@cedarville.edu>\n https://github.com/sellicott/tcc-riscv32.git\n\nTransputer target\n by David Smith <agentdavo@mac.com>\n https://github.com/agentdavo/tinycc-transputer\n\ntcc-65816 -  Tiny C Compiler for 65816 CPU (based on V0.9.23) from SNES-SDK\n https://github.com/nArnoSNES/tcc-65816\n\nPE-UEFI arm64\n by Andrei Warkentin <andrey.warkentin@gmail.com>\n https://github.com/andreiw/tinycc/\n\nTCCLS - global register allocator (proof of concept)\n by Sebastian Falbesoner <sebastian.falbesoner@gmail.com>\n https://bitbucket.org/theStack/tccls_poc.git\n\nsoftfloat\n by Giovanni Mascellani <gio@debian.org>\n https://gitlab.com/giomasce/tinycc.git\n\noptimize 386\n by Jason Hood <jadoxa@yahoo.com.au>\n\ntcctcl : tcl binding\n https://code.google.com/archive/p/tcltcc/\n\ntcc4tcl : tcl binding\n https://chiselapp.com/user/rkeene/repository/tcc4tcl/index\n\nlua-tcc : allows a Lua script to compile C code\n https://github.com/javierguerragiraldez/lua-tcc\n\ntcclua : semi-high-level bindings for `libtcc`\n https://github.com/nucular/tcclua/blob/master/tcc.lua\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.0078125,
          "content": "0.9.28rc"
        },
        {
          "name": "arm-asm.c",
          "type": "blob",
          "size": 97.6015625,
          "content": "/*\n *  ARM specific functions for TCC assembler\n *\n *  Copyright (c) 2001, 2002 Fabrice Bellard\n *  Copyright (c) 2020 Danny Milosavljevic\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n#define CONFIG_TCC_ASM\n#define NB_ASM_REGS 16\n\nST_FUNC void g(int c);\nST_FUNC void gen_le16(int c);\nST_FUNC void gen_le32(int c);\n\n/*************************************************************/\n#else\n/*************************************************************/\n\n#define USING_GLOBALS\n#include \"tcc.h\"\n\nenum {\n    OPT_REG32,\n    OPT_REGSET32,\n    OPT_IM8,\n    OPT_IM8N,\n    OPT_IM32,\n    OPT_VREG32,\n    OPT_VREG64,\n};\n#define OP_REG32  (1 << OPT_REG32)\n#define OP_VREG32 (1 << OPT_VREG32)\n#define OP_VREG64 (1 << OPT_VREG64)\n#define OP_REG    (OP_REG32 | OP_VREG32 | OP_VREG64)\n#define OP_IM32   (1 << OPT_IM32)\n#define OP_IM8   (1 << OPT_IM8)\n#define OP_IM8N   (1 << OPT_IM8N)\n#define OP_REGSET32  (1 << OPT_REGSET32)\n\ntypedef struct Operand {\n    uint32_t type;\n    union {\n        uint8_t reg;\n        uint16_t regset;\n        ExprValue e;\n    };\n} Operand;\n\n/* Read the VFP register referred to by token T.\n   If OK, returns its number.\n   If not OK, returns -1. */\nstatic int asm_parse_vfp_regvar(int t, int double_precision)\n{\n    if (double_precision) {\n        if (t >= TOK_ASM_d0 && t <= TOK_ASM_d15)\n            return t - TOK_ASM_d0;\n    } else {\n        if (t >= TOK_ASM_s0 && t <= TOK_ASM_s31)\n            return t - TOK_ASM_s0;\n    }\n    return -1;\n}\n\n/* Parse a text containing operand and store the result in OP */\nstatic void parse_operand(TCCState *s1, Operand *op)\n{\n    ExprValue e;\n    int8_t reg;\n    uint16_t regset = 0;\n\n    op->type = 0;\n\n    if (tok == '{') { // regset literal\n        next(); // skip '{'\n        while (tok != '}' && tok != TOK_EOF) {\n            reg = asm_parse_regvar(tok);\n            if (reg == -1) {\n                expect(\"register\");\n            } else\n                next(); // skip register name\n\n            if ((1 << reg) < regset)\n                tcc_warning(\"registers will be processed in ascending order by hardware--but are not specified in ascending order here\");\n            regset |= 1 << reg;\n            if (tok != ',')\n                break;\n            next(); // skip ','\n        }\n        skip('}');\n        if (regset == 0) {\n            // ARM instructions don't support empty regset.\n            tcc_error(\"empty register list is not supported\");\n        } else {\n            op->type = OP_REGSET32;\n            op->regset = regset;\n        }\n        return;\n    } else if ((reg = asm_parse_regvar(tok)) != -1) {\n        next(); // skip register name\n        op->type = OP_REG32;\n        op->reg = (uint8_t) reg;\n        return;\n    } else if ((reg = asm_parse_vfp_regvar(tok, 0)) != -1) {\n        next(); // skip register name\n        op->type = OP_VREG32;\n        op->reg = (uint8_t) reg;\n        return;\n    } else if ((reg = asm_parse_vfp_regvar(tok, 1)) != -1) {\n        next(); // skip register name\n        op->type = OP_VREG64;\n        op->reg = (uint8_t) reg;\n        return;\n    } else if (tok == '#' || tok == '$') {\n        /* constant value */\n        next(); // skip '#' or '$'\n    }\n    asm_expr(s1, &e);\n    op->type = OP_IM32;\n    op->e = e;\n    if (!op->e.sym) {\n        if ((int) op->e.v < 0 && (int) op->e.v >= -255)\n            op->type = OP_IM8N;\n        else if (op->e.v == (uint8_t)op->e.v)\n            op->type = OP_IM8;\n    } else\n        expect(\"operand\");\n}\n\n/* XXX: make it faster ? */\nST_FUNC void g(int c)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 1;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c;\n    ind = ind1;\n}\n\nST_FUNC void gen_le16 (int i)\n{\n    g(i);\n    g(i>>8);\n}\n\nST_FUNC void gen_le32 (int i)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 4;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind++] = i & 0xFF;\n    cur_text_section->data[ind++] = (i >> 8) & 0xFF;\n    cur_text_section->data[ind++] = (i >> 16) & 0xFF;\n    cur_text_section->data[ind++] = (i >> 24) & 0xFF;\n}\n\nST_FUNC void gen_expr32(ExprValue *pe)\n{\n    gen_le32(pe->v);\n}\n\nstatic uint32_t condition_code_of_token(int token) {\n    if (token < TOK_ASM_nopeq) {\n        expect(\"condition-enabled instruction\");\n    } else\n        return (token - TOK_ASM_nopeq) & 15;\n}\n\nstatic void asm_emit_opcode(int token, uint32_t opcode) {\n    gen_le32((condition_code_of_token(token) << 28) | opcode);\n}\n\nstatic void asm_emit_unconditional_opcode(uint32_t opcode) {\n    gen_le32(opcode);\n}\n\nstatic void asm_emit_coprocessor_opcode(uint32_t high_nibble, uint8_t cp_number, uint8_t cp_opcode, uint8_t cp_destination_register, uint8_t cp_n_operand_register, uint8_t cp_m_operand_register, uint8_t cp_opcode2, int inter_processor_transfer)\n{\n    uint32_t opcode = 0xe000000;\n    if (inter_processor_transfer)\n        opcode |= 1 << 4;\n    //assert(cp_opcode < 16);\n    opcode |= cp_opcode << 20;\n    //assert(cp_n_operand_register < 16);\n    opcode |= cp_n_operand_register << 16;\n    //assert(cp_destination_register < 16);\n    opcode |= cp_destination_register << 12;\n    //assert(cp_number < 16);\n    opcode |= cp_number << 8;\n    //assert(cp_information < 8);\n    opcode |= cp_opcode2 << 5;\n    //assert(cp_m_operand_register < 16);\n    opcode |= cp_m_operand_register;\n    asm_emit_unconditional_opcode((high_nibble << 28) | opcode);\n}\n\nstatic void asm_nullary_opcode(int token)\n{\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_nopeq:\n        asm_emit_opcode(token, 0xd << 21); // mov r0, r0\n        break;\n    case TOK_ASM_wfeeq:\n        asm_emit_opcode(token, 0x320f002);\n    case TOK_ASM_wfieq:\n        asm_emit_opcode(token, 0x320f003);\n        break;\n    default:\n        expect(\"nullary instruction\");\n    }\n}\n\nstatic void asm_unary_opcode(TCCState *s1, int token)\n{\n    Operand op;\n    parse_operand(s1, &op);\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_swieq:\n    case TOK_ASM_svceq:\n        if (op.type != OP_IM8)\n            expect(\"immediate 8-bit unsigned integer\");\n        else {\n            /* Note: Dummy operand (ignored by processor): ARM ref documented 0...255, ARM instruction set documented 24 bit */\n            asm_emit_opcode(token, (0xf << 24) | op.e.v);\n        }\n        break;\n    default:\n        expect(\"unary instruction\");\n    }\n}\n\nstatic void asm_binary_opcode(TCCState *s1, int token)\n{\n    Operand ops[2];\n    Operand rotation;\n    uint32_t encoded_rotation = 0;\n    uint64_t amount;\n    parse_operand(s1, &ops[0]);\n    skip(',');\n    parse_operand(s1, &ops[1]);\n    if (ops[0].type != OP_REG32) {\n        expect(\"(destination operand) register\");\n    }\n\n    if (ops[0].reg == 15) {\n        tcc_error(\"'%s' does not support 'pc' as operand\", get_tok_str(token, NULL));\n    }\n\n    if (ops[0].reg == 13)\n        tcc_warning(\"Using 'sp' as operand with '%s' is deprecated by ARM\", get_tok_str(token, NULL));\n\n    if (ops[1].type != OP_REG32) {\n        switch (ARM_INSTRUCTION_GROUP(token)) {\n        case TOK_ASM_movteq:\n        case TOK_ASM_movweq:\n            if (ops[1].type == OP_IM8 || ops[1].type == OP_IM8N || ops[1].type == OP_IM32) {\n                if (ops[1].e.v >= 0 && ops[1].e.v <= 0xFFFF) {\n                    uint16_t immediate_value = ops[1].e.v;\n                    switch (ARM_INSTRUCTION_GROUP(token)) {\n                    case TOK_ASM_movteq:\n                        asm_emit_opcode(token, 0x3400000 | (ops[0].reg << 12) | (immediate_value & 0xF000) << 4 | (immediate_value & 0xFFF));\n                        break;\n                    case TOK_ASM_movweq:\n                        asm_emit_opcode(token, 0x3000000 | (ops[0].reg << 12) | (immediate_value & 0xF000) << 4 | (immediate_value & 0xFFF));\n                        break;\n                    }\n                } else\n                    expect(\"(source operand) immediate 16 bit value\");\n            } else\n                expect(\"(source operand) immediate\");\n            break;\n        default:\n            expect(\"(source operand) register\");\n        }\n        return;\n    }\n\n    if (ops[1].reg == 15) {\n        tcc_error(\"'%s' does not support 'pc' as operand\", get_tok_str(token, NULL));\n    }\n\n    if (ops[1].reg == 13)\n        tcc_warning(\"Using 'sp' as operand with '%s' is deprecated by ARM\", get_tok_str(token, NULL));\n\n    if (tok == ',') {\n        next(); // skip ','\n        if (tok == TOK_ASM_ror) {\n            next(); // skip 'ror'\n            parse_operand(s1, &rotation);\n            if (rotation.type != OP_IM8) {\n                expect(\"immediate value for rotation\");\n            } else {\n                amount = rotation.e.v;\n                switch (amount) {\n                case 8:\n                    encoded_rotation = 1 << 10;\n                    break;\n                case 16:\n                    encoded_rotation = 2 << 10;\n                    break;\n                case 24:\n                    encoded_rotation = 3 << 10;\n                    break;\n                default:\n                    expect(\"'8' or '16' or '24'\");\n                }\n            }\n        }\n    }\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_clzeq:\n        if (encoded_rotation)\n            tcc_error(\"clz does not support rotation\");\n        asm_emit_opcode(token, 0x16f0f10 | (ops[0].reg << 12) | ops[1].reg);\n        break;\n    case TOK_ASM_sxtbeq:\n        asm_emit_opcode(token, 0x6af0070 | (ops[0].reg << 12) | ops[1].reg | encoded_rotation);\n        break;\n    case TOK_ASM_sxtheq:\n        asm_emit_opcode(token, 0x6bf0070 | (ops[0].reg << 12) | ops[1].reg | encoded_rotation);\n        break;\n    case TOK_ASM_uxtbeq:\n        asm_emit_opcode(token, 0x6ef0070 | (ops[0].reg << 12) | ops[1].reg | encoded_rotation);\n        break;\n    case TOK_ASM_uxtheq:\n        asm_emit_opcode(token, 0x6ff0070 | (ops[0].reg << 12) | ops[1].reg | encoded_rotation);\n        break;\n    default:\n        expect(\"binary instruction\");\n    }\n}\n\nstatic void asm_coprocessor_opcode(TCCState *s1, int token) {\n    uint8_t coprocessor;\n    Operand opcode1;\n    Operand opcode2;\n    uint8_t registers[3];\n    unsigned int i;\n    uint8_t high_nibble;\n    uint8_t mrc = 0;\n\n    if (tok >= TOK_ASM_p0 && tok <= TOK_ASM_p15) {\n        coprocessor = tok - TOK_ASM_p0;\n        next();\n    } else {\n        expect(\"'p<number>'\");\n    }\n    skip(',');\n    parse_operand(s1, &opcode1);\n    if (opcode1.type != OP_IM8 || opcode1.e.v > 15) {\n        tcc_error(\"opcode1 of instruction '%s' must be an immediate value between 0 and 15\", get_tok_str(token, NULL));\n    }\n\n    for (i = 0; i < 3; ++i) {\n        skip(',');\n        if (i == 0 && token != TOK_ASM_cdp2 && (ARM_INSTRUCTION_GROUP(token) == TOK_ASM_mrceq || ARM_INSTRUCTION_GROUP(token) == TOK_ASM_mcreq)) {\n            if (tok >= TOK_ASM_r0 && tok <= TOK_ASM_r15) {\n                registers[i] = tok - TOK_ASM_r0;\n                next();\n            } else {\n                expect(\"'r<number>'\");\n            }\n        } else {\n            if (tok >= TOK_ASM_c0 && tok <= TOK_ASM_c15) {\n                registers[i] = tok - TOK_ASM_c0;\n                next();\n            } else {\n                expect(\"'c<number>'\");\n            }\n        }\n    }\n    if (tok == ',') {\n        next();\n        parse_operand(s1, &opcode2);\n    } else {\n        opcode2.type = OP_IM8;\n        opcode2.e.v = 0;\n    }\n    if (opcode2.type != OP_IM8 || opcode2.e.v > 15) {\n        tcc_error(\"opcode2 of instruction '%s' must be an immediate value between 0 and 15\", get_tok_str(token, NULL));\n    }\n\n    if (token == TOK_ASM_cdp2) {\n        high_nibble = 0xF;\n        asm_emit_coprocessor_opcode(high_nibble, coprocessor, opcode1.e.v, registers[0], registers[1], registers[2], opcode2.e.v, 0);\n        return;\n    } else\n        high_nibble = condition_code_of_token(token);\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_cdpeq:\n        asm_emit_coprocessor_opcode(high_nibble, coprocessor, opcode1.e.v, registers[0], registers[1], registers[2], opcode2.e.v, 0);\n        break;\n    case TOK_ASM_mrceq:\n        // opcode1 encoding changes! highest and lowest bit gone.\n        mrc = 1;\n        /* fallthrough */\n    case TOK_ASM_mcreq:\n        // opcode1 encoding changes! highest and lowest bit gone.\n        if (opcode1.e.v > 7) {\n            tcc_error(\"opcode1 of instruction '%s' must be an immediate value between 0 and 7\", get_tok_str(token, NULL));\n        }\n        asm_emit_coprocessor_opcode(high_nibble, coprocessor, (opcode1.e.v << 1) | mrc, registers[0], registers[1], registers[2], opcode2.e.v, 1);\n        break;\n    default:\n        expect(\"known instruction\");\n    }\n}\n\n/* data processing and single data transfer instructions only */\n#define ENCODE_RN(register_index) ((register_index) << 16)\n#define ENCODE_RD(register_index) ((register_index) << 12)\n#define ENCODE_SET_CONDITION_CODES (1 << 20)\n\n/* Note: For data processing instructions, \"1\" means immediate.\n   Note: For single data transfer instructions, \"0\" means immediate. */\n#define ENCODE_IMMEDIATE_FLAG (1 << 25)\n\n#define ENCODE_BARREL_SHIFTER_SHIFT_BY_REGISTER (1 << 4)\n#define ENCODE_BARREL_SHIFTER_MODE_LSL (0 << 5)\n#define ENCODE_BARREL_SHIFTER_MODE_LSR (1 << 5)\n#define ENCODE_BARREL_SHIFTER_MODE_ASR (2 << 5)\n#define ENCODE_BARREL_SHIFTER_MODE_ROR (3 << 5)\n#define ENCODE_BARREL_SHIFTER_REGISTER(register_index) ((register_index) << 8)\n#define ENCODE_BARREL_SHIFTER_IMMEDIATE(value) ((value) << 7)\n\nstatic void asm_block_data_transfer_opcode(TCCState *s1, int token)\n{\n    uint32_t opcode;\n    int op0_exclam = 0;\n    Operand ops[2];\n    int nb_ops = 1;\n    parse_operand(s1, &ops[0]);\n    if (tok == '!') {\n        op0_exclam = 1;\n        next(); // skip '!'\n    }\n    if (tok == ',') {\n        next(); // skip comma\n        parse_operand(s1, &ops[1]);\n        ++nb_ops;\n    }\n    if (nb_ops < 1) {\n        expect(\"at least one operand\");\n    } else if (ops[nb_ops - 1].type != OP_REGSET32) {\n        expect(\"(last operand) register list\");\n    }\n\n    // block data transfer: 1 0 0 P U S W L << 20 (general case):\n    // operands:\n    //   Rn: bits 19...16 base register\n    //   Register List: bits 15...0\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_pusheq: // TODO: Optimize 1-register case to: str ?, [sp, #-4]!\n        // Instruction: 1 I=0 P=1 U=0 S=0 W=1 L=0 << 20, op 1101\n        //   operands:\n        //      Rn: base register\n        //      Register List: bits 15...0\n        if (nb_ops != 1)\n            expect(\"exactly one operand\");\n        else\n            asm_emit_opcode(token, (0x92d << 16) | ops[0].regset); // TODO: base register ?\n        break;\n    case TOK_ASM_popeq: // TODO: Optimize 1-register case to: ldr ?, [sp], #4\n        // Instruction: 1 I=0 P=0 U=1 S=0 W=0 L=1 << 20, op 1101\n        //   operands:\n        //      Rn: base register\n        //      Register List: bits 15...0\n        if (nb_ops != 1)\n            expect(\"exactly one operand\");\n        else\n            asm_emit_opcode(token, (0x8bd << 16) | ops[0].regset); // TODO: base register ?\n        break;\n    case TOK_ASM_stmdaeq:\n    case TOK_ASM_ldmdaeq:\n    case TOK_ASM_stmeq:\n    case TOK_ASM_ldmeq:\n    case TOK_ASM_stmiaeq:\n    case TOK_ASM_ldmiaeq:\n    case TOK_ASM_stmdbeq:\n    case TOK_ASM_ldmdbeq:\n    case TOK_ASM_stmibeq:\n    case TOK_ASM_ldmibeq:\n        switch (ARM_INSTRUCTION_GROUP(token)) {\n        case TOK_ASM_stmdaeq: // post-decrement store\n            opcode = 0x80 << 20;\n            break;\n        case TOK_ASM_ldmdaeq: // post-decrement load\n            opcode = 0x81 << 20;\n            break;\n        case TOK_ASM_stmeq: // post-increment store\n        case TOK_ASM_stmiaeq: // post-increment store\n            opcode = 0x88 << 20;\n            break;\n        case TOK_ASM_ldmeq: // post-increment load\n        case TOK_ASM_ldmiaeq: // post-increment load\n            opcode = 0x89 << 20;\n            break;\n        case TOK_ASM_stmdbeq: // pre-decrement store\n            opcode = 0x90 << 20;\n            break;\n        case TOK_ASM_ldmdbeq: // pre-decrement load\n            opcode = 0x91 << 20;\n            break;\n        case TOK_ASM_stmibeq: // pre-increment store\n            opcode = 0x98 << 20;\n            break;\n        case TOK_ASM_ldmibeq: // pre-increment load\n            opcode = 0x99 << 20;\n            break;\n        default:\n            tcc_error(\"internal error: This place should not be reached (fallback in asm_block_data_transfer_opcode)\");\n        }\n        // operands:\n        //    Rn: first operand\n        //    Register List: lower bits\n        if (nb_ops != 2)\n            expect(\"exactly two operands\");\n        else if (ops[0].type != OP_REG32)\n            expect(\"(first operand) register\");\n        else {\n            if (op0_exclam)\n                opcode |= 1 << 21; // writeback\n            asm_emit_opcode(token, opcode | ENCODE_RN(ops[0].reg) | ops[1].regset);\n        }\n        break;\n    default:\n        expect(\"block data transfer instruction\");\n    }\n}\n\n/* Parses shift directive and returns the parts that would have to be set in the opcode because of it.\n   Does not encode the actual shift amount.\n   It's not an error if there is no shift directive.\n\n   NB_SHIFT: will be set to 1 iff SHIFT is filled.  Note that for rrx, there's no need to fill SHIFT.\n   SHIFT: will be filled in with the shift operand to use, if any. */\nstatic uint32_t asm_parse_optional_shift(TCCState* s1, int* nb_shift, Operand* shift)\n{\n    uint32_t opcode = 0;\n    *nb_shift = 0;\n    switch (tok) {\n    case TOK_ASM_asl:\n    case TOK_ASM_lsl:\n    case TOK_ASM_asr:\n    case TOK_ASM_lsr:\n    case TOK_ASM_ror:\n        switch (tok) {\n        case TOK_ASM_asl:\n            /* fallthrough */\n        case TOK_ASM_lsl:\n            opcode = ENCODE_BARREL_SHIFTER_MODE_LSL;\n            break;\n        case TOK_ASM_asr:\n            opcode = ENCODE_BARREL_SHIFTER_MODE_ASR;\n            break;\n        case TOK_ASM_lsr:\n            opcode = ENCODE_BARREL_SHIFTER_MODE_LSR;\n            break;\n        case TOK_ASM_ror:\n            opcode = ENCODE_BARREL_SHIFTER_MODE_ROR;\n            break;\n        }\n        next();\n        parse_operand(s1, shift);\n        *nb_shift = 1;\n        break;\n    case TOK_ASM_rrx:\n        next();\n        opcode = ENCODE_BARREL_SHIFTER_MODE_ROR;\n        break;\n    }\n    return opcode;\n}\n\nstatic uint32_t asm_encode_shift(Operand* shift)\n{\n    uint64_t amount;\n    uint32_t operands = 0;\n    switch (shift->type) {\n    case OP_REG32:\n        if (shift->reg == 15)\n            tcc_error(\"r15 cannot be used as a shift count\");\n        else {\n            operands = ENCODE_BARREL_SHIFTER_SHIFT_BY_REGISTER;\n            operands |= ENCODE_BARREL_SHIFTER_REGISTER(shift->reg);\n        }\n        break;\n    case OP_IM8:\n        amount = shift->e.v;\n        if (amount > 0 && amount < 32)\n            operands = ENCODE_BARREL_SHIFTER_IMMEDIATE(amount);\n        else\n            tcc_error(\"shift count out of range\");\n        break;\n    default:\n        tcc_error(\"unknown shift amount\");\n    }\n    return operands;\n}\n\nstatic void asm_data_processing_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    int nb_ops;\n    Operand shift = {0};\n    int nb_shift = 0;\n    uint32_t operands = 0;\n\n    /* modulo 16 entries per instruction for the different condition codes */\n    uint32_t opcode_idx = (ARM_INSTRUCTION_GROUP(token) - TOK_ASM_andeq) >> 4;\n    uint32_t opcode_nos = opcode_idx >> 1; // without \"s\"; \"OpCode\" in ARM docs\n\n    for (nb_ops = 0; nb_ops < sizeof(ops)/sizeof(ops[0]); ) {\n        if (tok == TOK_ASM_asl || tok == TOK_ASM_lsl || tok == TOK_ASM_lsr || tok == TOK_ASM_asr || tok == TOK_ASM_ror || tok == TOK_ASM_rrx)\n            break;\n        parse_operand(s1, &ops[nb_ops]);\n        ++nb_ops;\n        if (tok != ',')\n            break;\n        next(); // skip ','\n    }\n    if (tok == ',')\n        next();\n    operands |= asm_parse_optional_shift(s1, &nb_shift, &shift);\n    if (nb_ops < 2)\n        expect(\"at least two operands\");\n    else if (nb_ops == 2) {\n        memcpy(&ops[2], &ops[1], sizeof(ops[1])); // move ops[2]\n        memcpy(&ops[1], &ops[0], sizeof(ops[0])); // ops[1] was implicit\n        nb_ops = 3;\n    } else if (nb_ops == 3) {\n        if (opcode_nos == 0xd || opcode_nos == 0xf || opcode_nos == 0xa || opcode_nos == 0xb || opcode_nos == 0x8 || opcode_nos == 0x9) { // mov, mvn, cmp, cmn, tst, teq\n            tcc_error(\"'%s' cannot be used with three operands\", get_tok_str(token, NULL));\n        }\n    }\n    if (nb_ops != 3) {\n        expect(\"two or three operands\");\n    } else {\n        uint32_t opcode = 0;\n        uint32_t immediate_value;\n        uint8_t half_immediate_rotation;\n        if (nb_shift && shift.type == OP_REG32) {\n            if ((ops[0].type == OP_REG32 && ops[0].reg == 15) ||\n                (ops[1].type == OP_REG32 && ops[1].reg == 15)) {\n                tcc_error(\"Using the 'pc' register in data processing instructions that have a register-controlled shift is not implemented by ARM\");\n            }\n        }\n\n        // data processing (general case):\n        // operands:\n        //   Rn: bits 19...16 (first operand)\n        //   Rd: bits 15...12 (destination)\n        //   Operand2: bits 11...0 (second operand);  depending on I that's either a register or an immediate\n        // operator:\n        //   bits 24...21: \"OpCode\"--see below\n\n        /* operations in the token list are ordered by opcode */\n        opcode = opcode_nos << 21; // drop \"s\"\n        if (ops[0].type != OP_REG32)\n            expect(\"(destination operand) register\");\n        else if (opcode_nos == 0xa || opcode_nos == 0xb || opcode_nos == 0x8 || opcode_nos == 0x9) // cmp, cmn, tst, teq\n            operands |= ENCODE_SET_CONDITION_CODES; // force S set, otherwise it's a completely different instruction.\n        else\n            operands |= ENCODE_RD(ops[0].reg);\n        if (ops[1].type != OP_REG32)\n            expect(\"(first source operand) register\");\n        else if (!(opcode_nos == 0xd || opcode_nos == 0xf)) // not: mov, mvn (those have only one source operand)\n            operands |= ENCODE_RN(ops[1].reg);\n        switch (ops[2].type) {\n        case OP_REG32:\n            operands |= ops[2].reg;\n            break;\n        case OP_IM8:\n        case OP_IM32:\n            operands |= ENCODE_IMMEDIATE_FLAG;\n            immediate_value = ops[2].e.v;\n            for (half_immediate_rotation = 0; half_immediate_rotation < 16; ++half_immediate_rotation) {\n                if (immediate_value >= 0x00 && immediate_value < 0x100)\n                    break;\n                // rotate left by two\n                immediate_value = ((immediate_value & 0x3FFFFFFF) << 2) | ((immediate_value & 0xC0000000) >> 30);\n            }\n            if (half_immediate_rotation >= 16) {\n                /* fallthrough */\n            } else {\n                operands |= immediate_value;\n                operands |= half_immediate_rotation << 8;\n                break;\n            }\n        case OP_IM8N: // immediate negative value\n            operands |= ENCODE_IMMEDIATE_FLAG;\n            immediate_value = ops[2].e.v;\n            /* Instruction swapping:\n               0001 = EOR - Rd:= Op1 EOR Op2     -> difficult\n               0011 = RSB - Rd:= Op2 - Op1       -> difficult\n               0111 = RSC - Rd:= Op2 - Op1 + C   -> difficult\n               1000 = TST - CC on: Op1 AND Op2   -> difficult\n               1001 = TEQ - CC on: Op1 EOR Op2   -> difficult\n               1100 = ORR - Rd:= Op1 OR Op2      -> difficult\n            */\n            switch (opcode_nos) {\n            case 0x0: // AND - Rd:= Op1 AND Op2\n                opcode = 0xe << 21; // BIC\n                immediate_value = ~immediate_value;\n                break;\n            case 0x2: // SUB - Rd:= Op1 - Op2\n                opcode = 0x4 << 21; // ADD\n                immediate_value = -immediate_value;\n                break;\n            case 0x4: // ADD - Rd:= Op1 + Op2\n                opcode = 0x2 << 21; // SUB\n                immediate_value = -immediate_value;\n                break;\n            case 0x5: // ADC - Rd:= Op1 + Op2 + C\n                opcode = 0x6 << 21; // SBC\n                immediate_value = ~immediate_value;\n                break;\n            case 0x6: // SBC - Rd:= Op1 - Op2 + C\n                opcode = 0x5 << 21; // ADC\n                immediate_value = ~immediate_value;\n                break;\n            case 0xa: // CMP - CC on: Op1 - Op2\n                opcode = 0xb << 21; // CMN\n                immediate_value = -immediate_value;\n                break;\n            case 0xb: // CMN - CC on: Op1 + Op2\n                opcode = 0xa << 21; // CMP\n                immediate_value = -immediate_value;\n                break;\n            case 0xd: // MOV - Rd:= Op2\n                opcode = 0xf << 21; // MVN\n                immediate_value = ~immediate_value;\n                break;\n            case 0xe: // BIC - Rd:= Op1 AND NOT Op2\n                opcode = 0x0 << 21; // AND\n                immediate_value = ~immediate_value;\n                break;\n            case 0xf: // MVN - Rd:= NOT Op2\n                opcode = 0xd << 21; // MOV\n                immediate_value = ~immediate_value;\n                break;\n            default:\n                tcc_error(\"cannot use '%s' with a negative immediate value\", get_tok_str(token, NULL));\n            }\n            for (half_immediate_rotation = 0; half_immediate_rotation < 16; ++half_immediate_rotation) {\n                if (immediate_value >= 0x00 && immediate_value < 0x100)\n                    break;\n                // rotate left by two\n                immediate_value = ((immediate_value & 0x3FFFFFFF) << 2) | ((immediate_value & 0xC0000000) >> 30);\n            }\n            if (half_immediate_rotation >= 16) {\n                immediate_value = ops[2].e.v;\n                tcc_error(\"immediate value 0x%X cannot be encoded into ARM immediate\", (unsigned) immediate_value);\n            }\n            operands |= immediate_value;\n            operands |= half_immediate_rotation << 8;\n            break;\n        default:\n            expect(\"(second source operand) register or immediate value\");\n        }\n\n        if (nb_shift) {\n            if (operands & ENCODE_IMMEDIATE_FLAG)\n                tcc_error(\"immediate rotation not implemented\");\n            else\n                operands |= asm_encode_shift(&shift);\n        }\n\n        /* S=0 and S=1 entries alternate one after another, in that order */\n        opcode |= (opcode_idx & 1) ? ENCODE_SET_CONDITION_CODES : 0;\n        asm_emit_opcode(token, opcode | operands);\n    }\n}\n\nstatic void asm_shift_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    int nb_ops;\n    int definitely_neutral = 0;\n    uint32_t opcode = 0xd << 21; // MOV\n    uint32_t operands = 0;\n\n    for (nb_ops = 0; nb_ops < sizeof(ops)/sizeof(ops[0]); ++nb_ops) {\n        parse_operand(s1, &ops[nb_ops]);\n        if (tok != ',') {\n            ++nb_ops;\n            break;\n        }\n        next(); // skip ','\n    }\n    if (nb_ops < 2) {\n        expect(\"at least two operands\");\n    }\n\n    if (ops[0].type != OP_REG32) {\n        expect(\"(destination operand) register\");\n    } else\n        operands |= ENCODE_RD(ops[0].reg);\n\n    if (nb_ops == 2) {\n        switch (ARM_INSTRUCTION_GROUP(token)) {\n        case TOK_ASM_rrxseq:\n            opcode |= ENCODE_SET_CONDITION_CODES;\n            /* fallthrough */\n        case TOK_ASM_rrxeq:\n            if (ops[1].type == OP_REG32) {\n                operands |= ops[1].reg;\n                operands |= ENCODE_BARREL_SHIFTER_MODE_ROR;\n                asm_emit_opcode(token, opcode | operands);\n            } else\n                tcc_error(\"(first source operand) register\");\n            return;\n        default:\n            memcpy(&ops[2], &ops[1], sizeof(ops[1])); // move ops[2]\n            memcpy(&ops[1], &ops[0], sizeof(ops[0])); // ops[1] was implicit\n            nb_ops = 3;\n        }\n    }\n    if (nb_ops != 3) {\n        expect(\"two or three operands\");\n    }\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_lslseq:\n    case TOK_ASM_lsrseq:\n    case TOK_ASM_asrseq:\n    case TOK_ASM_rorseq:\n        opcode |= ENCODE_SET_CONDITION_CODES;\n        break;\n    }\n\n    switch (ops[1].type) {\n    case OP_REG32:\n        operands |= ops[1].reg;\n        break;\n    case OP_IM8:\n        operands |= ENCODE_IMMEDIATE_FLAG;\n        operands |= ops[1].e.v;\n        tcc_error(\"Using an immediate value as the source operand is not possible with '%s' instruction on ARM\", get_tok_str(token, NULL));\n    }\n\n    switch (ops[2].type) {\n    case OP_REG32:\n        if ((ops[0].type == OP_REG32 && ops[0].reg == 15) ||\n            (ops[1].type == OP_REG32 && ops[1].reg == 15)) {\n            tcc_error(\"Using the 'pc' register in data processing instructions that have a register-controlled shift is not implemented by ARM\");\n        }\n        operands |= asm_encode_shift(&ops[2]);\n        break;\n    case OP_IM8:\n        if (ops[2].e.v)\n            operands |= asm_encode_shift(&ops[2]);\n        else\n            definitely_neutral = 1;\n        break;\n    }\n\n    if (!definitely_neutral) switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_lslseq:\n    case TOK_ASM_lsleq:\n        operands |= ENCODE_BARREL_SHIFTER_MODE_LSL;\n        break;\n    case TOK_ASM_lsrseq:\n    case TOK_ASM_lsreq:\n        operands |= ENCODE_BARREL_SHIFTER_MODE_LSR;\n        break;\n    case TOK_ASM_asrseq:\n    case TOK_ASM_asreq:\n        operands |= ENCODE_BARREL_SHIFTER_MODE_ASR;\n        break;\n    case TOK_ASM_rorseq:\n    case TOK_ASM_roreq:\n        operands |= ENCODE_BARREL_SHIFTER_MODE_ROR;\n        break;\n    default:\n        expect(\"shift instruction\");\n    }\n    asm_emit_opcode(token, opcode | operands);\n}\n\nstatic void asm_multiplication_opcode(TCCState *s1, int token)\n{\n    Operand ops[4];\n    int nb_ops = 0;\n    uint32_t opcode = 0x90;\n\n    for (nb_ops = 0; nb_ops < sizeof(ops)/sizeof(ops[0]); ++nb_ops) {\n        parse_operand(s1, &ops[nb_ops]);\n        if (tok != ',') {\n            ++nb_ops;\n            break;\n        }\n        next(); // skip ','\n    }\n    if (nb_ops < 2)\n        expect(\"at least two operands\");\n    else if (nb_ops == 2) {\n        switch (ARM_INSTRUCTION_GROUP(token)) {\n        case TOK_ASM_mulseq:\n        case TOK_ASM_muleq:\n            memcpy(&ops[2], &ops[0], sizeof(ops[1])); // ARM is actually like this!\n            break;\n        default:\n            expect(\"at least three operands\");\n        }\n        nb_ops = 3;\n    }\n\n    // multiply (special case):\n    // operands:\n    //   Rd: bits 19...16\n    //   Rm: bits 3...0\n    //   Rs: bits 11...8\n    //   Rn: bits 15...12\n\n    if (ops[0].type == OP_REG32)\n        opcode |= ops[0].reg << 16;\n    else\n        expect(\"(destination operand) register\");\n    if (ops[1].type == OP_REG32)\n        opcode |= ops[1].reg;\n    else\n        expect(\"(first source operand) register\");\n    if (ops[2].type == OP_REG32)\n        opcode |= ops[2].reg << 8;\n    else\n        expect(\"(second source operand) register\");\n    if (nb_ops > 3) {\n        if (ops[3].type == OP_REG32)\n            opcode |= ops[3].reg << 12;\n        else\n            expect(\"(third source operand) register\");\n    }\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_mulseq:\n        opcode |= 1 << 20; // Status\n        /* fallthrough */\n    case TOK_ASM_muleq:\n        if (nb_ops != 3)\n            expect(\"three operands\");\n        else {\n            asm_emit_opcode(token, opcode);\n        }\n        break;\n    case TOK_ASM_mlaseq:\n        opcode |= 1 << 20; // Status\n        /* fallthrough */\n    case TOK_ASM_mlaeq:\n        if (nb_ops != 4)\n            expect(\"four operands\");\n        else {\n            opcode |= 1 << 21; // Accumulate\n            asm_emit_opcode(token, opcode);\n        }\n        break;\n    default:\n        expect(\"known multiplication instruction\");\n    }\n}\n\nstatic void asm_long_multiplication_opcode(TCCState *s1, int token)\n{\n    Operand ops[4];\n    int nb_ops = 0;\n    uint32_t opcode = 0x90 | (1 << 23);\n\n    for (nb_ops = 0; nb_ops < sizeof(ops)/sizeof(ops[0]); ++nb_ops) {\n        parse_operand(s1, &ops[nb_ops]);\n        if (tok != ',') {\n            ++nb_ops;\n            break;\n        }\n        next(); // skip ','\n    }\n    if (nb_ops != 4) {\n        expect(\"four operands\");\n    }\n\n    // long multiply (special case):\n    // operands:\n    //   RdLo: bits 15...12\n    //   RdHi: bits 19...16\n    //   Rs: bits 11...8\n    //   Rm: bits 3...0\n\n    if (ops[0].type == OP_REG32)\n        opcode |= ops[0].reg << 12;\n    else\n        expect(\"(destination lo accumulator) register\");\n    if (ops[1].type == OP_REG32)\n        opcode |= ops[1].reg << 16;\n    else\n        expect(\"(destination hi accumulator) register\");\n    if (ops[2].type == OP_REG32)\n        opcode |= ops[2].reg;\n    else\n        expect(\"(first source operand) register\");\n    if (ops[3].type == OP_REG32)\n        opcode |= ops[3].reg << 8;\n    else\n        expect(\"(second source operand) register\");\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_smullseq:\n        opcode |= 1 << 20; // Status\n        /* fallthrough */\n    case TOK_ASM_smulleq:\n        opcode |= 1 << 22; // signed\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_umullseq:\n        opcode |= 1 << 20; // Status\n        /* fallthrough */\n    case TOK_ASM_umulleq:\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_smlalseq:\n        opcode |= 1 << 20; // Status\n        /* fallthrough */\n    case TOK_ASM_smlaleq:\n        opcode |= 1 << 22; // signed\n        opcode |= 1 << 21; // Accumulate\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_umlalseq:\n        opcode |= 1 << 20; // Status\n        /* fallthrough */\n    case TOK_ASM_umlaleq:\n        opcode |= 1 << 21; // Accumulate\n        asm_emit_opcode(token, opcode);\n        break;\n    default:\n        expect(\"known long multiplication instruction\");\n    }\n}\n\nstatic void asm_single_data_transfer_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    Operand strex_operand;\n    Operand shift;\n    int nb_shift = 0;\n    int exclam = 0;\n    int closed_bracket = 0;\n    int op2_minus = 0;\n    uint32_t opcode = 0;\n    // Note: ldr r0, [r4, #4]  ; simple offset: r0 = *(int*)(r4+4); r4 unchanged\n    // Note: ldr r0, [r4, #4]! ; pre-indexed:   r0 = *(int*)(r4+4); r4 = r4+4\n    // Note: ldr r0, [r4], #4  ; post-indexed:  r0 = *(int*)(r4+0); r4 = r4+4\n\n    parse_operand(s1, &ops[0]);\n    if (ops[0].type == OP_REG32)\n        opcode |= ENCODE_RD(ops[0].reg);\n    else {\n        expect(\"(destination operand) register\");\n    }\n    if (tok != ',')\n        expect(\"at least two arguments\");\n    next(); // skip ','\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_strexbeq:\n    case TOK_ASM_strexeq:\n        parse_operand(s1, &strex_operand);\n        if (strex_operand.type != OP_REG32) {\n            expect(\"register\");\n        }\n        if (tok != ',')\n            expect(\"at least three arguments\");\n        else\n            next(); // skip ','\n        break;\n    }\n\n    skip('[');\n    parse_operand(s1, &ops[1]);\n    if (ops[1].type == OP_REG32)\n        opcode |= ENCODE_RN(ops[1].reg);\n    else {\n        expect(\"(first source operand) register\");\n    }\n    if (tok == ']') {\n        next();\n        closed_bracket = 1;\n        // exclam = 1; // implicit in hardware; don't do it in software\n    }\n    if (tok == ',') {\n        next(); // skip ','\n        if (tok == '-') {\n            op2_minus = 1;\n            next();\n        }\n        parse_operand(s1, &ops[2]);\n        if (ops[2].type == OP_REG32) {\n            if (ops[2].reg == 15) {\n                tcc_error(\"Using 'pc' for register offset in '%s' is not implemented by ARM\", get_tok_str(token, NULL));\n            }\n            if (tok == ',') {\n                next();\n                opcode |= asm_parse_optional_shift(s1, &nb_shift, &shift);\n                if (opcode == 0)\n                    expect(\"shift directive, or no comma\");\n            }\n        }\n    } else {\n        // end of input expression in brackets--assume 0 offset\n        ops[2].type = OP_IM8;\n        ops[2].e.v = 0;\n        opcode |= 1 << 24; // add offset before transfer\n    }\n    if (!closed_bracket) {\n        skip(']');\n        opcode |= 1 << 24; // add offset before transfer\n        if (tok == '!') {\n            exclam = 1;\n            next(); // skip '!'\n        }\n    }\n\n    // single data transfer: 0 1 I P U B W L << 20 (general case):\n    // operands:\n    //    Rd: destination operand [ok]\n    //    Rn: first source operand [ok]\n    //    Operand2: bits 11...0 [ok]\n    // I: immediate operand? [ok]\n    // P: Pre/post indexing is PRE: Add offset before transfer [ok]\n    // U: Up/down is up? (*adds* offset to base) [ok]\n    // B: Byte/word is byte?  [ok]\n    // W: Write address back into base? [ok]\n    // L: Load/store is load? [ok]\n    if (exclam)\n        opcode |= 1 << 21; // write offset back into register\n\n    if (ops[2].type == OP_IM32 || ops[2].type == OP_IM8 || ops[2].type == OP_IM8N) {\n        int v = ops[2].e.v;\n        if (op2_minus)\n            tcc_error(\"minus before '#' not supported for immediate values\");\n        if (v >= 0) {\n            opcode |= 1 << 23; // up\n            if (v >= 0x1000)\n                tcc_error(\"offset out of range for '%s'\", get_tok_str(token, NULL));\n            else\n                opcode |= v;\n        } else { // down\n            if (v <= -0x1000)\n                tcc_error(\"offset out of range for '%s'\", get_tok_str(token, NULL));\n            else\n                opcode |= -v;\n        }\n    } else if (ops[2].type == OP_REG32) {\n        if (!op2_minus)\n            opcode |= 1 << 23; // up\n        opcode |= ENCODE_IMMEDIATE_FLAG; /* if set, it means it's NOT immediate */\n        opcode |= ops[2].reg;\n    } else\n        expect(\"register\");\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_strbeq:\n        opcode |= 1 << 22; // B\n        /* fallthrough */\n    case TOK_ASM_streq:\n        opcode |= 1 << 26; // Load/Store\n        if (nb_shift)\n            opcode |= asm_encode_shift(&shift);\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_ldrbeq:\n        opcode |= 1 << 22; // B\n        /* fallthrough */\n    case TOK_ASM_ldreq:\n        opcode |= 1 << 20; // L\n        opcode |= 1 << 26; // Load/Store\n        if (nb_shift)\n            opcode |= asm_encode_shift(&shift);\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_strexbeq:\n        opcode |= 1 << 22; // B\n        /* fallthrough */\n    case TOK_ASM_strexeq:\n        if ((opcode & 0xFFF) || nb_shift) {\n            tcc_error(\"neither offset nor shift allowed with 'strex'\");\n        } else if (opcode & ENCODE_IMMEDIATE_FLAG) { // if set, it means it's NOT immediate\n            tcc_error(\"offset not allowed with 'strex'\");\n        }\n        if ((opcode & (1 << 24)) == 0) { // add offset after transfer\n            tcc_error(\"adding offset after transfer not allowed with 'strex'\");\n        }\n\n        opcode |= 0xf90; // Used to mean: barrel shifter is enabled, barrel shift register is r15, mode is LSL\n        opcode |= strex_operand.reg;\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_ldrexbeq:\n        opcode |= 1 << 22; // B\n        /* fallthrough */\n    case TOK_ASM_ldrexeq:\n        if ((opcode & 0xFFF) || nb_shift) {\n            tcc_error(\"neither offset nor shift allowed with 'ldrex'\");\n        } else if (opcode & ENCODE_IMMEDIATE_FLAG) { // if set, it means it's NOT immediate\n            tcc_error(\"offset not allowed with 'ldrex'\");\n        }\n        if ((opcode & (1 << 24)) == 0) { // add offset after transfer\n            tcc_error(\"adding offset after transfer not allowed with 'ldrex'\");\n        }\n        opcode |= 1 << 20; // L\n        opcode |= 0x00f;\n        opcode |= 0xf90; // Used to mean: barrel shifter is enabled, barrel shift register is r15, mode is LSL\n        asm_emit_opcode(token, opcode);\n        break;\n    default:\n        expect(\"data transfer instruction\");\n    }\n}\n\n// Note: Only call this using a VFP register if you know exactly what you are doing (i.e. cp_number is 10 or 11 and you are doing a vmov)\nstatic void asm_emit_coprocessor_data_transfer(uint32_t high_nibble, uint8_t cp_number, uint8_t CRd, const Operand* Rn, const Operand* offset, int offset_minus, int preincrement, int writeback, int long_transfer, int load) {\n    uint32_t opcode = 0x0;\n    opcode |= 1 << 26; // Load/Store\n    opcode |= 1 << 27; // coprocessor\n\n    if (long_transfer)\n        opcode |= 1 << 22; // long transfer\n\n    if (load)\n        opcode |= 1 << 20; // L\n\n    opcode |= cp_number << 8;\n\n    //assert(CRd < 16);\n    opcode |= ENCODE_RD(CRd);\n\n    if (Rn->type != OP_REG32)\n        expect(\"register\");\n\n    //assert(Rn->reg < 16);\n    opcode |= ENCODE_RN(Rn->reg);\n    if (preincrement)\n        opcode |= 1 << 24; // add offset before transfer\n\n    if (writeback)\n        opcode |= 1 << 21; // write offset back into register\n\n    if (offset->type == OP_IM8 || offset->type == OP_IM8N || offset->type == OP_IM32) {\n        int v = offset->e.v;\n        if (offset_minus)\n            tcc_error(\"minus before '#' not supported for immediate values\");\n        if (offset->type == OP_IM8N || v < 0)\n            v = -v;\n        else\n            opcode |= 1 << 23; // up\n        if (v & 3) {\n            tcc_error(\"immediate offset must be a multiple of 4\");\n        }\n        v >>= 2;\n        if (v > 255) {\n            tcc_error(\"immediate offset must be between -1020 and 1020\");\n        }\n        opcode |= v;\n    } else if (offset->type == OP_REG32) {\n        if (!offset_minus)\n            opcode |= 1 << 23; // up\n        opcode |= ENCODE_IMMEDIATE_FLAG; /* if set, it means it's NOT immediate */\n        opcode |= offset->reg;\n        tcc_error(\"Using register offset to register address is not possible here\");\n    } else if (offset->type == OP_VREG64) {\n        opcode |= 16;\n        opcode |= offset->reg;\n    } else\n        expect(\"immediate or register\");\n\n    asm_emit_unconditional_opcode((high_nibble << 28) | opcode);\n}\n\n// Almost exactly the same as asm_single_data_transfer_opcode.\n// Difference: Offsets are smaller and multiples of 4; no shifts, no STREX, ENCODE_IMMEDIATE_FLAG is inverted again.\nstatic void asm_coprocessor_data_transfer_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    uint8_t coprocessor;\n    uint8_t coprocessor_destination_register;\n    int preincrement = 0;\n    int exclam = 0;\n    int closed_bracket = 0;\n    int op2_minus = 0;\n    int long_transfer = 0;\n    // Note: ldc p1, c0, [r4, #4]  ; simple offset: r0 = *(int*)(r4+4); r4 unchanged\n    // Note: ldc p2, c0, [r4, #4]! ; pre-indexed:   r0 = *(int*)(r4+4); r4 = r4+4\n    // Note: ldc p3, c0, [r4], #4  ; post-indexed:  r0 = *(int*)(r4+0); r4 = r4+4\n\n    if (tok >= TOK_ASM_p0 && tok <= TOK_ASM_p15) {\n        coprocessor = tok - TOK_ASM_p0;\n        next();\n    } else {\n        expect(\"'c<number>'\");\n    }\n\n    skip(',');\n\n    if (tok >= TOK_ASM_c0 && tok <= TOK_ASM_c15) {\n        coprocessor_destination_register = tok - TOK_ASM_c0;\n        next();\n    } else {\n        expect(\"'c<number>'\");\n    }\n\n    skip(',');\n    skip('[');\n    parse_operand(s1, &ops[1]);\n    if (ops[1].type != OP_REG32) {\n        expect(\"(first source operand) register\");\n    }\n    if (tok == ']') {\n        next();\n        closed_bracket = 1;\n        // exclam = 1; // implicit in hardware; don't do it in software\n    }\n    if (tok == ',') {\n        next(); // skip ','\n        if (tok == '-') {\n            op2_minus = 1;\n            next();\n        }\n        parse_operand(s1, &ops[2]);\n        if (ops[2].type == OP_REG32) {\n            if (ops[2].reg == 15) {\n                tcc_error(\"Using 'pc' for register offset in '%s' is not implemented by ARM\", get_tok_str(token, NULL));\n            }\n        } else if (ops[2].type == OP_VREG64) {\n            tcc_error(\"'%s' does not support VFP register operand\", get_tok_str(token, NULL));\n        }\n    } else {\n        // end of input expression in brackets--assume 0 offset\n        ops[2].type = OP_IM8;\n        ops[2].e.v = 0;\n        preincrement = 1; // add offset before transfer\n    }\n    if (!closed_bracket) {\n        skip(']');\n        preincrement = 1; // add offset before transfer\n        if (tok == '!') {\n            exclam = 1;\n            next(); // skip '!'\n        }\n    }\n\n    // TODO: Support options.\n\n    if (token == TOK_ASM_ldc2 || token == TOK_ASM_stc2 || token == TOK_ASM_ldc2l || token == TOK_ASM_stc2l) {\n        switch (token) {\n        case TOK_ASM_ldc2l:\n            long_transfer = 1; // long transfer\n            /* fallthrough */\n        case TOK_ASM_ldc2:\n            asm_emit_coprocessor_data_transfer(0xF, coprocessor, coprocessor_destination_register, &ops[1], &ops[2], op2_minus, preincrement, exclam, long_transfer, 1);\n            break;\n        case TOK_ASM_stc2l:\n            long_transfer = 1; // long transfer\n            /* fallthrough */\n        case TOK_ASM_stc2:\n            asm_emit_coprocessor_data_transfer(0xF, coprocessor, coprocessor_destination_register, &ops[1], &ops[2], op2_minus, preincrement, exclam, long_transfer, 0);\n            break;\n        }\n    } else switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_stcleq:\n        long_transfer = 1;\n        /* fallthrough */\n    case TOK_ASM_stceq:\n        asm_emit_coprocessor_data_transfer(condition_code_of_token(token), coprocessor, coprocessor_destination_register, &ops[1], &ops[2], op2_minus, preincrement, exclam, long_transfer, 0);\n        break;\n    case TOK_ASM_ldcleq:\n        long_transfer = 1;\n        /* fallthrough */\n    case TOK_ASM_ldceq:\n        asm_emit_coprocessor_data_transfer(condition_code_of_token(token), coprocessor, coprocessor_destination_register, &ops[1], &ops[2], op2_minus, preincrement, exclam, long_transfer, 1);\n        break;\n    default:\n        expect(\"coprocessor data transfer instruction\");\n    }\n}\n\n#if defined(TCC_ARM_VFP)\n#define CP_SINGLE_PRECISION_FLOAT 10\n#define CP_DOUBLE_PRECISION_FLOAT 11\n\nstatic void asm_floating_point_single_data_transfer_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    uint8_t coprocessor = 0;\n    uint8_t coprocessor_destination_register = 0;\n    int long_transfer = 0;\n    // Note: vldr p1, c0, [r4, #4]  ; simple offset: r0 = *(int*)(r4+4); r4 unchanged\n    // Note: Not allowed: vldr p2, c0, [r4, #4]! ; pre-indexed:   r0 = *(int*)(r4+4); r4 = r4+4\n    // Note: Not allowed: vldr p3, c0, [r4], #4  ; post-indexed:  r0 = *(int*)(r4+0); r4 = r4+4\n\n    parse_operand(s1, &ops[0]);\n    if (ops[0].type == OP_VREG32) {\n        coprocessor = CP_SINGLE_PRECISION_FLOAT;\n        coprocessor_destination_register = ops[0].reg;\n        long_transfer = coprocessor_destination_register & 1;\n        coprocessor_destination_register >>= 1;\n    } else if (ops[0].type == OP_VREG64) {\n        coprocessor = CP_DOUBLE_PRECISION_FLOAT;\n        coprocessor_destination_register = ops[0].reg;\n        next();\n    } else {\n        expect(\"floating point register\");\n    }\n\n    skip(',');\n    skip('[');\n    parse_operand(s1, &ops[1]);\n    if (ops[1].type != OP_REG32) {\n        expect(\"(first source operand) register\");\n    }\n    if (tok == ',') {\n        next(); // skip ','\n        parse_operand(s1, &ops[2]);\n        if (ops[2].type != OP_IM8 && ops[2].type != OP_IM8N) {\n            expect(\"immediate offset\");\n        }\n    } else {\n        // end of input expression in brackets--assume 0 offset\n        ops[2].type = OP_IM8;\n        ops[2].e.v = 0;\n    }\n    skip(']');\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vldreq:\n        asm_emit_coprocessor_data_transfer(condition_code_of_token(token), coprocessor, coprocessor_destination_register, &ops[1], &ops[2], 0, 1, 0, long_transfer, 1);\n        break;\n    case TOK_ASM_vstreq:\n        asm_emit_coprocessor_data_transfer(condition_code_of_token(token), coprocessor, coprocessor_destination_register, &ops[1], &ops[2], 0, 1, 0, long_transfer, 0);\n        break;\n    default:\n        expect(\"floating point data transfer instruction\");\n    }\n}\n\nstatic void asm_floating_point_block_data_transfer_opcode(TCCState *s1, int token)\n{\n    uint8_t coprocessor = 0;\n    int first_regset_register;\n    int last_regset_register;\n    uint8_t regset_item_count;\n    uint8_t extra_register_bit = 0;\n    int op0_exclam = 0;\n    int load = 0;\n    int preincrement = 0;\n    Operand ops[1];\n    Operand offset;\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vpusheq:\n    case TOK_ASM_vpopeq:\n        ops[0].type = OP_REG32;\n        ops[0].reg = 13; // sp\n        op0_exclam = 1;\n        break;\n    default:\n        parse_operand(s1, &ops[0]);\n        if (tok == '!') {\n            op0_exclam = 1;\n            next(); // skip '!'\n        }\n        skip(',');\n    }\n\n    skip('{');\n    first_regset_register = asm_parse_vfp_regvar(tok, 1);\n    if ((first_regset_register = asm_parse_vfp_regvar(tok, 1)) != -1) {\n        coprocessor = CP_DOUBLE_PRECISION_FLOAT;\n        next();\n    } else if ((first_regset_register = asm_parse_vfp_regvar(tok, 0)) != -1) {\n        coprocessor = CP_SINGLE_PRECISION_FLOAT;\n        next();\n    } else {\n        expect(\"floating-point register\");\n    }\n\n    if (tok == '-') {\n        next();\n        if ((last_regset_register = asm_parse_vfp_regvar(tok, coprocessor == CP_DOUBLE_PRECISION_FLOAT)) != -1)\n            next();\n        else {\n            expect(\"floating-point register\");\n        }\n    } else\n        last_regset_register = first_regset_register;\n\n    if (last_regset_register < first_regset_register) {\n        tcc_error(\"registers will be processed in ascending order by hardware--but are not specified in ascending order here\");\n    }\n    skip('}');\n    // Note: 0 (one down) is not implemented by us regardless.\n    regset_item_count = last_regset_register - first_regset_register + 1;\n    if (coprocessor == CP_DOUBLE_PRECISION_FLOAT)\n        regset_item_count <<= 1;\n    else {\n        extra_register_bit = first_regset_register & 1;\n        first_regset_register >>= 1;\n    }\n    offset.type = OP_IM8;\n    offset.e.v = regset_item_count << 2;\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vstmeq: // post-increment store\n    case TOK_ASM_vstmiaeq: // post-increment store\n        break;\n    case TOK_ASM_vpopeq:\n    case TOK_ASM_vldmeq: // post-increment load\n    case TOK_ASM_vldmiaeq: // post-increment load\n        load = 1;\n        break;\n    case TOK_ASM_vldmdbeq: // pre-decrement load\n        load = 1;\n        /* fallthrough */\n    case TOK_ASM_vpusheq:\n    case TOK_ASM_vstmdbeq: // pre-decrement store\n        offset.type = OP_IM8N;\n        offset.e.v = -offset.e.v;\n        preincrement = 1;\n        break;\n    default:\n        expect(\"floating point block data transfer instruction\");\n    }\n    if (ops[0].type != OP_REG32)\n        expect(\"(first operand) register\");\n    else if (ops[0].reg == 15)\n        tcc_error(\"'%s' does not support 'pc' as operand\", get_tok_str(token, NULL));\n    else if (!op0_exclam && ARM_INSTRUCTION_GROUP(token) != TOK_ASM_vldmeq && ARM_INSTRUCTION_GROUP(token) != TOK_ASM_vldmiaeq && ARM_INSTRUCTION_GROUP(token) != TOK_ASM_vstmeq && ARM_INSTRUCTION_GROUP(token) != TOK_ASM_vstmiaeq)\n        tcc_error(\"first operand of '%s' should have an exclamation mark\", get_tok_str(token, NULL));\n    else\n        asm_emit_coprocessor_data_transfer(condition_code_of_token(token), coprocessor, first_regset_register, &ops[0], &offset, 0, preincrement, op0_exclam, extra_register_bit, load);\n}\n\n#define VMOV_FRACTIONAL_DIGITS 7\n#define VMOV_ONE 10000000 /* pow(10, VMOV_FRACTIONAL_DIGITS) */\n\nstatic uint32_t vmov_parse_fractional_part(const char* s)\n{\n    uint32_t result = 0;\n    int i;\n    for (i = 0; i < VMOV_FRACTIONAL_DIGITS; ++i) {\n        char c = *s;\n        result *= 10;\n        if (c >= '0' && c <= '9') {\n            result += (c - '0');\n            ++s;\n        }\n    }\n    if (*s)\n        expect(\"decimal numeral\");\n    return result;\n}\n\nstatic int vmov_linear_approx_index(uint32_t beginning, uint32_t end, uint32_t value)\n{\n    int i;\n    uint32_t k;\n    uint32_t xvalue;\n\n    k = (end - beginning)/16;\n    for (xvalue = beginning, i = 0; i < 16; ++i, xvalue += k) {\n        if (value == xvalue)\n            return i;\n    }\n    //assert(0);\n    return -1;\n}\n\nstatic uint32_t vmov_parse_immediate_value() {\n    uint32_t value;\n    unsigned long integral_value;\n    const char *p;\n\n    if (tok != TOK_PPNUM) {\n        expect(\"immediate value\");\n    }\n    p = tokc.str.data;\n    errno = 0;\n    integral_value = strtoul(p, (char **)&p, 0);\n\n    if (errno || integral_value >= 32) {\n        tcc_error(\"invalid floating-point immediate value\");\n    }\n\n    value = (uint32_t) integral_value * VMOV_ONE;\n    if (*p == '.') {\n        ++p;\n        value += vmov_parse_fractional_part(p);\n    }\n    next();\n    return value;\n}\n\nstatic uint8_t vmov_encode_immediate_value(uint32_t value)\n{\n    uint32_t limit;\n    uint32_t end = 0;\n    uint32_t beginning = 0;\n    int r = -1;\n    int n;\n    int i;\n\n    limit = 32 * VMOV_ONE;\n    for (i = 0; i < 8; ++i) {\n        if (value < limit) {\n            end = limit;\n            limit >>= 1;\n            beginning = limit;\n            r = i;\n        } else\n            limit >>= 1;\n    }\n    if (r == -1 || value < beginning || value > end) {\n        tcc_error(\"invalid decimal number for vmov: %d\", value);\n    }\n    n = vmov_linear_approx_index(beginning, end, value);\n    return n | (((3 - r) & 0x7) << 4);\n}\n\n// Not standalone.\nstatic void asm_floating_point_immediate_data_processing_opcode_tail(TCCState *s1, int token, uint8_t coprocessor, uint8_t CRd) {\n    uint8_t opcode1 = 0;\n    uint8_t opcode2 = 0;\n    uint8_t operands[3] = {0, 0, 0};\n    uint32_t immediate_value = 0;\n    int op_minus = 0;\n    uint8_t code;\n\n    operands[0] = CRd;\n\n    if (tok == '#' || tok == '$') {\n        next();\n    }\n    if (tok == '-') {\n        op_minus = 1;\n        next();\n    }\n    immediate_value = vmov_parse_immediate_value();\n\n    opcode1 = 11; // \"Other\" instruction\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vcmpeq_f32:\n    case TOK_ASM_vcmpeq_f64:\n        opcode2 = 2;\n        operands[1] = 5;\n        if (immediate_value) {\n            expect(\"Immediate value 0\");\n        }\n        break;\n    case TOK_ASM_vcmpeeq_f32:\n    case TOK_ASM_vcmpeeq_f64:\n        opcode2 = 6;\n        operands[1] = 5;\n        if (immediate_value) {\n            expect(\"Immediate value 0\");\n        }\n        break;\n    case TOK_ASM_vmoveq_f32:\n    case TOK_ASM_vmoveq_f64:\n        opcode2 = 0;\n        if (op_minus)\n            operands[1] = 0x8;\n        else\n            operands[1] = 0x0;\n        code = vmov_encode_immediate_value(immediate_value);\n        operands[1] |= code >> 4;\n        operands[2] = code & 0xF;\n        break;\n    default:\n        expect(\"known floating point with immediate instruction\");\n    }\n\n    if (coprocessor == CP_SINGLE_PRECISION_FLOAT) {\n        if (operands[0] & 1)\n            opcode1 |= 4;\n        operands[0] >>= 1;\n    }\n\n    asm_emit_coprocessor_opcode(condition_code_of_token(token), coprocessor, opcode1, operands[0], operands[1], operands[2], opcode2, 0);\n}\n\nstatic void asm_floating_point_reg_arm_reg_transfer_opcode_tail(TCCState *s1, int token, int coprocessor, int nb_arm_regs, int nb_ops, Operand ops[3]) {\n    uint8_t opcode1 = 0;\n    uint8_t opcode2 = 0;\n    switch (coprocessor) {\n    case CP_SINGLE_PRECISION_FLOAT:\n        // \"vmov.f32 r2, s3\" or \"vmov.f32 s3, r2\"\n        if (nb_ops != 2 || nb_arm_regs != 1) {\n            tcc_error(\"vmov.f32 only implemented for one VFP register operand and one ARM register operands\");\n        }\n        if (ops[0].type != OP_REG32) { // determine mode: load or store\n            // need to swap operands 0 and 1\n            memcpy(&ops[2], &ops[1], sizeof(ops[2]));\n            memcpy(&ops[1], &ops[0], sizeof(ops[1]));\n            memcpy(&ops[0], &ops[2], sizeof(ops[0]));\n        } else\n            opcode1 |= 1;\n\n        if (ops[1].type == OP_VREG32) {\n            if (ops[1].reg & 1)\n                opcode2 |= 4;\n            ops[1].reg >>= 1;\n        }\n\n        if (ops[0].type == OP_VREG32) {\n            if (ops[0].reg & 1)\n                opcode1 |= 4;\n            ops[0].reg >>= 1;\n        }\n\n        asm_emit_coprocessor_opcode(condition_code_of_token(token), coprocessor, opcode1, ops[0].reg, (ops[1].type == OP_IM8) ? ops[1].e.v : ops[1].reg, 0x10, opcode2, 0);\n        break;\n    case CP_DOUBLE_PRECISION_FLOAT:\n        if (nb_ops != 3 || nb_arm_regs != 2) {\n            tcc_error(\"vmov.f32 only implemented for one VFP register operand and two ARM register operands\");\n        }\n        // Determine whether it's a store into a VFP register (vmov \"d1, r2, r3\") rather than \"vmov r2, r3, d1\"\n        if (ops[0].type == OP_VREG64) {\n            if (ops[2].type == OP_REG32) {\n                Operand temp;\n                // need to rotate operand list to the left\n                memcpy(&temp, &ops[0], sizeof(temp));\n                memcpy(&ops[0], &ops[1], sizeof(ops[0]));\n                memcpy(&ops[1], &ops[2], sizeof(ops[1]));\n                memcpy(&ops[2], &temp, sizeof(ops[2]));\n            } else {\n                tcc_error(\"vmov.f64 only implemented for one VFP register operand and two ARM register operands\");\n            }\n        } else if (ops[0].type != OP_REG32 || ops[1].type != OP_REG32 || ops[2].type != OP_VREG64) {\n            tcc_error(\"vmov.f64 only implemented for one VFP register operand and two ARM register operands\");\n        } else {\n            opcode1 |= 1;\n        }\n        asm_emit_coprocessor_data_transfer(condition_code_of_token(token), coprocessor, ops[0].reg, &ops[1], &ops[2], 0, 0, 0, 1, opcode1);\n        break;\n    default:\n        tcc_internal_error(\"unknown coprocessor\");\n    }\n}\n\nstatic void asm_floating_point_vcvt_data_processing_opcode(TCCState *s1, int token) {\n    uint8_t coprocessor = 0;\n    Operand ops[3];\n    uint8_t opcode1 = 11;\n    uint8_t opcode2 = 2;\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vcvtreq_s32_f64:\n    case TOK_ASM_vcvtreq_u32_f64:\n    case TOK_ASM_vcvteq_s32_f64:\n    case TOK_ASM_vcvteq_u32_f64:\n    case TOK_ASM_vcvteq_f64_s32:\n    case TOK_ASM_vcvteq_f64_u32:\n    case TOK_ASM_vcvteq_f32_f64:\n       coprocessor = CP_DOUBLE_PRECISION_FLOAT;\n       break;\n    case TOK_ASM_vcvtreq_s32_f32:\n    case TOK_ASM_vcvtreq_u32_f32:\n    case TOK_ASM_vcvteq_s32_f32:\n    case TOK_ASM_vcvteq_u32_f32:\n    case TOK_ASM_vcvteq_f32_s32:\n    case TOK_ASM_vcvteq_f32_u32:\n    case TOK_ASM_vcvteq_f64_f32:\n       coprocessor = CP_SINGLE_PRECISION_FLOAT;\n       break;\n    default:\n       tcc_error(\"Unknown coprocessor for instruction '%s'\", get_tok_str(token, NULL));\n    }\n\n    parse_operand(s1, &ops[0]);\n    ops[1].type = OP_IM8;\n    ops[1].e.v = 8;\n    /* floating-point -> integer */\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vcvtreq_s32_f32:\n    case TOK_ASM_vcvtreq_s32_f64:\n    case TOK_ASM_vcvteq_s32_f32:\n    case TOK_ASM_vcvteq_s32_f64:\n        ops[1].e.v |= 1; // signed\n        /* fall through */\n    case TOK_ASM_vcvteq_u32_f32:\n    case TOK_ASM_vcvteq_u32_f64:\n    case TOK_ASM_vcvtreq_u32_f32:\n    case TOK_ASM_vcvtreq_u32_f64:\n        ops[1].e.v |= 4; // to_integer (opc2)\n        break;\n    /* floating-point size conversion */\n    case TOK_ASM_vcvteq_f64_f32:\n    case TOK_ASM_vcvteq_f32_f64:\n        ops[1].e.v = 7;\n        break;\n    }\n\n    skip(',');\n    parse_operand(s1, &ops[2]);\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    /* floating-point -> integer */\n    case TOK_ASM_vcvteq_s32_f32:\n    case TOK_ASM_vcvteq_s32_f64:\n    case TOK_ASM_vcvteq_u32_f32:\n    case TOK_ASM_vcvteq_u32_f64:\n        opcode2 |= 4; // round_zero\n        break;\n\n    /* integer -> floating-point */\n    case TOK_ASM_vcvteq_f64_s32:\n    case TOK_ASM_vcvteq_f32_s32:\n        opcode2 |= 4; // signed--special\n        break;\n\n    /* floating-point size conversion */\n    case TOK_ASM_vcvteq_f64_f32:\n    case TOK_ASM_vcvteq_f32_f64:\n        opcode2 |= 4; // always set\n        break;\n    }\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vcvteq_f64_u32:\n    case TOK_ASM_vcvteq_f64_s32:\n    case TOK_ASM_vcvteq_f64_f32:\n        if (ops[0].type == OP_VREG64 && ops[2].type == OP_VREG32) {\n        } else {\n            expect(\"d<number>, s<number>\");\n        }\n        break;\n    default:\n        if (coprocessor == CP_SINGLE_PRECISION_FLOAT) {\n            if (ops[0].type == OP_VREG32 && ops[2].type == OP_VREG32) {\n            } else {\n                expect(\"s<number>, s<number>\");\n            }\n        } else if (coprocessor == CP_DOUBLE_PRECISION_FLOAT) {\n            if (ops[0].type == OP_VREG32 && ops[2].type == OP_VREG64) {\n            } else {\n                expect(\"s<number>, d<number>\");\n            }\n        }\n    }\n\n    if (ops[2].type == OP_VREG32) {\n        if (ops[2].reg & 1)\n            opcode2 |= 1;\n        ops[2].reg >>= 1;\n    }\n    if (ops[0].type == OP_VREG32) {\n        if (ops[0].reg & 1)\n            opcode1 |= 4;\n        ops[0].reg >>= 1;\n    }\n    asm_emit_coprocessor_opcode(condition_code_of_token(token), coprocessor, opcode1, ops[0].reg, (ops[1].type == OP_IM8) ? ops[1].e.v : ops[1].reg, (ops[2].type == OP_IM8) ? ops[2].e.v : ops[2].reg, opcode2, 0);\n}\n\nstatic void asm_floating_point_data_processing_opcode(TCCState *s1, int token) {\n    uint8_t coprocessor = CP_SINGLE_PRECISION_FLOAT;\n    uint8_t opcode1 = 0;\n    uint8_t opcode2 = 0; // (0 || 2) | register selection\n    Operand ops[3];\n    uint8_t nb_ops = 0;\n    int vmov = 0;\n    int nb_arm_regs = 0;\n\n/* TODO:\n   Instruction    opcode opcode2  Reason\n   =============================================================\n   -              1?00   ?1?      Undefined\n   VFNMS          1?01   ?0?      Must be unconditional\n   VFNMA          1?01   ?1?      Must be unconditional\n   VFMA           1?10   ?0?      Must be unconditional\n   VFMS           1?10   ?1?      Must be unconditional\n\n   VMOV Fd, Fm\n   VMOV Sn, Sm, Rd, Rn\n   VMOV Rd, Rn, Sn, Sm\n   VMOV Dn[0], Rd\n   VMOV Rd, Dn[0]\n   VMOV Dn[1], Rd\n   VMOV Rd, Dn[1]\n*/\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vmlaeq_f64:\n    case TOK_ASM_vmlseq_f64:\n    case TOK_ASM_vnmlseq_f64:\n    case TOK_ASM_vnmlaeq_f64:\n    case TOK_ASM_vmuleq_f64:\n    case TOK_ASM_vnmuleq_f64:\n    case TOK_ASM_vaddeq_f64:\n    case TOK_ASM_vsubeq_f64:\n    case TOK_ASM_vdiveq_f64:\n    case TOK_ASM_vnegeq_f64:\n    case TOK_ASM_vabseq_f64:\n    case TOK_ASM_vsqrteq_f64:\n    case TOK_ASM_vcmpeq_f64:\n    case TOK_ASM_vcmpeeq_f64:\n    case TOK_ASM_vmoveq_f64:\n        coprocessor = CP_DOUBLE_PRECISION_FLOAT;\n    }\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vmoveq_f32:\n    case TOK_ASM_vmoveq_f64:\n        vmov = 1;\n        break;\n    }\n\n    for (nb_ops = 0; nb_ops < 3; ) {\n        // Note: Necessary because parse_operand can't parse decimal numerals.\n        if (nb_ops == 1 && (tok == '#' || tok == '$' || tok == TOK_PPNUM || tok == '-')) {\n            asm_floating_point_immediate_data_processing_opcode_tail(s1, token, coprocessor, ops[0].reg);\n            return;\n        }\n        parse_operand(s1, &ops[nb_ops]);\n        if (vmov && ops[nb_ops].type == OP_REG32) {\n            ++nb_arm_regs;\n        } else if (ops[nb_ops].type == OP_VREG32) {\n            if (coprocessor != CP_SINGLE_PRECISION_FLOAT) {\n                expect(\"'s<number>'\");\n            }\n        } else if (ops[nb_ops].type == OP_VREG64) {\n            if (coprocessor != CP_DOUBLE_PRECISION_FLOAT) {\n                expect(\"'d<number>'\");\n            }\n        } else {\n            expect(\"floating point register\");\n        }\n        ++nb_ops;\n        if (tok == ',')\n            next();\n        else\n            break;\n    }\n\n    if (nb_arm_regs == 0) {\n        if (nb_ops == 2) { // implicit\n            memcpy(&ops[2], &ops[1], sizeof(ops[1])); // move ops[2]\n            memcpy(&ops[1], &ops[0], sizeof(ops[0])); // ops[1] was implicit\n            nb_ops = 3;\n        }\n        if (nb_ops < 3) {\n            tcc_error(\"Not enough operands for '%s' (%u)\", get_tok_str(token, NULL), nb_ops);\n        }\n    }\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vmlaeq_f32:\n    case TOK_ASM_vmlaeq_f64:\n        opcode1 = 0;\n        opcode2 = 0;\n        break;\n    case TOK_ASM_vmlseq_f32:\n    case TOK_ASM_vmlseq_f64:\n        opcode1 = 0;\n        opcode2 = 2;\n        break;\n    case TOK_ASM_vnmlseq_f32:\n    case TOK_ASM_vnmlseq_f64:\n        opcode1 = 1;\n        opcode2 = 0;\n        break;\n    case TOK_ASM_vnmlaeq_f32:\n    case TOK_ASM_vnmlaeq_f64:\n        opcode1 = 1;\n        opcode2 = 2;\n        break;\n    case TOK_ASM_vmuleq_f32:\n    case TOK_ASM_vmuleq_f64:\n        opcode1 = 2;\n        opcode2 = 0;\n        break;\n    case TOK_ASM_vnmuleq_f32:\n    case TOK_ASM_vnmuleq_f64:\n        opcode1 = 2;\n        opcode2 = 2;\n        break;\n    case TOK_ASM_vaddeq_f32:\n    case TOK_ASM_vaddeq_f64:\n        opcode1 = 3;\n        opcode2 = 0;\n        break;\n    case TOK_ASM_vsubeq_f32:\n    case TOK_ASM_vsubeq_f64:\n        opcode1 = 3;\n        opcode2 = 2;\n        break;\n    case TOK_ASM_vdiveq_f32:\n    case TOK_ASM_vdiveq_f64:\n        opcode1 = 8;\n        opcode2 = 0;\n        break;\n    case TOK_ASM_vnegeq_f32:\n    case TOK_ASM_vnegeq_f64:\n        opcode1 = 11; // Other\" instruction\n        opcode2 = 2;\n        ops[1].type = OP_IM8;\n        ops[1].e.v = 1;\n        break;\n    case TOK_ASM_vabseq_f32:\n    case TOK_ASM_vabseq_f64:\n        opcode1 = 11; // \"Other\" instruction\n        opcode2 = 6;\n        ops[1].type = OP_IM8;\n        ops[1].e.v = 0;\n        break;\n    case TOK_ASM_vsqrteq_f32:\n    case TOK_ASM_vsqrteq_f64:\n        opcode1 = 11; // \"Other\" instruction\n        opcode2 = 6;\n        ops[1].type = OP_IM8;\n        ops[1].e.v = 1;\n        break;\n    case TOK_ASM_vcmpeq_f32:\n    case TOK_ASM_vcmpeq_f64:\n        opcode1 = 11; // \"Other\" instruction\n        opcode2 = 2;\n        ops[1].type = OP_IM8;\n        ops[1].e.v = 4;\n        break;\n    case TOK_ASM_vcmpeeq_f32:\n    case TOK_ASM_vcmpeeq_f64:\n        opcode1 = 11; // \"Other\" instruction\n        opcode2 = 6;\n        ops[1].type = OP_IM8;\n        ops[1].e.v = 4;\n        break;\n    case TOK_ASM_vmoveq_f32:\n    case TOK_ASM_vmoveq_f64:\n        if (nb_arm_regs > 0) { // vmov.f32 r2, s3 or similar\n            asm_floating_point_reg_arm_reg_transfer_opcode_tail(s1, token, coprocessor, nb_arm_regs, nb_ops, ops);\n            return;\n        } else {\n            opcode1 = 11; // \"Other\" instruction\n            opcode2 = 2;\n            ops[1].type = OP_IM8;\n            ops[1].e.v = 0;\n        }\n        break;\n    default:\n        expect(\"known floating point instruction\");\n    }\n\n    if (coprocessor == CP_SINGLE_PRECISION_FLOAT) {\n        if (ops[2].type == OP_VREG32) {\n            if (ops[2].reg & 1)\n                opcode2 |= 1;\n            ops[2].reg >>= 1;\n        }\n\n        if (ops[1].type == OP_VREG32) {\n            if (ops[1].reg & 1)\n                opcode2 |= 4;\n            ops[1].reg >>= 1;\n        }\n\n        if (ops[0].type == OP_VREG32) {\n            if (ops[0].reg & 1)\n                opcode1 |= 4;\n            ops[0].reg >>= 1;\n        }\n    }\n\n    asm_emit_coprocessor_opcode(condition_code_of_token(token), coprocessor, opcode1, ops[0].reg, (ops[1].type == OP_IM8) ? ops[1].e.v : ops[1].reg, (ops[2].type == OP_IM8) ? ops[2].e.v : ops[2].reg, opcode2, 0);\n}\n\nstatic int asm_parse_vfp_status_regvar(int t)\n{\n    switch (t) {\n    case TOK_ASM_fpsid:\n        return 0;\n    case TOK_ASM_fpscr:\n        return 1;\n    case TOK_ASM_fpexc:\n        return 8;\n    default:\n        return -1;\n    }\n}\n\nstatic void asm_floating_point_status_register_opcode(TCCState* s1, int token)\n{\n    uint8_t coprocessor = CP_SINGLE_PRECISION_FLOAT;\n    uint8_t opcode;\n    int vfp_sys_reg = -1;\n    Operand arm_operand;\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_vmrseq:\n        opcode = 0xf;\n        if (tok == TOK_ASM_apsr_nzcv) {\n            arm_operand.type = OP_REG32;\n            arm_operand.reg = 15; // not PC\n            next(); // skip apsr_nzcv\n        } else {\n            parse_operand(s1, &arm_operand);\n            if (arm_operand.type == OP_REG32 && arm_operand.reg == 15) {\n                tcc_error(\"'%s' does not support 'pc' as operand\", get_tok_str(token, NULL));\n            }\n        }\n\n        skip(',');\n        vfp_sys_reg = asm_parse_vfp_status_regvar(tok);\n        next(); // skip vfp sys reg\n        if (arm_operand.type == OP_REG32 && arm_operand.reg == 15 && vfp_sys_reg != 1) {\n            tcc_error(\"'%s' only supports the variant 'vmrs apsr_nzcv, fpscr' here\", get_tok_str(token, NULL));\n        }\n        break;\n    case TOK_ASM_vmsreq:\n        opcode = 0xe;\n        vfp_sys_reg = asm_parse_vfp_status_regvar(tok);\n        next(); // skip vfp sys reg\n        skip(',');\n        parse_operand(s1, &arm_operand);\n        if (arm_operand.type == OP_REG32 && arm_operand.reg == 15) {\n            tcc_error(\"'%s' does not support 'pc' as operand\", get_tok_str(token, NULL));\n        }\n        break;\n    default:\n        expect(\"floating point status register instruction\");\n    }\n    if (vfp_sys_reg == -1) {\n        expect(\"VFP system register\");\n    }\n    if (arm_operand.type != OP_REG32) {\n        expect(\"ARM register\");\n    }\n    asm_emit_coprocessor_opcode(condition_code_of_token(token), coprocessor, opcode, arm_operand.reg, vfp_sys_reg, 0x10, 0, 0);\n}\n\n#endif\n\nstatic void asm_misc_single_data_transfer_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    int exclam = 0;\n    int closed_bracket = 0;\n    int op2_minus = 0;\n    uint32_t opcode = (1 << 7) | (1 << 4);\n\n    /* Note:\n       The argument syntax is exactly the same as in arm_single_data_transfer_opcode, except that there's no STREX argument form.\n       The main difference between this function and asm_misc_single_data_transfer_opcode is that the immediate values here must be smaller.\n       Also, the combination (P=0, W=1) is unpredictable here.\n       The immediate flag has moved to bit index 22--and its meaning has flipped.\n       The immediate value itself has been split into two parts: one at bits 11...8, one at bits 3...0\n       bit 26 (Load/Store instruction) is unset here.\n       bits 7 and 4 are set here. */\n\n    // Here: 0 0 0 P U I W L << 20\n    // [compare single data transfer: 0 1 I P U B W L << 20]\n\n    parse_operand(s1, &ops[0]);\n    if (ops[0].type == OP_REG32)\n        opcode |= ENCODE_RD(ops[0].reg);\n    else {\n        expect(\"(destination operand) register\");\n    }\n    if (tok != ',')\n        expect(\"at least two arguments\");\n    else\n        next(); // skip ','\n    skip('[');\n    parse_operand(s1, &ops[1]);\n    if (ops[1].type == OP_REG32)\n        opcode |= ENCODE_RN(ops[1].reg);\n    else {\n        expect(\"(first source operand) register\");\n    }\n    if (tok == ']') {\n        next();\n        closed_bracket = 1;\n        // exclam = 1; // implicit in hardware; don't do it in software\n    }\n    if (tok == ',') {\n        next(); // skip ','\n        if (tok == '-') {\n            op2_minus = 1;\n            next();\n        }\n        parse_operand(s1, &ops[2]);\n    } else {\n        // end of input expression in brackets--assume 0 offset\n        ops[2].type = OP_IM8;\n        ops[2].e.v = 0;\n        opcode |= 1 << 24; // add offset before transfer\n    }\n    if (!closed_bracket) {\n        skip(']');\n        opcode |= 1 << 24; // add offset before transfer\n        if (tok == '!') {\n            exclam = 1;\n            next(); // skip '!'\n        }\n    }\n\n    if (exclam) {\n        if ((opcode & (1 << 24)) == 0) {\n            tcc_error(\"result of '%s' would be unpredictable here\", get_tok_str(token, NULL));\n        }\n        opcode |= 1 << 21; // write offset back into register\n    }\n\n    if (ops[2].type == OP_IM32 || ops[2].type == OP_IM8 || ops[2].type == OP_IM8N) {\n        int v = ops[2].e.v;\n        if (op2_minus)\n            tcc_error(\"minus before '#' not supported for immediate values\");\n        if (v >= 0) {\n            opcode |= 1 << 23; // up\n            if (v >= 0x100)\n                tcc_error(\"offset out of range for '%s'\", get_tok_str(token, NULL));\n            else {\n                // bits 11...8: immediate hi nibble\n                // bits 3...0: immediate lo nibble\n                opcode |= (v & 0xF0) << 4;\n                opcode |= v & 0xF;\n            }\n        } else { // down\n            if (v <= -0x100)\n                tcc_error(\"offset out of range for '%s'\", get_tok_str(token, NULL));\n            else {\n                v = -v;\n                // bits 11...8: immediate hi nibble\n                // bits 3...0: immediate lo nibble\n                opcode |= (v & 0xF0) << 4;\n                opcode |= v & 0xF;\n            }\n        }\n        opcode |= 1 << 22; // not ENCODE_IMMEDIATE_FLAG;\n    } else if (ops[2].type == OP_REG32) {\n        if (!op2_minus)\n            opcode |= 1 << 23; // up\n        opcode |= ops[2].reg;\n    } else\n        expect(\"register\");\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_ldrsheq:\n        opcode |= 1 << 5; // halfword, not byte\n        /* fallthrough */\n    case TOK_ASM_ldrsbeq:\n        opcode |= 1 << 6; // sign extend\n        opcode |= 1 << 20; // L\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_ldrheq:\n        opcode |= 1 << 5; // halfword, not byte\n        opcode |= 1 << 20; // L\n        asm_emit_opcode(token, opcode);\n        break;\n    case TOK_ASM_strheq:\n        opcode |= 1 << 5; // halfword, not byte\n        asm_emit_opcode(token, opcode);\n        break;\n    }\n}\n\n/* Note: almost dupe of encbranch in arm-gen.c */\nstatic uint32_t encbranchoffset(int pos, int addr, int fail)\n{\n  addr-=pos+8;\n  addr/=4;\n  if(addr>=0x7fffff || addr<-0x800000) {\n    if(fail)\n      tcc_error(\"branch offset is too far\");\n    return 0;\n  }\n  return /*not 0x0A000000|*/(addr&0xffffff);\n}\n\nstatic void asm_branch_opcode(TCCState *s1, int token)\n{\n    int jmp_disp = 0;\n    Operand op;\n    ExprValue e;\n    ElfSym *esym;\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_beq:\n    case TOK_ASM_bleq:\n        asm_expr(s1, &e);\n        esym = elfsym(e.sym);\n        if (!esym || esym->st_shndx != cur_text_section->sh_num) {\n            tcc_error(\"invalid branch target\");\n        }\n        jmp_disp = encbranchoffset(ind, e.v + esym->st_value, 1);\n        break;\n    default:\n        parse_operand(s1, &op);\n        break;\n    }\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_beq:\n        asm_emit_opcode(token, (0xa << 24) | (jmp_disp & 0xffffff));\n        break;\n    case TOK_ASM_bleq:\n        asm_emit_opcode(token, (0xb << 24) | (jmp_disp & 0xffffff));\n        break;\n    case TOK_ASM_bxeq:\n        if (op.type != OP_REG32)\n            expect(\"register\");\n        else\n            asm_emit_opcode(token, (0x12fff1 << 4) | op.reg);\n        break;\n    case TOK_ASM_blxeq:\n        if (op.type != OP_REG32)\n            expect(\"register\");\n        else\n            asm_emit_opcode(token, (0x12fff3 << 4) | op.reg);\n        break;\n    default:\n        expect(\"branch instruction\");\n    }\n}\n\nST_FUNC void asm_opcode(TCCState *s1, int token)\n{\n    while (token == TOK_LINEFEED) {\n        next();\n        token = tok;\n    }\n    if (token == TOK_EOF)\n        return;\n    if (token < TOK_ASM_nopeq) { // no condition code\n        switch (token) {\n        case TOK_ASM_cdp2:\n            asm_coprocessor_opcode(s1, token);\n            return;\n        case TOK_ASM_ldc2:\n        case TOK_ASM_ldc2l:\n        case TOK_ASM_stc2:\n        case TOK_ASM_stc2l:\n            asm_coprocessor_data_transfer_opcode(s1, token);\n            return;\n        default:\n            expect(\"instruction\");\n        }\n    }\n\n    switch (ARM_INSTRUCTION_GROUP(token)) {\n    case TOK_ASM_pusheq:\n    case TOK_ASM_popeq:\n    case TOK_ASM_stmdaeq:\n    case TOK_ASM_ldmdaeq:\n    case TOK_ASM_stmeq:\n    case TOK_ASM_ldmeq:\n    case TOK_ASM_stmiaeq:\n    case TOK_ASM_ldmiaeq:\n    case TOK_ASM_stmdbeq:\n    case TOK_ASM_ldmdbeq:\n    case TOK_ASM_stmibeq:\n    case TOK_ASM_ldmibeq:\n        asm_block_data_transfer_opcode(s1, token);\n        return;\n    case TOK_ASM_nopeq:\n    case TOK_ASM_wfeeq:\n    case TOK_ASM_wfieq:\n        asm_nullary_opcode(token);\n        return;\n    case TOK_ASM_swieq:\n    case TOK_ASM_svceq:\n        asm_unary_opcode(s1, token);\n        return;\n    case TOK_ASM_beq:\n    case TOK_ASM_bleq:\n    case TOK_ASM_bxeq:\n    case TOK_ASM_blxeq:\n        asm_branch_opcode(s1, token);\n        return;\n    case TOK_ASM_clzeq:\n    case TOK_ASM_sxtbeq:\n    case TOK_ASM_sxtheq:\n    case TOK_ASM_uxtbeq:\n    case TOK_ASM_uxtheq:\n    case TOK_ASM_movteq:\n    case TOK_ASM_movweq:\n        asm_binary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_ldreq:\n    case TOK_ASM_ldrbeq:\n    case TOK_ASM_streq:\n    case TOK_ASM_strbeq:\n    case TOK_ASM_ldrexeq:\n    case TOK_ASM_ldrexbeq:\n    case TOK_ASM_strexeq:\n    case TOK_ASM_strexbeq:\n        asm_single_data_transfer_opcode(s1, token);\n        return;\n\n    case TOK_ASM_ldrheq:\n    case TOK_ASM_ldrsheq:\n    case TOK_ASM_ldrsbeq:\n    case TOK_ASM_strheq:\n       asm_misc_single_data_transfer_opcode(s1, token);\n       return;\n\n    case TOK_ASM_andeq:\n    case TOK_ASM_eoreq:\n    case TOK_ASM_subeq:\n    case TOK_ASM_rsbeq:\n    case TOK_ASM_addeq:\n    case TOK_ASM_adceq:\n    case TOK_ASM_sbceq:\n    case TOK_ASM_rsceq:\n    case TOK_ASM_tsteq:\n    case TOK_ASM_teqeq:\n    case TOK_ASM_cmpeq:\n    case TOK_ASM_cmneq:\n    case TOK_ASM_orreq:\n    case TOK_ASM_moveq:\n    case TOK_ASM_biceq:\n    case TOK_ASM_mvneq:\n    case TOK_ASM_andseq:\n    case TOK_ASM_eorseq:\n    case TOK_ASM_subseq:\n    case TOK_ASM_rsbseq:\n    case TOK_ASM_addseq:\n    case TOK_ASM_adcseq:\n    case TOK_ASM_sbcseq:\n    case TOK_ASM_rscseq:\n//  case TOK_ASM_tstseq:\n//  case TOK_ASM_teqseq:\n//  case TOK_ASM_cmpseq:\n//  case TOK_ASM_cmnseq:\n    case TOK_ASM_orrseq:\n    case TOK_ASM_movseq:\n    case TOK_ASM_bicseq:\n    case TOK_ASM_mvnseq:\n        asm_data_processing_opcode(s1, token);\n        return;\n\n    case TOK_ASM_lsleq:\n    case TOK_ASM_lslseq:\n    case TOK_ASM_lsreq:\n    case TOK_ASM_lsrseq:\n    case TOK_ASM_asreq:\n    case TOK_ASM_asrseq:\n    case TOK_ASM_roreq:\n    case TOK_ASM_rorseq:\n    case TOK_ASM_rrxseq:\n    case TOK_ASM_rrxeq:\n        asm_shift_opcode(s1, token);\n        return;\n\n    case TOK_ASM_muleq:\n    case TOK_ASM_mulseq:\n    case TOK_ASM_mlaeq:\n    case TOK_ASM_mlaseq:\n        asm_multiplication_opcode(s1, token);\n        return;\n\n    case TOK_ASM_smulleq:\n    case TOK_ASM_smullseq:\n    case TOK_ASM_umulleq:\n    case TOK_ASM_umullseq:\n    case TOK_ASM_smlaleq:\n    case TOK_ASM_smlalseq:\n    case TOK_ASM_umlaleq:\n    case TOK_ASM_umlalseq:\n        asm_long_multiplication_opcode(s1, token);\n        return;\n\n    case TOK_ASM_cdpeq:\n    case TOK_ASM_mcreq:\n    case TOK_ASM_mrceq:\n        asm_coprocessor_opcode(s1, token);\n        return;\n\n    case TOK_ASM_ldceq:\n    case TOK_ASM_ldcleq:\n    case TOK_ASM_stceq:\n    case TOK_ASM_stcleq:\n        asm_coprocessor_data_transfer_opcode(s1, token);\n        return;\n\n#if defined(TCC_ARM_VFP)\n    case TOK_ASM_vldreq:\n    case TOK_ASM_vstreq:\n        asm_floating_point_single_data_transfer_opcode(s1, token);\n        return;\n\n    case TOK_ASM_vmlaeq_f32:\n    case TOK_ASM_vmlseq_f32:\n    case TOK_ASM_vnmlseq_f32:\n    case TOK_ASM_vnmlaeq_f32:\n    case TOK_ASM_vmuleq_f32:\n    case TOK_ASM_vnmuleq_f32:\n    case TOK_ASM_vaddeq_f32:\n    case TOK_ASM_vsubeq_f32:\n    case TOK_ASM_vdiveq_f32:\n    case TOK_ASM_vnegeq_f32:\n    case TOK_ASM_vabseq_f32:\n    case TOK_ASM_vsqrteq_f32:\n    case TOK_ASM_vcmpeq_f32:\n    case TOK_ASM_vcmpeeq_f32:\n    case TOK_ASM_vmoveq_f32:\n    case TOK_ASM_vmlaeq_f64:\n    case TOK_ASM_vmlseq_f64:\n    case TOK_ASM_vnmlseq_f64:\n    case TOK_ASM_vnmlaeq_f64:\n    case TOK_ASM_vmuleq_f64:\n    case TOK_ASM_vnmuleq_f64:\n    case TOK_ASM_vaddeq_f64:\n    case TOK_ASM_vsubeq_f64:\n    case TOK_ASM_vdiveq_f64:\n    case TOK_ASM_vnegeq_f64:\n    case TOK_ASM_vabseq_f64:\n    case TOK_ASM_vsqrteq_f64:\n    case TOK_ASM_vcmpeq_f64:\n    case TOK_ASM_vcmpeeq_f64:\n    case TOK_ASM_vmoveq_f64:\n        asm_floating_point_data_processing_opcode(s1, token);\n        return;\n\n    case TOK_ASM_vcvtreq_s32_f32:\n    case TOK_ASM_vcvtreq_s32_f64:\n    case TOK_ASM_vcvteq_s32_f32:\n    case TOK_ASM_vcvteq_s32_f64:\n    case TOK_ASM_vcvtreq_u32_f32:\n    case TOK_ASM_vcvtreq_u32_f64:\n    case TOK_ASM_vcvteq_u32_f32:\n    case TOK_ASM_vcvteq_u32_f64:\n    case TOK_ASM_vcvteq_f64_s32:\n    case TOK_ASM_vcvteq_f32_s32:\n    case TOK_ASM_vcvteq_f64_u32:\n    case TOK_ASM_vcvteq_f32_u32:\n    case TOK_ASM_vcvteq_f64_f32:\n    case TOK_ASM_vcvteq_f32_f64:\n        asm_floating_point_vcvt_data_processing_opcode(s1, token);\n        return;\n\n    case TOK_ASM_vpusheq:\n    case TOK_ASM_vpopeq:\n    case TOK_ASM_vldmeq:\n    case TOK_ASM_vldmiaeq:\n    case TOK_ASM_vldmdbeq:\n    case TOK_ASM_vstmeq:\n    case TOK_ASM_vstmiaeq:\n    case TOK_ASM_vstmdbeq:\n        asm_floating_point_block_data_transfer_opcode(s1, token);\n        return;\n\n    case TOK_ASM_vmsreq:\n    case TOK_ASM_vmrseq:\n        asm_floating_point_status_register_opcode(s1, token);\n        return;\n#endif\n\n    default:\n        expect(\"known instruction\");\n    }\n}\n\nST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier)\n{\n    int r, reg, size, val;\n\n    r = sv->r;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        if (!(r & VT_LVAL) && modifier != 'c' && modifier != 'n' &&\n            modifier != 'P')\n            cstr_ccat(add_str, '#');\n        if (r & VT_SYM) {\n            const char *name = get_tok_str(sv->sym->v, NULL);\n            if (sv->sym->v >= SYM_FIRST_ANOM) {\n                /* In case of anonymous symbols (\"L.42\", used\n                   for static data labels) we can't find them\n                   in the C symbol table when later looking up\n                   this name.  So enter them now into the asm label\n                   list when we still know the symbol.  */\n                get_asm_sym(tok_alloc(name, strlen(name))->tok, sv->sym);\n            }\n            if (tcc_state->leading_underscore)\n                cstr_ccat(add_str, '_');\n            cstr_cat(add_str, name, -1);\n            if ((uint32_t) sv->c.i == 0)\n                goto no_offset;\n            cstr_ccat(add_str, '+');\n        }\n        val = sv->c.i;\n        if (modifier == 'n')\n            val = -val;\n        cstr_printf(add_str, \"%d\", (int) sv->c.i);\n      no_offset:;\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        cstr_printf(add_str, \"[fp,#%d]\", (int) sv->c.i);\n    } else if (r & VT_LVAL) {\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            tcc_internal_error(\"\");\n        cstr_printf(add_str, \"[%s]\",\n                 get_tok_str(TOK_ASM_r0 + reg, NULL));\n    } else {\n        /* register case */\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            tcc_internal_error(\"\");\n\n        /* choose register operand size */\n        if ((sv->type.t & VT_BTYPE) == VT_BYTE ||\n            (sv->type.t & VT_BTYPE) == VT_BOOL)\n            size = 1;\n        else if ((sv->type.t & VT_BTYPE) == VT_SHORT)\n            size = 2;\n        else\n            size = 4;\n\n        if (modifier == 'b') {\n            size = 1;\n        } else if (modifier == 'w') {\n            size = 2;\n        } else if (modifier == 'k') {\n            size = 4;\n        }\n\n        switch (size) {\n        default:\n            reg = TOK_ASM_r0 + reg;\n            break;\n        }\n        cstr_printf(add_str, \"%s\", get_tok_str(reg, NULL));\n    }\n}\n\n/* generate prolog and epilog code for asm statement */\nST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands,\n                          int nb_outputs, int is_output,\n                          uint8_t *clobber_regs,\n                          int out_reg)\n{\n    uint8_t regs_allocated[NB_ASM_REGS];\n    ASMOperand *op;\n    int i, reg;\n    uint32_t saved_regset = 0;\n\n    // TODO: Check non-E ABI.\n    // Note: Technically, r13 (sp) is also callee-saved--but that does not matter yet\n    static const uint8_t reg_saved[] = { 4, 5, 6, 7, 8, 9 /* Note: sometimes special reg \"sb\" */ , 10, 11 };\n\n    /* mark all used registers */\n    memcpy(regs_allocated, clobber_regs, sizeof(regs_allocated));\n    for(i = 0; i < nb_operands;i++) {\n        op = &operands[i];\n        if (op->reg >= 0)\n            regs_allocated[op->reg] = 1;\n    }\n    for(i = 0; i < sizeof(reg_saved)/sizeof(reg_saved[0]); i++) {\n        reg = reg_saved[i];\n        if (regs_allocated[reg])\n            saved_regset |= 1 << reg;\n    }\n\n    if (!is_output) { // prolog\n        /* generate reg save code */\n        if (saved_regset)\n            gen_le32(0xe92d0000 | saved_regset); // push {...}\n\n        /* generate load code */\n        for(i = 0; i < nb_operands; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL &&\n                    op->is_memory) {\n                    /* memory reference case (for both input and\n                       output cases) */\n                    SValue sv;\n                    sv = *op->vt;\n                    sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL | VT_LVAL;\n                    sv.type.t = VT_PTR;\n                    load(op->reg, &sv);\n                } else if (i >= nb_outputs || op->is_rw) { // not write-only\n                    /* load value in register */\n                    load(op->reg, op->vt);\n                    if (op->is_llong)\n                        tcc_error(\"long long not implemented\");\n                }\n            }\n        }\n    } else { // epilog\n        /* generate save code */\n        for(i = 0 ; i < nb_outputs; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    if (!op->is_memory) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL;\n                        sv.type.t = VT_PTR;\n                        load(out_reg, &sv);\n\n                        sv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | out_reg;\n                        store(op->reg, &sv);\n                    }\n                } else {\n                    store(op->reg, op->vt);\n                    if (op->is_llong)\n                        tcc_error(\"long long not implemented\");\n                }\n            }\n        }\n\n        /* generate reg restore code */\n        if (saved_regset)\n            gen_le32(0xe8bd0000 | saved_regset); // pop {...}\n    }\n}\n\n/* return the constraint priority (we allocate first the lowest\n   numbered constraints) */\nstatic inline int constraint_priority(const char *str)\n{\n    int priority, c, pr;\n\n    /* we take the lowest priority */\n    priority = 0;\n    for(;;) {\n        c = *str;\n        if (c == '\\0')\n            break;\n        str++;\n        switch(c) {\n        case 'l': // in ARM mode, that's  an alias for 'r' [ARM].\n        case 'r': // register [general]\n        case 'p': // valid memory address for load,store [general]\n            pr = 3;\n            break;\n        case 'M': // integer constant for shifts [ARM]\n        case 'I': // integer valid for data processing instruction immediate\n        case 'J': // integer in range -4095...4095\n\n        case 'i': // immediate integer operand, including symbolic constants [general]\n        case 'm': // memory operand [general]\n        case 'g': // general-purpose-register, memory, immediate integer [general]\n            pr = 4;\n            break;\n        default:\n            tcc_error(\"unknown constraint '%c'\", c);\n        }\n        if (pr > priority)\n            priority = pr;\n    }\n    return priority;\n}\n\nstatic const char *skip_constraint_modifiers(const char *p)\n{\n    /* Constraint modifier:\n        =   Operand is written to by this instruction\n        +   Operand is both read and written to by this instruction\n        %   Instruction is commutative for this operand and the following operand.\n\n       Per-alternative constraint modifier:\n        &   Operand is clobbered before the instruction is done using the input operands\n    */\n    while (*p == '=' || *p == '&' || *p == '+' || *p == '%')\n        p++;\n    return p;\n}\n\n#define REG_OUT_MASK 0x01\n#define REG_IN_MASK  0x02\n\n#define is_reg_allocated(reg) (regs_allocated[reg] & reg_mask)\n\nST_FUNC void asm_compute_constraints(ASMOperand *operands,\n                                    int nb_operands, int nb_outputs,\n                                    const uint8_t *clobber_regs,\n                                    int *pout_reg)\n{\n    /* overall format: modifier, then ,-seperated list of alternatives; all operands for a single instruction must have the same number of alternatives */\n    /* TODO: Simple constraints\n        whitespace  ignored\n        o  memory operand that is offsetable\n        V  memory but not offsetable\n        <  memory operand with autodecrement addressing is allowed.  Restrictions apply.\n        >  memory operand with autoincrement addressing is allowed.  Restrictions apply.\n        n  immediate integer operand with a known numeric value\n        E  immediate floating operand (const_double) is allowed, but only if target=host\n        F  immediate floating operand (const_double or const_vector) is allowed\n        s  immediate integer operand whose value is not an explicit integer\n        X  any operand whatsoever\n        0...9 (postfix); (can also be more than 1 digit number);  an operand that matches the specified operand number is allowed\n    */\n\n    /* TODO: ARM constraints:\n        k the stack pointer register\n        G the floating-point constant 0.0\n        Q memory reference where the exact address is in a single register (\"m\" is preferable for asm statements)\n        R an item in the constant pool\n        S symbol in the text segment of the current file\n[       Uv memory reference suitable for VFP load/store insns (reg+constant offset)]\n[       Uy memory reference suitable for iWMMXt load/store instructions]\n        Uq memory reference suitable for the ARMv4 ldrsb instruction\n    */\n    ASMOperand *op;\n    int sorted_op[MAX_ASM_OPERANDS];\n    int i, j, k, p1, p2, tmp, reg, c, reg_mask;\n    const char *str;\n    uint8_t regs_allocated[NB_ASM_REGS];\n\n    /* init fields */\n    for (i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        op->input_index = -1;\n        op->ref_index = -1;\n        op->reg = -1;\n        op->is_memory = 0;\n        op->is_rw = 0;\n    }\n    /* compute constraint priority and evaluate references to output\n       constraints if input constraints */\n    for (i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        str = op->constraint;\n        str = skip_constraint_modifiers(str);\n        if (isnum(*str) || *str == '[') {\n            /* this is a reference to another constraint */\n            k = find_constraint(operands, nb_operands, str, NULL);\n            if ((unsigned) k >= i || i < nb_outputs)\n                tcc_error(\"invalid reference in constraint %d ('%s')\",\n                          i, str);\n            op->ref_index = k;\n            if (operands[k].input_index >= 0)\n                tcc_error(\"cannot reference twice the same operand\");\n            operands[k].input_index = i;\n            op->priority = 5;\n        } else if ((op->vt->r & VT_VALMASK) == VT_LOCAL\n                   && op->vt->sym\n                   && (reg = op->vt->sym->r & VT_VALMASK) < VT_CONST) {\n            op->priority = 1;\n            op->reg = reg;\n        } else {\n            op->priority = constraint_priority(str);\n        }\n    }\n\n    /* sort operands according to their priority */\n    for (i = 0; i < nb_operands; i++)\n        sorted_op[i] = i;\n    for (i = 0; i < nb_operands - 1; i++) {\n        for (j = i + 1; j < nb_operands; j++) {\n            p1 = operands[sorted_op[i]].priority;\n            p2 = operands[sorted_op[j]].priority;\n            if (p2 < p1) {\n                tmp = sorted_op[i];\n                sorted_op[i] = sorted_op[j];\n                sorted_op[j] = tmp;\n            }\n        }\n    }\n\n    for (i = 0; i < NB_ASM_REGS; i++) {\n        if (clobber_regs[i])\n            regs_allocated[i] = REG_IN_MASK | REG_OUT_MASK;\n        else\n            regs_allocated[i] = 0;\n    }\n    /* sp cannot be used */\n    regs_allocated[13] = REG_IN_MASK | REG_OUT_MASK;\n    /* fp cannot be used yet */\n    regs_allocated[11] = REG_IN_MASK | REG_OUT_MASK;\n\n    /* allocate registers and generate corresponding asm moves */\n    for (i = 0; i < nb_operands; i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        str = op->constraint;\n        /* no need to allocate references */\n        if (op->ref_index >= 0)\n            continue;\n        /* select if register is used for output, input or both */\n        if (op->input_index >= 0) {\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n        } else if (j < nb_outputs) {\n            reg_mask = REG_OUT_MASK;\n        } else {\n            reg_mask = REG_IN_MASK;\n        }\n        if (op->reg >= 0) {\n            if (is_reg_allocated(op->reg))\n                tcc_error\n                    (\"asm regvar requests register that's taken already\");\n            reg = op->reg;\n        }\n      try_next:\n        c = *str++;\n        switch (c) {\n        case '=': // Operand is written-to\n            goto try_next;\n        case '+': // Operand is both READ and written-to\n            op->is_rw = 1;\n            /* FALL THRU */\n        case '&': // Operand is clobbered before the instruction is done using the input operands\n            if (j >= nb_outputs)\n                tcc_error(\"'%c' modifier can only be applied to outputs\",\n                          c);\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n            goto try_next;\n        case 'l': // In non-thumb mode, alias for 'r'--otherwise r0-r7 [ARM]\n        case 'r': // general-purpose register\n        case 'p': // loadable/storable address\n            /* any general register */\n            if ((reg = op->reg) >= 0)\n                goto reg_found;\n            else for (reg = 0; reg <= 8; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n          reg_found:\n            /* now we can reload in the register */\n            op->is_llong = 0;\n            op->reg = reg;\n            regs_allocated[reg] |= reg_mask;\n            break;\n        case 'I': // integer that is valid as an data processing instruction immediate (0...255, rotated by a multiple of two)\n        case 'J': // integer in the range -4095 to 4095 [ARM]\n        case 'K': // integer that satisfies constraint I when inverted (one's complement)\n        case 'L': // integer that satisfies constraint I when inverted (two's complement)\n        case 'i': // immediate integer operand, including symbolic constants\n            if (!((op->vt->r & (VT_VALMASK | VT_LVAL)) == VT_CONST))\n                goto try_next;\n            break;\n        case 'M': // integer in the range 0 to 32\n            if (!\n                ((op->vt->r & (VT_VALMASK | VT_LVAL | VT_SYM)) ==\n                 VT_CONST))\n                goto try_next;\n            break;\n        case 'm': // memory operand\n        case 'g':\n            /* nothing special to do because the operand is already in\n               memory, except if the pointer itself is stored in a\n               memory variable (VT_LLOCAL case) */\n            /* XXX: fix constant case */\n            /* if it is a reference to a memory zone, it must lie\n               in a register, so we reserve the register in the\n               input registers and a load will be generated\n               later */\n            if (j < nb_outputs || c == 'm') {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    /* any general register */\n                    for (reg = 0; reg <= 8; reg++) {\n                        if (!(regs_allocated[reg] & REG_IN_MASK))\n                            goto reg_found1;\n                    }\n                    goto try_next;\n                  reg_found1:\n                    /* now we can reload in the register */\n                    regs_allocated[reg] |= REG_IN_MASK;\n                    op->reg = reg;\n                    op->is_memory = 1;\n                }\n            }\n            break;\n        default:\n            tcc_error(\"asm constraint %d ('%s') could not be satisfied\",\n                      j, op->constraint);\n            break;\n        }\n        /* if a reference is present for that operand, we assign it too */\n        if (op->input_index >= 0) {\n            operands[op->input_index].reg = op->reg;\n            operands[op->input_index].is_llong = op->is_llong;\n        }\n    }\n\n    /* compute out_reg. It is used to store outputs registers to memory\n       locations references by pointers (VT_LLOCAL case) */\n    *pout_reg = -1;\n    for (i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        if (op->reg >= 0 &&\n            (op->vt->r & VT_VALMASK) == VT_LLOCAL && !op->is_memory) {\n            for (reg = 0; reg <= 8; reg++) {\n                if (!(regs_allocated[reg] & REG_OUT_MASK))\n                    goto reg_found2;\n            }\n            tcc_error(\"could not find free output register for reloading\");\n          reg_found2:\n            *pout_reg = reg;\n            break;\n        }\n    }\n\n    /* print sorted constraints */\n#ifdef ASM_DEBUG\n    for (i = 0; i < nb_operands; i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        printf(\"%%%d [%s]: \\\"%s\\\" r=0x%04x reg=%d\\n\",\n               j,\n               op->id ? get_tok_str(op->id, NULL) : \"\",\n               op->constraint, op->vt->r, op->reg);\n    }\n    if (*pout_reg >= 0)\n        printf(\"out_reg=%d\\n\", *pout_reg);\n#endif\n}\n\nST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str)\n{\n    int reg;\n    TokenSym *ts;\n\n    if (!strcmp(str, \"memory\") ||\n        !strcmp(str, \"cc\") ||\n        !strcmp(str, \"flags\"))\n        return;\n    ts = tok_alloc(str, strlen(str));\n    reg = asm_parse_regvar(ts->tok);\n    if (reg == -1) {\n        tcc_error(\"invalid clobber register '%s'\", str);\n    }\n    clobber_regs[reg] = 1;\n}\n\n/* If T refers to a register then return the register number and type.\n   Otherwise return -1.  */\nST_FUNC int asm_parse_regvar (int t)\n{\n    if (t >= TOK_ASM_r0 && t <= TOK_ASM_pc) { /* register name */\n        switch (t) {\n            case TOK_ASM_fp:\n                return TOK_ASM_r11 - TOK_ASM_r0;\n            case TOK_ASM_ip:\n                return TOK_ASM_r12 - TOK_ASM_r0;\n            case TOK_ASM_sp:\n                return TOK_ASM_r13 - TOK_ASM_r0;\n            case TOK_ASM_lr:\n                return TOK_ASM_r14 - TOK_ASM_r0;\n            case TOK_ASM_pc:\n                return TOK_ASM_r15 - TOK_ASM_r0;\n            default:\n                return t - TOK_ASM_r0;\n        }\n    } else\n        return -1;\n}\n\n/*************************************************************/\n#endif /* ndef TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "arm-gen.c",
          "type": "blob",
          "size": 59.947265625,
          "content": "/*\n *  ARMv4 code generator for TCC\n *\n *  Copyright (c) 2003 Daniel Glöckner\n *  Copyright (c) 2012 Thomas Preud'homme\n *\n *  Based on i386-gen.c by Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n#if defined(TCC_ARM_EABI) && !defined(TCC_ARM_VFP)\n#error \"Currently TinyCC only supports float computation with VFP instructions\"\n#endif\n\n/* number of available registers */\n#ifdef TCC_ARM_VFP\n#define NB_REGS            13\n#else\n#define NB_REGS             9\n#endif\n\n#ifndef CONFIG_TCC_CPUVER\n# define CONFIG_TCC_CPUVER 5\n#endif\n\n/* a register can belong to several classes. The classes must be\n   sorted from more general to more precise (see gv2() code which does\n   assumptions on it). */\n#define RC_INT     0x0001 /* generic integer register */\n#define RC_FLOAT   0x0002 /* generic float register */\n#define RC_R0      0x0004\n#define RC_R1      0x0008\n#define RC_R2      0x0010\n#define RC_R3      0x0020\n#define RC_R12     0x0040\n#define RC_F0      0x0080\n#define RC_F1      0x0100\n#define RC_F2      0x0200\n#define RC_F3      0x0400\n#ifdef TCC_ARM_VFP\n#define RC_F4      0x0800\n#define RC_F5      0x1000\n#define RC_F6      0x2000\n#define RC_F7      0x4000\n#endif\n#define RC_IRET    RC_R0  /* function return: integer register */\n#define RC_IRE2    RC_R1  /* function return: second integer register */\n#define RC_FRET    RC_F0  /* function return: float register */\n\n/* pretty names for the registers */\nenum {\n    TREG_R0 = 0,\n    TREG_R1,\n    TREG_R2,\n    TREG_R3,\n    TREG_R12,\n    TREG_F0,\n    TREG_F1,\n    TREG_F2,\n    TREG_F3,\n#ifdef TCC_ARM_VFP\n    TREG_F4,\n    TREG_F5,\n    TREG_F6,\n    TREG_F7,\n#endif\n    TREG_SP = 13,\n    TREG_LR,\n};\n\n#ifdef TCC_ARM_VFP\n#define T2CPR(t) (((t) & VT_BTYPE) != VT_FLOAT ? 0x100 : 0)\n#endif\n\n/* return registers for function */\n#define REG_IRET TREG_R0 /* single word int return register */\n#define REG_IRE2 TREG_R1 /* second word return register (for long long) */\n#define REG_FRET TREG_F0 /* float return register */\n\n#ifdef TCC_ARM_EABI\n#define TOK___divdi3 TOK___aeabi_ldivmod\n#define TOK___moddi3 TOK___aeabi_ldivmod\n#define TOK___udivdi3 TOK___aeabi_uldivmod\n#define TOK___umoddi3 TOK___aeabi_uldivmod\n#endif\n\n/* defined if function parameters must be evaluated in reverse order */\n#define INVERT_FUNC_PARAMS\n\n/* defined if structures are passed as pointers. Otherwise structures\n   are directly pushed on stack. */\n/* #define FUNC_STRUCT_PARAM_AS_PTR */\n\n/* pointer size, in bytes */\n#define PTR_SIZE 4\n\n/* long double size and alignment, in bytes */\n#ifdef TCC_ARM_VFP\n#define LDOUBLE_SIZE  8\n#endif\n\n#ifndef LDOUBLE_SIZE\n#define LDOUBLE_SIZE  8\n#endif\n\n#ifdef TCC_ARM_EABI\n#define LDOUBLE_ALIGN 8\n#else\n#define LDOUBLE_ALIGN 4\n#endif\n\n/* maximum alignment (for aligned attribute support) */\n#define MAX_ALIGN     8\n\n#define CHAR_IS_UNSIGNED\n\n#ifdef TCC_ARM_HARDFLOAT\n# define ARM_FLOAT_ABI ARM_HARD_FLOAT\n#else\n# define ARM_FLOAT_ABI ARM_SOFTFP_FLOAT\n#endif\n\n/******************************************************/\n#else /* ! TARGET_DEFS_ONLY */\n/******************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n\nST_DATA const char * const target_machine_defs =\n    \"__arm__\\0\"\n    \"__arm\\0\"\n    \"arm\\0\"\n    \"__arm_elf__\\0\"\n    \"__arm_elf\\0\"\n    \"arm_elf\\0\"\n    \"__ARM_ARCH_4__\\0\"\n    \"__ARMEL__\\0\"\n    \"__APCS_32__\\0\"\n#if defined TCC_ARM_EABI\n    \"__ARM_EABI__\\0\"\n#endif\n    ;\n\nenum float_abi float_abi;\n\nST_DATA const int reg_classes[NB_REGS] = {\n    /* r0 */ RC_INT | RC_R0,\n    /* r1 */ RC_INT | RC_R1,\n    /* r2 */ RC_INT | RC_R2,\n    /* r3 */ RC_INT | RC_R3,\n    /* r12 */ RC_INT | RC_R12,\n    /* f0 */ RC_FLOAT | RC_F0,\n    /* f1 */ RC_FLOAT | RC_F1,\n    /* f2 */ RC_FLOAT | RC_F2,\n    /* f3 */ RC_FLOAT | RC_F3,\n#ifdef TCC_ARM_VFP\n /* d4/s8 */ RC_FLOAT | RC_F4,\n/* d5/s10 */ RC_FLOAT | RC_F5,\n/* d6/s12 */ RC_FLOAT | RC_F6,\n/* d7/s14 */ RC_FLOAT | RC_F7,\n#endif\n};\n\nstatic int func_sub_sp_offset, last_itod_magic;\nstatic int leaffunc;\n\n#if defined(CONFIG_TCC_BCHECK)\nstatic addr_t func_bound_offset;\nstatic unsigned long func_bound_ind;\nST_DATA int func_bound_add_epilog;\n#endif\n\n#if defined(TCC_ARM_EABI) && defined(TCC_ARM_VFP)\nstatic CType float_type, double_type, func_float_type, func_double_type;\nST_FUNC void arm_init(struct TCCState *s)\n{\n    float_type.t = VT_FLOAT;\n    double_type.t = VT_DOUBLE;\n    func_float_type.t = VT_FUNC;\n    func_float_type.ref = sym_push(SYM_FIELD, &float_type, FUNC_CDECL, FUNC_OLD);\n    func_double_type.t = VT_FUNC;\n    func_double_type.ref = sym_push(SYM_FIELD, &double_type, FUNC_CDECL, FUNC_OLD);\n\n    float_abi = s->float_abi;\n#ifndef TCC_ARM_HARDFLOAT\n// XXX: Works on OpenBSD\n// # warning \"soft float ABI currently not supported: default to softfp\"\n#endif\n}\n#else\n#define func_float_type func_old_type\n#define func_double_type func_old_type\n#define func_ldouble_type func_old_type\nST_FUNC void arm_init(struct TCCState *s)\n{\n#if 0\n#if !defined (TCC_ARM_VFP)\n    tcc_warning(\"Support for FPA is deprecated and will be removed in next\"\n                \" release\");\n#endif\n#if !defined (TCC_ARM_EABI)\n    tcc_warning(\"Support for OABI is deprecated and will be removed in next\"\n                \" release\");\n#endif\n#endif\n}\n#endif\n\n#define CHECK_R(r) ((r) >= TREG_R0 && (r) <= TREG_LR)\n\nstatic int two2mask(int a,int b) {\n  if (!CHECK_R(a) || !CHECK_R(b))\n    tcc_error(\"compiler error! registers %i,%i is not valid\",a,b);\n  return (reg_classes[a]|reg_classes[b])&~(RC_INT|RC_FLOAT);\n}\n\nstatic int regmask(int r) {\n  if (!CHECK_R(r))\n    tcc_error(\"compiler error! register %i is not valid\",r);\n  return reg_classes[r]&~(RC_INT|RC_FLOAT);\n}\n\n/******************************************************/\n\n#if defined(TCC_ARM_EABI) && !defined(CONFIG_TCC_ELFINTERP)\nconst char *default_elfinterp(struct TCCState *s)\n{\n    if (s->float_abi == ARM_HARD_FLOAT)\n        return \"/lib/ld-linux-armhf.so.3\";\n    else\n        return \"/lib/ld-linux.so.3\";\n}\n#endif\n\nvoid o(uint32_t i)\n{\n  /* this is a good place to start adding big-endian support*/\n  int ind1;\n  if (nocode_wanted)\n    return;\n  ind1 = ind + 4;\n  if (!cur_text_section)\n    tcc_error(\"compiler error! This happens f.ex. if the compiler\\n\"\n         \"can't evaluate constant expressions outside of a function.\");\n  if (ind1 > cur_text_section->data_allocated)\n    section_realloc(cur_text_section, ind1);\n  cur_text_section->data[ind++] = i&255;\n  i>>=8;\n  cur_text_section->data[ind++] = i&255;\n  i>>=8;\n  cur_text_section->data[ind++] = i&255;\n  i>>=8;\n  cur_text_section->data[ind++] = i;\n}\n\nstatic uint32_t stuff_const(uint32_t op, uint32_t c)\n{\n  int try_neg=0;\n  uint32_t nc = 0, negop = 0;\n\n  switch(op&0x1F00000)\n  {\n    case 0x800000: //add\n    case 0x400000: //sub\n      try_neg=1;\n      negop=op^0xC00000;\n      nc=-c;\n      break;\n    case 0x1A00000: //mov\n    case 0x1E00000: //mvn\n      try_neg=1;\n      negop=op^0x400000;\n      nc=~c;\n      break;\n    case 0x200000: //xor\n      if(c==~0)\n\treturn (op&0xF010F000)|((op>>16)&0xF)|0x1E00000;\n      break;\n    case 0x0: //and\n      if(c==~0)\n\treturn (op&0xF010F000)|((op>>16)&0xF)|0x1A00000;\n    case 0x1C00000: //bic\n      try_neg=1;\n      negop=op^0x1C00000;\n      nc=~c;\n      break;\n    case 0x1800000: //orr\n      if(c==~0)\n\treturn (op&0xFFF0FFFF)|0x1E00000;\n      break;\n  }\n  do {\n    uint32_t m;\n    int i;\n    if(c<256) /* catch undefined <<32 */\n      return op|c;\n    for(i=2;i<32;i+=2) {\n      m=(0xff>>i)|(0xff<<(32-i));\n      if(!(c&~m))\n\treturn op|(i<<7)|(c<<i)|(c>>(32-i));\n    }\n    op=negop;\n    c=nc;\n  } while(try_neg--);\n  return 0;\n}\n\n\n//only add,sub\nvoid stuff_const_harder(uint32_t op, uint32_t v) {\n  uint32_t x;\n  x=stuff_const(op,v);\n  if(x)\n    o(x);\n  else {\n    uint32_t a[16], nv, no, o2, n2;\n    int i,j,k;\n    a[0]=0xff;\n    o2=(op&0xfff0ffff)|((op&0xf000)<<4);;\n    for(i=1;i<16;i++)\n      a[i]=(a[i-1]>>2)|(a[i-1]<<30);\n    for(i=0;i<12;i++)\n      for(j=i<4?i+12:15;j>=i+4;j--)\n\tif((v&(a[i]|a[j]))==v) {\n\t  o(stuff_const(op,v&a[i]));\n\t  o(stuff_const(o2,v&a[j]));\n\t  return;\n\t}\n    no=op^0xC00000;\n    n2=o2^0xC00000;\n    nv=-v;\n    for(i=0;i<12;i++)\n      for(j=i<4?i+12:15;j>=i+4;j--)\n\tif((nv&(a[i]|a[j]))==nv) {\n\t  o(stuff_const(no,nv&a[i]));\n\t  o(stuff_const(n2,nv&a[j]));\n\t  return;\n\t}\n    for(i=0;i<8;i++)\n      for(j=i+4;j<12;j++)\n\tfor(k=i<4?i+12:15;k>=j+4;k--)\n\t  if((v&(a[i]|a[j]|a[k]))==v) {\n\t    o(stuff_const(op,v&a[i]));\n\t    o(stuff_const(o2,v&a[j]));\n\t    o(stuff_const(o2,v&a[k]));\n\t    return;\n\t  }\n    no=op^0xC00000;\n    nv=-v;\n    for(i=0;i<8;i++)\n      for(j=i+4;j<12;j++)\n\tfor(k=i<4?i+12:15;k>=j+4;k--)\n\t  if((nv&(a[i]|a[j]|a[k]))==nv) {\n\t    o(stuff_const(no,nv&a[i]));\n\t    o(stuff_const(n2,nv&a[j]));\n\t    o(stuff_const(n2,nv&a[k]));\n\t    return;\n\t  }\n    o(stuff_const(op,v&a[0]));\n    o(stuff_const(o2,v&a[4]));\n    o(stuff_const(o2,v&a[8]));\n    o(stuff_const(o2,v&a[12]));\n  }\n}\n\nuint32_t encbranch(int pos, int addr, int fail)\n{\n  addr-=pos+8;\n  addr/=4;\n  if(addr>=0x1000000 || addr<-0x1000000) {\n    if(fail)\n      tcc_error(\"FIXME: function bigger than 32MB\");\n    return 0;\n  }\n  return 0x0A000000|(addr&0xffffff);\n}\n\nint decbranch(int pos)\n{\n  int x;\n  x=*(uint32_t *)(cur_text_section->data + pos);\n  x&=0x00ffffff;\n  if(x&0x800000)\n    x-=0x1000000;\n  return x*4+pos+8;\n}\n\n/* output a symbol and patch all calls to it */\nvoid gsym_addr(int t, int a)\n{\n  uint32_t *x;\n  int lt;\n  while(t) {\n    x=(uint32_t *)(cur_text_section->data + t);\n    t=decbranch(lt=t);\n    if(a==lt+4)\n      *x=0xE1A00000; // nop\n    else {\n      *x &= 0xff000000;\n      *x |= encbranch(lt,a,1);\n    }\n  }\n}\n\n#ifdef TCC_ARM_VFP\nstatic uint32_t vfpr(int r)\n{\n  if(r<TREG_F0 || r>TREG_F7)\n    tcc_error(\"compiler error! register %i is no vfp register\",r);\n  return r - TREG_F0;\n}\n#else\nstatic uint32_t fpr(int r)\n{\n  if(r<TREG_F0 || r>TREG_F3)\n    tcc_error(\"compiler error! register %i is no fpa register\",r);\n  return r - TREG_F0;\n}\n#endif\n\nstatic uint32_t intr(int r)\n{\n  if(r == TREG_R12)\n    return 12;\n  if(r >= TREG_R0 && r <= TREG_R3)\n    return r - TREG_R0;\n  if (!(r >= TREG_SP && r <= TREG_LR))\n    tcc_error(\"compiler error! register %i is no int register\",r);\n  return r + (13 - TREG_SP);\n}\n\nstatic void calcaddr(uint32_t *base, int *off, int *sgn, int maxoff, unsigned shift)\n{\n  if(*off>maxoff || *off&((1<<shift)-1)) {\n    uint32_t x, y;\n    x=0xE280E000;\n    if(*sgn)\n      x=0xE240E000;\n    x|=(*base)<<16;\n    *base=14; // lr\n    y=stuff_const(x,*off&~maxoff);\n    if(y) {\n      o(y);\n      *off&=maxoff;\n      return;\n    }\n    y=stuff_const(x,(*off+maxoff)&~maxoff);\n    if(y) {\n      o(y);\n      *sgn=!*sgn;\n      *off=((*off+maxoff)&~maxoff)-*off;\n      return;\n    }\n    stuff_const_harder(x,*off&~maxoff);\n    *off&=maxoff;\n  }\n}\n\nstatic uint32_t mapcc(int cc)\n{\n  switch(cc)\n  {\n    case TOK_ULT:\n      return 0x30000000; /* CC/LO */\n    case TOK_UGE:\n      return 0x20000000; /* CS/HS */\n    case TOK_EQ:\n      return 0x00000000; /* EQ */\n    case TOK_NE:\n      return 0x10000000; /* NE */\n    case TOK_ULE:\n      return 0x90000000; /* LS */\n    case TOK_UGT:\n      return 0x80000000; /* HI */\n    case TOK_Nset:\n      return 0x40000000; /* MI */\n    case TOK_Nclear:\n      return 0x50000000; /* PL */\n    case TOK_LT:\n      return 0xB0000000; /* LT */\n    case TOK_GE:\n      return 0xA0000000; /* GE */\n    case TOK_LE:\n      return 0xD0000000; /* LE */\n    case TOK_GT:\n      return 0xC0000000; /* GT */\n  }\n  tcc_error(\"unexpected condition code\");\n  return 0xE0000000; /* AL */\n}\n\nstatic int negcc(int cc)\n{\n  switch(cc)\n  {\n    case TOK_ULT:\n      return TOK_UGE;\n    case TOK_UGE:\n      return TOK_ULT;\n    case TOK_EQ:\n      return TOK_NE;\n    case TOK_NE:\n      return TOK_EQ;\n    case TOK_ULE:\n      return TOK_UGT;\n    case TOK_UGT:\n      return TOK_ULE;\n    case TOK_Nset:\n      return TOK_Nclear;\n    case TOK_Nclear:\n      return TOK_Nset;\n    case TOK_LT:\n      return TOK_GE;\n    case TOK_GE:\n      return TOK_LT;\n    case TOK_LE:\n      return TOK_GT;\n    case TOK_GT:\n      return TOK_LE;\n  }\n  tcc_error(\"unexpected condition code\");\n  return TOK_NE;\n}\n\n/* Load value into register r.\n   Use relative/got addressing to avoid setting DT_TEXTREL */\nstatic void load_value(SValue *sv, int r)\n{\n    o(0xE59F0000|(intr(r)<<12)); /* ldr r, [pc] */\n    o(0xEA000000); /* b $+4 */\n#ifndef CONFIG_TCC_PIC\n    if(sv->r & VT_SYM)\n        greloc(cur_text_section, sv->sym, ind, R_ARM_ABS32);\n    o(sv->c.i);\n#else\n    if(sv->r & VT_SYM) {\n\tif (sv->sym->type.t & VT_STATIC) {\n            greloc(cur_text_section, sv->sym, ind, R_ARM_REL32);\n            o(sv->c.i - 12);\n            o(0xe080000f | (intr(r)<<12) | (intr(r)<<16));  // add rx,rx,pc\n        }\n        else {\n            greloc(cur_text_section, sv->sym, ind, R_ARM_GOT_PREL);\n            o(-12);\n            o(0xe080000f | (intr(r)<<12) | (intr(r)<<16));  // add rx,rx,pc\n            o(0xe5900000 | (intr(r)<<12) | (intr(r)<<16));  // ldr rx,[rx]\n            if (sv->c.i)\n              stuff_const_harder(0xe2800000 | (intr(r)<<12) | (intr(r)<<16),\n                                 sv->c.i);\n        }\n    }\n    else\n        o(sv->c.i);\n#endif\n}\n\n/* load 'r' from value 'sv' */\nvoid load(int r, SValue *sv)\n{\n  int v, ft, fc, fr, sign;\n  uint32_t op;\n  SValue v1;\n\n  fr = sv->r;\n  ft = sv->type.t;\n  fc = sv->c.i;\n\n  if(fc>=0)\n    sign=0;\n  else {\n    sign=1;\n    fc=-fc;\n  }\n\n  v = fr & VT_VALMASK;\n  if (fr & VT_LVAL) {\n    uint32_t base = 0xB; // fp\n    if(v == VT_LLOCAL) {\n      v1.type.t = VT_PTR;\n      v1.r = VT_LOCAL | VT_LVAL;\n      v1.c.i = sv->c.i;\n      load(TREG_LR, &v1);\n      base = 14; /* lr */\n      fc=sign=0;\n      v=VT_LOCAL;\n    } else if(v == VT_CONST) {\n      v1.type.t = VT_PTR;\n      v1.r = fr&~VT_LVAL;\n      v1.c.i = sv->c.i;\n      v1.sym=sv->sym;\n      load(TREG_LR, &v1);\n      base = 14; /* lr */\n      fc=sign=0;\n      v=VT_LOCAL;\n    } else if(v < VT_CONST) {\n      base=intr(v);\n      fc=sign=0;\n      v=VT_LOCAL;\n    }\n    if(v == VT_LOCAL) {\n      if(is_float(ft)) {\n\tcalcaddr(&base,&fc,&sign,1020,2);\n#ifdef TCC_ARM_VFP\n        op=0xED100A00; /* flds */\n        if(!sign)\n          op|=0x800000;\n        if ((ft & VT_BTYPE) != VT_FLOAT)\n          op|=0x100;   /* flds -> fldd */\n        o(op|(vfpr(r)<<12)|(fc>>2)|(base<<16));\n#else\n\top=0xED100100;\n\tif(!sign)\n\t  op|=0x800000;\n#if LDOUBLE_SIZE == 8\n\tif ((ft & VT_BTYPE) != VT_FLOAT)\n\t  op|=0x8000;\n#else\n\tif ((ft & VT_BTYPE) == VT_DOUBLE)\n\t  op|=0x8000;\n\telse if ((ft & VT_BTYPE) == VT_LDOUBLE)\n\t  op|=0x400000;\n#endif\n\to(op|(fpr(r)<<12)|(fc>>2)|(base<<16));\n#endif\n      } else if((ft & (VT_BTYPE|VT_UNSIGNED)) == VT_BYTE\n                || (ft & VT_BTYPE) == VT_SHORT) {\n\tcalcaddr(&base,&fc,&sign,255,0);\n\top=0xE1500090;\n\tif ((ft & VT_BTYPE) == VT_SHORT)\n\t  op|=0x20;\n\tif ((ft & VT_UNSIGNED) == 0)\n\t  op|=0x40;\n\tif(!sign)\n\t  op|=0x800000;\n\to(op|(intr(r)<<12)|(base<<16)|((fc&0xf0)<<4)|(fc&0xf));\n      } else {\n\tcalcaddr(&base,&fc,&sign,4095,0);\n\top=0xE5100000;\n\tif(!sign)\n\t  op|=0x800000;\n        if ((ft & VT_BTYPE) == VT_BYTE || (ft & VT_BTYPE) == VT_BOOL)\n          op|=0x400000;\n        o(op|(intr(r)<<12)|fc|(base<<16));\n      }\n      return;\n    }\n  } else {\n    if (v == VT_CONST) {\n      op=stuff_const(0xE3A00000|(intr(r)<<12),sv->c.i);\n      if (fr & VT_SYM || !op)\n\tload_value(sv, r);\n      else\n        o(op);\n      return;\n    } else if (v == VT_LOCAL) {\n      op=stuff_const(0xE28B0000|(intr(r)<<12),sv->c.i);\n      if (fr & VT_SYM || !op) {\n\tload_value(sv, r);\n\to(0xE08B0000|(intr(r)<<12)|intr(r));\n      } else\n\to(op);\n      return;\n    } else if(v == VT_CMP) {\n      o(mapcc(sv->c.i)|0x3A00001|(intr(r)<<12));\n      o(mapcc(negcc(sv->c.i))|0x3A00000|(intr(r)<<12));\n      return;\n    } else if (v == VT_JMP || v == VT_JMPI) {\n      int t;\n      t = v & 1;\n      o(0xE3A00000|(intr(r)<<12)|t);\n      o(0xEA000000);\n      gsym(sv->c.i);\n      o(0xE3A00000|(intr(r)<<12)|(t^1));\n      return;\n    } else if (v < VT_CONST) {\n      if(is_float(ft))\n#ifdef TCC_ARM_VFP\n        o(0xEEB00A40|(vfpr(r)<<12)|vfpr(v)|T2CPR(ft)); /* fcpyX */\n#else\n\to(0xEE008180|(fpr(r)<<12)|fpr(v));\n#endif\n      else\n\to(0xE1A00000|(intr(r)<<12)|intr(v));\n      return;\n    }\n  }\n  tcc_error(\"load unimplemented!\");\n}\n\n/* store register 'r' in lvalue 'v' */\nvoid store(int r, SValue *sv)\n{\n  SValue v1;\n  int v, ft, fc, fr, sign;\n  uint32_t op;\n\n  fr = sv->r;\n  ft = sv->type.t;\n  fc = sv->c.i;\n\n  if(fc>=0)\n    sign=0;\n  else {\n    sign=1;\n    fc=-fc;\n  }\n\n  v = fr & VT_VALMASK;\n  if (fr & VT_LVAL || fr == VT_LOCAL) {\n    uint32_t base = 0xb; /* fp */\n    if(v < VT_CONST) {\n      base=intr(v);\n      v=VT_LOCAL;\n      fc=sign=0;\n    } else if(v == VT_CONST) {\n      v1.type.t = ft;\n      v1.r = fr&~VT_LVAL;\n      v1.c.i = sv->c.i;\n      v1.sym=sv->sym;\n      load(TREG_LR, &v1);\n      base = 14; /* lr */\n      fc=sign=0;\n      v=VT_LOCAL;\n    }\n    if(v == VT_LOCAL) {\n       if(is_float(ft)) {\n\tcalcaddr(&base,&fc,&sign,1020,2);\n#ifdef TCC_ARM_VFP\n        op=0xED000A00; /* fsts */\n        if(!sign)\n          op|=0x800000;\n        if ((ft & VT_BTYPE) != VT_FLOAT)\n          op|=0x100;   /* fsts -> fstd */\n        o(op|(vfpr(r)<<12)|(fc>>2)|(base<<16));\n#else\n\top=0xED000100;\n\tif(!sign)\n\t  op|=0x800000;\n#if LDOUBLE_SIZE == 8\n\tif ((ft & VT_BTYPE) != VT_FLOAT)\n\t  op|=0x8000;\n#else\n\tif ((ft & VT_BTYPE) == VT_DOUBLE)\n\t  op|=0x8000;\n\tif ((ft & VT_BTYPE) == VT_LDOUBLE)\n\t  op|=0x400000;\n#endif\n\to(op|(fpr(r)<<12)|(fc>>2)|(base<<16));\n#endif\n\treturn;\n      } else if((ft & VT_BTYPE) == VT_SHORT) {\n\tcalcaddr(&base,&fc,&sign,255,0);\n\top=0xE14000B0;\n\tif(!sign)\n\t  op|=0x800000;\n\to(op|(intr(r)<<12)|(base<<16)|((fc&0xf0)<<4)|(fc&0xf));\n      } else {\n\tcalcaddr(&base,&fc,&sign,4095,0);\n\top=0xE5000000;\n\tif(!sign)\n\t  op|=0x800000;\n        if ((ft & VT_BTYPE) == VT_BYTE || (ft & VT_BTYPE) == VT_BOOL)\n          op|=0x400000;\n        o(op|(intr(r)<<12)|fc|(base<<16));\n      }\n      return;\n    }\n  }\n  tcc_error(\"store unimplemented\");\n}\n\nstatic void gadd_sp(int val)\n{\n  stuff_const_harder(0xE28DD000,val);\n}\n\n/* 'is_jmp' is '1' if it is a jump */\nstatic void gcall_or_jmp(int is_jmp)\n{\n  int r;\n  uint32_t x;\n  if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n    /* constant case */\n    if(vtop->r & VT_SYM){\n\tx=encbranch(ind,ind+vtop->c.i,0);\n\tif(x) {\n\t    /* relocation case */\n\t    greloc(cur_text_section, vtop->sym, ind, R_ARM_PC24);\n\t    o(x|(is_jmp?0xE0000000:0xE1000000));\n\t} else {\n\t    r = TREG_LR;\n\t    load_value(vtop, r);\n\t    if(is_jmp)\n\t        o(0xE1A0F000 | intr(r)); // mov pc, r\n\t    else\n\t\to(0xe12fff30 | intr(r)); // blx r\n\t}\n     }else{\n\tif(!is_jmp)\n\t    o(0xE28FE004); // add lr,pc,#4\n\to(0xE51FF004);   // ldr pc,[pc,#-4]\n\to(vtop->c.i);\n     }\n  } else {\n    /* otherwise, indirect call */\n#ifdef CONFIG_TCC_BCHECK\n    vtop->r &= ~VT_MUSTBOUND;\n#endif\n    r = gv(RC_INT);\n    if(!is_jmp)\n      o(0xE1A0E00F);       // mov lr,pc\n    o(0xE1A0F000|intr(r)); // mov pc,r\n  }\n}\n\n#if defined(CONFIG_TCC_BCHECK)\n\nstatic void gen_bounds_call(int v)\n{\n    Sym *sym = external_helper_sym(v);\n\n    greloc(cur_text_section, sym, ind, R_ARM_PC24);\n    o(0xebfffffe);\n}\n\nstatic void gen_bounds_prolog(void)\n{\n    /* leave some room for bound checking code */\n    func_bound_offset = lbounds_section->data_offset;\n    func_bound_ind = ind;\n    func_bound_add_epilog = 0;\n    o(0xe1a00000);  /* ld r0,lbounds_section->data_offset */\n    o(0xe1a00000);\n    o(0xe1a00000);\n    o(0xe1a00000);\n    o(0xe1a00000);  /* call __bound_local_new */\n}\n\nstatic void gen_bounds_epilog(void)\n{\n    addr_t saved_ind;\n    addr_t *bounds_ptr;\n    Sym *sym_data;\n    int offset_modified = func_bound_offset != lbounds_section->data_offset;\n\n    if (!offset_modified && !func_bound_add_epilog)\n        return;\n\n    /* add end of table info */\n    bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));\n    *bounds_ptr = 0;\n\n    sym_data = get_sym_ref(&char_pointer_type, lbounds_section,\n                           func_bound_offset, PTR_SIZE);\n\n    /* generate bound local allocation */\n    if (offset_modified) {\n        saved_ind = ind;\n        ind = func_bound_ind;\n        o(0xe59f0000);  /* ldr r0, [pc] */\n        o(0xea000000);  /* b $+4 */\n        greloc(cur_text_section, sym_data, ind, R_ARM_REL32);\n        o(-12);  /* lbounds_section->data_offset */\n\to(0xe080000f);  /* add r0,r0,pc */\n        gen_bounds_call(TOK___bound_local_new);\n        ind = saved_ind;\n    }\n\n    /* generate bound check local freeing */\n    o(0xe92d0003);  /* push {r0,r1} */\n    o(0xed2d0b04);  /* vpush {d0,d1} */\n    o(0xe59f0000);  /* ldr r0, [pc] */\n    o(0xea000000);  /* b $+4 */\n    greloc(cur_text_section, sym_data, ind, R_ARM_REL32);\n    o(-12);  /* lbounds_section->data_offset */\n    o(0xe080000f);  /* add r0,r0,pc */\n    gen_bounds_call(TOK___bound_local_delete);\n    o(0xecbd0b04); /* vpop {d0,d1} */\n    o(0xe8bd0003); /* pop {r0,r1} */\n}\n#endif\n\nstatic int unalias_ldbl(int btype)\n{\n#if LDOUBLE_SIZE == 8\n    if (btype == VT_LDOUBLE)\n      btype = VT_DOUBLE;\n#endif\n    return btype;\n}\n\n/* Return whether a structure is an homogeneous float aggregate or not.\n   The answer is true if all the elements of the structure are of the same\n   primitive float type and there is less than 4 elements.\n\n   type: the type corresponding to the structure to be tested */\nstatic int is_hgen_float_aggr(CType *type)\n{\n  if ((type->t & VT_BTYPE) == VT_STRUCT) {\n    struct Sym *ref;\n    int btype, nb_fields = 0;\n\n    ref = type->ref->next;\n    if (ref) {\n      btype = unalias_ldbl(ref->type.t & VT_BTYPE);\n      if (btype == VT_FLOAT || btype == VT_DOUBLE) {\n        for(; ref && btype == unalias_ldbl(ref->type.t & VT_BTYPE); ref = ref->next, nb_fields++);\n        return !ref && nb_fields <= 4;\n      }\n    }\n  }\n  return 0;\n}\n\nstruct avail_regs {\n  signed char avail[3]; /* 3 holes max with only float and double alignments */\n  int first_hole; /* first available hole */\n  int last_hole; /* last available hole (none if equal to first_hole) */\n  int first_free_reg; /* next free register in the sequence, hole excluded */\n};\n\n/* Find suitable registers for a VFP Co-Processor Register Candidate (VFP CPRC\n   param) according to the rules described in the procedure call standard for\n   the ARM architecture (AAPCS). If found, the registers are assigned to this\n   VFP CPRC parameter. Registers are allocated in sequence unless a hole exists\n   and the parameter is a single float.\n\n   avregs: opaque structure to keep track of available VFP co-processor regs\n   align: alignment constraints for the param, as returned by type_size()\n   size: size of the parameter, as returned by type_size() */\nint assign_vfpreg(struct avail_regs *avregs, int align, int size)\n{\n  int first_reg = 0;\n\n  if (avregs->first_free_reg == -1)\n    return -1;\n  if (align >> 3) { /* double alignment */\n    first_reg = avregs->first_free_reg;\n    /* alignment constraint not respected so use next reg and record hole */\n    if (first_reg & 1)\n      avregs->avail[avregs->last_hole++] = first_reg++;\n  } else { /* no special alignment (float or array of float) */\n    /* if single float and a hole is available, assign the param to it */\n    if (size == 4 && avregs->first_hole != avregs->last_hole)\n      return avregs->avail[avregs->first_hole++];\n    else\n      first_reg = avregs->first_free_reg;\n  }\n  if (first_reg + size / 4 <= 16) {\n    avregs->first_free_reg = first_reg + size / 4;\n    return first_reg;\n  }\n  avregs->first_free_reg = -1;\n  return -1;\n}\n\n/* Returns whether all params need to be passed in core registers or not.\n   This is the case for function part of the runtime ABI. */\nint floats_in_core_regs(SValue *sval)\n{\n  if (!sval->sym)\n    return 0;\n\n  switch (sval->sym->v) {\n    case TOK___floatundisf:\n    case TOK___floatundidf:\n    case TOK___fixunssfdi:\n    case TOK___fixunsdfdi:\n#ifndef TCC_ARM_VFP\n    case TOK___fixunsxfdi:\n#endif\n    case TOK___floatdisf:\n    case TOK___floatdidf:\n    case TOK___fixsfdi:\n    case TOK___fixdfdi:\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n\n/* Return the number of registers needed to return the struct, or 0 if\n   returning via struct pointer. */\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize) {\n#ifdef TCC_ARM_EABI\n    int size, align;\n    size = type_size(vt, &align);\n    if (float_abi == ARM_HARD_FLOAT && !variadic &&\n        (is_float(vt->t) || is_hgen_float_aggr(vt))) {\n        *ret_align = 8;\n\t*regsize = 8;\n        ret->ref = NULL;\n        ret->t = VT_DOUBLE;\n        return (size + 7) >> 3;\n    } else if (size > 0 && size <= 4) {\n        *ret_align = 4;\n\t*regsize = 4;\n        ret->ref = NULL;\n        ret->t = VT_INT;\n        return 1;\n    } else\n        return 0;\n#else\n    return 0;\n#endif\n}\n\n/* Parameters are classified according to how they are copied to their final\n   destination for the function call. Because the copying is performed class\n   after class according to the order in the union below, it is important that\n   some constraints about the order of the members of this union are respected:\n   - CORE_STRUCT_CLASS must come after STACK_CLASS;\n   - CORE_CLASS must come after STACK_CLASS, CORE_STRUCT_CLASS and\n     VFP_STRUCT_CLASS;\n   - VFP_STRUCT_CLASS must come after VFP_CLASS.\n   See the comment for the main loop in copy_params() for the reason. */\nenum reg_class {\n\tSTACK_CLASS = 0,\n\tCORE_STRUCT_CLASS,\n\tVFP_CLASS,\n\tVFP_STRUCT_CLASS,\n\tCORE_CLASS,\n\tNB_CLASSES\n};\n\nstruct param_plan {\n    int start; /* first reg or addr used depending on the class */\n    int end; /* last reg used or next free addr depending on the class */\n    SValue *sval; /* pointer to SValue on the value stack */\n    struct param_plan *prev; /*  previous element in this class */\n};\n\nstruct plan {\n    struct param_plan *pplans; /* array of all the param plans */\n    struct param_plan *clsplans[NB_CLASSES]; /* per class lists of param plans */\n    int nb_plans;\n};\n\nstatic void add_param_plan(struct plan* plan, int cls, int start, int end, SValue *v)\n{\n    struct param_plan *p = &plan->pplans[plan->nb_plans++];\n    p->prev = plan->clsplans[cls];\n    plan->clsplans[cls] = p;\n    p->start = start, p->end = end, p->sval = v;\n}\n\n/* Assign parameters to registers and stack with alignment according to the\n   rules in the procedure call standard for the ARM architecture (AAPCS).\n   The overall assignment is recorded in an array of per parameter structures\n   called parameter plans. The parameter plans are also further organized in a\n   number of linked lists, one per class of parameter (see the comment for the\n   definition of union reg_class).\n\n   nb_args: number of parameters of the function for which a call is generated\n   float_abi: float ABI in use for this function call\n   plan: the structure where the overall assignment is recorded\n   todo: a bitmap that record which core registers hold a parameter\n\n   Returns the amount of stack space needed for parameter passing\n\n   Note: this function allocated an array in plan->pplans with tcc_malloc. It\n   is the responsibility of the caller to free this array once used (ie not\n   before copy_params). */\nstatic int assign_regs(int nb_args, int float_abi, struct plan *plan, int *todo)\n{\n  int i, size, align;\n  int ncrn /* next core register number */, nsaa /* next stacked argument address*/;\n  struct avail_regs avregs = {{0}};\n\n  ncrn = nsaa = 0;\n  *todo = 0;\n\n  for(i = nb_args; i-- ;) {\n    int j, start_vfpreg = 0;\n    CType type = vtop[-i].type;\n    type.t &= ~VT_ARRAY;\n    size = type_size(&type, &align);\n    size = (size + 3) & ~3;\n    align = (align + 3) & ~3;\n    switch(vtop[-i].type.t & VT_BTYPE) {\n      case VT_STRUCT:\n      case VT_FLOAT:\n      case VT_DOUBLE:\n      case VT_LDOUBLE:\n      if (float_abi == ARM_HARD_FLOAT) {\n        int is_hfa = 0; /* Homogeneous float aggregate */\n\n        if (is_float(vtop[-i].type.t)\n            || (is_hfa = is_hgen_float_aggr(&vtop[-i].type))) {\n          int end_vfpreg;\n\n          start_vfpreg = assign_vfpreg(&avregs, align, size);\n          end_vfpreg = start_vfpreg + ((size - 1) >> 2);\n          if (start_vfpreg >= 0) {\n            add_param_plan(plan, is_hfa ? VFP_STRUCT_CLASS : VFP_CLASS,\n                start_vfpreg, end_vfpreg, &vtop[-i]);\n            continue;\n          } else\n            break;\n        }\n      }\n      ncrn = (ncrn + (align-1)/4) & ~((align/4) - 1);\n      if (ncrn + size/4 <= 4 || (ncrn < 4 && start_vfpreg != -1)) {\n        /* The parameter is allocated both in core register and on stack. As\n\t * such, it can be of either class: it would either be the last of\n\t * CORE_STRUCT_CLASS or the first of STACK_CLASS. */\n        for (j = ncrn; j < 4 && j < ncrn + size / 4; j++)\n          *todo|=(1<<j);\n        add_param_plan(plan, CORE_STRUCT_CLASS, ncrn, j, &vtop[-i]);\n        ncrn += size/4;\n        if (ncrn > 4)\n          nsaa = (ncrn - 4) * 4;\n      } else {\n        ncrn = 4;\n        break;\n      }\n      continue;\n      default:\n      if (ncrn < 4) {\n        int is_long = (vtop[-i].type.t & VT_BTYPE) == VT_LLONG;\n\n        if (is_long) {\n          ncrn = (ncrn + 1) & -2;\n          if (ncrn == 4)\n            break;\n        }\n        add_param_plan(plan, CORE_CLASS, ncrn, ncrn + is_long, &vtop[-i]);\n        ncrn += 1 + is_long;\n        continue;\n      }\n    }\n    nsaa = (nsaa + (align - 1)) & ~(align - 1);\n    add_param_plan(plan, STACK_CLASS, nsaa, nsaa + size, &vtop[-i]);\n    nsaa += size; /* size already rounded up before */\n  }\n  return nsaa;\n}\n\n/* Copy parameters to their final destination (core reg, VFP reg or stack) for\n   function call.\n\n   nb_args: number of parameters the function take\n   plan: the overall assignment plan for parameters\n   todo: a bitmap indicating what core reg will hold a parameter\n\n   Returns the number of SValue added by this function on the value stack */\nstatic int copy_params(int nb_args, struct plan *plan, int todo)\n{\n  int size, align, r, i, nb_extra_sval = 0;\n  struct param_plan *pplan;\n  int pass = 0;\n\n   /* Several constraints require parameters to be copied in a specific order:\n      - structures are copied to the stack before being loaded in a reg;\n      - floats loaded to an odd numbered VFP reg are first copied to the\n        preceding even numbered VFP reg and then moved to the next VFP reg.\n\n      It is thus important that:\n      - structures assigned to core regs must be copied after parameters\n        assigned to the stack but before structures assigned to VFP regs because\n        a structure can lie partly in core registers and partly on the stack;\n      - parameters assigned to the stack and all structures be copied before\n        parameters assigned to a core reg since copying a parameter to the stack\n        require using a core reg;\n      - parameters assigned to VFP regs be copied before structures assigned to\n        VFP regs as the copy might use an even numbered VFP reg that already\n        holds part of a structure. */\nagain:\n  for(i = 0; i < NB_CLASSES; i++) {\n    for(pplan = plan->clsplans[i]; pplan; pplan = pplan->prev) {\n\n      if (pass\n          && (i != CORE_CLASS || pplan->sval->r < VT_CONST))\n        continue;\n\n      vpushv(pplan->sval);\n      pplan->sval->r = pplan->sval->r2 = VT_CONST; /* disable entry */\n      switch(i) {\n        case STACK_CLASS:\n        case CORE_STRUCT_CLASS:\n        case VFP_STRUCT_CLASS:\n          if ((pplan->sval->type.t & VT_BTYPE) == VT_STRUCT) {\n            int padding = 0;\n            size = type_size(&pplan->sval->type, &align);\n            /* align to stack align size */\n            size = (size + 3) & ~3;\n            if (i == STACK_CLASS && pplan->prev)\n              padding = pplan->start - pplan->prev->end;\n            size += padding; /* Add padding if any */\n            /* allocate the necessary size on stack */\n            gadd_sp(-size);\n            /* generate structure store */\n            r = get_reg(RC_INT);\n            o(0xE28D0000|(intr(r)<<12)|padding); /* add r, sp, padding */\n            vset(&vtop->type, r | VT_LVAL, 0);\n            vswap();\n\t    /* XXX: optimize. Save all register because memcpy can use them */\n\t    o(0xED2D0A00|(0&1)<<22|(0>>1)<<12|16); /* vpush {s0-s15} */\n            vstore(); /* memcpy to current sp + potential padding */\n\t    o(0xECBD0A00|(0&1)<<22|(0>>1)<<12|16); /* vpop {s0-s15} */\n\n            /* Homogeneous float aggregate are loaded to VFP registers\n               immediately since there is no way of loading data in multiple\n               non consecutive VFP registers as what is done for other\n               structures (see the use of todo). */\n            if (i == VFP_STRUCT_CLASS) {\n              int first = pplan->start, nb = pplan->end - first + 1;\n              /* vpop.32 {pplan->start, ..., pplan->end} */\n              o(0xECBD0A00|(first&1)<<22|(first>>1)<<12|nb);\n              /* No need to write the register used to a SValue since VFP regs\n                 cannot be used for gcall_or_jmp */\n            }\n          } else {\n            if (is_float(pplan->sval->type.t)) {\n#ifdef TCC_ARM_VFP\n              r = vfpr(gv(RC_FLOAT)) << 12;\n              if ((pplan->sval->type.t & VT_BTYPE) == VT_FLOAT)\n                size = 4;\n              else {\n                size = 8;\n                r |= 0x101; /* vpush.32 -> vpush.64 */\n              }\n              o(0xED2D0A01 + r); /* vpush */\n#else\n              r = fpr(gv(RC_FLOAT)) << 12;\n              if ((pplan->sval->type.t & VT_BTYPE) == VT_FLOAT)\n                size = 4;\n              else if ((pplan->sval->type.t & VT_BTYPE) == VT_DOUBLE)\n                size = 8;\n              else\n                size = LDOUBLE_SIZE;\n\n              if (size == 12)\n                r |= 0x400000;\n              else if(size == 8)\n                r|=0x8000;\n\n              o(0xED2D0100|r|(size>>2)); /* some kind of vpush for FPA */\n#endif\n            } else {\n              /* simple type (currently always same size) */\n              /* XXX: implicit cast ? */\n              size=4;\n              if ((pplan->sval->type.t & VT_BTYPE) == VT_LLONG) {\n                lexpand();\n                size = 8;\n                r = gv(RC_INT);\n                o(0xE52D0004|(intr(r)<<12)); /* push r */\n                vtop--;\n              }\n              r = gv(RC_INT);\n              o(0xE52D0004|(intr(r)<<12)); /* push r */\n            }\n            if (i == STACK_CLASS && pplan->prev)\n              gadd_sp(pplan->prev->end - pplan->start); /* Add padding if any */\n          }\n          break;\n\n        case VFP_CLASS:\n          gv(regmask(TREG_F0 + (pplan->start >> 1)));\n          if (pplan->start & 1) { /* Must be in upper part of double register */\n            o(0xEEF00A40|((pplan->start>>1)<<12)|(pplan->start>>1)); /* vmov.f32 s(n+1), sn */\n            vtop->r = VT_CONST; /* avoid being saved on stack by gv for next float */\n          }\n          break;\n\n        case CORE_CLASS:\n          if ((pplan->sval->type.t & VT_BTYPE) == VT_LLONG) {\n            lexpand();\n            gv(regmask(pplan->end));\n            pplan->sval->r2 = vtop->r;\n            vtop--;\n          }\n          gv(regmask(pplan->start));\n          /* Mark register as used so that gcall_or_jmp use another one\n             (regs >=4 are free as never used to pass parameters) */\n          pplan->sval->r = vtop->r;\n          break;\n      }\n      vtop--;\n    }\n  }\n\n  /* second pass to restore registers that were saved on stack by accident.\n     Maybe redundant after the \"lvalue_save\" patch in tccgen.c:gv() */\n  if (++pass < 2)\n    goto again;\n\n  /* Manually free remaining registers since next parameters are loaded\n   * manually, without the help of gv(int). */\n  save_regs(nb_args);\n\n  if(todo) {\n    o(0xE8BD0000|todo); /* pop {todo} */\n    for(pplan = plan->clsplans[CORE_STRUCT_CLASS]; pplan; pplan = pplan->prev) {\n      int r;\n      pplan->sval->r = pplan->start;\n      /* An SValue can only pin 2 registers at best (r and r2) but a structure\n         can occupy more than 2 registers. Thus, we need to push on the value\n         stack some fake parameter to have on SValue for each registers used\n         by a structure (r2 is not used). */\n      for (r = pplan->start + 1; r <= pplan->end; r++) {\n        if (todo & (1 << r)) {\n          nb_extra_sval++;\n          vpushi(0);\n          vtop->r = r;\n        }\n      }\n    }\n  }\n  return nb_extra_sval;\n}\n\n/* Generate function call. The function address is pushed first, then\n   all the parameters in call order. This functions pops all the\n   parameters and the function address. */\nvoid gfunc_call(int nb_args)\n{\n  int r, args_size;\n  int def_float_abi = float_abi;\n  int todo;\n  struct plan plan;\n#ifdef TCC_ARM_EABI\n  int variadic;\n#endif\n\n#ifdef CONFIG_TCC_BCHECK\n  if (tcc_state->do_bounds_check)\n    gbound_args(nb_args);\n#endif\n\n#ifdef TCC_ARM_EABI\n  if (float_abi == ARM_HARD_FLOAT) {\n    variadic = (vtop[-nb_args].type.ref->f.func_type == FUNC_ELLIPSIS);\n    if (variadic || floats_in_core_regs(&vtop[-nb_args]))\n      float_abi = ARM_SOFTFP_FLOAT;\n  }\n#endif\n  /* cannot let cpu flags if other instruction are generated. Also avoid leaving\n     VT_JMP anywhere except on the top of the stack because it would complicate\n     the code generator. */\n  r = vtop->r & VT_VALMASK;\n  if (r == VT_CMP || (r & ~1) == VT_JMP)\n    gv(RC_INT);\n\n  memset(&plan, 0, sizeof plan);\n  if (nb_args)\n    plan.pplans = tcc_malloc(nb_args * sizeof(*plan.pplans));\n\n  args_size = assign_regs(nb_args, float_abi, &plan, &todo);\n\n#ifdef TCC_ARM_EABI\n  if (args_size & 7) { /* Stack must be 8 byte aligned at fct call for EABI */\n    args_size = (args_size + 7) & ~7;\n    o(0xE24DD004); /* sub sp, sp, #4 */\n  }\n#endif\n\n  nb_args += copy_params(nb_args, &plan, todo);\n  tcc_free(plan.pplans);\n\n  /* Move fct SValue on top as required by gcall_or_jmp */\n  vrotb(nb_args + 1);\n  gcall_or_jmp(0);\n  if (args_size)\n      gadd_sp(args_size); /* pop all parameters passed on the stack */\n#if defined(TCC_ARM_EABI) && defined(TCC_ARM_VFP)\n  if(float_abi == ARM_SOFTFP_FLOAT && is_float(vtop->type.ref->type.t)) {\n    if((vtop->type.ref->type.t & VT_BTYPE) == VT_FLOAT) {\n      o(0xEE000A10); /*vmov s0, r0 */\n    } else {\n      o(0xEE000B10); /* vmov.32 d0[0], r0 */\n      o(0xEE201B10); /* vmov.32 d0[1], r1 */\n    }\n  }\n#endif\n  vtop -= nb_args + 1; /* Pop all params and fct address from value stack */\n  leaffunc = 0; /* we are calling a function, so we aren't in a leaf function */\n  float_abi = def_float_abi;\n}\n\n/* generate function prolog of type 't' */\nvoid gfunc_prolog(Sym *func_sym)\n{\n  CType *func_type = &func_sym->type;\n  Sym *sym,*sym2;\n  int n, nf, size, align, rs, struct_ret = 0;\n  int addr, pn, sn; /* pn=core, sn=stack */\n  CType ret_type;\n\n#ifdef TCC_ARM_EABI\n  struct avail_regs avregs = {{0}};\n#endif\n\n  sym = func_type->ref;\n\n  n = nf = 0;\n  if ((func_vt.t & VT_BTYPE) == VT_STRUCT &&\n      !gfunc_sret(&func_vt, func_var, &ret_type, &align, &rs))\n  {\n    n++;\n    struct_ret = 1;\n    func_vc = 12; /* Offset from fp of the place to store the result */\n  }\n  for(sym2 = sym->next; sym2 && (n < 4 || nf < 16); sym2 = sym2->next) {\n    size = type_size(&sym2->type, &align);\n#ifdef TCC_ARM_EABI\n    if (float_abi == ARM_HARD_FLOAT && !func_var &&\n        (is_float(sym2->type.t) || is_hgen_float_aggr(&sym2->type))) {\n      int tmpnf = assign_vfpreg(&avregs, align, size);\n      tmpnf += (size + 3) / 4;\n      nf = (tmpnf > nf) ? tmpnf : nf;\n    } else\n#endif\n    if (n < 4)\n      n += (size + 3) / 4;\n  }\n  o(0xE1A0C00D); /* mov ip,sp */\n  if (func_var)\n    n=4;\n  if (n) {\n    if(n>4)\n      n=4;\n#ifdef TCC_ARM_EABI\n    n=(n+1)&-2;\n#endif\n    o(0xE92D0000|((1<<n)-1)); /* save r0-r4 on stack if needed */\n  }\n  if (nf) {\n    if (nf>16)\n      nf=16;\n    nf=(nf+1)&-2; /* nf => HARDFLOAT => EABI */\n    o(0xED2D0A00|nf); /* save s0-s15 on stack if needed */\n  }\n  o(0xE92D5800); /* save fp, ip, lr */\n  o(0xE1A0B00D); /* mov fp, sp */\n  func_sub_sp_offset = ind;\n  o(0xE1A00000); /* nop, leave space for stack adjustment in epilog */\n\n#ifdef TCC_ARM_EABI\n  if (float_abi == ARM_HARD_FLOAT) {\n    func_vc += nf * 4;\n    memset(&avregs, 0, sizeof avregs);\n  }\n#endif\n  pn = struct_ret, sn = 0;\n  while ((sym = sym->next)) {\n    CType *type;\n    type = &sym->type;\n    size = type_size(type, &align);\n    size = (size + 3) >> 2;\n    align = (align + 3) & ~3;\n#ifdef TCC_ARM_EABI\n    if (float_abi == ARM_HARD_FLOAT && !func_var && (is_float(sym->type.t)\n        || is_hgen_float_aggr(&sym->type))) {\n      int fpn = assign_vfpreg(&avregs, align, size << 2);\n      if (fpn >= 0)\n        addr = fpn * 4;\n      else\n        goto from_stack;\n    } else\n#endif\n    if (pn < 4) {\n#ifdef TCC_ARM_EABI\n        pn = (pn + (align-1)/4) & -(align/4);\n#endif\n      addr = (nf + pn) * 4;\n      pn += size;\n      if (!sn && pn > 4)\n        sn = (pn - 4);\n    } else {\n#ifdef TCC_ARM_EABI\nfrom_stack:\n        sn = (sn + (align-1)/4) & -(align/4);\n#endif\n      addr = (n + nf + sn) * 4;\n      sn += size;\n    }\n    sym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL,\n             addr + 12);\n  }\n  last_itod_magic=0;\n  leaffunc = 1;\n  loc = 0;\n#ifdef CONFIG_TCC_BCHECK\n  if (tcc_state->do_bounds_check)\n    gen_bounds_prolog();\n#endif\n}\n\n/* generate function epilog */\nvoid gfunc_epilog(void)\n{\n  uint32_t x;\n  int diff;\n\n#ifdef CONFIG_TCC_BCHECK\n  if (tcc_state->do_bounds_check)\n    gen_bounds_epilog();\n#endif\n  /* Copy float return value to core register if base standard is used and\n     float computation is made with VFP */\n#if defined(TCC_ARM_EABI) && defined(TCC_ARM_VFP)\n  if ((float_abi == ARM_SOFTFP_FLOAT || func_var) && is_float(func_vt.t)) {\n    if((func_vt.t & VT_BTYPE) == VT_FLOAT)\n      o(0xEE100A10); /* fmrs r0, s0 */\n    else {\n      o(0xEE100B10); /* fmrdl r0, d0 */\n      o(0xEE301B10); /* fmrdh r1, d0 */\n    }\n  }\n#endif\n  o(0xE89BA800); /* restore fp, sp, pc */\n  diff = (-loc + 3) & -4;\n#ifdef TCC_ARM_EABI\n  if(!leaffunc)\n    diff = ((diff + 11) & -8) - 4;\n#endif\n  if(diff > 0) {\n    x=stuff_const(0xE24BD000, diff); /* sub sp,fp,# */\n    if(x)\n      *(uint32_t *)(cur_text_section->data + func_sub_sp_offset) = x;\n    else {\n      int addr;\n      addr=ind;\n      o(0xE59FC004); /* ldr ip,[pc+4] */\n      o(0xE04BD00C); /* sub sp,fp,ip  */\n      o(0xE1A0F00E); /* mov pc,lr */\n      o(diff);\n      *(uint32_t *)(cur_text_section->data + func_sub_sp_offset) = 0xE1000000|encbranch(func_sub_sp_offset,addr,1);\n    }\n  }\n}\n\nST_FUNC void gen_fill_nops(int bytes)\n{\n    if ((bytes & 3))\n      tcc_error(\"alignment of code section not multiple of 4\");\n    while (bytes > 0) {\n\to(0xE1A00000);\n\tbytes -= 4;\n    }\n}\n\n/* generate a jump to a label */\nST_FUNC int gjmp(int t)\n{\n  int r;\n  if (nocode_wanted)\n    return t;\n  r=ind;\n  o(0xE0000000|encbranch(r,t,1));\n  return r;\n}\n\n/* generate a jump to a fixed address */\nST_FUNC void gjmp_addr(int a)\n{\n  gjmp(a);\n}\n\nST_FUNC int gjmp_cond(int op, int t)\n{\n  int r;\n  if (nocode_wanted)\n    return t;\n  r=ind;\n  op=mapcc(op);\n  op|=encbranch(r,t,1);\n  o(op);\n  return r;\n}\n\nST_FUNC int gjmp_append(int n, int t)\n{\n  uint32_t *x;\n  int p,lp;\n  if(n) {\n    p = n;\n    do {\n      p = decbranch(lp=p);\n    } while(p);\n    x = (uint32_t *)(cur_text_section->data + lp);\n    *x &= 0xff000000;\n    *x |= encbranch(lp,t,1);\n    t = n;\n  }\n  return t;\n}\n\n/* generate an integer binary operation */\nvoid gen_opi(int op)\n{\n  int c, func = 0;\n  uint32_t opc = 0, r, fr;\n  unsigned short retreg = REG_IRET;\n\n  c=0;\n  switch(op) {\n    case '+':\n      opc = 0x8;\n      c=1;\n      break;\n    case TOK_ADDC1: /* add with carry generation */\n      opc = 0x9;\n      c=1;\n      break;\n    case '-':\n      opc = 0x4;\n      c=1;\n      break;\n    case TOK_SUBC1: /* sub with carry generation */\n      opc = 0x5;\n      c=1;\n      break;\n    case TOK_ADDC2: /* add with carry use */\n      opc = 0xA;\n      c=1;\n      break;\n    case TOK_SUBC2: /* sub with carry use */\n      opc = 0xC;\n      c=1;\n      break;\n    case '&':\n      opc = 0x0;\n      c=1;\n      break;\n    case '^':\n      opc = 0x2;\n      c=1;\n      break;\n    case '|':\n      opc = 0x18;\n      c=1;\n      break;\n    case '*':\n      gv2(RC_INT, RC_INT);\n      r = vtop[-1].r;\n      fr = vtop[0].r;\n      vtop--;\n      o(0xE0000090|(intr(r)<<16)|(intr(r)<<8)|intr(fr));\n      return;\n    case TOK_SHL:\n      opc = 0;\n      c=2;\n      break;\n    case TOK_SHR:\n      opc = 1;\n      c=2;\n      break;\n    case TOK_SAR:\n      opc = 2;\n      c=2;\n      break;\n    case '/':\n    case TOK_PDIV:\n      func=TOK___divsi3;\n      c=3;\n      break;\n    case TOK_UDIV:\n      func=TOK___udivsi3;\n      c=3;\n      break;\n    case '%':\n#ifdef TCC_ARM_EABI\n      func=TOK___aeabi_idivmod;\n      retreg=REG_IRE2;\n#else\n      func=TOK___modsi3;\n#endif\n      c=3;\n      break;\n    case TOK_UMOD:\n#ifdef TCC_ARM_EABI\n      func=TOK___aeabi_uidivmod;\n      retreg=REG_IRE2;\n#else\n      func=TOK___umodsi3;\n#endif\n      c=3;\n      break;\n    case TOK_UMULL:\n      gv2(RC_INT, RC_INT);\n      r=intr(vtop[-1].r2=get_reg(RC_INT));\n      c=vtop[-1].r;\n      vtop[-1].r=get_reg_ex(RC_INT,regmask(c));\n      vtop--;\n      o(0xE0800090|(r<<16)|(intr(vtop->r)<<12)|(intr(c)<<8)|intr(vtop[1].r));\n      return;\n    default:\n      opc = 0x15;\n      c=1;\n      break;\n  }\n  switch(c) {\n    case 1:\n      if((vtop[-1].r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n\tif(opc == 4 || opc == 5 || opc == 0xc) {\n\t  vswap();\n\t  opc|=2; // sub -> rsb\n\t}\n      }\n      if ((vtop->r & VT_VALMASK) == VT_CMP ||\n          (vtop->r & (VT_VALMASK & ~1)) == VT_JMP)\n        gv(RC_INT);\n      vswap();\n      c=intr(gv(RC_INT));\n      vswap();\n      opc=0xE0000000|(opc<<20);\n      if((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n\tuint32_t x;\n\tx=stuff_const(opc|0x2000000|(c<<16),vtop->c.i);\n\tif(x) {\n\t  if ((x & 0xfff00000) == 0xe3500000)   // cmp rx,#c\n\t    o(x);\n\t  else {\n\t    r=intr(vtop[-1].r=get_reg_ex(RC_INT,regmask(vtop[-1].r)));\n\t    o(x|(r<<12));\n\t  }\n\t  goto done;\n\t}\n      }\n      fr=intr(gv(RC_INT));\n#ifdef CONFIG_TCC_BCHECK\n      if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n        vswap();\n        c=intr(gv(RC_INT));\n        vswap();\n      }\n#endif\n      if ((opc & 0xfff00000) == 0xe1500000) // cmp rx,ry\n\to(opc|(c<<16)|fr);\n      else {\n        r=intr(vtop[-1].r=get_reg_ex(RC_INT,two2mask(vtop->r,vtop[-1].r)));\n        o(opc|(c<<16)|(r<<12)|fr);\n      }\ndone:\n      vtop--;\n      if (op >= TOK_ULT && op <= TOK_GT)\n        vset_VT_CMP(op);\n      break;\n    case 2:\n      opc=0xE1A00000|(opc<<5);\n      if ((vtop->r & VT_VALMASK) == VT_CMP ||\n          (vtop->r & (VT_VALMASK & ~1)) == VT_JMP)\n        gv(RC_INT);\n      vswap();\n      r=intr(gv(RC_INT));\n      vswap();\n      if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n\tfr=intr(vtop[-1].r=get_reg_ex(RC_INT,regmask(vtop[-1].r)));\n\tc = vtop->c.i & 0x1f;\n\to(opc|r|(c<<7)|(fr<<12));\n      } else {\n        fr=intr(gv(RC_INT));\n#ifdef CONFIG_TCC_BCHECK\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n          vswap();\n          r=intr(gv(RC_INT));\n          vswap();\n        }\n#endif\n\tc=intr(vtop[-1].r=get_reg_ex(RC_INT,two2mask(vtop->r,vtop[-1].r)));\n\to(opc|r|(c<<12)|(fr<<8)|0x10);\n      }\n      vtop--;\n      break;\n    case 3:\n      vpush_helper_func(func);\n      vrott(3);\n      gfunc_call(2);\n      vpushi(0);\n      vtop->r = retreg;\n      break;\n    default:\n      tcc_error(\"gen_opi %i unimplemented!\",op);\n  }\n}\n\n#ifdef TCC_ARM_VFP\nstatic int is_zero(int i)\n{\n  if((vtop[i].r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)\n    return 0;\n  if (vtop[i].type.t == VT_FLOAT)\n    return (vtop[i].c.f == 0.f);\n  else if (vtop[i].type.t == VT_DOUBLE)\n    return (vtop[i].c.d == 0.0);\n  return (vtop[i].c.ld == 0.l);\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n *    two operands are guaranteed to have the same floating point type */\nvoid gen_opf(int op)\n{\n  uint32_t x;\n  int fneg=0,r;\n  x=0xEE000A00|T2CPR(vtop->type.t);\n  switch(op) {\n    case '+':\n      if(is_zero(-1))\n        vswap();\n      if(is_zero(0)) {\n        vtop--;\n        return;\n      }\n      x|=0x300000;\n      break;\n    case '-':\n      x|=0x300040;\n      if(is_zero(0)) {\n        vtop--;\n        return;\n      }\n      if(is_zero(-1)) {\n        x|=0x810000; /* fsubX -> fnegX */\n        vswap();\n        vtop--;\n        fneg=1;\n      }\n      break;\n    case '*':\n      x|=0x200000;\n      break;\n    case '/':\n      x|=0x800000;\n      break;\n    default:\n      if(op < TOK_ULT || op > TOK_GT) {\n        tcc_error(\"unknown fp op %x!\",op);\n        return;\n      }\n      if(is_zero(-1)) {\n        vswap();\n        switch(op) {\n          case TOK_LT: op=TOK_GT; break;\n          case TOK_GE: op=TOK_ULE; break;\n          case TOK_LE: op=TOK_GE; break;\n          case TOK_GT: op=TOK_ULT; break;\n        }\n      }\n      x|=0xB40040; /* fcmpX */\n      if(op!=TOK_EQ && op!=TOK_NE)\n        x|=0x80; /* fcmpX -> fcmpeX */\n      if(is_zero(0)) {\n        vtop--;\n        o(x|0x10000|(vfpr(gv(RC_FLOAT))<<12)); /* fcmp(e)X -> fcmp(e)zX */\n      } else {\n        gv2(RC_FLOAT,RC_FLOAT);\n        x|=vfpr(vtop[0].r);\n        o(x|(vfpr(vtop[-1].r) << 12));\n        vtop--;\n      }\n      o(0xEEF1FA10); /* fmstat */\n\n      switch(op) {\n        case TOK_LE: op=TOK_ULE; break;\n        case TOK_LT: op=TOK_ULT; break;\n        case TOK_UGE: op=TOK_GE; break;\n        case TOK_UGT: op=TOK_GT; break;\n      }\n      vset_VT_CMP(op);\n      return;\n  }\n  r=gv(RC_FLOAT);\n  x|=vfpr(r);\n  r=regmask(r);\n  if(!fneg) {\n    int r2;\n    vswap();\n    r2=gv(RC_FLOAT);\n    x|=vfpr(r2)<<16;\n    r|=regmask(r2);\n#ifdef CONFIG_TCC_BCHECK\n    if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n      vswap();\n      r=gv(RC_FLOAT);\n      vswap();\n      x=(x&~0xf)|vfpr(r);\n    }\n#endif\n  }\n  vtop->r=get_reg_ex(RC_FLOAT,r);\n  if(!fneg)\n    vtop--;\n  o(x|(vfpr(vtop->r)<<12));\n}\n\n#else\nstatic uint32_t is_fconst()\n{\n  long double f;\n  uint32_t r;\n  if((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)\n    return 0;\n  if (vtop->type.t == VT_FLOAT)\n    f = vtop->c.f;\n  else if (vtop->type.t == VT_DOUBLE)\n    f = vtop->c.d;\n  else\n    f = vtop->c.ld;\n  if(!ieee_finite(f))\n    return 0;\n  r=0x8;\n  if(f<0.0) {\n    r=0x18;\n    f=-f;\n  }\n  if(f==0.0)\n    return r;\n  if(f==1.0)\n    return r|1;\n  if(f==2.0)\n    return r|2;\n  if(f==3.0)\n    return r|3;\n  if(f==4.0)\n    return r|4;\n  if(f==5.0)\n    return r|5;\n  if(f==0.5)\n    return r|6;\n  if(f==10.0)\n    return r|7;\n  return 0;\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranteed to have the same floating point type */\nvoid gen_opf(int op)\n{\n  uint32_t x, r, r2, c1, c2;\n  //fputs(\"gen_opf\\n\",stderr);\n  vswap();\n  c1 = is_fconst();\n  vswap();\n  c2 = is_fconst();\n  x=0xEE000100;\n#if LDOUBLE_SIZE == 8\n  if ((vtop->type.t & VT_BTYPE) != VT_FLOAT)\n    x|=0x80;\n#else\n  if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)\n    x|=0x80;\n  else if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE)\n    x|=0x80000;\n#endif\n  switch(op)\n  {\n    case '+':\n      if(!c2) {\n\tvswap();\n\tc2=c1;\n      }\n      vswap();\n      r=fpr(gv(RC_FLOAT));\n      vswap();\n      if(c2) {\n\tif(c2>0xf)\n\t  x|=0x200000; // suf\n\tr2=c2&0xf;\n      } else {\n\tr2=fpr(gv(RC_FLOAT));\n#ifdef CONFIG_TCC_BCHECK\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n          vswap();\n          r=fpr(gv(RC_FLOAT));\n          vswap();\n        }\n#endif\n      }\n      break;\n    case '-':\n      if(c2) {\n\tif(c2<=0xf)\n\t  x|=0x200000; // suf\n\tr2=c2&0xf;\n\tvswap();\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n      } else if(c1 && c1<=0xf) {\n\tx|=0x300000; // rsf\n\tr2=c1;\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n      } else {\n\tx|=0x200000; // suf\n\tvswap();\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n\tr2=fpr(gv(RC_FLOAT));\n#ifdef CONFIG_TCC_BCHECK\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n          vswap();\n          r=fpr(gv(RC_FLOAT));\n          vswap();\n        }\n#endif\n      }\n      break;\n    case '*':\n      if(!c2 || c2>0xf) {\n\tvswap();\n\tc2=c1;\n      }\n      vswap();\n      r=fpr(gv(RC_FLOAT));\n      vswap();\n      if(c2 && c2<=0xf)\n\tr2=c2;\n      else {\n\tr2=fpr(gv(RC_FLOAT));\n#ifdef CONFIG_TCC_BCHECK\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n          vswap();\n          r=fpr(gv(RC_FLOAT));\n          vswap();\n        }\n#endif\n      }\n      x|=0x100000; // muf\n      break;\n    case '/':\n      if(c2 && c2<=0xf) {\n\tx|=0x400000; // dvf\n\tr2=c2;\n\tvswap();\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n      } else if(c1 && c1<=0xf) {\n\tx|=0x500000; // rdf\n\tr2=c1;\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n      } else {\n\tx|=0x400000; // dvf\n\tvswap();\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n\tr2=fpr(gv(RC_FLOAT));\n#ifdef CONFIG_TCC_BCHECK\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n          vswap();\n          r=fpr(gv(RC_FLOAT));\n          vswap();\n        }\n#endif\n      }\n      break;\n    default:\n      if(op >= TOK_ULT && op <= TOK_GT) {\n\tx|=0xd0f110; // cmfe\n/* bug (intention?) in Linux FPU emulator\n   doesn't set carry if equal */\n\tswitch(op) {\n\t  case TOK_ULT:\n\t  case TOK_UGE:\n\t  case TOK_ULE:\n\t  case TOK_UGT:\n            tcc_error(\"unsigned comparison on floats?\");\n\t    break;\n\t  case TOK_LT:\n            op=TOK_Nset;\n\t    break;\n\t  case TOK_LE:\n            op=TOK_ULE; /* correct in unordered case only if AC bit in FPSR set */\n\t    break;\n\t  case TOK_EQ:\n\t  case TOK_NE:\n\t    x&=~0x400000; // cmfe -> cmf\n\t    break;\n\t}\n\tif(c1 && !c2) {\n\t  c2=c1;\n\t  vswap();\n\t  switch(op) {\n            case TOK_Nset:\n              op=TOK_GT;\n\t      break;\n            case TOK_GE:\n\t      op=TOK_ULE;\n\t      break;\n\t    case TOK_ULE:\n              op=TOK_GE;\n\t      break;\n            case TOK_GT:\n              op=TOK_Nset;\n\t      break;\n\t  }\n\t}\n\tvswap();\n\tr=fpr(gv(RC_FLOAT));\n\tvswap();\n\tif(c2) {\n\t  if(c2>0xf)\n\t    x|=0x200000;\n\t  r2=c2&0xf;\n\t} else {\n\t  r2=fpr(gv(RC_FLOAT));\n#ifdef CONFIG_TCC_BCHECK\n          if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n            vswap();\n            r=fpr(gv(RC_FLOAT));\n            vswap();\n          }\n#endif\n\t}\n        --vtop;\n        vset_VT_CMP(op);\n        ++vtop;\n      } else {\n        tcc_error(\"unknown fp op %x!\",op);\n\treturn;\n      }\n  }\n  if(vtop[-1].r == VT_CMP)\n    c1=15;\n  else {\n    c1=vtop->r;\n    if(r2&0x8)\n      c1=vtop[-1].r;\n    vtop[-1].r=get_reg_ex(RC_FLOAT,two2mask(vtop[-1].r,c1));\n    c1=fpr(vtop[-1].r);\n  }\n  vtop--;\n  o(x|(r<<16)|(c1<<12)|r2);\n}\n#endif\n\n/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\nST_FUNC void gen_cvt_itof(int t)\n{\n  uint32_t r, r2;\n  int bt;\n  bt=vtop->type.t & VT_BTYPE;\n  if(bt == VT_INT || bt == VT_SHORT || bt == VT_BYTE) {\n#ifndef TCC_ARM_VFP\n    uint32_t dsize = 0;\n#endif\n    r=intr(gv(RC_INT));\n#ifdef TCC_ARM_VFP\n    r2=vfpr(vtop->r=get_reg(RC_FLOAT));\n    o(0xEE000A10|(r<<12)|(r2<<16)); /* fmsr */\n    r2|=r2<<12;\n    if(!(vtop->type.t & VT_UNSIGNED))\n      r2|=0x80;                /* fuitoX -> fsituX */\n    o(0xEEB80A40|r2|T2CPR(t)); /* fYitoX*/\n#else\n    r2=fpr(vtop->r=get_reg(RC_FLOAT));\n    if((t & VT_BTYPE) != VT_FLOAT)\n      dsize=0x80;    /* flts -> fltd */\n    o(0xEE000110|dsize|(r2<<16)|(r<<12)); /* flts */\n    if((vtop->type.t & (VT_UNSIGNED|VT_BTYPE)) == (VT_UNSIGNED|VT_INT)) {\n      uint32_t off = 0;\n      o(0xE3500000|(r<<12));        /* cmp */\n      r=fpr(get_reg(RC_FLOAT));\n      if(last_itod_magic) {\n\toff=ind+8-last_itod_magic;\n\toff/=4;\n\tif(off>255)\n\t  off=0;\n      }\n      o(0xBD1F0100|(r<<12)|off);    /* ldflts */\n      if(!off) {\n        o(0xEA000000);              /* b */\n        last_itod_magic=ind;\n        o(0x4F800000);              /* 4294967296.0f */\n      }\n      o(0xBE000100|dsize|(r2<<16)|(r2<<12)|r); /* adflt */\n    }\n#endif\n    return;\n  } else if(bt == VT_LLONG) {\n    int func;\n    CType *func_type = 0;\n    if((t & VT_BTYPE) == VT_FLOAT) {\n      func_type = &func_float_type;\n      if(vtop->type.t & VT_UNSIGNED)\n        func=TOK___floatundisf;\n      else\n        func=TOK___floatdisf;\n#if LDOUBLE_SIZE != 8\n    } else if((t & VT_BTYPE) == VT_LDOUBLE) {\n      func_type = &func_ldouble_type;\n      if(vtop->type.t & VT_UNSIGNED)\n        func=TOK___floatundixf;\n      else\n        func=TOK___floatdixf;\n    } else if((t & VT_BTYPE) == VT_DOUBLE) {\n#else\n    } else if((t & VT_BTYPE) == VT_DOUBLE || (t & VT_BTYPE) == VT_LDOUBLE) {\n#endif\n      func_type = &func_double_type;\n      if(vtop->type.t & VT_UNSIGNED)\n        func=TOK___floatundidf;\n      else\n        func=TOK___floatdidf;\n    }\n    if(func_type) {\n      vpushsym(func_type, external_helper_sym(func));\n      vswap();\n      gfunc_call(1);\n      vpushi(0);\n      vtop->r=TREG_F0;\n      return;\n    }\n  }\n  tcc_error(\"unimplemented gen_cvt_itof %x!\",vtop->type.t);\n}\n\n/* convert fp to int 't' type */\nvoid gen_cvt_ftoi(int t)\n{\n  uint32_t r, r2;\n  int u, func = 0;\n  u=t&VT_UNSIGNED;\n  t&=VT_BTYPE;\n  r2=vtop->type.t & VT_BTYPE;\n  if(t==VT_INT) {\n#ifdef TCC_ARM_VFP\n    r=vfpr(gv(RC_FLOAT));\n    u=u?0:0x10000;\n    o(0xEEBC0AC0|(r<<12)|r|T2CPR(r2)|u); /* ftoXizY */\n    r2=intr(vtop->r=get_reg(RC_INT));\n    o(0xEE100A10|(r<<16)|(r2<<12));\n    return;\n#else\n    if(u) {\n      if(r2 == VT_FLOAT)\n        func=TOK___fixunssfsi;\n#if LDOUBLE_SIZE != 8\n      else if(r2 == VT_LDOUBLE)\n\tfunc=TOK___fixunsxfsi;\n      else if(r2 == VT_DOUBLE)\n#else\n      else if(r2 == VT_LDOUBLE || r2 == VT_DOUBLE)\n#endif\n\tfunc=TOK___fixunsdfsi;\n    } else {\n      r=fpr(gv(RC_FLOAT));\n      r2=intr(vtop->r=get_reg(RC_INT));\n      o(0xEE100170|(r2<<12)|r);\n      return;\n    }\n#endif\n  } else if(t == VT_LLONG) { // unsigned handled in gen_cvt_ftoi1\n    if(r2 == VT_FLOAT)\n      func=TOK___fixsfdi;\n#if LDOUBLE_SIZE != 8\n    else if(r2 == VT_LDOUBLE)\n      func=TOK___fixxfdi;\n    else if(r2 == VT_DOUBLE)\n#else\n    else if(r2 == VT_LDOUBLE || r2 == VT_DOUBLE)\n#endif\n      func=TOK___fixdfdi;\n  }\n  if(func) {\n    vpush_helper_func(func);\n    vswap();\n    gfunc_call(1);\n    vpushi(0);\n    if(t == VT_LLONG)\n      vtop->r2 = REG_IRE2;\n    vtop->r = REG_IRET;\n    return;\n  }\n  tcc_error(\"unimplemented gen_cvt_ftoi!\");\n}\n\n/* convert from one floating point type to another */\nvoid gen_cvt_ftof(int t)\n{\n#ifdef TCC_ARM_VFP\n  if(((vtop->type.t & VT_BTYPE) == VT_FLOAT) != ((t & VT_BTYPE) == VT_FLOAT)) {\n    uint32_t r = vfpr(gv(RC_FLOAT));\n    o(0xEEB70AC0|(r<<12)|r|T2CPR(vtop->type.t));\n  }\n#else\n  /* all we have to do on i386 and FPA ARM is to put the float in a register */\n  gv(RC_FLOAT);\n#endif\n}\n\n/* increment tcov counter */\nST_FUNC void gen_increment_tcov (SValue *sv)\n{\n  int r1, r2;\n\n  vpushv(sv);\n  vtop->r = r1 = get_reg(RC_INT);\n  r2 = get_reg(RC_INT);\n  o(0xE59F0000 | (intr(r1)<<12)); // ldr r1,[pc]\n  o(0xEA000000); // b $+4\n  greloc(cur_text_section, sv->sym, ind, R_ARM_REL32);\n  o(-12);\n  o(0xe080000f | (intr(r1)<<16) | (intr(r1)<<12)); // add r1,r1,pc\n  o(0xe5900000 | (intr(r1)<<16) | (intr(r2)<<12)); // ldr r2, [r1]\n  o(0xe2900001 | (intr(r2)<<16) | (intr(r2)<<12)); // adds r2, r2, #1\n  o(0xe5800000 | (intr(r1)<<16) | (intr(r2)<<12)); // str r2, [r1]\n  o(0xe2800004 | (intr(r1)<<16) | (intr(r1)<<12)); // add r1, r1, #4\n  o(0xe5900000 | (intr(r1)<<16) | (intr(r2)<<12)); // ldr r2, [r1]\n  o(0xe2a00000 | (intr(r2)<<16) | (intr(r2)<<12)); // adc r2, r2, #0\n  o(0xe5800000 | (intr(r1)<<16) | (intr(r2)<<12)); // str r2, [r1]\n  vpop();\n}\n\n/* computed goto support */\nvoid ggoto(void)\n{\n  gcall_or_jmp(1);\n  vtop--;\n}\n\n/* Save the stack pointer onto the stack and return the location of its address */\nST_FUNC void gen_vla_sp_save(int addr) {\n    SValue v;\n    v.type.t = VT_PTR;\n    v.r = VT_LOCAL | VT_LVAL;\n    v.c.i = addr;\n    store(TREG_SP, &v);\n}\n\n/* Restore the SP from a location on the stack */\nST_FUNC void gen_vla_sp_restore(int addr) {\n    SValue v;\n    v.type.t = VT_PTR;\n    v.r = VT_LOCAL | VT_LVAL;\n    v.c.i = addr;\n    load(TREG_SP, &v);\n}\n\n/* Subtract from the stack pointer, and push the resulting value onto the stack */\nST_FUNC void gen_vla_alloc(CType *type, int align) {\n    int r;\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check)\n        vpushv(vtop);\n#endif\n    r = intr(gv(RC_INT));\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check)\n        o(0xe2800001 | (r<<16)|(r<<12)); /* add r,r,#1 */\n#endif\n    o(0xE04D0000|(r<<12)|r); /* sub r, sp, r */\n#ifdef TCC_ARM_EABI\n    if (align < 8)\n        align = 8;\n#else\n    if (align < 4)\n        align = 4;\n#endif\n    if (align & (align - 1))\n        tcc_error(\"alignment is not a power of 2: %i\", align);\n    o(stuff_const(0xE3C0D000|(r<<16), align - 1)); /* bic sp, r, #align-1 */\n    vpop();\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check) {\n        vpushi(0);\n        vtop->r = TREG_R0;\n        o(0xe1a0000d | (vtop->r << 12)); // mov r0,sp\n        vswap();\n        vpush_helper_func(TOK___bound_new_region);\n        vrott(3);\n        gfunc_call(2);\n        func_bound_add_epilog = 1;\n    }\n#endif\n}\n\n/* end of ARM code generator */\n/*************************************************************/\n#endif\n/*************************************************************/\n"
        },
        {
          "name": "arm-link.c",
          "type": "blob",
          "size": 14.4404296875,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n#define EM_TCC_TARGET EM_ARM\n\n/* relocation type for 32 bit data relocation */\n#define R_DATA_32   R_ARM_ABS32\n#define R_DATA_PTR  R_ARM_ABS32\n#define R_JMP_SLOT  R_ARM_JUMP_SLOT\n#define R_GLOB_DAT  R_ARM_GLOB_DAT\n#define R_COPY      R_ARM_COPY\n#define R_RELATIVE  R_ARM_RELATIVE\n\n#define R_NUM       R_ARM_NUM\n\n#define ELF_START_ADDR 0x00010000\n#define ELF_PAGE_SIZE  0x10000\n\n#define PCRELATIVE_DLLPLT 1\n#define RELOCATE_DLLPLT 1\n\nenum float_abi {\n    ARM_SOFTFP_FLOAT,\n    ARM_HARD_FLOAT,\n};\n\n#else /* !TARGET_DEFS_ONLY */\n\n#include \"tcc.h\"\n\n#ifdef NEED_RELOC_TYPE\n/* Returns 1 for a code relocation, 0 for a data relocation. For unknown\n   relocations, returns -1. */\nST_FUNC int code_reloc (int reloc_type)\n{\n    switch (reloc_type) {\n\tcase R_ARM_MOVT_ABS:\n\tcase R_ARM_MOVW_ABS_NC:\n\tcase R_ARM_THM_MOVT_ABS:\n\tcase R_ARM_THM_MOVW_ABS_NC:\n\tcase R_ARM_ABS32:\n\tcase R_ARM_REL32:\n\tcase R_ARM_GOTPC:\n\tcase R_ARM_GOTOFF:\n\tcase R_ARM_GOT32:\n\tcase R_ARM_GOT_PREL:\n\tcase R_ARM_COPY:\n\tcase R_ARM_GLOB_DAT:\n\tcase R_ARM_NONE:\n\tcase R_ARM_TARGET1:\n\tcase R_ARM_MOVT_PREL:\n\tcase R_ARM_MOVW_PREL_NC:\n            return 0;\n\n        case R_ARM_PC24:\n        case R_ARM_CALL:\n\tcase R_ARM_JUMP24:\n\tcase R_ARM_PLT32:\n\tcase R_ARM_THM_PC22:\n\tcase R_ARM_THM_JUMP24:\n\tcase R_ARM_PREL31:\n\tcase R_ARM_V4BX:\n\tcase R_ARM_JUMP_SLOT:\n            return 1;\n    }\n    return -1;\n}\n\n/* Returns an enumerator to describe whether and when the relocation needs a\n   GOT and/or PLT entry to be created. See tcc.h for a description of the\n   different values. */\nST_FUNC int gotplt_entry_type (int reloc_type)\n{\n    switch (reloc_type) {\n\tcase R_ARM_NONE:\n\tcase R_ARM_COPY:\n\tcase R_ARM_GLOB_DAT:\n\tcase R_ARM_JUMP_SLOT:\n            return NO_GOTPLT_ENTRY;\n\n        case R_ARM_PC24:\n        case R_ARM_CALL:\n\tcase R_ARM_JUMP24:\n\tcase R_ARM_PLT32:\n\tcase R_ARM_THM_PC22:\n\tcase R_ARM_THM_JUMP24:\n\tcase R_ARM_MOVT_ABS:\n\tcase R_ARM_MOVW_ABS_NC:\n\tcase R_ARM_THM_MOVT_ABS:\n\tcase R_ARM_THM_MOVW_ABS_NC:\n\tcase R_ARM_PREL31:\n\tcase R_ARM_ABS32:\n\tcase R_ARM_REL32:\n\tcase R_ARM_V4BX:\n\tcase R_ARM_TARGET1:\n\tcase R_ARM_MOVT_PREL:\n\tcase R_ARM_MOVW_PREL_NC:\n            return AUTO_GOTPLT_ENTRY;\n\n\tcase R_ARM_GOTPC:\n\tcase R_ARM_GOTOFF:\n            return BUILD_GOT_ONLY;\n\n\tcase R_ARM_GOT32:\n\tcase R_ARM_GOT_PREL:\n            return ALWAYS_GOTPLT_ENTRY;\n    }\n    return -1;\n}\n\n#ifdef NEED_BUILD_GOT\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)\n{\n    Section *plt = s1->plt;\n    uint8_t *p;\n    unsigned plt_offset;\n\n    /* when building a DLL, GOT entry accesses must be done relative to\n       start of GOT (see x86_64 example above)  */\n\n    /* empty PLT: create PLT0 entry that push address of call site and\n       jump to ld.so resolution routine (GOT + 8) */\n    if (plt->data_offset == 0) {\n        p = section_ptr_add(plt, 20);\n        write32le(p,    0xe52de004); /* push {lr}         */\n        write32le(p+4,  0xe59fe004); /* ldr lr, [pc, #4] */\n        write32le(p+8,  0xe08fe00e); /* add lr, pc, lr    */\n        write32le(p+12, 0xe5bef008); /* ldr pc, [lr, #8]! */\n        /* p+16 is set in relocate_plt */\n    }\n    plt_offset = plt->data_offset;\n\n    if (attr->plt_thumb_stub) {\n        p = section_ptr_add(plt, 4);\n        write32le(p,   0x4778); /* bx pc */\n        write32le(p+2, 0x46c0); /* nop   */\n    }\n    p = section_ptr_add(plt, 16);\n    /* save GOT offset for relocate_plt */\n    write32le(p + 4, got_offset);\n    return plt_offset;\n}\n\n/* relocate the PLT: compute addresses and offsets in the PLT now that final\n   address for PLT and GOT are known (see fill_program_header) */\nST_FUNC void relocate_plt(TCCState *s1)\n{\n    uint8_t *p, *p_end;\n\n    if (!s1->plt)\n      return;\n\n    p = s1->plt->data;\n    p_end = p + s1->plt->data_offset;\n\n    if (p < p_end) {\n        int x = s1->got->sh_addr - s1->plt->sh_addr - 12;\n        write32le(s1->plt->data + 16, x - 4);\n        p += 20;\n        while (p < p_end) {\n\t    unsigned off = x  + read32le(p + 4) + (s1->plt->data - p) + 4;\n            if (read32le(p) == 0x46c04778) /* PLT Thumb stub present */\n                p += 4;\n            write32le(p, 0xe28fc200 | ((off >> 28) & 0xf));      // add ip, pc, #0xN0000000\n            write32le(p + 4, 0xe28cc600 | ((off >> 20) & 0xff)); // add ip, pc, #0xNN00000\n            write32le(p + 8, 0xe28cca00 | ((off >> 12) & 0xff)); // add ip, ip, #0xNN000\n            write32le(p + 12, 0xe5bcf000 | (off & 0xfff));\t // ldr pc, [ip, #0xNNN]!\n            p += 16;\n        }\n    }\n\n    if (s1->plt->reloc) {\n        ElfW_Rel *rel;\n        p = s1->got->data;\n        for_each_elem(s1->plt->reloc, 0, rel, ElfW_Rel) {\n            write32le(p + rel->r_offset, s1->plt->sh_addr);\n\t}\n    }\n}\n#endif\n#endif\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)\n{\n    ElfW(Sym) *sym;\n    int sym_index, esym_index;\n\n    sym_index = ELFW(R_SYM)(rel->r_info);\n    sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\n    switch(type) {\n        case R_ARM_PC24:\n        case R_ARM_CALL:\n        case R_ARM_JUMP24:\n        case R_ARM_PLT32:\n            {\n                int x, is_thumb, is_call, h, blx_avail, is_bl, th_ko;\n                x = (*(int *) ptr) & 0xffffff;\n#ifdef DEBUG_RELOC\n\t\tprintf (\"reloc %d: x=0x%x val=0x%x \", type, x, val);\n#endif\n                (*(int *)ptr) &= 0xff000000;\n                if (x & 0x800000)\n                    x -= 0x1000000;\n                x <<= 2;\n                blx_avail = (CONFIG_TCC_CPUVER >= 5);\n                is_thumb = val & 1;\n                is_bl = (*(unsigned *) ptr) >> 24 == 0xeb;\n                is_call = (type == R_ARM_CALL || (type == R_ARM_PC24 && is_bl));\n                x += val - addr;\n#ifdef DEBUG_RELOC\n\t\tprintf (\" newx=0x%x name=%s\\n\", x,\n\t\t\t(char *) symtab_section->link->data + sym->st_name);\n#endif\n                h = x & 2;\n                th_ko = (x & 3) && (!blx_avail || !is_call);\n                if (th_ko || x >= 0x2000000 || x < -0x2000000)\n                    tcc_error_noabort(\"can't relocate value at %x,%d\",addr, type);\n                x >>= 2;\n                x &= 0xffffff;\n                /* Only reached if blx is avail and it is a call */\n                if (is_thumb) {\n                    x |= h << 24;\n                    (*(int *)ptr) = 0xfa << 24; /* bl -> blx */\n                }\n                (*(int *) ptr) |= x;\n            }\n            return;\n        /* Since these relocations only concern Thumb-2 and blx instruction was\n           introduced before Thumb-2, we can assume blx is available and not\n           guard its use */\n        case R_ARM_THM_PC22:\n        case R_ARM_THM_JUMP24:\n            {\n                int x, hi, lo, s, j1, j2, i1, i2, imm10, imm11;\n                int to_thumb, is_call, to_plt, blx_bit = 1 << 12;\n                Section *plt;\n\n                /* weak reference */\n                if (sym->st_shndx == SHN_UNDEF &&\n                    ELFW(ST_BIND)(sym->st_info) == STB_WEAK)\n                    return;\n\n                /* Get initial offset */\n                hi = (*(uint16_t *)ptr);\n                lo = (*(uint16_t *)(ptr+2));\n                s = (hi >> 10) & 1;\n                j1 = (lo >> 13) & 1;\n                j2 = (lo >> 11) & 1;\n                i1 = (j1 ^ s) ^ 1;\n                i2 = (j2 ^ s) ^ 1;\n                imm10 = hi & 0x3ff;\n                imm11 = lo & 0x7ff;\n                x = (s << 24) | (i1 << 23) | (i2 << 22) |\n                    (imm10 << 12) | (imm11 << 1);\n                if (x & 0x01000000)\n                    x -= 0x02000000;\n\n                /* Relocation infos */\n                to_thumb = val & 1;\n                plt = s1->plt;\n                to_plt = (val >= plt->sh_addr) &&\n                         (val < plt->sh_addr + plt->data_offset);\n                is_call = (type == R_ARM_THM_PC22);\n\n                if (!to_thumb && !to_plt && !is_call) {\n                    int index;\n                    uint8_t *p;\n                    char *name, buf[1024];\n                    Section *text;\n\n                    name = (char *) symtab_section->link->data + sym->st_name;\n                    text = s1->sections[sym->st_shndx];\n                    /* Modify reloc to target a thumb stub to switch to ARM */\n                    snprintf(buf, sizeof(buf), \"%s_from_thumb\", name);\n                    index = put_elf_sym(symtab_section,\n                                        text->data_offset + 1,\n                                        sym->st_size, sym->st_info, 0,\n                                        sym->st_shndx, buf);\n                    to_thumb = 1;\n                    val = text->data_offset + 1;\n                    rel->r_info = ELFW(R_INFO)(index, type);\n                    /* Create a thumb stub function to switch to ARM mode */\n                    put_elf_reloc(symtab_section, text,\n                                  text->data_offset + 4, R_ARM_JUMP24,\n                                  sym_index);\n                    p = section_ptr_add(text, 8);\n                    write32le(p,   0x4778); /* bx pc */\n                    write32le(p+2, 0x46c0); /* nop   */\n                    write32le(p+4, 0xeafffffe); /* b $sym */\n                }\n\n                /* Compute final offset */\n                x += val - addr;\n                if (!to_thumb && is_call) {\n                    blx_bit = 0; /* bl -> blx */\n                    x = (x + 3) & -4; /* Compute offset from aligned PC */\n                }\n\n                /* Check that relocation is possible\n                   * offset must not be out of range\n                   * if target is to be entered in arm mode:\n                     - bit 1 must not set\n                     - instruction must be a call (bl) or a jump to PLT */\n                if (!to_thumb || x >= 0x1000000 || x < -0x1000000)\n                    if (to_thumb || (val & 2) || (!is_call && !to_plt))\n                        tcc_error_noabort(\"can't relocate value at %x,%d\",addr, type);\n\n                /* Compute and store final offset */\n                s = (x >> 24) & 1;\n                i1 = (x >> 23) & 1;\n                i2 = (x >> 22) & 1;\n                j1 = s ^ (i1 ^ 1);\n                j2 = s ^ (i2 ^ 1);\n                imm10 = (x >> 12) & 0x3ff;\n                imm11 = (x >> 1) & 0x7ff;\n                (*(uint16_t *)ptr) = (uint16_t) ((hi & 0xf800) |\n                                     (s << 10) | imm10);\n                (*(uint16_t *)(ptr+2)) = (uint16_t) ((lo & 0xc000) |\n                                (j1 << 13) | blx_bit | (j2 << 11) |\n                                imm11);\n            }\n            return;\n        case R_ARM_MOVT_ABS:\n        case R_ARM_MOVW_ABS_NC:\n            {\n                int x, imm4, imm12;\n                if (type == R_ARM_MOVT_ABS)\n                    val >>= 16;\n                imm12 = val & 0xfff;\n                imm4 = (val >> 12) & 0xf;\n                x = (imm4 << 16) | imm12;\n                if (type == R_ARM_THM_MOVT_ABS)\n                    *(int *)ptr |= x;\n                else\n                    *(int *)ptr += x;\n            }\n            return;\n        case R_ARM_MOVT_PREL:\n        case R_ARM_MOVW_PREL_NC:\n            {\n\t\tint insn = *(int *)ptr;\n                int addend = ((insn >> 4) & 0xf000) | (insn & 0xfff);\n\n\t\taddend = (addend ^ 0x8000) - 0x8000;\n\t\tval += addend - addr;\n\t\tif (type == R_ARM_MOVT_PREL)\n\t\t    val >>= 16;\n\t\t*(int *)ptr = (insn & 0xfff0f000) |\n\t\t\t      ((val & 0xf000) << 4) | (val & 0xfff);\n            }\n            return;\n        case R_ARM_THM_MOVT_ABS:\n        case R_ARM_THM_MOVW_ABS_NC:\n            {\n                int x, i, imm4, imm3, imm8;\n                if (type == R_ARM_THM_MOVT_ABS)\n                    val >>= 16;\n                imm8 = val & 0xff;\n                imm3 = (val >> 8) & 0x7;\n                i = (val >> 11) & 1;\n                imm4 = (val >> 12) & 0xf;\n                x = (imm3 << 28) | (imm8 << 16) | (i << 10) | imm4;\n                if (type == R_ARM_THM_MOVT_ABS)\n                    *(int *)ptr |= x;\n                else\n                    *(int *)ptr += x;\n            }\n            return;\n        case R_ARM_PREL31:\n            {\n                int x;\n                x = (*(int *)ptr) & 0x7fffffff;\n                (*(int *)ptr) &= 0x80000000;\n                x = (x * 2) / 2;\n                x += val - addr;\n                if((x^(x>>1))&0x40000000)\n                    tcc_error_noabort(\"can't relocate value at %x,%d\",addr, type);\n                (*(int *)ptr) |= x & 0x7fffffff;\n            }\n            return;\n        case R_ARM_ABS32:\n        case R_ARM_TARGET1:\n            if (s1->output_type & TCC_OUTPUT_DYN) {\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                qrel->r_offset = rel->r_offset;\n                if (esym_index) {\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_ARM_ABS32);\n                    qrel++;\n                    return;\n                } else {\n                    qrel->r_info = ELFW(R_INFO)(0, R_ARM_RELATIVE);\n                    qrel++;\n                }\n            }\n            *(int *)ptr += val;\n            return;\n        case R_ARM_REL32:\n            *(int *)ptr += val - addr;\n            return;\n        case R_ARM_GOTPC:\n            *(int *)ptr += s1->got->sh_addr - addr;\n            return;\n        case R_ARM_GOTOFF:\n            *(int *)ptr += val - s1->got->sh_addr;\n            return;\n        case R_ARM_GOT32:\n            /* we load the got offset */\n            *(int *)ptr += get_sym_attr(s1, sym_index, 0)->got_offset;\n            return;\n\tcase R_ARM_GOT_PREL:\n            /* we load the pc relative got offset */\n            *(int *)ptr += s1->got->sh_addr +\n\t\t\t   get_sym_attr(s1, sym_index, 0)->got_offset -\n\t\t\t   addr;\n            return;\n        case R_ARM_COPY:\n            return;\n        case R_ARM_V4BX:\n            /* trade Thumb support for ARMv4 support */\n            if ((0x0ffffff0 & *(int*)ptr) == 0x012FFF10)\n                *(int*)ptr ^= 0xE12FFF10 ^ 0xE1A0F000; /* BX Rm -> MOV PC, Rm */\n            return;\n        case R_ARM_GLOB_DAT:\n        case R_ARM_JUMP_SLOT:\n            *(addr_t *)ptr = val;\n            return;\n        case R_ARM_NONE:\n            /* Nothing to do.  Normally used to indicate a dependency\n               on a certain symbol (like for exception handling under EABI).  */\n            return;\n        case R_ARM_RELATIVE:\n#ifdef TCC_TARGET_PE\n            add32le(ptr, val - s1->pe_imagebase);\n#endif\n            /* do nothing */\n            return;\n        default:\n            fprintf(stderr,\"FIXME: handle reloc type %d at %x [%p] to %x\\n\",\n                type, (unsigned)addr, ptr, (unsigned)val);\n            return;\n    }\n}\n\n#endif /* !TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "arm-tok.h",
          "type": "blob",
          "size": 9.0439453125,
          "content": "/* ------------------------------------------------------------------ */\n/* WARNING: relative order of tokens is important.                    */\n\n/* register */\n\n DEF_ASM(r0)\n DEF_ASM(r1)\n DEF_ASM(r2)\n DEF_ASM(r3)\n DEF_ASM(r4)\n DEF_ASM(r5)\n DEF_ASM(r6)\n DEF_ASM(r7)\n DEF_ASM(r8)\n DEF_ASM(r9)\n DEF_ASM(r10)\n DEF_ASM(r11) /* fp */\n DEF_ASM(r12) /* ip[c] */\n DEF_ASM(r13) /* sp */\n DEF_ASM(r14) /* lr */\n DEF_ASM(r15) /* pc */\n\n/* register macros */\n\n DEF_ASM(fp) /* alias for r11 */\n DEF_ASM(ip) /* alias for r12 */\n DEF_ASM(sp) /* alias for r13 */\n DEF_ASM(lr) /* alias for r14 */\n DEF_ASM(pc) /* alias for r15 */\n\n /* coprocessors */\n\n DEF_ASM(p0)\n DEF_ASM(p1)\n DEF_ASM(p2)\n DEF_ASM(p3)\n DEF_ASM(p4)\n DEF_ASM(p5)\n DEF_ASM(p6)\n DEF_ASM(p7)\n DEF_ASM(p8)\n DEF_ASM(p9)\n DEF_ASM(p10)\n DEF_ASM(p11)\n DEF_ASM(p12)\n DEF_ASM(p13)\n DEF_ASM(p14)\n DEF_ASM(p15)\n\n /* coprocessor registers */\n\n DEF_ASM(c0)\n DEF_ASM(c1)\n DEF_ASM(c2)\n DEF_ASM(c3)\n DEF_ASM(c4)\n DEF_ASM(c5)\n DEF_ASM(c6)\n DEF_ASM(c7)\n DEF_ASM(c8)\n DEF_ASM(c9)\n DEF_ASM(c10)\n DEF_ASM(c11)\n DEF_ASM(c12)\n DEF_ASM(c13)\n DEF_ASM(c14)\n DEF_ASM(c15)\n\n /* single-precision VFP registers */\n\n DEF_ASM(s0)\n DEF_ASM(s1)\n DEF_ASM(s2)\n DEF_ASM(s3)\n DEF_ASM(s4)\n DEF_ASM(s5)\n DEF_ASM(s6)\n DEF_ASM(s7)\n DEF_ASM(s8)\n DEF_ASM(s9)\n DEF_ASM(s10)\n DEF_ASM(s11)\n DEF_ASM(s12)\n DEF_ASM(s13)\n DEF_ASM(s14)\n DEF_ASM(s15)\n DEF_ASM(s16)\n DEF_ASM(s17)\n DEF_ASM(s18)\n DEF_ASM(s19)\n DEF_ASM(s20)\n DEF_ASM(s21)\n DEF_ASM(s22)\n DEF_ASM(s23)\n DEF_ASM(s24)\n DEF_ASM(s25)\n DEF_ASM(s26)\n DEF_ASM(s27)\n DEF_ASM(s28)\n DEF_ASM(s29)\n DEF_ASM(s30)\n DEF_ASM(s31)\n\n /* double-precision VFP registers */\n\n DEF_ASM(d0)\n DEF_ASM(d1)\n DEF_ASM(d2)\n DEF_ASM(d3)\n DEF_ASM(d4)\n DEF_ASM(d5)\n DEF_ASM(d6)\n DEF_ASM(d7)\n DEF_ASM(d8)\n DEF_ASM(d9)\n DEF_ASM(d10)\n DEF_ASM(d11)\n DEF_ASM(d12)\n DEF_ASM(d13)\n DEF_ASM(d14)\n DEF_ASM(d15)\n\n /* VFP status registers */\n\n DEF_ASM(fpsid)\n DEF_ASM(fpscr)\n DEF_ASM(fpexc)\n\n /* VFP magical ARM register */\n\n DEF_ASM(apsr_nzcv)\n\n /* data processing directives */\n\n DEF_ASM(asl)\n\n /* instructions that have no condition code */\n\n DEF_ASM(cdp2)\n DEF_ASM(ldc2)\n DEF_ASM(ldc2l)\n DEF_ASM(stc2)\n DEF_ASM(stc2l)\n\n#define ARM_INSTRUCTION_GROUP(tok) ((((tok) - TOK_ASM_nopeq) & 0xFFFFFFF0) + TOK_ASM_nopeq)\n\n/* Note: condition code is 4 bits */\n#define DEF_ASM_CONDED(x) \\\n  DEF(TOK_ASM_ ## x ## eq, #x \"eq\") \\\n  DEF(TOK_ASM_ ## x ## ne, #x \"ne\") \\\n  DEF(TOK_ASM_ ## x ## cs, #x \"cs\") \\\n  DEF(TOK_ASM_ ## x ## cc, #x \"cc\") \\\n  DEF(TOK_ASM_ ## x ## mi, #x \"mi\") \\\n  DEF(TOK_ASM_ ## x ## pl, #x \"pl\") \\\n  DEF(TOK_ASM_ ## x ## vs, #x \"vs\") \\\n  DEF(TOK_ASM_ ## x ## vc, #x \"vc\") \\\n  DEF(TOK_ASM_ ## x ## hi, #x \"hi\") \\\n  DEF(TOK_ASM_ ## x ## ls, #x \"ls\") \\\n  DEF(TOK_ASM_ ## x ## ge, #x \"ge\") \\\n  DEF(TOK_ASM_ ## x ## lt, #x \"lt\") \\\n  DEF(TOK_ASM_ ## x ## gt, #x \"gt\") \\\n  DEF(TOK_ASM_ ## x ## le, #x \"le\") \\\n  DEF(TOK_ASM_ ## x, #x) \\\n  DEF(TOK_ASM_ ## x ## rsvd, #x \"rsvd\")\n\n/* Note: condition code is 4 bits */\n#define DEF_ASM_CONDED_WITH_SUFFIX(x, y) \\\n  DEF(TOK_ASM_ ## x ## eq ## _ ## y, #x \"eq.\" #y) \\\n  DEF(TOK_ASM_ ## x ## ne ## _ ## y, #x \"ne.\" #y) \\\n  DEF(TOK_ASM_ ## x ## cs ## _ ## y, #x \"cs.\" #y) \\\n  DEF(TOK_ASM_ ## x ## cc ## _ ## y, #x \"cc.\" #y) \\\n  DEF(TOK_ASM_ ## x ## mi ## _ ## y, #x \"mi.\" #y) \\\n  DEF(TOK_ASM_ ## x ## pl ## _ ## y, #x \"pl.\" #y) \\\n  DEF(TOK_ASM_ ## x ## vs ## _ ## y, #x \"vs.\" #y) \\\n  DEF(TOK_ASM_ ## x ## vc ## _ ## y, #x \"vc.\" #y) \\\n  DEF(TOK_ASM_ ## x ## hi ## _ ## y, #x \"hi.\" #y) \\\n  DEF(TOK_ASM_ ## x ## ls ## _ ## y, #x \"ls.\" #y) \\\n  DEF(TOK_ASM_ ## x ## ge ## _ ## y, #x \"ge.\" #y) \\\n  DEF(TOK_ASM_ ## x ## lt ## _ ## y, #x \"lt.\" #y) \\\n  DEF(TOK_ASM_ ## x ## gt ## _ ## y, #x \"gt.\" #y) \\\n  DEF(TOK_ASM_ ## x ## le ## _ ## y, #x \"le.\" #y) \\\n  DEF(TOK_ASM_ ## x ## _ ## y, #x \".\" #y) \\\n  DEF(TOK_ASM_ ## x ## rsvd ## _ ## y, #x \"rsvd.\" #y)\n\n#define DEF_ASM_CONDED_VFP_F32_F64(x) \\\n  DEF_ASM_CONDED_WITH_SUFFIX(x, f32) \\\n  DEF_ASM_CONDED_WITH_SUFFIX(x, f64)\n\n#define DEF_ASM_CONDED_WITH_TWO_SUFFIXES(x, y, z) \\\n  DEF(TOK_ASM_ ## x ## eq ## _ ## y ## _ ## z, #x \"eq.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## ne ## _ ## y ## _ ## z, #x \"ne.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## cs ## _ ## y ## _ ## z, #x \"cs.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## cc ## _ ## y ## _ ## z, #x \"cc.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## mi ## _ ## y ## _ ## z, #x \"mi.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## pl ## _ ## y ## _ ## z, #x \"pl.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## vs ## _ ## y ## _ ## z, #x \"vs.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## vc ## _ ## y ## _ ## z, #x \"vc.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## hi ## _ ## y ## _ ## z, #x \"hi.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## ls ## _ ## y ## _ ## z, #x \"ls.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## ge ## _ ## y ## _ ## z, #x \"ge.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## lt ## _ ## y ## _ ## z, #x \"lt.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## gt ## _ ## y ## _ ## z, #x \"gt.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## le ## _ ## y ## _ ## z, #x \"le.\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## _ ## y ## _ ## z, #x \".\" #y \".\" #z) \\\n  DEF(TOK_ASM_ ## x ## rsvd ## _ ## y ## _ ## z, #x \"rsvd.\" #y \".\" #z)\n\n/* Note: add new tokens after nop (MUST always use DEF_ASM_CONDED) */\n\n DEF_ASM_CONDED(nop)\n DEF_ASM_CONDED(wfe)\n DEF_ASM_CONDED(wfi)\n DEF_ASM_CONDED(swi)\n DEF_ASM_CONDED(svc)\n\n /* misc */\n DEF_ASM_CONDED(clz)\n\n /* size conversion */\n\n DEF_ASM_CONDED(sxtb)\n DEF_ASM_CONDED(sxth)\n DEF_ASM_CONDED(uxtb)\n DEF_ASM_CONDED(uxth)\n DEF_ASM_CONDED(movt)\n DEF_ASM_CONDED(movw)\n\n /* multiplication */\n\n DEF_ASM_CONDED(mul)\n DEF_ASM_CONDED(muls)\n DEF_ASM_CONDED(mla)\n DEF_ASM_CONDED(mlas)\n DEF_ASM_CONDED(smull)\n DEF_ASM_CONDED(smulls)\n DEF_ASM_CONDED(umull)\n DEF_ASM_CONDED(umulls)\n DEF_ASM_CONDED(smlal)\n DEF_ASM_CONDED(smlals)\n DEF_ASM_CONDED(umlal)\n DEF_ASM_CONDED(umlals)\n\n /* load/store */\n\n DEF_ASM_CONDED(ldr)\n DEF_ASM_CONDED(ldrb)\n DEF_ASM_CONDED(str)\n DEF_ASM_CONDED(strb)\n DEF_ASM_CONDED(ldrex)\n DEF_ASM_CONDED(ldrexb)\n DEF_ASM_CONDED(strex)\n DEF_ASM_CONDED(strexb)\n DEF_ASM_CONDED(ldrh)\n DEF_ASM_CONDED(ldrsh)\n DEF_ASM_CONDED(ldrsb)\n DEF_ASM_CONDED(strh)\n\n DEF_ASM_CONDED(stmda)\n DEF_ASM_CONDED(ldmda)\n DEF_ASM_CONDED(stm)\n DEF_ASM_CONDED(ldm)\n DEF_ASM_CONDED(stmia)\n DEF_ASM_CONDED(ldmia)\n DEF_ASM_CONDED(stmdb)\n DEF_ASM_CONDED(ldmdb)\n DEF_ASM_CONDED(stmib)\n DEF_ASM_CONDED(ldmib)\n\n DEF_ASM_CONDED(ldc)\n DEF_ASM_CONDED(ldcl)\n DEF_ASM_CONDED(stc)\n DEF_ASM_CONDED(stcl)\n\n /* instruction macros */\n\n DEF_ASM_CONDED(push)\n DEF_ASM_CONDED(pop)\n\n /* branches */\n\n DEF_ASM_CONDED(b)\n DEF_ASM_CONDED(bl)\n DEF_ASM_CONDED(bx)\n DEF_ASM_CONDED(blx)\n\n /* data processing instructions; order is important */\n\n DEF_ASM_CONDED(and)\n DEF_ASM_CONDED(ands)\n DEF_ASM_CONDED(eor)\n DEF_ASM_CONDED(eors)\n DEF_ASM_CONDED(sub)\n DEF_ASM_CONDED(subs)\n DEF_ASM_CONDED(rsb)\n DEF_ASM_CONDED(rsbs)\n DEF_ASM_CONDED(add)\n DEF_ASM_CONDED(adds)\n DEF_ASM_CONDED(adc)\n DEF_ASM_CONDED(adcs)\n DEF_ASM_CONDED(sbc)\n DEF_ASM_CONDED(sbcs)\n DEF_ASM_CONDED(rsc)\n DEF_ASM_CONDED(rscs)\n DEF_ASM_CONDED(tst)\n DEF_ASM_CONDED(tsts) // necessary here--but not useful to the user\n DEF_ASM_CONDED(teq)\n DEF_ASM_CONDED(teqs) // necessary here--but not useful to the user\n DEF_ASM_CONDED(cmp)\n DEF_ASM_CONDED(cmps) // necessary here--but not useful to the user\n DEF_ASM_CONDED(cmn)\n DEF_ASM_CONDED(cmns) // necessary here--but not useful to the user\n DEF_ASM_CONDED(orr)\n DEF_ASM_CONDED(orrs)\n DEF_ASM_CONDED(mov)\n DEF_ASM_CONDED(movs)\n DEF_ASM_CONDED(bic)\n DEF_ASM_CONDED(bics)\n DEF_ASM_CONDED(mvn)\n DEF_ASM_CONDED(mvns)\n\n DEF_ASM_CONDED(lsl)\n DEF_ASM_CONDED(lsls)\n DEF_ASM_CONDED(lsr)\n DEF_ASM_CONDED(lsrs)\n DEF_ASM_CONDED(asr)\n DEF_ASM_CONDED(asrs)\n DEF_ASM_CONDED(ror)\n DEF_ASM_CONDED(rors)\n DEF_ASM_CONDED(rrx)\n DEF_ASM_CONDED(rrxs)\n\n DEF_ASM_CONDED(cdp)\n DEF_ASM_CONDED(mcr)\n DEF_ASM_CONDED(mrc)\n\n // Floating point high-level instructions\n\n DEF_ASM_CONDED(vldr)\n DEF_ASM_CONDED(vstr)\n\n DEF_ASM_CONDED_VFP_F32_F64(vmla)\n DEF_ASM_CONDED_VFP_F32_F64(vmls)\n DEF_ASM_CONDED_VFP_F32_F64(vnmls)\n DEF_ASM_CONDED_VFP_F32_F64(vnmla)\n DEF_ASM_CONDED_VFP_F32_F64(vmul)\n DEF_ASM_CONDED_VFP_F32_F64(vnmul)\n DEF_ASM_CONDED_VFP_F32_F64(vadd)\n DEF_ASM_CONDED_VFP_F32_F64(vsub)\n DEF_ASM_CONDED_VFP_F32_F64(vdiv)\n DEF_ASM_CONDED_VFP_F32_F64(vneg)\n DEF_ASM_CONDED_VFP_F32_F64(vabs)\n DEF_ASM_CONDED_VFP_F32_F64(vsqrt)\n DEF_ASM_CONDED_VFP_F32_F64(vcmp)\n DEF_ASM_CONDED_VFP_F32_F64(vcmpe)\n DEF_ASM_CONDED_VFP_F32_F64(vmov)\n\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvtr, s32, f64)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvtr, s32, f32)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvtr, u32, f64)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvtr, u32, f32)\n\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, s32, f64)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, s32, f32)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, u32, f64)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, u32, f32)\n\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, f64, s32)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, f32, s32)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, f64, u32)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, f32, u32)\n\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, f64, f32)\n DEF_ASM_CONDED_WITH_TWO_SUFFIXES(vcvt, f32, f64)\n\n DEF_ASM_CONDED(vpush)\n DEF_ASM_CONDED(vpop)\n DEF_ASM_CONDED(vldm)\n DEF_ASM_CONDED(vldmia)\n DEF_ASM_CONDED(vldmdb)\n DEF_ASM_CONDED(vstm)\n DEF_ASM_CONDED(vstmia)\n DEF_ASM_CONDED(vstmdb)\n DEF_ASM_CONDED(vmsr)\n DEF_ASM_CONDED(vmrs)\n"
        },
        {
          "name": "arm64-asm.c",
          "type": "blob",
          "size": 1.890625,
          "content": "/*************************************************************/\n/*\n *  ARM64 dummy assembler for TCC\n *\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n#define CONFIG_TCC_ASM\n#define NB_ASM_REGS 16\n\nST_FUNC void g(int c);\nST_FUNC void gen_le16(int c);\nST_FUNC void gen_le32(int c);\n\n/*************************************************************/\n#else\n/*************************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n\nstatic void asm_error(void)\n{\n    tcc_error(\"ARM asm not implemented.\");\n}\n\n/* XXX: make it faster ? */\nST_FUNC void g(int c)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 1;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c;\n    ind = ind1;\n}\n\nST_FUNC void gen_le16 (int i)\n{\n    g(i);\n    g(i>>8);\n}\n\nST_FUNC void gen_le32 (int i)\n{\n    gen_le16(i);\n    gen_le16(i>>16);\n}\n\nST_FUNC void gen_expr32(ExprValue *pe)\n{\n    gen_le32(pe->v);\n}\n\nST_FUNC void asm_opcode(TCCState *s1, int opcode)\n{\n    asm_error();\n}\n\nST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier)\n{\n    asm_error();\n}\n\n/* generate prolog and epilog code for asm statement */\nST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands,\n                         int nb_outputs, int is_output,\n                         uint8_t *clobber_regs,\n                         int out_reg)\n{\n}\n\nST_FUNC void asm_compute_constraints(ASMOperand *operands,\n                                    int nb_operands, int nb_outputs,\n                                    const uint8_t *clobber_regs,\n                                    int *pout_reg)\n{\n}\n\nST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str)\n{\n    asm_error();\n}\n\nST_FUNC int asm_parse_regvar (int t)\n{\n    asm_error();\n    return -1;\n}\n\n/*************************************************************/\n#endif /* ndef TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "arm64-gen.c",
          "type": "blob",
          "size": 63.779296875,
          "content": "/*\n *  A64 code generator for TCC\n *\n *  Copyright (c) 2014-2015 Edmund Grimley Evans\n *\n * Copying and distribution of this file, with or without modification,\n * are permitted in any medium without royalty provided the copyright\n * notice and this notice are preserved.  This file is offered as-is,\n * without any warranty.\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n// Number of registers available to allocator:\n#define NB_REGS 28 // x0-x18, x30, v0-v7\n\n#define TREG_R(x) (x) // x = 0..18\n#define TREG_R30  19\n#define TREG_F(x) (x + 20) // x = 0..7\n\n// Register classes sorted from more general to more precise:\n#define RC_INT (1 << 0)\n#define RC_FLOAT (1 << 1)\n#define RC_R(x) (1 << (2 + (x))) // x = 0..18\n#define RC_R30  (1 << 21)\n#define RC_F(x) (1 << (22 + (x))) // x = 0..7\n\n#define RC_IRET (RC_R(0)) // int return register class\n#define RC_FRET (RC_F(0)) // float return register class\n\n#define REG_IRET (TREG_R(0)) // int return register number\n#define REG_FRET (TREG_F(0)) // float return register number\n\n#define PTR_SIZE 8\n\n#define LDOUBLE_SIZE 16\n#define LDOUBLE_ALIGN 16\n\n#define MAX_ALIGN 16\n\n#ifndef TCC_TARGET_MACHO\n#define CHAR_IS_UNSIGNED\n#endif\n\n/* define if return values need to be extended explicitely\n   at caller side (for interfacing with non-TCC compilers) */\n#define PROMOTE_RET\n/******************************************************/\n#else /* ! TARGET_DEFS_ONLY */\n/******************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n#include <assert.h>\n\nST_DATA const char * const target_machine_defs =\n    \"__aarch64__\\0\"\n#if defined(TCC_TARGET_MACHO)\n    \"__arm64__\\0\"\n#endif\n    \"__AARCH64EL__\\0\"\n    ;\n\nST_DATA const int reg_classes[NB_REGS] = {\n  RC_INT | RC_R(0),\n  RC_INT | RC_R(1),\n  RC_INT | RC_R(2),\n  RC_INT | RC_R(3),\n  RC_INT | RC_R(4),\n  RC_INT | RC_R(5),\n  RC_INT | RC_R(6),\n  RC_INT | RC_R(7),\n  RC_INT | RC_R(8),\n  RC_INT | RC_R(9),\n  RC_INT | RC_R(10),\n  RC_INT | RC_R(11),\n  RC_INT | RC_R(12),\n  RC_INT | RC_R(13),\n  RC_INT | RC_R(14),\n  RC_INT | RC_R(15),\n  RC_INT | RC_R(16),\n  RC_INT | RC_R(17),\n  RC_INT | RC_R(18),\n  RC_R30, // not in RC_INT as we make special use of x30\n  RC_FLOAT | RC_F(0),\n  RC_FLOAT | RC_F(1),\n  RC_FLOAT | RC_F(2),\n  RC_FLOAT | RC_F(3),\n  RC_FLOAT | RC_F(4),\n  RC_FLOAT | RC_F(5),\n  RC_FLOAT | RC_F(6),\n  RC_FLOAT | RC_F(7)\n};\n\n#if defined(CONFIG_TCC_BCHECK)\nstatic addr_t func_bound_offset;\nstatic unsigned long func_bound_ind;\nST_DATA int func_bound_add_epilog;\n#endif\n\n#define IS_FREG(x) ((x) >= TREG_F(0))\n\nstatic uint32_t intr(int r)\n{\n    assert(TREG_R(0) <= r && r <= TREG_R30);\n    return r < TREG_R30 ? r : 30;\n}\n\nstatic uint32_t fltr(int r)\n{\n    assert(TREG_F(0) <= r && r <= TREG_F(7));\n    return r - TREG_F(0);\n}\n\n// Add an instruction to text section:\nST_FUNC void o(unsigned int c)\n{\n    int ind1 = ind + 4;\n    if (nocode_wanted)\n        return;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    write32le(cur_text_section->data + ind, c);\n    ind = ind1;\n}\n\nstatic int arm64_encode_bimm64(uint64_t x)\n{\n    int neg = x & 1;\n    int rep, pos, len;\n\n    if (neg)\n        x = ~x;\n    if (!x)\n        return -1;\n\n    if (x >> 2 == (x & (((uint64_t)1 << (64 - 2)) - 1)))\n        rep = 2, x &= ((uint64_t)1 << 2) - 1;\n    else if (x >> 4 == (x & (((uint64_t)1 << (64 - 4)) - 1)))\n        rep = 4, x &= ((uint64_t)1 <<  4) - 1;\n    else if (x >> 8 == (x & (((uint64_t)1 << (64 - 8)) - 1)))\n        rep = 8, x &= ((uint64_t)1 <<  8) - 1;\n    else if (x >> 16 == (x & (((uint64_t)1 << (64 - 16)) - 1)))\n        rep = 16, x &= ((uint64_t)1 << 16) - 1;\n    else if (x >> 32 == (x & (((uint64_t)1 << (64 - 32)) - 1)))\n        rep = 32, x &= ((uint64_t)1 << 32) - 1;\n    else\n        rep = 64;\n\n    pos = 0;\n    if (!(x & (((uint64_t)1 << 32) - 1))) x >>= 32, pos += 32;\n    if (!(x & (((uint64_t)1 << 16) - 1))) x >>= 16, pos += 16;\n    if (!(x & (((uint64_t)1 <<  8) - 1))) x >>= 8, pos += 8;\n    if (!(x & (((uint64_t)1 <<  4) - 1))) x >>= 4, pos += 4;\n    if (!(x & (((uint64_t)1 <<  2) - 1))) x >>= 2, pos += 2;\n    if (!(x & (((uint64_t)1 <<  1) - 1))) x >>= 1, pos += 1;\n\n    len = 0;\n    if (!(~x & (((uint64_t)1 << 32) - 1))) x >>= 32, len += 32;\n    if (!(~x & (((uint64_t)1 << 16) - 1))) x >>= 16, len += 16;\n    if (!(~x & (((uint64_t)1 << 8) - 1))) x >>= 8, len += 8;\n    if (!(~x & (((uint64_t)1 << 4) - 1))) x >>= 4, len += 4;\n    if (!(~x & (((uint64_t)1 << 2) - 1))) x >>= 2, len += 2;\n    if (!(~x & (((uint64_t)1 << 1) - 1))) x >>= 1, len += 1;\n\n    if (x)\n        return -1;\n    if (neg) {\n        pos = (pos + len) & (rep - 1);\n        len = rep - len;\n    }\n    return ((0x1000 & rep << 6) | (((rep - 1) ^ 31) << 1 & 63) |\n            ((rep - pos) & (rep - 1)) << 6 | (len - 1));\n}\n\nstatic uint32_t arm64_movi(int r, uint64_t x)\n{\n    uint64_t m = 0xffff;\n    int e;\n    if (!(x & ~m))\n        return 0x52800000 | r | x << 5; // movz w(r),#(x)\n    if (!(x & ~(m << 16)))\n        return 0x52a00000 | r | x >> 11; // movz w(r),#(x >> 16),lsl #16\n    if (!(x & ~(m << 32)))\n        return 0xd2c00000 | r | x >> 27; // movz x(r),#(x >> 32),lsl #32\n    if (!(x & ~(m << 48)))\n        return 0xd2e00000 | r | x >> 43; // movz x(r),#(x >> 48),lsl #48\n    if ((x & ~m) == m << 16)\n        return (0x12800000 | r |\n                (~x << 5 & 0x1fffe0)); // movn w(r),#(~x)\n    if ((x & ~(m << 16)) == m)\n        return (0x12a00000 | r |\n                (~x >> 11 & 0x1fffe0)); // movn w(r),#(~x >> 16),lsl #16\n    if (!~(x | m))\n        return (0x92800000 | r |\n                (~x << 5 & 0x1fffe0)); // movn x(r),#(~x)\n    if (!~(x | m << 16))\n        return (0x92a00000 | r |\n                (~x >> 11 & 0x1fffe0)); // movn x(r),#(~x >> 16),lsl #16\n    if (!~(x | m << 32))\n        return (0x92c00000 | r |\n                (~x >> 27 & 0x1fffe0)); // movn x(r),#(~x >> 32),lsl #32\n    if (!~(x | m << 48))\n        return (0x92e00000 | r |\n                (~x >> 43 & 0x1fffe0)); // movn x(r),#(~x >> 32),lsl #32\n    if (!(x >> 32) && (e = arm64_encode_bimm64(x | x << 32)) >= 0)\n        return 0x320003e0 | r | (uint32_t)e << 10; // movi w(r),#(x)\n    if ((e = arm64_encode_bimm64(x)) >= 0)\n        return 0xb20003e0 | r | (uint32_t)e << 10; // movi x(r),#(x)\n    return 0;\n}\n\nstatic void arm64_movimm(int r, uint64_t x)\n{\n    uint32_t i;\n    if ((i = arm64_movi(r, x)))\n        o(i); // a single MOV\n    else {\n        // MOVZ/MOVN and 1-3 MOVKs\n        int z = 0, m = 0;\n        uint32_t mov1 = 0xd2800000; // movz\n        uint64_t x1 = x;\n        for (i = 0; i < 64; i += 16) {\n            z += !(x >> i & 0xffff);\n            m += !(~x >> i & 0xffff);\n        }\n        if (m > z) {\n            x1 = ~x;\n            mov1 = 0x92800000; // movn\n        }\n        for (i = 0; i < 64; i += 16)\n            if (x1 >> i & 0xffff) {\n                o(mov1 | r | (x1 >> i & 0xffff) << 5 | i << 17);\n                // movz/movn x(r),#(*),lsl #(i)\n                break;\n            }\n        for (i += 16; i < 64; i += 16)\n            if (x1 >> i & 0xffff)\n                o(0xf2800000 | r | (x >> i & 0xffff) << 5 | i << 17);\n                // movk x(r),#(*),lsl #(i)\n    }\n}\n\n// Patch all branches in list pointed to by t to branch to a:\nST_FUNC void gsym_addr(int t_, int a_)\n{\n    uint32_t t = t_;\n    uint32_t a = a_;\n    while (t) {\n        unsigned char *ptr = cur_text_section->data + t;\n        uint32_t next = read32le(ptr);\n        if (a - t + 0x8000000 >= 0x10000000)\n            tcc_error(\"branch out of range\");\n        write32le(ptr, (a - t == 4 ? 0xd503201f : // nop\n                        0x14000000 | ((a - t) >> 2 & 0x3ffffff))); // b\n        t = next;\n    }\n}\n\nstatic int arm64_type_size(int t)\n{\n    /*\n     * case values are in increasing order (from 1 to 11).\n     * which 'may' help compiler optimizers. See tcc.h\n     */\n    switch (t & VT_BTYPE) {\n    case VT_BYTE: return 0;\n    case VT_SHORT: return 1;\n    case VT_INT: return 2;\n    case VT_LLONG: return 3;\n    case VT_PTR: return 3;\n    case VT_FUNC: return 3;\n    case VT_STRUCT: return 3;\n    case VT_FLOAT: return 2;\n    case VT_DOUBLE: return 3;\n    case VT_LDOUBLE: return 4;\n    case VT_BOOL: return 0;\n    }\n    assert(0);\n    return 0;\n}\n\nstatic void arm64_spoff(int reg, uint64_t off)\n{\n    uint32_t sub = off >> 63;\n    if (sub)\n        off = -off;\n    if (off < 4096)\n        o(0x910003e0 | sub << 30 | reg | off << 10);\n        // (add|sub) x(reg),sp,#(off)\n    else {\n        arm64_movimm(30, off); // use x30 for offset\n        o(0x8b3e63e0 | sub << 30 | reg); // (add|sub) x(reg),sp,x30\n    }\n}\n\n/* invert 0: return value to use for store/load */\n/* invert 1: return value to use for arm64_sym */\nstatic uint64_t arm64_check_offset(int invert, int sz_, uint64_t off)\n{\n    uint32_t sz = sz_;\n    if (!(off & ~((uint32_t)0xfff << sz)) ||\n        (off < 256 || -off <= 256))\n        return invert ? off : 0ul;\n    else if ((off & ((uint32_t)0xfff << sz)))\n        return invert ? off & ((uint32_t)0xfff << sz)\n\t\t      : off & ~((uint32_t)0xfff << sz);\n    else if (off & 0x1ff)\n        return invert ? off & 0x1ff : off & ~0x1ff;\n    else\n        return invert ? 0ul : off;\n}\n\nstatic void arm64_ldrx(int sg, int sz_, int dst, int bas, uint64_t off)\n{\n    uint32_t sz = sz_;\n    if (sz >= 2)\n        sg = 0;\n    if (!(off & ~((uint32_t)0xfff << sz)))\n        o(0x39400000 | dst | bas << 5 | off << (10 - sz) |\n          (uint32_t)!!sg << 23 | sz << 30); // ldr(*) x(dst),[x(bas),#(off)]\n    else if (off < 256 || -off <= 256)\n        o(0x38400000 | dst | bas << 5 | (off & 511) << 12 |\n          (uint32_t)!!sg << 23 | sz << 30); // ldur(*) x(dst),[x(bas),#(off)]\n    else {\n        arm64_movimm(30, off); // use x30 for offset\n        o(0x38206800 | dst | bas << 5 | (uint32_t)30 << 16 |\n          (uint32_t)(!!sg + 1) << 22 | sz << 30); // ldr(*) x(dst),[x(bas),x30]\n    }\n}\n\nstatic void arm64_ldrv(int sz_, int dst, int bas, uint64_t off)\n{\n    uint32_t sz = sz_;\n    if (!(off & ~((uint32_t)0xfff << sz)))\n        o(0x3d400000 | dst | bas << 5 | off << (10 - sz) |\n          (sz & 4) << 21 | (sz & 3) << 30); // ldr (s|d|q)(dst),[x(bas),#(off)]\n    else if (off < 256 || -off <= 256)\n        o(0x3c400000 | dst | bas << 5 | (off & 511) << 12 |\n          (sz & 4) << 21 | (sz & 3) << 30); // ldur (s|d|q)(dst),[x(bas),#(off)]\n    else {\n        arm64_movimm(30, off); // use x30 for offset\n        o(0x3c606800 | dst | bas << 5 | (uint32_t)30 << 16 |\n          sz << 30 | (sz & 4) << 21); // ldr (s|d|q)(dst),[x(bas),x30]\n    }\n}\n\nstatic void arm64_ldrs(int reg_, int size)\n{\n    uint32_t reg = reg_;\n    // Use x30 for intermediate value in some cases.\n    switch (size) {\n    default: assert(0); break;\n    case 0:\n        /* Can happen with zero size structs */\n        break;\n    case 1:\n        arm64_ldrx(0, 0, reg, reg, 0);\n        break;\n    case 2:\n        arm64_ldrx(0, 1, reg, reg, 0);\n        break;\n    case 3:\n        arm64_ldrx(0, 1, 30, reg, 0);\n        arm64_ldrx(0, 0, reg, reg, 2);\n        o(0x2a0043c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #16\n        break;\n    case 4:\n        arm64_ldrx(0, 2, reg, reg, 0);\n        break;\n    case 5:\n        arm64_ldrx(0, 2, 30, reg, 0);\n        arm64_ldrx(0, 0, reg, reg, 4);\n        o(0xaa0083c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #32\n        break;\n    case 6:\n        arm64_ldrx(0, 2, 30, reg, 0);\n        arm64_ldrx(0, 1, reg, reg, 4);\n        o(0xaa0083c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #32\n        break;\n    case 7:\n        arm64_ldrx(0, 2, 30, reg, 0);\n        arm64_ldrx(0, 2, reg, reg, 3);\n        o(0x53087c00 | reg | reg << 5); // lsr w(reg), w(reg), #8\n        o(0xaa0083c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #32\n        break;\n    case 8:\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 9:\n        arm64_ldrx(0, 0, reg + 1, reg, 8);\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 10:\n        arm64_ldrx(0, 1, reg + 1, reg, 8);\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 11:\n        arm64_ldrx(0, 2, reg + 1, reg, 7);\n        o(0x53087c00 | (reg+1) | (reg+1) << 5); // lsr w(reg+1), w(reg+1), #8\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 12:\n        arm64_ldrx(0, 2, reg + 1, reg, 8);\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 13:\n        arm64_ldrx(0, 3, reg + 1, reg, 5);\n        o(0xd358fc00 | (reg+1) | (reg+1) << 5); // lsr x(reg+1), x(reg+1), #24\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 14:\n        arm64_ldrx(0, 3, reg + 1, reg, 6);\n        o(0xd350fc00 | (reg+1) | (reg+1) << 5); // lsr x(reg+1), x(reg+1), #16\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 15:\n        arm64_ldrx(0, 3, reg + 1, reg, 7);\n        o(0xd348fc00 | (reg+1) | (reg+1) << 5); // lsr x(reg+1), x(reg+1), #8\n        arm64_ldrx(0, 3, reg, reg, 0);\n        break;\n    case 16:\n        o(0xa9400000 | reg | (reg+1) << 10 | reg << 5);\n        // ldp x(reg),x(reg+1),[x(reg)]\n        break;\n    }\n}\n\nstatic void arm64_strx(int sz_, int dst, int bas, uint64_t off)\n{\n    uint32_t sz = sz_;\n    if (!(off & ~((uint32_t)0xfff << sz)))\n        o(0x39000000 | dst | bas << 5 | off << (10 - sz) | sz << 30);\n        // str(*) x(dst),[x(bas],#(off)]\n    else if (off < 256 || -off <= 256)\n        o(0x38000000 | dst | bas << 5 | (off & 511) << 12 | sz << 30);\n        // stur(*) x(dst),[x(bas],#(off)]\n    else {\n        arm64_movimm(30, off); // use x30 for offset\n        o(0x38206800 | dst | bas << 5 | (uint32_t)30 << 16 | sz << 30);\n        // str(*) x(dst),[x(bas),x30]\n    }\n}\n\nstatic void arm64_strv(int sz_, int dst, int bas, uint64_t off)\n{\n    uint32_t sz = sz_;\n    if (!(off & ~((uint32_t)0xfff << sz)))\n        o(0x3d000000 | dst | bas << 5 | off << (10 - sz) |\n          (sz & 4) << 21 | (sz & 3) << 30); // str (s|d|q)(dst),[x(bas),#(off)]\n    else if (off < 256 || -off <= 256)\n        o(0x3c000000 | dst | bas << 5 | (off & 511) << 12 |\n          (sz & 4) << 21 | (sz & 3) << 30); // stur (s|d|q)(dst),[x(bas),#(off)]\n    else {\n        arm64_movimm(30, off); // use x30 for offset\n        o(0x3c206800 | dst | bas << 5 | (uint32_t)30 << 16 |\n          sz << 30 | (sz & 4) << 21); // str (s|d|q)(dst),[x(bas),x30]\n    }\n}\n\nstatic void arm64_sym(int r, Sym *sym, unsigned long addend)\n{\n    greloca(cur_text_section, sym, ind, R_AARCH64_ADR_GOT_PAGE, 0);\n    o(0x90000000 | r);            // adrp xr, #sym\n    greloca(cur_text_section, sym, ind, R_AARCH64_LD64_GOT_LO12_NC, 0);\n    o(0xf9400000 | r | (r << 5)); // ld xr,[xr, #sym]\n    if (addend) {\n        // add xr, xr, #addend\n\tif (addend & 0xffful)\n           o(0x91000000 | r | r << 5 | (addend & 0xfff) << 10);\n        if (addend > 0xffful) {\n            // add xr, xr, #addend, lsl #12\n\t    if (addend & 0xfff000ul)\n                o(0x91400000 | r | r << 5 | ((addend >> 12) & 0xfff) << 10);\n            if (addend > 0xfffffful) {\n\t\t/* very unlikely */\n\t\tint t = r ? 0 : 1;\n\t\to(0xf81f0fe0 | t);            /* str xt, [sp, #-16]! */\n\t\tarm64_movimm(t, addend & ~0xfffffful); // use xt for addent\n\t\to(0x91000000 | r | (t << 5)); /* add xr, xt, #0 */\n\t\to(0xf84107e0 | t);            /* ldr xt, [sp], #16 */\n\t    }\n        }\n    }\n}\n\nstatic void arm64_load_cmp(int r, SValue *sv);\n\nST_FUNC void load(int r, SValue *sv)\n{\n    int svtt = sv->type.t;\n    int svr = sv->r & ~(VT_BOUNDED | VT_NONCONST);\n    int svrv = svr & VT_VALMASK;\n    uint64_t svcul = (uint32_t)sv->c.i;\n    svcul = svcul >> 31 & 1 ? svcul - ((uint64_t)1 << 32) : svcul;\n\n    if (svr == (VT_LOCAL | VT_LVAL)) {\n        if (IS_FREG(r))\n            arm64_ldrv(arm64_type_size(svtt), fltr(r), 29, svcul);\n        else\n            arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),\n                       intr(r), 29, svcul);\n        return;\n    }\n\n    if (svr == (VT_CONST | VT_LVAL)) {\n\tif (sv->sym)\n            arm64_sym(30, sv->sym, // use x30 for address\n\t              arm64_check_offset(0, arm64_type_size(svtt), sv->c.i));\n\telse\n\t    arm64_movimm (30, sv->c.i);\n        if (IS_FREG(r))\n            arm64_ldrv(arm64_type_size(svtt), fltr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), sv->c.i));\n        else\n            arm64_ldrx(!(svtt&VT_UNSIGNED), arm64_type_size(svtt), intr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), sv->c.i));\n        return;\n    }\n\n    if ((svr & ~VT_VALMASK) == VT_LVAL && svrv < VT_CONST) {\n        if ((svtt & VT_BTYPE) != VT_VOID) {\n            if (IS_FREG(r))\n                arm64_ldrv(arm64_type_size(svtt), fltr(r), intr(svrv), 0);\n            else\n                arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),\n                           intr(r), intr(svrv), 0);\n        }\n        return;\n    }\n\n    if (svr == (VT_CONST | VT_LVAL | VT_SYM)) {\n        arm64_sym(30, sv->sym, // use x30 for address\n\t\t  arm64_check_offset(0, arm64_type_size(svtt), svcul));\n        if (IS_FREG(r))\n            arm64_ldrv(arm64_type_size(svtt), fltr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), svcul));\n        else\n            arm64_ldrx(!(svtt&VT_UNSIGNED), arm64_type_size(svtt), intr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), svcul));\n        return;\n    }\n\n    if (svr == (VT_CONST | VT_SYM)) {\n        arm64_sym(intr(r), sv->sym, svcul);\n        return;\n    }\n\n    if (svr == VT_CONST) {\n        if ((svtt & VT_BTYPE) != VT_VOID)\n            arm64_movimm(intr(r), arm64_type_size(svtt) == 3 ?\n                         sv->c.i : (uint32_t)svcul);\n        return;\n    }\n\n    if (svr < VT_CONST) {\n        if (IS_FREG(r) && IS_FREG(svr))\n            if (svtt == VT_LDOUBLE)\n                o(0x4ea01c00 | fltr(r) | fltr(svr) << 5);\n                    // mov v(r).16b,v(svr).16b\n            else\n                o(0x1e604000 | fltr(r) | fltr(svr) << 5); // fmov d(r),d(svr)\n        else if (!IS_FREG(r) && !IS_FREG(svr))\n            o(0xaa0003e0 | intr(r) | intr(svr) << 16); // mov x(r),x(svr)\n        else\n            assert(0);\n      return;\n    }\n\n    if (svr == VT_LOCAL) {\n        if (-svcul < 0x1000)\n            o(0xd10003a0 | intr(r) | -svcul << 10); // sub x(r),x29,#...\n        else {\n            arm64_movimm(30, -svcul); // use x30 for offset\n            o(0xcb0003a0 | intr(r) | (uint32_t)30 << 16); // sub x(r),x29,x30\n        }\n        return;\n    }\n\n    if (svr == VT_JMP || svr == VT_JMPI) {\n        int t = (svr == VT_JMPI);\n        arm64_movimm(intr(r), t);\n        o(0x14000002); // b .+8\n        gsym(svcul);\n        arm64_movimm(intr(r), t ^ 1);\n        return;\n    }\n\n    if (svr == (VT_LLOCAL | VT_LVAL)) {\n        arm64_ldrx(0, 3, 30, 29, svcul); // use x30 for offset\n        if (IS_FREG(r))\n            arm64_ldrv(arm64_type_size(svtt), fltr(r), 30, 0);\n        else\n            arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),\n                       intr(r), 30, 0);\n        return;\n    }\n\n    if (svr == VT_CMP) {\n        arm64_load_cmp(r, sv);\n        return;\n    }\n\n    printf(\"load(%x, (%x, %x, %lx))\\n\", r, svtt, sv->r, (long)svcul);\n    assert(0);\n}\n\nST_FUNC void store(int r, SValue *sv)\n{\n    int svtt = sv->type.t;\n    int svr = sv->r & ~VT_BOUNDED;\n    int svrv = svr & VT_VALMASK;\n    uint64_t svcul = (uint32_t)sv->c.i;\n    svcul = svcul >> 31 & 1 ? svcul - ((uint64_t)1 << 32) : svcul;\n\n    if (svr == (VT_LOCAL | VT_LVAL)) {\n        if (IS_FREG(r))\n            arm64_strv(arm64_type_size(svtt), fltr(r), 29, svcul);\n        else\n            arm64_strx(arm64_type_size(svtt), intr(r), 29, svcul);\n        return;\n    }\n\n    if (svr == (VT_CONST | VT_LVAL)) {\n\tif (sv->sym)\n            arm64_sym(30, sv->sym, // use x30 for address\n\t\t      arm64_check_offset(0, arm64_type_size(svtt), sv->c.i));\n\telse\n\t    arm64_movimm (30, sv->c.i);\n        if (IS_FREG(r))\n            arm64_strv(arm64_type_size(svtt), fltr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), sv->c.i));\n        else\n            arm64_strx(arm64_type_size(svtt), intr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), sv->c.i));\n        return;\n    }\n\n    if ((svr & ~VT_VALMASK) == VT_LVAL && svrv < VT_CONST) {\n        if (IS_FREG(r))\n            arm64_strv(arm64_type_size(svtt), fltr(r), intr(svrv), 0);\n        else\n            arm64_strx(arm64_type_size(svtt), intr(r), intr(svrv), 0);\n        return;\n    }\n\n    if (svr == (VT_CONST | VT_LVAL | VT_SYM)) {\n        arm64_sym(30, sv->sym, // use x30 for address\n\t\t  arm64_check_offset(0, arm64_type_size(svtt), svcul));\n        if (IS_FREG(r))\n            arm64_strv(arm64_type_size(svtt), fltr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), svcul));\n        else\n            arm64_strx(arm64_type_size(svtt), intr(r), 30,\n\t\t       arm64_check_offset(1, arm64_type_size(svtt), svcul));\n        return;\n    }\n\n    printf(\"store(%x, (%x, %x, %lx))\\n\", r, svtt, sv->r, (long)svcul);\n    assert(0);\n}\n\nstatic void arm64_gen_bl_or_b(int b)\n{\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST && (vtop->r & VT_SYM)) {\n\tgreloca(cur_text_section, vtop->sym, ind,\n                b ? R_AARCH64_JUMP26 :  R_AARCH64_CALL26, 0);\n\to(0x14000000 | (uint32_t)!b << 31); // b/bl .\n    }\n    else {\n#ifdef CONFIG_TCC_BCHECK\n        vtop->r &= ~VT_MUSTBOUND;\n#endif\n        o(0xd61f0000 | (uint32_t)!b << 21 | intr(gv(RC_R30)) << 5); // br/blr\n    }\n}\n\n#if defined(CONFIG_TCC_BCHECK)\n\nstatic void gen_bounds_call(int v)\n{\n    Sym *sym = external_helper_sym(v);\n\n    greloca(cur_text_section, sym, ind, R_AARCH64_CALL26, 0);\n    o(0x94000000); // bl\n}\n\nstatic void gen_bounds_prolog(void)\n{\n    /* leave some room for bound checking code */\n    func_bound_offset = lbounds_section->data_offset;\n    func_bound_ind = ind;\n    func_bound_add_epilog = 0;\n    o(0xd503201f);  /* nop -> mov x0, lbound section pointer */\n    o(0xd503201f);\n    o(0xd503201f);\n    o(0xd503201f);  /* nop -> call __bound_local_new */\n}\n\nstatic void gen_bounds_epilog(void)\n{\n    addr_t saved_ind;\n    addr_t *bounds_ptr;\n    Sym *sym_data;\n    int offset_modified = func_bound_offset != lbounds_section->data_offset;\n\n    if (!offset_modified && !func_bound_add_epilog)\n        return;\n\n    /* add end of table info */\n    bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));\n    *bounds_ptr = 0;\n\n    sym_data = get_sym_ref(&char_pointer_type, lbounds_section,\n                           func_bound_offset, PTR_SIZE);\n\n    /* generate bound local allocation */\n    if (offset_modified) {\n        saved_ind = ind;\n        ind = func_bound_ind;\n        greloca(cur_text_section, sym_data, ind, R_AARCH64_ADR_GOT_PAGE, 0);\n        o(0x90000000 | 0);            // adrp x0, #sym_data\n        greloca(cur_text_section, sym_data, ind, R_AARCH64_LD64_GOT_LO12_NC, 0);\n        o(0xf9400000 | 0 | (0 << 5)); // ld x0,[x0, #sym_data]\n        gen_bounds_call(TOK___bound_local_new);\n        ind = saved_ind;\n    }\n\n    /* generate bound check local freeing */\n    o(0xa9bf07e0); /* stp x0, x1, [sp, #-16]! */\n    o(0x3c9f0fe0); /* str q0, [sp, #-16]! */\n    greloca(cur_text_section, sym_data, ind, R_AARCH64_ADR_GOT_PAGE, 0);\n    o(0x90000000 | 0);            // adrp x0, #sym_data\n    greloca(cur_text_section, sym_data, ind, R_AARCH64_LD64_GOT_LO12_NC, 0);\n    o(0xf9400000 | 0 | (0 << 5)); // ld x0,[x0, #sym_data]\n    gen_bounds_call(TOK___bound_local_delete);\n    o(0x3cc107e0); /* ldr q0, [sp], #16 */\n    o(0xa8c107e0); /* ldp x0, x1, [sp], #16 */\n}\n#endif\n\nstatic int arm64_hfa_aux(CType *type, int *fsize, int num)\n{\n    if (is_float(type->t)) {\n        int a, n = type_size(type, &a);\n        if (num >= 4 || (*fsize && *fsize != n))\n            return -1;\n        *fsize = n;\n        return num + 1;\n    }\n    else if ((type->t & VT_BTYPE) == VT_STRUCT) {\n        int is_struct = 0; // rather than union\n        Sym *field;\n        for (field = type->ref->next; field; field = field->next)\n            if (field->c) {\n                is_struct = 1;\n                break;\n            }\n        if (is_struct) {\n            int num0 = num;\n            for (field = type->ref->next; field; field = field->next) {\n                if (field->c != (num - num0) * *fsize)\n                    return -1;\n                num = arm64_hfa_aux(&field->type, fsize, num);\n                if (num == -1)\n                    return -1;\n            }\n            if (type->ref->c != (num - num0) * *fsize)\n                return -1;\n            return num;\n        }\n        else { // union\n            int num0 = num;\n            for (field = type->ref->next; field; field = field->next) {\n                int num1 = arm64_hfa_aux(&field->type, fsize, num0);\n                if (num1 == -1)\n                    return -1;\n                num = num1 < num ? num : num1;\n            }\n            if (type->ref->c != (num - num0) * *fsize)\n                return -1;\n            return num;\n        }\n    }\n    else if ((type->t & VT_ARRAY) && ((type->t & VT_BTYPE) != VT_PTR)) {\n        int num1;\n        if (!type->ref->c)\n            return num;\n        num1 = arm64_hfa_aux(&type->ref->type, fsize, num);\n        if (num1 == -1 || (num1 != num && type->ref->c > 4))\n            return -1;\n        num1 = num + type->ref->c * (num1 - num);\n        if (num1 > 4)\n            return -1;\n        return num1;\n    }\n    return -1;\n}\n\nstatic int arm64_hfa(CType *type, unsigned *fsize)\n{\n    if ((type->t & VT_BTYPE) == VT_STRUCT ||\n        ((type->t & VT_ARRAY) && ((type->t & VT_BTYPE) != VT_PTR))) {\n        int sz = 0;\n        int n = arm64_hfa_aux(type, &sz, 0);\n        if (0 < n && n <= 4) {\n            if (fsize)\n                *fsize = sz;\n            return n;\n        }\n    }\n    return 0;\n}\n\nstatic unsigned long arm64_pcs_aux(int variadic, int n, CType **type, unsigned long *a)\n{\n    int nx = 0; // next integer register\n    int nv = 0; // next vector register\n    unsigned long ns = 32; // next stack offset\n    int i;\n\n    for (i = 0; i < n; i++) {\n        int hfa = arm64_hfa(type[i], 0);\n        int size, align;\n\n        if ((type[i]->t & VT_ARRAY) ||\n            (type[i]->t & VT_BTYPE) == VT_FUNC)\n            size = align = 8;\n        else\n            size = type_size(type[i], &align);\n\n#if defined(TCC_TARGET_MACHO)\n        if (variadic && i == variadic) {\n            nx = 8;\n            nv = 8;\n\t}\n#endif\n        if (hfa)\n            // B.2\n            ;\n        else if (size > 16) {\n            // B.3: replace with pointer\n            if (nx < 8)\n                a[i] = nx++ << 1 | 1;\n            else {\n                ns = (ns + 7) & ~7;\n                a[i] = ns | 1;\n                ns += 8;\n            }\n            continue;\n        }\n        else if ((type[i]->t & VT_BTYPE) == VT_STRUCT)\n            // B.4\n            size = (size + 7) & ~7;\n\n        // C.1\n        if (is_float(type[i]->t) && nv < 8) {\n            a[i] = 16 + (nv++ << 1);\n            continue;\n        }\n\n        // C.2\n        if (hfa && nv + hfa <= 8) {\n            a[i] = 16 + (nv << 1);\n            nv += hfa;\n            continue;\n        }\n\n        // C.3\n        if (hfa) {\n            nv = 8;\n            size = (size + 7) & ~7;\n        }\n\n        // C.4\n        if (hfa || (type[i]->t & VT_BTYPE) == VT_LDOUBLE) {\n            ns = (ns + 7) & ~7;\n            ns = (ns + align - 1) & -align;\n        }\n\n        // C.5\n        if ((type[i]->t & VT_BTYPE) == VT_FLOAT)\n            size = 8;\n\n        // C.6\n        if (hfa || is_float(type[i]->t)) {\n            a[i] = ns;\n            ns += size;\n            continue;\n        }\n\n        // C.7\n        if ((type[i]->t & VT_BTYPE) != VT_STRUCT && size <= 8 && nx < 8) {\n            a[i] = nx++ << 1;\n            continue;\n        }\n\n        // C.8\n        if (align == 16)\n            nx = (nx + 1) & ~1;\n\n        // C.9\n        if ((type[i]->t & VT_BTYPE) != VT_STRUCT && size == 16 && nx < 7) {\n            a[i] = nx << 1;\n            nx += 2;\n            continue;\n        }\n\n        // C.10\n        if ((type[i]->t & VT_BTYPE) == VT_STRUCT && size <= (8 - nx) * 8) {\n            a[i] = nx << 1;\n            nx += (size + 7) >> 3;\n            continue;\n        }\n\n        // C.11\n        nx = 8;\n\n        // C.12\n        ns = (ns + 7) & ~7;\n        ns = (ns + align - 1) & -align;\n\n        // C.13\n        if ((type[i]->t & VT_BTYPE) == VT_STRUCT) {\n            a[i] = ns;\n            ns += size;\n            continue;\n        }\n\n        // C.14\n        if (size < 8)\n            size = 8;\n\n        // C.15\n        a[i] = ns;\n        ns += size;\n    }\n\n    return ns - 32;\n}\n\nstatic unsigned long arm64_pcs(int variadic, int n, CType **type, unsigned long *a)\n{\n    unsigned long stack;\n\n    // Return type:\n    if ((type[0]->t & VT_BTYPE) == VT_VOID)\n        a[0] = -1;\n    else {\n        arm64_pcs_aux(0, 1, type, a);\n        assert(a[0] == 0 || a[0] == 1 || a[0] == 16);\n    }\n\n    // Argument types:\n    stack = arm64_pcs_aux(variadic, n, type + 1, a + 1);\n\n    if (0) {\n        int i;\n        for (i = 0; i <= n; i++) {\n            if (!i)\n                printf(\"arm64_pcs return: \");\n            else\n                printf(\"arm64_pcs arg %d: \", i);\n            if (a[i] == (unsigned long)-1)\n                printf(\"void\\n\");\n            else if (a[i] == 1 && !i)\n                printf(\"X8 pointer\\n\");\n            else if (a[i] < 16)\n                printf(\"X%lu%s\\n\", a[i] / 2, a[i] & 1 ? \" pointer\" : \"\");\n            else if (a[i] < 32)\n                printf(\"V%lu\\n\", a[i] / 2 - 8);\n            else\n                printf(\"stack %lu%s\\n\",\n                       (a[i] - 32) & ~1, a[i] & 1 ? \" pointer\" : \"\");\n        }\n    }\n\n    return stack;\n}\n\nstatic int n_func_args(CType *type)\n{\n    int n_args = 0;\n    Sym *arg;\n\n    for (arg = type->ref->next; arg; arg = arg->next)\n        n_args++;\n    return n_args;\n}\n\nST_FUNC void gfunc_call(int nb_args)\n{\n    CType *return_type;\n    CType **t;\n    unsigned long *a, *a1;\n    unsigned long stack;\n    int i;\n    int variadic = (vtop[-nb_args].type.ref->f.func_type == FUNC_ELLIPSIS);\n    int var_nb_arg = n_func_args(&vtop[-nb_args].type);\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gbound_args(nb_args);\n#endif\n\n    return_type = &vtop[-nb_args].type.ref->type;\n    if ((return_type->t & VT_BTYPE) == VT_STRUCT)\n        --nb_args;\n\n    t = tcc_malloc((nb_args + 1) * sizeof(*t));\n    a = tcc_malloc((nb_args + 1) * sizeof(*a));\n    a1 = tcc_malloc((nb_args + 1) * sizeof(*a1));\n\n    t[0] = return_type;\n    for (i = 0; i < nb_args; i++)\n        t[nb_args - i] = &vtop[-i].type;\n\n    stack = arm64_pcs(variadic ? var_nb_arg : 0, nb_args, t, a);\n\n    // Allocate space for structs replaced by pointer:\n    for (i = nb_args; i; i--)\n        if (a[i] & 1) {\n            SValue *arg = &vtop[i - nb_args];\n            int align, size = type_size(&arg->type, &align);\n            assert((arg->type.t & VT_BTYPE) == VT_STRUCT);\n            stack = (stack + align - 1) & -align;\n            a1[i] = stack;\n            stack += size;\n        }\n\n    stack = (stack + 15) >> 4 << 4;\n\n    /* fetch cpu flag before generating any code */\n    if ((vtop->r & VT_VALMASK) == VT_CMP)\n      gv(RC_INT);\n\n    if (stack >= 0x1000000) // 16Mb\n        tcc_error(\"stack size too big %lu\", stack);\n    if (stack & 0xfff)\n        o(0xd10003ff | (stack & 0xfff) << 10); // sub sp,sp,#(n)\n    if (stack >> 12)\n            o(0xd14003ff | (stack >> 12) << 10);\n\n    // First pass: set all values on stack\n    for (i = nb_args; i; i--) {\n        vpushv(vtop - nb_args + i);\n\n        if (a[i] & 1) {\n            // struct replaced by pointer\n            int r = get_reg(RC_INT);\n            arm64_spoff(intr(r), a1[i]);\n            vset(&vtop->type, r | VT_LVAL, 0);\n            vswap();\n            vstore();\n            if (a[i] >= 32) {\n                // pointer on stack\n                r = get_reg(RC_INT);\n                arm64_spoff(intr(r), a1[i]);\n                arm64_strx(3, intr(r), 31, (a[i] - 32) >> 1 << 1);\n            }\n        }\n        else if (a[i] >= 32) {\n            // value on stack\n            if ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n                int r = get_reg(RC_INT);\n                arm64_spoff(intr(r), a[i] - 32);\n                vset(&vtop->type, r | VT_LVAL, 0);\n                vswap();\n                vstore();\n            }\n            else if (is_float(vtop->type.t)) {\n                gv(RC_FLOAT);\n                arm64_strv(arm64_type_size(vtop[0].type.t),\n                           fltr(vtop[0].r), 31, a[i] - 32);\n            }\n            else {\n                gv(RC_INT);\n                arm64_strx(3, // arm64_type_size(vtop[0].type.t),\n                           intr(vtop[0].r), 31, a[i] - 32);\n            }\n        }\n\n        --vtop;\n    }\n\n    // Second pass: assign values to registers\n    for (i = nb_args; i; i--, vtop--) {\n        if (a[i] < 16 && !(a[i] & 1)) {\n            // value in general-purpose registers\n            if ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n                int align, size = type_size(&vtop->type, &align);\n                if (size) {\n                    vtop->type.t = VT_PTR;\n                    gaddrof();\n                    gv(RC_R(a[i] / 2));\n                    arm64_ldrs(a[i] / 2, size);\n                }\n            }\n            else\n                gv(RC_R(a[i] / 2));\n        }\n        else if (a[i] < 16)\n            // struct replaced by pointer in register\n            arm64_spoff(a[i] / 2, a1[i]);\n        else if (a[i] < 32) {\n            // value in floating-point registers\n            if ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n                uint32_t j, sz, n = arm64_hfa(&vtop->type, &sz);\n                vtop->type.t = VT_PTR;\n                gaddrof();\n                gv(RC_R30);\n                for (j = 0; j < n; j++)\n                    o(0x3d4003c0 |\n                      (sz & 16) << 19 | -(sz & 8) << 27 | (sz & 4) << 29 |\n                      (a[i] / 2 - 8 + j) |\n                      j << 10); // ldr ([sdq])(*),[x30,#(j * sz)]\n            }\n            else\n                gv(RC_F(a[i] / 2 - 8));\n        }\n    }\n\n    if ((return_type->t & VT_BTYPE) == VT_STRUCT) {\n        if (a[0] == 1) {\n            // indirect return: set x8 and discard the stack value\n            gv(RC_R(8));\n            --vtop;\n        }\n        else\n            // return in registers: keep the address for after the call\n            vswap();\n    }\n\n    save_regs(0);\n    arm64_gen_bl_or_b(0);\n    --vtop;\n    if (stack & 0xfff)\n        o(0x910003ff | (stack & 0xfff) << 10); // add sp,sp,#(n)\n    if (stack >> 12)\n        o(0x914003ff | (stack >> 12) << 10);\n\n    {\n        int rt = return_type->t;\n        int bt = rt & VT_BTYPE;\n        if (bt == VT_STRUCT && !(a[0] & 1)) {\n            // A struct was returned in registers, so write it out:\n            gv(RC_R(8));\n            --vtop;\n            if (a[0] == 0) {\n                int align, size = type_size(return_type, &align);\n                assert(size <= 16);\n                if (size > 8)\n                    o(0xa9000500); // stp x0,x1,[x8]\n                else if (size)\n                    arm64_strx(size > 4 ? 3 : size > 2 ? 2 : size > 1, 0, 8, 0);\n\n            }\n            else if (a[0] == 16) {\n                uint32_t j, sz, n = arm64_hfa(return_type, &sz);\n                for (j = 0; j < n; j++)\n                    o(0x3d000100 |\n                      (sz & 16) << 19 | -(sz & 8) << 27 | (sz & 4) << 29 |\n                      (a[i] / 2 - 8 + j) |\n                      j << 10); // str ([sdq])(*),[x8,#(j * sz)]\n            }\n        }\n    }\n\n    tcc_free(a1);\n    tcc_free(a);\n    tcc_free(t);\n}\n\nstatic unsigned long arm64_func_va_list_stack;\nstatic int arm64_func_va_list_gr_offs;\nstatic int arm64_func_va_list_vr_offs;\nstatic int arm64_func_sub_sp_offset;\n\nST_FUNC void gfunc_prolog(Sym *func_sym)\n{\n    CType *func_type = &func_sym->type;\n    int n = 0;\n    int i = 0;\n    Sym *sym;\n    CType **t;\n    unsigned long *a;\n    int use_x8 = 0;\n    int last_int = 0;\n    int last_float = 0;\n    int variadic = func_sym->type.ref->f.func_type == FUNC_ELLIPSIS;\n    int var_nb_arg = n_func_args(&func_sym->type);\n\n    func_vc = 144; // offset of where x8 is stored\n\n    for (sym = func_type->ref; sym; sym = sym->next)\n        ++n;\n    t = n ? tcc_malloc(n * sizeof(*t)) : NULL;\n    a = n ? tcc_malloc(n * sizeof(*a)) : NULL;\n\n    for (sym = func_type->ref; sym; sym = sym->next)\n        t[i++] = &sym->type;\n\n    arm64_func_va_list_stack = arm64_pcs(variadic ? var_nb_arg : 0, n - 1, t, a);\n\n#if !defined(TCC_TARGET_MACHO)\n    if (variadic) {\n        use_x8 = 1;\n        last_int = 4;\n        last_float = 4;\n    }\n#endif\n    if (a && a[0] == 1)\n        use_x8 = 1;\n    for (i = 1, sym = func_type->ref->next; sym; i++, sym = sym->next) {\n        if (a[i] < 16) {\n            int last, align, size = type_size(&sym->type, &align);\n\t    last = a[i] / 4 + 1 + (size - 1) / 8;\n\t    last_int = last > last_int ? last : last_int;\n\t}\n        else if (a[i] < 32) {\n            int last, hfa = arm64_hfa(&sym->type, 0);\n\t    last = a[i] / 4 - 3 + (hfa ? hfa - 1 : 0);\n\t    last_float = last > last_float ? last : last_float;\n\t}\n    }\n\n    last_int = last_int > 4 ? 4 : last_int;\n    last_float = last_float > 4 ? 4 : last_float;\n\n    o(0xa9b27bfd); // stp x29,x30,[sp,#-224]!\n    for (i = 0; i < last_float; i++)\n        // stp q0,q1,[sp,#16], stp q2,q3,[sp,#48]\n        // stp q4,q5,[sp,#80], stp q6,q7,[sp,#112]\n        o(0xad0087e0 + i * 0x10000 + (i << 11) + (i << 1));\n    if (use_x8)\n        o(0xa90923e8); // stp x8,x8,[sp,#144]\n    for (i = 0; i < last_int; i++)\n        // stp x0,x1,[sp,#160], stp x2,x3,[sp,#176]\n        // stp x4,x5,[sp,#192], stp x6,x7,[sp,#208]\n        o(0xa90a07e0 + i * 0x10000 + (i << 11) + (i << 1));\n\n    arm64_func_va_list_gr_offs = -64;\n    arm64_func_va_list_vr_offs = -128;\n\n    for (i = 1, sym = func_type->ref->next; sym; i++, sym = sym->next) {\n        int off = (a[i] < 16 ? 160 + a[i] / 2 * 8 :\n                   a[i] < 32 ? 16 + (a[i] - 16) / 2 * 16 :\n                   224 + ((a[i] - 32) >> 1 << 1));\n        sym_push(sym->v & ~SYM_FIELD, &sym->type,\n                 (a[i] & 1 ? VT_LLOCAL : VT_LOCAL) | VT_LVAL,\n                 off);\n\n        if (a[i] < 16) {\n            int align, size = type_size(&sym->type, &align);\n            arm64_func_va_list_gr_offs = (a[i] / 2 - 7 +\n                                          (!(a[i] & 1) && size > 8)) * 8;\n        }\n        else if (a[i] < 32) {\n            uint32_t hfa = arm64_hfa(&sym->type, 0);\n            arm64_func_va_list_vr_offs = (a[i] / 2 - 16 +\n                                          (hfa ? hfa : 1)) * 16;\n        }\n\n        // HFAs of float and double need to be written differently:\n        if (16 <= a[i] && a[i] < 32 && (sym->type.t & VT_BTYPE) == VT_STRUCT) {\n            uint32_t j, sz, k = arm64_hfa(&sym->type, &sz);\n            if (sz < 16)\n                for (j = 0; j < k; j++) {\n                    o(0x3d0003e0 | -(sz & 8) << 27 | (sz & 4) << 29 |\n                      ((a[i] - 16) / 2 + j) | (off / sz + j) << 10);\n                    // str ([sdq])(*),[sp,#(j * sz)]\n                }\n        }\n    }\n\n    tcc_free(a);\n    tcc_free(t);\n\n    o(0x910003fd); // mov x29,sp\n    arm64_func_sub_sp_offset = ind;\n    // In gfunc_epilog these will be replaced with code to decrement SP:\n    o(0xd503201f); // nop\n    o(0xd503201f); // nop\n    loc = 0;\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_prolog();\n#endif\n}\n\nST_FUNC void gen_va_start(void)\n{\n    int r;\n    --vtop; // we don't need the \"arg\"\n    gaddrof();\n    r = intr(gv(RC_INT));\n\n    if (arm64_func_va_list_stack) {\n        //xx could use add (immediate) here\n        arm64_movimm(30, arm64_func_va_list_stack + 224);\n        o(0x8b1e03be); // add x30,x29,x30\n    }\n    else\n        o(0x910383be); // add x30,x29,#224\n    o(0xf900001e | r << 5); // str x30,[x(r)]\n\n#if !defined(TCC_TARGET_MACHO)\n    if (arm64_func_va_list_gr_offs) {\n        if (arm64_func_va_list_stack)\n            o(0x910383be); // add x30,x29,#224\n        o(0xf900041e | r << 5); // str x30,[x(r),#8]\n    }\n\n    if (arm64_func_va_list_vr_offs) {\n        o(0x910243be); // add x30,x29,#144\n        o(0xf900081e | r << 5); // str x30,[x(r),#16]\n    }\n\n    arm64_movimm(30, arm64_func_va_list_gr_offs);\n    o(0xb900181e | r << 5); // str w30,[x(r),#24]\n\n    arm64_movimm(30, arm64_func_va_list_vr_offs);\n    o(0xb9001c1e | r << 5); // str w30,[x(r),#28]\n#endif\n\n    --vtop;\n}\n\nST_FUNC void gen_va_arg(CType *t)\n{\n    int align, size = type_size(t, &align);\n    unsigned fsize, hfa = arm64_hfa(t, &fsize);\n    uint32_t r0, r1;\n\n    if (is_float(t->t)) {\n        hfa = 1;\n        fsize = size;\n    }\n\n    gaddrof();\n    r0 = intr(gv(RC_INT));\n    r1 = get_reg(RC_INT);\n    vtop[0].r = r1 | VT_LVAL;\n    r1 = intr(r1);\n\n    if (!hfa) {\n        uint32_t n = size > 16 ? 8 : (size + 7) & -8;\n#if !defined(TCC_TARGET_MACHO)\n        o(0xb940181e | r0 << 5); // ldr w30,[x(r0),#24] // __gr_offs\n        if (align == 16) {\n            assert(0); // this path untested but needed for __uint128_t\n            o(0x11003fde); // add w30,w30,#15\n            o(0x121c6fde); // and w30,w30,#-16\n        }\n        o(0x310003c0 | r1 | n << 10); // adds w(r1),w30,#(n)\n        o(0x540000ad); // b.le .+20\n#endif\n        o(0xf9400000 | r1 | r0 << 5); // ldr x(r1),[x(r0)] // __stack\n        o(0x9100001e | r1 << 5 | n << 10); // add x30,x(r1),#(n)\n        o(0xf900001e | r0 << 5); // str x30,[x(r0)] // __stack\n#if !defined(TCC_TARGET_MACHO)\n        o(0x14000004); // b .+16\n        o(0xb9001800 | r1 | r0 << 5); // str w(r1),[x(r0),#24] // __gr_offs\n        o(0xf9400400 | r1 | r0 << 5); // ldr x(r1),[x(r0),#8] // __gr_top\n        o(0x8b3ec000 | r1 | r1 << 5); // add x(r1),x(r1),w30,sxtw\n#endif\n        if (size > 16)\n            o(0xf9400000 | r1 | r1 << 5); // ldr x(r1),[x(r1)]\n    }\n    else {\n        uint32_t ssz = (size + 7) & -(uint32_t)8;\n#if !defined(TCC_TARGET_MACHO)\n        uint32_t rsz = hfa << 4;\n        uint32_t b1, b2;\n        o(0xb9401c1e | r0 << 5); // ldr w30,[x(r0),#28] // __vr_offs\n        o(0x310003c0 | r1 | rsz << 10); // adds w(r1),w30,#(rsz)\n        b1 = ind; o(0x5400000d); // b.le lab1\n#endif\n        o(0xf9400000 | r1 | r0 << 5); // ldr x(r1),[x(r0)] // __stack\n        if (fsize == 16) {\n            o(0x91003c00 | r1 | r1 << 5); // add x(r1),x(r1),#15\n            o(0x927cec00 | r1 | r1 << 5); // and x(r1),x(r1),#-16\n        }\n        o(0x9100001e | r1 << 5 | ssz << 10); // add x30,x(r1),#(ssz)\n        o(0xf900001e | r0 << 5); // str x30,[x(r0)] // __stack\n#if !defined(TCC_TARGET_MACHO)\n        b2 = ind; o(0x14000000); // b lab2\n        // lab1:\n        write32le(cur_text_section->data + b1, 0x5400000d | (ind - b1) << 3);\n        o(0xb9001c00 | r1 | r0 << 5); // str w(r1),[x(r0),#28] // __vr_offs\n        o(0xf9400800 | r1 | r0 << 5); // ldr x(r1),[x(r0),#16] // __vr_top\n        if (hfa == 1 || fsize == 16)\n            o(0x8b3ec000 | r1 | r1 << 5); // add x(r1),x(r1),w30,sxtw\n        else {\n            // We need to change the layout of this HFA.\n            // Get some space on the stack using global variable \"loc\":\n            loc = (loc - size) & -(uint32_t)align;\n            o(0x8b3ec000 | 30 | r1 << 5); // add x30,x(r1),w30,sxtw\n            arm64_movimm(r1, loc);\n            o(0x8b0003a0 | r1 | r1 << 16); // add x(r1),x29,x(r1)\n            o(0x4c402bdc | (uint32_t)fsize << 7 |\n              (uint32_t)(hfa == 2) << 15 |\n              (uint32_t)(hfa == 3) << 14); // ld1 {v28.(4s|2d),...},[x30]\n            o(0x0d00801c | r1 << 5 | (fsize == 8) << 10 |\n              (uint32_t)(hfa != 2) << 13 |\n              (uint32_t)(hfa != 3) << 21); // st(hfa) {v28.(s|d),...}[0],[x(r1)]\n        }\n        // lab2:\n        write32le(cur_text_section->data + b2, 0x14000000 | (ind - b2) >> 2);\n#endif\n    }\n}\n\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret,\n                       int *align, int *regsize)\n{\n    return 0;\n}\n\nST_FUNC void gfunc_return(CType *func_type)\n{\n    CType *t = func_type;\n    unsigned long a;\n\n    arm64_pcs(0, 0, &t, &a);\n    switch (a) {\n    case -1:\n        break;\n    case 0:\n        if ((func_type->t & VT_BTYPE) == VT_STRUCT) {\n            int align, size = type_size(func_type, &align);\n            gaddrof();\n            gv(RC_R(0));\n            arm64_ldrs(0, size);\n        }\n        else\n            gv(RC_IRET);\n        break;\n    case 1: {\n        CType type = *func_type;\n        mk_pointer(&type);\n        vset(&type, VT_LOCAL | VT_LVAL, func_vc);\n        indir();\n        vswap();\n        vstore();\n        break;\n    }\n    case 16:\n        if ((func_type->t & VT_BTYPE) == VT_STRUCT) {\n          uint32_t j, sz, n = arm64_hfa(&vtop->type, &sz);\n          gaddrof();\n          gv(RC_R(0));\n          for (j = 0; j < n; j++)\n              o(0x3d400000 |\n                (sz & 16) << 19 | -(sz & 8) << 27 | (sz & 4) << 29 |\n                j | j << 10); // ldr ([sdq])(*),[x0,#(j * sz)]\n        }\n        else\n            gv(RC_FRET);\n        break;\n    default:\n      assert(0);\n    }\n    vtop--;\n}\n\nST_FUNC void gfunc_epilog(void)\n{\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_epilog();\n#endif\n\n    if (loc) {\n        // Insert instructions to subtract size of stack frame from SP.\n        unsigned char *ptr = cur_text_section->data + arm64_func_sub_sp_offset;\n        uint64_t diff = (-loc + 15) & ~15;\n        if (!(diff >> 24)) {\n            if (diff & 0xfff) // sub sp,sp,#(diff & 0xfff)\n                write32le(ptr, 0xd10003ff | (diff & 0xfff) << 10);\n            if (diff >> 12) // sub sp,sp,#(diff >> 12),lsl #12\n                write32le(ptr + 4, 0xd14003ff | (diff >> 12) << 10);\n        }\n        else {\n            // In this case we may subtract more than necessary,\n            // but always less than 17/16 of what we were aiming for.\n            int i = 0;\n            int j = 0;\n            while (diff >> 20) {\n                diff = (diff + 0xffff) >> 16;\n                ++i;\n            }\n            while (diff >> 16) {\n                diff = (diff + 1) >> 1;\n                ++j;\n            }\n            write32le(ptr, 0xd2800010 | diff << 5 | i << 21);\n            // mov x16,#(diff),lsl #(16 * i)\n            write32le(ptr + 4, 0xcb3063ff | j << 10);\n            // sub sp,sp,x16,lsl #(j)\n        }\n    }\n    o(0x910003bf); // mov sp,x29\n    o(0xa8ce7bfd); // ldp x29,x30,[sp],#224\n\n    o(0xd65f03c0); // ret\n}\n\nST_FUNC void gen_fill_nops(int bytes)\n{\n    if ((bytes & 3))\n      tcc_error(\"alignment of code section not multiple of 4\");\n    while (bytes > 0) {\n\to(0xd503201f); // nop\n\tbytes -= 4;\n    }\n}\n\n// Generate forward branch to label:\nST_FUNC int gjmp(int t)\n{\n    int r = ind;\n    if (nocode_wanted)\n        return t;\n    o(t);\n    return r;\n}\n\n// Generate branch to known address:\nST_FUNC void gjmp_addr(int a)\n{\n    assert(a - ind + 0x8000000 < 0x10000000);\n    o(0x14000000 | ((a - ind) >> 2 & 0x3ffffff));\n}\n\nST_FUNC int gjmp_append(int n, int t)\n{\n    void *p;\n    /* insert vtop->c jump list in t */\n    if (n) {\n        uint32_t n1 = n, n2;\n        while ((n2 = read32le(p = cur_text_section->data + n1)))\n            n1 = n2;\n        write32le(p, t);\n        t = n;\n    }\n    return t;\n}\n\nvoid arm64_vset_VT_CMP(int op)\n{\n    if (op >= TOK_ULT && op <= TOK_GT) {\n        vtop->cmp_r = vtop->r;\n        vset_VT_CMP(0x80);\n    }\n}\n\nstatic void arm64_gen_opil(int op, uint32_t l);\n\nstatic void arm64_load_cmp(int r, SValue *sv)\n{\n    sv->r = sv->cmp_r;\n    if (sv->c.i & 1) {\n        vpushi(1);\n        arm64_gen_opil('^', 0);\n    }\n    if (r != sv->r) {\n        load(r, sv);\n        sv->r = r;\n    }\n}\n\nST_FUNC int gjmp_cond(int op, int t)\n{\n    int bt = vtop->type.t & VT_BTYPE;\n\n    int inv = op & 1;\n    vtop->r = vtop->cmp_r;\n\n    if (bt == VT_LDOUBLE) {\n        uint32_t a, b, f = fltr(gv(RC_FLOAT));\n        a = get_reg(RC_INT);\n        vpushi(0);\n        vtop[0].r = a;\n        b = get_reg(RC_INT);\n        a = intr(a);\n        b = intr(b);\n        o(0x4e083c00 | a | f << 5); // mov x(a),v(f).d[0]\n        o(0x4e183c00 | b | f << 5); // mov x(b),v(f).d[1]\n        o(0xaa000400 | a | a << 5 | b << 16); // orr x(a),x(a),x(b),lsl #1\n        o(0xb4000040 | a | !!inv << 24); // cbz/cbnz x(a),.+8\n        --vtop;\n    }\n    else if (bt == VT_FLOAT || bt == VT_DOUBLE) {\n        uint32_t a = fltr(gv(RC_FLOAT));\n        o(0x1e202008 | a << 5 | (bt != VT_FLOAT) << 22); // fcmp\n        o(0x54000040 | !!inv); // b.eq/b.ne .+8\n    }\n    else {\n        uint32_t ll = (bt == VT_PTR || bt == VT_LLONG);\n        uint32_t a = intr(gv(RC_INT));\n        o(0x34000040 | a | !!inv << 24 | ll << 31); // cbz/cbnz wA,.+8\n    }\n    return gjmp(t);\n}\n\nstatic int arm64_iconst(uint64_t *val, SValue *sv)\n{\n    if ((sv->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)\n        return 0;\n    if (val) {\n        int t = sv->type.t;\n\tint bt = t & VT_BTYPE;\n        *val = ((bt == VT_LLONG || bt == VT_PTR) ? sv->c.i :\n                (uint32_t)sv->c.i |\n                (t & VT_UNSIGNED ? 0 : -(sv->c.i & 0x80000000)));\n    }\n    return 1;\n}\n\nstatic int arm64_gen_opic(int op, uint32_t l, int rev, uint64_t val,\n                          uint32_t x, uint32_t a)\n{\n    if (op == '-' && !rev) {\n        val = -val;\n        op = '+';\n    }\n    val = l ? val : (uint32_t)val;\n\n    switch (op) {\n\n    case '+': {\n        uint32_t s = l ? val >> 63 : val >> 31;\n        val = s ? -val : val;\n        val = l ? val : (uint32_t)val;\n        if (!(val & ~(uint64_t)0xfff))\n            o(0x11000000 | l << 31 | s << 30 | x | a << 5 | val << 10);\n        else if (!(val & ~(uint64_t)0xfff000))\n            o(0x11400000 | l << 31 | s << 30 | x | a << 5 | val >> 12 << 10);\n        else {\n            arm64_movimm(30, val); // use x30\n            o(0x0b1e0000 | l << 31 | s << 30 | x | a << 5);\n        }\n        return 1;\n      }\n\n    case '-':\n        if (!val)\n            o(0x4b0003e0 | l << 31 | x | a << 16); // neg\n        else if (val == (l ? (uint64_t)-1 : (uint32_t)-1))\n            o(0x2a2003e0 | l << 31 | x | a << 16); // mvn\n        else {\n            arm64_movimm(30, val); // use x30\n            o(0x4b0003c0 | l << 31 | x | a << 16); // sub\n        }\n        return 1;\n\n    case '^':\n        if (val == -1 || (val == 0xffffffff && !l)) {\n            o(0x2a2003e0 | l << 31 | x | a << 16); // mvn\n            return 1;\n        }\n        // fall through\n    case '&':\n    case '|': {\n        int e = arm64_encode_bimm64(l ? val : val | val << 32);\n        if (e < 0)\n            return 0;\n        o((op == '&' ? 0x12000000 :\n           op == '|' ? 0x32000000 : 0x52000000) |\n          l << 31 | x | a << 5 | (uint32_t)e << 10);\n        return 1;\n    }\n\n    case TOK_SAR:\n    case TOK_SHL:\n    case TOK_SHR: {\n        uint32_t n = 32 << l;\n        val = val & (n - 1);\n        if (rev)\n            return 0;\n        if (!val) {\n            // tcc_warning(\"shift count >= width of type\");\n            o(0x2a0003e0 | l << 31 | a << 16);\n            return 1;\n        }\n        else if (op == TOK_SHL)\n            o(0x53000000 | l << 31 | l << 22 | x | a << 5 |\n              (n - val) << 16 | (n - 1 - val) << 10); // lsl\n        else\n            o(0x13000000 | (op == TOK_SHR) << 30 | l << 31 | l << 22 |\n              x | a << 5 | val << 16 | (n - 1) << 10); // lsr/asr\n        return 1;\n    }\n\n    }\n    return 0;\n}\n\nstatic void arm64_gen_opil(int op, uint32_t l)\n{\n    uint32_t x, a, b;\n\n    // Special treatment for operations with a constant operand:\n    {\n        uint64_t val;\n        int rev = 1;\n\n        if (arm64_iconst(0, &vtop[0])) {\n            vswap();\n            rev = 0;\n        }\n        if (arm64_iconst(&val, &vtop[-1])) {\n            gv(RC_INT);\n            a = intr(vtop[0].r);\n            --vtop;\n            x = get_reg(RC_INT);\n            ++vtop;\n            if (arm64_gen_opic(op, l, rev, val, intr(x), a)) {\n                vtop[0].r = x;\n                vswap();\n                --vtop;\n                return;\n            }\n        }\n        if (!rev)\n            vswap();\n    }\n\n    gv2(RC_INT, RC_INT);\n    assert(vtop[-1].r < VT_CONST && vtop[0].r < VT_CONST);\n    a = intr(vtop[-1].r);\n    b = intr(vtop[0].r);\n    vtop -= 2;\n    x = get_reg(RC_INT);\n    ++vtop;\n    vtop[0].r = x;\n    x = intr(x);\n\n    switch (op) {\n    case '%':\n        // Use x30 for quotient:\n        o(0x1ac00c00 | l << 31 | 30 | a << 5 | b << 16); // sdiv\n        o(0x1b008000 | l << 31 | x | (uint32_t)30 << 5 |\n          b << 16 | a << 10); // msub\n        break;\n    case '&':\n        o(0x0a000000 | l << 31 | x | a << 5 | b << 16); // and\n        break;\n    case '*':\n        o(0x1b007c00 | l << 31 | x | a << 5 | b << 16); // mul\n        break;\n    case '+':\n        o(0x0b000000 | l << 31 | x | a << 5 | b << 16); // add\n        break;\n    case '-':\n        o(0x4b000000 | l << 31 | x | a << 5 | b << 16); // sub\n        break;\n    case '/':\n        o(0x1ac00c00 | l << 31 | x | a << 5 | b << 16); // sdiv\n        break;\n    case '^':\n        o(0x4a000000 | l << 31 | x | a << 5 | b << 16); // eor\n        break;\n    case '|':\n        o(0x2a000000 | l << 31 | x | a << 5 | b << 16); // orr\n        break;\n    case TOK_EQ:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9f17e0 | x); // cset wA,eq\n        break;\n    case TOK_GE:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9fb7e0 | x); // cset wA,ge\n        break;\n    case TOK_GT:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9fd7e0 | x); // cset wA,gt\n        break;\n    case TOK_LE:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9fc7e0 | x); // cset wA,le\n        break;\n    case TOK_LT:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9fa7e0 | x); // cset wA,lt\n        break;\n    case TOK_NE:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9f07e0 | x); // cset wA,ne\n        break;\n    case TOK_SAR:\n        o(0x1ac02800 | l << 31 | x | a << 5 | b << 16); // asr\n        break;\n    case TOK_SHL:\n        o(0x1ac02000 | l << 31 | x | a << 5 | b << 16); // lsl\n        break;\n    case TOK_SHR:\n        o(0x1ac02400 | l << 31 | x | a << 5 | b << 16); // lsr\n        break;\n    case TOK_UDIV:\n    case TOK_PDIV:\n        o(0x1ac00800 | l << 31 | x | a << 5 | b << 16); // udiv\n        break;\n    case TOK_UGE:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9f37e0 | x); // cset wA,cs\n        break;\n    case TOK_UGT:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9f97e0 | x); // cset wA,hi\n        break;\n    case TOK_ULT:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9f27e0 | x); // cset wA,cc\n        break;\n    case TOK_ULE:\n        o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp\n        o(0x1a9f87e0 | x); // cset wA,ls\n        break;\n    case TOK_UMOD:\n        // Use x30 for quotient:\n        o(0x1ac00800 | l << 31 | 30 | a << 5 | b << 16); // udiv\n        o(0x1b008000 | l << 31 | x | (uint32_t)30 << 5 |\n          b << 16 | a << 10); // msub\n        break;\n    default:\n        assert(0);\n    }\n}\n\nST_FUNC void gen_opi(int op)\n{\n    arm64_gen_opil(op, 0);\n    arm64_vset_VT_CMP(op);\n}\n\nST_FUNC void gen_opl(int op)\n{\n    arm64_gen_opil(op, 1);\n    arm64_vset_VT_CMP(op);\n}\n\nST_FUNC void gen_opf(int op)\n{\n    uint32_t x, a, b, dbl;\n\n    if (vtop[0].type.t == VT_LDOUBLE) {\n        CType type = vtop[0].type;\n        int func = 0;\n        int cond = -1;\n        switch (op) {\n        case '*': func = TOK___multf3; break;\n        case '+': func = TOK___addtf3; break;\n        case '-': func = TOK___subtf3; break;\n        case '/': func = TOK___divtf3; break;\n        case TOK_EQ: func = TOK___eqtf2; cond = 1; break;\n        case TOK_NE: func = TOK___netf2; cond = 0; break;\n        case TOK_LT: func = TOK___lttf2; cond = 10; break;\n        case TOK_GE: func = TOK___getf2; cond = 11; break;\n        case TOK_LE: func = TOK___letf2; cond = 12; break;\n        case TOK_GT: func = TOK___gttf2; cond = 13; break;\n        default: assert(0); break;\n        }\n        vpush_helper_func(func);\n        vrott(3);\n        gfunc_call(2);\n        vpushi(0);\n        vtop->r = cond < 0 ? REG_FRET : REG_IRET;\n        if (cond < 0)\n            vtop->type = type;\n        else {\n            o(0x7100001f); // cmp w0,#0\n            o(0x1a9f07e0 | (uint32_t)cond << 12); // cset w0,(cond)\n        }\n        return;\n    }\n\n    dbl = vtop[0].type.t != VT_FLOAT;\n    gv2(RC_FLOAT, RC_FLOAT);\n    assert(vtop[-1].r < VT_CONST && vtop[0].r < VT_CONST);\n    a = fltr(vtop[-1].r);\n    b = fltr(vtop[0].r);\n    vtop -= 2;\n    switch (op) {\n    case TOK_EQ: case TOK_NE:\n    case TOK_LT: case TOK_GE: case TOK_LE: case TOK_GT:\n        x = get_reg(RC_INT);\n        ++vtop;\n        vtop[0].r = x;\n        x = intr(x);\n        break;\n    default:\n        x = get_reg(RC_FLOAT);\n        ++vtop;\n        vtop[0].r = x;\n        x = fltr(x);\n        break;\n    }\n\n    switch (op) {\n    case '*':\n        o(0x1e200800 | dbl << 22 | x | a << 5 | b << 16); // fmul\n        break;\n    case '+':\n        o(0x1e202800 | dbl << 22 | x | a << 5 | b << 16); // fadd\n        break;\n    case '-':\n        o(0x1e203800 | dbl << 22 | x | a << 5 | b << 16); // fsub\n        break;\n    case '/':\n        o(0x1e201800 | dbl << 22 | x | a << 5 | b << 16); // fdiv\n        break;\n    case TOK_EQ:\n        o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp\n        o(0x1a9f17e0 | x); // cset w(x),eq\n        break;\n    case TOK_GE:\n        o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp\n        o(0x1a9fb7e0 | x); // cset w(x),ge\n        break;\n    case TOK_GT:\n        o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp\n        o(0x1a9fd7e0 | x); // cset w(x),gt\n        break;\n    case TOK_LE:\n        o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp\n        o(0x1a9f87e0 | x); // cset w(x),ls\n        break;\n    case TOK_LT:\n        o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp\n        o(0x1a9f57e0 | x); // cset w(x),mi\n        break;\n    case TOK_NE:\n        o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp\n        o(0x1a9f07e0 | x); // cset w(x),ne\n        break;\n    default:\n        assert(0);\n    }\n    arm64_vset_VT_CMP(op);\n}\n\n// Generate sign extension from 32 to 64 bits:\nST_FUNC void gen_cvt_sxtw(void)\n{\n    uint32_t r = intr(gv(RC_INT));\n    o(0x93407c00 | r | r << 5); // sxtw x(r),w(r)\n}\n\n/* char/short to int conversion */\nST_FUNC void gen_cvt_csti(int t)\n{\n    int r = intr(gv(RC_INT));\n    o(0x13001c00\n        | ((t & VT_BTYPE) == VT_SHORT) << 13\n        | (uint32_t)!!(t & VT_UNSIGNED) << 30\n        | r | r << 5); // [su]xt[bh] w(r),w(r)\n}\n\nST_FUNC void gen_cvt_itof(int t)\n{\n    if (t == VT_LDOUBLE) {\n        int f = vtop->type.t;\n        int func = (f & VT_BTYPE) == VT_LLONG ?\n          (f & VT_UNSIGNED ? TOK___floatunditf : TOK___floatditf) :\n          (f & VT_UNSIGNED ? TOK___floatunsitf : TOK___floatsitf);\n        vpush_helper_func(func);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->type.t = t;\n        vtop->r = REG_FRET;\n        return;\n    }\n    else {\n        int d, n = intr(gv(RC_INT));\n        int s = !(vtop->type.t & VT_UNSIGNED);\n        uint32_t l = ((vtop->type.t & VT_BTYPE) == VT_LLONG);\n        --vtop;\n        d = get_reg(RC_FLOAT);\n        ++vtop;\n        vtop[0].r = d;\n        o(0x1e220000 | (uint32_t)!s << 16 |\n          (uint32_t)(t != VT_FLOAT) << 22 | fltr(d) |\n          l << 31 | n << 5); // [us]cvtf [sd](d),[wx](n)\n    }\n}\n\nST_FUNC void gen_cvt_ftoi(int t)\n{\n    if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE) {\n        int func = (t & VT_BTYPE) == VT_LLONG ?\n          (t & VT_UNSIGNED ? TOK___fixunstfdi : TOK___fixtfdi) :\n          (t & VT_UNSIGNED ? TOK___fixunstfsi : TOK___fixtfsi);\n        vpush_helper_func(func);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->type.t = t;\n        vtop->r = REG_IRET;\n        return;\n    }\n    else {\n        int d, n = fltr(gv(RC_FLOAT));\n        uint32_t l = ((vtop->type.t & VT_BTYPE) != VT_FLOAT);\n        --vtop;\n        d = get_reg(RC_INT);\n        ++vtop;\n        vtop[0].r = d;\n        o(0x1e380000 |\n          (uint32_t)!!(t & VT_UNSIGNED) << 16 |\n          (uint32_t)((t & VT_BTYPE) == VT_LLONG) << 31 | intr(d) |\n          l << 22 | n << 5); // fcvtz[su] [wx](d),[sd](n)\n    }\n}\n\nST_FUNC void gen_cvt_ftof(int t)\n{\n    int f = vtop[0].type.t & VT_BTYPE;\n    assert(t == VT_FLOAT || t == VT_DOUBLE || t == VT_LDOUBLE);\n    assert(f == VT_FLOAT || f == VT_DOUBLE || f == VT_LDOUBLE);\n    if (t == f)\n        return;\n\n    if (t == VT_LDOUBLE || f == VT_LDOUBLE) {\n        int func = (t == VT_LDOUBLE) ?\n            (f == VT_FLOAT ? TOK___extendsftf2 : TOK___extenddftf2) :\n            (t == VT_FLOAT ? TOK___trunctfsf2 : TOK___trunctfdf2);\n        vpush_helper_func(func);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->type.t = t;\n        vtop->r = REG_FRET;\n    }\n    else {\n        int x, a;\n        gv(RC_FLOAT);\n        assert(vtop[0].r < VT_CONST);\n        a = fltr(vtop[0].r);\n        --vtop;\n        x = get_reg(RC_FLOAT);\n        ++vtop;\n        vtop[0].r = x;\n        x = fltr(x);\n\n        if (f == VT_FLOAT)\n            o(0x1e22c000 | x | a << 5); // fcvt d(x),s(a)\n        else\n            o(0x1e624000 | x | a << 5); // fcvt s(x),d(a)\n    }\n}\n\n/* increment tcov counter */\nST_FUNC void gen_increment_tcov (SValue *sv)\n{\n    int r1, r2;\n\n    vpushv(sv);\n    vtop->r = r1 = get_reg(RC_INT);\n    r2 = get_reg(RC_INT);\n    greloca(cur_text_section, sv->sym, ind, R_AARCH64_ADR_GOT_PAGE, 0);\n    o(0x90000000 | r1);            // adrp r1, #sym\n    greloca(cur_text_section, sv->sym, ind, R_AARCH64_LD64_GOT_LO12_NC, 0);\n    o(0xf9400000 | r1 | (r1 << 5)); // ld xr,[xr, #sym]\n    o(0xf9400000 | (intr(r1)<<5) | intr(r2)); // ldr r2, [r1]\n    o(0x91000400 | (intr(r2)<<5) | intr(r2)); // add r2, r2, #1\n    o(0xf9000000 | (intr(r1)<<5) | intr(r2)); // str r2, [r1]\n    vpop();\n}\n\nST_FUNC void ggoto(void)\n{\n    arm64_gen_bl_or_b(1);\n    --vtop;\n}\n\nST_FUNC void gen_clear_cache(void)\n{\n    uint32_t beg, end, dsz, isz, p, lab1, b1;\n    gv2(RC_INT, RC_INT);\n    vpushi(0);\n    vtop->r = get_reg(RC_INT);\n    vpushi(0);\n    vtop->r = get_reg(RC_INT);\n    vpushi(0);\n    vtop->r = get_reg(RC_INT);\n    beg = intr(vtop[-4].r); // x0\n    end = intr(vtop[-3].r); // x1\n    dsz = intr(vtop[-2].r); // x2\n    isz = intr(vtop[-1].r); // x3\n    p = intr(vtop[0].r);    // x4\n    vtop -= 5;\n\n    o(0xd53b0020 | isz); // mrs x(isz),ctr_el0\n    o(0x52800080 | p); // mov w(p),#4\n    o(0x53104c00 | dsz | isz << 5); // ubfx w(dsz),w(isz),#16,#4\n    o(0x1ac02000 | dsz | p << 5 | dsz << 16); // lsl w(dsz),w(p),w(dsz)\n    o(0x12000c00 | isz | isz << 5); // and w(isz),w(isz),#15\n    o(0x1ac02000 | isz | p << 5 | isz << 16); // lsl w(isz),w(p),w(isz)\n    o(0x51000400 | p | dsz << 5); // sub w(p),w(dsz),#1\n    o(0x8a240004 | p | beg << 5 | p << 16); // bic x(p),x(beg),x(p)\n    b1 = ind; o(0x14000000); // b\n    lab1 = ind;\n    o(0xd50b7b20 | p); // dc cvau,x(p)\n    o(0x8b000000 | p | p << 5 | dsz << 16); // add x(p),x(p),x(dsz)\n    write32le(cur_text_section->data + b1, 0x14000000 | (ind - b1) >> 2);\n    o(0xeb00001f | p << 5 | end << 16); // cmp x(p),x(end)\n    o(0x54ffffa3 | ((lab1 - ind) << 3 & 0xffffe0)); // b.cc lab1\n    o(0xd5033b9f); // dsb ish\n    o(0x51000400 | p | isz << 5); // sub w(p),w(isz),#1\n    o(0x8a240004 | p | beg << 5 | p << 16); // bic x(p),x(beg),x(p)\n    b1 = ind; o(0x14000000); // b\n    lab1 = ind;\n    o(0xd50b7520 | p); // ic ivau,x(p)\n    o(0x8b000000 | p | p << 5 | isz << 16); // add x(p),x(p),x(isz)\n    write32le(cur_text_section->data + b1, 0x14000000 | (ind - b1) >> 2);\n    o(0xeb00001f | p << 5 | end << 16); // cmp x(p),x(end)\n    o(0x54ffffa3 | ((lab1 - ind) << 3 & 0xffffe0)); // b.cc lab1\n    o(0xd5033b9f); // dsb ish\n    o(0xd5033fdf); // isb\n}\n\nST_FUNC void gen_vla_sp_save(int addr) {\n    uint32_t r = intr(get_reg(RC_INT));\n    o(0x910003e0 | r); // mov x(r),sp\n    arm64_strx(3, r, 29, addr);\n}\n\nST_FUNC void gen_vla_sp_restore(int addr) {\n    // Use x30 because this function can be called when there\n    // is a live return value in x0 but there is nothing on\n    // the value stack to prevent get_reg from returning x0.\n    uint32_t r = 30;\n    arm64_ldrx(0, 3, r, 29, addr);\n    o(0x9100001f | r << 5); // mov sp,x(r)\n}\n\nST_FUNC void gen_vla_alloc(CType *type, int align) {\n    uint32_t r;\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check)\n        vpushv(vtop);\n#endif\n    r = intr(gv(RC_INT));\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check)\n        o(0x91004000 | r | r << 5); // add x(r),x(r),#15+1\n    else\n#endif\n    o(0x91003c00 | r | r << 5); // add x(r),x(r),#15\n    o(0x927cec00 | r | r << 5); // bic x(r),x(r),#15\n    o(0xcb2063ff | r << 16); // sub sp,sp,x(r)\n    vpop();\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check) {\n        vpushi(0);\n        vtop->r = TREG_R(0);\n        o(0x910003e0 | vtop->r); // mov r0,sp\n        vswap();\n        vpush_helper_func(TOK___bound_new_region);\n        vrott(3);\n        gfunc_call(2);\n        func_bound_add_epilog = 1;\n    }\n#endif\n}\n\n/* end of A64 code generator */\n/*************************************************************/\n#endif\n/*************************************************************/\n"
        },
        {
          "name": "arm64-link.c",
          "type": "blob",
          "size": 11.28515625,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n#define EM_TCC_TARGET EM_AARCH64\n\n#define R_DATA_32  R_AARCH64_ABS32\n#define R_DATA_PTR R_AARCH64_ABS64\n#define R_JMP_SLOT R_AARCH64_JUMP_SLOT\n#define R_GLOB_DAT R_AARCH64_GLOB_DAT\n#define R_COPY     R_AARCH64_COPY\n#define R_RELATIVE R_AARCH64_RELATIVE\n\n#define R_NUM      R_AARCH64_NUM\n\n#define ELF_START_ADDR 0x00400000\n#define ELF_PAGE_SIZE 0x10000\n\n#define PCRELATIVE_DLLPLT 1\n#define RELOCATE_DLLPLT 1\n\n#else /* !TARGET_DEFS_ONLY */\n\n#include \"tcc.h\"\n\n#ifdef NEED_RELOC_TYPE\n/* Returns 1 for a code relocation, 0 for a data relocation. For unknown\n   relocations, returns -1. */\nST_FUNC int code_reloc (int reloc_type)\n{\n    switch (reloc_type) {\n        case R_AARCH64_ABS32:\n        case R_AARCH64_ABS64:\n\tcase R_AARCH64_PREL32:\n        case R_AARCH64_MOVW_UABS_G0_NC:\n        case R_AARCH64_MOVW_UABS_G1_NC:\n        case R_AARCH64_MOVW_UABS_G2_NC:\n        case R_AARCH64_MOVW_UABS_G3:\n        case R_AARCH64_ADR_PREL_PG_HI21:\n        case R_AARCH64_ADD_ABS_LO12_NC:\n        case R_AARCH64_ADR_GOT_PAGE:\n        case R_AARCH64_LD64_GOT_LO12_NC:\n        case R_AARCH64_LDST128_ABS_LO12_NC:\n        case R_AARCH64_LDST64_ABS_LO12_NC:\n        case R_AARCH64_LDST32_ABS_LO12_NC:\n        case R_AARCH64_LDST16_ABS_LO12_NC:\n        case R_AARCH64_LDST8_ABS_LO12_NC:\n        case R_AARCH64_GLOB_DAT:\n        case R_AARCH64_COPY:\n            return 0;\n\n        case R_AARCH64_JUMP26:\n        case R_AARCH64_CALL26:\n        case R_AARCH64_JUMP_SLOT:\n            return 1;\n    }\n    return -1;\n}\n\n/* Returns an enumerator to describe whether and when the relocation needs a\n   GOT and/or PLT entry to be created. See tcc.h for a description of the\n   different values. */\nST_FUNC int gotplt_entry_type (int reloc_type)\n{\n    switch (reloc_type) {\n\tcase R_AARCH64_PREL32:\n        case R_AARCH64_MOVW_UABS_G0_NC:\n        case R_AARCH64_MOVW_UABS_G1_NC:\n        case R_AARCH64_MOVW_UABS_G2_NC:\n        case R_AARCH64_MOVW_UABS_G3:\n        case R_AARCH64_ADR_PREL_PG_HI21:\n        case R_AARCH64_ADD_ABS_LO12_NC:\n        case R_AARCH64_LDST128_ABS_LO12_NC:\n        case R_AARCH64_LDST64_ABS_LO12_NC:\n        case R_AARCH64_LDST32_ABS_LO12_NC:\n        case R_AARCH64_LDST16_ABS_LO12_NC:\n        case R_AARCH64_LDST8_ABS_LO12_NC:\n        case R_AARCH64_GLOB_DAT:\n        case R_AARCH64_JUMP_SLOT:\n        case R_AARCH64_COPY:\n            return NO_GOTPLT_ENTRY;\n\n        case R_AARCH64_ABS32:\n        case R_AARCH64_ABS64:\n        case R_AARCH64_JUMP26:\n        case R_AARCH64_CALL26:\n            return AUTO_GOTPLT_ENTRY;\n\n        case R_AARCH64_ADR_GOT_PAGE:\n        case R_AARCH64_LD64_GOT_LO12_NC:\n            return ALWAYS_GOTPLT_ENTRY;\n    }\n    return -1;\n}\n\n#ifdef NEED_BUILD_GOT\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)\n{\n    Section *plt = s1->plt;\n    uint8_t *p;\n    unsigned plt_offset;\n\n    if (plt->data_offset == 0) {\n        section_ptr_add(plt, 32);\n    }\n    plt_offset = plt->data_offset;\n\n    p = section_ptr_add(plt, 16);\n    write32le(p, got_offset);\n    write32le(p + 4, (uint64_t) got_offset >> 32);\n    return plt_offset;\n}\n\n/* relocate the PLT: compute addresses and offsets in the PLT now that final\n   address for PLT and GOT are known (see fill_program_header) */\nST_FUNC void relocate_plt(TCCState *s1)\n{\n    uint8_t *p, *p_end;\n\n    if (!s1->plt)\n      return;\n\n    p = s1->plt->data;\n    p_end = p + s1->plt->data_offset;\n\n    if (p < p_end) {\n        uint64_t plt = s1->plt->sh_addr;\n        uint64_t got = s1->got->sh_addr + 16;\n        uint64_t off = (got >> 12) - (plt >> 12);\n        if ((off + ((uint32_t)1 << 20)) >> 21)\n            tcc_error_noabort(\"Failed relocating PLT (off=0x%lx, got=0x%lx, plt=0x%lx)\", (long)off, (long)got, (long)plt);\n        write32le(p, 0xa9bf7bf0); // stp x16,x30,[sp,#-16]!\n        write32le(p + 4, (0x90000010 | // adrp x16,...\n\t\t\t  (off & 0x1ffffc) << 3 | (off & 3) << 29));\n        write32le(p + 8, (0xf9400211 | // ldr x17,[x16,#...]\n\t\t\t  (got & 0xff8) << 7));\n        write32le(p + 12, (0x91000210 | // add x16,x16,#...\n\t\t\t   (got & 0xfff) << 10));\n        write32le(p + 16, 0xd61f0220); // br x17\n        write32le(p + 20, 0xd503201f); // nop\n        write32le(p + 24, 0xd503201f); // nop\n        write32le(p + 28, 0xd503201f); // nop\n        p += 32;\n\tgot = s1->got->sh_addr;\n        while (p < p_end) {\n            uint64_t pc = plt + (p - s1->plt->data);\n            uint64_t addr = got + read64le(p);\n            uint64_t off = (addr >> 12) - (pc >> 12);\n            if ((off + ((uint32_t)1 << 20)) >> 21)\n                tcc_error_noabort(\"Failed relocating PLT (off=0x%lx, addr=0x%lx, pc=0x%lx)\", (long)off, (long)addr, (long)pc);\n            write32le(p, (0x90000010 | // adrp x16,...\n\t\t\t  (off & 0x1ffffc) << 3 | (off & 3) << 29));\n            write32le(p + 4, (0xf9400211 | // ldr x17,[x16,#...]\n\t\t\t      (addr & 0xff8) << 7));\n            write32le(p + 8, (0x91000210 | // add x16,x16,#...\n\t\t\t      (addr & 0xfff) << 10));\n            write32le(p + 12, 0xd61f0220); // br x17\n            p += 16;\n        }\n    }\n\n    if (s1->plt->reloc) {\n        ElfW_Rel *rel;\n        p = s1->got->data;\n        for_each_elem(s1->plt->reloc, 0, rel, ElfW_Rel) {\n            write64le(p + rel->r_offset, s1->plt->sh_addr);\n\t}\n    }\n}\n#endif\n#endif\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)\n{\n    int sym_index = ELFW(R_SYM)(rel->r_info), esym_index;\n#ifdef DEBUG_RELOC\n    ElfW(Sym) *sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n#endif\n\n    switch(type) {\n        case R_AARCH64_ABS64:\n            if ((s1->output_type & TCC_OUTPUT_DYN)) {\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                qrel->r_offset = rel->r_offset;\n                if (esym_index) {\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_AARCH64_ABS64);\n                    qrel->r_addend = rel->r_addend;\n                    qrel++;\n                    break;\n                } else {\n                    qrel->r_info = ELFW(R_INFO)(0, R_AARCH64_RELATIVE);\n                    qrel->r_addend = read64le(ptr) + val;\n                    qrel++;\n                }\n            }\n            add64le(ptr, val);\n            return;\n        case R_AARCH64_ABS32:\n            if (s1->output_type & TCC_OUTPUT_DYN) {\n                /* XXX: this logic may depend on TCC's codegen\n                   now TCC uses R_AARCH64_RELATIVE even for a 64bit pointer */\n                qrel->r_offset = rel->r_offset;\n                qrel->r_info = ELFW(R_INFO)(0, R_AARCH64_RELATIVE);\n                /* Use sign extension! */\n                qrel->r_addend = (int)read32le(ptr) + val;\n                qrel++;\n            }\n            add32le(ptr, val);\n            return;\n\tcase R_AARCH64_PREL32:\n            if (s1->output_type == TCC_OUTPUT_DLL) {\n                /* DLL relocation */\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                if (esym_index) {\n                    qrel->r_offset = rel->r_offset;\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_AARCH64_PREL32);\n                    /* Use sign extension! */\n                    qrel->r_addend = (int)read32le(ptr) + rel->r_addend;\n                    qrel++;\n                    break;\n                }\n            }\n\t    add32le(ptr, val - addr);\n\t    return;\n        case R_AARCH64_MOVW_UABS_G0_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffe0001f) |\n                            (val & 0xffff) << 5));\n            return;\n        case R_AARCH64_MOVW_UABS_G1_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffe0001f) |\n                            (val >> 16 & 0xffff) << 5));\n            return;\n        case R_AARCH64_MOVW_UABS_G2_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffe0001f) |\n                            (val >> 32 & 0xffff) << 5));\n            return;\n        case R_AARCH64_MOVW_UABS_G3:\n            write32le(ptr, ((read32le(ptr) & 0xffe0001f) |\n                            (val >> 48 & 0xffff) << 5));\n            return;\n        case R_AARCH64_ADR_PREL_PG_HI21: {\n            uint64_t off = (val >> 12) - (addr >> 12);\n            if ((off + ((uint64_t)1 << 20)) >> 21)\n                tcc_error_noabort(\"R_AARCH64_ADR_PREL_PG_HI21 relocation failed\");\n            write32le(ptr, ((read32le(ptr) & 0x9f00001f) |\n                            (off & 0x1ffffc) << 3 | (off & 3) << 29));\n            return;\n        }\n        case R_AARCH64_ADD_ABS_LO12_NC:\n        case R_AARCH64_LDST8_ABS_LO12_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffc003ff) |\n                            (val & 0xfff) << 10));\n            return;\n        case R_AARCH64_LDST16_ABS_LO12_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffc003ff) |\n                            (val & 0xffe) << 9));\n            return;\n        case R_AARCH64_LDST32_ABS_LO12_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffc003ff) |\n                            (val & 0xffc) << 8));\n            return;\n        case R_AARCH64_LDST64_ABS_LO12_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffc003ff) |\n                            (val & 0xff8) << 7));\n            return;\n        case R_AARCH64_LDST128_ABS_LO12_NC:\n            write32le(ptr, ((read32le(ptr) & 0xffc003ff) |\n                            (val & 0xff0) << 6));\n            return;\n        case R_AARCH64_JUMP26:\n        case R_AARCH64_CALL26:\n#ifdef DEBUG_RELOC\n\t    printf (\"reloc %d @ 0x%lx: val=0x%lx name=%s\\n\", type, addr, val,\n\t\t    (char *) symtab_section->link->data + sym->st_name);\n#endif\n            if (((val - addr) + ((uint64_t)1 << 27)) & ~(uint64_t)0xffffffc)\n                tcc_error_noabort(\"R_AARCH64_(JUMP|CALL)26 relocation failed\"\n                          \" (val=%lx, addr=%lx)\", (long)val, (long)addr);\n            write32le(ptr, (0x14000000 |\n                            (uint32_t)(type == R_AARCH64_CALL26) << 31 |\n                            ((val - addr) >> 2 & 0x3ffffff)));\n            return;\n        case R_AARCH64_ADR_GOT_PAGE: {\n            uint64_t off =\n                (((s1->got->sh_addr +\n                   get_sym_attr(s1, sym_index, 0)->got_offset) >> 12) - (addr >> 12));\n            if ((off + ((uint64_t)1 << 20)) >> 21)\n                tcc_error_noabort(\"R_AARCH64_ADR_GOT_PAGE relocation failed\");\n            write32le(ptr, ((read32le(ptr) & 0x9f00001f) |\n                            (off & 0x1ffffc) << 3 | (off & 3) << 29));\n            return;\n        }\n        case R_AARCH64_LD64_GOT_LO12_NC:\n            write32le(ptr,\n                      ((read32le(ptr) & 0xfff803ff) |\n                       ((s1->got->sh_addr +\n                         get_sym_attr(s1, sym_index, 0)->got_offset) & 0xff8) << 7));\n            return;\n        case R_AARCH64_COPY:\n            return;\n        case R_AARCH64_GLOB_DAT:\n        case R_AARCH64_JUMP_SLOT:\n            /* They don't need addend */\n#ifdef DEBUG_RELOC\n\t    printf (\"reloc %d @ 0x%lx: val=0x%lx name=%s\\n\", type, addr,\n\t\t    val - rel->r_addend,\n\t\t    (char *) symtab_section->link->data + sym->st_name);\n#endif\n            write64le(ptr, val - rel->r_addend);\n            return;\n        case R_AARCH64_RELATIVE:\n#ifdef TCC_TARGET_PE\n            add32le(ptr, val - s1->pe_imagebase);\n#endif\n            /* do nothing */\n            return;\n        default:\n            fprintf(stderr, \"FIXME: handle reloc type %x at %x [%p] to %x\\n\",\n                    type, (unsigned)addr, ptr, (unsigned)val);\n            return;\n    }\n}\n\n#endif /* !TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "c67-gen.c",
          "type": "blob",
          "size": 69.37890625,
          "content": "/*\n *  TMS320C67xx code generator for TCC\n * \n *  Copyright (c) 2001, 2002 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n/* #define ASSEMBLY_LISTING_C67 */\n\n/* number of available registers */\n#define NB_REGS            24\n\n/* a register can belong to several classes. The classes must be\n   sorted from more general to more precise (see gv2() code which does\n   assumptions on it). */\n#define RC_INT     0x0001\t/* generic integer register */\n#define RC_FLOAT   0x0002\t/* generic float register */\n#define RC_EAX     0x0004\n#define RC_ST0     0x0008\n#define RC_ECX     0x0010\n#define RC_EDX     0x0020\n#define RC_INT_BSIDE  0x00000040\t/* generic integer register  on b side */\n#define RC_C67_A4     0x00000100\n#define RC_C67_A5     0x00000200\n#define RC_C67_B4     0x00000400\n#define RC_C67_B5     0x00000800\n#define RC_C67_A6     0x00001000\n#define RC_C67_A7     0x00002000\n#define RC_C67_B6     0x00004000\n#define RC_C67_B7     0x00008000\n#define RC_C67_A8     0x00010000\n#define RC_C67_A9     0x00020000\n#define RC_C67_B8     0x00040000\n#define RC_C67_B9     0x00080000\n#define RC_C67_A10    0x00100000\n#define RC_C67_A11    0x00200000\n#define RC_C67_B10    0x00400000\n#define RC_C67_B11    0x00800000\n#define RC_C67_A12    0x01000000\n#define RC_C67_A13    0x02000000\n#define RC_C67_B12    0x04000000\n#define RC_C67_B13    0x08000000\n#define RC_IRET    RC_C67_A4\t/* function return: integer register */\n#define RC_IRE2    RC_C67_A5\t/* function return: second integer register */\n#define RC_FRET    RC_C67_A4\t/* function return: float register */\n\n/* pretty names for the registers */\nenum {\n    TREG_EAX = 0,\t\t// really A2\n    TREG_ECX,\t\t\t// really A3\n    TREG_EDX,\t\t\t// really B0\n    TREG_ST0,\t\t\t// really B1\n    TREG_C67_A4,\n    TREG_C67_A5,\n    TREG_C67_B4,\n    TREG_C67_B5,\n    TREG_C67_A6,\n    TREG_C67_A7,\n    TREG_C67_B6,\n    TREG_C67_B7,\n    TREG_C67_A8,\n    TREG_C67_A9,\n    TREG_C67_B8,\n    TREG_C67_B9,\n    TREG_C67_A10,\n    TREG_C67_A11,\n    TREG_C67_B10,\n    TREG_C67_B11,\n    TREG_C67_A12,\n    TREG_C67_A13,\n    TREG_C67_B12,\n    TREG_C67_B13,\n};\n\n/* return registers for function */\n#define REG_IRET TREG_C67_A4\t/* single word int return register */\n#define REG_IRE2 TREG_C67_A5    /* second word return register (for long long) */\n#define REG_FRET TREG_C67_A4\t/* float return register */\n\n/* defined if function parameters must be evaluated in reverse order */\n/* #define INVERT_FUNC_PARAMS */\n\n/* defined if structures are passed as pointers. Otherwise structures\n   are directly pushed on stack. */\n/* #define FUNC_STRUCT_PARAM_AS_PTR */\n\n/* pointer size, in bytes */\n#define PTR_SIZE 4\n\n/* long double size and alignment, in bytes */\n#define LDOUBLE_SIZE  12\n#define LDOUBLE_ALIGN 4\n/* maximum alignment (for aligned attribute support) */\n#define MAX_ALIGN     8\n\n#undef CONFIG_TCC_BCHECK\n\n/******************************************************/\n#else /* ! TARGET_DEFS_ONLY */\n/******************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n\nST_DATA const char * const target_machine_defs =\n    \"__C67__\\0\"\n    ;\n\nST_DATA const int reg_classes[NB_REGS] = {\n    /* eax */ RC_INT | RC_FLOAT | RC_EAX,\n    // only allow even regs for floats (allow for doubles)\n    /* ecx */ RC_INT | RC_ECX,\n    /* edx */ RC_INT | RC_INT_BSIDE | RC_FLOAT | RC_EDX,\n    // only allow even regs for floats (allow for doubles)\n    /* st0 */ RC_INT | RC_INT_BSIDE | RC_ST0,\n    /* A4  */ RC_C67_A4,\n    /* A5  */ RC_C67_A5,\n    /* B4  */ RC_C67_B4,\n    /* B5  */ RC_C67_B5,\n    /* A6  */ RC_C67_A6,\n    /* A7  */ RC_C67_A7,\n    /* B6  */ RC_C67_B6,\n    /* B7  */ RC_C67_B7,\n    /* A8  */ RC_C67_A8,\n    /* A9  */ RC_C67_A9,\n    /* B8  */ RC_C67_B8,\n    /* B9  */ RC_C67_B9,\n    /* A10  */ RC_C67_A10,\n    /* A11  */ RC_C67_A11,\n    /* B10  */ RC_C67_B10,\n    /* B11  */ RC_C67_B11,\n    /* A12  */ RC_C67_A10,\n    /* A13  */ RC_C67_A11,\n    /* B12  */ RC_C67_B10,\n    /* B13  */ RC_C67_B11\n};\n\n// although tcc thinks it is passing parameters on the stack,\n// the C67 really passes up to the first 10 params in special\n// regs or regs pairs (for 64 bit params).  So keep track of\n// the stack offsets so we can translate to the appropriate \n// reg (pair)\n\n#define NoCallArgsPassedOnStack 10\nint NoOfCurFuncArgs;\nint TranslateStackToReg[NoCallArgsPassedOnStack];\nint ParamLocOnStack[NoCallArgsPassedOnStack];\nint TotalBytesPushedOnStack;\n\n#ifndef FALSE\n# define FALSE 0\n# define TRUE 1\n#endif\n\n#undef BOOL\n#define BOOL int\n\n#define ALWAYS_ASSERT(x) \\\ndo {\\\n   if (!(x))\\\n       tcc_error(\"internal compiler error file at %s:%d\", __FILE__, __LINE__);\\\n} while (0)\n\n/******************************************************/\nstatic unsigned long func_sub_sp_offset;\nstatic int func_ret_sub;\n\nstatic BOOL C67_invert_test;\nstatic int C67_compare_reg;\n\n#ifdef ASSEMBLY_LISTING_C67\nFILE *f = NULL;\n#endif\n\nvoid C67_g(int c)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n#ifdef ASSEMBLY_LISTING_C67\n    fprintf(f, \" %08X\", c);\n#endif\n    ind1 = ind + 4;\n    if (ind1 > (int) cur_text_section->data_allocated)\n\tsection_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c & 0xff;\n    cur_text_section->data[ind + 1] = (c >> 8) & 0xff;\n    cur_text_section->data[ind + 2] = (c >> 16) & 0xff;\n    cur_text_section->data[ind + 3] = (c >> 24) & 0xff;\n    ind = ind1;\n}\n\n\n/* output a symbol and patch all calls to it */\nvoid gsym_addr(int t, int a)\n{\n    int n, *ptr;\n    while (t) {\n\tptr = (int *) (cur_text_section->data + t);\n\t{\n\t    Sym *sym;\n\n\t    // extract 32 bit address from MVKH/MVKL\n\t    n = ((*ptr >> 7) & 0xffff);\n\t    n |= ((*(ptr + 1) >> 7) & 0xffff) << 16;\n\n\t    // define a label that will be relocated\n\n\t    sym = get_sym_ref(&char_pointer_type, cur_text_section, a, 0);\n\t    greloc(cur_text_section, sym, t, R_C60LO16);\n\t    greloc(cur_text_section, sym, t + 4, R_C60HI16);\n\n\t    // clear out where the pointer was\n\n\t    *ptr &= ~(0xffff << 7);\n\t    *(ptr + 1) &= ~(0xffff << 7);\n\t}\n\tt = n;\n    }\n}\n\n// these are regs that tcc doesn't really know about, \n// but assign them unique values so the mapping routines\n// can distinguish them\n\n#define C67_A0 105\n#define C67_SP 106\n#define C67_B3 107\n#define C67_FP 108\n#define C67_B2 109\n#define C67_CREG_ZERO -1\t/* Special code for no condition reg test */\n\n\nint ConvertRegToRegClass(int r)\n{\n    // only works for A4-B13\n\n    return RC_C67_A4 << (r - TREG_C67_A4);\n}\n\n\n// map TCC reg to C67 reg number\n\nint C67_map_regn(int r)\n{\n    if (r == 0)\t\t\t// normal tcc regs\n\treturn 0x2;\t\t// A2\n    else if (r == 1)\t\t// normal tcc regs\n\treturn 3;\t\t// A3\n    else if (r == 2)\t\t// normal tcc regs\n\treturn 0;\t\t// B0\n    else if (r == 3)\t\t// normal tcc regs\n\treturn 1;\t\t// B1\n    else if (r >= TREG_C67_A4 && r <= TREG_C67_B13)\t// these form a pattern of alt pairs\n\treturn (((r & 0xfffffffc) >> 1) | (r & 1)) + 2;\n    else if (r == C67_A0)\n\treturn 0;\t\t// set to A0 (offset reg)\n    else if (r == C67_B2)\n\treturn 2;\t\t// set to B2 (offset reg)\n    else if (r == C67_B3)\n\treturn 3;\t\t// set to B3 (return address reg)\n    else if (r == C67_SP)\n\treturn 15;\t\t// set to SP (B15) (offset reg)\n    else if (r == C67_FP)\n\treturn 15;\t\t// set to FP (A15) (offset reg)\n    else if (r == C67_CREG_ZERO)\n\treturn 0;\t\t// Special code for no condition reg test\n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}\n\n// mapping from tcc reg number to \n// C67 register to condition code field\n//\n// valid condition code regs are:\n//\n// tcc reg 2 ->B0 -> 1\n// tcc reg 3 ->B1 -> 2\n// tcc reg 0 -> A2 -> 5\n// tcc reg 1 -> A3 -> X\n// tcc reg      B2 -> 3\n\nint C67_map_regc(int r)\n{\n    if (r == 0)\t\t\t// normal tcc regs\n\treturn 0x5;\n    else if (r == 2)\t\t// normal tcc regs\n\treturn 0x1;\n    else if (r == 3)\t\t// normal tcc regs\n\treturn 0x2;\n    else if (r == C67_B2)\t// normal tcc regs\n\treturn 0x3;\n    else if (r == C67_CREG_ZERO)\n\treturn 0;\t\t// Special code for no condition reg test\n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}\n\n\n// map TCC reg to C67 reg side A or B\n\nint C67_map_regs(int r)\n{\n    if (r == 0)\t\t\t// normal tcc regs\n\treturn 0x0;\n    else if (r == 1)\t\t// normal tcc regs\n\treturn 0x0;\n    else if (r == 2)\t\t// normal tcc regs\n\treturn 0x1;\n    else if (r == 3)\t\t// normal tcc regs\n\treturn 0x1;\n    else if (r >= TREG_C67_A4 && r <= TREG_C67_B13)\t// these form a pattern of alt pairs\n\treturn (r & 2) >> 1;\n    else if (r == C67_A0)\n\treturn 0;\t\t// set to A side \n    else if (r == C67_B2)\n\treturn 1;\t\t// set to B side \n    else if (r == C67_B3)\n\treturn 1;\t\t// set to B side\n    else if (r == C67_SP)\n\treturn 0x1;\t\t// set to SP (B15) B side \n    else if (r == C67_FP)\n\treturn 0x0;\t\t// set to FP (A15) A side \n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}\n\nint C67_map_S12(char *s)\n{\n    if (strstr(s, \".S1\") != NULL)\n\treturn 0;\n    else if (strcmp(s, \".S2\"))\n\treturn 1;\n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}\n\nint C67_map_D12(char *s)\n{\n    if (strstr(s, \".D1\") != NULL)\n\treturn 0;\n    else if (strcmp(s, \".D2\"))\n\treturn 1;\n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}\n\n\n\nvoid C67_asm(const char *s, int a, int b, int c)\n{\n    BOOL xpath;\n\n#ifdef ASSEMBLY_LISTING_C67\n    if (!f) {\n\tf = fopen(\"TCC67_out.txt\", \"wt\");\n    }\n    fprintf(f, \"%04X \", ind);\n#endif\n\n    if (strstr(s, \"MVKL\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\n\t      ((a & 0xffff) << 7) | (0x0a << 2) | (C67_map_regs(b) << 1));\n    } else if (strstr(s, \"MVKH\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\n\t      (((a >> 16) & 0xffff) << 7) |\n\t      (0x1a << 2) | (C67_map_regs(b) << 1));\n    } else if (strstr(s, \"STW.D SP POST DEC\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (15 << 18) |\t//SP B15\n\t      (2 << 13) |\t//ucst5 (must keep 8 byte boundary !!)\n\t      (0xa << 9) |\t//mode a = post dec ucst\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (1 << 7) |\t//y D1/D2 use B side\n\t      (7 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STB.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2 A side\n\t      (3 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STH.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2 A side\n\t      (5 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STB.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2 A side\n\t      (3 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STH.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2 A side\n\t      (5 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STW.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2 A side\n\t      (7 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STW.D *\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (C67_map_regn(b) << 18) |\t//base reg A0\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(b) << 7) |\t//y D1/D2 base reg side\n\t      (7 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STH.D *\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (C67_map_regn(b) << 18) |\t//base reg A0\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(b) << 7) |\t//y D1/D2 base reg side\n\t      (5 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STB.D *\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (C67_map_regn(b) << 18) |\t//base reg A0\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(b) << 7) |\t//y D1/D2 base reg side\n\t      (3 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"STW.D +*\") == s) {\n\tALWAYS_ASSERT(c < 32);\n\tC67_g((C67_map_regn(a) << 23) |\t//src\n\t      (C67_map_regn(b) << 18) |\t//base reg A0\n\t      (c << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(b) << 7) |\t//y D1/D2 base reg side\n\t      (7 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of src\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDW.D SP PRE INC\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg B15\n\t      (2 << 13) |\t//ucst5 (must keep 8 byte boundary)\n\t      (9 << 9) |\t//mode 9 = pre inc ucst5\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (1 << 7) |\t//y D1/D2  B side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDDW.D SP PRE INC\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg B15\n\t      (1 << 13) |\t//ucst5 (must keep 8 byte boundary)\n\t      (9 << 9) |\t//mode 9 = pre inc ucst5\n\t      (1 << 8) |\t//r (LDDW bit 1)\n\t      (1 << 7) |\t//y D1/D2  B side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDW.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2  A side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDDW.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (1 << 8) |\t//r (LDDW bit 1)\n\t      (0 << 7) |\t//y D1/D2  A side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDH.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2  A side\n\t      (4 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDB.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2  A side\n\t      (2 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDHU.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2  A side\n\t      (0 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDBU.D *+SP[A0]\") == s) {\n\tC67_g((C67_map_regn(a) << 23) |\t//dst\n\t      (15 << 18) |\t//base reg A15\n\t      (0 << 13) |\t//offset reg A0\n\t      (5 << 9) |\t//mode 5 = pos offset, base reg + off reg\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (0 << 7) |\t//y D1/D2  A side\n\t      (1 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(a) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDW.D *\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDDW.D *\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (1 << 8) |\t//r (LDDW bit 1)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDH.D *\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (4 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDB.D *\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (2 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDHU.D *\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (0 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDBU.D *\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (0 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (1 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU\n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"LDW.D +*\") == s) {\n\tC67_g((C67_map_regn(b) << 23) |\t//dst\n\t      (C67_map_regn(a) << 18) |\t//base reg A15\n\t      (1 << 13) |\t//cst5\n\t      (1 << 9) |\t//mode 1 = pos cst offset\n\t      (0 << 8) |\t//r (LDDW bit 0)\n\t      (C67_map_regs(a) << 7) |\t//y D1/D2  src side\n\t      (6 << 4) |\t//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU \n\t      (1 << 2) |\t//opcode\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPLTSP\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x3a << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPGTSP\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x39 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPEQSP\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x38 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    }\n\n    else if (strstr(s, \"CMPLTDP\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x2a << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPGTDP\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x29 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPEQDP\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x28 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPLT\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x57 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPGT\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x47 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPEQ\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x53 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPLTU\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x5f << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"CMPGTU\") == s) {\n\txpath = C67_map_regs(a) ^ C67_map_regs(b);\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1\n\t      (xpath << 12) |\t//x use cross path for src2\n\t      (0x4f << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side for reg c\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"B DISP\") == s) {\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//z\n\t      (a << 7) |\t//cnst\n\t      (0x4 << 2) |\t//opcode fixed\n\t      (0 << 1) |\t//S0/S1\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"B.\") == s) {\n\txpath = C67_map_regs(c) ^ 1;\n\n\tC67_g((C67_map_regc(b) << 29) |\t//creg\n\t      (a << 28) |\t//inv\n\t      (0 << 23) |\t//dst\n\t      (C67_map_regn(c) << 18) |\t//src2\n\t      (0 << 13) |\t//\n\t      (xpath << 12) |\t//x cross path if !B side\n\t      (0xd << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (1 << 1) |\t//must be S2\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"MV.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (0 << 13) |\t//src1 (cst5)\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x2 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SPTRUNC.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0xb << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"DPTRUNC.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      ((C67_map_regn(b) + 1) << 18) |\t//src2   WEIRD CPU must specify odd reg for some reason\n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x1 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"INTSP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2   \n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x4a << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"INTSPU.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2  \n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x49 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"INTDP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2  \n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x39 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"INTDPU.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      ((C67_map_regn(b) + 1) << 18) |\t//src2   WEIRD CPU must specify odd reg for some reason\n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x3b << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SPDP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (0 << 13) |\t//src1 NA\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x2 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"DPSP.L\") == s) {\n\tALWAYS_ASSERT(C67_map_regs(b) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      ((C67_map_regn(b) + 1) << 18) |\t//src2 WEIRD CPU must specify odd reg for some reason\n\t      (0 << 13) |\t//src1 NA\n\t      (0 << 12) |\t//x cross path if opposite sides\n\t      (0x9 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"ADD.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x3 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SUB.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x7 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"OR.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x7f << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"AND.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x7b << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"XOR.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x6f << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"ADDSP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x10 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"ADDDP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x18 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SUBSP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x11 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SUBDP.L\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x19 << 5) |\t//opcode\n\t      (0x6 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"MPYSP.M\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x1c << 7) |\t//opcode\n\t      (0x0 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"MPYDP.M\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2 (possible x path)\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x0e << 7) |\t//opcode\n\t      (0x0 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"MPYI.M\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1 (cst5)\n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x4 << 7) |\t//opcode\n\t      (0x0 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SHR.S\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x37 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SHRU.S\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x27 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"SHL.S\") == s) {\n\txpath = C67_map_regs(b) ^ C67_map_regs(c);\n\n\tALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(c) << 23) |\t//dst\n\t      (C67_map_regn(b) << 18) |\t//src2\n\t      (C67_map_regn(a) << 13) |\t//src1 \n\t      (xpath << 12) |\t//x cross path if opposite sides\n\t      (0x33 << 6) |\t//opcode\n\t      (0x8 << 2) |\t//opcode fixed\n\t      (C67_map_regs(c) << 1) |\t//side of dest\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"||ADDK\") == s) {\n\txpath = 0;\t\t// no xpath required just use the side of the src/dst\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(b) << 23) |\t//dst\n\t      (a << 07) |\t//scst16\n\t      (0x14 << 2) |\t//opcode fixed\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (1 << 0));\t//parallel\n    } else if (strstr(s, \"ADDK\") == s) {\n\txpath = 0;\t\t// no xpath required just use the side of the src/dst\n\n\tC67_g((0 << 29) |\t//creg\n\t      (0 << 28) |\t//inv\n\t      (C67_map_regn(b) << 23) |\t//dst\n\t      (a << 07) |\t//scst16\n\t      (0x14 << 2) |\t//opcode fixed\n\t      (C67_map_regs(b) << 1) |\t//side of dst\n\t      (0 << 0));\t//parallel\n    } else if (strstr(s, \"NOP\") == s) {\n\tC67_g(((a - 1) << 13) |\t//no of cycles\n\t      (0 << 0));\t//parallel\n    } else\n\tALWAYS_ASSERT(FALSE);\n\n#ifdef ASSEMBLY_LISTING_C67\n    fprintf(f, \" %s %d %d %d\\n\", s, a, b, c);\n#endif\n\n}\n\n//r=reg to load, fr=from reg, symbol for relocation, constant\n\nvoid C67_MVKL(int r, int fc)\n{\n    C67_asm(\"MVKL.\", fc, r, 0);\n}\n\nvoid C67_MVKH(int r, int fc)\n{\n    C67_asm(\"MVKH.\", fc, r, 0);\n}\n\nvoid C67_STB_SP_A0(int r)\n{\n    C67_asm(\"STB.D *+SP[A0]\", r, 0, 0);\t// STB  r,*+SP[A0]\n}\n\nvoid C67_STH_SP_A0(int r)\n{\n    C67_asm(\"STH.D *+SP[A0]\", r, 0, 0);\t// STH  r,*+SP[A0]\n}\n\nvoid C67_STW_SP_A0(int r)\n{\n    C67_asm(\"STW.D *+SP[A0]\", r, 0, 0);\t// STW  r,*+SP[A0]\n}\n\nvoid C67_STB_PTR(int r, int r2)\n{\n    C67_asm(\"STB.D *\", r, r2, 0);\t// STB  r, *r2\n}\n\nvoid C67_STH_PTR(int r, int r2)\n{\n    C67_asm(\"STH.D *\", r, r2, 0);\t// STH  r, *r2\n}\n\nvoid C67_STW_PTR(int r, int r2)\n{\n    C67_asm(\"STW.D *\", r, r2, 0);\t// STW  r, *r2\n}\n\nvoid C67_STW_PTR_PRE_INC(int r, int r2, int n)\n{\n    C67_asm(\"STW.D +*\", r, r2, n);\t// STW  r, *+r2\n}\n\nvoid C67_PUSH(int r)\n{\n    C67_asm(\"STW.D SP POST DEC\", r, 0, 0);\t// STW  r,*SP--\n}\n\nvoid C67_LDW_SP_A0(int r)\n{\n    C67_asm(\"LDW.D *+SP[A0]\", r, 0, 0);\t// LDW  *+SP[A0],r\n}\n\nvoid C67_LDDW_SP_A0(int r)\n{\n    C67_asm(\"LDDW.D *+SP[A0]\", r, 0, 0);\t// LDDW  *+SP[A0],r\n}\n\nvoid C67_LDH_SP_A0(int r)\n{\n    C67_asm(\"LDH.D *+SP[A0]\", r, 0, 0);\t// LDH  *+SP[A0],r\n}\n\nvoid C67_LDB_SP_A0(int r)\n{\n    C67_asm(\"LDB.D *+SP[A0]\", r, 0, 0);\t// LDB  *+SP[A0],r\n}\n\nvoid C67_LDHU_SP_A0(int r)\n{\n    C67_asm(\"LDHU.D *+SP[A0]\", r, 0, 0);\t// LDHU  *+SP[A0],r\n}\n\nvoid C67_LDBU_SP_A0(int r)\n{\n    C67_asm(\"LDBU.D *+SP[A0]\", r, 0, 0);\t// LDBU  *+SP[A0],r\n}\n\nvoid C67_LDW_PTR(int r, int r2)\n{\n    C67_asm(\"LDW.D *\", r, r2, 0);\t// LDW  *r,r2\n}\n\nvoid C67_LDDW_PTR(int r, int r2)\n{\n    C67_asm(\"LDDW.D *\", r, r2, 0);\t// LDDW  *r,r2\n}\n\nvoid C67_LDH_PTR(int r, int r2)\n{\n    C67_asm(\"LDH.D *\", r, r2, 0);\t// LDH  *r,r2\n}\n\nvoid C67_LDB_PTR(int r, int r2)\n{\n    C67_asm(\"LDB.D *\", r, r2, 0);\t// LDB  *r,r2\n}\n\nvoid C67_LDHU_PTR(int r, int r2)\n{\n    C67_asm(\"LDHU.D *\", r, r2, 0);\t// LDHU  *r,r2\n}\n\nvoid C67_LDBU_PTR(int r, int r2)\n{\n    C67_asm(\"LDBU.D *\", r, r2, 0);\t// LDBU  *r,r2\n}\n\nvoid C67_LDW_PTR_PRE_INC(int r, int r2)\n{\n    C67_asm(\"LDW.D +*\", r, r2, 0);\t// LDW  *+r,r2\n}\n\nvoid C67_POP(int r)\n{\n    C67_asm(\"LDW.D SP PRE INC\", r, 0, 0);\t// LDW  *++SP,r\n}\n\nvoid C67_POP_DW(int r)\n{\n    C67_asm(\"LDDW.D SP PRE INC\", r, 0, 0);\t// LDDW  *++SP,r\n}\n\nvoid C67_CMPLT(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPLT.L1\", s1, s2, dst);\n}\n\nvoid C67_CMPGT(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPGT.L1\", s1, s2, dst);\n}\n\nvoid C67_CMPEQ(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPEQ.L1\", s1, s2, dst);\n}\n\nvoid C67_CMPLTU(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPLTU.L1\", s1, s2, dst);\n}\n\nvoid C67_CMPGTU(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPGTU.L1\", s1, s2, dst);\n}\n\n\nvoid C67_CMPLTSP(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPLTSP.S1\", s1, s2, dst);\n}\n\nvoid C67_CMPGTSP(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPGTSP.S1\", s1, s2, dst);\n}\n\nvoid C67_CMPEQSP(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPEQSP.S1\", s1, s2, dst);\n}\n\nvoid C67_CMPLTDP(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPLTDP.S1\", s1, s2, dst);\n}\n\nvoid C67_CMPGTDP(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPGTDP.S1\", s1, s2, dst);\n}\n\nvoid C67_CMPEQDP(int s1, int s2, int dst)\n{\n    C67_asm(\"CMPEQDP.S1\", s1, s2, dst);\n}\n\n\nvoid C67_IREG_B_REG(int inv, int r1, int r2)\t// [!R] B  r2\n{\n    C67_asm(\"B.S2\", inv, r1, r2);\n}\n\n\n// call with how many 32 bit words to skip\n// (0 would branch to the branch instruction)\n\nvoid C67_B_DISP(int disp)\t//  B  +2  Branch with constant displacement\n{\n    // Branch point is relative to the 8 word fetch packet\n    //\n    // we will assume the text section always starts on an 8 word (32 byte boundary)\n    //\n    // so add in how many words into the fetch packet the branch is\n\n\n    C67_asm(\"B DISP\", disp + ((ind & 31) >> 2), 0, 0);\n}\n\nvoid C67_NOP(int n)\n{\n    C67_asm(\"NOP\", n, 0, 0);\n}\n\nvoid C67_ADDK(int n, int r)\n{\n    ALWAYS_ASSERT(abs(n) < 32767);\n\n    C67_asm(\"ADDK\", n, r, 0);\n}\n\nvoid C67_ADDK_PARALLEL(int n, int r)\n{\n    ALWAYS_ASSERT(abs(n) < 32767);\n\n    C67_asm(\"||ADDK\", n, r, 0);\n}\n\nvoid C67_Adjust_ADDK(int *inst, int n)\n{\n    ALWAYS_ASSERT(abs(n) < 32767);\n\n    *inst = (*inst & (~(0xffff << 7))) | ((n & 0xffff) << 7);\n}\n\nvoid C67_MV(int r, int v)\n{\n    C67_asm(\"MV.L\", 0, r, v);\n}\n\n\nvoid C67_DPTRUNC(int r, int v)\n{\n    C67_asm(\"DPTRUNC.L\", 0, r, v);\n}\n\nvoid C67_SPTRUNC(int r, int v)\n{\n    C67_asm(\"SPTRUNC.L\", 0, r, v);\n}\n\nvoid C67_INTSP(int r, int v)\n{\n    C67_asm(\"INTSP.L\", 0, r, v);\n}\n\nvoid C67_INTDP(int r, int v)\n{\n    C67_asm(\"INTDP.L\", 0, r, v);\n}\n\nvoid C67_INTSPU(int r, int v)\n{\n    C67_asm(\"INTSPU.L\", 0, r, v);\n}\n\nvoid C67_INTDPU(int r, int v)\n{\n    C67_asm(\"INTDPU.L\", 0, r, v);\n}\n\nvoid C67_SPDP(int r, int v)\n{\n    C67_asm(\"SPDP.L\", 0, r, v);\n}\n\nvoid C67_DPSP(int r, int v)\t// note regs must be on the same side\n{\n    C67_asm(\"DPSP.L\", 0, r, v);\n}\n\nvoid C67_ADD(int r, int v)\n{\n    C67_asm(\"ADD.L\", v, r, v);\n}\n\nvoid C67_SUB(int r, int v)\n{\n    C67_asm(\"SUB.L\", v, r, v);\n}\n\nvoid C67_AND(int r, int v)\n{\n    C67_asm(\"AND.L\", v, r, v);\n}\n\nvoid C67_OR(int r, int v)\n{\n    C67_asm(\"OR.L\", v, r, v);\n}\n\nvoid C67_XOR(int r, int v)\n{\n    C67_asm(\"XOR.L\", v, r, v);\n}\n\nvoid C67_ADDSP(int r, int v)\n{\n    C67_asm(\"ADDSP.L\", v, r, v);\n}\n\nvoid C67_SUBSP(int r, int v)\n{\n    C67_asm(\"SUBSP.L\", v, r, v);\n}\n\nvoid C67_MPYSP(int r, int v)\n{\n    C67_asm(\"MPYSP.M\", v, r, v);\n}\n\nvoid C67_ADDDP(int r, int v)\n{\n    C67_asm(\"ADDDP.L\", v, r, v);\n}\n\nvoid C67_SUBDP(int r, int v)\n{\n    C67_asm(\"SUBDP.L\", v, r, v);\n}\n\nvoid C67_MPYDP(int r, int v)\n{\n    C67_asm(\"MPYDP.M\", v, r, v);\n}\n\nvoid C67_MPYI(int r, int v)\n{\n    C67_asm(\"MPYI.M\", v, r, v);\n}\n\nvoid C67_SHL(int r, int v)\n{\n    C67_asm(\"SHL.S\", r, v, v);\n}\n\nvoid C67_SHRU(int r, int v)\n{\n    C67_asm(\"SHRU.S\", r, v, v);\n}\n\nvoid C67_SHR(int r, int v)\n{\n    C67_asm(\"SHR.S\", r, v, v);\n}\n\n\n\n/* load 'r' from value 'sv' */\nvoid load(int r, SValue * sv)\n{\n    int v, t, ft, fc, fr, size = 0, element;\n    BOOL Unsigned = FALSE;\n    SValue v1;\n\n    fr = sv->r;\n    ft = sv->type.t;\n    fc = sv->c.i;\n\n    v = fr & VT_VALMASK;\n    if (fr & VT_LVAL) {\n\tif (v == VT_LLOCAL) {\n\t    v1.type.t = VT_INT;\n\t    v1.r = VT_LOCAL | VT_LVAL;\n\t    v1.c.i = fc;\n\t    load(r, &v1);\n\t    fr = r;\n\t} else if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n\t    tcc_error(\"long double not supported\");\n\t} else if ((ft & VT_TYPE) == VT_BYTE) {\n\t    size = 1;\n\t} else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED)) {\n\t    size = 1;\n\t    Unsigned = TRUE;\n\t} else if ((ft & VT_TYPE) == VT_SHORT) {\n\t    size = 2;\n\t} else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED)) {\n\t    size = 2;\n\t    Unsigned = TRUE;\n\t} else if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t    size = 8;\n\t} else {\n\t    size = 4;\n\t}\n\n\t// check if fc is a positive reference on the stack, \n\t// if it is tcc is referencing what it thinks is a parameter\n\t// on the stack, so check if it is really in a register.\n\n\n\tif (v == VT_LOCAL && fc > 0) {\n\t    int stack_pos = 8;\n\n\t    for (t = 0; t < NoCallArgsPassedOnStack; t++) {\n\t\tif (fc == stack_pos)\n\t\t    break;\n\n\t\tstack_pos += TranslateStackToReg[t];\n\t    }\n\n\t    // param has been pushed on stack, get it like a local var\n\n\t    fc = ParamLocOnStack[t] - 8;\n\t}\n\n\tif ((fr & VT_VALMASK) < VT_CONST)\t// check for pure indirect\n\t{\n\t    if (size == 1) {\n\t\tif (Unsigned)\n\t\t    C67_LDBU_PTR(v, r);\t// LDBU  *v,r\n\t\telse\n\t\t    C67_LDB_PTR(v, r);\t// LDB  *v,r\n\t    } else if (size == 2) {\n\t\tif (Unsigned)\n\t\t    C67_LDHU_PTR(v, r);\t// LDHU  *v,r\n\t\telse\n\t\t    C67_LDH_PTR(v, r);\t// LDH  *v,r\n\t    } else if (size == 4) {\n\t\tC67_LDW_PTR(v, r);\t// LDW  *v,r\n\t    } else if (size == 8) {\n\t\tC67_LDDW_PTR(v, r);\t// LDDW  *v,r\n\t    }\n\n\t    C67_NOP(4);\t\t// NOP 4\n\t    return;\n\t} else if (fr & VT_SYM) {\n\t    greloc(cur_text_section, sv->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t    greloc(cur_text_section, sv->sym, ind + 4, R_C60HI16);\n\n\n\t    C67_MVKL(C67_A0, fc);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, fc);\t//r=reg to load,  constant\n\n\n\t    if (size == 1) {\n\t\tif (Unsigned)\n\t\t    C67_LDBU_PTR(C67_A0, r);\t// LDBU  *A0,r\n\t\telse\n\t\t    C67_LDB_PTR(C67_A0, r);\t// LDB  *A0,r\n\t    } else if (size == 2) {\n\t\tif (Unsigned)\n\t\t    C67_LDHU_PTR(C67_A0, r);\t// LDHU  *A0,r\n\t\telse\n\t\t    C67_LDH_PTR(C67_A0, r);\t// LDH  *A0,r\n\t    } else if (size == 4) {\n\t\tC67_LDW_PTR(C67_A0, r);\t// LDW  *A0,r\n\t    } else if (size == 8) {\n\t\tC67_LDDW_PTR(C67_A0, r);\t// LDDW  *A0,r\n\t    }\n\n\t    C67_NOP(4);\t\t// NOP 4\n\t    return;\n\t} else {\n\t    element = size;\n\n\t    // divide offset in bytes to create element index\n\t    C67_MVKL(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\n\t    if (size == 1) {\n\t\tif (Unsigned)\n\t\t    C67_LDBU_SP_A0(r);\t// LDBU  r, SP[A0]\n\t\telse\n\t\t    C67_LDB_SP_A0(r);\t// LDB  r, SP[A0]\n\t    } else if (size == 2) {\n\t\tif (Unsigned)\n\t\t    C67_LDHU_SP_A0(r);\t// LDHU  r, SP[A0]\n\t\telse\n\t\t    C67_LDH_SP_A0(r);\t// LDH  r, SP[A0]\n\t    } else if (size == 4) {\n\t\tC67_LDW_SP_A0(r);\t// LDW  r, SP[A0]\n\t    } else if (size == 8) {\n\t\tC67_LDDW_SP_A0(r);\t// LDDW  r, SP[A0]\n\t    }\n\n\n\t    C67_NOP(4);\t\t// NOP 4\n\t    return;\n\t}\n    } else {\n\tif (v == VT_CONST) {\n\t    if (fr & VT_SYM) {\n\t\tgreloc(cur_text_section, sv->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t\tgreloc(cur_text_section, sv->sym, ind + 4, R_C60HI16);\n\t    }\n\t    C67_MVKL(r, fc);\t//r=reg to load, constant\n\t    C67_MVKH(r, fc);\t//r=reg to load, constant\n\t} else if (v == VT_LOCAL) {\n\t    C67_MVKL(r, fc + 8);\t//r=reg to load, constant C67 stack points to next free\n\t    C67_MVKH(r, fc + 8);\t//r=reg to load, constant\n\t    C67_ADD(C67_FP, r);\t// MV v,r   v -> r\n\t} else if (v == VT_CMP) {\n\t    C67_MV(C67_compare_reg, r);\t// MV v,r   v -> r\n\t} else if (v == VT_JMP || v == VT_JMPI) {\n\t    t = v & 1;\n\t    C67_B_DISP(4);\t//  Branch with constant displacement, skip over this branch, load, nop, load\n\t    C67_MVKL(r, t);\t//  r=reg to load, 0 or 1 (do this while branching)\n\t    C67_NOP(4);\t\t//  NOP 4\n\t    gsym(fc);\t\t//  modifies other branches to branch here\n\t    C67_MVKL(r, t ^ 1);\t//  r=reg to load, 0 or 1\n\t} else if (v != r) {\n\t    C67_MV(v, r);\t// MV v,r   v -> r\n\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_MV(v + 1, r + 1);\t// MV v,r   v -> r\n\t}\n    }\n}\n\n\n/* store register 'r' in lvalue 'v' */\nvoid store(int r, SValue * v)\n{\n    int fr, bt, ft, fc, size, t, element;\n\n    ft = v->type.t;\n    fc = v->c.i;\n    fr = v->r & VT_VALMASK;\n    bt = ft & VT_BTYPE;\n    /* XXX: incorrect if float reg to reg */\n\n    if (bt == VT_LDOUBLE) {\n\ttcc_error(\"long double not supported\");\n    } else {\n\tif (bt == VT_SHORT)\n\t    size = 2;\n\telse if (bt == VT_BYTE)\n\t    size = 1;\n\telse if (bt == VT_DOUBLE)\n\t    size = 8;\n\telse\n\t    size = 4;\n\n\tif ((v->r & VT_VALMASK) == VT_CONST) {\n\t    /* constant memory reference */\n\n\t    if (v->r & VT_SYM) {\n\t\tgreloc(cur_text_section, v->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t\tgreloc(cur_text_section, v->sym, ind + 4, R_C60HI16);\n\t    }\n\t    C67_MVKL(C67_A0, fc);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, fc);\t//r=reg to load,  constant\n\n\t    if (size == 1)\n\t\tC67_STB_PTR(r, C67_A0);\t// STB  r, *A0\n\t    else if (size == 2)\n\t\tC67_STH_PTR(r, C67_A0);\t// STH  r, *A0\n\t    else if (size == 4 || size == 8)\n\t\tC67_STW_PTR(r, C67_A0);\t// STW  r, *A0\n\n\t    if (size == 8)\n\t\tC67_STW_PTR_PRE_INC(r + 1, C67_A0, 1);\t// STW  r, *+A0[1]\n\t} else if ((v->r & VT_VALMASK) == VT_LOCAL) {\n\t    // check case of storing to passed argument that\n\t    // tcc thinks is on the stack but for C67 is\n\t    // passed as a reg.  However it may have been\n\t    // saved to the stack, if that reg was required\n\t    // for a call to a child function\n\n\t    if (fc > 0)\t\t// argument ??\n\t    {\n\t\t// walk through sizes and figure which param\n\n\t\tint stack_pos = 8;\n\n\t\tfor (t = 0; t < NoCallArgsPassedOnStack; t++) {\n\t\t    if (fc == stack_pos)\n\t\t\tbreak;\n\n\t\t    stack_pos += TranslateStackToReg[t];\n\t\t}\n\n\t\t// param has been pushed on stack, get it like a local var\n\t\tfc = ParamLocOnStack[t] - 8;\n\t    }\n\n\t    if (size == 8)\n\t\telement = 4;\n\t    else\n\t\telement = size;\n\n\t    // divide offset in bytes to create word index\n\t    C67_MVKL(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\n\n\n\t    if (size == 1)\n\t\tC67_STB_SP_A0(r);\t// STB  r, SP[A0]\n\t    else if (size == 2)\n\t\tC67_STH_SP_A0(r);\t// STH  r, SP[A0]\n\t    else if (size == 4 || size == 8)\n\t\tC67_STW_SP_A0(r);\t// STW  r, SP[A0]\n\n\t    if (size == 8) {\n\t\tC67_ADDK(1, C67_A0);\t//  ADDK 1,A0\n\t\tC67_STW_SP_A0(r + 1);\t//  STW  r, SP[A0]\n\t    }\n\t} else {\n\t    if (size == 1)\n\t\tC67_STB_PTR(r, fr);\t// STB  r, *fr\n\t    else if (size == 2)\n\t\tC67_STH_PTR(r, fr);\t// STH  r, *fr\n\t    else if (size == 4 || size == 8)\n\t\tC67_STW_PTR(r, fr);\t// STW  r, *fr\n\n\t    if (size == 8) {\n\t\tC67_STW_PTR_PRE_INC(r + 1, fr, 1);\t// STW  r, *+fr[1]\n\t    }\n\t}\n    }\n}\n\n/* 'is_jmp' is '1' if it is a jump */\nstatic void gcall_or_jmp(int is_jmp)\n{\n    int r;\n    Sym *sym;\n\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n\t/* constant case */\n\tif (vtop->r & VT_SYM) {\n\t    /* relocation case */\n\n\t    // get add into A0, then start the jump B3\n\n\t    greloc(cur_text_section, vtop->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t    greloc(cur_text_section, vtop->sym, ind + 4, R_C60HI16);\n\n\t    C67_MVKL(C67_A0, 0);\t//r=reg to load, constant\n\t    C67_MVKH(C67_A0, 0);\t//r=reg to load, constant\n\t    C67_IREG_B_REG(0, C67_CREG_ZERO, C67_A0);\t//  B.S2x  A0\n\n\t    if (is_jmp) {\n\t\tC67_NOP(5);\t// simple jump, just put NOP\n\t    } else {\n\t\t// Call, must load return address into B3 during delay slots\n\n\t\tsym = get_sym_ref(&char_pointer_type, cur_text_section, ind + 12, 0);\t// symbol for return address\n\t\tgreloc(cur_text_section, sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t\tgreloc(cur_text_section, sym, ind + 4, R_C60HI16);\n\t\tC67_MVKL(C67_B3, 0);\t//r=reg to load, constant\n\t\tC67_MVKH(C67_B3, 0);\t//r=reg to load, constant\n\t\tC67_NOP(3);\t// put remaining NOPs\n\t    }\n\t} else {\n\t    /* put an empty PC32 relocation */\n\t    ALWAYS_ASSERT(FALSE);\n\t}\n    } else {\n\t/* otherwise, indirect call */\n\tr = gv(RC_INT);\n\tC67_IREG_B_REG(0, C67_CREG_ZERO, r);\t//  B.S2x  r\n\n\tif (is_jmp) {\n\t    C67_NOP(5);\t\t// simple jump, just put NOP\n\t} else {\n\t    // Call, must load return address into B3 during delay slots\n\n\t    sym = get_sym_ref(&char_pointer_type, cur_text_section, ind + 12, 0);\t// symbol for return address\n\t    greloc(cur_text_section, sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t    greloc(cur_text_section, sym, ind + 4, R_C60HI16);\n\t    C67_MVKL(C67_B3, 0);\t//r=reg to load, constant\n\t    C67_MVKH(C67_B3, 0);\t//r=reg to load, constant\n\t    C67_NOP(3);\t\t// put remaining NOPs\n\t}\n    }\n}\n\n/* Return the number of registers needed to return the struct, or 0 if\n   returning via struct pointer. */\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize) {\n    *ret_align = 1; // Never have to re-align return values for x86-64\n    return 0;\n}\n\n/* generate function call with address in (vtop->t, vtop->c) and free function\n   context. Stack entry is popped */\nvoid gfunc_call(int nb_args)\n{\n    int i, r, size = 0;\n    int args_sizes[NoCallArgsPassedOnStack];\n\n    if (nb_args > NoCallArgsPassedOnStack) {\n\ttcc_error(\"more than 10 function params not currently supported\");\n\t// handle more than 10, put some on the stack\n    }\n\n    for (i = 0; i < nb_args; i++) {\n\tif ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n\t    ALWAYS_ASSERT(FALSE);\n\t} else {\n\t    /* simple type (currently always same size) */\n\t    /* XXX: implicit cast ? */\n\n\n\t    if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n\t\ttcc_error(\"long long not supported\");\n\t    } else if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE) {\n\t\ttcc_error(\"long double not supported\");\n\t    } else if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE) {\n\t\tsize = 8;\n\t    } else {\n\t\tsize = 4;\n\t    }\n\n\t    // put the parameter into the corresponding reg (pair)\n\n\t    r = gv(RC_C67_A4 << (2 * i));\n\n\t    // must put on stack because with 1 pass compiler , no way to tell\n\t    // if an up coming nested call might overwrite these regs\n\n\t    C67_PUSH(r);\n\n\t    if (size == 8) {\n\t\tC67_STW_PTR_PRE_INC(r + 1, C67_SP, 3);\t// STW  r, *+SP[3] (go back and put the other)\n\t    }\n\t    args_sizes[i] = size;\n\t}\n\tvtop--;\n    }\n    // POP all the params on the stack into registers for the\n    // immediate call (in reverse order)\n\n    for (i = nb_args - 1; i >= 0; i--) {\n\n\tif (args_sizes[i] == 8)\n\t    C67_POP_DW(TREG_C67_A4 + i * 2);\n\telse\n\t    C67_POP(TREG_C67_A4 + i * 2);\n    }\n    gcall_or_jmp(0);\n    vtop--;\n}\n\n\n// to be compatible with Code Composer for the C67\n// the first 10 parameters must be passed in registers\n// (pairs for 64 bits) starting wit; A4:A5, then B4:B5 and\n// ending with B12:B13.\n//\n// When a call is made, if the caller has its parameters\n// in regs A4-B13 these must be saved before/as the call \n// parameters are loaded and restored upon return (or if/when needed).\n\n/* generate function prolog of type 't' */\nvoid gfunc_prolog(Sym *func_sym)\n{\n    CType *func_type = &func_sym->type;\n    int addr, align, size, func_call, i;\n    Sym *sym;\n    CType *type;\n\n    sym = func_type->ref;\n    func_call = sym->f.func_call;\n    addr = 8;\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n    if ((func_vt.t & VT_BTYPE) == VT_STRUCT) {\n\tfunc_vc = addr;\n\taddr += 4;\n    }\n\n    NoOfCurFuncArgs = 0;\n\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n\ttype = &sym->type;\n\tsym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL, addr);\n\tsize = type_size(type, &align);\n\tsize = (size + 3) & ~3;\n\n\t// keep track of size of arguments so\n\t// we can translate where tcc thinks they\n\t// are on the stack into the appropriate reg\n\n\tTranslateStackToReg[NoOfCurFuncArgs] = size;\n\tNoOfCurFuncArgs++;\n\n#ifdef FUNC_STRUCT_PARAM_AS_PTR\n\t/* structs are passed as pointer */\n\tif ((type->t & VT_BTYPE) == VT_STRUCT) {\n\t    size = 4;\n\t}\n#endif\n\taddr += size;\n    }\n    func_ret_sub = 0;\n    /* pascal type call ? */\n    if (func_call == FUNC_STDCALL)\n\tfunc_ret_sub = addr - 8;\n\n    C67_MV(C67_FP, C67_A0);\t//  move FP -> A0\n    C67_MV(C67_SP, C67_FP);\t//  move SP -> FP\n\n    // place all the args passed in regs onto the stack\n\n    loc = 0;\n    for (i = 0; i < NoOfCurFuncArgs; i++) {\n\n\tParamLocOnStack[i] = loc;\t// remember where the param is\n\tloc += -8;\n\n\tC67_PUSH(TREG_C67_A4 + i * 2);\n\n\tif (TranslateStackToReg[i] == 8) {\n\t    C67_STW_PTR_PRE_INC(TREG_C67_A4 + i * 2 + 1, C67_SP, 3);\t// STW  r, *+SP[1] (go back and put the other)\n\t}\n    }\n\n    TotalBytesPushedOnStack = -loc;\n\n    func_sub_sp_offset = ind;\t// remember where we put the stack instruction \n    C67_ADDK(0, C67_SP);\t//  ADDK.L2 loc,SP  (just put zero temporarily)\n\n    C67_PUSH(C67_A0);\n    C67_PUSH(C67_B3);\n}\n\n/* generate function epilog */\nvoid gfunc_epilog(void)\n{\n    {\n\tint local = (-loc + 7) & -8;\t// stack must stay aligned to 8 bytes for LDDW instr\n\tC67_POP(C67_B3);\n\tC67_NOP(4);\t\t// NOP wait for load\n\tC67_IREG_B_REG(0, C67_CREG_ZERO, C67_B3);\t//  B.S2  B3\n\tC67_POP(C67_FP);\n\tC67_ADDK(local, C67_SP);\t//  ADDK.L2 loc,SP  \n\tC67_Adjust_ADDK((int *) (cur_text_section->data +\n\t\t\t\t func_sub_sp_offset),\n\t\t\t-local + TotalBytesPushedOnStack);\n\tC67_NOP(3);\t\t// NOP \n    }\n}\n\nST_FUNC void gen_fill_nops(int bytes)\n{\n    if ((bytes & 3))\n      tcc_error(\"alignment of code section not multiple of 4\");\n    while (bytes > 0) {\n\tC67_NOP(4);\n\tbytes -= 4;\n    }\n}\n\n/* generate a jump to a label */\nint gjmp(int t)\n{\n    int ind1 = ind;\n    if (nocode_wanted)\n        return t;\n\n    C67_MVKL(C67_A0, t);\t//r=reg to load,  constant\n    C67_MVKH(C67_A0, t);\t//r=reg to load,  constant\n    C67_IREG_B_REG(0, C67_CREG_ZERO, C67_A0);\t// [!R] B.S2x  A0\n    C67_NOP(5);\n    return ind1;\n}\n\n/* generate a jump to a fixed address */\nvoid gjmp_addr(int a)\n{\n    Sym *sym;\n    // I guess this routine is used for relative short\n    // local jumps, for now just handle it as the general\n    // case\n\n    // define a label that will be relocated\n\n    sym = get_sym_ref(&char_pointer_type, cur_text_section, a, 0);\n    greloc(cur_text_section, sym, ind, R_C60LO16);\n    greloc(cur_text_section, sym, ind + 4, R_C60HI16);\n\n    gjmp(0);\t\t\t// place a zero there later the symbol will be added to it\n}\n\n/* generate a test. set 'inv' to invert test. Stack entry is popped */\nST_FUNC int gjmp_cond(int op, int t)\n{\n        int ind1;\n        int inv = op & 1;\n        if (nocode_wanted)\n            return t;\n\n\t/* fast case : can jump directly since flags are set */\n\t// C67 uses B2 sort of as flags register\n\tind1 = ind;\n\tC67_MVKL(C67_A0, t);\t//r=reg to load, constant\n\tC67_MVKH(C67_A0, t);\t//r=reg to load, constant\n\n\tif (C67_compare_reg != TREG_EAX &&\t// check if not already in a conditional test reg\n\t    C67_compare_reg != TREG_EDX &&\n\t    C67_compare_reg != TREG_ST0 && C67_compare_reg != C67_B2) {\n\t    C67_MV(C67_compare_reg, C67_B2);\n\t    C67_compare_reg = C67_B2;\n\t}\n\n\tC67_IREG_B_REG(C67_invert_test ^ inv, C67_compare_reg, C67_A0);\t// [!R] B.S2x  A0\n\tC67_NOP(5);\n\tt = ind1;\t\t//return where we need to patch\n\n        return t;\n}\n\nST_FUNC int gjmp_append(int n0, int t)\n{\n    if (n0) {\n            int n = n0, *p;\n\t    /* insert vtop->c jump list in t */\n\n\t    // I guess the idea is to traverse to the\n\t    // null at the end of the list and store t\n\t    // there\n\t    while (n != 0) {\n\t\tp = (int *) (cur_text_section->data + n);\n\n\t\t// extract 32 bit address from MVKH/MVKL\n\t\tn = ((*p >> 7) & 0xffff);\n\t\tn |= ((*(p + 1) >> 7) & 0xffff) << 16;\n\t    }\n\t    *p |= (t & 0xffff) << 7;\n\t    *(p + 1) |= ((t >> 16) & 0xffff) << 7;\n\t    t = n0;\n    }\n    return t;\n}\n\n/* generate an integer binary operation */\nvoid gen_opi(int op)\n{\n    int r, fr, opc, t;\n\n    switch (op) {\n    case '+':\n    case TOK_ADDC1:\t\t/* add with carry generation */\n\topc = 0;\n      gen_op8:\n\n\n// C67 can't do const compares, must load into a reg\n// so just go to gv2 directly - tktk\n\n\n\n\tif (op >= TOK_ULT && op <= TOK_GT)\n\t    gv2(RC_INT_BSIDE, RC_INT);\t// make sure r (src1) is on the B Side of CPU\n\telse\n\t    gv2(RC_INT, RC_INT);\n\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\n\tC67_compare_reg = C67_B2;\n\n\n\tif (op == TOK_LT) {\n\t    C67_CMPLT(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_GE) {\n\t    C67_CMPLT(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_GT) {\n\t    C67_CMPGT(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_LE) {\n\t    C67_CMPGT(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_EQ) {\n\t    C67_CMPEQ(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_NE) {\n\t    C67_CMPEQ(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_ULT) {\n\t    C67_CMPLTU(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_UGE) {\n\t    C67_CMPLTU(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_UGT) {\n\t    C67_CMPGTU(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_ULE) {\n\t    C67_CMPGTU(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == '+')\n\t    C67_ADD(fr, r);\t// ADD  r,fr,r\n\telse if (op == '-')\n\t    C67_SUB(fr, r);\t// SUB  r,fr,r\n\telse if (op == '&')\n\t    C67_AND(fr, r);\t// AND  r,fr,r\n\telse if (op == '|')\n\t    C67_OR(fr, r);\t// OR  r,fr,r\n\telse if (op == '^')\n\t    C67_XOR(fr, r);\t// XOR  r,fr,r\n\telse\n\t    ALWAYS_ASSERT(FALSE);\n\n\tvtop--;\n\tif (op >= TOK_ULT && op <= TOK_GT)\n            vset_VT_CMP(0x80);\n\tbreak;\n    case '-':\n    case TOK_SUBC1:\t\t/* sub with carry generation */\n\topc = 5;\n\tgoto gen_op8;\n    case TOK_ADDC2:\t\t/* add with carry use */\n\topc = 2;\n\tgoto gen_op8;\n    case TOK_SUBC2:\t\t/* sub with carry use */\n\topc = 3;\n\tgoto gen_op8;\n    case '&':\n\topc = 4;\n\tgoto gen_op8;\n    case '^':\n\topc = 6;\n\tgoto gen_op8;\n    case '|':\n\topc = 1;\n\tgoto gen_op8;\n    case '*':\n    case TOK_UMULL:\n\tgv2(RC_INT, RC_INT);\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_MPYI(fr, r);\t// 32 bit multiply  fr,r,fr\n\tC67_NOP(8);\t\t// NOP 8 for worst case\n\tbreak;\n    case TOK_SHL:\n\tgv2(RC_INT_BSIDE, RC_INT_BSIDE);\t// shift amount must be on same side as dst\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_SHL(fr, r);\t\t// arithmetic/logical shift\n\tbreak;\n\n    case TOK_SHR:\n\tgv2(RC_INT_BSIDE, RC_INT_BSIDE);\t// shift amount must be on same side as dst\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_SHRU(fr, r);\t// logical shift\n\tbreak;\n\n    case TOK_SAR:\n\tgv2(RC_INT_BSIDE, RC_INT_BSIDE);\t// shift amount must be on same side as dst\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_SHR(fr, r);\t\t// arithmetic shift\n\tbreak;\n\n    case '/':\n\tt = TOK__divi;\n      call_func:\n\tvswap();\n\t/* call generic idiv function */\n\tvpush_helper_func(t);\n\tvrott(3);\n\tgfunc_call(2);\n\tvpushi(0);\n\tvtop->r = REG_IRET;\n\tvtop->r2 = VT_CONST;\n\tbreak;\n    case TOK_UDIV:\n    case TOK_PDIV:\n\tt = TOK__divu;\n\tgoto call_func;\n    case '%':\n\tt = TOK__remi;\n\tgoto call_func;\n    case TOK_UMOD:\n\tt = TOK__remu;\n\tgoto call_func;\n\n    default:\n\topc = 7;\n\tgoto gen_op8;\n    }\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranteed to have the same floating point type */\n/* XXX: need to use ST1 too */\nvoid gen_opf(int op)\n{\n    int ft, fc, fr, r;\n\n    if (op >= TOK_ULT && op <= TOK_GT)\n\tgv2(RC_EDX, RC_EAX);\t// make sure src2 is on b side\n    else\n\tgv2(RC_FLOAT, RC_FLOAT);\t// make sure src2 is on b side\n\n    ft = vtop->type.t;\n    fc = vtop->c.i;\n    r = vtop->r;\n    fr = vtop[-1].r;\n\n\n    if ((ft & VT_BTYPE) == VT_LDOUBLE)\n\ttcc_error(\"long doubles not supported\");\n\n    if (op >= TOK_ULT && op <= TOK_GT) {\n\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\n\tC67_compare_reg = C67_B2;\n\n\tif (op == TOK_LT) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPLTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPLTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_GE) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPLTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPLTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_GT) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPGTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPGTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_LE) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPGTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPGTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_EQ) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPEQDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPEQSP(r, fr, C67_B2);\n\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_NE) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPEQDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPEQSP(r, fr, C67_B2);\n\n\t    C67_invert_test = TRUE;\n\t} else {\n\t    ALWAYS_ASSERT(FALSE);\n\t}\n        vset_VT_CMP(0x80);\n    } else {\n\tif (op == '+') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\tC67_ADDDP(r, fr);\t// ADD  fr,r,fr\n\t\tC67_NOP(6);\n\t    } else {\n\t\tC67_ADDSP(r, fr);\t// ADD  fr,r,fr\n\t\tC67_NOP(3);\n\t    }\n\t    vtop--;\n\t} else if (op == '-') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\tC67_SUBDP(r, fr);\t// SUB  fr,r,fr\n\t\tC67_NOP(6);\n\t    } else {\n\t\tC67_SUBSP(r, fr);\t// SUB  fr,r,fr\n\t\tC67_NOP(3);\n\t    }\n\t    vtop--;\n\t} else if (op == '*') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\tC67_MPYDP(r, fr);\t// MPY  fr,r,fr\n\t\tC67_NOP(9);\n\t    } else {\n\t\tC67_MPYSP(r, fr);\t// MPY  fr,r,fr\n\t\tC67_NOP(3);\n\t    }\n\t    vtop--;\n\t} else if (op == '/') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\t// must call intrinsic DP floating point divide\n\t\tvswap();\n\t\t/* call generic idiv function */\n\t\tvpush_helper_func(TOK__divd);\n\t\tvrott(3);\n\t\tgfunc_call(2);\n\t\tvpushi(0);\n\t\tvtop->r = REG_FRET;\n\t\tvtop->r2 = REG_IRE2;\n\n\t    } else {\n\t\t// must call intrinsic SP floating point divide\n\t\tvswap();\n\t\t/* call generic idiv function */\n\t\tvpush_helper_func(TOK__divf);\n\t\tvrott(3);\n\t\tgfunc_call(2);\n\t\tvpushi(0);\n\t\tvtop->r = REG_FRET;\n\t\tvtop->r2 = VT_CONST;\n\t    }\n\t} else\n\t    ALWAYS_ASSERT(FALSE);\n\n\n    }\n}\n\n\n/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\nvoid gen_cvt_itof(int t)\n{\n    int r;\n\n    gv(RC_INT);\n    r = vtop->r;\n\n    if ((t & VT_BTYPE) == VT_DOUBLE) {\n\tif (t & VT_UNSIGNED)\n\t    C67_INTDPU(r, r);\n\telse\n\t    C67_INTDP(r, r);\n\n\tC67_NOP(4);\n\tvtop->type.t = VT_DOUBLE;\n    } else {\n\tif (t & VT_UNSIGNED)\n\t    C67_INTSPU(r, r);\n\telse\n\t    C67_INTSP(r, r);\n\tC67_NOP(3);\n\tvtop->type.t = VT_FLOAT;\n    }\n\n}\n\n/* convert fp to int 't' type */\n/* XXX: handle long long case */\nvoid gen_cvt_ftoi(int t)\n{\n    int r;\n\n    gv(RC_FLOAT);\n    r = vtop->r;\n\n    if (t != VT_INT)\n\ttcc_error(\"long long not supported\");\n    else {\n\tif ((vtop->type.t & VT_BTYPE) == VT_DOUBLE) {\n\t    C67_DPTRUNC(r, r);\n\t    C67_NOP(3);\n\t} else {\n\t    C67_SPTRUNC(r, r);\n\t    C67_NOP(3);\n\t}\n\n\tvtop->type.t = VT_INT;\n\n    }\n}\n\n/* convert from one floating point type to another */\nvoid gen_cvt_ftof(int t)\n{\n    int r, r2;\n\n    if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE &&\n\t(t & VT_BTYPE) == VT_FLOAT) {\n\t// convert double to float\n\n\tgv(RC_FLOAT);\t\t// get it in a register pair\n\n\tr = vtop->r;\n\n\tC67_DPSP(r, r);\t\t// convert it to SP same register\n\tC67_NOP(3);\n\n\tvtop->type.t = VT_FLOAT;\n\tvtop->r2 = VT_CONST;\t// set this as unused\n    } else if ((vtop->type.t & VT_BTYPE) == VT_FLOAT &&\n\t       (t & VT_BTYPE) == VT_DOUBLE) {\n\t// convert float to double\n\n\tgv(RC_FLOAT);\t\t// get it in a register\n\n\tr = vtop->r;\n\n\tif (r == TREG_EAX) {\t// make sure the paired reg is avail\n\t    r2 = get_reg(RC_ECX);\n\t} else if (r == TREG_EDX) {\n\t    r2 = get_reg(RC_ST0);\n\t} else {\n\t    ALWAYS_ASSERT(FALSE);\n            r2 = 0; /* avoid warning */\n        }\n\n\tC67_SPDP(r, r);\t\t// convert it to DP same register\n\tC67_NOP(1);\n\n\tvtop->type.t = VT_DOUBLE;\n\tvtop->r2 = r2;\t\t// set this as unused\n    } else {\n\tALWAYS_ASSERT(FALSE);\n    }\n}\n\n/* computed goto support */\nvoid ggoto(void)\n{\n    gcall_or_jmp(1);\n    vtop--;\n}\n\n/* Save the stack pointer onto the stack and return the location of its address */\nST_FUNC void gen_vla_sp_save(int addr) {\n    tcc_error(\"variable length arrays unsupported for this target\");\n}\n\n/* Restore the SP from a location on the stack */\nST_FUNC void gen_vla_sp_restore(int addr) {\n    tcc_error(\"variable length arrays unsupported for this target\");\n}\n\n/* Subtract from the stack pointer, and push the resulting value onto the stack */\nST_FUNC void gen_vla_alloc(CType *type, int align) {\n    tcc_error(\"variable length arrays unsupported for this target\");\n}\n\n/* end of C67 code generator */\n/*************************************************************/\n#endif\n/*************************************************************/\n"
        },
        {
          "name": "c67-link.c",
          "type": "blob",
          "size": 3.1845703125,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n#define EM_TCC_TARGET EM_C60\n\n/* relocation type for 32 bit data relocation */\n#define R_DATA_32   R_C60_32\n#define R_DATA_PTR  R_C60_32\n#define R_JMP_SLOT  R_C60_JMP_SLOT\n#define R_GLOB_DAT  R_C60_GLOB_DAT\n#define R_COPY      R_C60_COPY\n#define R_RELATIVE  R_C60_RELATIVE\n\n#define R_NUM       R_C60_NUM\n\n#define ELF_START_ADDR 0x00000400\n#define ELF_PAGE_SIZE  0x1000\n\n#define PCRELATIVE_DLLPLT 0\n#define RELOCATE_DLLPLT 0\n\n#else /* !TARGET_DEFS_ONLY */\n\n#include \"tcc.h\"\n\n/* Returns 1 for a code relocation, 0 for a data relocation. For unknown\n   relocations, returns -1. */\nST_FUNC int code_reloc (int reloc_type)\n{\n    switch (reloc_type) {\n        case R_C60_32:\n\tcase R_C60LO16:\n\tcase R_C60HI16:\n        case R_C60_GOT32:\n        case R_C60_GOTOFF:\n        case R_C60_GOTPC:\n        case R_C60_COPY:\n            return 0;\n\n        case R_C60_PLT32:\n            return 1;\n    }\n    return -1;\n}\n\n/* Returns an enumerator to describe whether and when the relocation needs a\n   GOT and/or PLT entry to be created. See tcc.h for a description of the\n   different values. */\nST_FUNC int gotplt_entry_type (int reloc_type)\n{\n    switch (reloc_type) {\n        case R_C60_32:\n\tcase R_C60LO16:\n\tcase R_C60HI16:\n        case R_C60_COPY:\n            return NO_GOTPLT_ENTRY;\n\n        case R_C60_GOTOFF:\n        case R_C60_GOTPC:\n            return BUILD_GOT_ONLY;\n\n        case R_C60_PLT32:\n        case R_C60_GOT32:\n            return ALWAYS_GOTPLT_ENTRY;\n    }\n    return -1;\n}\n\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)\n{\n    tcc_error_noabort(\"C67 got not implemented\");\n    return 0;\n}\n\n/* relocate the PLT: compute addresses and offsets in the PLT now that final\n   address for PLT and GOT are known (see fill_program_header) */\nST_FUNC void relocate_plt(TCCState *s1)\n{\n    uint8_t *p, *p_end;\n\n    if (!s1->plt)\n      return;\n\n    p = s1->plt->data;\n    p_end = p + s1->plt->data_offset;\n\n    if (p < p_end) {\n        /* XXX: TODO */\n        while (p < p_end) {\n            /* XXX: TODO */\n        }\n   }\n}\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)\n{\n    switch(type) {\n        case R_C60_32:\n            *(int *)ptr += val;\n            break;\n        case R_C60LO16:\n            {\n                uint32_t orig;\n\n                /* put the low 16 bits of the absolute address add to what is\n                   already there */\n                orig  =   ((*(int *)(ptr  )) >> 7) & 0xffff;\n                orig |=  (((*(int *)(ptr+4)) >> 7) & 0xffff) << 16;\n\n                /* patch both at once - assumes always in pairs Low - High */\n                *(int *) ptr    = (*(int *) ptr    & (~(0xffff << 7)) ) |\n                                   (((val+orig)      & 0xffff) << 7);\n                *(int *)(ptr+4) = (*(int *)(ptr+4) & (~(0xffff << 7)) ) |\n                                  ((((val+orig)>>16) & 0xffff) << 7);\n            }\n            break;\n        case R_C60HI16:\n            break;\n        default:\n            fprintf(stderr,\"FIXME: handle reloc type %x at %x [%p] to %x\\n\",\n                    type, (unsigned) addr, ptr, (unsigned) val);\n            break;\n    }\n}\n\n#endif /* !TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "coff.h",
          "type": "blob",
          "size": 21.9033203125,
          "content": "/**************************************************************************/\n/*  COFF.H                                                                */\n/*     COFF data structures and related definitions used by the linker    */\n/**************************************************************************/\n\n/*------------------------------------------------------------------------*/\n/*  COFF FILE HEADER                                                      */\n/*------------------------------------------------------------------------*/\nstruct filehdr {\n        unsigned short  f_magic;        /* magic number */\n        unsigned short  f_nscns;        /* number of sections */\n        long            f_timdat;       /* time & date stamp */\n        long            f_symptr;       /* file pointer to symtab */\n        long            f_nsyms;        /* number of symtab entries */\n        unsigned short  f_opthdr;       /* sizeof(optional hdr) */\n        unsigned short  f_flags;        /* flags */\n        unsigned short  f_TargetID;     /* for C6x = 0x0099 */\n        };\n\n/*------------------------------------------------------------------------*/\n/*  File header flags                                                     */\n/*------------------------------------------------------------------------*/\n#define  F_RELFLG   0x01       /* relocation info stripped from file       */\n#define  F_EXEC     0x02       /* file is executable (no unresolved refs)  */\n#define  F_LNNO     0x04       /* line numbers stripped from file          */\n#define  F_LSYMS    0x08       /* local symbols stripped from file         */\n#define  F_GSP10    0x10       /* 34010 version                            */\n#define  F_GSP20    0x20       /* 34020 version                            */\n#define  F_SWABD    0x40       /* bytes swabbed (in names)                 */\n#define  F_AR16WR   0x80       /* byte ordering of an AR16WR (PDP-11)      */\n#define  F_LITTLE   0x100      /* byte ordering of an AR32WR (vax)         */\n#define  F_BIG      0x200      /* byte ordering of an AR32W (3B, maxi)     */\n#define  F_PATCH    0x400      /* contains \"patch\" list in optional header */\n#define  F_NODF     0x400   \n\n#define F_VERSION    (F_GSP10  | F_GSP20)   \n#define F_BYTE_ORDER (F_LITTLE | F_BIG)\n#define FILHDR  struct filehdr\n\n/* #define FILHSZ  sizeof(FILHDR)  */\n#define FILHSZ  22                /* above rounds to align on 4 bytes which causes problems */\n\n#define COFF_C67_MAGIC 0x00c2\n\n/*------------------------------------------------------------------------*/\n/*  Macros to recognize magic numbers                                     */\n/*------------------------------------------------------------------------*/\n#define ISMAGIC(x)      (((unsigned short)(x))==(unsigned short)magic)\n#define ISARCHIVE(x)    ((((unsigned short)(x))==(unsigned short)ARTYPE))\n#define BADMAGIC(x)     (((unsigned short)(x) & 0x8080) && !ISMAGIC(x))\n\n\f\n/*------------------------------------------------------------------------*/\n/*  OPTIONAL FILE HEADER                                                  */\n/*------------------------------------------------------------------------*/\ntypedef struct aouthdr {\n        short   magic;          /* see magic.h                          */\n        short   vstamp;         /* version stamp                        */\n        long    tsize;          /* text size in bytes, padded to FW bdry*/\n        long    dsize;          /* initialized data \"  \"                */\n        long    bsize;          /* uninitialized data \"   \"             */\n        long    entrypt;        /* entry pt.                            */\n        long    text_start;     /* base of text used for this file      */\n        long    data_start;     /* base of data used for this file      */\n} AOUTHDR;\n\n#define AOUTSZ  sizeof(AOUTHDR)\n\n/*----------------------------------------------------------------------*/\n/*      When a UNIX aout header is to be built in the optional header,  */\n/*      the following magic numbers can appear in that header:          */ \n/*                                                                      */\n/*              AOUT1MAGIC : default : readonly sharable text segment   */\n/*              AOUT2MAGIC:          : writable text segment            */\n/*              PAGEMAGIC  :         : configured for paging            */\n/*----------------------------------------------------------------------*/\n#define AOUT1MAGIC 0410\n#define AOUT2MAGIC 0407\n#define PAGEMAGIC  0413\n\n\f\n/*------------------------------------------------------------------------*/\n/*  COMMON ARCHIVE FILE STRUCTURES                                        */\n/*                                                                        */\n/*       ARCHIVE File Organization:                                       */\n/*       _______________________________________________                  */\n/*       |__________ARCHIVE_MAGIC_STRING_______________|                  */\n/*       |__________ARCHIVE_FILE_MEMBER_1______________|                  */\n/*       |                                             |                  */\n/*       |       Archive File Header \"ar_hdr\"          |                  */\n/*       |.............................................|                  */\n/*       |       Member Contents                       |                  */\n/*       |               1. External symbol directory  |                  */\n/*       |               2. Text file                  |                  */\n/*       |_____________________________________________|                  */\n/*       |________ARCHIVE_FILE_MEMBER_2________________|                  */\n/*       |               \"ar_hdr\"                      |                  */\n/*       |.............................................|                  */\n/*       |       Member Contents (.o or text file)     |                  */\n/*       |_____________________________________________|                  */\n/*       |       .               .               .     |                  */\n/*       |       .               .               .     |                  */\n/*       |       .               .               .     |                  */\n/*       |_____________________________________________|                  */\n/*       |________ARCHIVE_FILE_MEMBER_n________________|                  */\n/*       |               \"ar_hdr\"                      |                  */\n/*       |.............................................|                  */\n/*       |               Member Contents               |                  */\n/*       |_____________________________________________|                  */\n/*                                                                        */\n/*------------------------------------------------------------------------*/\n\n#define COFF_ARMAG   \"!<arch>\\n\"\n#define SARMAG  8\n#define ARFMAG  \"`\\n\"\n\nstruct ar_hdr           /* archive file member header - printable ascii */\n{\n        char    ar_name[16];    /* file member name - `/' terminated */\n        char    ar_date[12];    /* file member date - decimal */\n        char    ar_uid[6];      /* file member user id - decimal */\n        char    ar_gid[6];      /* file member group id - decimal */\n        char    ar_mode[8];     /* file member mode - octal */\n        char    ar_size[10];    /* file member size - decimal */\n        char    ar_fmag[2];     /* ARFMAG - string to end header */\n};\n\n\f\n/*------------------------------------------------------------------------*/\n/*  SECTION HEADER                                                        */\n/*------------------------------------------------------------------------*/\nstruct scnhdr {\n        char            s_name[8];      /* section name */\n        long            s_paddr;        /* physical address */\n        long            s_vaddr;        /* virtual address */\n        long            s_size;         /* section size */\n        long            s_scnptr;       /* file ptr to raw data for section */\n        long            s_relptr;       /* file ptr to relocation */\n        long            s_lnnoptr;      /* file ptr to line numbers */\n        unsigned int\ts_nreloc;       /* number of relocation entries */\n        unsigned int\ts_nlnno;        /* number of line number entries */\n        unsigned int\ts_flags;        /* flags */\n\t\tunsigned short\ts_reserved;     /* reserved byte */\n\t\tunsigned short  s_page;         /* memory page id */\n        };\n\n#define SCNHDR  struct scnhdr\n#define SCNHSZ  sizeof(SCNHDR)\n\n/*------------------------------------------------------------------------*/\n/* Define constants for names of \"special\" sections                       */\n/*------------------------------------------------------------------------*/\n/* #define _TEXT    \".text\" */\n#define _DATA    \".data\"\n#define _BSS     \".bss\"\n#define _CINIT   \".cinit\"\n#define _TV      \".tv\"\n\n/*------------------------------------------------------------------------*/\n/* The low 4 bits of s_flags is used as a section \"type\"                  */\n/*------------------------------------------------------------------------*/\n#define STYP_REG    0x00  /* \"regular\" : allocated, relocated, loaded */\n#define STYP_DSECT  0x01  /* \"dummy\"   : not allocated, relocated, not loaded */\n#define STYP_NOLOAD 0x02  /* \"noload\"  : allocated, relocated, not loaded */\n#define STYP_GROUP  0x04  /* \"grouped\" : formed of input sections */\n#define STYP_PAD    0x08  /* \"padding\" : not allocated, not relocated, loaded */\n#define STYP_COPY   0x10  /* \"copy\"    : used for C init tables - \n                                                not allocated, relocated,\n                                                loaded;  reloc & lineno\n                                                entries processed normally */\n#define STYP_TEXT   0x20   /* section contains text only */\n#define STYP_DATA   0x40   /* section contains data only */\n#define STYP_BSS    0x80   /* section contains bss only */\n\n#define STYP_ALIGN  0x100  /* align flag passed by old version assemblers */\n#define ALIGN_MASK  0x0F00 /* part of s_flags that is used for align vals */\n#define ALIGNSIZE(x) (1 << ((x & ALIGN_MASK) >> 8))\n\n\f\n/*------------------------------------------------------------------------*/\n/*  RELOCATION ENTRIES                                                    */\n/*------------------------------------------------------------------------*/\nstruct reloc\n{\n   long            r_vaddr;        /* (virtual) address of reference */\n   short           r_symndx;       /* index into symbol table */\n   unsigned short  r_disp;         /* additional bits for address calculation */\n   unsigned short  r_type;         /* relocation type */\n};\n\n#define RELOC   struct reloc\n#define RELSZ   10                 /* sizeof(RELOC) */\n\n/*--------------------------------------------------------------------------*/\n/*   define all relocation types                                            */\n/*--------------------------------------------------------------------------*/\n\n#define R_ABS           0         /* absolute address - no relocation       */\n#define R_DIR16         01        /* UNUSED                                 */\n#define R_REL16         02        /* UNUSED                                 */\n#define R_DIR24         04        /* UNUSED                                 */\n#define R_REL24         05        /* 24 bits, direct                        */\n#define R_DIR32         06        /* UNUSED                                 */\n#define R_RELBYTE      017        /* 8 bits, direct                         */\n#define R_RELWORD      020        /* 16 bits, direct                        */\n#define R_RELLONG      021        /* 32 bits, direct                        */\n#define R_PCRBYTE      022        /* 8 bits, PC-relative                    */\n#define R_PCRWORD      023        /* 16 bits, PC-relative                   */\n#define R_PCRLONG      024        /* 32 bits, PC-relative                   */\n#define R_OCRLONG      030        /* GSP: 32 bits, one's complement direct  */\n#define R_GSPPCR16     031        /* GSP: 16 bits, PC relative (in words)   */\n#define R_GSPOPR32     032        /* GSP: 32 bits, direct big-endian        */\n#define R_PARTLS16     040        /* Brahma: 16 bit offset of 24 bit address*/\n#define R_PARTMS8      041        /* Brahma: 8 bit page of 24 bit address   */\n#define R_PARTLS7      050        /* DSP: 7 bit offset of 16 bit address    */\n#define R_PARTMS9      051        /* DSP: 9 bit page of 16 bit address      */\n#define R_REL13        052        /* DSP: 13 bits, direct                   */\n\n\f\n/*------------------------------------------------------------------------*/\n/*  LINE NUMBER ENTRIES                                                   */\n/*------------------------------------------------------------------------*/\nstruct lineno\n{\n        union\n        {\n                long    l_symndx ;      /* sym. table index of function name\n                                                iff l_lnno == 0      */\n                long    l_paddr ;       /* (physical) address of line number */\n        }               l_addr ;\n        unsigned short  l_lnno ;        /* line number */\n};\n\n#define LINENO  struct lineno\n#define LINESZ  6       /* sizeof(LINENO) */\n\n\f\n/*------------------------------------------------------------------------*/\n/*   STORAGE CLASSES                                                      */\n/*------------------------------------------------------------------------*/\n#define  C_EFCN          -1    /* physical end of function */\n#define  C_NULL          0\n#define  C_AUTO          1     /* automatic variable */\n#define  C_EXT           2     /* external symbol */\n#define  C_STAT          3     /* static */\n#define  C_REG           4     /* register variable */\n#define  C_EXTDEF        5     /* external definition */\n#define  C_LABEL         6     /* label */\n#define  C_ULABEL        7     /* undefined label */\n#define  C_MOS           8     /* member of structure */\n#define  C_ARG           9     /* function argument */\n#define  C_STRTAG        10    /* structure tag */\n#define  C_MOU           11    /* member of union */\n#define  C_UNTAG         12    /* union tag */\n#define  C_TPDEF         13    /* type definition */\n#define C_USTATIC        14    /* undefined static */\n#define  C_ENTAG         15    /* enumeration tag */\n#define  C_MOE           16    /* member of enumeration */\n#define  C_REGPARM       17    /* register parameter */\n#define  C_FIELD         18    /* bit field */\n\n#define  C_BLOCK         100   /* \".bb\" or \".eb\" */\n#define  C_FCN           101   /* \".bf\" or \".ef\" */\n#define  C_EOS           102   /* end of structure */\n#define  C_FILE          103   /* file name */\n#define  C_LINE          104   /* dummy sclass for line number entry */\n#define  C_ALIAS         105   /* duplicate tag */\n#define  C_HIDDEN        106   /* special storage class for external */\n                               /* symbols in dmert public libraries  */\n\f\n/*------------------------------------------------------------------------*/\n/*  SYMBOL TABLE ENTRIES                                                  */\n/*------------------------------------------------------------------------*/\n\n#define  SYMNMLEN   8      /*  Number of characters in a symbol name */\n#define  FILNMLEN   14     /*  Number of characters in a file name */\n#define  DIMNUM     4      /*  Number of array dimensions in auxiliary entry */\n\n\nstruct syment\n{\n        union\n        {\n                char            _n_name[SYMNMLEN];      /* old COFF version */\n                struct\n                {\n                        long    _n_zeroes;      /* new == 0 */\n                        long    _n_offset;      /* offset into string table */\n                } _n_n;\n                char            *_n_nptr[2];    /* allows for overlaying */\n        } _n;\n        long                    n_value;        /* value of symbol */\n        short                   n_scnum;        /* section number */\n        unsigned short          n_type;         /* type and derived type */\n        char                    n_sclass;       /* storage class */\n        char                    n_numaux;       /* number of aux. entries */\n};\n\n#define n_name          _n._n_name\n#define n_nptr          _n._n_nptr[1]\n#define n_zeroes        _n._n_n._n_zeroes\n#define n_offset        _n._n_n._n_offset\n\n/*------------------------------------------------------------------------*/\n/* Relocatable symbols have a section number of the                       */\n/* section in which they are defined.  Otherwise, section                 */\n/* numbers have the following meanings:                                   */\n/*------------------------------------------------------------------------*/\n#define  N_UNDEF  0                     /* undefined symbol */\n#define  N_ABS    -1                    /* value of symbol is absolute */\n#define  N_DEBUG  -2                    /* special debugging symbol  */\n#define  N_TV     (unsigned short)-3    /* needs transfer vector (preload) */\n#define  P_TV     (unsigned short)-4    /* needs transfer vector (postload) */\n\n\f\n/*------------------------------------------------------------------------*/\n/* The fundamental type of a symbol packed into the low                   */\n/* 4 bits of the word.                                                    */\n/*------------------------------------------------------------------------*/\n#define  _EF    \".ef\"\n\n#define  T_NULL     0          /* no type info */\n#define  T_ARG      1          /* function argument (only used by compiler) */\n#define  T_CHAR     2          /* character */\n#define  T_SHORT    3          /* short integer */\n#define  T_INT      4          /* integer */\n#define  T_LONG     5          /* long integer */\n#define  T_FLOAT    6          /* floating point */\n#define  T_DOUBLE   7          /* double word */\n#define  T_STRUCT   8          /* structure  */\n#define  T_UNION    9          /* union  */\n#define  T_ENUM     10         /* enumeration  */\n#define  T_MOE      11         /* member of enumeration */\n#define  T_UCHAR    12         /* unsigned character */\n#define  T_USHORT   13         /* unsigned short */\n#define  T_UINT     14         /* unsigned integer */\n#define  T_ULONG    15         /* unsigned long */\n\n/*------------------------------------------------------------------------*/\n/* derived types are:                                                     */\n/*------------------------------------------------------------------------*/\n#define  DT_NON      0          /* no derived type */\n#define  DT_PTR      1          /* pointer */\n#define  DT_FCN      2          /* function */\n#define  DT_ARY      3          /* array */\n\n#define MKTYPE(basic, d1,d2,d3,d4,d5,d6) \\\n       ((basic) | ((d1) <<  4) | ((d2) <<  6) | ((d3) <<  8) |\\\n                  ((d4) << 10) | ((d5) << 12) | ((d6) << 14))\n\n/*------------------------------------------------------------------------*/\n/* type packing constants and macros                                      */\n/*------------------------------------------------------------------------*/\n#define  N_BTMASK_COFF     017\n#define  N_TMASK_COFF      060\n#define  N_TMASK1_COFF     0300\n#define  N_TMASK2_COFF     0360\n#define  N_BTSHFT_COFF     4\n#define  N_TSHIFT_COFF     2\n\n#define  BTYPE_COFF(x)  ((x) & N_BTMASK_COFF)  \n#define  ISINT(x)  (((x) >= T_CHAR && (x) <= T_LONG) ||   \\\n\t\t    ((x) >= T_UCHAR && (x) <= T_ULONG) || (x) == T_ENUM)\n#define  ISFLT_COFF(x)  ((x) == T_DOUBLE || (x) == T_FLOAT)\n#define  ISPTR_COFF(x)  (((x) & N_TMASK_COFF) == (DT_PTR << N_BTSHFT_COFF)) \n#define  ISFCN_COFF(x)  (((x) & N_TMASK_COFF) == (DT_FCN << N_BTSHFT_COFF))\n#define  ISARY_COFF(x)  (((x) & N_TMASK_COFF) == (DT_ARY << N_BTSHFT_COFF))\n#define  ISTAG_COFF(x)  ((x)==C_STRTAG || (x)==C_UNTAG || (x)==C_ENTAG)\n\n#define  INCREF_COFF(x) ((((x)&~N_BTMASK_COFF)<<N_TSHIFT_COFF)|(DT_PTR<<N_BTSHFT_COFF)|(x&N_BTMASK_COFF))\n#define  DECREF_COFF(x) ((((x)>>N_TSHIFT_COFF)&~N_BTMASK_COFF)|((x)&N_BTMASK_COFF))\n\n\f\n/*------------------------------------------------------------------------*/\n/*  AUXILIARY SYMBOL ENTRY                                                */\n/*------------------------------------------------------------------------*/\nunion auxent\n{\n\tstruct\n\t{\n\t\tlong            x_tagndx;       /* str, un, or enum tag indx */\n\t\tunion\n\t\t{\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tunsigned short  x_lnno; /* declaration line number */\n\t\t\t\tunsigned short  x_size; /* str, union, array size */\n\t\t\t} x_lnsz;\n\t\t\tlong    x_fsize;        /* size of function */\n\t\t} x_misc;\n\t\tunion\n\t\t{\n\t\t\tstruct                  /* if ISFCN, tag, or .bb */\n\t\t\t{\n\t\t\t\tlong    x_lnnoptr;      /* ptr to fcn line # */\n\t\t\t\tlong    x_endndx;       /* entry ndx past block end */\n\t\t\t}       x_fcn;\n\t\t\tstruct                  /* if ISARY, up to 4 dimen. */\n\t\t\t{\n\t\t\t\tunsigned short  x_dimen[DIMNUM];\n\t\t\t}       x_ary;\n\t\t}               x_fcnary;\n\t\tunsigned short  x_regcount;   /* number of registers used by func */\n\t}       x_sym;\n\tstruct\n\t{\n\t\tchar    x_fname[FILNMLEN];\n\t}       x_file;\n\tstruct\n\t{\n\t\tlong    x_scnlen;          /* section length */\n\t\tunsigned short  x_nreloc;  /* number of relocation entries */\n\t\tunsigned short  x_nlinno;  /* number of line numbers */\n\t}       x_scn;\n};\n\n#define SYMENT  struct syment\n#define SYMESZ  18      /* sizeof(SYMENT) */\n\n#define AUXENT  union auxent\n#define AUXESZ  18      /* sizeof(AUXENT) */\n\n/*------------------------------------------------------------------------*/\n/*  NAMES OF \"SPECIAL\" SYMBOLS                                            */\n/*------------------------------------------------------------------------*/\n#define _STEXT          \".text\"\n#define _ETEXT          \"etext\"\n#define _SDATA          \".data\"\n#define _EDATA          \"edata\"\n#define _SBSS           \".bss\"\n#define _END            \"end\"\n#define _CINITPTR       \"cinit\"\n\n/*--------------------------------------------------------------------------*/\n/*  ENTRY POINT SYMBOLS                                                     */\n/*--------------------------------------------------------------------------*/\n#define _START          \"_start\"\n#define _MAIN           \"_main\"\n    /*  _CSTART         \"_c_int00\"          (defined in params.h)  */\n\n\n#define _TVORIG         \"_tvorig\"\n#define _TORIGIN        \"_torigin\"\n#define _DORIGIN        \"_dorigin\"\n\n#define _SORIGIN        \"_sorigin\"\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 20.59765625,
          "content": "#!/bin/sh\n#\n# tcc configure script (c) 2003 Fabrice Bellard\n\n# set temporary file name\n# if test ! -z \"$TMPDIR\" ; then\n#     TMPDIR1=\"${TMPDIR}\"\n# elif test ! -z \"$TEMPDIR\" ; then\n#     TMPDIR1=\"${TEMPDIR}\"\n# else\n#     TMPDIR1=\"/tmp\"\n# fi\n#\n# bashism: TMPN=\"${TMPDIR1}/tcc-conf-${RANDOM}-$$-${RANDOM}.c\"\n\nTMPN=\"./conftest-$$\"\nTMPH=$TMPN.h\n\n# default parameters\nprefix=\"\"\nexecprefix=\"\"\nbindir=\"\"\nlibdir=\"\"\ntccdir=\"\"\nincludedir=\"\"\nmandir=\"\"\ninfodir=\"\"\nsysroot=\"\"\ncross_prefix=\"\"\ncc=\"gcc\"\nar=\"ar\"\nbigendian=\"no\"\nmingw32=\"no\"\nLIBSUF=\".a\"\nEXESUF=\"\"\nDLLSUF=\".so\"\ntcc_usrinclude=\"\"\ntcc_sysincludepaths=\"\"\ntcc_libpaths=\"\"\ntcc_crtprefix=\"\"\ntcc_elfinterp=\"\"\ntriplet=\ntcc_lddir=\nconfvars=\nsuggest=\"yes\"\ngcc_major=0\ngcc_minor=0\ncc_name=\"gcc\"\nar_set=\ncpu=\ncpuver=\ndwarf=\ntargetos=\nbuild_cross=\n\n# use CC/AR from environment when set\ntest -n \"$CC\" && cc=\"$CC\"\ntest -n \"$AR\" && ar=\"$AR\"\n\n# set default CFLAGS if unset in environment\ntest -z \"$CFLAGS\" && CFLAGS=\"-Wall -O2\"\n\n# find source path\nsource_path=${0%configure}\nsource_path=${source_path%/}\n\n# $1: --OPTNAME=VALUE [, $2: NAME to assign-to instead of OPTNAME]\nassign_opt() {\n  set -- \"${2:-${1%%=*}}\" \"${1#*=}\"  # [--OPT]NAME VALUE\n  eval ${1#--}=\\$2  # no risk of IFS/glob in [OPT]NAME\n}\n\n# succeed if $1 doesn't IFS-split funny (globs, spaces, ...)\ngood_split() {\n  set -- \"$1\" $1\n  test $# = 2 && test \"$1\" = \"$2\"\n}\n\n# $1: NAME[=VALUE]  succeed if confvars has NAME or NAME=* element\nconfvars_has() {\n  ! case \" $confvars \" in *\" ${1%%=*} \"* | *\" ${1%%=*}=\"*)\n    false\n  esac\n}\n\n# [multiple] NAME or NAME=VAL\nconfvars_set() {\n  for cv; do\n    good_split \"$cv\" || { echo \"configure: ERROR: bad config '$cv'\"; exit 1; }\n    confvars_has \"$cv\" && echo \"configure: WARNING: duplicate config '$cv'\"\n    confvars=\"$confvars $cv\"\n  done\n}\n\nfor opt do\n  eval opt=\\\"$opt\\\"\n  case \"$opt\" in\n  --prefix=*) assign_opt \"$opt\"\n  ;;\n  --exec-prefix=*) assign_opt \"$opt\" execprefix\n  ;;\n  --tccdir=*) assign_opt \"$opt\"\n  ;;\n  --bindir=*) assign_opt \"$opt\"\n  ;;\n  --libdir=*) assign_opt \"$opt\"\n  ;;\n  --includedir=*) assign_opt \"$opt\"\n  ;;\n  --sharedir=*) assign_opt \"$opt\"\n  ;;\n  --mandir=*) assign_opt \"$opt\"\n  ;;\n  --infodir=*) assign_opt \"$opt\"\n  ;;\n  --docdir=*) assign_opt \"$opt\"\n  ;;\n  --sysroot=*) assign_opt \"$opt\"\n  ;;\n  --targetos=*) assign_opt \"$opt\"\n  ;;\n  --source-path=*) assign_opt \"$opt\" source_path\n  ;;\n  --cross-prefix=*) assign_opt \"$opt\" cross_prefix\n  ;;\n  --cc=*) assign_opt \"$opt\"\n  ;;\n  --ar=*) assign_opt \"$opt\" ; ar_set=\"yes\"\n  ;;\n  --extra-cflags=*) assign_opt \"$opt\" CFLAGS\n  ;;\n  --extra-ldflags=*) assign_opt \"$opt\" LDFLAGS\n  ;;\n  --extra-libs=*) assign_opt \"$opt\" extralibs\n  ;;\n  --sysincludepaths=*) assign_opt \"$opt\" tcc_sysincludepaths\n  ;;\n  --libpaths=*) assign_opt \"$opt\" tcc_libpaths\n  ;;\n  --crtprefix=*) assign_opt \"$opt\" tcc_crtprefix\n  ;;\n  --elfinterp=*) assign_opt \"$opt\" tcc_elfinterp\n  ;;\n  --triplet=*) assign_opt \"$opt\"\n  ;;\n  --cpu=*) assign_opt \"$opt\"\n  ;;\n  --dwarf=*) confvars_set \"dwarf=${opt#*=}\"\n  ;;\n  --enable-cross) confvars_set cross\n  ;;\n  --disable-static) confvars_set static=no\n  ;;\n  --enable-static) confvars_set static\n  ;;\n  --disable-rpath) confvars_set rpath=no\n  ;;\n  --debug) confvars_set debug\n  ;;\n  --with-libgcc) confvars_set libgcc\n  ;;\n  --with-selinux) confvars_set selinux\n  ;;\n  --tcc-switches=*) assign_opt \"$opt\" tcc_switches\n  ;;\n  --config-mingw32) mingw32=yes\n  ;;\n  --config-mingw32=*) assign_opt \"$opt\" mingw32\n  ;;\n  --config-*) confvars_set \"${opt#--config-}\"; suggest=\"no\"\n  ;;\n  --help|-h) show_help=\"yes\"\n  ;;\n  *) echo \"configure: WARNING: unrecognized option $opt\"\n  ;;\n  esac\ndone\n\nshow_help() {\ncat << EOF\nUsage: configure [options]\nOptions: [defaults in brackets after descriptions]\n\nStandard options:\n  --help                   print this message\n  --prefix=PREFIX          install in PREFIX [$prefix]\n  --exec-prefix=EPREFIX    install architecture-dependent files in EPREFIX\n\t\t\t   [same as prefix]\n  --bindir=DIR             user executables in DIR [EPREFIX/bin]\n  --libdir=DIR             object code libraries in DIR [EPREFIX/lib]\n  --tccdir=DIR             installation directory [EPREFIX/lib/tcc]\n  --includedir=DIR         C header files in DIR [PREFIX/include]\n  --sharedir=DIR           documentation root DIR [PREFIX/share]\n  --docdir=DIR             documentation in DIR [SHAREDIR/doc/tcc]\n  --mandir=DIR             man documentation in DIR [SHAREDIR/man]\n  --infodir=DIR            info documentation in DIR [SHAREDIR/info]\n\nAdvanced options (experts only):\n  --source-path=PATH       path of source code [$source_path]\n  --sysroot=PREFIX         prepend PREFIX to library/include paths [$sysroot]\n  --cc=CC                  use C compiler CC [$cc]\n  --ar=AR                  create archives using AR [$ar]\n  --extra-cflags=          specify compiler flags [$CFLAGS]\n  --extra-ldflags=         specify linker options [$LDFLAGS]\n\n  --debug                  include debug info with resulting binaries\n  --disable-static         make libtcc.so instead of libtcc.a\n  --enable-static          make libtcc.a instead of libtcc.dll (win32)\n  --disable-rpath          disable use of -rpath with libtcc.so\n  --with-libgcc            use libgcc_s.so.1 instead of libtcc1.a\n  --with-selinux           use mmap for executable memory (tcc -run)\n  --enable-cross           build cross compilers (see also 'make help')\n\n  --sysincludepaths=...    specify system include paths, colon separated\n  --libpaths=...           specify system library paths, colon separated\n  --crtprefix=...          specify locations of crt?.o, colon separated\n  --elfinterp=...          specify elf interpreter\n  --triplet=...            specify system library/include directory triplet\n  --tcc-switches=...       specify implicit switches passed to tcc\n\n  --config-uClibc,-musl    enable system specific configurations\n  --config-mingw32[=yes|no] build on windows using msys, busybox, etc.\n  --config-backtrace=no    disable stack backtraces (with -run or -bt)\n  --config-bcheck=no       disable bounds checker (-b)\n  --config-predefs=no      do not compile tccdefs.h, instead just include\n  --config-new_macho=no|yes force apple object format (autodetect osx <= 10)\n  --config-new_dtags=yes   use new ELF DTAGs (DT_RUNPATH instead of DT_RPATH)\n  --config-codesign=no     do not use codesign on apple to sign executables\n  --config-dwarf=x         use dwarf debug info instead of stabs (x=2..5)\n\nCross build options (experimental):\n  --cpu=CPU                target CPU [$cpu]\n  --targetos=...           target OS (Darwin,WIN32,Android/Termux) [$targetos]\n  --cross-prefix=PREFIX    use PREFIX for compile tools [$cross_prefix]\nEOF\nexit 1\n}\n\ndefault() # set variable unless already set and not empty\n{\n    test -n \"$2\" && eval : \\${$1:=\\$2}  # ': ${foo:=$2}'\n}\n\ndefault_conf() # add one config to confvars unless already present\n{\n    confvars_has \"$1\" || confvars_set \"$1\"\n}\n\nif test -z \"${source_path#.}\" ; then\n  source_path=$(pwd)\n  source_path_used=\"no\"\nelse\n  source_path_used=\"yes\"\nfi\n\n# OS specific\nbuildos=$(uname)\ncpu_sys=$(uname -m)\n\ncase $buildos in\n  Windows_NT|MINGW*|MSYS*|CYGWIN*)\n    buildos=\"WIN32\"\n    test \"$MSYSTEM\" = \"MINGW32\" && cpu_sys=i386\n  ;;\n  Linux)\n    if test \"$(uname -o)\" = \"Android\"; then\n      buildos=Android\n      if test -n \"$TERMUX_VERSION\"; then\n        buildos=Termux\n      fi\n    fi\n  ;;\nesac\n\nif test \"$mingw32\" = \"yes\"; then\n  default targetos WIN32\nelse\n  default targetos \"$buildos\"\nfi\n\ndefault cpu \"$cpu_sys\"\n\n# check for crpss build\nif test \"$cpu\" != \"$cpu_sys\" ||\n   test \"$targetos\" != \"$buildos\" ||\n   test -n \"$cross_prefix\"\nthen\n  build_cross=\"yes\"\n  cc=\"${cross_prefix}${cc}\"\n  ar=\"${cross_prefix}${ar}\"\nfi\n\ncase \"$cpu\" in\n  x86|i386|i486|i586|i686|i86pc|BePC|i686-AT386)\n    cpu=\"i386\"\n  ;;\n  x86_64|amd64|x86-64)\n    cpu=\"x86_64\"\n  ;;\n  evbarm)\n    case \"`uname -p`\" in\n      aarch64|arm64)\n        cpu=\"arm64\"\n        ;;\n      earmv*)\n        cpu=\"arm\"\n        ;;\n    esac\n  ;;\n  aarch64|arm64|evbarm)\n    cpu=\"arm64\"\n  ;;\n  arm*)\n    case \"$cpu\" in\n      arm|armv4l)\n\tcpuver=4\n      ;;\n      armv5tel|armv5tejl)\n\tcpuver=5\n      ;;\n      armv6j|armv6l)\n\tcpuver=6\n      ;;\n      armv7|armv7a|armv7l)\n\tcpuver=7\n      ;;\n    esac\n    cpu=\"arm\"\n  ;;\n  alpha)\n    cpu=\"alpha\"\n  ;;\n  \"Power Macintosh\"|ppc|ppc64)\n    cpu=\"ppc\"\n  ;;\n  mips)\n    cpu=\"mips\"\n  ;;\n  s390)\n    cpu=\"s390\"\n  ;;\n  riscv64)\n    cpu=\"riscv64\"\n  ;;\n  *)\n    echo \"Unsupported CPU\"\n    exit 1\n  ;;\nesac\n\ncase $targetos in\n  Darwin)\n    confvars_set OSX dwarf=4\n    default_conf \"codesign\"\n    DLLSUF=\".dylib\"\n    if test -z \"$build_cross\"; then\n      cc=`command -v cc`\n      cc=`readlink $cc || echo clang`\n      tcc_usrinclude=\"`xcrun --show-sdk-path`/usr/include\"\n      if test \"${confvars%new_macho*}\" = \"${confvars}\"; then\n          # if new_macho was not specified and (known) ver <= 10, use old (=no)\n          osxver=$(sw_vers -productVersion 2>/dev/null)  # X.Y.Z\n          osxver=${osxver%%.*}  # major version (or empty on sw_vers error)\n          [ \"${osxver:-11}\" -ge 11 ] || confvars_set new_macho=no\n      fi\n    fi\n    # on OSX M1 with --cpu=x86_64, build a tcc to run under rosetta entirely\n    if test \"$cpu\" = x86_64 && test \"$cpu_sys\" = arm64; then\n        CFLAGS=\"$CFLAGS -arch $cpu\"\n        LDFLAGS=\"$LDFLAGS -arch $cpu\"\n    fi\n    ;;\n  DragonFly|OpenBSD|FreeBSD|NetBSD)\n    confvars_set BSD ldl=no\n    ;;\n  Android|Termux)\n    if test \"$targetos\" = \"Termux\"; then\n      targetos=Android\n      default sysroot \"/data/data/com.termux/files/usr\"\n    else\n      default sysroot \"/usr\"\n    fi\n    default prefix \"${sysroot}\"\n    confvars_set Android new_dtags rpath=no\n    test \"${cpu}\" != \"i386\" && confvars_set pie\n    default_conf \"static=no\"\n    case \"$cpu\" in\n      arm) default triplet \"arm-linux-androideabi\"; cpuver=7 ;;\n      arm64) default triplet \"aarch64-linux-android\" ;;\n      x86_64) default triplet \"x86_64-linux-android\" ;;\n      i386) default triplet \"i686-linux-android\" ;;\n    esac\n    test \"${cpu%64}\" != \"${cpu}\" && S=\"64\" || S=\"\"\n    default tcc_sysincludepaths \"{B}/include:{R}/include:{R}/include/${triplet}\"\n    default tcc_libpaths \"{B}:{R}/lib:/system/lib${S}\"\n    default tcc_crtprefix \"{R}/lib\"\n    default tcc_elfinterp \"/system/bin/linker${S}\"\n    default tcc_switches \"-Wl,-rpath=$sysroot/lib\"\n    ;;\n  WIN32)\n    mingw32=\"yes\"\n    confvars=\"WIN32 $confvars\"  # WIN32 intentionally first (commit 729918ef)\n    default prefix \"C:/Program Files/tcc\"\n    default tccdir \"${prefix}\"\n    default bindir \"${tccdir}\"\n    default docdir \"${tccdir}/doc\"\n    default libdir \"${tccdir}/libtcc\"\n    # set tccdir at runtime from executable path\n    test \"$tccdir\" = \"$bindir\" && tccdir_auto=\"yes\"\n    # chech $cc to avoid mingw gcc dependencies such as 'libgcc_s_dw2-1.dll'\n    # (no confirmed $cc_name yet, and also will never have if cross compiling)\n    test \"${cc%gcc*}\" = \"$cc\" || default LDFLAGS \"-static\"\n    LIBSUF=\".lib\"\n    EXESUF=\".exe\"\n    DLLSUF=\".dll\"\n    if test \"$source_path_used\" = \"no\"; then\n      source_path=\".\"\n    fi\n    ;;\n  *)\n    ;;\nesac\n\nif test \"$mingw32\" = \"no\"; then\n  default prefix       \"/usr/local\"\n  default execprefix   \"${prefix}\"\n  default libdir       \"${execprefix}/lib\"\n  default bindir       \"${execprefix}/bin\"\n  default tccdir       \"${libdir}/tcc\"\n  default includedir   \"${prefix}/include\"\n  default sharedir     \"${prefix}/share\"\n  default docdir       \"${sharedir}/doc\"\n  default mandir       \"${sharedir}/man\"\n  default infodir      \"${sharedir}/info\"\nfi\n\nif test x\"$show_help\" = \"xyes\" ; then\n    show_help\nfi\n\nCONFTEST=./conftest$EXESUF\nif test -z \"$cross_prefix\" \\\n    && $cc -o $CONFTEST \"$source_path/conftest.c\" \\\n    && $CONFTEST 2>/dev/null; then\n  cc_name=\"$($CONFTEST compiler)\"\n  gcc_major=\"$($CONFTEST version)\"\n  gcc_minor=\"$($CONFTEST minor)\"\nelse\n  if test -z \"$build_cross\"; then\n    echo \"configure: error: '$cc' failed to compile conftest.c.\"\n  fi\n  if test \"${cc%tcc*}\" != \"$cc\"; then\n    cc_name=\"tcc\"\n  elif test \"${cc%clang*}\" != \"$cc\"; then\n    cc_name=\"clang\"\n  fi\nfi\n\nif test -z \"$build_cross\"; then\n  bigendian=\"$($CONFTEST bigendian)\"\n  _triplet=\"$($CONFTEST triplet)\"\n  if test \"$mingw32\" = \"no\" ; then\n      if test -z \"$triplet\" && test -n \"$_triplet\"; then\n        if test -f \"/usr/lib/$_triplet/crti.o\"; then\n          triplet=\"$_triplet\"\n        fi\n      fi\n      if test -z \"$triplet\"; then\n        case $cpu in x86_64|arm64|riscv64)\n          if test -f \"/usr/lib64/crti.o\" ; then\n            tcc_lddir=\"lib64\"\n          fi\n        esac\n      fi\n      if test \"$suggest\" = \"yes\"; then\n        if test -f \"/lib/ld-uClibc.so.0\" ; then\n          echo \"Perhaps you want ./configure --config-uClibc\"\n        fi\n        if test -f \"/lib/ld-musl-${cpu}.so.1\"; then\n          echo \"Perhaps you want ./configure --config-musl\"\n        fi\n      fi\n  fi\nelse\n  # can only make guesses about compiler and target\n  case $cpu in\n    ppc|mips|s390)  bigendian=yes;;\n  esac\n  case $targetos in\n    Linux)\n      default triplet \"${cpu}-linux-gnu\"\n  esac\nfi\n\nif test \"$bigendian\" = \"yes\" ; then\n  confvars_set BIGENDIAN\nfi\n\nif test \"$cpu\" = \"arm\"; then\n  if test \"${triplet%eabihf}\" != \"$triplet\" ; then\n    confvars_set arm_eabihf arm_vfp\n  elif test \"${triplet%eabi}\" != \"$triplet\" ; then\n    confvars_set arm_eabi arm_vfp\n  elif test -z \"$build_cross\"; then\n    if test \"${_triplet%eabihf}\" != \"$_triplet\" ; then\n      confvars_set arm_eabihf arm_vfp\n    elif test \"${_triplet%eabi}\" != \"$_triplet\" ; then\n      confvars_set arm_eabi arm_vfp\n    elif grep -s -q \"^Features.* \\(vfp\\|iwmmxt\\) \" /proc/cpuinfo ; then\n      confvars_set arm_vfp\n    fi\n  fi\nfi\n\n# a final configuration tuning\nif test \"$cc_name\" != \"tcc\"; then\n  OPT1=\"-Wdeclaration-after-statement\" #-fno-strict-aliasing\n  # we want -Wno- but gcc does not always reject unknown -Wno- options\n  if test \"$cc_name\" = \"clang\"; then\n    OPT2= #\"-Wstring-plus-int\"\n  else\n    OPT2=\"-Wunused-result\"\n  fi\n  $cc $OPT1 $OPT2 -o a.out -c -xc - < /dev/null > cc_msg.txt 2>&1\n  for o in $OPT1; do # enable these options\n    if ! grep -q -- $o cc_msg.txt; then CFLAGS=\"$CFLAGS $o\"; fi\n  done\n  for o in $OPT2; do # disable these options\n    if ! grep -q -- $o cc_msg.txt; then CFLAGS=\"$CFLAGS -Wno-${o#-W*}\"; fi\n  done\n  # cat cc_msg.txt\n  # echo $CFLAGS\n  rm -f cc_msg.txt a.out\nelse # cc is tcc\n  test \"$ar_set\" || ar=\"$cc -ar\"\nfi\n\nfcho() { if test -n \"$2\"; then echo \"$1$2\"; fi }\n\nfcho \"Binary directory    \" \"$bindir\"\nfcho \"TinyCC directory    \" \"$tccdir\"\nfcho \"Library directory   \" \"$libdir\"\nfcho \"Include directory   \" \"$includedir\"\nfcho \"Manual directory    \" \"$mandir\"\nfcho \"Info directory      \" \"$infodir\"\nfcho \"Doc directory       \" \"$docdir\"\nfcho \"Target root prefix  \" \"$sysroot\"\nfcho \"/usr/include dir    \" \"$tcc_usrinclude\"\necho \"Source path         $source_path\"\necho \"Build OS            $(uname -m -s)\"\necho \"C compiler          $cc ($gcc_major.$gcc_minor)\"\necho \"Target OS           $targetos\"\necho \"CPU                 $cpu\"\nfcho \"Triplet             \" \"$triplet\"\nfcho \"Libs                \" \"$tcc_libpaths\"\nfcho \"Sysinclude          \" \"$tcc_sysincludepaths\"\nfcho \"Crt                 \" \"$tcc_crtprefix\"\nfcho \"Elfinterp           \" \"$tcc_elfinterp\"\nfcho \"Switches            \" \"$tcc_switches\"\nfcho \"Config              \" \"${confvars# }\"\necho \"Creating config.mak and config.h\"\n\nversion=$(head \"$source_path/VERSION\")\n\ncat >config.mak <<EOF\n# Automatically generated by configure - do not modify\nprefix=$prefix\nbindir=\\$(DESTDIR)$bindir\ntccdir=\\$(DESTDIR)$tccdir\nlibdir=\\$(DESTDIR)$libdir\nincludedir=\\$(DESTDIR)$includedir\nmandir=\\$(DESTDIR)$mandir\ninfodir=\\$(DESTDIR)$infodir\ndocdir=\\$(DESTDIR)$docdir\nCC=$cc\nCC_NAME=$cc_name\nGCC_MAJOR=$gcc_major\nGCC_MINOR=$gcc_minor\nAR=$ar\nLIBSUF=$LIBSUF\nEXESUF=$EXESUF\nDLLSUF=$DLLSUF\nCFLAGS=$CFLAGS\nLDFLAGS=$LDFLAGS\nARCH=$cpu\nTARGETOS=$targetos\nBUILDOS=$buildos\nVERSION=$version\nEOF\n\nif test \"$source_path_used\" = \"yes\" ; then\n    case $source_path in\n       /*) echo \"TOPSRC=$source_path\";;\n\t*) echo \"TOPSRC=\\$(TOP)/$source_path\";;\n     esac >>config.mak\nelse\n     echo 'TOPSRC=$(TOP)' >>config.mak\nfi\n\n# $1: macro name, $2: val to set - quoted [, $3: non-empty for #ifndef]\nprint_str() {\n  if test -n \"$2\"; then\n    test -n \"$3\" && echo \"#ifndef $1\" >> $TMPH\n    echo \"#define $1 \\\"$2\\\"\" >> $TMPH\n    test -n \"$3\" && echo \"#endif\" >> $TMPH\n  fi\n}\n\n# $1: macro name, $2: val to set [, $3: non-empty for #ifndef]\nprint_num() {\n  if test -n \"$2\"; then\n     test -n \"$3\" && echo \"#ifndef $1\" >> $TMPH\n     echo \"#define $1 $2\" >> $TMPH\n     test -n \"$3\" && echo \"#endif\" >> $TMPH\n  fi\n}\n\ncat >$TMPH <<EOF\n/* Automatically generated by configure - do not modify */\n\n#define TCC_VERSION \"$version\"\n\n#define CC_NAME CC_$cc_name\n#define GCC_MAJOR $gcc_major\n#define GCC_MINOR $gcc_minor\n\n#if !(TCC_TARGET_I386 || TCC_TARGET_X86_64 || TCC_TARGET_ARM\\\n || TCC_TARGET_ARM64 || TCC_TARGET_RISCV64 || TCC_TARGET_C67)\nEOF\n\npredefs=1\n# options that are applied only to the native tcc\nfor v in $cpu $confvars ; do\n  if test \"${v%=*}\" = \"$v\"; then\n    v=\"$v=yes\"\n  fi\n  R=\"CONFIG_$v\"\n  echo \"$R\" >> config.mak\n  case \"$R\" in\n    # CPU\n    CONFIG_i386=yes)        print_num TCC_TARGET_I386 1 ;;\n    CONFIG_x86_64=yes)      print_num TCC_TARGET_X86_64 1 ;;\n    CONFIG_arm64=yes)       print_num TCC_TARGET_ARM64 1 ;;\n    CONFIG_riscv64=yes)     print_num TCC_TARGET_RISCV64 1 ;;\n    CONFIG_arm=yes)         print_num TCC_TARGET_ARM 1\n                            print_num CONFIG_TCC_CPUVER \"$cpuver\" ;;\n    CONFIG_arm_eabihf=yes)  print_num TCC_ARM_EABI 1\n                            print_num TCC_ARM_HARDFLOAT 1 ;;\n    CONFIG_arm_eabi=yes)    print_num TCC_ARM_EABI 1 ;;\n    CONFIG_arm_vfp=yes)     print_num TCC_ARM_VFP 1 ;;\n    # OS\n    CONFIG_WIN32=yes)       print_num TCC_TARGET_PE 1 ;;\n    CONFIG_OSX=yes)         print_num TCC_TARGET_MACHO 1 ;;\n    CONFIG_Android=yes)     print_num TARGETOS_ANDROID 1 ;;\n    CONFIG_BSD=yes)         print_num TARGETOS_$targetos 1\n      case \"$targetos\" in\n        FreeBSD)    default tcc_elfinterp \"/libexec/ld-elf.so.1\";;\n        FreeBSD_kernel)\n          case \"$cpu\" in\n          x86_64)   default tcc_elfinterp \"/lib/ld-kfreebsd-x86-64.so.1\";;\n          *)        default tcc_elfinterp \"/lib/ld.so.1\";;\n          esac ;;\n        DragonFly)  default tcc_elfinterp \"/usr/libexec/ld-elf.so.2\";;\n        NetBSD)     default tcc_elfinterp \"/usr/libexec/ld.elf_so\";;\n        OpenBSD)    default tcc_elfinterp \"/usr/libexec/ld.so\";;\n      esac\n      ;;\n    CONFIG_uClibc=yes)      print_num CONFIG_TCC_UCLIBC 1\n      default tcc_elfinterp \"/lib/ld-uClibc.so.0\"\n      ;;\n    CONFIG_musl=yes)        print_num CONFIG_TCC_MUSL 1\n      case \"$cpu\" in\n        arm64)      default tcc_elfinterp \"/lib/ld-musl-aarch64.so.1\";;\n        *)          default tcc_elfinterp \"/lib/ld-musl-${cpu}.so.1\";;\n      esac\n      ;;\n    # other\n    CONFIG_libgcc=yes)      print_num CONFIG_USE_LIBGCC 1 ;;\n    CONFIG_selinux=yes)     print_num CONFIG_SELINUX 1 ;;\n    CONFIG_pie=yes)         print_num CONFIG_TCC_PIE 1 ;;\n    CONFIG_pic=yes)         print_num CONFIG_TCC_PIC 1 ;;\n    CONFIG_new_dtags=yes)   print_num CONFIG_NEW_DTAGS 1 ;;\n    CONFIG_codesign=yes)    print_num CONFIG_CODESIGN 1 ;;\n    CONFIG_new_macho=no)    print_num CONFIG_NEW_MACHO 0 ;;\n    CONFIG_bcheck=no)       print_num CONFIG_TCC_BCHECK 0 ;;\n    CONFIG_backtrace=no)    print_num CONFIG_TCC_BACKTRACE 0 ;;\n    CONFIG_dwarf=*)         print_num CONFIG_DWARF_VERSION ${R#*=} ;;\n    CONFIG_semlock=*)       print_num CONFIG_TCC_SEMLOCK ${R#*=} ;;\n    CONFIG_predefs=no)      predefs=0 ;;\n  esac\ndone\n\nprint_str CONFIG_USR_INCLUDE \"$tcc_usrinclude\"\nprint_str CONFIG_TCC_SYSINCLUDEPATHS \"$tcc_sysincludepaths\"\nprint_str CONFIG_TCC_LIBPATHS \"$tcc_libpaths\"\nprint_str CONFIG_TCC_CRTPREFIX \"$tcc_crtprefix\"\nprint_str CONFIG_TCC_ELFINTERP \"$tcc_elfinterp\"\nprint_str CONFIG_TCC_SWITCHES \"$tcc_switches\"\nprint_str CONFIG_LDDIR \"$tcc_lddir\"\nprint_str CONFIG_TRIPLET \"$triplet\"\necho \"#endif\" >> $TMPH && echo >> $TMPH\n\nprint_str CONFIG_SYSROOT \"$sysroot\" x\ntest \"$tccdir_auto\" = \"yes\" || print_str CONFIG_TCCDIR \"$tccdir\" x\nprint_num CONFIG_TCC_PREDEFS \"$predefs\"\n\ndiff $TMPH config.h >/dev/null 2>&1\nif test $? -ne 0 ; then\n    mv -f $TMPH config.h\nelse\n    echo \"config.h is unchanged\"\nfi\n\necho \"@set VERSION $version\" > config.texi\n\nrm -f $TMPN* $CONFTEST\n\n# ---------------------------------------------------------------------------\n# build tree in object directory if source path is different from current one\n\nuse_cp=\nfn_makelink()\n{\n    tgt=$1/$2\n    case $2 in\n    */*) dn=${2%/*}\n\t test -d $dn || mkdir -p $dn\n\t case $1 in\n\t /*) ;;\n\t  *) while test $dn ; do\n\t\ttgt=../$tgt; dn=${dn#${dn%%/*}}; dn=${dn#/}\n\t     done\n\t     ;;\n\t esac\n\t ;;\n    esac\n\n    test -n \"$use_cp\" || ln -sfn \"$tgt\" $2 ||\n        { use_cp=yes; echo \"ln failed. Using cp instead.\"; }\n    test -z \"$use_cp\" || cp -f \"$1/$2\" $2\n}\n\nif test \"$source_path_used\" = \"yes\" ; then\n  FILES=\"Makefile lib/Makefile tests/Makefile tests/tests2/Makefile tests/pp/Makefile\"\n  for f in $FILES ; do\n    fn_makelink \"$source_path\" $f\n  done\nfi\n\n# ---------------------------------------------------------------------------\n"
        },
        {
          "name": "conftest.c",
          "type": "blob",
          "size": 7.919921875,
          "content": "/* ----------------------------------------------------------------------- */\n/* with -D C2STR: convert tccdefs.h to C-strings */\n\n#if C2STR\n\n#include <stdio.h>\n#include <string.h>\n\n/* replace native host macros by compile-time versions */\nconst char *platform_macros[] = {\n    \"__i386__\",             \"TCC_TARGET_I386\",\n    \"__x86_64__\",           \"TCC_TARGET_X86_64\",\n    \"_WIN32\",               \"TCC_TARGET_PE\",\n    \"__arm__\",              \"TCC_TARGET_ARM\",\n    \"__ARM_EABI__\",         \"TCC_ARM_EABI\",\n    \"__aarch64__\",          \"TCC_TARGET_ARM64\",\n    \"__riscv\",              \"TCC_TARGET_RISCV64\",\n    \"__APPLE__\",            \"TCC_TARGET_MACHO\",\n    \"__FreeBSD__\",          \"TARGETOS_FreeBSD\",\n    \"__FreeBSD_kernel__\",   \"TARGETOS_FreeBSD_kernel\",\n    \"__OpenBSD__\",          \"TARGETOS_OpenBSD\",\n    \"__NetBSD__\",           \"TARGETOS_NetBSD\",\n    \"__linux__\",            \"TARGETOS_Linux\",\n    \"__ANDROID__\",          \"TARGETOS_ANDROID\",\n\n    \"__SIZEOF_POINTER__\",   \"PTR_SIZE\",\n    \"__SIZEOF_LONG__\",      \"LONG_SIZE\",\n    0\n};\n\nint isid(int c)\n{\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n        || (c >= '0' && c <= '9') || c == '_';\n}\n\nint isspc(int c)\n{\n    return (unsigned char)c <= ' ' && c != 0;\n}\n\nint main(int argc, char **argv)\n{\n    char l[1000], l2[1000], *p, *q, *p0;\n    FILE *fp, *op;\n    int c, e, f, s, cmt, cmt_n;\n    const char *r;\n\n    if (argc < 3)\n        return 1;\n\n    fp = fopen(argv[1], \"rb\");\n    op = fopen(argv[2], \"wb\");\n    if (!fp || !op) {\n        fprintf(stderr, \"c2str: file error\\n\");\n        return 1;\n    }\n\n    cmt = cmt_n = 0;\n    for (;;) {\n        p = l;\n    append:\n        if (fgets(p, sizeof l - (p - l), fp)) {\n            p = strchr(p, 0);\n            while (p > l && isspc(p[-1]))\n                --p;\n            *p = 0;\n        } else if (p == l)\n            break;\n\n        /* check for continuation */\n        if (p > l && p[-1] == '\\\\') {\n            p[-1] = ' ';\n            goto append;\n        }\n\n        /* count & skip leading spaces */\n        p = l, q = l2, f = 0;\n        while (*p && isspc(*p))\n            ++p, ++f;\n\n        /* handle comments */\n        if (p[0] == '/' && cmt == 0) {\n            if (p[1] == '*')\n                cmt = 2;\n            if (p[1] == '/')\n                cmt = 1;\n        }\n        if (cmt) {\n            fprintf(op, \"%s\", l);\n            if (++cmt_n == 1)\n                fprintf(op, \" (converted, do not edit this file)\");\n            fprintf(op, \"\\n\");\n            if (cmt == 1)\n                cmt = 0;\n            if (cmt == 2) {\n                p = strchr(l, 0);\n                if (p >= l + 2 && p[-1] == '/' && p[-2] == '*')\n                    cmt = 0;\n            }\n            continue;\n        }\n\n        if (f < 4) {\n            do {\n                /* replace machine/os macros by compile-time counterparts */\n                for (e = f = 0; (r = platform_macros[f]); f += 2) {\n                    c = strlen(r);\n                    /* remove 'defined' */\n                    //e = memcmp(p, \"defined \", 8) ? 0 : 8;\n                    if (0 == memcmp(p + e, r, c)) {\n                        p += e + c;\n                        q = strchr(strcpy(q, platform_macros[f + 1]), 0);\n                        break;\n                    }\n\n                }\n                if (r)\n                    continue;\n            } while (!!(*q++ = *p++));\n            /* output as is */\n            fprintf(op, \"%s\\n\", l2);\n            continue;\n\n        } else {\n            s = e = f = 0, p0 = p;\n            for (;;) {\n                c = *p++;\n\n                if (isspc(c)) {\n                    s = 1;\n                    continue;\n                }\n                if (c == '/' && (p[0] == '/' || p[0] == '*'))\n                    c = 0; /* trailing comment detected */\n                else if (s && q > l2\n                    && ((isid(q[-1]) && isid(c))\n                        // keep space after macro name\n                        || (q >= l2 + 2\n                            && l2[0] == '#'\n                            && l2[1] == 'd'\n                            && f < 2 && !e\n                            )))\n                    *q++ = ' ', ++f;\n                s = 0;\n\n                if (c == '(')\n                    ++e;\n                if (c == ')')\n                    --e;\n                if (c == '\\\\' || c == '\\\"')\n                    *q++ = '\\\\';\n                *q++ = c;\n                if (c == 0)\n                    break;\n                p0 = p;\n            }\n            /* output with quotes */\n            fprintf(op, \"    \\\"%s\\\\n\\\"%s\\n\", l2, p0);\n        }\n    }\n\n    fclose(fp);\n    fclose(op);\n    return 0;\n}\n\n/* ----------------------------------------------------------------------- */\n/* get some information from the host compiler for configure */\n\n#elif 1\n\n#include <stdio.h>\n\n#if defined(_WIN32)\n#include <fcntl.h>\n#include <io.h>\nint _CRT_glob = 0;\n#endif\n\n/* Define architecture */\n#if defined(__i386__) || defined _M_IX86\n# define TRIPLET_ARCH \"i386\"\n#elif defined(__x86_64__) || defined _M_AMD64\n# define TRIPLET_ARCH \"x86_64\"\n#elif defined(__arm__)\n# define TRIPLET_ARCH \"arm\"\n#elif defined(__aarch64__)\n# define TRIPLET_ARCH \"aarch64\"\n#elif defined(__riscv) && defined(__LP64__)\n# define TRIPLET_ARCH \"riscv64\"\n#else\n# define TRIPLET_ARCH \"unknown\"\n#endif\n\n/* Define OS */\n#if defined (__linux__)\n# define TRIPLET_OS \"linux\"\n#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)\n# define TRIPLET_OS \"kfreebsd\"\n#elif defined(__NetBSD__)\n# define TRIPLET_OS \"netbsd\"\n#elif defined(__OpenBSD__)\n# define TRIPLET_OS \"openbsd\"\n#elif defined(_WIN32)\n# define TRIPLET_OS \"win32\"\n#elif defined(__APPLE__)\n# define TRIPLET_OS \"darwin\"\n#elif !defined (__GNU__)\n# define TRIPLET_OS \"unknown\"\n#endif\n\n#if defined __ANDROID__\n# define ABI_PREFIX \"android\"\n#else\n# define ABI_PREFIX \"gnu\"\n#endif\n\n/* Define calling convention and ABI */\n#if defined (__ARM_EABI__)\n# if defined (__ARM_PCS_VFP)\n#  define TRIPLET_ABI ABI_PREFIX\"eabihf\"\n# else\n#  define TRIPLET_ABI ABI_PREFIX\"eabi\"\n# endif\n#else\n# define TRIPLET_ABI ABI_PREFIX\n#endif\n\n#if defined _WIN32\n# define TRIPLET TRIPLET_ARCH \"-\" TRIPLET_OS\n#elif defined __GNU__\n# define TRIPLET TRIPLET_ARCH \"-\" TRIPLET_ABI\n#else\n# define TRIPLET TRIPLET_ARCH \"-\" TRIPLET_OS \"-\" TRIPLET_ABI\n#endif\n\nint main(int argc, char *argv[])\n{\n#if defined(_WIN32)\n    _setmode(_fileno(stdout), _O_BINARY);  /* don't translate \\n to \\r\\n */\n#endif\n    switch(argc == 2 ? argv[1][0] : 0) {\n        case 'b'://igendian\n        {\n            volatile unsigned foo = 0x01234567;\n            puts(*(unsigned char*)&foo == 0x67 ? \"no\" : \"yes\");\n            break;\n        }\n#if defined(__clang__)\n        case 'm'://inor\n            printf(\"%d\\n\", __clang_minor__);\n            break;\n        case 'v'://ersion\n            printf(\"%d\\n\", __clang_major__);\n            break;\n#elif defined(__TINYC__)\n        case 'v'://ersion\n            puts(\"0\");\n            break;\n        case 'm'://inor\n            printf(\"%d\\n\", __TINYC__);\n            break;\n#elif defined(_MSC_VER)\n        case 'v'://ersion\n            puts(\"0\");\n            break;\n        case 'm'://inor\n            printf(\"%d\\n\", _MSC_VER);\n            break;\n#elif defined(__GNUC__) && defined(__GNUC_MINOR__)\n        /* GNU comes last as other compilers may add 'GNU' compatibility */\n        case 'm'://inor\n            printf(\"%d\\n\", __GNUC_MINOR__);\n            break;\n        case 'v'://ersion\n            printf(\"%d\\n\", __GNUC__);\n            break;\n#else\n        case 'm'://inor\n        case 'v'://ersion\n            puts(\"0\");\n            break;\n#endif\n        case 't'://riplet\n            puts(TRIPLET);\n            break;\n        case 'c'://ompiler\n#if defined(__clang__)\n            puts(\"clang\");\n#elif defined(__TINYC__)\n            puts(\"tcc\");\n#elif defined(_MSC_VER)\n            puts(\"msvc\");\n#elif defined(__GNUC__)\n            puts(\"gcc\");\n#else\n            puts(\"unknown\");\n#endif\n            break;\n        default:\n            break;\n    }\n    return 0;\n}\n\n/* ----------------------------------------------------------------------- */\n#endif\n"
        },
        {
          "name": "dwarf.h",
          "type": "blob",
          "size": 30.6640625,
          "content": "/* This file defines standard DWARF types, structures, and macros.\n   Copyright (C) 2000-2011, 2014, 2016, 2017, 2018 Red Hat, Inc.\n   This file is part of elfutils.\n\n   This file is free software; you can redistribute it and/or modify\n   it under the terms of either\n\n     * the GNU Lesser General Public License as published by the Free\n       Software Foundation; either version 3 of the License, or (at\n       your option) any later version\n\n   or\n\n     * the GNU General Public License as published by the Free\n       Software Foundation; either version 2 of the License, or (at\n       your option) any later version\n\n   or both in parallel, as here.\n\n   elfutils is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n\n   You should have received copies of the GNU General Public License and\n   the GNU Lesser General Public License along with this program.  If\n   not, see <http://www.gnu.org/licenses/>.  */\n\n#ifndef _DWARF_H\n#define\t_DWARF_H 1\n\n/* DWARF Unit Header Types.  */\nenum\n  {\n    DW_UT_compile = 0x01,\n    DW_UT_type = 0x02,\n    DW_UT_partial = 0x03,\n    DW_UT_skeleton = 0x04,\n    DW_UT_split_compile = 0x05,\n    DW_UT_split_type = 0x06,\n\n    DW_UT_lo_user = 0x80,\n    DW_UT_hi_user = 0xff\n  };\n\n/* DWARF tags.  */\nenum\n  {\n    DW_TAG_array_type = 0x01,\n    DW_TAG_class_type = 0x02,\n    DW_TAG_entry_point = 0x03,\n    DW_TAG_enumeration_type = 0x04,\n    DW_TAG_formal_parameter = 0x05,\n    /* 0x06 reserved.  */\n    /* 0x07 reserved.  */\n    DW_TAG_imported_declaration = 0x08,\n    /* 0x09 reserved.  */\n    DW_TAG_label = 0x0a,\n    DW_TAG_lexical_block = 0x0b,\n    /* 0x0c reserved.  */\n    DW_TAG_member = 0x0d,\n    /* 0x0e reserved.  */\n    DW_TAG_pointer_type = 0x0f,\n    DW_TAG_reference_type = 0x10,\n    DW_TAG_compile_unit = 0x11,\n    DW_TAG_string_type = 0x12,\n    DW_TAG_structure_type = 0x13,\n    /* 0x14 reserved.  */\n    DW_TAG_subroutine_type = 0x15,\n    DW_TAG_typedef = 0x16,\n    DW_TAG_union_type = 0x17,\n    DW_TAG_unspecified_parameters = 0x18,\n    DW_TAG_variant = 0x19,\n    DW_TAG_common_block = 0x1a,\n    DW_TAG_common_inclusion = 0x1b,\n    DW_TAG_inheritance = 0x1c,\n    DW_TAG_inlined_subroutine = 0x1d,\n    DW_TAG_module = 0x1e,\n    DW_TAG_ptr_to_member_type = 0x1f,\n    DW_TAG_set_type = 0x20,\n    DW_TAG_subrange_type = 0x21,\n    DW_TAG_with_stmt = 0x22,\n    DW_TAG_access_declaration = 0x23,\n    DW_TAG_base_type = 0x24,\n    DW_TAG_catch_block = 0x25,\n    DW_TAG_const_type = 0x26,\n    DW_TAG_constant = 0x27,\n    DW_TAG_enumerator = 0x28,\n    DW_TAG_file_type = 0x29,\n    DW_TAG_friend = 0x2a,\n    DW_TAG_namelist = 0x2b,\n    DW_TAG_namelist_item = 0x2c,\n    DW_TAG_packed_type = 0x2d,\n    DW_TAG_subprogram = 0x2e,\n    DW_TAG_template_type_parameter = 0x2f,\n    DW_TAG_template_value_parameter = 0x30,\n    DW_TAG_thrown_type = 0x31,\n    DW_TAG_try_block = 0x32,\n    DW_TAG_variant_part = 0x33,\n    DW_TAG_variable = 0x34,\n    DW_TAG_volatile_type = 0x35,\n    DW_TAG_dwarf_procedure = 0x36,\n    DW_TAG_restrict_type = 0x37,\n    DW_TAG_interface_type = 0x38,\n    DW_TAG_namespace = 0x39,\n    DW_TAG_imported_module = 0x3a,\n    DW_TAG_unspecified_type = 0x3b,\n    DW_TAG_partial_unit = 0x3c,\n    DW_TAG_imported_unit = 0x3d,\n    /* 0x3e reserved.  Was DW_TAG_mutable_type.  */\n    DW_TAG_condition = 0x3f,\n    DW_TAG_shared_type = 0x40,\n    DW_TAG_type_unit = 0x41,\n    DW_TAG_rvalue_reference_type = 0x42,\n    DW_TAG_template_alias = 0x43,\n    DW_TAG_coarray_type = 0x44,\n    DW_TAG_generic_subrange = 0x45,\n    DW_TAG_dynamic_type = 0x46,\n    DW_TAG_atomic_type = 0x47,\n    DW_TAG_call_site = 0x48,\n    DW_TAG_call_site_parameter = 0x49,\n    DW_TAG_skeleton_unit = 0x4a,\n    DW_TAG_immutable_type = 0x4b,\n\n    DW_TAG_lo_user = 0x4080,\n\n    DW_TAG_MIPS_loop = 0x4081,\n    DW_TAG_format_label = 0x4101,\n    DW_TAG_function_template = 0x4102,\n    DW_TAG_class_template = 0x4103,\n\n    DW_TAG_GNU_BINCL = 0x4104,\n    DW_TAG_GNU_EINCL = 0x4105,\n\n    DW_TAG_GNU_template_template_param = 0x4106,\n    DW_TAG_GNU_template_parameter_pack = 0x4107,\n    DW_TAG_GNU_formal_parameter_pack = 0x4108,\n    DW_TAG_GNU_call_site = 0x4109,\n    DW_TAG_GNU_call_site_parameter = 0x410a,\n\n    DW_TAG_hi_user = 0xffff\n  };\n\n\n/* Children determination encodings.  */\nenum\n  {\n    DW_CHILDREN_no = 0,\n    DW_CHILDREN_yes = 1\n  };\n\n\n/* DWARF attributes encodings.  */\nenum\n  {\n    DW_AT_sibling = 0x01,\n    DW_AT_location = 0x02,\n    DW_AT_name = 0x03,\n    /* 0x04 reserved.  */\n    /* 0x05 reserved.  */\n    /* 0x06 reserved.  */\n    /* 0x07 reserved.  */\n    /* 0x08 reserved.  */\n    DW_AT_ordering = 0x09,\n    /* 0x0a reserved.  */\n    DW_AT_byte_size = 0x0b,\n    DW_AT_bit_offset = 0x0c,  /* Deprecated in DWARF4.  */\n    DW_AT_bit_size = 0x0d,\n    /* 0x0e reserved.  */\n    /* 0x0f reserved.  */\n    DW_AT_stmt_list = 0x10,\n    DW_AT_low_pc = 0x11,\n    DW_AT_high_pc = 0x12,\n    DW_AT_language = 0x13,\n    /* 0x14 reserved.  */\n    DW_AT_discr = 0x15,\n    DW_AT_discr_value = 0x16,\n    DW_AT_visibility = 0x17,\n    DW_AT_import = 0x18,\n    DW_AT_string_length = 0x19,\n    DW_AT_common_reference = 0x1a,\n    DW_AT_comp_dir = 0x1b,\n    DW_AT_const_value = 0x1c,\n    DW_AT_containing_type = 0x1d,\n    DW_AT_default_value = 0x1e,\n    /* 0x1f reserved.  */\n    DW_AT_inline = 0x20,\n    DW_AT_is_optional = 0x21,\n    DW_AT_lower_bound = 0x22,\n    /* 0x23 reserved.  */\n    /* 0x24 reserved.  */\n    DW_AT_producer = 0x25,\n    /* 0x26 reserved.  */\n    DW_AT_prototyped = 0x27,\n    /* 0x28 reserved.  */\n    /* 0x29 reserved.  */\n    DW_AT_return_addr = 0x2a,\n    /* 0x2b reserved.  */\n    DW_AT_start_scope = 0x2c,\n    /* 0x2d reserved.  */\n    DW_AT_bit_stride = 0x2e,\n    DW_AT_upper_bound = 0x2f,\n    /* 0x30 reserved.  */\n    DW_AT_abstract_origin = 0x31,\n    DW_AT_accessibility = 0x32,\n    DW_AT_address_class = 0x33,\n    DW_AT_artificial = 0x34,\n    DW_AT_base_types = 0x35,\n    DW_AT_calling_convention = 0x36,\n    DW_AT_count = 0x37,\n    DW_AT_data_member_location = 0x38,\n    DW_AT_decl_column = 0x39,\n    DW_AT_decl_file = 0x3a,\n    DW_AT_decl_line = 0x3b,\n    DW_AT_declaration = 0x3c,\n    DW_AT_discr_list = 0x3d,\n    DW_AT_encoding = 0x3e,\n    DW_AT_external = 0x3f,\n    DW_AT_frame_base = 0x40,\n    DW_AT_friend = 0x41,\n    DW_AT_identifier_case = 0x42,\n    DW_AT_macro_info = 0x43, /* Deprecated in DWARF5.  */\n    DW_AT_namelist_item = 0x44,\n    DW_AT_priority = 0x45,\n    DW_AT_segment = 0x46,\n    DW_AT_specification = 0x47,\n    DW_AT_static_link = 0x48,\n    DW_AT_type = 0x49,\n    DW_AT_use_location = 0x4a,\n    DW_AT_variable_parameter = 0x4b,\n    DW_AT_virtuality = 0x4c,\n    DW_AT_vtable_elem_location = 0x4d,\n    DW_AT_allocated = 0x4e,\n    DW_AT_associated = 0x4f,\n    DW_AT_data_location = 0x50,\n    DW_AT_byte_stride = 0x51,\n    DW_AT_entry_pc = 0x52,\n    DW_AT_use_UTF8 = 0x53,\n    DW_AT_extension = 0x54,\n    DW_AT_ranges = 0x55,\n    DW_AT_trampoline = 0x56,\n    DW_AT_call_column = 0x57,\n    DW_AT_call_file = 0x58,\n    DW_AT_call_line = 0x59,\n    DW_AT_description = 0x5a,\n    DW_AT_binary_scale = 0x5b,\n    DW_AT_decimal_scale = 0x5c,\n    DW_AT_small = 0x5d,\n    DW_AT_decimal_sign = 0x5e,\n    DW_AT_digit_count = 0x5f,\n    DW_AT_picture_string = 0x60,\n    DW_AT_mutable = 0x61,\n    DW_AT_threads_scaled = 0x62,\n    DW_AT_explicit = 0x63,\n    DW_AT_object_pointer = 0x64,\n    DW_AT_endianity = 0x65,\n    DW_AT_elemental = 0x66,\n    DW_AT_pure = 0x67,\n    DW_AT_recursive = 0x68,\n    DW_AT_signature = 0x69,\n    DW_AT_main_subprogram = 0x6a,\n    DW_AT_data_bit_offset = 0x6b,\n    DW_AT_const_expr = 0x6c,\n    DW_AT_enum_class = 0x6d,\n    DW_AT_linkage_name = 0x6e,\n    DW_AT_string_length_bit_size = 0x6f,\n    DW_AT_string_length_byte_size = 0x70,\n    DW_AT_rank = 0x71,\n    DW_AT_str_offsets_base = 0x72,\n    DW_AT_addr_base = 0x73,\n    DW_AT_rnglists_base = 0x74,\n    /* 0x75 reserved.  */\n    DW_AT_dwo_name = 0x76,\n    DW_AT_reference = 0x77,\n    DW_AT_rvalue_reference = 0x78,\n    DW_AT_macros = 0x79,\n    DW_AT_call_all_calls = 0x7a,\n    DW_AT_call_all_source_calls = 0x7b,\n    DW_AT_call_all_tail_calls = 0x7c,\n    DW_AT_call_return_pc = 0x7d,\n    DW_AT_call_value = 0x7e,\n    DW_AT_call_origin = 0x7f,\n    DW_AT_call_parameter = 0x80,\n    DW_AT_call_pc = 0x81,\n    DW_AT_call_tail_call = 0x82,\n    DW_AT_call_target = 0x83,\n    DW_AT_call_target_clobbered = 0x84,\n    DW_AT_call_data_location = 0x85,\n    DW_AT_call_data_value = 0x86,\n    DW_AT_noreturn = 0x87,\n    DW_AT_alignment = 0x88,\n    DW_AT_export_symbols = 0x89,\n    DW_AT_deleted = 0x8a,\n    DW_AT_defaulted = 0x8b,\n    DW_AT_loclists_base = 0x8c,\n\n    DW_AT_lo_user = 0x2000,\n\n    DW_AT_MIPS_fde = 0x2001,\n    DW_AT_MIPS_loop_begin = 0x2002,\n    DW_AT_MIPS_tail_loop_begin = 0x2003,\n    DW_AT_MIPS_epilog_begin = 0x2004,\n    DW_AT_MIPS_loop_unroll_factor = 0x2005,\n    DW_AT_MIPS_software_pipeline_depth = 0x2006,\n    DW_AT_MIPS_linkage_name = 0x2007,\n    DW_AT_MIPS_stride = 0x2008,\n    DW_AT_MIPS_abstract_name = 0x2009,\n    DW_AT_MIPS_clone_origin = 0x200a,\n    DW_AT_MIPS_has_inlines = 0x200b,\n    DW_AT_MIPS_stride_byte = 0x200c,\n    DW_AT_MIPS_stride_elem = 0x200d,\n    DW_AT_MIPS_ptr_dopetype = 0x200e,\n    DW_AT_MIPS_allocatable_dopetype = 0x200f,\n    DW_AT_MIPS_assumed_shape_dopetype = 0x2010,\n    DW_AT_MIPS_assumed_size = 0x2011,\n\n    /* GNU extensions.  */\n    DW_AT_sf_names = 0x2101,\n    DW_AT_src_info = 0x2102,\n    DW_AT_mac_info = 0x2103,\n    DW_AT_src_coords = 0x2104,\n    DW_AT_body_begin = 0x2105,\n    DW_AT_body_end = 0x2106,\n    DW_AT_GNU_vector = 0x2107,\n    DW_AT_GNU_guarded_by = 0x2108,\n    DW_AT_GNU_pt_guarded_by = 0x2109,\n    DW_AT_GNU_guarded = 0x210a,\n    DW_AT_GNU_pt_guarded = 0x210b,\n    DW_AT_GNU_locks_excluded = 0x210c,\n    DW_AT_GNU_exclusive_locks_required = 0x210d,\n    DW_AT_GNU_shared_locks_required = 0x210e,\n    DW_AT_GNU_odr_signature = 0x210f,\n    DW_AT_GNU_template_name = 0x2110,\n    DW_AT_GNU_call_site_value = 0x2111,\n    DW_AT_GNU_call_site_data_value = 0x2112,\n    DW_AT_GNU_call_site_target = 0x2113,\n    DW_AT_GNU_call_site_target_clobbered = 0x2114,\n    DW_AT_GNU_tail_call = 0x2115,\n    DW_AT_GNU_all_tail_call_sites = 0x2116,\n    DW_AT_GNU_all_call_sites = 0x2117,\n    DW_AT_GNU_all_source_call_sites = 0x2118,\n    DW_AT_GNU_locviews = 0x2137,\n    DW_AT_GNU_entry_view = 0x2138,\n    DW_AT_GNU_macros = 0x2119,\n    DW_AT_GNU_deleted = 0x211a,\n    /* GNU Debug Fission extensions.  */\n    DW_AT_GNU_dwo_name = 0x2130,\n    DW_AT_GNU_dwo_id = 0x2131,\n    DW_AT_GNU_ranges_base = 0x2132,\n    DW_AT_GNU_addr_base = 0x2133,\n    DW_AT_GNU_pubnames = 0x2134,\n    DW_AT_GNU_pubtypes = 0x2135,\n\n    /* https://gcc.gnu.org/wiki/DW_AT_GNU_numerator_denominator  */\n    DW_AT_GNU_numerator = 0x2303,\n    DW_AT_GNU_denominator = 0x2304,\n    /* https://gcc.gnu.org/wiki/DW_AT_GNU_bias  */\n    DW_AT_GNU_bias = 0x2305,\n\n    DW_AT_hi_user = 0x3fff\n  };\n\n/* Old unofficially attribute names.  Should not be used.\n   Will not appear in known-dwarf.h  */\n\n/* DWARF1 array subscripts and element data types.  */\n#define DW_AT_subscr_data\t0x0a\n/* DWARF1 enumeration literals.  */\n#define DW_AT_element_list\t0x0f\n/* DWARF1 reference for variable to member structure, class or union.  */\n#define DW_AT_member\t\t0x14\n\n/* DWARF form encodings.  */\nenum\n  {\n    DW_FORM_addr = 0x01,\n    DW_FORM_block2 = 0x03,\n    DW_FORM_block4 = 0x04,\n    DW_FORM_data2 = 0x05,\n    DW_FORM_data4 = 0x06,\n    DW_FORM_data8 = 0x07,\n    DW_FORM_string = 0x08,\n    DW_FORM_block = 0x09,\n    DW_FORM_block1 = 0x0a,\n    DW_FORM_data1 = 0x0b,\n    DW_FORM_flag = 0x0c,\n    DW_FORM_sdata = 0x0d,\n    DW_FORM_strp = 0x0e,\n    DW_FORM_udata = 0x0f,\n    DW_FORM_ref_addr = 0x10,\n    DW_FORM_ref1 = 0x11,\n    DW_FORM_ref2 = 0x12,\n    DW_FORM_ref4 = 0x13,\n    DW_FORM_ref8 = 0x14,\n    DW_FORM_ref_udata = 0x15,\n    DW_FORM_indirect = 0x16,\n    DW_FORM_sec_offset = 0x17,\n    DW_FORM_exprloc = 0x18,\n    DW_FORM_flag_present = 0x19,\n    DW_FORM_strx = 0x1a,\n    DW_FORM_addrx = 0x1b,\n    DW_FORM_ref_sup4 = 0x1c,\n    DW_FORM_strp_sup = 0x1d,\n    DW_FORM_data16 = 0x1e,\n    DW_FORM_line_strp = 0x1f,\n    DW_FORM_ref_sig8 = 0x20,\n    DW_FORM_implicit_const = 0x21,\n    DW_FORM_loclistx = 0x22,\n    DW_FORM_rnglistx = 0x23,\n    DW_FORM_ref_sup8 = 0x24,\n    DW_FORM_strx1 = 0x25,\n    DW_FORM_strx2 = 0x26,\n    DW_FORM_strx3 = 0x27,\n    DW_FORM_strx4 = 0x28,\n    DW_FORM_addrx1 = 0x29,\n    DW_FORM_addrx2 = 0x2a,\n    DW_FORM_addrx3 = 0x2b,\n    DW_FORM_addrx4 = 0x2c,\n\n    /* GNU Debug Fission extensions.  */\n    DW_FORM_GNU_addr_index = 0x1f01,\n    DW_FORM_GNU_str_index = 0x1f02,\n\n    DW_FORM_GNU_ref_alt = 0x1f20, /* offset in alternate .debuginfo.  */\n    DW_FORM_GNU_strp_alt = 0x1f21 /* offset in alternate .debug_str. */\n  };\n\n\n/* DWARF location operation encodings.  */\nenum\n  {\n    DW_OP_addr = 0x03,\t\t/* Constant address.  */\n    DW_OP_deref = 0x06,\n    DW_OP_const1u = 0x08,\t/* Unsigned 1-byte constant.  */\n    DW_OP_const1s = 0x09,\t/* Signed 1-byte constant.  */\n    DW_OP_const2u = 0x0a,\t/* Unsigned 2-byte constant.  */\n    DW_OP_const2s = 0x0b,\t/* Signed 2-byte constant.  */\n    DW_OP_const4u = 0x0c,\t/* Unsigned 4-byte constant.  */\n    DW_OP_const4s = 0x0d,\t/* Signed 4-byte constant.  */\n    DW_OP_const8u = 0x0e,\t/* Unsigned 8-byte constant.  */\n    DW_OP_const8s = 0x0f,\t/* Signed 8-byte constant.  */\n    DW_OP_constu = 0x10,\t/* Unsigned LEB128 constant.  */\n    DW_OP_consts = 0x11,\t/* Signed LEB128 constant.  */\n    DW_OP_dup = 0x12,\n    DW_OP_drop = 0x13,\n    DW_OP_over = 0x14,\n    DW_OP_pick = 0x15,\t\t/* 1-byte stack index.  */\n    DW_OP_swap = 0x16,\n    DW_OP_rot = 0x17,\n    DW_OP_xderef = 0x18,\n    DW_OP_abs = 0x19,\n    DW_OP_and = 0x1a,\n    DW_OP_div = 0x1b,\n    DW_OP_minus = 0x1c,\n    DW_OP_mod = 0x1d,\n    DW_OP_mul = 0x1e,\n    DW_OP_neg = 0x1f,\n    DW_OP_not = 0x20,\n    DW_OP_or = 0x21,\n    DW_OP_plus = 0x22,\n    DW_OP_plus_uconst = 0x23,\t/* Unsigned LEB128 addend.  */\n    DW_OP_shl = 0x24,\n    DW_OP_shr = 0x25,\n    DW_OP_shra = 0x26,\n    DW_OP_xor = 0x27,\n    DW_OP_bra = 0x28,\t\t/* Signed 2-byte constant.  */\n    DW_OP_eq = 0x29,\n    DW_OP_ge = 0x2a,\n    DW_OP_gt = 0x2b,\n    DW_OP_le = 0x2c,\n    DW_OP_lt = 0x2d,\n    DW_OP_ne = 0x2e,\n    DW_OP_skip = 0x2f,\t\t/* Signed 2-byte constant.  */\n    DW_OP_lit0 = 0x30,\t\t/* Literal 0.  */\n    DW_OP_lit1 = 0x31,\t\t/* Literal 1.  */\n    DW_OP_lit2 = 0x32,\t\t/* Literal 2.  */\n    DW_OP_lit3 = 0x33,\t\t/* Literal 3.  */\n    DW_OP_lit4 = 0x34,\t\t/* Literal 4.  */\n    DW_OP_lit5 = 0x35,\t\t/* Literal 5.  */\n    DW_OP_lit6 = 0x36,\t\t/* Literal 6.  */\n    DW_OP_lit7 = 0x37,\t\t/* Literal 7.  */\n    DW_OP_lit8 = 0x38,\t\t/* Literal 8.  */\n    DW_OP_lit9 = 0x39,\t\t/* Literal 9.  */\n    DW_OP_lit10 = 0x3a,\t\t/* Literal 10.  */\n    DW_OP_lit11 = 0x3b,\t\t/* Literal 11.  */\n    DW_OP_lit12 = 0x3c,\t\t/* Literal 12.  */\n    DW_OP_lit13 = 0x3d,\t\t/* Literal 13.  */\n    DW_OP_lit14 = 0x3e,\t\t/* Literal 14.  */\n    DW_OP_lit15 = 0x3f,\t\t/* Literal 15.  */\n    DW_OP_lit16 = 0x40,\t\t/* Literal 16.  */\n    DW_OP_lit17 = 0x41,\t\t/* Literal 17.  */\n    DW_OP_lit18 = 0x42,\t\t/* Literal 18.  */\n    DW_OP_lit19 = 0x43,\t\t/* Literal 19.  */\n    DW_OP_lit20 = 0x44,\t\t/* Literal 20.  */\n    DW_OP_lit21 = 0x45,\t\t/* Literal 21.  */\n    DW_OP_lit22 = 0x46,\t\t/* Literal 22.  */\n    DW_OP_lit23 = 0x47,\t\t/* Literal 23.  */\n    DW_OP_lit24 = 0x48,\t\t/* Literal 24.  */\n    DW_OP_lit25 = 0x49,\t\t/* Literal 25.  */\n    DW_OP_lit26 = 0x4a,\t\t/* Literal 26.  */\n    DW_OP_lit27 = 0x4b,\t\t/* Literal 27.  */\n    DW_OP_lit28 = 0x4c,\t\t/* Literal 28.  */\n    DW_OP_lit29 = 0x4d,\t\t/* Literal 29.  */\n    DW_OP_lit30 = 0x4e,\t\t/* Literal 30.  */\n    DW_OP_lit31 = 0x4f,\t\t/* Literal 31.  */\n    DW_OP_reg0 = 0x50,\t\t/* Register 0.  */\n    DW_OP_reg1 = 0x51,\t\t/* Register 1.  */\n    DW_OP_reg2 = 0x52,\t\t/* Register 2.  */\n    DW_OP_reg3 = 0x53,\t\t/* Register 3.  */\n    DW_OP_reg4 = 0x54,\t\t/* Register 4.  */\n    DW_OP_reg5 = 0x55,\t\t/* Register 5.  */\n    DW_OP_reg6 = 0x56,\t\t/* Register 6.  */\n    DW_OP_reg7 = 0x57,\t\t/* Register 7.  */\n    DW_OP_reg8 = 0x58,\t\t/* Register 8.  */\n    DW_OP_reg9 = 0x59,\t\t/* Register 9.  */\n    DW_OP_reg10 = 0x5a,\t\t/* Register 10.  */\n    DW_OP_reg11 = 0x5b,\t\t/* Register 11.  */\n    DW_OP_reg12 = 0x5c,\t\t/* Register 12.  */\n    DW_OP_reg13 = 0x5d,\t\t/* Register 13.  */\n    DW_OP_reg14 = 0x5e,\t\t/* Register 14.  */\n    DW_OP_reg15 = 0x5f,\t\t/* Register 15.  */\n    DW_OP_reg16 = 0x60,\t\t/* Register 16.  */\n    DW_OP_reg17 = 0x61,\t\t/* Register 17.  */\n    DW_OP_reg18 = 0x62,\t\t/* Register 18.  */\n    DW_OP_reg19 = 0x63,\t\t/* Register 19.  */\n    DW_OP_reg20 = 0x64,\t\t/* Register 20.  */\n    DW_OP_reg21 = 0x65,\t\t/* Register 21.  */\n    DW_OP_reg22 = 0x66,\t\t/* Register 22.  */\n    DW_OP_reg23 = 0x67,\t\t/* Register 24.  */\n    DW_OP_reg24 = 0x68,\t\t/* Register 24.  */\n    DW_OP_reg25 = 0x69,\t\t/* Register 25.  */\n    DW_OP_reg26 = 0x6a,\t\t/* Register 26.  */\n    DW_OP_reg27 = 0x6b,\t\t/* Register 27.  */\n    DW_OP_reg28 = 0x6c,\t\t/* Register 28.  */\n    DW_OP_reg29 = 0x6d,\t\t/* Register 29.  */\n    DW_OP_reg30 = 0x6e,\t\t/* Register 30.  */\n    DW_OP_reg31 = 0x6f,\t\t/* Register 31.  */\n    DW_OP_breg0 = 0x70,\t\t/* Base register 0.  */\n    DW_OP_breg1 = 0x71,\t\t/* Base register 1.  */\n    DW_OP_breg2 = 0x72,\t\t/* Base register 2.  */\n    DW_OP_breg3 = 0x73,\t\t/* Base register 3.  */\n    DW_OP_breg4 = 0x74,\t\t/* Base register 4.  */\n    DW_OP_breg5 = 0x75,\t\t/* Base register 5.  */\n    DW_OP_breg6 = 0x76,\t\t/* Base register 6.  */\n    DW_OP_breg7 = 0x77,\t\t/* Base register 7.  */\n    DW_OP_breg8 = 0x78,\t\t/* Base register 8.  */\n    DW_OP_breg9 = 0x79,\t\t/* Base register 9.  */\n    DW_OP_breg10 = 0x7a,\t/* Base register 10.  */\n    DW_OP_breg11 = 0x7b,\t/* Base register 11.  */\n    DW_OP_breg12 = 0x7c,\t/* Base register 12.  */\n    DW_OP_breg13 = 0x7d,\t/* Base register 13.  */\n    DW_OP_breg14 = 0x7e,\t/* Base register 14.  */\n    DW_OP_breg15 = 0x7f,\t/* Base register 15.  */\n    DW_OP_breg16 = 0x80,\t/* Base register 16.  */\n    DW_OP_breg17 = 0x81,\t/* Base register 17.  */\n    DW_OP_breg18 = 0x82,\t/* Base register 18.  */\n    DW_OP_breg19 = 0x83,\t/* Base register 19.  */\n    DW_OP_breg20 = 0x84,\t/* Base register 20.  */\n    DW_OP_breg21 = 0x85,\t/* Base register 21.  */\n    DW_OP_breg22 = 0x86,\t/* Base register 22.  */\n    DW_OP_breg23 = 0x87,\t/* Base register 23.  */\n    DW_OP_breg24 = 0x88,\t/* Base register 24.  */\n    DW_OP_breg25 = 0x89,\t/* Base register 25.  */\n    DW_OP_breg26 = 0x8a,\t/* Base register 26.  */\n    DW_OP_breg27 = 0x8b,\t/* Base register 27.  */\n    DW_OP_breg28 = 0x8c,\t/* Base register 28.  */\n    DW_OP_breg29 = 0x8d,\t/* Base register 29.  */\n    DW_OP_breg30 = 0x8e,\t/* Base register 30.  */\n    DW_OP_breg31 = 0x8f,\t/* Base register 31.  */\n    DW_OP_regx = 0x90,\t\t/* Unsigned LEB128 register.  */\n    DW_OP_fbreg = 0x91,\t\t/* Signed LEB128 offset.  */\n    DW_OP_bregx = 0x92,\t\t/* ULEB128 register followed by SLEB128 off. */\n    DW_OP_piece = 0x93,\t\t/* ULEB128 size of piece addressed. */\n    DW_OP_deref_size = 0x94,\t/* 1-byte size of data retrieved.  */\n    DW_OP_xderef_size = 0x95,\t/* 1-byte size of data retrieved.  */\n    DW_OP_nop = 0x96,\n    DW_OP_push_object_address = 0x97,\n    DW_OP_call2 = 0x98,\n    DW_OP_call4 = 0x99,\n    DW_OP_call_ref = 0x9a,\n    DW_OP_form_tls_address = 0x9b,/* TLS offset to address in current thread */\n    DW_OP_call_frame_cfa = 0x9c,/* CFA as determined by CFI.  */\n    DW_OP_bit_piece = 0x9d,\t/* ULEB128 size and ULEB128 offset in bits.  */\n    DW_OP_implicit_value = 0x9e, /* DW_FORM_block follows opcode.  */\n    DW_OP_stack_value = 0x9f,\t /* No operands, special like DW_OP_piece.  */\n\n    DW_OP_implicit_pointer = 0xa0,\n    DW_OP_addrx = 0xa1,\n    DW_OP_constx = 0xa2,\n    DW_OP_entry_value = 0xa3,\n    DW_OP_const_type = 0xa4,\n    DW_OP_regval_type = 0xa5,\n    DW_OP_deref_type = 0xa6,\n    DW_OP_xderef_type = 0xa7,\n    DW_OP_convert = 0xa8,\n    DW_OP_reinterpret = 0xa9,\n\n    /* GNU extensions.  */\n    DW_OP_GNU_push_tls_address = 0xe0,\n    DW_OP_GNU_uninit = 0xf0,\n    DW_OP_GNU_encoded_addr = 0xf1,\n    DW_OP_GNU_implicit_pointer = 0xf2,\n    DW_OP_GNU_entry_value = 0xf3,\n    DW_OP_GNU_const_type = 0xf4,\n    DW_OP_GNU_regval_type = 0xf5,\n    DW_OP_GNU_deref_type = 0xf6,\n    DW_OP_GNU_convert = 0xf7,\n    DW_OP_GNU_reinterpret = 0xf9,\n    DW_OP_GNU_parameter_ref = 0xfa,\n\n    /* GNU Debug Fission extensions.  */\n    DW_OP_GNU_addr_index = 0xfb,\n    DW_OP_GNU_const_index = 0xfc,\n\n    DW_OP_GNU_variable_value = 0xfd,\n\n    DW_OP_lo_user = 0xe0,\t/* Implementation-defined range start.  */\n    DW_OP_hi_user = 0xff\t/* Implementation-defined range end.  */\n  };\n\n\n/* DWARF base type encodings.  */\nenum\n  {\n    DW_ATE_void = 0x0,\n    DW_ATE_address = 0x1,\n    DW_ATE_boolean = 0x2,\n    DW_ATE_complex_float = 0x3,\n    DW_ATE_float = 0x4,\n    DW_ATE_signed = 0x5,\n    DW_ATE_signed_char = 0x6,\n    DW_ATE_unsigned = 0x7,\n    DW_ATE_unsigned_char = 0x8,\n    DW_ATE_imaginary_float = 0x9,\n    DW_ATE_packed_decimal = 0xa,\n    DW_ATE_numeric_string = 0xb,\n    DW_ATE_edited = 0xc,\n    DW_ATE_signed_fixed = 0xd,\n    DW_ATE_unsigned_fixed = 0xe,\n    DW_ATE_decimal_float = 0xf,\n    DW_ATE_UTF = 0x10,\n    DW_ATE_UCS = 0x11,\n    DW_ATE_ASCII = 0x12,\n\n    DW_ATE_lo_user = 0x80,\n    DW_ATE_hi_user = 0xff\n  };\n\n\n/* DWARF decimal sign encodings.  */\nenum\n  {\n    DW_DS_unsigned = 1,\n    DW_DS_leading_overpunch = 2,\n    DW_DS_trailing_overpunch = 3,\n    DW_DS_leading_separate = 4,\n    DW_DS_trailing_separate = 5,\n  };\n\n\n/* DWARF endianity encodings.  */\nenum\n  {\n    DW_END_default = 0,\n    DW_END_big = 1,\n    DW_END_little = 2,\n\n    DW_END_lo_user = 0x40,\n    DW_END_hi_user = 0xff\n  };\n\n\n/* DWARF accessibility encodings.  */\nenum\n  {\n    DW_ACCESS_public = 1,\n    DW_ACCESS_protected = 2,\n    DW_ACCESS_private = 3\n  };\n\n\n/* DWARF visibility encodings.  */\nenum\n  {\n    DW_VIS_local = 1,\n    DW_VIS_exported = 2,\n    DW_VIS_qualified = 3\n  };\n\n\n/* DWARF virtuality encodings.  */\nenum\n  {\n    DW_VIRTUALITY_none = 0,\n    DW_VIRTUALITY_virtual = 1,\n    DW_VIRTUALITY_pure_virtual = 2\n  };\n\n\n/* DWARF language encodings.  */\nenum\n  {\n    DW_LANG_C89 = 0x0001,\t     /* ISO C:1989 */\n    DW_LANG_C = 0x0002,\t\t     /* C */\n    DW_LANG_Ada83 = 0x0003,\t     /* ISO Ada:1983 */\n    DW_LANG_C_plus_plus\t= 0x0004,    /* ISO C++:1998 */\n    DW_LANG_Cobol74 = 0x0005,\t     /* ISO Cobol:1974 */\n    DW_LANG_Cobol85 = 0x0006,\t     /* ISO Cobol:1985 */\n    DW_LANG_Fortran77 = 0x0007,\t     /* ISO FORTRAN 77 */\n    DW_LANG_Fortran90 = 0x0008,\t     /* ISO Fortran 90 */\n    DW_LANG_Pascal83 = 0x0009,\t     /* ISO Pascal:1983 */\n    DW_LANG_Modula2 = 0x000a,\t     /* ISO Modula-2:1996 */\n    DW_LANG_Java = 0x000b,\t     /* Java */\n    DW_LANG_C99 = 0x000c,\t     /* ISO C:1999 */\n    DW_LANG_Ada95 = 0x000d,\t     /* ISO Ada:1995 */\n    DW_LANG_Fortran95 = 0x000e,\t     /* ISO Fortran 95 */\n    DW_LANG_PLI = 0x000f,\t     /* ISO PL/1:1976 */\n    DW_LANG_ObjC = 0x0010,\t     /* Objective-C */\n    DW_LANG_ObjC_plus_plus = 0x0011, /* Objective-C++ */\n    DW_LANG_UPC = 0x0012,\t     /* Unified Parallel C */\n    DW_LANG_D = 0x0013,\t\t     /* D */\n    DW_LANG_Python = 0x0014,\t     /* Python */\n    DW_LANG_OpenCL = 0x0015,\t     /* OpenCL */\n    DW_LANG_Go = 0x0016,\t     /* Go */\n    DW_LANG_Modula3 = 0x0017,\t     /* Modula-3 */\n    DW_LANG_Haskell = 0x0018,\t     /* Haskell */\n    DW_LANG_C_plus_plus_03 = 0x0019, /* ISO C++:2003 */\n    DW_LANG_C_plus_plus_11 = 0x001a, /* ISO C++:2011 */\n    DW_LANG_OCaml = 0x001b,\t     /* OCaml */\n    DW_LANG_Rust = 0x001c,\t     /* Rust */\n    DW_LANG_C11 = 0x001d,\t     /* ISO C:2011 */\n    DW_LANG_Swift = 0x001e,\t     /* Swift */\n    DW_LANG_Julia = 0x001f,\t     /* Julia */\n    DW_LANG_Dylan = 0x0020,\t     /* Dylan */\n    DW_LANG_C_plus_plus_14 = 0x0021, /* ISO C++:2014 */\n    DW_LANG_Fortran03 = 0x0022,\t     /* ISO/IEC 1539-1:2004 */\n    DW_LANG_Fortran08 = 0x0023,\t     /* ISO/IEC 1539-1:2010 */\n    DW_LANG_RenderScript = 0x0024,   /* RenderScript Kernal Language */\n    DW_LANG_BLISS = 0x0025,\t     /* BLISS */\n\n    DW_LANG_lo_user = 0x8000,\n    DW_LANG_Mips_Assembler = 0x8001, /* Assembler */\n    DW_LANG_hi_user = 0xffff\n  };\n\n/* Old (typo) '1' != 'I'.  */\n#define DW_LANG_PL1 DW_LANG_PLI\n\n/* DWARF identifier case encodings.  */\nenum\n  {\n    DW_ID_case_sensitive = 0,\n    DW_ID_up_case = 1,\n    DW_ID_down_case = 2,\n    DW_ID_case_insensitive = 3\n  };\n\n\n/* DWARF calling conventions encodings.\n   Used as values of DW_AT_calling_convention for subroutines\n   (normal, program or nocall) or structures, unions and class types\n   (normal, reference or value).  */\nenum\n  {\n    DW_CC_normal = 0x1,\n    DW_CC_program = 0x2,\n    DW_CC_nocall = 0x3,\n    DW_CC_pass_by_reference = 0x4,\n    DW_CC_pass_by_value = 0x5,\n    DW_CC_lo_user = 0x40,\n    DW_CC_hi_user = 0xff\n  };\n\n\n/* DWARF inline encodings.  */\nenum\n  {\n    DW_INL_not_inlined = 0,\n    DW_INL_inlined = 1,\n    DW_INL_declared_not_inlined = 2,\n    DW_INL_declared_inlined = 3\n  };\n\n\n/* DWARF ordering encodings.  */\nenum\n  {\n    DW_ORD_row_major = 0,\n    DW_ORD_col_major = 1\n  };\n\n\n/* DWARF discriminant descriptor encodings.  */\nenum\n  {\n    DW_DSC_label = 0,\n    DW_DSC_range = 1\n  };\n\n/* DWARF defaulted member function encodings.  */\nenum\n  {\n    DW_DEFAULTED_no = 0,\n    DW_DEFAULTED_in_class = 1,\n    DW_DEFAULTED_out_of_class = 2\n  };\n\n/* DWARF line content descriptions.  */\nenum\n  {\n    DW_LNCT_path = 0x1,\n    DW_LNCT_directory_index = 0x2,\n    DW_LNCT_timestamp = 0x3,\n    DW_LNCT_size = 0x4,\n    DW_LNCT_MD5 = 0x5,\n    DW_LNCT_lo_user = 0x2000,\n    DW_LNCT_hi_user = 0x3fff\n  };\n\n/* DWARF standard opcode encodings.  */\nenum\n  {\n    DW_LNS_copy = 1,\n    DW_LNS_advance_pc = 2,\n    DW_LNS_advance_line = 3,\n    DW_LNS_set_file = 4,\n    DW_LNS_set_column = 5,\n    DW_LNS_negate_stmt = 6,\n    DW_LNS_set_basic_block = 7,\n    DW_LNS_const_add_pc = 8,\n    DW_LNS_fixed_advance_pc = 9,\n    DW_LNS_set_prologue_end = 10,\n    DW_LNS_set_epilogue_begin = 11,\n    DW_LNS_set_isa = 12\n  };\n\n\n/* DWARF extended opcode encodings.  */\nenum\n  {\n    DW_LNE_end_sequence = 1,\n    DW_LNE_set_address = 2,\n    DW_LNE_define_file = 3,\n    DW_LNE_set_discriminator = 4,\n\n    DW_LNE_lo_user = 128,\n\n    DW_LNE_NVIDIA_inlined_call = 144,\n    DW_LNE_NVIDIA_set_function_name = 145,\n\n    DW_LNE_hi_user = 255\n  };\n\n\n/* DWARF macinfo type encodings.  */\nenum\n  {\n    DW_MACINFO_define = 1,\n    DW_MACINFO_undef = 2,\n    DW_MACINFO_start_file = 3,\n    DW_MACINFO_end_file = 4,\n    DW_MACINFO_vendor_ext = 255\n  };\n\n\n/* DWARF debug_macro type encodings.  */\nenum\n  {\n    DW_MACRO_define = 0x01,\n    DW_MACRO_undef = 0x02,\n    DW_MACRO_start_file = 0x03,\n    DW_MACRO_end_file = 0x04,\n    DW_MACRO_define_strp = 0x05,\n    DW_MACRO_undef_strp = 0x06,\n    DW_MACRO_import = 0x07,\n    DW_MACRO_define_sup = 0x08,\n    DW_MACRO_undef_sup = 0x09,\n    DW_MACRO_import_sup = 0x0a,\n    DW_MACRO_define_strx = 0x0b,\n    DW_MACRO_undef_strx = 0x0c,\n    DW_MACRO_lo_user = 0xe0,\n    DW_MACRO_hi_user = 0xff\n  };\n\n/* Old GNU extension names for DWARF5 debug_macro type encodings.\n   There are no equivalents for the supplementary object file (sup)\n   and indirect string references (strx).  */\n#define DW_MACRO_GNU_define\t\t DW_MACRO_define\n#define DW_MACRO_GNU_undef\t\t DW_MACRO_undef\n#define DW_MACRO_GNU_start_file\t\t DW_MACRO_start_file\n#define DW_MACRO_GNU_end_file\t\t DW_MACRO_end_file\n#define DW_MACRO_GNU_define_indirect\t DW_MACRO_define_strp\n#define DW_MACRO_GNU_undef_indirect\t DW_MACRO_undef_strp\n#define DW_MACRO_GNU_transparent_include DW_MACRO_import\n#define DW_MACRO_GNU_lo_user\t\t DW_MACRO_lo_user\n#define DW_MACRO_GNU_hi_user\t\t DW_MACRO_hi_user\n\n\n/* Range list entry encoding.  */\nenum\n  {\n    DW_RLE_end_of_list = 0x0,\n    DW_RLE_base_addressx = 0x1,\n    DW_RLE_startx_endx = 0x2,\n    DW_RLE_startx_length = 0x3,\n    DW_RLE_offset_pair = 0x4,\n    DW_RLE_base_address = 0x5,\n    DW_RLE_start_end = 0x6,\n    DW_RLE_start_length = 0x7\n  };\n\n\n/* Location list entry encoding.  */\nenum\n  {\n    DW_LLE_end_of_list = 0x0,\n    DW_LLE_base_addressx = 0x1,\n    DW_LLE_startx_endx = 0x2,\n    DW_LLE_startx_length = 0x3,\n    DW_LLE_offset_pair = 0x4,\n    DW_LLE_default_location = 0x5,\n    DW_LLE_base_address = 0x6,\n    DW_LLE_start_end = 0x7,\n    DW_LLE_start_length = 0x8\n  };\n\n\n/* GNU DebugFission list entry encodings (.debug_loc.dwo).  */\nenum\n  {\n    DW_LLE_GNU_end_of_list_entry = 0x0,\n    DW_LLE_GNU_base_address_selection_entry = 0x1,\n    DW_LLE_GNU_start_end_entry = 0x2,\n    DW_LLE_GNU_start_length_entry = 0x3\n  };\n\n/* DWARF5 package file section identifiers.  */\nenum\n  {\n    DW_SECT_INFO = 1,\n    /* Reserved = 2, */\n    DW_SECT_ABBREV = 3,\n    DW_SECT_LINE = 4,\n    DW_SECT_LOCLISTS = 5,\n    DW_SECT_STR_OFFSETS = 6,\n    DW_SECT_MACRO = 7,\n    DW_SECT_RNGLISTS = 8,\n  };\n\n\n/* DWARF call frame instruction encodings.  */\nenum\n  {\n    DW_CFA_advance_loc = 0x40,\n    DW_CFA_offset = 0x80,\n    DW_CFA_restore = 0xc0,\n    DW_CFA_extended = 0,\n\n    DW_CFA_nop = 0x00,\n    DW_CFA_set_loc = 0x01,\n    DW_CFA_advance_loc1 = 0x02,\n    DW_CFA_advance_loc2 = 0x03,\n    DW_CFA_advance_loc4 = 0x04,\n    DW_CFA_offset_extended = 0x05,\n    DW_CFA_restore_extended = 0x06,\n    DW_CFA_undefined = 0x07,\n    DW_CFA_same_value = 0x08,\n    DW_CFA_register = 0x09,\n    DW_CFA_remember_state = 0x0a,\n    DW_CFA_restore_state = 0x0b,\n    DW_CFA_def_cfa = 0x0c,\n    DW_CFA_def_cfa_register = 0x0d,\n    DW_CFA_def_cfa_offset = 0x0e,\n    DW_CFA_def_cfa_expression = 0x0f,\n    DW_CFA_expression = 0x10,\n    DW_CFA_offset_extended_sf = 0x11,\n    DW_CFA_def_cfa_sf = 0x12,\n    DW_CFA_def_cfa_offset_sf = 0x13,\n    DW_CFA_val_offset = 0x14,\n    DW_CFA_val_offset_sf = 0x15,\n    DW_CFA_val_expression = 0x16,\n\n    DW_CFA_low_user = 0x1c,\n    DW_CFA_MIPS_advance_loc8 = 0x1d,\n    DW_CFA_GNU_window_save = 0x2d,\n    DW_CFA_AARCH64_negate_ra_state = 0x2d,\n    DW_CFA_GNU_args_size = 0x2e,\n    DW_CFA_GNU_negative_offset_extended = 0x2f,\n    DW_CFA_high_user = 0x3f\n  };\n\n/* ID indicating CIE as opposed to FDE in .debug_frame.  */\nenum\n  {\n    DW_CIE_ID_32 = 0xffffffffU,\t\t /* In 32-bit format CIE header.  */\n    DW_CIE_ID_64 = 0xffffffffffffffffULL /* In 64-bit format CIE header.  */\n  };\n\n\n/* Information for GNU unwind information.  */\nenum\n  {\n    DW_EH_PE_absptr = 0x00,\n    DW_EH_PE_omit = 0xff,\n\n    /* FDE data encoding.  */\n    DW_EH_PE_uleb128 = 0x01,\n    DW_EH_PE_udata2 = 0x02,\n    DW_EH_PE_udata4 = 0x03,\n    DW_EH_PE_udata8 = 0x04,\n    DW_EH_PE_sleb128 = 0x09,\n    DW_EH_PE_sdata2 = 0x0a,\n    DW_EH_PE_sdata4 = 0x0b,\n    DW_EH_PE_sdata8 = 0x0c,\n    DW_EH_PE_signed = 0x08,\n\n    /* FDE flags.  */\n    DW_EH_PE_pcrel = 0x10,\n    DW_EH_PE_textrel = 0x20,\n    DW_EH_PE_datarel = 0x30,\n    DW_EH_PE_funcrel = 0x40,\n    DW_EH_PE_aligned = 0x50,\n\n    DW_EH_PE_indirect = 0x80\n  };\n\n\n/* DWARF XXX.  */\n#define DW_ADDR_none\t0\n\n/* Section 7.2.2 of the DWARF3 specification defines a range of escape\n   codes that can appear in the length field of certain DWARF structures.\n\n   These defines enumerate the minimum and maximum values of this range.\n   Currently only the maximum value is used (to indicate that 64-bit\n   values are going to be used in the dwarf data that accompanies the\n   structure).  The other values are reserved.\n\n   Note: There is a typo in DWARF3 spec (published Dec 20, 2005).  In\n   sections 7.4, 7.5.1, 7.19, 7.20 the minimum escape code is referred to\n   as 0xffffff00 whereas in fact it should be 0xfffffff0.  */\n#define DWARF3_LENGTH_MIN_ESCAPE_CODE 0xfffffff0u\n#define DWARF3_LENGTH_MAX_ESCAPE_CODE 0xffffffffu\n#define DWARF3_LENGTH_64_BIT          DWARF3_LENGTH_MAX_ESCAPE_CODE\n\n#endif\t/* dwarf.h */\n"
        },
        {
          "name": "elf.h",
          "type": "blob",
          "size": 144.2509765625,
          "content": "/* This file defines standard ELF types, structures, and macros.\n   Copyright (C) 1995-2012 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef _ELF_H\n#define\t_ELF_H 1\n\n#ifndef _WIN32\n#include <inttypes.h>\n#else\n#ifndef __int8_t_defined\n#define __int8_t_defined\ntypedef signed char int8_t;\ntypedef short int int16_t;\ntypedef int int32_t;\ntypedef long long int int64_t;\ntypedef unsigned char           uint8_t;\ntypedef unsigned short int      uint16_t;\ntypedef unsigned int            uint32_t;\ntypedef unsigned long long int  uint64_t;\n#endif\n#endif\n\n/* Standard ELF types.  */\n\n/* Type for a 16-bit quantity.  */\ntypedef uint16_t Elf32_Half;\ntypedef uint16_t Elf64_Half;\n\n/* Types for signed and unsigned 32-bit quantities.  */\ntypedef uint32_t Elf32_Word;\ntypedef\tint32_t  Elf32_Sword;\ntypedef uint32_t Elf64_Word;\ntypedef\tint32_t  Elf64_Sword;\n\n/* Types for signed and unsigned 64-bit quantities.  */\ntypedef uint64_t Elf32_Xword;\ntypedef\tint64_t  Elf32_Sxword;\ntypedef uint64_t Elf64_Xword;\ntypedef\tint64_t  Elf64_Sxword;\n\n/* Type of addresses.  */\ntypedef uint32_t Elf32_Addr;\ntypedef uint64_t Elf64_Addr;\n\n/* Type of file offsets.  */\ntypedef uint32_t Elf32_Off;\ntypedef uint64_t Elf64_Off;\n\n/* Type for section indices, which are 16-bit quantities.  */\ntypedef uint16_t Elf32_Section;\ntypedef uint16_t Elf64_Section;\n\n/* Type for version symbol information.  */\ntypedef Elf32_Half Elf32_Versym;\ntypedef Elf64_Half Elf64_Versym;\n\n\n/* The ELF file header.  This appears at the start of every ELF file.  */\n\n#define EI_NIDENT (16)\n\ntypedef struct\n{\n  unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */\n  Elf32_Half\te_type;\t\t\t/* Object file type */\n  Elf32_Half\te_machine;\t\t/* Architecture */\n  Elf32_Word\te_version;\t\t/* Object file version */\n  Elf32_Addr\te_entry;\t\t/* Entry point virtual address */\n  Elf32_Off\te_phoff;\t\t/* Program header table file offset */\n  Elf32_Off\te_shoff;\t\t/* Section header table file offset */\n  Elf32_Word\te_flags;\t\t/* Processor-specific flags */\n  Elf32_Half\te_ehsize;\t\t/* ELF header size in bytes */\n  Elf32_Half\te_phentsize;\t\t/* Program header table entry size */\n  Elf32_Half\te_phnum;\t\t/* Program header table entry count */\n  Elf32_Half\te_shentsize;\t\t/* Section header table entry size */\n  Elf32_Half\te_shnum;\t\t/* Section header table entry count */\n  Elf32_Half\te_shstrndx;\t\t/* Section header string table index */\n} Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */\n  Elf64_Half\te_type;\t\t\t/* Object file type */\n  Elf64_Half\te_machine;\t\t/* Architecture */\n  Elf64_Word\te_version;\t\t/* Object file version */\n  Elf64_Addr\te_entry;\t\t/* Entry point virtual address */\n  Elf64_Off\te_phoff;\t\t/* Program header table file offset */\n  Elf64_Off\te_shoff;\t\t/* Section header table file offset */\n  Elf64_Word\te_flags;\t\t/* Processor-specific flags */\n  Elf64_Half\te_ehsize;\t\t/* ELF header size in bytes */\n  Elf64_Half\te_phentsize;\t\t/* Program header table entry size */\n  Elf64_Half\te_phnum;\t\t/* Program header table entry count */\n  Elf64_Half\te_shentsize;\t\t/* Section header table entry size */\n  Elf64_Half\te_shnum;\t\t/* Section header table entry count */\n  Elf64_Half\te_shstrndx;\t\t/* Section header string table index */\n} Elf64_Ehdr;\n\n/* Fields in the e_ident array.  The EI_* macros are indices into the\n   array.  The macros under each EI_* macro are the values the byte\n   may have.  */\n\n#define EI_MAG0\t\t0\t\t/* File identification byte 0 index */\n#define ELFMAG0\t\t0x7f\t\t/* Magic number byte 0 */\n\n#define EI_MAG1\t\t1\t\t/* File identification byte 1 index */\n#define ELFMAG1\t\t'E'\t\t/* Magic number byte 1 */\n\n#define EI_MAG2\t\t2\t\t/* File identification byte 2 index */\n#define ELFMAG2\t\t'L'\t\t/* Magic number byte 2 */\n\n#define EI_MAG3\t\t3\t\t/* File identification byte 3 index */\n#define ELFMAG3\t\t'F'\t\t/* Magic number byte 3 */\n\n/* Conglomeration of the identification bytes, for easy testing as a word.  */\n#define\tELFMAG\t\t\"\\177ELF\"\n#define\tSELFMAG\t\t4\n\n#define EI_CLASS\t4\t\t/* File class byte index */\n#define ELFCLASSNONE\t0\t\t/* Invalid class */\n#define ELFCLASS32\t1\t\t/* 32-bit objects */\n#define ELFCLASS64\t2\t\t/* 64-bit objects */\n#define ELFCLASSNUM\t3\n\n#define EI_DATA\t\t5\t\t/* Data encoding byte index */\n#define ELFDATANONE\t0\t\t/* Invalid data encoding */\n#define ELFDATA2LSB\t1\t\t/* 2's complement, little endian */\n#define ELFDATA2MSB\t2\t\t/* 2's complement, big endian */\n#define ELFDATANUM\t3\n\n#define EI_VERSION\t6\t\t/* File version byte index */\n\t\t\t\t\t/* Value must be EV_CURRENT */\n\n#define EI_OSABI\t7\t\t/* OS ABI identification */\n#define ELFOSABI_NONE\t\t0\t/* UNIX System V ABI */\n#define ELFOSABI_SYSV\t\t0\t/* Alias.  */\n#define ELFOSABI_HPUX\t\t1\t/* HP-UX */\n#define ELFOSABI_NETBSD\t\t2\t/* NetBSD.  */\n#define ELFOSABI_GNU\t\t3\t/* Object uses GNU ELF extensions.  */\n#define ELFOSABI_LINUX\t\tELFOSABI_GNU /* Compatibility alias.  */\n#define ELFOSABI_SOLARIS\t6\t/* Sun Solaris.  */\n#define ELFOSABI_AIX\t\t7\t/* IBM AIX.  */\n#define ELFOSABI_IRIX\t\t8\t/* SGI Irix.  */\n#define ELFOSABI_FREEBSD\t9\t/* FreeBSD.  */\n#define ELFOSABI_TRU64\t\t10\t/* Compaq TRU64 UNIX.  */\n#define ELFOSABI_MODESTO\t11\t/* Novell Modesto.  */\n#define ELFOSABI_OPENBSD\t12\t/* OpenBSD.  */\n#define ELFOSABI_OPENVMS        13\n#define ELFOSABI_NSK            14      /* Hewlett-Packard Non-Stop Kernel.  */\n#define ELFOSABI_AROS           15      /* Amiga Research OS.  */\n#define ELFOSABI_FENIXOS        16      /* FenixOS.  */\n#define ELFOSABI_ARM_AEABI\t64\t/* ARM EABI.  */\n#define ELFOSABI_C6000_LINUX    65      /* Linux TMS320C6000.  */\n#define ELFOSABI_ARM\t\t97\t/* ARM */\n#define ELFOSABI_STANDALONE\t255\t/* Standalone (embedded) application */\n\n#define EI_ABIVERSION\t8\t\t/* ABI version */\n\n#define EI_PAD\t\t9\t\t/* Byte index of padding bytes */\n\n/* Legal values for e_type (object file type).  */\n\n#define ET_NONE\t\t0\t\t/* No file type */\n#define ET_REL\t\t1\t\t/* Relocatable file */\n#define ET_EXEC\t\t2\t\t/* Executable file */\n#define ET_DYN\t\t3\t\t/* Shared object file */\n#define ET_CORE\t\t4\t\t/* Core file */\n#define\tET_NUM\t\t5\t\t/* Number of defined types */\n#define ET_LOOS\t\t0xfe00\t\t/* OS-specific range start */\n#define ET_HIOS\t\t0xfeff\t\t/* OS-specific range end */\n#define ET_LOPROC\t0xff00\t\t/* Processor-specific range start */\n#define ET_HIPROC\t0xffff\t\t/* Processor-specific range end */\n\n/* Legal values for e_machine (architecture).  */\n\n#define EM_NONE\t\t 0\t\t/* No machine */\n#define EM_M32\t\t 1\t\t/* AT&T WE 32100 */\n#define EM_SPARC\t 2\t\t/* SUN SPARC */\n#define EM_386\t\t 3\t\t/* Intel 80386 */\n#define EM_68K\t\t 4\t\t/* Motorola m68k family */\n#define EM_88K\t\t 5\t\t/* Motorola m88k family */\n#define EM_860\t\t 7\t\t/* Intel 80860 */\n#define EM_MIPS\t\t 8\t\t/* MIPS R3000 big-endian */\n#define EM_S370\t\t 9\t\t/* IBM System/370 */\n#define EM_MIPS_RS3_LE\t10\t\t/* MIPS R3000 little-endian */\n\n#define EM_PARISC\t15\t\t/* HPPA */\n#define EM_VPP500\t17\t\t/* Fujitsu VPP500 */\n#define EM_SPARC32PLUS\t18\t\t/* Sun's \"v8plus\" */\n#define EM_960\t\t19\t\t/* Intel 80960 */\n#define EM_PPC\t\t20\t\t/* PowerPC */\n#define EM_PPC64\t21\t\t/* PowerPC 64-bit */\n#define EM_S390\t\t22\t\t/* IBM S390 */\n\n#define EM_V800\t\t36\t\t/* NEC V800 series */\n#define EM_FR20\t\t37\t\t/* Fujitsu FR20 */\n#define EM_RH32\t\t38\t\t/* TRW RH-32 */\n#define EM_RCE\t\t39\t\t/* Motorola RCE */\n#define EM_ARM\t\t40\t\t/* ARM */\n#define EM_FAKE_ALPHA\t41\t\t/* Digital Alpha */\n#define EM_SH\t\t42\t\t/* Hitachi SH */\n#define EM_SPARCV9\t43\t\t/* SPARC v9 64-bit */\n#define EM_TRICORE\t44\t\t/* Siemens Tricore */\n#define EM_ARC\t\t45\t\t/* Argonaut RISC Core */\n#define EM_H8_300\t46\t\t/* Hitachi H8/300 */\n#define EM_H8_300H\t47\t\t/* Hitachi H8/300H */\n#define EM_H8S\t\t48\t\t/* Hitachi H8S */\n#define EM_H8_500\t49\t\t/* Hitachi H8/500 */\n#define EM_IA_64\t50\t\t/* Intel Merced */\n#define EM_MIPS_X\t51\t\t/* Stanford MIPS-X */\n#define EM_COLDFIRE\t52\t\t/* Motorola Coldfire */\n#define EM_68HC12\t53\t\t/* Motorola M68HC12 */\n#define EM_MMA\t\t54\t\t/* Fujitsu MMA Multimedia Accelerator*/\n#define EM_PCP\t\t55\t\t/* Siemens PCP */\n#define EM_NCPU\t\t56\t\t/* Sony nCPU embedded RISC */\n#define EM_NDR1\t\t57\t\t/* Denso NDR1 microprocessor */\n#define EM_STARCORE\t58\t\t/* Motorola Start*Core processor */\n#define EM_ME16\t\t59\t\t/* Toyota ME16 processor */\n#define EM_ST100\t60\t\t/* STMicroelectronic ST100 processor */\n#define EM_TINYJ\t61\t\t/* Advanced Logic Corp. Tinyj emb.fam*/\n#define EM_X86_64\t62\t\t/* AMD x86-64 architecture */\n#define EM_PDSP\t\t63\t\t/* Sony DSP Processor */\n\n#define EM_FX66\t\t66\t\t/* Siemens FX66 microcontroller */\n#define EM_ST9PLUS\t67\t\t/* STMicroelectronics ST9+ 8/16 mc */\n#define EM_ST7\t\t68\t\t/* STMicroelectronics ST7 8 bit mc */\n#define EM_68HC16\t69\t\t/* Motorola MC68HC16 microcontroller */\n#define EM_68HC11\t70\t\t/* Motorola MC68HC11 microcontroller */\n#define EM_68HC08\t71\t\t/* Motorola MC68HC08 microcontroller */\n#define EM_68HC05\t72\t\t/* Motorola MC68HC05 microcontroller */\n#define EM_SVX\t\t73\t\t/* Silicon Graphics SVx */\n#define EM_ST19\t\t74\t\t/* STMicroelectronics ST19 8 bit mc */\n#define EM_VAX\t\t75\t\t/* Digital VAX */\n#define EM_CRIS\t\t76\t\t/* Axis Communications 32-bit embedded processor */\n#define EM_JAVELIN\t77\t\t/* Infineon Technologies 32-bit embedded processor */\n#define EM_FIREPATH\t78\t\t/* Element 14 64-bit DSP Processor */\n#define EM_ZSP\t\t79\t\t/* LSI Logic 16-bit DSP Processor */\n#define EM_MMIX\t\t80\t\t/* Donald Knuth's educational 64-bit processor */\n#define EM_HUANY\t81\t\t/* Harvard University machine-independent object files */\n#define EM_PRISM\t82\t\t/* SiTera Prism */\n#define EM_AVR\t\t83\t\t/* Atmel AVR 8-bit microcontroller */\n#define EM_FR30\t\t84\t\t/* Fujitsu FR30 */\n#define EM_D10V\t\t85\t\t/* Mitsubishi D10V */\n#define EM_D30V\t\t86\t\t/* Mitsubishi D30V */\n#define EM_V850\t\t87\t\t/* NEC v850 */\n#define EM_M32R\t\t88\t\t/* Mitsubishi M32R */\n#define EM_MN10300\t89\t\t/* Matsushita MN10300 */\n#define EM_MN10200\t90\t\t/* Matsushita MN10200 */\n#define EM_PJ\t\t91\t\t/* picoJava */\n#define EM_OPENRISC\t92\t\t/* OpenRISC 32-bit embedded processor */\n#define EM_ARC_A5\t93\t\t/* ARC Cores Tangent-A5 */\n#define EM_XTENSA\t94\t\t/* Tensilica Xtensa Architecture */\n#define EM_AARCH64\t183\t\t/* ARM AARCH64 */\n#define EM_TILEPRO\t188\t\t/* Tilera TILEPro */\n#define EM_TILEGX\t191\t\t/* Tilera TILE-Gx */\n#define EM_RISCV\t243\t        /* RISC-V */\n#define EM_NUM\t\t253\n\n/* If it is necessary to assign new unofficial EM_* values, please\n   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the\n   chances of collision with official or non-GNU unofficial values.  */\n\n#define EM_ALPHA\t0x9026\n#define EM_C60\t\t0x9c60\n\n/* Legal values for e_version (version).  */\n\n#define EV_NONE\t\t0\t\t/* Invalid ELF version */\n#define EV_CURRENT\t1\t\t/* Current version */\n#define EV_NUM\t\t2\n\n/* Section header.  */\n\ntypedef struct\n{\n  Elf32_Word\tsh_name;\t\t/* Section name (string tbl index) */\n  Elf32_Word\tsh_type;\t\t/* Section type */\n  Elf32_Word\tsh_flags;\t\t/* Section flags */\n  Elf32_Addr\tsh_addr;\t\t/* Section virtual addr at execution */\n  Elf32_Off\tsh_offset;\t\t/* Section file offset */\n  Elf32_Word\tsh_size;\t\t/* Section size in bytes */\n  Elf32_Word\tsh_link;\t\t/* Link to another section */\n  Elf32_Word\tsh_info;\t\t/* Additional section information */\n  Elf32_Word\tsh_addralign;\t\t/* Section alignment */\n  Elf32_Word\tsh_entsize;\t\t/* Entry size if section holds table */\n} Elf32_Shdr;\n\ntypedef struct\n{\n  Elf64_Word\tsh_name;\t\t/* Section name (string tbl index) */\n  Elf64_Word\tsh_type;\t\t/* Section type */\n  Elf64_Xword\tsh_flags;\t\t/* Section flags */\n  Elf64_Addr\tsh_addr;\t\t/* Section virtual addr at execution */\n  Elf64_Off\tsh_offset;\t\t/* Section file offset */\n  Elf64_Xword\tsh_size;\t\t/* Section size in bytes */\n  Elf64_Word\tsh_link;\t\t/* Link to another section */\n  Elf64_Word\tsh_info;\t\t/* Additional section information */\n  Elf64_Xword\tsh_addralign;\t\t/* Section alignment */\n  Elf64_Xword\tsh_entsize;\t\t/* Entry size if section holds table */\n} Elf64_Shdr;\n\n/* Special section indices.  */\n\n#define SHN_UNDEF\t0\t\t/* Undefined section */\n#define SHN_LORESERVE\t0xff00\t\t/* Start of reserved indices */\n#define SHN_LOPROC\t0xff00\t\t/* Start of processor-specific */\n#define SHN_BEFORE\t0xff00\t\t/* Order section before all others\n\t\t\t\t\t   (Solaris).  */\n#define SHN_AFTER\t0xff01\t\t/* Order section after all others\n\t\t\t\t\t   (Solaris).  */\n#define SHN_HIPROC\t0xff1f\t\t/* End of processor-specific */\n#define SHN_LOOS\t0xff20\t\t/* Start of OS-specific */\n#define SHN_HIOS\t0xff3f\t\t/* End of OS-specific */\n#define SHN_ABS\t\t0xfff1\t\t/* Associated symbol is absolute */\n#define SHN_COMMON\t0xfff2\t\t/* Associated symbol is common */\n#define SHN_XINDEX\t0xffff\t\t/* Index is in extra table.  */\n#define SHN_HIRESERVE\t0xffff\t\t/* End of reserved indices */\n\n/* Legal values for sh_type (section type).  */\n\n#define SHT_NULL\t  0\t\t/* Section header table entry unused */\n#define SHT_PROGBITS\t  1\t\t/* Program data */\n#define SHT_SYMTAB\t  2\t\t/* Symbol table */\n#define SHT_STRTAB\t  3\t\t/* String table */\n#define SHT_RELA\t  4\t\t/* Relocation entries with addends */\n#define SHT_HASH\t  5\t\t/* Symbol hash table */\n#define SHT_DYNAMIC\t  6\t\t/* Dynamic linking information */\n#define SHT_NOTE\t  7\t\t/* Notes */\n#define SHT_NOBITS\t  8\t\t/* Program space with no data (bss) */\n#define SHT_REL\t\t  9\t\t/* Relocation entries, no addends */\n#define SHT_SHLIB\t  10\t\t/* Reserved */\n#define SHT_DYNSYM\t  11\t\t/* Dynamic linker symbol table */\n#define SHT_INIT_ARRAY\t  14\t\t/* Array of constructors */\n#define SHT_FINI_ARRAY\t  15\t\t/* Array of destructors */\n#define SHT_PREINIT_ARRAY 16\t\t/* Array of pre-constructors */\n#define SHT_GROUP\t  17\t\t/* Section group */\n#define SHT_SYMTAB_SHNDX  18\t\t/* Extended section indices */\n#define\tSHT_NUM\t\t  19\t\t/* Number of defined types.  */\n#define SHT_LOOS\t  0x60000000\t/* Start OS-specific.  */\n#define SHT_GNU_ATTRIBUTES 0x6ffffff5\t/* Object attributes.  */\n#define SHT_GNU_HASH\t  0x6ffffff6\t/* GNU-style hash table.  */\n#define SHT_GNU_LIBLIST\t  0x6ffffff7\t/* Prelink library list */\n#define SHT_CHECKSUM\t  0x6ffffff8\t/* Checksum for DSO content.  */\n#define SHT_LOSUNW\t  0x6ffffffa\t/* Sun-specific low bound.  */\n#define SHT_SUNW_move\t  0x6ffffffa\n#define SHT_SUNW_COMDAT   0x6ffffffb\n#define SHT_SUNW_syminfo  0x6ffffffc\n#define SHT_GNU_verdef\t  0x6ffffffd\t/* Version definition section.  */\n#define SHT_GNU_verneed\t  0x6ffffffe\t/* Version needs section.  */\n#define SHT_GNU_versym\t  0x6fffffff\t/* Version symbol table.  */\n#define SHT_HISUNW\t  0x6fffffff\t/* Sun-specific high bound.  */\n#define SHT_HIOS\t  0x6fffffff\t/* End OS-specific type */\n#define SHT_LOPROC\t  0x70000000\t/* Start of processor-specific */\n#define SHT_HIPROC\t  0x7fffffff\t/* End of processor-specific */\n#define SHT_LOUSER\t  0x80000000\t/* Start of application-specific */\n#define SHT_HIUSER\t  0x8fffffff\t/* End of application-specific */\n\n/* Legal values for sh_flags (section flags).  */\n\n#define SHF_WRITE\t     (1 << 0)\t/* Writable */\n#define SHF_ALLOC\t     (1 << 1)\t/* Occupies memory during execution */\n#define SHF_EXECINSTR\t     (1 << 2)\t/* Executable */\n#define SHF_MERGE\t     (1 << 4)\t/* Might be merged */\n#define SHF_STRINGS\t     (1 << 5)\t/* Contains nul-terminated strings */\n#define SHF_INFO_LINK\t     (1 << 6)\t/* `sh_info' contains SHT index */\n#define SHF_LINK_ORDER\t     (1 << 7)\t/* Preserve order after combining */\n#define SHF_OS_NONCONFORMING (1 << 8)\t/* Non-standard OS specific handling\n\t\t\t\t\t   required */\n#define SHF_GROUP\t     (1 << 9)\t/* Section is member of a group.  */\n#define SHF_TLS\t\t     (1 << 10)\t/* Section hold thread-local data.  */\n#define SHF_COMPRESSED\t     (1 << 11)\t/* Section with compressed data. */\n#define SHF_MASKOS\t     0x0ff00000\t/* OS-specific.  */\n#define SHF_MASKPROC\t     0xf0000000\t/* Processor-specific */\n#define SHF_ORDERED\t     (1 << 30)\t/* Special ordering requirement\n\t\t\t\t\t   (Solaris).  */\n#define SHF_EXCLUDE\t     (1U << 31)\t/* Section is excluded unless\n\t\t\t\t\t   referenced or allocated (Solaris).*/\n\n/* Section group handling.  */\n#define GRP_COMDAT\t0x1\t\t/* Mark group as COMDAT.  */\n\n/* Symbol table entry.  */\n\ntypedef struct\n{\n  Elf32_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  Elf32_Addr\tst_value;\t\t/* Symbol value */\n  Elf32_Word\tst_size;\t\t/* Symbol size */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char\tst_other;\t\t/* Symbol visibility */\n  Elf32_Section\tst_shndx;\t\t/* Section index */\n} Elf32_Sym;\n\ntypedef struct\n{\n  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char st_other;\t\t/* Symbol visibility */\n  Elf64_Section\tst_shndx;\t\t/* Section index */\n  Elf64_Addr\tst_value;\t\t/* Symbol value */\n  Elf64_Xword\tst_size;\t\t/* Symbol size */\n} Elf64_Sym;\n\n/* The syminfo section if available contains additional information about\n   every dynamic symbol.  */\n\ntypedef struct\n{\n  Elf32_Half si_boundto;\t\t/* Direct bindings, symbol bound to */\n  Elf32_Half si_flags;\t\t\t/* Per symbol flags */\n} Elf32_Syminfo;\n\ntypedef struct\n{\n  Elf64_Half si_boundto;\t\t/* Direct bindings, symbol bound to */\n  Elf64_Half si_flags;\t\t\t/* Per symbol flags */\n} Elf64_Syminfo;\n\n/* Possible values for si_boundto.  */\n#define SYMINFO_BT_SELF\t\t0xffff\t/* Symbol bound to self */\n#define SYMINFO_BT_PARENT\t0xfffe\t/* Symbol bound to parent */\n#define SYMINFO_BT_LOWRESERVE\t0xff00\t/* Beginning of reserved entries */\n\n/* Possible bitmasks for si_flags.  */\n#define SYMINFO_FLG_DIRECT\t0x0001\t/* Direct bound symbol */\n#define SYMINFO_FLG_PASSTHRU\t0x0002\t/* Pass-thru symbol for translator */\n#define SYMINFO_FLG_COPY\t0x0004\t/* Symbol is a copy-reloc */\n#define SYMINFO_FLG_LAZYLOAD\t0x0008\t/* Symbol bound to object to be lazy\n\t\t\t\t\t   loaded */\n/* Syminfo version values.  */\n#define SYMINFO_NONE\t\t0\n#define SYMINFO_CURRENT\t\t1\n#define SYMINFO_NUM\t\t2\n\n\n/* How to extract and insert information held in the st_info field.  */\n\n#define ELF32_ST_BIND(val)\t\t(((unsigned char) (val)) >> 4)\n#define ELF32_ST_TYPE(val)\t\t((val) & 0xf)\n#define ELF32_ST_INFO(bind, type)\t(((bind) << 4) + ((type) & 0xf))\n\n/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */\n#define ELF64_ST_BIND(val)\t\tELF32_ST_BIND (val)\n#define ELF64_ST_TYPE(val)\t\tELF32_ST_TYPE (val)\n#define ELF64_ST_INFO(bind, type)\tELF32_ST_INFO ((bind), (type))\n\n/* Legal values for ST_BIND subfield of st_info (symbol binding).  */\n\n#define STB_LOCAL\t0\t\t/* Local symbol */\n#define STB_GLOBAL\t1\t\t/* Global symbol */\n#define STB_WEAK\t2\t\t/* Weak symbol */\n#define\tSTB_NUM\t\t3\t\t/* Number of defined types.  */\n#define STB_LOOS\t10\t\t/* Start of OS-specific */\n#define STB_GNU_UNIQUE\t10\t\t/* Unique symbol.  */\n#define STB_HIOS\t12\t\t/* End of OS-specific */\n#define STB_LOPROC\t13\t\t/* Start of processor-specific */\n#define STB_HIPROC\t15\t\t/* End of processor-specific */\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n\n#define STT_NOTYPE\t0\t\t/* Symbol type is unspecified */\n#define STT_OBJECT\t1\t\t/* Symbol is a data object */\n#define STT_FUNC\t2\t\t/* Symbol is a code object */\n#define STT_SECTION\t3\t\t/* Symbol associated with a section */\n#define STT_FILE\t4\t\t/* Symbol's name is file name */\n#define STT_COMMON\t5\t\t/* Symbol is a common data object */\n#define STT_TLS\t\t6\t\t/* Symbol is thread-local data object*/\n#define\tSTT_NUM\t\t7\t\t/* Number of defined types.  */\n#define STT_LOOS\t10\t\t/* Start of OS-specific */\n#define STT_GNU_IFUNC\t10\t\t/* Symbol is indirect code object */\n#define STT_HIOS\t12\t\t/* End of OS-specific */\n#define STT_LOPROC\t13\t\t/* Start of processor-specific */\n#define STT_HIPROC\t15\t\t/* End of processor-specific */\n\n\n/* Symbol table indices are found in the hash buckets and chain table\n   of a symbol hash table section.  This special index value indicates\n   the end of a chain, meaning no further symbols are found in that bucket.  */\n\n#define STN_UNDEF\t0\t\t/* End of a chain.  */\n\n\n/* How to extract and insert information held in the st_other field.  */\n\n#define ELF32_ST_VISIBILITY(o)\t((o) & 0x03)\n\n/* For ELF64 the definitions are the same.  */\n#define ELF64_ST_VISIBILITY(o)\tELF32_ST_VISIBILITY (o)\n\n/* Symbol visibility specification encoded in the st_other field.  */\n#define STV_DEFAULT\t0\t\t/* Default symbol visibility rules */\n#define STV_INTERNAL\t1\t\t/* Processor specific hidden class */\n#define STV_HIDDEN\t2\t\t/* Sym unavailable in other modules */\n#define STV_PROTECTED\t3\t\t/* Not preemptible, not exported */\n\n\n/* Relocation table entry without addend (in section of type SHT_REL).  */\n\ntypedef struct\n{\n  Elf32_Addr\tr_offset;\t\t/* Address */\n  Elf32_Word\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf32_Rel;\n\n/* I have seen two different definitions of the Elf64_Rel and\n   Elf64_Rela structures, so we'll leave them out until Novell (or\n   whoever) gets their act together.  */\n/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */\n\ntypedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf64_Rel;\n\n/* Relocation table entry with addend (in section of type SHT_RELA).  */\n\ntypedef struct\n{\n  Elf32_Addr\tr_offset;\t\t/* Address */\n  Elf32_Word\tr_info;\t\t\t/* Relocation type and symbol index */\n  Elf32_Sword\tr_addend;\t\t/* Addend */\n} Elf32_Rela;\n\ntypedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n  Elf64_Sxword\tr_addend;\t\t/* Addend */\n} Elf64_Rela;\n\n/* How to extract and insert information held in the r_info field.  */\n\n#define ELF32_R_SYM(val)\t\t((val) >> 8)\n#define ELF32_R_TYPE(val)\t\t((val) & 0xff)\n#define ELF32_R_INFO(sym, type)\t\t(((sym) << 8) + ((type) & 0xff))\n\n#define ELF64_R_SYM(i)\t\t\t((i) >> 32)\n#define ELF64_R_TYPE(i)\t\t\t((i) & 0xffffffff)\n#define ELF64_R_INFO(sym,type)\t\t((((Elf64_Xword) (sym)) << 32) + (type))\n\n/* Program segment header.  */\n\ntypedef struct\n{\n  Elf32_Word\tp_type;\t\t\t/* Segment type */\n  Elf32_Off\tp_offset;\t\t/* Segment file offset */\n  Elf32_Addr\tp_vaddr;\t\t/* Segment virtual address */\n  Elf32_Addr\tp_paddr;\t\t/* Segment physical address */\n  Elf32_Word\tp_filesz;\t\t/* Segment size in file */\n  Elf32_Word\tp_memsz;\t\t/* Segment size in memory */\n  Elf32_Word\tp_flags;\t\t/* Segment flags */\n  Elf32_Word\tp_align;\t\t/* Segment alignment */\n} Elf32_Phdr;\n\ntypedef struct\n{\n  Elf64_Word\tp_type;\t\t\t/* Segment type */\n  Elf64_Word\tp_flags;\t\t/* Segment flags */\n  Elf64_Off\tp_offset;\t\t/* Segment file offset */\n  Elf64_Addr\tp_vaddr;\t\t/* Segment virtual address */\n  Elf64_Addr\tp_paddr;\t\t/* Segment physical address */\n  Elf64_Xword\tp_filesz;\t\t/* Segment size in file */\n  Elf64_Xword\tp_memsz;\t\t/* Segment size in memory */\n  Elf64_Xword\tp_align;\t\t/* Segment alignment */\n} Elf64_Phdr;\n\n/* Special value for e_phnum.  This indicates that the real number of\n   program headers is too large to fit into e_phnum.  Instead the real\n   value is in the field sh_info of section 0.  */\n\n#define PN_XNUM\t\t0xffff\n\n/* Legal values for p_type (segment type).  */\n\n#define\tPT_NULL\t\t0\t\t/* Program header table entry unused */\n#define PT_LOAD\t\t1\t\t/* Loadable program segment */\n#define PT_DYNAMIC\t2\t\t/* Dynamic linking information */\n#define PT_INTERP\t3\t\t/* Program interpreter */\n#define PT_NOTE\t\t4\t\t/* Auxiliary information */\n#define PT_SHLIB\t5\t\t/* Reserved */\n#define PT_PHDR\t\t6\t\t/* Entry for header table itself */\n#define PT_TLS\t\t7\t\t/* Thread-local storage segment */\n#define\tPT_NUM\t\t8\t\t/* Number of defined types */\n#define PT_LOOS\t\t0x60000000\t/* Start of OS-specific */\n#define PT_GNU_EH_FRAME\t0x6474e550\t/* GCC .eh_frame_hdr segment */\n#define PT_GNU_STACK\t0x6474e551\t/* Indicates stack executability */\n#define PT_GNU_RELRO\t0x6474e552\t/* Read-only after relocation */\n#define PT_LOSUNW\t0x6ffffffa\n#define PT_SUNWBSS\t0x6ffffffa\t/* Sun Specific segment */\n#define PT_SUNWSTACK\t0x6ffffffb\t/* Stack segment */\n#define PT_HISUNW\t0x6fffffff\n#define PT_HIOS\t\t0x6fffffff\t/* End of OS-specific */\n#define PT_LOPROC\t0x70000000\t/* Start of processor-specific */\n#define PT_HIPROC\t0x7fffffff\t/* End of processor-specific */\n\n/* Legal values for p_flags (segment flags).  */\n\n#define PF_X\t\t(1 << 0)\t/* Segment is executable */\n#define PF_W\t\t(1 << 1)\t/* Segment is writable */\n#define PF_R\t\t(1 << 2)\t/* Segment is readable */\n#define PF_MASKOS\t0x0ff00000\t/* OS-specific */\n#define PF_MASKPROC\t0xf0000000\t/* Processor-specific */\n\n/* Legal values for note segment descriptor types for core files. */\n\n#define NT_PRSTATUS\t1\t\t/* Contains copy of prstatus struct */\n#define NT_FPREGSET\t2\t\t/* Contains copy of fpregset struct */\n#define NT_PRPSINFO\t3\t\t/* Contains copy of prpsinfo struct */\n#define NT_PRXREG\t4\t\t/* Contains copy of prxregset struct */\n#define NT_TASKSTRUCT\t4\t\t/* Contains copy of task structure */\n#define NT_PLATFORM\t5\t\t/* String from sysinfo(SI_PLATFORM) */\n#define NT_AUXV\t\t6\t\t/* Contains copy of auxv array */\n#define NT_GWINDOWS\t7\t\t/* Contains copy of gwindows struct */\n#define NT_ASRS\t\t8\t\t/* Contains copy of asrset struct */\n#define NT_PSTATUS\t10\t\t/* Contains copy of pstatus struct */\n#define NT_PSINFO\t13\t\t/* Contains copy of psinfo struct */\n#define NT_PRCRED\t14\t\t/* Contains copy of prcred struct */\n#define NT_UTSNAME\t15\t\t/* Contains copy of utsname struct */\n#define NT_LWPSTATUS\t16\t\t/* Contains copy of lwpstatus struct */\n#define NT_LWPSINFO\t17\t\t/* Contains copy of lwpinfo struct */\n#define NT_PRFPXREG\t20\t\t/* Contains copy of fprxregset struct */\n#define NT_PRXFPREG\t0x46e62b7f\t/* Contains copy of user_fxsr_struct */\n#define NT_PPC_VMX\t0x100\t\t/* PowerPC Altivec/VMX registers */\n#define NT_PPC_SPE\t0x101\t\t/* PowerPC SPE/EVR registers */\n#define NT_PPC_VSX\t0x102\t\t/* PowerPC VSX registers */\n#define NT_386_TLS\t0x200\t\t/* i386 TLS slots (struct user_desc) */\n#define NT_386_IOPERM\t0x201\t\t/* x86 io permission bitmap (1=deny) */\n#define NT_X86_XSTATE\t0x202\t\t/* x86 extended state using xsave */\n#define NT_S390_HIGH_GPRS\t0x300\t/* s390 upper register halves */\n#define NT_S390_TIMER\t0x301\t\t/* s390 timer register */\n#define NT_S390_TODCMP\t0x302\t\t/* s390 TOD clock comparator register */\n#define NT_S390_TODPREG\t0x303\t\t/* s390 TOD programmable register */\n#define NT_S390_CTRS\t0x304\t\t/* s390 control registers */\n#define NT_S390_PREFIX\t0x305\t\t/* s390 prefix register */\n#define NT_S390_LAST_BREAK\t0x306\t/* s390 breaking event address */\n#define NT_S390_SYSTEM_CALL\t0x307\t/* s390 system call restart data */\n#define NT_ARM_VFP\t0x400\t\t/* ARM VFP/NEON registers */\n#define NT_ARM_TLS\t0x401\t\t/* ARM TLS register */\n#define NT_ARM_HW_BREAK\t0x402\t\t/* ARM hardware breakpoint registers */\n#define NT_ARM_HW_WATCH\t0x403\t\t/* ARM hardware watchpoint registers */\n\n/* Legal values for the note segment descriptor types for object files.  */\n\n#define NT_VERSION\t1\t\t/* Contains a version string.  */\n\n\n/* Dynamic section entry.  */\n\ntypedef struct\n{\n  Elf32_Sword\td_tag;\t\t\t/* Dynamic entry type */\n  union\n    {\n      Elf32_Word d_val;\t\t\t/* Integer value */\n      Elf32_Addr d_ptr;\t\t\t/* Address value */\n    } d_un;\n} Elf32_Dyn;\n\ntypedef struct\n{\n  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */\n  union\n    {\n      Elf64_Xword d_val;\t\t/* Integer value */\n      Elf64_Addr d_ptr;\t\t\t/* Address value */\n    } d_un;\n} Elf64_Dyn;\n\n/* Legal values for d_tag (dynamic entry type).  */\n\n#define DT_NULL\t\t0\t\t/* Marks end of dynamic section */\n#define DT_NEEDED\t1\t\t/* Name of needed library */\n#define DT_PLTRELSZ\t2\t\t/* Size in bytes of PLT relocs */\n#define DT_PLTGOT\t3\t\t/* Processor defined value */\n#define DT_HASH\t\t4\t\t/* Address of symbol hash table */\n#define DT_STRTAB\t5\t\t/* Address of string table */\n#define DT_SYMTAB\t6\t\t/* Address of symbol table */\n#define DT_RELA\t\t7\t\t/* Address of Rela relocs */\n#define DT_RELASZ\t8\t\t/* Total size of Rela relocs */\n#define DT_RELAENT\t9\t\t/* Size of one Rela reloc */\n#define DT_STRSZ\t10\t\t/* Size of string table */\n#define DT_SYMENT\t11\t\t/* Size of one symbol table entry */\n#define DT_INIT\t\t12\t\t/* Address of init function */\n#define DT_FINI\t\t13\t\t/* Address of termination function */\n#define DT_SONAME\t14\t\t/* Name of shared object */\n#define DT_RPATH\t15\t\t/* Library search path (deprecated) */\n#define DT_SYMBOLIC\t16\t\t/* Start symbol search here */\n#define DT_REL\t\t17\t\t/* Address of Rel relocs */\n#define DT_RELSZ\t18\t\t/* Total size of Rel relocs */\n#define DT_RELENT\t19\t\t/* Size of one Rel reloc */\n#define DT_PLTREL\t20\t\t/* Type of reloc in PLT */\n#define DT_DEBUG\t21\t\t/* For debugging; unspecified */\n#define DT_TEXTREL\t22\t\t/* Reloc might modify .text */\n#define DT_JMPREL\t23\t\t/* Address of PLT relocs */\n#define\tDT_BIND_NOW\t24\t\t/* Process relocations of object */\n#define\tDT_INIT_ARRAY\t25\t\t/* Array with addresses of init fct */\n#define\tDT_FINI_ARRAY\t26\t\t/* Array with addresses of fini fct */\n#define\tDT_INIT_ARRAYSZ\t27\t\t/* Size in bytes of DT_INIT_ARRAY */\n#define\tDT_FINI_ARRAYSZ\t28\t\t/* Size in bytes of DT_FINI_ARRAY */\n#define DT_RUNPATH\t29\t\t/* Library search path */\n#define DT_FLAGS\t30\t\t/* Flags for the object being loaded */\n#define DT_ENCODING\t32\t\t/* Start of encoded range */\n#define DT_PREINIT_ARRAY 32\t\t/* Array with addresses of preinit fct*/\n#define DT_PREINIT_ARRAYSZ 33\t\t/* size in bytes of DT_PREINIT_ARRAY */\n#define\tDT_NUM\t\t34\t\t/* Number used */\n#define DT_LOOS\t\t0x6000000d\t/* Start of OS-specific */\n#define DT_HIOS\t\t0x6ffff000\t/* End of OS-specific */\n#define DT_LOPROC\t0x70000000\t/* Start of processor-specific */\n#define DT_HIPROC\t0x7fffffff\t/* End of processor-specific */\n#define\tDT_PROCNUM\tDT_MIPS_NUM\t/* Most used by any processor */\n\n/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n   approach.  */\n#define DT_VALRNGLO\t0x6ffffd00\n#define DT_GNU_PRELINKED 0x6ffffdf5\t/* Prelinking timestamp */\n#define DT_GNU_CONFLICTSZ 0x6ffffdf6\t/* Size of conflict section */\n#define DT_GNU_LIBLISTSZ 0x6ffffdf7\t/* Size of library list */\n#define DT_CHECKSUM\t0x6ffffdf8\n#define DT_PLTPADSZ\t0x6ffffdf9\n#define DT_MOVEENT\t0x6ffffdfa\n#define DT_MOVESZ\t0x6ffffdfb\n#define DT_FEATURE_1\t0x6ffffdfc\t/* Feature selection (DTF_*).  */\n#define DT_POSFLAG_1\t0x6ffffdfd\t/* Flags for DT_* entries, effecting\n\t\t\t\t\t   the following DT_* entry.  */\n#define DT_SYMINSZ\t0x6ffffdfe\t/* Size of syminfo table (in bytes) */\n#define DT_SYMINENT\t0x6ffffdff\t/* Entry size of syminfo */\n#define DT_VALRNGHI\t0x6ffffdff\n#define DT_VALTAGIDX(tag)\t(DT_VALRNGHI - (tag))\t/* Reverse order! */\n#define DT_VALNUM 12\n\n/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n\n   If any adjustment is made to the ELF object after it has been\n   built these entries will need to be adjusted.  */\n#define DT_ADDRRNGLO\t0x6ffffe00\n#define DT_GNU_HASH\t0x6ffffef5\t/* GNU-style hash table.  */\n#define DT_TLSDESC_PLT\t0x6ffffef6\n#define DT_TLSDESC_GOT\t0x6ffffef7\n#define DT_GNU_CONFLICT\t0x6ffffef8\t/* Start of conflict section */\n#define DT_GNU_LIBLIST\t0x6ffffef9\t/* Library list */\n#define DT_CONFIG\t0x6ffffefa\t/* Configuration information.  */\n#define DT_DEPAUDIT\t0x6ffffefb\t/* Dependency auditing.  */\n#define DT_AUDIT\t0x6ffffefc\t/* Object auditing.  */\n#define\tDT_PLTPAD\t0x6ffffefd\t/* PLT padding.  */\n#define\tDT_MOVETAB\t0x6ffffefe\t/* Move table.  */\n#define DT_SYMINFO\t0x6ffffeff\t/* Syminfo table.  */\n#define DT_ADDRRNGHI\t0x6ffffeff\n#define DT_ADDRTAGIDX(tag)\t(DT_ADDRRNGHI - (tag))\t/* Reverse order! */\n#define DT_ADDRNUM 11\n\n/* The versioning entry types.  The next are defined as part of the\n   GNU extension.  */\n#define DT_VERSYM\t0x6ffffff0\n\n#define DT_RELACOUNT\t0x6ffffff9\n#define DT_RELCOUNT\t0x6ffffffa\n\n/* These were chosen by Sun.  */\n#define DT_FLAGS_1\t0x6ffffffb\t/* State flags, see DF_1_* below.  */\n#define\tDT_VERDEF\t0x6ffffffc\t/* Address of version definition\n\t\t\t\t\t   table */\n#define\tDT_VERDEFNUM\t0x6ffffffd\t/* Number of version definitions */\n#define\tDT_VERNEED\t0x6ffffffe\t/* Address of table with needed\n\t\t\t\t\t   versions */\n#define\tDT_VERNEEDNUM\t0x6fffffff\t/* Number of needed versions */\n#define DT_VERSIONTAGIDX(tag)\t(DT_VERNEEDNUM - (tag))\t/* Reverse order! */\n#define DT_VERSIONTAGNUM 16\n\n/* Sun added these machine-independent extensions in the \"processor-specific\"\n   range.  Be compatible.  */\n#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */\n#define DT_FILTER       0x7fffffff      /* Shared object to get values from */\n#define DT_EXTRATAGIDX(tag)\t((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)\n#define DT_EXTRANUM\t3\n\n/* Values of `d_un.d_val' in the DT_FLAGS entry.  */\n#define DF_ORIGIN\t0x00000001\t/* Object may use DF_ORIGIN */\n#define DF_SYMBOLIC\t0x00000002\t/* Symbol resolutions starts here */\n#define DF_TEXTREL\t0x00000004\t/* Object contains text relocations */\n#define DF_BIND_NOW\t0x00000008\t/* No lazy binding for this object */\n#define DF_STATIC_TLS\t0x00000010\t/* Module uses the static TLS model */\n\n/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1\n   entry in the dynamic section.  */\n#define DF_1_NOW\t0x00000001\t/* Set RTLD_NOW for this object.  */\n#define DF_1_GLOBAL\t0x00000002\t/* Set RTLD_GLOBAL for this object.  */\n#define DF_1_GROUP\t0x00000004\t/* Set RTLD_GROUP for this object.  */\n#define DF_1_NODELETE\t0x00000008\t/* Set RTLD_NODELETE for this object.*/\n#define DF_1_LOADFLTR\t0x00000010\t/* Trigger filtee loading at runtime.*/\n#define DF_1_INITFIRST\t0x00000020\t/* Set RTLD_INITFIRST for this object*/\n#define DF_1_NOOPEN\t0x00000040\t/* Set RTLD_NOOPEN for this object.  */\n#define DF_1_ORIGIN\t0x00000080\t/* $ORIGIN must be handled.  */\n#define DF_1_DIRECT\t0x00000100\t/* Direct binding enabled.  */\n#define DF_1_TRANS\t0x00000200\n#define DF_1_INTERPOSE\t0x00000400\t/* Object is used to interpose.  */\n#define DF_1_NODEFLIB\t0x00000800\t/* Ignore default lib search path.  */\n#define DF_1_NODUMP\t0x00001000\t/* Object can't be dldump'ed.  */\n#define DF_1_CONFALT\t0x00002000\t/* Configuration alternative created.*/\n#define DF_1_ENDFILTEE\t0x00004000\t/* Filtee terminates filters search. */\n#define\tDF_1_DISPRELDNE\t0x00008000\t/* Disp reloc applied at build time. */\n#define\tDF_1_DISPRELPND\t0x00010000\t/* Disp reloc applied at run-time.  */\n#define\tDF_1_NODIRECT\t0x00020000\t/* Object has no-direct binding. */\n#define\tDF_1_IGNMULDEF\t0x00040000\n#define\tDF_1_NOKSYMS\t0x00080000\n#define\tDF_1_NOHDR\t0x00100000\n#define\tDF_1_EDITED\t0x00200000\t/* Object is modified after built.  */\n#define\tDF_1_NORELOC\t0x00400000\n#define\tDF_1_SYMINTPOSE\t0x00800000\t/* Object has individual interposers.  */\n#define\tDF_1_GLOBAUDIT\t0x01000000\t/* Global auditing required.  */\n#define\tDF_1_SINGLETON\t0x02000000\t/* Singleton symbols are used.  */\n#define\tDF_1_PIE\t0x08000000\n\n/* Flags for the feature selection in DT_FEATURE_1.  */\n#define DTF_1_PARINIT\t0x00000001\n#define DTF_1_CONFEXP\t0x00000002\n\n/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */\n#define DF_P1_LAZYLOAD\t0x00000001\t/* Lazyload following object.  */\n#define DF_P1_GROUPPERM\t0x00000002\t/* Symbols from next object are not\n\t\t\t\t\t   generally available.  */\n\n/* Version definition sections.  */\n\ntypedef struct\n{\n  Elf32_Half\tvd_version;\t\t/* Version revision */\n  Elf32_Half\tvd_flags;\t\t/* Version information */\n  Elf32_Half\tvd_ndx;\t\t\t/* Version Index */\n  Elf32_Half\tvd_cnt;\t\t\t/* Number of associated aux entries */\n  Elf32_Word\tvd_hash;\t\t/* Version name hash value */\n  Elf32_Word\tvd_aux;\t\t\t/* Offset in bytes to verdaux array */\n  Elf32_Word\tvd_next;\t\t/* Offset in bytes to next verdef\n\t\t\t\t\t   entry */\n} Elf32_Verdef;\n\ntypedef struct\n{\n  Elf64_Half\tvd_version;\t\t/* Version revision */\n  Elf64_Half\tvd_flags;\t\t/* Version information */\n  Elf64_Half\tvd_ndx;\t\t\t/* Version Index */\n  Elf64_Half\tvd_cnt;\t\t\t/* Number of associated aux entries */\n  Elf64_Word\tvd_hash;\t\t/* Version name hash value */\n  Elf64_Word\tvd_aux;\t\t\t/* Offset in bytes to verdaux array */\n  Elf64_Word\tvd_next;\t\t/* Offset in bytes to next verdef\n\t\t\t\t\t   entry */\n} Elf64_Verdef;\n\n\n/* Legal values for vd_version (version revision).  */\n#define VER_DEF_NONE\t0\t\t/* No version */\n#define VER_DEF_CURRENT\t1\t\t/* Current version */\n#define VER_DEF_NUM\t2\t\t/* Given version number */\n\n/* Legal values for vd_flags (version information flags).  */\n#define VER_FLG_BASE\t0x1\t\t/* Version definition of file itself */\n#define VER_FLG_WEAK\t0x2\t\t/* Weak version identifier */\n\n/* Versym symbol index values.  */\n#define\tVER_NDX_LOCAL\t\t0\t/* Symbol is local.  */\n#define\tVER_NDX_GLOBAL\t\t1\t/* Symbol is global.  */\n#define\tVER_NDX_LORESERVE\t0xff00\t/* Beginning of reserved entries.  */\n#define\tVER_NDX_ELIMINATE\t0xff01\t/* Symbol is to be eliminated.  */\n\n/* Auxiliary version information.  */\n\ntypedef struct\n{\n  Elf32_Word\tvda_name;\t\t/* Version or dependency names */\n  Elf32_Word\tvda_next;\t\t/* Offset in bytes to next verdaux\n\t\t\t\t\t   entry */\n} Elf32_Verdaux;\n\ntypedef struct\n{\n  Elf64_Word\tvda_name;\t\t/* Version or dependency names */\n  Elf64_Word\tvda_next;\t\t/* Offset in bytes to next verdaux\n\t\t\t\t\t   entry */\n} Elf64_Verdaux;\n\n\n/* Version dependency section.  */\n\ntypedef struct\n{\n  Elf32_Half\tvn_version;\t\t/* Version of structure */\n  Elf32_Half\tvn_cnt;\t\t\t/* Number of associated aux entries */\n  Elf32_Word\tvn_file;\t\t/* Offset of filename for this\n\t\t\t\t\t   dependency */\n  Elf32_Word\tvn_aux;\t\t\t/* Offset in bytes to vernaux array */\n  Elf32_Word\tvn_next;\t\t/* Offset in bytes to next verneed\n\t\t\t\t\t   entry */\n} Elf32_Verneed;\n\ntypedef struct\n{\n  Elf64_Half\tvn_version;\t\t/* Version of structure */\n  Elf64_Half\tvn_cnt;\t\t\t/* Number of associated aux entries */\n  Elf64_Word\tvn_file;\t\t/* Offset of filename for this\n\t\t\t\t\t   dependency */\n  Elf64_Word\tvn_aux;\t\t\t/* Offset in bytes to vernaux array */\n  Elf64_Word\tvn_next;\t\t/* Offset in bytes to next verneed\n\t\t\t\t\t   entry */\n} Elf64_Verneed;\n\n\n/* Legal values for vn_version (version revision).  */\n#define VER_NEED_NONE\t 0\t\t/* No version */\n#define VER_NEED_CURRENT 1\t\t/* Current version */\n#define VER_NEED_NUM\t 2\t\t/* Given version number */\n\n/* Auxiliary needed version information.  */\n\ntypedef struct\n{\n  Elf32_Word\tvna_hash;\t\t/* Hash value of dependency name */\n  Elf32_Half\tvna_flags;\t\t/* Dependency specific information */\n  Elf32_Half\tvna_other;\t\t/* Unused */\n  Elf32_Word\tvna_name;\t\t/* Dependency name string offset */\n  Elf32_Word\tvna_next;\t\t/* Offset in bytes to next vernaux\n\t\t\t\t\t   entry */\n} Elf32_Vernaux;\n\ntypedef struct\n{\n  Elf64_Word\tvna_hash;\t\t/* Hash value of dependency name */\n  Elf64_Half\tvna_flags;\t\t/* Dependency specific information */\n  Elf64_Half\tvna_other;\t\t/* Unused */\n  Elf64_Word\tvna_name;\t\t/* Dependency name string offset */\n  Elf64_Word\tvna_next;\t\t/* Offset in bytes to next vernaux\n\t\t\t\t\t   entry */\n} Elf64_Vernaux;\n\n\n/* Legal values for vna_flags.  */\n#define VER_FLG_WEAK\t0x2\t\t/* Weak version identifier */\n\n\n/* Auxiliary vector.  */\n\n/* This vector is normally only used by the program interpreter.  The\n   usual definition in an ABI supplement uses the name auxv_t.  The\n   vector is not usually defined in a standard <elf.h> file, but it\n   can't hurt.  We rename it to avoid conflicts.  The sizes of these\n   types are an arrangement between the exec server and the program\n   interpreter, so we don't fully specify them here.  */\n\ntypedef struct\n{\n  uint32_t a_type;\t\t/* Entry type */\n  union\n    {\n      uint32_t a_val;\t\t/* Integer value */\n      /* We use to have pointer elements added here.  We cannot do that,\n\t though, since it does not work when using 32-bit definitions\n\t on 64-bit platforms and vice versa.  */\n    } a_un;\n} Elf32_auxv_t;\n\ntypedef struct\n{\n  uint64_t a_type;\t\t/* Entry type */\n  union\n    {\n      uint64_t a_val;\t\t/* Integer value */\n      /* We use to have pointer elements added here.  We cannot do that,\n\t though, since it does not work when using 32-bit definitions\n\t on 64-bit platforms and vice versa.  */\n    } a_un;\n} Elf64_auxv_t;\n\n/* Legal values for a_type (entry type).  */\n\n#define AT_NULL\t\t0\t\t/* End of vector */\n#define AT_IGNORE\t1\t\t/* Entry should be ignored */\n#define AT_EXECFD\t2\t\t/* File descriptor of program */\n#define AT_PHDR\t\t3\t\t/* Program headers for program */\n#define AT_PHENT\t4\t\t/* Size of program header entry */\n#define AT_PHNUM\t5\t\t/* Number of program headers */\n#define AT_PAGESZ\t6\t\t/* System page size */\n#define AT_BASE\t\t7\t\t/* Base address of interpreter */\n#define AT_FLAGS\t8\t\t/* Flags */\n#define AT_ENTRY\t9\t\t/* Entry point of program */\n#define AT_NOTELF\t10\t\t/* Program is not ELF */\n#define AT_UID\t\t11\t\t/* Real uid */\n#define AT_EUID\t\t12\t\t/* Effective uid */\n#define AT_GID\t\t13\t\t/* Real gid */\n#define AT_EGID\t\t14\t\t/* Effective gid */\n#define AT_CLKTCK\t17\t\t/* Frequency of times() */\n\n/* Some more special a_type values describing the hardware.  */\n#define AT_PLATFORM\t15\t\t/* String identifying platform.  */\n#define AT_HWCAP\t16\t\t/* Machine dependent hints about\n\t\t\t\t\t   processor capabilities.  */\n\n/* This entry gives some information about the FPU initialization\n   performed by the kernel.  */\n#define AT_FPUCW\t18\t\t/* Used FPU control word.  */\n\n/* Cache block sizes.  */\n#define AT_DCACHEBSIZE\t19\t\t/* Data cache block size.  */\n#define AT_ICACHEBSIZE\t20\t\t/* Instruction cache block size.  */\n#define AT_UCACHEBSIZE\t21\t\t/* Unified cache block size.  */\n\n/* A special ignored value for PPC, used by the kernel to control the\n   interpretation of the AUXV. Must be > 16.  */\n#define AT_IGNOREPPC\t22\t\t/* Entry should be ignored.  */\n\n#define\tAT_SECURE\t23\t\t/* Boolean, was exec setuid-like?  */\n\n#define AT_BASE_PLATFORM 24\t\t/* String identifying real platforms.*/\n\n#define AT_RANDOM\t25\t\t/* Address of 16 random bytes.  */\n\n#define AT_EXECFN\t31\t\t/* Filename of executable.  */\n\n/* Pointer to the global system page used for system calls and other\n   nice things.  */\n#define AT_SYSINFO\t32\n#define AT_SYSINFO_EHDR\t33\n\n/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains\n   log2 of line size; mask those to get cache size.  */\n#define AT_L1I_CACHESHAPE\t34\n#define AT_L1D_CACHESHAPE\t35\n#define AT_L2_CACHESHAPE\t36\n#define AT_L3_CACHESHAPE\t37\n\n/* Note section contents.  Each entry in the note section begins with\n   a header of a fixed form.  */\n\ntypedef struct\n{\n  Elf32_Word n_namesz;\t\t\t/* Length of the note's name.  */\n  Elf32_Word n_descsz;\t\t\t/* Length of the note's descriptor.  */\n  Elf32_Word n_type;\t\t\t/* Type of the note.  */\n} Elf32_Nhdr;\n\ntypedef struct\n{\n  Elf64_Word n_namesz;\t\t\t/* Length of the note's name.  */\n  Elf64_Word n_descsz;\t\t\t/* Length of the note's descriptor.  */\n  Elf64_Word n_type;\t\t\t/* Type of the note.  */\n} Elf64_Nhdr;\n\n/* Known names of notes.  */\n\n/* Solaris entries in the note section have this name.  */\n#define ELF_NOTE_SOLARIS\t\"SUNW Solaris\"\n\n/* Note entries for GNU systems have this name.  */\n#define ELF_NOTE_GNU\t\t\"GNU\"\n\n\n/* Defined types of notes for Solaris.  */\n\n/* Value of descriptor (one word) is desired pagesize for the binary.  */\n#define ELF_NOTE_PAGESIZE_HINT\t1\n\n\n/* Defined note types for GNU systems.  */\n\n/* ABI information.  The descriptor consists of words:\n   word 0: OS descriptor\n   word 1: major version of the ABI\n   word 2: minor version of the ABI\n   word 3: subminor version of the ABI\n*/\n#define NT_GNU_ABI_TAG\t1\n#define ELF_NOTE_ABI\tNT_GNU_ABI_TAG /* Old name.  */\n\n/* Known OSes.  These values can appear in word 0 of an\n   NT_GNU_ABI_TAG note section entry.  */\n#define ELF_NOTE_OS_LINUX\t0\n#define ELF_NOTE_OS_GNU\t\t1\n#define ELF_NOTE_OS_SOLARIS2\t2\n#define ELF_NOTE_OS_FREEBSD\t3\n\n/* Synthetic hwcap information.  The descriptor begins with two words:\n   word 0: number of entries\n   word 1: bitmask of enabled entries\n   Then follow variable-length entries, one byte followed by a\n   '\\0'-terminated hwcap name string.  The byte gives the bit\n   number to test if enabled, (1U << bit) & bitmask.  */\n#define NT_GNU_HWCAP\t2\n\n/* Build ID bits as generated by ld --build-id.\n   The descriptor consists of any nonzero number of bytes.  */\n#define NT_GNU_BUILD_ID\t3\n\n/* Version note generated by GNU gold containing a version string.  */\n#define NT_GNU_GOLD_VERSION\t4\n\n\n/* Move records.  */\ntypedef struct\n{\n  Elf32_Xword m_value;\t\t/* Symbol value.  */\n  Elf32_Word m_info;\t\t/* Size and index.  */\n  Elf32_Word m_poffset;\t\t/* Symbol offset.  */\n  Elf32_Half m_repeat;\t\t/* Repeat count.  */\n  Elf32_Half m_stride;\t\t/* Stride info.  */\n} Elf32_Move;\n\ntypedef struct\n{\n  Elf64_Xword m_value;\t\t/* Symbol value.  */\n  Elf64_Xword m_info;\t\t/* Size and index.  */\n  Elf64_Xword m_poffset;\t/* Symbol offset.  */\n  Elf64_Half m_repeat;\t\t/* Repeat count.  */\n  Elf64_Half m_stride;\t\t/* Stride info.  */\n} Elf64_Move;\n\n/* Macro to construct move records.  */\n#define ELF32_M_SYM(info)\t((info) >> 8)\n#define ELF32_M_SIZE(info)\t((unsigned char) (info))\n#define ELF32_M_INFO(sym, size)\t(((sym) << 8) + (unsigned char) (size))\n\n#define ELF64_M_SYM(info)\tELF32_M_SYM (info)\n#define ELF64_M_SIZE(info)\tELF32_M_SIZE (info)\n#define ELF64_M_INFO(sym, size)\tELF32_M_INFO (sym, size)\n\n\n/* Motorola 68k specific definitions.  */\n\n/* Values for Elf32_Ehdr.e_flags.  */\n#define EF_CPU32\t0x00810000\n\n/* m68k relocs.  */\n\n#define R_68K_NONE\t0\t\t/* No reloc */\n#define R_68K_32\t1\t\t/* Direct 32 bit  */\n#define R_68K_16\t2\t\t/* Direct 16 bit  */\n#define R_68K_8\t\t3\t\t/* Direct 8 bit  */\n#define R_68K_PC32\t4\t\t/* PC relative 32 bit */\n#define R_68K_PC16\t5\t\t/* PC relative 16 bit */\n#define R_68K_PC8\t6\t\t/* PC relative 8 bit */\n#define R_68K_GOT32\t7\t\t/* 32 bit PC relative GOT entry */\n#define R_68K_GOT16\t8\t\t/* 16 bit PC relative GOT entry */\n#define R_68K_GOT8\t9\t\t/* 8 bit PC relative GOT entry */\n#define R_68K_GOT32O\t10\t\t/* 32 bit GOT offset */\n#define R_68K_GOT16O\t11\t\t/* 16 bit GOT offset */\n#define R_68K_GOT8O\t12\t\t/* 8 bit GOT offset */\n#define R_68K_PLT32\t13\t\t/* 32 bit PC relative PLT address */\n#define R_68K_PLT16\t14\t\t/* 16 bit PC relative PLT address */\n#define R_68K_PLT8\t15\t\t/* 8 bit PC relative PLT address */\n#define R_68K_PLT32O\t16\t\t/* 32 bit PLT offset */\n#define R_68K_PLT16O\t17\t\t/* 16 bit PLT offset */\n#define R_68K_PLT8O\t18\t\t/* 8 bit PLT offset */\n#define R_68K_COPY\t19\t\t/* Copy symbol at runtime */\n#define R_68K_GLOB_DAT\t20\t\t/* Create GOT entry */\n#define R_68K_JMP_SLOT\t21\t\t/* Create PLT entry */\n#define R_68K_RELATIVE\t22\t\t/* Adjust by program base */\n#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */\n#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */\n#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */\n#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */\n#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */\n#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */\n#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */\n#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */\n#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */\n#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */\n#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */\n#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */\n#define R_68K_TLS_LE32      37          /* 32 bit offset relative to\n\t\t\t\t\t   static TLS block */\n#define R_68K_TLS_LE16      38          /* 16 bit offset relative to\n\t\t\t\t\t   static TLS block */\n#define R_68K_TLS_LE8       39          /* 8 bit offset relative to\n\t\t\t\t\t   static TLS block */\n#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */\n#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */\n#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */\n/* Keep this the last entry.  */\n#define R_68K_NUM\t43\n\n/* Intel 80386 specific definitions.  */\n\n/* i386 relocs.  */\n\n#define R_386_NONE\t   0\t\t/* No reloc */\n#define R_386_32\t   1\t\t/* Direct 32 bit  */\n#define R_386_PC32\t   2\t\t/* PC relative 32 bit */\n#define R_386_GOT32\t   3\t\t/* 32 bit GOT entry */\n#define R_386_PLT32\t   4\t\t/* 32 bit PLT address */\n#define R_386_COPY\t   5\t\t/* Copy symbol at runtime */\n#define R_386_GLOB_DAT\t   6\t\t/* Create GOT entry */\n#define R_386_JMP_SLOT\t   7\t\t/* Create PLT entry */\n#define R_386_RELATIVE\t   8\t\t/* Adjust by program base */\n#define R_386_GOTOFF\t   9\t\t/* 32 bit offset to GOT */\n#define R_386_GOTPC\t   10\t\t/* 32 bit PC relative offset to GOT */\n#define R_386_32PLT\t   11\n#define R_386_TLS_TPOFF\t   14\t\t/* Offset in static TLS block */\n#define R_386_TLS_IE\t   15\t\t/* Address of GOT entry for static TLS\n\t\t\t\t\t   block offset */\n#define R_386_TLS_GOTIE\t   16\t\t/* GOT entry for static TLS block\n\t\t\t\t\t   offset */\n#define R_386_TLS_LE\t   17\t\t/* Offset relative to static TLS\n\t\t\t\t\t   block */\n#define R_386_TLS_GD\t   18\t\t/* Direct 32 bit for GNU version of\n\t\t\t\t\t   general dynamic thread local data */\n#define R_386_TLS_LDM\t   19\t\t/* Direct 32 bit for GNU version of\n\t\t\t\t\t   local dynamic thread local data\n\t\t\t\t\t   in LE code */\n#define R_386_16\t   20\n#define R_386_PC16\t   21\n#define R_386_8\t\t   22\n#define R_386_PC8\t   23\n#define R_386_TLS_GD_32\t   24\t\t/* Direct 32 bit for general dynamic\n\t\t\t\t\t   thread local data */\n#define R_386_TLS_GD_PUSH  25\t\t/* Tag for pushl in GD TLS code */\n#define R_386_TLS_GD_CALL  26\t\t/* Relocation for call to\n\t\t\t\t\t   __tls_get_addr() */\n#define R_386_TLS_GD_POP   27\t\t/* Tag for popl in GD TLS code */\n#define R_386_TLS_LDM_32   28\t\t/* Direct 32 bit for local dynamic\n\t\t\t\t\t   thread local data in LE code */\n#define R_386_TLS_LDM_PUSH 29\t\t/* Tag for pushl in LDM TLS code */\n#define R_386_TLS_LDM_CALL 30\t\t/* Relocation for call to\n\t\t\t\t\t   __tls_get_addr() in LDM code */\n#define R_386_TLS_LDM_POP  31\t\t/* Tag for popl in LDM TLS code */\n#define R_386_TLS_LDO_32   32\t\t/* Offset relative to TLS block */\n#define R_386_TLS_IE_32\t   33\t\t/* GOT entry for negated static TLS\n\t\t\t\t\t   block offset */\n#define R_386_TLS_LE_32\t   34\t\t/* Negated offset relative to static\n\t\t\t\t\t   TLS block */\n#define R_386_TLS_DTPMOD32 35\t\t/* ID of module containing symbol */\n#define R_386_TLS_DTPOFF32 36\t\t/* Offset in TLS block */\n#define R_386_TLS_TPOFF32  37\t\t/* Negated offset in static TLS block */\n/* 38? */\n#define R_386_TLS_GOTDESC  39\t\t/* GOT offset for TLS descriptor.  */\n#define R_386_TLS_DESC_CALL 40\t\t/* Marker of call through TLS\n\t\t\t\t\t   descriptor for\n\t\t\t\t\t   relaxation.  */\n#define R_386_TLS_DESC     41\t\t/* TLS descriptor containing\n\t\t\t\t\t   pointer to code and to\n\t\t\t\t\t   argument, returning the TLS\n\t\t\t\t\t   offset for the symbol.  */\n#define R_386_IRELATIVE\t   42\t\t/* Adjust indirectly by program base */\n#define R_386_GOT32X       43\t\t/* 32 bit GOT entry, relaxable */\n/* Keep this the last entry.  */\n#define R_386_NUM\t   44\n\n/* SUN SPARC specific definitions.  */\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n\n#define STT_SPARC_REGISTER\t13\t/* Global register reserved to app. */\n\n/* Values for Elf64_Ehdr.e_flags.  */\n\n#define EF_SPARCV9_MM\t\t3\n#define EF_SPARCV9_TSO\t\t0\n#define EF_SPARCV9_PSO\t\t1\n#define EF_SPARCV9_RMO\t\t2\n#define EF_SPARC_LEDATA\t\t0x800000 /* little endian data */\n#define EF_SPARC_EXT_MASK\t0xFFFF00\n#define EF_SPARC_32PLUS\t\t0x000100 /* generic V8+ features */\n#define EF_SPARC_SUN_US1\t0x000200 /* Sun UltraSPARC1 extensions */\n#define EF_SPARC_HAL_R1\t\t0x000400 /* HAL R1 extensions */\n#define EF_SPARC_SUN_US3\t0x000800 /* Sun UltraSPARCIII extensions */\n\n/* SPARC relocs.  */\n\n#define R_SPARC_NONE\t\t0\t/* No reloc */\n#define R_SPARC_8\t\t1\t/* Direct 8 bit */\n#define R_SPARC_16\t\t2\t/* Direct 16 bit */\n#define R_SPARC_32\t\t3\t/* Direct 32 bit */\n#define R_SPARC_DISP8\t\t4\t/* PC relative 8 bit */\n#define R_SPARC_DISP16\t\t5\t/* PC relative 16 bit */\n#define R_SPARC_DISP32\t\t6\t/* PC relative 32 bit */\n#define R_SPARC_WDISP30\t\t7\t/* PC relative 30 bit shifted */\n#define R_SPARC_WDISP22\t\t8\t/* PC relative 22 bit shifted */\n#define R_SPARC_HI22\t\t9\t/* High 22 bit */\n#define R_SPARC_22\t\t10\t/* Direct 22 bit */\n#define R_SPARC_13\t\t11\t/* Direct 13 bit */\n#define R_SPARC_LO10\t\t12\t/* Truncated 10 bit */\n#define R_SPARC_GOT10\t\t13\t/* Truncated 10 bit GOT entry */\n#define R_SPARC_GOT13\t\t14\t/* 13 bit GOT entry */\n#define R_SPARC_GOT22\t\t15\t/* 22 bit GOT entry shifted */\n#define R_SPARC_PC10\t\t16\t/* PC relative 10 bit truncated */\n#define R_SPARC_PC22\t\t17\t/* PC relative 22 bit shifted */\n#define R_SPARC_WPLT30\t\t18\t/* 30 bit PC relative PLT address */\n#define R_SPARC_COPY\t\t19\t/* Copy symbol at runtime */\n#define R_SPARC_GLOB_DAT\t20\t/* Create GOT entry */\n#define R_SPARC_JMP_SLOT\t21\t/* Create PLT entry */\n#define R_SPARC_RELATIVE\t22\t/* Adjust by program base */\n#define R_SPARC_UA32\t\t23\t/* Direct 32 bit unaligned */\n\n/* Additional Sparc64 relocs.  */\n\n#define R_SPARC_PLT32\t\t24\t/* Direct 32 bit ref to PLT entry */\n#define R_SPARC_HIPLT22\t\t25\t/* High 22 bit PLT entry */\n#define R_SPARC_LOPLT10\t\t26\t/* Truncated 10 bit PLT entry */\n#define R_SPARC_PCPLT32\t\t27\t/* PC rel 32 bit ref to PLT entry */\n#define R_SPARC_PCPLT22\t\t28\t/* PC rel high 22 bit PLT entry */\n#define R_SPARC_PCPLT10\t\t29\t/* PC rel trunc 10 bit PLT entry */\n#define R_SPARC_10\t\t30\t/* Direct 10 bit */\n#define R_SPARC_11\t\t31\t/* Direct 11 bit */\n#define R_SPARC_64\t\t32\t/* Direct 64 bit */\n#define R_SPARC_OLO10\t\t33\t/* 10bit with secondary 13bit addend */\n#define R_SPARC_HH22\t\t34\t/* Top 22 bits of direct 64 bit */\n#define R_SPARC_HM10\t\t35\t/* High middle 10 bits of ... */\n#define R_SPARC_LM22\t\t36\t/* Low middle 22 bits of ... */\n#define R_SPARC_PC_HH22\t\t37\t/* Top 22 bits of pc rel 64 bit */\n#define R_SPARC_PC_HM10\t\t38\t/* High middle 10 bit of ... */\n#define R_SPARC_PC_LM22\t\t39\t/* Low middle 22 bits of ... */\n#define R_SPARC_WDISP16\t\t40\t/* PC relative 16 bit shifted */\n#define R_SPARC_WDISP19\t\t41\t/* PC relative 19 bit shifted */\n#define R_SPARC_GLOB_JMP\t42\t/* was part of v9 ABI but was removed */\n#define R_SPARC_7\t\t43\t/* Direct 7 bit */\n#define R_SPARC_5\t\t44\t/* Direct 5 bit */\n#define R_SPARC_6\t\t45\t/* Direct 6 bit */\n#define R_SPARC_DISP64\t\t46\t/* PC relative 64 bit */\n#define R_SPARC_PLT64\t\t47\t/* Direct 64 bit ref to PLT entry */\n#define R_SPARC_HIX22\t\t48\t/* High 22 bit complemented */\n#define R_SPARC_LOX10\t\t49\t/* Truncated 11 bit complemented */\n#define R_SPARC_H44\t\t50\t/* Direct high 12 of 44 bit */\n#define R_SPARC_M44\t\t51\t/* Direct mid 22 of 44 bit */\n#define R_SPARC_L44\t\t52\t/* Direct low 10 of 44 bit */\n#define R_SPARC_REGISTER\t53\t/* Global register usage */\n#define R_SPARC_UA64\t\t54\t/* Direct 64 bit unaligned */\n#define R_SPARC_UA16\t\t55\t/* Direct 16 bit unaligned */\n#define R_SPARC_TLS_GD_HI22\t56\n#define R_SPARC_TLS_GD_LO10\t57\n#define R_SPARC_TLS_GD_ADD\t58\n#define R_SPARC_TLS_GD_CALL\t59\n#define R_SPARC_TLS_LDM_HI22\t60\n#define R_SPARC_TLS_LDM_LO10\t61\n#define R_SPARC_TLS_LDM_ADD\t62\n#define R_SPARC_TLS_LDM_CALL\t63\n#define R_SPARC_TLS_LDO_HIX22\t64\n#define R_SPARC_TLS_LDO_LOX10\t65\n#define R_SPARC_TLS_LDO_ADD\t66\n#define R_SPARC_TLS_IE_HI22\t67\n#define R_SPARC_TLS_IE_LO10\t68\n#define R_SPARC_TLS_IE_LD\t69\n#define R_SPARC_TLS_IE_LDX\t70\n#define R_SPARC_TLS_IE_ADD\t71\n#define R_SPARC_TLS_LE_HIX22\t72\n#define R_SPARC_TLS_LE_LOX10\t73\n#define R_SPARC_TLS_DTPMOD32\t74\n#define R_SPARC_TLS_DTPMOD64\t75\n#define R_SPARC_TLS_DTPOFF32\t76\n#define R_SPARC_TLS_DTPOFF64\t77\n#define R_SPARC_TLS_TPOFF32\t78\n#define R_SPARC_TLS_TPOFF64\t79\n#define R_SPARC_GOTDATA_HIX22\t80\n#define R_SPARC_GOTDATA_LOX10\t81\n#define R_SPARC_GOTDATA_OP_HIX22\t82\n#define R_SPARC_GOTDATA_OP_LOX10\t83\n#define R_SPARC_GOTDATA_OP\t84\n#define R_SPARC_H34\t\t85\n#define R_SPARC_SIZE32\t\t86\n#define R_SPARC_SIZE64\t\t87\n#define R_SPARC_WDISP10\t\t88\n#define R_SPARC_JMP_IREL\t248\n#define R_SPARC_IRELATIVE\t249\n#define R_SPARC_GNU_VTINHERIT\t250\n#define R_SPARC_GNU_VTENTRY\t251\n#define R_SPARC_REV32\t\t252\n/* Keep this the last entry.  */\n#define R_SPARC_NUM\t\t253\n\n/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */\n\n#define DT_SPARC_REGISTER 0x70000001\n#define DT_SPARC_NUM\t2\n\n/* MIPS R3000 specific definitions.  */\n\n/* Legal values for e_flags field of Elf32_Ehdr.  */\n\n#define EF_MIPS_NOREORDER   1\t\t/* A .noreorder directive was used */\n#define EF_MIPS_PIC\t    2\t\t/* Contains PIC code */\n#define EF_MIPS_CPIC\t    4\t\t/* Uses PIC calling sequence */\n#define EF_MIPS_XGOT\t    8\n#define EF_MIPS_64BIT_WHIRL 16\n#define EF_MIPS_ABI2\t    32\n#define EF_MIPS_ABI_ON32    64\n#define EF_MIPS_ARCH\t    0xf0000000\t/* MIPS architecture level */\n\n/* Legal values for MIPS architecture level.  */\n\n#define EF_MIPS_ARCH_1\t    0x00000000\t/* -mips1 code.  */\n#define EF_MIPS_ARCH_2\t    0x10000000\t/* -mips2 code.  */\n#define EF_MIPS_ARCH_3\t    0x20000000\t/* -mips3 code.  */\n#define EF_MIPS_ARCH_4\t    0x30000000\t/* -mips4 code.  */\n#define EF_MIPS_ARCH_5\t    0x40000000\t/* -mips5 code.  */\n#define EF_MIPS_ARCH_32\t    0x60000000\t/* MIPS32 code.  */\n#define EF_MIPS_ARCH_64\t    0x70000000\t/* MIPS64 code.  */\n\n/* The following are non-official names and should not be used.  */\n\n#define E_MIPS_ARCH_1\t  0x00000000\t/* -mips1 code.  */\n#define E_MIPS_ARCH_2\t  0x10000000\t/* -mips2 code.  */\n#define E_MIPS_ARCH_3\t  0x20000000\t/* -mips3 code.  */\n#define E_MIPS_ARCH_4\t  0x30000000\t/* -mips4 code.  */\n#define E_MIPS_ARCH_5\t  0x40000000\t/* -mips5 code.  */\n#define E_MIPS_ARCH_32\t  0x60000000\t/* MIPS32 code.  */\n#define E_MIPS_ARCH_64\t  0x70000000\t/* MIPS64 code.  */\n\n/* Special section indices.  */\n\n#define SHN_MIPS_ACOMMON    0xff00\t/* Allocated common symbols */\n#define SHN_MIPS_TEXT\t    0xff01\t/* Allocated test symbols.  */\n#define SHN_MIPS_DATA\t    0xff02\t/* Allocated data symbols.  */\n#define SHN_MIPS_SCOMMON    0xff03\t/* Small common symbols */\n#define SHN_MIPS_SUNDEFINED 0xff04\t/* Small undefined symbols */\n\n/* Legal values for sh_type field of Elf32_Shdr.  */\n\n#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */\n#define SHT_MIPS_MSYM\t       0x70000001\n#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */\n#define SHT_MIPS_GPTAB\t       0x70000003 /* Global data area sizes */\n#define SHT_MIPS_UCODE\t       0x70000004 /* Reserved for SGI/MIPS compilers */\n#define SHT_MIPS_DEBUG\t       0x70000005 /* MIPS ECOFF debugging information*/\n#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */\n#define SHT_MIPS_PACKAGE       0x70000007\n#define SHT_MIPS_PACKSYM       0x70000008\n#define SHT_MIPS_RELD\t       0x70000009\n#define SHT_MIPS_IFACE         0x7000000b\n#define SHT_MIPS_CONTENT       0x7000000c\n#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */\n#define SHT_MIPS_SHDR\t       0x70000010\n#define SHT_MIPS_FDESC\t       0x70000011\n#define SHT_MIPS_EXTSYM\t       0x70000012\n#define SHT_MIPS_DENSE\t       0x70000013\n#define SHT_MIPS_PDESC\t       0x70000014\n#define SHT_MIPS_LOCSYM\t       0x70000015\n#define SHT_MIPS_AUXSYM\t       0x70000016\n#define SHT_MIPS_OPTSYM\t       0x70000017\n#define SHT_MIPS_LOCSTR\t       0x70000018\n#define SHT_MIPS_LINE\t       0x70000019\n#define SHT_MIPS_RFDESC\t       0x7000001a\n#define SHT_MIPS_DELTASYM      0x7000001b\n#define SHT_MIPS_DELTAINST     0x7000001c\n#define SHT_MIPS_DELTACLASS    0x7000001d\n#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */\n#define SHT_MIPS_DELTADECL     0x7000001f\n#define SHT_MIPS_SYMBOL_LIB    0x70000020\n#define SHT_MIPS_EVENTS\t       0x70000021 /* Event section.  */\n#define SHT_MIPS_TRANSLATE     0x70000022\n#define SHT_MIPS_PIXIE\t       0x70000023\n#define SHT_MIPS_XLATE\t       0x70000024\n#define SHT_MIPS_XLATE_DEBUG   0x70000025\n#define SHT_MIPS_WHIRL\t       0x70000026\n#define SHT_MIPS_EH_REGION     0x70000027\n#define SHT_MIPS_XLATE_OLD     0x70000028\n#define SHT_MIPS_PDR_EXCEPTION 0x70000029\n\n/* Legal values for sh_flags field of Elf32_Shdr.  */\n\n#define SHF_MIPS_GPREL\t 0x10000000\t/* Must be part of global data area */\n#define SHF_MIPS_MERGE\t 0x20000000\n#define SHF_MIPS_ADDR\t 0x40000000\n#define SHF_MIPS_STRINGS 0x80000000\n#define SHF_MIPS_NOSTRIP 0x08000000\n#define SHF_MIPS_LOCAL\t 0x04000000\n#define SHF_MIPS_NAMES\t 0x02000000\n#define SHF_MIPS_NODUPE\t 0x01000000\n\n\n/* Symbol tables.  */\n\n/* MIPS specific values for `st_other'.  */\n#define STO_MIPS_DEFAULT\t\t0x0\n#define STO_MIPS_INTERNAL\t\t0x1\n#define STO_MIPS_HIDDEN\t\t\t0x2\n#define STO_MIPS_PROTECTED\t\t0x3\n#define STO_MIPS_PLT\t\t\t0x8\n#define STO_MIPS_SC_ALIGN_UNUSED\t0xff\n\n/* MIPS specific values for `st_info'.  */\n#define STB_MIPS_SPLIT_COMMON\t\t13\n\n/* Entries found in sections of type SHT_MIPS_GPTAB.  */\n\ntypedef union\n{\n  struct\n    {\n      Elf32_Word gt_current_g_value;\t/* -G value used for compilation */\n      Elf32_Word gt_unused;\t\t/* Not used */\n    } gt_header;\t\t\t/* First entry in section */\n  struct\n    {\n      Elf32_Word gt_g_value;\t\t/* If this value were used for -G */\n      Elf32_Word gt_bytes;\t\t/* This many bytes would be used */\n    } gt_entry;\t\t\t\t/* Subsequent entries in section */\n} Elf32_gptab;\n\n/* Entry found in sections of type SHT_MIPS_REGINFO.  */\n\ntypedef struct\n{\n  Elf32_Word\tri_gprmask;\t\t/* General registers used */\n  Elf32_Word\tri_cprmask[4];\t\t/* Coprocessor registers used */\n  Elf32_Sword\tri_gp_value;\t\t/* $gp register value */\n} Elf32_RegInfo;\n\n/* Entries found in sections of type SHT_MIPS_OPTIONS.  */\n\ntypedef struct\n{\n  unsigned char kind;\t\t/* Determines interpretation of the\n\t\t\t\t   variable part of descriptor.  */\n  unsigned char size;\t\t/* Size of descriptor, including header.  */\n  Elf32_Section section;\t/* Section header index of section affected,\n\t\t\t\t   0 for global options.  */\n  Elf32_Word info;\t\t/* Kind-specific information.  */\n} Elf_Options;\n\n/* Values for `kind' field in Elf_Options.  */\n\n#define ODK_NULL\t0\t/* Undefined.  */\n#define ODK_REGINFO\t1\t/* Register usage information.  */\n#define ODK_EXCEPTIONS\t2\t/* Exception processing options.  */\n#define ODK_PAD\t\t3\t/* Section padding options.  */\n#define ODK_HWPATCH\t4\t/* Hardware workarounds performed */\n#define ODK_FILL\t5\t/* record the fill value used by the linker. */\n#define ODK_TAGS\t6\t/* reserve space for desktop tools to write. */\n#define ODK_HWAND\t7\t/* HW workarounds.  'AND' bits when merging. */\n#define ODK_HWOR\t8\t/* HW workarounds.  'OR' bits when merging.  */\n\n/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */\n\n#define OEX_FPU_MIN\t0x1f\t/* FPE's which MUST be enabled.  */\n#define OEX_FPU_MAX\t0x1f00\t/* FPE's which MAY be enabled.  */\n#define OEX_PAGE0\t0x10000\t/* page zero must be mapped.  */\n#define OEX_SMM\t\t0x20000\t/* Force sequential memory mode?  */\n#define OEX_FPDBUG\t0x40000\t/* Force floating point debug mode?  */\n#define OEX_PRECISEFP\tOEX_FPDBUG\n#define OEX_DISMISS\t0x80000\t/* Dismiss invalid address faults?  */\n\n#define OEX_FPU_INVAL\t0x10\n#define OEX_FPU_DIV0\t0x08\n#define OEX_FPU_OFLO\t0x04\n#define OEX_FPU_UFLO\t0x02\n#define OEX_FPU_INEX\t0x01\n\n/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */\n\n#define OHW_R4KEOP\t0x1\t/* R4000 end-of-page patch.  */\n#define OHW_R8KPFETCH\t0x2\t/* may need R8000 prefetch patch.  */\n#define OHW_R5KEOP\t0x4\t/* R5000 end-of-page patch.  */\n#define OHW_R5KCVTL\t0x8\t/* R5000 cvt.[ds].l bug.  clean=1.  */\n\n#define OPAD_PREFIX\t0x1\n#define OPAD_POSTFIX\t0x2\n#define OPAD_SYMBOL\t0x4\n\n/* Entry found in `.options' section.  */\n\ntypedef struct\n{\n  Elf32_Word hwp_flags1;\t/* Extra flags.  */\n  Elf32_Word hwp_flags2;\t/* Extra flags.  */\n} Elf_Options_Hw;\n\n/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */\n\n#define OHWA0_R4KEOP_CHECKED\t0x00000001\n#define OHWA1_R4KEOP_CLEAN\t0x00000002\n\n/* MIPS relocs.  */\n\n#define R_MIPS_NONE\t\t0\t/* No reloc */\n#define R_MIPS_16\t\t1\t/* Direct 16 bit */\n#define R_MIPS_32\t\t2\t/* Direct 32 bit */\n#define R_MIPS_REL32\t\t3\t/* PC relative 32 bit */\n#define R_MIPS_26\t\t4\t/* Direct 26 bit shifted */\n#define R_MIPS_HI16\t\t5\t/* High 16 bit */\n#define R_MIPS_LO16\t\t6\t/* Low 16 bit */\n#define R_MIPS_GPREL16\t\t7\t/* GP relative 16 bit */\n#define R_MIPS_LITERAL\t\t8\t/* 16 bit literal entry */\n#define R_MIPS_GOT16\t\t9\t/* 16 bit GOT entry */\n#define R_MIPS_PC16\t\t10\t/* PC relative 16 bit */\n#define R_MIPS_CALL16\t\t11\t/* 16 bit GOT entry for function */\n#define R_MIPS_GPREL32\t\t12\t/* GP relative 32 bit */\n\n#define R_MIPS_SHIFT5\t\t16\n#define R_MIPS_SHIFT6\t\t17\n#define R_MIPS_64\t\t18\n#define R_MIPS_GOT_DISP\t\t19\n#define R_MIPS_GOT_PAGE\t\t20\n#define R_MIPS_GOT_OFST\t\t21\n#define R_MIPS_GOT_HI16\t\t22\n#define R_MIPS_GOT_LO16\t\t23\n#define R_MIPS_SUB\t\t24\n#define R_MIPS_INSERT_A\t\t25\n#define R_MIPS_INSERT_B\t\t26\n#define R_MIPS_DELETE\t\t27\n#define R_MIPS_HIGHER\t\t28\n#define R_MIPS_HIGHEST\t\t29\n#define R_MIPS_CALL_HI16\t30\n#define R_MIPS_CALL_LO16\t31\n#define R_MIPS_SCN_DISP\t\t32\n#define R_MIPS_REL16\t\t33\n#define R_MIPS_ADD_IMMEDIATE\t34\n#define R_MIPS_PJUMP\t\t35\n#define R_MIPS_RELGOT\t\t36\n#define R_MIPS_JALR\t\t37\n#define R_MIPS_TLS_DTPMOD32\t38\t/* Module number 32 bit */\n#define R_MIPS_TLS_DTPREL32\t39\t/* Module-relative offset 32 bit */\n#define R_MIPS_TLS_DTPMOD64\t40\t/* Module number 64 bit */\n#define R_MIPS_TLS_DTPREL64\t41\t/* Module-relative offset 64 bit */\n#define R_MIPS_TLS_GD\t\t42\t/* 16 bit GOT offset for GD */\n#define R_MIPS_TLS_LDM\t\t43\t/* 16 bit GOT offset for LDM */\n#define R_MIPS_TLS_DTPREL_HI16\t44\t/* Module-relative offset, high 16 bits */\n#define R_MIPS_TLS_DTPREL_LO16\t45\t/* Module-relative offset, low 16 bits */\n#define R_MIPS_TLS_GOTTPREL\t46\t/* 16 bit GOT offset for IE */\n#define R_MIPS_TLS_TPREL32\t47\t/* TP-relative offset, 32 bit */\n#define R_MIPS_TLS_TPREL64\t48\t/* TP-relative offset, 64 bit */\n#define R_MIPS_TLS_TPREL_HI16\t49\t/* TP-relative offset, high 16 bits */\n#define R_MIPS_TLS_TPREL_LO16\t50\t/* TP-relative offset, low 16 bits */\n#define R_MIPS_GLOB_DAT\t\t51\n#define R_MIPS_COPY\t\t126\n#define R_MIPS_JUMP_SLOT        127\n/* Keep this the last entry.  */\n#define R_MIPS_NUM\t\t128\n\n/* Legal values for p_type field of Elf32_Phdr.  */\n\n#define PT_MIPS_REGINFO\t0x70000000\t/* Register usage information */\n#define PT_MIPS_RTPROC  0x70000001\t/* Runtime procedure table. */\n#define PT_MIPS_OPTIONS 0x70000002\n\n/* Special program header types.  */\n\n#define PF_MIPS_LOCAL\t0x10000000\n\n/* Legal values for d_tag field of Elf32_Dyn.  */\n\n#define DT_MIPS_RLD_VERSION  0x70000001\t/* Runtime linker interface version */\n#define DT_MIPS_TIME_STAMP   0x70000002\t/* Timestamp */\n#define DT_MIPS_ICHECKSUM    0x70000003\t/* Checksum */\n#define DT_MIPS_IVERSION     0x70000004\t/* Version string (string tbl index) */\n#define DT_MIPS_FLAGS\t     0x70000005\t/* Flags */\n#define DT_MIPS_BASE_ADDRESS 0x70000006\t/* Base address */\n#define DT_MIPS_MSYM\t     0x70000007\n#define DT_MIPS_CONFLICT     0x70000008\t/* Address of CONFLICT section */\n#define DT_MIPS_LIBLIST\t     0x70000009\t/* Address of LIBLIST section */\n#define DT_MIPS_LOCAL_GOTNO  0x7000000a\t/* Number of local GOT entries */\n#define DT_MIPS_CONFLICTNO   0x7000000b\t/* Number of CONFLICT entries */\n#define DT_MIPS_LIBLISTNO    0x70000010\t/* Number of LIBLIST entries */\n#define DT_MIPS_SYMTABNO     0x70000011\t/* Number of DYNSYM entries */\n#define DT_MIPS_UNREFEXTNO   0x70000012\t/* First external DYNSYM */\n#define DT_MIPS_GOTSYM\t     0x70000013\t/* First GOT entry in DYNSYM */\n#define DT_MIPS_HIPAGENO     0x70000014\t/* Number of GOT page table entries */\n#define DT_MIPS_RLD_MAP\t     0x70000016\t/* Address of run time loader map.  */\n#define DT_MIPS_DELTA_CLASS  0x70000017\t/* Delta C++ class definition.  */\n#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in\n\t\t\t\t\t\tDT_MIPS_DELTA_CLASS.  */\n#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */\n#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in\n\t\t\t\t\t\tDT_MIPS_DELTA_INSTANCE.  */\n#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */\n#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in\n\t\t\t\t\t     DT_MIPS_DELTA_RELOC.  */\n#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta\n\t\t\t\t\t   relocations refer to.  */\n#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in\n\t\t\t\t\t   DT_MIPS_DELTA_SYM.  */\n#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the\n\t\t\t\t\t     class declaration.  */\n#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in\n\t\t\t\t\t\tDT_MIPS_DELTA_CLASSSYM.  */\n#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */\n#define DT_MIPS_PIXIE_INIT   0x70000023\n#define DT_MIPS_SYMBOL_LIB   0x70000024\n#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025\n#define DT_MIPS_LOCAL_GOTIDX 0x70000026\n#define DT_MIPS_HIDDEN_GOTIDX 0x70000027\n#define DT_MIPS_PROTECTED_GOTIDX 0x70000028\n#define DT_MIPS_OPTIONS\t     0x70000029 /* Address of .options.  */\n#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */\n#define DT_MIPS_DYNSTR_ALIGN 0x7000002b\n#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */\n#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve\n\t\t\t\t\t\t    function stored in GOT.  */\n#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added\n\t\t\t\t\t   by rld on dlopen() calls.  */\n#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */\n#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */\n#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */\n/* The address of .got.plt in an executable using the new non-PIC ABI.  */\n#define DT_MIPS_PLTGOT\t     0x70000032\n/* The base of the PLT in an executable using the new non-PIC ABI if that\n   PLT is writable.  For a non-writable PLT, this is omitted or has a zero\n   value.  */\n#define DT_MIPS_RWPLT        0x70000034\n#define DT_MIPS_NUM\t     0x35\n\n/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */\n\n#define RHF_NONE\t\t   0\t\t/* No flags */\n#define RHF_QUICKSTART\t\t   (1 << 0)\t/* Use quickstart */\n#define RHF_NOTPOT\t\t   (1 << 1)\t/* Hash size not power of 2 */\n#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)\t/* Ignore LD_LIBRARY_PATH */\n#define RHF_NO_MOVE\t\t   (1 << 3)\n#define RHF_SGI_ONLY\t\t   (1 << 4)\n#define RHF_GUARANTEE_INIT\t   (1 << 5)\n#define RHF_DELTA_C_PLUS_PLUS\t   (1 << 6)\n#define RHF_GUARANTEE_START_INIT   (1 << 7)\n#define RHF_PIXIE\t\t   (1 << 8)\n#define RHF_DEFAULT_DELAY_LOAD\t   (1 << 9)\n#define RHF_REQUICKSTART\t   (1 << 10)\n#define RHF_REQUICKSTARTED\t   (1 << 11)\n#define RHF_CORD\t\t   (1 << 12)\n#define RHF_NO_UNRES_UNDEF\t   (1 << 13)\n#define RHF_RLD_ORDER_SAFE\t   (1 << 14)\n\n/* Entries found in sections of type SHT_MIPS_LIBLIST.  */\n\ntypedef struct\n{\n  Elf32_Word l_name;\t\t/* Name (string table index) */\n  Elf32_Word l_time_stamp;\t/* Timestamp */\n  Elf32_Word l_checksum;\t/* Checksum */\n  Elf32_Word l_version;\t\t/* Interface version */\n  Elf32_Word l_flags;\t\t/* Flags */\n} Elf32_Lib;\n\ntypedef struct\n{\n  Elf64_Word l_name;\t\t/* Name (string table index) */\n  Elf64_Word l_time_stamp;\t/* Timestamp */\n  Elf64_Word l_checksum;\t/* Checksum */\n  Elf64_Word l_version;\t\t/* Interface version */\n  Elf64_Word l_flags;\t\t/* Flags */\n} Elf64_Lib;\n\n\n/* Legal values for l_flags.  */\n\n#define LL_NONE\t\t  0\n#define LL_EXACT_MATCH\t  (1 << 0)\t/* Require exact match */\n#define LL_IGNORE_INT_VER (1 << 1)\t/* Ignore interface version */\n#define LL_REQUIRE_MINOR  (1 << 2)\n#define LL_EXPORTS\t  (1 << 3)\n#define LL_DELAY_LOAD\t  (1 << 4)\n#define LL_DELTA\t  (1 << 5)\n\n/* Entries found in sections of type SHT_MIPS_CONFLICT.  */\n\ntypedef Elf32_Addr Elf32_Conflict;\n\n\n/* HPPA specific definitions.  */\n\n/* Legal values for e_flags field of Elf32_Ehdr.  */\n\n#define EF_PARISC_TRAPNIL\t0x00010000 /* Trap nil pointer dereference.  */\n#define EF_PARISC_EXT\t\t0x00020000 /* Program uses arch. extensions. */\n#define EF_PARISC_LSB\t\t0x00040000 /* Program expects little endian. */\n#define EF_PARISC_WIDE\t\t0x00080000 /* Program expects wide mode.  */\n#define EF_PARISC_NO_KABP\t0x00100000 /* No kernel assisted branch\n\t\t\t\t\t      prediction.  */\n#define EF_PARISC_LAZYSWAP\t0x00400000 /* Allow lazy swapping.  */\n#define EF_PARISC_ARCH\t\t0x0000ffff /* Architecture version.  */\n\n/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */\n\n#define EFA_PARISC_1_0\t\t    0x020b /* PA-RISC 1.0 big-endian.  */\n#define EFA_PARISC_1_1\t\t    0x0210 /* PA-RISC 1.1 big-endian.  */\n#define EFA_PARISC_2_0\t\t    0x0214 /* PA-RISC 2.0 big-endian.  */\n\n/* Additional section indices.  */\n\n#define SHN_PARISC_ANSI_COMMON\t0xff00\t   /* Section for tentatively declared\n\t\t\t\t\t      symbols in ANSI C.  */\n#define SHN_PARISC_HUGE_COMMON\t0xff01\t   /* Common blocks in huge model.  */\n\n/* Legal values for sh_type field of Elf32_Shdr.  */\n\n#define SHT_PARISC_EXT\t\t0x70000000 /* Contains product specific ext. */\n#define SHT_PARISC_UNWIND\t0x70000001 /* Unwind information.  */\n#define SHT_PARISC_DOC\t\t0x70000002 /* Debug info for optimized code. */\n\n/* Legal values for sh_flags field of Elf32_Shdr.  */\n\n#define SHF_PARISC_SHORT\t0x20000000 /* Section with short addressing. */\n#define SHF_PARISC_HUGE\t\t0x40000000 /* Section far from gp.  */\n#define SHF_PARISC_SBP\t\t0x80000000 /* Static branch prediction code. */\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n\n#define STT_PARISC_MILLICODE\t13\t/* Millicode function entry point.  */\n\n#define STT_HP_OPAQUE\t\t(STT_LOOS + 0x1)\n#define STT_HP_STUB\t\t(STT_LOOS + 0x2)\n\n/* HPPA relocs.  */\n\n#define R_PARISC_NONE\t\t0\t/* No reloc.  */\n#define R_PARISC_DIR32\t\t1\t/* Direct 32-bit reference.  */\n#define R_PARISC_DIR21L\t\t2\t/* Left 21 bits of eff. address.  */\n#define R_PARISC_DIR17R\t\t3\t/* Right 17 bits of eff. address.  */\n#define R_PARISC_DIR17F\t\t4\t/* 17 bits of eff. address.  */\n#define R_PARISC_DIR14R\t\t6\t/* Right 14 bits of eff. address.  */\n#define R_PARISC_PCREL32\t9\t/* 32-bit rel. address.  */\n#define R_PARISC_PCREL21L\t10\t/* Left 21 bits of rel. address.  */\n#define R_PARISC_PCREL17R\t11\t/* Right 17 bits of rel. address.  */\n#define R_PARISC_PCREL17F\t12\t/* 17 bits of rel. address.  */\n#define R_PARISC_PCREL14R\t14\t/* Right 14 bits of rel. address.  */\n#define R_PARISC_DPREL21L\t18\t/* Left 21 bits of rel. address.  */\n#define R_PARISC_DPREL14R\t22\t/* Right 14 bits of rel. address.  */\n#define R_PARISC_GPREL21L\t26\t/* GP-relative, left 21 bits.  */\n#define R_PARISC_GPREL14R\t30\t/* GP-relative, right 14 bits.  */\n#define R_PARISC_LTOFF21L\t34\t/* LT-relative, left 21 bits.  */\n#define R_PARISC_LTOFF14R\t38\t/* LT-relative, right 14 bits.  */\n#define R_PARISC_SECREL32\t41\t/* 32 bits section rel. address.  */\n#define R_PARISC_SEGBASE\t48\t/* No relocation, set segment base.  */\n#define R_PARISC_SEGREL32\t49\t/* 32 bits segment rel. address.  */\n#define R_PARISC_PLTOFF21L\t50\t/* PLT rel. address, left 21 bits.  */\n#define R_PARISC_PLTOFF14R\t54\t/* PLT rel. address, right 14 bits.  */\n#define R_PARISC_LTOFF_FPTR32\t57\t/* 32 bits LT-rel. function pointer. */\n#define R_PARISC_LTOFF_FPTR21L\t58\t/* LT-rel. fct ptr, left 21 bits. */\n#define R_PARISC_LTOFF_FPTR14R\t62\t/* LT-rel. fct ptr, right 14 bits. */\n#define R_PARISC_FPTR64\t\t64\t/* 64 bits function address.  */\n#define R_PARISC_PLABEL32\t65\t/* 32 bits function address.  */\n#define R_PARISC_PLABEL21L\t66\t/* Left 21 bits of fdesc address.  */\n#define R_PARISC_PLABEL14R\t70\t/* Right 14 bits of fdesc address.  */\n#define R_PARISC_PCREL64\t72\t/* 64 bits PC-rel. address.  */\n#define R_PARISC_PCREL22F\t74\t/* 22 bits PC-rel. address.  */\n#define R_PARISC_PCREL14WR\t75\t/* PC-rel. address, right 14 bits.  */\n#define R_PARISC_PCREL14DR\t76\t/* PC rel. address, right 14 bits.  */\n#define R_PARISC_PCREL16F\t77\t/* 16 bits PC-rel. address.  */\n#define R_PARISC_PCREL16WF\t78\t/* 16 bits PC-rel. address.  */\n#define R_PARISC_PCREL16DF\t79\t/* 16 bits PC-rel. address.  */\n#define R_PARISC_DIR64\t\t80\t/* 64 bits of eff. address.  */\n#define R_PARISC_DIR14WR\t83\t/* 14 bits of eff. address.  */\n#define R_PARISC_DIR14DR\t84\t/* 14 bits of eff. address.  */\n#define R_PARISC_DIR16F\t\t85\t/* 16 bits of eff. address.  */\n#define R_PARISC_DIR16WF\t86\t/* 16 bits of eff. address.  */\n#define R_PARISC_DIR16DF\t87\t/* 16 bits of eff. address.  */\n#define R_PARISC_GPREL64\t88\t/* 64 bits of GP-rel. address.  */\n#define R_PARISC_GPREL14WR\t91\t/* GP-rel. address, right 14 bits.  */\n#define R_PARISC_GPREL14DR\t92\t/* GP-rel. address, right 14 bits.  */\n#define R_PARISC_GPREL16F\t93\t/* 16 bits GP-rel. address.  */\n#define R_PARISC_GPREL16WF\t94\t/* 16 bits GP-rel. address.  */\n#define R_PARISC_GPREL16DF\t95\t/* 16 bits GP-rel. address.  */\n#define R_PARISC_LTOFF64\t96\t/* 64 bits LT-rel. address.  */\n#define R_PARISC_LTOFF14WR\t99\t/* LT-rel. address, right 14 bits.  */\n#define R_PARISC_LTOFF14DR\t100\t/* LT-rel. address, right 14 bits.  */\n#define R_PARISC_LTOFF16F\t101\t/* 16 bits LT-rel. address.  */\n#define R_PARISC_LTOFF16WF\t102\t/* 16 bits LT-rel. address.  */\n#define R_PARISC_LTOFF16DF\t103\t/* 16 bits LT-rel. address.  */\n#define R_PARISC_SECREL64\t104\t/* 64 bits section rel. address.  */\n#define R_PARISC_SEGREL64\t112\t/* 64 bits segment rel. address.  */\n#define R_PARISC_PLTOFF14WR\t115\t/* PLT-rel. address, right 14 bits.  */\n#define R_PARISC_PLTOFF14DR\t116\t/* PLT-rel. address, right 14 bits.  */\n#define R_PARISC_PLTOFF16F\t117\t/* 16 bits LT-rel. address.  */\n#define R_PARISC_PLTOFF16WF\t118\t/* 16 bits PLT-rel. address.  */\n#define R_PARISC_PLTOFF16DF\t119\t/* 16 bits PLT-rel. address.  */\n#define R_PARISC_LTOFF_FPTR64\t120\t/* 64 bits LT-rel. function ptr.  */\n#define R_PARISC_LTOFF_FPTR14WR\t123\t/* LT-rel. fct. ptr., right 14 bits. */\n#define R_PARISC_LTOFF_FPTR14DR\t124\t/* LT-rel. fct. ptr., right 14 bits. */\n#define R_PARISC_LTOFF_FPTR16F\t125\t/* 16 bits LT-rel. function ptr.  */\n#define R_PARISC_LTOFF_FPTR16WF\t126\t/* 16 bits LT-rel. function ptr.  */\n#define R_PARISC_LTOFF_FPTR16DF\t127\t/* 16 bits LT-rel. function ptr.  */\n#define R_PARISC_LORESERVE\t128\n#define R_PARISC_COPY\t\t128\t/* Copy relocation.  */\n#define R_PARISC_IPLT\t\t129\t/* Dynamic reloc, imported PLT */\n#define R_PARISC_EPLT\t\t130\t/* Dynamic reloc, exported PLT */\n#define R_PARISC_TPREL32\t153\t/* 32 bits TP-rel. address.  */\n#define R_PARISC_TPREL21L\t154\t/* TP-rel. address, left 21 bits.  */\n#define R_PARISC_TPREL14R\t158\t/* TP-rel. address, right 14 bits.  */\n#define R_PARISC_LTOFF_TP21L\t162\t/* LT-TP-rel. address, left 21 bits. */\n#define R_PARISC_LTOFF_TP14R\t166\t/* LT-TP-rel. address, right 14 bits.*/\n#define R_PARISC_LTOFF_TP14F\t167\t/* 14 bits LT-TP-rel. address.  */\n#define R_PARISC_TPREL64\t216\t/* 64 bits TP-rel. address.  */\n#define R_PARISC_TPREL14WR\t219\t/* TP-rel. address, right 14 bits.  */\n#define R_PARISC_TPREL14DR\t220\t/* TP-rel. address, right 14 bits.  */\n#define R_PARISC_TPREL16F\t221\t/* 16 bits TP-rel. address.  */\n#define R_PARISC_TPREL16WF\t222\t/* 16 bits TP-rel. address.  */\n#define R_PARISC_TPREL16DF\t223\t/* 16 bits TP-rel. address.  */\n#define R_PARISC_LTOFF_TP64\t224\t/* 64 bits LT-TP-rel. address.  */\n#define R_PARISC_LTOFF_TP14WR\t227\t/* LT-TP-rel. address, right 14 bits.*/\n#define R_PARISC_LTOFF_TP14DR\t228\t/* LT-TP-rel. address, right 14 bits.*/\n#define R_PARISC_LTOFF_TP16F\t229\t/* 16 bits LT-TP-rel. address.  */\n#define R_PARISC_LTOFF_TP16WF\t230\t/* 16 bits LT-TP-rel. address.  */\n#define R_PARISC_LTOFF_TP16DF\t231\t/* 16 bits LT-TP-rel. address.  */\n#define R_PARISC_GNU_VTENTRY\t232\n#define R_PARISC_GNU_VTINHERIT\t233\n#define R_PARISC_TLS_GD21L\t234\t/* GD 21-bit left.  */\n#define R_PARISC_TLS_GD14R\t235\t/* GD 14-bit right.  */\n#define R_PARISC_TLS_GDCALL\t236\t/* GD call to __t_g_a.  */\n#define R_PARISC_TLS_LDM21L\t237\t/* LD module 21-bit left.  */\n#define R_PARISC_TLS_LDM14R\t238\t/* LD module 14-bit right.  */\n#define R_PARISC_TLS_LDMCALL\t239\t/* LD module call to __t_g_a.  */\n#define R_PARISC_TLS_LDO21L\t240\t/* LD offset 21-bit left.  */\n#define R_PARISC_TLS_LDO14R\t241\t/* LD offset 14-bit right.  */\n#define R_PARISC_TLS_DTPMOD32\t242\t/* DTP module 32-bit.  */\n#define R_PARISC_TLS_DTPMOD64\t243\t/* DTP module 64-bit.  */\n#define R_PARISC_TLS_DTPOFF32\t244\t/* DTP offset 32-bit.  */\n#define R_PARISC_TLS_DTPOFF64\t245\t/* DTP offset 32-bit.  */\n#define R_PARISC_TLS_LE21L\tR_PARISC_TPREL21L\n#define R_PARISC_TLS_LE14R\tR_PARISC_TPREL14R\n#define R_PARISC_TLS_IE21L\tR_PARISC_LTOFF_TP21L\n#define R_PARISC_TLS_IE14R\tR_PARISC_LTOFF_TP14R\n#define R_PARISC_TLS_TPREL32\tR_PARISC_TPREL32\n#define R_PARISC_TLS_TPREL64\tR_PARISC_TPREL64\n#define R_PARISC_HIRESERVE\t255\n\n/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */\n\n#define PT_HP_TLS\t\t(PT_LOOS + 0x0)\n#define PT_HP_CORE_NONE\t\t(PT_LOOS + 0x1)\n#define PT_HP_CORE_VERSION\t(PT_LOOS + 0x2)\n#define PT_HP_CORE_KERNEL\t(PT_LOOS + 0x3)\n#define PT_HP_CORE_COMM\t\t(PT_LOOS + 0x4)\n#define PT_HP_CORE_PROC\t\t(PT_LOOS + 0x5)\n#define PT_HP_CORE_LOADABLE\t(PT_LOOS + 0x6)\n#define PT_HP_CORE_STACK\t(PT_LOOS + 0x7)\n#define PT_HP_CORE_SHM\t\t(PT_LOOS + 0x8)\n#define PT_HP_CORE_MMF\t\t(PT_LOOS + 0x9)\n#define PT_HP_PARALLEL\t\t(PT_LOOS + 0x10)\n#define PT_HP_FASTBIND\t\t(PT_LOOS + 0x11)\n#define PT_HP_OPT_ANNOT\t\t(PT_LOOS + 0x12)\n#define PT_HP_HSL_ANNOT\t\t(PT_LOOS + 0x13)\n#define PT_HP_STACK\t\t(PT_LOOS + 0x14)\n\n#define PT_PARISC_ARCHEXT\t0x70000000\n#define PT_PARISC_UNWIND\t0x70000001\n\n/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */\n\n#define PF_PARISC_SBP\t\t0x08000000\n\n#define PF_HP_PAGE_SIZE\t\t0x00100000\n#define PF_HP_FAR_SHARED\t0x00200000\n#define PF_HP_NEAR_SHARED\t0x00400000\n#define PF_HP_CODE\t\t0x01000000\n#define PF_HP_MODIFY\t\t0x02000000\n#define PF_HP_LAZYSWAP\t\t0x04000000\n#define PF_HP_SBP\t\t0x08000000\n\n\n/* Alpha specific definitions.  */\n\n/* Legal values for e_flags field of Elf64_Ehdr.  */\n\n#define EF_ALPHA_32BIT\t\t1\t/* All addresses must be < 2GB.  */\n#define EF_ALPHA_CANRELAX\t2\t/* Relocations for relaxing exist.  */\n\n/* Legal values for sh_type field of Elf64_Shdr.  */\n\n/* These two are primarily concerned with ECOFF debugging info.  */\n#define SHT_ALPHA_DEBUG\t\t0x70000001\n#define SHT_ALPHA_REGINFO\t0x70000002\n\n/* Legal values for sh_flags field of Elf64_Shdr.  */\n\n#define SHF_ALPHA_GPREL\t\t0x10000000\n\n/* Legal values for st_other field of Elf64_Sym.  */\n#define STO_ALPHA_NOPV\t\t0x80\t/* No PV required.  */\n#define STO_ALPHA_STD_GPLOAD\t0x88\t/* PV only used for initial ldgp.  */\n\n/* Alpha relocs.  */\n\n#define R_ALPHA_NONE\t\t0\t/* No reloc */\n#define R_ALPHA_REFLONG\t\t1\t/* Direct 32 bit */\n#define R_ALPHA_REFQUAD\t\t2\t/* Direct 64 bit */\n#define R_ALPHA_GPREL32\t\t3\t/* GP relative 32 bit */\n#define R_ALPHA_LITERAL\t\t4\t/* GP relative 16 bit w/optimization */\n#define R_ALPHA_LITUSE\t\t5\t/* Optimization hint for LITERAL */\n#define R_ALPHA_GPDISP\t\t6\t/* Add displacement to GP */\n#define R_ALPHA_BRADDR\t\t7\t/* PC+4 relative 23 bit shifted */\n#define R_ALPHA_HINT\t\t8\t/* PC+4 relative 16 bit shifted */\n#define R_ALPHA_SREL16\t\t9\t/* PC relative 16 bit */\n#define R_ALPHA_SREL32\t\t10\t/* PC relative 32 bit */\n#define R_ALPHA_SREL64\t\t11\t/* PC relative 64 bit */\n#define R_ALPHA_GPRELHIGH\t17\t/* GP relative 32 bit, high 16 bits */\n#define R_ALPHA_GPRELLOW\t18\t/* GP relative 32 bit, low 16 bits */\n#define R_ALPHA_GPREL16\t\t19\t/* GP relative 16 bit */\n#define R_ALPHA_COPY\t\t24\t/* Copy symbol at runtime */\n#define R_ALPHA_GLOB_DAT\t25\t/* Create GOT entry */\n#define R_ALPHA_JMP_SLOT\t26\t/* Create PLT entry */\n#define R_ALPHA_RELATIVE\t27\t/* Adjust by program base */\n#define R_ALPHA_TLS_GD_HI\t28\n#define R_ALPHA_TLSGD\t\t29\n#define R_ALPHA_TLS_LDM\t\t30\n#define R_ALPHA_DTPMOD64\t31\n#define R_ALPHA_GOTDTPREL\t32\n#define R_ALPHA_DTPREL64\t33\n#define R_ALPHA_DTPRELHI\t34\n#define R_ALPHA_DTPRELLO\t35\n#define R_ALPHA_DTPREL16\t36\n#define R_ALPHA_GOTTPREL\t37\n#define R_ALPHA_TPREL64\t\t38\n#define R_ALPHA_TPRELHI\t\t39\n#define R_ALPHA_TPRELLO\t\t40\n#define R_ALPHA_TPREL16\t\t41\n/* Keep this the last entry.  */\n#define R_ALPHA_NUM\t\t46\n\n/* Magic values of the LITUSE relocation addend.  */\n#define LITUSE_ALPHA_ADDR\t0\n#define LITUSE_ALPHA_BASE\t1\n#define LITUSE_ALPHA_BYTOFF\t2\n#define LITUSE_ALPHA_JSR\t3\n#define LITUSE_ALPHA_TLS_GD\t4\n#define LITUSE_ALPHA_TLS_LDM\t5\n\n/* Legal values for d_tag of Elf64_Dyn.  */\n#define DT_ALPHA_PLTRO\t\t(DT_LOPROC + 0)\n#define DT_ALPHA_NUM\t\t1\n\n/* PowerPC specific declarations */\n\n/* Values for Elf32/64_Ehdr.e_flags.  */\n#define EF_PPC_EMB\t\t0x80000000\t/* PowerPC embedded flag */\n\n/* Cygnus local bits below */\n#define EF_PPC_RELOCATABLE\t0x00010000\t/* PowerPC -mrelocatable flag*/\n#define EF_PPC_RELOCATABLE_LIB\t0x00008000\t/* PowerPC -mrelocatable-lib\n\t\t\t\t\t\t   flag */\n\n/* PowerPC relocations defined by the ABIs */\n#define R_PPC_NONE\t\t0\n#define R_PPC_ADDR32\t\t1\t/* 32bit absolute address */\n#define R_PPC_ADDR24\t\t2\t/* 26bit address, 2 bits ignored.  */\n#define R_PPC_ADDR16\t\t3\t/* 16bit absolute address */\n#define R_PPC_ADDR16_LO\t\t4\t/* lower 16bit of absolute address */\n#define R_PPC_ADDR16_HI\t\t5\t/* high 16bit of absolute address */\n#define R_PPC_ADDR16_HA\t\t6\t/* adjusted high 16bit */\n#define R_PPC_ADDR14\t\t7\t/* 16bit address, 2 bits ignored */\n#define R_PPC_ADDR14_BRTAKEN\t8\n#define R_PPC_ADDR14_BRNTAKEN\t9\n#define R_PPC_REL24\t\t10\t/* PC relative 26 bit */\n#define R_PPC_REL14\t\t11\t/* PC relative 16 bit */\n#define R_PPC_REL14_BRTAKEN\t12\n#define R_PPC_REL14_BRNTAKEN\t13\n#define R_PPC_GOT16\t\t14\n#define R_PPC_GOT16_LO\t\t15\n#define R_PPC_GOT16_HI\t\t16\n#define R_PPC_GOT16_HA\t\t17\n#define R_PPC_PLTREL24\t\t18\n#define R_PPC_COPY\t\t19\n#define R_PPC_GLOB_DAT\t\t20\n#define R_PPC_JMP_SLOT\t\t21\n#define R_PPC_RELATIVE\t\t22\n#define R_PPC_LOCAL24PC\t\t23\n#define R_PPC_UADDR32\t\t24\n#define R_PPC_UADDR16\t\t25\n#define R_PPC_REL32\t\t26\n#define R_PPC_PLT32\t\t27\n#define R_PPC_PLTREL32\t\t28\n#define R_PPC_PLT16_LO\t\t29\n#define R_PPC_PLT16_HI\t\t30\n#define R_PPC_PLT16_HA\t\t31\n#define R_PPC_SDAREL16\t\t32\n#define R_PPC_SECTOFF\t\t33\n#define R_PPC_SECTOFF_LO\t34\n#define R_PPC_SECTOFF_HI\t35\n#define R_PPC_SECTOFF_HA\t36\n\n/* PowerPC relocations defined for the TLS access ABI.  */\n#define R_PPC_TLS\t\t67 /* none\t(sym+add)@tls */\n#define R_PPC_DTPMOD32\t\t68 /* word32\t(sym+add)@dtpmod */\n#define R_PPC_TPREL16\t\t69 /* half16*\t(sym+add)@tprel */\n#define R_PPC_TPREL16_LO\t70 /* half16\t(sym+add)@tprel@l */\n#define R_PPC_TPREL16_HI\t71 /* half16\t(sym+add)@tprel@h */\n#define R_PPC_TPREL16_HA\t72 /* half16\t(sym+add)@tprel@ha */\n#define R_PPC_TPREL32\t\t73 /* word32\t(sym+add)@tprel */\n#define R_PPC_DTPREL16\t\t74 /* half16*\t(sym+add)@dtprel */\n#define R_PPC_DTPREL16_LO\t75 /* half16\t(sym+add)@dtprel@l */\n#define R_PPC_DTPREL16_HI\t76 /* half16\t(sym+add)@dtprel@h */\n#define R_PPC_DTPREL16_HA\t77 /* half16\t(sym+add)@dtprel@ha */\n#define R_PPC_DTPREL32\t\t78 /* word32\t(sym+add)@dtprel */\n#define R_PPC_GOT_TLSGD16\t79 /* half16*\t(sym+add)@got@tlsgd */\n#define R_PPC_GOT_TLSGD16_LO\t80 /* half16\t(sym+add)@got@tlsgd@l */\n#define R_PPC_GOT_TLSGD16_HI\t81 /* half16\t(sym+add)@got@tlsgd@h */\n#define R_PPC_GOT_TLSGD16_HA\t82 /* half16\t(sym+add)@got@tlsgd@ha */\n#define R_PPC_GOT_TLSLD16\t83 /* half16*\t(sym+add)@got@tlsld */\n#define R_PPC_GOT_TLSLD16_LO\t84 /* half16\t(sym+add)@got@tlsld@l */\n#define R_PPC_GOT_TLSLD16_HI\t85 /* half16\t(sym+add)@got@tlsld@h */\n#define R_PPC_GOT_TLSLD16_HA\t86 /* half16\t(sym+add)@got@tlsld@ha */\n#define R_PPC_GOT_TPREL16\t87 /* half16*\t(sym+add)@got@tprel */\n#define R_PPC_GOT_TPREL16_LO\t88 /* half16\t(sym+add)@got@tprel@l */\n#define R_PPC_GOT_TPREL16_HI\t89 /* half16\t(sym+add)@got@tprel@h */\n#define R_PPC_GOT_TPREL16_HA\t90 /* half16\t(sym+add)@got@tprel@ha */\n#define R_PPC_GOT_DTPREL16\t91 /* half16*\t(sym+add)@got@dtprel */\n#define R_PPC_GOT_DTPREL16_LO\t92 /* half16*\t(sym+add)@got@dtprel@l */\n#define R_PPC_GOT_DTPREL16_HI\t93 /* half16*\t(sym+add)@got@dtprel@h */\n#define R_PPC_GOT_DTPREL16_HA\t94 /* half16*\t(sym+add)@got@dtprel@ha */\n\n/* The remaining relocs are from the Embedded ELF ABI, and are not\n   in the SVR4 ELF ABI.  */\n#define R_PPC_EMB_NADDR32\t101\n#define R_PPC_EMB_NADDR16\t102\n#define R_PPC_EMB_NADDR16_LO\t103\n#define R_PPC_EMB_NADDR16_HI\t104\n#define R_PPC_EMB_NADDR16_HA\t105\n#define R_PPC_EMB_SDAI16\t106\n#define R_PPC_EMB_SDA2I16\t107\n#define R_PPC_EMB_SDA2REL\t108\n#define R_PPC_EMB_SDA21\t\t109\t/* 16 bit offset in SDA */\n#define R_PPC_EMB_MRKREF\t110\n#define R_PPC_EMB_RELSEC16\t111\n#define R_PPC_EMB_RELST_LO\t112\n#define R_PPC_EMB_RELST_HI\t113\n#define R_PPC_EMB_RELST_HA\t114\n#define R_PPC_EMB_BIT_FLD\t115\n#define R_PPC_EMB_RELSDA\t116\t/* 16 bit relative offset in SDA */\n\n/* Diab tool relocations.  */\n#define R_PPC_DIAB_SDA21_LO\t180\t/* like EMB_SDA21, but lower 16 bit */\n#define R_PPC_DIAB_SDA21_HI\t181\t/* like EMB_SDA21, but high 16 bit */\n#define R_PPC_DIAB_SDA21_HA\t182\t/* like EMB_SDA21, adjusted high 16 */\n#define R_PPC_DIAB_RELSDA_LO\t183\t/* like EMB_RELSDA, but lower 16 bit */\n#define R_PPC_DIAB_RELSDA_HI\t184\t/* like EMB_RELSDA, but high 16 bit */\n#define R_PPC_DIAB_RELSDA_HA\t185\t/* like EMB_RELSDA, adjusted high 16 */\n\n/* GNU extension to support local ifunc.  */\n#define R_PPC_IRELATIVE\t\t248\n\n/* GNU relocs used in PIC code sequences.  */\n#define R_PPC_REL16\t\t249\t/* half16   (sym+add-.) */\n#define R_PPC_REL16_LO\t\t250\t/* half16   (sym+add-.)@l */\n#define R_PPC_REL16_HI\t\t251\t/* half16   (sym+add-.)@h */\n#define R_PPC_REL16_HA\t\t252\t/* half16   (sym+add-.)@ha */\n\n/* This is a phony reloc to handle any old fashioned TOC16 references\n   that may still be in object files.  */\n#define R_PPC_TOC16\t\t255\n\n/* PowerPC specific values for the Dyn d_tag field.  */\n#define DT_PPC_GOT\t\t(DT_LOPROC + 0)\n#define DT_PPC_NUM\t\t1\n\n/* PowerPC64 relocations defined by the ABIs */\n#define R_PPC64_NONE\t\tR_PPC_NONE\n#define R_PPC64_ADDR32\t\tR_PPC_ADDR32 /* 32bit absolute address */\n#define R_PPC64_ADDR24\t\tR_PPC_ADDR24 /* 26bit address, word aligned */\n#define R_PPC64_ADDR16\t\tR_PPC_ADDR16 /* 16bit absolute address */\n#define R_PPC64_ADDR16_LO\tR_PPC_ADDR16_LO\t/* lower 16bits of address */\n#define R_PPC64_ADDR16_HI\tR_PPC_ADDR16_HI\t/* high 16bits of address. */\n#define R_PPC64_ADDR16_HA\tR_PPC_ADDR16_HA /* adjusted high 16bits.  */\n#define R_PPC64_ADDR14\t\tR_PPC_ADDR14 /* 16bit address, word aligned */\n#define R_PPC64_ADDR14_BRTAKEN\tR_PPC_ADDR14_BRTAKEN\n#define R_PPC64_ADDR14_BRNTAKEN\tR_PPC_ADDR14_BRNTAKEN\n#define R_PPC64_REL24\t\tR_PPC_REL24 /* PC-rel. 26 bit, word aligned */\n#define R_PPC64_REL14\t\tR_PPC_REL14 /* PC relative 16 bit */\n#define R_PPC64_REL14_BRTAKEN\tR_PPC_REL14_BRTAKEN\n#define R_PPC64_REL14_BRNTAKEN\tR_PPC_REL14_BRNTAKEN\n#define R_PPC64_GOT16\t\tR_PPC_GOT16\n#define R_PPC64_GOT16_LO\tR_PPC_GOT16_LO\n#define R_PPC64_GOT16_HI\tR_PPC_GOT16_HI\n#define R_PPC64_GOT16_HA\tR_PPC_GOT16_HA\n\n#define R_PPC64_COPY\t\tR_PPC_COPY\n#define R_PPC64_GLOB_DAT\tR_PPC_GLOB_DAT\n#define R_PPC64_JMP_SLOT\tR_PPC_JMP_SLOT\n#define R_PPC64_RELATIVE\tR_PPC_RELATIVE\n\n#define R_PPC64_UADDR32\t\tR_PPC_UADDR32\n#define R_PPC64_UADDR16\t\tR_PPC_UADDR16\n#define R_PPC64_REL32\t\tR_PPC_REL32\n#define R_PPC64_PLT32\t\tR_PPC_PLT32\n#define R_PPC64_PLTREL32\tR_PPC_PLTREL32\n#define R_PPC64_PLT16_LO\tR_PPC_PLT16_LO\n#define R_PPC64_PLT16_HI\tR_PPC_PLT16_HI\n#define R_PPC64_PLT16_HA\tR_PPC_PLT16_HA\n\n#define R_PPC64_SECTOFF\t\tR_PPC_SECTOFF\n#define R_PPC64_SECTOFF_LO\tR_PPC_SECTOFF_LO\n#define R_PPC64_SECTOFF_HI\tR_PPC_SECTOFF_HI\n#define R_PPC64_SECTOFF_HA\tR_PPC_SECTOFF_HA\n#define R_PPC64_ADDR30\t\t37 /* word30 (S + A - P) >> 2 */\n#define R_PPC64_ADDR64\t\t38 /* doubleword64 S + A */\n#define R_PPC64_ADDR16_HIGHER\t39 /* half16 #higher(S + A) */\n#define R_PPC64_ADDR16_HIGHERA\t40 /* half16 #highera(S + A) */\n#define R_PPC64_ADDR16_HIGHEST\t41 /* half16 #highest(S + A) */\n#define R_PPC64_ADDR16_HIGHESTA\t42 /* half16 #highesta(S + A) */\n#define R_PPC64_UADDR64\t\t43 /* doubleword64 S + A */\n#define R_PPC64_REL64\t\t44 /* doubleword64 S + A - P */\n#define R_PPC64_PLT64\t\t45 /* doubleword64 L + A */\n#define R_PPC64_PLTREL64\t46 /* doubleword64 L + A - P */\n#define R_PPC64_TOC16\t\t47 /* half16* S + A - .TOC */\n#define R_PPC64_TOC16_LO\t48 /* half16 #lo(S + A - .TOC.) */\n#define R_PPC64_TOC16_HI\t49 /* half16 #hi(S + A - .TOC.) */\n#define R_PPC64_TOC16_HA\t50 /* half16 #ha(S + A - .TOC.) */\n#define R_PPC64_TOC\t\t51 /* doubleword64 .TOC */\n#define R_PPC64_PLTGOT16\t52 /* half16* M + A */\n#define R_PPC64_PLTGOT16_LO\t53 /* half16 #lo(M + A) */\n#define R_PPC64_PLTGOT16_HI\t54 /* half16 #hi(M + A) */\n#define R_PPC64_PLTGOT16_HA\t55 /* half16 #ha(M + A) */\n\n#define R_PPC64_ADDR16_DS\t56 /* half16ds* (S + A) >> 2 */\n#define R_PPC64_ADDR16_LO_DS\t57 /* half16ds  #lo(S + A) >> 2 */\n#define R_PPC64_GOT16_DS\t58 /* half16ds* (G + A) >> 2 */\n#define R_PPC64_GOT16_LO_DS\t59 /* half16ds  #lo(G + A) >> 2 */\n#define R_PPC64_PLT16_LO_DS\t60 /* half16ds  #lo(L + A) >> 2 */\n#define R_PPC64_SECTOFF_DS\t61 /* half16ds* (R + A) >> 2 */\n#define R_PPC64_SECTOFF_LO_DS\t62 /* half16ds  #lo(R + A) >> 2 */\n#define R_PPC64_TOC16_DS\t63 /* half16ds* (S + A - .TOC.) >> 2 */\n#define R_PPC64_TOC16_LO_DS\t64 /* half16ds  #lo(S + A - .TOC.) >> 2 */\n#define R_PPC64_PLTGOT16_DS\t65 /* half16ds* (M + A) >> 2 */\n#define R_PPC64_PLTGOT16_LO_DS\t66 /* half16ds  #lo(M + A) >> 2 */\n\n/* PowerPC64 relocations defined for the TLS access ABI.  */\n#define R_PPC64_TLS\t\t67 /* none\t(sym+add)@tls */\n#define R_PPC64_DTPMOD64\t68 /* doubleword64 (sym+add)@dtpmod */\n#define R_PPC64_TPREL16\t\t69 /* half16*\t(sym+add)@tprel */\n#define R_PPC64_TPREL16_LO\t70 /* half16\t(sym+add)@tprel@l */\n#define R_PPC64_TPREL16_HI\t71 /* half16\t(sym+add)@tprel@h */\n#define R_PPC64_TPREL16_HA\t72 /* half16\t(sym+add)@tprel@ha */\n#define R_PPC64_TPREL64\t\t73 /* doubleword64 (sym+add)@tprel */\n#define R_PPC64_DTPREL16\t74 /* half16*\t(sym+add)@dtprel */\n#define R_PPC64_DTPREL16_LO\t75 /* half16\t(sym+add)@dtprel@l */\n#define R_PPC64_DTPREL16_HI\t76 /* half16\t(sym+add)@dtprel@h */\n#define R_PPC64_DTPREL16_HA\t77 /* half16\t(sym+add)@dtprel@ha */\n#define R_PPC64_DTPREL64\t78 /* doubleword64 (sym+add)@dtprel */\n#define R_PPC64_GOT_TLSGD16\t79 /* half16*\t(sym+add)@got@tlsgd */\n#define R_PPC64_GOT_TLSGD16_LO\t80 /* half16\t(sym+add)@got@tlsgd@l */\n#define R_PPC64_GOT_TLSGD16_HI\t81 /* half16\t(sym+add)@got@tlsgd@h */\n#define R_PPC64_GOT_TLSGD16_HA\t82 /* half16\t(sym+add)@got@tlsgd@ha */\n#define R_PPC64_GOT_TLSLD16\t83 /* half16*\t(sym+add)@got@tlsld */\n#define R_PPC64_GOT_TLSLD16_LO\t84 /* half16\t(sym+add)@got@tlsld@l */\n#define R_PPC64_GOT_TLSLD16_HI\t85 /* half16\t(sym+add)@got@tlsld@h */\n#define R_PPC64_GOT_TLSLD16_HA\t86 /* half16\t(sym+add)@got@tlsld@ha */\n#define R_PPC64_GOT_TPREL16_DS\t87 /* half16ds*\t(sym+add)@got@tprel */\n#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */\n#define R_PPC64_GOT_TPREL16_HI\t89 /* half16\t(sym+add)@got@tprel@h */\n#define R_PPC64_GOT_TPREL16_HA\t90 /* half16\t(sym+add)@got@tprel@ha */\n#define R_PPC64_GOT_DTPREL16_DS\t91 /* half16ds*\t(sym+add)@got@dtprel */\n#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */\n#define R_PPC64_GOT_DTPREL16_HI\t93 /* half16\t(sym+add)@got@dtprel@h */\n#define R_PPC64_GOT_DTPREL16_HA\t94 /* half16\t(sym+add)@got@dtprel@ha */\n#define R_PPC64_TPREL16_DS\t95 /* half16ds*\t(sym+add)@tprel */\n#define R_PPC64_TPREL16_LO_DS\t96 /* half16ds\t(sym+add)@tprel@l */\n#define R_PPC64_TPREL16_HIGHER\t97 /* half16\t(sym+add)@tprel@higher */\n#define R_PPC64_TPREL16_HIGHERA\t98 /* half16\t(sym+add)@tprel@highera */\n#define R_PPC64_TPREL16_HIGHEST\t99 /* half16\t(sym+add)@tprel@highest */\n#define R_PPC64_TPREL16_HIGHESTA 100 /* half16\t(sym+add)@tprel@highesta */\n#define R_PPC64_DTPREL16_DS\t101 /* half16ds* (sym+add)@dtprel */\n#define R_PPC64_DTPREL16_LO_DS\t102 /* half16ds\t(sym+add)@dtprel@l */\n#define R_PPC64_DTPREL16_HIGHER\t103 /* half16\t(sym+add)@dtprel@higher */\n#define R_PPC64_DTPREL16_HIGHERA 104 /* half16\t(sym+add)@dtprel@highera */\n#define R_PPC64_DTPREL16_HIGHEST 105 /* half16\t(sym+add)@dtprel@highest */\n#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16\t(sym+add)@dtprel@highesta */\n\n/* GNU extension to support local ifunc.  */\n#define R_PPC64_JMP_IREL\t247\n#define R_PPC64_IRELATIVE\t248\n#define R_PPC64_REL16\t\t249\t/* half16   (sym+add-.) */\n#define R_PPC64_REL16_LO\t250\t/* half16   (sym+add-.)@l */\n#define R_PPC64_REL16_HI\t251\t/* half16   (sym+add-.)@h */\n#define R_PPC64_REL16_HA\t252\t/* half16   (sym+add-.)@ha */\n\n/* PowerPC64 specific values for the Dyn d_tag field.  */\n#define DT_PPC64_GLINK  (DT_LOPROC + 0)\n#define DT_PPC64_OPD\t(DT_LOPROC + 1)\n#define DT_PPC64_OPDSZ\t(DT_LOPROC + 2)\n#define DT_PPC64_NUM    3\n\n\n/* ARM specific declarations */\n\n/* Processor specific flags for the ELF header e_flags field.  */\n#define EF_ARM_RELEXEC\t\t0x01\n#define EF_ARM_HASENTRY\t\t0x02\n#define EF_ARM_INTERWORK\t0x04\n#define EF_ARM_APCS_26\t\t0x08\n#define EF_ARM_APCS_FLOAT\t0x10\n#define EF_ARM_PIC\t\t0x20\n#define EF_ARM_ALIGN8\t\t0x40 /* 8-bit structure alignment is in use */\n#define EF_ARM_NEW_ABI\t\t0x80\n#define EF_ARM_OLD_ABI\t\t0x100\n#define EF_ARM_SOFT_FLOAT\t0x200\n#define EF_ARM_VFP_FLOAT\t0x400\n#define EF_ARM_MAVERICK_FLOAT\t0x800\n\n#define EF_ARM_ABI_FLOAT_SOFT\t0x200   /* NB conflicts with EF_ARM_SOFT_FLOAT */\n#define EF_ARM_ABI_FLOAT_HARD\t0x400   /* NB conflicts with EF_ARM_VFP_FLOAT */\n\n\n/* Other constants defined in the ARM ELF spec. version B-01.  */\n/* NB. These conflict with values defined above.  */\n#define EF_ARM_SYMSARESORTED\t0x04\n#define EF_ARM_DYNSYMSUSESEGIDX\t0x08\n#define EF_ARM_MAPSYMSFIRST\t0x10\n#define EF_ARM_EABIMASK\t\t0XFF000000\n\n/* Constants defined in AAELF.  */\n#define EF_ARM_BE8\t    0x00800000\n#define EF_ARM_LE8\t    0x00400000\n\n#define EF_ARM_EABI_VERSION(flags)\t((flags) & EF_ARM_EABIMASK)\n#define EF_ARM_EABI_UNKNOWN\t0x00000000\n#define EF_ARM_EABI_VER1\t0x01000000\n#define EF_ARM_EABI_VER2\t0x02000000\n#define EF_ARM_EABI_VER3\t0x03000000\n#define EF_ARM_EABI_VER4\t0x04000000\n#define EF_ARM_EABI_VER5\t0x05000000\n\n/* Additional symbol types for Thumb.  */\n#define STT_ARM_TFUNC\t\tSTT_LOPROC /* A Thumb function.  */\n#define STT_ARM_16BIT\t\tSTT_HIPROC /* A Thumb label.  */\n\n/* ARM-specific values for sh_flags */\n#define SHF_ARM_ENTRYSECT\t0x10000000 /* Section contains an entry point */\n#define SHF_ARM_COMDEF\t\t0x80000000 /* Section may be multiply defined\n\t\t\t\t\t      in the input to a link step.  */\n\n/* ARM-specific program header flags */\n#define PF_ARM_SB\t\t0x10000000 /* Segment contains the location\n\t\t\t\t\t      addressed by the static base. */\n#define PF_ARM_PI\t\t0x20000000 /* Position-independent segment.  */\n#define PF_ARM_ABS\t\t0x40000000 /* Absolute segment.  */\n\n/* Processor specific values for the Phdr p_type field.  */\n#define PT_ARM_EXIDX\t\t(PT_LOPROC + 1)\t/* ARM unwind segment.  */\n\n/* Processor specific values for the Shdr sh_type field.  */\n#define SHT_ARM_EXIDX\t\t(SHT_LOPROC + 1) /* ARM unwind section.  */\n#define SHT_ARM_PREEMPTMAP\t(SHT_LOPROC + 2) /* Preemption details.  */\n#define SHT_ARM_ATTRIBUTES\t(SHT_LOPROC + 3) /* ARM attributes section.  */\n\n\n/* AArch64 relocs.  */\n\n#define R_AARCH64_NONE            0\t/* No relocation.  */\n#define R_AARCH64_ABS64         257\t/* Direct 64 bit. */\n#define R_AARCH64_ABS32         258\t/* Direct 32 bit.  */\n#define R_AARCH64_ABS16         259\t/* Direct 16-bit.  */\n#define R_AARCH64_PREL64        260\t/* PC-relative 64-bit.  */\n#define R_AARCH64_PREL32        261\t/* PC-relative 32-bit.  */\n#define R_AARCH64_PREL16        262\t/* PC-relative 16-bit.  */\n#define R_AARCH64_MOVW_UABS_G0  263\t/* Dir. MOVZ imm. from bits 15:0.  */\n#define R_AARCH64_MOVW_UABS_G0_NC 264\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_UABS_G1  265\t/* Dir. MOVZ imm. from bits 31:16.  */\n#define R_AARCH64_MOVW_UABS_G1_NC 266\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_UABS_G2  267\t/* Dir. MOVZ imm. from bits 47:32.  */\n#define R_AARCH64_MOVW_UABS_G2_NC 268\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_UABS_G3  269\t/* Dir. MOV{K,Z} imm. from 63:48.  */\n#define R_AARCH64_MOVW_SABS_G0  270\t/* Dir. MOV{N,Z} imm. from 15:0.  */\n#define R_AARCH64_MOVW_SABS_G1  271\t/* Dir. MOV{N,Z} imm. from 31:16.  */\n#define R_AARCH64_MOVW_SABS_G2  272\t/* Dir. MOV{N,Z} imm. from 47:32.  */\n#define R_AARCH64_LD_PREL_LO19  273\t/* PC-rel. LD imm. from bits 20:2.  */\n#define R_AARCH64_ADR_PREL_LO21 274\t/* PC-rel. ADR imm. from bits 20:0.  */\n#define R_AARCH64_ADR_PREL_PG_HI21 275\t/* Page-rel. ADRP imm. from 32:12.  */\n#define R_AARCH64_ADR_PREL_PG_HI21_NC 276\t/* Likewise; no overflow check.  */\n#define R_AARCH64_ADD_ABS_LO12_NC 277\t/* Dir. ADD imm. from bits 11:0.  */\n#define R_AARCH64_LDST8_ABS_LO12_NC 278\t/* Likewise for LD/ST; no check. */\n#define R_AARCH64_TSTBR14       279\t/* PC-rel. TBZ/TBNZ imm. from 15:2.  */\n#define R_AARCH64_CONDBR19      280\t/* PC-rel. cond. br. imm. from 20:2. */\n#define R_AARCH64_JUMP26        282\t/* PC-rel. B imm. from bits 27:2.  */\n#define R_AARCH64_CALL26        283\t/* Likewise for CALL.  */\n#define R_AARCH64_LDST16_ABS_LO12_NC 284\t/* Dir. ADD imm. from bits 11:1.  */\n#define R_AARCH64_LDST32_ABS_LO12_NC 285\t/* Likewise for bits 11:2.  */\n#define R_AARCH64_LDST64_ABS_LO12_NC 286\t/* Likewise for bits 11:3.  */\n#define R_AARCH64_MOVW_PREL_G0  287\t/* PC-rel. MOV{N,Z} imm. from 15:0.  */\n#define R_AARCH64_MOVW_PREL_G0_NC 288\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_PREL_G1  289\t/* PC-rel. MOV{N,Z} imm. from 31:16. */\n#define R_AARCH64_MOVW_PREL_G1_NC 290\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_PREL_G2  291\t/* PC-rel. MOV{N,Z} imm. from 47:32. */\n#define R_AARCH64_MOVW_PREL_G2_NC 292\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_PREL_G3  293\t/* PC-rel. MOV{N,Z} imm. from 63:48. */\n#define R_AARCH64_LDST128_ABS_LO12_NC 299\t/* Dir. ADD imm. from bits 11:4.  */\n#define R_AARCH64_MOVW_GOTOFF_G0 300\t/* GOT-rel. off. MOV{N,Z} imm. 15:0. */\n#define R_AARCH64_MOVW_GOTOFF_G0_NC 301\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_GOTOFF_G1 302\t/* GOT-rel. o. MOV{N,Z} imm. 31:16.  */\n#define R_AARCH64_MOVW_GOTOFF_G1_NC 303\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_GOTOFF_G2 304\t/* GOT-rel. o. MOV{N,Z} imm. 47:32.  */\n#define R_AARCH64_MOVW_GOTOFF_G2_NC 305\t/* Likewise for MOVK; no check.  */\n#define R_AARCH64_MOVW_GOTOFF_G3 306\t/* GOT-rel. o. MOV{N,Z} imm. 63:48.  */\n#define R_AARCH64_GOTREL64      307\t/* GOT-relative 64-bit.  */\n#define R_AARCH64_GOTREL32      308\t/* GOT-relative 32-bit.  */\n#define R_AARCH64_GOT_LD_PREL19 309\t/* PC-rel. GOT off. load imm. 20:2.  */\n#define R_AARCH64_LD64_GOTOFF_LO15 310\t/* GOT-rel. off. LD/ST imm. 14:3.  */\n#define R_AARCH64_ADR_GOT_PAGE  311\t/* P-page-rel. GOT off. ADRP 32:12.  */\n#define R_AARCH64_LD64_GOT_LO12_NC 312\t/* Dir. GOT off. LD/ST imm. 11:3.  */\n#define R_AARCH64_LD64_GOTPAGE_LO15 313\t/* GOT-page-rel. GOT off. LD/ST 14:3 */\n#define R_AARCH64_TLSGD_ADR_PREL21 512\t/* PC-relative ADR imm. 20:0.  */\n#define R_AARCH64_TLSGD_ADR_PAGE21 513\t/* page-rel. ADRP imm. 32:12.  */\n#define R_AARCH64_TLSGD_ADD_LO12_NC 514\t/* direct ADD imm. from 11:0.  */\n#define R_AARCH64_TLSGD_MOVW_G1 515\t/* GOT-rel. MOV{N,Z} 31:16.  */\n#define R_AARCH64_TLSGD_MOVW_G0_NC 516\t/* GOT-rel. MOVK imm. 15:0.  */\n#define R_AARCH64_TLSLD_ADR_PREL21 517\t/* Like 512; local dynamic model.  */\n#define R_AARCH64_TLSLD_ADR_PAGE21 518\t/* Like 513; local dynamic model.  */\n#define R_AARCH64_TLSLD_ADD_LO12_NC 519\t/* Like 514; local dynamic model.  */\n#define R_AARCH64_TLSLD_MOVW_G1 520\t/* Like 515; local dynamic model.  */\n#define R_AARCH64_TLSLD_MOVW_G0_NC 521\t/* Like 516; local dynamic model.  */\n#define R_AARCH64_TLSLD_LD_PREL19 522\t/* TLS PC-rel. load imm. 20:2.  */\n#define R_AARCH64_TLSLD_MOVW_DTPREL_G2 523\t/* TLS DTP-rel. MOV{N,Z} 47:32.  */\n#define R_AARCH64_TLSLD_MOVW_DTPREL_G1 524\t/* TLS DTP-rel. MOV{N,Z} 31:16.  */\n#define R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC 525\t/* Likewise; MOVK; no check.  */\n#define R_AARCH64_TLSLD_MOVW_DTPREL_G0 526\t/* TLS DTP-rel. MOV{N,Z} 15:0.  */\n#define R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC 527\t/* Likewise; MOVK; no check.  */\n#define R_AARCH64_TLSLD_ADD_DTPREL_HI12 528\t/* DTP-rel. ADD imm. from 23:12. */\n#define R_AARCH64_TLSLD_ADD_DTPREL_LO12 529\t/* DTP-rel. ADD imm. from 11:0.  */\n#define R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC 530\t/* Likewise; no ovfl. check.  */\n#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12 531\t/* DTP-rel. LD/ST imm. 11:0.  */\n#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC 532\t/* Likewise; no check.  */\n#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12 533\t/* DTP-rel. LD/ST imm. 11:1.  */\n#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC 534\t/* Likewise; no check.  */\n#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12 535\t/* DTP-rel. LD/ST imm. 11:2.  */\n#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC 536\t/* Likewise; no check.  */\n#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12 537\t/* DTP-rel. LD/ST imm. 11:3.  */\n#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC 538\t/* Likewise; no check.  */\n#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 539\t/* GOT-rel. MOV{N,Z} 31:16.  */\n#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC 540\t/* GOT-rel. MOVK 15:0.  */\n#define R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 541\t/* Page-rel. ADRP 32:12.  */\n#define R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC 542\t/* Direct LD off. 11:3.  */\n#define R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 543\t/* PC-rel. load imm. 20:2.  */\n#define R_AARCH64_TLSLE_MOVW_TPREL_G2 544\t/* TLS TP-rel. MOV{N,Z} 47:32.  */\n#define R_AARCH64_TLSLE_MOVW_TPREL_G1 545\t/* TLS TP-rel. MOV{N,Z} 31:16.  */\n#define R_AARCH64_TLSLE_MOVW_TPREL_G1_NC 546\t/* Likewise; MOVK; no check.  */\n#define R_AARCH64_TLSLE_MOVW_TPREL_G0 547\t/* TLS TP-rel. MOV{N,Z} 15:0.  */\n#define R_AARCH64_TLSLE_MOVW_TPREL_G0_NC 548\t/* Likewise; MOVK; no check.  */\n#define R_AARCH64_TLSLE_ADD_TPREL_HI12 549\t/* TP-rel. ADD imm. 23:12.  */\n#define R_AARCH64_TLSLE_ADD_TPREL_LO12 550\t/* TP-rel. ADD imm. 11:0.  */\n#define R_AARCH64_TLSLE_ADD_TPREL_LO12_NC 551\t/* Likewise; no ovfl. check.  */\n#define R_AARCH64_TLSLE_LDST8_TPREL_LO12 552\t/* TP-rel. LD/ST off. 11:0.  */\n#define R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC 553\t/* Likewise; no ovfl. check. */\n#define R_AARCH64_TLSLE_LDST16_TPREL_LO12 554\t/* TP-rel. LD/ST off. 11:1.  */\n#define R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC 555\t/* Likewise; no check.  */\n#define R_AARCH64_TLSLE_LDST32_TPREL_LO12 556\t/* TP-rel. LD/ST off. 11:2.  */\n#define R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC 557\t/* Likewise; no check.  */\n#define R_AARCH64_TLSLE_LDST64_TPREL_LO12 558\t/* TP-rel. LD/ST off. 11:3.  */\n#define R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC 559\t/* Likewise; no check.  */\n#define R_AARCH64_TLSDESC_LD_PREL19 560\t/* PC-rel. load immediate 20:2.  */\n#define R_AARCH64_TLSDESC_ADR_PREL21 561\t/* PC-rel. ADR immediate 20:0.  */\n#define R_AARCH64_TLSDESC_ADR_PAGE21 562\t/* Page-rel. ADRP imm. 32:12.  */\n#define R_AARCH64_TLSDESC_LD64_LO12 563\t/* Direct LD off. from 11:3.  */\n#define R_AARCH64_TLSDESC_ADD_LO12 564\t/* Direct ADD imm. from 11:0.  */\n#define R_AARCH64_TLSDESC_OFF_G1 565\t/* GOT-rel. MOV{N,Z} imm. 31:16.  */\n#define R_AARCH64_TLSDESC_OFF_G0_NC 566\t/* GOT-rel. MOVK imm. 15:0; no ck.  */\n#define R_AARCH64_TLSDESC_LDR   567\t/* Relax LDR.  */\n#define R_AARCH64_TLSDESC_ADD   568\t/* Relax ADD.  */\n#define R_AARCH64_TLSDESC_CALL  569\t/* Relax BLR.  */\n#define R_AARCH64_TLSLE_LDST128_TPREL_LO12 570\t/* TP-rel. LD/ST off. 11:4.  */\n#define R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC 571\t/* Likewise; no check.  */\n#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12 572\t/* DTP-rel. LD/ST imm. 11:4. */\n#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC 573\t/* Likewise; no check.  */\n#define R_AARCH64_COPY         1024\t/* Copy symbol at runtime.  */\n#define R_AARCH64_GLOB_DAT     1025\t/* Create GOT entry.  */\n#define R_AARCH64_JUMP_SLOT    1026\t/* Create PLT entry.  */\n#define R_AARCH64_RELATIVE     1027\t/* Adjust by program base.  */\n#define R_AARCH64_TLS_DTPMOD64 1028\t/* Module number, 64 bit.  */\n#define R_AARCH64_TLS_DTPREL64 1029\t/* Module-relative offset, 64 bit.  */\n#define R_AARCH64_TLS_TPREL64  1030\t/* TP-relative offset, 64 bit.  */\n#define R_AARCH64_TLSDESC      1031\t/* TLS Descriptor.  */\n#define R_AARCH64_IRELATIVE    1032\t/* STT_GNU_IFUNC relocation.  */\n/* Keep this the last entry.  */\n#define R_AARCH64_NUM          1033\n\n/* ARM relocs.  */\n\n#define R_ARM_NONE\t\t0\t/* No reloc */\n#define R_ARM_PC24\t\t1\t/* PC relative 26 bit branch */\n#define R_ARM_ABS32\t\t2\t/* Direct 32 bit  */\n#define R_ARM_REL32\t\t3\t/* PC relative 32 bit */\n#define R_ARM_PC13\t\t4\n#define R_ARM_ABS16\t\t5\t/* Direct 16 bit */\n#define R_ARM_ABS12\t\t6\t/* Direct 12 bit */\n#define R_ARM_THM_ABS5\t\t7\n#define R_ARM_ABS8\t\t8\t/* Direct 8 bit */\n#define R_ARM_SBREL32\t\t9\n#define R_ARM_THM_PC22\t\t10\n#define R_ARM_THM_PC8\t\t11\n#define R_ARM_AMP_VCALL9\t12\n#define R_ARM_SWI24\t\t13\t/* Obsolete static relocation.  */\n#define R_ARM_TLS_DESC\t\t13      /* Dynamic relocation.  */\n#define R_ARM_THM_SWI8\t\t14\n#define R_ARM_XPC25\t\t15\n#define R_ARM_THM_XPC22\t\t16\n#define R_ARM_TLS_DTPMOD32\t17\t/* ID of module containing symbol */\n#define R_ARM_TLS_DTPOFF32\t18\t/* Offset in TLS block */\n#define R_ARM_TLS_TPOFF32\t19\t/* Offset in static TLS block */\n#define R_ARM_COPY\t\t20\t/* Copy symbol at runtime */\n#define R_ARM_GLOB_DAT\t\t21\t/* Create GOT entry */\n#define R_ARM_JUMP_SLOT\t\t22\t/* Create PLT entry */\n#define R_ARM_RELATIVE\t\t23\t/* Adjust by program base */\n#define R_ARM_GOTOFF\t\t24\t/* 32 bit offset to GOT */\n#define R_ARM_GOTPC\t\t25\t/* 32 bit PC relative offset to GOT */\n#define R_ARM_GOT32\t\t26\t/* 32 bit GOT entry */\n#define R_ARM_PLT32\t\t27\t/* 32 bit PLT address */\n#define R_ARM_CALL\t\t28\n#define R_ARM_JUMP24\t\t29\n#define R_ARM_THM_JUMP24\t30\n#define R_ARM_BASE_ABS  31  /* Adjust by program base.  */\n#define R_ARM_ALU_PCREL_7_0\t32\n#define R_ARM_ALU_PCREL_15_8\t33\n#define R_ARM_ALU_PCREL_23_15\t34\n#define R_ARM_LDR_SBREL_11_0\t35\n#define R_ARM_ALU_SBREL_19_12\t36\n#define R_ARM_ALU_SBREL_27_20\t37\n#define R_ARM_TARGET1 38\n#define R_ARM_SBREL31 39  /* Program base relative.  */\n#define R_ARM_V4BX\t\t40\n#define R_ARM_TARGET2   41\n#define R_ARM_PREL31\t\t42\n#define R_ARM_MOVW_ABS_NC\t43\n#define R_ARM_MOVT_ABS\t\t 44\n#define R_ARM_MOVW_PREL_NC  45\t/* PC relative 16-bit (MOVW).  */\n#define R_ARM_MOVT_PREL 46  /* PC relative (MOVT).  */\n#define R_ARM_THM_MOVW_ABS_NC\t47\n#define R_ARM_THM_MOVT_ABS\t48\n/* Values from 49 to 89 are not yet used/handled by tcc. */\n#define R_ARM_TLS_GOTDESC\t90\n#define R_ARM_TLS_CALL\t\t91\n#define R_ARM_TLS_DESCSEQ\t92\n#define R_ARM_THM_TLS_CALL\t93\n#define R_ARM_GOT_PREL\t\t96\n#define R_ARM_GNU_VTENTRY\t100\n#define R_ARM_GNU_VTINHERIT\t101\n#define R_ARM_THM_PC11\t\t102\t/* thumb unconditional branch */\n#define R_ARM_THM_PC9\t\t103\t/* thumb conditional branch */\n#define R_ARM_TLS_GD32\t\t104\t/* PC-rel 32 bit for global dynamic\n\t\t\t\t\t   thread local data */\n#define R_ARM_TLS_LDM32\t\t105\t/* PC-rel 32 bit for local dynamic\n\t\t\t\t\t   thread local data */\n#define R_ARM_TLS_LDO32\t\t106\t/* 32 bit offset relative to TLS\n\t\t\t\t\t   block */\n#define R_ARM_TLS_IE32\t\t107\t/* PC-rel 32 bit for GOT entry of\n\t\t\t\t\t   static TLS block offset */\n#define R_ARM_TLS_LE32\t\t108\t/* 32 bit offset relative to static\n\t\t\t\t\t   TLS block */\n#define\tR_ARM_THM_TLS_DESCSEQ\t129\n#define R_ARM_IRELATIVE\t\t160\n#define R_ARM_RXPC25\t\t249\n#define R_ARM_RSBREL32\t\t250\n#define R_ARM_THM_RPC22\t\t251\n#define R_ARM_RREL32\t\t252\n#define R_ARM_RABS22\t\t253\n#define R_ARM_RPC24\t\t254\n#define R_ARM_RBASE\t\t255\n/* Keep this the last entry.  */\n#define R_ARM_NUM\t\t256\n\n/* TMS320C67xx specific declarations */\n\n/* XXX: no ELF standard yet*/\n\n/* TMS320C67xx relocs. */\n#define R_C60_32       1\n#define R_C60_GOT32     3               /* 32 bit GOT entry */\n#define R_C60_PLT32     4               /* 32 bit PLT address */\n#define R_C60_COPY      5               /* Copy symbol at runtime */\n#define R_C60_GLOB_DAT  6               /* Create GOT entry */\n#define R_C60_JMP_SLOT  7               /* Create PLT entry */\n#define R_C60_RELATIVE  8               /* Adjust by program base */\n#define R_C60_GOTOFF    9               /* 32 bit offset to GOT */\n#define R_C60_GOTPC     10              /* 32 bit PC relative offset to GOT */\n\n#define R_C60LO16      0x54       /* low 16 bit MVKL embedded */\n#define R_C60HI16      0x55       /* high 16 bit MVKH embedded */\n/* Keep this the last entry.  */\n#define R_C60_NUM      0x56\n\n/* IA-64 specific declarations.  */\n\n/* Processor specific flags for the Ehdr e_flags field.  */\n#define EF_IA_64_MASKOS\t\t0x0000000f\t/* os-specific flags */\n#define EF_IA_64_ABI64\t\t0x00000010\t/* 64-bit ABI */\n#define EF_IA_64_ARCH\t\t0xff000000\t/* arch. version mask */\n\n/* Processor specific values for the Phdr p_type field.  */\n#define PT_IA_64_ARCHEXT\t(PT_LOPROC + 0)\t/* arch extension bits */\n#define PT_IA_64_UNWIND\t\t(PT_LOPROC + 1)\t/* ia64 unwind bits */\n#define PT_IA_64_HP_OPT_ANOT\t(PT_LOOS + 0x12)\n#define PT_IA_64_HP_HSL_ANOT\t(PT_LOOS + 0x13)\n#define PT_IA_64_HP_STACK\t(PT_LOOS + 0x14)\n\n/* Processor specific flags for the Phdr p_flags field.  */\n#define PF_IA_64_NORECOV\t0x80000000\t/* spec insns w/o recovery */\n\n/* Processor specific values for the Shdr sh_type field.  */\n#define SHT_IA_64_EXT\t\t(SHT_LOPROC + 0) /* extension bits */\n#define SHT_IA_64_UNWIND\t(SHT_LOPROC + 1) /* unwind bits */\n\n/* Processor specific flags for the Shdr sh_flags field.  */\n#define SHF_IA_64_SHORT\t\t0x10000000\t/* section near gp */\n#define SHF_IA_64_NORECOV\t0x20000000\t/* spec insns w/o recovery */\n\n/* Processor specific values for the Dyn d_tag field.  */\n#define DT_IA_64_PLT_RESERVE\t(DT_LOPROC + 0)\n#define DT_IA_64_NUM\t\t1\n\n/* IA-64 relocations.  */\n#define R_IA64_NONE\t\t0x00\t/* none */\n#define R_IA64_IMM14\t\t0x21\t/* symbol + addend, add imm14 */\n#define R_IA64_IMM22\t\t0x22\t/* symbol + addend, add imm22 */\n#define R_IA64_IMM64\t\t0x23\t/* symbol + addend, mov imm64 */\n#define R_IA64_DIR32MSB\t\t0x24\t/* symbol + addend, data4 MSB */\n#define R_IA64_DIR32LSB\t\t0x25\t/* symbol + addend, data4 LSB */\n#define R_IA64_DIR64MSB\t\t0x26\t/* symbol + addend, data8 MSB */\n#define R_IA64_DIR64LSB\t\t0x27\t/* symbol + addend, data8 LSB */\n#define R_IA64_GPREL22\t\t0x2a\t/* @gprel(sym + add), add imm22 */\n#define R_IA64_GPREL64I\t\t0x2b\t/* @gprel(sym + add), mov imm64 */\n#define R_IA64_GPREL32MSB\t0x2c\t/* @gprel(sym + add), data4 MSB */\n#define R_IA64_GPREL32LSB\t0x2d\t/* @gprel(sym + add), data4 LSB */\n#define R_IA64_GPREL64MSB\t0x2e\t/* @gprel(sym + add), data8 MSB */\n#define R_IA64_GPREL64LSB\t0x2f\t/* @gprel(sym + add), data8 LSB */\n#define R_IA64_LTOFF22\t\t0x32\t/* @ltoff(sym + add), add imm22 */\n#define R_IA64_LTOFF64I\t\t0x33\t/* @ltoff(sym + add), mov imm64 */\n#define R_IA64_PLTOFF22\t\t0x3a\t/* @pltoff(sym + add), add imm22 */\n#define R_IA64_PLTOFF64I\t0x3b\t/* @pltoff(sym + add), mov imm64 */\n#define R_IA64_PLTOFF64MSB\t0x3e\t/* @pltoff(sym + add), data8 MSB */\n#define R_IA64_PLTOFF64LSB\t0x3f\t/* @pltoff(sym + add), data8 LSB */\n#define R_IA64_FPTR64I\t\t0x43\t/* @fptr(sym + add), mov imm64 */\n#define R_IA64_FPTR32MSB\t0x44\t/* @fptr(sym + add), data4 MSB */\n#define R_IA64_FPTR32LSB\t0x45\t/* @fptr(sym + add), data4 LSB */\n#define R_IA64_FPTR64MSB\t0x46\t/* @fptr(sym + add), data8 MSB */\n#define R_IA64_FPTR64LSB\t0x47\t/* @fptr(sym + add), data8 LSB */\n#define R_IA64_PCREL60B\t\t0x48\t/* @pcrel(sym + add), brl */\n#define R_IA64_PCREL21B\t\t0x49\t/* @pcrel(sym + add), ptb, call */\n#define R_IA64_PCREL21M\t\t0x4a\t/* @pcrel(sym + add), chk.s */\n#define R_IA64_PCREL21F\t\t0x4b\t/* @pcrel(sym + add), fchkf */\n#define R_IA64_PCREL32MSB\t0x4c\t/* @pcrel(sym + add), data4 MSB */\n#define R_IA64_PCREL32LSB\t0x4d\t/* @pcrel(sym + add), data4 LSB */\n#define R_IA64_PCREL64MSB\t0x4e\t/* @pcrel(sym + add), data8 MSB */\n#define R_IA64_PCREL64LSB\t0x4f\t/* @pcrel(sym + add), data8 LSB */\n#define R_IA64_LTOFF_FPTR22\t0x52\t/* @ltoff(@fptr(s+a)), imm22 */\n#define R_IA64_LTOFF_FPTR64I\t0x53\t/* @ltoff(@fptr(s+a)), imm64 */\n#define R_IA64_LTOFF_FPTR32MSB\t0x54\t/* @ltoff(@fptr(s+a)), data4 MSB */\n#define R_IA64_LTOFF_FPTR32LSB\t0x55\t/* @ltoff(@fptr(s+a)), data4 LSB */\n#define R_IA64_LTOFF_FPTR64MSB\t0x56\t/* @ltoff(@fptr(s+a)), data8 MSB */\n#define R_IA64_LTOFF_FPTR64LSB\t0x57\t/* @ltoff(@fptr(s+a)), data8 LSB */\n#define R_IA64_SEGREL32MSB\t0x5c\t/* @segrel(sym + add), data4 MSB */\n#define R_IA64_SEGREL32LSB\t0x5d\t/* @segrel(sym + add), data4 LSB */\n#define R_IA64_SEGREL64MSB\t0x5e\t/* @segrel(sym + add), data8 MSB */\n#define R_IA64_SEGREL64LSB\t0x5f\t/* @segrel(sym + add), data8 LSB */\n#define R_IA64_SECREL32MSB\t0x64\t/* @secrel(sym + add), data4 MSB */\n#define R_IA64_SECREL32LSB\t0x65\t/* @secrel(sym + add), data4 LSB */\n#define R_IA64_SECREL64MSB\t0x66\t/* @secrel(sym + add), data8 MSB */\n#define R_IA64_SECREL64LSB\t0x67\t/* @secrel(sym + add), data8 LSB */\n#define R_IA64_REL32MSB\t\t0x6c\t/* data 4 + REL */\n#define R_IA64_REL32LSB\t\t0x6d\t/* data 4 + REL */\n#define R_IA64_REL64MSB\t\t0x6e\t/* data 8 + REL */\n#define R_IA64_REL64LSB\t\t0x6f\t/* data 8 + REL */\n#define R_IA64_LTV32MSB\t\t0x74\t/* symbol + addend, data4 MSB */\n#define R_IA64_LTV32LSB\t\t0x75\t/* symbol + addend, data4 LSB */\n#define R_IA64_LTV64MSB\t\t0x76\t/* symbol + addend, data8 MSB */\n#define R_IA64_LTV64LSB\t\t0x77\t/* symbol + addend, data8 LSB */\n#define R_IA64_PCREL21BI\t0x79\t/* @pcrel(sym + add), 21bit inst */\n#define R_IA64_PCREL22\t\t0x7a\t/* @pcrel(sym + add), 22bit inst */\n#define R_IA64_PCREL64I\t\t0x7b\t/* @pcrel(sym + add), 64bit inst */\n#define R_IA64_IPLTMSB\t\t0x80\t/* dynamic reloc, imported PLT, MSB */\n#define R_IA64_IPLTLSB\t\t0x81\t/* dynamic reloc, imported PLT, LSB */\n#define R_IA64_COPY\t\t0x84\t/* copy relocation */\n#define R_IA64_SUB\t\t0x85\t/* Addend and symbol difference */\n#define R_IA64_LTOFF22X\t\t0x86\t/* LTOFF22, relaxable.  */\n#define R_IA64_LDXMOV\t\t0x87\t/* Use of LTOFF22X.  */\n#define R_IA64_TPREL14\t\t0x91\t/* @tprel(sym + add), imm14 */\n#define R_IA64_TPREL22\t\t0x92\t/* @tprel(sym + add), imm22 */\n#define R_IA64_TPREL64I\t\t0x93\t/* @tprel(sym + add), imm64 */\n#define R_IA64_TPREL64MSB\t0x96\t/* @tprel(sym + add), data8 MSB */\n#define R_IA64_TPREL64LSB\t0x97\t/* @tprel(sym + add), data8 LSB */\n#define R_IA64_LTOFF_TPREL22\t0x9a\t/* @ltoff(@tprel(s+a)), imm2 */\n#define R_IA64_DTPMOD64MSB\t0xa6\t/* @dtpmod(sym + add), data8 MSB */\n#define R_IA64_DTPMOD64LSB\t0xa7\t/* @dtpmod(sym + add), data8 LSB */\n#define R_IA64_LTOFF_DTPMOD22\t0xaa\t/* @ltoff(@dtpmod(sym + add)), imm22 */\n#define R_IA64_DTPREL14\t\t0xb1\t/* @dtprel(sym + add), imm14 */\n#define R_IA64_DTPREL22\t\t0xb2\t/* @dtprel(sym + add), imm22 */\n#define R_IA64_DTPREL64I\t0xb3\t/* @dtprel(sym + add), imm64 */\n#define R_IA64_DTPREL32MSB\t0xb4\t/* @dtprel(sym + add), data4 MSB */\n#define R_IA64_DTPREL32LSB\t0xb5\t/* @dtprel(sym + add), data4 LSB */\n#define R_IA64_DTPREL64MSB\t0xb6\t/* @dtprel(sym + add), data8 MSB */\n#define R_IA64_DTPREL64LSB\t0xb7\t/* @dtprel(sym + add), data8 LSB */\n#define R_IA64_LTOFF_DTPREL22\t0xba\t/* @ltoff(@dtprel(s+a)), imm22 */\n\n/* SH specific declarations */\n\n/* Processor specific flags for the ELF header e_flags field.  */\n#define EF_SH_MACH_MASK\t\t0x1f\n#define EF_SH_UNKNOWN\t\t0x0\n#define EF_SH1\t\t\t0x1\n#define EF_SH2\t\t\t0x2\n#define EF_SH3\t\t\t0x3\n#define EF_SH_DSP\t\t0x4\n#define EF_SH3_DSP\t\t0x5\n#define EF_SH4AL_DSP\t\t0x6\n#define EF_SH3E\t\t\t0x8\n#define EF_SH4\t\t\t0x9\n#define EF_SH2E\t\t\t0xb\n#define EF_SH4A\t\t\t0xc\n#define EF_SH2A\t\t\t0xd\n#define EF_SH4_NOFPU\t\t0x10\n#define EF_SH4A_NOFPU\t\t0x11\n#define EF_SH4_NOMMU_NOFPU\t0x12\n#define EF_SH2A_NOFPU\t\t0x13\n#define EF_SH3_NOMMU\t\t0x14\n#define EF_SH2A_SH4_NOFPU\t0x15\n#define EF_SH2A_SH3_NOFPU\t0x16\n#define EF_SH2A_SH4\t\t0x17\n#define EF_SH2A_SH3E\t\t0x18\n\n/* SH relocs.  */\n#define\tR_SH_NONE\t\t0\n#define\tR_SH_DIR32\t\t1\n#define\tR_SH_REL32\t\t2\n#define\tR_SH_DIR8WPN\t\t3\n#define\tR_SH_IND12W\t\t4\n#define\tR_SH_DIR8WPL\t\t5\n#define\tR_SH_DIR8WPZ\t\t6\n#define\tR_SH_DIR8BP\t\t7\n#define\tR_SH_DIR8W\t\t8\n#define\tR_SH_DIR8L\t\t9\n#define\tR_SH_SWITCH16\t\t25\n#define\tR_SH_SWITCH32\t\t26\n#define\tR_SH_USES\t\t27\n#define\tR_SH_COUNT\t\t28\n#define\tR_SH_ALIGN\t\t29\n#define\tR_SH_CODE\t\t30\n#define\tR_SH_DATA\t\t31\n#define\tR_SH_LABEL\t\t32\n#define\tR_SH_SWITCH8\t\t33\n#define\tR_SH_GNU_VTINHERIT\t34\n#define\tR_SH_GNU_VTENTRY\t35\n#define\tR_SH_TLS_GD_32\t\t144\n#define\tR_SH_TLS_LD_32\t\t145\n#define\tR_SH_TLS_LDO_32\t\t146\n#define\tR_SH_TLS_IE_32\t\t147\n#define\tR_SH_TLS_LE_32\t\t148\n#define\tR_SH_TLS_DTPMOD32\t149\n#define\tR_SH_TLS_DTPOFF32\t150\n#define\tR_SH_TLS_TPOFF32\t151\n#define\tR_SH_GOT32\t\t160\n#define\tR_SH_PLT32\t\t161\n#define\tR_SH_COPY\t\t162\n#define\tR_SH_GLOB_DAT\t\t163\n#define\tR_SH_JMP_SLOT\t\t164\n#define\tR_SH_RELATIVE\t\t165\n#define\tR_SH_GOTOFF\t\t166\n#define\tR_SH_GOTPC\t\t167\n/* Keep this the last entry.  */\n#define\tR_SH_NUM\t\t256\n\n/* S/390 specific definitions.  */\n\n/* Valid values for the e_flags field.  */\n\n#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */\n\n/* Additional s390 relocs */\n\n#define R_390_NONE\t\t0\t/* No reloc.  */\n#define R_390_8\t\t\t1\t/* Direct 8 bit.  */\n#define R_390_12\t\t2\t/* Direct 12 bit.  */\n#define R_390_16\t\t3\t/* Direct 16 bit.  */\n#define R_390_32\t\t4\t/* Direct 32 bit.  */\n#define R_390_PC32\t\t5\t/* PC relative 32 bit.\t*/\n#define R_390_GOT12\t\t6\t/* 12 bit GOT offset.  */\n#define R_390_GOT32\t\t7\t/* 32 bit GOT offset.  */\n#define R_390_PLT32\t\t8\t/* 32 bit PC relative PLT address.  */\n#define R_390_COPY\t\t9\t/* Copy symbol at runtime.  */\n#define R_390_GLOB_DAT\t\t10\t/* Create GOT entry.  */\n#define R_390_JMP_SLOT\t\t11\t/* Create PLT entry.  */\n#define R_390_RELATIVE\t\t12\t/* Adjust by program base.  */\n#define R_390_GOTOFF32\t\t13\t/* 32 bit offset to GOT.\t */\n#define R_390_GOTPC\t\t14\t/* 32 bit PC relative offset to GOT.  */\n#define R_390_GOT16\t\t15\t/* 16 bit GOT offset.  */\n#define R_390_PC16\t\t16\t/* PC relative 16 bit.\t*/\n#define R_390_PC16DBL\t\t17\t/* PC relative 16 bit shifted by 1.  */\n#define R_390_PLT16DBL\t\t18\t/* 16 bit PC rel. PLT shifted by 1.  */\n#define R_390_PC32DBL\t\t19\t/* PC relative 32 bit shifted by 1.  */\n#define R_390_PLT32DBL\t\t20\t/* 32 bit PC rel. PLT shifted by 1.  */\n#define R_390_GOTPCDBL\t\t21\t/* 32 bit PC rel. GOT shifted by 1.  */\n#define R_390_64\t\t22\t/* Direct 64 bit.  */\n#define R_390_PC64\t\t23\t/* PC relative 64 bit.\t*/\n#define R_390_GOT64\t\t24\t/* 64 bit GOT offset.  */\n#define R_390_PLT64\t\t25\t/* 64 bit PC relative PLT address.  */\n#define R_390_GOTENT\t\t26\t/* 32 bit PC rel. to GOT entry >> 1. */\n#define R_390_GOTOFF16\t\t27\t/* 16 bit offset to GOT. */\n#define R_390_GOTOFF64\t\t28\t/* 64 bit offset to GOT. */\n#define R_390_GOTPLT12\t\t29\t/* 12 bit offset to jump slot.\t*/\n#define R_390_GOTPLT16\t\t30\t/* 16 bit offset to jump slot.\t*/\n#define R_390_GOTPLT32\t\t31\t/* 32 bit offset to jump slot.\t*/\n#define R_390_GOTPLT64\t\t32\t/* 64 bit offset to jump slot.\t*/\n#define R_390_GOTPLTENT\t\t33\t/* 32 bit rel. offset to jump slot.  */\n#define R_390_PLTOFF16\t\t34\t/* 16 bit offset from GOT to PLT. */\n#define R_390_PLTOFF32\t\t35\t/* 32 bit offset from GOT to PLT. */\n#define R_390_PLTOFF64\t\t36\t/* 16 bit offset from GOT to PLT. */\n#define R_390_TLS_LOAD\t\t37\t/* Tag for load insn in TLS code.  */\n#define R_390_TLS_GDCALL\t38\t/* Tag for function call in general\n\t\t\t\t\t   dynamic TLS code. */\n#define R_390_TLS_LDCALL\t39\t/* Tag for function call in local\n\t\t\t\t\t   dynamic TLS code. */\n#define R_390_TLS_GD32\t\t40\t/* Direct 32 bit for general dynamic\n\t\t\t\t\t   thread local data.  */\n#define R_390_TLS_GD64\t\t41\t/* Direct 64 bit for general dynamic\n\t\t\t\t\t  thread local data.  */\n#define R_390_TLS_GOTIE12\t42\t/* 12 bit GOT offset for static TLS\n\t\t\t\t\t   block offset.  */\n#define R_390_TLS_GOTIE32\t43\t/* 32 bit GOT offset for static TLS\n\t\t\t\t\t   block offset.  */\n#define R_390_TLS_GOTIE64\t44\t/* 64 bit GOT offset for static TLS\n\t\t\t\t\t   block offset. */\n#define R_390_TLS_LDM32\t\t45\t/* Direct 32 bit for local dynamic\n\t\t\t\t\t   thread local data in LE code.  */\n#define R_390_TLS_LDM64\t\t46\t/* Direct 64 bit for local dynamic\n\t\t\t\t\t   thread local data in LE code.  */\n#define R_390_TLS_IE32\t\t47\t/* 32 bit address of GOT entry for\n\t\t\t\t\t   negated static TLS block offset.  */\n#define R_390_TLS_IE64\t\t48\t/* 64 bit address of GOT entry for\n\t\t\t\t\t   negated static TLS block offset.  */\n#define R_390_TLS_IEENT\t\t49\t/* 32 bit rel. offset to GOT entry for\n\t\t\t\t\t   negated static TLS block offset.  */\n#define R_390_TLS_LE32\t\t50\t/* 32 bit negated offset relative to\n\t\t\t\t\t   static TLS block.  */\n#define R_390_TLS_LE64\t\t51\t/* 64 bit negated offset relative to\n\t\t\t\t\t   static TLS block.  */\n#define R_390_TLS_LDO32\t\t52\t/* 32 bit offset relative to TLS\n\t\t\t\t\t   block.  */\n#define R_390_TLS_LDO64\t\t53\t/* 64 bit offset relative to TLS\n\t\t\t\t\t   block.  */\n#define R_390_TLS_DTPMOD\t54\t/* ID of module containing symbol.  */\n#define R_390_TLS_DTPOFF\t55\t/* Offset in TLS block.\t */\n#define R_390_TLS_TPOFF\t\t56\t/* Negated offset in static TLS\n\t\t\t\t\t   block.  */\n#define R_390_20\t\t57\t/* Direct 20 bit.  */\n#define R_390_GOT20\t\t58\t/* 20 bit GOT offset.  */\n#define R_390_GOTPLT20\t\t59\t/* 20 bit offset to jump slot.  */\n#define R_390_TLS_GOTIE20\t60\t/* 20 bit GOT offset for static TLS\n\t\t\t\t\t   block offset.  */\n#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */\n/* Keep this the last entry.  */\n#define R_390_NUM\t\t62\n\n\n/* CRIS relocations.  */\n#define R_CRIS_NONE\t\t0\n#define R_CRIS_8\t\t1\n#define R_CRIS_16\t\t2\n#define R_CRIS_32\t\t3\n#define R_CRIS_8_PCREL\t\t4\n#define R_CRIS_16_PCREL\t\t5\n#define R_CRIS_32_PCREL\t\t6\n#define R_CRIS_GNU_VTINHERIT\t7\n#define R_CRIS_GNU_VTENTRY\t8\n#define R_CRIS_COPY\t\t9\n#define R_CRIS_GLOB_DAT\t\t10\n#define R_CRIS_JUMP_SLOT\t11\n#define R_CRIS_RELATIVE\t\t12\n#define R_CRIS_16_GOT\t\t13\n#define R_CRIS_32_GOT\t\t14\n#define R_CRIS_16_GOTPLT\t15\n#define R_CRIS_32_GOTPLT\t16\n#define R_CRIS_32_GOTREL\t17\n#define R_CRIS_32_PLT_GOTREL\t18\n#define R_CRIS_32_PLT_PCREL\t19\n\n#define R_CRIS_NUM\t\t20\n\n\n/* AMD x86-64 relocations.  */\n#define R_X86_64_NONE\t\t0\t/* No reloc */\n#define R_X86_64_64\t\t1\t/* Direct 64 bit  */\n#define R_X86_64_PC32\t\t2\t/* PC relative 32 bit signed */\n#define R_X86_64_GOT32\t\t3\t/* 32 bit GOT entry */\n#define R_X86_64_PLT32\t\t4\t/* 32 bit PLT address */\n#define R_X86_64_COPY\t\t5\t/* Copy symbol at runtime */\n#define R_X86_64_GLOB_DAT\t6\t/* Create GOT entry */\n#define R_X86_64_JUMP_SLOT\t7\t/* Create PLT entry */\n#define R_X86_64_RELATIVE\t8\t/* Adjust by program base */\n#define R_X86_64_GOTPCREL\t9\t/* 32 bit signed PC relative\n\t\t\t\t\t   offset to GOT */\n#define R_X86_64_32\t\t10\t/* Direct 32 bit zero extended */\n#define R_X86_64_32S\t\t11\t/* Direct 32 bit sign extended */\n#define R_X86_64_16\t\t12\t/* Direct 16 bit zero extended */\n#define R_X86_64_PC16\t\t13\t/* 16 bit sign extended pc relative */\n#define R_X86_64_8\t\t14\t/* Direct 8 bit sign extended  */\n#define R_X86_64_PC8\t\t15\t/* 8 bit sign extended pc relative */\n#define R_X86_64_DTPMOD64\t16\t/* ID of module containing symbol */\n#define R_X86_64_DTPOFF64\t17\t/* Offset in module's TLS block */\n#define R_X86_64_TPOFF64\t18\t/* Offset in initial TLS block */\n#define R_X86_64_TLSGD\t\t19\t/* 32 bit signed PC relative offset\n\t\t\t\t\t   to two GOT entries for GD symbol */\n#define R_X86_64_TLSLD\t\t20\t/* 32 bit signed PC relative offset\n\t\t\t\t\t   to two GOT entries for LD symbol */\n#define R_X86_64_DTPOFF32\t21\t/* Offset in TLS block */\n#define R_X86_64_GOTTPOFF\t22\t/* 32 bit signed PC relative offset\n\t\t\t\t\t   to GOT entry for IE symbol */\n#define R_X86_64_TPOFF32\t23\t/* Offset in initial TLS block */\n#define R_X86_64_PC64\t\t24\t/* PC relative 64 bit */\n#define R_X86_64_GOTOFF64\t25\t/* 64 bit offset to GOT */\n#define R_X86_64_GOTPC32\t26\t/* 32 bit signed pc relative\n\t\t\t\t\t   offset to GOT */\n#define R_X86_64_GOT64\t\t27\t/* 64-bit GOT entry offset */\n#define R_X86_64_GOTPCREL64\t28\t/* 64-bit PC relative offset\n\t\t\t\t\t   to GOT entry */\n#define R_X86_64_GOTPC64\t29\t/* 64-bit PC relative offset to GOT */\n#define R_X86_64_GOTPLT64\t30 \t/* like GOT64, says PLT entry needed */\n#define R_X86_64_PLTOFF64\t31\t/* 64-bit GOT relative offset\n\t\t\t\t\t   to PLT entry */\n#define R_X86_64_SIZE32\t\t32\t/* Size of symbol plus 32-bit addend */\n#define R_X86_64_SIZE64\t\t33\t/* Size of symbol plus 64-bit addend */\n#define R_X86_64_GOTPC32_TLSDESC 34\t/* GOT offset for TLS descriptor.  */\n#define R_X86_64_TLSDESC_CALL   35\t/* Marker for call through TLS\n\t\t\t\t\t   descriptor.  */\n#define R_X86_64_TLSDESC        36\t/* TLS descriptor.  */\n#define R_X86_64_IRELATIVE\t37\t/* Adjust indirectly by program base */\n#define R_X86_64_RELATIVE64\t38\t/* 64-bit adjust by program base */\n#define R_X86_64_GOTPCRELX\t41\t/* like GOTPCREL, but optionally with\n\t\t\t\t\t   linker optimizations */\n#define R_X86_64_REX_GOTPCRELX\t42      /* like GOTPCRELX, but a REX prefix\n\t\t\t\t\t   is present */\n\n#define R_X86_64_NUM\t\t43\n\n/* x86-64 sh_type values.  */\n#define SHT_X86_64_UNWIND       0x70000001 /* Unwind information.  */\n\n/* AM33 relocations.  */\n#define R_MN10300_NONE\t\t0\t/* No reloc.  */\n#define R_MN10300_32\t\t1\t/* Direct 32 bit.  */\n#define R_MN10300_16\t\t2\t/* Direct 16 bit.  */\n#define R_MN10300_8\t\t3\t/* Direct 8 bit.  */\n#define R_MN10300_PCREL32\t4\t/* PC-relative 32-bit.  */\n#define R_MN10300_PCREL16\t5\t/* PC-relative 16-bit signed.  */\n#define R_MN10300_PCREL8\t6\t/* PC-relative 8-bit signed.  */\n#define R_MN10300_GNU_VTINHERIT\t7\t/* Ancient C++ vtable garbage... */\n#define R_MN10300_GNU_VTENTRY\t8\t/* ... collection annotation.  */\n#define R_MN10300_24\t\t9\t/* Direct 24 bit.  */\n#define R_MN10300_GOTPC32\t10\t/* 32-bit PCrel offset to GOT.  */\n#define R_MN10300_GOTPC16\t11\t/* 16-bit PCrel offset to GOT.  */\n#define R_MN10300_GOTOFF32\t12\t/* 32-bit offset from GOT.  */\n#define R_MN10300_GOTOFF24\t13\t/* 24-bit offset from GOT.  */\n#define R_MN10300_GOTOFF16\t14\t/* 16-bit offset from GOT.  */\n#define R_MN10300_PLT32\t\t15\t/* 32-bit PCrel to PLT entry.  */\n#define R_MN10300_PLT16\t\t16\t/* 16-bit PCrel to PLT entry.  */\n#define R_MN10300_GOT32\t\t17\t/* 32-bit offset to GOT entry.  */\n#define R_MN10300_GOT24\t\t18\t/* 24-bit offset to GOT entry.  */\n#define R_MN10300_GOT16\t\t19\t/* 16-bit offset to GOT entry.  */\n#define R_MN10300_COPY\t\t20\t/* Copy symbol at runtime.  */\n#define R_MN10300_GLOB_DAT\t21\t/* Create GOT entry.  */\n#define R_MN10300_JMP_SLOT\t22\t/* Create PLT entry.  */\n#define R_MN10300_RELATIVE\t23\t/* Adjust by program base.  */\n#define R_MN10300_TLS_GD\t24\t/* 32-bit offset for global dynamic.  */\n#define R_MN10300_TLS_LD\t25\t/* 32-bit offset for local dynamic.  */\n#define R_MN10300_TLS_LDO\t26\t/* Module-relative offset.  */\n#define R_MN10300_TLS_GOTIE\t27\t/* GOT offset for static TLS block\n\t\t\t\t\t   offset.  */\n#define R_MN10300_TLS_IE\t28\t/* GOT address for static TLS block\n\t\t\t\t\t   offset.  */\n#define R_MN10300_TLS_LE\t29\t/* Offset relative to static TLS\n\t\t\t\t\t   block.  */\n#define R_MN10300_TLS_DTPMOD\t30\t/* ID of module containing symbol.  */\n#define R_MN10300_TLS_DTPOFF\t31\t/* Offset in module TLS block.  */\n#define R_MN10300_TLS_TPOFF\t32\t/* Offset in static TLS block.  */\n#define R_MN10300_SYM_DIFF\t33\t/* Adjustment for next reloc as needed\n\t\t\t\t\t   by linker relaxation.  */\n#define R_MN10300_ALIGN\t\t34\t/* Alignment requirement for linker\n\t\t\t\t\t   relaxation.  */\n#define R_MN10300_NUM\t\t35\n\n\n/* M32R relocs.  */\n#define R_M32R_NONE\t\t0\t/* No reloc. */\n#define R_M32R_16\t\t1\t/* Direct 16 bit. */\n#define R_M32R_32\t\t2\t/* Direct 32 bit. */\n#define R_M32R_24\t\t3\t/* Direct 24 bit. */\n#define R_M32R_10_PCREL\t\t4\t/* PC relative 10 bit shifted. */\n#define R_M32R_18_PCREL\t\t5\t/* PC relative 18 bit shifted. */\n#define R_M32R_26_PCREL\t\t6\t/* PC relative 26 bit shifted. */\n#define R_M32R_HI16_ULO\t\t7\t/* High 16 bit with unsigned low. */\n#define R_M32R_HI16_SLO\t\t8\t/* High 16 bit with signed low. */\n#define R_M32R_LO16\t\t9\t/* Low 16 bit. */\n#define R_M32R_SDA16\t\t10\t/* 16 bit offset in SDA. */\n#define R_M32R_GNU_VTINHERIT\t11\n#define R_M32R_GNU_VTENTRY\t12\n/* M32R relocs use SHT_RELA.  */\n#define R_M32R_16_RELA\t\t33\t/* Direct 16 bit. */\n#define R_M32R_32_RELA\t\t34\t/* Direct 32 bit. */\n#define R_M32R_24_RELA\t\t35\t/* Direct 24 bit. */\n#define R_M32R_10_PCREL_RELA\t36\t/* PC relative 10 bit shifted. */\n#define R_M32R_18_PCREL_RELA\t37\t/* PC relative 18 bit shifted. */\n#define R_M32R_26_PCREL_RELA\t38\t/* PC relative 26 bit shifted. */\n#define R_M32R_HI16_ULO_RELA\t39\t/* High 16 bit with unsigned low */\n#define R_M32R_HI16_SLO_RELA\t40\t/* High 16 bit with signed low */\n#define R_M32R_LO16_RELA\t41\t/* Low 16 bit */\n#define R_M32R_SDA16_RELA\t42\t/* 16 bit offset in SDA */\n#define R_M32R_RELA_GNU_VTINHERIT\t43\n#define R_M32R_RELA_GNU_VTENTRY\t44\n#define R_M32R_REL32\t\t45\t/* PC relative 32 bit.  */\n\n#define R_M32R_GOT24\t\t48\t/* 24 bit GOT entry */\n#define R_M32R_26_PLTREL\t49\t/* 26 bit PC relative to PLT shifted */\n#define R_M32R_COPY\t\t50\t/* Copy symbol at runtime */\n#define R_M32R_GLOB_DAT\t\t51\t/* Create GOT entry */\n#define R_M32R_JMP_SLOT\t\t52\t/* Create PLT entry */\n#define R_M32R_RELATIVE\t\t53\t/* Adjust by program base */\n#define R_M32R_GOTOFF\t\t54\t/* 24 bit offset to GOT */\n#define R_M32R_GOTPC24\t\t55\t/* 24 bit PC relative offset to GOT */\n#define R_M32R_GOT16_HI_ULO\t56\t/* High 16 bit GOT entry with unsigned\n\t\t\t\t\t   low */\n#define R_M32R_GOT16_HI_SLO\t57\t/* High 16 bit GOT entry with signed\n\t\t\t\t\t   low */\n#define R_M32R_GOT16_LO\t\t58\t/* Low 16 bit GOT entry */\n#define R_M32R_GOTPC_HI_ULO\t59\t/* High 16 bit PC relative offset to\n\t\t\t\t\t   GOT with unsigned low */\n#define R_M32R_GOTPC_HI_SLO\t60\t/* High 16 bit PC relative offset to\n\t\t\t\t\t   GOT with signed low */\n#define R_M32R_GOTPC_LO\t\t61\t/* Low 16 bit PC relative offset to\n\t\t\t\t\t   GOT */\n#define R_M32R_GOTOFF_HI_ULO\t62\t/* High 16 bit offset to GOT\n\t\t\t\t\t   with unsigned low */\n#define R_M32R_GOTOFF_HI_SLO\t63\t/* High 16 bit offset to GOT\n\t\t\t\t\t   with signed low */\n#define R_M32R_GOTOFF_LO\t64\t/* Low 16 bit offset to GOT */\n#define R_M32R_NUM\t\t256\t/* Keep this the last entry. */\n\n\n/* TILEPro relocations.  */\n#define R_TILEPRO_NONE\t\t0\t/* No reloc */\n#define R_TILEPRO_32\t\t1\t/* Direct 32 bit */\n#define R_TILEPRO_16\t\t2\t/* Direct 16 bit */\n#define R_TILEPRO_8\t\t3\t/* Direct 8 bit */\n#define R_TILEPRO_32_PCREL\t4\t/* PC relative 32 bit */\n#define R_TILEPRO_16_PCREL\t5\t/* PC relative 16 bit */\n#define R_TILEPRO_8_PCREL\t6\t/* PC relative 8 bit */\n#define R_TILEPRO_LO16\t\t7\t/* Low 16 bit */\n#define R_TILEPRO_HI16\t\t8\t/* High 16 bit */\n#define R_TILEPRO_HA16\t\t9\t/* High 16 bit, adjusted */\n#define R_TILEPRO_COPY\t\t10\t/* Copy relocation */\n#define R_TILEPRO_GLOB_DAT\t11\t/* Create GOT entry */\n#define R_TILEPRO_JMP_SLOT\t12\t/* Create PLT entry */\n#define R_TILEPRO_RELATIVE\t13\t/* Adjust by program base */\n#define R_TILEPRO_BROFF_X1\t14\t/* X1 pipe branch offset */\n#define R_TILEPRO_JOFFLONG_X1\t15\t/* X1 pipe jump offset */\n#define R_TILEPRO_JOFFLONG_X1_PLT 16\t/* X1 pipe jump offset to PLT */\n#define R_TILEPRO_IMM8_X0\t17\t/* X0 pipe 8-bit */\n#define R_TILEPRO_IMM8_Y0\t18\t/* Y0 pipe 8-bit */\n#define R_TILEPRO_IMM8_X1\t19\t/* X1 pipe 8-bit */\n#define R_TILEPRO_IMM8_Y1\t20\t/* Y1 pipe 8-bit */\n#define R_TILEPRO_MT_IMM15_X1\t21\t/* X1 pipe mtspr */\n#define R_TILEPRO_MF_IMM15_X1\t22\t/* X1 pipe mfspr */\n#define R_TILEPRO_IMM16_X0\t23\t/* X0 pipe 16-bit */\n#define R_TILEPRO_IMM16_X1\t24\t/* X1 pipe 16-bit */\n#define R_TILEPRO_IMM16_X0_LO\t25\t/* X0 pipe low 16-bit */\n#define R_TILEPRO_IMM16_X1_LO\t26\t/* X1 pipe low 16-bit */\n#define R_TILEPRO_IMM16_X0_HI\t27\t/* X0 pipe high 16-bit */\n#define R_TILEPRO_IMM16_X1_HI\t28\t/* X1 pipe high 16-bit */\n#define R_TILEPRO_IMM16_X0_HA\t29\t/* X0 pipe high 16-bit, adjusted */\n#define R_TILEPRO_IMM16_X1_HA\t30\t/* X1 pipe high 16-bit, adjusted */\n#define R_TILEPRO_IMM16_X0_PCREL 31\t/* X0 pipe PC relative 16 bit */\n#define R_TILEPRO_IMM16_X1_PCREL 32\t/* X1 pipe PC relative 16 bit */\n#define R_TILEPRO_IMM16_X0_LO_PCREL 33\t/* X0 pipe PC relative low 16 bit */\n#define R_TILEPRO_IMM16_X1_LO_PCREL 34\t/* X1 pipe PC relative low 16 bit */\n#define R_TILEPRO_IMM16_X0_HI_PCREL 35\t/* X0 pipe PC relative high 16 bit */\n#define R_TILEPRO_IMM16_X1_HI_PCREL 36\t/* X1 pipe PC relative high 16 bit */\n#define R_TILEPRO_IMM16_X0_HA_PCREL 37\t/* X0 pipe PC relative ha() 16 bit */\n#define R_TILEPRO_IMM16_X1_HA_PCREL 38\t/* X1 pipe PC relative ha() 16 bit */\n#define R_TILEPRO_IMM16_X0_GOT\t39\t/* X0 pipe 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X1_GOT\t40\t/* X1 pipe 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X0_GOT_LO 41\t/* X0 pipe low 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X1_GOT_LO 42\t/* X1 pipe low 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X0_GOT_HI 43\t/* X0 pipe high 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X1_GOT_HI 44\t/* X1 pipe high 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X0_GOT_HA 45\t/* X0 pipe ha() 16-bit GOT offset */\n#define R_TILEPRO_IMM16_X1_GOT_HA 46\t/* X1 pipe ha() 16-bit GOT offset */\n#define R_TILEPRO_MMSTART_X0\t47\t/* X0 pipe mm \"start\" */\n#define R_TILEPRO_MMEND_X0\t48\t/* X0 pipe mm \"end\" */\n#define R_TILEPRO_MMSTART_X1\t49\t/* X1 pipe mm \"start\" */\n#define R_TILEPRO_MMEND_X1\t50\t/* X1 pipe mm \"end\" */\n#define R_TILEPRO_SHAMT_X0\t51\t/* X0 pipe shift amount */\n#define R_TILEPRO_SHAMT_X1\t52\t/* X1 pipe shift amount */\n#define R_TILEPRO_SHAMT_Y0\t53\t/* Y0 pipe shift amount */\n#define R_TILEPRO_SHAMT_Y1\t54\t/* Y1 pipe shift amount */\n#define R_TILEPRO_DEST_IMM8_X1\t55\t/* X1 pipe destination 8-bit */\n/* Relocs 56-59 are currently not defined.  */\n#define R_TILEPRO_TLS_GD_CALL\t60\t/* \"jal\" for TLS GD */\n#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61\t/* X0 pipe \"addi\" for TLS GD */\n#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62\t/* X1 pipe \"addi\" for TLS GD */\n#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63\t/* Y0 pipe \"addi\" for TLS GD */\n#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64\t/* Y1 pipe \"addi\" for TLS GD */\n#define R_TILEPRO_TLS_IE_LOAD\t65\t/* \"lw_tls\" for TLS IE */\n#define R_TILEPRO_IMM16_X0_TLS_GD 66\t/* X0 pipe 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X1_TLS_GD 67\t/* X1 pipe 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68\t/* X0 pipe low 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69\t/* X1 pipe low 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70\t/* X0 pipe high 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71\t/* X1 pipe high 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72\t/* X0 pipe ha() 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73\t/* X1 pipe ha() 16-bit TLS GD offset */\n#define R_TILEPRO_IMM16_X0_TLS_IE 74\t/* X0 pipe 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X1_TLS_IE 75\t/* X1 pipe 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76\t/* X0 pipe low 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77\t/* X1 pipe low 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78\t/* X0 pipe high 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79\t/* X1 pipe high 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80\t/* X0 pipe ha() 16-bit TLS IE offset */\n#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81\t/* X1 pipe ha() 16-bit TLS IE offset */\n#define R_TILEPRO_TLS_DTPMOD32\t82\t/* ID of module containing symbol */\n#define R_TILEPRO_TLS_DTPOFF32\t83\t/* Offset in TLS block */\n#define R_TILEPRO_TLS_TPOFF32\t84\t/* Offset in static TLS block */\n#define R_TILEPRO_IMM16_X0_TLS_LE 85\t/* X0 pipe 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X1_TLS_LE 86\t/* X1 pipe 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87\t/* X0 pipe low 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88\t/* X1 pipe low 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89\t/* X0 pipe high 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90\t/* X1 pipe high 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91\t/* X0 pipe ha() 16-bit TLS LE offset */\n#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92\t/* X1 pipe ha() 16-bit TLS LE offset */\n\n#define R_TILEPRO_GNU_VTINHERIT\t128\t/* GNU C++ vtable hierarchy */\n#define R_TILEPRO_GNU_VTENTRY\t129\t/* GNU C++ vtable member usage */\n\n#define R_TILEPRO_NUM\t\t130\n\n\n/* TILE-Gx relocations.  */\n#define R_TILEGX_NONE\t\t0\t/* No reloc */\n#define R_TILEGX_64\t\t1\t/* Direct 64 bit */\n#define R_TILEGX_32\t\t2\t/* Direct 32 bit */\n#define R_TILEGX_16\t\t3\t/* Direct 16 bit */\n#define R_TILEGX_8\t\t4\t/* Direct 8 bit */\n#define R_TILEGX_64_PCREL\t5\t/* PC relative 64 bit */\n#define R_TILEGX_32_PCREL\t6\t/* PC relative 32 bit */\n#define R_TILEGX_16_PCREL\t7\t/* PC relative 16 bit */\n#define R_TILEGX_8_PCREL\t8\t/* PC relative 8 bit */\n#define R_TILEGX_HW0\t\t9\t/* hword 0 16-bit */\n#define R_TILEGX_HW1\t\t10\t/* hword 1 16-bit */\n#define R_TILEGX_HW2\t\t11\t/* hword 2 16-bit */\n#define R_TILEGX_HW3\t\t12\t/* hword 3 16-bit */\n#define R_TILEGX_HW0_LAST\t13\t/* last hword 0 16-bit */\n#define R_TILEGX_HW1_LAST\t14\t/* last hword 1 16-bit */\n#define R_TILEGX_HW2_LAST\t15\t/* last hword 2 16-bit */\n#define R_TILEGX_COPY\t\t16\t/* Copy relocation */\n#define R_TILEGX_GLOB_DAT\t17\t/* Create GOT entry */\n#define R_TILEGX_JMP_SLOT\t18\t/* Create PLT entry */\n#define R_TILEGX_RELATIVE\t19\t/* Adjust by program base */\n#define R_TILEGX_BROFF_X1\t20\t/* X1 pipe branch offset */\n#define R_TILEGX_JUMPOFF_X1\t21\t/* X1 pipe jump offset */\n#define R_TILEGX_JUMPOFF_X1_PLT\t22\t/* X1 pipe jump offset to PLT */\n#define R_TILEGX_IMM8_X0\t23\t/* X0 pipe 8-bit */\n#define R_TILEGX_IMM8_Y0\t24\t/* Y0 pipe 8-bit */\n#define R_TILEGX_IMM8_X1\t25\t/* X1 pipe 8-bit */\n#define R_TILEGX_IMM8_Y1\t26\t/* Y1 pipe 8-bit */\n#define R_TILEGX_DEST_IMM8_X1\t27\t/* X1 pipe destination 8-bit */\n#define R_TILEGX_MT_IMM14_X1\t28\t/* X1 pipe mtspr */\n#define R_TILEGX_MF_IMM14_X1\t29\t/* X1 pipe mfspr */\n#define R_TILEGX_MMSTART_X0\t30\t/* X0 pipe mm \"start\" */\n#define R_TILEGX_MMEND_X0\t31\t/* X0 pipe mm \"end\" */\n#define R_TILEGX_SHAMT_X0\t32\t/* X0 pipe shift amount */\n#define R_TILEGX_SHAMT_X1\t33\t/* X1 pipe shift amount */\n#define R_TILEGX_SHAMT_Y0\t34\t/* Y0 pipe shift amount */\n#define R_TILEGX_SHAMT_Y1\t35\t/* Y1 pipe shift amount */\n#define R_TILEGX_IMM16_X0_HW0\t36\t/* X0 pipe hword 0 */\n#define R_TILEGX_IMM16_X1_HW0\t37\t/* X1 pipe hword 0 */\n#define R_TILEGX_IMM16_X0_HW1\t38\t/* X0 pipe hword 1 */\n#define R_TILEGX_IMM16_X1_HW1\t39\t/* X1 pipe hword 1 */\n#define R_TILEGX_IMM16_X0_HW2\t40\t/* X0 pipe hword 2 */\n#define R_TILEGX_IMM16_X1_HW2\t41\t/* X1 pipe hword 2 */\n#define R_TILEGX_IMM16_X0_HW3\t42\t/* X0 pipe hword 3 */\n#define R_TILEGX_IMM16_X1_HW3\t43\t/* X1 pipe hword 3 */\n#define R_TILEGX_IMM16_X0_HW0_LAST 44\t/* X0 pipe last hword 0 */\n#define R_TILEGX_IMM16_X1_HW0_LAST 45\t/* X1 pipe last hword 0 */\n#define R_TILEGX_IMM16_X0_HW1_LAST 46\t/* X0 pipe last hword 1 */\n#define R_TILEGX_IMM16_X1_HW1_LAST 47\t/* X1 pipe last hword 1 */\n#define R_TILEGX_IMM16_X0_HW2_LAST 48\t/* X0 pipe last hword 2 */\n#define R_TILEGX_IMM16_X1_HW2_LAST 49\t/* X1 pipe last hword 2 */\n#define R_TILEGX_IMM16_X0_HW0_PCREL 50\t/* X0 pipe PC relative hword 0 */\n#define R_TILEGX_IMM16_X1_HW0_PCREL 51\t/* X1 pipe PC relative hword 0 */\n#define R_TILEGX_IMM16_X0_HW1_PCREL 52\t/* X0 pipe PC relative hword 1 */\n#define R_TILEGX_IMM16_X1_HW1_PCREL 53\t/* X1 pipe PC relative hword 1 */\n#define R_TILEGX_IMM16_X0_HW2_PCREL 54\t/* X0 pipe PC relative hword 2 */\n#define R_TILEGX_IMM16_X1_HW2_PCREL 55\t/* X1 pipe PC relative hword 2 */\n#define R_TILEGX_IMM16_X0_HW3_PCREL 56\t/* X0 pipe PC relative hword 3 */\n#define R_TILEGX_IMM16_X1_HW3_PCREL 57\t/* X1 pipe PC relative hword 3 */\n#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */\n#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */\n#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */\n#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */\n#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */\n#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */\n#define R_TILEGX_IMM16_X0_HW0_GOT 64\t/* X0 pipe hword 0 GOT offset */\n#define R_TILEGX_IMM16_X1_HW0_GOT 65\t/* X1 pipe hword 0 GOT offset */\n#define R_TILEGX_IMM16_X0_HW0_PLT_PCREL 66 /* X0 pipe PC-rel PLT hword 0 */\n#define R_TILEGX_IMM16_X1_HW0_PLT_PCREL 67 /* X1 pipe PC-rel PLT hword 0 */\n#define R_TILEGX_IMM16_X0_HW1_PLT_PCREL 68 /* X0 pipe PC-rel PLT hword 1 */\n#define R_TILEGX_IMM16_X1_HW1_PLT_PCREL 69 /* X1 pipe PC-rel PLT hword 1 */\n#define R_TILEGX_IMM16_X0_HW2_PLT_PCREL 70 /* X0 pipe PC-rel PLT hword 2 */\n#define R_TILEGX_IMM16_X1_HW2_PLT_PCREL 71 /* X1 pipe PC-rel PLT hword 2 */\n#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */\n#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */\n#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */\n#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */\n#define R_TILEGX_IMM16_X0_HW3_PLT_PCREL 76 /* X0 pipe PC-rel PLT hword 3 */\n#define R_TILEGX_IMM16_X1_HW3_PLT_PCREL 77 /* X1 pipe PC-rel PLT hword 3 */\n#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78\t/* X0 pipe hword 0 TLS GD offset */\n#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79\t/* X1 pipe hword 0 TLS GD offset */\n#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80\t/* X0 pipe hword 0 TLS LE offset */\n#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81\t/* X1 pipe hword 0 TLS LE offset */\n#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */\n#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */\n#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */\n#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */\n#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */\n#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */\n#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */\n#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */\n/* Relocs 90-91 are currently not defined.  */\n#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92\t/* X0 pipe hword 0 TLS IE offset */\n#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93\t/* X1 pipe hword 0 TLS IE offset */\n#define R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL 94 /* X0 pipe PC-rel PLT last hword 0 */\n#define R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL 95 /* X1 pipe PC-rel PLT last hword 0 */\n#define R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL 96 /* X0 pipe PC-rel PLT last hword 1 */\n#define R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL 97 /* X1 pipe PC-rel PLT last hword 1 */\n#define R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL 98 /* X0 pipe PC-rel PLT last hword 2 */\n#define R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL 99 /* X1 pipe PC-rel PLT last hword 2 */\n#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */\n#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */\n#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */\n#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */\n/* Relocs 104-105 are currently not defined.  */\n#define R_TILEGX_TLS_DTPMOD64\t106\t/* 64-bit ID of symbol's module */\n#define R_TILEGX_TLS_DTPOFF64\t107\t/* 64-bit offset in TLS block */\n#define R_TILEGX_TLS_TPOFF64\t108\t/* 64-bit offset in static TLS block */\n#define R_TILEGX_TLS_DTPMOD32\t109\t/* 32-bit ID of symbol's module */\n#define R_TILEGX_TLS_DTPOFF32\t110\t/* 32-bit offset in TLS block */\n#define R_TILEGX_TLS_TPOFF32\t111\t/* 32-bit offset in static TLS block */\n#define R_TILEGX_TLS_GD_CALL\t112\t/* \"jal\" for TLS GD */\n#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113\t/* X0 pipe \"addi\" for TLS GD */\n#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114\t/* X1 pipe \"addi\" for TLS GD */\n#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115\t/* Y0 pipe \"addi\" for TLS GD */\n#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116\t/* Y1 pipe \"addi\" for TLS GD */\n#define R_TILEGX_TLS_IE_LOAD\t117\t/* \"ld_tls\" for TLS IE */\n#define R_TILEGX_IMM8_X0_TLS_ADD 118\t/* X0 pipe \"addi\" for TLS GD/IE */\n#define R_TILEGX_IMM8_X1_TLS_ADD 119\t/* X1 pipe \"addi\" for TLS GD/IE */\n#define R_TILEGX_IMM8_Y0_TLS_ADD 120\t/* Y0 pipe \"addi\" for TLS GD/IE */\n#define R_TILEGX_IMM8_Y1_TLS_ADD 121\t/* Y1 pipe \"addi\" for TLS GD/IE */\n\n#define R_TILEGX_GNU_VTINHERIT\t128\t/* GNU C++ vtable hierarchy */\n#define R_TILEGX_GNU_VTENTRY\t129\t/* GNU C++ vtable member usage */\n\n#define R_TILEGX_NUM\t\t130\n\n/* RISC-V ELF Flags */\n#define EF_RISCV_RVC \t\t\t0x0001\n#define EF_RISCV_FLOAT_ABI \t\t0x0006\n#define EF_RISCV_FLOAT_ABI_SOFT \t0x0000\n#define EF_RISCV_FLOAT_ABI_SINGLE \t0x0002\n#define EF_RISCV_FLOAT_ABI_DOUBLE \t0x0004\n#define EF_RISCV_FLOAT_ABI_QUAD \t0x0006\n\n/* RISC-V relocations.  */\n#define R_RISCV_NONE\t\t 0\n#define R_RISCV_32\t\t 1\n#define R_RISCV_64\t\t 2\n#define R_RISCV_RELATIVE\t 3\n#define R_RISCV_COPY\t\t 4\n#define R_RISCV_JUMP_SLOT\t 5\n#define R_RISCV_TLS_DTPMOD32\t 6\n#define R_RISCV_TLS_DTPMOD64\t 7\n#define R_RISCV_TLS_DTPREL32\t 8\n#define R_RISCV_TLS_DTPREL64\t 9\n#define R_RISCV_TLS_TPREL32\t10\n#define R_RISCV_TLS_TPREL64\t11\n#define R_RISCV_BRANCH\t\t16\n#define R_RISCV_JAL\t\t17\n#define R_RISCV_CALL\t\t18\n#define R_RISCV_CALL_PLT\t19\n#define R_RISCV_GOT_HI20\t20\n#define R_RISCV_TLS_GOT_HI20\t21\n#define R_RISCV_TLS_GD_HI20\t22\n#define R_RISCV_PCREL_HI20\t23\n#define R_RISCV_PCREL_LO12_I\t24\n#define R_RISCV_PCREL_LO12_S\t25\n#define R_RISCV_HI20\t\t26\n#define R_RISCV_LO12_I\t\t27\n#define R_RISCV_LO12_S\t\t28\n#define R_RISCV_TPREL_HI20\t29\n#define R_RISCV_TPREL_LO12_I\t30\n#define R_RISCV_TPREL_LO12_S\t31\n#define R_RISCV_TPREL_ADD\t32\n#define R_RISCV_ADD8\t\t33\n#define R_RISCV_ADD16\t\t34\n#define R_RISCV_ADD32\t\t35\n#define R_RISCV_ADD64\t\t36\n#define R_RISCV_SUB8\t\t37\n#define R_RISCV_SUB16\t\t38\n#define R_RISCV_SUB32\t\t39\n#define R_RISCV_SUB64\t\t40\n#define R_RISCV_GNU_VTINHERIT\t41\n#define R_RISCV_GNU_VTENTRY\t42\n#define R_RISCV_ALIGN\t\t43\n#define R_RISCV_RVC_BRANCH\t44\n#define R_RISCV_RVC_JUMP\t45\n#define R_RISCV_RVC_LUI\t\t46\n#define R_RISCV_GPREL_I\t\t47\n#define R_RISCV_GPREL_S\t\t48\n#define R_RISCV_TPREL_I\t\t49\n#define R_RISCV_TPREL_S\t\t50\n#define R_RISCV_RELAX\t\t51\n#define R_RISCV_SUB6\t\t52\n#define R_RISCV_SET6\t\t53\n#define R_RISCV_SET8\t\t54\n#define R_RISCV_SET16\t\t55\n#define R_RISCV_SET32\t\t56\n#define R_RISCV_32_PCREL\t57\n\n#define R_RISCV_NUM\t\t58\n\n\n#endif\t/* elf.h */\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "i386-asm.c",
          "type": "blob",
          "size": 51.6572265625,
          "content": "/*\n *  i386 specific functions for TCC assembler\n *\n *  Copyright (c) 2001, 2002 Fabrice Bellard\n *  Copyright (c) 2009 Frédéric Feret (x86_64 support)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define USING_GLOBALS\n#include \"tcc.h\"\n\n#define MAX_OPERANDS 3\n\n#define TOK_ASM_first TOK_ASM_clc\n#define TOK_ASM_last TOK_ASM_emms\n#define TOK_ASM_alllast TOK_ASM_subps\n\n#define OPC_B          0x01  /* only used with OPC_WL */\n#define OPC_WL         0x02  /* accepts w, l or no suffix */\n#define OPC_BWL        (OPC_B | OPC_WL) /* accepts b, w, l or no suffix */\n#define OPC_REG        0x04 /* register is added to opcode */\n#define OPC_MODRM      0x08 /* modrm encoding */\n\n#define OPCT_MASK      0x70\n#define OPC_FWAIT      0x10 /* add fwait opcode */\n#define OPC_SHIFT      0x20 /* shift opcodes */\n#define OPC_ARITH      0x30 /* arithmetic opcodes */\n#define OPC_FARITH     0x40 /* FPU arithmetic opcodes */\n#define OPC_TEST       0x50 /* test opcodes */\n#define OPC_0F01       0x60 /* 0x0f01XX (group 7, XX is 2nd opcode,\n                               no operands and unstructured mod/rm) */\n#define OPCT_IS(v,i) (((v) & OPCT_MASK) == (i))\n\n#define OPC_0F        0x100 /* Is secondary map (0x0f prefix) */\n#define OPC_48        0x200 /* Always has REX prefix */\n#ifdef TCC_TARGET_X86_64\n# define OPC_WLQ     0x1000  /* accepts w, l, q or no suffix */\n# define OPC_BWLQ    (OPC_B | OPC_WLQ) /* accepts b, w, l, q or no suffix */\n# define OPC_WLX     OPC_WLQ\n# define OPC_BWLX    OPC_BWLQ\n#else\n# define OPC_WLX     OPC_WL\n# define OPC_BWLX    OPC_BWL\n#endif\n\n#define OPC_GROUP_SHIFT 13\n\n/* in order to compress the operand type, we use specific operands and\n   we or only with EA  */\nenum {\n    OPT_REG8=0, /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_REG16,  /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_REG32,  /* warning: value is hardcoded from TOK_ASM_xxx */\n#ifdef TCC_TARGET_X86_64\n    OPT_REG64,  /* warning: value is hardcoded from TOK_ASM_xxx */\n#endif\n    OPT_MMX,    /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_SSE,    /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_CR,     /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_TR,     /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_DB,     /* warning: value is hardcoded from TOK_ASM_xxx */\n    OPT_SEG,\n    OPT_ST,\n#ifdef TCC_TARGET_X86_64\n    OPT_REG8_LOW, /* %spl,%bpl,%sil,%dil, encoded like ah,ch,dh,bh, but\n\t\t     with REX prefix, not used in insn templates */\n#endif\n    OPT_IM8,\n    OPT_IM8S,\n    OPT_IM16,\n    OPT_IM32,\n#ifdef TCC_TARGET_X86_64\n    OPT_IM64,\n#endif\n    OPT_EAX,    /* %al, %ax, %eax or %rax register */\n    OPT_ST0,    /* %st(0) register */\n    OPT_CL,     /* %cl register */\n    OPT_DX,     /* %dx register */\n    OPT_ADDR,   /* OP_EA with only offset */\n    OPT_INDIR,  /* *(expr) */\n    /* composite types */\n    OPT_COMPOSITE_FIRST,\n    OPT_IM,     /* IM8 | IM16 | IM32 */\n    OPT_REG,    /* REG8 | REG16 | REG32 | REG64 */\n    OPT_REGW,   /* REG16 | REG32 | REG64 */\n    OPT_IMW,    /* IM16 | IM32 */\n    OPT_MMXSSE, /* MMX | SSE */\n    OPT_DISP,   /* Like OPT_ADDR, but emitted as displacement (for jumps) */\n    OPT_DISP8,  /* Like OPT_ADDR, but only 8bit (short jumps) */\n    /* can be ored with any OPT_xxx */\n    OPT_EA = 0x80\n};\n\n#define OP_REG8   (1 << OPT_REG8)\n#define OP_REG16  (1 << OPT_REG16)\n#define OP_REG32  (1 << OPT_REG32)\n#define OP_MMX    (1 << OPT_MMX)\n#define OP_SSE    (1 << OPT_SSE)\n#define OP_CR     (1 << OPT_CR)\n#define OP_TR     (1 << OPT_TR)\n#define OP_DB     (1 << OPT_DB)\n#define OP_SEG    (1 << OPT_SEG)\n#define OP_ST     (1 << OPT_ST)\n#define OP_IM8    (1 << OPT_IM8)\n#define OP_IM8S   (1 << OPT_IM8S)\n#define OP_IM16   (1 << OPT_IM16)\n#define OP_IM32   (1 << OPT_IM32)\n#define OP_EAX    (1 << OPT_EAX)\n#define OP_ST0    (1 << OPT_ST0)\n#define OP_CL     (1 << OPT_CL)\n#define OP_DX     (1 << OPT_DX)\n#define OP_ADDR   (1 << OPT_ADDR)\n#define OP_INDIR  (1 << OPT_INDIR)\n#ifdef TCC_TARGET_X86_64\n# define OP_REG64 (1 << OPT_REG64)\n# define OP_REG8_LOW (1 << OPT_REG8_LOW)\n# define OP_IM64  (1 << OPT_IM64)\n# define OP_EA32  (OP_EA << 1)\n#else\n# define OP_REG64 0\n# define OP_REG8_LOW 0\n# define OP_IM64  0\n# define OP_EA32  0\n#endif\n\n#define OP_EA     0x40000000\n#define OP_REG    (OP_REG8 | OP_REG16 | OP_REG32 | OP_REG64)\n\n#ifdef TCC_TARGET_X86_64\n# define TREG_XAX   TREG_RAX\n# define TREG_XCX   TREG_RCX\n# define TREG_XDX   TREG_RDX\n# define TOK_ASM_xax TOK_ASM_rax\n#else\n# define TREG_XAX   TREG_EAX\n# define TREG_XCX   TREG_ECX\n# define TREG_XDX   TREG_EDX\n# define TOK_ASM_xax TOK_ASM_eax\n#endif\n\ntypedef struct ASMInstr {\n    uint16_t sym;\n    uint16_t opcode;\n    uint16_t instr_type;\n    uint8_t nb_ops;\n    uint8_t op_type[MAX_OPERANDS]; /* see OP_xxx */\n} ASMInstr;\n\ntypedef struct Operand {\n    uint32_t type;\n    int8_t  reg; /* register, -1 if none */\n    int8_t  reg2; /* second register, -1 if none */\n    uint8_t shift;\n    ExprValue e;\n} Operand;\n\nstatic const uint8_t reg_to_size[9] = {\n/*\n    [OP_REG8] = 0,\n    [OP_REG16] = 1,\n    [OP_REG32] = 2,\n#ifdef TCC_TARGET_X86_64\n    [OP_REG64] = 3,\n#endif\n*/\n    0, 0, 1, 0, 2, 0, 0, 0, 3\n};\n\n#define NB_TEST_OPCODES 30\n\nstatic const uint8_t test_bits[NB_TEST_OPCODES] = {\n 0x00, /* o */\n 0x01, /* no */\n 0x02, /* b */\n 0x02, /* c */\n 0x02, /* nae */\n 0x03, /* nb */\n 0x03, /* nc */\n 0x03, /* ae */\n 0x04, /* e */\n 0x04, /* z */\n 0x05, /* ne */\n 0x05, /* nz */\n 0x06, /* be */\n 0x06, /* na */\n 0x07, /* nbe */\n 0x07, /* a */\n 0x08, /* s */\n 0x09, /* ns */\n 0x0a, /* p */\n 0x0a, /* pe */\n 0x0b, /* np */\n 0x0b, /* po */\n 0x0c, /* l */\n 0x0c, /* nge */\n 0x0d, /* nl */\n 0x0d, /* ge */\n 0x0e, /* le */\n 0x0e, /* ng */\n 0x0f, /* nle */\n 0x0f, /* g */\n};\n\nstatic const uint8_t segment_prefixes[] = {\n 0x26, /* es */\n 0x2e, /* cs */\n 0x36, /* ss */\n 0x3e, /* ds */\n 0x64, /* fs */\n 0x65  /* gs */\n};\n\nstatic const ASMInstr asm_instrs[] = {\n#define ALT(x) x\n/* This removes a 0x0f in the second byte */\n#define O(o) ((uint64_t) ((((o) & 0xff00) == 0x0f00) ? ((((o) >> 8) & ~0xff) | ((o) & 0xff)) : (o)))\n/* This constructs instr_type from opcode, type and group.  */\n#define T(o,i,g) ((i) | ((g) << OPC_GROUP_SHIFT) | ((((o) & 0xff00) == 0x0f00) ? OPC_0F : 0))\n#define DEF_ASM_OP0(name, opcode)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 0, { 0 } },\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 1, { op0 }},\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 2, { op0, op1 }},\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 3, { op0, op1, op2 }},\n#ifdef TCC_TARGET_X86_64\n# include \"x86_64-asm.h\"\n#else\n# include \"i386-asm.h\"\n#endif\n    /* last operation */\n    { 0, },\n};\n\nstatic const uint16_t op0_codes[] = {\n#define ALT(x)\n#define DEF_ASM_OP0(x, opcode) opcode,\n#define DEF_ASM_OP0L(name, opcode, group, instr_type)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)\n#ifdef TCC_TARGET_X86_64\n# include \"x86_64-asm.h\"\n#else\n# include \"i386-asm.h\"\n#endif\n};\n\nstatic inline int get_reg_shift(TCCState *s1)\n{\n    int shift, v;\n    v = asm_int_expr(s1);\n    switch(v) {\n    case 1:\n        shift = 0;\n        break;\n    case 2:\n        shift = 1;\n        break;\n    case 4:\n        shift = 2;\n        break;\n    case 8:\n        shift = 3;\n        break;\n    default:\n        expect(\"1, 2, 4 or 8 constant\");\n        shift = 0;\n        break;\n    }\n    return shift;\n}\n\n#ifdef TCC_TARGET_X86_64\nstatic int asm_parse_numeric_reg(int t, unsigned int *type)\n{\n    int reg = -1;\n    if (t >= TOK_IDENT && t < tok_ident) {\n\tconst char *s = table_ident[t - TOK_IDENT]->str;\n\tchar c;\n\t*type = OP_REG64;\n\tif (*s == 'c') {\n\t    s++;\n\t    *type = OP_CR;\n\t}\n\tif (*s++ != 'r')\n\t  return -1;\n\t/* Don't allow leading '0'.  */\n\tif ((c = *s++) >= '1' && c <= '9')\n\t  reg = c - '0';\n\telse\n\t  return -1;\n\tif ((c = *s) >= '0' && c <= '5')\n\t  s++, reg = reg * 10 + c - '0';\n\tif (reg > 15)\n\t  return -1;\n\tif ((c = *s) == 0)\n\t  ;\n\telse if (*type != OP_REG64)\n\t  return -1;\n\telse if (c == 'b' && !s[1])\n\t  *type = OP_REG8;\n\telse if (c == 'w' && !s[1])\n\t  *type = OP_REG16;\n\telse if (c == 'd' && !s[1])\n\t  *type = OP_REG32;\n\telse\n\t  return -1;\n    }\n    return reg;\n}\n#endif\n\nstatic int asm_parse_reg(unsigned int *type)\n{\n    int reg = 0;\n    *type = 0;\n    if (tok != '%')\n        goto error_32;\n    next();\n    if (tok >= TOK_ASM_eax && tok <= TOK_ASM_edi) {\n        reg = tok - TOK_ASM_eax;\n\t*type = OP_REG32;\n#ifdef TCC_TARGET_X86_64\n    } else if (tok >= TOK_ASM_rax && tok <= TOK_ASM_rdi) {\n        reg = tok - TOK_ASM_rax;\n\t*type = OP_REG64;\n    } else if (tok == TOK_ASM_rip) {\n        reg = -2; /* Probably should use different escape code. */\n\t*type = OP_REG64;\n    } else if ((reg = asm_parse_numeric_reg(tok, type)) >= 0\n\t       && (*type == OP_REG32 || *type == OP_REG64)) {\n\t;\n#endif\n    } else {\n    error_32:\n        expect(\"register\");\n    }\n    next();\n    return reg;\n}\n\nstatic void parse_operand(TCCState *s1, Operand *op)\n{\n    ExprValue e;\n    int reg, indir;\n    const char *p;\n\n    indir = 0;\n    if (tok == '*') {\n        next();\n        indir = OP_INDIR;\n    }\n\n    if (tok == '%') {\n        next();\n        if (tok >= TOK_ASM_al && tok <= TOK_ASM_db7) {\n            reg = tok - TOK_ASM_al;\n            op->type = 1 << (reg >> 3); /* WARNING: do not change constant order */\n            op->reg = reg & 7;\n            if ((op->type & OP_REG) && op->reg == TREG_XAX)\n                op->type |= OP_EAX;\n            else if (op->type == OP_REG8 && op->reg == TREG_XCX)\n                op->type |= OP_CL;\n            else if (op->type == OP_REG16 && op->reg == TREG_XDX)\n                op->type |= OP_DX;\n        } else if (tok >= TOK_ASM_dr0 && tok <= TOK_ASM_dr7) {\n            op->type = OP_DB;\n            op->reg = tok - TOK_ASM_dr0;\n        } else if (tok >= TOK_ASM_es && tok <= TOK_ASM_gs) {\n            op->type = OP_SEG;\n            op->reg = tok - TOK_ASM_es;\n        } else if (tok == TOK_ASM_st) {\n            op->type = OP_ST;\n            op->reg = 0;\n            next();\n            if (tok == '(') {\n                next();\n                if (tok != TOK_PPNUM)\n                    goto reg_error;\n                p = tokc.str.data;\n                reg = p[0] - '0';\n                if ((unsigned)reg >= 8 || p[1] != '\\0')\n                    goto reg_error;\n                op->reg = reg;\n                next();\n                skip(')');\n            }\n            if (op->reg == 0)\n                op->type |= OP_ST0;\n            goto no_skip;\n#ifdef TCC_TARGET_X86_64\n\t} else if (tok >= TOK_ASM_spl && tok <= TOK_ASM_dil) {\n\t    op->type = OP_REG8 | OP_REG8_LOW;\n\t    op->reg = 4 + tok - TOK_ASM_spl;\n        } else if ((op->reg = asm_parse_numeric_reg(tok, &op->type)) >= 0) {\n\t    ;\n#endif\n        } else {\n        reg_error:\n            tcc_error(\"unknown register %%%s\", get_tok_str(tok, &tokc));\n        }\n        next();\n    no_skip: ;\n    } else if (tok == '$') {\n        /* constant value */\n        next();\n        asm_expr(s1, &e);\n        op->type = OP_IM32;\n        op->e = e;\n        if (!op->e.sym) {\n            if (op->e.v == (uint8_t)op->e.v)\n                op->type |= OP_IM8;\n            if (op->e.v == (int8_t)op->e.v)\n                op->type |= OP_IM8S;\n            if (op->e.v == (uint16_t)op->e.v)\n                op->type |= OP_IM16;\n#ifdef TCC_TARGET_X86_64\n            if (op->e.v != (int32_t)op->e.v && op->e.v != (uint32_t)op->e.v)\n                op->type = OP_IM64;\n#endif\n        }\n    } else {\n        /* address(reg,reg2,shift) with all variants */\n        op->type = OP_EA;\n        op->reg = -1;\n        op->reg2 = -1;\n        op->shift = 0;\n        if (tok != '(') {\n            asm_expr(s1, &e);\n            op->e = e;\n        } else {\n            next();\n            if (tok == '%') {\n                unget_tok('(');\n                op->e.v = 0;\n                op->e.sym = NULL;\n            } else {\n                /* bracketed offset expression */\n                asm_expr(s1, &e);\n                if (tok != ')')\n                    expect(\")\");\n                next();\n                op->e.v = e.v;\n                op->e.sym = e.sym;\n            }\n\t    op->e.pcrel = 0;\n        }\n        if (tok == '(') {\n\t    unsigned int type = 0;\n            next();\n            if (tok != ',') {\n                op->reg = asm_parse_reg(&type);\n            }\n            if (tok == ',') {\n                next();\n                if (tok != ',') {\n                    op->reg2 = asm_parse_reg(&type);\n                }\n                if (tok == ',') {\n                    next();\n                    op->shift = get_reg_shift(s1);\n                }\n            }\n\t    if (type & OP_REG32)\n\t        op->type |= OP_EA32;\n            skip(')');\n        }\n        if (op->reg == -1 && op->reg2 == -1)\n            op->type |= OP_ADDR;\n    }\n    op->type |= indir;\n}\n\n/* XXX: unify with C code output ? */\nST_FUNC void gen_expr32(ExprValue *pe)\n{\n    if (pe->pcrel)\n        /* If PC-relative, always set VT_SYM, even without symbol,\n\t   so as to force a relocation to be emitted.  */\n\tgen_addrpc32(VT_SYM, pe->sym, pe->v + (ind + 4));\n    else\n\tgen_addr32(pe->sym ? VT_SYM : 0, pe->sym, pe->v);\n}\n\n#ifdef TCC_TARGET_X86_64\nST_FUNC void gen_expr64(ExprValue *pe)\n{\n    gen_addr64(pe->sym ? VT_SYM : 0, pe->sym, pe->v);\n}\n#endif\n\n/* XXX: unify with C code output ? */\nstatic void gen_disp32(ExprValue *pe)\n{\n    Sym *sym = pe->sym;\n    ElfSym *esym = elfsym(sym);\n    if (esym && esym->st_shndx == cur_text_section->sh_num) {\n        /* same section: we can output an absolute value. Note\n           that the TCC compiler behaves differently here because\n           it always outputs a relocation to ease (future) code\n           elimination in the linker */\n        gen_le32(pe->v + esym->st_value - ind - 4);\n    } else {\n        if (sym && sym->type.t == VT_VOID) {\n            sym->type.t = VT_FUNC;\n            sym->type.ref = NULL;\n        }\n#ifdef TCC_TARGET_X86_64\n        greloca(cur_text_section, sym, ind, R_X86_64_PLT32, pe->v - 4);\n        gen_le32(0);\n#else\n        gen_addrpc32(VT_SYM, sym, pe->v);\n#endif\n\n    }\n}\n\n/* generate the modrm operand */\nstatic inline int asm_modrm(int reg, Operand *op)\n{\n    int mod, reg1, reg2, sib_reg1;\n\n    if (op->type & (OP_REG | OP_MMX | OP_SSE)) {\n        g(0xc0 + (reg << 3) + op->reg);\n    } else if (op->reg == -1 && op->reg2 == -1) {\n        /* displacement only */\n#ifdef TCC_TARGET_X86_64\n\tg(0x04 + (reg << 3));\n\tg(0x25);\n#else\n\tg(0x05 + (reg << 3));\n#endif\n\tgen_expr32(&op->e);\n#ifdef TCC_TARGET_X86_64\n    } else if (op->reg == -2) {\n        ExprValue *pe = &op->e;\n        g(0x05 + (reg << 3));\n        gen_addrpc32(pe->sym ? VT_SYM : 0, pe->sym, pe->v);\n        return ind;\n#endif\n    } else {\n        sib_reg1 = op->reg;\n        /* fist compute displacement encoding */\n        if (sib_reg1 == -1) {\n            sib_reg1 = 5;\n            mod = 0x00;\n        } else if (op->e.v == 0 && !op->e.sym && op->reg != 5) {\n            mod = 0x00;\n        } else if (op->e.v == (int8_t)op->e.v && !op->e.sym) {\n            mod = 0x40;\n        } else {\n            mod = 0x80;\n        }\n        /* compute if sib byte needed */\n        reg1 = op->reg;\n        if (op->reg2 != -1)\n            reg1 = 4;\n        g(mod + (reg << 3) + reg1);\n        if (reg1 == 4) {\n            /* add sib byte */\n            reg2 = op->reg2;\n            if (reg2 == -1)\n                reg2 = 4; /* indicate no index */\n            g((op->shift << 6) + (reg2 << 3) + sib_reg1);\n        }\n        /* add offset */\n        if (mod == 0x40) {\n            g(op->e.v);\n        } else if (mod == 0x80 || op->reg == -1) {\n\t    gen_expr32(&op->e);\n        }\n    }\n    return 0;\n}\n\n#ifdef TCC_TARGET_X86_64\n#define REX_W 0x48\n#define REX_R 0x44\n#define REX_X 0x42\n#define REX_B 0x41\n\nstatic void asm_rex(int width64, Operand *ops, int nb_ops, int *op_type,\n\t\t    int regi, int rmi)\n{\n  unsigned char rex = width64 ? 0x48 : 0;\n  int saw_high_8bit = 0;\n  int i;\n  if (rmi == -1) {\n      /* No mod/rm byte, but we might have a register op nevertheless\n         (we will add it to the opcode later).  */\n      for(i = 0; i < nb_ops; i++) {\n\t  if (op_type[i] & (OP_REG | OP_ST)) {\n\t      if (ops[i].reg >= 8) {\n\t\t  rex |= REX_B;\n\t\t  ops[i].reg -= 8;\n\t      } else if (ops[i].type & OP_REG8_LOW)\n\t\t  rex |= 0x40;\n\t      else if (ops[i].type & OP_REG8 && ops[i].reg >= 4)\n\t\t  /* An 8 bit reg >= 4 without REG8 is ah/ch/dh/bh */\n\t\t  saw_high_8bit = ops[i].reg;\n\t      break;\n\t  }\n      }\n  } else {\n      if (regi != -1) {\n\t  if (ops[regi].reg >= 8) {\n\t      rex |= REX_R;\n\t      ops[regi].reg -= 8;\n\t  } else if (ops[regi].type & OP_REG8_LOW)\n\t      rex |= 0x40;\n\t  else if (ops[regi].type & OP_REG8 && ops[regi].reg >= 4)\n\t      /* An 8 bit reg >= 4 without REG8 is ah/ch/dh/bh */\n\t      saw_high_8bit = ops[regi].reg;\n      }\n      if (ops[rmi].type & (OP_REG | OP_MMX | OP_SSE | OP_CR | OP_EA)) {\n\t  if (ops[rmi].reg >= 8) {\n\t      rex |= REX_B;\n\t      ops[rmi].reg -= 8;\n\t  } else if (ops[rmi].type & OP_REG8_LOW)\n\t      rex |= 0x40;\n\t  else if (ops[rmi].type & OP_REG8 && ops[rmi].reg >= 4)\n\t      /* An 8 bit reg >= 4 without REG8 is ah/ch/dh/bh */\n\t      saw_high_8bit = ops[rmi].reg;\n      }\n      if (ops[rmi].type & OP_EA && ops[rmi].reg2 >= 8) {\n\t  rex |= REX_X;\n\t  ops[rmi].reg2 -= 8;\n      }\n  }\n  if (rex) {\n      if (saw_high_8bit)\n\t  tcc_error(\"can't encode register %%%ch when REX prefix is required\",\n\t\t    \"acdb\"[saw_high_8bit-4]);\n      g(rex);\n  }\n}\n#endif\n\n\nstatic void maybe_print_stats (void)\n{\n    static int already;\n\n    if (0 && !already)\n    /* print stats about opcodes */\n    {\n        const struct ASMInstr *pa;\n        int freq[4];\n        int op_vals[500];\n        int nb_op_vals, i, j;\n\n\talready = 1;\n        nb_op_vals = 0;\n        memset(freq, 0, sizeof(freq));\n        for(pa = asm_instrs; pa->sym != 0; pa++) {\n            freq[pa->nb_ops]++;\n            //for(i=0;i<pa->nb_ops;i++) {\n                for(j=0;j<nb_op_vals;j++) {\n                    //if (pa->op_type[i] == op_vals[j])\n                    if (pa->instr_type == op_vals[j])\n                        goto found;\n                }\n                //op_vals[nb_op_vals++] = pa->op_type[i];\n                op_vals[nb_op_vals++] = pa->instr_type;\n            found: ;\n            //}\n        }\n        for(i=0;i<nb_op_vals;i++) {\n            int v = op_vals[i];\n            //if ((v & (v - 1)) != 0)\n                printf(\"%3d: %08x\\n\", i, v);\n        }\n        printf(\"size=%d nb=%d f0=%d f1=%d f2=%d f3=%d\\n\",\n               (int)sizeof(asm_instrs),\n\t       (int)sizeof(asm_instrs) / (int)sizeof(ASMInstr),\n               freq[0], freq[1], freq[2], freq[3]);\n    }\n}\n\nST_FUNC void asm_opcode(TCCState *s1, int opcode)\n{\n    const ASMInstr *pa;\n    int i, modrm_index, modreg_index, reg, v, op1, seg_prefix, pc, p;\n    int nb_ops, s;\n    Operand ops[MAX_OPERANDS], *pop;\n    int op_type[3]; /* decoded op type */\n    int alltypes;   /* OR of all operand types */\n    int autosize;\n    int p66;\n#ifdef TCC_TARGET_X86_64\n    int rex64;\n#endif\n\n    maybe_print_stats();\n    /* force synthetic ';' after prefix instruction, so we can handle */\n    /* one-line things like \"rep stosb\" instead of only \"rep\\nstosb\" */\n    if (opcode >= TOK_ASM_wait && opcode <= TOK_ASM_repnz)\n        unget_tok(';');\n\n    /* get operands */\n    pop = ops;\n    nb_ops = 0;\n    seg_prefix = 0;\n    alltypes = 0;\n    for(;;) {\n        if (tok == ';' || tok == TOK_LINEFEED)\n            break;\n        if (nb_ops >= MAX_OPERANDS) {\n            tcc_error(\"incorrect number of operands\");\n        }\n        parse_operand(s1, pop);\n        if (tok == ':') {\n           if (pop->type != OP_SEG || seg_prefix)\n               tcc_error(\"incorrect prefix\");\n           seg_prefix = segment_prefixes[pop->reg];\n           next();\n           parse_operand(s1, pop);\n           if (!(pop->type & OP_EA)) {\n               tcc_error(\"segment prefix must be followed by memory reference\");\n           }\n        }\n        pop++;\n        nb_ops++;\n        if (tok != ',')\n            break;\n        next();\n    }\n\n    s = 0; /* avoid warning */\n\nagain:\n    /* optimize matching by using a lookup table (no hashing is needed\n       !) */\n    for(pa = asm_instrs; pa->sym != 0; pa++) {\n\tint it = pa->instr_type & OPCT_MASK;\n        s = 0;\n        if (it == OPC_FARITH) {\n            v = opcode - pa->sym;\n            if (!((unsigned)v < 8 * 6 && (v % 6) == 0))\n                continue;\n        } else if (it == OPC_ARITH) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + 8*NBWLX))\n                continue;\n            s = (opcode - pa->sym) % NBWLX;\n\t    if ((pa->instr_type & OPC_BWLX) == OPC_WLX)\n\t      {\n\t\t/* We need to reject the xxxb opcodes that we accepted above.\n\t\t   Note that pa->sym for WLX opcodes is the 'w' token,\n\t\t   to get the 'b' token subtract one.  */\n\t\tif (((opcode - pa->sym + 1) % NBWLX) == 0)\n\t\t    continue;\n\t        s++;\n\t      }\n        } else if (it == OPC_SHIFT) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + 7*NBWLX))\n                continue;\n            s = (opcode - pa->sym) % NBWLX;\n        } else if (it == OPC_TEST) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + NB_TEST_OPCODES))\n                continue;\n\t    /* cmovxx is a test opcode but accepts multiple sizes.\n\t       The suffixes aren't encoded in the table, instead we\n\t       simply force size autodetection always and deal with suffixed\n\t       variants below when we don't find e.g. \"cmovzl\".  */\n\t    if (pa->instr_type & OPC_WLX)\n\t        s = NBWLX - 1;\n        } else if (pa->instr_type & OPC_B) {\n#ifdef TCC_TARGET_X86_64\n\t    /* Some instructions don't have the full size but only\n\t       bwl form.  insb e.g. */\n\t    if ((pa->instr_type & OPC_WLQ) != OPC_WLQ\n\t\t&& !(opcode >= pa->sym && opcode < pa->sym + NBWLX-1))\n\t        continue;\n#endif\n            if (!(opcode >= pa->sym && opcode < pa->sym + NBWLX))\n                continue;\n            s = opcode - pa->sym;\n        } else if (pa->instr_type & OPC_WLX) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + NBWLX-1))\n                continue;\n            s = opcode - pa->sym + 1;\n        } else {\n            if (pa->sym != opcode)\n                continue;\n        }\n        if (pa->nb_ops != nb_ops)\n            continue;\n#ifdef TCC_TARGET_X86_64\n\t/* Special case for moves.  Selecting the IM64->REG64 form\n\t   should only be done if we really have an >32bit imm64, and that\n\t   is hardcoded.  Ignore it here.  */\n\tif (pa->opcode == 0xb0 && ops[0].type != OP_IM64\n\t    && (ops[1].type & OP_REG) == OP_REG64\n\t    && !(pa->instr_type & OPC_0F))\n\t    continue;\n#endif\n        /* now decode and check each operand */\n\talltypes = 0;\n        for(i = 0; i < nb_ops; i++) {\n            int op1, op2;\n            op1 = pa->op_type[i];\n            op2 = op1 & 0x1f;\n            switch(op2) {\n            case OPT_IM:\n                v = OP_IM8 | OP_IM16 | OP_IM32;\n                break;\n            case OPT_REG:\n                v = OP_REG8 | OP_REG16 | OP_REG32 | OP_REG64;\n                break;\n            case OPT_REGW:\n                v = OP_REG16 | OP_REG32 | OP_REG64;\n                break;\n            case OPT_IMW:\n                v = OP_IM16 | OP_IM32;\n                break;\n\t    case OPT_MMXSSE:\n\t\tv = OP_MMX | OP_SSE;\n\t\tbreak;\n\t    case OPT_DISP:\n\t    case OPT_DISP8:\n\t\tv = OP_ADDR;\n\t\tbreak;\n            default:\n                v = 1 << op2;\n                break;\n            }\n            if (op1 & OPT_EA)\n                v |= OP_EA;\n\t    op_type[i] = v;\n            if ((ops[i].type & v) == 0)\n                goto next;\n\t    alltypes |= ops[i].type;\n        }\n        (void)alltypes; /* maybe unused */\n        /* all is matching ! */\n        break;\n    next: ;\n    }\n    if (pa->sym == 0) {\n        if (opcode >= TOK_ASM_first && opcode <= TOK_ASM_last) {\n            int b;\n            b = op0_codes[opcode - TOK_ASM_first];\n            if (b & 0xff00) \n                g(b >> 8);\n            g(b);\n            return;\n        } else if (opcode <= TOK_ASM_alllast) {\n            tcc_error(\"bad operand with opcode '%s'\",\n                  get_tok_str(opcode, NULL));\n        } else {\n\t    /* Special case for cmovcc, we accept size suffixes but ignore\n\t       them, but we don't want them to blow up our tables.  */\n\t    TokenSym *ts = table_ident[opcode - TOK_IDENT];\n\t    if (ts->len >= 6\n\t\t&& strchr(\"wlq\", ts->str[ts->len-1])\n\t\t&& !memcmp(ts->str, \"cmov\", 4)) {\n\t\topcode = tok_alloc(ts->str, ts->len-1)->tok;\n\t\tgoto again;\n\t    }\n            tcc_error(\"unknown opcode '%s'\", ts->str);\n        }\n    }\n    /* if the size is unknown, then evaluate it (OPC_B or OPC_WL case) */\n    autosize = NBWLX-1;\n#ifdef TCC_TARGET_X86_64\n    /* XXX the autosize should rather be zero, to not have to adjust this\n       all the time.  */\n    if ((pa->instr_type & OPC_BWLQ) == OPC_B)\n        autosize = NBWLX-2;\n#endif\n    if (s == autosize) {\n\t/* Check for register operands providing hints about the size.\n\t   Start from the end, i.e. destination operands.  This matters\n\t   only for opcodes accepting different sized registers, lar and lsl\n\t   are such opcodes.  */\n        for(i = nb_ops - 1; s == autosize && i >= 0; i--) {\n            if ((ops[i].type & OP_REG) && !(op_type[i] & (OP_CL | OP_DX)))\n                s = reg_to_size[ops[i].type & OP_REG];\n        }\n        if (s == autosize) {\n            if ((opcode == TOK_ASM_push || opcode == TOK_ASM_pop) &&\n                (ops[0].type & (OP_SEG | OP_IM8S | OP_IM32)))\n                s = 2;\n\t    else if ((opcode == TOK_ASM_push || opcode == TOK_ASM_pop) &&\n\t\t     (ops[0].type & OP_EA))\n\t        s = NBWLX - 2;\n            else\n                tcc_error(\"cannot infer opcode suffix\");\n        }\n    }\n\n#ifdef TCC_TARGET_X86_64\n    rex64 = 0;\n    if (pa->instr_type & OPC_48)\n        rex64 = 1;\n    else if (s == 3 || (alltypes & OP_REG64)) {\n        /* generate REX prefix */\n\tint default64 = 0;\n\tfor(i = 0; i < nb_ops; i++) {\n\t    if (op_type[i] == OP_REG64 && pa->opcode != 0xb8) {\n\t\t/* If only 64bit regs are accepted in one operand\n\t\t   this is a default64 instruction without need for\n\t\t   REX prefixes, except for movabs(0xb8).  */\n\t\tdefault64 = 1;\n\t\tbreak;\n\t    }\n\t}\n\t/* XXX find better encoding for the default64 instructions.  */\n        if (((opcode != TOK_ASM_push && opcode != TOK_ASM_pop\n\t      && opcode != TOK_ASM_pushw && opcode != TOK_ASM_pushl\n\t      && opcode != TOK_ASM_pushq && opcode != TOK_ASM_popw\n\t      && opcode != TOK_ASM_popl && opcode != TOK_ASM_popq\n\t      && opcode != TOK_ASM_call && opcode != TOK_ASM_jmp))\n\t    && !default64)\n            rex64 = 1;\n    }\n#endif\n\n    /* now generates the operation */\n    if (OPCT_IS(pa->instr_type, OPC_FWAIT))\n        g(0x9b);\n    if (seg_prefix)\n        g(seg_prefix);\n#ifdef TCC_TARGET_X86_64\n    /* Generate addr32 prefix if needed */\n    for(i = 0; i < nb_ops; i++) {\n        if (ops[i].type & OP_EA32) {\n\t    g(0x67);\n\t    break;\n        }\n    }\n#endif\n    /* generate data16 prefix if needed */\n    p66 = 0;\n    if (s == 1)\n        p66 = 1;\n    else {\n\t/* accepting mmx+sse in all operands --> needs 0x66 to\n\t   switch to sse mode.  Accepting only sse in an operand --> is\n\t   already SSE insn and needs 0x66/f2/f3 handling.  */\n        for (i = 0; i < nb_ops; i++)\n            if ((op_type[i] & (OP_MMX | OP_SSE)) == (OP_MMX | OP_SSE)\n\t        && ops[i].type & OP_SSE)\n\t        p66 = 1;\n    }\n    if (p66)\n        g(0x66);\n\n    v = pa->opcode;\n    p = v >> 8;  /* possibly prefix byte(s) */\n    switch (p) {\n        case 0: break;  /* no prefix */\n        case 0x48: break; /* REX, handled elsewhere */\n        case 0x66:\n        case 0x67:\n        case 0xf2:\n        case 0xf3: v = v & 0xff; g(p); break;\n        case 0xd4: case 0xd5: break; /* aam and aad, not prefix, but hardcoded immediate argument \"10\" */\n        case 0xd8: case 0xd9: case 0xda: case 0xdb: /* x87, no normal prefix */\n        case 0xdc: case 0xdd: case 0xde: case 0xdf: break;\n        default: tcc_error(\"bad prefix 0x%2x in opcode table\", p); break;\n    }\n    if (pa->instr_type & OPC_0F)\n        v = ((v & ~0xff) << 8) | 0x0f00 | (v & 0xff);\n    if ((v == 0x69 || v == 0x6b) && nb_ops == 2) {\n        /* kludge for imul $im, %reg */\n        nb_ops = 3;\n        ops[2] = ops[1];\n        op_type[2] = op_type[1];\n    } else if (v == 0xcd && ops[0].e.v == 3 && !ops[0].e.sym) {\n        v--; /* int $3 case */\n        nb_ops = 0;\n    } else if ((v == 0x06 || v == 0x07)) {\n        if (ops[0].reg >= 4) {\n            /* push/pop %fs or %gs */\n            v = 0x0fa0 + (v - 0x06) + ((ops[0].reg - 4) << 3);\n        } else {\n            v += ops[0].reg << 3;\n        }\n        nb_ops = 0;\n    } else if (v <= 0x05) {\n        /* arith case */\n        v += ((opcode - TOK_ASM_addb) / NBWLX) << 3;\n    } else if ((pa->instr_type & (OPCT_MASK | OPC_MODRM)) == OPC_FARITH) {\n        /* fpu arith case */\n        v += ((opcode - pa->sym) / 6) << 3;\n    }\n\n    /* search which operand will be used for modrm */\n    modrm_index = -1;\n    modreg_index = -1;\n    if (pa->instr_type & OPC_MODRM) {\n#ifdef TCC_TARGET_X86_64\n\tif (!nb_ops) {\n\t    /* A modrm opcode without operands is a special case (e.g. mfence).\n\t       It has a group and acts as if there's an register operand 0 */\n\t    i = 0;\n\t    ops[i].type = OP_REG;\n\t    if (pa->sym == TOK_ASM_endbr64)\n\t      ops[i].reg = 2; // dx\n\t    else if (pa->sym >= TOK_ASM_lfence && pa->sym <= TOK_ASM_sfence)\n  \t      ops[i].reg = 0; // ax\n\t    else\n\t      tcc_error(\"bad MODR/M opcode without operands\");\n\t    goto modrm_found;\n\t}\n#endif\n        /* first look for an ea operand */\n        for(i = 0;i < nb_ops; i++) {\n            if (op_type[i] & OP_EA)\n                goto modrm_found;\n        }\n        /* then if not found, a register or indirection (shift instructions) */\n        for(i = 0;i < nb_ops; i++) {\n            if (op_type[i] & (OP_REG | OP_MMX | OP_SSE | OP_INDIR))\n                goto modrm_found;\n        }\n#ifdef ASM_DEBUG\n        tcc_error(\"bad op table\");\n#endif\n    modrm_found:\n        modrm_index = i;\n        /* if a register is used in another operand then it is\n           used instead of group */\n        for(i = 0;i < nb_ops; i++) {\n            int t = op_type[i];\n            if (i != modrm_index &&\n                (t & (OP_REG | OP_MMX | OP_SSE | OP_CR | OP_TR | OP_DB | OP_SEG))) {\n                modreg_index = i;\n                break;\n            }\n        }\n    }\n#ifdef TCC_TARGET_X86_64\n    asm_rex (rex64, ops, nb_ops, op_type, modreg_index, modrm_index);\n#endif\n\n    if (pa->instr_type & OPC_REG) {\n        /* mov $im, %reg case */\n        if (v == 0xb0 && s >= 1)\n            v += 7;\n        for(i = 0; i < nb_ops; i++) {\n            if (op_type[i] & (OP_REG | OP_ST)) {\n                v += ops[i].reg;\n                break;\n            }\n        }\n    }\n    if (pa->instr_type & OPC_B)\n        v += s >= 1;\n    if (nb_ops == 1 && pa->op_type[0] == OPT_DISP8) {\n\tElfSym *esym;\n        int jmp_disp;\n\n        /* see if we can really generate the jump with a byte offset */\n\tesym = elfsym(ops[0].e.sym);\n        if (!esym || esym->st_shndx != cur_text_section->sh_num)\n            goto no_short_jump;\n        jmp_disp = ops[0].e.v + esym->st_value - ind - 2 - (v >= 0xff);\n        if (jmp_disp == (int8_t)jmp_disp) {\n            /* OK to generate jump */\n\t    ops[0].e.sym = 0;\n            ops[0].e.v = jmp_disp;\n\t    op_type[0] = OP_IM8S;\n        } else {\n        no_short_jump:\n\t    /* long jump will be allowed. need to modify the\n\t       opcode slightly */\n\t    if (v == 0xeb) /* jmp */\n\t        v = 0xe9;\n\t    else if (v == 0x70) /* jcc */\n\t        v += 0x0f10;\n\t    else\n\t        tcc_error(\"invalid displacement\");\n        }\n    }\n    if (OPCT_IS(pa->instr_type, OPC_TEST))\n        v += test_bits[opcode - pa->sym];\n    else if (OPCT_IS(pa->instr_type, OPC_0F01))\n        v |= 0x0f0100;\n    op1 = v >> 16;\n    if (op1)\n        g(op1);\n    op1 = (v >> 8) & 0xff;\n    if (op1)\n        g(op1);\n    g(v);\n\n    if (OPCT_IS(pa->instr_type, OPC_SHIFT)) {\n        reg = (opcode - pa->sym) / NBWLX;\n        if (reg == 6)\n            reg = 7;\n    } else if (OPCT_IS(pa->instr_type, OPC_ARITH)) {\n        reg = (opcode - pa->sym) / NBWLX;\n    } else if (OPCT_IS(pa->instr_type, OPC_FARITH)) {\n        reg = (opcode - pa->sym) / 6;\n    } else {\n        reg = (pa->instr_type >> OPC_GROUP_SHIFT) & 7;\n    }\n\n    pc = 0;\n    if (pa->instr_type & OPC_MODRM) {\n        /* if a register is used in another operand then it is\n           used instead of group */\n\tif (modreg_index >= 0)\n\t    reg = ops[modreg_index].reg;\n        pc = asm_modrm(reg, &ops[modrm_index]);\n    }\n\n    /* emit constants */\n#ifndef TCC_TARGET_X86_64\n    if (!(pa->instr_type & OPC_0F)\n\t&& (pa->opcode == 0x9a || pa->opcode == 0xea)) {\n        /* ljmp or lcall kludge */\n\tgen_expr32(&ops[1].e);\n        if (ops[0].e.sym)\n            tcc_error(\"cannot relocate\");\n        gen_le16(ops[0].e.v);\n        return;\n    }\n#endif\n    for(i = 0;i < nb_ops; i++) {\n        v = op_type[i];\n        if (v & (OP_IM8 | OP_IM16 | OP_IM32 | OP_IM64 | OP_IM8S | OP_ADDR)) {\n            /* if multiple sizes are given it means we must look\n               at the op size */\n            if ((v | OP_IM8 | OP_IM64) == (OP_IM8 | OP_IM16 | OP_IM32 | OP_IM64)) {\n                if (s == 0)\n                    v = OP_IM8;\n                else if (s == 1)\n                    v = OP_IM16;\n                else if (s == 2 || (v & OP_IM64) == 0)\n                    v = OP_IM32;\n                else\n                    v = OP_IM64;\n            }\n\n            if ((v & (OP_IM8 | OP_IM8S | OP_IM16)) && ops[i].e.sym)\n                tcc_error(\"cannot relocate\");\n\n            if (v & (OP_IM8 | OP_IM8S)) {\n                g(ops[i].e.v);\n            } else if (v & OP_IM16) {\n                gen_le16(ops[i].e.v);\n#ifdef TCC_TARGET_X86_64\n            } else if (v & OP_IM64) {\n                gen_expr64(&ops[i].e);\n#endif\n\t    } else if (pa->op_type[i] == OPT_DISP || pa->op_type[i] == OPT_DISP8) {\n                gen_disp32(&ops[i].e);\n            } else {\n                gen_expr32(&ops[i].e);\n            }\n        }\n    }\n\n    /* after immediate operands, adjust pc-relative address */\n    if (pc)\n        add32le(cur_text_section->data + pc - 4, pc - ind);\n}\n\n/* return the constraint priority (we allocate first the lowest\n   numbered constraints) */\nstatic inline int constraint_priority(const char *str)\n{\n    int priority, c, pr;\n\n    /* we take the lowest priority */\n    priority = 0;\n    for(;;) {\n        c = *str;\n        if (c == '\\0')\n            break;\n        str++;\n        switch(c) {\n        case 'A':\n            pr = 0;\n            break;\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'S':\n        case 'D':\n            pr = 1;\n            break;\n        case 'q':\n            pr = 2;\n            break;\n        case 'r':\n\tcase 'R':\n\tcase 'p':\n            pr = 3;\n            break;\n        case 'N':\n        case 'M':\n        case 'I':\n\tcase 'e':\n        case 'i':\n        case 'm':\n        case 'g':\n            pr = 4;\n            break;\n        default:\n            tcc_error(\"unknown constraint '%c'\", c);\n            pr = 0;\n        }\n        if (pr > priority)\n            priority = pr;\n    }\n    return priority;\n}\n\nstatic const char *skip_constraint_modifiers(const char *p)\n{\n    while (*p == '=' || *p == '&' || *p == '+' || *p == '%')\n        p++;\n    return p;\n}\n\n/* If T (a token) is of the form \"%reg\" returns the register\n   number and type, otherwise return -1.  */\nST_FUNC int asm_parse_regvar (int t)\n{\n    const char *s;\n    Operand op;\n    if (t < TOK_IDENT || (t & SYM_FIELD))\n        return -1;\n    s = table_ident[t - TOK_IDENT]->str;\n    if (s[0] != '%')\n        return -1;\n    t = tok_alloc_const(s + 1);\n    unget_tok(t);\n    unget_tok('%');\n    parse_operand(tcc_state, &op);\n    /* Accept only integer regs for now.  */\n    if (op.type & OP_REG)\n        return op.reg;\n    else\n        return -1;\n}\n\n#define REG_OUT_MASK 0x01\n#define REG_IN_MASK  0x02\n\n#define is_reg_allocated(reg) (regs_allocated[reg] & reg_mask)\n\nST_FUNC void asm_compute_constraints(ASMOperand *operands,\n                                    int nb_operands, int nb_outputs,\n                                    const uint8_t *clobber_regs,\n                                    int *pout_reg)\n{\n    ASMOperand *op;\n    int sorted_op[MAX_ASM_OPERANDS];\n    int i, j, k, p1, p2, tmp, reg, c, reg_mask;\n    const char *str;\n    uint8_t regs_allocated[NB_ASM_REGS];\n\n    /* init fields */\n    for(i=0;i<nb_operands;i++) {\n        op = &operands[i];\n        op->input_index = -1;\n        op->ref_index = -1;\n        op->reg = -1;\n        op->is_memory = 0;\n        op->is_rw = 0;\n    }\n    /* compute constraint priority and evaluate references to output\n       constraints if input constraints */\n    for(i=0;i<nb_operands;i++) {\n        op = &operands[i];\n        str = op->constraint;\n        str = skip_constraint_modifiers(str);\n        if (isnum(*str) || *str == '[') {\n            /* this is a reference to another constraint */\n            k = find_constraint(operands, nb_operands, str, NULL);\n            if ((unsigned)k >= i || i < nb_outputs)\n                tcc_error(\"invalid reference in constraint %d ('%s')\",\n                      i, str);\n            op->ref_index = k;\n            if (operands[k].input_index >= 0)\n                tcc_error(\"cannot reference twice the same operand\");\n            operands[k].input_index = i;\n            op->priority = 5;\n\t} else if ((op->vt->r & VT_VALMASK) == VT_LOCAL\n\t\t   && op->vt->sym\n\t\t   && (reg = op->vt->sym->r & VT_VALMASK) < VT_CONST) {\n\t    op->priority = 1;\n\t    op->reg = reg;\n        } else {\n            op->priority = constraint_priority(str);\n        }\n    }\n\n    /* sort operands according to their priority */\n    for(i=0;i<nb_operands;i++)\n        sorted_op[i] = i;\n    for(i=0;i<nb_operands - 1;i++) {\n        for(j=i+1;j<nb_operands;j++) {\n            p1 = operands[sorted_op[i]].priority;\n            p2 = operands[sorted_op[j]].priority;\n            if (p2 < p1) {\n                tmp = sorted_op[i];\n                sorted_op[i] = sorted_op[j];\n                sorted_op[j] = tmp;\n            }\n        }\n    }\n\n    for(i = 0;i < NB_ASM_REGS; i++) {\n        if (clobber_regs[i])\n            regs_allocated[i] = REG_IN_MASK | REG_OUT_MASK;\n        else\n            regs_allocated[i] = 0;\n    }\n    /* esp cannot be used */\n    regs_allocated[4] = REG_IN_MASK | REG_OUT_MASK;\n    /* ebp cannot be used yet */\n    regs_allocated[5] = REG_IN_MASK | REG_OUT_MASK;\n\n    /* allocate registers and generate corresponding asm moves */\n    for(i=0;i<nb_operands;i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        str = op->constraint;\n        /* no need to allocate references */\n        if (op->ref_index >= 0)\n            continue;\n        /* select if register is used for output, input or both */\n        if (op->input_index >= 0) {\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n        } else if (j < nb_outputs) {\n            reg_mask = REG_OUT_MASK;\n        } else {\n            reg_mask = REG_IN_MASK;\n        }\n\tif (op->reg >= 0) {\n\t    if (is_reg_allocated(op->reg))\n\t        tcc_error(\"asm regvar requests register that's taken already\");\n\t    reg = op->reg;\n\t}\n    try_next:\n        c = *str++;\n        switch(c) {\n        case '=':\n            goto try_next;\n        case '+':\n            op->is_rw = 1;\n            /* FALL THRU */\n        case '&':\n            if (j >= nb_outputs)\n                tcc_error(\"'%c' modifier can only be applied to outputs\", c);\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n            goto try_next;\n        case 'A':\n            /* allocate both eax and edx */\n            if (is_reg_allocated(TREG_XAX) ||\n                is_reg_allocated(TREG_XDX))\n                goto try_next;\n            op->is_llong = 1;\n            op->reg = TREG_XAX;\n            regs_allocated[TREG_XAX] |= reg_mask;\n            regs_allocated[TREG_XDX] |= reg_mask;\n            break;\n        case 'a':\n            reg = TREG_XAX;\n            goto alloc_reg;\n        case 'b':\n            reg = 3;\n            goto alloc_reg;\n        case 'c':\n            reg = TREG_XCX;\n            goto alloc_reg;\n        case 'd':\n            reg = TREG_XDX;\n            goto alloc_reg;\n        case 'S':\n            reg = 6;\n            goto alloc_reg;\n        case 'D':\n            reg = 7;\n        alloc_reg:\n            if (op->reg >= 0 && reg != op->reg)\n                goto try_next;\n            if (is_reg_allocated(reg))\n                goto try_next;\n            goto reg_found;\n        case 'q':\n            /* eax, ebx, ecx or edx */\n            if (op->reg >= 0) {\n                if ((reg = op->reg) < 4)\n                    goto reg_found;\n            } else for(reg = 0; reg < 4; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n        case 'r':\n\tcase 'R':\n\tcase 'p': /* A general address, for x86(64) any register is acceptable*/\n            /* any general register */\n            if ((reg = op->reg) >= 0)\n                goto reg_found;\n            else for(reg = 0; reg < 8; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n        reg_found:\n            /* now we can reload in the register */\n            op->is_llong = 0;\n            op->reg = reg;\n            regs_allocated[reg] |= reg_mask;\n            break;\n\tcase 'e':\n        case 'i':\n            if (!((op->vt->r & (VT_VALMASK | VT_LVAL)) == VT_CONST))\n                goto try_next;\n            break;\n        case 'I':\n        case 'N':\n        case 'M':\n            if (!((op->vt->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST))\n                goto try_next;\n            break;\n        case 'm':\n        case 'g':\n            /* nothing special to do because the operand is already in\n               memory, except if the pointer itself is stored in a\n               memory variable (VT_LLOCAL case) */\n            /* XXX: fix constant case */\n            /* if it is a reference to a memory zone, it must lie\n               in a register, so we reserve the register in the\n               input registers and a load will be generated\n               later */\n            if (j < nb_outputs || c == 'm') {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    /* any general register */\n                    for(reg = 0; reg < 8; reg++) {\n                        if (!(regs_allocated[reg] & REG_IN_MASK))\n                            goto reg_found1;\n                    }\n                    goto try_next;\n                reg_found1:\n                    /* now we can reload in the register */\n                    regs_allocated[reg] |= REG_IN_MASK;\n                    op->reg = reg;\n                    op->is_memory = 1;\n                }\n            }\n            break;\n        default:\n            tcc_error(\"asm constraint %d ('%s') could not be satisfied\",\n                  j, op->constraint);\n            break;\n        }\n        /* if a reference is present for that operand, we assign it too */\n        if (op->input_index >= 0) {\n            operands[op->input_index].reg = op->reg;\n            operands[op->input_index].is_llong = op->is_llong;\n        }\n    }\n\n    /* compute out_reg. It is used to store outputs registers to memory\n       locations references by pointers (VT_LLOCAL case) */\n    *pout_reg = -1;\n    for(i=0;i<nb_operands;i++) {\n        op = &operands[i];\n        if (op->reg >= 0 &&\n            (op->vt->r & VT_VALMASK) == VT_LLOCAL  &&\n            !op->is_memory) {\n            for(reg = 0; reg < 8; reg++) {\n                if (!(regs_allocated[reg] & REG_OUT_MASK))\n                    goto reg_found2;\n            }\n            tcc_error(\"could not find free output register for reloading\");\n        reg_found2:\n            *pout_reg = reg;\n            break;\n        }\n    }\n\n    /* print sorted constraints */\n#ifdef ASM_DEBUG\n    for(i=0;i<nb_operands;i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        printf(\"%%%d [%s]: \\\"%s\\\" r=0x%04x reg=%d\\n\",\n               j,\n               op->id ? get_tok_str(op->id, NULL) : \"\",\n               op->constraint,\n               op->vt->r,\n               op->reg);\n    }\n    if (*pout_reg >= 0)\n        printf(\"out_reg=%d\\n\", *pout_reg);\n#endif\n}\n\nST_FUNC void subst_asm_operand(CString *add_str,\n                              SValue *sv, int modifier)\n{\n    int r, reg, size, val;\n\n    r = sv->r;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        if (!(r & VT_LVAL) && modifier != 'c' && modifier != 'n' &&\n\t    modifier != 'P')\n            cstr_ccat(add_str, '$');\n        if (r & VT_SYM) {\n\t    const char *name = get_tok_str(sv->sym->v, NULL);\n\t    if (sv->sym->v >= SYM_FIRST_ANOM) {\n\t\t/* In case of anonymous symbols (\"L.42\", used\n\t\t   for static data labels) we can't find them\n\t\t   in the C symbol table when later looking up\n\t\t   this name.  So enter them now into the asm label\n\t\t   list when we still know the symbol.  */\n\t\tget_asm_sym(tok_alloc_const(name), sv->sym);\n\t    }\n            if (tcc_state->leading_underscore)\n              cstr_ccat(add_str, '_');\n            cstr_cat(add_str, name, -1);\n            if ((uint32_t)sv->c.i == 0)\n                goto no_offset;\n\t    cstr_ccat(add_str, '+');\n        }\n        val = sv->c.i;\n        if (modifier == 'n')\n            val = -val;\n        cstr_printf(add_str, \"%d\", (int)sv->c.i);\n    no_offset:;\n#ifdef TCC_TARGET_X86_64\n        if (r & VT_LVAL)\n            cstr_cat(add_str, \"(%rip)\", -1);\n#endif\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        cstr_printf(add_str, \"%d(%%%s)\", (int)sv->c.i, get_tok_str(TOK_ASM_xax + 5, NULL));\n    } else if (r & VT_LVAL) {\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            tcc_internal_error(\"\");\n        cstr_printf(add_str, \"(%%%s)\", get_tok_str(TOK_ASM_xax + reg, NULL));\n    } else {\n        /* register case */\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            tcc_internal_error(\"\");\n\n        /* choose register operand size */\n        if ((sv->type.t & VT_BTYPE) == VT_BYTE ||\n\t    (sv->type.t & VT_BTYPE) == VT_BOOL)\n            size = 1;\n        else if ((sv->type.t & VT_BTYPE) == VT_SHORT)\n            size = 2;\n#ifdef TCC_TARGET_X86_64\n        else if ((sv->type.t & VT_BTYPE) == VT_LLONG ||\n\t\t (sv->type.t & VT_BTYPE) == VT_PTR)\n            size = 8;\n#endif\n        else\n            size = 4;\n        if (size == 1 && reg >= 4)\n            size = 4;\n\n        if (modifier == 'b') {\n            if (reg >= 4)\n                tcc_error(\"cannot use byte register\");\n            size = 1;\n        } else if (modifier == 'h') {\n            if (reg >= 4)\n                tcc_error(\"cannot use byte register\");\n            size = -1;\n        } else if (modifier == 'w') {\n            size = 2;\n        } else if (modifier == 'k') {\n            size = 4;\n#ifdef TCC_TARGET_X86_64\n        } else if (modifier == 'q') {\n            size = 8;\n#endif\n        }\n\n        switch(size) {\n        case -1:\n            reg = TOK_ASM_ah + reg;\n            break;\n        case 1:\n            reg = TOK_ASM_al + reg;\n            break;\n        case 2:\n            reg = TOK_ASM_ax + reg;\n            break;\n        default:\n            reg = TOK_ASM_eax + reg;\n            break;\n#ifdef TCC_TARGET_X86_64\n        case 8:\n            reg = TOK_ASM_rax + reg;\n            break;\n#endif\n        }\n        cstr_printf(add_str, \"%%%s\", get_tok_str(reg, NULL));\n    }\n}\n\n/* generate prolog and epilog code for asm statement */\nST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands,\n                         int nb_outputs, int is_output,\n                         uint8_t *clobber_regs,\n                         int out_reg)\n{\n    uint8_t regs_allocated[NB_ASM_REGS];\n    ASMOperand *op;\n    int i, reg;\n\n    /* Strictly speaking %Xbp and %Xsp should be included in the\n       call-preserved registers, but currently it doesn't matter.  */\n#ifdef TCC_TARGET_X86_64\n#ifdef TCC_TARGET_PE\n    static const uint8_t reg_saved[] = { 3, 6, 7, 12, 13, 14, 15 };\n#else\n    static const uint8_t reg_saved[] = { 3, 12, 13, 14, 15 };\n#endif\n#else\n    static const uint8_t reg_saved[] = { 3, 6, 7 };\n#endif\n\n    /* mark all used registers */\n    memcpy(regs_allocated, clobber_regs, sizeof(regs_allocated));\n    for(i = 0; i < nb_operands;i++) {\n        op = &operands[i];\n        if (op->reg >= 0)\n            regs_allocated[op->reg] = 1;\n    }\n    if (!is_output) {\n        /* generate reg save code */\n        for(i = 0; i < sizeof(reg_saved)/sizeof(reg_saved[0]); i++) {\n            reg = reg_saved[i];\n            if (regs_allocated[reg]) {\n\t\tif (reg >= 8)\n\t\t  g(0x41), reg-=8;\n                g(0x50 + reg);\n            }\n        }\n\n        /* generate load code */\n        for(i = 0; i < nb_operands; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL &&\n                    op->is_memory) {\n                    /* memory reference case (for both input and\n                       output cases) */\n                    SValue sv;\n                    sv = *op->vt;\n                    sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL | VT_LVAL;\n                    sv.type.t = VT_PTR;\n                    load(op->reg, &sv);\n                } else if (i >= nb_outputs || op->is_rw) {\n                    /* load value in register */\n                    load(op->reg, op->vt);\n                    if (op->is_llong) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.c.i += 4;\n                        load(TREG_XDX, &sv);\n                    }\n                }\n            }\n        }\n    } else {\n        /* generate save code */\n        for(i = 0 ; i < nb_outputs; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    if (!op->is_memory) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL;\n\t\t\tsv.type.t = VT_PTR;\n                        load(out_reg, &sv);\n\n\t\t\tsv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | out_reg;\n                        store(op->reg, &sv);\n                    }\n                } else {\n                    store(op->reg, op->vt);\n                    if (op->is_llong) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.c.i += 4;\n                        store(TREG_XDX, &sv);\n                    }\n                }\n            }\n        }\n        /* generate reg restore code */\n        for(i = sizeof(reg_saved)/sizeof(reg_saved[0]) - 1; i >= 0; i--) {\n            reg = reg_saved[i];\n            if (regs_allocated[reg]) {\n\t\tif (reg >= 8)\n\t\t  g(0x41), reg-=8;\n                g(0x58 + reg);\n            }\n        }\n    }\n}\n\nST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str)\n{\n    int reg;\n#ifdef TCC_TARGET_X86_64\n    unsigned int type;\n#endif\n\n    if (!strcmp(str, \"memory\") ||\n        !strcmp(str, \"cc\") ||\n\t!strcmp(str, \"flags\"))\n        return;\n    reg = tok_alloc_const(str);\n    if (reg >= TOK_ASM_eax && reg <= TOK_ASM_edi) {\n        reg -= TOK_ASM_eax;\n    } else if (reg >= TOK_ASM_ax && reg <= TOK_ASM_di) {\n        reg -= TOK_ASM_ax;\n#ifdef TCC_TARGET_X86_64\n    } else if (reg >= TOK_ASM_rax && reg <= TOK_ASM_rdi) {\n        reg -= TOK_ASM_rax;\n    } else if ((reg = asm_parse_numeric_reg(reg, &type)) >= 0) {\n\t;\n#endif\n    } else {\n        tcc_error(\"invalid clobber register '%s'\", str);\n    }\n    clobber_regs[reg] = 1;\n}\n"
        },
        {
          "name": "i386-asm.h",
          "type": "blob",
          "size": 23.68359375,
          "content": "     DEF_ASM_OP0(clc, 0xf8) /* must be first OP0 */\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pusha, 0x60)\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(pause, 0xf390)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWLX))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(popcntw, 0xf30fb8, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(tzcntw, 0xf30fbc, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(lzcntw, 0xf30fbd, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\n     /* prefixes */\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(fwait, 0x9b)\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     ALT(DEF_ASM_OP0(word, 0x66))\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWLX, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWLX, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWLX, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WLX, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WLX, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WLX, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WLX, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WLX, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WLX, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WLX, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x660fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WLX, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WLX, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WLX, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WLX, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WLX, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WLX, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WLX, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_REGW, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_EAX, OPT_REGW))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WLX, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWLX, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWLX, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WLX, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WLX, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, 0, OPT_DISP))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, 0, OPT_DISP8))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, OPC_MODRM, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\nALT(DEF_ASM_OP1(setob, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\n    DEF_ASM_OP0(retl,0xc3)\nALT(DEF_ASM_OP1(retl,0xc2, 0, 0, OPT_IM16))\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_TEST, OPT_DISP8))\n    DEF_ASM_OP1(loopne, 0xe0, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loope, 0xe1, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loopz, 0xe1, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loop, 0xe2, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, 0, OPT_DISP8)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(fadd, 0xdcc0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP2(fmul, 0xdcc8, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\nALT(DEF_ASM_OP2(larw, 0x0f02, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x6662, 0, OPC_MODRM, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\nALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMXSSE )\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG32 ))\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\nALT(DEF_ASM_OP2(movq, 0x660fd6, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_SSE ))\nALT(DEF_ASM_OP2(movq, 0xf30f7e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE ))\n\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n\n    /* sse */\n    DEF_ASM_OP1(ldmxcsr, 0x0fae, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(stmxcsr, 0x0fae, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP2(movups, 0x0f10, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )\nALT(DEF_ASM_OP2(movups, 0x0f11, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movaps, 0x0f28, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )\nALT(DEF_ASM_OP2(movaps, 0x0f29, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movhps, 0x0f16, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )\nALT(DEF_ASM_OP2(movhps, 0x0f17, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(addps, 0x0f58, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(cvtpi2ps, 0x0f2a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_SSE )\n    DEF_ASM_OP2(cvtps2pi, 0x0f2d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )\n    DEF_ASM_OP2(cvttps2pi, 0x0f2c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )\n    DEF_ASM_OP2(divps, 0x0f5e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(maxps, 0x0f5f, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(minps, 0x0f5d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(mulps, 0x0f59, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(pavgb, 0x0fe0, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(pavgw, 0x0fe3, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(pmaxsw, 0x0fee, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmaxub, 0x0fde, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pminsw, 0x0fea, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pminub, 0x0fda, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(rcpss, 0x0f53, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(rsqrtps, 0x0f52, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(sqrtps, 0x0f51, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(subps, 0x0f5c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n"
        },
        {
          "name": "i386-gen.c",
          "type": "blob",
          "size": 30.5947265625,
          "content": "/*\n *  X86 code generator for TCC\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n/* number of available registers */\n#define NB_REGS         5\n#define NB_ASM_REGS     8\n#define CONFIG_TCC_ASM\n\n/* a register can belong to several classes. The classes must be\n   sorted from more general to more precise (see gv2() code which does\n   assumptions on it). */\n#define RC_INT     0x0001 /* generic integer register */\n#define RC_FLOAT   0x0002 /* generic float register */\n#define RC_EAX     0x0004\n#define RC_EDX     0x0008\n#define RC_ECX     0x0010\n#define RC_EBX     0x0020\n#define RC_ST0     0x0040\n\n#define RC_IRET    RC_EAX /* function return: integer register */\n#define RC_IRE2    RC_EDX /* function return: second integer register */\n#define RC_FRET    RC_ST0 /* function return: float register */\n\n/* pretty names for the registers */\nenum {\n    TREG_EAX = 0,\n    TREG_ECX,\n    TREG_EDX,\n    TREG_EBX,\n    TREG_ST0,\n    TREG_ESP = 4\n};\n\n/* return registers for function */\n#define REG_IRET TREG_EAX /* single word int return register */\n#define REG_IRE2 TREG_EDX /* second word return register (for long long) */\n#define REG_FRET TREG_ST0 /* float return register */\n\n/* defined if function parameters must be evaluated in reverse order */\n#define INVERT_FUNC_PARAMS\n\n/* defined if structures are passed as pointers. Otherwise structures\n   are directly pushed on stack. */\n/* #define FUNC_STRUCT_PARAM_AS_PTR */\n\n/* pointer size, in bytes */\n#define PTR_SIZE 4\n\n/* long double size and alignment, in bytes */\n#define LDOUBLE_SIZE  12\n#define LDOUBLE_ALIGN 4\n/* maximum alignment (for aligned attribute support) */\n#define MAX_ALIGN     8\n\n/* define if return values need to be extended explicitely\n   at caller side (for interfacing with non-TCC compilers) */\n#define PROMOTE_RET\n\n/******************************************************/\n#else /* ! TARGET_DEFS_ONLY */\n/******************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n\nST_DATA const char * const target_machine_defs =\n    \"__i386__\\0\"\n    \"__i386\\0\"\n    ;\n\n/* define to 1/0 to [not] have EBX as 4th register */\n#define USE_EBX 0\n\nST_DATA const int reg_classes[NB_REGS] = {\n    /* eax */ RC_INT | RC_EAX,\n    /* ecx */ RC_INT | RC_ECX,\n    /* edx */ RC_INT | RC_EDX,\n    /* ebx */ (RC_INT | RC_EBX) * USE_EBX,\n    /* st0 */ RC_FLOAT | RC_ST0,\n};\n\nstatic unsigned long func_sub_sp_offset;\nstatic int func_ret_sub;\n#ifdef CONFIG_TCC_BCHECK\nstatic addr_t func_bound_offset;\nstatic unsigned long func_bound_ind;\nST_DATA int func_bound_add_epilog;\nstatic void gen_bounds_prolog(void);\nstatic void gen_bounds_epilog(void);\n#endif\n\n/* XXX: make it faster ? */\nST_FUNC void g(int c)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 1;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c;\n    ind = ind1;\n}\n\nST_FUNC void o(unsigned int c)\n{\n    while (c) {\n        g(c);\n        c = c >> 8;\n    }\n}\n\nST_FUNC void gen_le16(int v)\n{\n    g(v);\n    g(v >> 8);\n}\n\nST_FUNC void gen_le32(int c)\n{\n    g(c);\n    g(c >> 8);\n    g(c >> 16);\n    g(c >> 24);\n}\n\n/* output a symbol and patch all calls to it */\nST_FUNC void gsym_addr(int t, int a)\n{\n    while (t) {\n        unsigned char *ptr = cur_text_section->data + t;\n        uint32_t n = read32le(ptr); /* next value */\n        write32le(ptr, a - t - 4);\n        t = n;\n    }\n}\n\n/* instruction + 4 bytes data. Return the address of the data */\nstatic int oad(int c, int s)\n{\n    int t;\n    if (nocode_wanted)\n        return s;\n    o(c);\n    t = ind;\n    gen_le32(s);\n    return t;\n}\n\nST_FUNC void gen_fill_nops(int bytes)\n{\n    while (bytes--)\n      g(0x90);\n}\n\n/* generate jmp to a label */\n#define gjmp2(instr,lbl) oad(instr,lbl)\n\n/* output constant with relocation if 'r & VT_SYM' is true */\nST_FUNC void gen_addr32(int r, Sym *sym, int c)\n{\n    if (r & VT_SYM)\n        greloc(cur_text_section, sym, ind, R_386_32);\n    gen_le32(c);\n}\n\nST_FUNC void gen_addrpc32(int r, Sym *sym, int c)\n{\n    if (r & VT_SYM)\n        greloc(cur_text_section, sym, ind, R_386_PC32);\n    gen_le32(c - 4);\n}\n\n/* generate a modrm reference. 'op_reg' contains the additional 3\n   opcode bits */\nstatic void gen_modrm(int op_reg, int r, Sym *sym, int c)\n{\n    op_reg = op_reg << 3;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        /* constant memory reference */\n        o(0x05 | op_reg);\n        gen_addr32(r, sym, c);\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        /* currently, we use only ebp as base */\n        if (c == (char)c) {\n            /* short reference */\n            o(0x45 | op_reg);\n            g(c);\n        } else {\n            oad(0x85 | op_reg, c);\n        }\n    } else {\n        g(0x00 | op_reg | (r & VT_VALMASK));\n    }\n}\n\n/* load 'r' from value 'sv' */\nST_FUNC void load(int r, SValue *sv)\n{\n    int v, t, ft, fc, fr;\n    SValue v1;\n\n    fr = sv->r;\n    ft = sv->type.t & ~VT_DEFSIGN;\n    fc = sv->c.i;\n\n    ft &= ~(VT_VOLATILE | VT_CONSTANT);\n\n    v = fr & VT_VALMASK;\n    if (fr & VT_LVAL) {\n        if (v == VT_LLOCAL) {\n            v1.type.t = VT_INT;\n            v1.r = VT_LOCAL | VT_LVAL;\n            v1.c.i = fc;\n            v1.sym = NULL;\n            fr = r;\n            if (!(reg_classes[fr] & RC_INT))\n                fr = get_reg(RC_INT);\n            load(fr, &v1);\n        }\n        if ((ft & VT_BTYPE) == VT_FLOAT) {\n            o(0xd9); /* flds */\n            r = 0;\n        } else if ((ft & VT_BTYPE) == VT_DOUBLE) {\n            o(0xdd); /* fldl */\n            r = 0;\n        } else if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n            o(0xdb); /* fldt */\n            r = 5;\n        } else if ((ft & VT_TYPE) == VT_BYTE || (ft & VT_TYPE) == VT_BOOL) {\n            o(0xbe0f);   /* movsbl */\n        } else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED)) {\n            o(0xb60f);   /* movzbl */\n        } else if ((ft & VT_TYPE) == VT_SHORT) {\n            o(0xbf0f);   /* movswl */\n        } else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED)) {\n            o(0xb70f);   /* movzwl */\n        } else {\n            o(0x8b);     /* movl */\n        }\n        gen_modrm(r, fr, sv->sym, fc);\n    } else {\n        if (v == VT_CONST) {\n            o(0xb8 + r); /* mov $xx, r */\n            gen_addr32(fr, sv->sym, fc);\n        } else if (v == VT_LOCAL) {\n            if (fc) {\n                o(0x8d); /* lea xxx(%ebp), r */\n                gen_modrm(r, VT_LOCAL, sv->sym, fc);\n            } else {\n                o(0x89);\n                o(0xe8 + r); /* mov %ebp, r */\n            }\n        } else if (v == VT_CMP) {\n            o(0x0f); /* setxx %br */\n            o(fc);\n            o(0xc0 + r);\n            o(0xc0b60f + r * 0x90000); /* movzbl %al, %eax */\n        } else if (v == VT_JMP || v == VT_JMPI) {\n            t = v & 1;\n            oad(0xb8 + r, t); /* mov $1, r */\n            o(0x05eb); /* jmp after */\n            gsym(fc);\n            oad(0xb8 + r, t ^ 1); /* mov $0, r */\n        } else if (v != r) {\n            o(0x89);\n            o(0xc0 + r + v * 8); /* mov v, r */\n        }\n    }\n}\n\n/* store register 'r' in lvalue 'v' */\nST_FUNC void store(int r, SValue *v)\n{\n    int fr, bt, ft, fc;\n\n    ft = v->type.t;\n    fc = v->c.i;\n    fr = v->r & VT_VALMASK;\n    ft &= ~(VT_VOLATILE | VT_CONSTANT);\n    bt = ft & VT_BTYPE;\n    /* XXX: incorrect if float reg to reg */\n    if (bt == VT_FLOAT) {\n        o(0xd9); /* fsts */\n        r = 2;\n    } else if (bt == VT_DOUBLE) {\n        o(0xdd); /* fstpl */\n        r = 2;\n    } else if (bt == VT_LDOUBLE) {\n        o(0xc0d9); /* fld %st(0) */\n        o(0xdb); /* fstpt */\n        r = 7;\n    } else {\n        if (bt == VT_SHORT)\n            o(0x66);\n        if (bt == VT_BYTE || bt == VT_BOOL)\n            o(0x88);\n        else\n            o(0x89);\n    }\n    if (fr == VT_CONST ||\n        fr == VT_LOCAL ||\n        (v->r & VT_LVAL)) {\n        gen_modrm(r, v->r, v->sym, fc);\n    } else if (fr != r) {\n        o(0xc0 + fr + r * 8); /* mov r, fr */\n    }\n}\n\nstatic void gadd_sp(int val)\n{\n    if (val == (char)val) {\n        o(0xc483);\n        g(val);\n    } else {\n        oad(0xc481, val); /* add $xxx, %esp */\n    }\n}\n\n#if defined CONFIG_TCC_BCHECK || defined TCC_TARGET_PE\nstatic void gen_static_call(int v)\n{\n    Sym *sym;\n\n    sym = external_helper_sym(v);\n    oad(0xe8, -4);\n    greloc(cur_text_section, sym, ind-4, R_386_PC32);\n}\n#endif\n\n/* 'is_jmp' is '1' if it is a jump */\nstatic void gcall_or_jmp(int is_jmp)\n{\n    int r;\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST && (vtop->r & VT_SYM)) {\n        /* constant and relocation case */\n        greloc(cur_text_section, vtop->sym, ind + 1, R_386_PC32);\n        oad(0xe8 + is_jmp, vtop->c.i - 4); /* call/jmp im */\n    } else {\n        /* otherwise, indirect call */\n        r = gv(RC_INT);\n        o(0xff); /* call/jmp *r */\n        o(0xd0 + r + (is_jmp << 4));\n    }\n}\n\nstatic const uint8_t fastcall_regs[3] = { TREG_EAX, TREG_EDX, TREG_ECX };\nstatic const uint8_t fastcallw_regs[2] = { TREG_ECX, TREG_EDX };\n\n/* Return the number of registers needed to return the struct, or 0 if\n   returning via struct pointer. */\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)\n{\n#if defined(TCC_TARGET_PE) || TARGETOS_FreeBSD || TARGETOS_OpenBSD\n    int size, align, nregs;\n    *ret_align = 1; // Never have to re-align return values for x86\n    *regsize = 4;\n    size = type_size(vt, &align);\n    if (size > 8 || (size & (size - 1)))\n        return 0;\n    nregs = 1;\n    if (size == 8)\n        ret->t = VT_INT, nregs = 2;\n    else if (size == 4)\n        ret->t = VT_INT;\n    else if (size == 2)\n        ret->t = VT_SHORT;\n    else\n        ret->t = VT_BYTE;\n    ret->ref = NULL;\n    return nregs;\n#else\n    *ret_align = 1; // Never have to re-align return values for x86\n    return 0;\n#endif\n}\n\n/* Generate function call. The function address is pushed first, then\n   all the parameters in call order. This functions pops all the\n   parameters and the function address. */\nST_FUNC void gfunc_call(int nb_args)\n{\n    int size, align, r, args_size, i, func_call;\n    Sym *func_sym;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gbound_args(nb_args);\n#endif\n\n    args_size = 0;\n    for(i = 0;i < nb_args; i++) {\n        if ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n            /* fetch cpu flag before generating any code */\n            if ((vtop->r & VT_VALMASK) == VT_CMP)\n                gv(RC_INT);\n            size = type_size(&vtop->type, &align);\n            /* align to stack align size */\n            size = (size + 3) & ~3;\n            /* allocate the necessary size on stack */\n#ifdef TCC_TARGET_PE\n            if (size >= 4096) {\n                r = get_reg(RC_EAX);\n                oad(0x68, size); // push size\n                /* cannot call normal 'alloca' with bound checking */\n                gen_static_call(tok_alloc_const(\"__alloca\"));\n                gadd_sp(4);\n            } else\n#endif\n            {\n                oad(0xec81, size); /* sub $xxx, %esp */\n                /* generate structure store */\n                r = get_reg(RC_INT);\n                o(0xe089 + (r << 8)); /* mov %esp, r */\n            }\n            vset(&vtop->type, r | VT_LVAL, 0);\n            vswap();\n            vstore();\n            args_size += size;\n        } else if (is_float(vtop->type.t)) {\n            gv(RC_FLOAT); /* only one float register */\n            if ((vtop->type.t & VT_BTYPE) == VT_FLOAT)\n                size = 4;\n            else if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)\n                size = 8;\n            else\n                size = 12;\n            oad(0xec81, size); /* sub $xxx, %esp */\n            if (size == 12)\n                o(0x7cdb);\n            else\n                o(0x5cd9 + size - 4); /* fstp[s|l] 0(%esp) */\n            g(0x24);\n            g(0x00);\n            args_size += size;\n        } else {\n            /* simple type (currently always same size) */\n            /* XXX: implicit cast ? */\n            r = gv(RC_INT);\n            if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n                size = 8;\n                o(0x50 + vtop->r2); /* push r */\n            } else {\n                size = 4;\n            }\n            o(0x50 + r); /* push r */\n            args_size += size;\n        }\n        vtop--;\n    }\n    save_regs(0); /* save used temporary registers */\n    func_sym = vtop->type.ref;\n    func_call = func_sym->f.func_call;\n    /* fast call case */\n    if ((func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) ||\n        func_call == FUNC_FASTCALLW || func_call == FUNC_THISCALL) {\n        int fastcall_nb_regs;\n        const uint8_t *fastcall_regs_ptr;\n        if (func_call == FUNC_FASTCALLW) {\n            fastcall_regs_ptr = fastcallw_regs;\n            fastcall_nb_regs = 2;\n        } else if (func_call == FUNC_THISCALL) {\n            fastcall_regs_ptr = fastcallw_regs;\n            fastcall_nb_regs = 1;\n        } else {\n            fastcall_regs_ptr = fastcall_regs;\n            fastcall_nb_regs = func_call - FUNC_FASTCALL1 + 1;\n        }\n        for(i = 0;i < fastcall_nb_regs; i++) {\n            if (args_size <= 0)\n                break;\n            o(0x58 + fastcall_regs_ptr[i]); /* pop r */\n            /* XXX: incorrect for struct/floats */\n            args_size -= 4;\n        }\n    }\n#if !defined(TCC_TARGET_PE) && !TARGETOS_FreeBSD || TARGETOS_OpenBSD\n    else if ((vtop->type.ref->type.t & VT_BTYPE) == VT_STRUCT)\n        args_size -= 4;\n#endif\n\n    gcall_or_jmp(0);\n\n    if (args_size && func_call != FUNC_STDCALL && func_call != FUNC_THISCALL && func_call != FUNC_FASTCALLW)\n        gadd_sp(args_size);\n    vtop--;\n}\n\n#ifdef TCC_TARGET_PE\n#define FUNC_PROLOG_SIZE (10 + USE_EBX)\n#else\n#define FUNC_PROLOG_SIZE (9 + USE_EBX)\n#endif\n\n/* generate function prolog of type 't' */\nST_FUNC void gfunc_prolog(Sym *func_sym)\n{\n    CType *func_type = &func_sym->type;\n    int addr, align, size, func_call, fastcall_nb_regs;\n    int param_index, param_addr;\n    const uint8_t *fastcall_regs_ptr;\n    Sym *sym;\n    CType *type;\n\n    sym = func_type->ref;\n    func_call = sym->f.func_call;\n    addr = 8;\n    loc = 0;\n    func_vc = 0;\n\n    if (func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) {\n        fastcall_nb_regs = func_call - FUNC_FASTCALL1 + 1;\n        fastcall_regs_ptr = fastcall_regs;\n    } else if (func_call == FUNC_FASTCALLW) {\n        fastcall_nb_regs = 2;\n        fastcall_regs_ptr = fastcallw_regs;\n    } else if (func_call == FUNC_THISCALL) {\n        fastcall_nb_regs = 1;\n        fastcall_regs_ptr = fastcallw_regs;\n    } else {\n        fastcall_nb_regs = 0;\n        fastcall_regs_ptr = NULL;\n    }\n    param_index = 0;\n\n    ind += FUNC_PROLOG_SIZE;\n    func_sub_sp_offset = ind;\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n#if defined(TCC_TARGET_PE) || TARGETOS_FreeBSD || TARGETOS_OpenBSD\n    size = type_size(&func_vt,&align);\n    if (((func_vt.t & VT_BTYPE) == VT_STRUCT)\n        && (size > 8 || (size & (size - 1)))) {\n#else\n    if ((func_vt.t & VT_BTYPE) == VT_STRUCT) {\n#endif\n        /* XXX: fastcall case ? */\n        func_vc = addr;\n        addr += 4;\n        param_index++;\n    }\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n        type = &sym->type;\n        size = type_size(type, &align);\n        size = (size + 3) & ~3;\n#ifdef FUNC_STRUCT_PARAM_AS_PTR\n        /* structs are passed as pointer */\n        if ((type->t & VT_BTYPE) == VT_STRUCT) {\n            size = 4;\n        }\n#endif\n        if (param_index < fastcall_nb_regs) {\n            /* save FASTCALL register */\n            loc -= 4;\n            o(0x89);     /* movl */\n            gen_modrm(fastcall_regs_ptr[param_index], VT_LOCAL, NULL, loc);\n            param_addr = loc;\n        } else {\n            param_addr = addr;\n            addr += size;\n        }\n        sym_push(sym->v & ~SYM_FIELD, type,\n                 VT_LOCAL | VT_LVAL, param_addr);\n        param_index++;\n    }\n    func_ret_sub = 0;\n    /* pascal type call or fastcall ? */\n    if (func_call == FUNC_STDCALL || func_call == FUNC_FASTCALLW || func_call == FUNC_THISCALL)\n        func_ret_sub = addr - 8;\n#if !defined(TCC_TARGET_PE) && !TARGETOS_FreeBSD || TARGETOS_OpenBSD\n    else if (func_vc)\n        func_ret_sub = 4;\n#endif\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_prolog();\n#endif\n}\n\n/* generate function epilog */\nST_FUNC void gfunc_epilog(void)\n{\n    addr_t v, saved_ind;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_epilog();\n#endif\n\n    /* align local size to word & save local variables */\n    v = (-loc + 3) & -4;\n\n#if USE_EBX\n    o(0x8b);\n    gen_modrm(TREG_EBX, VT_LOCAL, NULL, -(v+4));\n#endif\n\n    o(0xc9); /* leave */\n    if (func_ret_sub == 0) {\n        o(0xc3); /* ret */\n    } else {\n        o(0xc2); /* ret n */\n        g(func_ret_sub);\n        g(func_ret_sub >> 8);\n    }\n    saved_ind = ind;\n    ind = func_sub_sp_offset - FUNC_PROLOG_SIZE;\n#ifdef TCC_TARGET_PE\n    if (v >= 4096) {\n        oad(0xb8, v); /* mov stacksize, %eax */\n        gen_static_call(TOK___chkstk); /* call __chkstk, (does the stackframe too) */\n    } else\n#endif\n    {\n        o(0xe58955);  /* push %ebp, mov %esp, %ebp */\n        o(0xec81);  /* sub esp, stacksize */\n        gen_le32(v);\n#ifdef TCC_TARGET_PE\n        o(0x90);  /* adjust to FUNC_PROLOG_SIZE */\n#endif\n    }\n    o(0x53 * USE_EBX); /* push ebx */\n    ind = saved_ind;\n}\n\n/* generate a jump to a label */\nST_FUNC int gjmp(int t)\n{\n    return gjmp2(0xe9, t);\n}\n\n/* generate a jump to a fixed address */\nST_FUNC void gjmp_addr(int a)\n{\n    int r;\n    r = a - ind - 2;\n    if (r == (char)r) {\n        g(0xeb);\n        g(r);\n    } else {\n        oad(0xe9, a - ind - 5);\n    }\n}\n\n#if 0\n/* generate a jump to a fixed address */\nST_FUNC void gjmp_cond_addr(int a, int op)\n{\n    int r = a - ind - 2;\n    if (r == (char)r)\n        g(op - 32), g(r);\n    else\n        g(0x0f), gjmp2(op - 16, r - 4);\n}\n#endif\n\nST_FUNC int gjmp_append(int n, int t)\n{\n    void *p;\n    /* insert vtop->c jump list in t */\n    if (n) {\n        uint32_t n1 = n, n2;\n        while ((n2 = read32le(p = cur_text_section->data + n1)))\n            n1 = n2;\n        write32le(p, t);\n        t = n;\n    }\n    return t;\n}\n\nST_FUNC int gjmp_cond(int op, int t)\n{\n    g(0x0f);\n    t = gjmp2(op - 16, t);\n    return t;\n}\n\nST_FUNC void gen_opi(int op)\n{\n    int r, fr, opc, c;\n\n    switch(op) {\n    case '+':\n    case TOK_ADDC1: /* add with carry generation */\n        opc = 0;\n    gen_op8:\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            /* constant case */\n            vswap();\n            r = gv(RC_INT);\n            vswap();\n            c = vtop->c.i;\n            if (c == (char)c) {\n                /* generate inc and dec for smaller code */\n                if ((c == 1 || c == -1) && (op == '+' || op == '-')) {\n                    opc = (c == 1) ^ (op == '+');\n                    o (0x40 | (opc << 3) | r); // inc,dec\n                } else {\n                    o(0x83);\n                    o(0xc0 | (opc << 3) | r);\n                    g(c);\n                }\n            } else {\n                o(0x81);\n                oad(0xc0 | (opc << 3) | r, c);\n            }\n        } else {\n            gv2(RC_INT, RC_INT);\n            r = vtop[-1].r;\n            fr = vtop[0].r;\n            o((opc << 3) | 0x01);\n            o(0xc0 + r + fr * 8); \n        }\n        vtop--;\n        if (op >= TOK_ULT && op <= TOK_GT)\n            vset_VT_CMP(op);\n        break;\n    case '-':\n    case TOK_SUBC1: /* sub with carry generation */\n        opc = 5;\n        goto gen_op8;\n    case TOK_ADDC2: /* add with carry use */\n        opc = 2;\n        goto gen_op8;\n    case TOK_SUBC2: /* sub with carry use */\n        opc = 3;\n        goto gen_op8;\n    case '&':\n        opc = 4;\n        goto gen_op8;\n    case '^':\n        opc = 6;\n        goto gen_op8;\n    case '|':\n        opc = 1;\n        goto gen_op8;\n    case '*':\n        gv2(RC_INT, RC_INT);\n        r = vtop[-1].r;\n        fr = vtop[0].r;\n        vtop--;\n        o(0xaf0f); /* imul fr, r */\n        o(0xc0 + fr + r * 8);\n        break;\n    case TOK_SHL:\n        opc = 4;\n        goto gen_shift;\n    case TOK_SHR:\n        opc = 5;\n        goto gen_shift;\n    case TOK_SAR:\n        opc = 7;\n    gen_shift:\n        opc = 0xc0 | (opc << 3);\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            /* constant case */\n            vswap();\n            r = gv(RC_INT);\n            vswap();\n            c = vtop->c.i & 0x1f;\n            o(0xc1); /* shl/shr/sar $xxx, r */\n            o(opc | r);\n            g(c);\n        } else {\n            /* we generate the shift in ecx */\n            gv2(RC_INT, RC_ECX);\n            r = vtop[-1].r;\n            o(0xd3); /* shl/shr/sar %cl, r */\n            o(opc | r);\n        }\n        vtop--;\n        break;\n    case '/':\n    case TOK_UDIV:\n    case TOK_PDIV:\n    case '%':\n    case TOK_UMOD:\n    case TOK_UMULL:\n        /* first operand must be in eax */\n        /* XXX: need better constraint for second operand */\n        gv2(RC_EAX, RC_ECX);\n        r = vtop[-1].r;\n        fr = vtop[0].r;\n        vtop--;\n        save_reg(TREG_EDX);\n        /* save EAX too if used otherwise */\n        save_reg_upstack(TREG_EAX, 1);\n        if (op == TOK_UMULL) {\n            o(0xf7); /* mul fr */\n            o(0xe0 + fr);\n            vtop->r2 = TREG_EDX;\n            r = TREG_EAX;\n        } else {\n            if (op == TOK_UDIV || op == TOK_UMOD) {\n                o(0xf7d231); /* xor %edx, %edx, div fr, %eax */\n                o(0xf0 + fr);\n            } else {\n                o(0xf799); /* cltd, idiv fr, %eax */\n                o(0xf8 + fr);\n            }\n            if (op == '%' || op == TOK_UMOD)\n                r = TREG_EDX;\n            else\n                r = TREG_EAX;\n        }\n        vtop->r = r;\n        break;\n    default:\n        opc = 7;\n        goto gen_op8;\n    }\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranteed to have the same floating point type */\n/* XXX: need to use ST1 too */\nST_FUNC void gen_opf(int op)\n{\n    int a, ft, fc, swapped, r;\n\n    if (op == TOK_NEG) { /* unary minus */\n        gv(RC_FLOAT);\n        o(0xe0d9); /* fchs */\n        return;\n    }\n\n    /* convert constants to memory references */\n    if ((vtop[-1].r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n        vswap();\n        gv(RC_FLOAT);\n        vswap();\n    }\n    if ((vtop[0].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)\n        gv(RC_FLOAT);\n\n    /* must put at least one value in the floating point register */\n    if ((vtop[-1].r & VT_LVAL) &&\n        (vtop[0].r & VT_LVAL)) {\n        vswap();\n        gv(RC_FLOAT);\n        vswap();\n    }\n    swapped = 0;\n    /* swap the stack if needed so that t1 is the register and t2 is\n       the memory reference */\n    if (vtop[-1].r & VT_LVAL) {\n        vswap();\n        swapped = 1;\n    }\n    if (op >= TOK_ULT && op <= TOK_GT) {\n        /* load on stack second operand */\n        load(TREG_ST0, vtop);\n        save_reg(TREG_EAX); /* eax is used by FP comparison code */\n        if (op == TOK_GE || op == TOK_GT)\n            swapped = !swapped;\n        else if (op == TOK_EQ || op == TOK_NE)\n            swapped = 0;\n        if (swapped)\n            o(0xc9d9); /* fxch %st(1) */\n        if (op == TOK_EQ || op == TOK_NE)\n            o(0xe9da); /* fucompp */\n        else\n            o(0xd9de); /* fcompp */\n        o(0xe0df); /* fnstsw %ax */\n        if (op == TOK_EQ) {\n            o(0x45e480); /* and $0x45, %ah */\n            o(0x40fC80); /* cmp $0x40, %ah */\n        } else if (op == TOK_NE) {\n            o(0x45e480); /* and $0x45, %ah */\n            o(0x40f480); /* xor $0x40, %ah */\n            op = TOK_NE;\n        } else if (op == TOK_GE || op == TOK_LE) {\n            o(0x05c4f6); /* test $0x05, %ah */\n            op = TOK_EQ;\n        } else {\n            o(0x45c4f6); /* test $0x45, %ah */\n            op = TOK_EQ;\n        }\n        vtop--;\n        vset_VT_CMP(op);\n    } else {\n        /* no memory reference possible for long double operations */\n        if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE) {\n            load(TREG_ST0, vtop);\n            swapped = !swapped;\n        }\n        \n        switch(op) {\n        default:\n        case '+':\n            a = 0;\n            break;\n        case '-':\n            a = 4;\n            if (swapped)\n                a++;\n            break;\n        case '*':\n            a = 1;\n            break;\n        case '/':\n            a = 6;\n            if (swapped)\n                a++;\n            break;\n        }\n        ft = vtop->type.t;\n        fc = vtop->c.i;\n        if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n            o(0xde); /* fxxxp %st, %st(1) */\n            o(0xc1 + (a << 3));\n        } else {\n            /* if saved lvalue, then we must reload it */\n            r = vtop->r;\n            if ((r & VT_VALMASK) == VT_LLOCAL) {\n                SValue v1;\n                r = get_reg(RC_INT);\n                v1.type.t = VT_INT;\n                v1.r = VT_LOCAL | VT_LVAL;\n                v1.c.i = fc;\n                v1.sym = NULL;\n                load(r, &v1);\n                fc = 0;\n            }\n\n            if ((ft & VT_BTYPE) == VT_DOUBLE)\n                o(0xdc);\n            else\n                o(0xd8);\n            gen_modrm(a, r, vtop->sym, fc);\n        }\n        vtop--;\n    }\n}\n\n/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\nST_FUNC void gen_cvt_itof(int t)\n{\n    save_reg(TREG_ST0);\n    gv(RC_INT);\n    if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n        /* signed long long to float/double/long double (unsigned case\n           is handled generically) */\n        o(0x50 + vtop->r2); /* push r2 */\n        o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n        o(0x242cdf); /* fildll (%esp) */\n        o(0x08c483); /* add $8, %esp */\n        vtop->r2 = VT_CONST;\n    } else if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) == \n               (VT_INT | VT_UNSIGNED)) {\n        /* unsigned int to float/double/long double */\n        o(0x6a); /* push $0 */\n        g(0x00);\n        o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n        o(0x242cdf); /* fildll (%esp) */\n        o(0x08c483); /* add $8, %esp */\n    } else {\n        /* int to float/double/long double */\n        o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n        o(0x2404db); /* fildl (%esp) */\n        o(0x04c483); /* add $4, %esp */\n    }\n    vtop->r2 = VT_CONST;\n    vtop->r = TREG_ST0;\n}\n\n/* convert fp to int 't' type */\nST_FUNC void gen_cvt_ftoi(int t)\n{\n    int bt = vtop->type.t & VT_BTYPE;\n    if (bt == VT_FLOAT)\n        vpush_helper_func(TOK___fixsfdi);\n    else if (bt == VT_LDOUBLE)\n        vpush_helper_func(TOK___fixxfdi);\n    else\n        vpush_helper_func(TOK___fixdfdi);\n    vswap();\n    gfunc_call(1);\n    vpushi(0);\n    vtop->r = REG_IRET;\n    if ((t & VT_BTYPE) == VT_LLONG)\n        vtop->r2 = REG_IRE2;\n}\n\n/* convert from one floating point type to another */\nST_FUNC void gen_cvt_ftof(int t)\n{\n    /* all we have to do on i386 is to put the float in a register */\n    gv(RC_FLOAT);\n}\n\n/* char/short to int conversion */\nST_FUNC void gen_cvt_csti(int t)\n{\n    int r, sz, xl;\n    r = gv(RC_INT);\n    sz = !(t & VT_UNSIGNED);\n    xl = (t & VT_BTYPE) == VT_SHORT;\n    o(0xc0b60f /* mov[sz] %a[xl], %eax */\n        | (sz << 3 | xl) << 8\n        | (r << 3 | r) << 16\n        );\n}\n\n/* increment tcov counter */\nST_FUNC void gen_increment_tcov (SValue *sv)\n{\n   o(0x0583); /* addl $1, xxx */\n   greloc(cur_text_section, sv->sym, ind, R_386_32);\n   gen_le32(0);\n   o(1);\n   o(0x1583); /* addcl $0, xxx */\n   greloc(cur_text_section, sv->sym, ind, R_386_32);\n   gen_le32(4);\n   g(0);\n}\n\n/* computed goto support */\nST_FUNC void ggoto(void)\n{\n    gcall_or_jmp(1);\n    vtop--;\n}\n\n/* bound check support functions */\n#ifdef CONFIG_TCC_BCHECK\n\nstatic void gen_bounds_prolog(void)\n{\n    /* leave some room for bound checking code */\n    func_bound_offset = lbounds_section->data_offset;\n    func_bound_ind = ind;\n    func_bound_add_epilog = 0;\n    oad(0xb8, 0); /* lbound section pointer */\n    oad(0xb8, 0); /* call to function */\n}\n\nstatic void gen_bounds_epilog(void)\n{\n    addr_t saved_ind;\n    addr_t *bounds_ptr;\n    Sym *sym_data;\n    int offset_modified = func_bound_offset != lbounds_section->data_offset;\n\n    if (!offset_modified && !func_bound_add_epilog)\n        return;\n\n    /* add end of table info */\n    bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));\n    *bounds_ptr = 0;\n\n    sym_data = get_sym_ref(&char_pointer_type, lbounds_section,\n                           func_bound_offset, PTR_SIZE);\n\n    /* generate bound local allocation */\n    if (offset_modified) {\n        saved_ind = ind;\n        ind = func_bound_ind;\n        greloc(cur_text_section, sym_data, ind + 1, R_386_32);\n        ind = ind + 5;\n        gen_static_call(TOK___bound_local_new);\n        ind = saved_ind;\n    }\n\n    /* generate bound check local freeing */\n    o(0x5250); /* save returned value, if any */\n    greloc(cur_text_section, sym_data, ind + 1, R_386_32);\n    oad(0xb8, 0); /* mov %eax, xxx */\n    gen_static_call(TOK___bound_local_delete);\n    o(0x585a); /* restore returned value, if any */\n}\n#endif\n\n/* Save the stack pointer onto the stack */\nST_FUNC void gen_vla_sp_save(int addr) {\n    /* mov %esp,addr(%ebp)*/\n    o(0x89);\n    gen_modrm(TREG_ESP, VT_LOCAL, NULL, addr);\n}\n\n/* Restore the SP from a location on the stack */\nST_FUNC void gen_vla_sp_restore(int addr) {\n    o(0x8b);\n    gen_modrm(TREG_ESP, VT_LOCAL, NULL, addr);\n}\n\n/* Subtract from the stack pointer, and push the resulting value onto the stack */\nST_FUNC void gen_vla_alloc(CType *type, int align) {\n    int use_call = 0;\n\n#if defined(CONFIG_TCC_BCHECK)\n    use_call = tcc_state->do_bounds_check;\n#endif\n#ifdef TCC_TARGET_PE    /* alloca does more than just adjust %rsp on Windows */\n    use_call = 1;\n#endif\n    if (use_call)\n    {\n        vpush_helper_func(TOK_alloca);\n        vswap(); /* Move alloca ref past allocation size */\n        gfunc_call(1);\n    }\n    else {\n        int r;\n        r = gv(RC_INT); /* allocation size */\n        /* sub r,%rsp */\n        o(0x2b);\n        o(0xe0 | r);\n        /* We align to 16 bytes rather than align */\n        /* and ~15, %esp */\n        o(0xf0e483);\n        vpop();\n    }\n}\n\n/* end of X86 code generator */\n/*************************************************************/\n#endif\n/*************************************************************/\n"
        },
        {
          "name": "i386-link.c",
          "type": "blob",
          "size": 9.7607421875,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n#define EM_TCC_TARGET EM_386\n\n/* relocation type for 32 bit data relocation */\n#define R_DATA_32   R_386_32\n#define R_DATA_PTR  R_386_32\n#define R_JMP_SLOT  R_386_JMP_SLOT\n#define R_GLOB_DAT  R_386_GLOB_DAT\n#define R_COPY      R_386_COPY\n#define R_RELATIVE  R_386_RELATIVE\n\n#define R_NUM       R_386_NUM\n\n#define ELF_START_ADDR 0x08048000\n#define ELF_PAGE_SIZE  0x1000\n\n#define PCRELATIVE_DLLPLT 0\n#define RELOCATE_DLLPLT 1\n\n#else /* !TARGET_DEFS_ONLY */\n\n#include \"tcc.h\"\n\n#ifdef NEED_RELOC_TYPE\n/* Returns 1 for a code relocation, 0 for a data relocation. For unknown\n   relocations, returns -1. */\nST_FUNC int code_reloc (int reloc_type)\n{\n    switch (reloc_type) {\n\tcase R_386_RELATIVE:\n\tcase R_386_16:\n        case R_386_32:\n\tcase R_386_GOTPC:\n\tcase R_386_GOTOFF:\n\tcase R_386_GOT32:\n\tcase R_386_GOT32X:\n\tcase R_386_GLOB_DAT:\n\tcase R_386_COPY:\n\tcase R_386_TLS_GD:\n\tcase R_386_TLS_LDM:\n\tcase R_386_TLS_LDO_32:\n\tcase R_386_TLS_LE:\n            return 0;\n\n\tcase R_386_PC16:\n\tcase R_386_PC32:\n\tcase R_386_PLT32:\n\tcase R_386_JMP_SLOT:\n            return 1;\n    }\n    return -1;\n}\n\n/* Returns an enumerator to describe whether and when the relocation needs a\n   GOT and/or PLT entry to be created. See tcc.h for a description of the\n   different values. */\nST_FUNC int gotplt_entry_type (int reloc_type)\n{\n    switch (reloc_type) {\n\tcase R_386_RELATIVE:\n\tcase R_386_16:\n\tcase R_386_GLOB_DAT:\n\tcase R_386_JMP_SLOT:\n\tcase R_386_COPY:\n            return NO_GOTPLT_ENTRY;\n\n        case R_386_32:\n\t    /* This relocations shouldn't normally need GOT or PLT\n\t       slots if it weren't for simplicity in the code generator.\n\t       See our caller for comments.  */\n            return AUTO_GOTPLT_ENTRY;\n\n\tcase R_386_PC16:\n\tcase R_386_PC32:\n            return AUTO_GOTPLT_ENTRY;\n\n\tcase R_386_GOTPC:\n\tcase R_386_GOTOFF:\n            return BUILD_GOT_ONLY;\n\n\tcase R_386_GOT32:\n\tcase R_386_GOT32X:\n\tcase R_386_PLT32:\n\tcase R_386_TLS_GD:\n\tcase R_386_TLS_LDM:\n\tcase R_386_TLS_LDO_32:\n\tcase R_386_TLS_LE:\n            return ALWAYS_GOTPLT_ENTRY;\n    }\n    return -1;\n}\n\n#ifdef NEED_BUILD_GOT\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)\n{\n    Section *plt = s1->plt;\n    uint8_t *p;\n    int modrm;\n    unsigned plt_offset, relofs;\n\n    /* on i386 if we build a DLL, we add a %ebx offset */\n    if (s1->output_type & TCC_OUTPUT_DYN)\n        modrm = 0xa3;\n    else\n        modrm = 0x25;\n\n    /* empty PLT: create PLT0 entry that pushes the library identifier\n       (GOT + PTR_SIZE) and jumps to ld.so resolution routine\n       (GOT + 2 * PTR_SIZE) */\n    if (plt->data_offset == 0) {\n        p = section_ptr_add(plt, 16);\n        p[0] = 0xff; /* pushl got + PTR_SIZE */\n        p[1] = modrm + 0x10;\n        write32le(p + 2, PTR_SIZE);\n        p[6] = 0xff; /* jmp *(got + PTR_SIZE * 2) */\n        p[7] = modrm;\n        write32le(p + 8, PTR_SIZE * 2);\n    }\n    plt_offset = plt->data_offset;\n\n    /* The PLT slot refers to the relocation entry it needs via offset.\n       The reloc entry is created below, so its offset is the current\n       data_offset */\n    relofs = s1->plt->reloc ? s1->plt->reloc->data_offset : 0;\n\n    /* Jump to GOT entry where ld.so initially put the address of ip + 4 */\n    p = section_ptr_add(plt, 16);\n    p[0] = 0xff; /* jmp *(got + x) */\n    p[1] = modrm;\n    write32le(p + 2, got_offset);\n    p[6] = 0x68; /* push $xxx */\n    write32le(p + 7, relofs - sizeof (ElfW_Rel));\n    p[11] = 0xe9; /* jmp plt_start */\n    write32le(p + 12, -(plt->data_offset));\n    return plt_offset;\n}\n\n/* relocate the PLT: compute addresses and offsets in the PLT now that final\n   address for PLT and GOT are known (see fill_program_header) */\nST_FUNC void relocate_plt(TCCState *s1)\n{\n    uint8_t *p, *p_end;\n\n    if (!s1->plt)\n      return;\n\n    p = s1->plt->data;\n    p_end = p + s1->plt->data_offset;\n\n    if (!(s1->output_type & TCC_OUTPUT_DYN) && p < p_end) {\n        add32le(p + 2, s1->got->sh_addr);\n        add32le(p + 8, s1->got->sh_addr);\n        p += 16;\n        while (p < p_end) {\n            add32le(p + 2, s1->got->sh_addr);\n            p += 16;\n        }\n    }\n\n    if (s1->plt->reloc) {\n        ElfW_Rel *rel;\n        int x = s1->plt->sh_addr + 16 + 6;\n        p = s1->got->data;\n        for_each_elem(s1->plt->reloc, 0, rel, ElfW_Rel) {\n            write32le(p + rel->r_offset, x);\n            x += 16;\n        }\n    }\n}\n#endif\n#endif\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)\n{\n    int sym_index, esym_index;\n\n    sym_index = ELFW(R_SYM)(rel->r_info);\n\n    switch (type) {\n        case R_386_32:\n            if (s1->output_type & TCC_OUTPUT_DYN) {\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                qrel->r_offset = rel->r_offset;\n                if (esym_index) {\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_386_32);\n                    qrel++;\n                    return;\n                } else {\n                    qrel->r_info = ELFW(R_INFO)(0, R_386_RELATIVE);\n                    qrel++;\n                }\n            }\n            add32le(ptr, val);\n            return;\n        case R_386_PC32:\n            if (s1->output_type == TCC_OUTPUT_DLL) {\n                /* DLL relocation */\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                if (esym_index) {\n                    qrel->r_offset = rel->r_offset;\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_386_PC32);\n                    qrel++;\n                    return;\n                }\n            }\n            add32le(ptr, val - addr);\n            return;\n        case R_386_PLT32:\n            add32le(ptr, val - addr);\n            return;\n        case R_386_GLOB_DAT:\n        case R_386_JMP_SLOT:\n            write32le(ptr, val);\n            return;\n        case R_386_GOTPC:\n            add32le(ptr, s1->got->sh_addr - addr);\n            return;\n        case R_386_GOTOFF:\n            add32le(ptr, val - s1->got->sh_addr);\n            return;\n        case R_386_GOT32:\n        case R_386_GOT32X:\n            /* we load the got offset */\n            add32le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);\n            return;\n        case R_386_16:\n            if (s1->output_format != TCC_OUTPUT_FORMAT_BINARY) {\n            output_file:\n                tcc_error_noabort(\"can only produce 16-bit binary files\");\n            }\n            write16le(ptr, read16le(ptr) + val);\n            return;\n        case R_386_PC16:\n            if (s1->output_format != TCC_OUTPUT_FORMAT_BINARY)\n                goto output_file;\n            write16le(ptr, read16le(ptr) + val - addr);\n            return;\n        case R_386_RELATIVE:\n#ifdef TCC_TARGET_PE\n            add32le(ptr, val - s1->pe_imagebase);\n#endif\n            /* do nothing */\n            return;\n        case R_386_COPY:\n            /* This relocation must copy initialized data from the library\n            to the program .bss segment. Currently made like for ARM\n            (to remove noise of default case). Is this true?\n            */\n            return;\n        case R_386_TLS_GD:\n            {\n                static const unsigned char expect[] = {\n                    /* lea 0(,%ebx,1),%eax */\n                    0x8d, 0x04, 0x1d, 0x00, 0x00, 0x00, 0x00,\n                    /* call __tls_get_addr@PLT */\n                    0xe8, 0xfc, 0xff, 0xff, 0xff };\n                static const unsigned char replace[] = {\n                    /* mov %gs:0,%eax */\n                    0x65, 0xa1, 0x00, 0x00, 0x00, 0x00,\n                    /* sub 0,%eax */\n                    0x81, 0xe8, 0x00, 0x00, 0x00, 0x00 };\n\n                if (memcmp (ptr-3, expect, sizeof(expect)) == 0) {\n                    ElfW(Sym) *sym;\n                    Section *sec;\n                    int32_t x;\n\n                    memcpy(ptr-3, replace, sizeof(replace));\n                    rel[1].r_info = ELFW(R_INFO)(0, R_386_NONE);\n                    sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n                    sec = s1->sections[sym->st_shndx];\n                    x = sym->st_value - sec->sh_addr - sec->data_offset;\n                    add32le(ptr + 5, -x);\n                }\n                else\n                    tcc_error_noabort(\"unexpected R_386_TLS_GD pattern\");\n            }\n            return;\n        case R_386_TLS_LDM:\n            {\n                static const unsigned char expect[] = {\n                    /* lea 0(%ebx),%eax */\n                    0x8d, 0x83, 0x00, 0x00, 0x00, 0x00,\n                    /* call __tls_get_addr@PLT */\n                    0xe8, 0xfc, 0xff, 0xff, 0xff };\n                static const unsigned char replace[] = {\n                    /* mov %gs:0,%eax */\n                    0x65, 0xa1, 0x00, 0x00, 0x00, 0x00,\n                    /* nop */\n                    0x90,\n                    /* lea 0(%esi,%eiz,1),%esi */\n                    0x8d, 0x74, 0x26, 0x00 };\n\n                if (memcmp (ptr-2, expect, sizeof(expect)) == 0) {\n                    memcpy(ptr-2, replace, sizeof(replace));\n                    rel[1].r_info = ELFW(R_INFO)(0, R_386_NONE);\n                }\n                else\n                    tcc_error_noabort(\"unexpected R_386_TLS_LDM pattern\");\n            }\n            return;\n        case R_386_TLS_LDO_32:\n        case R_386_TLS_LE:\n            {\n                ElfW(Sym) *sym;\n                Section *sec;\n                int32_t x;\n\n                sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n                sec = s1->sections[sym->st_shndx];\n                x = val - sec->sh_addr - sec->data_offset;\n                add32le(ptr, x);\n            }\n            return;\n        case R_386_NONE:\n            return;\n        default:\n            fprintf(stderr,\"FIXME: handle reloc type %d at %x [%p] to %x\\n\",\n                type, (unsigned)addr, ptr, (unsigned)val);\n            return;\n    }\n}\n\n#endif /* !TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "i386-tok.h",
          "type": "blob",
          "size": 6.1845703125,
          "content": "/* ------------------------------------------------------------------ */\n/* WARNING: relative order of tokens is important. */\n\n#define DEF_BWL(x) \\\n DEF(TOK_ASM_ ## x ## b, #x \"b\") \\\n DEF(TOK_ASM_ ## x ## w, #x \"w\") \\\n DEF(TOK_ASM_ ## x ## l, #x \"l\") \\\n DEF(TOK_ASM_ ## x, #x)\n#define DEF_WL(x) \\\n DEF(TOK_ASM_ ## x ## w, #x \"w\") \\\n DEF(TOK_ASM_ ## x ## l, #x \"l\") \\\n DEF(TOK_ASM_ ## x, #x)\n#ifdef TCC_TARGET_X86_64\n# define DEF_BWLQ(x) \\\n DEF(TOK_ASM_ ## x ## b, #x \"b\") \\\n DEF(TOK_ASM_ ## x ## w, #x \"w\") \\\n DEF(TOK_ASM_ ## x ## l, #x \"l\") \\\n DEF(TOK_ASM_ ## x ## q, #x \"q\") \\\n DEF(TOK_ASM_ ## x, #x)\n# define DEF_WLQ(x) \\\n DEF(TOK_ASM_ ## x ## w, #x \"w\") \\\n DEF(TOK_ASM_ ## x ## l, #x \"l\") \\\n DEF(TOK_ASM_ ## x ## q, #x \"q\") \\\n DEF(TOK_ASM_ ## x, #x)\n# define DEF_BWLX DEF_BWLQ\n# define DEF_WLX DEF_WLQ\n/* number of sizes + 1 */\n# define NBWLX 5\n#else\n# define DEF_BWLX DEF_BWL\n# define DEF_WLX DEF_WL\n/* number of sizes + 1 */\n# define NBWLX 4\n#endif\n\n#define DEF_FP1(x) \\\n DEF(TOK_ASM_ ## f ## x ## s, \"f\" #x \"s\") \\\n DEF(TOK_ASM_ ## fi ## x ## l, \"fi\" #x \"l\") \\\n DEF(TOK_ASM_ ## f ## x ## l, \"f\" #x \"l\") \\\n DEF(TOK_ASM_ ## fi ## x ## s, \"fi\" #x \"s\")\n\n#define DEF_FP(x) \\\n DEF(TOK_ASM_ ## f ## x, \"f\" #x ) \\\n DEF(TOK_ASM_ ## f ## x ## p, \"f\" #x \"p\") \\\n DEF_FP1(x)\n\n#define DEF_ASMTEST(x,suffix) \\\n DEF_ASM(x ## o ## suffix) \\\n DEF_ASM(x ## no ## suffix) \\\n DEF_ASM(x ## b ## suffix) \\\n DEF_ASM(x ## c ## suffix) \\\n DEF_ASM(x ## nae ## suffix) \\\n DEF_ASM(x ## nb ## suffix) \\\n DEF_ASM(x ## nc ## suffix) \\\n DEF_ASM(x ## ae ## suffix) \\\n DEF_ASM(x ## e ## suffix) \\\n DEF_ASM(x ## z ## suffix) \\\n DEF_ASM(x ## ne ## suffix) \\\n DEF_ASM(x ## nz ## suffix) \\\n DEF_ASM(x ## be ## suffix) \\\n DEF_ASM(x ## na ## suffix) \\\n DEF_ASM(x ## nbe ## suffix) \\\n DEF_ASM(x ## a ## suffix) \\\n DEF_ASM(x ## s ## suffix) \\\n DEF_ASM(x ## ns ## suffix) \\\n DEF_ASM(x ## p ## suffix) \\\n DEF_ASM(x ## pe ## suffix) \\\n DEF_ASM(x ## np ## suffix) \\\n DEF_ASM(x ## po ## suffix) \\\n DEF_ASM(x ## l ## suffix) \\\n DEF_ASM(x ## nge ## suffix) \\\n DEF_ASM(x ## nl ## suffix) \\\n DEF_ASM(x ## ge ## suffix) \\\n DEF_ASM(x ## le ## suffix) \\\n DEF_ASM(x ## ng ## suffix) \\\n DEF_ASM(x ## nle ## suffix) \\\n DEF_ASM(x ## g ## suffix)\n\n/* ------------------------------------------------------------------ */\n/* register */\n DEF_ASM(al)\n DEF_ASM(cl)\n DEF_ASM(dl)\n DEF_ASM(bl)\n DEF_ASM(ah)\n DEF_ASM(ch)\n DEF_ASM(dh)\n DEF_ASM(bh)\n DEF_ASM(ax)\n DEF_ASM(cx)\n DEF_ASM(dx)\n DEF_ASM(bx)\n DEF_ASM(sp)\n DEF_ASM(bp)\n DEF_ASM(si)\n DEF_ASM(di)\n DEF_ASM(eax)\n DEF_ASM(ecx)\n DEF_ASM(edx)\n DEF_ASM(ebx)\n DEF_ASM(esp)\n DEF_ASM(ebp)\n DEF_ASM(esi)\n DEF_ASM(edi)\n#ifdef TCC_TARGET_X86_64\n DEF_ASM(rax)\n DEF_ASM(rcx)\n DEF_ASM(rdx)\n DEF_ASM(rbx)\n DEF_ASM(rsp)\n DEF_ASM(rbp)\n DEF_ASM(rsi)\n DEF_ASM(rdi)\n#endif\n DEF_ASM(mm0)\n DEF_ASM(mm1)\n DEF_ASM(mm2)\n DEF_ASM(mm3)\n DEF_ASM(mm4)\n DEF_ASM(mm5)\n DEF_ASM(mm6)\n DEF_ASM(mm7)\n DEF_ASM(xmm0)\n DEF_ASM(xmm1)\n DEF_ASM(xmm2)\n DEF_ASM(xmm3)\n DEF_ASM(xmm4)\n DEF_ASM(xmm5)\n DEF_ASM(xmm6)\n DEF_ASM(xmm7)\n DEF_ASM(cr0)\n DEF_ASM(cr1)\n DEF_ASM(cr2)\n DEF_ASM(cr3)\n DEF_ASM(cr4)\n DEF_ASM(cr5)\n DEF_ASM(cr6)\n DEF_ASM(cr7)\n DEF_ASM(tr0)\n DEF_ASM(tr1)\n DEF_ASM(tr2)\n DEF_ASM(tr3)\n DEF_ASM(tr4)\n DEF_ASM(tr5)\n DEF_ASM(tr6)\n DEF_ASM(tr7)\n DEF_ASM(db0)\n DEF_ASM(db1)\n DEF_ASM(db2)\n DEF_ASM(db3)\n DEF_ASM(db4)\n DEF_ASM(db5)\n DEF_ASM(db6)\n DEF_ASM(db7)\n DEF_ASM(dr0)\n DEF_ASM(dr1)\n DEF_ASM(dr2)\n DEF_ASM(dr3)\n DEF_ASM(dr4)\n DEF_ASM(dr5)\n DEF_ASM(dr6)\n DEF_ASM(dr7)\n DEF_ASM(es)\n DEF_ASM(cs)\n DEF_ASM(ss)\n DEF_ASM(ds)\n DEF_ASM(fs)\n DEF_ASM(gs)\n DEF_ASM(st)\n DEF_ASM(rip)\n\n#ifdef TCC_TARGET_X86_64\n /* The four low parts of sp/bp/si/di that exist only on\n    x86-64 (encoding aliased to ah,ch,dh,dh when not using REX). */\n DEF_ASM(spl)\n DEF_ASM(bpl)\n DEF_ASM(sil)\n DEF_ASM(dil)\n#endif\n /* generic two operands */\n DEF_BWLX(mov)\n\n DEF_BWLX(add)\n DEF_BWLX(or)\n DEF_BWLX(adc)\n DEF_BWLX(sbb)\n DEF_BWLX(and)\n DEF_BWLX(sub)\n DEF_BWLX(xor)\n DEF_BWLX(cmp)\n\n /* unary ops */\n DEF_BWLX(inc)\n DEF_BWLX(dec)\n DEF_BWLX(not)\n DEF_BWLX(neg)\n DEF_BWLX(mul)\n DEF_BWLX(imul)\n DEF_BWLX(div)\n DEF_BWLX(idiv)\n\n DEF_BWLX(xchg)\n DEF_BWLX(test)\n\n /* shifts */\n DEF_BWLX(rol)\n DEF_BWLX(ror)\n DEF_BWLX(rcl)\n DEF_BWLX(rcr)\n DEF_BWLX(shl)\n DEF_BWLX(shr)\n DEF_BWLX(sar)\n\n DEF_WLX(shld)\n DEF_WLX(shrd)\n\n DEF_ASM(pushw)\n DEF_ASM(pushl)\n#ifdef TCC_TARGET_X86_64\n DEF_ASM(pushq)\n#endif\n DEF_ASM(push)\n\n DEF_ASM(popw)\n DEF_ASM(popl)\n#ifdef TCC_TARGET_X86_64\n DEF_ASM(popq)\n#endif\n DEF_ASM(pop)\n\n DEF_BWL(in)\n DEF_BWL(out)\n\n DEF_WLX(movzb)\n DEF_ASM(movzwl)\n DEF_ASM(movsbw)\n DEF_ASM(movsbl)\n DEF_ASM(movswl)\n#ifdef TCC_TARGET_X86_64\n DEF_ASM(movsbq)\n DEF_ASM(movswq)\n DEF_ASM(movzwq)\n DEF_ASM(movslq)\n#endif\n\n DEF_WLX(lea)\n\n DEF_ASM(les)\n DEF_ASM(lds)\n DEF_ASM(lss)\n DEF_ASM(lfs)\n DEF_ASM(lgs)\n\n DEF_ASM(call)\n DEF_ASM(jmp)\n DEF_ASM(lcall)\n DEF_ASM(ljmp)\n\n DEF_ASMTEST(j,)\n\n DEF_ASMTEST(set,)\n DEF_ASMTEST(set,b)\n DEF_ASMTEST(cmov,)\n\n DEF_WLX(bsf)\n DEF_WLX(bsr)\n DEF_WLX(bt)\n DEF_WLX(bts)\n DEF_WLX(btr)\n DEF_WLX(btc)\n DEF_WLX(popcnt)\n DEF_WLX(tzcnt)\n DEF_WLX(lzcnt)\n\n DEF_WLX(lar)\n DEF_WLX(lsl)\n\n /* generic FP ops */\n DEF_FP(add)\n DEF_FP(mul)\n\n DEF_ASM(fcom)\n DEF_ASM(fcom_1) /* non existent op, just to have a regular table */\n DEF_FP1(com)\n\n DEF_FP(comp)\n DEF_FP(sub)\n DEF_FP(subr)\n DEF_FP(div)\n DEF_FP(divr)\n\n DEF_BWLX(xadd)\n DEF_BWLX(cmpxchg)\n\n /* string ops */\n DEF_BWLX(cmps)\n DEF_BWLX(scmp)\n DEF_BWL(ins)\n DEF_BWL(outs)\n DEF_BWLX(lods)\n DEF_BWLX(slod)\n DEF_BWLX(movs)\n DEF_BWLX(smov)\n DEF_BWLX(scas)\n DEF_BWLX(ssca)\n DEF_BWLX(stos)\n DEF_BWLX(ssto)\n\n /* generic asm ops */\n#define ALT(x)\n#define DEF_ASM_OP0(name, opcode) DEF_ASM(name)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)\n#ifdef TCC_TARGET_X86_64\n# include \"x86_64-asm.h\"\n#else\n# include \"i386-asm.h\"\n#endif\n\n#define ALT(x)\n#define DEF_ASM_OP0(name, opcode)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type) DEF_ASM(name)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) DEF_ASM(name)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) DEF_ASM(name)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) DEF_ASM(name)\n#ifdef TCC_TARGET_X86_64\n# include \"x86_64-asm.h\"\n#else\n# include \"i386-asm.h\"\n#endif\n"
        },
        {
          "name": "il-gen.c",
          "type": "blob",
          "size": 16.044921875,
          "content": "/*\n *  CIL code generator for TCC\n * \n *  Copyright (c) 2002 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#error this code has bit-rotted since 2003\n\n/* number of available registers */\n#define NB_REGS             3\n\n/* a register can belong to several classes. The classes must be\n   sorted from more general to more precise (see gv2() code which does\n   assumptions on it). */\n#define RC_ST      0x0001  /* any stack entry */\n#define RC_ST0     0x0002  /* top of stack */\n#define RC_ST1     0x0004  /* top - 1 */\n\n#define RC_INT     RC_ST\n#define RC_FLOAT   RC_ST\n#define RC_IRET    RC_ST0 /* function return: integer register */\n#define RC_LRET    RC_ST0 /* function return: second integer register */\n#define RC_FRET    RC_ST0 /* function return: float register */\n\n/* pretty names for the registers */\nenum {\n    REG_ST0 = 0,\n    REG_ST1,\n    REG_ST2,\n};\n\nconst int reg_classes[NB_REGS] = {\n    /* ST0 */ RC_ST | RC_ST0,\n    /* ST1 */ RC_ST | RC_ST1,\n    /* ST2 */ RC_ST,\n};\n\n/* return registers for function */\n#define REG_IRET REG_ST0 /* single word int return register */\n#define REG_LRET REG_ST0 /* second word return register (for long long) */\n#define REG_FRET REG_ST0 /* float return register */\n\n/* defined if function parameters must be evaluated in reverse order */\n/* #define INVERT_FUNC_PARAMS */\n\n/* defined if structures are passed as pointers. Otherwise structures\n   are directly pushed on stack. */\n/* #define FUNC_STRUCT_PARAM_AS_PTR */\n\n/* pointer size, in bytes */\n#define PTR_SIZE 4\n\n/* long double size and alignment, in bytes */\n#define LDOUBLE_SIZE  8\n#define LDOUBLE_ALIGN 8\n\n/* function call context */\ntypedef struct GFuncContext {\n    int func_call; /* func call type (FUNC_STDCALL or FUNC_CDECL) */\n} GFuncContext;\n\n/******************************************************/\n/* opcode definitions */\n\n#define IL_OP_PREFIX 0xFE\n\nenum ILOPCodes {\n#define OP(name, str, n) IL_OP_ ## name = n,\n#include \"il-opcodes.h\"\n#undef OP\n};\n\nchar *il_opcodes_str[] = {\n#define OP(name, str, n) [n] = str,\n#include \"il-opcodes.h\"\n#undef OP\n};\n\n/******************************************************/\n\n/* arguments variable numbers start from there */\n#define ARG_BASE 0x70000000\n\nstatic FILE *il_outfile;\n\nstatic void out_byte(int c)\n{\n    *(char *)ind++ = c;\n}\n\nstatic void out_le32(int c)\n{\n    out_byte(c);\n    out_byte(c >> 8);\n    out_byte(c >> 16);\n    out_byte(c >> 24);\n}\n\nstatic void init_outfile(void)\n{\n    if (!il_outfile) {\n        il_outfile = stdout;\n        fprintf(il_outfile, \n                \".assembly extern mscorlib\\n\"\n                \"{\\n\"\n                \".ver 1:0:2411:0\\n\"\n                \"}\\n\\n\");\n    }\n}\n\nstatic void out_op1(int op)\n{\n    if (op & 0x100)\n        out_byte(IL_OP_PREFIX);\n    out_byte(op & 0xff);\n}\n\n/* output an opcode with prefix */\nstatic void out_op(int op)\n{\n    out_op1(op);\n    fprintf(il_outfile, \" %s\\n\", il_opcodes_str[op]);\n}\n\nstatic void out_opb(int op, int c)\n{\n    out_op1(op);\n    out_byte(c);\n    fprintf(il_outfile, \" %s %d\\n\", il_opcodes_str[op], c);\n}\n\nstatic void out_opi(int op, int c)\n{\n    out_op1(op);\n    out_le32(c);\n    fprintf(il_outfile, \" %s 0x%x\\n\", il_opcodes_str[op], c);\n}\n\n/* XXX: not complete */\nstatic void il_type_to_str(char *buf, int buf_size, \n                           int t, const char *varstr)\n{\n    int bt;\n    Sym *s, *sa;\n    char buf1[256];\n    const char *tstr;\n\n    t = t & VT_TYPE;\n    bt = t & VT_BTYPE;\n    buf[0] = '\\0';\n    if (t & VT_UNSIGNED)\n        pstrcat(buf, buf_size, \"unsigned \");\n    switch(bt) {\n    case VT_VOID:\n        tstr = \"void\";\n        goto add_tstr;\n    case VT_BOOL:\n        tstr = \"bool\";\n        goto add_tstr;\n    case VT_BYTE:\n        tstr = \"int8\";\n        goto add_tstr;\n    case VT_SHORT:\n        tstr = \"int16\";\n        goto add_tstr;\n    case VT_ENUM:\n    case VT_INT:\n    case VT_LONG:\n        tstr = \"int32\";\n        goto add_tstr;\n    case VT_LLONG:\n        tstr = \"int64\";\n        goto add_tstr;\n    case VT_FLOAT:\n        tstr = \"float32\";\n        goto add_tstr;\n    case VT_DOUBLE:\n    case VT_LDOUBLE:\n        tstr = \"float64\";\n    add_tstr:\n        pstrcat(buf, buf_size, tstr);\n        break;\n    case VT_STRUCT:\n        tcc_error(\"structures not handled yet\");\n        break;\n    case VT_FUNC:\n        s = sym_find((unsigned)t >> VT_STRUCT_SHIFT);\n        il_type_to_str(buf, buf_size, s->t, varstr);\n        pstrcat(buf, buf_size, \"(\");\n        sa = s->next;\n        while (sa != NULL) {\n            il_type_to_str(buf1, sizeof(buf1), sa->t, NULL);\n            pstrcat(buf, buf_size, buf1);\n            sa = sa->next;\n            if (sa)\n                pstrcat(buf, buf_size, \", \");\n        }\n        pstrcat(buf, buf_size, \")\");\n        goto no_var;\n    case VT_PTR:\n        s = sym_find((unsigned)t >> VT_STRUCT_SHIFT);\n        pstrcpy(buf1, sizeof(buf1), \"*\");\n        if (varstr)\n            pstrcat(buf1, sizeof(buf1), varstr);\n        il_type_to_str(buf, buf_size, s->t, buf1);\n        goto no_var;\n    }\n    if (varstr) {\n        pstrcat(buf, buf_size, \" \");\n        pstrcat(buf, buf_size, varstr);\n    }\n no_var: ;\n}\n\n\n/* patch relocation entry with value 'val' */\nvoid greloc_patch1(Reloc *p, int val)\n{\n}\n\n/* output a symbol and patch all calls to it */\nvoid gsym_addr(t, a)\n{\n}\n\n/* output jump and return symbol */\nstatic int out_opj(int op, int c)\n{\n    out_op1(op);\n    out_le32(0);\n    if (c == 0) {\n        c = ind - (int)cur_text_section->data;\n    }\n    fprintf(il_outfile, \" %s L%d\\n\", il_opcodes_str[op], c);\n    return c;\n}\n\nvoid gsym(int t)\n{\n    fprintf(il_outfile, \"L%d:\\n\", t);\n}\n\n/* load 'r' from value 'sv' */\nvoid load(int r, SValue *sv)\n{\n    int v, fc, ft;\n\n    v = sv->r & VT_VALMASK;\n    fc = sv->c.i;\n    ft = sv->t;\n\n    if (sv->r & VT_LVAL) {\n        if (v == VT_LOCAL) {\n            if (fc >= ARG_BASE) {\n                fc -= ARG_BASE;\n                if (fc >= 0 && fc <= 4) {\n                    out_op(IL_OP_LDARG_0 + fc);\n                } else if (fc <= 0xff) {\n                    out_opb(IL_OP_LDARG_S, fc);\n                } else {\n                    out_opi(IL_OP_LDARG, fc);\n                }\n            } else {\n                if (fc >= 0 && fc <= 4) {\n                    out_op(IL_OP_LDLOC_0 + fc);\n                } else if (fc <= 0xff) {\n                    out_opb(IL_OP_LDLOC_S, fc);\n                } else {\n                    out_opi(IL_OP_LDLOC, fc);\n                }\n            }\n        } else if (v == VT_CONST) {\n                /* XXX: handle globals */\n                out_opi(IL_OP_LDSFLD, 0);\n        } else {\n            if ((ft & VT_BTYPE) == VT_FLOAT) {\n                out_op(IL_OP_LDIND_R4);\n            } else if ((ft & VT_BTYPE) == VT_DOUBLE) {\n                out_op(IL_OP_LDIND_R8);\n            } else if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n                out_op(IL_OP_LDIND_R8);\n            } else if ((ft & VT_TYPE) == VT_BYTE)\n                out_op(IL_OP_LDIND_I1);\n            else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED))\n                out_op(IL_OP_LDIND_U1);\n            else if ((ft & VT_TYPE) == VT_SHORT)\n                out_op(IL_OP_LDIND_I2);\n            else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED))\n                out_op(IL_OP_LDIND_U2);\n            else\n                out_op(IL_OP_LDIND_I4);\n        } \n    } else {\n        if (v == VT_CONST) {\n            /* XXX: handle globals */\n            if (fc >= -1 && fc <= 8) {\n                out_op(IL_OP_LDC_I4_M1 + fc + 1); \n            } else {\n                out_opi(IL_OP_LDC_I4, fc);\n            }\n        } else if (v == VT_LOCAL) {\n            if (fc >= ARG_BASE) {\n                fc -= ARG_BASE;\n                if (fc <= 0xff) {\n                    out_opb(IL_OP_LDARGA_S, fc);\n                } else {\n                    out_opi(IL_OP_LDARGA, fc);\n                }\n            } else {\n                if (fc <= 0xff) {\n                    out_opb(IL_OP_LDLOCA_S, fc);\n                } else {\n                    out_opi(IL_OP_LDLOCA, fc);\n                }\n            }\n        } else {\n            /* XXX: do it */\n        }\n    }\n}\n\n/* store register 'r' in lvalue 'v' */\nvoid store(int r, SValue *sv)\n{\n    int v, fc, ft;\n\n    v = sv->r & VT_VALMASK;\n    fc = sv->c.i;\n    ft = sv->t;\n    if (v == VT_LOCAL) {\n        if (fc >= ARG_BASE) {\n            fc -= ARG_BASE;\n            /* XXX: check IL arg store semantics */\n            if (fc <= 0xff) {\n                out_opb(IL_OP_STARG_S, fc);\n            } else {\n                out_opi(IL_OP_STARG, fc);\n            }\n        } else {\n            if (fc >= 0 && fc <= 4) {\n                out_op(IL_OP_STLOC_0 + fc);\n            } else if (fc <= 0xff) {\n                out_opb(IL_OP_STLOC_S, fc);\n            } else {\n                out_opi(IL_OP_STLOC, fc);\n            }\n        }\n    } else if (v == VT_CONST) {\n        /* XXX: handle globals */\n        out_opi(IL_OP_STSFLD, 0);\n    } else {\n        if ((ft & VT_BTYPE) == VT_FLOAT)\n            out_op(IL_OP_STIND_R4);\n        else if ((ft & VT_BTYPE) == VT_DOUBLE)\n            out_op(IL_OP_STIND_R8);\n        else if ((ft & VT_BTYPE) == VT_LDOUBLE)\n            out_op(IL_OP_STIND_R8);\n        else if ((ft & VT_BTYPE) == VT_BYTE)\n            out_op(IL_OP_STIND_I1);\n        else if ((ft & VT_BTYPE) == VT_SHORT)\n            out_op(IL_OP_STIND_I2);\n        else\n            out_op(IL_OP_STIND_I4);\n    }\n}\n\n/* start function call and return function call context */\nvoid gfunc_start(GFuncContext *c, int func_call)\n{\n    c->func_call = func_call;\n}\n\n/* push function parameter which is in (vtop->t, vtop->c). Stack entry\n   is then popped. */\nvoid gfunc_param(GFuncContext *c)\n{\n    if ((vtop->t & VT_BTYPE) == VT_STRUCT) {\n        tcc_error(\"structures passed as value not handled yet\");\n    } else {\n        /* simply push on stack */\n        gv(RC_ST0);\n    }\n    vtop--;\n}\n\n/* generate function call with address in (vtop->t, vtop->c) and free function\n   context. Stack entry is popped */\nvoid gfunc_call(GFuncContext *c)\n{\n    char buf[1024];\n\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n        /* XXX: more info needed from tcc */\n        il_type_to_str(buf, sizeof(buf), vtop->t, \"xxx\");\n        fprintf(il_outfile, \" call %s\\n\", buf);\n    } else {\n        /* indirect call */\n        gv(RC_INT);\n        il_type_to_str(buf, sizeof(buf), vtop->t, NULL);\n        fprintf(il_outfile, \" calli %s\\n\", buf);\n    }\n    vtop--;\n}\n\n/* generate function prolog of type 't' */\nvoid gfunc_prolog(int t)\n{\n    int addr, u, func_call;\n    Sym *sym;\n    char buf[1024];\n\n    init_outfile();\n\n    /* XXX: pass function name to gfunc_prolog */\n    il_type_to_str(buf, sizeof(buf), t, funcname);\n    fprintf(il_outfile, \".method static %s il managed\\n\", buf);\n    fprintf(il_outfile, \"{\\n\");\n    /* XXX: cannot do better now */\n    fprintf(il_outfile, \" .maxstack %d\\n\", NB_REGS);\n    fprintf(il_outfile, \" .locals (int32, int32, int32, int32, int32, int32, int32, int32)\\n\");\n    \n    if (!strcmp(funcname, \"main\"))\n        fprintf(il_outfile, \" .entrypoint\\n\");\n        \n    sym = sym_find((unsigned)t >> VT_STRUCT_SHIFT);\n    func_call = sym->r;\n\n    addr = ARG_BASE;\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n    func_vt = sym->t;\n    func_var = (sym->c == FUNC_ELLIPSIS);\n    if ((func_vt & VT_BTYPE) == VT_STRUCT) {\n        func_vc = addr;\n        addr++;\n    }\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n        u = sym->t;\n        sym_push(sym->v & ~SYM_FIELD, u,\n                 VT_LOCAL | lvalue_type(sym->type.t), addr);\n        addr++;\n    }\n}\n\n/* generate function epilog */\nvoid gfunc_epilog(void)\n{\n    out_op(IL_OP_RET);\n    fprintf(il_outfile, \"}\\n\\n\");\n}\n\n/* generate a jump to a label */\nint gjmp(int t)\n{\n    return out_opj(IL_OP_BR, t);\n}\n\n/* generate a jump to a fixed address */\nvoid gjmp_addr(int a)\n{\n    /* XXX: handle syms */\n    out_opi(IL_OP_BR, a);\n}\n\n/* generate a test. set 'inv' to invert test. Stack entry is popped */\nint gtst(int inv, int t)\n{\n    int v, *p, c;\n\n    v = vtop->r & VT_VALMASK;\n    if (v == VT_CMP) {\n        c = vtop->c.i ^ inv;\n        switch(c) {\n        case TOK_EQ:\n            c = IL_OP_BEQ;\n            break;\n        case TOK_NE:\n            c = IL_OP_BNE_UN;\n            break;\n        case TOK_LT:\n            c = IL_OP_BLT;\n            break;\n        case TOK_LE:\n            c = IL_OP_BLE;\n            break;\n        case TOK_GT:\n            c = IL_OP_BGT;\n            break;\n        case TOK_GE:\n            c = IL_OP_BGE;\n            break;\n        case TOK_ULT:\n            c = IL_OP_BLT_UN;\n            break;\n        case TOK_ULE:\n            c = IL_OP_BLE_UN;\n            break;\n        case TOK_UGT:\n            c = IL_OP_BGT_UN;\n            break;\n        case TOK_UGE:\n            c = IL_OP_BGE_UN;\n            break;\n        }\n        t = out_opj(c, t);\n    } else if (v == VT_JMP || v == VT_JMPI) {\n        /* && or || optimization */\n        if ((v & 1) == inv) {\n            /* insert vtop->c jump list in t */\n            p = &vtop->c.i;\n            while (*p != 0)\n                p = (int *)*p;\n            *p = t;\n            t = vtop->c.i;\n        } else {\n            t = gjmp(t);\n            gsym(vtop->c.i);\n        }\n    }\n    vtop--;\n    return t;\n}\n\n/* generate an integer binary operation */\nvoid gen_opi(int op)\n{\n    gv2(RC_ST1, RC_ST0);\n    switch(op) {\n    case '+':\n        out_op(IL_OP_ADD);\n        goto std_op;\n    case '-':\n        out_op(IL_OP_SUB);\n        goto std_op;\n    case '&':\n        out_op(IL_OP_AND);\n        goto std_op;\n    case '^':\n        out_op(IL_OP_XOR);\n        goto std_op;\n    case '|':\n        out_op(IL_OP_OR);\n        goto std_op;\n    case '*':\n        out_op(IL_OP_MUL);\n        goto std_op;\n    case TOK_SHL:\n        out_op(IL_OP_SHL);\n        goto std_op;\n    case TOK_SHR:\n        out_op(IL_OP_SHR_UN);\n        goto std_op;\n    case TOK_SAR:\n        out_op(IL_OP_SHR);\n        goto std_op;\n    case '/':\n    case TOK_PDIV:\n        out_op(IL_OP_DIV);\n        goto std_op;\n    case TOK_UDIV:\n        out_op(IL_OP_DIV_UN);\n        goto std_op;\n    case '%':\n        out_op(IL_OP_REM);\n        goto std_op;\n    case TOK_UMOD:\n        out_op(IL_OP_REM_UN);\n    std_op:\n        vtop--;\n        vtop[0].r = REG_ST0;\n        break;\n    case TOK_EQ:\n    case TOK_NE:\n    case TOK_LT:\n    case TOK_LE:\n    case TOK_GT:\n    case TOK_GE:\n    case TOK_ULT:\n    case TOK_ULE:\n    case TOK_UGT:\n    case TOK_UGE:\n        vtop--;\n        vtop[0].r = VT_CMP;\n        vtop[0].c.i = op;\n        break;\n    }\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranteed to have the same floating point type */\nvoid gen_opf(int op)\n{\n    /* same as integer */\n    gen_opi(op);\n}\n\n/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\nvoid gen_cvt_itof(int t)\n{\n    gv(RC_ST0);\n    if (t == VT_FLOAT)\n        out_op(IL_OP_CONV_R4);\n    else\n        out_op(IL_OP_CONV_R8);\n}\n\n/* convert fp to int 't' type */\n/* XXX: handle long long case */\nvoid gen_cvt_ftoi(int t)\n{\n    gv(RC_ST0);\n    switch(t) {\n    case VT_INT | VT_UNSIGNED:\n        out_op(IL_OP_CONV_U4);\n        break;\n    case VT_LLONG:\n        out_op(IL_OP_CONV_I8);\n        break;\n    case VT_LLONG | VT_UNSIGNED:\n        out_op(IL_OP_CONV_U8);\n        break;\n    default:\n        out_op(IL_OP_CONV_I4);\n        break;\n    }\n}\n\n/* convert from one floating point type to another */\nvoid gen_cvt_ftof(int t)\n{\n    gv(RC_ST0);\n    if (t == VT_FLOAT) {\n        out_op(IL_OP_CONV_R4);\n    } else {\n        out_op(IL_OP_CONV_R8);\n    }\n}\n\n/* end of CIL code generator */\n/*************************************************************/\n\n"
        },
        {
          "name": "il-opcodes.h",
          "type": "blob",
          "size": 7.43359375,
          "content": "/*\n *  CIL opcode definition\n * \n *  Copyright (c) 2002 Fabrice Bellard\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\nOP(NOP, \"nop\", 0x00)\nOP(BREAK, \"break\", 0x01)\nOP(LDARG_0, \"ldarg.0\", 0x02)\nOP(LDARG_1, \"ldarg.1\", 0x03)\nOP(LDARG_2, \"ldarg.2\", 0x04)\nOP(LDARG_3, \"ldarg.3\", 0x05)\nOP(LDLOC_0, \"ldloc.0\", 0x06)\nOP(LDLOC_1, \"ldloc.1\", 0x07)\nOP(LDLOC_2, \"ldloc.2\", 0x08)\nOP(LDLOC_3, \"ldloc.3\", 0x09)\nOP(STLOC_0, \"stloc.0\", 0x0a)\nOP(STLOC_1, \"stloc.1\", 0x0b)\nOP(STLOC_2, \"stloc.2\", 0x0c)\nOP(STLOC_3, \"stloc.3\", 0x0d)\nOP(LDARG_S, \"ldarg.s\", 0x0e)\nOP(LDARGA_S, \"ldarga.s\", 0x0f)\nOP(STARG_S, \"starg.s\", 0x10)\nOP(LDLOC_S, \"ldloc.s\", 0x11)\nOP(LDLOCA_S, \"ldloca.s\", 0x12)\nOP(STLOC_S, \"stloc.s\", 0x13)\nOP(LDNULL, \"ldnull\", 0x14)\nOP(LDC_I4_M1, \"ldc.i4.m1\", 0x15)\nOP(LDC_I4_0, \"ldc.i4.0\", 0x16)\nOP(LDC_I4_1, \"ldc.i4.1\", 0x17)\nOP(LDC_I4_2, \"ldc.i4.2\", 0x18)\nOP(LDC_I4_3, \"ldc.i4.3\", 0x19)\nOP(LDC_I4_4, \"ldc.i4.4\", 0x1a)\nOP(LDC_I4_5, \"ldc.i4.5\", 0x1b)\nOP(LDC_I4_6, \"ldc.i4.6\", 0x1c)\nOP(LDC_I4_7, \"ldc.i4.7\", 0x1d)\nOP(LDC_I4_8, \"ldc.i4.8\", 0x1e)\nOP(LDC_I4_S, \"ldc.i4.s\", 0x1f)\nOP(LDC_I4, \"ldc.i4\", 0x20)\nOP(LDC_I8, \"ldc.i8\", 0x21)\nOP(LDC_R4, \"ldc.r4\", 0x22)\nOP(LDC_R8, \"ldc.r8\", 0x23)\nOP(LDPTR, \"ldptr\", 0x24)\nOP(DUP, \"dup\", 0x25)\nOP(POP, \"pop\", 0x26)\nOP(JMP, \"jmp\", 0x27)\nOP(CALL, \"call\", 0x28)\nOP(CALLI, \"calli\", 0x29)\nOP(RET, \"ret\", 0x2a)\nOP(BR_S, \"br.s\", 0x2b)\nOP(BRFALSE_S, \"brfalse.s\", 0x2c)\nOP(BRTRUE_S, \"brtrue.s\", 0x2d)\nOP(BEQ_S, \"beq.s\", 0x2e)\nOP(BGE_S, \"bge.s\", 0x2f)\nOP(BGT_S, \"bgt.s\", 0x30)\nOP(BLE_S, \"ble.s\", 0x31)\nOP(BLT_S, \"blt.s\", 0x32)\nOP(BNE_UN_S, \"bne.un.s\", 0x33)\nOP(BGE_UN_S, \"bge.un.s\", 0x34)\nOP(BGT_UN_S, \"bgt.un.s\", 0x35)\nOP(BLE_UN_S, \"ble.un.s\", 0x36)\nOP(BLT_UN_S, \"blt.un.s\", 0x37)\nOP(BR, \"br\", 0x38)\nOP(BRFALSE, \"brfalse\", 0x39)\nOP(BRTRUE, \"brtrue\", 0x3a)\nOP(BEQ, \"beq\", 0x3b)\nOP(BGE, \"bge\", 0x3c)\nOP(BGT, \"bgt\", 0x3d)\nOP(BLE, \"ble\", 0x3e)\nOP(BLT, \"blt\", 0x3f)\nOP(BNE_UN, \"bne.un\", 0x40)\nOP(BGE_UN, \"bge.un\", 0x41)\nOP(BGT_UN, \"bgt.un\", 0x42)\nOP(BLE_UN, \"ble.un\", 0x43)\nOP(BLT_UN, \"blt.un\", 0x44)\nOP(SWITCH, \"switch\", 0x45)\nOP(LDIND_I1, \"ldind.i1\", 0x46)\nOP(LDIND_U1, \"ldind.u1\", 0x47)\nOP(LDIND_I2, \"ldind.i2\", 0x48)\nOP(LDIND_U2, \"ldind.u2\", 0x49)\nOP(LDIND_I4, \"ldind.i4\", 0x4a)\nOP(LDIND_U4, \"ldind.u4\", 0x4b)\nOP(LDIND_I8, \"ldind.i8\", 0x4c)\nOP(LDIND_I, \"ldind.i\", 0x4d)\nOP(LDIND_R4, \"ldind.r4\", 0x4e)\nOP(LDIND_R8, \"ldind.r8\", 0x4f)\nOP(LDIND_REF, \"ldind.ref\", 0x50)\nOP(STIND_REF, \"stind.ref\", 0x51)\nOP(STIND_I1, \"stind.i1\", 0x52)\nOP(STIND_I2, \"stind.i2\", 0x53)\nOP(STIND_I4, \"stind.i4\", 0x54)\nOP(STIND_I8, \"stind.i8\", 0x55)\nOP(STIND_R4, \"stind.r4\", 0x56)\nOP(STIND_R8, \"stind.r8\", 0x57)\nOP(ADD, \"add\", 0x58)\nOP(SUB, \"sub\", 0x59)\nOP(MUL, \"mul\", 0x5a)\nOP(DIV, \"div\", 0x5b)\nOP(DIV_UN, \"div.un\", 0x5c)\nOP(REM, \"rem\", 0x5d)\nOP(REM_UN, \"rem.un\", 0x5e)\nOP(AND, \"and\", 0x5f)\nOP(OR, \"or\", 0x60)\nOP(XOR, \"xor\", 0x61)\nOP(SHL, \"shl\", 0x62)\nOP(SHR, \"shr\", 0x63)\nOP(SHR_UN, \"shr.un\", 0x64)\nOP(NEG, \"neg\", 0x65)\nOP(NOT, \"not\", 0x66)\nOP(CONV_I1, \"conv.i1\", 0x67)\nOP(CONV_I2, \"conv.i2\", 0x68)\nOP(CONV_I4, \"conv.i4\", 0x69)\nOP(CONV_I8, \"conv.i8\", 0x6a)\nOP(CONV_R4, \"conv.r4\", 0x6b)\nOP(CONV_R8, \"conv.r8\", 0x6c)\nOP(CONV_U4, \"conv.u4\", 0x6d)\nOP(CONV_U8, \"conv.u8\", 0x6e)\nOP(CALLVIRT, \"callvirt\", 0x6f)\nOP(CPOBJ, \"cpobj\", 0x70)\nOP(LDOBJ, \"ldobj\", 0x71)\nOP(LDSTR, \"ldstr\", 0x72)\nOP(NEWOBJ, \"newobj\", 0x73)\nOP(CASTCLASS, \"castclass\", 0x74)\nOP(ISINST, \"isinst\", 0x75)\nOP(CONV_R_UN, \"conv.r.un\", 0x76)\nOP(ANN_DATA_S, \"ann.data.s\", 0x77)\nOP(UNBOX, \"unbox\", 0x79)\nOP(THROW, \"throw\", 0x7a)\nOP(LDFLD, \"ldfld\", 0x7b)\nOP(LDFLDA, \"ldflda\", 0x7c)\nOP(STFLD, \"stfld\", 0x7d)\nOP(LDSFLD, \"ldsfld\", 0x7e)\nOP(LDSFLDA, \"ldsflda\", 0x7f)\nOP(STSFLD, \"stsfld\", 0x80)\nOP(STOBJ, \"stobj\", 0x81)\nOP(CONV_OVF_I1_UN, \"conv.ovf.i1.un\", 0x82)\nOP(CONV_OVF_I2_UN, \"conv.ovf.i2.un\", 0x83)\nOP(CONV_OVF_I4_UN, \"conv.ovf.i4.un\", 0x84)\nOP(CONV_OVF_I8_UN, \"conv.ovf.i8.un\", 0x85)\nOP(CONV_OVF_U1_UN, \"conv.ovf.u1.un\", 0x86)\nOP(CONV_OVF_U2_UN, \"conv.ovf.u2.un\", 0x87)\nOP(CONV_OVF_U4_UN, \"conv.ovf.u4.un\", 0x88)\nOP(CONV_OVF_U8_UN, \"conv.ovf.u8.un\", 0x89)\nOP(CONV_OVF_I_UN, \"conv.ovf.i.un\", 0x8a)\nOP(CONV_OVF_U_UN, \"conv.ovf.u.un\", 0x8b)\nOP(BOX, \"box\", 0x8c)\nOP(NEWARR, \"newarr\", 0x8d)\nOP(LDLEN, \"ldlen\", 0x8e)\nOP(LDELEMA, \"ldelema\", 0x8f)\nOP(LDELEM_I1, \"ldelem.i1\", 0x90)\nOP(LDELEM_U1, \"ldelem.u1\", 0x91)\nOP(LDELEM_I2, \"ldelem.i2\", 0x92)\nOP(LDELEM_U2, \"ldelem.u2\", 0x93)\nOP(LDELEM_I4, \"ldelem.i4\", 0x94)\nOP(LDELEM_U4, \"ldelem.u4\", 0x95)\nOP(LDELEM_I8, \"ldelem.i8\", 0x96)\nOP(LDELEM_I, \"ldelem.i\", 0x97)\nOP(LDELEM_R4, \"ldelem.r4\", 0x98)\nOP(LDELEM_R8, \"ldelem.r8\", 0x99)\nOP(LDELEM_REF, \"ldelem.ref\", 0x9a)\nOP(STELEM_I, \"stelem.i\", 0x9b)\nOP(STELEM_I1, \"stelem.i1\", 0x9c)\nOP(STELEM_I2, \"stelem.i2\", 0x9d)\nOP(STELEM_I4, \"stelem.i4\", 0x9e)\nOP(STELEM_I8, \"stelem.i8\", 0x9f)\nOP(STELEM_R4, \"stelem.r4\", 0xa0)\nOP(STELEM_R8, \"stelem.r8\", 0xa1)\nOP(STELEM_REF, \"stelem.ref\", 0xa2)\nOP(CONV_OVF_I1, \"conv.ovf.i1\", 0xb3)\nOP(CONV_OVF_U1, \"conv.ovf.u1\", 0xb4)\nOP(CONV_OVF_I2, \"conv.ovf.i2\", 0xb5)\nOP(CONV_OVF_U2, \"conv.ovf.u2\", 0xb6)\nOP(CONV_OVF_I4, \"conv.ovf.i4\", 0xb7)\nOP(CONV_OVF_U4, \"conv.ovf.u4\", 0xb8)\nOP(CONV_OVF_I8, \"conv.ovf.i8\", 0xb9)\nOP(CONV_OVF_U8, \"conv.ovf.u8\", 0xba)\nOP(REFANYVAL, \"refanyval\", 0xc2)\nOP(CKFINITE, \"ckfinite\", 0xc3)\nOP(MKREFANY, \"mkrefany\", 0xc6)\nOP(ANN_CALL, \"ann.call\", 0xc7)\nOP(ANN_CATCH, \"ann.catch\", 0xc8)\nOP(ANN_DEAD, \"ann.dead\", 0xc9)\nOP(ANN_HOISTED, \"ann.hoisted\", 0xca)\nOP(ANN_HOISTED_CALL, \"ann.hoisted.call\", 0xcb)\nOP(ANN_LAB, \"ann.lab\", 0xcc)\nOP(ANN_DEF, \"ann.def\", 0xcd)\nOP(ANN_REF_S, \"ann.ref.s\", 0xce)\nOP(ANN_PHI, \"ann.phi\", 0xcf)\nOP(LDTOKEN, \"ldtoken\", 0xd0)\nOP(CONV_U2, \"conv.u2\", 0xd1)\nOP(CONV_U1, \"conv.u1\", 0xd2)\nOP(CONV_I, \"conv.i\", 0xd3)\nOP(CONV_OVF_I, \"conv.ovf.i\", 0xd4)\nOP(CONV_OVF_U, \"conv.ovf.u\", 0xd5)\nOP(ADD_OVF, \"add.ovf\", 0xd6)\nOP(ADD_OVF_UN, \"add.ovf.un\", 0xd7)\nOP(MUL_OVF, \"mul.ovf\", 0xd8)\nOP(MUL_OVF_UN, \"mul.ovf.un\", 0xd9)\nOP(SUB_OVF, \"sub.ovf\", 0xda)\nOP(SUB_OVF_UN, \"sub.ovf.un\", 0xdb)\nOP(ENDFINALLY, \"endfinally\", 0xdc)\nOP(LEAVE, \"leave\", 0xdd)\nOP(LEAVE_S, \"leave.s\", 0xde)\nOP(STIND_I, \"stind.i\", 0xdf)\nOP(CONV_U, \"conv.u\", 0xe0)\n\n/* prefix instructions. we use an opcode >= 256 to ease coding */\n\nOP(ARGLIST, \"arglist\", 0x100)\nOP(CEQ, \"ceq\", 0x101)\nOP(CGT, \"cgt\", 0x102)\nOP(CGT_UN, \"cgt.un\", 0x103)\nOP(CLT, \"clt\", 0x104)\nOP(CLT_UN, \"clt.un\", 0x105)\nOP(LDFTN, \"ldftn\", 0x106)\nOP(LDVIRTFTN, \"ldvirtftn\", 0x107)\nOP(JMPI, \"jmpi\", 0x108)\nOP(LDARG, \"ldarg\", 0x109)\nOP(LDARGA, \"ldarga\", 0x10a)\nOP(STARG, \"starg\", 0x10b)\nOP(LDLOC, \"ldloc\", 0x10c)\nOP(LDLOCA, \"ldloca\", 0x10d)\nOP(STLOC, \"stloc\", 0x10e)\nOP(LOCALLOC, \"localloc\", 0x10f)\nOP(ENDFILTER, \"endfilter\", 0x111)\nOP(UNALIGNED, \"unaligned\", 0x112)\nOP(VOLATILE, \"volatile\", 0x113)\nOP(TAIL, \"tail\", 0x114)\nOP(INITOBJ, \"initobj\", 0x115)\nOP(ANN_LIVE, \"ann.live\", 0x116)\nOP(CPBLK, \"cpblk\", 0x117)\nOP(INITBLK, \"initblk\", 0x118)\nOP(ANN_REF, \"ann.ref\", 0x119)\nOP(RETHROW, \"rethrow\", 0x11a)\nOP(SIZEOF, \"sizeof\", 0x11c)\nOP(REFANYTYPE, \"refanytype\", 0x11d)\nOP(ANN_DATA, \"ann.data\", 0x122)\nOP(ANN_ARG, \"ann.arg\", 0x123)\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "libtcc.c",
          "type": "blob",
          "size": 64.0390625,
          "content": "/*\n *  TCC - Tiny C Compiler\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef ONE_SOURCE\n# define ONE_SOURCE 1\n#endif\n\n#if ONE_SOURCE\n#include \"tccpp.c\"\n#include \"tccgen.c\"\n#include \"tccdbg.c\"\n#include \"tccasm.c\"\n#include \"tccelf.c\"\n#include \"tccrun.c\"\n#ifdef TCC_TARGET_I386\n#include \"i386-gen.c\"\n#include \"i386-link.c\"\n#include \"i386-asm.c\"\n#elif defined(TCC_TARGET_ARM)\n#include \"arm-gen.c\"\n#include \"arm-link.c\"\n#include \"arm-asm.c\"\n#elif defined(TCC_TARGET_ARM64)\n#include \"arm64-gen.c\"\n#include \"arm64-link.c\"\n#include \"arm-asm.c\"\n#elif defined(TCC_TARGET_C67)\n#include \"c67-gen.c\"\n#include \"c67-link.c\"\n#include \"tcccoff.c\"\n#elif defined(TCC_TARGET_X86_64)\n#include \"x86_64-gen.c\"\n#include \"x86_64-link.c\"\n#include \"i386-asm.c\"\n#elif defined(TCC_TARGET_RISCV64)\n#include \"riscv64-gen.c\"\n#include \"riscv64-link.c\"\n#include \"riscv64-asm.c\"\n#else\n#error unknown target\n#endif\n#ifdef TCC_TARGET_PE\n#include \"tccpe.c\"\n#endif\n#ifdef TCC_TARGET_MACHO\n#include \"tccmacho.c\"\n#endif\n#endif /* ONE_SOURCE */\n\n#include \"tcc.h\"\n\n/********************************************************/\n/* global variables */\n\n/* XXX: get rid of this ASAP (or maybe not) */\nST_DATA struct TCCState *tcc_state;\nTCC_SEM(static tcc_compile_sem);\n/* an array of pointers to memory to be free'd after errors */\nST_DATA void** stk_data;\nST_DATA int nb_stk_data;\n\n/********************************************************/\n#ifdef _WIN32\nST_FUNC char *normalize_slashes(char *path)\n{\n    char *p;\n    for (p = path; *p; ++p)\n        if (*p == '\\\\')\n            *p = '/';\n    return path;\n}\n\n#if defined LIBTCC_AS_DLL && !defined CONFIG_TCCDIR\nstatic HMODULE tcc_module;\nBOOL WINAPI DllMain (HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)\n{\n    if (DLL_PROCESS_ATTACH == dwReason)\n        tcc_module = hDll;\n    return TRUE;\n}\n#else\n#define tcc_module NULL /* NULL means executable itself */\n#endif\n\n#ifndef CONFIG_TCCDIR\n/* on win32, we suppose the lib and includes are at the location of 'tcc.exe' */\nstatic inline char *config_tccdir_w32(char *path)\n{\n    char *p;\n    GetModuleFileNameA(tcc_module, path, MAX_PATH);\n    p = tcc_basename(normalize_slashes(strlwr(path)));\n    if (p > path)\n        --p;\n    *p = 0;\n    return path;\n}\n#define CONFIG_TCCDIR config_tccdir_w32(alloca(MAX_PATH))\n#endif\n\n#ifdef TCC_IS_NATIVE\nstatic void tcc_add_systemdir(TCCState *s)\n{\n    char buf[1000];\n    GetSystemDirectoryA(buf, sizeof buf);\n    tcc_add_library_path(s, normalize_slashes(buf));\n}\n#endif\n#endif\n\n/********************************************************/\n\nPUB_FUNC void tcc_enter_state(TCCState *s1)\n{\n    if (s1->error_set_jmp_enabled)\n        return;\n    WAIT_SEM(&tcc_compile_sem);\n    tcc_state = s1;\n}\n\nPUB_FUNC void tcc_exit_state(TCCState *s1)\n{\n    if (s1->error_set_jmp_enabled)\n        return;\n    tcc_state = NULL;\n    POST_SEM(&tcc_compile_sem);\n}\n\n/********************************************************/\n/* copy a string and truncate it. */\nST_FUNC char *pstrcpy(char *buf, size_t buf_size, const char *s)\n{\n    char *q, *q_end;\n    int c;\n\n    if (buf_size > 0) {\n        q = buf;\n        q_end = buf + buf_size - 1;\n        while (q < q_end) {\n            c = *s++;\n            if (c == '\\0')\n                break;\n            *q++ = c;\n        }\n        *q = '\\0';\n    }\n    return buf;\n}\n\n/* strcat and truncate. */\nST_FUNC char *pstrcat(char *buf, size_t buf_size, const char *s)\n{\n    size_t len;\n    len = strlen(buf);\n    if (len < buf_size)\n        pstrcpy(buf + len, buf_size - len, s);\n    return buf;\n}\n\nST_FUNC char *pstrncpy(char *out, const char *in, size_t num)\n{\n    memcpy(out, in, num);\n    out[num] = '\\0';\n    return out;\n}\n\n/* extract the basename of a file */\nPUB_FUNC char *tcc_basename(const char *name)\n{\n    char *p = strchr(name, 0);\n    while (p > name && !IS_DIRSEP(p[-1]))\n        --p;\n    return p;\n}\n\n/* extract extension part of a file\n *\n * (if no extension, return pointer to end-of-string)\n */\nPUB_FUNC char *tcc_fileextension (const char *name)\n{\n    char *b = tcc_basename(name);\n    char *e = strrchr(b, '.');\n    return e ? e : strchr(b, 0);\n}\n\nST_FUNC char *tcc_load_text(int fd)\n{\n    int len = lseek(fd, 0, SEEK_END);\n    char *buf = load_data(fd, 0, len + 1);\n    if (buf)\n        buf[len] = 0;\n    return buf;\n}\n\n/********************************************************/\n/* memory management */\n\n/* we'll need the actual versions for a minute */\n#undef free\n#undef realloc\n\nstatic void *default_reallocator(void *ptr, unsigned long size)\n{\n    void *ptr1;\n    if (size == 0) {\n        free(ptr);\n        ptr1 = NULL;\n    }\n    else {\n        ptr1 = realloc(ptr, size);\n        if (!ptr1) {\n            fprintf(stderr, \"memory full\\n\");\n            exit (1);\n        }\n    }\n    return ptr1;\n}\n\nST_FUNC void libc_free(void *ptr)\n{\n    free(ptr);\n}\n\n#define free(p) use_tcc_free(p)\n#define realloc(p, s) use_tcc_realloc(p, s)\n\n/* global so that every tcc_alloc()/tcc_free() call doesn't need to be changed */\nstatic void *(*reallocator)(void*, unsigned long) = default_reallocator;\n\nLIBTCCAPI void tcc_set_realloc(TCCReallocFunc *realloc)\n{\n    reallocator = realloc ? realloc : default_reallocator;\n}\n\n/* in case MEM_DEBUG is #defined */\n#undef tcc_free\n#undef tcc_malloc\n#undef tcc_realloc\n#undef tcc_mallocz\n#undef tcc_strdup\n\nPUB_FUNC void tcc_free(void *ptr)\n{\n    reallocator(ptr, 0);\n}\n\nPUB_FUNC void *tcc_malloc(unsigned long size)\n{\n    return reallocator(0, size);\n}\n\nPUB_FUNC void *tcc_realloc(void *ptr, unsigned long size)\n{\n    return reallocator(ptr, size);\n}\n\nPUB_FUNC void *tcc_mallocz(unsigned long size)\n{\n    void *ptr;\n    ptr = tcc_malloc(size);\n    if (size)\n        memset(ptr, 0, size);\n    return ptr;\n}\n\nPUB_FUNC char *tcc_strdup(const char *str)\n{\n    char *ptr;\n    ptr = tcc_malloc(strlen(str) + 1);\n    strcpy(ptr, str);\n    return ptr;\n}\n\n#ifdef MEM_DEBUG\n\n#define MEM_DEBUG_MAGIC1 0xFEEDDEB1\n#define MEM_DEBUG_MAGIC2 0xFEEDDEB2\n#define MEM_DEBUG_MAGIC3 0xFEEDDEB3\n#define MEM_DEBUG_FILE_LEN 40\n#define MEM_DEBUG_CHECK3(header) \\\n    ((mem_debug_header_t*)((char*)header + header->size))->magic3\n#define MEM_USER_PTR(header) \\\n    ((char *)header + offsetof(mem_debug_header_t, magic3))\n#define MEM_HEADER_PTR(ptr) \\\n    (mem_debug_header_t *)((char*)ptr - offsetof(mem_debug_header_t, magic3))\n\nstruct mem_debug_header {\n    unsigned magic1;\n    unsigned size;\n    struct mem_debug_header *prev;\n    struct mem_debug_header *next;\n    int line_num;\n    char file_name[MEM_DEBUG_FILE_LEN + 1];\n    unsigned magic2;\n    ALIGNED(16) unsigned char magic3[4];\n};\n\ntypedef struct mem_debug_header mem_debug_header_t;\n\nTCC_SEM(static mem_sem);\nstatic mem_debug_header_t *mem_debug_chain;\nstatic unsigned mem_cur_size;\nstatic unsigned mem_max_size;\nstatic int nb_states;\n\nstatic mem_debug_header_t *malloc_check(void *ptr, const char *msg)\n{\n    mem_debug_header_t * header = MEM_HEADER_PTR(ptr);\n    if (header->magic1 != MEM_DEBUG_MAGIC1 ||\n        header->magic2 != MEM_DEBUG_MAGIC2 ||\n        read32le(MEM_DEBUG_CHECK3(header)) != MEM_DEBUG_MAGIC3 ||\n        header->size == (unsigned)-1) {\n        fprintf(stderr, \"%s check failed\\n\", msg);\n        if (header->magic1 == MEM_DEBUG_MAGIC1)\n            fprintf(stderr, \"%s:%u: block allocated here.\\n\",\n                header->file_name, header->line_num);\n        exit(1);\n    }\n    return header;\n}\n\nPUB_FUNC void *tcc_malloc_debug(unsigned long size, const char *file, int line)\n{\n    int ofs;\n    mem_debug_header_t *header;\n    if (!size)\n        return NULL;\n    header = tcc_malloc(sizeof(mem_debug_header_t) + size);\n    header->magic1 = MEM_DEBUG_MAGIC1;\n    header->magic2 = MEM_DEBUG_MAGIC2;\n    header->size = size;\n    write32le(MEM_DEBUG_CHECK3(header), MEM_DEBUG_MAGIC3);\n    header->line_num = line;\n    ofs = strlen(file) - MEM_DEBUG_FILE_LEN;\n    strncpy(header->file_name, file + (ofs > 0 ? ofs : 0), MEM_DEBUG_FILE_LEN);\n    header->file_name[MEM_DEBUG_FILE_LEN] = 0;\n    WAIT_SEM(&mem_sem);\n    header->next = mem_debug_chain;\n    header->prev = NULL;\n    if (header->next)\n        header->next->prev = header;\n    mem_debug_chain = header;\n    mem_cur_size += size;\n    if (mem_cur_size > mem_max_size)\n        mem_max_size = mem_cur_size;\n    POST_SEM(&mem_sem);\n    return MEM_USER_PTR(header);\n}\n\nPUB_FUNC void tcc_free_debug(void *ptr)\n{\n    mem_debug_header_t *header;\n    if (!ptr)\n        return;\n    header = malloc_check(ptr, \"tcc_free\");\n    WAIT_SEM(&mem_sem);\n    mem_cur_size -= header->size;\n    header->size = (unsigned)-1;\n    if (header->next)\n        header->next->prev = header->prev;\n    if (header->prev)\n        header->prev->next = header->next;\n    if (header == mem_debug_chain)\n        mem_debug_chain = header->next;\n    POST_SEM(&mem_sem);\n    tcc_free(header);\n}\n\nPUB_FUNC void *tcc_mallocz_debug(unsigned long size, const char *file, int line)\n{\n    void *ptr;\n    ptr = tcc_malloc_debug(size,file,line);\n    if (size)\n        memset(ptr, 0, size);\n    return ptr;\n}\n\nPUB_FUNC void *tcc_realloc_debug(void *ptr, unsigned long size, const char *file, int line)\n{\n    mem_debug_header_t *header;\n    int mem_debug_chain_update = 0;\n\n    if (!ptr)\n        return tcc_malloc_debug(size, file, line);\n    if (!size) {\n        tcc_free_debug(ptr);\n        return NULL;\n    }\n    header = malloc_check(ptr, \"tcc_realloc\");\n    WAIT_SEM(&mem_sem);\n    mem_cur_size -= header->size;\n    mem_debug_chain_update = (header == mem_debug_chain);\n    header = tcc_realloc(header, sizeof(mem_debug_header_t) + size);\n    header->size = size;\n    write32le(MEM_DEBUG_CHECK3(header), MEM_DEBUG_MAGIC3);\n    if (header->next)\n        header->next->prev = header;\n    if (header->prev)\n        header->prev->next = header;\n    if (mem_debug_chain_update)\n        mem_debug_chain = header;\n    mem_cur_size += size;\n    if (mem_cur_size > mem_max_size)\n        mem_max_size = mem_cur_size;\n    POST_SEM(&mem_sem);\n    return MEM_USER_PTR(header);\n}\n\nPUB_FUNC char *tcc_strdup_debug(const char *str, const char *file, int line)\n{\n    char *ptr;\n    ptr = tcc_malloc_debug(strlen(str) + 1, file, line);\n    strcpy(ptr, str);\n    return ptr;\n}\n\nPUB_FUNC void tcc_memcheck(int d)\n{\n    WAIT_SEM(&mem_sem);\n    nb_states += d;\n    if (0 == nb_states && mem_cur_size) {\n        mem_debug_header_t *header = mem_debug_chain;\n        fflush(stdout);\n        fprintf(stderr, \"MEM_DEBUG: mem_leak= %d bytes, mem_max_size= %d bytes\\n\",\n            mem_cur_size, mem_max_size);\n        while (header) {\n            fprintf(stderr, \"%s:%u: error: %u bytes leaked\\n\",\n                header->file_name, header->line_num, header->size);\n            header = header->next;\n        }\n        fflush(stderr);\n        mem_cur_size = 0;\n        mem_max_size = 0;\n        mem_debug_chain = NULL;\n#if MEM_DEBUG-0 == 2\n        exit(2);\n#endif\n    }\n    POST_SEM(&mem_sem);\n}\n\n/* restore the debug versions */\n#define tcc_free(ptr)           tcc_free_debug(ptr)\n#define tcc_malloc(size)        tcc_malloc_debug(size, __FILE__, __LINE__)\n#define tcc_mallocz(size)       tcc_mallocz_debug(size, __FILE__, __LINE__)\n#define tcc_realloc(ptr,size)   tcc_realloc_debug(ptr, size, __FILE__, __LINE__)\n#define tcc_strdup(str)         tcc_strdup_debug(str, __FILE__, __LINE__)\n\n#endif /* MEM_DEBUG */\n\n#ifdef _WIN32\n# define realpath(file, buf) _fullpath(buf, file, 260)\n#endif\n\n/* for #pragma once */\nST_FUNC int normalized_PATHCMP(const char *f1, const char *f2)\n{\n    char *p1, *p2;\n    int ret = 1;\n    if (!!(p1 = realpath(f1, NULL))) {\n        if (!!(p2 = realpath(f2, NULL))) {\n            ret = PATHCMP(p1, p2);\n            libc_free(p2); /* realpath() requirement */\n        }\n        libc_free(p1);\n    }\n    return ret;\n}\n\n/********************************************************/\n/* dynarrays */\n\nST_FUNC void dynarray_add(void *ptab, int *nb_ptr, void *data)\n{\n    int nb, nb_alloc;\n    void **pp;\n\n    nb = *nb_ptr;\n    pp = *(void ***)ptab;\n    /* every power of two we double array size */\n    if ((nb & (nb - 1)) == 0) {\n        if (!nb)\n            nb_alloc = 1;\n        else\n            nb_alloc = nb * 2;\n        pp = tcc_realloc(pp, nb_alloc * sizeof(void *));\n        *(void***)ptab = pp;\n    }\n    pp[nb++] = data;\n    *nb_ptr = nb;\n}\n\nST_FUNC void dynarray_reset(void *pp, int *n)\n{\n    void **p;\n    for (p = *(void***)pp; *n; ++p, --*n)\n        if (*p)\n            tcc_free(*p);\n    tcc_free(*(void**)pp);\n    *(void**)pp = NULL;\n}\n\nstatic void tcc_split_path(TCCState *s, void *p_ary, int *p_nb_ary, const char *in)\n{\n    const char *p;\n    do {\n        int c;\n        CString str;\n\n        cstr_new(&str);\n        for (p = in; c = *p, c != '\\0' && c != PATHSEP[0]; ++p) {\n            if (c == '{' && p[1] && p[2] == '}') {\n                c = p[1], p += 2;\n                if (c == 'B')\n                    cstr_cat(&str, s->tcc_lib_path, -1);\n                if (c == 'R')\n                    cstr_cat(&str, CONFIG_SYSROOT, -1);\n                if (c == 'f' && file) {\n                    /* substitute current file's dir */\n                    const char *f = file->true_filename;\n                    const char *b = tcc_basename(f);\n                    if (b > f)\n                        cstr_cat(&str, f, b - f - 1);\n                    else\n                        cstr_cat(&str, \".\", 1);\n                }\n            } else {\n                cstr_ccat(&str, c);\n            }\n        }\n        if (str.size) {\n            cstr_ccat(&str, '\\0');\n            dynarray_add(p_ary, p_nb_ary, tcc_strdup(str.data));\n        }\n        cstr_free(&str);\n        in = p+1;\n    } while (*p);\n}\n\n/********************************************************/\n/* warning / error */\n\n/* warn_... option bits */\n#define WARN_ON  1 /* warning is on (-Woption) */\n#define WARN_ERR 2 /* warning is an error (-Werror=option) */\n#define WARN_NOE 4 /* warning is not an error (-Wno-error=option) */\n\n/* error1() modes */\nenum { ERROR_WARN, ERROR_NOABORT, ERROR_ERROR };\n\nstatic void error1(int mode, const char *fmt, va_list ap)\n{\n    BufferedFile **pf, *f;\n    TCCState *s1 = tcc_state;\n    CString cs;\n    int line = 0;\n\n    tcc_exit_state(s1);\n\n    if (mode == ERROR_WARN) {\n        if (s1->warn_error)\n            mode = ERROR_ERROR;\n        if (s1->warn_num) {\n            /* handle tcc_warning_c(warn_option)(fmt, ...) */\n            int wopt = *(&s1->warn_none + s1->warn_num);\n            s1->warn_num = 0;\n            if (0 == (wopt & WARN_ON))\n                return;\n            if (wopt & WARN_ERR)\n                mode = ERROR_ERROR;\n            if (wopt & WARN_NOE)\n                mode = ERROR_WARN;\n        }\n        if (s1->warn_none)\n            return;\n    }\n\n    cstr_new(&cs);\n    if (fmt[0] == '%' && fmt[1] == 'i' && fmt[2] == ':')\n        line = va_arg(ap, int), fmt += 3;\n    f = NULL;\n    if (s1->error_set_jmp_enabled) { /* we're called while parsing a file */\n        /* use upper file if inline \":asm:\" or token \":paste:\" */\n        for (f = file; f && f->filename[0] == ':'; f = f->prev)\n            ;\n    }\n    if (f) {\n        for(pf = s1->include_stack; pf < s1->include_stack_ptr; pf++)\n            cstr_printf(&cs, \"In file included from %s:%d:\\n\",\n                (*pf)->filename, (*pf)->line_num - 1);\n        if (0 == line)\n            line = f->line_num - ((tok_flags & TOK_FLAG_BOL) && !macro_ptr);\n        cstr_printf(&cs, \"%s:%d: \", f->filename, line);\n    } else if (s1->current_filename) {\n        cstr_printf(&cs, \"%s: \", s1->current_filename);\n    } else {\n        cstr_printf(&cs, \"tcc: \");\n    }\n    cstr_printf(&cs, mode == ERROR_WARN ? \"warning: \" : \"error: \");\n    if (pp_expr > 1)\n        pp_error(&cs); /* special handler for preprocessor expression errors */\n    else\n        cstr_vprintf(&cs, fmt, ap);\n    if (!s1->error_func) {\n        /* default case: stderr */\n        if (s1 && s1->output_type == TCC_OUTPUT_PREPROCESS && s1->ppfp == stdout)\n            printf(\"\\n\"); /* print a newline during tcc -E */\n        fflush(stdout); /* flush -v output */\n        fprintf(stderr, \"%s\\n\", (char*)cs.data);\n        fflush(stderr); /* print error/warning now (win32) */\n    } else {\n        s1->error_func(s1->error_opaque, (char*)cs.data);\n    }\n    cstr_free(&cs);\n    if (mode != ERROR_WARN)\n        s1->nb_errors++;\n    if (mode == ERROR_ERROR && s1->error_set_jmp_enabled) {\n        while (nb_stk_data)\n            tcc_free(*(void**)stk_data[--nb_stk_data]);\n        longjmp(s1->error_jmp_buf, 1);\n    }\n}\n\nLIBTCCAPI void tcc_set_error_func(TCCState *s, void *error_opaque, TCCErrorFunc *error_func)\n{\n    s->error_opaque = error_opaque;\n    s->error_func = error_func;\n}\n\n/* error without aborting current compilation */\nPUB_FUNC int _tcc_error_noabort(const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    error1(ERROR_NOABORT, fmt, ap);\n    va_end(ap);\n    return -1;\n}\n\n#undef _tcc_error\nPUB_FUNC void _tcc_error(const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    error1(ERROR_ERROR, fmt, ap);\n    exit(1);\n}\n#define _tcc_error use_tcc_error_noabort\n\nPUB_FUNC void _tcc_warning(const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    error1(ERROR_WARN, fmt, ap);\n    va_end(ap);\n}\n\n\n/********************************************************/\n/* I/O layer */\n\nST_FUNC void tcc_open_bf(TCCState *s1, const char *filename, int initlen)\n{\n    BufferedFile *bf;\n    int buflen = initlen ? initlen : IO_BUF_SIZE;\n\n    bf = tcc_mallocz(sizeof(BufferedFile) + buflen);\n    bf->buf_ptr = bf->buffer;\n    bf->buf_end = bf->buffer + initlen;\n    bf->buf_end[0] = CH_EOB; /* put eob symbol */\n    pstrcpy(bf->filename, sizeof(bf->filename), filename);\n#ifdef _WIN32\n    normalize_slashes(bf->filename);\n#endif\n    bf->true_filename = bf->filename;\n    bf->line_num = 1;\n    bf->ifdef_stack_ptr = s1->ifdef_stack_ptr;\n    bf->fd = -1;\n    bf->prev = file;\n    bf->prev_tok_flags = tok_flags;\n    file = bf;\n    tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;\n}\n\nST_FUNC void tcc_close(void)\n{\n    TCCState *s1 = tcc_state;\n    BufferedFile *bf = file;\n    if (bf->fd > 0) {\n        close(bf->fd);\n        total_lines += bf->line_num - 1;\n    }\n    if (bf->true_filename != bf->filename)\n        tcc_free(bf->true_filename);\n    file = bf->prev;\n    tok_flags = bf->prev_tok_flags;\n    tcc_free(bf);\n}\n\nstatic int _tcc_open(TCCState *s1, const char *filename)\n{\n    int fd;\n    if (strcmp(filename, \"-\") == 0)\n        fd = 0, filename = \"<stdin>\";\n    else\n        fd = open(filename, O_RDONLY | O_BINARY);\n    if ((s1->verbose == 2 && fd >= 0) || s1->verbose == 3)\n        printf(\"%s %*s%s\\n\", fd < 0 ? \"nf\":\"->\",\n               (int)(s1->include_stack_ptr - s1->include_stack), \"\", filename);\n    return fd;\n}\n\nST_FUNC int tcc_open(TCCState *s1, const char *filename)\n{\n    int fd = _tcc_open(s1, filename);\n    if (fd < 0)\n        return -1;\n    tcc_open_bf(s1, filename, 0);\n    file->fd = fd;\n    return 0;\n}\n\n/* compile the file opened in 'file'. Return non zero if errors. */\nstatic int tcc_compile(TCCState *s1, int filetype, const char *str, int fd)\n{\n    /* Here we enter the code section where we use the global variables for\n       parsing and code generation (tccpp.c, tccgen.c, <target>-gen.c).\n       Other threads need to wait until we're done.\n\n       Alternatively we could use thread local storage for those global\n       variables, which may or may not have advantages */\n\n    tcc_enter_state(s1);\n    s1->error_set_jmp_enabled = 1;\n\n    if (setjmp(s1->error_jmp_buf) == 0) {\n        s1->nb_errors = 0;\n\n        if (fd == -1) {\n            int len = strlen(str);\n            tcc_open_bf(s1, \"<string>\", len);\n            memcpy(file->buffer, str, len);\n        } else {\n            tcc_open_bf(s1, str, 0);\n            file->fd = fd;\n        }\n\n        preprocess_start(s1, filetype);\n        tccgen_init(s1);\n\n        if (s1->output_type == TCC_OUTPUT_PREPROCESS) {\n            tcc_preprocess(s1);\n        } else {\n            tccelf_begin_file(s1);\n            if (filetype & (AFF_TYPE_ASM | AFF_TYPE_ASMPP)) {\n                tcc_assemble(s1, !!(filetype & AFF_TYPE_ASMPP));\n            } else {\n                tccgen_compile(s1);\n            }\n            tccelf_end_file(s1);\n        }\n    }\n    tccgen_finish(s1);\n    preprocess_end(s1);\n    s1->error_set_jmp_enabled = 0;\n    tcc_exit_state(s1);\n    return s1->nb_errors != 0 ? -1 : 0;\n}\n\nLIBTCCAPI int tcc_compile_string(TCCState *s, const char *str)\n{\n    return tcc_compile(s, s->filetype, str, -1);\n}\n\n/* define a preprocessor symbol. value can be NULL, sym can be \"sym=val\" */\nLIBTCCAPI void tcc_define_symbol(TCCState *s1, const char *sym, const char *value)\n{\n    const char *eq;\n    if (NULL == (eq = strchr(sym, '=')))\n        eq = strchr(sym, 0);\n    if (NULL == value)\n        value = *eq ? eq + 1 : \"1\";\n    cstr_printf(&s1->cmdline_defs, \"#define %.*s %s\\n\", (int)(eq-sym), sym, value);\n}\n\n/* undefine a preprocessor symbol */\nLIBTCCAPI void tcc_undefine_symbol(TCCState *s1, const char *sym)\n{\n    cstr_printf(&s1->cmdline_defs, \"#undef %s\\n\", sym);\n}\n\n\nLIBTCCAPI TCCState *tcc_new(void)\n{\n    TCCState *s;\n\n    s = tcc_mallocz(sizeof(TCCState));\n#ifdef MEM_DEBUG\n    tcc_memcheck(1);\n#endif\n\n#undef gnu_ext\n    s->gnu_ext = 1;\n    s->tcc_ext = 1;\n    s->nocommon = 1;\n    s->dollars_in_identifiers = 1; /*on by default like in gcc/clang*/\n    s->cversion = 199901; /* default unless -std=c11 is supplied */\n    s->warn_implicit_function_declaration = 1;\n    s->warn_discarded_qualifiers = 1;\n    s->ms_extensions = 1;\n    s->unwind_tables = 1;\n\n#ifdef CHAR_IS_UNSIGNED\n    s->char_is_unsigned = 1;\n#endif\n#ifdef TCC_TARGET_I386\n    s->seg_size = 32;\n#endif\n    /* enable this if you want symbols with leading underscore on windows: */\n#if defined TCC_TARGET_MACHO /* || defined TCC_TARGET_PE */\n    s->leading_underscore = 1;\n#endif\n#ifdef TCC_TARGET_ARM\n    s->float_abi = ARM_FLOAT_ABI;\n#endif\n#ifdef CONFIG_NEW_DTAGS\n    s->enable_new_dtags = 1;\n#endif\n    s->ppfp = stdout;\n    /* might be used in error() before preprocess_start() */\n    s->include_stack_ptr = s->include_stack;\n\n    tcc_set_lib_path(s, CONFIG_TCCDIR);\n    return s;\n}\n\nLIBTCCAPI void tcc_delete(TCCState *s1)\n{\n    /* free sections */\n    tccelf_delete(s1);\n\n    /* free library paths */\n    dynarray_reset(&s1->library_paths, &s1->nb_library_paths);\n    dynarray_reset(&s1->crt_paths, &s1->nb_crt_paths);\n\n    /* free include paths */\n    dynarray_reset(&s1->include_paths, &s1->nb_include_paths);\n    dynarray_reset(&s1->sysinclude_paths, &s1->nb_sysinclude_paths);\n\n    tcc_free(s1->tcc_lib_path);\n    tcc_free(s1->soname);\n    tcc_free(s1->rpath);\n    tcc_free(s1->elf_entryname);\n    tcc_free(s1->init_symbol);\n    tcc_free(s1->fini_symbol);\n    tcc_free(s1->mapfile);\n    tcc_free(s1->outfile);\n    tcc_free(s1->deps_outfile);\n#if defined TCC_TARGET_MACHO\n    tcc_free(s1->install_name);\n#endif\n    dynarray_reset(&s1->files, &s1->nb_files);\n    dynarray_reset(&s1->target_deps, &s1->nb_target_deps);\n    dynarray_reset(&s1->pragma_libs, &s1->nb_pragma_libs);\n    dynarray_reset(&s1->argv, &s1->argc);\n    cstr_free(&s1->cmdline_defs);\n    cstr_free(&s1->cmdline_incl);\n    cstr_free(&s1->linker_arg);\n    tcc_free(s1->dState);\n#ifdef TCC_IS_NATIVE\n    /* free runtime memory */\n    tcc_run_free(s1);\n#endif\n    /* free loaded dlls array */\n    dynarray_reset(&s1->loaded_dlls, &s1->nb_loaded_dlls);\n    tcc_free(s1);\n#ifdef MEM_DEBUG\n    tcc_memcheck(-1);\n#endif\n}\n\nLIBTCCAPI int tcc_set_output_type(TCCState *s, int output_type)\n{\n#ifdef CONFIG_TCC_PIE\n    if (output_type == TCC_OUTPUT_EXE)\n        output_type |= TCC_OUTPUT_DYN;\n#endif\n    s->output_type = output_type;\n\n    if (!s->nostdinc) {\n        /* default include paths */\n        /* -isystem paths have already been handled */\n        tcc_add_sysinclude_path(s, CONFIG_TCC_SYSINCLUDEPATHS);\n    }\n\n    if (output_type == TCC_OUTPUT_PREPROCESS) {\n        s->do_debug = 0;\n        return 0;\n    }\n\n    /* add sections */\n    tccelf_new(s);\n\n    if (output_type == TCC_OUTPUT_OBJ) {\n        /* always elf for objects */\n        s->output_format = TCC_OUTPUT_FORMAT_ELF;\n        return 0;\n    }\n\n    tcc_add_library_path(s, CONFIG_TCC_LIBPATHS);\n\n#ifdef TCC_TARGET_PE\n# ifdef TCC_IS_NATIVE\n    /* allow linking with system dll's directly */\n    tcc_add_systemdir(s);\n# endif\n#elif defined TCC_TARGET_MACHO\n# ifdef TCC_IS_NATIVE\n    tcc_add_macos_sdkpath(s);\n# endif\n#else\n    /* paths for crt objects */\n    tcc_split_path(s, &s->crt_paths, &s->nb_crt_paths, CONFIG_TCC_CRTPREFIX);\n    if (output_type != TCC_OUTPUT_MEMORY && !s->nostdlib)\n        tccelf_add_crtbegin(s);\n#endif\n    return 0;\n}\n\nLIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname)\n{\n    tcc_split_path(s, &s->include_paths, &s->nb_include_paths, pathname);\n    return 0;\n}\n\nLIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname)\n{\n    tcc_split_path(s, &s->sysinclude_paths, &s->nb_sysinclude_paths, pathname);\n    return 0;\n}\n\n/* add/update a 'DLLReference', Just find if level == -1  */\nST_FUNC DLLReference *tcc_add_dllref(TCCState *s1, const char *dllname, int level)\n{\n    DLLReference *ref = NULL;\n    int i;\n    for (i = 0; i < s1->nb_loaded_dlls; i++)\n        if (0 == strcmp(s1->loaded_dlls[i]->name, dllname)) {\n            ref = s1->loaded_dlls[i];\n            break;\n        }\n    if (level == -1)\n        return ref;\n    if (ref) {\n        if (level < ref->level)\n            ref->level = level;\n        ref->found = 1;\n        return ref;\n    }\n    ref = tcc_mallocz(sizeof(DLLReference) + strlen(dllname));\n    strcpy(ref->name, dllname);\n    dynarray_add(&s1->loaded_dlls, &s1->nb_loaded_dlls, ref);\n    ref->level = level;\n    ref->index = s1->nb_loaded_dlls;\n    return ref;\n}\n\n/* OpenBSD: choose latest from libxxx.so.x.y versions */\n#if defined TARGETOS_OpenBSD && !defined _WIN32\n#include <glob.h>\nstatic int tcc_glob_so(TCCState *s1, const char *pattern, char *buf, int size)\n{\n    const char *star;\n    glob_t g;\n    char *p;\n    int i, v, v1, v2, v3;\n\n    star = strchr(pattern, '*');\n    if (!star || glob(pattern, 0, NULL, &g))\n        return -1;\n    for (v = -1, i = 0; i < g.gl_pathc; ++i) {\n        p = g.gl_pathv[i];\n        if (2 != sscanf(p + (star - pattern), \"%d.%d.%d\", &v1, &v2, &v3))\n            continue;\n        if ((v1 = v1 * 1000 + v2) > v)\n            v = v1, pstrcpy(buf, size, p);\n    }\n    globfree(&g);\n    return v;\n}\n#endif\n\nstatic int guess_filetype(const char *filename);\n\nST_FUNC int tcc_add_file_internal(TCCState *s1, const char *filename, int flags)\n{\n    int fd, ret = -1;\n\n#if defined TARGETOS_OpenBSD && !defined _WIN32\n    char buf[1024];\n    if (tcc_glob_so(s1, filename, buf, sizeof buf) >= 0)\n        filename = buf;\n#endif\n\n    if (0 == (flags & AFF_TYPE_MASK))\n        flags |= guess_filetype(filename);\n\n    /* ignore binary files with -E */\n    if (s1->output_type == TCC_OUTPUT_PREPROCESS\n        && (flags & AFF_TYPE_BIN))\n        return 0;\n\n    /* open the file */\n    fd = _tcc_open(s1, filename);\n    if (fd < 0) {\n        if (flags & AFF_PRINT_ERROR)\n            tcc_error_noabort(\"file '%s' not found\", filename);\n        return FILE_NOT_FOUND;\n    }\n\n    s1->current_filename = filename;\n    if (flags & AFF_TYPE_BIN) {\n        ElfW(Ehdr) ehdr;\n        int obj_type;\n\n        obj_type = tcc_object_type(fd, &ehdr);\n        lseek(fd, 0, SEEK_SET);\n\n        switch (obj_type) {\n\n        case AFF_BINTYPE_REL:\n            ret = tcc_load_object_file(s1, fd, 0);\n            break;\n\n        case AFF_BINTYPE_AR:\n            ret = tcc_load_archive(s1, fd, !(flags & AFF_WHOLE_ARCHIVE));\n            break;\n\n#ifdef TCC_TARGET_PE\n        default:\n            ret = pe_load_file(s1, fd, filename);\n            goto check_success;\n\n#elif defined TCC_TARGET_MACHO\n        case AFF_BINTYPE_DYN:\n        case_dyn_or_tbd:\n            if (s1->output_type == TCC_OUTPUT_MEMORY) {\n#ifdef TCC_IS_NATIVE\n                void* dl;\n                const char* soname = filename;\n                if (obj_type != AFF_BINTYPE_DYN)\n                    soname = macho_tbd_soname(filename);\n                dl = dlopen(soname, RTLD_GLOBAL | RTLD_LAZY);\n                if (dl)\n                    tcc_add_dllref(s1, soname, 0)->handle = dl, ret = 0;\n\t        if (filename != soname)\n\t\t    tcc_free((void *)soname);\n#endif\n            } else if (obj_type == AFF_BINTYPE_DYN) {\n                ret = macho_load_dll(s1, fd, filename, (flags & AFF_REFERENCED_DLL) != 0);\n            } else {\n                ret = macho_load_tbd(s1, fd, filename, (flags & AFF_REFERENCED_DLL) != 0);\n            }\n            goto check_success;\n        default:\n        {\n            const char *ext = tcc_fileextension(filename);\n            if (!strcmp(ext, \".tbd\"))\n                goto case_dyn_or_tbd;\n            if (!strcmp(ext, \".dylib\")) {\n                obj_type = AFF_BINTYPE_DYN;\n                goto case_dyn_or_tbd;\n            }\n            goto check_success;\n        }\n\n#else /* unix */\n        case AFF_BINTYPE_DYN:\n            if (s1->output_type == TCC_OUTPUT_MEMORY) {\n#ifdef TCC_IS_NATIVE\n                void* dl = dlopen(filename, RTLD_GLOBAL | RTLD_LAZY);\n                if (dl)\n                    tcc_add_dllref(s1, filename, 0)->handle = dl, ret = 0;\n#endif\n            } else\n                ret = tcc_load_dll(s1, fd, filename, (flags & AFF_REFERENCED_DLL) != 0);\n            break;\n\n        default:\n            /* as GNU ld, consider it is an ld script if not recognized */\n            ret = tcc_load_ldscript(s1, fd);\n            goto check_success;\n\n#endif /* pe / macos / unix */\n\ncheck_success:\n            if (ret < 0)\n                tcc_error_noabort(\"%s: unrecognized file type\", filename);\n            break;\n\n#ifdef TCC_TARGET_COFF\n        case AFF_BINTYPE_C67:\n            ret = tcc_load_coff(s1, fd);\n            break;\n#endif\n        }\n        close(fd);\n    } else {\n        /* update target deps */\n        dynarray_add(&s1->target_deps, &s1->nb_target_deps, tcc_strdup(filename));\n        ret = tcc_compile(s1, flags, filename, fd);\n    }\n    s1->current_filename = NULL;\n    return ret;\n}\n\nstatic int guess_filetype(const char *filename)\n{\n    int filetype = 0;\n    if (1) {\n        /* use a file extension to detect a filetype */\n        const char *ext = tcc_fileextension(filename);\n        if (ext[0]) {\n            ext++;\n            if (!strcmp(ext, \"S\"))\n                filetype = AFF_TYPE_ASMPP;\n            else if (!strcmp(ext, \"s\"))\n                filetype = AFF_TYPE_ASM;\n            else if (!PATHCMP(ext, \"c\")\n                     || !PATHCMP(ext, \"h\")\n                     || !PATHCMP(ext, \"i\"))\n                filetype = AFF_TYPE_C;\n            else\n                filetype |= AFF_TYPE_BIN;\n        } else {\n            filetype = AFF_TYPE_C;\n        }\n    }\n    return filetype;\n}\n\nLIBTCCAPI int tcc_add_file(TCCState *s, const char *filename)\n{\n    return tcc_add_file_internal(s, filename, s->filetype | AFF_PRINT_ERROR);\n}\n\nLIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname)\n{\n    tcc_split_path(s, &s->library_paths, &s->nb_library_paths, pathname);\n    return 0;\n}\n\nstatic int tcc_add_library_internal(TCCState *s1, const char *fmt,\n    const char *filename, int flags, char **paths, int nb_paths)\n{\n    char buf[1024];\n    int i, ret;\n\n    for(i = 0; i < nb_paths; i++) {\n        snprintf(buf, sizeof(buf), fmt, paths[i], filename);\n        ret = tcc_add_file_internal(s1, buf, flags & ~AFF_PRINT_ERROR);\n        if (ret != FILE_NOT_FOUND)\n            return ret;\n    }\n    if (flags & AFF_PRINT_ERROR)\n        tcc_error_noabort(\"library '%s' not found\", filename);\n    return FILE_NOT_FOUND;\n}\n\n/* find and load a dll. Return non zero if not found */\nST_FUNC int tcc_add_dll(TCCState *s, const char *filename, int flags)\n{\n    return tcc_add_library_internal(s, \"%s/%s\", filename, flags,\n        s->library_paths, s->nb_library_paths);\n}\n\n/* find [cross-]libtcc1.a and tcc helper objects in library path */\nST_FUNC int tcc_add_support(TCCState *s1, const char *filename)\n{\n    char buf[100];\n    if (CONFIG_TCC_CROSSPREFIX[0])\n        filename = strcat(strcpy(buf, CONFIG_TCC_CROSSPREFIX), filename);\n    return tcc_add_dll(s1, filename, AFF_PRINT_ERROR);\n}\n\n#if !defined TCC_TARGET_PE && !defined TCC_TARGET_MACHO\nST_FUNC int tcc_add_crt(TCCState *s1, const char *filename)\n{\n    return tcc_add_library_internal(s1, \"%s/%s\",\n        filename, AFF_PRINT_ERROR, s1->crt_paths, s1->nb_crt_paths);\n}\n#endif\n\n/* the library name is the same as the argument of the '-l' option */\nLIBTCCAPI int tcc_add_library(TCCState *s, const char *libraryname)\n{\n#if defined TCC_TARGET_PE\n    static const char * const libs[] = { \"%s/%s.def\", \"%s/lib%s.def\", \"%s/%s.dll\", \"%s/lib%s.dll\", \"%s/lib%s.a\", NULL };\n    const char * const *pp = s->static_link ? libs + 4 : libs;\n#elif defined TCC_TARGET_MACHO\n    static const char * const libs[] = { \"%s/lib%s.dylib\", \"%s/lib%s.tbd\", \"%s/lib%s.a\", NULL };\n    const char * const *pp = s->static_link ? libs + 2 : libs;\n#elif defined TARGETOS_OpenBSD\n    static const char * const libs[] = { \"%s/lib%s.so.*\", \"%s/lib%s.a\", NULL };\n    const char * const *pp = s->static_link ? libs + 1 : libs;\n#else\n    static const char * const libs[] = { \"%s/lib%s.so\", \"%s/lib%s.a\", NULL };\n    const char * const *pp = s->static_link ? libs + 1 : libs;\n#endif\n    int flags = s->filetype & AFF_WHOLE_ARCHIVE;\n    while (*pp) {\n        int ret = tcc_add_library_internal(s, *pp,\n            libraryname, flags, s->library_paths, s->nb_library_paths);\n        if (ret != FILE_NOT_FOUND)\n            return ret;\n        ++pp;\n    }\n    return tcc_add_dll(s, libraryname, AFF_PRINT_ERROR);\n}\n\n/* handle #pragma comment(lib,) */\nST_FUNC void tcc_add_pragma_libs(TCCState *s1)\n{\n    int i;\n    for (i = 0; i < s1->nb_pragma_libs; i++)\n        tcc_add_library(s1, s1->pragma_libs[i]);\n}\n\nLIBTCCAPI int tcc_add_symbol(TCCState *s1, const char *name, const void *val)\n{\n#ifdef TCC_TARGET_PE\n    /* On x86_64 'val' might not be reachable with a 32bit offset.\n       So it is handled here as if it were in a DLL. */\n    pe_putimport(s1, 0, name, (uintptr_t)val);\n#else\n    char buf[256];\n    if (s1->leading_underscore) {\n        buf[0] = '_';\n        pstrcpy(buf + 1, sizeof(buf) - 1, name);\n        name = buf;\n    }\n    set_global_sym(s1, name, NULL, (addr_t)(uintptr_t)val); /* NULL: SHN_ABS */\n#endif\n    return 0;\n}\n\nLIBTCCAPI void tcc_set_lib_path(TCCState *s, const char *path)\n{\n    tcc_free(s->tcc_lib_path);\n    s->tcc_lib_path = tcc_strdup(path);\n}\n\n/********************************************************/\n/* options parser */\n\nstatic int strstart(const char *val, const char **str)\n{\n    const char *p, *q;\n    p = *str;\n    q = val;\n    while (*q) {\n        if (*p != *q)\n            return 0;\n        p++;\n        q++;\n    }\n    *str = p;\n    return 1;\n}\n\n/* Like strstart, but automatically takes into account that ld options can\n *\n * - start with double or single dash (e.g. '--soname' or '-soname')\n * - arguments can be given as separate or after '=' (e.g. '-Wl,-soname,x.so'\n *   or '-Wl,-soname=x.so')\n *\n * you provide `val` always in 'option[=]' form (no leading -)\n */\nstatic int link_option(const char *str, const char *val, const char **ptr)\n{\n    const char *p, *q;\n    int ret;\n\n    /* there should be 1 or 2 dashes */\n    if (*str++ != '-')\n        return 0;\n    if (*str == '-')\n        str++;\n\n    /* then str & val should match (potentially up to '=') */\n    p = str;\n    q = val;\n\n    ret = 1;\n    if (q[0] == '?') {\n        ++q;\n        if (strstart(\"no-\", &p))\n            ret = -1;\n    }\n\n    while (*q != '\\0' && *q != '=') {\n        if (*p != *q)\n            return 0;\n        p++;\n        q++;\n    }\n\n    /* '=' near eos means ',' or '=' is ok */\n    if (*q == '=') {\n        if (*p == 0)\n            *ptr = p;\n        if (*p != ',' && *p != '=')\n            return 0;\n        p++;\n    } else if (*p) {\n        return 0;\n    }\n    *ptr = p;\n    return ret;\n}\n\nstatic int link_arg(const char *opt, const char *str)\n{\n    int l = strlen(opt);\n    return 0 == strncmp(opt, str, l) && (str[l] == '\\0' || str[l] == ',');\n}\n\nstatic const char *skip_linker_arg(const char **str)\n{\n    const char *s1 = *str;\n    const char *s2 = strchr(s1, ',');\n    *str = s2 ? s2++ : (s2 = s1 + strlen(s1));\n    return s2;\n}\n\nstatic void copy_linker_arg(char **pp, const char *s, int sep)\n{\n    const char *q = s;\n    char *p = *pp;\n    int l = 0;\n    if (p && sep)\n        p[l = strlen(p)] = sep, ++l;\n    skip_linker_arg(&q);\n    pstrncpy(l + (*pp = tcc_realloc(p, q - s + l + 1)), s, q - s);\n}\n\nstatic void args_parser_add_file(TCCState *s, const char* filename, int filetype)\n{\n    struct filespec *f = tcc_malloc(sizeof *f + strlen(filename));\n    f->type = filetype;\n    strcpy(f->name, filename);\n    dynarray_add(&s->files, &s->nb_files, f);\n}\n\n/* set linker options */\nstatic int tcc_set_linker(TCCState *s, const char *option)\n{\n    TCCState *s1 = s;\n    while (*option) {\n\n        const char *p = NULL;\n        char *end = NULL;\n        int ignoring = 0;\n        int ret;\n\n        if (link_option(option, \"Bsymbolic\", &p)) {\n            s->symbolic = 1;\n        } else if (link_option(option, \"nostdlib\", &p)) {\n            s->nostdlib = 1;\n        } else if (link_option(option, \"e=\", &p)\n               ||  link_option(option, \"entry=\", &p)) {\n            copy_linker_arg(&s->elf_entryname, p, 0);\n        } else if (link_option(option, \"fini=\", &p)) {\n            copy_linker_arg(&s->fini_symbol, p, 0);\n            ignoring = 1;\n        } else if (link_option(option, \"image-base=\", &p)\n                || link_option(option, \"Ttext=\", &p)) {\n            s->text_addr = strtoull(p, &end, 16);\n            s->has_text_addr = 1;\n        } else if (link_option(option, \"init=\", &p)) {\n            copy_linker_arg(&s->init_symbol, p, 0);\n            ignoring = 1;\n        } else if (link_option(option, \"Map=\", &p)) {\n            copy_linker_arg(&s->mapfile, p, 0);\n            ignoring = 1;\n        } else if (link_option(option, \"oformat=\", &p)) {\n#if defined(TCC_TARGET_PE)\n            if (strstart(\"pe-\", &p)) {\n#elif PTR_SIZE == 8\n            if (strstart(\"elf64-\", &p)) {\n#else\n            if (strstart(\"elf32-\", &p)) {\n#endif\n                s->output_format = TCC_OUTPUT_FORMAT_ELF;\n            } else if (link_arg(\"binary\", p)) {\n                s->output_format = TCC_OUTPUT_FORMAT_BINARY;\n#ifdef TCC_TARGET_COFF\n            } else if (link_arg(\"coff\", p)) {\n                s->output_format = TCC_OUTPUT_FORMAT_COFF;\n#endif\n            } else\n                goto err;\n\n        } else if (link_option(option, \"as-needed\", &p)) {\n            ignoring = 1;\n        } else if (link_option(option, \"O\", &p)) {\n            ignoring = 1;\n        } else if (link_option(option, \"export-all-symbols\", &p)) {\n            s->rdynamic = 1;\n        } else if (link_option(option, \"export-dynamic\", &p)) {\n            s->rdynamic = 1;\n        } else if (link_option(option, \"rpath=\", &p)) {\n            copy_linker_arg(&s->rpath, p, ':');\n        } else if (link_option(option, \"enable-new-dtags\", &p)) {\n            s->enable_new_dtags = 1;\n        } else if (link_option(option, \"section-alignment=\", &p)) {\n            s->section_align = strtoul(p, &end, 16);\n        } else if (link_option(option, \"soname=\", &p)) {\n            copy_linker_arg(&s->soname, p, 0);\n        } else if (link_option(option, \"install_name=\", &p)) {\n            copy_linker_arg(&s->soname, p, 0);\n#ifdef TCC_TARGET_PE\n        } else if (link_option(option, \"large-address-aware\", &p)) {\n            s->pe_characteristics |= 0x20;\n        } else if (link_option(option, \"file-alignment=\", &p)) {\n            s->pe_file_align = strtoul(p, &end, 16);\n        } else if (link_option(option, \"stack=\", &p)) {\n            s->pe_stack_size = strtoul(p, &end, 10);\n        } else if (link_option(option, \"subsystem=\", &p)) {\n#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)\n            if (link_arg(\"native\", p)) {\n                s->pe_subsystem = 1;\n            } else if (link_arg(\"console\", p)) {\n                s->pe_subsystem = 3;\n            } else if (link_arg(\"gui\", p) || link_arg(\"windows\", p)) {\n                s->pe_subsystem = 2;\n            } else if (link_arg(\"posix\", p)) {\n                s->pe_subsystem = 7;\n            } else if (link_arg(\"efiapp\", p)) {\n                s->pe_subsystem = 10;\n            } else if (link_arg(\"efiboot\", p)) {\n                s->pe_subsystem = 11;\n            } else if (link_arg(\"efiruntime\", p)) {\n                s->pe_subsystem = 12;\n            } else if (link_arg(\"efirom\", p)) {\n                s->pe_subsystem = 13;\n#elif defined(TCC_TARGET_ARM)\n            if (link_arg(\"wince\", p)) {\n                s->pe_subsystem = 9;\n#endif\n            } else\n                goto err;\n#endif\n#ifdef TCC_TARGET_MACHO\n        } else if (link_option(option, \"all_load\", &p)) {\n\t    s->filetype |= AFF_WHOLE_ARCHIVE;\n        } else if (link_option(option, \"force_load\", &p)) {\n\t    s->filetype |= AFF_WHOLE_ARCHIVE;\n            args_parser_add_file(s, p, AFF_TYPE_LIB | (s->filetype & ~AFF_TYPE_MASK));\n            s->nb_libraries++;\n        } else if (link_option(option, \"single_module\", &p)) {\n            ignoring = 1;\n#endif\n        } else if (ret = link_option(option, \"?whole-archive\", &p), ret) {\n            if (ret > 0)\n                s->filetype |= AFF_WHOLE_ARCHIVE;\n            else\n                s->filetype &= ~AFF_WHOLE_ARCHIVE;\n        } else if (link_option(option, \"z=\", &p)) {\n            ignoring = 1;\n        } else if (p) {\n            return 0;\n        } else {\n    err:\n            return tcc_error_noabort(\"unsupported linker option '%s'\", option);\n        }\n        if (ignoring)\n            tcc_warning_c(warn_unsupported)(\"unsupported linker option '%s'\", option);\n        option = skip_linker_arg(&p);\n    }\n    return 1;\n}\n\ntypedef struct TCCOption {\n    const char *name;\n    uint16_t index;\n    uint16_t flags;\n} TCCOption;\n\nenum {\n    TCC_OPTION_ignored = 0,\n    TCC_OPTION_HELP,\n    TCC_OPTION_HELP2,\n    TCC_OPTION_v,\n    TCC_OPTION_I,\n    TCC_OPTION_D,\n    TCC_OPTION_U,\n    TCC_OPTION_P,\n    TCC_OPTION_L,\n    TCC_OPTION_B,\n    TCC_OPTION_l,\n    TCC_OPTION_bench,\n    TCC_OPTION_bt,\n    TCC_OPTION_b,\n    TCC_OPTION_ba,\n    TCC_OPTION_g,\n    TCC_OPTION_c,\n    TCC_OPTION_dumpmachine,\n    TCC_OPTION_dumpversion,\n    TCC_OPTION_d,\n    TCC_OPTION_static,\n    TCC_OPTION_std,\n    TCC_OPTION_shared,\n    TCC_OPTION_soname,\n    TCC_OPTION_o,\n    TCC_OPTION_r,\n    TCC_OPTION_Wl,\n    TCC_OPTION_Wp,\n    TCC_OPTION_W,\n    TCC_OPTION_O,\n    TCC_OPTION_mfloat_abi,\n    TCC_OPTION_m,\n    TCC_OPTION_f,\n    TCC_OPTION_isystem,\n    TCC_OPTION_iwithprefix,\n    TCC_OPTION_include,\n    TCC_OPTION_nostdinc,\n    TCC_OPTION_nostdlib,\n    TCC_OPTION_print_search_dirs,\n    TCC_OPTION_rdynamic,\n    TCC_OPTION_pthread,\n    TCC_OPTION_run,\n    TCC_OPTION_w,\n    TCC_OPTION_E,\n    TCC_OPTION_M,\n    TCC_OPTION_MD,\n    TCC_OPTION_MF,\n    TCC_OPTION_MM,\n    TCC_OPTION_MMD,\n    TCC_OPTION_MP,\n    TCC_OPTION_x,\n    TCC_OPTION_ar,\n    TCC_OPTION_impdef,\n    TCC_OPTION_dynamiclib,\n    TCC_OPTION_flat_namespace,\n    TCC_OPTION_two_levelnamespace,\n    TCC_OPTION_undefined,\n    TCC_OPTION_install_name,\n    TCC_OPTION_compatibility_version ,\n    TCC_OPTION_current_version,\n};\n\n#define TCC_OPTION_HAS_ARG 0x0001\n#define TCC_OPTION_NOSEP   0x0002 /* cannot have space before option and arg */\n\nstatic const TCCOption tcc_options[] = {\n    { \"h\", TCC_OPTION_HELP, 0 },\n    { \"-help\", TCC_OPTION_HELP, 0 },\n    { \"?\", TCC_OPTION_HELP, 0 },\n    { \"hh\", TCC_OPTION_HELP2, 0 },\n    { \"v\", TCC_OPTION_v, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"-version\", TCC_OPTION_v, 0 }, /* handle as verbose, also prints version*/\n    { \"I\", TCC_OPTION_I, TCC_OPTION_HAS_ARG },\n    { \"D\", TCC_OPTION_D, TCC_OPTION_HAS_ARG },\n    { \"U\", TCC_OPTION_U, TCC_OPTION_HAS_ARG },\n    { \"P\", TCC_OPTION_P, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"L\", TCC_OPTION_L, TCC_OPTION_HAS_ARG },\n    { \"B\", TCC_OPTION_B, TCC_OPTION_HAS_ARG },\n    { \"l\", TCC_OPTION_l, TCC_OPTION_HAS_ARG },\n    { \"bench\", TCC_OPTION_bench, 0 },\n#ifdef CONFIG_TCC_BACKTRACE\n    { \"bt\", TCC_OPTION_bt, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n#endif\n#ifdef CONFIG_TCC_BCHECK\n    { \"b\", TCC_OPTION_b, 0 },\n#endif\n    { \"g\", TCC_OPTION_g, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n#ifdef TCC_TARGET_MACHO\n    { \"compatibility_version\", TCC_OPTION_compatibility_version, TCC_OPTION_HAS_ARG },\n    { \"current_version\", TCC_OPTION_current_version, TCC_OPTION_HAS_ARG },\n#endif\n    { \"c\", TCC_OPTION_c, 0 },\n#ifdef TCC_TARGET_MACHO\n    { \"dynamiclib\", TCC_OPTION_dynamiclib, 0 },\n#endif\n    { \"dumpmachine\", TCC_OPTION_dumpmachine, 0},\n    { \"dumpversion\", TCC_OPTION_dumpversion, 0},\n    { \"d\", TCC_OPTION_d, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"static\", TCC_OPTION_static, 0 },\n    { \"std\", TCC_OPTION_std, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"shared\", TCC_OPTION_shared, 0 },\n    { \"soname\", TCC_OPTION_soname, TCC_OPTION_HAS_ARG },\n    { \"o\", TCC_OPTION_o, TCC_OPTION_HAS_ARG },\n    { \"pthread\", TCC_OPTION_pthread, 0},\n    { \"run\", TCC_OPTION_run, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"rdynamic\", TCC_OPTION_rdynamic, 0 },\n    { \"r\", TCC_OPTION_r, 0 },\n    { \"Wl,\", TCC_OPTION_Wl, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"Wp,\", TCC_OPTION_Wp, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"W\", TCC_OPTION_W, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"O\", TCC_OPTION_O, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n#ifdef TCC_TARGET_ARM\n    { \"mfloat-abi\", TCC_OPTION_mfloat_abi, TCC_OPTION_HAS_ARG },\n#endif\n    { \"m\", TCC_OPTION_m, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n#ifdef TCC_TARGET_MACHO\n    { \"flat_namespace\", TCC_OPTION_flat_namespace, 0 },\n#endif\n    { \"f\", TCC_OPTION_f, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"isystem\", TCC_OPTION_isystem, TCC_OPTION_HAS_ARG },\n    { \"include\", TCC_OPTION_include, TCC_OPTION_HAS_ARG },\n    { \"nostdinc\", TCC_OPTION_nostdinc, 0 },\n    { \"nostdlib\", TCC_OPTION_nostdlib, 0 },\n    { \"print-search-dirs\", TCC_OPTION_print_search_dirs, 0 },\n    { \"w\", TCC_OPTION_w, 0 },\n    { \"E\", TCC_OPTION_E, 0},\n    { \"M\", TCC_OPTION_M, 0},\n    { \"MD\", TCC_OPTION_MD, 0},\n    { \"MF\", TCC_OPTION_MF, TCC_OPTION_HAS_ARG },\n    { \"MM\", TCC_OPTION_MM, 0},\n    { \"MMD\", TCC_OPTION_MMD, 0},\n    { \"MP\", TCC_OPTION_MP, 0},\n    { \"x\", TCC_OPTION_x, TCC_OPTION_HAS_ARG },\n    { \"ar\", TCC_OPTION_ar, 0},\n#ifdef TCC_TARGET_PE\n    { \"impdef\", TCC_OPTION_impdef, 0},\n#endif\n#ifdef TCC_TARGET_MACHO\n    { \"install_name\", TCC_OPTION_install_name, TCC_OPTION_HAS_ARG },\n    { \"two_levelnamespace\", TCC_OPTION_two_levelnamespace, 0 },\n    { \"undefined\", TCC_OPTION_undefined, TCC_OPTION_HAS_ARG },\n#endif\n    /* ignored (silently, except after -Wunsupported) */\n    { \"arch\", 0, TCC_OPTION_HAS_ARG},\n    { \"C\", 0, 0 },\n    { \"-param\", 0, TCC_OPTION_HAS_ARG },\n    { \"pedantic\", 0, 0 },\n    { \"pipe\", 0, 0 },\n    { \"s\", 0, 0 },\n    { \"traditional\", 0, 0 },\n    { NULL, 0, 0 },\n};\n\ntypedef struct FlagDef {\n    uint16_t offset;\n    uint16_t flags;\n    const char *name;\n} FlagDef;\n\n#define WD_ALL    0x0001 /* warning is activated when using -Wall */\n#define FD_INVERT 0x0002 /* invert value before storing */\n\nstatic const FlagDef options_W[] = {\n    { offsetof(TCCState, warn_all), WD_ALL, \"all\" },\n    { offsetof(TCCState, warn_error), 0, \"error\" },\n    { offsetof(TCCState, warn_write_strings), 0, \"write-strings\" },\n    { offsetof(TCCState, warn_unsupported), 0, \"unsupported\" },\n    { offsetof(TCCState, warn_implicit_function_declaration), WD_ALL, \"implicit-function-declaration\" },\n    { offsetof(TCCState, warn_discarded_qualifiers), WD_ALL, \"discarded-qualifiers\" },\n    { 0, 0, NULL }\n};\n\nstatic const FlagDef options_f[] = {\n    { offsetof(TCCState, char_is_unsigned), 0, \"unsigned-char\" },\n    { offsetof(TCCState, char_is_unsigned), FD_INVERT, \"signed-char\" },\n    { offsetof(TCCState, nocommon), FD_INVERT, \"common\" },\n    { offsetof(TCCState, leading_underscore), 0, \"leading-underscore\" },\n    { offsetof(TCCState, ms_extensions), 0, \"ms-extensions\" },\n    { offsetof(TCCState, dollars_in_identifiers), 0, \"dollars-in-identifiers\" },\n    { offsetof(TCCState, test_coverage), 0, \"test-coverage\" },\n    { offsetof(TCCState, reverse_funcargs), 0, \"reverse-funcargs\" },\n    { offsetof(TCCState, gnu89_inline), 0, \"gnu89-inline\" },\n    { offsetof(TCCState, unwind_tables), 0, \"asynchronous-unwind-tables\" },\n    { 0, 0, NULL }\n};\n\nstatic const FlagDef options_m[] = {\n    { offsetof(TCCState, ms_bitfields), 0, \"ms-bitfields\" },\n#ifdef TCC_TARGET_X86_64\n    { offsetof(TCCState, nosse), FD_INVERT, \"sse\" },\n#endif\n    { 0, 0, NULL }\n};\n\nstatic int set_flag(TCCState *s, const FlagDef *flags, const char *name)\n{\n    int value, mask, ret;\n    const FlagDef *p;\n    const char *r;\n    unsigned char *f;\n\n    r = name, value = !strstart(\"no-\", &r), mask = 0;\n\n    /* when called with options_W, look for -W[no-]error=<option> */\n    if ((flags->flags & WD_ALL) && strstart(\"error=\", &r))\n        value = value ? WARN_ON|WARN_ERR : WARN_NOE, mask = WARN_ON;\n\n    for (ret = -1, p = flags; p->name; ++p) {\n        if (ret) {\n            if (strcmp(r, p->name))\n                continue;\n        } else {\n            if (0 == (p->flags & WD_ALL))\n                continue;\n        }\n\n        f = (unsigned char *)s + p->offset;\n        *f = (*f & mask) | (value ^ !!(p->flags & FD_INVERT));\n\n        if (ret) {\n            ret = 0;\n            if (strcmp(r, \"all\"))\n                break;\n        }\n    }\n    return ret;\n}\n\nstatic const char dumpmachine_str[] =\n/* this is a best guess, please refine as necessary */\n#ifdef TCC_TARGET_I386\n    \"i386-pc\"\n#elif defined TCC_TARGET_X86_64\n    \"x86_64-pc\"\n#elif defined TCC_TARGET_C67\n    \"c67\"\n#elif defined TCC_TARGET_ARM\n    \"arm\"\n#elif defined TCC_TARGET_ARM64\n    \"aarch64\"\n#elif defined TCC_TARGET_RISCV64\n    \"riscv64\"\n#endif\n    \"-\"\n#ifdef TCC_TARGET_PE\n    \"mingw32\"\n#elif defined(TCC_TARGET_MACHO)\n    \"apple-darwin\"\n#elif TARGETOS_FreeBSD || TARGETOS_FreeBSD_kernel\n    \"freebsd\"\n#elif TARGETOS_OpenBSD\n    \"openbsd\"\n#elif TARGETOS_NetBSD\n    \"netbsd\"\n#elif CONFIG_TCC_MUSL\n    \"linux-musl\"\n#else\n    \"linux-gnu\"\n#endif\n;\n\nstatic int args_parser_make_argv(const char *r, int *argc, char ***argv)\n{\n    int ret = 0, q, c;\n    CString str;\n    for(;;) {\n        while (c = (unsigned char)*r, c && c <= ' ')\n          ++r;\n        if (c == 0)\n            break;\n        q = 0;\n        cstr_new(&str);\n        while (c = (unsigned char)*r, c) {\n            ++r;\n            if (c == '\\\\' && (*r == '\"' || *r == '\\\\')) {\n                c = *r++;\n            } else if (c == '\"') {\n                q = !q;\n                continue;\n            } else if (q == 0 && c <= ' ') {\n                break;\n            }\n            cstr_ccat(&str, c);\n        }\n        cstr_ccat(&str, 0);\n        //printf(\"<%s>\\n\", str.data), fflush(stdout);\n        dynarray_add(argv, argc, tcc_strdup(str.data));\n        cstr_free(&str);\n        ++ret;\n    }\n    return ret;\n}\n\n/* read list file */\nstatic int args_parser_listfile(TCCState *s,\n    const char *filename, int optind, int *pargc, char ***pargv)\n{\n    TCCState *s1 = s;\n    int fd, i;\n    char *p;\n    int argc = 0;\n    char **argv = NULL;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return tcc_error_noabort(\"listfile '%s' not found\", filename);\n\n    p = tcc_load_text(fd);\n    for (i = 0; i < *pargc; ++i)\n        if (i == optind)\n            args_parser_make_argv(p, &argc, &argv);\n        else\n            dynarray_add(&argv, &argc, tcc_strdup((*pargv)[i]));\n\n    tcc_free(p);\n    dynarray_reset(&s->argv, &s->argc);\n    *pargc = s->argc = argc, *pargv = s->argv = argv;\n    return 0;\n}\n\n#if defined TCC_TARGET_MACHO\nstatic uint32_t parse_version(TCCState *s1, const char *version)\n{\n    uint32_t a = 0;\n    uint32_t b = 0;\n    uint32_t c = 0;\n    char* last;\n\n    a = strtoul(version, &last, 10);\n    if (*last == '.') {\n        b = strtoul(&last[1], &last, 10);\n        if (*last == '.')\n             c = strtoul(&last[1], &last, 10);\n    }\n    if (*last || a > 0xffff || b > 0xff || c > 0xff)\n        tcc_error_noabort(\"version a.b.c not correct: %s\", version);\n    return (a << 16) | (b << 8) | c;\n}\n#endif\n\nPUB_FUNC int tcc_parse_args(TCCState *s, int *pargc, char ***pargv, int optind)\n{\n    TCCState *s1 = s;\n    const TCCOption *popt;\n    const char *optarg, *r;\n    const char *run = NULL;\n    int x;\n    int tool = 0, arg_start = 0, noaction = optind;\n    char **argv = *pargv;\n    int argc = *pargc;\n\n    cstr_reset(&s->linker_arg);\n\n    while (optind < argc) {\n        r = argv[optind];\n        if (r[0] == '@' && r[1] != '\\0') {\n            if (args_parser_listfile(s, r + 1, optind, &argc, &argv))\n                return -1;\n            continue;\n        }\n        optind++;\n        if (tool) {\n            if (r[0] == '-' && r[1] == 'v' && r[2] == 0)\n                ++s->verbose;\n            continue;\n        }\nreparse:\n        if (r[0] != '-' || r[1] == '\\0') {\n            args_parser_add_file(s, r, s->filetype);\n            if (run) {\ndorun:\n                if (tcc_set_options(s, run))\n                    return -1;\n                arg_start = optind - 1;\n                break;\n            }\n            continue;\n        }\n\n        /* allow \"tcc files... -run -- args ...\" */\n        if (r[1] == '-' && r[2] == '\\0' && run)\n            goto dorun;\n\n        /* find option in table */\n        for(popt = tcc_options; ; ++popt) {\n            const char *p1 = popt->name;\n            const char *r1 = r + 1;\n            if (p1 == NULL)\n                return tcc_error_noabort(\"invalid option -- '%s'\", r);\n            if (!strstart(p1, &r1))\n                continue;\n            optarg = r1;\n            if (popt->flags & TCC_OPTION_HAS_ARG) {\n                if (*r1 == '\\0' && !(popt->flags & TCC_OPTION_NOSEP)) {\n                    if (optind >= argc)\n                arg_err:\n                        return tcc_error_noabort(\"argument to '%s' is missing\", r);\n                    optarg = argv[optind++];\n                }\n            } else if (*r1 != '\\0')\n                continue;\n            break;\n        }\n\n        switch(popt->index) {\n        case TCC_OPTION_HELP:\n            x = OPT_HELP;\n            goto extra_action;\n        case TCC_OPTION_HELP2:\n            x = OPT_HELP2;\n            goto extra_action;\n        case TCC_OPTION_I:\n            tcc_add_include_path(s, optarg);\n            break;\n        case TCC_OPTION_D:\n            tcc_define_symbol(s, optarg, NULL);\n            break;\n        case TCC_OPTION_U:\n            tcc_undefine_symbol(s, optarg);\n            break;\n        case TCC_OPTION_L:\n            tcc_add_library_path(s, optarg);\n            break;\n        case TCC_OPTION_B:\n            /* set tcc utilities path (mainly for tcc development) */\n            tcc_set_lib_path(s, optarg);\n            ++noaction;\n            break;\n        case TCC_OPTION_l:\n            args_parser_add_file(s, optarg, AFF_TYPE_LIB | (s->filetype & ~AFF_TYPE_MASK));\n            s->nb_libraries++;\n            break;\n        case TCC_OPTION_pthread:\n            s->option_pthread = 1;\n            break;\n        case TCC_OPTION_bench:\n            s->do_bench = 1;\n            break;\n#ifdef CONFIG_TCC_BACKTRACE\n        case TCC_OPTION_bt:\n            s->rt_num_callers = atoi(optarg); /* zero = default (6) */\n            goto enable_backtrace;\n        enable_backtrace:\n            s->do_backtrace = 1;\n            s->do_debug = s->do_debug ? s->do_debug : 1;\n\t    s->dwarf = CONFIG_DWARF_VERSION;\n            break;\n#ifdef CONFIG_TCC_BCHECK\n        case TCC_OPTION_b:\n            s->do_bounds_check = 1;\n            goto enable_backtrace;\n#endif\n#endif\n        case TCC_OPTION_g:\n            s->do_debug = 2;\n            s->dwarf = CONFIG_DWARF_VERSION;\n            if (strstart(\"dwarf\", &optarg)) {\n                s->dwarf = (*optarg) ? (0 - atoi(optarg)) : DEFAULT_DWARF_VERSION;\n            } else if (isnum(*optarg)) {\n                x = *optarg - '0';\n                /* -g0 = no info, -g1 = lines/functions only, -g2 = full info */\n                s->do_debug = x > 2 ? 2 : x == 0 && s->do_backtrace ? 1 : x;\n#ifdef TCC_TARGET_PE\n            } else if (0 == strcmp(\".pdb\", optarg)) {\n                s->dwarf = 5, s->do_debug |= 16;\n#endif\n            }\n            break;\n        case TCC_OPTION_c:\n            x = TCC_OUTPUT_OBJ;\n        set_output_type:\n            if (s->output_type)\n                tcc_warning(\"-%s: overriding compiler action already specified\", popt->name);\n            s->output_type = x;\n            break;\n        case TCC_OPTION_d:\n            if (*optarg == 'D')\n                s->dflag = 3;\n            else if (*optarg == 'M')\n                s->dflag = 7;\n            else if (*optarg == 't')\n                s->dflag = 16;\n            else if (isnum(*optarg))\n                s->g_debug |= atoi(optarg);\n            else\n                goto unsupported_option;\n            break;\n        case TCC_OPTION_static:\n            s->static_link = 1;\n            break;\n        case TCC_OPTION_std:\n            if (strcmp(optarg, \"=c11\") == 0 || strcmp(optarg, \"=gnu11\") == 0)\n                s->cversion = 201112;\n            break;\n        case TCC_OPTION_shared:\n            x = TCC_OUTPUT_DLL;\n            goto set_output_type;\n        case TCC_OPTION_soname:\n            s->soname = tcc_strdup(optarg);\n            break;\n        case TCC_OPTION_o:\n            if (s->outfile) {\n                tcc_warning(\"multiple -o option\");\n                tcc_free(s->outfile);\n            }\n            s->outfile = tcc_strdup(optarg);\n            break;\n        case TCC_OPTION_r:\n            /* generate a .o merging several output files */\n            s->option_r = 1;\n            x = TCC_OUTPUT_OBJ;\n            goto set_output_type;\n        case TCC_OPTION_isystem:\n            tcc_add_sysinclude_path(s, optarg);\n            break;\n        case TCC_OPTION_include:\n            cstr_printf(&s->cmdline_incl, \"#include \\\"%s\\\"\\n\", optarg);\n            break;\n        case TCC_OPTION_nostdinc:\n            s->nostdinc = 1;\n            break;\n        case TCC_OPTION_nostdlib:\n            s->nostdlib = 1;\n            break;\n        case TCC_OPTION_run:\n#ifndef TCC_IS_NATIVE\n            return tcc_error_noabort(\"-run is not available in a cross compiler\");\n#else\n            run = optarg;\n            x = TCC_OUTPUT_MEMORY;\n            goto set_output_type;\n#endif\n        case TCC_OPTION_v:\n            do ++s->verbose; while (*optarg++ == 'v');\n            ++noaction;\n            break;\n        case TCC_OPTION_f:\n            if (set_flag(s, options_f, optarg) < 0)\n                goto unsupported_option;\n            break;\n#ifdef TCC_TARGET_ARM\n        case TCC_OPTION_mfloat_abi:\n            /* tcc doesn't support soft float yet */\n            if (!strcmp(optarg, \"softfp\")) {\n                s->float_abi = ARM_SOFTFP_FLOAT;\n            } else if (!strcmp(optarg, \"hard\"))\n                s->float_abi = ARM_HARD_FLOAT;\n            else\n                return tcc_error_noabort(\"unsupported float abi '%s'\", optarg);\n            break;\n#endif\n        case TCC_OPTION_m:\n            if (set_flag(s, options_m, optarg) < 0) {\n                if (x = atoi(optarg), x != 32 && x != 64)\n                    goto unsupported_option;\n                if (PTR_SIZE != x/8)\n                    return x;\n                ++noaction;\n            }\n            break;\n        case TCC_OPTION_W:\n            s->warn_none = 0;\n            if (optarg[0] && set_flag(s, options_W, optarg) < 0)\n                goto unsupported_option;\n            break;\n        case TCC_OPTION_w:\n            s->warn_none = 1;\n            break;\n        case TCC_OPTION_rdynamic:\n            s->rdynamic = 1;\n            break;\n        case TCC_OPTION_Wl:\n            if (s->linker_arg.size)\n                ((char*)s->linker_arg.data)[s->linker_arg.size - 1] = ',';\n            cstr_cat(&s->linker_arg, optarg, 0);\n            x = tcc_set_linker(s, s->linker_arg.data);\n            if (x)\n                cstr_reset(&s->linker_arg);\n            if (x < 0)\n                return -1;\n            break;\n        case TCC_OPTION_Wp:\n            r = optarg;\n            goto reparse;\n        case TCC_OPTION_E:\n            x = TCC_OUTPUT_PREPROCESS;\n            goto set_output_type;\n        case TCC_OPTION_P:\n            s->Pflag = atoi(optarg) + 1;\n            break;\n        case TCC_OPTION_M:\n            s->include_sys_deps = 1;\n            // fall through\n        case TCC_OPTION_MM:\n            s->just_deps = 1;\n            if(!s->deps_outfile)\n                s->deps_outfile = tcc_strdup(\"-\");\n            // fall through\n        case TCC_OPTION_MMD:\n            s->gen_deps = 1;\n            break;\n        case TCC_OPTION_MD:\n            s->gen_deps = 1;\n            s->include_sys_deps = 1;\n            break;\n        case TCC_OPTION_MF:\n            s->deps_outfile = tcc_strdup(optarg);\n            break;\n        case TCC_OPTION_MP:\n            s->gen_phony_deps = 1;\n            break;\n        case TCC_OPTION_dumpmachine:\n            printf(\"%s\\n\", dumpmachine_str);\n            exit(0);\n        case TCC_OPTION_dumpversion:\n            printf (\"%s\\n\", TCC_VERSION);\n            exit(0);\n        case TCC_OPTION_x:\n            x = 0;\n            if (*optarg == 'c')\n                x = AFF_TYPE_C;\n            else if (*optarg == 'a')\n                x = AFF_TYPE_ASMPP;\n            else if (*optarg == 'b')\n                x = AFF_TYPE_BIN;\n            else if (*optarg == 'n')\n                x = AFF_TYPE_NONE;\n            else\n                tcc_warning(\"unsupported language '%s'\", optarg);\n            s->filetype = x | (s->filetype & ~AFF_TYPE_MASK);\n            break;\n        case TCC_OPTION_O:\n            s->optimize = atoi(optarg);\n            break;\n        case TCC_OPTION_print_search_dirs:\n            x = OPT_PRINT_DIRS;\n            goto extra_action;\n        case TCC_OPTION_impdef:\n            x = OPT_IMPDEF;\n            goto extra_action;\n#if defined TCC_TARGET_MACHO\n        case TCC_OPTION_dynamiclib:\n            x = TCC_OUTPUT_DLL;\n            goto set_output_type;\n        case TCC_OPTION_flat_namespace:\n\t     break;\n        case TCC_OPTION_two_levelnamespace:\n\t     break;\n        case TCC_OPTION_undefined:\n\t     break;\n        case TCC_OPTION_install_name:\n\t    s->install_name = tcc_strdup(optarg);\n            break;\n        case TCC_OPTION_compatibility_version:\n\t    s->compatibility_version = parse_version(s, optarg);\n            break;\n        case TCC_OPTION_current_version:\n\t    s->current_version = parse_version(s, optarg);;\n            break;\n#endif\n        case TCC_OPTION_ar:\n            x = OPT_AR;\n        extra_action:\n            arg_start = optind - 1;\n            if (arg_start != noaction)\n                return tcc_error_noabort(\"cannot parse %s here\", r);\n            tool = x;\n            break;\n        default:\nunsupported_option:\n            tcc_warning_c(warn_unsupported)(\"unsupported option '%s'\", r);\n            break;\n        }\n    }\n    if (s->linker_arg.size) {\n        r = s->linker_arg.data;\n        goto arg_err;\n    }\n    *pargc = argc - arg_start;\n    *pargv = argv + arg_start;\n    if (tool)\n        return tool;\n    if (optind != noaction)\n        return 0;\n    if (s->verbose == 2)\n        return OPT_PRINT_DIRS;\n    if (s->verbose)\n        return OPT_V;\n    return OPT_HELP;\n}\n\nLIBTCCAPI int tcc_set_options(TCCState *s, const char *r)\n{\n    char **argv = NULL;\n    int argc = 0, ret;\n    args_parser_make_argv(r, &argc, &argv);\n    ret = tcc_parse_args(s, &argc, &argv, 0);\n    dynarray_reset(&argv, &argc);\n    return ret < 0 ? ret : 0;\n}\n\nPUB_FUNC void tcc_print_stats(TCCState *s1, unsigned total_time)\n{\n    if (!total_time)\n        total_time = 1;\n    fprintf(stderr, \"# %d idents, %d lines, %u bytes\\n\"\n                    \"# %0.3f s, %u lines/s, %0.1f MB/s\\n\",\n           total_idents, total_lines, total_bytes,\n           (double)total_time/1000,\n           (unsigned)total_lines*1000/total_time,\n           (double)total_bytes/1000/total_time);\n    fprintf(stderr, \"# text %u, data.rw %u, data.ro %u, bss %u bytes\\n\",\n           s1->total_output[0],\n           s1->total_output[1],\n           s1->total_output[2],\n           s1->total_output[3]\n           );\n#ifdef MEM_DEBUG\n    fprintf(stderr, \"# memory usage\");\n#ifdef TCC_IS_NATIVE\n    if (s1->run_size) {\n        Section *s = s1->symtab;\n        unsigned ms = s->data_offset + s->link->data_offset + s->hash->data_offset;\n        unsigned rs = s1->run_size;\n        fprintf(stderr, \": %d to run, %d symbols, %d other,\",\n            rs, ms, mem_cur_size - rs - ms);\n    }\n#endif\n    fprintf(stderr, \" %d max (bytes)\\n\", mem_max_size);\n#endif\n}\n\n#if ONE_SOURCE\n# undef malloc\n# undef realloc\n# undef free\n#endif\n"
        },
        {
          "name": "libtcc.h",
          "type": "blob",
          "size": 4.111328125,
          "content": "#ifndef LIBTCC_H\n#define LIBTCC_H\n\n#ifndef LIBTCCAPI\n# define LIBTCCAPI\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*****************************/\n/* set custom allocator for all allocations (optional), NULL for default. */\ntypedef void *TCCReallocFunc(void *ptr, unsigned long size);\nLIBTCCAPI void tcc_set_realloc(TCCReallocFunc *my_realloc);\n\n/*****************************/\ntypedef struct TCCState TCCState;\n\n/* create a new TCC compilation context */\nLIBTCCAPI TCCState *tcc_new(void);\n\n/* free a TCC compilation context */\nLIBTCCAPI void tcc_delete(TCCState *s);\n\n/* set CONFIG_TCCDIR at runtime */\nLIBTCCAPI void tcc_set_lib_path(TCCState *s, const char *path);\n\n/* set error/warning callback (optional) */\ntypedef void TCCErrorFunc(void *opaque, const char *msg);\nLIBTCCAPI void tcc_set_error_func(TCCState *s, void *error_opaque, TCCErrorFunc *error_func);\n\n/* set options as from command line (multiple supported) */\nLIBTCCAPI int tcc_set_options(TCCState *s, const char *str);\n\n/*****************************/\n/* preprocessor */\n\n/* add include path */\nLIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname);\n\n/* add in system include path */\nLIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname);\n\n/* define preprocessor symbol 'sym'. value can be NULL, sym can be \"sym=val\" */\nLIBTCCAPI void tcc_define_symbol(TCCState *s, const char *sym, const char *value);\n\n/* undefine preprocess symbol 'sym' */\nLIBTCCAPI void tcc_undefine_symbol(TCCState *s, const char *sym);\n\n/*****************************/\n/* compiling */\n\n/* add a file (C file, dll, object, library, ld script). Return -1 if error. */\nLIBTCCAPI int tcc_add_file(TCCState *s, const char *filename);\n\n/* compile a string containing a C source. Return -1 if error. */\nLIBTCCAPI int tcc_compile_string(TCCState *s, const char *buf);\n\n/* Tip: to have more specific errors/warnings from tcc_compile_string(),\n   you can prefix the string with \"#line <num> \\\"<filename>\\\"\\n\" */\n\n/*****************************/\n/* linking commands */\n\n/* set output type. MUST BE CALLED before any compilation */\nLIBTCCAPI int tcc_set_output_type(TCCState *s, int output_type);\n#define TCC_OUTPUT_MEMORY   1 /* output will be run in memory */\n#define TCC_OUTPUT_EXE      2 /* executable file */\n#define TCC_OUTPUT_DLL      4 /* dynamic library */\n#define TCC_OUTPUT_OBJ      3 /* object file */\n#define TCC_OUTPUT_PREPROCESS 5 /* only preprocess */\n\n/* equivalent to -Lpath option */\nLIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname);\n\n/* the library name is the same as the argument of the '-l' option */\nLIBTCCAPI int tcc_add_library(TCCState *s, const char *libraryname);\n\n/* add a symbol to the compiled program */\nLIBTCCAPI int tcc_add_symbol(TCCState *s, const char *name, const void *val);\n\n/* output an executable, library or object file. DO NOT call\n   tcc_relocate() before. */\nLIBTCCAPI int tcc_output_file(TCCState *s, const char *filename);\n\n/* link and run main() function and return its value. DO NOT call\n   tcc_relocate() before. */\nLIBTCCAPI int tcc_run(TCCState *s, int argc, char **argv);\n\n/* do all relocations (needed before using tcc_get_symbol()) */\nLIBTCCAPI int tcc_relocate(TCCState *s1);\n\n/* return symbol value or NULL if not found */\nLIBTCCAPI void *tcc_get_symbol(TCCState *s, const char *name);\n\n/* list all (global) symbols and their values via 'symbol_cb()' */\nLIBTCCAPI void tcc_list_symbols(TCCState *s, void *ctx,\n    void (*symbol_cb)(void *ctx, const char *name, const void *val));\n\n/* experimental/advanced section (see libtcc_test_mt.c for an example) */\n\n/* catch runtime exceptions (optionally limit backtraces at top_func),\n   when using tcc_set_options(\"-bt\") and when not using tcc_run() */\nLIBTCCAPI void *_tcc_setjmp(TCCState *s1, void *jmp_buf, void *top_func, void *longjmp);\n#define tcc_setjmp(s1,jb,f) setjmp(_tcc_setjmp(s1, jb, f, longjmp))\n\n/* custom error printer for runtime exceptions. Returning 0 stops backtrace */\ntypedef int TCCBtFunc(void *udata, void *pc, const char *file, int line, const char* func, const char *msg);\nLIBTCCAPI void tcc_set_backtrace_func(TCCState *s1, void* userdata, TCCBtFunc*);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "riscv64-asm.c",
          "type": "blob",
          "size": 77.673828125,
          "content": "/*************************************************************/\n/*\n *  RISCV64 assembler for TCC\n *\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n#define CONFIG_TCC_ASM\n/* 32 general purpose + 32 floating point registers */\n#define NB_ASM_REGS 64\n\nST_FUNC void g(int c);\nST_FUNC void gen_le16(int c);\nST_FUNC void gen_le32(int c);\n\n/*************************************************************/\n#else\n/*************************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n\nenum {\n    OPT_REG,\n    OPT_IM12S,\n    OPT_IM32,\n};\n// Registers go from 0 to 31. We use next bit to choose general/float\n#define REG_FLOAT_MASK 0x20\n#define REG_IS_FLOAT(register_index) ((register_index) & REG_FLOAT_MASK)\n#define REG_VALUE(register_index)    ((register_index) & (REG_FLOAT_MASK-1))\n#define C_ENCODE_RS1(register_index) (REG_VALUE(register_index) << 7)\n#define C_ENCODE_RS2(register_index) (REG_VALUE(register_index) << 2)\n#define ENCODE_RD(register_index)  (REG_VALUE(register_index) << 7)\n#define ENCODE_RS1(register_index) (REG_VALUE(register_index) << 15)\n#define ENCODE_RS2(register_index) (REG_VALUE(register_index) << 20)\n#define NTH_BIT(b, n) ((b >> n) & 1)\n#define OP_IM12S (1 << OPT_IM12S)\n#define OP_IM32 (1 << OPT_IM32)\n#define OP_REG (1 << OPT_REG)\n\ntypedef struct Operand {\n    uint32_t type;\n    union {\n        uint8_t reg;\n        uint16_t regset;\n        ExprValue e;\n    };\n} Operand;\n\nstatic const Operand zero = { OP_REG, { 0 }};\nstatic const Operand ra = { OP_REG, { 1 }};\nstatic const Operand zimm = { OP_IM12S };\n\nstatic void asm_binary_opcode(TCCState* s1, int token);\nST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str);\nST_FUNC void asm_compute_constraints(ASMOperand *operands, int nb_operands, int nb_outputs, const uint8_t *clobber_regs, int *pout_reg);\nstatic void asm_emit_a(int token, uint32_t opcode, const Operand *rs1, const Operand *rs2, const Operand *rd1, int aq, int rl);\nstatic void asm_emit_b(int token, uint32_t opcode, const Operand *rs1, const Operand *rs2, const Operand *imm);\nstatic void asm_emit_i(int token, uint32_t opcode, const Operand *rd, const Operand *rs1, const Operand *rs2);\nstatic void asm_emit_j(int token, uint32_t opcode, const Operand *rd, const Operand *rs2);\nstatic void asm_emit_opcode(uint32_t opcode);\nstatic void asm_emit_r(int token, uint32_t opcode, const Operand *rd, const Operand *rs1, const Operand *rs2);\nstatic void asm_emit_s(int token, uint32_t opcode, const Operand *rs1, const Operand *rs2, const Operand *imm);\nstatic void asm_emit_u(int token, uint32_t opcode, const Operand *rd, const Operand *rs2);\nST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands, int nb_outputs, int is_output, uint8_t *clobber_regs, int out_reg);\nstatic void asm_nullary_opcode(TCCState *s1, int token);\nST_FUNC void asm_opcode(TCCState *s1, int token);\nstatic int asm_parse_csrvar(int t);\nST_FUNC int asm_parse_regvar(int t);\nstatic void asm_ternary_opcode(TCCState *s1, int token);\nstatic void asm_unary_opcode(TCCState *s1, int token);\nstatic void asm_branch_opcode(TCCState *s1, int token, int argc);\nST_FUNC void gen_expr32(ExprValue *pe);\nstatic void parse_operand(TCCState *s1, Operand *op);\nstatic void parse_branch_offset_operand(TCCState *s1, Operand *op);\nstatic void parse_operands(TCCState *s1, Operand *ops, int count);\nstatic void parse_mem_access_operands(TCCState *s1, Operand* ops);\nST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier);\n/* C extension */\nstatic void asm_emit_ca(int token, uint16_t opcode, const Operand *rd, const Operand *rs2);\nstatic void asm_emit_cb(int token, uint16_t opcode, const Operand *rs1, const Operand *imm);\nstatic void asm_emit_ci(int token, uint16_t opcode, const Operand *rd, const Operand *imm);\nstatic void asm_emit_ciw(int token, uint16_t opcode, const Operand *rd, const Operand *imm);\nstatic void asm_emit_cj(int token, uint16_t opcode, const Operand *imm);\nstatic void asm_emit_cl(int token, uint16_t opcode, const Operand *rd, const Operand *rs1, const Operand *imm);\nstatic void asm_emit_cr(int token, uint16_t opcode, const Operand *rd, const Operand *rs2);\nstatic void asm_emit_cs(int token, uint16_t opcode, const Operand *rs2, const Operand *rs1, const Operand *imm);\nstatic void asm_emit_css(int token, uint16_t opcode, const Operand *rs2, const Operand *imm);\n\n/* XXX: make it faster ? */\nST_FUNC void g(int c)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 1;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c;\n    ind = ind1;\n}\n\nST_FUNC void gen_le16 (int i)\n{\n    g(i);\n    g(i>>8);\n}\n\nST_FUNC void gen_le32 (int i)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 4;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind++] = i & 0xFF;\n    cur_text_section->data[ind++] = (i >> 8) & 0xFF;\n    cur_text_section->data[ind++] = (i >> 16) & 0xFF;\n    cur_text_section->data[ind++] = (i >> 24) & 0xFF;\n}\n\nST_FUNC void gen_expr32(ExprValue *pe)\n{\n    gen_le32(pe->v);\n}\n\nstatic void asm_emit_opcode(uint32_t opcode) {\n    gen_le32(opcode);\n}\n\nstatic void asm_nullary_opcode(TCCState *s1, int token)\n{\n    switch (token) {\n    // Sync instructions\n\n    case TOK_ASM_fence_i: // I\n        asm_emit_opcode((0x3 << 2) | 3| (1 << 12));\n        return;\n\n    // System calls\n\n    case TOK_ASM_ecall: // I (pseudo)\n        asm_emit_opcode((0x1C << 2) | 3 | (0 << 12));\n        return;\n    case TOK_ASM_ebreak: // I (pseudo)\n        asm_emit_opcode((0x1C << 2) | 3 | (0 << 12) | (1 << 20));\n        return;\n\n    // Other\n\n    case TOK_ASM_nop:\n        asm_emit_i(token, (4 << 2) | 3, &zero, &zero, &zimm);\n        return;\n\n    case TOK_ASM_wfi:\n        asm_emit_opcode((0x1C << 2) | 3 | (0x105 << 20));\n        return;\n\n    /* Pseudoinstructions */\n    case TOK_ASM_ret:\n        /* jalr zero, x1, 0 */\n        asm_emit_opcode( 0x67 | (0 << 12) | ENCODE_RS1(1) );\n        return;\n\n    /* C extension */\n    case TOK_ASM_c_ebreak:\n        asm_emit_cr(token, 2 | (9 << 12), &zero, &zero);\n        return;\n    case TOK_ASM_c_nop:\n        asm_emit_ci(token, 1, &zero, &zimm);\n        return;\n\n    default:\n        expect(\"nullary instruction\");\n    }\n}\n\n/* Parse a text containing operand and store the result in OP */\nstatic void parse_operand(TCCState *s1, Operand *op)\n{\n    ExprValue e = {0};\n    Sym label = {0};\n    int8_t reg;\n\n    op->type = 0;\n\n    if ((reg = asm_parse_regvar(tok)) != -1) {\n        next(); // skip register name\n        op->type = OP_REG;\n        op->reg = (uint8_t) reg;\n        return;\n    } else if (tok == '$') {\n        /* constant value */\n        next(); // skip '#' or '$'\n    } else if ((e.v = asm_parse_csrvar(tok)) != -1) {\n        next();\n    } else {\n        asm_expr(s1, &e);\n    }\n    op->type = OP_IM32;\n    op->e = e;\n    /* compare against unsigned 12-bit maximum */\n    if (!op->e.sym) {\n        if ((int) op->e.v >= -0x1000 && (int) op->e.v < 0x1000)\n            op->type = OP_IM12S;\n    } else if (op->e.sym->type.t & (VT_EXTERN | VT_STATIC)) {\n        label.type.t = VT_VOID | VT_STATIC;\n\n        /* use the medium PIC model: GOT, auipc, lw */\n        if (op->e.sym->type.t & VT_STATIC)\n            greloca(cur_text_section, op->e.sym, ind, R_RISCV_PCREL_HI20, 0);\n        else\n            greloca(cur_text_section, op->e.sym, ind, R_RISCV_GOT_HI20, 0);\n        put_extern_sym(&label, cur_text_section, ind, 0);\n        greloca(cur_text_section, &label, ind+4, R_RISCV_PCREL_LO12_I, 0);\n\n        op->type = OP_IM12S;\n        op->e.v = 0;\n    } else {\n        expect(\"operand\");\n    }\n}\n\nstatic void parse_branch_offset_operand(TCCState *s1, Operand *op){\n    ExprValue e = {0};\n\n    asm_expr(s1, &e);\n    op->type = OP_IM32;\n    op->e = e;\n    /* compare against unsigned 12-bit maximum */\n    if (!op->e.sym) {\n        if ((int) op->e.v >= -0x1000 && (int) op->e.v < 0x1000)\n            op->type = OP_IM12S;\n    } else if (op->e.sym->type.t & (VT_EXTERN | VT_STATIC)) {\n        greloca(cur_text_section, op->e.sym, ind, R_RISCV_BRANCH, 0);\n\n        /* XXX: Implement far branches */\n\n        op->type = OP_IM12S;\n        op->e.v = 0;\n    } else {\n        expect(\"operand\");\n    }\n}\n\nstatic void parse_jump_offset_operand(TCCState *s1, Operand *op){\n    ExprValue e = {0};\n\n    asm_expr(s1, &e);\n    op->type = OP_IM32;\n    op->e = e;\n    /* compare against unsigned 12-bit maximum */\n    if (!op->e.sym) {\n        if ((int) op->e.v >= -0x1000 && (int) op->e.v < 0x1000)\n            op->type = OP_IM12S;\n    } else if (op->e.sym->type.t & (VT_EXTERN | VT_STATIC)) {\n        greloca(cur_text_section, op->e.sym, ind, R_RISCV_JAL, 0);\n        op->type = OP_IM12S;\n        op->e.v = 0;\n    } else {\n        expect(\"operand\");\n    }\n}\n\nstatic void parse_operands(TCCState *s1, Operand* ops, int count){\n    int i;\n    for (i = 0; i < count; i++) {\n        if ( i != 0 )\n            skip(',');\n        parse_operand(s1, &ops[i]);\n    }\n}\n\n/* parse `X, imm(Y)` to {X, Y, imm} operands */\nstatic void parse_mem_access_operands(TCCState *s1, Operand* ops){\n\n    Operand op;\n\n    parse_operand(s1, &ops[0]);\n    skip(',');\n    if ( tok == '(') {\n        /* `X, (Y)` case*/\n        next();\n        parse_operand(s1, &ops[1]);\n        skip(')');\n        ops[2] = zimm;\n    } else {\n        parse_operand(s1, &ops[2]);\n        if ( tok == '('){\n            /* `X, imm(Y)` case*/\n            next();\n            parse_operand(s1, &ops[1]);\n            skip(')');\n        } else {\n            /* `X, Y` case*/\n            /* we parsed Y thinking it was imm, swap and default imm to zero */\n            op = ops[2];\n            ops[1] = ops[2];\n            ops[2] = op;\n            ops[2] = zimm;\n        }\n    }\n}\n\n/* This is special: First operand is optional */\nstatic void asm_jal_opcode(TCCState *s1, int token){\n    Operand ops[2];\n\n    if (token == TOK_ASM_j ){\n        ops[0] = zero; // j offset\n    } else if (asm_parse_regvar(tok) == -1) {\n        ops[0] = ra;   // jal offset\n    } else {\n        // jal reg, offset\n        parse_operand(s1, &ops[0]);\n        if ( tok == ',') next(); else expect(\"','\");\n    }\n    parse_jump_offset_operand(s1, &ops[1]);\n    asm_emit_j(token, 0x6f, &ops[0], &ops[1]);\n}\n\n/* This is special: It can be a pseudointruction or a instruction */\nstatic void asm_jalr_opcode(TCCState *s1, int token){\n    Operand ops[3];\n    Operand op;\n\n    parse_operand(s1, &ops[0]);\n    if ( tok == ',')\n        next();\n    else {\n        /* no more operands, it's the pseudoinstruction:\n         *  jalr rs\n         * Expand to:\n         *  jalr ra, 0(rs)\n         */\n        asm_emit_i(token, 0x67 | (0 << 12), &ra, &ops[0], &zimm);\n        return;\n    }\n\n    if ( tok == '(') {\n        /* `X, (Y)` case*/\n        next();\n        parse_operand(s1, &ops[1]);\n        skip(')');\n        ops[2] = zimm;\n    } else {\n        parse_operand(s1, &ops[2]);\n        if ( tok == '('){\n            /* `X, imm(Y)` case*/\n            next();\n            parse_operand(s1, &ops[1]);\n            skip(')');\n        } else {\n            /* `X, Y` case*/\n            /* we parsed Y thinking it was imm, swap and default imm to zero */\n            op = ops[2];\n            ops[1] = ops[2];\n            ops[2] = op;\n            ops[2] = zimm;\n        }\n    }\n    /* jalr(RD, RS1, IMM); I-format */\n    asm_emit_i(token, 0x67 | (0 << 12), &ops[0], &ops[1], &ops[2]);\n}\n\n\nstatic void asm_unary_opcode(TCCState *s1, int token)\n{\n    uint32_t opcode = (0x1C << 2) | 3 | (2 << 12);\n    Operand op;\n\n    parse_operands(s1, &op, 1);\n    /* Note: Those all map to CSR--so they are pseudo-instructions. */\n    opcode |= ENCODE_RD(op.reg);\n\n    switch (token) {\n    /* pseudoinstructions */\n    case TOK_ASM_rdcycle:\n        asm_emit_opcode(opcode | (0xC00 << 20));\n        return;\n    case TOK_ASM_rdcycleh:\n        asm_emit_opcode(opcode | (0xC80 << 20));\n        return;\n    case TOK_ASM_rdtime:\n        asm_emit_opcode(opcode | (0xC01 << 20) | ENCODE_RD(op.reg));\n        return;\n    case TOK_ASM_rdtimeh:\n        asm_emit_opcode(opcode | (0xC81 << 20) | ENCODE_RD(op.reg));\n        return;\n    case TOK_ASM_rdinstret:\n        asm_emit_opcode(opcode | (0xC02 << 20) | ENCODE_RD(op.reg));\n        return;\n    case TOK_ASM_rdinstreth:\n        asm_emit_opcode(opcode | (0xC82 << 20) | ENCODE_RD(op.reg));\n        return;\n\n    case TOK_ASM_jr:\n        /* jalr zero, 0(rs)*/\n        asm_emit_i(token, 0x67 | (0 << 12), &zero, &op, &zimm);\n        return;\n    case TOK_ASM_call:\n        /* auipc ra, 0 */\n        greloca(cur_text_section, op.e.sym, ind, R_RISCV_CALL, 0);\n        asm_emit_opcode(3 | (5 << 2) | ENCODE_RD(1));\n        /* jalr zero, 0(ra) */\n        asm_emit_opcode(0x67 | (0 << 12) | ENCODE_RS1(1));\n        return;\n    case TOK_ASM_tail:\n        /* auipc x6, 0 */\n        greloca(cur_text_section, op.e.sym, ind, R_RISCV_CALL, 0);\n        asm_emit_opcode(3 | (5 << 2) | ENCODE_RD(6));\n        /* jalr zero, 0(x6) */\n        asm_emit_opcode(0x67 | (0 << 12) | ENCODE_RS1(6));\n        return;\n\n    /* C extension */\n    case TOK_ASM_c_j:\n        asm_emit_cj(token, 1 | (5 << 13), &op);\n        return;\n    case TOK_ASM_c_jal: /* RV32C-only */\n        asm_emit_cj(token, 1 | (1 << 13), &op);\n        return;\n    case TOK_ASM_c_jalr:\n        asm_emit_cr(token, 2 | (9 << 12), &op, &zero);\n        return;\n    case TOK_ASM_c_jr:\n        asm_emit_cr(token, 2 | (8 << 12), &op, &zero);\n        return;\n    default:\n        expect(\"unary instruction\");\n    }\n}\n\nstatic void asm_emit_u(int token, uint32_t opcode, const Operand* rd, const Operand* rs2)\n{\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs2->type != OP_IM12S && rs2->type != OP_IM32) {\n        tcc_error(\"'%s': Expected second source operand that is an immediate value\", get_tok_str(token, NULL));\n    } else if (rs2->e.v >= 0x100000) {\n        tcc_error(\"'%s': Expected second source operand that is an immediate value between 0 and 0xfffff\", get_tok_str(token, NULL));\n    }\n    /* U-type instruction:\n\t      31...12 imm[31:12]\n\t      11...7 rd\n\t      6...0 opcode */\n    gen_le32(opcode | ENCODE_RD(rd->reg) | (rs2->e.v << 12));\n}\n\nstatic int parse_fence_operand(){\n    int t = tok;\n    if ( tok == TOK_ASM_or ){\n        // we are in a fence instruction, parse as output read\n        t = TOK_ASM_or_fence;\n    }\n    next();\n    return t - (TOK_ASM_w_fence - 1);\n}\n\nstatic void asm_fence_opcode(TCCState *s1, int token){\n    // `fence` is both an instruction and a pseudoinstruction:\n    // `fence` expands to `fence iorw, iorw`\n    int succ = 0xF, pred = 0xF;\n    if (tok != TOK_LINEFEED && tok != ';' && tok != CH_EOF){\n        pred = parse_fence_operand();\n        if ( pred > 0xF || pred < 0) {\n            tcc_error(\"'%s': Expected first operand that is a valid predecessor operand\", get_tok_str(token, NULL));\n        }\n        skip(',');\n        succ = parse_fence_operand();\n        if ( succ > 0xF || succ < 0) {\n            tcc_error(\"'%s': Expected second operand that is a valid successor operand\", get_tok_str(token, NULL));\n        }\n    }\n    asm_emit_opcode((0x3 << 2) | 3 | (0 << 12) | succ<<20 | pred<<24);\n}\n\nstatic void asm_binary_opcode(TCCState* s1, int token)\n{\n    Operand imm = { OP_IM12S };\n    Operand ops[2];\n    int32_t lo;\n    uint32_t hi;\n\n    parse_operands(s1, &ops[0], 2);\n    switch (token) {\n    case TOK_ASM_lui:\n        asm_emit_u(token, (0xD << 2) | 3, &ops[0], &ops[1]);\n        return;\n    case TOK_ASM_auipc:\n        asm_emit_u(token, (0x05 << 2) | 3, &ops[0], &ops[1]);\n        return;\n\n    /* C extension */\n    case TOK_ASM_c_add:\n        asm_emit_cr(token, 2 | (9 << 12), ops, ops + 1);\n        return;\n    case TOK_ASM_c_mv:\n        asm_emit_cr(token, 2 | (8 << 12), ops, ops + 1);\n        return;\n\n    case TOK_ASM_c_addi16sp:\n        asm_emit_ci(token, 1 | (3 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_addi:\n        asm_emit_ci(token, 1, ops, ops + 1);\n        return;\n    case TOK_ASM_c_addiw:\n        asm_emit_ci(token, 1 | (1 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_fldsp:\n        asm_emit_ci(token, 2 | (1 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_flwsp: /* RV32FC-only */\n        asm_emit_ci(token, 2 | (3 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_ldsp:\n        asm_emit_ci(token, 2 | (3 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_li:\n        asm_emit_ci(token, 1 | (2 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_lui:\n        asm_emit_ci(token, 1 | (3 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_lwsp:\n        asm_emit_ci(token, 2 | (2 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_slli:\n        asm_emit_ci(token, 2, ops, ops + 1);\n        return;\n\n    case TOK_ASM_c_addi4spn:\n        asm_emit_ciw(token, 0, ops, ops + 1);\n        return;\n\n#define CA (1 | (3 << 10) | (4 << 13))\n    case TOK_ASM_c_addw:\n        asm_emit_ca(token, CA | (1 << 5) | (1 << 12), ops, ops + 1);\n        return;\n    case TOK_ASM_c_and:\n        asm_emit_ca(token, CA | (3 << 5), ops, ops + 1);\n        return;\n    case TOK_ASM_c_or:\n        asm_emit_ca(token, CA | (2 << 5), ops, ops + 1);\n        return;\n    case TOK_ASM_c_sub:\n        asm_emit_ca(token, CA, ops, ops + 1);\n        return;\n    case TOK_ASM_c_subw:\n        asm_emit_ca(token, CA | (1 << 12), ops, ops + 1);\n        return;\n    case TOK_ASM_c_xor:\n        asm_emit_ca(token, CA | (1 << 5), ops, ops + 1);\n        return;\n#undef CA\n\n    case TOK_ASM_c_andi:\n        asm_emit_cb(token, 1 | (2 << 10) | (4 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_beqz:\n        asm_emit_cb(token, 1 | (6 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_bnez:\n        asm_emit_cb(token, 1 | (7 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_srai:\n        asm_emit_cb(token, 1 | (1 << 10) | (4 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_srli:\n        asm_emit_cb(token, 1 | (4 << 13), ops, ops + 1);\n        return;\n\n    case TOK_ASM_c_sdsp:\n        asm_emit_css(token, 2 | (7 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_swsp:\n        asm_emit_css(token, 2 | (6 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_fswsp: /* RV32FC-only */\n        asm_emit_css(token, 2 | (7 << 13), ops, ops + 1);\n        return;\n    case TOK_ASM_c_fsdsp:\n        asm_emit_css(token, 2 | (5 << 13), ops, ops + 1);\n        return;\n\n    /* pseudoinstructions */\n    /* rd, sym */\n    case TOK_ASM_la:\n        /* auipc rd, 0 */\n        asm_emit_u(token, 3 | (5 << 2), ops, ops + 1);\n        /* lw rd, rd, 0 */\n        asm_emit_i(token, 3 | (2 << 12), ops, ops, ops + 1);\n        return;\n    case TOK_ASM_lla:\n        /* auipc rd, 0 */\n        asm_emit_u(token, 3 | (5 << 2), ops, ops + 1);\n        /* addi rd, rd, 0 */\n        asm_emit_i(token, 3 | (4 << 2), ops, ops, ops + 1);\n        return;\n    case TOK_ASM_li:\n        if(ops[1].type != OP_IM32 && ops[1].type != OP_IM12S){\n            tcc_error(\"'%s': Expected first source operand that is an immediate value between 0 and 0xFFFFFFFFFFFFFFFF\", get_tok_str(token, NULL));\n        }\n        lo = ops[1].e.v;\n        hi = (int64_t)ops[1].e.v >> 32;\n        if(lo < 0){\n            hi += 1;\n        }\n        imm.e.v = ((hi + 0x800) & 0xfffff000) >> 12;\n        /* lui rd, HI_20(HI_32(imm)) */\n        asm_emit_u(token, (0xD << 2) | 3, &ops[0], &imm);\n        /* addi rd, rd, LO_12(HI_32(imm)) */\n        imm.e.v = (int32_t)hi<<20>>20;\n        asm_emit_i(token, 3 | (4 << 2), &ops[0], &ops[0], &imm);\n        /* slli rd, rd, 12 */\n        imm.e.v = 12;\n        asm_emit_i(token, (4 << 2) | 3 | (1 << 12), &ops[0], &ops[0], &imm);\n        /* addi rd, rd, HI_12(LO_32(imm)) */\n        imm.e.v = (lo + (1<<19)) >> 20;\n        asm_emit_i(token, 3 | (4 << 2), &ops[0], &ops[0], &imm);\n        /* slli rd, rd, 12 */\n        imm.e.v = 12;\n        asm_emit_i(token, (4 << 2) | 3 | (1 << 12), &ops[0], &ops[0], &imm);\n        /* addi rd, rd, HI_12(LO_20(LO_32imm)) */\n        lo = lo << 12 >> 12;\n        imm.e.v = lo >> 8;\n        asm_emit_i(token, 3 | (4 << 2), &ops[0], &ops[0], &imm);\n        /* slli rd, rd,  8 */\n        imm.e.v = 8;\n        asm_emit_i(token, (4 << 2) | 3 | (1 << 12), &ops[0], &ops[0], &imm);\n        /* addi rd, rd, LO_8(LO_20(LO_32imm)) */\n        lo &= 0xff;\n        imm.e.v = lo << 20 >> 20;\n        asm_emit_i(token, 3 | (4 << 2), &ops[0], &ops[0], &imm);\n        return;\n    case TOK_ASM_mv:\n        /* addi rd, rs, 0 */\n        asm_emit_i(token, 3 | (4 << 2), &ops[0], &ops[1], &imm);\n        return;\n    case TOK_ASM_not:\n        /* xori rd, rs, -1 */\n        imm.e.v = -1;\n        asm_emit_i(token, (0x4 << 2) | 3 | (4 << 12), &ops[0], &ops[1], &imm);\n        return;\n    case TOK_ASM_neg:\n        /* sub rd, x0, rs */\n        imm.e.v = 1;\n        asm_emit_i(token, (0x4 << 2) | 3 | (4 << 12), &ops[0], &zero, &imm);\n        return;\n    case TOK_ASM_negw:\n        /* sub rd, x0, rs */\n        imm.e.v = 1;\n        asm_emit_i(token, (0x4 << 2) | 3 | (4 << 12), &ops[0], &zero, &imm);\n        return;\n    case TOK_ASM_jump:\n        /* auipc x5, 0 */\n        asm_emit_opcode(3 | (5 << 2) | ENCODE_RD(5));\n        greloca(cur_text_section, ops->e.sym, ind, R_RISCV_CALL, 0);\n        /* jalr zero, 0(x5) */\n        asm_emit_opcode(0x67 | (0 << 12) | ENCODE_RS1(5));\n        return;\n    case TOK_ASM_seqz:\n        /* sltiu rd, rs, 1 */\n        imm.e.v = 1;\n        asm_emit_i(token, (0x4 << 2) | 3 | (3 << 12), &ops[0], &ops[1], &imm);\n        return;\n    case TOK_ASM_snez:\n        /* sltu rd, zero, rs */\n        imm.e.v = 1;\n        asm_emit_r(token, (0xC << 2) | 3 | (3 << 12), &ops[0], &zero, &ops[1]);\n        return;\n    case TOK_ASM_sltz:\n        /* slt rd, rs, zero */\n        asm_emit_r(token, (0xC << 2) | 3 | (2 << 12), &ops[0], &ops[1], &zero);\n        return;\n    case TOK_ASM_sgtz:\n        /* slt rd, zero, rs */\n        asm_emit_r(token, (0xC << 2) | 3 | (2 << 12), &ops[0], &zero, &ops[1]);\n        return;\n\n    default:\n        expect(\"binary instruction\");\n    }\n}\n\n/* caller: Add funct3, funct7 into opcode */\nstatic void asm_emit_r(int token, uint32_t opcode, const Operand* rd, const Operand* rs1, const Operand* rs2)\n{\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected first source operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected second source operand that is a register or immediate\", get_tok_str(token, NULL));\n    }\n    /* R-type instruction:\n\t     31...25 funct7\n\t     24...20 rs2\n\t     19...15 rs1\n\t     14...12 funct3\n\t     11...7 rd\n\t     6...0 opcode */\n    gen_le32(opcode | ENCODE_RD(rd->reg) | ENCODE_RS1(rs1->reg) | ENCODE_RS2(rs2->reg));\n}\n\n/* caller: Add funct3 into opcode */\nstatic void asm_emit_i(int token, uint32_t opcode, const Operand* rd, const Operand* rs1, const Operand* rs2)\n{\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected first source operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs2->type != OP_IM12S) {\n        tcc_error(\"'%s': Expected second source operand that is an immediate value between 0 and 8191\", get_tok_str(token, NULL));\n    }\n    /* I-type instruction:\n\t     31...20 imm[11:0]\n\t     19...15 rs1\n\t     14...12 funct3\n\t     11...7 rd\n\t     6...0 opcode */\n\n    gen_le32(opcode | ENCODE_RD(rd->reg) | ENCODE_RS1(rs1->reg) | (rs2->e.v << 20));\n}\n\nstatic void asm_emit_j(int token, uint32_t opcode, const Operand* rd, const Operand* rs2)\n{\n    uint32_t imm;\n\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs2->type != OP_IM12S && rs2->type != OP_IM32) {\n        tcc_error(\"'%s': Expected second source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    imm = rs2->e.v;\n\n    /* even offsets in a +- 1 MiB range */\n    if ((int)imm > (1 << 20) -1 || (int)imm <= -1 * ((1 << 20) -1)) {\n        tcc_error(\"'%s': Expected second source operand that is an immediate value between 0 and 0x1fffff\", get_tok_str(token, NULL));\n    }\n\n    if (imm & 1) {\n        tcc_error(\"'%s': Expected second source operand that is an even immediate value\", get_tok_str(token, NULL));\n    }\n    /* J-type instruction:\n    31      imm[20]\n    30...21 imm[10:1]\n    20      imm[11]\n    19...12 imm[19:12]\n    11...7  rd\n    6...0   opcode */\n    gen_le32(opcode | ENCODE_RD(rd->reg) | (((imm >> 20) & 1) << 31) | (((imm >> 1) & 0x3ff) << 21) | (((imm >> 11) & 1) << 20) | (((imm >> 12) & 0xff) << 12));\n}\n\nstatic void asm_mem_access_opcode(TCCState *s1, int token)\n{\n\n    Operand ops[3];\n    parse_mem_access_operands(s1, &ops[0]);\n\n    /* Pseudoinstruction: inst reg, label\n     * expand to:\n     *   auipc reg, 0\n     *   inst reg, 0(reg)\n     * And with the proper relocation to label\n     */\n    if (ops[1].type == OP_IM32 && ops[1].e.sym && ops[1].e.sym->type.t & VT_STATIC){\n        ops[1] = ops[0];\n        /* set the offset to zero */\n        ops[2].type = OP_IM12S;\n        ops[2].e.v  = 0;\n        /* auipc reg, 0 */\n        asm_emit_u(token, (0x05 << 2) | 3, &ops[0], &ops[2]);\n    }\n\n    switch (token) {\n    // l{b|h|w|d}[u] rd, imm(rs1); I-format\n    case TOK_ASM_lb:\n         asm_emit_i(token, (0x0 << 2) | 3, &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_lh:\n         asm_emit_i(token, (0x0 << 2) | 3 | (1 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_lw:\n         asm_emit_i(token, (0x0 << 2) | 3 | (2 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_ld:\n         asm_emit_i(token, (0x0 << 2) | 3 | (3 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_lbu:\n         asm_emit_i(token, (0x0 << 2) | 3 | (4 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_lhu:\n         asm_emit_i(token, (0x0 << 2) | 3 | (5 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_lwu:\n         asm_emit_i(token, (0x0 << 2) | 3 | (6 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n\n    // s{b|h|w|d} rs2, imm(rs1); S-format (with rsX swapped)\n    case TOK_ASM_sb:\n         asm_emit_s(token, (0x8 << 2) | 3 | (0 << 12), &ops[1], &ops[0], &ops[2]);\n         return;\n    case TOK_ASM_sh:\n         asm_emit_s(token, (0x8 << 2) | 3 | (1 << 12), &ops[1], &ops[0], &ops[2]);\n         return;\n    case TOK_ASM_sw:\n         asm_emit_s(token, (0x8 << 2) | 3 | (2 << 12), &ops[1], &ops[0], &ops[2]);\n         return;\n    case TOK_ASM_sd:\n         asm_emit_s(token, (0x8 << 2) | 3 | (3 << 12), &ops[1], &ops[0], &ops[2]);\n         return;\n    }\n}\n\nstatic void asm_branch_opcode(TCCState *s1, int token, int argc)\n{\n    Operand ops[3];\n    parse_operands(s1, &ops[0], argc-1);\n    skip(',');\n    parse_branch_offset_operand(s1, &ops[argc-1]);\n\n    switch(token){\n    /* branch (RS1, RS2, IMM); B-format */\n    case TOK_ASM_beq:\n        asm_emit_b(token, 0x63 | (0 << 12), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_bne:\n        asm_emit_b(token, 0x63 | (1 << 12), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_blt:\n        asm_emit_b(token, 0x63 | (4 << 12), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_bge:\n        asm_emit_b(token, 0x63 | (5 << 12), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_bltu:\n        asm_emit_b(token, 0x63 | (6 << 12), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_bgeu:\n        asm_emit_b(token, 0x63 | (7 << 12), ops, ops + 1, ops + 2);\n        return;\n    /* related pseudoinstructions */\n    case TOK_ASM_bgt:\n        asm_emit_b(token, 0x63 | (4 << 12), ops + 1, ops, ops + 2);\n        return;\n    case TOK_ASM_ble:\n        asm_emit_b(token, 0x63 | (5 << 12), ops + 1, ops, ops + 2);\n        return;\n    case TOK_ASM_bgtu:\n        asm_emit_b(token, 0x63 | (6 << 12), ops + 1, ops, ops + 2);\n        return;\n    case TOK_ASM_bleu:\n        asm_emit_b(token, 0x63 | (7 << 12), ops + 1, ops, ops + 2);\n        return;\n    /* shorter pseudoinstructions */\n    case TOK_ASM_bnez:\n        /* bne rs, zero, offset */\n        asm_emit_b(token, 0x63 | (1 << 12), &ops[0], &zero, &ops[1]);\n        return;\n    case TOK_ASM_beqz:\n        /* bne rs, zero, offset */\n        asm_emit_b(token, 0x63 | (0 << 12), &ops[0], &zero, &ops[1]);\n        return;\n    case TOK_ASM_blez:\n        /* bge rs, zero, offset */\n        asm_emit_b(token, 0x63 | (5 << 12), &ops[0], &zero, &ops[1]);\n        return;\n    case TOK_ASM_bgez:\n        /* bge zero, rs, offset */\n        asm_emit_b(token, 0x63 | (5 << 12), &zero, &ops[0], &ops[1]);\n        return;\n    case TOK_ASM_bltz:\n        /* blt rs, zero, offset */\n        asm_emit_b(token, 0x63 | (4 << 12), &ops[0], &zero, &ops[1]);\n        return;\n    case TOK_ASM_bgtz:\n        /* blt zero, rs, offset */\n        asm_emit_b(token, 0x63 | (4 << 12), &zero, &ops[0], &ops[1]);\n        return;\n    }\n}\n\nstatic void asm_ternary_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n    parse_operands(s1, &ops[0], 3);\n\n    switch (token) {\n    case TOK_ASM_sll:\n        asm_emit_r(token, (0xC << 2) | 3 | (1 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_slli:\n        asm_emit_i(token, (4 << 2) | 3 | (1 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_srl:\n        asm_emit_r(token, (0xC << 2) | 3 | (4 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_srli:\n        asm_emit_i(token, (0x4 << 2) | 3 | (5 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_sra:\n        asm_emit_r(token, (0xC << 2) | 3 | (5 << 12) | (32 << 25), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_srai:\n        asm_emit_i(token, (0x4 << 2) | 3 | (5 << 12) | (16 << 26), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_sllw:\n        asm_emit_r(token, (0xE << 2) | 3 | (1 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_slliw:\n        asm_emit_i(token, (6 << 2) | 3 | (1 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_srlw:\n        asm_emit_r(token, (0xE << 2) | 3 | (5 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_srliw:\n        asm_emit_i(token, (0x6 << 2) | 3 | (5 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_sraw:\n        asm_emit_r(token, (0xE << 2) | 3 | (5 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n    case TOK_ASM_sraiw:\n        asm_emit_i(token, (0x6 << 2) | 3 | (5 << 12), &ops[0], &ops[1], &ops[2]);\n        return;\n\n    // Arithmetic (RD,RS1,(RS2|IMM)); R-format, I-format or U-format\n\n    case TOK_ASM_add:\n         asm_emit_r(token, (0xC << 2) | 3, &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_addi:\n         asm_emit_i(token, (4 << 2) | 3, &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_sub:\n         asm_emit_r(token, (0xC << 2) | 3 | (32 << 25), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_addw:\n         asm_emit_r(token, (0xE << 2) | 3 | (0 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_addiw: // 64 bit\n         asm_emit_i(token, (0x6 << 2) | 3 | (0 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_subw:\n         asm_emit_r(token, (0xE << 2) | 3 | (0 << 12) | (32 << 25), &ops[0], &ops[1], &ops[2]);\n         return;\n\n    // Logical (RD,RS1,(RS2|IMM)); R-format or I-format\n\n    case TOK_ASM_xor:\n         asm_emit_r(token, (0xC << 2) | 3 | (4 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_xori:\n         asm_emit_i(token, (0x4 << 2) | 3 | (4 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_or:\n         asm_emit_r(token, (0xC << 2) | 3 | (6 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_ori:\n         asm_emit_i(token, (0x4 << 2) | 3 | (6 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_and:\n         asm_emit_r(token, (0xC << 2) | 3 | (7 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_andi:\n         asm_emit_i(token, (0x4 << 2) | 3 | (7 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n\n    // Compare (RD,RS1,(RS2|IMM)); R-format or I-format\n\n    case TOK_ASM_slt:\n         asm_emit_r(token, (0xC << 2) | 3 | (2 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_slti:\n         asm_emit_i(token, (0x4 << 2) | 3 | (2 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_sltu:\n         asm_emit_r(token, (0xC << 2) | 3 | (3 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n    case TOK_ASM_sltiu:\n         asm_emit_i(token, (0x4 << 2) | 3 | (3 << 12), &ops[0], &ops[1], &ops[2]);\n         return;\n\n    /* M extension */\n    case TOK_ASM_div:\n        asm_emit_r(token, 0x33 | (4 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_divu:\n        asm_emit_r(token, 0x33 | (5 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_divuw:\n        asm_emit_r(token, 0x3b | (5 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_divw:\n        asm_emit_r(token, 0x3b | (4 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_mul:\n        asm_emit_r(token, 0x33 | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_mulh:\n        asm_emit_r(token, 0x33 | (1 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_mulhsu:\n        asm_emit_r(token, 0x33 | (2 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_mulhu:\n        asm_emit_r(token, 0x33 | (3 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_mulw:\n        asm_emit_r(token, 0x3b | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_rem:\n        asm_emit_r(token, 0x33 | (6 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_remu:\n        asm_emit_r(token, 0x33 | (7 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_remuw:\n        asm_emit_r(token, 0x3b | (7 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_remw:\n        asm_emit_r(token, 0x3b | (6 << 12) | (1 << 25), ops, ops + 1, ops + 2);\n        return;\n\n    /* Zicsr extension; (rd, csr, rs/uimm) */\n    case TOK_ASM_csrrc:\n        asm_emit_i(token, 0x73 | (3 << 12), ops, ops + 2, ops + 1);\n        return;\n    case TOK_ASM_csrrci:\n        /* using rs1 field for uimmm */\n        ops[2].type = OP_REG;\n        asm_emit_i(token, 0x73 | (7 << 12), ops, ops + 2, ops + 1);\n        return;\n    case TOK_ASM_csrrs:\n        asm_emit_i(token, 0x73 | (2 << 12), ops, ops + 2, ops + 1);\n        return;\n    case TOK_ASM_csrrsi:\n        ops[2].type = OP_REG;\n        asm_emit_i(token, 0x73 | (6 << 12), ops, ops + 2, ops + 1);\n        return;\n    case TOK_ASM_csrrw:\n        asm_emit_i(token, 0x73 | (1 << 12), ops, ops + 2, ops + 1);\n        return;\n    case TOK_ASM_csrrwi:\n        ops[2].type = OP_REG;\n        asm_emit_i(token, 0x73 | (5 << 12), ops, ops + 2, ops + 1);\n        return;\n\n    /* C extension */\n    /* register-based loads and stores (RD, RS1, IMM); CL-format */\n    case TOK_ASM_c_fld:\n        asm_emit_cl(token, 1 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_flw: /* RV32FC-only */\n        asm_emit_cl(token, 3 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_fsd:\n        asm_emit_cs(token, 5 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_fsw: /* RV32FC-only */\n        asm_emit_cs(token, 7 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_ld:\n        asm_emit_cl(token, 3 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_lw:\n        asm_emit_cl(token, 2 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_sd:\n        asm_emit_cs(token, 7 << 13, ops, ops + 1, ops + 2);\n        return;\n    case TOK_ASM_c_sw:\n        asm_emit_cs(token, 6 << 13, ops, ops + 1, ops + 2);\n        return;\n\n    default:\n        expect(\"ternary instruction\");\n    }\n}\n\nstatic void asm_atomic_opcode(TCCState *s1, int token)\n{\n    Operand ops[3];\n\n    parse_operand(s1, &ops[0]);\n    skip(',');\n\n    if ( token <= TOK_ASM_lr_d_aqrl && token >= TOK_ASM_lr_w ) {\n        ops[1] = zero;\n    } else {\n        parse_operand(s1, &ops[1]);\n        skip(',');\n    }\n\n    skip('(');\n    parse_operand(s1, &ops[2]);\n    skip(')');\n\n    switch(token){\n        case TOK_ASM_lr_w:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 0, 0);\n            break;\n        case TOK_ASM_lr_w_aq:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 1, 0);\n            break;\n        case TOK_ASM_lr_w_rl:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 0, 1);\n            break;\n        case TOK_ASM_lr_w_aqrl:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 1, 1);\n            break;\n\n        case TOK_ASM_lr_d:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 0, 0);\n            break;\n        case TOK_ASM_lr_d_aq:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 1, 0);\n            break;\n        case TOK_ASM_lr_d_rl:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 0, 1);\n            break;\n        case TOK_ASM_lr_d_aqrl:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x2<<27, &ops[0], &ops[1], &ops[2], 1, 1);\n            break;\n\n        case TOK_ASM_sc_w:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 0, 0);\n            break;\n        case TOK_ASM_sc_w_aq:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 1, 0);\n            break;\n        case TOK_ASM_sc_w_rl:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 0, 1);\n            break;\n        case TOK_ASM_sc_w_aqrl:\n            asm_emit_a(token, 0x2F | 0x2<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 1, 1);\n            break;\n\n        case TOK_ASM_sc_d:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 0, 0);\n            break;\n        case TOK_ASM_sc_d_aq:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 1, 0);\n            break;\n        case TOK_ASM_sc_d_rl:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 0, 1);\n            break;\n        case TOK_ASM_sc_d_aqrl:\n            asm_emit_a(token, 0x2F | 0x3<<12 | 0x3<<27, &ops[0], &ops[1], &ops[2], 1, 1);\n            break;\n    }\n}\n\n/* caller: Add funct3 and func5 to opcode */\nstatic void asm_emit_a(int token, uint32_t opcode, const Operand *rd1, const Operand *rs2, const Operand *rs1, int aq, int rl)\n{\n    if (rd1->type != OP_REG)\n        tcc_error(\"'%s': Expected first destination operand that is a register\", get_tok_str(token, NULL));\n    if (rs2->type != OP_REG)\n        tcc_error(\"'%s': Expected second source operand that is a register\", get_tok_str(token, NULL));\n    if (rs1->type != OP_REG)\n        tcc_error(\"'%s': Expected third source operand that is a register\", get_tok_str(token, NULL));\n        /* A-type instruction:\n\t        31...27 funct5\n\t        26      aq\n\t        25      rl\n\t        24...20 rs2\n\t        19...15 rs1\n\t        14...11 funct3\n\t        11...7  rd\n\t        6...0 opcode\n        opcode always fixed pos. */\n    gen_le32(opcode | ENCODE_RS1(rs1->reg) | ENCODE_RS2(rs2->reg) | ENCODE_RD(rd1->reg) | aq << 26 | rl << 25);\n}\n\n/* caller: Add funct3 to opcode */\nstatic void asm_emit_s(int token, uint32_t opcode, const Operand* rs1, const Operand* rs2, const Operand* imm)\n{\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected first source operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected second source operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (imm->type != OP_IM12S) {\n        tcc_error(\"'%s': Expected third operand that is an immediate value between 0 and 8191\", get_tok_str(token, NULL));\n    }\n    {\n        uint16_t v = imm->e.v;\n        /* S-type instruction:\n\t        31...25 imm[11:5]\n\t        24...20 rs2\n\t        19...15 rs1\n\t        14...12 funct3\n\t        11...7 imm[4:0]\n\t        6...0 opcode\n        opcode always fixed pos. */\n        gen_le32(opcode | ENCODE_RS1(rs1->reg) | ENCODE_RS2(rs2->reg) | ((v & 0x1F) << 7) | ((v >> 5) << 25));\n    }\n}\n\nstatic void asm_emit_b(int token, uint32_t opcode, const Operand *rs1, const Operand *rs2, const Operand *imm)\n{\n    uint32_t offset;\n\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected first source operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n    if (imm->type != OP_IM12S) {\n        tcc_error(\"'%s': Expected second source operand that is an immediate value between 0 and 8191\", get_tok_str(token, NULL));\n    }\n\n    offset = imm->e.v;\n\n    /* B-type instruction:\n    31      imm[12]\n    30...25 imm[10:5]\n    24...20 rs2\n    19...15 rs1\n    14...12 funct3\n    8...11  imm[4:1]\n    7       imm[11]\n    6...0   opcode */\n    asm_emit_opcode(opcode | ENCODE_RS1(rs1->reg) | ENCODE_RS2(rs2->reg) | (((offset >> 1) & 0xF) << 8) | (((offset >> 5) & 0x1f) << 25) | (((offset >> 11) & 1) << 7) | (((offset >> 12) & 1) << 31));\n}\n\nST_FUNC void asm_opcode(TCCState *s1, int token)\n{\n    switch (token) {\n    case TOK_ASM_ebreak:\n    case TOK_ASM_ecall:\n    case TOK_ASM_fence_i:\n    case TOK_ASM_hrts:\n    case TOK_ASM_mrth:\n    case TOK_ASM_mrts:\n    case TOK_ASM_wfi:\n        asm_nullary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_fence:\n        asm_fence_opcode(s1, token);\n        return;\n\n    case TOK_ASM_rdcycle:\n    case TOK_ASM_rdcycleh:\n    case TOK_ASM_rdtime:\n    case TOK_ASM_rdtimeh:\n    case TOK_ASM_rdinstret:\n    case TOK_ASM_rdinstreth:\n        asm_unary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_lui:\n    case TOK_ASM_auipc:\n        asm_binary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_lb:\n    case TOK_ASM_lh:\n    case TOK_ASM_lw:\n    case TOK_ASM_ld:\n    case TOK_ASM_lbu:\n    case TOK_ASM_lhu:\n    case TOK_ASM_lwu:\n    case TOK_ASM_sb:\n    case TOK_ASM_sh:\n    case TOK_ASM_sw:\n    case TOK_ASM_sd:\n        asm_mem_access_opcode(s1, token);\n        break;\n\n    case TOK_ASM_jalr:\n        asm_jalr_opcode(s1, token); /* it can be a pseudo instruction too*/\n        break;\n    case TOK_ASM_j:\n        asm_jal_opcode(s1, token); /* jal zero, offset*/\n        return;\n    case TOK_ASM_jal:\n        asm_jal_opcode(s1, token); /* it can be a pseudo instruction too*/\n        break;\n\n    case TOK_ASM_add:\n    case TOK_ASM_addi:\n    case TOK_ASM_addiw:\n    case TOK_ASM_addw:\n    case TOK_ASM_and:\n    case TOK_ASM_andi:\n    case TOK_ASM_or:\n    case TOK_ASM_ori:\n    case TOK_ASM_sll:\n    case TOK_ASM_slli:\n    case TOK_ASM_slliw:\n    case TOK_ASM_sllw:\n    case TOK_ASM_slt:\n    case TOK_ASM_slti:\n    case TOK_ASM_sltiu:\n    case TOK_ASM_sltu:\n    case TOK_ASM_sra:\n    case TOK_ASM_srai:\n    case TOK_ASM_sraiw:\n    case TOK_ASM_sraw:\n    case TOK_ASM_srl:\n    case TOK_ASM_srli:\n    case TOK_ASM_srliw:\n    case TOK_ASM_srlw:\n    case TOK_ASM_sub:\n    case TOK_ASM_subw:\n    case TOK_ASM_xor:\n    case TOK_ASM_xori:\n    /* M extension */\n    case TOK_ASM_div:\n    case TOK_ASM_divu:\n    case TOK_ASM_divuw:\n    case TOK_ASM_divw:\n    case TOK_ASM_mul:\n    case TOK_ASM_mulh:\n    case TOK_ASM_mulhsu:\n    case TOK_ASM_mulhu:\n    case TOK_ASM_mulw:\n    case TOK_ASM_rem:\n    case TOK_ASM_remu:\n    case TOK_ASM_remuw:\n    case TOK_ASM_remw:\n    /* Zicsr extension */\n    case TOK_ASM_csrrc:\n    case TOK_ASM_csrrci:\n    case TOK_ASM_csrrs:\n    case TOK_ASM_csrrsi:\n    case TOK_ASM_csrrw:\n    case TOK_ASM_csrrwi:\n        asm_ternary_opcode(s1, token);\n        return;\n\n    /* Branches */\n    case TOK_ASM_beq:\n    case TOK_ASM_bge:\n    case TOK_ASM_bgeu:\n    case TOK_ASM_blt:\n    case TOK_ASM_bltu:\n    case TOK_ASM_bne:\n        asm_branch_opcode(s1, token, 3);\n        break;\n\n    /* C extension */\n    case TOK_ASM_c_ebreak:\n    case TOK_ASM_c_nop:\n        asm_nullary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_c_j:\n    case TOK_ASM_c_jal:\n    case TOK_ASM_c_jalr:\n    case TOK_ASM_c_jr:\n        asm_unary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_c_add:\n    case TOK_ASM_c_addi16sp:\n    case TOK_ASM_c_addi4spn:\n    case TOK_ASM_c_addi:\n    case TOK_ASM_c_addiw:\n    case TOK_ASM_c_addw:\n    case TOK_ASM_c_and:\n    case TOK_ASM_c_andi:\n    case TOK_ASM_c_beqz:\n    case TOK_ASM_c_bnez:\n    case TOK_ASM_c_fldsp:\n    case TOK_ASM_c_flwsp:\n    case TOK_ASM_c_fsdsp:\n    case TOK_ASM_c_fswsp:\n    case TOK_ASM_c_ldsp:\n    case TOK_ASM_c_li:\n    case TOK_ASM_c_lui:\n    case TOK_ASM_c_lwsp:\n    case TOK_ASM_c_mv:\n    case TOK_ASM_c_or:\n    case TOK_ASM_c_sdsp:\n    case TOK_ASM_c_slli:\n    case TOK_ASM_c_srai:\n    case TOK_ASM_c_srli:\n    case TOK_ASM_c_sub:\n    case TOK_ASM_c_subw:\n    case TOK_ASM_c_swsp:\n    case TOK_ASM_c_xor:\n        asm_binary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_c_fld:\n    case TOK_ASM_c_flw:\n    case TOK_ASM_c_fsd:\n    case TOK_ASM_c_fsw:\n    case TOK_ASM_c_ld:\n    case TOK_ASM_c_lw:\n    case TOK_ASM_c_sd:\n    case TOK_ASM_c_sw:\n        asm_ternary_opcode(s1, token);\n        return;\n\n    /* pseudoinstructions */\n    case TOK_ASM_nop:\n    case TOK_ASM_ret:\n        asm_nullary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_jr:\n    case TOK_ASM_call:\n    case TOK_ASM_tail:\n        asm_unary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_la:\n    case TOK_ASM_lla:\n    case TOK_ASM_li:\n    case TOK_ASM_jump:\n    case TOK_ASM_seqz:\n    case TOK_ASM_snez:\n    case TOK_ASM_sltz:\n    case TOK_ASM_sgtz:\n    case TOK_ASM_mv:\n    case TOK_ASM_not:\n    case TOK_ASM_neg:\n    case TOK_ASM_negw:\n        asm_binary_opcode(s1, token);\n        return;\n\n    case TOK_ASM_bnez:\n    case TOK_ASM_beqz:\n    case TOK_ASM_blez:\n    case TOK_ASM_bgez:\n    case TOK_ASM_bltz:\n    case TOK_ASM_bgtz:\n        asm_branch_opcode(s1, token, 2);\n        return;\n\n    case TOK_ASM_bgt:\n    case TOK_ASM_bgtu:\n    case TOK_ASM_ble:\n    case TOK_ASM_bleu:\n        asm_branch_opcode(s1, token, 3);\n        return;\n\n    /* Atomic operations */\n    case TOK_ASM_lr_w:\n    case TOK_ASM_lr_w_aq:\n    case TOK_ASM_lr_w_rl:\n    case TOK_ASM_lr_w_aqrl:\n    case TOK_ASM_lr_d:\n    case TOK_ASM_lr_d_aq:\n    case TOK_ASM_lr_d_rl:\n    case TOK_ASM_lr_d_aqrl:\n    case TOK_ASM_sc_w:\n    case TOK_ASM_sc_w_aq:\n    case TOK_ASM_sc_w_rl:\n    case TOK_ASM_sc_w_aqrl:\n    case TOK_ASM_sc_d:\n    case TOK_ASM_sc_d_aq:\n    case TOK_ASM_sc_d_rl:\n    case TOK_ASM_sc_d_aqrl:\n        asm_atomic_opcode(s1, token);\n        break;\n\n    default:\n        expect(\"known instruction\");\n    }\n}\n\nstatic int asm_parse_csrvar(int t)\n{\n    switch (t) {\n    case TOK_ASM_cycle:\n        return 0xc00;\n    case TOK_ASM_fcsr:\n        return 3;\n    case TOK_ASM_fflags:\n        return 1;\n    case TOK_ASM_frm:\n        return 2;\n    case TOK_ASM_instret:\n        return 0xc02;\n    case TOK_ASM_time:\n        return 0xc01;\n    case TOK_ASM_cycleh:\n        return 0xc80;\n    case TOK_ASM_instreth:\n        return 0xc82;\n    case TOK_ASM_timeh:\n        return 0xc81;\n    default:\n        return -1;\n    }\n}\n\nST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier)\n{\n    int r, reg, val;\n\n    r = sv->r;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        if (!(r & VT_LVAL) && modifier != 'c' && modifier != 'n' &&\n            modifier != 'P') {\n            //cstr_ccat(add_str, '#');\n        }\n        if (r & VT_SYM) {\n            const char *name = get_tok_str(sv->sym->v, NULL);\n            if (sv->sym->v >= SYM_FIRST_ANOM) {\n                /* In case of anonymous symbols (\"L.42\", used\n                   for static data labels) we can't find them\n                   in the C symbol table when later looking up\n                   this name.  So enter them now into the asm label\n                   list when we still know the symbol.  */\n                get_asm_sym(tok_alloc(name, strlen(name))->tok, sv->sym);\n            }\n            if (tcc_state->leading_underscore)\n                cstr_ccat(add_str, '_');\n            cstr_cat(add_str, name, -1);\n            if ((uint32_t) sv->c.i == 0)\n                goto no_offset;\n            cstr_ccat(add_str, '+');\n        }\n        val = sv->c.i;\n        if (modifier == 'n')\n            val = -val;\n        if (modifier == 'z' && sv->c.i == 0) {\n            cstr_cat(add_str, \"zero\", -1);\n        } else {\n            cstr_printf(add_str, \"%d\", (int) sv->c.i);\n        }\n      no_offset:;\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        cstr_printf(add_str, \"%d\", (int) sv->c.i);\n    } else if (r & VT_LVAL) {\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            tcc_internal_error(\"\");\n        if ((sv->type.t & VT_BTYPE) == VT_FLOAT ||\n            (sv->type.t & VT_BTYPE) == VT_DOUBLE) {\n            /* floating point register */\n            reg = TOK_ASM_f0 + reg;\n        } else {\n            /* general purpose register */\n            reg = TOK_ASM_x0 + reg;\n        }\n        cstr_cat(add_str, get_tok_str(reg, NULL), -1);\n    } else {\n        /* register case */\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            tcc_internal_error(\"\");\n        if ((sv->type.t & VT_BTYPE) == VT_FLOAT ||\n            (sv->type.t & VT_BTYPE) == VT_DOUBLE) {\n            /* floating point register */\n            reg = TOK_ASM_f0 + reg;\n        } else {\n            /* general purpose register */\n            reg = TOK_ASM_x0 + reg;\n        }\n        cstr_cat(add_str, get_tok_str(reg, NULL), -1);\n    }\n}\n\n/* TCC does not use RISC-V register numbers internally, it uses 0-8 for\n * integers and 8-16 for floats instead */\nstatic int tcc_ireg(int r){\n    return REG_VALUE(r) - 10;\n}\nstatic int tcc_freg(int r){\n    return REG_VALUE(r) - 10 + 8;\n}\n\n/* generate prolog and epilog code for asm statement */\nST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands,\n                         int nb_outputs, int is_output,\n                         uint8_t *clobber_regs,\n                         int out_reg)\n{\n    uint8_t regs_allocated[NB_ASM_REGS];\n    ASMOperand *op;\n    int i, reg;\n\n    static const uint8_t reg_saved[] = {\n        // General purpose regs\n        8, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\n        // Float regs\n        40, 41, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59\n    };\n\n    /* mark all used registers */\n    memcpy(regs_allocated, clobber_regs, sizeof(regs_allocated));\n    for(i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        if (op->reg >= 0) {\n            regs_allocated[op->reg] = 1;\n        }\n    }\n\n    if(!is_output) {\n        /* generate reg save code */\n        for(i = 0; i < sizeof(reg_saved)/sizeof(reg_saved[0]); i++) {\n            reg = reg_saved[i];\n            if (regs_allocated[reg]) {\n                /* push */\n                /* addi sp, sp, -offset */\n                gen_le32((4 << 2) | 3 |\n                        ENCODE_RD(2) | ENCODE_RS1(2) | (unsigned)-8 << 20);\n                if (REG_IS_FLOAT(reg)){\n                    /* fsd reg, offset(sp) */\n                    gen_le32( 0x27 | (3 << 12) |\n                            ENCODE_RS2(reg) | ENCODE_RS1(2) );\n                } else {\n                    /* sd reg, offset(sp) */\n                    gen_le32((0x8 << 2) | 3 | (3 << 12) |\n                            ENCODE_RS2(reg) | ENCODE_RS1(2) );\n                }\n            }\n        }\n\n        /* generate load code */\n        for(i = 0; i < nb_operands; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL &&\n                    op->is_memory) {\n                    /* memory reference case (for both input and\n                       output cases) */\n                    SValue sv;\n                    sv = *op->vt;\n                    sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL | VT_LVAL;\n                    sv.type.t = VT_PTR;\n                    load(tcc_ireg(op->reg), &sv);\n                } else if (i >= nb_outputs || op->is_rw) {\n                    /* load value in register */\n                    if ((op->vt->type.t & VT_BTYPE) == VT_FLOAT ||\n                        (op->vt->type.t & VT_BTYPE) == VT_DOUBLE) {\n                        load(tcc_freg(op->reg), op->vt);\n                    } else {\n                        load(tcc_ireg(op->reg), op->vt);\n                    }\n                    if (op->is_llong) {\n                        tcc_error(\"long long not implemented\");\n                    }\n                }\n            }\n        }\n    } else {\n        /* generate save code */\n        for(i = 0 ; i < nb_outputs; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    if (!op->is_memory) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL;\n                        sv.type.t = VT_PTR;\n                        load(tcc_ireg(out_reg), &sv);\n\n                        sv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | out_reg;\n                        store(tcc_ireg(op->reg), &sv);\n                    }\n                } else {\n                    if ((op->vt->type.t & VT_BTYPE) == VT_FLOAT ||\n                        (op->vt->type.t & VT_BTYPE) == VT_DOUBLE) {\n                        store(tcc_freg(op->reg), op->vt);\n                    } else {\n                        store(tcc_ireg(op->reg), op->vt);\n                    }\n                    if (op->is_llong) {\n                        tcc_error(\"long long not implemented\");\n                    }\n                }\n            }\n        }\n        /* generate reg restore code for floating point registers */\n        for(i = sizeof(reg_saved)/sizeof(reg_saved[0]) - 1; i >= 0; i--) {\n            reg = reg_saved[i];\n            if (regs_allocated[reg]) {\n                /* pop */\n                if (REG_IS_FLOAT(reg)){\n                    /* fld reg, offset(sp) */\n                    gen_le32(7 | (3 << 12) |\n                            ENCODE_RD(reg) | ENCODE_RS1(2) | 0);\n                } else {\n                    /* ld reg, offset(sp) */\n                    gen_le32(3 | (3 << 12) |\n                            ENCODE_RD(reg) | ENCODE_RS1(2) | 0);\n                }\n                /* addi sp, sp, offset */\n                gen_le32((4 << 2) | 3 |\n                        ENCODE_RD(2) | ENCODE_RS1(2) | 8 << 20);\n            }\n        }\n    }\n}\n\n/* return the constraint priority (we allocate first the lowest\n   numbered constraints) */\nstatic inline int constraint_priority(const char *str)\n{\n    // TODO: How is this chosen??\n    int priority, c, pr;\n\n    /* we take the lowest priority */\n    priority = 0;\n    for(;;) {\n        c = *str;\n        if (c == '\\0')\n            break;\n        str++;\n        switch(c) {\n        case 'A': // address that is held in a general-purpose register.\n        case 'S': // constraint that matches an absolute symbolic address.\n        case 'f': // register [float]\n        case 'r': // register [general]\n        case 'p': // valid memory address for load,store [general]\n            pr = 3;\n            break;\n        case 'I': // 12 bit signed immedate\n        case 'i': // immediate integer operand, including symbolic constants [general]\n        case 'm': // memory operand [general]\n        case 'g': // general-purpose-register, memory, immediate integer [general]\n            pr = 4;\n            break;\n        case 'v':\n            tcc_error(\"unimp: constraint '%c'\", c);\n        default:\n            tcc_error(\"unknown constraint '%d'\", c);\n        }\n        if (pr > priority)\n            priority = pr;\n    }\n    return priority;\n}\n\nstatic const char *skip_constraint_modifiers(const char *p)\n{\n    /* Constraint modifier:\n        =   Operand is written to by this instruction\n        +   Operand is both read and written to by this instruction\n        %   Instruction is commutative for this operand and the following operand.\n\n       Per-alternative constraint modifier:\n        &   Operand is clobbered before the instruction is done using the input operands\n    */\n    while (*p == '=' || *p == '&' || *p == '+' || *p == '%')\n        p++;\n    return p;\n}\n\n#define REG_OUT_MASK 0x01\n#define REG_IN_MASK  0x02\n\n#define is_reg_allocated(reg) (regs_allocated[reg] & reg_mask)\n\nST_FUNC void asm_compute_constraints(ASMOperand *operands,\n                                    int nb_operands, int nb_outputs,\n                                    const uint8_t *clobber_regs,\n                                    int *pout_reg)\n{\n    /* TODO: Simple constraints\n        whitespace  ignored\n        o  memory operand that is offsetable\n        V  memory but not offsetable\n        <  memory operand with autodecrement addressing is allowed.  Restrictions apply.\n        >  memory operand with autoincrement addressing is allowed.  Restrictions apply.\n        n  immediate integer operand with a known numeric value\n        E  immediate floating operand (const_double) is allowed, but only if target=host\n        F  immediate floating operand (const_double or const_vector) is allowed\n        s  immediate integer operand whose value is not an explicit integer\n        X  any operand whatsoever\n        0...9 (postfix); (can also be more than 1 digit number);  an operand that matches the specified operand number is allowed\n    */\n\n    /* TODO: RISCV constraints\n        J   The integer 0.\n        K   A 5-bit unsigned immediate for CSR access instructions.\n        A   An address that is held in a general-purpose register.\n        S   A constraint that matches an absolute symbolic address.\n        vr  A vector register (if available)..\n        vd  A vector register, excluding v0 (if available).\n        vm  A vector register, only v0 (if available).\n    */\n    ASMOperand *op;\n    int sorted_op[MAX_ASM_OPERANDS];\n    int i, j, k, p1, p2, tmp, reg, c, reg_mask;\n    const char *str;\n    uint8_t regs_allocated[NB_ASM_REGS];\n\n    /* init fields */\n    for (i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        op->input_index = -1;\n        op->ref_index = -1;\n        op->reg = -1;\n        op->is_memory = 0;\n        op->is_rw = 0;\n    }\n    /* compute constraint priority and evaluate references to output\n       constraints if input constraints */\n    for (i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        str = op->constraint;\n        str = skip_constraint_modifiers(str);\n        if (isnum(*str) || *str == '[') {\n            /* this is a reference to another constraint */\n            k = find_constraint(operands, nb_operands, str, NULL);\n            if ((unsigned) k >= i || i < nb_outputs)\n                tcc_error(\"invalid reference in constraint %d ('%s')\",\n                          i, str);\n            op->ref_index = k;\n            if (operands[k].input_index >= 0)\n                tcc_error(\"cannot reference twice the same operand\");\n            operands[k].input_index = i;\n            op->priority = 5;\n        } else if ((op->vt->r & VT_VALMASK) == VT_LOCAL\n                   && op->vt->sym\n                   && (reg = op->vt->sym->r & VT_VALMASK) < VT_CONST) {\n            op->priority = 1;\n            op->reg = reg;\n        } else {\n            op->priority = constraint_priority(str);\n        }\n    }\n\n    /* sort operands according to their priority */\n    for (i = 0; i < nb_operands; i++)\n        sorted_op[i] = i;\n    for (i = 0; i < nb_operands - 1; i++) {\n        for (j = i + 1; j < nb_operands; j++) {\n            p1 = operands[sorted_op[i]].priority;\n            p2 = operands[sorted_op[j]].priority;\n            if (p2 < p1) {\n                tmp = sorted_op[i];\n                sorted_op[i] = sorted_op[j];\n                sorted_op[j] = tmp;\n            }\n        }\n    }\n\n    for (i = 0; i < NB_ASM_REGS; i++) {\n        if (clobber_regs[i])\n            regs_allocated[i] = REG_IN_MASK | REG_OUT_MASK;\n        else\n            regs_allocated[i] = 0;\n    }\n\n    /* allocate registers and generate corresponding asm moves */\n    for (i = 0; i < nb_operands; i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        str = op->constraint;\n        /* no need to allocate references */\n        if (op->ref_index >= 0)\n            continue;\n        /* select if register is used for output, input or both */\n        if (op->input_index >= 0) {\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n        } else if (j < nb_outputs) {\n            reg_mask = REG_OUT_MASK;\n        } else {\n            reg_mask = REG_IN_MASK;\n        }\n        if (op->reg >= 0) {\n            if (is_reg_allocated(op->reg))\n                tcc_error\n                    (\"asm regvar requests register that's taken already\");\n            reg = op->reg;\n        }\n      try_next:\n        c = *str++;\n        switch (c) {\n        case '=': // Operand is written-to\n            goto try_next;\n        case '+': // Operand is both READ and written-to\n            op->is_rw = 1;\n            /* FALL THRU */\n        case '&': // Operand is clobbered before the instruction is done using the input operands\n            if (j >= nb_outputs)\n                tcc_error(\"'%c' modifier can only be applied to outputs\", c);\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n            goto try_next;\n        case 'r': // general-purpose register\n        case 'p': // loadable/storable address\n            /* any general register */\n            /* From a0 to a7 */\n            if ((reg = op->reg) >= 0)\n                goto reg_found;\n            else for (reg = 10; reg <= 18; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n          reg_found:\n            /* now we can reload in the register */\n            op->is_llong = 0;\n            op->reg = reg;\n            regs_allocated[reg] |= reg_mask;\n            break;\n        case 'f': // floating pont register\n            /* floating point register */\n            /* From fa0 to fa7 */\n            if ((reg = op->reg) >= 0)\n                goto reg_found;\n            else for (reg = 42; reg <= 50; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n        case 'I': // I-Type 12 bit signed immediate\n        case 'i': // immediate integer operand, including symbolic constants\n            if (!((op->vt->r & (VT_VALMASK | VT_LVAL)) == VT_CONST))\n                goto try_next;\n            break;\n        case 'm': // memory operand\n        case 'g': // any register\n            /* nothing special to do because the operand is already in\n               memory, except if the pointer itself is stored in a\n               memory variable (VT_LLOCAL case) */\n            /* XXX: fix constant case */\n            /* if it is a reference to a memory zone, it must lie\n               in a register, so we reserve the register in the\n               input registers and a load will be generated\n               later */\n            if (j < nb_outputs || c == 'm') {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    /* any general register: from a0 to a7 */\n                    for (reg = 10; reg <= 18; reg++) {\n                        if (!(regs_allocated[reg] & REG_IN_MASK))\n                            goto reg_found1;\n                    }\n                    goto try_next;\n                  reg_found1:\n                    /* now we can reload in the register */\n                    regs_allocated[reg] |= REG_IN_MASK;\n                    op->reg = reg;\n                    op->is_memory = 1;\n                }\n            }\n            break;\n        default:\n            tcc_error(\"asm constraint %d ('%s') could not be satisfied\",\n                      j, op->constraint);\n            break;\n        }\n        /* if a reference is present for that operand, we assign it too */\n        if (op->input_index >= 0) {\n            operands[op->input_index].reg = op->reg;\n            operands[op->input_index].is_llong = op->is_llong;\n        }\n    }\n\n    /* compute out_reg. It is used to store outputs registers to memory\n       locations references by pointers (VT_LLOCAL case) */\n    *pout_reg = -1;\n    for (i = 0; i < nb_operands; i++) {\n        op = &operands[i];\n        if (op->reg >= 0 &&\n            (op->vt->r & VT_VALMASK) == VT_LLOCAL && !op->is_memory) {\n            if (REG_IS_FLOAT(op->reg)){\n                /* From fa0 to fa7 */\n                for (reg = 42; reg <= 50; reg++) {\n                    if (!(regs_allocated[reg] & REG_OUT_MASK))\n                        goto reg_found2;\n                }\n            } else {\n                /* From a0 to a7 */\n                for (reg = 10; reg <= 18; reg++) {\n                    if (!(regs_allocated[reg] & REG_OUT_MASK))\n                        goto reg_found2;\n                }\n            }\n            tcc_error(\"could not find free output register for reloading\");\n          reg_found2:\n            *pout_reg = reg;\n            break;\n        }\n    }\n\n    /* print sorted constraints */\n#ifdef ASM_DEBUG\n    for (i = 0; i < nb_operands; i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        printf(\"%%%d [%s]: \\\"%s\\\" r=0x%04x reg=%d\\n\",\n               j,\n               op->id ? get_tok_str(op->id, NULL) : \"\",\n               op->constraint, op->vt->r, op->reg);\n    }\n    if (*pout_reg >= 0)\n        printf(\"out_reg=%d\\n\", *pout_reg);\n#endif\n}\n\nST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str)\n{\n    int reg;\n    TokenSym *ts;\n\n    if (!strcmp(str, \"memory\") ||\n        !strcmp(str, \"cc\") ||\n        !strcmp(str, \"flags\"))\n        return;\n    ts = tok_alloc(str, strlen(str));\n    reg = asm_parse_regvar(ts->tok);\n    if (reg == -1) {\n        tcc_error(\"invalid clobber register '%s'\", str);\n    }\n    clobber_regs[reg] = 1;\n}\n\nST_FUNC int asm_parse_regvar (int t)\n{\n    /* PC register not implemented */\n    if (t >= TOK_ASM_pc || t < TOK_ASM_x0)\n        return -1;\n\n    if (t < TOK_ASM_f0)\n        return t - TOK_ASM_x0;\n\n    if (t < TOK_ASM_zero)\n        return t - TOK_ASM_f0 + 32; // Use higher 32 for floating point\n\n    /* ABI mnemonic */\n    if (t < TOK_ASM_ft0)\n        return t - TOK_ASM_zero;\n\n    return t - TOK_ASM_ft0 + 32; // Use higher 32 for floating point\n}\n\n/*************************************************************/\n/* C extension */\n\n/* caller: Add funct6, funct2 into opcode */\nstatic void asm_emit_ca(int token, uint16_t opcode, const Operand *rd, const Operand *rs2)\n{\n    uint8_t dst, src;\n\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected source operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    /* subtract index of x8 */\n    dst = rd->reg - 8;\n    src = rs2->reg - 8;\n\n    /* only registers {x,f}8 to {x,f}15 are valid (3-bit) */\n    if (dst > 7) {\n        tcc_error(\"'%s': Expected destination operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    if (src > 7) {\n        tcc_error(\"'%s': Expected source operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    /* CA-type instruction:\n    15...10 funct6\n    9...7   rd'/rs1'\n    6..5    funct2\n    4...2   rs2'\n    1...0   opcode */\n\n    gen_le16(opcode | C_ENCODE_RS2(src) | C_ENCODE_RS1(dst));\n}\n\nstatic void asm_emit_cb(int token, uint16_t opcode, const Operand *rs1, const Operand *imm)\n{\n    uint32_t offset;\n    uint8_t src;\n\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected source operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (imm->type != OP_IM12S && imm->type != OP_IM32) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    offset = imm->e.v;\n\n    if (offset & 1) {\n        tcc_error(\"'%s': Expected source operand that is an even immediate value\", get_tok_str(token, NULL));\n    }\n\n    src = rs1->reg - 8;\n\n    if (src > 7) {\n        tcc_error(\"'%s': Expected source operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    /* CB-type instruction:\n    15...13 funct3\n    12...10 offset\n    9..7    rs1'\n    6...2   offset\n    1...0   opcode */\n\n    /* non-branch also using CB:\n    15...13 funct3\n    12      imm\n    11..10  funct2\n    9...7   rd'/rs1'\n    6..2    imm\n    1...0   opcode */\n\n    switch (token) {\n    case TOK_ASM_c_beqz:\n    case TOK_ASM_c_bnez:\n        gen_le16(opcode | C_ENCODE_RS1(src) | ((NTH_BIT(offset, 5) | (((offset >> 1) & 3) << 1) | (((offset >> 6) & 3) << 3)) << 2) | ((((offset >> 3) & 3) | NTH_BIT(offset, 8)) << 10));\n        return;\n    default:\n        gen_le16(opcode | C_ENCODE_RS1(src) | ((offset & 0x1f) << 2) | (NTH_BIT(offset, 5) << 12));\n        return;\n    }\n}\n\nstatic void asm_emit_ci(int token, uint16_t opcode, const Operand *rd, const Operand *imm)\n{\n    uint32_t immediate;\n\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (imm->type != OP_IM12S && imm->type != OP_IM32) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    immediate = imm->e.v;\n\n    /* CI-type instruction:\n    15...13 funct3\n    12      imm\n    11...7  rd/rs1\n    6...2   imm\n    1...0   opcode */\n\n    switch (token) {\n    case TOK_ASM_c_addi:\n    case TOK_ASM_c_addiw:\n    case TOK_ASM_c_li:\n    case TOK_ASM_c_slli:\n        gen_le16(opcode | ((immediate & 0x1f) << 2) | ENCODE_RD(rd->reg) | (NTH_BIT(immediate, 5) << 12));\n        return;\n    case TOK_ASM_c_addi16sp:\n        gen_le16(opcode | NTH_BIT(immediate, 5) << 2 | (((immediate >> 7) & 3) << 3) | NTH_BIT(immediate, 6) << 5 | NTH_BIT(immediate, 4) << 6 | ENCODE_RD(rd->reg) | (NTH_BIT(immediate, 9) << 12));\n        return;\n    case TOK_ASM_c_lui:\n        gen_le16(opcode | (((immediate >> 12) & 0x1f) << 2) | ENCODE_RD(rd->reg) | (NTH_BIT(immediate, 17) << 12));\n        return;\n    case TOK_ASM_c_fldsp:\n    case TOK_ASM_c_ldsp:\n        gen_le16(opcode | (((immediate >> 6) & 7) << 2) | (((immediate >> 3) & 2) << 5) | ENCODE_RD(rd->reg) | (NTH_BIT(immediate, 5) << 12));\n        return;\n    case TOK_ASM_c_flwsp:\n    case TOK_ASM_c_lwsp:\n        gen_le16(opcode | (((immediate >> 6) & 3) << 2) | (((immediate >> 2) & 7) << 4) | ENCODE_RD(rd->reg) | (NTH_BIT(immediate, 5) << 12));\n        return;\n    case TOK_ASM_c_nop:\n        gen_le16(opcode);\n        return;\n    default:\n        expect(\"known instruction\");\n    }\n}\n\n/* caller: Add funct3 into opcode */\nstatic void asm_emit_ciw(int token, uint16_t opcode, const Operand *rd, const Operand *imm)\n{\n    uint32_t nzuimm;\n    uint8_t dst;\n\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (imm->type != OP_IM12S && imm->type != OP_IM32) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    dst = rd->reg - 8;\n\n    if (dst > 7) {\n        tcc_error(\"'%s': Expected destination operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    nzuimm = imm->e.v;\n\n    if (nzuimm > 0x3fc) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value between 0 and 0x3ff\", get_tok_str(token, NULL));\n    }\n\n    if (nzuimm & 3) {\n        tcc_error(\"'%s': Expected source operand that is a non-zero immediate value divisible by 4\", get_tok_str(token, NULL));\n    }\n\n    /* CIW-type instruction:\n    15...13 funct3\n    12...5  imm\n    4...2   rd'\n    1...0   opcode */\n\n    gen_le16(opcode | ENCODE_RS2(rd->reg) | ((NTH_BIT(nzuimm, 3) | (NTH_BIT(nzuimm, 2) << 1) | (((nzuimm >> 6) & 0xf) << 2) | (((nzuimm >> 4) & 3) << 6)) << 5));\n}\n\n/* caller: Add funct3 into opcode */\nstatic void asm_emit_cj(int token, uint16_t opcode, const Operand *imm)\n{\n    uint32_t offset;\n\n    /* +-2 KiB range */\n    if (imm->type != OP_IM12S) {\n        tcc_error(\"'%s': Expected source operand that is a 12-bit immediate value\", get_tok_str(token, NULL));\n    }\n\n    offset = imm->e.v;\n\n    if (offset & 1) {\n        tcc_error(\"'%s': Expected source operand that is an even immediate value\", get_tok_str(token, NULL));\n    }\n\n    /* CJ-type instruction:\n    15...13 funct3\n    12...2  offset[11|4|9:8|10|6|7|3:1|5]\n    1...0   opcode */\n\n    gen_le16(opcode | (NTH_BIT(offset, 5) << 2) | (((offset >> 1) & 7) << 3) | (NTH_BIT(offset, 7) << 6) | (NTH_BIT(offset, 6) << 7) | (NTH_BIT(offset, 10) << 8) | (((offset >> 8) & 3) << 9) | (NTH_BIT(offset, 4) << 11) | (NTH_BIT(offset, 11) << 12));\n}\n\n/* caller: Add funct3 into opcode */\nstatic void asm_emit_cl(int token, uint16_t opcode, const Operand *rd, const Operand *rs1, const Operand *imm)\n{\n    uint32_t offset;\n    uint8_t dst, src;\n\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected source operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (imm->type != OP_IM12S && imm->type != OP_IM32) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    dst = rd->reg - 8;\n    src = rs1->reg - 8;\n\n    if (dst > 7) {\n        tcc_error(\"'%s': Expected destination operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    if (src > 7) {\n        tcc_error(\"'%s': Expected source operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    offset = imm->e.v;\n\n    if (offset > 0xff) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value between 0 and 0xff\", get_tok_str(token, NULL));\n    }\n\n    if (offset & 3) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value divisible by 4\", get_tok_str(token, NULL));\n    }\n\n    /* CL-type instruction:\n    15...13 funct3\n    12...10 imm\n    9...7   rs1'\n    6...5   imm\n    4...2   rd'\n    1...0   opcode */\n\n    switch (token) {\n    /* imm variant 1 */\n    case TOK_ASM_c_flw:\n    case TOK_ASM_c_lw:\n        gen_le16(opcode | C_ENCODE_RS2(dst) | C_ENCODE_RS1(src) | (NTH_BIT(offset, 6) << 5) | (NTH_BIT(offset, 2) << 6) | (((offset >> 3) & 7) << 10));\n        return;\n    /* imm variant 2 */\n    case TOK_ASM_c_fld:\n    case TOK_ASM_c_ld:\n        gen_le16(opcode | C_ENCODE_RS2(dst) | C_ENCODE_RS1(src) | (((offset >> 6) & 3) << 5) | (((offset >> 3) & 7) << 10));\n        return;\n    default:\n        expect(\"known instruction\");\n    }\n}\n\n/* caller: Add funct4 into opcode */\nstatic void asm_emit_cr(int token, uint16_t opcode, const Operand *rd, const Operand *rs2)\n{\n    if (rd->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected source operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    /* CR-type instruction:\n    15...12 funct4\n    11..7   rd/rs1\n    6...2   rs2\n    1...0   opcode */\n\n    gen_le16(opcode | C_ENCODE_RS1(rd->reg) | C_ENCODE_RS2(rs2->reg));\n}\n\n/* caller: Add funct3 into opcode */\nstatic void asm_emit_cs(int token, uint16_t opcode, const Operand *rs2, const Operand *rs1, const Operand *imm)\n{\n    uint32_t offset;\n    uint8_t base, src;\n\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (rs1->type != OP_REG) {\n        tcc_error(\"'%s': Expected source operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (imm->type != OP_IM12S && imm->type != OP_IM32) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    base = rs1->reg - 8;\n    src = rs2->reg - 8;\n\n    if (base > 7) {\n        tcc_error(\"'%s': Expected destination operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    if (src > 7) {\n        tcc_error(\"'%s': Expected source operand that is a valid C-extension register\", get_tok_str(token, NULL));\n    }\n\n    offset = imm->e.v;\n\n    if (offset > 0xff) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value between 0 and 0xff\", get_tok_str(token, NULL));\n    }\n\n    if (offset & 3) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value divisible by 4\", get_tok_str(token, NULL));\n    }\n\n    /* CS-type instruction:\n    15...13 funct3\n    12...10 imm\n    9...7   rs1'\n    6...5   imm\n    4...2   rs2'\n    1...0   opcode */\n    switch (token) {\n    /* imm variant 1 */\n    case TOK_ASM_c_fsw:\n    case TOK_ASM_c_sw:\n        gen_le16(opcode | C_ENCODE_RS2(base) | C_ENCODE_RS1(src) | (NTH_BIT(offset, 6) << 5) | (NTH_BIT(offset, 2) << 6) | (((offset >> 3) & 7) << 10));\n        return;\n    /* imm variant 2 */\n    case TOK_ASM_c_fsd:\n    case TOK_ASM_c_sd:\n        gen_le16(opcode | C_ENCODE_RS2(base) | C_ENCODE_RS1(src) | (((offset >> 6) & 3) << 5) | (((offset >> 3) & 7) << 10));\n        return;\n    default:\n        expect(\"known instruction\");\n    }\n}\n\n/* caller: Add funct3 into opcode */\nstatic void asm_emit_css(int token, uint16_t opcode, const Operand *rs2, const Operand *imm)\n{\n    uint32_t offset;\n\n    if (rs2->type != OP_REG) {\n        tcc_error(\"'%s': Expected destination operand that is a register\", get_tok_str(token, NULL));\n    }\n\n    if (imm->type != OP_IM12S && imm->type != OP_IM32) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value\", get_tok_str(token, NULL));\n    }\n\n    offset = imm->e.v;\n\n    if (offset > 0xff) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value between 0 and 0xff\", get_tok_str(token, NULL));\n    }\n\n    if (offset & 3) {\n        tcc_error(\"'%s': Expected source operand that is an immediate value divisible by 4\", get_tok_str(token, NULL));\n    }\n\n    /* CSS-type instruction:\n    15...13 funct3\n    12...7  imm\n    6...2   rs2\n    1...0   opcode */\n\n    switch (token) {\n    /* imm variant 1 */\n    case TOK_ASM_c_fswsp:\n    case TOK_ASM_c_swsp:\n        gen_le16(opcode | ENCODE_RS2(rs2->reg) | (((offset >> 6) & 3) << 7) | (((offset >> 2) & 0xf) << 9));\n        return;\n    /* imm variant 2 */\n    case TOK_ASM_c_fsdsp:\n    case TOK_ASM_c_sdsp:\n        gen_le16(opcode | ENCODE_RS2(rs2->reg) | (((offset >> 6) & 7) << 7) | (((offset >> 3) & 7) << 10));\n        return;\n    default:\n        expect(\"known instruction\");\n    }\n}\n\n/*************************************************************/\n#endif /* ndef TARGET_DEFS_ONLY */\n"
        },
        {
          "name": "riscv64-gen.c",
          "type": "blob",
          "size": 45.6064453125,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n// Number of registers available to allocator:\n#define NB_REGS 19 // x10-x17 aka a0-a7, f10-f17 aka fa0-fa7, xxx, ra, sp\n#define CONFIG_TCC_ASM\n\n#define TREG_R(x) (x) // x = 0..7\n#define TREG_F(x) (x + 8) // x = 0..7\n\n// Register classes sorted from more general to more precise:\n#define RC_INT (1 << 0)\n#define RC_FLOAT (1 << 1)\n#define RC_R(x) (1 << (2 + (x))) // x = 0..7\n#define RC_F(x) (1 << (10 + (x))) // x = 0..7\n\n#define RC_IRET (RC_R(0)) // int return register class\n#define RC_IRE2 (RC_R(1)) // int 2nd return register class\n#define RC_FRET (RC_F(0)) // float return register class\n\n#define REG_IRET (TREG_R(0)) // int return register number\n#define REG_IRE2 (TREG_R(1)) // int 2nd return register number\n#define REG_FRET (TREG_F(0)) // float return register number\n\n#define PTR_SIZE 8\n\n#define LDOUBLE_SIZE 16\n#define LDOUBLE_ALIGN 16\n\n#define MAX_ALIGN 16\n\n#define CHAR_IS_UNSIGNED\n\n#else\n#define USING_GLOBALS\n#include \"tcc.h\"\n#include <assert.h>\n\nST_DATA const char * const target_machine_defs =\n    \"__riscv\\0\"\n    \"__riscv_xlen 64\\0\"\n    \"__riscv_flen 64\\0\"\n    \"__riscv_div\\0\"\n    \"__riscv_mul\\0\"\n    \"__riscv_fdiv\\0\"\n    \"__riscv_fsqrt\\0\"\n    \"__riscv_float_abi_double\\0\"\n    ;\n\n#define XLEN 8\n\n#define TREG_RA 17\n#define TREG_SP 18\n\nST_DATA const int reg_classes[NB_REGS] = {\n  RC_INT | RC_R(0),\n  RC_INT | RC_R(1),\n  RC_INT | RC_R(2),\n  RC_INT | RC_R(3),\n  RC_INT | RC_R(4),\n  RC_INT | RC_R(5),\n  RC_INT | RC_R(6),\n  RC_INT | RC_R(7),\n  RC_FLOAT | RC_F(0),\n  RC_FLOAT | RC_F(1),\n  RC_FLOAT | RC_F(2),\n  RC_FLOAT | RC_F(3),\n  RC_FLOAT | RC_F(4),\n  RC_FLOAT | RC_F(5),\n  RC_FLOAT | RC_F(6),\n  RC_FLOAT | RC_F(7),\n  0,\n  1 << TREG_RA,\n  1 << TREG_SP\n};\n\n#if defined(CONFIG_TCC_BCHECK)\nstatic addr_t func_bound_offset;\nstatic unsigned long func_bound_ind;\nST_DATA int func_bound_add_epilog;\n#endif\n\nstatic int ireg(int r)\n{\n    if (r == TREG_RA)\n      return 1; // ra\n    if (r == TREG_SP)\n      return 2; // sp\n    assert(r >= 0 && r < 8);\n    return r + 10;  // tccrX --> aX == x(10+X)\n}\n\nstatic int is_ireg(int r)\n{\n    return (unsigned)r < 8 || r == TREG_RA || r == TREG_SP;\n}\n\nstatic int freg(int r)\n{\n    assert(r >= 8 && r < 16);\n    return r - 8 + 10;  // tccfX --> faX == f(10+X)\n}\n\nstatic int is_freg(int r)\n{\n    return r >= 8 && r < 16;\n}\n\nST_FUNC void o(unsigned int c)\n{\n    int ind1 = ind + 4;\n    if (nocode_wanted)\n        return;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    write32le(cur_text_section->data + ind, c);\n    ind = ind1;\n}\n\nstatic void EIu(uint32_t opcode, uint32_t func3,\n               uint32_t rd, uint32_t rs1, uint32_t imm)\n{\n    o(opcode | (func3 << 12) | (rd << 7) | (rs1 << 15) | (imm << 20));\n}\n\nstatic void ER(uint32_t opcode, uint32_t func3,\n               uint32_t rd, uint32_t rs1, uint32_t rs2, uint32_t func7)\n{\n    o(opcode | func3 << 12 | rd << 7 | rs1 << 15 | rs2 << 20 | func7 << 25);\n}\n\nstatic void EI(uint32_t opcode, uint32_t func3,\n               uint32_t rd, uint32_t rs1, uint32_t imm)\n{\n    assert(! ((imm + (1 << 11)) >> 12));\n    EIu(opcode, func3, rd, rs1, imm);\n}\n\nstatic void ES(uint32_t opcode, uint32_t func3,\n               uint32_t rs1, uint32_t rs2, uint32_t imm)\n{\n    assert(! ((imm + (1 << 11)) >> 12));\n    o(opcode | (func3 << 12) | ((imm & 0x1f) << 7) | (rs1 << 15)\n      | (rs2 << 20) | ((imm >> 5) << 25));\n}\n\n// Patch all branches in list pointed to by t to branch to a:\nST_FUNC void gsym_addr(int t_, int a_)\n{\n    uint32_t t = t_;\n    uint32_t a = a_;\n    while (t) {\n        unsigned char *ptr = cur_text_section->data + t;\n        uint32_t next = read32le(ptr);\n        uint32_t r = a - t, imm;\n        if ((r + (1 << 21)) & ~((1U << 22) - 2))\n          tcc_error(\"out-of-range branch chain\");\n        imm =   (((r >> 12) &  0xff) << 12)\n            | (((r >> 11) &     1) << 20)\n            | (((r >>  1) & 0x3ff) << 21)\n            | (((r >> 20) &     1) << 31);\n        write32le(ptr, r == 4 ? 0x33 : 0x6f | imm); // nop || j imm\n        t = next;\n    }\n}\n\nstatic int load_symofs(int r, SValue *sv, int forstore)\n{\n    int rr, doload = 0, large_addend = 0;\n    int fc = sv->c.i, v = sv->r & VT_VALMASK;\n    if (sv->r & VT_SYM) {\n        Sym label = {0};\n        assert(v == VT_CONST);\n        if (sv->sym->type.t & VT_STATIC) { // XXX do this per linker relax\n            greloca(cur_text_section, sv->sym, ind,\n                    R_RISCV_PCREL_HI20, sv->c.i);\n            sv->c.i = 0;\n        } else {\n            if (((unsigned)fc + (1 << 11)) >> 12){\n              large_addend = 1;\n            }\n            greloca(cur_text_section, sv->sym, ind,\n                    R_RISCV_GOT_HI20, 0);\n            doload = 1;\n        }\n        label.type.t = VT_VOID | VT_STATIC;\n\tif (!nocode_wanted)\n            put_extern_sym(&label, cur_text_section, ind, 0);\n        rr = is_ireg(r) ? ireg(r) : 5;\n        o(0x17 | (rr << 7));   // auipc RR, 0 %pcrel_hi(sym)+addend\n        greloca(cur_text_section, &label, ind,\n                doload || !forstore\n                  ? R_RISCV_PCREL_LO12_I : R_RISCV_PCREL_LO12_S, 0);\n        if (doload) {\n            EI(0x03, 3, rr, rr, 0); // ld RR, 0(RR)\n            if (large_addend) {\n                o(0x37 | (6 << 7) | ((0x800 + fc) & 0xfffff000)); //lui t1, high(fc)\n                ER(0x33, 0, rr, rr, 6, 0); // add RR, RR, t1\n                sv->c.i = fc << 20 >> 20;\n            }\n        }\n    } else if (v == VT_LOCAL || v == VT_LLOCAL) {\n        rr = 8; // s0\n        if (fc != sv->c.i)\n          tcc_error(\"unimp: store(giant local off) (0x%lx)\", (long)sv->c.i);\n        if (((unsigned)fc + (1 << 11)) >> 12) {\n            rr = is_ireg(r) ? ireg(r) : 5; // t0\n            o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)\n            ER(0x33, 0, rr, rr, 8, 0); // add RR, RR, s0\n            sv->c.i = fc << 20 >> 20;\n        }\n    } else\n      tcc_error(\"uhh\");\n    return rr;\n}\n\nstatic void load_large_constant(int rr, int fc, uint32_t pi)\n{\n    if (fc < 0)\n\tpi++;\n    o(0x37 | (rr << 7) | (((pi + 0x800) & 0xfffff000))); // lui RR, up(up(fc))\n    EI(0x13, 0, rr, rr, (int)pi << 20 >> 20);   // addi RR, RR, lo(up(fc))\n    EI(0x13, 1, rr, rr, 12); // slli RR, RR, 12\n    EI(0x13, 0, rr, rr, (fc + (1 << 19)) >> 20);  // addi RR, RR, up(lo(fc))\n    EI(0x13, 1, rr, rr, 12); // slli RR, RR, 12\n    fc = fc << 12 >> 12;\n    EI(0x13, 0, rr, rr, fc >> 8);  // addi RR, RR, lo1(lo(fc))\n    EI(0x13, 1, rr, rr, 8); // slli RR, RR, 8\n}\n\nST_FUNC void load(int r, SValue *sv)\n{\n    int fr = sv->r;\n    int v = fr & VT_VALMASK;\n    int rr = is_ireg(r) ? ireg(r) : freg(r);\n    int fc = sv->c.i;\n    int bt = sv->type.t & VT_BTYPE;\n    int align, size;\n    if (fr & VT_LVAL) {\n        int func3, opcode = is_freg(r) ? 0x07 : 0x03, br;\n        size = type_size(&sv->type, &align);\n        assert (!is_freg(r) || bt == VT_FLOAT || bt == VT_DOUBLE);\n        if (bt == VT_PTR || bt == VT_FUNC) /* XXX should be done in generic code */\n          size = PTR_SIZE;\n        func3 = size == 1 ? 0 : size == 2 ? 1 : size == 4 ? 2 : 3;\n        if (size < 4 && !is_float(sv->type.t) && (sv->type.t & VT_UNSIGNED))\n          func3 |= 4;\n        if (v == VT_LOCAL || (fr & VT_SYM)) {\n            br = load_symofs(r, sv, 0);\n            fc = sv->c.i;\n        } else if (v < VT_CONST) {\n            br = ireg(v);\n            /*if (((unsigned)fc + (1 << 11)) >> 12)\n              tcc_error(\"unimp: load(large addend) (0x%x)\", fc);*/\n            fc = 0; // XXX store ofs in LVAL(reg)\n        } else if (v == VT_LLOCAL) {\n            br = load_symofs(r, sv, 0);\n            fc = sv->c.i;\n            EI(0x03, 3, rr, br, fc); // ld RR, fc(BR)\n            br = rr;\n            fc = 0;\n        } else if (v == VT_CONST) {\n            int64_t si = sv->c.i;\n            si >>= 32;\n            if (si != 0) {\n\t\tload_large_constant(rr, fc, si);\n                fc &= 0xff;\n            } else {\n                o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)\n                fc = fc << 20 >> 20;\n\t    }\n            br = rr;\n\t} else {\n            tcc_error(\"unimp: load(non-local lval)\");\n        }\n        EI(opcode, func3, rr, br, fc); // l[bhwd][u] / fl[wd] RR, fc(BR)\n    } else if (v == VT_CONST) {\n        int rb = 0, do32bit = 8, zext = 0;\n        assert((!is_float(sv->type.t) && is_ireg(r)) || bt == VT_LDOUBLE);\n        if (fr & VT_SYM) {\n            rb = load_symofs(r, sv, 0);\n            fc = sv->c.i;\n            do32bit = 0;\n        }\n        if (is_float(sv->type.t) && bt != VT_LDOUBLE)\n          tcc_error(\"unimp: load(float)\");\n        if (fc != sv->c.i) {\n            int64_t si = sv->c.i;\n            si >>= 32;\n            if (si != 0) {\n\t\tload_large_constant(rr, fc, si);\n                fc &= 0xff;\n                rb = rr;\n                do32bit = 0;\n            } else if (bt == VT_LLONG) {\n                /* A 32bit unsigned constant for a 64bit type.\n                   lui always sign extends, so we need to do an explicit zext.*/\n                zext = 1;\n            }\n        }\n        if (((unsigned)fc + (1 << 11)) >> 12)\n            o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)), rb = rr; //lui RR, upper(fc)\n        if (fc || (rr != rb) || do32bit || (fr & VT_SYM))\n          EI(0x13 | do32bit, 0, rr, rb, fc << 20 >> 20); // addi[w] R, x0|R, FC\n        if (zext) {\n            EI(0x13, 1, rr, rr, 32); // slli RR, RR, 32\n            EI(0x13, 5, rr, rr, 32); // srli RR, RR, 32\n        }\n    } else if (v == VT_LOCAL) {\n        int br = load_symofs(r, sv, 0);\n        assert(is_ireg(r));\n        fc = sv->c.i;\n        EI(0x13, 0, rr, br, fc); // addi R, s0, FC\n    } else if (v < VT_CONST) { /* reg-reg */\n        //assert(!fc); XXX support offseted regs\n        if (is_freg(r) && is_freg(v))\n          ER(0x53, 0, rr, freg(v), freg(v), bt == VT_DOUBLE ? 0x11 : 0x10); //fsgnj.[sd] RR, V, V == fmv.[sd] RR, V\n        else if (is_ireg(r) && is_ireg(v))\n          EI(0x13, 0, rr, ireg(v), 0); // addi RR, V, 0 == mv RR, V\n        else {\n            int func7 = is_ireg(r) ? 0x70 : 0x78;\n            size = type_size(&sv->type, &align);\n            if (size == 8)\n              func7 |= 1;\n            assert(size == 4 || size == 8);\n            o(0x53 | (rr << 7) | ((is_freg(v) ? freg(v) : ireg(v)) << 15)\n              | (func7 << 25)); // fmv.{w.x, x.w, d.x, x.d} RR, VR\n        }\n    } else if (v == VT_CMP) {\n        int op = vtop->cmp_op;\n        int a = vtop->cmp_r & 0xff;\n        int b = (vtop->cmp_r >> 8) & 0xff;\n        int inv = 0;\n        switch (op) {\n            case TOK_ULT:\n            case TOK_UGE:\n            case TOK_ULE:\n            case TOK_UGT:\n            case TOK_LT:\n            case TOK_GE:\n            case TOK_LE:\n            case TOK_GT:\n                if (op & 1) { // remove [U]GE,GT\n                    inv = 1;\n                    op--;\n                }\n                if ((op & 7) == 6) { // [U]LE\n                    int t = a; a = b; b = t;\n                    inv ^= 1;\n                }\n                ER(0x33, (op > TOK_UGT) ? 2 : 3, rr, a, b, 0); // slt[u] d, a, b\n                if (inv)\n                  EI(0x13, 4, rr, rr, 1); // xori d, d, 1\n                break;\n            case TOK_NE:\n            case TOK_EQ:\n                if (rr != a || b)\n                  ER(0x33, 0, rr, a, b, 0x20); // sub d, a, b\n                if (op == TOK_NE)\n                  ER(0x33, 3, rr, 0, rr, 0); // sltu d, x0, d == snez d,d\n                else\n                  EI(0x13, 3, rr, rr, 1); // sltiu d, d, 1 == seqz d,d\n                break;\n        }\n    } else if ((v & ~1) == VT_JMP) {\n        int t = v & 1;\n        assert(is_ireg(r));\n        EI(0x13, 0, rr, 0, t);      // addi RR, x0, t\n        gjmp_addr(ind + 8);\n        gsym(fc);\n        EI(0x13, 0, rr, 0, t ^ 1);  // addi RR, x0, !t\n    } else\n      tcc_error(\"unimp: load(non-const)\");\n}\n\nST_FUNC void store(int r, SValue *sv)\n{\n    int fr = sv->r & VT_VALMASK;\n    int rr = is_ireg(r) ? ireg(r) : freg(r), ptrreg;\n    int fc = sv->c.i;\n    int bt = sv->type.t & VT_BTYPE;\n    int align, size = type_size(&sv->type, &align);\n    assert(!is_float(bt) || is_freg(r) || bt == VT_LDOUBLE);\n    /* long doubles are in two integer registers, but the load/store\n       primitives only deal with one, so do as if it's one reg.  */\n    if (bt == VT_LDOUBLE)\n      size = align = 8;\n    if (bt == VT_STRUCT)\n      tcc_error(\"unimp: store(struct)\");\n    if (size > 8)\n      tcc_error(\"unimp: large sized store\");\n    assert(sv->r & VT_LVAL);\n    if (fr == VT_LOCAL || (sv->r & VT_SYM)) {\n        ptrreg = load_symofs(-1, sv, 1);\n        fc = sv->c.i;\n    } else if (fr < VT_CONST) {\n        ptrreg = ireg(fr);\n        /*if (((unsigned)fc + (1 << 11)) >> 12)\n          tcc_error(\"unimp: store(large addend) (0x%x)\", fc);*/\n        fc = 0; // XXX support offsets regs\n    } else if (fr == VT_CONST) {\n        int64_t si = sv->c.i;\n        ptrreg = 8; // s0\n        si >>= 32;\n        if (si != 0) {\n\t    load_large_constant(ptrreg, fc, si);\n            fc &= 0xff;\n        } else {\n            o(0x37 | (ptrreg << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)\n            fc = fc << 20 >> 20;\n\t}\n    } else\n      tcc_error(\"implement me: %s(!local)\", __FUNCTION__);\n    ES(is_freg(r) ? 0x27 : 0x23,                          // fs... | s...\n       size == 1 ? 0 : size == 2 ? 1 : size == 4 ? 2 : 3, // ... [wd] | [bhwd]\n       ptrreg, rr, fc);                                   // RR, fc(base)\n}\n\nstatic void gcall_or_jmp(int docall)\n{\n    int tr = docall ? 1 : 5; // ra or t0\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&\n        ((vtop->r & VT_SYM) && vtop->c.i == (int)vtop->c.i)) {\n        /* constant symbolic case -> simple relocation */\n        greloca(cur_text_section, vtop->sym, ind,\n                R_RISCV_CALL_PLT, (int)vtop->c.i);\n        o(0x17 | (tr << 7));   // auipc TR, 0 %call(func)\n        EI(0x67, 0, tr, tr, 0);// jalr  TR, r(TR)\n    } else if (vtop->r < VT_CONST) {\n        int r = ireg(vtop->r);\n        EI(0x67, 0, tr, r, 0);      // jalr TR, 0(R)\n    } else {\n        int r = TREG_RA;\n        load(r, vtop);\n        r = ireg(r);\n        EI(0x67, 0, tr, r, 0);      // jalr TR, 0(R)\n    }\n}\n\n#if defined(CONFIG_TCC_BCHECK)\n\nstatic void gen_bounds_call(int v)\n{\n    Sym *sym = external_helper_sym(v);\n\n    greloca(cur_text_section, sym, ind, R_RISCV_CALL_PLT, 0);\n    o(0x17 | (1 << 7));   // auipc TR, 0 %call(func)\n    EI(0x67, 0, 1, 1, 0); // jalr  TR, r(TR)\n}\n\nstatic void gen_bounds_prolog(void)\n{\n    /* leave some room for bound checking code */\n    func_bound_offset = lbounds_section->data_offset;\n    func_bound_ind = ind;\n    func_bound_add_epilog = 0;\n    o(0x00000013);  /* ld a0,#lbound section pointer */\n    o(0x00000013);\n    o(0x00000013);  /* nop -> call __bound_local_new */\n    o(0x00000013);\n}\n\nstatic void gen_bounds_epilog(void)\n{\n    addr_t saved_ind;\n    addr_t *bounds_ptr;\n    Sym *sym_data;\n    Sym label = {0};\n\n    int offset_modified = func_bound_offset != lbounds_section->data_offset;\n\n    if (!offset_modified && !func_bound_add_epilog)\n        return;\n\n    /* add end of table info */\n    bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));\n    *bounds_ptr = 0;\n\n    sym_data = get_sym_ref(&char_pointer_type, lbounds_section,\n                           func_bound_offset, PTR_SIZE);\n\n    label.type.t = VT_VOID | VT_STATIC;\n    /* generate bound local allocation */\n    if (offset_modified) {\n        saved_ind = ind;\n        ind = func_bound_ind;\n        put_extern_sym(&label, cur_text_section, ind, 0);\n        greloca(cur_text_section, sym_data, ind, R_RISCV_GOT_HI20, 0);\n        o(0x17 | (10 << 7));    // auipc a0, 0 %pcrel_hi(sym)+addend\n        greloca(cur_text_section, &label, ind, R_RISCV_PCREL_LO12_I, 0);\n        EI(0x03, 3, 10, 10, 0); // ld a0, 0(a0)\n        gen_bounds_call(TOK___bound_local_new);\n        ind = saved_ind;\n        label.c = 0; /* force new local ELF symbol */\n    }\n\n    /* generate bound check local freeing */\n    o(0xe02a1101); /* addi sp,sp,-32  sd   a0,0(sp)   */\n    o(0xa82ae42e); /* sd   a1,8(sp)   fsd  fa0,16(sp) */\n    put_extern_sym(&label, cur_text_section, ind, 0);\n    greloca(cur_text_section, sym_data, ind, R_RISCV_GOT_HI20, 0);\n    o(0x17 | (10 << 7));    // auipc a0, 0 %pcrel_hi(sym)+addend\n    greloca(cur_text_section, &label, ind, R_RISCV_PCREL_LO12_I, 0);\n    EI(0x03, 3, 10, 10, 0); // ld a0, 0(a0)\n    gen_bounds_call(TOK___bound_local_delete);\n    o(0x65a26502); /* ld   a0,0(sp)   ld   a1,8(sp)   */\n    o(0x61052542); /* fld  fa0,16(sp) addi sp,sp,32   */\n}\n#endif\n\nstatic void reg_pass_rec(CType *type, int *rc, int *fieldofs, int ofs)\n{\n    if ((type->t & VT_BTYPE) == VT_STRUCT) {\n        Sym *f;\n        if (type->ref->type.t == VT_UNION)\n          rc[0] = -1;\n        else for (f = type->ref->next; f; f = f->next)\n          reg_pass_rec(&f->type, rc, fieldofs, ofs + f->c);\n    } else if (type->t & VT_ARRAY) {\n        if (type->ref->c < 0 || type->ref->c > 2)\n          rc[0] = -1;\n        else {\n            int a, sz = type_size(&type->ref->type, &a);\n            reg_pass_rec(&type->ref->type, rc, fieldofs, ofs);\n            if (rc[0] > 2 || (rc[0] == 2 && type->ref->c > 1))\n              rc[0] = -1;\n            else if (type->ref->c == 2 && rc[0] && rc[1] == RC_FLOAT) {\n              rc[++rc[0]] = RC_FLOAT;\n              fieldofs[rc[0]] = ((ofs + sz) << 4)\n                                | (type->ref->type.t & VT_BTYPE);\n            } else if (type->ref->c == 2)\n              rc[0] = -1;\n        }\n    } else if (rc[0] == 2 || rc[0] < 0 || (type->t & VT_BTYPE) == VT_LDOUBLE)\n      rc[0] = -1;\n    else if (!rc[0] || rc[1] == RC_FLOAT || is_float(type->t)) {\n      rc[++rc[0]] = is_float(type->t) ? RC_FLOAT : RC_INT;\n      fieldofs[rc[0]] = (ofs << 4) | ((type->t & VT_BTYPE) == VT_PTR ? VT_LLONG : type->t & VT_BTYPE);\n    } else\n      rc[0] = -1;\n}\n\nstatic void reg_pass(CType *type, int *prc, int *fieldofs, int named)\n{\n    prc[0] = 0;\n    reg_pass_rec(type, prc, fieldofs, 0);\n    if (prc[0] <= 0 || !named) {\n        int align, size = type_size(type, &align);\n        prc[0] = (size + 7) >> 3;\n        prc[1] = prc[2] = RC_INT;\n        fieldofs[1] = (0 << 4) | (size <= 1 ? VT_BYTE : size <= 2 ? VT_SHORT : size <= 4 ? VT_INT : VT_LLONG);\n        fieldofs[2] = (8 << 4) | (size <= 9 ? VT_BYTE : size <= 10 ? VT_SHORT : size <= 12 ? VT_INT : VT_LLONG);\n    }\n}\n\nST_FUNC void gfunc_call(int nb_args)\n{\n    int i, align, size, areg[2];\n    int *info = tcc_malloc((nb_args + 1) * sizeof (int));\n    int stack_adj = 0, tempspace = 0, stack_add, ofs, splitofs = 0;\n    SValue *sv;\n    Sym *sa;\n\n#ifdef CONFIG_TCC_BCHECK\n    int bc_save = tcc_state->do_bounds_check;\n    if (tcc_state->do_bounds_check)\n        gbound_args(nb_args);\n#endif\n\n    areg[0] = 0; /* int arg regs */\n    areg[1] = 8; /* float arg regs */\n    sa = vtop[-nb_args].type.ref->next;\n    for (i = 0; i < nb_args; i++) {\n        int nregs, byref = 0, tempofs;\n        int prc[3], fieldofs[3];\n        sv = &vtop[1 + i - nb_args];\n        sv->type.t &= ~VT_ARRAY; // XXX this should be done in tccgen.c\n        size = type_size(&sv->type, &align);\n        if (size > 16) {\n            if (align < XLEN)\n              align = XLEN;\n            tempspace = (tempspace + align - 1) & -align;\n            tempofs = tempspace;\n            tempspace += size;\n            size = align = 8;\n            byref = 64 | (tempofs << 7);\n        }\n        reg_pass(&sv->type, prc, fieldofs, sa != 0);\n        if (!sa && align == 2*XLEN && size <= 2*XLEN)\n          areg[0] = (areg[0] + 1) & ~1;\n        nregs = prc[0];\n        if (size == 0)\n            info[i] = 0;\n        else if ((prc[1] == RC_INT && areg[0] >= 8)\n            || (prc[1] == RC_FLOAT && areg[1] >= 16)\n            || (nregs == 2 && prc[1] == RC_FLOAT && prc[2] == RC_FLOAT\n                && areg[1] >= 15)\n            || (nregs == 2 && prc[1] != prc[2]\n                && (areg[1] >= 16 || areg[0] >= 8))) {\n            info[i] = 32;\n            if (align < XLEN)\n              align = XLEN;\n            stack_adj += (size + align - 1) & -align;\n            if (!sa) /* one vararg on stack forces the rest on stack */\n              areg[0] = 8, areg[1] = 16;\n        } else {\n            info[i] = areg[prc[1] - 1]++;\n            if (!byref)\n              info[i] |= (fieldofs[1] & VT_BTYPE) << 12;\n            assert(!(fieldofs[1] >> 4));\n            if (nregs == 2) {\n                if (prc[2] == RC_FLOAT || areg[0] < 8)\n                  info[i] |= (1 + areg[prc[2] - 1]++) << 7;\n                else {\n                    info[i] |= 16;\n                    stack_adj += 8;\n                }\n                if (!byref) {\n                    assert((fieldofs[2] >> 4) < 2048);\n                    info[i] |= fieldofs[2] << (12 + 4); // includes offset\n                }\n            }\n        }\n        info[i] |= byref;\n        if (sa)\n          sa = sa->next;\n    }\n    stack_adj = (stack_adj + 15) & -16;\n    tempspace = (tempspace + 15) & -16;\n    stack_add = stack_adj + tempspace;\n\n    /* fetch cpu flag before generating any code */\n    if ((vtop->r & VT_VALMASK) == VT_CMP)\n      gv(RC_INT);\n\n\n    if (stack_add) {\n        if (stack_add >= 0x800) {\n            unsigned int bit11 = (((unsigned int)-stack_add) >> 11) & 1;\n            o(0x37 | (5 << 7) |\n              ((-stack_add + (bit11 << 12)) & 0xfffff000)); //lui t0, upper(v)\n            EI(0x13, 0, 5, 5, ((-stack_add & 0xfff) - bit11 * (1 << 12)));\n                                                         // addi t0, t0, lo(v)\n            ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0\n        }\n        else\n            EI(0x13, 0, 2, 2, -stack_add);   // addi sp, sp, -adj\n        for (i = ofs = 0; i < nb_args; i++) {\n            if (info[i] & (64 | 32)) {\n                vrotb(nb_args - i);\n                size = type_size(&vtop->type, &align);\n                if (info[i] & 64) {\n                    vset(&char_pointer_type, TREG_SP, 0);\n                    vpushi(stack_adj + (info[i] >> 7));\n                    gen_op('+');\n                    vpushv(vtop); // this replaces the old argument\n                    vrott(3);\n                    indir();\n                    vtop->type = vtop[-1].type;\n                    vswap();\n                    vstore();\n                    vpop();\n                    size = align = 8;\n                }\n                if (info[i] & 32) {\n                    if (align < XLEN)\n                      align = XLEN;\n                    /* Once we support offseted regs we can do this:\n                       vset(&vtop->type, TREG_SP | VT_LVAL, ofs);\n                       to construct the lvalue for the outgoing stack slot,\n                       until then we have to jump through hoops.  */\n                    vset(&char_pointer_type, TREG_SP, 0);\n                    ofs = (ofs + align - 1) & -align;\n                    vpushi(ofs);\n                    gen_op('+');\n                    indir();\n                    vtop->type = vtop[-1].type;\n                    vswap();\n                    vstore();\n                    vtop->r = vtop->r2 = VT_CONST; // this arg is done\n                    ofs += size;\n                }\n                vrott(nb_args - i);\n            } else if (info[i] & 16) {\n                assert(!splitofs);\n                splitofs = ofs;\n                ofs += 8;\n            }\n        }\n    }\n    for (i = 0; i < nb_args; i++) {\n        int ii = info[nb_args - 1 - i], r = ii, r2 = r;\n        if (!(r & 32)) {\n            CType origtype;\n            int loadt;\n            r &= 15;\n            r2 = r2 & 64 ? 0 : (r2 >> 7) & 31;\n            assert(r2 <= 16);\n            vrotb(i+1);\n            origtype = vtop->type;\n            size = type_size(&vtop->type, &align);\n            if (size == 0)\n                goto done;\n            loadt = vtop->type.t & VT_BTYPE;\n            if (loadt == VT_STRUCT) {\n                loadt = (ii >> 12) & VT_BTYPE;\n            }\n            if (info[nb_args - 1 - i] & 16) {\n                assert(!r2);\n                r2 = 1 + TREG_RA;\n            }\n            if (loadt == VT_LDOUBLE) {\n                assert(r2);\n                r2--;\n            } else if (r2) {\n                test_lvalue();\n                vpushv(vtop);\n            }\n            vtop->type.t = loadt | (vtop->type.t & VT_UNSIGNED);\n            gv(r < 8 ? RC_R(r) : RC_F(r - 8));\n            vtop->type = origtype;\n\n            if (r2 && loadt != VT_LDOUBLE) {\n                r2--;\n                assert(r2 < 16 || r2 == TREG_RA);\n                vswap();\n                gaddrof();\n                vtop->type = char_pointer_type;\n                vpushi(ii >> 20);\n#ifdef CONFIG_TCC_BCHECK\n\t\tif ((origtype.t & VT_BTYPE) == VT_STRUCT)\n                    tcc_state->do_bounds_check = 0;\n#endif\n                gen_op('+');\n#ifdef CONFIG_TCC_BCHECK\n\t\ttcc_state->do_bounds_check = bc_save;\n#endif\n                indir();\n                vtop->type = origtype;\n                loadt = vtop->type.t & VT_BTYPE;\n                if (loadt == VT_STRUCT) {\n                    loadt = (ii >> 16) & VT_BTYPE;\n                }\n                save_reg_upstack(r2, 1);\n                vtop->type.t = loadt | (vtop->type.t & VT_UNSIGNED);\n                load(r2, vtop);\n                assert(r2 < VT_CONST);\n                vtop--;\n                vtop->r2 = r2;\n            }\n            if (info[nb_args - 1 - i] & 16) {\n                ES(0x23, 3, 2, ireg(vtop->r2), splitofs); // sd t0, ofs(sp)\n                vtop->r2 = VT_CONST;\n            } else if (loadt == VT_LDOUBLE && vtop->r2 != r2) {\n                assert(vtop->r2 <= 7 && r2 <= 7);\n                /* XXX we'd like to have 'gv' move directly into\n                   the right class instead of us fixing it up.  */\n                EI(0x13, 0, ireg(r2), ireg(vtop->r2), 0); // mv Ra+1, RR2\n                vtop->r2 = r2;\n            }\ndone:\n            vrott(i+1);\n        }\n    }\n    vrotb(nb_args + 1);\n    save_regs(nb_args + 1);\n    gcall_or_jmp(1);\n    vtop -= nb_args + 1;\n    if (stack_add) {\n        if (stack_add >= 0x800) {\n            unsigned int bit11 = ((unsigned int)stack_add >> 11) & 1;\n            o(0x37 | (5 << 7) |\n              ((stack_add + (bit11 << 12)) & 0xfffff000)); //lui t0, upper(v)\n            EI(0x13, 0, 5, 5, (stack_add & 0xfff) - bit11 * (1 << 12));\n                                                           // addi t0, t0, lo(v)\n            ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0\n        }\n        else\n            EI(0x13, 0, 2, 2, stack_add);      // addi sp, sp, adj\n   }\n   tcc_free(info);\n}\n\nstatic int func_sub_sp_offset, num_va_regs, func_va_list_ofs;\n\nST_FUNC void gfunc_prolog(Sym *func_sym)\n{\n    CType *func_type = &func_sym->type;\n    int i, addr, align, size;\n    int param_addr = 0;\n    int areg[2];\n    Sym *sym;\n    CType *type;\n\n    sym = func_type->ref;\n    loc = -16; // for ra and s0\n    func_sub_sp_offset = ind;\n    ind += 5 * 4;\n\n    areg[0] = 0, areg[1] = 0;\n    addr = 0;\n    /* if the function returns by reference, then add an\n       implicit pointer parameter */\n    size = type_size(&func_vt, &align);\n    if (size > 2 * XLEN) {\n        loc -= 8;\n        func_vc = loc;\n        ES(0x23, 3, 8, 10 + areg[0]++, loc); // sd a0, loc(s0)\n    }\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n        int byref = 0;\n        int regcount;\n        int prc[3], fieldofs[3];\n        type = &sym->type;\n        size = type_size(type, &align);\n        if (size > 2 * XLEN) {\n            type = &char_pointer_type;\n            size = align = byref = 8;\n        }\n        reg_pass(type, prc, fieldofs, 1);\n        regcount = prc[0];\n        if (areg[prc[1] - 1] >= 8\n            || (regcount == 2\n                && ((prc[1] == RC_FLOAT && prc[2] == RC_FLOAT && areg[1] >= 7)\n                    || (prc[1] != prc[2] && (areg[1] >= 8 || areg[0] >= 8))))) {\n            if (align < XLEN)\n              align = XLEN;\n            addr = (addr + align - 1) & -align;\n            param_addr = addr;\n            addr += size;\n        } else {\n            loc -= regcount * 8; // XXX could reserve only 'size' bytes\n            param_addr = loc;\n            for (i = 0; i < regcount; i++) {\n                if (areg[prc[1+i] - 1] >= 8) {\n                    assert(i == 1 && regcount == 2 && !(addr & 7));\n                    EI(0x03, 3, 5, 8, addr); // ld t0, addr(s0)\n                    addr += 8;\n                    ES(0x23, 3, 8, 5, loc + i*8); // sd t0, loc(s0)\n                } else if (prc[1+i] == RC_FLOAT) {\n                    ES(0x27, (size / regcount) == 4 ? 2 : 3, 8, 10 + areg[1]++, loc + (fieldofs[i+1] >> 4)); // fs[wd] FAi, loc(s0)\n                } else {\n                    ES(0x23, 3, 8, 10 + areg[0]++, loc + i*8); // sd aX, loc(s0) // XXX\n                }\n            }\n        }\n        sym_push(sym->v & ~SYM_FIELD, &sym->type,\n                 (byref ? VT_LLOCAL : VT_LOCAL) | VT_LVAL,\n                 param_addr);\n    }\n    func_va_list_ofs = addr;\n    num_va_regs = 0;\n    if (func_var) {\n        for (; areg[0] < 8; areg[0]++) {\n            num_va_regs++;\n            ES(0x23, 3, 8, 10 + areg[0], -8 + num_va_regs * 8); // sd aX, loc(s0)\n        }\n    }\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_prolog();\n#endif\n}\n\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret,\n                       int *ret_align, int *regsize)\n{\n    int align, size = type_size(vt, &align), nregs;\n    int prc[3], fieldofs[3];\n    *ret_align = 1;\n    *regsize = 8;\n    if (size > 16)\n      return 0;\n    reg_pass(vt, prc, fieldofs, 1);\n    nregs = prc[0];\n    if (nregs == 2 && prc[1] != prc[2])\n      return -1;  /* generic code can't deal with this case */\n    if (prc[1] == RC_FLOAT) {\n        *regsize = size / nregs;\n    }\n    ret->t = fieldofs[1] & VT_BTYPE;\n    ret->ref = NULL;\n    return nregs;\n}\n\nST_FUNC void arch_transfer_ret_regs(int aftercall)\n{\n    int prc[3], fieldofs[3];\n    reg_pass(&vtop->type, prc, fieldofs, 1);\n    assert(prc[0] == 2 && prc[1] != prc[2] && !(fieldofs[1] >> 4));\n    assert(vtop->r == (VT_LOCAL | VT_LVAL));\n    vpushv(vtop);\n    vtop->type.t = fieldofs[1] & VT_BTYPE;\n    (aftercall ? store : load)(prc[1] == RC_INT ? REG_IRET : REG_FRET, vtop);\n    vtop->c.i += fieldofs[2] >> 4;\n    vtop->type.t = fieldofs[2] & VT_BTYPE;\n    (aftercall ? store : load)(prc[2] == RC_INT ? REG_IRET : REG_FRET, vtop);\n    vtop--;\n}\n\nST_FUNC void gfunc_epilog(void)\n{\n    int v, saved_ind, d, large_ofs_ind;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_epilog();\n#endif\n\n    loc = (loc - num_va_regs * 8);\n    d = v = (-loc + 15) & -16;\n\n    if (v >= (1 << 11)) {\n        d = 16;\n        o(0x37 | (5 << 7) | ((0x800 + (v-16)) & 0xfffff000)); //lui t0, upper(v)\n        EI(0x13, 0, 5, 5, (v-16) << 20 >> 20); // addi t0, t0, lo(v)\n        ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0\n    }\n    EI(0x03, 3, 1, 2, d - 8 - num_va_regs * 8);  // ld ra, v-8(sp)\n    EI(0x03, 3, 8, 2, d - 16 - num_va_regs * 8); // ld s0, v-16(sp)\n    EI(0x13, 0, 2, 2, d);      // addi sp, sp, v\n    EI(0x67, 0, 0, 1, 0);      // jalr x0, 0(x1), aka ret\n    large_ofs_ind = ind;\n    if (v >= (1 << 11)) {\n        EI(0x13, 0, 8, 2, d - num_va_regs * 8);      // addi s0, sp, d\n        o(0x37 | (5 << 7) | ((0x800 + (v-16)) & 0xfffff000)); //lui t0, upper(v)\n        EI(0x13, 0, 5, 5, (v-16) << 20 >> 20); // addi t0, t0, lo(v)\n        ER(0x33, 0, 2, 2, 5, 0x20); // sub sp, sp, t0\n        gjmp_addr(func_sub_sp_offset + 5*4);\n    }\n    saved_ind = ind;\n\n    ind = func_sub_sp_offset;\n    EI(0x13, 0, 2, 2, -d);     // addi sp, sp, -d\n    ES(0x23, 3, 2, 1, d - 8 - num_va_regs * 8);  // sd ra, d-8(sp)\n    ES(0x23, 3, 2, 8, d - 16 - num_va_regs * 8); // sd s0, d-16(sp)\n    if (v < (1 << 11))\n      EI(0x13, 0, 8, 2, d - num_va_regs * 8);      // addi s0, sp, d\n    else\n      gjmp_addr(large_ofs_ind);\n    if ((ind - func_sub_sp_offset) != 5*4)\n      EI(0x13, 0, 0, 0, 0);      // addi x0, x0, 0 == nop\n    ind = saved_ind;\n}\n\nST_FUNC void gen_va_start(void)\n{\n    vtop--;\n    vset(&char_pointer_type, VT_LOCAL, func_va_list_ofs);\n}\n\nST_FUNC void gen_fill_nops(int bytes)\n{\n    if ((bytes & 3))\n      tcc_error(\"alignment of code section not multiple of 4\");\n    while (bytes > 0) {\n        EI(0x13, 0, 0, 0, 0);      // addi x0, x0, 0 == nop\n        bytes -= 4;\n    }\n}\n\n// Generate forward branch to label:\nST_FUNC int gjmp(int t)\n{\n    if (nocode_wanted)\n      return t;\n    o(t);\n    return ind - 4;\n}\n\n// Generate branch to known address:\nST_FUNC void gjmp_addr(int a)\n{\n    uint32_t r = a - ind, imm;\n    if ((r + (1 << 21)) & ~((1U << 22) - 2)) {\n        o(0x17 | (5 << 7) | (((r + 0x800) & 0xfffff000))); // lui RR, up(r)\n        r = (int)r << 20 >> 20;\n        EI(0x67, 0, 0, 5, r);      // jalr x0, r(t0)\n    } else {\n        imm = (((r >> 12) &  0xff) << 12)\n            | (((r >> 11) &     1) << 20)\n            | (((r >>  1) & 0x3ff) << 21)\n            | (((r >> 20) &     1) << 31);\n        o(0x6f | imm); // jal x0, imm ==  j imm\n    }\n}\n\nST_FUNC int gjmp_cond(int op, int t)\n{\n    int tmp;\n    int a = vtop->cmp_r & 0xff;\n    int b = (vtop->cmp_r >> 8) & 0xff;\n    switch (op) {\n        case TOK_ULT: op = 6; break;\n        case TOK_UGE: op = 7; break;\n        case TOK_ULE: op = 7; tmp = a; a = b; b = tmp; break;\n        case TOK_UGT: op = 6; tmp = a; a = b; b = tmp; break;\n        case TOK_LT:  op = 4; break;\n        case TOK_GE:  op = 5; break;\n        case TOK_LE:  op = 5; tmp = a; a = b; b = tmp; break;\n        case TOK_GT:  op = 4; tmp = a; a = b; b = tmp; break;\n        case TOK_NE:  op = 1; break;\n        case TOK_EQ:  op = 0; break;\n    }\n    o(0x63 | (op ^ 1) << 12 | a << 15 | b << 20 | 8 << 7); // bOP a,b,+4\n    return gjmp(t);\n}\n\nST_FUNC int gjmp_append(int n, int t)\n{\n    void *p;\n    /* insert jump list n into t */\n    if (n) {\n        uint32_t n1 = n, n2;\n        while ((n2 = read32le(p = cur_text_section->data + n1)))\n            n1 = n2;\n        write32le(p, t);\n        t = n;\n    }\n    return t;\n}\n\nstatic void gen_opil(int op, int ll)\n{\n    int a, b, d;\n    int func3 = 0;\n    ll = ll ? 0 : 8;\n    if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n        int fc = vtop->c.i;\n        if (fc == vtop->c.i && !(((unsigned)fc + (1 << 11)) >> 12)) {\n            int cll = 0;\n            int m = ll ? 31 : 63;\n            vswap();\n            gv(RC_INT);\n            a = ireg(vtop[0].r);\n            --vtop;\n            d = get_reg(RC_INT);\n            ++vtop;\n            vswap();\n            switch (op) {\n                case '-':\n                    if (fc <= -(1 << 11))\n                      break;\n                    fc = -fc;\n                case '+':\n                    func3 = 0; // addi d, a, fc\n                    cll = ll;\n                do_cop:\n                    EI(0x13 | cll, func3, ireg(d), a, fc);\n                    --vtop;\n                    if (op >= TOK_ULT && op <= TOK_GT) {\n                      vset_VT_CMP(TOK_NE);\n                      vtop->cmp_r = ireg(d) | 0 << 8;\n                    } else\n                      vtop[0].r = d;\n                    return;\n                case TOK_LE:\n                    if (fc >= (1 << 11) - 1)\n                      break;\n                    ++fc;\n                case TOK_LT:  func3 = 2; goto do_cop; // slti d, a, fc\n                case TOK_ULE:\n                    if (fc >= (1 << 11) - 1 || fc == -1)\n                      break;\n                    ++fc;\n                case TOK_ULT: func3 = 3; goto do_cop; // sltiu d, a, fc\n                case '^':     func3 = 4; goto do_cop; // xori d, a, fc\n                case '|':     func3 = 6; goto do_cop; // ori  d, a, fc\n                case '&':     func3 = 7; goto do_cop; // andi d, a, fc\n                case TOK_SHL: func3 = 1; cll = ll; fc &= m; goto do_cop; // slli d, a, fc\n                case TOK_SHR: func3 = 5; cll = ll; fc &= m; goto do_cop; // srli d, a, fc\n                case TOK_SAR: func3 = 5; cll = ll; fc = 1024 | (fc & m); goto do_cop;\n\n                case TOK_UGE: /* -> TOK_ULT */\n                case TOK_UGT: /* -> TOK_ULE */\n                case TOK_GE:  /* -> TOK_LT */\n                case TOK_GT:  /* -> TOK_LE */\n                    gen_opil(op - 1, !ll);\n                    vtop->cmp_op ^= 1;\n                    return;\n\n                case TOK_NE:\n                case TOK_EQ:\n                    if (fc)\n                      gen_opil('-', !ll), a = ireg(vtop++->r);\n                    --vtop;\n                    vset_VT_CMP(op);\n                    vtop->cmp_r = a | 0 << 8;\n                    return;\n            }\n        }\n    }\n    gv2(RC_INT, RC_INT);\n    a = ireg(vtop[-1].r);\n    b = ireg(vtop[0].r);\n    vtop -= 2;\n    d = get_reg(RC_INT);\n    vtop++;\n    vtop[0].r = d;\n    d = ireg(d);\n    switch (op) {\n    default:\n        if (op >= TOK_ULT && op <= TOK_GT) {\n            vset_VT_CMP(op);\n            vtop->cmp_r = a | b << 8;\n            break;\n        }\n        tcc_error(\"implement me: %s(%s)\", __FUNCTION__, get_tok_str(op, NULL));\n        break;\n\n    case '+':\n        ER(0x33 | ll, 0, d, a, b, 0); // add d, a, b\n        break;\n    case '-':\n        ER(0x33 | ll, 0, d, a, b, 0x20); // sub d, a, b\n        break;\n    case TOK_SAR:\n        ER(0x33 | ll | ll, 5, d, a, b, 0x20); // sra d, a, b\n        break;\n    case TOK_SHR:\n        ER(0x33 | ll | ll, 5, d, a, b, 0); // srl d, a, b\n        break;\n    case TOK_SHL:\n        ER(0x33 | ll, 1, d, a, b, 0); // sll d, a, b\n        break;\n    case '*':\n        ER(0x33 | ll, 0, d, a, b, 1); // mul d, a, b\n        break;\n    case '/':\n        ER(0x33 | ll, 4, d, a, b, 1); // div d, a, b\n        break;\n    case '&':\n        ER(0x33, 7, d, a, b, 0); // and d, a, b\n        break;\n    case '^':\n        ER(0x33, 4, d, a, b, 0); // xor d, a, b\n        break;\n    case '|':\n        ER(0x33, 6, d, a, b, 0); // or d, a, b\n        break;\n    case '%':\n        ER(ll ? 0x3b:  0x33, 6, d, a, b, 1); // rem d, a, b\n        break;\n    case TOK_UMOD:\n        ER(0x33 | ll, 7, d, a, b, 1); // remu d, a, b\n        break;\n    case TOK_PDIV:\n    case TOK_UDIV:\n        ER(0x33 | ll, 5, d, a, b, 1); // divu d, a, b\n        break;\n    }\n}\n\nST_FUNC void gen_opi(int op)\n{\n    gen_opil(op, 0);\n}\n\nST_FUNC void gen_opl(int op)\n{\n    gen_opil(op, 1);\n}\n\nST_FUNC void gen_opf(int op)\n{\n    int rs1, rs2, rd, dbl, invert;\n    if (vtop[0].type.t == VT_LDOUBLE) {\n        CType type = vtop[0].type;\n        int func = 0;\n        int cond = -1;\n        switch (op) {\n        case '*': func = TOK___multf3; break;\n        case '+': func = TOK___addtf3; break;\n        case '-': func = TOK___subtf3; break;\n        case '/': func = TOK___divtf3; break;\n        case TOK_EQ: func = TOK___eqtf2; cond = 1; break;\n        case TOK_NE: func = TOK___netf2; cond = 0; break;\n        case TOK_LT: func = TOK___lttf2; cond = 10; break;\n        case TOK_GE: func = TOK___getf2; cond = 11; break;\n        case TOK_LE: func = TOK___letf2; cond = 12; break;\n        case TOK_GT: func = TOK___gttf2; cond = 13; break;\n        default: assert(0); break;\n        }\n        vpush_helper_func(func);\n        vrott(3);\n        gfunc_call(2);\n        vpushi(0);\n        vtop->r = REG_IRET;\n        vtop->r2 = cond < 0 ? TREG_R(1) : VT_CONST;\n        if (cond < 0)\n            vtop->type = type;\n        else {\n            vpushi(0);\n            gen_opil(op, 1);\n        }\n        return;\n    }\n\n    gv2(RC_FLOAT, RC_FLOAT);\n    assert(vtop->type.t == VT_DOUBLE || vtop->type.t == VT_FLOAT);\n    dbl = vtop->type.t == VT_DOUBLE;\n    rs1 = freg(vtop[-1].r);\n    rs2 = freg(vtop->r);\n    vtop--;\n    invert = 0;\n    switch(op) {\n    default:\n        assert(0);\n    case '+':\n        op = 0; // fadd\n    arithop:\n        rd = get_reg(RC_FLOAT);\n        vtop->r = rd;\n        rd = freg(rd);\n        ER(0x53, 7, rd, rs1, rs2, dbl | (op << 2)); // fop.[sd] RD, RS1, RS2 (dyn rm)\n        break;\n    case '-':\n        op = 1; // fsub\n        goto arithop;\n    case '*':\n        op = 2; // fmul\n        goto arithop;\n    case '/':\n        op = 3; // fdiv\n        goto arithop;\n    case TOK_EQ:\n        op = 2; // EQ\n    cmpop:\n        rd = get_reg(RC_INT);\n        vtop->r = rd;\n        rd = ireg(rd);\n        ER(0x53, op, rd, rs1, rs2, dbl | 0x50); // fcmp.[sd] RD, RS1, RS2 (op == eq/lt/le)\n        if (invert)\n          EI(0x13, 4, rd, rd, 1); // xori RD, 1\n        break;\n    case TOK_NE:\n        invert = 1;\n        op = 2; // EQ\n        goto cmpop;\n    case TOK_LT:\n        op = 1; // LT\n        goto cmpop;\n    case TOK_LE:\n        op = 0; // LE\n        goto cmpop;\n    case TOK_GT:\n        op = 1; // LT\n        rd = rs1, rs1 = rs2, rs2 = rd;\n        goto cmpop;\n    case TOK_GE:\n        op = 0; // LE\n        rd = rs1, rs1 = rs2, rs2 = rd;\n        goto cmpop;\n    }\n}\n\nST_FUNC void gen_cvt_sxtw(void)\n{\n    /* XXX on risc-v the registers are usually sign-extended already.\n       Let's try to not do anything here.  */\n}\n\nST_FUNC void gen_cvt_itof(int t)\n{\n    int rr = ireg(gv(RC_INT)), dr;\n    int u = vtop->type.t & VT_UNSIGNED;\n    int l = (vtop->type.t & VT_BTYPE) == VT_LLONG;\n    if (t == VT_LDOUBLE) {\n        int func = l ?\n          (u ? TOK___floatunditf : TOK___floatditf) :\n          (u ? TOK___floatunsitf : TOK___floatsitf);\n        vpush_helper_func(func);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->type.t = t;\n        vtop->r = REG_IRET;\n        vtop->r2 = TREG_R(1);\n    } else {\n        vtop--;\n        dr = get_reg(RC_FLOAT);\n        vtop++;\n        vtop->r = dr;\n        dr = freg(dr);\n        EIu(0x53, 7, dr, rr, ((0x68 | (t == VT_DOUBLE ? 1 : 0)) << 5) | (u ? 1 : 0) | (l ? 2 : 0)); // fcvt.[sd].[wl][u]\n    }\n}\n\nST_FUNC void gen_cvt_ftoi(int t)\n{\n    int ft = vtop->type.t & VT_BTYPE;\n    int l = (t & VT_BTYPE) == VT_LLONG;\n    int u = t & VT_UNSIGNED;\n    if (ft == VT_LDOUBLE) {\n        int func = l ?\n          (u ? TOK___fixunstfdi : TOK___fixtfdi) :\n          (u ? TOK___fixunstfsi : TOK___fixtfsi);\n        vpush_helper_func(func);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->type.t = t;\n        vtop->r = REG_IRET;\n    } else {\n        int rr = freg(gv(RC_FLOAT)), dr;\n        vtop--;\n        dr = get_reg(RC_INT);\n        vtop++;\n        vtop->r = dr;\n        dr = ireg(dr);\n        EIu(0x53, 1, dr, rr, ((0x60 | (ft == VT_DOUBLE ? 1 : 0)) << 5) | (u ? 1 : 0) | (l ? 2 : 0)); // fcvt.[wl][u].[sd] rtz\n    }\n}\n\nST_FUNC void gen_cvt_ftof(int dt)\n{\n    int st = vtop->type.t & VT_BTYPE, rs, rd;\n    dt &= VT_BTYPE;\n    if (st == dt)\n      return;\n    if (dt == VT_LDOUBLE || st == VT_LDOUBLE) {\n        int func = (dt == VT_LDOUBLE) ?\n            (st == VT_FLOAT ? TOK___extendsftf2 : TOK___extenddftf2) :\n            (dt == VT_FLOAT ? TOK___trunctfsf2 : TOK___trunctfdf2);\n        /* We can't use gfunc_call, as func_old_type works like vararg\n           functions, and on riscv unnamed float args are passed like\n           integers.  But we really need them in the float argument registers\n           for extendsftf2/extenddftf2.  So, do it explicitely.  */\n        save_regs(1);\n        if (dt == VT_LDOUBLE)\n          gv(RC_F(0));\n        else {\n            gv(RC_R(0));\n            assert(vtop->r2 < 7);\n            if (vtop->r2 != 1 + vtop->r) {\n                EI(0x13, 0, ireg(vtop->r) + 1, ireg(vtop->r2), 0); // mv Ra+1, RR2\n                vtop->r2 = 1 + vtop->r;\n            }\n        }\n        vpush_helper_func(func);\n        gcall_or_jmp(1);\n        vtop -= 2;\n        vpushi(0);\n        vtop->type.t = dt;\n        if (dt == VT_LDOUBLE)\n          vtop->r = REG_IRET, vtop->r2 = REG_IRET+1;\n        else\n          vtop->r = REG_FRET;\n    } else {\n        assert (dt == VT_FLOAT || dt == VT_DOUBLE);\n        assert (st == VT_FLOAT || st == VT_DOUBLE);\n        rs = gv(RC_FLOAT);\n        rd = get_reg(RC_FLOAT);\n        if (dt == VT_DOUBLE)\n          EI(0x53, 0, freg(rd), freg(rs), 0x21 << 5); // fcvt.d.s RD, RS (no rm)\n        else\n          EI(0x53, 7, freg(rd), freg(rs), (0x20 << 5) | 1); // fcvt.s.d RD, RS (dyn rm)\n        vtop->r = rd;\n    }\n}\n\n/* increment tcov counter */\nST_FUNC void gen_increment_tcov (SValue *sv)\n{\n    int r1, r2;\n    Sym label = {0};\n    label.type.t = VT_VOID | VT_STATIC;\n\n    vpushv(sv);\n    vtop->r = r1 = get_reg(RC_INT);\n    r2 = get_reg(RC_INT);\n    r1 = ireg(r1);\n    r2 = ireg(r2);\n    greloca(cur_text_section, sv->sym, ind, R_RISCV_PCREL_HI20, 0);\n    put_extern_sym(&label, cur_text_section, ind, 0);\n    o(0x17 | (r1 << 7)); // auipc RR, 0 %pcrel_hi(sym)\n    greloca(cur_text_section, &label, ind, R_RISCV_PCREL_LO12_I, 0);\n    EI(0x03, 3, r2, r1, 0); // ld r2, x[r1]\n    EI(0x13, 0, r2, r2, 1); // addi r2, r2, #1\n    greloca(cur_text_section, sv->sym, ind, R_RISCV_PCREL_HI20, 0);\n    label.c = 0; /* force new local ELF symbol */\n    put_extern_sym(&label, cur_text_section, ind, 0);\n    o(0x17 | (r1 << 7)); // auipc RR, 0 %pcrel_hi(sym)\n    greloca(cur_text_section, &label, ind, R_RISCV_PCREL_LO12_S, 0);\n    ES(0x23, 3, r1, r2, 0); // sd r2, [r1]\n    vpop();\n}\n\nST_FUNC void ggoto(void)\n{\n    gcall_or_jmp(0);\n    vtop--;\n}\n\nST_FUNC void gen_vla_sp_save(int addr)\n{\n    if (((unsigned)addr + (1 << 11)) >> 12) {\n\to(0x37 | (5 << 7) | ((0x800 + addr) & 0xfffff000)); //lui t0,upper(addr)\n        ER(0x33, 0, 5, 5, 8, 0); // add t0, t0, s0\n        ES(0x23, 3, 5, 2, (int)addr << 20 >> 20); // sd sp, fc(t0)\n    }\n    else\n        ES(0x23, 3, 8, 2, addr); // sd sp, fc(s0)\n}\n\nST_FUNC void gen_vla_sp_restore(int addr)\n{\n    if (((unsigned)addr + (1 << 11)) >> 12) {\n\to(0x37 | (5 << 7) | ((0x800 + addr) & 0xfffff000)); //lui t0,upper(addr)\n        ER(0x33, 0, 5, 5, 8, 0); // add t0, t0, s0\n        EI(0x03, 3, 2, 5, (int)addr << 20 >> 20); // ld sp, fc(t0)\n    }\n    else\n        EI(0x03, 3, 2, 8, addr); // ld sp, fc(s0)\n}\n\nST_FUNC void gen_vla_alloc(CType *type, int align)\n{\n    int rr;\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check)\n        vpushv(vtop);\n#endif\n    rr = ireg(gv(RC_INT));\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check)\n        EI(0x13, 0, rr, rr, 15+1);   // addi RR, RR, 15+1\n    else\n#endif\n    EI(0x13, 0, rr, rr, 15);   // addi RR, RR, 15\n    EI(0x13, 7, rr, rr, -16);  // andi, RR, RR, -16\n    ER(0x33, 0, 2, 2, rr, 0x20); // sub sp, sp, rr\n    vpop();\n#if defined(CONFIG_TCC_BCHECK)\n    if (tcc_state->do_bounds_check) {\n        vpushi(0);\n        vtop->r = TREG_R(0);\n        o(0x00010513); /* mv a0,sp */\n        vswap();\n        vpush_helper_func(TOK___bound_new_region);\n        vrott(3);\n        gfunc_call(2);\n        func_bound_add_epilog = 1;\n    }\n#endif\n}\n#endif\n"
        },
        {
          "name": "riscv64-link.c",
          "type": "blob",
          "size": 12.349609375,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n#define EM_TCC_TARGET EM_RISCV\n\n#define R_DATA_32  R_RISCV_32\n#define R_DATA_PTR R_RISCV_64\n#define R_JMP_SLOT R_RISCV_JUMP_SLOT\n#define R_GLOB_DAT R_RISCV_64\n#define R_COPY     R_RISCV_COPY\n#define R_RELATIVE R_RISCV_RELATIVE\n\n#define R_NUM      R_RISCV_NUM\n\n#define ELF_START_ADDR 0x00010000\n#define ELF_PAGE_SIZE 0x1000\n\n#define PCRELATIVE_DLLPLT 1\n#define RELOCATE_DLLPLT 1\n\n#else /* !TARGET_DEFS_ONLY */\n\n//#define DEBUG_RELOC\n#include \"tcc.h\"\n\n/* Returns 1 for a code relocation, 0 for a data relocation. For unknown\n   relocations, returns -1. */\nST_FUNC int code_reloc (int reloc_type)\n{\n    switch (reloc_type) {\n\n    case R_RISCV_BRANCH:\n    case R_RISCV_CALL:\n    case R_RISCV_JAL:\n        return 1;\n\n    case R_RISCV_GOT_HI20:\n    case R_RISCV_PCREL_HI20:\n    case R_RISCV_PCREL_LO12_I:\n    case R_RISCV_PCREL_LO12_S:\n    case R_RISCV_32_PCREL:\n    case R_RISCV_SET6:\n    case R_RISCV_SET8:\n    case R_RISCV_SET16:\n    case R_RISCV_SUB6:\n    case R_RISCV_ADD16:\n    case R_RISCV_ADD32:\n    case R_RISCV_ADD64:\n    case R_RISCV_SUB8:\n    case R_RISCV_SUB16:\n    case R_RISCV_SUB32:\n    case R_RISCV_SUB64:\n    case R_RISCV_32:\n    case R_RISCV_64:\n        return 0;\n\n    case R_RISCV_CALL_PLT:\n        return 1;\n    }\n    return -1;\n}\n\n/* Returns an enumerator to describe whether and when the relocation needs a\n   GOT and/or PLT entry to be created. See tcc.h for a description of the\n   different values. */\nST_FUNC int gotplt_entry_type (int reloc_type)\n{\n    switch (reloc_type) {\n    case R_RISCV_ALIGN:\n    case R_RISCV_RELAX:\n    case R_RISCV_RVC_BRANCH:\n    case R_RISCV_RVC_JUMP:\n    case R_RISCV_JUMP_SLOT:\n    case R_RISCV_SET6:\n    case R_RISCV_SET8:\n    case R_RISCV_SET16:\n    case R_RISCV_SUB6:\n    case R_RISCV_ADD16:\n    case R_RISCV_SUB8:\n    case R_RISCV_SUB16:\n        return NO_GOTPLT_ENTRY;\n\n    case R_RISCV_BRANCH:\n    case R_RISCV_CALL:\n    case R_RISCV_PCREL_HI20:\n    case R_RISCV_PCREL_LO12_I:\n    case R_RISCV_PCREL_LO12_S:\n    case R_RISCV_32_PCREL:\n    case R_RISCV_ADD32:\n    case R_RISCV_ADD64:\n    case R_RISCV_SUB32:\n    case R_RISCV_SUB64:\n    case R_RISCV_32:\n    case R_RISCV_64:\n    case R_RISCV_JAL:\n    case R_RISCV_CALL_PLT:\n        return AUTO_GOTPLT_ENTRY;\n\n    case R_RISCV_GOT_HI20:\n        return ALWAYS_GOTPLT_ENTRY;\n    }\n    return -1;\n}\n\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)\n{\n    Section *plt = s1->plt;\n    uint8_t *p;\n    unsigned plt_offset;\n\n    if (plt->data_offset == 0)\n        section_ptr_add(plt, 32);\n    plt_offset = plt->data_offset;\n\n    p = section_ptr_add(plt, 16);\n    write64le(p, got_offset);\n    return plt_offset;\n}\n\n/* relocate the PLT: compute addresses and offsets in the PLT now that final\n   address for PLT and GOT are known (see fill_program_header) */\nST_FUNC void relocate_plt(TCCState *s1)\n{\n    uint8_t *p, *p_end;\n\n    if (!s1->plt)\n      return;\n\n    p = s1->plt->data;\n    p_end = p + s1->plt->data_offset;\n\n    if (p < p_end) {\n        uint64_t plt = s1->plt->sh_addr;\n        uint64_t got = s1->got->sh_addr;\n        uint64_t off = (got - plt + 0x800) >> 12;\n        if ((off + ((uint32_t)1 << 20)) >> 21)\n            tcc_error_noabort(\"Failed relocating PLT (off=0x%lx, got=0x%lx, plt=0x%lx)\", (long)off, (long)got, (long)plt);\n        write32le(p, 0x397 | (off << 12)); // auipc t2, %pcrel_hi(got)\n        write32le(p + 4, 0x41c30333); // sub t1, t1, t3\n        write32le(p + 8, 0x0003be03   // ld t3, %pcrel_lo(got)(t2)\n                         | (((got - plt) & 0xfff) << 20));\n        write32le(p + 12, 0xfd430313); // addi t1, t1, -(32+12)\n        write32le(p + 16, 0x00038293   // addi t0, t2, %pcrel_lo(got)\n                          | (((got - plt) & 0xfff) << 20));\n        write32le(p + 20, 0x00135313); // srli t1, t1, log2(16/PTRSIZE)\n        write32le(p + 24, 0x0082b283); // ld t0, PTRSIZE(t0)\n        write32le(p + 28, 0x000e0067); // jr t3\n        p += 32;\n        while (p < p_end) {\n            uint64_t pc = plt + (p - s1->plt->data);\n            uint64_t addr = got + read64le(p);\n            uint64_t off = (addr - pc + 0x800) >> 12;\n            if ((off + ((uint32_t)1 << 20)) >> 21)\n                tcc_error_noabort(\"Failed relocating PLT (off=0x%lx, addr=0x%lx, pc=0x%lx)\", (long)off, (long)addr, (long)pc);\n            write32le(p, 0xe17 | (off << 12)); // auipc t3, %pcrel_hi(func@got)\n            write32le(p + 4, 0x000e3e03 // ld t3, %pcrel_lo(func@got)(t3)\n                             | (((addr - pc) & 0xfff) << 20));\n            write32le(p + 8, 0x000e0367); // jalr t1, t3\n            write32le(p + 12, 0x00000013); // nop\n            p += 16;\n        }\n    }\n\n    if (s1->plt->reloc) {\n        ElfW_Rel *rel;\n        p = s1->got->data;\n        for_each_elem(s1->plt->reloc, 0, rel, ElfW_Rel) {\n            write64le(p + rel->r_offset, s1->plt->sh_addr);\n\t}\n    }\n}\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr,\n              addr_t addr, addr_t val)\n{\n    uint64_t off64;\n    uint32_t off32;\n    int sym_index = ELFW(R_SYM)(rel->r_info), esym_index;\n    ElfW(Sym) *sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\n    switch(type) {\n    case R_RISCV_ALIGN:\n    case R_RISCV_RELAX:\n        return;\n\n    case R_RISCV_BRANCH:\n        off64 = val - addr;\n        if ((off64 + (1 << 12)) & ~(uint64_t)0x1ffe)\n          tcc_error_noabort(\"R_RISCV_BRANCH relocation failed\"\n                    \" (val=%lx, addr=%lx)\", (long)val, (long)addr);\n        off32 = off64 >> 1;\n        write32le(ptr, (read32le(ptr) & ~0xfe000f80)\n                       | ((off32 & 0x800) << 20)\n                       | ((off32 & 0x3f0) << 21)\n                       | ((off32 & 0x00f) << 8)\n                       | ((off32 & 0x400) >> 3));\n        return;\n    case R_RISCV_JAL:\n        off64 = val - addr;\n        if ((off64 + (1 << 21)) & ~(((uint64_t)1 << 22) - 2))\n          tcc_error_noabort(\"R_RISCV_JAL relocation failed\"\n                    \" (val=%lx, addr=%lx)\", (long)val, (long)addr);\n        off32 = off64;\n        write32le(ptr, (read32le(ptr) & 0xfff)\n                       | (((off32 >> 12) &  0xff) << 12)\n                       | (((off32 >> 11) &     1) << 20)\n                       | (((off32 >>  1) & 0x3ff) << 21)\n                       | (((off32 >> 20) &     1) << 31));\n        return;\n    case R_RISCV_CALL:\n    case R_RISCV_CALL_PLT:\n        write32le(ptr, (read32le(ptr) & 0xfff)\n                       | ((val - addr + 0x800) & ~0xfff));\n        write32le(ptr + 4, (read32le(ptr + 4) & 0xfffff)\n                           | (((val - addr) & 0xfff) << 20));\n        return;\n    case R_RISCV_PCREL_HI20:\n#ifdef DEBUG_RELOC\n        printf(\"PCREL_HI20: val=%lx addr=%lx\\n\", (long)val, (long)addr);\n#endif\n        off64 = (int64_t)(val - addr + 0x800) >> 12;\n        if ((off64 + ((uint64_t)1 << 20)) >> 21)\n          tcc_error_noabort(\"R_RISCV_PCREL_HI20 relocation failed: off=%lx cond=%lx sym=%s\",\n                    (long)off64, (long)((int64_t)(off64 + ((uint64_t)1 << 20)) >> 21),\n                    symtab_section->link->data + sym->st_name);\n        write32le(ptr, (read32le(ptr) & 0xfff)\n                       | ((off64 & 0xfffff) << 12));\n        last_hi.addr = addr;\n        last_hi.val = val;\n        return;\n    case R_RISCV_GOT_HI20:\n        val = s1->got->sh_addr + get_sym_attr(s1, sym_index, 0)->got_offset;\n        off64 = (int64_t)(val - addr + 0x800) >> 12;\n        if ((off64 + ((uint64_t)1 << 20)) >> 21)\n          tcc_error_noabort(\"R_RISCV_GOT_HI20 relocation failed\");\n        last_hi.addr = addr;\n        last_hi.val = val;\n        write32le(ptr, (read32le(ptr) & 0xfff)\n                       | ((off64 & 0xfffff) << 12));\n        return;\n    case R_RISCV_PCREL_LO12_I:\n#ifdef DEBUG_RELOC\n        printf(\"PCREL_LO12_I: val=%lx addr=%lx\\n\", (long)val, (long)addr);\n#endif\n        if (val != last_hi.addr)\n          tcc_error_noabort(\"unsupported hi/lo pcrel reloc scheme\");\n        val = last_hi.val;\n        addr = last_hi.addr;\n        write32le(ptr, (read32le(ptr) & 0xfffff)\n                       | (((val - addr) & 0xfff) << 20));\n        return;\n    case R_RISCV_PCREL_LO12_S:\n        if (val != last_hi.addr)\n          tcc_error_noabort(\"unsupported hi/lo pcrel reloc scheme\");\n        val = last_hi.val;\n        addr = last_hi.addr;\n        off32 = val - addr;\n        write32le(ptr, (read32le(ptr) & ~0xfe000f80)\n                       | ((off32 & 0xfe0) << 20)\n                       | ((off32 & 0x01f) << 7));\n        return;\n\n    case R_RISCV_RVC_BRANCH:\n        off64 = (val - addr);\n        if ((off64 + (1 << 8)) & ~(uint64_t)0x1fe)\n          tcc_error_noabort(\"R_RISCV_RVC_BRANCH relocation failed\"\n                    \" (val=%lx, addr=%lx)\", (long)val, (long)addr);\n        off32 = off64;\n        write16le(ptr, (read16le(ptr) & 0xe383)\n                       | (((off32 >> 5) & 1) << 2)\n                       | (((off32 >> 1) & 3) << 3)\n                       | (((off32 >> 6) & 3) << 5)\n                       | (((off32 >> 3) & 3) << 10)\n                       | (((off32 >> 8) & 1) << 12));\n        return;\n    case R_RISCV_RVC_JUMP:\n        off64 = (val - addr);\n        if ((off64 + (1 << 11)) & ~(uint64_t)0xffe)\n          tcc_error_noabort(\"R_RISCV_RVC_BRANCH relocation failed\"\n                    \" (val=%lx, addr=%lx)\", (long)val, (long)addr);\n        off32 = off64;\n        write16le(ptr, (read16le(ptr) & 0xe003)\n                       | (((off32 >>  5) & 1) << 2)\n                       | (((off32 >>  1) & 7) << 3)\n                       | (((off32 >>  7) & 1) << 6)\n                       | (((off32 >>  6) & 1) << 7)\n                       | (((off32 >> 10) & 1) << 8)\n                       | (((off32 >>  8) & 3) << 9)\n                       | (((off32 >>  4) & 1) << 11)\n                       | (((off32 >> 11) & 1) << 12));\n        return;\n\n    case R_RISCV_32:\n        if (s1->output_type & TCC_OUTPUT_DYN) {\n            /* XXX: this logic may depend on TCC's codegen\n               now TCC uses R_RISCV_RELATIVE even for a 64bit pointer */\n            qrel->r_offset = rel->r_offset;\n            qrel->r_info = ELFW(R_INFO)(0, R_RISCV_RELATIVE);\n            /* Use sign extension! */\n            qrel->r_addend = (int)read32le(ptr) + val;\n            qrel++;\n        }\n        add32le(ptr, val);\n        return;\n    case R_RISCV_64:\n        if (s1->output_type & TCC_OUTPUT_DYN) {\n            esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n            qrel->r_offset = rel->r_offset;\n            if (esym_index) {\n                qrel->r_info = ELFW(R_INFO)(esym_index, R_RISCV_64);\n                qrel->r_addend = rel->r_addend;\n                qrel++;\n                break;\n            } else {\n                qrel->r_info = ELFW(R_INFO)(0, R_RISCV_RELATIVE);\n                qrel->r_addend = read64le(ptr) + val;\n                qrel++;\n            }\n        }\n    case R_RISCV_JUMP_SLOT:\n        add64le(ptr, val);\n        return;\n    case R_RISCV_ADD64:\n        write64le(ptr, read64le(ptr) + val);\n        return;\n    case R_RISCV_ADD32:\n        write32le(ptr, read32le(ptr) + val);\n        return;\n    case R_RISCV_SUB64:\n        write64le(ptr, read64le(ptr) - val);\n        return;\n    case R_RISCV_SUB32:\n        write32le(ptr, read32le(ptr) - val);\n        return;\n    case R_RISCV_ADD16:\n        write16le(ptr, read16le(ptr) + val);\n        return;\n    case R_RISCV_SUB8:\n        *ptr -= val;\n        return;\n    case R_RISCV_SUB16:\n        write16le(ptr, read16le(ptr) - val);\n        return;\n    case R_RISCV_SET6:\n        *ptr = (*ptr & ~0x3f) | (val & 0x3f);\n        return;\n    case R_RISCV_SET8:\n        *ptr = (*ptr & ~0xff) | (val & 0xff);\n        return;\n    case R_RISCV_SET16:\n        *ptr = (*ptr & ~0xffff) | (val & 0xffff);\n        return;\n    case R_RISCV_SUB6:\n        *ptr = (*ptr & ~0x3f) | ((*ptr - val) & 0x3f);\n        return;\n    case R_RISCV_32_PCREL:\n        if (s1->output_type & TCC_OUTPUT_DYN) {\n\t    /* DLL relocation */\n\t    esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n\t    if (esym_index) {\n                qrel->r_offset = rel->r_offset;\n                qrel->r_info = ELFW(R_INFO)(esym_index, R_RISCV_32_PCREL);\n                /* Use sign extension! */\n                qrel->r_addend = (int)read32le(ptr) + rel->r_addend;\n                qrel++;\n\t\tbreak;\n\t    }\n        }\n\tadd32le(ptr, val - addr);\n        return;\n    case R_RISCV_COPY:\n        /* XXX */\n        return;\n\n    default:\n        fprintf(stderr, \"FIXME: handle reloc type %x at %x [%p] to %x\\n\",\n                type, (unsigned)addr, ptr, (unsigned)val);\n        return;\n    }\n}\n#endif\n"
        },
        {
          "name": "riscv64-tok.h",
          "type": "blob",
          "size": 7.984375,
          "content": "/* ------------------------------------------------------------------ */\n/* WARNING: relative order of tokens is important.                    */\n\n/*\n * The specifications are available under https://riscv.org/technical/specifications/\n */\n\n#define DEF_ASM_WITH_SUFFIX(x, y) \\\n  DEF(TOK_ASM_ ## x ## _ ## y, #x \".\" #y)\n\n#define DEF_ASM_WITH_SUFFIXES(x, y, z) \\\n  DEF(TOK_ASM_ ## x ## _ ## y ## _ ## z, #x \".\" #y \".\" #z)\n\n#define DEF_ASM_FENCE(x) \\\n  DEF(TOK_ASM_ ## x ## _fence, #x)\n\n/* register */\n /* integer */\n DEF_ASM(x0)\n DEF_ASM(x1)\n DEF_ASM(x2)\n DEF_ASM(x3)\n DEF_ASM(x4)\n DEF_ASM(x5)\n DEF_ASM(x6)\n DEF_ASM(x7)\n DEF_ASM(x8)\n DEF_ASM(x9)\n DEF_ASM(x10)\n DEF_ASM(x11)\n DEF_ASM(x12)\n DEF_ASM(x13)\n DEF_ASM(x14)\n DEF_ASM(x15)\n DEF_ASM(x16)\n DEF_ASM(x17)\n DEF_ASM(x18)\n DEF_ASM(x19)\n DEF_ASM(x20)\n DEF_ASM(x21)\n DEF_ASM(x22)\n DEF_ASM(x23)\n DEF_ASM(x24)\n DEF_ASM(x25)\n DEF_ASM(x26)\n DEF_ASM(x27)\n DEF_ASM(x28)\n DEF_ASM(x29)\n DEF_ASM(x30)\n DEF_ASM(x31)\n /* float */\n DEF_ASM(f0)\n DEF_ASM(f1)\n DEF_ASM(f2)\n DEF_ASM(f3)\n DEF_ASM(f4)\n DEF_ASM(f5)\n DEF_ASM(f6)\n DEF_ASM(f7)\n DEF_ASM(f8)\n DEF_ASM(f9)\n DEF_ASM(f10)\n DEF_ASM(f11)\n DEF_ASM(f12)\n DEF_ASM(f13)\n DEF_ASM(f14)\n DEF_ASM(f15)\n DEF_ASM(f16)\n DEF_ASM(f17)\n DEF_ASM(f18)\n DEF_ASM(f19)\n DEF_ASM(f20)\n DEF_ASM(f21)\n DEF_ASM(f22)\n DEF_ASM(f23)\n DEF_ASM(f24)\n DEF_ASM(f25)\n DEF_ASM(f26)\n DEF_ASM(f27)\n DEF_ASM(f28)\n DEF_ASM(f29)\n DEF_ASM(f30)\n DEF_ASM(f31)\n\n/* register ABI mnemonics, refer to RISC-V ABI 1.0 */\n /* integer */\n DEF_ASM(zero)\n DEF_ASM(ra)\n DEF_ASM(sp)\n DEF_ASM(gp)\n DEF_ASM(tp)\n DEF_ASM(t0)\n DEF_ASM(t1)\n DEF_ASM(t2)\n DEF_ASM(s0)\n DEF_ASM(s1)\n DEF_ASM(a0)\n DEF_ASM(a1)\n DEF_ASM(a2)\n DEF_ASM(a3)\n DEF_ASM(a4)\n DEF_ASM(a5)\n DEF_ASM(a6)\n DEF_ASM(a7)\n DEF_ASM(s2)\n DEF_ASM(s3)\n DEF_ASM(s4)\n DEF_ASM(s5)\n DEF_ASM(s6)\n DEF_ASM(s7)\n DEF_ASM(s8)\n DEF_ASM(s9)\n DEF_ASM(s10)\n DEF_ASM(s11)\n DEF_ASM(t3)\n DEF_ASM(t4)\n DEF_ASM(t5)\n DEF_ASM(t6)\n /* float */\n DEF_ASM(ft0)\n DEF_ASM(ft1)\n DEF_ASM(ft2)\n DEF_ASM(ft3)\n DEF_ASM(ft4)\n DEF_ASM(ft5)\n DEF_ASM(ft6)\n DEF_ASM(ft7)\n DEF_ASM(fs0)\n DEF_ASM(fs1)\n DEF_ASM(fa0)\n DEF_ASM(fa1)\n DEF_ASM(fa2)\n DEF_ASM(fa3)\n DEF_ASM(fa4)\n DEF_ASM(fa5)\n DEF_ASM(fa6)\n DEF_ASM(fa7)\n DEF_ASM(fs2)\n DEF_ASM(fs3)\n DEF_ASM(fs4)\n DEF_ASM(fs5)\n DEF_ASM(fs6)\n DEF_ASM(fs7)\n DEF_ASM(fs8)\n DEF_ASM(fs9)\n DEF_ASM(fs10)\n DEF_ASM(fs11)\n DEF_ASM(ft8)\n DEF_ASM(ft9)\n DEF_ASM(ft10)\n DEF_ASM(ft11)\n /* not in the ABI */\n DEF_ASM(pc)\n\n/*   Loads */\n\n DEF_ASM(lb)\n DEF_ASM(lh)\n DEF_ASM(lw)\n DEF_ASM(lbu)\n DEF_ASM(lhu)\n /* RV64 */\n DEF_ASM(ld)\n DEF_ASM(lwu)\n\n/* Stores */\n\n DEF_ASM(sb)\n DEF_ASM(sh)\n DEF_ASM(sw)\n /* RV64 */\n DEF_ASM(sd)\n\n/* Shifts */\n\n DEF_ASM(sll)\n DEF_ASM(srl)\n DEF_ASM(sra)\n /* RV64 */\n DEF_ASM(slli)\n DEF_ASM(srli)\n DEF_ASM(sllw)\n DEF_ASM(slliw)\n DEF_ASM(srlw)\n DEF_ASM(srliw)\n DEF_ASM(srai)\n DEF_ASM(sraw)\n DEF_ASM(sraiw)\n\n/* Arithmetic */\n\n DEF_ASM(add)\n DEF_ASM(addi)\n DEF_ASM(sub)\n DEF_ASM(lui)\n DEF_ASM(auipc)\n /* RV64 */\n DEF_ASM(addw)\n DEF_ASM(addiw)\n DEF_ASM(subw)\n\n/* Logical */\n\n DEF_ASM(xor)\n DEF_ASM(xori)\n DEF_ASM(or)\n DEF_ASM(ori)\n DEF_ASM(and)\n DEF_ASM(andi)\n\n/* Compare */\n\n DEF_ASM(slt)\n DEF_ASM(slti)\n DEF_ASM(sltu)\n DEF_ASM(sltiu)\n\n/* Branch */\n\n DEF_ASM(beq)\n DEF_ASM(bne)\n DEF_ASM(blt)\n DEF_ASM(bge)\n DEF_ASM(bltu)\n DEF_ASM(bgeu)\n\n/* Jump */\n\n DEF_ASM(jal)\n DEF_ASM(jalr)\n\n/* Sync */\n\n DEF_ASM(fence)\n /* Zifencei extension */\n DEF_ASM_WITH_SUFFIX(fence, i)\n\n/* System call */\n\n /* used to be called scall and sbreak */\n DEF_ASM(ecall)\n DEF_ASM(ebreak)\n\n/* Counters */\n\n DEF_ASM(rdcycle)\n DEF_ASM(rdcycleh)\n DEF_ASM(rdtime)\n DEF_ASM(rdtimeh)\n DEF_ASM(rdinstret)\n DEF_ASM(rdinstreth)\n\n/* “M” Standard Extension for Integer Multiplication and Division, V2.0 */\n DEF_ASM(mul)\n DEF_ASM(mulh)\n DEF_ASM(mulhsu)\n DEF_ASM(mulhu)\n DEF_ASM(div)\n DEF_ASM(divu)\n DEF_ASM(rem)\n DEF_ASM(remu)\n /* RV64 */\n DEF_ASM(mulw)\n DEF_ASM(divw)\n DEF_ASM(divuw)\n DEF_ASM(remw)\n DEF_ASM(remuw)\n\n/* \"C\" Extension for Compressed Instructions, V2.0 */\n DEF_ASM_WITH_SUFFIX(c, nop)\n/* Loads */\n DEF_ASM_WITH_SUFFIX(c, li)\n DEF_ASM_WITH_SUFFIX(c, lw)\n DEF_ASM_WITH_SUFFIX(c, lwsp)\n /* single float */\n DEF_ASM_WITH_SUFFIX(c, flw)\n DEF_ASM_WITH_SUFFIX(c, flwsp)\n /* double float */\n DEF_ASM_WITH_SUFFIX(c, fld)\n DEF_ASM_WITH_SUFFIX(c, fldsp)\n /* RV64 */\n DEF_ASM_WITH_SUFFIX(c, ld)\n DEF_ASM_WITH_SUFFIX(c, ldsp)\n\n/* Stores */\n\n DEF_ASM_WITH_SUFFIX(c, sw)\n DEF_ASM_WITH_SUFFIX(c, sd)\n DEF_ASM_WITH_SUFFIX(c, swsp)\n DEF_ASM_WITH_SUFFIX(c, sdsp)\n /* single float */\n DEF_ASM_WITH_SUFFIX(c, fsw)\n DEF_ASM_WITH_SUFFIX(c, fswsp)\n /* double float */\n DEF_ASM_WITH_SUFFIX(c, fsd)\n DEF_ASM_WITH_SUFFIX(c, fsdsp)\n\n/* Shifts */\n DEF_ASM_WITH_SUFFIX(c, slli)\n DEF_ASM_WITH_SUFFIX(c, srli)\n DEF_ASM_WITH_SUFFIX(c, srai)\n\n/* Arithmetic */\n DEF_ASM_WITH_SUFFIX(c, add)\n DEF_ASM_WITH_SUFFIX(c, addi)\n DEF_ASM_WITH_SUFFIX(c, addi16sp)\n DEF_ASM_WITH_SUFFIX(c, addi4spn)\n DEF_ASM_WITH_SUFFIX(c, lui)\n DEF_ASM_WITH_SUFFIX(c, sub)\n DEF_ASM_WITH_SUFFIX(c, mv)\n /* RV64 */\n DEF_ASM_WITH_SUFFIX(c, addw)\n DEF_ASM_WITH_SUFFIX(c, addiw)\n DEF_ASM_WITH_SUFFIX(c, subw)\n\n/* Logical */\n DEF_ASM_WITH_SUFFIX(c, xor)\n DEF_ASM_WITH_SUFFIX(c, or)\n DEF_ASM_WITH_SUFFIX(c, and)\n DEF_ASM_WITH_SUFFIX(c, andi)\n\n/* Branch */\n DEF_ASM_WITH_SUFFIX(c, beqz)\n DEF_ASM_WITH_SUFFIX(c, bnez)\n\n/* Jump */\n DEF_ASM_WITH_SUFFIX(c, j)\n DEF_ASM_WITH_SUFFIX(c, jr)\n DEF_ASM_WITH_SUFFIX(c, jal)\n DEF_ASM_WITH_SUFFIX(c, jalr)\n\n/* System call */\n DEF_ASM_WITH_SUFFIX(c, ebreak)\n\n/* XXX F Extension: Single-Precision Floating Point */\n/* XXX D Extension: Double-Precision Floating Point */\n/* from the spec: Tables 16.5–16.7 list the RVC instructions. */\n\n/* “Zicsr”, Control and Status Register (CSR) Instructions, V2.0 */\n DEF_ASM(csrrw)\n DEF_ASM(csrrs)\n DEF_ASM(csrrc)\n DEF_ASM(csrrwi)\n DEF_ASM(csrrsi)\n DEF_ASM(csrrci)\n /* registers */\n DEF_ASM(cycle)\n DEF_ASM(fcsr)\n DEF_ASM(fflags)\n DEF_ASM(frm)\n DEF_ASM(instret)\n DEF_ASM(time)\n /* RV32I-only */\n DEF_ASM(cycleh)\n DEF_ASM(instreth)\n DEF_ASM(timeh)\n /* pseudo */\n DEF_ASM(csrc)\n DEF_ASM(csrci)\n DEF_ASM(csrr)\n DEF_ASM(csrs)\n DEF_ASM(csrsi)\n DEF_ASM(csrw)\n DEF_ASM(csrwi)\n DEF_ASM(frcsr)\n DEF_ASM(frflags)\n DEF_ASM(frrm)\n DEF_ASM(fscsr)\n DEF_ASM(fsflags)\n DEF_ASM(fsrm)\n\n/* Privileged Instructions */\n\n DEF_ASM(mrts)\n DEF_ASM(mrth)\n DEF_ASM(hrts)\n DEF_ASM(wfi)\n\n/* pseudoinstructions */\n DEF_ASM(beqz)\n DEF_ASM(bgez)\n DEF_ASM(bgt)\n DEF_ASM(bgtu)\n DEF_ASM(bgtz)\n DEF_ASM(ble)\n DEF_ASM(bleu)\n DEF_ASM(blez)\n DEF_ASM(bltz)\n DEF_ASM(bnez)\n DEF_ASM(call)\n DEF_ASM_WITH_SUFFIX(fabs, d)\n DEF_ASM_WITH_SUFFIX(fabs, s)\n DEF_ASM(fld)\n DEF_ASM(flw)\n DEF_ASM_WITH_SUFFIX(fmv, d)\n DEF_ASM_WITH_SUFFIX(fmv, s)\n DEF_ASM_WITH_SUFFIX(fneg, d)\n DEF_ASM_WITH_SUFFIX(fneg, s)\n DEF_ASM(fsd)\n DEF_ASM(fsw)\n DEF_ASM(j)\n DEF_ASM(jump)\n DEF_ASM(jr)\n DEF_ASM(la)\n DEF_ASM(li)\n DEF_ASM(lla)\n DEF_ASM(mv)\n DEF_ASM(neg)\n DEF_ASM(negw)\n DEF_ASM(nop)\n DEF_ASM(not)\n DEF_ASM(ret)\n DEF_ASM(seqz)\n DEF_ASM_WITH_SUFFIX(sext, w)\n DEF_ASM(sgtz)\n DEF_ASM(sltz)\n DEF_ASM(snez)\n DEF_ASM(tail)\n\n/* Possible values for .option directive */\n DEF_ASM(arch)\n DEF_ASM(rvc)\n DEF_ASM(norvc)\n DEF_ASM(pic)\n DEF_ASM(nopic)\n DEF_ASM(relax)\n DEF_ASM(norelax)\n DEF_ASM(push)\n DEF_ASM(pop)\n\n/* “A” Standard Extension for Atomic Instructions, Version 2.1 */\n /* XXX: Atomic memory operations */\n DEF_ASM_WITH_SUFFIX(lr, w)\n DEF_ASM_WITH_SUFFIXES(lr, w, aq)\n DEF_ASM_WITH_SUFFIXES(lr, w, rl)\n DEF_ASM_WITH_SUFFIXES(lr, w, aqrl)\n\n DEF_ASM_WITH_SUFFIX(lr, d)\n DEF_ASM_WITH_SUFFIXES(lr, d, aq)\n DEF_ASM_WITH_SUFFIXES(lr, d, rl)\n DEF_ASM_WITH_SUFFIXES(lr, d, aqrl)\n\n\n DEF_ASM_WITH_SUFFIX(sc, w)\n DEF_ASM_WITH_SUFFIXES(sc, w, aq)\n DEF_ASM_WITH_SUFFIXES(sc, w, rl)\n DEF_ASM_WITH_SUFFIXES(sc, w, aqrl)\n\n DEF_ASM_WITH_SUFFIX(sc, d)\n DEF_ASM_WITH_SUFFIXES(sc, d, aq)\n DEF_ASM_WITH_SUFFIXES(sc, d, rl)\n DEF_ASM_WITH_SUFFIXES(sc, d, aqrl)\n\n/* `fence` arguments */\n/* NOTE: Order is important */\n DEF_ASM_FENCE(w)\n DEF_ASM_FENCE(r)\n DEF_ASM_FENCE(rw)\n\n DEF_ASM_FENCE(o)\n DEF_ASM_FENCE(ow)\n DEF_ASM_FENCE(or)\n DEF_ASM_FENCE(orw)\n\n DEF_ASM_FENCE(i)\n DEF_ASM_FENCE(iw)\n DEF_ASM_FENCE(ir)\n DEF_ASM_FENCE(irw)\n\n DEF_ASM_FENCE(io)\n DEF_ASM_FENCE(iow)\n DEF_ASM_FENCE(ior)\n DEF_ASM_FENCE(iorw)\n\n#undef DEF_ASM_FENCE\n#undef DEF_ASM_WITH_SUFFIX\n#undef DEF_ASM_WITH_SUFFIXES\n"
        },
        {
          "name": "stab.def",
          "type": "blob",
          "size": 8.9169921875,
          "content": "/* Table of DBX symbol codes for the GNU system.\n   Copyright (C) 1988, 1997 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This contains contribution from Cygnus Support.  */\n\f\n/* Global variable.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_GSYM, 0x20, \"GSYM\")\n\n/* Function name for BSD Fortran.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_FNAME, 0x22, \"FNAME\")\n\n/* Function name or text-segment variable for C.  Value is its address.\n   Desc is supposedly starting line number, but GCC doesn't set it\n   and DBX seems not to miss it.  */\n__define_stab (N_FUN, 0x24, \"FUN\")\n\n/* Data-segment variable with internal linkage.  Value is its address.\n   \"Static Sym\".  */\n__define_stab (N_STSYM, 0x26, \"STSYM\")\n\n/* BSS-segment variable with internal linkage.  Value is its address.  */\n__define_stab (N_LCSYM, 0x28, \"LCSYM\")\n\n/* Name of main routine.  Only the name is significant.\n   This is not used in C.  */\n__define_stab (N_MAIN, 0x2a, \"MAIN\")\n\n/* Global symbol in Pascal.\n   Supposedly the value is its line number; I'm skeptical.  */\n__define_stab (N_PC, 0x30, \"PC\")\n\n/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0. */\n__define_stab (N_NSYMS, 0x32, \"NSYMS\")\n\n/* \"No DST map for sym: name, ,0,type,ignored\"  according to Ultrix V4.0. */\n__define_stab (N_NOMAP, 0x34, \"NOMAP\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  */\n__define_stab (N_OBJ, 0x38, \"OBJ\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  Possibly related to the\n   optimization flags used in this module.  */\n__define_stab (N_OPT, 0x3c, \"OPT\")\n\n/* Register variable.  Value is number of register.  */\n__define_stab (N_RSYM, 0x40, \"RSYM\")\n\n/* Modula-2 compilation unit.  Can someone say what info it contains?  */\n__define_stab (N_M2C, 0x42, \"M2C\")\n\n/* Line number in text segment.  Desc is the line number;\n   value is corresponding address.  */\n__define_stab (N_SLINE, 0x44, \"SLINE\")\n\n/* Similar, for data segment.  */\n__define_stab (N_DSLINE, 0x46, \"DSLINE\")\n\n/* Similar, for bss segment.  */\n__define_stab (N_BSLINE, 0x48, \"BSLINE\")\n\n/* Sun's source-code browser stabs.  ?? Don't know what the fields are.\n   Supposedly the field is \"path to associated .cb file\".  THIS VALUE\n   OVERLAPS WITH N_BSLINE!  */\n__define_stab (N_BROWS, 0x48, \"BROWS\")\n\n/* GNU Modula-2 definition module dependency.  Value is the modification time\n   of the definition file.  Other is non-zero if it is imported with the\n   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there\n   are enough empty fields? */\n__define_stab(N_DEFD, 0x4a, \"DEFD\")\n\n/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2\n   and one is for C++.   Still,... */\n/* GNU C++ exception variable.  Name is variable name.  */\n__define_stab (N_EHDECL, 0x50, \"EHDECL\")\n/* Modula2 info \"for imc\":  name,,0,0,0  according to Ultrix V4.0.  */\n__define_stab (N_MOD2, 0x50, \"MOD2\")\n\n/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if\n   this entry is immediately followed by a CAUGHT stab saying what exception\n   was caught.  Multiple CAUGHT stabs means that multiple exceptions\n   can be caught here.  If Desc is 0, it means all exceptions are caught\n   here.  */\n__define_stab (N_CATCH, 0x54, \"CATCH\")\n\n/* Structure or union element.  Value is offset in the structure.  */\n__define_stab (N_SSYM, 0x60, \"SSYM\")\n\n/* Name of main source file.\n   Value is starting text address of the compilation.  */\n__define_stab (N_SO, 0x64, \"SO\")\n\n/* Automatic variable in the stack.  Value is offset from frame pointer.\n   Also used for type descriptions.  */\n__define_stab (N_LSYM, 0x80, \"LSYM\")\n\n/* Beginning of an include file.  Only Sun uses this.\n   In an object file, only the name is significant.\n   The Sun linker puts data into some of the other fields.  */\n__define_stab (N_BINCL, 0x82, \"BINCL\")\n\n/* Name of sub-source file (#include file).\n   Value is starting text address of the compilation.  */\n__define_stab (N_SOL, 0x84, \"SOL\")\n\n/* Parameter variable.  Value is offset from argument pointer.\n   (On most machines the argument pointer is the same as the frame pointer.  */\n__define_stab (N_PSYM, 0xa0, \"PSYM\")\n\n/* End of an include file.  No name.\n   This and N_BINCL act as brackets around the file's output.\n   In an object file, there is no significant data in this entry.\n   The Sun linker puts data into some of the fields.  */\n__define_stab (N_EINCL, 0xa2, \"EINCL\")\n\n/* Alternate entry point.  Value is its address.  */\n__define_stab (N_ENTRY, 0xa4, \"ENTRY\")\n\n/* Beginning of lexical block.\n   The desc is the nesting level in lexical blocks.\n   The value is the address of the start of the text for the block.\n   The variables declared inside the block *precede* the N_LBRAC symbol.  */\n__define_stab (N_LBRAC, 0xc0, \"LBRAC\")\n\n/* Place holder for deleted include file.  Replaces a N_BINCL and everything\n   up to the corresponding N_EINCL.  The Sun linker generates these when\n   it finds multiple identical copies of the symbols from an include file.\n   This appears only in output from the Sun linker.  */\n__define_stab (N_EXCL, 0xc2, \"EXCL\")\n\n/* Modula-2 scope information.  Can someone say what info it contains?  */\n__define_stab (N_SCOPE, 0xc4, \"SCOPE\")\n\n/* End of a lexical block.  Desc matches the N_LBRAC's desc.\n   The value is the address of the end of the text for the block.  */\n__define_stab (N_RBRAC, 0xe0, \"RBRAC\")\n\n/* Begin named common block.  Only the name is significant.  */\n__define_stab (N_BCOMM, 0xe2, \"BCOMM\")\n\n/* End named common block.  Only the name is significant\n   (and it should match the N_BCOMM).  */\n__define_stab (N_ECOMM, 0xe4, \"ECOMM\")\n\n/* End common (local name): value is address.\n   I'm not sure how this is used.  */\n__define_stab (N_ECOML, 0xe8, \"ECOML\")\n\n/* These STAB's are used on Gould systems for Non-Base register symbols\n   or something like that.  FIXME.  I have assigned the values at random\n   since I don't have a Gould here.  Fixups from Gould folk welcome... */\n__define_stab (N_NBTEXT, 0xF0, \"NBTEXT\")\n__define_stab (N_NBDATA, 0xF2, \"NBDATA\")\n__define_stab (N_NBBSS,  0xF4, \"NBBSS\")\n__define_stab (N_NBSTS,  0xF6, \"NBSTS\")\n__define_stab (N_NBLCS,  0xF8, \"NBLCS\")\n\n/* Second symbol entry containing a length-value for the preceding entry.\n   The value is the length.  */\n__define_stab (N_LENG, 0xfe, \"LENG\")\n\f\n/* The above information, in matrix format.\n\n\t\t\tSTAB MATRIX\n\t_________________________________________________\n\t| 00 - 1F are not dbx stab symbols\t\t|\n\t| In most cases, the low bit is the EXTernal bit|\n\n\t| 00 UNDEF  | 02 ABS\t| 04 TEXT   | 06 DATA\t|\n\t| 01  |EXT  | 03  |EXT\t| 05  |EXT  | 07  |EXT\t|\n\n\t| 08 BSS    | 0A INDR\t| 0C FN_SEQ | 0E   \t|\n\t| 09  |EXT  | 0B \t| 0D\t    | 0F\t|\n\n\t| 10 \t    | 12 COMM\t| 14 SETA   | 16 SETT\t|\n\t| 11\t    | 13\t| 15 \t    | 17\t|\n\n\t| 18 SETD   | 1A SETB\t| 1C SETV   | 1E WARNING|\n\t| 19\t    | 1B\t| 1D \t    | 1F FN\t|\n\n\t|_______________________________________________|\n\t| Debug entries with bit 01 set are unused.\t|\n\t| 20 GSYM   | 22 FNAME\t| 24 FUN    | 26 STSYM\t|\n\t| 28 LCSYM  | 2A MAIN\t| 2C\t    | 2E\t|\n\t| 30 PC\t    | 32 NSYMS\t| 34 NOMAP  | 36\t|\n\t| 38 OBJ    | 3A\t| 3C OPT    | 3E\t|\n\t| 40 RSYM   | 42 M2C\t| 44 SLINE  | 46 DSLINE |\n\t| 48 BSLINE*| 4A DEFD\t| 4C        | 4E\t|\n\t| 50 EHDECL*| 52\t| 54 CATCH  | 56        |\n\t| 58        | 5A        | 5C        | 5E\t|\n\t| 60 SSYM   | 62\t| 64 SO\t    | 66 \t|\n\t| 68 \t    | 6A\t| 6C\t    | 6E\t|\n\t| 70\t    | 72\t| 74\t    | 76\t|\n\t| 78\t    | 7A\t| 7C\t    | 7E\t|\n\t| 80 LSYM   | 82 BINCL\t| 84 SOL    | 86\t|\n\t| 88\t    | 8A\t| 8C\t    | 8E\t|\n\t| 90\t    | 92\t| 94\t    | 96\t|\n\t| 98\t    | 9A\t| 9C\t    | 9E\t|\n\t| A0 PSYM   | A2 EINCL\t| A4 ENTRY  | A6\t|\n\t| A8\t    | AA\t| AC\t    | AE\t|\n\t| B0\t    | B2\t| B4\t    | B6\t|\n\t| B8\t    | BA\t| BC\t    | BE\t|\n\t| C0 LBRAC  | C2 EXCL\t| C4 SCOPE  | C6\t|\n\t| C8\t    | CA\t| CC\t    | CE\t|\n\t| D0\t    | D2\t| D4\t    | D6\t|\n\t| D8\t    | DA\t| DC\t    | DE\t|\n\t| E0 RBRAC  | E2 BCOMM\t| E4 ECOMM  | E6\t|\n\t| E8 ECOML  | EA\t| EC\t    | EE\t|\n\t| F0\t    | F2\t| F4\t    | F6\t|\n\t| F8\t    | FA\t| FC\t    | FE LENG\t|\n\t+-----------------------------------------------+\n * 50 EHDECL is also MOD2.\n * 48 BSLINE is also BROWS.\n */\n"
        },
        {
          "name": "stab.h",
          "type": "blob",
          "size": 0.2529296875,
          "content": "#ifndef __GNU_STAB__\n\n/* Indicate the GNU stab.h is in use.  */\n\n#define __GNU_STAB__\n\n#define __define_stab(NAME, CODE, STRING) NAME=CODE,\n\nenum __stab_debug_code\n{\n#include \"stab.def\"\nLAST_UNUSED_STAB_CODE\n};\n\n#undef __define_stab\n\n#endif /* __GNU_STAB_ */\n"
        },
        {
          "name": "tcc-doc.texi",
          "type": "blob",
          "size": 38.630859375,
          "content": "\\input texinfo @c -*- texinfo -*-\n@c %**start of header\n@setfilename tcc-doc.info\n@settitle Tiny C Compiler Reference Documentation\n@dircategory Software development\n@direntry\n* TCC: (tcc-doc).               The Tiny C Compiler.\n@end direntry\n@c %**end of header\n\n@include config.texi\n\n@iftex\n@titlepage\n@afourpaper\n@sp 7\n@center @titlefont{Tiny C Compiler Reference Documentation}\n@sp 3\n@end titlepage\n@headings double\n@end iftex\n\n@contents\n\n@node Top, Introduction, (dir), (dir)\n@top Tiny C Compiler Reference Documentation\n\nThis manual documents version @value{VERSION} of the Tiny C Compiler.\n\n@menu\n* Introduction::                Introduction to tcc.\n* Invoke::                      Invocation of tcc (command line, options).\n* Clang::                       ANSI C and extensions.\n* asm::                         Assembler syntax.\n* linker::                      Output file generation and supported targets.\n* Bounds::                      Automatic bounds-checking of C code.\n* Libtcc::                      The libtcc library.\n* devel::                       Guide for Developers.\n@end menu\n\n\n@node Introduction\n@chapter Introduction\n\nTinyCC (aka TCC) is a small but hyper fast C compiler. Unlike other C\ncompilers, it is meant to be self-relying: you do not need an\nexternal assembler or linker because TCC does that for you.\n\nTCC compiles so @emph{fast} that even for big projects @code{Makefile}s may\nnot be necessary.\n\nTCC not only supports ANSI C, but also most of the new ISO C99\nstandard and many GNUC extensions including inline assembly.\n\nTCC can also be used to make @emph{C scripts}, i.e. pieces of C source\nthat you run as a Perl or Python script. Compilation is so fast that\nyour script will be as fast as if it was an executable.\n\nTCC can also automatically generate memory and bound checks\n(@pxref{Bounds}) while allowing all C pointers operations. TCC can do\nthese checks even if non patched libraries are used.\n\nWith @code{libtcc}, you can use TCC as a backend for dynamic code\ngeneration (@pxref{Libtcc}).\n\nTCC mainly supports the i386 target on Linux and Windows. There are alpha\nports for the ARM (@code{arm-tcc}) and the TMS320C67xx targets\n(@code{c67-tcc}). More information about the ARM port is available at\n@url{http://lists.gnu.org/archive/html/tinycc-devel/2003-10/msg00044.html}.\n\nFor usage on Windows, see also @url{tcc-win32.txt}.\n\n@node Invoke\n@chapter Command line invocation\n\n@section Quick start\n\n@example\n@c man begin SYNOPSIS\nusage: tcc [options] [@var{infile1} @var{infile2}@dots{}] [@option{-run} @var{infile} @var{args}@dots{}]\n@c man end\n@end example\n\n@noindent\n@c man begin DESCRIPTION\nTCC options are a very much like gcc options. The main difference is that TCC\ncan also execute directly the resulting program and give it runtime\narguments.\n\nHere are some examples to understand the logic:\n\n@table @code\n@item @samp{tcc -run a.c}\nCompile @file{a.c} and execute it directly\n\n@item @samp{tcc -run a.c arg1}\nCompile a.c and execute it directly. arg1 is given as first argument to\nthe @code{main()} of a.c.\n\n@item @samp{tcc a.c -run b.c arg1}\nCompile @file{a.c} and @file{b.c}, link them together and execute them. arg1 is given\nas first argument to the @code{main()} of the resulting program. \n@ignore \nBecause multiple C files are specified, @option{--} are necessary to clearly \nseparate the program arguments from the TCC options.\n@end ignore\n\n@item @samp{tcc -o myprog a.c b.c}\nCompile @file{a.c} and @file{b.c}, link them and generate the executable @file{myprog}.\n\n@item @samp{tcc -o myprog a.o b.o}\nlink @file{a.o} and @file{b.o} together and generate the executable @file{myprog}.\n\n@item @samp{tcc -c a.c}\nCompile @file{a.c} and generate object file @file{a.o}.\n\n@item @samp{tcc -c asmfile.S}\nPreprocess with C preprocess and assemble @file{asmfile.S} and generate\nobject file @file{asmfile.o}.\n\n@item @samp{tcc -c asmfile.s}\nAssemble (but not preprocess) @file{asmfile.s} and generate object file\n@file{asmfile.o}.\n\n@item @samp{tcc -r -o ab.o a.c b.c}\nCompile @file{a.c} and @file{b.c}, link them together and generate the object file @file{ab.o}.\n\n@end table\n\nScripting:\n\nTCC can be invoked from @emph{scripts}, just as shell scripts. You just\nneed to add @code{#!/usr/local/bin/tcc -run} at the start of your C source:\n\n@example\n#!/usr/local/bin/tcc -run\n#include <stdio.h>\n\nint main() \n@{\n    printf(\"Hello World\\n\");\n    return 0;\n@}\n@end example\n\nTCC can read C source code from @emph{standard input} when @option{-} is used in \nplace of @option{infile}. Example:\n\n@example\necho 'main()@{puts(\"hello\");@}' | tcc -run -\n@end example\n@c man end\n\n@section Option summary\n\nGeneral Options:\n\n@c man begin OPTIONS\n@table @option\n@item -c\nGenerate an object file.\n\n@item -o outfile\nPut object file, executable, or dll into output file @file{outfile}.\n\n@item -run source [args...]\nCompile file @var{source} and run it with the command line arguments\n@var{args}. In order to be able to give more than one argument to a\nscript, several TCC options can be given @emph{after} the\n@option{-run} option, separated by spaces:\n@example\ntcc \"-run -L/usr/X11R6/lib -lX11\" ex4.c\n@end example\nIn a script, it gives the following header:\n@example\n#!/usr/local/bin/tcc -run -L/usr/X11R6/lib -lX11\n@end example\n\n@item -v\nDisplay TCC version.\n\n@item -vv\nShow included files.  As sole argument, print search dirs.  -vvv shows tries too.\n\n@item -bench\nDisplay compilation statistics.\n\n@end table\n\nPreprocessor options:\n\n@table @option\n@item -Idir\nSpecify an additional include path. Include paths are searched in the\norder they are specified.\n\nSystem include paths are always searched after. The default system\ninclude paths are: @file{/usr/local/include}, @file{/usr/include}\nand @file{PREFIX/lib/tcc/include}. (@file{PREFIX} is usually\n@file{/usr} or @file{/usr/local}).\n\n@item -Dsym[=val]\nDefine preprocessor symbol @samp{sym} to\nval. If val is not present, its value is @samp{1}. Function-like macros can\nalso be defined: @option{-DF(a)=a+1}\n\n@item -Usym\nUndefine preprocessor symbol @samp{sym}.\n\n@item -E\nPreprocess only, to stdout or file (with -o).\n\n@end table\n\nCompilation flags:\n\nNote: each of the following options has a negative form beginning with\n@option{-fno-}.\n\n@table @option\n@item -funsigned-char\nLet the @code{char} type be unsigned.\n\n@item -fsigned-char\nLet the @code{char} type be signed.\n\n@item -fno-common\nDo not generate common symbols for uninitialized data.\n\n@item -fleading-underscore\nAdd a leading underscore at the beginning of each C symbol.\n\n@item -fms-extensions\nAllow a MS C compiler extensions to the language. Currently this\nassumes a nested named structure declaration without an identifier\nbehaves like an unnamed one.\n\n@item -fdollars-in-identifiers\nAllow dollar signs in identifiers\n\n@item -ftest-coverage\nCreate code coverage code. After running the resulting code an executable.tcov\nor sofile.tcov file is generated with code coverage.\n\n@end table\n\nWarning options:\n\n@table @option\n@item -w\nDisable all warnings.\n\n@end table\n\nNote: each of the following warning options has a negative form beginning with\n@option{-Wno-}.\n\n@table @option\n@item -Wimplicit-function-declaration\nWarn about implicit function declaration.\n\n@item -Wunsupported\nWarn about unsupported GCC features that are ignored by TCC.\n\n@item -Wwrite-strings\nMake string constants be of type @code{const char *} instead of @code{char\n*}.\n\n@item -Werror\nAbort compilation if a warning is issued. Can be given an option to enable\nthe specified warning and turn it into an error, for example\n@option{-Werror=unsupported}.\n\n@item -Wall \nActivate some useful warnings.\n\n@end table\n\nLinker options:\n\n@table @option\n@item -Ldir\nSpecify an additional static library path for the @option{-l} option. The\ndefault library paths are @file{/usr/local/lib}, @file{/usr/lib} and @file{/lib}.\n\n@item -lxxx\nLink your program with dynamic library libxxx.so or static library\nlibxxx.a. The library is searched in the paths specified by the\n@option{-L} option and @env{LIBRARY_PATH} variable.\n\n@item -Bdir\nSet the path where the tcc internal libraries (and include files) can be\nfound (default is @file{PREFIX/lib/tcc}).\n\n@item -shared\nGenerate a shared library instead of an executable.\n\n@item -soname name\nset name for shared library to be used at runtime\n\n@item -static\nGenerate a statically linked executable (default is a shared linked\nexecutable).\n\n@item -rdynamic\nExport global symbols to the dynamic linker. It is useful when a library\nopened with @code{dlopen()} needs to access executable symbols.\n\n@item -r\nGenerate an object file combining all input files.\n\n@item -Wl,-rpath=path\nPut custom search path for dynamic libraries into executable.\n\n@item -Wl,--enable-new-dtags\nWhen putting a custom search path for dynamic libraries into the executable,\ncreate the new ELF dynamic tag DT_RUNPATH instead of the old legacy DT_RPATH.\n\n@item -Wl,--oformat=fmt\nUse @var{fmt} as output format. The supported output formats are:\n@table @code\n@item elf32-i386\nELF output format (default)\n@item binary\nBinary image (only for executable output)\n@item coff\nCOFF output format (only for executable output for TMS320C67xx target)\n@end table\n\n@item -Wl,--export-all-symbols\n@item -Wl,--export-dynamic\nExport global symbols to the dynamic linker. It is useful when a library\nopened with @code{dlopen()} needs to access executable symbols.\n\n@item -Wl,-subsystem=console/gui/wince/...\nSet type for PE (Windows) executables.\n\n@item -Wl,-[Ttext=# | section-alignment=# | file-alignment=# | image-base=# | stack=#]\nModify executable layout.\n\n@item -Wl,-Bsymbolic\nSet DT_SYMBOLIC tag.\n\n@item -Wl,-(no-)whole-archive\nTurn on/off linking of all objects in archives.\n\n@end table\n\nDebugger options:\n\n@table @option\n@item -g\nGenerate run time stab debug information so that you get clear run time\nerror messages: @code{ test.c:68: in function 'test5()': dereferencing\ninvalid pointer} instead of the laconic @code{Segmentation\nfault}.\n\n@item -gdwarf[-x]\nGenerate run time dwarf debug information instead of stab debug information.\n\n@item -b\nGenerate additional support code to check memory allocations and array/pointer\nbounds (@pxref{Bounds}). @option{-g} is implied.\n\n@item -bt[N]\nDisplay N callers in stack traces. This is useful with @option{-g} or @option{-b}.\nWhen activated, @code{__TCC_BACKTRACE__} is defined.\n\nWith executables, additional support for stack traces is included. A function\n    @code{ int tcc_backtrace(const char *fmt, ...); }\nis provided to trigger a stack trace with a message on demand.\n\n@end table\n\nMisc options:\n\n@table @option\n\n@item -M\nJust output makefile fragment with dependencies\n\n@item -MM\nLike -M except mention only user header files, not system header files.\n\n@item -MD\nGenerate makefile fragment with dependencies.\n\n@item -MMD\nLike -MD except mention only user header files, not system header files.\n\n@item -MF depfile\nUse @file{depfile} as output for -MD.\n\n@item -print-search-dirs\nPrint the configured installation directory and a list of library\nand include directories tcc will search.\n\n@item -dumpversion\nPrint version.\n\n@end table\n\nTarget specific options:\n\n@table @option\n@item -mms-bitfields\nUse an algorithm for bitfield alignment consistent with MSVC. Default is\ngcc's algorithm.\n\n@item -mfloat-abi (ARM only)\nSelect the float ABI. Possible values: @code{softfp} and @code{hard}\n\n@item -mno-sse\nDo not use sse registers on x86_64\n\n@item -m32, -m64\nPass command line to the i386/x86_64 cross compiler.\n\n@end table\n\nNote: GCC options @option{-Ox}, @option{-fx} and @option{-mx} are\nignored.\n@c man end\n\n@c man begin ENVIRONMENT\nEnvironment variables that affect how tcc operates.\n\n@table @option\n\n@item CPATH\n@item C_INCLUDE_PATH\nA colon-separated list of directories searched for include files,\ndirectories given with @option{-I} are searched first.\n\n@item LIBRARY_PATH\nA colon-separated list of directories searched for libraries for the\n@option{-l} option, directories given with @option{-L} are searched first.\n\n@end table\n\n@c man end\n\n@ignore\n\n@setfilename tcc\n@settitle Tiny C Compiler\n\n@c man begin SEEALSO\ncpp(1),\ngcc(1)\n@c man end\n\n@c man begin AUTHOR\nFabrice Bellard\n@c man end\n\n@end ignore\n\n@node Clang\n@chapter C language support\n\n@section ANSI C\n\nTCC implements all the ANSI C standard, including structure bit fields\nand floating point numbers (@code{long double}, @code{double}, and\n@code{float} fully supported).\n\n@section ISOC99 extensions\n\nTCC implements many features of the new C standard: ISO C99. Currently\nmissing items are: complex and imaginary numbers.\n\nCurrently implemented ISOC99 features:\n\n@itemize\n\n@item variable length arrays.\n\n@item 64 bit @code{long long} types are fully supported.\n\n@item The boolean type @code{_Bool} is supported.\n\n@item @code{__func__} is a string variable containing the current\nfunction name.\n\n@item Variadic macros: @code{__VA_ARGS__} can be used for\n   function-like macros:\n@example\n    #define dprintf(level, __VA_ARGS__) printf(__VA_ARGS__)\n@end example\n\n@noindent\n@code{dprintf} can then be used with a variable number of parameters.\n\n@item Declarations can appear anywhere in a block (as in C++).\n\n@item Array and struct/union elements can be initialized in any order by\n  using designators:\n@example\n    struct @{ int x, y; @} st[10] = @{ [0].x = 1, [0].y = 2 @};\n\n    int tab[10] = @{ 1, 2, [5] = 5, [9] = 9@};\n@end example\n    \n@item Compound initializers are supported:\n@example\n    int *p = (int [])@{ 1, 2, 3 @};\n@end example\nto initialize a pointer pointing to an initialized array. The same\nworks for structures and strings.\n\n@item Hexadecimal floating point constants are supported:\n@example\n          double d = 0x1234p10;\n@end example\n\n@noindent\nis the same as writing \n@example\n          double d = 4771840.0;\n@end example\n\n@item @code{inline} keyword is ignored.\n\n@item @code{restrict} keyword is ignored.\n@end itemize\n\n@section GNU C extensions\n\nTCC implements some GNU C extensions:\n\n@itemize\n\n@item array designators can be used without '=': \n@example\n    int a[10] = @{ [0] 1, [5] 2, 3, 4 @};\n@end example\n\n@item Structure field designators can be a label: \n@example\n    struct @{ int x, y; @} st = @{ x: 1, y: 1@};\n@end example\ninstead of\n@example\n    struct @{ int x, y; @} st = @{ .x = 1, .y = 1@};\n@end example\n\n@item @code{\\e} is ASCII character 27.\n\n@item case ranges : ranges can be used in @code{case}s:\n@example\n    switch(a) @{\n    case 1 @dots{} 9:\n          printf(\"range 1 to 9\\n\");\n          break;\n    default:\n          printf(\"unexpected\\n\");\n          break;\n    @}\n@end example\n\n@cindex aligned attribute\n@cindex packed attribute\n@cindex section attribute\n@cindex unused attribute\n@cindex cdecl attribute\n@cindex stdcall attribute\n@cindex regparm attribute\n@cindex dllexport attribute\n@cindex nodecorate attribute\n\n@item The keyword @code{__attribute__} is handled to specify variable or\nfunction attributes. The following attributes are supported:\n  @itemize\n\n  @item @code{aligned(n)}: align a variable or a structure field to n bytes\n(must be a power of two).\n\n  @item @code{packed}: force alignment of a variable or a structure field to\n  1.\n\n  @item @code{section(name)}: generate function or data in assembly section\nname (name is a string containing the section name) instead of the default\nsection.\n\n  @item @code{unused}: specify that the variable or the function is unused.\n\n  @item @code{cdecl}: use standard C calling convention (default).\n\n  @item @code{stdcall}: use Pascal-like calling convention.\n\n  @item @code{regparm(n)}: use fast i386 calling convention. @var{n} must be\nbetween 1 and 3. The first @var{n} function parameters are respectively put in\nregisters @code{%eax}, @code{%edx} and @code{%ecx}.\n\n  @item @code{dllexport}: export function from dll/executable (win32 only)\n\n  @item @code{nodecorate}: do not apply any decorations that would otherwise be applied when exporting function from dll/executable (win32 only)\n\n  @end itemize\n\nHere are some examples:\n@example\n    int a __attribute__ ((aligned(8), section(\".mysection\")));\n@end example\n\n@noindent\nalign variable @code{a} to 8 bytes and put it in section @code{.mysection}.\n\n@example\n    int my_add(int a, int b) __attribute__ ((section(\".mycodesection\"))) \n    @{\n        return a + b;\n    @}\n@end example\n\n@noindent\ngenerate function @code{my_add} in section @code{.mycodesection}.\n\n@item GNU style variadic macros:\n@example\n    #define dprintf(fmt, args@dots{}) printf(fmt, ## args)\n\n    dprintf(\"no arg\\n\");\n    dprintf(\"one arg %d\\n\", 1);\n@end example\n\n@item @code{__FUNCTION__} is interpreted as C99 @code{__func__} \n(so it has not exactly the same semantics as string literal GNUC\nwhere it is a string literal).\n\n@item The @code{__alignof__} keyword can be used as @code{sizeof} \nto get the alignment of a type or an expression.\n\n@item The @code{typeof(x)} returns the type of @code{x}. \n@code{x} is an expression or a type.\n\n@item Computed gotos: @code{&&label} returns a pointer of type \n@code{void *} on the goto label @code{label}. @code{goto *expr} can be\nused to jump on the pointer resulting from @code{expr}.\n\n@item Inline assembly with asm instruction:\n@cindex inline assembly\n@cindex assembly, inline\n@cindex __asm__\n@example\nstatic inline void * my_memcpy(void * to, const void * from, size_t n)\n@{\nint d0, d1, d2;\n__asm__ __volatile__(\n        \"rep ; movsl\\n\\t\"\n        \"testb $2,%b4\\n\\t\"\n        \"je 1f\\n\\t\"\n        \"movsw\\n\"\n        \"1:\\ttestb $1,%b4\\n\\t\"\n        \"je 2f\\n\\t\"\n        \"movsb\\n\"\n        \"2:\"\n        : \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n        :\"0\" (n/4), \"q\" (n),\"1\" ((long) to),\"2\" ((long) from)\n        : \"memory\");\nreturn (to);\n@}\n@end example\n\n@noindent\n@cindex gas\nTCC includes its own x86 inline assembler with a @code{gas}-like (GNU\nassembler) syntax. No intermediate files are generated. GCC 3.x named\noperands are supported.\n\n@item @code{__builtin_types_compatible_p()} and @code{__builtin_constant_p()} \nare supported.\n\n@item @code{#pragma pack} is supported for win32 compatibility.\n\n@end itemize\n\n@section TinyCC extensions\n\n@itemize\n\n@item @code{__TINYC__} is a predefined macro to indicate that you use TCC.\n\n@item @code{#!} at the start of a line is ignored to allow scripting.\n\n@item Binary digits can be entered (@code{0b101} instead of\n@code{5}).\n\n@end itemize\n\n@node asm\n@chapter TinyCC Assembler\n\nSince version 0.9.16, TinyCC integrates its own assembler. TinyCC\nassembler supports a gas-like syntax (GNU assembler). You can\ndeactivate assembler support if you want a smaller TinyCC executable\n(the C compiler does not rely on the assembler).\n\nTinyCC Assembler is used to handle files with @file{.S} (C\npreprocessed assembler) and @file{.s} extensions. It is also used to\nhandle the GNU inline assembler with the @code{asm} keyword.\n\n@section Syntax\n\nTinyCC Assembler supports most of the gas syntax. The tokens are the\nsame as C.\n\n@itemize\n\n@item C and C++ comments are supported.\n\n@item Identifiers are the same as C, so you cannot use '.' or '$'.\n\n@item Only 32 bit integer numbers are supported.\n\n@end itemize\n\n@section Expressions\n\n@itemize\n\n@item Integers in decimal, octal and hexa are supported.\n\n@item Unary operators: +, -, ~.\n\n@item Binary operators in decreasing priority order:\n\n@enumerate\n@item *, /, %\n@item &, |, ^\n@item +, -\n@end enumerate\n\n@item A value is either an absolute number or a label plus an offset. \nAll operators accept absolute values except '+' and '-'. '+' or '-' can be\nused to add an offset to a label. '-' supports two labels only if they\nare the same or if they are both defined and in the same section.\n\n@end itemize\n\n@section Labels\n\n@itemize\n\n@item All labels are considered as local, except undefined ones.\n\n@item Numeric labels can be used as local @code{gas}-like labels. \nThey can be defined several times in the same source. Use 'b'\n(backward) or 'f' (forward) as suffix to reference them:\n\n@example\n 1:\n      jmp 1b /* jump to '1' label before */\n      jmp 1f /* jump to '1' label after */\n 1:\n@end example\n\n@end itemize\n\n@section Directives\n@cindex assembler directives\n@cindex directives, assembler\n@cindex align directive\n@cindex skip directive\n@cindex space directive\n@cindex byte directive\n@cindex word directive\n@cindex short directive\n@cindex int directive\n@cindex long directive\n@cindex quad directive\n@cindex globl directive\n@cindex global directive\n@cindex section directive\n@cindex text directive\n@cindex data directive\n@cindex bss directive\n@cindex fill directive\n@cindex org directive\n@cindex previous directive\n@cindex string directive\n@cindex asciz directive\n@cindex ascii directive\n\nAll directives are preceded by a '.'. The following directives are\nsupported:\n\n@itemize\n@item .align n[,value]\n@item .skip n[,value]\n@item .space n[,value]\n@item .byte value1[,...]\n@item .word value1[,...]\n@item .short value1[,...]\n@item .int value1[,...]\n@item .long value1[,...]\n@item .quad immediate_value1[,...]\n@item .globl symbol\n@item .global symbol\n@item .section section\n@item .text\n@item .data\n@item .bss\n@item .fill repeat[,size[,value]]\n@item .org n\n@item .previous\n@item .string string[,...]\n@item .asciz string[,...]\n@item .ascii string[,...]\n@end itemize\n\n@section X86 Assembler\n@cindex assembler\n\nAll X86 opcodes are supported. Only ATT syntax is supported (source\nthen destination operand order). If no size suffix is given, TinyCC\ntries to guess it from the operand sizes.\n\nCurrently, MMX opcodes are supported but not SSE ones.\n\n@node linker\n@chapter TinyCC Linker\n@cindex linker\n\n@section ELF file generation\n@cindex ELF\n\nTCC can directly output relocatable ELF files (object files),\nexecutable ELF files and dynamic ELF libraries without relying on an\nexternal linker.\n\nDynamic ELF libraries can be output but the C compiler does not generate\nposition independent code (PIC). It means that the dynamic library\ncode generated by TCC cannot be factorized among processes yet.\n\nTCC linker eliminates unreferenced object code in libraries. A single pass is\ndone on the object and library list, so the order in which object files and\nlibraries are specified is important (same constraint as GNU ld). No grouping\noptions (@option{--start-group} and @option{--end-group}) are supported.\n\n@section ELF file loader\n\nTCC can load ELF object files, archives (.a files) and dynamic\nlibraries (.so).\n\n@section PE-i386 file generation\n@cindex PE-i386\n\nTCC for Windows supports the native Win32 executable file format (PE-i386).  It\ngenerates EXE files (console and gui) and DLL files.\n\nFor usage on Windows, see also tcc-win32.txt.\n\n@section GNU Linker Scripts\n@cindex scripts, linker\n@cindex linker scripts\n@cindex GROUP, linker command\n@cindex FILE, linker command\n@cindex OUTPUT_FORMAT, linker command\n@cindex TARGET, linker command\n\nBecause on many Linux systems some dynamic libraries (such as\n@file{/usr/lib/libc.so}) are in fact GNU ld link scripts (horrible!),\nthe TCC linker also supports a subset of GNU ld scripts.\n\nThe @code{GROUP} and @code{FILE} commands are supported. @code{OUTPUT_FORMAT}\nand @code{TARGET} are ignored.\n\nExample from @file{/usr/lib/libc.so}:\n@example\n/* GNU ld script\n   Use the shared library, but some functions are only in\n   the static library, so try that secondarily.  */\nGROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a )\n@end example\n\n@node Bounds\n@chapter TinyCC Memory and Bound checks\n@cindex bound checks\n@cindex memory checks\n\nThis feature is activated with the @option{-b} option (@pxref{Invoke}).\nHere are some examples of caught errors:\n\n@table @asis\n\n@item Invalid range with standard string function:\n@example\n@{\n    char tab[10];\n    memset(tab, 0, 11);\n@}\n@end example\n\n@item Out of bounds-error in global or local arrays:\n@example\n@{\n    int tab[10];\n    for(i=0;i<11;i++) @{\n        sum += tab[i];\n    @}\n@}\n@end example\n\n@item Out of bounds-error in malloc'ed data:\n@example\n@{\n    int *tab;\n    tab = malloc(20 * sizeof(int));\n    for(i=0;i<21;i++) @{\n        sum += tab[i];\n    @}\n    free(tab);\n@}\n@end example\n\n@item Access of freed memory:\n@example\n@{\n    int *tab;\n    tab = malloc(20 * sizeof(int));\n    free(tab);\n    for(i=0;i<20;i++) @{\n        sum += tab[i];\n    @}\n@}\n@end example\n\n@item Double free:\n@example\n@{\n    int *tab;\n    tab = malloc(20 * sizeof(int));\n    free(tab);\n    free(tab);\n@}\n@end example\n@end table\n\nTCC defines @code{__TCC_BCHECK__} if activated.\n\nThere are five environment variables that can be used to control the behavior:\n@itemize\n@item TCC_BOUNDS_WARN_POINTER_ADD\n- Print warning when pointer add creates an illegal pointer.\n@item TCC_BOUNDS_PRINT_CALLS\n- Print bound checking calls. Can be used for debugging.\n@item TCC_BOUNDS_PRINT_HEAP\n- Print heap objects that are not freed at exit of program.\n@item TCC_BOUNDS_PRINT_STATISTIC\n- Print statistic information at exit of program.\n@item TCC_BOUNDS_NEVER_FATAL\n- Try to continue in case of a bound checking error.\n@end itemize\n\nAlso, a function @code{__bounds_checking(x)} can be used to turn off/on bounds\nchecking from usercode (see below).\n\nNotes:\n@itemize\n@item Only available on i386 (linux and windows), x86_64 (linux and windows),\narm, arm64 and riscv64 for the moment.\n@item The generated code is slower and bigger.\n@item The bound checking code is not included in shared libraries. The main\nexecutable should always be compiled with the @option{-b}.\n@item Pointer size is @emph{unchanged} and code generated with bound checks is\n@emph{fully compatible} with unchecked code. When a pointer comes from\nunchecked code, it is assumed to be valid. Even very obscure C code with\ncasts should work correctly.\n@item Signal handlers are not compatible with bounds checking. The\nbounds checking code disables checking in signal/sigaction handlers.\nThe fork() function call in a multi threaded application is also a problem.\nThe bound checking code fixes this for the child process.\n@item The reason that signals and fork have problems is that we use locking\ninside the bounds checking code.\nInside a signal handler we can not use locks. Also in a multi threaded\napplication after a fork the child process can have the lock set\nby another thread.\n@item The BOUNDS_CHECKING_OFF and BOUNDS_CHECKING_ON can also be used to\ndisable bounds checking for some code.\n@item The __bounds_checking call adds a value to a thread local value.\nThe value starts at 0. If the value is not 0 the code is not checked\nfor bounds checking errors.\n@end itemize\n\n@example\n#ifdef __TCC_BCHECK__\nextern void __bounds_checking (int x);\n# define BOUNDS_CHECKING_OFF __bounds_checking(1)\n# define BOUNDS_CHECKING_ON  __bounds_checking(-1)\n#else\n# define BOUNDS_CHECKING_OFF\n# define BOUNDS_CHECKING_ON\n#endif\n@end example\n\nFor more information about the ideas behind this method, see\n@url{http://www.doc.ic.ac.uk/~phjk/BoundsChecking.html}.\n\n@node Libtcc\n@chapter The @code{libtcc} library\n\nThe @code{libtcc} library enables you to use TCC as a backend for\ndynamic code generation. \n\nRead the @file{libtcc.h} to have an overview of the API. Read\n@file{libtcc_test.c} to have a very simple example.\n\nThe idea consists in giving a C string containing the program you want\nto compile directly to @code{libtcc}. Then you can access to any global\nsymbol (function or variable) defined.\n\n@node devel\n@chapter Developer's guide\n\nThis chapter gives some hints to understand how TCC works. You can skip\nit if you do not intend to modify the TCC code.\n\n@section File reading\n\nThe @code{BufferedFile} structure contains the context needed to read a\nfile, including the current line number. @code{tcc_open()} opens a new\nfile and @code{tcc_close()} closes it. @code{inp()} returns the next\ncharacter.\n\n@section Lexer\n\n@code{next()} reads the next token in the current\nfile. @code{next_nomacro()} reads the next token without macro\nexpansion.\n\n@code{tok} contains the current token (see @code{TOK_xxx})\nconstants. Identifiers and keywords are also keywords. @code{tokc}\ncontains additional infos about the token (for example a constant value\nif number or string token).\n\n@section Parser\n\nThe parser is hardcoded (yacc is not necessary). It does only one pass,\nexcept:\n\n@itemize\n\n@item For initialized arrays with unknown size, a first pass \nis done to count the number of elements.\n\n@item For architectures where arguments are evaluated in \nreverse order, a first pass is done to reverse the argument order.\n\n@end itemize\n\n@section Types\n\nThe types are stored in a single 'int' variable. It was chosen in the\nfirst stages of development when tcc was much simpler. Now, it may not\nbe the best solution.\n\n@example\n#define VT_INT        0  /* integer type */\n#define VT_BYTE       1  /* signed byte type */\n#define VT_SHORT      2  /* short type */\n#define VT_VOID       3  /* void type */\n#define VT_PTR        4  /* pointer */\n#define VT_ENUM       5  /* enum definition */\n#define VT_FUNC       6  /* function type */\n#define VT_STRUCT     7  /* struct/union definition */\n#define VT_FLOAT      8  /* IEEE float */\n#define VT_DOUBLE     9  /* IEEE double */\n#define VT_LDOUBLE   10  /* IEEE long double */\n#define VT_BOOL      11  /* ISOC99 boolean type */\n#define VT_LLONG     12  /* 64 bit integer */\n#define VT_LONG      13  /* long integer (NEVER USED as type, only\n                            during parsing) */\n#define VT_BTYPE      0x000f /* mask for basic type */\n#define VT_UNSIGNED   0x0010  /* unsigned type */\n#define VT_ARRAY      0x0020  /* array type (also has VT_PTR) */\n#define VT_VLA        0x20000 /* VLA type (also has VT_PTR and VT_ARRAY) */\n#define VT_BITFIELD   0x0040  /* bitfield modifier */\n#define VT_CONSTANT   0x0800  /* const modifier */\n#define VT_VOLATILE   0x1000  /* volatile modifier */\n#define VT_DEFSIGN    0x2000  /* signed type */\n\n#define VT_STRUCT_SHIFT 18   /* structure/enum name shift (14 bits left) */\n@end example\n\nWhen a reference to another type is needed (for pointers, functions and\nstructures), the @code{32 - VT_STRUCT_SHIFT} high order bits are used to\nstore an identifier reference.\n\nThe @code{VT_UNSIGNED} flag can be set for chars, shorts, ints and long\nlongs.\n\nArrays are considered as pointers @code{VT_PTR} with the flag\n@code{VT_ARRAY} set. Variable length arrays are considered as special\narrays and have flag @code{VT_VLA} set instead of @code{VT_ARRAY}.\n\nThe @code{VT_BITFIELD} flag can be set for chars, shorts, ints and long\nlongs. If it is set, then the bitfield position is stored from bits\nVT_STRUCT_SHIFT to VT_STRUCT_SHIFT + 5 and the bit field size is stored\nfrom bits VT_STRUCT_SHIFT + 6 to VT_STRUCT_SHIFT + 11.\n\n@code{VT_LONG} is never used except during parsing.\n\nDuring parsing, the storage of an object is also stored in the type\ninteger:\n\n@example\n#define VT_EXTERN  0x00000080  /* extern definition */\n#define VT_STATIC  0x00000100  /* static variable */\n#define VT_TYPEDEF 0x00000200  /* typedef definition */\n#define VT_INLINE  0x00000400  /* inline definition */\n#define VT_IMPORT  0x00004000  /* win32: extern data imported from dll */\n#define VT_EXPORT  0x00008000  /* win32: data exported from dll */\n#define VT_WEAK    0x00010000  /* win32: data exported from dll */\n@end example\n\n@section Symbols\n\nAll symbols are stored in hashed symbol stacks. Each symbol stack\ncontains @code{Sym} structures.\n\n@code{Sym.v} contains the symbol name (remember\nan identifier is also a token, so a string is never necessary to store\nit). @code{Sym.t} gives the type of the symbol. @code{Sym.r} is usually\nthe register in which the corresponding variable is stored. @code{Sym.c} is\nusually a constant associated to the symbol like its address for normal\nsymbols, and the number of entries for symbols representing arrays.\nVariable length array types use @code{Sym.c} as a location on the stack\nwhich holds the runtime sizeof for the type.\n\nFour main symbol stacks are defined:\n\n@table @code\n\n@item define_stack\nfor the macros (@code{#define}s).\n\n@item global_stack\nfor the global variables, functions and types.\n\n@item local_stack\nfor the local variables, functions and types.\n\n@item global_label_stack\nfor the local labels (for @code{goto}).\n\n@item label_stack\nfor GCC block local labels (see the @code{__label__} keyword).\n\n@end table\n\n@code{sym_push()} is used to add a new symbol in the local symbol\nstack. If no local symbol stack is active, it is added in the global\nsymbol stack.\n\n@code{sym_pop(st,b)} pops symbols from the symbol stack @var{st} until\nthe symbol @var{b} is on the top of stack. If @var{b} is NULL, the stack\nis emptied.\n\n@code{sym_find(v)} return the symbol associated to the identifier\n@var{v}. The local stack is searched first from top to bottom, then the\nglobal stack.\n\n@section Sections\n\nThe generated code and data are written in sections. The structure\n@code{Section} contains all the necessary information for a given\nsection. @code{new_section()} creates a new section. ELF file semantics\nis assumed for each section.\n\nThe following sections are predefined:\n\n@table @code\n\n@item text_section\nis the section containing the generated code. @var{ind} contains the\ncurrent position in the code section.\n\n@item data_section\ncontains initialized data\n\n@item bss_section\ncontains uninitialized data\n\n@item bounds_section\n@itemx lbounds_section\nare used when bound checking is activated\n\n@item stab_section\n@itemx stabstr_section\nare used when debugging is active to store debug information\n\n@item symtab_section\n@itemx strtab_section\ncontain the exported symbols (currently only used for debugging).\n\n@end table\n\n@section Code generation\n@cindex code generation\n\n@subsection Introduction\n\nThe TCC code generator directly generates linked binary code in one\npass. It is rather unusual these days (see gcc for example which\ngenerates text assembly), but it can be very fast and surprisingly\nlittle complicated.\n\nThe TCC code generator is register based. Optimization is only done at\nthe expression level. No intermediate representation of expression is\nkept except the current values stored in the @emph{value stack}.\n\nOn x86, three temporary registers are used. When more registers are\nneeded, one register is spilled into a new temporary variable on the stack.\n\n@subsection The value stack\n@cindex value stack, introduction\n\nWhen an expression is parsed, its value is pushed on the value stack\n(@var{vstack}). The top of the value stack is @var{vtop}. Each value\nstack entry is the structure @code{SValue}.\n\n@code{SValue.t} is the type. @code{SValue.r} indicates how the value is\ncurrently stored in the generated code. It is usually a CPU register\nindex (@code{REG_xxx} constants), but additional values and flags are\ndefined:\n\n@example\n#define VT_CONST     0x00f0\n#define VT_LLOCAL    0x00f1\n#define VT_LOCAL     0x00f2\n#define VT_CMP       0x00f3\n#define VT_JMP       0x00f4\n#define VT_JMPI      0x00f5\n#define VT_LVAL      0x0100\n#define VT_SYM       0x0200\n#define VT_MUSTCAST  0x0400\n#define VT_MUSTBOUND 0x0800\n#define VT_BOUNDED   0x8000\n#define VT_LVAL_BYTE     0x1000\n#define VT_LVAL_SHORT    0x2000\n#define VT_LVAL_UNSIGNED 0x4000\n#define VT_LVAL_TYPE     (VT_LVAL_BYTE | VT_LVAL_SHORT | VT_LVAL_UNSIGNED)\n@end example\n\n@table @code\n\n@item VT_CONST\nindicates that the value is a constant. It is stored in the union\n@code{SValue.c}, depending on its type.\n\n@item VT_LOCAL\nindicates a local variable pointer at offset @code{SValue.c.i} in the\nstack.\n\n@item VT_CMP\nindicates that the value is actually stored in the CPU flags (i.e. the\nvalue is the consequence of a test). The value is either 0 or 1. The\nactual CPU flags used is indicated in @code{SValue.c.i}. \n\nIf any code is generated which destroys the CPU flags, this value MUST be\nput in a normal register.\n\n@item VT_JMP\n@itemx VT_JMPI\nindicates that the value is the consequence of a conditional jump. For VT_JMP,\nit is 1 if the jump is taken, 0 otherwise. For VT_JMPI it is inverted.\n\nThese values are used to compile the @code{||} and @code{&&} logical\noperators.\n\nIf any code is generated, this value MUST be put in a normal\nregister. Otherwise, the generated code won't be executed if the jump is\ntaken.\n\n@item VT_LVAL\nis a flag indicating that the value is actually an lvalue (left value of\nan assignment). It means that the value stored is actually a pointer to\nthe wanted value. \n\nUnderstanding the use @code{VT_LVAL} is very important if you want to\nunderstand how TCC works.\n\n@item VT_LVAL_BYTE\n@itemx VT_LVAL_SHORT\n@itemx VT_LVAL_UNSIGNED\nif the lvalue has an integer type, then these flags give its real\ntype. The type alone is not enough in case of cast optimisations.\n\n@item VT_LLOCAL\nis a saved lvalue on the stack. @code{VT_LVAL} must also be set with\n@code{VT_LLOCAL}. @code{VT_LLOCAL} can arise when a @code{VT_LVAL} in\na register has to be saved to the stack, or it can come from an\narchitecture-specific calling convention.\n\n@item VT_MUSTCAST\nindicates that a cast to the value type must be performed if the value\nis used (lazy casting).\n\n@item VT_SYM\nindicates that the symbol @code{SValue.sym} must be added to the constant.\n\n@item VT_MUSTBOUND\n@itemx VT_BOUNDED\nare only used for optional bound checking.\n\n@end table\n\n@subsection Manipulating the value stack\n@cindex value stack\n\n@code{vsetc()} and @code{vset()} pushes a new value on the value\nstack. If the previous @var{vtop} was stored in a very unsafe place(for\nexample in the CPU flags), then some code is generated to put the\nprevious @var{vtop} in a safe storage.\n\n@code{vpop()} pops @var{vtop}. In some cases, it also generates cleanup\ncode (for example if stacked floating point registers are used as on\nx86).\n\nThe @code{gv(rc)} function generates code to evaluate @var{vtop} (the\ntop value of the stack) into registers. @var{rc} selects in which\nregister class the value should be put. @code{gv()} is the @emph{most\nimportant function} of the code generator.\n\n@code{gv2()} is the same as @code{gv()} but for the top two stack\nentries.\n\n@subsection CPU dependent code generation\n@cindex CPU dependent\nSee the @file{i386-gen.c} file to have an example.\n\n@table @code\n\n@item load()\nmust generate the code needed to load a stack value into a register.\n\n@item store()\nmust generate the code needed to store a register into a stack value\nlvalue.\n\n@item gfunc_start()\n@itemx gfunc_param()\n@itemx gfunc_call()\nshould generate a function call\n\n@item gfunc_prolog()\n@itemx gfunc_epilog()\nshould generate a function prolog/epilog.\n\n@item gen_opi(op)\nmust generate the binary integer operation @var{op} on the two top\nentries of the stack which are guaranteed to contain integer types.\n\nThe result value should be put on the stack.\n\n@item gen_opf(op)\nsame as @code{gen_opi()} for floating point operations. The two top\nentries of the stack are guaranteed to contain floating point values of\nsame types.\n\n@item gen_cvt_itof()\ninteger to floating point conversion.\n\n@item gen_cvt_ftoi()\nfloating point to integer conversion.\n\n@item gen_cvt_ftof()\nfloating point to floating point of different size conversion.\n\n@end table\n\n@section Optimizations done\n@cindex optimizations\n@cindex constant propagation\n@cindex strength reduction\n@cindex comparison operators\n@cindex caching processor flags\n@cindex flags, caching\n@cindex jump optimization\nConstant propagation is done for all operations. Multiplications and\ndivisions are optimized to shifts when appropriate. Comparison\noperators are optimized by maintaining a special cache for the\nprocessor flags. &&, || and ! are optimized by maintaining a special\n'jump target' value. No other jump optimization is currently performed\nbecause it would require to store the code in a more abstract fashion.\n\n@unnumbered Concept Index\n@printindex cp\n\n@bye\n\n@c Local variables:\n@c fill-column: 78\n@c texinfo-column-for-description: 32\n@c End:\n"
        },
        {
          "name": "tcc.c",
          "type": "blob",
          "size": 14.3955078125,
          "content": "/*\n *  TCC - Tiny C Compiler\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef ONE_SOURCE\n# define ONE_SOURCE 1\n#endif\n\n#include \"tcc.h\"\n#if ONE_SOURCE\n# include \"libtcc.c\"\n#endif\n#include \"tcctools.c\"\n\nstatic const char help[] =\n    \"Tiny C Compiler \"TCC_VERSION\" - Copyright (C) 2001-2006 Fabrice Bellard\\n\"\n    \"Usage: tcc [options...] [-o outfile] [-c] infile(s)...\\n\"\n    \"       tcc [options...] -run infile (or --) [arguments...]\\n\"\n    \"General options:\\n\"\n    \"  -c           compile only - generate an object file\\n\"\n    \"  -o outfile   set output filename\\n\"\n    \"  -run         run compiled source\\n\"\n    \"  -fflag       set or reset (with 'no-' prefix) 'flag' (see tcc -hh)\\n\"\n    \"  -Wwarning    set or reset (with 'no-' prefix) 'warning' (see tcc -hh)\\n\"\n    \"  -w           disable all warnings\\n\"\n    \"  -v --version show version\\n\"\n    \"  -vv          show search paths or loaded files\\n\"\n    \"  -h -hh       show this, show more help\\n\"\n    \"  -bench       show compilation statistics\\n\"\n    \"  -            use stdin pipe as infile\\n\"\n    \"  @listfile    read arguments from listfile\\n\"\n    \"Preprocessor options:\\n\"\n    \"  -Idir        add include path 'dir'\\n\"\n    \"  -Dsym[=val]  define 'sym' with value 'val'\\n\"\n    \"  -Usym        undefine 'sym'\\n\"\n    \"  -E           preprocess only\\n\"\n    \"Linker options:\\n\"\n    \"  -Ldir        add library path 'dir'\\n\"\n    \"  -llib        link with dynamic or static library 'lib'\\n\"\n    \"  -r           generate (relocatable) object file\\n\"\n    \"  -shared      generate a shared library/dll\\n\"\n    \"  -rdynamic    export all global symbols to dynamic linker\\n\"\n    \"  -soname      set name for shared library to be used at runtime\\n\"\n    \"  -Wl,-opt[=val]  set linker option (see tcc -hh)\\n\"\n    \"Debugger options:\\n\"\n    \"  -g           generate stab runtime debug info\\n\"\n    \"  -gdwarf[-x]  generate dwarf runtime debug info\\n\"\n#ifdef TCC_TARGET_PE\n    \"  -g.pdb       create .pdb debug database\\n\"\n#endif\n#ifdef CONFIG_TCC_BCHECK\n    \"  -b           compile with built-in memory and bounds checker (implies -g)\\n\"\n#endif\n#ifdef CONFIG_TCC_BACKTRACE\n    \"  -bt[N]       link with backtrace (stack dump) support [show max N callers]\\n\"\n#endif\n    \"Misc. options:\\n\"\n    \"  -std=version define __STDC_VERSION__ according to version (c11/gnu11)\\n\"\n    \"  -x[c|a|b|n]  specify type of the next infile (C,ASM,BIN,NONE)\\n\"\n    \"  -nostdinc    do not use standard system include paths\\n\"\n    \"  -nostdlib    do not link with standard crt and libraries\\n\"\n    \"  -Bdir        set tcc's private include/library dir\\n\"\n    \"  -M[M]D       generate make dependency file [ignore system files]\\n\"\n    \"  -M[M]        as above but no other output\\n\"\n    \"  -MF file     specify dependency file name\\n\"\n#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)\n    \"  -m32/64      defer to i386/x86_64 cross compiler\\n\"\n#endif\n    \"Tools:\\n\"\n    \"  create library  : tcc -ar [crstvx] lib [files]\\n\"\n#ifdef TCC_TARGET_PE\n    \"  create def file : tcc -impdef lib.dll [-v] [-o lib.def]\\n\"\n#endif\n    ;\n\nstatic const char help2[] =\n    \"Tiny C Compiler \"TCC_VERSION\" - More Options\\n\"\n    \"Special options:\\n\"\n    \"  -P -P1                        with -E: no/alternative #line output\\n\"\n    \"  -dD -dM                       with -E: output #define directives\\n\"\n    \"  -pthread                      same as -D_REENTRANT and -lpthread\\n\"\n    \"  -On                           same as -D__OPTIMIZE__ for n > 0\\n\"\n    \"  -Wp,-opt                      same as -opt\\n\"\n    \"  -include file                 include 'file' above each input file\\n\"\n    \"  -isystem dir                  add 'dir' to system include path\\n\"\n    \"  -static                       link to static libraries (not recommended)\\n\"\n    \"  -dumpversion                  print version\\n\"\n    \"  -print-search-dirs            print search paths\\n\"\n    \"  -dt                           with -run/-E: auto-define 'test_...' macros\\n\"\n    \"Ignored options:\\n\"\n    \"  -arch -C --param -pedantic -pipe -s -traditional\\n\"\n    \"-W[no-]... warnings:\\n\"\n    \"  all                           turn on some (*) warnings\\n\"\n    \"  error[=warning]               stop after warning (any or specified)\\n\"\n    \"  write-strings                 strings are const\\n\"\n    \"  unsupported                   warn about ignored options, pragmas, etc.\\n\"\n    \"  implicit-function-declaration warn for missing prototype (*)\\n\"\n    \"  discarded-qualifiers          warn when const is dropped (*)\\n\"\n    \"-f[no-]... flags:\\n\"\n    \"  unsigned-char                 default char is unsigned\\n\"\n    \"  signed-char                   default char is signed\\n\"\n    \"  common                        use common section instead of bss\\n\"\n    \"  leading-underscore            decorate extern symbols\\n\"\n    \"  ms-extensions                 allow anonymous struct in struct\\n\"\n    \"  dollars-in-identifiers        allow '$' in C symbols\\n\"\n    \"  reverse-funcargs              evaluate function arguments right to left\\n\"\n    \"  gnu89-inline                  'extern inline' is like 'static inline'\\n\"\n    \"  asynchronous-unwind-tables    create eh_frame section [on]\\n\"\n    \"  test-coverage                 create code coverage code\\n\"\n    \"-m... target specific options:\\n\"\n    \"  ms-bitfields                  use MSVC bitfield layout\\n\"\n#ifdef TCC_TARGET_ARM\n    \"  float-abi                     hard/softfp on arm\\n\"\n#endif\n#ifdef TCC_TARGET_X86_64\n    \"  no-sse                        disable floats on x86_64\\n\"\n#endif\n    \"-Wl,... linker options:\\n\"\n    \"  -nostdlib                     do not link with standard crt/libs\\n\"\n    \"  -[no-]whole-archive           load lib(s) fully/only as needed\\n\"\n    \"  -export-all-symbols           same as -rdynamic\\n\"\n    \"  -export-dynamic               same as -rdynamic\\n\"\n    \"  -image-base= -Ttext=          set base address of executable\\n\"\n    \"  -section-alignment=           set section alignment in executable\\n\"\n#ifdef TCC_TARGET_PE\n    \"  -file-alignment=              set PE file alignment\\n\"\n    \"  -stack=                       set PE stack reserve\\n\"\n    \"  -large-address-aware          set related PE option\\n\"\n    \"  -subsystem=[console/windows]  set PE subsystem\\n\"\n    \"  -oformat=[pe-* binary]        set executable output format\\n\"\n    \"Predefined macros:\\n\"\n    \"  tcc -E -dM - < nul\\n\"\n#else\n    \"  -rpath=                       set dynamic library search path\\n\"\n    \"  -enable-new-dtags             set DT_RUNPATH instead of DT_RPATH\\n\"\n    \"  -soname=                      set DT_SONAME elf tag\\n\"\n#if defined(TCC_TARGET_MACHO)\n    \"  -install_name=                set DT_SONAME elf tag (soname macOS alias)\\n\"\n#endif\n    \"  -Bsymbolic                    set DT_SYMBOLIC elf tag\\n\"\n    \"  -oformat=[elf32/64-* binary]  set executable output format\\n\"\n    \"  -init= -fini= -Map= -as-needed -O   (ignored)\\n\"\n    \"Predefined macros:\\n\"\n    \"  tcc -E -dM - < /dev/null\\n\"\n#endif\n    \"See also the manual for more details.\\n\"\n    ;\n\nstatic const char version[] =\n    \"tcc version \"TCC_VERSION\n#ifdef TCC_GITHASH\n    \" \"TCC_GITHASH\n#endif\n    \" (\"\n#ifdef TCC_TARGET_I386\n        \"i386\"\n#elif defined TCC_TARGET_X86_64\n        \"x86_64\"\n#elif defined TCC_TARGET_C67\n        \"C67\"\n#elif defined TCC_TARGET_ARM\n        \"ARM\"\n# ifdef TCC_ARM_EABI\n        \" eabi\"\n#  ifdef TCC_ARM_HARDFLOAT\n        \"hf\"\n#  endif\n# endif\n#elif defined TCC_TARGET_ARM64\n        \"AArch64\"\n#elif defined TCC_TARGET_RISCV64\n        \"riscv64\"\n#endif\n#ifdef TCC_TARGET_PE\n        \" Windows\"\n#elif defined(TCC_TARGET_MACHO)\n        \" Darwin\"\n#elif TARGETOS_FreeBSD || TARGETOS_FreeBSD_kernel\n        \" FreeBSD\"\n#elif TARGETOS_OpenBSD\n        \" OpenBSD\"\n#elif TARGETOS_NetBSD\n        \" NetBSD\"\n#else\n        \" Linux\"\n#endif\n    \")\\n\"\n    ;\n\nstatic void print_dirs(const char *msg, char **paths, int nb_paths)\n{\n    int i;\n    printf(\"%s:\\n%s\", msg, nb_paths ? \"\" : \"  -\\n\");\n    for(i = 0; i < nb_paths; i++)\n        printf(\"  %s\\n\", paths[i]);\n}\n\nstatic void print_search_dirs(TCCState *s)\n{\n    printf(\"install: %s\\n\", s->tcc_lib_path);\n    /* print_dirs(\"programs\", NULL, 0); */\n    print_dirs(\"include\", s->sysinclude_paths, s->nb_sysinclude_paths);\n    print_dirs(\"libraries\", s->library_paths, s->nb_library_paths);\n    printf(\"libtcc1:\\n  %s/%s\\n\", s->library_paths[0], CONFIG_TCC_CROSSPREFIX TCC_LIBTCC1);\n#if !defined TCC_TARGET_PE && !defined TCC_TARGET_MACHO\n    print_dirs(\"crt\", s->crt_paths, s->nb_crt_paths);\n    printf(\"elfinterp:\\n  %s\\n\",  DEFAULT_ELFINTERP(s));\n#endif\n}\n\nstatic void set_environment(TCCState *s)\n{\n    char * path;\n\n    path = getenv(\"C_INCLUDE_PATH\");\n    if(path != NULL) {\n        tcc_add_sysinclude_path(s, path);\n    }\n    path = getenv(\"CPATH\");\n    if(path != NULL) {\n        tcc_add_include_path(s, path);\n    }\n    path = getenv(\"LIBRARY_PATH\");\n    if(path != NULL) {\n        tcc_add_library_path(s, path);\n    }\n}\n\nstatic char *default_outputfile(TCCState *s, const char *first_file)\n{\n    char buf[1024];\n    char *ext;\n    const char *name = \"a\";\n\n    if (first_file && strcmp(first_file, \"-\"))\n        name = tcc_basename(first_file);\n    snprintf(buf, sizeof(buf), \"%s\", name);\n    ext = tcc_fileextension(buf);\n#ifdef TCC_TARGET_PE\n    if (s->output_type == TCC_OUTPUT_DLL)\n        strcpy(ext, \".dll\");\n    else\n    if (s->output_type == TCC_OUTPUT_EXE)\n        strcpy(ext, \".exe\");\n    else\n#endif\n    if ((s->just_deps || s->output_type == TCC_OUTPUT_OBJ) && !s->option_r && *ext)\n        strcpy(ext, \".o\");\n    else\n        strcpy(buf, \"a.out\");\n    return tcc_strdup(buf);\n}\n\nstatic unsigned getclock_ms(void)\n{\n#ifdef _WIN32\n    return GetTickCount();\n#else\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec*1000 + (tv.tv_usec+500)/1000;\n#endif\n}\n\nint main(int argc0, char **argv0)\n{\n    TCCState *s, *s1;\n    int ret, opt, n = 0, t = 0, done;\n    unsigned start_time = 0, end_time = 0;\n    const char *first_file;\n    int argc; char **argv;\n    FILE *ppfp = stdout;\n\nredo:\n    argc = argc0, argv = argv0;\n    s = s1 = tcc_new();\n#ifdef CONFIG_TCC_SWITCHES /* predefined options */\n    tcc_set_options(s, CONFIG_TCC_SWITCHES);\n#endif\n    opt = tcc_parse_args(s, &argc, &argv, 1);\n    if (opt < 0)\n        return 1;\n\n    if (n == 0) {\n        if (opt == OPT_HELP) {\n            fputs(help, stdout);\n            if (!s->verbose)\n                return 0;\n            ++opt;\n        }\n        if (opt == OPT_HELP2) {\n            fputs(help2, stdout);\n            return 0;\n        }\n        if (opt == OPT_M32 || opt == OPT_M64)\n            return tcc_tool_cross(s, argv, opt);\n        if (s->verbose)\n            printf(\"%s\", version);\n        if (opt == OPT_AR)\n            return tcc_tool_ar(s, argc, argv);\n#ifdef TCC_TARGET_PE\n        if (opt == OPT_IMPDEF)\n            return tcc_tool_impdef(s, argc, argv);\n#endif\n        if (opt == OPT_V)\n            return 0;\n        if (opt == OPT_PRINT_DIRS) {\n            /* initialize search dirs */\n            set_environment(s);\n            tcc_set_output_type(s, TCC_OUTPUT_MEMORY);\n            print_search_dirs(s);\n            return 0;\n        }\n\n        if (s->nb_files == 0) {\n            tcc_error_noabort(\"no input files\");\n        } else if (s->output_type == TCC_OUTPUT_PREPROCESS) {\n            if (s->outfile && 0!=strcmp(\"-\",s->outfile)) {\n                ppfp = fopen(s->outfile, \"wb\");\n                if (!ppfp)\n                    tcc_error_noabort(\"could not write '%s'\", s->outfile);\n            }\n        } else if (s->output_type == TCC_OUTPUT_OBJ && !s->option_r) {\n            if (s->nb_libraries)\n                tcc_error_noabort(\"cannot specify libraries with -c\");\n            else if (s->nb_files > 1 && s->outfile)\n                tcc_error_noabort(\"cannot specify output file with -c many files\");\n        }\n        if (s->nb_errors)\n            return 1;\n        if (s->do_bench)\n            start_time = getclock_ms();\n    }\n\n    set_environment(s);\n    if (s->output_type == 0)\n        s->output_type = TCC_OUTPUT_EXE;\n    tcc_set_output_type(s, s->output_type);\n    s->ppfp = ppfp;\n\n    if ((s->output_type == TCC_OUTPUT_MEMORY\n      || s->output_type == TCC_OUTPUT_PREPROCESS)\n        && (s->dflag & 16)) { /* -dt option */\n        if (t)\n            s->dflag |= 32;\n        s->run_test = ++t;\n        if (n)\n            --n;\n    }\n\n    /* compile or add each files or library */\n    first_file = NULL;\n    do {\n        struct filespec *f = s->files[n];\n        s->filetype = f->type;\n        if (f->type & AFF_TYPE_LIB) {\n            ret = tcc_add_library(s, f->name);\n        } else {\n            if (1 == s->verbose)\n                printf(\"-> %s\\n\", f->name);\n            if (!first_file)\n                first_file = f->name;\n            ret = tcc_add_file(s, f->name);\n        }\n    } while (++n < s->nb_files\n            && 0 == ret\n            && (s->output_type != TCC_OUTPUT_OBJ || s->option_r));\n\n    if (s->do_bench)\n        end_time = getclock_ms();\n\n    if (s->run_test) {\n        t = 0;\n    } else if (s->output_type == TCC_OUTPUT_PREPROCESS) {\n        ;\n    } else if (0 == ret) {\n        if (s->output_type == TCC_OUTPUT_MEMORY) {\n#ifdef TCC_IS_NATIVE\n            ret = tcc_run(s, argc, argv);\n#endif\n        } else {\n            if (!s->outfile)\n                s->outfile = default_outputfile(s, first_file);\n            if (!s->just_deps)\n                ret = tcc_output_file(s, s->outfile);\n            if (!ret && s->gen_deps)\n                gen_makedeps(s, s->outfile, s->deps_outfile);\n        }\n    }\n\n    done = 1;\n    if (t)\n        done = 0; /* run more tests with -dt -run */\n    else if (ret) {\n        if (s->nb_errors)\n            ret = 1;\n        /* else keep the original exit code from tcc_run() */\n    } else if (n < s->nb_files)\n        done = 0; /* compile more files with -c */\n    else if (s->do_bench)\n        tcc_print_stats(s, end_time - start_time);\n\n    tcc_delete(s);\n\n    if (!done)\n        goto redo;\n    if (ppfp && ppfp != stdout)\n        fclose(ppfp);\n    return ret;\n}\n"
        },
        {
          "name": "tcc.h",
          "type": "blob",
          "size": 66.7685546875,
          "content": "/*\n *  TCC - Tiny C Compiler\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef _TCC_H\n#define _TCC_H\n\n#define _GNU_SOURCE\n#define _DARWIN_C_SOURCE\n#include \"config.h\"\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n/* gnu headers use to #define __attribute__ to empty for non-gcc compilers */\n#ifdef __TINYC__\n# undef __attribute__\n#endif\n#include <string.h>\n#include <errno.h>\n#include <math.h>\n#include <fcntl.h>\n#include <setjmp.h>\n#include <time.h>\n\n#ifndef _WIN32\n# include <unistd.h>\n# include <sys/time.h>\n# ifndef CONFIG_TCC_STATIC\n#  include <dlfcn.h>\n# endif\n/* XXX: need to define this to use them in non ISOC99 context */\nextern float strtof (const char *__nptr, char **__endptr);\nextern long double strtold (const char *__nptr, char **__endptr);\n#endif\n\n#ifdef _WIN32\n# define WIN32_LEAN_AND_MEAN 1\n# include <windows.h>\n# include <io.h> /* open, close etc. */\n# include <direct.h> /* getcwd */\n# include <malloc.h> /* alloca */\n# ifdef __GNUC__\n#  include <stdint.h>\n# endif\n# define inline __inline\n# define snprintf _snprintf\n# define vsnprintf _vsnprintf\n# ifndef __GNUC__\n#  define strtold (long double)strtod\n#  define strtof (float)strtod\n#  define strtoll _strtoi64\n#  define strtoull _strtoui64\n# endif\n# ifdef LIBTCC_AS_DLL\n#  define LIBTCCAPI __declspec(dllexport)\n#  define PUB_FUNC LIBTCCAPI\n# endif\n# ifdef _MSC_VER\n#  pragma warning (disable : 4244)  // conversion from 'uint64_t' to 'int', possible loss of data\n#  pragma warning (disable : 4267)  // conversion from 'size_t' to 'int', possible loss of data\n#  pragma warning (disable : 4996)  // The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name\n#  pragma warning (disable : 4018)  // signed/unsigned mismatch\n#  pragma warning (disable : 4146)  // unary minus operator applied to unsigned type, result still unsigned\n#  define ssize_t intptr_t\n#  ifdef _X86_\n#   define __i386__ 1\n#  endif\n#  ifdef _AMD64_\n#   define __x86_64__ 1\n#  endif\n# endif\n# ifndef va_copy\n#  define va_copy(a,b) a = b\n# endif\n#endif\n\n#ifndef O_BINARY\n# define O_BINARY 0\n#endif\n\n#ifndef offsetof\n#define offsetof(type, field) ((size_t) &((type *)0)->field)\n#endif\n\n#ifndef countof\n#define countof(tab) (sizeof(tab) / sizeof((tab)[0]))\n#endif\n\n#ifdef _MSC_VER\n# define NORETURN __declspec(noreturn)\n# define ALIGNED(x) __declspec(align(x))\n# define PRINTF_LIKE(x,y)\n#else\n# define NORETURN __attribute__((noreturn))\n# define ALIGNED(x) __attribute__((aligned(x)))\n# define PRINTF_LIKE(x,y) __attribute__ ((format (printf, (x), (y))))\n#endif\n\n#ifdef _WIN32\n# define IS_DIRSEP(c) (c == '/' || c == '\\\\')\n# define IS_ABSPATH(p) (IS_DIRSEP(p[0]) || (p[0] && p[1] == ':' && IS_DIRSEP(p[2])))\n# define PATHCMP stricmp\n# define PATHSEP \";\"\n#else\n# define IS_DIRSEP(c) (c == '/')\n# define IS_ABSPATH(p) IS_DIRSEP(p[0])\n# define PATHCMP strcmp\n# define PATHSEP \":\"\n#endif\n\n/* -------------------------------------------- */\n\n/* parser debug */\n/* #define PARSE_DEBUG */\n/* preprocessor debug */\n/* #define PP_DEBUG */\n/* include file debug */\n/* #define INC_DEBUG */\n/* memory leak debug (only for single threaded usage) */\n/* #define MEM_DEBUG 1,2,3 */\n/* assembler debug */\n/* #define ASM_DEBUG */\n\n/* target selection */\n/* #define TCC_TARGET_I386   *//* i386 code generator */\n/* #define TCC_TARGET_X86_64 *//* x86-64 code generator */\n/* #define TCC_TARGET_ARM    *//* ARMv4 code generator */\n/* #define TCC_TARGET_ARM64  *//* ARMv8 code generator */\n/* #define TCC_TARGET_C67    *//* TMS320C67xx code generator */\n/* #define TCC_TARGET_RISCV64 *//* risc-v code generator */\n\n/* default target is I386 */\n#if !defined(TCC_TARGET_I386) && !defined(TCC_TARGET_ARM) && \\\n    !defined(TCC_TARGET_ARM64) && !defined(TCC_TARGET_C67) && \\\n    !defined(TCC_TARGET_X86_64) && !defined(TCC_TARGET_RISCV64)\n# if defined __x86_64__\n#  define TCC_TARGET_X86_64\n# elif defined __arm__\n#  define TCC_TARGET_ARM\n#  define TCC_ARM_EABI\n#  define TCC_ARM_VFP\n#  define TCC_ARM_HARDFLOAT\n# elif defined __aarch64__\n#  define TCC_TARGET_ARM64\n# elif defined __riscv\n#  define TCC_TARGET_RISCV64\n# else\n#  define TCC_TARGET_I386\n# endif\n# ifdef _WIN32\n#  define TCC_TARGET_PE 1\n# endif\n# ifdef __APPLE__\n#  define TCC_TARGET_MACHO 1\n# endif\n#endif\n\n/* only native compiler supports -run */\n#if defined _WIN32 == defined TCC_TARGET_PE \\\n    && defined __APPLE__ == defined TCC_TARGET_MACHO\n# if defined __i386__ && defined TCC_TARGET_I386\n#  define TCC_IS_NATIVE\n# elif defined __x86_64__ && defined TCC_TARGET_X86_64\n#  define TCC_IS_NATIVE\n# elif defined __arm__ && defined TCC_TARGET_ARM\n#  define TCC_IS_NATIVE\n# elif defined __aarch64__ && defined TCC_TARGET_ARM64\n#  define TCC_IS_NATIVE\n# elif defined __riscv && defined __LP64__ && defined TCC_TARGET_RISCV64\n#  define TCC_IS_NATIVE\n# endif\n#endif\n\n#if defined CONFIG_TCC_BACKTRACE && CONFIG_TCC_BACKTRACE==0\n# undef CONFIG_TCC_BACKTRACE\n#else\n# define CONFIG_TCC_BACKTRACE 1 /* enable builtin stack backtraces */\n#endif\n\n#if defined CONFIG_TCC_BCHECK && CONFIG_TCC_BCHECK==0\n#  undef CONFIG_TCC_BCHECK\n#else\n#  define CONFIG_TCC_BCHECK 1 /* enable bound checking code */\n#endif\n\n#if defined CONFIG_NEW_MACHO && CONFIG_NEW_MACHO==0\n#  undef CONFIG_NEW_MACHO\n#else\n#  define CONFIG_NEW_MACHO 1 /* enable new macho code */\n#endif\n\n#if defined TARGETOS_OpenBSD \\\n    || defined TARGETOS_FreeBSD \\\n    || defined TARGETOS_NetBSD \\\n    || defined TARGETOS_FreeBSD_kernel\n# define TARGETOS_BSD 1\n#elif !(defined TCC_TARGET_PE || defined TCC_TARGET_MACHO)\n# define TARGETOS_Linux 1 /* for tccdefs_.h */\n#endif\n\n#if defined TCC_TARGET_PE || defined TCC_TARGET_MACHO\n# define ELF_OBJ_ONLY /* create elf .o but native executables */\n#endif\n\n/* No ten-byte long doubles on window and macos except in\n   cross-compilers made by a mingw-GCC */\n#if defined TCC_TARGET_PE \\\n    || (defined TCC_TARGET_MACHO && defined TCC_TARGET_ARM64) \\\n    || (defined _WIN32 && !defined __GNUC__)\n# define TCC_USING_DOUBLE_FOR_LDOUBLE 1\n#endif\n\n#ifdef CONFIG_TCC_PIE\n# define CONFIG_TCC_PIC 1\n#endif\n\n/* support using libtcc from threads */\n#ifndef CONFIG_TCC_SEMLOCK\n# define CONFIG_TCC_SEMLOCK 1\n#endif\n\n/* ------------ path configuration ------------ */\n\n#ifndef CONFIG_SYSROOT\n# define CONFIG_SYSROOT \"\"\n#endif\n#if !defined CONFIG_TCCDIR && !defined _WIN32\n# define CONFIG_TCCDIR \"/usr/local/lib/tcc\"\n#endif\n#ifndef CONFIG_LDDIR\n# define CONFIG_LDDIR \"lib\"\n#endif\n#ifdef CONFIG_TRIPLET\n# define USE_TRIPLET(s) s \"/\" CONFIG_TRIPLET\n# define ALSO_TRIPLET(s) USE_TRIPLET(s) \":\" s\n#else\n# define USE_TRIPLET(s) s\n# define ALSO_TRIPLET(s) s\n#endif\n\n/* path to find crt1.o, crti.o and crtn.o */\n#ifndef CONFIG_TCC_CRTPREFIX\n# define CONFIG_TCC_CRTPREFIX USE_TRIPLET(CONFIG_SYSROOT \"/usr/\" CONFIG_LDDIR)\n#endif\n\n#ifndef CONFIG_USR_INCLUDE\n# define CONFIG_USR_INCLUDE \"/usr/include\"\n#endif\n\n/* Below: {B} is substituted by CONFIG_TCCDIR (rsp. -B option) */\n\n/* system include paths */\n#ifndef CONFIG_TCC_SYSINCLUDEPATHS\n# if defined TCC_TARGET_PE || defined _WIN32\n#  define CONFIG_TCC_SYSINCLUDEPATHS \"{B}/include\"PATHSEP\"{B}/include/winapi\"\n# else\n#  define CONFIG_TCC_SYSINCLUDEPATHS \\\n        \"{B}/include\" \\\n    \":\" ALSO_TRIPLET(CONFIG_SYSROOT \"/usr/local/include\") \\\n    \":\" ALSO_TRIPLET(CONFIG_SYSROOT CONFIG_USR_INCLUDE)\n# endif\n#endif\n\n/* library search paths */\n#ifndef CONFIG_TCC_LIBPATHS\n# if defined TCC_TARGET_PE || defined _WIN32\n#  define CONFIG_TCC_LIBPATHS \"{B}/lib\"\n# else\n#  define CONFIG_TCC_LIBPATHS \\\n        \"{B}\" \\\n    \":\" ALSO_TRIPLET(CONFIG_SYSROOT \"/usr/\" CONFIG_LDDIR) \\\n    \":\" ALSO_TRIPLET(CONFIG_SYSROOT \"/\" CONFIG_LDDIR) \\\n    \":\" ALSO_TRIPLET(CONFIG_SYSROOT \"/usr/local/\" CONFIG_LDDIR)\n# endif\n#endif\n\n/* name of ELF interpreter */\n#ifndef CONFIG_TCC_ELFINTERP\n# if defined __GNU__\n#  define CONFIG_TCC_ELFINTERP \"/lib/ld.so\"\n# elif defined(TCC_TARGET_PE)\n#  define CONFIG_TCC_ELFINTERP \"-\"\n# elif defined TCC_TARGET_ARM64\n#  define CONFIG_TCC_ELFINTERP \"/lib/ld-linux-aarch64.so.1\"\n# elif defined(TCC_TARGET_X86_64)\n#  define CONFIG_TCC_ELFINTERP \"/lib64/ld-linux-x86-64.so.2\"\n# elif defined(TCC_TARGET_RISCV64)\n#  define CONFIG_TCC_ELFINTERP \"/lib/ld-linux-riscv64-lp64d.so.1\"\n# elif defined(TCC_ARM_EABI)\n#  define DEFAULT_ELFINTERP(s) default_elfinterp(s)\n# else\n#  define CONFIG_TCC_ELFINTERP \"/lib/ld-linux.so.2\"\n# endif\n#endif\n\n/* var elf_interp dans *-gen.c */\n#ifndef DEFAULT_ELFINTERP\n# define DEFAULT_ELFINTERP(s) CONFIG_TCC_ELFINTERP\n#endif\n\n/* (target specific) libtcc1.a */\n#ifndef TCC_LIBTCC1\n# define TCC_LIBTCC1 \"libtcc1.a\"\n#endif\n\n/* library to use with CONFIG_USE_LIBGCC instead of libtcc1.a */\n#if defined CONFIG_USE_LIBGCC && !defined TCC_LIBGCC\n#define TCC_LIBGCC USE_TRIPLET(CONFIG_SYSROOT \"/\" CONFIG_LDDIR) \"/libgcc_s.so.1\"\n#endif\n\n/* <cross-prefix-to->libtcc1.a */\n#ifndef CONFIG_TCC_CROSSPREFIX\n# define CONFIG_TCC_CROSSPREFIX \"\"\n#endif\n\n/* -------------------------------------------- */\n\n#include \"libtcc.h\"\n#include \"elf.h\"\n#include \"stab.h\"\n#include \"dwarf.h\"\n\n/* -------------------------------------------- */\n\n#ifndef PUB_FUNC /* functions used by tcc.c but not in libtcc.h */\n# define PUB_FUNC\n#endif\n\n#ifndef ONE_SOURCE\n# define ONE_SOURCE 0\n#endif\n\n#if ONE_SOURCE\n#define ST_INLN static inline\n#define ST_FUNC static\n#define ST_DATA static\n#else\n#define ST_INLN\n#define ST_FUNC\n#define ST_DATA extern\n#endif\n\n#ifdef TCC_PROFILE /* profile all functions */\n# define static\n# define inline\n#endif\n\n/* -------------------------------------------- */\n/* include the target specific definitions */\n\n#define TARGET_DEFS_ONLY\n#ifdef TCC_TARGET_I386\n# include \"i386-gen.c\"\n# include \"i386-link.c\"\n#elif defined TCC_TARGET_X86_64\n# include \"x86_64-gen.c\"\n# include \"x86_64-link.c\"\n#elif defined TCC_TARGET_ARM\n# include \"arm-gen.c\"\n# include \"arm-link.c\"\n# include \"arm-asm.c\"\n#elif defined TCC_TARGET_ARM64\n# include \"arm64-gen.c\"\n# include \"arm64-link.c\"\n# include \"arm-asm.c\"\n#elif defined TCC_TARGET_C67\n# define TCC_TARGET_COFF\n# include \"coff.h\"\n# include \"c67-gen.c\"\n# include \"c67-link.c\"\n#elif defined(TCC_TARGET_RISCV64)\n# include \"riscv64-gen.c\"\n# include \"riscv64-link.c\"\n# include \"riscv64-asm.c\"\n#else\n#error unknown target\n#endif\n#undef TARGET_DEFS_ONLY\n\n/* -------------------------------------------- */\n\n#if PTR_SIZE == 8\n# define ELFCLASSW ELFCLASS64\n# define ElfW(type) Elf##64##_##type\n# define ELFW(type) ELF##64##_##type\n# define ElfW_Rel ElfW(Rela)\n# define SHT_RELX SHT_RELA\n# define REL_SECTION_FMT \".rela%s\"\n#else\n# define ELFCLASSW ELFCLASS32\n# define ElfW(type) Elf##32##_##type\n# define ELFW(type) ELF##32##_##type\n# define ElfW_Rel ElfW(Rel)\n# define SHT_RELX SHT_REL\n# define REL_SECTION_FMT \".rel%s\"\n#endif\n/* target address type */\n#define addr_t ElfW(Addr)\n#define ElfSym ElfW(Sym)\n\n#if PTR_SIZE == 8 && !defined TCC_TARGET_PE\n# define LONG_SIZE 8\n#else\n# define LONG_SIZE 4\n#endif\n\n/* -------------------------------------------- */\n\n#define INCLUDE_STACK_SIZE  32\n#define IFDEF_STACK_SIZE    64\n#define VSTACK_SIZE         512\n#define STRING_MAX_SIZE     1024\n#define TOKSTR_MAX_SIZE     256\n#define PACK_STACK_SIZE     8\n\n#define TOK_HASH_SIZE       16384 /* must be a power of two */\n#define TOK_ALLOC_INCR      512  /* must be a power of two */\n#define TOK_MAX_SIZE        4 /* token max size in int unit when stored in string */\n\n/* token symbol management */\ntypedef struct TokenSym {\n    struct TokenSym *hash_next;\n    struct Sym *sym_define; /* direct pointer to define */\n    struct Sym *sym_label; /* direct pointer to label */\n    struct Sym *sym_struct; /* direct pointer to structure */\n    struct Sym *sym_identifier; /* direct pointer to identifier */\n    int tok; /* token number */\n    int len;\n    char str[1];\n} TokenSym;\n\n#ifdef TCC_TARGET_PE\ntypedef unsigned short nwchar_t;\n#else\ntypedef int nwchar_t;\n#endif\n\ntypedef struct CString {\n    int size; /* size in bytes */\n    int size_allocated;\n    char *data; /* nwchar_t* in cases */\n} CString;\n\n/* type definition */\ntypedef struct CType {\n    int t;\n    struct Sym *ref;\n} CType;\n\n/* constant value */\ntypedef union CValue {\n    long double ld;\n    double d;\n    float f;\n    uint64_t i;\n    struct {\n        char *data;\n        int size;\n    } str;\n    int tab[LDOUBLE_SIZE/4];\n} CValue;\n\n/* value on stack */\ntypedef struct SValue {\n    CType type;      /* type */\n    unsigned short r;      /* register + flags */\n    unsigned short r2;     /* second register, used for 'long long'\n                              type. If not used, set to VT_CONST */\n    union {\n      struct { int jtrue, jfalse; }; /* forward jmps */\n      CValue c;         /* constant, if VT_CONST */\n    };\n    union {\n      struct { unsigned short cmp_op, cmp_r; }; /* VT_CMP operation */\n      struct Sym *sym;  /* symbol, if (VT_SYM | VT_CONST), or if */\n    };                  /* result of unary() for an identifier. */\n\n} SValue;\n\n/* symbol attributes */\nstruct SymAttr {\n    unsigned short\n    aligned     : 5, /* alignment as log2+1 (0 == unspecified) */\n    packed      : 1,\n    weak        : 1,\n    visibility  : 2,\n    dllexport   : 1,\n    nodecorate  : 1,\n    dllimport   : 1,\n    addrtaken   : 1,\n    nodebug     : 1,\n    xxxx        : 2; /* not used */\n};\n\n/* function attributes or temporary attributes for parsing */\nstruct FuncAttr {\n    unsigned\n    func_call   : 3, /* calling convention (0..5), see below */\n    func_type   : 2, /* FUNC_OLD/NEW/ELLIPSIS */\n    func_noreturn : 1, /* attribute((noreturn)) */\n    func_ctor   : 1, /* attribute((constructor)) */\n    func_dtor   : 1, /* attribute((destructor)) */\n    func_args   : 8, /* PE __stdcall args */\n    func_alwinl : 1, /* always_inline */\n    xxxx        : 15;\n};\n\n/* symbol management */\ntypedef struct Sym {\n    int v; /* symbol token */\n    unsigned short r; /* associated register or VT_CONST/VT_LOCAL and LVAL type */\n    struct SymAttr a; /* symbol attributes */\n    union {\n        struct {\n            int c; /* associated number or Elf symbol index */\n            union {\n                int sym_scope; /* scope level for locals */\n                int jnext; /* next jump label */\n                int jind; /* label position */\n                struct FuncAttr f; /* function attributes */\n                int auxtype; /* bitfield access type */\n            };\n        };\n        long long enum_val; /* enum constant if IS_ENUM_VAL */\n        int *d; /* define token stream */\n        struct Sym *cleanup_func;\n    };\n\n    CType type; /* associated type */\n    union {\n        struct Sym *next; /* next related symbol (for fields and anoms) */\n        int *e; /* expanded token stream */\n        int asm_label; /* associated asm label */\n        struct Sym *cleanupstate; /* in defined labels */\n        int *vla_array_str; /* vla array code */\n    };\n    struct Sym *prev; /* prev symbol in stack */\n    struct Sym *prev_tok; /* previous symbol for this token */\n} Sym;\n\n/* section definition */\ntypedef struct Section {\n    unsigned long data_offset; /* current data offset */\n    unsigned char *data;       /* section data */\n    unsigned long data_allocated; /* used for realloc() handling */\n    TCCState *s1;\n    int sh_name;             /* elf section name (only used during output) */\n    int sh_num;              /* elf section number */\n    int sh_type;             /* elf section type */\n    int sh_flags;            /* elf section flags */\n    int sh_info;             /* elf section info */\n    int sh_addralign;        /* elf section alignment */\n    int sh_entsize;          /* elf entry size */\n    unsigned long sh_size;   /* section size (only used during output) */\n    addr_t sh_addr;          /* address at which the section is relocated */\n    unsigned long sh_offset; /* file offset */\n    int nb_hashed_syms;      /* used to resize the hash table */\n    struct Section *link;    /* link to another section */\n    struct Section *reloc;   /* corresponding section for relocation, if any */\n    struct Section *hash;    /* hash table for symbols */\n    struct Section *prev;    /* previous section on section stack */\n    char name[1];           /* section name */\n} Section;\n\ntypedef struct DLLReference {\n    int level;\n    void *handle;\n    unsigned char found, index;\n    char name[1];\n} DLLReference;\n\n/* -------------------------------------------------- */\n\n#define SYM_STRUCT     0x40000000 /* struct/union/enum symbol space */\n#define SYM_FIELD      0x20000000 /* struct/union field symbol space */\n#define SYM_FIRST_ANOM 0x10000000 /* first anonymous sym */\n\n/* stored in 'Sym->f.func_type' field */\n#define FUNC_NEW       1 /* ansi function prototype */\n#define FUNC_OLD       2 /* old function prototype */\n#define FUNC_ELLIPSIS  3 /* ansi function prototype with ... */\n\n/* stored in 'Sym->f.func_call' field */\n#define FUNC_CDECL     0 /* standard c call */\n#define FUNC_STDCALL   1 /* pascal c call */\n#define FUNC_FASTCALL1 2 /* first param in %eax */\n#define FUNC_FASTCALL2 3 /* first parameters in %eax, %edx */\n#define FUNC_FASTCALL3 4 /* first parameter in %eax, %edx, %ecx */\n#define FUNC_FASTCALLW 5 /* first parameter in %ecx, %edx */\n#define FUNC_THISCALL  6 /* first param in %ecx */\n\n/* field 'Sym.t' for macros */\n#define MACRO_OBJ      0 /* object like macro */\n#define MACRO_FUNC     1 /* function like macro */\n#define MACRO_JOIN     2 /* macro uses ## */\n\n/* field 'Sym.r' for C labels */\n#define LABEL_DEFINED  0 /* label is defined */\n#define LABEL_FORWARD  1 /* label is forward defined */\n#define LABEL_DECLARED 2 /* label is declared but never used */\n#define LABEL_GONE     3 /* label isn't in scope, but not yet popped\n                            from local_label_stack (stmt exprs) */\n\n/* type_decl() types */\n#define TYPE_ABSTRACT  1 /* type without variable */\n#define TYPE_DIRECT    2 /* type with variable */\n#define TYPE_PARAM     4 /* type declares function parameter */\n#define TYPE_NEST      8 /* nested call to post_type */\n\n#define IO_BUF_SIZE 8192\n\ntypedef struct BufferedFile {\n    uint8_t *buf_ptr;\n    uint8_t *buf_end;\n    int fd;\n    struct BufferedFile *prev;\n    int line_num;    /* current line number - here to simplify code */\n    int line_ref;    /* tcc -E: last printed line */\n    int ifndef_macro;  /* #ifndef macro / #endif search */\n    int ifndef_macro_saved; /* saved ifndef_macro */\n    int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */\n    int include_next_index; /* next search path */\n    int prev_tok_flags; /* saved tok_flags */\n    char filename[1024];    /* filename */\n    char *true_filename; /* filename not modified by # line directive */\n    unsigned char unget[4];\n    unsigned char buffer[1]; /* extra size for CH_EOB char */\n} BufferedFile;\n\n#define CH_EOB   '\\\\'       /* end of buffer or '\\0' char in file */\n#define CH_EOF   (-1)   /* end of file */\n\n/* used to record tokens */\ntypedef struct TokenString {\n    int *str;\n    int len;\n    int need_spc;\n    int allocated_len;\n    int last_line_num;\n    int save_line_num;\n    /* used to chain token-strings with begin/end_macro() */\n    struct TokenString *prev;\n    const int *prev_ptr;\n    char alloc;\n} TokenString;\n\n/* GNUC attribute definition */\ntypedef struct AttributeDef {\n    struct SymAttr a;\n    struct FuncAttr f;\n    struct Section *section;\n    Sym *cleanup_func;\n    int alias_target; /* token */\n    int asm_label; /* associated asm label */\n    char attr_mode; /* __attribute__((__mode__(...))) */\n} AttributeDef;\n\n/* inline functions */\ntypedef struct InlineFunc {\n    TokenString *func_str;\n    Sym *sym;\n    char filename[1];\n} InlineFunc;\n\n/* include file cache, used to find files faster and also to eliminate\n   inclusion if the include file is protected by #ifndef ... #endif */\ntypedef struct CachedInclude {\n    int ifndef_macro;\n    int once;\n    int hash_next; /* -1 if none */\n    char filename[1]; /* path specified in #include */\n} CachedInclude;\n\n#define CACHED_INCLUDES_HASH_SIZE 32\n\n#ifdef CONFIG_TCC_ASM\ntypedef struct ExprValue {\n    uint64_t v;\n    Sym *sym;\n    int pcrel;\n} ExprValue;\n\n#define MAX_ASM_OPERANDS 30\ntypedef struct ASMOperand {\n    int id; /* GCC 3 optional identifier (0 if number only supported) */\n    char constraint[16];\n    char asm_str[16]; /* computed asm string for operand */\n    SValue *vt; /* C value of the expression */\n    int ref_index; /* if >= 0, gives reference to a output constraint */\n    int input_index; /* if >= 0, gives reference to an input constraint */\n    int priority; /* priority, used to assign registers */\n    int reg; /* if >= 0, register number used for this operand */\n    int is_llong; /* true if double register value */\n    int is_memory; /* true if memory operand */\n    int is_rw;     /* for '+' modifier */\n    int is_label;  /* for asm goto */\n} ASMOperand;\n#endif\n\n/* extra symbol attributes (not in symbol table) */\nstruct sym_attr {\n    unsigned got_offset;\n    unsigned plt_offset;\n    int plt_sym;\n    int dyn_index;\n#ifdef TCC_TARGET_ARM\n    unsigned char plt_thumb_stub:1;\n#endif\n};\n\nstruct TCCState {\n    unsigned char verbose; /* if true, display some information during compilation */\n    unsigned char nostdinc; /* if true, no standard headers are added */\n    unsigned char nostdlib; /* if true, no standard libraries are added */\n    unsigned char nocommon; /* if true, do not use common symbols for .bss data */\n    unsigned char static_link; /* if true, static linking is performed */\n    unsigned char rdynamic; /* if true, all symbols are exported */\n    unsigned char symbolic; /* if true, resolve symbols in the current module first */\n    unsigned char filetype; /* file type for compilation (NONE,C,ASM) */\n    unsigned char optimize; /* only to #define __OPTIMIZE__ */\n    unsigned char option_pthread; /* -pthread option */\n    unsigned char enable_new_dtags; /* -Wl,--enable-new-dtags */\n    unsigned int  cversion; /* supported C ISO version, 199901 (the default), 201112, ... */\n\n    /* C language options */\n    unsigned char char_is_unsigned;\n    unsigned char leading_underscore;\n    unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */\n    unsigned char dollars_in_identifiers;  /* allows '$' char in identifiers */\n    unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */\n    unsigned char reverse_funcargs; /* if true, evaluate last function arg first */\n    unsigned char gnu89_inline; /* treat 'extern inline' like 'static inline' */\n    unsigned char unwind_tables; /* create eh_frame section */\n\n    /* warning switches */\n    unsigned char warn_none;\n    unsigned char warn_all;\n    unsigned char warn_error;\n    unsigned char warn_write_strings;\n    unsigned char warn_unsupported;\n    unsigned char warn_implicit_function_declaration;\n    unsigned char warn_discarded_qualifiers;\n    #define WARN_ON  1 /* warning is on (-Woption) */\n    unsigned char warn_num; /* temp var for tcc_warning_c() */\n\n    unsigned char option_r; /* option -r */\n    unsigned char do_bench; /* option -bench */\n    unsigned char just_deps; /* option -M  */\n    unsigned char gen_deps; /* option -MD  */\n    unsigned char include_sys_deps; /* option -MD  */\n    unsigned char gen_phony_deps; /* option -MP */\n\n    /* compile with debug symbol (and use them if error during execution) */\n    unsigned char do_debug;\n    unsigned char dwarf;\n    unsigned char do_backtrace;\n#ifdef CONFIG_TCC_BCHECK\n    /* compile with built-in memory and bounds checker */\n    unsigned char do_bounds_check;\n#endif\n    unsigned char test_coverage;  /* generate test coverage code */\n\n    /* use GNU C extensions */\n    unsigned char gnu_ext;\n    /* use TinyCC extensions */\n    unsigned char tcc_ext;\n\n    unsigned char dflag; /* -dX value */\n    unsigned char Pflag; /* -P switch (LINE_MACRO_OUTPUT_FORMAT) */\n\n#ifdef TCC_TARGET_X86_64\n    unsigned char nosse; /* For -mno-sse support. */\n#endif\n#ifdef TCC_TARGET_ARM\n    unsigned char float_abi; /* float ABI of the generated code*/\n#endif\n\n    unsigned char has_text_addr;\n    addr_t text_addr; /* address of text section */\n    unsigned section_align; /* section alignment */\n#ifdef TCC_TARGET_I386\n    int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */\n#endif\n\n    char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */\n    char *soname; /* as specified on the command line (-soname) */\n    char *rpath; /* as specified on the command line (-Wl,-rpath=) */\n    char *elf_entryname; /* \"_start\" unless set */\n    char *init_symbol; /* symbols to call at load-time (not used currently) */\n    char *fini_symbol; /* symbols to call at unload-time (not used currently) */\n    char *mapfile; /* create a mapfile (not used currently) */\n\n    /* output type, see TCC_OUTPUT_XXX */\n    int output_type;\n    /* output format, see TCC_OUTPUT_FORMAT_xxx */\n    int output_format;\n    /* nth test to run with -dt -run */\n    int run_test;\n\n    /* array of all loaded dlls (including those referenced by loaded dlls) */\n    DLLReference **loaded_dlls;\n    int nb_loaded_dlls;\n\n    /* include paths */\n    char **include_paths;\n    int nb_include_paths;\n\n    char **sysinclude_paths;\n    int nb_sysinclude_paths;\n\n    /* library paths */\n    char **library_paths;\n    int nb_library_paths;\n\n    /* crt?.o object path */\n    char **crt_paths;\n    int nb_crt_paths;\n\n    /* -D / -U options */\n    CString cmdline_defs;\n    /* -include options */\n    CString cmdline_incl;\n\n    /* error handling */\n    void *error_opaque;\n    void (*error_func)(void *opaque, const char *msg);\n    int error_set_jmp_enabled;\n    jmp_buf error_jmp_buf;\n    int nb_errors;\n\n    /* output file for preprocessing (-E) */\n    FILE *ppfp;\n\n    /* for -MD/-MF: collected dependencies for this compilation */\n    char **target_deps;\n    int nb_target_deps;\n\n    /* compilation */\n    BufferedFile *include_stack[INCLUDE_STACK_SIZE];\n    BufferedFile **include_stack_ptr;\n\n    int ifdef_stack[IFDEF_STACK_SIZE];\n    int *ifdef_stack_ptr;\n\n    /* included files enclosed with #ifndef MACRO */\n    int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE];\n    CachedInclude **cached_includes;\n    int nb_cached_includes;\n\n    /* #pragma pack stack */\n    int pack_stack[PACK_STACK_SIZE];\n    int *pack_stack_ptr;\n    char **pragma_libs;\n    int nb_pragma_libs;\n\n    /* inline functions are stored as token lists and compiled last\n       only if referenced */\n    struct InlineFunc **inline_fns;\n    int nb_inline_fns;\n\n    /* sections */\n    Section **sections;\n    int nb_sections; /* number of sections, including first dummy section */\n\n    Section **priv_sections;\n    int nb_priv_sections; /* number of private sections */\n\n    /* predefined sections */\n    Section *text_section, *data_section, *rodata_section, *bss_section;\n    Section *common_section;\n    Section *cur_text_section; /* current section where function code is generated */\n#ifdef CONFIG_TCC_BCHECK\n    /* bound check related sections */\n    Section *bounds_section; /* contains global data bound description */\n    Section *lbounds_section; /* contains local data bound description */\n#endif\n    /* symbol section */\n    union { Section *symtab_section, *symtab; }; /* historical alias */\n    /* temporary dynamic symbol sections (for dll loading) */\n    Section *dynsymtab_section;\n    /* exported dynamic symbol section */\n    Section *dynsym;\n    /* got & plt handling */\n    Section *got, *plt;\n    /* exception handling */\n    Section *eh_frame_section;\n    Section *eh_frame_hdr_section;\n    unsigned long eh_start;\n    /* debug sections */\n    Section *stab_section;\n    Section *dwarf_info_section;\n    Section *dwarf_abbrev_section;\n    Section *dwarf_line_section;\n    Section *dwarf_aranges_section;\n    Section *dwarf_str_section;\n    Section *dwarf_line_str_section;\n    int dwlo, dwhi; /* dwarf section range */\n    /* test coverage */\n    Section *tcov_section;\n    /* debug state */\n    struct _tccdbg *dState;\n\n    /* Is there a new undefined sym since last new_undef_sym() */\n    int new_undef_sym;\n    /* extra attributes (eg. GOT/PLT value) for symtab symbols */\n    struct sym_attr *sym_attrs;\n    int nb_sym_attrs;\n    /* ptr to next reloc entry reused */\n    ElfW_Rel *qrel;\n    #define qrel s1->qrel\n\n#ifdef TCC_TARGET_RISCV64\n    struct pcrel_hi { addr_t addr, val; } last_hi;\n    #define last_hi s1->last_hi\n#endif\n\n#ifdef TCC_TARGET_PE\n    /* PE info */\n    int pe_subsystem;\n    unsigned pe_characteristics;\n    unsigned pe_file_align;\n    unsigned pe_stack_size;\n    addr_t pe_imagebase;\n# ifdef TCC_TARGET_X86_64\n    Section *uw_pdata;\n    int uw_sym;\n    unsigned uw_offs;\n# endif\n#endif\n\n#if defined TCC_TARGET_MACHO\n    char *install_name;\n    uint32_t compatibility_version;\n    uint32_t current_version;\n#endif\n\n#ifndef ELF_OBJ_ONLY\n    int nb_sym_versions;\n    struct sym_version *sym_versions;\n    int nb_sym_to_version;\n    int *sym_to_version;\n    int dt_verneednum;\n    Section *versym_section;\n    Section *verneed_section;\n#endif\n\n#ifdef TCC_IS_NATIVE\n    const char *run_main; /* entry for tcc_run() */\n    void *run_ptr; /* runtime_memory */\n    unsigned run_size; /* size of runtime_memory  */\n#ifdef _WIN64\n    void *run_function_table; /* unwind data */\n#endif\n    struct TCCState *next;\n    struct rt_context *rc; /* pointer to backtrace info block */\n    void *run_lj, *run_jb; /* sj/lj for tcc_setjmp()/tcc_run() */\n    TCCBtFunc *bt_func;\n    void *bt_data;\n#endif\n\n#ifdef CONFIG_TCC_BACKTRACE\n    int rt_num_callers;\n#endif\n\n    /* benchmark info */\n    int total_idents;\n    int total_lines;\n    unsigned int total_bytes;\n    unsigned int total_output[4];\n\n    /* option -dnum (for general development purposes) */\n    int g_debug;\n\n    /* used by tcc_load_ldscript */\n    int fd, cc;\n\n    /* for warnings/errors for object files */\n    const char *current_filename;\n\n    /* used by main and tcc_parse_args only */\n    struct filespec **files; /* files seen on command line */\n    int nb_files; /* number thereof */\n    int nb_libraries; /* number of libs thereof */\n    char *outfile; /* output filename */\n    char *deps_outfile; /* option -MF */\n    int argc;\n    char **argv;\n    CString linker_arg; /* collect -Wl options */\n};\n\nstruct filespec {\n    char type;\n    char name[1];\n};\n\n/* The current value can be: */\n#define VT_VALMASK   0x003f  /* mask for value location, register or: */\n#define VT_CONST     0x0030  /* constant in vc (must be first non register value) */\n#define VT_LLOCAL    0x0031  /* lvalue, offset on stack */\n#define VT_LOCAL     0x0032  /* offset on stack */\n#define VT_CMP       0x0033  /* the value is stored in processor flags (in vc) */\n#define VT_JMP       0x0034  /* value is the consequence of jmp true (even) */\n#define VT_JMPI      0x0035  /* value is the consequence of jmp false (odd) */\n#define VT_LVAL      0x0100  /* var is an lvalue */\n#define VT_SYM       0x0200  /* a symbol value is added */\n#define VT_MUSTCAST  0x0C00  /* value must be casted to be correct (used for\n                                char/short stored in integer registers) */\n#define VT_NONCONST  0x1000  /* VT_CONST, but not an (C standard) integer\n                                constant expression */\n#define VT_MUSTBOUND 0x4000  /* bound checking must be done before\n                                dereferencing value */\n#define VT_BOUNDED   0x8000  /* value is bounded. The address of the\n                                bounding function call point is in vc */\n/* types */\n#define VT_BTYPE       0x000f  /* mask for basic type */\n#define VT_VOID             0  /* void type */\n#define VT_BYTE             1  /* signed byte type */\n#define VT_SHORT            2  /* short type */\n#define VT_INT              3  /* integer type */\n#define VT_LLONG            4  /* 64 bit integer */\n#define VT_PTR              5  /* pointer */\n#define VT_FUNC             6  /* function type */\n#define VT_STRUCT           7  /* struct/union definition */\n#define VT_FLOAT            8  /* IEEE float */\n#define VT_DOUBLE           9  /* IEEE double */\n#define VT_LDOUBLE         10  /* IEEE long double */\n#define VT_BOOL            11  /* ISOC99 boolean type */\n#define VT_QLONG           13  /* 128-bit integer. Only used for x86-64 ABI */\n#define VT_QFLOAT          14  /* 128-bit float. Only used for x86-64 ABI */\n\n#define VT_UNSIGNED    0x0010  /* unsigned type */\n#define VT_DEFSIGN     0x0020  /* explicitly signed or unsigned */\n#define VT_ARRAY       0x0040  /* array type (also has VT_PTR) */\n#define VT_BITFIELD    0x0080  /* bitfield modifier */\n#define VT_CONSTANT    0x0100  /* const modifier */\n#define VT_VOLATILE    0x0200  /* volatile modifier */\n#define VT_VLA         0x0400  /* VLA type (also has VT_PTR and VT_ARRAY) */\n#define VT_LONG        0x0800  /* long type (also has VT_INT rsp. VT_LLONG) */\n\n/* storage */\n#define VT_EXTERN  0x00001000  /* extern definition */\n#define VT_STATIC  0x00002000  /* static variable */\n#define VT_TYPEDEF 0x00004000  /* typedef definition */\n#define VT_INLINE  0x00008000  /* inline definition */\n/* currently unused: 0x000[1248]0000  */\n\n#define VT_STRUCT_SHIFT 20     /* shift for bitfield shift values (32 - 2*6) */\n#define VT_STRUCT_MASK (((1U << (6+6)) - 1) << VT_STRUCT_SHIFT | VT_BITFIELD)\n#define BIT_POS(t) (((t) >> VT_STRUCT_SHIFT) & 0x3f)\n#define BIT_SIZE(t) (((t) >> (VT_STRUCT_SHIFT + 6)) & 0x3f)\n\n#define VT_UNION    (1 << VT_STRUCT_SHIFT | VT_STRUCT)\n#define VT_ENUM     (2 << VT_STRUCT_SHIFT) /* integral type is an enum really */\n#define VT_ENUM_VAL (3 << VT_STRUCT_SHIFT) /* integral type is an enum constant really */\n\n#define IS_ENUM(t) ((t & VT_STRUCT_MASK) == VT_ENUM)\n#define IS_ENUM_VAL(t) ((t & VT_STRUCT_MASK) == VT_ENUM_VAL)\n#define IS_UNION(t) ((t & (VT_STRUCT_MASK|VT_BTYPE)) == VT_UNION)\n\n#define VT_ATOMIC   VT_VOLATILE\n\n/* type mask (except storage) */\n#define VT_STORAGE (VT_EXTERN | VT_STATIC | VT_TYPEDEF | VT_INLINE)\n#define VT_TYPE (~(VT_STORAGE|VT_STRUCT_MASK))\n\n/* symbol was created by tccasm.c first */\n#define VT_ASM (VT_VOID | 1 << VT_STRUCT_SHIFT)\n#define VT_ASM_FUNC (VT_ASM | 2 << VT_STRUCT_SHIFT)\n#define IS_ASM_SYM(sym) (((sym)->type.t & (VT_BTYPE | VT_ASM)) == VT_ASM)\n\n/* general: set/get the pseudo-bitfield value for bit-mask M */\n#define BFVAL(M,N) ((unsigned)((M) & ~((M) << 1)) * (N))\n#define BFGET(X,M) (((X) & (M)) / BFVAL(M,1))\n#define BFSET(X,M,N) ((X) = ((X) & ~(M)) | BFVAL(M,N))\n\n/* token values */\n\n/* conditional ops */\n#define TOK_LAND  0x90\n#define TOK_LOR   0x91\n/* warning: the following compare tokens depend on i386 asm code */\n#define TOK_ULT 0x92\n#define TOK_UGE 0x93\n#define TOK_EQ  0x94\n#define TOK_NE  0x95\n#define TOK_ULE 0x96\n#define TOK_UGT 0x97\n#define TOK_Nset 0x98\n#define TOK_Nclear 0x99\n#define TOK_LT  0x9c\n#define TOK_GE  0x9d\n#define TOK_LE  0x9e\n#define TOK_GT  0x9f\n\n#define TOK_ISCOND(t) (t >= TOK_LAND && t <= TOK_GT)\n\n#define TOK_DEC     0x80 /* -- */\n#define TOK_MID     0x81 /* inc/dec, to void constant */\n#define TOK_INC     0x82 /* ++ */\n#define TOK_UDIV    0x83 /* unsigned division */\n#define TOK_UMOD    0x84 /* unsigned modulo */\n#define TOK_PDIV    0x85 /* fast division with undefined rounding for pointers */\n#define TOK_UMULL   0x86 /* unsigned 32x32 -> 64 mul */\n#define TOK_ADDC1   0x87 /* add with carry generation */\n#define TOK_ADDC2   0x88 /* add with carry use */\n#define TOK_SUBC1   0x89 /* add with carry generation */\n#define TOK_SUBC2   0x8a /* add with carry use */\n#define TOK_SHL     '<' /* shift left */\n#define TOK_SAR     '>' /* signed shift right */\n#define TOK_SHR     0x8b /* unsigned shift right */\n#define TOK_NEG     TOK_MID /* unary minus operation (for floats) */\n\n#define TOK_ARROW   0xa0 /* -> */\n#define TOK_DOTS    0xa1 /* three dots */\n#define TOK_TWODOTS 0xa2 /* C++ token ? */\n#define TOK_TWOSHARPS 0xa3 /* ## preprocessing token */\n#define TOK_PLCHLDR 0xa4 /* placeholder token as defined in C99 */\n#define TOK_PPJOIN  (TOK_TWOSHARPS | SYM_FIELD) /* A '##' in a macro to mean pasting */\n#define TOK_SOTYPE  0xa7 /* alias of '(' for parsing sizeof (type) */\n\n/* assignment operators */\n#define TOK_A_ADD   0xb0\n#define TOK_A_SUB   0xb1\n#define TOK_A_MUL   0xb2\n#define TOK_A_DIV   0xb3\n#define TOK_A_MOD   0xb4\n#define TOK_A_AND   0xb5\n#define TOK_A_OR    0xb6\n#define TOK_A_XOR   0xb7\n#define TOK_A_SHL   0xb8\n#define TOK_A_SAR   0xb9\n\n#define TOK_ASSIGN(t) (t >= TOK_A_ADD && t <= TOK_A_SAR)\n#define TOK_ASSIGN_OP(t) (\"+-*/%&|^<>\"[t - TOK_A_ADD])\n\n/* tokens that carry values (in additional token string space / tokc) --> */\n#define TOK_CCHAR   0xc0 /* char constant in tokc */\n#define TOK_LCHAR   0xc1\n#define TOK_CINT    0xc2 /* number in tokc */\n#define TOK_CUINT   0xc3 /* unsigned int constant */\n#define TOK_CLLONG  0xc4 /* long long constant */\n#define TOK_CULLONG 0xc5 /* unsigned long long constant */\n#define TOK_CLONG   0xc6 /* long constant */\n#define TOK_CULONG  0xc7 /* unsigned long constant */\n#define TOK_STR     0xc8 /* pointer to string in tokc */\n#define TOK_LSTR    0xc9\n#define TOK_CFLOAT  0xca /* float constant */\n#define TOK_CDOUBLE 0xcb /* double constant */\n#define TOK_CLDOUBLE 0xcc /* long double constant */\n#define TOK_PPNUM   0xcd /* preprocessor number */\n#define TOK_PPSTR   0xce /* preprocessor string */\n#define TOK_LINENUM 0xcf /* line number info */\n\n#define TOK_HAS_VALUE(t) (t >= TOK_CCHAR && t <= TOK_LINENUM)\n\n#define TOK_EOF       (-1)  /* end of file */\n#define TOK_LINEFEED  10    /* line feed */\n\n/* all identifiers and strings have token above that */\n#define TOK_IDENT 256\n\nenum tcc_token {\n    TOK_LAST = TOK_IDENT - 1\n#define DEF(id, str) ,id\n#include \"tcctok.h\"\n#undef DEF\n};\n\n/* keywords: tok >= TOK_IDENT && tok < TOK_UIDENT */\n#define TOK_UIDENT TOK_DEFINE\n\n/* ------------ libtcc.c ------------ */\n\nST_DATA struct TCCState *tcc_state;\nST_DATA void** stk_data;\nST_DATA int nb_stk_data;\n\n/* public functions currently used by the tcc main function */\nST_FUNC char *pstrcpy(char *buf, size_t buf_size, const char *s);\nST_FUNC char *pstrcat(char *buf, size_t buf_size, const char *s);\nST_FUNC char *pstrncpy(char *out, const char *in, size_t num);\nPUB_FUNC char *tcc_basename(const char *name);\nPUB_FUNC char *tcc_fileextension (const char *name);\n\n/* all allocations - even MEM_DEBUG - use these */\nPUB_FUNC void tcc_free(void *ptr);\nPUB_FUNC void *tcc_malloc(unsigned long size);\nPUB_FUNC void *tcc_mallocz(unsigned long size);\nPUB_FUNC void *tcc_realloc(void *ptr, unsigned long size);\nPUB_FUNC char *tcc_strdup(const char *str);\n\n#ifdef MEM_DEBUG\n#define tcc_free(ptr)           tcc_free_debug(ptr)\n#define tcc_malloc(size)        tcc_malloc_debug(size, __FILE__, __LINE__)\n#define tcc_mallocz(size)       tcc_mallocz_debug(size, __FILE__, __LINE__)\n#define tcc_realloc(ptr,size)   tcc_realloc_debug(ptr, size, __FILE__, __LINE__)\n#define tcc_strdup(str)         tcc_strdup_debug(str, __FILE__, __LINE__)\nPUB_FUNC void tcc_free_debug(void *ptr);\nPUB_FUNC void *tcc_malloc_debug(unsigned long size, const char *file, int line);\nPUB_FUNC void *tcc_mallocz_debug(unsigned long size, const char *file, int line);\nPUB_FUNC void *tcc_realloc_debug(void *ptr, unsigned long size, const char *file, int line);\nPUB_FUNC char *tcc_strdup_debug(const char *str, const char *file, int line);\n#endif\n\nST_FUNC void libc_free(void *ptr);\n#define free(p) use_tcc_free(p)\n#define malloc(s) use_tcc_malloc(s)\n#define realloc(p, s) use_tcc_realloc(p, s)\n#undef strdup\n#define strdup(s) use_tcc_strdup(s)\nPUB_FUNC int _tcc_error_noabort(const char *fmt, ...) PRINTF_LIKE(1,2);\nPUB_FUNC NORETURN void _tcc_error(const char *fmt, ...) PRINTF_LIKE(1,2);\nPUB_FUNC void _tcc_warning(const char *fmt, ...) PRINTF_LIKE(1,2);\n#define tcc_internal_error(msg) \\\n    tcc_error(\"internal compiler error in %s:%d: %s\", __FUNCTION__,__LINE__,msg)\n\n/* other utilities */\nST_FUNC void dynarray_add(void *ptab, int *nb_ptr, void *data);\nST_FUNC void dynarray_reset(void *pp, int *n);\nST_INLN void cstr_ccat(CString *cstr, int ch);\nST_FUNC void cstr_cat(CString *cstr, const char *str, int len);\nST_FUNC void cstr_wccat(CString *cstr, int ch);\nST_FUNC void cstr_new(CString *cstr);\nST_FUNC void cstr_free(CString *cstr);\nST_FUNC int cstr_printf(CString *cs, const char *fmt, ...) PRINTF_LIKE(2,3);\nST_FUNC int cstr_vprintf(CString *cstr, const char *fmt, va_list ap);\nST_FUNC void cstr_reset(CString *cstr);\nST_FUNC void tcc_open_bf(TCCState *s1, const char *filename, int initlen);\nST_FUNC int tcc_open(TCCState *s1, const char *filename);\nST_FUNC void tcc_close(void);\n\n/* mark a memory pointer on stack for cleanup after errors */\n#define stk_push(p) dynarray_add(&stk_data, &nb_stk_data, p)\n#define stk_pop() (--nb_stk_data)\n/* mark CString on stack for cleanup errors */\n#define cstr_new_s(cstr) (cstr_new(cstr), stk_push(&(cstr)->data))\n#define cstr_free_s(cstr) (cstr_free(cstr), stk_pop())\n\nST_FUNC int tcc_add_file_internal(TCCState *s1, const char *filename, int flags);\n/* flags: */\n#define AFF_PRINT_ERROR     0x10 /* print error if file not found */\n#define AFF_REFERENCED_DLL  0x20 /* load a referenced dll from another dll */\n#define AFF_TYPE_BIN        0x40 /* file to add is binary */\n#define AFF_WHOLE_ARCHIVE   0x80 /* load all objects from archive */\n/* s->filetype: */\n#define AFF_TYPE_NONE   0\n#define AFF_TYPE_C      1\n#define AFF_TYPE_ASM    2\n#define AFF_TYPE_ASMPP  4\n#define AFF_TYPE_LIB    8\n#define AFF_TYPE_MASK   (15 | AFF_TYPE_BIN)\n/* values from tcc_object_type(...) */\n#define AFF_BINTYPE_REL 1\n#define AFF_BINTYPE_DYN 2\n#define AFF_BINTYPE_AR  3\n#define AFF_BINTYPE_C67 4\n\n/* return value of tcc_add_file_internal(): 0, -1, or FILE_NOT_FOUND */\n#define FILE_NOT_FOUND -2\n\n#ifndef ELF_OBJ_ONLY\nST_FUNC int tcc_add_crt(TCCState *s, const char *filename);\n#endif\nST_FUNC int tcc_add_dll(TCCState *s, const char *filename, int flags);\nST_FUNC int tcc_add_support(TCCState *s1, const char *filename);\n#ifdef CONFIG_TCC_BCHECK\nST_FUNC void tcc_add_bcheck(TCCState *s1);\n#endif\n#ifdef CONFIG_TCC_BACKTRACE\nST_FUNC void tcc_add_btstub(TCCState *s1);\n#endif\nST_FUNC void tcc_add_pragma_libs(TCCState *s1);\nPUB_FUNC int tcc_add_library_err(TCCState *s, const char *f);\nPUB_FUNC void tcc_print_stats(TCCState *s, unsigned total_time);\nPUB_FUNC int tcc_parse_args(TCCState *s, int *argc, char ***argv, int optind);\n#ifdef _WIN32\nST_FUNC char *normalize_slashes(char *path);\n#endif\nST_FUNC DLLReference *tcc_add_dllref(TCCState *s1, const char *dllname, int level);\nST_FUNC char *tcc_load_text(int fd);\n/* for #pragma once */\nST_FUNC int normalized_PATHCMP(const char *f1, const char *f2);\n\n/* tcc_parse_args return codes: */\n#define OPT_HELP 1\n#define OPT_HELP2 2\n#define OPT_V 3\n#define OPT_PRINT_DIRS 4\n#define OPT_AR 5\n#define OPT_IMPDEF 6\n#define OPT_M32 32\n#define OPT_M64 64\n\n/* ------------ tccpp.c ------------ */\n\nST_DATA struct BufferedFile *file;\nST_DATA int tok;\nST_DATA CValue tokc;\nST_DATA const int *macro_ptr;\nST_DATA int parse_flags;\nST_DATA int tok_flags;\nST_DATA CString tokcstr; /* current parsed string, if any */\n\n/* display benchmark infos */\nST_DATA int tok_ident;\nST_DATA TokenSym **table_ident;\nST_DATA int pp_expr;\n\n#define TOK_FLAG_BOL   0x0001 /* beginning of line before */\n#define TOK_FLAG_BOF   0x0002 /* beginning of file before */\n#define TOK_FLAG_ENDIF 0x0004 /* a endif was found matching starting #ifdef */\n\n#define PARSE_FLAG_PREPROCESS 0x0001 /* activate preprocessing */\n#define PARSE_FLAG_TOK_NUM    0x0002 /* return numbers instead of TOK_PPNUM */\n#define PARSE_FLAG_LINEFEED   0x0004 /* line feed is returned as a\n                                        token. line feed is also\n                                        returned at eof */\n#define PARSE_FLAG_ASM_FILE 0x0008 /* we processing an asm file: '#' can be used for line comment, etc. */\n#define PARSE_FLAG_SPACES     0x0010 /* next() returns space tokens (for -E) */\n#define PARSE_FLAG_ACCEPT_STRAYS 0x0020 /* next() returns '\\\\' token */\n#define PARSE_FLAG_TOK_STR    0x0040 /* return parsed strings instead of TOK_PPSTR */\n\n/* isidnum_table flags: */\n#define IS_SPC 1\n#define IS_ID  2\n#define IS_NUM 4\n\nenum line_macro_output_format {\n    LINE_MACRO_OUTPUT_FORMAT_GCC,\n    LINE_MACRO_OUTPUT_FORMAT_NONE,\n    LINE_MACRO_OUTPUT_FORMAT_STD,\n    LINE_MACRO_OUTPUT_FORMAT_P10 = 11\n};\n\nST_FUNC TokenSym *tok_alloc(const char *str, int len);\nST_FUNC int tok_alloc_const(const char *str);\nST_FUNC const char *get_tok_str(int v, CValue *cv);\nST_FUNC void begin_macro(TokenString *str, int alloc);\nST_FUNC void end_macro(void);\nST_FUNC int set_idnum(int c, int val);\nST_INLN void tok_str_new(TokenString *s);\nST_FUNC TokenString *tok_str_alloc(void);\nST_FUNC void tok_str_free(TokenString *s);\nST_FUNC void tok_str_free_str(int *str);\nST_FUNC void tok_str_add(TokenString *s, int t);\nST_FUNC void tok_str_add_tok(TokenString *s);\nST_INLN void define_push(int v, int macro_type, int *str, Sym *first_arg);\nST_FUNC void define_undef(Sym *s);\nST_INLN Sym *define_find(int v);\nST_FUNC void free_defines(Sym *b);\nST_FUNC void parse_define(void);\nST_FUNC void skip_to_eol(int warn);\nST_FUNC void preprocess(int is_bof);\nST_FUNC void next(void);\nST_INLN void unget_tok(int last_tok);\nST_FUNC void preprocess_start(TCCState *s1, int filetype);\nST_FUNC void preprocess_end(TCCState *s1);\nST_FUNC void tccpp_new(TCCState *s);\nST_FUNC void tccpp_delete(TCCState *s);\nST_FUNC void tccpp_putfile(const char *filename);\nST_FUNC int tcc_preprocess(TCCState *s1);\nST_FUNC void skip(int c);\nST_FUNC NORETURN void expect(const char *msg);\nST_FUNC void pp_error(CString *cs);\n\n\n/* space excluding newline */\nstatic inline int is_space(int ch) {\n    return ch == ' ' || ch == '\\t' || ch == '\\v' || ch == '\\f' || ch == '\\r';\n}\nstatic inline int isid(int c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';\n}\nstatic inline int isnum(int c) {\n    return c >= '0' && c <= '9';\n}\nstatic inline int isoct(int c) {\n    return c >= '0' && c <= '7';\n}\nstatic inline int toup(int c) {\n    return (c >= 'a' && c <= 'z') ? c - 'a' + 'A' : c;\n}\n\n/* ------------ tccgen.c ------------ */\n\n#define SYM_POOL_NB (8192 / sizeof(Sym))\n\nST_DATA Sym *global_stack;\nST_DATA Sym *local_stack;\nST_DATA Sym *local_label_stack;\nST_DATA Sym *global_label_stack;\nST_DATA Sym *define_stack;\nST_DATA CType int_type, func_old_type, char_pointer_type;\nST_DATA SValue *vtop;\nST_DATA int rsym, anon_sym, ind, loc;\nST_DATA char debug_modes;\n\nST_DATA int nocode_wanted; /* true if no code generation wanted for an expression */\nST_DATA int global_expr;  /* true if compound literals must be allocated globally (used during initializers parsing */\nST_DATA CType func_vt; /* current function return type (used by return instruction) */\nST_DATA int func_var; /* true if current function is variadic */\nST_DATA int func_vc;\nST_DATA int func_ind;\nST_DATA const char *funcname;\n\nST_FUNC void tccgen_init(TCCState *s1);\nST_FUNC int tccgen_compile(TCCState *s1);\nST_FUNC void tccgen_finish(TCCState *s1);\nST_FUNC void check_vstack(void);\n\nST_INLN int is_float(int t);\nST_FUNC int ieee_finite(double d);\nST_FUNC int exact_log2p1(int i);\nST_FUNC void test_lvalue(void);\n\nST_FUNC ElfSym *elfsym(Sym *);\nST_FUNC void update_storage(Sym *sym);\nST_FUNC void put_extern_sym2(Sym *sym, int sh_num, addr_t value, unsigned long size, int can_add_underscore);\nST_FUNC void put_extern_sym(Sym *sym, Section *section, addr_t value, unsigned long size);\n#if PTR_SIZE == 4\nST_FUNC void greloc(Section *s, Sym *sym, unsigned long offset, int type);\n#endif\nST_FUNC void greloca(Section *s, Sym *sym, unsigned long offset, int type, addr_t addend);\n\nST_INLN void sym_free(Sym *sym);\nST_FUNC Sym *sym_push(int v, CType *type, int r, int c);\nST_FUNC void sym_pop(Sym **ptop, Sym *b, int keep);\nST_FUNC Sym *sym_push2(Sym **ps, int v, int t, int c);\nST_FUNC Sym *sym_find2(Sym *s, int v);\nST_INLN Sym *sym_find(int v);\nST_FUNC Sym *label_find(int v);\nST_FUNC Sym *label_push(Sym **ptop, int v, int flags);\nST_FUNC void label_pop(Sym **ptop, Sym *slast, int keep);\nST_INLN Sym *struct_find(int v);\n\nST_FUNC Sym *global_identifier_push(int v, int t, int c);\nST_FUNC Sym *external_global_sym(int v, CType *type);\nST_FUNC Sym *external_helper_sym(int v);\nST_FUNC void vpush_helper_func(int v);\nST_FUNC void vset(CType *type, int r, int v);\nST_FUNC void vset_VT_CMP(int op);\nST_FUNC void vpushi(int v);\nST_FUNC void vpushv(SValue *v);\nST_FUNC void vpushsym(CType *type, Sym *sym);\nST_FUNC void vswap(void);\nST_FUNC void vrott(int n);\nST_FUNC void vrotb(int n);\nST_FUNC void vrev(int n);\nST_FUNC void vpop(void);\n#if PTR_SIZE == 4\nST_FUNC void lexpand(void);\n#endif\n#ifdef TCC_TARGET_ARM\nST_FUNC int get_reg_ex(int rc, int rc2);\n#endif\nST_FUNC void save_reg(int r);\nST_FUNC void save_reg_upstack(int r, int n);\nST_FUNC int get_reg(int rc);\nST_FUNC void save_regs(int n);\nST_FUNC void gaddrof(void);\nST_FUNC int gv(int rc);\nST_FUNC void gv2(int rc1, int rc2);\nST_FUNC void gen_op(int op);\nST_FUNC int type_size(CType *type, int *a);\nST_FUNC void mk_pointer(CType *type);\nST_FUNC void vstore(void);\nST_FUNC void inc(int post, int c);\nST_FUNC CString* parse_mult_str(const char *msg);\nST_FUNC CString* parse_asm_str(void);\nST_FUNC void indir(void);\nST_FUNC void unary(void);\nST_FUNC void gexpr(void);\nST_FUNC int expr_const(void);\n#if defined CONFIG_TCC_BCHECK || defined TCC_TARGET_C67\nST_FUNC Sym *get_sym_ref(CType *type, Section *sec, unsigned long offset, unsigned long size);\n#endif\n#if defined TCC_TARGET_X86_64 && !defined TCC_TARGET_PE\nST_FUNC int classify_x86_64_va_arg(CType *ty);\n#endif\n#ifdef CONFIG_TCC_BCHECK\nST_FUNC void gbound_args(int nb_args);\nST_DATA int func_bound_add_epilog;\n#endif\n\n/* ------------ tccelf.c ------------ */\n\n#define TCC_OUTPUT_FORMAT_ELF    0 /* default output format: ELF */\n#define TCC_OUTPUT_FORMAT_BINARY 1 /* binary image output */\n#define TCC_OUTPUT_FORMAT_COFF   2 /* COFF */\n#define TCC_OUTPUT_DYN           TCC_OUTPUT_DLL\n\n#define ARMAG  \"!<arch>\\n\"    /* For COFF and a.out archives */\n\ntypedef struct {\n    unsigned int n_strx;         /* index into string table of name */\n    unsigned char n_type;         /* type of symbol */\n    unsigned char n_other;        /* misc info (usually empty) */\n    unsigned short n_desc;        /* description field */\n    unsigned int n_value;        /* value of symbol */\n} Stab_Sym;\n\nST_FUNC void tccelf_new(TCCState *s);\nST_FUNC void tccelf_delete(TCCState *s);\nST_FUNC void tccelf_begin_file(TCCState *s1);\nST_FUNC void tccelf_end_file(TCCState *s1);\nST_FUNC Section *new_section(TCCState *s1, const char *name, int sh_type, int sh_flags);\nST_FUNC void section_realloc(Section *sec, unsigned long new_size);\nST_FUNC size_t section_add(Section *sec, addr_t size, int align);\nST_FUNC void *section_ptr_add(Section *sec, addr_t size);\nST_FUNC Section *find_section(TCCState *s1, const char *name);\nST_FUNC void free_section(Section *s);\nST_FUNC Section *new_symtab(TCCState *s1, const char *symtab_name, int sh_type, int sh_flags, const char *strtab_name, const char *hash_name, int hash_sh_flags);\nST_FUNC void init_symtab(Section *s);\n\nST_FUNC int put_elf_str(Section *s, const char *sym);\nST_FUNC int put_elf_sym(Section *s, addr_t value, unsigned long size, int info, int other, int shndx, const char *name);\nST_FUNC int set_elf_sym(Section *s, addr_t value, unsigned long size, int info, int other, int shndx, const char *name);\nST_FUNC int find_elf_sym(Section *s, const char *name);\nST_FUNC void put_elf_reloc(Section *symtab, Section *s, unsigned long offset, int type, int symbol);\nST_FUNC void put_elf_reloca(Section *symtab, Section *s, unsigned long offset, int type, int symbol, addr_t addend);\n\nST_FUNC void resolve_common_syms(TCCState *s1);\nST_FUNC void relocate_syms(TCCState *s1, Section *symtab, int do_resolve);\nST_FUNC void relocate_sections(TCCState *s1);\n\nST_FUNC ssize_t full_read(int fd, void *buf, size_t count);\nST_FUNC void *load_data(int fd, unsigned long file_offset, unsigned long size);\nST_FUNC int tcc_object_type(int fd, ElfW(Ehdr) *h);\nST_FUNC int tcc_load_object_file(TCCState *s1, int fd, unsigned long file_offset);\nST_FUNC int tcc_load_archive(TCCState *s1, int fd, int alacarte);\nST_FUNC void add_array(TCCState *s1, const char *sec, int c);\n\nST_FUNC struct sym_attr *get_sym_attr(TCCState *s1, int index, int alloc);\nST_FUNC addr_t get_sym_addr(TCCState *s, const char *name, int err, int forc);\nST_FUNC void list_elf_symbols(TCCState *s, void *ctx,\n    void (*symbol_cb)(void *ctx, const char *name, const void *val));\nST_FUNC int set_global_sym(TCCState *s1, const char *name, Section *sec, addr_t offs);\n\n/* Browse each elem of type <type> in section <sec> starting at elem <startoff>\n   using variable <elem> */\n#define for_each_elem(sec, startoff, elem, type) \\\n    for (elem = (type *) sec->data + startoff; \\\n         elem < (type *) (sec->data + sec->data_offset); elem++)\n\n#ifndef ELF_OBJ_ONLY\nST_FUNC int tcc_load_dll(TCCState *s1, int fd, const char *filename, int level);\nST_FUNC int tcc_load_ldscript(TCCState *s1, int fd);\nST_FUNC void tccelf_add_crtbegin(TCCState *s1);\nST_FUNC void tccelf_add_crtend(TCCState *s1);\n#endif\n#ifndef TCC_TARGET_PE\nST_FUNC void tcc_add_runtime(TCCState *s1);\n#endif\n\n/* ------------ xxx-link.c ------------ */\n\n#if !defined ELF_OBJ_ONLY || defined TCC_TARGET_MACHO\nST_FUNC int code_reloc (int reloc_type);\nST_FUNC int gotplt_entry_type (int reloc_type);\n/* Whether to generate a GOT/PLT entry and when. NO_GOTPLT_ENTRY is first so\n   that unknown relocation don't create a GOT or PLT entry */\nenum gotplt_entry {\n    NO_GOTPLT_ENTRY,\t/* never generate (eg. GLOB_DAT & JMP_SLOT relocs) */\n    BUILD_GOT_ONLY,\t/* only build GOT (eg. TPOFF relocs) */\n    AUTO_GOTPLT_ENTRY,\t/* generate if sym is UNDEF */\n    ALWAYS_GOTPLT_ENTRY\t/* always generate (eg. PLTOFF relocs) */\n};\n#define NEED_RELOC_TYPE\n\n#if !defined TCC_TARGET_MACHO || defined TCC_IS_NATIVE\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr);\nST_FUNC void relocate_plt(TCCState *s1);\nST_FUNC void build_got_entries(TCCState *s1, int got_sym); /* in tccelf.c */\n#define NEED_BUILD_GOT\n\n#endif\n#endif\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val);\n\n/* ------------ xxx-gen.c ------------ */\nST_DATA const char * const target_machine_defs;\nST_DATA const int reg_classes[NB_REGS];\n\nST_FUNC void gsym_addr(int t, int a);\nST_FUNC void gsym(int t);\nST_FUNC void load(int r, SValue *sv);\nST_FUNC void store(int r, SValue *v);\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *align, int *regsize);\nST_FUNC void gfunc_call(int nb_args);\nST_FUNC void gfunc_prolog(Sym *func_sym);\nST_FUNC void gfunc_epilog(void);\nST_FUNC void gen_fill_nops(int);\nST_FUNC int gjmp(int t);\nST_FUNC void gjmp_addr(int a);\nST_FUNC int gjmp_cond(int op, int t);\nST_FUNC int gjmp_append(int n, int t);\nST_FUNC void gen_opi(int op);\nST_FUNC void gen_opf(int op);\nST_FUNC void gen_cvt_ftoi(int t);\nST_FUNC void gen_cvt_itof(int t);\nST_FUNC void gen_cvt_ftof(int t);\nST_FUNC void ggoto(void);\n#ifndef TCC_TARGET_C67\nST_FUNC void o(unsigned int c);\n#endif\nST_FUNC void gen_vla_sp_save(int addr);\nST_FUNC void gen_vla_sp_restore(int addr);\nST_FUNC void gen_vla_alloc(CType *type, int align);\n\nstatic inline uint16_t read16le(unsigned char *p) {\n    return p[0] | (uint16_t)p[1] << 8;\n}\nstatic inline void write16le(unsigned char *p, uint16_t x) {\n    p[0] = x & 255;  p[1] = x >> 8 & 255;\n}\nstatic inline uint32_t read32le(unsigned char *p) {\n  return read16le(p) | (uint32_t)read16le(p + 2) << 16;\n}\nstatic inline void write32le(unsigned char *p, uint32_t x) {\n    write16le(p, x);  write16le(p + 2, x >> 16);\n}\nstatic inline void add32le(unsigned char *p, int32_t x) {\n    write32le(p, read32le(p) + x);\n}\nstatic inline uint64_t read64le(unsigned char *p) {\n  return read32le(p) | (uint64_t)read32le(p + 4) << 32;\n}\nstatic inline void write64le(unsigned char *p, uint64_t x) {\n    write32le(p, x);  write32le(p + 4, x >> 32);\n}\nstatic inline void add64le(unsigned char *p, int64_t x) {\n    write64le(p, read64le(p) + x);\n}\n#define DWARF_MAX_128\t((8 * sizeof (int64_t) + 6) / 7)\n#define\tdwarf_read_1(ln,end) \\\n\t((ln) < (end) ? *(ln)++ : 0)\n#define\tdwarf_read_2(ln,end) \\\n\t((ln) + 1 < (end) ? (ln) += 2, read16le((ln) - 2) : 0)\n#define\tdwarf_read_4(ln,end) \\\n\t((ln) + 3 < (end) ? (ln) += 4, read32le((ln) - 4) : 0)\n#define\tdwarf_read_8(ln,end) \\\n\t((ln) + 7 < (end) ? (ln) += 8, read64le((ln) - 8) : 0)\nstatic inline uint64_t\ndwarf_read_uleb128(unsigned char **ln, unsigned char *end)\n{\n    unsigned char *cp = *ln;\n    uint64_t retval = 0;\n    int i;\n\n    for (i = 0; i < DWARF_MAX_128; i++) {\n\tuint64_t byte = dwarf_read_1(cp, end);\n\n        retval |= (byte & 0x7f) << (i * 7);\n\tif ((byte & 0x80) == 0)\n\t    break;\n    }\n    *ln = cp;\n    return retval;\n}\nstatic inline int64_t\ndwarf_read_sleb128(unsigned char **ln, unsigned char *end)\n{\n    unsigned char *cp = *ln;\n    int64_t retval = 0;\n    int i;\n\n    for (i = 0; i < DWARF_MAX_128; i++) {\n\tuint64_t byte = dwarf_read_1(cp, end);\n\n        retval |= (byte & 0x7f) << (i * 7);\n\tif ((byte & 0x80) == 0) {\n\t    if ((byte & 0x40) && (i + 1) * 7 < 64)\n\t\tretval |= -1LL << ((i + 1) * 7);\n\t    break;\n\t}\n    }\n    *ln = cp;\n    return retval;\n}\n\n\n/* ------------ i386-gen.c ------------ */\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || defined TCC_TARGET_ARM\nST_FUNC void g(int c);\nST_FUNC void gen_le16(int c);\nST_FUNC void gen_le32(int c);\n#endif\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64\nST_FUNC void gen_addr32(int r, Sym *sym, int c);\nST_FUNC void gen_addrpc32(int r, Sym *sym, int c);\nST_FUNC void gen_cvt_csti(int t);\nST_FUNC void gen_increment_tcov (SValue *sv);\n#endif\n\n/* ------------ x86_64-gen.c ------------ */\n#ifdef TCC_TARGET_X86_64\nST_FUNC void gen_addr64(int r, Sym *sym, int64_t c);\nST_FUNC void gen_opl(int op);\n#ifdef TCC_TARGET_PE\nST_FUNC void gen_vla_result(int addr);\n#endif\nST_FUNC void gen_cvt_sxtw(void);\nST_FUNC void gen_cvt_csti(int t);\n#endif\n\n/* ------------ arm-gen.c ------------ */\n#ifdef TCC_TARGET_ARM\n#if defined(TCC_ARM_EABI) && !defined(CONFIG_TCC_ELFINTERP)\nPUB_FUNC const char *default_elfinterp(struct TCCState *s);\n#endif\nST_FUNC void arm_init(struct TCCState *s);\nST_FUNC void gen_increment_tcov (SValue *sv);\n#endif\n\n/* ------------ arm64-gen.c ------------ */\n#ifdef TCC_TARGET_ARM64\nST_FUNC void gen_opl(int op);\nST_FUNC void gfunc_return(CType *func_type);\nST_FUNC void gen_va_start(void);\nST_FUNC void gen_va_arg(CType *t);\nST_FUNC void gen_clear_cache(void);\nST_FUNC void gen_cvt_sxtw(void);\nST_FUNC void gen_cvt_csti(int t);\nST_FUNC void gen_increment_tcov (SValue *sv);\n#endif\n\n/* ------------ riscv64-gen.c ------------ */\n#ifdef TCC_TARGET_RISCV64\nST_FUNC void gen_opl(int op);\n//ST_FUNC void gfunc_return(CType *func_type);\nST_FUNC void gen_va_start(void);\nST_FUNC void arch_transfer_ret_regs(int);\nST_FUNC void gen_cvt_sxtw(void);\nST_FUNC void gen_increment_tcov (SValue *sv);\n#endif\n\n/* ------------ c67-gen.c ------------ */\n#ifdef TCC_TARGET_C67\n#endif\n\n/* ------------ tcccoff.c ------------ */\n#ifdef TCC_TARGET_COFF\nST_FUNC int tcc_output_coff(TCCState *s1, FILE *f);\nST_FUNC int tcc_load_coff(TCCState * s1, int fd);\n#endif\n\n/* ------------ tccasm.c ------------ */\nST_FUNC void asm_instr(void);\nST_FUNC void asm_global_instr(void);\nST_FUNC int tcc_assemble(TCCState *s1, int do_preprocess);\n#ifdef CONFIG_TCC_ASM\nST_FUNC int find_constraint(ASMOperand *operands, int nb_operands, const char *name, const char **pp);\nST_FUNC Sym* get_asm_sym(int name, Sym *csym);\nST_FUNC void asm_expr(TCCState *s1, ExprValue *pe);\nST_FUNC int asm_int_expr(TCCState *s1);\n/* ------------ i386-asm.c ------------ */\nST_FUNC void gen_expr32(ExprValue *pe);\n#ifdef TCC_TARGET_X86_64\nST_FUNC void gen_expr64(ExprValue *pe);\n#endif\nST_FUNC void asm_opcode(TCCState *s1, int opcode);\nST_FUNC int asm_parse_regvar(int t);\nST_FUNC void asm_compute_constraints(ASMOperand *operands, int nb_operands, int nb_outputs, const uint8_t *clobber_regs, int *pout_reg);\nST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier);\nST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands, int nb_outputs, int is_output, uint8_t *clobber_regs, int out_reg);\nST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str);\n#endif\n\n/* ------------ tccpe.c -------------- */\n#ifdef TCC_TARGET_PE\nST_FUNC int pe_load_file(struct TCCState *s1, int fd, const char *filename);\nST_FUNC int pe_output_file(TCCState * s1, const char *filename);\nST_FUNC int pe_putimport(TCCState *s1, int dllindex, const char *name, addr_t value);\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64\n#endif\n#ifdef TCC_TARGET_X86_64\nST_FUNC void pe_add_unwind_data(unsigned start, unsigned end, unsigned stack);\n#endif\nPUB_FUNC int tcc_get_dllexports(const char *filename, char **pp);\n/* symbol properties stored in Elf32_Sym->st_other */\n# define ST_PE_EXPORT 0x10\n# define ST_PE_IMPORT 0x20\n# define ST_PE_STDCALL 0x40\n#endif\n#define ST_ASM_SET 0x04\n\n/* ------------ tccmacho.c ----------------- */\n#ifdef TCC_TARGET_MACHO\nST_FUNC int macho_output_file(TCCState * s1, const char *filename);\nST_FUNC int macho_load_dll(TCCState *s1, int fd, const char *filename, int lev);\nST_FUNC int macho_load_tbd(TCCState *s1, int fd, const char *filename, int lev);\n#ifdef TCC_IS_NATIVE\nST_FUNC void tcc_add_macos_sdkpath(TCCState* s);\nST_FUNC const char* macho_tbd_soname(const char* filename);\n#endif\n#endif\n/* ------------ tccrun.c ----------------- */\n#ifdef TCC_IS_NATIVE\n#ifdef CONFIG_TCC_STATIC\n#define RTLD_LAZY       0x001\n#define RTLD_NOW        0x002\n#define RTLD_GLOBAL     0x100\n#define RTLD_DEFAULT    NULL\n/* dummy function for profiling */\nST_FUNC void *dlopen(const char *filename, int flag);\nST_FUNC void dlclose(void *p);\nST_FUNC const char *dlerror(void);\nST_FUNC void *dlsym(void *handle, const char *symbol);\n#endif\nST_FUNC void tcc_run_free(TCCState *s1);\n#endif\n\n/* ------------ tcctools.c ----------------- */\n#if 0 /* included in tcc.c */\nST_FUNC int tcc_tool_ar(TCCState *s, int argc, char **argv);\n#ifdef TCC_TARGET_PE\nST_FUNC int tcc_tool_impdef(TCCState *s, int argc, char **argv);\n#endif\nST_FUNC int tcc_tool_cross(TCCState *s, char **argv, int option);\nST_FUNC int gen_makedeps(TCCState *s, const char *target, const char *filename);\n#endif\n\n/* ------------ tccdbg.c ------------ */\n\nST_FUNC void tcc_debug_new(TCCState *s);\n\nST_FUNC void tcc_debug_start(TCCState *s1);\nST_FUNC void tcc_debug_end(TCCState *s1);\nST_FUNC void tcc_debug_bincl(TCCState *s1);\nST_FUNC void tcc_debug_eincl(TCCState *s1);\nST_FUNC void tcc_debug_newfile(TCCState *s1);\n\nST_FUNC void tcc_debug_line(TCCState *s1);\nST_FUNC void tcc_add_debug_info(TCCState *s1, int param, Sym *s, Sym *e);\nST_FUNC void tcc_debug_funcstart(TCCState *s1, Sym *sym);\nST_FUNC void tcc_debug_prolog_epilog(TCCState *s1, int value);\nST_FUNC void tcc_debug_funcend(TCCState *s1, int size);\nST_FUNC void tcc_debug_extern_sym(TCCState *s1, Sym *sym, int sh_num, int sym_bind, int sym_type);\nST_FUNC void tcc_debug_typedef(TCCState *s1, Sym *sym);\nST_FUNC void tcc_debug_stabn(TCCState *s1, int type, int value);\nST_FUNC void tcc_debug_fix_anon(TCCState *s1, CType *t);\n\n#if !(defined ELF_OBJ_ONLY || defined TCC_TARGET_ARM || defined TARGETOS_BSD)\nST_FUNC void tcc_eh_frame_start(TCCState *s1);\nST_FUNC void tcc_eh_frame_end(TCCState *s1);\nST_FUNC void tcc_eh_frame_hdr(TCCState *s1, int final);\n#define TCC_EH_FRAME 1\n#endif\n\nST_FUNC void tcc_tcov_start(TCCState *s1);\nST_FUNC void tcc_tcov_end(TCCState *s1);\nST_FUNC void tcc_tcov_check_line(TCCState *s1, int start);\nST_FUNC void tcc_tcov_block_end(TCCState *s1, int line);\nST_FUNC void tcc_tcov_block_begin(TCCState *s1);\nST_FUNC void tcc_tcov_reset_ind(TCCState *s1);\n\n#define stab_section            s1->stab_section\n#define stabstr_section         stab_section->link\n#define tcov_section            s1->tcov_section\n#define eh_frame_section        s1->eh_frame_section\n#define eh_frame_hdr_section    s1->eh_frame_hdr_section\n#define dwarf_info_section      s1->dwarf_info_section\n#define dwarf_abbrev_section    s1->dwarf_abbrev_section\n#define dwarf_line_section      s1->dwarf_line_section\n#define dwarf_aranges_section   s1->dwarf_aranges_section\n#define dwarf_str_section       s1->dwarf_str_section\n#define dwarf_line_str_section  s1->dwarf_line_str_section\n\n/* default dwarf version for \"-gdwarf\" */\n#ifdef TCC_TARGET_MACHO\n# define DEFAULT_DWARF_VERSION 2\n#else\n# define DEFAULT_DWARF_VERSION 5\n#endif\n\n/* default dwarf version for \"-g\". use 0 to emit stab debug infos */\n#ifndef CONFIG_DWARF_VERSION\n# define CONFIG_DWARF_VERSION 0\n#endif\n\n#if defined TCC_TARGET_PE\n# define R_DATA_32DW 'Z' /* fake code to avoid DLL relocs */\n#elif defined TCC_TARGET_X86_64\n# define R_DATA_32DW R_X86_64_32\n#else\n# define R_DATA_32DW R_DATA_32\n#endif\n\n/********************************************************/\n#if CONFIG_TCC_SEMLOCK\n#if defined _WIN32\ntypedef struct { int init; CRITICAL_SECTION cs; } TCCSem;\nstatic inline void wait_sem(TCCSem *p) {\n    if (!p->init)\n        InitializeCriticalSection(&p->cs), p->init = 1;\n    EnterCriticalSection(&p->cs);\n}\nstatic inline void post_sem(TCCSem *p) {\n    LeaveCriticalSection(&p->cs);\n}\n#elif defined __APPLE__\n#include <dispatch/dispatch.h>\ntypedef struct { int init; dispatch_semaphore_t sem; } TCCSem;\nstatic inline void wait_sem(TCCSem *p) {\n    if (!p->init)\n        p->sem = dispatch_semaphore_create(1), p->init = 1;\n    dispatch_semaphore_wait(p->sem, DISPATCH_TIME_FOREVER);\n}\nstatic inline void post_sem(TCCSem *p) {\n    dispatch_semaphore_signal(p->sem);\n}\n#else\n#include <semaphore.h>\ntypedef struct { int init; sem_t sem; } TCCSem;\nstatic inline void wait_sem(TCCSem *p) {\n    if (!p->init)\n        sem_init(&p->sem, 0, 1), p->init = 1;\n    while (sem_wait(&p->sem) < 0 && errno == EINTR);\n}\nstatic inline void post_sem(TCCSem *p) {\n    sem_post(&p->sem);\n}\n#endif\n#define TCC_SEM(s) TCCSem s\n#define WAIT_SEM wait_sem\n#define POST_SEM post_sem\n#else\n#define TCC_SEM(s)\n#define WAIT_SEM(p)\n#define POST_SEM(p)\n#endif\n\n/********************************************************/\n#undef ST_DATA\n#if ONE_SOURCE\n#define ST_DATA static\n#else\n#define ST_DATA\n#endif\n/********************************************************/\n\n#define text_section        TCC_STATE_VAR(text_section)\n#define data_section        TCC_STATE_VAR(data_section)\n#define rodata_section      TCC_STATE_VAR(rodata_section)\n#define bss_section         TCC_STATE_VAR(bss_section)\n#define common_section      TCC_STATE_VAR(common_section)\n#define cur_text_section    TCC_STATE_VAR(cur_text_section)\n#define bounds_section      TCC_STATE_VAR(bounds_section)\n#define lbounds_section     TCC_STATE_VAR(lbounds_section)\n#define symtab_section      TCC_STATE_VAR(symtab_section)\n#define gnu_ext             TCC_STATE_VAR(gnu_ext)\n#define tcc_error_noabort   TCC_SET_STATE(_tcc_error_noabort)\n#define tcc_error           TCC_SET_STATE(_tcc_error)\n#define tcc_warning         TCC_SET_STATE(_tcc_warning)\n\n#define total_idents        TCC_STATE_VAR(total_idents)\n#define total_lines         TCC_STATE_VAR(total_lines)\n#define total_bytes         TCC_STATE_VAR(total_bytes)\n\nPUB_FUNC void tcc_enter_state(TCCState *s1);\nPUB_FUNC void tcc_exit_state(TCCState *s1);\n\n/* conditional warning depending on switch */\n#define tcc_warning_c(sw) TCC_SET_STATE((\\\n    tcc_state->warn_num = offsetof(TCCState, sw) \\\n    - offsetof(TCCState, warn_none), _tcc_warning))\n\n/********************************************************/\n#endif /* _TCC_H */\n\n#undef TCC_STATE_VAR\n#undef TCC_SET_STATE\n\n#ifdef USING_GLOBALS\n# define TCC_STATE_VAR(sym) tcc_state->sym\n# define TCC_SET_STATE(fn) fn\n# undef USING_GLOBALS\n# undef _tcc_error\n#else\n# define TCC_STATE_VAR(sym) s1->sym\n# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)\n# define _tcc_error use_tcc_error_noabort\n#endif\n"
        },
        {
          "name": "tccasm.c",
          "type": "blob",
          "size": 40.0693359375,
          "content": "/*\n *  GAS like assembler for TCC\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define USING_GLOBALS\n#include \"tcc.h\"\n#ifdef CONFIG_TCC_ASM\n\nstatic Section *last_text_section; /* to handle .previous asm directive */\nstatic int asmgoto_n;\n\nstatic int asm_get_prefix_name(TCCState *s1, const char *prefix, unsigned int n)\n{\n    char buf[64];\n    snprintf(buf, sizeof(buf), \"%s%u\", prefix, n);\n    return tok_alloc_const(buf);\n}\n\nST_FUNC int asm_get_local_label_name(TCCState *s1, unsigned int n)\n{\n    return asm_get_prefix_name(s1, \"L..\", n);\n}\n\nstatic int tcc_assemble_internal(TCCState *s1, int do_preprocess, int global);\nstatic Sym* asm_new_label(TCCState *s1, int label, int is_local);\nstatic Sym* asm_new_label1(TCCState *s1, int label, int is_local, int sh_num, int value);\n\n/* If a C name has an _ prepended then only asm labels that start\n   with _ are representable in C, by removing the first _.  ASM names\n   without _ at the beginning don't correspond to C names, but we use\n   the global C symbol table to track ASM names as well, so we need to\n   transform those into ones that don't conflict with a C name,\n   so prepend a '.' for them, but force the ELF asm name to be set.  */\nstatic int asm2cname(int v, int *addeddot)\n{\n    const char *name;\n    *addeddot = 0;\n    if (!tcc_state->leading_underscore)\n      return v;\n    name = get_tok_str(v, NULL);\n    if (!name)\n      return v;\n    if (name[0] == '_') {\n        v = tok_alloc_const(name + 1);\n    } else if (!strchr(name, '.')) {\n        char newname[256];\n        snprintf(newname, sizeof newname, \".%s\", name);\n        v = tok_alloc_const(newname);\n        *addeddot = 1;\n    }\n    return v;\n}\n\nstatic Sym *asm_label_find(int v)\n{\n    Sym *sym;\n    int addeddot;\n    v = asm2cname(v, &addeddot);\n    sym = sym_find(v);\n    while (sym && sym->sym_scope && !(sym->type.t & VT_STATIC))\n        sym = sym->prev_tok;\n    return sym;\n}\n\nstatic Sym *asm_label_push(int v)\n{\n    int addeddot, v2 = asm2cname(v, &addeddot);\n    /* We always add VT_EXTERN, for sym definition that's tentative\n       (for .set, removed for real defs), for mere references it's correct\n       as is.  */\n    Sym *sym = global_identifier_push(v2, VT_ASM | VT_EXTERN | VT_STATIC, 0);\n    if (addeddot)\n        sym->asm_label = v;\n    return sym;\n}\n\n/* Return a symbol we can use inside the assembler, having name NAME.\n   Symbols from asm and C source share a namespace.  If we generate\n   an asm symbol it's also a (file-global) C symbol, but it's\n   either not accessible by name (like \"L.123\"), or its type information\n   is such that it's not usable without a proper C declaration.\n\n   Sometimes we need symbols accessible by name from asm, which\n   are anonymous in C, in this case CSYM can be used to transfer\n   all information from that symbol to the (possibly newly created)\n   asm symbol.  */\nST_FUNC Sym* get_asm_sym(int name, Sym *csym)\n{\n    Sym *sym = asm_label_find(name);\n    if (!sym) {\n\tsym = asm_label_push(name);\n\tif (csym)\n\t  sym->c = csym->c;\n    }\n    return sym;\n}\n\nstatic Sym* asm_section_sym(TCCState *s1, Section *sec)\n{\n    char buf[100]; int label; Sym *sym;\n    snprintf(buf, sizeof buf, \"L.%s\", sec->name);\n    label = tok_alloc_const(buf);\n    sym = asm_label_find(label);\n    return sym ? sym : asm_new_label1(s1, label, 1, sec->sh_num, 0);\n}\n\n/* We do not use the C expression parser to handle symbols. Maybe the\n   C expression parser could be tweaked to do so. */\n\nstatic void asm_expr_unary(TCCState *s1, ExprValue *pe)\n{\n    Sym *sym;\n    int op, label;\n    uint64_t n;\n    const char *p;\n\n    switch(tok) {\n    case TOK_PPNUM:\n        p = tokc.str.data;\n        n = strtoull(p, (char **)&p, 0);\n        if (*p == 'b' || *p == 'f') {\n            /* backward or forward label */\n            label = asm_get_local_label_name(s1, n);\n            sym = asm_label_find(label);\n            if (*p == 'b') {\n                /* backward : find the last corresponding defined label */\n                if (sym && (!sym->c || elfsym(sym)->st_shndx == SHN_UNDEF))\n                    sym = sym->prev_tok;\n                if (!sym)\n                    tcc_error(\"local label '%d' not found backward\", (int)n);\n            } else {\n                /* forward */\n                if (!sym || (sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)) {\n                    /* if the last label is defined, then define a new one */\n\t\t    sym = asm_label_push(label);\n                }\n            }\n\t    pe->v = 0;\n\t    pe->sym = sym;\n\t    pe->pcrel = 0;\n        } else if (*p == '\\0') {\n            pe->v = n;\n            pe->sym = NULL;\n\t    pe->pcrel = 0;\n        } else {\n            tcc_error(\"invalid number syntax\");\n        }\n        next();\n        break;\n    case '+':\n        next();\n        asm_expr_unary(s1, pe);\n        break;\n    case '-':\n    case '~':\n        op = tok;\n        next();\n        asm_expr_unary(s1, pe);\n        if (pe->sym)\n            tcc_error(\"invalid operation with label\");\n        if (op == '-')\n            pe->v = -pe->v;\n        else\n            pe->v = ~pe->v;\n        break;\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n\tpe->v = tokc.i;\n\tpe->sym = NULL;\n\tpe->pcrel = 0;\n\tnext();\n\tbreak;\n    case '(':\n        next();\n        asm_expr(s1, pe);\n        skip(')');\n        break;\n    case '.':\n        pe->v = ind;\n        pe->sym = asm_section_sym(s1, cur_text_section);\n        pe->pcrel = 0;\n        next();\n        break;\n    default:\n        if (tok >= TOK_IDENT) {\n\t    ElfSym *esym;\n            /* label case : if the label was not found, add one */\n\t    sym = get_asm_sym(tok, NULL);\n\t    esym = elfsym(sym);\n            if (esym && esym->st_shndx == SHN_ABS) {\n                /* if absolute symbol, no need to put a symbol value */\n                pe->v = esym->st_value;\n                pe->sym = NULL;\n\t\tpe->pcrel = 0;\n            } else {\n                pe->v = 0;\n                pe->sym = sym;\n\t\tpe->pcrel = 0;\n            }\n            next();\n        } else {\n            tcc_error(\"bad expression syntax [%s]\", get_tok_str(tok, &tokc));\n        }\n        break;\n    }\n}\n    \nstatic void asm_expr_prod(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_unary(s1, pe);\n    for(;;) {\n        op = tok;\n        if (op != '*' && op != '/' && op != '%' && \n            op != TOK_SHL && op != TOK_SAR)\n            break;\n        next();\n        asm_expr_unary(s1, &e2);\n        if (pe->sym || e2.sym)\n            tcc_error(\"invalid operation with label\");\n        switch(op) {\n        case '*':\n            pe->v *= e2.v;\n            break;\n        case '/':  \n            if (e2.v == 0) {\n            div_error:\n                tcc_error(\"division by zero\");\n            }\n            pe->v /= e2.v;\n            break;\n        case '%':  \n            if (e2.v == 0)\n                goto div_error;\n            pe->v %= e2.v;\n            break;\n        case TOK_SHL:\n            pe->v <<= e2.v;\n            break;\n        default:\n        case TOK_SAR:\n            pe->v >>= e2.v;\n            break;\n        }\n    }\n}\n\nstatic void asm_expr_logic(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_prod(s1, pe);\n    for(;;) {\n        op = tok;\n        if (op != '&' && op != '|' && op != '^')\n            break;\n        next();\n        asm_expr_prod(s1, &e2);\n        if (pe->sym || e2.sym)\n            tcc_error(\"invalid operation with label\");\n        switch(op) {\n        case '&':\n            pe->v &= e2.v;\n            break;\n        case '|':  \n            pe->v |= e2.v;\n            break;\n        default:\n        case '^':\n            pe->v ^= e2.v;\n            break;\n        }\n    }\n}\n\nstatic inline void asm_expr_sum(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_logic(s1, pe);\n    for(;;) {\n        op = tok;\n        if (op != '+' && op != '-')\n            break;\n        next();\n        asm_expr_logic(s1, &e2);\n        if (op == '+') {\n            if (pe->sym != NULL && e2.sym != NULL)\n                goto cannot_relocate;\n            pe->v += e2.v;\n            if (pe->sym == NULL && e2.sym != NULL)\n                pe->sym = e2.sym;\n        } else {\n            pe->v -= e2.v;\n            /* NOTE: we are less powerful than gas in that case\n               because we store only one symbol in the expression */\n\t    if (!e2.sym) {\n\t\t/* OK */\n\t    } else if (pe->sym == e2.sym) { \n\t\t/* OK */\n\t\tpe->sym = NULL; /* same symbols can be subtracted to NULL */\n\t    } else {\n\t\tElfSym *esym1, *esym2;\n\t\tesym1 = elfsym(pe->sym);\n\t\tesym2 = elfsym(e2.sym);\n\t\tif (!esym2)\n\t\t    goto cannot_relocate;\n\t\tif (esym1 && esym1->st_shndx == esym2->st_shndx\n\t\t    && esym1->st_shndx != SHN_UNDEF) {\n\t\t    /* we also accept defined symbols in the same section */\n\t\t    pe->v += esym1->st_value - esym2->st_value;\n\t\t    pe->sym = NULL;\n\t\t} else if (esym2->st_shndx == cur_text_section->sh_num) {\n\t\t    /* When subtracting a defined symbol in current section\n\t\t       this actually makes the value PC-relative.  */\n\t\t    pe->v += 0 - esym2->st_value;\n\t\t    pe->pcrel = 1;\n\t\t    e2.sym = NULL;\n\t\t} else {\ncannot_relocate:\n\t\t    tcc_error(\"invalid operation with label\");\n\t\t}\n\t    }\n        }\n    }\n}\n\nstatic inline void asm_expr_cmp(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_sum(s1, pe);\n    for(;;) {\n        op = tok;\n\tif (op != TOK_EQ && op != TOK_NE\n\t    && (op > TOK_GT || op < TOK_ULE))\n            break;\n        next();\n        asm_expr_sum(s1, &e2);\n        if (pe->sym || e2.sym)\n            tcc_error(\"invalid operation with label\");\n        switch(op) {\n\tcase TOK_EQ:\n\t    pe->v = pe->v == e2.v;\n\t    break;\n\tcase TOK_NE:\n\t    pe->v = pe->v != e2.v;\n\t    break;\n\tcase TOK_LT:\n\t    pe->v = (int64_t)pe->v < (int64_t)e2.v;\n\t    break;\n\tcase TOK_GE:\n\t    pe->v = (int64_t)pe->v >= (int64_t)e2.v;\n\t    break;\n\tcase TOK_LE:\n\t    pe->v = (int64_t)pe->v <= (int64_t)e2.v;\n\t    break;\n\tcase TOK_GT:\n\t    pe->v = (int64_t)pe->v > (int64_t)e2.v;\n\t    break;\n        default:\n            break;\n        }\n\t/* GAS compare results are -1/0 not 1/0.  */\n\tpe->v = -(int64_t)pe->v;\n    }\n}\n\nST_FUNC void asm_expr(TCCState *s1, ExprValue *pe)\n{\n    asm_expr_cmp(s1, pe);\n}\n\nST_FUNC int asm_int_expr(TCCState *s1)\n{\n    ExprValue e;\n    asm_expr(s1, &e);\n    if (e.sym)\n        expect(\"constant\");\n    return e.v;\n}\n\nstatic Sym* asm_new_label1(TCCState *s1, int label, int is_local,\n                           int sh_num, int value)\n{\n    Sym *sym;\n    ElfSym *esym;\n\n    sym = asm_label_find(label);\n    if (sym) {\n\tesym = elfsym(sym);\n\t/* A VT_EXTERN symbol, even if it has a section is considered\n\t   overridable.  This is how we \"define\" .set targets.  Real\n\t   definitions won't have VT_EXTERN set.  */\n        if (esym && esym->st_shndx != SHN_UNDEF) {\n            /* the label is already defined */\n            if (IS_ASM_SYM(sym)\n                && (is_local == 1 || (sym->type.t & VT_EXTERN)))\n                goto new_label;\n            if (!(sym->type.t & VT_EXTERN))\n                tcc_error(\"assembler label '%s' already defined\",\n                          get_tok_str(label, NULL));\n        }\n    } else {\n    new_label:\n        sym = asm_label_push(label);\n    }\n    if (!sym->c)\n      put_extern_sym2(sym, SHN_UNDEF, 0, 0, 1);\n    esym = elfsym(sym);\n    esym->st_shndx = sh_num;\n    esym->st_value = value;\n    if (is_local != 2)\n        sym->type.t &= ~VT_EXTERN;\n    return sym;\n}\n\nstatic Sym* asm_new_label(TCCState *s1, int label, int is_local)\n{\n    return asm_new_label1(s1, label, is_local, cur_text_section->sh_num, ind);\n}\n\n/* Set the value of LABEL to that of some expression (possibly\n   involving other symbols).  LABEL can be overwritten later still.  */\nstatic Sym* set_symbol(TCCState *s1, int label)\n{\n    long n;\n    ExprValue e;\n    Sym *sym;\n    ElfSym *esym;\n    next();\n    asm_expr(s1, &e);\n    n = e.v;\n    esym = elfsym(e.sym);\n    if (esym)\n\tn += esym->st_value;\n    sym = asm_new_label1(s1, label, 2, esym ? esym->st_shndx : SHN_ABS, n);\n    elfsym(sym)->st_other |= ST_ASM_SET;\n    return sym;\n}\n\nstatic void use_section1(TCCState *s1, Section *sec)\n{\n    cur_text_section->data_offset = ind;\n    cur_text_section = sec;\n    ind = cur_text_section->data_offset;\n}\n\nstatic void use_section(TCCState *s1, const char *name)\n{\n    Section *sec;\n    sec = find_section(s1, name);\n    use_section1(s1, sec);\n}\n\nstatic void push_section(TCCState *s1, const char *name)\n{\n    Section *sec = find_section(s1, name);\n    sec->prev = cur_text_section;\n    use_section1(s1, sec);\n}\n\nstatic void pop_section(TCCState *s1)\n{\n    Section *prev = cur_text_section->prev;\n    if (!prev)\n        tcc_error(\".popsection without .pushsection\");\n    cur_text_section->prev = NULL;\n    use_section1(s1, prev);\n}\n\nstatic void asm_parse_directive(TCCState *s1, int global)\n{\n    int n, offset, v, size, tok1;\n    Section *sec;\n    uint8_t *ptr;\n\n    /* assembler directive */\n    sec = cur_text_section;\n    switch(tok) {\n    case TOK_ASMDIR_align:\n    case TOK_ASMDIR_balign:\n    case TOK_ASMDIR_p2align:\n    case TOK_ASMDIR_skip:\n    case TOK_ASMDIR_space:\n        tok1 = tok;\n        next();\n        n = asm_int_expr(s1);\n        if (tok1 == TOK_ASMDIR_p2align)\n        {\n            if (n < 0 || n > 30)\n                tcc_error(\"invalid p2align, must be between 0 and 30\");\n            n = 1 << n;\n            tok1 = TOK_ASMDIR_align;\n        }\n        if (tok1 == TOK_ASMDIR_align || tok1 == TOK_ASMDIR_balign) {\n            if (n < 0 || (n & (n-1)) != 0)\n                tcc_error(\"alignment must be a positive power of two\");\n            offset = (ind + n - 1) & -n;\n            size = offset - ind;\n            /* the section must have a compatible alignment */\n            if (sec->sh_addralign < n)\n                sec->sh_addralign = n;\n        } else {\n\t    if (n < 0)\n\t        n = 0;\n            size = n;\n        }\n        v = 0;\n        if (tok == ',') {\n            next();\n            v = asm_int_expr(s1);\n        }\n    zero_pad:\n        if (sec->sh_type != SHT_NOBITS) {\n            sec->data_offset = ind;\n            ptr = section_ptr_add(sec, size);\n            memset(ptr, v, size);\n        }\n        ind += size;\n        break;\n    case TOK_ASMDIR_quad:\n#ifdef TCC_TARGET_X86_64\n\tsize = 8;\n\tgoto asm_data;\n#else\n        next();\n        for(;;) {\n            uint64_t vl;\n            const char *p;\n\n            p = tokc.str.data;\n            if (tok != TOK_PPNUM) {\n            error_constant:\n                tcc_error(\"64 bit constant\");\n            }\n            vl = strtoll(p, (char **)&p, 0);\n            if (*p != '\\0')\n                goto error_constant;\n            next();\n            if (sec->sh_type != SHT_NOBITS) {\n                /* XXX: endianness */\n                gen_le32(vl);\n                gen_le32(vl >> 32);\n            } else {\n                ind += 8;\n            }\n            if (tok != ',')\n                break;\n            next();\n        }\n        break;\n#endif\n    case TOK_ASMDIR_byte:\n        size = 1;\n        goto asm_data;\n    case TOK_ASMDIR_word:\n    case TOK_ASMDIR_short:\n        size = 2;\n        goto asm_data;\n    case TOK_ASMDIR_long:\n    case TOK_ASMDIR_int:\n        size = 4;\n    asm_data:\n        next();\n        for(;;) {\n            ExprValue e;\n            asm_expr(s1, &e);\n            if (sec->sh_type != SHT_NOBITS) {\n                if (size == 4) {\n                    gen_expr32(&e);\n#ifdef TCC_TARGET_X86_64\n\t\t} else if (size == 8) {\n\t\t    gen_expr64(&e);\n#endif\n                } else {\n                    if (e.sym)\n                        expect(\"constant\");\n                    if (size == 1)\n                        g(e.v);\n                    else\n                        gen_le16(e.v);\n                }\n            } else {\n                ind += size;\n            }\n            if (tok != ',')\n                break;\n            next();\n        }\n        break;\n    case TOK_ASMDIR_fill:\n        {\n            int repeat, size, val, i, j;\n            uint8_t repeat_buf[8];\n            next();\n            repeat = asm_int_expr(s1);\n            if (repeat < 0) {\n                tcc_error(\"repeat < 0; .fill ignored\");\n                break;\n            }\n            size = 1;\n            val = 0;\n            if (tok == ',') {\n                next();\n                size = asm_int_expr(s1);\n                if (size < 0) {\n                    tcc_error(\"size < 0; .fill ignored\");\n                    break;\n                }\n                if (size > 8)\n                    size = 8;\n                if (tok == ',') {\n                    next();\n                    val = asm_int_expr(s1);\n                }\n            }\n            /* XXX: endianness */\n            repeat_buf[0] = val;\n            repeat_buf[1] = val >> 8;\n            repeat_buf[2] = val >> 16;\n            repeat_buf[3] = val >> 24;\n            repeat_buf[4] = 0;\n            repeat_buf[5] = 0;\n            repeat_buf[6] = 0;\n            repeat_buf[7] = 0;\n            for(i = 0; i < repeat; i++) {\n                for(j = 0; j < size; j++) {\n                    g(repeat_buf[j]);\n                }\n            }\n        }\n        break;\n    case TOK_ASMDIR_rept:\n        {\n            int repeat;\n            TokenString *init_str;\n            next();\n            repeat = asm_int_expr(s1);\n            init_str = tok_str_alloc();\n            while (next(), tok != TOK_ASMDIR_endr) {\n                if (tok == CH_EOF)\n                    tcc_error(\"we at end of file, .endr not found\");\n                tok_str_add_tok(init_str);\n            }\n            tok_str_add(init_str, TOK_EOF);\n            begin_macro(init_str, 1);\n            while (repeat-- > 0) {\n                tcc_assemble_internal(s1, (parse_flags & PARSE_FLAG_PREPROCESS),\n\t\t\t\t      global);\n                macro_ptr = init_str->str;\n            }\n            end_macro();\n            next();\n            break;\n        }\n    case TOK_ASMDIR_org:\n        {\n            unsigned long n;\n\t    ExprValue e;\n\t    ElfSym *esym;\n            next();\n\t    asm_expr(s1, &e);\n\t    n = e.v;\n\t    esym = elfsym(e.sym);\n\t    if (esym) {\n\t\tif (esym->st_shndx != cur_text_section->sh_num)\n\t\t  expect(\"constant or same-section symbol\");\n\t\tn += esym->st_value;\n\t    }\n            if (n < ind)\n                tcc_error(\"attempt to .org backwards\");\n            v = 0;\n            size = n - ind;\n            goto zero_pad;\n        }\n        break;\n    case TOK_ASMDIR_set:\n\tnext();\n\ttok1 = tok;\n\tnext();\n\t/* Also accept '.set stuff', but don't do anything with this.\n\t   It's used in GAS to set various features like '.set mips16'.  */\n\tif (tok == ',')\n\t    set_symbol(s1, tok1);\n\tbreak;\n    case TOK_ASMDIR_globl:\n    case TOK_ASMDIR_global:\n    case TOK_ASMDIR_weak:\n    case TOK_ASMDIR_hidden:\n\ttok1 = tok;\n\tdo { \n            Sym *sym;\n            next();\n            sym = get_asm_sym(tok, NULL);\n\t    if (tok1 != TOK_ASMDIR_hidden)\n                sym->type.t &= ~VT_STATIC;\n            if (tok1 == TOK_ASMDIR_weak)\n                sym->a.weak = 1;\n\t    else if (tok1 == TOK_ASMDIR_hidden)\n\t        sym->a.visibility = STV_HIDDEN;\n            update_storage(sym);\n            next();\n\t} while (tok == ',');\n\tbreak;\n    case TOK_ASMDIR_string:\n    case TOK_ASMDIR_ascii:\n    case TOK_ASMDIR_asciz:\n        {\n            const char *p;\n            int i, size, t;\n\n            t = tok;\n            next();\n            for(;;) {\n                if (tok != TOK_STR)\n                    expect(\"string constant\");\n                p = tokc.str.data;\n                size = tokc.str.size;\n                if (t == TOK_ASMDIR_ascii && size > 0)\n                    size--;\n                for(i = 0; i < size; i++)\n                    g(p[i]);\n                next();\n                if (tok == ',') {\n                    next();\n                } else if (tok != TOK_STR) {\n                    break;\n                }\n            }\n\t}\n\tbreak;\n    case TOK_ASMDIR_text:\n    case TOK_ASMDIR_data:\n    case TOK_ASMDIR_bss:\n\t{ \n            char sname[64];\n            tok1 = tok;\n            n = 0;\n            next();\n            if (tok != ';' && tok != TOK_LINEFEED) {\n\t\tn = asm_int_expr(s1);\n\t\tnext();\n            }\n            if (n)\n                sprintf(sname, \"%s%d\", get_tok_str(tok1, NULL), n);\n            else\n                sprintf(sname, \"%s\", get_tok_str(tok1, NULL));\n            use_section(s1, sname);\n\t}\n\tbreak;\n    case TOK_ASMDIR_file:\n        {\n            const char *p;\n            parse_flags &= ~PARSE_FLAG_TOK_STR;\n            next();\n            if (tok == TOK_PPNUM)\n                next();\n            if (tok == TOK_PPSTR && tokc.str.data[0] == '\"') {\n                tokc.str.data[tokc.str.size - 2] = 0;\n                p = tokc.str.data + 1;\n            } else if (tok >= TOK_IDENT) {\n                p = get_tok_str(tok, &tokc);\n            } else {\n                skip_to_eol(0);\n                break;\n            }\n            tccpp_putfile(p);\n            next();\n        }\n        break;\n    case TOK_ASMDIR_ident:\n        {\n            char ident[256];\n\n            ident[0] = '\\0';\n            next();\n            if (tok == TOK_STR)\n                pstrcat(ident, sizeof(ident), tokc.str.data);\n            else\n                pstrcat(ident, sizeof(ident), get_tok_str(tok, NULL));\n            tcc_warning_c(warn_unsupported)(\"ignoring .ident %s\", ident);\n            next();\n        }\n        break;\n    case TOK_ASMDIR_size:\n        { \n            Sym *sym;\n\n            next();\n            sym = asm_label_find(tok);\n            if (!sym) {\n                tcc_error(\"label not found: %s\", get_tok_str(tok, NULL));\n            }\n            /* XXX .size name,label2-label1 */\n            tcc_warning_c(warn_unsupported)(\"ignoring .size %s,*\", get_tok_str(tok, NULL));\n            next();\n            skip(',');\n            while (tok != TOK_LINEFEED && tok != ';' && tok != CH_EOF) {\n                next();\n            }\n        }\n        break;\n    case TOK_ASMDIR_type:\n        { \n            Sym *sym;\n            const char *newtype;\n            int st_type;\n\n            next();\n            sym = get_asm_sym(tok, NULL);\n            next();\n            skip(',');\n            if (tok == TOK_STR) {\n                newtype = tokc.str.data;\n            } else {\n                if (tok == '@' || tok == '%')\n                    next();\n                newtype = get_tok_str(tok, NULL);\n            }\n\n            if (!strcmp(newtype, \"function\") || !strcmp(newtype, \"STT_FUNC\")) {\n                if (IS_ASM_SYM(sym))\n                    sym->type.t = (sym->type.t & ~VT_ASM) | VT_ASM_FUNC;\n                st_type = STT_FUNC;\n            set_st_type:\n                if (sym->c) {\n                    ElfSym *esym = elfsym(sym);\n                    esym->st_info = ELFW(ST_INFO)(ELFW(ST_BIND)(esym->st_info), st_type);\n                }\n            } else if (!strcmp(newtype, \"object\") || !strcmp(newtype, \"STT_OBJECT\")) {\n                st_type = STT_OBJECT;\n                goto set_st_type;\n            } else\n                tcc_warning_c(warn_unsupported)(\"change type of '%s' from 0x%x to '%s' ignored\",\n                    get_tok_str(sym->v, NULL), sym->type.t, newtype);\n\n            next();\n        }\n        break;\n    case TOK_ASMDIR_pushsection:\n    case TOK_ASMDIR_section:\n        {\n            char sname[256];\n\t    int old_nb_section = s1->nb_sections;\n            int flags = SHF_ALLOC;\n\n\t    tok1 = tok;\n            /* XXX: support more options */\n            next();\n            sname[0] = '\\0';\n            while (tok != ';' && tok != TOK_LINEFEED && tok != ',') {\n                if (tok == TOK_STR)\n                    pstrcat(sname, sizeof(sname), tokc.str.data);\n                else\n                    pstrcat(sname, sizeof(sname), get_tok_str(tok, NULL));\n                next();\n            }\n            if (tok == ',') {\n                const char *p;\n                /* skip section options */\n                next();\n                if (tok != TOK_STR)\n                    expect(\"string constant\");\n                for (p = tokc.str.data; *p; ++p) {\n                    if (*p == 'w')\n                        flags |= SHF_WRITE;\n                    if (*p == 'x')\n                        flags |= SHF_EXECINSTR;\n                }\n                next();\n                if (tok == ',') {\n                    next();\n                    if (tok == '@' || tok == '%')\n                        next();\n                    next();\n                }\n            }\n            last_text_section = cur_text_section;\n\t    if (tok1 == TOK_ASMDIR_section)\n\t        use_section(s1, sname);\n\t    else\n\t        push_section(s1, sname);\n\t    /* If we just allocated a new section reset its alignment to\n\t       1.  new_section normally acts for GCC compatibility and\n\t       sets alignment to PTR_SIZE.  The assembler behaves different. */\n\t    if (old_nb_section != s1->nb_sections) {\n\t        cur_text_section->sh_addralign = 1;\n\t        cur_text_section->sh_flags = flags;\n            }\n        }\n        break;\n    case TOK_ASMDIR_previous:\n        { \n            Section *sec;\n            next();\n            if (!last_text_section)\n                tcc_error(\"no previous section referenced\");\n            sec = cur_text_section;\n            use_section1(s1, last_text_section);\n            last_text_section = sec;\n        }\n        break;\n    case TOK_ASMDIR_popsection:\n\tnext();\n\tpop_section(s1);\n\tbreak;\n#ifdef TCC_TARGET_I386\n    case TOK_ASMDIR_code16:\n        {\n            next();\n            s1->seg_size = 16;\n        }\n        break;\n    case TOK_ASMDIR_code32:\n        {\n            next();\n            s1->seg_size = 32;\n        }\n        break;\n#endif\n#ifdef TCC_TARGET_X86_64\n    /* added for compatibility with GAS */\n    case TOK_ASMDIR_code64:\n        next();\n        break;\n#endif\n#ifdef TCC_TARGET_RISCV64\n    case TOK_ASMDIR_option:\n        next();\n        switch(tok){\n            case TOK_ASM_rvc:    /* Will be deprecated soon in favor of arch */\n            case TOK_ASM_norvc:  /* Will be deprecated soon in favor of arch */\n            case TOK_ASM_pic:\n            case TOK_ASM_nopic:\n            case TOK_ASM_relax:\n            case TOK_ASM_norelax:\n            case TOK_ASM_push:\n            case TOK_ASM_pop:\n                /* TODO: unimplemented */\n                next();\n                break;\n            case TOK_ASM_arch:\n                /* TODO: unimplemented, requires extra parsing */\n                tcc_error(\"unimp .option '.%s'\", get_tok_str(tok, NULL));\n                break;\n            default:\n                tcc_error(\"unknown .option '.%s'\", get_tok_str(tok, NULL));\n                break;\n        }\n        break;\n#endif\n    /* TODO: Implement symvar support. FreeBSD >= 14 needs this */\n    case TOK_ASMDIR_symver:\n\tnext();\n\tnext();\n        skip(',');\n\tnext();\n        skip('@');\n\tnext();\n\tbreak;\n    default:\n        tcc_error(\"unknown assembler directive '.%s'\", get_tok_str(tok, NULL));\n        break;\n    }\n}\n\n\n/* assemble a file */\nstatic int tcc_assemble_internal(TCCState *s1, int do_preprocess, int global)\n{\n    int opcode;\n    int saved_parse_flags = parse_flags;\n\n    parse_flags = PARSE_FLAG_ASM_FILE | PARSE_FLAG_TOK_STR;\n    if (do_preprocess)\n        parse_flags |= PARSE_FLAG_PREPROCESS;\n    for(;;) {\n        next();\n        if (tok == TOK_EOF)\n            break;\n        tcc_debug_line(s1);\n        parse_flags |= PARSE_FLAG_LINEFEED; /* XXX: suppress that hack */\n    redo:\n        if (tok == '#') {\n            /* horrible gas comment */\n            while (tok != TOK_LINEFEED)\n                next();\n        } else if (tok >= TOK_ASMDIR_FIRST && tok <= TOK_ASMDIR_LAST) {\n            asm_parse_directive(s1, global);\n        } else if (tok == TOK_PPNUM) {\n            const char *p;\n            int n;\n            p = tokc.str.data;\n            n = strtoul(p, (char **)&p, 10);\n            if (*p != '\\0')\n                expect(\"':'\");\n            /* new local label */\n            asm_new_label(s1, asm_get_local_label_name(s1, n), 1);\n            next();\n            skip(':');\n            goto redo;\n        } else if (tok >= TOK_IDENT) {\n            /* instruction or label */\n            opcode = tok;\n            next();\n            if (tok == ':') {\n                /* new label */\n                asm_new_label(s1, opcode, 0);\n                next();\n                goto redo;\n            } else if (tok == '=') {\n\t\tset_symbol(s1, opcode);\n                goto redo;\n            } else {\n                asm_opcode(s1, opcode);\n            }\n        }\n        /* end of line */\n        if (tok != ';' && tok != TOK_LINEFEED)\n            expect(\"end of line\");\n        parse_flags &= ~PARSE_FLAG_LINEFEED; /* XXX: suppress that hack */\n    }\n\n    parse_flags = saved_parse_flags;\n    return 0;\n}\n\n/* Assemble the current file */\nST_FUNC int tcc_assemble(TCCState *s1, int do_preprocess)\n{\n    int ret;\n    tcc_debug_start(s1);\n    /* default section is text */\n    cur_text_section = text_section;\n    ind = cur_text_section->data_offset;\n    nocode_wanted = 0;\n    ret = tcc_assemble_internal(s1, do_preprocess, 1);\n    cur_text_section->data_offset = ind;\n    tcc_debug_end(s1);\n    return ret;\n}\n\n/********************************************************************/\n/* GCC inline asm support */\n\n/* assemble the string 'str' in the current C compilation unit without\n   C preprocessing. */\nstatic void tcc_assemble_inline(TCCState *s1, const char *str, int len, int global)\n{\n    const int *saved_macro_ptr = macro_ptr;\n    int dotid = set_idnum('.', IS_ID);\n#ifndef TCC_TARGET_RISCV64\n    int dolid = set_idnum('$', 0);\n#endif\n\n    tcc_open_bf(s1, \":asm:\", len);\n    memcpy(file->buffer, str, len);\n    macro_ptr = NULL;\n    tcc_assemble_internal(s1, 0, global);\n    tcc_close();\n\n#ifndef TCC_TARGET_RISCV64\n    set_idnum('$', dolid);\n#endif\n    set_idnum('.', dotid);\n    macro_ptr = saved_macro_ptr;\n}\n\n/* find a constraint by its number or id (gcc 3 extended\n   syntax). return -1 if not found. Return in *pp in char after the\n   constraint */\nST_FUNC int find_constraint(ASMOperand *operands, int nb_operands, \n                           const char *name, const char **pp)\n{\n    int index;\n    TokenSym *ts;\n    const char *p;\n\n    if (isnum(*name)) {\n        index = 0;\n        while (isnum(*name)) {\n            index = (index * 10) + (*name) - '0';\n            name++;\n        }\n        if ((unsigned)index >= nb_operands)\n            index = -1;\n    } else if (*name == '[') {\n        name++;\n        p = strchr(name, ']');\n        if (p) {\n            ts = tok_alloc(name, p - name);\n            for(index = 0; index < nb_operands; index++) {\n                if (operands[index].id == ts->tok)\n                    goto found;\n            }\n            index = -1;\n        found:\n            name = p + 1;\n        } else {\n            index = -1;\n        }\n    } else {\n        index = -1;\n    }\n    if (pp)\n        *pp = name;\n    return index;\n}\n\nstatic void subst_asm_operands(ASMOperand *operands, int nb_operands, \n                               CString *out_str, const char *str)\n{\n    int c, index, modifier;\n    ASMOperand *op;\n    SValue sv;\n\n    for(;;) {\n        c = *str++;\n        if (c == '%') {\n            if (*str == '%') {\n                str++;\n                goto add_char;\n            }\n            modifier = 0;\n            if (*str == 'c' || *str == 'n' ||\n                *str == 'b' || *str == 'w' || *str == 'h' || *str == 'k' ||\n\t\t*str == 'q' || *str == 'l' ||\n#ifdef TCC_TARGET_RISCV64\n\t\t*str == 'z' ||\n#endif\n\t\t/* P in GCC would add \"@PLT\" to symbol refs in PIC mode,\n\t\t   and make literal operands not be decorated with '$'.  */\n\t\t*str == 'P')\n                modifier = *str++;\n            index = find_constraint(operands, nb_operands, str, &str);\n            if (index < 0)\n                tcc_error(\"invalid operand reference after %%\");\n            op = &operands[index];\n            if (modifier == 'l') {\n                cstr_cat(out_str, get_tok_str(op->is_label, NULL), -1);\n            } else {\n                sv = *op->vt;\n                if (op->reg >= 0) {\n                    sv.r = op->reg;\n                    if ((op->vt->r & VT_VALMASK) == VT_LLOCAL && op->is_memory)\n                      sv.r |= VT_LVAL;\n                }\n                subst_asm_operand(out_str, &sv, modifier);\n            }\n        } else {\n        add_char:\n            cstr_ccat(out_str, c);\n            if (c == '\\0')\n                break;\n        }\n    }\n}\n\n\nstatic void parse_asm_operands(ASMOperand *operands, int *nb_operands_ptr,\n                               int is_output)\n{\n    ASMOperand *op;\n    int nb_operands;\n    char* astr;\n\n    if (tok != ':') {\n        nb_operands = *nb_operands_ptr;\n        for(;;) {\n            if (nb_operands >= MAX_ASM_OPERANDS)\n                tcc_error(\"too many asm operands\");\n            op = &operands[nb_operands++];\n            op->id = 0;\n            if (tok == '[') {\n                next();\n                if (tok < TOK_IDENT)\n                    expect(\"identifier\");\n                op->id = tok;\n                next();\n                skip(']');\n            }\n\t    astr = parse_mult_str(\"string constant\")->data;\n            pstrcpy(op->constraint, sizeof op->constraint, astr);\n            skip('(');\n            gexpr();\n            if (is_output) {\n                if (!(vtop->type.t & VT_ARRAY))\n                    test_lvalue();\n            } else {\n                /* we want to avoid LLOCAL case, except when the 'm'\n                   constraint is used. Note that it may come from\n                   register storage, so we need to convert (reg)\n                   case */\n                if ((vtop->r & VT_LVAL) &&\n                    ((vtop->r & VT_VALMASK) == VT_LLOCAL ||\n                     (vtop->r & VT_VALMASK) < VT_CONST) &&\n                    !strchr(op->constraint, 'm')) {\n                    gv(RC_INT);\n                }\n            }\n            op->vt = vtop;\n            skip(')');\n            if (tok == ',') {\n                next();\n            } else {\n                break;\n            }\n        }\n        *nb_operands_ptr = nb_operands;\n    }\n}\n\n/* parse the GCC asm() instruction */\nST_FUNC void asm_instr(void)\n{\n    CString astr, *astr1;\n\n    ASMOperand operands[MAX_ASM_OPERANDS];\n    int nb_outputs, nb_operands, i, must_subst, out_reg, nb_labels;\n    uint8_t clobber_regs[NB_ASM_REGS];\n    Section *sec;\n\n    /* since we always generate the asm() instruction, we can ignore\n       volatile */\n    while (tok == TOK_VOLATILE1 || tok == TOK_VOLATILE2 || tok == TOK_VOLATILE3\n           || tok == TOK_GOTO) {\n        next();\n    }\n\n    astr1 = parse_asm_str();\n    cstr_new_s(&astr);\n    cstr_cat(&astr, astr1->data, astr1->size);\n\n    nb_operands = 0;\n    nb_outputs = 0;\n    nb_labels = 0;\n    must_subst = 0;\n    memset(clobber_regs, 0, sizeof(clobber_regs));\n    if (tok == ':') {\n        next();\n        must_subst = 1;\n        /* output args */\n        parse_asm_operands(operands, &nb_operands, 1);\n        nb_outputs = nb_operands;\n        if (tok == ':') {\n            next();\n            if (tok != ')') {\n                /* input args */\n                parse_asm_operands(operands, &nb_operands, 0);\n                if (tok == ':') {\n                    /* clobber list */\n                    /* XXX: handle registers */\n                    next();\n                    for(;;) {\n                        if (tok == ':')\n                          break;\n                        if (tok != TOK_STR)\n                            expect(\"string constant\");\n                        asm_clobber(clobber_regs, tokc.str.data);\n                        next();\n                        if (tok == ',') {\n                            next();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                if (tok == ':') {\n                    /* goto labels */\n                    next();\n                    for (;;) {\n                        Sym *csym;\n                        int asmname;\n                        if (nb_operands + nb_labels >= MAX_ASM_OPERANDS)\n                          tcc_error(\"too many asm operands\");\n                        if (tok < TOK_UIDENT)\n                          expect(\"label identifier\");\n                        operands[nb_operands + nb_labels++].id = tok;\n\n                        csym = label_find(tok);\n                        if (!csym) {\n                            csym = label_push(&global_label_stack, tok,\n                                              LABEL_FORWARD);\n                        } else {\n                            if (csym->r == LABEL_DECLARED)\n                              csym->r = LABEL_FORWARD;\n                        }\n                        next();\n                        asmname = asm_get_prefix_name(tcc_state, \"LG.\",\n                                                      ++asmgoto_n);\n                        if (!csym->c)\n                          put_extern_sym2(csym, SHN_UNDEF, 0, 0, 1);\n                        get_asm_sym(asmname, csym);\n                        operands[nb_operands + nb_labels - 1].is_label = asmname;\n\n                        if (tok != ',')\n                          break;\n                        next();\n                    }\n                }\n            }\n        }\n    }\n    skip(')');\n    /* NOTE: we do not eat the ';' so that we can restore the current\n       token after the assembler parsing */\n    if (tok != ';')\n        expect(\"';'\");\n    \n    /* save all values in the memory */\n    save_regs(0);\n\n    /* compute constraints */\n    asm_compute_constraints(operands, nb_operands, nb_outputs, \n                            clobber_regs, &out_reg);\n\n    /* substitute the operands in the asm string. No substitution is\n       done if no operands (GCC behaviour) */\n#ifdef ASM_DEBUG\n    printf(\"asm: \\\"%s\\\"\\n\", (char *)astr.data);\n#endif\n    if (must_subst) {\n        cstr_reset(astr1);\n        cstr_cat(astr1, astr.data, astr.size);\n        cstr_reset(&astr);\n        subst_asm_operands(operands, nb_operands + nb_labels, &astr, astr1->data);\n    }\n\n#ifdef ASM_DEBUG\n    printf(\"subst_asm: \\\"%s\\\"\\n\", (char *)astr.data);\n#endif\n\n    /* generate loads */\n    asm_gen_code(operands, nb_operands, nb_outputs, 0, \n                 clobber_regs, out_reg);    \n\n    /* We don't allow switching section within inline asm to\n       bleed out to surrounding code.  */\n    sec = cur_text_section;\n    /* assemble the string with tcc internal assembler */\n    tcc_assemble_inline(tcc_state, astr.data, astr.size - 1, 0);\n    cstr_free_s(&astr);\n    if (sec != cur_text_section) {\n        tcc_warning(\"inline asm tries to change current section\");\n        use_section1(tcc_state, sec);\n    }\n\n    /* restore the current C token */\n    next();\n\n    /* store the output values if needed */\n    asm_gen_code(operands, nb_operands, nb_outputs, 1, \n                 clobber_regs, out_reg);\n    \n    /* free everything */\n    for(i=0;i<nb_operands;i++) {\n        vpop();\n    }\n\n}\n\nST_FUNC void asm_global_instr(void)\n{\n    CString *astr;\n    int saved_nocode_wanted = nocode_wanted;\n\n    /* Global asm blocks are always emitted.  */\n    nocode_wanted = 0;\n    next();\n    astr = parse_asm_str();\n    skip(')');\n    /* NOTE: we do not eat the ';' so that we can restore the current\n       token after the assembler parsing */\n    if (tok != ';')\n        expect(\"';'\");\n    \n#ifdef ASM_DEBUG\n    printf(\"asm_global: \\\"%s\\\"\\n\", (char *)astr->data);\n#endif\n    cur_text_section = text_section;\n    ind = cur_text_section->data_offset;\n\n    /* assemble the string with tcc internal assembler */\n    tcc_assemble_inline(tcc_state, astr->data, astr->size - 1, 1);\n    \n    cur_text_section->data_offset = ind;\n\n    /* restore the current C token */\n    next();\n\n    nocode_wanted = saved_nocode_wanted;\n}\n\n/********************************************************/\n#else\nST_FUNC int tcc_assemble(TCCState *s1, int do_preprocess)\n{\n    tcc_error(\"asm not supported\");\n}\n\nST_FUNC void asm_instr(void)\n{\n    tcc_error(\"inline asm() not supported\");\n}\n\nST_FUNC void asm_global_instr(void)\n{\n    tcc_error(\"inline asm() not supported\");\n}\n#endif /* CONFIG_TCC_ASM */\n"
        },
        {
          "name": "tcccoff.c",
          "type": "blob",
          "size": 22.3046875,
          "content": "/*\n *  COFF file handling for TCC\n * \n *  Copyright (c) 2003, 2004 TK\n *  Copyright (c) 2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"tcc.h\"\n\n/* XXX: this file uses tcc_error() to the effect of exit(1) */\n#undef _tcc_error\n\n#define MAXNSCNS 255\t\t/* MAXIMUM NUMBER OF SECTIONS         */\n#define MAX_STR_TABLE 1000000\nAOUTHDR o_filehdr;\t\t/* OPTIONAL (A.OUT) FILE HEADER       */\n\nSCNHDR section_header[MAXNSCNS];\n\n#define MAX_FUNCS 1000\n#define MAX_FUNC_NAME_LENGTH 128\n\nint nFuncs;\nchar Func[MAX_FUNCS][MAX_FUNC_NAME_LENGTH];\nchar AssociatedFile[MAX_FUNCS][MAX_FUNC_NAME_LENGTH];\nint LineNoFilePtr[MAX_FUNCS];\nint EndAddress[MAX_FUNCS];\nint LastLineNo[MAX_FUNCS];\nint FuncEntries[MAX_FUNCS];\n\nint OutputTheSection(Section * sect);\nshort int GetCoffFlags(const char *s);\nvoid SortSymbolTable(TCCState *s1);\nSection *FindSection(TCCState * s1, const char *sname);\n\nint C67_main_entry_point;\n\nint FindCoffSymbolIndex(TCCState * s1, const char *func_name);\nint nb_syms;\n\ntypedef struct {\n    long tag;\n    long size;\n    long fileptr;\n    long nextsym;\n    short int dummy;\n} AUXFUNC;\n\ntypedef struct {\n    long regmask;\n    unsigned short lineno;\n    unsigned short nentries;\n    int localframe;\n    int nextentry;\n    short int dummy;\n} AUXBF;\n\ntypedef struct {\n    long dummy;\n    unsigned short lineno;\n    unsigned short dummy1;\n    int dummy2;\n    int dummy3;\n    unsigned short dummy4;\n} AUXEF;\n\nST_FUNC int tcc_output_coff(TCCState *s1, FILE *f)\n{\n    Section *tcc_sect;\n    SCNHDR *coff_sec;\n    int file_pointer;\n    char *Coff_str_table, *pCoff_str_table;\n    int CoffTextSectionNo, coff_nb_syms;\n    FILHDR file_hdr;\t\t/* FILE HEADER STRUCTURE              */\n    Section *stext, *sdata, *sbss;\n    int i, NSectionsToOutput = 0;\n\n    Coff_str_table = pCoff_str_table = NULL;\n\n    stext = FindSection(s1, \".text\");\n    sdata = FindSection(s1, \".data\");\n    sbss = FindSection(s1, \".bss\");\n\n    nb_syms = symtab_section->data_offset / sizeof(Elf32_Sym);\n    coff_nb_syms = FindCoffSymbolIndex(s1, \"XXXXXXXXXX1\");\n\n    file_hdr.f_magic = COFF_C67_MAGIC;\t/* magic number */\n    file_hdr.f_timdat = 0;\t/* time & date stamp */\n    file_hdr.f_opthdr = sizeof(AOUTHDR);\t/* sizeof(optional hdr) */\n    file_hdr.f_flags = 0x1143;\t/* flags (copied from what code composer does) */\n    file_hdr.f_TargetID = 0x99;\t/* for C6x = 0x0099 */\n\n    o_filehdr.magic = 0x0108;\t/* see magic.h                          */\n    o_filehdr.vstamp = 0x0190;\t/* version stamp                        */\n    o_filehdr.tsize = stext->data_offset;\t/* text size in bytes, padded to FW bdry */\n    o_filehdr.dsize = sdata->data_offset;\t/* initialized data \"  \"                */\n    o_filehdr.bsize = sbss->data_offset;\t/* uninitialized data \"   \"             */\n    o_filehdr.entrypt = C67_main_entry_point;\t/* entry pt.                          */\n    o_filehdr.text_start = stext->sh_addr;\t/* base of text used for this file      */\n    o_filehdr.data_start = sdata->sh_addr;\t/* base of data used for this file      */\n\n\n    // create all the section headers\n\n    file_pointer = FILHSZ + sizeof(AOUTHDR);\n\n    CoffTextSectionNo = -1;\n\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (OutputTheSection(tcc_sect)) {\n\t    NSectionsToOutput++;\n\n\t    if (CoffTextSectionNo == -1 && tcc_sect == stext)\n\t\tCoffTextSectionNo = NSectionsToOutput;\t// rem which coff sect number the .text sect is\n\n\t    strcpy(coff_sec->s_name, tcc_sect->name);\t/* section name */\n\n\t    coff_sec->s_paddr = tcc_sect->sh_addr;\t/* physical address */\n\t    coff_sec->s_vaddr = tcc_sect->sh_addr;\t/* virtual address */\n\t    coff_sec->s_size = tcc_sect->data_offset;\t/* section size */\n\t    coff_sec->s_scnptr = 0;\t/* file ptr to raw data for section */\n\t    coff_sec->s_relptr = 0;\t/* file ptr to relocation */\n\t    coff_sec->s_lnnoptr = 0;\t/* file ptr to line numbers */\n\t    coff_sec->s_nreloc = 0;\t/* number of relocation entries */\n\t    coff_sec->s_flags = GetCoffFlags(coff_sec->s_name);\t/* flags */\n\t    coff_sec->s_reserved = 0;\t/* reserved byte */\n\t    coff_sec->s_page = 0;\t/* memory page id */\n\n\t    file_pointer += sizeof(SCNHDR);\n\t}\n    }\n\n    file_hdr.f_nscns = NSectionsToOutput;\t/* number of sections */\n\n    // now loop through and determine file pointer locations\n    // for the raw data\n\n\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (OutputTheSection(tcc_sect)) {\n\t    // put raw data\n\t    coff_sec->s_scnptr = file_pointer;\t/* file ptr to raw data for section */\n\t    file_pointer += coff_sec->s_size;\n\t}\n    }\n\n    // now loop through and determine file pointer locations\n    // for the relocation data\n\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (OutputTheSection(tcc_sect)) {\n\t    // put relocations data\n\t    if (coff_sec->s_nreloc > 0) {\n\t\tcoff_sec->s_relptr = file_pointer;\t/* file ptr to relocation */\n\t\tfile_pointer += coff_sec->s_nreloc * sizeof(struct reloc);\n\t    }\n\t}\n    }\n\n    // now loop through and determine file pointer locations\n    // for the line number data\n\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tcoff_sec->s_nlnno = 0;\n\tcoff_sec->s_lnnoptr = 0;\n\n\tif (s1->do_debug && tcc_sect == stext) {\n\t    // count how many line nos data\n\n\t    // also find association between source file name and function\n\t    // so we can sort the symbol table\n\n\n\t    Stab_Sym *sym, *sym_end;\n\t    char func_name[MAX_FUNC_NAME_LENGTH],\n\t\tlast_func_name[MAX_FUNC_NAME_LENGTH];\n\t    unsigned long func_addr, last_pc, pc;\n\t    const char *incl_files[INCLUDE_STACK_SIZE];\n\t    int incl_index, len, last_line_num;\n\t    const char *str, *p;\n\n\t    coff_sec->s_lnnoptr = file_pointer;\t/* file ptr to linno */\n\n\n\t    func_name[0] = '\\0';\n\t    func_addr = 0;\n\t    incl_index = 0;\n\t    last_func_name[0] = '\\0';\n\t    last_pc = 0xffffffff;\n\t    last_line_num = 1;\n\t    sym = (Stab_Sym *) stab_section->data + 1;\n\t    sym_end =\n\t\t(Stab_Sym *) (stab_section->data +\n\t\t\t      stab_section->data_offset);\n\n\t    nFuncs = 0;\n\t    while (sym < sym_end) {\n\t\tswitch (sym->n_type) {\n\t\t    /* function start or end */\n\t\tcase N_FUN:\n\t\t    if (sym->n_strx == 0) {\n\t\t\t// end of function\n\n\t\t\tcoff_sec->s_nlnno++;\n\t\t\tfile_pointer += LINESZ;\n\n\t\t\tpc = sym->n_value + func_addr;\n\t\t\tfunc_name[0] = '\\0';\n\t\t\tfunc_addr = 0;\n\t\t\tEndAddress[nFuncs] = pc;\n\t\t\tFuncEntries[nFuncs] =\n\t\t\t    (file_pointer -\n\t\t\t     LineNoFilePtr[nFuncs]) / LINESZ - 1;\n\t\t\tLastLineNo[nFuncs++] = last_line_num + 1;\n\t\t    } else {\n\t\t\t// beginning of function\n\n\t\t\tLineNoFilePtr[nFuncs] = file_pointer;\n\t\t\tcoff_sec->s_nlnno++;\n\t\t\tfile_pointer += LINESZ;\n\n\t\t\tstr =\n\t\t\t    (const char *) stabstr_section->data +\n\t\t\t    sym->n_strx;\n\n\t\t\tp = strchr(str, ':');\n\t\t\tif (!p) {\n\t\t\t    pstrcpy(func_name, sizeof(func_name), str);\n\t\t\t    pstrcpy(Func[nFuncs], sizeof(func_name), str);\n\t\t\t} else {\n\t\t\t    len = p - str;\n\t\t\t    if (len > sizeof(func_name) - 1)\n\t\t\t\tlen = sizeof(func_name) - 1;\n\t\t\t    memcpy(func_name, str, len);\n\t\t\t    memcpy(Func[nFuncs], str, len);\n\t\t\t    func_name[len] = '\\0';\n\t\t\t}\n\n\t\t\t// save the file that it came in so we can sort later\n\t\t\tpstrcpy(AssociatedFile[nFuncs], sizeof(func_name),\n\t\t\t\tincl_files[incl_index - 1]);\n\n\t\t\tfunc_addr = sym->n_value;\n\t\t    }\n\t\t    break;\n\n\t\t    /* line number info */\n\t\tcase N_SLINE:\n\t\t    pc = sym->n_value + func_addr;\n\n\t\t    last_pc = pc;\n\t\t    last_line_num = sym->n_desc;\n\n\t\t    /* XXX: slow! */\n\t\t    strcpy(last_func_name, func_name);\n\n\t\t    coff_sec->s_nlnno++;\n\t\t    file_pointer += LINESZ;\n\t\t    break;\n\t\t    /* include files */\n\t\tcase N_BINCL:\n\t\t    str =\n\t\t\t(const char *) stabstr_section->data + sym->n_strx;\n\t\t  add_incl:\n\t\t    if (incl_index < INCLUDE_STACK_SIZE) {\n\t\t\tincl_files[incl_index++] = str;\n\t\t    }\n\t\t    break;\n\t\tcase N_EINCL:\n\t\t    if (incl_index > 1)\n\t\t\tincl_index--;\n\t\t    break;\n\t\tcase N_SO:\n\t\t    if (sym->n_strx == 0) {\n\t\t\tincl_index = 0;\t/* end of translation unit */\n\t\t    } else {\n\t\t\tstr =\n\t\t\t    (const char *) stabstr_section->data +\n\t\t\t    sym->n_strx;\n\t\t\t/* do not add path */\n\t\t\tlen = strlen(str);\n\t\t\tif (len > 0 && str[len - 1] != '/')\n\t\t\t    goto add_incl;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tsym++;\n\t    }\n\t}\n\n    }\n\n    file_hdr.f_symptr = file_pointer;\t/* file pointer to symtab */\n\n    if (s1->do_debug)\n\tfile_hdr.f_nsyms = coff_nb_syms;\t/* number of symtab entries */\n    else\n\tfile_hdr.f_nsyms = 0;\n\n    file_pointer += file_hdr.f_nsyms * SYMNMLEN;\n\n    // OK now we are all set to write the file\n\n\n    fwrite(&file_hdr, FILHSZ, 1, f);\n    fwrite(&o_filehdr, sizeof(o_filehdr), 1, f);\n\n    // write section headers\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (OutputTheSection(tcc_sect)) {\n\t    fwrite(coff_sec, sizeof(SCNHDR), 1, f);\n\t}\n    }\n\n    // write raw data\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (OutputTheSection(tcc_sect)) {\n\t    fwrite(tcc_sect->data, tcc_sect->data_offset, 1, f);\n\t}\n    }\n\n    // write relocation data\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (OutputTheSection(tcc_sect)) {\n\t    // put relocations data\n\t    if (coff_sec->s_nreloc > 0) {\n\t\tfwrite(tcc_sect->reloc,\n\t\t       coff_sec->s_nreloc * sizeof(struct reloc), 1, f);\n\t    }\n\t}\n    }\n\n\n    // group the symbols in order of filename, func1, func2, etc\n    // finally global symbols\n\n    if (s1->do_debug)\n\tSortSymbolTable(s1);\n\n    // write line no data\n\n    for (i = 1; i < s1->nb_sections; i++) {\n\tcoff_sec = &section_header[i];\n\ttcc_sect = s1->sections[i];\n\n\tif (s1->do_debug && tcc_sect == stext) {\n\t    // count how many line nos data\n\n\n\t    Stab_Sym *sym, *sym_end;\n\t    char func_name[128], last_func_name[128];\n\t    unsigned long func_addr, last_pc, pc;\n\t    const char *incl_files[INCLUDE_STACK_SIZE];\n\t    int incl_index, len, last_line_num;\n\t    const char *str, *p;\n\n\t    LINENO CoffLineNo;\n\n\t    func_name[0] = '\\0';\n\t    func_addr = 0;\n\t    incl_index = 0;\n\t    last_func_name[0] = '\\0';\n\t    last_pc = 0;\n\t    last_line_num = 1;\n\t    sym = (Stab_Sym *) stab_section->data + 1;\n\t    sym_end =\n\t\t(Stab_Sym *) (stab_section->data +\n\t\t\t      stab_section->data_offset);\n\n\t    while (sym < sym_end) {\n\t\tswitch (sym->n_type) {\n\t\t    /* function start or end */\n\t\tcase N_FUN:\n\t\t    if (sym->n_strx == 0) {\n\t\t\t// end of function\n\n\t\t\tCoffLineNo.l_addr.l_paddr = last_pc;\n\t\t\tCoffLineNo.l_lnno = last_line_num + 1;\n\t\t\tfwrite(&CoffLineNo, 6, 1, f);\n\n\t\t\tpc = sym->n_value + func_addr;\n\t\t\tfunc_name[0] = '\\0';\n\t\t\tfunc_addr = 0;\n\t\t    } else {\n\t\t\t// beginning of function\n\n\t\t\tstr =\n\t\t\t    (const char *) stabstr_section->data +\n\t\t\t    sym->n_strx;\n\n\n\t\t\tp = strchr(str, ':');\n\t\t\tif (!p) {\n\t\t\t    pstrcpy(func_name, sizeof(func_name), str);\n\t\t\t} else {\n\t\t\t    len = p - str;\n\t\t\t    if (len > sizeof(func_name) - 1)\n\t\t\t\tlen = sizeof(func_name) - 1;\n\t\t\t    memcpy(func_name, str, len);\n\t\t\t    func_name[len] = '\\0';\n\t\t\t}\n\t\t\tfunc_addr = sym->n_value;\n\t\t\tlast_pc = func_addr;\n\t\t\tlast_line_num = -1;\n\n\t\t\t// output a function begin\n\n\t\t\tCoffLineNo.l_addr.l_symndx =\n\t\t\t    FindCoffSymbolIndex(s1, func_name);\n\t\t\tCoffLineNo.l_lnno = 0;\n\n\t\t\tfwrite(&CoffLineNo, 6, 1, f);\n\t\t    }\n\t\t    break;\n\n\t\t    /* line number info */\n\t\tcase N_SLINE:\n\t\t    pc = sym->n_value + func_addr;\n\n\n\t\t    /* XXX: slow! */\n\t\t    strcpy(last_func_name, func_name);\n\n\t\t    // output a line reference\n\n\t\t    CoffLineNo.l_addr.l_paddr = last_pc;\n\n\t\t    if (last_line_num == -1) {\n\t\t\tCoffLineNo.l_lnno = sym->n_desc;\n\t\t    } else {\n\t\t\tCoffLineNo.l_lnno = last_line_num + 1;\n\t\t    }\n\n\t\t    fwrite(&CoffLineNo, 6, 1, f);\n\n\t\t    last_pc = pc;\n\t\t    last_line_num = sym->n_desc;\n\n\t\t    break;\n\n\t\t    /* include files */\n\t\tcase N_BINCL:\n\t\t    str =\n\t\t\t(const char *) stabstr_section->data + sym->n_strx;\n\t\t  add_incl2:\n\t\t    if (incl_index < INCLUDE_STACK_SIZE) {\n\t\t\tincl_files[incl_index++] = str;\n\t\t    }\n\t\t    break;\n\t\tcase N_EINCL:\n\t\t    if (incl_index > 1)\n\t\t\tincl_index--;\n\t\t    break;\n\t\tcase N_SO:\n\t\t    if (sym->n_strx == 0) {\n\t\t\tincl_index = 0;\t/* end of translation unit */\n\t\t    } else {\n\t\t\tstr =\n\t\t\t    (const char *) stabstr_section->data +\n\t\t\t    sym->n_strx;\n\t\t\t/* do not add path */\n\t\t\tlen = strlen(str);\n\t\t\tif (len > 0 && str[len - 1] != '/')\n\t\t\t    goto add_incl2;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tsym++;\n\t    }\n\t}\n    }\n\n    // write symbol table\n    if (s1->do_debug) {\n\tint k;\n\tstruct syment csym;\n\tAUXFUNC auxfunc;\n\tAUXBF auxbf;\n\tAUXEF auxef;\n\tint i;\n\tElf32_Sym *p;\n\tconst char *name;\n\tint nstr;\n\tint n = 0;\n\n\tCoff_str_table = (char *) tcc_malloc(MAX_STR_TABLE);\n\tpCoff_str_table = Coff_str_table;\n\tnstr = 0;\n\n\tp = (Elf32_Sym *) symtab_section->data;\n\n\n\tfor (i = 0; i < nb_syms; i++) {\n\n\t    name = symtab_section->link->data + p->st_name;\n\n\t    for (k = 0; k < 8; k++)\n\t\tcsym._n._n_name[k] = 0;\n\n\t    if (strlen(name) <= 8) {\n\t\tstrcpy(csym._n._n_name, name);\n\t    } else {\n\t\tif (pCoff_str_table - Coff_str_table + strlen(name) >\n\t\t    MAX_STR_TABLE - 1)\n\t\t    tcc_error(\"String table too large\");\n\n\t\tcsym._n._n_n._n_zeroes = 0;\n\t\tcsym._n._n_n._n_offset =\n\t\t    pCoff_str_table - Coff_str_table + 4;\n\n\t\tstrcpy(pCoff_str_table, name);\n\t\tpCoff_str_table += strlen(name) + 1;\t// skip over null\n\t\tnstr++;\n\t    }\n\n\t    if (p->st_info == 4) {\n\t\t// put a filename symbol\n\t\tcsym.n_value = 33;\t// ?????\n\t\tcsym.n_scnum = N_DEBUG;\n\t\tcsym.n_type = 0;\n\t\tcsym.n_sclass = C_FILE;\n\t\tcsym.n_numaux = 0;\n\t\tfwrite(&csym, 18, 1, f);\n\t\tn++;\n\n\t    } else if (p->st_info == 0x12) {\n\t\t// find the function data\n\n\t\tfor (k = 0; k < nFuncs; k++) {\n\t\t    if (strcmp(name, Func[k]) == 0)\n\t\t\tbreak;\n\t\t}\n\n\t\tif (k >= nFuncs) {\n\t\t    tcc_error(\"debug info can't find function: %s\", name);\n\t\t}\n\t\t// put a Function Name\n\n\t\tcsym.n_value = p->st_value;\t// physical address\n\t\tcsym.n_scnum = CoffTextSectionNo;\n\t\tcsym.n_type = MKTYPE(T_INT, DT_FCN, 0, 0, 0, 0, 0);\n\t\tcsym.n_sclass = C_EXT;\n\t\tcsym.n_numaux = 1;\n\t\tfwrite(&csym, 18, 1, f);\n\n\t\t// now put aux info\n\n\t\tauxfunc.tag = 0;\n\t\tauxfunc.size = EndAddress[k] - p->st_value;\n\t\tauxfunc.fileptr = LineNoFilePtr[k];\n\t\tauxfunc.nextsym = n + 6;\t// tktk\n\t\tauxfunc.dummy = 0;\n\t\tfwrite(&auxfunc, 18, 1, f);\n\n\t\t// put a .bf\n\n\t\tstrcpy(csym._n._n_name, \".bf\");\n\t\tcsym.n_value = p->st_value;\t// physical address\n\t\tcsym.n_scnum = CoffTextSectionNo;\n\t\tcsym.n_type = 0;\n\t\tcsym.n_sclass = C_FCN;\n\t\tcsym.n_numaux = 1;\n\t\tfwrite(&csym, 18, 1, f);\n\n\t\t// now put aux info\n\n\t\tauxbf.regmask = 0;\n\t\tauxbf.lineno = 0;\n\t\tauxbf.nentries = FuncEntries[k];\n\t\tauxbf.localframe = 0;\n\t\tauxbf.nextentry = n + 6;\n\t\tauxbf.dummy = 0;\n\t\tfwrite(&auxbf, 18, 1, f);\n\n\t\t// put a .ef\n\n\t\tstrcpy(csym._n._n_name, \".ef\");\n\t\tcsym.n_value = EndAddress[k];\t// physical address  \n\t\tcsym.n_scnum = CoffTextSectionNo;\n\t\tcsym.n_type = 0;\n\t\tcsym.n_sclass = C_FCN;\n\t\tcsym.n_numaux = 1;\n\t\tfwrite(&csym, 18, 1, f);\n\n\t\t// now put aux info\n\n\t\tauxef.dummy = 0;\n\t\tauxef.lineno = LastLineNo[k];\n\t\tauxef.dummy1 = 0;\n\t\tauxef.dummy2 = 0;\n\t\tauxef.dummy3 = 0;\n\t\tauxef.dummy4 = 0;\n\t\tfwrite(&auxef, 18, 1, f);\n\n\t\tn += 6;\n\n\t    } else {\n\t\t// try an put some type info\n\n\t\tif ((p->st_other & VT_BTYPE) == VT_DOUBLE) {\n\t\t    csym.n_type = T_DOUBLE;\t// int\n\t\t    csym.n_sclass = C_EXT;\n\t\t} else if ((p->st_other & VT_BTYPE) == VT_FLOAT) {\n\t\t    csym.n_type = T_FLOAT;\n\t\t    csym.n_sclass = C_EXT;\n\t\t} else if ((p->st_other & VT_BTYPE) == VT_INT) {\n\t\t    csym.n_type = T_INT;\t// int\n\t\t    csym.n_sclass = C_EXT;\n\t\t} else if ((p->st_other & VT_BTYPE) == VT_SHORT) {\n\t\t    csym.n_type = T_SHORT;\n\t\t    csym.n_sclass = C_EXT;\n\t\t} else if ((p->st_other & VT_BTYPE) == VT_BYTE) {\n\t\t    csym.n_type = T_CHAR;\n\t\t    csym.n_sclass = C_EXT;\n\t\t} else {\n\t\t    csym.n_type = T_INT;\t// just mark as a label\n\t\t    csym.n_sclass = C_LABEL;\n\t\t}\n\n\n\t\tcsym.n_value = p->st_value;\n\t\tcsym.n_scnum = 2;\n\t\tcsym.n_numaux = 1;\n\t\tfwrite(&csym, 18, 1, f);\n\n\t\tauxfunc.tag = 0;\n\t\tauxfunc.size = 0x20;\n\t\tauxfunc.fileptr = 0;\n\t\tauxfunc.nextsym = 0;\n\t\tauxfunc.dummy = 0;\n\t\tfwrite(&auxfunc, 18, 1, f);\n\t\tn++;\n\t\tn++;\n\n\t    }\n\n\t    p++;\n\t}\n    }\n\n    if (s1->do_debug) {\n\t// write string table\n\n\t// first write the size\n\ti = pCoff_str_table - Coff_str_table;\n\tfwrite(&i, 4, 1, f);\n\n\t// then write the strings\n\tfwrite(Coff_str_table, i, 1, f);\n\n\ttcc_free(Coff_str_table);\n    }\n\n    return 0;\n}\n\n\n\n// group the symbols in order of filename, func1, func2, etc\n// finally global symbols\n\nvoid SortSymbolTable(TCCState *s1)\n{\n    int i, j, k, n = 0;\n    Elf32_Sym *p, *p2, *NewTable;\n    char *name, *name2;\n\n    NewTable = (Elf32_Sym *) tcc_malloc(nb_syms * sizeof(Elf32_Sym));\n\n    p = (Elf32_Sym *) symtab_section->data;\n\n\n    // find a file symbol, copy it over\n    // then scan the whole symbol list and copy any function\n    // symbols that match the file association\n\n    for (i = 0; i < nb_syms; i++) {\n\tif (p->st_info == 4) {\n\t    name = (char *) symtab_section->link->data + p->st_name;\n\n\t    // this is a file symbol, copy it over\n\n\t    NewTable[n++] = *p;\n\n\t    p2 = (Elf32_Sym *) symtab_section->data;\n\n\t    for (j = 0; j < nb_syms; j++) {\n\t\tif (p2->st_info == 0x12) {\n\t\t    // this is a func symbol\n\n\t\t    name2 =\n\t\t\t(char *) symtab_section->link->data + p2->st_name;\n\n\t\t    // find the function data index\n\n\t\t    for (k = 0; k < nFuncs; k++) {\n\t\t\tif (strcmp(name2, Func[k]) == 0)\n\t\t\t    break;\n\t\t    }\n\n\t\t    if (k >= nFuncs) {\n                        tcc_error(\"debug (sort) info can't find function: %s\", name2);\n\t\t    }\n\n\t\t    if (strcmp(AssociatedFile[k], name) == 0) {\n\t\t\t// yes they match copy it over\n\n\t\t\tNewTable[n++] = *p2;\n\t\t    }\n\t\t}\n\t\tp2++;\n\t    }\n\t}\n\tp++;\n    }\n\n    // now all the filename and func symbols should have been copied over\n    // copy all the rest over (all except file and funcs)\n\n    p = (Elf32_Sym *) symtab_section->data;\n    for (i = 0; i < nb_syms; i++) {\n\tif (p->st_info != 4 && p->st_info != 0x12) {\n\t    NewTable[n++] = *p;\n\t}\n\tp++;\n    }\n\n    if (n != nb_syms)\n\ttcc_error(\"Internal Compiler error, debug info\");\n\n    // copy it all back\n\n    p = (Elf32_Sym *) symtab_section->data;\n    for (i = 0; i < nb_syms; i++) {\n\t*p++ = NewTable[i];\n    }\n\n    tcc_free(NewTable);\n}\n\n\nint FindCoffSymbolIndex(TCCState *s1, const char *func_name)\n{\n    int i, n = 0;\n    Elf32_Sym *p;\n    char *name;\n\n    p = (Elf32_Sym *) symtab_section->data;\n\n    for (i = 0; i < nb_syms; i++) {\n\n\tname = (char *) symtab_section->link->data + p->st_name;\n\n\tif (p->st_info == 4) {\n\t    // put a filename symbol\n\t    n++;\n\t} else if (p->st_info == 0x12) {\n\n\t    if (strcmp(func_name, name) == 0)\n\t\treturn n;\n\n\t    n += 6;\n\n\t    // put a Function Name\n\n\t    // now put aux info\n\n\t    // put a .bf\n\n\t    // now put aux info\n\n\t    // put a .ef\n\n\t    // now put aux info\n\n\t} else {\n\t    n += 2;\n\t}\n\n\tp++;\n    }\n\n    return n;\t\t\t// total number of symbols\n}\n\nint OutputTheSection(Section * sect)\n{\n    const char *s = sect->name;\n\n    if (!strcmp(s, \".text\"))\n\treturn 1;\n    else if (!strcmp(s, \".data\"))\n\treturn 1;\n    else\n\treturn 0;\n}\n\nshort int GetCoffFlags(const char *s)\n{\n    if (!strcmp(s, \".text\"))\n\treturn STYP_TEXT | STYP_DATA | STYP_ALIGN | 0x400;\n    else if (!strcmp(s, \".data\"))\n\treturn STYP_DATA;\n    else if (!strcmp(s, \".bss\"))\n\treturn STYP_BSS;\n    else if (!strcmp(s, \".stack\"))\n\treturn STYP_BSS | STYP_ALIGN | 0x200;\n    else if (!strcmp(s, \".cinit\"))\n\treturn STYP_COPY | STYP_DATA | STYP_ALIGN | 0x200;\n    else\n\treturn 0;\n}\n\nSection *FindSection(TCCState * s1, const char *sname)\n{\n    Section *s;\n    int i;\n\n    for (i = 1; i < s1->nb_sections; i++) {\n\ts = s1->sections[i];\n\n\tif (!strcmp(sname, s->name))\n\t    return s;\n    }\n\n    tcc_error(\"could not find section %s\", sname);\n    return 0;\n}\n\nST_FUNC int tcc_load_coff(TCCState * s1, int fd)\n{\n// tktk TokenSym *ts;\n\n    FILE *f;\n    unsigned int str_size;\n    char *Coff_str_table, *name;\n    int i, k;\n    struct syment csym;\n    char name2[9];\n    FILHDR file_hdr;\t\t/* FILE HEADER STRUCTURE              */\n\n    f = fdopen(fd, \"rb\");\n    if (!f) {\n\ttcc_error(\"Unable to open .out file for input\");\n    }\n\n    if (fread(&file_hdr, FILHSZ, 1, f) != 1)\n\ttcc_error(\"error reading .out file for input\");\n\n    if (fread(&o_filehdr, sizeof(o_filehdr), 1, f) != 1)\n\ttcc_error(\"error reading .out file for input\");\n\n    // first read the string table\n\n    if (fseek(f, file_hdr.f_symptr + file_hdr.f_nsyms * SYMESZ, SEEK_SET))\n\ttcc_error(\"error reading .out file for input\");\n\n    if (fread(&str_size, sizeof(int), 1, f) != 1)\n\ttcc_error(\"error reading .out file for input\");\n\n\n    Coff_str_table = (char *) tcc_malloc(str_size);\n\n    if (fread(Coff_str_table, str_size - 4, 1, f) != 1)\n\ttcc_error(\"error reading .out file for input\");\n\n    // read/process all the symbols\n\n    // seek back to symbols\n\n    if (fseek(f, file_hdr.f_symptr, SEEK_SET))\n\ttcc_error(\"error reading .out file for input\");\n\n    for (i = 0; i < file_hdr.f_nsyms; i++) {\n\tif (fread(&csym, SYMESZ, 1, f) != 1)\n\t    tcc_error(\"error reading .out file for input\");\n\n\tif (csym._n._n_n._n_zeroes == 0) {\n\t    name = Coff_str_table + csym._n._n_n._n_offset - 4;\n\t} else {\n\t    name = csym._n._n_name;\n\n\t    if (name[7] != 0) {\n\t\tfor (k = 0; k < 8; k++)\n\t\t    name2[k] = name[k];\n\n\t\tname2[8] = 0;\n\n\t\tname = name2;\n\t    }\n\t}\n//              if (strcmp(\"_DAC_Buffer\",name)==0)  // tktk\n//                      name[0]=0;\n\n\tif (((csym.n_type & 0x30) == 0x20 && csym.n_sclass == 0x2) || ((csym.n_type & 0x30) == 0x30 && csym.n_sclass == 0x2) || (csym.n_type == 0x4 && csym.n_sclass == 0x2) || (csym.n_type == 0x8 && csym.n_sclass == 0x2) ||\t// structures\n\t    (csym.n_type == 0x18 && csym.n_sclass == 0x2) ||\t// pointer to structure\n\t    (csym.n_type == 0x7 && csym.n_sclass == 0x2) ||\t// doubles\n\t    (csym.n_type == 0x6 && csym.n_sclass == 0x2))\t// floats\n\t{\n\t    // strip off any leading underscore (except for other main routine)\n\n\t    if (name[0] == '_' && strcmp(name, \"_main\") != 0)\n\t\tname++;\n\n\t    tcc_add_symbol(s1, name, (void*)(uintptr_t)csym.n_value);\n\t}\n\t// skip any aux records\n\n\tif (csym.n_numaux == 1) {\n\t    if (fread(&csym, SYMESZ, 1, f) != 1)\n\t\ttcc_error(\"error reading .out file for input\");\n\t    i++;\n\t}\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "tccdbg.c",
          "type": "blob",
          "size": 83.2734375,
          "content": "/*\n *  TCC - Tiny C Compiler\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"tcc.h\"\n\n/* stab debug support */\n\nstatic const struct {\n  int type;\n  int size;\n  int encoding;\n  const char *name;\n} default_debug[] = {\n    {   VT_INT, 4, DW_ATE_signed, \"int:t1=r1;-2147483648;2147483647;\" },\n    {   VT_BYTE, 1, DW_ATE_signed_char, \"char:t2=r2;0;127;\" },\n#if LONG_SIZE == 4\n    {   VT_LONG | VT_INT, 4, DW_ATE_signed, \"long int:t3=r3;-2147483648;2147483647;\" },\n#else\n    {   VT_LLONG | VT_LONG, 8, DW_ATE_signed, \"long int:t3=r3;-9223372036854775808;9223372036854775807;\" },\n#endif\n    {   VT_INT | VT_UNSIGNED, 4, DW_ATE_unsigned, \"unsigned int:t4=r4;0;037777777777;\" },\n#if LONG_SIZE == 4\n    {   VT_LONG | VT_INT | VT_UNSIGNED, 4, DW_ATE_unsigned, \"long unsigned int:t5=r5;0;037777777777;\" },\n#else\n    /* use octal instead of -1 so size_t works (-gstabs+ in gcc) */\n    {   VT_LLONG | VT_LONG | VT_UNSIGNED, 8, DW_ATE_unsigned, \"long unsigned int:t5=r5;0;01777777777777777777777;\" },\n#endif\n    {   VT_QLONG, 16, DW_ATE_signed, \"__int128:t6=r6;0;-1;\" },\n    {   VT_QLONG | VT_UNSIGNED, 16, DW_ATE_unsigned, \"__int128 unsigned:t7=r7;0;-1;\" },\n    {   VT_LLONG, 8, DW_ATE_signed, \"long long int:t8=r8;-9223372036854775808;9223372036854775807;\" },\n    {   VT_LLONG | VT_UNSIGNED, 8, DW_ATE_unsigned, \"long long unsigned int:t9=r9;0;01777777777777777777777;\" },\n    {   VT_SHORT, 2, DW_ATE_signed, \"short int:t10=r10;-32768;32767;\" },\n    {   VT_SHORT | VT_UNSIGNED, 2, DW_ATE_unsigned, \"short unsigned int:t11=r11;0;65535;\" },\n    {   VT_BYTE | VT_DEFSIGN, 1, DW_ATE_signed_char, \"signed char:t12=r12;-128;127;\" },\n    {   VT_BYTE | VT_DEFSIGN | VT_UNSIGNED, 1, DW_ATE_unsigned_char, \"unsigned char:t13=r13;0;255;\" },\n    {   VT_FLOAT, 4, DW_ATE_float, \"float:t14=r1;4;0;\" },\n    {   VT_DOUBLE, 8, DW_ATE_float, \"double:t15=r1;8;0;\" },\n#ifdef TCC_USING_DOUBLE_FOR_LDOUBLE\n    {   VT_DOUBLE | VT_LONG, 8, DW_ATE_float, \"long double:t16=r1;8;0;\" },\n#else\n    {   VT_LDOUBLE, 16, DW_ATE_float, \"long double:t16=r1;16;0;\" },\n#endif\n    {   -1, -1, -1, \"_Float32:t17=r1;4;0;\" },\n    {   -1, -1, -1, \"_Float64:t18=r1;8;0;\" },\n    {   -1, -1, -1, \"_Float128:t19=r1;16;0;\" },\n    {   -1, -1, -1, \"_Float32x:t20=r1;8;0;\" },\n    {   -1, -1, -1, \"_Float64x:t21=r1;16;0;\" },\n    {   -1, -1, -1, \"_Decimal32:t22=r1;4;0;\" },\n    {   -1, -1, -1, \"_Decimal64:t23=r1;8;0;\" },\n    {   -1, -1, -1, \"_Decimal128:t24=r1;16;0;\" },\n    /* if default char is unsigned */\n    {   VT_BYTE | VT_UNSIGNED, 1, DW_ATE_unsigned_char, \"unsigned char:t25=r25;0;255;\" },\n    /* boolean type */\n    {   VT_BOOL, 1, DW_ATE_boolean, \"bool:t26=r26;0;255;\" },\n#if LONG_SIZE == 4\n    {   VT_VOID, 1, DW_ATE_unsigned_char, \"void:t27=27\" },\n#else\n    /* bitfields use these */\n    {   VT_LONG | VT_INT, 8, DW_ATE_signed, \"long int:t27=r27;-9223372036854775808;9223372036854775807;\" },\n    {   VT_LONG | VT_INT | VT_UNSIGNED, 8, DW_ATE_unsigned, \"long unsigned int:t28=r28;0;01777777777777777777777;\" },\n    {   VT_VOID, 1, DW_ATE_unsigned_char, \"void:t29=29\" },\n#endif\n};\n\n#define\tN_DEFAULT_DEBUG\t(sizeof (default_debug) / sizeof (default_debug[0]))\n\n/* dwarf debug */\n\n#define\tDWARF_LINE_BASE\t\t\t\t-5\n#define\tDWARF_LINE_RANGE\t\t\t14\n#define\tDWARF_OPCODE_BASE\t\t\t13\n\n#if defined TCC_TARGET_ARM64\n#define\tDWARF_MIN_INSTR_LEN\t\t\t4\n#elif defined TCC_TARGET_ARM\n#define\tDWARF_MIN_INSTR_LEN\t\t\t2\n#else\n#define\tDWARF_MIN_INSTR_LEN\t\t\t1\n#endif\n\n#define\tDWARF_ABBREV_COMPILE_UNIT\t\t1\n#define\tDWARF_ABBREV_BASE_TYPE\t\t\t2\n#define\tDWARF_ABBREV_VARIABLE_EXTERNAL\t\t3\n#define\tDWARF_ABBREV_VARIABLE_STATIC\t\t4\n#define\tDWARF_ABBREV_VARIABLE_LOCAL\t\t5\n#define\tDWARF_ABBREV_FORMAL_PARAMETER\t\t6\n#define\tDWARF_ABBREV_POINTER\t\t\t7\n#define\tDWARF_ABBREV_ARRAY_TYPE\t\t\t8\n#define\tDWARF_ABBREV_SUBRANGE_TYPE\t\t9\n#define\tDWARF_ABBREV_TYPEDEF\t\t\t10\n#define\tDWARF_ABBREV_ENUMERATOR_SIGNED\t\t11\n#define\tDWARF_ABBREV_ENUMERATOR_UNSIGNED\t12\n#define\tDWARF_ABBREV_ENUMERATION_TYPE\t\t13\n#define\tDWARF_ABBREV_MEMBER\t\t\t14\n#define\tDWARF_ABBREV_MEMBER_BF\t\t\t15\n#define\tDWARF_ABBREV_STRUCTURE_TYPE\t\t16\n#define\tDWARF_ABBREV_STRUCTURE_EMPTY_TYPE\t17\n#define\tDWARF_ABBREV_UNION_TYPE\t\t\t18\n#define\tDWARF_ABBREV_UNION_EMPTY_TYPE\t\t19\n#define\tDWARF_ABBREV_SUBPROGRAM_EXTERNAL\t20\n#define\tDWARF_ABBREV_SUBPROGRAM_STATIC\t\t21\n#define\tDWARF_ABBREV_LEXICAL_BLOCK\t\t22\n#define\tDWARF_ABBREV_LEXICAL_EMPTY_BLOCK\t23\n#define\tDWARF_ABBREV_SUBROUTINE_TYPE\t\t24\n#define\tDWARF_ABBREV_SUBROUTINE_EMPTY_TYPE\t25\n#define\tDWARF_ABBREV_FORMAL_PARAMETER2\t\t26\n\n/* all entries should have been generated with dwarf_uleb128 except\n   has_children. All values are currently below 128 so this currently\n   works.  */\nstatic const unsigned char dwarf_abbrev_init[] = {\n    DWARF_ABBREV_COMPILE_UNIT, DW_TAG_compile_unit, 1,\n          DW_AT_producer, DW_FORM_strp,\n          DW_AT_language, DW_FORM_data1,\n          DW_AT_name, DW_FORM_line_strp,\n          DW_AT_comp_dir, DW_FORM_line_strp,\n          DW_AT_low_pc, DW_FORM_addr,\n#if PTR_SIZE == 4\n          DW_AT_high_pc, DW_FORM_data4,\n#else\n          DW_AT_high_pc, DW_FORM_data8,\n#endif\n          DW_AT_stmt_list, DW_FORM_sec_offset,\n          0, 0,\n    DWARF_ABBREV_BASE_TYPE, DW_TAG_base_type, 0,\n          DW_AT_byte_size, DW_FORM_udata,\n          DW_AT_encoding, DW_FORM_data1,\n          DW_AT_name, DW_FORM_strp,\n          0, 0,\n    DWARF_ABBREV_VARIABLE_EXTERNAL, DW_TAG_variable, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_external, DW_FORM_flag,\n          DW_AT_location, DW_FORM_exprloc,\n          0, 0,\n    DWARF_ABBREV_VARIABLE_STATIC, DW_TAG_variable, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_location, DW_FORM_exprloc,\n          0, 0,\n    DWARF_ABBREV_VARIABLE_LOCAL, DW_TAG_variable, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_location, DW_FORM_exprloc,\n          0, 0,\n    DWARF_ABBREV_FORMAL_PARAMETER, DW_TAG_formal_parameter, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_location, DW_FORM_exprloc,\n          0, 0,\n    DWARF_ABBREV_POINTER, DW_TAG_pointer_type, 0,\n          DW_AT_byte_size, DW_FORM_data1,\n          DW_AT_type, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_ARRAY_TYPE, DW_TAG_array_type, 1,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_sibling, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_SUBRANGE_TYPE, DW_TAG_subrange_type, 0,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_upper_bound, DW_FORM_udata,\n          0, 0,\n    DWARF_ABBREV_TYPEDEF, DW_TAG_typedef, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_ENUMERATOR_SIGNED, DW_TAG_enumerator, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_const_value, DW_FORM_sdata,\n          0, 0,\n    DWARF_ABBREV_ENUMERATOR_UNSIGNED, DW_TAG_enumerator, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_const_value, DW_FORM_udata,\n          0, 0,\n    DWARF_ABBREV_ENUMERATION_TYPE, DW_TAG_enumeration_type, 1,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_encoding, DW_FORM_data1,\n          DW_AT_byte_size, DW_FORM_data1,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_sibling, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_MEMBER, DW_TAG_member, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_data_member_location, DW_FORM_udata,\n          0, 0,\n    DWARF_ABBREV_MEMBER_BF, DW_TAG_member, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_bit_size, DW_FORM_udata,\n          DW_AT_data_bit_offset, DW_FORM_udata,\n          0, 0,\n    DWARF_ABBREV_STRUCTURE_TYPE, DW_TAG_structure_type, 1,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_byte_size, DW_FORM_udata,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_sibling, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_STRUCTURE_EMPTY_TYPE, DW_TAG_structure_type, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_byte_size, DW_FORM_udata,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          0, 0,\n    DWARF_ABBREV_UNION_TYPE, DW_TAG_union_type, 1,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_byte_size, DW_FORM_udata,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_sibling, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_UNION_EMPTY_TYPE, DW_TAG_union_type, 0,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_byte_size, DW_FORM_udata,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          0, 0,\n    DWARF_ABBREV_SUBPROGRAM_EXTERNAL, DW_TAG_subprogram, 1,\n          DW_AT_external, DW_FORM_flag,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_low_pc, DW_FORM_addr,\n#if PTR_SIZE == 4\n          DW_AT_high_pc, DW_FORM_data4,\n#else\n          DW_AT_high_pc, DW_FORM_data8,\n#endif\n          DW_AT_sibling, DW_FORM_ref4,\n\t  DW_AT_frame_base, DW_FORM_exprloc,\n          0, 0,\n    DWARF_ABBREV_SUBPROGRAM_STATIC, DW_TAG_subprogram, 1,\n          DW_AT_name, DW_FORM_strp,\n          DW_AT_decl_file, DW_FORM_udata,\n          DW_AT_decl_line, DW_FORM_udata,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_low_pc, DW_FORM_addr,\n#if PTR_SIZE == 4\n          DW_AT_high_pc, DW_FORM_data4,\n#else\n          DW_AT_high_pc, DW_FORM_data8,\n#endif\n          DW_AT_sibling, DW_FORM_ref4,\n\t  DW_AT_frame_base, DW_FORM_exprloc,\n          0, 0,\n    DWARF_ABBREV_LEXICAL_BLOCK, DW_TAG_lexical_block, 1,\n          DW_AT_low_pc, DW_FORM_addr,\n#if PTR_SIZE == 4\n          DW_AT_high_pc, DW_FORM_data4,\n#else\n          DW_AT_high_pc, DW_FORM_data8,\n#endif\n          0, 0,\n    DWARF_ABBREV_LEXICAL_EMPTY_BLOCK, DW_TAG_lexical_block, 0,\n          DW_AT_low_pc, DW_FORM_addr,\n#if PTR_SIZE == 4\n          DW_AT_high_pc, DW_FORM_data4,\n#else\n          DW_AT_high_pc, DW_FORM_data8,\n#endif\n          0, 0,\n    DWARF_ABBREV_SUBROUTINE_TYPE, DW_TAG_subroutine_type, 1,\n          DW_AT_type, DW_FORM_ref4,\n          DW_AT_sibling, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_SUBROUTINE_EMPTY_TYPE, DW_TAG_subroutine_type, 0,\n          DW_AT_type, DW_FORM_ref4,\n          0, 0,\n    DWARF_ABBREV_FORMAL_PARAMETER2, DW_TAG_formal_parameter, 0,\n          DW_AT_type, DW_FORM_ref4,\n          0, 0,\n  0\n};\n\nstatic const unsigned char dwarf_line_opcodes[] = {\n    0 ,1 ,1 ,1 ,1 ,0 ,0 ,0 ,1 ,0 ,0 ,1\n};\n\n/* ------------------------------------------------------------------------- */\n/* debug state */\n\nstruct _tccdbg {\n\n    int last_line_num, new_file;\n    int section_sym;\n\n    int debug_next_type;\n\n    struct _debug_hash {\n        int debug_type;\n        Sym *type;\n    } *debug_hash;\n\n    struct _debug_anon_hash {\n        Sym *type;\n        int n_debug_type;\n        int *debug_type;\n    } *debug_anon_hash;\n\n    int n_debug_hash;\n    int n_debug_anon_hash;\n\n    struct _debug_info {\n        int start;\n        int end;\n        int n_sym;\n        struct debug_sym {\n            int type;\n            unsigned long value;\n            char *str;\n            Section *sec;\n            int sym_index;\n            int info;\n            int file;\n            int line;\n        } *sym;\n        struct _debug_info *child, *next, *last, *parent;\n    } *debug_info, *debug_info_root;\n\n    struct {\n        int info;\n        int abbrev;\n        int line;\n        int str;\n        int line_str;\n    } dwarf_sym;\n\n    struct {\n        int start;\n        int dir_size;\n        char **dir_table;\n        int filename_size;\n        struct dwarf_filename_struct {\n            int dir_entry;\n            char *name;\n        } *filename_table;\n        int line_size;\n        int line_max_size;\n        unsigned char *line_data;\n        int cur_file;\n        int last_file;\n        int last_pc;\n        int last_line;\n    } dwarf_line;\n\n    struct {\n        int start;\n        Sym *func;\n        int line;\n        int base_type_used[N_DEFAULT_DEBUG];\n    } dwarf_info;\n\n    /* test coverage */\n    struct {\n        unsigned long offset;\n        unsigned long last_file_name;\n        unsigned long last_func_name;\n        int ind;\n        int line;\n    } tcov_data;\n\n};\n\n#define last_line_num       s1->dState->last_line_num\n#define new_file            s1->dState->new_file\n#define section_sym         s1->dState->section_sym\n#define debug_next_type     s1->dState->debug_next_type\n#define debug_hash          s1->dState->debug_hash\n#define debug_anon_hash     s1->dState->debug_anon_hash\n#define n_debug_hash        s1->dState->n_debug_hash\n#define n_debug_anon_hash   s1->dState->n_debug_anon_hash\n#define debug_info          s1->dState->debug_info\n#define debug_info_root     s1->dState->debug_info_root\n#define dwarf_sym           s1->dState->dwarf_sym\n#define dwarf_line          s1->dState->dwarf_line\n#define dwarf_info          s1->dState->dwarf_info\n#define tcov_data           s1->dState->tcov_data\n\n#define\tFDE_ENCODING        (DW_EH_PE_udata4 | DW_EH_PE_signed | DW_EH_PE_pcrel)\n\n/* ------------------------------------------------------------------------- */\nstatic void put_stabs(TCCState *s1, const char *str, int type, int other,\n    int desc, unsigned long value);\n\nST_FUNC void tcc_debug_new(TCCState *s1)\n{\n    int shf = 0;\n    if (!s1->dState)\n        s1->dState = tcc_mallocz(sizeof *s1->dState);\n\n#ifdef CONFIG_TCC_BACKTRACE\n    /* include stab info with standalone backtrace support */\n    if (s1->do_debug && s1->output_type == TCC_OUTPUT_MEMORY)\n        s1->do_backtrace = 1;\n    if (s1->do_backtrace)\n        shf = SHF_ALLOC; /* have debug data available at runtime */\n#endif\n\n    if (s1->dwarf) {\n        s1->dwlo = s1->nb_sections;\n        dwarf_info_section =\n\t    new_section(s1, \".debug_info\", SHT_PROGBITS, shf);\n        dwarf_abbrev_section =\n\t    new_section(s1, \".debug_abbrev\", SHT_PROGBITS, shf);\n        dwarf_line_section =\n\t    new_section(s1, \".debug_line\", SHT_PROGBITS, shf);\n        dwarf_aranges_section =\n\t    new_section(s1, \".debug_aranges\", SHT_PROGBITS, shf);\n\tshf |= SHF_MERGE | SHF_STRINGS;\n        dwarf_str_section =\n\t    new_section(s1, \".debug_str\", SHT_PROGBITS, shf);\n\tdwarf_str_section->sh_entsize = 1;\n\tdwarf_info_section->sh_addralign =\n\tdwarf_abbrev_section->sh_addralign =\n\tdwarf_line_section->sh_addralign =\n\tdwarf_aranges_section->sh_addralign =\n\tdwarf_str_section->sh_addralign = 1;\n\tif (s1->dwarf >= 5) {\n            dwarf_line_str_section =\n\t        new_section(s1, \".debug_line_str\", SHT_PROGBITS, shf);\n\t    dwarf_line_str_section->sh_entsize = 1;\n\t    dwarf_line_str_section->sh_addralign = 1;\n\t}\n        s1->dwhi = s1->nb_sections;\n    }\n    else\n    {\n        stab_section = new_section(s1, \".stab\", SHT_PROGBITS, shf);\n        stab_section->sh_entsize = sizeof(Stab_Sym);\n        stab_section->sh_addralign = sizeof ((Stab_Sym*)0)->n_value;\n        stab_section->link = new_section(s1, \".stabstr\", SHT_STRTAB, shf);\n        /* put first entry */\n        put_stabs(s1, \"\", 0, 0, 0, 0);\n    }\n}\n\n/* put stab debug information */\nstatic void put_stabs(TCCState *s1, const char *str, int type, int other, int desc,\n                      unsigned long value)\n{\n    Stab_Sym *sym;\n\n    unsigned offset;\n    if (type == N_SLINE\n        && (offset = stab_section->data_offset)\n        && (sym = (Stab_Sym*)(stab_section->data + offset) - 1)\n        && sym->n_type == type\n        && sym->n_value == value) {\n        /* just update line_number in previous entry */\n        sym->n_desc = desc;\n        return;\n    }\n\n    sym = section_ptr_add(stab_section, sizeof(Stab_Sym));\n    if (str) {\n        sym->n_strx = put_elf_str(stab_section->link, str);\n    } else {\n        sym->n_strx = 0;\n    }\n    sym->n_type = type;\n    sym->n_other = other;\n    sym->n_desc = desc;\n    sym->n_value = value;\n}\n\nstatic void put_stabs_r(TCCState *s1, const char *str, int type, int other, int desc,\n                        unsigned long value, Section *sec, int sym_index)\n{\n    put_elf_reloc(symtab_section, stab_section,\n                  stab_section->data_offset + 8,\n                  sizeof ((Stab_Sym*)0)->n_value == PTR_SIZE ? R_DATA_PTR : R_DATA_32,\n                  sym_index);\n    put_stabs(s1, str, type, other, desc, value);\n}\n\nstatic void put_stabn(TCCState *s1, int type, int other, int desc, int value)\n{\n    put_stabs(s1, NULL, type, other, desc, value);\n}\n\n/* ------------------------------------------------------------------------- */\n#define\tdwarf_data1(s,data) \\\n\t(*(uint8_t*)section_ptr_add((s), 1) = (data))\n#define\tdwarf_data2(s,data) \\\n\twrite16le(section_ptr_add((s), 2), (data))\n#define\tdwarf_data4(s,data) \\\n\twrite32le(section_ptr_add((s), 4), (data))\n#define\tdwarf_data8(s,data) \\\n\twrite64le(section_ptr_add((s), 8), (data))\n\nstatic int dwarf_get_section_sym(Section *s)\n{\n    TCCState *s1 = s->s1;\n    return put_elf_sym(symtab_section, 0, 0,\n                       ELFW(ST_INFO)(STB_LOCAL, STT_SECTION), 0,\n                       s->sh_num, NULL);\n}\n\nstatic void dwarf_reloc(Section *s, int sym, int rel)\n{\n    TCCState *s1 = s->s1;\n    put_elf_reloca(symtab_section, s, s->data_offset, rel, sym, 0);\n}\n\nstatic void dwarf_string(Section *s, Section *dw, int sym, const char *str)\n{\n    TCCState *s1 = s->s1;\n    int offset, len;\n    char *ptr;\n\n    len = strlen(str) + 1;\n    offset = dw->data_offset;\n    ptr = section_ptr_add(dw, len);\n    memmove(ptr, str, len);\n    put_elf_reloca(symtab_section, s, s->data_offset, R_DATA_32DW, sym,\n                   PTR_SIZE == 4 ? 0 : offset);\n    dwarf_data4(s, PTR_SIZE == 4 ? offset : 0);\n}\n\nstatic void dwarf_strp(Section *s, const char *str)\n{\n    TCCState *s1 = s->s1;\n    dwarf_string(s, dwarf_str_section, dwarf_sym.str, str);\n}\n\nstatic void dwarf_line_strp(Section *s, const char *str)\n{\n    TCCState *s1 = s->s1;\n    dwarf_string(s, dwarf_line_str_section, dwarf_sym.line_str, str);\n}\n\nstatic void dwarf_line_op(TCCState *s1, unsigned char op)\n{\n    if (dwarf_line.line_size >= dwarf_line.line_max_size) {\n\tdwarf_line.line_max_size += 1024;\n\tdwarf_line.line_data =\n\t    (unsigned char *)tcc_realloc(dwarf_line.line_data,\n\t\t\t\t\t dwarf_line.line_max_size);\n    }\n    dwarf_line.line_data[dwarf_line.line_size++] = op;\n}\n\nstatic void dwarf_file(TCCState *s1)\n{\n    int i, j;\n    char *filename;\n    int index_offset = s1->dwarf < 5;\n\n    if (!strcmp(file->filename, \"<command line>\")) {\n        dwarf_line.cur_file = 1;\n\treturn;\n    }\n    filename = strrchr(file->filename, '/');\n    if (filename == NULL) {\n        for (i = 1; i < dwarf_line.filename_size; i++)\n            if (dwarf_line.filename_table[i].dir_entry == 0 &&\n\t\tstrcmp(dwarf_line.filename_table[i].name,\n\t\t       file->filename) == 0) {\n\t\t    dwarf_line.cur_file = i + index_offset;\n\t            return;\n\t\t}\n\ti = -index_offset;\n\tfilename = file->filename;\n    }\n    else {\n\tchar *undo = filename;\n\tchar *dir = file->filename;\n\n\t*filename++ = '\\0';\n        for (i = 0; i < dwarf_line.dir_size; i++)\n\t    if (strcmp(dwarf_line.dir_table[i], dir) == 0) {\n\t\tfor (j = 1; j < dwarf_line.filename_size; j++)\n\t\t    if (dwarf_line.filename_table[j].dir_entry - index_offset\n\t\t\t== i &&\n\t\t\tstrcmp(dwarf_line.filename_table[j].name,\n\t\t\t       filename) == 0) {\n\t\t\t*undo = '/';\n\t\t        dwarf_line.cur_file = j + index_offset;\n\t\t\treturn;\n\t\t    }\n\t\tbreak;\n\t    }\n\tif (i == dwarf_line.dir_size) {\n\t    dwarf_line.dir_size++;\n\t    dwarf_line.dir_table =\n                (char **) tcc_realloc(dwarf_line.dir_table,\n                                      dwarf_line.dir_size *\n                                      sizeof (char *));\n            dwarf_line.dir_table[i] = tcc_strdup(dir);\n\t}\n\t*undo = '/';\n    }\n    dwarf_line.filename_table =\n        (struct dwarf_filename_struct *)\n        tcc_realloc(dwarf_line.filename_table,\n                    (dwarf_line.filename_size + 1) *\n                    sizeof (struct dwarf_filename_struct));\n    dwarf_line.filename_table[dwarf_line.filename_size].dir_entry =\n\ti + index_offset;\n    dwarf_line.filename_table[dwarf_line.filename_size].name =\n        tcc_strdup(filename);\n    dwarf_line.cur_file = dwarf_line.filename_size++ + index_offset;\n    return;\n}\n\n#if 0\nstatic int dwarf_uleb128_size (unsigned long long value)\n{\n    int size =  0;\n\n    do {\n        value >>= 7;\n        size++;\n    } while (value != 0);\n    return size;\n}\n#endif\n\nstatic int dwarf_sleb128_size (long long value)\n{\n    int size =  0;\n    long long end = value >> 63;\n    unsigned char last = end & 0x40;\n    unsigned char byte;\n\n    do {\n        byte = value & 0x7f;\n        value >>= 7;\n        size++;\n    } while (value != end || (byte & 0x40) != last);\n    return size;\n}\n\nstatic void dwarf_uleb128 (Section *s, unsigned long long value)\n{\n    do {\n        unsigned char byte = value & 0x7f;\n\n        value >>= 7;\n        dwarf_data1(s, byte | (value ? 0x80 : 0));\n    } while (value != 0);\n}\n\nstatic void dwarf_sleb128 (Section *s, long long value)\n{\n    int more;\n    long long end = value >> 63;\n    unsigned char last = end & 0x40;\n\n    do {\n        unsigned char byte = value & 0x7f;\n\n        value >>= 7;\n\tmore = value != end || (byte & 0x40) != last;\n        dwarf_data1(s, byte | (0x80 * more));\n    } while (more);\n}\n\nstatic void dwarf_uleb128_op (TCCState *s1, unsigned long long value)\n{\n    do {\n        unsigned char byte = value & 0x7f;\n\n        value >>= 7;\n        dwarf_line_op(s1, byte | (value ? 0x80 : 0));\n    } while (value != 0);\n}\n\nstatic void dwarf_sleb128_op (TCCState *s1, long long value)\n{\n    int more;\n    long long end = value >> 63;\n    unsigned char last = end & 0x40;\n\n    do {\n        unsigned char byte = value & 0x7f;\n\n        value >>= 7;\n        more = value != end || (byte & 0x40) != last;\n        dwarf_line_op(s1, byte | (0x80 * more));\n    } while (more);\n}\n\n#if TCC_EH_FRAME\nST_FUNC void tcc_eh_frame_start(TCCState *s1)\n{\n    if (!s1->unwind_tables)\n        return;\n    eh_frame_section = new_section(s1, \".eh_frame\", SHT_PROGBITS, SHF_ALLOC);\n\n    s1->eh_start = eh_frame_section->data_offset;\n    dwarf_data4(eh_frame_section, 0); // length\n    dwarf_data4(eh_frame_section, 0); // CIE ID\n    dwarf_data1(eh_frame_section, 1); // Version\n    dwarf_data1(eh_frame_section, 'z'); // Augmentation String\n    dwarf_data1(eh_frame_section, 'R');\n    dwarf_data1(eh_frame_section, 0);\n#if defined TCC_TARGET_I386\n    dwarf_uleb128(eh_frame_section, 1); // code_alignment_factor\n    dwarf_sleb128(eh_frame_section, -4); // data_alignment_factor\n    dwarf_uleb128(eh_frame_section, 8); // return address column\n    dwarf_uleb128(eh_frame_section, 1); // Augmentation len\n    dwarf_data1(eh_frame_section, FDE_ENCODING);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 4); // r4 (esp)\n    dwarf_uleb128(eh_frame_section, 4); // ofs 4\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 8); // r8 (eip)\n    dwarf_uleb128(eh_frame_section, 1); // cfa-4\n#elif defined TCC_TARGET_X86_64\n    dwarf_uleb128(eh_frame_section, 1); // code_alignment_factor\n    dwarf_sleb128(eh_frame_section, -8); // data_alignment_factor\n    dwarf_uleb128(eh_frame_section, 16); // return address column\n    dwarf_uleb128(eh_frame_section, 1); // Augmentation len\n    dwarf_data1(eh_frame_section, FDE_ENCODING);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 7); // r7 (rsp)\n    dwarf_uleb128(eh_frame_section, 8); // ofs 8\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 16); // r16 (rip)\n    dwarf_uleb128(eh_frame_section, 1); // cfa-8\n#elif defined TCC_TARGET_ARM\n    /* TODO: arm must be compiled with: -funwind-tables */\n    /* arm also uses .ARM.extab and .ARM.exidx sections */\n    dwarf_uleb128(eh_frame_section, 2); // code_alignment_factor\n    dwarf_sleb128(eh_frame_section, -4); // data_alignment_factor\n    dwarf_uleb128(eh_frame_section, 14); // return address column\n    dwarf_uleb128(eh_frame_section, 1); // Augmentation len\n    dwarf_data1(eh_frame_section, FDE_ENCODING);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 13); // r13 (sp)\n    dwarf_uleb128(eh_frame_section, 0); // ofs 0\n#elif defined TCC_TARGET_ARM64\n    dwarf_uleb128(eh_frame_section, 4); // code_alignment_factor\n    dwarf_sleb128(eh_frame_section, -8); // data_alignment_factor\n    dwarf_uleb128(eh_frame_section, 30); // return address column\n    dwarf_uleb128(eh_frame_section, 1); // Augmentation len\n    dwarf_data1(eh_frame_section, FDE_ENCODING);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 31); // x31 (sp)\n    dwarf_uleb128(eh_frame_section, 0); // ofs 0\n#elif defined TCC_TARGET_RISCV64\n    eh_frame_section->data[s1->eh_start + 8] = 3; // version = 3\n    dwarf_uleb128(eh_frame_section, 1); // code_alignment_factor\n    dwarf_sleb128(eh_frame_section, -4); // data_alignment_factor\n    dwarf_uleb128(eh_frame_section, 1); // return address column\n    dwarf_uleb128(eh_frame_section, 1); // Augmentation len\n    dwarf_data1(eh_frame_section, FDE_ENCODING);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 2); // r2 (sp)\n    dwarf_uleb128(eh_frame_section, 0); // ofs 0\n#endif\n    while ((eh_frame_section->data_offset - s1->eh_start) & 3)\n\tdwarf_data1(eh_frame_section, DW_CFA_nop);\n    write32le(eh_frame_section->data + s1->eh_start, // length\n\t      eh_frame_section->data_offset - s1->eh_start - 4);\n}\n\nstatic void tcc_debug_frame_end(TCCState *s1, int size)\n{\n    int eh_section_sym;\n    unsigned long fde_start;\n\n    if (!eh_frame_section)\n\treturn;\n    eh_section_sym = dwarf_get_section_sym(text_section);\n    fde_start = eh_frame_section->data_offset;\n    dwarf_data4(eh_frame_section, 0); // length\n    dwarf_data4(eh_frame_section,\n\t\tfde_start - s1->eh_start + 4); // CIE Pointer\n#if defined TCC_TARGET_I386\n    dwarf_reloc(eh_frame_section, eh_section_sym, R_386_PC32);\n#elif defined TCC_TARGET_X86_64\n    dwarf_reloc(eh_frame_section, eh_section_sym, R_X86_64_PC32);\n#elif defined TCC_TARGET_ARM\n    dwarf_reloc(eh_frame_section, eh_section_sym, R_ARM_REL32);\n#elif defined TCC_TARGET_ARM64\n    dwarf_reloc(eh_frame_section, eh_section_sym, R_AARCH64_PREL32);\n#elif defined TCC_TARGET_RISCV64\n    dwarf_reloc(eh_frame_section, eh_section_sym, R_RISCV_32_PCREL);\n#endif\n    dwarf_data4(eh_frame_section, func_ind); // PC Begin\n    dwarf_data4(eh_frame_section, size); // PC Range\n    dwarf_data1(eh_frame_section, 0); // Augmentation Length\n#if defined TCC_TARGET_I386\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 1);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 8);\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 5); // r5 (ebp)\n    dwarf_uleb128(eh_frame_section, 2); // cfa-8\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 2);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_register);\n    dwarf_uleb128(eh_frame_section, 5); // r5 (ebp)\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc4);\n    dwarf_data4(eh_frame_section, size - 5);\n    dwarf_data1(eh_frame_section, DW_CFA_restore + 5); // r5 (ebp)\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 4); // r4 (esp)\n    dwarf_uleb128(eh_frame_section, 4); // ofs 4\n#elif defined TCC_TARGET_X86_64\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 1);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 16);\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 6); // r6 (rbp)\n    dwarf_uleb128(eh_frame_section, 2); // cfa-16\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 3);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_register);\n    dwarf_uleb128(eh_frame_section, 6); // r6 (rbp)\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc4);\n    dwarf_data4(eh_frame_section, size - 5);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 7); // r7 (rsp)\n    dwarf_uleb128(eh_frame_section, 8); // ofs 8\n#elif defined TCC_TARGET_ARM\n    /* TODO */\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 2);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 8);\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 14); // r14 (lr)\n    dwarf_uleb128(eh_frame_section, 1);\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 11); // r11 (fp)\n    dwarf_uleb128(eh_frame_section, 2);\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc4);\n    dwarf_data4(eh_frame_section, size / 2 - 5);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_register);\n    dwarf_uleb128(eh_frame_section, 11); // r11 (fp)\n#elif defined TCC_TARGET_ARM64\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 1);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 224);\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 29); // x29 (fp)\n    dwarf_uleb128(eh_frame_section, 28); // cfa-224\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 30); // x30 (lr)\n    dwarf_uleb128(eh_frame_section, 27); // cfa-216\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 3);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 224 + ((-loc + 15) & ~15));\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc4);\n    dwarf_data4(eh_frame_section, size / 4 - 5);\n    dwarf_data1(eh_frame_section, DW_CFA_restore + 30); // x30 (lr)\n    dwarf_data1(eh_frame_section, DW_CFA_restore + 29); // x29 (fp)\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 0);\n#elif defined TCC_TARGET_RISCV64\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 4);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 16); // ofs 16\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 8);\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 1); // r1 (ra, lr)\n    dwarf_uleb128(eh_frame_section, 2); // cfa-8\n    dwarf_data1(eh_frame_section, DW_CFA_offset + 8); // r8 (s0, fp)\n    dwarf_uleb128(eh_frame_section, 4); // cfa-16\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 8);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 8); // r8 (s0, fp)\n    dwarf_uleb128(eh_frame_section, 0); // ofs 0\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc4);\n    while (size >= 4 &&\n\t   read32le(cur_text_section->data + func_ind + size - 4) != 0x00008067)\n\tsize -= 4;\n    dwarf_data4(eh_frame_section, size - 36);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa);\n    dwarf_uleb128(eh_frame_section, 2); // r2 (r2, sp)\n    dwarf_uleb128(eh_frame_section, 16); // ofs 16\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 4);\n    dwarf_data1(eh_frame_section, DW_CFA_restore + 1); // r1 (lr)\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 4);\n    dwarf_data1(eh_frame_section, DW_CFA_restore + 8); // r8 (s0, fp)\n    dwarf_data1(eh_frame_section, DW_CFA_advance_loc + 4);\n    dwarf_data1(eh_frame_section, DW_CFA_def_cfa_offset);\n    dwarf_uleb128(eh_frame_section, 0); // ofs 0\n#endif\n    while ((eh_frame_section->data_offset - fde_start) & 3)\n\tdwarf_data1(eh_frame_section, DW_CFA_nop);\n    write32le(eh_frame_section->data + fde_start, // length\n\t      eh_frame_section->data_offset - fde_start - 4);\n}\n\nST_FUNC void tcc_eh_frame_end(TCCState *s1)\n{\n    if (!eh_frame_section)\n\treturn;\n    dwarf_data4(eh_frame_section, 0);\n}\n\nstruct eh_search_table {\n    uint32_t pc_offset;\n    uint32_t fde_offset;\n};\n\nstatic int sort_eh_table(const void *a, const void *b)\n{\n    uint32_t pc1 = ((const struct eh_search_table *)a)->pc_offset;\n    uint32_t pc2 = ((const struct eh_search_table *)b)->pc_offset;\n\n    return pc1 < pc2 ? -1 : pc1 > pc2 ? 1 : 0;\n}\n\nST_FUNC void tcc_eh_frame_hdr(TCCState *s1, int final)\n{\n    int count = 0, offset;\n    unsigned long count_offset, tab_offset;\n    unsigned char *ln, *end;\n    unsigned int last_cie_offset = 0xffffffff;\n\n    if (!eh_frame_section || !eh_frame_section->data_offset)\n\treturn;\n    if (final && !eh_frame_hdr_section)\n\treturn;\n    if (final == 0)\n        eh_frame_hdr_section =\n\t    new_section(s1, \".eh_frame_hdr\", SHT_PROGBITS, SHF_ALLOC);\n    eh_frame_hdr_section->data_offset = 0;\n    dwarf_data1(eh_frame_hdr_section, 1); // Version\n    // Pointer Encoding Format\n    dwarf_data1(eh_frame_hdr_section, DW_EH_PE_sdata4 | DW_EH_PE_pcrel);\n    // Count Encoding Format\n    dwarf_data1(eh_frame_hdr_section, DW_EH_PE_udata4 | DW_EH_PE_absptr);\n    // Table Encoding Format\n    dwarf_data1(eh_frame_hdr_section, DW_EH_PE_sdata4 | DW_EH_PE_datarel);\n    offset = eh_frame_section->sh_addr -\n             eh_frame_hdr_section->sh_addr -\n             eh_frame_hdr_section->data_offset;\n    dwarf_data4(eh_frame_hdr_section, offset); // eh_frame_ptr\n    // Count\n    count_offset = eh_frame_hdr_section->data_offset;\n    dwarf_data4(eh_frame_hdr_section, 0);\n    tab_offset = eh_frame_hdr_section->data_offset;\n    ln = eh_frame_section->data;\n    end = eh_frame_section->data + eh_frame_section->data_offset;\n    while (ln < end) {\n\tunsigned char *fde = ln, *rd = ln;\n\tunsigned int cie_offset, version, length = dwarf_read_4(rd, end);\n\tunsigned int pc_offset, fde_offset;\n\n\tif (length == 0)\n\t    goto next;\n        cie_offset = dwarf_read_4(rd, end);\n\tif (cie_offset == 0)\n\t    goto next;\n\tif (cie_offset != last_cie_offset) {\n\t    unsigned char *cie = rd - cie_offset + 4;\n\n\t    if (cie < eh_frame_section->data)\n\t\tgoto next;\n\t    version = dwarf_read_1(cie, end);\n\t    if ((version == 1 || version == 3) &&\n\t        dwarf_read_1(cie, end) == 'z' && // Augmentation String\n\t\tdwarf_read_1(cie, end) == 'R' &&\n\t\tdwarf_read_1(cie, end) == 0) {\n\t        dwarf_read_uleb128(&cie, end); // code_alignment_factor\n\t        dwarf_read_sleb128(&cie, end); // data_alignment_factor\n\t\tdwarf_read_1(cie, end); // return address column\n\t\tif (dwarf_read_uleb128(&cie, end) == 1 &&\n\t\t    dwarf_read_1(cie, end) == FDE_ENCODING) {\n\t\t    last_cie_offset = cie_offset;\n\t\t}\n\t\telse\n\t\t    goto next;\n\t    }\n\t    else\n\t\tgoto next;\n\t}\n\tcount++;\n\tfde_offset = eh_frame_section->sh_addr +\n\t\t     (fde - eh_frame_section->data) -\n\t\t     eh_frame_hdr_section->sh_addr;\n\tpc_offset = dwarf_read_4(rd, end) + fde_offset + 8;\n\tdwarf_data4(eh_frame_hdr_section, pc_offset);\n\tdwarf_data4(eh_frame_hdr_section, fde_offset);\nnext:\n\tln += length + 4;\n    }\n    add32le(eh_frame_hdr_section->data + count_offset, count);\n    qsort(eh_frame_hdr_section->data + tab_offset, count,\n\t  sizeof(struct eh_search_table), sort_eh_table);\n}\n#endif\n\n/* start of translation unit info */\nST_FUNC void tcc_debug_start(TCCState *s1)\n{\n    int i;\n    char buf[512];\n    char *filename;\n\n    /* we might currently #include the <command-line> */\n    filename = file->prev ? file->prev->filename : file->filename;\n\n    /* an elf symbol of type STT_FILE must be put so that STB_LOCAL\n       symbols can be safely used */\n    put_elf_sym(symtab_section, 0, 0,\n                ELFW(ST_INFO)(STB_LOCAL, STT_FILE), 0,\n                SHN_ABS, filename);\n\n    if (s1->do_debug) {\n\n        new_file = last_line_num = 0;\n        debug_next_type = N_DEFAULT_DEBUG;\n        debug_hash = NULL;\n        debug_anon_hash = NULL;\n        n_debug_hash = 0;\n        n_debug_anon_hash = 0;\n\n        getcwd(buf, sizeof(buf));\n#ifdef _WIN32\n        normalize_slashes(buf);\n#endif\n\n        if (s1->dwarf) {\n            int start_abbrev;\n            unsigned char *ptr;\n\t    char *undo;\n\n            /* dwarf_abbrev */\n            start_abbrev = dwarf_abbrev_section->data_offset;\n            ptr = section_ptr_add(dwarf_abbrev_section, sizeof(dwarf_abbrev_init));\n            memcpy(ptr, dwarf_abbrev_init, sizeof(dwarf_abbrev_init));\n\n            if (s1->dwarf < 5) {\n    \t        while (*ptr) {\n    \t            ptr += 3;\n    \t            while (*ptr) {\n    \t                if (ptr[1] == DW_FORM_line_strp)\n    \t\t            ptr[1] = DW_FORM_strp;\n\t\t        if (s1->dwarf < 4) {\n\t\t\t    /* These are compatable for DW_TAG_compile_unit\n\t\t\t       DW_AT_stmt_list. */\n\t\t\t    if  (ptr[1] == DW_FORM_sec_offset)\n\t\t\t         ptr[1] = DW_FORM_data4;\n\t\t\t    /* This code uses only size < 0x80 so these are\n\t\t\t       compatible. */\n\t\t\t    if  (ptr[1] == DW_FORM_exprloc)\n\t\t\t         ptr[1] = DW_FORM_block1;\n\t\t\t}\n    \t                ptr += 2;\n    \t            }\n\t\t    ptr += 2;\n    \t        }\n            }\n\n            dwarf_sym.info = dwarf_get_section_sym(dwarf_info_section);\n            dwarf_sym.abbrev = dwarf_get_section_sym(dwarf_abbrev_section);\n            dwarf_sym.line = dwarf_get_section_sym(dwarf_line_section);\n            dwarf_sym.str = dwarf_get_section_sym(dwarf_str_section);\n            if (tcc_state->dwarf >= 5)\n    \t        dwarf_sym.line_str = dwarf_get_section_sym(dwarf_line_str_section);\n            else {\n    \t        dwarf_line_str_section = dwarf_str_section;\n                dwarf_sym.line_str = dwarf_sym.str;\n            }\n            section_sym = dwarf_get_section_sym(text_section);\n\n            /* dwarf_info */\n            dwarf_info.start = dwarf_info_section->data_offset;\n            dwarf_data4(dwarf_info_section, 0); // size\n            dwarf_data2(dwarf_info_section, s1->dwarf); // version\n            if (s1->dwarf >= 5) {\n                dwarf_data1(dwarf_info_section, DW_UT_compile); // unit type\n                dwarf_data1(dwarf_info_section, PTR_SIZE);\n                dwarf_reloc(dwarf_info_section, dwarf_sym.abbrev, R_DATA_32DW);\n                dwarf_data4(dwarf_info_section, start_abbrev);\n            }\n            else {\n                dwarf_reloc(dwarf_info_section, dwarf_sym.abbrev, R_DATA_32DW);\n                dwarf_data4(dwarf_info_section, start_abbrev);\n                dwarf_data1(dwarf_info_section, PTR_SIZE);\n            }\n\n            dwarf_data1(dwarf_info_section, DWARF_ABBREV_COMPILE_UNIT);\n            dwarf_strp(dwarf_info_section, \"tcc \" TCC_VERSION);\n            dwarf_data1(dwarf_info_section, s1->cversion == 201112 ? DW_LANG_C11 : DW_LANG_C99);\n            dwarf_line_strp(dwarf_info_section, filename);\n            dwarf_line_strp(dwarf_info_section, buf);\n            dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);\n#if PTR_SIZE == 4\n            dwarf_data4(dwarf_info_section, ind); // low pc\n            dwarf_data4(dwarf_info_section, 0); // high pc\n#else\n            dwarf_data8(dwarf_info_section, ind); // low pc\n            dwarf_data8(dwarf_info_section, 0); // high pc\n#endif\n            dwarf_reloc(dwarf_info_section, dwarf_sym.line, R_DATA_32DW);\n            dwarf_data4(dwarf_info_section, dwarf_line_section->data_offset); // stmt_list\n\n            /* dwarf_line */\n            dwarf_line.start = dwarf_line_section->data_offset;\n            dwarf_data4(dwarf_line_section, 0); // length\n            dwarf_data2(dwarf_line_section, s1->dwarf); // version\n            if (s1->dwarf >= 5) {\n                dwarf_data1(dwarf_line_section, PTR_SIZE); // address size\n                dwarf_data1(dwarf_line_section, 0); // segment selector\n            }\n            dwarf_data4(dwarf_line_section, 0); // prologue Length\n            dwarf_data1(dwarf_line_section, DWARF_MIN_INSTR_LEN);\n            if (s1->dwarf >= 4)\n                dwarf_data1(dwarf_line_section, 1); // maximum ops per instruction\n            dwarf_data1(dwarf_line_section, 1); // Initial value of 'is_stmt'\n            dwarf_data1(dwarf_line_section, DWARF_LINE_BASE);\n            dwarf_data1(dwarf_line_section, DWARF_LINE_RANGE);\n            dwarf_data1(dwarf_line_section, DWARF_OPCODE_BASE);\n            ptr = section_ptr_add(dwarf_line_section, sizeof(dwarf_line_opcodes));\n            memcpy(ptr, dwarf_line_opcodes, sizeof(dwarf_line_opcodes));\n\t    undo = strrchr(filename, '/');\n\t    if (undo)\n\t\t*undo = 0;\n            dwarf_line.dir_size = 1 + (undo != NULL);\n            dwarf_line.dir_table = (char **) tcc_malloc(sizeof (char *) *\n\t\t\t\t\t\t\tdwarf_line.dir_size);\n            dwarf_line.dir_table[0] = tcc_strdup(buf);\n\t    if (undo)\n                dwarf_line.dir_table[1] = tcc_strdup(filename);\n            dwarf_line.filename_size = 2;\n            dwarf_line.filename_table =\n    \t        (struct dwarf_filename_struct *)\n    \t        tcc_malloc(2*sizeof (struct dwarf_filename_struct));\n            dwarf_line.filename_table[0].dir_entry = 0;\n\t    if (undo) {\n                dwarf_line.filename_table[0].name = tcc_strdup(undo + 1);\n                dwarf_line.filename_table[1].dir_entry = 1;\n                dwarf_line.filename_table[1].name = tcc_strdup(undo + 1);\n\t\t*undo = '/';\n\t    }\n\t    else {\n                dwarf_line.filename_table[0].name = tcc_strdup(filename);\n                dwarf_line.filename_table[1].dir_entry = 0;\n                dwarf_line.filename_table[1].name = tcc_strdup(filename);\n\t    }\n            dwarf_line.line_size = dwarf_line.line_max_size = 0;\n            dwarf_line.line_data = NULL;\n            dwarf_line.cur_file = 1;\n            dwarf_line.last_file = 0;\n            dwarf_line.last_pc = 0;\n            dwarf_line.last_line = 1;\n            dwarf_line_op(s1, 0); // extended\n            dwarf_uleb128_op(s1, 1 + PTR_SIZE); // extended size\n            dwarf_line_op(s1, DW_LNE_set_address);\n            for (i = 0; i < PTR_SIZE; i++)\n    \t        dwarf_line_op(s1, 0);\n            memset(&dwarf_info.base_type_used, 0, sizeof(dwarf_info.base_type_used));\n        }\n        else\n        {\n            /* file info: full path + filename */\n            pstrcat(buf, sizeof(buf), \"/\");\n            section_sym = put_elf_sym(symtab_section, 0, 0,\n                                      ELFW(ST_INFO)(STB_LOCAL, STT_SECTION), 0,\n                                      text_section->sh_num, NULL);\n            put_stabs_r(s1, buf, N_SO, 0, 0,\n                        text_section->data_offset, text_section, section_sym);\n            put_stabs_r(s1, filename, N_SO, 0, 0,\n                        text_section->data_offset, text_section, section_sym);\n            for (i = 0; i < N_DEFAULT_DEBUG; i++)\n                put_stabs(s1, default_debug[i].name, N_LSYM, 0, 0, 0);\n        }\n        /* we're currently 'including' the <command line> */\n        tcc_debug_bincl(s1);\n    }\n}\n\n/* put end of translation unit info */\nST_FUNC void tcc_debug_end(TCCState *s1)\n{\n    if (!s1->do_debug || debug_next_type == 0)\n        return;\n\n    if (debug_info_root)\n        tcc_debug_funcend(s1, 0); /* free stuff in case of errors */\n\n    if (s1->dwarf) {\n\tint i, j;\n\tint start_aranges;\n\tunsigned char *ptr;\n\tint text_size = text_section->data_offset;\n\n\t/* dwarf_info */\n\tfor (i = 0; i < n_debug_anon_hash; i++) {\n\t    Sym *t = debug_anon_hash[i].type;\n\t    int pos = dwarf_info_section->data_offset;\n\n\t    dwarf_data1(dwarf_info_section,\n                        IS_UNION (t->type.t) ? DWARF_ABBREV_UNION_EMPTY_TYPE\n                                             : DWARF_ABBREV_STRUCTURE_EMPTY_TYPE);\n            dwarf_strp(dwarf_info_section,\n                       (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM\n                       ? \"\" : get_tok_str(t->v, NULL));\n            dwarf_uleb128(dwarf_info_section, 0);\n            dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n            dwarf_uleb128(dwarf_info_section, file->line_num);\n\t    for (j = 0; j < debug_anon_hash[i].n_debug_type; j++)\n\t\twrite32le(dwarf_info_section->data +\n\t\t\t  debug_anon_hash[i].debug_type[j],\n\t\t\t  pos - dwarf_info.start);\n\t    tcc_free (debug_anon_hash[i].debug_type);\n\t}\n\ttcc_free (debug_anon_hash);\n\tdwarf_data1(dwarf_info_section, 0);\n\tptr = dwarf_info_section->data + dwarf_info.start;\n\twrite32le(ptr, dwarf_info_section->data_offset - dwarf_info.start - 4);\n\twrite32le(ptr + 25 + (s1->dwarf >= 5) + PTR_SIZE, text_size);\n\n\t/* dwarf_aranges */\n\tstart_aranges = dwarf_aranges_section->data_offset;\n\tdwarf_data4(dwarf_aranges_section, 0); // size\n\tdwarf_data2(dwarf_aranges_section, 2); // version\n\tdwarf_reloc(dwarf_aranges_section, dwarf_sym.info, R_DATA_32DW);\n\tdwarf_data4(dwarf_aranges_section, 0); // dwarf_info\n#if PTR_SIZE == 4\n\tdwarf_data1(dwarf_aranges_section, 4); // address size\n#else\n\tdwarf_data1(dwarf_aranges_section, 8); // address size\n#endif\n\tdwarf_data1(dwarf_aranges_section, 0); // segment selector size\n\tdwarf_data4(dwarf_aranges_section, 0); // padding\n\tdwarf_reloc(dwarf_aranges_section, section_sym, R_DATA_PTR);\n#if PTR_SIZE == 4\n\tdwarf_data4(dwarf_aranges_section, 0); // Begin\n\tdwarf_data4(dwarf_aranges_section, text_size); // End\n\tdwarf_data4(dwarf_aranges_section, 0); // End list\n\tdwarf_data4(dwarf_aranges_section, 0); // End list\n#else\n\tdwarf_data8(dwarf_aranges_section, 0); // Begin\n\tdwarf_data8(dwarf_aranges_section, text_size); // End\n\tdwarf_data8(dwarf_aranges_section, 0); // End list\n\tdwarf_data8(dwarf_aranges_section, 0); // End list\n#endif\n\tptr = dwarf_aranges_section->data + start_aranges;\n\twrite32le(ptr, dwarf_aranges_section->data_offset - start_aranges - 4);\n\n\t/* dwarf_line */\n\tif (s1->dwarf >= 5) {\n\t    dwarf_data1(dwarf_line_section, 1); /* col */\n\t    dwarf_uleb128(dwarf_line_section, DW_LNCT_path);\n\t    dwarf_uleb128(dwarf_line_section, DW_FORM_line_strp);\n\t    dwarf_uleb128(dwarf_line_section, dwarf_line.dir_size);\n\t    for (i = 0; i < dwarf_line.dir_size; i++)\n\t        dwarf_line_strp(dwarf_line_section, dwarf_line.dir_table[i]);\n\t    dwarf_data1(dwarf_line_section, 2); /* col */\n\t    dwarf_uleb128(dwarf_line_section, DW_LNCT_path);\n\t    dwarf_uleb128(dwarf_line_section, DW_FORM_line_strp);\n\t    dwarf_uleb128(dwarf_line_section, DW_LNCT_directory_index);\n\t    dwarf_uleb128(dwarf_line_section, DW_FORM_udata);\n\t    dwarf_uleb128(dwarf_line_section, dwarf_line.filename_size);\n\t    for (i = 0; i < dwarf_line.filename_size; i++) {\n\t        dwarf_line_strp(dwarf_line_section,\n\t\t\t\tdwarf_line.filename_table[i].name);\n\t        dwarf_uleb128(dwarf_line_section,\n\t\t\t      dwarf_line.filename_table[i].dir_entry);\n\t    }\n\t}\n\telse {\n\t    int len;\n\n\t    for (i = 0; i < dwarf_line.dir_size; i++) {\n\t        len = strlen(dwarf_line.dir_table[i]) + 1;\n\t        ptr = section_ptr_add(dwarf_line_section, len);\n\t        memmove(ptr, dwarf_line.dir_table[i], len);\n\t    }\n\t    dwarf_data1(dwarf_line_section, 0); /* end dir */\n\t    for (i = 0; i < dwarf_line.filename_size; i++) {\n\t        len = strlen(dwarf_line.filename_table[i].name) + 1;\n\t        ptr = section_ptr_add(dwarf_line_section, len);\n\t        memmove(ptr, dwarf_line.filename_table[i].name, len);\n\t        dwarf_uleb128(dwarf_line_section,\n\t\t\t      dwarf_line.filename_table[i].dir_entry);\n\t        dwarf_uleb128(dwarf_line_section, 0); /* time */\n\t        dwarf_uleb128(dwarf_line_section, 0); /* size */\n\t    }\n\t    dwarf_data1(dwarf_line_section, 0); /* end file */\n\t}\n\tfor (i = 0; i < dwarf_line.dir_size; i++)\n\t    tcc_free(dwarf_line.dir_table[i]);\n\ttcc_free(dwarf_line.dir_table);\n\tfor (i = 0; i < dwarf_line.filename_size; i++)\n\t    tcc_free(dwarf_line.filename_table[i].name);\n\ttcc_free(dwarf_line.filename_table);\n\n\tdwarf_line_op(s1, 0); // extended\n\tdwarf_uleb128_op(s1, 1); // extended size\n\tdwarf_line_op(s1, DW_LNE_end_sequence);\n\ti = (s1->dwarf >= 5) * 2;\n\twrite32le(&dwarf_line_section->data[dwarf_line.start + 6 + i],\n\t\t  dwarf_line_section->data_offset - dwarf_line.start - (10 + i));\n\tsection_ptr_add(dwarf_line_section, 3);\n\tdwarf_reloc(dwarf_line_section, section_sym, R_DATA_PTR);\n\tptr = section_ptr_add(dwarf_line_section, dwarf_line.line_size - 3);\n\tmemmove(ptr - 3, dwarf_line.line_data, dwarf_line.line_size);\n\ttcc_free(dwarf_line.line_data);\n\twrite32le(dwarf_line_section->data + dwarf_line.start,\n\t\t  dwarf_line_section->data_offset - dwarf_line.start - 4);\n    }\n    else\n    {\n        put_stabs_r(s1, NULL, N_SO, 0, 0,\n                    text_section->data_offset, text_section, section_sym);\n    }\n    tcc_free(debug_hash);\n    debug_next_type = 0;\n}\n\nstatic BufferedFile* put_new_file(TCCState *s1)\n{\n    BufferedFile *f = file;\n    /* use upper file if from inline \":asm:\" */\n    if (f->filename[0] == ':')\n        f = f->prev;\n    if (f && new_file) {\n        new_file = last_line_num = 0;\n        if (s1->dwarf)\n            dwarf_file(s1);\n        else\n            put_stabs_r(s1, f->filename, N_SOL, 0, 0, ind, text_section, section_sym);\n    }\n    return f;\n}\n\n/* put alternative filename */\nST_FUNC void tcc_debug_newfile(TCCState *s1)\n{\n    if (!s1->do_debug)\n        return;\n    if (s1->dwarf)\n        dwarf_file(s1);\n    new_file = 1;\n}\n\n/* begin of #include */\nST_FUNC void tcc_debug_bincl(TCCState *s1)\n{\n    if (!s1->do_debug)\n        return;\n    if (s1->dwarf)\n        dwarf_file(s1);\n    else\n        put_stabs(s1, file->filename, N_BINCL, 0, 0, 0);\n    new_file = 1;\n}\n\n/* end of #include */\nST_FUNC void tcc_debug_eincl(TCCState *s1)\n{\n    if (!s1->do_debug)\n        return;\n    if (s1->dwarf)\n        dwarf_file(s1);\n    else\n        put_stabn(s1, N_EINCL, 0, 0, 0);\n    new_file = 1;\n}\n\n/* generate line number info */\nST_FUNC void tcc_debug_line(TCCState *s1)\n{\n    BufferedFile *f;\n\n    if (!s1->do_debug)\n        return;\n    if (cur_text_section != text_section || nocode_wanted)\n        return;\n    f = put_new_file(s1);\n    if (!f)\n        return;\n    if (last_line_num == f->line_num)\n        return;\n    last_line_num = f->line_num;\n\n    if (s1->dwarf) {\n\tint len_pc = (ind - dwarf_line.last_pc) / DWARF_MIN_INSTR_LEN;\n\tint len_line = f->line_num - dwarf_line.last_line;\n\tint n = len_pc * DWARF_LINE_RANGE + len_line + DWARF_OPCODE_BASE - DWARF_LINE_BASE;\n\n\tif (dwarf_line.cur_file != dwarf_line.last_file) {\n\t    dwarf_line.last_file = dwarf_line.cur_file;\n\t    dwarf_line_op(s1, DW_LNS_set_file);\n\t    dwarf_uleb128_op(s1, dwarf_line.cur_file);\n\t}\n\tif (len_pc &&\n\t    len_line >= DWARF_LINE_BASE && len_line <= (DWARF_OPCODE_BASE + DWARF_LINE_BASE) &&\n\t    n >= DWARF_OPCODE_BASE && n <= 255)\n            dwarf_line_op(s1, n);\n\telse {\n\t    if (len_pc) {\n\t        n = len_pc * DWARF_LINE_RANGE + 0 + DWARF_OPCODE_BASE - DWARF_LINE_BASE;\n\t        if (n >= DWARF_OPCODE_BASE && n <= 255)\n                    dwarf_line_op(s1, n);\n\t\telse {\n\t            dwarf_line_op(s1, DW_LNS_advance_pc);\n\t\t    dwarf_uleb128_op(s1, len_pc);\n\t\t}\n\t    }\n\t    if (len_line) {\n\t        n = 0 * DWARF_LINE_RANGE + len_line + DWARF_OPCODE_BASE - DWARF_LINE_BASE;\n\t        if (len_line >= DWARF_LINE_BASE && len_line <= (DWARF_OPCODE_BASE + DWARF_LINE_BASE) &&\n\t\t    n >= DWARF_OPCODE_BASE && n <= 255)\n\t            dwarf_line_op(s1, n);\n\t\telse {\n\t            dwarf_line_op(s1, DW_LNS_advance_line);\n\t\t    dwarf_sleb128_op(s1, len_line);\n\t\t}\n\t    }\n\t}\n\tdwarf_line.last_pc = ind;\n\tdwarf_line.last_line = f->line_num;\n    }\n    else\n    {\n\tif (func_ind != -1) {\n            put_stabn(s1, N_SLINE, 0, f->line_num, ind - func_ind);\n        } else {\n            /* from tcc_assemble */\n            put_stabs_r(s1, NULL, N_SLINE, 0, f->line_num, ind, text_section, section_sym);\n        }\n    }\n}\n\nstatic void tcc_debug_stabs (TCCState *s1, const char *str, int type, unsigned long value,\n                             Section *sec, int sym_index, int info)\n{\n    struct debug_sym *s;\n\n    if (debug_info) {\n        debug_info->sym =\n            (struct debug_sym *)tcc_realloc (debug_info->sym,\n                                             sizeof(struct debug_sym) *\n                                             (debug_info->n_sym + 1));\n        s = debug_info->sym + debug_info->n_sym++;\n        s->type = type;\n        s->value = value;\n        s->str = tcc_strdup(str);\n        s->sec = sec;\n        s->sym_index = sym_index;\n        s->info = info;\n        s->file = dwarf_line.cur_file;\n        s->line = file->line_num;\n    }\n    else if (sec)\n        put_stabs_r (s1, str, type, 0, 0, value, sec, sym_index);\n    else\n        put_stabs (s1, str, type, 0, 0, value);\n}\n\nST_FUNC void tcc_debug_stabn(TCCState *s1, int type, int value)\n{\n    if (!s1->do_debug)\n        return;\n    if (type == N_LBRAC) {\n        struct _debug_info *info =\n            (struct _debug_info *) tcc_mallocz(sizeof (*info));\n\n        info->start = value;\n        info->parent = debug_info;\n        if (debug_info) {\n            if (debug_info->child) {\n                if (debug_info->child->last)\n                    debug_info->child->last->next = info;\n                else\n                    debug_info->child->next = info;\n                debug_info->child->last = info;\n            }\n            else\n                debug_info->child = info;\n        }\n        else\n            debug_info_root = info;\n        debug_info = info;\n    }\n    else {\n        debug_info->end = value;\n        debug_info = debug_info->parent;\n    }\n}\n\nstatic int tcc_debug_find(TCCState *s1, Sym *t, int dwarf)\n{\n    int i;\n\n    if (!debug_info && dwarf &&\n\t(t->type.t & VT_BTYPE) == VT_STRUCT && t->c == -1) {\n\tfor (i = 0; i < n_debug_anon_hash; i++)\n            if (t == debug_anon_hash[i].type)\n\t\treturn 0;\n\tdebug_anon_hash = (struct _debug_anon_hash *)\n            tcc_realloc (debug_anon_hash,\n                         (n_debug_anon_hash + 1) * sizeof(*debug_anon_hash));\n        debug_anon_hash[n_debug_anon_hash].n_debug_type = 0;\n        debug_anon_hash[n_debug_anon_hash].debug_type = NULL;\n        debug_anon_hash[n_debug_anon_hash++].type = t;\n\treturn 0;\n    }\n    for (i = 0; i < n_debug_hash; i++)\n        if (t == debug_hash[i].type)\n\t    return debug_hash[i].debug_type;\n    return -1;\n}\n\nstatic int tcc_get_dwarf_info(TCCState *s1, Sym *s);\n\nstatic void tcc_debug_check_anon(TCCState *s1, Sym *t, int debug_type)\n{\n    int i;\n\n    if (!debug_info && (t->type.t & VT_BTYPE) == VT_STRUCT && t->type.ref->c == -1)\n\tfor (i = 0; i < n_debug_anon_hash; i++)\n            if (t->type.ref == debug_anon_hash[i].type) {\n\t\tdebug_anon_hash[i].debug_type =\n\t\t    tcc_realloc(debug_anon_hash[i].debug_type,\n\t\t\t\t(debug_anon_hash[i].n_debug_type + 1) * sizeof(int));\n\t\tdebug_anon_hash[i].debug_type[debug_anon_hash[i].n_debug_type++] =\n\t\t    debug_type;\n            }\n}\n\nST_FUNC void tcc_debug_fix_anon(TCCState *s1, CType *t)\n{\n    int i, j, debug_type;\n\n    if (!(s1->do_debug & 2) || !s1->dwarf || debug_info)\n\treturn;\n\n    if ((t->t & VT_BTYPE) == VT_STRUCT && t->ref->c != -1)\n\tfor (i = 0; i < n_debug_anon_hash; i++)\n\t    if (t->ref == debug_anon_hash[i].type) {\n\t\tSym sym = {0}; sym .type = *t ;\n\n\t\t/* Trick to not hash this struct */\n\t\tdebug_info = (struct _debug_info *) t;\n\t\tdebug_type = tcc_get_dwarf_info(s1, &sym);\n\t\tdebug_info = NULL;\n\t\tfor (j = 0; j < debug_anon_hash[i].n_debug_type; j++)\n\t\t    write32le(dwarf_info_section->data +\n\t\t\t      debug_anon_hash[i].debug_type[j],\n\t\t\t      debug_type - dwarf_info.start);\n\t\ttcc_free(debug_anon_hash[i].debug_type);\n\t\tn_debug_anon_hash--;\n\t\tfor (; i < n_debug_anon_hash; i++)\n\t\t    debug_anon_hash[i] = debug_anon_hash[i + 1];\n\t    }\n}\n\nstatic int tcc_debug_add(TCCState *s1, Sym *t, int dwarf)\n{\n    int offset = dwarf ? dwarf_info_section->data_offset : ++debug_next_type;\n    debug_hash = (struct _debug_hash *)\n\ttcc_realloc (debug_hash,\n\t\t     (n_debug_hash + 1) * sizeof(*debug_hash));\n    debug_hash[n_debug_hash].debug_type = offset;\n    debug_hash[n_debug_hash++].type = t;\n    return offset;\n}\n\nstatic void tcc_debug_remove(TCCState *s1, Sym *t)\n{\n    int i;\n\n    for (i = 0; i < n_debug_hash; i++)\n        if (t == debug_hash[i].type) {\n\t    n_debug_hash--;\n\t    for (; i < n_debug_hash; i++)\n\t\tdebug_hash[i] = debug_hash[i+1];\n\t}\n}\n\n#define\tSTRUCT_NODEBUG(s) \t\t\t       \\\n    (s->a.nodebug ||                           \\\n     ((s->v & ~SYM_FIELD) >= SYM_FIRST_ANOM && \\\n      ((s->type.t & VT_BTYPE) == VT_BYTE ||    \\\n       (s->type.t & VT_BTYPE) == VT_BOOL ||    \\\n       (s->type.t & VT_BTYPE) == VT_SHORT ||   \\\n       (s->type.t & VT_BTYPE) == VT_INT ||     \\\n       (s->type.t & VT_BTYPE) == VT_LLONG)))\n\nstatic void tcc_get_debug_info(TCCState *s1, Sym *s, CString *result)\n{\n    int type;\n    int n = 0;\n    int debug_type = -1;\n    Sym *t = s;\n    CString str;\n\n    for (;;) {\n        type = t->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE | VT_VLA);\n        if ((type & VT_BTYPE) != VT_BYTE)\n            type &= ~VT_DEFSIGN;\n        if (type == VT_PTR || type == (VT_PTR | VT_ARRAY))\n            n++, t = t->type.ref;\n        else\n            break;\n    }\n    if ((type & VT_BTYPE) == VT_STRUCT) {\n\tSym *e = t;\n\n        t = t->type.ref;\n\tdebug_type = tcc_debug_find(s1, t, 0);\n        if (debug_type == -1) {\n            debug_type = tcc_debug_add(s1, t, 0);\n            cstr_new (&str);\n            cstr_printf (&str, \"%s:T%d=%c%d\",\n                         (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM\n                         ? \"\" : get_tok_str(t->v, NULL),\n                         debug_type,\n                         IS_UNION (t->type.t) ? 'u' : 's',\n                         t->c);\n            while (t->next) {\n                int pos, size, align;\n\n                t = t->next;\n\t\tif (STRUCT_NODEBUG(t))\n\t\t    continue;\n                cstr_printf (&str, \"%s:\",\n                             get_tok_str(t->v, NULL));\n                tcc_get_debug_info (s1, t, &str);\n                if (t->type.t & VT_BITFIELD) {\n                    pos = t->c * 8 + BIT_POS(t->type.t);\n                    size = BIT_SIZE(t->type.t);\n                }\n                else {\n                    pos = t->c * 8;\n                    size = type_size(&t->type, &align) * 8;\n                }\n                cstr_printf (&str, \",%d,%d;\", pos, size);\n            }\n            cstr_printf (&str, \";\");\n            tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);\n            cstr_free (&str);\n            if (debug_info)\n                tcc_debug_remove(s1, e);\n        }\n    }\n    else if (IS_ENUM(type)) {\n        Sym *e = t = t->type.ref;\n\n\tdebug_type = tcc_debug_find(s1, t, 0);\n\tif (debug_type == -1) {\n\t    debug_type = tcc_debug_add(s1, t, 0);\n            cstr_new (&str);\n            cstr_printf (&str, \"%s:T%d=e\",\n                         (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM\n                         ? \"\" : get_tok_str(t->v, NULL),\n                         debug_type);\n            while (t->next) {\n                t = t->next;\n                cstr_printf (&str, \"%s:\",\n                             (t->v & ~SYM_FIELD) >= SYM_FIRST_ANOM\n                             ? \"\" : get_tok_str(t->v, NULL));\n                cstr_printf (&str, e->type.t & VT_UNSIGNED ? \"%u,\" : \"%d,\",\n                             (int)t->enum_val);\n            }\n            cstr_printf (&str, \";\");\n            tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);\n            cstr_free (&str);\n            if (debug_info)\n                tcc_debug_remove(s1, e);\n\t}\n    }\n    else if ((type & VT_BTYPE) != VT_FUNC) {\n        type &= ~VT_STRUCT_MASK;\n        for (debug_type = 1; debug_type <= N_DEFAULT_DEBUG; debug_type++)\n            if (default_debug[debug_type - 1].type == type)\n                break;\n        if (debug_type > N_DEFAULT_DEBUG)\n            return;\n    }\n    if (n > 0)\n        cstr_printf (result, \"%d=\", ++debug_next_type);\n    t = s;\n    for (;;) {\n        type = t->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE | VT_VLA);\n        if ((type & VT_BTYPE) != VT_BYTE)\n            type &= ~VT_DEFSIGN;\n        if (type == VT_PTR)\n            cstr_printf (result, \"%d=*\", ++debug_next_type);\n        else if (type == (VT_PTR | VT_ARRAY))\n            cstr_printf (result, \"%d=ar1;0;%d;\",\n                         ++debug_next_type, t->type.ref->c - 1);\n        else if (type == VT_FUNC) {\n            cstr_printf (result, \"%d=f\", ++debug_next_type);\n            tcc_get_debug_info (s1, t->type.ref, result);\n            return;\n        }\n        else\n            break;\n        t = t->type.ref;\n    }\n    cstr_printf (result, \"%d\", debug_type);\n}\n\nstatic int tcc_get_dwarf_info(TCCState *s1, Sym *s)\n{\n    int type;\n    int debug_type = -1;\n    Sym *e, *t = s;\n    int i;\n    int last_pos = -1;\n    int retval;\n\n    if (new_file)\n        put_new_file(s1);\n    for (;;) {\n        type = t->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE | VT_VLA);\n        if ((type & VT_BTYPE) != VT_BYTE)\n            type &= ~VT_DEFSIGN;\n        if (type == VT_PTR || type == (VT_PTR | VT_ARRAY))\n            t = t->type.ref;\n        else\n            break;\n    }\n    if ((type & VT_BTYPE) == VT_STRUCT) {\n        t = t->type.ref;\n\tdebug_type = tcc_debug_find(s1, t, 1);\n\tif (debug_type == -1) {\n\t    int pos_sib = 0, i, *pos_type;\n\n\t    debug_type = tcc_debug_add(s1, t, 1);\n\t    e = t;\n\t    i = 0;\n\t    while (e->next) {\n\t\te = e->next;\n\t\tif (STRUCT_NODEBUG(e))\n\t\t    continue;\n\t\ti++;\n\t    }\n\t    pos_type = (int *) tcc_malloc(i * sizeof(int));\n\t    dwarf_data1(dwarf_info_section,\n\t\t\tIS_UNION (t->type.t)\n\t\t        ? t->next ? DWARF_ABBREV_UNION_TYPE\n\t\t\t\t  : DWARF_ABBREV_UNION_EMPTY_TYPE\n\t\t        : t->next ? DWARF_ABBREV_STRUCTURE_TYPE\n\t\t\t\t  : DWARF_ABBREV_STRUCTURE_EMPTY_TYPE);\n\t    dwarf_strp(dwarf_info_section,\n                       (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM\n                       ? \"\" : get_tok_str(t->v, NULL));\n\t    dwarf_uleb128(dwarf_info_section, t->c);\n\t    dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n\t    dwarf_uleb128(dwarf_info_section, file->line_num);\n\t    if (t->next) {\n\t        pos_sib = dwarf_info_section->data_offset;\n\t        dwarf_data4(dwarf_info_section, 0);\n\t    }\n\t    e = t;\n\t    i = 0;\n            while (e->next) {\n                e = e->next;\n\t\tif (STRUCT_NODEBUG(e))\n\t\t    continue;\n\t        dwarf_data1(dwarf_info_section,\n\t\t\t    e->type.t & VT_BITFIELD ? DWARF_ABBREV_MEMBER_BF\n\t\t\t\t\t\t    : DWARF_ABBREV_MEMBER);\n\t\tdwarf_strp(dwarf_info_section,\n\t\t\t   get_tok_str(e->v, NULL));\n\t\tdwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n\t\tdwarf_uleb128(dwarf_info_section, file->line_num);\n\t\tpos_type[i++] = dwarf_info_section->data_offset;\n\t\tdwarf_data4(dwarf_info_section, 0);\n                if (e->type.t & VT_BITFIELD) {\n                    int pos = e->c * 8 + BIT_POS(e->type.t);\n                    int size = BIT_SIZE(e->type.t);\n\n\t\t    dwarf_uleb128(dwarf_info_section, size);\n\t\t    dwarf_uleb128(dwarf_info_section, pos);\n\t\t}\n\t\telse\n\t\t    dwarf_uleb128(dwarf_info_section, e->c);\n\t    }\n\t    if (t->next) {\n\t        dwarf_data1(dwarf_info_section, 0);\n\t        write32le(dwarf_info_section->data + pos_sib,\n\t\t          dwarf_info_section->data_offset - dwarf_info.start);\n\t    }\n\t    e = t;\n\t    i = 0;\n\t    while (e->next) {\n\t\te = e->next;\n\t\tif (STRUCT_NODEBUG(e))\n\t\t    continue;\n\t\ttype = tcc_get_dwarf_info(s1, e);\n\t\ttcc_debug_check_anon(s1, e, pos_type[i]);\n\t\twrite32le(dwarf_info_section->data + pos_type[i++],\n\t\t\t  type - dwarf_info.start);\n\t    }\n\t    tcc_free(pos_type);\n\t    if (debug_info)\n\t\ttcc_debug_remove(s1, t);\n        }\n    }\n    else if (IS_ENUM(type)) {\n        t = t->type.ref;\n\tdebug_type = tcc_debug_find(s1, t, 1);\n\tif (debug_type == -1) {\n\t    int pos_sib, pos_type;\n\t    Sym sym = {0}; sym.type.t = VT_INT | (type & VT_UNSIGNED);\n\n\t    pos_type = tcc_get_dwarf_info(s1, &sym);\n\t    debug_type = tcc_debug_add(s1, t, 1);\n\t    dwarf_data1(dwarf_info_section, DWARF_ABBREV_ENUMERATION_TYPE);\n\t    dwarf_strp(dwarf_info_section,\n                       (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM\n                       ? \"\" : get_tok_str(t->v, NULL));\n\t    dwarf_data1(dwarf_info_section,\n\t\t        type & VT_UNSIGNED ? DW_ATE_unsigned : DW_ATE_signed );\n\t    dwarf_data1(dwarf_info_section, 4);\n\t    dwarf_data4(dwarf_info_section, pos_type - dwarf_info.start);\n\t    dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n\t    dwarf_uleb128(dwarf_info_section, file->line_num);\n\t    pos_sib = dwarf_info_section->data_offset;\n\t    dwarf_data4(dwarf_info_section, 0);\n\t    e = t;\n            while (e->next) {\n                e = e->next;\n\t        dwarf_data1(dwarf_info_section,\n\t\t\ttype & VT_UNSIGNED ? DWARF_ABBREV_ENUMERATOR_UNSIGNED\n\t\t\t\t\t   : DWARF_ABBREV_ENUMERATOR_SIGNED);\n\t        dwarf_strp(dwarf_info_section,\n                           (e->v & ~SYM_FIELD) >= SYM_FIRST_ANOM\n                           ? \"\" : get_tok_str(e->v, NULL));\n\t\tif (type & VT_UNSIGNED)\n\t            dwarf_uleb128(dwarf_info_section, e->enum_val);\n\t\telse\n\t            dwarf_sleb128(dwarf_info_section, e->enum_val);\n            }\n\t    dwarf_data1(dwarf_info_section, 0);\n\t    write32le(dwarf_info_section->data + pos_sib,\n\t\t      dwarf_info_section->data_offset - dwarf_info.start);\n\t    if (debug_info)\n\t\ttcc_debug_remove(s1, t);\n\t}\n    }\n    else if ((type & VT_BTYPE) != VT_FUNC) {\n        type &= ~VT_STRUCT_MASK;\n        for (i = 1; i <= N_DEFAULT_DEBUG; i++)\n            if (default_debug[i - 1].type == type)\n                break;\n        if (i > N_DEFAULT_DEBUG)\n            return 0;\n\tdebug_type = dwarf_info.base_type_used[i - 1];\n\tif (debug_type == 0) {\n\t    char name[100];\n\n\t    debug_type = dwarf_info_section->data_offset;\n\t    dwarf_data1(dwarf_info_section, DWARF_ABBREV_BASE_TYPE);\n\t    dwarf_uleb128(dwarf_info_section, default_debug[i - 1].size);\n\t    dwarf_data1(dwarf_info_section, default_debug[i - 1].encoding);\n\t    strncpy(name, default_debug[i - 1].name, sizeof(name) -1);\n\t    *strchr(name, ':') = 0;\n\t    dwarf_strp(dwarf_info_section, name);\n\t    dwarf_info.base_type_used[i - 1] = debug_type;\n\t}\n    }\n    retval = debug_type;\n    e = NULL;\n    t = s;\n    for (;;) {\n        type = t->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE | VT_VLA);\n        if ((type & VT_BTYPE) != VT_BYTE)\n            type &= ~VT_DEFSIGN;\n        if (type == VT_PTR) {\n\t    i = dwarf_info_section->data_offset;\n\t    if (retval == debug_type)\n\t\tretval = i;\n\t    dwarf_data1(dwarf_info_section, DWARF_ABBREV_POINTER);\n\t    dwarf_data1(dwarf_info_section, PTR_SIZE);\n\t    if (last_pos != -1) {\n\t\ttcc_debug_check_anon(s1, e, last_pos);\n\t\twrite32le(dwarf_info_section->data + last_pos,\n\t\t\t  i - dwarf_info.start);\n\t    }\n\t    last_pos = dwarf_info_section->data_offset;\n\t    e = t->type.ref;\n\t    dwarf_data4(dwarf_info_section, 0);\n\t}\n        else if (type == (VT_PTR | VT_ARRAY)) {\n\t    int sib_pos, sub_type;\n#if LONG_SIZE == 4\n\t    Sym sym = {0}; sym.type.t = VT_LONG | VT_INT | VT_UNSIGNED;\n#else\n\t    Sym sym = {0}; sym.type.t = VT_LLONG | VT_LONG | VT_UNSIGNED;\n#endif\n\n\t    sub_type = tcc_get_dwarf_info(s1, &sym);\n\t    i = dwarf_info_section->data_offset;\n\t    if (retval == debug_type)\n\t\tretval = i;\n\t    dwarf_data1(dwarf_info_section, DWARF_ABBREV_ARRAY_TYPE);\n\t    if (last_pos != -1) {\n\t\ttcc_debug_check_anon(s1, e, last_pos);\n\t\twrite32le(dwarf_info_section->data + last_pos,\n\t\t\t  i - dwarf_info.start);\n\t    }\n\t    last_pos = dwarf_info_section->data_offset;\n\t    e = t->type.ref;\n\t    dwarf_data4(dwarf_info_section, 0);\n\t    sib_pos = dwarf_info_section->data_offset;\n\t    dwarf_data4(dwarf_info_section, 0);\n\t    for (;;) {\n\t        dwarf_data1(dwarf_info_section, DWARF_ABBREV_SUBRANGE_TYPE);\n\t        dwarf_data4(dwarf_info_section, sub_type - dwarf_info.start);\n\t        dwarf_uleb128(dwarf_info_section, t->type.ref->c - 1);\n\t\ts = t->type.ref;\n\t\ttype = s->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE);\n\t\tif (type != (VT_PTR | VT_ARRAY))\n\t\t    break;\n\t\tt = s;\n\t    }\n\t    dwarf_data1(dwarf_info_section, 0);\n\t    write32le(dwarf_info_section->data + sib_pos,\n\t\t      dwarf_info_section->data_offset - dwarf_info.start);\n\t}\n        else if (type == VT_FUNC) {\n\t    int sib_pos = 0, *pos_type;\n\t    Sym *f;\n\n\t    i = dwarf_info_section->data_offset;\n\t    debug_type = tcc_get_dwarf_info(s1, t->type.ref);\n\t    if (retval == debug_type)\n\t\tretval = i;\n\t    dwarf_data1(dwarf_info_section,\n\t\t\tt->type.ref->next ? DWARF_ABBREV_SUBROUTINE_TYPE\n\t\t\t\t\t  : DWARF_ABBREV_SUBROUTINE_EMPTY_TYPE);\n\t    if (last_pos != -1) {\n\t\ttcc_debug_check_anon(s1, e, last_pos);\n\t\twrite32le(dwarf_info_section->data + last_pos,\n\t\t\t  i - dwarf_info.start);\n\t    }\n\t    last_pos = dwarf_info_section->data_offset;\n\t    e = t->type.ref;\n\t    dwarf_data4(dwarf_info_section, 0);\n\t    if (t->type.ref->next) {\n\t        sib_pos = dwarf_info_section->data_offset;\n\t        dwarf_data4(dwarf_info_section, 0);\n\t    }\n\t    f = t->type.ref;\n\t    i = 0;\n\t    while (f->next) {\n\t\tf = f->next;\n\t\ti++;\n\t    }\n\t    pos_type = (int *) tcc_malloc(i * sizeof(int));\n\t    f = t->type.ref;\n\t    i = 0;\n\t    while (f->next) {\n\t\tf = f->next;\n\t        dwarf_data1(dwarf_info_section, DWARF_ABBREV_FORMAL_PARAMETER2);\n\t\tpos_type[i++] = dwarf_info_section->data_offset;\n\t        dwarf_data4(dwarf_info_section, 0);\n\t    }\n\t    if (t->type.ref->next) {\n\t        dwarf_data1(dwarf_info_section, 0);\n\t        write32le(dwarf_info_section->data + sib_pos,\n\t\t          dwarf_info_section->data_offset - dwarf_info.start);\n\t    }\n\t    f = t->type.ref;\n\t    i = 0;\n\t    while (f->next) {\n\t\tf = f->next;\n\t\ttype = tcc_get_dwarf_info(s1, f);\n\t\ttcc_debug_check_anon(s1, f, pos_type[i]);\n\t        write32le(dwarf_info_section->data + pos_type[i++],\n                          type - dwarf_info.start);\n\t    }\n\t    tcc_free(pos_type);\n        }\n        else {\n\t    if (last_pos != -1) {\n\t\ttcc_debug_check_anon(s1, e, last_pos);\n\t\twrite32le(dwarf_info_section->data + last_pos,\n\t\t\t  debug_type - dwarf_info.start);\n\t    }\n            break;\n\t}\n        t = t->type.ref;\n    }\n    return retval;\n}\n\nstatic void tcc_debug_finish (TCCState *s1, struct _debug_info *cur)\n{\n    while (cur) {\n        struct _debug_info *next = cur->next;\n        int i;\n\n        if (s1->dwarf) {\n\n            for (i = cur->n_sym - 1; i >= 0; i--) {\n                struct debug_sym *s = &cur->sym[i];\n\n\t\tdwarf_data1(dwarf_info_section,\n                            s->type == N_PSYM\n\t\t\t    ? DWARF_ABBREV_FORMAL_PARAMETER\n\t\t\t    : s->type == N_GSYM\n                            ? DWARF_ABBREV_VARIABLE_EXTERNAL\n                            : s->type == N_STSYM\n\t\t\t    ? DWARF_ABBREV_VARIABLE_STATIC\n\t\t\t    : DWARF_ABBREV_VARIABLE_LOCAL);\n                dwarf_strp(dwarf_info_section, s->str);\n\t\tif (s->type == N_GSYM || s->type == N_STSYM) {\n                    dwarf_uleb128(dwarf_info_section, s->file);\n                    dwarf_uleb128(dwarf_info_section, s->line);\n\t\t}\n                dwarf_data4(dwarf_info_section, s->info - dwarf_info.start);\n\t\tif (s->type == N_GSYM || s->type == N_STSYM) {\n\t\t    /* global/static */\n\t\t    if (s->type == N_GSYM)\n                        dwarf_data1(dwarf_info_section, 1);\n                    dwarf_data1(dwarf_info_section, PTR_SIZE + 1);\n                    dwarf_data1(dwarf_info_section, DW_OP_addr);\n\t\t    if (s->type == N_STSYM)\n\t\t        dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);\n#if PTR_SIZE == 4\n                    dwarf_data4(dwarf_info_section, s->value);\n#else\n                    dwarf_data8(dwarf_info_section, s->value);\n#endif\n\t\t}\n\t\telse {\n\t\t    /* param/local */\n                    dwarf_data1(dwarf_info_section, dwarf_sleb128_size(s->value) + 1);\n                    dwarf_data1(dwarf_info_section, DW_OP_fbreg);\n                    dwarf_sleb128(dwarf_info_section, s->value);\n\t\t}\n\t\ttcc_free (s->str);\n            }\n            tcc_free (cur->sym);\n            dwarf_data1(dwarf_info_section,\n\t\t\tcur->child ? DWARF_ABBREV_LEXICAL_BLOCK\n\t\t\t           : DWARF_ABBREV_LEXICAL_EMPTY_BLOCK);\n            dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);\n#if PTR_SIZE == 4\n            dwarf_data4(dwarf_info_section, func_ind + cur->start);\n            dwarf_data4(dwarf_info_section, cur->end - cur->start);\n#else\n            dwarf_data8(dwarf_info_section, func_ind + cur->start);\n            dwarf_data8(dwarf_info_section, cur->end - cur->start);\n#endif\n            tcc_debug_finish (s1, cur->child);\n\t    if (cur->child)\n                dwarf_data1(dwarf_info_section, 0);\n        }\n        else\n        {\n            for (i = 0; i < cur->n_sym; i++) {\n                struct debug_sym *s = &cur->sym[i];\n\n                if (s->sec)\n                    put_stabs_r(s1, s->str, s->type, 0, 0, s->value,\n                                s->sec, s->sym_index);\n                else\n                    put_stabs(s1, s->str, s->type, 0, 0, s->value);\n                tcc_free (s->str);\n            }\n            tcc_free (cur->sym);\n            put_stabn(s1, N_LBRAC, 0, 0, cur->start);\n            tcc_debug_finish (s1, cur->child);\n            put_stabn(s1, N_RBRAC, 0, 0, cur->end);\n        }\n        tcc_free (cur);\n        cur = next;\n    }\n}\n\nST_FUNC void tcc_add_debug_info(TCCState *s1, int param, Sym *s, Sym *e)\n{\n    CString debug_str;\n\n    if (!(s1->do_debug & 2))\n        return;\n\n    cstr_new (&debug_str);\n    for (; s != e; s = s->prev) {\n        if (!s->v || (s->r & VT_VALMASK) != VT_LOCAL)\n            continue;\n\tif (s1->dwarf) {\n\t    tcc_debug_stabs(s1, get_tok_str(s->v, NULL),\n\t\t\t    param ? N_PSYM : N_LSYM, s->c, NULL, 0,\n\t\t\t    tcc_get_dwarf_info(s1, s));\n\t}\n\telse\n        {\n            cstr_reset (&debug_str);\n            cstr_printf (&debug_str, \"%s:%s\", get_tok_str(s->v, NULL),\n\t\t\t param ? \"p\" : \"\");\n            tcc_get_debug_info(s1, s, &debug_str);\n            tcc_debug_stabs(s1, debug_str.data, param ? N_PSYM : N_LSYM,\n\t\t\t    s->c, NULL, 0, 0);\n\t}\n    }\n    cstr_free (&debug_str);\n}\n\n/* put function symbol */\nST_FUNC void tcc_debug_funcstart(TCCState *s1, Sym *sym)\n{\n    CString debug_str;\n    BufferedFile *f;\n\n    if (!s1->do_debug)\n        return;\n    debug_info_root = NULL;\n    debug_info = NULL;\n    tcc_debug_stabn(s1, N_LBRAC, ind - func_ind);\n    f = put_new_file(s1);\n    if (!f)\n\treturn;\n\n    if (s1->dwarf) {\n        tcc_debug_line(s1);\n        dwarf_info.func = sym;\n        dwarf_info.line = file->line_num;\n\tif (s1->do_backtrace) {\n\t    int i, len;\n\n\t    dwarf_line_op(s1, 0); // extended\n\t    dwarf_uleb128_op(s1, strlen(funcname) + 2);\n\t    dwarf_line_op(s1, DW_LNE_hi_user - 1);\n\t    len = strlen(funcname) + 1;\n\t    for (i = 0; i < len; i++)\n\t\tdwarf_line_op(s1, funcname[i]);\n\t}\n    }\n    else\n    {\n        cstr_new (&debug_str);\n        cstr_printf(&debug_str, \"%s:%c\", funcname, sym->type.t & VT_STATIC ? 'f' : 'F');\n        tcc_get_debug_info(s1, sym->type.ref, &debug_str);\n        put_stabs_r(s1, debug_str.data, N_FUN, 0, f->line_num, 0, cur_text_section, sym->c);\n        cstr_free (&debug_str);\n        tcc_debug_line(s1);\n    }\n}\n\nST_FUNC void tcc_debug_prolog_epilog(TCCState *s1, int value)\n{\n    if (!s1->do_debug)\n        return;\n    if (s1->dwarf) {\n\tdwarf_line_op(s1, value == 0 ? DW_LNS_set_prologue_end\n\t\t\t\t     : DW_LNS_set_epilogue_begin);\n    }\n}\n\n/* put function size */\nST_FUNC void tcc_debug_funcend(TCCState *s1, int size)\n{\n    /* lldb does not like function end and next function start at same pc */\n    int min_instr_len;\n\n#if TCC_EH_FRAME\n    tcc_debug_frame_end(s1, size);\n#endif\n    if (!s1->do_debug)\n        return;\n    min_instr_len = dwarf_line.last_pc == ind ? 0 : DWARF_MIN_INSTR_LEN;\n    ind -= min_instr_len;\n    tcc_debug_line(s1);\n    ind += min_instr_len;\n    tcc_debug_stabn(s1, N_RBRAC, size);\n    if (s1->dwarf) {\n        int func_sib = 0;\n\tSym *sym = dwarf_info.func;\n\tint n_debug_info = tcc_get_dwarf_info(s1, sym->type.ref);\n\n        dwarf_data1(dwarf_info_section,\n\t    sym->type.t & VT_STATIC ? DWARF_ABBREV_SUBPROGRAM_STATIC\n\t\t\t\t    : DWARF_ABBREV_SUBPROGRAM_EXTERNAL);\n        if ((sym->type.t & VT_STATIC) == 0)\n            dwarf_data1(dwarf_info_section, 1);\n        dwarf_strp(dwarf_info_section, funcname);\n        dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n        dwarf_uleb128(dwarf_info_section, dwarf_info.line);\n\ttcc_debug_check_anon(s1, sym->type.ref, dwarf_info_section->data_offset);\n        dwarf_data4(dwarf_info_section, n_debug_info - dwarf_info.start);\n        dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);\n#if PTR_SIZE == 4\n        dwarf_data4(dwarf_info_section, func_ind); // low_pc\n        dwarf_data4(dwarf_info_section, size); // high_pc\n#else\n        dwarf_data8(dwarf_info_section, func_ind); // low_pc\n        dwarf_data8(dwarf_info_section, size); // high_pc\n#endif\n        func_sib = dwarf_info_section->data_offset;\n        dwarf_data4(dwarf_info_section, 0); // sibling\n        dwarf_data1(dwarf_info_section, 1);\n#if defined(TCC_TARGET_I386)\n        dwarf_data1(dwarf_info_section, DW_OP_reg5); // ebp\n#elif defined(TCC_TARGET_X86_64)\n        dwarf_data1(dwarf_info_section, DW_OP_reg6); // rbp\n#elif defined TCC_TARGET_ARM\n        dwarf_data1(dwarf_info_section, DW_OP_reg13); // sp\n#elif defined TCC_TARGET_ARM64\n        dwarf_data1(dwarf_info_section, DW_OP_reg29); // reg 29\n#elif defined TCC_TARGET_RISCV64\n        dwarf_data1(dwarf_info_section, DW_OP_reg8); // r8(s0)\n#else\n        dwarf_data1(dwarf_info_section, DW_OP_call_frame_cfa);\n#endif\n        tcc_debug_finish (s1, debug_info_root);\n\tdwarf_data1(dwarf_info_section, 0);\n        write32le(dwarf_info_section->data + func_sib,\n                  dwarf_info_section->data_offset - dwarf_info.start);\n    }\n    else\n    {\n        tcc_debug_finish (s1, debug_info_root);\n    }\n    debug_info_root = 0;\n}\n\n\nST_FUNC void tcc_debug_extern_sym(TCCState *s1, Sym *sym, int sh_num, int sym_bind, int sym_type)\n{\n    if (!(s1->do_debug & 2))\n        return;\n\n    if (sym_type == STT_FUNC || sym->v >= SYM_FIRST_ANOM)\n        return;\n    if (s1->dwarf) {\n        int debug_type;\n\n        debug_type = tcc_get_dwarf_info(s1, sym);\n\tdwarf_data1(dwarf_info_section,\n\t\t    sym_bind == STB_GLOBAL\n\t\t    ? DWARF_ABBREV_VARIABLE_EXTERNAL\n\t\t    : DWARF_ABBREV_VARIABLE_STATIC);\n\tdwarf_strp(dwarf_info_section, get_tok_str(sym->v, NULL));\n\tdwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n\tdwarf_uleb128(dwarf_info_section, file->line_num);\n\ttcc_debug_check_anon(s1, sym, dwarf_info_section->data_offset);\n\tdwarf_data4(dwarf_info_section, debug_type - dwarf_info.start);\n\tif (sym_bind == STB_GLOBAL)\n\t    dwarf_data1(dwarf_info_section, 1);\n\tdwarf_data1(dwarf_info_section, PTR_SIZE + 1);\n\tdwarf_data1(dwarf_info_section, DW_OP_addr);\n\tgreloca(dwarf_info_section, sym, dwarf_info_section->data_offset,\n\t\tR_DATA_PTR, 0);\n#if PTR_SIZE == 4\n\tdwarf_data4(dwarf_info_section, 0);\n#else\n\tdwarf_data8(dwarf_info_section, 0);\n#endif\n    }\n    else\n    {\n        Section *s = sh_num == SHN_COMMON ? common_section\n\t\t\t\t\t  : s1->sections[sh_num];\n        CString str;\n\n        cstr_new (&str);\n        cstr_printf (&str, \"%s:%c\",\n                get_tok_str(sym->v, NULL),\n                sym_bind == STB_GLOBAL ? 'G' : func_ind != -1 ? 'V' : 'S'\n                );\n        tcc_get_debug_info(s1, sym, &str);\n        if (sym_bind == STB_GLOBAL)\n            tcc_debug_stabs(s1, str.data, N_GSYM, 0, NULL, 0, 0);\n        else\n            tcc_debug_stabs(s1, str.data,\n                (sym->type.t & VT_STATIC) && data_section == s\n                ? N_STSYM : N_LCSYM, 0, s, sym->c, 0);\n        cstr_free (&str);\n    }\n}\n\nST_FUNC void tcc_debug_typedef(TCCState *s1, Sym *sym)\n{\n    if (!(s1->do_debug & 2))\n        return;\n\n    if (s1->dwarf) {\n\tint debug_type;\n\n        debug_type = tcc_get_dwarf_info(s1, sym);\n\tif (debug_type != -1) {\n\t    dwarf_data1(dwarf_info_section, DWARF_ABBREV_TYPEDEF);\n\t    dwarf_strp(dwarf_info_section, get_tok_str(sym->v, NULL));\n\t    dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);\n\t    dwarf_uleb128(dwarf_info_section, file->line_num);\n\t    tcc_debug_check_anon(s1, sym, dwarf_info_section->data_offset);\n\t    dwarf_data4(dwarf_info_section, debug_type - dwarf_info.start);\n\t}\n    }\n    else\n    {\n        CString str;\n        cstr_new (&str);\n        cstr_printf (&str, \"%s:t\",\n                     (sym->v & ~SYM_FIELD) >= SYM_FIRST_ANOM\n                     ? \"\" : get_tok_str(sym->v, NULL));\n        tcc_get_debug_info(s1, sym, &str);\n        tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);\n        cstr_free (&str);\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/* for section layout see lib/tcov.c */\n\nST_FUNC void tcc_tcov_block_end(TCCState *s1, int line);\n\nST_FUNC void tcc_tcov_block_begin(TCCState *s1)\n{\n    SValue sv;\n    void *ptr;\n    unsigned long last_offset = tcov_data.offset;\n\n    tcc_tcov_block_end (tcc_state, 0);\n    if (s1->test_coverage == 0 || nocode_wanted)\n\treturn;\n\n    if (tcov_data.last_file_name == 0 ||\n\tstrcmp ((const char *)(tcov_section->data + tcov_data.last_file_name),\n\t\tfile->true_filename) != 0) {\n\tchar wd[1024];\n\tCString cstr;\n\n\tif (tcov_data.last_func_name)\n\t    section_ptr_add(tcov_section, 1);\n\tif (tcov_data.last_file_name)\n\t    section_ptr_add(tcov_section, 1);\n\ttcov_data.last_func_name = 0;\n\tcstr_new (&cstr);\n\tif (file->true_filename[0] == '/') {\n\t    tcov_data.last_file_name = tcov_section->data_offset;\n\t    cstr_printf (&cstr, \"%s\", file->true_filename);\n\t}\n\telse {\n\t    getcwd (wd, sizeof(wd));\n\t    tcov_data.last_file_name = tcov_section->data_offset + strlen(wd) + 1;\n\t    cstr_printf (&cstr, \"%s/%s\", wd, file->true_filename);\n\t}\n\tptr = section_ptr_add(tcov_section, cstr.size + 1);\n\tstrcpy((char *)ptr, cstr.data);\n#ifdef _WIN32\n        normalize_slashes((char *)ptr);\n#endif\n\tcstr_free (&cstr);\n    }\n    if (tcov_data.last_func_name == 0 ||\n\tstrcmp ((const char *)(tcov_section->data + tcov_data.last_func_name),\n\t\tfuncname) != 0) {\n\tsize_t len;\n\n\tif (tcov_data.last_func_name)\n\t    section_ptr_add(tcov_section, 1);\n\ttcov_data.last_func_name = tcov_section->data_offset;\n\tlen = strlen (funcname);\n\tptr = section_ptr_add(tcov_section, len + 1);\n\tstrcpy((char *)ptr, funcname);\n\tsection_ptr_add(tcov_section, -tcov_section->data_offset & 7);\n\tptr = section_ptr_add(tcov_section, 8);\n\twrite64le (ptr, file->line_num);\n    }\n    if (ind == tcov_data.ind && tcov_data.line == file->line_num)\n        tcov_data.offset = last_offset;\n    else {\n        Sym label = {0};\n        label.type.t = VT_LLONG | VT_STATIC;\n\n        ptr = section_ptr_add(tcov_section, 16);\n        tcov_data.line = file->line_num;\n        write64le (ptr, (tcov_data.line << 8) | 0xff);\n        put_extern_sym(&label, tcov_section,\n\t\t       ((unsigned char *)ptr - tcov_section->data) + 8, 0);\n        sv.type = label.type;\n        sv.r = VT_SYM | VT_LVAL | VT_CONST;\n        sv.r2 = VT_CONST;\n        sv.c.i = 0;\n        sv.sym = &label;\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || \\\n    defined TCC_TARGET_ARM || defined TCC_TARGET_ARM64 || \\\n    defined TCC_TARGET_RISCV64\n        gen_increment_tcov (&sv);\n#else\n        vpushv(&sv);\n        inc(0, TOK_INC);\n        vpop();\n#endif\n        tcov_data.offset = (unsigned char *)ptr - tcov_section->data;\n        tcov_data.ind = ind;\n    }\n}\n\nST_FUNC void tcc_tcov_block_end(TCCState *s1, int line)\n{\n    if (s1->test_coverage == 0)\n\treturn;\n    if (line == -1)\n        line = tcov_data.line;\n    if (tcov_data.offset) {\n\tvoid *ptr = tcov_section->data + tcov_data.offset;\n\tunsigned long long nline = line ? line : file->line_num;\n\n\twrite64le (ptr, (read64le (ptr) & 0xfffffffffull) | (nline << 36));\n\ttcov_data.offset = 0;\n    }\n}\n\nST_FUNC void tcc_tcov_check_line(TCCState *s1, int start)\n{\n    if (s1->test_coverage == 0)\n\treturn;\n    if (tcov_data.line != file->line_num) {\n        if ((tcov_data.line + 1) != file->line_num) {\n\t    tcc_tcov_block_end (s1, -1);\n\t    if (start)\n                tcc_tcov_block_begin (s1);\n\t}\n\telse\n\t    tcov_data.line = file->line_num;\n    }\n}\n\nST_FUNC void tcc_tcov_start(TCCState *s1)\n{\n    if (s1->test_coverage == 0)\n\treturn;\n    if (!s1->dState)\n        s1->dState = tcc_mallocz(sizeof *s1->dState);\n    memset (&tcov_data, 0, sizeof (tcov_data));\n    if (tcov_section == NULL) {\n        tcov_section = new_section(tcc_state, \".tcov\", SHT_PROGBITS,\n\t\t\t\t   SHF_ALLOC | SHF_WRITE);\n\tsection_ptr_add(tcov_section, 4); // pointer to executable name\n    }\n}\n\nST_FUNC void tcc_tcov_end(TCCState *s1)\n{\n    if (s1->test_coverage == 0)\n\treturn;\n    if (tcov_data.last_func_name)\n        section_ptr_add(tcov_section, 1);\n    if (tcov_data.last_file_name)\n        section_ptr_add(tcov_section, 1);\n}\n\nST_FUNC void tcc_tcov_reset_ind(TCCState *s1)\n{\n    tcov_data.ind = 0;\n}\n\n/* ------------------------------------------------------------------------- */\n#undef last_line_num\n#undef new_file\n#undef section_sym\n#undef debug_next_type\n#undef debug_hash\n#undef n_debug_hash\n#undef debug_anon_hash\n#undef n_debug_anon_hash\n#undef debug_info\n#undef debug_info_root\n#undef dwarf_sym\n#undef dwarf_line\n#undef dwarf_info\n#undef tcov_data\n"
        },
        {
          "name": "tccelf.c",
          "type": "blob",
          "size": 129.2626953125,
          "content": "/*\n *  ELF file handling for TCC\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"tcc.h\"\n\n/* Define this to get some debug output during relocation processing.  */\n#undef DEBUG_RELOC\n\n/********************************************************/\n/* global variables */\n\n/* elf version information */\nstruct sym_version {\n    char *lib;\n    char *version;\n    int out_index;\n    int prev_same_lib;\n};\n\n#define nb_sym_versions     s1->nb_sym_versions\n#define sym_versions        s1->sym_versions\n#define nb_sym_to_version   s1->nb_sym_to_version\n#define sym_to_version      s1->sym_to_version\n#define dt_verneednum       s1->dt_verneednum\n#define versym_section      s1->versym_section\n#define verneed_section     s1->verneed_section\n\n/* special flag to indicate that the section should not be linked to the other ones */\n#define SHF_PRIVATE 0x80000000\n/* section is dynsymtab_section */\n#define SHF_DYNSYM 0x40000000\n\n#ifdef TCC_TARGET_PE\n#define shf_RELRO SHF_ALLOC\nstatic const char rdata[] = \".rdata\";\n#else\n#define shf_RELRO SHF_ALLOC /* eventually made SHF_WRITE in sort_sections() */\nstatic const char rdata[] = \".data.ro\";\n#endif\n\n/* ------------------------------------------------------------------------- */\n\nST_FUNC void tccelf_new(TCCState *s)\n{\n    TCCState *s1 = s;\n\n    /* no section zero */\n    dynarray_add(&s->sections, &s->nb_sections, NULL);\n\n    /* create standard sections */\n    text_section = new_section(s, \".text\", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);\n    data_section = new_section(s, \".data\", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);\n    /* create ro data section (make ro after relocation done with GNU_RELRO) */\n    rodata_section = new_section(s, rdata, SHT_PROGBITS, shf_RELRO);\n    bss_section = new_section(s, \".bss\", SHT_NOBITS, SHF_ALLOC | SHF_WRITE);\n    common_section = new_section(s, \".common\", SHT_NOBITS, SHF_PRIVATE);\n    common_section->sh_num = SHN_COMMON;\n\n    /* symbols are always generated for linking stage */\n    symtab_section = new_symtab(s, \".symtab\", SHT_SYMTAB, 0,\n                                \".strtab\",\n                                \".hashtab\", SHF_PRIVATE);\n\n    /* private symbol table for dynamic symbols */\n    s->dynsymtab_section = new_symtab(s, \".dynsymtab\", SHT_SYMTAB, SHF_PRIVATE|SHF_DYNSYM,\n                                      \".dynstrtab\",\n                                      \".dynhashtab\", SHF_PRIVATE);\n    get_sym_attr(s, 0, 1);\n\n    if (s->do_debug) {\n        /* add debug sections */\n        tcc_debug_new(s);\n    }\n\n#if TCC_EH_FRAME\n    if (s->output_format != TCC_OUTPUT_FORMAT_ELF)\n        s->unwind_tables = 0;\n    tcc_eh_frame_start(s);\n#endif\n\n#ifdef CONFIG_TCC_BCHECK\n    if (s->do_bounds_check) {\n        /* if bound checking, then add corresponding sections */\n        /* (make ro after relocation done with GNU_RELRO) */\n        bounds_section = new_section(s, \".bounds\", SHT_PROGBITS, shf_RELRO);\n        lbounds_section = new_section(s, \".lbounds\", SHT_PROGBITS, shf_RELRO);\n    }\n#endif\n\n#ifdef TCC_TARGET_PE\n    /* to make sure that -ltcc1 -Wl,-e,_start will grab the startup code\n       from libtcc1.a (unless _start defined) */\n    if (s->elf_entryname)\n        set_global_sym(s, s->elf_entryname, NULL, 0); /* SHN_UNDEF */\n#endif\n}\n\nST_FUNC void free_section(Section *s)\n{\n    if (!s)\n        return;\n    tcc_free(s->data);\n    s->data = NULL;\n    s->data_allocated = s->data_offset = 0;\n}\n\nST_FUNC void tccelf_delete(TCCState *s1)\n{\n    int i;\n\n#ifndef ELF_OBJ_ONLY\n    /* free symbol versions */\n    for (i = 0; i < nb_sym_versions; i++) {\n        tcc_free(sym_versions[i].version);\n        tcc_free(sym_versions[i].lib);\n    }\n    tcc_free(sym_versions);\n    tcc_free(sym_to_version);\n#endif\n\n    /* free all sections */\n    for(i = 1; i < s1->nb_sections; i++)\n        free_section(s1->sections[i]);\n    dynarray_reset(&s1->sections, &s1->nb_sections);\n\n    for(i = 0; i < s1->nb_priv_sections; i++)\n        free_section(s1->priv_sections[i]);\n    dynarray_reset(&s1->priv_sections, &s1->nb_priv_sections);\n\n    tcc_free(s1->sym_attrs);\n    symtab_section = NULL; /* for tccrun.c:rt_printline() */\n}\n\n/* save section data state */\nST_FUNC void tccelf_begin_file(TCCState *s1)\n{\n    Section *s; int i;\n    for (i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        s->sh_offset = s->data_offset;\n    }\n    /* disable symbol hashing during compilation */\n    s = s1->symtab, s->reloc = s->hash, s->hash = NULL;\n#if defined TCC_TARGET_X86_64 && defined TCC_TARGET_PE\n    s1->uw_sym = 0;\n    s1->uw_offs = 0;\n#endif\n}\n\nstatic void update_relocs(TCCState *s1, Section *s, int *old_to_new_syms, int first_sym);\n\n/* At the end of compilation, convert any UNDEF syms to global, and merge\n   with previously existing symbols */\nST_FUNC void tccelf_end_file(TCCState *s1)\n{\n    Section *s = s1->symtab;\n    int first_sym, nb_syms, *tr, i;\n\n    first_sym = s->sh_offset / sizeof (ElfSym);\n    nb_syms = s->data_offset / sizeof (ElfSym) - first_sym;\n    s->data_offset = s->sh_offset;\n    s->link->data_offset = s->link->sh_offset;\n    s->hash = s->reloc, s->reloc = NULL;\n    tr = tcc_mallocz(nb_syms * sizeof *tr);\n\n    for (i = 0; i < nb_syms; ++i) {\n        ElfSym *sym = (ElfSym*)s->data + first_sym + i;\n        if (sym->st_shndx == SHN_UNDEF) {\n            int sym_bind = ELFW(ST_BIND)(sym->st_info);\n            int sym_type = ELFW(ST_TYPE)(sym->st_info);\n            if (sym_bind == STB_LOCAL)\n                sym_bind = STB_GLOBAL;\n#ifndef TCC_TARGET_PE\n            if (sym_bind == STB_GLOBAL && s1->output_type == TCC_OUTPUT_OBJ) {\n                /* undefined symbols with STT_FUNC are confusing gnu ld when\n                   linking statically to STT_GNU_IFUNC */\n                sym_type = STT_NOTYPE;\n            }\n#endif\n            sym->st_info = ELFW(ST_INFO)(sym_bind, sym_type);\n        }\n        tr[i] = set_elf_sym(s, sym->st_value, sym->st_size, sym->st_info,\n            sym->st_other, sym->st_shndx, (char*)s->link->data + sym->st_name);\n    }\n    /* now update relocations */\n    update_relocs(s1, s, tr, first_sym);\n    tcc_free(tr);\n    /* record text/data/bss output for -bench info */\n    for (i = 0; i < 4; ++i) {\n        s = s1->sections[i + 1];\n        s1->total_output[i] += s->data_offset - s->sh_offset;\n    }\n}\n\nST_FUNC Section *new_section(TCCState *s1, const char *name, int sh_type, int sh_flags)\n{\n    Section *sec;\n\n    sec = tcc_mallocz(sizeof(Section) + strlen(name));\n    sec->s1 = s1;\n    strcpy(sec->name, name);\n    sec->sh_type = sh_type;\n    sec->sh_flags = sh_flags;\n    switch(sh_type) {\n    case SHT_GNU_versym:\n        sec->sh_addralign = 2;\n        break;\n    case SHT_HASH:\n    case SHT_GNU_HASH:\n    case SHT_REL:\n    case SHT_RELA:\n    case SHT_DYNSYM:\n    case SHT_SYMTAB:\n    case SHT_DYNAMIC:\n    case SHT_GNU_verneed:\n    case SHT_GNU_verdef:\n        sec->sh_addralign = PTR_SIZE;\n        break;\n    case SHT_STRTAB:\n        sec->sh_addralign = 1;\n        break;\n    default:\n        sec->sh_addralign =  PTR_SIZE; /* gcc/pcc default alignment */\n        break;\n    }\n\n    if (sh_flags & SHF_PRIVATE) {\n        dynarray_add(&s1->priv_sections, &s1->nb_priv_sections, sec);\n    } else {\n        sec->sh_num = s1->nb_sections;\n        dynarray_add(&s1->sections, &s1->nb_sections, sec);\n    }\n\n    return sec;\n}\n\nST_FUNC void init_symtab(Section *s)\n{\n    int *ptr, nb_buckets = 1;\n    put_elf_str(s->link, \"\");\n    section_ptr_add(s, sizeof (ElfW(Sym)));\n    ptr = section_ptr_add(s->hash, (2 + nb_buckets + 1) * sizeof(int));\n    ptr[0] = nb_buckets;\n    ptr[1] = 1;\n    memset(ptr + 2, 0, (nb_buckets + 1) * sizeof(int));\n}\n\nST_FUNC Section *new_symtab(TCCState *s1,\n                           const char *symtab_name, int sh_type, int sh_flags,\n                           const char *strtab_name,\n                           const char *hash_name, int hash_sh_flags)\n{\n    Section *symtab, *strtab, *hash;\n    symtab = new_section(s1, symtab_name, sh_type, sh_flags);\n    symtab->sh_entsize = sizeof(ElfW(Sym));\n    strtab = new_section(s1, strtab_name, SHT_STRTAB, sh_flags);\n    symtab->link = strtab;\n    hash = new_section(s1, hash_name, SHT_HASH, hash_sh_flags);\n    hash->sh_entsize = sizeof(int);\n    symtab->hash = hash;\n    hash->link = symtab;\n    init_symtab(symtab);\n    return symtab;\n}\n\n/* realloc section and set its content to zero */\nST_FUNC void section_realloc(Section *sec, unsigned long new_size)\n{\n    unsigned long size;\n    unsigned char *data;\n\n    size = sec->data_allocated;\n    if (size == 0)\n        size = 1;\n    while (size < new_size)\n        size = size * 2;\n    data = tcc_realloc(sec->data, size);\n    memset(data + sec->data_allocated, 0, size - sec->data_allocated);\n    sec->data = data;\n    sec->data_allocated = size;\n}\n\n/* reserve at least 'size' bytes aligned per 'align' in section\n   'sec' from current offset, and return the aligned offset */\nST_FUNC size_t section_add(Section *sec, addr_t size, int align)\n{\n    size_t offset, offset1;\n\n    offset = (sec->data_offset + align - 1) & -align;\n    offset1 = offset + size;\n    if (sec->sh_type != SHT_NOBITS && offset1 > sec->data_allocated)\n        section_realloc(sec, offset1);\n    sec->data_offset = offset1;\n    if (align > sec->sh_addralign)\n        sec->sh_addralign = align;\n    return offset;\n}\n\n/* reserve at least 'size' bytes in section 'sec' from\n   sec->data_offset. */\nST_FUNC void *section_ptr_add(Section *sec, addr_t size)\n{\n    size_t offset = section_add(sec, size, 1);\n    return sec->data + offset;\n}\n\n#ifndef ELF_OBJ_ONLY\n/* reserve at least 'size' bytes from section start */\nstatic void section_reserve(Section *sec, unsigned long size)\n{\n    if (size > sec->data_allocated)\n        section_realloc(sec, size);\n    if (size > sec->data_offset)\n        sec->data_offset = size;\n}\n#endif\n\nstatic Section *have_section(TCCState *s1, const char *name)\n{\n    Section *sec;\n    int i;\n    for(i = 1; i < s1->nb_sections; i++) {\n        sec = s1->sections[i];\n        if (!strcmp(name, sec->name))\n            return sec;\n    }\n    return NULL;\n}\n\n/* return a reference to a section, and create it if it does not\n   exists */\nST_FUNC Section *find_section(TCCState *s1, const char *name)\n{\n    Section *sec = have_section(s1, name);\n    if (sec)\n        return sec;\n    /* sections are created as PROGBITS */\n    return new_section(s1, name, SHT_PROGBITS, SHF_ALLOC);\n}\n\n/* ------------------------------------------------------------------------- */\n\nST_FUNC int put_elf_str(Section *s, const char *sym)\n{\n    int offset, len;\n    char *ptr;\n\n    len = strlen(sym) + 1;\n    offset = s->data_offset;\n    ptr = section_ptr_add(s, len);\n    memmove(ptr, sym, len);\n    return offset;\n}\n\n/* elf symbol hashing function */\nstatic ElfW(Word) elf_hash(const unsigned char *name)\n{\n    ElfW(Word) h = 0, g;\n\n    while (*name) {\n        h = (h << 4) + *name++;\n        g = h & 0xf0000000;\n        if (g)\n            h ^= g >> 24;\n        h &= ~g;\n    }\n    return h;\n}\n\n/* rebuild hash table of section s */\n/* NOTE: we do factorize the hash table code to go faster */\nstatic void rebuild_hash(Section *s, unsigned int nb_buckets)\n{\n    ElfW(Sym) *sym;\n    int *ptr, *hash, nb_syms, sym_index, h;\n    unsigned char *strtab;\n\n    strtab = s->link->data;\n    nb_syms = s->data_offset / sizeof(ElfW(Sym));\n\n    if (!nb_buckets)\n        nb_buckets = ((int*)s->hash->data)[0];\n\n    s->hash->data_offset = 0;\n    ptr = section_ptr_add(s->hash, (2 + nb_buckets + nb_syms) * sizeof(int));\n    ptr[0] = nb_buckets;\n    ptr[1] = nb_syms;\n    ptr += 2;\n    hash = ptr;\n    memset(hash, 0, (nb_buckets + 1) * sizeof(int));\n    ptr += nb_buckets + 1;\n\n    sym = (ElfW(Sym) *)s->data + 1;\n    for(sym_index = 1; sym_index < nb_syms; sym_index++) {\n        if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL) {\n            h = elf_hash(strtab + sym->st_name) % nb_buckets;\n            *ptr = hash[h];\n            hash[h] = sym_index;\n        } else {\n            *ptr = 0;\n        }\n        ptr++;\n        sym++;\n    }\n}\n\n/* return the symbol number */\nST_FUNC int put_elf_sym(Section *s, addr_t value, unsigned long size,\n    int info, int other, int shndx, const char *name)\n{\n    int name_offset, sym_index;\n    int nbuckets, h;\n    ElfW(Sym) *sym;\n    Section *hs;\n\n    sym = section_ptr_add(s, sizeof(ElfW(Sym)));\n    if (name && name[0])\n        name_offset = put_elf_str(s->link, name);\n    else\n        name_offset = 0;\n    /* XXX: endianness */\n    sym->st_name = name_offset;\n    sym->st_value = value;\n    sym->st_size = size;\n    sym->st_info = info;\n    sym->st_other = other;\n    sym->st_shndx = shndx;\n    sym_index = sym - (ElfW(Sym) *)s->data;\n    hs = s->hash;\n    if (hs) {\n        int *ptr, *base;\n        ptr = section_ptr_add(hs, sizeof(int));\n        base = (int *)hs->data;\n        /* only add global or weak symbols. */\n        if (ELFW(ST_BIND)(info) != STB_LOCAL) {\n            /* add another hashing entry */\n            nbuckets = base[0];\n            h = elf_hash((unsigned char *)s->link->data + name_offset) % nbuckets;\n            *ptr = base[2 + h];\n            base[2 + h] = sym_index;\n            base[1]++;\n            /* we resize the hash table */\n            hs->nb_hashed_syms++;\n            if (hs->nb_hashed_syms > 2 * nbuckets) {\n                rebuild_hash(s, 2 * nbuckets);\n            }\n        } else {\n            *ptr = 0;\n            base[1]++;\n        }\n    }\n    return sym_index;\n}\n\nST_FUNC int find_elf_sym(Section *s, const char *name)\n{\n    ElfW(Sym) *sym;\n    Section *hs;\n    int nbuckets, sym_index, h;\n    const char *name1;\n\n    hs = s->hash;\n    if (!hs)\n        return 0;\n    nbuckets = ((int *)hs->data)[0];\n    h = elf_hash((unsigned char *) name) % nbuckets;\n    sym_index = ((int *)hs->data)[2 + h];\n    while (sym_index != 0) {\n        sym = &((ElfW(Sym) *)s->data)[sym_index];\n        name1 = (char *) s->link->data + sym->st_name;\n        if (!strcmp(name, name1))\n            return sym_index;\n        sym_index = ((int *)hs->data)[2 + nbuckets + sym_index];\n    }\n    return 0;\n}\n\n/* return elf symbol value, signal error if 'err' is nonzero, decorate\n   name if FORC */\nST_FUNC addr_t get_sym_addr(TCCState *s1, const char *name, int err, int forc)\n{\n    int sym_index;\n    ElfW(Sym) *sym;\n    char buf[256];\n    if (forc && s1->leading_underscore\n#ifdef TCC_TARGET_PE\n        /* win32-32bit stdcall symbols always have _ already */\n        && !strchr(name, '@')\n#endif\n        ) {\n        buf[0] = '_';\n        pstrcpy(buf + 1, sizeof(buf) - 1, name);\n        name = buf;\n    }\n    sym_index = find_elf_sym(s1->symtab, name);\n    sym = &((ElfW(Sym) *)s1->symtab->data)[sym_index];\n    if (!sym_index || sym->st_shndx == SHN_UNDEF) {\n        if (err)\n            tcc_error_noabort(\"%s not defined\", name);\n        return (addr_t)-1;\n    }\n    return sym->st_value;\n}\n\n/* return elf symbol value */\nLIBTCCAPI void *tcc_get_symbol(TCCState *s, const char *name)\n{\n    addr_t addr = get_sym_addr(s, name, 0, 1);\n    return addr == -1 ? NULL : (void*)(uintptr_t)addr;\n}\n\n/* list elf symbol names and values */\nST_FUNC void list_elf_symbols(TCCState *s, void *ctx,\n    void (*symbol_cb)(void *ctx, const char *name, const void *val))\n{\n    ElfW(Sym) *sym;\n    Section *symtab;\n    int sym_index, end_sym;\n    const char *name;\n    unsigned char sym_vis, sym_bind;\n\n    symtab = s->symtab;\n    end_sym = symtab->data_offset / sizeof (ElfSym);\n    for (sym_index = 0; sym_index < end_sym; ++sym_index) {\n        sym = &((ElfW(Sym) *)symtab->data)[sym_index];\n        if (sym->st_value) {\n            name = (char *) symtab->link->data + sym->st_name;\n            sym_bind = ELFW(ST_BIND)(sym->st_info);\n            sym_vis = ELFW(ST_VISIBILITY)(sym->st_other);\n            if (sym_bind == STB_GLOBAL && sym_vis == STV_DEFAULT)\n                symbol_cb(ctx, name, (void*)(uintptr_t)sym->st_value);\n        }\n    }\n}\n\n/* list elf symbol names and values */\nLIBTCCAPI void tcc_list_symbols(TCCState *s, void *ctx,\n    void (*symbol_cb)(void *ctx, const char *name, const void *val))\n{\n    list_elf_symbols(s, ctx, symbol_cb);\n}\n\n#ifndef ELF_OBJ_ONLY\nstatic void\nversion_add (TCCState *s1)\n{\n    int i;\n    ElfW(Sym) *sym;\n    ElfW(Verneed) *vn = NULL;\n    Section *symtab;\n    int sym_index, end_sym, nb_versions = 2, nb_entries = 0;\n    ElfW(Half) *versym;\n    const char *name;\n\n    if (0 == nb_sym_versions)\n        return;\n    versym_section = new_section(s1, \".gnu.version\", SHT_GNU_versym, SHF_ALLOC);\n    versym_section->sh_entsize = sizeof(ElfW(Half));\n    versym_section->link = s1->dynsym;\n\n    /* add needed symbols */\n    symtab = s1->dynsym;\n    end_sym = symtab->data_offset / sizeof (ElfSym);\n    versym = section_ptr_add(versym_section, end_sym * sizeof(ElfW(Half)));\n    for (sym_index = 1; sym_index < end_sym; ++sym_index) {\n        int dllindex, verndx;\n        sym = &((ElfW(Sym) *)symtab->data)[sym_index];\n        name = (char *) symtab->link->data + sym->st_name;\n        dllindex = find_elf_sym(s1->dynsymtab_section, name);\n        verndx = (dllindex && dllindex < nb_sym_to_version)\n                 ? sym_to_version[dllindex] : -1;\n        if (verndx >= 0\n            /* XXX: on android, clang refuses to link with a libtcc.so made by tcc\n               when defined symbols have a version > 1 or when the version is '0'.\n               Whereas version '1' for example for 'signal' in an exe defeats\n               bcheck's signal_redir. */\n            && (sym->st_shndx == SHN_UNDEF || (s1->output_type & TCC_OUTPUT_EXE))\n            ) {\n            if (!sym_versions[verndx].out_index)\n              sym_versions[verndx].out_index = nb_versions++;\n            versym[sym_index] = sym_versions[verndx].out_index;\n        } else {\n            versym[sym_index] = 1; /* (*global*) */\n        }\n        //printf(\"SYM %d %s\\n\", versym[sym_index], name);\n    }\n    /* generate verneed section, but not when it will be empty.  Some\n       dynamic linkers look at their contents even when DTVERNEEDNUM and\n       section size is zero.  */\n    if (nb_versions > 2) {\n        verneed_section = new_section(s1, \".gnu.version_r\",\n                                      SHT_GNU_verneed, SHF_ALLOC);\n        verneed_section->link = s1->dynsym->link;\n        for (i = nb_sym_versions; i-- > 0;) {\n            struct sym_version *sv = &sym_versions[i];\n            int n_same_libs = 0, prev;\n            size_t vnofs;\n            ElfW(Vernaux) *vna = 0;\n            if (sv->out_index < 1)\n              continue;\n\n            /* make sure that a DT_NEEDED tag is put */\n            /* abitest-tcc fails on older i386-linux with \"ld-linux.so.2\" DT_NEEDED\n               ret_int_test... Inconsistency detected by ld.so: dl-minimal.c: 148:\n               realloc: Assertion `ptr == alloc_last_block' failed! */\n            if (strcmp(sv->lib, \"ld-linux.so.2\"))\n                tcc_add_dllref(s1, sv->lib, 0);\n\n            vnofs = section_add(verneed_section, sizeof(*vn), 1);\n            vn = (ElfW(Verneed)*)(verneed_section->data + vnofs);\n            vn->vn_version = 1;\n            vn->vn_file = put_elf_str(verneed_section->link, sv->lib);\n            vn->vn_aux = sizeof (*vn);\n            do {\n                prev = sv->prev_same_lib;\n                if (sv->out_index > 0) {\n                    vna = section_ptr_add(verneed_section, sizeof(*vna));\n                    vna->vna_hash = elf_hash ((const unsigned char *)sv->version);\n                    vna->vna_flags = 0;\n                    vna->vna_other = sv->out_index;\n                    sv->out_index = -2;\n                    vna->vna_name = put_elf_str(verneed_section->link, sv->version);\n                    vna->vna_next = sizeof (*vna);\n                    //printf(\"LIB %d %s %s\\n\", vna->vna_other, sv->lib, verneed_section->link->data + vna->vna_name);\n                    n_same_libs++;\n                }\n                if (prev >= 0)\n                  sv = &sym_versions[prev];\n            } while(prev >= 0);\n            vna->vna_next = 0;\n            vn = (ElfW(Verneed)*)(verneed_section->data + vnofs);\n            vn->vn_cnt = n_same_libs;\n            vn->vn_next = sizeof(*vn) + n_same_libs * sizeof(*vna);\n            nb_entries++;\n        }\n        if (vn)\n          vn->vn_next = 0;\n        verneed_section->sh_info = nb_entries;\n    }\n    dt_verneednum = nb_entries;\n}\n#endif /* ndef ELF_OBJ_ONLY */\n\n/* add an elf symbol : check if it is already defined and patch\n   it. Return symbol index. NOTE that sh_num can be SHN_UNDEF. */\nST_FUNC int set_elf_sym(Section *s, addr_t value, unsigned long size,\n                       int info, int other, int shndx, const char *name)\n{\n    TCCState *s1 = s->s1;\n    ElfW(Sym) *esym;\n    int sym_bind, sym_index, sym_type, esym_bind;\n    unsigned char sym_vis, esym_vis, new_vis;\n\n    sym_bind = ELFW(ST_BIND)(info);\n    sym_type = ELFW(ST_TYPE)(info);\n    sym_vis = ELFW(ST_VISIBILITY)(other);\n\n    if (sym_bind != STB_LOCAL) {\n        /* we search global or weak symbols */\n        sym_index = find_elf_sym(s, name);\n        if (!sym_index)\n            goto do_def;\n        esym = &((ElfW(Sym) *)s->data)[sym_index];\n        if (esym->st_value == value && esym->st_size == size && esym->st_info == info\n            && esym->st_other == other && esym->st_shndx == shndx)\n            return sym_index;\n        if (esym->st_shndx != SHN_UNDEF) {\n            esym_bind = ELFW(ST_BIND)(esym->st_info);\n            /* propagate the most constraining visibility */\n            /* STV_DEFAULT(0)<STV_PROTECTED(3)<STV_HIDDEN(2)<STV_INTERNAL(1) */\n            esym_vis = ELFW(ST_VISIBILITY)(esym->st_other);\n            if (esym_vis == STV_DEFAULT) {\n                new_vis = sym_vis;\n            } else if (sym_vis == STV_DEFAULT) {\n                new_vis = esym_vis;\n            } else {\n                new_vis = (esym_vis < sym_vis) ? esym_vis : sym_vis;\n            }\n            esym->st_other = (esym->st_other & ~ELFW(ST_VISIBILITY)(-1))\n                             | new_vis;\n            if (shndx == SHN_UNDEF) {\n                /* ignore adding of undefined symbol if the\n                   corresponding symbol is already defined */\n            } else if (sym_bind == STB_GLOBAL && esym_bind == STB_WEAK) {\n                /* global overrides weak, so patch */\n                goto do_patch;\n            } else if (sym_bind == STB_WEAK && esym_bind == STB_GLOBAL) {\n                /* weak is ignored if already global */\n            } else if (sym_bind == STB_WEAK && esym_bind == STB_WEAK) {\n                /* keep first-found weak definition, ignore subsequents */\n            } else if (sym_vis == STV_HIDDEN || sym_vis == STV_INTERNAL) {\n                /* ignore hidden symbols after */\n            } else if ((esym->st_shndx == SHN_COMMON\n                            || esym->st_shndx == bss_section->sh_num)\n                        && (shndx < SHN_LORESERVE\n                            && shndx != bss_section->sh_num)) {\n                /* data symbol gets precedence over common/bss */\n                goto do_patch;\n            } else if (shndx == SHN_COMMON || shndx == bss_section->sh_num) {\n                /* data symbol keeps precedence over common/bss */\n            } else if (s->sh_flags & SHF_DYNSYM) {\n                /* we accept that two DLL define the same symbol */\n\t    } else if (esym->st_other & ST_ASM_SET) {\n\t\t/* If the existing symbol came from an asm .set\n\t\t   we can override.  */\n\t\tgoto do_patch;\n            } else {\n#if 0\n                printf(\"new_bind=%x new_shndx=%x new_vis=%x old_bind=%x old_shndx=%x old_vis=%x\\n\",\n                       sym_bind, shndx, new_vis, esym_bind, esym->st_shndx, esym_vis);\n#endif\n                tcc_error_noabort(\"'%s' defined twice\", name);\n            }\n        } else {\n            esym->st_other = other;\n        do_patch:\n            esym->st_info = ELFW(ST_INFO)(sym_bind, sym_type);\n            esym->st_shndx = shndx;\n            s1->new_undef_sym = 1;\n            esym->st_value = value;\n            esym->st_size = size;\n        }\n    } else {\n    do_def:\n        sym_index = put_elf_sym(s, value, size,\n                                ELFW(ST_INFO)(sym_bind, sym_type), other,\n                                shndx, name);\n    }\n    return sym_index;\n}\n\n/* put relocation */\nST_FUNC void put_elf_reloca(Section *symtab, Section *s, unsigned long offset,\n                            int type, int symbol, addr_t addend)\n{\n    TCCState *s1 = s->s1;\n    char buf[256];\n    Section *sr;\n    ElfW_Rel *rel;\n\n    sr = s->reloc;\n    if (!sr) {\n        /* if no relocation section, create it */\n        snprintf(buf, sizeof(buf), REL_SECTION_FMT, s->name);\n        /* if the symtab is allocated, then we consider the relocation\n           are also */\n        sr = new_section(s->s1, buf, SHT_RELX, symtab->sh_flags);\n        sr->sh_entsize = sizeof(ElfW_Rel);\n        sr->link = symtab;\n        sr->sh_info = s->sh_num;\n        s->reloc = sr;\n    }\n    rel = section_ptr_add(sr, sizeof(ElfW_Rel));\n    rel->r_offset = offset;\n    rel->r_info = ELFW(R_INFO)(symbol, type);\n#if SHT_RELX == SHT_RELA\n    rel->r_addend = addend;\n#endif\n    if (SHT_RELX != SHT_RELA && addend)\n        tcc_error_noabort(\"non-zero addend on REL architecture\");\n}\n\nST_FUNC void put_elf_reloc(Section *symtab, Section *s, unsigned long offset,\n                           int type, int symbol)\n{\n    put_elf_reloca(symtab, s, offset, type, symbol, 0);\n}\n\nST_FUNC struct sym_attr *get_sym_attr(TCCState *s1, int index, int alloc)\n{\n    int n;\n    struct sym_attr *tab;\n\n    if (index >= s1->nb_sym_attrs) {\n        if (!alloc)\n            return s1->sym_attrs;\n        /* find immediately bigger power of 2 and reallocate array */\n        n = 1;\n        while (index >= n)\n            n *= 2;\n        tab = tcc_realloc(s1->sym_attrs, n * sizeof(*s1->sym_attrs));\n        s1->sym_attrs = tab;\n        memset(s1->sym_attrs + s1->nb_sym_attrs, 0,\n               (n - s1->nb_sym_attrs) * sizeof(*s1->sym_attrs));\n        s1->nb_sym_attrs = n;\n    }\n    return &s1->sym_attrs[index];\n}\n\nstatic void update_relocs(TCCState *s1, Section *s, int *old_to_new_syms, int first_sym)\n{\n    int i, type, sym_index;\n    Section *sr;\n    ElfW_Rel *rel;\n\n    for(i = 1; i < s1->nb_sections; i++) {\n        sr = s1->sections[i];\n        if (sr->sh_type == SHT_RELX && sr->link == s) {\n            for_each_elem(sr, 0, rel, ElfW_Rel) {\n                sym_index = ELFW(R_SYM)(rel->r_info);\n                type = ELFW(R_TYPE)(rel->r_info);\n                if ((sym_index -= first_sym) < 0)\n                    continue; /* zero sym_index in reloc (can happen with asm) */\n                sym_index = old_to_new_syms[sym_index];\n                rel->r_info = ELFW(R_INFO)(sym_index, type);\n            }\n        }\n    }\n}\n\n/* In an ELF file symbol table, the local symbols must appear below\n   the global and weak ones. Since TCC cannot sort it while generating\n   the code, we must do it after. All the relocation tables are also\n   modified to take into account the symbol table sorting */\nstatic void sort_syms(TCCState *s1, Section *s)\n{\n    int *old_to_new_syms;\n    ElfW(Sym) *new_syms;\n    int nb_syms, i;\n    ElfW(Sym) *p, *q;\n\n    nb_syms = s->data_offset / sizeof(ElfW(Sym));\n    new_syms = tcc_malloc(nb_syms * sizeof(ElfW(Sym)));\n    old_to_new_syms = tcc_malloc(nb_syms * sizeof(int));\n\n    /* first pass for local symbols */\n    p = (ElfW(Sym) *)s->data;\n    q = new_syms;\n    for(i = 0; i < nb_syms; i++) {\n        if (ELFW(ST_BIND)(p->st_info) == STB_LOCAL) {\n            old_to_new_syms[i] = q - new_syms;\n            *q++ = *p;\n        }\n        p++;\n    }\n    /* save the number of local symbols in section header */\n    if( s->sh_size )    /* this 'if' makes IDA happy */\n        s->sh_info = q - new_syms;\n\n    /* then second pass for non local symbols */\n    p = (ElfW(Sym) *)s->data;\n    for(i = 0; i < nb_syms; i++) {\n        if (ELFW(ST_BIND)(p->st_info) != STB_LOCAL) {\n            old_to_new_syms[i] = q - new_syms;\n            *q++ = *p;\n        }\n        p++;\n    }\n\n    /* we copy the new symbols to the old */\n    memcpy(s->data, new_syms, nb_syms * sizeof(ElfW(Sym)));\n    tcc_free(new_syms);\n\n    update_relocs(s1, s, old_to_new_syms, 0);\n    tcc_free(old_to_new_syms);\n}\n\n#ifndef ELF_OBJ_ONLY\n/* See: https://flapenguin.me/elf-dt-gnu-hash */\n#define\tELFCLASS_BITS (PTR_SIZE * 8)\n\nstatic Section *create_gnu_hash(TCCState *s1)\n{\n    int nb_syms, i, ndef, nbuckets, symoffset, bloom_size, bloom_shift;\n    ElfW(Sym) *p;\n    Section *gnu_hash;\n    Section *dynsym = s1->dynsym;\n    Elf32_Word *ptr;\n\n    gnu_hash = new_section(s1, \".gnu.hash\", SHT_GNU_HASH, SHF_ALLOC);\n    gnu_hash->link = dynsym->hash->link;\n\n    nb_syms = dynsym->data_offset / sizeof(ElfW(Sym));\n\n    /* count def symbols */\n    ndef = 0;\n    p = (ElfW(Sym) *)dynsym->data;\n    for(i = 0; i < nb_syms; i++, p++)\n        ndef += p->st_shndx != SHN_UNDEF;\n\n    /* calculate gnu hash sizes and fill header */\n    nbuckets = ndef / 4 + 1;\n    symoffset = nb_syms - ndef;\n    bloom_shift = PTR_SIZE == 8 ? 6 : 5;\n    bloom_size = 1; /* must be power of two */\n    while (ndef >= bloom_size * (1 << (bloom_shift - 3)))\n\tbloom_size *= 2;\n    ptr = section_ptr_add(gnu_hash, 4 * 4 +\n\t\t\t\t    PTR_SIZE * bloom_size +\n\t\t\t\t    nbuckets * 4 +\n\t\t\t\t    ndef * 4);\n    ptr[0] = nbuckets;\n    ptr[1] = symoffset;\n    ptr[2] = bloom_size;\n    ptr[3] = bloom_shift;\n    return gnu_hash;\n}\n\nstatic Elf32_Word elf_gnu_hash (const unsigned char *name)\n{\n    Elf32_Word h = 5381;\n    unsigned char c;\n\n    while ((c = *name++))\n        h = h * 33 + c;\n    return h;\n}\n\nstatic void update_gnu_hash(TCCState *s1, Section *gnu_hash)\n{\n    int *old_to_new_syms;\n    ElfW(Sym) *new_syms;\n    int nb_syms, i, nbuckets, bloom_size, bloom_shift;\n    ElfW(Sym) *p, *q;\n    Section *vs;\n    Section *dynsym = s1->dynsym;\n    Elf32_Word *ptr, *buckets, *chain, *hash;\n    unsigned int *nextbuck;\n    addr_t *bloom;\n    unsigned char *strtab;\n    struct { int first, last; } *buck;\n\n    strtab = dynsym->link->data;\n    nb_syms = dynsym->data_offset / sizeof(ElfW(Sym));\n    new_syms = tcc_malloc(nb_syms * sizeof(ElfW(Sym)));\n    old_to_new_syms = tcc_malloc(nb_syms * sizeof(int));\n    hash = tcc_malloc(nb_syms * sizeof(Elf32_Word));\n    nextbuck = tcc_malloc(nb_syms * sizeof(int));\n\n    /* calculate hashes and copy undefs */\n    p = (ElfW(Sym) *)dynsym->data;\n    q = new_syms;\n    for(i = 0; i < nb_syms; i++, p++) {\n        if (p->st_shndx == SHN_UNDEF) {\n            old_to_new_syms[i] = q - new_syms;\n            *q++ = *p;\n        }\n\telse\n\t    hash[i] = elf_gnu_hash(strtab + p->st_name);\n    }\n\n    ptr = (Elf32_Word *) gnu_hash->data;\n    nbuckets = ptr[0];\n    bloom_size = ptr[2];\n    bloom_shift = ptr[3];\n    bloom = (addr_t *) (void *) &ptr[4];\n    buckets = (Elf32_Word*) (void *) &bloom[bloom_size];\n    chain = &buckets[nbuckets];\n    buck = tcc_malloc(nbuckets * sizeof(*buck));\n\n    if (gnu_hash->data_offset != 4 * 4 +\n\t\t\t\t PTR_SIZE * bloom_size +\n\t\t\t\t nbuckets * 4 +\n\t\t\t\t (nb_syms - (q - new_syms)) * 4)\n\ttcc_error_noabort (\"gnu_hash size incorrect\");\n\n    /* find buckets */\n    for(i = 0; i < nbuckets; i++)\n\tbuck[i].first = -1;\n\n    p = (ElfW(Sym) *)dynsym->data;\n    for(i = 0; i < nb_syms; i++, p++)\n        if (p->st_shndx != SHN_UNDEF) {\n\t    int bucket = hash[i] % nbuckets;\n\n\t    if (buck[bucket].first == -1)\n\t\tbuck[bucket].first = buck[bucket].last = i;\n\t    else {\n\t\tnextbuck[buck[bucket].last] = i;\n\t\tbuck[bucket].last = i;\n\t    }\n\t}\n\n    /* fill buckets/chains/bloom and sort symbols */\n    p = (ElfW(Sym) *)dynsym->data;\n    for(i = 0; i < nbuckets; i++) {\n\tint cur = buck[i].first;\n\n\tif (cur != -1) {\n\t    buckets[i] = q - new_syms;\n\t    for (;;) {\n                old_to_new_syms[cur] = q - new_syms;\n                *q++ = p[cur];\n\t        *chain++ = hash[cur] & ~1;\n\t\tbloom[(hash[cur] / ELFCLASS_BITS) % bloom_size] |=\n\t\t    (addr_t)1 << (hash[cur] % ELFCLASS_BITS) |\n\t\t    (addr_t)1 << ((hash[cur] >> bloom_shift) % ELFCLASS_BITS);\n\t\tif (cur == buck[i].last)\n\t\t    break;\n\t\tcur = nextbuck[cur];\n\t    }\n\t    chain[-1] |= 1;\n\t}\n    }\n\n    memcpy(dynsym->data, new_syms, nb_syms * sizeof(ElfW(Sym)));\n    tcc_free(new_syms);\n    tcc_free(hash);\n    tcc_free(buck);\n    tcc_free(nextbuck);\n\n    update_relocs(s1, dynsym, old_to_new_syms, 0);\n\n    /* modify the versions */\n    vs = versym_section;\n    if (vs) {\n\tElfW(Half) *newver, *versym = (ElfW(Half) *)vs->data;\n\n\tif (1/*versym*/) {\n            newver = tcc_malloc(nb_syms * sizeof(*newver));\n\t    for (i = 0; i < nb_syms; i++)\n\t        newver[old_to_new_syms[i]] = versym[i];\n\t    memcpy(vs->data, newver, nb_syms * sizeof(*newver));\n\t    tcc_free(newver);\n\t}\n    }\n\n    tcc_free(old_to_new_syms);\n\n    /* rebuild hash */\n    ptr = (Elf32_Word *) dynsym->hash->data;\n    rebuild_hash(dynsym, ptr[0]);\n}\n#endif /* ELF_OBJ_ONLY */\n\n/* relocate symbol table, resolve undefined symbols if do_resolve is\n   true and output error if undefined symbol. */\nST_FUNC void relocate_syms(TCCState *s1, Section *symtab, int do_resolve)\n{\n    ElfW(Sym) *sym;\n    int sym_bind, sh_num;\n    const char *name;\n\n    for_each_elem(symtab, 1, sym, ElfW(Sym)) {\n        sh_num = sym->st_shndx;\n        if (sh_num == SHN_UNDEF) {\n            if (do_resolve == 2) /* relocating dynsym */\n                continue;\n            name = (char *) s1->symtab->link->data + sym->st_name;\n            /* Use ld.so to resolve symbol for us (for tcc -run) */\n            if (do_resolve) {\n#if defined TCC_IS_NATIVE && !defined TCC_TARGET_PE\n                /* dlsym() needs the undecorated name.  */\n                void *addr = dlsym(RTLD_DEFAULT, &name[s1->leading_underscore]);\n#if TARGETOS_OpenBSD || TARGETOS_FreeBSD || TARGETOS_NetBSD || TARGETOS_ANDROID\n\t\tif (addr == NULL) {\n\t\t    int i;\n\t\t    for (i = 0; i < s1->nb_loaded_dlls; i++)\n                        if ((addr = dlsym(s1->loaded_dlls[i]->handle, name)))\n\t\t\t    break;\n\t\t}\n#endif\n                if (addr) {\n                    sym->st_value = (addr_t) addr;\n#ifdef DEBUG_RELOC\n\t\t    printf (\"relocate_sym: %s -> 0x%lx\\n\", name, sym->st_value);\n#endif\n                    goto found;\n                }\n#endif\n            /* if dynamic symbol exist, it will be used in relocate_section */\n            } else if (s1->dynsym && find_elf_sym(s1->dynsym, name))\n                goto found;\n            /* XXX: _fp_hw seems to be part of the ABI, so we ignore\n               it */\n            if (!strcmp(name, \"_fp_hw\"))\n                goto found;\n            /* only weak symbols are accepted to be undefined. Their\n               value is zero */\n            sym_bind = ELFW(ST_BIND)(sym->st_info);\n            if (sym_bind == STB_WEAK)\n                sym->st_value = 0;\n            else\n                tcc_error_noabort(\"undefined symbol '%s'\", name);\n\n        } else if (sh_num < SHN_LORESERVE) {\n            /* add section base */\n            sym->st_value += s1->sections[sym->st_shndx]->sh_addr;\n        }\n    found: ;\n    }\n}\n\n/* relocate a given section (CPU dependent) by applying the relocations\n   in the associated relocation section */\nstatic void relocate_section(TCCState *s1, Section *s, Section *sr)\n{\n    ElfW_Rel *rel;\n    ElfW(Sym) *sym;\n    int type, sym_index;\n    unsigned char *ptr;\n    addr_t tgt, addr;\n    int is_dwarf = s->sh_num >= s1->dwlo && s->sh_num < s1->dwhi;\n\n    qrel = (ElfW_Rel *)sr->data;\n    for_each_elem(sr, 0, rel, ElfW_Rel) {\n        ptr = s->data + rel->r_offset;\n        sym_index = ELFW(R_SYM)(rel->r_info);\n        sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n        type = ELFW(R_TYPE)(rel->r_info);\n        tgt = sym->st_value;\n#if SHT_RELX == SHT_RELA\n        tgt += rel->r_addend;\n#endif\n        if (is_dwarf && type == R_DATA_32DW\n            && sym->st_shndx >= s1->dwlo && sym->st_shndx < s1->dwhi) {\n            /* dwarf section relocation to each other */\n            add32le(ptr, tgt - s1->sections[sym->st_shndx]->sh_addr);\n            continue;\n        }\n        addr = s->sh_addr + rel->r_offset;\n        relocate(s1, rel, type, ptr, addr, tgt);\n    }\n#ifndef ELF_OBJ_ONLY\n    /* if the relocation is allocated, we change its symbol table */\n    if (sr->sh_flags & SHF_ALLOC) {\n        sr->link = s1->dynsym;\n        if (s1->output_type & TCC_OUTPUT_DYN) {\n            size_t r = (uint8_t*)qrel - sr->data;\n            if (sizeof ((Stab_Sym*)0)->n_value < PTR_SIZE\n                && 0 == strcmp(s->name, \".stab\"))\n                r = 0; /* cannot apply 64bit relocation to 32bit value */\n            sr->data_offset = sr->sh_size = r;\n#ifdef CONFIG_TCC_PIE\n            if (r && (s->sh_flags & SHF_EXECINSTR))\n                tcc_warning(\"%d relocations to %s\", (unsigned)(r / sizeof *qrel), s->name);\n#endif\n        }\n    }\n#endif\n}\n\n/* relocate all sections */\nST_FUNC void relocate_sections(TCCState *s1)\n{\n    int i;\n    Section *s, *sr;\n\n    for (i = 1; i < s1->nb_sections; ++i) {\n        sr = s1->sections[i];\n        if (sr->sh_type != SHT_RELX)\n            continue;\n        s = s1->sections[sr->sh_info];\n#ifndef TCC_TARGET_MACHO\n        if (s != s1->got\n            || s1->static_link\n            || s1->output_type == TCC_OUTPUT_MEMORY)\n#endif\n        {\n            relocate_section(s1, s, sr);\n        }\n#ifndef ELF_OBJ_ONLY\n        if (sr->sh_flags & SHF_ALLOC) {\n            ElfW_Rel *rel;\n            /* relocate relocation table in 'sr' */\n            for_each_elem(sr, 0, rel, ElfW_Rel)\n                rel->r_offset += s->sh_addr;\n        }\n#endif\n    }\n}\n\n#ifndef ELF_OBJ_ONLY\n/* count the number of dynamic relocations so that we can reserve\n   their space */\nstatic int prepare_dynamic_rel(TCCState *s1, Section *sr)\n{\n    int count = 0;\n#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64) || \\\n    defined(TCC_TARGET_ARM) || defined(TCC_TARGET_ARM64) || \\\n    defined(TCC_TARGET_RISCV64)\n    ElfW_Rel *rel;\n    for_each_elem(sr, 0, rel, ElfW_Rel) {\n        int sym_index = ELFW(R_SYM)(rel->r_info);\n        int type = ELFW(R_TYPE)(rel->r_info);\n        switch(type) {\n#if defined(TCC_TARGET_I386)\n        case R_386_32:\n            if (!get_sym_attr(s1, sym_index, 0)->dyn_index\n                && ((ElfW(Sym)*)symtab_section->data + sym_index)->st_shndx == SHN_UNDEF) {\n                /* don't fixup unresolved (weak) symbols */\n                rel->r_info = ELFW(R_INFO)(sym_index, R_386_RELATIVE);\n                break;\n            }\n#elif defined(TCC_TARGET_X86_64)\n        case R_X86_64_32:\n        case R_X86_64_32S:\n        case R_X86_64_64:\n#elif defined(TCC_TARGET_ARM)\n        case R_ARM_ABS32:\n        case R_ARM_TARGET1:\n#elif defined(TCC_TARGET_ARM64)\n        case R_AARCH64_ABS32:\n        case R_AARCH64_ABS64:\n#elif defined(TCC_TARGET_RISCV64)\n        case R_RISCV_32:\n        case R_RISCV_64:\n#endif\n            count++;\n            break;\n#if defined(TCC_TARGET_I386)\n        case R_386_PC32:\n#elif defined(TCC_TARGET_X86_64)\n        case R_X86_64_PC32:\n\t{\n\t    ElfW(Sym) *sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n            /* Hidden defined symbols can and must be resolved locally.\n               We're misusing a PLT32 reloc for this, as that's always\n               resolved to its address even in shared libs.  */\n\t    if (sym->st_shndx != SHN_UNDEF &&\n\t\tELFW(ST_VISIBILITY)(sym->st_other) == STV_HIDDEN) {\n                rel->r_info = ELFW(R_INFO)(sym_index, R_X86_64_PLT32);\n\t        break;\n\t    }\n\t}\n#elif defined(TCC_TARGET_ARM64)\n        case R_AARCH64_PREL32:\n#endif\n            if (s1->output_type != TCC_OUTPUT_DLL)\n                break;\n            if (get_sym_attr(s1, sym_index, 0)->dyn_index)\n                count++;\n            break;\n        default:\n            break;\n        }\n    }\n#endif\n    return count;\n}\n#endif\n\n#ifdef NEED_BUILD_GOT\nstatic int build_got(TCCState *s1)\n{\n    /* if no got, then create it */\n    s1->got = new_section(s1, \".got\", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);\n    s1->got->sh_entsize = 4;\n    /* keep space for _DYNAMIC pointer and two dummy got entries */\n    section_ptr_add(s1->got, 3 * PTR_SIZE);\n    return set_elf_sym(symtab_section, 0, 0, ELFW(ST_INFO)(STB_GLOBAL, STT_OBJECT),\n        0, s1->got->sh_num, \"_GLOBAL_OFFSET_TABLE_\");\n}\n\n/* Create a GOT and (for function call) a PLT entry corresponding to a symbol\n   in s1->symtab. When creating the dynamic symbol table entry for the GOT\n   relocation, use 'size' and 'info' for the corresponding symbol metadata.\n   Returns the offset of the GOT or (if any) PLT entry. */\nstatic struct sym_attr * put_got_entry(TCCState *s1, int dyn_reloc_type,\n                                       int sym_index)\n{\n    int need_plt_entry;\n    const char *name;\n    ElfW(Sym) *sym;\n    struct sym_attr *attr;\n    unsigned got_offset;\n    char plt_name[200];\n    int len;\n    Section *s_rel;\n\n    need_plt_entry = (dyn_reloc_type == R_JMP_SLOT);\n    attr = get_sym_attr(s1, sym_index, 1);\n\n    /* In case a function is both called and its address taken 2 GOT entries\n       are created, one for taking the address (GOT) and the other for the PLT\n       entry (PLTGOT).  */\n    if (need_plt_entry ? attr->plt_offset : attr->got_offset)\n        return attr;\n\n    s_rel = s1->got;\n    if (need_plt_entry) {\n        if (!s1->plt) {\n            s1->plt = new_section(s1, \".plt\", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);\n            s1->plt->sh_entsize = 4;\n        }\n        s_rel = s1->plt;\n    }\n\n    /* create the GOT entry */\n    got_offset = s1->got->data_offset;\n    section_ptr_add(s1->got, PTR_SIZE);\n\n    /* Create the GOT relocation that will insert the address of the object or\n       function of interest in the GOT entry. This is a static relocation for\n       memory output (dlsym will give us the address of symbols) and dynamic\n       relocation otherwise (executable and DLLs). The relocation should be\n       done lazily for GOT entry with *_JUMP_SLOT relocation type (the one\n       associated to a PLT entry) but is currently done at load time for an\n       unknown reason. */\n\n    sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];\n    name = (char *) symtab_section->link->data + sym->st_name;\n    //printf(\"sym %d %s\\n\", need_plt_entry, name);\n\n    if (s1->dynsym) {\n\tif (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL) {\n\t    /* Hack alarm.  We don't want to emit dynamic symbols\n\t       and symbol based relocs for STB_LOCAL symbols, but rather\n\t       want to resolve them directly.  At this point the symbol\n\t       values aren't final yet, so we must defer this.  We will later\n\t       have to create a RELATIVE reloc anyway, so we misuse the\n\t       relocation slot to smuggle the symbol reference until\n\t       fill_local_got_entries.  Not that the sym_index is\n\t       relative to symtab_section, not s1->dynsym!  Nevertheless\n\t       we use s1->dyn_sym so that if this is the first call\n\t       that got->reloc is correctly created.  Also note that\n\t       RELATIVE relocs are not normally created for the .got,\n\t       so the types serves as a marker for later (and is retained\n\t       also for the final output, which is okay because then the\n\t       got is just normal data).  */\n\t    put_elf_reloc(s1->dynsym, s1->got, got_offset, R_RELATIVE,\n\t\t\t  sym_index);\n\t} else {\n\t    if (0 == attr->dyn_index)\n                attr->dyn_index = set_elf_sym(s1->dynsym, sym->st_value,\n                                              sym->st_size, sym->st_info, 0,\n                                              sym->st_shndx, name);\n\t    put_elf_reloc(s1->dynsym, s_rel, got_offset, dyn_reloc_type,\n\t\t\t  attr->dyn_index);\n\t}\n    } else {\n        put_elf_reloc(symtab_section, s1->got, got_offset, dyn_reloc_type,\n                      sym_index);\n    }\n\n    if (need_plt_entry) {\n        attr->plt_offset = create_plt_entry(s1, got_offset, attr);\n\n        /* create a symbol 'sym@plt' for the PLT jump vector */\n        len = strlen(name);\n        if (len > sizeof plt_name - 5)\n            len = sizeof plt_name - 5;\n        memcpy(plt_name, name, len);\n        strcpy(plt_name + len, \"@plt\");\n        attr->plt_sym = put_elf_sym(s1->symtab, attr->plt_offset, 0,\n            ELFW(ST_INFO)(STB_GLOBAL, STT_FUNC), 0, s1->plt->sh_num, plt_name);\n    } else {\n        attr->got_offset = got_offset;\n    }\n\n    return attr;\n}\n\n/* build GOT and PLT entries */\n/* Two passes because R_JMP_SLOT should become first. Some targets\n   (arm, arm64) do not allow mixing R_JMP_SLOT and R_GLOB_DAT. */\nST_FUNC void build_got_entries(TCCState *s1, int got_sym)\n{\n    Section *s;\n    ElfW_Rel *rel;\n    ElfW(Sym) *sym;\n    int i, type, gotplt_entry, reloc_type, sym_index;\n    struct sym_attr *attr;\n    int pass = 0;\nredo:\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_RELX)\n            continue;\n        /* no need to handle got relocations */\n        if (s->link != symtab_section)\n            continue;\n        for_each_elem(s, 0, rel, ElfW_Rel) {\n            type = ELFW(R_TYPE)(rel->r_info);\n            gotplt_entry = gotplt_entry_type(type);\n            if (gotplt_entry == -1) {\n                tcc_error_noabort (\"Unknown relocation type for got: %d\", type);\n                continue;\n            }\n            sym_index = ELFW(R_SYM)(rel->r_info);\n            sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\n            if (gotplt_entry == NO_GOTPLT_ENTRY) {\n                continue;\n            }\n\n            /* Automatically create PLT/GOT [entry] if it is an undefined\n\t       reference (resolved at runtime), or the symbol is absolute,\n\t       probably created by tcc_add_symbol, and thus on 64-bit\n\t       targets might be too far from application code.  */\n            if (gotplt_entry == AUTO_GOTPLT_ENTRY) {\n                if (sym->st_shndx == SHN_UNDEF) {\n                    ElfW(Sym) *esym;\n\t\t    int dynindex;\n                    if (!PCRELATIVE_DLLPLT\n                        && (s1->output_type & TCC_OUTPUT_DYN))\n                        continue;\n\t\t    /* Relocations for UNDEF symbols would normally need\n\t\t       to be transferred into the executable or shared object.\n\t\t       If that were done AUTO_GOTPLT_ENTRY wouldn't exist.\n\t\t       But TCC doesn't do that (at least for exes), so we\n\t\t       need to resolve all such relocs locally.  And that\n\t\t       means PLT slots for functions in DLLs and COPY relocs for\n\t\t       data symbols.  COPY relocs were generated in\n\t\t       bind_exe_dynsyms (and the symbol adjusted to be defined),\n\t\t       and for functions we were generated a dynamic symbol\n\t\t       of function type.  */\n\t\t    if (s1->dynsym) {\n\t\t\t/* dynsym isn't set for -run :-/  */\n\t\t\tdynindex = get_sym_attr(s1, sym_index, 0)->dyn_index;\n\t\t\tesym = (ElfW(Sym) *)s1->dynsym->data + dynindex;\n\t\t\tif (dynindex\n\t\t\t    && (ELFW(ST_TYPE)(esym->st_info) == STT_FUNC\n\t\t\t\t|| (ELFW(ST_TYPE)(esym->st_info) == STT_NOTYPE\n\t\t\t\t    && ELFW(ST_TYPE)(sym->st_info) == STT_FUNC)))\n\t\t\t    goto jmp_slot;\n\t\t    }\n                } else if (sym->st_shndx == SHN_ABS) {\n                    if (sym->st_value == 0) /* from tcc_add_btstub() */\n                        continue;\n#ifndef TCC_TARGET_ARM\n                    if (PTR_SIZE != 8)\n                        continue;\n#endif\n                    /* from tcc_add_symbol(): on 64 bit platforms these\n                       need to go through .got */\n                } else\n                    continue;\n            }\n\n#ifdef TCC_TARGET_X86_64\n            if ((type == R_X86_64_PLT32 || type == R_X86_64_PC32) &&\n\t\tsym->st_shndx != SHN_UNDEF &&\n                (ELFW(ST_VISIBILITY)(sym->st_other) != STV_DEFAULT ||\n\t\t ELFW(ST_BIND)(sym->st_info) == STB_LOCAL ||\n\t\t s1->output_type & TCC_OUTPUT_EXE)) {\n\t\tif (pass != 0)\n\t\t    continue;\n                rel->r_info = ELFW(R_INFO)(sym_index, R_X86_64_PC32);\n                continue;\n            }\n#endif\n            reloc_type = code_reloc(type);\n            if (reloc_type == -1) {\n                tcc_error_noabort (\"Unknown relocation type: %d\", type);\n                continue;\n            }\n\n            if (reloc_type != 0) {\n        jmp_slot:\n\t        if (pass != 0)\n                    continue;\n                reloc_type = R_JMP_SLOT;\n            } else {\n\t        if (pass != 1)\n                    continue;\n                reloc_type = R_GLOB_DAT;\n            }\n\n            if (!s1->got)\n                got_sym = build_got(s1);\n\n            if (gotplt_entry == BUILD_GOT_ONLY)\n                continue;\n\n            attr = put_got_entry(s1, reloc_type, sym_index);\n\n            if (reloc_type == R_JMP_SLOT)\n                rel->r_info = ELFW(R_INFO)(attr->plt_sym, type);\n        }\n    }\n    if (++pass < 2)\n        goto redo;\n    /* .rel.plt refers to .got actually */\n    if (s1->plt && s1->plt->reloc)\n        s1->plt->reloc->sh_info = s1->got->sh_num;\n    if (got_sym) /* set size */\n        ((ElfW(Sym)*)symtab_section->data)[got_sym].st_size = s1->got->data_offset;\n}\n#endif /* def NEED_BUILD_GOT */\n\nST_FUNC int set_global_sym(TCCState *s1, const char *name, Section *sec, addr_t offs)\n{\n    int shn = sec ? sec->sh_num : offs || !name ? SHN_ABS : SHN_UNDEF;\n    if (sec && offs == -1)\n        offs = sec->data_offset;\n    return set_elf_sym(symtab_section, offs, 0,\n        ELFW(ST_INFO)(name ? STB_GLOBAL : STB_LOCAL, STT_NOTYPE), 0, shn, name);\n}\n\nstatic void add_init_array_defines(TCCState *s1, const char *section_name)\n{\n    Section *s;\n    addr_t end_offset;\n    char buf[1024];\n    s = have_section(s1, section_name);\n    if (!s || !(s->sh_flags & SHF_ALLOC)) {\n        end_offset = 0;\n        s = text_section;\n    } else {\n        end_offset = s->data_offset;\n    }\n    snprintf(buf, sizeof(buf), \"__%s_start\", section_name + 1);\n    set_global_sym(s1, buf, s, 0);\n    snprintf(buf, sizeof(buf), \"__%s_end\", section_name + 1);\n    set_global_sym(s1, buf, s, end_offset);\n}\n\nST_FUNC void add_array (TCCState *s1, const char *sec, int c)\n{\n    Section *s;\n    s = find_section(s1, sec);\n    s->sh_flags = shf_RELRO;\n    s->sh_type = sec[1] == 'i' ? SHT_INIT_ARRAY : SHT_FINI_ARRAY;\n    put_elf_reloc (s1->symtab, s, s->data_offset, R_DATA_PTR, c);\n    section_ptr_add(s, PTR_SIZE);\n}\n\n#ifdef CONFIG_TCC_BCHECK\nST_FUNC void tcc_add_bcheck(TCCState *s1)\n{\n    if (0 == s1->do_bounds_check)\n        return;\n    section_ptr_add(bounds_section, sizeof(addr_t));\n}\n#endif\n\n/* set symbol to STB_LOCAL and resolve. The point is to not export it as\n   a dynamic symbol to allow so's to have one each with a different value. */\nstatic void set_local_sym(TCCState *s1, const char *name, Section *s, int offset)\n{\n    int c = find_elf_sym(s1->symtab, name);\n    if (c) {\n        ElfW(Sym) *esym = (ElfW(Sym)*)s1->symtab->data + c;\n        esym->st_info = ELFW(ST_INFO)(STB_LOCAL, STT_NOTYPE);\n        esym->st_value = offset;\n        esym->st_shndx = s->sh_num;\n    }\n}\n\n/* avoid generating debug/test_coverage code for stub functions */\nstatic void tcc_compile_string_no_debug(TCCState *s, const char *str)\n{\n    int save_do_debug = s->do_debug;\n    int save_test_coverage = s->test_coverage;\n\n    s->do_debug = 0;\n    s->test_coverage = 0;\n    tcc_compile_string(s, str);\n    s->do_debug = save_do_debug;\n    s->test_coverage = save_test_coverage;\n}\n\n#ifdef CONFIG_TCC_BACKTRACE\nstatic void put_ptr(TCCState *s1, Section *s, int offs)\n{\n    int c;\n    c = set_global_sym(s1, NULL, s, offs);\n    s = data_section;\n    put_elf_reloc (s1->symtab, s, s->data_offset, R_DATA_PTR, c);\n    section_ptr_add(s, PTR_SIZE);\n}\n\nST_FUNC void tcc_add_btstub(TCCState *s1)\n{\n    Section *s;\n    int n, o, *p;\n    CString cstr;\n    const char *__rt_info = &\"___rt_info\"[!s1->leading_underscore];\n\n    s = data_section;\n    /* Align to PTR_SIZE */\n    section_ptr_add(s, -s->data_offset & (PTR_SIZE - 1));\n    o = s->data_offset;\n    /* create a struct rt_context (see tccrun.c) */\n    if (s1->dwarf) {\n        put_ptr(s1, dwarf_line_section, 0);\n        put_ptr(s1, dwarf_line_section, -1);\n\tif (s1->dwarf >= 5)\n            put_ptr(s1, dwarf_line_str_section, 0);\n\telse\n            put_ptr(s1, dwarf_str_section, 0);\n    }\n    else\n    {\n        put_ptr(s1, stab_section, 0);\n        put_ptr(s1, stab_section, -1);\n        put_ptr(s1, stab_section->link, 0);\n    }\n\n    /* skip esym_start/esym_end/elf_str (not loaded) */\n    section_ptr_add(s, 3 * PTR_SIZE);\n\n    if (s1->output_type == TCC_OUTPUT_MEMORY && 0 == s1->dwarf) {\n        put_ptr(s1, text_section, 0);\n    } else {\n        /* prog_base : local nameless symbol with offset 0 at SHN_ABS */\n        put_ptr(s1, NULL, 0);\n#if defined TCC_TARGET_MACHO\n        /* adjust for __PAGEZERO */\n        if (s1->dwarf == 0 && s1->output_type == TCC_OUTPUT_EXE)\n            write64le(data_section->data + data_section->data_offset - PTR_SIZE,\n\t              (uint64_t)1 << 32);\n#endif\n    }\n    n = 3 * PTR_SIZE;\n#ifdef CONFIG_TCC_BCHECK\n    if (s1->do_bounds_check) {\n        put_ptr(s1, bounds_section, 0);\n        n -= PTR_SIZE;\n    }\n#endif\n    section_ptr_add(s, n);\n    p = section_ptr_add(s, 2 * sizeof (int));\n    p[0] = s1->rt_num_callers;\n    p[1] = s1->dwarf;\n    // if (s->data_offset - o != 10*PTR_SIZE + 2*sizeof (int)) exit(99);\n\n    if (s1->output_type == TCC_OUTPUT_MEMORY) {\n        set_global_sym(s1, __rt_info, s, o);\n        return;\n    }\n\n    cstr_new(&cstr);\n    cstr_printf(&cstr,\n        \"extern void __bt_init(),__bt_exit(),__bt_init_dll();\"\n        \"static void *__rt_info[];\"\n        \"__attribute__((constructor)) static void __bt_init_rt(){\");\n#ifdef TCC_TARGET_PE\n    if (s1->output_type == TCC_OUTPUT_DLL)\n#ifdef CONFIG_TCC_BCHECK\n        cstr_printf(&cstr, \"__bt_init_dll(%d);\", s1->do_bounds_check);\n#else\n        cstr_printf(&cstr, \"__bt_init_dll(0);\");\n#endif\n#endif\n    cstr_printf(&cstr, \"__bt_init(__rt_info,%d);}\",\n        s1->output_type != TCC_OUTPUT_DLL);\n    /* In case dlcose is called by application */\n    cstr_printf(&cstr,\n        \"__attribute__((destructor)) static void __bt_exit_rt(){\"\n        \"__bt_exit(__rt_info);}\");\n    tcc_compile_string_no_debug(s1, cstr.data);\n    cstr_free(&cstr);\n    set_local_sym(s1, __rt_info, s, o);\n}\n#endif /* def CONFIG_TCC_BACKTRACE */\n\nstatic void tcc_tcov_add_file(TCCState *s1, const char *filename)\n{\n    CString cstr;\n    void *ptr;\n    char wd[1024];\n\n    if (tcov_section == NULL)\n        return;\n    section_ptr_add(tcov_section, 1);\n    write32le (tcov_section->data, tcov_section->data_offset);\n\n    cstr_new (&cstr);\n    if (filename[0] == '/')\n        cstr_printf (&cstr, \"%s.tcov\", filename);\n    else {\n        getcwd (wd, sizeof(wd));\n        cstr_printf (&cstr, \"%s/%s.tcov\", wd, filename);\n    }\n    ptr = section_ptr_add(tcov_section, cstr.size + 1);\n    strcpy((char *)ptr, cstr.data);\n    unlink((char *)ptr);\n#ifdef _WIN32\n    normalize_slashes((char *)ptr);\n#endif\n    cstr_free (&cstr);\n\n    cstr_new(&cstr);\n    cstr_printf(&cstr,\n        \"extern char *__tcov_data[];\"\n        \"extern void __store_test_coverage ();\"\n        \"__attribute__((destructor)) static void __tcov_exit() {\"\n        \"__store_test_coverage(__tcov_data);\"\n        \"}\");\n    tcc_compile_string_no_debug(s1, cstr.data);\n    cstr_free(&cstr);\n    set_local_sym(s1, &\"___tcov_data\"[!s1->leading_underscore], tcov_section, 0);\n}\n\n#if !defined TCC_TARGET_PE && !defined TCC_TARGET_MACHO\n/* add libc crt1/crti objects */\nST_FUNC void tccelf_add_crtbegin(TCCState *s1)\n{\n#if TARGETOS_OpenBSD\n    if (s1->output_type != TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crt0.o\");\n    if (s1->output_type == TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crtbeginS.o\");\n    else\n        tcc_add_crt(s1, \"crtbegin.o\");\n#elif TARGETOS_FreeBSD || TARGETOS_NetBSD\n    if (s1->output_type != TCC_OUTPUT_DLL)\n#if TARGETOS_FreeBSD\n        tcc_add_crt(s1, \"crt1.o\");\n#else\n        tcc_add_crt(s1, \"crt0.o\");\n#endif\n    tcc_add_crt(s1, \"crti.o\");\n    if (s1->static_link)\n        tcc_add_crt(s1, \"crtbeginT.o\");\n    else if (s1->output_type == TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crtbeginS.o\");\n    else\n        tcc_add_crt(s1, \"crtbegin.o\");\n#elif TARGETOS_ANDROID\n    if (s1->output_type == TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crtbegin_so.o\");\n    else\n        tcc_add_crt(s1, \"crtbegin_dynamic.o\");\n#else\n    if (s1->output_type != TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crt1.o\");\n    tcc_add_crt(s1, \"crti.o\");\n#endif\n}\n\nST_FUNC void tccelf_add_crtend(TCCState *s1)\n{\n#if TARGETOS_OpenBSD\n    if (s1->output_type == TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crtendS.o\");\n    else\n        tcc_add_crt(s1, \"crtend.o\");\n#elif TARGETOS_FreeBSD || TARGETOS_NetBSD\n    if (s1->output_type == TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crtendS.o\");\n    else\n        tcc_add_crt(s1, \"crtend.o\");\n    tcc_add_crt(s1, \"crtn.o\");\n#elif TARGETOS_ANDROID\n    if (s1->output_type == TCC_OUTPUT_DLL)\n        tcc_add_crt(s1, \"crtend_so.o\");\n    else\n        tcc_add_crt(s1, \"crtend_android.o\");\n#else\n    tcc_add_crt(s1, \"crtn.o\");\n#endif\n}\n#endif /* !defined TCC_TARGET_PE && !defined TCC_TARGET_MACHO */\n\n#ifndef TCC_TARGET_PE\n/* add tcc runtime libraries */\nST_FUNC void tcc_add_runtime(TCCState *s1)\n{\n    s1->filetype = 0;\n\n#ifdef CONFIG_TCC_BCHECK\n    tcc_add_bcheck(s1);\n#endif\n    tcc_add_pragma_libs(s1);\n\n    /* add libc */\n    if (!s1->nostdlib) {\n        int lpthread = s1->option_pthread;\n\n#ifdef CONFIG_TCC_BCHECK\n        if (s1->do_bounds_check && s1->output_type != TCC_OUTPUT_DLL) {\n            tcc_add_support(s1, \"bcheck.o\");\n# if !(TARGETOS_OpenBSD || TARGETOS_NetBSD)\n            tcc_add_library(s1, \"dl\");\n# endif\n            lpthread = 1;\n        }\n#endif\n#ifdef CONFIG_TCC_BACKTRACE\n        if (s1->do_backtrace) {\n            if (s1->output_type & TCC_OUTPUT_EXE)\n                tcc_add_support(s1, \"bt-exe.o\");\n            if (s1->output_type != TCC_OUTPUT_DLL)\n                tcc_add_support(s1, \"bt-log.o\");\n            tcc_add_btstub(s1);\n            lpthread = 1;\n        }\n#endif\n        if (lpthread)\n            tcc_add_library(s1, \"pthread\");\n        tcc_add_library(s1, \"c\");\n#ifdef TCC_LIBGCC\n        if (!s1->static_link) {\n            if (TCC_LIBGCC[0] == '/')\n                tcc_add_file(s1, TCC_LIBGCC);\n            else\n                tcc_add_dll(s1, TCC_LIBGCC, AFF_PRINT_ERROR);\n        }\n#endif\n#if defined TCC_TARGET_ARM && TARGETOS_FreeBSD\n        tcc_add_library(s1, \"gcc_s\"); // unwind code\n#endif\n        if (TCC_LIBTCC1[0])\n            tcc_add_support(s1, TCC_LIBTCC1);\n#ifndef TCC_TARGET_MACHO\n        if (s1->output_type != TCC_OUTPUT_MEMORY)\n            tccelf_add_crtend(s1);\n#endif\n    }\n}\n#endif /* ndef TCC_TARGET_PE */\n\n/* add various standard linker symbols (must be done after the\n   sections are filled (for example after allocating common\n   symbols)) */\nstatic void tcc_add_linker_symbols(TCCState *s1)\n{\n    char buf[1024];\n    int i;\n    Section *s;\n\n    set_global_sym(s1, \"_etext\", text_section, -1);\n    set_global_sym(s1, \"_edata\", data_section, -1);\n    set_global_sym(s1, \"_end\", bss_section, -1);\n#if TARGETOS_OpenBSD\n    set_global_sym(s1, \"__executable_start\", NULL, ELF_START_ADDR);\n#endif\n#ifdef TCC_TARGET_RISCV64\n    /* XXX should be .sdata+0x800, not .data+0x800 */\n    set_global_sym(s1, \"__global_pointer$\", data_section, 0x800);\n#endif\n    /* horrible new standard ldscript defines */\n    add_init_array_defines(s1, \".preinit_array\");\n    add_init_array_defines(s1, \".init_array\");\n    add_init_array_defines(s1, \".fini_array\");\n    /* add start and stop symbols for sections whose name can be\n       expressed in C */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if ((s->sh_flags & SHF_ALLOC)\n            && (s->sh_type == SHT_PROGBITS || s->sh_type == SHT_NOBITS\n                || s->sh_type == SHT_STRTAB)) {\n            /* check if section name can be expressed in C */\n            const char *p0, *p;\n            p0 = s->name;\n            if (*p0 == '.')\n                ++p0;\n            p = p0;\n            for(;;) {\n                int c = *p;\n                if (!c)\n                    break;\n                if (!isid(c) && !isnum(c))\n                    goto next_sec;\n                p++;\n            }\n            snprintf(buf, sizeof(buf), \"__start_%s\", p0);\n            set_global_sym(s1, buf, s, 0);\n            snprintf(buf, sizeof(buf), \"__stop_%s\", p0);\n            set_global_sym(s1, buf, s, -1);\n        }\n    next_sec: ;\n    }\n}\n\nST_FUNC void resolve_common_syms(TCCState *s1)\n{\n    ElfW(Sym) *sym;\n\n    /* Allocate common symbols in BSS.  */\n    for_each_elem(symtab_section, 1, sym, ElfW(Sym)) {\n        if (sym->st_shndx == SHN_COMMON) {\n            /* symbol alignment is in st_value for SHN_COMMONs */\n\t    sym->st_value = section_add(bss_section, sym->st_size,\n\t\t\t\t\tsym->st_value);\n            sym->st_shndx = bss_section->sh_num;\n        }\n    }\n\n    /* Now assign linker provided symbols their value.  */\n    tcc_add_linker_symbols(s1);\n}\n\n#ifndef ELF_OBJ_ONLY\nST_FUNC void fill_got_entry(TCCState *s1, ElfW_Rel *rel)\n{\n    int sym_index = ELFW(R_SYM) (rel->r_info);\n    ElfW(Sym) *sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];\n    struct sym_attr *attr = get_sym_attr(s1, sym_index, 0);\n    unsigned offset = attr->got_offset;\n\n    if (0 == offset)\n        return;\n    section_reserve(s1->got, offset + PTR_SIZE);\n#if PTR_SIZE == 8\n    write64le(s1->got->data + offset, sym->st_value);\n#else\n    write32le(s1->got->data + offset, sym->st_value);\n#endif\n}\n\n/* Perform relocation to GOT or PLT entries */\nST_FUNC void fill_got(TCCState *s1)\n{\n    Section *s;\n    ElfW_Rel *rel;\n    int i;\n\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_RELX)\n            continue;\n        /* no need to handle got relocations */\n        if (s->link != symtab_section)\n            continue;\n        for_each_elem(s, 0, rel, ElfW_Rel) {\n            switch (ELFW(R_TYPE) (rel->r_info)) {\n                case R_X86_64_GOT32:\n                case R_X86_64_GOTPCREL:\n\t\tcase R_X86_64_GOTPCRELX:\n\t\tcase R_X86_64_REX_GOTPCRELX:\n                case R_X86_64_PLT32:\n                    fill_got_entry(s1, rel);\n                    break;\n            }\n        }\n    }\n}\n\n/* See put_got_entry for a description.  This is the second stage\n   where GOT references to local defined symbols are rewritten.  */\nstatic void fill_local_got_entries(TCCState *s1)\n{\n    ElfW_Rel *rel;\n    if (!s1->got->reloc)\n        return;\n    for_each_elem(s1->got->reloc, 0, rel, ElfW_Rel) {\n\tif (ELFW(R_TYPE)(rel->r_info) == R_RELATIVE) {\n\t    int sym_index = ELFW(R_SYM) (rel->r_info);\n\t    ElfW(Sym) *sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];\n\t    struct sym_attr *attr = get_sym_attr(s1, sym_index, 0);\n\t    unsigned offset = attr->got_offset;\n\t    if (offset != rel->r_offset - s1->got->sh_addr)\n\t        tcc_error_noabort(\"fill_local_got_entries: huh?\");\n\t    rel->r_info = ELFW(R_INFO)(0, R_RELATIVE);\n#if SHT_RELX == SHT_RELA\n\t    rel->r_addend = sym->st_value;\n#else\n\t    /* All our REL architectures also happen to be 32bit LE.  */\n\t    write32le(s1->got->data + offset, sym->st_value);\n#endif\n\t}\n    }\n}\n\n/* Bind symbols of executable: resolve undefined symbols from exported symbols\n   in shared libraries */\nstatic void bind_exe_dynsyms(TCCState *s1, int is_PIE)\n{\n    const char *name;\n    int sym_index, index;\n    ElfW(Sym) *sym, *esym;\n    int type;\n\n    /* Resolve undefined symbols from dynamic symbols. When there is a match:\n       - if STT_FUNC or STT_GNU_IFUNC symbol -> add it in PLT\n       - if STT_OBJECT symbol -> add it in .bss section with suitable reloc */\n    for_each_elem(symtab_section, 1, sym, ElfW(Sym)) {\n        if (sym->st_shndx == SHN_UNDEF) {\n            name = (char *) symtab_section->link->data + sym->st_name;\n            sym_index = find_elf_sym(s1->dynsymtab_section, name);\n            if (sym_index) {\n                if (is_PIE)\n                    continue;\n                esym = &((ElfW(Sym) *)s1->dynsymtab_section->data)[sym_index];\n                type = ELFW(ST_TYPE)(esym->st_info);\n                if ((type == STT_FUNC) || (type == STT_GNU_IFUNC)) {\n                    /* Indirect functions shall have STT_FUNC type in executable\n                     * dynsym section. Indeed, a dlsym call following a lazy\n                     * resolution would pick the symbol value from the\n                     * executable dynsym entry which would contain the address\n                     * of the function wanted by the caller of dlsym instead of\n                     * the address of the function that would return that\n                     * address */\n                    int dynindex\n\t\t      = put_elf_sym(s1->dynsym, 0, esym->st_size,\n\t\t\t\t    ELFW(ST_INFO)(STB_GLOBAL,STT_FUNC), 0, 0,\n\t\t\t\t    name);\n\t\t    int index = sym - (ElfW(Sym) *) symtab_section->data;\n\t\t    get_sym_attr(s1, index, 1)->dyn_index = dynindex;\n                } else if (type == STT_OBJECT) {\n                    unsigned long offset;\n                    ElfW(Sym) *dynsym;\n                    offset = bss_section->data_offset;\n                    /* XXX: which alignment ? */\n                    offset = (offset + 16 - 1) & -16;\n                    set_elf_sym (s1->symtab, offset, esym->st_size,\n                                 esym->st_info, 0, bss_section->sh_num, name);\n                    index = put_elf_sym(s1->dynsym, offset, esym->st_size,\n                                        esym->st_info, 0, bss_section->sh_num,\n                                        name);\n\n                    /* Ensure R_COPY works for weak symbol aliases */\n                    if (ELFW(ST_BIND)(esym->st_info) == STB_WEAK) {\n                        for_each_elem(s1->dynsymtab_section, 1, dynsym, ElfW(Sym)) {\n                            if ((dynsym->st_value == esym->st_value)\n                                && (ELFW(ST_BIND)(dynsym->st_info) == STB_GLOBAL)) {\n                                char *dynname = (char *) s1->dynsymtab_section->link->data\n                                                + dynsym->st_name;\n                                put_elf_sym(s1->dynsym, offset, dynsym->st_size,\n                                            dynsym->st_info, 0,\n                                            bss_section->sh_num, dynname);\n                                break;\n                            }\n                        }\n                    }\n\n                    put_elf_reloc(s1->dynsym, bss_section,\n                                  offset, R_COPY, index);\n                    offset += esym->st_size;\n                    bss_section->data_offset = offset;\n                }\n            } else {\n                /* STB_WEAK undefined symbols are accepted */\n                /* XXX: _fp_hw seems to be part of the ABI, so we ignore it */\n                if (ELFW(ST_BIND)(sym->st_info) == STB_WEAK ||\n                    !strcmp(name, \"_fp_hw\")) {\n                } else {\n                    tcc_error_noabort(\"undefined symbol '%s'\", name);\n                }\n            }\n        }\n    }\n}\n\n/* Bind symbols of libraries: export all non local symbols of executable that\n   are referenced by shared libraries. The reason is that the dynamic loader\n   search symbol first in executable and then in libraries. Therefore a\n   reference to a symbol already defined by a library can still be resolved by\n   a symbol in the executable.   With -rdynamic, export all defined symbols */\nstatic void bind_libs_dynsyms(TCCState *s1)\n{\n    const char *name;\n    int dynsym_index;\n    ElfW(Sym) *sym, *esym;\n\n    for_each_elem(symtab_section, 1, sym, ElfW(Sym)) {\n        name = (char *)symtab_section->link->data + sym->st_name;\n        dynsym_index = find_elf_sym(s1->dynsymtab_section, name);\n        if (sym->st_shndx != SHN_UNDEF) {\n            if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL\n                && (dynsym_index || s1->rdynamic))\n                set_elf_sym(s1->dynsym, sym->st_value, sym->st_size,\n                            sym->st_info, 0, sym->st_shndx, name);\n        } else if (dynsym_index) {\n            esym = (ElfW(Sym) *)s1->dynsymtab_section->data + dynsym_index;\n            if (esym->st_shndx == SHN_UNDEF) {\n                /* weak symbols can stay undefined */\n                if (ELFW(ST_BIND)(esym->st_info) != STB_WEAK)\n                    tcc_warning(\"undefined dynamic symbol '%s'\", name);\n            }\n        }\n    }\n}\n\n/* Export all non local symbols. This is used by shared libraries so that the\n   non local symbols they define can resolve a reference in another shared\n   library or in the executable. Correspondingly, it allows undefined local\n   symbols to be resolved by other shared libraries or by the executable. */\nstatic void export_global_syms(TCCState *s1)\n{\n    int dynindex, index;\n    const char *name;\n    ElfW(Sym) *sym;\n    for_each_elem(symtab_section, 1, sym, ElfW(Sym)) {\n        if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL) {\n\t    name = (char *) symtab_section->link->data + sym->st_name;\n\t    dynindex = set_elf_sym(s1->dynsym, sym->st_value, sym->st_size,\n\t\t\t\t   sym->st_info, 0, sym->st_shndx, name);\n\t    index = sym - (ElfW(Sym) *) symtab_section->data;\n            get_sym_attr(s1, index, 1)->dyn_index = dynindex;\n        }\n    }\n}\n\n/* decide if an unallocated section should be output. */\nstatic int set_sec_sizes(TCCState *s1)\n{\n    int i;\n    Section *s;\n    int textrel = 0;\n    int file_type = s1->output_type;\n\n    /* Allocate strings for section names */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type == SHT_RELX && !(s->sh_flags & SHF_ALLOC)) {\n            /* when generating a DLL, we include relocations but\n               we may patch them */\n            if ((file_type & TCC_OUTPUT_DYN)\n                && (s1->sections[s->sh_info]->sh_flags & SHF_ALLOC)) {\n                int count = prepare_dynamic_rel(s1, s);\n                if (count) {\n                    /* allocate the section */\n                    s->sh_flags |= SHF_ALLOC;\n                    s->sh_size = count * sizeof(ElfW_Rel);\n                    if (s1->sections[s->sh_info]->sh_flags & SHF_EXECINSTR)\n                        textrel += count;\n                }\n            }\n        } else if ((s->sh_flags & SHF_ALLOC)\n#ifdef TCC_TARGET_ARM\n                   || s->sh_type == SHT_ARM_ATTRIBUTES\n#endif\n                   || s1->do_debug) {\n            s->sh_size = s->data_offset;\n        }\n\n#ifdef TCC_TARGET_ARM\n        /* XXX: Suppress stack unwinding section. */\n        if (s->sh_type == SHT_ARM_EXIDX) {\n            s->sh_flags = 0;\n            s->sh_size = 0;\n        }\n#endif\n\n    }\n    return textrel;\n}\n\n/* various data used under elf_output_file() */\nstruct dyn_inf {\n    Section *dynamic;\n    Section *dynstr;\n    struct {\n        /* Info to be copied in dynamic section */\n        unsigned long data_offset;\n        addr_t rel_addr;\n        addr_t rel_size;\n    };\n\n    ElfW(Phdr) *phdr;\n    int phnum;\n    int shnum;\n    Section *interp;\n    Section *note;\n    Section *gnu_hash;\n\n    /* read only segment mapping for GNU_RELRO */\n    Section _roinf, *roinf;\n};\n\n/* Decide the layout of sections loaded in memory. This must be done before\n   program headers are filled since they contain info about the layout.\n   We do the following ordering: interp, symbol tables, relocations, progbits,\n   nobits */\nstatic int sort_sections(TCCState *s1, int *sec_order, struct dyn_inf *d)\n{\n    Section *s;\n    int i, j, k, f, f0, n;\n    int nb_sections = s1->nb_sections;\n    int *sec_cls = sec_order + nb_sections;\n\n    for (i = 1; i < nb_sections; i++) {\n        s = s1->sections[i];\n        if (0 == s->sh_name) {\n            j = 0x900; /* no sh_name: won't go to file */\n        } else if (s->sh_flags & SHF_ALLOC) {\n            j = 0x100;\n            if (s->sh_flags & SHF_WRITE)\n                j = 0x200;\n            if (s->sh_flags & SHF_TLS)\n                j += 0x200;\n        } else {\n            j = 0x700;\n        }\n        if (j >= 0x700 && s1->output_format != TCC_OUTPUT_FORMAT_ELF)\n            s->sh_size = 0, j = 0x900;\n\n        if (s->sh_type == SHT_SYMTAB || s->sh_type == SHT_DYNSYM) {\n            k = 0x10;\n        } else if (s->sh_type == SHT_STRTAB && strcmp(s->name, \".stabstr\")) {\n            k = 0x11;\n            if (i == nb_sections - 1) /* \".shstrtab\" assumed to stay last */\n                k = 0xff;\n        } else if (s->sh_type == SHT_HASH || s->sh_type == SHT_GNU_HASH) {\n            k = 0x12;\n        } else if (s->sh_type == SHT_GNU_verdef\n                  || s->sh_type == SHT_GNU_verneed\n                  || s->sh_type == SHT_GNU_versym) {\n            k = 0x13;\n        } else if (s->sh_type == SHT_RELX) {\n            k = 0x20;\n            if (s1->plt && s == s1->plt->reloc)\n                k = 0x21;\n        } else if (s->sh_flags & SHF_EXECINSTR) {\n            k = 0x30;\n        /* RELRO sections --> */\n        } else if (s->sh_type == SHT_PREINIT_ARRAY) {\n            k = 0x41;\n        } else if (s->sh_type == SHT_INIT_ARRAY) {\n            k = 0x42;\n        } else if (s->sh_type == SHT_FINI_ARRAY) {\n            k = 0x43;\n        } else if (s->sh_type == SHT_DYNAMIC) {\n            k = 0x46;\n        } else if (s == s1->got) {\n            k = 0x47; /* .got as RELRO needs BIND_NOW in DT_FLAGS */\n        } else if (s->reloc && (s->reloc->sh_flags & SHF_ALLOC) && j == 0x100) {\n            k = 0x44;\n        /* <-- */\n        } else if (s->sh_type == SHT_NOTE) {\n            k = 0x60;\n        } else if (s->sh_type == SHT_NOBITS) {\n            k = 0x70; /* bss */\n        } else if (s == d->interp) {\n            k = 0x00;\n        } else {\n            k = 0x50; /* data */\n        }\n        k += j;\n\n        if ((k & 0xfff0) == 0x140) {\n            /* make RELRO section writable */\n            k += 0x100, s->sh_flags |= SHF_WRITE;\n        }\n        for (n = i; n > 1 && k < (f = sec_cls[n - 1]); --n)\n            sec_cls[n] = f, sec_order[n] = sec_order[n - 1];\n        sec_cls[n] = k, sec_order[n] = i;\n    }\n    sec_order[0] = 0;\n    d->shnum = 1;\n\n    /* count PT_LOAD headers needed */\n    n = f0 = 0;\n    for (i = 1; i < nb_sections; i++) {\n        s = s1->sections[sec_order[i]];\n        k = sec_cls[i];\n        f = 0;\n        if (k < 0x900)\n            ++d->shnum;\n        if (k < 0x700) {\n            f = s->sh_flags & (SHF_ALLOC|SHF_WRITE|SHF_EXECINSTR|SHF_TLS);\n#if TARGETOS_NetBSD\n\t    /* NetBSD only supports 2 PT_LOAD sections.\n\t       See: https://blog.netbsd.org/tnf/entry/the_first_report_on_lld */\n\t    if ((f & SHF_WRITE) == 0)\n                f |= SHF_EXECINSTR;\n#else\n            if ((k & 0xfff0) == 0x240) /* RELRO sections */\n                f |= 1<<4;\n#endif\n            /* start new header when flags changed or relro, but avoid zero memsz */\n            if (f != f0 && s->sh_size)\n                f0 = f, ++n, f |= 1<<8;\n        }\n        sec_cls[i] = f;\n        //printf(\"ph %d sec %02d : %3X %3X  %8.2X  %04X  %s\\n\", (f>0) * n, i, f, k, s->sh_type, (int)s->sh_size, s->name);\n    }\n    return n;\n}\n\nstatic ElfW(Phdr) *fill_phdr(ElfW(Phdr) *ph, int type, Section *s)\n{\n    if (s) {\n        ph->p_offset = s->sh_offset;\n        ph->p_vaddr = s->sh_addr;\n        ph->p_filesz = s->sh_size;\n        ph->p_align = s->sh_addralign;\n    }\n    ph->p_type = type;\n    ph->p_flags = PF_R;\n    ph->p_paddr = ph->p_vaddr;\n    ph->p_memsz = ph->p_filesz;\n    return ph;\n}\n\n/* Assign sections to segments and decide how are sections laid out when loaded\n   in memory. This function also fills corresponding program headers. */\nstatic int layout_sections(TCCState *s1, int *sec_order, struct dyn_inf *d)\n{\n    Section *s;\n    addr_t addr, tmp, align, s_align, base;\n    ElfW(Phdr) *ph = NULL;\n    int i, f, n, phnum, phfill;\n    int file_offset;\n\n    /* compute number of program headers */\n    phnum = sort_sections(s1, sec_order, d);\n    phfill = 0; /* set to 1 to have dll's with a PT_PHDR */\n    if (d->interp)\n        phfill = 2;\n    phnum += phfill;\n    if (d->note)\n        ++phnum;\n    if (d->dynamic)\n        ++phnum;\n    if (eh_frame_hdr_section)\n        ++phnum;\n    if (d->roinf)\n        ++phnum;\n    d->phnum = phnum;\n    d->phdr = tcc_mallocz(phnum * sizeof(ElfW(Phdr)));\n\n    file_offset = 0;\n    if (s1->output_format == TCC_OUTPUT_FORMAT_ELF) {\n        file_offset = (sizeof(ElfW(Ehdr)) + phnum * sizeof(ElfW(Phdr)) + 3) & -4;\n        file_offset += d->shnum * sizeof (ElfW(Shdr));\n    }\n\n    s_align = ELF_PAGE_SIZE;\n    if (s1->section_align)\n        s_align = s1->section_align;\n\n    addr = ELF_START_ADDR;\n    if (s1->output_type & TCC_OUTPUT_DYN)\n        addr = 0;\n\n    if (s1->has_text_addr) {\n        addr = s1->text_addr;\n        if (0) {\n            int a_offset, p_offset;\n            /* we ensure that (addr % ELF_PAGE_SIZE) == file_offset %\n               ELF_PAGE_SIZE */\n            a_offset = (int) (addr & (s_align - 1));\n            p_offset = file_offset & (s_align - 1);\n            if (a_offset < p_offset)\n                a_offset += s_align;\n            file_offset += (a_offset - p_offset);\n        }\n    }\n    base = addr;\n    /* compute address after headers */\n    addr += file_offset;\n\n    n = 0;\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[sec_order[i]];\n        f = sec_order[i + s1->nb_sections];\n        align = s->sh_addralign - 1;\n\n        if (f == 0) { /* no alloc */\n            file_offset = (file_offset + align) & ~align;\n            s->sh_offset = file_offset;\n            if (s->sh_type != SHT_NOBITS)\n                file_offset += s->sh_size;\n            continue;\n        }\n\n        if ((f & 1<<8) && n) {\n            /* different rwx section flags */\n            if (s1->output_format == TCC_OUTPUT_FORMAT_ELF) {\n                /* if in the middle of a page, w e duplicate the page in\n                   memory so that one copy is RX and the other is RW */\n                if ((addr & (s_align - 1)) != 0)\n                    addr += s_align;\n            } else {\n                align = s_align - 1;\n            }\n        }\n\n        tmp = addr;\n        addr = (addr + align) & ~align;\n        file_offset += (int)(addr - tmp);\n        s->sh_offset = file_offset;\n        s->sh_addr = addr;\n\n        if (f & 1<<8) {\n            /* set new program header */\n            ph = &d->phdr[phfill + n];\n            ph->p_type = PT_LOAD;\n            ph->p_align = s_align;\n            ph->p_flags = PF_R;\n            if (f & SHF_WRITE)\n                ph->p_flags |= PF_W;\n            if (f & SHF_EXECINSTR)\n                ph->p_flags |= PF_X;\n            if (f & SHF_TLS) {\n                ph->p_type = PT_TLS;\n                ph->p_align = align + 1;\n            }\n\n            ph->p_offset = file_offset;\n            ph->p_vaddr = addr;\n            if (n == 0) {\n\t\t/* Make the first PT_LOAD segment include the program\n\t\t   headers itself (and the ELF header as well), it'll\n\t\t   come out with same memory use but will make various\n\t\t   tools like binutils strip work better.  */\n\t\tph->p_offset = 0;\n\t\tph->p_vaddr = base;\n            }\n            ph->p_paddr = ph->p_vaddr;\n            ++n;\n        }\n\n        if (f & 1<<4) {\n            Section *roinf = &d->_roinf;\n            if (roinf->sh_size == 0) {\n                roinf->sh_offset = s->sh_offset;\n                roinf->sh_addr = s->sh_addr;\n                roinf->sh_addralign = 1;\n\t    }\n            roinf->sh_size = (addr - roinf->sh_addr) + s->sh_size;\n        }\n\n        addr += s->sh_size;\n        if (s->sh_type != SHT_NOBITS)\n            file_offset += s->sh_size;\n\n        ph->p_filesz = file_offset - ph->p_offset;\n        ph->p_memsz = addr - ph->p_vaddr;\n    }\n\n    /* Fill other headers */\n    if (d->note)\n        fill_phdr(++ph, PT_NOTE, d->note);\n    if (d->dynamic)\n        fill_phdr(++ph, PT_DYNAMIC, d->dynamic)->p_flags |= PF_W;\n    if (eh_frame_hdr_section)\n        fill_phdr(++ph, PT_GNU_EH_FRAME, eh_frame_hdr_section);\n    if (d->roinf)\n        fill_phdr(++ph, PT_GNU_RELRO, d->roinf)->p_flags |= PF_W;\n    if (d->interp)\n        fill_phdr(&d->phdr[1], PT_INTERP, d->interp);\n    if (phfill) {\n        ph = &d->phdr[0];\n        ph->p_offset = sizeof(ElfW(Ehdr));\n        ph->p_vaddr = base + ph->p_offset;\n        ph->p_filesz = phnum * sizeof(ElfW(Phdr));\n        ph->p_align = 4;\n        fill_phdr(ph, PT_PHDR, NULL);\n    }\n    return 0;\n}\n\n/* put dynamic tag */\nstatic void put_dt(Section *dynamic, int dt, addr_t val)\n{\n    ElfW(Dyn) *dyn;\n    dyn = section_ptr_add(dynamic, sizeof(ElfW(Dyn)));\n    dyn->d_tag = dt;\n    dyn->d_un.d_val = val;\n}\n\n/* Fill the dynamic section with tags describing the address and size of\n   sections */\nstatic void fill_dynamic(TCCState *s1, struct dyn_inf *dyninf)\n{\n    Section *dynamic = dyninf->dynamic;\n    Section *s;\n\n    /* put dynamic section entries */\n    put_dt(dynamic, DT_HASH, s1->dynsym->hash->sh_addr);\n    put_dt(dynamic, DT_GNU_HASH, dyninf->gnu_hash->sh_addr);\n    put_dt(dynamic, DT_STRTAB, dyninf->dynstr->sh_addr);\n    put_dt(dynamic, DT_SYMTAB, s1->dynsym->sh_addr);\n    put_dt(dynamic, DT_STRSZ, dyninf->dynstr->data_offset);\n    put_dt(dynamic, DT_SYMENT, sizeof(ElfW(Sym)));\n#if PTR_SIZE == 8\n    put_dt(dynamic, DT_RELA, dyninf->rel_addr);\n    put_dt(dynamic, DT_RELASZ, dyninf->rel_size);\n    put_dt(dynamic, DT_RELAENT, sizeof(ElfW_Rel));\n    if (s1->plt && s1->plt->reloc) {\n        put_dt(dynamic, DT_PLTGOT, s1->got->sh_addr);\n        put_dt(dynamic, DT_PLTRELSZ, s1->plt->reloc->data_offset);\n        put_dt(dynamic, DT_JMPREL, s1->plt->reloc->sh_addr);\n        put_dt(dynamic, DT_PLTREL, DT_RELA);\n    }\n    put_dt(dynamic, DT_RELACOUNT, 0);\n#else\n    put_dt(dynamic, DT_REL, dyninf->rel_addr);\n    put_dt(dynamic, DT_RELSZ, dyninf->rel_size);\n    put_dt(dynamic, DT_RELENT, sizeof(ElfW_Rel));\n    if (s1->plt && s1->plt->reloc) {\n        put_dt(dynamic, DT_PLTGOT, s1->got->sh_addr);\n        put_dt(dynamic, DT_PLTRELSZ, s1->plt->reloc->data_offset);\n        put_dt(dynamic, DT_JMPREL, s1->plt->reloc->sh_addr);\n        put_dt(dynamic, DT_PLTREL, DT_REL);\n    }\n    put_dt(dynamic, DT_RELCOUNT, 0);\n#endif\n    if (versym_section && verneed_section) {\n\t/* The dynamic linker can not handle VERSYM without VERNEED */\n        put_dt(dynamic, DT_VERSYM, versym_section->sh_addr);\n        put_dt(dynamic, DT_VERNEED, verneed_section->sh_addr);\n        put_dt(dynamic, DT_VERNEEDNUM, dt_verneednum);\n    }\n    s = have_section(s1, \".preinit_array\");\n    if (s && s->data_offset) {\n        put_dt(dynamic, DT_PREINIT_ARRAY, s->sh_addr);\n        put_dt(dynamic, DT_PREINIT_ARRAYSZ, s->data_offset);\n    }\n    s = have_section(s1, \".init_array\");\n    if (s && s->data_offset) {\n        put_dt(dynamic, DT_INIT_ARRAY, s->sh_addr);\n        put_dt(dynamic, DT_INIT_ARRAYSZ, s->data_offset);\n    }\n    s = have_section(s1, \".fini_array\");\n    if (s && s->data_offset) {\n        put_dt(dynamic, DT_FINI_ARRAY, s->sh_addr);\n        put_dt(dynamic, DT_FINI_ARRAYSZ, s->data_offset);\n    }\n    s = have_section(s1, \".init\");\n    if (s && s->data_offset) {\n        put_dt(dynamic, DT_INIT, s->sh_addr);\n    }\n    s = have_section(s1, \".fini\");\n    if (s && s->data_offset) {\n        put_dt(dynamic, DT_FINI, s->sh_addr);\n    }\n    if (s1->do_debug)\n        put_dt(dynamic, DT_DEBUG, 0);\n    put_dt(dynamic, DT_NULL, 0);\n}\n\n/* Remove gaps between RELX sections.\n   These gaps are a result of final_sections_reloc. Here some relocs are removed.\n   The gaps are then filled with 0 in tcc_output_elf. The 0 is intepreted as\n   R_...NONE reloc. This does work on most targets but on OpenBSD/arm64 this\n   is illegal. OpenBSD/arm64 does not support R_...NONE reloc. */\nstatic void update_reloc_sections(TCCState *s1, struct dyn_inf *dyninf)\n{\n    int i;\n    unsigned long file_offset = 0;\n    Section *s;\n    Section *relocplt = s1->plt ? s1->plt->reloc : NULL;\n\n    /* dynamic relocation table information, for .dynamic section */\n    dyninf->rel_addr = dyninf->rel_size = 0;\n\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n\tif (s->sh_type == SHT_RELX && s != relocplt) {\n\t    if (dyninf->rel_size == 0) {\n\t\tdyninf->rel_addr = s->sh_addr;\n\t\tfile_offset = s->sh_offset;\n\t    }\n\t    else {\n\t\ts->sh_addr = dyninf->rel_addr + dyninf->rel_size;\n\t\ts->sh_offset = file_offset + dyninf->rel_size;\n\t    }\n\t    dyninf->rel_size += s->sh_size;\n\t}\n    }\n}\n#endif /* ndef ELF_OBJ_ONLY */\n\n/* Create an ELF file on disk.\n   This function handle ELF specific layout requirements */\nstatic int tcc_output_elf(TCCState *s1, FILE *f, int phnum, ElfW(Phdr) *phdr)\n{\n    int i, shnum, offset, size, file_type;\n    Section *s;\n    ElfW(Ehdr) ehdr;\n    ElfW(Shdr) shdr, *sh;\n\n    file_type = s1->output_type;\n    shnum = s1->nb_sections;\n\n    memset(&ehdr, 0, sizeof(ehdr));\n    if (phnum > 0) {\n        ehdr.e_phentsize = sizeof(ElfW(Phdr));\n        ehdr.e_phnum = phnum;\n        ehdr.e_phoff = sizeof(ElfW(Ehdr));\n    }\n\n    /* fill header */\n    ehdr.e_ident[0] = ELFMAG0;\n    ehdr.e_ident[1] = ELFMAG1;\n    ehdr.e_ident[2] = ELFMAG2;\n    ehdr.e_ident[3] = ELFMAG3;\n    ehdr.e_ident[4] = ELFCLASSW;\n    ehdr.e_ident[5] = ELFDATA2LSB;\n    ehdr.e_ident[6] = EV_CURRENT;\n\n#if TARGETOS_FreeBSD || TARGETOS_FreeBSD_kernel\n    ehdr.e_ident[EI_OSABI] = ELFOSABI_FREEBSD;\n#elif defined TCC_TARGET_ARM && defined TCC_ARM_EABI\n    ehdr.e_flags = EF_ARM_EABI_VER5;\n    ehdr.e_flags |= s1->float_abi == ARM_HARD_FLOAT\n        ? EF_ARM_VFP_FLOAT : EF_ARM_SOFT_FLOAT;\n#elif defined TCC_TARGET_ARM\n    ehdr.e_ident[EI_OSABI] = ELFOSABI_ARM;\n#elif defined TCC_TARGET_RISCV64\n    /* XXX should be configurable */\n    ehdr.e_flags = EF_RISCV_FLOAT_ABI_DOUBLE;\n#endif\n\n    if (file_type == TCC_OUTPUT_OBJ) {\n        ehdr.e_type = ET_REL;\n    } else {\n        if (file_type & TCC_OUTPUT_DYN)\n            ehdr.e_type = ET_DYN;\n        else\n            ehdr.e_type = ET_EXEC;\n        if (s1->elf_entryname)\n            ehdr.e_entry = get_sym_addr(s1, s1->elf_entryname, 1, 0);\n        else\n            ehdr.e_entry = get_sym_addr(s1, \"_start\", !!(file_type & TCC_OUTPUT_EXE), 0);\n        if (ehdr.e_entry == (addr_t)-1)\n            ehdr.e_entry = text_section->sh_addr;\n        if (s1->nb_errors)\n            return -1;\n    }\n\n    sort_syms(s1, s1->symtab);\n\n    ehdr.e_machine = EM_TCC_TARGET;\n    ehdr.e_version = EV_CURRENT;\n    ehdr.e_shoff = (sizeof(ElfW(Ehdr)) + phnum * sizeof(ElfW(Phdr)) + 3) & -4;\n    ehdr.e_ehsize = sizeof(ElfW(Ehdr));\n    ehdr.e_shentsize = sizeof(ElfW(Shdr));\n    ehdr.e_shnum = shnum;\n    ehdr.e_shstrndx = shnum - 1;\n\n    offset = fwrite(&ehdr, 1, sizeof(ElfW(Ehdr)), f);\n    if (phdr)\n        offset += fwrite(phdr, 1, phnum * sizeof(ElfW(Phdr)), f);\n\n    /* output section headers */\n    while (offset < ehdr.e_shoff) {\n        fputc(0, f);\n        offset++;\n    }\n\n    for(i = 0; i < shnum; i++) {\n        sh = &shdr;\n        memset(sh, 0, sizeof(ElfW(Shdr)));\n        if (i) {\n            s = s1->sections[i];\n            sh->sh_name = s->sh_name;\n            sh->sh_type = s->sh_type;\n            sh->sh_flags = s->sh_flags;\n            sh->sh_entsize = s->sh_entsize;\n            sh->sh_info = s->sh_info;\n            if (s->link)\n                sh->sh_link = s->link->sh_num;\n            sh->sh_addralign = s->sh_addralign;\n            sh->sh_addr = s->sh_addr;\n            sh->sh_offset = s->sh_offset;\n            sh->sh_size = s->sh_size;\n        }\n        offset += fwrite(sh, 1, sizeof(ElfW(Shdr)), f);\n    }\n\n    /* output sections */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_NOBITS) {\n            while (offset < s->sh_offset) {\n                fputc(0, f);\n                offset++;\n            }\n            size = s->sh_size;\n            if (size)\n                offset += fwrite(s->data, 1, size, f);\n        }\n    }\n    return 0;\n}\n\nstatic int tcc_output_binary(TCCState *s1, FILE *f)\n{\n    Section *s;\n    int i, offset, size;\n\n    offset = 0;\n    for(i=1;i<s1->nb_sections;i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_NOBITS &&\n            (s->sh_flags & SHF_ALLOC)) {\n            while (offset < s->sh_offset) {\n                fputc(0, f);\n                offset++;\n            }\n            size = s->sh_size;\n            fwrite(s->data, 1, size, f);\n            offset += size;\n        }\n    }\n    return 0;\n}\n\n/* Write an elf, coff or \"binary\" file */\nstatic int tcc_write_elf_file(TCCState *s1, const char *filename, int phnum,\n                              ElfW(Phdr) *phdr)\n{\n    int fd, mode, file_type, ret;\n    FILE *f;\n\n    file_type = s1->output_type;\n    if (file_type == TCC_OUTPUT_OBJ)\n        mode = 0666;\n    else\n        mode = 0777;\n    unlink(filename);\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, mode);\n    if (fd < 0 || (f = fdopen(fd, \"wb\")) == NULL)\n        return tcc_error_noabort(\"could not write '%s: %s'\", filename, strerror(errno));\n    if (s1->verbose)\n        printf(\"<- %s\\n\", filename);\n#ifdef TCC_TARGET_COFF\n    if (s1->output_format == TCC_OUTPUT_FORMAT_COFF)\n        tcc_output_coff(s1, f);\n    else\n#endif\n    if (s1->output_format == TCC_OUTPUT_FORMAT_ELF)\n        ret = tcc_output_elf(s1, f, phnum, phdr);\n    else\n        ret = tcc_output_binary(s1, f);\n    fclose(f);\n\n    return ret;\n}\n\n#ifndef ELF_OBJ_ONLY\n/* order sections according to sec_order, remove sections\n   that we aren't going to output.  */\nstatic void reorder_sections(TCCState *s1, int *sec_order)\n{\n    int i, nnew, k, *backmap;\n    Section **snew, *s;\n    ElfW(Sym) *sym;\n\n    backmap = tcc_malloc(s1->nb_sections * sizeof(backmap[0]));\n    for (i = 0, nnew = 0, snew = NULL; i < s1->nb_sections; i++) {\n\tk = sec_order[i];\n\ts = s1->sections[k];\n\tif (!i || s->sh_name) {\n\t    backmap[k] = nnew;\n            dynarray_add(&snew, &nnew, s);\n\t} else {\n\t    backmap[k] = 0;\n            /* just remember to free them later */\n\t    dynarray_add(&s1->priv_sections, &s1->nb_priv_sections, s);\n\t}\n    }\n    for (i = 1; i < nnew; i++) {\n\ts = snew[i];\n        s->sh_num = i;\n        if (s->sh_type == SHT_RELX)\n            s->sh_info = backmap[s->sh_info];\n        else if (s->sh_type == SHT_SYMTAB || s->sh_type == SHT_DYNSYM)\n            for_each_elem(s, 1, sym, ElfW(Sym))\n                if (sym->st_shndx < s1->nb_sections)\n                    sym->st_shndx = backmap[sym->st_shndx];\n    }\n    tcc_free(s1->sections);\n    s1->sections = snew;\n    s1->nb_sections = nnew;\n    tcc_free(backmap);\n}\n\n#ifdef TCC_TARGET_ARM\nstatic void create_arm_attribute_section(TCCState *s1)\n{\n   // Needed for DLL support.\n    static const unsigned char arm_attr[] = {\n        0x41,                            // 'A'\n        0x2c, 0x00, 0x00, 0x00,          // size 0x2c\n        'a', 'e', 'a', 'b', 'i', 0x00,   // \"aeabi\"\n        0x01, 0x22, 0x00, 0x00, 0x00,    // 'File Attributes', size 0x22\n        0x05, 0x36, 0x00,                // 'CPU_name', \"6\"\n        0x06, 0x06,                      // 'CPU_arch', 'v6'\n        0x08, 0x01,                      // 'ARM_ISA_use', 'Yes'\n        0x09, 0x01,                      // 'THUMB_ISA_use', 'Thumb-1'\n        0x0a, 0x02,                      // 'FP_arch', 'VFPv2'\n        0x12, 0x04,                      // 'ABI_PCS_wchar_t', 4\n        0x14, 0x01,                      // 'ABI_FP_denormal', 'Needed'\n        0x15, 0x01,                      // 'ABI_FP_exceptions', 'Needed'\n        0x17, 0x03,                      // 'ABI_FP_number_model', 'IEEE 754'\n        0x18, 0x01,                      // 'ABI_align_needed', '8-byte'\n        0x19, 0x01,                      // 'ABI_align_preserved', '8-byte, except leaf SP'\n        0x1a, 0x02,                      // 'ABI_enum_size', 'int'\n        0x1c, 0x01,                      // 'ABI_VFP_args', 'VFP registers'\n        0x22, 0x01                       // 'CPU_unaligned_access', 'v6'\n    };\n    Section *attr = new_section(s1, \".ARM.attributes\", SHT_ARM_ATTRIBUTES, 0);\n    unsigned char *ptr = section_ptr_add(attr, sizeof(arm_attr));\n    attr->sh_addralign = 1;\n    memcpy(ptr, arm_attr, sizeof(arm_attr));\n    if (s1->float_abi != ARM_HARD_FLOAT) {\n        ptr[26] = 0x00; // 'FP_arch', 'No'\n        ptr[41] = 0x1e; // 'ABI_optimization_goals'\n        ptr[42] = 0x06; // 'Aggressive Debug'\n    }\n}\n#endif\n\n#if TARGETOS_OpenBSD || TARGETOS_NetBSD\nstatic Section *create_bsd_note_section(TCCState *s1,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tconst char *value)\n{\n    Section *s = find_section (s1, name);\n\n    if (s->data_offset == 0) {\n        char *ptr = section_ptr_add(s, sizeof(ElfW(Nhdr)) + 8 + 4);\n        ElfW(Nhdr) *note = (ElfW(Nhdr) *) ptr;\n\n        s->sh_type = SHT_NOTE;\n        note->n_namesz = 8;\n        note->n_descsz = 4;\n        note->n_type = ELF_NOTE_OS_GNU;\n\tstrcpy (ptr + sizeof(ElfW(Nhdr)), value);\n    }\n    return s;\n}\n#endif\n\nstatic void alloc_sec_names(TCCState *s1, int is_obj);\n\n/* Output an elf, coff or binary file */\n/* XXX: suppress unneeded sections */\nstatic int elf_output_file(TCCState *s1, const char *filename)\n{\n    int i, ret, file_type, *sec_order;\n    struct dyn_inf dyninf = {0};\n    Section *interp, *dynstr, *dynamic;\n    int textrel, got_sym, dt_flags_1;\n\n    file_type = s1->output_type;\n    s1->nb_errors = 0;\n    ret = -1;\n    interp = dynstr = dynamic = NULL;\n    sec_order = NULL;\n    dyninf.roinf = &dyninf._roinf;\n\n#ifdef TCC_TARGET_ARM\n    create_arm_attribute_section (s1);\n#endif\n\n#if TARGETOS_OpenBSD\n    dyninf.note = create_bsd_note_section (s1, \".note.openbsd.ident\", \"OpenBSD\");\n#endif\n\n#if TARGETOS_NetBSD\n    dyninf.note = create_bsd_note_section (s1, \".note.netbsd.ident\", \"NetBSD\");\n#endif\n\n#if TARGETOS_FreeBSD || TARGETOS_NetBSD\n    dyninf.roinf = NULL;\n#endif\n        /* if linking, also link in runtime libraries (libc, libgcc, etc.) */\n        tcc_add_runtime(s1);\n\tresolve_common_syms(s1);\n\n        if (!s1->static_link) {\n            if (file_type & TCC_OUTPUT_EXE) {\n                char *ptr;\n                /* allow override the dynamic loader */\n                const char *elfint = getenv(\"LD_SO\");\n                if (elfint == NULL)\n                    elfint = DEFAULT_ELFINTERP(s1);\n                /* add interpreter section only if executable */\n                interp = new_section(s1, \".interp\", SHT_PROGBITS, SHF_ALLOC);\n                interp->sh_addralign = 1;\n                ptr = section_ptr_add(interp, 1 + strlen(elfint));\n                strcpy(ptr, elfint);\n                dyninf.interp = interp;\n            }\n\n            /* add dynamic symbol table */\n            s1->dynsym = new_symtab(s1, \".dynsym\", SHT_DYNSYM, SHF_ALLOC,\n                                    \".dynstr\",\n                                    \".hash\", SHF_ALLOC);\n\t    /* Number of local symbols (readelf complains if not set) */\n\t    s1->dynsym->sh_info = 1;\n            dynstr = s1->dynsym->link;\n            /* add dynamic section */\n            dynamic = new_section(s1, \".dynamic\", SHT_DYNAMIC,\n                                  SHF_ALLOC | SHF_WRITE);\n            dynamic->link = dynstr;\n            dynamic->sh_entsize = sizeof(ElfW(Dyn));\n\n            got_sym = build_got(s1);\n            if (file_type & TCC_OUTPUT_EXE) {\n                bind_exe_dynsyms(s1, file_type & TCC_OUTPUT_DYN);\n                if (s1->nb_errors)\n                    goto the_end;\n            }\n            build_got_entries(s1, got_sym);\n            if (file_type & TCC_OUTPUT_EXE) {\n                bind_libs_dynsyms(s1);\n            } else {\n                /* shared library case: simply export all global symbols */\n                export_global_syms(s1);\n            }\n#if TCC_EH_FRAME\n\t    /* fill with initial data */\n\t    tcc_eh_frame_hdr(s1, 0);\n#endif\n\t    dyninf.gnu_hash = create_gnu_hash(s1);\n        } else {\n            build_got_entries(s1, 0);\n        }\n\tversion_add (s1);\n\n    textrel = set_sec_sizes(s1);\n\n    if (!s1->static_link) {\n        /* add a list of needed dlls */\n        for(i = 0; i < s1->nb_loaded_dlls; i++) {\n            DLLReference *dllref = s1->loaded_dlls[i];\n            if (dllref->level == 0)\n                put_dt(dynamic, DT_NEEDED, put_elf_str(dynstr, dllref->name));\n        }\n\n        if (s1->rpath)\n            put_dt(dynamic, s1->enable_new_dtags ? DT_RUNPATH : DT_RPATH,\n                   put_elf_str(dynstr, s1->rpath));\n\n        dt_flags_1 = DF_1_NOW;\n        if (file_type & TCC_OUTPUT_DYN) {\n            if (s1->soname)\n                put_dt(dynamic, DT_SONAME, put_elf_str(dynstr, s1->soname));\n            /* XXX: currently, since we do not handle PIC code, we\n               must relocate the readonly segments */\n            if (textrel)\n                put_dt(dynamic, DT_TEXTREL, 0);\n            if (file_type & TCC_OUTPUT_EXE)\n                dt_flags_1 = DF_1_NOW | DF_1_PIE;\n        }\n        put_dt(dynamic, DT_FLAGS, DF_BIND_NOW);\n        put_dt(dynamic, DT_FLAGS_1, dt_flags_1);\n        if (s1->symbolic)\n            put_dt(dynamic, DT_SYMBOLIC, 0);\n\n        dyninf.dynamic = dynamic;\n        dyninf.dynstr = dynstr;\n        /* remember offset and reserve space for 2nd call below */\n        dyninf.data_offset = dynamic->data_offset;\n        fill_dynamic(s1, &dyninf);\n        dynamic->sh_size = dynamic->data_offset;\n        dynstr->sh_size = dynstr->data_offset;\n    }\n\n    /* create and fill .shstrtab section */\n    alloc_sec_names(s1, 0);\n    /* this array is used to reorder sections in the output file */\n    sec_order = tcc_malloc(sizeof(int) * 2 * s1->nb_sections);\n    /* compute section to program header mapping */\n    layout_sections(s1, sec_order, &dyninf);\n\n        if (dynamic) {\n            /* put in GOT the dynamic section address and relocate PLT */\n            write32le(s1->got->data, dynamic->sh_addr);\n            if (file_type == TCC_OUTPUT_EXE\n                || (RELOCATE_DLLPLT && (file_type & TCC_OUTPUT_DYN)))\n                relocate_plt(s1);\n            /* relocate symbols in .dynsym now that final addresses are known */\n            relocate_syms(s1, s1->dynsym, 2);\n        }\n\n        /* if building executable or DLL, then relocate each section\n           except the GOT which is already relocated */\n        relocate_syms(s1, s1->symtab, 0);\n        if (s1->nb_errors != 0)\n            goto the_end;\n        relocate_sections(s1);\n        if (dynamic) {\n\t    update_reloc_sections (s1, &dyninf);\n            dynamic->data_offset = dyninf.data_offset;\n            fill_dynamic(s1, &dyninf);\n\t}\n        /* Perform relocation to GOT or PLT entries */\n        if (file_type == TCC_OUTPUT_EXE && s1->static_link)\n            fill_got(s1);\n        else if (s1->got)\n            fill_local_got_entries(s1);\n\n    if (dyninf.gnu_hash)\n        update_gnu_hash(s1, dyninf.gnu_hash);\n\n    reorder_sections(s1, sec_order);\n#if TCC_EH_FRAME\n    /* fill with final data */\n    tcc_eh_frame_hdr(s1, 1);\n#endif\n    /* Create the ELF file with name 'filename' */\n    ret = tcc_write_elf_file(s1, filename, dyninf.phnum, dyninf.phdr);\n the_end:\n    tcc_free(sec_order);\n    tcc_free(dyninf.phdr);\n    return ret;\n}\n#endif /* ndef ELF_OBJ_ONLY */\n\n/* Allocate strings for section names */\nstatic void alloc_sec_names(TCCState *s1, int is_obj)\n{\n    int i;\n    Section *s, *strsec;\n\n    strsec = new_section(s1, \".shstrtab\", SHT_STRTAB, 0);\n    put_elf_str(strsec, \"\");\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (is_obj)\n            s->sh_size = s->data_offset;\n\tif (s->sh_size || s == strsec || (s->sh_flags & SHF_ALLOC) || is_obj)\n            s->sh_name = put_elf_str(strsec, s->name);\n    }\n    strsec->sh_size = strsec->data_offset;\n}\n\n/* Output an elf .o file */\nstatic int elf_output_obj(TCCState *s1, const char *filename)\n{\n    Section *s;\n    int i, ret, file_offset;\n    s1->nb_errors = 0;\n    /* Allocate strings for section names */\n    alloc_sec_names(s1, 1);\n    file_offset = (sizeof (ElfW(Ehdr)) + 3) & -4;\n    file_offset += s1->nb_sections * sizeof(ElfW(Shdr));\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        file_offset = (file_offset + 15) & -16;\n        s->sh_offset = file_offset;\n        if (s->sh_type != SHT_NOBITS)\n            file_offset += s->sh_size;\n    }\n    /* Create the ELF file with name 'filename' */\n    ret = tcc_write_elf_file(s1, filename, 0, NULL);\n    return ret;\n}\n\nLIBTCCAPI int tcc_output_file(TCCState *s, const char *filename)\n{\n    if (s->test_coverage)\n        tcc_tcov_add_file(s, filename);\n    if (s->output_type == TCC_OUTPUT_OBJ)\n        return elf_output_obj(s, filename);\n#ifdef TCC_TARGET_PE\n    return  pe_output_file(s, filename);\n#elif defined TCC_TARGET_MACHO\n    return macho_output_file(s, filename);\n#else\n    return elf_output_file(s, filename);\n#endif\n}\n\nST_FUNC ssize_t full_read(int fd, void *buf, size_t count) {\n    char *cbuf = buf;\n    size_t rnum = 0;\n    while (1) {\n        ssize_t num = read(fd, cbuf, count-rnum);\n        if (num < 0) return num;\n        if (num == 0) return rnum;\n        rnum += num;\n        cbuf += num;\n    }\n}\n\nST_FUNC void *load_data(int fd, unsigned long file_offset, unsigned long size)\n{\n    void *data;\n\n    data = tcc_malloc(size);\n    lseek(fd, file_offset, SEEK_SET);\n    full_read(fd, data, size);\n    return data;\n}\n\ntypedef struct SectionMergeInfo {\n    Section *s;            /* corresponding existing section */\n    unsigned long offset;  /* offset of the new section in the existing section */\n    uint8_t new_section;       /* true if section 's' was added */\n    uint8_t link_once;         /* true if link once section */\n} SectionMergeInfo;\n\nST_FUNC int tcc_object_type(int fd, ElfW(Ehdr) *h)\n{\n    int size = full_read(fd, h, sizeof *h);\n    if (size == sizeof *h && 0 == memcmp(h, ELFMAG, 4)) {\n        if (h->e_type == ET_REL)\n            return AFF_BINTYPE_REL;\n        if (h->e_type == ET_DYN)\n            return AFF_BINTYPE_DYN;\n    } else if (size >= 8) {\n        if (0 == memcmp(h, ARMAG, 8))\n            return AFF_BINTYPE_AR;\n#ifdef TCC_TARGET_COFF\n        if (((struct filehdr*)h)->f_magic == COFF_C67_MAGIC)\n            return AFF_BINTYPE_C67;\n#endif\n    }\n    return 0;\n}\n\n/* load an object file and merge it with current files */\n/* XXX: handle correctly stab (debug) info */\nST_FUNC int tcc_load_object_file(TCCState *s1,\n                                int fd, unsigned long file_offset)\n{\n    ElfW(Ehdr) ehdr;\n    ElfW(Shdr) *shdr, *sh;\n    unsigned long size, offset, offseti;\n    int i, j, nb_syms, sym_index, ret, seencompressed;\n    char *strsec, *strtab;\n    int stab_index, stabstr_index;\n    int *old_to_new_syms;\n    char *sh_name, *name;\n    SectionMergeInfo *sm_table, *sm;\n    ElfW(Sym) *sym, *symtab;\n    ElfW_Rel *rel;\n    Section *s;\n\n    lseek(fd, file_offset, SEEK_SET);\n    if (tcc_object_type(fd, &ehdr) != AFF_BINTYPE_REL)\n        goto invalid;\n    /* test CPU specific stuff */\n    if (ehdr.e_ident[5] != ELFDATA2LSB ||\n        ehdr.e_machine != EM_TCC_TARGET) {\ninvalid:\n        return tcc_error_noabort(\"invalid object file\");\n    }\n    /* read sections */\n    shdr = load_data(fd, file_offset + ehdr.e_shoff,\n                     sizeof(ElfW(Shdr)) * ehdr.e_shnum);\n    sm_table = tcc_mallocz(sizeof(SectionMergeInfo) * ehdr.e_shnum);\n\n    /* load section names */\n    sh = &shdr[ehdr.e_shstrndx];\n    strsec = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);\n\n    /* load symtab and strtab */\n    old_to_new_syms = NULL;\n    symtab = NULL;\n    strtab = NULL;\n    nb_syms = 0;\n    seencompressed = 0;\n    stab_index = stabstr_index = 0;\n    ret = -1;\n\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        sh = &shdr[i];\n        if (sh->sh_type == SHT_SYMTAB) {\n            if (symtab) {\n                tcc_error_noabort(\"object must contain only one symtab\");\n                goto the_end;\n            }\n            nb_syms = sh->sh_size / sizeof(ElfW(Sym));\n            symtab = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);\n            sm_table[i].s = symtab_section;\n\n            /* now load strtab */\n            sh = &shdr[sh->sh_link];\n            strtab = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);\n        }\n\tif (sh->sh_flags & SHF_COMPRESSED)\n\t    seencompressed = 1;\n    }\n\n    /* now examine each section and try to merge its content with the\n       ones in memory */\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        /* no need to examine section name strtab */\n        if (i == ehdr.e_shstrndx)\n            continue;\n        sh = &shdr[i];\n\tif (sh->sh_type == SHT_RELX)\n\t  sh = &shdr[sh->sh_info];\n        /* ignore sections types we do not handle (plus relocs to those) */\n        sh_name = strsec + sh->sh_name;\n        if (0 == strncmp(sh_name, \".debug_\", 7)\n         || 0 == strncmp(sh_name, \".stab\", 5)) {\n\t    if (!s1->do_debug || seencompressed)\n\t        continue;\n#if !(TARGETOS_OpenBSD || TARGETOS_FreeBSD || TARGETOS_NetBSD)\n        } else if (0 == strncmp(sh_name, \".eh_frame\", 9)) {\n            if (NULL == eh_frame_section)\n                continue;\n#endif\n        } else\n        if (sh->sh_type != SHT_PROGBITS &&\n            sh->sh_type != SHT_NOTE &&\n            sh->sh_type != SHT_NOBITS &&\n            sh->sh_type != SHT_PREINIT_ARRAY &&\n            sh->sh_type != SHT_INIT_ARRAY &&\n            sh->sh_type != SHT_FINI_ARRAY\n#ifdef TCC_ARM_EABI\n            && sh->sh_type != SHT_ARM_EXIDX\n#endif\n#if TARGETOS_OpenBSD || TARGETOS_FreeBSD || TARGETOS_NetBSD\n            && sh->sh_type != SHT_X86_64_UNWIND\n#endif\n            )\n            continue;\n\n\tsh = &shdr[i];\n        sh_name = strsec + sh->sh_name;\n        if (sh->sh_addralign < 1)\n            sh->sh_addralign = 1;\n        /* find corresponding section, if any */\n        for(j = 1; j < s1->nb_sections;j++) {\n            s = s1->sections[j];\n            if (strcmp(s->name, sh_name))\n                continue;\n            if (sh->sh_type != s->sh_type\n                && strcmp (s->name, \".eh_frame\")\n                ) {\n                tcc_error_noabort(\"section type conflict: %s %02x <> %02x\", s->name, sh->sh_type, s->sh_type);\n                goto the_end;\n            }\n            if (!strncmp(sh_name, \".gnu.linkonce\", 13)) {\n                /* if a 'linkonce' section is already present, we\n                   do not add it again. It is a little tricky as\n                   symbols can still be defined in\n                   it. */\n                sm_table[i].link_once = 1;\n                goto next;\n            }\n            if (stab_section) {\n                if (s == stab_section)\n                    stab_index = i;\n                if (s == stab_section->link)\n                    stabstr_index = i;\n            }\n            goto found;\n        }\n        /* not found: create new section */\n        s = new_section(s1, sh_name, sh->sh_type, sh->sh_flags & ~SHF_GROUP);\n        /* take as much info as possible from the section. sh_link and\n           sh_info will be updated later */\n        s->sh_addralign = sh->sh_addralign;\n        s->sh_entsize = sh->sh_entsize;\n        sm_table[i].new_section = 1;\n    found:\n        /* align start of section */\n        s->data_offset += -s->data_offset & (sh->sh_addralign - 1);\n        if (sh->sh_addralign > s->sh_addralign)\n            s->sh_addralign = sh->sh_addralign;\n        sm_table[i].offset = s->data_offset;\n        sm_table[i].s = s;\n        /* concatenate sections */\n        size = sh->sh_size;\n        if (sh->sh_type != SHT_NOBITS) {\n            unsigned char *ptr;\n            lseek(fd, file_offset + sh->sh_offset, SEEK_SET);\n            ptr = section_ptr_add(s, size);\n            full_read(fd, ptr, size);\n        } else {\n            s->data_offset += size;\n        }\n        /* align end of section */\n        /* This is needed if we compile a c file after this */\n        if (s == text_section || s == data_section || s == rodata_section ||\n            s == bss_section || s == common_section)\n            s->data_offset += -s->data_offset & (s->sh_addralign - 1);\n    next: ;\n    }\n\n    /* gr relocate stab strings */\n    if (stab_index && stabstr_index) {\n        Stab_Sym *a, *b;\n        unsigned o;\n        s = sm_table[stab_index].s;\n        a = (Stab_Sym *)(s->data + sm_table[stab_index].offset);\n        b = (Stab_Sym *)(s->data + s->data_offset);\n        o = sm_table[stabstr_index].offset;\n        while (a < b) {\n            if (a->n_strx)\n                a->n_strx += o;\n            a++;\n        }\n    }\n\n    /* second short pass to update sh_link and sh_info fields of new\n       sections */\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        s = sm_table[i].s;\n        if (!s || !sm_table[i].new_section)\n            continue;\n        sh = &shdr[i];\n        if (sh->sh_link > 0)\n            s->link = sm_table[sh->sh_link].s;\n        if (sh->sh_type == SHT_RELX) {\n            s->sh_info = sm_table[sh->sh_info].s->sh_num;\n            /* update backward link */\n            s1->sections[s->sh_info]->reloc = s;\n        }\n    }\n\n    /* resolve symbols */\n    old_to_new_syms = tcc_mallocz(nb_syms * sizeof(int));\n\n    sym = symtab + 1;\n    for(i = 1; i < nb_syms; i++, sym++) {\n        if (sym->st_shndx != SHN_UNDEF &&\n            sym->st_shndx < SHN_LORESERVE) {\n            sm = &sm_table[sym->st_shndx];\n            if (sm->link_once) {\n                /* if a symbol is in a link once section, we use the\n                   already defined symbol. It is very important to get\n                   correct relocations */\n                if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL) {\n                    name = strtab + sym->st_name;\n                    sym_index = find_elf_sym(symtab_section, name);\n                    if (sym_index)\n                        old_to_new_syms[i] = sym_index;\n                }\n                continue;\n            }\n            /* if no corresponding section added, no need to add symbol */\n            if (!sm->s)\n                continue;\n            /* convert section number */\n            sym->st_shndx = sm->s->sh_num;\n            /* offset value */\n            sym->st_value += sm->offset;\n        }\n        /* add symbol */\n        name = strtab + sym->st_name;\n        sym_index = set_elf_sym(symtab_section, sym->st_value, sym->st_size,\n                                sym->st_info, sym->st_other,\n                                sym->st_shndx, name);\n        old_to_new_syms[i] = sym_index;\n    }\n\n    /* third pass to patch relocation entries */\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        s = sm_table[i].s;\n        if (!s)\n            continue;\n        sh = &shdr[i];\n        offset = sm_table[i].offset;\n        size = sh->sh_size;\n        switch(s->sh_type) {\n        case SHT_RELX:\n            /* take relocation offset information */\n            offseti = sm_table[sh->sh_info].offset;\n\t    for (rel = (ElfW_Rel *) s->data + (offset / sizeof(*rel));\n\t\t rel < (ElfW_Rel *) s->data + ((offset + size) / sizeof(*rel));\n\t\t rel++) {\n                int type;\n                unsigned sym_index;\n                /* convert symbol index */\n                type = ELFW(R_TYPE)(rel->r_info);\n                sym_index = ELFW(R_SYM)(rel->r_info);\n                /* NOTE: only one symtab assumed */\n                if (sym_index >= nb_syms)\n                    goto invalid_reloc;\n                sym_index = old_to_new_syms[sym_index];\n                /* ignore link_once in rel section. */\n                if (!sym_index && !sm_table[sh->sh_info].link_once\n#ifdef TCC_TARGET_ARM\n                    && type != R_ARM_V4BX\n#elif defined TCC_TARGET_RISCV64\n                    && type != R_RISCV_ALIGN\n                    && type != R_RISCV_RELAX\n#endif\n                   ) {\n                invalid_reloc:\n                    tcc_error_noabort(\"Invalid relocation entry [%2d] '%s' @ %.8x\",\n                        i, strsec + sh->sh_name, (int)rel->r_offset);\n                    goto the_end;\n                }\n                rel->r_info = ELFW(R_INFO)(sym_index, type);\n                /* offset the relocation offset */\n                rel->r_offset += offseti;\n#ifdef TCC_TARGET_ARM\n                /* Jumps and branches from a Thumb code to a PLT entry need\n                   special handling since PLT entries are ARM code.\n                   Unconditional bl instructions referencing PLT entries are\n                   handled by converting these instructions into blx\n                   instructions. Other case of instructions referencing a PLT\n                   entry require to add a Thumb stub before the PLT entry to\n                   switch to ARM mode. We set bit plt_thumb_stub of the\n                   attribute of a symbol to indicate such a case. */\n                if (type == R_ARM_THM_JUMP24)\n                    get_sym_attr(s1, sym_index, 1)->plt_thumb_stub = 1;\n#endif\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    ret = 0;\n the_end:\n    tcc_free(symtab);\n    tcc_free(strtab);\n    tcc_free(old_to_new_syms);\n    tcc_free(sm_table);\n    tcc_free(strsec);\n    tcc_free(shdr);\n    return ret;\n}\n\ntypedef struct ArchiveHeader {\n    char ar_name[16];           /* name of this member */\n    char ar_date[12];           /* file mtime */\n    char ar_uid[6];             /* owner uid; printed as decimal */\n    char ar_gid[6];             /* owner gid; printed as decimal */\n    char ar_mode[8];            /* file mode, printed as octal   */\n    char ar_size[10];           /* file size, printed as decimal */\n    char ar_fmag[2];            /* should contain ARFMAG */\n} ArchiveHeader;\n\n#define ARFMAG \"`\\n\"\n\nstatic unsigned long long get_be(const uint8_t *b, int n)\n{\n    unsigned long long ret = 0;\n    while (n)\n        ret = (ret << 8) | *b++, --n;\n    return ret;\n}\n\nstatic int read_ar_header(int fd, int offset, ArchiveHeader *hdr)\n{\n    char *p, *e;\n    int len;\n    lseek(fd, offset, SEEK_SET);\n    len = full_read(fd, hdr, sizeof(ArchiveHeader));\n    if (len != sizeof(ArchiveHeader))\n        return len ? -1 : 0;\n    if (memcmp(hdr->ar_fmag, ARFMAG, sizeof hdr->ar_fmag))\n        return -1;\n    p = hdr->ar_name;\n    for (e = p + sizeof hdr->ar_name; e > p && e[-1] == ' ';)\n        --e;\n    *e = '\\0';\n    hdr->ar_size[sizeof hdr->ar_size-1] = 0;\n    return len;\n}\n\n/* load only the objects which resolve undefined symbols */\nstatic int tcc_load_alacarte(TCCState *s1, int fd, int size, int entrysize)\n{\n    int i, bound, nsyms, sym_index, len, ret = -1;\n    unsigned long long off;\n    uint8_t *data;\n    const char *ar_names, *p;\n    const uint8_t *ar_index;\n    ElfW(Sym) *sym;\n    ArchiveHeader hdr;\n\n    data = tcc_malloc(size);\n    if (full_read(fd, data, size) != size)\n        goto invalid;\n    nsyms = get_be(data, entrysize);\n    ar_index = data + entrysize;\n    ar_names = (char *) ar_index + nsyms * entrysize;\n\n    do {\n        bound = 0;\n        for (p = ar_names, i = 0; i < nsyms; i++, p += strlen(p)+1) {\n            Section *s = symtab_section;\n            sym_index = find_elf_sym(s, p);\n            if (!sym_index)\n                continue;\n            sym = &((ElfW(Sym) *)s->data)[sym_index];\n            if(sym->st_shndx != SHN_UNDEF)\n                continue;\n            off = get_be(ar_index + i * entrysize, entrysize);\n            len = read_ar_header(fd, off, &hdr);\n            if (len <= 0 || memcmp(hdr.ar_fmag, ARFMAG, 2)) {\n        invalid:\n                tcc_error_noabort(\"invalid archive\");\n                goto the_end;\n            }\n            off += len;\n            if (s1->verbose == 2)\n                printf(\"   -> %s\\n\", hdr.ar_name);\n            if (tcc_load_object_file(s1, fd, off) < 0)\n                goto the_end;\n            ++bound;\n        }\n    } while(bound);\n    ret = 0;\n the_end:\n    tcc_free(data);\n    return ret;\n}\n\n/* load a '.a' file */\nST_FUNC int tcc_load_archive(TCCState *s1, int fd, int alacarte)\n{\n    ArchiveHeader hdr;\n    /* char magic[8]; */\n    int size, len;\n    unsigned long file_offset;\n    ElfW(Ehdr) ehdr;\n\n    /* skip magic which was already checked */\n    /* full_read(fd, magic, sizeof(magic)); */\n    file_offset = sizeof ARMAG - 1;\n\n    for(;;) {\n        len = read_ar_header(fd, file_offset, &hdr);\n        if (len == 0)\n            return 0;\n        if (len < 0)\n            return tcc_error_noabort(\"invalid archive\");\n        file_offset += len;\n        size = strtol(hdr.ar_size, NULL, 0);\n        if (alacarte) {\n            /* coff symbol table : we handle it */\n            if (!strcmp(hdr.ar_name, \"/\"))\n                return tcc_load_alacarte(s1, fd, size, 4);\n            if (!strcmp(hdr.ar_name, \"/SYM64/\"))\n                return tcc_load_alacarte(s1, fd, size, 8);\n        } else if (tcc_object_type(fd, &ehdr) == AFF_BINTYPE_REL) {\n            if (s1->verbose == 2)\n                printf(\"   -> %s\\n\", hdr.ar_name);\n            if (tcc_load_object_file(s1, fd, file_offset) < 0)\n                return -1;\n        }\n        /* align to even */\n        file_offset = (file_offset + size + 1) & ~1;\n    }\n}\n\n#ifndef ELF_OBJ_ONLY\n/* Set LV[I] to the global index of sym-version (LIB,VERSION).  Maybe resizes\n   LV, maybe create a new entry for (LIB,VERSION).  */\nstatic void set_ver_to_ver(TCCState *s1, int *n, int **lv, int i, char *lib, char *version)\n{\n    while (i >= *n) {\n        *lv = tcc_realloc(*lv, (*n + 1) * sizeof(**lv));\n        (*lv)[(*n)++] = -1;\n    }\n    if ((*lv)[i] == -1) {\n        int v, prev_same_lib = -1;\n        for (v = 0; v < nb_sym_versions; v++) {\n            if (strcmp(sym_versions[v].lib, lib))\n              continue;\n            prev_same_lib = v;\n            if (!strcmp(sym_versions[v].version, version))\n              break;\n        }\n        if (v == nb_sym_versions) {\n            sym_versions = tcc_realloc (sym_versions,\n                                        (v + 1) * sizeof(*sym_versions));\n            sym_versions[v].lib = tcc_strdup(lib);\n            sym_versions[v].version = tcc_strdup(version);\n            sym_versions[v].out_index = 0;\n            sym_versions[v].prev_same_lib = prev_same_lib;\n            nb_sym_versions++;\n        }\n        (*lv)[i] = v;\n    }\n}\n\n/* Associates symbol SYM_INDEX (in dynsymtab) with sym-version index\n   VERNDX.  */\nstatic void\nset_sym_version(TCCState *s1, int sym_index, int verndx)\n{\n    if (sym_index >= nb_sym_to_version) {\n        int newelems = sym_index ? sym_index * 2 : 1;\n        sym_to_version = tcc_realloc(sym_to_version,\n                                     newelems * sizeof(*sym_to_version));\n        memset(sym_to_version + nb_sym_to_version, -1,\n               (newelems - nb_sym_to_version) * sizeof(*sym_to_version));\n        nb_sym_to_version = newelems;\n    }\n    if (sym_to_version[sym_index] < 0)\n      sym_to_version[sym_index] = verndx;\n}\n\nstruct versym_info {\n    int nb_versyms;\n    ElfW(Verdef) *verdef;\n    ElfW(Verneed) *verneed;\n    ElfW(Half) *versym;\n    int nb_local_ver, *local_ver;\n};\n\n\nstatic void store_version(TCCState *s1, struct versym_info *v, char *dynstr)\n{\n    char *lib, *version;\n    uint32_t next;\n    int i;\n\n#define\tDEBUG_VERSION 0\n\n    if (v->versym && v->verdef) {\n      ElfW(Verdef) *vdef = v->verdef;\n      lib = NULL;\n      do {\n        ElfW(Verdaux) *verdaux =\n\t  (ElfW(Verdaux) *) (((char *) vdef) + vdef->vd_aux);\n\n#if DEBUG_VERSION\n\tprintf (\"verdef: version:%u flags:%u index:%u, hash:%u\\n\",\n\t        vdef->vd_version, vdef->vd_flags, vdef->vd_ndx,\n\t\tvdef->vd_hash);\n#endif\n\tif (vdef->vd_cnt) {\n          version = dynstr + verdaux->vda_name;\n\n\t  if (lib == NULL)\n\t    lib = version;\n\t  else\n            set_ver_to_ver(s1, &v->nb_local_ver, &v->local_ver, vdef->vd_ndx,\n                           lib, version);\n#if DEBUG_VERSION\n\t  printf (\"  verdaux(%u): %s\\n\", vdef->vd_ndx, version);\n#endif\n\t}\n        next = vdef->vd_next;\n        vdef = (ElfW(Verdef) *) (((char *) vdef) + next);\n      } while (next);\n    }\n    if (v->versym && v->verneed) {\n      ElfW(Verneed) *vneed = v->verneed;\n      do {\n        ElfW(Vernaux) *vernaux =\n\t  (ElfW(Vernaux) *) (((char *) vneed) + vneed->vn_aux);\n\n        lib = dynstr + vneed->vn_file;\n#if DEBUG_VERSION\n\tprintf (\"verneed: %u %s\\n\", vneed->vn_version, lib);\n#endif\n\tfor (i = 0; i < vneed->vn_cnt; i++) {\n\t  if ((vernaux->vna_other & 0x8000) == 0) { /* hidden */\n              version = dynstr + vernaux->vna_name;\n              set_ver_to_ver(s1, &v->nb_local_ver, &v->local_ver, vernaux->vna_other,\n                             lib, version);\n#if DEBUG_VERSION\n\t    printf (\"  vernaux(%u): %u %u %s\\n\",\n\t\t    vernaux->vna_other, vernaux->vna_hash,\n\t\t    vernaux->vna_flags, version);\n#endif\n\t  }\n\t  vernaux = (ElfW(Vernaux) *) (((char *) vernaux) + vernaux->vna_next);\n\t}\n        next = vneed->vn_next;\n        vneed = (ElfW(Verneed) *) (((char *) vneed) + next);\n      } while (next);\n    }\n\n#if DEBUG_VERSION\n    for (i = 0; i < v->nb_local_ver; i++) {\n      if (v->local_ver[i] > 0) {\n        printf (\"%d: lib: %s, version %s\\n\",\n\t\ti, sym_versions[v->local_ver[i]].lib,\n                sym_versions[v->local_ver[i]].version);\n      }\n    }\n#endif\n}\n\n/* load a library / DLL\n   'level = 0' means that the DLL is referenced by the user\n   (so it should be added as DT_NEEDED in the generated ELF file) */\nST_FUNC int tcc_load_dll(TCCState *s1, int fd, const char *filename, int level)\n{\n    ElfW(Ehdr) ehdr;\n    ElfW(Shdr) *shdr, *sh, *sh1;\n    int i, nb_syms, nb_dts, sym_bind, ret = -1;\n    ElfW(Sym) *sym, *dynsym;\n    ElfW(Dyn) *dt, *dynamic;\n\n    char *dynstr;\n    int sym_index;\n    const char *name, *soname;\n    struct versym_info v;\n\n    full_read(fd, &ehdr, sizeof(ehdr));\n\n    /* test CPU specific stuff */\n    if (ehdr.e_ident[5] != ELFDATA2LSB ||\n        ehdr.e_machine != EM_TCC_TARGET) {\n        return tcc_error_noabort(\"bad architecture\");\n    }\n\n    /* read sections */\n    shdr = load_data(fd, ehdr.e_shoff, sizeof(ElfW(Shdr)) * ehdr.e_shnum);\n\n    /* load dynamic section and dynamic symbols */\n    nb_syms = 0;\n    nb_dts = 0;\n    dynamic = NULL;\n    dynsym = NULL; /* avoid warning */\n    dynstr = NULL; /* avoid warning */\n    memset(&v, 0, sizeof v);\n\n    for(i = 0, sh = shdr; i < ehdr.e_shnum; i++, sh++) {\n        switch(sh->sh_type) {\n        case SHT_DYNAMIC:\n            nb_dts = sh->sh_size / sizeof(ElfW(Dyn));\n            dynamic = load_data(fd, sh->sh_offset, sh->sh_size);\n            break;\n        case SHT_DYNSYM:\n            nb_syms = sh->sh_size / sizeof(ElfW(Sym));\n            dynsym = load_data(fd, sh->sh_offset, sh->sh_size);\n            sh1 = &shdr[sh->sh_link];\n            dynstr = load_data(fd, sh1->sh_offset, sh1->sh_size);\n            break;\n        case SHT_GNU_verdef:\n\t    v.verdef = load_data(fd, sh->sh_offset, sh->sh_size);\n\t    break;\n        case SHT_GNU_verneed:\n\t    v.verneed = load_data(fd, sh->sh_offset, sh->sh_size);\n\t    break;\n        case SHT_GNU_versym:\n            v.nb_versyms = sh->sh_size / sizeof(ElfW(Half));\n\t    v.versym = load_data(fd, sh->sh_offset, sh->sh_size);\n\t    break;\n        default:\n            break;\n        }\n    }\n\n    if (!dynamic)\n        goto the_end;\n\n    /* compute the real library name */\n    soname = tcc_basename(filename);\n    for(i = 0, dt = dynamic; i < nb_dts; i++, dt++)\n        if (dt->d_tag == DT_SONAME)\n            soname = dynstr + dt->d_un.d_val;\n\n    /* if the dll is already loaded, do not load it */\n    if (tcc_add_dllref(s1, soname, level)->found)\n        goto ret_success;\n\n    if (v.nb_versyms != nb_syms)\n        tcc_free (v.versym), v.versym = NULL;\n    else\n        store_version(s1, &v, dynstr);\n\n    /* add dynamic symbols in dynsym_section */\n    for(i = 1, sym = dynsym + 1; i < nb_syms; i++, sym++) {\n        sym_bind = ELFW(ST_BIND)(sym->st_info);\n        if (sym_bind == STB_LOCAL)\n            continue;\n        name = dynstr + sym->st_name;\n        sym_index = set_elf_sym(s1->dynsymtab_section, sym->st_value, sym->st_size,\n                                sym->st_info, sym->st_other, sym->st_shndx, name);\n        if (v.versym) {\n            ElfW(Half) vsym = v.versym[i];\n            if ((vsym & 0x8000) == 0 && vsym > 0 && vsym < v.nb_local_ver)\n                set_sym_version(s1, sym_index, v.local_ver[vsym]);\n        }\n    }\n\n    /* do not load all referenced libraries\n       (recursive loading can break linking of libraries) */\n    /* following DT_NEEDED is needed for the dynamic loader (libdl.so),\n       but it is no longer needed, when linking a library or a program.\n       When tcc output mode is OUTPUT_MEM,\n       tcc calls dlopen, which handles DT_NEEDED for us */\n\n#if 0\n    for(i = 0, dt = dynamic; i < nb_dts; i++, dt++)\n        if (dt->d_tag == DT_RPATH)\n            tcc_add_library_path(s1, dynstr + dt->d_un.d_val);\n\n    /* load all referenced DLLs */\n    for(i = 0, dt = dynamic; i < nb_dts; i++, dt++) {\n        switch(dt->d_tag) {\n        case DT_NEEDED:\n            name = dynstr + dt->d_un.d_val;\n            if (tcc_add_dllref(s1, name, -1))\n                continue;\n            if (tcc_add_dll(s1, name, AFF_REFERENCED_DLL) < 0) {\n                ret = tcc_error_noabort(\"referenced dll '%s' not found\", name);\n                goto the_end;\n            }\n        }\n    }\n#endif\n\n ret_success:\n    ret = 0;\n the_end:\n    tcc_free(dynstr);\n    tcc_free(dynsym);\n    tcc_free(dynamic);\n    tcc_free(shdr);\n    tcc_free(v.local_ver);\n    tcc_free(v.verdef);\n    tcc_free(v.verneed);\n    tcc_free(v.versym);\n    return ret;\n}\n\n#define LD_TOK_NAME 256\n#define LD_TOK_EOF  (-1)\n\nstatic int ld_inp(TCCState *s1)\n{\n    char b;\n    if (s1->cc != -1) {\n        int c = s1->cc;\n        s1->cc = -1;\n        return c;\n    }\n    if (1 == read(s1->fd, &b, 1))\n        return b;\n    return CH_EOF;\n}\n\n/* return next ld script token */\nstatic int ld_next(TCCState *s1, char *name, int name_size)\n{\n    int c, d, ch;\n    char *q;\n\n redo:\n    ch = ld_inp(s1);\n    switch(ch) {\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\v':\n    case '\\r':\n    case '\\n':\n        goto redo;\n    case '/':\n        ch = ld_inp(s1);\n        if (ch == '*') { /* comment */\n            for (d = 0;; d = ch) {\n                ch = ld_inp(s1);\n                if (ch == CH_EOF || (ch == '/' && d == '*'))\n                    break;\n            }\n            goto redo;\n        } else {\n            q = name;\n            *q++ = '/';\n            goto parse_name;\n        }\n        break;\n    case '\\\\':\n    /* case 'a' ... 'z': */\n    case 'a':\n       case 'b':\n       case 'c':\n       case 'd':\n       case 'e':\n       case 'f':\n       case 'g':\n       case 'h':\n       case 'i':\n       case 'j':\n       case 'k':\n       case 'l':\n       case 'm':\n       case 'n':\n       case 'o':\n       case 'p':\n       case 'q':\n       case 'r':\n       case 's':\n       case 't':\n       case 'u':\n       case 'v':\n       case 'w':\n       case 'x':\n       case 'y':\n       case 'z':\n    /* case 'A' ... 'z': */\n    case 'A':\n       case 'B':\n       case 'C':\n       case 'D':\n       case 'E':\n       case 'F':\n       case 'G':\n       case 'H':\n       case 'I':\n       case 'J':\n       case 'K':\n       case 'L':\n       case 'M':\n       case 'N':\n       case 'O':\n       case 'P':\n       case 'Q':\n       case 'R':\n       case 'S':\n       case 'T':\n       case 'U':\n       case 'V':\n       case 'W':\n       case 'X':\n       case 'Y':\n       case 'Z':\n    case '_':\n    case '.':\n    case '$':\n    case '~':\n        q = name;\n    parse_name:\n        for(;;) {\n            if (!((ch >= 'a' && ch <= 'z') ||\n                  (ch >= 'A' && ch <= 'Z') ||\n                  (ch >= '0' && ch <= '9') ||\n                  strchr(\"/.-_+=$:\\\\,~\", ch)))\n                break;\n            if ((q - name) < name_size - 1) {\n                *q++ = ch;\n            }\n            ch = ld_inp(s1);\n        }\n        s1->cc = ch;\n        *q = '\\0';\n        c = LD_TOK_NAME;\n        break;\n    case CH_EOF:\n        c = LD_TOK_EOF;\n        break;\n    default:\n        c = ch;\n        break;\n    }\n    return c;\n}\n\nstatic int ld_add_file(TCCState *s1, const char filename[])\n{\n    if (filename[0] == '/') {\n        if (CONFIG_SYSROOT[0] == '\\0'\n            && tcc_add_file_internal(s1, filename, AFF_TYPE_BIN) == 0)\n            return 0;\n        filename = tcc_basename(filename);\n    }\n    return tcc_add_dll(s1, filename, AFF_PRINT_ERROR);\n}\n\nstatic int ld_add_file_list(TCCState *s1, const char *cmd, int as_needed)\n{\n    char filename[1024], libname[1016];\n    int t, group, nblibs = 0, ret = 0;\n    char **libs = NULL;\n\n    group = !strcmp(cmd, \"GROUP\");\n    if (!as_needed)\n        s1->new_undef_sym = 0;\n    t = ld_next(s1, filename, sizeof(filename));\n    if (t != '(') {\n        ret = tcc_error_noabort(\"( expected\");\n        goto lib_parse_error;\n    }\n    t = ld_next(s1, filename, sizeof(filename));\n    for(;;) {\n        libname[0] = '\\0';\n        if (t == LD_TOK_EOF) {\n            ret = tcc_error_noabort(\"unexpected end of file\");\n            goto lib_parse_error;\n        } else if (t == ')') {\n            break;\n        } else if (t == '-') {\n            t = ld_next(s1, filename, sizeof(filename));\n            if ((t != LD_TOK_NAME) || (filename[0] != 'l')) {\n                ret = tcc_error_noabort(\"library name expected\");\n                goto lib_parse_error;\n            }\n            pstrcpy(libname, sizeof libname, &filename[1]);\n            if (s1->static_link) {\n                snprintf(filename, sizeof filename, \"lib%s.a\", libname);\n            } else {\n                snprintf(filename, sizeof filename, \"lib%s.so\", libname);\n            }\n        } else if (t != LD_TOK_NAME) {\n            ret = tcc_error_noabort(\"filename expected\");\n            goto lib_parse_error;\n        }\n        if (!strcmp(filename, \"AS_NEEDED\")) {\n            ret = ld_add_file_list(s1, cmd, 1);\n            if (ret)\n                goto lib_parse_error;\n        } else {\n            /* TODO: Implement AS_NEEDED support. */\n\t    /*       DT_NEEDED is not used any more so ignore as_needed */\n            if (1 || !as_needed) {\n                ret = ld_add_file(s1, filename);\n                if (ret)\n                    goto lib_parse_error;\n                if (group) {\n                    /* Add the filename *and* the libname to avoid future conversions */\n                    dynarray_add(&libs, &nblibs, tcc_strdup(filename));\n                    if (libname[0] != '\\0')\n                        dynarray_add(&libs, &nblibs, tcc_strdup(libname));\n                }\n            }\n        }\n        t = ld_next(s1, filename, sizeof(filename));\n        if (t == ',') {\n            t = ld_next(s1, filename, sizeof(filename));\n        }\n    }\n    if (group && !as_needed) {\n        while (s1->new_undef_sym) {\n            int i;\n            s1->new_undef_sym = 0;\n            for (i = 0; i < nblibs; i ++)\n                ld_add_file(s1, libs[i]);\n        }\n    }\nlib_parse_error:\n    dynarray_reset(&libs, &nblibs);\n    return ret;\n}\n\n/* interpret a subset of GNU ldscripts to handle the dummy libc.so\n   files */\nST_FUNC int tcc_load_ldscript(TCCState *s1, int fd)\n{\n    char cmd[64];\n    char filename[1024];\n    int t, ret;\n\n    s1->fd = fd;\n    s1->cc = -1;\n    for(;;) {\n        t = ld_next(s1, cmd, sizeof(cmd));\n        if (t == LD_TOK_EOF)\n            return 0;\n        else if (t != LD_TOK_NAME)\n            return -1;\n        if (!strcmp(cmd, \"INPUT\") ||\n            !strcmp(cmd, \"GROUP\")) {\n            ret = ld_add_file_list(s1, cmd, 0);\n            if (ret)\n                return ret;\n        } else if (!strcmp(cmd, \"OUTPUT_FORMAT\") ||\n                   !strcmp(cmd, \"TARGET\")) {\n            /* ignore some commands */\n            t = ld_next(s1, cmd, sizeof(cmd));\n            if (t != '(')\n                return tcc_error_noabort(\"( expected\");\n            for(;;) {\n                t = ld_next(s1, filename, sizeof(filename));\n                if (t == LD_TOK_EOF) {\n                    return tcc_error_noabort(\"unexpected end of file\");\n                } else if (t == ')') {\n                    break;\n                }\n            }\n        } else {\n            return -1;\n        }\n    }\n    return 0;\n}\n#endif /* !ELF_OBJ_ONLY */\n"
        },
        {
          "name": "tccgen.c",
          "type": "blob",
          "size": 255.0400390625,
          "content": "/*\n *  TCC - Tiny C Compiler\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define USING_GLOBALS\n#include \"tcc.h\"\n\n/********************************************************/\n/* global variables */\n\n/* loc : local variable index\n   ind : output code index\n   rsym: return symbol\n   anon_sym: anonymous symbol index\n*/\nST_DATA int rsym, anon_sym, ind, loc;\n\nST_DATA Sym *global_stack;\nST_DATA Sym *local_stack;\nST_DATA Sym *define_stack;\nST_DATA Sym *global_label_stack;\nST_DATA Sym *local_label_stack;\n\nstatic Sym *sym_free_first;\nstatic void **sym_pools;\nstatic int nb_sym_pools;\n\nstatic Sym *all_cleanups, *pending_gotos;\nstatic int local_scope;\nST_DATA char debug_modes;\n\nST_DATA SValue *vtop;\nstatic SValue _vstack[1 + VSTACK_SIZE];\n#define vstack (_vstack + 1)\n\nST_DATA int nocode_wanted; /* no code generation wanted */\n#define NODATA_WANTED (nocode_wanted > 0) /* no static data output wanted either */\n#define DATA_ONLY_WANTED 0x80000000 /* ON outside of functions and for static initializers */\n\n/* no code output after unconditional jumps such as with if (0) ... */\n#define CODE_OFF_BIT 0x20000000\n#define CODE_OFF() if(!nocode_wanted)(nocode_wanted |= CODE_OFF_BIT)\n#define CODE_ON() (nocode_wanted &= ~CODE_OFF_BIT)\n\n/* no code output when parsing sizeof()/typeof() etc. (using nocode_wanted++/--) */\n#define NOEVAL_MASK 0x0000FFFF\n#define NOEVAL_WANTED (nocode_wanted & NOEVAL_MASK)\n\n/* no code output when parsing constant expressions */\n#define CONST_WANTED_BIT  0x00010000\n#define CONST_WANTED_MASK 0x0FFF0000\n#define CONST_WANTED  (nocode_wanted & CONST_WANTED_MASK)\n\nST_DATA int global_expr;  /* true if compound literals must be allocated globally (used during initializers parsing */\nST_DATA CType func_vt; /* current function return type (used by return instruction) */\nST_DATA int func_var; /* true if current function is variadic (used by return instruction) */\nST_DATA int func_vc;\nST_DATA int func_ind;\nST_DATA const char *funcname;\nST_DATA CType int_type, func_old_type, char_type, char_pointer_type;\nstatic CString initstr;\n\n#if PTR_SIZE == 4\n#define VT_SIZE_T (VT_INT | VT_UNSIGNED)\n#define VT_PTRDIFF_T VT_INT\n#elif LONG_SIZE == 4\n#define VT_SIZE_T (VT_LLONG | VT_UNSIGNED)\n#define VT_PTRDIFF_T VT_LLONG\n#else\n#define VT_SIZE_T (VT_LONG | VT_LLONG | VT_UNSIGNED)\n#define VT_PTRDIFF_T (VT_LONG | VT_LLONG)\n#endif\n\nstatic struct switch_t {\n    struct case_t {\n        int64_t v1, v2;\n        int ind, line;\n    } **p; int n; /* list of case ranges */\n    int def_sym; /* default symbol */\n    int nocode_wanted;\n    int *bsym;\n    struct scope *scope;\n    struct switch_t *prev;\n    SValue sv;\n} *cur_switch; /* current switch */\n\n#define MAX_TEMP_LOCAL_VARIABLE_NUMBER 8\n/*list of temporary local variables on the stack in current function. */\nstatic struct temp_local_variable {\n\tint location; //offset on stack. Svalue.c.i\n\tshort size;\n\tshort align;\n} arr_temp_local_vars[MAX_TEMP_LOCAL_VARIABLE_NUMBER];\nstatic int nb_temp_local_vars;\n\nstatic struct scope {\n    struct scope *prev;\n    struct { int loc, locorig, num; } vla;\n    struct { Sym *s; int n; } cl;\n    int *bsym, *csym;\n    Sym *lstk, *llstk;\n} *cur_scope, *loop_scope, *root_scope;\n\ntypedef struct {\n    Section *sec;\n    int local_offset;\n    Sym *flex_array_ref;\n} init_params;\n\n#if 1\n#define precedence_parser\nstatic void init_prec(void);\n#endif\n\nstatic void block(int flags);\n#define STMT_EXPR 1\n#define STMT_COMPOUND 2\n\nstatic void gen_cast(CType *type);\nstatic void gen_cast_s(int t);\nstatic inline CType *pointed_type(CType *type);\nstatic int is_compatible_types(CType *type1, CType *type2);\nstatic int parse_btype(CType *type, AttributeDef *ad, int ignore_label);\nstatic CType *type_decl(CType *type, AttributeDef *ad, int *v, int td);\nstatic void parse_expr_type(CType *type);\nstatic void init_putv(init_params *p, CType *type, unsigned long c);\nstatic void decl_initializer(init_params *p, CType *type, unsigned long c, int flags);\nstatic void decl_initializer_alloc(CType *type, AttributeDef *ad, int r, int has_init, int v, int scope);\nstatic int decl(int l);\nstatic void expr_eq(void);\nstatic void vpush_type_size(CType *type, int *a);\nstatic int is_compatible_unqualified_types(CType *type1, CType *type2);\nstatic inline int64_t expr_const64(void);\nstatic void vpush64(int ty, unsigned long long v);\nstatic void vpush(CType *type);\nstatic int gvtst(int inv, int t);\nstatic void gen_inline_functions(TCCState *s);\nstatic void free_inline_functions(TCCState *s);\nstatic void skip_or_save_block(TokenString **str);\nstatic void gv_dup(void);\nstatic int get_temp_local_var(int size,int align,int *r2);\nstatic void cast_error(CType *st, CType *dt);\nstatic void end_switch(void);\nstatic void do_Static_assert(void);\n\n/* ------------------------------------------------------------------------- */\n/* Automagical code suppression */\n\n/* Clear 'nocode_wanted' at forward label if it was used */\nST_FUNC void gsym(int t)\n{\n  if (t) {\n    gsym_addr(t, ind);\n    CODE_ON();\n  }\n}\n\n/* Clear 'nocode_wanted' if current pc is a label */\nstatic int gind()\n{\n  int t = ind;\n  CODE_ON();\n  if (debug_modes)\n    tcc_tcov_block_begin(tcc_state);\n  return t;\n}\n\n/* Set 'nocode_wanted' after unconditional (backwards) jump */\nstatic void gjmp_addr_acs(int t)\n{\n  gjmp_addr(t);\n  CODE_OFF();\n}\n\n/* Set 'nocode_wanted' after unconditional (forwards) jump */\nstatic int gjmp_acs(int t)\n{\n  t = gjmp(t);\n  CODE_OFF();\n  return t;\n}\n\n/* These are #undef'd at the end of this file */\n#define gjmp_addr gjmp_addr_acs\n#define gjmp gjmp_acs\n/* ------------------------------------------------------------------------- */\n\nST_INLN int is_float(int t)\n{\n    int bt = t & VT_BTYPE;\n    return bt == VT_LDOUBLE\n        || bt == VT_DOUBLE\n        || bt == VT_FLOAT\n        || bt == VT_QFLOAT;\n}\n\nstatic inline int is_integer_btype(int bt)\n{\n    return bt == VT_BYTE\n        || bt == VT_BOOL\n        || bt == VT_SHORT\n        || bt == VT_INT\n        || bt == VT_LLONG;\n}\n\nstatic int btype_size(int bt)\n{\n    return bt == VT_BYTE || bt == VT_BOOL ? 1 :\n        bt == VT_SHORT ? 2 :\n        bt == VT_INT ? 4 :\n        bt == VT_LLONG ? 8 :\n        bt == VT_PTR ? PTR_SIZE : 0;\n}\n\n/* returns function return register from type */\nstatic int R_RET(int t)\n{\n    if (!is_float(t))\n        return REG_IRET;\n#ifdef TCC_TARGET_X86_64\n    if ((t & VT_BTYPE) == VT_LDOUBLE)\n        return TREG_ST0;\n#elif defined TCC_TARGET_RISCV64\n    if ((t & VT_BTYPE) == VT_LDOUBLE)\n        return REG_IRET;\n#endif\n    return REG_FRET;\n}\n\n/* returns 2nd function return register, if any */\nstatic int R2_RET(int t)\n{\n    t &= VT_BTYPE;\n#if PTR_SIZE == 4\n    if (t == VT_LLONG)\n        return REG_IRE2;\n#elif defined TCC_TARGET_X86_64\n    if (t == VT_QLONG)\n        return REG_IRE2;\n    if (t == VT_QFLOAT)\n        return REG_FRE2;\n#elif defined TCC_TARGET_RISCV64\n    if (t == VT_LDOUBLE)\n        return REG_IRE2;\n#endif\n    return VT_CONST;\n}\n\n/* returns true for two-word types */\n#define USING_TWO_WORDS(t) (R2_RET(t) != VT_CONST)\n\n/* put function return registers to stack value */\nstatic void PUT_R_RET(SValue *sv, int t)\n{\n    sv->r = R_RET(t), sv->r2 = R2_RET(t);\n}\n\n/* returns function return register class for type t */\nstatic int RC_RET(int t)\n{\n    return reg_classes[R_RET(t)] & ~(RC_FLOAT | RC_INT);\n}\n\n/* returns generic register class for type t */\nstatic int RC_TYPE(int t)\n{\n    if (!is_float(t))\n        return RC_INT;\n#ifdef TCC_TARGET_X86_64\n    if ((t & VT_BTYPE) == VT_LDOUBLE)\n        return RC_ST0;\n    if ((t & VT_BTYPE) == VT_QFLOAT)\n        return RC_FRET;\n#elif defined TCC_TARGET_RISCV64\n    if ((t & VT_BTYPE) == VT_LDOUBLE)\n        return RC_INT;\n#endif\n    return RC_FLOAT;\n}\n\n/* returns 2nd register class corresponding to t and rc */\nstatic int RC2_TYPE(int t, int rc)\n{\n    if (!USING_TWO_WORDS(t))\n        return 0;\n#ifdef RC_IRE2\n    if (rc == RC_IRET)\n        return RC_IRE2;\n#endif\n#ifdef RC_FRE2\n    if (rc == RC_FRET)\n        return RC_FRE2;\n#endif\n    if (rc & RC_FLOAT)\n        return RC_FLOAT;\n    return RC_INT;\n}\n\n/* we use our own 'finite' function to avoid potential problems with\n   non standard math libs */\n/* XXX: endianness dependent */\nST_FUNC int ieee_finite(double d)\n{\n    int p[4];\n    memcpy(p, &d, sizeof(double));\n    return ((unsigned)((p[1] | 0x800fffff) + 1)) >> 31;\n}\n\n/* compiling intel long double natively */\n#if (defined __i386__ || defined __x86_64__) \\\n    && (defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64)\n# define TCC_IS_NATIVE_387\n#endif\n\nST_FUNC void test_lvalue(void)\n{\n    if (!(vtop->r & VT_LVAL))\n        expect(\"lvalue\");\n}\n\nST_FUNC void check_vstack(void)\n{\n    if (vtop != vstack - 1)\n        tcc_error(\"internal compiler error: vstack leak (%d)\",\n                  (int)(vtop - vstack + 1));\n}\n\n/* vstack debugging aid */\n#if 0\nvoid pv (const char *lbl, int a, int b)\n{\n    int i;\n    for (i = a; i < a + b; ++i) {\n        SValue *p = &vtop[-i];\n        printf(\"%s vtop[-%d] : type.t:%04x  r:%04x  r2:%04x  c.i:%d\\n\",\n            lbl, i, p->type.t, p->r, p->r2, (int)p->c.i);\n    }\n}\n#endif\n\n/* ------------------------------------------------------------------------- */\n/* initialize vstack and types.  This must be done also for tcc -E */\nST_FUNC void tccgen_init(TCCState *s1)\n{\n    vtop = vstack - 1;\n    memset(vtop, 0, sizeof *vtop);\n\n    /* define some often used types */\n    int_type.t = VT_INT;\n\n    char_type.t = VT_BYTE;\n    if (s1->char_is_unsigned)\n        char_type.t |= VT_UNSIGNED;\n    char_pointer_type = char_type;\n    mk_pointer(&char_pointer_type);\n\n    func_old_type.t = VT_FUNC;\n    func_old_type.ref = sym_push(SYM_FIELD, &int_type, 0, 0);\n    func_old_type.ref->f.func_call = FUNC_CDECL;\n    func_old_type.ref->f.func_type = FUNC_OLD;\n#ifdef precedence_parser\n    init_prec();\n#endif\n    cstr_new(&initstr);\n}\n\nST_FUNC int tccgen_compile(TCCState *s1)\n{\n    funcname = \"\";\n    func_ind = -1;\n    anon_sym = SYM_FIRST_ANOM;\n    nocode_wanted = DATA_ONLY_WANTED; /* no code outside of functions */\n    debug_modes = (s1->do_debug ? 1 : 0) | s1->test_coverage << 1;\n\n    tcc_debug_start(s1);\n    tcc_tcov_start (s1);\n#ifdef TCC_TARGET_ARM\n    arm_init(s1);\n#endif\n#ifdef INC_DEBUG\n    printf(\"%s: **** new file\\n\", file->filename);\n#endif\n    parse_flags = PARSE_FLAG_PREPROCESS | PARSE_FLAG_TOK_NUM | PARSE_FLAG_TOK_STR;\n    next();\n    decl(VT_CONST);\n    gen_inline_functions(s1);\n    check_vstack();\n    /* end of translation unit info */\n#if TCC_EH_FRAME\n    tcc_eh_frame_end(s1);\n#endif\n    tcc_debug_end(s1);\n    tcc_tcov_end(s1);\n    return 0;\n}\n\nST_FUNC void tccgen_finish(TCCState *s1)\n{\n    tcc_debug_end(s1); /* just in case of errors: free memory */\n    free_inline_functions(s1);\n    sym_pop(&global_stack, NULL, 0);\n    sym_pop(&local_stack, NULL, 0);\n    /* free preprocessor macros */\n    free_defines(NULL);\n    /* free sym_pools */\n    dynarray_reset(&sym_pools, &nb_sym_pools);\n    cstr_free(&initstr);\n    dynarray_reset(&stk_data, &nb_stk_data);\n    while (cur_switch)\n        end_switch();\n    local_scope = 0;\n    loop_scope = NULL;\n    all_cleanups = NULL;\n    pending_gotos = NULL;\n    nb_temp_local_vars = 0;\n    global_label_stack = NULL;\n    local_label_stack = NULL;\n    cur_text_section = NULL;\n    sym_free_first = NULL;\n}\n\n/* ------------------------------------------------------------------------- */\nST_FUNC ElfSym *elfsym(Sym *s)\n{\n  if (!s || !s->c)\n    return NULL;\n  return &((ElfSym *)symtab_section->data)[s->c];\n}\n\n/* apply storage attributes to Elf symbol */\nST_FUNC void update_storage(Sym *sym)\n{\n    ElfSym *esym;\n    int sym_bind, old_sym_bind;\n\n    esym = elfsym(sym);\n    if (!esym)\n        return;\n\n    if (sym->a.visibility)\n        esym->st_other = (esym->st_other & ~ELFW(ST_VISIBILITY)(-1))\n            | sym->a.visibility;\n\n    if (sym->type.t & (VT_STATIC | VT_INLINE))\n        sym_bind = STB_LOCAL;\n    else if (sym->a.weak)\n        sym_bind = STB_WEAK;\n    else\n        sym_bind = STB_GLOBAL;\n    old_sym_bind = ELFW(ST_BIND)(esym->st_info);\n    if (sym_bind != old_sym_bind) {\n        esym->st_info = ELFW(ST_INFO)(sym_bind, ELFW(ST_TYPE)(esym->st_info));\n    }\n\n#ifdef TCC_TARGET_PE\n    if (sym->a.dllimport)\n        esym->st_other |= ST_PE_IMPORT;\n    if (sym->a.dllexport)\n        esym->st_other |= ST_PE_EXPORT;\n#endif\n\n#if 0\n    printf(\"storage %s: bind=%c vis=%d exp=%d imp=%d\\n\",\n        get_tok_str(sym->v, NULL),\n        sym_bind == STB_WEAK ? 'w' : sym_bind == STB_LOCAL ? 'l' : 'g',\n        sym->a.visibility,\n        sym->a.dllexport,\n        sym->a.dllimport\n        );\n#endif\n}\n\n/* ------------------------------------------------------------------------- */\n/* update sym->c so that it points to an external symbol in section\n   'section' with value 'value' */\n\nST_FUNC void put_extern_sym2(Sym *sym, int sh_num,\n                            addr_t value, unsigned long size,\n                            int can_add_underscore)\n{\n    int sym_type, sym_bind, info, other, t;\n    ElfSym *esym;\n    const char *name;\n    char buf1[256];\n\n    if (!sym->c) {\n        name = get_tok_str(sym->v, NULL);\n        t = sym->type.t;\n        if ((t & VT_BTYPE) == VT_FUNC) {\n            sym_type = STT_FUNC;\n        } else if ((t & VT_BTYPE) == VT_VOID) {\n            sym_type = STT_NOTYPE;\n            if ((t & (VT_BTYPE|VT_ASM_FUNC)) == VT_ASM_FUNC)\n                sym_type = STT_FUNC;\n        } else {\n            sym_type = STT_OBJECT;\n        }\n        if (t & (VT_STATIC | VT_INLINE))\n            sym_bind = STB_LOCAL;\n        else\n            sym_bind = STB_GLOBAL;\n        other = 0;\n\n#ifdef TCC_TARGET_PE\n        if (sym_type == STT_FUNC && sym->type.ref) {\n            Sym *ref = sym->type.ref;\n            if (ref->a.nodecorate) {\n                can_add_underscore = 0;\n            }\n            if (ref->f.func_call == FUNC_STDCALL && can_add_underscore) {\n                sprintf(buf1, \"_%s@%d\", name, ref->f.func_args * PTR_SIZE);\n                name = buf1;\n                other |= ST_PE_STDCALL;\n                can_add_underscore = 0;\n            }\n        }\n#endif\n\n        if (sym->asm_label) {\n            name = get_tok_str(sym->asm_label, NULL);\n            can_add_underscore = 0;\n        }\n\n        if (tcc_state->leading_underscore && can_add_underscore) {\n            buf1[0] = '_';\n            pstrcpy(buf1 + 1, sizeof(buf1) - 1, name);\n            name = buf1;\n        }\n\n        info = ELFW(ST_INFO)(sym_bind, sym_type);\n        sym->c = put_elf_sym(symtab_section, value, size, info, other, sh_num, name);\n\n        if (debug_modes)\n            tcc_debug_extern_sym(tcc_state, sym, sh_num, sym_bind, sym_type);\n\n    } else {\n        esym = elfsym(sym);\n        esym->st_value = value;\n        esym->st_size = size;\n        esym->st_shndx = sh_num;\n    }\n    update_storage(sym);\n}\n\nST_FUNC void put_extern_sym(Sym *sym, Section *s, addr_t value, unsigned long size)\n{\n    if (nocode_wanted && (NODATA_WANTED || (s && s == cur_text_section)))\n        return;\n    put_extern_sym2(sym, s ? s->sh_num : SHN_UNDEF, value, size, 1);\n}\n\n/* add a new relocation entry to symbol 'sym' in section 's' */\nST_FUNC void greloca(Section *s, Sym *sym, unsigned long offset, int type,\n                     addr_t addend)\n{\n    int c = 0;\n\n    if (nocode_wanted && s == cur_text_section)\n        return;\n\n    if (sym) {\n        if (0 == sym->c)\n            put_extern_sym(sym, NULL, 0, 0);\n        c = sym->c;\n    }\n\n    /* now we can add ELF relocation info */\n    put_elf_reloca(symtab_section, s, offset, type, c, addend);\n}\n\n#if PTR_SIZE == 4\nST_FUNC void greloc(Section *s, Sym *sym, unsigned long offset, int type)\n{\n    greloca(s, sym, offset, type, 0);\n}\n#endif\n\n/* ------------------------------------------------------------------------- */\n/* symbol allocator */\nstatic Sym *__sym_malloc(void)\n{\n    Sym *sym_pool, *sym, *last_sym;\n    int i;\n\n    sym_pool = tcc_malloc(SYM_POOL_NB * sizeof(Sym));\n    dynarray_add(&sym_pools, &nb_sym_pools, sym_pool);\n\n    last_sym = sym_free_first;\n    sym = sym_pool;\n    for(i = 0; i < SYM_POOL_NB; i++) {\n        sym->next = last_sym;\n        last_sym = sym;\n        sym++;\n    }\n    sym_free_first = last_sym;\n    return last_sym;\n}\n\nstatic inline Sym *sym_malloc(void)\n{\n    Sym *sym;\n#ifndef SYM_DEBUG\n    sym = sym_free_first;\n    if (!sym)\n        sym = __sym_malloc();\n    sym_free_first = sym->next;\n    return sym;\n#else\n    sym = tcc_malloc(sizeof(Sym));\n    return sym;\n#endif\n}\n\nST_INLN void sym_free(Sym *sym)\n{\n#ifndef SYM_DEBUG\n    sym->next = sym_free_first;\n    sym_free_first = sym;\n#else\n    tcc_free(sym);\n#endif\n}\n\n/* push, without hashing */\nST_FUNC Sym *sym_push2(Sym **ps, int v, int t, int c)\n{\n    Sym *s;\n\n    s = sym_malloc();\n    memset(s, 0, sizeof *s);\n    s->v = v;\n    s->type.t = t;\n    s->c = c;\n    /* add in stack */\n    s->prev = *ps;\n    *ps = s;\n    return s;\n}\n\n/* find a symbol and return its associated structure. 's' is the top\n   of the symbol stack */\nST_FUNC Sym *sym_find2(Sym *s, int v)\n{\n    while (s) {\n        if (s->v == v)\n            return s;\n        s = s->prev;\n    }\n    return NULL;\n}\n\n/* structure lookup */\nST_INLN Sym *struct_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_struct;\n}\n\n/* find an identifier */\nST_INLN Sym *sym_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_identifier;\n}\n\nstatic int sym_scope(Sym *s)\n{\n  if (IS_ENUM_VAL (s->type.t))\n    return s->type.ref->sym_scope;\n  else\n    return s->sym_scope;\n}\n\n/* push a given symbol on the symbol stack */\nST_FUNC Sym *sym_push(int v, CType *type, int r, int c)\n{\n    Sym *s, **ps;\n    TokenSym *ts;\n\n    if (local_stack)\n        ps = &local_stack;\n    else\n        ps = &global_stack;\n    s = sym_push2(ps, v, type->t, c);\n    s->type.ref = type->ref;\n    s->r = r;\n    /* don't record fields or anonymous symbols */\n    /* XXX: simplify */\n    if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {\n        /* record symbol in token array */\n        ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];\n        if (v & SYM_STRUCT)\n            ps = &ts->sym_struct;\n        else\n            ps = &ts->sym_identifier;\n        s->prev_tok = *ps;\n        *ps = s;\n        s->sym_scope = local_scope;\n        if (s->prev_tok && sym_scope(s->prev_tok) == s->sym_scope)\n            tcc_error(\"redeclaration of '%s'\",\n                get_tok_str(v & ~SYM_STRUCT, NULL));\n    }\n    return s;\n}\n\n/* push a global identifier */\nST_FUNC Sym *global_identifier_push(int v, int t, int c)\n{\n    Sym *s, **ps;\n    s = sym_push2(&global_stack, v, t, c);\n    s->r = VT_CONST | VT_SYM;\n    /* don't record anonymous symbol */\n    if (v < SYM_FIRST_ANOM) {\n        ps = &table_ident[v - TOK_IDENT]->sym_identifier;\n        /* modify the top most local identifier, so that sym_identifier will\n           point to 's' when popped; happens when called from inline asm */\n        while (*ps != NULL && (*ps)->sym_scope)\n            ps = &(*ps)->prev_tok;\n        s->prev_tok = *ps;\n        *ps = s;\n    }\n    return s;\n}\n\n/* pop symbols until top reaches 'b'.  If KEEP is non-zero don't really\n   pop them yet from the list, but do remove them from the token array.  */\nST_FUNC void sym_pop(Sym **ptop, Sym *b, int keep)\n{\n    Sym *s, *ss, **ps;\n    TokenSym *ts;\n    int v;\n\n    s = *ptop;\n    while(s != b) {\n        ss = s->prev;\n        v = s->v;\n        /* remove symbol in token array */\n        /* XXX: simplify */\n        if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {\n            ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];\n            if (v & SYM_STRUCT)\n                ps = &ts->sym_struct;\n            else\n                ps = &ts->sym_identifier;\n            *ps = s->prev_tok;\n        }\n\tif (!keep)\n\t    sym_free(s);\n        s = ss;\n    }\n    if (!keep)\n\t*ptop = b;\n}\n\n/* label lookup */\nST_FUNC Sym *label_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_label;\n}\n\nST_FUNC Sym *label_push(Sym **ptop, int v, int flags)\n{\n    Sym *s, **ps;\n    s = sym_push2(ptop, v, VT_STATIC, 0);\n    s->r = flags;\n    ps = &table_ident[v - TOK_IDENT]->sym_label;\n    if (ptop == &global_label_stack) {\n        /* modify the top most local identifier, so that\n           sym_identifier will point to 's' when popped */\n        while (*ps != NULL)\n            ps = &(*ps)->prev_tok;\n    }\n    s->prev_tok = *ps;\n    *ps = s;\n    return s;\n}\n\n/* pop labels until element last is reached. Look if any labels are\n   undefined. Define symbols if '&&label' was used. */\nST_FUNC void label_pop(Sym **ptop, Sym *slast, int keep)\n{\n    Sym *s, *s1;\n    for(s = *ptop; s != slast; s = s1) {\n        s1 = s->prev;\n        if (s->r == LABEL_DECLARED) {\n            tcc_warning_c(warn_all)(\"label '%s' declared but not used\", get_tok_str(s->v, NULL));\n        } else if (s->r == LABEL_FORWARD) {\n                tcc_error(\"label '%s' used but not defined\",\n                      get_tok_str(s->v, NULL));\n        } else {\n            if (s->c) {\n                /* define corresponding symbol. A size of\n                   1 is put. */\n                put_extern_sym(s, cur_text_section, s->jnext, 1);\n            }\n        }\n        /* remove label */\n        if (s->r != LABEL_GONE)\n            table_ident[s->v - TOK_IDENT]->sym_label = s->prev_tok;\n        if (!keep)\n            sym_free(s);\n        else\n            s->r = LABEL_GONE;\n    }\n    if (!keep)\n        *ptop = slast;\n}\n\n/* ------------------------------------------------------------------------- */\nstatic void vcheck_cmp(void)\n{\n    /* cannot let cpu flags if other instruction are generated. Also\n       avoid leaving VT_JMP anywhere except on the top of the stack\n       because it would complicate the code generator.\n\n       Don't do this when nocode_wanted.  vtop might come from\n       !nocode_wanted regions (see 88_codeopt.c) and transforming\n       it to a register without actually generating code is wrong\n       as their value might still be used for real.  All values\n       we push under nocode_wanted will eventually be popped\n       again, so that the VT_CMP/VT_JMP value will be in vtop\n       when code is unsuppressed again. */\n\n    /* However if it's just automatic suppression via CODE_OFF/ON()\n       then it seems that we better let things work undisturbed.\n       How can it work at all under nocode_wanted?  Well, gv() will\n       actually clear it at the gsym() in load()/VT_JMP in the\n       generator backends */\n\n    if (vtop->r == VT_CMP && 0 == (nocode_wanted & ~CODE_OFF_BIT))\n        gv(RC_INT);\n}\n\nstatic void vsetc(CType *type, int r, CValue *vc)\n{\n    if (vtop >= vstack + (VSTACK_SIZE - 1))\n        tcc_error(\"memory full (vstack)\");\n    vcheck_cmp();\n    vtop++;\n    vtop->type = *type;\n    vtop->r = r;\n    vtop->r2 = VT_CONST;\n    vtop->c = *vc;\n    vtop->sym = NULL;\n}\n\nST_FUNC void vswap(void)\n{\n    SValue tmp;\n\n    vcheck_cmp();\n    tmp = vtop[0];\n    vtop[0] = vtop[-1];\n    vtop[-1] = tmp;\n}\n\n/* pop stack value */\nST_FUNC void vpop(void)\n{\n    int v;\n    v = vtop->r & VT_VALMASK;\n#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)\n    /* for x86, we need to pop the FP stack */\n    if (v == TREG_ST0) {\n        o(0xd8dd); /* fstp %st(0) */\n    } else\n#endif\n    if (v == VT_CMP) {\n        /* need to put correct jump if && or || without test */\n        gsym(vtop->jtrue);\n        gsym(vtop->jfalse);\n    }\n    vtop--;\n}\n\n/* push constant of type \"type\" with useless value */\nstatic void vpush(CType *type)\n{\n    vset(type, VT_CONST, 0);\n}\n\n/* push arbitrary 64bit constant */\nstatic void vpush64(int ty, unsigned long long v)\n{\n    CValue cval;\n    CType ctype;\n    ctype.t = ty;\n    ctype.ref = NULL;\n    cval.i = v;\n    vsetc(&ctype, VT_CONST, &cval);\n}\n\n/* push integer constant */\nST_FUNC void vpushi(int v)\n{\n    vpush64(VT_INT, v);\n}\n\n/* push a pointer sized constant */\nstatic void vpushs(addr_t v)\n{\n    vpush64(VT_SIZE_T, v);\n}\n\n/* push long long constant */\nstatic inline void vpushll(long long v)\n{\n    vpush64(VT_LLONG, v);\n}\n\nST_FUNC void vset(CType *type, int r, int v)\n{\n    CValue cval;\n    cval.i = v;\n    vsetc(type, r, &cval);\n}\n\nstatic void vseti(int r, int v)\n{\n    CType type;\n    type.t = VT_INT;\n    type.ref = NULL;\n    vset(&type, r, v);\n}\n\nST_FUNC void vpushv(SValue *v)\n{\n    if (vtop >= vstack + (VSTACK_SIZE - 1))\n        tcc_error(\"memory full (vstack)\");\n    vtop++;\n    *vtop = *v;\n}\n\nstatic void vdup(void)\n{\n    vpushv(vtop);\n}\n\n/* rotate the stack element at position n-1 to the top */\nST_FUNC void vrotb(int n)\n{\n    SValue tmp;\n    if (--n < 1)\n        return;\n    vcheck_cmp();\n    tmp = vtop[-n];\n    memmove(vtop - n, vtop - n + 1, sizeof *vtop * n);\n    vtop[0] = tmp;\n}\n\n/* rotate the top stack element into position n-1 */\nST_FUNC void vrott(int n)\n{\n    SValue tmp;\n    if (--n < 1)\n        return;\n    vcheck_cmp();\n    tmp = vtop[0];\n    memmove(vtop - n + 1, vtop - n, sizeof *vtop * n);\n    vtop[-n] = tmp;\n}\n\n/* reverse order of the the first n stack elements */\nST_FUNC void vrev(int n)\n{\n    int i;\n    SValue tmp;\n    vcheck_cmp();\n    for (i = 0, n = -n; i > ++n; --i)\n        tmp = vtop[i], vtop[i] = vtop[n], vtop[n] = tmp;\n}\n\n/* ------------------------------------------------------------------------- */\n/* vtop->r = VT_CMP means CPU-flags have been set from comparison or test. */\n\n/* called from generators to set the result from relational ops  */\nST_FUNC void vset_VT_CMP(int op)\n{\n    vtop->r = VT_CMP;\n    vtop->cmp_op = op;\n    vtop->jfalse = 0;\n    vtop->jtrue = 0;\n}\n\n/* called once before asking generators to load VT_CMP to a register */\nstatic void vset_VT_JMP(void)\n{\n    int op = vtop->cmp_op;\n\n    if (vtop->jtrue || vtop->jfalse) {\n        int origt = vtop->type.t;\n        /* we need to jump to 'mov $0,%R' or 'mov $1,%R' */\n        int inv = op & (op < 2); /* small optimization */\n        vseti(VT_JMP+inv, gvtst(inv, 0));\n        vtop->type.t |= origt & (VT_UNSIGNED | VT_DEFSIGN);\n    } else {\n        /* otherwise convert flags (rsp. 0/1) to register */\n        vtop->c.i = op;\n        if (op < 2) /* doesn't seem to happen */\n            vtop->r = VT_CONST;\n    }\n}\n\n/* Set CPU Flags, doesn't yet jump */\nstatic void gvtst_set(int inv, int t)\n{\n    int *p;\n\n    if (vtop->r != VT_CMP) {\n        vpushi(0);\n        gen_op(TOK_NE);\n        if (vtop->r != VT_CMP) /* must be VT_CONST then */\n            vset_VT_CMP(vtop->c.i != 0);\n    }\n\n    p = inv ? &vtop->jfalse : &vtop->jtrue;\n    *p = gjmp_append(*p, t);\n}\n\n/* Generate value test\n *\n * Generate a test for any value (jump, comparison and integers) */\nstatic int gvtst(int inv, int t)\n{\n    int op, x, u;\n\n    gvtst_set(inv, t);\n    t = vtop->jtrue, u = vtop->jfalse;\n    if (inv)\n        x = u, u = t, t = x;\n    op = vtop->cmp_op;\n\n    /* jump to the wanted target */\n    if (op > 1)\n        t = gjmp_cond(op ^ inv, t);\n    else if (op != inv)\n        t = gjmp(t);\n    /* resolve complementary jumps to here */\n    gsym(u);\n\n    vtop--;\n    return t;\n}\n\n/* generate a zero or nozero test */\nstatic void gen_test_zero(int op)\n{\n    if (vtop->r == VT_CMP) {\n        int j;\n        if (op == TOK_EQ) {\n            j = vtop->jfalse;\n            vtop->jfalse = vtop->jtrue;\n            vtop->jtrue = j;\n            vtop->cmp_op ^= 1;\n        }\n    } else {\n        vpushi(0);\n        gen_op(op);\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/* push a symbol value of TYPE */\nST_FUNC void vpushsym(CType *type, Sym *sym)\n{\n    CValue cval;\n    cval.i = 0;\n    vsetc(type, VT_CONST | VT_SYM, &cval);\n    vtop->sym = sym;\n}\n\n/* Return a static symbol pointing to a section */\nST_FUNC Sym *get_sym_ref(CType *type, Section *sec, unsigned long offset, unsigned long size)\n{\n    int v;\n    Sym *sym;\n\n    v = anon_sym++;\n    sym = sym_push(v, type, VT_CONST | VT_SYM, 0);\n    sym->type.t |= VT_STATIC;\n    put_extern_sym(sym, sec, offset, size);\n    return sym;\n}\n\n/* push a reference to a section offset by adding a dummy symbol */\nstatic void vpush_ref(CType *type, Section *sec, unsigned long offset, unsigned long size)\n{\n    vpushsym(type, get_sym_ref(type, sec, offset, size));  \n}\n\n/* define a new external reference to a symbol 'v' of type 'u' */\nST_FUNC Sym *external_global_sym(int v, CType *type)\n{\n    Sym *s;\n\n    s = sym_find(v);\n    if (!s) {\n        /* push forward reference */\n        s = global_identifier_push(v, type->t | VT_EXTERN, 0);\n        s->type.ref = type->ref;\n    } else if (IS_ASM_SYM(s)) {\n        s->type.t = type->t | (s->type.t & VT_EXTERN);\n        s->type.ref = type->ref;\n        update_storage(s);\n    }\n    return s;\n}\n\n/* create an external reference with no specific type similar to asm labels.\n   This avoids type conflicts if the symbol is used from C too */\nST_FUNC Sym *external_helper_sym(int v)\n{\n    CType ct = { VT_ASM_FUNC, NULL };\n    return external_global_sym(v, &ct);\n}\n\n/* push a reference to an helper function (such as memmove) */\nST_FUNC void vpush_helper_func(int v)\n{\n    vpushsym(&func_old_type, external_helper_sym(v));\n}\n\n/* Merge symbol attributes.  */\nstatic void merge_symattr(struct SymAttr *sa, struct SymAttr *sa1)\n{\n    if (sa1->aligned && !sa->aligned)\n      sa->aligned = sa1->aligned;\n    sa->packed |= sa1->packed;\n    sa->weak |= sa1->weak;\n    sa->nodebug |= sa1->nodebug;\n    if (sa1->visibility != STV_DEFAULT) {\n\tint vis = sa->visibility;\n\tif (vis == STV_DEFAULT\n\t    || vis > sa1->visibility)\n\t  vis = sa1->visibility;\n\tsa->visibility = vis;\n    }\n    sa->dllexport |= sa1->dllexport;\n    sa->nodecorate |= sa1->nodecorate;\n    sa->dllimport |= sa1->dllimport;\n}\n\n/* Merge function attributes.  */\nstatic void merge_funcattr(struct FuncAttr *fa, struct FuncAttr *fa1)\n{\n    if (fa1->func_call && !fa->func_call)\n      fa->func_call = fa1->func_call;\n    if (fa1->func_type && !fa->func_type)\n      fa->func_type = fa1->func_type;\n    if (fa1->func_args && !fa->func_args)\n      fa->func_args = fa1->func_args;\n    if (fa1->func_noreturn)\n      fa->func_noreturn = 1;\n    if (fa1->func_ctor)\n      fa->func_ctor = 1;\n    if (fa1->func_dtor)\n      fa->func_dtor = 1;\n}\n\n/* Merge attributes.  */\nstatic void merge_attr(AttributeDef *ad, AttributeDef *ad1)\n{\n    merge_symattr(&ad->a, &ad1->a);\n    merge_funcattr(&ad->f, &ad1->f);\n\n    if (ad1->section)\n      ad->section = ad1->section;\n    if (ad1->alias_target)\n      ad->alias_target = ad1->alias_target;\n    if (ad1->asm_label)\n      ad->asm_label = ad1->asm_label;\n    if (ad1->attr_mode)\n      ad->attr_mode = ad1->attr_mode;\n}\n\n/* Merge some type attributes.  */\nstatic void patch_type(Sym *sym, CType *type)\n{\n    if (!(type->t & VT_EXTERN) || IS_ENUM_VAL(sym->type.t)) {\n        if (!(sym->type.t & VT_EXTERN))\n            tcc_error(\"redefinition of '%s'\", get_tok_str(sym->v, NULL));\n        sym->type.t &= ~VT_EXTERN;\n    }\n\n    if (IS_ASM_SYM(sym)) {\n        /* stay static if both are static */\n        sym->type.t = type->t & (sym->type.t | ~VT_STATIC);\n        sym->type.ref = type->ref;\n        if ((type->t & VT_BTYPE) != VT_FUNC && !(type->t & VT_ARRAY))\n            sym->r |= VT_LVAL;\n    }\n\n    if (!is_compatible_types(&sym->type, type)) {\n        tcc_error(\"incompatible types for redefinition of '%s'\",\n                  get_tok_str(sym->v, NULL));\n\n    } else if ((sym->type.t & VT_BTYPE) == VT_FUNC) {\n        int static_proto = sym->type.t & VT_STATIC;\n        /* warn if static follows non-static function declaration */\n        if ((type->t & VT_STATIC) && !static_proto\n            /* XXX this test for inline shouldn't be here.  Until we\n               implement gnu-inline mode again it silences a warning for\n               mingw caused by our workarounds.  */\n            && !((type->t | sym->type.t) & VT_INLINE))\n            tcc_warning(\"static storage ignored for redefinition of '%s'\",\n                get_tok_str(sym->v, NULL));\n\n        /* set 'inline' if both agree or if one has static */\n        if ((type->t | sym->type.t) & VT_INLINE) {\n            if (!((type->t ^ sym->type.t) & VT_INLINE)\n             || ((type->t | sym->type.t) & VT_STATIC))\n                static_proto |= VT_INLINE;\n        }\n\n        if (0 == (type->t & VT_EXTERN)) {\n            struct FuncAttr f = sym->type.ref->f;\n            /* put complete type, use static from prototype */\n            sym->type.t = (type->t & ~(VT_STATIC|VT_INLINE)) | static_proto;\n            sym->type.ref = type->ref;\n            merge_funcattr(&sym->type.ref->f, &f);\n        } else {\n            sym->type.t &= ~VT_INLINE | static_proto;\n        }\n\n        if (sym->type.ref->f.func_type == FUNC_OLD\n             && type->ref->f.func_type != FUNC_OLD) {\n            sym->type.ref = type->ref;\n        }\n\n    } else {\n        if ((sym->type.t & VT_ARRAY) && type->ref->c >= 0) {\n            /* set array size if it was omitted in extern declaration */\n            sym->type.ref->c = type->ref->c;\n        }\n        if ((type->t ^ sym->type.t) & VT_STATIC)\n            tcc_warning(\"storage mismatch for redefinition of '%s'\",\n                get_tok_str(sym->v, NULL));\n    }\n}\n\n/* Merge some storage attributes.  */\nstatic void patch_storage(Sym *sym, AttributeDef *ad, CType *type)\n{\n    if (type)\n        patch_type(sym, type);\n\n#ifdef TCC_TARGET_PE\n    if (sym->a.dllimport != ad->a.dllimport)\n        tcc_error(\"incompatible dll linkage for redefinition of '%s'\",\n            get_tok_str(sym->v, NULL));\n#endif\n    merge_symattr(&sym->a, &ad->a);\n    if (ad->asm_label)\n        sym->asm_label = ad->asm_label;\n    update_storage(sym);\n}\n\n/* copy sym to other stack */\nstatic Sym *sym_copy(Sym *s0, Sym **ps)\n{\n    Sym *s;\n    s = sym_malloc(), *s = *s0;\n    s->prev = *ps, *ps = s;\n    if (s->v < SYM_FIRST_ANOM) {\n        ps = &table_ident[s->v - TOK_IDENT]->sym_identifier;\n        s->prev_tok = *ps, *ps = s;\n    }\n    return s;\n}\n\n/* copy s->type.ref to stack 'ps' for VT_FUNC and VT_PTR */\nstatic void sym_copy_ref(Sym *s, Sym **ps)\n{\n    int bt = s->type.t & VT_BTYPE;\n    if (bt == VT_FUNC || bt == VT_PTR || (bt == VT_STRUCT && s->sym_scope)) {\n        Sym **sp = &s->type.ref;\n        for (s = *sp, *sp = NULL; s; s = s->next) {\n            Sym *s2 = sym_copy(s, ps);\n            sp = &(*sp = s2)->next;\n            sym_copy_ref(s2, ps);\n        }\n    }\n}\n\n/* define a new external reference to a symbol 'v' */\nstatic Sym *external_sym(int v, CType *type, int r, AttributeDef *ad)\n{\n    Sym *s;\n\n    /* look for global symbol */\n    s = sym_find(v);\n    while (s && s->sym_scope)\n        s = s->prev_tok;\n\n    if (!s) {\n        /* push forward reference */\n        s = global_identifier_push(v, type->t, 0);\n        s->r |= r;\n        s->a = ad->a;\n        s->asm_label = ad->asm_label;\n        s->type.ref = type->ref;\n        /* copy type to the global stack */\n        if (local_stack)\n            sym_copy_ref(s, &global_stack);\n    } else {\n        patch_storage(s, ad, type);\n    }\n    /* push variables on local_stack if any */\n    if (local_stack && (s->type.t & VT_BTYPE) != VT_FUNC)\n        s = sym_copy(s, &local_stack);\n    return s;\n}\n\n/* save registers up to (vtop - n) stack entry */\nST_FUNC void save_regs(int n)\n{\n    SValue *p, *p1;\n    for(p = vstack, p1 = vtop - n; p <= p1; p++)\n        save_reg(p->r);\n}\n\n/* save r to the memory stack, and mark it as being free */\nST_FUNC void save_reg(int r)\n{\n    save_reg_upstack(r, 0);\n}\n\n/* save r to the memory stack, and mark it as being free,\n   if seen up to (vtop - n) stack entry */\nST_FUNC void save_reg_upstack(int r, int n)\n{\n    int l, size, align, bt, r2;\n    SValue *p, *p1, sv;\n\n    if ((r &= VT_VALMASK) >= VT_CONST)\n        return;\n    if (nocode_wanted)\n        return;\n    l = r2 = 0;\n    for(p = vstack, p1 = vtop - n; p <= p1; p++) {\n        if ((p->r & VT_VALMASK) == r || p->r2 == r) {\n            /* must save value on stack if not already done */\n            if (!l) {\n                bt = p->type.t & VT_BTYPE;\n                if (bt == VT_VOID)\n                    continue;\n                if ((p->r & VT_LVAL) || bt == VT_FUNC)\n                    bt = VT_PTR;\n                sv.type.t = bt;\n                size = type_size(&sv.type, &align);\n                l = get_temp_local_var(size, align, &r2);\n                sv.r = VT_LOCAL | VT_LVAL;\n                sv.c.i = l;\n                store(p->r & VT_VALMASK, &sv);\n#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)\n                /* x86 specific: need to pop fp register ST0 if saved */\n                if (r == TREG_ST0) {\n                    o(0xd8dd); /* fstp %st(0) */\n                }\n#endif\n                /* special long long case */\n                if (p->r2 < VT_CONST && USING_TWO_WORDS(bt)) {\n                    sv.c.i += PTR_SIZE;\n                    store(p->r2, &sv);\n                }\n            }\n            /* mark that stack entry as being saved on the stack */\n            if (p->r & VT_LVAL) {\n                /* also clear the bounded flag because the\n                   relocation address of the function was stored in\n                   p->c.i */\n                p->r = (p->r & ~(VT_VALMASK | VT_BOUNDED)) | VT_LLOCAL;\n            } else {\n                p->r = VT_LVAL | VT_LOCAL;\n                p->type.t &= ~VT_ARRAY; /* cannot combine VT_LVAL with VT_ARRAY */\n            }\n            p->sym = NULL;\n            p->r2 = r2;\n            p->c.i = l;\n        }\n    }\n}\n\n#ifdef TCC_TARGET_ARM\n/* find a register of class 'rc2' with at most one reference on stack.\n * If none, call get_reg(rc) */\nST_FUNC int get_reg_ex(int rc, int rc2)\n{\n    int r;\n    SValue *p;\n    \n    for(r=0;r<NB_REGS;r++) {\n        if (reg_classes[r] & rc2) {\n            int n;\n            n=0;\n            for(p = vstack; p <= vtop; p++) {\n                if ((p->r & VT_VALMASK) == r ||\n                    p->r2 == r)\n                    n++;\n            }\n            if (n <= 1)\n                return r;\n        }\n    }\n    return get_reg(rc);\n}\n#endif\n\n/* find a free register of class 'rc'. If none, save one register */\nST_FUNC int get_reg(int rc)\n{\n    int r;\n    SValue *p;\n\n    /* find a free register */\n    for(r=0;r<NB_REGS;r++) {\n        if (reg_classes[r] & rc) {\n            if (nocode_wanted)\n                return r;\n            for(p=vstack;p<=vtop;p++) {\n                if ((p->r & VT_VALMASK) == r ||\n                    p->r2 == r)\n                    goto notfound;\n            }\n            return r;\n        }\n    notfound: ;\n    }\n    \n    /* no register left : free the first one on the stack (VERY\n       IMPORTANT to start from the bottom to ensure that we don't\n       spill registers used in gen_opi()) */\n    for(p=vstack;p<=vtop;p++) {\n        /* look at second register (if long long) */\n        r = p->r2;\n        if (r < VT_CONST && (reg_classes[r] & rc))\n            goto save_found;\n        r = p->r & VT_VALMASK;\n        if (r < VT_CONST && (reg_classes[r] & rc)) {\n        save_found:\n            save_reg(r);\n            return r;\n        }\n    }\n    /* Should never comes here */\n    return -1;\n}\n\n/* find a free temporary local variable (return the offset on stack) match\n   size and align. If none, add new temporary stack variable */\nstatic int get_temp_local_var(int size,int align, int *r2)\n{\n    int i;\n    struct temp_local_variable *temp_var;\n    SValue *p;\n    int r;\n    unsigned used = 0;\n\n    /* mark locations that are still in use */\n    for (p = vstack; p <= vtop; p++) {\n\tr = p->r & VT_VALMASK;\n\tif (r == VT_LOCAL || r == VT_LLOCAL) {\n\t    r = p->r2 - (VT_CONST + 1);\n\t    if (r >= 0 && r < MAX_TEMP_LOCAL_VARIABLE_NUMBER)\n\t        used |= 1<<r;\n\t}\n    }\n    for (i=0;i<nb_temp_local_vars;i++) {\n\ttemp_var=&arr_temp_local_vars[i];\n\tif(!(used & 1<<i)\n\t && temp_var->size>=size\n\t && temp_var->align>=align) {\nret_tmp:\n\t    *r2 = (VT_CONST + 1) + i;\n\t    return temp_var->location;\n\t}\n    }\n    loc = (loc - size) & -align;\n    if (nb_temp_local_vars<MAX_TEMP_LOCAL_VARIABLE_NUMBER) {\n\ttemp_var=&arr_temp_local_vars[i];\n\ttemp_var->location=loc;\n\ttemp_var->size=size;\n\ttemp_var->align=align;\n\tnb_temp_local_vars++;\n\tgoto ret_tmp;\n    }\n    *r2 = VT_CONST;\n    return loc;\n}\n\n/* move register 's' (of type 't') to 'r', and flush previous value of r to memory\n   if needed */\nstatic void move_reg(int r, int s, int t)\n{\n    SValue sv;\n\n    if (r != s) {\n        save_reg(r);\n        sv.type.t = t;\n        sv.type.ref = NULL;\n        sv.r = s;\n        sv.c.i = 0;\n        load(r, &sv);\n    }\n}\n\n/* get address of vtop (vtop MUST BE an lvalue) */\nST_FUNC void gaddrof(void)\n{\n    vtop->r &= ~VT_LVAL;\n    /* tricky: if saved lvalue, then we can go back to lvalue */\n    if ((vtop->r & VT_VALMASK) == VT_LLOCAL)\n        vtop->r = (vtop->r & ~VT_VALMASK) | VT_LOCAL | VT_LVAL;\n}\n\n#ifdef CONFIG_TCC_BCHECK\n/* generate a bounded pointer addition */\nstatic void gen_bounded_ptr_add(void)\n{\n    int save = (vtop[-1].r & VT_VALMASK) == VT_LOCAL;\n    if (save) {\n      vpushv(&vtop[-1]);\n      vrott(3);\n    }\n    vpush_helper_func(TOK___bound_ptr_add);\n    vrott(3);\n    gfunc_call(2);\n    vtop -= save;\n    vpushi(0);\n    /* returned pointer is in REG_IRET */\n    vtop->r = REG_IRET | VT_BOUNDED;\n    if (nocode_wanted)\n        return;\n    /* relocation offset of the bounding function call point */\n    vtop->c.i = (cur_text_section->reloc->data_offset - sizeof(ElfW_Rel));\n}\n\n/* patch pointer addition in vtop so that pointer dereferencing is\n   also tested */\nstatic void gen_bounded_ptr_deref(void)\n{\n    addr_t func;\n    int size, align;\n    ElfW_Rel *rel;\n    Sym *sym;\n\n    if (nocode_wanted)\n        return;\n\n    size = type_size(&vtop->type, &align);\n    switch(size) {\n    case  1: func = TOK___bound_ptr_indir1; break;\n    case  2: func = TOK___bound_ptr_indir2; break;\n    case  4: func = TOK___bound_ptr_indir4; break;\n    case  8: func = TOK___bound_ptr_indir8; break;\n    case 12: func = TOK___bound_ptr_indir12; break;\n    case 16: func = TOK___bound_ptr_indir16; break;\n    default:\n        /* may happen with struct member access */\n        return;\n    }\n    sym = external_helper_sym(func);\n    if (!sym->c)\n        put_extern_sym(sym, NULL, 0, 0);\n    /* patch relocation */\n    /* XXX: find a better solution ? */\n    rel = (ElfW_Rel *)(cur_text_section->reloc->data + vtop->c.i);\n    rel->r_info = ELFW(R_INFO)(sym->c, ELFW(R_TYPE)(rel->r_info));\n}\n\n/* generate lvalue bound code */\nstatic void gbound(void)\n{\n    CType type1;\n\n    vtop->r &= ~VT_MUSTBOUND;\n    /* if lvalue, then use checking code before dereferencing */\n    if (vtop->r & VT_LVAL) {\n        /* if not VT_BOUNDED value, then make one */\n        if (!(vtop->r & VT_BOUNDED)) {\n            /* must save type because we must set it to int to get pointer */\n            type1 = vtop->type;\n            vtop->type.t = VT_PTR;\n            gaddrof();\n            vpushi(0);\n            gen_bounded_ptr_add();\n            vtop->r |= VT_LVAL;\n            vtop->type = type1;\n        }\n        /* then check for dereferencing */\n        gen_bounded_ptr_deref();\n    }\n}\n\n/* we need to call __bound_ptr_add before we start to load function\n   args into registers */\nST_FUNC void gbound_args(int nb_args)\n{\n    int i, v;\n    SValue *sv;\n\n    for (i = 1; i <= nb_args; ++i)\n        if (vtop[1 - i].r & VT_MUSTBOUND) {\n            vrotb(i);\n            gbound();\n            vrott(i);\n        }\n\n    sv = vtop - nb_args;\n    if (sv->r & VT_SYM) {\n        v = sv->sym->v;\n        if (v == TOK_setjmp\n          || v == TOK__setjmp\n#ifndef TCC_TARGET_PE\n          || v == TOK_sigsetjmp\n          || v == TOK___sigsetjmp\n#endif\n          ) {\n            vpush_helper_func(TOK___bound_setjmp);\n            vpushv(sv + 1);\n            gfunc_call(1);\n            func_bound_add_epilog = 1;\n        }\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64\n        if (v == TOK_alloca)\n            func_bound_add_epilog = 1;\n#endif\n#if TARGETOS_NetBSD\n        if (v == TOK_longjmp) /* undo rename to __longjmp14 */\n            sv->sym->asm_label = TOK___bound_longjmp;\n#endif\n    }\n}\n\n/* Add bounds for local symbols from S to E (via ->prev) */\nstatic void add_local_bounds(Sym *s, Sym *e)\n{\n    for (; s != e; s = s->prev) {\n        if (!s->v || (s->r & VT_VALMASK) != VT_LOCAL)\n          continue;\n        /* Add arrays/structs/unions because we always take address */\n        if ((s->type.t & VT_ARRAY)\n            || (s->type.t & VT_BTYPE) == VT_STRUCT\n            || s->a.addrtaken) {\n            /* add local bound info */\n            int align, size = type_size(&s->type, &align);\n            addr_t *bounds_ptr = section_ptr_add(lbounds_section,\n                                                 2 * sizeof(addr_t));\n            bounds_ptr[0] = s->c;\n            bounds_ptr[1] = size;\n        }\n    }\n}\n#endif\n\n/* Wrapper around sym_pop, that potentially also registers local bounds.  */\nstatic void pop_local_syms(Sym *b, int keep)\n{\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check && !keep && (local_scope || !func_var))\n        add_local_bounds(local_stack, b);\n#endif\n    if (debug_modes)\n        tcc_add_debug_info (tcc_state, !local_scope, local_stack, b);\n    sym_pop(&local_stack, b, keep);\n}\n\n/* increment an lvalue pointer */\nstatic void incr_offset(int offset)\n{\n    int t = vtop->type.t;\n    gaddrof(); /* remove VT_LVAL */\n    vtop->type.t = VT_PTRDIFF_T; /* set scalar type */\n    vpushs(offset);\n    gen_op('+');\n    vtop->r |= VT_LVAL;\n    vtop->type.t = t;\n}\n\nstatic void incr_bf_adr(int o)\n{\n    vtop->type.t = VT_BYTE | VT_UNSIGNED;\n    incr_offset(o);\n}\n\n/* single-byte load mode for packed or otherwise unaligned bitfields */\nstatic void load_packed_bf(CType *type, int bit_pos, int bit_size)\n{\n    int n, o, bits;\n    save_reg_upstack(vtop->r, 1);\n    vpush64(type->t & VT_BTYPE, 0); // B X\n    bits = 0, o = bit_pos >> 3, bit_pos &= 7;\n    do {\n        vswap(); // X B\n        incr_bf_adr(o);\n        vdup(); // X B B\n        n = 8 - bit_pos;\n        if (n > bit_size)\n            n = bit_size;\n        if (bit_pos)\n            vpushi(bit_pos), gen_op(TOK_SHR), bit_pos = 0; // X B Y\n        if (n < 8)\n            vpushi((1 << n) - 1), gen_op('&');\n        gen_cast(type);\n        if (bits)\n            vpushi(bits), gen_op(TOK_SHL);\n        vrotb(3); // B Y X\n        gen_op('|'); // B X\n        bits += n, bit_size -= n, o = 1;\n    } while (bit_size);\n    vswap(), vpop();\n    if (!(type->t & VT_UNSIGNED)) {\n        n = ((type->t & VT_BTYPE) == VT_LLONG ? 64 : 32) - bits;\n        vpushi(n), gen_op(TOK_SHL);\n        vpushi(n), gen_op(TOK_SAR);\n    }\n}\n\n/* single-byte store mode for packed or otherwise unaligned bitfields */\nstatic void store_packed_bf(int bit_pos, int bit_size)\n{\n    int bits, n, o, m, c;\n    c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    vswap(); // X B\n    save_reg_upstack(vtop->r, 1);\n    bits = 0, o = bit_pos >> 3, bit_pos &= 7;\n    do {\n        incr_bf_adr(o); // X B\n        vswap(); //B X\n        c ? vdup() : gv_dup(); // B V X\n        vrott(3); // X B V\n        if (bits)\n            vpushi(bits), gen_op(TOK_SHR);\n        if (bit_pos)\n            vpushi(bit_pos), gen_op(TOK_SHL);\n        n = 8 - bit_pos;\n        if (n > bit_size)\n            n = bit_size;\n        if (n < 8) {\n            m = ((1 << n) - 1) << bit_pos;\n            vpushi(m), gen_op('&'); // X B V1\n            vpushv(vtop-1); // X B V1 B\n            vpushi(m & 0x80 ? ~m & 0x7f : ~m);\n            gen_op('&'); // X B V1 B1\n            gen_op('|'); // X B V2\n        }\n        vdup(), vtop[-1] = vtop[-2]; // X B B V2\n        vstore(), vpop(); // X B\n        bits += n, bit_size -= n, bit_pos = 0, o = 1;\n    } while (bit_size);\n    vpop(), vpop();\n}\n\nstatic int adjust_bf(SValue *sv, int bit_pos, int bit_size)\n{\n    int t;\n    if (0 == sv->type.ref)\n        return 0;\n    t = sv->type.ref->auxtype;\n    if (t != -1 && t != VT_STRUCT) {\n        sv->type.t = (sv->type.t & ~(VT_BTYPE | VT_LONG)) | t;\n        sv->r |= VT_LVAL;\n    }\n    return t;\n}\n\n/* store vtop a register belonging to class 'rc'. lvalues are\n   converted to values. Cannot be used if cannot be converted to\n   register value (such as structures). */\nST_FUNC int gv(int rc)\n{\n    int r, r2, r_ok, r2_ok, rc2, bt;\n    int bit_pos, bit_size, size, align;\n\n    /* NOTE: get_reg can modify vstack[] */\n    if (vtop->type.t & VT_BITFIELD) {\n        CType type;\n\n        bit_pos = BIT_POS(vtop->type.t);\n        bit_size = BIT_SIZE(vtop->type.t);\n        /* remove bit field info to avoid loops */\n        vtop->type.t &= ~VT_STRUCT_MASK;\n\n        type.ref = NULL;\n        type.t = vtop->type.t & VT_UNSIGNED;\n        if ((vtop->type.t & VT_BTYPE) == VT_BOOL)\n            type.t |= VT_UNSIGNED;\n\n        r = adjust_bf(vtop, bit_pos, bit_size);\n\n        if ((vtop->type.t & VT_BTYPE) == VT_LLONG)\n            type.t |= VT_LLONG;\n        else\n            type.t |= VT_INT;\n\n        if (r == VT_STRUCT) {\n            load_packed_bf(&type, bit_pos, bit_size);\n        } else {\n            int bits = (type.t & VT_BTYPE) == VT_LLONG ? 64 : 32;\n            /* cast to int to propagate signedness in following ops */\n            gen_cast(&type);\n            /* generate shifts */\n            vpushi(bits - (bit_pos + bit_size));\n            gen_op(TOK_SHL);\n            vpushi(bits - bit_size);\n            /* NOTE: transformed to SHR if unsigned */\n            gen_op(TOK_SAR);\n        }\n        r = gv(rc);\n    } else {\n        if (is_float(vtop->type.t) && \n            (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n            /* CPUs usually cannot use float constants, so we store them\n               generically in data segment */\n            init_params p = { rodata_section };\n            unsigned long offset;\n            size = type_size(&vtop->type, &align);\n            if (NODATA_WANTED)\n                size = 0, align = 1;\n            offset = section_add(p.sec, size, align);\n            vpush_ref(&vtop->type, p.sec, offset, size);\n\t    vswap();\n\t    init_putv(&p, &vtop->type, offset);\n\t    vtop->r |= VT_LVAL;\n        }\n#ifdef CONFIG_TCC_BCHECK\n        if (vtop->r & VT_MUSTBOUND) \n            gbound();\n#endif\n\n        bt = vtop->type.t & VT_BTYPE;\n\n#ifdef TCC_TARGET_RISCV64\n        /* XXX mega hack */\n        if (bt == VT_LDOUBLE && rc == RC_FLOAT)\n          rc = RC_INT;\n#endif\n        rc2 = RC2_TYPE(bt, rc);\n\n        /* need to reload if:\n           - constant\n           - lvalue (need to dereference pointer)\n           - already a register, but not in the right class */\n        r = vtop->r & VT_VALMASK;\n        r_ok = !(vtop->r & VT_LVAL) && (r < VT_CONST) && (reg_classes[r] & rc);\n        r2_ok = !rc2 || ((vtop->r2 < VT_CONST) && (reg_classes[vtop->r2] & rc2));\n\n        if (!r_ok || !r2_ok) {\n\n            if (!r_ok) {\n                if (1 /* we can 'mov (r),r' in cases */\n                    && r < VT_CONST\n                    && (reg_classes[r] & rc)\n                    && !rc2\n                    )\n                    save_reg_upstack(r, 1);\n                else\n                    r = get_reg(rc);\n            }\n\n            if (rc2) {\n                int load_type = (bt == VT_QFLOAT) ? VT_DOUBLE : VT_PTRDIFF_T;\n                int original_type = vtop->type.t;\n\n                /* two register type load :\n                   expand to two words temporarily */\n                if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n                    /* load constant */\n                    unsigned long long ll = vtop->c.i;\n                    vtop->c.i = ll; /* first word */\n                    load(r, vtop);\n                    vtop->r = r; /* save register value */\n                    vpushi(ll >> 32); /* second word */\n                } else if (vtop->r & VT_LVAL) {\n                    /* We do not want to modifier the long long pointer here.\n                       So we save any other instances down the stack */\n                    save_reg_upstack(vtop->r, 1);\n                    /* load from memory */\n                    vtop->type.t = load_type;\n                    load(r, vtop);\n                    vdup();\n                    vtop[-1].r = r; /* save register value */\n                    /* increment pointer to get second word */\n                    incr_offset(PTR_SIZE);\n                } else {\n                    /* move registers */\n                    if (!r_ok)\n                        load(r, vtop);\n                    if (r2_ok && vtop->r2 < VT_CONST)\n                        goto done;\n                    vdup();\n                    vtop[-1].r = r; /* save register value */\n                    vtop->r = vtop[-1].r2;\n                }\n                /* Allocate second register. Here we rely on the fact that\n                   get_reg() tries first to free r2 of an SValue. */\n                r2 = get_reg(rc2);\n                load(r2, vtop);\n                vpop();\n                /* write second register */\n                vtop->r2 = r2;\n            done:\n                vtop->type.t = original_type;\n            } else {\n                if (vtop->r == VT_CMP)\n                    vset_VT_JMP();\n                /* one register type load */\n                load(r, vtop);\n            }\n        }\n        vtop->r = r;\n#ifdef TCC_TARGET_C67\n        /* uses register pairs for doubles */\n        if (bt == VT_DOUBLE)\n            vtop->r2 = r+1;\n#endif\n    }\n    return r;\n}\n\n/* generate vtop[-1] and vtop[0] in resp. classes rc1 and rc2 */\nST_FUNC void gv2(int rc1, int rc2)\n{\n    /* generate more generic register first. But VT_JMP or VT_CMP\n       values must be generated first in all cases to avoid possible\n       reload errors */\n    if (vtop->r != VT_CMP && rc1 <= rc2) {\n        vswap();\n        gv(rc1);\n        vswap();\n        gv(rc2);\n        /* test if reload is needed for first register */\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n            vswap();\n            gv(rc1);\n            vswap();\n        }\n    } else {\n        gv(rc2);\n        vswap();\n        gv(rc1);\n        vswap();\n        /* test if reload is needed for first register */\n        if ((vtop[0].r & VT_VALMASK) >= VT_CONST) {\n            gv(rc2);\n        }\n    }\n}\n\n#if PTR_SIZE == 4\n/* expand 64bit on stack in two ints */\nST_FUNC void lexpand(void)\n{\n    int u, v;\n    u = vtop->type.t & (VT_DEFSIGN | VT_UNSIGNED);\n    v = vtop->r & (VT_VALMASK | VT_LVAL);\n    if (v == VT_CONST) {\n        vdup();\n        vtop[0].c.i >>= 32;\n    } else if (v == (VT_LVAL|VT_CONST) || v == (VT_LVAL|VT_LOCAL)) {\n        vdup();\n        vtop[0].c.i += 4;\n    } else {\n        gv(RC_INT);\n        vdup();\n        vtop[0].r = vtop[-1].r2;\n        vtop[0].r2 = vtop[-1].r2 = VT_CONST;\n    }\n    vtop[0].type.t = vtop[-1].type.t = VT_INT | u;\n}\n#endif\n\n#if PTR_SIZE == 4\n/* build a long long from two ints */\nstatic void lbuild(int t)\n{\n    gv2(RC_INT, RC_INT);\n    vtop[-1].r2 = vtop[0].r;\n    vtop[-1].type.t = t;\n    vpop();\n}\n#endif\n\n/* convert stack entry to register and duplicate its value in another\n   register */\nstatic void gv_dup(void)\n{\n    int t, rc, r;\n\n    t = vtop->type.t;\n#if PTR_SIZE == 4\n    if ((t & VT_BTYPE) == VT_LLONG) {\n        if (t & VT_BITFIELD) {\n            gv(RC_INT);\n            t = vtop->type.t;\n        }\n        lexpand();\n        gv_dup();\n        vswap();\n        vrotb(3);\n        gv_dup();\n        vrotb(4);\n        /* stack: H L L1 H1 */\n        lbuild(t);\n        vrotb(3);\n        vrotb(3);\n        vswap();\n        lbuild(t);\n        vswap();\n        return;\n    }\n#endif\n    /* duplicate value */\n    rc = RC_TYPE(t);\n    gv(rc);\n    r = get_reg(rc);\n    vdup();\n    load(r, vtop);\n    vtop->r = r;\n}\n\n#if PTR_SIZE == 4\n/* generate CPU independent (unsigned) long long operations */\nstatic void gen_opl(int op)\n{\n    int t, a, b, op1, c, i;\n    int func;\n    unsigned short reg_iret = REG_IRET;\n    unsigned short reg_lret = REG_IRE2;\n    SValue tmp;\n\n    switch(op) {\n    case '/':\n    case TOK_PDIV:\n        func = TOK___divdi3;\n        goto gen_func;\n    case TOK_UDIV:\n        func = TOK___udivdi3;\n        goto gen_func;\n    case '%':\n        func = TOK___moddi3;\n        goto gen_mod_func;\n    case TOK_UMOD:\n        func = TOK___umoddi3;\n    gen_mod_func:\n#ifdef TCC_ARM_EABI\n        reg_iret = TREG_R2;\n        reg_lret = TREG_R3;\n#endif\n    gen_func:\n        /* call generic long long function */\n        vpush_helper_func(func);\n        vrott(3);\n        gfunc_call(2);\n        vpushi(0);\n        vtop->r = reg_iret;\n        vtop->r2 = reg_lret;\n        break;\n    case '^':\n    case '&':\n    case '|':\n    case '*':\n    case '+':\n    case '-':\n        //pv(\"gen_opl A\",0,2);\n        t = vtop->type.t;\n        vswap();\n        lexpand();\n        vrotb(3);\n        lexpand();\n        /* stack: L1 H1 L2 H2 */\n        tmp = vtop[0];\n        vtop[0] = vtop[-3];\n        vtop[-3] = tmp;\n        tmp = vtop[-2];\n        vtop[-2] = vtop[-3];\n        vtop[-3] = tmp;\n        vswap();\n        /* stack: H1 H2 L1 L2 */\n        //pv(\"gen_opl B\",0,4);\n        if (op == '*') {\n            vpushv(vtop - 1);\n            vpushv(vtop - 1);\n            gen_op(TOK_UMULL);\n            lexpand();\n            /* stack: H1 H2 L1 L2 ML MH */\n            for(i=0;i<4;i++)\n                vrotb(6);\n            /* stack: ML MH H1 H2 L1 L2 */\n            tmp = vtop[0];\n            vtop[0] = vtop[-2];\n            vtop[-2] = tmp;\n            /* stack: ML MH H1 L2 H2 L1 */\n            gen_op('*');\n            vrotb(3);\n            vrotb(3);\n            gen_op('*');\n            /* stack: ML MH M1 M2 */\n            gen_op('+');\n            gen_op('+');\n        } else if (op == '+' || op == '-') {\n            /* XXX: add non carry method too (for MIPS or alpha) */\n            if (op == '+')\n                op1 = TOK_ADDC1;\n            else\n                op1 = TOK_SUBC1;\n            gen_op(op1);\n            /* stack: H1 H2 (L1 op L2) */\n            vrotb(3);\n            vrotb(3);\n            gen_op(op1 + 1); /* TOK_xxxC2 */\n        } else {\n            gen_op(op);\n            /* stack: H1 H2 (L1 op L2) */\n            vrotb(3);\n            vrotb(3);\n            /* stack: (L1 op L2) H1 H2 */\n            gen_op(op);\n            /* stack: (L1 op L2) (H1 op H2) */\n        }\n        /* stack: L H */\n        lbuild(t);\n        break;\n    case TOK_SAR:\n    case TOK_SHR:\n    case TOK_SHL:\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            t = vtop[-1].type.t;\n            vswap();\n            lexpand();\n            vrotb(3);\n            /* stack: L H shift */\n            c = (int)vtop->c.i;\n            /* constant: simpler */\n            /* NOTE: all comments are for SHL. the other cases are\n               done by swapping words */\n            vpop();\n            if (op != TOK_SHL)\n                vswap();\n            if (c >= 32) {\n                /* stack: L H */\n                vpop();\n                if (c > 32) {\n                    vpushi(c - 32);\n                    gen_op(op);\n                }\n                if (op != TOK_SAR) {\n                    vpushi(0);\n                } else {\n                    gv_dup();\n                    vpushi(31);\n                    gen_op(TOK_SAR);\n                }\n                vswap();\n            } else {\n                vswap();\n                gv_dup();\n                /* stack: H L L */\n                vpushi(c);\n                gen_op(op);\n                vswap();\n                vpushi(32 - c);\n                if (op == TOK_SHL)\n                    gen_op(TOK_SHR);\n                else\n                    gen_op(TOK_SHL);\n                vrotb(3);\n                /* stack: L L H */\n                vpushi(c);\n                if (op == TOK_SHL)\n                    gen_op(TOK_SHL);\n                else\n                    gen_op(TOK_SHR);\n                gen_op('|');\n            }\n            if (op != TOK_SHL)\n                vswap();\n            lbuild(t);\n        } else {\n            /* XXX: should provide a faster fallback on x86 ? */\n            switch(op) {\n            case TOK_SAR:\n                func = TOK___ashrdi3;\n                goto gen_func;\n            case TOK_SHR:\n                func = TOK___lshrdi3;\n                goto gen_func;\n            case TOK_SHL:\n                func = TOK___ashldi3;\n                goto gen_func;\n            }\n        }\n        break;\n    default:\n        /* compare operations */\n        t = vtop->type.t;\n        vswap();\n        lexpand();\n        vrotb(3);\n        lexpand();\n        /* stack: L1 H1 L2 H2 */\n        tmp = vtop[-1];\n        vtop[-1] = vtop[-2];\n        vtop[-2] = tmp;\n        /* stack: L1 L2 H1 H2 */\n        if (!cur_switch || cur_switch->bsym) {\n            /* avoid differnt registers being saved in branches.\n               This is not needed when comparing switch cases */\n            save_regs(4);\n        }\n        /* compare high */\n        op1 = op;\n        /* when values are equal, we need to compare low words. since\n           the jump is inverted, we invert the test too. */\n        if (op1 == TOK_LT)\n            op1 = TOK_LE;\n        else if (op1 == TOK_GT)\n            op1 = TOK_GE;\n        else if (op1 == TOK_ULT)\n            op1 = TOK_ULE;\n        else if (op1 == TOK_UGT)\n            op1 = TOK_UGE;\n        a = 0;\n        b = 0;\n        gen_op(op1);\n        if (op == TOK_NE) {\n            b = gvtst(0, 0);\n        } else {\n            a = gvtst(1, 0);\n            if (op != TOK_EQ) {\n                /* generate non equal test */\n                vpushi(0);\n                vset_VT_CMP(TOK_NE);\n                b = gvtst(0, 0);\n            }\n        }\n        /* compare low. Always unsigned */\n        op1 = op;\n        if (op1 == TOK_LT)\n            op1 = TOK_ULT;\n        else if (op1 == TOK_LE)\n            op1 = TOK_ULE;\n        else if (op1 == TOK_GT)\n            op1 = TOK_UGT;\n        else if (op1 == TOK_GE)\n            op1 = TOK_UGE;\n        gen_op(op1);\n#if 0//def TCC_TARGET_I386\n        if (op == TOK_NE) { gsym(b); break; }\n        if (op == TOK_EQ) { gsym(a); break; }\n#endif\n        gvtst_set(1, a);\n        gvtst_set(0, b);\n        break;\n    }\n}\n#endif\n\n/* normalize values */\nstatic uint64_t value64(uint64_t l1, int t)\n{\n    if ((t & VT_BTYPE) == VT_LLONG\n        || (PTR_SIZE == 8 && (t & VT_BTYPE) == VT_PTR))\n        return l1;\n    else if (t & VT_UNSIGNED)\n        return (uint32_t)l1;\n    else\n        return (uint32_t)l1 | -(l1 & 0x80000000);\n}\n\nstatic uint64_t gen_opic_sdiv(uint64_t a, uint64_t b)\n{\n    uint64_t x = (a >> 63 ? -a : a) / (b >> 63 ? -b : b);\n    return (a ^ b) >> 63 ? -x : x;\n}\n\nstatic int gen_opic_lt(uint64_t a, uint64_t b)\n{\n    return (a ^ (uint64_t)1 << 63) < (b ^ (uint64_t)1 << 63);\n}\n\n/* handle integer constant optimizations and various machine\n   independent opt */\nstatic void gen_opic(int op)\n{\n    SValue *v1 = vtop - 1;\n    SValue *v2 = vtop;\n    int t1 = v1->type.t & VT_BTYPE;\n    int t2 = v2->type.t & VT_BTYPE;\n    int c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    int c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    uint64_t l1 = c1 ? value64(v1->c.i, v1->type.t) : 0;\n    uint64_t l2 = c2 ? value64(v2->c.i, v2->type.t) : 0;\n    int shm = (t1 == VT_LLONG) ? 63 : 31;\n    int r;\n\n    if (c1 && c2) {\n        switch(op) {\n        case '+': l1 += l2; break;\n        case '-': l1 -= l2; break;\n        case '&': l1 &= l2; break;\n        case '^': l1 ^= l2; break;\n        case '|': l1 |= l2; break;\n        case '*': l1 *= l2; break;\n\n        case TOK_PDIV:\n        case '/':\n        case '%':\n        case TOK_UDIV:\n        case TOK_UMOD:\n            /* if division by zero, generate explicit division */\n            if (l2 == 0) {\n                if (CONST_WANTED && !NOEVAL_WANTED)\n                    tcc_error(\"division by zero in constant\");\n                goto general_case;\n            }\n            switch(op) {\n            default: l1 = gen_opic_sdiv(l1, l2); break;\n            case '%': l1 = l1 - l2 * gen_opic_sdiv(l1, l2); break;\n            case TOK_UDIV: l1 = l1 / l2; break;\n            case TOK_UMOD: l1 = l1 % l2; break;\n            }\n            break;\n        case TOK_SHL: l1 <<= (l2 & shm); break;\n        case TOK_SHR: l1 >>= (l2 & shm); break;\n        case TOK_SAR:\n            l1 = (l1 >> 63) ? ~(~l1 >> (l2 & shm)) : l1 >> (l2 & shm);\n            break;\n            /* tests */\n        case TOK_ULT: l1 = l1 < l2; break;\n        case TOK_UGE: l1 = l1 >= l2; break;\n        case TOK_EQ: l1 = l1 == l2; break;\n        case TOK_NE: l1 = l1 != l2; break;\n        case TOK_ULE: l1 = l1 <= l2; break;\n        case TOK_UGT: l1 = l1 > l2; break;\n        case TOK_LT: l1 = gen_opic_lt(l1, l2); break;\n        case TOK_GE: l1 = !gen_opic_lt(l1, l2); break;\n        case TOK_LE: l1 = !gen_opic_lt(l2, l1); break;\n        case TOK_GT: l1 = gen_opic_lt(l2, l1); break;\n            /* logical */\n        case TOK_LAND: l1 = l1 && l2; break;\n        case TOK_LOR: l1 = l1 || l2; break;\n        default:\n            goto general_case;\n        }\n        v1->c.i = value64(l1, v1->type.t);\n        v1->r |= v2->r & VT_NONCONST;\n        vtop--;\n    } else {\n        /* if commutative ops, put c2 as constant */\n        if (c1 && (op == '+' || op == '&' || op == '^' || \n                   op == '|' || op == '*' || op == TOK_EQ || op == TOK_NE)) {\n            vswap();\n            c2 = c1; //c = c1, c1 = c2, c2 = c;\n            l2 = l1; //l = l1, l1 = l2, l2 = l;\n        }\n        if (c1 && ((l1 == 0 &&\n                    (op == TOK_SHL || op == TOK_SHR || op == TOK_SAR)) ||\n                   (l1 == -1 && op == TOK_SAR))) {\n            /* treat (0 << x), (0 >> x) and (-1 >> x) as constant */\n            vpop();\n        } else if (c2 && ((l2 == 0 && (op == '&' || op == '*')) ||\n                          (op == '|' &&\n                            (l2 == -1 || (l2 == 0xFFFFFFFF && t2 != VT_LLONG))) ||\n                          (l2 == 1 && (op == '%' || op == TOK_UMOD)))) {\n            /* treat (x & 0), (x * 0), (x | -1) and (x % 1) as constant */\n            if (l2 == 1)\n                vtop->c.i = 0;\n            vswap();\n            vtop--;\n        } else if (c2 && (((op == '*' || op == '/' || op == TOK_UDIV ||\n                          op == TOK_PDIV) &&\n                           l2 == 1) ||\n                          ((op == '+' || op == '-' || op == '|' || op == '^' ||\n                            op == TOK_SHL || op == TOK_SHR || op == TOK_SAR) &&\n                           l2 == 0) ||\n                          (op == '&' &&\n                            (l2 == -1 || (l2 == 0xFFFFFFFF && t2 != VT_LLONG))))) {\n            /* filter out NOP operations like x*1, x-0, x&-1... */\n            vtop--;\n        } else if (c2 && (op == '*' || op == TOK_PDIV || op == TOK_UDIV)) {\n            /* try to use shifts instead of muls or divs */\n            if (l2 > 0 && (l2 & (l2 - 1)) == 0) {\n                int n = -1;\n                while (l2) {\n                    l2 >>= 1;\n                    n++;\n                }\n                vtop->c.i = n;\n                if (op == '*')\n                    op = TOK_SHL;\n                else if (op == TOK_PDIV)\n                    op = TOK_SAR;\n                else\n                    op = TOK_SHR;\n            }\n            goto general_case;\n        } else if (c2 && (op == '+' || op == '-') &&\n                   (r = vtop[-1].r & (VT_VALMASK | VT_LVAL | VT_SYM),\n                    r == (VT_CONST | VT_SYM) || r == VT_LOCAL)) {\n            /* symbol + constant case */\n            if (op == '-')\n                l2 = -l2;\n\t    l2 += vtop[-1].c.i;\n\t    /* The backends can't always deal with addends to symbols\n\t       larger than +-1<<31.  Don't construct such.  */\n\t    if ((int)l2 != l2)\n\t        goto general_case;\n            vtop--;\n            vtop->c.i = l2;\n        } else {\n        general_case:\n                /* call low level op generator */\n                if (t1 == VT_LLONG || t2 == VT_LLONG ||\n                    (PTR_SIZE == 8 && (t1 == VT_PTR || t2 == VT_PTR)))\n                    gen_opl(op);\n                else\n                    gen_opi(op);\n        }\n        if (vtop->r == VT_CONST)\n            vtop->r |= VT_NONCONST; /* is const, but only by optimization */\n    }\n}\n\n#if defined TCC_TARGET_X86_64 || defined TCC_TARGET_I386\n# define gen_negf gen_opf\n#elif defined TCC_TARGET_ARM\nvoid gen_negf(int op)\n{\n    /* arm will detect 0-x and replace by vneg */\n    vpushi(0), vswap(), gen_op('-');\n}\n#else\n/* XXX: implement in gen_opf() for other backends too */\nvoid gen_negf(int op)\n{\n    /* In IEEE negate(x) isn't subtract(0,x).  Without NaNs it's\n       subtract(-0, x), but with them it's really a sign flip\n       operation.  We implement this with bit manipulation and have\n       to do some type reinterpretation for this, which TCC can do\n       only via memory.  */\n\n    int align, size, bt;\n\n    size = type_size(&vtop->type, &align);\n    bt = vtop->type.t & VT_BTYPE;\n    save_reg(gv(RC_TYPE(bt)));\n    vdup();\n    incr_bf_adr(size - 1);\n    vdup();\n    vpushi(0x80); /* flip sign */\n    gen_op('^');\n    vstore();\n    vpop();\n}\n#endif\n\n/* generate a floating point operation with constant propagation */\nstatic void gen_opif(int op)\n{\n    int c1, c2, i, bt;\n    SValue *v1, *v2;\n#if defined _MSC_VER && defined __x86_64__\n    /* avoid bad optimization with f1 -= f2 for f1:-0.0, f2:0.0 */\n    volatile\n#endif\n    long double f1, f2;\n\n    v1 = vtop - 1;\n    v2 = vtop;\n    if (op == TOK_NEG)\n        v1 = v2;\n    bt = v1->type.t & VT_BTYPE;\n\n    /* currently, we cannot do computations with forward symbols */\n    c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    if (c1 && c2) {\n        if (bt == VT_FLOAT) {\n            f1 = v1->c.f;\n            f2 = v2->c.f;\n        } else if (bt == VT_DOUBLE) {\n            f1 = v1->c.d;\n            f2 = v2->c.d;\n        } else {\n            f1 = v1->c.ld;\n            f2 = v2->c.ld;\n        }\n        /* NOTE: we only do constant propagation if finite number (not\n           NaN or infinity) (ANSI spec) */\n        if (!(ieee_finite(f1) || !ieee_finite(f2)) && !CONST_WANTED)\n            goto general_case;\n        switch(op) {\n        case '+': f1 += f2; break;\n        case '-': f1 -= f2; break;\n        case '*': f1 *= f2; break;\n        case '/': \n            if (f2 == 0.0) {\n                union { float f; unsigned u; } x1, x2, y;\n\t\t/* If not in initializer we need to potentially generate\n\t\t   FP exceptions at runtime, otherwise we want to fold.  */\n                if (!CONST_WANTED)\n                    goto general_case;\n                /* the run-time result of 0.0/0.0 on x87, also of other compilers\n                   when used to compile the f1 /= f2 below, would be -nan */\n                x1.f = f1, x2.f = f2;\n                if (f1 == 0.0)\n                    y.u = 0x7fc00000; /* nan */\n                else\n                    y.u = 0x7f800000; /* infinity */\n                y.u |= (x1.u ^ x2.u) & 0x80000000; /* set sign */\n                f1 = y.f;\n                break;\n            }\n            f1 /= f2;\n            break;\n        case TOK_NEG:\n            f1 = -f1;\n            goto unary_result;\n        case TOK_EQ:\n            i = f1 == f2;\n\tmake_int:\n            vtop -= 2;\n            vpushi(i);\n            return;\n        case TOK_NE:\n            i = f1 != f2;\n\t    goto make_int;\n        case TOK_LT:\n            i = f1 < f2;\n\t    goto make_int;\n        case TOK_GE:\n            i = f1 >= f2;\n\t    goto make_int;\n        case TOK_LE:\n            i = f1 <= f2;\n\t    goto make_int;\n        case TOK_GT:\n            i = f1 > f2;\n\t    goto make_int;\n        default:\n            goto general_case;\n        }\n        vtop--;\n    unary_result:\n        /* XXX: overflow test ? */\n        if (bt == VT_FLOAT) {\n            v1->c.f = f1;\n        } else if (bt == VT_DOUBLE) {\n            v1->c.d = f1;\n        } else {\n            v1->c.ld = f1;\n        }\n    } else {\n    general_case:\n        if (op == TOK_NEG) {\n            gen_negf(op);\n        } else {\n            gen_opf(op);\n        }\n    }\n}\n\n/* print a type. If 'varstr' is not NULL, then the variable is also\n   printed in the type */\n/* XXX: union */\n/* XXX: add array and function pointers */\nstatic void type_to_str(char *buf, int buf_size,\n                 CType *type, const char *varstr)\n{\n    int bt, v, t;\n    Sym *s, *sa;\n    char buf1[256];\n    const char *tstr;\n\n    t = type->t;\n    bt = t & VT_BTYPE;\n    buf[0] = '\\0';\n\n    if (t & VT_EXTERN)\n        pstrcat(buf, buf_size, \"extern \");\n    if (t & VT_STATIC)\n        pstrcat(buf, buf_size, \"static \");\n    if (t & VT_TYPEDEF)\n        pstrcat(buf, buf_size, \"typedef \");\n    if (t & VT_INLINE)\n        pstrcat(buf, buf_size, \"inline \");\n    if (bt != VT_PTR) {\n        if (t & VT_VOLATILE)\n            pstrcat(buf, buf_size, \"volatile \");\n        if (t & VT_CONSTANT)\n            pstrcat(buf, buf_size, \"const \");\n    }\n    if (((t & VT_DEFSIGN) && bt == VT_BYTE)\n        || ((t & VT_UNSIGNED)\n            && (bt == VT_SHORT || bt == VT_INT || bt == VT_LLONG)\n            && !IS_ENUM(t)\n            ))\n        pstrcat(buf, buf_size, (t & VT_UNSIGNED) ? \"unsigned \" : \"signed \");\n\n    buf_size -= strlen(buf);\n    buf += strlen(buf);\n\n    switch(bt) {\n    case VT_VOID:\n        tstr = \"void\";\n        goto add_tstr;\n    case VT_BOOL:\n        tstr = \"_Bool\";\n        goto add_tstr;\n    case VT_BYTE:\n        tstr = \"char\";\n        goto add_tstr;\n    case VT_SHORT:\n        tstr = \"short\";\n        goto add_tstr;\n    case VT_INT:\n        tstr = \"int\";\n        goto maybe_long;\n    case VT_LLONG:\n        tstr = \"long long\";\n    maybe_long:\n        if (t & VT_LONG)\n            tstr = \"long\";\n        if (!IS_ENUM(t))\n            goto add_tstr;\n        tstr = \"enum \";\n        goto tstruct;\n    case VT_FLOAT:\n        tstr = \"float\";\n        goto add_tstr;\n    case VT_DOUBLE:\n        tstr = \"double\";\n        if (!(t & VT_LONG))\n            goto add_tstr;\n    case VT_LDOUBLE:\n        tstr = \"long double\";\n    add_tstr:\n        pstrcat(buf, buf_size, tstr);\n        break;\n    case VT_STRUCT:\n        tstr = \"struct \";\n        if (IS_UNION(t))\n            tstr = \"union \";\n    tstruct:\n        pstrcat(buf, buf_size, tstr);\n        v = type->ref->v & ~SYM_STRUCT;\n        if (v >= SYM_FIRST_ANOM)\n            pstrcat(buf, buf_size, \"<anonymous>\");\n        else\n            pstrcat(buf, buf_size, get_tok_str(v, NULL));\n        break;\n    case VT_FUNC:\n        s = type->ref;\n        buf1[0]=0;\n        if (varstr && '*' == *varstr) {\n            pstrcat(buf1, sizeof(buf1), \"(\");\n            pstrcat(buf1, sizeof(buf1), varstr);\n            pstrcat(buf1, sizeof(buf1), \")\");\n        }\n        pstrcat(buf1, buf_size, \"(\");\n        sa = s->next;\n        while (sa != NULL) {\n            char buf2[256];\n            type_to_str(buf2, sizeof(buf2), &sa->type, NULL);\n            pstrcat(buf1, sizeof(buf1), buf2);\n            sa = sa->next;\n            if (sa)\n                pstrcat(buf1, sizeof(buf1), \", \");\n        }\n        if (s->f.func_type == FUNC_ELLIPSIS)\n            pstrcat(buf1, sizeof(buf1), \", ...\");\n        pstrcat(buf1, sizeof(buf1), \")\");\n        type_to_str(buf, buf_size, &s->type, buf1);\n        goto no_var;\n    case VT_PTR:\n        s = type->ref;\n        if (t & (VT_ARRAY|VT_VLA)) {\n            if (varstr && '*' == *varstr)\n                snprintf(buf1, sizeof(buf1), \"(%s)[%d]\", varstr, s->c);\n            else\n                snprintf(buf1, sizeof(buf1), \"%s[%d]\", varstr ? varstr : \"\", s->c);\n            type_to_str(buf, buf_size, &s->type, buf1);\n            goto no_var;\n        }\n        pstrcpy(buf1, sizeof(buf1), \"*\");\n        if (t & VT_CONSTANT)\n            pstrcat(buf1, buf_size, \"const \");\n        if (t & VT_VOLATILE)\n            pstrcat(buf1, buf_size, \"volatile \");\n        if (varstr)\n            pstrcat(buf1, sizeof(buf1), varstr);\n        type_to_str(buf, buf_size, &s->type, buf1);\n        goto no_var;\n    }\n    if (varstr) {\n        pstrcat(buf, buf_size, \" \");\n        pstrcat(buf, buf_size, varstr);\n    }\n no_var: ;\n}\n\nstatic void type_incompatibility_error(CType* st, CType* dt, const char* fmt)\n{\n    char buf1[256], buf2[256];\n    type_to_str(buf1, sizeof(buf1), st, NULL);\n    type_to_str(buf2, sizeof(buf2), dt, NULL);\n    tcc_error(fmt, buf1, buf2);\n}\n\nstatic void type_incompatibility_warning(CType* st, CType* dt, const char* fmt)\n{\n    char buf1[256], buf2[256];\n    type_to_str(buf1, sizeof(buf1), st, NULL);\n    type_to_str(buf2, sizeof(buf2), dt, NULL);\n    tcc_warning(fmt, buf1, buf2);\n}\n\nstatic int pointed_size(CType *type)\n{\n    int align;\n    return type_size(pointed_type(type), &align);\n}\n\nstatic inline int is_null_pointer(SValue *p)\n{\n    if ((p->r & (VT_VALMASK | VT_LVAL | VT_SYM | VT_NONCONST)) != VT_CONST)\n        return 0;\n    return ((p->type.t & VT_BTYPE) == VT_INT && (uint32_t)p->c.i == 0) ||\n        ((p->type.t & VT_BTYPE) == VT_LLONG && p->c.i == 0) ||\n        ((p->type.t & VT_BTYPE) == VT_PTR &&\n         (PTR_SIZE == 4 ? (uint32_t)p->c.i == 0 : p->c.i == 0) &&\n         ((pointed_type(&p->type)->t & VT_BTYPE) == VT_VOID) &&\n         0 == (pointed_type(&p->type)->t & (VT_CONSTANT | VT_VOLATILE))\n         );\n}\n\n/* compare function types. OLD functions match any new functions */\nstatic int is_compatible_func(CType *type1, CType *type2)\n{\n    Sym *s1, *s2;\n\n    s1 = type1->ref;\n    s2 = type2->ref;\n    if (s1->f.func_call != s2->f.func_call)\n        return 0;\n    if (s1->f.func_type != s2->f.func_type\n        && s1->f.func_type != FUNC_OLD\n        && s2->f.func_type != FUNC_OLD)\n        return 0;\n    for (;;) {\n        if (!is_compatible_unqualified_types(&s1->type, &s2->type))\n            return 0;\n        if (s1->f.func_type == FUNC_OLD || s2->f.func_type == FUNC_OLD )\n            return 1;\n        s1 = s1->next;\n        s2 = s2->next;\n        if (!s1)\n            return !s2;\n        if (!s2)\n            return 0;\n    }\n}\n\n/* return true if type1 and type2 are the same.  If unqualified is\n   true, qualifiers on the types are ignored.\n */\nstatic int compare_types(CType *type1, CType *type2, int unqualified)\n{\n    int bt1, t1, t2;\n\n    if (IS_ENUM(type1->t)) {\n        if (IS_ENUM(type2->t))\n            return type1->ref == type2->ref;\n        type1 = &type1->ref->type;\n    } else if (IS_ENUM(type2->t))\n        type2 = &type2->ref->type;\n\n    t1 = type1->t & VT_TYPE;\n    t2 = type2->t & VT_TYPE;\n    if (unqualified) {\n        /* strip qualifiers before comparing */\n        t1 &= ~(VT_CONSTANT | VT_VOLATILE);\n        t2 &= ~(VT_CONSTANT | VT_VOLATILE);\n    }\n\n    /* Default Vs explicit signedness only matters for char */\n    if ((t1 & VT_BTYPE) != VT_BYTE) {\n        t1 &= ~VT_DEFSIGN;\n        t2 &= ~VT_DEFSIGN;\n    }\n    /* XXX: bitfields ? */\n    if (t1 != t2)\n        return 0;\n\n    if ((t1 & VT_ARRAY)\n        && !(type1->ref->c < 0\n          || type2->ref->c < 0\n          || type1->ref->c == type2->ref->c))\n            return 0;\n\n    /* test more complicated cases */\n    bt1 = t1 & VT_BTYPE;\n    if (bt1 == VT_PTR) {\n        type1 = pointed_type(type1);\n        type2 = pointed_type(type2);\n        return is_compatible_types(type1, type2);\n    } else if (bt1 == VT_STRUCT) {\n        return (type1->ref == type2->ref);\n    } else if (bt1 == VT_FUNC) {\n        return is_compatible_func(type1, type2);\n    } else {\n        return 1;\n    }\n}\n\n#define CMP_OP 'C'\n#define SHIFT_OP 'S'\n\n/* Check if OP1 and OP2 can be \"combined\" with operation OP, the combined\n   type is stored in DEST if non-null (except for pointer plus/minus) . */\nstatic int combine_types(CType *dest, SValue *op1, SValue *op2, int op)\n{\n    CType *type1, *type2, type;\n    int t1, t2, bt1, bt2;\n    int ret = 1;\n\n    /* for shifts, 'combine' only left operand */\n    if (op == SHIFT_OP)\n        op2 = op1;\n\n    type1 = &op1->type, type2 = &op2->type;\n    t1 = type1->t, t2 = type2->t;\n    bt1 = t1 & VT_BTYPE, bt2 = t2 & VT_BTYPE;\n\n    type.t = VT_VOID;\n    type.ref = NULL;\n\n    if (bt1 == VT_VOID || bt2 == VT_VOID) {\n        ret = op == '?' ? 1 : 0;\n        /* NOTE: as an extension, we accept void on only one side */\n        type.t = VT_VOID;\n    } else if (bt1 == VT_PTR || bt2 == VT_PTR) {\n        if (op == '+') {\n          if (!is_integer_btype(bt1 == VT_PTR ? bt2 : bt1))\n            ret = 0;\n        }\n        /* http://port70.net/~nsz/c/c99/n1256.html#6.5.15p6 */\n        /* If one is a null ptr constant the result type is the other.  */\n        else if (is_null_pointer (op2)) type = *type1;\n        else if (is_null_pointer (op1)) type = *type2;\n        else if (bt1 != bt2) {\n            /* accept comparison or cond-expr between pointer and integer\n               with a warning */\n            if ((op == '?' || op == CMP_OP)\n                && (is_integer_btype(bt1) || is_integer_btype(bt2)))\n              tcc_warning(\"pointer/integer mismatch in %s\",\n                          op == '?' ? \"conditional expression\" : \"comparison\");\n            else if (op != '-' || !is_integer_btype(bt2))\n              ret = 0;\n            type = *(bt1 == VT_PTR ? type1 : type2);\n        } else {\n            CType *pt1 = pointed_type(type1);\n            CType *pt2 = pointed_type(type2);\n            int pbt1 = pt1->t & VT_BTYPE;\n            int pbt2 = pt2->t & VT_BTYPE;\n            int newquals, copied = 0;\n            if (pbt1 != VT_VOID && pbt2 != VT_VOID\n                && !compare_types(pt1, pt2, 1/*unqualif*/)) {\n                if (op != '?' && op != CMP_OP)\n                  ret = 0;\n                else\n                  type_incompatibility_warning(type1, type2,\n                    op == '?'\n                     ? \"pointer type mismatch in conditional expression ('%s' and '%s')\"\n                     : \"pointer type mismatch in comparison('%s' and '%s')\");\n            }\n            if (op == '?') {\n                /* pointers to void get preferred, otherwise the\n                   pointed to types minus qualifs should be compatible */\n                type = *((pbt1 == VT_VOID) ? type1 : type2);\n                /* combine qualifs */\n                newquals = ((pt1->t | pt2->t) & (VT_CONSTANT | VT_VOLATILE));\n                if ((~pointed_type(&type)->t & (VT_CONSTANT | VT_VOLATILE))\n                    & newquals)\n                  {\n                    /* copy the pointer target symbol */\n                    type.ref = sym_push(SYM_FIELD, &type.ref->type,\n                                        0, type.ref->c);\n                    copied = 1;\n                    pointed_type(&type)->t |= newquals;\n                  }\n                /* pointers to incomplete arrays get converted to\n                   pointers to completed ones if possible */\n                if (pt1->t & VT_ARRAY\n                    && pt2->t & VT_ARRAY\n                    && pointed_type(&type)->ref->c < 0\n                    && (pt1->ref->c > 0 || pt2->ref->c > 0))\n                  {\n                    if (!copied)\n                      type.ref = sym_push(SYM_FIELD, &type.ref->type,\n                                          0, type.ref->c);\n                    pointed_type(&type)->ref =\n                        sym_push(SYM_FIELD, &pointed_type(&type)->ref->type,\n                                 0, pointed_type(&type)->ref->c);\n                    pointed_type(&type)->ref->c =\n                        0 < pt1->ref->c ? pt1->ref->c : pt2->ref->c;\n                  }\n            }\n        }\n        if (op == CMP_OP)\n          type.t = VT_SIZE_T;\n    } else if (bt1 == VT_STRUCT || bt2 == VT_STRUCT) {\n        if (op != '?' || !compare_types(type1, type2, 1))\n          ret = 0;\n        type = *type1;\n    } else if (is_float(bt1) || is_float(bt2)) {\n        if (bt1 == VT_LDOUBLE || bt2 == VT_LDOUBLE) {\n            type.t = VT_LDOUBLE;\n        } else if (bt1 == VT_DOUBLE || bt2 == VT_DOUBLE) {\n            type.t = VT_DOUBLE;\n        } else {\n            type.t = VT_FLOAT;\n        }\n    } else if (bt1 == VT_LLONG || bt2 == VT_LLONG) {\n        /* cast to biggest op */\n        type.t = VT_LLONG | VT_LONG;\n        if (bt1 == VT_LLONG)\n          type.t &= t1;\n        if (bt2 == VT_LLONG)\n          type.t &= t2;\n        /* convert to unsigned if it does not fit in a long long */\n        if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED) ||\n            (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED))\n          type.t |= VT_UNSIGNED;\n    } else {\n        /* integer operations */\n        type.t = VT_INT | (VT_LONG & (t1 | t2));\n        /* convert to unsigned if it does not fit in an integer */\n        if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED) ||\n            (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED))\n          type.t |= VT_UNSIGNED;\n    }\n    if (dest)\n      *dest = type;\n    return ret;\n}\n\n/* generic gen_op: handles types problems */\nST_FUNC void gen_op(int op)\n{\n    int t1, t2, bt1, bt2, t;\n    CType type1, combtype;\n    int op_class = op;\n\n    if (op == TOK_SHR || op == TOK_SAR || op == TOK_SHL)\n        op_class = SHIFT_OP;\n    else if (TOK_ISCOND(op)) /* == != > ... */\n        op_class = CMP_OP;\n\nredo:\n    t1 = vtop[-1].type.t;\n    t2 = vtop[0].type.t;\n    bt1 = t1 & VT_BTYPE;\n    bt2 = t2 & VT_BTYPE;\n        \n    if (bt1 == VT_FUNC || bt2 == VT_FUNC) {\n\tif (bt2 == VT_FUNC) {\n\t    mk_pointer(&vtop->type);\n\t    gaddrof();\n\t}\n\tif (bt1 == VT_FUNC) {\n\t    vswap();\n\t    mk_pointer(&vtop->type);\n\t    gaddrof();\n\t    vswap();\n\t}\n\tgoto redo;\n    } else if (!combine_types(&combtype, vtop - 1, vtop, op_class)) {\nop_err:\n        tcc_error(\"invalid operand types for binary operation\");\n    } else if (bt1 == VT_PTR || bt2 == VT_PTR) {\n        /* at least one operand is a pointer */\n        /* relational op: must be both pointers */\n        int align;\n        if (op_class == CMP_OP)\n            goto std_op;\n        /* if both pointers, then it must be the '-' op */\n        if (bt1 == VT_PTR && bt2 == VT_PTR) {\n            if (op != '-')\n                goto op_err;\n            vpush_type_size(pointed_type(&vtop[-1].type), &align);\n            vtop->type.t &= ~VT_UNSIGNED;\n            vrott(3);\n            gen_opic(op);\n            vtop->type.t = VT_PTRDIFF_T;\n            vswap();\n            gen_op(TOK_PDIV);\n        } else {\n            /* exactly one pointer : must be '+' or '-'. */\n            if (op != '-' && op != '+')\n                goto op_err;\n            /* Put pointer as first operand */\n            if (bt2 == VT_PTR) {\n                vswap();\n                t = t1, t1 = t2, t2 = t;\n                bt2 = bt1;\n            }\n#if PTR_SIZE == 4\n            if (bt2 == VT_LLONG)\n                /* XXX: truncate here because gen_opl can't handle ptr + long long */\n                gen_cast_s(VT_INT);\n#endif\n            type1 = vtop[-1].type;\n            vpush_type_size(pointed_type(&vtop[-1].type), &align);\n            gen_op('*');\n#ifdef CONFIG_TCC_BCHECK\n            if (tcc_state->do_bounds_check && !CONST_WANTED) {\n                /* if bounded pointers, we generate a special code to\n                   test bounds */\n                if (op == '-') {\n                    vpushi(0);\n                    vswap();\n                    gen_op('-');\n                }\n                gen_bounded_ptr_add();\n            } else\n#endif\n            {\n                gen_opic(op);\n            }\n            type1.t &= ~(VT_ARRAY|VT_VLA);\n            /* put again type if gen_opic() swaped operands */\n            vtop->type = type1;\n        }\n    } else {\n        /* floats can only be used for a few operations */\n        if (is_float(combtype.t)\n            && op != '+' && op != '-' && op != '*' && op != '/'\n            && op_class != CMP_OP) {\n            goto op_err;\n        }\n    std_op:\n        t = t2 = combtype.t;\n        /* special case for shifts and long long: we keep the shift as\n           an integer */\n        if (op_class == SHIFT_OP)\n            t2 = VT_INT;\n        /* XXX: currently, some unsigned operations are explicit, so\n           we modify them here */\n        if (t & VT_UNSIGNED) {\n            if (op == TOK_SAR)\n                op = TOK_SHR;\n            else if (op == '/')\n                op = TOK_UDIV;\n            else if (op == '%')\n                op = TOK_UMOD;\n            else if (op == TOK_LT)\n                op = TOK_ULT;\n            else if (op == TOK_GT)\n                op = TOK_UGT;\n            else if (op == TOK_LE)\n                op = TOK_ULE;\n            else if (op == TOK_GE)\n                op = TOK_UGE;\n        }\n        vswap();\n        gen_cast_s(t);\n        vswap();\n        gen_cast_s(t2);\n        if (is_float(t))\n            gen_opif(op);\n        else\n            gen_opic(op);\n        if (op_class == CMP_OP) {\n            /* relational op: the result is an int */\n            vtop->type.t = VT_INT;\n        } else {\n            vtop->type.t = t;\n        }\n    }\n    // Make sure that we have converted to an rvalue:\n    if (vtop->r & VT_LVAL)\n        gv(is_float(vtop->type.t & VT_BTYPE) ? RC_FLOAT : RC_INT);\n}\n\n#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64 || defined TCC_TARGET_ARM\n#define gen_cvt_itof1 gen_cvt_itof\n#else\n/* generic itof for unsigned long long case */\nstatic void gen_cvt_itof1(int t)\n{\n    if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) == \n        (VT_LLONG | VT_UNSIGNED)) {\n\n        if (t == VT_FLOAT)\n            vpush_helper_func(TOK___floatundisf);\n#if LDOUBLE_SIZE != 8\n        else if (t == VT_LDOUBLE)\n            vpush_helper_func(TOK___floatundixf);\n#endif\n        else\n            vpush_helper_func(TOK___floatundidf);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        PUT_R_RET(vtop, t);\n    } else {\n        gen_cvt_itof(t);\n    }\n}\n#endif\n\n#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64\n#define gen_cvt_ftoi1 gen_cvt_ftoi\n#else\n/* generic ftoi for unsigned long long case */\nstatic void gen_cvt_ftoi1(int t)\n{\n    int st;\n    if (t == (VT_LLONG | VT_UNSIGNED)) {\n        /* not handled natively */\n        st = vtop->type.t & VT_BTYPE;\n        if (st == VT_FLOAT)\n            vpush_helper_func(TOK___fixunssfdi);\n#if LDOUBLE_SIZE != 8\n        else if (st == VT_LDOUBLE)\n            vpush_helper_func(TOK___fixunsxfdi);\n#endif\n        else\n            vpush_helper_func(TOK___fixunsdfdi);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        PUT_R_RET(vtop, t);\n    } else {\n        gen_cvt_ftoi(t);\n    }\n}\n#endif\n\n/* special delayed cast for char/short */\nstatic void force_charshort_cast(void)\n{\n    int sbt = BFGET(vtop->r, VT_MUSTCAST) == 2 ? VT_LLONG : VT_INT;\n    int dbt = vtop->type.t;\n    vtop->r &= ~VT_MUSTCAST;\n    vtop->type.t = sbt;\n    gen_cast_s(dbt == VT_BOOL ? VT_BYTE|VT_UNSIGNED : dbt);\n    vtop->type.t = dbt;\n}\n\nstatic void gen_cast_s(int t)\n{\n    CType type;\n    type.t = t;\n    type.ref = NULL;\n    gen_cast(&type);\n}\n\n/* cast 'vtop' to 'type'. Casting to bitfields is forbidden. */\nstatic void gen_cast(CType *type)\n{\n    int sbt, dbt, sf, df, c;\n    int dbt_bt, sbt_bt, ds, ss, bits, trunc;\n\n    /* special delayed cast for char/short */\n    if (vtop->r & VT_MUSTCAST)\n        force_charshort_cast();\n\n    /* bitfields first get cast to ints */\n    if (vtop->type.t & VT_BITFIELD)\n        gv(RC_INT);\n\n    if (IS_ENUM(type->t) && type->ref->c < 0)\n        tcc_error(\"cast to incomplete type\");\n\n    dbt = type->t & (VT_BTYPE | VT_UNSIGNED);\n    sbt = vtop->type.t & (VT_BTYPE | VT_UNSIGNED);\n    if (sbt == VT_FUNC)\n        sbt = VT_PTR;\n\nagain:\n    if (sbt != dbt) {\n        sf = is_float(sbt);\n        df = is_float(dbt);\n        dbt_bt = dbt & VT_BTYPE;\n        sbt_bt = sbt & VT_BTYPE;\n        if (dbt_bt == VT_VOID)\n            goto done;\n        if (sbt_bt == VT_VOID) {\nerror:\n            cast_error(&vtop->type, type);\n        }\n\n        c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n#if !defined TCC_IS_NATIVE && !defined TCC_IS_NATIVE_387\n        /* don't try to convert to ldouble when cross-compiling\n           (except when it's '0' which is needed for arm:gen_negf()) */\n        if (dbt_bt == VT_LDOUBLE && !nocode_wanted && (sf || vtop->c.i != 0))\n            c = 0;\n#endif\n        if (c) {\n            /* constant case: we can do it now */\n            /* XXX: in ISOC, cannot do it if error in convert */\n            if (sbt == VT_FLOAT)\n                vtop->c.ld = vtop->c.f;\n            else if (sbt == VT_DOUBLE)\n                vtop->c.ld = vtop->c.d;\n\n            if (df) {\n                if (sbt_bt == VT_LLONG) {\n                    if ((sbt & VT_UNSIGNED) || !(vtop->c.i >> 63))\n                        vtop->c.ld = vtop->c.i;\n                    else\n                        vtop->c.ld = -(long double)-vtop->c.i;\n                } else if(!sf) {\n                    if ((sbt & VT_UNSIGNED) || !(vtop->c.i >> 31))\n                        vtop->c.ld = (uint32_t)vtop->c.i;\n                    else\n                        vtop->c.ld = -(long double)-(uint32_t)vtop->c.i;\n                }\n\n                if (dbt == VT_FLOAT)\n                    vtop->c.f = (float)vtop->c.ld;\n                else if (dbt == VT_DOUBLE)\n                    vtop->c.d = (double)vtop->c.ld;\n            } else if (sf && dbt == VT_BOOL) {\n                vtop->c.i = (vtop->c.ld != 0);\n            } else {\n                if(sf) {\n                    if (dbt & VT_UNSIGNED)\n                        vtop->c.i = (uint64_t)vtop->c.ld;\n                    else\n                        vtop->c.i = (int64_t)vtop->c.ld;\n                }\n                else if (sbt_bt == VT_LLONG || (PTR_SIZE == 8 && sbt == VT_PTR))\n                    ;\n                else if (sbt & VT_UNSIGNED)\n                    vtop->c.i = (uint32_t)vtop->c.i;\n                else\n                    vtop->c.i = ((uint32_t)vtop->c.i | -(vtop->c.i & 0x80000000));\n\n                if (dbt_bt == VT_LLONG || (PTR_SIZE == 8 && dbt == VT_PTR))\n                    ;\n                else if (dbt == VT_BOOL)\n                    vtop->c.i = (vtop->c.i != 0);\n                else {\n                    uint32_t m = dbt_bt == VT_BYTE ? 0xff :\n                                 dbt_bt == VT_SHORT ? 0xffff :\n                                  0xffffffff;\n                    vtop->c.i &= m;\n                    if (!(dbt & VT_UNSIGNED))\n                        vtop->c.i |= -(vtop->c.i & ((m >> 1) + 1));\n                }\n            }\n            goto done;\n\n        } else if (dbt == VT_BOOL\n            && (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM))\n                == (VT_CONST | VT_SYM)) {\n            /* addresses are considered non-zero (see tcctest.c:sinit23) */\n            vtop->r = VT_CONST;\n            vtop->c.i = 1;\n            goto done;\n        }\n\n        /* cannot generate code for global or static initializers */\n        if (nocode_wanted & DATA_ONLY_WANTED)\n            goto done;\n\n        /* non constant case: generate code */\n        if (dbt == VT_BOOL) {\n            gen_test_zero(TOK_NE);\n            goto done;\n        }\n\n        if (sf || df) {\n            if (sf && df) {\n                /* convert from fp to fp */\n                gen_cvt_ftof(dbt);\n            } else if (df) {\n                /* convert int to fp */\n                gen_cvt_itof1(dbt);\n            } else {\n                /* convert fp to int */\n                sbt = dbt;\n                if (dbt_bt != VT_LLONG && dbt_bt != VT_INT)\n                    sbt = VT_INT;\n                gen_cvt_ftoi1(sbt);\n                goto again; /* may need char/short cast */\n            }\n            goto done;\n        }\n\n        ds = btype_size(dbt_bt);\n        ss = btype_size(sbt_bt);\n        if (ds == 0 || ss == 0)\n            goto error;\n\n        /* same size and no sign conversion needed */\n        if (ds == ss && ds >= 4)\n            goto done;\n        if (dbt_bt == VT_PTR || sbt_bt == VT_PTR) {\n            tcc_warning(\"cast between pointer and integer of different size\");\n            if (sbt_bt == VT_PTR) {\n                /* put integer type to allow logical operations below */\n                vtop->type.t = (PTR_SIZE == 8 ? VT_LLONG : VT_INT);\n            }\n        }\n\n        /* processor allows { int a = 0, b = *(char*)&a; }\n           That means that if we cast to less width, we can just\n           change the type and read it still later. */\n        #define ALLOW_SUBTYPE_ACCESS 1\n\n        if (ALLOW_SUBTYPE_ACCESS && (vtop->r & VT_LVAL)) {\n            /* value still in memory */\n            if (ds <= ss)\n                goto done;\n            /* ss <= 4 here */\n            if (ds <= 4 && !(dbt == (VT_SHORT | VT_UNSIGNED) && sbt == VT_BYTE)) {\n                gv(RC_INT);\n                goto done; /* no 64bit envolved */\n            }\n        }\n        gv(RC_INT);\n\n        trunc = 0;\n#if PTR_SIZE == 4\n        if (ds == 8) {\n            /* generate high word */\n            if (sbt & VT_UNSIGNED) {\n                vpushi(0);\n                gv(RC_INT);\n            } else {\n                gv_dup();\n                vpushi(31);\n                gen_op(TOK_SAR);\n            }\n            lbuild(dbt);\n        } else if (ss == 8) {\n            /* from long long: just take low order word */\n            lexpand();\n            vpop();\n        }\n        ss = 4;\n\n#elif PTR_SIZE == 8\n        if (ds == 8) {\n            /* need to convert from 32bit to 64bit */\n            if (sbt & VT_UNSIGNED) {\n#if defined(TCC_TARGET_RISCV64)\n                /* RISC-V keeps 32bit vals in registers sign-extended.\n                   So here we need a zero-extension.  */\n                trunc = 32;\n#else\n                goto done;\n#endif\n            } else {\n                gen_cvt_sxtw();\n                goto done;\n            }\n            ss = ds, ds = 4, dbt = sbt;\n        } else if (ss == 8) {\n            /* RISC-V keeps 32bit vals in registers sign-extended.\n               So here we need a sign-extension for signed types and\n               zero-extension. for unsigned types. */\n#if !defined(TCC_TARGET_RISCV64)\n            trunc = 32; /* zero upper 32 bits for non RISC-V targets */\n#endif\n        } else {\n            ss = 4;\n        }\n#endif\n\n        if (ds >= ss)\n            goto done;\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || defined TCC_TARGET_ARM64\n        if (ss == 4) {\n            gen_cvt_csti(dbt);\n            goto done;\n        }\n#endif\n        bits = (ss - ds) * 8;\n        /* for unsigned, gen_op will convert SAR to SHR */\n        vtop->type.t = (ss == 8 ? VT_LLONG : VT_INT) | (dbt & VT_UNSIGNED);\n        vpushi(bits);\n        gen_op(TOK_SHL);\n        vpushi(bits - trunc);\n        gen_op(TOK_SAR);\n        vpushi(trunc);\n        gen_op(TOK_SHR);\n    }\ndone:\n    vtop->type = *type;\n    vtop->type.t &= ~ ( VT_CONSTANT | VT_VOLATILE | VT_ARRAY );\n}\n\n/* return type size as known at compile time. Put alignment at 'a' */\nST_FUNC int type_size(CType *type, int *a)\n{\n    Sym *s;\n    int bt;\n\n    bt = type->t & VT_BTYPE;\n    if (bt == VT_STRUCT) {\n        /* struct/union */\n        s = type->ref;\n        *a = s->r;\n        return s->c;\n    } else if (bt == VT_PTR) {\n        if (type->t & VT_ARRAY) {\n            int ts;\n            s = type->ref;\n            ts = type_size(&s->type, a);\n            if (ts < 0 && s->c < 0)\n                ts = -ts;\n            return ts * s->c;\n        } else {\n            *a = PTR_SIZE;\n            return PTR_SIZE;\n        }\n    } else if (IS_ENUM(type->t) && type->ref->c < 0) {\n        *a = 0;\n        return -1; /* incomplete enum */\n    } else if (bt == VT_LDOUBLE) {\n        *a = LDOUBLE_ALIGN;\n        return LDOUBLE_SIZE;\n    } else if (bt == VT_DOUBLE || bt == VT_LLONG) {\n#if (defined TCC_TARGET_I386 && !defined TCC_TARGET_PE) \\\n || (defined TCC_TARGET_ARM && !defined TCC_ARM_EABI)\n        *a = 4;\n#else\n        *a = 8;\n#endif\n        return 8;\n    } else if (bt == VT_INT || bt == VT_FLOAT) {\n        *a = 4;\n        return 4;\n    } else if (bt == VT_SHORT) {\n        *a = 2;\n        return 2;\n    } else if (bt == VT_QLONG || bt == VT_QFLOAT) {\n        *a = 8;\n        return 16;\n    } else {\n        /* char, void, function, _Bool */\n        *a = 1;\n        return 1;\n    }\n}\n\n/* push type size as known at runtime time on top of value stack. Put\n   alignment at 'a' */\nstatic void vpush_type_size(CType *type, int *a)\n{\n    if (type->t & VT_VLA) {\n        type_size(&type->ref->type, a);\n        vset(&int_type, VT_LOCAL|VT_LVAL, type->ref->c);\n    } else {\n        int size = type_size(type, a);\n        if (size < 0)\n            tcc_error(\"unknown type size\");\n        vpushs(size);\n    }\n}\n\n/* return the pointed type of t */\nstatic inline CType *pointed_type(CType *type)\n{\n    return &type->ref->type;\n}\n\n/* modify type so that its it is a pointer to type. */\nST_FUNC void mk_pointer(CType *type)\n{\n    Sym *s;\n    s = sym_push(SYM_FIELD, type, 0, -1);\n    type->t = VT_PTR | (type->t & VT_STORAGE);\n    type->ref = s;\n}\n\n/* return true if type1 and type2 are exactly the same (including\n   qualifiers). \n*/\nstatic int is_compatible_types(CType *type1, CType *type2)\n{\n    return compare_types(type1,type2,0);\n}\n\n/* return true if type1 and type2 are the same (ignoring qualifiers).\n*/\nstatic int is_compatible_unqualified_types(CType *type1, CType *type2)\n{\n    return compare_types(type1,type2,1);\n}\n\nstatic void cast_error(CType *st, CType *dt)\n{\n    type_incompatibility_error(st, dt, \"cannot convert '%s' to '%s'\");\n}\n\n/* verify type compatibility to store vtop in 'dt' type */\nstatic void verify_assign_cast(CType *dt)\n{\n    CType *st, *type1, *type2;\n    int dbt, sbt, qualwarn, lvl;\n\n    st = &vtop->type; /* source type */\n    dbt = dt->t & VT_BTYPE;\n    sbt = st->t & VT_BTYPE;\n    if (dt->t & VT_CONSTANT)\n        tcc_warning(\"assignment of read-only location\");\n    switch(dbt) {\n    case VT_VOID:\n        if (sbt != dbt)\n            tcc_error(\"assignment to void expression\");\n        break;\n    case VT_PTR:\n        /* special cases for pointers */\n        /* '0' can also be a pointer */\n        if (is_null_pointer(vtop))\n            break;\n        /* accept implicit pointer to integer cast with warning */\n        if (is_integer_btype(sbt)) {\n            tcc_warning(\"assignment makes pointer from integer without a cast\");\n            break;\n        }\n        type1 = pointed_type(dt);\n        if (sbt == VT_PTR)\n            type2 = pointed_type(st);\n        else if (sbt == VT_FUNC)\n            type2 = st; /* a function is implicitly a function pointer */\n        else\n            goto error;\n        if (is_compatible_types(type1, type2))\n            break;\n        for (qualwarn = lvl = 0;; ++lvl) {\n            if (((type2->t & VT_CONSTANT) && !(type1->t & VT_CONSTANT)) ||\n                ((type2->t & VT_VOLATILE) && !(type1->t & VT_VOLATILE)))\n                qualwarn = 1;\n            dbt = type1->t & (VT_BTYPE|VT_LONG);\n            sbt = type2->t & (VT_BTYPE|VT_LONG);\n            if (dbt != VT_PTR || sbt != VT_PTR)\n                break;\n            type1 = pointed_type(type1);\n            type2 = pointed_type(type2);\n        }\n        if (!is_compatible_unqualified_types(type1, type2)) {\n            if ((dbt == VT_VOID || sbt == VT_VOID) && lvl == 0) {\n                /* void * can match anything */\n            } else if (dbt == sbt\n                && is_integer_btype(sbt & VT_BTYPE)\n                && IS_ENUM(type1->t) + IS_ENUM(type2->t)\n                    + !!((type1->t ^ type2->t) & VT_UNSIGNED) < 2) {\n\t\t/* Like GCC don't warn by default for merely changes\n\t\t   in pointer target signedness.  Do warn for different\n\t\t   base types, though, in particular for unsigned enums\n\t\t   and signed int targets.  */\n            } else {\n                tcc_warning(\"assignment from incompatible pointer type\");\n                break;\n            }\n        }\n        if (qualwarn)\n            tcc_warning_c(warn_discarded_qualifiers)(\"assignment discards qualifiers from pointer target type\");\n        break;\n    case VT_BYTE:\n    case VT_SHORT:\n    case VT_INT:\n    case VT_LLONG:\n        if (sbt == VT_PTR || sbt == VT_FUNC) {\n            tcc_warning(\"assignment makes integer from pointer without a cast\");\n        } else if (sbt == VT_STRUCT) {\n            goto case_VT_STRUCT;\n        }\n        /* XXX: more tests */\n        break;\n    case VT_STRUCT:\n    case_VT_STRUCT:\n        if (!is_compatible_unqualified_types(dt, st)) {\n    error:\n            cast_error(st, dt);\n        }\n        break;\n    }\n}\n\nstatic void gen_assign_cast(CType *dt)\n{\n    verify_assign_cast(dt);\n    gen_cast(dt);\n}\n\n/* store vtop in lvalue pushed on stack */\nST_FUNC void vstore(void)\n{\n    int sbt, dbt, ft, r, size, align, bit_size, bit_pos, delayed_cast;\n\n    ft = vtop[-1].type.t;\n    sbt = vtop->type.t & VT_BTYPE;\n    dbt = ft & VT_BTYPE;\n    verify_assign_cast(&vtop[-1].type);\n\n    if (sbt == VT_STRUCT) {\n        /* if structure, only generate pointer */\n        /* structure assignment : generate memcpy */\n        size = type_size(&vtop->type, &align);\n        /* destination, keep on stack() as result */\n        vpushv(vtop - 1);\n#ifdef CONFIG_TCC_BCHECK\n        if (vtop->r & VT_MUSTBOUND)\n            gbound(); /* check would be wrong after gaddrof() */\n#endif\n        vtop->type.t = VT_PTR;\n        gaddrof();\n        /* source */\n        vswap();\n#ifdef CONFIG_TCC_BCHECK\n        if (vtop->r & VT_MUSTBOUND)\n            gbound();\n#endif\n        vtop->type.t = VT_PTR;\n        gaddrof();\n\n#ifdef TCC_TARGET_NATIVE_STRUCT_COPY\n        if (1\n#ifdef CONFIG_TCC_BCHECK\n            && !tcc_state->do_bounds_check\n#endif\n            ) {\n            gen_struct_copy(size);\n        } else\n#endif\n        {\n            /* type size */\n            vpushi(size);\n            /* Use memmove, rather than memcpy, as dest and src may be same: */\n#ifdef TCC_ARM_EABI\n            if(!(align & 7))\n                vpush_helper_func(TOK_memmove8);\n            else if(!(align & 3))\n                vpush_helper_func(TOK_memmove4);\n            else\n#endif\n            vpush_helper_func(TOK_memmove);\n            vrott(4);\n            gfunc_call(3);\n        }\n\n    } else if (ft & VT_BITFIELD) {\n        /* bitfield store handling */\n\n        /* save lvalue as expression result (example: s.b = s.a = n;) */\n        vdup(), vtop[-1] = vtop[-2];\n\n        bit_pos = BIT_POS(ft);\n        bit_size = BIT_SIZE(ft);\n        /* remove bit field info to avoid loops */\n        vtop[-1].type.t = ft & ~VT_STRUCT_MASK;\n\n        if (dbt == VT_BOOL) {\n            gen_cast(&vtop[-1].type);\n            vtop[-1].type.t = (vtop[-1].type.t & ~VT_BTYPE) | (VT_BYTE | VT_UNSIGNED);\n        }\n        r = adjust_bf(vtop - 1, bit_pos, bit_size);\n        if (dbt != VT_BOOL) {\n            gen_cast(&vtop[-1].type);\n            dbt = vtop[-1].type.t & VT_BTYPE;\n        }\n        if (r == VT_STRUCT) {\n            store_packed_bf(bit_pos, bit_size);\n        } else {\n            unsigned long long mask = (1ULL << bit_size) - 1;\n            if (dbt != VT_BOOL) {\n                /* mask source */\n                if (dbt == VT_LLONG)\n                    vpushll(mask);\n                else\n                    vpushi((unsigned)mask);\n                gen_op('&');\n            }\n            /* shift source */\n            vpushi(bit_pos);\n            gen_op(TOK_SHL);\n            vswap();\n            /* duplicate destination */\n            vdup();\n            vrott(3);\n            /* load destination, mask and or with source */\n            if (dbt == VT_LLONG)\n                vpushll(~(mask << bit_pos));\n            else\n                vpushi(~((unsigned)mask << bit_pos));\n            gen_op('&');\n            gen_op('|');\n            /* store result */\n            vstore();\n            /* ... and discard */\n            vpop();\n        }\n    } else if (dbt == VT_VOID) {\n        --vtop;\n    } else {\n            /* optimize char/short casts */\n            delayed_cast = 0;\n            if ((dbt == VT_BYTE || dbt == VT_SHORT)\n                && is_integer_btype(sbt)\n                ) {\n                if ((vtop->r & VT_MUSTCAST)\n                    && btype_size(dbt) > btype_size(sbt)\n                    )\n                    force_charshort_cast();\n                delayed_cast = 1;\n            } else {\n                gen_cast(&vtop[-1].type);\n            }\n\n#ifdef CONFIG_TCC_BCHECK\n            /* bound check case */\n            if (vtop[-1].r & VT_MUSTBOUND) {\n                vswap();\n                gbound();\n                vswap();\n            }\n#endif\n            gv(RC_TYPE(dbt)); /* generate value */\n\n            if (delayed_cast) {\n                vtop->r |= BFVAL(VT_MUSTCAST, (sbt == VT_LLONG) + 1);\n                //tcc_warning(\"deley cast %x -> %x\", sbt, dbt);\n                vtop->type.t = ft & VT_TYPE;\n            }\n\n            /* if lvalue was saved on stack, must read it */\n            if ((vtop[-1].r & VT_VALMASK) == VT_LLOCAL) {\n                SValue sv;\n                r = get_reg(RC_INT);\n                sv.type.t = VT_PTRDIFF_T;\n                sv.r = VT_LOCAL | VT_LVAL;\n                sv.c.i = vtop[-1].c.i;\n                load(r, &sv);\n                vtop[-1].r = r | VT_LVAL;\n            }\n\n            r = vtop->r & VT_VALMASK;\n            /* two word case handling :\n               store second register at word + 4 (or +8 for x86-64)  */\n            if (USING_TWO_WORDS(dbt)) {\n                int load_type = (dbt == VT_QFLOAT) ? VT_DOUBLE : VT_PTRDIFF_T;\n                vtop[-1].type.t = load_type;\n                store(r, vtop - 1);\n                vswap();\n                incr_offset(PTR_SIZE);\n                vswap();\n                /* XXX: it works because r2 is spilled last ! */\n                store(vtop->r2, vtop - 1);\n            } else {\n                /* single word */\n                store(r, vtop - 1);\n            }\n        vswap();\n        vtop--; /* NOT vpop() because on x86 it would flush the fp stack */\n    }\n}\n\n/* post defines POST/PRE add. c is the token ++ or -- */\nST_FUNC void inc(int post, int c)\n{\n    test_lvalue();\n    vdup(); /* save lvalue */\n    if (post) {\n        gv_dup(); /* duplicate value */\n        vrotb(3);\n        vrotb(3);\n    }\n    /* add constant */\n    vpushi(c - TOK_MID); \n    gen_op('+');\n    vstore(); /* store value */\n    if (post)\n        vpop(); /* if post op, return saved value */\n}\n\nST_FUNC CString* parse_mult_str (const char *msg)\n{\n    /* read the string */\n    if (tok != TOK_STR)\n        expect(msg);\n    cstr_reset(&initstr);\n    while (tok == TOK_STR) {\n        /* XXX: add \\0 handling too ? */\n        cstr_cat(&initstr, tokc.str.data, -1);\n        next();\n    }\n    cstr_ccat(&initstr, '\\0');\n    return &initstr;\n}\n\n/* If I is >= 1 and a power of two, returns log2(i)+1.\n   If I is 0 returns 0.  */\nST_FUNC int exact_log2p1(int i)\n{\n  int ret;\n  if (!i)\n    return 0;\n  for (ret = 1; i >= 1 << 8; ret += 8)\n    i >>= 8;\n  if (i >= 1 << 4)\n    ret += 4, i >>= 4;\n  if (i >= 1 << 2)\n    ret += 2, i >>= 2;\n  if (i >= 1 << 1)\n    ret++;\n  return ret;\n}\n\n/* Parse __attribute__((...)) GNUC extension. */\nstatic void parse_attribute(AttributeDef *ad)\n{\n    int t, n;\n    char *astr;\n    \nredo:\n    if (tok != TOK_ATTRIBUTE1 && tok != TOK_ATTRIBUTE2)\n        return;\n    next();\n    skip('(');\n    skip('(');\n    while (tok != ')') {\n        if (tok < TOK_IDENT)\n            expect(\"attribute name\");\n        t = tok;\n        next();\n        switch(t) {\n\tcase TOK_CLEANUP1:\n\tcase TOK_CLEANUP2:\n\t{\n\t    Sym *s;\n\n\t    skip('(');\n\t    s = sym_find(tok);\n\t    if (!s) {\n\t        tcc_warning_c(warn_implicit_function_declaration)(\n                    \"implicit declaration of function '%s'\", get_tok_str(tok, &tokc));\n\t        s = external_global_sym(tok, &func_old_type);\n            } else if ((s->type.t & VT_BTYPE) != VT_FUNC)\n                tcc_error(\"'%s' is not declared as function\", get_tok_str(tok, &tokc));\n\t    ad->cleanup_func = s;\n\t    next();\n            skip(')');\n\t    break;\n\t}\n        case TOK_CONSTRUCTOR1:\n        case TOK_CONSTRUCTOR2:\n            ad->f.func_ctor = 1;\n            break;\n        case TOK_DESTRUCTOR1:\n        case TOK_DESTRUCTOR2:\n            ad->f.func_dtor = 1;\n            break;\n        case TOK_ALWAYS_INLINE1:\n        case TOK_ALWAYS_INLINE2:\n            ad->f.func_alwinl = 1;\n            break;\n        case TOK_SECTION1:\n        case TOK_SECTION2:\n            skip('(');\n\t    astr = parse_mult_str(\"section name\")->data;\n            ad->section = find_section(tcc_state, astr);\n            skip(')');\n            break;\n        case TOK_ALIAS1:\n        case TOK_ALIAS2:\n            skip('(');\n\t    astr = parse_mult_str(\"alias(\\\"target\\\")\")->data;\n            /* save string as token, for later */\n            ad->alias_target = tok_alloc_const(astr);\n            skip(')');\n            break;\n\tcase TOK_VISIBILITY1:\n\tcase TOK_VISIBILITY2:\n            skip('(');\n\t    astr = parse_mult_str(\"visibility(\\\"default|hidden|internal|protected\\\")\")->data;\n\t    if (!strcmp (astr, \"default\"))\n\t        ad->a.visibility = STV_DEFAULT;\n\t    else if (!strcmp (astr, \"hidden\"))\n\t        ad->a.visibility = STV_HIDDEN;\n\t    else if (!strcmp (astr, \"internal\"))\n\t        ad->a.visibility = STV_INTERNAL;\n\t    else if (!strcmp (astr, \"protected\"))\n\t        ad->a.visibility = STV_PROTECTED;\n\t    else\n                expect(\"visibility(\\\"default|hidden|internal|protected\\\")\");\n            skip(')');\n            break;\n        case TOK_ALIGNED1:\n        case TOK_ALIGNED2:\n            if (tok == '(') {\n                next();\n                n = expr_const();\n                if (n <= 0 || (n & (n - 1)) != 0) \n                    tcc_error(\"alignment must be a positive power of two\");\n                skip(')');\n            } else {\n                n = MAX_ALIGN;\n            }\n            ad->a.aligned = exact_log2p1(n);\n\t    if (n != 1 << (ad->a.aligned - 1))\n\t      tcc_error(\"alignment of %d is larger than implemented\", n);\n            break;\n        case TOK_PACKED1:\n        case TOK_PACKED2:\n            ad->a.packed = 1;\n            break;\n        case TOK_WEAK1:\n        case TOK_WEAK2:\n            ad->a.weak = 1;\n            break;\n        case TOK_NODEBUG1:\n        case TOK_NODEBUG2:\n            ad->a.nodebug = 1;\n            break;\n        case TOK_UNUSED1:\n        case TOK_UNUSED2:\n            /* currently, no need to handle it because tcc does not\n               track unused objects */\n            break;\n        case TOK_NORETURN1:\n        case TOK_NORETURN2:\n            ad->f.func_noreturn = 1;\n            break;\n        case TOK_CDECL1:\n        case TOK_CDECL2:\n        case TOK_CDECL3:\n            ad->f.func_call = FUNC_CDECL;\n            break;\n        case TOK_STDCALL1:\n        case TOK_STDCALL2:\n        case TOK_STDCALL3:\n            ad->f.func_call = FUNC_STDCALL;\n            break;\n#ifdef TCC_TARGET_I386\n        case TOK_REGPARM1:\n        case TOK_REGPARM2:\n            skip('(');\n            n = expr_const();\n            if (n > 3) \n                n = 3;\n            else if (n < 0)\n                n = 0;\n            if (n > 0)\n                ad->f.func_call = FUNC_FASTCALL1 + n - 1;\n            skip(')');\n            break;\n        case TOK_FASTCALL1:\n        case TOK_FASTCALL2:\n        case TOK_FASTCALL3:\n            ad->f.func_call = FUNC_FASTCALLW;\n            break;\n        case TOK_THISCALL1:\n        case TOK_THISCALL2:\n        case TOK_THISCALL3:\n            ad->f.func_call = FUNC_THISCALL;\n            break;\n#endif\n        case TOK_MODE:\n            skip('(');\n            switch(tok) {\n                case TOK_MODE_DI:\n                    ad->attr_mode = VT_LLONG + 1;\n                    break;\n                case TOK_MODE_QI:\n                    ad->attr_mode = VT_BYTE + 1;\n                    break;\n                case TOK_MODE_HI:\n                    ad->attr_mode = VT_SHORT + 1;\n                    break;\n                case TOK_MODE_SI:\n                case TOK_MODE_word:\n                    ad->attr_mode = VT_INT + 1;\n                    break;\n                default:\n                    tcc_warning(\"__mode__(%s) not supported\\n\", get_tok_str(tok, NULL));\n                    break;\n            }\n            next();\n            skip(')');\n            break;\n        case TOK_DLLEXPORT:\n            ad->a.dllexport = 1;\n            break;\n        case TOK_NODECORATE:\n            ad->a.nodecorate = 1;\n            break;\n        case TOK_DLLIMPORT:\n            ad->a.dllimport = 1;\n            break;\n        default:\n            tcc_warning_c(warn_unsupported)(\"'%s' attribute ignored\", get_tok_str(t, NULL));\n            /* skip parameters */\n            if (tok == '(') {\n                int parenthesis = 0;\n                do {\n                    if (tok == '(') \n                        parenthesis++;\n                    else if (tok == ')') \n                        parenthesis--;\n                    next();\n                } while (parenthesis && tok != -1);\n            }\n            break;\n        }\n        if (tok != ',')\n            break;\n        next();\n    }\n    skip(')');\n    skip(')');\n    goto redo;\n}\n\nstatic Sym * find_field (CType *type, int v, int *cumofs)\n{\n    Sym *s = type->ref;\n    int v1 = v | SYM_FIELD;\n    if (!(v & SYM_FIELD)) { /* top-level call */\n        if ((type->t & VT_BTYPE) != VT_STRUCT)\n            expect(\"struct or union\");\n        if (v < TOK_UIDENT)\n            expect(\"field name\");\n        if (s->c < 0)\n            tcc_error(\"dereferencing incomplete type '%s'\",\n                get_tok_str(s->v & ~SYM_STRUCT, 0));\n    }\n    while ((s = s->next) != NULL) {\n        if (s->v == v1) {\n            *cumofs = s->c;\n            return s;\n        }\n        if ((s->type.t & VT_BTYPE) == VT_STRUCT\n          && s->v >= (SYM_FIRST_ANOM | SYM_FIELD)) {\n            /* try to find field in anonymous sub-struct/union */\n            Sym *ret = find_field (&s->type, v1, cumofs);\n            if (ret) {\n                *cumofs += s->c;\n                return ret;\n            }\n        }\n    }\n    if (!(v & SYM_FIELD))\n        tcc_error(\"field not found: %s\", get_tok_str(v, NULL));\n    return s;\n}\n\nstatic void check_fields (CType *type, int check)\n{\n    Sym *s = type->ref;\n\n    while ((s = s->next) != NULL) {\n        int v = s->v & ~SYM_FIELD;\n        if (v < SYM_FIRST_ANOM) {\n            TokenSym *ts = table_ident[v - TOK_IDENT];\n            if (check && (ts->tok & SYM_FIELD))\n                tcc_error(\"duplicate member '%s'\", get_tok_str(v, NULL));\n            ts->tok ^= SYM_FIELD;\n        } else if ((s->type.t & VT_BTYPE) == VT_STRUCT)\n            check_fields (&s->type, check);\n    }\n}\n\nstatic void struct_layout(CType *type, AttributeDef *ad)\n{\n    int size, align, maxalign, offset, c, bit_pos, bit_size;\n    int packed, a, bt, prevbt, prev_bit_size;\n    int pcc = !tcc_state->ms_bitfields;\n    int pragma_pack = *tcc_state->pack_stack_ptr;\n    Sym *f;\n\n    maxalign = 1;\n    offset = 0;\n    c = 0;\n    bit_pos = 0;\n    prevbt = VT_STRUCT; /* make it never match */\n    prev_bit_size = 0;\n\n//#define BF_DEBUG\n\n    for (f = type->ref->next; f; f = f->next) {\n        if (f->type.t & VT_BITFIELD)\n            bit_size = BIT_SIZE(f->type.t);\n        else\n            bit_size = -1;\n        size = type_size(&f->type, &align);\n        a = f->a.aligned ? 1 << (f->a.aligned - 1) : 0;\n        packed = 0;\n\n        if (pcc && bit_size == 0) {\n            /* in pcc mode, packing does not affect zero-width bitfields */\n\n        } else {\n            /* in pcc mode, attribute packed overrides if set. */\n            if (pcc && (f->a.packed || ad->a.packed))\n                align = packed = 1;\n\n            /* pragma pack overrides align if lesser and packs bitfields always */\n            if (pragma_pack) {\n                packed = 1;\n                if (pragma_pack < align)\n                    align = pragma_pack;\n                /* in pcc mode pragma pack also overrides individual align */\n                if (pcc && pragma_pack < a)\n                    a = 0;\n            }\n        }\n        /* some individual align was specified */\n        if (a)\n            align = a;\n\n        if (type->ref->type.t == VT_UNION) {\n\t    if (pcc && bit_size >= 0)\n\t        size = (bit_size + 7) >> 3;\n\t    offset = 0;\n\t    if (size > c)\n\t        c = size;\n\n\t} else if (bit_size < 0) {\n            if (pcc)\n                c += (bit_pos + 7) >> 3;\n\t    c = (c + align - 1) & -align;\n\t    offset = c;\n\t    if (size > 0)\n\t        c += size;\n\t    bit_pos = 0;\n\t    prevbt = VT_STRUCT;\n\t    prev_bit_size = 0;\n\n\t} else {\n\t    /* A bit-field.  Layout is more complicated.  There are two\n\t       options: PCC (GCC) compatible and MS compatible */\n            if (pcc) {\n\t\t/* In PCC layout a bit-field is placed adjacent to the\n                   preceding bit-fields, except if:\n                   - it has zero-width\n                   - an individual alignment was given\n                   - it would overflow its base type container and\n                     there is no packing */\n                if (bit_size == 0) {\n            new_field:\n\t\t    c = (c + ((bit_pos + 7) >> 3) + align - 1) & -align;\n\t\t    bit_pos = 0;\n                } else if (f->a.aligned) {\n                    goto new_field;\n                } else if (!packed) {\n                    int a8 = align * 8;\n\t            int ofs = ((c * 8 + bit_pos) % a8 + bit_size + a8 - 1) / a8;\n                    if (ofs > size / align)\n                        goto new_field;\n                }\n\n                /* in pcc mode, long long bitfields have type int if they fit */\n                if (size == 8 && bit_size <= 32)\n                    f->type.t = (f->type.t & ~VT_BTYPE) | VT_INT, size = 4;\n\n                while (bit_pos >= align * 8)\n                    c += align, bit_pos -= align * 8;\n                offset = c;\n\n\t\t/* In PCC layout named bit-fields influence the alignment\n\t\t   of the containing struct using the base types alignment,\n\t\t   except for packed fields (which here have correct align).  */\n\t\tif (f->v & SYM_FIRST_ANOM\n                    // && bit_size // ??? gcc on ARM/rpi does that\n                    )\n\t\t    align = 1;\n\n\t    } else {\n\t\tbt = f->type.t & VT_BTYPE;\n\t\tif ((bit_pos + bit_size > size * 8)\n                    || (bit_size > 0) == (bt != prevbt)\n                    ) {\n\t\t    c = (c + align - 1) & -align;\n\t\t    offset = c;\n\t\t    bit_pos = 0;\n\t\t    /* In MS bitfield mode a bit-field run always uses\n\t\t       at least as many bits as the underlying type.\n\t\t       To start a new run it's also required that this\n\t\t       or the last bit-field had non-zero width.  */\n\t\t    if (bit_size || prev_bit_size)\n\t\t        c += size;\n\t\t}\n\t\t/* In MS layout the records alignment is normally\n\t\t   influenced by the field, except for a zero-width\n\t\t   field at the start of a run (but by further zero-width\n\t\t   fields it is again).  */\n\t\tif (bit_size == 0 && prevbt != bt)\n\t\t    align = 1;\n\t\tprevbt = bt;\n                prev_bit_size = bit_size;\n\t    }\n\n\t    f->type.t = (f->type.t & ~(0x3f << VT_STRUCT_SHIFT))\n\t\t        | (bit_pos << VT_STRUCT_SHIFT);\n\t    bit_pos += bit_size;\n\t}\n\tif (align > maxalign)\n\t    maxalign = align;\n\n#ifdef BF_DEBUG\n\tprintf(\"set field %s offset %-2d size %-2d align %-2d\",\n\t       get_tok_str(f->v & ~SYM_FIELD, NULL), offset, size, align);\n\tif (f->type.t & VT_BITFIELD) {\n\t    printf(\" pos %-2d bits %-2d\",\n                    BIT_POS(f->type.t),\n                    BIT_SIZE(f->type.t)\n                    );\n\t}\n\tprintf(\"\\n\");\n#endif\n\n        f->c = offset;\n\tf->r = 0;\n    }\n\n    if (pcc)\n        c += (bit_pos + 7) >> 3;\n\n    /* store size and alignment */\n    a = bt = ad->a.aligned ? 1 << (ad->a.aligned - 1) : 1;\n    if (a < maxalign)\n        a = maxalign;\n    type->ref->r = a;\n    if (pragma_pack && pragma_pack < maxalign && 0 == pcc) {\n        /* can happen if individual align for some member was given.  In\n           this case MSVC ignores maxalign when aligning the size */\n        a = pragma_pack;\n        if (a < bt)\n            a = bt;\n    }\n    c = (c + a - 1) & -a;\n    type->ref->c = c;\n\n#ifdef BF_DEBUG\n    printf(\"struct size %-2d align %-2d\\n\\n\", c, a), fflush(stdout);\n#endif\n\n    /* check whether we can access bitfields by their type */\n    for (f = type->ref->next; f; f = f->next) {\n        int s, px, cx, c0;\n        CType t;\n\n        if (0 == (f->type.t & VT_BITFIELD))\n            continue;\n        f->type.ref = f;\n        f->auxtype = -1;\n        bit_size = BIT_SIZE(f->type.t);\n        if (bit_size == 0)\n            continue;\n        bit_pos = BIT_POS(f->type.t);\n        size = type_size(&f->type, &align);\n\n        if (bit_pos + bit_size <= size * 8 && f->c + size <= c\n#ifdef TCC_TARGET_ARM\n            && !(f->c & (align - 1))\n#endif\n            )\n            continue;\n\n        /* try to access the field using a different type */\n        c0 = -1, s = align = 1;\n        t.t = VT_BYTE;\n        for (;;) {\n            px = f->c * 8 + bit_pos;\n            cx = (px >> 3) & -align;\n            px = px - (cx << 3);\n            if (c0 == cx)\n                break;\n            s = (px + bit_size + 7) >> 3;\n            if (s > 4) {\n                t.t = VT_LLONG;\n            } else if (s > 2) {\n                t.t = VT_INT;\n            } else if (s > 1) {\n                t.t = VT_SHORT;\n            } else {\n                t.t = VT_BYTE;\n            }\n            s = type_size(&t, &align);\n            c0 = cx;\n        }\n\n        if (px + bit_size <= s * 8 && cx + s <= c\n#ifdef TCC_TARGET_ARM\n            && !(cx & (align - 1))\n#endif\n            ) {\n            /* update offset and bit position */\n            f->c = cx;\n            bit_pos = px;\n\t    f->type.t = (f->type.t & ~(0x3f << VT_STRUCT_SHIFT))\n\t\t        | (bit_pos << VT_STRUCT_SHIFT);\n            if (s != size)\n                f->auxtype = t.t;\n#ifdef BF_DEBUG\n            printf(\"FIX field %s offset %-2d size %-2d align %-2d \"\n                \"pos %-2d bits %-2d\\n\",\n                get_tok_str(f->v & ~SYM_FIELD, NULL),\n                cx, s, align, px, bit_size);\n#endif\n        } else {\n            /* fall back to load/store single-byte wise */\n            f->auxtype = VT_STRUCT;\n#ifdef BF_DEBUG\n            printf(\"FIX field %s : load byte-wise\\n\",\n                 get_tok_str(f->v & ~SYM_FIELD, NULL));\n#endif\n        }\n    }\n}\n\n/* enum/struct/union declaration. u is VT_ENUM/VT_STRUCT/VT_UNION */\nstatic void struct_decl(CType *type, int u)\n{\n    int v, c, size, align, flexible;\n    int bit_size, bsize, bt, ut;\n    Sym *s, *ss, **ps;\n    AttributeDef ad, ad1;\n    CType type1, btype;\n\n    memset(&ad, 0, sizeof ad);\n    next();\n    parse_attribute(&ad);\n\n    v = 0;\n    if (tok >= TOK_IDENT) /* struct/enum tag */\n        v = tok, next();\n\n    bt = ut = 0;\n    if (u == VT_ENUM) {\n        ut = VT_INT;\n        if (tok == ':') { /* C2x enum : <type> ... */\n            next();\n            if (!parse_btype(&btype, &ad1, 0)\n             || !is_integer_btype(btype.t & VT_BTYPE))\n                expect(\"enum type\");\n            bt = ut = btype.t & (VT_BTYPE|VT_LONG|VT_UNSIGNED|VT_DEFSIGN);\n        }\n    }\n\n    if (v) {\n        /* struct already defined ? return it */\n        s = struct_find(v);\n        if (s && (s->sym_scope == local_scope || (tok != '{' && tok != ';'))) {\n            if (u == s->type.t)\n                goto do_decl;\n            if (u == VT_ENUM && IS_ENUM(s->type.t)) /* XXX: check integral types */\n                goto do_decl;\n            tcc_error(\"redeclaration of '%s'\", get_tok_str(v, NULL));\n        }\n    } else {\n        if (tok != '{')\n            expect(\"struct/union/enum name\");\n        v = anon_sym++;\n    }\n    /* Record the original enum/struct/union token.  */\n    type1.t = u | ut;\n    type1.ref = NULL;\n    /* we put an undefined size for struct/union */\n    s = sym_push(v | SYM_STRUCT, &type1, 0, bt ? 0 : -1);\n    s->r = 0; /* default alignment is zero as gcc */\ndo_decl:\n    type->t = s->type.t;\n    type->ref = s;\n\n    if (tok == '{') {\n        next();\n        if (s->c != -1\n            && !(u == VT_ENUM && s->c == 0)) /* not yet defined typed enum */\n            tcc_error(\"struct/union/enum already defined\");\n        s->c = -2;\n        /* cannot be empty */\n        /* non empty enums are not allowed */\n        ps = &s->next;\n        if (u == VT_ENUM) {\n            long long ll = 0, pl = 0, nl = 0;\n\t    CType t;\n            t.ref = s;\n            /* enum symbols have static storage */\n            t.t = VT_INT|VT_STATIC|VT_ENUM_VAL;\n            if (bt)\n                t.t = bt|VT_STATIC|VT_ENUM_VAL;\n            for(;;) {\n                v = tok;\n                if (v < TOK_UIDENT)\n                    expect(\"identifier\");\n                ss = sym_find(v);\n                if (ss && !local_stack)\n                    tcc_error(\"redefinition of enumerator '%s'\",\n                              get_tok_str(v, NULL));\n                next();\n                if (tok == '=') {\n                    next();\n\t\t    ll = expr_const64();\n                }\n                ss = sym_push(v, &t, VT_CONST, 0);\n                ss->enum_val = ll;\n                *ps = ss, ps = &ss->next;\n                if (ll < nl)\n                    nl = ll;\n                if (ll > pl)\n                    pl = ll;\n                if (tok != ',')\n                    break;\n                next();\n                ll++;\n                /* NOTE: we accept a trailing comma */\n                if (tok == '}')\n                    break;\n            }\n            skip('}');\n\n            if (bt) {\n                t.t = bt;\n                s->c = 2;\n                goto enum_done;\n            }\n\n            /* set integral type of the enum */\n            t.t = VT_INT;\n            if (nl >= 0) {\n                if (pl != (unsigned)pl)\n                    t.t = (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);\n                t.t |= VT_UNSIGNED;\n            } else if (pl != (int)pl || nl != (int)nl)\n                t.t = (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);\n\n            /* set type for enum members */\n            for (ss = s->next; ss; ss = ss->next) {\n                ll = ss->enum_val;\n                if (ll == (int)ll) /* default is int if it fits */\n                    continue;\n                if (t.t & VT_UNSIGNED) {\n                    ss->type.t |= VT_UNSIGNED;\n                    if (ll == (unsigned)ll)\n                        continue;\n                }\n                ss->type.t = (ss->type.t & ~VT_BTYPE)\n                    | (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);\n            }\n            s->c = 1;\n        enum_done:\n            s->type.t = type->t = t.t | VT_ENUM;\n\n        } else {\n            c = 0;\n            flexible = 0;\n            while (tok != '}') {\n                if (!parse_btype(&btype, &ad1, 0)) {\n                    if (tok == TOK_STATIC_ASSERT) {\n                        do_Static_assert();\n                        continue;\n                    }\n\t\t    skip(';');\n\t\t    continue;\n\t\t}\n                while (1) {\n\t\t    if (flexible)\n\t\t        tcc_error(\"flexible array member '%s' not at the end of struct\",\n                              get_tok_str(v, NULL));\n                    bit_size = -1;\n                    v = 0;\n                    type1 = btype;\n                    if (tok != ':') {\n\t\t\tif (tok != ';')\n                            type_decl(&type1, &ad1, &v, TYPE_DIRECT);\n                        if (v == 0) {\n                    \t    if ((type1.t & VT_BTYPE) != VT_STRUCT)\n                        \texpect(\"identifier\");\n                    \t    else {\n\t\t\t\tint v = btype.ref->v;\n\t\t\t\tif (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {\n\t\t\t\t    if (tcc_state->ms_extensions == 0)\n                        \t\texpect(\"identifier\");\n\t\t\t\t}\n                    \t    }\n                        }\n                        if (type_size(&type1, &align) < 0) {\n\t\t\t    if ((u == VT_STRUCT) && (type1.t & VT_ARRAY) && c)\n\t\t\t        flexible = 1;\n\t\t\t    else\n\t\t\t        tcc_error(\"field '%s' has incomplete type\",\n                                      get_tok_str(v, NULL));\n                        }\n                        if ((type1.t & VT_BTYPE) == VT_FUNC ||\n\t\t\t    (type1.t & VT_BTYPE) == VT_VOID ||\n                            (type1.t & VT_STORAGE))\n                            tcc_error(\"invalid type for '%s'\", \n                                  get_tok_str(v, NULL));\n                    }\n                    if (tok == ':') {\n                        next();\n                        bit_size = expr_const();\n                        /* XXX: handle v = 0 case for messages */\n                        if (bit_size < 0)\n                            tcc_error(\"negative width in bit-field '%s'\", \n                                  get_tok_str(v, NULL));\n                        if (v && bit_size == 0)\n                            tcc_error(\"zero width for bit-field '%s'\", \n                                  get_tok_str(v, NULL));\n\t\t\tparse_attribute(&ad1);\n                    }\n                    size = type_size(&type1, &align);\n                    if (bit_size >= 0) {\n                        bt = type1.t & VT_BTYPE;\n                        if (bt != VT_INT && \n                            bt != VT_BYTE && \n                            bt != VT_SHORT &&\n                            bt != VT_BOOL &&\n                            bt != VT_LLONG)\n                            tcc_error(\"bitfields must have scalar type\");\n                        bsize = size * 8;\n                        if (bit_size > bsize) {\n                            tcc_error(\"width of '%s' exceeds its type\",\n                                  get_tok_str(v, NULL));\n                        } else if (bit_size == bsize\n                                    && !ad.a.packed && !ad1.a.packed) {\n                            /* no need for bit fields */\n                            ;\n                        } else if (bit_size == 64) {\n                            tcc_error(\"field width 64 not implemented\");\n                        } else {\n                            type1.t = (type1.t & ~VT_STRUCT_MASK)\n                                | VT_BITFIELD\n                                | (bit_size << (VT_STRUCT_SHIFT + 6));\n                        }\n                    }\n                    if (v != 0 || (type1.t & VT_BTYPE) == VT_STRUCT) {\n                        /* Remember we've seen a real field to check\n\t\t\t   for placement of flexible array member. */\n\t\t\tc = 1;\n                    }\n\t\t    /* If member is a struct or bit-field, enforce\n\t\t       placing into the struct (as anonymous).  */\n                    if (v == 0 &&\n\t\t\t((type1.t & VT_BTYPE) == VT_STRUCT ||\n\t\t\t bit_size >= 0)) {\n\t\t        v = anon_sym++;\n\t\t    }\n                    if (v) {\n                        ss = sym_push(v | SYM_FIELD, &type1, 0, 0);\n                        ss->a = ad1.a;\n                        *ps = ss;\n                        ps = &ss->next;\n                    }\n                    if (tok == ';' || tok == TOK_EOF)\n                        break;\n                    skip(',');\n                }\n                skip(';');\n            }\n            skip('}');\n\t    parse_attribute(&ad);\n            if (ad.cleanup_func) {\n                tcc_warning(\"attribute '__cleanup__' ignored on type\");\n            }\n\t    check_fields(type, 1);\n\t    check_fields(type, 0);\n            struct_layout(type, &ad);\n\t    if (debug_modes)\n\t\ttcc_debug_fix_anon(tcc_state, type);\n        }\n    }\n}\n\nstatic void sym_to_attr(AttributeDef *ad, Sym *s)\n{\n    merge_symattr(&ad->a, &s->a);\n    merge_funcattr(&ad->f, &s->f);\n}\n\n/* Add type qualifiers to a type. If the type is an array then the qualifiers\n   are added to the element type, copied because it could be a typedef. */\nstatic void parse_btype_qualify(CType *type, int qualifiers)\n{\n    while (type->t & VT_ARRAY) {\n        type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);\n        type = &type->ref->type;\n    }\n    type->t |= qualifiers;\n}\n\n/* return 0 if no type declaration. otherwise, return the basic type\n   and skip it. \n */\nstatic int parse_btype(CType *type, AttributeDef *ad, int ignore_label)\n{\n    int t, u, bt, st, type_found, typespec_found, g, n;\n    Sym *s;\n    CType type1;\n\n    memset(ad, 0, sizeof(AttributeDef));\n    type_found = 0;\n    typespec_found = 0;\n    t = VT_INT;\n    bt = st = -1;\n    type->ref = NULL;\n\n    while(1) {\n        switch(tok) {\n        case TOK_EXTENSION:\n            /* currently, we really ignore extension */\n            next();\n            continue;\n\n            /* basic types */\n        case TOK_CHAR:\n            u = VT_BYTE;\n        basic_type:\n            next();\n        basic_type1:\n            if (u == VT_SHORT || u == VT_LONG) {\n                if (st != -1 || (bt != -1 && bt != VT_INT))\n                    tmbt: tcc_error(\"too many basic types\");\n                st = u;\n            } else {\n                if (bt != -1 || (st != -1 && u != VT_INT))\n                    goto tmbt;\n                bt = u;\n            }\n            if (u != VT_INT)\n                t = (t & ~(VT_BTYPE|VT_LONG)) | u;\n            typespec_found = 1;\n            break;\n        case TOK_VOID:\n            u = VT_VOID;\n            goto basic_type;\n        case TOK_SHORT:\n            u = VT_SHORT;\n            goto basic_type;\n        case TOK_INT:\n            u = VT_INT;\n            goto basic_type;\n        case TOK_ALIGNAS:\n            { int n;\n              AttributeDef ad1;\n              next();\n              skip('(');\n              memset(&ad1, 0, sizeof(AttributeDef));\n              if (parse_btype(&type1, &ad1, 0)) {\n                  type_decl(&type1, &ad1, &n, TYPE_ABSTRACT);\n                  if (ad1.a.aligned)\n                    n = 1 << (ad1.a.aligned - 1);\n                  else\n                    type_size(&type1, &n);\n              } else {\n                  n = expr_const();\n                  if (n < 0 || (n & (n - 1)) != 0)\n                    tcc_error(\"alignment must be a positive power of two\");\n              }\n              skip(')');\n              ad->a.aligned = exact_log2p1(n);\n            }\n            continue;\n        case TOK_LONG:\n            if ((t & VT_BTYPE) == VT_DOUBLE) {\n                t = (t & ~(VT_BTYPE|VT_LONG)) | VT_LDOUBLE;\n            } else if ((t & (VT_BTYPE|VT_LONG)) == VT_LONG) {\n                t = (t & ~(VT_BTYPE|VT_LONG)) | VT_LLONG;\n            } else {\n                u = VT_LONG;\n                goto basic_type;\n            }\n            next();\n            break;\n#ifdef TCC_TARGET_ARM64\n        case TOK_UINT128:\n            /* GCC's __uint128_t appears in some Linux header files. Make it a\n               synonym for long double to get the size and alignment right. */\n            u = VT_LDOUBLE;\n            goto basic_type;\n#endif\n        case TOK_BOOL:\n            u = VT_BOOL;\n            goto basic_type;\n        case TOK_COMPLEX:\n            tcc_error(\"_Complex is not yet supported\");\n        case TOK_FLOAT:\n            u = VT_FLOAT;\n            goto basic_type;\n        case TOK_DOUBLE:\n            if ((t & (VT_BTYPE|VT_LONG)) == VT_LONG) {\n                t = (t & ~(VT_BTYPE|VT_LONG)) | VT_LDOUBLE;\n            } else {\n                u = VT_DOUBLE;\n                goto basic_type;\n            }\n            next();\n            break;\n        case TOK_ENUM:\n            struct_decl(&type1, VT_ENUM);\n        basic_type2:\n            u = type1.t;\n            type->ref = type1.ref;\n            goto basic_type1;\n        case TOK_STRUCT:\n            struct_decl(&type1, VT_STRUCT);\n            goto basic_type2;\n        case TOK_UNION:\n            struct_decl(&type1, VT_UNION);\n            goto basic_type2;\n\n            /* type modifiers */\n        case TOK__Atomic:\n            next();\n            type->t = t;\n            parse_btype_qualify(type, VT_ATOMIC);\n            t = type->t;\n            if (tok == '(') {\n                parse_expr_type(&type1);\n                /* remove all storage modifiers except typedef */\n                type1.t &= ~(VT_STORAGE&~VT_TYPEDEF);\n                if (type1.ref)\n                    sym_to_attr(ad, type1.ref);\n                goto basic_type2;\n            }\n            break;\n        case TOK_CONST1:\n        case TOK_CONST2:\n        case TOK_CONST3:\n            type->t = t;\n            parse_btype_qualify(type, VT_CONSTANT);\n            t = type->t;\n            next();\n            break;\n        case TOK_VOLATILE1:\n        case TOK_VOLATILE2:\n        case TOK_VOLATILE3:\n            type->t = t;\n            parse_btype_qualify(type, VT_VOLATILE);\n            t = type->t;\n            next();\n            break;\n        case TOK_SIGNED1:\n        case TOK_SIGNED2:\n        case TOK_SIGNED3:\n            if ((t & (VT_DEFSIGN|VT_UNSIGNED)) == (VT_DEFSIGN|VT_UNSIGNED))\n                tcc_error(\"signed and unsigned modifier\");\n            t |= VT_DEFSIGN;\n            next();\n            typespec_found = 1;\n            break;\n        case TOK_REGISTER:\n        case TOK_AUTO:\n        case TOK_RESTRICT1:\n        case TOK_RESTRICT2:\n        case TOK_RESTRICT3:\n            next();\n            break;\n        case TOK_UNSIGNED:\n            if ((t & (VT_DEFSIGN|VT_UNSIGNED)) == VT_DEFSIGN)\n                tcc_error(\"signed and unsigned modifier\");\n            t |= VT_DEFSIGN | VT_UNSIGNED;\n            next();\n            typespec_found = 1;\n            break;\n\n            /* storage */\n        case TOK_EXTERN:\n            g = VT_EXTERN;\n            goto storage;\n        case TOK_STATIC:\n            g = VT_STATIC;\n            goto storage;\n        case TOK_TYPEDEF:\n            g = VT_TYPEDEF;\n            goto storage;\n       storage:\n            if (t & (VT_EXTERN|VT_STATIC|VT_TYPEDEF) & ~g)\n                tcc_error(\"multiple storage classes\");\n            t |= g;\n            next();\n            break;\n        case TOK_INLINE1:\n        case TOK_INLINE2:\n        case TOK_INLINE3:\n            t |= VT_INLINE;\n            next();\n            break;\n        case TOK_NORETURN3:\n            next();\n            ad->f.func_noreturn = 1;\n            break;\n            /* GNUC attribute */\n        case TOK_ATTRIBUTE1:\n        case TOK_ATTRIBUTE2:\n            parse_attribute(ad);\n            if (ad->attr_mode) {\n                u = ad->attr_mode -1;\n                t = (t & ~(VT_BTYPE|VT_LONG)) | u;\n            }\n            continue;\n            /* GNUC typeof */\n        case TOK_TYPEOF1:\n        case TOK_TYPEOF2:\n        case TOK_TYPEOF3:\n            next();\n            parse_expr_type(&type1);\n            /* remove all storage modifiers except typedef */\n            type1.t &= ~(VT_STORAGE&~VT_TYPEDEF);\n\t    if (type1.ref)\n                sym_to_attr(ad, type1.ref);\n            goto basic_type2;\n        case TOK_THREAD_LOCAL:\n            tcc_error(\"_Thread_local is not implemented\");\n        default:\n            if (typespec_found)\n                goto the_end;\n            s = sym_find(tok);\n            if (!s || !(s->type.t & VT_TYPEDEF))\n                goto the_end;\n\n            n = tok, next();\n            if (tok == ':' && ignore_label) {\n                /* ignore if it's a label */\n                unget_tok(n);\n                goto the_end;\n            }\n\n            t &= ~(VT_BTYPE|VT_LONG);\n            u = t & ~(VT_CONSTANT | VT_VOLATILE), t ^= u;\n            type->t = (s->type.t & ~VT_TYPEDEF) | u;\n            type->ref = s->type.ref;\n            if (t)\n                parse_btype_qualify(type, t);\n            t = type->t;\n            /* get attributes from typedef */\n            sym_to_attr(ad, s);\n            typespec_found = 1;\n            st = bt = -2;\n            break;\n        }\n        type_found = 1;\n    }\nthe_end:\n    if (tcc_state->char_is_unsigned) {\n        if ((t & (VT_DEFSIGN|VT_BTYPE)) == VT_BYTE)\n            t |= VT_UNSIGNED;\n    }\n    /* VT_LONG is used just as a modifier for VT_INT / VT_LLONG */\n    bt = t & (VT_BTYPE|VT_LONG);\n    if (bt == VT_LONG)\n        t |= LONG_SIZE == 8 ? VT_LLONG : VT_INT;\n#ifdef TCC_USING_DOUBLE_FOR_LDOUBLE\n    if (bt == VT_LDOUBLE)\n        t = (t & ~(VT_BTYPE|VT_LONG)) | (VT_DOUBLE|VT_LONG);\n#endif\n    type->t = t;\n    return type_found;\n}\n\n/* convert a function parameter type (array to pointer and function to\n   function pointer) */\nstatic inline void convert_parameter_type(CType *pt)\n{\n    /* remove const and volatile qualifiers (XXX: const could be used\n       to indicate a const function parameter */\n    pt->t &= ~(VT_CONSTANT | VT_VOLATILE);\n    /* array must be transformed to pointer according to ANSI C */\n    pt->t &= ~(VT_ARRAY | VT_VLA);\n    if ((pt->t & VT_BTYPE) == VT_FUNC) {\n        mk_pointer(pt);\n    }\n}\n\nST_FUNC CString* parse_asm_str(void)\n{\n    skip('(');\n    return parse_mult_str(\"string constant\");\n}\n\n/* Parse an asm label and return the token */\nstatic int asm_label_instr(void)\n{\n    int v;\n    char *astr;\n\n    next();\n    astr = parse_asm_str()->data;\n    skip(')');\n#ifdef ASM_DEBUG\n    printf(\"asm_alias: \\\"%s\\\"\\n\", astr);\n#endif\n    v = tok_alloc_const(astr);\n    return v;\n}\n\nstatic int post_type(CType *type, AttributeDef *ad, int storage, int td)\n{\n    int n, l, t1, arg_size, align;\n    Sym **plast, *s, *first;\n    AttributeDef ad1;\n    CType pt;\n    TokenString *vla_array_tok = NULL;\n    int *vla_array_str = NULL;\n\n    if (tok == '(') {\n        /* function type, or recursive declarator (return if so) */\n        next();\n\tif (TYPE_DIRECT == (td & (TYPE_DIRECT|TYPE_ABSTRACT)))\n\t  return 0;\n\tif (tok == ')')\n\t  l = 0;\n\telse if (parse_btype(&pt, &ad1, 0))\n\t  l = FUNC_NEW;\n\telse if (td & (TYPE_DIRECT|TYPE_ABSTRACT)) {\n\t    merge_attr (ad, &ad1);\n\t    return 0;\n\t} else\n\t  l = FUNC_OLD;\n\n        first = NULL;\n        plast = &first;\n        arg_size = 0;\n        ++local_scope;\n        if (l) {\n            for(;;) {\n                /* read param name and compute offset */\n                if (l != FUNC_OLD) {\n                    if ((pt.t & VT_BTYPE) == VT_VOID && tok == ')')\n                        break;\n                    type_decl(&pt, &ad1, &n, TYPE_DIRECT | TYPE_ABSTRACT | TYPE_PARAM);\n                    if ((pt.t & VT_BTYPE) == VT_VOID)\n                        tcc_error(\"parameter declared as void\");\n                    if (n == 0)\n                        n = SYM_FIELD;\n                } else {\n                    n = tok;\n                    pt.t = VT_VOID; /* invalid type */\n                    pt.ref = NULL;\n                    next();\n                }\n                if (n < TOK_UIDENT)\n                    expect(\"identifier\");\n                convert_parameter_type(&pt);\n                arg_size += (type_size(&pt, &align) + PTR_SIZE - 1) / PTR_SIZE;\n                /* these symbols may be evaluated for VLArrays (see below, under\n                   nocode_wanted) which is why we push them here as normal symbols\n                   temporarily.  Example: int func(int a, int b[++a]); */\n                s = sym_push(n, &pt, VT_LOCAL|VT_LVAL, 0);\n                *plast = s;\n                plast = &s->next;\n                if (tok == ')')\n                    break;\n                skip(',');\n                if (l == FUNC_NEW && tok == TOK_DOTS) {\n                    l = FUNC_ELLIPSIS;\n                    next();\n                    break;\n                }\n\t\tif (l == FUNC_NEW && !parse_btype(&pt, &ad1, 0))\n\t\t    tcc_error(\"invalid type\");\n            }\n        } else\n            /* if no parameters, then old type prototype */\n            l = FUNC_OLD;\n        skip(')');\n        /* remove parameter symbols from token table, keep on stack */\n        if (first) {\n            sym_pop(local_stack ? &local_stack : &global_stack, first->prev, 1);\n            for (s = first; s; s = s->next)\n                s->v |= SYM_FIELD;\n        }\n        --local_scope;\n        /* NOTE: const is ignored in returned type as it has a special\n           meaning in gcc / C++ */\n        type->t &= ~VT_CONSTANT; \n        /* some ancient pre-K&R C allows a function to return an array\n           and the array brackets to be put after the arguments, such \n           that \"int c()[]\" means something like \"int[] c()\" */\n        if (tok == '[') {\n            next();\n            skip(']'); /* only handle simple \"[]\" */\n            mk_pointer(type);\n        }\n        /* we push a anonymous symbol which will contain the function prototype */\n        ad->f.func_args = arg_size;\n        ad->f.func_type = l;\n        s = sym_push(SYM_FIELD, type, 0, 0);\n        s->a = ad->a;\n        s->f = ad->f;\n        s->next = first;\n        type->t = VT_FUNC;\n        type->ref = s;\n    } else if (tok == '[') {\n\tint saved_nocode_wanted = nocode_wanted;\n        /* array definition */\n        next();\n        n = -1;\n        t1 = 0;\n        if (td & TYPE_PARAM) while (1) {\n\t    /* XXX The optional type-quals and static should only be accepted\n\t       in parameter decls.  The '*' as well, and then even only\n\t       in prototypes (not function defs).  */\n\t    switch (tok) {\n\t    case TOK_RESTRICT1: case TOK_RESTRICT2: case TOK_RESTRICT3:\n\t    case TOK_CONST1:\n\t    case TOK_VOLATILE1:\n\t    case TOK_STATIC:\n\t    case '*':\n\t\tnext();\n\t\tcontinue;\n\t    default:\n\t\tbreak;\n\t    }\n            if (tok != ']') {\n\t\t/* Code generation is not done now but has to be done\n\t\t   at start of function. Save code here for later use. */\n\t        nocode_wanted = 1;\n\t\tskip_or_save_block(&vla_array_tok);\n\t\tunget_tok(0);\n\t\tvla_array_str = vla_array_tok->str;\n\t\tbegin_macro(vla_array_tok, 2);\n\t\tnext();\n\t        gexpr();\n\t\tend_macro();\n\t\tnext();\n\t\tgoto check;\n            }\n            break;\n\n\t} else if (tok != ']') {\n            if (!local_stack || (storage & VT_STATIC))\n                vpushi(expr_const());\n            else {\n\t\t/* VLAs (which can only happen with local_stack && !VT_STATIC)\n\t\t   length must always be evaluated, even under nocode_wanted,\n\t\t   so that its size slot is initialized (e.g. under sizeof\n\t\t   or typeof).  */\n\t\tnocode_wanted = 0;\n\t\tgexpr();\n\t    }\ncheck:\n            if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n                n = vtop->c.i;\n                if (n < 0)\n                    tcc_error(\"invalid array size\");\n            } else {\n                if (!is_integer_btype(vtop->type.t & VT_BTYPE))\n                    tcc_error(\"size of variable length array should be an integer\");\n                n = 0;\n                t1 = VT_VLA;\n            }\n        }\n        skip(']');\n        /* parse next post type */\n        post_type(type, ad, storage, (td & ~(TYPE_DIRECT|TYPE_ABSTRACT)) | TYPE_NEST);\n\n        if ((type->t & VT_BTYPE) == VT_FUNC)\n            tcc_error(\"declaration of an array of functions\");\n        if ((type->t & VT_BTYPE) == VT_VOID\n            || type_size(type, &align) < 0)\n            tcc_error(\"declaration of an array of incomplete type elements\");\n\n        t1 |= type->t & VT_VLA;\n\n        if (t1 & VT_VLA) {\n            if (n < 0) {\n\t\tif  (td & TYPE_NEST)\n                    tcc_error(\"need explicit inner array size in VLAs\");\n\t    }\n\t    else {\n                loc -= type_size(&int_type, &align);\n                loc &= -align;\n                n = loc;\n\n                vpush_type_size(type, &align);\n                gen_op('*');\n                vset(&int_type, VT_LOCAL|VT_LVAL, n);\n                vswap();\n                vstore();\n\t    }\n        }\n        if (n != -1)\n            vpop();\n\tnocode_wanted = saved_nocode_wanted;\n                \n        /* we push an anonymous symbol which will contain the array\n           element type */\n        s = sym_push(SYM_FIELD, type, 0, n);\n        type->t = (t1 ? VT_VLA : VT_ARRAY) | VT_PTR;\n        type->ref = s;\n\n        if (vla_array_str) {\n            /* for function args, the top dimension is converted to pointer */\n\t    if ((t1 & VT_VLA) && (td & TYPE_NEST))\n\t        s->vla_array_str = vla_array_str;\n\t    else\n\t        tok_str_free_str(vla_array_str);\n\t}\n    }\n    return 1;\n}\n\n/* Parse a type declarator (except basic type), and return the type\n   in 'type'. 'td' is a bitmask indicating which kind of type decl is\n   expected. 'type' should contain the basic type. 'ad' is the\n   attribute definition of the basic type. It can be modified by\n   type_decl().  If this (possibly abstract) declarator is a pointer chain\n   it returns the innermost pointed to type (equals *type, but is a different\n   pointer), otherwise returns type itself, that's used for recursive calls.  */\nstatic CType *type_decl(CType *type, AttributeDef *ad, int *v, int td)\n{\n    CType *post, *ret;\n    int qualifiers, storage;\n\n    /* recursive type, remove storage bits first, apply them later again */\n    storage = type->t & VT_STORAGE;\n    type->t &= ~VT_STORAGE;\n    post = ret = type;\n\n    while (tok == '*') {\n        qualifiers = 0;\n    redo:\n        next();\n        switch(tok) {\n        case TOK__Atomic:\n            qualifiers |= VT_ATOMIC;\n            goto redo;\n        case TOK_CONST1:\n        case TOK_CONST2:\n        case TOK_CONST3:\n            qualifiers |= VT_CONSTANT;\n            goto redo;\n        case TOK_VOLATILE1:\n        case TOK_VOLATILE2:\n        case TOK_VOLATILE3:\n            qualifiers |= VT_VOLATILE;\n            goto redo;\n        case TOK_RESTRICT1:\n        case TOK_RESTRICT2:\n        case TOK_RESTRICT3:\n            goto redo;\n\t/* XXX: clarify attribute handling */\n\tcase TOK_ATTRIBUTE1:\n\tcase TOK_ATTRIBUTE2:\n\t    parse_attribute(ad);\n\t    break;\n        }\n        mk_pointer(type);\n        type->t |= qualifiers;\n\tif (ret == type)\n\t    /* innermost pointed to type is the one for the first derivation */\n\t    ret = pointed_type(type);\n    }\n\n    if (tok == '(') {\n\t/* This is possibly a parameter type list for abstract declarators\n\t   ('int ()'), use post_type for testing this.  */\n\tif (!post_type(type, ad, 0, td)) {\n\t    /* It's not, so it's a nested declarator, and the post operations\n\t       apply to the innermost pointed to type (if any).  */\n\t    /* XXX: this is not correct to modify 'ad' at this point, but\n\t       the syntax is not clear */\n\t    parse_attribute(ad);\n\t    post = type_decl(type, ad, v, td);\n\t    skip(')');\n\t} else\n\t  goto abstract;\n    } else if (tok >= TOK_IDENT && (td & TYPE_DIRECT)) {\n\t/* type identifier */\n\t*v = tok;\n\tnext();\n    } else {\n  abstract:\n\tif (!(td & TYPE_ABSTRACT))\n\t  expect(\"identifier\");\n\t*v = 0;\n    }\n    post_type(post, ad, post != ret ? 0 : storage,\n              td & ~(TYPE_DIRECT|TYPE_ABSTRACT));\n    parse_attribute(ad);\n    type->t |= storage;\n    return ret;\n}\n\n/* indirection with full error checking and bound check */\nST_FUNC void indir(void)\n{\n    if ((vtop->type.t & VT_BTYPE) != VT_PTR) {\n        if ((vtop->type.t & VT_BTYPE) == VT_FUNC)\n            return;\n        expect(\"pointer\");\n    }\n    if (vtop->r & VT_LVAL)\n        gv(RC_INT);\n    vtop->type = *pointed_type(&vtop->type);\n    /* Arrays and functions are never lvalues */\n    if (!(vtop->type.t & (VT_ARRAY | VT_VLA))\n        && (vtop->type.t & VT_BTYPE) != VT_FUNC) {\n        vtop->r |= VT_LVAL;\n        /* if bound checking, the referenced pointer must be checked */\n#ifdef CONFIG_TCC_BCHECK\n        if (tcc_state->do_bounds_check)\n            vtop->r |= VT_MUSTBOUND;\n#endif\n    }\n}\n\n/* pass a parameter to a function and do type checking and casting */\nstatic void gfunc_param_typed(Sym *func, Sym *arg)\n{\n    int func_type;\n    CType type;\n\n    func_type = func->f.func_type;\n    if (func_type == FUNC_OLD ||\n        (func_type == FUNC_ELLIPSIS && arg == NULL)) {\n        /* default casting : only need to convert float to double */\n        if ((vtop->type.t & VT_BTYPE) == VT_FLOAT) {\n            gen_cast_s(VT_DOUBLE);\n        } else if (vtop->type.t & VT_BITFIELD) {\n            type.t = vtop->type.t & (VT_BTYPE | VT_UNSIGNED);\n\t    type.ref = vtop->type.ref;\n            gen_cast(&type);\n        } else if (vtop->r & VT_MUSTCAST) {\n            force_charshort_cast();\n        }\n    } else if (arg == NULL) {\n        tcc_error(\"too many arguments to function\");\n    } else {\n        type = arg->type;\n        type.t &= ~VT_CONSTANT; /* need to do that to avoid false warning */\n        gen_assign_cast(&type);\n    }\n}\n\n/* parse an expression and return its type without any side effect. */\nstatic void expr_type(CType *type, void (*expr_fn)(void))\n{\n    nocode_wanted++;\n    expr_fn();\n    *type = vtop->type;\n    vpop();\n    nocode_wanted--;\n}\n\n/* parse an expression of the form '(type)' or '(expr)' and return its\n   type */\nstatic void parse_expr_type(CType *type)\n{\n    int n;\n    AttributeDef ad;\n\n    skip('(');\n    if (parse_btype(type, &ad, 0)) {\n        type_decl(type, &ad, &n, TYPE_ABSTRACT);\n    } else {\n        expr_type(type, gexpr);\n    }\n    skip(')');\n}\n\nstatic void parse_type(CType *type)\n{\n    AttributeDef ad;\n    int n;\n\n    if (!parse_btype(type, &ad, 0)) {\n        expect(\"type\");\n    }\n    type_decl(type, &ad, &n, TYPE_ABSTRACT);\n}\n\nstatic void parse_builtin_params(int nc, const char *args)\n{\n    char c, sep = '(';\n    CType type;\n    if (nc)\n        nocode_wanted++;\n    next();\n    if (*args == 0)\n\tskip(sep);\n    while ((c = *args++)) {\n\tskip(sep);\n\tsep = ',';\n        if (c == 't') {\n            parse_type(&type);\n\t    vpush(&type);\n\t    continue;\n        }\n        expr_eq();\n        type.ref = NULL;\n        type.t = 0;\n\tswitch (c) {\n\t    case 'e':\n\t\tcontinue;\n\t    case 'V':\n                type.t = VT_CONSTANT;\n\t    case 'v':\n                type.t |= VT_VOID;\n                mk_pointer (&type);\n                break;\n\t    case 'S':\n                type.t = VT_CONSTANT;\n\t    case 's':\n                type.t |= char_type.t;\n                mk_pointer (&type);\n                break;\n\t    case 'i':\n                type.t = VT_INT;\n                break;\n\t    case 'l':\n                type.t = VT_SIZE_T;\n                break;\n\t    default:\n                break;\n\t}\n        gen_assign_cast(&type);\n    }\n    skip(')');\n    if (nc)\n        nocode_wanted--;\n}\n\nstatic void parse_atomic(int atok)\n{\n    int size, align, arg, t, save = 0;\n    CType *atom, *atom_ptr, ct = {0};\n    SValue store;\n    char buf[40];\n    static const char *const templates[] = {\n        /*\n         * Each entry consists of callback and function template.\n         * The template represents argument types and return type.\n         *\n         * ? void (return-only)\n         * b bool\n         * a atomic\n         * A read-only atomic\n         * p pointer to memory\n         * v value\n         * l load pointer\n         * s save pointer\n         * m memory model\n         */\n\n        /* keep in order of appearance in tcctok.h: */\n        /* __atomic_store */            \"alm.?\",\n        /* __atomic_load */             \"Asm.v\",\n        /* __atomic_exchange */         \"alsm.v\",\n        /* __atomic_compare_exchange */ \"aplbmm.b\",\n        /* __atomic_fetch_add */        \"avm.v\",\n        /* __atomic_fetch_sub */        \"avm.v\",\n        /* __atomic_fetch_or */         \"avm.v\",\n        /* __atomic_fetch_xor */        \"avm.v\",\n        /* __atomic_fetch_and */        \"avm.v\",\n        /* __atomic_fetch_nand */       \"avm.v\",\n        /* __atomic_and_fetch */        \"avm.v\",\n        /* __atomic_sub_fetch */        \"avm.v\",\n        /* __atomic_or_fetch */         \"avm.v\",\n        /* __atomic_xor_fetch */        \"avm.v\",\n        /* __atomic_and_fetch */        \"avm.v\",\n        /* __atomic_nand_fetch */       \"avm.v\"\n    };\n    const char *template = templates[(atok - TOK___atomic_store)];\n\n    atom = atom_ptr = NULL;\n    size = 0; /* pacify compiler */\n    next();\n    skip('(');\n    for (arg = 0;;) {\n        expr_eq();\n        switch (template[arg]) {\n        case 'a':\n        case 'A':\n            atom_ptr = &vtop->type;\n            if ((atom_ptr->t & VT_BTYPE) != VT_PTR)\n                expect(\"pointer\");\n            atom = pointed_type(atom_ptr);\n            size = type_size(atom, &align);\n            if (size > 8\n                || (size & (size - 1))\n                || (atok > TOK___atomic_compare_exchange\n                    && (0 == btype_size(atom->t & VT_BTYPE)\n                        || (atom->t & VT_BTYPE) == VT_PTR)))\n                expect(\"integral or integer-sized pointer target type\");\n            /* GCC does not care either: */\n            /* if (!(atom->t & VT_ATOMIC))\n                tcc_warning(\"pointer target declaration is missing '_Atomic'\"); */\n            break;\n\n        case 'p':\n            if ((vtop->type.t & VT_BTYPE) != VT_PTR\n             || type_size(pointed_type(&vtop->type), &align) != size)\n                tcc_error(\"pointer target type mismatch in argument %d\", arg + 1);\n            gen_assign_cast(atom_ptr);\n            break;\n        case 'v':\n            gen_assign_cast(atom);\n            break;\n        case 'l':\n            indir();\n            gen_assign_cast(atom);\n            break;\n        case 's':\n            save = 1;\n            indir();\n            store = *vtop;\n            vpop();\n            break;\n        case 'm':\n            gen_assign_cast(&int_type);\n            break;\n        case 'b':\n            ct.t = VT_BOOL;\n            gen_assign_cast(&ct);\n            break;\n        }\n        if ('.' == template[++arg])\n            break;\n        skip(',');\n    }\n    skip(')');\n\n    ct.t = VT_VOID;\n    switch (template[arg + 1]) {\n    case 'b':\n        ct.t = VT_BOOL;\n        break;\n    case 'v':\n        ct = *atom;\n        break;\n    }\n\n    sprintf(buf, \"%s_%d\", get_tok_str(atok, 0), size);\n    vpush_helper_func(tok_alloc_const(buf));\n    vrott(arg - save + 1);\n    gfunc_call(arg - save);\n\n    vpush(&ct);\n    PUT_R_RET(vtop, ct.t);\n    t = ct.t & VT_BTYPE;\n    if (t == VT_BYTE || t == VT_SHORT || t == VT_BOOL) {\n#ifdef PROMOTE_RET\n        vtop->r |= BFVAL(VT_MUSTCAST, 1);\n#else\n        vtop->type.t = VT_INT;\n#endif\n    }\n    gen_cast(&ct);\n    if (save) {\n        vpush(&ct);\n        *vtop = store;\n        vswap();\n        vstore();\n    }\n}\n\nST_FUNC void unary(void)\n{\n    int n, t, align, size, r;\n    CType type;\n    Sym *s;\n    AttributeDef ad;\n\n    /* generate line number info */\n    if (debug_modes)\n        tcc_debug_line(tcc_state), tcc_tcov_check_line (tcc_state, 1);\n\n    type.ref = NULL;\n    /* XXX: GCC 2.95.3 does not generate a table although it should be\n       better here */\n tok_next:\n    switch(tok) {\n    case TOK_EXTENSION:\n        next();\n        goto tok_next;\n    case TOK_LCHAR:\n#ifdef TCC_TARGET_PE\n        t = VT_SHORT|VT_UNSIGNED;\n        goto push_tokc;\n#endif\n    case TOK_CINT:\n    case TOK_CCHAR: \n\tt = VT_INT;\n push_tokc:\n\ttype.t = t;\n\tvsetc(&type, VT_CONST, &tokc);\n        next();\n        break;\n    case TOK_CUINT:\n        t = VT_INT | VT_UNSIGNED;\n        goto push_tokc;\n    case TOK_CLLONG:\n        t = VT_LLONG;\n\tgoto push_tokc;\n    case TOK_CULLONG:\n        t = VT_LLONG | VT_UNSIGNED;\n\tgoto push_tokc;\n    case TOK_CFLOAT:\n        t = VT_FLOAT;\n\tgoto push_tokc;\n    case TOK_CDOUBLE:\n        t = VT_DOUBLE;\n\tgoto push_tokc;\n    case TOK_CLDOUBLE:\n#ifdef TCC_USING_DOUBLE_FOR_LDOUBLE\n        t = VT_DOUBLE | VT_LONG;\n#else\n        t = VT_LDOUBLE;\n#endif\n\tgoto push_tokc;\n    case TOK_CLONG:\n        t = (LONG_SIZE == 8 ? VT_LLONG : VT_INT) | VT_LONG;\n\tgoto push_tokc;\n    case TOK_CULONG:\n        t = (LONG_SIZE == 8 ? VT_LLONG : VT_INT) | VT_LONG | VT_UNSIGNED;\n\tgoto push_tokc;\n    case TOK___FUNCTION__:\n        if (!gnu_ext)\n            goto tok_identifier;\n        /* fall thru */\n    case TOK___FUNC__:\n        tok = TOK_STR;\n        cstr_reset(&tokcstr);\n        cstr_cat(&tokcstr, funcname, 0);\n        tokc.str.size = tokcstr.size;\n        tokc.str.data = tokcstr.data;\n        goto case_TOK_STR;\n    case TOK_LSTR:\n#ifdef TCC_TARGET_PE\n        t = VT_SHORT | VT_UNSIGNED;\n#else\n        t = VT_INT;\n#endif\n        goto str_init;\n    case TOK_STR:\n    case_TOK_STR:\n        /* string parsing */\n        t = char_type.t;\n    str_init:\n        if (tcc_state->warn_write_strings & WARN_ON)\n            t |= VT_CONSTANT;\n        type.t = t;\n        mk_pointer(&type);\n        type.t |= VT_ARRAY;\n        memset(&ad, 0, sizeof(AttributeDef));\n        ad.section = rodata_section;\n        decl_initializer_alloc(&type, &ad, VT_CONST, 2, 0, 0);\n        break;\n    case TOK_SOTYPE:\n    case '(':\n        t = tok;\n        next();\n        /* cast ? */\n        if (parse_btype(&type, &ad, 0)) {\n            type_decl(&type, &ad, &n, TYPE_ABSTRACT);\n            skip(')');\n            /* check ISOC99 compound literal */\n            if (tok == '{') {\n                    /* data is allocated locally by default */\n                if (global_expr)\n                    r = VT_CONST;\n                else\n                    r = VT_LOCAL;\n                /* all except arrays are lvalues */\n                if (!(type.t & VT_ARRAY))\n                    r |= VT_LVAL;\n                memset(&ad, 0, sizeof(AttributeDef));\n                decl_initializer_alloc(&type, &ad, r, 1, 0, 0);\n            } else if (t == TOK_SOTYPE) { /* from sizeof/alignof (...) */\n                vpush(&type);\n                return;\n            } else {\n                unary();\n                gen_cast(&type);\n            }\n        } else if (tok == '{') {\n\t    int saved_nocode_wanted = nocode_wanted;\n            if (CONST_WANTED && !NOEVAL_WANTED)\n                expect(\"constant\");\n            if (0 == local_scope)\n                tcc_error(\"statement expression outside of function\");\n            /* save all registers */\n            save_regs(0);\n            /* statement expression : we do not accept break/continue\n               inside as GCC does.  We do retain the nocode_wanted state,\n\t       as statement expressions can't ever be entered from the\n\t       outside, so any reactivation of code emission (from labels\n\t       or loop heads) can be disabled again after the end of it. */\n            block(STMT_EXPR);\n            /* If the statement expr can be entered, then we retain the current\n               nocode_wanted state (from e.g. a 'return 0;' in the stmt-expr).\n               If it can't be entered then the state is that from before the\n               statement expression.  */\n            if (saved_nocode_wanted)\n              nocode_wanted = saved_nocode_wanted;\n            skip(')');\n        } else {\n            gexpr();\n            skip(')');\n        }\n        break;\n    case '*':\n        next();\n        unary();\n        indir();\n        break;\n    case '&':\n        next();\n        unary();\n        /* functions names must be treated as function pointers,\n           except for unary '&' and sizeof. Since we consider that\n           functions are not lvalues, we only have to handle it\n           there and in function calls. */\n        /* arrays can also be used although they are not lvalues */\n        if ((vtop->type.t & VT_BTYPE) != VT_FUNC &&\n            !(vtop->type.t & (VT_ARRAY | VT_VLA)))\n            test_lvalue();\n        if (vtop->sym)\n          vtop->sym->a.addrtaken = 1;\n        mk_pointer(&vtop->type);\n        gaddrof();\n        break;\n    case '!':\n        next();\n        unary();\n        gen_test_zero(TOK_EQ);\n        break;\n    case '~':\n        next();\n        unary();\n        vpushi(-1);\n        gen_op('^');\n        break;\n    case '+':\n        next();\n        unary();\n        if ((vtop->type.t & VT_BTYPE) == VT_PTR)\n            tcc_error(\"pointer not accepted for unary plus\");\n        /* In order to force cast, we add zero, except for floating point\n\t   where we really need an noop (otherwise -0.0 will be transformed\n\t   into +0.0).  */\n\tif (!is_float(vtop->type.t)) {\n\t    vpushi(0);\n\t    gen_op('+');\n\t}\n        break;\n    case TOK_SIZEOF:\n    case TOK_ALIGNOF1:\n    case TOK_ALIGNOF2:\n    case TOK_ALIGNOF3:\n        t = tok;\n        next();\n        if (tok == '(')\n            tok = TOK_SOTYPE;\n        expr_type(&type, unary);\n        if (t == TOK_SIZEOF) {\n            vpush_type_size(&type, &align);\n            gen_cast_s(VT_SIZE_T);\n        } else {\n            type_size(&type, &align);\n            s = NULL;\n            if (vtop[1].r & VT_SYM)\n                s = vtop[1].sym; /* hack: accessing previous vtop */\n            if (s && s->a.aligned)\n                align = 1 << (s->a.aligned - 1);\n            vpushs(align);\n        }\n        break;\n\n    case TOK_builtin_expect:\n\t/* __builtin_expect is a no-op for now */\n\tparse_builtin_params(0, \"ee\");\n\tvpop();\n        break;\n    case TOK_builtin_types_compatible_p:\n\tparse_builtin_params(0, \"tt\");\n\tvtop[-1].type.t &= ~(VT_CONSTANT | VT_VOLATILE);\n\tvtop[0].type.t &= ~(VT_CONSTANT | VT_VOLATILE);\n\tn = is_compatible_types(&vtop[-1].type, &vtop[0].type);\n\tvtop -= 2;\n\tvpushi(n);\n        break;\n    case TOK_builtin_choose_expr:\n\t{\n\t    int64_t c;\n\t    next();\n\t    skip('(');\n\t    c = expr_const64();\n\t    skip(',');\n\t    if (!c) {\n\t\tnocode_wanted++;\n\t    }\n\t    expr_eq();\n\t    if (!c) {\n\t\tvpop();\n\t\tnocode_wanted--;\n\t    }\n\t    skip(',');\n\t    if (c) {\n\t\tnocode_wanted++;\n\t    }\n\t    expr_eq();\n\t    if (c) {\n\t\tvpop();\n\t\tnocode_wanted--;\n\t    }\n\t    skip(')');\n\t}\n        break;\n    case TOK_builtin_constant_p:\n\tparse_builtin_params(1, \"e\");\n\tn = 1;\n\tif ((vtop->r & (VT_VALMASK | VT_LVAL)) != VT_CONST\n\t    || ((vtop->r & VT_SYM) && vtop->sym->a.addrtaken)\n\t    )\n\t    n = 0;\n\tvtop--;\n\tvpushi(n);\n        break;\n    case TOK_builtin_unreachable:\n\tparse_builtin_params(0, \"\"); /* just skip '()' */\n        type.t = VT_VOID;\n        vpush(&type);\n        CODE_OFF();\n        break;\n    case TOK_builtin_frame_address:\n    case TOK_builtin_return_address:\n        {\n            int tok1 = tok;\n            int level;\n            next();\n            skip('(');\n            level = expr_const();\n            if (level < 0)\n                tcc_error(\"%s only takes positive integers\", get_tok_str(tok1, 0));\n            skip(')');\n            type.t = VT_VOID;\n            mk_pointer(&type);\n            vset(&type, VT_LOCAL, 0);       /* local frame */\n            while (level--) {\n#ifdef TCC_TARGET_RISCV64\n                vpushi(2*PTR_SIZE);\n                gen_op('-');\n#endif\n                mk_pointer(&vtop->type);\n                indir();                    /* -> parent frame */\n            }\n            if (tok1 == TOK_builtin_return_address) {\n                // assume return address is just above frame pointer on stack\n#ifdef TCC_TARGET_ARM\n                vpushi(2*PTR_SIZE);\n                gen_op('+');\n#elif defined TCC_TARGET_RISCV64\n                vpushi(PTR_SIZE);\n                gen_op('-');\n#else\n                vpushi(PTR_SIZE);\n                gen_op('+');\n#endif\n                mk_pointer(&vtop->type);\n                indir();\n            }\n        }\n        break;\n#ifdef TCC_TARGET_RISCV64\n    case TOK_builtin_va_start:\n        parse_builtin_params(0, \"ee\");\n        r = vtop->r & VT_VALMASK;\n        if (r == VT_LLOCAL)\n            r = VT_LOCAL;\n        if (r != VT_LOCAL)\n            tcc_error(\"__builtin_va_start expects a local variable\");\n        gen_va_start();\n\tvstore();\n        break;\n#endif\n#ifdef TCC_TARGET_X86_64\n#ifdef TCC_TARGET_PE\n    case TOK_builtin_va_start:\n\tparse_builtin_params(0, \"ee\");\n        r = vtop->r & VT_VALMASK;\n        if (r == VT_LLOCAL)\n            r = VT_LOCAL;\n        if (r != VT_LOCAL)\n            tcc_error(\"__builtin_va_start expects a local variable\");\n        vtop->r = r;\n\tvtop->type = char_pointer_type;\n\tvtop->c.i += 8;\n\tvstore();\n        break;\n#else\n    case TOK_builtin_va_arg_types:\n\tparse_builtin_params(0, \"t\");\n\tvpushi(classify_x86_64_va_arg(&vtop->type));\n\tvswap();\n\tvpop();\n\tbreak;\n#endif\n#endif\n\n#ifdef TCC_TARGET_ARM64\n    case TOK_builtin_va_start: {\n\tparse_builtin_params(0, \"ee\");\n        //xx check types\n        gen_va_start();\n        vpushi(0);\n        vtop->type.t = VT_VOID;\n        break;\n    }\n    case TOK_builtin_va_arg: {\n\tparse_builtin_params(0, \"et\");\n\ttype = vtop->type;\n\tvpop();\n        //xx check types\n        gen_va_arg(&type);\n        vtop->type = type;\n        break;\n    }\n    case TOK___arm64_clear_cache: {\n\tparse_builtin_params(0, \"ee\");\n        gen_clear_cache();\n        vpushi(0);\n        vtop->type.t = VT_VOID;\n        break;\n    }\n#endif\n\n    /* atomic operations */\n    case TOK___atomic_store:\n    case TOK___atomic_load:\n    case TOK___atomic_exchange:\n    case TOK___atomic_compare_exchange:\n    case TOK___atomic_fetch_add:\n    case TOK___atomic_fetch_sub:\n    case TOK___atomic_fetch_or:\n    case TOK___atomic_fetch_xor:\n    case TOK___atomic_fetch_and:\n    case TOK___atomic_fetch_nand:\n    case TOK___atomic_add_fetch:\n    case TOK___atomic_sub_fetch:\n    case TOK___atomic_or_fetch:\n    case TOK___atomic_xor_fetch:\n    case TOK___atomic_and_fetch:\n    case TOK___atomic_nand_fetch:\n        parse_atomic(tok);\n        break;\n\n    /* pre operations */\n    case TOK_INC:\n    case TOK_DEC:\n        t = tok;\n        next();\n        unary();\n        inc(0, t);\n        break;\n    case '-':\n        next();\n        unary();\n\tif (is_float(vtop->type.t)) {\n            gen_opif(TOK_NEG);\n\t} else {\n            vpushi(0);\n            vswap();\n            gen_op('-');\n        }\n        break;\n    case TOK_LAND:\n        if (!gnu_ext)\n            goto tok_identifier;\n        next();\n        /* allow to take the address of a label */\n        if (tok < TOK_UIDENT)\n            expect(\"label identifier\");\n        s = label_find(tok);\n        if (!s) {\n            s = label_push(&global_label_stack, tok, LABEL_FORWARD);\n        } else {\n            if (s->r == LABEL_DECLARED)\n                s->r = LABEL_FORWARD;\n        }\n        if ((s->type.t & VT_BTYPE) != VT_PTR) {\n            s->type.t = VT_VOID;\n            mk_pointer(&s->type);\n            s->type.t |= VT_STATIC;\n        }\n        vpushsym(&s->type, s);\n        next();\n        break;\n\n    case TOK_GENERIC:\n    {\n\tCType controlling_type;\n\tint has_default = 0;\n\tint has_match = 0;\n\tint learn = 0;\n\tTokenString *str = NULL;\n\tint saved_nocode_wanted = nocode_wanted;\n        nocode_wanted &= ~CONST_WANTED_MASK;\n\n        next();\n\tskip('(');\n\texpr_type(&controlling_type, expr_eq);\n\tconvert_parameter_type (&controlling_type);\n\n        nocode_wanted = saved_nocode_wanted;\n\n        for (;;) {\n\t    learn = 0;\n\t    skip(',');\n\t    if (tok == TOK_DEFAULT) {\n\t\tif (has_default)\n\t\t    tcc_error(\"too many 'default'\");\n\t\thas_default = 1;\n\t\tif (!has_match)\n\t\t    learn = 1;\n\t\tnext();\n\t    } else {\n\t        AttributeDef ad_tmp;\n\t\tint itmp;\n\t        CType cur_type;\n\n\t\tparse_btype(&cur_type, &ad_tmp, 0);\n\t\ttype_decl(&cur_type, &ad_tmp, &itmp, TYPE_ABSTRACT);\n\t\tif (compare_types(&controlling_type, &cur_type, 0)) {\n\t\t    if (has_match) {\n\t\t      tcc_error(\"type match twice\");\n\t\t    }\n\t\t    has_match = 1;\n\t\t    learn = 1;\n\t\t}\n\t    }\n\t    skip(':');\n\t    if (learn) {\n\t\tif (str)\n\t\t    tok_str_free(str);\n\t\tskip_or_save_block(&str);\n\t    } else {\n\t\tskip_or_save_block(NULL);\n\t    }\n\t    if (tok == ')')\n\t\tbreak;\n\t}\n\tif (!str) {\n\t    char buf[60];\n\t    type_to_str(buf, sizeof buf, &controlling_type, NULL);\n\t    tcc_error(\"type '%s' does not match any association\", buf);\n\t}\n\tbegin_macro(str, 1);\n\tnext();\n\texpr_eq();\n\tif (tok != TOK_EOF)\n\t    expect(\",\");\n\tend_macro();\n        next();\n\tbreak;\n    }\n    // special qnan , snan and infinity values\n    case TOK___NAN__:\n        n = 0x7fc00000;\nspecial_math_val:\n\tvpushi(n);\n\tvtop->type.t = VT_FLOAT;\n        next();\n        break;\n    case TOK___SNAN__:\n\tn = 0x7f800001;\n\tgoto special_math_val;\n    case TOK___INF__:\n\tn = 0x7f800000;\n\tgoto special_math_val;\n\n    default:\n    tok_identifier:\n        if (tok < TOK_UIDENT)\n            tcc_error(\"expression expected before '%s'\", get_tok_str(tok, &tokc));\n        t = tok;\n        next();\n        s = sym_find(t);\n        if (!s || IS_ASM_SYM(s)) {\n            const char *name = get_tok_str(t, NULL);\n            if (tok != '(')\n                tcc_error(\"'%s' undeclared\", name);\n            /* for simple function calls, we tolerate undeclared\n               external reference to int() function */\n            tcc_warning_c(warn_implicit_function_declaration)(\n                \"implicit declaration of function '%s'\", name);\n            s = external_global_sym(t, &func_old_type);\n        }\n\n        r = s->r;\n        /* A symbol that has a register is a local register variable,\n           which starts out as VT_LOCAL value.  */\n        if ((r & VT_VALMASK) < VT_CONST)\n            r = (r & ~VT_VALMASK) | VT_LOCAL;\n\n        vset(&s->type, r, s->c);\n        /* Point to s as backpointer (even without r&VT_SYM).\n\t   Will be used by at least the x86 inline asm parser for\n\t   regvars.  */\n\tvtop->sym = s;\n\n        if (r & VT_SYM) {\n            vtop->c.i = 0;\n#ifdef TCC_TARGET_PE\n            if (s->a.dllimport) {\n                mk_pointer(&vtop->type);\n                vtop->r |= VT_LVAL;\n                indir();\n            }\n#endif\n        } else if (r == VT_CONST && IS_ENUM_VAL(s->type.t)) {\n            vtop->c.i = s->enum_val;\n        }\n        break;\n    }\n    \n    /* post operations */\n    while (1) {\n        if (tok == TOK_INC || tok == TOK_DEC) {\n            inc(1, tok);\n            next();\n        } else if (tok == '.' || tok == TOK_ARROW) {\n            int qualifiers, cumofs;\n            /* field */ \n            if (tok == TOK_ARROW) \n                indir();\n            qualifiers = vtop->type.t & (VT_CONSTANT | VT_VOLATILE);\n            test_lvalue();\n            /* expect pointer on structure */\n            next();\n\t    s = find_field(&vtop->type, tok, &cumofs);\n            /* add field offset to pointer */\n            gaddrof();\n            vtop->type = char_pointer_type; /* change type to 'char *' */\n            vpushi(cumofs);\n            gen_op('+');\n            /* change type to field type, and set to lvalue */\n            vtop->type = s->type;\n            vtop->type.t |= qualifiers;\n            /* an array is never an lvalue */\n            if (!(vtop->type.t & VT_ARRAY)) {\n                vtop->r |= VT_LVAL;\n#ifdef CONFIG_TCC_BCHECK\n                /* if bound checking, the referenced pointer must be checked */\n                if (tcc_state->do_bounds_check)\n                    vtop->r |= VT_MUSTBOUND;\n#endif\n            }\n            next();\n        } else if (tok == '[') {\n            next();\n            gexpr();\n            gen_op('+');\n            indir();\n            skip(']');\n        } else if (tok == '(') {\n            SValue ret;\n            Sym *sa;\n            int nb_args, ret_nregs, ret_align, regsize, variadic;\n            TokenString *p, *p2;\n\n            /* function call  */\n            if ((vtop->type.t & VT_BTYPE) != VT_FUNC) {\n                /* pointer test (no array accepted) */\n                if ((vtop->type.t & (VT_BTYPE | VT_ARRAY)) == VT_PTR) {\n                    vtop->type = *pointed_type(&vtop->type);\n                    if ((vtop->type.t & VT_BTYPE) != VT_FUNC)\n                        goto error_func;\n                } else {\n                error_func:\n                    expect(\"function pointer\");\n                }\n            } else {\n                vtop->r &= ~VT_LVAL; /* no lvalue */\n            }\n            /* get return type */\n            s = vtop->type.ref;\n            next();\n            sa = s->next; /* first parameter */\n            nb_args = regsize = 0;\n            ret.r2 = VT_CONST;\n            /* compute first implicit argument if a structure is returned */\n            if ((s->type.t & VT_BTYPE) == VT_STRUCT) {\n                variadic = (s->f.func_type == FUNC_ELLIPSIS);\n                ret_nregs = gfunc_sret(&s->type, variadic, &ret.type,\n                                       &ret_align, &regsize);\n                if (ret_nregs <= 0) {\n                    /* get some space for the returned structure */\n                    size = type_size(&s->type, &align);\n#ifdef TCC_TARGET_ARM64\n                /* On arm64, a small struct is return in registers.\n                   It is much easier to write it to memory if we know\n                   that we are allowed to write some extra bytes, so\n                   round the allocated space up to a power of 2: */\n                if (size < 16)\n                    while (size & (size - 1))\n                        size = (size | (size - 1)) + 1;\n#endif\n                    loc = (loc - size) & -align;\n                    ret.type = s->type;\n                    ret.r = VT_LOCAL | VT_LVAL;\n                    /* pass it as 'int' to avoid structure arg passing\n                       problems */\n                    vseti(VT_LOCAL, loc);\n#ifdef CONFIG_TCC_BCHECK\n                    if (tcc_state->do_bounds_check)\n                        --loc;\n#endif\n                    ret.c = vtop->c;\n                    if (ret_nregs < 0)\n                      vtop--;\n                    else\n                      nb_args++;\n                }\n            } else {\n                ret_nregs = 1;\n                ret.type = s->type;\n            }\n\n            if (ret_nregs > 0) {\n                /* return in register */\n                ret.c.i = 0;\n                PUT_R_RET(&ret, ret.type.t);\n            }\n\n            p = NULL;\n            if (tok != ')') {\n                r = tcc_state->reverse_funcargs;\n                for(;;) {\n                    if (r) {\n                        skip_or_save_block(&p2);\n                        p2->prev = p, p = p2;\n                    } else {\n                        expr_eq();\n                        gfunc_param_typed(s, sa);\n                    }\n                    nb_args++;\n                    if (sa)\n                        sa = sa->next;\n                    if (tok == ')')\n                        break;\n                    skip(',');\n                }\n            }\n            if (sa)\n                tcc_error(\"too few arguments to function\");\n\n            if (p) { /* with reverse_funcargs */\n                for (n = 0; p; p = p2, ++n) {\n                    p2 = p, sa = s;\n                    do {\n                        sa = sa->next, p2 = p2->prev;\n                    } while (p2 && sa);\n                    p2 = p->prev;\n                    begin_macro(p, 1), next();\n                    expr_eq();\n                    gfunc_param_typed(s, sa);\n                    end_macro();\n                }\n                vrev(n);\n            }\n\n            next();\n            gfunc_call(nb_args);\n\n            if (ret_nregs < 0) {\n                vsetc(&ret.type, ret.r, &ret.c);\n#ifdef TCC_TARGET_RISCV64\n                arch_transfer_ret_regs(1);\n#endif\n            } else {\n                /* return value */\n                n = ret_nregs;\n                while (n > 1) {\n                    int rc = reg_classes[ret.r] & ~(RC_INT | RC_FLOAT);\n                    /* We assume that when a structure is returned in multiple\n                       registers, their classes are consecutive values of the\n                       suite s(n) = 2^n */\n                    rc <<= --n;\n                    for (r = 0; r < NB_REGS; ++r)\n                        if (reg_classes[r] & rc)\n                            break;\n                    vsetc(&ret.type, r, &ret.c);\n                }\n                vsetc(&ret.type, ret.r, &ret.c);\n                vtop->r2 = ret.r2;\n\n                /* handle packed struct return */\n                if (((s->type.t & VT_BTYPE) == VT_STRUCT) && ret_nregs) {\n                    int addr, offset;\n\n                    size = type_size(&s->type, &align);\n                    /* We're writing whole regs often, make sure there's enough\n                       space.  Assume register size is power of 2.  */\n                    size = (size + regsize - 1) & -regsize;\n                    if (ret_align > align)\n                        align = ret_align;\n                    loc = (loc - size) & -align;\n                    addr = loc;\n                    offset = 0;\n                    for (;;) {\n                        vset(&ret.type, VT_LOCAL | VT_LVAL, addr + offset);\n                        vswap();\n                        vstore();\n                        vtop--;\n                        if (--ret_nregs == 0)\n                          break;\n                        offset += regsize;\n                    }\n                    vset(&s->type, VT_LOCAL | VT_LVAL, addr);\n                }\n\n                /* Promote char/short return values. This is matters only\n                   for calling function that were not compiled by TCC and\n                   only on some architectures.  For those where it doesn't\n                   matter we expect things to be already promoted to int,\n                   but not larger.  */\n                t = s->type.t & VT_BTYPE;\n                if (t == VT_BYTE || t == VT_SHORT || t == VT_BOOL) {\n#ifdef PROMOTE_RET\n                    vtop->r |= BFVAL(VT_MUSTCAST, 1);\n#else\n                    vtop->type.t = VT_INT;\n#endif\n                }\n            }\n            if (s->f.func_noreturn) {\n                if (debug_modes)\n\t            tcc_tcov_block_end(tcc_state, -1);\n                CODE_OFF();\n\t    }\n        } else {\n            break;\n        }\n    }\n}\n\n#ifndef precedence_parser /* original top-down parser */\n\nstatic void expr_prod(void)\n{\n    int t;\n\n    unary();\n    while ((t = tok) == '*' || t == '/' || t == '%') {\n        next();\n        unary();\n        gen_op(t);\n    }\n}\n\nstatic void expr_sum(void)\n{\n    int t;\n\n    expr_prod();\n    while ((t = tok) == '+' || t == '-') {\n        next();\n        expr_prod();\n        gen_op(t);\n    }\n}\n\nstatic void expr_shift(void)\n{\n    int t;\n\n    expr_sum();\n    while ((t = tok) == TOK_SHL || t == TOK_SAR) {\n        next();\n        expr_sum();\n        gen_op(t);\n    }\n}\n\nstatic void expr_cmp(void)\n{\n    int t;\n\n    expr_shift();\n    while (((t = tok) >= TOK_ULE && t <= TOK_GT) ||\n           t == TOK_ULT || t == TOK_UGE) {\n        next();\n        expr_shift();\n        gen_op(t);\n    }\n}\n\nstatic void expr_cmpeq(void)\n{\n    int t;\n\n    expr_cmp();\n    while ((t = tok) == TOK_EQ || t == TOK_NE) {\n        next();\n        expr_cmp();\n        gen_op(t);\n    }\n}\n\nstatic void expr_and(void)\n{\n    expr_cmpeq();\n    while (tok == '&') {\n        next();\n        expr_cmpeq();\n        gen_op('&');\n    }\n}\n\nstatic void expr_xor(void)\n{\n    expr_and();\n    while (tok == '^') {\n        next();\n        expr_and();\n        gen_op('^');\n    }\n}\n\nstatic void expr_or(void)\n{\n    expr_xor();\n    while (tok == '|') {\n        next();\n        expr_xor();\n        gen_op('|');\n    }\n}\n\nstatic void expr_landor(int op);\n\nstatic void expr_land(void)\n{\n    expr_or();\n    if (tok == TOK_LAND)\n        expr_landor(tok);\n}\n\nstatic void expr_lor(void)\n{\n    expr_land();\n    if (tok == TOK_LOR)\n        expr_landor(tok);\n}\n\n# define expr_landor_next(op) op == TOK_LAND ? expr_or() : expr_land()\n#else /* defined precedence_parser */\n# define expr_landor_next(op) unary(), expr_infix(precedence(op) + 1)\n# define expr_lor() unary(), expr_infix(1)\n\nstatic int precedence(int tok)\n{\n    switch (tok) {\n        case TOK_LOR: return 1;\n        case TOK_LAND: return 2;\n\tcase '|': return 3;\n\tcase '^': return 4;\n\tcase '&': return 5;\n\tcase TOK_EQ: case TOK_NE: return 6;\n relat: case TOK_ULT: case TOK_UGE: return 7;\n\tcase TOK_SHL: case TOK_SAR: return 8;\n\tcase '+': case '-': return 9;\n\tcase '*': case '/': case '%': return 10;\n\tdefault:\n\t    if (tok >= TOK_ULE && tok <= TOK_GT)\n\t        goto relat;\n\t    return 0;\n    }\n}\nstatic unsigned char prec[256];\nstatic void init_prec(void)\n{\n    int i;\n    for (i = 0; i < 256; i++)\n\tprec[i] = precedence(i);\n}\n#define precedence(i) ((unsigned)i < 256 ? prec[i] : 0)\n\nstatic void expr_landor(int op);\n\nstatic void expr_infix(int p)\n{\n    int t = tok, p2;\n    while ((p2 = precedence(t)) >= p) {\n        if (t == TOK_LOR || t == TOK_LAND) {\n            expr_landor(t);\n        } else {\n            next();\n            unary();\n            if (precedence(tok) > p2)\n              expr_infix(p2 + 1);\n            gen_op(t);\n        }\n        t = tok;\n    }\n}\n#endif\n\n/* Assuming vtop is a value used in a conditional context\n   (i.e. compared with zero) return 0 if it's false, 1 if\n   true and -1 if it can't be statically determined.  */\nstatic int condition_3way(void)\n{\n    int c = -1;\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&\n\t(!(vtop->r & VT_SYM) || !vtop->sym->a.weak)) {\n\tvdup();\n        gen_cast_s(VT_BOOL);\n\tc = vtop->c.i;\n\tvpop();\n    }\n    return c;\n}\n\nstatic void expr_landor(int op)\n{\n    int t = 0, cc = 1, f = 0, i = op == TOK_LAND, c;\n    for(;;) {\n        c = f ? i : condition_3way();\n        if (c < 0)\n            save_regs(1), cc = 0;\n        else if (c != i)\n            nocode_wanted++, f = 1;\n        if (tok != op)\n            break;\n        if (c < 0)\n            t = gvtst(i, t);\n        else\n            vpop();\n        next();\n        expr_landor_next(op);\n    }\n    if (cc || f) {\n        vpop();\n        vpushi(i ^ f);\n        gsym(t);\n        nocode_wanted -= f;\n    } else {\n        gvtst_set(i, t);\n    }\n}\n\nstatic int is_cond_bool(SValue *sv)\n{\n    if ((sv->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST\n        && (sv->type.t & VT_BTYPE) == VT_INT)\n        return (unsigned)sv->c.i < 2;\n    if (sv->r == VT_CMP)\n        return 1;\n    return 0;\n}\n\nstatic void expr_cond(void)\n{\n    int tt, u, r1, r2, rc, t1, t2, islv, c, g;\n    SValue sv;\n    CType type;\n\n    expr_lor();\n    if (tok == '?') {\n        next();\n\tc = condition_3way();\n        g = (tok == ':' && gnu_ext);\n        tt = 0;\n        if (!g) {\n            if (c < 0) {\n                save_regs(1);\n                tt = gvtst(1, 0);\n            } else {\n                vpop();\n            }\n        } else if (c < 0) {\n            /* needed to avoid having different registers saved in\n               each branch */\n            save_regs(1);\n            gv_dup();\n            tt = gvtst(0, 0);\n        }\n\n        if (c == 0)\n          nocode_wanted++;\n        if (!g)\n          gexpr();\n\n        if ((vtop->type.t & VT_BTYPE) == VT_FUNC)\n          mk_pointer(&vtop->type);\n        sv = *vtop; /* save value to handle it later */\n        vtop--; /* no vpop so that FP stack is not flushed */\n\n        if (g) {\n            u = tt;\n        } else if (c < 0) {\n            u = gjmp(0);\n            gsym(tt);\n        } else\n          u = 0;\n\n        if (c == 0)\n          nocode_wanted--;\n        if (c == 1)\n          nocode_wanted++;\n        skip(':');\n        expr_cond();\n\n        if ((vtop->type.t & VT_BTYPE) == VT_FUNC)\n          mk_pointer(&vtop->type);\n\n        /* cast operands to correct type according to ISOC rules */\n        if (!combine_types(&type, &sv, vtop, '?'))\n          type_incompatibility_error(&sv.type, &vtop->type,\n            \"type mismatch in conditional expression (have '%s' and '%s')\");\n\n        if (c < 0 && is_cond_bool(vtop) && is_cond_bool(&sv)) {\n            /* optimize \"if (f ? a > b : c || d) ...\" for example, where normally\n               \"a < b\" and \"c || d\" would be forced to \"(int)0/1\" first, whereas\n               this code jumps directly to the if's then/else branches. */\n            t1 = gvtst(0, 0);\n            t2 = gjmp(0);\n            gsym(u);\n            vpushv(&sv);\n            /* combine jump targets of 2nd op with VT_CMP of 1st op */\n            gvtst_set(0, t1);\n            gvtst_set(1, t2);\n            gen_cast(&type);\n            //  tcc_warning(\"two conditions expr_cond\");\n            return;\n        }\n\n        /* keep structs lvalue by transforming `(expr ? a : b)` to `*(expr ? &a : &b)` so\n           that `(expr ? a : b).mem` does not error  with \"lvalue expected\" */\n        islv = (vtop->r & VT_LVAL) && (sv.r & VT_LVAL) && VT_STRUCT == (type.t & VT_BTYPE);\n\n        /* now we convert second operand */\n        if (c != 1) {\n            gen_cast(&type);\n            if (islv) {\n                mk_pointer(&vtop->type);\n                gaddrof();\n            } else if (VT_STRUCT == (vtop->type.t & VT_BTYPE))\n              gaddrof();\n        }\n\n        rc = RC_TYPE(type.t);\n        /* for long longs, we use fixed registers to avoid having\n           to handle a complicated move */\n        if (USING_TWO_WORDS(type.t))\n          rc = RC_RET(type.t);\n\n        tt = r2 = 0;\n        if (c < 0) {\n            r2 = gv(rc);\n            tt = gjmp(0);\n        }\n        gsym(u);\n        if (c == 1)\n          nocode_wanted--;\n\n        /* this is horrible, but we must also convert first\n           operand */\n        if (c != 0) {\n            *vtop = sv;\n            gen_cast(&type);\n            if (islv) {\n                mk_pointer(&vtop->type);\n                gaddrof();\n            } else if (VT_STRUCT == (vtop->type.t & VT_BTYPE))\n              gaddrof();\n        }\n\n        if (c < 0) {\n            r1 = gv(rc);\n            move_reg(r2, r1, islv ? VT_PTR : type.t);\n            vtop->r = r2;\n            gsym(tt);\n        }\n\n        if (islv)\n          indir();\n    }\n}\n\nstatic void expr_eq(void)\n{\n    int t;\n    \n    expr_cond();\n    if ((t = tok) == '=' || TOK_ASSIGN(t)) {\n        test_lvalue();\n        next();\n        if (t == '=') {\n            expr_eq();\n        } else {\n            vdup();\n            expr_eq();\n            gen_op(TOK_ASSIGN_OP(t));\n        }\n        vstore();\n    }\n}\n\nST_FUNC void gexpr(void)\n{\n    expr_eq();\n    if (tok == ',') {\n        do {\n            vpop();\n            next();\n            expr_eq();\n        } while (tok == ',');\n\n        /* convert array & function to pointer */\n        convert_parameter_type(&vtop->type);\n\n        /* make builtin_constant_p((1,2)) return 0 (like on gcc) */\n        if ((vtop->r & VT_VALMASK) == VT_CONST && nocode_wanted && !CONST_WANTED)\n            gv(RC_TYPE(vtop->type.t));\n    }\n}\n\n/* parse a constant expression and return value in vtop.  */\nstatic void expr_const1(void)\n{\n    nocode_wanted += CONST_WANTED_BIT;\n    expr_cond();\n    nocode_wanted -= CONST_WANTED_BIT;\n}\n\n/* parse an integer constant and return its value. */\nstatic inline int64_t expr_const64(void)\n{\n    int64_t c;\n    expr_const1();\n    if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM | VT_NONCONST)) != VT_CONST)\n        expect(\"constant expression\");\n    c = vtop->c.i;\n    vpop();\n    return c;\n}\n\n/* parse an integer constant and return its value.\n   Complain if it doesn't fit 32bit (signed or unsigned).  */\nST_FUNC int expr_const(void)\n{\n    int c;\n    int64_t wc = expr_const64();\n    c = wc;\n    if (c != wc && (unsigned)c != wc)\n        tcc_error(\"constant exceeds 32 bit\");\n    return c;\n}\n\n/* ------------------------------------------------------------------------- */\n/* return from function */\n\n#ifndef TCC_TARGET_ARM64\nstatic void gfunc_return(CType *func_type)\n{\n    if ((func_type->t & VT_BTYPE) == VT_STRUCT) {\n        CType type, ret_type;\n        int ret_align, ret_nregs, regsize;\n        ret_nregs = gfunc_sret(func_type, func_var, &ret_type,\n                               &ret_align, &regsize);\n        if (ret_nregs < 0) {\n#ifdef TCC_TARGET_RISCV64\n            arch_transfer_ret_regs(0);\n#endif\n        } else if (0 == ret_nregs) {\n            /* if returning structure, must copy it to implicit\n               first pointer arg location */\n            type = *func_type;\n            mk_pointer(&type);\n            vset(&type, VT_LOCAL | VT_LVAL, func_vc);\n            indir();\n            vswap();\n            /* copy structure value to pointer */\n            vstore();\n        } else {\n            /* returning structure packed into registers */\n            int size, addr, align, rc, n;\n            size = type_size(func_type,&align);\n            if ((align & (ret_align - 1))\n                && ((vtop->r & VT_VALMASK) < VT_CONST /* pointer to struct */\n                    || (vtop->c.i & (ret_align - 1))\n                    )) {\n                loc = (loc - size) & -ret_align;\n                addr = loc;\n                type = *func_type;\n                vset(&type, VT_LOCAL | VT_LVAL, addr);\n                vswap();\n                vstore();\n                vpop();\n                vset(&ret_type, VT_LOCAL | VT_LVAL, addr);\n            }\n            vtop->type = ret_type;\n            rc = RC_RET(ret_type.t);\n            //printf(\"struct return: n:%d t:%02x rc:%02x\\n\", ret_nregs, ret_type.t, rc);\n            for (n = ret_nregs; --n > 0;) {\n                vdup();\n                gv(rc);\n                vswap();\n                incr_offset(regsize);\n                /* We assume that when a structure is returned in multiple\n                   registers, their classes are consecutive values of the\n                   suite s(n) = 2^n */\n                rc <<= 1;\n            }\n            gv(rc);\n            vtop -= ret_nregs - 1;\n        }\n    } else {\n        gv(RC_RET(func_type->t));\n    }\n    vtop--; /* NOT vpop() because on x86 it would flush the fp stack */\n}\n#endif\n\nstatic void check_func_return(void)\n{\n    if ((func_vt.t & VT_BTYPE) == VT_VOID)\n        return;\n    if (!strcmp (funcname, \"main\")\n        && (func_vt.t & VT_BTYPE) == VT_INT) {\n        /* main returns 0 by default */\n        vpushi(0);\n        gen_assign_cast(&func_vt);\n        gfunc_return(&func_vt);\n    } else {\n        tcc_warning(\"function might return no value: '%s'\", funcname);\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/* switch/case */\n\nstatic int case_cmp(uint64_t a, uint64_t b)\n{\n    if (cur_switch->sv.type.t & VT_UNSIGNED)\n        return a < b ? -1 : a > b;\n    else\n        return (int64_t)a < (int64_t)b ? -1 : (int64_t)a > (int64_t)b;\n}\n\nstatic int case_cmp_qs(const void *pa, const void *pb)\n{\n    return case_cmp((*(struct case_t**)pa)->v1, (*(struct case_t**)pb)->v1);\n}\n\nstatic void case_sort(struct switch_t *sw)\n{\n    struct case_t **p;\n    if (sw->n < 2)\n        return;\n    qsort(sw->p, sw->n, sizeof *sw->p, case_cmp_qs);\n    p = sw->p;\n    while (p < sw->p + sw->n - 1) {\n        if (case_cmp(p[0]->v2, p[1]->v1) >= 0) {\n            int l1 = p[0]->line, l2 = p[1]->line;\n            /* using special format \"%i:...\" to show specific line */\n            tcc_error(\"%i:duplicate case value\", l1 > l2 ? l1 : l2);\n        } else if (p[0]->v2 + 1 == p[1]->v1 && p[0]->ind == p[1]->ind) {\n            /* treat \"case 1: case 2: case 3:\" like \"case 1 ... 3: */\n            p[1]->v1 = p[0]->v1;\n            tcc_free(p[0]);\n            memmove(p, p + 1, (--sw->n - (p - sw->p)) * sizeof *p);\n        } else\n            ++p;\n    }\n}\n\nstatic int gcase(struct case_t **base, int len, int dsym)\n{\n    struct case_t *p;\n    int t, l2, e;\n\n    t = vtop->type.t & VT_BTYPE;\n    if (t != VT_LLONG)\n        t = VT_INT;\n    while (len) {\n        /* binary search while len > 8, else linear */\n        l2 = len > 8 ? len/2 : 0;\n        p = base[l2];\n        vdup(), vpush64(t, p->v2);\n        if (l2 == 0 && p->v1 == p->v2) {\n            gen_op(TOK_EQ); /* jmp to case when equal */\n            gsym_addr(gvtst(0, 0), p->ind);\n        } else {\n            /* case v1 ... v2 */\n            gen_op(TOK_GT); /* jmp over when > V2 */\n            if (len == 1) /* last case test jumps to default when false */\n                dsym = gvtst(0, dsym), e = 0;\n            else\n                e = gvtst(0, 0);\n            vdup(), vpush64(t, p->v1);\n            gen_op(TOK_GE); /* jmp to case when >= V1 */\n            gsym_addr(gvtst(0, 0), p->ind);\n            dsym = gcase(base, l2, dsym);\n            gsym(e);\n        }\n        ++l2, base += l2, len -= l2;\n    }\n    /* jump automagically will suppress more jumps */\n    return gjmp(dsym);\n}\n\nstatic void end_switch(void)\n{\n    struct switch_t *sw = cur_switch;\n    dynarray_reset(&sw->p, &sw->n);\n    cur_switch = sw->prev;\n    tcc_free(sw);\n}\n\n/* ------------------------------------------------------------------------- */\n/* __attribute__((cleanup(fn))) */\n\nstatic void try_call_scope_cleanup(Sym *stop)\n{\n    Sym *cls = cur_scope->cl.s;\n\n    for (; cls != stop; cls = cls->next) {\n\tSym *fs = cls->cleanup_func;\n\tSym *vs = cls->prev_tok;\n\n\tvpushsym(&fs->type, fs);\n\tvset(&vs->type, vs->r, vs->c);\n\tvtop->sym = vs;\n        mk_pointer(&vtop->type);\n\tgaddrof();\n\tgfunc_call(1);\n    }\n}\n\nstatic void try_call_cleanup_goto(Sym *cleanupstate)\n{\n    Sym *oc, *cc;\n    int ocd, ccd;\n\n    if (!cur_scope->cl.s)\n\treturn;\n\n    /* search NCA of both cleanup chains given parents and initial depth */\n    ocd = cleanupstate ? cleanupstate->v & ~SYM_FIELD : 0;\n    for (ccd = cur_scope->cl.n, oc = cleanupstate; ocd > ccd; --ocd, oc = oc->next)\n      ;\n    for (cc = cur_scope->cl.s; ccd > ocd; --ccd, cc = cc->next)\n      ;\n    for (; cc != oc; cc = cc->next, oc = oc->next, --ccd)\n      ;\n\n    try_call_scope_cleanup(cc);\n}\n\n/* call 'func' for each __attribute__((cleanup(func))) */\nstatic void block_cleanup(struct scope *o)\n{\n    int jmp = 0;\n    Sym *g, **pg;\n    for (pg = &pending_gotos; (g = *pg) && g->c > o->cl.n;) {\n        if (g->prev_tok->r & LABEL_FORWARD) {\n            Sym *pcl = g->next;\n            if (!jmp)\n                jmp = gjmp(0);\n            gsym(pcl->jnext);\n            try_call_scope_cleanup(o->cl.s);\n            pcl->jnext = gjmp(0);\n            if (!o->cl.n)\n                goto remove_pending;\n            g->c = o->cl.n;\n            pg = &g->prev;\n        } else {\n    remove_pending:\n            *pg = g->prev;\n            sym_free(g);\n        }\n    }\n    gsym(jmp);\n    try_call_scope_cleanup(o->cl.s);\n}\n\n/* ------------------------------------------------------------------------- */\n/* VLA */\n\nstatic void vla_restore(int loc)\n{\n    if (loc)\n        gen_vla_sp_restore(loc);\n}\n\nstatic void vla_leave(struct scope *o)\n{\n    struct scope *c = cur_scope, *v = NULL;\n    for (; c != o && c; c = c->prev)\n      if (c->vla.num)\n        v = c;\n    if (v)\n      vla_restore(v->vla.locorig);\n}\n\n/* ------------------------------------------------------------------------- */\n/* local scopes */\n\nstatic void new_scope(struct scope *o)\n{\n    /* copy and link previous scope */\n    *o = *cur_scope;\n    o->prev = cur_scope;\n    cur_scope = o;\n    cur_scope->vla.num = 0;\n\n    /* record local declaration stack position */\n    o->lstk = local_stack;\n    o->llstk = local_label_stack;\n    ++local_scope;\n}\n\nstatic void prev_scope(struct scope *o, int is_expr)\n{\n    vla_leave(o->prev);\n\n    if (o->cl.s != o->prev->cl.s)\n        block_cleanup(o->prev);\n\n    /* pop locally defined labels */\n    label_pop(&local_label_stack, o->llstk, is_expr);\n\n    /* In the is_expr case (a statement expression is finished here),\n       vtop might refer to symbols on the local_stack.  Either via the\n       type or via vtop->sym.  We can't pop those nor any that in turn\n       might be referred to.  To make it easier we don't roll back\n       any symbols in that case; some upper level call to block() will\n       do that.  We do have to remove such symbols from the lookup\n       tables, though.  sym_pop will do that.  */\n\n    /* pop locally defined symbols */\n    pop_local_syms(o->lstk, is_expr);\n    cur_scope = o->prev;\n    --local_scope;\n}\n\n/* leave a scope via break/continue(/goto) */\nstatic void leave_scope(struct scope *o)\n{\n    if (!o)\n        return;\n    try_call_scope_cleanup(o->cl.s);\n    vla_leave(o);\n}\n\n/* short versiona for scopes with 'if/do/while/switch' which can\n   declare only types (of struct/union/enum) */\nstatic void new_scope_s(struct scope *o)\n{\n    o->lstk = local_stack;\n    ++local_scope;\n}\n\nstatic void prev_scope_s(struct scope *o)\n{\n    sym_pop(&local_stack, o->lstk, 0);\n    --local_scope;\n}\n\n/* ------------------------------------------------------------------------- */\n/* call block from 'for do while' loops */\n\nstatic void lblock(int *bsym, int *csym)\n{\n    struct scope *lo = loop_scope, *co = cur_scope;\n    int *b = co->bsym, *c = co->csym;\n    if (csym) {\n        co->csym = csym;\n        loop_scope = co;\n    }\n    co->bsym = bsym;\n    block(0);\n    co->bsym = b;\n    if (csym) {\n        co->csym = c;\n        loop_scope = lo;\n    }\n}\n\nstatic void block(int flags)\n{\n    int a, b, c, d, e, t;\n    struct scope o;\n    Sym *s;\n\n    if (flags & STMT_EXPR) {\n        /* default return value is (void) */\n        vpushi(0);\n        vtop->type.t = VT_VOID;\n    }\n\nagain:\n    t = tok;\n    /* If the token carries a value, next() might destroy it. Only with\n       invalid code such as f(){\"123\"4;} */\n    if (TOK_HAS_VALUE(t))\n        goto expr;\n    next();\n\n    if (debug_modes)\n        tcc_tcov_check_line (tcc_state, 0), tcc_tcov_block_begin (tcc_state);\n\n    if (t == TOK_IF) {\n        new_scope_s(&o);\n        skip('(');\n        gexpr();\n        skip(')');\n        a = gvtst(1, 0);\n        block(0);\n        if (tok == TOK_ELSE) {\n            d = gjmp(0);\n            gsym(a);\n            next();\n            block(0);\n            gsym(d); /* patch else jmp */\n        } else {\n            gsym(a);\n        }\n        prev_scope_s(&o);\n\n    } else if (t == TOK_WHILE) {\n        new_scope_s(&o);\n        d = gind();\n        skip('(');\n        gexpr();\n        skip(')');\n        a = gvtst(1, 0);\n        b = 0;\n        lblock(&a, &b);\n        gjmp_addr(d);\n        gsym_addr(b, d);\n        gsym(a);\n        prev_scope_s(&o);\n\n    } else if (t == '{') {\n        if (debug_modes)\n            tcc_debug_stabn(tcc_state, N_LBRAC, ind - func_ind);\n        new_scope(&o);\n\n        /* handle local labels declarations */\n        while (tok == TOK_LABEL) {\n            do {\n                next();\n                if (tok < TOK_UIDENT)\n                    expect(\"label identifier\");\n                label_push(&local_label_stack, tok, LABEL_DECLARED);\n                next();\n            } while (tok == ',');\n            skip(';');\n        }\n\n        while (tok != '}') {\n\t    decl(VT_LOCAL);\n            if (tok != '}') {\n                if (flags & STMT_EXPR)\n                    vpop();\n                block(flags | STMT_COMPOUND);\n            }\n        }\n\n        prev_scope(&o, flags & STMT_EXPR);\n        if (debug_modes)\n            tcc_debug_stabn(tcc_state, N_RBRAC, ind - func_ind);\n        if (local_scope)\n            next();\n        else if (!nocode_wanted)\n            check_func_return();\n\n    } else if (t == TOK_RETURN) {\n        b = (func_vt.t & VT_BTYPE) != VT_VOID;\n        if (tok != ';') {\n            gexpr();\n            if (b) {\n                gen_assign_cast(&func_vt);\n            } else {\n                if (vtop->type.t != VT_VOID)\n                    tcc_warning(\"void function returns a value\");\n                vtop--;\n            }\n        } else if (b) {\n            tcc_warning(\"'return' with no value\");\n            b = 0;\n        }\n        leave_scope(root_scope);\n        if (b)\n            gfunc_return(&func_vt);\n        skip(';');\n        /* jump unless last stmt in top-level block */\n        if (tok != '}' || local_scope != 1)\n            rsym = gjmp(rsym);\n        if (debug_modes)\n\t    tcc_tcov_block_end (tcc_state, -1);\n        CODE_OFF();\n\n    } else if (t == TOK_BREAK) {\n        /* compute jump */\n        if (!cur_scope->bsym)\n            tcc_error(\"cannot break\");\n        if (cur_switch && cur_scope->bsym == cur_switch->bsym)\n            leave_scope(cur_switch->scope);\n        else\n            leave_scope(loop_scope);\n        *cur_scope->bsym = gjmp(*cur_scope->bsym);\n        skip(';');\n\n    } else if (t == TOK_CONTINUE) {\n        /* compute jump */\n        if (!cur_scope->csym)\n            tcc_error(\"cannot continue\");\n        leave_scope(loop_scope);\n        *cur_scope->csym = gjmp(*cur_scope->csym);\n        skip(';');\n\n    } else if (t == TOK_FOR) {\n        new_scope(&o);\n\n        skip('(');\n        if (tok != ';') {\n            /* c99 for-loop init decl? */\n            if (!decl(VT_JMP)) {\n                /* no, regular for-loop init expr */\n                gexpr();\n                vpop();\n            }\n        }\n        skip(';');\n        a = b = 0;\n        c = d = gind();\n        if (tok != ';') {\n            gexpr();\n            a = gvtst(1, 0);\n        }\n        skip(';');\n        if (tok != ')') {\n            e = gjmp(0);\n            d = gind();\n            gexpr();\n            vpop();\n            gjmp_addr(c);\n            gsym(e);\n        }\n        skip(')');\n        lblock(&a, &b);\n        gjmp_addr(d);\n        gsym_addr(b, d);\n        gsym(a);\n        prev_scope(&o, 0);\n\n    } else if (t == TOK_DO) {\n        new_scope_s(&o);\n        a = b = 0;\n        d = gind();\n        lblock(&a, &b);\n        gsym(b);\n        skip(TOK_WHILE);\n        skip('(');\n\tgexpr();\n        skip(')');\n        skip(';');\n\tc = gvtst(0, 0);\n\tgsym_addr(c, d);\n        gsym(a);\n        prev_scope_s(&o);\n\n    } else if (t == TOK_SWITCH) {\n        struct switch_t *sw;\n\n        sw = tcc_mallocz(sizeof *sw);\n        sw->bsym = &a;\n        sw->scope = cur_scope;\n        sw->prev = cur_switch;\n        sw->nocode_wanted = nocode_wanted;\n        cur_switch = sw;\n\n        new_scope_s(&o);\n        skip('(');\n        gexpr();\n        skip(')');\n        if (!is_integer_btype(vtop->type.t & VT_BTYPE))\n            tcc_error(\"switch value not an integer\");\n        sw->sv = *vtop--; /* save switch value */\n        a = 0;\n        b = gjmp(0); /* jump to first case */\n        lblock(&a, NULL);\n        a = gjmp(a); /* add implicit break */\n        /* case lookup */\n        gsym(b);\n        prev_scope_s(&o);\n        if (sw->nocode_wanted)\n            goto skip_switch;\n        case_sort(sw);\n        sw->bsym = NULL; /* marker for 32bit:gen_opl() */\n        vpushv(&sw->sv);\n        gv(RC_INT);\n        d = gcase(sw->p, sw->n, 0);\n        vpop();\n        if (sw->def_sym)\n            gsym_addr(d, sw->def_sym);\n        else\n            gsym(d);\n    skip_switch:\n        /* break label */\n        gsym(a);\n        end_switch();\n\n    } else if (t == TOK_CASE) {\n        struct case_t *cr;\n        if (!cur_switch)\n            expect(\"switch\");\n        cr = tcc_malloc(sizeof(struct case_t));\n        dynarray_add(&cur_switch->p, &cur_switch->n, cr);\n        t = cur_switch->sv.type.t;\n        cr->v1 = cr->v2 = value64(expr_const64(), t);\n        if (tok == TOK_DOTS && gnu_ext) {\n            next();\n            cr->v2 = value64(expr_const64(), t);\n            if (case_cmp(cr->v2, cr->v1) < 0)\n                tcc_warning(\"empty case range\");\n        }\n        /* case and default are unreachable from a switch under nocode_wanted */\n        if (!cur_switch->nocode_wanted)\n            cr->ind = gind();\n        cr->line = file->line_num;\n        skip(':');\n        goto block_after_label;\n\n    } else if (t == TOK_DEFAULT) {\n        if (!cur_switch)\n            expect(\"switch\");\n        if (cur_switch->def_sym)\n            tcc_error(\"too many 'default'\");\n        cur_switch->def_sym = cur_switch->nocode_wanted ? -1 : gind();\n        skip(':');\n        goto block_after_label;\n\n    } else if (t == TOK_GOTO) {\n        vla_restore(cur_scope->vla.locorig);\n        if (tok == '*' && gnu_ext) {\n            /* computed goto */\n            next();\n            gexpr();\n            if ((vtop->type.t & VT_BTYPE) != VT_PTR)\n                expect(\"pointer\");\n            ggoto();\n\n        } else if (tok >= TOK_UIDENT) {\n\t    s = label_find(tok);\n\t    /* put forward definition if needed */\n            if (!s)\n              s = label_push(&global_label_stack, tok, LABEL_FORWARD);\n            else if (s->r == LABEL_DECLARED)\n              s->r = LABEL_FORWARD;\n\n\t    if (s->r & LABEL_FORWARD) {\n\t\t/* start new goto chain for cleanups, linked via label->next */\n\t\tif (cur_scope->cl.s && !nocode_wanted) {\n                    sym_push2(&pending_gotos, SYM_FIELD, 0, cur_scope->cl.n);\n                    pending_gotos->prev_tok = s;\n                    s = sym_push2(&s->next, SYM_FIELD, 0, 0);\n                    pending_gotos->next = s;\n                }\n\t\ts->jnext = gjmp(s->jnext);\n\t    } else {\n\t\ttry_call_cleanup_goto(s->cleanupstate);\n\t\tgjmp_addr(s->jind);\n\t    }\n\t    next();\n\n        } else {\n            expect(\"label identifier\");\n        }\n        skip(';');\n\n    } else if (t == TOK_ASM1 || t == TOK_ASM2 || t == TOK_ASM3) {\n        asm_instr();\n\n    } else {\n        if (tok == ':' && t >= TOK_UIDENT) {\n            /* label case */\n\t    next();\n            s = label_find(t);\n            if (s) {\n                if (s->r == LABEL_DEFINED)\n                    tcc_error(\"duplicate label '%s'\", get_tok_str(s->v, NULL));\n                s->r = LABEL_DEFINED;\n\t\tif (s->next) {\n\t\t    Sym *pcl; /* pending cleanup goto */\n\t\t    for (pcl = s->next; pcl; pcl = pcl->prev)\n\t\t      gsym(pcl->jnext);\n\t\t    sym_pop(&s->next, NULL, 0);\n\t\t} else\n\t\t  gsym(s->jnext);\n            } else {\n                s = label_push(&global_label_stack, t, LABEL_DEFINED);\n            }\n            s->jind = gind();\n            s->cleanupstate = cur_scope->cl.s;\n\n    block_after_label:\n              {\n                /* Accept attributes after labels (e.g. 'unused') */\n                AttributeDef ad_tmp;\n                parse_attribute(&ad_tmp);\n              }\n            if (debug_modes)\n                tcc_tcov_reset_ind(tcc_state);\n            vla_restore(cur_scope->vla.loc);\n\n            if (tok != '}') {\n                if (0 == (flags & STMT_COMPOUND))\n                    goto again;\n                /* C23: insert implicit null-statement whithin compound statement */\n            } else {\n                /* we accept this, but it is a mistake */\n                tcc_warning_c(warn_all)(\"deprecated use of label at end of compound statement\");\n            }\n        } else {\n            /* expression case */\n            if (t != ';') {\n                unget_tok(t);\n    expr:\n                if (flags & STMT_EXPR) {\n                    vpop();\n                    gexpr();\n                } else {\n                    gexpr();\n                    vpop();\n                }\n                skip(';');\n            }\n        }\n    }\n\n    if (debug_modes)\n        tcc_tcov_check_line (tcc_state, 0), tcc_tcov_block_end (tcc_state, 0);\n}\n\n/* This skips over a stream of tokens containing balanced {} and ()\n   pairs, stopping at outer ',' ';' and '}' (or matching '}' if we started\n   with a '{').  If STR then allocates and stores the skipped tokens\n   in *STR.  This doesn't check if () and {} are nested correctly,\n   i.e. \"({)}\" is accepted.  */\nstatic void skip_or_save_block(TokenString **str)\n{\n    int braces = tok == '{';\n    int level = 0;\n    if (str)\n      *str = tok_str_alloc();\n\n    while (1) {\n\tint t = tok;\n        if (level == 0\n            && (t == ','\n             || t == ';'\n             || t == '}'\n             || t == ')'\n             || t == ']'))\n             break;\n\tif (t == TOK_EOF) {\n\t     if (str || level > 0)\n\t       tcc_error(\"unexpected end of file\");\n\t     else\n\t       break;\n\t}\n\tif (str)\n\t  tok_str_add_tok(*str);\n\tnext();\n\tif (t == '{' || t == '(' || t == '[') {\n\t    level++;\n\t} else if (t == '}' || t == ')' || t == ']') {\n\t    level--;\n\t    if (level == 0 && braces && t == '}')\n\t      break;\n\t}\n    }\n    if (str)\n\ttok_str_add(*str, TOK_EOF);\n}\n\n#define EXPR_CONST 1\n#define EXPR_ANY   2\n\nstatic void parse_init_elem(int expr_type)\n{\n    int saved_global_expr;\n    switch(expr_type) {\n    case EXPR_CONST:\n        /* compound literals must be allocated globally in this case */\n        saved_global_expr = global_expr;\n        global_expr = 1;\n        expr_const1();\n        global_expr = saved_global_expr;\n        /* NOTE: symbols are accepted, as well as lvalue for anon symbols\n\t   (compound literals).  */\n        if (((vtop->r & (VT_VALMASK | VT_LVAL)) != VT_CONST\n             && ((vtop->r & (VT_SYM|VT_LVAL)) != (VT_SYM|VT_LVAL)\n                 || vtop->sym->v < SYM_FIRST_ANOM))\n#ifdef TCC_TARGET_PE\n                 || ((vtop->r & VT_SYM) && vtop->sym->a.dllimport)\n#endif\n           )\n            tcc_error(\"initializer element is not constant\");\n        break;\n    case EXPR_ANY:\n        expr_eq();\n        break;\n    }\n}\n\n#if 1\nstatic void init_assert(init_params *p, int offset)\n{\n    if (p->sec ? !NODATA_WANTED && offset > p->sec->data_offset\n               : !nocode_wanted && offset > p->local_offset)\n        tcc_internal_error(\"initializer overflow\");\n}\n#else\n#define init_assert(sec, offset)\n#endif\n\n/* put zeros for variable based init */\nstatic void init_putz(init_params *p, unsigned long c, int size)\n{\n    init_assert(p, c + size);\n    if (p->sec) {\n        /* nothing to do because globals are already set to zero */\n    } else {\n        vpush_helper_func(TOK_memset);\n        vseti(VT_LOCAL, c);\n        vpushi(0);\n        vpushs(size);\n#if defined TCC_TARGET_ARM && defined TCC_ARM_EABI\n        vswap();  /* using __aeabi_memset(void*, size_t, int) */\n#endif\n        gfunc_call(3);\n    }\n}\n\n#define DIF_FIRST     1\n#define DIF_SIZE_ONLY 2\n#define DIF_HAVE_ELEM 4\n#define DIF_CLEAR     8\n\n/* delete relocations for specified range c ... c + size. Unfortunatly\n   in very special cases, relocations may occur unordered */\nstatic void decl_design_delrels(Section *sec, int c, int size)\n{\n    ElfW_Rel *rel, *rel2, *rel_end;\n    if (!sec || !sec->reloc)\n        return;\n    rel = rel2 = (ElfW_Rel*)sec->reloc->data;\n    rel_end = (ElfW_Rel*)(sec->reloc->data + sec->reloc->data_offset);\n    while (rel < rel_end) {\n        if (rel->r_offset >= c && rel->r_offset < c + size) {\n            sec->reloc->data_offset -= sizeof *rel;\n        } else {\n            if (rel2 != rel)\n                memcpy(rel2, rel, sizeof *rel);\n            ++rel2;\n        }\n        ++rel;\n    }\n}\n\nstatic void decl_design_flex(init_params *p, Sym *ref, int index)\n{\n    if (ref == p->flex_array_ref) {\n        if (index >= ref->c)\n            ref->c = index + 1;\n    } else if (ref->c < 0)\n        tcc_error(\"flexible array has zero size in this context\");\n}\n\n/* t is the array or struct type. c is the array or struct\n   address. cur_field is the pointer to the current\n   field, for arrays the 'c' member contains the current start\n   index.  'flags' is as in decl_initializer.\n   'al' contains the already initialized length of the\n   current container (starting at c).  This returns the new length of that.  */\nstatic int decl_designator(init_params *p, CType *type, unsigned long c,\n                           Sym **cur_field, int flags, int al)\n{\n    Sym *s, *f;\n    int index, index_last, align, l, nb_elems, elem_size;\n    unsigned long corig = c;\n\n    elem_size = 0;\n    nb_elems = 1;\n\n    if (flags & DIF_HAVE_ELEM)\n        goto no_designator;\n\n    if (gnu_ext && tok >= TOK_UIDENT) {\n        l = tok, next();\n        if (tok == ':')\n            goto struct_field;\n        unget_tok(l);\n    }\n\n    /* NOTE: we only support ranges for last designator */\n    while (nb_elems == 1 && (tok == '[' || tok == '.')) {\n        if (tok == '[') {\n            if (!(type->t & VT_ARRAY))\n                expect(\"array type\");\n            next();\n            index = index_last = expr_const();\n            if (tok == TOK_DOTS && gnu_ext) {\n                next();\n                index_last = expr_const();\n            }\n            skip(']');\n            s = type->ref;\n            decl_design_flex(p, s, index_last);\n            if (index < 0 || index_last >= s->c || index_last < index)\n\t        tcc_error(\"index exceeds array bounds or range is empty\");\n            if (cur_field)\n\t\t(*cur_field)->c = index_last;\n            type = pointed_type(type);\n            elem_size = type_size(type, &align);\n            c += index * elem_size;\n            nb_elems = index_last - index + 1;\n        } else {\n            int cumofs;\n            next();\n            l = tok;\n        struct_field:\n            next();\n\t    f = find_field(type, l, &cumofs);\n            if (cur_field)\n                *cur_field = f;\n\t    type = &f->type;\n            c += cumofs;\n        }\n        cur_field = NULL;\n    }\n    if (!cur_field) {\n        if (tok == '=') {\n            next();\n        } else if (!gnu_ext) {\n\t    expect(\"=\");\n        }\n    } else {\n    no_designator:\n        if (type->t & VT_ARRAY) {\n\t    index = (*cur_field)->c;\n            s = type->ref;\n            decl_design_flex(p, s, index);\n            if (index >= s->c)\n                tcc_error(\"too many initializers\");\n            type = pointed_type(type);\n            elem_size = type_size(type, &align);\n            c += index * elem_size;\n        } else {\n            f = *cur_field;\n\t    /* Skip bitfield padding. Also with size 32 and 64. */\n\t    while (f && (f->v & SYM_FIRST_ANOM) &&\n\t\t   is_integer_btype(f->type.t & VT_BTYPE))\n\t        *cur_field = f = f->next;\n            if (!f)\n                tcc_error(\"too many initializers\");\n\t    type = &f->type;\n            c += f->c;\n        }\n    }\n\n    if (!elem_size) /* for structs */\n        elem_size = type_size(type, &align);\n\n    /* Using designators the same element can be initialized more\n       than once.  In that case we need to delete possibly already\n       existing relocations. */\n    if (!(flags & DIF_SIZE_ONLY) && c - corig < al) {\n        decl_design_delrels(p->sec, c, elem_size * nb_elems);\n        flags &= ~DIF_CLEAR; /* mark stack dirty too */\n    }\n\n    decl_initializer(p, type, c, flags & ~DIF_FIRST);\n\n    if (!(flags & DIF_SIZE_ONLY) && nb_elems > 1) {\n        Sym aref = {0};\n        CType t1;\n        int i;\n        if (p->sec || (type->t & VT_ARRAY)) {\n            /* make init_putv/vstore believe it were a struct */\n            aref.c = elem_size;\n            t1.t = VT_STRUCT, t1.ref = &aref;\n            type = &t1;\n        }\n        if (p->sec)\n            vpush_ref(type, p->sec, c, elem_size);\n        else\n\t    vset(type, VT_LOCAL|VT_LVAL, c);\n        for (i = 1; i < nb_elems; i++) {\n            vdup();\n            init_putv(p, type, c + elem_size * i);\n\t}\n        vpop();\n    }\n\n    c += nb_elems * elem_size;\n    if (c - corig > al)\n      al = c - corig;\n    return al;\n}\n\n/* store a value or an expression directly in global data or in local array */\nstatic void init_putv(init_params *p, CType *type, unsigned long c)\n{\n    int bt;\n    void *ptr;\n    CType dtype;\n    int size, align;\n    Section *sec = p->sec;\n    uint64_t val;\n\n    dtype = *type;\n    dtype.t &= ~VT_CONSTANT; /* need to do that to avoid false warning */\n\n    size = type_size(type, &align);\n    if (type->t & VT_BITFIELD)\n        size = (BIT_POS(type->t) + BIT_SIZE(type->t) + 7) / 8;\n    init_assert(p, c + size);\n\n    if (sec) {\n        /* XXX: not portable */\n        /* XXX: generate error if incorrect relocation */\n        gen_assign_cast(&dtype);\n        bt = type->t & VT_BTYPE;\n\n        if ((vtop->r & VT_SYM)\n            && bt != VT_PTR\n            && (bt != (PTR_SIZE == 8 ? VT_LLONG : VT_INT)\n                || (type->t & VT_BITFIELD))\n            && !((vtop->r & VT_CONST) && vtop->sym->v >= SYM_FIRST_ANOM)\n            )\n            tcc_error(\"initializer element is not computable at load time\");\n\n        if (NODATA_WANTED) {\n            vtop--;\n            return;\n        }\n\n        ptr = sec->data + c;\n        val = vtop->c.i;\n\n        /* XXX: make code faster ? */\n\tif ((vtop->r & (VT_SYM|VT_CONST)) == (VT_SYM|VT_CONST) &&\n\t    vtop->sym->v >= SYM_FIRST_ANOM &&\n\t    /* XXX This rejects compound literals like\n\t       '(void *){ptr}'.  The problem is that '&sym' is\n\t       represented the same way, which would be ruled out\n\t       by the SYM_FIRST_ANOM check above, but also '\"string\"'\n\t       in 'char *p = \"string\"' is represented the same\n\t       with the type being VT_PTR and the symbol being an\n\t       anonymous one.  That is, there's no difference in vtop\n\t       between '(void *){x}' and '&(void *){x}'.  Ignore\n\t       pointer typed entities here.  Hopefully no real code\n\t       will ever use compound literals with scalar type.  */\n\t    (vtop->type.t & VT_BTYPE) != VT_PTR) {\n\t    /* These come from compound literals, memcpy stuff over.  */\n\t    Section *ssec;\n\t    ElfSym *esym;\n\t    ElfW_Rel *rel;\n\t    esym = elfsym(vtop->sym);\n\t    ssec = tcc_state->sections[esym->st_shndx];\n\t    memmove (ptr, ssec->data + esym->st_value + (int)vtop->c.i, size);\n\t    if (ssec->reloc) {\n\t\t/* We need to copy over all memory contents, and that\n\t\t   includes relocations.  Use the fact that relocs are\n\t\t   created it order, so look from the end of relocs\n\t\t   until we hit one before the copied region.  */\n                unsigned long relofs = ssec->reloc->data_offset;\n\t\twhile (relofs >= sizeof(*rel)) {\n                    relofs -= sizeof(*rel);\n                    rel = (ElfW_Rel*)(ssec->reloc->data + relofs);\n\t\t    if (rel->r_offset >= esym->st_value + size)\n\t\t      continue;\n\t\t    if (rel->r_offset < esym->st_value)\n\t\t      break;\n\t\t    put_elf_reloca(symtab_section, sec,\n\t\t\t\t   c + rel->r_offset - esym->st_value,\n\t\t\t\t   ELFW(R_TYPE)(rel->r_info),\n\t\t\t\t   ELFW(R_SYM)(rel->r_info),\n#if PTR_SIZE == 8\n\t\t\t\t   rel->r_addend\n#else\n\t\t\t\t   0\n#endif\n\t\t\t\t  );\n\t\t}\n\t    }\n\t} else {\n            if (type->t & VT_BITFIELD) {\n                int bit_pos, bit_size, bits, n;\n                unsigned char *p, v, m;\n                bit_pos = BIT_POS(vtop->type.t);\n                bit_size = BIT_SIZE(vtop->type.t);\n                p = (unsigned char*)ptr + (bit_pos >> 3);\n                bit_pos &= 7, bits = 0;\n                while (bit_size) {\n                    n = 8 - bit_pos;\n                    if (n > bit_size)\n                        n = bit_size;\n                    v = val >> bits << bit_pos;\n                    m = ((1 << n) - 1) << bit_pos;\n                    *p = (*p & ~m) | (v & m);\n                    bits += n, bit_size -= n, bit_pos = 0, ++p;\n                }\n            } else\n            switch(bt) {\n\t    case VT_BOOL:\n\t\t*(char *)ptr = val != 0;\n                break;\n\t    case VT_BYTE:\n\t\t*(char *)ptr = val;\n\t\tbreak;\n\t    case VT_SHORT:\n                write16le(ptr, val);\n\t\tbreak;\n\t    case VT_FLOAT:\n                write32le(ptr, val);\n\t\tbreak;\n\t    case VT_DOUBLE:\n                write64le(ptr, val);\n\t\tbreak;\n\t    case VT_LDOUBLE:\n#if defined TCC_IS_NATIVE_387\n                /* Host and target platform may be different but both have x87.\n                   On windows, tcc does not use VT_LDOUBLE, except when it is a\n                   cross compiler.  In this case a mingw gcc as host compiler\n                   comes here with 10-byte long doubles, while msvc or tcc won't.\n                   tcc itself can still translate by asm.\n                   In any case we avoid possibly random bytes 11 and 12.\n                */\n                if (sizeof (long double) >= 10)\n                    memcpy(ptr, &vtop->c.ld, 10);\n#ifdef __TINYC__\n                else if (sizeof (long double) == sizeof (double))\n                    __asm__(\"fldl %1\\nfstpt %0\\n\" : \"=m\" (*ptr) : \"m\" (vtop->c.ld));\n#endif\n                else\n#endif\n                /* For other platforms it should work natively, but may not work\n                   for cross compilers */\n                if (sizeof(long double) == LDOUBLE_SIZE)\n                    memcpy(ptr, &vtop->c.ld, LDOUBLE_SIZE);\n                else if (sizeof(double) == LDOUBLE_SIZE)\n                    *(double*)ptr = (double)vtop->c.ld;\n                else if (0 == memcmp(ptr, &vtop->c.ld, LDOUBLE_SIZE))\n                    ; /* nothing to do for 0.0 */\n#ifndef TCC_CROSS_TEST\n                else\n                    tcc_error(\"can't cross compile long double constants\");\n#endif\n\t\tbreak;\n\n#if PTR_SIZE == 8\n            /* intptr_t may need a reloc too, see tcctest.c:relocation_test() */\n\t    case VT_LLONG:\n\t    case VT_PTR:\n\t        if (vtop->r & VT_SYM)\n\t          greloca(sec, vtop->sym, c, R_DATA_PTR, val);\n\t        else\n\t          write64le(ptr, val);\n\t        break;\n            case VT_INT:\n                write32le(ptr, val);\n                break;\n#else\n\t    case VT_LLONG:\n                write64le(ptr, val);\n                break;\n            case VT_PTR:\n            case VT_INT:\n\t        if (vtop->r & VT_SYM)\n\t          greloc(sec, vtop->sym, c, R_DATA_PTR);\n\t        write32le(ptr, val);\n\t        break;\n#endif\n\t    default:\n                //tcc_internal_error(\"unexpected type\");\n                break;\n\t    }\n\t}\n        vtop--;\n    } else {\n        vset(&dtype, VT_LOCAL|VT_LVAL, c);\n        vswap();\n        vstore();\n        vpop();\n    }\n}\n\n/* 't' contains the type and storage info. 'c' is the offset of the\n   object in section 'sec'. If 'sec' is NULL, it means stack based\n   allocation. 'flags & DIF_FIRST' is true if array '{' must be read (multi\n   dimension implicit array init handling). 'flags & DIF_SIZE_ONLY' is true if\n   size only evaluation is wanted (only for arrays). */\nstatic void decl_initializer(init_params *p, CType *type, unsigned long c, int flags)\n{\n    int len, n, no_oblock, i;\n    int size1, align1;\n    Sym *s, *f;\n    Sym indexsym;\n    CType *t1;\n\n    /* generate line number info */\n    if (debug_modes && !(flags & DIF_SIZE_ONLY) && !p->sec)\n        tcc_debug_line(tcc_state), tcc_tcov_check_line (tcc_state, 1);\n\n    if (!(flags & DIF_HAVE_ELEM) && tok != '{' &&\n\t/* In case of strings we have special handling for arrays, so\n\t   don't consume them as initializer value (which would commit them\n\t   to some anonymous symbol).  */\n\ttok != TOK_LSTR && tok != TOK_STR &&\n\t(!(flags & DIF_SIZE_ONLY)\n            /* a struct may be initialized from a struct of same type, as in\n                    struct {int x,y;} a = {1,2}, b = {3,4}, c[] = {a,b};\n               In that case we need to parse the element in order to check\n               it for compatibility below */\n            || (type->t & VT_BTYPE) == VT_STRUCT)\n        ) {\n        int ncw_prev = nocode_wanted;\n        if ((flags & DIF_SIZE_ONLY) && !p->sec)\n            ++nocode_wanted;\n\tparse_init_elem(!p->sec ? EXPR_ANY : EXPR_CONST);\n        nocode_wanted = ncw_prev;\n        flags |= DIF_HAVE_ELEM;\n    }\n\n    if (type->t & VT_ARRAY) {\n        no_oblock = 1;\n        if (((flags & DIF_FIRST) && tok != TOK_LSTR && tok != TOK_STR) ||\n            tok == '{') {\n            skip('{');\n            no_oblock = 0;\n        }\n\n        s = type->ref;\n        n = s->c;\n        t1 = pointed_type(type);\n        size1 = type_size(t1, &align1);\n\n        /* only parse strings here if correct type (otherwise: handle\n           them as ((w)char *) expressions */\n        if ((tok == TOK_LSTR && \n#ifdef TCC_TARGET_PE\n             (t1->t & VT_BTYPE) == VT_SHORT && (t1->t & VT_UNSIGNED)\n#else\n             (t1->t & VT_BTYPE) == VT_INT\n#endif\n            ) || (tok == TOK_STR && (t1->t & VT_BTYPE) == VT_BYTE)) {\n\t    len = 0;\n            cstr_reset(&initstr);\n            if (size1 != (tok == TOK_STR ? 1 : sizeof(nwchar_t)))\n              tcc_error(\"unhandled string literal merging\");\n            while (tok == TOK_STR || tok == TOK_LSTR) {\n                if (initstr.size)\n                  initstr.size -= size1;\n                if (tok == TOK_STR)\n                  len += tokc.str.size;\n                else\n                  len += tokc.str.size / sizeof(nwchar_t);\n                len--;\n                cstr_cat(&initstr, tokc.str.data, tokc.str.size);\n                next();\n            }\n            if (tok != ')' && tok != '}' && tok != ',' && tok != ';'\n                && tok != TOK_EOF) {\n                /* Not a lone literal but part of a bigger expression.  */\n                unget_tok(size1 == 1 ? TOK_STR : TOK_LSTR);\n                tokc.str.size = initstr.size;\n                tokc.str.data = initstr.data;\n                goto do_init_array;\n            }\n\n            decl_design_flex(p, s, len);\n            if (!(flags & DIF_SIZE_ONLY)) {\n                int nb = n, ch;\n                if (len < nb)\n                    nb = len;\n                if (len > nb)\n                  tcc_warning(\"initializer-string for array is too long\");\n                /* in order to go faster for common case (char\n                   string in global variable, we handle it\n                   specifically */\n                if (p->sec && size1 == 1) {\n                    init_assert(p, c + nb);\n                    if (!NODATA_WANTED)\n                      memcpy(p->sec->data + c, initstr.data, nb);\n                } else {\n                    for(i=0;i<n;i++) {\n                        if (i >= nb) {\n                          /* only add trailing zero if enough storage (no\n                             warning in this case since it is standard) */\n                          if (flags & DIF_CLEAR)\n                            break;\n                          if (n - i >= 4) {\n                            init_putz(p, c + i * size1, (n - i) * size1);\n                            break;\n                          }\n                          ch = 0;\n                        } else if (size1 == 1)\n                          ch = ((unsigned char *)initstr.data)[i];\n                        else\n                          ch = ((nwchar_t *)initstr.data)[i];\n                        vpushi(ch);\n                        init_putv(p, t1, c + i * size1);\n                    }\n                }\n            }\n        } else {\n\n          do_init_array:\n\t    indexsym.c = 0;\n\t    f = &indexsym;\n\n          do_init_list:\n            /* zero memory once in advance */\n            if (!(flags & (DIF_CLEAR | DIF_SIZE_ONLY))) {\n                init_putz(p, c, n*size1);\n                flags |= DIF_CLEAR;\n            }\n\n\t    len = 0;\n            /* GNU extension: if the initializer is empty for a flex array,\n               it's size is zero.  We won't enter the loop, so set the size\n               now.  */\n            decl_design_flex(p, s, len);\n\t    while (tok != '}' || (flags & DIF_HAVE_ELEM)) {\n\t\tlen = decl_designator(p, type, c, &f, flags, len);\n\t\tflags &= ~DIF_HAVE_ELEM;\n\t\tif (type->t & VT_ARRAY) {\n\t\t    ++indexsym.c;\n\t\t    /* special test for multi dimensional arrays (may not\n\t\t       be strictly correct if designators are used at the\n\t\t       same time) */\n\t\t    if (no_oblock && len >= n*size1)\n\t\t        break;\n\t\t} else {\n\t\t    if (s->type.t == VT_UNION)\n\t\t        f = NULL;\n\t\t    else\n\t\t        f = f->next;\n\t\t    if (no_oblock && f == NULL)\n\t\t        break;\n\t\t}\n\n\t\tif (tok == '}')\n\t\t    break;\n\t\tskip(',');\n\t    }\n        }\n        if (!no_oblock)\n            skip('}');\n\n    } else if ((flags & DIF_HAVE_ELEM)\n        /* Use i_c_parameter_t, to strip toplevel qualifiers.\n           The source type might have VT_CONSTANT set, which is\n           of course assignable to non-const elements.  */\n            && is_compatible_unqualified_types(type, &vtop->type)) {\n        goto one_elem;\n\n    } else if ((type->t & VT_BTYPE) == VT_STRUCT) {\n        no_oblock = 1;\n        if ((flags & DIF_FIRST) || tok == '{') {\n            skip('{');\n            no_oblock = 0;\n        }\n        s = type->ref;\n        f = s->next;\n        n = s->c;\n        size1 = 1;\n\tgoto do_init_list;\n\n    } else if (tok == '{') {\n        if (flags & DIF_HAVE_ELEM)\n          skip(';');\n        next();\n        decl_initializer(p, type, c, flags & ~DIF_HAVE_ELEM);\n        skip('}');\n\n    } else one_elem: if ((flags & DIF_SIZE_ONLY)) {\n\t/* If we supported only ISO C we wouldn't have to accept calling\n\t   this on anything than an array if DIF_SIZE_ONLY (and even then\n\t   only on the outermost level, so no recursion would be needed),\n\t   because initializing a flex array member isn't supported.\n\t   But GNU C supports it, so we need to recurse even into\n\t   subfields of structs and arrays when DIF_SIZE_ONLY is set.  */\n        /* just skip expression */\n        if (flags & DIF_HAVE_ELEM)\n            vpop();\n        else\n            skip_or_save_block(NULL);\n\n    } else {\n\tif (!(flags & DIF_HAVE_ELEM)) {\n\t    /* This should happen only when we haven't parsed\n\t       the init element above for fear of committing a\n\t       string constant to memory too early.  */\n\t    if (tok != TOK_STR && tok != TOK_LSTR)\n\t      expect(\"string constant\");\n\t    parse_init_elem(!p->sec ? EXPR_ANY : EXPR_CONST);\n\t}\n        if (!p->sec && (flags & DIF_CLEAR) /* container was already zero'd */\n            && (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST\n            && vtop->c.i == 0\n            && btype_size(type->t & VT_BTYPE) /* not for fp constants */\n            )\n            vpop();\n        else\n            init_putv(p, type, c);\n    }\n}\n\n/* parse an initializer for type 't' if 'has_init' is non zero, and\n   allocate space in local or global data space ('r' is either\n   VT_LOCAL or VT_CONST). If 'v' is non zero, then an associated\n   variable 'v' of scope 'scope' is declared before initializers\n   are parsed. If 'v' is zero, then a reference to the new object\n   is put in the value stack. If 'has_init' is 2, a special parsing\n   is done to handle string constants. */\nstatic void decl_initializer_alloc(CType *type, AttributeDef *ad, int r, \n                                   int has_init, int v, int global)\n{\n    int size, align, addr;\n    TokenString *init_str = NULL;\n\n    Section *sec;\n    Sym *flexible_array;\n    Sym *sym;\n    int saved_nocode_wanted = nocode_wanted;\n#ifdef CONFIG_TCC_BCHECK\n    int bcheck = tcc_state->do_bounds_check && !NODATA_WANTED;\n#endif\n    init_params p = {0};\n\n    /* Always allocate static or global variables */\n    if (v && (r & VT_VALMASK) == VT_CONST)\n        nocode_wanted |= DATA_ONLY_WANTED;\n\n    flexible_array = NULL;\n    size = type_size(type, &align);\n\n    /* exactly one flexible array may be initialized, either the\n       toplevel array or the last member of the toplevel struct */\n\n    if (size < 0) {\n        // error out except for top-level incomplete arrays\n        // (arrays of incomplete types are handled in array parsing)\n        if (!(type->t & VT_ARRAY))\n            tcc_error(\"initialization of incomplete type\");\n\n        /* If the base type itself was an array type of unspecified size\n           (like in 'typedef int arr[]; arr x = {1};') then we will\n           overwrite the unknown size by the real one for this decl.\n           We need to unshare the ref symbol holding that size. */\n        type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);\n        p.flex_array_ref = type->ref;\n\n    } else if (has_init && (type->t & VT_BTYPE) == VT_STRUCT) {\n        Sym *field = type->ref->next;\n        if (field) {\n            while (field->next)\n                field = field->next;\n            if (field->type.t & VT_ARRAY && field->type.ref->c < 0) {\n                flexible_array = field;\n                p.flex_array_ref = field->type.ref;\n                size = -1;\n            }\n        }\n    }\n\n    if (size < 0) {\n        /* If unknown size, do a dry-run 1st pass */\n        if (!has_init) \n            tcc_error(\"unknown type size\");\n        if (has_init == 2) {\n            /* only get strings */\n            init_str = tok_str_alloc();\n            while (tok == TOK_STR || tok == TOK_LSTR) {\n                tok_str_add_tok(init_str);\n                next();\n            }\n            tok_str_add(init_str, TOK_EOF);\n        } else\n            skip_or_save_block(&init_str);\n        unget_tok(0);\n\n        /* compute size */\n        begin_macro(init_str, 1);\n        next();\n        decl_initializer(&p, type, 0, DIF_FIRST | DIF_SIZE_ONLY);\n        /* prepare second initializer parsing */\n        macro_ptr = init_str->str;\n        next();\n\n        /* if still unknown size, error */\n        size = type_size(type, &align);\n        if (size < 0) \n            tcc_error(\"unknown type size\");\n\n        /* If there's a flex member and it was used in the initializer\n           adjust size.  */\n        if (flexible_array && flexible_array->type.ref->c > 0)\n            size += flexible_array->type.ref->c\n                    * pointed_size(&flexible_array->type);\n    }\n\n    /* take into account specified alignment if bigger */\n    if (ad->a.aligned) {\n\tint speca = 1 << (ad->a.aligned - 1);\n        if (speca > align)\n            align = speca;\n    } else if (ad->a.packed) {\n        align = 1;\n    }\n\n    if (!v && NODATA_WANTED)\n        size = 0, align = 1;\n\n    if ((r & VT_VALMASK) == VT_LOCAL) {\n        sec = NULL;\n#ifdef CONFIG_TCC_BCHECK\n        if (bcheck && v) {\n            /* add padding between stack variables for bound checking */\n            loc -= align;\n        }\n#endif\n        loc = (loc - size) & -align;\n        addr = loc;\n        p.local_offset = addr + size;\n#ifdef CONFIG_TCC_BCHECK\n        if (bcheck && v) {\n            /* add padding between stack variables for bound checking */\n            loc -= align;\n        }\n#endif\n        if (v) {\n            /* local variable */\n#ifdef CONFIG_TCC_ASM\n\t    if (ad->asm_label) {\n\t\tint reg = asm_parse_regvar(ad->asm_label);\n\t\tif (reg >= 0)\n\t\t    r = (r & ~VT_VALMASK) | reg;\n\t    }\n#endif\n            sym = sym_push(v, type, r, addr);\n\t    if (ad->cleanup_func) {\n\t\tSym *cls = sym_push2(&all_cleanups,\n                    SYM_FIELD | ++cur_scope->cl.n, 0, 0);\n\t\tcls->prev_tok = sym;\n\t\tcls->cleanup_func = ad->cleanup_func;\n\t\tcls->next = cur_scope->cl.s;\n\t\tcur_scope->cl.s = cls;\n\t    }\n\n            sym->a = ad->a;\n        } else {\n            /* push local reference */\n            vset(type, r, addr);\n        }\n    } else {\n\tsym = NULL;\n        if (v && global) {\n            /* see if the symbol was already defined */\n            sym = sym_find(v);\n            if (sym) {\n                if (p.flex_array_ref && (sym->type.t & type->t & VT_ARRAY)\n                    && sym->type.ref->c > type->ref->c) {\n                    /* flex array was already declared with explicit size\n                            extern int arr[10];\n                            int arr[] = { 1,2,3 }; */\n                    type->ref->c = sym->type.ref->c;\n                    size = type_size(type, &align);\n                }\n                patch_storage(sym, ad, type);\n                /* we accept several definitions of the same global variable. */\n                if (!has_init && sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)\n                    goto no_alloc;\n            }\n        }\n\n        /* allocate symbol in corresponding section */\n        sec = ad->section;\n        if (!sec) {\n            CType *tp = type;\n            while ((tp->t & (VT_BTYPE|VT_ARRAY)) == (VT_PTR|VT_ARRAY))\n                tp = &tp->ref->type;\n            if (tp->t & VT_CONSTANT) {\n\t\tsec = rodata_section;\n            } else if (has_init) {\n\t\tsec = data_section;\n                /*if (tcc_state->g_debug & 4)\n                    tcc_warning(\"rw data: %s\", get_tok_str(v, 0));*/\n            } else if (tcc_state->nocommon)\n                sec = bss_section;\n        }\n\n        if (sec) {\n\t    addr = section_add(sec, size, align);\n#ifdef CONFIG_TCC_BCHECK\n            /* add padding if bound check */\n            if (bcheck)\n                section_add(sec, 1, 1);\n#endif\n        } else {\n            addr = align; /* SHN_COMMON is special, symbol value is align */\n\t    sec = common_section;\n        }\n\n        if (v) {\n            if (!sym) {\n                sym = sym_push(v, type, r | VT_SYM, 0);\n                patch_storage(sym, ad, NULL);\n            }\n            /* update symbol definition */\n\t    put_extern_sym(sym, sec, addr, size);\n        } else {\n            /* push global reference */\n            vpush_ref(type, sec, addr, size);\n            sym = vtop->sym;\n\t    vtop->r |= r;\n        }\n\n#ifdef CONFIG_TCC_BCHECK\n        /* handles bounds now because the symbol must be defined\n           before for the relocation */\n        if (bcheck) {\n            addr_t *bounds_ptr;\n\n            greloca(bounds_section, sym, bounds_section->data_offset, R_DATA_PTR, 0);\n            /* then add global bound info */\n            bounds_ptr = section_ptr_add(bounds_section, 2 * sizeof(addr_t));\n            bounds_ptr[0] = 0; /* relocated */\n            bounds_ptr[1] = size;\n        }\n#endif\n    }\n\n    if (type->t & VT_VLA) {\n        int a;\n\n        if (NODATA_WANTED)\n            goto no_alloc;\n\n        /* save before-VLA stack pointer if needed */\n        if (cur_scope->vla.num == 0) {\n            if (cur_scope->prev && cur_scope->prev->vla.num) {\n                cur_scope->vla.locorig = cur_scope->prev->vla.loc;\n            } else {\n                gen_vla_sp_save(loc -= PTR_SIZE);\n                cur_scope->vla.locorig = loc;\n            }\n        }\n\n        vpush_type_size(type, &a);\n        gen_vla_alloc(type, a);\n#if defined TCC_TARGET_PE && defined TCC_TARGET_X86_64\n        /* on _WIN64, because of the function args scratch area, the\n           result of alloca differs from RSP and is returned in RAX.  */\n        gen_vla_result(addr), addr = (loc -= PTR_SIZE);\n#endif\n        gen_vla_sp_save(addr);\n        cur_scope->vla.loc = addr;\n        cur_scope->vla.num++;\n    } else if (has_init) {\n        p.sec = sec;\n        decl_initializer(&p, type, addr, DIF_FIRST);\n        /* patch flexible array member size back to -1, */\n        /* for possible subsequent similar declarations */\n        if (flexible_array)\n            flexible_array->type.ref->c = -1;\n    }\n\n no_alloc:\n    /* restore parse state if needed */\n    if (init_str) {\n        end_macro();\n        next();\n    }\n\n    nocode_wanted = saved_nocode_wanted;\n}\n\n/* generate vla code saved in post_type() */\nstatic void func_vla_arg_code(Sym *arg)\n{\n    int align;\n    TokenString *vla_array_tok = NULL;\n\n    if (arg->type.ref)\n        func_vla_arg_code(arg->type.ref);\n\n    if ((arg->type.t & VT_VLA) && arg->type.ref->vla_array_str) {\n\tloc -= type_size(&int_type, &align);\n\tloc &= -align;\n\targ->type.ref->c = loc;\n\n\tunget_tok(0);\n\tvla_array_tok = tok_str_alloc();\n\tvla_array_tok->str = arg->type.ref->vla_array_str;\n\tbegin_macro(vla_array_tok, 1);\n\tnext();\n\tgexpr();\n\tend_macro();\n\tnext();\n\tvpush_type_size(&arg->type.ref->type, &align);\n\tgen_op('*');\n\tvset(&int_type, VT_LOCAL|VT_LVAL, arg->type.ref->c);\n\tvswap();\n\tvstore();\n\tvpop();\n    }\n}\n\nstatic void func_vla_arg(Sym *sym)\n{\n    Sym *arg;\n\n    for (arg = sym->type.ref->next; arg; arg = arg->next)\n        if ((arg->type.t & VT_BTYPE) == VT_PTR && (arg->type.ref->type.t & VT_VLA))\n            func_vla_arg_code(arg->type.ref);\n}\n\n/* parse a function defined by symbol 'sym' and generate its code in\n   'cur_text_section' */\nstatic void gen_function(Sym *sym)\n{\n    struct scope f = { 0 };\n    cur_scope = root_scope = &f;\n    nocode_wanted = 0;\n\n    ind = cur_text_section->data_offset;\n    if (sym->a.aligned) {\n\tsize_t newoff = section_add(cur_text_section, 0,\n\t\t\t\t    1 << (sym->a.aligned - 1));\n\tgen_fill_nops(newoff - ind);\n    }\n\n    funcname = get_tok_str(sym->v, NULL);\n    func_ind = ind;\n    func_vt = sym->type.ref->type;\n    func_var = sym->type.ref->f.func_type == FUNC_ELLIPSIS;\n\n    /* NOTE: we patch the symbol size later */\n    put_extern_sym(sym, cur_text_section, ind, 0);\n\n    if (sym->type.ref->f.func_ctor)\n        add_array (tcc_state, \".init_array\", sym->c);\n    if (sym->type.ref->f.func_dtor)\n        add_array (tcc_state, \".fini_array\", sym->c);\n\n    /* put debug symbol */\n    tcc_debug_funcstart(tcc_state, sym);\n\n    /* push a dummy symbol to enable local sym storage */\n    sym_push2(&local_stack, SYM_FIELD, 0, 0);\n    local_scope = 1; /* for function parameters */\n    nb_temp_local_vars = 0;\n    gfunc_prolog(sym);\n    tcc_debug_prolog_epilog(tcc_state, 0);\n\n    local_scope = 0;\n    rsym = 0;\n    func_vla_arg(sym);\n    block(0);\n    gsym(rsym);\n\n    nocode_wanted = 0;\n    /* reset local stack */\n    pop_local_syms(NULL, 0);\n    tcc_debug_prolog_epilog(tcc_state, 1);\n    gfunc_epilog();\n\n    /* end of function */\n    tcc_debug_funcend(tcc_state, ind - func_ind);\n\n    /* patch symbol size */\n    elfsym(sym)->st_size = ind - func_ind;\n\n    cur_text_section->data_offset = ind;\n    local_scope = 0;\n    label_pop(&global_label_stack, NULL, 0);\n    sym_pop(&all_cleanups, NULL, 0);\n\n    /* It's better to crash than to generate wrong code */\n    cur_text_section = NULL;\n    funcname = \"\"; /* for safety */\n    func_vt.t = VT_VOID; /* for safety */\n    func_var = 0; /* for safety */\n    ind = 0; /* for safety */\n    func_ind = -1;\n    nocode_wanted = DATA_ONLY_WANTED;\n    check_vstack();\n\n    /* do this after funcend debug info */\n    next();\n}\n\nstatic void gen_inline_functions(TCCState *s)\n{\n    Sym *sym;\n    int inline_generated, i;\n    struct InlineFunc *fn;\n\n    tcc_open_bf(s, \":inline:\", 0);\n    /* iterate while inline function are referenced */\n    do {\n        inline_generated = 0;\n        for (i = 0; i < s->nb_inline_fns; ++i) {\n            fn = s->inline_fns[i];\n            sym = fn->sym;\n            if (sym && (sym->c || !(sym->type.t & VT_INLINE))) {\n                /* the function was used or forced (and then not internal):\n                   generate its code and convert it to a normal function */\n                fn->sym = NULL;\n                tccpp_putfile(fn->filename);\n                begin_macro(fn->func_str, 1);\n                next();\n                cur_text_section = text_section;\n                gen_function(sym);\n                end_macro();\n\n                inline_generated = 1;\n            }\n        }\n    } while (inline_generated);\n    tcc_close();\n}\n\nstatic void free_inline_functions(TCCState *s)\n{\n    int i;\n    /* free tokens of unused inline functions */\n    for (i = 0; i < s->nb_inline_fns; ++i) {\n        struct InlineFunc *fn = s->inline_fns[i];\n        if (fn->sym)\n            tok_str_free(fn->func_str);\n    }\n    dynarray_reset(&s->inline_fns, &s->nb_inline_fns);\n}\n\nstatic void do_Static_assert(void)\n{\n    int c;\n    const char *msg;\n\n    next();\n    skip('(');\n    c = expr_const();\n    msg = \"_Static_assert fail\";\n    if (tok == ',') {\n        next();\n        msg = parse_mult_str(\"string constant\")->data;\n    }\n    skip(')');\n    if (c == 0)\n        tcc_error(\"%s\", msg);\n    skip(';');\n}\n\n/* 'l' is VT_LOCAL or VT_CONST to define default storage type\n   or VT_CMP if parsing old style parameter list\n   or VT_JMP if parsing c99 for decl: for (int i = 0, ...) */\nstatic int decl(int l)\n{\n    int v, has_init, r, oldint;\n    CType type, btype;\n    Sym *sym;\n    AttributeDef ad, adbase;\n    ElfSym *esym;\n\n    while (1) {\n\n        oldint = 0;\n        if (!parse_btype(&btype, &adbase, l == VT_LOCAL)) {\n            if (l == VT_JMP)\n                return 0;\n            /* skip redundant ';' if not in old parameter decl scope */\n            if (tok == ';' && l != VT_CMP) {\n                next();\n                continue;\n            }\n            if (tok == TOK_STATIC_ASSERT) {\n                do_Static_assert();\n                continue;\n            }\n            if (l != VT_CONST)\n                break;\n            if (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3) {\n                /* global asm block */\n                asm_global_instr();\n                continue;\n            }\n            if (tok >= TOK_UIDENT) {\n               /* special test for old K&R protos without explicit int\n                  type. Only accepted when defining global data */\n                btype.t = VT_INT;\n                oldint = 1;\n            } else {\n                if (tok != TOK_EOF)\n                    expect(\"declaration\");\n                break;\n            }\n        }\n\n        if (tok == ';') {\n\t    if ((btype.t & VT_BTYPE) == VT_STRUCT) {\n\t\tv = btype.ref->v;\n\t\tif (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) >= SYM_FIRST_ANOM)\n        \t    tcc_warning(\"unnamed struct/union that defines no instances\");\n                next();\n                continue;\n\t    }\n            if (IS_ENUM(btype.t)) {\n                next();\n                continue;\n            }\n        }\n\n        while (1) { /* iterate thru each declaration */\n            type = btype;\n\t    ad = adbase;\n            type_decl(&type, &ad, &v, TYPE_DIRECT);\n#if 0\n            {\n                char buf[500];\n                type_to_str(buf, sizeof(buf), &type, get_tok_str(v, NULL));\n                printf(\"type = '%s'\\n\", buf);\n            }\n#endif\n            if ((type.t & VT_BTYPE) == VT_FUNC) {\n                if ((type.t & VT_STATIC) && (l != VT_CONST))\n                    tcc_error(\"function without file scope cannot be static\");\n                /* if old style function prototype, we accept a\n                   declaration list */\n                sym = type.ref;\n                if (sym->f.func_type == FUNC_OLD && l == VT_CONST) {\n                    func_vt = type;\n                    decl(VT_CMP);\n                }\n\n                if ((type.t & (VT_EXTERN|VT_INLINE)) == (VT_EXTERN|VT_INLINE)) {\n                    /* always_inline functions must be handled as if they\n                       don't generate multiple global defs, even if extern\n                       inline, i.e. GNU inline semantics for those.  Rewrite\n                       them into static inline.  */\n                    if (tcc_state->gnu89_inline || sym->f.func_alwinl)\n                        type.t = (type.t & ~VT_EXTERN) | VT_STATIC;\n                    else\n                        type.t &= ~VT_INLINE; /* always compile otherwise */\n                }\n\n            } else if (oldint) {\n                tcc_warning(\"type defaults to int\");\n            }\n\n            if (gnu_ext && (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3)) {\n                ad.asm_label = asm_label_instr();\n                /* parse one last attribute list, after asm label */\n                parse_attribute(&ad);\n            #if 0\n                /* gcc does not allow __asm__(\"label\") with function definition,\n                   but why not ... */\n                if (tok == '{')\n                    expect(\";\");\n            #endif\n            }\n\n#ifdef TCC_TARGET_PE\n            if (ad.a.dllimport || ad.a.dllexport) {\n                if (type.t & VT_STATIC)\n                    tcc_error(\"cannot have dll linkage with static\");\n                if (type.t & VT_TYPEDEF) {\n                    tcc_warning(\"'%s' attribute ignored for typedef\",\n                        ad.a.dllimport ? (ad.a.dllimport = 0, \"dllimport\") :\n                        (ad.a.dllexport = 0, \"dllexport\"));\n                } else if (ad.a.dllimport) {\n                    if ((type.t & VT_BTYPE) == VT_FUNC)\n                        ad.a.dllimport = 0;\n                    else\n                        type.t |= VT_EXTERN;\n                }\n            }\n#endif\n            if (tok == '{') {\n                if (l != VT_CONST)\n                    tcc_error(\"cannot use local functions\");\n                if ((type.t & VT_BTYPE) != VT_FUNC)\n                    expect(\"function definition\");\n\n                /* reject abstract declarators in function definition\n                   make old style params without decl have int type */\n                sym = type.ref;\n                while ((sym = sym->next) != NULL) {\n                    if (!(sym->v & ~SYM_FIELD))\n                        expect(\"identifier\");\n                    if (sym->type.t == VT_VOID)\n                        sym->type = int_type;\n                }\n\n                /* apply post-declaraton attributes */\n                merge_funcattr(&type.ref->f, &ad.f);\n\n                /* put function symbol */\n                type.t &= ~VT_EXTERN;\n                sym = external_sym(v, &type, 0, &ad);\n\n                /* static inline functions are just recorded as a kind\n                   of macro. Their code will be emitted at the end of\n                   the compilation unit only if they are used */\n                if (sym->type.t & VT_INLINE) {\n                    struct InlineFunc *fn;\n                    fn = tcc_malloc(sizeof *fn + strlen(file->filename));\n                    strcpy(fn->filename, file->filename);\n                    fn->sym = sym;\n                    dynarray_add(&tcc_state->inline_fns,\n\t\t\t\t &tcc_state->nb_inline_fns, fn);\n                    skip_or_save_block(&fn->func_str);\n                } else {\n                    /* compute text section */\n                    cur_text_section = ad.section;\n                    if (!cur_text_section)\n                        cur_text_section = text_section;\n                    else if (cur_text_section->sh_num > bss_section->sh_num)\n                        cur_text_section->sh_flags = text_section->sh_flags;\n                    gen_function(sym);\n                }\n                break;\n            } else {\n\t\tif (l == VT_CMP) {\n\t\t    /* find parameter in function parameter list */\n\t\t    for (sym = func_vt.ref->next; sym; sym = sym->next)\n\t\t\tif ((sym->v & ~SYM_FIELD) == v)\n\t\t\t    goto found;\n\t\t    tcc_error(\"declaration for parameter '%s' but no such parameter\",\n\t\t\t      get_tok_str(v, NULL));\n                found:\n\t\t    if (type.t & VT_STORAGE) /* 'register' is okay */\n\t\t        tcc_error(\"storage class specified for '%s'\",\n\t\t\t\t  get_tok_str(v, NULL));\n\t\t    if (sym->type.t != VT_VOID)\n\t\t        tcc_error(\"redefinition of parameter '%s'\",\n\t\t\t\t  get_tok_str(v, NULL));\n\t\t    convert_parameter_type(&type);\n\t\t    sym->type = type;\n\t\t} else if (type.t & VT_TYPEDEF) {\n                    /* save typedefed type  */\n                    /* XXX: test storage specifiers ? */\n                    sym = sym_find(v);\n                    if (sym && sym->sym_scope == local_scope) {\n                        if (!is_compatible_types(&sym->type, &type)\n                            || !(sym->type.t & VT_TYPEDEF))\n                            tcc_error(\"incompatible redefinition of '%s'\",\n                                get_tok_str(v, NULL));\n                        sym->type = type;\n                    } else {\n                        sym = sym_push(v, &type, 0, 0);\n                    }\n                    sym->a = ad.a;\n                    if ((type.t & VT_BTYPE) == VT_FUNC)\n                      merge_funcattr(&sym->type.ref->f, &ad.f);\n                    if (debug_modes)\n                        tcc_debug_typedef (tcc_state, sym);\n\t\t} else if ((type.t & VT_BTYPE) == VT_VOID\n\t\t\t   && !(type.t & VT_EXTERN)) {\n\t\t    tcc_error(\"declaration of void object\");\n                } else {\n                    r = 0;\n                    if ((type.t & VT_BTYPE) == VT_FUNC) {\n                        /* external function definition */\n                        /* specific case for func_call attribute */\n                        merge_funcattr(&type.ref->f, &ad.f);\n                    } else if (!(type.t & VT_ARRAY)) {\n                        /* not lvalue if array */\n                        r |= VT_LVAL;\n                    }\n                    has_init = (tok == '=');\n                    if (has_init && (type.t & VT_VLA))\n                        tcc_error(\"variable length array cannot be initialized\");\n\n                    if (((type.t & VT_EXTERN) && (!has_init || l != VT_CONST))\n\t\t        || (type.t & VT_BTYPE) == VT_FUNC\n                        /* as with GCC, uninitialized global arrays with no size\n                           are considered extern: */\n                        || ((type.t & VT_ARRAY) && !has_init\n                            && l == VT_CONST && type.ref->c < 0)\n                        ) {\n                        /* external variable or function */\n                        type.t |= VT_EXTERN;\n                        external_sym(v, &type, r, &ad);\n                    } else {\n                        if (l == VT_CONST || (type.t & VT_STATIC))\n                            r |= VT_CONST;\n                        else\n                            r |= VT_LOCAL;\n                        if (has_init)\n                            next();\n                        else if (l == VT_CONST)\n                            /* uninitialized global variables may be overridden */\n                            type.t |= VT_EXTERN;\n                        decl_initializer_alloc(&type, &ad, r, has_init, v, l == VT_CONST);\n                    }\n\n                    if (ad.alias_target && l == VT_CONST) {\n                        /* Aliases need to be emitted when their target symbol\n                           is emitted, even if perhaps unreferenced.\n                           We only support the case where the base is already\n                           defined, otherwise we would need deferring to emit\n                           the aliases until the end of the compile unit.  */\n                        esym = elfsym(sym_find(ad.alias_target));\n                        if (!esym)\n                            tcc_error(\"unsupported forward __alias__ attribute\");\n                        put_extern_sym2(sym_find(v), esym->st_shndx,\n                                        esym->st_value, esym->st_size, 1);\n                    }\n                }\n                if (tok != ',') {\n                    if (l == VT_JMP)\n                        return 1;\n                    skip(';');\n                    break;\n                }\n                next();\n            }\n        }\n    }\n    return 0;\n}\n\n/* ------------------------------------------------------------------------- */\n#undef gjmp_addr\n#undef gjmp\n/* ------------------------------------------------------------------------- */\n"
        },
        {
          "name": "tcclib.h",
          "type": "blob",
          "size": 2.5498046875,
          "content": "/* Simple libc header for TCC \n * \n * Add any function you want from the libc there. This file is here\n * only for your convenience so that you do not need to put the whole\n * glibc include files on your floppy disk \n */\n#ifndef _TCCLIB_H\n#define _TCCLIB_H\n\n#include <stddef.h>\n#include <stdarg.h>\n\n/* stdlib.h */\nvoid *calloc(size_t nmemb, size_t size);\nvoid *malloc(size_t size);\nvoid free(void *ptr);\nvoid *realloc(void *ptr, size_t size);\nint atoi(const char *nptr);\nlong int strtol(const char *nptr, char **endptr, int base);\nunsigned long int strtoul(const char *nptr, char **endptr, int base);\nvoid exit(int);\n\n/* stdio.h */\ntypedef struct __FILE FILE;\n#define EOF (-1)\nextern FILE *stdin;\nextern FILE *stdout;\nextern FILE *stderr;\nFILE *fopen(const char *path, const char *mode);\nFILE *fdopen(int fildes, const char *mode);\nFILE *freopen(const  char *path, const char *mode, FILE *stream);\nint fclose(FILE *stream);\nsize_t  fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t  fwrite(void *ptr, size_t size, size_t nmemb, FILE *stream);\nint fgetc(FILE *stream);\nchar *fgets(char *s, int size, FILE *stream);\nint getc(FILE *stream);\nint getchar(void);\nchar *gets(char *s);\nint ungetc(int c, FILE *stream);\nint fflush(FILE *stream);\nint putchar (int c);\n\nint printf(const char *format, ...);\nint fprintf(FILE *stream, const char *format, ...);\nint sprintf(char *str, const char *format, ...);\nint snprintf(char *str, size_t size, const  char  *format, ...);\nint asprintf(char **strp, const char *format, ...);\nint dprintf(int fd, const char *format, ...);\nint vprintf(const char *format, va_list ap);\nint vfprintf(FILE  *stream,  const  char *format, va_list ap);\nint vsprintf(char *str, const char *format, va_list ap);\nint vsnprintf(char *str, size_t size, const char  *format, va_list ap);\nint vasprintf(char  **strp,  const  char *format, va_list ap);\nint vdprintf(int fd, const char *format, va_list ap);\n\nvoid perror(const char *s);\n\n/* string.h */\nchar *strcat(char *dest, const char *src);\nchar *strchr(const char *s, int c);\nchar *strrchr(const char *s, int c);\nchar *strcpy(char *dest, const char *src);\nvoid *memcpy(void *dest, const void *src, size_t n);\nvoid *memmove(void *dest, const void *src, size_t n);\nvoid *memset(void *s, int c, size_t n);\nchar *strdup(const char *s);\nsize_t strlen(const char *s);\n\n/* dlfcn.h */\n#define RTLD_LAZY       0x001\n#define RTLD_NOW        0x002\n#define RTLD_GLOBAL     0x100\n\nvoid *dlopen(const char *filename, int flag);\nconst char *dlerror(void);\nvoid *dlsym(void *handle, char *symbol);\nint dlclose(void *handle);\n\n#endif /* _TCCLIB_H */\n"
        },
        {
          "name": "tccmacho.c",
          "type": "blob",
          "size": 90.32421875,
          "content": "/*\n * Mach-O file handling for TCC\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#include \"tcc.h\"\n\n/* In order to make life easy for us we are generating Mach-O files which\n   don't make use of some modern features, but which aren't entirely classic\n   either in that they do use some modern features.  We're also only\n   generating 64bit Mach-O files, and only native endian at that.\n\n   In particular we're generating executables that don't make use of\n   DYLD_INFO for dynamic linking info, as that requires us building a\n   trie of exported names.  We're simply using classic symbol tables which\n   are still supported by modern dyld.\n\n   But we do use LC_MAIN, which is a \"modern\" feature in order to not have\n   to setup our own crt code.  We're not using lazy linking, so even function\n   calls are resolved at startup.  */\n\n#if !defined TCC_TARGET_X86_64 && !defined TCC_TARGET_ARM64\n#error Platform not supported\n#endif\n\n/* XXX: this file uses tcc_error() to the effect of exit(1) */\n#undef _tcc_error\n\n#define DEBUG_MACHO 0\n#define dprintf if (DEBUG_MACHO) printf\n\n#define MH_EXECUTE              (0x2)\n#define MH_DYLDLINK             (0x4)\n#define MH_DYLIB                (0x6)\n#define MH_PIE                  (0x200000)\n\n#define CPU_SUBTYPE_LIB64       (0x80000000)\n#define CPU_SUBTYPE_X86_ALL     (3)\n#define CPU_SUBTYPE_ARM64_ALL   (0)\n\n#define CPU_ARCH_ABI64          (0x01000000)\n\n#define CPU_TYPE_X86            (7)\n#define CPU_TYPE_X86_64         (CPU_TYPE_X86 | CPU_ARCH_ABI64)\n#define CPU_TYPE_ARM            (12)\n#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)\n\nstruct fat_header {\n    uint32_t        magic;          /* FAT_MAGIC or FAT_MAGIC_64 */\n    uint32_t        nfat_arch;      /* number of structs that follow */\n};\n\nstruct fat_arch {\n    int             cputype;        /* cpu specifier (int) */\n    int             cpusubtype;     /* machine specifier (int) */\n    uint32_t        offset;         /* file offset to this object file */\n    uint32_t        size;           /* size of this object file */\n    uint32_t        align;          /* alignment as a power of 2 */\n};\n\n#define FAT_MAGIC       0xcafebabe\n#define FAT_CIGAM       0xbebafeca\n#define FAT_MAGIC_64    0xcafebabf\n#define FAT_CIGAM_64    0xbfbafeca\n\nstruct mach_header {\n    uint32_t        magic;          /* mach magic number identifier */\n    int             cputype;        /* cpu specifier */\n    int             cpusubtype;     /* machine specifier */\n    uint32_t        filetype;       /* type of file */\n    uint32_t        ncmds;          /* number of load commands */\n    uint32_t        sizeofcmds;     /* the size of all the load commands */\n    uint32_t        flags;          /* flags */\n};\n\nstruct mach_header_64 {\n    struct mach_header  mh;\n    uint32_t            reserved;       /* reserved, pad to 64bit */\n};\n\n/* Constant for the magic field of the mach_header (32-bit architectures) */\n#define MH_MAGIC        0xfeedface      /* the mach magic number */\n#define MH_CIGAM        0xcefaedfe      /* NXSwapInt(MH_MAGIC) */\n#define MH_MAGIC_64     0xfeedfacf      /* the 64-bit mach magic number */\n#define MH_CIGAM_64     0xcffaedfe      /* NXSwapInt(MH_MAGIC_64) */\n\nstruct load_command {\n    uint32_t        cmd;            /* type of load command */\n    uint32_t        cmdsize;        /* total size of command in bytes */\n};\n\n#define LC_REQ_DYLD 0x80000000\n#define LC_SYMTAB        0x2\n#define LC_DYSYMTAB      0xb\n#define LC_LOAD_DYLIB    0xc\n#define LC_ID_DYLIB      0xd\n#define LC_LOAD_DYLINKER 0xe\n#define LC_SEGMENT_64    0x19\n#define LC_RPATH (0x1c | LC_REQ_DYLD)\n#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD)\n#define LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)\n#define LC_MAIN (0x28|LC_REQ_DYLD)\n#define LC_SOURCE_VERSION 0x2A\n#define LC_BUILD_VERSION 0x32\n#define LC_DYLD_EXPORTS_TRIE (0x33 | LC_REQ_DYLD)\n#define LC_DYLD_CHAINED_FIXUPS (0x34 | LC_REQ_DYLD)\n\n#define SG_READ_ONLY    0x10 /* This segment is made read-only after fixups */\n\ntypedef int vm_prot_t;\n\nstruct segment_command_64 { /* for 64-bit architectures */\n    uint32_t        cmd;            /* LC_SEGMENT_64 */\n    uint32_t        cmdsize;        /* includes sizeof section_64 structs */\n    char            segname[16];    /* segment name */\n    uint64_t        vmaddr;         /* memory address of this segment */\n    uint64_t        vmsize;         /* memory size of this segment */\n    uint64_t        fileoff;        /* file offset of this segment */\n    uint64_t        filesize;       /* amount to map from the file */\n    vm_prot_t       maxprot;        /* maximum VM protection */\n    vm_prot_t       initprot;       /* initial VM protection */\n    uint32_t        nsects;         /* number of sections in segment */\n    uint32_t        flags;          /* flags */\n};\n\nstruct section_64 { /* for 64-bit architectures */\n    char            sectname[16];   /* name of this section */\n    char            segname[16];    /* segment this section goes in */\n    uint64_t        addr;           /* memory address of this section */\n    uint64_t        size;           /* size in bytes of this section */\n    uint32_t        offset;         /* file offset of this section */\n    uint32_t        align;          /* section alignment (power of 2) */\n    uint32_t        reloff;         /* file offset of relocation entries */\n    uint32_t        nreloc;         /* number of relocation entries */\n    uint32_t        flags;          /* flags (section type and attributes)*/\n    uint32_t        reserved1;      /* reserved (for offset or index) */\n    uint32_t        reserved2;      /* reserved (for count or sizeof) */\n    uint32_t        reserved3;      /* reserved */\n};\n\nenum {\n    DYLD_CHAINED_IMPORT          = 1,\n};\n\nstruct dyld_chained_fixups_header {\n    uint32_t    fixups_version; ///< 0\n    uint32_t    starts_offset;  ///< Offset of dyld_chained_starts_in_image.\n    uint32_t    imports_offset; ///< Offset of imports table in chain_data.\n    uint32_t    symbols_offset; ///< Offset of symbol strings in chain_data.\n    uint32_t    imports_count;  ///< Number of imported symbol names.\n    uint32_t    imports_format; ///< DYLD_CHAINED_IMPORT*\n    uint32_t    symbols_format; ///< 0 => uncompressed, 1 => zlib compressed\n};\n\nstruct dyld_chained_starts_in_image\n{\n    uint32_t    seg_count;\n    uint32_t    seg_info_offset[1];  // each entry is offset into this struct for that segment\n    // followed by pool of dyld_chain_starts_in_segment data\n};\n\nenum {\n    DYLD_CHAINED_PTR_64                     =  2,    // target is vmaddr\n    DYLD_CHAINED_PTR_64_OFFSET              =  6,    // target is vm offset\n};\n\nenum {\n    DYLD_CHAINED_PTR_START_NONE   = 0xFFFF, // used in page_start[] to denote a page with no fixups\n};\n\n#define SEG_PAGE_SIZE 16384\n\nstruct dyld_chained_starts_in_segment\n{\n    uint32_t    size;               // size of this (amount kernel needs to copy)\n    uint16_t    page_size;          // 0x1000 or 0x4000\n    uint16_t    pointer_format;     // DYLD_CHAINED_PTR_*\n    uint64_t    segment_offset;     // offset in memory to start of segment\n    uint32_t    max_valid_pointer;  // for 32-bit OS, any value beyond this is not a pointer\n    uint16_t    page_count;         // how many pages are in array\n    uint16_t    page_start[1];      // each entry is offset in each page of first element in chain\n                                    // or DYLD_CHAINED_PTR_START_NONE if no fixups on page\n};\n\nenum BindSpecialDylib {\n  BIND_SPECIAL_DYLIB_FLAT_LOOKUP = -2,\n};\n\nstruct dyld_chained_import\n{\n    uint32_t    lib_ordinal :  8,\n                weak_import :  1,\n                name_offset : 23;\n};\n\nstruct dyld_chained_ptr_64_rebase\n{\n    uint64_t    target    : 36,    // vmaddr, 64GB max image size\n                high8     :  8,    // top 8 bits set to this after slide added\n                reserved  :  7,    // all zeros\n                next      : 12,    // 4-byte stride\n                bind      :  1;    // == 0\n};\n\nstruct dyld_chained_ptr_64_bind\n{\n    uint64_t    ordinal   : 24,\n                addend    :  8,   // 0 thru 255\n                reserved  : 19,   // all zeros\n                next      : 12,   // 4-byte stride\n                bind      :  1;   // == 1\n};\n\n#define S_REGULAR                       0x0\n#define S_ZEROFILL                      0x1\n#define S_NON_LAZY_SYMBOL_POINTERS      0x6\n#define S_LAZY_SYMBOL_POINTERS          0x7\n#define S_SYMBOL_STUBS                  0x8\n#define S_MOD_INIT_FUNC_POINTERS        0x9\n#define S_MOD_TERM_FUNC_POINTERS        0xa\n\n#define S_ATTR_PURE_INSTRUCTIONS        0x80000000\n#define S_ATTR_SOME_INSTRUCTIONS        0x00000400\n#define S_ATTR_DEBUG             \t0x02000000\n\n\ntypedef uint32_t lc_str;\n\nstruct dylib_command {\n    uint32_t cmd;                   /* LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB,\n                                       LC_REEXPORT_DYLIB */\n    uint32_t cmdsize;               /* includes pathname string */\n    lc_str   name;                  /* library's path name */\n    uint32_t timestamp;             /* library's build time stamp */\n    uint32_t current_version;       /* library's current version number */\n    uint32_t compatibility_version; /* library's compatibility vers number*/\n};\n\nstruct rpath_command {\n    uint32_t     cmd;           /* LC_RPATH */\n    uint32_t     cmdsize;       /* includes string */\n    lc_str       path;          /* path to add to run path */\n};\n\nstruct dylinker_command {\n    uint32_t        cmd;            /* LC_ID_DYLINKER, LC_LOAD_DYLINKER or\n                                       LC_DYLD_ENVIRONMENT */\n    uint32_t        cmdsize;        /* includes pathname string */\n    lc_str          name;           /* dynamic linker's path name */\n};\n\nstruct linkedit_data_command {\n    uint32_t    cmd;            /* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,\n                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,\n                                   LC_DYLIB_CODE_SIGN_DRS,\n                                   LC_LINKER_OPTIMIZATION_HINT,\n                                   LC_DYLD_EXPORTS_TRIE, or\n                                   LC_DYLD_CHAINED_FIXUPS. */\n    uint32_t    cmdsize;        /* sizeof(struct linkedit_data_command) */\n    uint32_t    dataoff;        /* file offset of data in __LINKEDIT segment */\n    uint32_t    datasize;       /* file size of data in __LINKEDIT segment  */\n};\n\n#define PLATFORM_MACOS 1\n\nstruct build_version_command {\n    uint32_t    cmd;            /* LC_BUILD_VERSION */\n    uint32_t    cmdsize;        /* sizeof(struct build_version_command) plus */\n                                /* ntools * sizeof(struct build_tool_version) */\n    uint32_t    platform;       /* platform */\n    uint32_t    minos;          /* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t    sdk;            /* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t    ntools;         /* number of tool entries following this */\n};\n\nstruct source_version_command {\n    uint32_t  cmd;      /* LC_SOURCE_VERSION */\n    uint32_t  cmdsize;  /* 16 */\n    uint64_t  version;  /* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n};\n\nstruct symtab_command {\n    uint32_t        cmd;            /* LC_SYMTAB */\n    uint32_t        cmdsize;        /* sizeof(struct symtab_command) */\n    uint32_t        symoff;         /* symbol table offset */\n    uint32_t        nsyms;          /* number of symbol table entries */\n    uint32_t        stroff;         /* string table offset */\n    uint32_t        strsize;        /* string table size in bytes */\n};\n\nstruct dysymtab_command {\n    uint32_t cmd;       /* LC_DYSYMTAB */\n    uint32_t cmdsize;   /* sizeof(struct dysymtab_command) */\n\n    uint32_t ilocalsym; /* index to local symbols */\n    uint32_t nlocalsym; /* number of local symbols */\n\n    uint32_t iextdefsym;/* index to externally defined symbols */\n    uint32_t nextdefsym;/* number of externally defined symbols */\n\n    uint32_t iundefsym; /* index to undefined symbols */\n    uint32_t nundefsym; /* number of undefined symbols */\n\n    uint32_t tocoff;    /* file offset to table of contents */\n    uint32_t ntoc;      /* number of entries in table of contents */\n\n    uint32_t modtaboff; /* file offset to module table */\n    uint32_t nmodtab;   /* number of module table entries */\n\n    uint32_t extrefsymoff;  /* offset to referenced symbol table */\n    uint32_t nextrefsyms;   /* number of referenced symbol table entries */\n\n    uint32_t indirectsymoff;/* file offset to the indirect symbol table */\n    uint32_t nindirectsyms; /* number of indirect symbol table entries */\n\n    uint32_t extreloff; /* offset to external relocation entries */\n    uint32_t nextrel;   /* number of external relocation entries */\n    uint32_t locreloff; /* offset to local relocation entries */\n    uint32_t nlocrel;   /* number of local relocation entries */\n};\n\n#define BIND_OPCODE_DONE                                        0x00\n#define BIND_OPCODE_SET_DYLIB_SPECIAL_IMM                       0x30\n#define BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM               0x40\n#define BIND_OPCODE_SET_TYPE_IMM                                0x50\n#define BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB                 0x70\n#define BIND_OPCODE_DO_BIND                                     0x90\n\n#define BIND_SYMBOL_FLAGS_WEAK_IMPORT                           0x1\n\n#define BIND_TYPE_POINTER                                       1\n#define BIND_SPECIAL_DYLIB_FLAT_LOOKUP                          -2\n\n#define REBASE_OPCODE_DONE                                      0x00\n#define REBASE_OPCODE_SET_TYPE_IMM                              0x10\n#define REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB               0x20\n#define REBASE_OPCODE_DO_REBASE_IMM_TIMES                       0x50\n\n#define REBASE_TYPE_POINTER                                     1\n\n#define EXPORT_SYMBOL_FLAGS_KIND_REGULAR                        0x00\n#define EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE                       0x02\n#define EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION                     0x04\n\nstruct dyld_info_command {\n    uint32_t cmd;             /* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */\n    uint32_t cmdsize;         /* sizeof(struct dyld_info_command) */\n    uint32_t rebase_off;      /* file offset to rebase info  */\n    uint32_t rebase_size;     /* size of rebase info   */\n    uint32_t bind_off;        /* file offset to binding info   */\n    uint32_t bind_size;       /* size of binding info  */\n    uint32_t weak_bind_off;   /* file offset to weak binding info   */\n    uint32_t weak_bind_size;  /* size of weak binding info  */\n    uint32_t lazy_bind_off;   /* file offset to lazy binding info */\n    uint32_t lazy_bind_size;  /* size of lazy binding infs */\n    uint32_t export_off;      /* file offset to lazy binding info */\n    uint32_t export_size;     /* size of lazy binding infs */\n};\n\n#define INDIRECT_SYMBOL_LOCAL   0x80000000\n\nstruct entry_point_command {\n    uint32_t  cmd;      /* LC_MAIN only used in MH_EXECUTE filetypes */\n    uint32_t  cmdsize;  /* 24 */\n    uint64_t  entryoff; /* file (__TEXT) offset of main() */\n    uint64_t  stacksize;/* if not zero, initial stack size */\n};\n\nenum skind {\n    sk_unknown = 0,\n    sk_discard,\n    sk_text,\n    sk_stubs,\n    sk_stub_helper,\n    sk_ro_data,\n    sk_uw_info,\n    sk_nl_ptr,  // non-lazy pointers, aka GOT\n    sk_debug_info,\n    sk_debug_abbrev,\n    sk_debug_line,\n    sk_debug_aranges,\n    sk_debug_str,\n    sk_debug_line_str,\n    sk_stab,\n    sk_stab_str,\n    sk_la_ptr,  // lazy pointers\n    sk_init,\n    sk_fini,\n    sk_rw_data,\n    sk_bss,\n    sk_linkedit,\n    sk_last\n};\n\nstruct nlist_64 {\n    uint32_t  n_strx;      /* index into the string table */\n    uint8_t n_type;        /* type flag, see below */\n    uint8_t n_sect;        /* section number or NO_SECT */\n    uint16_t n_desc;       /* see <mach-o/stab.h> */\n    uint64_t n_value;      /* value of this symbol (or stab offset) */\n};\n\n#define N_UNDF  0x0\n#define N_ABS   0x2\n#define N_EXT   0x1\n#define N_SECT  0xe\n\n#define N_WEAK_REF      0x0040\n#define N_WEAK_DEF      0x0080\n\nstruct macho {\n    struct mach_header_64 mh;\n    int *seg2lc, nseg;\n    struct load_command **lc;\n    struct entry_point_command *ep;\n    int nlc;\n    struct {\n        Section *s;\n        int machosect;\n    } sk_to_sect[sk_last];\n    int *elfsectomacho;\n    int *e2msym;\n    Section *symtab, *strtab, *indirsyms, *stubs, *exports;\n    uint32_t ilocal, iextdef, iundef;\n    int stubsym, n_got, nr_plt;\n    int segment[sk_last];\n#ifdef CONFIG_NEW_MACHO\n    Section *chained_fixups;\n    int n_bind;\n    int n_bind_rebase;\n    struct bind_rebase {\n\tint section;\n\tint bind;\n\tElfW_Rel rel;\n    } *bind_rebase;\n#else\n    Section *rebase, *binding, *weak_binding, *lazy_binding;\n    Section *stub_helper, *la_symbol_ptr;\n    struct dyld_info_command *dyldinfo;\n    int helpsym, lasym, dyld_private, dyld_stub_binder;\n    int n_lazy_bind;    \n    struct s_lazy_bind {\n        int section;\n        int bind_offset;\n        int la_symbol_offset;\n        ElfW_Rel rel;\n    } *s_lazy_bind;\n    int n_rebase;    \n    struct s_rebase {\n        int section;\n        ElfW_Rel rel;\n    } *s_rebase;\n    int n_bind; \n    struct bind {\n        int section;\n        ElfW_Rel rel;\n    } *bind;\n#endif\n};\n\n#define SHT_LINKEDIT (SHT_LOOS + 42)\n#define SHN_FROMDLL  (SHN_LOOS + 2)  /* Symbol is undefined, comes from a DLL */\n\nstatic void * add_lc(struct macho *mo, uint32_t cmd, uint32_t cmdsize)\n{\n    struct load_command *lc = tcc_mallocz(cmdsize);\n    lc->cmd = cmd;\n    lc->cmdsize = cmdsize;\n    mo->lc = tcc_realloc(mo->lc, sizeof(mo->lc[0]) * (mo->nlc + 1));\n    mo->lc[mo->nlc++] = lc;\n    return lc;\n}\n\nstatic struct segment_command_64 * add_segment(struct macho *mo, const char *name)\n{\n    struct segment_command_64 *sc = add_lc(mo, LC_SEGMENT_64, sizeof(*sc));\n    strncpy(sc->segname, name, 16);\n    mo->seg2lc = tcc_realloc(mo->seg2lc, sizeof(*mo->seg2lc) * (mo->nseg + 1));\n    mo->seg2lc[mo->nseg++] = mo->nlc - 1;\n    return sc;\n}\n\nstatic struct segment_command_64 * get_segment(struct macho *mo, int i)\n{\n    return (struct segment_command_64 *) (mo->lc[mo->seg2lc[i]]);\n}\n\nstatic int add_section(struct macho *mo, struct segment_command_64 **_seg, const char *name)\n{\n    struct segment_command_64 *seg = *_seg;\n    int ret = seg->nsects;\n    struct section_64 *sec;\n    seg->nsects++;\n    seg->cmdsize += sizeof(*sec);\n    seg = tcc_realloc(seg, sizeof(*seg) + seg->nsects * sizeof(*sec));\n    sec = (struct section_64*)((char*)seg + sizeof(*seg)) + ret;\n    memset(sec, 0, sizeof(*sec));\n    strncpy(sec->sectname, name, 16);\n    strncpy(sec->segname, seg->segname, 16);\n    *_seg = seg;\n    return ret;\n}\n\nstatic struct section_64 *get_section(struct segment_command_64 *seg, int i)\n{\n    return (struct section_64*)((char*)seg + sizeof(*seg)) + i;\n}\n\nstatic void * add_dylib(struct macho *mo, char *name)\n{\n    struct dylib_command *lc;\n    int sz = (sizeof(*lc) + strlen(name) + 1 + 7) & -8;\n    lc = add_lc(mo, LC_LOAD_DYLIB, sz);\n    lc->name = sizeof(*lc);\n    strcpy((char*)lc + lc->name, name);\n    lc->timestamp = 2;\n    lc->current_version = 1 << 16;\n    lc->compatibility_version = 1 << 16;\n    return lc;\n}\n\nstatic int uleb128_size (unsigned long long value)\n{\n    int size =  0;\n\n    do {\n        value >>= 7;\n        size++;\n    } while (value != 0);\n    return size;\n}\n\nstatic void write_uleb128(Section *section, uint64_t value)\n{\n    do {\n        unsigned char byte = value & 0x7f;\n\tuint8_t *ptr = section_ptr_add(section, 1);\n\n        value >>= 7;\n        *ptr = byte | (value ? 0x80 : 0);\n    } while (value != 0);\n}\n\nstatic void tcc_macho_add_destructor(TCCState *s1)\n{\n    int init_sym, mh_execute_header, at_exit_sym;\n    Section *s;\n    ElfW_Rel *rel;\n    uint8_t *ptr;\n\n    mh_execute_header = put_elf_sym(s1->symtab, -4096, 0,\n\t\t\t\t    ELFW(ST_INFO)(STB_GLOBAL, STT_OBJECT), 0,\n\t\t\t\t    text_section->sh_num, \"__mh_execute_header\");\n    s = find_section(s1, \".fini_array\");\n    if (s->data_offset == 0)\n        return; \n    init_sym = put_elf_sym(s1->symtab, text_section->data_offset, 0,\n                           ELFW(ST_INFO)(STB_LOCAL, STT_FUNC), 0,\n                           text_section->sh_num, \"___GLOBAL_init_65535\");\n    at_exit_sym = put_elf_sym(s1->symtab, 0, 0,\n                              ELFW(ST_INFO)(STB_GLOBAL, STT_FUNC), 0,\n                              SHN_UNDEF, \"___cxa_atexit\");\n#ifdef TCC_TARGET_X86_64\n    ptr = section_ptr_add(text_section, 4);\n    ptr[0] = 0x55;  // pushq   %rbp\n    ptr[1] = 0x48;  // movq    %rsp, %rbp\n    ptr[2] = 0x89;\n    ptr[3] = 0xe5;\n    for_each_elem(s->reloc, 0, rel, ElfW_Rel) {\n        int sym_index = ELFW(R_SYM)(rel->r_info);\n\n        ptr = section_ptr_add(text_section, 26);\n        ptr[0] = 0x48;  // lea destructor(%rip),%rax\n        ptr[1] = 0x8d;\n        ptr[2] = 0x05;\n        put_elf_reloca(s1->symtab, text_section, \n\t\t       text_section->data_offset - 23,\n\t\t       R_X86_64_PC32, sym_index, -4);\n        ptr[7] = 0x48;  // mov %rax,%rdi\n        ptr[8] = 0x89;\n        ptr[9] = 0xc7;\n\tptr[10] = 0x31; // xorl %ecx, %ecx\n\tptr[11] = 0xc9;\n\tptr[12] = 0x89; // movl %ecx, %esi\n\tptr[13] = 0xce;\n        ptr[14] = 0x48;  // lea mh_execute_header(%rip),%rdx\n        ptr[15] = 0x8d;\n        ptr[16] = 0x15;\n        put_elf_reloca(s1->symtab, text_section,\n\t\t       text_section->data_offset - 9,\n\t\t       R_X86_64_PC32, mh_execute_header, -4);\n\tptr[21] = 0xe8; // call __cxa_atexit\n        put_elf_reloca(s1->symtab, text_section,\n\t\t       text_section->data_offset - 4,\n\t\t       R_X86_64_PLT32, at_exit_sym, -4);\n    }\n    ptr = section_ptr_add(text_section, 2);\n    ptr[0] = 0x5d;  // pop   %rbp\n    ptr[1] = 0xc3;  // ret\n#elif defined TCC_TARGET_ARM64\n    ptr = section_ptr_add(text_section, 8);\n    write32le(ptr, 0xa9bf7bfd);     // stp     x29, x30, [sp, #-16]!\n    write32le(ptr + 4, 0x910003fd); // mov     x29, sp\n    for_each_elem(s->reloc, 0, rel, ElfW_Rel) {\n        int sym_index = ELFW(R_SYM)(rel->r_info);\n\n        ptr = section_ptr_add(text_section, 24);\n        put_elf_reloc(s1->symtab, text_section, \n\t\t      text_section->data_offset - 24,\n\t\t      R_AARCH64_ADR_PREL_PG_HI21, sym_index);\n        write32le(ptr, 0x90000000);      // adrp x0, destructor@page\n        put_elf_reloc(s1->symtab, text_section,\n\t\t      text_section->data_offset - 20,\n\t\t      R_AARCH64_LDST8_ABS_LO12_NC, sym_index);\n        write32le(ptr + 4, 0x91000000);  // add x0,x0,destructor@pageoff\n        write32le(ptr + 8, 0xd2800001);  // mov x1, #0\n        put_elf_reloc(s1->symtab, text_section, \n\t\t      text_section->data_offset - 12,\n\t\t      R_AARCH64_ADR_PREL_PG_HI21, mh_execute_header);\n        write32le(ptr + 12, 0x90000002);      // adrp x2, mh_execute_header@page\n        put_elf_reloc(s1->symtab, text_section,\n\t\t      text_section->data_offset - 8,\n\t\t      R_AARCH64_LDST8_ABS_LO12_NC, mh_execute_header);\n        write32le(ptr + 16, 0x91000042);  // add x2,x2,mh_execute_header@pageoff\n        put_elf_reloc(s1->symtab, text_section,\n\t\t      text_section->data_offset - 4,\n\t\t      R_AARCH64_CALL26, at_exit_sym);\n\twrite32le(ptr + 20, 0x94000000); // bl __cxa_atexit\n    }\n    ptr = section_ptr_add(text_section, 8);\n    write32le(ptr, 0xa8c17bfd);     // ldp     x29, x30, [sp], #16\n    write32le(ptr + 4, 0xd65f03c0); // ret\n#endif\n    s->reloc->data_offset = s->data_offset = 0;\n    s->sh_flags &= ~SHF_ALLOC;\n    add_array (s1, \".init_array\", init_sym);\n}\n\n#ifdef CONFIG_NEW_MACHO\nstatic void bind_rebase_add(struct macho *mo, int bind, int sh_info,\n\t\t\t    ElfW_Rel *rel, struct sym_attr *attr)\n{\n    mo->bind_rebase = tcc_realloc(mo->bind_rebase, (mo->n_bind_rebase + 1) *\n\t\t                  sizeof(struct bind_rebase));\n    mo->bind_rebase[mo->n_bind_rebase].section = sh_info;\n    mo->bind_rebase[mo->n_bind_rebase].bind = bind;\n    mo->bind_rebase[mo->n_bind_rebase].rel = *rel;\n    if (attr)\n        mo->bind_rebase[mo->n_bind_rebase].rel.r_offset = attr->got_offset;\n    mo->n_bind_rebase++;\n    mo->n_bind += bind;\n}\n\nstatic void check_relocs(TCCState *s1, struct macho *mo)\n{\n    Section *s;\n    ElfW_Rel *rel, save_rel;\n    ElfW(Sym) *sym;\n    int i, j, type, gotplt_entry, sym_index, for_code;\n    uint32_t *pi, *goti;\n    struct sym_attr *attr;\n\n    goti = NULL;\n    mo->nr_plt = mo->n_got = 0;\n    for (i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_RELX ||\n\t    !strncmp(s1->sections[s->sh_info]->name, \".debug_\", 7))\n            continue;\n        for_each_elem(s, 0, rel, ElfW_Rel) {\n\t    save_rel = *rel;\n            type = ELFW(R_TYPE)(rel->r_info);\n            gotplt_entry = gotplt_entry_type(type);\n            for_code = code_reloc(type);\n            /* We generate a non-lazy pointer for used undefined symbols\n               and for defined symbols that must have a place for their\n               address due to codegen (i.e. a reloc requiring a got slot).  */\n            sym_index = ELFW(R_SYM)(rel->r_info);\n            sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n            if (sym->st_shndx == SHN_UNDEF\n                || gotplt_entry == ALWAYS_GOTPLT_ENTRY) {\n                attr = get_sym_attr(s1, sym_index, 1);\n                if (!attr->dyn_index) {\n                    attr->got_offset = s1->got->data_offset;\n                    attr->plt_offset = -1;\n                    attr->dyn_index = 1; /* used as flag */\n                    section_ptr_add(s1->got, PTR_SIZE);\n                    put_elf_reloc(s1->symtab, s1->got, attr->got_offset,\n                                  R_JMP_SLOT, sym_index);\n\t \t    goti = tcc_realloc(goti, (mo->n_got + 1) * sizeof(*goti));\n                    if (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL) {\n                        if (sym->st_shndx == SHN_UNDEF)\n                          tcc_error(\"undefined local symbo: '%s'\",\n\t\t\t\t    (char *) symtab_section->link->data + sym->st_name);\n\t\t\tgoti[mo->n_got++] = INDIRECT_SYMBOL_LOCAL;\n                    } else {\n                        goti[mo->n_got++] = mo->e2msym[sym_index];\n                        if (sym->st_shndx == SHN_UNDEF\n#ifdef TCC_TARGET_X86_64\n                            && type == R_X86_64_GOTPCREL\n#elif defined TCC_TARGET_ARM64\n                            && type == R_AARCH64_ADR_GOT_PAGE\n#endif\n                            ) {\n\t\t\t    attr->plt_offset = -mo->n_bind_rebase - 2;\n\t\t\t    bind_rebase_add(mo, 1, s1->got->reloc->sh_info, &save_rel, attr);\n\t\t\t    s1->got->reloc->data_offset -= sizeof (ElfW_Rel);\n\t\t\t}\n\t\t        if (for_code && sym->st_shndx == SHN_UNDEF)\n\t\t\t    s1->got->reloc->data_offset -= sizeof (ElfW_Rel);\n\t\t    }\n                }\n                if (for_code && sym->st_shndx == SHN_UNDEF) {\n\t\t    if ((int)attr->plt_offset < -1) {\n\t\t\t/* remove above bind and replace with plt */\n\t\t\tmo->bind_rebase[-attr->plt_offset - 2].bind = 2;\n\t\t\tattr->plt_offset = -1;\n\t\t    }\n                    if (attr->plt_offset == -1) {\n                        uint8_t *jmp;\n\n                        attr->plt_offset = mo->stubs->data_offset;\n#ifdef TCC_TARGET_X86_64\n                        if (type != R_X86_64_PLT32)\n                             continue;\n                        jmp = section_ptr_add(mo->stubs, 6);\n                        jmp[0] = 0xff;  /* jmpq *ofs(%rip) */\n                        jmp[1] = 0x25;\n                        put_elf_reloc(s1->symtab, mo->stubs,\n                                      attr->plt_offset + 2,\n                                      R_X86_64_GOTPCREL, sym_index);\n#elif defined TCC_TARGET_ARM64\n                        if (type != R_AARCH64_CALL26)\n                             continue;\n                        jmp = section_ptr_add(mo->stubs, 12);\n                        put_elf_reloc(s1->symtab, mo->stubs,\n                                      attr->plt_offset,\n                                      R_AARCH64_ADR_GOT_PAGE, sym_index);\n                        write32le(jmp, // adrp x16, #sym\n                                  0x90000010);\n                        put_elf_reloc(s1->symtab, mo->stubs,\n                                      attr->plt_offset + 4,\n                                      R_AARCH64_LD64_GOT_LO12_NC, sym_index);\n                        write32le(jmp + 4, // ld x16,[x16, #sym]\n                                  0xf9400210);\n                        write32le(jmp + 8, // br x16\n                                  0xd61f0200);\n#endif\n\t\t\tbind_rebase_add(mo, 1, s1->got->reloc->sh_info, &save_rel, attr);\n                        pi = section_ptr_add(mo->indirsyms, sizeof(*pi));\n                        *pi = mo->e2msym[sym_index];\n                        mo->nr_plt++;\n                    }\n                    rel->r_info = ELFW(R_INFO)(mo->stubsym, type);\n                    rel->r_addend += attr->plt_offset;\n                }\n            }\n\t    if (type == R_DATA_PTR || type == R_JMP_SLOT)\n\t\tbind_rebase_add(mo, sym->st_shndx == SHN_UNDEF ? 1 : 0,\n\t\t\t\ts->sh_info, &save_rel, NULL);\n        }\n    }\n    /* remove deleted binds */\n    for (i = 0, j = 0; i < mo->n_bind_rebase; i++)\n\tif (mo->bind_rebase[i].bind == 2)\n\t    mo->n_bind--;\n\telse\n\t    mo->bind_rebase[j++] = mo->bind_rebase[i];\n    mo->n_bind_rebase = j;\n    pi = section_ptr_add(mo->indirsyms, mo->n_got * sizeof(*pi));\n    memcpy(pi, goti, mo->n_got * sizeof(*pi));\n    tcc_free(goti);\n}\n\n#else\n\nstatic void check_relocs(TCCState *s1, struct macho *mo)\n{\n    uint8_t *jmp;\n    Section *s;\n    ElfW_Rel *rel, save_rel;\n    ElfW(Sym) *sym;\n    int i, type, gotplt_entry, sym_index, for_code;\n    int bind_offset, la_symbol_offset;\n    uint32_t *pi, *goti;\n    struct sym_attr *attr;\n\n#ifdef TCC_TARGET_X86_64\n    jmp = section_ptr_add(mo->stub_helper, 16);\n    jmp[0] = 0x4c;  /* leaq _dyld_private(%rip), %r11 */\n    jmp[1] = 0x8d;\n    jmp[2] = 0x1d;\n    put_elf_reloca(s1->symtab, mo->stub_helper, 3,\n\t\t   R_X86_64_PC32, mo->dyld_private, -4);\n    jmp[7] = 0x41;  /* pushq %r11 */\n    jmp[8] = 0x53;\n    jmp[9] = 0xff;  /* jmpq    *dyld_stub_binder@GOT(%rip) */\n    jmp[10] = 0x25;\n    put_elf_reloca(s1->symtab, mo->stub_helper, 11,\n\t\t   R_X86_64_GOTPCREL, mo->dyld_stub_binder, -4);\n    jmp[15] = 0x90; /* nop */\n#elif defined TCC_TARGET_ARM64\n    jmp = section_ptr_add(mo->stub_helper, 24);\n    put_elf_reloc(s1->symtab, mo->stub_helper, 0,\n\t\t  R_AARCH64_ADR_PREL_PG_HI21, mo->dyld_private);\n    write32le(jmp, 0x90000011); // adrp x17, _dyld_private@page\n    put_elf_reloc(s1->symtab, mo->stub_helper, 4,\n\t\t  R_AARCH64_LDST64_ABS_LO12_NC, mo->dyld_private);\n    write32le(jmp + 4, 0x91000231); // add x17,x17,_dyld_private@pageoff\n    write32le(jmp + 8, 0xa9bf47f0); // stp x16/x17, [sp, #-16]!\n    put_elf_reloc(s1->symtab, mo->stub_helper, 12,\n\t\t  R_AARCH64_ADR_GOT_PAGE, mo->dyld_stub_binder);\n    write32le(jmp + 12, 0x90000010); // adrp x16, dyld_stub_binder@page\n    put_elf_reloc(s1->symtab, mo->stub_helper, 16,\n\t\t  R_AARCH64_LD64_GOT_LO12_NC, mo->dyld_stub_binder);\n    write32le(jmp + 16, 0xf9400210); // ldr x16,[x16,dyld_stub_binder@pageoff]\n    write32le(jmp + 20, 0xd61f0200); // br x16\n#endif\n    \n    goti = NULL;\n    mo->nr_plt = mo->n_got = 0;\n    for (i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_RELX ||\n\t    !strncmp(s1->sections[s->sh_info]->name, \".debug_\", 7))\n            continue;\n        for_each_elem(s, 0, rel, ElfW_Rel) {\n\t    save_rel = *rel;\n            type = ELFW(R_TYPE)(rel->r_info);\n            gotplt_entry = gotplt_entry_type(type);\n            for_code = code_reloc(type);\n            /* We generate a non-lazy pointer for used undefined symbols\n               and for defined symbols that must have a place for their\n               address due to codegen (i.e. a reloc requiring a got slot).  */\n            sym_index = ELFW(R_SYM)(rel->r_info);\n            sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n            if (sym->st_shndx == SHN_UNDEF\n                || gotplt_entry == ALWAYS_GOTPLT_ENTRY) {\n                attr = get_sym_attr(s1, sym_index, 1);\n                if (!attr->dyn_index) {\n                    attr->got_offset = s1->got->data_offset;\n                    attr->plt_offset = -1;\n                    attr->dyn_index = 1; /* used as flag */\n\t\t    section_ptr_add(s1->got, PTR_SIZE);\n                    put_elf_reloc(s1->symtab, s1->got, attr->got_offset,\n                                  R_JMP_SLOT, sym_index);\n\t\t    goti = tcc_realloc(goti, (mo->n_got + 1) * sizeof(*goti));\n                    if (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL) {\n                        if (sym->st_shndx == SHN_UNDEF)\n                          tcc_error(\"undefined local symbo: '%s'\",\n\t\t\t\t    (char *) symtab_section->link->data + sym->st_name);\n\t\t\tgoti[mo->n_got++] = INDIRECT_SYMBOL_LOCAL;\n                    } else {\n\t\t\tgoti[mo->n_got++] = mo->e2msym[sym_index];\n\t\t\tif (sym->st_shndx == SHN_UNDEF\n#ifdef TCC_TARGET_X86_64\n\t\t\t    && type == R_X86_64_GOTPCREL\n#elif defined TCC_TARGET_ARM64\n\t\t\t    && type == R_AARCH64_ADR_GOT_PAGE\n#endif\n\t\t\t    ) {\n\t\t\t    mo->bind =\n\t\t\t        tcc_realloc(mo->bind,\n\t\t\t\t\t    (mo->n_bind + 1) *\n\t\t\t\t\t    sizeof(struct bind));\n\t\t\t    mo->bind[mo->n_bind].section = s1->got->reloc->sh_info;\n\t\t\t    mo->bind[mo->n_bind].rel = save_rel;\n                            mo->bind[mo->n_bind].rel.r_offset = attr->got_offset;\n\t\t\t    mo->n_bind++;\n\t\t\t    s1->got->reloc->data_offset -= sizeof (ElfW_Rel);\n\t\t\t}\n\t\t    }\n                }\n                if (for_code && sym->st_shndx == SHN_UNDEF) {\n                    if (attr->plt_offset == -1) {\n                        attr->plt_offset = mo->stubs->data_offset;\n#ifdef TCC_TARGET_X86_64\n\t\t\tif (type != R_X86_64_PLT32)\n\t\t\t     continue;\n\t\t\t/* __stubs */\n                        jmp = section_ptr_add(mo->stubs, 6);\n                        jmp[0] = 0xff;  /* jmpq *__la_symbol_ptr(%rip) */\n                        jmp[1] = 0x25;\n                        put_elf_reloca(s1->symtab, mo->stubs,\n                                       mo->stubs->data_offset - 4,\n                                       R_X86_64_PC32, mo->lasym,\n\t\t\t\t       mo->la_symbol_ptr->data_offset - 4);\n\n\t\t\t/* __stub_helper */\n\t\t\tbind_offset = mo->stub_helper->data_offset + 1;\n                        jmp = section_ptr_add(mo->stub_helper, 10);\n                        jmp[0] = 0x68;  /* pushq $bind_offset */\n                        jmp[5] = 0xe9;  /* jmpq __stub_helper */\n                        write32le(jmp + 6, -mo->stub_helper->data_offset);\n\n\t\t\t/* __la_symbol_ptr */\n\t\t\tla_symbol_offset = mo->la_symbol_ptr->data_offset;\n                        put_elf_reloca(s1->symtab, mo->la_symbol_ptr,\n\t\t\t\t       mo->la_symbol_ptr->data_offset,\n\t\t\t\t       R_DATA_PTR, mo->helpsym,\n\t\t\t\t       mo->stub_helper->data_offset - 10);\n\t\t\tsection_ptr_add(mo->la_symbol_ptr, PTR_SIZE);\n#elif defined TCC_TARGET_ARM64\n\t\t\tif (type != R_AARCH64_CALL26)\n\t\t\t     continue;\n\t\t\t/* __stubs */\n                        jmp = section_ptr_add(mo->stubs, 12);\n                        put_elf_reloca(s1->symtab, mo->stubs,\n                                       mo->stubs->data_offset - 12,\n                                       R_AARCH64_ADR_PREL_PG_HI21, mo->lasym,\n\t\t\t\t       mo->la_symbol_ptr->data_offset);\n                        write32le(jmp, // adrp x16, __la_symbol_ptr@page\n                                  0x90000010);\n                        put_elf_reloca(s1->symtab, mo->stubs,\n                                       mo->stubs->data_offset - 8,\n                                       R_AARCH64_LDST64_ABS_LO12_NC, mo->lasym,\n\t\t\t\t       mo->la_symbol_ptr->data_offset);\n                        write32le(jmp + 4, // ldr x16,[x16, __la_symbol_ptr@pageoff]\n                                  0xf9400210);\n                        write32le(jmp + 8, // br x16\n                                  0xd61f0200);\n\n\t\t\t/* __stub_helper */\n\t\t\tbind_offset = mo->stub_helper->data_offset + 8;\n                        jmp = section_ptr_add(mo->stub_helper, 12);\n                        write32le(jmp + 0, // ldr  w16, l0\n                                  0x18000050);\n                        write32le(jmp + 4, // b stubHelperHeader\n                                  0x14000000 +\n\t\t\t\t  ((-(mo->stub_helper->data_offset - 8) / 4) &\n\t\t\t\t   0x3ffffff));\n                        write32le(jmp + 8, 0); // l0: .long bind_offset\n\n\t\t\t/* __la_symbol_ptr */\n\t\t\tla_symbol_offset = mo->la_symbol_ptr->data_offset;\n                        put_elf_reloca(s1->symtab, mo->la_symbol_ptr,\n\t\t\t\t       mo->la_symbol_ptr->data_offset,\n\t\t\t\t       R_DATA_PTR, mo->helpsym,\n\t\t\t\t       mo->stub_helper->data_offset - 12);\n\t\t\tsection_ptr_add(mo->la_symbol_ptr, PTR_SIZE);\n#endif\n                        mo->s_lazy_bind =\n                            tcc_realloc(mo->s_lazy_bind, (mo->n_lazy_bind + 1) *\n                                        sizeof(struct s_lazy_bind));\n                        mo->s_lazy_bind[mo->n_lazy_bind].section =\n                            mo->stub_helper->reloc->sh_info;\n                        mo->s_lazy_bind[mo->n_lazy_bind].bind_offset =\n\t\t\t    bind_offset;\n                        mo->s_lazy_bind[mo->n_lazy_bind].la_symbol_offset =\n\t\t\t    la_symbol_offset;\n                        mo->s_lazy_bind[mo->n_lazy_bind].rel = save_rel;\n                        mo->s_lazy_bind[mo->n_lazy_bind].rel.r_offset =\n                            attr->plt_offset;\n                        mo->n_lazy_bind++;\n\t\t\tpi = section_ptr_add(mo->indirsyms, sizeof(*pi));\n\t\t\t*pi = mo->e2msym[sym_index];\n\t\t\tmo->nr_plt++;\n                    }\n                    rel->r_info = ELFW(R_INFO)(mo->stubsym, type);\n                    rel->r_addend += attr->plt_offset;\n                }\n            }\n            if (type == R_DATA_PTR || type == R_JMP_SLOT) {\n\t\tif (sym->st_shndx == SHN_UNDEF) {\n\t\t    mo->bind = tcc_realloc(mo->bind,\n\t\t\t\t\t   (mo->n_bind + 1) *\n\t\t\t\t\t   sizeof(struct bind));\n\t\t    mo->bind[mo->n_bind].section = s->sh_info;\n\t\t    mo->bind[mo->n_bind].rel = save_rel;\n\t\t    mo->n_bind++;\n\t\t}\n\t\telse {\n                    mo->s_rebase =\n                        tcc_realloc(mo->s_rebase, (mo->n_rebase + 1) *\n\t\t\t\t    sizeof(struct s_rebase));\n                    mo->s_rebase[mo->n_rebase].section = s->sh_info;\n                    mo->s_rebase[mo->n_rebase].rel = save_rel;\n                    mo->n_rebase++;\n\t\t}\n\t    }\n        }\n    }\n    pi = section_ptr_add(mo->indirsyms, mo->n_got * sizeof(*pi));\n    memcpy(pi, goti, mo->n_got * sizeof(*pi));\n    pi = section_ptr_add(mo->indirsyms, mo->nr_plt * sizeof(*pi));\n    memcpy(pi, mo->indirsyms->data, mo->nr_plt * sizeof(*pi));\n    tcc_free(goti);\n}\n#endif\n\nstatic int check_symbols(TCCState *s1, struct macho *mo)\n{\n    int sym_index, sym_end;\n    int ret = 0;\n\n    mo->ilocal = mo->iextdef = mo->iundef = -1;\n    sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));\n    for (sym_index = 1; sym_index < sym_end; ++sym_index) {\n        int elf_index = ((struct nlist_64 *)mo->symtab->data + sym_index - 1)->n_value;\n        ElfW(Sym) *sym = (ElfW(Sym) *)symtab_section->data + elf_index;\n        const char *name = (char*)symtab_section->link->data + sym->st_name;\n        unsigned type = ELFW(ST_TYPE)(sym->st_info);\n        unsigned bind = ELFW(ST_BIND)(sym->st_info);\n        unsigned vis  = ELFW(ST_VISIBILITY)(sym->st_other);\n\n        dprintf(\"%4d (%4d): %09lx %4d %4d %4d %3d %s\\n\",\n                sym_index, elf_index, (long)sym->st_value,\n                type, bind, vis, sym->st_shndx, name);\n        if (bind == STB_LOCAL) {\n            if (mo->ilocal == -1)\n              mo->ilocal = sym_index - 1;\n            if (mo->iextdef != -1 || mo->iundef != -1)\n              tcc_error(\"local syms after global ones\");\n        } else if (sym->st_shndx != SHN_UNDEF) {\n            if (mo->iextdef == -1)\n              mo->iextdef = sym_index - 1;\n            if (mo->iundef != -1)\n              tcc_error(\"external defined symbol after undefined\");\n        } else if (sym->st_shndx == SHN_UNDEF) {\n            if (mo->iundef == -1)\n              mo->iundef = sym_index - 1;\n            if (ELFW(ST_BIND)(sym->st_info) == STB_WEAK\n\t\t|| s1->output_type != TCC_OUTPUT_EXE\n                || find_elf_sym(s1->dynsymtab_section, name)) {\n                /* Mark the symbol as coming from a dylib so that\n                   relocate_syms doesn't complain.  Normally bind_exe_dynsyms\n                   would do this check, and place the symbol into dynsym\n                   which is checked by relocate_syms.  But Mach-O doesn't use\n                   bind_exe_dynsyms.  */\n                sym->st_shndx = SHN_FROMDLL;\n                continue;\n            }\n            tcc_error_noabort(\"undefined symbol '%s'\", name);\n            ret = -1;\n        }\n    }\n    return ret;\n}\n\nstatic void convert_symbol(TCCState *s1, struct macho *mo, struct nlist_64 *pn)\n{\n    struct nlist_64 n = *pn;\n    ElfSym *sym = (ElfW(Sym) *)symtab_section->data + pn->n_value;\n    const char *name = (char*)symtab_section->link->data + sym->st_name;\n    switch(ELFW(ST_TYPE)(sym->st_info)) {\n    case STT_NOTYPE:\n    case STT_OBJECT:\n    case STT_FUNC:\n    case STT_SECTION:\n        n.n_type = N_SECT;\n        break;\n    case STT_FILE:\n        n.n_type = N_ABS;\n        break;\n    default:\n        tcc_error(\"unhandled ELF symbol type %d %s\",\n                  ELFW(ST_TYPE)(sym->st_info), name);\n    }\n    if (sym->st_shndx == SHN_UNDEF)\n      tcc_error(\"should have been rewritten to SHN_FROMDLL: %s\", name);\n    else if (sym->st_shndx == SHN_FROMDLL)\n      n.n_type = N_UNDF, n.n_sect = 0;\n    else if (sym->st_shndx == SHN_ABS)\n      n.n_type = N_ABS, n.n_sect = 0;\n    else if (sym->st_shndx >= SHN_LORESERVE)\n      tcc_error(\"unhandled ELF symbol section %d %s\", sym->st_shndx, name);\n    else if (!mo->elfsectomacho[sym->st_shndx]) {\n      if (strncmp(s1->sections[sym->st_shndx]->name, \".debug_\", 7))\n        tcc_error(\"ELF section %d(%s) not mapped into Mach-O for symbol %s\",\n                  sym->st_shndx, s1->sections[sym->st_shndx]->name, name);\n    }\n    else\n      n.n_sect = mo->elfsectomacho[sym->st_shndx];\n    if (ELFW(ST_BIND)(sym->st_info) == STB_GLOBAL)\n      n.n_type |=  N_EXT;\n    else if (ELFW(ST_BIND)(sym->st_info) == STB_WEAK)\n      n.n_desc |= N_WEAK_REF | (n.n_type != N_UNDF ? N_WEAK_DEF : 0);\n    n.n_strx = pn->n_strx;\n    n.n_value = sym->st_value;\n    *pn = n;\n}\n\nstatic void convert_symbols(TCCState *s1, struct macho *mo)\n{\n    struct nlist_64 *pn;\n    for_each_elem(mo->symtab, 0, pn, struct nlist_64)\n        convert_symbol(s1, mo, pn);\n}\n\nstatic int machosymcmp(const void *_a, const void *_b, void *arg)\n{\n    TCCState *s1 = arg;\n    int ea = ((struct nlist_64 *)_a)->n_value;\n    int eb = ((struct nlist_64 *)_b)->n_value;\n    ElfSym *sa = (ElfSym *)symtab_section->data + ea;\n    ElfSym *sb = (ElfSym *)symtab_section->data + eb;\n    int r;\n    /* locals, then defined externals, then undefined externals, the\n       last two sections also by name, otherwise stable sort */\n    r = (ELFW(ST_BIND)(sb->st_info) == STB_LOCAL)\n        - (ELFW(ST_BIND)(sa->st_info) == STB_LOCAL);\n    if (r)\n      return r;\n    r = (sa->st_shndx == SHN_UNDEF) - (sb->st_shndx == SHN_UNDEF);\n    if (r)\n      return r;\n    if (ELFW(ST_BIND)(sa->st_info) != STB_LOCAL) {\n        const char * na = (char*)symtab_section->link->data + sa->st_name;\n        const char * nb = (char*)symtab_section->link->data + sb->st_name;\n        r = strcmp(na, nb);\n        if (r)\n          return r;\n    }\n    return ea - eb;\n}\n\n/* cannot use qsort because code has to be reentrant */\nstatic void tcc_qsort (void  *base, size_t nel, size_t width,\n                       int (*comp)(const void *, const void *, void *), void *arg)\n{\n    size_t wnel, gap, wgap, i, j, k;\n    char *a, *b, tmp;\n\n    wnel = width * nel;\n    for (gap = 0; ++gap < nel;)\n        gap *= 3;\n    while ( gap /= 3 ) {\n        wgap = width * gap;\n        for (i = wgap; i < wnel; i += width) {\n            for (j = i - wgap; ;j -= wgap) {\n                a = j + (char *)base;\n                b = a + wgap;\n                if ( (*comp)(a, b, arg) <= 0 )\n                    break;\n                k = width;\n                do {\n                    tmp = *a;\n                    *a++ = *b;\n                    *b++ = tmp;\n                } while ( --k );\n                if (j < wgap)\n                    break;\n            }\n        }\n    }\n}\n\nstatic void create_symtab(TCCState *s1, struct macho *mo)\n{\n    int sym_index, sym_end;\n    struct nlist_64 *pn;\n\n    /* Stub creation belongs to check_relocs, but we need to create\n       the symbol now, so its included in the sorting.  */\n    mo->stubs = new_section(s1, \"__stubs\", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);\n    s1->got = new_section(s1, \".got\", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);\n    mo->stubsym = put_elf_sym(s1->symtab, 0, 0,\n                              ELFW(ST_INFO)(STB_LOCAL, STT_SECTION), 0,\n                              mo->stubs->sh_num, \".__stubs\");\n#ifdef CONFIG_NEW_MACHO\n    mo->chained_fixups = new_section(s1, \"CHAINED_FIXUPS\",\n\t\t\t\t     SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n#else\n    mo->stub_helper = new_section(s1, \"__stub_helper\", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);\n    mo->la_symbol_ptr = new_section(s1, \"__la_symbol_ptr\", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);\n    mo->helpsym = put_elf_sym(s1->symtab, 0, 0,\n                              ELFW(ST_INFO)(STB_LOCAL, STT_SECTION), 0,\n                              mo->stub_helper->sh_num, \".__stub_helper\");\n    mo->lasym = put_elf_sym(s1->symtab, 0, 0,\n                            ELFW(ST_INFO)(STB_LOCAL, STT_SECTION), 0,\n                            mo->la_symbol_ptr->sh_num, \".__la_symbol_ptr\");\n    section_ptr_add(data_section, -data_section->data_offset & (PTR_SIZE - 1));\n    mo->dyld_private = put_elf_sym(s1->symtab, data_section->data_offset, PTR_SIZE,\n                                   ELFW(ST_INFO)(STB_LOCAL, STT_OBJECT), 0,\n                                   data_section->sh_num, \".__dyld_private\");\n    section_ptr_add(data_section, PTR_SIZE);\n    mo->dyld_stub_binder = put_elf_sym(s1->symtab, 0, 0,\n                \t\t       ELFW(ST_INFO)(STB_GLOBAL, STT_OBJECT), 0,\n\t\t\t\t       SHN_UNDEF, \"dyld_stub_binder\");\n    mo->rebase = new_section(s1, \"REBASE\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n    mo->binding = new_section(s1, \"BINDING\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n    mo->weak_binding = new_section(s1, \"WEAK_BINDING\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n    mo->lazy_binding = new_section(s1, \"LAZY_BINDING\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n#endif\n    mo->exports = new_section(s1, \"EXPORT\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n    mo->indirsyms = new_section(s1, \"LEINDIR\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n\n    mo->symtab = new_section(s1, \"LESYMTAB\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n    mo->strtab = new_section(s1, \"LESTRTAB\", SHT_LINKEDIT, SHF_ALLOC | SHF_WRITE);\n    put_elf_str(mo->strtab, \" \"); /* Mach-O starts strtab with a space */\n    sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));\n    pn = section_ptr_add(mo->symtab, sizeof(*pn) * (sym_end - 1));\n    for (sym_index = 1; sym_index < sym_end; ++sym_index) {\n        ElfW(Sym) *sym = (ElfW(Sym) *)symtab_section->data + sym_index;\n        const char *name = (char*)symtab_section->link->data + sym->st_name;\n        pn[sym_index - 1].n_strx = put_elf_str(mo->strtab, name);\n        pn[sym_index - 1].n_value = sym_index;\n    }\n    section_ptr_add(mo->strtab, -mo->strtab->data_offset & (PTR_SIZE - 1));\n    tcc_qsort(pn, sym_end - 1, sizeof(*pn), machosymcmp, s1);\n    mo->e2msym = tcc_malloc(sym_end * sizeof(*mo->e2msym));\n    mo->e2msym[0] = -1;\n    for (sym_index = 1; sym_index < sym_end; ++sym_index) {\n        mo->e2msym[pn[sym_index - 1].n_value] = sym_index - 1;\n    }\n}\n\nconst struct {\n    int seg_initial;\n    uint32_t flags;\n    const char *name;\n} skinfo[sk_last] = {\n    /*[sk_unknown] =*/        { 0 },\n    /*[sk_discard] =*/        { 0 },\n    /*[sk_text] =*/           { 1, S_REGULAR | S_ATTR_PURE_INSTRUCTIONS\n                                   | S_ATTR_SOME_INSTRUCTIONS, \"__text\" },\n    /*[sk_stubs] =*/          { 1, S_REGULAR | S_ATTR_PURE_INSTRUCTIONS | S_SYMBOL_STUBS\n                                   | S_ATTR_SOME_INSTRUCTIONS , \"__stubs\" },\n    /*[sk_stub_helper] =*/    { 1, S_REGULAR | S_ATTR_PURE_INSTRUCTIONS\n                                   | S_ATTR_SOME_INSTRUCTIONS , \"__stub_helper\" },\n    /*[sk_ro_data] =*/        { 2, S_REGULAR, \"__rodata\" },\n    /*[sk_uw_info] =*/        { 0 },\n    /*[sk_nl_ptr] =*/         { 2, S_NON_LAZY_SYMBOL_POINTERS, \"__got\" },\n    /*[sk_debug_info] =*/     { 3, S_REGULAR | S_ATTR_DEBUG, \"__debug_info\" },\n    /*[sk_debug_abbrev] =*/   { 3, S_REGULAR | S_ATTR_DEBUG, \"__debug_abbrev\" },\n    /*[sk_debug_line] =*/     { 3, S_REGULAR | S_ATTR_DEBUG, \"__debug_line\" },\n    /*[sk_debug_aranges] =*/  { 3, S_REGULAR | S_ATTR_DEBUG, \"__debug_aranges\" },\n    /*[sk_debug_str] =*/      { 3, S_REGULAR | S_ATTR_DEBUG, \"__debug_str\" },\n    /*[sk_debug_line_str] =*/ { 3, S_REGULAR | S_ATTR_DEBUG, \"__debug_line_str\" },\n    /*[sk_stab] =*/           { 4, S_REGULAR, \"__stab\" },\n    /*[sk_stab_str] =*/       { 4, S_REGULAR, \"__stab_str\" },\n    /*[sk_la_ptr] =*/         { 4, S_LAZY_SYMBOL_POINTERS, \"__la_symbol_ptr\" },\n    /*[sk_init] =*/           { 4, S_MOD_INIT_FUNC_POINTERS, \"__mod_init_func\" },\n    /*[sk_fini] =*/           { 4, S_MOD_TERM_FUNC_POINTERS, \"__mod_term_func\" },\n    /*[sk_rw_data] =*/        { 4, S_REGULAR, \"__data\" },\n    /*[sk_bss] =*/            { 4, S_ZEROFILL, \"__bss\" },\n    /*[sk_linkedit] =*/       { 5, S_REGULAR, NULL },\n};\n\n#define\tSTART\t((uint64_t)1 << 32)\n\nconst struct {\n    int used;\n    const char *name;\n    uint64_t vmaddr;\n    uint64_t vmsize;\n    vm_prot_t maxprot;\n    vm_prot_t initprot;\n    uint32_t flags;\n} all_segment[] = {\n    { 1, \"__PAGEZERO\",       0, START, 0, 0,            0 },\n    { 0, \"__TEXT\",       START,     0, 5, 5,            0 },\n    { 0, \"__DATA_CONST\",    -1,     0, 3, 3, SG_READ_ONLY },\n    { 0, \"__DWARF\",         -1,     0, 7, 3,            0 },\n    { 0, \"__DATA\",          -1,     0, 3, 3,            0 },\n    { 1, \"__LINKEDIT\",      -1,     0, 1, 1,            0 },\n};\n\n#define\tN_SEGMENT\t(sizeof(all_segment)/sizeof(all_segment[0]))\n\n#ifdef CONFIG_NEW_MACHO\nstatic void calc_fixup_size(TCCState *s1, struct macho *mo)\n{\n    int i, size;\n\n    size = (sizeof(struct dyld_chained_fixups_header) + 7) & -8;\n    size += (sizeof(struct dyld_chained_starts_in_image) + (mo->nseg - 1) * sizeof(uint32_t) + 7) & -8;\n    for (i = (s1->output_type == TCC_OUTPUT_EXE); i < mo->nseg - 1; i++) {\n\tint page_count = (get_segment(mo, i)->vmsize + SEG_PAGE_SIZE - 1) / SEG_PAGE_SIZE;\n\tsize += (sizeof(struct dyld_chained_starts_in_segment) + (page_count - 1) * sizeof(uint16_t) + 7) & -8;\n    }\n    size += mo->n_bind * sizeof (struct dyld_chained_import) + 1;\n    for (i = 0; i < mo->n_bind_rebase; i++) {\n\tif (mo->bind_rebase[i].bind) {\n\t    int sym_index = ELFW(R_SYM)(mo->bind_rebase[i].rel.r_info);\n\t    ElfW(Sym) *sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\t    const char *name = (char *) symtab_section->link->data + sym->st_name;\n\t    size += strlen(name) + 1;\n\t}\n    }\n    size = (size + 7) & -8;\n    section_ptr_add(mo->chained_fixups, size);\n}\n\n#else\n\nstatic void set_segment_and_offset(TCCState *s1, struct macho *mo, addr_t addr,\n\t\t\t\t   uint8_t *ptr, int opcode,\n\t\t\t\t   Section *sec, addr_t offset)\n{\n    int i;\n    struct segment_command_64 *seg = NULL;\n\n    for (i = (s1->output_type == TCC_OUTPUT_EXE); i < mo->nseg - 1; i++) {\n\tseg = get_segment(mo, i);\n\tif (addr >= seg->vmaddr && addr < (seg->vmaddr + seg->vmsize))\n\t    break;\n    }\n    *ptr = opcode | i;\n    write_uleb128(sec, offset - seg->vmaddr);\n}\n\nstatic void bind_rebase(TCCState *s1, struct macho *mo)\n{\n    int i;\n    uint8_t *ptr;\n    ElfW(Sym) *sym;\n    const char *name;\n\n    for (i = 0; i < mo->n_lazy_bind; i++) {\n\tint sym_index = ELFW(R_SYM)(mo->s_lazy_bind[i].rel.r_info);\n\n\tsym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\tname = (char *) symtab_section->link->data + sym->st_name;\n\twrite32le(mo->stub_helper->data +\n\t\t  mo->s_lazy_bind[i].bind_offset,\n\t\t  mo->lazy_binding->data_offset);\n\tptr = section_ptr_add(mo->lazy_binding, 1);\n\tset_segment_and_offset(s1, mo, mo->la_symbol_ptr->sh_addr, ptr,\n\t\t\t       BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB,\n\t\t\t       mo->lazy_binding,\n\t\t\t       mo->s_lazy_bind[i].la_symbol_offset +\n\t\t\t       mo->la_symbol_ptr->sh_addr);\n\tptr = section_ptr_add(mo->lazy_binding, 5 + strlen(name));\n\t*ptr++ = BIND_OPCODE_SET_DYLIB_SPECIAL_IMM |\n\t\t (BIND_SPECIAL_DYLIB_FLAT_LOOKUP & 0xf);\n\t*ptr++ = BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM | 0;\n\tstrcpy((char *)ptr, name);\n\tptr += strlen(name) + 1;\n\t*ptr++ = BIND_OPCODE_DO_BIND;\n\t*ptr = BIND_OPCODE_DONE;\n    }\n    for (i = 0; i < mo->n_rebase; i++) {\n\tSection *s = s1->sections[mo->s_rebase[i].section];\n\n\tptr = section_ptr_add(mo->rebase, 2);\n\t*ptr++ = REBASE_OPCODE_SET_TYPE_IMM | REBASE_TYPE_POINTER;\n\tset_segment_and_offset(s1, mo, s->sh_addr, ptr,\n\t\t\t       REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB,\n\t\t\t       mo->rebase,\n\t\t\t       mo->s_rebase[i].rel.r_offset +\n\t\t\t       s->sh_addr);\n\tptr = section_ptr_add(mo->rebase, 1);\n\t*ptr = REBASE_OPCODE_DO_REBASE_IMM_TIMES | 1;\n    }\n    for (i = 0; i < mo->n_bind; i++) {\n\tint sym_index = ELFW(R_SYM)(mo->bind[i].rel.r_info);\n\tSection *s = s1->sections[mo->bind[i].section];\n\tSection *binding;\n\n\tsym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\tname = (char *) symtab_section->link->data + sym->st_name;\n\tbinding = ELFW(ST_BIND)(sym->st_info) == STB_WEAK\n\t    ? mo->weak_binding : mo->binding;\n        ptr = section_ptr_add(binding, 4 + (binding == mo->binding) +\n\t\t\t     \t       strlen(name));\n\tif (binding == mo->binding)\n            *ptr++ = BIND_OPCODE_SET_DYLIB_SPECIAL_IMM |\n\t             (BIND_SPECIAL_DYLIB_FLAT_LOOKUP & 0xf);\n        *ptr++ = BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM |\n\t\t (binding == mo->weak_binding\n\t\t  ? BIND_SYMBOL_FLAGS_WEAK_IMPORT : 0);\n        strcpy((char *)ptr, name);\n        ptr += strlen(name) + 1;\n        *ptr++ = BIND_OPCODE_SET_TYPE_IMM | BIND_TYPE_POINTER;\n\tset_segment_and_offset(s1, mo, s->sh_addr, ptr,\n\t\t\t       BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB,\n\t\t\t       binding,\n\t\t\t       mo->bind[i].rel.r_offset + s->sh_addr);\n        ptr = section_ptr_add(binding, 1);\n        *ptr++ = BIND_OPCODE_DO_BIND;\n    }\n    if (mo->rebase->data_offset) {\n        ptr = section_ptr_add(mo->rebase, 1);\n        *ptr = REBASE_OPCODE_DONE;\n    }\n    if (mo->binding->data_offset) {\n        ptr = section_ptr_add(mo->binding, 1);\n        *ptr = BIND_OPCODE_DONE;\n    }\n    if (mo->weak_binding->data_offset) {\n        ptr = section_ptr_add(mo->weak_binding, 1);\n        *ptr = BIND_OPCODE_DONE;\n    }\n    tcc_free(mo->s_lazy_bind);\n    tcc_free(mo->s_rebase);\n    tcc_free(mo->bind);\n}\n#endif\n\nstruct trie_info {\n    const char *name;\n    int flag;\n    addr_t addr;\n    int str_size;\n    int term_size;\n};\n\nstruct trie_node {\n    int start;\n    int end;\n    int index_start;\n    int index_end;\n    int n_child;\n    struct trie_node *child;\n};\n\nstruct trie_seq {\n    int n_child;\n    struct trie_node *node;\n    int offset;\n    int nest_offset;\n};\n\nstatic void create_trie(struct trie_node *node,\n                        int from, int to, int index_start,\n                        int n_trie, struct trie_info *trie)\n{\n    int i;\n    int start, end, index_end;\n    char cur;\n    struct trie_node *child;\n\n    for (i = from; i < to; i = end) {\n        cur = trie[i].name[index_start];\n        start = i++;\n        for (; i < to; i++)\n            if (cur != trie[i].name[index_start])\n                break;\n        end = i;\n        if (start == end - 1 ||\n            (trie[start].name[index_start] &&\n             trie[start].name[index_start + 1] == 0))\n            index_end = trie[start].str_size - 1;\n        else {\n            index_end = index_start + 1;\n            for (;;) {\n                cur = trie[start].name[index_end];\n                for (i = start + 1; i < end; i++)\n                    if (cur != trie[i].name[index_end])\n                        break;\n                if (trie[start].name[index_end] &&\n                    trie[start].name[index_end + 1] == 0) {\n                    end = start + 1;\n                    index_end = trie[start].str_size - 1;\n                    break;\n                }\n                if (i != end)\n                    break;\n                index_end++;\n            }\n        }\n        node->child = tcc_realloc(node->child,\n                                  (node->n_child + 1) *\n                                  sizeof(struct trie_node));\n        child = &node->child[node->n_child];\n        child->start = start;\n        child->end = end;\n        child->index_start = index_start;\n        child->index_end = index_end;\n        child->n_child = 0;\n        child->child = NULL;\n        node->n_child++;\n        if (start != end - 1)\n            create_trie(child, start, end, index_end, n_trie, trie);\n    }\n}\n\nstatic int create_seq(int *offset, int *n_seq, struct trie_seq **seq,\n                        struct trie_node *node,\n                        int n_trie, struct trie_info *trie)\n{\n    int i, nest_offset, last_seq = *n_seq, retval = *offset;\n    struct trie_seq *p_seq;\n    struct trie_node *p_nest;\n\n    for (i = 0; i < node->n_child; i++) {\n        p_nest = &node->child[i];\n        *seq = tcc_realloc(*seq, (*n_seq + 1) * sizeof(struct trie_seq));\n        p_seq = &(*seq)[(*n_seq)++];\n        p_seq->n_child = i == 0 ? node->n_child : -1;\n        p_seq->node = p_nest;\n        p_seq->offset = *offset;\n        p_seq->nest_offset = 0;\n        *offset += (i == 0 ? 1 + 1 : 0) +\n                   p_nest->index_end - p_nest->index_start + 1 + 3;\n    }\n    for (i = 0; i < node->n_child; i++) {\n        nest_offset =\n            create_seq(offset, n_seq, seq, &node->child[i], n_trie, trie);\n        p_seq = &(*seq)[last_seq + i];\n        p_seq->nest_offset = nest_offset;\n    }\n    return retval;\n}\n\nstatic void node_free(struct trie_node *node)\n{\n    int i;\n\n    for (i = 0; i < node->n_child; i++)\n\tnode_free(&node->child[i]);\n    tcc_free(node->child);\n}\n\nstatic int triecmp(const void *_a, const void *_b, void *arg)\n{\n    struct trie_info *a = (struct trie_info *) _a;\n    struct trie_info *b = (struct trie_info *) _b;\n    int len_a = strlen(a->name);\n    int len_b = strlen(b->name);\n\n    /* strange sorting needed. Name 'xx' should be after 'xx1' */\n    if (!strncmp(a->name, b->name, len_a < len_b ? len_a : len_b))\n\treturn len_a < len_b ? 1 : (len_a > len_b ? -1 : 0);\n    return strcmp(a->name, b->name);\n}\n\nstatic void export_trie(TCCState *s1, struct macho *mo)\n{\n    int i, size, offset = 0, save_offset;\n    uint8_t *ptr;\n    int sym_index;\n    int sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));\n    int n_trie = 0, n_seq = 0;\n    struct trie_info *trie = NULL, *p_trie;\n    struct trie_node node, *p_node;\n    struct trie_seq *seq = NULL;\n    addr_t vm_addr = get_segment(mo, s1->output_type == TCC_OUTPUT_EXE)->vmaddr;\n\n    for (sym_index = 1; sym_index < sym_end; ++sym_index) {\n\tElfW(Sym) *sym = (ElfW(Sym) *)symtab_section->data + sym_index;\n\tconst char *name = (char*)symtab_section->link->data + sym->st_name;\n\n\tif (sym->st_shndx != SHN_UNDEF && sym->st_shndx < SHN_LORESERVE &&\n            (ELFW(ST_BIND)(sym->st_info) == STB_GLOBAL ||\n\t     ELFW(ST_BIND)(sym->st_info) == STB_WEAK)) {\n\t    int flag = EXPORT_SYMBOL_FLAGS_KIND_REGULAR;\n\t    addr_t addr =\n\t\tsym->st_value + s1->sections[sym->st_shndx]->sh_addr - vm_addr;\n\n\t    if (ELFW(ST_BIND)(sym->st_info) == STB_WEAK)\n\t\tflag |= EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION;\n\t    dprintf (\"%s %d %llx\\n\", name, flag, (long long)addr + vm_addr);\n\t    trie = tcc_realloc(trie, (n_trie + 1) * sizeof(struct trie_info));\n\t    trie[n_trie].name = name;\n\t    trie[n_trie].flag = flag;\n\t    trie[n_trie].addr = addr;\n\t    trie[n_trie].str_size = strlen(name) + 1;\n\t    trie[n_trie].term_size = uleb128_size(flag) + uleb128_size(addr);\n\t    n_trie++;\n\t}\n    }\n    if (n_trie) {\n        tcc_qsort(trie, n_trie, sizeof(struct trie_info), triecmp, NULL);\n\tmemset(&node, 0, sizeof(node));\n        create_trie(&node, 0, n_trie, 0, n_trie, trie);\n\tcreate_seq(&offset, &n_seq, &seq, &node, n_trie, trie);\n        save_offset = offset;\n        for (i = 0; i < n_seq; i++) {\n            p_node = seq[i].node;\n            if (p_node->n_child == 0) {\n                p_trie = &trie[p_node->start];\n                seq[i].nest_offset = offset;\n                offset += 1 + p_trie->term_size + 1;\n            }\n        }\n        for (i = 0; i < n_seq; i++) {\n            p_node = seq[i].node;\n            p_trie = &trie[p_node->start];\n            if (seq[i].n_child >= 0) {\n                section_ptr_add(mo->exports,\n\t\t\t\tseq[i].offset - mo->exports->data_offset);\n                ptr = section_ptr_add(mo->exports, 2);\n                *ptr++ = 0;\n                *ptr = seq[i].n_child;\n            }\n            size = p_node->index_end - p_node->index_start;\n            ptr = section_ptr_add(mo->exports, size + 1);\n            memcpy(ptr, &p_trie->name[p_node->index_start], size);\n            ptr[size] = 0;\n            write_uleb128(mo->exports, seq[i].nest_offset);\n        }\n        section_ptr_add(mo->exports, save_offset - mo->exports->data_offset);\n        for (i = 0; i < n_seq; i++) {\n            p_node = seq[i].node;\n            if (p_node->n_child == 0) {\n                p_trie = &trie[p_node->start];\n                write_uleb128(mo->exports, p_trie->term_size);\n                write_uleb128(mo->exports, p_trie->flag);\n                write_uleb128(mo->exports, p_trie->addr);\n                ptr = section_ptr_add(mo->exports, 1);\n                *ptr = 0;\n            }\n        }\n        section_ptr_add(mo->exports, -mo->exports->data_offset & 7);\n\tnode_free(&node);\n        tcc_free(seq);\n    }\n    tcc_free(trie);\n}\n\nstatic void collect_sections(TCCState *s1, struct macho *mo, const char *filename)\n{\n    int i, sk, numsec;\n    int used_segment[N_SEGMENT];\n    uint64_t curaddr, fileofs;\n    Section *s;\n    struct segment_command_64 *seg;\n    struct dylib_command *dylib;\n#ifdef CONFIG_NEW_MACHO\n    struct linkedit_data_command *chained_fixups_lc;\n    struct linkedit_data_command *export_trie_lc;\n#endif\n    struct build_version_command *dyldbv;\n    struct source_version_command *dyldsv;\n    struct rpath_command *rpath;\n    struct dylinker_command *dyldlc;\n    struct symtab_command *symlc;\n    struct dysymtab_command *dysymlc;\n    char *str;\n\n    for (i = 0; i < N_SEGMENT; i++)\n\tused_segment[i] = all_segment[i].used;\n\n    memset (mo->sk_to_sect, 0, sizeof(mo->sk_to_sect));\n    for (i = s1->nb_sections; i-- > 1;) {\n        int type, flags;\n        s = s1->sections[i];\n        type = s->sh_type;\n        flags = s->sh_flags;\n        sk = sk_unknown;\n\t/* debug sections have sometimes no SHF_ALLOC */\n        if ((flags & SHF_ALLOC) || !strncmp(s->name, \".debug_\", 7)) {\n            switch (type) {\n            default:           sk = sk_unknown; break;\n            case SHT_INIT_ARRAY: sk = sk_init; break;\n            case SHT_FINI_ARRAY: sk = sk_fini; break;\n            case SHT_NOBITS:   sk = sk_bss; break;\n            case SHT_SYMTAB:   sk = sk_discard; break;\n            case SHT_STRTAB:\n\t\tif (s == stabstr_section)\n\t\t  sk = sk_stab_str;\n\t\telse\n\t\t  sk = sk_discard;\n\t\tbreak;\n            case SHT_RELX:     sk = sk_discard; break;\n            case SHT_LINKEDIT: sk = sk_linkedit; break;\n            case SHT_PROGBITS:\n                if (s == mo->stubs)\n                  sk = sk_stubs;\n#ifndef CONFIG_NEW_MACHO\n                else if (s == mo->stub_helper)\n                  sk = sk_stub_helper;\n                else if (s == mo->la_symbol_ptr)\n                  sk = sk_la_ptr;\n#endif\n                else if (s == rodata_section)\n                  sk = sk_ro_data;\n                else if (s == s1->got)\n                  sk = sk_nl_ptr;\n                else if (s == stab_section)\n                  sk = sk_stab;\n                else if (s == dwarf_info_section)\n                  sk = sk_debug_info;\n                else if (s == dwarf_abbrev_section)\n                  sk = sk_debug_abbrev;\n                else if (s == dwarf_line_section)\n                  sk = sk_debug_line;\n                else if (s == dwarf_aranges_section)\n                  sk = sk_debug_aranges;\n                else if (s == dwarf_str_section)\n                  sk = sk_debug_str;\n                else if (s == dwarf_line_str_section)\n                  sk = sk_debug_line_str;\n                else if (flags & SHF_EXECINSTR)\n                  sk = sk_text;\n                else if (flags & SHF_WRITE)\n                  sk = sk_rw_data;\n                else\n                  sk = sk_ro_data;\n                break;\n            }\n        } else\n          sk = sk_discard;\n        s->prev = mo->sk_to_sect[sk].s;\n        mo->sk_to_sect[sk].s = s;\n\tused_segment[skinfo[sk].seg_initial] = 1;\n    }\n\n    if (s1->output_type != TCC_OUTPUT_EXE)\n\tused_segment[0] = 0;\n\n    for (i = 0; i < N_SEGMENT; i++)\n\tif (used_segment[i]) {\n\t    seg = add_segment(mo, all_segment[i].name);\n\t    if (i == 1 && s1->output_type != TCC_OUTPUT_EXE)\n\t        seg->vmaddr = 0;\n\t    else\n\t        seg->vmaddr = all_segment[i].vmaddr;\n\t    seg->vmsize = all_segment[i].vmsize;\n\t    seg->maxprot = all_segment[i].maxprot;\n\t    seg->initprot = all_segment[i].initprot;\n\t    seg->flags = all_segment[i].flags;\n            for (sk = sk_unknown; sk < sk_last; sk++)\n\t\tif (skinfo[sk].seg_initial == i)\n\t            mo->segment[sk] = mo->nseg - 1;\n\t}\n\n    if (s1->output_type != TCC_OUTPUT_EXE) {\n\tconst char *name = s1->install_name ? s1->install_name : filename;\n        i = (sizeof(*dylib) + strlen(name) + 1 + 7) &-8;\n        dylib = add_lc(mo, LC_ID_DYLIB, i);\n\tdylib->name = sizeof(*dylib);\n\tdylib->timestamp = 1;\n\tdylib->current_version =\n\t    s1->current_version ? s1->current_version : 1 << 16;\n\tdylib->compatibility_version =\n\t    s1->compatibility_version ? s1->compatibility_version : 1 << 16;\n        str = (char*)dylib + dylib->name;\n        strcpy(str, name);\n    }\n\n#ifdef CONFIG_NEW_MACHO\n    chained_fixups_lc = add_lc(mo, LC_DYLD_CHAINED_FIXUPS,\n\t\t\t       sizeof(struct linkedit_data_command));\n    export_trie_lc = add_lc(mo, LC_DYLD_EXPORTS_TRIE,\n\t\t\t    sizeof(struct linkedit_data_command));\n#else\n    mo->dyldinfo = add_lc(mo, LC_DYLD_INFO_ONLY, sizeof(*mo->dyldinfo));\n#endif\n\n    symlc = add_lc(mo, LC_SYMTAB, sizeof(*symlc));\n    dysymlc = add_lc(mo, LC_DYSYMTAB, sizeof(*dysymlc));\n\n    if (s1->output_type == TCC_OUTPUT_EXE) {\n        i = (sizeof(*dyldlc) + strlen(\"/usr/lib/dyld\") + 1 + 7) &-8;\n        dyldlc = add_lc(mo, LC_LOAD_DYLINKER, i);\n        dyldlc->name = sizeof(*dyldlc);\n        str = (char*)dyldlc + dyldlc->name;\n        strcpy(str, \"/usr/lib/dyld\");\n    }\n\n    dyldbv = add_lc(mo, LC_BUILD_VERSION, sizeof(*dyldbv));\n    dyldbv->platform = PLATFORM_MACOS;\n    dyldbv->minos = (10 << 16) + (6 << 8);\n    dyldbv->sdk = (10 << 16) + (6 << 8);\n    dyldbv->ntools = 0;\n\n    dyldsv = add_lc(mo, LC_SOURCE_VERSION, sizeof(*dyldsv));\n    dyldsv->version = 0;\n\n    if (s1->output_type == TCC_OUTPUT_EXE) {\n        mo->ep = add_lc(mo, LC_MAIN, sizeof(*mo->ep));\n        mo->ep->entryoff = 4096;\n    }\n\n    for(i = 0; i < s1->nb_loaded_dlls; i++) {\n        DLLReference *dllref = s1->loaded_dlls[i];\n        if (dllref->level == 0)\n          add_dylib(mo, dllref->name);\n    }\n\n    if (s1->rpath) {\n\tchar *path = s1->rpath, *end;\n\tdo {\n\t    end = strchr(path, ':');\n\t    if (!end)\n\t\tend = strchr(path, 0);\n            i = (sizeof(*rpath) + (end - path) + 1 + 7) &-8;\n            rpath = add_lc(mo, LC_RPATH, i);\n            rpath->path = sizeof(*rpath);\n            str = (char*)rpath + rpath->path;\n            memcpy(str, path, end - path);\n\t    str[end - path] = 0;\n\t    path = end + 1;\n\t} while (*end);\n    }\n\n    fileofs = 4096;  /* leave space for mach-o headers */\n    curaddr = get_segment(mo, s1->output_type == TCC_OUTPUT_EXE)->vmaddr;\n    curaddr += 4096;\n    seg = NULL;\n    numsec = 0;\n    mo->elfsectomacho = tcc_mallocz(sizeof(*mo->elfsectomacho) * s1->nb_sections);\n    for (sk = sk_unknown; sk < sk_last; sk++) {\n        struct section_64 *sec = NULL;\n        if (seg) {\n            seg->vmsize = curaddr - seg->vmaddr;\n            seg->filesize = fileofs - seg->fileoff;\n        }\n#ifdef CONFIG_NEW_MACHO\n\tif (sk == sk_linkedit) {\n\t    calc_fixup_size(s1, mo);\n\t    export_trie(s1, mo);\n\t}\n#else\n\tif (sk == sk_linkedit) {\n\t    bind_rebase(s1, mo);\n\t    export_trie(s1, mo);\n\t}\n#endif\n        if (skinfo[sk].seg_initial &&\n\t    (s1->output_type != TCC_OUTPUT_EXE || mo->segment[sk]) &&\n\t    mo->sk_to_sect[sk].s) {\n            uint64_t al = 0;\n            int si;\n            seg = get_segment(mo, mo->segment[sk]);\n            if (skinfo[sk].name) {\n                si = add_section(mo, &seg, skinfo[sk].name);\n                numsec++;\n                mo->lc[mo->seg2lc[mo->segment[sk]]] = (struct load_command*)seg;\n                mo->sk_to_sect[sk].machosect = si;\n                sec = get_section(seg, si);\n                sec->flags = skinfo[sk].flags;\n\t\tif (sk == sk_stubs)\n#ifdef TCC_TARGET_X86_64\n\t    \t    sec->reserved2 = 6;\n#elif defined TCC_TARGET_ARM64\n\t    \t    sec->reserved2 = 12;\n#endif\n\t\tif (sk == sk_nl_ptr)\n\t    \t    sec->reserved1 = mo->nr_plt;\n#ifndef CONFIG_NEW_MACHO\n\t\tif (sk == sk_la_ptr)\n\t    \t    sec->reserved1 = mo->nr_plt + mo->n_got;\n#endif\n            }\n            if (seg->vmaddr == -1) {\n                curaddr = (curaddr + SEG_PAGE_SIZE - 1) & -SEG_PAGE_SIZE;\n                seg->vmaddr = curaddr;\n                fileofs = (fileofs + SEG_PAGE_SIZE - 1) & -SEG_PAGE_SIZE;\n                seg->fileoff = fileofs;\n            }\n\n            for (s = mo->sk_to_sect[sk].s; s; s = s->prev) {\n                int a = exact_log2p1(s->sh_addralign);\n                if (a && al < (a - 1))\n                  al = a - 1;\n                s->sh_size = s->data_offset;\n            }\n            if (sec)\n              sec->align = al;\n            al = 1ULL << al;\n            if (al > 4096)\n              tcc_warning(\"alignment > 4096\"), sec->align = 12, al = 4096;\n            curaddr = (curaddr + al - 1) & -al;\n            fileofs = (fileofs + al - 1) & -al;\n            if (sec) {\n                sec->addr = curaddr;\n                sec->offset = fileofs;\n            }\n            for (s = mo->sk_to_sect[sk].s; s; s = s->prev) {\n                al = s->sh_addralign;\n                curaddr = (curaddr + al - 1) & -al;\n                dprintf(\"%s: curaddr now 0x%lx\\n\", s->name, (long)curaddr);\n                s->sh_addr = curaddr;\n                curaddr += s->sh_size;\n                if (s->sh_type != SHT_NOBITS) {\n                    fileofs = (fileofs + al - 1) & -al;\n                    s->sh_offset = fileofs;\n                    fileofs += s->sh_size;\n                    dprintf(\"%s: fileofs now %ld\\n\", s->name, (long)fileofs);\n                }\n                if (sec)\n                  mo->elfsectomacho[s->sh_num] = numsec;\n            }\n            if (sec)\n              sec->size = curaddr - sec->addr;\n        }\n        if (DEBUG_MACHO)\n          for (s = mo->sk_to_sect[sk].s; s; s = s->prev) {\n              int type = s->sh_type;\n              int flags = s->sh_flags;\n              printf(\"%d section %-16s %-10s %09lx %04x %02d %s,%s,%s\\n\",\n                     sk,\n                     s->name,\n                     type == SHT_PROGBITS ? \"progbits\" :\n                     type == SHT_NOBITS ? \"nobits\" :\n                     type == SHT_SYMTAB ? \"symtab\" :\n                     type == SHT_STRTAB ? \"strtab\" :\n                     type == SHT_INIT_ARRAY ? \"init\" :\n                     type == SHT_FINI_ARRAY ? \"fini\" :\n                     type == SHT_RELX ? \"rel\" : \"???\",\n                     (long)s->sh_addr,\n                     (unsigned)s->data_offset,\n                     s->sh_addralign,\n                     flags & SHF_ALLOC ? \"alloc\" : \"\",\n                     flags & SHF_WRITE ? \"write\" : \"\",\n                     flags & SHF_EXECINSTR ? \"exec\" : \"\"\n                    );\n          }\n    }\n    if (seg) {\n        seg->vmsize = curaddr - seg->vmaddr;\n        seg->filesize = fileofs - seg->fileoff;\n    }\n\n    /* Fill symtab info */\n    symlc->symoff = mo->symtab->sh_offset;\n    symlc->nsyms = mo->symtab->data_offset / sizeof(struct nlist_64);\n    symlc->stroff = mo->strtab->sh_offset;\n    symlc->strsize = mo->strtab->data_offset;\n\n    dysymlc->iundefsym = mo->iundef == -1 ? symlc->nsyms : mo->iundef;\n    dysymlc->iextdefsym = mo->iextdef == -1 ? dysymlc->iundefsym : mo->iextdef;\n    dysymlc->ilocalsym = mo->ilocal == -1 ? dysymlc->iextdefsym : mo->ilocal;\n    dysymlc->nlocalsym = dysymlc->iextdefsym - dysymlc->ilocalsym;\n    dysymlc->nextdefsym = dysymlc->iundefsym - dysymlc->iextdefsym;\n    dysymlc->nundefsym = symlc->nsyms - dysymlc->iundefsym;\n    dysymlc->indirectsymoff = mo->indirsyms->sh_offset;\n    dysymlc->nindirectsyms = mo->indirsyms->data_offset / sizeof(uint32_t);\n\n#ifdef CONFIG_NEW_MACHO\n    if (mo->chained_fixups->data_offset) {\n        chained_fixups_lc->dataoff = mo->chained_fixups->sh_offset;\n        chained_fixups_lc->datasize = mo->chained_fixups->data_offset;\n    }\n    if (mo->exports->data_offset) {\n        export_trie_lc->dataoff = mo->exports->sh_offset;\n        export_trie_lc->datasize = mo->exports->data_offset;\n    }\n#else\n    if (mo->rebase->data_offset) {\n        mo->dyldinfo->rebase_off = mo->rebase->sh_offset;\n        mo->dyldinfo->rebase_size = mo->rebase->data_offset;\n    }\n    if (mo->binding->data_offset) {\n        mo->dyldinfo->bind_off = mo->binding->sh_offset;\n        mo->dyldinfo->bind_size = mo->binding->data_offset;\n    }\n    if (mo->weak_binding->data_offset) {\n        mo->dyldinfo->weak_bind_off = mo->weak_binding->sh_offset;\n        mo->dyldinfo->weak_bind_size = mo->weak_binding->data_offset;\n    }\n    if (mo->lazy_binding->data_offset) {\n        mo->dyldinfo->lazy_bind_off = mo->lazy_binding->sh_offset;\n        mo->dyldinfo->lazy_bind_size = mo->lazy_binding->data_offset;\n    }\n    if (mo->exports->data_offset) {\n        mo->dyldinfo->export_off = mo->exports->sh_offset;\n        mo->dyldinfo->export_size = mo->exports->data_offset;\n    }\n#endif\n}\n\nstatic void macho_write(TCCState *s1, struct macho *mo, FILE *fp)\n{\n    int i, sk;\n    uint64_t fileofs = 0;\n    Section *s;\n    mo->mh.mh.magic = MH_MAGIC_64;\n#ifdef TCC_TARGET_X86_64\n    mo->mh.mh.cputype = CPU_TYPE_X86_64;\n    mo->mh.mh.cpusubtype = CPU_SUBTYPE_LIB64 | CPU_SUBTYPE_X86_ALL;\n#elif defined TCC_TARGET_ARM64\n    mo->mh.mh.cputype = CPU_TYPE_ARM64;\n    mo->mh.mh.cpusubtype = CPU_SUBTYPE_ARM64_ALL;\n#endif\n    if (s1->output_type == TCC_OUTPUT_EXE) {\n        mo->mh.mh.filetype = MH_EXECUTE;\n        mo->mh.mh.flags = MH_DYLDLINK | MH_PIE;\n    }\n    else {\n        mo->mh.mh.filetype = MH_DYLIB;\n        mo->mh.mh.flags = MH_DYLDLINK;\n    }\n    mo->mh.mh.ncmds = mo->nlc;\n    mo->mh.mh.sizeofcmds = 0;\n    for (i = 0; i < mo->nlc; i++)\n      mo->mh.mh.sizeofcmds += mo->lc[i]->cmdsize;\n\n    fwrite(&mo->mh, 1, sizeof(mo->mh), fp);\n    fileofs += sizeof(mo->mh);\n    for (i = 0; i < mo->nlc; i++) {\n        fwrite(mo->lc[i], 1, mo->lc[i]->cmdsize, fp);\n        fileofs += mo->lc[i]->cmdsize;\n    }\n\n    for (sk = sk_unknown; sk < sk_last; sk++) {\n        //struct segment_command_64 *seg;\n        if (skinfo[sk].seg_initial == 0 ||\n\t    (s1->output_type == TCC_OUTPUT_EXE && !mo->segment[sk]) ||\n\t    !mo->sk_to_sect[sk].s)\n          continue;\n        /*seg =*/ get_segment(mo, mo->segment[sk]);\n        for (s = mo->sk_to_sect[sk].s; s; s = s->prev) {\n            if (s->sh_type != SHT_NOBITS) {\n                while (fileofs < s->sh_offset)\n                  fputc(0, fp), fileofs++;\n                if (s->sh_size) {\n                    fwrite(s->data, 1, s->sh_size, fp);\n                    fileofs += s->sh_size;\n                }\n            }\n        }\n    }\n}\n\n#ifdef CONFIG_NEW_MACHO\nstatic int bind_rebase_cmp(const void *_a, const void *_b, void *arg)\n{\n    TCCState *s1 = arg;\n    struct bind_rebase *a = (struct bind_rebase *) _a;\n    struct bind_rebase *b = (struct bind_rebase *) _b;\n    addr_t aa = s1->sections[a->section]->sh_addr + a->rel.r_offset;\n    addr_t ab = s1->sections[b->section]->sh_addr + b->rel.r_offset;\n\n    return aa > ab ? 1 : aa < ab ? -1 : 0;\n}\n\nST_FUNC void bind_rebase_import(TCCState *s1, struct macho *mo)\n{\n    int i, j, k, bind_index, size, page_count, sym_index;\n    const char *name;\n    ElfW(Sym) *sym;\n    unsigned char *data = mo->chained_fixups->data;\n    struct segment_command_64 *seg;\n    struct dyld_chained_fixups_header *header;\n    struct dyld_chained_starts_in_image *image;\n    struct dyld_chained_starts_in_segment *segment;\n    struct dyld_chained_import *import;\n\n    tcc_qsort(mo->bind_rebase, mo->n_bind_rebase, sizeof(struct bind_rebase),\n\t      bind_rebase_cmp, s1);\n    for (i = 0; i < mo->n_bind_rebase - 1; i++)\n\tif (mo->bind_rebase[i].section == mo->bind_rebase[i + 1].section &&\n\t    mo->bind_rebase[i].rel.r_offset == mo->bind_rebase[i + 1].rel.r_offset) {\n\t    sym_index = ELFW(R_SYM)(mo->bind_rebase[i].rel.r_info);\n            sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\t    name = (char *) symtab_section->link->data + sym->st_name;\n\t    tcc_error(\"Overlap %s/%s %s:%s\",\n\t\t      mo->bind_rebase[i].bind ? \"bind\" : \"rebase\",\n\t\t      mo->bind_rebase[i + 1].bind ? \"bind\" : \"rebase\",\n\t\t      s1->sections[mo->bind_rebase[i].section]->name, name);\n\t}\n    header = (struct dyld_chained_fixups_header *) data;\n    data += (sizeof(struct dyld_chained_fixups_header) + 7) & -8;\n    header->starts_offset = data - mo->chained_fixups->data;\n    header->imports_count = mo->n_bind;\n    header->imports_format = DYLD_CHAINED_IMPORT;\n    header->symbols_format = 0;\n    size = sizeof(struct dyld_chained_starts_in_image) +\n\t   (mo->nseg - 1) * sizeof(uint32_t);\n    image = (struct dyld_chained_starts_in_image *) data;\n    data += (size + 7) & -8;\n    image->seg_count = mo->nseg;\n    for (i = (s1->output_type == TCC_OUTPUT_EXE); i < mo->nseg - 1; i++) {\n        image->seg_info_offset[i] = (data - mo->chained_fixups->data) -\n\t\t\t\t    header->starts_offset;\n\tseg = get_segment(mo, i);\n\tpage_count = (seg->vmsize + SEG_PAGE_SIZE - 1) / SEG_PAGE_SIZE;\n\tsize = sizeof(struct dyld_chained_starts_in_segment) +\n\t\t      (page_count - 1) * sizeof(uint16_t);\n        segment = (struct dyld_chained_starts_in_segment *) data;\n        data += (size + 7) & -8;\n        segment->size = size;\n        segment->page_size = SEG_PAGE_SIZE;\n#if 1\n#define\tPTR_64_OFFSET 0\n#define\tPTR_64_MASK   0x7FFFFFFFFFFULL\n        segment->pointer_format = DYLD_CHAINED_PTR_64;\n#else\n#define\tPTR_64_OFFSET 0x100000000ULL\n#define\tPTR_64_MASK   0xFFFFFFFFFFFFFFULL\n        segment->pointer_format = DYLD_CHAINED_PTR_64_OFFSET;\n#endif\n        segment->segment_offset = seg->fileoff;\n        segment->max_valid_pointer = 0;\n        segment->page_count = page_count;\n\t// add bind/rebase\n\tbind_index = 0;\n\tk = 0;\n\tfor (j = 0; j < page_count; j++) {\n\t    addr_t start = seg->vmaddr + j * SEG_PAGE_SIZE;\n\t    addr_t end = start + SEG_PAGE_SIZE;\n\t    void *last = NULL;\n\t    addr_t last_o = 0;\n\t    addr_t cur_o, cur;\n\t    struct dyld_chained_ptr_64_rebase *rebase;\n\t    struct dyld_chained_ptr_64_bind *bind;\n\n\t    segment->page_start[j] = DYLD_CHAINED_PTR_START_NONE;\n\t    for (; k < mo->n_bind_rebase; k++) {\n\t        Section *s = s1->sections[mo->bind_rebase[k].section];\n\t\taddr_t r_offset = mo->bind_rebase[k].rel.r_offset;\n\t\taddr_t addr = s->sh_addr + r_offset;\n\n\t\tif ((addr & 3) ||\n\t\t    (addr & (SEG_PAGE_SIZE - 1)) > SEG_PAGE_SIZE - PTR_SIZE)\n\t\t    tcc_error(\"Illegal rel_offset %s %lld\",\n\t\t\t      s->name, (long long)r_offset);\n\t\tif (addr >= end)\n\t\t    break;\n\t\tif (addr >= start) {\n\t\t    cur_o = addr - start;\n\t            if (mo->bind_rebase[k].bind) {\n\t\t        if (segment->page_start[j] == DYLD_CHAINED_PTR_START_NONE)\n\t\t\t    segment->page_start[j] = cur_o;\n\t\t        else {\n\t\t\t    bind = (struct dyld_chained_ptr_64_bind *) last;\n\t\t\t    bind->next = (cur_o - last_o) / 4;\n\t\t        }\n\t\t        bind = (struct dyld_chained_ptr_64_bind *)\n\t\t\t\t    (s->data + r_offset);\n\t\t        last = bind;\n\t\t        last_o = cur_o;\n\t\t        bind->ordinal = bind_index;\n\t\t        bind->addend = 0;\n\t\t        bind->reserved = 0;\n\t\t        bind->next = 0;\n\t\t        bind->bind = 1;\n\t\t    }\n\t\t    else {\n\t\t        if (segment->page_start[j] == DYLD_CHAINED_PTR_START_NONE)\n\t\t\t    segment->page_start[j] = cur_o;\n\t\t        else {\n\t\t\t    rebase = (struct dyld_chained_ptr_64_rebase *) last;\n\t\t\t    rebase->next = (cur_o - last_o) / 4;\n\t\t        }\n\t\t        rebase = (struct dyld_chained_ptr_64_rebase *)\n\t\t\t\t    (s->data + r_offset);\n\t\t        last = rebase;\n\t\t        last_o = cur_o;\n\t\t        cur = (*(uint64_t *) (s->data + r_offset)) -\n\t\t\t      PTR_64_OFFSET;\n\t\t        rebase->target = cur & PTR_64_MASK;\n\t\t        rebase->high8 = cur >> (64 - 8);\n\t\t\tif (cur != ((uint64_t)rebase->high8 << (64 - 8)) + rebase->target)\n\t\t\t    tcc_error(\"rebase error\");\n\t\t        rebase->reserved = 0;\n\t\t        rebase->next = 0;\n\t\t        rebase->bind = 0;\n\t\t    }\n\t\t}\n\t\tbind_index += mo->bind_rebase[k].bind;\n\t    }\n\t}\n    }\n    // add imports\n    header->imports_offset = data - mo->chained_fixups->data;\n    import = (struct dyld_chained_import *) data;\n    data += mo->n_bind * sizeof (struct dyld_chained_import);\n    header->symbols_offset = data - mo->chained_fixups->data;\n    data++;\n    for (i = 0, bind_index = 0; i < mo->n_bind_rebase; i++) {\n\tif (mo->bind_rebase[i].bind) {\n\t    import[bind_index].lib_ordinal =\n\t\tBIND_SPECIAL_DYLIB_FLAT_LOOKUP & 0xffu;\n\t    import[bind_index].name_offset =\n\t\t(data - mo->chained_fixups->data) - header->symbols_offset;\n\t    sym_index = ELFW(R_SYM)(mo->bind_rebase[i].rel.r_info);\n\t    sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n\t    import[bind_index].weak_import =\n\t\tELFW(ST_BIND)(sym->st_info) == STB_WEAK;\n\t    name = (char *) symtab_section->link->data + sym->st_name;\n            strcpy((char *) data, name);\n\t    data += strlen(name) + 1;\n\t    bind_index++;\n\t}\n    }\n    tcc_free(mo->bind_rebase);\n}\n#endif\n\nST_FUNC int macho_output_file(TCCState *s1, const char *filename)\n{\n    int fd, mode, file_type;\n    FILE *fp;\n    int i, ret = -1;\n    struct macho mo;\n\n    (void)memset(&mo, 0, sizeof(mo));\n\n    file_type = s1->output_type;\n    if (file_type == TCC_OUTPUT_OBJ)\n        mode = 0666;\n    else\n        mode = 0777;\n    unlink(filename);\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, mode);\n    if (fd < 0 || (fp = fdopen(fd, \"wb\")) == NULL) {\n        tcc_error_noabort(\"could not write '%s: %s'\", filename, strerror(errno));\n        return -1;\n    }\n    if (s1->verbose)\n        printf(\"<- %s\\n\", filename);\n\n    tcc_add_runtime(s1);\n    tcc_macho_add_destructor(s1);\n    resolve_common_syms(s1);\n    create_symtab(s1, &mo);\n    check_relocs(s1, &mo);\n    ret = check_symbols(s1, &mo);\n    if (!ret) {\n\tint save_output = s1->output_type;\n\n        collect_sections(s1, &mo, filename);\n        relocate_syms(s1, s1->symtab, 0);\n\tif (s1->output_type == TCC_OUTPUT_EXE)\n            mo.ep->entryoff = get_sym_addr(s1, \"main\", 1, 1)\n                            -     get_segment(&mo, 1)->vmaddr;\n        if (s1->nb_errors)\n          goto do_ret;\n\t// Macho uses bind/rebase instead of dynsym\n\ts1->output_type = TCC_OUTPUT_EXE;\n        relocate_sections(s1);\n\ts1->output_type = save_output;\n#ifdef CONFIG_NEW_MACHO\n\tbind_rebase_import(s1, &mo);\n#endif\n        convert_symbols(s1, &mo);\n        macho_write(s1, &mo, fp);\n    }\n\n do_ret:\n    for (i = 0; i < mo.nlc; i++)\n      tcc_free(mo.lc[i]);\n    tcc_free(mo.seg2lc);\n    tcc_free(mo.lc);\n    tcc_free(mo.elfsectomacho);\n    tcc_free(mo.e2msym);\n\n    fclose(fp);\n#ifdef CONFIG_CODESIGN\n    if (!ret) {\n\tchar command[1024];\n\tint retval;\n\n\tsnprintf(command, sizeof(command), \"codesign -f -s - %s\", filename);\n\tretval = system (command);\n\tif (retval == -1 || !(WIFEXITED(retval) && WEXITSTATUS(retval) == 0))\n\t    tcc_error (\"command failed '%s'\", command);\n    }\n#endif\n    return ret;\n}\n\nstatic uint32_t macho_swap32(uint32_t x)\n{\n  return (x >> 24) | (x << 24) | ((x >> 8) & 0xff00) | ((x & 0xff00) << 8);\n}\n#define SWAP(x) (swap ? macho_swap32(x) : (x))\n#define tbd_parse_movepast(s) \\\n    (pos = (pos = strstr(pos, s)) ? pos + strlen(s) : NULL)\n#define tbd_parse_movetoany(cs) (pos = strpbrk(pos, cs))\n#define tbd_parse_skipws while (*pos && (*pos==' '||*pos=='\\n')) ++pos\n#define tbd_parse_tramplequote if(*pos=='\\''||*pos=='\"') tbd_parse_trample\n#define tbd_parse_tramplespace if(*pos==' ') tbd_parse_trample\n#define tbd_parse_trample *pos++=0\n\n#ifdef TCC_IS_NATIVE\n/* Looks for the active developer SDK set by xcode-select (or the default\n   one set during installation.) */\nST_FUNC void tcc_add_macos_sdkpath(TCCState* s)\n{\n    char *sdkroot = NULL, *pos = NULL;\n    void* xcs = dlopen(\"libxcselect.dylib\", RTLD_GLOBAL | RTLD_LAZY);\n    CString path;\n    int (*f)(unsigned int, char**) = dlsym(xcs, \"xcselect_host_sdk_path\");\n    cstr_new(&path);\n    if (f) f(1, &sdkroot);\n    if (sdkroot)\n        pos = strstr(sdkroot,\"SDKs/MacOSX\");\n    if (pos)\n        cstr_printf(&path, \"%.*s.sdk/usr/lib\", (int)(pos - sdkroot + 11), sdkroot);\n    /* must use free from libc directly */\n#pragma push_macro(\"free\")\n#undef free\n    free(sdkroot);\n#pragma pop_macro(\"free\")\n    if (path.size)\n        tcc_add_library_path(s, (char*)path.data);\n    else\n        tcc_add_library_path(s,\n            \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib\"\n            \":\" \"/Applications/Xcode.app/Developer/SDKs/MacOSX.sdk/usr/lib\"\n            );\n    cstr_free(&path);\n}\n\nST_FUNC const char* macho_tbd_soname(const char* filename) {\n    char *soname, *data, *pos;\n    const char *ret = filename;\n\n    int fd = open(filename,O_RDONLY);\n    if (fd<0) return ret;\n    pos = data = tcc_load_text(fd);\n    if (!tbd_parse_movepast(\"install-name: \")) goto the_end;\n    tbd_parse_skipws;\n    tbd_parse_tramplequote;\n    soname = pos;\n    if (!tbd_parse_movetoany(\"\\n \\\"'\")) goto the_end;\n    tbd_parse_trample;\n    ret = tcc_strdup(soname);\nthe_end:\n    tcc_free(data);\n    return ret;\n}\n#endif /* TCC_IS_NATIVE */\n\nST_FUNC int macho_load_tbd(TCCState* s1, int fd, const char* filename, int lev)\n{\n    char *soname, *data, *pos;\n    int ret = -1;\n\n    pos = data = tcc_load_text(fd);\n    if (!tbd_parse_movepast(\"install-name: \")) goto the_end;\n    tbd_parse_skipws;\n    tbd_parse_tramplequote;\n    soname = pos;\n    if (!tbd_parse_movetoany(\"\\n \\\"'\")) goto the_end;\n    tbd_parse_trample;\n    ret = 0;\n    if (tcc_add_dllref(s1, soname, lev)->found)\n        goto the_end;\n    while(pos) {\n        char* sym = NULL;\n        int cont = 1;\n        if (!tbd_parse_movepast(\"symbols: \")) break;\n        if (!tbd_parse_movepast(\"[\")) break;\n        while (cont) {\n            tbd_parse_skipws;\n            tbd_parse_tramplequote;\n            sym = pos;\n            if (!tbd_parse_movetoany(\",] \\\"'\")) break;\n            tbd_parse_tramplequote;\n            tbd_parse_tramplespace;\n            tbd_parse_skipws;\n            if (*pos==0||*pos==']') cont=0;\n            tbd_parse_trample;\n            set_elf_sym(s1->dynsymtab_section, 0, 0,\n                ELFW(ST_INFO)(STB_GLOBAL, STT_NOTYPE), 0, SHN_UNDEF, sym);\n        }\n    }\n\nthe_end:\n    tcc_free(data);\n    return ret;\n}\n\nST_FUNC int macho_load_dll(TCCState * s1, int fd, const char* filename, int lev)\n{\n    unsigned char buf[sizeof(struct mach_header_64)];\n    void *buf2;\n    uint32_t machofs = 0;\n    struct fat_header fh;\n    struct mach_header mh;\n    struct load_command *lc;\n    int i, swap = 0;\n    const char *soname = filename;\n    struct nlist_64 *symtab = 0;\n    uint32_t nsyms = 0;\n    char *strtab = 0;\n    uint32_t strsize = 0;\n    uint32_t iextdef = 0;\n    uint32_t nextdef = 0;\n\n  again:\n    if (full_read(fd, buf, sizeof(buf)) != sizeof(buf))\n      return -1;\n    memcpy(&fh, buf, sizeof(fh));\n    if (fh.magic == FAT_MAGIC || fh.magic == FAT_CIGAM) {\n        struct fat_arch *fa = load_data(fd, sizeof(fh),\n                                        fh.nfat_arch * sizeof(*fa));\n        swap = fh.magic == FAT_CIGAM;\n        for (i = 0; i < SWAP(fh.nfat_arch); i++)\n#ifdef TCC_TARGET_X86_64\n          if (SWAP(fa[i].cputype) == CPU_TYPE_X86_64\n              && SWAP(fa[i].cpusubtype) == CPU_SUBTYPE_X86_ALL)\n#elif defined TCC_TARGET_ARM64\n          if (SWAP(fa[i].cputype) == CPU_TYPE_ARM64\n              && SWAP(fa[i].cpusubtype) == CPU_SUBTYPE_ARM64_ALL)\n#endif\n            break;\n        if (i == SWAP(fh.nfat_arch)) {\n            tcc_free(fa);\n            return -1;\n        }\n        machofs = SWAP(fa[i].offset);\n        tcc_free(fa);\n        lseek(fd, machofs, SEEK_SET);\n        goto again;\n    } else if (fh.magic == FAT_MAGIC_64 || fh.magic == FAT_CIGAM_64) {\n        tcc_warning(\"%s: Mach-O fat 64bit files of type 0x%x not handled\",\n                    filename, fh.magic);\n        return -1;\n    }\n\n    memcpy(&mh, buf, sizeof(mh));\n    if (mh.magic != MH_MAGIC_64)\n      return -1;\n    dprintf(\"found Mach-O at %d\\n\", machofs);\n    buf2 = load_data(fd, machofs + sizeof(struct mach_header_64), mh.sizeofcmds);\n    for (i = 0, lc = buf2; i < mh.ncmds; i++) {\n        dprintf(\"lc %2d: 0x%08x\\n\", i, lc->cmd);\n        switch (lc->cmd) {\n        case LC_SYMTAB:\n        {\n            struct symtab_command *sc = (struct symtab_command*)lc;\n            nsyms = sc->nsyms;\n            symtab = load_data(fd, machofs + sc->symoff, nsyms * sizeof(*symtab));\n            strsize = sc->strsize;\n            strtab = load_data(fd, machofs + sc->stroff, strsize);\n            break;\n        }\n        case LC_ID_DYLIB:\n        {\n            struct dylib_command *dc = (struct dylib_command*)lc;\n            soname = (char*)lc + dc->name;\n            dprintf(\" ID_DYLIB %d 0x%x 0x%x %s\\n\",\n                    dc->timestamp, dc->current_version,\n                    dc->compatibility_version, soname);\n            break;\n        }\n        case LC_REEXPORT_DYLIB:\n        {\n            struct dylib_command *dc = (struct dylib_command*)lc;\n            char *name = (char*)lc + dc->name;\n            int subfd = open(name, O_RDONLY | O_BINARY);\n            dprintf(\" REEXPORT %s\\n\", name);\n            if (subfd < 0)\n              tcc_warning(\"can't open %s (reexported from %s)\", name, filename);\n            else {\n                /* Hopefully the REEXPORTs never form a cycle, we don't check\n                   for that!  */\n                macho_load_dll(s1, subfd, name, lev + 1);\n                close(subfd);\n            }\n            break;\n        }\n        case LC_DYSYMTAB:\n        {\n            struct dysymtab_command *dc = (struct dysymtab_command*)lc;\n            iextdef = dc->iextdefsym;\n            nextdef = dc->nextdefsym;\n            break;\n        }\n        }\n        lc = (struct load_command*) ((char*)lc + lc->cmdsize);\n    }\n\n    if (tcc_add_dllref(s1, soname, lev)->found)\n        goto the_end;\n\n    if (!nsyms || !nextdef)\n      tcc_warning(\"%s doesn't export any symbols?\", filename);\n\n    //dprintf(\"symbols (all):\\n\");\n    dprintf(\"symbols (exported):\\n\");\n    dprintf(\"    n: typ sec   desc              value name\\n\");\n    //for (i = 0; i < nsyms; i++) {\n    for (i = iextdef; i < iextdef + nextdef; i++) {\n        struct nlist_64 *sym = symtab + i;\n        dprintf(\"%5d: %3d %3d 0x%04x 0x%016lx %s\\n\",\n                i, sym->n_type, sym->n_sect, sym->n_desc, (long)sym->n_value,\n                strtab + sym->n_strx);\n        set_elf_sym(s1->dynsymtab_section, 0, 0,\n                    ELFW(ST_INFO)(STB_GLOBAL, STT_NOTYPE),\n                    0, SHN_UNDEF, strtab + sym->n_strx);\n    }\n\n  the_end:\n    tcc_free(strtab);\n    tcc_free(symtab);\n    tcc_free(buf2);\n    return 0;\n}\n"
        },
        {
          "name": "tccpe.c",
          "type": "blob",
          "size": 61.8515625,
          "content": "/*\n *  TCCPE.C - PE file output for the Tiny C Compiler\n *\n *  Copyright (c) 2005-2007 grischka\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"tcc.h\"\n\n#define PE_MERGE_DATA 1\n#define PE_PRINT_SECTIONS 0\n\n#ifndef _WIN32\n#define stricmp strcasecmp\n#define strnicmp strncasecmp\n#include <sys/stat.h> /* chmod() */\n#endif\n\n#ifdef TCC_TARGET_X86_64\n# define ADDR3264 ULONGLONG\n# define PE_IMAGE_REL IMAGE_REL_BASED_DIR64\n# define REL_TYPE_DIRECT R_X86_64_64\n# define R_XXX_THUNKFIX R_X86_64_PC32\n# define R_XXX_RELATIVE R_X86_64_RELATIVE\n# define R_XXX_FUNCCALL R_X86_64_PLT32\n# define IMAGE_FILE_MACHINE 0x8664\n# define RSRC_RELTYPE 3\n\n#elif defined TCC_TARGET_ARM\n# define ADDR3264 DWORD\n# define PE_IMAGE_REL IMAGE_REL_BASED_HIGHLOW\n# define REL_TYPE_DIRECT R_ARM_ABS32\n# define R_XXX_THUNKFIX R_ARM_ABS32\n# define R_XXX_RELATIVE R_ARM_RELATIVE\n# define R_XXX_FUNCCALL R_ARM_PC24\n# define R_XXX_FUNCCALL2 R_ARM_ABS32\n# define IMAGE_FILE_MACHINE 0x01C0\n# define RSRC_RELTYPE 7 /* ??? (not tested) */\n\n#elif defined TCC_TARGET_I386\n# define ADDR3264 DWORD\n# define PE_IMAGE_REL IMAGE_REL_BASED_HIGHLOW\n# define REL_TYPE_DIRECT R_386_32\n# define R_XXX_THUNKFIX R_386_32\n# define R_XXX_RELATIVE R_386_RELATIVE\n# define R_XXX_FUNCCALL R_386_PC32\n# define IMAGE_FILE_MACHINE 0x014C\n# define RSRC_RELTYPE 7 /* DIR32NB */\n\n#endif\n\n#ifndef IMAGE_NT_SIGNATURE\n/* ----------------------------------------------------------- */\n/* definitions below are from winnt.h */\n\ntypedef unsigned char BYTE;\ntypedef unsigned short WORD;\ntypedef unsigned int DWORD;\ntypedef unsigned long long ULONGLONG;\n#pragma pack(push, 1)\n\ntypedef struct _IMAGE_DOS_HEADER {  /* DOS .EXE header */\n    WORD e_magic;         /* Magic number */\n    WORD e_cblp;          /* Bytes on last page of file */\n    WORD e_cp;            /* Pages in file */\n    WORD e_crlc;          /* Relocations */\n    WORD e_cparhdr;       /* Size of header in paragraphs */\n    WORD e_minalloc;      /* Minimum extra paragraphs needed */\n    WORD e_maxalloc;      /* Maximum extra paragraphs needed */\n    WORD e_ss;            /* Initial (relative) SS value */\n    WORD e_sp;            /* Initial SP value */\n    WORD e_csum;          /* Checksum */\n    WORD e_ip;            /* Initial IP value */\n    WORD e_cs;            /* Initial (relative) CS value */\n    WORD e_lfarlc;        /* File address of relocation table */\n    WORD e_ovno;          /* Overlay number */\n    WORD e_res[4];        /* Reserved words */\n    WORD e_oemid;         /* OEM identifier (for e_oeminfo) */\n    WORD e_oeminfo;       /* OEM information; e_oemid specific */\n    WORD e_res2[10];      /* Reserved words */\n    DWORD e_lfanew;        /* File address of new exe header */\n} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n\n#define IMAGE_NT_SIGNATURE  0x00004550  /* PE00 */\n#define SIZE_OF_NT_SIGNATURE 4\n\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n\n#define IMAGE_SIZEOF_FILE_HEADER 20\n\ntypedef struct _IMAGE_DATA_DIRECTORY {\n    DWORD   VirtualAddress;\n    DWORD   Size;\n} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n\n\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    /* Standard fields. */\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n#ifndef TCC_TARGET_X86_64\n    DWORD   BaseOfData;\n#endif\n    /* NT additional fields. */\n    ADDR3264 ImageBase;\n    DWORD   SectionAlignment;\n    DWORD   FileAlignment;\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    ADDR3264 SizeOfStackReserve;\n    ADDR3264 SizeOfStackCommit;\n    ADDR3264 SizeOfHeapReserve;\n    ADDR3264 SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[16];\n} IMAGE_OPTIONAL_HEADER32, IMAGE_OPTIONAL_HEADER64, IMAGE_OPTIONAL_HEADER;\n\n#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   /* Export Directory */\n#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   /* Import Directory */\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   /* Resource Directory */\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   /* Exception Directory */\n#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   /* Security Directory */\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   /* Base Relocation Table */\n#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   /* Debug Directory */\n/*      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7      (X86 usage) */\n#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   /* Architecture Specific Data */\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   /* RVA of GP */\n#define IMAGE_DIRECTORY_ENTRY_TLS             9   /* TLS Directory */\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   /* Load Configuration Directory */\n#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   /* Bound Import Directory in headers */\n#define IMAGE_DIRECTORY_ENTRY_IAT            12   /* Import Address Table */\n#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   /* Delay Load Import Descriptors */\n#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   /* COM Runtime descriptor */\n\n/* Section header format. */\n#define IMAGE_SIZEOF_SHORT_NAME         8\n\ntypedef struct _IMAGE_SECTION_HEADER {\n    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];\n    union {\n            DWORD   PhysicalAddress;\n            DWORD   VirtualSize;\n    } Misc;\n    DWORD   VirtualAddress;\n    DWORD   SizeOfRawData;\n    DWORD   PointerToRawData;\n    DWORD   PointerToRelocations;\n    DWORD   PointerToLinenumbers;\n    WORD    NumberOfRelocations;\n    WORD    NumberOfLinenumbers;\n    DWORD   Characteristics;\n} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n\n#define IMAGE_SIZEOF_SECTION_HEADER     40\n\ntypedef struct _IMAGE_EXPORT_DIRECTORY {\n    DWORD Characteristics;\n    DWORD TimeDateStamp;\n    WORD MajorVersion;\n    WORD MinorVersion;\n    DWORD Name;\n    DWORD Base;\n    DWORD NumberOfFunctions;\n    DWORD NumberOfNames;\n    DWORD AddressOfFunctions;\n    DWORD AddressOfNames;\n    DWORD AddressOfNameOrdinals;\n} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;\n\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n    union {\n        DWORD Characteristics;\n        DWORD OriginalFirstThunk;\n    };\n    DWORD TimeDateStamp;\n    DWORD ForwarderChain;\n    DWORD Name;\n    DWORD FirstThunk;\n} IMAGE_IMPORT_DESCRIPTOR;\n\ntypedef struct _IMAGE_BASE_RELOCATION {\n    DWORD   VirtualAddress;\n    DWORD   SizeOfBlock;\n//  WORD    TypeOffset[1];\n} IMAGE_BASE_RELOCATION;\n\n#define IMAGE_SIZEOF_BASE_RELOCATION     8\n\n#define IMAGE_REL_BASED_ABSOLUTE         0\n#define IMAGE_REL_BASED_HIGH             1\n#define IMAGE_REL_BASED_LOW              2\n#define IMAGE_REL_BASED_HIGHLOW          3\n#define IMAGE_REL_BASED_HIGHADJ          4\n#define IMAGE_REL_BASED_MIPS_JMPADDR     5\n#define IMAGE_REL_BASED_SECTION          6\n#define IMAGE_REL_BASED_REL32            7\n#define IMAGE_REL_BASED_DIR64           10\n\n#define IMAGE_SCN_CNT_CODE                  0x00000020\n#define IMAGE_SCN_CNT_INITIALIZED_DATA      0x00000040\n#define IMAGE_SCN_CNT_UNINITIALIZED_DATA    0x00000080\n#define IMAGE_SCN_MEM_DISCARDABLE           0x02000000\n#define IMAGE_SCN_MEM_SHARED                0x10000000\n#define IMAGE_SCN_MEM_EXECUTE               0x20000000\n#define IMAGE_SCN_MEM_READ                  0x40000000\n#define IMAGE_SCN_MEM_WRITE                 0x80000000\n\n#pragma pack(pop)\n\n/* ----------------------------------------------------------- */\n#endif /* ndef IMAGE_NT_SIGNATURE */\n/* ----------------------------------------------------------- */\n\n#ifndef IMAGE_REL_BASED_DIR64\n# define IMAGE_REL_BASED_DIR64 10\n#endif\n\n#pragma pack(push, 1)\nstruct pe_header\n{\n    IMAGE_DOS_HEADER doshdr;\n    BYTE dosstub[0x40];\n    DWORD nt_sig;\n    IMAGE_FILE_HEADER filehdr;\n#ifdef TCC_TARGET_X86_64\n    IMAGE_OPTIONAL_HEADER64 opthdr;\n#else\n#ifdef _WIN64\n    IMAGE_OPTIONAL_HEADER32 opthdr;\n#else\n    IMAGE_OPTIONAL_HEADER opthdr;\n#endif\n#endif\n};\n\nstruct pe_reloc_header {\n    DWORD offset;\n    DWORD size;\n};\n\nstruct pe_rsrc_header {\n    struct _IMAGE_FILE_HEADER filehdr;\n    struct _IMAGE_SECTION_HEADER sectionhdr;\n};\n\nstruct pe_rsrc_reloc {\n    DWORD offset;\n    DWORD size;\n    WORD type;\n};\n#pragma pack(pop)\n\n/* ------------------------------------------------------------- */\n/* internal temporary structures */\n\nenum {\n    sec_text = 0,\n    sec_rdata ,\n    sec_data ,\n    sec_bss ,\n    sec_idata ,\n    sec_pdata ,\n    sec_other ,\n    sec_rsrc ,\n    sec_debug ,\n    sec_reloc ,\n    sec_last\n};\n\n#if 0\nstatic const DWORD pe_sec_flags[] = {\n    0x60000020, /* \".text\"     , */\n    0xC0000040, /* \".data\"     , */\n    0xC0000080, /* \".bss\"      , */\n    0x40000040, /* \".idata\"    , */\n    0x40000040, /* \".pdata\"    , */\n    0xE0000060, /* < other >   , */\n    0x40000040, /* \".rsrc\"     , */\n    0x42000802, /* \".stab\"     , */\n    0x42000040, /* \".reloc\"    , */\n};\n#endif\n\nstruct section_info {\n    int cls;\n    char name[32];\n    ADDR3264 sh_addr;\n    DWORD sh_size;\n    DWORD pe_flags;\n    Section *sec;\n    DWORD data_size;\n    IMAGE_SECTION_HEADER ish;\n};\n\nstruct import_symbol {\n    int sym_index;\n    int iat_index;\n    int thk_offset;\n};\n\nstruct pe_import_info {\n    int dll_index;\n    int sym_count;\n    struct import_symbol **symbols;\n};\n\nstruct pe_info {\n    TCCState *s1;\n    Section *reloc;\n    Section *thunk;\n    const char *filename;\n    int type;\n    DWORD sizeofheaders;\n    ADDR3264 imagebase;\n    const char *start_symbol;\n    DWORD start_addr;\n    DWORD imp_offs;\n    DWORD imp_size;\n    DWORD iat_offs;\n    DWORD iat_size;\n    DWORD exp_offs;\n    DWORD exp_size;\n    int subsystem;\n    DWORD section_align;\n    DWORD file_align;\n    struct section_info **sec_info;\n    int sec_count;\n    struct pe_import_info **imp_info;\n    int imp_count;\n};\n\n#define PE_NUL 0\n#define PE_DLL 1\n#define PE_GUI 2\n#define PE_EXE 3\n#define PE_RUN 4\n\n/* --------------------------------------------*/\n\nstatic const char *pe_export_name(TCCState *s1, ElfW(Sym) *sym)\n{\n    const char *name = (char*)symtab_section->link->data + sym->st_name;\n    if (s1->leading_underscore && name[0] == '_' && !(sym->st_other & ST_PE_STDCALL))\n        return name + 1;\n    return name;\n}\n\n\nstatic int dynarray_assoc(void **pp, int n, int key)\n{\n    int i;\n    for (i = 0; i < n; ++i, ++pp)\n    if (key == **(int **) pp)\n        return i;\n    return -1;\n}\n\nstatic DWORD umin(DWORD a, DWORD b)\n{\n    return a < b ? a : b;\n}\n\nstatic DWORD umax(DWORD a, DWORD b)\n{\n    return a < b ? b : a;\n}\n\nstatic DWORD pe_file_align(struct pe_info *pe, DWORD n)\n{\n    return (n + (pe->file_align - 1)) & ~(pe->file_align - 1);\n}\n\nstatic ADDR3264 pe_virtual_align(struct pe_info *pe, ADDR3264 n)\n{\n    return (n + (pe->section_align - 1)) & ~(ADDR3264)(pe->section_align - 1);\n}\n\nstatic void pe_align_section(Section *s, int a)\n{\n    int i = s->data_offset & (a-1);\n    if (i)\n        section_ptr_add(s, a - i);\n}\n\nstatic void pe_set_datadir(struct pe_header *hdr, int dir, DWORD addr, DWORD size)\n{\n    hdr->opthdr.DataDirectory[dir].VirtualAddress = addr;\n    hdr->opthdr.DataDirectory[dir].Size = size;\n}\n\nstruct pe_file {\n    FILE *op;\n    DWORD sum;\n    unsigned pos;\n};\n\nstatic int pe_fwrite(const void *data, int len, struct pe_file *pf)\n{\n    const WORD *p = data;\n    DWORD sum;\n    int ret, i;\n    pf->pos += (ret = fwrite(data, 1, len, pf->op));\n    sum = pf->sum;\n    for (i = len; i > 0; i -= 2) {\n        sum += (i >= 2) ? *p++ : *(BYTE*)p;\n        sum = (sum + (sum >> 16)) & 0xFFFF;\n    }\n    pf->sum = sum;\n    return len == ret ? 0 : -1;\n}\n\nstatic void pe_fpad(struct pe_file *pf, DWORD new_pos)\n{\n    char buf[256];\n    int n, diff = new_pos - pf->pos;\n    memset(buf, 0, sizeof buf);\n    while (diff > 0) {\n        diff -= n = umin(diff, sizeof buf);\n        fwrite(buf, n, 1, pf->op);\n    }\n    pf->pos = new_pos;\n}\n\n/*----------------------------------------------------------------------------*/\n/* PE-DWARF/COFF support\n   does not work with a mingw-gdb really but works with cv2pdb\n   (https://github.com/rainers/cv2pdb) */\n\n#define N_COFF_SYMS 0\n\nstatic const char dwarf_secs[] =\n{\n    \".debug_info\\0\"\n    \".debug_abbrev\\0\"\n    \".debug_line\\0\"\n    \".debug_aranges\\0\"\n    \".debug_str\\0\"\n    \".debug_line_str\\0\"\n};\n\nstatic const unsigned coff_strtab_size = 4 + sizeof dwarf_secs - 1;\n\nstatic int pe_put_long_secname(char *secname, const char *name)\n{\n    const char *d = dwarf_secs;\n    do {\n        if (0 == strcmp(d, name)) {\n            snprintf(secname, 8, \"/%d\", (int)(d - dwarf_secs + 4));\n            return 1;\n        }\n        d = strchr(d, 0) + 1;\n    } while (*d);\n    return 0;\n}\n\nstatic void pe_create_pdb(TCCState *s1, const char *exename)\n{\n    char buf[300]; int r;\n    snprintf(buf, sizeof buf, \"cv2pdb.exe %s\", exename);\n    r = system(buf);\n    strcpy(tcc_fileextension(strcpy(buf, exename)), \".pdb\");\n    if (r) {\n        tcc_error_noabort(\"could not create '%s'\\n(need working cv2pdb from https://github.com/rainers/cv2pdb)\", buf);\n    } else if (s1->verbose) {\n        printf(\"<- %s\\n\", buf);\n    }\n}\n\n/*----------------------------------------------------------------------------*/\nstatic int pe_write(struct pe_info *pe)\n{\n    static const struct pe_header pe_template = {\n    {\n    /* IMAGE_DOS_HEADER doshdr */\n    0x5A4D, /*WORD e_magic;         Magic number */\n    0x0090, /*WORD e_cblp;          Bytes on last page of file */\n    0x0003, /*WORD e_cp;            Pages in file */\n    0x0000, /*WORD e_crlc;          Relocations */\n\n    0x0004, /*WORD e_cparhdr;       Size of header in paragraphs */\n    0x0000, /*WORD e_minalloc;      Minimum extra paragraphs needed */\n    0xFFFF, /*WORD e_maxalloc;      Maximum extra paragraphs needed */\n    0x0000, /*WORD e_ss;            Initial (relative) SS value */\n\n    0x00B8, /*WORD e_sp;            Initial SP value */\n    0x0000, /*WORD e_csum;          Checksum */\n    0x0000, /*WORD e_ip;            Initial IP value */\n    0x0000, /*WORD e_cs;            Initial (relative) CS value */\n    0x0040, /*WORD e_lfarlc;        File address of relocation table */\n    0x0000, /*WORD e_ovno;          Overlay number */\n    {0,0,0,0}, /*WORD e_res[4];     Reserved words */\n    0x0000, /*WORD e_oemid;         OEM identifier (for e_oeminfo) */\n    0x0000, /*WORD e_oeminfo;       OEM information; e_oemid specific */\n    {0,0,0,0,0,0,0,0,0,0}, /*WORD e_res2[10];      Reserved words */\n    0x00000080  /*DWORD   e_lfanew;        File address of new exe header */\n    },{\n    /* BYTE dosstub[0x40] */\n    /* 14 code bytes + \"This program cannot be run in DOS mode.\\r\\r\\n$\" + 6 * 0x00 */\n    0x0e,0x1f,0xba,0x0e,0x00,0xb4,0x09,0xcd,0x21,0xb8,0x01,0x4c,0xcd,0x21,0x54,0x68,\n    0x69,0x73,0x20,0x70,0x72,0x6f,0x67,0x72,0x61,0x6d,0x20,0x63,0x61,0x6e,0x6e,0x6f,\n    0x74,0x20,0x62,0x65,0x20,0x72,0x75,0x6e,0x20,0x69,0x6e,0x20,0x44,0x4f,0x53,0x20,\n    0x6d,0x6f,0x64,0x65,0x2e,0x0d,0x0d,0x0a,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    },\n    0x00004550, /* DWORD nt_sig = IMAGE_NT_SIGNATURE */\n    {\n    /* IMAGE_FILE_HEADER filehdr */\n    IMAGE_FILE_MACHINE, /*WORD    Machine; */\n    0x0003, /*WORD    NumberOfSections; */\n    0x00000000, /*DWORD   TimeDateStamp; */\n    0x00000000, /*DWORD   PointerToSymbolTable; */\n    0x00000000, /*DWORD   NumberOfSymbols; */\n#if defined(TCC_TARGET_X86_64)\n    0x00F0, /*WORD    SizeOfOptionalHeader; */\n    0x022F  /*WORD    Characteristics; */\n#define CHARACTERISTICS_DLL 0x222E\n#elif defined(TCC_TARGET_I386)\n    0x00E0, /*WORD    SizeOfOptionalHeader; */\n    0x030F  /*WORD    Characteristics; */\n#define CHARACTERISTICS_DLL 0x230E\n#elif defined(TCC_TARGET_ARM)\n    0x00E0, /*WORD    SizeOfOptionalHeader; */\n    0x010F, /*WORD    Characteristics; */\n#define CHARACTERISTICS_DLL 0x230F\n#endif\n},{\n    /* IMAGE_OPTIONAL_HEADER opthdr */\n    /* Standard fields. */\n#ifdef TCC_TARGET_X86_64\n    0x020B, /*WORD    Magic; */\n#else\n    0x010B, /*WORD    Magic; */\n#endif\n    0x06, /*BYTE    MajorLinkerVersion; */\n    0x00, /*BYTE    MinorLinkerVersion; */\n    0x00000000, /*DWORD   SizeOfCode; */\n    0x00000000, /*DWORD   SizeOfInitializedData; */\n    0x00000000, /*DWORD   SizeOfUninitializedData; */\n    0x00000000, /*DWORD   AddressOfEntryPoint; */\n    0x00000000, /*DWORD   BaseOfCode; */\n#ifndef TCC_TARGET_X86_64\n    0x00000000, /*DWORD   BaseOfData; */\n#endif\n    /* NT additional fields. */\n#if defined(TCC_TARGET_ARM)\n    0x00100000,\t    /*DWORD   ImageBase; */\n#else\n    0x00400000,\t    /*DWORD   ImageBase; */\n#endif\n    0x00001000, /*DWORD   SectionAlignment; */\n    0x00000200, /*DWORD   FileAlignment; */\n    0x0004, /*WORD    MajorOperatingSystemVersion; */\n    0x0000, /*WORD    MinorOperatingSystemVersion; */\n    0x0000, /*WORD    MajorImageVersion; */\n    0x0000, /*WORD    MinorImageVersion; */\n    0x0004, /*WORD    MajorSubsystemVersion; */\n    0x0000, /*WORD    MinorSubsystemVersion; */\n    0x00000000, /*DWORD   Win32VersionValue; */\n    0x00000000, /*DWORD   SizeOfImage; */\n    0x00000200, /*DWORD   SizeOfHeaders; */\n    0x00000000, /*DWORD   CheckSum; */\n    0x0002, /*WORD    Subsystem; */\n    0x0000, /*WORD    DllCharacteristics; */\n    0x00100000, /*DWORD   SizeOfStackReserve; */\n    0x00001000, /*DWORD   SizeOfStackCommit; */\n    0x00100000, /*DWORD   SizeOfHeapReserve; */\n    0x00001000, /*DWORD   SizeOfHeapCommit; */\n    0x00000000, /*DWORD   LoaderFlags; */\n    0x00000010, /*DWORD   NumberOfRvaAndSizes; */\n\n    /* IMAGE_DATA_DIRECTORY DataDirectory[16]; */\n    {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},\n     {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}}\n    }};\n\n    struct pe_header pe_header = pe_template;\n\n    int i;\n    struct pe_file pf = {0};\n    DWORD file_offset;\n    struct section_info *si;\n    IMAGE_SECTION_HEADER *psh;\n    TCCState *s1 = pe->s1;\n    int need_strtab = 0;\n\n    pf.op = fopen(pe->filename, \"wb\");\n    if (NULL == pf.op)\n        return tcc_error_noabort(\"could not write '%s': %s\", pe->filename, strerror(errno));\n\n    pe->sizeofheaders = pe_file_align(pe,\n        sizeof (struct pe_header)\n        + pe->sec_count * sizeof (IMAGE_SECTION_HEADER)\n        );\n\n    file_offset = pe->sizeofheaders;\n\n    if (2 == pe->s1->verbose)\n        printf(\"-------------------------------\"\n               \"\\n  virt   file   size  section\" \"\\n\");\n    for (i = 0; i < pe->sec_count; ++i) {\n        DWORD addr, size;\n        const char *sh_name;\n\n        si = pe->sec_info[i];\n        sh_name = si->name;\n        addr = si->sh_addr - pe->imagebase;\n        size = si->sh_size;\n        psh = &si->ish;\n\n        if (2 == pe->s1->verbose)\n            printf(\"%6x %6x %6x  %s\\n\",\n                (unsigned)addr, (unsigned)file_offset, (unsigned)size, sh_name);\n\n        switch (si->cls) {\n            case sec_text:\n                if (!pe_header.opthdr.BaseOfCode)\n                    pe_header.opthdr.BaseOfCode = addr;\n                break;\n\n            case sec_data:\n#ifndef TCC_TARGET_X86_64\n                if (!pe_header.opthdr.BaseOfData)\n                    pe_header.opthdr.BaseOfData = addr;\n#endif\n                break;\n\n            case sec_bss:\n                break;\n\n            case sec_reloc:\n                pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_BASERELOC, addr, size);\n                break;\n\n            case sec_rsrc:\n                pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_RESOURCE, addr, size);\n                break;\n\n            case sec_pdata:\n                pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_EXCEPTION, addr, size);\n                break;\n        }\n\n        if (pe->imp_size) {\n            pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_IMPORT,\n                pe->imp_offs, pe->imp_size);\n            pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_IAT,\n                pe->iat_offs, pe->iat_size);\n        }\n        if (pe->exp_size) {\n            pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_EXPORT,\n                pe->exp_offs, pe->exp_size);\n        }\n\n        memcpy(psh->Name, sh_name, umin(strlen(sh_name), sizeof psh->Name));\n        if (si->cls == sec_debug)\n            need_strtab += pe_put_long_secname((char*)psh->Name, sh_name);\n\n        psh->Characteristics = si->pe_flags;\n        psh->VirtualAddress = addr;\n        psh->Misc.VirtualSize = size;\n        pe_header.opthdr.SizeOfImage =\n            umax(pe_virtual_align(pe, size + addr), pe_header.opthdr.SizeOfImage);\n\n        if (si->data_size) {\n            psh->PointerToRawData = file_offset;\n            file_offset = pe_file_align(pe, file_offset + si->data_size);\n            psh->SizeOfRawData = file_offset - psh->PointerToRawData;\n            if (si->cls == sec_text)\n                pe_header.opthdr.SizeOfCode += psh->SizeOfRawData;\n            else\n                pe_header.opthdr.SizeOfInitializedData += psh->SizeOfRawData;\n        }\n    }\n\n    //pe_header.filehdr.TimeDateStamp = time(NULL);\n    pe_header.filehdr.NumberOfSections = pe->sec_count;\n    pe_header.opthdr.AddressOfEntryPoint = pe->start_addr;\n    pe_header.opthdr.SizeOfHeaders = pe->sizeofheaders;\n    pe_header.opthdr.ImageBase = pe->imagebase;\n    pe_header.opthdr.Subsystem = pe->subsystem;\n    if (pe->s1->pe_stack_size)\n        pe_header.opthdr.SizeOfStackReserve = pe->s1->pe_stack_size;\n    if (PE_DLL == pe->type)\n        pe_header.filehdr.Characteristics = CHARACTERISTICS_DLL;\n    pe_header.filehdr.Characteristics |= pe->s1->pe_characteristics;\n    if (need_strtab) {\n        pe_header.filehdr.PointerToSymbolTable = file_offset;\n        pe_header.filehdr.NumberOfSymbols = N_COFF_SYMS;\n    }\n    pe_fwrite(&pe_header, sizeof pe_header, &pf);\n    for (i = 0; i < pe->sec_count; ++i)\n        pe_fwrite(&pe->sec_info[i]->ish, sizeof(IMAGE_SECTION_HEADER), &pf);\n\n    file_offset = pe->sizeofheaders;\n    for (i = 0; i < pe->sec_count; ++i) {\n        Section *s;\n        si = pe->sec_info[i];\n        if (!si->data_size)\n            continue;\n        for (s = si->sec; s; s = s->prev) {\n            pe_fpad(&pf, file_offset);\n            pe_fwrite(s->data, s->data_offset, &pf);\n            if (s->prev)\n                file_offset += s->prev->sh_addr - s->sh_addr;\n        }\n        file_offset = si->ish.PointerToRawData + si->ish.SizeOfRawData;\n        pe_fpad(&pf, file_offset);\n    }\n\n    if (need_strtab) {\n        /* create a tiny COFF string table with the long section names */\n        pe_fwrite(&coff_strtab_size, sizeof coff_strtab_size, &pf);\n        pe_fwrite(dwarf_secs, sizeof dwarf_secs - 1, &pf);\n        file_offset = pf.pos;\n    }\n\n    pf.sum += file_offset;\n    fseek(pf.op, offsetof(struct pe_header, opthdr.CheckSum), SEEK_SET);\n    pe_fwrite(&pf.sum, sizeof (DWORD), &pf);\n\n    fclose (pf.op);\n#ifndef _WIN32\n    chmod(pe->filename, 0777);\n#endif\n\n    if (2 == pe->s1->verbose)\n        printf(\"-------------------------------\\n\");\n    if (pe->s1->verbose)\n        printf(\"<- %s (%u bytes)\\n\", pe->filename, (unsigned)file_offset);\n\n    if (s1->do_debug & 16)\n        pe_create_pdb(s1, pe->filename);\n    return 0;\n}\n\n/*----------------------------------------------------------------------------*/\n\nstatic struct import_symbol *pe_add_import(struct pe_info *pe, int sym_index)\n{\n    int i;\n    int dll_index;\n    struct pe_import_info *p;\n    struct import_symbol *s;\n    ElfW(Sym) *isym;\n\n    isym = (ElfW(Sym) *)pe->s1->dynsymtab_section->data + sym_index;\n    dll_index = isym->st_size;\n\n    i = dynarray_assoc ((void**)pe->imp_info, pe->imp_count, dll_index);\n    if (-1 != i) {\n        p = pe->imp_info[i];\n        goto found_dll;\n    }\n    p = tcc_mallocz(sizeof *p);\n    p->dll_index = dll_index;\n    dynarray_add(&pe->imp_info, &pe->imp_count, p);\n\nfound_dll:\n    i = dynarray_assoc ((void**)p->symbols, p->sym_count, sym_index);\n    if (-1 != i)\n        return p->symbols[i];\n\n    s = tcc_mallocz(sizeof *s);\n    dynarray_add(&p->symbols, &p->sym_count, s);\n    s->sym_index = sym_index;\n    return s;\n}\n\nstatic void pe_free_imports(struct pe_info *pe)\n{\n    int i;\n    for (i = 0; i < pe->imp_count; ++i) {\n        struct pe_import_info *p = pe->imp_info[i];\n        dynarray_reset(&p->symbols, &p->sym_count);\n    }\n    dynarray_reset(&pe->imp_info, &pe->imp_count);\n}\n\n/*----------------------------------------------------------------------------*/\nstatic void pe_build_imports(struct pe_info *pe)\n{\n    int thk_ptr, ent_ptr, dll_ptr, sym_cnt, i;\n    DWORD rva_base = pe->thunk->sh_addr - pe->imagebase;\n    int ndlls = pe->imp_count;\n    TCCState *s1 = pe->s1;\n\n    for (sym_cnt = i = 0; i < ndlls; ++i)\n        sym_cnt += pe->imp_info[i]->sym_count;\n\n    if (0 == sym_cnt)\n        return;\n\n    pe_align_section(pe->thunk, 16);\n    pe->imp_size = (ndlls + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR);\n    pe->iat_size = (sym_cnt + ndlls) * sizeof(ADDR3264);\n    dll_ptr = pe->thunk->data_offset;\n    thk_ptr = dll_ptr + pe->imp_size;\n    ent_ptr = thk_ptr + pe->iat_size;\n    pe->imp_offs = dll_ptr + rva_base;\n    pe->iat_offs = thk_ptr + rva_base;\n    section_ptr_add(pe->thunk, pe->imp_size + 2*pe->iat_size);\n\n    for (i = 0; i < pe->imp_count; ++i) {\n        IMAGE_IMPORT_DESCRIPTOR *hdr;\n        int k, n, dllindex;\n        ADDR3264 v;\n        struct pe_import_info *p = pe->imp_info[i];\n        const char *name;\n        DLLReference *dllref;\n\n        dllindex = p->dll_index;\n        if (dllindex)\n            name = (dllref = pe->s1->loaded_dlls[dllindex-1])->name;\n        else\n            name = \"\", dllref = NULL;\n\n        /* put the dll name into the import header */\n        v = put_elf_str(pe->thunk, name);\n        hdr = (IMAGE_IMPORT_DESCRIPTOR*)(pe->thunk->data + dll_ptr);\n        hdr->FirstThunk = thk_ptr + rva_base;\n        hdr->OriginalFirstThunk = ent_ptr + rva_base;\n        hdr->Name = v + rva_base;\n\n        for (k = 0, n = p->sym_count; k <= n; ++k) {\n            if (k < n) {\n                int iat_index = p->symbols[k]->iat_index;\n                int sym_index = p->symbols[k]->sym_index;\n                ElfW(Sym) *imp_sym = (ElfW(Sym) *)pe->s1->dynsymtab_section->data + sym_index;\n                const char *name = (char*)pe->s1->dynsymtab_section->link->data + imp_sym->st_name;\n                int ordinal;\n\n                /* patch symbol (and possibly its underscored alias) */\n                do {\n                    ElfW(Sym) *esym = (ElfW(Sym) *)symtab_section->data + iat_index;\n                    iat_index = esym->st_value;\n                    esym->st_value = thk_ptr;\n                    esym->st_shndx = pe->thunk->sh_num;\n                } while (iat_index);\n\n                if (dllref)\n                    v = 0, ordinal = imp_sym->st_value; /* ordinal from pe_load_def */\n                else\n                    ordinal = 0, v = imp_sym->st_value; /* address from tcc_add_symbol() */\n\n#ifdef TCC_IS_NATIVE\n                if (pe->type == PE_RUN) {\n                    if (dllref) {\n                        if ( !dllref->handle )\n                            dllref->handle = LoadLibraryA(dllref->name);\n                        v = (ADDR3264)GetProcAddress(dllref->handle, ordinal?(char*)0+ordinal:name);\n                    }\n                    if (!v)\n                        tcc_error_noabort(\"could not resolve symbol '%s'\", name);\n                } else\n#endif\n                if (ordinal) {\n                    v = ordinal | (ADDR3264)1 << (sizeof(ADDR3264)*8 - 1);\n                } else {\n                    v = pe->thunk->data_offset + rva_base;\n                    section_ptr_add(pe->thunk, sizeof(WORD)); /* hint, not used */\n                    put_elf_str(pe->thunk, name);\n                }\n\n            } else {\n                v = 0; /* last entry is zero */\n            }\n\n            *(ADDR3264*)(pe->thunk->data+thk_ptr) =\n            *(ADDR3264*)(pe->thunk->data+ent_ptr) = v;\n            thk_ptr += sizeof (ADDR3264);\n            ent_ptr += sizeof (ADDR3264);\n        }\n        dll_ptr += sizeof(IMAGE_IMPORT_DESCRIPTOR);\n    }\n}\n\n/* ------------------------------------------------------------- */\n\nstruct pe_sort_sym\n{\n    int index;\n    const char *name;\n};\n\nstatic int sym_cmp(const void *va, const void *vb)\n{\n    const char *ca = (*(struct pe_sort_sym**)va)->name;\n    const char *cb = (*(struct pe_sort_sym**)vb)->name;\n    return strcmp(ca, cb);\n}\n\nstatic void pe_build_exports(struct pe_info *pe)\n{\n    ElfW(Sym) *sym;\n    int sym_index, sym_end;\n    DWORD rva_base, base_o, func_o, name_o, ord_o, str_o;\n    IMAGE_EXPORT_DIRECTORY *hdr;\n    int sym_count, ord;\n    struct pe_sort_sym **sorted, *p;\n    TCCState *s1 = pe->s1;\n\n    FILE *op;\n    char buf[260];\n    const char *dllname;\n    const char *name;\n\n    rva_base = pe->thunk->sh_addr - pe->imagebase;\n    sym_count = 0, sorted = NULL, op = NULL;\n\n    sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));\n    for (sym_index = 1; sym_index < sym_end; ++sym_index) {\n        sym = (ElfW(Sym)*)symtab_section->data + sym_index;\n        name = pe_export_name(pe->s1, sym);\n        if (sym->st_other & ST_PE_EXPORT) {\n            p = tcc_malloc(sizeof *p);\n            p->index = sym_index;\n            p->name = name;\n            dynarray_add(&sorted, &sym_count, p);\n        }\n#if 0\n        if (sym->st_other & ST_PE_EXPORT)\n            printf(\"export: %s\\n\", name);\n        if (sym->st_other & ST_PE_STDCALL)\n            printf(\"stdcall: %s\\n\", name);\n#endif\n    }\n\n    if (0 == sym_count)\n        return;\n\n    qsort (sorted, sym_count, sizeof *sorted, sym_cmp);\n\n    pe_align_section(pe->thunk, 16);\n    dllname = tcc_basename(pe->filename);\n\n    base_o = pe->thunk->data_offset;\n    func_o = base_o + sizeof(IMAGE_EXPORT_DIRECTORY);\n    name_o = func_o + sym_count * sizeof (DWORD);\n    ord_o = name_o + sym_count * sizeof (DWORD);\n    str_o = ord_o + sym_count * sizeof(WORD);\n\n    hdr = section_ptr_add(pe->thunk, str_o - base_o);\n    hdr->Characteristics        = 0;\n    hdr->Base                   = 1;\n    hdr->NumberOfFunctions      = sym_count;\n    hdr->NumberOfNames          = sym_count;\n    hdr->AddressOfFunctions     = func_o + rva_base;\n    hdr->AddressOfNames         = name_o + rva_base;\n    hdr->AddressOfNameOrdinals  = ord_o + rva_base;\n    hdr->Name                   = str_o + rva_base;\n    put_elf_str(pe->thunk, dllname);\n\n#if 1\n    /* automatically write exports to <output-filename>.def */\n    pstrcpy(buf, sizeof buf, pe->filename);\n    strcpy(tcc_fileextension(buf), \".def\");\n    op = fopen(buf, \"wb\");\n    if (NULL == op) {\n        tcc_error_noabort(\"could not create '%s': %s\", buf, strerror(errno));\n    } else {\n        fprintf(op, \"LIBRARY %s\\n\\nEXPORTS\\n\", dllname);\n        if (pe->s1->verbose)\n            printf(\"<- %s (%d symbol%s)\\n\", buf, sym_count, &\"s\"[sym_count < 2]);\n    }\n#endif\n\n    for (ord = 0; ord < sym_count; ++ord)\n    {\n        p = sorted[ord], sym_index = p->index, name = p->name;\n        /* insert actual address later in relocate_sections() */\n        put_elf_reloc(symtab_section, pe->thunk,\n            func_o, R_XXX_RELATIVE, sym_index);\n        *(DWORD*)(pe->thunk->data + name_o)\n            = pe->thunk->data_offset + rva_base;\n        *(WORD*)(pe->thunk->data + ord_o)\n            = ord;\n        put_elf_str(pe->thunk, name);\n        func_o += sizeof (DWORD);\n        name_o += sizeof (DWORD);\n        ord_o += sizeof (WORD);\n        if (op)\n            fprintf(op, \"%s\\n\", name);\n    }\n\n    pe->exp_offs = base_o + rva_base;\n    pe->exp_size = pe->thunk->data_offset - base_o;\n    dynarray_reset(&sorted, &sym_count);\n    if (op)\n        fclose(op);\n}\n\n/* ------------------------------------------------------------- */\nstatic void pe_build_reloc (struct pe_info *pe)\n{\n    DWORD offset, block_ptr, sh_addr, addr;\n    int count, i;\n    ElfW_Rel *rel, *rel_end;\n    Section *s = NULL, *sr;\n    struct pe_reloc_header *hdr;\n\n    sh_addr = offset = block_ptr = count = i = 0;\n    rel = rel_end = NULL;\n\n    for(;;) {\n        if (rel < rel_end) {\n            int type = ELFW(R_TYPE)(rel->r_info);\n            addr = rel->r_offset + sh_addr;\n            ++ rel;\n            if (type != REL_TYPE_DIRECT)\n                continue;\n            if (count == 0) { /* new block */\n                block_ptr = pe->reloc->data_offset;\n                section_ptr_add(pe->reloc, sizeof(struct pe_reloc_header));\n                offset = addr & 0xFFFFFFFF<<12;\n            }\n            if ((addr -= offset)  < (1<<12)) { /* one block spans 4k addresses */\n                WORD *wp = section_ptr_add(pe->reloc, sizeof (WORD));\n                *wp = addr | PE_IMAGE_REL<<12;\n                ++count;\n                continue;\n            }\n            -- rel;\n\n        } else if (s) {\n            sr = s->reloc;\n            if (sr) {\n                rel = (ElfW_Rel *)sr->data;\n                rel_end = (ElfW_Rel *)(sr->data + sr->data_offset);\n                sh_addr = s->sh_addr;\n            }\n            s = s->prev;\n            continue;\n\n        } else if (i < pe->sec_count) {\n            s = pe->sec_info[i]->sec, ++i;\n            continue;\n\n        } else if (!count)\n            break;\n\n        /* fill the last block and ready for a new one */\n        if (count & 1) /* align for DWORDS */\n            section_ptr_add(pe->reloc, sizeof(WORD)), ++count;\n        hdr = (struct pe_reloc_header *)(pe->reloc->data + block_ptr);\n        hdr -> offset = offset - pe->imagebase;\n        hdr -> size = count * sizeof(WORD) + sizeof(struct pe_reloc_header);\n        count = 0;\n    }\n}\n\n/* ------------------------------------------------------------- */\nstatic int pe_section_class(Section *s)\n{\n    int type, flags;\n    const char *name;\n    type = s->sh_type;\n    flags = s->sh_flags;\n    name = s->name;\n\n    if (0 == memcmp(name, \".stab\", 5) || 0 == memcmp(name, \".debug_\", 7)) {\n        return sec_debug;\n    } else if (flags & SHF_ALLOC) {\n        if (type == SHT_PROGBITS\n         || type == SHT_INIT_ARRAY\n         || type == SHT_FINI_ARRAY) {\n            if (flags & SHF_EXECINSTR)\n                return sec_text;\n            if (flags & SHF_WRITE)\n                return sec_data;\n            if (0 == strcmp(name, \".rsrc\"))\n                return sec_rsrc;\n            if (0 == strcmp(name, \".iedat\"))\n                return sec_idata;\n            if (0 == strcmp(name, \".pdata\"))\n                return sec_pdata;\n            return sec_rdata;\n        } else if (type == SHT_NOBITS) {\n            return sec_bss;\n        }\n        return sec_other;\n    } else {\n        if (0 == strcmp(name, \".reloc\"))\n            return sec_reloc;\n    }\n    return sec_last;\n}\n\nstatic int pe_assign_addresses (struct pe_info *pe)\n{\n    int i, k, n, c, nbs;\n    ADDR3264 addr;\n    int *sec_order, *sec_cls;\n    struct section_info *si;\n    Section *s;\n    TCCState *s1 = pe->s1;\n\n    if (PE_DLL == pe->type)\n        pe->reloc = new_section(pe->s1, \".reloc\", SHT_PROGBITS, 0);\n    //pe->thunk = new_section(pe->s1, \".iedat\", SHT_PROGBITS, SHF_ALLOC);\n\n    nbs = s1->nb_sections;\n    sec_order = tcc_mallocz(2 * sizeof (int) * nbs);\n    sec_cls = sec_order + nbs;\n    for (i = 1; i < nbs; ++i) {\n        s = s1->sections[i];\n        k = pe_section_class(s);\n        for (n = i; n > 1 && k < (c = sec_cls[n - 1]); --n)\n            sec_cls[n] = c, sec_order[n] = sec_order[n - 1];\n        sec_cls[n] = k, sec_order[n] = i;\n    }\n    si = NULL;\n    addr = pe->imagebase + 1;\n\n    for (i = 1; (c = sec_cls[i]) < sec_last; ++i) {\n        s = s1->sections[sec_order[i]];\n\n        if (PE_MERGE_DATA && c == sec_bss)\n            c = sec_data;\n\n        if (si && c == si->cls && c != sec_debug) {\n            /* merge with previous section */\n            s->sh_addr = addr = ((addr - 1) | (16 - 1)) + 1;\n        } else {\n            si = NULL;\n            s->sh_addr = addr = pe_virtual_align(pe, addr);\n        }\n\n        if (NULL == pe->thunk\n            && c == (data_section == rodata_section ? sec_data : sec_rdata))\n            pe->thunk = s;\n\n        if (s == pe->thunk) {\n            pe_build_imports(pe);\n            pe_build_exports(pe);\n        }\n        if (s == pe->reloc)\n            pe_build_reloc (pe);\n\n        if (0 == s->data_offset)\n            continue;\n\n        if (si)\n            goto add_section;\n\n        si = tcc_mallocz(sizeof *si);\n        dynarray_add(&pe->sec_info, &pe->sec_count, si);\n\n        strcpy(si->name, s->name);\n        si->cls = c;\n        si->sh_addr = addr;\n\n        si->pe_flags = IMAGE_SCN_MEM_READ;\n        if (s->sh_flags & SHF_EXECINSTR)\n            si->pe_flags |= IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE;\n        else if (s->sh_type == SHT_NOBITS)\n            si->pe_flags |= IMAGE_SCN_CNT_UNINITIALIZED_DATA;\n        else\n            si->pe_flags |= IMAGE_SCN_CNT_INITIALIZED_DATA;\n        if (s->sh_flags & SHF_WRITE)\n            si->pe_flags |= IMAGE_SCN_MEM_WRITE;\n        if (0 == (s->sh_flags & SHF_ALLOC))\n            si->pe_flags |= IMAGE_SCN_MEM_DISCARDABLE;\n\nadd_section:\n        addr += s->data_offset;\n        si->sh_size = addr - si->sh_addr;\n        if (s->sh_type != SHT_NOBITS) {\n            Section **ps = &si->sec;\n            while (*ps)\n                ps = &(*ps)->prev;\n            *ps = s, s->prev = NULL;\n            si->data_size = si->sh_size;\n        }\n        //printf(\"%08x %05x %08x %s\\n\", si->sh_addr, si->sh_size, si->pe_flags, s->name);\n    }\n#if 0\n    for (i = 1; i < nbs; ++i) {\n        Section *s = s1->sections[sec_order[i]];\n        int type = s->sh_type;\n        int flags = s->sh_flags;\n        printf(\"section %-16s %-10s %p %04x %s,%s,%s\\n\",\n            s->name,\n            type == SHT_PROGBITS ? \"progbits\" :\n            type == SHT_INIT_ARRAY ? \"initarr\" :\n            type == SHT_FINI_ARRAY ? \"finiarr\" :\n            type == SHT_NOBITS ? \"nobits\" :\n            type == SHT_SYMTAB ? \"symtab\" :\n            type == SHT_STRTAB ? \"strtab\" :\n            type == SHT_RELX ? \"rel\" : \"???\",\n            s->sh_addr,\n            (unsigned)s->data_offset,\n            flags & SHF_ALLOC ? \"alloc\" : \"\",\n            flags & SHF_WRITE ? \"write\" : \"\",\n            flags & SHF_EXECINSTR ? \"exec\" : \"\"\n            );\n        fflush(stdout);\n    }\n    s1->verbose = 2;\n#endif\n    tcc_free(sec_order);\n    return 0;\n}\n\n/*----------------------------------------------------------------------------*/\nstatic int pe_check_symbols(struct pe_info *pe)\n{\n    int sym_index, sym_end;\n    int ret = 0;\n    TCCState *s1 = pe->s1;\n\n    pe_align_section(text_section, 8);\n\n    sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));\n    for (sym_index = 1; sym_index < sym_end; ++sym_index) {\n        ElfW(Sym) *sym = (ElfW(Sym) *)symtab_section->data + sym_index;\n        if (sym->st_shndx == SHN_UNDEF) {\n            const char *name = (char*)symtab_section->link->data + sym->st_name;\n            unsigned type = ELFW(ST_TYPE)(sym->st_info);\n            int imp_sym;\n            struct import_symbol *is;\n\n            int _imp_, n;\n            char buffer[200];\n            const char *s, *p;\n\n            n = _imp_ = 0;\n            do {\n                s = pe_export_name(s1, sym);\n                if (n) {\n                    /* second try: */\n                    if (sym->st_other & ST_PE_STDCALL) {\n                        /* try w/0 stdcall deco (windows API convention) */\n                        p = strrchr(s, '@');\n                        if (!p || s[0] != '_')\n                            break;\n                        strcpy(buffer, s+1)[p-s-1] = 0, s = buffer;\n                    } else if (s[0] != '_') { /* try non-ansi function */\n                        buffer[0] = '_', strcpy(buffer + 1, s), s = buffer;\n                    } else if (0 == memcmp(s, \"_imp__\", 6)) { /* mingw 3.7 */\n                        s += 6, _imp_ = 1;\n                    } else if (0 == memcmp(s, \"__imp_\", 6)) { /* mingw 2.0 */\n                        s += 6, _imp_ = 1;\n                    } else {\n                        break;\n                    }\n                }\n                imp_sym = find_elf_sym(s1->dynsymtab_section, s);\n            } while (0 == imp_sym && ++n < 2);\n\n            //printf(\"pe_find_export (%d) %4x %s\\n\", n, imp_sym, name);\n            if (0 == imp_sym)\n                continue; /* will throw the 'undefined' error in relocate_syms() */\n\n            is = pe_add_import(pe, imp_sym);\n\n            if (type == STT_FUNC\n                /* symbols from assembler often have no type */\n                || type == STT_NOTYPE) {\n                unsigned offset = is->thk_offset;\n                if (offset) {\n                    /* got aliased symbol, like stricmp and _stricmp */\n                } else {\n                    unsigned char *p;\n\n                    /* add a helper symbol, will be patched later in\n                       pe_build_imports */\n                    sprintf(buffer, \"IAT.%s\", name);\n                    is->iat_index = put_elf_sym(\n                        symtab_section, 0, sizeof(DWORD),\n                        ELFW(ST_INFO)(STB_LOCAL, STT_OBJECT),\n                        0, SHN_UNDEF, buffer);\n\n                    offset = text_section->data_offset;\n                    is->thk_offset = offset;\n\n                    /* add the 'jmp IAT[x]' instruction */\n#ifdef TCC_TARGET_ARM\n                    p = section_ptr_add(text_section, 8+4); // room for code and address\n                    write32le(p + 0, 0xE59FC000); // arm code ldr ip, [pc] ; PC+8+0 = 0001xxxx\n                    write32le(p + 4, 0xE59CF000); // arm code ldr pc, [ip]\n                    put_elf_reloc(symtab_section, text_section,\n                        offset + 8, R_XXX_THUNKFIX, is->iat_index); // offset to IAT position\n#else\n                    p = section_ptr_add(text_section, 8);\n                    write16le(p, 0x25FF);\n#ifdef TCC_TARGET_X86_64\n                    write32le(p + 2, (DWORD)-4);\n#endif\n                    put_elf_reloc(symtab_section, text_section, \n                        offset + 2, R_XXX_THUNKFIX, is->iat_index);\n#endif\n                }\n                /* tcc_realloc might have altered sym's address */\n                sym = (ElfW(Sym) *)symtab_section->data + sym_index;\n                /* patch the original symbol */\n                sym->st_value = offset;\n                sym->st_shndx = text_section->sh_num;\n                sym->st_other &= ~ST_PE_EXPORT; /* do not export */\n\n            } else { /* STT_OBJECT */\n                if (0 == _imp_ && 0 == (sym->st_other & ST_PE_IMPORT))\n                    ret = tcc_error_noabort(\"symbol '%s' is missing __declspec(dllimport)\", name);\n                /* original symbol will be patched later in pe_build_imports */\n                sym->st_value = is->iat_index; /* chain potential alias */\n                is->iat_index = sym_index;\n            }\n\n        } else if (pe->s1->rdynamic\n                   && ELFW(ST_BIND)(sym->st_info) != STB_LOCAL) {\n            /* if -rdynamic option, then export all non local symbols */\n            sym->st_other |= ST_PE_EXPORT;\n        }\n    }\n    return ret;\n}\n\n/*----------------------------------------------------------------------------*/\n#if PE_PRINT_SECTIONS\nstatic void pe_print_section(FILE * f, Section * s)\n{\n    /* just if you're curious */\n    BYTE *p, *e, b;\n    int i, n, l, m;\n    p = s->data;\n    e = s->data + s->data_offset;\n    l = e - p;\n\n    fprintf(f, \"section  \\\"%s\\\"\", s->name);\n    if (s->link)\n        fprintf(f, \"\\nlink     \\\"%s\\\"\", s->link->name);\n    if (s->reloc)\n        fprintf(f, \"\\nreloc    \\\"%s\\\"\", s->reloc->name);\n    fprintf(f, \"\\nv_addr   %08X\", (unsigned)s->sh_addr);\n    fprintf(f, \"\\ncontents %08X\", (unsigned)l);\n    fprintf(f, \"\\n\\n\");\n\n    if (s->sh_type == SHT_NOBITS)\n        return;\n\n    if (0 == l)\n        return;\n\n    if (s->sh_type == SHT_SYMTAB)\n        m = sizeof(ElfW(Sym));\n    else if (s->sh_type == SHT_RELX)\n        m = sizeof(ElfW_Rel);\n    else\n        m = 16;\n\n    fprintf(f, \"%-8s\", \"offset\");\n    for (i = 0; i < m; ++i)\n        fprintf(f, \" %02x\", i);\n    n = 56;\n\n    if (s->sh_type == SHT_SYMTAB || s->sh_type == SHT_RELX) {\n        const char *fields1[] = {\n            \"name\",\n            \"value\",\n            \"size\",\n            \"bind\",\n            \"type\",\n            \"other\",\n            \"shndx\",\n            NULL\n        };\n\n        const char *fields2[] = {\n            \"offs\",\n            \"type\",\n            \"symb\",\n            NULL\n        };\n\n        const char **p;\n\n        if (s->sh_type == SHT_SYMTAB)\n            p = fields1, n = 106;\n        else\n            p = fields2, n = 58;\n\n        for (i = 0; p[i]; ++i)\n            fprintf(f, \"%6s\", p[i]);\n        fprintf(f, \"  symbol\");\n    }\n\n    fprintf(f, \"\\n\");\n    for (i = 0; i < n; ++i)\n        fprintf(f, \"-\");\n    fprintf(f, \"\\n\");\n\n    for (i = 0; i < l;)\n    {\n        fprintf(f, \"%08X\", i);\n        for (n = 0; n < m; ++n) {\n            if (n + i < l)\n                fprintf(f, \" %02X\", p[i + n]);\n            else\n                fprintf(f, \"   \");\n        }\n\n        if (s->sh_type == SHT_SYMTAB) {\n            ElfW(Sym) *sym = (ElfW(Sym) *) (p + i);\n            const char *name = s->link->data + sym->st_name;\n            fprintf(f, \"  %04X  %04X  %04X   %02X    %02X    %02X   %04X  \\\"%s\\\"\",\n                    (unsigned)sym->st_name,\n                    (unsigned)sym->st_value,\n                    (unsigned)sym->st_size,\n                    (unsigned)ELFW(ST_BIND)(sym->st_info),\n                    (unsigned)ELFW(ST_TYPE)(sym->st_info),\n                    (unsigned)sym->st_other,\n                    (unsigned)sym->st_shndx,\n                    name);\n\n        } else if (s->sh_type == SHT_RELX) {\n            ElfW_Rel *rel = (ElfW_Rel *) (p + i);\n            ElfW(Sym) *sym =\n                (ElfW(Sym) *) s->link->data + ELFW(R_SYM)(rel->r_info);\n            const char *name = s->link->link->data + sym->st_name;\n            fprintf(f, \"  %04X   %02X   %04X  \\\"%s\\\"\",\n                    (unsigned)rel->r_offset,\n                    (unsigned)ELFW(R_TYPE)(rel->r_info),\n                    (unsigned)ELFW(R_SYM)(rel->r_info),\n                    name);\n        } else {\n            fprintf(f, \"   \");\n            for (n = 0; n < m; ++n) {\n                if (n + i < l) {\n                    b = p[i + n];\n                    if (b < 32 || b >= 127)\n                        b = '.';\n                    fprintf(f, \"%c\", b);\n                }\n            }\n        }\n        i += m;\n        fprintf(f, \"\\n\");\n    }\n    fprintf(f, \"\\n\\n\");\n}\n\nstatic void pe_print_sections(TCCState *s1, const char *fname)\n{\n    Section *s;\n    FILE *f;\n    int i;\n    f = fopen(fname, \"w\");\n    for (i = 1; i < s1->nb_sections; ++i) {\n        s = s1->sections[i];\n        pe_print_section(f, s);\n    }\n    pe_print_section(f, s1->dynsymtab_section);\n    fclose(f);\n}\n#endif\n\n/* ------------------------------------------------------------- */\n\nST_FUNC int pe_putimport(TCCState *s1, int dllindex, const char *name, addr_t value)\n{\n    return set_elf_sym(\n        s1->dynsymtab_section,\n        value,\n        dllindex, /* st_size */\n        ELFW(ST_INFO)(STB_GLOBAL, STT_NOTYPE),\n        0,\n        value ? SHN_ABS : SHN_UNDEF,\n        name\n        );\n}\n\nstatic int read_mem(int fd, unsigned offset, void *buffer, unsigned len)\n{\n    lseek(fd, offset, SEEK_SET);\n    return len == read(fd, buffer, len);\n}\n\n/* ------------------------------------------------------------- */\n\nstatic int get_dllexports(int fd, char **pp)\n{\n    int i, k, l, n, n0, ret;\n    char *p;\n\n    IMAGE_SECTION_HEADER ish;\n    IMAGE_EXPORT_DIRECTORY ied;\n    IMAGE_DOS_HEADER dh;\n    IMAGE_FILE_HEADER ih;\n    DWORD sig, ref, addr;\n    DWORD *namep = NULL, p0 = 0, p1;\n\n    int pef_hdroffset, opt_hdroffset, sec_hdroffset;\n\n    n = n0 = 0;\n    p = NULL;\n    ret = 1;\n    if (!read_mem(fd, 0, &dh, sizeof dh))\n        goto the_end;\n    if (!read_mem(fd, dh.e_lfanew, &sig, sizeof sig))\n        goto the_end;\n    if (sig != 0x00004550)\n        goto the_end;\n    pef_hdroffset = dh.e_lfanew + sizeof sig;\n    if (!read_mem(fd, pef_hdroffset, &ih, sizeof ih))\n        goto the_end;\n    opt_hdroffset = pef_hdroffset + sizeof ih;\n    if (ih.Machine == 0x014C) {\n        IMAGE_OPTIONAL_HEADER32 oh;\n        sec_hdroffset = opt_hdroffset + sizeof oh;\n        if (!read_mem(fd, opt_hdroffset, &oh, sizeof oh))\n            goto the_end;\n        if (IMAGE_DIRECTORY_ENTRY_EXPORT >= oh.NumberOfRvaAndSizes)\n            goto the_end_0;\n        addr = oh.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\n    } else if (ih.Machine == 0x8664) {\n        IMAGE_OPTIONAL_HEADER64 oh;\n        sec_hdroffset = opt_hdroffset + sizeof oh;\n        if (!read_mem(fd, opt_hdroffset, &oh, sizeof oh))\n            goto the_end;\n        if (IMAGE_DIRECTORY_ENTRY_EXPORT >= oh.NumberOfRvaAndSizes)\n            goto the_end_0;\n        addr = oh.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\n    } else\n        goto the_end;\n\n    //printf(\"addr: %08x\\n\", addr);\n    for (i = 0; i < ih.NumberOfSections; ++i) {\n        if (!read_mem(fd, sec_hdroffset + i * sizeof ish, &ish, sizeof ish))\n            goto the_end;\n        //printf(\"vaddr: %08x\\n\", ish.VirtualAddress);\n        if (addr >= ish.VirtualAddress && addr < ish.VirtualAddress + ish.SizeOfRawData)\n            goto found;\n    }\n    goto the_end_0;\nfound:\n    ref = ish.VirtualAddress - ish.PointerToRawData;\n    if (!read_mem(fd, addr - ref, &ied, sizeof ied))\n        goto the_end;\n    k = ied.NumberOfNames;\n    if (k) {\n        namep = tcc_malloc(l = k * sizeof *namep);\n        if (!read_mem(fd, ied.AddressOfNames - ref, namep, l))\n            goto the_end;\n        for (i = l = 0; i < k; ++i) {\n            p1 = namep[i] - ref;\n            if (p1 != p0)\n                lseek(fd, p0 = p1, SEEK_SET), l = 0;\n            do {\n                if (0 == l) {\n                    if (n + 1000 >= n0)\n                        p = tcc_realloc(p, n0 += 1000);\n                    if ((l = read(fd, p + n, 1000 - 1)) <= 0)\n                        goto the_end;\n                }\n                --l, ++p0;\n            } while (p[n++]);\n        }\n        p[n] = 0;\n    }\nthe_end_0:\n    ret = 0;\nthe_end:\n    tcc_free(namep);\n    if (ret && p)\n        tcc_free(p), p = NULL;\n    *pp = p;\n    return ret;\n}\n\n/* -------------------------------------------------------------\n *  This is for compiled windows resources in 'coff' format\n *  as generated by 'windres.exe -O coff ...'.\n */\n\nstatic int pe_load_res(TCCState *s1, int fd)\n{\n    struct pe_rsrc_header hdr;\n    Section *rsrc_section;\n    int i, ret = -1, sym_index;\n    BYTE *ptr;\n    unsigned offs;\n\n    if (!read_mem(fd, 0, &hdr, sizeof hdr))\n        goto quit;\n\n    if (hdr.filehdr.Machine != IMAGE_FILE_MACHINE\n        || hdr.filehdr.NumberOfSections != 1\n        || strcmp((char*)hdr.sectionhdr.Name, \".rsrc\") != 0)\n        goto quit;\n\n    rsrc_section = new_section(s1, \".rsrc\", SHT_PROGBITS, SHF_ALLOC);\n    ptr = section_ptr_add(rsrc_section, hdr.sectionhdr.SizeOfRawData);\n    offs = hdr.sectionhdr.PointerToRawData;\n    if (!read_mem(fd, offs, ptr, hdr.sectionhdr.SizeOfRawData))\n        goto quit;\n    offs = hdr.sectionhdr.PointerToRelocations;\n    sym_index = put_elf_sym(symtab_section, 0, 0, 0, 0, rsrc_section->sh_num, \".rsrc\");\n    for (i = 0; i < hdr.sectionhdr.NumberOfRelocations; ++i) {\n        struct pe_rsrc_reloc rel;\n        if (!read_mem(fd, offs, &rel, sizeof rel))\n            goto quit;\n        // printf(\"rsrc_reloc: %x %x %x\\n\", rel.offset, rel.size, rel.type);\n        if (rel.type != RSRC_RELTYPE)\n            goto quit;\n        put_elf_reloc(symtab_section, rsrc_section,\n            rel.offset, R_XXX_RELATIVE, sym_index);\n        offs += sizeof rel;\n    }\n    ret = 0;\nquit:\n    return ret;\n}\n\n/* ------------------------------------------------------------- */\n\nstatic char *trimfront(char *p)\n{\n    while ((unsigned char)*p <= ' ' && *p && *p != '\\n')\n\t++p;\n    return p;\n}\n\n/*\nstatic char *trimback(char *a, char *e)\n{\n    while (e > a && (unsigned char)e[-1] <= ' ')\n\t--e;\n    *e = 0;;\n    return a;\n}*/\n\nstatic char *get_token(char **s, char *f)\n{\n    char *p = *s, *e;\n    p = e = trimfront(p);\n    while ((unsigned char)*e > ' ')\n        ++e;\n    *s = trimfront(e);\n    *f = **s; *e = 0;\n    return p;\n}\n\nstatic int pe_load_def(TCCState *s1, int fd)\n{\n    int state = 0, ret = -1, dllindex = 0, ord;\n    char dllname[80], *buf, *line, *p, *x, next;\n\n    buf = tcc_load_text(fd);\n    if (!buf)\n        return ret;\n\n    for (line = buf;; ++line)  {\n        p = get_token(&line, &next);\n        if (!(*p && *p != ';'))\n            goto skip;\n        switch (state) {\n        case 0:\n            if (0 != stricmp(p, \"LIBRARY\") || next == '\\n')\n                goto quit;\n            pstrcpy(dllname, sizeof dllname, get_token(&line, &next));\n            ++state;\n            break;\n        case 1:\n            if (0 != stricmp(p, \"EXPORTS\"))\n                goto quit;\n            ++state;\n            break;\n        case 2:\n            dllindex = tcc_add_dllref(s1, dllname, 0)->index;\n            ++state;\n            /* fall through */\n        default:\n            /* get ordinal and will store in sym->st_value */\n            ord = 0;\n            if (next == '@') {\n                x = get_token(&line, &next);\n                ord = (int)strtol(x + 1, &x, 10);\n            }\n            //printf(\"token %s ; %s : %d\\n\", dllname, p, ord);\n            pe_putimport(s1, dllindex, p, ord);\n            break;\n        }\nskip:\n        while ((unsigned char)next > ' ')\n            get_token(&line, &next);\n        if (next != '\\n')\n            break;\n    }\n    ret = 0;\nquit:\n    tcc_free(buf);\n    return ret;\n}\n\n/* ------------------------------------------------------------- */\n\nstatic int pe_load_dll(TCCState *s1, int fd, const char *filename)\n{\n    char *p, *q;\n    DLLReference *ref = tcc_add_dllref(s1, tcc_basename(filename), 0);\n    if (ref->found)\n        return 0;\n    if (get_dllexports(fd, &p))\n        return -1;\n    if (p) {\n        for (q = p; *q; q += 1 + strlen(q))\n            pe_putimport(s1, ref->index, q, 0);\n        tcc_free(p);\n    }\n    return 0;\n}\n\nST_FUNC int pe_load_file(struct TCCState *s1, int fd, const char *filename)\n{\n    int ret = -1;\n    char buf[10];\n    if (0 == strcmp(tcc_fileextension(filename), \".def\"))\n        ret = pe_load_def(s1, fd);\n    else if (pe_load_res(s1, fd) == 0)\n        ret = 0;\n    else if (read_mem(fd, 0, buf, 4) && 0 == memcmp(buf, \"MZ\", 2))\n        ret = pe_load_dll(s1, fd, filename);\n    return ret;\n}\n\nPUB_FUNC int tcc_get_dllexports(const char *filename, char **pp)\n{\n    int ret, fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n    ret = get_dllexports(fd, pp);\n    close(fd);\n    return ret;\n}\n\n/* ------------------------------------------------------------- */\n#ifdef TCC_TARGET_X86_64\nstatic unsigned pe_add_uwwind_info(TCCState *s1)\n{\n    if (NULL == s1->uw_pdata) {\n        s1->uw_pdata = find_section(s1, \".pdata\");\n        s1->uw_pdata->sh_addralign = 4;\n    }\n    if (0 == s1->uw_sym)\n        s1->uw_sym = put_elf_sym(symtab_section, 0, 0, 0, 0, text_section->sh_num, \".uw_base\");\n    if (0 == s1->uw_offs) {\n        /* As our functions all have the same stackframe, we use one entry for all */\n        static const unsigned char uw_info[] = {\n            0x01, // UBYTE: 3 Version , UBYTE: 5 Flags\n            0x04, // UBYTE Size of prolog\n            0x02, // UBYTE Count of unwind codes\n            0x05, // UBYTE: 4 Frame Register (rbp), UBYTE: 4 Frame Register offset (scaled)\n            // USHORT * n Unwind codes array (descending order)\n            // 0x0b, 0x01, 0xff, 0xff, // stack size\n            // UBYTE offset of end of instr in prolog + 1, UBYTE:4 operation, UBYTE:4 info\n            0x04, 0x03, // 3:0 UWOP_SET_FPREG (mov rsp -> rbp)\n            0x01, 0x50, // 0:5 UWOP_PUSH_NONVOL (push rbp)\n        };\n\n        Section *s = text_section;\n        unsigned char *p;\n\n        section_ptr_add(s, -s->data_offset & 3); /* align */\n        s1->uw_offs = s->data_offset;\n        p = section_ptr_add(s, sizeof uw_info);\n        memcpy(p, uw_info, sizeof uw_info);\n    }\n\n    return s1->uw_offs;\n}\n\nST_FUNC void pe_add_unwind_data(unsigned start, unsigned end, unsigned stack)\n{\n    TCCState *s1 = tcc_state;\n    Section *pd;\n    unsigned o, n, d;\n    struct /* _RUNTIME_FUNCTION */ {\n      DWORD BeginAddress;\n      DWORD EndAddress;\n      DWORD UnwindData;\n    } *p;\n\n    d = pe_add_uwwind_info(s1);\n    pd = s1->uw_pdata;\n    o = pd->data_offset;\n    p = section_ptr_add(pd, sizeof *p);\n\n    /* record this function */\n    p->BeginAddress = start;\n    p->EndAddress = end;\n    p->UnwindData = d;\n\n    /* put relocations on it */\n    for (n = o + sizeof *p; o < n; o += sizeof p->BeginAddress)\n        put_elf_reloc(symtab_section, pd, o, R_XXX_RELATIVE, s1->uw_sym);\n}\n#endif\n/* ------------------------------------------------------------- */\n#ifdef TCC_TARGET_X86_64\n#define PE_STDSYM(n,s) n\n#else\n#define PE_STDSYM(n,s) \"_\" n s\n#endif\n\nstatic void pe_add_runtime(TCCState *s1, struct pe_info *pe)\n{\n    const char *start_symbol;\n    int pe_type;\n\n    if (TCC_OUTPUT_DLL == s1->output_type) {\n        pe_type = PE_DLL;\n        start_symbol = PE_STDSYM(\"__dllstart\",\"@12\");\n    } else {\n        const char *run_symbol;\n        if (find_elf_sym(symtab_section, PE_STDSYM(\"WinMain\",\"@16\"))) {\n            start_symbol = \"__winstart\";\n            run_symbol = \"__runwinmain\";\n            pe_type = PE_GUI;\n        } else if (find_elf_sym(symtab_section, PE_STDSYM(\"wWinMain\",\"@16\"))) {\n            start_symbol = \"__wwinstart\";\n            run_symbol = \"__runwwinmain\";\n            pe_type = PE_GUI;\n        } else if (find_elf_sym(symtab_section, \"wmain\")) {\n            start_symbol = \"__wstart\";\n            run_symbol = \"__runwmain\";\n            pe_type = PE_EXE;\n        } else {\n            start_symbol =  \"__start\";\n            run_symbol = \"__runmain\";\n            pe_type = PE_EXE;\n            if (s1->pe_subsystem == 2)\n                pe_type = PE_GUI;\n        }\n\n        if (TCC_OUTPUT_MEMORY == s1->output_type && !s1->nostdlib)\n            start_symbol = run_symbol;\n    }\n    if (s1->elf_entryname) {\n        pe->start_symbol = start_symbol = s1->elf_entryname;\n    } else {\n        pe->start_symbol = start_symbol + 1;\n        if (!s1->leading_underscore || strchr(start_symbol, '@'))\n            ++start_symbol;\n    }\n\n#ifdef CONFIG_TCC_BACKTRACE\n    if (s1->do_backtrace) {\n#ifdef CONFIG_TCC_BCHECK\n        if (s1->do_bounds_check && s1->output_type != TCC_OUTPUT_DLL)\n            tcc_add_support(s1, \"bcheck.o\");\n#endif\n        if (s1->output_type == TCC_OUTPUT_EXE)\n            tcc_add_support(s1, \"bt-exe.o\");\n        if (s1->output_type == TCC_OUTPUT_DLL)\n            tcc_add_support(s1, \"bt-dll.o\");\n        if (s1->output_type != TCC_OUTPUT_DLL)\n            tcc_add_support(s1, \"bt-log.o\");\n        tcc_add_btstub(s1);\n    }\n#endif\n\n    /* grab the startup code from libtcc1.a */\n#ifdef TCC_IS_NATIVE\n    if (TCC_OUTPUT_MEMORY != s1->output_type || s1->run_main)\n#endif\n    set_global_sym(s1, start_symbol, NULL, 0);\n\n    if (0 == s1->nostdlib) {\n        static const char * const libs[] = {\n            \"msvcrt\", \"kernel32\", \"\", \"user32\", \"gdi32\", NULL\n        };\n        const char * const *pp, *p;\n        if (TCC_LIBTCC1[0])\n            tcc_add_support(s1, TCC_LIBTCC1);\n        s1->static_link = 0; /* no static crt for tcc */\n        for (pp = libs; 0 != (p = *pp); ++pp) {\n            if (*p)\n                tcc_add_library(s1, p);\n            else if (PE_DLL != pe_type && PE_GUI != pe_type)\n                break;\n        }\n    }\n\n    /* need this for 'tccelf.c:relocate_sections()' */\n    if (TCC_OUTPUT_DLL == s1->output_type)\n        s1->output_type = TCC_OUTPUT_EXE;\n    if (TCC_OUTPUT_MEMORY == s1->output_type)\n        pe_type = PE_RUN;\n    pe->type = pe_type;\n}\n\nstatic void pe_set_options(TCCState * s1, struct pe_info *pe)\n{\n    if (PE_DLL == pe->type) {\n        /* XXX: check if is correct for arm-pe target */\n        pe->imagebase = 0x10000000;\n    } else {\n#if defined(TCC_TARGET_ARM)\n        pe->imagebase = 0x00010000;\n#else\n        pe->imagebase = 0x00400000;\n#endif\n    }\n\n#if defined(TCC_TARGET_ARM)\n    /* we use \"console\" subsystem by default */\n    pe->subsystem = 9;\n#else\n    if (PE_DLL == pe->type || PE_GUI == pe->type)\n        pe->subsystem = 2;\n    else\n        pe->subsystem = 3;\n#endif\n    /* Allow override via -Wl,-subsystem=... option */\n    if (s1->pe_subsystem != 0)\n        pe->subsystem = s1->pe_subsystem;\n\n    /* set default file/section alignment */\n    if (pe->subsystem == 1) {\n        pe->section_align = 0x20;\n        pe->file_align = 0x20;\n    } else {\n        pe->section_align = 0x1000;\n        pe->file_align = 0x200;\n    }\n\n    if (s1->section_align != 0)\n        pe->section_align = s1->section_align;\n    if (s1->pe_file_align != 0)\n        pe->file_align = s1->pe_file_align;\n\n    if ((pe->subsystem >= 10) && (pe->subsystem <= 12))\n        pe->imagebase = 0;\n\n    if (s1->has_text_addr)\n        pe->imagebase = s1->text_addr;\n}\n\nST_FUNC int pe_output_file(TCCState *s1, const char *filename)\n{\n    struct pe_info pe;\n\n    memset(&pe, 0, sizeof pe);\n    pe.filename = filename;\n    pe.s1 = s1;\n    s1->filetype = 0;\n\n#ifdef CONFIG_TCC_BCHECK\n    tcc_add_bcheck(s1);\n#endif\n    tcc_add_pragma_libs(s1);\n    pe_add_runtime(s1, &pe);\n    resolve_common_syms(s1);\n    pe_set_options(s1, &pe);\n    pe_check_symbols(&pe);\n\n    if (s1->nb_errors)\n        ;\n    else if (filename) {\n        pe_assign_addresses(&pe);\n        relocate_syms(s1, s1->symtab, 0);\n        s1->pe_imagebase = pe.imagebase;\n        relocate_sections(s1);\n        pe.start_addr = (DWORD)\n            (get_sym_addr(s1, pe.start_symbol, 1, 1) - pe.imagebase);\n        if (0 == s1->nb_errors)\n            pe_write(&pe);\n        dynarray_reset(&pe.sec_info, &pe.sec_count);\n    } else {\n#ifdef TCC_IS_NATIVE\n        pe.thunk = data_section;\n        pe_build_imports(&pe);\n        s1->run_main = pe.start_symbol;\n#ifdef TCC_TARGET_X86_64\n        s1->uw_pdata = find_section(s1, \".pdata\");\n#endif\n#endif\n    }\n    pe_free_imports(&pe);\n#if PE_PRINT_SECTIONS\n    if (s1->g_debug & 8)\n        pe_print_sections(s1, \"tcc.log\");\n#endif\n    return s1->nb_errors ? -1 : 0;\n}\n\n/* ------------------------------------------------------------- */\n"
        },
        {
          "name": "tccpp.c",
          "type": "blob",
          "size": 109.1689453125,
          "content": "/*\n *  TCC - Tiny C Compiler\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define USING_GLOBALS\n#include \"tcc.h\"\n\n/* #define to 1 to enable (see parse_pp_string()) */\n#define ACCEPT_LF_IN_STRINGS 0\n\n/********************************************************/\n/* global variables */\n\nST_DATA int tok_flags;\nST_DATA int parse_flags;\n\nST_DATA struct BufferedFile *file;\nST_DATA int tok;\nST_DATA CValue tokc;\nST_DATA const int *macro_ptr;\nST_DATA CString tokcstr; /* current parsed string, if any */\n\n/* display benchmark infos */\nST_DATA int tok_ident;\nST_DATA TokenSym **table_ident;\nST_DATA int pp_expr;\n\n/* ------------------------------------------------------------------------- */\n\nstatic TokenSym *hash_ident[TOK_HASH_SIZE];\nstatic char token_buf[STRING_MAX_SIZE + 1];\nstatic CString cstr_buf;\nstatic TokenString tokstr_buf;\nstatic TokenString unget_buf;\nstatic unsigned char isidnum_table[256 - CH_EOF];\nstatic int pp_debug_tok, pp_debug_symv;\nstatic int pp_counter;\nstatic void tok_print(const int *str, const char *msg, ...);\nstatic void next_nomacro(void);\nstatic void parse_number(const char *p);\nstatic void parse_string(const char *p, int len);\n\nstatic struct TinyAlloc *toksym_alloc;\nstatic struct TinyAlloc *tokstr_alloc;\n\nstatic TokenString *macro_stack;\n\nstatic const char tcc_keywords[] = \n#define DEF(id, str) str \"\\0\"\n#include \"tcctok.h\"\n#undef DEF\n;\n\n/* WARNING: the content of this string encodes token numbers */\nstatic const unsigned char tok_two_chars[] =\n/* outdated -- gr\n    \"<=\\236>=\\235!=\\225&&\\240||\\241++\\244--\\242==\\224<<\\1>>\\2+=\\253\"\n    \"-=\\255*=\\252/=\\257%=\\245&=\\246^=\\336|=\\374->\\313..\\250##\\266\";\n*/{\n    '<','=', TOK_LE,\n    '>','=', TOK_GE,\n    '!','=', TOK_NE,\n    '&','&', TOK_LAND,\n    '|','|', TOK_LOR,\n    '+','+', TOK_INC,\n    '-','-', TOK_DEC,\n    '=','=', TOK_EQ,\n    '<','<', TOK_SHL,\n    '>','>', TOK_SAR,\n    '+','=', TOK_A_ADD,\n    '-','=', TOK_A_SUB,\n    '*','=', TOK_A_MUL,\n    '/','=', TOK_A_DIV,\n    '%','=', TOK_A_MOD,\n    '&','=', TOK_A_AND,\n    '^','=', TOK_A_XOR,\n    '|','=', TOK_A_OR,\n    '-','>', TOK_ARROW,\n    '.','.', TOK_TWODOTS,\n    '#','#', TOK_TWOSHARPS,\n    0\n};\n\nST_FUNC void skip(int c)\n{\n    if (tok != c) {\n        char tmp[40];\n        pstrcpy(tmp, sizeof tmp, get_tok_str(c, &tokc));\n        tcc_error(\"'%s' expected (got \\\"%s\\\")\", tmp, get_tok_str(tok, &tokc));\n\t}\n    next();\n}\n\nST_FUNC void expect(const char *msg)\n{\n    tcc_error(\"%s expected\", msg);\n}\n\n/* ------------------------------------------------------------------------- */\n/* Custom allocator for tiny objects */\n\n#define USE_TAL\n\n#ifndef USE_TAL\n#define tal_free(al, p) tcc_free(p)\n#define tal_realloc(al, p, size) tcc_realloc(p, size)\n#define tal_new(a,b,c)\n#define tal_delete(a)\n#else\n#if !defined(MEM_DEBUG)\n#define tal_free(al, p) tal_free_impl(al, p)\n#define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size)\n#define TAL_DEBUG_PARAMS\n#else\n#define TAL_DEBUG MEM_DEBUG\n//#define TAL_INFO 1 /* collect and dump allocators stats */\n#define tal_free(al, p) tal_free_impl(al, p, __FILE__, __LINE__)\n#define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size, __FILE__, __LINE__)\n#define TAL_DEBUG_PARAMS , const char *file, int line\n#define TAL_DEBUG_FILE_LEN 40\n#endif\n\n#define TOKSYM_TAL_SIZE     (768 * 1024) /* allocator for tiny TokenSym in table_ident */\n#define TOKSTR_TAL_SIZE     (768 * 1024) /* allocator for tiny TokenString instances */\n#define TOKSYM_TAL_LIMIT     256 /* prefer unique limits to distinguish allocators debug msgs */\n#define TOKSTR_TAL_LIMIT    1024 /* 256 * sizeof(int) */\n\ntypedef struct TinyAlloc {\n    unsigned  limit;\n    unsigned  size;\n    uint8_t *buffer;\n    uint8_t *p;\n    unsigned  nb_allocs;\n    struct TinyAlloc *next, *top;\n#ifdef TAL_INFO\n    unsigned  nb_peak;\n    unsigned  nb_total;\n    unsigned  nb_missed;\n    uint8_t *peak_p;\n#endif\n} TinyAlloc;\n\ntypedef struct tal_header_t {\n    unsigned  size;\n#ifdef TAL_DEBUG\n    int     line_num; /* negative line_num used for double free check */\n    char    file_name[TAL_DEBUG_FILE_LEN + 1];\n#endif\n} tal_header_t;\n\n/* ------------------------------------------------------------------------- */\n\nstatic TinyAlloc *tal_new(TinyAlloc **pal, unsigned limit, unsigned size)\n{\n    TinyAlloc *al = tcc_mallocz(sizeof(TinyAlloc));\n    al->p = al->buffer = tcc_malloc(size);\n    al->limit = limit;\n    al->size = size;\n    if (pal) *pal = al;\n    return al;\n}\n\nstatic void tal_delete(TinyAlloc *al)\n{\n    TinyAlloc *next;\n\ntail_call:\n    if (!al)\n        return;\n#ifdef TAL_INFO\n    fprintf(stderr, \"limit %4d  size %7d  nb_peak %5d  nb_total %7d  nb_missed %5d  usage %5.1f%%\\n\",\n            al->limit, al->size, al->nb_peak, al->nb_total, al->nb_missed,\n            (al->peak_p - al->buffer) * 100.0 / al->size);\n#endif\n#if TAL_DEBUG && TAL_DEBUG != 3 /* do not check TAL leaks with -DMEM_DEBUG=3 */\n    if (al->nb_allocs > 0) {\n        uint8_t *p;\n        fprintf(stderr, \"TAL_DEBUG: memory leak %d chunk(s) (limit= %d)\\n\",\n                al->nb_allocs, al->limit);\n        p = al->buffer;\n        while (p < al->p) {\n            tal_header_t *header = (tal_header_t *)p;\n            if (header->line_num > 0) {\n                fprintf(stderr, \"%s:%d: chunk of %d bytes leaked\\n\",\n                        header->file_name, header->line_num, header->size);\n            }\n            p += header->size + sizeof(tal_header_t);\n        }\n#if TAL_DEBUG == 2\n        exit(2);\n#endif\n    }\n#endif\n    next = al->next;\n    tcc_free(al->buffer);\n    tcc_free(al);\n    al = next;\n    goto tail_call;\n}\n\nstatic void tal_free_impl(TinyAlloc *al, void *p TAL_DEBUG_PARAMS)\n{\n    if (!p)\n        return;\ntail_call:\n    if (al->buffer <= (uint8_t *)p && (uint8_t *)p < al->buffer + al->size) {\n#ifdef TAL_DEBUG\n        tal_header_t *header = (((tal_header_t *)p) - 1);\n        if (header->line_num < 0) {\n            fprintf(stderr, \"%s:%d: TAL_DEBUG: double frees chunk from\\n\",\n                    file, line);\n            fprintf(stderr, \"%s:%d: %d bytes\\n\",\n                    header->file_name, (int)-header->line_num, (int)header->size);\n        } else\n            header->line_num = -header->line_num;\n#endif\n        al->nb_allocs--;\n        if (!al->nb_allocs)\n            al->p = al->buffer;\n    } else if (al->next) {\n        al = al->next;\n        goto tail_call;\n    }\n    else\n        tcc_free(p);\n}\n\nstatic void *tal_realloc_impl(TinyAlloc **pal, void *p, unsigned size TAL_DEBUG_PARAMS)\n{\n    tal_header_t *header;\n    void *ret;\n    int is_own;\n    unsigned adj_size = (size + 3) & -4;\n    TinyAlloc *al = *pal;\n\ntail_call:\n    is_own = (al->buffer <= (uint8_t *)p && (uint8_t *)p < al->buffer + al->size);\n    if ((!p || is_own) && size <= al->limit) {\n        if (al->p - al->buffer + adj_size + sizeof(tal_header_t) < al->size) {\n            header = (tal_header_t *)al->p;\n            header->size = adj_size;\n#ifdef TAL_DEBUG\n            { int ofs = strlen(file) - TAL_DEBUG_FILE_LEN;\n            strncpy(header->file_name, file + (ofs > 0 ? ofs : 0), TAL_DEBUG_FILE_LEN);\n            header->file_name[TAL_DEBUG_FILE_LEN] = 0;\n            header->line_num = line; }\n#endif\n            ret = al->p + sizeof(tal_header_t);\n            al->p += adj_size + sizeof(tal_header_t);\n            if (is_own) {\n                header = (((tal_header_t *)p) - 1);\n                if (p) memcpy(ret, p, header->size);\n#ifdef TAL_DEBUG\n                header->line_num = -header->line_num;\n#endif\n            } else {\n                al->nb_allocs++;\n            }\n#ifdef TAL_INFO\n            if (al->nb_peak < al->nb_allocs)\n                al->nb_peak = al->nb_allocs;\n            if (al->peak_p < al->p)\n                al->peak_p = al->p;\n            al->nb_total++;\n#endif\n            return ret;\n        } else if (is_own) {\n            al->nb_allocs--;\n            ret = tal_realloc(*pal, 0, size);\n            header = (((tal_header_t *)p) - 1);\n            if (p) memcpy(ret, p, header->size);\n#ifdef TAL_DEBUG\n            header->line_num = -header->line_num;\n#endif\n            return ret;\n        }\n        if (al->next) {\n            al = al->next;\n        } else {\n            TinyAlloc *bottom = al, *next = al->top ? al->top : al;\n\n            al = tal_new(pal, next->limit, next->size * 2);\n            al->next = next;\n            bottom->top = al;\n        }\n        goto tail_call;\n    }\n    if (is_own) {\n        al->nb_allocs--;\n        ret = tcc_malloc(size);\n        header = (((tal_header_t *)p) - 1);\n        if (p) memcpy(ret, p, header->size);\n#ifdef TAL_DEBUG\n        header->line_num = -header->line_num;\n#endif\n    } else if (al->next) {\n        al = al->next;\n        goto tail_call;\n    } else\n        ret = tcc_realloc(p, size);\n#ifdef TAL_INFO\n    al->nb_missed++;\n#endif\n    return ret;\n}\n\n#endif /* USE_TAL */\n\n/* ------------------------------------------------------------------------- */\n/* CString handling */\nstatic void cstr_realloc(CString *cstr, int new_size)\n{\n    int size;\n\n    size = cstr->size_allocated;\n    if (size < 8)\n        size = 8; /* no need to allocate a too small first string */\n    while (size < new_size)\n        size = size * 2;\n    cstr->data = tcc_realloc(cstr->data, size);\n    cstr->size_allocated = size;\n}\n\n/* add a byte */\nST_INLN void cstr_ccat(CString *cstr, int ch)\n{\n    int size;\n    size = cstr->size + 1;\n    if (size > cstr->size_allocated)\n        cstr_realloc(cstr, size);\n    cstr->data[size - 1] = ch;\n    cstr->size = size;\n}\n\nST_INLN char *unicode_to_utf8 (char *b, uint32_t Uc)\n{\n    if (Uc<0x80) *b++=Uc;\n    else if (Uc<0x800) *b++=192+Uc/64, *b++=128+Uc%64;\n    else if (Uc-0xd800u<0x800) goto error;\n    else if (Uc<0x10000) *b++=224+Uc/4096, *b++=128+Uc/64%64, *b++=128+Uc%64;\n    else if (Uc<0x110000) *b++=240+Uc/262144, *b++=128+Uc/4096%64, *b++=128+Uc/64%64, *b++=128+Uc%64;\n    else error: tcc_error(\"0x%x is not a valid universal character\", Uc);\n    return b;\n}\n\n/* add a unicode character expanded into utf8 */\nST_INLN void cstr_u8cat(CString *cstr, int ch)\n{\n    char buf[4], *e;\n    e = unicode_to_utf8(buf, (uint32_t)ch);\n    cstr_cat(cstr, buf, e - buf);\n}\n\n/* add string of 'len', or of its len/len+1 when 'len' == -1/0 */\nST_FUNC void cstr_cat(CString *cstr, const char *str, int len)\n{\n    int size;\n    if (len <= 0)\n        len = strlen(str) + 1 + len;\n    size = cstr->size + len;\n    if (size > cstr->size_allocated)\n        cstr_realloc(cstr, size);\n    memmove(cstr->data + cstr->size, str, len);\n    cstr->size = size;\n}\n\n/* add a wide char */\nST_FUNC void cstr_wccat(CString *cstr, int ch)\n{\n    int size;\n    size = cstr->size + sizeof(nwchar_t);\n    if (size > cstr->size_allocated)\n        cstr_realloc(cstr, size);\n    *(nwchar_t *)(cstr->data + size - sizeof(nwchar_t)) = ch;\n    cstr->size = size;\n}\n\nST_FUNC void cstr_new(CString *cstr)\n{\n    memset(cstr, 0, sizeof(CString));\n}\n\n/* free string and reset it to NULL */\nST_FUNC void cstr_free(CString *cstr)\n{\n    tcc_free(cstr->data);\n}\n\n/* reset string to empty */\nST_FUNC void cstr_reset(CString *cstr)\n{\n    cstr->size = 0;\n}\n\nST_FUNC int cstr_vprintf(CString *cstr, const char *fmt, va_list ap)\n{\n    va_list v;\n    int len, size = 80;\n    for (;;) {\n        size += cstr->size;\n        if (size > cstr->size_allocated)\n            cstr_realloc(cstr, size);\n        size = cstr->size_allocated - cstr->size;\n        va_copy(v, ap);\n        len = vsnprintf(cstr->data + cstr->size, size, fmt, v);\n        va_end(v);\n        if (len >= 0 && len < size)\n            break;\n        size *= 2;\n    }\n    cstr->size += len;\n    return len;\n}\n\nST_FUNC int cstr_printf(CString *cstr, const char *fmt, ...)\n{\n    va_list ap; int len;\n    va_start(ap, fmt);\n    len = cstr_vprintf(cstr, fmt, ap);\n    va_end(ap);\n    return len;\n}\n\n/* XXX: unicode ? */\nstatic void add_char(CString *cstr, int c)\n{\n    if (c == '\\'' || c == '\\\"' || c == '\\\\') {\n        /* XXX: could be more precise if char or string */\n        cstr_ccat(cstr, '\\\\');\n    }\n    if (c >= 32 && c <= 126) {\n        cstr_ccat(cstr, c);\n    } else {\n        cstr_ccat(cstr, '\\\\');\n        if (c == '\\n') {\n            cstr_ccat(cstr, 'n');\n        } else {\n            cstr_ccat(cstr, '0' + ((c >> 6) & 7));\n            cstr_ccat(cstr, '0' + ((c >> 3) & 7));\n            cstr_ccat(cstr, '0' + (c & 7));\n        }\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/* allocate a new token */\nstatic TokenSym *tok_alloc_new(TokenSym **pts, const char *str, int len)\n{\n    TokenSym *ts, **ptable;\n    int i;\n\n    if (tok_ident >= SYM_FIRST_ANOM) \n        tcc_error(\"memory full (symbols)\");\n\n    /* expand token table if needed */\n    i = tok_ident - TOK_IDENT;\n    if ((i % TOK_ALLOC_INCR) == 0) {\n        ptable = tcc_realloc(table_ident, (i + TOK_ALLOC_INCR) * sizeof(TokenSym *));\n        table_ident = ptable;\n    }\n\n    ts = tal_realloc(toksym_alloc, 0, sizeof(TokenSym) + len);\n    table_ident[i] = ts;\n    ts->tok = tok_ident++;\n    ts->sym_define = NULL;\n    ts->sym_label = NULL;\n    ts->sym_struct = NULL;\n    ts->sym_identifier = NULL;\n    ts->len = len;\n    ts->hash_next = NULL;\n    memcpy(ts->str, str, len);\n    ts->str[len] = '\\0';\n    *pts = ts;\n    return ts;\n}\n\n#define TOK_HASH_INIT 1\n#define TOK_HASH_FUNC(h, c) ((h) + ((h) << 5) + ((h) >> 27) + (c))\n\n\n/* find a token and add it if not found */\nST_FUNC TokenSym *tok_alloc(const char *str, int len)\n{\n    TokenSym *ts, **pts;\n    int i;\n    unsigned int h;\n    \n    h = TOK_HASH_INIT;\n    for(i=0;i<len;i++)\n        h = TOK_HASH_FUNC(h, ((unsigned char *)str)[i]);\n    h &= (TOK_HASH_SIZE - 1);\n\n    pts = &hash_ident[h];\n    for(;;) {\n        ts = *pts;\n        if (!ts)\n            break;\n        if (ts->len == len && !memcmp(ts->str, str, len))\n            return ts;\n        pts = &(ts->hash_next);\n    }\n    return tok_alloc_new(pts, str, len);\n}\n\nST_FUNC int tok_alloc_const(const char *str)\n{\n    return tok_alloc(str, strlen(str))->tok;\n}\n\n\n/* XXX: buffer overflow */\n/* XXX: float tokens */\nST_FUNC const char *get_tok_str(int v, CValue *cv)\n{\n    char *p;\n    int i, len;\n\n    cstr_reset(&cstr_buf);\n    p = cstr_buf.data;\n\n    switch(v) {\n    case TOK_CINT:\n    case TOK_CUINT:\n    case TOK_CLONG:\n    case TOK_CULONG:\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n        /* XXX: not quite exact, but only useful for testing  */\n#ifdef _WIN32\n        sprintf(p, \"%u\", (unsigned)cv->i);\n#else\n        sprintf(p, \"%llu\", (unsigned long long)cv->i);\n#endif\n        break;\n    case TOK_LCHAR:\n        cstr_ccat(&cstr_buf, 'L');\n    case TOK_CCHAR:\n        cstr_ccat(&cstr_buf, '\\'');\n        add_char(&cstr_buf, cv->i);\n        cstr_ccat(&cstr_buf, '\\'');\n        cstr_ccat(&cstr_buf, '\\0');\n        break;\n    case TOK_PPNUM:\n    case TOK_PPSTR:\n        return (char*)cv->str.data;\n    case TOK_LSTR:\n        cstr_ccat(&cstr_buf, 'L');\n    case TOK_STR:\n        cstr_ccat(&cstr_buf, '\\\"');\n        if (v == TOK_STR) {\n            len = cv->str.size - 1;\n            for(i=0;i<len;i++)\n                add_char(&cstr_buf, ((unsigned char *)cv->str.data)[i]);\n        } else {\n            len = (cv->str.size / sizeof(nwchar_t)) - 1;\n            for(i=0;i<len;i++)\n                add_char(&cstr_buf, ((nwchar_t *)cv->str.data)[i]);\n        }\n        cstr_ccat(&cstr_buf, '\\\"');\n        cstr_ccat(&cstr_buf, '\\0');\n        break;\n\n    case TOK_CFLOAT:\n        return strcpy(p, \"<float>\");\n    case TOK_CDOUBLE:\n        return strcpy(p, \"<double>\");\n    case TOK_CLDOUBLE:\n        return strcpy(p, \"<long double>\");\n    case TOK_LINENUM:\n        return strcpy(p, \"<linenumber>\");\n\n    /* above tokens have value, the ones below don't */\n    case TOK_LT:\n        v = '<';\n        goto addv;\n    case TOK_GT:\n        v = '>';\n        goto addv;\n    case TOK_DOTS:\n        return strcpy(p, \"...\");\n    case TOK_A_SHL:\n        return strcpy(p, \"<<=\");\n    case TOK_A_SAR:\n        return strcpy(p, \">>=\");\n    case TOK_EOF:\n        return strcpy(p, \"<eof>\");\n    case 0: /* anonymous nameless symbols */\n        return strcpy(p, \"<no name>\");\n    default:\n        v &= ~(SYM_FIELD | SYM_STRUCT);\n        if (v < TOK_IDENT) {\n            /* search in two bytes table */\n            const unsigned char *q = tok_two_chars;\n            while (*q) {\n                if (q[2] == v) {\n                    *p++ = q[0];\n                    *p++ = q[1];\n                    *p = '\\0';\n                    return cstr_buf.data;\n                }\n                q += 3;\n            }\n            if (v >= 127 || (v < 32 && !is_space(v) && v != '\\n')) {\n                sprintf(p, \"<\\\\x%02x>\", v);\n                break;\n            }\n    addv:\n            *p++ = v;\n            *p = '\\0';\n        } else if (v < tok_ident) {\n            return table_ident[v - TOK_IDENT]->str;\n        } else if (v >= SYM_FIRST_ANOM) {\n            /* special name for anonymous symbol */\n            sprintf(p, \"L.%u\", v - SYM_FIRST_ANOM);\n        } else {\n            /* should never happen */\n            return NULL;\n        }\n        break;\n    }\n    return cstr_buf.data;\n}\n\n/* return the current character, handling end of block if necessary\n   (but not stray) */\nstatic int handle_eob(void)\n{\n    BufferedFile *bf = file;\n    int len;\n\n    /* only tries to read if really end of buffer */\n    if (bf->buf_ptr >= bf->buf_end) {\n        if (bf->fd >= 0) {\n#if defined(PARSE_DEBUG)\n            len = 1;\n#else\n            len = IO_BUF_SIZE;\n#endif\n            len = read(bf->fd, bf->buffer, len);\n            if (len < 0)\n                len = 0;\n        } else {\n            len = 0;\n        }\n        total_bytes += len;\n        bf->buf_ptr = bf->buffer;\n        bf->buf_end = bf->buffer + len;\n        *bf->buf_end = CH_EOB;\n    }\n    if (bf->buf_ptr < bf->buf_end) {\n        return bf->buf_ptr[0];\n    } else {\n        bf->buf_ptr = bf->buf_end;\n        return CH_EOF;\n    }\n}\n\n/* read next char from current input file and handle end of input buffer */\nstatic int next_c(void)\n{\n    int ch = *++file->buf_ptr;\n    /* end of buffer/file handling */\n    if (ch == CH_EOB && file->buf_ptr >= file->buf_end)\n        ch = handle_eob();\n    return ch;\n}\n\n/* input with '\\[\\r]\\n' handling. */\nstatic int handle_stray_noerror(int err)\n{\n    int ch;\n    while ((ch = next_c()) == '\\\\') {\n        ch = next_c();\n        if (ch == '\\n') {\n    newl:\n            file->line_num++;\n        } else {\n            if (ch == '\\r') {\n                ch = next_c();\n                if (ch == '\\n')\n                    goto newl;\n                *--file->buf_ptr = '\\r';\n            }\n            if (err)\n                tcc_error(\"stray '\\\\' in program\");\n            /* may take advantage of 'BufferedFile.unget[4}' */\n            return *--file->buf_ptr = '\\\\';\n        }\n    }\n    return ch;\n}\n\n#define ninp() handle_stray_noerror(0)\n\n/* handle '\\\\' in strings, comments and skipped regions */\nstatic int handle_bs(uint8_t **p)\n{\n    int c;\n    file->buf_ptr = *p - 1;\n    c = ninp();\n    *p = file->buf_ptr;\n    return c;\n}\n\n/* skip the stray and handle the \\\\n case. Output an error if\n   incorrect char after the stray */\nstatic int handle_stray(uint8_t **p)\n{\n    int c;\n    file->buf_ptr = *p - 1;\n    c = handle_stray_noerror(!(parse_flags & PARSE_FLAG_ACCEPT_STRAYS));\n    *p = file->buf_ptr;\n    return c;\n}\n\n/* handle the complicated stray case */\n#define PEEKC(c, p)\\\n{\\\n    c = *++p;\\\n    if (c == '\\\\')\\\n        c = handle_stray(&p); \\\n}\n\nstatic int skip_spaces(void)\n{\n    int ch;\n    --file->buf_ptr;\n    do {\n        ch = ninp();\n    } while (isidnum_table[ch - CH_EOF] & IS_SPC);\n    return ch;\n}\n\n/* single line C++ comments */\nstatic uint8_t *parse_line_comment(uint8_t *p)\n{\n    int c;\n    for(;;) {\n        for (;;) {\n            c = *++p;\n    redo:\n            if (c == '\\n' || c == '\\\\')\n                break;\n            c = *++p;\n            if (c == '\\n' || c == '\\\\')\n                break;\n        }\n        if (c == '\\n')\n            break;\n        c = handle_bs(&p);\n        if (c == CH_EOF)\n            break;\n        if (c != '\\\\')\n            goto redo;\n    }\n    return p;\n}\n\n/* C comments */\nstatic uint8_t *parse_comment(uint8_t *p)\n{\n    int c;\n    for(;;) {\n        /* fast skip loop */\n        for(;;) {\n            c = *++p;\n        redo:\n            if (c == '\\n' || c == '*' || c == '\\\\')\n                break;\n            c = *++p;\n            if (c == '\\n' || c == '*' || c == '\\\\')\n                break;\n        }\n        /* now we can handle all the cases */\n        if (c == '\\n') {\n            file->line_num++;\n        } else if (c == '*') {\n            do {\n                c = *++p;\n            } while (c == '*');\n            if (c == '\\\\')\n                c = handle_bs(&p);\n            if (c == '/')\n                break;\n            goto check_eof;\n        } else {\n            c = handle_bs(&p);\n        check_eof:\n            if (c == CH_EOF)\n                tcc_error(\"unexpected end of file in comment\");\n            if (c != '\\\\')\n                goto redo;\n        }\n    }\n    return p + 1;\n}\n\n/* parse a string without interpreting escapes */\nstatic uint8_t *parse_pp_string(uint8_t *p, int sep, CString *str)\n{\n    int c;\n    for(;;) {\n        c = *++p;\n    redo:\n        if (c == sep) {\n            break;\n        } else if (c == '\\\\') {\n            c = handle_bs(&p);\n            if (c == CH_EOF) {\n        unterminated_string:\n                /* XXX: indicate line number of start of string */\n                tok_flags &= ~TOK_FLAG_BOL;\n                tcc_error(\"missing terminating %c character\", sep);\n            } else if (c == '\\\\') {\n                if (str)\n                    cstr_ccat(str, c);\n                c = *++p;\n                /* add char after '\\\\' unconditionally */\n                if (c == '\\\\') {\n                    c = handle_bs(&p);\n                    if (c == CH_EOF)\n                        goto unterminated_string;\n                }\n                goto add_char;\n            } else {\n                goto redo;\n            }\n        } else if (c == '\\n') {\n        add_lf:\n            if (ACCEPT_LF_IN_STRINGS) {\n                file->line_num++;\n                goto add_char;\n            } else if (str) { /* not skipping */\n                goto unterminated_string;\n            } else {\n                //tcc_warning(\"missing terminating %c character\", sep);\n                return p;\n            }\n        } else if (c == '\\r') {\n            c = *++p;\n            if (c == '\\\\')\n                c = handle_bs(&p);\n            if (c == '\\n')\n                goto add_lf;\n            if (c == CH_EOF)\n                goto unterminated_string;\n            if (str)\n                cstr_ccat(str, '\\r');\n            goto redo;\n        } else {\n        add_char:\n            if (str)\n                cstr_ccat(str, c);\n        }\n    }\n    p++;\n    return p;\n}\n\n/* skip block of text until #else, #elif or #endif. skip also pairs of\n   #if/#endif */\nstatic void preprocess_skip(void)\n{\n    int a, start_of_line, c, in_warn_or_error;\n    uint8_t *p;\n\n    p = file->buf_ptr;\n    a = 0;\nredo_start:\n    start_of_line = 1;\n    in_warn_or_error = 0;\n    for(;;) {\n        c = *p;\n        switch(c) {\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\v':\n        case '\\r':\n            p++;\n            continue;\n        case '\\n':\n            file->line_num++;\n            p++;\n            goto redo_start;\n        case '\\\\':\n            c = handle_bs(&p);\n            if (c == CH_EOF)\n                expect(\"#endif\");\n            if (c == '\\\\')\n                ++p;\n            continue;\n        /* skip strings */\n        case '\\\"':\n        case '\\'':\n            if (in_warn_or_error)\n                goto _default;\n            tok_flags &= ~TOK_FLAG_BOL;\n            p = parse_pp_string(p, c, NULL);\n            break;\n        /* skip comments */\n        case '/':\n            if (in_warn_or_error)\n                goto _default;\n            ++p;\n            c = handle_bs(&p);\n            if (c == '*') {\n                p = parse_comment(p);\n            } else if (c == '/') {\n                p = parse_line_comment(p);\n            }\n            continue;\n        case '#':\n            p++;\n            if (start_of_line) {\n                file->buf_ptr = p;\n                next_nomacro();\n                p = file->buf_ptr;\n                if (a == 0 && \n                    (tok == TOK_ELSE || tok == TOK_ELIF || tok == TOK_ENDIF))\n                    goto the_end;\n                if (tok == TOK_IF || tok == TOK_IFDEF || tok == TOK_IFNDEF)\n                    a++;\n                else if (tok == TOK_ENDIF)\n                    a--;\n                else if( tok == TOK_ERROR || tok == TOK_WARNING)\n                    in_warn_or_error = 1;\n                else if (tok == TOK_LINEFEED)\n                    goto redo_start;\n                else if (parse_flags & PARSE_FLAG_ASM_FILE)\n                    p = parse_line_comment(p - 1);\n            }\n#if !defined(TCC_TARGET_ARM)\n            else if (parse_flags & PARSE_FLAG_ASM_FILE)\n                p = parse_line_comment(p - 1);\n#else\n            /* ARM assembly uses '#' for constants */\n#endif\n            break;\n_default:\n        default:\n            p++;\n            break;\n        }\n        start_of_line = 0;\n    }\n the_end: ;\n    file->buf_ptr = p;\n}\n\n#if 0\n/* return the number of additional 'ints' necessary to store the\n   token */\nstatic inline int tok_size(const int *p)\n{\n    switch(*p) {\n        /* 4 bytes */\n    case TOK_CINT:\n    case TOK_CUINT:\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n    case TOK_CFLOAT:\n    case TOK_LINENUM:\n        return 1 + 1;\n    case TOK_STR:\n    case TOK_LSTR:\n    case TOK_PPNUM:\n    case TOK_PPSTR:\n        return 1 + 1 + (p[1] + 3) / 4;\n    case TOK_CLONG:\n    case TOK_CULONG:\n\treturn 1 + LONG_SIZE / 4;\n    case TOK_CDOUBLE:\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n        return 1 + 2;\n    case TOK_CLDOUBLE:\n#ifdef TCC_USING_DOUBLE_FOR_LDOUBLE\n        return 1 + 8 / 4;\n#else\n        return 1 + LDOUBLE_SIZE / 4;\n#endif\n    default:\n        return 1 + 0;\n    }\n}\n#endif\n\n/* token string handling */\nST_INLN void tok_str_new(TokenString *s)\n{\n    s->str = NULL;\n    s->len = s->need_spc = 0;\n    s->allocated_len = 0;\n    s->last_line_num = -1;\n}\n\nST_FUNC TokenString *tok_str_alloc(void)\n{\n    TokenString *str = tal_realloc(tokstr_alloc, 0, sizeof *str);\n    tok_str_new(str);\n    return str;\n}\n\nST_FUNC void tok_str_free_str(int *str)\n{\n    tal_free(tokstr_alloc, str);\n}\n\nST_FUNC void tok_str_free(TokenString *str)\n{\n    tok_str_free_str(str->str);\n    tal_free(tokstr_alloc, str);\n}\n\nST_FUNC int *tok_str_realloc(TokenString *s, int new_size)\n{\n    int *str, size;\n\n    size = s->allocated_len;\n    if (size < 16)\n        size = 16;\n    while (size < new_size)\n        size = size * 2;\n    if (size > s->allocated_len) {\n        str = tal_realloc(tokstr_alloc, s->str, size * sizeof(int));\n        s->allocated_len = size;\n        s->str = str;\n    }\n    return s->str;\n}\n\nST_FUNC void tok_str_add(TokenString *s, int t)\n{\n    int len, *str;\n\n    len = s->len;\n    str = s->str;\n    if (len >= s->allocated_len)\n        str = tok_str_realloc(s, len + 1);\n    str[len++] = t;\n    s->len = len;\n}\n\nST_FUNC void begin_macro(TokenString *str, int alloc)\n{\n    str->alloc = alloc;\n    str->prev = macro_stack;\n    str->prev_ptr = macro_ptr;\n    str->save_line_num = file->line_num;\n    macro_ptr = str->str;\n    macro_stack = str;\n}\n\nST_FUNC void end_macro(void)\n{\n    TokenString *str = macro_stack;\n    macro_stack = str->prev;\n    macro_ptr = str->prev_ptr;\n    file->line_num = str->save_line_num;\n    if (str->alloc == 0) {\n        /* matters if str not alloced, may be tokstr_buf */\n        str->len = str->need_spc = 0;\n    } else {\n        if (str->alloc == 2)\n            str->str = NULL; /* don't free */\n        tok_str_free(str);\n    }\n}\n\nstatic void tok_str_add2(TokenString *s, int t, CValue *cv)\n{\n    int len, *str;\n\n    len = s->len;\n    str = s->str;\n\n    /* allocate space for worst case */\n    if (len + TOK_MAX_SIZE >= s->allocated_len)\n        str = tok_str_realloc(s, len + TOK_MAX_SIZE + 1);\n    str[len++] = t;\n    switch(t) {\n    case TOK_CINT:\n    case TOK_CUINT:\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n    case TOK_CFLOAT:\n    case TOK_LINENUM:\n#if LONG_SIZE == 4\n    case TOK_CLONG:\n    case TOK_CULONG:\n#endif\n        str[len++] = cv->tab[0];\n        break;\n    case TOK_PPNUM:\n    case TOK_PPSTR:\n    case TOK_STR:\n    case TOK_LSTR:\n        {\n            /* Insert the string into the int array. */\n            size_t nb_words =\n                1 + (cv->str.size + sizeof(int) - 1) / sizeof(int);\n            if (len + nb_words >= s->allocated_len)\n                str = tok_str_realloc(s, len + nb_words + 1);\n            str[len] = cv->str.size;\n            memcpy(&str[len + 1], cv->str.data, cv->str.size);\n            len += nb_words;\n        }\n        break;\n    case TOK_CDOUBLE:\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n#if LONG_SIZE == 8\n    case TOK_CLONG:\n    case TOK_CULONG:\n#endif\n        str[len++] = cv->tab[0];\n        str[len++] = cv->tab[1];\n        break;\n    case TOK_CLDOUBLE:\n#if LDOUBLE_SIZE == 8 || defined TCC_USING_DOUBLE_FOR_LDOUBLE\n        str[len++] = cv->tab[0];\n        str[len++] = cv->tab[1];\n#elif LDOUBLE_SIZE == 12\n        str[len++] = cv->tab[0];\n        str[len++] = cv->tab[1];\n        str[len++] = cv->tab[2];\n#elif LDOUBLE_SIZE == 16\n        str[len++] = cv->tab[0];\n        str[len++] = cv->tab[1];\n        str[len++] = cv->tab[2];\n        str[len++] = cv->tab[3];\n#else\n#error add long double size support\n#endif\n        break;\n    default:\n        break;\n    }\n    s->len = len;\n}\n\n/* add the current parse token in token string 's' */\nST_FUNC void tok_str_add_tok(TokenString *s)\n{\n    CValue cval;\n\n    /* save line number info */\n    if (file->line_num != s->last_line_num) {\n        s->last_line_num = file->line_num;\n        cval.i = s->last_line_num;\n        tok_str_add2(s, TOK_LINENUM, &cval);\n    }\n    tok_str_add2(s, tok, &tokc);\n}\n\n/* like tok_str_add2(), add a space if needed */\nstatic void tok_str_add2_spc(TokenString *s, int t, CValue *cv)\n{\n    if (s->need_spc == 3)\n        tok_str_add(s, ' ');\n    s->need_spc = 2;\n    tok_str_add2(s, t, cv);\n}\n\n/* get a token from an integer array and increment pointer. */\nstatic inline void tok_get(int *t, const int **pp, CValue *cv)\n{\n    const int *p = *pp;\n    int n, *tab;\n\n    tab = cv->tab;\n    switch(*t = *p++) {\n#if LONG_SIZE == 4\n    case TOK_CLONG:\n#endif\n    case TOK_CINT:\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n    case TOK_LINENUM:\n        cv->i = *p++;\n        break;\n#if LONG_SIZE == 4\n    case TOK_CULONG:\n#endif\n    case TOK_CUINT:\n        cv->i = (unsigned)*p++;\n        break;\n    case TOK_CFLOAT:\n\ttab[0] = *p++;\n\tbreak;\n    case TOK_STR:\n    case TOK_LSTR:\n    case TOK_PPNUM:\n    case TOK_PPSTR:\n        cv->str.size = *p++;\n        cv->str.data = (char*)p;\n        p += (cv->str.size + sizeof(int) - 1) / sizeof(int);\n        break;\n    case TOK_CDOUBLE:\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n#if LONG_SIZE == 8\n    case TOK_CLONG:\n    case TOK_CULONG:\n#endif\n        n = 2;\n        goto copy;\n    case TOK_CLDOUBLE:\n#if LDOUBLE_SIZE == 8 || defined TCC_USING_DOUBLE_FOR_LDOUBLE\n        n = 2;\n#elif LDOUBLE_SIZE == 12\n        n = 3;\n#elif LDOUBLE_SIZE == 16\n        n = 4;\n#else\n# error add long double size support\n#endif\n    copy:\n        do\n            *tab++ = *p++;\n        while (--n);\n        break;\n    default:\n        break;\n    }\n    *pp = p;\n}\n\n#if 0\n# define TOK_GET(t,p,c) tok_get(t,p,c)\n#else\n# define TOK_GET(t,p,c) do { \\\n    int _t = **(p); \\\n    if (TOK_HAS_VALUE(_t)) \\\n        tok_get(t, p, c); \\\n    else \\\n        *(t) = _t, ++*(p); \\\n    } while (0)\n#endif\n\nstatic int macro_is_equal(const int *a, const int *b)\n{\n    CValue cv;\n    int t;\n\n    if (!a || !b)\n        return 1;\n\n    while (*a && *b) {\n        cstr_reset(&tokcstr);\n        TOK_GET(&t, &a, &cv);\n        cstr_cat(&tokcstr, get_tok_str(t, &cv), 0);\n        TOK_GET(&t, &b, &cv);\n        if (strcmp(tokcstr.data, get_tok_str(t, &cv)))\n            return 0;\n    }\n    return !(*a || *b);\n}\n\n/* defines handling */\nST_INLN void define_push(int v, int macro_type, int *str, Sym *first_arg)\n{\n    Sym *s, *o;\n\n    o = define_find(v);\n    s = sym_push2(&define_stack, v, macro_type, 0);\n    s->d = str;\n    s->next = first_arg;\n    table_ident[v - TOK_IDENT]->sym_define = s;\n\n    if (o && !macro_is_equal(o->d, s->d))\n\ttcc_warning(\"%s redefined\", get_tok_str(v, NULL));\n}\n\n/* undefined a define symbol. Its name is just set to zero */\nST_FUNC void define_undef(Sym *s)\n{\n    int v = s->v;\n    if (v >= TOK_IDENT && v < tok_ident)\n        table_ident[v - TOK_IDENT]->sym_define = NULL;\n}\n\nST_INLN Sym *define_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_define;\n}\n\n/* free define stack until top reaches 'b' */\nST_FUNC void free_defines(Sym *b)\n{\n    while (define_stack != b) {\n        Sym *top = define_stack;\n        define_stack = top->prev;\n        tok_str_free_str(top->d);\n        define_undef(top);\n        sym_free(top);\n    }\n}\n\n/* fake the nth \"#if defined test_...\" for tcc -dt -run */\nstatic void maybe_run_test(TCCState *s)\n{\n    const char *p;\n    if (s->include_stack_ptr != s->include_stack)\n        return;\n    p = get_tok_str(tok, NULL);\n    if (0 != memcmp(p, \"test_\", 5))\n        return;\n    if (0 != --s->run_test)\n        return;\n    fprintf(s->ppfp, &\"\\n[%s]\\n\"[!(s->dflag & 32)], p), fflush(s->ppfp);\n    define_push(tok, MACRO_OBJ, NULL, NULL);\n}\n\nST_FUNC void skip_to_eol(int warn)\n{\n    if (tok == TOK_LINEFEED)\n        return;\n    if (warn)\n        tcc_warning(\"extra tokens after directive\");\n    file->buf_ptr = parse_line_comment(file->buf_ptr - 1);\n    tok = TOK_LINEFEED;\n}\n\nstatic CachedInclude *\nsearch_cached_include(TCCState *s1, const char *filename, int add);\n\nstatic int parse_include(TCCState *s1, int do_next, int test)\n{\n    int c, i;\n    char name[1024], buf[1024], *p;\n    CachedInclude *e;\n\n    c = skip_spaces();\n    if (c == '<' || c == '\\\"') {\n        cstr_reset(&tokcstr);\n        file->buf_ptr = parse_pp_string(file->buf_ptr, c == '<' ? '>' : c, &tokcstr);\n        i = tokcstr.size;\n        pstrncpy(name, tokcstr.data, i >= sizeof name ? sizeof name - 1 : i);\n        next_nomacro();\n    } else {\n        /* computed #include : concatenate tokens until result is one of\n           the two accepted forms.  Don't convert pp-tokens to tokens here. */\n\tparse_flags = PARSE_FLAG_PREPROCESS\n                    | PARSE_FLAG_LINEFEED\n                    | (parse_flags & PARSE_FLAG_ASM_FILE);\n        name[0] = 0;\n        for (;;) {\n            next();\n            p = name, i = strlen(p) - 1;\n            if (i > 0\n                && ((p[0] == '\"' && p[i] == '\"')\n                 || (p[0] == '<' && p[i] == '>')))\n                break;\n            if (tok == TOK_LINEFEED)\n                tcc_error(\"'#include' expects \\\"FILENAME\\\" or <FILENAME>\");\n            pstrcat(name, sizeof name, get_tok_str(tok, &tokc));\n\t}\n        c = p[0];\n        /* remove '<>|\"\"' */\n        memmove(p, p + 1, i - 1), p[i - 1] = 0;\n    }\n\n    if (!test)\n        skip_to_eol(1);\n\n    i = do_next ? file->include_next_index : -1;\n    for (;;) {\n        ++i;\n        if (i == 0) {\n            /* check absolute include path */\n            if (!IS_ABSPATH(name))\n                continue;\n            buf[0] = '\\0';\n        } else if (i == 1) {\n            /* search in file's dir if \"header.h\" */\n            if (c != '\\\"')\n                continue;\n            p = file->true_filename;\n            pstrncpy(buf, p, tcc_basename(p) - p);\n        } else {\n            int j = i - 2, k = j - s1->nb_include_paths;\n            if (k < 0)\n                p = s1->include_paths[j];\n            else if (k < s1->nb_sysinclude_paths)\n                p = s1->sysinclude_paths[k];\n            else if (test)\n                return 0;\n            else\n                tcc_error(\"include file '%s' not found\", name);\n            pstrcpy(buf, sizeof buf, p);\n            pstrcat(buf, sizeof buf, \"/\");\n        }\n        pstrcat(buf, sizeof buf, name);\n        e = search_cached_include(s1, buf, 0);\n        if (e && (define_find(e->ifndef_macro) || e->once)) {\n            /* no need to parse the include because the 'ifndef macro'\n               is defined (or had #pragma once) */\n#ifdef INC_DEBUG\n            printf(\"%s: skipping cached %s\\n\", file->filename, buf);\n#endif\n            return 1;\n        }\n        if (tcc_open(s1, buf) >= 0)\n            break;\n    }\n\n    if (test) {\n        tcc_close();\n    } else {\n        if (s1->include_stack_ptr >= s1->include_stack + INCLUDE_STACK_SIZE)\n            tcc_error(\"#include recursion too deep\");\n        /* push previous file on stack */\n        *s1->include_stack_ptr++ = file->prev;\n        file->include_next_index = i;\n#ifdef INC_DEBUG\n        printf(\"%s: including %s\\n\", file->prev->filename, file->filename);\n#endif\n        /* update target deps */\n        if (s1->gen_deps) {\n            BufferedFile *bf = file;\n            while (i == 1 && (bf = bf->prev))\n                i = bf->include_next_index;\n            /* skip system include files */\n            if (s1->include_sys_deps || i - 2 < s1->nb_include_paths)\n                dynarray_add(&s1->target_deps, &s1->nb_target_deps,\n                    tcc_strdup(buf));\n        }\n        /* add include file debug info */\n        tcc_debug_bincl(s1);\n    }\n    return 1;\n}\n\n/* eval an expression for #if/#elif */\nstatic int expr_preprocess(TCCState *s1)\n{\n    int c, t;\n    int t0 = tok;\n    TokenString *str;\n    \n    str = tok_str_alloc();\n    pp_expr = 1;\n    while (1) {\n        next(); /* do macro subst */\n        t = tok;\n        if (tok < TOK_IDENT) {\n            if (tok == TOK_LINEFEED || tok == TOK_EOF)\n                break;\n            if (tok >= TOK_STR && tok <= TOK_CLDOUBLE)\n                tcc_error(\"invalid constant in preprocessor expression\");\n\n        } else if (tok == TOK_DEFINED) {\n            parse_flags &= ~PARSE_FLAG_PREPROCESS; /* no macro subst */\n            next();\n            t = tok;\n            if (t == '(') \n                next();\n            parse_flags |= PARSE_FLAG_PREPROCESS;\n            if (tok < TOK_IDENT)\n                expect(\"identifier after 'defined'\");\n            if (s1->run_test)\n                maybe_run_test(s1);\n            c = 0;\n            if (define_find(tok)\n                || tok == TOK___HAS_INCLUDE\n                || tok == TOK___HAS_INCLUDE_NEXT)\n                c = 1;\n            if (t == '(') {\n                next();\n                if (tok != ')')\n                    expect(\"')'\");\n            }\n            tok = TOK_CINT;\n            tokc.i = c;\n        } else if (tok == TOK___HAS_INCLUDE ||\n                   tok == TOK___HAS_INCLUDE_NEXT) {\n            t = tok;\n            next();\n\t    if (tok != '(')\n\t\texpect(\"'('\");\n            c = parse_include(s1, t - TOK___HAS_INCLUDE, 1);\n            if (tok != ')')\n                expect(\"')'\");\n            tok = TOK_CINT;\n            tokc.i = c;\n        } else {\n            /* if undefined macro, replace with zero */\n            tok = TOK_CINT;\n            tokc.i = 0;\n        }\n        tok_str_add_tok(str);\n    }\n    if (0 == str->len)\n        tcc_error(\"#%s with no expression\", get_tok_str(t0, 0));\n    tok_str_add(str, TOK_EOF); /* simulate end of file */\n    pp_expr = t0; /* redirect pre-processor expression error messages */\n    t = tok;\n    /* now evaluate C constant expression */\n    begin_macro(str, 1);\n    next();\n    c = expr_const();\n    if (tok != TOK_EOF)\n        tcc_error(\"...\");\n    pp_expr = 0;\n    end_macro();\n    tok = t; /* restore LF or EOF */\n    return c != 0;\n}\n\nST_FUNC void pp_error(CString *cs)\n{\n    cstr_printf(cs, \"bad preprocessor expression: #%s\", get_tok_str(pp_expr, 0));\n    macro_ptr = macro_stack->str;\n    while (next(), tok != TOK_EOF)\n        cstr_printf(cs, \" %s\", get_tok_str(tok, &tokc));\n}\n\n/* parse after #define */\nST_FUNC void parse_define(void)\n{\n    Sym *s, *first, **ps;\n    int v, t, varg, is_vaargs, t0;\n    int saved_parse_flags = parse_flags;\n    TokenString str;\n\n    v = tok;\n    if (v < TOK_IDENT || v == TOK_DEFINED)\n        tcc_error(\"invalid macro name '%s'\", get_tok_str(tok, &tokc));\n    first = NULL;\n    t = MACRO_OBJ;\n    /* We have to parse the whole define as if not in asm mode, in particular\n       no line comment with '#' must be ignored.  Also for function\n       macros the argument list must be parsed without '.' being an ID\n       character.  */\n    parse_flags = ((parse_flags & ~PARSE_FLAG_ASM_FILE) | PARSE_FLAG_SPACES);\n    /* '(' must be just after macro definition for MACRO_FUNC */\n    next_nomacro();\n    parse_flags &= ~PARSE_FLAG_SPACES;\n    is_vaargs = 0;\n    if (tok == '(') {\n        int dotid = set_idnum('.', 0);\n        next_nomacro();\n        ps = &first;\n        if (tok != ')') for (;;) {\n            varg = tok;\n            next_nomacro();\n            is_vaargs = 0;\n            if (varg == TOK_DOTS) {\n                varg = TOK___VA_ARGS__;\n                is_vaargs = 1;\n            } else if (tok == TOK_DOTS && gnu_ext) {\n                is_vaargs = 1;\n                next_nomacro();\n            }\n            if (varg < TOK_IDENT)\n        bad_list:\n                tcc_error(\"bad macro parameter list\");\n            s = sym_push2(&define_stack, varg | SYM_FIELD, is_vaargs, 0);\n            *ps = s;\n            ps = &s->next;\n            if (tok == ')')\n                break;\n            if (tok != ',' || is_vaargs)\n                goto bad_list;\n            next_nomacro();\n        }\n        parse_flags |= PARSE_FLAG_SPACES;\n        next_nomacro();\n        t = MACRO_FUNC;\n        set_idnum('.', dotid);\n    }\n\n    /* The body of a macro definition should be parsed such that identifiers\n       are parsed like the file mode determines (i.e. with '.' being an\n       ID character in asm mode).  But '#' should be retained instead of\n       regarded as line comment leader, so still don't set ASM_FILE\n       in parse_flags. */\n    parse_flags |= PARSE_FLAG_ACCEPT_STRAYS | PARSE_FLAG_SPACES | PARSE_FLAG_LINEFEED;\n    tok_str_new(&str);\n    t0 = 0;\n    while (tok != TOK_LINEFEED && tok != TOK_EOF) {\n        if (is_space(tok)) {\n            str.need_spc |= 1;\n        } else {\n            if (TOK_TWOSHARPS == tok) {\n                if (0 == t0)\n                    goto bad_twosharp;\n                tok = TOK_PPJOIN;\n                t |= MACRO_JOIN;\n            }\n            tok_str_add2_spc(&str, tok, &tokc);\n            t0 = tok;\n        }\n        next_nomacro();\n    }\n    parse_flags = saved_parse_flags;\n    tok_str_add(&str, 0);\n    if (t0 == TOK_PPJOIN)\nbad_twosharp:\n        tcc_error(\"'##' cannot appear at either end of macro\");\n    define_push(v, t, str.str, first);\n    //tok_print(str.str, \"#define (%d) %s %d:\", t | is_vaargs * 4, get_tok_str(v, 0));\n}\n\nstatic CachedInclude *search_cached_include(TCCState *s1, const char *filename, int add)\n{\n    const char *s, *basename;\n    unsigned int h;\n    CachedInclude *e;\n    int c, i, len;\n\n    s = basename = tcc_basename(filename);\n    h = TOK_HASH_INIT;\n    while ((c = (unsigned char)*s) != 0) {\n#ifdef _WIN32\n        h = TOK_HASH_FUNC(h, toup(c));\n#else\n        h = TOK_HASH_FUNC(h, c);\n#endif\n        s++;\n    }\n    h &= (CACHED_INCLUDES_HASH_SIZE - 1);\n\n    i = s1->cached_includes_hash[h];\n    for(;;) {\n        if (i == 0)\n            break;\n        e = s1->cached_includes[i - 1];\n        if (0 == PATHCMP(filename, e->filename))\n            return e;\n        if (e->once\n            && 0 == PATHCMP(basename, tcc_basename(e->filename))\n            && 0 == normalized_PATHCMP(filename, e->filename)\n            )\n            return e;\n        i = e->hash_next;\n    }\n    if (!add)\n        return NULL;\n\n    e = tcc_malloc(sizeof(CachedInclude) + (len = strlen(filename)));\n    memcpy(e->filename, filename, len + 1);\n    e->ifndef_macro = e->once = 0;\n    dynarray_add(&s1->cached_includes, &s1->nb_cached_includes, e);\n    /* add in hash table */\n    e->hash_next = s1->cached_includes_hash[h];\n    s1->cached_includes_hash[h] = s1->nb_cached_includes;\n#ifdef INC_DEBUG\n    printf(\"adding cached '%s'\\n\", filename);\n#endif\n    return e;\n}\n\nstatic int pragma_parse(TCCState *s1)\n{\n    next_nomacro();\n    if (tok == TOK_push_macro || tok == TOK_pop_macro) {\n        int t = tok, v;\n        Sym *s;\n\n        if (next(), tok != '(')\n            goto pragma_err;\n        if (next(), tok != TOK_STR)\n            goto pragma_err;\n        v = tok_alloc(tokc.str.data, tokc.str.size - 1)->tok;\n        if (next(), tok != ')')\n            goto pragma_err;\n        if (t == TOK_push_macro) {\n            while (NULL == (s = define_find(v)))\n                define_push(v, 0, NULL, NULL);\n            s->type.ref = s; /* set push boundary */\n        } else {\n            for (s = define_stack; s; s = s->prev)\n                if (s->v == v && s->type.ref == s) {\n                    s->type.ref = NULL;\n                    break;\n                }\n        }\n        if (s)\n            table_ident[v - TOK_IDENT]->sym_define = s->d ? s : NULL;\n        else\n            tcc_warning(\"unbalanced #pragma pop_macro\");\n        pp_debug_tok = t, pp_debug_symv = v;\n\n    } else if (tok == TOK_once) {\n        search_cached_include(s1, file->true_filename, 1)->once = 1;\n\n    } else if (s1->output_type == TCC_OUTPUT_PREPROCESS) {\n        /* tcc -E: keep pragmas below unchanged */\n        unget_tok(' ');\n        unget_tok(TOK_PRAGMA);\n        unget_tok('#');\n        unget_tok(TOK_LINEFEED);\n        return 1;\n\n    } else if (tok == TOK_pack) {\n        /* This may be:\n           #pragma pack(1) // set\n           #pragma pack() // reset to default\n           #pragma pack(push) // push current\n           #pragma pack(push,1) // push & set\n           #pragma pack(pop) // restore previous */\n        next();\n        skip('(');\n        if (tok == TOK_ASM_pop) {\n            next();\n            if (s1->pack_stack_ptr <= s1->pack_stack) {\n            stk_error:\n                tcc_error(\"out of pack stack\");\n            }\n            s1->pack_stack_ptr--;\n        } else {\n            int val = 0;\n            if (tok != ')') {\n                if (tok == TOK_ASM_push) {\n                    next();\n                    if (s1->pack_stack_ptr >= s1->pack_stack + PACK_STACK_SIZE - 1)\n                        goto stk_error;\n                    val = *s1->pack_stack_ptr++;\n                    if (tok != ',')\n                        goto pack_set;\n                    next();\n                }\n                if (tok != TOK_CINT)\n                    goto pragma_err;\n                val = tokc.i;\n                if (val < 1 || val > 16 || (val & (val - 1)) != 0)\n                    goto pragma_err;\n                next();\n            }\n        pack_set:\n            *s1->pack_stack_ptr = val;\n        }\n        if (tok != ')')\n            goto pragma_err;\n\n    } else if (tok == TOK_comment) {\n        char *p; int t;\n        next();\n        skip('(');\n        t = tok;\n        next();\n        skip(',');\n        if (tok != TOK_STR)\n            goto pragma_err;\n        p = tcc_strdup(tokc.str.data);\n        next();\n        if (tok != ')')\n            goto pragma_err;\n        if (t == TOK_lib) {\n            dynarray_add(&s1->pragma_libs, &s1->nb_pragma_libs, p);\n        } else {\n            if (t == TOK_option)\n                tcc_set_options(s1, p);\n            tcc_free(p);\n        }\n\n    } else {\n        tcc_warning_c(warn_all)(\"#pragma %s ignored\", get_tok_str(tok, &tokc));\n        return 0;\n    }\n    next();\n    return 1;\npragma_err:\n    tcc_error(\"malformed #pragma directive\");\n}\n\n/* put alternative filename */\nST_FUNC void tccpp_putfile(const char *filename)\n{\n    char buf[1024];\n    buf[0] = 0;\n    if (!IS_ABSPATH(filename)) {\n        /* prepend directory from real file */\n        pstrcpy(buf, sizeof buf, file->true_filename);\n        *tcc_basename(buf) = 0;\n    }\n    pstrcat(buf, sizeof buf, filename);\n#ifdef _WIN32\n    normalize_slashes(buf);\n#endif\n    if (0 == strcmp(file->filename, buf))\n        return;\n    //printf(\"new file '%s'\\n\", buf);\n    if (file->true_filename == file->filename)\n        file->true_filename = tcc_strdup(file->filename);\n    pstrcpy(file->filename, sizeof file->filename, buf);\n    tcc_debug_newfile(tcc_state);\n}\n\n/* is_bof is true if first non space token at beginning of file */\nST_FUNC void preprocess(int is_bof)\n{\n    TCCState *s1 = tcc_state;\n    int c, n, saved_parse_flags;\n    char buf[1024], *q;\n    Sym *s;\n\n    saved_parse_flags = parse_flags;\n    parse_flags = PARSE_FLAG_PREPROCESS\n        | PARSE_FLAG_TOK_NUM\n        | PARSE_FLAG_TOK_STR\n        | PARSE_FLAG_LINEFEED\n        | (parse_flags & PARSE_FLAG_ASM_FILE)\n        ;\n\n    next_nomacro();\n redo:\n    switch(tok) {\n    case TOK_DEFINE:\n        pp_debug_tok = tok;\n        next_nomacro();\n        pp_debug_symv = tok;\n        parse_define();\n        break;\n    case TOK_UNDEF:\n        pp_debug_tok = tok;\n        next_nomacro();\n        pp_debug_symv = tok;\n        s = define_find(tok);\n        /* undefine symbol by putting an invalid name */\n        if (s)\n            define_undef(s);\n        next_nomacro();\n        break;\n    case TOK_INCLUDE:\n    case TOK_INCLUDE_NEXT:\n        parse_include(s1, tok - TOK_INCLUDE, 0);\n        goto the_end;\n    case TOK_IFNDEF:\n        c = 1;\n        goto do_ifdef;\n    case TOK_IF:\n        c = expr_preprocess(s1);\n        goto do_if;\n    case TOK_IFDEF:\n        c = 0;\n    do_ifdef:\n        next_nomacro();\n        if (tok < TOK_IDENT)\n            tcc_error(\"invalid argument for '#if%sdef'\", c ? \"n\" : \"\");\n        if (is_bof) {\n            if (c) {\n#ifdef INC_DEBUG\n                printf(\"#ifndef %s\\n\", get_tok_str(tok, NULL));\n#endif\n                file->ifndef_macro = tok;\n            }\n        }\n        if (define_find(tok)\n            || tok == TOK___HAS_INCLUDE\n            || tok == TOK___HAS_INCLUDE_NEXT)\n            c ^= 1;\n        next_nomacro();\n    do_if:\n        if (s1->ifdef_stack_ptr >= s1->ifdef_stack + IFDEF_STACK_SIZE)\n            tcc_error(\"memory full (ifdef)\");\n        *s1->ifdef_stack_ptr++ = c;\n        goto test_skip;\n    case TOK_ELSE:\n        next_nomacro();\n        if (s1->ifdef_stack_ptr == s1->ifdef_stack)\n            tcc_error(\"#else without matching #if\");\n        if (s1->ifdef_stack_ptr[-1] & 2)\n            tcc_error(\"#else after #else\");\n        c = (s1->ifdef_stack_ptr[-1] ^= 3);\n        goto test_else;\n    case TOK_ELIF:\n        if (s1->ifdef_stack_ptr == s1->ifdef_stack)\n            tcc_error(\"#elif without matching #if\");\n        c = s1->ifdef_stack_ptr[-1];\n        if (c > 1)\n            tcc_error(\"#elif after #else\");\n        /* last #if/#elif expression was true: we skip */\n        if (c == 1) {\n            skip_to_eol(0);\n            c = 0;\n        } else {\n            c = expr_preprocess(s1);\n            s1->ifdef_stack_ptr[-1] = c;\n        }\n    test_else:\n        if (s1->ifdef_stack_ptr == file->ifdef_stack_ptr + 1)\n            file->ifndef_macro = 0;\n    test_skip:\n        if (!(c & 1)) {\n            skip_to_eol(1);\n            preprocess_skip();\n            is_bof = 0;\n            goto redo;\n        }\n        break;\n    case TOK_ENDIF:\n        next_nomacro();\n        if (s1->ifdef_stack_ptr <= file->ifdef_stack_ptr)\n            tcc_error(\"#endif without matching #if\");\n        s1->ifdef_stack_ptr--;\n        /* '#ifndef macro' was at the start of file. Now we check if\n           an '#endif' is exactly at the end of file */\n        if (file->ifndef_macro &&\n            s1->ifdef_stack_ptr == file->ifdef_stack_ptr) {\n            file->ifndef_macro_saved = file->ifndef_macro;\n            /* need to set to zero to avoid false matches if another\n               #ifndef at middle of file */\n            file->ifndef_macro = 0;\n            tok_flags |= TOK_FLAG_ENDIF;\n        }\n        break;\n\n    case TOK_LINE:\n        parse_flags &= ~PARSE_FLAG_TOK_NUM;\n        next();\n        parse_flags |= PARSE_FLAG_TOK_NUM;\n        if (tok != TOK_PPNUM) {\n    _line_err:\n            tcc_error(\"wrong #line format\");\n        }\n        goto _line_num;\n    case TOK_PPNUM:\n        if (parse_flags & PARSE_FLAG_ASM_FILE)\n            goto ignore;\n    _line_num:\n        for (n = 0, q = tokc.str.data; *q; ++q) {\n            if (!isnum(*q))\n                goto _line_err;\n            n = n * 10 + *q - '0';\n        }\n        parse_flags &= ~PARSE_FLAG_TOK_STR;\n        next();\n        parse_flags |= PARSE_FLAG_TOK_STR;\n        if (tok == TOK_PPSTR && tokc.str.data[0] == '\"') {\n            tokc.str.data[tokc.str.size - 2] = 0;\n            tccpp_putfile(tokc.str.data + 1);\n            n--;\n            if (macro_ptr && *macro_ptr == 0)\n                macro_stack->save_line_num = n;\n        }\n        else if (tok != TOK_LINEFEED)\n            goto _line_err;\n        if (file->fd > 0)\n            total_lines += file->line_num - n;\n        file->line_ref += file->line_num - n;\n        file->line_num = n;\n        goto ignore; /* skip optional level number */\n\n    case TOK_ERROR:\n    case TOK_WARNING:\n    {\n        q = buf;\n        c = skip_spaces();\n        while (c != '\\n' && c != CH_EOF) {\n            if ((q - buf) < sizeof(buf) - 1)\n                *q++ = c;\n            c = ninp();\n        }\n        *q = '\\0';\n        if (tok == TOK_ERROR)\n            tcc_error(\"#error %s\", buf);\n        else\n            tcc_warning(\"#warning %s\", buf);\n        next_nomacro();\n        break;\n    }\n    case TOK_PRAGMA:\n        if (!pragma_parse(s1))\n            goto ignore;\n        break;\n    case TOK_LINEFEED:\n        goto the_end;\n    default:\n        /* ignore gas line comment in an 'S' file. */\n        if (saved_parse_flags & PARSE_FLAG_ASM_FILE)\n            goto ignore;\n        if (tok == '!' && is_bof)\n            /* '#!' is ignored at beginning to allow C scripts. */\n            goto ignore;\n        tcc_warning(\"Ignoring unknown preprocessing directive #%s\", get_tok_str(tok, &tokc));\n    ignore:\n        skip_to_eol(0);\n        goto the_end;\n    }\n    skip_to_eol(1);\n the_end:\n    parse_flags = saved_parse_flags;\n}\n\n/* evaluate escape codes in a string. */\nstatic void parse_escape_string(CString *outstr, const uint8_t *buf, int is_long)\n{\n    int c, n, i;\n    const uint8_t *p;\n\n    p = buf;\n    for(;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '\\\\') {\n            p++;\n            /* escape */\n            c = *p;\n            switch(c) {\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n                /* at most three octal digits */\n                n = c - '0';\n                p++;\n                c = *p;\n                if (isoct(c)) {\n                    n = n * 8 + c - '0';\n                    p++;\n                    c = *p;\n                    if (isoct(c)) {\n                        n = n * 8 + c - '0';\n                        p++;\n                    }\n                }\n                c = n;\n                goto add_char_nonext;\n            case 'x': i = 0; goto parse_hex_or_ucn;\n            case 'u': i = 4; goto parse_hex_or_ucn;\n            case 'U': i = 8; goto parse_hex_or_ucn;\n    parse_hex_or_ucn:\n                p++;\n                n = 0;\n                do {\n                    c = *p;\n                    if (c >= 'a' && c <= 'f')\n                        c = c - 'a' + 10;\n                    else if (c >= 'A' && c <= 'F')\n                        c = c - 'A' + 10;\n                    else if (isnum(c))\n                        c = c - '0';\n                    else if (i >= 0)\n                        expect(\"more hex digits in universal-character-name\");\n                    else\n                        goto add_hex_or_ucn;\n                    n = n * 16 + c;\n                    p++;\n                } while (--i);\n\t\tif (is_long) {\n    add_hex_or_ucn:\n                    c = n;\n\t\t    goto add_char_nonext;\n\t\t}\n                cstr_u8cat(outstr, n);\n                continue;\n            case 'a':\n                c = '\\a';\n                break;\n            case 'b':\n                c = '\\b';\n                break;\n            case 'f':\n                c = '\\f';\n                break;\n            case 'n':\n                c = '\\n';\n                break;\n            case 'r':\n                c = '\\r';\n                break;\n            case 't':\n                c = '\\t';\n                break;\n            case 'v':\n                c = '\\v';\n                break;\n            case 'e':\n                if (!gnu_ext)\n                    goto invalid_escape;\n                c = 27;\n                break;\n            case '\\'':\n            case '\\\"':\n            case '\\\\': \n            case '?':\n                break;\n            default:\n            invalid_escape:\n                if (c >= '!' && c <= '~')\n                    tcc_warning(\"unknown escape sequence: \\'\\\\%c\\'\", c);\n                else\n                    tcc_warning(\"unknown escape sequence: \\'\\\\x%x\\'\", c);\n                break;\n            }\n        } else if (is_long && c >= 0x80) {\n            /* assume we are processing UTF-8 sequence */\n            /* reference: The Unicode Standard, Version 10.0, ch3.9 */\n\n            int cont; /* count of continuation bytes */\n            int skip; /* how many bytes should skip when error occurred */\n            int i;\n\n            /* decode leading byte */\n            if (c < 0xC2) {\n\t            skip = 1; goto invalid_utf8_sequence;\n            } else if (c <= 0xDF) {\n\t            cont = 1; n = c & 0x1f;\n            } else if (c <= 0xEF) {\n\t            cont = 2; n = c & 0xf;\n            } else if (c <= 0xF4) {\n\t            cont = 3; n = c & 0x7;\n            } else {\n\t            skip = 1; goto invalid_utf8_sequence;\n            }\n\n            /* decode continuation bytes */\n            for (i = 1; i <= cont; i++) {\n                int l = 0x80, h = 0xBF;\n\n                /* adjust limit for second byte */\n                if (i == 1) {\n                    switch (c) {\n                    case 0xE0: l = 0xA0; break;\n                    case 0xED: h = 0x9F; break;\n                    case 0xF0: l = 0x90; break;\n                    case 0xF4: h = 0x8F; break;\n                    }\n                }\n\n                if (p[i] < l || p[i] > h) {\n                    skip = i; goto invalid_utf8_sequence;\n                }\n\n                n = (n << 6) | (p[i] & 0x3f);\n            }\n\n            /* advance pointer */\n            p += 1 + cont;\n            c = n;\n            goto add_char_nonext;\n\n            /* error handling */\n        invalid_utf8_sequence:\n            tcc_warning(\"ill-formed UTF-8 subsequence starting with: \\'\\\\x%x\\'\", c);\n            c = 0xFFFD;\n            p += skip;\n            goto add_char_nonext;\n\n        }\n        p++;\n    add_char_nonext:\n        if (!is_long)\n            cstr_ccat(outstr, c);\n        else {\n#ifdef TCC_TARGET_PE\n            /* store as UTF-16 */\n            if (c < 0x10000) {\n                cstr_wccat(outstr, c);\n            } else {\n                c -= 0x10000;\n                cstr_wccat(outstr, (c >> 10) + 0xD800);\n                cstr_wccat(outstr, (c & 0x3FF) + 0xDC00);\n            }\n#else\n            cstr_wccat(outstr, c);\n#endif\n        }\n    }\n    /* add a trailing '\\0' */\n    if (!is_long)\n        cstr_ccat(outstr, '\\0');\n    else\n        cstr_wccat(outstr, '\\0');\n}\n\nstatic void parse_string(const char *s, int len)\n{\n    uint8_t buf[1000], *p = buf;\n    int is_long, sep;\n\n    if ((is_long = *s == 'L'))\n        ++s, --len;\n    sep = *s++;\n    len -= 2;\n    if (len >= sizeof buf)\n        p = tcc_malloc(len + 1);\n    memcpy(p, s, len);\n    p[len] = 0;\n\n    cstr_reset(&tokcstr);\n    parse_escape_string(&tokcstr, p, is_long);\n    if (p != buf)\n        tcc_free(p);\n\n    if (sep == '\\'') {\n        int char_size, i, n, c;\n        /* XXX: make it portable */\n        if (!is_long)\n            tok = TOK_CCHAR, char_size = 1;\n        else\n            tok = TOK_LCHAR, char_size = sizeof(nwchar_t);\n        n = tokcstr.size / char_size - 1;\n        if (n < 1)\n            tcc_error(\"empty character constant\");\n        if (n > 1)\n            tcc_warning_c(warn_all)(\"multi-character character constant\");\n        for (c = i = 0; i < n; ++i) {\n            if (is_long)\n                c = ((nwchar_t *)tokcstr.data)[i];\n            else\n                c = (c << 8) | ((char *)tokcstr.data)[i];\n        }\n        tokc.i = c;\n    } else {\n        tokc.str.size = tokcstr.size;\n        tokc.str.data = tokcstr.data;\n        if (!is_long)\n            tok = TOK_STR;\n        else\n            tok = TOK_LSTR;\n    }\n}\n\n/* we use 64 bit numbers */\n#define BN_SIZE 2\n\n/* bn = (bn << shift) | or_val */\nstatic void bn_lshift(unsigned int *bn, int shift, int or_val)\n{\n    int i;\n    unsigned int v;\n    for(i=0;i<BN_SIZE;i++) {\n        v = bn[i];\n        bn[i] = (v << shift) | or_val;\n        or_val = v >> (32 - shift);\n    }\n}\n\nstatic void bn_zero(unsigned int *bn)\n{\n    int i;\n    for(i=0;i<BN_SIZE;i++) {\n        bn[i] = 0;\n    }\n}\n\n/* parse number in null terminated string 'p' and return it in the\n   current token */\nstatic void parse_number(const char *p)\n{\n    int b, t, shift, frac_bits, s, exp_val, ch;\n    char *q;\n    unsigned int bn[BN_SIZE];\n    double d;\n\n    /* number */\n    q = token_buf;\n    ch = *p++;\n    t = ch;\n    ch = *p++;\n    *q++ = t;\n    b = 10;\n    if (t == '.') {\n        goto float_frac_parse;\n    } else if (t == '0') {\n        if (ch == 'x' || ch == 'X') {\n            q--;\n            ch = *p++;\n            b = 16;\n        } else if (tcc_state->tcc_ext && (ch == 'b' || ch == 'B')) {\n            q--;\n            ch = *p++;\n            b = 2;\n        }\n    }\n    /* parse all digits. cannot check octal numbers at this stage\n       because of floating point constants */\n    while (1) {\n        if (ch >= 'a' && ch <= 'f')\n            t = ch - 'a' + 10;\n        else if (ch >= 'A' && ch <= 'F')\n            t = ch - 'A' + 10;\n        else if (isnum(ch))\n            t = ch - '0';\n        else\n            break;\n        if (t >= b)\n            break;\n        if (q >= token_buf + STRING_MAX_SIZE) {\n        num_too_long:\n            tcc_error(\"number too long\");\n        }\n        *q++ = ch;\n        ch = *p++;\n    }\n    if (ch == '.' ||\n        ((ch == 'e' || ch == 'E') && b == 10) ||\n        ((ch == 'p' || ch == 'P') && (b == 16 || b == 2))) {\n        if (b != 10) {\n            /* NOTE: strtox should support that for hexa numbers, but\n               non ISOC99 libcs do not support it, so we prefer to do\n               it by hand */\n            /* hexadecimal or binary floats */\n            /* XXX: handle overflows */\n            *q = '\\0';\n            if (b == 16)\n                shift = 4;\n            else \n                shift = 1;\n            bn_zero(bn);\n            q = token_buf;\n            while (1) {\n                t = *q++;\n                if (t == '\\0') {\n                    break;\n                } else if (t >= 'a') {\n                    t = t - 'a' + 10;\n                } else if (t >= 'A') {\n                    t = t - 'A' + 10;\n                } else {\n                    t = t - '0';\n                }\n                bn_lshift(bn, shift, t);\n            }\n            frac_bits = 0;\n            if (ch == '.') {\n                ch = *p++;\n                while (1) {\n                    t = ch;\n                    if (t >= 'a' && t <= 'f') {\n                        t = t - 'a' + 10;\n                    } else if (t >= 'A' && t <= 'F') {\n                        t = t - 'A' + 10;\n                    } else if (t >= '0' && t <= '9') {\n                        t = t - '0';\n                    } else {\n                        break;\n                    }\n                    if (t >= b)\n                        tcc_error(\"invalid digit\");\n                    bn_lshift(bn, shift, t);\n                    frac_bits += shift;\n                    ch = *p++;\n                }\n            }\n            if (ch != 'p' && ch != 'P')\n                expect(\"exponent\");\n            ch = *p++;\n            s = 1;\n            exp_val = 0;\n            if (ch == '+') {\n                ch = *p++;\n            } else if (ch == '-') {\n                s = -1;\n                ch = *p++;\n            }\n            if (ch < '0' || ch > '9')\n                expect(\"exponent digits\");\n            while (ch >= '0' && ch <= '9') {\n                exp_val = exp_val * 10 + ch - '0';\n                ch = *p++;\n            }\n            exp_val = exp_val * s;\n            \n            /* now we can generate the number */\n            /* XXX: should patch directly float number */\n            d = (double)bn[1] * 4294967296.0 + (double)bn[0];\n            d = ldexp(d, exp_val - frac_bits);\n            t = toup(ch);\n            if (t == 'F') {\n                ch = *p++;\n                tok = TOK_CFLOAT;\n                /* float : should handle overflow */\n                tokc.f = (float)d;\n            } else if (t == 'L') {\n                ch = *p++;\n                tok = TOK_CLDOUBLE;\n#ifdef TCC_USING_DOUBLE_FOR_LDOUBLE\n                tokc.d = d;\n#else\n                /* XXX: not large enough */\n                tokc.ld = (long double)d;\n#endif\n            } else {\n                tok = TOK_CDOUBLE;\n                tokc.d = d;\n            }\n        } else {\n            /* decimal floats */\n            if (ch == '.') {\n                if (q >= token_buf + STRING_MAX_SIZE)\n                    goto num_too_long;\n                *q++ = ch;\n                ch = *p++;\n            float_frac_parse:\n                while (ch >= '0' && ch <= '9') {\n                    if (q >= token_buf + STRING_MAX_SIZE)\n                        goto num_too_long;\n                    *q++ = ch;\n                    ch = *p++;\n                }\n            }\n            if (ch == 'e' || ch == 'E') {\n                if (q >= token_buf + STRING_MAX_SIZE)\n                    goto num_too_long;\n                *q++ = ch;\n                ch = *p++;\n                if (ch == '-' || ch == '+') {\n                    if (q >= token_buf + STRING_MAX_SIZE)\n                        goto num_too_long;\n                    *q++ = ch;\n                    ch = *p++;\n                }\n                if (ch < '0' || ch > '9')\n                    expect(\"exponent digits\");\n                while (ch >= '0' && ch <= '9') {\n                    if (q >= token_buf + STRING_MAX_SIZE)\n                        goto num_too_long;\n                    *q++ = ch;\n                    ch = *p++;\n                }\n            }\n            *q = '\\0';\n            t = toup(ch);\n            errno = 0;\n            if (t == 'F') {\n                ch = *p++;\n                tok = TOK_CFLOAT;\n                tokc.f = strtof(token_buf, NULL);\n            } else if (t == 'L') {\n                ch = *p++;\n                tok = TOK_CLDOUBLE;\n#ifdef TCC_USING_DOUBLE_FOR_LDOUBLE\n                tokc.d = strtod(token_buf, NULL);\n#else\n                tokc.ld = strtold(token_buf, NULL);\n#endif\n            } else {\n                tok = TOK_CDOUBLE;\n                tokc.d = strtod(token_buf, NULL);\n            }\n        }\n    } else {\n        unsigned long long n, n1;\n        int lcount, ucount, ov = 0;\n        const char *p1;\n\n        /* integer number */\n        *q = '\\0';\n        q = token_buf;\n        if (b == 10 && *q == '0') {\n            b = 8;\n            q++;\n        }\n        n = 0;\n        while(1) {\n            t = *q++;\n            /* no need for checks except for base 10 / 8 errors */\n            if (t == '\\0')\n                break;\n            else if (t >= 'a')\n                t = t - 'a' + 10;\n            else if (t >= 'A')\n                t = t - 'A' + 10;\n            else\n                t = t - '0';\n            if (t >= b)\n                tcc_error(\"invalid digit\");\n            n1 = n;\n            n = n * b + t;\n            /* detect overflow */\n            if (n1 >= 0x1000000000000000ULL && n / b != n1)\n                ov = 1;\n        }\n\n        /* Determine the characteristics (unsigned and/or 64bit) the type of\n           the constant must have according to the constant suffix(es) */\n        lcount = ucount = 0;\n        p1 = p;\n        for(;;) {\n            t = toup(ch);\n            if (t == 'L') {\n                if (lcount >= 2)\n                    tcc_error(\"three 'l's in integer constant\");\n                if (lcount && *(p - 1) != ch)\n                    tcc_error(\"incorrect integer suffix: %s\", p1);\n                lcount++;\n                ch = *p++;\n            } else if (t == 'U') {\n                if (ucount >= 1)\n                    tcc_error(\"two 'u's in integer constant\");\n                ucount++;\n                ch = *p++;\n            } else {\n                break;\n            }\n        }\n\n        /* Determine if it needs 64 bits and/or unsigned in order to fit */\n        if (ucount == 0 && b == 10) {\n            if (lcount <= (LONG_SIZE == 4)) {\n                if (n >= 0x80000000U)\n                    lcount = (LONG_SIZE == 4) + 1;\n            }\n            if (n >= 0x8000000000000000ULL)\n                ov = 1, ucount = 1;\n        } else {\n            if (lcount <= (LONG_SIZE == 4)) {\n                if (n >= 0x100000000ULL)\n                    lcount = (LONG_SIZE == 4) + 1;\n                else if (n >= 0x80000000U)\n                    ucount = 1;\n            }\n            if (n >= 0x8000000000000000ULL)\n                ucount = 1;\n        }\n\n        if (ov)\n            tcc_warning(\"integer constant overflow\");\n\n        tok = TOK_CINT;\n\tif (lcount) {\n            tok = TOK_CLONG;\n            if (lcount == 2)\n                tok = TOK_CLLONG;\n\t}\n\tif (ucount)\n\t    ++tok; /* TOK_CU... */\n        tokc.i = n;\n    }\n    if (ch)\n        tcc_error(\"invalid number\");\n}\n\n\n#define PARSE2(c1, tok1, c2, tok2)              \\\n    case c1:                                    \\\n        PEEKC(c, p);                            \\\n        if (c == c2) {                          \\\n            p++;                                \\\n            tok = tok2;                         \\\n        } else {                                \\\n            tok = tok1;                         \\\n        }                                       \\\n        break;\n\n/* return next token without macro substitution */\nstatic void next_nomacro(void)\n{\n    int t, c, is_long, len;\n    TokenSym *ts;\n    uint8_t *p, *p1;\n    unsigned int h;\n\n    p = file->buf_ptr;\n redo_no_start:\n    c = *p;\n    switch(c) {\n    case ' ':\n    case '\\t':\n        tok = c;\n        p++;\n maybe_space:\n        if (parse_flags & PARSE_FLAG_SPACES)\n            goto keep_tok_flags;\n        while (isidnum_table[*p - CH_EOF] & IS_SPC)\n            ++p;\n        goto redo_no_start;\n    case '\\f':\n    case '\\v':\n    case '\\r':\n        p++;\n        goto redo_no_start;\n    case '\\\\':\n        /* first look if it is in fact an end of buffer */\n        c = handle_stray(&p);\n        if (c == '\\\\')\n            goto parse_simple;\n        if (c == CH_EOF) {\n            TCCState *s1 = tcc_state;\n            if (!(tok_flags & TOK_FLAG_BOL)) {\n                /* add implicit newline */\n                goto maybe_newline;\n            } else if (!(parse_flags & PARSE_FLAG_PREPROCESS)) {\n                tok = TOK_EOF;\n            } else if (s1->ifdef_stack_ptr != file->ifdef_stack_ptr) {\n                tcc_error(\"missing #endif\");\n            } else if (s1->include_stack_ptr == s1->include_stack) {\n                /* no include left : end of file. */\n                tok = TOK_EOF;\n            } else {\n                /* pop include file */\n\n                /* test if previous '#endif' was after a #ifdef at\n                   start of file */\n                if (tok_flags & TOK_FLAG_ENDIF) {\n#ifdef INC_DEBUG\n                    printf(\"#endif %s\\n\", get_tok_str(file->ifndef_macro_saved, NULL));\n#endif\n                    search_cached_include(s1, file->true_filename, 1)\n                        ->ifndef_macro = file->ifndef_macro_saved;\n                    tok_flags &= ~TOK_FLAG_ENDIF;\n                }\n\n                /* add end of include file debug info */\n                tcc_debug_eincl(tcc_state);\n                /* pop include stack */\n                tcc_close();\n                s1->include_stack_ptr--;\n                p = file->buf_ptr;\n                goto maybe_newline;\n            }\n        } else {\n            goto redo_no_start;\n        }\n        break;\n\n    case '\\n':\n        file->line_num++;\n        p++;\nmaybe_newline:\n        tok_flags |= TOK_FLAG_BOL;\n        if (0 == (parse_flags & PARSE_FLAG_LINEFEED))\n            goto redo_no_start;\n        tok = TOK_LINEFEED;\n        goto keep_tok_flags;\n\n    case '#':\n        /* XXX: simplify */\n        PEEKC(c, p);\n        if ((tok_flags & TOK_FLAG_BOL) && \n            (parse_flags & PARSE_FLAG_PREPROCESS)) {\n            tok_flags &= ~TOK_FLAG_BOL;\n            file->buf_ptr = p;\n            preprocess(tok_flags & TOK_FLAG_BOF);\n            p = file->buf_ptr;\n            goto maybe_newline;\n        } else {\n            if (c == '#') {\n                p++;\n                tok = TOK_TWOSHARPS;\n            } else {\n#if !defined(TCC_TARGET_ARM)\n                if (parse_flags & PARSE_FLAG_ASM_FILE) {\n                    p = parse_line_comment(p - 1);\n                    goto redo_no_start;\n                } else\n#endif\n                {\n                    tok = '#';\n                }\n            }\n        }\n        break;\n    \n    /* dollar is allowed to start identifiers when not parsing asm */\n    case '$':\n        if (!(isidnum_table['$' - CH_EOF] & IS_ID)\n         || (parse_flags & PARSE_FLAG_ASM_FILE))\n            goto parse_simple;\n\n    case 'a': case 'b': case 'c': case 'd':\n    case 'e': case 'f': case 'g': case 'h':\n    case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p':\n    case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z': \n    case 'A': case 'B': case 'C': case 'D':\n    case 'E': case 'F': case 'G': case 'H':\n    case 'I': case 'J': case 'K': \n    case 'M': case 'N': case 'O': case 'P':\n    case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z': \n    case '_':\n    parse_ident_fast:\n        p1 = p;\n        h = TOK_HASH_INIT;\n        h = TOK_HASH_FUNC(h, c);\n        while (c = *++p, isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))\n            h = TOK_HASH_FUNC(h, c);\n        len = p - p1;\n        if (c != '\\\\') {\n            TokenSym **pts;\n\n            /* fast case : no stray found, so we have the full token\n               and we have already hashed it */\n            h &= (TOK_HASH_SIZE - 1);\n            pts = &hash_ident[h];\n            for(;;) {\n                ts = *pts;\n                if (!ts)\n                    break;\n                if (ts->len == len && !memcmp(ts->str, p1, len))\n                    goto token_found;\n                pts = &(ts->hash_next);\n            }\n            ts = tok_alloc_new(pts, (char *) p1, len);\n        token_found: ;\n        } else {\n            /* slower case */\n            cstr_reset(&tokcstr);\n            cstr_cat(&tokcstr, (char *) p1, len);\n            p--;\n            PEEKC(c, p);\n        parse_ident_slow:\n            while (isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))\n            {\n                cstr_ccat(&tokcstr, c);\n                PEEKC(c, p);\n            }\n            ts = tok_alloc(tokcstr.data, tokcstr.size);\n        }\n        tok = ts->tok;\n        break;\n    case 'L':\n        t = p[1];\n        if (t != '\\\\' && t != '\\'' && t != '\\\"') {\n            /* fast case */\n            goto parse_ident_fast;\n        } else {\n            PEEKC(c, p);\n            if (c == '\\'' || c == '\\\"') {\n                is_long = 1;\n                goto str_const;\n            } else {\n                cstr_reset(&tokcstr);\n                cstr_ccat(&tokcstr, 'L');\n                goto parse_ident_slow;\n            }\n        }\n        break;\n\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n    case '8': case '9':\n        t = c;\n        PEEKC(c, p);\n        /* after the first digit, accept digits, alpha, '.' or sign if\n           prefixed by 'eEpP' */\n    parse_num:\n        cstr_reset(&tokcstr);\n        for(;;) {\n            cstr_ccat(&tokcstr, t);\n            if (!((isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))\n                  || c == '.'\n                  || ((c == '+' || c == '-')\n                      && (((t == 'e' || t == 'E')\n                            && !(parse_flags & PARSE_FLAG_ASM_FILE\n                                /* 0xe+1 is 3 tokens in asm */\n                                && ((char*)tokcstr.data)[0] == '0'\n                                && toup(((char*)tokcstr.data)[1]) == 'X'))\n                          || t == 'p' || t == 'P'))))\n                break;\n            t = c;\n            PEEKC(c, p);\n        }\n        /* We add a trailing '\\0' to ease parsing */\n        cstr_ccat(&tokcstr, '\\0');\n        tokc.str.size = tokcstr.size;\n        tokc.str.data = tokcstr.data;\n        tok = TOK_PPNUM;\n        break;\n\n    case '.':\n        /* special dot handling because it can also start a number */\n        PEEKC(c, p);\n        if (isnum(c)) {\n            t = '.';\n            goto parse_num;\n        } else if ((isidnum_table['.' - CH_EOF] & IS_ID)\n                   && (isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))) {\n            *--p = c = '.';\n            goto parse_ident_fast;\n        } else if (c == '.') {\n            PEEKC(c, p);\n            if (c == '.') {\n                p++;\n                tok = TOK_DOTS;\n            } else {\n                *--p = '.'; /* may underflow into file->unget[] */\n                tok = '.';\n            }\n        } else {\n            tok = '.';\n        }\n        break;\n    case '\\'':\n    case '\\\"':\n        is_long = 0;\n    str_const:\n        cstr_reset(&tokcstr);\n        if (is_long)\n            cstr_ccat(&tokcstr, 'L');\n        cstr_ccat(&tokcstr, c);\n        p = parse_pp_string(p, c, &tokcstr);\n        cstr_ccat(&tokcstr, c);\n        cstr_ccat(&tokcstr, '\\0');\n        tokc.str.size = tokcstr.size;\n        tokc.str.data = tokcstr.data;\n        tok = TOK_PPSTR;\n        break;\n\n    case '<':\n        PEEKC(c, p);\n        if (c == '=') {\n            p++;\n            tok = TOK_LE;\n        } else if (c == '<') {\n            PEEKC(c, p);\n            if (c == '=') {\n                p++;\n                tok = TOK_A_SHL;\n            } else {\n                tok = TOK_SHL;\n            }\n        } else {\n            tok = TOK_LT;\n        }\n        break;\n    case '>':\n        PEEKC(c, p);\n        if (c == '=') {\n            p++;\n            tok = TOK_GE;\n        } else if (c == '>') {\n            PEEKC(c, p);\n            if (c == '=') {\n                p++;\n                tok = TOK_A_SAR;\n            } else {\n                tok = TOK_SAR;\n            }\n        } else {\n            tok = TOK_GT;\n        }\n        break;\n        \n    case '&':\n        PEEKC(c, p);\n        if (c == '&') {\n            p++;\n            tok = TOK_LAND;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_AND;\n        } else {\n            tok = '&';\n        }\n        break;\n        \n    case '|':\n        PEEKC(c, p);\n        if (c == '|') {\n            p++;\n            tok = TOK_LOR;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_OR;\n        } else {\n            tok = '|';\n        }\n        break;\n\n    case '+':\n        PEEKC(c, p);\n        if (c == '+') {\n            p++;\n            tok = TOK_INC;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_ADD;\n        } else {\n            tok = '+';\n        }\n        break;\n        \n    case '-':\n        PEEKC(c, p);\n        if (c == '-') {\n            p++;\n            tok = TOK_DEC;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_SUB;\n        } else if (c == '>') {\n            p++;\n            tok = TOK_ARROW;\n        } else {\n            tok = '-';\n        }\n        break;\n\n    PARSE2('!', '!', '=', TOK_NE)\n    PARSE2('=', '=', '=', TOK_EQ)\n    PARSE2('*', '*', '=', TOK_A_MUL)\n    PARSE2('%', '%', '=', TOK_A_MOD)\n    PARSE2('^', '^', '=', TOK_A_XOR)\n        \n        /* comments or operator */\n    case '/':\n        PEEKC(c, p);\n        if (c == '*') {\n            p = parse_comment(p);\n            /* comments replaced by a blank */\n            tok = ' ';\n            goto maybe_space;\n        } else if (c == '/') {\n            p = parse_line_comment(p);\n            tok = ' ';\n            goto maybe_space;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_DIV;\n        } else {\n            tok = '/';\n        }\n        break;\n        \n        /* simple tokens */\n    case '(':\n    case ')':\n    case '[':\n    case ']':\n    case '{':\n    case '}':\n    case ',':\n    case ';':\n    case ':':\n    case '?':\n    case '~':\n    case '@': /* only used in assembler */\n    parse_simple:\n        tok = c;\n        p++;\n        break;\n    default:\n        if (c >= 0x80 && c <= 0xFF) /* utf8 identifiers */\n\t    goto parse_ident_fast;\n        if (parse_flags & PARSE_FLAG_ASM_FILE)\n            goto parse_simple;\n        tcc_error(\"unrecognized character \\\\x%02x\", c);\n        break;\n    }\n    tok_flags = 0;\nkeep_tok_flags:\n    file->buf_ptr = p;\n#if defined(PARSE_DEBUG)\n    printf(\"token = %d %s\\n\", tok, get_tok_str(tok, &tokc));\n#endif\n}\n\n#ifdef PP_DEBUG\nstatic int indent;\nstatic void define_print(TCCState *s1, int v);\nstatic void pp_print(const char *msg, int v, const int *str)\n{\n    FILE *fp = tcc_state->ppfp;\n\n    if (msg[0] == '#' && indent == 0)\n        fprintf(fp, \"\\n\");\n    else if (msg[0] == '+')\n         ++indent, ++msg;\n    else if (msg[0] == '-')\n        --indent, ++msg;\n\n    fprintf(fp, \"%*s\", indent, \"\");\n    if (msg[0] == '#') {\n        define_print(tcc_state, v);\n    } else {\n        tok_print(str, v ? \"%s %s\" : \"%s\", msg, get_tok_str(v, 0));\n    }\n}\n#define PP_PRINT(x) pp_print x\n#else\n#define PP_PRINT(x)\n#endif\n\nstatic int macro_subst(\n    TokenString *tok_str,\n    Sym **nested_list,\n    const int *macro_str\n    );\n\n/* substitute arguments in replacement lists in macro_str by the values in\n   args (field d) and return allocated string */\nstatic int *macro_arg_subst(Sym **nested_list, const int *macro_str, Sym *args)\n{\n    int t, t0, t1, t2, n;\n    const int *st;\n    Sym *s;\n    CValue cval;\n    TokenString str;\n\n#ifdef PP_DEBUG\n    PP_PRINT((\"asubst:\", 0, macro_str));\n    for (s = args, n = 0; s; s = s->prev, ++n);\n    while (n--) {\n        for (s = args, t = 0; t < n; s = s->prev, ++t);\n        tok_print(s->d, \"%*s - arg: %s:\", indent, \"\", get_tok_str(s->v, 0));\n    }\n#endif\n\n    tok_str_new(&str);\n    t0 = t1 = 0;\n    while(1) {\n        TOK_GET(&t, &macro_str, &cval);\n        if (!t)\n            break;\n        if (t == '#') {\n            /* stringize */\n            do t = *macro_str++; while (t == ' ');\n            s = sym_find2(args, t);\n            if (s) {\n                cstr_reset(&tokcstr);\n                cstr_ccat(&tokcstr, '\\\"');\n                st = s->d;\n                while (*st != TOK_EOF) {\n                    const char *s;\n                    TOK_GET(&t, &st, &cval);\n                    s = get_tok_str(t, &cval);\n                    while (*s) {\n                        if (t == TOK_PPSTR && *s != '\\'')\n                            add_char(&tokcstr, *s);\n                        else\n                            cstr_ccat(&tokcstr, *s);\n                        ++s;\n                    }\n                }\n                cstr_ccat(&tokcstr, '\\\"');\n                cstr_ccat(&tokcstr, '\\0');\n                //printf(\"\\nstringize: <%s>\\n\", (char *)tokcstr.data);\n                /* add string */\n                cval.str.size = tokcstr.size;\n                cval.str.data = tokcstr.data;\n                tok_str_add2(&str, TOK_PPSTR, &cval);\n            } else {\n                expect(\"macro parameter after '#'\");\n            }\n        } else if (t >= TOK_IDENT) {\n            s = sym_find2(args, t);\n            if (s) {\n                st = s->d;\n                n = 0;\n                while ((t2 = macro_str[n]) == ' ')\n                    ++n;\n                /* if '##' is present before or after, no arg substitution */\n                if (t2 == TOK_PPJOIN || t1 == TOK_PPJOIN) {\n                    /* special case for var arg macros : ## eats the ','\n                       if empty VA_ARGS variable. */\n                    if (t1 == TOK_PPJOIN && t0 == ',' && gnu_ext && s->type.t) {\n                        int c = str.str[str.len - 1];\n                        while (str.str[--str.len] != ',')\n                            ;\n                        if (*st == TOK_EOF) {\n                            /* suppress ',' '##' */\n                        } else {\n                            /* suppress '##' and add variable */\n                            str.len++;\n                            if (c == ' ')\n                                str.str[str.len++] = c;\n                            goto add_var;\n                        }\n                    } else {\n                        if (*st == TOK_EOF)\n                            tok_str_add(&str, TOK_PLCHLDR);\n                    }\n                } else {\n            add_var:\n\t\t    if (!s->e) {\n\t\t\t/* Expand arguments tokens and store them.  In most\n\t\t\t   cases we could also re-expand each argument if\n\t\t\t   used multiple times, but not if the argument\n\t\t\t   contains the __COUNTER__ macro.  */\n\t\t\tTokenString str2;\n\t\t\ttok_str_new(&str2);\n\t\t\tmacro_subst(&str2, nested_list, st);\n\t\t\ttok_str_add(&str2, TOK_EOF);\n\t\t\ts->e = str2.str;\n\t\t    }\n\t\t    st = s->e;\n                }\n                while (*st != TOK_EOF) {\n                    TOK_GET(&t2, &st, &cval);\n                    tok_str_add2(&str, t2, &cval);\n                }\n            } else {\n                tok_str_add(&str, t);\n            }\n        } else {\n            tok_str_add2(&str, t, &cval);\n        }\n        if (t != ' ')\n            t0 = t1, t1 = t;\n    }\n    tok_str_add(&str, 0);\n    PP_PRINT((\"areslt:\", 0, str.str));\n    return str.str;\n}\n\n/* handle the '##' operator. return the resulting string (which must be freed). */\nstatic inline int *macro_twosharps(const int *ptr0)\n{\n    int t1, t2, n, l;\n    CValue cv1, cv2;\n    TokenString macro_str1;\n    const int *ptr;\n\n    tok_str_new(&macro_str1);\n    cstr_reset(&tokcstr);\n    for (ptr = ptr0;;) {\n        TOK_GET(&t1, &ptr, &cv1);\n        if (t1 == 0)\n            break;\n        for (;;) {\n            n = 0;\n            while ((t2 = ptr[n]) == ' ')\n                ++n;\n            if (t2 != TOK_PPJOIN)\n                break;\n            ptr += n;\n            while ((t2 = *++ptr) == ' ' || t2 == TOK_PPJOIN)\n                ;\n            TOK_GET(&t2, &ptr, &cv2);\n            if (t2 == TOK_PLCHLDR)\n                continue;\n            if (t1 != TOK_PLCHLDR) {\n                cstr_cat(&tokcstr, get_tok_str(t1, &cv1), -1);\n                t1 = TOK_PLCHLDR;\n            }\n            cstr_cat(&tokcstr, get_tok_str(t2, &cv2), -1);\n        }\n        if (tokcstr.size) {\n            cstr_ccat(&tokcstr, 0);\n            tcc_open_bf(tcc_state, \":paste:\", tokcstr.size);\n            memcpy(file->buffer, tokcstr.data, tokcstr.size);\n            tok_flags = 0; /* don't interpret '#' */\n            for (n = 0;;n = l) {\n                next_nomacro();\n                tok_str_add2(&macro_str1, tok, &tokc);\n                if (*file->buf_ptr == 0)\n                    break;\n                tok_str_add(&macro_str1, ' ');\n                l = file->buf_ptr - file->buffer;\n                tcc_warning(\"pasting \\\"%.*s\\\" and \\\"%s\\\" does not give a valid\"\n                    \" preprocessing token\", l - n, file->buffer + n, file->buf_ptr);\n            }\n            tcc_close();\n            cstr_reset(&tokcstr);\n        }\n        if (t1 != TOK_PLCHLDR)\n            tok_str_add2(&macro_str1, t1, &cv1);\n    }\n    tok_str_add(&macro_str1, 0);\n    PP_PRINT((\"pasted:\", 0, macro_str1.str));\n    return macro_str1.str;\n}\n\nstatic int peek_file (TokenString *ws_str)\n{\n    uint8_t *p = file->buf_ptr - 1;\n    int c;\n    for (;;) {\n        PEEKC(c, p);\n        switch (c) {\n        case '/':\n            PEEKC(c, p);\n            if (c == '*')\n                p = parse_comment(p);\n            else if (c == '/')\n                p = parse_line_comment(p);\n            else {\n                c = *--p = '/';\n                goto leave;\n            }\n            --p, c = ' ';\n            break;\n        case ' ': case '\\t':\n            break;\n        case '\\f': case '\\v': case '\\r':\n            continue;\n        case '\\n':\n            file->line_num++, tok_flags |= TOK_FLAG_BOL;\n            break;\n        default: leave:\n            file->buf_ptr = p;\n            return c;\n        }\n        if (ws_str)\n            tok_str_add(ws_str, c);\n    }\n}\n\n/* peek or read [ws_str == NULL] next token from function macro call,\n   walking up macro levels up to the file if necessary */\nstatic int next_argstream(Sym **nested_list, TokenString *ws_str)\n{\n    int t;\n    Sym *sa;\n\n    while (macro_ptr) {\n        const int *m = macro_ptr;\n        while ((t = *m) != 0) {\n            if (ws_str) {\n                if (t != ' ')\n                    return t;\n                ++m;\n            } else {\n                TOK_GET(&tok, &macro_ptr, &tokc);\n                return tok;\n            }\n        }\n        end_macro();\n        /* also, end of scope for nested defined symbol */\n        sa = *nested_list;\n        if (sa)\n            *nested_list = sa->prev, sym_free(sa);\n    }\n    if (ws_str) {\n        return peek_file(ws_str);\n    } else {\n        next_nomacro();\n        if (tok == '\\t' || tok == TOK_LINEFEED)\n            tok = ' ';\n        return tok;\n    }\n}\n\n/* do macro substitution of current token with macro 's' and add\n   result to (tok_str,tok_len). 'nested_list' is the list of all\n   macros we got inside to avoid recursing. Return non zero if no\n   substitution needs to be done */\nstatic int macro_subst_tok(\n    TokenString *tok_str,\n    Sym **nested_list,\n    Sym *s)\n{\n    int t;\n    int v = s->v;\n\n    PP_PRINT((\"#\", v, s->d));\n    if (s->d) {\n        int *mstr = s->d;\n        int *jstr;\n        Sym *sa;\n        int ret;\n\n        if (s->type.t & MACRO_FUNC) {\n            int saved_parse_flags = parse_flags;\n            TokenString str;\n            int parlevel, i;\n            Sym *sa1, *args;\n\n            parse_flags |= PARSE_FLAG_SPACES | PARSE_FLAG_LINEFEED\n                | PARSE_FLAG_ACCEPT_STRAYS;\n\n            tok_str_new(&str);\n            /* peek next token from argument stream */\n            t = next_argstream(nested_list, &str);\n            if (t != '(') {\n                /* not a macro substitution after all, restore the\n                 * macro token plus all whitespace we've read.\n                 * whitespace is intentionally not merged to preserve\n                 * newlines. */\n                parse_flags = saved_parse_flags;\n                tok_str_add2_spc(tok_str, v, 0);\n                if (parse_flags & PARSE_FLAG_SPACES)\n                    for (i = 0; i < str.len; i++)\n                        tok_str_add(tok_str, str.str[i]);\n                tok_str_free_str(str.str);\n                return 0;\n            } else {\n                tok_str_free_str(str.str);\n            }\n\n            /* argument macro */\n            args = NULL;\n            sa = s->next;\n            /* NOTE: empty args are allowed, except if no args */\n            i = 2; /* eat '(' */\n            for(;;) {\n                do {\n                    t = next_argstream(nested_list, NULL);\n                } while (t == ' ' || --i);\n\n                if (!sa) {\n                    if (t == ')') /* handle '()' case */\n                        break;\n                    tcc_error(\"macro '%s' used with too many args\",\n                        get_tok_str(v, 0));\n                }\n            empty_arg:\n                tok_str_new(&str);\n                parlevel = 0;\n                /* NOTE: non zero sa->type.t indicates VA_ARGS */\n                while (parlevel > 0\n                        || (t != ')' && (t != ',' || sa->type.t))) {\n                    if (t == TOK_EOF)\n                        tcc_error(\"EOF in invocation of macro '%s'\",\n                            get_tok_str(v, 0));\n                    if (t == '(')\n                        parlevel++;\n                    if (t == ')')\n                        parlevel--;\n                    if (t == ' ')\n                        str.need_spc |= 1;\n                    else\n                        tok_str_add2_spc(&str, t, &tokc);\n                    t = next_argstream(nested_list, NULL);\n                }\n                tok_str_add(&str, TOK_EOF);\n                sa1 = sym_push2(&args, sa->v & ~SYM_FIELD, sa->type.t, 0);\n                sa1->d = str.str;\n                sa = sa->next;\n                if (t == ')') {\n                    if (!sa)\n                        break;\n                    /* special case for gcc var args: add an empty\n                       var arg argument if it is omitted */\n                    if (sa->type.t && gnu_ext)\n                        goto empty_arg;\n                    tcc_error(\"macro '%s' used with too few args\",\n                        get_tok_str(v, 0));\n                }\n                i = 1;\n            }\n\n            /* now subst each arg */\n            mstr = macro_arg_subst(nested_list, mstr, args);\n            /* free memory */\n            sa = args;\n            while (sa) {\n                sa1 = sa->prev;\n                tok_str_free_str(sa->d);\n                tok_str_free_str(sa->e);\n                sym_free(sa);\n                sa = sa1;\n            }\n            parse_flags = saved_parse_flags;\n        }\n\n        /* process '##'s (if present) */\n        jstr = mstr;\n        if (s->type.t & MACRO_JOIN)\n            jstr = macro_twosharps(mstr);\n\n        sa = sym_push2(nested_list, v, 0, 0);\n        ret = macro_subst(tok_str, nested_list, jstr);\n        /* pop nested defined symbol */\n        if (sa == *nested_list)\n            *nested_list = sa->prev, sym_free(sa);\n\n        if (jstr != mstr)\n            tok_str_free_str(jstr);\n        if (mstr != s->d)\n            tok_str_free_str(mstr);\n        return ret;\n\n    } else {\n        CValue cval;\n        char buf[32], *cstrval = buf;\n\n        /* special macros */\n        if (v == TOK___LINE__ || v == TOK___COUNTER__) {\n            t = v == TOK___LINE__ ? file->line_num : pp_counter++;\n            snprintf(buf, sizeof(buf), \"%d\", t);\n            t = TOK_PPNUM;\n            goto add_cstr1;\n\n        } else if (v == TOK___FILE__) {\n            cstrval = file->filename;\n            goto add_cstr;\n\n        } else if (v == TOK___DATE__ || v == TOK___TIME__) {\n            time_t ti;\n            struct tm *tm;\n            time(&ti);\n            tm = localtime(&ti);\n            if (v == TOK___DATE__) {\n                static char const ab_month_name[12][4] = {\n                    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n                };\n                snprintf(buf, sizeof(buf), \"%s %2d %d\",\n                    ab_month_name[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);\n            } else {\n                snprintf(buf, sizeof(buf), \"%02d:%02d:%02d\",\n                    tm->tm_hour, tm->tm_min, tm->tm_sec);\n            }\n        add_cstr:\n            t = TOK_STR;\n        add_cstr1:\n            cval.str.size = strlen(cstrval) + 1;\n            cval.str.data = cstrval;\n            tok_str_add2_spc(tok_str, t, &cval);\n        }\n        return 0;\n    }\n}\n\n/* do macro substitution of macro_str and add result to\n   (tok_str,tok_len). 'nested_list' is the list of all macros we got\n   inside to avoid recursing. */\nstatic int macro_subst(\n    TokenString *tok_str,\n    Sym **nested_list,\n    const int *macro_str\n    )\n{\n    Sym *s;\n    int t, nosubst = 0;\n    CValue cval;\n    TokenString *str;\n\n#ifdef PP_DEBUG\n    int tlen = tok_str->len;\n    PP_PRINT((\"+expand:\", 0, macro_str));\n#endif\n\n    while (1) {\n        TOK_GET(&t, &macro_str, &cval);\n        if (t == 0 || t == TOK_EOF)\n            break;\n        if (t >= TOK_IDENT) {\n            s = define_find(t);\n            if (s == NULL || nosubst)\n                goto no_subst;\n            /* if nested substitution, do nothing */\n            if (sym_find2(*nested_list, t)) {\n                /* and mark so it doesn't get subst'd again */\n                t |= SYM_FIELD;\n                goto no_subst;\n            }\n            str = tok_str_alloc();\n            str->str = (int*)macro_str; /* setup stream for possible arguments */\n            begin_macro(str, 2);\n            nosubst = macro_subst_tok(tok_str, nested_list, s);\n            if (macro_stack != str) {\n                /* already finished by reading function macro arguments */\n                break;\n            }\n            macro_str = macro_ptr;\n            end_macro ();\n        } else if (t == ' ') {\n            if (parse_flags & PARSE_FLAG_SPACES)\n                tok_str->need_spc |= 1;\n        } else {\n    no_subst:\n            tok_str_add2_spc(tok_str, t, &cval);\n            if (nosubst && t != '(')\n                nosubst = 0;\n            /* GCC supports 'defined' as result of a macro substitution */\n            if (t == TOK_DEFINED && pp_expr)\n                nosubst = 1;\n        }\n    }\n\n#ifdef PP_DEBUG\n    tok_str_add(tok_str, 0), --tok_str->len;\n    PP_PRINT((\"-result:\", 0, tok_str->str + tlen));\n#endif\n    return nosubst;\n}\n\n/* return next token with macro substitution */\nST_FUNC void next(void)\n{\n    int t;\n    while (macro_ptr) {\nredo:\n        t = *macro_ptr;\n        if (TOK_HAS_VALUE(t)) {\n            tok_get(&tok, &macro_ptr, &tokc);\n            if (t == TOK_LINENUM) {\n                file->line_num = tokc.i;\n                goto redo;\n            }\n            goto convert;\n        } else if (t == 0) {\n            /* end of macro or unget token string */\n            end_macro();\n            continue;\n        } else if (t == TOK_EOF) {\n            /* do nothing */\n        } else {\n            ++macro_ptr;\n            t &= ~SYM_FIELD; /* remove 'nosubst' marker */\n            if (t == '\\\\') {\n                if (!(parse_flags & PARSE_FLAG_ACCEPT_STRAYS))\n                    tcc_error(\"stray '\\\\' in program\");\n            }\n        }\n        tok = t;\n        return;\n    }\n\n    next_nomacro();\n    t = tok;\n    if (t >= TOK_IDENT && (parse_flags & PARSE_FLAG_PREPROCESS)) {\n        /* if reading from file, try to substitute macros */\n        Sym *s = define_find(t);\n        if (s) {\n            Sym *nested_list = NULL;\n            macro_subst_tok(&tokstr_buf, &nested_list, s);\n            tok_str_add(&tokstr_buf, 0);\n            begin_macro(&tokstr_buf, 0);\n            goto redo;\n        }\n        return;\n    }\n\nconvert:\n    /* convert preprocessor tokens into C tokens */\n    if (t == TOK_PPNUM) {\n        if  (parse_flags & PARSE_FLAG_TOK_NUM)\n            parse_number(tokc.str.data);\n    } else if (t == TOK_PPSTR) {\n        if (parse_flags & PARSE_FLAG_TOK_STR)\n            parse_string(tokc.str.data, tokc.str.size - 1);\n    }\n}\n\n/* push back current token and set current token to 'last_tok'. Only\n   identifier case handled for labels. */\nST_INLN void unget_tok(int last_tok)\n{\n    TokenString *str = &unget_buf;\n    int alloc = 0;\n    if (str->len) /* use static buffer except if already in use */\n        str = tok_str_alloc(), alloc = 1;\n    if (tok != TOK_EOF)\n        tok_str_add2(str, tok, &tokc);\n    tok_str_add(str, 0);\n    begin_macro(str, alloc);\n    tok = last_tok;\n}\n\n/* ------------------------------------------------------------------------- */\n/* init preprocessor */\n\nstatic const char * const target_os_defs =\n#ifdef TCC_TARGET_PE\n    \"_WIN32\\0\"\n# if PTR_SIZE == 8\n    \"_WIN64\\0\"\n# endif\n#else\n# if defined TCC_TARGET_MACHO\n    \"__APPLE__\\0\"\n# elif TARGETOS_FreeBSD\n    \"__FreeBSD__ 12\\0\"\n# elif TARGETOS_FreeBSD_kernel\n    \"__FreeBSD_kernel__\\0\"\n# elif TARGETOS_NetBSD\n    \"__NetBSD__\\0\"\n# elif TARGETOS_OpenBSD\n    \"__OpenBSD__\\0\"\n# else\n    \"__linux__\\0\"\n    \"__linux\\0\"\n#  if TARGETOS_ANDROID\n    \"__ANDROID__\\0\"\n#  endif\n# endif\n    \"__unix__\\0\"\n    \"__unix\\0\"\n#endif\n    ;\n\nstatic void putdef(CString *cs, const char *p)\n{\n    cstr_printf(cs, \"#define %s%s\\n\", p, &\" 1\"[!!strchr(p, ' ')*2]);\n}\n\nstatic void putdefs(CString *cs, const char *p)\n{\n    while (*p)\n        putdef(cs, p), p = strchr(p, 0) + 1;\n}\n\nstatic void tcc_predefs(TCCState *s1, CString *cs, int is_asm)\n{\n    cstr_printf(cs, \"#define __TINYC__ 9%.2s\\n\", *& TCC_VERSION + 4);\n    putdefs(cs, target_machine_defs);\n    putdefs(cs, target_os_defs);\n\n#ifdef TCC_TARGET_ARM\n    if (s1->float_abi == ARM_HARD_FLOAT)\n      putdef(cs, \"__ARM_PCS_VFP\");\n#endif\n    if (is_asm)\n      putdef(cs, \"__ASSEMBLER__\");\n    if (s1->output_type == TCC_OUTPUT_PREPROCESS)\n      putdef(cs, \"__TCC_PP__\");\n    if (s1->output_type == TCC_OUTPUT_MEMORY)\n      putdef(cs, \"__TCC_RUN__\");\n#ifdef CONFIG_TCC_BACKTRACE\n    if (s1->do_backtrace)\n      putdef(cs, \"__TCC_BACKTRACE__\");\n#endif\n#ifdef CONFIG_TCC_BCHECK\n    if (s1->do_bounds_check)\n      putdef(cs, \"__TCC_BCHECK__\");\n#endif\n    if (s1->char_is_unsigned)\n      putdef(cs, \"__CHAR_UNSIGNED__\");\n    if (s1->optimize > 0)\n      putdef(cs, \"__OPTIMIZE__\");\n    if (s1->option_pthread)\n      putdef(cs, \"_REENTRANT\");\n    if (s1->leading_underscore)\n      putdef(cs, \"__leading_underscore\");\n    cstr_printf(cs, \"#define __SIZEOF_POINTER__ %d\\n\", PTR_SIZE);\n    cstr_printf(cs, \"#define __SIZEOF_LONG__ %d\\n\", LONG_SIZE);\n    if (!is_asm) {\n      putdef(cs, \"__STDC__\");\n      cstr_printf(cs, \"#define __STDC_VERSION__ %dL\\n\", s1->cversion);\n      cstr_cat(cs,\n        /* load more predefs and __builtins */\n#if CONFIG_TCC_PREDEFS\n        #include \"tccdefs_.h\" /* include as strings */\n#else\n        \"#include <tccdefs.h>\\n\" /* load at runtime */\n#endif\n        , -1);\n    }\n    cstr_printf(cs, \"#define __BASE_FILE__ \\\"%s\\\"\\n\", file->filename);\n}\n\nST_FUNC void preprocess_start(TCCState *s1, int filetype)\n{\n    int is_asm = !!(filetype & (AFF_TYPE_ASM|AFF_TYPE_ASMPP));\n\n    tccpp_new(s1);\n\n    s1->include_stack_ptr = s1->include_stack;\n    s1->ifdef_stack_ptr = s1->ifdef_stack;\n    file->ifdef_stack_ptr = s1->ifdef_stack_ptr;\n    pp_expr = 0;\n    pp_counter = 0;\n    pp_debug_tok = pp_debug_symv = 0;\n    s1->pack_stack[0] = 0;\n    s1->pack_stack_ptr = s1->pack_stack;\n\n    set_idnum('$', !is_asm && s1->dollars_in_identifiers ? IS_ID : 0);\n    set_idnum('.', is_asm ? IS_ID : 0);\n\n    if (!(filetype & AFF_TYPE_ASM)) {\n        CString cstr;\n        cstr_new(&cstr);\n        tcc_predefs(s1, &cstr, is_asm);\n        if (s1->cmdline_defs.size)\n          cstr_cat(&cstr, s1->cmdline_defs.data, s1->cmdline_defs.size);\n        if (s1->cmdline_incl.size)\n          cstr_cat(&cstr, s1->cmdline_incl.data, s1->cmdline_incl.size);\n        //printf(\"%.*s\\n\", cstr.size, (char*)cstr.data);\n        *s1->include_stack_ptr++ = file;\n        tcc_open_bf(s1, \"<command line>\", cstr.size);\n        memcpy(file->buffer, cstr.data, cstr.size);\n        cstr_free(&cstr);\n    }\n    parse_flags = is_asm ? PARSE_FLAG_ASM_FILE : 0;\n}\n\n/* cleanup from error/setjmp */\nST_FUNC void preprocess_end(TCCState *s1)\n{\n    while (macro_stack)\n        end_macro();\n    macro_ptr = NULL;\n    while (file)\n        tcc_close();\n    tccpp_delete(s1);\n}\n\nST_FUNC int set_idnum(int c, int val)\n{\n    int prev = isidnum_table[c - CH_EOF];\n    isidnum_table[c - CH_EOF] = val;\n    return prev;\n}\n\nST_FUNC void tccpp_new(TCCState *s)\n{\n    int i, c;\n    const char *p, *r;\n\n    /* init isid table */\n    for(i = CH_EOF; i<128; i++)\n        set_idnum(i,\n            is_space(i) ? IS_SPC\n            : isid(i) ? IS_ID\n            : isnum(i) ? IS_NUM\n            : 0);\n\n    for(i = 128; i<256; i++)\n        set_idnum(i, IS_ID);\n\n    /* init allocators */\n    tal_new(&toksym_alloc, TOKSYM_TAL_LIMIT, TOKSYM_TAL_SIZE);\n    tal_new(&tokstr_alloc, TOKSTR_TAL_LIMIT, TOKSTR_TAL_SIZE);\n\n    memset(hash_ident, 0, TOK_HASH_SIZE * sizeof(TokenSym *));\n    memset(s->cached_includes_hash, 0, sizeof s->cached_includes_hash);\n\n    cstr_new(&tokcstr);\n    cstr_new(&cstr_buf);\n    cstr_realloc(&cstr_buf, STRING_MAX_SIZE);\n    tok_str_new(&tokstr_buf);\n    tok_str_realloc(&tokstr_buf, TOKSTR_MAX_SIZE);\n    tok_str_new(&unget_buf);\n\n    tok_ident = TOK_IDENT;\n    p = tcc_keywords;\n    while (*p) {\n        r = p;\n        for(;;) {\n            c = *r++;\n            if (c == '\\0')\n                break;\n        }\n        tok_alloc(p, r - p - 1);\n        p = r;\n    }\n\n    /* we add dummy defines for some special macros to speed up tests\n       and to have working defined() */\n    define_push(TOK___LINE__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___FILE__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___DATE__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___TIME__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___COUNTER__, MACRO_OBJ, NULL, NULL);\n}\n\nST_FUNC void tccpp_delete(TCCState *s)\n{\n    int i, n;\n\n    dynarray_reset(&s->cached_includes, &s->nb_cached_includes);\n\n    /* free tokens */\n    n = tok_ident - TOK_IDENT;\n    if (n > total_idents)\n        total_idents = n;\n    for(i = 0; i < n; i++)\n        tal_free(toksym_alloc, table_ident[i]);\n    tcc_free(table_ident);\n    table_ident = NULL;\n\n    /* free static buffers */\n    cstr_free(&tokcstr);\n    cstr_free(&cstr_buf);\n    tok_str_free_str(tokstr_buf.str);\n    tok_str_free_str(unget_buf.str);\n\n    /* free allocators */\n    tal_delete(toksym_alloc);\n    toksym_alloc = NULL;\n    tal_delete(tokstr_alloc);\n    tokstr_alloc = NULL;\n}\n\n/* ------------------------------------------------------------------------- */\n/* tcc -E [-P[1]] [-dD} support */\n\nstatic int pp_need_space(int a, int b);\n\nstatic void tok_print(const int *str, const char *msg, ...)\n{\n    FILE *fp = tcc_state->ppfp;\n    va_list ap;\n    int t, t0, s;\n    CValue cval;\n\n    va_start(ap, msg);\n    vfprintf(fp, msg, ap);\n    va_end(ap);\n\n    s = t0 = 0;\n    while (str) {\n\tTOK_GET(&t, &str, &cval);\n\tif (t == 0 || t == TOK_EOF)\n\t    break;\n        if (pp_need_space(t0, t))\n            s = 0;\n\tfprintf(fp, &\" %s\"[s], t == TOK_PLCHLDR ? \"<>\" : get_tok_str(t, &cval));\n        s = 1, t0 = t;\n    }\n    fprintf(fp, \"\\n\");\n}\n\nstatic void pp_line(TCCState *s1, BufferedFile *f, int level)\n{\n    int d = f->line_num - f->line_ref;\n\n    if (s1->dflag & 4)\n\treturn;\n\n    if (s1->Pflag == LINE_MACRO_OUTPUT_FORMAT_NONE) {\n        ;\n    } else if (level == 0 && f->line_ref && d < 8) {\n\twhile (d > 0)\n\t    fputs(\"\\n\", s1->ppfp), --d;\n    } else if (s1->Pflag == LINE_MACRO_OUTPUT_FORMAT_STD) {\n\tfprintf(s1->ppfp, \"#line %d \\\"%s\\\"\\n\", f->line_num, f->filename);\n    } else {\n\tfprintf(s1->ppfp, \"# %d \\\"%s\\\"%s\\n\", f->line_num, f->filename,\n\t    level > 0 ? \" 1\" : level < 0 ? \" 2\" : \"\");\n    }\n    f->line_ref = f->line_num;\n}\n\nstatic void define_print(TCCState *s1, int v)\n{\n    FILE *fp;\n    Sym *s;\n\n    s = define_find(v);\n    if (NULL == s || NULL == s->d)\n        return;\n\n    fp = s1->ppfp;\n    fprintf(fp, \"#define %s\", get_tok_str(v, NULL));\n    if (s->type.t & MACRO_FUNC) {\n        Sym *a = s->next;\n        fprintf(fp,\"(\");\n        if (a)\n            for (;;) {\n                fprintf(fp,\"%s\", get_tok_str(a->v, NULL));\n                if (!(a = a->next))\n                    break;\n                fprintf(fp,\",\");\n            }\n        fprintf(fp,\")\");\n    }\n    tok_print(s->d, \"\");\n}\n\nstatic void pp_debug_defines(TCCState *s1)\n{\n    int v, t;\n    const char *vs;\n    FILE *fp;\n\n    t = pp_debug_tok;\n    if (t == 0)\n        return;\n\n    file->line_num--;\n    pp_line(s1, file, 0);\n    file->line_ref = ++file->line_num;\n\n    fp = s1->ppfp;\n    v = pp_debug_symv;\n    vs = get_tok_str(v, NULL);\n    if (t == TOK_DEFINE) {\n        define_print(s1, v);\n    } else if (t == TOK_UNDEF) {\n        fprintf(fp, \"#undef %s\\n\", vs);\n    } else if (t == TOK_push_macro) {\n        fprintf(fp, \"#pragma push_macro(\\\"%s\\\")\\n\", vs);\n    } else if (t == TOK_pop_macro) {\n        fprintf(fp, \"#pragma pop_macro(\\\"%s\\\")\\n\", vs);\n    }\n    pp_debug_tok = 0;\n}\n\n/* Add a space between tokens a and b to avoid unwanted textual pasting */\nstatic int pp_need_space(int a, int b)\n{\n    return 'E' == a ? '+' == b || '-' == b\n        : '+' == a ? TOK_INC == b || '+' == b\n        : '-' == a ? TOK_DEC == b || '-' == b\n        : a >= TOK_IDENT || a == TOK_PPNUM ? b >= TOK_IDENT || b == TOK_PPNUM\n        : 0;\n}\n\n/* maybe hex like 0x1e */\nstatic int pp_check_he0xE(int t, const char *p)\n{\n    if (t == TOK_PPNUM && toup(strchr(p, 0)[-1]) == 'E')\n        return 'E';\n    return t;\n}\n\n/* Preprocess the current file */\nST_FUNC int tcc_preprocess(TCCState *s1)\n{\n    BufferedFile **iptr;\n    int token_seen, spcs, level;\n    const char *p;\n    char white[400];\n\n    parse_flags = PARSE_FLAG_PREPROCESS\n                | (parse_flags & PARSE_FLAG_ASM_FILE)\n                | PARSE_FLAG_LINEFEED\n                | PARSE_FLAG_SPACES\n                | PARSE_FLAG_ACCEPT_STRAYS\n                ;\n    /* Credits to Fabrice Bellard's initial revision to demonstrate its\n       capability to compile and run itself, provided all numbers are\n       given as decimals. tcc -E -P10 will do. */\n    if (s1->Pflag == LINE_MACRO_OUTPUT_FORMAT_P10)\n        parse_flags |= PARSE_FLAG_TOK_NUM, s1->Pflag = 1;\n\n    if (s1->do_bench) {\n\t/* for PP benchmarks */\n\tdo next(); while (tok != TOK_EOF);\n\treturn 0;\n    }\n\n    token_seen = TOK_LINEFEED, spcs = 0, level = 0;\n    if (file->prev)\n        pp_line(s1, file->prev, level++);\n    pp_line(s1, file, level);\n\n    for (;;) {\n        iptr = s1->include_stack_ptr;\n        next();\n        if (tok == TOK_EOF)\n            break;\n\n        level = s1->include_stack_ptr - iptr;\n        if (level) {\n            if (level > 0)\n                pp_line(s1, *iptr, 0);\n            pp_line(s1, file, level);\n        }\n        if (s1->dflag & 7) {\n            pp_debug_defines(s1);\n            if (s1->dflag & 4)\n                continue;\n        }\n\n        if (is_space(tok)) {\n            if (spcs < sizeof white - 1)\n                white[spcs++] = tok;\n            continue;\n        } else if (tok == TOK_LINEFEED) {\n            spcs = 0;\n            if (token_seen == TOK_LINEFEED)\n                continue;\n            ++file->line_ref;\n        } else if (token_seen == TOK_LINEFEED) {\n            pp_line(s1, file, 0);\n        } else if (spcs == 0 && pp_need_space(token_seen, tok)) {\n            white[spcs++] = ' ';\n        }\n\n        white[spcs] = 0, fputs(white, s1->ppfp), spcs = 0;\n        fputs(p = get_tok_str(tok, &tokc), s1->ppfp);\n        token_seen = pp_check_he0xE(tok, p);\n    }\n    return 0;\n}\n\n/* ------------------------------------------------------------------------- */\n"
        },
        {
          "name": "tccrun.c",
          "type": "blob",
          "size": 42.322265625,
          "content": "/*\n *  TCC - Tiny C Compiler - Support for -run switch\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"tcc.h\"\n\n/* only native compiler supports -run */\n#ifdef TCC_IS_NATIVE\n\n#ifdef CONFIG_TCC_BACKTRACE\n/* runtime debug info block */\ntypedef struct rt_context\n{\n    /* tccelf.c:tcc_add_btstub() wants these in that order: */\n    union {\n\tstruct {\n\t    Stab_Sym *stab_sym;\n\t    Stab_Sym *stab_sym_end;\n\t    char *stab_str;\n\t};\n\tstruct {\n\t    unsigned char *dwarf_line;\n\t    unsigned char *dwarf_line_end;\n\t    unsigned char *dwarf_line_str;\n\t};\n    };\n    ElfW(Sym) *esym_start;\n    ElfW(Sym) *esym_end;\n    char *elf_str;\n    // 6 * PTR_SIZE\n    addr_t prog_base;\n    void *bounds_start;\n    void *top_func;\n    struct rt_context *next;\n    // 10 * PTR_SIZE\n    int num_callers;\n    int dwarf;\n} rt_context;\n\n/* linked list of rt_contexts */\nstatic rt_context *g_rc;\nstatic int signal_set;\nstatic void set_exception_handler(void);\n#endif /* def CONFIG_TCC_BACKTRACE */\n\ntypedef struct rt_frame {\n    addr_t ip, fp, sp;\n} rt_frame;\n\nstatic TCCState *g_s1;\n/* semaphore to protect it */\nTCC_SEM(static rt_sem);\nstatic void rt_wait_sem(void) { WAIT_SEM(&rt_sem); }\nstatic void rt_post_sem(void) { POST_SEM(&rt_sem); }\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *f, int level);\nstatic void rt_exit(rt_frame *f, int code);\n\n/* ------------------------------------------------------------- */\n/* defined when included from lib/bt-exe.c */\n#ifndef CONFIG_TCC_BACKTRACE_ONLY\n\n#ifndef _WIN32\n# include <sys/mman.h>\n#endif\n\nstatic int protect_pages(void *ptr, unsigned long length, int mode);\nstatic int tcc_relocate_ex(TCCState *s1, void *ptr, unsigned ptr_diff);\nstatic void st_link(TCCState *s1);\nstatic void st_unlink(TCCState *s1);\n#ifdef CONFIG_TCC_BACKTRACE\nstatic int _tcc_backtrace(rt_frame *f, const char *fmt, va_list ap);\n#endif\n#ifdef _WIN64\nstatic void *win64_add_function_table(TCCState *s1);\nstatic void win64_del_function_table(void *);\n#endif\n\n#if !defined PAGESIZE\n# if defined _SC_PAGESIZE\n#  define PAGESIZE sysconf(_SC_PAGESIZE)\n# elif defined __APPLE__\n#  include <libkern/OSCacheControl.h>\n#  define PAGESIZE getpagesize()\n# else\n#  define PAGESIZE 4096\n# endif\n#endif\n\n#define PAGEALIGN(n) ((addr_t)n + (-(addr_t)n & (PAGESIZE-1)))\n\n#if !_WIN32 && !__APPLE__\n//#define CONFIG_SELINUX 1\n#endif\n\nstatic int rt_mem(TCCState *s1, int size)\n{\n    void *ptr;\n    int ptr_diff = 0;\n#ifdef CONFIG_SELINUX\n    /* Using mmap instead of malloc */\n    void *prw;\n    char tmpfname[] = \"/tmp/.tccrunXXXXXX\";\n    int fd = mkstemp(tmpfname);\n    unlink(tmpfname);\n    ftruncate(fd, size);\n\n    ptr = mmap(NULL, size * 2, PROT_READ|PROT_EXEC, MAP_SHARED, fd, 0);\n    /* mmap RW memory at fixed distance */\n    prw = mmap((char*)ptr + size, size, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, fd, 0);\n    close(fd);\n    if (ptr == MAP_FAILED || prw == MAP_FAILED)\n\treturn tcc_error_noabort(\"tccrun: could not map memory\");\n    ptr_diff = (char*)prw - (char*)ptr; /* = size; */\n    //printf(\"map %p %p %p\\n\", ptr, prw, (void*)ptr_diff);\n    size *= 2;\n#else\n    ptr = tcc_malloc(size += PAGESIZE); /* one extra page to align malloc memory */\n#endif\n    s1->run_ptr = ptr;\n    s1->run_size = size;\n    return ptr_diff;\n}\n\n/* ------------------------------------------------------------- */\n/* Do all relocations (needed before using tcc_get_symbol())\n   Returns -1 on error. */\n\nLIBTCCAPI int tcc_relocate(TCCState *s1)\n{\n    int size, ret, ptr_diff;\n\n    if (s1->run_ptr)\n        exit(tcc_error_noabort(\"'tcc_relocate()' twice is no longer supported\"));\n#ifdef CONFIG_TCC_BACKTRACE\n    if (s1->do_backtrace)\n        tcc_add_symbol(s1, \"_tcc_backtrace\", _tcc_backtrace); /* for bt-log.c */\n#endif\n    size = tcc_relocate_ex(s1, NULL, 0);\n    if (size < 0)\n        return -1;\n    ptr_diff = rt_mem(s1, size);\n    if (ptr_diff < 0)\n        return -1;\n    ret = tcc_relocate_ex(s1, s1->run_ptr, ptr_diff);\n    if (ret == 0)\n        st_link(s1);\n    return ret;\n}\n\nST_FUNC void tcc_run_free(TCCState *s1)\n{\n    unsigned size;\n    void *ptr;\n    int i;\n\n    /* free any loaded DLLs */\n    for ( i = 0; i < s1->nb_loaded_dlls; i++) {\n        DLLReference *ref = s1->loaded_dlls[i];\n        if ( ref->handle )\n#ifdef _WIN32\n            FreeLibrary((HMODULE)ref->handle);\n#else\n            dlclose(ref->handle);\n#endif\n    }\n    /* unmap or unprotect and free memory */\n    ptr = s1->run_ptr;\n    if (NULL == ptr)\n        return;\n    st_unlink(s1);\n    size = s1->run_size;\n#ifdef CONFIG_SELINUX\n    munmap(ptr, size);\n#else\n    /* unprotect memory to make it usable for malloc again */\n    protect_pages((void*)PAGEALIGN(ptr), size - PAGESIZE, 2 /*rw*/);\n# ifdef _WIN64\n    win64_del_function_table(s1->run_function_table);\n# endif\n    tcc_free(ptr);\n#endif\n}\n\n#define RT_EXIT_ZERO 0xE0E00E0E /* passed from longjmp instead of '0' */\n\n/* launch the compiled program with the given arguments */\nLIBTCCAPI int tcc_run(TCCState *s1, int argc, char **argv)\n{\n    int (*prog_main)(int, char **, char **), ret;\n    const char *top_sym;\n    jmp_buf main_jb;\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n    char **envp = NULL;\n#elif defined(__OpenBSD__) || defined(__NetBSD__)\n    extern char **environ;\n    char **envp = environ;\n#else\n    char **envp = environ;\n#endif\n\n    /* tcc -dt -run ... nothing to do if no main() */\n    if ((s1->dflag & 16) && (addr_t)-1 == get_sym_addr(s1, \"main\", 0, 1))\n        return 0;\n\n    tcc_add_symbol(s1, \"__rt_exit\", rt_exit);\n    if (s1->nostdlib) {\n        s1->run_main = top_sym = \"_start\";\n    } else {\n        tcc_add_support(s1, \"runmain.o\");\n        s1->run_main = \"_runmain\";\n        top_sym = \"main\";\n    }\n    if (tcc_relocate(s1) < 0)\n        return -1;\n\n    prog_main = (void*)get_sym_addr(s1, s1->run_main, 1, 1);\n    if ((addr_t)-1 == (addr_t)prog_main)\n        return -1;\n    errno = 0; /* clean errno value */\n    fflush(stdout);\n    fflush(stderr);\n\n    ret = tcc_setjmp(s1, main_jb, tcc_get_symbol(s1, top_sym));\n    if (0 == ret)\n        ret = prog_main(argc, argv, envp);\n    else if (RT_EXIT_ZERO == ret)\n        ret = 0;\n\n    if (s1->dflag & 16 && ret) /* tcc -dt -run ... */\n        fprintf(s1->ppfp, \"[returns %d]\\n\", ret), fflush(s1->ppfp);\n    return ret;\n}\n\n/* ------------------------------------------------------------- */\n/* remove all STB_LOCAL symbols */\nstatic void cleanup_symbols(TCCState *s1)\n{\n    Section *s = s1->symtab;\n    int sym_index, end_sym = s->data_offset / sizeof (ElfSym);\n    /* reset symtab */\n    s->data_offset = s->link->data_offset = s->hash->data_offset = 0;\n    init_symtab(s);\n    /* add global symbols again */\n    for (sym_index = 1; sym_index < end_sym; ++sym_index) {\n        ElfW(Sym) *sym = &((ElfW(Sym) *)s->data)[sym_index];\n        const char *name = (char *)s->link->data + sym->st_name;\n        if (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL)\n            continue;\n        //printf(\"sym %s\\n\", name);\n        put_elf_sym(s, sym->st_value, sym->st_size, sym->st_info, sym->st_other, sym->st_shndx, name);\n    }\n}\n\n/* free all sections except symbols */\nstatic void cleanup_sections(TCCState *s1)\n{\n    struct { Section **secs; int nb_secs; } *p = (void*)&s1->sections;\n    int i, f = 2;\n    do {\n        for (i = --f; i < p->nb_secs; i++) {\n            Section *s = p->secs[i];\n            if (s == s1->symtab || s == s1->symtab->link || s == s1->symtab->hash) {\n                s->data = tcc_realloc(s->data, s->data_allocated = s->data_offset);\n            } else {\n                free_section(s), tcc_free(s), p->secs[i] = NULL;\n            }\n        }\n    } while (++p, f);\n}\n\n/* ------------------------------------------------------------- */\n/* 0 = .text rwx  other rw (memory >= 2 pages a 4096 bytes) */\n/* 1 = .text rx   other rw (memory >= 3 pages) */\n/* 2 = .text rx  .rdata ro  .data/.bss rw (memory >= 4 pages) */\n\n/* Some targets implement secutiry options that do not allow write in\n   executable code. These targets need CONFIG_RUNMEM_RO=1.\n   The disadvantage of this is that it requires a little bit more memory. */\n\n#ifndef CONFIG_RUNMEM_RO\n# ifdef __APPLE__\n#   define CONFIG_RUNMEM_RO 1\n# else\n#   define CONFIG_RUNMEM_RO 0\n#  endif\n#endif\n\n/* relocate code. Return -1 on error, required size if ptr is NULL,\n   otherwise copy code into buffer passed by the caller */\nstatic int tcc_relocate_ex(TCCState *s1, void *ptr, unsigned ptr_diff)\n{\n    Section *s;\n    unsigned offset, length, align, i, k, f;\n    unsigned n, copy;\n    addr_t mem, addr;\n\n    if (NULL == ptr) {\n#ifdef TCC_TARGET_PE\n        pe_output_file(s1, NULL);\n#else\n        tcc_add_runtime(s1);\n\tresolve_common_syms(s1);\n        build_got_entries(s1, 0);\n#endif\n    }\n\n    offset = copy = 0;\n    mem = (addr_t)ptr;\nredo:\n    if (s1->verbose == 2 && copy)\n        printf(&\"-----------------------------------------------------\\n\"[PTR_SIZE*2 - 8]);\n    if (s1->nb_errors)\n        return -1;\n    if (copy == 3)\n        return 0;\n\n    for (k = 0; k < 3; ++k) { /* 0:rx, 1:ro, 2:rw sections */\n        n = 0; addr = 0;\n        for(i = 1; i < s1->nb_sections; i++) {\n            static const char shf[] = {\n                SHF_ALLOC|SHF_EXECINSTR, SHF_ALLOC, SHF_ALLOC|SHF_WRITE\n                };\n            s = s1->sections[i];\n            if (shf[k] != (s->sh_flags & (SHF_ALLOC|SHF_WRITE|SHF_EXECINSTR)))\n                continue;\n            length = s->data_offset;\n            if (copy == 2) {\n                if (addr == 0)\n                    addr = s->sh_addr;\n                n = (s->sh_addr - addr) + length;\n                continue;\n            }\n            if (copy) { /* final step: copy section data to memory */\n                if (s1->verbose == 2)\n                    printf(\"%d: %-16s %p  len %05x  align %04x\\n\",\n                        k, s->name, (void*)s->sh_addr, length, s->sh_addralign);\n                ptr = (void*)s->sh_addr;\n                if (k == 0)\n                    ptr = (void*)(s->sh_addr + ptr_diff);\n                if (NULL == s->data || s->sh_type == SHT_NOBITS)\n                    memset(ptr, 0, length);\n                else\n                    memcpy(ptr, s->data, length);\n                continue;\n            }\n\n            align = s->sh_addralign;\n            if (++n == 1) {\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64\n                /* To avoid that x86 processors would reload cached instructions\n                   each time when data is written in the near, we need to make\n                   sure that code and data do not share the same 64 byte unit */\n                if (align < 64)\n                    align = 64;\n#endif\n                /* start new page for different permissions */\n                if (k <= CONFIG_RUNMEM_RO)\n                    align = PAGESIZE;\n            }\n            s->sh_addralign = align;\n            addr = k ? mem + ptr_diff : mem;\n            offset += -(addr + offset) & (align - 1);\n            s->sh_addr = mem ? addr + offset : 0;\n            offset += length;\n        }\n        if (copy == 2) { /* set permissions */\n            if (n == 0) /* no data  */\n                continue;\n#ifdef CONFIG_SELINUX\n            if (k == 0) /* SHF_EXECINSTR has its own mapping */\n                continue;\n#endif\n            f = k;\n            if (f >= CONFIG_RUNMEM_RO) {\n                if (f != 0)\n                    continue;\n                f = 3; /* change only SHF_EXECINSTR to rwx */\n            }\n            n = PAGEALIGN(n);\n            if (s1->verbose == 2) {\n                printf(\"protect         %3s %p  len %05x\\n\",\n                    &\"rx\\0ro\\0rw\\0rwx\"[f*3], (void*)addr, (unsigned)n);\n            }\n            if (protect_pages((void*)addr, n, f) < 0)\n                return tcc_error_noabort(\n                    \"mprotect failed (did you mean to configure --with-selinux?)\");\n        }\n    }\n\n    if (0 == mem)\n        return PAGEALIGN(offset);\n\n    if (++copy == 2) {\n        goto redo;\n    }\n    if (copy == 3) {\n#ifdef _WIN64\n        s1->run_function_table = win64_add_function_table(s1);\n#endif\n        /* remove local symbols and free sections except symtab */\n        cleanup_symbols(s1);\n        cleanup_sections(s1);\n        goto redo;\n    }\n\n    /* relocate symbols */\n    relocate_syms(s1, s1->symtab, !(s1->nostdlib));\n    /* relocate sections */\n#ifdef TCC_TARGET_PE\n    s1->pe_imagebase = mem;\n#else\n    relocate_plt(s1);\n#endif\n    relocate_sections(s1);\n    goto redo;\n}\n\n/* ------------------------------------------------------------- */\n/* allow to run code in memory */\n\nstatic int protect_pages(void *ptr, unsigned long length, int mode)\n{\n#ifdef _WIN32\n    static const unsigned char protect[] = {\n        PAGE_EXECUTE_READ,\n        PAGE_READONLY,\n        PAGE_READWRITE,\n        PAGE_EXECUTE_READWRITE\n        };\n    DWORD old;\n    if (!VirtualProtect(ptr, length, protect[mode], &old))\n        return -1;\n#else\n    static const unsigned char protect[] = {\n        PROT_READ | PROT_EXEC,\n        PROT_READ,\n        PROT_READ | PROT_WRITE,\n        PROT_READ | PROT_WRITE | PROT_EXEC\n        };\n    if (mprotect(ptr, length, protect[mode]))\n        return -1;\n/* XXX: BSD sometimes dump core with bad system call */\n# if (defined TCC_TARGET_ARM && !TARGETOS_BSD) || defined TCC_TARGET_ARM64\n    if (mode == 0 || mode == 3) {\n        void __clear_cache(void *beginning, void *end);\n        __clear_cache(ptr, (char *)ptr + length);\n    }\n# endif\n#endif\n    return 0;\n}\n\n#ifdef _WIN64\nstatic void *win64_add_function_table(TCCState *s1)\n{\n    void *p = NULL;\n    if (s1->uw_pdata) {\n        p = (void*)s1->uw_pdata->sh_addr;\n        RtlAddFunctionTable(\n            (RUNTIME_FUNCTION*)p,\n            s1->uw_pdata->data_offset / sizeof (RUNTIME_FUNCTION),\n            s1->pe_imagebase\n            );\n        s1->uw_pdata = NULL;\n    }\n    return p;\n}\n\nstatic void win64_del_function_table(void *p)\n{\n    if (p) {\n        RtlDeleteFunctionTable((RUNTIME_FUNCTION*)p);\n    }\n}\n#endif\n\nstatic void bt_link(TCCState *s1)\n{\n#ifdef CONFIG_TCC_BACKTRACE\n    rt_context *rc;\n    void *p;\n\n    if (!s1->do_backtrace)\n        return;\n    rc = tcc_get_symbol(s1, \"__rt_info\");\n    if (!rc)\n        return;\n    rc->esym_start = (ElfW(Sym) *)(symtab_section->data);\n    rc->esym_end = (ElfW(Sym) *)(symtab_section->data + symtab_section->data_offset);\n    rc->elf_str = (char *)symtab_section->link->data;\n    if (PTR_SIZE == 8 && !s1->dwarf)\n        rc->prog_base &= 0xffffffff00000000ULL;\n#ifdef CONFIG_TCC_BCHECK\n    if (s1->do_bounds_check) {\n        if ((p = tcc_get_symbol(s1, \"__bound_init\")))\n            ((void(*)(void*,int))p)(rc->bounds_start, 1);\n    }\n#endif\n    rc->next = g_rc, g_rc = rc, s1->rc = rc;\n    if (0 == signal_set)\n        set_exception_handler(), signal_set = 1;\n#endif\n}\n\nstatic void st_link(TCCState *s1)\n{\n    rt_wait_sem();\n    s1->next = g_s1, g_s1 = s1;\n    bt_link(s1);\n    rt_post_sem();\n}\n\n/* remove 'el' from 'list' */\nstatic void ptr_unlink(void *list, void *e, unsigned next)\n{\n    void **pp, **nn, *p;\n    for (pp = list; !!(p = *pp); pp = nn) {\n        nn = (void*)((char*)p + next); /* nn = &p->next; */\n        if (p == e) {\n            *pp = *nn;\n            break;\n        }\n    }\n}\n\nstatic void st_unlink(TCCState *s1)\n{\n    rt_wait_sem();\n#ifdef CONFIG_TCC_BACKTRACE\n    ptr_unlink(&g_rc, s1->rc, offsetof(rt_context, next));\n#endif\n    ptr_unlink(&g_s1, s1, offsetof(TCCState, next));\n    rt_post_sem();\n}\n\nLIBTCCAPI void *_tcc_setjmp(TCCState *s1, void *p_jmp_buf, void *func, void *p_longjmp)\n{\n    s1->run_lj = p_longjmp;\n    s1->run_jb = p_jmp_buf;\n#ifdef CONFIG_TCC_BACKTRACE\n    if (s1->rc)\n        s1->rc->top_func = func;\n#endif\n    return p_jmp_buf;\n}\n\nLIBTCCAPI void tcc_set_backtrace_func(TCCState *s1, void *data, TCCBtFunc *func)\n{\n    s1->bt_func = func;\n    s1->bt_data = data;\n}\n\nstatic TCCState *rt_find_state(rt_frame *f)\n{\n    TCCState *s;\n    int level;\n    addr_t pc;\n\n    s = g_s1;\n    if (NULL == s || NULL == s->next) {\n        /* play it safe in the simple case when there is only one state */\n        return s;\n    }\n    for (level = 0; level < 8; ++level) {\n        if (rt_get_caller_pc(&pc, f, level) < 0)\n            break;\n        for (s = g_s1; s; s = s->next) {\n            if (pc >= (addr_t)s->run_ptr\n             && pc  < (addr_t)s->run_ptr + s->run_size)\n                return s;\n        }\n    }\n    return NULL;\n}\n\nstatic void rt_exit(rt_frame *f, int code)\n{\n    TCCState *s;\n    rt_wait_sem();\n    s = rt_find_state(f);\n    rt_post_sem();\n    if (s && s->run_lj) {\n        if (code == 0)\n            code = RT_EXIT_ZERO;\n        ((void(*)(void*,int))s->run_lj)(s->run_jb, code);\n    }\n    exit(code);\n}\n\n/* ------------------------------------------------------------- */\n#else // if defined CONFIG_TCC_BACKTRACE_ONLY\nstatic void rt_exit(rt_frame *f, int code)\n{\n    exit(code);\n}\n#endif //ndef CONFIG_TCC_BACKTRACE_ONLY\n/* ------------------------------------------------------------- */\n#ifdef CONFIG_TCC_BACKTRACE\n\nstatic int rt_vprintf(const char *fmt, va_list ap)\n{\n    int ret = vfprintf(stderr, fmt, ap);\n    fflush(stderr);\n    return ret;\n}\n\nstatic int rt_printf(const char *fmt, ...)\n{\n    va_list ap;\n    int r;\n    va_start(ap, fmt);\n    r = rt_vprintf(fmt, ap);\n    va_end(ap);\n    return r;\n}\n\nstatic char *rt_elfsym(rt_context *rc, addr_t wanted_pc, addr_t *func_addr)\n{\n    ElfW(Sym) *esym;\n    for (esym = rc->esym_start + 1; esym < rc->esym_end; ++esym) {\n        int type = ELFW(ST_TYPE)(esym->st_info);\n        if ((type == STT_FUNC || type == STT_GNU_IFUNC)\n            && wanted_pc >= esym->st_value\n            && wanted_pc < esym->st_value + esym->st_size) {\n            *func_addr = esym->st_value;\n            return rc->elf_str + esym->st_name;\n        }\n    }\n    return NULL;\n}\n\ntypedef struct bt_info\n{\n    char file[100];\n    int line;\n    char func[100];\n    addr_t func_pc;\n} bt_info;\n\n/* print the position in the source file of PC value 'pc' by reading\n   the stabs debug information */\nstatic addr_t rt_printline (rt_context *rc, addr_t wanted_pc, bt_info *bi)\n{\n    char func_name[128];\n    addr_t func_addr, last_pc, pc;\n    const char *incl_files[INCLUDE_STACK_SIZE];\n    int incl_index, last_incl_index, len, last_line_num, i;\n    const char *str, *p;\n    Stab_Sym *sym;\n\n    func_name[0] = '\\0';\n    func_addr = 0;\n    incl_index = 0;\n    last_pc = (addr_t)-1;\n    last_line_num = 1;\n    last_incl_index = 0;\n\n    for (sym = rc->stab_sym + 1; sym < rc->stab_sym_end; ++sym) {\n        str = rc->stab_str + sym->n_strx;\n        pc = sym->n_value;\n\n        switch(sym->n_type) {\n        case N_SLINE:\n            if (func_addr)\n                goto rel_pc;\n        case N_SO:\n        case N_SOL:\n            goto abs_pc;\n        case N_FUN:\n            if (sym->n_strx == 0) /* end of function */\n                goto rel_pc;\n        abs_pc:\n#if PTR_SIZE == 8\n            /* Stab_Sym.n_value is only 32bits */\n            pc += rc->prog_base;\n#endif\n            goto check_pc;\n        rel_pc:\n            pc += func_addr;\n        check_pc:\n            if (pc >= wanted_pc && wanted_pc >= last_pc)\n                goto found;\n            break;\n        }\n\n        switch(sym->n_type) {\n            /* function start or end */\n        case N_FUN:\n            if (sym->n_strx == 0)\n                goto reset_func;\n            p = strchr(str, ':');\n            if (0 == p || (len = p - str + 1, len > sizeof func_name))\n                len = sizeof func_name;\n            pstrcpy(func_name, len, str);\n            func_addr = pc;\n            break;\n            /* line number info */\n        case N_SLINE:\n            last_pc = pc;\n            last_line_num = sym->n_desc;\n            last_incl_index = incl_index;\n            break;\n            /* include files */\n        case N_BINCL:\n            if (incl_index < INCLUDE_STACK_SIZE)\n                incl_files[incl_index++] = str;\n            break;\n        case N_EINCL:\n            if (incl_index > 1)\n                incl_index--;\n            break;\n            /* start/end of translation unit */\n        case N_SO:\n            incl_index = 0;\n            if (sym->n_strx) {\n                /* do not add path */\n                len = strlen(str);\n                if (len > 0 && str[len - 1] != '/')\n                    incl_files[incl_index++] = str;\n            }\n        reset_func:\n            func_name[0] = '\\0';\n            func_addr = 0;\n            last_pc = (addr_t)-1;\n            break;\n            /* alternative file name (from #line or #include directives) */\n        case N_SOL:\n            if (incl_index)\n                incl_files[incl_index-1] = str;\n            break;\n        }\n    }\n    last_incl_index = 0, func_name[0] = 0, func_addr = 0;\nfound:\n    i = last_incl_index;\n    if (i > 0) {\n        pstrcpy(bi->file, sizeof bi->file, incl_files[--i]);\n        bi->line = last_line_num;\n    }\n    pstrcpy(bi->func, sizeof bi->func, func_name);\n    bi->func_pc = func_addr;\n    return func_addr;\n}\n\n/* ------------------------------------------------------------- */\n/* rt_printline - dwarf version */\n\n#define DIR_TABLE_SIZE\t(64)\n#define FILE_TABLE_SIZE\t(512)\n\n#define\tdwarf_ignore_type(ln, end) /* timestamp/size/md5/... */ \\\n\tswitch (entry_format[j].form) { \\\n\tcase DW_FORM_data1: (ln) += 1; break; \\\n\tcase DW_FORM_data2: (ln) += 2; break; \\\n\tcase DW_FORM_data4: (ln) += 3; break; \\\n\tcase DW_FORM_data8: (ln) += 8; break; \\\n\tcase DW_FORM_data16: (ln) += 16; break; \\\n\tcase DW_FORM_udata: dwarf_read_uleb128(&(ln), (end)); break; \\\n\tdefault: goto next_line; \\\n\t}\n\nstatic addr_t rt_printline_dwarf (rt_context *rc, addr_t wanted_pc, bt_info *bi)\n{\n    unsigned char *ln;\n    unsigned char *cp;\n    unsigned char *end;\n    unsigned char *opcode_length;\n    unsigned long long size;\n    unsigned int length;\n    unsigned char version;\n    unsigned int min_insn_length;\n    unsigned int max_ops_per_insn;\n    int line_base;\n    unsigned int line_range;\n    unsigned int opcode_base;\n    unsigned int opindex;\n    unsigned int col;\n    unsigned int i;\n    unsigned int j;\n    unsigned int len;\n    unsigned long long value;\n    struct {\n\tunsigned int type;\n\tunsigned int form;\n    } entry_format[256];\n    unsigned int dir_size;\n#if 0\n    char *dirs[DIR_TABLE_SIZE];\n#endif\n    unsigned int filename_size;\n    struct /*dwarf_filename_struct*/ {\n        unsigned int dir_entry;\n        char *name;\n    } filename_table[FILE_TABLE_SIZE];\n    addr_t last_pc;\n    addr_t pc;\n    addr_t func_addr;\n    int line;\n    char *filename;\n    char *function;\n\n    filename = NULL;\n    function = NULL;\n    func_addr = 0;\n    line = 0;\n\n    ln = rc->dwarf_line;\n    while (ln < rc->dwarf_line_end) {\n\tdir_size = 0;\n\tfilename_size = 0;\n        last_pc = 0;\n        pc = 0;\n        func_addr = 0;\n        line = 1;\n        filename = NULL;\n        function = NULL;\n\tlength = 4;\n\tsize = dwarf_read_4(ln, rc->dwarf_line_end);\n\tif (size == 0xffffffffu) // dwarf 64\n\t    length = 8, size = dwarf_read_8(ln, rc->dwarf_line_end);\n\tend = ln + size;\n\tif (end < ln || end > rc->dwarf_line_end)\n\t    break;\n\tversion = dwarf_read_2(ln, end);\n\tif (version >= 5)\n\t    ln += length + 2; // address size, segment selector, prologue Length\n\telse\n\t    ln += length; // prologue Length\n\tmin_insn_length = dwarf_read_1(ln, end);\n\tif (version >= 4)\n\t    max_ops_per_insn = dwarf_read_1(ln, end);\n\telse\n\t    max_ops_per_insn = 1;\n\tln++; // Initial value of 'is_stmt'\n\tline_base = dwarf_read_1(ln, end);\n\tline_base |= line_base >= 0x80 ? ~0xff : 0;\n\tline_range = dwarf_read_1(ln, end);\n\topcode_base = dwarf_read_1(ln, end);\n\topcode_length = ln;\n\tln += opcode_base - 1;\n\topindex = 0;\n\tif (version >= 5) {\n\t    col = dwarf_read_1(ln, end);\n\t    for (i = 0; i < col; i++) {\n\t        entry_format[i].type = dwarf_read_uleb128(&ln, end);\n\t        entry_format[i].form = dwarf_read_uleb128(&ln, end);\n\t    }\n\t    dir_size = dwarf_read_uleb128(&ln, end);\n\t    for (i = 0; i < dir_size; i++) {\n\t\tfor (j = 0; j < col; j++) {\n\t\t    if (entry_format[j].type == DW_LNCT_path) {\n\t\t        if (entry_format[j].form != DW_FORM_line_strp)\n\t\t\t    goto next_line;\n#if 0\n\t\t        value = length == 4 ? dwarf_read_4(ln, end)\n\t\t\t\t\t    : dwarf_read_8(ln, end);\n\t\t        if (i < DIR_TABLE_SIZE)\n\t\t            dirs[i] = (char *)rc->dwarf_line_str + value;\n#else\n\t\t\tlength == 4 ? dwarf_read_4(ln, end)\n\t\t\t\t    : dwarf_read_8(ln, end);\n#endif\n\t\t    }\n\t\t    else \n\t\t\tdwarf_ignore_type(ln, end);\n\t\t}\n\t    }\n\t    col = dwarf_read_1(ln, end);\n\t    for (i = 0; i < col; i++) {\n\t        entry_format[i].type = dwarf_read_uleb128(&ln, end);\n\t        entry_format[i].form = dwarf_read_uleb128(&ln, end);\n\t    }\n\t    filename_size = dwarf_read_uleb128(&ln, end);\n\t    for (i = 0; i < filename_size; i++)\n\t\tfor (j = 0; j < col; j++) {\n\t\t    if (entry_format[j].type == DW_LNCT_path) {\n\t\t\tif (entry_format[j].form != DW_FORM_line_strp)\n\t\t\t    goto next_line;\n\t\t\tvalue = length == 4 ? dwarf_read_4(ln, end)\n\t\t\t\t\t    : dwarf_read_8(ln, end);\n\t\t        if (i < FILE_TABLE_SIZE)\n\t\t            filename_table[i].name =\n\t\t\t\t(char *)rc->dwarf_line_str + value;\n\t            }\n\t\t    else if (entry_format[j].type == DW_LNCT_directory_index) {\n\t\t\tswitch (entry_format[j].form) {\n\t\t\tcase DW_FORM_data1: value = dwarf_read_1(ln, end); break;\n\t\t\tcase DW_FORM_data2: value = dwarf_read_2(ln, end); break;\n\t\t\tcase DW_FORM_data4: value = dwarf_read_4(ln, end); break;\n\t\t\tcase DW_FORM_udata: value = dwarf_read_uleb128(&ln, end); break;\n\t\t\tdefault: goto next_line;\n\t\t\t}\n\t\t        if (i < FILE_TABLE_SIZE)\n\t\t            filename_table[i].dir_entry = value;\n\t\t    }\n\t\t    else \n\t\t\tdwarf_ignore_type(ln, end);\n\t    }\n\t}\n\telse {\n\t    while ((dwarf_read_1(ln, end))) {\n#if 0\n\t\tif (++dir_size < DIR_TABLE_SIZE)\n\t\t    dirs[dir_size - 1] = (char *)ln - 1;\n#endif\n\t\twhile (dwarf_read_1(ln, end)) {}\n\t    }\n\t    while ((dwarf_read_1(ln, end))) {\n\t\tif (++filename_size < FILE_TABLE_SIZE) {\n\t\t    filename_table[filename_size - 1].name = (char *)ln - 1;\n\t\t    while (dwarf_read_1(ln, end)) {}\n\t\t    filename_table[filename_size - 1].dir_entry =\n\t\t        dwarf_read_uleb128(&ln, end);\n\t\t}\n\t\telse {\n\t\t    while (dwarf_read_1(ln, end)) {}\n\t\t    dwarf_read_uleb128(&ln, end);\n\t\t}\n\t\tdwarf_read_uleb128(&ln, end); // time\n\t\tdwarf_read_uleb128(&ln, end); // size\n\t    }\n\t}\n\tif (filename_size >= 1)\n\t    filename = filename_table[0].name;\n\twhile (ln < end) {\n\t    last_pc = pc;\n\t    i = dwarf_read_1(ln, end);\n\t    if (i >= opcode_base) {\n\t        if (max_ops_per_insn == 1)\n\t\t    pc += ((i - opcode_base) / line_range) * min_insn_length;\n\t\telse {\n\t\t    pc += (opindex + (i - opcode_base) / line_range) /\n\t\t\t  max_ops_per_insn * min_insn_length;\n\t\t    opindex = (opindex + (i - opcode_base) / line_range) %\n\t\t\t       max_ops_per_insn;\n\t\t}\n\t\ti = (int)((i - opcode_base) % line_range) + line_base;\ncheck_pc:\n\t\tif (pc >= wanted_pc && wanted_pc >= last_pc)\n\t\t    goto found;\n\t\tline += i;\n\t    }\n\t    else {\n\t        switch (i) {\n\t        case 0:\n\t\t    len = dwarf_read_uleb128(&ln, end);\n\t\t    cp = ln;\n\t\t    ln += len;\n\t\t    if (len == 0)\n\t\t        goto next_line;\n\t\t    switch (dwarf_read_1(cp, end)) {\n\t\t    case DW_LNE_end_sequence:\n\t\t        break;\n\t\t    case DW_LNE_set_address:\n#if PTR_SIZE == 4\n\t\t        pc = dwarf_read_4(cp, end);\n#else\n\t\t        pc = dwarf_read_8(cp, end);\n#endif\n#if defined TCC_TARGET_MACHO\n\t\t\tpc += rc->prog_base;\n#endif\n\t\t        opindex = 0;\n\t\t        break;\n\t\t    case DW_LNE_define_file: /* deprecated */\n\t\t        if (++filename_size < FILE_TABLE_SIZE) {\n\t\t            filename_table[filename_size - 1].name = (char *)ln - 1;\n\t\t            while (dwarf_read_1(ln, end)) {}\n\t\t            filename_table[filename_size - 1].dir_entry =\n\t\t                dwarf_read_uleb128(&ln, end);\n\t\t        }\n\t\t        else {\n\t\t            while (dwarf_read_1(ln, end)) {}\n\t\t            dwarf_read_uleb128(&ln, end);\n\t\t        }\n\t\t        dwarf_read_uleb128(&ln, end); // time\n\t\t        dwarf_read_uleb128(&ln, end); // size\n\t\t        break;\n\t\t    case DW_LNE_hi_user - 1:\n\t\t        function = (char *)cp;\n\t\t        func_addr = pc;\n\t\t        break;\n\t\t    default:\n\t\t        break;\n\t\t    }\n\t\t    break;\n\t        case DW_LNS_advance_pc:\n\t\t    if (max_ops_per_insn == 1)\n\t\t        pc += dwarf_read_uleb128(&ln, end) * min_insn_length;\n\t\t    else {\n\t\t        unsigned long long off = dwarf_read_uleb128(&ln, end);\n\n\t\t        pc += (opindex + off) / max_ops_per_insn *\n\t\t\t      min_insn_length;\n\t\t        opindex = (opindex + off) % max_ops_per_insn;\n\t\t    }\n\t\t    i = 0;\n\t\t    goto check_pc;\n\t        case DW_LNS_advance_line:\n\t\t    line += dwarf_read_sleb128(&ln, end);\n\t\t    break;\n\t        case DW_LNS_set_file:\n\t\t    i = dwarf_read_uleb128(&ln, end);\n\t\t    i -= i > 0 && version < 5;\n\t\t    if (i < FILE_TABLE_SIZE && i < filename_size)\n\t\t        filename = filename_table[i].name;\n\t\t    break;\n\t        case DW_LNS_const_add_pc:\n\t\t    if (max_ops_per_insn ==  1)\n\t\t        pc += ((255 - opcode_base) / line_range) * min_insn_length;\n\t\t    else {\n\t\t        unsigned int off = (255 - opcode_base) / line_range;\n\n\t\t        pc += ((opindex + off) / max_ops_per_insn) *\n\t\t\t      min_insn_length;\n\t\t        opindex = (opindex + off) % max_ops_per_insn;\n\t\t    }\n\t\t    i = 0;\n\t\t    goto check_pc;\n\t        case DW_LNS_fixed_advance_pc:\n\t\t    i = dwarf_read_2(ln, end);\n\t\t    pc += i;\n\t\t    opindex = 0;\n\t\t    i = 0;\n\t\t    goto check_pc;\n\t        default:\n\t\t    for (j = 0; j < opcode_length[i - 1]; j++)\n                        dwarf_read_uleb128 (&ln, end);\n\t\t    break;\n\t\t}\n\t    }\n\t}\nnext_line:\n\tln = end;\n    }\n    filename = function = NULL, func_addr = 0;\nfound:\n    if (filename)\n        pstrcpy(bi->file, sizeof bi->file, filename), bi->line = line;\n    if (function)\n        pstrcpy(bi->func, sizeof bi->func, function);\n    bi->func_pc = func_addr;\n    return (addr_t)func_addr;\n}\n/* ------------------------------------------------------------- */\n#ifndef CONFIG_TCC_BACKTRACE_ONLY\nstatic\n#endif\nint _tcc_backtrace(rt_frame *f, const char *fmt, va_list ap)\n{\n    rt_context *rc, *rc2;\n    addr_t pc;\n    char skip[40], msg[200];\n    int i, level, ret, n, one;\n    const char *a, *b;\n    bt_info bi;\n    addr_t (*getinfo)(rt_context*, addr_t, bt_info*);\n\n    skip[0] = 0;\n    /* If fmt is like \"^file.c^...\" then skip calls from 'file.c' */\n    if (fmt[0] == '^' && (b = strchr(a = fmt + 1, fmt[0]))) {\n        memcpy(skip, a, b - a), skip[b - a] = 0;\n        fmt = b + 1;\n    }\n    one = 0;\n    /* hack for bcheck.c:dprintf(): one level, no newline */\n    if (fmt[0] == '\\001')\n        ++fmt, one = 1;\n    vsnprintf(msg, sizeof msg, fmt, ap);\n\n    rt_wait_sem();\n    rc = g_rc;\n    getinfo = rt_printline, n = 6;\n    if (rc) {\n        if (rc->dwarf)\n            getinfo = rt_printline_dwarf;\n        if (rc->num_callers)\n            n = rc->num_callers;\n    }\n\n    for (i = level = 0; level < n; i++) {\n        ret = rt_get_caller_pc(&pc, f, i);\n        if (ret == -1)\n            break;\n        memset(&bi, 0, sizeof bi);\n        for (rc2 = rc; rc2; rc2 = rc2->next) {\n            if (getinfo(rc2, pc, &bi))\n                break;\n            /* we try symtab symbols (no line number info) */\n            if (!!(a = rt_elfsym(rc2, pc, &bi.func_pc))) {\n                pstrcpy(bi.func, sizeof bi.func, a);\n                break;\n            }\n        }\n        //fprintf(stderr, \"%d rc %p %p\\n\", i, (void*)pcfunc, (void*)pc);\n        if (skip[0] && strstr(bi.file, skip))\n            continue;\n#ifndef CONFIG_TCC_BACKTRACE_ONLY\n        {\n            TCCState *s = rt_find_state(f);\n            if (s && s->bt_func) {\n                ret = s->bt_func(\n                    s->bt_data,\n                    (void*)pc,\n                    bi.file[0] ? bi.file : NULL,\n                    bi.line,\n                    bi.func[0] ? bi.func : NULL,\n                    level == 0 ? msg : NULL\n                    );\n                if (ret == 0)\n                    break;\n                goto check_break;\n            }\n        }\n#endif\n        if (bi.file[0]) {\n            rt_printf(\"%s:%d\", bi.file, bi.line);\n        } else {\n            rt_printf(\"0x%08llx\", (long long)pc);\n        }\n        rt_printf(\": %s %s\", level ? \"by\" : \"at\", bi.func[0] ? bi.func : \"???\");\n        if (level == 0) {\n            rt_printf(\": %s\", msg);\n            if (one)\n                break;\n        }\n        rt_printf(\"\\n\");\n\n#ifndef CONFIG_TCC_BACKTRACE_ONLY\n    check_break:\n#endif\n        if (rc2\n            && bi.func_pc\n            && bi.func_pc == (addr_t)rc2->top_func)\n            break;\n        ++level;\n    }\n    rt_post_sem();\n    return 0;\n}\n\n/* emit a run time error at position 'pc' */\nstatic int rt_error(rt_frame *f, const char *fmt, ...)\n{\n    va_list ap; char msg[200]; int ret;\n    va_start(ap, fmt);\n    snprintf(msg, sizeof msg, \"RUNTIME ERROR: %s\", fmt);\n    ret = _tcc_backtrace(f, msg, ap);\n    va_end(ap);\n    return ret;\n}\n\n/* ------------------------------------------------------------- */\n\n#ifndef _WIN32\n# include <signal.h>\n# ifndef __OpenBSD__\n#  include <sys/ucontext.h>\n# endif\n#else\n# define ucontext_t CONTEXT\n#endif\n\n/* translate from ucontext_t* to internal rt_context * */\nstatic void rt_getcontext(ucontext_t *uc, rt_frame *rc)\n{\n#if defined _WIN64\n    rc->ip = uc->Rip;\n    rc->fp = uc->Rbp;\n    rc->sp = uc->Rsp;\n#elif defined _WIN32\n    rc->ip = uc->Eip;\n    rc->fp = uc->Ebp;\n    rc->sp = uc->Esp;\n#elif defined __i386__\n# if defined(__APPLE__)\n    rc->ip = uc->uc_mcontext->__ss.__eip;\n    rc->fp = uc->uc_mcontext->__ss.__ebp;\n# elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n    rc->ip = uc->uc_mcontext.mc_eip;\n    rc->fp = uc->uc_mcontext.mc_ebp;\n# elif defined(__dietlibc__)\n    rc->ip = uc->uc_mcontext.eip;\n    rc->fp = uc->uc_mcontext.ebp;\n# elif defined(__NetBSD__)\n    rc->ip = uc->uc_mcontext.__gregs[_REG_EIP];\n    rc->fp = uc->uc_mcontext.__gregs[_REG_EBP];\n# elif defined(__OpenBSD__)\n    rc->ip = uc->sc_eip;\n    rc->fp = uc->sc_ebp;\n# elif !defined REG_EIP && defined EIP /* fix for glibc 2.1 */\n    rc->ip = uc->uc_mcontext.gregs[EIP];\n    rc->fp = uc->uc_mcontext.gregs[EBP];\n# else\n    rc->ip = uc->uc_mcontext.gregs[REG_EIP];\n    rc->fp = uc->uc_mcontext.gregs[REG_EBP];\n# endif\n#elif defined(__x86_64__)\n# if defined(__APPLE__)\n    rc->ip = uc->uc_mcontext->__ss.__rip;\n    rc->fp = uc->uc_mcontext->__ss.__rbp;\n# elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n    rc->ip = uc->uc_mcontext.mc_rip;\n    rc->fp = uc->uc_mcontext.mc_rbp;\n# elif defined(__NetBSD__)\n    rc->ip = uc->uc_mcontext.__gregs[_REG_RIP];\n    rc->fp = uc->uc_mcontext.__gregs[_REG_RBP];\n# elif defined(__OpenBSD__)\n    rc->ip = uc->sc_rip;\n    rc->fp = uc->sc_rbp;\n# else\n    rc->ip = uc->uc_mcontext.gregs[REG_RIP];\n    rc->fp = uc->uc_mcontext.gregs[REG_RBP];\n# endif\n#elif defined(__arm__) && defined(__NetBSD__)\n    rc->ip = uc->uc_mcontext.__gregs[_REG_PC];\n    rc->fp = uc->uc_mcontext.__gregs[_REG_FP];\n#elif defined(__arm__) && defined(__OpenBSD__)\n    rc->ip = uc->sc_pc;\n    rc->fp = uc->sc_r11;\n#elif defined(__arm__) && defined(__FreeBSD__)\n    rc->ip = uc->uc_mcontext.__gregs[_REG_PC];\n    rc->fp = uc->uc_mcontext.__gregs[_REG_FP];\n#elif defined(__arm__)\n    rc->ip = uc->uc_mcontext.arm_pc;\n    rc->fp = uc->uc_mcontext.arm_fp;\n#elif defined(__aarch64__) && defined(__APPLE__)\n    // see:\n    // /Library/Developer/CommandLineTools/SDKs/MacOSX11.1.sdk/usr/include/mach/arm/_structs.h\n    rc->ip = uc->uc_mcontext->__ss.__pc;\n    rc->fp = uc->uc_mcontext->__ss.__fp;\n#elif defined(__aarch64__) && defined(__FreeBSD__)\n    rc->ip = uc->uc_mcontext.mc_gpregs.gp_elr; /* aka REG_PC */\n    rc->fp = uc->uc_mcontext.mc_gpregs.gp_x[29];\n#elif defined(__aarch64__) && defined(__NetBSD__)\n    rc->ip = uc->uc_mcontext.__gregs[_REG_PC];\n    rc->fp = uc->uc_mcontext.__gregs[_REG_FP];\n#elif defined(__aarch64__) && defined(__OpenBSD__)\n    rc->ip = uc->sc_elr;\n    rc->fp = uc->sc_x[29];\n#elif defined(__aarch64__)\n    rc->ip = uc->uc_mcontext.pc;\n    rc->fp = uc->uc_mcontext.regs[29];\n#elif defined(__riscv) && defined(__OpenBSD__)\n    rc->ip = uc->sc_sepc;\n    rc->fp = uc->sc_s[0];\n#elif defined(__riscv)\n    rc->ip = uc->uc_mcontext.__gregs[REG_PC];\n    rc->fp = uc->uc_mcontext.__gregs[REG_S0];\n#endif\n}\n\n/* ------------------------------------------------------------- */\n#ifndef _WIN32\n/* signal handler for fatal errors */\nstatic void sig_error(int signum, siginfo_t *siginf, void *puc)\n{\n    rt_frame f;\n    rt_getcontext(puc, &f);\n\n    switch(signum) {\n    case SIGFPE:\n        switch(siginf->si_code) {\n        case FPE_INTDIV:\n        case FPE_FLTDIV:\n            rt_error(&f, \"division by zero\");\n            break;\n        default:\n            rt_error(&f, \"floating point exception\");\n            break;\n        }\n        break;\n    case SIGBUS:\n    case SIGSEGV:\n        rt_error(&f, \"invalid memory access\");\n        break;\n    case SIGILL:\n        rt_error(&f, \"illegal instruction\");\n        break;\n    case SIGABRT:\n        rt_error(&f, \"abort() called\");\n        break;\n    default:\n        rt_error(&f, \"caught signal %d\", signum);\n        break;\n    }\n    {\n        sigset_t s;\n        sigemptyset(&s);\n        sigaddset(&s, signum);\n        sigprocmask(SIG_UNBLOCK, &s, NULL);\n    }\n    rt_exit(&f, 255);\n}\n\n#ifndef SA_SIGINFO\n# define SA_SIGINFO 0x00000004u\n#endif\n\n/* Generate a stack backtrace when a CPU exception occurs. */\nstatic void set_exception_handler(void)\n{\n    struct sigaction sigact;\n    /* install TCC signal handlers to print debug info on fatal\n       runtime errors */\n    sigemptyset (&sigact.sa_mask);\n    sigact.sa_flags = SA_SIGINFO; //| SA_RESETHAND;\n#if 0//def SIGSTKSZ // this causes signals not to work at all on some (older) linuxes\n    sigact.sa_flags |= SA_ONSTACK;\n#endif\n    sigact.sa_sigaction = sig_error;\n    sigaction(SIGFPE, &sigact, NULL);\n    sigaction(SIGILL, &sigact, NULL);\n    sigaction(SIGSEGV, &sigact, NULL);\n    sigaction(SIGBUS, &sigact, NULL);\n    sigaction(SIGABRT, &sigact, NULL);\n#if 0//def SIGSTKSZ\n    /* This allows stack overflow to be reported instead of a SEGV */\n    {\n        stack_t ss;\n        static unsigned char stack[SIGSTKSZ] __attribute__((aligned(16)));\n\n        ss.ss_sp = stack;\n        ss.ss_size = SIGSTKSZ;\n        ss.ss_flags = 0;\n        sigaltstack(&ss, NULL);\n    }\n#endif\n}\n\n#else /* WIN32 */\n\n/* signal handler for fatal errors */\nstatic long __stdcall cpu_exception_handler(EXCEPTION_POINTERS *ex_info)\n{\n    rt_frame f;\n    unsigned code;\n    rt_getcontext(ex_info->ContextRecord, &f);\n\n    switch (code = ex_info->ExceptionRecord->ExceptionCode) {\n    case EXCEPTION_ACCESS_VIOLATION:\n\trt_error(&f, \"invalid memory access\");\n        break;\n    case EXCEPTION_STACK_OVERFLOW:\n        rt_error(&f, \"stack overflow\");\n        break;\n    case EXCEPTION_INT_DIVIDE_BY_ZERO:\n        rt_error(&f, \"division by zero\");\n        break;\n    case EXCEPTION_BREAKPOINT:\n    case EXCEPTION_SINGLE_STEP:\n        f.ip = *(addr_t*)f.sp;\n        rt_error(&f, \"breakpoint/single-step exception:\");\n        return EXCEPTION_CONTINUE_SEARCH;\n    default:\n        rt_error(&f, \"caught exception %08x\", code);\n        break;\n    }\n    rt_exit(&f, 255);\n    return EXCEPTION_EXECUTE_HANDLER;\n}\n\n/* Generate a stack backtrace when a CPU exception occurs. */\nstatic void set_exception_handler(void)\n{\n    SetUnhandledExceptionFilter(cpu_exception_handler);\n}\n\n#endif\n\n/* ------------------------------------------------------------- */\n/* return the PC at frame level 'level'. Return negative if not found */\n#if defined(__i386__) || defined(__x86_64__)\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *rc, int level)\n{\n    if (level == 0) {\n        *paddr = rc->ip;\n    } else {\n        addr_t fp = rc->fp;\n        while (1) {\n            if (fp < 0x1000)\n                return -1;\n            if (0 == --level)\n                break;\n            /* XXX: check address validity with program info */\n            fp = ((addr_t *)fp)[0];\n        }\n        *paddr = ((addr_t *)fp)[1];\n    }\n    return 0;\n}\n\n/* XXX: only supports linux/bsd */\n#elif defined(__arm__) && !defined(_WIN32)\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *rc, int level)\n{\n    if (level == 0) {\n        *paddr = rc->ip;\n    } else {\n        addr_t fp = rc->fp;\n        while (1) {\n            if (fp < 0x1000)\n                return -1;\n            if (0 == --level)\n                break;\n            fp = ((addr_t *)fp)[0];\n        }\n        *paddr = ((addr_t *)fp)[2];\n    }\n    return 0;\n}\n\n#elif defined(__aarch64__)\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *rc, int level)\n{\n    if (level == 0) {\n        *paddr = rc->ip;\n    } else {\n        addr_t fp = rc->fp;\n        while (1) {\n            if (fp < 0x1000)\n                return -1;\n            if (0 == --level)\n                break;\n            fp = ((addr_t *)fp)[0];\n        }\n        *paddr = ((addr_t *)fp)[1];\n    }\n    return 0;\n}\n\n#elif defined(__riscv)\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *rc, int level)\n{\n    if (level == 0) {\n        *paddr = rc->ip;\n    } else {\n        addr_t fp = rc->fp;\n        while (1) {\n            if (fp < 0x1000)\n                return -1;\n            if (0 == --level)\n                break;\n            fp = ((addr_t *)fp)[-2];\n        }\n        *paddr = ((addr_t *)fp)[-1];\n    }\n    return 0;\n}\n\n#else\n#warning add arch specific rt_get_caller_pc()\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *rc, int level)\n{\n    return -1;\n}\n\n#endif\n#else // for runmain.c:exit(); when CONFIG_TCC_BACKTRACE == 0 */\nstatic int rt_get_caller_pc(addr_t *paddr, rt_frame *f, int level)\n{\n    if (level)\n        return -1;\n    *paddr = f->ip;\n    return 0;\n}\n#endif /* CONFIG_TCC_BACKTRACE */\n/* ------------------------------------------------------------- */\n#ifdef CONFIG_TCC_STATIC\n\n/* dummy function for profiling */\nST_FUNC void *dlopen(const char *filename, int flag)\n{\n    return NULL;\n}\n\nST_FUNC void dlclose(void *p)\n{\n}\n\nST_FUNC const char *dlerror(void)\n{\n    return \"error\";\n}\n\ntypedef struct TCCSyms {\n    char *str;\n    void *ptr;\n} TCCSyms;\n\n\n/* add the symbol you want here if no dynamic linking is done */\nstatic TCCSyms tcc_syms[] = {\n#if !defined(CONFIG_TCCBOOT)\n#define TCCSYM(a) { #a, &a, },\n    TCCSYM(printf)\n    TCCSYM(fprintf)\n    TCCSYM(fopen)\n    TCCSYM(fclose)\n#undef TCCSYM\n#endif\n    { NULL, NULL },\n};\n\nST_FUNC void *dlsym(void *handle, const char *symbol)\n{\n    TCCSyms *p;\n    p = tcc_syms;\n    while (p->str != NULL) {\n        if (!strcmp(p->str, symbol))\n            return p->ptr;\n        p++;\n    }\n    return NULL;\n}\n\n#endif /* CONFIG_TCC_STATIC */\n#endif /* TCC_IS_NATIVE */\n/* ------------------------------------------------------------- */\n"
        },
        {
          "name": "tcctok.h",
          "type": "blob",
          "size": 13.6318359375,
          "content": "/*********************************************************************/\n/* keywords */\n     DEF(TOK_IF, \"if\")\n     DEF(TOK_ELSE, \"else\")\n     DEF(TOK_WHILE, \"while\")\n     DEF(TOK_FOR, \"for\")\n     DEF(TOK_DO, \"do\")\n     DEF(TOK_CONTINUE, \"continue\")\n     DEF(TOK_BREAK, \"break\")\n     DEF(TOK_RETURN, \"return\")\n     DEF(TOK_GOTO, \"goto\")\n     DEF(TOK_SWITCH, \"switch\")\n     DEF(TOK_CASE, \"case\")\n     DEF(TOK_DEFAULT, \"default\")\n     DEF(TOK_ASM1, \"asm\")\n     DEF(TOK_ASM2, \"__asm\")\n     DEF(TOK_ASM3, \"__asm__\")\n\n     DEF(TOK_EXTERN, \"extern\")\n     DEF(TOK_STATIC, \"static\")\n     DEF(TOK_UNSIGNED, \"unsigned\")\n     DEF(TOK__Atomic, \"_Atomic\")\n     DEF(TOK_CONST1, \"const\")\n     DEF(TOK_CONST2, \"__const\") /* gcc keyword */\n     DEF(TOK_CONST3, \"__const__\") /* gcc keyword */\n     DEF(TOK_VOLATILE1, \"volatile\")\n     DEF(TOK_VOLATILE2, \"__volatile\") /* gcc keyword */\n     DEF(TOK_VOLATILE3, \"__volatile__\") /* gcc keyword */\n     DEF(TOK_REGISTER, \"register\")\n     DEF(TOK_SIGNED1, \"signed\")\n     DEF(TOK_SIGNED2, \"__signed\") /* gcc keyword */\n     DEF(TOK_SIGNED3, \"__signed__\") /* gcc keyword */\n     DEF(TOK_AUTO, \"auto\")\n     DEF(TOK_INLINE1, \"inline\")\n     DEF(TOK_INLINE2, \"__inline\") /* gcc keyword */\n     DEF(TOK_INLINE3, \"__inline__\") /* gcc keyword */\n     DEF(TOK_RESTRICT1, \"restrict\")\n     DEF(TOK_RESTRICT2, \"__restrict\")\n     DEF(TOK_RESTRICT3, \"__restrict__\")\n     DEF(TOK_EXTENSION, \"__extension__\") /* gcc keyword */\n     DEF(TOK_THREAD_LOCAL, \"_Thread_local\") /* C11 thread-local storage */\n\n     DEF(TOK_GENERIC, \"_Generic\")\n     DEF(TOK_STATIC_ASSERT, \"_Static_assert\")\n\n     DEF(TOK_VOID, \"void\")\n     DEF(TOK_CHAR, \"char\")\n     DEF(TOK_INT, \"int\")\n     DEF(TOK_FLOAT, \"float\")\n     DEF(TOK_DOUBLE, \"double\")\n     DEF(TOK_BOOL, \"_Bool\")\n     DEF(TOK_COMPLEX, \"_Complex\")\n     DEF(TOK_SHORT, \"short\")\n     DEF(TOK_LONG, \"long\")\n     DEF(TOK_STRUCT, \"struct\")\n     DEF(TOK_UNION, \"union\")\n     DEF(TOK_TYPEDEF, \"typedef\")\n     DEF(TOK_ENUM, \"enum\")\n     DEF(TOK_SIZEOF, \"sizeof\")\n     DEF(TOK_ATTRIBUTE1, \"__attribute\")\n     DEF(TOK_ATTRIBUTE2, \"__attribute__\")\n     DEF(TOK_ALIGNOF1, \"__alignof\")\n     DEF(TOK_ALIGNOF2, \"__alignof__\")\n     DEF(TOK_ALIGNOF3, \"_Alignof\")\n     DEF(TOK_ALIGNAS, \"_Alignas\")\n     DEF(TOK_TYPEOF1, \"typeof\")\n     DEF(TOK_TYPEOF2, \"__typeof\")\n     DEF(TOK_TYPEOF3, \"__typeof__\")\n     DEF(TOK_LABEL, \"__label__\")\n\n#ifdef TCC_TARGET_ARM64\n     DEF(TOK_UINT128, \"__uint128_t\")\n#endif\n\n/*********************************************************************/\n/* the following are not keywords. They are included to ease parsing */\n/* preprocessor only */\n     DEF(TOK_DEFINE, \"define\")\n     DEF(TOK_INCLUDE, \"include\")\n     DEF(TOK_INCLUDE_NEXT, \"include_next\")\n     DEF(TOK_IFDEF, \"ifdef\")\n     DEF(TOK_IFNDEF, \"ifndef\")\n     DEF(TOK_ELIF, \"elif\")\n     DEF(TOK_ENDIF, \"endif\")\n     DEF(TOK_DEFINED, \"defined\")\n     DEF(TOK_UNDEF, \"undef\")\n     DEF(TOK_ERROR, \"error\")\n     DEF(TOK_WARNING, \"warning\")\n     DEF(TOK_LINE, \"line\")\n     DEF(TOK_PRAGMA, \"pragma\")\n     DEF(TOK___LINE__, \"__LINE__\")\n     DEF(TOK___FILE__, \"__FILE__\")\n     DEF(TOK___DATE__, \"__DATE__\")\n     DEF(TOK___TIME__, \"__TIME__\")\n     DEF(TOK___FUNCTION__, \"__FUNCTION__\")\n     DEF(TOK___VA_ARGS__, \"__VA_ARGS__\")\n     DEF(TOK___COUNTER__, \"__COUNTER__\")\n     DEF(TOK___HAS_INCLUDE, \"__has_include\")\n     DEF(TOK___HAS_INCLUDE_NEXT, \"__has_include_next\")\n\n/* special identifiers */\n     DEF(TOK___FUNC__, \"__func__\")\n\n/* special floating point values */\n     DEF(TOK___NAN__, \"__nan__\")\n     DEF(TOK___SNAN__, \"__snan__\")\n     DEF(TOK___INF__, \"__inf__\")\n#if defined TCC_TARGET_X86_64\n     DEF(TOK___mzerosf, \"__mzerosf\") /* -0.0 */\n     DEF(TOK___mzerodf, \"__mzerodf\") /* -0.0 */\n#endif\n\n/* attribute identifiers */\n/* XXX: handle all tokens generically since speed is not critical */\n     DEF(TOK_SECTION1, \"section\")\n     DEF(TOK_SECTION2, \"__section__\")\n     DEF(TOK_ALIGNED1, \"aligned\")\n     DEF(TOK_ALIGNED2, \"__aligned__\")\n     DEF(TOK_PACKED1, \"packed\")\n     DEF(TOK_PACKED2, \"__packed__\")\n     DEF(TOK_WEAK1, \"weak\")\n     DEF(TOK_WEAK2, \"__weak__\")\n     DEF(TOK_ALIAS1, \"alias\")\n     DEF(TOK_ALIAS2, \"__alias__\")\n     DEF(TOK_UNUSED1, \"unused\")\n     DEF(TOK_UNUSED2, \"__unused__\")\n     DEF(TOK_NODEBUG1, \"nodebug\")\n     DEF(TOK_NODEBUG2, \"__nodebug__\")\n     DEF(TOK_CDECL1, \"cdecl\")\n     DEF(TOK_CDECL2, \"__cdecl\")\n     DEF(TOK_CDECL3, \"__cdecl__\")\n     DEF(TOK_STDCALL1, \"stdcall\")\n     DEF(TOK_STDCALL2, \"__stdcall\")\n     DEF(TOK_STDCALL3, \"__stdcall__\")\n     DEF(TOK_FASTCALL1, \"fastcall\")\n     DEF(TOK_FASTCALL2, \"__fastcall\")\n     DEF(TOK_FASTCALL3, \"__fastcall__\")\n     DEF(TOK_THISCALL1, \"thiscall\")\n     DEF(TOK_THISCALL2, \"__thiscall\")\n     DEF(TOK_THISCALL3, \"__thiscall__\")\n     DEF(TOK_REGPARM1, \"regparm\")\n     DEF(TOK_REGPARM2, \"__regparm__\")\n     DEF(TOK_CLEANUP1, \"cleanup\")\n     DEF(TOK_CLEANUP2, \"__cleanup__\")\n     DEF(TOK_CONSTRUCTOR1, \"constructor\")\n     DEF(TOK_CONSTRUCTOR2, \"__constructor__\")\n     DEF(TOK_DESTRUCTOR1, \"destructor\")\n     DEF(TOK_DESTRUCTOR2, \"__destructor__\")\n     DEF(TOK_ALWAYS_INLINE1, \"always_inline\")\n     DEF(TOK_ALWAYS_INLINE2, \"__always_inline__\")\n\n     DEF(TOK_MODE, \"__mode__\")\n     DEF(TOK_MODE_QI, \"__QI__\")\n     DEF(TOK_MODE_DI, \"__DI__\")\n     DEF(TOK_MODE_HI, \"__HI__\")\n     DEF(TOK_MODE_SI, \"__SI__\")\n     DEF(TOK_MODE_word, \"__word__\")\n\n     DEF(TOK_DLLEXPORT, \"dllexport\")\n     DEF(TOK_DLLIMPORT, \"dllimport\")\n     DEF(TOK_NODECORATE, \"nodecorate\")\n     DEF(TOK_NORETURN1, \"noreturn\")\n     DEF(TOK_NORETURN2, \"__noreturn__\")\n     DEF(TOK_NORETURN3, \"_Noreturn\")\n     DEF(TOK_VISIBILITY1, \"visibility\")\n     DEF(TOK_VISIBILITY2, \"__visibility__\")\n\n     DEF(TOK_builtin_types_compatible_p, \"__builtin_types_compatible_p\")\n     DEF(TOK_builtin_choose_expr, \"__builtin_choose_expr\")\n     DEF(TOK_builtin_constant_p, \"__builtin_constant_p\")\n     DEF(TOK_builtin_frame_address, \"__builtin_frame_address\")\n     DEF(TOK_builtin_return_address, \"__builtin_return_address\")\n     DEF(TOK_builtin_expect, \"__builtin_expect\")\n     DEF(TOK_builtin_unreachable, \"__builtin_unreachable\")\n     /*DEF(TOK_builtin_va_list, \"__builtin_va_list\")*/\n#if defined TCC_TARGET_PE && defined TCC_TARGET_X86_64\n     DEF(TOK_builtin_va_start, \"__builtin_va_start\")\n#elif defined TCC_TARGET_X86_64\n     DEF(TOK_builtin_va_arg_types, \"__builtin_va_arg_types\")\n#elif defined TCC_TARGET_ARM64\n     DEF(TOK_builtin_va_start, \"__builtin_va_start\")\n     DEF(TOK_builtin_va_arg, \"__builtin_va_arg\")\n#elif defined TCC_TARGET_RISCV64\n     DEF(TOK_builtin_va_start, \"__builtin_va_start\")\n#endif\n\n/* atomic operations */\n#define DEF_ATOMIC(ID) DEF(TOK_##__##ID, \"__\"#ID)\n     DEF_ATOMIC(atomic_store)\n     DEF_ATOMIC(atomic_load)\n     DEF_ATOMIC(atomic_exchange)\n     DEF_ATOMIC(atomic_compare_exchange)\n     DEF_ATOMIC(atomic_fetch_add)\n     DEF_ATOMIC(atomic_fetch_sub)\n     DEF_ATOMIC(atomic_fetch_or)\n     DEF_ATOMIC(atomic_fetch_xor)\n     DEF_ATOMIC(atomic_fetch_and)\n     DEF_ATOMIC(atomic_fetch_nand)\n     DEF_ATOMIC(atomic_add_fetch)\n     DEF_ATOMIC(atomic_sub_fetch)\n     DEF_ATOMIC(atomic_or_fetch)\n     DEF_ATOMIC(atomic_xor_fetch)\n     DEF_ATOMIC(atomic_and_fetch)\n     DEF_ATOMIC(atomic_nand_fetch)\n\n/* pragma */\n     DEF(TOK_pack, \"pack\")\n#if !defined(TCC_TARGET_I386) && !defined(TCC_TARGET_X86_64) && \\\n    !defined(TCC_TARGET_ARM) && !defined(TCC_TARGET_ARM64) && \\\n    !defined(TCC_TARGET_RISCV64)\n     /* already defined for assembler */\n     DEF(TOK_ASM_push, \"push\")\n     DEF(TOK_ASM_pop, \"pop\")\n#endif\n     DEF(TOK_comment, \"comment\")\n     DEF(TOK_lib, \"lib\")\n     DEF(TOK_push_macro, \"push_macro\")\n     DEF(TOK_pop_macro, \"pop_macro\")\n     DEF(TOK_once, \"once\")\n     DEF(TOK_option, \"option\")\n\n/* builtin functions or variables */\n#ifndef TCC_ARM_EABI\n     DEF(TOK_memcpy, \"memcpy\")\n     DEF(TOK_memmove, \"memmove\")\n     DEF(TOK_memset, \"memset\")\n     DEF(TOK___divdi3, \"__divdi3\")\n     DEF(TOK___moddi3, \"__moddi3\")\n     DEF(TOK___udivdi3, \"__udivdi3\")\n     DEF(TOK___umoddi3, \"__umoddi3\")\n     DEF(TOK___ashrdi3, \"__ashrdi3\")\n     DEF(TOK___lshrdi3, \"__lshrdi3\")\n     DEF(TOK___ashldi3, \"__ashldi3\")\n     DEF(TOK___floatundisf, \"__floatundisf\")\n     DEF(TOK___floatundidf, \"__floatundidf\")\n# ifndef TCC_ARM_VFP\n     DEF(TOK___floatundixf, \"__floatundixf\")\n     DEF(TOK___fixunsxfdi, \"__fixunsxfdi\")\n# endif\n     DEF(TOK___fixunssfdi, \"__fixunssfdi\")\n     DEF(TOK___fixunsdfdi, \"__fixunsdfdi\")\n#endif\n\n#if defined TCC_TARGET_ARM\n# ifdef TCC_ARM_EABI\n     DEF(TOK_memcpy, \"__aeabi_memcpy\")\n     DEF(TOK_memmove, \"__aeabi_memmove\")\n     DEF(TOK_memmove4, \"__aeabi_memmove4\")\n     DEF(TOK_memmove8, \"__aeabi_memmove8\")\n     DEF(TOK_memset, \"__aeabi_memset\")\n     DEF(TOK___aeabi_ldivmod, \"__aeabi_ldivmod\")\n     DEF(TOK___aeabi_uldivmod, \"__aeabi_uldivmod\")\n     DEF(TOK___aeabi_idivmod, \"__aeabi_idivmod\")\n     DEF(TOK___aeabi_uidivmod, \"__aeabi_uidivmod\")\n     DEF(TOK___divsi3, \"__aeabi_idiv\")\n     DEF(TOK___udivsi3, \"__aeabi_uidiv\")\n     DEF(TOK___floatdisf, \"__aeabi_l2f\")\n     DEF(TOK___floatdidf, \"__aeabi_l2d\")\n     DEF(TOK___fixsfdi, \"__aeabi_f2lz\")\n     DEF(TOK___fixdfdi, \"__aeabi_d2lz\")\n     DEF(TOK___ashrdi3, \"__aeabi_lasr\")\n     DEF(TOK___lshrdi3, \"__aeabi_llsr\")\n     DEF(TOK___ashldi3, \"__aeabi_llsl\")\n     DEF(TOK___floatundisf, \"__aeabi_ul2f\")\n     DEF(TOK___floatundidf, \"__aeabi_ul2d\")\n     DEF(TOK___fixunssfdi, \"__aeabi_f2ulz\")\n     DEF(TOK___fixunsdfdi, \"__aeabi_d2ulz\")\n# else\n     DEF(TOK___modsi3, \"__modsi3\")\n     DEF(TOK___umodsi3, \"__umodsi3\")\n     DEF(TOK___divsi3, \"__divsi3\")\n     DEF(TOK___udivsi3, \"__udivsi3\")\n     DEF(TOK___floatdisf, \"__floatdisf\")\n     DEF(TOK___floatdidf, \"__floatdidf\")\n#  ifndef TCC_ARM_VFP\n     DEF(TOK___floatdixf, \"__floatdixf\")\n     DEF(TOK___fixunssfsi, \"__fixunssfsi\")\n     DEF(TOK___fixunsdfsi, \"__fixunsdfsi\")\n     DEF(TOK___fixunsxfsi, \"__fixunsxfsi\")\n     DEF(TOK___fixxfdi, \"__fixxfdi\")\n#  endif\n     DEF(TOK___fixsfdi, \"__fixsfdi\")\n     DEF(TOK___fixdfdi, \"__fixdfdi\")\n# endif\n#endif\n\n#if defined TCC_TARGET_C67\n     DEF(TOK__divi, \"_divi\")\n     DEF(TOK__divu, \"_divu\")\n     DEF(TOK__divf, \"_divf\")\n     DEF(TOK__divd, \"_divd\")\n     DEF(TOK__remi, \"_remi\")\n     DEF(TOK__remu, \"_remu\")\n#endif\n\n#if defined TCC_TARGET_I386\n     DEF(TOK___fixsfdi, \"__fixsfdi\")\n     DEF(TOK___fixdfdi, \"__fixdfdi\")\n     DEF(TOK___fixxfdi, \"__fixxfdi\")\n#endif\n\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64\n     DEF(TOK_alloca, \"alloca\")\n#endif\n\n#if defined TCC_TARGET_PE\n     DEF(TOK___chkstk, \"__chkstk\")\n#endif\n#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64\n     DEF(TOK___arm64_clear_cache, \"__arm64_clear_cache\")\n     DEF(TOK___addtf3, \"__addtf3\")\n     DEF(TOK___subtf3, \"__subtf3\")\n     DEF(TOK___multf3, \"__multf3\")\n     DEF(TOK___divtf3, \"__divtf3\")\n     DEF(TOK___extendsftf2, \"__extendsftf2\")\n     DEF(TOK___extenddftf2, \"__extenddftf2\")\n     DEF(TOK___trunctfsf2, \"__trunctfsf2\")\n     DEF(TOK___trunctfdf2, \"__trunctfdf2\")\n     DEF(TOK___fixtfsi, \"__fixtfsi\")\n     DEF(TOK___fixtfdi, \"__fixtfdi\")\n     DEF(TOK___fixunstfsi, \"__fixunstfsi\")\n     DEF(TOK___fixunstfdi, \"__fixunstfdi\")\n     DEF(TOK___floatsitf, \"__floatsitf\")\n     DEF(TOK___floatditf, \"__floatditf\")\n     DEF(TOK___floatunsitf, \"__floatunsitf\")\n     DEF(TOK___floatunditf, \"__floatunditf\")\n     DEF(TOK___eqtf2, \"__eqtf2\")\n     DEF(TOK___netf2, \"__netf2\")\n     DEF(TOK___lttf2, \"__lttf2\")\n     DEF(TOK___letf2, \"__letf2\")\n     DEF(TOK___gttf2, \"__gttf2\")\n     DEF(TOK___getf2, \"__getf2\")\n#endif\n\n/* bound checking symbols */\n#ifdef CONFIG_TCC_BCHECK\n     DEF(TOK___bound_ptr_add, \"__bound_ptr_add\")\n     DEF(TOK___bound_ptr_indir1, \"__bound_ptr_indir1\")\n     DEF(TOK___bound_ptr_indir2, \"__bound_ptr_indir2\")\n     DEF(TOK___bound_ptr_indir4, \"__bound_ptr_indir4\")\n     DEF(TOK___bound_ptr_indir8, \"__bound_ptr_indir8\")\n     DEF(TOK___bound_ptr_indir12, \"__bound_ptr_indir12\")\n     DEF(TOK___bound_ptr_indir16, \"__bound_ptr_indir16\")\n     DEF(TOK___bound_main_arg, \"__bound_main_arg\")\n     DEF(TOK___bound_local_new, \"__bound_local_new\")\n     DEF(TOK___bound_local_delete, \"__bound_local_delete\")\n     DEF(TOK___bound_setjmp, \"__bound_setjmp\")\n     DEF(TOK___bound_longjmp, \"__bound_longjmp\")\n     DEF(TOK___bound_new_region, \"__bound_new_region\")\n# ifdef TCC_TARGET_PE\n#  ifdef TCC_TARGET_X86_64\n     DEF(TOK___bound_alloca_nr, \"__bound_alloca_nr\")\n#  endif\n# else\n     DEF(TOK_sigsetjmp, \"sigsetjmp\")\n     DEF(TOK___sigsetjmp, \"__sigsetjmp\")\n     DEF(TOK_siglongjmp, \"siglongjmp\")\n# endif\n     DEF(TOK_setjmp, \"setjmp\")\n     DEF(TOK__setjmp, \"_setjmp\")\n     DEF(TOK_longjmp, \"longjmp\")\n#endif\n\n\n/*********************************************************************/\n/* Tiny Assembler */\n#define DEF_ASM(x) DEF(TOK_ASM_ ## x, #x)\n#define DEF_ASMDIR(x) DEF(TOK_ASMDIR_ ## x, \".\" #x)\n#define TOK_ASM_int TOK_INT\n\n#define TOK_ASMDIR_FIRST TOK_ASMDIR_byte\n#define TOK_ASMDIR_LAST TOK_ASMDIR_section\n\n DEF_ASMDIR(byte)       /* must be first directive */\n DEF_ASMDIR(word)\n DEF_ASMDIR(align)\n DEF_ASMDIR(balign)\n DEF_ASMDIR(p2align)\n DEF_ASMDIR(set)\n DEF_ASMDIR(skip)\n DEF_ASMDIR(space)\n DEF_ASMDIR(string)\n DEF_ASMDIR(asciz)\n DEF_ASMDIR(ascii)\n DEF_ASMDIR(file)\n DEF_ASMDIR(globl)\n DEF_ASMDIR(global)\n DEF_ASMDIR(weak)\n DEF_ASMDIR(hidden)\n DEF_ASMDIR(ident)\n DEF_ASMDIR(size)\n DEF_ASMDIR(type)\n DEF_ASMDIR(text)\n DEF_ASMDIR(data)\n DEF_ASMDIR(bss)\n DEF_ASMDIR(previous)\n DEF_ASMDIR(pushsection)\n DEF_ASMDIR(popsection)\n DEF_ASMDIR(fill)\n DEF_ASMDIR(rept)\n DEF_ASMDIR(endr)\n DEF_ASMDIR(org)\n DEF_ASMDIR(quad)\n#if defined(TCC_TARGET_I386)\n DEF_ASMDIR(code16)\n DEF_ASMDIR(code32)\n#elif defined(TCC_TARGET_X86_64)\n DEF_ASMDIR(code64)\n#elif defined(TCC_TARGET_RISCV64)\n DEF_ASMDIR(option)\n#endif\n DEF_ASMDIR(short)\n DEF_ASMDIR(long)\n DEF_ASMDIR(int)\n DEF_ASMDIR(symver)\n DEF_ASMDIR(section)    /* must be last directive */\n\n#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64\n#include \"i386-tok.h\"\n#endif\n\n#if defined TCC_TARGET_ARM || defined TCC_TARGET_ARM64\n#include \"arm-tok.h\"\n#endif\n\n#if defined TCC_TARGET_RISCV64\n#include \"riscv64-tok.h\"\n#endif\n"
        },
        {
          "name": "tcctools.c",
          "type": "blob",
          "size": 19.1005859375,
          "content": "/* -------------------------------------------------------------- */\n/*\n *  TCC - Tiny C Compiler\n *\n *  tcctools.c - extra tools and and -m32/64 support\n *\n */\n\n/* -------------------------------------------------------------- */\n/*\n * This program is for making libtcc1.a without ar\n * tiny_libmaker - tiny elf lib maker\n * usage: tiny_libmaker [lib] files...\n * Copyright (c) 2007 Timppa\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#include \"tcc.h\"\n\n//#define ARMAG  \"!<arch>\\n\"\n#define ARFMAG \"`\\n\"\n\ntypedef struct {\n    char ar_name[16];\n    char ar_date[12];\n    char ar_uid[6];\n    char ar_gid[6];\n    char ar_mode[8];\n    char ar_size[10];\n    char ar_fmag[2];\n} ArHdr;\n\nstatic unsigned long le2belong(unsigned long ul) {\n    return ((ul & 0xFF0000)>>8)+((ul & 0xFF000000)>>24) +\n        ((ul & 0xFF)<<24)+((ul & 0xFF00)<<8);\n}\n\nstatic int ar_usage(int ret) {\n    fprintf(stderr, \"usage: tcc -ar [crstvx] lib [files]\\n\");\n    fprintf(stderr, \"create library ([abdiopN] not supported).\\n\");\n    return ret;\n}\n\nST_FUNC int tcc_tool_ar(TCCState *s1, int argc, char **argv)\n{\n    static const ArHdr arhdr_init = {\n        \"/               \",\n        \"0           \",\n        \"0     \",\n        \"0     \",\n        \"0       \",\n        \"0         \",\n        ARFMAG\n        };\n\n    ArHdr arhdr = arhdr_init;\n    ArHdr arhdro = arhdr_init;\n\n    FILE *fi, *fh = NULL, *fo = NULL;\n    const char *created_file = NULL; // must delete on error\n    ElfW(Ehdr) *ehdr;\n    ElfW(Shdr) *shdr;\n    ElfW(Sym) *sym;\n    int i, fsize, i_lib, i_obj;\n    char *buf, *shstr, *symtab, *strtab;\n    int symtabsize = 0;//, strtabsize = 0;\n    char *anames = NULL;\n    int *afpos = NULL;\n    int istrlen, strpos = 0, fpos = 0, funccnt = 0, funcmax, hofs;\n    char tfile[260], stmp[20];\n    char *file, *name;\n    int ret = 2;\n    const char *ops_conflict = \"habdiopN\";  // unsupported but destructive if ignored.\n    int extract = 0;\n    int table = 0;\n    int verbose = 0;\n\n    i_lib = 0; i_obj = 0;  // will hold the index of the lib and first obj\n    for (i = 1; i < argc; i++) {\n        const char *a = argv[i];\n        if (*a == '-' && strchr(a, '.'))\n            ret = 1; // -x.y is always invalid (same as gnu ar)\n        if ((*a == '-') || (i == 1 && !strchr(a, '.'))) {  // options argument\n            if (strpbrk(a, ops_conflict))\n                ret = 1;\n            if (strchr(a, 'x'))\n                extract = 1;\n            if (strchr(a, 't'))\n                table = 1;\n            if (strchr(a, 'v'))\n                verbose = 1;\n        } else {  // lib or obj files: don't abort - keep validating all args.\n            if (!i_lib)  // first file is the lib\n                i_lib = i;\n            else if (!i_obj)  // second file is the first obj\n                i_obj = i;\n        }\n    }\n\n    if (!i_lib)  // i_obj implies also i_lib.\n        ret = 1;\n    i_obj = i_obj ? i_obj : argc;  // An empty archive will be generated if no input file is given\n\n    if (ret == 1)\n        return ar_usage(ret);\n\n    if (extract || table) {\n        if ((fh = fopen(argv[i_lib], \"rb\")) == NULL)\n        {\n            fprintf(stderr, \"tcc: ar: can't open file %s\\n\", argv[i_lib]);\n            goto finish;\n        }\n        fread(stmp, 1, 8, fh);\n\tif (memcmp(stmp,ARMAG,8))\n\t{\nno_ar:\n            fprintf(stderr, \"tcc: ar: not an ar archive %s\\n\", argv[i_lib]);\n            goto finish;\n\t}\n\twhile (fread(&arhdr, 1, sizeof(arhdr), fh) == sizeof(arhdr)) {\n\t    char *p, *e;\n\n\t    if (memcmp(arhdr.ar_fmag, ARFMAG, 2))\n\t\tgoto no_ar;\n\t    p = arhdr.ar_name;\n\t    for (e = p + sizeof arhdr.ar_name; e > p && e[-1] == ' ';)\n\t\te--;\n\t    *e = '\\0';\n\t    arhdr.ar_size[sizeof arhdr.ar_size-1] = 0;\n\t    fsize = atoi(arhdr.ar_size);\n\t    buf = tcc_malloc(fsize + 1);\n\t    fread(buf, fsize, 1, fh);\n\t    if (strcmp(arhdr.ar_name,\"/\") && strcmp(arhdr.ar_name,\"/SYM64/\")) {\n\t\tif (e > p && e[-1] == '/')\n\t\t    e[-1] = '\\0';\n\t\t/* tv not implemented */\n\t        if (table || verbose)\n\t\t    printf(\"%s%s\\n\", extract ? \"x - \" : \"\", arhdr.ar_name);\n\t\tif (extract) {\n\t\t    if ((fo = fopen(arhdr.ar_name, \"wb\")) == NULL)\n\t\t    {\n\t\t\tfprintf(stderr, \"tcc: ar: can't create file %s\\n\",\n\t\t\t\tarhdr.ar_name);\n\t\t        tcc_free(buf);\n\t\t\tgoto finish;\n\t\t    }\n\t\t    fwrite(buf, fsize, 1, fo);\n\t\t    fclose(fo);\n\t\t    /* ignore date/uid/gid/mode */\n\t\t}\n\t    }\n            if (fsize & 1)\n                fgetc(fh);\n            tcc_free(buf);\n\t}\n\tret = 0;\nfinish:\n\tif (fh)\n\t\tfclose(fh);\n\treturn ret;\n    }\n\n    if ((fh = fopen(argv[i_lib], \"wb\")) == NULL)\n    {\n        fprintf(stderr, \"tcc: ar: can't create file %s\\n\", argv[i_lib]);\n        goto the_end;\n    }\n    created_file = argv[i_lib];\n\n    sprintf(tfile, \"%s.tmp\", argv[i_lib]);\n    if ((fo = fopen(tfile, \"wb+\")) == NULL)\n    {\n        fprintf(stderr, \"tcc: ar: can't create temporary file %s\\n\", tfile);\n        goto the_end;\n    }\n\n    funcmax = 250;\n    afpos = tcc_realloc(NULL, funcmax * sizeof *afpos); // 250 func\n    memcpy(&arhdro.ar_mode, \"100644\", 6);\n\n    // i_obj = first input object file\n    while (i_obj < argc)\n    {\n        if (*argv[i_obj] == '-') {  // by now, all options start with '-'\n            i_obj++;\n            continue;\n        }\n        if ((fi = fopen(argv[i_obj], \"rb\")) == NULL) {\n            fprintf(stderr, \"tcc: ar: can't open file %s \\n\", argv[i_obj]);\n            goto the_end;\n        }\n        if (verbose)\n            printf(\"a - %s\\n\", argv[i_obj]);\n\n        fseek(fi, 0, SEEK_END);\n        fsize = ftell(fi);\n        fseek(fi, 0, SEEK_SET);\n        buf = tcc_malloc(fsize + 1);\n        fread(buf, fsize, 1, fi);\n        fclose(fi);\n\n        // elf header\n        ehdr = (ElfW(Ehdr) *)buf;\n        if (ehdr->e_ident[4] != ELFCLASSW)\n        {\n            fprintf(stderr, \"tcc: ar: Unsupported Elf Class: %s\\n\", argv[i_obj]);\n            goto the_end;\n        }\n\n        shdr = (ElfW(Shdr) *) (buf + ehdr->e_shoff + ehdr->e_shstrndx * ehdr->e_shentsize);\n        shstr = (char *)(buf + shdr->sh_offset);\n        symtab = strtab = NULL;\n        for (i = 0; i < ehdr->e_shnum; i++)\n        {\n            shdr = (ElfW(Shdr) *) (buf + ehdr->e_shoff + i * ehdr->e_shentsize);\n            if (!shdr->sh_offset)\n                continue;\n            if (shdr->sh_type == SHT_SYMTAB)\n            {\n                symtab = (char *)(buf + shdr->sh_offset);\n                symtabsize = shdr->sh_size;\n            }\n            if (shdr->sh_type == SHT_STRTAB)\n            {\n                if (!strcmp(shstr + shdr->sh_name, \".strtab\"))\n                {\n                    strtab = (char *)(buf + shdr->sh_offset);\n                    //strtabsize = shdr->sh_size;\n                }\n            }\n        }\n\n        if (symtab && strtab)\n        {\n            int nsym = symtabsize / sizeof(ElfW(Sym));\n            //printf(\"symtab: info size shndx name\\n\");\n            for (i = 1; i < nsym; i++)\n            {\n                sym = (ElfW(Sym) *) (symtab + i * sizeof(ElfW(Sym)));\n                if (sym->st_shndx &&\n                    (sym->st_info == 0x10\n                    || sym->st_info == 0x11\n                    || sym->st_info == 0x12\n                    || sym->st_info == 0x20\n                    || sym->st_info == 0x21\n                    || sym->st_info == 0x22\n                    )) {\n                    //printf(\"symtab: %2Xh %4Xh %2Xh %s\\n\", sym->st_info, sym->st_size, sym->st_shndx, strtab + sym->st_name);\n                    istrlen = strlen(strtab + sym->st_name)+1;\n                    anames = tcc_realloc(anames, strpos+istrlen);\n                    strcpy(anames + strpos, strtab + sym->st_name);\n                    strpos += istrlen;\n                    if (++funccnt >= funcmax) {\n                        funcmax += 250;\n                        afpos = tcc_realloc(afpos, funcmax * sizeof *afpos); // 250 func more\n                    }\n                    afpos[funccnt] = fpos;\n                }\n            }\n        }\n\n        file = argv[i_obj];\n        for (name = strchr(file, 0);\n             name > file && name[-1] != '/' && name[-1] != '\\\\';\n             --name);\n        istrlen = strlen(name);\n        if (istrlen >= sizeof(arhdro.ar_name))\n            istrlen = sizeof(arhdro.ar_name) - 1;\n        memset(arhdro.ar_name, ' ', sizeof(arhdro.ar_name));\n        memcpy(arhdro.ar_name, name, istrlen);\n        arhdro.ar_name[istrlen] = '/';\n        sprintf(stmp, \"%-10d\", fsize);\n        memcpy(&arhdro.ar_size, stmp, 10);\n        fwrite(&arhdro, sizeof(arhdro), 1, fo);\n        fwrite(buf, fsize, 1, fo);\n        tcc_free(buf);\n        i_obj++;\n        fpos += (fsize + sizeof(arhdro));\n        if (fpos & 1)\n            fputc(0, fo), ++fpos;\n    }\n    hofs = 8 + sizeof(arhdr) + strpos + (funccnt+1) * sizeof(int);\n    fpos = 0;\n    if ((hofs & 1)) // align\n        hofs++, fpos = 1;\n    // write header\n    fwrite(ARMAG, 8, 1, fh);\n    // create an empty archive\n    if (!funccnt) {\n        ret = 0;\n        goto the_end;\n    }\n    sprintf(stmp, \"%-10d\", (int)(strpos + (funccnt+1) * sizeof(int)) + fpos);\n    memcpy(&arhdr.ar_size, stmp, 10);\n    fwrite(&arhdr, sizeof(arhdr), 1, fh);\n    afpos[0] = le2belong(funccnt);\n    for (i=1; i<=funccnt; i++)\n        afpos[i] = le2belong(afpos[i] + hofs);\n    fwrite(afpos, (funccnt+1) * sizeof(int), 1, fh);\n    fwrite(anames, strpos, 1, fh);\n    if (fpos)\n        fwrite(\"\", 1, 1, fh);\n    // write objects\n    fseek(fo, 0, SEEK_END);\n    fsize = ftell(fo);\n    fseek(fo, 0, SEEK_SET);\n    buf = tcc_malloc(fsize + 1);\n    fread(buf, fsize, 1, fo);\n    fwrite(buf, fsize, 1, fh);\n    tcc_free(buf);\n    ret = 0;\nthe_end:\n    if (anames)\n        tcc_free(anames);\n    if (afpos)\n        tcc_free(afpos);\n    if (fh)\n        fclose(fh);\n    if (created_file && ret != 0)\n        remove(created_file);\n    if (fo)\n        fclose(fo), remove(tfile);\n    return ret;\n}\n\n/* -------------------------------------------------------------- */\n/*\n * tiny_impdef creates an export definition file (.def) from a dll\n * on MS-Windows. Usage: tiny_impdef library.dll [-o outputfile]\"\n *\n *  Copyright (c) 2005,2007 grischka\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#ifdef TCC_TARGET_PE\n\nST_FUNC int tcc_tool_impdef(TCCState *s1, int argc, char **argv)\n{\n    int ret, v, i;\n    char infile[260];\n    char outfile[260];\n\n    const char *file;\n    char *p, *q;\n    FILE *fp, *op;\n\n#ifdef _WIN32\n    char path[260];\n#endif\n\n    infile[0] = outfile[0] = 0;\n    fp = op = NULL;\n    ret = 1;\n    p = NULL;\n    v = 0;\n\n    for (i = 1; i < argc; ++i) {\n        const char *a = argv[i];\n        if ('-' == a[0]) {\n            if (0 == strcmp(a, \"-v\")) {\n                v = 1;\n            } else if (0 == strcmp(a, \"-o\")) {\n                if (++i == argc)\n                    goto usage;\n                strcpy(outfile, argv[i]);\n            } else\n                goto usage;\n        } else if (0 == infile[0])\n            strcpy(infile, a);\n        else\n            goto usage;\n    }\n\n    if (0 == infile[0]) {\nusage:\n        fprintf(stderr,\n            \"usage: tcc -impdef library.dll [-v] [-o outputfile]\\n\"\n            \"create export definition file (.def) from dll\\n\"\n            );\n        goto the_end;\n    }\n\n    if (0 == outfile[0]) {\n        strcpy(outfile, tcc_basename(infile));\n        q = strrchr(outfile, '.');\n        if (NULL == q)\n            q = strchr(outfile, 0);\n        strcpy(q, \".def\");\n    }\n\n    file = infile;\n#ifdef _WIN32\n    if (SearchPath(NULL, file, \".dll\", sizeof path, path, NULL))\n        file = path;\n#endif\n    ret = tcc_get_dllexports(file, &p);\n    if (ret || !p) {\n        fprintf(stderr, \"tcc: impdef: %s '%s'\\n\",\n            ret == -1 ? \"can't find file\" :\n            ret ==  1 ? \"can't read symbols\" :\n            ret ==  0 ? \"no symbols found in\" :\n            \"unknown file type\", file);\n        ret = 1;\n        goto the_end;\n    }\n\n    if (v)\n        printf(\"-> %s\\n\", file);\n\n    op = fopen(outfile, \"wb\");\n    if (NULL == op) {\n        fprintf(stderr, \"tcc: impdef: could not create output file: %s\\n\", outfile);\n        goto the_end;\n    }\n\n    fprintf(op, \"LIBRARY %s\\n\\nEXPORTS\\n\", tcc_basename(file));\n    for (q = p, i = 0; *q; ++i) {\n        fprintf(op, \"%s\\n\", q);\n        q += strlen(q) + 1;\n    }\n\n    if (v)\n        printf(\"<- %s (%d symbol%s)\\n\", outfile, i, &\"s\"[i<2]);\n\n    ret = 0;\n\nthe_end:\n    if (p)\n        tcc_free(p);\n    if (fp)\n        fclose(fp);\n    if (op)\n        fclose(op);\n    return ret;\n}\n\n#endif /* TCC_TARGET_PE */\n\n/* -------------------------------------------------------------- */\n/*\n *  TCC - Tiny C Compiler\n *\n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/* re-execute the i386/x86_64 cross-compilers with tcc -m32/-m64: */\n\n#if !defined TCC_TARGET_I386 && !defined TCC_TARGET_X86_64\n\nST_FUNC int tcc_tool_cross(TCCState *s1, char **argv, int option)\n{\n    tcc_error_noabort(\"-m%d not implemented.\", option);\n    return 1;\n}\n\n#else\n#ifdef _WIN32\n#include <process.h>\n\n/* - Empty argument or with space/tab (not newline) requires quoting.\n * - Double-quotes at the value require '\\'-escape, regardless of quoting.\n * - Consecutive (or 1) backslashes at the value all need '\\'-escape only if\n *   followed by [escaped] double quote, else taken literally, e.g. <x\\\\y\\>\n *   remains literal without quoting or esc, but <x\\\\\"y\\> becomes <x\\\\\\\\\\\"y\\>.\n * - This \"before double quote\" rule applies also before delimiting quoting,\n *   e.g. <x\\y \\\"z\\> becomes <\"x\\y \\\\\\\"z\\\\\"> (quoting required because space).\n *\n * https://learn.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments\n */\nstatic char *quote_win32(const char *s)\n{\n    char *o, *r = tcc_malloc(2 * strlen(s) + 3);   /* max-esc, quotes, \\0 */\n    int cbs = 0, quoted = !*s;  /* consecutive backslashes before current */\n\n    for (o = r; *s; *o++ = *s++) {\n        quoted |= *s == ' ' || *s == '\\t';\n        if (*s == '\\\\' || *s == '\"')\n            *o++ = '\\\\';\n        else\n            o -= cbs;  /* undo cbs escapes, if any (not followed by DQ) */\n        cbs = *s == '\\\\' ? cbs + 1 : 0;\n    }\n    if (quoted) {\n        memmove(r + 1, r, o++ - r);\n        *r = *o++ = '\"';\n    } else {\n        o -= cbs;\n    }\n\n    *o = 0;\n    return r; /* don't bother with realloc(r, o-r+1) */\n}\n\nstatic int execvp_win32(const char *prog, char **argv)\n{\n    int ret; char **p;\n    /* replace all \" by \\\" */\n    for (p = argv; *p; ++p)\n        *p = quote_win32(*p);\n    ret = _spawnvp(P_NOWAIT, prog, (const char *const*)argv);\n    if (-1 == ret)\n        return ret;\n    _cwait(&ret, ret, WAIT_CHILD);\n    exit(ret);\n}\n#define execvp execvp_win32\n#endif /* _WIN32 */\n\nST_FUNC int tcc_tool_cross(TCCState *s1, char **argv, int target)\n{\n    char program[4096];\n    char *a0 = argv[0];\n    int prefix = tcc_basename(a0) - a0;\n\n    snprintf(program, sizeof program,\n        \"%.*s%s\"\n#ifdef TCC_TARGET_PE\n        \"-win32\"\n#endif\n        \"-tcc\"\n#ifdef _WIN32\n        \".exe\"\n#endif\n        , prefix, a0, target == 64 ? \"x86_64\" : \"i386\");\n\n    if (strcmp(a0, program))\n        execvp(argv[0] = program, argv);\n    tcc_error_noabort(\"could not run '%s'\", program);\n    return 1;\n}\n\n#endif /* TCC_TARGET_I386 && TCC_TARGET_X86_64 */\n/* -------------------------------------------------------------- */\n/* enable commandline wildcard expansion (tcc -o x.exe *.c) */\n\n#ifdef _WIN32\nconst int _CRT_glob = 1;\n#ifndef _CRT_glob\nconst int _dowildcard = 1;\n#endif\n#endif\n\n/* -------------------------------------------------------------- */\n/* generate xxx.d file */\n\nstatic char *escape_target_dep(const char *s) {\n    char *res = tcc_malloc(strlen(s) * 2 + 1);\n    int j;\n    for (j = 0; *s; s++, j++) {\n        if (is_space(*s)) {\n            res[j++] = '\\\\';\n        }\n        res[j] = *s;\n    }\n    res[j] = '\\0';\n    return res;\n}\n\nST_FUNC int gen_makedeps(TCCState *s1, const char *target, const char *filename)\n{\n    FILE *depout;\n    char buf[1024];\n    char **escaped_targets;\n    int i, k, num_targets;\n\n    if (!filename) {\n        /* compute filename automatically: dir/file.o -> dir/file.d */\n        snprintf(buf, sizeof buf, \"%.*s.d\",\n            (int)(tcc_fileextension(target) - target), target);\n        filename = buf;\n    }\n\n    if(!strcmp(filename, \"-\"))\n        depout = fdopen(1, \"w\");\n    else\n        /* XXX return err codes instead of error() ? */\n        depout = fopen(filename, \"w\");\n    if (!depout)\n        return tcc_error_noabort(\"could not open '%s'\", filename);\n    if (s1->verbose)\n        printf(\"<- %s\\n\", filename);\n\n    escaped_targets = tcc_malloc(s1->nb_target_deps * sizeof(*escaped_targets));\n    num_targets = 0;\n    for (i = 0; i<s1->nb_target_deps; ++i) {\n        for (k = 0; k < i; ++k)\n            if (0 == strcmp(s1->target_deps[i], s1->target_deps[k]))\n                goto next;\n        escaped_targets[num_targets++] = escape_target_dep(s1->target_deps[i]);\n    next:;\n    }\n\n    fprintf(depout, \"%s:\", target);\n    for (i = 0; i < num_targets; ++i)\n        fprintf(depout, \" \\\\\\n  %s\", escaped_targets[i]);\n    fprintf(depout, \"\\n\");\n    if (s1->gen_phony_deps) {\n        /* Skip first file, which is the c file.\n         * Only works for single file give on command-line,\n         * but other compilers have the same limitation */\n        for (i = 1; i < num_targets; ++i)\n            fprintf(depout, \"%s:\\n\", escaped_targets[i]);\n    }\n    for (i = 0; i < num_targets; ++i)\n        tcc_free(escaped_targets[i]);\n    tcc_free(escaped_targets);\n    fclose(depout);\n    return 0;\n}\n\n/* -------------------------------------------------------------- */\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "texi2pod.pl",
          "type": "blob",
          "size": 10.771484375,
          "content": "#! /usr/bin/perl -w\n\n#   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n\n# This file is part of GNU CC.\n\n# GNU CC is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2, or (at your option)\n# any later version.\n\n# GNU CC is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with GNU CC; see the file COPYING.  If not, write to\n# the Free Software Foundation, 59 Temple Place - Suite 330,\n# Boston MA 02111-1307, USA.\n\n# This does trivial (and I mean _trivial_) conversion of Texinfo\n# markup to Perl POD format.  It's intended to be used to extract\n# something suitable for a manpage from a Texinfo document.\n\n$output = 0;\n$skipping = 0;\n%sects = ();\n$section = \"\";\n@icstack = ();\n@endwstack = ();\n@skstack = ();\n@instack = ();\n$shift = \"\";\n%defs = ();\n$fnno = 1;\n$inf = \"\";\n$ibase = \"\";\n\nwhile ($_ = shift) {\n    if (/^-D(.*)$/) {\n\tif ($1 ne \"\") {\n\t    $flag = $1;\n\t} else {\n\t    $flag = shift;\n\t}\n\t$value = \"\";\n\t($flag, $value) = ($flag =~ /^([^=]+)(?:=(.+))?/);\n\tdie \"no flag specified for -D\\n\"\n\t    unless $flag ne \"\";\n\tdie \"flags may only contain letters, digits, hyphens, dashes and underscores\\n\"\n\t    unless $flag =~ /^[a-zA-Z0-9_-]+$/;\n\t$defs{$flag} = $value;\n    } elsif (/^-/) {\n\tusage();\n    } else {\n\t$in = $_, next unless defined $in;\n\t$out = $_, next unless defined $out;\n\tusage();\n    }\n}\n\nif (defined $in) {\n    $inf = gensym();\n    open($inf, \"<$in\") or die \"opening \\\"$in\\\": $!\\n\";\n    $ibase = $1 if $in =~ m|^(.+)/[^/]+$|;\n} else {\n    $inf = \\*STDIN;\n}\n\nif (defined $out) {\n    open(STDOUT, \">$out\") or die \"opening \\\"$out\\\": $!\\n\";\n}\n\nwhile(defined $inf) {\nwhile(<$inf>) {\n    # Certain commands are discarded without further processing.\n    /^\\@(?:\n\t [a-z]+index\t\t# @*index: useful only in complete manual\n\t |need\t\t\t# @need: useful only in printed manual\n\t |(?:end\\s+)?group\t# @group .. @end group: ditto\n\t |page\t\t\t# @page: ditto\n\t |node\t\t\t# @node: useful only in .info file\n\t |(?:end\\s+)?ifnottex   # @ifnottex .. @end ifnottex: use contents\n\t)\\b/x and next;\n\n    chomp;\n\n    # Look for filename and title markers.\n    /^\\@setfilename\\s+([^.]+)/ and $fn = $1, next;\n    /^\\@settitle\\s+([^.]+)/ and $tl = postprocess($1), next;\n\n    # Identify a man title but keep only the one we are interested in.\n    /^\\@c\\s+man\\s+title\\s+([A-Za-z0-9-]+)\\s+(.+)/ and do {\n\tif (exists $defs{$1}) {\n\t    $fn = $1;\n\t    $tl = postprocess($2);\n\t}\n\tnext;\n    };\n\n    # Look for blocks surrounded by @c man begin SECTION ... @c man end.\n    # This really oughta be @ifman ... @end ifman and the like, but such\n    # would require rev'ing all other Texinfo translators.\n    /^\\@c\\s+man\\s+begin\\s+([A-Z]+)\\s+([A-Za-z0-9-]+)/ and do {\n\t$output = 1 if exists $defs{$2};\n        $sect = $1;\n\tnext;\n    };\n    /^\\@c\\s+man\\s+begin\\s+([A-Z]+)/ and $sect = $1, $output = 1, next;\n    /^\\@c\\s+man\\s+end/ and do {\n\t$sects{$sect} = \"\" unless exists $sects{$sect};\n\t$sects{$sect} .= postprocess($section);\n\t$section = \"\";\n\t$output = 0;\n\tnext;\n    };\n\n    # handle variables\n    /^\\@set\\s+([a-zA-Z0-9_-]+)\\s*(.*)$/ and do {\n\t$defs{$1} = $2;\n\tnext;\n    };\n    /^\\@clear\\s+([a-zA-Z0-9_-]+)/ and do {\n\tdelete $defs{$1};\n\tnext;\n    };\n\n    next unless $output;\n\n    # Discard comments.  (Can't do it above, because then we'd never see\n    # @c man lines.)\n    /^\\@c\\b/ and next;\n\n    # End-block handler goes up here because it needs to operate even\n    # if we are skipping.\n    /^\\@end\\s+([a-z]+)/ and do {\n\t# Ignore @end foo, where foo is not an operation which may\n\t# cause us to skip, if we are presently skipping.\n\tmy $ended = $1;\n\tnext if $skipping && $ended !~ /^(?:ifset|ifclear|ignore|menu|iftex)$/;\n\n\tdie \"\\@end $ended without \\@$ended at line $.\\n\" unless defined $endw;\n\tdie \"\\@$endw ended by \\@end $ended at line $.\\n\" unless $ended eq $endw;\n\n\t$endw = pop @endwstack;\n\n\tif ($ended =~ /^(?:ifset|ifclear|ignore|menu|iftex)$/) {\n\t    $skipping = pop @skstack;\n\t    next;\n\t} elsif ($ended =~ /^(?:example|smallexample|display)$/) {\n\t    $shift = \"\";\n\t    $_ = \"\";\t# need a paragraph break\n\t} elsif ($ended =~ /^(?:itemize|enumerate|[fv]?table)$/) {\n\t    $_ = \"\\n=back\\n\";\n\t    $ic = pop @icstack;\n\t} else {\n\t    die \"unknown command \\@end $ended at line $.\\n\";\n\t}\n    };\n\n    # We must handle commands which can cause skipping even while we\n    # are skipping, otherwise we will not process nested conditionals\n    # correctly.\n    /^\\@ifset\\s+([a-zA-Z0-9_-]+)/ and do {\n\tpush @endwstack, $endw;\n\tpush @skstack, $skipping;\n\t$endw = \"ifset\";\n\t$skipping = 1 unless exists $defs{$1};\n\tnext;\n    };\n\n    /^\\@ifclear\\s+([a-zA-Z0-9_-]+)/ and do {\n\tpush @endwstack, $endw;\n\tpush @skstack, $skipping;\n\t$endw = \"ifclear\";\n\t$skipping = 1 if exists $defs{$1};\n\tnext;\n    };\n\n    /^\\@(ignore|menu|iftex)\\b/ and do {\n\tpush @endwstack, $endw;\n\tpush @skstack, $skipping;\n\t$endw = $1;\n\t$skipping = 1;\n\tnext;\n    };\n\n    next if $skipping;\n\n    # Character entities.  First the ones that can be replaced by raw text\n    # or discarded outright:\n    s/\\@copyright\\{\\}/(c)/g;\n    s/\\@dots\\{\\}/.../g;\n    s/\\@enddots\\{\\}/..../g;\n    s/\\@([.!? ])/$1/g;\n    s/\\@[:-]//g;\n    s/\\@bullet(?:\\{\\})?/*/g;\n    s/\\@TeX\\{\\}/TeX/g;\n    s/\\@pounds\\{\\}/\\#/g;\n    s/\\@minus(?:\\{\\})?/-/g;\n    s/\\\\,/,/g;\n\n    # Now the ones that have to be replaced by special escapes\n    # (which will be turned back into text by unmunge())\n    s/&/&amp;/g;\n    s/\\@\\{/&lbrace;/g;\n    s/\\@\\}/&rbrace;/g;\n    s/\\@\\@/&at;/g;\n\n    # Inside a verbatim block, handle @var specially.\n    if ($shift ne \"\") {\n\ts/\\@var\\{([^\\}]*)\\}/<$1>/g;\n    }\n\n    # POD doesn't interpret E<> inside a verbatim block.\n    if ($shift eq \"\") {\n\ts/</&lt;/g;\n\ts/>/&gt;/g;\n    } else {\n\ts/</&LT;/g;\n\ts/>/&GT;/g;\n    }\n\n    # Single line command handlers.\n\n    /^\\@include\\s+(.+)$/ and do {\n\tpush @instack, $inf;\n\t$inf = gensym();\n\n\t# Try cwd and $ibase.\n\topen($inf, \"<\" . $1) \n\t    or open($inf, \"<\" . $ibase . \"/\" . $1)\n\t\tor die \"cannot open $1 or $ibase/$1: $!\\n\";\n\tnext;\n    };\n\n    /^\\@(?:section|unnumbered|unnumberedsec|center)\\s+(.+)$/\n\tand $_ = \"\\n=head2 $1\\n\";\n    /^\\@subsection\\s+(.+)$/\n\tand $_ = \"\\n=head3 $1\\n\";\n\n    # Block command handlers:\n    /^\\@itemize\\s+(\\@[a-z]+|\\*|-)/ and do {\n\tpush @endwstack, $endw;\n\tpush @icstack, $ic;\n\t$ic = $1;\n\t$_ = \"\\n=over 4\\n\";\n\t$endw = \"itemize\";\n    };\n\n    /^\\@enumerate(?:\\s+([a-zA-Z0-9]+))?/ and do {\n\tpush @endwstack, $endw;\n\tpush @icstack, $ic;\n\tif (defined $1) {\n\t    $ic = $1 . \".\";\n\t} else {\n\t    $ic = \"1.\";\n\t}\n\t$_ = \"\\n=over 4\\n\";\n\t$endw = \"enumerate\";\n    };\n\n    /^\\@([fv]?table)\\s+(\\@[a-z]+)/ and do {\n\tpush @endwstack, $endw;\n\tpush @icstack, $ic;\n\t$endw = $1;\n\t$ic = $2;\n\t$ic =~ s/\\@(?:samp|strong|key|gcctabopt|option|env)/B/;\n\t$ic =~ s/\\@(?:code|kbd)/C/;\n\t$ic =~ s/\\@(?:dfn|var|emph|cite|i)/I/;\n\t$ic =~ s/\\@(?:file)/F/;\n\t$_ = \"\\n=over 4\\n\";\n    };\n\n    /^\\@((?:small)?example|display)/ and do {\n\tpush @endwstack, $endw;\n\t$endw = $1;\n\t$shift = \"\\t\";\n\t$_ = \"\";\t# need a paragraph break\n    };\n\n    /^\\@itemx?\\s*(.+)?$/ and do {\n\tif (defined $1) {\n\t    # Entity escapes prevent munging by the <> processing below.\n\t    $_ = \"\\n=item $ic\\&LT;$1\\&GT;\\n\";\n\t} else {\n\t    $_ = \"\\n=item $ic\\n\";\n\t    $ic =~ y/A-Ya-y/B-Zb-z/;\n\t    $ic =~ s/(\\d+)/$1 + 1/eg;\n\t}\n    };\n\n    $section .= $shift.$_.\"\\n\";\n}\n# End of current file.\nclose($inf);\n$inf = pop @instack;\n}\n\ndie \"No filename or title\\n\" unless defined $fn && defined $tl;\n\n$sects{NAME} = \"$fn \\- $tl\\n\";\n$sects{FOOTNOTES} .= \"=back\\n\" if exists $sects{FOOTNOTES};\n\nfor $sect (qw(NAME SYNOPSIS DESCRIPTION OPTIONS ENVIRONMENT FILES\n\t      BUGS NOTES FOOTNOTES SEEALSO AUTHOR COPYRIGHT)) {\n    if(exists $sects{$sect}) {\n\t$head = $sect;\n\t$head =~ s/SEEALSO/SEE ALSO/;\n\tprint \"=head1 $head\\n\\n\";\n\tprint scalar unmunge ($sects{$sect});\n\tprint \"\\n\";\n    }\n}\n\nsub usage\n{\n    die \"usage: $0 [-D toggle...] [infile [outfile]]\\n\";\n}\n\nsub postprocess\n{\n    local $_ = $_[0];\n\n    # @value{foo} is replaced by whatever 'foo' is defined as.\n    while (m/(\\@value\\{([a-zA-Z0-9_-]+)\\})/g) {\n\tif (! exists $defs{$2}) {\n\t    print STDERR \"Option $2 not defined\\n\";\n\t    s/\\Q$1\\E//;\n\t} else {\n\t    $value = $defs{$2};\n\t    s/\\Q$1\\E/$value/;\n\t}\n    }\n\n    # Formatting commands.\n    # Temporary escape for @r.\n    s/\\@r\\{([^\\}]*)\\}/R<$1>/g;\n    s/\\@(?:dfn|var|emph|cite|i)\\{([^\\}]*)\\}/I<$1>/g;\n    s/\\@(?:code|kbd)\\{([^\\}]*)\\}/C<$1>/g;\n    s/\\@(?:gccoptlist|samp|strong|key|option|env|command|b)\\{([^\\}]*)\\}/B<$1>/g;\n    s/\\@sc\\{([^\\}]*)\\}/\\U$1/g;\n    s/\\@file\\{([^\\}]*)\\}/F<$1>/g;\n    s/\\@w\\{([^\\}]*)\\}/S<$1>/g;\n    s/\\@(?:dmn|math)\\{([^\\}]*)\\}/$1/g;\n\n    # Cross references are thrown away, as are @noindent and @refill.\n    # (@noindent is impossible in .pod, and @refill is unnecessary.)\n    # @* is also impossible in .pod; we discard it and any newline that\n    # follows it.  Similarly, our macro @gol must be discarded.\n\n    s/\\(?\\@xref\\{(?:[^\\}]*)\\}(?:[^.<]|(?:<[^<>]*>))*\\.\\)?//g;\n    s/\\s+\\(\\@pxref\\{(?:[^\\}]*)\\}\\)//g;\n    s/;\\s+\\@pxref\\{(?:[^\\}]*)\\}//g;\n    s/\\@noindent\\s*//g;\n    s/\\@refill//g;\n    s/\\@gol//g;\n    s/\\@\\*\\s*\\n?//g;\n\n    # @uref can take one, two, or three arguments, with different\n    # semantics each time.  @url and @email are just like @uref with\n    # one argument, for our purposes.\n    s/\\@(?:uref|url|email)\\{([^\\},]*)\\}/&lt;B<$1>&gt;/g;\n    s/\\@uref\\{([^\\},]*),([^\\},]*)\\}/$2 (C<$1>)/g;\n    s/\\@uref\\{([^\\},]*),([^\\},]*),([^\\},]*)\\}/$3/g;\n\n    # Turn B<blah I<blah> blah> into B<blah> I<blah> B<blah> to\n    # match Texinfo semantics of @emph inside @samp.  Also handle @r\n    # inside bold.\n    s/&LT;/</g;\n    s/&GT;/>/g;\n    1 while s/B<((?:[^<>]|I<[^<>]*>)*)R<([^>]*)>/B<$1>${2}B</g;\n    1 while (s/B<([^<>]*)I<([^>]+)>/B<$1>I<$2>B</g);\n    1 while (s/I<([^<>]*)B<([^>]+)>/I<$1>B<$2>I</g);\n    s/[BI]<>//g;\n    s/([BI])<(\\s+)([^>]+)>/$2$1<$3>/g;\n    s/([BI])<([^>]+?)(\\s+)>/$1<$2>$3/g;\n\n    # Extract footnotes.  This has to be done after all other\n    # processing because otherwise the regexp will choke on formatting\n    # inside @footnote.\n    while (/\\@footnote/g) {\n\ts/\\@footnote\\{([^\\}]+)\\}/[$fnno]/;\n\tadd_footnote($1, $fnno);\n\t$fnno++;\n    }\n\n    return $_;\n}\n\nsub unmunge\n{\n    # Replace escaped symbols with their equivalents.\n    local $_ = $_[0];\n\n    s/&lt;/E<lt>/g;\n    s/&gt;/E<gt>/g;\n    s/&lbrace;/\\{/g;\n    s/&rbrace;/\\}/g;\n    s/&at;/\\@/g;\n    s/&amp;/&/g;\n    return $_;\n}\n\nsub add_footnote\n{\n    unless (exists $sects{FOOTNOTES}) {\n\t$sects{FOOTNOTES} = \"\\n=over 4\\n\\n\";\n    }\n\n    $sects{FOOTNOTES} .= \"=item $fnno.\\n\\n\"; $fnno++;\n    $sects{FOOTNOTES} .= $_[0];\n    $sects{FOOTNOTES} .= \"\\n\\n\";\n}\n\n# stolen from Symbol.pm\n{\n    my $genseq = 0;\n    sub gensym\n    {\n\tmy $name = \"GEN\" . $genseq++;\n\tmy $ref = \\*{$name};\n\tdelete $::{$name};\n\treturn $ref;\n    }\n}\n"
        },
        {
          "name": "win32",
          "type": "tree",
          "content": null
        },
        {
          "name": "x86_64-asm.h",
          "type": "blob",
          "size": 26.9033203125,
          "content": "     DEF_ASM_OP0(clc, 0xf8) /* must be first OP0 */\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfq, 0x9c)\n     DEF_ASM_OP0(popfq, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(cqto, 0x4899)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(iretw, 0x66cf)\n     DEF_ASM_OP0(iretl, 0xcf)\n     DEF_ASM_OP0(iretq, 0x48cf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(pause, 0xf390)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n    DEF_ASM_OP0L(vmcall, 0xc1, 0, OPC_0F01)\n    DEF_ASM_OP0L(vmlaunch, 0xc2, 0, OPC_0F01)\n    DEF_ASM_OP0L(vmresume, 0xc3, 0, OPC_0F01)\n    DEF_ASM_OP0L(vmxoff, 0xc4, 0, OPC_0F01)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWLX))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWLX))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWLX))\n\n     /* bits */\n\nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(popcntw, 0xf30fb8, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(tzcntw, 0xf30fbc, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(lzcntw, 0xf30fbd, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\n     /* prefixes */\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n\n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n\n     DEF_ASM_OP0(syscall, 0x0f05)\n     DEF_ASM_OP0(sysret, 0x0f07)\n     DEF_ASM_OP0L(sysretq, 0x480f07, 0, 0)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\n/* Right now we can't express the fact that 0xa1/0xa3 can't use $eax and a \n   32 bit moffset as operands.\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWLX, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWLX, OPT_EAX, OPT_ADDR)) */\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\n/* The moves are special: the 0xb8 form supports IM64 (the only insn that\n   does) with REG64.  It doesn't support IM32 with REG64, it would use\n   the full movabs form (64bit immediate).  For IM32->REG64 we prefer\n   the 0xc7 opcode.  So disallow all 64bit forms and code the rest by hand. */\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWLX, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(mov,  0xb8, 0, OPC_REG, OPT_IM64, OPT_REG64))\nALT(DEF_ASM_OP2(movq, 0xb8, 0, OPC_REG, OPT_IM64, OPT_REG64))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WLX, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WLX, OPT_CR, OPT_REG64))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WLX, OPT_DB, OPT_REG64))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WLX, OPT_REG64, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WLX, OPT_REG64, OPT_DB))\n\nALT(DEF_ASM_OP2(movsbw, 0x660fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbq, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movswq, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP2(movslq, 0x63, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WLX, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzwq, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP1(pushq, 0x6a, 0, 0, OPT_IM8S))\nALT(DEF_ASM_OP1(push, 0x6a, 0, 0, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x666a, 0, 0, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WLX, OPT_REG64))\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WLX, OPT_REG16))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WLX, OPT_REG64 | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6668, 0, 0, OPT_IM16))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WLX, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WLX, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WLX, OPT_REG64))\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WLX, OPT_REG16))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WLX, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_REGW, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_EAX, OPT_REGW))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WLX, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWLX, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWLX, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, 0, OPT_DISP))\n    DEF_ASM_OP1(callq, 0xff, 2, OPC_MODRM, OPT_INDIR)\nALT(DEF_ASM_OP1(callq, 0xe8, 0, 0, OPT_DISP))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, 0, OPT_DISP8))\n\nALT(DEF_ASM_OP1(lcall, 0xff, 3, OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(ljmpw, 0x66ff, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(ljmpl, 0xff, 5, OPC_MODRM, OPT_EA)\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\nALT(DEF_ASM_OP1(setob, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\n    DEF_ASM_OP0(retq, 0xc3)\nALT(DEF_ASM_OP1(retq, 0xc2, 0, 0, OPT_IM16))\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_TEST, OPT_DISP8))\n    DEF_ASM_OP1(loopne, 0xe0, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loope, 0xe1, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loopz, 0xe1, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(loop, 0xe2, 0, 0, OPT_DISP8)\n    DEF_ASM_OP1(jecxz, 0x67e3, 0, 0, OPT_DISP8)\n\n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(fadd, 0xdcc0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP2(fmul, 0xdcc8, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n\n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n    /* The *q forms of fxrstor/fxsave use a REX prefix.\n       If the operand would use extended registers we would have to modify\n       it instead of generating a second one.  Currently that's no\n       problem with TCC, we don't use extended registers.  */\n    DEF_ASM_OP1(fxsaveq, 0x0fae, 0, OPC_MODRM | OPC_48, OPT_EA )\n    DEF_ASM_OP1(fxrstorq, 0x0fae, 1, OPC_MODRM | OPC_48, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\nALT(DEF_ASM_OP2(larw, 0x0f02, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lgdtq, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidtq, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG16)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sgdtq, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidtq, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG32 | OPT_EA)\nALT(DEF_ASM_OP1(str, 0x660f00, 1, OPC_MODRM, OPT_REG16))\nALT(DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM | OPC_48, OPT_REG64))\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP0L(swapgs, 0x0f01, 7, OPC_MODRM)\n\n    /* 486 */\n    /* bswap can't be applied to 16bit regs */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\n    DEF_ASM_OP1(bswapl, 0x0fc8, 0, OPC_REG, OPT_REG32 )\n    DEF_ASM_OP1(bswapq, 0x0fc8, 0, OPC_REG | OPC_48, OPT_REG64 )\n\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n\n    /* AMD 64 */\n    DEF_ASM_OP1(cmpxchg16b, 0x0fc7, 1, OPC_MODRM | OPC_48, OPT_EA )\n\n    /* pentium pro */\nALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMXSSE )\n    /* movd shouldn't accept REG64, but AMD64 spec uses it for 32 and 64 bit\n       moves, so let's be compatible. */\nALT(DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG64, OPT_MMXSSE ))\nALT(DEF_ASM_OP2(movq, 0x0f6e, 0, OPC_MODRM | OPC_48, OPT_REG64, OPT_MMXSSE ))\nALT(DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX ))\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG32 ))\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG64 ))\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\nALT(DEF_ASM_OP2(movq, 0x660fd6, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_SSE ))\nALT(DEF_ASM_OP2(movq, 0xf30f7e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE ))\nALT(DEF_ASM_OP2(movq, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG64 ))\n\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n\n    /* sse */\n    DEF_ASM_OP1(ldmxcsr, 0x0fae, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(stmxcsr, 0x0fae, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP2(movups, 0x0f10, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )\nALT(DEF_ASM_OP2(movups, 0x0f11, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movaps, 0x0f28, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )\nALT(DEF_ASM_OP2(movaps, 0x0f29, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movhps, 0x0f16, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )\nALT(DEF_ASM_OP2(movhps, 0x0f17, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(addps, 0x0f58, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(cvtpi2ps, 0x0f2a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_SSE )\n    DEF_ASM_OP2(cvtps2pi, 0x0f2d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )\n    DEF_ASM_OP2(cvttps2pi, 0x0f2c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )\n    DEF_ASM_OP2(divps, 0x0f5e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(maxps, 0x0f5f, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(minps, 0x0f5d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(mulps, 0x0f59, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(pavgb, 0x0fe0, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(pavgw, 0x0fe3, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(pmaxsw, 0x0fee, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pmaxub, 0x0fde, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pminsw, 0x0fea, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(pminub, 0x0fda, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )\n    DEF_ASM_OP2(rcpss, 0x0f53, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(rsqrtps, 0x0f52, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(sqrtps, 0x0f51, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n    DEF_ASM_OP2(subps, 0x0f5c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )\n\n    /* movnti should only accept REG32 and REG64, we accept more */\n    DEF_ASM_OP2(movnti, 0x0fc3, 0, OPC_MODRM, OPT_REG, OPT_EA)\n    DEF_ASM_OP2(movntil, 0x0fc3, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(movntiq, 0x0fc3, 0, OPC_MODRM | OPC_48, OPT_REG64, OPT_EA)\n    DEF_ASM_OP1(prefetchnta, 0x0f18, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(prefetcht0, 0x0f18, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(prefetcht1, 0x0f18, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(prefetcht2, 0x0f18, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(prefetchw, 0x0f0d, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP0L(lfence, 0x0fae, 5, OPC_MODRM)\n    DEF_ASM_OP0L(mfence, 0x0fae, 6, OPC_MODRM)\n    DEF_ASM_OP0L(sfence, 0x0fae, 7, OPC_MODRM)\n    DEF_ASM_OP1(clflush, 0x0fae, 7, OPC_MODRM, OPT_EA)\n\n    /* Control-Flow Enforcement */\n    DEF_ASM_OP0L(endbr64, 0xf30f1e, 7, OPC_MODRM)\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n"
        },
        {
          "name": "x86_64-gen.c",
          "type": "blob",
          "size": 64.86328125,
          "content": "/*\n *  x86-64 code generator for TCC\n *\n *  Copyright (c) 2008 Shinichiro Hamaji\n *\n *  Based on i386-gen.c by Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef TARGET_DEFS_ONLY\n\n/* number of available registers */\n#define NB_REGS         25\n#define NB_ASM_REGS     16\n#define CONFIG_TCC_ASM\n\n/* a register can belong to several classes. The classes must be\n   sorted from more general to more precise (see gv2() code which does\n   assumptions on it). */\n#define RC_INT     0x0001 /* generic integer register */\n#define RC_FLOAT   0x0002 /* generic float register */\n#define RC_RAX     0x0004\n#define RC_RDX     0x0008\n#define RC_RCX     0x0010\n#define RC_RSI     0x0020\n#define RC_RDI     0x0040\n#define RC_ST0     0x0080 /* only for long double */\n#define RC_R8      0x0100\n#define RC_R9      0x0200\n#define RC_R10     0x0400\n#define RC_R11     0x0800\n#define RC_XMM0    0x1000\n#define RC_XMM1    0x2000\n#define RC_XMM2    0x4000\n#define RC_XMM3    0x8000\n#define RC_XMM4    0x10000\n#define RC_XMM5    0x20000\n#define RC_XMM6    0x40000\n#define RC_XMM7    0x80000\n#define RC_IRET    RC_RAX /* function return: integer register */\n#define RC_IRE2    RC_RDX /* function return: second integer register */\n#define RC_FRET    RC_XMM0 /* function return: float register */\n#define RC_FRE2    RC_XMM1 /* function return: second float register */\n\n/* pretty names for the registers */\nenum {\n    TREG_RAX = 0,\n    TREG_RCX = 1,\n    TREG_RDX = 2,\n    TREG_RSP = 4,\n    TREG_RSI = 6,\n    TREG_RDI = 7,\n\n    TREG_R8  = 8,\n    TREG_R9  = 9,\n    TREG_R10 = 10,\n    TREG_R11 = 11,\n\n    TREG_XMM0 = 16,\n    TREG_XMM1 = 17,\n    TREG_XMM2 = 18,\n    TREG_XMM3 = 19,\n    TREG_XMM4 = 20,\n    TREG_XMM5 = 21,\n    TREG_XMM6 = 22,\n    TREG_XMM7 = 23,\n\n    TREG_ST0 = 24,\n\n    TREG_MEM = 0x20\n};\n\n#define REX_BASE(reg) (((reg) >> 3) & 1)\n#define REG_VALUE(reg) ((reg) & 7)\n\n/* return registers for function */\n#define REG_IRET TREG_RAX /* single word int return register */\n#define REG_IRE2 TREG_RDX /* second word return register (for long long) */\n#define REG_FRET TREG_XMM0 /* float return register */\n#define REG_FRE2 TREG_XMM1 /* second float return register */\n\n/* defined if function parameters must be evaluated in reverse order */\n#define INVERT_FUNC_PARAMS\n\n/* pointer size, in bytes */\n#define PTR_SIZE 8\n\n/* long double size and alignment, in bytes */\n#define LDOUBLE_SIZE  16\n#define LDOUBLE_ALIGN 16\n/* maximum alignment (for aligned attribute support) */\n#define MAX_ALIGN     16\n\n/* define if return values need to be extended explicitely\n   at caller side (for interfacing with non-TCC compilers) */\n#define PROMOTE_RET\n\n#define TCC_TARGET_NATIVE_STRUCT_COPY\nST_FUNC void gen_struct_copy(int size);\n\n/******************************************************/\n#else /* ! TARGET_DEFS_ONLY */\n/******************************************************/\n#define USING_GLOBALS\n#include \"tcc.h\"\n#include <assert.h>\n\nST_DATA const char * const target_machine_defs =\n    \"__x86_64__\\0\"\n    \"__amd64__\\0\"\n    ;\n\nST_DATA const int reg_classes[NB_REGS] = {\n    /* eax */ RC_INT | RC_RAX,\n    /* ecx */ RC_INT | RC_RCX,\n    /* edx */ RC_INT | RC_RDX,\n    0,\n    0,\n    0,\n    RC_RSI,\n    RC_RDI,\n    RC_R8,\n    RC_R9,\n    RC_R10,\n    RC_R11,\n    0,\n    0,\n    0,\n    0,\n    /* xmm0 */ RC_FLOAT | RC_XMM0,\n    /* xmm1 */ RC_FLOAT | RC_XMM1,\n    /* xmm2 */ RC_FLOAT | RC_XMM2,\n    /* xmm3 */ RC_FLOAT | RC_XMM3,\n    /* xmm4 */ RC_FLOAT | RC_XMM4,\n    /* xmm5 */ RC_FLOAT | RC_XMM5,\n    /* xmm6 an xmm7 are included so gv() can be used on them,\n       but they are not tagged with RC_FLOAT because they are\n       callee saved on Windows */\n    RC_XMM6,\n    RC_XMM7,\n    /* st0 */ RC_ST0\n};\n\nstatic unsigned long func_sub_sp_offset;\nstatic int func_ret_sub;\n\n#if defined(CONFIG_TCC_BCHECK)\nstatic addr_t func_bound_offset;\nstatic unsigned long func_bound_ind;\nST_DATA int func_bound_add_epilog;\n#endif\n\n#ifdef TCC_TARGET_PE\nstatic int func_scratch, func_alloca;\n#endif\n\n/* XXX: make it faster ? */\nST_FUNC void g(int c)\n{\n    int ind1;\n    if (nocode_wanted)\n        return;\n    ind1 = ind + 1;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c;\n    ind = ind1;\n}\n\nST_FUNC void o(unsigned int c)\n{\n    while (c) {\n        g(c);\n        c = c >> 8;\n    }\n}\n\nST_FUNC void gen_le16(int v)\n{\n    g(v);\n    g(v >> 8);\n}\n\nST_FUNC void gen_le32(int c)\n{\n    g(c);\n    g(c >> 8);\n    g(c >> 16);\n    g(c >> 24);\n}\n\nST_FUNC void gen_le64(int64_t c)\n{\n    g(c);\n    g(c >> 8);\n    g(c >> 16);\n    g(c >> 24);\n    g(c >> 32);\n    g(c >> 40);\n    g(c >> 48);\n    g(c >> 56);\n}\n\nstatic void orex(int ll, int r, int r2, int b)\n{\n    if ((r & VT_VALMASK) >= VT_CONST)\n        r = 0;\n    if ((r2 & VT_VALMASK) >= VT_CONST)\n        r2 = 0;\n    if (ll || REX_BASE(r) || REX_BASE(r2))\n        o(0x40 | REX_BASE(r) | (REX_BASE(r2) << 2) | (ll << 3));\n    o(b);\n}\n\n/* output a symbol and patch all calls to it */\nST_FUNC void gsym_addr(int t, int a)\n{\n    while (t) {\n        unsigned char *ptr = cur_text_section->data + t;\n        uint32_t n = read32le(ptr); /* next value */\n        write32le(ptr, a < 0 ? -a : a - t - 4);\n        t = n;\n    }\n}\n\nstatic int is64_type(int t)\n{\n    return ((t & VT_BTYPE) == VT_PTR ||\n            (t & VT_BTYPE) == VT_FUNC ||\n            (t & VT_BTYPE) == VT_LLONG);\n}\n\n/* instruction + 4 bytes data. Return the address of the data */\nstatic int oad(int c, int s)\n{\n    int t;\n    if (nocode_wanted)\n        return s;\n    o(c);\n    t = ind;\n    gen_le32(s);\n    return t;\n}\n\n/* generate jmp to a label */\n#define gjmp2(instr,lbl) oad(instr,lbl)\n\nST_FUNC void gen_addr32(int r, Sym *sym, int c)\n{\n    if (r & VT_SYM)\n        greloca(cur_text_section, sym, ind, R_X86_64_32S, c), c=0;\n    gen_le32(c);\n}\n\n/* output constant with relocation if 'r & VT_SYM' is true */\nST_FUNC void gen_addr64(int r, Sym *sym, int64_t c)\n{\n    if (r & VT_SYM)\n        greloca(cur_text_section, sym, ind, R_X86_64_64, c), c=0;\n    gen_le64(c);\n}\n\n/* output constant with relocation if 'r & VT_SYM' is true */\nST_FUNC void gen_addrpc32(int r, Sym *sym, int c)\n{\n    if (r & VT_SYM)\n        greloca(cur_text_section, sym, ind, R_X86_64_PC32, c-4), c=4;\n    gen_le32(c-4);\n}\n\n/* output got address with relocation */\nstatic void gen_gotpcrel(int r, Sym *sym, int c)\n{\n#ifdef TCC_TARGET_PE\n    tcc_error(\"internal error: no GOT on PE: %s %x %x | %02x %02x %02x\\n\",\n        get_tok_str(sym->v, NULL), c, r,\n        cur_text_section->data[ind-3],\n        cur_text_section->data[ind-2],\n        cur_text_section->data[ind-1]\n        );\n#endif\n    greloca(cur_text_section, sym, ind, R_X86_64_GOTPCREL, -4);\n    gen_le32(0);\n    if (c) {\n        /* we use add c, %xxx for displacement */\n        orex(1, r, 0, 0x81);\n        o(0xc0 + REG_VALUE(r));\n        gen_le32(c);\n    }\n}\n\nstatic void gen_modrm_impl(int op_reg, int r, Sym *sym, int c, int is_got)\n{\n    op_reg = REG_VALUE(op_reg) << 3;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        /* constant memory reference */\n\tif (!(r & VT_SYM)) {\n\t    /* Absolute memory reference */\n\t    o(0x04 | op_reg); /* [sib] | destreg */\n\t    oad(0x25, c);     /* disp32 */\n\t} else {\n\t    o(0x05 | op_reg); /* (%rip)+disp32 | destreg */\n\t    if (is_got) {\n\t\tgen_gotpcrel(r, sym, c);\n\t    } else {\n\t\tgen_addrpc32(r, sym, c);\n\t    }\n\t}\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        /* currently, we use only ebp as base */\n        if (c == (char)c) {\n            /* short reference */\n            o(0x45 | op_reg);\n            g(c);\n        } else {\n            oad(0x85 | op_reg, c);\n        }\n    } else if ((r & VT_VALMASK) >= TREG_MEM) {\n        if (c) {\n            g(0x80 | op_reg | REG_VALUE(r));\n            gen_le32(c);\n        } else {\n            g(0x00 | op_reg | REG_VALUE(r));\n        }\n    } else {\n        g(0x00 | op_reg | REG_VALUE(r));\n    }\n}\n\n/* generate a modrm reference. 'op_reg' contains the additional 3\n   opcode bits */\nstatic void gen_modrm(int op_reg, int r, Sym *sym, int c)\n{\n    gen_modrm_impl(op_reg, r, sym, c, 0);\n}\n\n/* generate a modrm reference. 'op_reg' contains the additional 3\n   opcode bits */\nstatic void gen_modrm64(int opcode, int op_reg, int r, Sym *sym, int c)\n{\n    int is_got;\n    is_got = (op_reg & TREG_MEM) && !(sym->type.t & VT_STATIC);\n    orex(1, r, op_reg, opcode);\n    gen_modrm_impl(op_reg, r, sym, c, is_got);\n}\n\n\n/* load 'r' from value 'sv' */\nvoid load(int r, SValue *sv)\n{\n    int v, t, ft, fc, fr;\n    SValue v1;\n\n    fr = sv->r;\n    ft = sv->type.t & ~VT_DEFSIGN;\n    fc = sv->c.i;\n    if (fc != sv->c.i && (fr & VT_SYM))\n      tcc_error(\"64 bit addend in load\");\n\n    ft &= ~(VT_VOLATILE | VT_CONSTANT);\n\n#ifndef TCC_TARGET_PE\n    /* we use indirect access via got */\n    if ((fr & VT_VALMASK) == VT_CONST && (fr & VT_SYM) &&\n        (fr & VT_LVAL) && !(sv->sym->type.t & VT_STATIC)) {\n        /* use the result register as a temporal register */\n        int tr = r | TREG_MEM;\n        if (is_float(ft)) {\n            /* we cannot use float registers as a temporal register */\n            tr = get_reg(RC_INT) | TREG_MEM;\n        }\n        gen_modrm64(0x8b, tr, fr, sv->sym, 0);\n\n        /* load from the temporal register */\n        fr = tr | VT_LVAL;\n    }\n#endif\n\n    v = fr & VT_VALMASK;\n    if (fr & VT_LVAL) {\n        int b, ll;\n        if (v == VT_LLOCAL) {\n            v1.type.t = VT_PTR;\n            v1.r = VT_LOCAL | VT_LVAL;\n            v1.c.i = fc;\n            fr = r;\n            if (!(reg_classes[fr] & (RC_INT|RC_R11)))\n                fr = get_reg(RC_INT);\n            load(fr, &v1);\n        }\n\tif (fc != sv->c.i) {\n\t    /* If the addends doesn't fit into a 32bit signed\n\t       we must use a 64bit move.  We've checked above\n\t       that this doesn't have a sym associated.  */\n\t    v1.type.t = VT_LLONG;\n\t    v1.r = VT_CONST;\n\t    v1.c.i = sv->c.i;\n\t    fr = r;\n\t    if (!(reg_classes[fr] & (RC_INT|RC_R11)))\n\t        fr = get_reg(RC_INT);\n\t    load(fr, &v1);\n\t    fc = 0;\n\t}\n        ll = 0;\n\t/* Like GCC we can load from small enough properly sized\n\t   structs and unions as well.\n\t   XXX maybe move to generic operand handling, but should\n\t   occur only with asm, so tccasm.c might also be a better place */\n\tif ((ft & VT_BTYPE) == VT_STRUCT) {\n\t    int align;\n\t    switch (type_size(&sv->type, &align)) {\n\t\tcase 1: ft = VT_BYTE; break;\n\t\tcase 2: ft = VT_SHORT; break;\n\t\tcase 4: ft = VT_INT; break;\n\t\tcase 8: ft = VT_LLONG; break;\n\t\tdefault:\n\t\t    tcc_error(\"invalid aggregate type for register load\");\n\t\t    break;\n\t    }\n\t}\n        if ((ft & VT_BTYPE) == VT_FLOAT) {\n            b = 0x6e0f66;\n            r = REG_VALUE(r); /* movd */\n        } else if ((ft & VT_BTYPE) == VT_DOUBLE) {\n            b = 0x7e0ff3; /* movq */\n            r = REG_VALUE(r);\n        } else if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n            b = 0xdb, r = 5; /* fldt */\n        } else if ((ft & VT_TYPE) == VT_BYTE || (ft & VT_TYPE) == VT_BOOL) {\n            b = 0xbe0f;   /* movsbl */\n        } else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED)) {\n            b = 0xb60f;   /* movzbl */\n        } else if ((ft & VT_TYPE) == VT_SHORT) {\n            b = 0xbf0f;   /* movswl */\n        } else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED)) {\n            b = 0xb70f;   /* movzwl */\n        } else if ((ft & VT_TYPE) == (VT_VOID)) {\n            /* Can happen with zero size structs */\n            return;\n        } else {\n            assert(((ft & VT_BTYPE) == VT_INT)\n                   || ((ft & VT_BTYPE) == VT_LLONG)\n                   || ((ft & VT_BTYPE) == VT_PTR)\n                   || ((ft & VT_BTYPE) == VT_FUNC)\n                );\n            ll = is64_type(ft);\n            b = 0x8b;\n        }\n        if (ll) {\n            gen_modrm64(b, r, fr, sv->sym, fc);\n        } else {\n            orex(ll, fr, r, b);\n            gen_modrm(r, fr, sv->sym, fc);\n        }\n    } else {\n        if (v == VT_CONST) {\n            if (fr & VT_SYM) {\n#ifdef TCC_TARGET_PE\n                orex(1,0,r,0x8d);\n                o(0x05 + REG_VALUE(r) * 8); /* lea xx(%rip), r */\n                gen_addrpc32(fr, sv->sym, fc);\n#else\n                if (sv->sym->type.t & VT_STATIC) {\n                    orex(1,0,r,0x8d);\n                    o(0x05 + REG_VALUE(r) * 8); /* lea xx(%rip), r */\n                    gen_addrpc32(fr, sv->sym, fc);\n                } else {\n                    orex(1,0,r,0x8b);\n                    o(0x05 + REG_VALUE(r) * 8); /* mov xx(%rip), r */\n                    gen_gotpcrel(r, sv->sym, fc);\n                }\n#endif\n            } else if (is64_type(ft)) {\n                if (sv->c.i >> 32) {\n                    orex(1,r,0, 0xb8 + REG_VALUE(r)); /* movabs $xx, r */\n                    gen_le64(sv->c.i);\n                } else if (sv->c.i > 0) {\n                    orex(0,r,0, 0xb8 + REG_VALUE(r)); /* mov $xx, r */\n                    gen_le32(sv->c.i);\n                } else {\n                    o(0xc031 + REG_VALUE(r) * 0x900); /* xor r, r */\n                }\n            } else {\n                orex(0,r,0, 0xb8 + REG_VALUE(r)); /* mov $xx, r */\n                gen_le32(fc);\n            }\n        } else if (v == VT_LOCAL) {\n            orex(1,0,r,0x8d); /* lea xxx(%ebp), r */\n            gen_modrm(r, VT_LOCAL, sv->sym, fc);\n        } else if (v == VT_CMP) {\n\t    if (fc & 0x100)\n\t      {\n                v = vtop->cmp_r;\n                fc &= ~0x100;\n\t        /* This was a float compare.  If the parity bit is\n\t\t   set the result was unordered, meaning false for everything\n\t\t   except TOK_NE, and true for TOK_NE.  */\n                orex(0, r, 0, 0xb0 + REG_VALUE(r)); /* mov $0/1,%al */\n                g(v ^ fc ^ (v == TOK_NE));\n                o(0x037a + (REX_BASE(r) << 8));\n              }\n            orex(0,r,0, 0x0f); /* setxx %br */\n            o(fc);\n            o(0xc0 + REG_VALUE(r));\n            orex(0,r,0, 0x0f);\n            o(0xc0b6 + REG_VALUE(r) * 0x900); /* movzbl %al, %eax */\n        } else if (v == VT_JMP || v == VT_JMPI) {\n            t = v & 1;\n            orex(0,r,0,0);\n            oad(0xb8 + REG_VALUE(r), t); /* mov $1, r */\n            o(0x05eb + (REX_BASE(r) << 8)); /* jmp after */\n            gsym(fc);\n            orex(0,r,0,0);\n            oad(0xb8 + REG_VALUE(r), t ^ 1); /* mov $0, r */\n        } else if (v != r) {\n            if ((r >= TREG_XMM0) && (r <= TREG_XMM7)) {\n                if (v == TREG_ST0) {\n                    /* gen_cvt_ftof(VT_DOUBLE); */\n                    o(0xf0245cdd); /* fstpl -0x10(%rsp) */\n                    /* movsd -0x10(%rsp),%xmmN */\n                    o(0x100ff2);\n                    o(0x44 + REG_VALUE(r)*8); /* %xmmN */\n                    o(0xf024);\n                } else {\n                    assert((v >= TREG_XMM0) && (v <= TREG_XMM7));\n                    if ((ft & VT_BTYPE) == VT_FLOAT) {\n                        o(0x100ff3);\n                    } else {\n                        assert((ft & VT_BTYPE) == VT_DOUBLE);\n                        o(0x100ff2);\n                    }\n                    o(0xc0 + REG_VALUE(v) + REG_VALUE(r)*8);\n                }\n            } else if (r == TREG_ST0) {\n                assert((v >= TREG_XMM0) && (v <= TREG_XMM7));\n                /* gen_cvt_ftof(VT_LDOUBLE); */\n                /* movsd %xmmN,-0x10(%rsp) */\n                o(0x110ff2);\n                o(0x44 + REG_VALUE(r)*8); /* %xmmN */\n                o(0xf024);\n                o(0xf02444dd); /* fldl -0x10(%rsp) */\n            } else {\n                orex(is64_type(ft), r, v, 0x89);\n                o(0xc0 + REG_VALUE(r) + REG_VALUE(v) * 8); /* mov v, r */\n            }\n        }\n    }\n}\n\n/* store register 'r' in lvalue 'v' */\nvoid store(int r, SValue *v)\n{\n    int fr, bt, ft, fc;\n    int op64 = 0;\n    /* store the REX prefix in this variable when PIC is enabled */\n    int pic = 0;\n\n    fr = v->r & VT_VALMASK;\n    ft = v->type.t;\n    fc = v->c.i;\n    if (fc != v->c.i && (fr & VT_SYM))\n      tcc_error(\"64 bit addend in store\");\n    ft &= ~(VT_VOLATILE | VT_CONSTANT);\n    bt = ft & VT_BTYPE;\n\n#ifndef TCC_TARGET_PE\n    /* we need to access the variable via got */\n    if (fr == VT_CONST\n        && (v->r & VT_SYM)\n        && !(v->sym->type.t & VT_STATIC)) {\n        /* mov xx(%rip), %r11 */\n        o(0x1d8b4c);\n        gen_gotpcrel(TREG_R11, v->sym, v->c.i);\n        pic = is64_type(bt) ? 0x49 : 0x41;\n    }\n#endif\n\n    /* XXX: incorrect if float reg to reg */\n    if (bt == VT_FLOAT) {\n        o(0x66);\n        o(pic);\n        o(0x7e0f); /* movd */\n        r = REG_VALUE(r);\n    } else if (bt == VT_DOUBLE) {\n        o(0x66);\n        o(pic);\n        o(0xd60f); /* movq */\n        r = REG_VALUE(r);\n    } else if (bt == VT_LDOUBLE) {\n        o(0xc0d9); /* fld %st(0) */\n        o(pic);\n        o(0xdb); /* fstpt */\n        r = 7;\n    } else {\n        if (bt == VT_SHORT)\n            o(0x66);\n        o(pic);\n        if (bt == VT_BYTE || bt == VT_BOOL)\n            orex(0, 0, r, 0x88);\n        else if (is64_type(bt))\n            op64 = 0x89;\n        else\n            orex(0, 0, r, 0x89);\n    }\n    if (pic) {\n        /* xxx r, (%r11) where xxx is mov, movq, fld, or etc */\n        if (op64)\n            o(op64);\n        o(3 + (r << 3));\n    } else if (op64) {\n        if (fr == VT_CONST || fr == VT_LOCAL || (v->r & VT_LVAL)) {\n            gen_modrm64(op64, r, v->r, v->sym, fc);\n        } else if (fr != r) {\n            orex(1, fr, r, op64);\n            o(0xc0 + fr + r * 8); /* mov r, fr */\n        }\n    } else {\n        if (fr == VT_CONST || fr == VT_LOCAL || (v->r & VT_LVAL)) {\n            gen_modrm(r, v->r, v->sym, fc);\n        } else if (fr != r) {\n            o(0xc0 + fr + r * 8); /* mov r, fr */\n        }\n    }\n}\n\n/* 'is_jmp' is '1' if it is a jump */\nstatic void gcall_or_jmp(int is_jmp)\n{\n    int r;\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&\n\t((vtop->r & VT_SYM) && (vtop->c.i-4) == (int)(vtop->c.i-4))) {\n        /* constant symbolic case -> simple relocation */\n        greloca(cur_text_section, vtop->sym, ind + 1, R_X86_64_PLT32, (int)(vtop->c.i-4));\n        oad(0xe8 + is_jmp, 0); /* call/jmp im */\n    } else {\n        /* otherwise, indirect call */\n        r = TREG_R11;\n        load(r, vtop);\n        o(0x41); /* REX */\n        o(0xff); /* call/jmp *r */\n        o(0xd0 + REG_VALUE(r) + (is_jmp << 4));\n    }\n}\n\n#if defined(CONFIG_TCC_BCHECK)\n\nstatic void gen_bounds_call(int v)\n{\n    Sym *sym = external_helper_sym(v);\n    oad(0xe8, 0);\n    greloca(cur_text_section, sym, ind-4, R_X86_64_PLT32, -4);\n}\n\n#ifdef TCC_TARGET_PE\n# define TREG_FASTCALL_1 TREG_RCX\n#else\n# define TREG_FASTCALL_1 TREG_RDI\n#endif\n\nstatic void gen_bounds_prolog(void)\n{\n    /* leave some room for bound checking code */\n    func_bound_offset = lbounds_section->data_offset;\n    func_bound_ind = ind;\n    func_bound_add_epilog = 0;\n    o(0x0d8d48 + ((TREG_FASTCALL_1 == TREG_RDI) * 0x300000)); /*lbound section pointer */\n    gen_le32 (0);\n    oad(0xb8, 0); /* call to function */\n}\n\nstatic void gen_bounds_epilog(void)\n{\n    addr_t saved_ind;\n    addr_t *bounds_ptr;\n    Sym *sym_data;\n    int offset_modified = func_bound_offset != lbounds_section->data_offset;\n\n    if (!offset_modified && !func_bound_add_epilog)\n        return;\n\n    /* add end of table info */\n    bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));\n    *bounds_ptr = 0;\n\n    sym_data = get_sym_ref(&char_pointer_type, lbounds_section, \n                           func_bound_offset, PTR_SIZE);\n\n    /* generate bound local allocation */\n    if (offset_modified) {\n        saved_ind = ind;\n        ind = func_bound_ind;\n        greloca(cur_text_section, sym_data, ind + 3, R_X86_64_PC32, -4);\n        ind = ind + 7;\n        gen_bounds_call(TOK___bound_local_new);\n        ind = saved_ind;\n    }\n\n    /* generate bound check local freeing */\n    o(0x5250); /* save returned value, if any */\n    o(0x20ec8348); /* sub $32,%rsp */\n    o(0x290f);     /* movaps %xmm0,0x10(%rsp) */\n    o(0x102444);\n    o(0x240c290f); /* movaps %xmm1,(%rsp) */\n    greloca(cur_text_section, sym_data, ind + 3, R_X86_64_PC32, -4);\n    o(0x0d8d48 + ((TREG_FASTCALL_1 == TREG_RDI) * 0x300000)); /* lea xxx(%rip), %rcx/rdi */\n    gen_le32 (0);\n    gen_bounds_call(TOK___bound_local_delete);\n    o(0x280f);     /* movaps 0x10(%rsp),%xmm0 */\n    o(0x102444);\n    o(0x240c280f); /* movaps (%rsp),%xmm1 */\n    o(0x20c48348); /* add $32,%rsp */\n    o(0x585a); /* restore returned value, if any */\n}\n#endif\n\n#ifdef TCC_TARGET_PE\n\n#define REGN 4\nstatic const uint8_t arg_regs[REGN] = {\n    TREG_RCX, TREG_RDX, TREG_R8, TREG_R9\n};\n\n/* Prepare arguments in R10 and R11 rather than RCX and RDX\n   because gv() will not ever use these */\nstatic int arg_prepare_reg(int idx) {\n  if (idx == 0 || idx == 1)\n      /* idx=0: r10, idx=1: r11 */\n      return idx + 10;\n  else\n      return idx >= 0 && idx < REGN ? arg_regs[idx] : 0;\n}\n\n/* Generate function call. The function address is pushed first, then\n   all the parameters in call order. This functions pops all the\n   parameters and the function address. */\n\nstatic void gen_offs_sp(int b, int r, int d)\n{\n    orex(1,0,r & 0x100 ? 0 : r, b);\n    if (d == (char)d) {\n        o(0x2444 | (REG_VALUE(r) << 3));\n        g(d);\n    } else {\n        o(0x2484 | (REG_VALUE(r) << 3));\n        gen_le32(d);\n    }\n}\n\nstatic int using_regs(int size)\n{\n    return !(size > 8 || (size & (size - 1)));\n}\n\n/* Return the number of registers needed to return the struct, or 0 if\n   returning via struct pointer. */\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)\n{\n    int size, align;\n    *ret_align = 1; // Never have to re-align return values for x86-64\n    *regsize = 8;\n    size = type_size(vt, &align);\n    if (!using_regs(size))\n        return 0;\n    if (size == 8)\n        ret->t = VT_LLONG;\n    else if (size == 4)\n        ret->t = VT_INT;\n    else if (size == 2)\n        ret->t = VT_SHORT;\n    else\n        ret->t = VT_BYTE;\n    ret->ref = NULL;\n    return 1;\n}\n\nstatic int is_sse_float(int t) {\n    int bt;\n    bt = t & VT_BTYPE;\n    return bt == VT_DOUBLE || bt == VT_FLOAT;\n}\n\nstatic int gfunc_arg_size(CType *type) {\n    int align;\n    if (type->t & (VT_ARRAY|VT_BITFIELD))\n        return 8;\n    return type_size(type, &align);\n}\n\nvoid gfunc_call(int nb_args)\n{\n    int size, r, args_size, i, d, bt, struct_size;\n    int arg;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gbound_args(nb_args);\n#endif\n\n    args_size = (nb_args < REGN ? REGN : nb_args) * PTR_SIZE;\n    arg = nb_args;\n\n    /* for struct arguments, we need to call memcpy and the function\n       call breaks register passing arguments we are preparing.\n       So, we process arguments which will be passed by stack first. */\n    struct_size = args_size;\n    for(i = 0; i < nb_args; i++) {\n        SValue *sv;\n        \n        --arg;\n        sv = &vtop[-i];\n        bt = (sv->type.t & VT_BTYPE);\n        size = gfunc_arg_size(&sv->type);\n\n        if (using_regs(size))\n            continue; /* arguments smaller than 8 bytes passed in registers or on stack */\n\n        if (bt == VT_STRUCT) {\n            /* fetch cpu flag before generating any code */\n            if ((vtop->r & VT_VALMASK) == VT_CMP)\n                gv(RC_INT);\n            /* align to stack align size */\n            size = (size + 15) & ~15;\n            /* generate structure store */\n            r = get_reg(RC_INT);\n            gen_offs_sp(0x8d, r, struct_size);\n            struct_size += size;\n\n            /* generate memcpy call */\n            vset(&sv->type, r | VT_LVAL, 0);\n            vpushv(sv);\n            vstore();\n            --vtop;\n        } else if (bt == VT_LDOUBLE) {\n            gv(RC_ST0);\n            gen_offs_sp(0xdb, 0x107, struct_size);\n            struct_size += 16;\n        }\n    }\n\n    if (func_scratch < struct_size)\n        func_scratch = struct_size;\n\n    arg = nb_args;\n    struct_size = args_size;\n\n    for(i = 0; i < nb_args; i++) {\n        --arg;\n        bt = (vtop->type.t & VT_BTYPE);\n\n        size = gfunc_arg_size(&vtop->type);\n        if (!using_regs(size)) {\n            /* align to stack align size */\n            size = (size + 15) & ~15;\n            if (arg >= REGN) {\n                d = get_reg(RC_INT);\n                gen_offs_sp(0x8d, d, struct_size);\n                gen_offs_sp(0x89, d, arg*8);\n            } else {\n                d = arg_prepare_reg(arg);\n                gen_offs_sp(0x8d, d, struct_size);\n            }\n            struct_size += size;\n        } else {\n            if (is_sse_float(vtop->type.t)) {\n\t\tif (tcc_state->nosse)\n\t\t  tcc_error(\"SSE disabled\");\n                if (arg >= REGN) {\n                    gv(RC_XMM0);\n                    /* movq %xmm0, j*8(%rsp) */\n                    gen_offs_sp(0xd60f66, 0x100, arg*8);\n                } else {\n                    /* Load directly to xmmN register */\n                    gv(RC_XMM0 << arg);\n                    d = arg_prepare_reg(arg);\n                    /* mov %xmmN, %rxx */\n                    o(0x66);\n                    orex(1,d,0, 0x7e0f);\n                    o(0xc0 + arg*8 + REG_VALUE(d));\n                }\n            } else {\n                if (bt == VT_STRUCT) {\n                    vtop->type.ref = NULL;\n                    vtop->type.t = size > 4 ? VT_LLONG : size > 2 ? VT_INT\n                        : size > 1 ? VT_SHORT : VT_BYTE;\n                }\n                \n                r = gv(RC_INT);\n                if (arg >= REGN) {\n                    gen_offs_sp(0x89, r, arg*8);\n                } else {\n                    d = arg_prepare_reg(arg);\n                    orex(1,d,r,0x89); /* mov */\n                    o(0xc0 + REG_VALUE(r) * 8 + REG_VALUE(d));\n                }\n            }\n        }\n        vtop--;\n    }\n    save_regs(0);\n    /* Copy R10 and R11 into RCX and RDX, respectively */\n    if (nb_args > 0) {\n        o(0xd1894c); /* mov %r10, %rcx */\n        if (nb_args > 1) {\n            o(0xda894c); /* mov %r11, %rdx */\n        }\n    }\n    \n    gcall_or_jmp(0);\n\n    if ((vtop->r & VT_SYM) && vtop->sym->v == TOK_alloca) {\n        /* need to add the \"func_scratch\" area after alloca */\n        o(0x48); func_alloca = oad(0x05, func_alloca); /* add $NN, %rax */\n#ifdef CONFIG_TCC_BCHECK\n        if (tcc_state->do_bounds_check)\n            gen_bounds_call(TOK___bound_alloca_nr); /* new region */\n#endif\n    }\n    vtop--;\n}\n\n\n#define FUNC_PROLOG_SIZE 11\n\n/* generate function prolog of type 't' */\nvoid gfunc_prolog(Sym *func_sym)\n{\n    CType *func_type = &func_sym->type;\n    int addr, reg_param_index, bt, size;\n    Sym *sym;\n    CType *type;\n\n    func_ret_sub = 0;\n    func_scratch = 32;\n    func_alloca = 0;\n    loc = 0;\n\n    addr = PTR_SIZE * 2;\n    ind += FUNC_PROLOG_SIZE;\n    func_sub_sp_offset = ind;\n    reg_param_index = 0;\n\n    sym = func_type->ref;\n\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n    size = gfunc_arg_size(&func_vt);\n    if (!using_regs(size)) {\n        gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);\n        func_vc = addr;\n        reg_param_index++;\n        addr += 8;\n    }\n\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n        type = &sym->type;\n        bt = type->t & VT_BTYPE;\n        size = gfunc_arg_size(type);\n        if (!using_regs(size)) {\n            if (reg_param_index < REGN) {\n                gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);\n            }\n            sym_push(sym->v & ~SYM_FIELD, type,\n                     VT_LLOCAL | VT_LVAL, addr);\n        } else {\n            if (reg_param_index < REGN) {\n                /* save arguments passed by register */\n                if ((bt == VT_FLOAT) || (bt == VT_DOUBLE)) {\n\t\t    if (tcc_state->nosse)\n\t\t      tcc_error(\"SSE disabled\");\n                    o(0xd60f66); /* movq */\n                    gen_modrm(reg_param_index, VT_LOCAL, NULL, addr);\n                } else {\n                    gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);\n                }\n            }\n            sym_push(sym->v & ~SYM_FIELD, type,\n\t\t     VT_LOCAL | VT_LVAL, addr);\n        }\n        addr += 8;\n        reg_param_index++;\n    }\n\n    while (reg_param_index < REGN) {\n        if (func_var) {\n            gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);\n            addr += 8;\n        }\n        reg_param_index++;\n    }\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_prolog();\n#endif\n}\n\n/* generate function epilog */\nvoid gfunc_epilog(void)\n{\n    int v, start;\n\n    /* align local size to word & save local variables */\n    func_scratch = (func_scratch + 15) & -16;\n    loc = (loc & -16) - func_scratch;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_epilog();\n#endif\n\n    o(0xc9); /* leave */\n    if (func_ret_sub == 0) {\n        o(0xc3); /* ret */\n    } else {\n        o(0xc2); /* ret n */\n        g(func_ret_sub);\n        g(func_ret_sub >> 8);\n    }\n\n    v = -loc;\n    start = func_sub_sp_offset - FUNC_PROLOG_SIZE;\n    cur_text_section->data_offset = ind;\n    pe_add_unwind_data(start, ind, v);\n\n    ind = start;\n    if (v >= 4096) {\n        Sym *sym = external_helper_sym(TOK___chkstk);\n        oad(0xb8, v); /* mov stacksize, %eax */\n        oad(0xe8, 0); /* call __chkstk, (does the stackframe too) */\n        greloca(cur_text_section, sym, ind-4, R_X86_64_PLT32, -4);\n        o(0x90); /* fill for FUNC_PROLOG_SIZE = 11 bytes */\n    } else {\n        o(0xe5894855);  /* push %rbp, mov %rsp, %rbp */\n        o(0xec8148);  /* sub rsp, stacksize */\n        gen_le32(v);\n    }\n    ind = cur_text_section->data_offset;\n\n    /* add the \"func_scratch\" area after each alloca seen */\n    gsym_addr(func_alloca, -func_scratch);\n}\n\n#else\n\nstatic void gadd_sp(int val)\n{\n    if (val == (char)val) {\n        o(0xc48348);\n        g(val);\n    } else {\n        oad(0xc48148, val); /* add $xxx, %rsp */\n    }\n}\n\ntypedef enum X86_64_Mode {\n  x86_64_mode_none,\n  x86_64_mode_memory,\n  x86_64_mode_integer,\n  x86_64_mode_sse,\n  x86_64_mode_x87\n} X86_64_Mode;\n\nstatic X86_64_Mode classify_x86_64_merge(X86_64_Mode a, X86_64_Mode b)\n{\n    if (a == b)\n        return a;\n    else if (a == x86_64_mode_none)\n        return b;\n    else if (b == x86_64_mode_none)\n        return a;\n    else if ((a == x86_64_mode_memory) || (b == x86_64_mode_memory))\n        return x86_64_mode_memory;\n    else if ((a == x86_64_mode_integer) || (b == x86_64_mode_integer))\n        return x86_64_mode_integer;\n    else if ((a == x86_64_mode_x87) || (b == x86_64_mode_x87))\n        return x86_64_mode_memory;\n    else\n        return x86_64_mode_sse;\n}\n\nstatic X86_64_Mode classify_x86_64_inner(CType *ty)\n{\n    X86_64_Mode mode;\n    Sym *f;\n    \n    switch (ty->t & VT_BTYPE) {\n    case VT_VOID: return x86_64_mode_none;\n    \n    case VT_INT:\n    case VT_BYTE:\n    case VT_SHORT:\n    case VT_LLONG:\n    case VT_BOOL:\n    case VT_PTR:\n    case VT_FUNC:\n        return x86_64_mode_integer;\n    \n    case VT_FLOAT:\n    case VT_DOUBLE: return x86_64_mode_sse;\n    \n    case VT_LDOUBLE: return x86_64_mode_x87;\n      \n    case VT_STRUCT:\n        f = ty->ref;\n\n        mode = x86_64_mode_none;\n        for (f = f->next; f; f = f->next)\n            mode = classify_x86_64_merge(mode, classify_x86_64_inner(&f->type));\n        \n        return mode;\n    }\n    assert(0);\n    return 0;\n}\n\nstatic X86_64_Mode classify_x86_64_arg(CType *ty, CType *ret, int *psize, int *palign, int *reg_count)\n{\n    X86_64_Mode mode;\n    int size, align, ret_t = 0;\n    \n    if (ty->t & (VT_BITFIELD|VT_ARRAY)) {\n        *psize = 8;\n        *palign = 8;\n        *reg_count = 1;\n        ret_t = ty->t;\n        mode = x86_64_mode_integer;\n    } else {\n        size = type_size(ty, &align);\n        *psize = (size + 7) & ~7;\n        *palign = (align + 7) & ~7;\n        *reg_count = 0; /* avoid compiler warning */\n\n        if (size > 16) {\n            mode = x86_64_mode_memory;\n        } else {\n            mode = classify_x86_64_inner(ty);\n            switch (mode) {\n            case x86_64_mode_integer:\n                if (size > 8) {\n                    *reg_count = 2;\n                    ret_t = VT_QLONG;\n                } else {\n                    *reg_count = 1;\n                    if (size > 4)\n                        ret_t = VT_LLONG;\n                    else if (size > 2)\n                        ret_t = VT_INT;\n                    else if (size > 1)\n                        ret_t = VT_SHORT;\n                    else\n                        ret_t = VT_BYTE;\n                    if ((ty->t & VT_BTYPE) == VT_STRUCT || (ty->t & VT_UNSIGNED))\n                        ret_t |= VT_UNSIGNED;\n                }\n                break;\n                \n            case x86_64_mode_x87:\n                *reg_count = 1;\n                ret_t = VT_LDOUBLE;\n                break;\n\n            case x86_64_mode_sse:\n                if (size > 8) {\n                    *reg_count = 2;\n                    ret_t = VT_QFLOAT;\n                } else {\n                    *reg_count = 1;\n                    ret_t = (size > 4) ? VT_DOUBLE : VT_FLOAT;\n                }\n                break;\n            default: break; /* nothing to be done for x86_64_mode_memory and x86_64_mode_none*/\n            }\n        }\n    }\n    \n    if (ret) {\n        ret->ref = NULL;\n        ret->t = ret_t;\n    }\n    \n    return mode;\n}\n\nST_FUNC int classify_x86_64_va_arg(CType *ty)\n{\n    /* This definition must be synced with stdarg.h */\n    enum __va_arg_type {\n        __va_gen_reg, __va_float_reg, __va_stack\n    };\n    int size, align, reg_count;\n    X86_64_Mode mode = classify_x86_64_arg(ty, NULL, &size, &align, &reg_count);\n    switch (mode) {\n    default: return __va_stack;\n    case x86_64_mode_integer: return __va_gen_reg;\n    case x86_64_mode_sse: return __va_float_reg;\n    }\n}\n\n/* Return the number of registers needed to return the struct, or 0 if\n   returning via struct pointer. */\nST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)\n{\n    int size, align, reg_count;\n    if (classify_x86_64_arg(vt, ret, &size, &align, &reg_count) == x86_64_mode_memory)\n        return 0;\n    *ret_align = 1; // Never have to re-align return values for x86-64\n    *regsize = 8 * reg_count; /* the (virtual) regsize is 16 for VT_QLONG/QFLOAT */\n    return 1;\n}\n\n#define REGN 6\nstatic const uint8_t arg_regs[REGN] = {\n    TREG_RDI, TREG_RSI, TREG_RDX, TREG_RCX, TREG_R8, TREG_R9\n};\n\nstatic int arg_prepare_reg(int idx) {\n  if (idx == 2 || idx == 3)\n      /* idx=2: r10, idx=3: r11 */\n      return idx + 8;\n  else\n      return idx >= 0 && idx < REGN ? arg_regs[idx] : 0;\n}\n\n/* Generate function call. The function address is pushed first, then\n   all the parameters in call order. This functions pops all the\n   parameters and the function address. */\nvoid gfunc_call(int nb_args)\n{\n    X86_64_Mode mode;\n    CType type;\n    int size, align, r, args_size, stack_adjust, i, reg_count, k;\n    int nb_reg_args = 0;\n    int nb_sse_args = 0;\n    int sse_reg, gen_reg;\n    char *onstack = tcc_malloc((nb_args + 1) * sizeof (char));\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gbound_args(nb_args);\n#endif\n\n    /* calculate the number of integer/float register arguments, remember\n       arguments to be passed via stack (in onstack[]), and also remember\n       if we have to align the stack pointer to 16 (onstack[i] == 2).  Needs\n       to be done in a left-to-right pass over arguments.  */\n    stack_adjust = 0;\n    for(i = nb_args - 1; i >= 0; i--) {\n        mode = classify_x86_64_arg(&vtop[-i].type, NULL, &size, &align, &reg_count);\n        if (size == 0) continue;\n        if (mode == x86_64_mode_sse && nb_sse_args + reg_count <= 8) {\n            nb_sse_args += reg_count;\n\t    onstack[i] = 0;\n\t} else if (mode == x86_64_mode_integer && nb_reg_args + reg_count <= REGN) {\n            nb_reg_args += reg_count;\n\t    onstack[i] = 0;\n\t} else if (mode == x86_64_mode_none) {\n\t    onstack[i] = 0;\n\t} else {\n\t    if (align == 16 && (stack_adjust &= 15)) {\n\t\tonstack[i] = 2;\n\t\tstack_adjust = 0;\n\t    } else\n\t      onstack[i] = 1;\n\t    stack_adjust += size;\n\t}\n    }\n\n    if (nb_sse_args && tcc_state->nosse)\n      tcc_error(\"SSE disabled but floating point arguments passed\");\n\n    /* fetch cpu flag before generating any code */\n    if ((vtop->r & VT_VALMASK) == VT_CMP)\n      gv(RC_INT);\n\n    /* for struct arguments, we need to call memcpy and the function\n       call breaks register passing arguments we are preparing.\n       So, we process arguments which will be passed by stack first. */\n    gen_reg = nb_reg_args;\n    sse_reg = nb_sse_args;\n    args_size = 0;\n    stack_adjust &= 15;\n    for (i = k = 0; i < nb_args;) {\n\tmode = classify_x86_64_arg(&vtop[-i].type, NULL, &size, &align, &reg_count);\n\tif (size) {\n            if (!onstack[i + k]) {\n\t        ++i;\n\t        continue;\n\t    }\n            /* Possibly adjust stack to align SSE boundary.  We're processing\n\t       args from right to left while allocating happens left to right\n\t       (stack grows down), so the adjustment needs to happen _after_\n\t       an argument that requires it.  */\n            if (stack_adjust) {\n\t        o(0x50); /* push %rax; aka sub $8,%rsp */\n                args_size += 8;\n\t        stack_adjust = 0;\n            }\n\t    if (onstack[i + k] == 2)\n\t        stack_adjust = 1;\n        }\n\n\tvrotb(i+1);\n\n\tswitch (vtop->type.t & VT_BTYPE) {\n\t    case VT_STRUCT:\n\t\t/* allocate the necessary size on stack */\n\t\to(0x48);\n\t\toad(0xec81, size); /* sub $xxx, %rsp */\n\t\t/* generate structure store */\n\t\tr = get_reg(RC_INT);\n\t\torex(1, r, 0, 0x89); /* mov %rsp, r */\n\t\to(0xe0 + REG_VALUE(r));\n\t\tvset(&vtop->type, r | VT_LVAL, 0);\n\t\tvswap();\n\t\t/* keep stack aligned for (__bound_)memmove call */\n\t\to(0x10ec8348); /* sub $16,%rsp */\n\t\to(0xf0e48348); /* and $-16,%rsp */\n\t\torex(0,r,0,0x50 + REG_VALUE(r)); /* push r (last %rsp) */\n\t\to(0x08ec8348); /* sub $8,%rsp */\n\t\tvstore();\n\t\to(0x08c48348); /* add $8,%rsp */\n\t\to(0x5c);       /* pop %rsp */\n\t\tbreak;\n\n\t    case VT_LDOUBLE:\n                gv(RC_ST0);\n                oad(0xec8148, size); /* sub $xxx, %rsp */\n                o(0x7cdb); /* fstpt 0(%rsp) */\n                g(0x24);\n                g(0x00);\n\t\tbreak;\n\n\t    case VT_FLOAT:\n\t    case VT_DOUBLE:\n\t\tassert(mode == x86_64_mode_sse);\n\t\tr = gv(RC_FLOAT);\n\t\to(0x50); /* push $rax */\n\t\t/* movq %xmmN, (%rsp) */\n\t\to(0xd60f66);\n\t\to(0x04 + REG_VALUE(r)*8);\n\t\to(0x24);\n\t\tbreak;\n\n\t    default:\n\t\tassert(mode == x86_64_mode_integer);\n\t\t/* simple type */\n\t\t/* XXX: implicit cast ? */\n\t\tr = gv(RC_INT);\n\t\torex(0,r,0,0x50 + REG_VALUE(r)); /* push r */\n\t\tbreak;\n\t}\n\targs_size += size;\n\n\tvpop();\n\t--nb_args;\n\tk++;\n    }\n\n    tcc_free(onstack);\n\n    /* XXX This should be superfluous.  */\n    save_regs(0); /* save used temporary registers */\n\n    /* then, we prepare register passing arguments.\n       Note that we cannot set RDX and RCX in this loop because gv()\n       may break these temporary registers. Let's use R10 and R11\n       instead of them */\n    assert(gen_reg <= REGN);\n    assert(sse_reg <= 8);\n    for(i = 0; i < nb_args; i++) {\n        mode = classify_x86_64_arg(&vtop->type, &type, &size, &align, &reg_count);\n        if (size == 0) continue;\n        /* Alter stack entry type so that gv() knows how to treat it */\n        vtop->type = type;\n        if (mode == x86_64_mode_sse) {\n            if (reg_count == 2) {\n                sse_reg -= 2;\n                gv(RC_FRET); /* Use pair load into xmm0 & xmm1 */\n                if (sse_reg) { /* avoid redundant movaps %xmm0, %xmm0 */\n                    /* movaps %xmm1, %xmmN */\n                    o(0x280f);\n                    o(0xc1 + ((sse_reg+1) << 3));\n                    /* movaps %xmm0, %xmmN */\n                    o(0x280f);\n                    o(0xc0 + (sse_reg << 3));\n                }\n            } else {\n                assert(reg_count == 1);\n                --sse_reg;\n                /* Load directly to register */\n                gv(RC_XMM0 << sse_reg);\n            }\n        } else if (mode == x86_64_mode_integer) {\n            /* simple type */\n            /* XXX: implicit cast ? */\n            int d;\n            gen_reg -= reg_count;\n            r = gv(RC_INT);\n            d = arg_prepare_reg(gen_reg);\n            orex(1,d,r,0x89); /* mov */\n            o(0xc0 + REG_VALUE(r) * 8 + REG_VALUE(d));\n            if (reg_count == 2) {\n                d = arg_prepare_reg(gen_reg+1);\n                orex(1,d,vtop->r2,0x89); /* mov */\n                o(0xc0 + REG_VALUE(vtop->r2) * 8 + REG_VALUE(d));\n            }\n        }\n        vtop--;\n    }\n    assert(gen_reg == 0);\n    assert(sse_reg == 0);\n\n    /* We shouldn't have many operands on the stack anymore, but the\n       call address itself is still there, and it might be in %eax\n       (or edx/ecx) currently, which the below writes would clobber.\n       So evict all remaining operands here.  */\n    save_regs(0);\n\n    /* Copy R10 and R11 into RDX and RCX, respectively */\n    if (nb_reg_args > 2) {\n        o(0xd2894c); /* mov %r10, %rdx */\n        if (nb_reg_args > 3) {\n            o(0xd9894c); /* mov %r11, %rcx */\n        }\n    }\n\n    if (vtop->type.ref->f.func_type != FUNC_NEW) /* implies FUNC_OLD or FUNC_ELLIPSIS */\n        oad(0xb8, nb_sse_args < 8 ? nb_sse_args : 8); /* mov nb_sse_args, %eax */\n    gcall_or_jmp(0);\n    if (args_size)\n        gadd_sp(args_size);\n    vtop--;\n}\n\n#define FUNC_PROLOG_SIZE 11\n\nstatic void push_arg_reg(int i) {\n    loc -= 8;\n    gen_modrm64(0x89, arg_regs[i], VT_LOCAL, NULL, loc);\n}\n\n/* generate function prolog of type 't' */\nvoid gfunc_prolog(Sym *func_sym)\n{\n    CType *func_type = &func_sym->type;\n    X86_64_Mode mode, ret_mode;\n    int i, addr, align, size, reg_count;\n    int param_addr = 0, reg_param_index, sse_param_index;\n    Sym *sym;\n    CType *type;\n\n    sym = func_type->ref;\n    addr = PTR_SIZE * 2;\n    loc = 0;\n    ind += FUNC_PROLOG_SIZE;\n    func_sub_sp_offset = ind;\n    func_ret_sub = 0;\n    ret_mode = classify_x86_64_arg(&func_vt, NULL, &size, &align, &reg_count);\n\n    if (func_var) {\n        int seen_reg_num, seen_sse_num, seen_stack_size;\n        seen_reg_num = ret_mode == x86_64_mode_memory;\n        seen_sse_num = 0;\n        /* frame pointer and return address */\n        seen_stack_size = PTR_SIZE * 2;\n        /* count the number of seen parameters */\n        sym = func_type->ref;\n        while ((sym = sym->next) != NULL) {\n            type = &sym->type;\n            mode = classify_x86_64_arg(type, NULL, &size, &align, &reg_count);\n            switch (mode) {\n            default:\n            stack_arg:\n                seen_stack_size = ((seen_stack_size + align - 1) & -align) + size;\n                break;\n                \n            case x86_64_mode_integer:\n                if (seen_reg_num + reg_count > REGN)\n\t\t    goto stack_arg;\n\t\tseen_reg_num += reg_count;\n                break;\n                \n            case x86_64_mode_sse:\n                if (seen_sse_num + reg_count > 8)\n\t\t    goto stack_arg;\n\t\tseen_sse_num += reg_count;\n                break;\n            }\n        }\n\n        loc -= 24;\n        /* movl $0x????????, -0x18(%rbp) */\n        o(0xe845c7);\n        gen_le32(seen_reg_num * 8);\n        /* movl $0x????????, -0x14(%rbp) */\n        o(0xec45c7);\n        gen_le32(seen_sse_num * 16 + 48);\n\t/* leaq $0x????????, %r11 */\n\to(0x9d8d4c);\n\tgen_le32(seen_stack_size);\n\t/* movq %r11, -0x10(%rbp) */\n\to(0xf05d894c);\n\t/* leaq $-192(%rbp), %r11 */\n\to(0x9d8d4c);\n\tgen_le32(-176 - 24);\n\t/* movq %r11, -0x8(%rbp) */\n\to(0xf85d894c);\n\n        /* save all register passing arguments */\n        for (i = 0; i < 8; i++) {\n            loc -= 16;\n\t    if (!tcc_state->nosse) {\n\t\to(0xd60f66); /* movq */\n\t\tgen_modrm(7 - i, VT_LOCAL, NULL, loc);\n\t    }\n            /* movq $0, loc+8(%rbp) */\n            o(0x85c748);\n            gen_le32(loc + 8);\n            gen_le32(0);\n        }\n        for (i = 0; i < REGN; i++) {\n            push_arg_reg(REGN-1-i);\n        }\n    }\n\n    sym = func_type->ref;\n    reg_param_index = 0;\n    sse_param_index = 0;\n\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n    if (ret_mode == x86_64_mode_memory) {\n        push_arg_reg(reg_param_index);\n        func_vc = loc;\n        reg_param_index++;\n    }\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n        type = &sym->type;\n        mode = classify_x86_64_arg(type, NULL, &size, &align, &reg_count);\n        switch (mode) {\n        case x86_64_mode_sse:\n\t    if (tcc_state->nosse)\n\t        tcc_error(\"SSE disabled but floating point arguments used\");\n            if (sse_param_index + reg_count <= 8) {\n                /* save arguments passed by register */\n                loc -= reg_count * 8;\n                param_addr = loc;\n                for (i = 0; i < reg_count; ++i) {\n                    o(0xd60f66); /* movq */\n                    gen_modrm(sse_param_index, VT_LOCAL, NULL, param_addr + i*8);\n                    ++sse_param_index;\n                }\n            } else {\n                addr = (addr + align - 1) & -align;\n                param_addr = addr;\n                addr += size;\n            }\n            break;\n            \n        case x86_64_mode_memory:\n        case x86_64_mode_x87:\n            addr = (addr + align - 1) & -align;\n            param_addr = addr;\n            addr += size;\n            break;\n            \n        case x86_64_mode_integer: {\n            if (reg_param_index + reg_count <= REGN) {\n                /* save arguments passed by register */\n                loc -= reg_count * 8;\n                param_addr = loc;\n                for (i = 0; i < reg_count; ++i) {\n                    gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, param_addr + i*8);\n                    ++reg_param_index;\n                }\n            } else {\n                addr = (addr + align - 1) & -align;\n                param_addr = addr;\n                addr += size;\n            }\n            break;\n        }\n\tdefault: break; /* nothing to be done for x86_64_mode_none */\n        }\n        sym_push(sym->v & ~SYM_FIELD, type,\n                 VT_LOCAL | VT_LVAL, param_addr);\n    }\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_prolog();\n#endif\n}\n\n/* generate function epilog */\nvoid gfunc_epilog(void)\n{\n    int v, saved_ind;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (tcc_state->do_bounds_check)\n        gen_bounds_epilog();\n#endif\n    o(0xc9); /* leave */\n    if (func_ret_sub == 0) {\n        o(0xc3); /* ret */\n    } else {\n        o(0xc2); /* ret n */\n        g(func_ret_sub);\n        g(func_ret_sub >> 8);\n    }\n    /* align local size to word & save local variables */\n    v = (-loc + 15) & -16;\n    saved_ind = ind;\n    ind = func_sub_sp_offset - FUNC_PROLOG_SIZE;\n    o(0xe5894855);  /* push %rbp, mov %rsp, %rbp */\n    o(0xec8148);  /* sub rsp, stacksize */\n    gen_le32(v);\n    ind = saved_ind;\n}\n\n#endif /* not PE */\n\nST_FUNC void gen_fill_nops(int bytes)\n{\n    while (bytes--)\n      g(0x90);\n}\n\n/* generate a jump to a label */\nint gjmp(int t)\n{\n    return gjmp2(0xe9, t);\n}\n\n/* generate a jump to a fixed address */\nvoid gjmp_addr(int a)\n{\n    int r;\n    r = a - ind - 2;\n    if (r == (char)r) {\n        g(0xeb);\n        g(r);\n    } else {\n        oad(0xe9, a - ind - 5);\n    }\n}\n\nST_FUNC int gjmp_append(int n, int t)\n{\n    void *p;\n    /* insert vtop->c jump list in t */\n    if (n) {\n        uint32_t n1 = n, n2;\n        while ((n2 = read32le(p = cur_text_section->data + n1)))\n            n1 = n2;\n        write32le(p, t);\n        t = n;\n    }\n    return t;\n}\n\nST_FUNC int gjmp_cond(int op, int t)\n{\n        if (op & 0x100)\n\t  {\n\t    /* This was a float compare.  If the parity flag is set\n\t       the result was unordered.  For anything except != this\n\t       means false and we don't jump (anding both conditions).\n\t       For != this means true (oring both).\n\t       Take care about inverting the test.  We need to jump\n\t       to our target if the result was unordered and test wasn't NE,\n\t       otherwise if unordered we don't want to jump.  */\n            int v = vtop->cmp_r;\n            op &= ~0x100;\n            if (op ^ v ^ (v != TOK_NE))\n              o(0x067a);  /* jp +6 */\n\t    else\n\t      {\n\t        g(0x0f);\n\t\tt = gjmp2(0x8a, t); /* jp t */\n\t      }\n\t  }\n        g(0x0f);\n        t = gjmp2(op - 16, t);\n        return t;\n}\n\n/* generate an integer binary operation */\nvoid gen_opi(int op)\n{\n    int r, fr, opc, c;\n    int ll, uu, cc;\n\n    ll = is64_type(vtop[-1].type.t);\n    uu = (vtop[-1].type.t & VT_UNSIGNED) != 0;\n    cc = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n\n    switch(op) {\n    case '+':\n    case TOK_ADDC1: /* add with carry generation */\n        opc = 0;\n    gen_op8:\n        if (cc && (!ll || (int)vtop->c.i == vtop->c.i)) {\n            /* constant case */\n            vswap();\n            r = gv(RC_INT);\n            vswap();\n            c = vtop->c.i;\n            if (c == (char)c) {\n                /* XXX: generate inc and dec for smaller code ? */\n                orex(ll, r, 0, 0x83);\n                o(0xc0 | (opc << 3) | REG_VALUE(r));\n                g(c);\n            } else {\n                orex(ll, r, 0, 0x81);\n                oad(0xc0 | (opc << 3) | REG_VALUE(r), c);\n            }\n        } else {\n            gv2(RC_INT, RC_INT);\n            r = vtop[-1].r;\n            fr = vtop[0].r;\n            orex(ll, r, fr, (opc << 3) | 0x01);\n            o(0xc0 + REG_VALUE(r) + REG_VALUE(fr) * 8);\n        }\n        vtop--;\n        if (op >= TOK_ULT && op <= TOK_GT)\n            vset_VT_CMP(op);\n        break;\n    case '-':\n    case TOK_SUBC1: /* sub with carry generation */\n        opc = 5;\n        goto gen_op8;\n    case TOK_ADDC2: /* add with carry use */\n        opc = 2;\n        goto gen_op8;\n    case TOK_SUBC2: /* sub with carry use */\n        opc = 3;\n        goto gen_op8;\n    case '&':\n        opc = 4;\n        goto gen_op8;\n    case '^':\n        opc = 6;\n        goto gen_op8;\n    case '|':\n        opc = 1;\n        goto gen_op8;\n    case '*':\n        gv2(RC_INT, RC_INT);\n        r = vtop[-1].r;\n        fr = vtop[0].r;\n        orex(ll, fr, r, 0xaf0f); /* imul fr, r */\n        o(0xc0 + REG_VALUE(fr) + REG_VALUE(r) * 8);\n        vtop--;\n        break;\n    case TOK_SHL:\n        opc = 4;\n        goto gen_shift;\n    case TOK_SHR:\n        opc = 5;\n        goto gen_shift;\n    case TOK_SAR:\n        opc = 7;\n    gen_shift:\n        opc = 0xc0 | (opc << 3);\n        if (cc) {\n            /* constant case */\n            vswap();\n            r = gv(RC_INT);\n            vswap();\n            orex(ll, r, 0, 0xc1); /* shl/shr/sar $xxx, r */\n            o(opc | REG_VALUE(r));\n            g(vtop->c.i & (ll ? 63 : 31));\n        } else {\n            /* we generate the shift in ecx */\n            gv2(RC_INT, RC_RCX);\n            r = vtop[-1].r;\n            orex(ll, r, 0, 0xd3); /* shl/shr/sar %cl, r */\n            o(opc | REG_VALUE(r));\n        }\n        vtop--;\n        break;\n    case TOK_UDIV:\n    case TOK_UMOD:\n        uu = 1;\n        goto divmod;\n    case '/':\n    case '%':\n    case TOK_PDIV:\n        uu = 0;\n    divmod:\n        /* first operand must be in eax */\n        /* XXX: need better constraint for second operand */\n        gv2(RC_RAX, RC_RCX);\n        r = vtop[-1].r;\n        fr = vtop[0].r;\n        vtop--;\n        save_reg(TREG_RDX);\n        orex(ll, 0, 0, uu ? 0xd231 : 0x99); /* xor %edx,%edx : cqto */\n        orex(ll, fr, 0, 0xf7); /* div fr, %eax */\n        o((uu ? 0xf0 : 0xf8) + REG_VALUE(fr));\n        if (op == '%' || op == TOK_UMOD)\n            r = TREG_RDX;\n        else\n            r = TREG_RAX;\n        vtop->r = r;\n        break;\n    default:\n        opc = 7;\n        goto gen_op8;\n    }\n}\n\nvoid gen_opl(int op)\n{\n    gen_opi(op);\n}\n\nvoid vpush_const(int t, int v)\n{\n    CType ctype = { t | VT_CONSTANT, 0 };\n    vpushsym(&ctype, external_global_sym(v, &ctype));\n    vtop->r |= VT_LVAL;\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranteed to have the same floating point type */\n/* XXX: need to use ST1 too */\nvoid gen_opf(int op)\n{\n    int a, ft, fc, swapped, r;\n    int bt = vtop->type.t & VT_BTYPE;\n    int float_type = bt == VT_LDOUBLE ? RC_ST0 : RC_FLOAT;\n\n    if (op == TOK_NEG) { /* unary minus */\n        gv(float_type);\n        if (float_type == RC_ST0) {\n            o(0xe0d9); /* fchs */\n        } else {\n            /* -0.0, in libtcc1.c */\n            vpush_const(bt, bt == VT_FLOAT ? TOK___mzerosf : TOK___mzerodf);\n            gv(RC_FLOAT);\n            if (bt == VT_DOUBLE)\n                o(0x66);\n            /* xorp[sd] %xmm1, %xmm0 */\n            o(0xc0570f | (REG_VALUE(vtop[0].r) + REG_VALUE(vtop[-1].r)*8) << 16);\n            vtop--;\n        }\n        return;\n    }\n\n    /* convert constants to memory references */\n    if ((vtop[-1].r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n        vswap();\n        gv(float_type);\n        vswap();\n    }\n    if ((vtop[0].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)\n        gv(float_type);\n\n    /* must put at least one value in the floating point register */\n    if ((vtop[-1].r & VT_LVAL) &&\n        (vtop[0].r & VT_LVAL)) {\n        vswap();\n        gv(float_type);\n        vswap();\n    }\n    swapped = 0;\n    /* swap the stack if needed so that t1 is the register and t2 is\n       the memory reference */\n    if (vtop[-1].r & VT_LVAL) {\n        vswap();\n        swapped = 1;\n    }\n    if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE) {\n        if (op >= TOK_ULT && op <= TOK_GT) {\n            /* load on stack second operand */\n            load(TREG_ST0, vtop);\n            save_reg(TREG_RAX); /* eax is used by FP comparison code */\n            if (op == TOK_GE || op == TOK_GT)\n                swapped = !swapped;\n            else if (op == TOK_EQ || op == TOK_NE)\n                swapped = 0;\n            if (swapped)\n                o(0xc9d9); /* fxch %st(1) */\n            if (op == TOK_EQ || op == TOK_NE)\n                o(0xe9da); /* fucompp */\n            else\n                o(0xd9de); /* fcompp */\n            o(0xe0df); /* fnstsw %ax */\n            if (op == TOK_EQ) {\n                o(0x45e480); /* and $0x45, %ah */\n                o(0x40fC80); /* cmp $0x40, %ah */\n            } else if (op == TOK_NE) {\n                o(0x45e480); /* and $0x45, %ah */\n                o(0x40f480); /* xor $0x40, %ah */\n                op = TOK_NE;\n            } else if (op == TOK_GE || op == TOK_LE) {\n                o(0x05c4f6); /* test $0x05, %ah */\n                op = TOK_EQ;\n            } else {\n                o(0x45c4f6); /* test $0x45, %ah */\n                op = TOK_EQ;\n            }\n            vtop--;\n            vset_VT_CMP(op);\n        } else {\n            /* no memory reference possible for long double operations */\n            load(TREG_ST0, vtop);\n            swapped = !swapped;\n\n            switch(op) {\n            default:\n            case '+':\n                a = 0;\n                break;\n            case '-':\n                a = 4;\n                if (swapped)\n                    a++;\n                break;\n            case '*':\n                a = 1;\n                break;\n            case '/':\n                a = 6;\n                if (swapped)\n                    a++;\n                break;\n            }\n            ft = vtop->type.t;\n            fc = vtop->c.i;\n            o(0xde); /* fxxxp %st, %st(1) */\n            o(0xc1 + (a << 3));\n            vtop--;\n        }\n    } else {\n        if (op >= TOK_ULT && op <= TOK_GT) {\n            /* if saved lvalue, then we must reload it */\n            r = vtop->r;\n            fc = vtop->c.i;\n            if ((r & VT_VALMASK) == VT_LLOCAL) {\n                SValue v1;\n                r = get_reg(RC_INT);\n                v1.type.t = VT_PTR;\n                v1.r = VT_LOCAL | VT_LVAL;\n                v1.c.i = fc;\n                load(r, &v1);\n                fc = 0;\n                vtop->r = r = r | VT_LVAL;\n            }\n\n            if (op == TOK_EQ || op == TOK_NE) {\n                swapped = 0;\n            } else {\n                if (op == TOK_LE || op == TOK_LT)\n                    swapped = !swapped;\n                if (op == TOK_LE || op == TOK_GE) {\n                    op = 0x93; /* setae */\n                } else {\n                    op = 0x97; /* seta */\n                }\n            }\n\n            if (swapped) {\n                gv(RC_FLOAT);\n                vswap();\n            }\n            assert(!(vtop[-1].r & VT_LVAL));\n            \n            if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)\n                o(0x66);\n            if (op == TOK_EQ || op == TOK_NE)\n                o(0x2e0f); /* ucomisd */\n            else\n                o(0x2f0f); /* comisd */\n\n            if (vtop->r & VT_LVAL) {\n                gen_modrm(vtop[-1].r, r, vtop->sym, fc);\n            } else {\n                o(0xc0 + REG_VALUE(vtop[0].r) + REG_VALUE(vtop[-1].r)*8);\n            }\n\n            vtop--;\n            vset_VT_CMP(op | 0x100);\n            vtop->cmp_r = op;\n        } else {\n            assert((vtop->type.t & VT_BTYPE) != VT_LDOUBLE);\n            switch(op) {\n            default:\n            case '+':\n                a = 0;\n                break;\n            case '-':\n                a = 4;\n                break;\n            case '*':\n                a = 1;\n                break;\n            case '/':\n                a = 6;\n                break;\n            }\n            ft = vtop->type.t;\n            fc = vtop->c.i;\n            assert((ft & VT_BTYPE) != VT_LDOUBLE);\n            \n            r = vtop->r;\n            /* if saved lvalue, then we must reload it */\n            if ((vtop->r & VT_VALMASK) == VT_LLOCAL) {\n                SValue v1;\n                r = get_reg(RC_INT);\n                v1.type.t = VT_PTR;\n                v1.r = VT_LOCAL | VT_LVAL;\n                v1.c.i = fc;\n                load(r, &v1);\n                fc = 0;\n                vtop->r = r = r | VT_LVAL;\n            }\n            \n            assert(!(vtop[-1].r & VT_LVAL));\n            if (swapped) {\n                assert(vtop->r & VT_LVAL);\n                gv(RC_FLOAT);\n                vswap();\n                fc = vtop->c.i; /* bcheck may have saved previous vtop[-1] */\n            }\n            \n            if ((ft & VT_BTYPE) == VT_DOUBLE) {\n                o(0xf2);\n            } else {\n                o(0xf3);\n            }\n            o(0x0f);\n            o(0x58 + a);\n            \n            if (vtop->r & VT_LVAL) {\n                gen_modrm(vtop[-1].r, r, vtop->sym, fc);\n            } else {\n                o(0xc0 + REG_VALUE(vtop[0].r) + REG_VALUE(vtop[-1].r)*8);\n            }\n\n            vtop--;\n        }\n    }\n}\n\n/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\nvoid gen_cvt_itof(int t)\n{\n    if ((t & VT_BTYPE) == VT_LDOUBLE) {\n        save_reg(TREG_ST0);\n        gv(RC_INT);\n        if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n            /* signed long long to float/double/long double (unsigned case\n               is handled generically) */\n            o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n            o(0x242cdf); /* fildll (%rsp) */\n            o(0x08c48348); /* add $8, %rsp */\n        } else if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) ==\n                   (VT_INT | VT_UNSIGNED)) {\n            /* unsigned int to float/double/long double */\n            o(0x6a); /* push $0 */\n            g(0x00);\n            o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n            o(0x242cdf); /* fildll (%rsp) */\n            o(0x10c48348); /* add $16, %rsp */\n        } else {\n            /* int to float/double/long double */\n            o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n            o(0x2404db); /* fildl (%rsp) */\n            o(0x08c48348); /* add $8, %rsp */\n        }\n        vtop->r = TREG_ST0;\n    } else {\n        int r = get_reg(RC_FLOAT);\n        gv(RC_INT);\n        o(0xf2 + ((t & VT_BTYPE) == VT_FLOAT?1:0));\n        if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) ==\n            (VT_INT | VT_UNSIGNED) ||\n            (vtop->type.t & VT_BTYPE) == VT_LLONG) {\n            o(0x48); /* REX */\n        }\n        o(0x2a0f);\n        o(0xc0 + (vtop->r & VT_VALMASK) + REG_VALUE(r)*8); /* cvtsi2sd */\n        vtop->r = r;\n    }\n}\n\n/* convert from one floating point type to another */\nvoid gen_cvt_ftof(int t)\n{\n    int ft, bt, tbt;\n\n    ft = vtop->type.t;\n    bt = ft & VT_BTYPE;\n    tbt = t & VT_BTYPE;\n    \n    if (bt == VT_FLOAT) {\n        gv(RC_FLOAT);\n        if (tbt == VT_DOUBLE) {\n            o(0x140f); /* unpcklps */\n            o(0xc0 + REG_VALUE(vtop->r)*9);\n            o(0x5a0f); /* cvtps2pd */\n            o(0xc0 + REG_VALUE(vtop->r)*9);\n        } else if (tbt == VT_LDOUBLE) {\n            save_reg(RC_ST0);\n            /* movss %xmm0,-0x10(%rsp) */\n            o(0x110ff3);\n            o(0x44 + REG_VALUE(vtop->r)*8);\n            o(0xf024);\n            o(0xf02444d9); /* flds -0x10(%rsp) */\n            vtop->r = TREG_ST0;\n        }\n    } else if (bt == VT_DOUBLE) {\n        gv(RC_FLOAT);\n        if (tbt == VT_FLOAT) {\n            o(0x140f66); /* unpcklpd */\n            o(0xc0 + REG_VALUE(vtop->r)*9);\n            o(0x5a0f66); /* cvtpd2ps */\n            o(0xc0 + REG_VALUE(vtop->r)*9);\n        } else if (tbt == VT_LDOUBLE) {\n            save_reg(RC_ST0);\n            /* movsd %xmm0,-0x10(%rsp) */\n            o(0x110ff2);\n            o(0x44 + REG_VALUE(vtop->r)*8);\n            o(0xf024);\n            o(0xf02444dd); /* fldl -0x10(%rsp) */\n            vtop->r = TREG_ST0;\n        }\n    } else {\n        int r;\n        gv(RC_ST0);\n        r = get_reg(RC_FLOAT);\n        if (tbt == VT_DOUBLE) {\n            o(0xf0245cdd); /* fstpl -0x10(%rsp) */\n            /* movsd -0x10(%rsp),%xmm0 */\n            o(0x100ff2);\n            o(0x44 + REG_VALUE(r)*8);\n            o(0xf024);\n            vtop->r = r;\n        } else if (tbt == VT_FLOAT) {\n            o(0xf0245cd9); /* fstps -0x10(%rsp) */\n            /* movss -0x10(%rsp),%xmm0 */\n            o(0x100ff3);\n            o(0x44 + REG_VALUE(r)*8);\n            o(0xf024);\n            vtop->r = r;\n        }\n    }\n}\n\n/* convert fp to int 't' type */\nvoid gen_cvt_ftoi(int t)\n{\n    int ft, bt, size, r;\n    ft = vtop->type.t;\n    bt = ft & VT_BTYPE;\n    if (bt == VT_LDOUBLE) {\n        gen_cvt_ftof(VT_DOUBLE);\n        bt = VT_DOUBLE;\n    }\n\n    gv(RC_FLOAT);\n    if (t != VT_INT)\n        size = 8;\n    else\n        size = 4;\n\n    r = get_reg(RC_INT);\n    if (bt == VT_FLOAT) {\n        o(0xf3);\n    } else if (bt == VT_DOUBLE) {\n        o(0xf2);\n    } else {\n        assert(0);\n    }\n    orex(size == 8, r, 0, 0x2c0f); /* cvttss2si or cvttsd2si */\n    o(0xc0 + REG_VALUE(vtop->r) + REG_VALUE(r)*8);\n    vtop->r = r;\n}\n\n// Generate sign extension from 32 to 64 bits:\nST_FUNC void gen_cvt_sxtw(void)\n{\n    int r = gv(RC_INT);\n    /* x86_64 specific: movslq */\n    o(0x6348);\n    o(0xc0 + (REG_VALUE(r) << 3) + REG_VALUE(r));\n}\n\n/* char/short to int conversion */\nST_FUNC void gen_cvt_csti(int t)\n{\n    int r, sz, xl, ll;\n    r = gv(RC_INT);\n    sz = !(t & VT_UNSIGNED);\n    xl = (t & VT_BTYPE) == VT_SHORT;\n    ll = (vtop->type.t & VT_BTYPE) == VT_LLONG;\n    orex(ll, r, 0, 0xc0b60f /* mov[sz] %a[xl], %eax */\n        | (sz << 3 | xl) << 8\n        | (REG_VALUE(r) << 3 | REG_VALUE(r)) << 16\n        );\n}\n\n/* increment tcov counter */\nST_FUNC void gen_increment_tcov (SValue *sv)\n{\n   o(0x058348); /* addq $1, xxx(%rip) */\n   greloca(cur_text_section, sv->sym, ind, R_X86_64_PC32, -5);\n   gen_le32(0);\n   o(1);\n}\n\n/* computed goto support */\nST_FUNC void ggoto(void)\n{\n    gcall_or_jmp(1);\n    vtop--;\n}\n\n/* Save the stack pointer onto the stack and return the location of its address */\nST_FUNC void gen_vla_sp_save(int addr) {\n    /* mov %rsp,addr(%rbp)*/\n    gen_modrm64(0x89, TREG_RSP, VT_LOCAL, NULL, addr);\n}\n\n/* Restore the SP from a location on the stack */\nST_FUNC void gen_vla_sp_restore(int addr) {\n    gen_modrm64(0x8b, TREG_RSP, VT_LOCAL, NULL, addr);\n}\n\n#ifdef TCC_TARGET_PE\n/* Save result of gen_vla_alloc onto the stack */\nST_FUNC void gen_vla_result(int addr) {\n    /* mov %rax,addr(%rbp)*/\n    gen_modrm64(0x89, TREG_RAX, VT_LOCAL, NULL, addr);\n}\n#endif\n\n/* Subtract from the stack pointer, and push the resulting value onto the stack */\nST_FUNC void gen_vla_alloc(CType *type, int align) {\n    int use_call = 0;\n\n#if defined(CONFIG_TCC_BCHECK)\n    use_call = tcc_state->do_bounds_check;\n#endif\n#ifdef TCC_TARGET_PE\t/* alloca does more than just adjust %rsp on Windows */\n    use_call = 1;\n#endif\n    if (use_call)\n    {\n        vpush_helper_func(TOK_alloca);\n        vswap(); /* Move alloca ref past allocation size */\n        gfunc_call(1);\n    }\n    else {\n        int r;\n        r = gv(RC_INT); /* allocation size */\n        /* sub r,%rsp */\n        o(0x2b48);\n        o(0xe0 | REG_VALUE(r));\n        /* We align to 16 bytes rather than align */\n        /* and ~15, %rsp */\n        o(0xf0e48348);\n        vpop();\n    }\n}\n\n/*\n * Assmuing the top part of the stack looks like below,\n *  src dest src\n */\nST_FUNC void gen_struct_copy(int size)\n{\n    int n = size / PTR_SIZE;\n#ifdef TCC_TARGET_PE\n    o(0x5756); /* push rsi, rdi */\n#endif\n    gv2(RC_RDI, RC_RSI);\n    if (n <= 4) {\n        while (n)\n            o(0xa548), --n;\n    } else {\n        vpushi(n);\n        gv(RC_RCX);\n        o(0xa548f3);\n        vpop();\n    }\n    if (size & 0x04)\n        o(0xa5);\n    if (size & 0x02)\n        o(0xa566);\n    if (size & 0x01)\n        o(0xa4);\n#ifdef TCC_TARGET_PE\n    o(0x5e5f); /* pop rdi, rsi */\n#endif\n    vpop();\n    vpop();\n}\n\n/* end of x86-64 code generator */\n/*************************************************************/\n#endif /* ! TARGET_DEFS_ONLY */\n/******************************************************/\n"
        },
        {
          "name": "x86_64-link.c",
          "type": "blob",
          "size": 12.88671875,
          "content": "#ifdef TARGET_DEFS_ONLY\n\n#define EM_TCC_TARGET EM_X86_64\n\n/* relocation type for 32 bit data relocation */\n#define R_DATA_32   R_X86_64_32S\n#define R_DATA_PTR  R_X86_64_64\n#define R_JMP_SLOT  R_X86_64_JUMP_SLOT\n#define R_GLOB_DAT  R_X86_64_GLOB_DAT\n#define R_COPY      R_X86_64_COPY\n#define R_RELATIVE  R_X86_64_RELATIVE\n\n#define R_NUM       R_X86_64_NUM\n\n#define ELF_START_ADDR 0x400000\n#define ELF_PAGE_SIZE  0x200000\n\n#define PCRELATIVE_DLLPLT 1\n#define RELOCATE_DLLPLT 1\n\n#else /* !TARGET_DEFS_ONLY */\n\n#include \"tcc.h\"\n\n#ifdef NEED_RELOC_TYPE\n/* Returns 1 for a code relocation, 0 for a data relocation. For unknown\n   relocations, returns -1. */\nST_FUNC int code_reloc (int reloc_type)\n{\n    switch (reloc_type) {\n        case R_X86_64_32:\n        case R_X86_64_32S:\n        case R_X86_64_64:\n        case R_X86_64_GOTPC32:\n        case R_X86_64_GOTPC64:\n        case R_X86_64_GOTPCREL:\n        case R_X86_64_GOTPCRELX:\n        case R_X86_64_REX_GOTPCRELX:\n        case R_X86_64_GOTTPOFF:\n        case R_X86_64_GOT32:\n        case R_X86_64_GOT64:\n        case R_X86_64_GLOB_DAT:\n        case R_X86_64_COPY:\n        case R_X86_64_RELATIVE:\n        case R_X86_64_GOTOFF64:\n        case R_X86_64_TLSGD:\n        case R_X86_64_TLSLD:\n        case R_X86_64_DTPOFF32:\n        case R_X86_64_TPOFF32:\n        case R_X86_64_DTPOFF64:\n        case R_X86_64_TPOFF64:\n            return 0;\n\n        case R_X86_64_PC32:\n        case R_X86_64_PC64:\n        case R_X86_64_PLT32:\n        case R_X86_64_PLTOFF64:\n        case R_X86_64_JUMP_SLOT:\n            return 1;\n    }\n    return -1;\n}\n\n/* Returns an enumerator to describe whether and when the relocation needs a\n   GOT and/or PLT entry to be created. See tcc.h for a description of the\n   different values. */\nST_FUNC int gotplt_entry_type (int reloc_type)\n{\n    switch (reloc_type) {\n        case R_X86_64_GLOB_DAT:\n        case R_X86_64_JUMP_SLOT:\n        case R_X86_64_COPY:\n        case R_X86_64_RELATIVE:\n            return NO_GOTPLT_ENTRY;\n\n\t/* The following relocs wouldn't normally need GOT or PLT\n\t   slots, but we need them for simplicity in the link\n\t   editor part.  See our caller for comments.  */\n        case R_X86_64_32:\n        case R_X86_64_32S:\n        case R_X86_64_64:\n        case R_X86_64_PC32:\n        case R_X86_64_PC64:\n            return AUTO_GOTPLT_ENTRY;\n\n        case R_X86_64_GOTTPOFF:\n            return BUILD_GOT_ONLY;\n\n        case R_X86_64_GOT32:\n        case R_X86_64_GOT64:\n        case R_X86_64_GOTPC32:\n        case R_X86_64_GOTPC64:\n        case R_X86_64_GOTOFF64:\n        case R_X86_64_GOTPCREL:\n        case R_X86_64_GOTPCRELX:\n        case R_X86_64_TLSGD:\n        case R_X86_64_TLSLD:\n        case R_X86_64_DTPOFF32:\n        case R_X86_64_TPOFF32:\n        case R_X86_64_DTPOFF64:\n        case R_X86_64_TPOFF64:\n        case R_X86_64_REX_GOTPCRELX:\n        case R_X86_64_PLT32:\n        case R_X86_64_PLTOFF64:\n            return ALWAYS_GOTPLT_ENTRY;\n    }\n\n    return -1;\n}\n\n#ifdef NEED_BUILD_GOT\nST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)\n{\n    Section *plt = s1->plt;\n    uint8_t *p;\n    int modrm;\n    unsigned plt_offset, relofs;\n\n    modrm = 0x25;\n\n    /* empty PLT: create PLT0 entry that pushes the library identifier\n       (GOT + PTR_SIZE) and jumps to ld.so resolution routine\n       (GOT + 2 * PTR_SIZE) */\n    if (plt->data_offset == 0) {\n        p = section_ptr_add(plt, 16);\n        p[0] = 0xff; /* pushl got + PTR_SIZE */\n        p[1] = modrm + 0x10;\n        write32le(p + 2, PTR_SIZE);\n        p[6] = 0xff; /* jmp *(got + PTR_SIZE * 2) */\n        p[7] = modrm;\n        write32le(p + 8, PTR_SIZE * 2);\n    }\n    plt_offset = plt->data_offset;\n\n    /* The PLT slot refers to the relocation entry it needs via offset.\n       The reloc entry is created below, so its offset is the current\n       data_offset */\n    relofs = s1->plt->reloc ? s1->plt->reloc->data_offset : 0;\n\n    /* Jump to GOT entry where ld.so initially put the address of ip + 4 */\n    p = section_ptr_add(plt, 16);\n    p[0] = 0xff; /* jmp *(got + x) */\n    p[1] = modrm;\n    write32le(p + 2, got_offset);\n    p[6] = 0x68; /* push $xxx */\n    /* On x86-64, the relocation is referred to by _index_ */\n    write32le(p + 7, relofs / sizeof (ElfW_Rel) - 1);\n    p[11] = 0xe9; /* jmp plt_start */\n    write32le(p + 12, -(plt->data_offset));\n    return plt_offset;\n}\n\n/* relocate the PLT: compute addresses and offsets in the PLT now that final\n   address for PLT and GOT are known (see fill_program_header) */\nST_FUNC void relocate_plt(TCCState *s1)\n{\n    uint8_t *p, *p_end;\n\n    if (!s1->plt)\n      return;\n\n    p = s1->plt->data;\n    p_end = p + s1->plt->data_offset;\n\n    if (p < p_end) {\n        int x = s1->got->sh_addr - s1->plt->sh_addr - 6;\n        add32le(p + 2, x);\n        add32le(p + 8, x - 6);\n        p += 16;\n        while (p < p_end) {\n            add32le(p + 2, x + (s1->plt->data - p));\n            p += 16;\n        }\n    }\n\n    if (s1->plt->reloc) {\n        ElfW_Rel *rel;\n        int x = s1->plt->sh_addr + 16 + 6;\n        p = s1->got->data;\n        for_each_elem(s1->plt->reloc, 0, rel, ElfW_Rel) {\n            write64le(p + rel->r_offset, x);\n            x += 16;\n        }\n    }\n}\n#endif\n#endif\n\nST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)\n{\n    int sym_index, esym_index;\n\n    sym_index = ELFW(R_SYM)(rel->r_info);\n\n    switch (type) {\n        case R_X86_64_64:\n            if (s1->output_type & TCC_OUTPUT_DYN) {\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                qrel->r_offset = rel->r_offset;\n                if (esym_index) {\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_X86_64_64);\n                    qrel->r_addend = rel->r_addend;\n                    qrel++;\n                    break;\n                } else {\n                    qrel->r_info = ELFW(R_INFO)(0, R_X86_64_RELATIVE);\n                    qrel->r_addend = read64le(ptr) + val;\n                    qrel++;\n                }\n            }\n            add64le(ptr, val);\n            break;\n        case R_X86_64_32:\n        case R_X86_64_32S:\n            if (s1->output_type & TCC_OUTPUT_DYN) {\n                /* XXX: this logic may depend on TCC's codegen\n                   now TCC uses R_X86_64_32 even for a 64bit pointer */\n                qrel->r_offset = rel->r_offset;\n                qrel->r_info = ELFW(R_INFO)(0, R_X86_64_RELATIVE);\n                /* Use sign extension! */\n                qrel->r_addend = (int)read32le(ptr) + val;\n                qrel++;\n            }\n            add32le(ptr, val);\n            break;\n\n        case R_X86_64_PC32:\n            if (s1->output_type == TCC_OUTPUT_DLL) {\n                /* DLL relocation */\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                if (esym_index) {\n                    qrel->r_offset = rel->r_offset;\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_X86_64_PC32);\n                    /* Use sign extension! */\n                    qrel->r_addend = (int)read32le(ptr) + rel->r_addend;\n                    qrel++;\n                    break;\n                }\n            }\n            goto plt32pc32;\n\n        case R_X86_64_PLT32:\n            /* fallthrough: val already holds the PLT slot address */\n\n        plt32pc32:\n        {\n            long long diff;\n            diff = (long long)val - addr;\n            if (diff < -2147483648LL || diff > 2147483647LL) {\n#ifdef TCC_TARGET_PE\n              /* ignore overflow with undefined weak symbols */\n              if (((ElfW(Sym)*)symtab_section->data)[sym_index].st_shndx != SHN_UNDEF)\n#endif\n                tcc_error_noabort(\"internal error: relocation failed\");\n            }\n            add32le(ptr, diff);\n        }\n            break;\n\n        case R_X86_64_COPY:\n\t    break;\n\n        case R_X86_64_PLTOFF64:\n            add64le(ptr, val - s1->got->sh_addr + rel->r_addend);\n            break;\n\n        case R_X86_64_PC64:\n            if (s1->output_type == TCC_OUTPUT_DLL) {\n                /* DLL relocation */\n                esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;\n                if (esym_index) {\n                    qrel->r_offset = rel->r_offset;\n                    qrel->r_info = ELFW(R_INFO)(esym_index, R_X86_64_PC64);\n                    qrel->r_addend = read64le(ptr) + rel->r_addend;\n                    qrel++;\n                    break;\n                }\n            }\n            add64le(ptr, val - addr);\n            break;\n\n        case R_X86_64_GLOB_DAT:\n        case R_X86_64_JUMP_SLOT:\n            /* They don't need addend */\n            write64le(ptr, val - rel->r_addend);\n            break;\n        case R_X86_64_GOTPCREL:\n        case R_X86_64_GOTPCRELX:\n        case R_X86_64_REX_GOTPCRELX:\n            add32le(ptr, s1->got->sh_addr - addr +\n                         get_sym_attr(s1, sym_index, 0)->got_offset - 4);\n            break;\n        case R_X86_64_GOTPC32:\n            add32le(ptr, s1->got->sh_addr - addr + rel->r_addend);\n            break;\n        case R_X86_64_GOTPC64:\n            add64le(ptr, s1->got->sh_addr - addr + rel->r_addend);\n            break;\n        case R_X86_64_GOTTPOFF:\n            add32le(ptr, val - s1->got->sh_addr);\n            break;\n        case R_X86_64_GOT32:\n            /* we load the got offset */\n            add32le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);\n            break;\n        case R_X86_64_GOT64:\n            /* we load the got offset */\n            add64le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);\n            break;\n        case R_X86_64_GOTOFF64:\n            add64le(ptr, val - s1->got->sh_addr);\n            break;\n        case R_X86_64_TLSGD:\n            {\n                static const unsigned char expect[] = {\n                    /* .byte 0x66; lea 0(%rip),%rdi */\n                    0x66, 0x48, 0x8d, 0x3d, 0x00, 0x00, 0x00, 0x00,\n                    /* .word 0x6666; rex64; call __tls_get_addr@PLT */\n                    0x66, 0x66, 0x48, 0xe8, 0x00, 0x00, 0x00, 0x00 };\n                static const unsigned char replace[] = {\n                    /* mov %fs:0,%rax */\n                    0x64, 0x48, 0x8b, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00,\n                    /* lea -4(%rax),%rax */\n                    0x48, 0x8d, 0x80, 0x00, 0x00, 0x00, 0x00 };\n\n                if (memcmp (ptr-4, expect, sizeof(expect)) == 0) {\n                    ElfW(Sym) *sym;\n                    Section *sec;\n                    int32_t x;\n\n                    memcpy(ptr-4, replace, sizeof(replace));\n                    rel[1].r_info = ELFW(R_INFO)(0, R_X86_64_NONE);\n                    sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n                    sec = s1->sections[sym->st_shndx];\n                    x = sym->st_value - sec->sh_addr - sec->data_offset;\n                    add32le(ptr + 8, x);\n                }\n                else\n                    tcc_error_noabort(\"unexpected R_X86_64_TLSGD pattern\");\n            }\n            break;\n        case R_X86_64_TLSLD:\n            {\n                static const unsigned char expect[] = {\n                    /* lea 0(%rip),%rdi */\n                    0x48, 0x8d, 0x3d, 0x00, 0x00, 0x00, 0x00,\n                    /* call __tls_get_addr@PLT */\n                    0xe8, 0x00, 0x00, 0x00, 0x00 };\n                static const unsigned char replace[] = {\n                    /* data16 data16 data16 mov %fs:0,%rax */\n                    0x66, 0x66, 0x66, 0x64, 0x48, 0x8b, 0x04, 0x25,\n                    0x00, 0x00, 0x00, 0x00 };\n\n                if (memcmp (ptr-3, expect, sizeof(expect)) == 0) {\n                    memcpy(ptr-3, replace, sizeof(replace));\n                    rel[1].r_info = ELFW(R_INFO)(0, R_X86_64_NONE);\n                }\n                else\n                    tcc_error_noabort(\"unexpected R_X86_64_TLSLD pattern\");\n            }\n            break;\n        case R_X86_64_DTPOFF32:\n        case R_X86_64_TPOFF32:\n            {\n                ElfW(Sym) *sym;\n                Section *sec;\n                int32_t x;\n\n                sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n                sec = s1->sections[sym->st_shndx];\n                x = val - sec->sh_addr - sec->data_offset;\n                add32le(ptr, x);\n            }\n            break;\n        case R_X86_64_DTPOFF64:\n        case R_X86_64_TPOFF64:\n            {\n                ElfW(Sym) *sym;\n                Section *sec;\n                int32_t x;\n\n                sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];\n                sec = s1->sections[sym->st_shndx];\n                x = val - sec->sh_addr - sec->data_offset;\n                add64le(ptr, x);\n            }\n            break;\n        case R_X86_64_NONE:\n            break;\n        case R_X86_64_RELATIVE:\n#ifdef TCC_TARGET_PE\n            add32le(ptr, val - s1->pe_imagebase);\n#endif\n            /* do nothing */\n            break;\n        default:\n            fprintf(stderr,\"FIXME: handle reloc type %d at %x [%p] to %x\\n\",\n                type, (unsigned)addr, ptr, (unsigned)val);\n            break;\n    }\n}\n\n#endif /* !TARGET_DEFS_ONLY */\n"
        }
      ]
    }
  ]
}