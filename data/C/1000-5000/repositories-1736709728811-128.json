{
  "metadata": {
    "timestamp": 1736709728811,
    "page": 128,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cnlohr/rawdrawandroid",
      "stars": 3847,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.052734375,
          "content": "*.keystore\nmakecapk/\ncnfgtest.apk\nAndroidManifest.xml\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1474609375,
          "content": "[submodule \"rawdraw\"]\n\tpath = rawdraw\n\turl = https://github.com/cntools/rawdraw\n[submodule \"cnfa\"]\n\tpath = cnfa\n\turl = https://github.com/cntools/cnfa\n"
        },
        {
          "name": "AndroidManifest.xml.template",
          "type": "blob",
          "size": 1.0458984375,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n<manifest xmlns:tools=\"http://schemas.android.com/tools\" xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"${PACKAGENAME}\">\n\t<uses-sdk android:minSdkVersion=\"${ANDROIDVERSION}\"\n          android:targetSdkVersion=\"${ANDROIDTARGET}\" />\n    <uses-permission android:name=\"android.permission.SET_RELEASE_APP\"/>\n    <application android:debuggable=\"true\" android:hasCode=\"false\" android:label=\"${LABEL}\" tools:replace=\"android:icon,android:theme,android:allowBackup,label\" android:icon=\"@mipmap/icon\">\n        <activity android:configChanges=\"keyboardHidden|orientation\" android:label=\"${LABEL}\" android:name=\"android.app.NativeActivity\" android:exported=\"true\">\n            <meta-data android:name=\"android.app.lib_name\" android:value=\"${APPNAME}\"/>\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2020 <>< CNLohr\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 8.17578125,
          "content": "#Copyright (c) 2019-2020 <>< Charles Lohr - Under the MIT/x11 or NewBSD License you choose.\n# NO WARRANTY! NO GUARANTEE OF SUPPORT! USE AT YOUR OWN RISK\n\nall : makecapk.apk\n\n.PHONY : push run\n\n# WARNING WARNING WARNING!  YOU ABSOLUTELY MUST OVERRIDE THE PROJECT NAME\n# you should also override these parameters, get your own signatre file and make your own manifest.\nAPPNAME?=cnfgtest\nLABEL?=$(APPNAME)\nAPKFILE ?= $(APPNAME).apk\nPACKAGENAME?=org.yourorg.$(APPNAME)\nRAWDRAWANDROID?=.\nRAWDRAWANDROIDSRCS=$(RAWDRAWANDROID)/android_native_app_glue.c\nSRC?=test.c\n\n#We've tested it with android version 22, 24, 28, 29 and 30 and 32.\n#You can target something like Android 28, but if you set ANDROIDVERSION to say 22, then\n#Your app should (though not necessarily) support all the way back to Android 22. \nANDROIDVERSION?=30\nANDROIDTARGET?=$(ANDROIDVERSION)\nCFLAGS?=-ffunction-sections -Os -fdata-sections -Wall -fvisibility=hidden\nLDFLAGS?=-Wl,--gc-sections -Wl,-Map=output.map -s\nANDROID_FULLSCREEN?=y\nADB?=adb\nUNAME := $(shell uname)\n\n# For really tight compiles....\nCFLAGS += -fvisibility=hidden\nLDFLAGS += -s\n\n# For C++\n# LDFLAGS += -static-libstdc++\n# $(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/lib/aarch64-linux-android/libc.a\n\nANDROID_FULLSCREEN?=y\nADB?=adb\nUNAME := $(shell uname)\n\n\nANDROIDSRCS:= $(SRC) $(RAWDRAWANDROIDSRCS)\n\n#if you have a custom Android Home location you can add it to this list.  \n#This makefile will select the first present folder.\n\n\nifeq ($(UNAME), Linux)\nOS_NAME = linux-x86_64\nendif\nifeq ($(UNAME), Darwin)\nOS_NAME = darwin-x86_64\nendif\nifeq ($(OS), Windows_NT)\nOS_NAME = windows-x86_64\nendif\n\n# Search list for where to try to find the SDK\nSDK_LOCATIONS += $(ANDROID_HOME) $(ANDROID_SDK_ROOT) ~/Android/Sdk $(HOME)/Library/Android/sdk\n\n#Just a little Makefile witchcraft to find the first SDK_LOCATION that exists\n#Then find an ndk folder and build tools folder in there.\nANDROIDSDK?=$(firstword $(foreach dir, $(SDK_LOCATIONS), $(basename $(dir) ) ) )\nNDK?=$(firstword $(ANDROID_NDK) $(ANDROID_NDK_HOME) $(wildcard $(ANDROIDSDK)/ndk/*) $(wildcard $(ANDROIDSDK)/ndk-bundle/*) )\nBUILD_TOOLS?=$(lastword $(wildcard $(ANDROIDSDK)/build-tools/*) )\n\n# fall back to default Android SDL installation location if valid NDK was not found\nifeq ($(NDK),)\nANDROIDSDK := ~/Android/Sdk\nendif\n\n# Verify if directories are detected\nifeq ($(ANDROIDSDK),)\n$(error ANDROIDSDK directory not found)\nendif\nifeq ($(NDK),)\n$(error NDK directory not found)\nendif\nifeq ($(BUILD_TOOLS),)\n$(error BUILD_TOOLS directory not found)\nendif\n\nifneq (\"$(wildcard ./android-$(ANDROIDVERSION).jar)\",\"\")\nANDROID_JAR:=android-$(ANDROIDVERSION).jar\nelse\nANDROID_JAR:=$(ANDROIDSDK)/platforms/android-$(ANDROIDVERSION)/android.jar\nendif\n\nandroid-$(ANDROIDVERSION).jar :\n\twget https://github.com/Sable/android-platforms/raw/refs/heads/master/android-$(ANDROIDVERSION)/android.jar -O android-$(ANDROIDVERSION).jar\n\ntestsdk :\n\t@echo \"SDK:\\t\\t\" $(ANDROIDSDK)\n\t@echo \"NDK:\\t\\t\" $(NDK)\n\t@echo \"Build Tools:\\t\" $(BUILD_TOOLS)\n\nCFLAGS+=-Os -DANDROID -DAPPNAME=\\\"$(APPNAME)\\\"\nifeq (ANDROID_FULLSCREEN,y)\nCFLAGS +=-DANDROID_FULLSCREEN\nendif\nCFLAGS+= -I$(RAWDRAWANDROID)/rawdraw -I$(NDK)/sysroot/usr/include -I$(NDK)/sysroot/usr/include/android -I$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/include -I$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/include/android -fPIC -I$(RAWDRAWANDROID) -DANDROIDVERSION=$(ANDROIDVERSION)\nLDFLAGS += -lm -lGLESv3 -lEGL -landroid -llog -lOpenSLES\nLDFLAGS += -shared -uANativeActivity_onCreate\n\nCC_ARM64:=$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/bin/aarch64-linux-android$(ANDROIDVERSION)-clang\nCC_ARM32:=$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/bin/armv7a-linux-androideabi$(ANDROIDVERSION)-clang\nCC_x86:=$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/bin/i686-linux-android$(ANDROIDVERSION)-clang\nCC_x86_64=$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/bin/x86_64-linux-android$(ANDROIDVERSION)-clang\nAAPT:=$(BUILD_TOOLS)/aapt\n\n# Which binaries to build? Just comment/uncomment these lines:\nTARGETS += makecapk/lib/arm64-v8a/lib$(APPNAME).so\n#TARGETS += makecapk/lib/armeabi-v7a/lib$(APPNAME).so\n#TARGETS += makecapk/lib/x86/lib$(APPNAME).so\n#TARGETS += makecapk/lib/x86_64/lib$(APPNAME).so\n\nCFLAGS_ARM64:=-m64\nCFLAGS_ARM32:=-mfloat-abi=softfp -m32\nCFLAGS_x86:=-march=i686 -mssse3 -mfpmath=sse -m32\nCFLAGS_x86_64:=-march=x86-64 -msse4.2 -mpopcnt -m64\nSTOREPASS?=password\nDNAME:=\"CN=example.com, OU=ID, O=Example, L=Doe, S=John, C=GB\"\nKEYSTOREFILE:=my-release-key.keystore\nALIASNAME?=standkey\n\nkeystore : $(KEYSTOREFILE)\n\n$(KEYSTOREFILE) :\n\tkeytool -genkey -v -keystore $(KEYSTOREFILE) -alias $(ALIASNAME) -keyalg RSA -keysize 2048 -validity 10000 -storepass $(STOREPASS) -keypass $(STOREPASS) -dname $(DNAME)\n\nfolders:\n\tmkdir -p makecapk/lib/arm64-v8a\n\tmkdir -p makecapk/lib/armeabi-v7a\n\tmkdir -p makecapk/lib/x86\n\tmkdir -p makecapk/lib/x86_64\n\nmakecapk/lib/arm64-v8a/lib$(APPNAME).so : $(ANDROIDSRCS)\n\tmkdir -p makecapk/lib/arm64-v8a\n\t$(CC_ARM64) $(CFLAGS) $(CFLAGS_ARM64) -o $@ $^ -L$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/lib/aarch64-linux-android/$(ANDROIDVERSION) $(LDFLAGS)\n\nmakecapk/lib/armeabi-v7a/lib$(APPNAME).so : $(ANDROIDSRCS)\n\tmkdir -p makecapk/lib/armeabi-v7a\n\t$(CC_ARM32) $(CFLAGS) $(CFLAGS_ARM32) -o $@ $^ -L$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/lib/arm-linux-androideabi/$(ANDROIDVERSION) $(LDFLAGS)\n\nmakecapk/lib/x86/lib$(APPNAME).so : $(ANDROIDSRCS)\n\tmkdir -p makecapk/lib/x86\n\t$(CC_x86) $(CFLAGS) $(CFLAGS_x86) -o $@ $^ -L$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/lib/i686-linux-android/$(ANDROIDVERSION) $(LDFLAGS)\n\nmakecapk/lib/x86_64/lib$(APPNAME).so : $(ANDROIDSRCS)\n\tmkdir -p makecapk/lib/x86_64\n\t$(CC_x86) $(CFLAGS) $(CFLAGS_x86_64) -o $@ $^ -L$(NDK)/toolchains/llvm/prebuilt/$(OS_NAME)/sysroot/usr/lib/x86_64-linux-android/$(ANDROIDVERSION) $(LDFLAGS)\n\n#We're really cutting corners.  You should probably use resource files.. Replace android:label=\"@string/app_name\" and add a resource file.\n#Then do this -S Sources/res on the aapt line.\n#For icon support, add -S makecapk/res to the aapt line.  also,  android:icon=\"@mipmap/icon\" to your application line in the manifest.\n#If you want to strip out about 800 bytes of data you can remove the icon and strings.\n\n#Notes for the past:  These lines used to work, but don't seem to anymore.  Switched to newer jarsigner.\n#(zipalign -c -v 8 makecapk.apk)||true #This seems to not work well.\n#jarsigner -verify -verbose -certs makecapk.apk\n\n\n\nmakecapk.apk : $(TARGETS) $(EXTRA_ASSETS_TRIGGER) AndroidManifest.xml\n\tmkdir -p makecapk/assets\n\tcp -r Sources/assets/* makecapk/assets\n\trm -rf temp.apk\n\t$(AAPT) package -f -F temp.apk -I $(ANDROID_JAR) -M AndroidManifest.xml -S Sources/res -A makecapk/assets -v --target-sdk-version $(ANDROIDTARGET)\n\tunzip -o temp.apk -d makecapk\n\trm -rf makecapk.apk\n\t# We use -4 here for the compression ratio, as it's a good balance of speed and size. -9 will make a slightly smaller executable but takes longer to build\n\tcd makecapk && zip -D4r ../makecapk.apk . && zip -D0r ../makecapk.apk ./resources.arsc ./AndroidManifest.xml\n\t# jarsigner is only necessary when targetting Android < 7.0\n\t#jarsigner -sigalg SHA1withRSA -digestalg SHA1 -verbose -keystore $(KEYSTOREFILE) -storepass $(STOREPASS) makecapk.apk $(ALIASNAME)\n\trm -rf $(APKFILE)\n\t$(BUILD_TOOLS)/zipalign -v 4 makecapk.apk $(APKFILE)\n\t#Using the apksigner in this way is only required on Android 30+\n\t$(BUILD_TOOLS)/apksigner sign --key-pass pass:$(STOREPASS) --ks-pass pass:$(STOREPASS) --ks $(KEYSTOREFILE) $(APKFILE)\n\trm -rf temp.apk\n\trm -rf makecapk.apk\n\t@ls -l $(APKFILE)\n\nmanifest: AndroidManifest.xml\n\nAndroidManifest.xml :\n\trm -rf AndroidManifest.xml\n\tPACKAGENAME=$(PACKAGENAME) \\\n\t\tANDROIDVERSION=22 \\\n\t\tANDROIDTARGET=$(ANDROIDTARGET) \\\n\t\tAPPNAME=$(APPNAME) \\\n\t\tLABEL=$(LABEL) envsubst '$$ANDROIDTARGET $$ANDROIDVERSION $$APPNAME $$PACKAGENAME $$LABEL' \\\n\t\t< AndroidManifest.xml.template > AndroidManifest.xml\n\n\nuninstall : \n\t($(ADB) uninstall $(PACKAGENAME))||true\n\npush : makecapk.apk\n\t@echo \"Installing\" $(PACKAGENAME)\n\t$(ADB) install -r $(APKFILE)\n\nrun : push\n\t$(eval ACTIVITYNAME:=$(shell $(AAPT) dump badging $(APKFILE) | grep \"launchable-activity\" | cut -f 2 -d\"'\"))\n\t$(ADB) shell am start -n $(PACKAGENAME)/$(ACTIVITYNAME)\n\nclean :\n\trm -rf AndroidManifest.xml temp.apk makecapk.apk makecapk $(APKFILE)\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.423828125,
          "content": "[![rawdrawandroid](https://github.com/cnlohr/rawdrawandroid/actions/workflows/install.yml/badge.svg)](https://github.com/dreua/rawdrawandroid/actions/workflows/install.yml)\n\n### Update: Works with OpenXR [on Meta Quest](https://github.com/cnlohr/tsopenxr/tree/master/meta_quest)!\n\n# Table of Contents\n\n  - [rawdrawandroid](#rawdrawandroid)\n  - [why?](#why)\n  - [Development Environment](#development-environment)\n    - [Linux install Android Studio with NDK.](#linux-install-android-studio-with-ndk)\n    - [Steps for GUI-less install (Windows, WSL)](#steps-for-gui-less-install-windows-wsl-and-command-line-only-linux)\n      - [Extra note for actually deploying to device in Windows](#extra-note-for-actually-deploying-to-device-in-windows)\n      - [Rest of steps](#rest-of-steps)\n  - [If you are going to use this](#if-you-are-going-to-use-this)\n  - [Helper functions](#helper-functions)\n  - [Departures from regular rawdraw.](#departures-from-regular-rawdraw)\n  - [Google Play](#google-play)\n    - [Part 0: Changes to your app.](#part-0-changes-to-your-app)\n    - [Keys: You will want a key for yourself that's a real key. Not the fake one.](#keys--you-will-want-a-key-for-yourself-thats-a-real-key--not-the-fake-one)\n    - Let Google create and manage my app signing key (recommended)\n    - [Export and upload a key and certificate from a Java keystore](#export-and-upload-a-key-and-certificate-from-a-java-keystore)\n    - [Prepping your app for upload.](#prepping-your-app-for-upload)\n    - [Pre-SDK-32-Tools](#pre-sdk-32-tools)\n  - [TODO](#todo)\n\n# rawdrawandroid\n\nEver wanted to write C code and run it on Android?  Sick of multi-megabyte\npackages just to do the most basic of things.  Well, this is a demo of how\nto make your own APKs and build, install and automatically run them in about\n2 seconds, and with an apk size of about 25kB (with API 26).  API 30 (Android R+)\nis unfortunately at 45kB to support ARM64 + ARM32.\n\nWith this framework you get a demo which has:\n * To make a window with OpenGL ES support\n * Accelerometer/gyro input, multi-touch\n * An android keyboard for key input\n * Ability to store asset files in your APK and read them with `AAssetManager`\n * Permissions support for using things like sound. Example in https://github.com/cnlohr/cnfa / https://github.com/cntools/cnfa/blob/d271e0196d81412032eeffa634a94a1aaf0060a7/CNFA_android.c#L305\n * Directly access USB devices.  Example in https://github.com/cnlohr/androidusbtest\n\n[![Youtube Video](http://img.youtube.com/vi/Cz_LvaN36Ag/0.jpg)](http://www.youtube.com/watch?v=Cz_LvaN36Ag \"\")\n\nDISCLAIMER: I take no warranty or responsibility for this code.  Use at your own risk.  I've never released an app on the app store, so there may be some fundamental issue with using this toolset to make commercial apps!\n\nFor support, we have a Discord, but it is not public at the moment, feel free to reach out to @cnlohr on Discord, with a short message as to why you'd like to join, and he can send you an invite!\n\n# Why?\n\nBecause sometimes you want to do things that don't fit into the normal way of doing it and all the discussions online revolve around doing it with all the normal processes.  And those processes change, making it difficult to keep up and do specific things.  By using `Makefile`s it's easy to see what exact commands are executed and add custom rules and tweak your build.  C is a universal language.  Rawdraw operates on everything from an ESP8266, to RaspberryPi, Windows Linux and now, even Android.  Write code once, use it everywhere.\n\nWhen you don't fill your build process with hills of beans, you end up being left with the parts that are important, and not the frivilous parts. This makes it easier to develop, deploy, etc, because everything takes much less time.\n\nA little bit of this also has to do to stick it to all those Luddites on the internet who post \"that's impossible\" or \"you're doing it wrong\" to Stack Overflow questions... Requesting permissions in the JNI \"oh you **have** to do that in Java\" or other dumb stuff like that.  I am completely uninterested in your opinions of what is or is not possible.  This is computer science.  There aren't restrictions.  I can do anything I want.  It's just bits.  You don't own me.\n\nP.S. If you want a bunch of examples of how to do a ton of things in C on Android that you \"need\" java for, scroll to the bottom of this file: https://github.com/cntools/rawdraw/blob/master/CNFGEGLDriver.c - it shows how to use the JNI to marshall a ton of stuff to/from the Android API without needing to jump back into Java/Kotlin land.\n\n# Development Environment\n\nMost of the testing was done on Linux, however @AEFeinstein has done at least cursory testing in Windows.  You still need some components of Android studio set up to use this, so it's generally easier to just install Android studio completely, but there are instructions on sort of how to do it piecemeal for Windows.\n\n## Linux install Android Studio with NDK.\n\n#### See [section below](#steps-for-gui-less-install-windows-wsl-and-command-line-only-linux) for command-line-only install.\n\nThis set of steps describes how to install Android Studio with NDK support in Linux.  It uses the graphical installer and installs a lot more stuff than the instructions below.  You may be able to mix-and-match these two sets of instructions.  For instance if you are on Linux but don't want to sacrifice 6 GB of disk to the Googs.\n\n**NOTE** You probably should use the WSL instructions instead of these instructions as it will produc a more lean installation.\n\n1) Install prerequisites:\n```\nsudo apt install openjdk-17-jdk-headless adb\n```\n2) Download Android Studio: https://developer.android.com/studio\n3) Start 'studio.sh' in android-studio/bin\n4) Let it install the SDK.\n5) Go to sdkmanager (\"Configure\" button in bottom right)\n6) Probably want to use Android 24, so select that from the list.\n7) Select \"SDK Tools\" -> \"NDK (Side-by-side)\"\n8) Download this repo\n```\ngit clone https://github.com/cnlohr/rawdrawandroid --recurse-submodules\ncd rawdrawandroid\n```\n9) Turn on developer mode on your phone (will vary depending on android version)\n10) Make your own key\n```\nmake keystore\n```\n11) Go into developer options on your phone and enable \"USB debugging\" make sure to select always allow.\n12) Plug your phone into the computer.\n13) Run your program.\n```\nmake push run\n```\n\n## Steps for GUI-less install (Windows, WSL) (And command-line-only-linux)\n\nIf you're developing in Windows Subsystem for Linux (WSL), follow the \"Steps for GUI-less install\" to install the Android components from the command line, without any GUI components.\n\n### Extra note for actually deploying to device in Windows\n\nIn order to push the APK to your phone, you need `adb` installed in Windows as well.  You can do that by getting the full Android Studio from https://developer.android.com/studio#downloads or directly https://dl.google.com/android/repository/platform-tools_r24.0.4-windows.zip. Installing the full Android Studio is easier, but you can also get the \"Command line tools only\" and install `adb` from there.  The steps below outline how to do this with the direct link.\n\n### Rest of steps\n\n1. Install Windows Subsystem for Linux (WSL).  You can find instructions here: https://docs.microsoft.com/en-us/windows/wsl/install-win10 - we use \"Ubuntu\" for this.\n\n2. Install prerequisites:\n```\nsudo apt install openjdk-17-jdk-headless adb unzip zip\n```\n2. Download \"Command line tools only\": https://developer.android.com/studio#downloads - you can get a URL and use `wget` in WSL to download the tools by clicking on the **\"Linux\"** toolset, then right-clicking on the accept link and saying copy link to location.  Then you can say `wget <link>` in WSL.\n3. Create a folder for the Android SDK and export it. You may want to add that export to your `~/.bashrc`:\n```\nmkdir ~/android-sdk\nexport ANDROID_HOME=~/android-sdk\nprintf \"\\nexport ANDROID_HOME=~/android-sdk\\n\" >> ~/.bashrc\n```\n4. Unzip the \"Command line tools only\" file so that `tools` is in your brand new `android-sdk` folder.\n5. Install the SDK and NDK components:\n\nFor earler versions of tools see note for pre-SDK-32-Tools.\n\nIf your platform command-line tools are **30**, the command-line tools will be placed in the cmdline-tools folder. So, you will need to execute the following:\n```\nyes | $ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} --licenses\n$ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} \"build-tools;30.0.2\" \"cmake;3.10.2.4988404\" \"ndk;21.3.6528147\" \"platform-tools\" \"platforms;android-30\" \"tools\"\n```\n\nIf you want to target Android 34 (not recommended in 2024, for device compatibility, you will need to execute the following):\n```\nyes | $ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} --licenses\n$ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} \"build-tools;34.0.0\" \"ndk;26.2.11394342\" \"platform-tools\" \"platforms;android-34\" \"tools\" \"cmake;3.10.2.4988404\"\n```\n**NOTE** You don not actually need `platforms;android-##`, if you want to avoid a 2GB download, you can omit this and once you get rawdrawandroid, you can say `make android-##.jar` to download just the jar file (that's all you need).  (Where ## is the android version number)\n\n**NOTE** If you are upgrading NDK versions, you may need to remove old versions, this Makefile does not necessarily do the best job at auto-selecting NDK versions.\n\nYou can see all avialable versions of software with this command:\n```\n$ANDROID_HOME/cmdline-tools/bin/sdkmanager --list --sdk_root=${ANDROID_HOME}\n```\n\n6. Install the Windows ADB toolset.\n```\nmkdir -p $ANDROID_HOME/windows\ncd $ANDROID_HOME/windows\nwget https://dl.google.com/android/repository/platform-tools_r24.0.4-windows.zip\nunzip platform-tools_r24.0.4-windows.zip\nexport ADB=$ANDROID_HOME/windows/platform-tools/adb.exe\nprintf \"\\nexport ADB=$ANDROID_HOME/windows/platform-tools/adb.exe\\n\" >> ~/.bashrc\n```\n\nAlternatively, you may want to use https://dl.google.com/android/repository/platform-tools_r30.0.5-windows.zip for r30.\n\n6. NOTE: because of updates to environment variables, you may want to close and re-open your WSL terminal.\n7. Download this repo\n```\ngit clone https://github.com/cnlohr/rawdrawandroid --recurse-submodules\ncd rawdrawandroid\n```\n8. Turn on developer mode on your phone (will vary depending on android version)\n9. Go into developer options on your phone and enable \"USB debugging\" make sure to select always allow.\n10. Plug your phone into the computer.\n11. Make your keystore.\n```\nmake keystore\n```\n12. Compile and run your program.\n```\nmake run\n```\n\n# If you are going to use this\n* Check out the example here: https://github.com/cnlohr/rawdrawandroidexample\n* You may want to copy-and-paste this project, but, you could probably use it as a submodule.  You may also want to copy-and-paste the submodule.\n* You *MUST* override the app name.  \n  - See in Makefile `APPNAME` and `PACKAGENAME` you should be able to include this project's makefile and override that.\n  - You must also update `AndroidManifest.xml` with whatever name and org you plan to use.\n  - You will need to update: `package` in `<manifest>` to be your `PACKAGENAME` variable in Makefile.\n  - Both `android:label` labels need to reflect your new app name.  They are in your `<application>` and `<activity>` sections.\n  - Update the `android:value` field in `android.app.lib_name`\n \n* If you are using permission you have to prompt for, you must both add it to your `AndroidManifest.xml` as well as check if you have it, and if not, prompt the user.  See helper functions below.  You can see an example of this with `sound_android.c` from ColorChord.  https://github.com/cnlohr/colorchord/blob/master/colorchord2/sound_android.c\n* Be sure to uninstall any previously installed apps which would look like this app, if you have a different build by the same name signed with another key, bad things will happen.\n* You can see your log with:\n```\nadb logcat\n```\n * If your app opens and closes instantly, try seeing if there are any missing symbols:\n```\nadb logcat | grep UnsatisfiedLinkError\n```\n\n\n# Helper functions\n\nBecause we are doing this entirelly in the NDK, with the JNI, we won't have the luxury of writing any Java/Kotlin code and calling it.  That means all of the examples online have to be heavily marshalled.  In rawdraw's EGL driver, we have many examples of how to do that.  That said, you can use the following functions which get you most of the way there. \n\n`struct android_app * gapp;`\n\n`int AndroidHasPermissions(const char* perm_name);`\n\n`void AndroidRequestAppPermissions(const char * perm);`\n\n`void AndroidDisplayKeyboard(int pShow);`\n\n`int AndroidGetUnicodeChar( int keyCode, int metaState );`\n\n`int android_width, android_height;`\n\n`extern int android_sdk_version; //Derived at start from property ro.build.version.sdk`\n\n\n# Departures from regular rawdraw.\n\nAlso, above and beyond rawdraw, you *must* implement the following two functions to handle when your apps is suspended, resumed or has its window terminated.\n\n`void HandleResume();`\n`void HandleSuspend();`\n`void HandleWindowTermination();`\n\nIn addition to that, the syntax of `HandleMotion(...)` is different, in that instead of the `mask` variable being a mask, it is simply updating that specific pointer.\n\n# Google Play\n\nAs it turns out, Google somehow lets apps built with this onto the store.  Like ColorChord https://github.com/cnlohr/colorchord.\n\n## Part 0: Changes to your app.\n\n1. Make sure you are using the newest SDK.\n2. You will need to add a versionCode to your `AndroidManifest.xml`.  In your `AndroidManifest.xml`, add `android:versionCode=\"integer\"` to the tag where \"integer\" is a version number.\n3. In your `AndroidManifest.xml`, change `android:debuggable` to false.\n4. You may want to support multiple platforms natively.  Add the following to your `Makefile`: `TARGETS:=makecapk/lib/arm64-v8a/lib$(APPNAME).so makecapk/lib/armeabi-v7a/lib$(APPNAME).so makecapk/lib/x86/lib$(APPNAME).so makecapk/lib/x86_64/lib$(APPNAME).so`\n5. You will need to specify target and Min SDK in your `AndroidManifest.xml`  See: `<uses-sdk android:minSdkVersion=\"22\" android:targetSdkVersion=\"28\" />`\n6. Those target / min versions must match your Makefile.  Note that without a `minSdkVerson` google will wrongfully assume 1.  This is dangerous.  Be sure to test your app on a device with whichever minSdkVersion you've specified.\n7.  You will need to disable the debuggable flag in your app.  See `<application android:debuggable=\"false\" ...>`\n\n\nGet a google play account.  Details surrounding app creation are outside the scope of this readme.  When getting ready to upload your APK.\n\n## Keys:  You will want a key for yourself that's a real key.  Not the fake one.\n\nFirst you will need to make a real key.  This can be accomplished by deleting our fake key `my-release-key.keystore` and executing the following command (being careful to fill `####` in with real info): \n\n```make keystore STOREPASS=#### DNAME=\"\\\"CN=####, OU=ID, O=####, L=####, S=####, C=####\\\"\" ALIASNAME=####```\n\nThe alias name will be `standkey`. You will want to verify you can build your app with this key.  Be sure to fill in STOREPASS the same.\n\n```make clean run  STOREPASS=####```\n\n\n## Let Google create and manage my app signing key (recommended) \n\n\n## Export and upload a key and certificate from a Java keystore \n\nIf you want to use the play store key with \"Export and upload a key and certificate from a Java keystore\" Instead of `Let Google create and manage my app signing key (recommended)` and follow PEKP instructions.\n\n## Prepping your app for upload.\n\nYou MUST have aligned ZIPs for the Play store.  You must run the following command:\n\n```zipalign -c -v 8 makecapk.apk```\n\nUpload your APK `makecapk.apk` made with your key.\n\n## Pre-SDK-32-Tools\n\nIf you are using **Android 29 or older**, do this.\n```\nyes | $ANDROID_HOME/tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} --licenses\n$ANDROID_HOME/tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} \"build-tools;29.0.3\" \"cmake;3.10.2.4988404\" \"ndk;21.1.6352462\" \"platform-tools\" \"platforms;android-29\" \"tools\"\n```\n\nIf your platform command-line tools are **30**, the command-line tools will be placed in the cmdline-tools folder. So, you will need to execute the following:\n```\nyes | $ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} --licenses\n$ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} \"build-tools;30.0.2\" \"cmake;3.10.2.4988404\" \"ndk;21.3.6528147\" \"platform-tools\" \"platforms;android-30\" \"tools\"\n```\n\nIf your platform command-line tools are **32**, the command-line tools will be placed in the cmdline-tools folder. So, you will need to execute the following (This appears to be backwards compatbile to some degree with Android 30):\n```\nyes | $ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} --licenses\n$ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=${ANDROID_HOME} \"build-tools;32.0.0\" \"cmake;3.22.1\" \"ndk;25.1.8937393\" \"platforms;android-32\" \"platform-tools\" \"tools\"\n```\n\n\n# TODO\n\nTry a bunch of these cool priveleges, see what they all do.\n* permission.ACCESS\n* permission.INTERNET\n* permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS\n* permission.ACCESS_NETWORK_STATE\n* permission.WRITE_EXTERNAL_STORAGE\n* permission.READ_PHONE_STATE\n* permission.GET_TASKS\n* permission.REORDER_TASKS\n* permission.WRITE_APN_SETTINGS\n* permission.READ_SECURE_SETTINGS\n* permission.READ_SETTINGS\n* permission.REAL_GET_TASKS\n* permission.INTERACT_ACROSS_USERS\n* permission.MANAGE_USERS\n* permission.INSTALL_PACKAGES\n* permission.DELETE_PACKAGES\n* permission.INTERACT_ACROSS_USERS_FULL\n* permission.READ_MEDIA_STORAGE\n* permission.WRITE_MEDIA_STORAGE\n* android.permission.VR\n* android.permission.INSTALL_PACKAGES\n\n\n\n\n"
        },
        {
          "name": "Sources",
          "type": "tree",
          "content": null
        },
        {
          "name": "android_native_app_glue.c",
          "type": "blob",
          "size": 18.9736328125,
          "content": "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include <jni.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/resource.h>\n\n#include \"android_native_app_glue.h\"\n#include <android/log.h>\n#include <android/native_activity.h>\n\n#include \"webview_native_activity.h\"\nstruct android_app * gapp;\n\n#define LOGI(...) ((void)printf(__VA_ARGS__))\n#define LOGE(...) ((void)printf(__VA_ARGS__))\n\n/* For debug builds, always enable the debug traces in this library */\n\n#ifndef NDEBUG\n#  define LOGV(...)  ((void)printf(__VA_ARGS__))\n#else\n#  define LOGV(...)  ((void)0)\n#endif\n\n\ntypedef struct  __attribute__((packed))\n{\n\tvoid (*callback)( void * ); \n\tvoid * opaque;\n} MainThreadCallbackProps;\n\nstatic int pfd[2];\npthread_t debug_capture_thread;\nstatic void * debug_capture_thread_fn( void * v )\n{\n\t//struct android_app * app = (struct android_app*)v;\n    ssize_t readSize;\n    char buf[2048];\n\n    while((readSize = read(pfd[0], buf, sizeof buf - 1)) > 0) {\n        if(buf[readSize - 1] == '\\n') {\n            --readSize;\n        }\n        buf[readSize] = 0;  // add null-terminator\n        __android_log_write(ANDROID_LOG_DEBUG, APPNAME, buf); // Set any log level you want\n#ifdef RDALOGFNCB\n\t\textern void RDALOGFNCB( int size, char * buf );\n\t\tRDALOGFNCB( readSize, buf );\n#endif\n\t\t//if( debug_capture_hook_function ) debug_capture_hook_function( readSize, buf );\n    }\n    return 0;\n}\n\nstatic void free_saved_state(struct android_app* android_app) {\n    pthread_mutex_lock(&android_app->mutex);\n    if (android_app->savedState != NULL) {\n        free(android_app->savedState);\n        android_app->savedState = NULL;\n        android_app->savedStateSize = 0;\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nint8_t android_app_read_cmd(struct android_app* android_app) {\n    int8_t cmd;\n    if (read(android_app->msgread, &cmd, sizeof(cmd)) == sizeof(cmd)) {\n        switch (cmd) {\n            case APP_CMD_SAVE_STATE:\n                free_saved_state(android_app);\n                break;\n        }\n        return cmd;\n    } else {\n        LOGE(\"No data on command pipe!\");\n    }\n    return -1;\n}\n\nstatic void print_cur_config(struct android_app* android_app) {\n\t//For additional debugging this can be enabled, but for now - no need for the extra space.\n/*\n    char lang[2], country[2];\n    AConfiguration_getLanguage(android_app->config, lang);\n    AConfiguration_getCountry(android_app->config, country);\n\n    LOGV(\"Config: mcc=%d mnc=%d lang=%c%c cnt=%c%c orien=%d touch=%d dens=%d \"\n            \"keys=%d nav=%d keysHid=%d navHid=%d sdk=%d size=%d long=%d \"\n            \"modetype=%d modenight=%d\",\n            AConfiguration_getMcc(android_app->config),\n            AConfiguration_getMnc(android_app->config),\n            lang[0], lang[1], country[0], country[1],\n            AConfiguration_getOrientation(android_app->config),\n            AConfiguration_getTouchscreen(android_app->config),\n            AConfiguration_getDensity(android_app->config),\n            AConfiguration_getKeyboard(android_app->config),\n            AConfiguration_getNavigation(android_app->config),\n            AConfiguration_getKeysHidden(android_app->config),\n            AConfiguration_getNavHidden(android_app->config),\n            AConfiguration_getSdkVersion(android_app->config),\n            AConfiguration_getScreenSize(android_app->config),\n            AConfiguration_getScreenLong(android_app->config),\n            AConfiguration_getUiModeType(android_app->config),\n            AConfiguration_getUiModeNight(android_app->config));\n*/\n}\n\nvoid android_app_pre_exec_cmd(struct android_app* android_app, int8_t cmd) {\n    switch (cmd) {\n        case APP_CMD_INPUT_CHANGED:\n            LOGV(\"APP_CMD_INPUT_CHANGED\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            if (android_app->inputQueue != NULL) {\n                AInputQueue_detachLooper(android_app->inputQueue);\n            }\n            android_app->inputQueue = android_app->pendingInputQueue;\n            if (android_app->inputQueue != NULL) {\n                LOGV(\"Attaching input queue to looper\");\n                AInputQueue_attachLooper(android_app->inputQueue,\n                        android_app->looper, LOOPER_ID_INPUT, NULL,\n                        &android_app->inputPollSource);\n            }\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_INIT_WINDOW:\n            LOGV(\"APP_CMD_INIT_WINDOW\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->window = android_app->pendingWindow;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_TERM_WINDOW:\n            LOGV(\"APP_CMD_TERM_WINDOW\\n\");\n            pthread_cond_broadcast(&android_app->cond);\n            break;\n\n        case APP_CMD_RESUME:\n        case APP_CMD_START:\n        case APP_CMD_PAUSE:\n        case APP_CMD_STOP:\n            LOGV(\"activityState=%d\\n\", cmd);\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->activityState = cmd;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_CONFIG_CHANGED:\n            LOGV(\"APP_CMD_CONFIG_CHANGED\\n\");\n            AConfiguration_fromAssetManager(android_app->config,\n                    android_app->activity->assetManager);\n            print_cur_config(android_app);\n            break;\n\n        case APP_CMD_DESTROY:\n            LOGV(\"APP_CMD_DESTROY\\n\");\n            android_app->destroyRequested = 1;\n            break;\n    }\n}\n\nvoid android_app_post_exec_cmd(struct android_app* android_app, int8_t cmd) {\n    switch (cmd) {\n        case APP_CMD_TERM_WINDOW:\n            LOGV(\"APP_CMD_TERM_WINDOW\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->window = NULL;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_SAVE_STATE:\n            LOGV(\"APP_CMD_SAVE_STATE\\n\");\n            pthread_mutex_lock(&android_app->mutex);\n            android_app->stateSaved = 1;\n            pthread_cond_broadcast(&android_app->cond);\n            pthread_mutex_unlock(&android_app->mutex);\n            break;\n\n        case APP_CMD_RESUME:\n            free_saved_state(android_app);\n            break;\n    }\n}\n\nvoid app_dummy() {\n\n}\n\nstatic void android_app_destroy(struct android_app* android_app) {\n    LOGV(\"android_app_destroy!\");\n    free_saved_state(android_app);\n    pthread_mutex_lock(&android_app->mutex);\n    if (android_app->inputQueue != NULL) {\n        AInputQueue_detachLooper(android_app->inputQueue);\n    }\n    AConfiguration_delete(android_app->config);\n    android_app->destroyed = 1;\n    pthread_cond_broadcast(&android_app->cond);\n    pthread_mutex_unlock(&android_app->mutex);\n    // Can't touch android_app object after this.\n}\n\nstatic void process_input(struct android_app* app, struct android_poll_source* source) {\n    AInputEvent* event = NULL;\n    while (AInputQueue_getEvent(app->inputQueue, &event) >= 0) {\n        //LOGV(\"New input event: type=%d\\n\", AInputEvent_getType(event));\n        if (AInputQueue_preDispatchEvent(app->inputQueue, event)) {\n            continue;\n        }\n        int32_t handled = 0;\n        if (app->onInputEvent != NULL) handled = app->onInputEvent(app, event);\n        AInputQueue_finishEvent(app->inputQueue, event, handled);\n    }\n}\n\nstatic int process_ui( int dummy1, int dummy2, void * dummy3 ) {\n\t// Can't trust parameters in UI thread callback.\n\tMainThreadCallbackProps rep;\n    read(gapp->uimsgread, &rep, sizeof(rep));\n\trep.callback( rep.opaque );\n\treturn 1;\n}\n\nstatic void process_cmd(struct android_app* app, struct android_poll_source* source) {\n    int8_t cmd = android_app_read_cmd(app);\n    android_app_pre_exec_cmd(app, cmd);\n    if (app->onAppCmd != NULL) app->onAppCmd(app, cmd);\n    android_app_post_exec_cmd(app, cmd);\n}\n\nstatic void* android_app_entry(void* param) {\n    struct android_app* android_app = (struct android_app*)param;\n\n    android_app->config = AConfiguration_new();\n    AConfiguration_fromAssetManager(android_app->config, android_app->activity->assetManager);\n\n    print_cur_config(android_app);\n    android_app->cmdPollSource.id = LOOPER_ID_MAIN;\n    android_app->cmdPollSource.app = android_app;\n    android_app->cmdPollSource.process = process_cmd;\n    android_app->inputPollSource.id = LOOPER_ID_INPUT;\n    android_app->inputPollSource.app = android_app;\n    android_app->inputPollSource.process = process_input;\n\n    ALooper* looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);\n    ALooper_addFd(looper, android_app->msgread, LOOPER_ID_MAIN, ALOOPER_EVENT_INPUT, NULL, &android_app->cmdPollSource);\n    android_app->looper = looper;\n\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->running = 1;\n    pthread_cond_broadcast(&android_app->cond);\n    pthread_mutex_unlock(&android_app->mutex);\n\n    android_main(android_app);\n\n    android_app_destroy(android_app);\n    return NULL;\n}\n\n// --------------------------------------------------------------------\n// Native activity interaction (called from main thread)\n// --------------------------------------------------------------------\n\nstatic struct android_app* android_app_create(ANativeActivity* activity,\n        void* savedState, size_t savedStateSize) {\n    struct android_app* android_app = (struct android_app*)malloc(sizeof(struct android_app));\n    memset(android_app, 0, sizeof(struct android_app));\n    android_app->activity = activity;\n\n    pthread_mutex_init(&android_app->mutex, NULL);\n    pthread_cond_init(&android_app->cond, NULL);\n\n\n    pthread_attr_t attr; \n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\t//Capture input\n    setvbuf(stdout, 0, _IOLBF, 0); // make stdout line-buffered\n    setvbuf(stderr, 0, _IONBF, 0); // make stderr unbuffered\n    pipe(pfd);\n    dup2(pfd[1], 1);\n    dup2(pfd[1], 2);\n    pthread_create(&debug_capture_thread, &attr, debug_capture_thread_fn, android_app);\n\n    if (savedState != NULL) {\n        android_app->savedState = malloc(savedStateSize);\n        android_app->savedStateSize = savedStateSize;\n        memcpy(android_app->savedState, savedState, savedStateSize);\n    }\n\n    int msgpipe[2];\n    if (pipe(msgpipe)) {\n        LOGE(\"could not create pipe: %s\", strerror(errno));\n        return NULL;\n    }\n    android_app->msgread = msgpipe[0];\n    android_app->msgwrite = msgpipe[1];\n\n\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Handle calling events on the UI thread.  You can get callbacks with RunCallbackOnUIThread.\n    int msgpipemain[2];\n    if (pipe(msgpipemain)) {\n        LOGE(\"could not create pipe: %s\", strerror(errno));\n        return NULL;\n    }\n    android_app->uimsgread = msgpipemain[0];\n    android_app->uimsgwrite = msgpipemain[1];\n    ALooper * looper = ALooper_forThread();\n    ALooper_addFd(looper, android_app->uimsgread, LOOPER_ID_MAIN_THREAD, ALOOPER_EVENT_INPUT, process_ui, gapp);  //NOTE: Cannot use NULL callback\n    android_app->looperui = looper;\n\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    pthread_create(&android_app->thread, &attr, android_app_entry, android_app);\n\n    // Wait for thread to start.\n    pthread_mutex_lock(&android_app->mutex);\n    while (!android_app->running) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n\n    return android_app;\n}\n\nstatic void android_app_write_cmd(struct android_app* android_app, int8_t cmd) {\n    if (write(android_app->msgwrite, &cmd, sizeof(cmd)) != sizeof(cmd)) {\n        LOGE(\"Failure writing android_app cmd: %s\\n\", strerror(errno));\n    }\n}\n\nstatic void android_app_set_input(struct android_app* android_app, AInputQueue* inputQueue) {\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->pendingInputQueue = inputQueue;\n    android_app_write_cmd(android_app, APP_CMD_INPUT_CHANGED);\n    while (android_app->inputQueue != android_app->pendingInputQueue) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nstatic void android_app_set_window(struct android_app* android_app, ANativeWindow* window) {\n    pthread_mutex_lock(&android_app->mutex);\n    if (android_app->pendingWindow != NULL) {\n        android_app_write_cmd(android_app, APP_CMD_TERM_WINDOW);\n    }\n    android_app->pendingWindow = window;\n    if (window != NULL) {\n        android_app_write_cmd(android_app, APP_CMD_INIT_WINDOW);\n    }\n    while (android_app->window != android_app->pendingWindow) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nstatic void android_app_set_activity_state(struct android_app* android_app, int8_t cmd) {\n    pthread_mutex_lock(&android_app->mutex);\n    android_app_write_cmd(android_app, cmd);\n    while (android_app->activityState != cmd) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n}\n\nstatic void android_app_free(struct android_app* android_app) {\n    pthread_mutex_lock(&android_app->mutex);\n    android_app_write_cmd(android_app, APP_CMD_DESTROY);\n    while (!android_app->destroyed) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n\n    close(android_app->msgread);\n    close(android_app->msgwrite);\n    pthread_cond_destroy(&android_app->cond);\n    pthread_mutex_destroy(&android_app->mutex);\n    free(android_app);\n}\n\nstatic void onDestroy(ANativeActivity* activity) {\n    LOGV(\"Destroy: %p\\n\", activity);\n    android_app_free((struct android_app*)activity->instance);\n}\n\nstatic void onStart(ANativeActivity* activity) {\n    LOGV(\"Start: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_START);\n}\n\nstatic void onResume(ANativeActivity* activity) {\n    LOGV(\"Resume: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_RESUME);\n}\n\nstatic void* onSaveInstanceState(ANativeActivity* activity, size_t* outLen) {\n    struct android_app* android_app = (struct android_app*)activity->instance;\n    void* savedState = NULL;\n\n    LOGV(\"SaveInstanceState: %p\\n\", activity);\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->stateSaved = 0;\n    android_app_write_cmd(android_app, APP_CMD_SAVE_STATE);\n    while (!android_app->stateSaved) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n\n    if (android_app->savedState != NULL) {\n        savedState = android_app->savedState;\n        *outLen = android_app->savedStateSize;\n        android_app->savedState = NULL;\n        android_app->savedStateSize = 0;\n    }\n\n    pthread_mutex_unlock(&android_app->mutex);\n\n    return savedState;\n}\n\nstatic void onPause(ANativeActivity* activity) {\n    LOGV(\"Pause: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_PAUSE);\n}\n\nstatic void onStop(ANativeActivity* activity) {\n    LOGV(\"Stop: %p\\n\", activity);\n    android_app_set_activity_state((struct android_app*)activity->instance, APP_CMD_STOP);\n}\n\nstatic void onConfigurationChanged(ANativeActivity* activity) {\n    struct android_app* android_app = (struct android_app*)activity->instance;\n    LOGV(\"ConfigurationChanged: %p\\n\", activity);\n    android_app_write_cmd(android_app, APP_CMD_CONFIG_CHANGED);\n}\n\nstatic void onLowMemory(ANativeActivity* activity) {\n    struct android_app* android_app = (struct android_app*)activity->instance;\n    LOGV(\"LowMemory: %p\\n\", activity);\n    android_app_write_cmd(android_app, APP_CMD_LOW_MEMORY);\n}\n\nstatic void onWindowFocusChanged(ANativeActivity* activity, int focused) {\n    LOGV(\"WindowFocusChanged: %p -- %d\\n\", activity, focused);\n    android_app_write_cmd((struct android_app*)activity->instance,\n            focused ? APP_CMD_GAINED_FOCUS : APP_CMD_LOST_FOCUS);\n}\n\nstatic void onNativeWindowCreated(ANativeActivity* activity, ANativeWindow* window) {\n    LOGV(\"NativeWindowCreated: %p -- %p\\n\", activity, window);\n    android_app_set_window((struct android_app*)activity->instance, window);\n}\n\nstatic void onNativeWindowDestroyed(ANativeActivity* activity, ANativeWindow* window) {\n    LOGV(\"NativeWindowDestroyed: %p -- %p\\n\", activity, window);\n    android_app_set_window((struct android_app*)activity->instance, NULL);\n}\n\nstatic void onInputQueueCreated(ANativeActivity* activity, AInputQueue* queue) {\n    LOGV(\"InputQueueCreated: %p -- %p\\n\", activity, queue);\n    android_app_set_input((struct android_app*)activity->instance, queue);\n}\n\nstatic void onInputQueueDestroyed(ANativeActivity* activity, AInputQueue* queue) {\n    LOGV(\"InputQueueDestroyed: %p -- %p\\n\", activity, queue);\n    android_app_set_input((struct android_app*)activity->instance, NULL);\n}\n\nstatic void onNativeWindowRedrawNeeded(ANativeActivity* activity, ANativeWindow *window ) {\n    LOGV(\"onNativeWindowRedrawNeeded: %p -- %p\\n\", activity, window);\n}\n\nJNIEXPORT\nvoid ANativeActivity_onCreate(ANativeActivity* activity, void* savedState,\n                              size_t savedStateSize) {\n    LOGV(\"Creating: %p\\n\", activity);\n    activity->callbacks->onDestroy = onDestroy;\n    activity->callbacks->onStart = onStart;\n    activity->callbacks->onResume = onResume;\n    activity->callbacks->onSaveInstanceState = onSaveInstanceState;\n    activity->callbacks->onPause = onPause;\n    activity->callbacks->onStop = onStop;\n    activity->callbacks->onConfigurationChanged = onConfigurationChanged;\n    activity->callbacks->onLowMemory = onLowMemory;\n    activity->callbacks->onWindowFocusChanged = onWindowFocusChanged;\n    activity->callbacks->onNativeWindowCreated = onNativeWindowCreated;\n    activity->callbacks->onNativeWindowDestroyed = onNativeWindowDestroyed;\n    activity->callbacks->onInputQueueCreated = onInputQueueCreated;\n    activity->callbacks->onInputQueueDestroyed = onInputQueueDestroyed;\n\tactivity->callbacks->onNativeWindowRedrawNeeded = onNativeWindowRedrawNeeded;\n\n    activity->instance = android_app_create(activity, savedState, savedStateSize);\n}\n\nvoid RunCallbackOnUIThread( void (*callback)(void *), void * opaque )\n{\n\tMainThreadCallbackProps gpdata;\n\tgpdata.callback = callback;\n\tgpdata.opaque = opaque;\n\twrite(gapp->uimsgwrite, &gpdata, sizeof(gpdata) );\t\n}\n\n"
        },
        {
          "name": "android_native_app_glue.h",
          "type": "blob",
          "size": 12.1572265625,
          "content": "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#ifndef _ANDROID_NATIVE_APP_GLUE_H\n#define _ANDROID_NATIVE_APP_GLUE_H\n\n#include <poll.h>\n#include <pthread.h>\n#include <sched.h>\n\n#include <android/configuration.h>\n#include <android/looper.h>\n#include <android/native_activity.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * The native activity interface provided by <android/native_activity.h>\n * is based on a set of application-provided callbacks that will be called\n * by the Activity's main thread when certain events occur.\n *\n * This means that each one of this callbacks _should_ _not_ block, or they\n * risk having the system force-close the application. This programming\n * model is direct, lightweight, but constraining.\n *\n * The 'android_native_app_glue' static library is used to provide a different\n * execution model where the application can implement its own main event\n * loop in a different thread instead. Here's how it works:\n *\n * 1/ The application must provide a function named \"android_main()\" that\n *    will be called when the activity is created, in a new thread that is\n *    distinct from the activity's main thread.\n *\n * 2/ android_main() receives a pointer to a valid \"android_app\" structure\n *    that contains references to other important objects, e.g. the\n *    ANativeActivity object instance the application is running in.\n *\n * 3/ the \"android_app\" object holds an ALooper instance that already\n *    listens to two important things:\n *\n *      - activity lifecycle events (e.g. \"pause\", \"resume\"). See APP_CMD_XXX\n *        declarations below.\n *\n *      - input events coming from the AInputQueue attached to the activity.\n *\n *    Each of these correspond to an ALooper identifier returned by\n *    ALooper_pollOnce with values of LOOPER_ID_MAIN and LOOPER_ID_INPUT,\n *    respectively.\n *\n *    Your application can use the same ALooper to listen to additional\n *    file-descriptors.  They can either be callback based, or with return\n *    identifiers starting with LOOPER_ID_USER.\n *\n * 4/ Whenever you receive a LOOPER_ID_MAIN or LOOPER_ID_INPUT event,\n *    the returned data will point to an android_poll_source structure.  You\n *    can call the process() function on it, and fill in android_app->onAppCmd\n *    and android_app->onInputEvent to be called for your own processing\n *    of the event.\n *\n *    Alternatively, you can call the low-level functions to read and process\n *    the data directly...  look at the process_cmd() and process_input()\n *    implementations in the glue to see how to do this.\n *\n * See the sample named \"native-activity\" that comes with the NDK with a\n * full usage example.  Also look at the JavaDoc of NativeActivity.\n */\n\nstruct android_app;\n\n/**\n * Data associated with an ALooper fd that will be returned as the \"outData\"\n * when that source has data ready.\n */\nstruct android_poll_source {\n    // The identifier of this source.  May be LOOPER_ID_MAIN or\n    // LOOPER_ID_INPUT.\n    int32_t id;\n\n    // The android_app this ident is associated with.\n    struct android_app* app;\n\n    // Function to call to perform the standard processing of data from\n    // this source.\n    void (*process)(struct android_app* app, struct android_poll_source* source);\n};\n\n/**\n * This is the interface for the standard glue code of a threaded\n * application.  In this model, the application's code is running\n * in its own thread separate from the main thread of the process.\n * It is not required that this thread be associated with the Java\n * VM, although it will need to be in order to make JNI calls any\n * Java objects.\n */\nstruct android_app {\n    // The application can place a pointer to its own state object\n    // here if it likes.\n    void* userData;\n\n    // Fill this in with the function to process main app commands (APP_CMD_*)\n    void (*onAppCmd)(struct android_app* app, int32_t cmd);\n\n    // Fill this in with the function to process input events.  At this point\n    // the event has already been pre-dispatched, and it will be finished upon\n    // return.  Return 1 if you have handled the event, 0 for any default\n    // dispatching.\n    int32_t (*onInputEvent)(struct android_app* app, AInputEvent* event);\n\n    // The ANativeActivity object instance that this app is running in.\n    ANativeActivity* activity;\n\n    // The current configuration the app is running in.\n    AConfiguration* config;\n\n    // This is the last instance's saved state, as provided at creation time.\n    // It is NULL if there was no state.  You can use this as you need; the\n    // memory will remain around until you call android_app_exec_cmd() for\n    // APP_CMD_RESUME, at which point it will be freed and savedState set to NULL.\n    // These variables should only be changed when processing a APP_CMD_SAVE_STATE,\n    // at which point they will be initialized to NULL and you can malloc your\n    // state and place the information here.  In that case the memory will be\n    // freed for you later.\n    void* savedState;\n    size_t savedStateSize;\n\n    // The ALooper associated with the app's thread.\n    ALooper* looper;\n\n\n    // The ALooper associated with the main thread.\n    ALooper* looperui;\n\n    // When non-NULL, this is the input queue from which the app will\n    // receive user input events.\n    AInputQueue* inputQueue;\n\n    // When non-NULL, this is the window surface that the app can draw in.\n    ANativeWindow* window;\n\n    // Current content rectangle of the window; this is the area where the\n    // window's content should be placed to be seen by the user.\n    ARect contentRect;\n\n    // Current state of the app's activity.  May be either APP_CMD_START,\n    // APP_CMD_RESUME, APP_CMD_PAUSE, or APP_CMD_STOP; see below.\n    int activityState;\n\n    // This is non-zero when the application's NativeActivity is being\n    // destroyed and waiting for the app thread to complete.\n    int destroyRequested;\n\n    // -------------------------------------------------\n    // Below are \"private\" implementation of the glue code.\n\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n\n    int msgread;\n    int msgwrite;\n\n\tint uimsgread;\n\tint uimsgwrite;\n\n    pthread_t thread;\n\n    struct android_poll_source cmdPollSource;\n    struct android_poll_source inputPollSource;\n\n    int running;\n    int stateSaved;\n    int destroyed;\n    int redrawNeeded;\n    AInputQueue* pendingInputQueue;\n    ANativeWindow* pendingWindow;\n    ARect pendingContentRect;\n};\n\nenum {\n    /**\n     * Looper data ID of commands coming from the app's main thread, which\n     * is returned as an identifier from ALooper_pollOnce().  The data for this\n     * identifier is a pointer to an android_poll_source structure.\n     * These can be retrieved and processed with android_app_read_cmd()\n     * and android_app_exec_cmd().\n     */\n    LOOPER_ID_MAIN = 1,\n\n    /**\n     * Looper data ID of events coming from the AInputQueue of the\n     * application's window, which is returned as an identifier from\n     * ALooper_pollOnce().  The data for this identifier is a pointer to an\n     * android_poll_source structure.  These can be read via the inputQueue\n     * object of android_app.\n     */\n    LOOPER_ID_INPUT = 2,\n\n    /**\n     * Start of main ALooper identifiers.\n     */\n    LOOPER_ID_MAIN_THREAD = 3,\n\n    /**\n     * Start of user-defined ALooper identifiers.\n     */\n    LOOPER_ID_USER = 4,\n};\n\nenum {\n    /**\n     * Command from main thread: the AInputQueue has changed.  Upon processing\n     * this command, android_app->inputQueue will be updated to the new queue\n     * (or NULL).\n     */\n    APP_CMD_INPUT_CHANGED,\n\n    /**\n     * Command from main thread: a new ANativeWindow is ready for use.  Upon\n     * receiving this command, android_app->window will contain the new window\n     * surface.\n     */\n    APP_CMD_INIT_WINDOW,\n\n    /**\n     * Command from main thread: the existing ANativeWindow needs to be\n     * terminated.  Upon receiving this command, android_app->window still\n     * contains the existing window; after calling android_app_exec_cmd\n     * it will be set to NULL.\n     */\n    APP_CMD_TERM_WINDOW,\n\n    /**\n     * Command from main thread: the current ANativeWindow has been resized.\n     * Please redraw with its new size.\n     */\n    APP_CMD_WINDOW_RESIZED,\n\n    /**\n     * Command from main thread: the system needs that the current ANativeWindow\n     * be redrawn.  You should redraw the window before handing this to\n     * android_app_exec_cmd() in order to avoid transient drawing glitches.\n     */\n    APP_CMD_WINDOW_REDRAW_NEEDED,\n\n    /**\n     * Command from main thread: the content area of the window has changed,\n     * such as from the soft input window being shown or hidden.  You can\n     * find the new content rect in android_app::contentRect.\n     */\n    APP_CMD_CONTENT_RECT_CHANGED,\n\n    /**\n     * Command from main thread: the app's activity window has gained\n     * input focus.\n     */\n    APP_CMD_GAINED_FOCUS,\n\n    /**\n     * Command from main thread: the app's activity window has lost\n     * input focus.\n     */\n    APP_CMD_LOST_FOCUS,\n\n    /**\n     * Command from main thread: the current device configuration has changed.\n     */\n    APP_CMD_CONFIG_CHANGED,\n\n    /**\n     * Command from main thread: the system is running low on memory.\n     * Try to reduce your memory use.\n     */\n    APP_CMD_LOW_MEMORY,\n\n    /**\n     * Command from main thread: the app's activity has been started.\n     */\n    APP_CMD_START,\n\n    /**\n     * Command from main thread: the app's activity has been resumed.\n     */\n    APP_CMD_RESUME,\n\n    /**\n     * Command from main thread: the app should generate a new saved state\n     * for itself, to restore from later if needed.  If you have saved state,\n     * allocate it with malloc and place it in android_app.savedState with\n     * the size in android_app.savedStateSize.  The will be freed for you\n     * later.\n     */\n    APP_CMD_SAVE_STATE,\n\n    /**\n     * Command from main thread: the app's activity has been paused.\n     */\n    APP_CMD_PAUSE,\n\n    /**\n     * Command from main thread: the app's activity has been stopped.\n     */\n    APP_CMD_STOP,\n\n    /**\n     * Command from main thread: the app's activity is being destroyed,\n     * and waiting for the app thread to clean up and exit before proceeding.\n     */\n    APP_CMD_DESTROY,\n\n    /**\n     * Custom command to execute something from an event queue\n     */\n    APP_CMD_CUSTOM_EVENT,\n};\n\n/**\n * Call when ALooper_pollAll() returns LOOPER_ID_MAIN, reading the next\n * app command message.\n */\nint8_t android_app_read_cmd(struct android_app* android_app);\n\n/**\n * Call with the command returned by android_app_read_cmd() to do the\n * initial pre-processing of the given command.  You can perform your own\n * actions for the command after calling this function.\n */\nvoid android_app_pre_exec_cmd(struct android_app* android_app, int8_t cmd);\n\n/**\n * Call with the command returned by android_app_read_cmd() to do the\n * final post-processing of the given command.  You must have done your own\n * actions for the command before calling this function.\n */\nvoid android_app_post_exec_cmd(struct android_app* android_app, int8_t cmd);\n\n/**\n * Dummy function that used to be used to prevent the linker from stripping app\n * glue code. No longer necessary, since __attribute__((visibility(\"default\")))\n * does this for us.\n */\n__attribute__((\n    deprecated(\"Calls to app_dummy are no longer necessary. See \"\n               \"https://github.com/android-ndk/ndk/issues/381.\"))) void\napp_dummy();\n\n/**\n * This is the function that application code must implement, representing\n * the main entry to the app.\n */\nextern void android_main(struct android_app* app);\n\n/**\n * Mechanism to run code on main UI thread.\n */\nvoid RunCallbackOnUIThread( void (*callback)(void *), void * opaque );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _ANDROID_NATIVE_APP_GLUE_H */\n"
        },
        {
          "name": "android_usb_devices.c",
          "type": "blob",
          "size": 10.5751953125,
          "content": "//Copyright 2020 <>< Charles Lohr, You may use this file and library freely under the MIT/x11, NewBSD or ColorChord Licenses.\n\n#include \"android_usb_devices.h\"\n#include \"CNFG.h\"\n#include \"os_generic.h\"\n\ndouble dTimeOfUSBFail;\ndouble dTimeOfLastAsk;\njobject deviceConnection = 0;\nint deviceConnectionFD = 0;\nextern struct android_app * gapp;\n\nvoid DisconnectUSB()\n{\n\tdeviceConnectionFD = 0;\n\tdTimeOfUSBFail = OGGetAbsoluteTime();\n}\n\nint RequestPermissionOrGetConnectionFD( char * ats, uint16_t vid, uint16_t pid )\n{\n\t//Don't permit \n\tif( OGGetAbsoluteTime() - dTimeOfUSBFail < 1 ) \n\t{\n\t\tats+=sprintf(ats, \"Comms failed.  Waiting to reconnect.\" );\n\t\treturn -1;\n\t}\n\n\tstruct android_app* app = gapp;\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = app->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\t// Retrieves NativeActivity.\n\tjobject lNativeActivity = gapp->activity->clazz;\n\n\t//https://stackoverflow.com/questions/13280581/using-android-to-communicate-with-a-usb-hid-device\n\n\t//UsbManager manager = (UsbManager)getSystemService(Context.USB_SERVICE);\n\tjclass ClassContext = env->FindClass( envptr, \"android/content/Context\" );\n\tjfieldID lid_USB_SERVICE = env->GetStaticFieldID( envptr, ClassContext, \"USB_SERVICE\", \"Ljava/lang/String;\" );\n\tjobject USB_SERVICE = env->GetStaticObjectField( envptr, ClassContext, lid_USB_SERVICE );\n\n\tjmethodID MethodgetSystemService = env->GetMethodID( envptr, ClassContext, \"getSystemService\", \"(Ljava/lang/String;)Ljava/lang/Object;\" );\n\tjobject manager = env->CallObjectMethod( envptr, lNativeActivity, MethodgetSystemService, USB_SERVICE);\n\t\t\t//Actually returns an android/hardware/usb/UsbManager\n\tjclass ClassUsbManager = env->FindClass( envptr, \"android/hardware/usb/UsbManager\" );\n\n\t//HashMap<String, UsbDevice> deviceList = mManager.getDeviceList();\n\tjmethodID MethodgetDeviceList = env->GetMethodID( envptr, ClassUsbManager, \"getDeviceList\", \"()Ljava/util/HashMap;\" );\n\tjobject deviceList = env->CallObjectMethod( envptr, manager, MethodgetDeviceList );\n\n\t//Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();\n\tjclass ClassHashMap = env->FindClass( envptr, \"java/util/HashMap\" );\n\tjmethodID Methodvalues = env->GetMethodID( envptr, ClassHashMap, \"values\", \"()Ljava/util/Collection;\" );\n\tjobject deviceListCollection = env->CallObjectMethod( envptr, deviceList, Methodvalues );\n\tjclass ClassCollection = env->FindClass( envptr, \"java/util/Collection\" );\n\tjmethodID Methoditerator = env->GetMethodID( envptr, ClassCollection, \"iterator\", \"()Ljava/util/Iterator;\" );\n\tjobject deviceListIterator = env->CallObjectMethod( envptr, deviceListCollection, Methoditerator );\n\tjclass ClassIterator = env->FindClass( envptr, \"java/util/Iterator\" );\n\n\t//while (deviceIterator.hasNext())\n\tjmethodID MethodhasNext = env->GetMethodID( envptr, ClassIterator, \"hasNext\", \"()Z\" );\n\tjboolean bHasNext = env->CallBooleanMethod( envptr, deviceListIterator, MethodhasNext );\n\n\tats+=sprintf(ats, \"Has Devices: %d\\n\", bHasNext );\n\n\tjmethodID Methodnext = env->GetMethodID( envptr, ClassIterator, \"next\", \"()Ljava/lang/Object;\" );\n\n\tjclass ClassUsbDevice = env->FindClass( envptr, \"android/hardware/usb/UsbDevice\" );\n\tjclass ClassUsbInterface = env->FindClass( envptr, \"android/hardware/usb/UsbInterface\" );\n\tjclass ClassUsbEndpoint = env->FindClass( envptr, \"android/hardware/usb/UsbEndpoint\" );\n\tjclass ClassUsbDeviceConnection = env->FindClass( envptr, \"android/hardware/usb/UsbDeviceConnection\" );\n\tjmethodID MethodgetDeviceName = env->GetMethodID( envptr, ClassUsbDevice, \"getDeviceName\", \"()Ljava/lang/String;\" );\n\tjmethodID MethodgetVendorId = env->GetMethodID( envptr, ClassUsbDevice, \"getVendorId\", \"()I\" );\n\tjmethodID MethodgetProductId = env->GetMethodID( envptr, ClassUsbDevice, \"getProductId\", \"()I\" );\n\tjmethodID MethodgetInterfaceCount = env->GetMethodID( envptr, ClassUsbDevice, \"getInterfaceCount\", \"()I\" );\n\tjmethodID MethodgetInterface = env->GetMethodID( envptr, ClassUsbDevice, \"getInterface\", \"(I)Landroid/hardware/usb/UsbInterface;\" );\n\n\tjmethodID MethodgetEndpointCount = env->GetMethodID( envptr, ClassUsbInterface, \"getEndpointCount\", \"()I\" );\n\tjmethodID MethodgetEndpoint = env->GetMethodID( envptr, ClassUsbInterface, \"getEndpoint\", \"(I)Landroid/hardware/usb/UsbEndpoint;\" );\n\n\tjmethodID MethodgetAddress = env->GetMethodID( envptr, ClassUsbEndpoint, \"getAddress\", \"()I\" );\n\tjmethodID MethodgetMaxPacketSize = env->GetMethodID( envptr, ClassUsbEndpoint, \"getMaxPacketSize\", \"()I\" );\n\n\tjobject matchingDevice = 0;\n\tjobject matchingInterface = 0;\n\n\twhile( bHasNext )\n\t{\n\t\t//  UsbDevice device = deviceIterator.next();\n    \t//\tLog.i(TAG,\"Model: \" + device.getDeviceName());\n\t\tjobject device = env->CallObjectMethod( envptr, deviceListIterator, Methodnext );\n\t\tuint16_t vendorId = env->CallIntMethod( envptr, device, MethodgetVendorId );\n\t\tuint16_t productId = env->CallIntMethod( envptr, device, MethodgetProductId );\n\t\tint ifaceCount = env->CallIntMethod( envptr, device, MethodgetInterfaceCount );\n\t\tconst char *strdevname = env->GetStringUTFChars(envptr, env->CallObjectMethod( envptr, device, MethodgetDeviceName ), 0);\n\t\tats+=sprintf(ats, \"%s,%04x:%04x(%d)\\n\", strdevname,\n\t\t\tvendorId,\n\t\t\tproductId, ifaceCount );\n\n\t\tif( vendorId == vid && productId == pid )\n\t\t{\n\t\t\tif( ifaceCount )\n\t\t\t{\n\t\t\t\tmatchingDevice = device;\n\t\t\t\tmatchingInterface = env->CallObjectMethod( envptr, device, MethodgetInterface, 0 );\n\t\t\t}\n\t\t}\n\n\t\tbHasNext = env->CallBooleanMethod( envptr, deviceListIterator, MethodhasNext );\n\t}\n\t\n\tjobject matchingEp = 0;\n\n\tif( matchingInterface )\n\t{\n\t\t//matchingInterface is of type android/hardware/usb/UsbInterface\n\t\tint epCount = env->CallIntMethod( envptr, matchingInterface, MethodgetEndpointCount );\n\t\tats+=sprintf(ats, \"Found device %d eps\\n\", epCount );\n\t\tint i;\n\t\tfor( i = 0; i < epCount; i++ )\n\t\t{\n\t\t\tjobject endpoint = env->CallObjectMethod( envptr, matchingInterface, MethodgetEndpoint, i );\n\t\t\tjint epnum = env->CallIntMethod( envptr, endpoint, MethodgetAddress );\n\t\t\tjint mps = env->CallIntMethod( envptr, endpoint, MethodgetMaxPacketSize );\n\t\t\tif( epnum == 0x02 ) matchingEp = endpoint;\n\t\t\tats+=sprintf(ats, \"%p: %02x: MPS: %d (%c)\\n\", endpoint, epnum, mps, (matchingEp == endpoint)?'*':' ' );\n\t\t}\t\t\t\n\t}\n\n\tjmethodID MethodopenDevice = env->GetMethodID( envptr, ClassUsbManager, \"openDevice\", \"(Landroid/hardware/usb/UsbDevice;)Landroid/hardware/usb/UsbDeviceConnection;\" );\n\tjmethodID MethodrequestPermission = env->GetMethodID( envptr, ClassUsbManager, \"requestPermission\", \"(Landroid/hardware/usb/UsbDevice;Landroid/app/PendingIntent;)V\" );\n\tjmethodID MethodhasPermission = env->GetMethodID( envptr, ClassUsbManager, \"hasPermission\", \"(Landroid/hardware/usb/UsbDevice;)Z\" );\n\tjmethodID MethodclaimInterface = env->GetMethodID( envptr, ClassUsbDeviceConnection, \"claimInterface\", \"(Landroid/hardware/usb/UsbInterface;Z)Z\" );\n\tjmethodID MethodsetInterface = env->GetMethodID( envptr, ClassUsbDeviceConnection, \"setInterface\", \"(Landroid/hardware/usb/UsbInterface;)Z\" );\n\tjmethodID MethodgetFileDescriptor = env->GetMethodID( envptr, ClassUsbDeviceConnection, \"getFileDescriptor\", \"()I\" );\n\t//jmethodID MethodbulkTransfer = env->GetMethodID( envptr, ClassUsbDeviceConnection, \"bulkTransfer\", \"(Landroid/hardware/usb/UsbEndpoint;[BII)I\" );  \n\n\t//see https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/hardware/usb/UsbDeviceConnection.java\n\t//Calls: native_bulk_request -> android_hardware_UsbDeviceConnection_bulk_request -> usb_device_bulk_transfer\n\t//\t\t\t\tUsbEndpoint endpoint, byte[] buffer, int length, int timeout\n\t//bulkTransfer(UsbEndpoint endpoint, byte[] buffer, int length, int timeout) \n\n\t//UsbDeviceConnection bulkTransfer\n\n\tif( matchingEp && matchingDevice )\n\t{\n\t\t//UsbDeviceConnection deviceConnection = manager.openDevice( device )\n\t\tdeviceConnection = env->CallObjectMethod( envptr, manager, MethodopenDevice, matchingDevice );\n\t\tjint epnum = env->CallIntMethod( envptr, matchingEp, MethodgetAddress );\n\n\t\tif( !deviceConnection )\n\t\t{\n\t\t\t// \thasPermission(UsbDevice device) \n\n\t\t\tif( OGGetAbsoluteTime() - dTimeOfLastAsk < 5 )\n\t\t\t{\n\t\t\t\tats+=sprintf(ats, \"Asked for permission.  Waiting to ask again.\" );\n\t\t\t}\n\t\t\telse if( env->CallBooleanMethod( envptr, manager, MethodhasPermission, matchingDevice ) )\n\t\t\t{\n\t\t\t\tats+=sprintf(ats, \"Has permission - disconnected?\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//android.app.PendingIntent currently setting to 0 (null) seems not to cause crashes, but does force lock screen to happen.\n\t\t\t\t//Because the screen locks we need to do a much more complicated operation, generating a PendingIntent.  See Below.\n\t\t\t\t//  \t\t\tenv->CallVoidMethod( envptr, manager, MethodrequestPermission, matchingDevice, 0 );\n\n\t\t\t\t//This part mimiced off of:\n\t\t\t\t//https://www.programcreek.com/java-api-examples/?class=android.hardware.usb.UsbManager&method=requestPermission\n\t\t\t\t// manager.requestPermission(device, PendingIntent.getBroadcast(context, 0, new Intent(MainActivity.ACTION_USB_PERMISSION), 0));\n\t\t\t\tjclass ClassPendingIntent = env->FindClass( envptr, \"android/app/PendingIntent\" );\n\t\t\t\tjclass ClassIntent = env->FindClass(envptr, \"android/content/Intent\");\n\t\t\t\tjmethodID newIntent = env->GetMethodID(envptr, ClassIntent, \"<init>\", \"(Ljava/lang/String;)V\");\n\t\t\t\tjstring ACTION_USB_PERMISSION = env->NewStringUTF( envptr, \"com.android.recipes.USB_PERMISSION\" );\n\t\t\t\tjobject intentObject = env->NewObject(envptr, ClassIntent, newIntent, ACTION_USB_PERMISSION);\n\n\t\t\t\tjmethodID MethodgetBroadcast = env->GetStaticMethodID( envptr, ClassPendingIntent, \"getBroadcast\", \n\t\t\t\t\t\"(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;\" );\n\t\t\t\tjobject pi = env->CallStaticObjectMethod( envptr, ClassPendingIntent, MethodgetBroadcast, lNativeActivity, 0, intentObject, 0 );\n\n\t\t\t\t//This actually requests permission.\n\t\t\t\tenv->CallVoidMethod( envptr, manager, MethodrequestPermission, matchingDevice, pi );\n\t\t\t\tdTimeOfLastAsk = OGGetAbsoluteTime();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Because we want to read and write to an interrupt endpoint, we need to claim the interface - it seems setting interfaces is insufficient here.\n\t\t\tjboolean claimOk = env->CallBooleanMethod( envptr, deviceConnection, MethodclaimInterface, matchingInterface, 1 );\n\t\t\t//jboolean claimOk = env->CallBooleanMethod( envptr, deviceConnection, MethodsetInterface, matchingInterface );\n\t\t\t//jboolean claimOk = 1;\n\t\t\tif( claimOk )\n\t\t\t{\n\t\t\t\tdeviceConnectionFD = env->CallIntMethod( envptr, deviceConnection, MethodgetFileDescriptor );\n\t\t\t}\n\n\t\t\tats+=sprintf(ats, \"DC: %p; Claim: %d; FD: %d\\n\", deviceConnection, claimOk, deviceConnectionFD );\n\t\t}\n\n\t}\n\n\tjnii->DetachCurrentThread( jniiptr );\n\treturn (!deviceConnectionFD)?-5:0;\n}\n\n"
        },
        {
          "name": "android_usb_devices.h",
          "type": "blob",
          "size": 0.4833984375,
          "content": "//Copyright 2020 <>< Charles Lohr, You may use this file and library freely under the MIT/x11, NewBSD or ColorChord Licenses.\n\n#ifndef _ANDROID_USB_DEVICES_H\n#define _ANDROID_USB_DEVICES_H\n\n#include <asset_manager.h>\n#include <asset_manager_jni.h>\n#include <android_native_app_glue.h>\n\nint RequestPermissionOrGetConnectionFD( char * debug_status, uint16_t vid, uint16_t pid );\nvoid DisconnectUSB(); //Disconnect from USB\n\nextern jobject deviceConnection;\nextern int deviceConnectionFD;\n\n#endif\n\n"
        },
        {
          "name": "cnfa",
          "type": "commit",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "rawdraw",
          "type": "commit",
          "content": null
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 20.0458984375,
          "content": "//Copyright (c) 2011-2020 <>< Charles Lohr - Under the MIT/x11 or NewBSD License you choose.\n// NO WARRANTY! NO GUARANTEE OF SUPPORT! USE AT YOUR OWN RISK\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include \"os_generic.h\"\n#include <GLES3/gl3.h>\n#include <android/asset_manager.h>\n#include <android/asset_manager_jni.h>\n#include <android_native_app_glue.h>\n#include <android/sensor.h>\n#include <byteswap.h>\n#include <errno.h>\n#include <fcntl.h>\n#include \"CNFGAndroid.h\"\n\n//#define CNFA_IMPLEMENTATION\n#define CNFG_IMPLEMENTATION\n#define CNFG3D\n\n//#include \"cnfa/CNFA.h\"\n#include \"CNFG.h\"\n\n#define WEBVIEW_NATIVE_ACTIVITY_IMPLEMENTATION\n#include \"webview_native_activity.h\"\n\nfloat mountainangle;\nfloat mountainoffsetx;\nfloat mountainoffsety;\n\nASensorManager * sm;\nconst ASensor * as;\nbool no_sensor_for_gyro = false;\nASensorEventQueue* aeq;\nALooper * l;\n\nWebViewNativeActivityObject MyWebView;\n\nconst uint32_t SAMPLE_RATE = 44100;\nconst uint16_t SAMPLE_COUNT = 512;\nuint32_t stream_offset = 0;\nuint16_t audio_frequency;\n\nvoid SetupIMU()\n{\n\tsm = ASensorManager_getInstanceForPackage(\"gyroscope\");\n\tas = ASensorManager_getDefaultSensor( sm, ASENSOR_TYPE_GYROSCOPE );\n\tno_sensor_for_gyro = as == NULL;\n\tl = ALooper_prepare( ALOOPER_PREPARE_ALLOW_NON_CALLBACKS );\n\taeq = ASensorManager_createEventQueue( sm, (ALooper*)&l, 0, 0, 0 ); //XXX??!?! This looks wrong.\n\tif(!no_sensor_for_gyro) {\n\t\tASensorEventQueue_enableSensor( aeq, as);\n\t\tprintf( \"setEvent Rate: %d\\n\", ASensorEventQueue_setEventRate( aeq, as, 10000 ) );\n\t}\n\n}\n\nfloat accx, accy, accz;\nint accs;\n\nvoid AccCheck()\n{\n\tif(no_sensor_for_gyro) {\n\t\treturn;\n\t}\n\n\tASensorEvent evt;\n\tdo\n\t{\n\t\tssize_t s = ASensorEventQueue_getEvents( aeq, &evt, 1 );\n\t\tif( s <= 0 ) break;\n\t\taccx = evt.vector.v[0];\n\t\taccy = evt.vector.v[1];\n\t\taccz = evt.vector.v[2];\n\t\tmountainangle /*degrees*/ -= accz;// * 3.1415 / 360.0;// / 100.0;\n\t\tmountainoffsety += accy;\n\t\tmountainoffsetx += accx;\n\t\taccs++;\n\t} while( 1 );\n}\n\nunsigned frames = 0;\nunsigned long iframeno = 0;\n\nvoid AndroidDisplayKeyboard(int pShow);\n\nint lastbuttonx = 0;\nint lastbuttony = 0;\nint lastmotionx = 0;\nint lastmotiony = 0;\nint lastbid = 0;\nint lastmask = 0;\nint lastkey, lastkeydown;\n\nstatic int keyboard_up;\nuint8_t buttonstate[8];\n\nvoid HandleKey( int keycode, int bDown )\n{\n\tlastkey = keycode;\n\tlastkeydown = bDown;\n\tif( keycode == 10 && !bDown ) { keyboard_up = 0; AndroidDisplayKeyboard( keyboard_up );  }\n\n\tif( keycode == 4 ) { AndroidSendToBack( 1 ); } //Handle Physical Back Button.\n}\n\nvoid HandleButton( int x, int y, int button, int bDown )\n{\n\tbuttonstate[button] = bDown;\n\tlastbid = button;\n\tlastbuttonx = x;\n\tlastbuttony = y;\n\n\tif( bDown ) { keyboard_up = !keyboard_up; AndroidDisplayKeyboard( keyboard_up ); }\n}\n\nvoid HandleMotion( int x, int y, int mask )\n{\n\tlastmask = mask;\n\tlastmotionx = x;\n\tlastmotiony = y;\n}\n\n//writes the text to a file to path (example): /storage/emulated/0/Android/data/org.yourorg.cnfgtest/files\n// You would not normally want to do this, but it's an example of how to do local storage.\nvoid Log(const char *fmt, ...)\n{\n\tconst char* getpath = AndroidGetExternalFilesDir();\n\tchar buffer[2048];\n\tsnprintf(buffer, sizeof(buffer), \"%s/log.txt\", getpath);\n\tFILE *f = fopen(buffer, \"w\");\n\tif (f == NULL)\n\t{\n\t\texit(1);\n\t}\n\n\tva_list arg;\n\tva_start(arg, fmt);\n\tvsnprintf(buffer, sizeof(buffer), fmt, arg);\n\tva_end(arg);\t\n\n\tfprintf(f, \"%s\\n\", buffer);\n\n\tfclose(f);\n}\n#define HMX 162\n#define HMY 162\nshort screenx, screeny;\nfloat Heightmap[HMX*HMY];\n\nextern struct android_app * gapp;\n\nvoid DrawHeightmap()\n{\n\tint x, y;\n\t//float fdt = ((iframeno++)%(360*10))/10.0;\n\n\tmountainangle += .2;\n\tif( mountainangle < 0 ) mountainangle += 360;\n\tif( mountainangle > 360 ) mountainangle -= 360;\n\n\tmountainoffsety = mountainoffsety - ((mountainoffsety-100) * .1);\n\n\tfloat eye[3] = { (float)(sin(mountainangle*(3.14159/180.0))*30*sin(mountainoffsety/100.)), (float)(cos(mountainangle*(3.14159/180.0))*30*sin(mountainoffsety/100.)), (float)(30*cos(mountainoffsety/100.)) };\n\tfloat at[3] = { 0,0, 0 };\n\tfloat up[3] = { 0,0, 1 };\n\n\ttdSetViewport( -1, -1, 1, 1, screenx, screeny );\n\n\ttdMode( tdPROJECTION );\n\ttdIdentity( gSMatrix );\n\ttdPerspective( 30, ((float)screenx)/((float)screeny), .1, 200., gSMatrix );\n\n\ttdMode( tdMODELVIEW );\n\ttdIdentity( gSMatrix );\n\ttdTranslate( gSMatrix, 0, 0, -40 );\n\ttdLookAt( gSMatrix, eye, at, up );\n\n\tfloat scale = 60./HMX;\n\n\tfor( x = 0; x < HMX-1; x++ )\n\tfor( y = 0; y < HMY-1; y++ )\n\t{\n\t\tfloat tx = x-HMX/2;\n\t\tfloat ty = y-HMY/2;\n\t\tfloat pta[3];\n\t\tfloat ptb[3];\n\t\tfloat ptc[3];\n\t\tfloat ptd[3];\n\n\t\tfloat normal[3];\n\t\tfloat lightdir[3] = { .6, -.6, 1 };\n\t\tfloat tmp1[3];\n\t\tfloat tmp2[3];\n\n\t\tRDPoint pto[6];\n\n\t\tpta[0] = (tx+0)*scale; pta[1] = (ty+0)*scale; pta[2] = Heightmap[(x+0)+(y+0)*HMX]*scale;\n\t\tptb[0] = (tx+1)*scale; ptb[1] = (ty+0)*scale; ptb[2] = Heightmap[(x+1)+(y+0)*HMX]*scale;\n\t\tptc[0] = (tx+0)*scale; ptc[1] = (ty+1)*scale; ptc[2] = Heightmap[(x+0)+(y+1)*HMX]*scale;\n\t\tptd[0] = (tx+1)*scale; ptd[1] = (ty+1)*scale; ptd[2] = Heightmap[(x+1)+(y+1)*HMX]*scale;\n\n\t\ttdPSub( pta, ptb, tmp2 );\n\t\ttdPSub( ptc, ptb, tmp1 );\n\t\ttdCross( tmp1, tmp2, normal );\n\t\ttdNormalizeSelf( normal );\n\n\t\ttdFinalPoint( pta, pta );\n\t\ttdFinalPoint( ptb, ptb );\n\t\ttdFinalPoint( ptc, ptc );\n\t\ttdFinalPoint( ptd, ptd );\n\n\t\tif( pta[2] >= 1.0 ) continue;\n\t\tif( ptb[2] >= 1.0 ) continue;\n\t\tif( ptc[2] >= 1.0 ) continue;\n\t\tif( ptd[2] >= 1.0 ) continue;\n\n\t\tif( pta[2] < 0 ) continue;\n\t\tif( ptb[2] < 0 ) continue;\n\t\tif( ptc[2] < 0 ) continue;\n\t\tif( ptd[2] < 0 ) continue;\n\n\t\tpto[0].x = pta[0]; pto[0].y = pta[1];\n\t\tpto[1].x = ptb[0]; pto[1].y = ptb[1];\n\t\tpto[2].x = ptd[0]; pto[2].y = ptd[1];\n\n\t\tpto[3].x = ptc[0]; pto[3].y = ptc[1];\n\t\tpto[4].x = ptd[0]; pto[4].y = ptd[1];\n\t\tpto[5].x = pta[0]; pto[5].y = pta[1];\n\n//\t\tCNFGColor(((x+y)&1)?0xFFFFFF:0x000000);\n\n\t\tfloat bright = tdDot( normal, lightdir );\n\t\tif( bright < 0 ) bright = 0;\n\t\tCNFGColor( 0xff | ( ( (int)( bright * 90 ) ) << 24 ) );\n\n//\t\tCNFGTackPoly( &pto[0], 3 );\t\tCNFGTackPoly( &pto[3], 3 );\n\t\tCNFGTackSegment( pta[0], pta[1], ptb[0], ptb[1] );\n\t\tCNFGTackSegment( pta[0], pta[1], ptc[0], ptc[1] );\n\t\tCNFGTackSegment( ptb[0], ptb[1], ptc[0], ptc[1] );\n\t\n\t}\n}\n\n\nint HandleDestroy()\n{\n\tprintf( \"Destroying\\n\" );\n\treturn 0;\n}\n\nvolatile int suspended;\n\nvoid HandleSuspend()\n{\n\tsuspended = 1;\n}\n\nvoid HandleResume()\n{\n\tsuspended = 0;\n}\n\n/*\nvoid AudioCallback( struct CNFADriver * sd, short * out, short * in, int framesp, int framesr )\n{\n\tmemset(out, 0, framesp*sizeof(uint16_t));\n\tif(suspended) return;\n\tif(!buttonstate[1]) return; // play audio only if ~touching with two fingers\n\taudio_frequency = 440;\n\tfor(uint32_t i = 0; i < framesp; i++) {\n\t\tint16_t sample = INT16_MAX * sin(audio_frequency*(2*M_PI)*(stream_offset+i)/SAMPLE_RATE);\n\t\tout[i] = sample;\n\t}\n\tstream_offset += framesp;\n}\n*/\n\nvoid MakeNotification( const char * channelID, const char * channelName, const char * title, const char * message )\n{\n\tstatic int id;\n\tid++;\n\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjstring channelIDStr = env->NewStringUTF( ENVCALL channelID );\n\tjstring channelNameStr = env->NewStringUTF( ENVCALL channelName );\n\n\t// Runs getSystemService(Context.NOTIFICATION_SERVICE).\n\tjclass NotificationManagerClass = env->FindClass( ENVCALL \"android/app/NotificationManager\" );\n\tjclass activityClass = env->GetObjectClass( ENVCALL gapp->activity->clazz );\n\tjmethodID MethodGetSystemService = env->GetMethodID( ENVCALL activityClass, \"getSystemService\", \"(Ljava/lang/String;)Ljava/lang/Object;\");\n\tjstring notificationServiceName = env->NewStringUTF( ENVCALL \"notification\" );\n\tjobject notificationServiceObj = env->CallObjectMethod( ENVCALL gapp->activity->clazz, MethodGetSystemService, notificationServiceName);\n\n\t// create the Notification channel.\n\tjclass notificationChannelClass = env->FindClass( ENVCALL \"android/app/NotificationChannel\" );\n\tjmethodID notificationChannelConstructorID = env->GetMethodID( ENVCALL notificationChannelClass, \"<init>\", \"(Ljava/lang/String;Ljava/lang/CharSequence;I)V\" );\n\tjobject notificationChannelObj = env->NewObject( ENVCALL notificationChannelClass, notificationChannelConstructorID, channelIDStr, channelNameStr, 3 ); // IMPORTANCE_DEFAULT\n\tjmethodID createNotificationChannelID = env->GetMethodID( ENVCALL NotificationManagerClass, \"createNotificationChannel\", \"(Landroid/app/NotificationChannel;)V\" );\n\tenv->CallVoidMethod( ENVCALL notificationServiceObj, createNotificationChannelID, notificationChannelObj );\n\n\tenv->DeleteLocalRef( ENVCALL channelNameStr );\n\tenv->DeleteLocalRef( ENVCALL notificationChannelObj );\n\n\t// Create the Notification builder.\n\tjclass classBuilder = env->FindClass( ENVCALL \"android/app/Notification$Builder\" );\n\tjstring titleStr = env->NewStringUTF( ENVCALL title );\n\tjstring messageStr = env->NewStringUTF( ENVCALL message );\n\tjmethodID eventConstructor = env->GetMethodID( ENVCALL classBuilder, \"<init>\", \"(Landroid/content/Context;Ljava/lang/String;)V\" );\n\tjobject eventObj = env->NewObject( ENVCALL classBuilder, eventConstructor, gapp->activity->clazz, channelIDStr );\n\tjmethodID setContentTitleID = env->GetMethodID( ENVCALL classBuilder, \"setContentTitle\", \"(Ljava/lang/CharSequence;)Landroid/app/Notification$Builder;\" );\n\tjmethodID setContentTextID = env->GetMethodID( ENVCALL classBuilder, \"setContentText\", \"(Ljava/lang/CharSequence;)Landroid/app/Notification$Builder;\" );\n\tjmethodID setSmallIconID = env->GetMethodID( ENVCALL classBuilder, \"setSmallIcon\", \"(I)Landroid/app/Notification$Builder;\" );\n\n\t// You could do things like setPriority, or setContentIntent if you want it to do something when you click it.\n\n\tenv->CallObjectMethod( ENVCALL eventObj, setContentTitleID, titleStr );\n\tenv->CallObjectMethod( ENVCALL eventObj, setContentTextID, messageStr );\n\tenv->CallObjectMethod( ENVCALL eventObj, setSmallIconID, 17301504 ); // R.drawable.alert_dark_frame\n\n\t// eventObj.build()\n\tjmethodID buildID = env->GetMethodID( ENVCALL classBuilder, \"build\", \"()Landroid/app/Notification;\" );\n\tjobject notification = env->CallObjectMethod( ENVCALL eventObj, buildID );\n\n\t// NotificationManager.notify(...)\n\tjmethodID notifyID = env->GetMethodID( ENVCALL NotificationManagerClass, \"notify\", \"(ILandroid/app/Notification;)V\" );\n\tenv->CallVoidMethod( ENVCALL notificationServiceObj, notifyID, id, notification );\n\n\tenv->DeleteLocalRef( ENVCALL notification );\n\tenv->DeleteLocalRef( ENVCALL titleStr );\n\tenv->DeleteLocalRef( ENVCALL activityClass );\n\tenv->DeleteLocalRef( ENVCALL messageStr );\n\tenv->DeleteLocalRef( ENVCALL channelIDStr );\n\tenv->DeleteLocalRef( ENVCALL NotificationManagerClass );\n\tenv->DeleteLocalRef( ENVCALL notificationServiceObj );\n\tenv->DeleteLocalRef( ENVCALL notificationServiceName );\n\n}\n\nvoid HandleThisWindowTermination()\n{\n\tsuspended = 1;\n}\n\n\nuint32_t randomtexturedata[256*256];\nuint32_t webviewdata[500*500];\nchar fromJSBuffer[128];\n\nvoid CheckWebView( void * v )\n{\n\tstatic int runno = 0;\n\tWebViewNativeActivityObject * wvn = (WebViewNativeActivityObject*)v;\n\tif( WebViewGetProgress( wvn ) != 100 ) return;\n\n\trunno++;\n\tif( runno == 1 )\n\t{\n\t\t// The attach (initial) message payload has no meaning.\n\t\tWebViewPostMessage( wvn, \"\", 1 );\n\t}\n\telse\n\t{\n\t\t// Invoke JavaScript, which calls a function to send a webmessage\n\t\t// back into C land.\n\t\tWebViewExecuteJavascript( wvn, \"SendMessageToC();\" );\n\t\t\n\t\t// Send a WebMessage into the JavaScript code.\n\t\tchar st[128];\n\t\tsprintf( st, \"Into JavaScript %d\\n\", runno );\n\t\tWebViewPostMessage( wvn, st, 0 );\n\t}\n}\n\njobject g_attachLooper;\n\nvoid SetupWebView( void * v )\n{\n\tWebViewNativeActivityObject * wvn = (WebViewNativeActivityObject*)v;\n\n\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\twhile( g_attachLooper == 0 ) usleep(1);\n\tWebViewCreate( wvn, \"file:///android_asset/test.html\", g_attachLooper, 500, 500 );\n\t//WebViewCreate( wvn, \"about:blank\", g_attachLooper, 500, 500 );\n}\n\n\npthread_t jsthread;\n\nvoid * JavscriptThread( void * v )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\t// Create a looper on this thread...\n\tjclass LooperClass = env->FindClass(envptr, \"android/os/Looper\");\n\tjmethodID myLooperMethod = env->GetStaticMethodID(envptr, LooperClass, \"myLooper\", \"()Landroid/os/Looper;\");\n\tjobject thisLooper = env->CallStaticObjectMethod( envptr, LooperClass, myLooperMethod );\n\tif( !thisLooper )\n\t{\n\t\tjmethodID prepareMethod = env->GetStaticMethodID(envptr, LooperClass, \"prepare\", \"()V\");\n\t\tenv->CallStaticVoidMethod( envptr, LooperClass, prepareMethod );\n\t\tthisLooper = env->CallStaticObjectMethod( envptr, LooperClass, myLooperMethod );\n\t\tg_attachLooper = env->NewGlobalRef(envptr, thisLooper);\n\t}\n\n\tjmethodID getQueueMethod = env->GetMethodID( envptr, LooperClass, \"getQueue\", \"()Landroid/os/MessageQueue;\" );\n\tjobject   lque = env->CallObjectMethod( envptr, g_attachLooper, getQueueMethod );\n\n\tjclass MessageQueueClass = env->FindClass(envptr, \"android/os/MessageQueue\");\n\tjmethodID nextMethod = env->GetMethodID( envptr, MessageQueueClass, \"next\", \"()Landroid/os/Message;\" );\n\t\n\tjclass MessageClass = env->FindClass(envptr, \"android/os/Message\");\n\tjfieldID objid = env->GetFieldID( envptr, MessageClass, \"obj\", \"Ljava/lang/Object;\" );\n\tjclass PairClass = env->FindClass(envptr, \"android/util/Pair\");\n\tjfieldID pairfirst  = env->GetFieldID( envptr, PairClass, \"first\", \"Ljava/lang/Object;\" );\n\n\twhile(1)\n\t{\n\t\t// Instead of using Looper::loop(), we just call next on the looper object.\n\t\tjobject msg = env->CallObjectMethod( envptr, lque, nextMethod );\n\t\tjobject innerObj = env->GetObjectField( envptr, msg, objid );\n\t\tconst char * name;\n\t\tjstring strObj;\n\t\tjclass innerClass;\n\t\t\n\t\t// Check Object Type\n\t\t{\n\t\t\tinnerClass = env->GetObjectClass( envptr, innerObj );\n\t\t\tjmethodID mid = env->GetMethodID( envptr, innerClass, \"getClass\", \"()Ljava/lang/Class;\");\n\t\t\tjobject clsObj = env->CallObjectMethod( envptr, innerObj, mid );\n\t\t\tjclass clazzz = env->GetObjectClass( envptr, clsObj );\n\t\t\tmid = env->GetMethodID(envptr, clazzz, \"getName\", \"()Ljava/lang/String;\");\n\t\t\tstrObj = (jstring)env->CallObjectMethod( envptr, clsObj, mid);\n\t\t\tname = env->GetStringUTFChars( envptr, strObj, 0);\n\t\t\tenv->DeleteLocalRef( envptr, clsObj );\n\t\t\tenv->DeleteLocalRef( envptr, clazzz );\n\t\t}\n\n\t\tif( strcmp( name, \"z5\" ) == 0 || strcmp( name, \"g5\" ) == 0 )\n\t\t{\n\t\t\t// Special, Some Androids (notably Meta Quest) use a different private message type.\n\t\t\tjfieldID mstrf  = env->GetFieldID( envptr, innerClass, \"a\", \"[B\" );\n\t\t\tjbyteArray jba = (jstring)env->GetObjectField(envptr, innerObj, mstrf );\n\t\t\tint len = env->GetArrayLength( envptr, jba );\n\t\t\tjboolean isCopy = 0;\n\t\t\tjbyte * bufferPtr = env->GetByteArrayElements(envptr, jba, &isCopy);\n\n\t\t\tif( len >= 6 )\n\t\t\t{\n\t\t\t\tconst char *descr = (const char*)bufferPtr + 6;\n\t\t\t\tchar tcpy[len-5];\n\t\t\t\tmemcpy( tcpy, descr, len-6 );\n\t\t\t\ttcpy[len-6] = 0;\n\t\t\t\tsnprintf( fromJSBuffer, sizeof( fromJSBuffer)-1, \"WebMessage: %s\\n\", tcpy );\n\n\t\t\t\tenv->DeleteLocalRef( envptr, jba );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjobject MessagePayload = env->GetObjectField( envptr, innerObj, pairfirst );\n\t\t\t// MessagePayload is a org.chromium.content_public.browser.MessagePayload\n\n\t\t\tjclass mpclass = env->GetObjectClass( envptr, MessagePayload );\n\n\t\t\t// Get field \"b\" which is the web message payload.\n\t\t\t// If you are using binary sockets, it will be in `c` and be a byte array.\n\t\t\tjfieldID mstrf  = env->GetFieldID( envptr, mpclass, \"b\", \"Ljava/lang/String;\" );\n\t\t\tjstring strObjDescr = (jstring)env->GetObjectField(envptr, MessagePayload, mstrf );\n\n\t\t\tconst char *descr = env->GetStringUTFChars( envptr, strObjDescr, 0);\n\t\t\tsnprintf( fromJSBuffer, sizeof( fromJSBuffer)-1, \"WebMessage: %s\\n\", descr );\n\n\t\t\tenv->ReleaseStringUTFChars(envptr, strObjDescr, descr);\n\t\t\tenv->DeleteLocalRef( envptr, strObjDescr );\n\t\t\tenv->DeleteLocalRef( envptr, MessagePayload );\n\t\t\tenv->DeleteLocalRef( envptr, mpclass );\n\t\t}\n\t\tenv->ReleaseStringUTFChars(envptr, strObj, name);\n\t\tenv->DeleteLocalRef( envptr, strObj );\n\t\tenv->DeleteLocalRef( envptr, msg );\n\t\tenv->DeleteLocalRef( envptr, innerObj );\n\t\tenv->DeleteLocalRef( envptr, innerClass );\n\t}\n}\n\nvoid SetupJSThread()\n{\n\tpthread_create( &jsthread, 0, JavscriptThread, 0 );\n}\n\nint main( int argc, char ** argv )\n{\n\tint x, y;\n\tdouble ThisTime;\n\tdouble LastFPSTime = OGGetAbsoluteTime();\n\n\tLog( \"Starting Up\" );\n\n\tCNFGBGColor = 0x000040ff;\n\tCNFGSetupFullscreen( \"Test Bench\", 0 );\n\t\n\tHandleWindowTermination = HandleThisWindowTermination;\n\n\tfor( x = 0; x < HMX; x++ )\n\tfor( y = 0; y < HMY; y++ )\n\t{\n\t\tHeightmap[x+y*HMX] = tdPerlin2D( x, y )*8.;\n\t}\n\n\tconst char * assettext = \"Not Found\";\n\tAAsset * file = AAssetManager_open( gapp->activity->assetManager, \"asset.txt\", AASSET_MODE_BUFFER );\n\tif( file )\n\t{\n\t\tsize_t fileLength = AAsset_getLength(file);\n\t\tchar * temp = (char*)malloc( fileLength + 1);\n\t\tmemcpy( temp, AAsset_getBuffer( file ), fileLength );\n\t\ttemp[fileLength] = 0;\n\t\tassettext = temp;\n\t}\n\n\tSetupIMU();\n\t\n\t// Disabled, for now.\n\t//InitCNFAAndroid( AudioCallback, \"A Name\", SAMPLE_RATE, 0, 1, 0, SAMPLE_COUNT, 0, 0, 0 );\n\n\tSetupJSThread();\n\n\t// Create webview and wait for its completion\n\tRunCallbackOnUIThread( SetupWebView, &MyWebView );\n\twhile( !MyWebView.WebViewObject ) usleep(1);\n\n\tLog( \"Startup Complete\" );\n\n\twhile(1)\n\t{\n\t\tint i;\n\t\tiframeno++;\n\n\t\tif( iframeno == 200 )\n\t\t{\n\t\t\tMakeNotification( \"default\", \"rawdraw alerts\", \"rawdraw\", \"Hit frame two hundred\\nNew Line\" );\n\t\t}\n\n\t\tCNFGHandleInput();\n\t\tAccCheck();\n\n\t\tif( suspended ) { usleep(50000); continue; }\n\n\t\tRunCallbackOnUIThread( (void(*)(void*))WebViewRequestRenderToCanvas, &MyWebView );\n\t\tRunCallbackOnUIThread( CheckWebView, &MyWebView );\n\n\t\tCNFGClearFrame();\n\t\tCNFGColor( 0xFFFFFFFF );\n\t\tCNFGGetDimensions( &screenx, &screeny );\n\n\t\t// Mesh in background\n\t\tCNFGSetLineWidth( 9 );\n\t\tDrawHeightmap();\n\t\tCNFGPenX = 0; CNFGPenY = 400;\n\t\tCNFGColor( 0xffffffff );\n\t\tCNFGDrawText( assettext, 15 );\n\t\tCNFGFlushRender();\n\n\t\tCNFGPenX = 0; CNFGPenY = 480;\n\t\tchar st[50];\n\t\tsprintf( st, \"%dx%d %d %d %d %d %d %d\\n%d %d\\n%5.2f %5.2f %5.2f %d\", screenx, screeny, lastbuttonx, lastbuttony, lastmotionx, lastmotiony, lastkey, lastkeydown, lastbid, lastmask, accx, accy, accz, accs );\n\t\tCNFGDrawText( st, 10 );\n\t\tCNFGSetLineWidth( 2 );\n\n\t\t// Square behind text\n\t\tCNFGColor( 0x303030ff );\n\t\tCNFGTackRectangle( 600, 0, 950, 350);\n\n\t\tCNFGPenX = 10; CNFGPenY = 10;\n\n\t\t// Text\n\t\tCNFGColor( 0xffffffff );\n\t\tfor( i = 0; i < 1; i++ )\n\t\t{\n\t\t\tint c;\n\t\t\tchar tw[2] = { 0, 0 };\n\t\t\tfor( c = 0; c < 256; c++ )\n\t\t\t{\n\t\t\t\ttw[0] = c;\n\n\t\t\t\tCNFGPenX = ( c % 16 ) * 20+606;\n\t\t\t\tCNFGPenY = ( c / 16 ) * 20+5;\n\t\t\t\tCNFGDrawText( tw, 4 );\n\t\t\t}\n\t\t}\n\n\t\t// Green triangles\n\t\tCNFGPenX = 0;\n\t\tCNFGPenY = 0;\n\t\tCNFGColor( 0x00FF00FF );\n\n\t\tfor( i = 0; i < 400; i++ )\n\t\t{\n\t\t\tRDPoint pp[3];\n\t\t\tpp[0].x = (short)(50*sin((float)(i+iframeno)*.01) + (i%20)*30);\n\t\t\tpp[0].y = (short)(50*cos((float)(i+iframeno)*.01) + (i/20)*20)+700;\n\t\t\tpp[1].x = (short)(20*sin((float)(i+iframeno)*.01) + (i%20)*30);\n\t\t\tpp[1].y = (short)(50*cos((float)(i+iframeno)*.01) + (i/20)*20)+700;\n\t\t\tpp[2].x = (short)(10*sin((float)(i+iframeno)*.01) + (i%20)*30);\n\t\t\tpp[2].y = (short)(30*cos((float)(i+iframeno)*.01) + (i/20)*20)+700;\n\t\t\tCNFGTackPoly( pp, 3 );\n\t\t}\n\n\t\t// Last WebMessage\n\t\tCNFGColor( 0xFFFFFFFF );\n\t\tCNFGPenX = 0; CNFGPenY = 100;\n\t\tCNFGDrawText( fromJSBuffer, 6 );\n\n\t\tint x, y;\n\t\tfor( y = 0; y < 256; y++ )\n\t\tfor( x = 0; x < 256; x++ )\n\t\t\trandomtexturedata[x+y*256] = x | ((x*394543L+y*355+iframeno*3)<<8);\n\t\tCNFGBlitImage( randomtexturedata, 100, 600, 256, 256 );\n\n\t\tWebViewNativeGetPixels( &MyWebView, webviewdata, 500, 500 );\n\t\tCNFGBlitImage( webviewdata, 500, 640, 500, 500 );\n\n\t\tframes++;\n\t\t//On Android, CNFGSwapBuffers must be called, and CNFGUpdateScreenWithBitmap does not have an implied framebuffer swap.\n\t\tCNFGSwapBuffers();\n\n\t\tThisTime = OGGetAbsoluteTime();\n\t\tif( ThisTime > LastFPSTime + 1 )\n\t\t{\n\t\t\tprintf( \"FPS: %d\\n\", frames );\n\t\t\tframes = 0;\n\t\t\tLastFPSTime+=1;\n\t\t}\n\n\t}\n\n\treturn(0);\n}\n\n"
        },
        {
          "name": "webview_native_activity.h",
          "type": "blob",
          "size": 15.1328125,
          "content": "#ifndef _WEBVIEW_NATIVE_ACTIVITY\n#define _WEBVIEW_NATIVE_ACTIVITY\n\n#include <android/native_activity.h>\n\nextern volatile jobject g_objRootView;\n\ntypedef struct\n{\n\tjobject WebViewObject;\n\tjobjectArray MessageChannels;\n\tjobject BackingBitmap;\n\tjobject BackingCanvas;\n\tint updated_canvas;\n\tint w, h;\n} WebViewNativeActivityObject;\n\n// Must be called from main thread\n\n// initial_url = \"about:blank\" for a java-script only page.  Can also be file:///android_asset/test.html.\n// Loading from \"about:blank\" will make the page ready almost immediately, otherwise it's about 50ms to load.\n// useLooperForWebMessages is required, and must be a global jobject of your preferred looper to handle webmessages.\nvoid WebViewCreate( WebViewNativeActivityObject * w, const char * initial_url, jobject useLooperForWebMessages, int pw, int ph );\nvoid WebViewExecuteJavascript( WebViewNativeActivityObject * obj, const char * js );\n\n// Note: Do not initialize until page reports as 100% loaded, with WebViewGetProgress.\nvoid WebViewPostMessage( WebViewNativeActivityObject * obj, const char * mesg, int initial );\nvoid WebViewRequestRenderToCanvas( WebViewNativeActivityObject * obj );\nint  WebViewGetProgress( WebViewNativeActivityObject * obj );\nchar * WebViewGetLastWindowTitle( WebViewNativeActivityObject * obj );\n\n// Can be called from any thread.\nvoid WebViewNativeGetPixels( WebViewNativeActivityObject * obj, uint32_t * pixel_data, int w, int h );\n\n#ifdef WEBVIEW_NATIVE_ACTIVITY_IMPLEMENTATION\n\nvolatile jobject g_objRootView;\n\nvoid WebViewCreate( WebViewNativeActivityObject * w, const char * initial_url, jobject useLooperForWebMessages, int pw, int ph )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tjobject clazz = gapp->activity->clazz;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tif( g_objRootView == 0 )\n\t{\n\t\tjclass ViewClass = env->FindClass(envptr, \"android/widget/LinearLayout\");\n\t\tjmethodID ViewConstructor = env->GetMethodID(envptr, ViewClass, \"<init>\", \"(Landroid/content/Context;)V\");\n\t\tjclass activityClass = env->FindClass(envptr, \"android/app/Activity\");\n\t\tjmethodID activityGetContextMethod = env->GetMethodID(envptr, activityClass, \"getApplicationContext\", \"()Landroid/content/Context;\");\n\t\tjobject contextObject = env->CallObjectMethod(envptr, clazz, activityGetContextMethod);\n\t\tjobject jv = env->NewObject(envptr, ViewClass, ViewConstructor, contextObject );\n\t\tg_objRootView = env->NewGlobalRef(envptr, jv);\n\n\t\tjclass clszz = env->GetObjectClass(envptr,clazz);\n\t\tjmethodID setContentViewMethod = env->GetMethodID(envptr, clszz, \"setContentView\", \"(Landroid/view/View;)V\");\n\t\tenv->CallVoidMethod(envptr,clazz, setContentViewMethod, g_objRootView );\n\t}\n\n\tjclass WebViewClass = env->FindClass(envptr, \"android/webkit/WebView\");\n\tjclass activityClass = env->FindClass(envptr, \"android/app/Activity\");\n\tjmethodID activityGetContextMethod = env->GetMethodID(envptr, activityClass, \"getApplicationContext\", \"()Landroid/content/Context;\");\n\tjobject contextObject = env->CallObjectMethod(envptr, clazz, activityGetContextMethod);\n\n\tjmethodID WebViewConstructor = env->GetMethodID(envptr, WebViewClass, \"<init>\", \"(Landroid/content/Context;)V\");\n\tjobject wvObj = env->NewObject(envptr, WebViewClass, WebViewConstructor, contextObject );\n\n\t// Unknown reason why - if you don't first load about:blank, it sometimes doesn't render right?\n\t// Even more annoying - you can't pre-use loadUrl if you want to use message channels.\n\tjmethodID WebViewLoadBaseURLMethod = env->GetMethodID(envptr, WebViewClass, \"loadDataWithBaseURL\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V\");\n\tjstring strul = env->NewStringUTF( envptr, \"http://example.com\" );\n\tjstring strdata = env->NewStringUTF( envptr, \"not-yet-loaded\" );\n\tjstring strmime = env->NewStringUTF( envptr, \"text/html\" );\n\tjstring strencoding = env->NewStringUTF( envptr, \"utf8\" );\n\tjstring strhistoryurl = env->NewStringUTF( envptr, \"\" );\n\tenv->CallVoidMethod(envptr, wvObj, WebViewLoadBaseURLMethod, strul, strdata, strmime, strencoding, strhistoryurl );\n\tenv->DeleteLocalRef( envptr, strul );\n\tenv->DeleteLocalRef( envptr, strdata );\n\tenv->DeleteLocalRef( envptr, strmime );\n\tenv->DeleteLocalRef( envptr, strencoding );\n\tenv->DeleteLocalRef( envptr, strhistoryurl );\n\n\t// You have to switch to this to be able to run javascript code.\n\tjmethodID LoadURLMethod = env->GetMethodID(envptr, WebViewClass, \"loadUrl\", \"(Ljava/lang/String;)V\");\n\tjstring strjs = env->NewStringUTF( envptr, initial_url );\n\tenv->CallVoidMethod(envptr, wvObj, LoadURLMethod, strjs );\n\tenv->DeleteLocalRef( envptr, strjs );\n\n\tjmethodID WebViewGetSettingMethod = env->GetMethodID(envptr, WebViewClass, \"getSettings\", \"()Landroid/webkit/WebSettings;\");\n\tjobject websettings = env->CallObjectMethod(envptr, wvObj, WebViewGetSettingMethod );\n\tjclass WebSettingsClass = env->FindClass(envptr, \"android/webkit/WebSettings\");\n\tjmethodID setJavaScriptEnabledMethod = env->GetMethodID(envptr, WebSettingsClass, \"setJavaScriptEnabled\", \"(Z)V\");\n\tenv->CallVoidMethod( envptr, websettings, setJavaScriptEnabledMethod, true );\n\tenv->DeleteLocalRef( envptr, websettings );\n\n\tjmethodID setMeasuredDimensionMethodID = env->GetMethodID(envptr, WebViewClass, \"setMeasuredDimension\", \"(II)V\");\n\tenv->CallVoidMethod(envptr, wvObj, setMeasuredDimensionMethodID, pw, ph );\n\n\tjclass ViewClass = env->FindClass(envptr, \"android/widget/LinearLayout\");\n\tjmethodID addViewMethod = env->GetMethodID(envptr, ViewClass, \"addView\", \"(Landroid/view/View;)V\");\n\tenv->CallVoidMethod( envptr, g_objRootView, addViewMethod, wvObj );\n\n\tjclass WebMessagePortClass = env->FindClass(envptr, \"android/webkit/WebMessagePort\" );\n\tjmethodID createWebMessageChannelMethod = env->GetMethodID(envptr, WebViewClass, \"createWebMessageChannel\", \"()[Landroid/webkit/WebMessagePort;\");\n\tjobjectArray messageChannels = env->CallObjectMethod( envptr, wvObj, createWebMessageChannelMethod );\n\tjobject mc0 = env->GetObjectArrayElement(envptr, messageChannels, 0); // MC1 is handed over to javascript.\n\n\tjclass HandlerClassType = env->FindClass(envptr, \"android/os/Handler\" );\n\tjmethodID HandlerObjectConstructor = env->GetMethodID(envptr, HandlerClassType, \"<init>\", \"(Landroid/os/Looper;)V\");\n\tjobject handlerObject = env->NewObject( envptr, HandlerClassType, HandlerObjectConstructor, useLooperForWebMessages );\n\thandlerObject = env->NewGlobalRef(envptr, handlerObject);\n\tjmethodID setWebMessageCallbackMethod = env->GetMethodID( envptr, WebMessagePortClass, \"setWebMessageCallback\", \"(Landroid/webkit/WebMessagePort$WebMessageCallback;Landroid/os/Handler;)V\" );\n\n\t// Only can receive messages on MC0\n\tenv->CallVoidMethod( envptr, mc0, setWebMessageCallbackMethod, 0, handlerObject );\n\t\n\t// Generate backing bitmap and canvas.\n\tjclass CanvasClass = env->FindClass(envptr, \"android/graphics/Canvas\");\n\tjclass BitmapClass = env->FindClass(envptr, \"android/graphics/Bitmap\");\n\tjmethodID createBitmap = env->GetStaticMethodID(envptr, BitmapClass, \"createBitmap\", \"(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;\");\n\tjclass bmpCfgCls = env->FindClass(envptr, \"android/graphics/Bitmap$Config\");\n\tjstring bitmap_mode = env->NewStringUTF(envptr, \"ARGB_8888\");\n\tjmethodID bmpClsValueOfMid = env->GetStaticMethodID(envptr, bmpCfgCls, \"valueOf\", \"(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;\");\n\tjobject jBmpCfg = env->CallStaticObjectMethod(envptr, bmpCfgCls, bmpClsValueOfMid, bitmap_mode);\n\tjobject bitmap = env->CallStaticObjectMethod( envptr, BitmapClass, createBitmap, pw, ph, jBmpCfg );\n\tjmethodID canvasConstructor = env->GetMethodID(envptr, CanvasClass, \"<init>\", \"(Landroid/graphics/Bitmap;)V\");\n\tjobject canvas = env->NewObject(envptr, CanvasClass, canvasConstructor, bitmap );\n\n\tenv->DeleteLocalRef( envptr, CanvasClass );\n\tenv->DeleteLocalRef( envptr, BitmapClass );\n\tenv->DeleteLocalRef( envptr, bmpCfgCls );\n\tenv->DeleteLocalRef( envptr, bitmap_mode );\n\n\tw->BackingBitmap = env->NewGlobalRef(envptr, bitmap );\n\tw->BackingCanvas = env->NewGlobalRef(envptr, canvas );\n\tw->WebViewObject = env->NewGlobalRef(envptr, wvObj);\n\tw->MessageChannels = env->NewGlobalRef(envptr, messageChannels);\n\tw->w = pw;\n\tw->h = ph;\t\n\n\tenv->DeleteLocalRef( envptr, WebViewClass );\n\tenv->DeleteLocalRef( envptr, activityClass );\n\tenv->DeleteLocalRef( envptr, WebSettingsClass );\n\tenv->DeleteLocalRef( envptr, ViewClass );\n}\n\nint  WebViewGetProgress( WebViewNativeActivityObject * obj )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjclass WebViewClass = env->FindClass(envptr, \"android/webkit/WebView\");\n\tjmethodID WebViewProgress = env->GetMethodID(envptr, WebViewClass, \"getProgress\", \"()I\");\n\tint ret = env->CallIntMethod( envptr, obj->WebViewObject, WebViewProgress );\n\tenv->DeleteLocalRef( envptr, WebViewClass );\n\treturn ret;\n}\n\nvoid WebViewPostMessage( WebViewNativeActivityObject * w, const char * mesg, int initial )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjclass WebMessagePortClass = env->FindClass(envptr, \"android/webkit/WebMessagePort\" );\n\tjclass WebViewClass = env->FindClass(envptr, \"android/webkit/WebView\");\n\tjclass WebMessageClass = env->FindClass(envptr, \"android/webkit/WebMessage\" );\n\n\tjstring strjs = env->NewStringUTF( envptr, mesg );\n\n\tif( initial )\n\t{\n\t\tjobject mc1 = env->GetObjectArrayElement(envptr, w->MessageChannels, 1);\n\t\tjmethodID WebMessageConstructor = env->GetMethodID(envptr, WebMessageClass, \"<init>\", \"(Ljava/lang/String;[Landroid/webkit/WebMessagePort;)V\");\n\n\t\t//https://stackoverflow.com/questions/41753104/how-do-you-use-webmessageport-as-an-alternative-to-addjavascriptinterface\n\t\t// Only on initial hop do we want to post the root webmessage, which hooks up out webmessage port.\n\t\tjmethodID postMessageMethod = env->GetMethodID(envptr, WebViewClass, \"postWebMessage\", \"(Landroid/webkit/WebMessage;Landroid/net/Uri;)V\");\n\n\t\t// Need to generate a new message channel array.\n\t\tjobjectArray jsUseWebPorts = env->NewObjectArray( envptr, 1, WebMessagePortClass, mc1);\n\n\t\t// Need Uri.EMPTY\n\t\tjclass UriClass = env->FindClass(envptr, \"android/net/Uri\" );\n\t\tjfieldID EmptyField = env->GetStaticFieldID( envptr, UriClass, \"EMPTY\", \"Landroid/net/Uri;\" );\n\t\tjobject EmptyURI = env->GetStaticObjectField( envptr, UriClass, EmptyField );\n\n\n\t\tjobject newwm = env->NewObject(envptr, WebMessageClass, WebMessageConstructor, strjs, jsUseWebPorts );\n\t\tenv->CallVoidMethod( envptr, w->WebViewObject, postMessageMethod, newwm, EmptyURI );\n\n\t\tenv->DeleteLocalRef( envptr, jsUseWebPorts );\n\t\tenv->DeleteLocalRef( envptr, newwm );\n\t\tenv->DeleteLocalRef( envptr, EmptyURI );\n\t\tenv->DeleteLocalRef( envptr, UriClass );\n\t}\n\telse\n\t{\n\t\tjobject mc0 = env->GetObjectArrayElement(envptr, w->MessageChannels, 0);\n\t\tjmethodID postMessageMethod = env->GetMethodID(envptr, WebMessagePortClass, \"postMessage\", \"(Landroid/webkit/WebMessage;)V\");\n\t\tjmethodID WebMessageConstructor = env->GetMethodID(envptr, WebMessageClass, \"<init>\", \"(Ljava/lang/String;)V\");\n\n\t\tjobject newwm = env->NewObject(envptr, WebMessageClass, WebMessageConstructor, strjs );\n\t\tenv->CallVoidMethod( envptr, mc0, postMessageMethod, newwm );\n\n\t\tenv->DeleteLocalRef( envptr, newwm );\n\t\tenv->DeleteLocalRef( envptr, mc0 );\n\t}\n\n\tenv->DeleteLocalRef( envptr, strjs );\n\tenv->DeleteLocalRef( envptr, WebViewClass );\n\tenv->DeleteLocalRef( envptr, WebMessageClass );\n\tenv->DeleteLocalRef( envptr, WebMessagePortClass );\n}\n\nvoid WebViewRequestRenderToCanvas( WebViewNativeActivityObject * obj )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjclass WebViewClass = env->FindClass(envptr, \"android/webkit/WebView\");\n\tjmethodID drawMethod = env->GetMethodID(envptr, WebViewClass, \"draw\", \"(Landroid/graphics/Canvas;)V\");\n\tenv->CallVoidMethod( envptr, obj->WebViewObject, drawMethod, obj->BackingCanvas );\n\tenv->DeleteLocalRef( envptr, WebViewClass );\n}\n\nvoid WebViewNativeGetPixels( WebViewNativeActivityObject * obj, uint32_t * pixel_data, int w, int h )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjclass BitmapClass = env->FindClass(envptr, \"android/graphics/Bitmap\");\n\tjobject buffer = env->NewDirectByteBuffer(envptr, pixel_data, obj->w*obj->h*4 );\n\tjmethodID copyPixelsBufferID = env->GetMethodID( envptr, BitmapClass, \"copyPixelsToBuffer\", \"(Ljava/nio/Buffer;)V\" );\n\tenv->CallVoidMethod( envptr, obj->BackingBitmap, copyPixelsBufferID, buffer );\n\n\tint i;\n\tint num = obj->w * obj->h;\n\tfor( i = 0; i < num; i++ ) pixel_data[i] = bswap_32( pixel_data[i] );\n\n\tenv->DeleteLocalRef( envptr, BitmapClass );\n\tenv->DeleteLocalRef( envptr, buffer );\n\n\tjnii->DetachCurrentThread( jniiptr );\n}\n\nvoid WebViewExecuteJavascript( WebViewNativeActivityObject * obj, const char * js )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjclass WebViewClass = env->FindClass(envptr, \"android/webkit/WebView\");\n\tjmethodID WebViewEvalJSMethod = env->GetMethodID(envptr, WebViewClass, \"evaluateJavascript\", \"(Ljava/lang/String;Landroid/webkit/ValueCallback;)V\");\n\n\t//WebView.evaluateJavascript(String script, ValueCallback<String> resultCallback) \n\tjstring strjs = env->NewStringUTF( envptr, js );\n\tenv->CallVoidMethod( envptr, obj->WebViewObject, WebViewEvalJSMethod, strjs, 0 );  // Tricky: resultCallback = 0, if you try running looper.loop() it will crash - only manually process messages.\n\tenv->DeleteLocalRef( envptr, WebViewClass );\n\tenv->DeleteLocalRef( envptr, strjs );\n}\n\nchar * WebViewGetLastWindowTitle( WebViewNativeActivityObject * obj )\n{\n\tconst struct JNINativeInterface * env = 0;\n\tconst struct JNINativeInterface ** envptr = &env;\n\tconst struct JNIInvokeInterface ** jniiptr = gapp->activity->vm;\n\tconst struct JNIInvokeInterface * jnii = *jniiptr;\n\tjnii->AttachCurrentThread( jniiptr, &envptr, NULL);\n\tenv = (*envptr);\n\n\tjclass WebViewClass = env->FindClass(envptr, \"android/webkit/WebView\");\n\tjmethodID getTitle = env->GetMethodID(envptr, WebViewClass, \"getTitle\", \"()Ljava/lang/String;\");\n\tjobject titleObject = env->CallObjectMethod( envptr, obj->WebViewObject, getTitle );\n\tchar *nativeString = strdup( env->GetStringUTFChars(envptr, titleObject, 0) );\n\tenv->DeleteLocalRef( envptr, titleObject );\n\tenv->DeleteLocalRef( envptr, WebViewClass );\n\n\treturn nativeString;\n}\n\n\n#endif\n#endif\n\n"
        }
      ]
    }
  ]
}