{
  "metadata": {
    "timestamp": 1736709756747,
    "page": 183,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dekuNukem/Nintendo_Switch_Reverse_Engineering",
      "stars": 3491,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.1904296875,
          "content": "# My Nintendo Switch reverse engineering attempts\n\nI'm just going to dump all my discoveries here, and hopefully they would be useful to the Nintendo Switch community.\n\n## Questions?\n\nPlease make a post in the [issue section](https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering/issues), contributors have been immensely helpful.\n\n## Contributors\n\nPlease remember that the information in this repo is the work of a lot more people than just me. Please take a look at the [contributers list](https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering/graphs/contributors) and appreciate their work. Be sure to credit them as well.\n\n## Joy-Con PCB Layout and test points\n\n![Alt text](http://i.imgur.com/7Ui8lFv.jpg)\n\n[Full-size PDF](./joycon_pcb.pdf) of Joy-Con pinouts, both left and right.\n\nThe \"JC\" is for the 10-pin Joycon connector, see below for details.\n\n### Remarks\n\n* Joy-Con runs at 1.8V\n\n* There are no silkscreen marking component and test point numbers. Nintendo maybe is trying to discourage people from doing funky things to the Joy-Con?\n\n* Also, in a bizarre move, Nintendo didn't use the traditional \"one side pulled-up other side to ground\" way of reading buttons, instead they used a keypad configuration where buttons are arranged in rows and columns. They used the keypad scanner built-in inside the BCM20734 with 128KHz clock for reading the buttons. That means it would be extremely hard to spoof button presses for TAS and twitch-plays. Maybe the Pro controller is different, need to buy one though.\n\n* The only button that's not part of the keypad is the joystick button, which is still activated by pulling it down to ground.\n\n## SPI Peripherals\n\n![Alt text](https://i.imgur.com/2c3tmyd.png)\n\nThere are 2 SPI devices on the bus, one 4Mb MX25U4033E flash memory and one LSM6DS3 6-axis MEMS accelerometer and gyroscope.\n\n[Here is a capture](./logic_captures/left_grey_joycon_spi_poweron_then_dock.logicdata) of SPI lines when the Joy-Con battery is connected, and then attached to the console.\n\nIt looks like SCK runs at 12.5MHz when accessing the flash memory, but switches to 6.25MHz when accessing the MEMS chip.\n\n### Accelerometer and gyroscope\n\nUpon connection the microcontroller initializes a software reset of the MEMS chip, then set up the accelerometer and gyroscope as follows:\n\n| Accelerometer               | Gyroscope                      |\n|-----------------------------|--------------------------------|\n| ODR 1.66KHz, full-scale Â±8g | ODR 208Hz, full-scale 2000dps  |\n\nThe accelerometer also has AA filter at 100Hz bandwidth, low-pass filter enabled, slope filter enabled with cut-off frequency at 416Hz.\n\nThe Joy-Con then polls LSM6DS3 every 1.35ms(740Hz) for both accelerometer and gyroscope data in all axises, totaling 12 bytes(6 axises, each axis 2 bytes).\n\nSince the Joy-Con polls MEMS data every 1.35ms but only send out controller update every 15ms, there might be some internal averaging to smooth out the data, needs to go through the numbers to find out.\n\n### Flash Memory\n\nWell there's a capture of the SPI lines when the Joy-Con is powered up (battery connected), which contains all the address and data Joy-Con reads from the flash memory. I don't have time to go through it right now but of course you can if you want.\n\nThe SPI flash can be dumped post-pairing over UART using `19 01 03 38 00 92 00 31 00 00 d4 e6 01 0c 00 01 40 40 00 01 40 40 10 XX XX XX XX YY 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00` where XX XX XX XX is a 32-bit little-endian address and YY is the amount to dump up to 0x1c bytes. The resulting data will be at +0x20 in the Joy-Con response.\n\nJoy-Con color, serial and calibration settings are all stored on the SPI flash and are accessed through the above query.\n\n## Joy-Con to Console Communication\n\nWhen attached to the console, the Joy-Con talks to it through a physical connection instead of Bluetooth. There are 10 pins on the connector, I'm just going to arbitrarily name it like this:\n\n![Alt text](https://i.imgur.com/52xjlRb.jpg)\n\n![Alt text](https://i.imgur.com/LIFiq8X.jpg)\n\nLooking at the pins on both Joy-Con facing towards you, the left most one is Pin 1, and the right most one is Pin 10. I simply removed the rumble motor, burned a hole on the back cover, and routed all the wires out through that.\n\nCapture of the docking of the [left](./logic_captures/left_grey_joycon_docking_controllers_screen.logicdata) and [right](./logic_captures/right_grey_joycon_docking_controllers_screen.logicdata) Joycon.\n\n![Alt text](https://i.imgur.com/iUq5RNG.png)\n\n### Joy-Con Connector Pinout\n\n\n| Logic analyzer channel | Joycon Connector Pin |            Function           |                                                       Remarks                                                                       |\n|:----------------------:|:--------------------:|:-----------------------------:| ----------------------------------------------------------------------------------------------------------------------------------- |\n|            -           |           1          |              GND              |                                                          -                                                                          |\n|            -           |           2          |              GND              |                                                          -                                                                          |\n|            0           |           3          |              Jdet             | HIGH when connected to console via Bluetooth. Joy-Con will not send serial data post-handshake unless pin is pulled LOW by console. |\n|            1           |           4          |               5V              |                                              Joy-Con power and charging                                                             |\n|            2           |           5          | Serial data console to Joycon |                                             Inverted level (idle at GND)                                                            |\n|            3           |           6          |              JRST             |                                      Joy-Con reset signal , high level is reset                                                     |\n|            -           |           7          |              GND              |                                                          -                                                                          |\n|            4           |           8          | Serial data Joycon to console |                                            Standard level (idle at 1.8V)                                                            |\n|            5           |           9          |           Power output        |                             Joy can output power to Ring Fit Adventure or starlink toy                                              |\n|            6           |          10          |          Flow control         |                             Joy-Con will only send data to console when this line is HIGH                                           |\n\n* When first connected the baud rate is at 1000000bps(!), after the initial handshake the speed is then switched to 3125000bps(!!)\n\n* Thanks to [yujc1986's contribution](https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering/commit/bfeadd4f3f7de46a9bd9e06a190f76e4a1887d31), the pin names has been updated according to the circuit board labels on the [Starlink: Battle for Atlas](https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering/tree/master/peripheral%20device/startlink%20toy) Joycon adapter.\n\n### Handshake procedure\n\nI took apart 2 left Joy-Con, one grey one red. Below you can see the difference in the response between two Joy-Con.\n\n**Console to Joy-Con**                                       |**GREY Joy-Con response**                                    |**RED Joy-Con response**                                     |**Different?**|**Remarks**\n:-----------------------------------------------------------:|:-----------------------------------------------------------:|:-----------------------------------------------------------:|:-------:|:-----:\n`A1 A2 A3 A4 19 01 03 07 00 A5 02 01 7E 00 00 00`            |`19 81 03 07 00 A5 02 02 7D 00 00 64`                        |`19 81 03 07 00 A5 02 02 7D 00 00 64`                        |Same     |Handshake start; 1000000bps\n`19 01 03 07 00 91 01 00 00 00 00 24`                        |`19 81 03 0F 00 94 01 08 00 00 FA E8 01 31 67 9C 8A BB 7C 00`|`19 81 03 0F 00 94 01 08 00 00 8F 87 01 E6 4C 5F B9 E6 98 00`|Different|Joycon MAC\n`19 01 03 0F 00 91 20 08 00 00 BD B1 C0 C6 2D 00 00 00 00 00`|`19 81 03 07 00 94 20 00 00 00 00 A8`                        |`19 81 03 07 00 94 20 00 00 00 00 A8`                        |Same     |Command to switch to 3125000bps\n`19 01 03 07 00 91 11 00 00 00 00 0E`                        |`19 81 03 07 00 94 11 00 00 0F 00 33`                        |`19 81 03 07 00 94 11 00 00 0F 00 33`                        |Same     |?; 3125000 bps from now on\n`19 01 03 07 00 91 10 00 00 00 00 3D`                        |`19 81 03 07 00 94 10 00 00 00 00 D6`                        |`19 81 03 07 00 94 10 00 00 00 00 D6`                        |Same     |?\n`19 01 03 0B 00 91 12 04 00 00 12 A6 0F 00 00 00`            |`19 81 03 07 00 94 12 00 00 00 00 B0`                        |`19 81 03 07 00 94 12 00 00 00 00 B0`                        |Same     |?\n`19 01 03 08 00 92 00 01 00 00 69 2D 1F`                     |61B Controller status                                        |61B Controller status                                        |Different|Handshake done. Console sends this controller status request command every 15ms from now on.\n\n* Pin 5 (Serial data, console to Joy-Con) is normally pulled high on the console side when nothing is connected. Since this line is inverted on the Joy-Con side, it will be pulled down when a Joy-Con is attached to the console, thus initializing a handshake.\n\n* It seems Pin 5 needs to be pulled down for a while for the handshake to take place, 500ms works for me.\n\n* Handshake starts at 1000000bps, and the console will send a 4-byte start sequence of `A1 A2 A3 A4`, followed by 12 byte command of `19 01 03 07 00 A5 02 01 7E 00 00 00`. It will send those commands repeatedly every 100ms (10Hz) for 3 seconds. Joy-Con respond with `19 81 03 07 00 A5 02 02 7D 00 00 64`. If no response is received it gives up and wait for another event on the line.\n\n* The console then sends `19 01 03 07 00 91 01 00 00 00 00 24`, to which Joy-Con respond with a 20-byte MAC response used to pair the Joy-Con to the console. After the response is received the little Joy-Con insertion animation starts on the screen. The color for this animation is cached on the console after a Joy-Con has been connected for the first time and the color has been retrieved from SPI flash.\n\n* They console sends `19 01 03 0F 00 91 20 08 00 00 BD B1 C0 C6 2D 00 00 00 00 00`, a command that switches baud rate from 1000000 to 3125000. Joy-Con respond with `19 81 03 07 00 94 20 00 00 00 00 A8`. Note that the faster baud rate takes effect from the next command. This command is not required for pairing to complete.\n\n* Now serial comm is at 3125000bps. Console sends `19 01 03 07 00 91 11 00 00 00 00 0E`, Joy-Con responds with `19 81 03 07 00 94 11 00 00 0F 00 33`.\n\n* Console sends `19 01 03 07 00 91 10 00 00 00 00 3D`, Joy-Con responds with `19 81 03 07 00 94 10 00 00 00 00 D6`.\n\n* Now the pairing is seemingly done, the console will now send `19 01 03 08 00 92 00 01 00 00 69 2D 1F` every 15ms to ask for a controller status update. See \"Protocol\" section below for details.\n\n### Pesky checksums\n\nIt turns out the last byte of each command sent over serial seems to be a checksum of some sort, and without figuring it out it would be rather difficult testing what each command does because the console will not accept commands with the wrong checksum. \n\n**Thanks to [ewalt1's](https://github.com/ewalt1) effort and contribution, we seems to have a solution to the checksum problem:** \n\nThe first 4 bytes are a header, with the 4th byte being the length of the remaining packet (not counting the checksum). The next 7 bytes are some type of data, with the 8th byte being the CRC of that data. The CRC used is CRC-8 with a polynomial of 0x8D and an initial value of 0x00.\n \nThere's some example code for calculating this CRC using a lookup table in [packet_parse/joycon_crc.py](./packet_parse/joycon_crc.py).\n\n*Note: these checksums are only sent over serial, not over the Bluetooth or USB HID mode.*\n\n### Joy-Con status data packet\n\nIn normal operation the console asks Joy-Con for an update every 15ms (66.6fps), the command for requesting update is:\n\n```\n19 01 03 08 00 92 00 01 00 00 69 2d 1f\n```\n\nAround 4ms later, Joy-Con respond with a 61 bytes long answer.\n\nOne sample:\n\n```\n19 81 03 38 \n00 92 00 31 \n00 00 e9 2e \n30 7f 40 00 \n00 00 65 f7 \n81 00 00 00 \nc0 23 01 e2 \nff 3e 10 0a \n00 d6 ff d0 \nff 23 01 e1 \nff 37 10 0a \n00 d6 ff cf \nff 29 01 dd \nff 34 10 0a \n00 d7 ff ce \nff \n```\n\nHere is what I figured out:\n\n\n|   Byte #  |        Sample value       |               Remarks              |\n|:---------:|:-------------------------:|:----------------------------------:|\n|   0 to 8  | `19 81 03 38 00 92 00 31` |            Header, fixed           |\n| 16 and 17 |          `00 02`          |  Button status, see section below  |\n|     19    |            `f7`           | Joystick X value, reversed nibble? |\n|     20    |            `81`           |          Joystick Y value          |\n| 31 and 32 |          `4e 05`          |          Gyroscope X value         |\n| 33 and 34 |          `cc fb`          |          Gyroscope Y value         |\n| 35 and 36 |          `eb ff`          |          Gyroscope Z value         |\n| 37 and 38 |          `41 00`          |        Accelerometer X Value       |\n| 39 and 40 |          `1b 03`          |        Accelerometer Y Value       |\n| 41 and 42 |          `82 f0`          |        Accelerometer Z Value       |\n\nEach accelerometer and gyroscope axis data is 2 bytes long and forms a int16_t, last byte is the higher byte.\n\n### Button status\n\nThe 16th and 17th byte (on line 5, before `65 f7`) are the button status, when a button is pressed the corresponding bit is set to 1.\n\n![Alt text](http://i.imgur.com/QXBaCIe.png)\n\n### Joystick value\n\nByte 19 and 20 (`f7 81` between 5th and 6th line) are the Joystick values, most likely the raw 8-bit ADC data. Byte 19 is X while byte 20 is Y. Again, bizarrely, the X nibble is reversed, as in the `f7` should actually be `7f` (127 at neutral position). The Y value is correct though (`0x81` is 129).\n\n### Joy-Con status data packet\n\nSee the [bluetooth_hid_subcommands_notes.md](./bluetooth_hid_subcommands_notes.md) file for details about the data transferred during normal operations (button status, joysticks, etc).\n\n### Rumble commands\n\nDetails on rumble data are in the [rumble_data_table.md](./rumble_data_table.md) file.\n\n## Touchscreen controller\n\n![Alt text](http://i.imgur.com/ZZWBv5d.jpg)\n\nThe console itself uses a FT9CJ capacitive touchscreen controller. And [according to techinsights](http://www.techinsights.com/about-techinsights/overview/blog/nintendo-switch-teardown/) it's a custom part by STMicroelectronics for the Nintendo Switch. After looking at the communication it appears to use I2C, which is in line with other touchscreen controller chips. [Here is a capture](./logic_captures/touchscreen_controller_poweron_i2c.logicdata) of the I2C bus on power-up.\n\nThe 7-bit I2C address of the chip is 0x49 (0x92 write, 0x93 read), and it's polled around every 4ms for update.\n\n## Docking station firmware dump\n\nThe docking station uses a STM32F048 microcontroller. It's actually labeled as STM32P048 because it uses the FASTROM option where ST pre-programs the flash memory inside the factory. It has 32KB flash memory and 6KB RAM, runs at 48MHz. \n\nIt uses SWD debugging and programming interface, and interestingly the programming testpoints are on the PCB and clearly labeled. After connecting a ST-Link programmer to it reveals that the chip is not read-protected at all, so a firmware dump was easily made. I'm not going to post it in the repo, but if you want it just ask.\n\n\n## Ending remarks\n\nI'll update this from time to time when I have new discoveries. Please share if you find this useful.\n\n"
        },
        {
          "name": "USB-HID-Notes.md",
          "type": "blob",
          "size": 2.6689453125,
          "content": "# USB HID Notes\n\nBoth the Pro Controller and the Charging Joy-Con Grip support communication over USB HID. Both use identical STM32s and both, for the most part, have the same firmware for the micro-controller. The only significant difference is that the grip exposes two interfaces for talking with each Joy-Con individually, and the Pro Controller only exposes one. Additionally, the Pro Controller firmware seems to have functionality for ignoring checksums if the Broadcom chip sends a 00 checksum for its first reply.\n\n## HID Protocol\n\nThe STM32 handles most UART communication for handshaking. HID commands may start with an 01, 10, or 80. 80 seems to contain all of Nintendo's custom protocol.\n\n#### `01 .. ..`\n\nSends `19 01 03 07 00 00 92 00 00 00 00 00 01 .. ..` over UART.\n\n#### `10 .. ..`\n\nSends `19 01 03 07 00 00 92 00 00 00 00 00 10 .. ..` over UART.\n\n#### `80 01`\nSample response: `81 01 00 02 57 30 ea 8a bb 7c`\n\nSends current connection status, and if the Joy-Con are connected, a MAC address and the type of controller. In the above case, it sent an `02` for a right Joy-Con and a Joy-Con MAC address 7c:bb:8a:ea:30:57. These same packets are also sent during a session if the Joy-Con connection state changes.\n\n\n#### `80 02`\nSample response: `81 02`\n\nSends handshaking packets over UART to the Joy-Con or Pro Controller Broadcom chip. This command can only be called once per session.\n\n#### `80 03`\nSample response: `81 03`\n\nSwitches baudrate to 3Mbit, needed for improved Joy-Con latency. This command can only be called following `80 02`, but allows another `80 02` packet to be sent following it. A second handshake is required for the baud switch to work.\n\n#### `80 04`\n\nForces the Joy-Con or Pro Controller to only talk over USB HID without any timeouts. This is required for the Pro Controller to not time out and revert to Bluetooth.\n\n#### `80 05`\n\nAllows the Joy-Con or Pro Controller to time out and talk Bluetooth again. If the controller is not send a USB HID packet within a certain amount of time, it will time out and reset the connection.\n\n#### `80 06`\n\nPossibly resets? Sends `19 01 03 07 00 00 92 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 06 01` over UART.\n\n#### `80 91`\n\nSends a pre-handshake command, looks up UART post-header lengths for various pre-handshake commands when sending. UART command 01 is 0F large, 18 is 37 large, 40 uses the size specified in the 16-bit word following `80 91`, 03, 05, 06, 07, 13, anything else defaults to 0B large.\n\n#### `80 92`\n\nSends any UART command. The UART post-header length is specified in the 16-bit word following `80 92`. For example, sending `80 92 00 01 00 00 00 00 1F` will send a UART input packet and retrieves a response for that packet.\n\n\n"
        },
        {
          "name": "bluetooth_hid_notes.md",
          "type": "blob",
          "size": 15.0068359375,
          "content": "# Bluetooth HID Information\n\n## Output reports\n\n### OUTPUT 0x01\n\nRumble and subcommand.\n\nThe OUTPUT 1 report is how all normal subcommands are sent. It also includes rumble data.\n\nSample C code for sending a subcommand:\n\n```\nuint8_t buf[0x40]; bzero(buf, 0x40);\nbuf[0] = 1; // 0x10 for rumble only\nbuf[1] = GlobalPacketNumber; // Increment by 1 for each packet sent. It loops in 0x0 - 0xF range.\nmemcpy(buf + 2, rumbleData, 8);\nbuf[10] = subcommandID;\nmemcpy(buf + 11, subcommandData, subcommandDataLen);\nhid_write(handle, buf, 0x40);\n```\n\nYou can send rumble data and subcommand with `x01` command, otherwise only rumble with `x10` command.\n\nSee \"Rumble data\" below.\n\n### OUTPUT 0x03\n\nNFC/IR MCU FW Update packet.\n\n### OUTPUT 0x10\n\nRumble only. See OUTPUT 0x01 and \"Rumble data\" below.\n\n### OUTPUT 0x11\n\nRequest specific data from the NFC/IR MCU. Can also send rumble.\n\n### OUTPUT 0x12\n\nUnknown. Does the same thing with 0x28 subcmd.\n\n### Rumble data\n\nA timing byte, then 4 bytes of rumble data for left Joy-Con, followed by 4 bytes for right Joy-Con.\n[00 01 40 40 00 01 40 40] (320Hz 0.0f 160Hz 0.0f) is neutral.\nThe rumble data structure contains 2 bytes High Band data, 2 byte Low Band data.\nThe values for HF Band frequency and LF amplitude are encoded.\n\n|  Byte #  |        Range                               | Remarks                                                                  |\n|:--------:|:------------------------------------------:| ------------------------------------------------------------------------ |\n| 0, 4     | `x04` - `xFC` (81.75Hz - 313.14Hz)         | High Band Lower Frequency. Steps `+0x0004`.                              |\n| 0-1, 4-5 | `x00 01` - `xFC 01` (320.00Hz - 1252.57Hz) | Byte `1`,`5` LSB enables High Band Higher Frequency. Steps `+0x0400`.    |\n| 1, 5     | `x00 00` - `xC8 00` (0.0f - 1.0f)          | High Band Amplitude. Steps `+0x0200`. Real max: `FE`.                    |\n| 2, 6     | `x01` - `x7F` (40.87Hz - 626.28Hz)         | Low Band Frequency.                                                      |\n| 3, 7     | `x40` - `x72` (0.0f - 1.0f)                | Low Band Amplitude. Safe max: `00 72`.                                   |\n| 2-3, 6-7 | `x80 40` - `x80 71` (0.01f - 0.98f)        | Byte `2`,`6` +0x80 enables intermediate LF amplitude. Real max: `80 FF`. |\n \nFor a rumble values table, example and the algorithm for frequency, check rumble_data_table.md.\n\nThe byte values for frequency raise the frequency in Hz exponentially and not linearly.\n\nDon't use real maximum values for Amplitude. Otherwise, they can damage the linear actuators.\nThese safe amplitude ranges are defined by Switch HID library.\n\n## Input reports\n\n### INPUT 0x3F\n\nThis input packet is pushed to the host when a button is pressed or released, and provides the \"normal controller\" interface for the OS.\n\n|  Byte #         |        Sample value        | Remarks                   |\n|:---------------:|:--------------------------:|:-------------------------:|\n|  0              | `x3F`                      | Input report ID           |\n|  1-2            | `x28 CA`                   | Button status             |\n|  3              | `x08`                      | Stick hat data            |\n|  4-11 (Joy-Con) | `x00 80 00 80 00 80 00 80` | Filler data               |\n|  4-7 (Pro Con)  | `x40 8A 4F 8A`             | Left analog stick data    |\n|  8-11 (Pro Con) | `xD0 7E DF 7F`             | Right analog stick data   |\n\n#### Stick hat data\n\nHold your controller sideways so that SL, SYNC, and SR line up with the screen. Pushing the stick towards a direction in this table will cause that value to be sent.\n\n| SL | SYNC | SR |\n| --:|:----:|:-- |\n| 7  |  0   |  1 |\n| 6  |  8   |  2 |\n| 5  |  4   |  3 |\n\n#### Button status format\n\n| Byte | Bit `x01` | `x02`  |`x04`        |`x08`         |`x10`  |`x20`     |`x40`   |`x80`     |\n|:----:|:---------:|:------:|:------------|:------------:|:-----:|:--------:|:------:|:--------:|\n| 1    | Down      | Right  | Left        | Up           | SL    | SR       | --     | --       |\n| 2    | Minus     | Plus   | Left Stick  | Right Stick  | Home  | Capture  | L / R  | ZL / ZR  |\n\n#### Stick data\n\nThe code below properly decodes the stick data:\n\n```\nuint8_t *data = packet + (left ? 4 : 8);\nuint16_t stick_horizontal = data[0] | (data[1] << 8);\nuint16_t stick_vertical = data[2] | (data[3] << 8);\n```\n\n### INPUT 0x21\n\nStandard input reports used for subcommand replies.\n\n### INPUT 0x23\n\nNFC/IR MCU FW update input report.\n\n### INPUT 0x30\n\nStandard full mode - input reports with IMU data instead of subcommand replies. Pushes current state @60Hz, or @120Hz if Pro Controller.\n\n### INPUT 0x31\n\nNFC/IR MCU mode. Pushes large packets with standard input report + NFC/IR MCU data input report.\n\n### INPUT 0x32\n\nUnknown. Sends standard input reports.\n\n### INPUT 0x33\n\nUnknown. Sends standard input reports.\n\n### Standard input report format\n\nThe 3rd byte belongs entirely to the Right Joy-Con, while the 5th byte belongs entirely to the Left Joy-Con.\nThe middle byte is shared between the controllers.\n\n(Note: in the following table, the byte with the packet ID is included and located at byte \"0\".)\n\n|   Byte #           |        Sample         | Remarks                                                                             |\n|:------------------:|:---------------------:| ----------------------------------------------------------------------------------- |\n| 0                  | `x21`, `x30`, `x31`   | Input report ID                                                                     |\n| 1                  | `x00` - `xFF`         | Timer. Increments very fast. Can be used to estimate excess Bluetooth latency.      |\n| 2 high nibble      | `0` - `9`             | Battery level. 8=full, 6=medium, 4=low, 2=critical, 0=empty. LSB=Charging.          |\n| 2 low nibble       | `x0`, `x1`, `xE`      | Connection info. `(con_info >> 1) & 3` - 3=JC, 0=Pro/ChrGrip. `con_info & 1` - 1=Switch/USB powered. |\n| 3, 4, 5            | `x41 00 82`           | Button status (see below table)                                                     |\n| 6, 7, 8            | --                    | Left analog stick data                                                              |\n| 9, 10, 11          | --                    | Right analog stick data                                                             |\n| 12                 | `x70`, `xC0`, `xB0`   | Vibrator input report. Decides if next vibration pattern should be sent.            |\n| 13  (ID `x21`)     | `x00`, `x80`, `x90`, `x82`| ACK byte for subcmd reply. ACK: MSB is `1`, NACK: MSB is `0`. If reply is ACK and has data, `byte12 & 0x7F` gives as the type of data. If simple ACK or NACK, the data type portion is `x00` |\n| 14  (ID `x21`)     | `x02`, `x10`, `x03`   | Reply-to subcommand ID. The subcommand ID is used as-is.                            |\n| 15-49  (ID `x21`)  | --                    | Subcommand reply data. Max 35 bytes (excludes 2 byte subcmd ack above).             |\n| 13-49  (ID `x23`)  | --                    | NFC/IR MCU FW update input report. Max 37 bytes.                                    |\n| 13-48  (ID `x30`, `x31`, `x32`, `x33`) | -- | 6-Axis data. 3 frames of 2 groups of 3 Int16LE each. Group is Acc followed by Gyro. |\n| 49-361  (ID `x31`) | --                    | NFC/IR data input report. Max 313 bytes.                                            |\n\n(Note2: In the `21` input reports, the byte13 (ACK byte) can be parsed as follows: `byte13 >> 7` tells us if it's an ACK or NACK. If it's an ACK, check `byte13 & 0x7F` to see what type of data it has. If it is a simple ACK, the byte13 is `x80` and thus the type of data is `x00`. If we expect a certain order of received packets, we can hardcode these byte13 values. If it's a NACK, the byte13 is always `x00`)\n\n#### Standard input report - buttons\n| Byte       | Bit `x01` | `x02` | `x04`    | `x08`    | `x10` | `x20`    | `x40` | `x80`         |\n|:----------:|:---------:|:-----:|:--------:|:--------:|:-----:|:--------:|:-----:|:-------------:|\n| 3 (Right)  | Y         | X     | B        | A        | SR    | SL       | R     | ZR            |\n| 4 (Shared) | Minus     | Plus  | R Stick  | L Stick  | Home  | Capture  | --    | Charging Grip |\n| 5 (Left)   | Down      | Up    | Right    | Left     | SR    | SL       | L     | ZL            |\n\nNote that the button status of the L and R Joy-Cons can be ORed together to get a complete button status.\n\n#### Standard input report - Stick data\n\nThe code below properly decodes the stick data:\n\n```\nuint8_t *data = packet + (left ? 6 : 9);\nuint16_t stick_horizontal = data[0] | ((data[1] & 0xF) << 8);\nuint16_t stick_vertical = (data[1] >> 4) | (data[2] << 4);\n```\n\n#### Standard input report - 6-Axis sensor data\n\nSee [here](imu_sensor_notes.md) for the 6-Axis sensor data format and conversion.\n\nAlso, these are **uncalibrated** stick/sensor data and must be converted to useful axes and values using the calibration data in the SPI flash.\n\nSee [here](spi_flash_dump_notes.md#analog-stick-factory-and-user-calibration) for the calibration data format.\n\n## Feature reports\n\n### FEATURE 0x02: Get last subcommand reply\n\n[Send] feature Report\n\nBuffer returned contains the latest 0x21 subcommand input report.\n\nYou must pass a buffer that can fit a 0x21 input report.\n\n### FEATURE 0x70: Enable OTA FW upgrade\n\n[Send] feature Report\n\nEnables FW update. Unlocks Erase/Write memory commands.\n\nThe buffer sent must be exactly one byte. If else, Joy-Con rejects it.\n\nThe only possible ways to send it, is a Linux device with patched hidraw to accept 1 byte reports, directly through l2cap or a custom bluetooth development kit. \n\n| Byte # |  Sample   | Remarks                        |\n|:------:|:---------:| ------------------------------ |\n| 0      | `x70`     | Feature report ID              |\n\n### FEATURE 0x71: Setup memory read\n\n[Send] feature Report\n\nPrepares the SPI Read report with the requested address and size.\n\n| Byte # |  Sample        | Remarks                        |\n|:------:|:--------------:| ------------------------------ |\n| 0      | `x71`          | Feature report ID              |\n| 1 - 4  | `xF4 1F 00 F8` | UInt32LE address               |\n| 5 - 6  | `x08 00`       | UInt16LE size. Max xF9 bytes.  |\n| 7      | `x7C`          | Checksum (8-bit 2s Complement) |\n\nThe checksum is calculated as `0x100 - Sum of Bytes`.\n\nMemory map:\n\n| Address #   |  Size    | Remarks                |\n|:-----------:|:--------:| ---------------------- |\n| `x00000000` | `xC8000` | ROM region 1 (800KB)   |\n| `x000D0000` | `x10000` | RAM region 1 (64KB)    |\n| `x00200000` | `x48000` | RAM region 2 (288KB)   |\n| `x00260000` | `xC000`  | ROM region 2 (48KB)    |\n| `xF8000000` | `x80000` | SPI (512KB, fully R/W) |\n\n### FEATURE 0x72: Memory read\n\n[Get] feature Report\n\n| Byte # |  Sample   | Remarks                         |\n|:------:|:---------:| ------------------------------- |\n| 0      | `x72`     | Feature report ID               |\n| 1      | `x8E`     | Checksum* (8-bit 2s Complement) |\n| 2-EOF  |           |                                 |\n\n*Checksum is optional.\n\nIn Get feature report mode it returns the 0x71 requested SPI or Rom data.\n\nIf the 0x71 command wasn't sent previously, it will return zeroed data (except ID and CRC).\n\nThe data returned has the following structure:\n\n| Byte #  |  Sample        | Remarks                        |\n|:-------:|:--------------:| ------------------------------ |\n| 0       | `x72`          | Feature report ID              |\n| 1 - 4   | `xF4 1F 00 F8` | UInt32LE address               |\n| 5 - 6   | `x08 00`       | UInt16LE size                  |\n| 7-EOF-1 |                | Data requested                 |\n| EOF     | `xC7`          | Checksum (8-bit 2s Complement) |\n\nThe returned size is header + size in 0x71 ft report + 1. So make sure to get your report with an adequate buffer size.\n\n### FEATURE 0x73: Memory sector erase\n\n[Send] feature Report\n\nErases specified sector in SPI. Can erase locked sectors.\n\nShould be used only with SPI (0xF8000000 - 0xF807FFFF), because SPI needs to be erased before writing to it.\n\n0x70 command must be sent before using this. Otherwise, Joy-Con will reply with invalid report ID.\n\n| Byte # |  Sample        | Remarks                        |\n|:------:|:--------------:| ------------------------------ |\n| 0      | `x73`          | Feature report ID              |\n| 1 - 4  | `x00 80 02 F8` | UInt32LE address               |\n| 5 - 6  | `x00 10`       | UInt16LE size.                 |\n| 7      | `x03`          | Checksum (8-bit 2s Complement) |\n\nThis command only checks `& 0x00FFF000` to acquire the sector number. Size is also irrelevant, but it's best to use values `x01 - x100`.\n\n#### Warning:\n\nThis erases the whole sector. If you send xF35628F8 x0400, it will not erase 4bytes @x2856F3. It will erase the whole x285000 sector.\n\nYou need to read the sector, change the values you want and then erase and program them back.\n\n### FEATURE 0x74: Memory write\n\n[Send] feature Report\n\nWrites to SPI. Can write locked sectors.\n\n0x70 command must be sent before using this. Otherwise, Joy-Con will reply with invalid report ID.\n\n| Byte #  |  Sample        | Remarks                        |\n|:-------:|:--------------:| ------------------------------ |\n| 0       | `x74`          | Feature report ID              |\n| 1 - 4   | `x00 80 02 F8` | UInt32LE address               |\n| 5 - 6   | `xF9 00`       | UInt16LE size. Max xF9 bytes.  |\n| 7-EOF-1 |                | Data to write                  |\n| EOF     | `xDC`          | Checksum (8-bit 2s Complement) |\n\n#### Warning:\n\nCheck ft report x73 for info in erasing first.\n\n### FEATURE 0x75: Launch (Reboot)\n\n[Send] feature Report\n\nReboots and executes the firmware rom in the given address.\n\nIf address is `x0000` the Host should assume that the device will reboot.\n\n0x70 command must be sent before using this. Otherwise, Joy-Con will reply with invalid report ID.\n\n| Byte #  |  Sample        | Remarks                                  |\n|:-------:|:--------------:| ---------------------------------------- |\n| 0       | `x75`          | Feature report ID                        |\n| 1 - 4   | `x00 80 02 F8` | UInt32LE entry address for firmware jump |\n| 5 - 6   | `x04 00`       | UInt16LE size. Always 4.                 |\n| 7       | `x00 80 02 F8` | UInt32LE entry address for firmware jump |\n| 8       | `xDC`          | Checksum (8-bit 2s Complement)           |\n\nSending x75 00000000 0400 00000000 CRC will reboot the device and load the bootrom at 0x0. This is a good practice after finishing erasing/writing proccess.\n\nExchanging the SPI chip with a compatible one, but bigger size, user can use his own modified ROM firmware (must change addresses) and PatchRAM and launch it by using the above command to send the new address. Also, by modifying the initial PatchRAM in SPI at 0x0, you can create a similar logic that will launch the custom rom in every reboot without using x75 cmd. Additionally, you can add button scan to dual boot ROM firmware or PatchRAM.\n\n### FEATURE 0xCC\n\n[Send] feature Report\n\nUnknown parameters needed\n\n### FEATURE 0xFE\n\n[Get] feature Report\n\nUnknown parameters needed\n\n## Subcommands\n\nSee [here](bluetooth_hid_subcommands_notes.md) for information about all subcommands supported.\n"
        },
        {
          "name": "bluetooth_hid_subcommands_notes.md",
          "type": "blob",
          "size": 18.53125,
          "content": "# Subcommands\n\n### Subcommand 0x##: All unused subcommands\n\nAll subcommands that do nothing, reply back with ACK `x80##` and `x03`\n\n### Subcommand 0x00: Get Only Controller State\n\nReplies with `x8000` `x03`\n\nDoes nothing actually, but can be used to get Controller state only (w/o 6-Axis sensor data), like any subcommand that does nothing.\n\n### Subcommand 0x01: Bluetooth manual pairing\n\nTakes max 2 arguments. A Pair request type uint8 and Host BD_ADDR 6 bytes in LE.\n\nWhen used with cmd x01 it handles pairing. It is especially useful to change on the fly the pairing info for the next session, or to bluetooth pair through wired (rail/usb) connection.\n\nThe procedure must be done sequentially:\n\n- 1: x01 x01 [{BD_ADDR_LE}] (Send host MAC and acquire Joy-Con MAC)\n- 2: x01 x02 (Acquire the XORed LTK hash)\n- 3: x01 x03 (saves pairing info in Joy-Con)\n\nHost Pair request x01 (send HOST BT MAC and request Joy-Con BT MAC):\n\n| Byte # | Sample               | Remarks                                 |\n|:------:|:--------------------:| --------------------------------------- |\n|  0     | `x01`                | subcmd                                  |\n|  1     | `x01`                | Pair request type                       |\n|  2-7   | `x16 30 AA 82 BB 98` | Host Bluetooth address in Little-Endian |\n\nJoy-Con Pair request x01 reply:\n\n| Byte # | Sample               | Remarks                         |\n|:------:|:--------------------:| ------------------------------- |\n|  0     | `x01`                | Pair request type               |\n|  1-6   | `x57 30 EA 8A BB 7C` | Joy-Con BT MAC in Little-Endian |\n|  7-31  |                      | Descriptor?                     |\n\nHost Pair request x03 (request LTK):\n\nJoy-Con Pair request x02 reply:\n\nLong Term Key (LTK) in Little-Endian. Each byte is XORed with 0xAA.\n\nHost Pair request x03:\n\nJoy-Con saves pairing info in x2000 SPI region.\n\nIf the command is `x11`, it polls the MCU State? Used with IR Camera or NFC?\n\n### Subcommand 0x02: Request device info\n\nResponse data after 02 command byte:\n\n| Byte # | Sample               | Remarks                                                  |\n|:------:|:--------------------:| -------------------------------------------------------- |\n|  0-1   | `x03 48`             | Firmware Version. Latest is 3.89 (from 5.0.0 and up).    |\n|  2     | `x01`                | 1=Left Joy-Con, 2=Right Joy-Con, 3=Pro Controller.       |\n|  3     | `x02`                | Unknown. Seems to be always `02`                         |\n|  4-9   | `x7C BB 8A EA 30 57` | Joy-Con MAC address in Big Endian                        |\n|  10    | `x01`                | Unknown. Seems to be always `01`                         |\n|  11    | `x01`                | If `01`, colors in SPI are used. Otherwise default ones. |\n\n### Subcommand 0x03: Set input report mode\n\nOne argument:\n\n| Arg #  | Remarks                                                                                          |\n|:------:| ------------------------------------------------------------------------------------------------ |\n|  `x00` | Used with cmd `x11`. Active polling for NFC/IR camera data. 0x31 data format must be set first.  |\n|  `x01` | Same as `00`. Active polling mode for NFC/IR MCU configuration data.                             |\n|  `x02` | Same as `00`. Active polling mode for NFC/IR data and configuration. For specific NFC/IR modes   |\n|  `x03` | Same as `00`. Active polling mode for IR camera data. For specific IR modes                      |\n|  `x23` | MCU update state report?                                                                         |\n|  `x30` | Standard full mode. Pushes current state @60Hz                                                   |\n|  `x31` | NFC/IR mode. Pushes large packets @60Hz                                                          |\n|  `x33` | Unknown mode.                                                                                    |\n|  `x35` | Unknown mode.                                                                                    |\n|  `x3F` | Simple HID mode. Pushes updates with every button press                                          |\n\n`x31` input report has all zeroes for IR/NFC data if a `11` ouput report with subcmd `03 00/01/02/03` was not sent before.\n\n### Subcommand 0x04: Trigger buttons elapsed time\n\nReplies with 7 little-endian uint16. The values are in 10ms. They reset by turning off the controller.\n\n```\nLeft_trigger_ms = ((byte[1] << 8) | byte[0]) * 10;\n```\n\n| Bytes # | Remarks |\n|:-------:|:-------:|\n|   1-0   | L       |\n|   3-2   | R       |\n|   5-4   | ZL      |\n|   7-6   | ZR      |\n|   9-8   | SL      |\n|   10-9  | SR      |\n|   12-11 | HOME    |\n\n### Subcommand 0x05: Get page list state\n\nReplies a uint8 with a value of `x01` if there's a Host list with BD addresses/link keys in memory.\n\n### Subcommand 0x06: Set HCI state (disconnect/page/pair/turn off)\n\nCauses the controller to change power state.\n\nTakes as argument a uint8_t:\n\n| Arg value # | Remarks                                       |\n|:-----------:| --------------------------------------------- |\n|   `x00`     | Disconnect (sleep mode / page scan mode)      |\n|   `x01`     | Reboot and Reconnect (page mode)              |\n|   `x02`     | Reboot and enter Pair mode (discoverable)     |\n|   `x04`     | Reboot and Reconnect (page mode / HOME mode?) |\n\nOption `x01`: It does a reboot and tries to reconnect. If no host is found, it goes into sleep.\n\nOption `x02`: If some time passes without a pairing, or pressing a button, the controller connects to the last active BD_ADDR.\n\nOption `x04`: It does a reboot and tries to reconnect. If no host is found, it goes into sleep. It probably does more, as this mode is calle HOME mode.\n\nPage mode (x01, x04) is not to be confused with page scan mode. It's like pressing a button to reconnect, but it does it automatically.\n\nAll extra modes default to sleep mode if nothing happens. This is a R1 page scan mode which can accept a request from host (as seen with the \"Search for Controllers\" option).\n\n### Subcommand 0x07: Reset pairing info\n\nInitializes the 0x2000 SPI section.\n\n### Subcommand 0x08: Set shipment low power state\n\nTakes as argument `x00` or `x01`.\n\nIf `x01` it writes `x01` @`x5000` of SPI flash. With `x00`, it resets to `xFF` @`x5000`.\n\nIf `x01` is set, the feature Triggered Broadcom Fast Connect scans when in suspened or disconnected state is disabled. Additionally, it sets the low power mode, when disconnected, to HID OFF.\n\nThis is useful when the controllers ship, because the controller cannot wake up from button presses. It does not disable all buttons when it has pairing data, only the easy pressable. A long press from the others can wake up the controller, **if it has pairing data**.\n\nSwitch always sends `x08 00` subcmd after every connection, and thus enabling Triggered Broadcom Fast Connect and LPM mode to SLEEP.\n\n### Subcommand 0x10: SPI flash read\nLittle-endian int32 address, int8 size, max size is `x1D`.\nReplies with `x9010` ack and echoes the request info, followed by `size` bytes of data.\n\n```\nRequest:\n[01 .. .. .. .. .. .. .. .. .. 10 80 60 00 00 18]\n                               ^ subcommand\n                                  ^~~~~~~~~~~ address x6080\n                                              ^ length = 0x18 bytes\nResponse: INPUT 21\n[21 .. .. .. .. .. .. .. .. .. .. .. .. 90 10 80 60 00 00 18 .. .. .. ....]\n                                        ^ subcommand reply\n                                              ^~~~~~~~~~~ address\n                                                          ^ length = 0x18 bytes\n                                                             ^~~~~ data\n```\n\n### Subcommand 0x11: SPI flash Write\n\nLittle-endian int32 address, int8 size. Max size `x1D` data to write.\nReplies with `x8011` ack and a uint8 status. `x00` = success, `x01` = write protected.\n\n### Subcommand 0x12: SPI sector erase\n\nTakes a Little-endian uint32. Erases the whole 4KB in the specified address to 0xFF.\nReplies with `x8012` ack and a uint8 status. `x00` = success, `x01` = write protected.\n\n### Subcommand 0x20: Reset NFC/IR MCU\n\n### Subcommand 0x21: Set NFC/IR MCU configuration\n\nWrite configuration data to MCU. This data can be IR configuration, NFC configuration or data for the 512KB MCU firmware update.\n\nTakes 38 or 37 bytes long argument data.\n\nReplies with ACK `xA0` `x20` and 34 bytes of data.\n\n### Subcommand 0x22: Set NFC/IR MCU state\n\nTakes one argument:\n\n| Argument # | Remarks           |\n|:----------:| ----------------- |\n|   `00`     | Suspend           |\n|   `01`     | Resume            |\n|   `02`     | Resume for update |\n\n### Subcommand 0x24: Set unknown data (fw 3.86 and up)\n\nTakes a 38 byte long argument.\n\nSets a byte to `x01` (enable something?) and sets also an unknown data (configuration? for NFC/IR MCU?) to the bt device struct that copies it from given argument.\n\nReplies with `x80 24 00` always.\n\n### Subcommand 0x25: Reset 0x24 unknown data (fw 3.86 and up)\n\nSets the above byte to `x00` (disable something?) and resets the previous 38 byte data to all zeroes.\n\nReplies with `x80 25 00` always.\n\n### Subcommand 0x28: Set unknown NFC/IR MCU data\n\nTakes a 38 byte long argument and copies it to unknown array_222640[96] at &array_222640[3].\n\nDoes the same job with OUTPUT report 0x12.\n\nReplies with ACK `x80` `x28`.\n\n### Subcommand 0x29: Get `x28` NFC/IR MCU data\n\nReplies with ACK `xA8` `x29` and 34 bytes data, from a different buffer than the one the x28 writes.\n\n### Subcommand 0x2A: Set GPIO Pin Output value (2 @Port 2)\n\nTakes a uint8_t and sets unknown GPIO Pin 2 at Port 2 to `0` = GPIO_PIN_OUTPUT_LOW` or `1` = GPIO_PIN_OUTPUT_HIGH`.\n\nThis normally enables a function. For example, subcmd `x48` sets GPIO Pin 7 @Port 2 output value, which disables or enables IMU.\n\nReplies always with ACK `x00` `x2A`.\n\n`x00` as an ACK here is a bug. Devs forgot to add an ACK reply.\n\n### Subcommand 0x2B: Get `x29` NFC/IR MCU data\n\nReplies with ACK `xA9` `x2B` and 20 bytes long data (which has also a part from x24 subcmd).\n\n### Subcommand 0x30: Set player lights\n\nFirst argument byte is a bitfield:\n\n```\naaaa bbbb\n     3210 - keep player light on\n3210 - flash player light\n```\n\nOn overrides flashing. When on USB, flashing bits work like always on bits.\n\n\n### Subcommand 0x31: Get player lights\n\nReplies with ACK `xB0` `x31` and one byte that uses the same bitfield with `x30` subcommand\n\n`xB1` is the 4 leds trail effect. But it can't be set via `x30`.\n\n### Subcommand 0x38: Set HOME Light\n\n25 bytes argument that control 49 elements.\n\n| Byte #, Nibble | Remarks                                                                  |\n|:--------------:| ------------------------------------------------------------------------ |\n| `x00`, High    | Number of Mini Cycles. 1-15. If number of cycles is > 0 then `x0` = `x1` |\n| `x00`, Low     | Global Mini Cycle Duration. 8ms - 175ms. Value `x0` = 0ms/OFF            |\n| `x01`, High    | LED Start Intensity. Value `x0`=0% - `xF`=100%                           |\n| `x01`, Low     | Number of Full Cycles. 1-15. Value `x0` is repeat forever, but if also Byte `x00` High nibble is set to `x0`, it does the 1st Mini Cycle and then the LED stays on with LED Start Intensity. |\n\nWhen all selected Mini Cycles play and then end, this is a full cycle.\n\nThe Mini Cycle configurations are grouped in two (except the 15th):\n\n| Byte #, Nibble | Remarks                                                   |\n|:--------------:| --------------------------------------------------------- |\n| `x02`, High    | Mini Cycle 1 LED Intensity                                |\n| `x02`, Low     | Mini Cycle 2 LED Intensity                                |\n| `x03`, High    | Fading Transition Duration to Mini Cycle 1 (Uses PWM). Value is a Multiplier of Global Mini Cycle Duration |\n| `x03`, Low     | LED Duration Multiplier of Mini Cycle 1. `x0` = `x1` = x1 |\n| `x04`, High    | Fading Transition Duration to Mini Cycle 2 (Uses PWM). Value is a Multiplier of Global Mini Cycle Duration |\n| `x04`, Low     | LED Duration Multiplier of Mini Cycle 1. `x0` = `x1` = x1 |\n\nThe Fading Transition uses a PWM to increment the transition to the Mini Cycle. \n\nThe LED Duration Multiplier and the Fading Multiplier use the same algorithm: Global Mini Cycle Duration ms * Multiplier value. \n\nExample: GMCD is set to `xF` = 175ms and LED Duration Multiplier is set to `x4`. The Duration that the LED will stay on it's configured intensity is then  175 * 4 = 700ms.\n\nUnused Mini Cycles can be skipped from the output packet.\n\nTable of Mini Cycle configuration:\n\n| Byte #, Nibble | Remarks                                   |\n| -------------- | ----------------------------------------- |\n| `x02`, High    | Mini Cycle 1 LED Intensity                |\n| `x02`, Low     | Mini Cycle 2 LED Intensity                |\n| `x03` High/Low | Fading/LED Duration Multipliers for MC 1  |\n| `x04` High/Low | Fading/LED Duration Multipliers for MC 2  |\n| `x05`, High    | Mini Cycle 3 LED Intensity                |\n| `x05`, Low     | Mini Cycle 4 LED Intensity                |\n| `x06` High/Low | Fading/LED Duration Multipliers for MC 3  |\n| `x06` High/Low | Fading/LED Duration Multipliers for MC 4  |\n| ...            | ...                                       |\n| `x20`, High    | Mini Cycle 13 LED Intensity               |\n| `x20`, Low     | Mini Cycle 14 LED Intensity               |\n| `x21` High/Low | Fading/LED Duration Multipliers for MC 13 |\n| `x22` High/Low | Fading/LED Duration Multipliers for MC 14 |\n| `x23`, High    | Mini Cycle 15 LED Intensity               |\n| `x23`, Low     | Unused                                    |\n| `x24` High/Low | Fading/LED Duration Multipliers for MC 15 |\n\n### Subcommand 0x40: Enable IMU (6-Axis sensor)\n\nOne argument of `x00` Disable  or `x01` Enable.\n\n### Subcommand 0x41: Set IMU sensitivity\n\nSets the 6-axis sensor sensitivity for accelerometer and gyroscope. 4 uint8_t.\n\nSending x40 x01 (IMU enable), if it was previously disabled, resets your configuration to Acc: 1.66 kHz (high perf), Â±8G, 100 Hz Anti-aliasing filter bandwidth and Gyro: 208 Hz (high performance), Â±2000dps..\n\nGyroscope sensitivity (Byte 0):\n\n| Arg # | Remarks            |\n|:-----:|:------------------:|\n| `00`  | Â±250dps            |\n| `01`  | Â±500dps            |\n| `02`  | Â±1000dps           |\n| `03`  | Â±2000dps (default) |\n\nAccelerometer sensitivity (Byte 1):\n\n| Arg # | Remarks       |\n|:-----:|:-------------:|\n| `00`  | Â±8G (default) |\n| `01`  | Â±4G           |\n| `02`  | Â±2G           |\n| `03`  | Â±16G          |\n\nGyroscope performance rate (Byte 2):\n\n| Arg # | Remarks                    |\n|:-----:|:--------------------------:|\n| `00`  | 833Hz (high perf)          |\n| `01`  | 208Hz (high perf, default) |\n\nAccelerometer Anti-aliasing filter bandwidth (Byte 3):\n\n| Arg # | Remarks         |\n|:-----:|:---------------:|\n| `00`  | 200Hz           |\n| `01`  | 100Hz (default) |\n\n### Subcommand 0x42: Write to IMU registers\n\nIt takes 3 uint8_t arguments and writes to the selected register. You can write only writable registers (r/w).\n\nConsult LSM6DS3.pdf for all registers and their meaning. The registers addresses are mapped 1:1 in the subcmd.\n\nWith this subcmd you can completely control the IMU.\n\n| Byte # | Remarks                  |\n|:------:|:------------------------:|\n| `00`   | Register address         |\n| `01`   | Always `x01` for writing |\n| `02`   | Value to write           |\n\n### Subcommand 0x43: Read IMU registers\n\nIt takes 2 uint8t_t.\n\n| Byte # | Remarks                    |\n|:------:| -------------------------- |\n| `00`   | Register start address     |\n| `01`   | Registers to show. Max x20 |\n\nIt replies with `xC043##$$`, where ## is the first register address to show and $$ is how many registers to show. After these the data follows.\n\nFor example, by sending `x0020` you can view registers `x00` - `x1F`, `x2020`: `x20` - `x2F`, etc.\n\nTo quickly get the register you need, send `x##01` (## is the register address) and parse the 1st byte after the subcmd + args reply (`xC043##$$`).\n\nConsult LSM6DS3.pdf for all registers and their meaning. The registers addresses are mapped 1:1 in the subcmd.\n\n### Subcommand 0x48: Enable vibration\n\nOne argument of `x00` Disable  or `x01` Enable.\n\n### Subcommand 0x50: Get regulated voltage\n\nReplies with ACK `xD0` `x50` and a little-endian uint16. Raises when charging a Joy-Con.\n\nInternally, the values come from 1000mV - 1800mV regulated voltage samples, that are translated to 1320-1680 values.\n\nThese follow a curve between 3.3V and 4.2V (tested with multimeter). So a 2.5x multiplier can get us the real battery voltage in mV.\n\nBased on this info, we have the following table:\n\n|   Range #            |   Range     | Range in mV | Reported battery |\n|:--------------------:|:-----------:|:-----------:| ---------------- |\n|   `x0528` - `x059F`  | 1320 - 1439 | 3300 - 3599 | 2 - Critical     |\n|   `x05A0` - `x05DF`  | 1440 - 1503 | 3600 - 3759 | 4 - Low          |\n|   `x05E0` - `x0617`  | 1504 - 1559 | 3760 - 3899 | 6 - Medium       |\n|   `x0618` - `x0690`  | 1560 - 1680 | 3900 - 4200 | 8 - Full         |\n\nTests showed charging stops at 1680 and the controller turns off at 1320.\n\n### Subcommand 0x51: Set GPIO Pin Output value (7 & 15 @Port 1)\n\nThis sets the output value for `Pin 7` and `Pin 15` at `Port 1`. It's currently unknown what they do..\n\nIt takes a uint8. Valid values are 0x00, 0x04, 0x10, 0x14. Other values result to these bitwise.\n\nThe end result values are translated to `GPIO_PIN_OUTPUT_LOW = 0` and `GPIO_PIN_OUTPUT_HIGH = 0`.\n\n| Value # | PIN @Port 1 | GPIO Output Value    |\n|:-------:|:-----------:| -------------------- |\n| `x00`   | `7`         | GPIO_PIN_OUTPUT_HIGH |\n|         | `15`        | GPIO_PIN_OUTPUT_LOW  |\n| `x04`   | `7`         | GPIO_PIN_OUTPUT_LOW  |\n|         | `15`        | GPIO_PIN_OUTPUT_LOW  |\n| `x10`   | `7`         | GPIO_PIN_OUTPUT_HIGH |\n|         | `15`        | GPIO_PIN_OUTPUT_HIGH |\n| `x14`   | `7`         | GPIO_PIN_OUTPUT_LOW  |\n|         | `15`        | GPIO_PIN_OUTPUT_HIGH |\n\nReplies with ACK `x80` `x51`.\n\n### Subcommand 0x52: Get GPIO Pin Input/Output value\n\nReplies with ACK `xD1` `x52` and a uint8. The uint8 value is actually 4bit (b0000WXYZ).\n\nEach bit translates to GPIO_PIN_OUTPUT_LOW or GPIO_PIN_OUTPUT_HIGH. The first 3 bits (ZYX) are **inverted**.\n\nExample with 0x12:\n\n| bit LSB o # | PIN @Port | Example Value           |\n|:-----------:|:---------:| ----------------------- |\n| `bit 0` (Z) | `4 @0`    | 0: GPIO_PIN_OUTPUT_HIGH |\n| `bit 1` (Y) | `2 @3`    | 1: GPIO_PIN_OUTPUT_LOW  |\n| `bit 2` (X) | `7 @1`    | 0: GPIO_PIN_OUTPUT_HIGH |\n| `bit 3` (W) | `15 @1`   | 1: GPIO_PIN_OUTPUT_HIGH |\n\nIf the joy-cons are connected to a charging grip, the reply is `x17` (L, L, L, H). If you remove it from it, changes to `x14` (H, H, L, H).\n\nIf you only connect or pair it from sleep mode, the reply is `x04` (H, H, L, L).\n"
        },
        {
          "name": "datasheets",
          "type": "tree",
          "content": null
        },
        {
          "name": "imu_sensor_notes.md",
          "type": "blob",
          "size": 7.5400390625,
          "content": "# 6-Axis sensor information\n\n## Packet data information\n\nIf 6-axis sensor is enabled, the IMU data in an 0x30, 0x31, 0x32 and 0x33 input report is packaged like this (assuming the packet ID is located at byte 0):\n\n| Byte       | Remarks                                                       |\n|:----------:| ------------------------------------------------------------- |\n|   13-14    | accel_x (Int16LE)                                             |\n|   15-16    | accel_y (Int16LE)                                             |\n|   17-18    | accel_z (Int16LE)                                             |\n|   19-20    | gyro_1 (Int16LE)                                              |\n|   21-22    | gyro_2 (Int16LE)                                              |\n|   23-24    | gyro_3 (Int16LE)                                              |\n|   25-48    | The data is repeated 2 more times. Each with 5ms Ît sampling. |\n\nThe 6-Axis data is repeated 3 times. On Joy-con with a 15ms packet push, this is translated to 5ms difference sampling. E.g. 1st sample 0ms, 2nd 5ms, 3rd 10ms. Using all 3 samples let you have a 5ms precision instead of 15ms.\n\n## Axes definition\n\nThe accelerator axes are defined by the output in packet. Because of the placement of the IMU chip, the 2 Joy-Con have an axis reversed each. \n\nThe following images show exactly the 6 axes:\n\n![alt text](http://ctcaer.com/wii/switch/joycon_acc-gyro_left2.png)![alt text](http://ctcaer.com/wii/switch/joycon_acc-gyro_right2.png)\n\n## Convert to basic useful data using raw values\n\n### Accelerometer - Acceleration (in G)\n\nThe following equation should scale an int16 IMU value into an acceleration vector component (measured in Gs):\n\n`acc_vector_component = acc_raw_component * G_RANGE / SENSOR_RES / 1000` [Value in G]\n\nwhere `G_RANGE` is the sensitivity range setting of the accelerometer, as explained [here](http://ozzmaker.com/accelerometer-to-g/).\n\nThe Joy-Con are ranged to Â±8000 MilliGs (G_RANGE = 16000 MilliGs), the sensitivity calibration is always Â±8192 MilliGs and the SENSOR_RES is 16bit, so the above equation can be simplified to:\n\n##### Normal Â±8000 mG:\n\n`acc_vector_component = acc_raw_component * 0.000244f`. (=16000/65535/1000)\n\n### Gyroscope - Rotation (in Degrees/s - dps)\n\nFor Gyro the equation to convert the values into angular velocity (measured in degrees per second):\n\n`gyro_vector_component = gyro_raw_component * G_GAIN / SENSOR_RES` [Value in dps]\n\nwhere G_GAIN is the degrees per second sensitivity range.\n\nThe Joy-Con, based on their configuration, have a gyro sensitivity of Â±2000dps (G_GAIN = 4000dps), so the above equation can be simplified to:\n\n##### Normal Â±2000 dps or 61 mdps/digit:\n\n`gyro_vector_component = gyro_raw_component * 0.06103f` (=4000/65535)\n\nTo express the full-scale rates in both directions without saturating you can add a 15% (STMicroelectronics LSM6DS3 datasheet) and it's the recommended way to do it.\n\nThe new conversion will be:  \n\n##### LSM6DS3 Â±2000 dps or 70 mdps/digit:\n\n`gyro_vector_component = gyro_raw_component * 0.070f` (=4588/65535)\n\n### Gyroscope - Rotation (in revolutions/s)\n\nInternally Switch uses revolutions per second instead of degrees. That's why the gyro calibration is always 13371.\n\nNormally to get revolutions/s you need to follow the below equation:\n\n`gyro_revolutions = gyro_raw_component * G_GAIN / SENSOR_RES / 360.0f` [Value in revolutions/s]\n\nSo the equation for the above 3 sensitivities will become:\n\n##### Normal:\n\n`gyro_revolutions = gyro_raw_component * 0.0001694f` (=4000/65535/360)\n\n##### LSM6DS3:\n\n`gyro_revolutions = gyro_raw_component * 0.0001944f` (=4588/65535/360)\n\nThe [SparkFun library for the LSM6DS3](https://github.com/sparkfun/SparkFun_LSM6DS3_Arduino_Library) will likely be a valuable resource for future IMU hacking.\n\n## Convert to basic useful data using SPI Calibration\n\n### Accelerometer (Calibrated) - Acceleration (in G)\n\nThe SPI `accelerometer calibration`, includes 3 important values for each axis:\n\nThe `cal_acc_origin` is the origin scale value when the Joy-Con is held completely horizontally. It's not an origin position but how the raw values are affected by noise and by the unleveled body of the controller (triggers protruding).\n\nThe `cal_acc_horizontal_offset` is the offest (difference) that the Joy-Con/Pro-con has when it's on a flat surface than being completely horizontal. (The Trigger bumps change its position and you can use this offset to calibrate the position when it is on a flat surface)\n\nThe `cal_acc_horizontal_offset` is always the same. Advise [here](spi_flash_notes.md#6-axis-and-stick-device-parameters) for the values each model (JC Left, JC Right, Pro).\n\n The `cal_acc_coeff` is used for calibrating sensitivity. The default uncalibrated value for Â±8G sensitivity is x4000 (16384). Advise [here](spi_flash_notes.md#6-axis-and-stick-device-parameters).\n\nBased on these we can conclude on the following equation to find the final coefficient:\n\n##### Origin posititon is horizontal and stick is upside:\n\n`acc_coeff = (float)(1.0 / (float)(cal_acc_coeff - uint16_to_int16(cal_acc_origin))) * 4.0f;`\n\nThen we use the coefficient to convert the value into G (SI: 9.8m/sÂ²):\n\n`acc_vector_component = acc_raw_component * acc_coeff`\n\n### Completely level* Accelerometer when horizontal on flat surface:\n\n*This will level the accelerometer to 0 values when resting on flat surface. It's useful when we perform a manual calibration.\n\nWe subtract `cal_acc_horizontal_offset` and then we use the coefficient to convert the value into G (SI: 9.8m/sÂ²):\n\n`acc_vector_component = (acc_raw_component - uint16_to_int16(cal_acc_horizontal_offset)) * acc_coeff`\n\n### Gyroscope (Calibrated) - Rotation (in Degrees/s - dps)\n\nThe SPI `gyro calibration`, includes 2 important values for each axis:\n\nThe `cal_gyro_offset` is the offset when the Joy-Con is stable (held still).\n\nThe `cal_gyro_coeff` is used for calibrating sensitivity. The default uncalibrated value for Â±2000dps sensitivity is x343B (13371). Advise [here](spi_flash_notes.md#6-axis-and-stick-device-parameters).\n\nBased on these we can conclude on the final equation:\n\n##### Default (saturation free) LSM6DS3 Â±2000 dps : 70 mdps/digit:\n\n`gyro_cal_coeff = (float)(936.0 / (float)(cal_gyro_coeff - uint16_to_int16(cal_gyro_offset)));`\n\n##### Accurate Â±2000 dps : 61 mdps/digit:\n\n`gyro_cal_coeff = (float)(816.0 / (float)(cal_gyro_coeff - uint16_to_int16(cal_gyro_offset)));`\n\nThen we use the coefficient to convert the value into degreesÂ°/s (SI: 0.01745 rad/s):\n\n`gyro_vector_component = (gyro_raw_component - uint16_to_int16(cal_gyro_offset)) * gyro_cal_coeff`\n\nHere, unlike acceleration, the origin position is indeed the still position and not a scaling value. So it must be also used in the unit calculation, in addition to coeffition.\n\n### Gyroscope - Rotation (in revolutions/s)\n\nThe equation will become:\n\n`gyro_vector_component = (gyro_raw_component - uint16_to_int16(cal_gyro_offset)) * gyro_cal_coeff * 0.0027777778`\n\n## Noise level range for each sensitivity configuration\n\nThis is useful to set a noise cancellation deadzone for acc and gyro.\n\nBased on official values. Also it's a range value (not a Â± value).\n\nAccelerometer:\n\n| Sensitivity   | Noise level range |\n|:-------------:|:-----------------:|\n| Â±2G           | 328 * 2.5 = 2050  |\n| Â±4G           | 164 * 2.5 = 410   |\n| Â±8G (default) | 82 * 2.5 = 205    |\n| Â±16G          | No official value |\n\nGyroscope:\n\n| Sensitivity        | Noise level range |\n|:------------------:|:-----------------:|\n| Â±250dps            | 236 * 2.5 = 590   |\n| Â±500dps            | 118 * 2.5 = 295   |\n| Â±1000dps           | 59 * 2.5 = 147    |\n| Â±2000dps (default) | 30 * 2.5 = 75     |\n"
        },
        {
          "name": "joycon_pcb.pdf",
          "type": "blob",
          "size": 5209.7451171875,
          "content": ""
        },
        {
          "name": "joycon_reader",
          "type": "tree",
          "content": null
        },
        {
          "name": "joycon_spoofer",
          "type": "tree",
          "content": null
        },
        {
          "name": "logic_captures",
          "type": "tree",
          "content": null
        },
        {
          "name": "packet_parse",
          "type": "tree",
          "content": null
        },
        {
          "name": "peripheral device",
          "type": "tree",
          "content": null
        },
        {
          "name": "push.sh",
          "type": "blob",
          "size": 0.3369140625,
          "content": "find . -type f -name \"*.b#*\" -exec rm -f {} \\;\nfind . -type f -name \"*.s#*\" -exec rm -f {} \\;\nfind . -type f -name \"*.l#*\" -exec rm -f {} \\;\nfind . -type f -name \"*.csv#*\" -exec rm -f {} \\;\nfind . -type f -name \"*.DS_Store*\" -exec rm -f {} \\;\nfind . -name \"__pycache__\" -exec rm -rf {} \\;\ngit add --all\ngit commit -m \"$@\"\ngit push origin master\n"
        },
        {
          "name": "rumble_data_table.md",
          "type": "blob",
          "size": 12.2744140625,
          "content": "The encoding algorithm for frequency is log2((double)freq/10.0)*32.0.\nThe algorithm for amplitude is split in 3 range indexes (idx < 16, 16 <= idx < 32, idx < 128), it is:\n```\n// 32<= idx < 128\nlog2f(8.7f*amp)*32.0f\n\n// 16 <= idx < 32\nlog2f(17.0f*amp)*16.0f\n```\n\nAn example of code using it is:\n\n```\n//Float frequency to hex conversion\nif (freq < 0.0f)\n  freq = 0.0f;\nelse if (freq > 1252.0f)\n  freq = 1252.0f;\nuint8_t encoded_hex_freq = (uint8_t)round(log2((double)freq/10.0)*32.0);\n\n//Convert to Joy-Con HF range. Range in big-endian: 0x0004-0x01FC with +0x0004 steps.\nuint16_t hf = (encoded_hex_freq-0x60)*4;\n//Convert to Joy-Con LF range. Range: 0x01-0x7F.\nuint8_t lf = encoded_hex_freq-0x40;\n\n// Float amplitude to hex conversion\nuint8_t encoded_hex_amp = 0;\nif(amp > 0.23f)\n  encoded_hex_amp = (uint8_t)round(log2f(amp*8.7f)*32.f);\nelse if(amp > 0.12f)\n  encoded_hex_amp = (uint8_t)round(log2f(amp*17.f)*16.f);\nelse{\n  // TBD\n}\nuint16_t hf_amp = encoded_hex_amp * 2;    // encoded_hex_amp<<1;\nuint8_t lf_amp = encoded_hex_amp / 2 + 64;// (encoded_hex_amp>>1)+0x40;\n```\n\nThe high frequency and low amplitude are encoded and must always add the \"control\" byte to the HA/LF byte. An example is the following:\n```\n//Left linear actuator\nuint16_t hf = 0x01a8; //Set H.Frequency\nuint8_t hf_amp = 0x88; //Set H.Frequency amplitude\n//Byte swapping\nbyte[0] = hf & 0xFF;\nbyte[1] = hf_amp + ((hf >> 8) & 0xFF); //Add amp + 1st byte of frequency to amplitude byte\n\nuint8_t lf = 0x63; //Set L.Frequency\nuint16_t lf_amp = 0x804d; //Set L.Frequency amplitude\n//Byte swapping\nbyte[2] = lf + ((lf_amp >> 8) & 0xFF); //Add freq + 1st byte of LF amplitude to the frequency byte\nbyte[3] = lf_amp & 0xFF;\n```\n\n## Frequency Table\n\nValues # are in HEX.\n\n| HF Byte 0-1 # | LF Byte 2 # | Frequency (Hz) | Frequency Rounded (Hz) |\n|:--:|:---:|:---:|:---:|\n|\t\t|\t`01`\t|\t40.875885\t|\t41\t|\n|\t\t|\t`02`\t|\t41.77095\t|\t42\t|\n|\t\t|\t`03`\t|\t42.685616\t|\t43\t|\n|\t\t|\t`04`\t|\t43.620308\t|\t44\t|\n|\t\t|\t`05`\t|\t44.57547\t|\t45\t|\n|\t\t|\t`06`\t|\t45.551544\t|\t46\t|\n|\t\t|\t`07`\t|\t46.548996\t|\t47\t|\n|\t\t|\t`08`\t|\t47.568283\t|\t48\t|\n|\t\t|\t`09`\t|\t48.609894\t|\t49\t|\n|\t\t|\t`0A`\t|\t49.674313\t|\t50\t|\n|\t\t|\t`0B`\t|\t50.762039\t|\t51\t|\n|\t\t|\t`0C`\t|\t51.873581\t|\t52\t|\n|\t\t|\t`0D`\t|\t53.009464\t|\t53\t|\n|\t\t|\t`0E`\t|\t54.170223\t|\t54\t|\n|\t\t|\t`0F`\t|\t55.356396\t|\t55\t|\n|\t\t|\t`10`\t|\t56.568542\t|\t57\t|\n|\t\t|\t`11`\t|\t57.807232\t|\t58\t|\n|\t\t|\t`12`\t|\t59.073048\t|\t59\t|\n|\t\t|\t`13`\t|\t60.366577\t|\t60\t|\n|\t\t|\t`14`\t|\t61.688435\t|\t62\t|\n|\t\t|\t`15`\t|\t63.039234\t|\t63\t|\n|\t\t|\t`16`\t|\t64.419617\t|\t64\t|\n|\t\t|\t`17`\t|\t65.830215\t|\t66\t|\n|\t\t|\t`18`\t|\t67.271713\t|\t67\t|\n|\t\t|\t`19`\t|\t68.744774\t|\t69\t|\n|\t\t|\t`1A`\t|\t70.250084\t|\t70\t|\n|\t\t|\t`1B`\t|\t71.788361\t|\t72\t|\n|\t\t|\t`1C`\t|\t73.360321\t|\t73\t|\n|\t\t|\t`1D`\t|\t74.966705\t|\t75\t|\n|\t\t|\t`1e`\t|\t76.608261\t|\t77\t|\n|\t\t|\t`1f`\t|\t78.285767\t|\t78\t|\n|\t\t|\t`20`\t|\t80\t|\t80\t|\n|\t`04 00`\t|\t`21`\t|\t81.75177\t|\t82\t|\n|\t`08 00`\t|\t`22`\t|\t83.541901\t|\t84\t|\n|\t`0c 00`\t|\t`23`\t|\t85.371231\t|\t85\t|\n|\t`10 00`\t|\t`24`\t|\t87.240616\t|\t87\t|\n|\t`14 00`\t|\t`25`\t|\t89.15094\t|\t89\t|\n|\t`18 00`\t|\t`26`\t|\t91.103088\t|\t91\t|\n|\t`1c 00`\t|\t`27`\t|\t93.097992\t|\t93\t|\n|\t`20 00`\t|\t`28`\t|\t95.136566\t|\t95\t|\n|\t`24 00`\t|\t`29`\t|\t97.219788\t|\t97\t|\n|\t`28 00`\t|\t`2a`\t|\t99.348625\t|\t99\t|\n|\t`2c 00`\t|\t`2b`\t|\t101.524078\t|\t102\t|\n|\t`30 00`\t|\t`2c`\t|\t103.747162\t|\t104\t|\n|\t`34 00`\t|\t`2d`\t|\t106.018929\t|\t106\t|\n|\t`38 00`\t|\t`2e`\t|\t108.340446\t|\t108\t|\n|\t`3c 00`\t|\t`2f`\t|\t110.712791\t|\t111\t|\n|\t`40 00`\t|\t`30`\t|\t113.137085\t|\t113\t|\n|\t`44 00`\t|\t`31`\t|\t115.614464\t|\t116\t|\n|\t`48 00`\t|\t`32`\t|\t118.146095\t|\t118\t|\n|\t`4c 00`\t|\t`33`\t|\t120.733154\t|\t121\t|\n|\t`50 00`\t|\t`34`\t|\t123.376869\t|\t123\t|\n|\t`54 00`\t|\t`35`\t|\t126.078468\t|\t126\t|\n|\t`58 00`\t|\t`36`\t|\t128.839233\t|\t129\t|\n|\t`5c 00`\t|\t`37`\t|\t131.660431\t|\t132\t|\n|\t`60 00`\t|\t`38`\t|\t134.543427\t|\t135\t|\n|\t`64 00`\t|\t`39`\t|\t137.489548\t|\t137\t|\n|\t`68 00`\t|\t`3a`\t|\t140.500168\t|\t141\t|\n|\t`6c 00`\t|\t`3b`\t|\t143.576721\t|\t144\t|\n|\t`70 00`\t|\t`3c`\t|\t146.720642\t|\t147\t|\n|\t`74 00`\t|\t`3d`\t|\t149.933411\t|\t150\t|\n|\t`78 00`\t|\t`3e`\t|\t153.216522\t|\t153\t|\n|\t`7c 00`\t|\t`3f`\t|\t156.571533\t|\t157\t|\n|\t`80 00`\t|\t`40`\t|\t160\t|\t160\t|\n|\t`84 00`\t|\t`41`\t|\t163.50354\t|\t164\t|\n|\t`88 00`\t|\t`42`\t|\t167.083801\t|\t167\t|\n|\t`8c 00`\t|\t`43`\t|\t170.742462\t|\t171\t|\n|\t`90 00`\t|\t`44`\t|\t174.481232\t|\t174\t|\n|\t`94 00`\t|\t`45`\t|\t178.30188\t|\t178\t|\n|\t`98 00`\t|\t`46`\t|\t182.206177\t|\t182\t|\n|\t`9c 00`\t|\t`47`\t|\t186.195984\t|\t186\t|\n|\t`a0 00`\t|\t`48`\t|\t190.273132\t|\t190\t|\n|\t`a4 00`\t|\t`49`\t|\t194.439575\t|\t194\t|\n|\t`a8 00`\t|\t`4a`\t|\t198.69725\t|\t199\t|\n|\t`ac 00`\t|\t`4b`\t|\t203.048157\t|\t203\t|\n|\t`b0 00`\t|\t`4c`\t|\t207.494324\t|\t207\t|\n|\t`b4 00`\t|\t`4d`\t|\t212.037857\t|\t212\t|\n|\t`b8 00`\t|\t`4e`\t|\t216.680893\t|\t217\t|\n|\t`bc 00`\t|\t`4f`\t|\t221.425583\t|\t221\t|\n|\t`c0 00`\t|\t`50`\t|\t226.27417\t|\t226\t|\n|\t`c4 00`\t|\t`51`\t|\t231.228928\t|\t231\t|\n|\t`c8 00`\t|\t`52`\t|\t236.292191\t|\t236\t|\n|\t`cc 00`\t|\t`53`\t|\t241.466309\t|\t241\t|\n|\t`d0 00`\t|\t`54`\t|\t246.753738\t|\t247\t|\n|\t`d4 00`\t|\t`55`\t|\t252.156937\t|\t252\t|\n|\t`d8 00`\t|\t`56`\t|\t257.678467\t|\t258\t|\n|\t`dc 00`\t|\t`57`\t|\t263.320862\t|\t263\t|\n|\t`e0 00`\t|\t`58`\t|\t269.086853\t|\t269\t|\n|\t`e4 00`\t|\t`59`\t|\t274.979095\t|\t275\t|\n|\t`e8 00`\t|\t`5a`\t|\t281.000336\t|\t281\t|\n|\t`ec 00`\t|\t`5b`\t|\t287.153442\t|\t287\t|\n|\t`f0 00`\t|\t`5c`\t|\t293.441284\t|\t293\t|\n|\t`f4 00`\t|\t`5d`\t|\t299.866821\t|\t300\t|\n|\t`f8 00`\t|\t`5e`\t|\t306.433044\t|\t306\t|\n|\t`fc 00`\t|\t`5f`\t|\t313.143066\t|\t313\t|\n|\t`00 01`\t|\t`60`\t|\t320\t|\t320\t|\n|\t`04 01`\t|\t`61`\t|\t327.00708\t|\t327\t|\n|\t`08 01`\t|\t`62`\t|\t334.167603\t|\t334\t|\n|\t`0c 01`\t|\t`63`\t|\t341.484924\t|\t341\t|\n|\t`10 01`\t|\t`64`\t|\t348.962463\t|\t349\t|\n|\t`14 01`\t|\t`65`\t|\t356.60376\t|\t357\t|\n|\t`18 01`\t|\t`66`\t|\t364.412354\t|\t364\t|\n|\t`1c 01`\t|\t`67`\t|\t372.391968\t|\t372\t|\n|\t`20 01`\t|\t`68`\t|\t380.546265\t|\t381\t|\n|\t`24 01`\t|\t`69`\t|\t388.87915\t|\t389\t|\n|\t`28 01`\t|\t`6a`\t|\t397.394501\t|\t397\t|\n|\t`2c 01`\t|\t`6b`\t|\t406.096313\t|\t406\t|\n|\t`30 01`\t|\t`6c`\t|\t414.988647\t|\t415\t|\n|\t`34 01`\t|\t`6d`\t|\t424.075714\t|\t424\t|\n|\t`38 01`\t|\t`6e`\t|\t433.361786\t|\t433\t|\n|\t`3c 01`\t|\t`6f`\t|\t442.851166\t|\t443\t|\n|\t`40 01`\t|\t`70`\t|\t452.54834\t|\t453\t|\n|\t`44 01`\t|\t`71`\t|\t462.457855\t|\t462\t|\n|\t`48 01`\t|\t`72`\t|\t472.584381\t|\t473\t|\n|\t`4c 01`\t|\t`73`\t|\t482.932617\t|\t483\t|\n|\t`50 01`\t|\t`74`\t|\t493.507477\t|\t494\t|\n|\t`54 01`\t|\t`75`\t|\t504.313873\t|\t504\t|\n|\t`58 01`\t|\t`76`\t|\t515.356934\t|\t515\t|\n|\t`5c 01`\t|\t`77`\t|\t526.641724\t|\t527\t|\n|\t`60 01`\t|\t`78`\t|\t538.173706\t|\t538\t|\n|\t`64 01`\t|\t`79`\t|\t549.958191\t|\t550\t|\n|\t`68 01`\t|\t`7a`\t|\t562.000671\t|\t562\t|\n|\t`6c 01`\t|\t`7b`\t|\t574.306885\t|\t574\t|\n|\t`70 01`\t|\t`7c`\t|\t586.882568\t|\t587\t|\n|\t`74 01`\t|\t`7d`\t|\t599.733643\t|\t600\t|\n|\t`78 01`\t|\t`7e`\t|\t612.866089\t|\t613\t|\n|\t`7c 01`\t|\t`7f`\t|\t626.286133\t|\t626\t|\n|\t`80 01`\t|\t\t|\t640\t|\t640\t|\n|\t`84 01`\t|\t\t|\t654.01416\t|\t654\t|\n|\t`88 01`\t|\t\t|\t668.335205\t|\t668\t|\n|\t`8c 01`\t|\t\t|\t682.969849\t|\t683\t|\n|\t`90 01`\t|\t\t|\t697.924927\t|\t698\t|\n|\t`94 01`\t|\t\t|\t713.20752\t|\t713\t|\n|\t`98 01`\t|\t\t|\t728.824707\t|\t729\t|\n|\t`9c 01`\t|\t\t|\t744.783936\t|\t745\t|\n|\t`a0 01`\t|\t\t|\t761.092529\t|\t761\t|\n|\t`a4 01`\t|\t\t|\t777.758301\t|\t778\t|\n|\t`a8 01`\t|\t\t|\t794.789001\t|\t795\t|\n|\t`ac 01`\t|\t\t|\t812.192627\t|\t812\t|\n|\t`b0 01`\t|\t\t|\t829.977295\t|\t830\t|\n|\t`b4 01`\t|\t\t|\t848.151428\t|\t848\t|\n|\t`b8 01`\t|\t\t|\t866.723572\t|\t867\t|\n|\t`bc 01`\t|\t\t|\t885.702332\t|\t886\t|\n|\t`c0 01`\t|\t\t|\t905.09668\t|\t905\t|\n|\t`c4 01`\t|\t\t|\t924.91571\t|\t925\t|\n|\t`c8 01`\t|\t\t|\t945.168762\t|\t945\t|\n|\t`cc 01`\t|\t\t|\t965.865234\t|\t966\t|\n|\t`d0 01`\t|\t\t|\t987.014954\t|\t987\t|\n|\t`d4 01`\t|\t\t|\t1008.627747\t|\t1009\t|\n|\t`d8 01`\t|\t\t|\t1030.713867\t|\t1031\t|\n|\t`dc 01`\t|\t\t|\t1053.283447\t|\t1053\t|\n|\t`e0 01`\t|\t\t|\t1076.347412\t|\t1076\t|\n|\t`e4 01`\t|\t\t|\t1099.916382\t|\t1100\t|\n|\t`e8 01`\t|\t\t|\t1124.001343\t|\t1124\t|\n|\t`ec 01`\t|\t\t|\t1148.61377\t|\t1149\t|\n|\t`f0 01`\t|\t\t|\t1173.765137\t|\t1174\t|\n|\t`f4 01`\t|\t\t|\t1199.467285\t|\t1199\t|\n|\t`f8 01`\t|\t\t|\t1225.732178\t|\t1226\t|\n|\t`fc 01`\t|\t\t|\t1252.572266\t|\t1253\t|\n\n\n\n## Amplitude Table\n\n| HA Byte 1 # | LA Byte 2-3 # | Amplitude | Amplitude Rounded |\n|:--:|:---:|:---:|:---:|\n|\t`0`\t|\t`00 40`\t|\t0.000000\t|\t0.000\t|\n|\t`2`\t|\t`80 40`\t|\t0.007843\t|\t0.010\t|\n|\t`4`\t|\t`00 41`\t|\t0.011823\t|\t0.012\t|\n|\t`6`\t|\t`80 41`\t|\t0.014061\t|\t0.014\t|\n|\t`8`\t|\t`00 42`\t|\t0.016720\t|\t0.017\t|\n|\t`0a`\t|\t`80 42`\t|\t0.019885\t|\t0.020\t|\n|\t`0c`\t|\t`00 43`\t|\t0.023648\t|\t0.024\t|\n|\t`0e`\t|\t`80 43`\t|\t0.028123\t|\t0.028\t|\n|\t`10`\t|\t`00 44`\t|\t0.033442\t|\t0.033\t|\n|\t`12`\t|\t`80 44`\t|\t0.039771\t|\t0.040\t|\n|\t`14`\t|\t`00 45`\t|\t0.047296\t|\t0.047\t|\n|\t`16`\t|\t`80 45`\t|\t0.056246\t|\t0.056\t|\n|\t`18`\t|\t`00 46`\t|\t0.066886\t|\t0.067\t|\n|\t`1a`\t|\t`80 46`\t|\t0.079542\t|\t0.080\t|\n|\t`1c`\t|\t`00 47`\t|\t0.094592\t|\t0.095\t|\n|\t`1e`\t|\t`80 47`\t|\t0.112491\t|\t0.112\t|\n|\t`20`\t|\t`00 48`\t|\t0.117471\t|\t0.117\t|\n|\t`22`\t|\t`80 48`\t|\t0.122671\t|\t0.123\t|\n|\t`24`\t|\t`00 49`\t|\t0.128102\t|\t0.128\t|\n|\t`26`\t|\t`80 49`\t|\t0.133774\t|\t0.134\t|\n|\t`28`\t|\t`00 4a`\t|\t0.139697\t|\t0.140\t|\n|\t`2a`\t|\t`80 4a`\t|\t0.145882\t|\t0.146\t|\n|\t`2c`\t|\t`00 4b`\t|\t0.152341\t|\t0.152\t|\n|\t`2e`\t|\t`80 4b`\t|\t0.159085\t|\t0.159\t|\n|\t`30`\t|\t`00 4c`\t|\t0.166129\t|\t0.166\t|\n|\t`32`\t|\t`80 4c`\t|\t0.173484\t|\t0.173\t|\n|\t`34`\t|\t`00 4d`\t|\t0.181166\t|\t0.181\t|\n|\t`36`\t|\t`80 4d`\t|\t0.189185\t|\t0.189\t|\n|\t`38`\t|\t`00 4e`\t|\t0.197561\t|\t0.198\t|\n|\t`3a`\t|\t`80 4e`\t|\t0.206308\t|\t0.206\t|\n|\t`3c`\t|\t`00 4f`\t|\t0.215442\t|\t0.215\t|\n|\t`3e`\t|\t`80 4f`\t|\t0.224982\t|\t0.225\t|\n|\t`40`\t|\t`00 50`\t|\t0.229908\t|\t0.230\t|\n|\t`42`\t|\t`80 50`\t|\t0.234943\t|\t0.235\t|\n|\t`44`\t|\t`00 51`\t|\t0.240087\t|\t0.240\t|\n|\t`46`\t|\t`80 51`\t|\t0.245345\t|\t0.245\t|\n|\t`48`\t|\t`00 52`\t|\t0.250715\t|\t0.251\t|\n|\t`4a`\t|\t`80 52`\t|\t0.256206\t|\t0.256\t|\n|\t`4c`\t|\t`00 53`\t|\t0.261816\t|\t0.262\t|\n|\t`4e`\t|\t`80 53`\t|\t0.267549\t|\t0.268\t|\n|\t`50`\t|\t`00 54`\t|\t0.273407\t|\t0.273\t|\n|\t`52`\t|\t`80 54`\t|\t0.279394\t|\t0.279\t|\n|\t`54`\t|\t`00 55`\t|\t0.285514\t|\t0.286\t|\n|\t`56`\t|\t`80 55`\t|\t0.291765\t|\t0.292\t|\n|\t`58`\t|\t`00 56`\t|\t0.298154\t|\t0.298\t|\n|\t`5a`\t|\t`80 56`\t|\t0.304681\t|\t0.305\t|\n|\t`5c`\t|\t`00 57`\t|\t0.311353\t|\t0.311\t|\n|\t`5e`\t|\t`80 57`\t|\t0.318171\t|\t0.318\t|\n|\t`60`\t|\t`00 58`\t|\t0.325138\t|\t0.325\t|\n|\t`62`\t|\t`80 58`\t|\t0.332258\t|\t0.332\t|\n|\t`64`\t|\t`00 59`\t|\t0.339534\t|\t0.340\t|\n|\t`66`\t|\t`80 59`\t|\t0.346969\t|\t0.347\t|\n|\t`68`\t|\t`00 5a`\t|\t0.354566\t|\t0.355\t|\n|\t`6a`\t|\t`80 5a`\t|\t0.362331\t|\t0.362\t|\n|\t`6c`\t|\t`00 5b`\t|\t0.370265\t|\t0.370\t|\n|\t`6e`\t|\t`80 5b`\t|\t0.378372\t|\t0.378\t|\n|\t`70`\t|\t`00 5c`\t|\t0.386657\t|\t0.387\t|\n|\t`72`\t|\t`80 5c`\t|\t0.395124\t|\t0.395\t|\n|\t`74`\t|\t`00 5d`\t|\t0.403777\t|\t0.404\t|\n|\t`76`\t|\t`80 5d`\t|\t0.412619\t|\t0.413\t|\n|\t`78`\t|\t`00 5e`\t|\t0.421652\t|\t0.422\t|\n|\t`7a`\t|\t`80 5e`\t|\t0.430885\t|\t0.431\t|\n|\t`7c`\t|\t`00 5f`\t|\t0.440321\t|\t0.440\t|\n|\t`7e`\t|\t`80 5f`\t|\t0.449964\t|\t0.450\t|\n|\t`80`\t|\t`00 60`\t|\t0.459817\t|\t0.460\t|\n|\t`82`\t|\t`80 60`\t|\t0.469885\t|\t0.470\t|\n|\t`84`\t|\t`00 61`\t|\t0.480174\t|\t0.480\t|\n|\t`86`\t|\t`80 61`\t|\t0.490689\t|\t0.491\t|\n|\t`88`\t|\t`00 62`\t|\t0.501433\t|\t0.501\t|\n|\t`8a`\t|\t`80 62`\t|\t0.512413\t|\t0.512\t|\n|\t`8c`\t|\t`00 63`\t|\t0.523633\t|\t0.524\t|\n|\t`8e`\t|\t`80 63`\t|\t0.535100\t|\t0.535\t|\n|\t`90`\t|\t`00 64`\t|\t0.546816\t|\t0.547\t|\n|\t`92`\t|\t`80 64`\t|\t0.558790\t|\t0.559\t|\n|\t`94`\t|\t`00 65`\t|\t0.571027\t|\t0.571\t|\n|\t`96`\t|\t`80 65`\t|\t0.583530\t|\t0.584\t|\n|\t`98`\t|\t`00 66`\t|\t0.596307\t|\t0.596\t|\n|\t`9a`\t|\t`80 66`\t|\t0.609365\t|\t0.609\t|\n|\t`9c`\t|\t`00 67`\t|\t0.622708\t|\t0.623\t|\n|\t`9e`\t|\t`80 67`\t|\t0.636344\t|\t0.636\t|\n|\t`a0`\t|\t`00 68`\t|\t0.650279\t|\t0.650\t|\n|\t`a2`\t|\t`80 68`\t|\t0.664518\t|\t0.665\t|\n|\t`a4`\t|\t`00 69`\t|\t0.679069\t|\t0.679\t|\n|\t`a6`\t|\t`80 69`\t|\t0.693939\t|\t0.694\t|\n|\t`a8`\t|\t`00 6a`\t|\t0.709133\t|\t0.709\t|\n|\t`aa`\t|\t`80 6a`\t|\t0.724662\t|\t0.725\t|\n|\t`ac`\t|\t`00 6b`\t|\t0.740529\t|\t0.741\t|\n|\t`ae`\t|\t`80 6b`\t|\t0.756745\t|\t0.757\t|\n|\t`b0`\t|\t`00 6c`\t|\t0.773316\t|\t0.773\t|\n|\t`b2`\t|\t`80 6c`\t|\t0.790249\t|\t0.790\t|\n|\t`b4`\t|\t`00 6d`\t|\t0.807554\t|\t0.808\t|\n|\t`b6`\t|\t`80 6d`\t|\t0.825237\t|\t0.825\t|\n|\t`b8`\t|\t`00 6e`\t|\t0.843307\t|\t0.843\t|\n|\t`ba`\t|\t`80 6e`\t|\t0.861772\t|\t0.862\t|\n|\t`bc`\t|\t`00 6f`\t|\t0.880643\t|\t0.881\t|\n|\t`be`\t|\t`80 6f`\t|\t0.899928\t|\t0.900\t|\n|\t`c0`\t|\t`00 70`\t|\t0.919633\t|\t0.920\t|\n|\t`c2`\t|\t`80 70`\t|\t0.939771\t|\t0.940\t|\n|\t`c4`\t|\t`00 71`\t|\t0.960348\t|\t0.960\t|\n|\t`c6`\t|\t`80 71`\t|\t0.981378\t|\t0.981\t|\n|\t`c8`\t|\t`00 72`\t|\t1.002867\t|\t1.003\t|\n\nThe amplitudes below are not safe for the integrity of the linear resonant actuators.\n\n| HA Byte 1 # | LA Byte 2-3 # | Amplitude | Amplitude Rounded |\n|:--:|:---:|:---:|:---:|\n|\t`ca`\t|\t`80 72`\t|\t1.024826\t|\t1.025\t|\n|\t`cc`\t|\t`00 73`\t|\t1.047266\t|\t1.047\t|\n|\t`ce`\t|\t`80 73`\t|\t1.070197\t|\t1.070\t|\n|\t`d0`\t|\t`00 74`\t|\t1.093630\t|\t1.094\t|\n|\t`d2`\t|\t`80 74`\t|\t1.117576\t|\t1.118\t|\n|\t`d4`\t|\t`00 75`\t|\t1.142045\t|\t1.142\t|\n|\t`d6`\t|\t`80 75`\t|\t1.167051\t|\t1.167\t|\n|\t`d8`\t|\t`00 76`\t|\t1.192603\t|\t1.193\t|\n|\t`da`\t|\t`80 76`\t|\t1.218715\t|\t1.219\t|\n|\t`dc`\t|\t`00 77`\t|\t1.245398\t|\t1.245\t|\n|\t`de`\t|\t`80 77`\t|\t1.272665\t|\t1.273\t|\n|\t`e0`\t|\t`00 78`\t|\t1.300529\t|\t1.301\t|\n|\t`e2`\t|\t`80 78`\t|\t1.329003\t|\t1.329\t|\n|\t`e4`\t|\t`00 79`\t|\t1.358100\t|\t1.358\t|\n|\t`e6`\t|\t`80 79`\t|\t1.387834\t|\t1.388\t|\n|\t`e8`\t|\t`00 7a`\t|\t1.418218\t|\t1.418\t|\n|\t`ea`\t|\t`80 7a`\t|\t1.449268\t|\t1.449\t|\n|\t`ec`\t|\t`00 7b`\t|\t1.480997\t|\t1.481\t|\n|\t`ee`\t|\t`80 7b`\t|\t1.513420\t|\t1.513\t|\n|\t`f0`\t|\t`00 7c`\t|\t1.546553\t|\t1.547\t|\n|\t`f2`\t|\t`80 7c`\t|\t1.580411\t|\t1.580\t|\n|\t`f4`\t|\t`00 7d`\t|\t1.615010\t|\t1.615\t|\n|\t`f6`\t|\t`80 7d`\t|\t1.650366\t|\t1.650\t|\n|\t`f8`\t|\t`00 7e`\t|\t1.686497\t|\t1.686\t|\n|\t`fa`\t|\t`80 7e`\t|\t1.723417\t|\t1.723\t|\n|\t`fc`\t|\t`00 7f`\t|\t1.761146\t|\t1.761\t|\n|\t`fe`\t|\t`80 7f`\t|\t1.799701\t|\t1.800\t|\n\n\n"
        },
        {
          "name": "spi_flash_notes.md",
          "type": "blob",
          "size": 15.4892578125,
          "content": "#SPI Flash Memory Information\n\n## SPI memory map\n\n| Section Name            |  Offset | Size    | Remarks                                                              |\n| ----------------------- |:-------:|:-------:| -------------------------------------------------------------------- |\n| Initial PatchRAM        | `x0000` | `x1000` | Stores static data like BT address, OTA DS 1 offset, etc             |\n| Failsafe                | `x1000` | `x1000` | Stores OTA Signature Magic and OTA Dynamic Section 2 offset          |\n| Pairing info            | `x2000` | `x1000` | Stores last connected device, data for Sticks and Sensor calibration |\n| Pairing info (factory)  | `x3000` | `x1000` | Empty. (Dev-units use it?)                                           |\n| Pairing info (factory2) | `x4000` | `x1000` | Empty. (Dev-units use it?)                                           |\n| Shipment                | `x5000` | `x1000` | Only first byte is used                                              |\n| Config and calibration  | `x6000` | `xA000` | Stores Factory configuration and calibration, user calibration       |\n| PatchRAM section        | `x10000`| `x70000`| Stores Broadcom PatchRAMs, by default @0x10000 and @0x28000          |\n\n## x0000: Initial PatchRAM\n\nInitial PatchRAM section starts at `x0000` and ends at `x03B0`. Has a total of 13 records and does not end with the usual PatchRAM EOF footer (xFE 0000).\n\nIncludes Magic numbers, OTA FW DS1 address and code that loads the PatchRAM @0x10000 or @0x28000 by checking the 0xx1ff4 address.\n\n|    Range        |        Sample                       | Remarks                                             |\n|:---------------:|:-----------------------------------:| --------------------------------------------------- |\n| `x0000`-`x0010` | `x01 08 00 F0 00 00 62 08 C0 5D 89` | Loader Magic or it sends x895DC008 @x620000F0 MMIO  |\n| `x0012`-`x001A` | `x40 0600 x5730EA8ABB7C`            | BD_ADDR type record, in LE (7C:BB:8A:EA:30:57)      |\n| `x001B`-`x03AF` | ---                                 | Initial code that loads one of the main PatchRAM    |\n| `x03B0`-`x03B7` | `x02 0A 00000100 00200000 0010`     | DS1 Uint32LE (`x010000`) and 2 values (x200, x1000) |\n\n## x1000 Failsafe mechanism\n\nThe failsafe mechanism has 2 functions.\n\nBootloader checks OTA Magic and if it's OK, it loads the OTA FW in DS2 offset, otherwise from DS1.\n\nTo update OTA FW in DS1 location, it needs a valid OTA Signature Magic which is a result from a verified OTA FW in DS2. Then proceeds to update OTA FW 1 and erases the whole failsafe section, so it can load OTA FW from DS1.\n\n|    Range        |        Sample              | Remarks                                                    |\n|:---------------:|:--------------------------:| ---------------------------------------------------------- |\n| `x1FF4`-`x1FFB` | `xAA 5 5F0 0F 68 E5 97 D2` | OTA Signature Magic, reversed (`xD2 97 E5 68 0F F0 55 AA`) |\n| `x1FFC`-`x1FFF` | `x00800200`                | Dynamic Section Offset 2 for OTA FW, reversed (`x028000`) |\n\nNo data before `x1FF4`.\n\n## x2000 Pairing info\n\nUsed internally to store current and previous Host Bluetooth addresses and Long Term Keys.\n\nIt can store entries until it fills  the whole section.\n\nThe current used data has `x95` magic. If `x00`, this data defines the previous paired connection and the next section defines the current one.\n\nBy connecting through USB (Charging grip), it keeps the active section and the current LTK used with Switch can be acquired.\n\nCan be reset with `x07` subcommand.\n\n|  Section Range  | Subsection Range | Remarks                                                         |\n|:---------------:|:----------------:| --------------------------------------------------------------- |\n| `x2000`-`x2025` | -------------    | Pairing info section 1                                          |\n|                 | `x2000`          | Magic. Used=`x95`, Unused=`x00`. If `x00`, checks next section. |\n|                 | `x2001`          | Size of pairing data. Always `x22` bytes                        |\n|                 | `x2002 - x2003`  | Checksum?                                                       |\n|                 | `x2004 - x2009`  | Host Bluetooth address (Big-Endian)                             |\n|                 | `x200A - x2019`  | 128-bit Long Term Key (Little-Endian)                           |\n|                 | `x201A - x2023`  | Always zeroed                                                   |\n|                 | `x2024`          | Host capabilities? Switch=`x68`, PC=`x08`                       |\n|                 | `x2025`          | Always zero                                                     |\n| `x2026`-`x204B` | -------------    | Pairing info section 2. All `xFF` if section 1 is used          |\n|                 | `x2026`          | Magic                                                           |\n|                 | `x2027`          | Size of pairing data                                            |\n|                 | `x2028 - x2029`  | Checksum?                                                       |\n|                 | `x202A - x202F`  | Host Bluetooth address (Big-Endian)                             |\n|                 | `x2030 - x203F`  | 128-bit Long Term Key (Little-Endian)                           |\n|                 | `x2040 - x2049`  | Always zeroed                                                   |\n|                 | `x204A`          | Switch=`x68`, PC=`x08`                                          |\n|                 | `x204B`          | Always zero                                                     |\n| --              | --               | The layout is repeated according to saved pairings              |\n\n## x3000 Pairing info (factory)\n\nIt copies and uses the pairing info from here to 0x2000.\n\n## x4000 Pairing info (factory2)\n\nIt copies the pairing info from here to 0x3000, checks if OK and erases it.\n\n## x5000 Shipment\n\nThe first byte is probably set to x1 on new Joy-Con. Switch makes sure to set it to 0.\n\n## x6000 Factory Configuration and Calibration\n\n|  Section Range  | Subsection Range | Remarks                                                                 |\n|:---------------:|:----------------:| ----------------------------------------------------------------------- |\n| `x6000`-`x600F` | -------------    | Serial number in non-extended ASCII. If first byte is >= `x80`, no S/N. If a byte is `00` `NUL`, skip. Max 15 chars, if 16 chars last one is skipped.|\n| `x6012`         | -------------    | Device type. JC (L): `x01`, JC (R): `x02`, Pro: `x03`. Only the 3 LSB are accounted for. Used internally and for `x02` subcmd. |\n| `x6013`         | -------------    | Unknown, seems to always be `xA0`                                       |\n| `x601B`         | -------------    | Color info exists if `x01`. If 0, default colors used are ARGB `#55555555`, `#FFFFFFFF`. Used for `x02` subcmd. |\n| `x6020`-`x6037` | -------------    | Factory configuration & calibration 1                                   |\n|                 | `x6020 - x6037`  | 6-Axis motion sensor Factory calibration                                |\n| `x603D`-`x6055` | -------------    | Factory configuration & calibration 2                                   |\n|                 | `x603D - x6045`  | Left analog stick calibration                                           |\n|                 | `x6046 - x604E`  | Right analog stick calibration                                          |\n|                 | `x6050 - x6052`  | Body #RGB color, 24-bit                                                 |\n|                 | `x6053 - x6055`  | Buttons #RGB color, 24-bit                                              |\n|                 | `x6056 - x6058`  | Left Grip #RGB color, 24-bit (Added in 5.0.0 for Pro)                   |\n|                 | `x6059 - x605B`  | Right Grip #RGB color, 24-bit (Added in 5.0.0 for Pro)                  |\n| `x6080`-`x6097` | -------------    | Factory Sensor and Stick device parameters                              |\n|                 | `x6080`-`x6085`  | 6-Axis Horizontal Offsets. (JC sideways)                                |\n|                 | `x6086`-`x6097`  | Stick device parameters 1                                               |\n| `x6098`-`x60A9` | -------------    | Factory Stick device parameters 2                                       |\n|                 | `x6098`-`x60A9`  | Stick device parameters 2. Normally the same with 1, even in Pro Contr. |\n| `x6E00`-`x6EFF` | -------------    | Unknown data values.. Exists only in Joy-Con                            |\n\nAbove data ends at `x6F00`.\n\n## x8000 User Calibration\n\nThis section holds user generated 6-Axis Motion Sensor and Analog Sticks calibration data.\n\n|  Section Range  | Subsection Range | Remarks                                        |\n|:---------------:|:----------------:| ---------------------------------------------- |\n| `x8010`-`x8025` | -------------    | User Analog sticks calibration                 |\n|                 | `x8010`, `x8011` | Magic `xB2 xA1` for user available calibration |\n|                 | `x8012 - x801A`  | Actual User Left Stick Calibration data        |\n|                 | `x801B`, `x801C` | Magic `xB2 xA1` for user available calibration |\n|                 | `x801D - x8025`  | Actual user Right Stick Calibration data       |\n| `x8026`-`x803F` | -------------    | User 6-Axis Motion Sensor calibration          |\n|                 | `x8026`, `x8027` | Magic `xB2 xA1` for user available calibration |\n|                 | `x8028`-`x803F`  | Actual 6-Axis Motion Sensor Calibration data   |\n\n```\n00008000: ffff ffff ffff ffff ffff ffff ffff ffff\n00008010: ffff ffff ffff ffff ffff[ffb2 a1c6 f871  ; Control Stick Calibration data\n00008020: 6884 42a3 5442|b2a1 7600 a6fe ea02 0040\n00008030: 0040 0040 0e00 fcff e0ff 3b34 3b34 3b34] ; Motion Control Calibration data\n```\n\n## x010000 Broadcom PatchRAM (OTA FW update)\nValid areas for PatchRAM are DS1 `@x10000` and DS2 `@x28000`.\n\nWhich one is loaded is decided by matching the OTA Signature Magic at `x1FF4`. If it matches, it checks the DS2 offset at `x1FFC` and loads OTA in DS2, otherwise it loads DS1 which is pointed by `x03B3` at static section.\n\nNormally the PatchRAM size for Joy-Con is max 96KB, but if the code fits RAM, it can go higher and itt can be updated through UART and Bluetooth.\n\nIt patches ROM and RAM and keeps all the customized code for Joy-Con proprietary protocol, hw configuration, internal communication, patches from Broadcom, etc. \n\nIt uses records defined, by a uint8_t record type, a uint16LE size and data[size]. There's no checksum, so, user can modify it and it will load, if the modifications were correct, otherwise it will bootloop. The currently known records are 0x40 (BD_ADDR), 0x08 (patches ROM) and 0x0A (patches RAM).\n\nThe PatchRAM (OTA FW) is not to be confused with the actual ROM firmware (848KB) of BCM20734.\n\nFor a parser or an ida loader check [shuffle2's nxpad](https://github.com/shuffle2/nxpad).\n\n\n## Analog stick factory and user calibration\n\n3 groups of 3 bytes. \n\nThe general code to decode each 3 byte group into uint16_t is:\n```\nuint16_t data[6]\ndata[0] = (stick_cal[1] << 8) & 0xF00 | stick_cal[0];\ndata[1] = (stick_cal[2] << 4) | (stick_cal[1] >> 4);\ndata[2] = (stick_cal[4] << 8) & 0xF00 | stick_cal[3];\ndata[3] = (stick_cal[5] << 4) | (stick_cal[4] >> 4);\ndata[4] = (stick_cal[7] << 8) & 0xF00 | stick_cal[6];\ndata[5] = (stick_cal[8] << 4) | (stick_cal[7] >> 4);\n```\n\nLeft Stick:\n\n| uint16_t #| Sample | Remarks                 |\n|:---------:|:------:| ----------------------- |\n| `0`       | `x4F7` | X Axis Max above center |\n| `1`       | `x424` | Y Axis Max above center |\n| `2`       | `x79F` | X Axis Center           |\n| `3`       | `x8A0` | Y Axis Center           |\n| `4`       | `x510` | X Axis Min below center |\n| `5`       | `x479` | Y Axis Min below center |\n\nRight Stick:\n\n| uint16_t #| Sample | Remarks                 |\n|:---------:|:------:| ----------------------- |\n| `0`       | `x79F` | X Axis Center           |\n| `1`       | `x8A0` | Y Axis Center           |\n| `2`       | `x510` | X Axis Min below center |\n| `3`       | `x479` | Y Axis Min below center |\n| `4`       | `x4F7` | X Axis Max above center |\n| `5`       | `x424` | Y Axis Max above center |\n\nThe minimum and maximum values are then subtracted or added to the center values to get the real Min/Max range.\n\nFor example (Right stick):\n```\nuint16_t rstick_center_x = data[0];\nuint16_t rstick_center_y = data[1];\nuint16_t rstick_x_min = rstick_center_x - data[2];\nuint16_t rstick_x_max = rstick_center_x + data[4];\nuint16_t rstick_y_min = rstick_center_y - data[3];\nuint16_t rstick_y_max = rstick_center_y + data[5];\n```\n\n## 6-Axis sensor factory and user calibration\n\n4 groups of 3 Int16LE.\n\nEach group defines the X Y Z axis.\n\n1st two groups are Acc cal and the 2nd two groups are Gyro cal.\n\nSample (Big-Endian):\n\n| int16_t #  | Sample XYZ       | Remarks                                                                |\n|:----------:|:----------------:| ---------------------------------------------------------------------- |\n| `0` - `2`  | `FFB0 FEB9 00E0` | Acc XYZ origin position when completely horizontal and stick is upside |\n| `3` - `5`  | `4000 4000 4000` | Acc XYZ sensitivity special coeff, for default sensitivity: Â±8G.       |\n| `6` - `8`  | `000E FFDF FFD0` | Gyro XYZ origin position when still                                    |\n| `9` - `11` | `343B 343B 343B` | Gyro XYZ sensitivity special coeff, for default sensitivity: Â±2000dps. |\n\nFor the sensitivities conversion check [here](imu_sensor_notes.md#convert-to-basic-useful-data-using-spi-calibration).\n\nReference code for converting from uint16_t to int16_t for doing the above calculations:\n\n```\nint16_t uint16_to_int16(uint16_t a) {\n\tint16_t b;\n\tchar* aPointer = (char*)&a, *bPointer = (char*)&b;\n\tmemcpy(bPointer, aPointer, sizeof(a));\n\treturn b;\n}\n```\n\n## 6-Axis and Stick device parameters\n\nThese follow the same encoding with sensor and stick calibration accordingly.\n\n#### 6-Axis Horizontal Offsets:\n\n3 Int16LE.\nDefine the accelerator additional offset from origin position when the Joy-Con is on a flat surface. The trigger bumps on the Joy-Con and Pro controller change the origin position and use can use these to level it.\n\nDefault values:\n\n| Axis | Joy-Con (L)  | Joy-Con (R)    | Pro Controller |\n|:----:|:------------:|:--------------:|:--------------:|\n| X    | `x15E` (350) | `x15E` (350)   | `FD50` (-688)  |\n| Y    | `x00` (0)    | `x00` (0)      | `x00` (0)      |\n| Z    | `xFF1` (4081)| `xF00F` (-4081)| `xFC6` (4038)  |\n\n#### Stick Parameters 1 & 2:\n18 bytes that produce 12 uint16_t.\nDefine maximum/minimum ranges that the analog stick hardware supports and dead-zones.\n\nEach section is for different stick.\n\n| uint16_t # | Sample    | Remarks                   |\n|:----------:|:---------:| ------------------------- |\n| `0`, `1`   | `019 4CD` | Seems that this is unused |\n| `2`        | `AE`      | Dead-zone                 |\n| `3`        | `E14`     | Range ratio               |\n| `4`, `5`   | `2EE 2EE` | X/Y: Unknown              |\n| `6`, `7`   | `2EE 2EE` | X/Y: Unknown              |\n| `8`, `9`   | `AB4 AB4` | X/Y: Unknown              |\n| `10`, `11` | `496 496` | X/Y: Unknown              |\n\n##### Dead-zone:\n\nIt is used to all directions, so it isn't divided by 2. It behaves like a radial dead-zone. Changing it as big as a half axis range, produces a circular d-pad style behavior. The default values for Joy-Con translates to ~15% and ~10% for Pro controller.\n\n##### Range ratio:\n\nMaking this very small, produces d-pad like movement on the cross but still retains circular directionality. So it probably produces a float coefficient.\n"
        }
      ]
    }
  ]
}