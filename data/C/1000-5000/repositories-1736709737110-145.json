{
  "metadata": {
    "timestamp": 1736709737110,
    "page": 145,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zserge/jsmn",
      "stars": 3735,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 2.5791015625,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  LLVM\nAccessModifierOffset: -2\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlinesLeft: false\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: All\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: false\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:   \n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Attach\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nColumnLimit:     80\nCommentPragmas:  '^ IWYU pragma:'\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]\nIncludeCategories: \n  - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n    Priority:        2\n  - Regex:           '^(<|\"(gtest|isl|json)/)'\n    Priority:        3\n  - Regex:           '.*'\n    Priority:        1\nIndentCaseLabels: false\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nKeepEmptyLinesAtTheStartOfBlocks: true\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakBeforeFirstCallParameter: 19\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 60\nPointerAlignment: Right\nReflowComments:  true\nSortIncludes:    true\nSpaceAfterCStyleCast: false\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Cpp11\nTabWidth:        8\nUseTab:          Never\n...\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.044921875,
          "content": "language: c\nsudo: false\nscript:\n  - make test\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0361328125,
          "content": "Copyright (c) 2010 Serge A. Zaitsev\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.841796875,
          "content": "# You can put your build options here\n-include config.mk\n\ntest: test_default test_strict test_links test_strict_links\ntest_default: test/tests.c jsmn.h\n\t$(CC) $(CFLAGS) $(LDFLAGS) $< -o test/$@\n\t./test/$@\ntest_strict: test/tests.c jsmn.h\n\t$(CC) -DJSMN_STRICT=1 $(CFLAGS) $(LDFLAGS) $< -o test/$@\n\t./test/$@\ntest_links: test/tests.c jsmn.h\n\t$(CC) -DJSMN_PARENT_LINKS=1 $(CFLAGS) $(LDFLAGS) $< -o test/$@\n\t./test/$@\ntest_strict_links: test/tests.c jsmn.h\n\t$(CC) -DJSMN_STRICT=1 -DJSMN_PARENT_LINKS=1 $(CFLAGS) $(LDFLAGS) $< -o test/$@\n\t./test/$@\n\nsimple_example: example/simple.c jsmn.h\n\t$(CC) $(LDFLAGS) $< -o $@\n\njsondump: example/jsondump.c jsmn.h\n\t$(CC) $(LDFLAGS) $< -o $@\n\nfmt:\n\tclang-format -i jsmn.h test/*.[ch] example/*.[ch]\n\nlint:\n\tclang-tidy jsmn.h --checks='*'\n\nclean:\n\trm -f *.o example/*.o\n\trm -f simple_example\n\trm -f jsondump\n\n.PHONY: clean test\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.771484375,
          "content": "JSMN\n====\n\n[![Build Status](https://travis-ci.org/zserge/jsmn.svg?branch=master)](https://travis-ci.org/zserge/jsmn)\n\njsmn (pronounced like 'jasmine') is a minimalistic JSON parser in C.  It can be\neasily integrated into resource-limited or embedded projects.\n\nYou can find more information about JSON format at [json.org][1]\n\nLibrary sources are available at https://github.com/zserge/jsmn\n\nThe web page with some information about jsmn can be found at\n[http://zserge.com/jsmn.html][2]\n\nPhilosophy\n----------\n\nMost JSON parsers offer you a bunch of functions to load JSON data, parse it\nand extract any value by its name. jsmn proves that checking the correctness of\nevery JSON packet or allocating temporary objects to store parsed JSON fields\noften is an overkill. \n\nJSON format itself is extremely simple, so why should we complicate it?\n\njsmn is designed to be\t**robust** (it should work fine even with erroneous\ndata), **fast** (it should parse data on the fly), **portable** (no superfluous\ndependencies or non-standard C extensions). And of course, **simplicity** is a\nkey feature - simple code style, simple algorithm, simple integration into\nother projects.\n\nFeatures\n--------\n\n* compatible with C89\n* no dependencies (even libc!)\n* highly portable (tested on x86/amd64, ARM, AVR)\n* about 200 lines of code\n* extremely small code footprint\n* API contains only 2 functions\n* no dynamic memory allocation\n* incremental single-pass parsing\n* library code is covered with unit-tests\n\nDesign\n------\n\nThe rudimentary jsmn object is a **token**. Let's consider a JSON string:\n\n\t'{ \"name\" : \"Jack\", \"age\" : 27 }'\n\nIt holds the following tokens:\n\n* Object: `{ \"name\" : \"Jack\", \"age\" : 27}` (the whole object)\n* Strings: `\"name\"`, `\"Jack\"`, `\"age\"` (keys and some values)\n* Number: `27`\n\nIn jsmn, tokens do not hold any data, but point to token boundaries in JSON\nstring instead. In the example above jsmn will create tokens like: Object\n[0..31], String [3..7], String [12..16], String [20..23], Number [27..29].\n\nEvery jsmn token has a type, which indicates the type of corresponding JSON\ntoken. jsmn supports the following token types:\n\n* Object - a container of key-value pairs, e.g.:\n\t`{ \"foo\":\"bar\", \"x\":0.3 }`\n* Array - a sequence of values, e.g.:\n\t`[ 1, 2, 3 ]`\n* String - a quoted sequence of chars, e.g.: `\"foo\"`\n* Primitive - a number, a boolean (`true`, `false`) or `null`\n\nBesides start/end positions, jsmn tokens for complex types (like arrays\nor objects) also contain a number of child items, so you can easily follow\nobject hierarchy.\n\nThis approach provides enough information for parsing any JSON data and makes\nit possible to use zero-copy techniques.\n\nUsage\n-----\n\nDownload `jsmn.h`, include it, done.\n\n```\n#include \"jsmn.h\"\n\n...\njsmn_parser p;\njsmntok_t t[128]; /* We expect no more than 128 JSON tokens */\n\njsmn_init(&p);\nr = jsmn_parse(&p, s, strlen(s), t, 128); // \"s\" is the char array holding the json content\n```\n\nSince jsmn is a single-header, header-only library, for more complex use cases\nyou might need to define additional macros. `#define JSMN_STATIC` hides all\njsmn API symbols by making them static. Also, if you want to include `jsmn.h`\nfrom multiple C files, to avoid duplication of symbols you may define  `JSMN_HEADER` macro.\n\n```\n/* In every .c file that uses jsmn include only declarations: */\n#define JSMN_HEADER\n#include \"jsmn.h\"\n\n/* Additionally, create one jsmn.c file for jsmn implementation: */\n#include \"jsmn.h\"\n```\n\nAPI\n---\n\nToken types are described by `jsmntype_t`:\n\n\ttypedef enum {\n\t\tJSMN_UNDEFINED = 0,\n\t\tJSMN_OBJECT = 1 << 0,\n\t\tJSMN_ARRAY = 1 << 1,\n\t\tJSMN_STRING = 1 << 2,\n\t\tJSMN_PRIMITIVE = 1 << 3\n\t} jsmntype_t;\n\n**Note:** Unlike JSON data types, primitive tokens are not divided into\nnumbers, booleans and null, because one can easily tell the type using the\nfirst character:\n\n* <code>'t', 'f'</code> - boolean \n* <code>'n'</code> - null\n* <code>'-', '0'..'9'</code> - number\n\nToken is an object of `jsmntok_t` type:\n\n\ttypedef struct {\n\t\tjsmntype_t type; // Token type\n\t\tint start;       // Token start position\n\t\tint end;         // Token end position\n\t\tint size;        // Number of child (nested) tokens\n\t} jsmntok_t;\n\n**Note:** string tokens point to the first character after\nthe opening quote and the previous symbol before final quote. This was made \nto simplify string extraction from JSON data.\n\nAll job is done by `jsmn_parser` object. You can initialize a new parser using:\n\n\tjsmn_parser parser;\n\tjsmntok_t tokens[10];\n\n\tjsmn_init(&parser);\n\n\t// js - pointer to JSON string\n\t// tokens - an array of tokens available\n\t// 10 - number of tokens available\n\tjsmn_parse(&parser, js, strlen(js), tokens, 10);\n\nThis will create a parser, and then it tries to parse up to 10 JSON tokens from\nthe `js` string.\n\nA non-negative return value of `jsmn_parse` is the number of tokens actually\nused by the parser.\nPassing NULL instead of the tokens array would not store parsing results, but\ninstead the function will return the number of tokens needed to parse the given\nstring. This can be useful if you don't know yet how many tokens to allocate.\n\nIf something goes wrong, you will get an error. Error will be one of these:\n\n* `JSMN_ERROR_INVAL` - bad token, JSON string is corrupted\n* `JSMN_ERROR_NOMEM` - not enough tokens, JSON string is too large\n* `JSMN_ERROR_PART` - JSON string is too short, expecting more JSON data\n\nIf you get `JSMN_ERROR_NOMEM`, you can re-allocate more tokens and call\n`jsmn_parse` once more.  If you read json data from the stream, you can\nperiodically call `jsmn_parse` and check if return value is `JSMN_ERROR_PART`.\nYou will get this error until you reach the end of JSON data.\n\nOther info\n----------\n\nThis software is distributed under [MIT license](http://www.opensource.org/licenses/mit-license.php),\n so feel free to integrate it in your commercial products.\n\n[1]: http://www.json.org/\n[2]: http://zserge.com/jsmn.html\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "jsmn.h",
          "type": "blob",
          "size": 11.8603515625,
          "content": "/*\n * MIT License\n *\n * Copyright (c) 2010 Serge Zaitsev\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef JSMN_H\n#define JSMN_H\n\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef JSMN_STATIC\n#define JSMN_API static\n#else\n#define JSMN_API extern\n#endif\n\n/**\n * JSON type identifier. Basic types are:\n * \to Object\n * \to Array\n * \to String\n * \to Other primitive: number, boolean (true/false) or null\n */\ntypedef enum {\n  JSMN_UNDEFINED = 0,\n  JSMN_OBJECT = 1 << 0,\n  JSMN_ARRAY = 1 << 1,\n  JSMN_STRING = 1 << 2,\n  JSMN_PRIMITIVE = 1 << 3\n} jsmntype_t;\n\nenum jsmnerr {\n  /* Not enough tokens were provided */\n  JSMN_ERROR_NOMEM = -1,\n  /* Invalid character inside JSON string */\n  JSMN_ERROR_INVAL = -2,\n  /* The string is not a full JSON packet, more bytes expected */\n  JSMN_ERROR_PART = -3\n};\n\n/**\n * JSON token description.\n * type\t\ttype (object, array, string etc.)\n * start\tstart position in JSON data string\n * end\t\tend position in JSON data string\n */\ntypedef struct jsmntok {\n  jsmntype_t type;\n  int start;\n  int end;\n  int size;\n#ifdef JSMN_PARENT_LINKS\n  int parent;\n#endif\n} jsmntok_t;\n\n/**\n * JSON parser. Contains an array of token blocks available. Also stores\n * the string being parsed now and current position in that string.\n */\ntypedef struct jsmn_parser {\n  unsigned int pos;     /* offset in the JSON string */\n  unsigned int toknext; /* next token to allocate */\n  int toksuper;         /* superior token node, e.g. parent object or array */\n} jsmn_parser;\n\n/**\n * Create JSON parser over an array of tokens\n */\nJSMN_API void jsmn_init(jsmn_parser *parser);\n\n/**\n * Run JSON parser. It parses a JSON data string into and array of tokens, each\n * describing\n * a single JSON object.\n */\nJSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,\n                        jsmntok_t *tokens, const unsigned int num_tokens);\n\n#ifndef JSMN_HEADER\n/**\n * Allocates a fresh unused token from the token pool.\n */\nstatic jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,\n                                   const size_t num_tokens) {\n  jsmntok_t *tok;\n  if (parser->toknext >= num_tokens) {\n    return NULL;\n  }\n  tok = &tokens[parser->toknext++];\n  tok->start = tok->end = -1;\n  tok->size = 0;\n#ifdef JSMN_PARENT_LINKS\n  tok->parent = -1;\n#endif\n  return tok;\n}\n\n/**\n * Fills token type and boundaries.\n */\nstatic void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,\n                            const int start, const int end) {\n  token->type = type;\n  token->start = start;\n  token->end = end;\n  token->size = 0;\n}\n\n/**\n * Fills next available token with JSON primitive.\n */\nstatic int jsmn_parse_primitive(jsmn_parser *parser, const char *js,\n                                const size_t len, jsmntok_t *tokens,\n                                const size_t num_tokens) {\n  jsmntok_t *token;\n  int start;\n\n  start = parser->pos;\n\n  for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) {\n    switch (js[parser->pos]) {\n#ifndef JSMN_STRICT\n    /* In strict mode primitive must be followed by \",\" or \"}\" or \"]\" */\n    case ':':\n#endif\n    case '\\t':\n    case '\\r':\n    case '\\n':\n    case ' ':\n    case ',':\n    case ']':\n    case '}':\n      goto found;\n    default:\n                   /* to quiet a warning from gcc*/\n      break;\n    }\n    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {\n      parser->pos = start;\n      return JSMN_ERROR_INVAL;\n    }\n  }\n#ifdef JSMN_STRICT\n  /* In strict mode primitive must be followed by a comma/object/array */\n  parser->pos = start;\n  return JSMN_ERROR_PART;\n#endif\n\nfound:\n  if (tokens == NULL) {\n    parser->pos--;\n    return 0;\n  }\n  token = jsmn_alloc_token(parser, tokens, num_tokens);\n  if (token == NULL) {\n    parser->pos = start;\n    return JSMN_ERROR_NOMEM;\n  }\n  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);\n#ifdef JSMN_PARENT_LINKS\n  token->parent = parser->toksuper;\n#endif\n  parser->pos--;\n  return 0;\n}\n\n/**\n * Fills next token with JSON string.\n */\nstatic int jsmn_parse_string(jsmn_parser *parser, const char *js,\n                             const size_t len, jsmntok_t *tokens,\n                             const size_t num_tokens) {\n  jsmntok_t *token;\n\n  int start = parser->pos;\n  \n  /* Skip starting quote */\n  parser->pos++;\n  \n  for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) {\n    char c = js[parser->pos];\n\n    /* Quote: end of string */\n    if (c == '\\\"') {\n      if (tokens == NULL) {\n        return 0;\n      }\n      token = jsmn_alloc_token(parser, tokens, num_tokens);\n      if (token == NULL) {\n        parser->pos = start;\n        return JSMN_ERROR_NOMEM;\n      }\n      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);\n#ifdef JSMN_PARENT_LINKS\n      token->parent = parser->toksuper;\n#endif\n      return 0;\n    }\n\n    /* Backslash: Quoted symbol expected */\n    if (c == '\\\\' && parser->pos + 1 < len) {\n      int i;\n      parser->pos++;\n      switch (js[parser->pos]) {\n      /* Allowed escaped symbols */\n      case '\\\"':\n      case '/':\n      case '\\\\':\n      case 'b':\n      case 'f':\n      case 'r':\n      case 'n':\n      case 't':\n        break;\n      /* Allows escaped symbol \\uXXXX */\n      case 'u':\n        parser->pos++;\n        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\\0';\n             i++) {\n          /* If it isn't a hex character we have an error */\n          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */\n                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */\n                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */\n            parser->pos = start;\n            return JSMN_ERROR_INVAL;\n          }\n          parser->pos++;\n        }\n        parser->pos--;\n        break;\n      /* Unexpected symbol */\n      default:\n        parser->pos = start;\n        return JSMN_ERROR_INVAL;\n      }\n    }\n  }\n  parser->pos = start;\n  return JSMN_ERROR_PART;\n}\n\n/**\n * Parse JSON string and fill tokens.\n */\nJSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,\n                        jsmntok_t *tokens, const unsigned int num_tokens) {\n  int r;\n  int i;\n  jsmntok_t *token;\n  int count = parser->toknext;\n\n  for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) {\n    char c;\n    jsmntype_t type;\n\n    c = js[parser->pos];\n    switch (c) {\n    case '{':\n    case '[':\n      count++;\n      if (tokens == NULL) {\n        break;\n      }\n      token = jsmn_alloc_token(parser, tokens, num_tokens);\n      if (token == NULL) {\n        return JSMN_ERROR_NOMEM;\n      }\n      if (parser->toksuper != -1) {\n        jsmntok_t *t = &tokens[parser->toksuper];\n#ifdef JSMN_STRICT\n        /* In strict mode an object or array can't become a key */\n        if (t->type == JSMN_OBJECT) {\n          return JSMN_ERROR_INVAL;\n        }\n#endif\n        t->size++;\n#ifdef JSMN_PARENT_LINKS\n        token->parent = parser->toksuper;\n#endif\n      }\n      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);\n      token->start = parser->pos;\n      parser->toksuper = parser->toknext - 1;\n      break;\n    case '}':\n    case ']':\n      if (tokens == NULL) {\n        break;\n      }\n      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);\n#ifdef JSMN_PARENT_LINKS\n      if (parser->toknext < 1) {\n        return JSMN_ERROR_INVAL;\n      }\n      token = &tokens[parser->toknext - 1];\n      for (;;) {\n        if (token->start != -1 && token->end == -1) {\n          if (token->type != type) {\n            return JSMN_ERROR_INVAL;\n          }\n          token->end = parser->pos + 1;\n          parser->toksuper = token->parent;\n          break;\n        }\n        if (token->parent == -1) {\n          if (token->type != type || parser->toksuper == -1) {\n            return JSMN_ERROR_INVAL;\n          }\n          break;\n        }\n        token = &tokens[token->parent];\n      }\n#else\n      for (i = parser->toknext - 1; i >= 0; i--) {\n        token = &tokens[i];\n        if (token->start != -1 && token->end == -1) {\n          if (token->type != type) {\n            return JSMN_ERROR_INVAL;\n          }\n          parser->toksuper = -1;\n          token->end = parser->pos + 1;\n          break;\n        }\n      }\n      /* Error if unmatched closing bracket */\n      if (i == -1) {\n        return JSMN_ERROR_INVAL;\n      }\n      for (; i >= 0; i--) {\n        token = &tokens[i];\n        if (token->start != -1 && token->end == -1) {\n          parser->toksuper = i;\n          break;\n        }\n      }\n#endif\n      break;\n    case '\\\"':\n      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);\n      if (r < 0) {\n        return r;\n      }\n      count++;\n      if (parser->toksuper != -1 && tokens != NULL) {\n        tokens[parser->toksuper].size++;\n      }\n      break;\n    case '\\t':\n    case '\\r':\n    case '\\n':\n    case ' ':\n      break;\n    case ':':\n      parser->toksuper = parser->toknext - 1;\n      break;\n    case ',':\n      if (tokens != NULL && parser->toksuper != -1 &&\n          tokens[parser->toksuper].type != JSMN_ARRAY &&\n          tokens[parser->toksuper].type != JSMN_OBJECT) {\n#ifdef JSMN_PARENT_LINKS\n        parser->toksuper = tokens[parser->toksuper].parent;\n#else\n        for (i = parser->toknext - 1; i >= 0; i--) {\n          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {\n            if (tokens[i].start != -1 && tokens[i].end == -1) {\n              parser->toksuper = i;\n              break;\n            }\n          }\n        }\n#endif\n      }\n      break;\n#ifdef JSMN_STRICT\n    /* In strict mode primitives are: numbers and booleans */\n    case '-':\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case 't':\n    case 'f':\n    case 'n':\n      /* And they must not be keys of the object */\n      if (tokens != NULL && parser->toksuper != -1) {\n        const jsmntok_t *t = &tokens[parser->toksuper];\n        if (t->type == JSMN_OBJECT ||\n            (t->type == JSMN_STRING && t->size != 0)) {\n          return JSMN_ERROR_INVAL;\n        }\n      }\n#else\n    /* In non-strict mode every unquoted value is a primitive */\n    default:\n#endif\n      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);\n      if (r < 0) {\n        return r;\n      }\n      count++;\n      if (parser->toksuper != -1 && tokens != NULL) {\n        tokens[parser->toksuper].size++;\n      }\n      break;\n\n#ifdef JSMN_STRICT\n    /* Unexpected char in strict mode */\n    default:\n      return JSMN_ERROR_INVAL;\n#endif\n    }\n  }\n\n  if (tokens != NULL) {\n    for (i = parser->toknext - 1; i >= 0; i--) {\n      /* Unmatched opened object or array */\n      if (tokens[i].start != -1 && tokens[i].end == -1) {\n        return JSMN_ERROR_PART;\n      }\n    }\n  }\n\n  return count;\n}\n\n/**\n * Creates a new parser based over a given buffer with an array of tokens\n * available.\n */\nJSMN_API void jsmn_init(jsmn_parser *parser) {\n  parser->pos = 0;\n  parser->toknext = 0;\n  parser->toksuper = -1;\n}\n\n#endif /* JSMN_HEADER */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* JSMN_H */\n"
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 0.359375,
          "content": "{\n  \"name\": \"jsmn\",\n  \"keywords\": \"json\",\n  \"description\": \"Minimalistic JSON parser/tokenizer in C. It can be easily integrated into resource-limited or embedded projects\",\n  \"repository\":\n  {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/zserge/jsmn.git\"\n  },\n  \"frameworks\": \"*\",\n  \"platforms\": \"*\",\n  \"examples\": [\n    \"example/*.c\"\n  ],\n  \"exclude\": \"test\"\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}