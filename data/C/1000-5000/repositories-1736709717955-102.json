{
  "metadata": {
    "timestamp": 1736709717955,
    "page": 102,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "containers/bubblewrap",
      "stars": 4047,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dir-locals.el",
          "type": "blob",
          "size": 0.0615234375,
          "content": "((c-mode . ((indent-tabs-mode . nil) (c-file-style . \"gnu\"))))\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1005859375,
          "content": "[*.[ch]]\nindent_style = space\nindent_size = 2\ntrim_trailing_whitespace = true\nindent_brace_style = gnu\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE-OF-CONDUCT.md",
          "type": "blob",
          "size": 0.1904296875,
          "content": "## The bubblewrap Project Community Code of Conduct\n\nThe bubblewrap project follows the [Containers Community Code of Conduct](https://github.com/containers/common/blob/HEAD/CODE-OF-CONDUCT.md).\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 24.7880859375,
          "content": "                  GNU LIBRARY GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1991 Free Software Foundation, Inc.\n 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n[This is the first released version of the library GPL.  It is\n numbered 2 because it goes with version 2 of the ordinary GPL.]\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicenses are intended to guarantee your freedom to share and change\nfree software--to make sure the software is free for all its users.\n\n  This license, the Library General Public License, applies to some\nspecially designated Free Software Foundation software, and to any\nother libraries whose authors decide to use it.  You can use it for\nyour libraries, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if\nyou distribute copies of the library, or if you modify it.\n\n  For example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou.  You must make sure that they, too, receive or can get the source\ncode.  If you link a program with the library, you must provide\ncomplete object files to the recipients so that they can relink them\nwith the library, after making changes to the library and recompiling\nit.  And you must show them these terms so they know their rights.\n\n  Our method of protecting your rights has two steps: (1) copyright\nthe library, and (2) offer you this license which gives you legal\npermission to copy, distribute and/or modify the library.\n\n  Also, for each distributor's protection, we want to make certain\nthat everyone understands that there is no warranty for this free\nlibrary.  If the library is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original\nversion, so that any problems introduced by others will not reflect on\nthe original authors' reputations.\n\f\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that companies distributing free\nsoftware will individually obtain patent licenses, thus in effect\ntransforming the program into proprietary software.  To prevent this,\nwe have made it clear that any patent must be licensed for everyone's\nfree use or not licensed at all.\n\n  Most GNU software, including some libraries, is covered by the ordinary\nGNU General Public License, which was designed for utility programs.  This\nlicense, the GNU Library General Public License, applies to certain\ndesignated libraries.  This license is quite different from the ordinary\none; be sure to read it in full, and don't assume that anything in it is\nthe same as in the ordinary license.\n\n  The reason we have a separate public license for some libraries is that\nthey blur the distinction we usually make between modifying or adding to a\nprogram and simply using it.  Linking a program with a library, without\nchanging the library, is in some sense simply using the library, and is\nanalogous to running a utility program or application program.  However, in\na textual and legal sense, the linked executable is a combined work, a\nderivative of the original library, and the ordinary General Public License\ntreats it as such.\n\n  Because of this blurred distinction, using the ordinary General\nPublic License for libraries did not effectively promote software\nsharing, because most developers did not use the libraries.  We\nconcluded that weaker conditions might promote sharing better.\n\n  However, unrestricted linking of non-free programs would deprive the\nusers of those programs of all benefit from the free status of the\nlibraries themselves.  This Library General Public License is intended to\npermit developers of non-free programs to use free libraries, while\npreserving your freedom as a user of such programs to change the free\nlibraries that are incorporated in them.  (We have not seen how to achieve\nthis as regards changes in header files, but we have achieved it as regards\nchanges in the actual functions of the Library.)  The hope is that this\nwill lead to faster development of free libraries.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.  Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\".  The\nformer contains code derived from the library, while the latter only\nworks together with the library.\n\n  Note that it is possible for a library to be covered by the ordinary\nGeneral Public License rather than by this special one.\n\f\n                  GNU LIBRARY GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License Agreement applies to any software library which\ncontains a notice placed by the copyright holder or other authorized\nparty saying it may be distributed under the terms of this Library\nGeneral Public License (also called \"this License\").  Each licensee is\naddressed as \"you\".\n\n  A \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\n  The \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms.  A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language.  (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n  \"Source code\" for a work means the preferred form of the work for\nmaking modifications to it.  For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control compilation\nand installation of the library.\n\n  Activities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it).  Whether that is true depends on what the Library does\nand what the program that uses the Library does.\n  \n  1. You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\n  You may charge a fee for the physical act of transferring a copy,\nand you may at your option offer warranty protection in exchange for a\nfee.\n\f\n  2. You may modify your copy or copies of the Library or any portion\nof it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) The modified work must itself be a software library.\n\n    b) You must cause the files modified to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    c) You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n\n    d) If a facility in the modified Library refers to a function or a\n    table of data to be supplied by an application program that uses\n    the facility, other than as an argument passed when the facility\n    is invoked, then you must make a good faith effort to ensure that,\n    in the event an application does not supply such function or\n    table, the facility still operates, and performs whatever part of\n    its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of the\n    application.  Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may opt to apply the terms of the ordinary GNU General Public\nLicense instead of this License to a given copy of the Library.  To do\nthis, you must alter all the notices that refer to this License, so\nthat they refer to the ordinary GNU General Public License, version 2,\ninstead of to this License.  (If a newer version than version 2 of the\nordinary GNU General Public License has appeared, then you can specify\nthat version instead if you wish.)  Do not make any other change in\nthese notices.\n\f\n  Once this change is made in a given copy, it is irreversible for\nthat copy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\n  This option is useful when you wish to copy part of the code of\nthe Library into a program that is not a library.\n\n  4. You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\n  If distribution of object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the\nsource code from the same place satisfies the requirement to\ndistribute the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  5. A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\".  Such a\nwork, in isolation, is not a derivative work of the Library, and\ntherefore falls outside the scope of this License.\n\n  However, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\".  The executable is therefore covered by this License.\nSection 6 states terms for distribution of such executables.\n\n  When a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library.  The\nthreshold for this to be true is not precisely defined by law.\n\n  If such an object file uses only numerical parameters, data\nstructure layouts and accessors, and small macros and small inline\nfunctions (ten lines or less in length), then the use of the object\nfile is unrestricted, regardless of whether it is legally a derivative\nwork.  (Executables containing this object code plus portions of the\nLibrary will still fall under Section 6.)\n\n  Otherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\f\n  6. As an exception to the Sections above, you may also compile or\nlink a \"work that uses the Library\" with the Library to produce a\nwork containing portions of the Library, and distribute that work\nunder terms of your choice, provided that the terms permit\nmodification of the work for the customer's own use and reverse\nengineering for debugging such modifications.\n\n  You must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License.  You must supply a copy of this License.  If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License.  Also, you must do one\nof these things:\n\n    a) Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library.  (It is understood\n    that the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n\n    b) Accompany the work with a written offer, valid for at\n    least three years, to give the same user the materials\n    specified in Subsection 6a, above, for a charge no more\n    than the cost of performing this distribution.\n\n    c) If distribution of the work is made by offering access to copy\n    from a designated place, offer equivalent access to copy the above\n    specified materials from the same place.\n\n    d) Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\n  For an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it.  However, as a special exception,\nthe source code distributed need not include anything that is normally\ndistributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\n  It may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system.  Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\f\n  7. You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n    a) Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other library\n    facilities.  This must be distributed under the terms of the\n    Sections above.\n\n    b) Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n  8. You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License.  Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License.  However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n  9. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n  10. Each time you redistribute the Library (or any work based on the\nLibrary), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\f\n  11. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Library at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Library by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Library.\n\nIf any portion of this section is held invalid or unenforceable under any\nparticular circumstance, the balance of the section is intended to apply,\nand the section as a whole is intended to apply in other circumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  12. If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License may add\nan explicit geographical distribution limitation excluding those countries,\nso that distribution is permitted only in or among countries not thus\nexcluded.  In such case, this License incorporates the limitation as if\nwritten in the body of this License.\n\n  13. The Free Software Foundation may publish revised and/or new\nversions of the Library General Public License from time to time.\nSuch new versions will be similar in spirit to the present version,\nbut may differ in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation.  If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\f\n  14. If you wish to incorporate parts of the Library into other free\nprograms whose distribution conditions are incompatible with these,\nwrite to the author to ask for permission.  For software which is\ncopyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this.  Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n                            NO WARRANTY\n\n  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\f\n           How to Apply These Terms to Your New Libraries\n\n  If you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change.  You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms of the\nordinary General Public License).\n\n  To apply these terms, attach the following notices to the library.  It is\nsafest to attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the library's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Library General Public\n    License as published by the Free Software Foundation; either\n    version 2 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Library General Public License for more details.\n\n    You should have received a copy of the GNU Library General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nAlso add information on how to contact you by electronic and paper mail.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the library, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n\n  <signature of Ty Coon>, 1 April 1990\n  Ty Coon, President of Vice\n\nThat's all there is to it!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.0068359375,
          "content": "COPYING"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 1.5673828125,
          "content": "bubblewrap 0.11.0\n=================\n\nReleased: 2024-10-30\n\nDependencies:\n\n  * Remove the Autotools build system. Meson ≥ 0.49.0 is now required\n    at build-time. (#625, Hugo Osvaldo Barrera)\n\n  * For users of bash-completion, bash-completion ≥ 2.10 is recommended.\n    With older bash-completion, bubblewrap might install completions\n    outside its `${prefix}` unless overridden with `-Dbash_completion_dir=…`.\n\nEnhancements:\n\n  * New `--overlay`, `--tmp-overlay`, `--ro-overlay` and `--overlay-src`\n    options allow creation of overlay mounts.\n    This feature is not available when bubblewrap is installed setuid.\n    (#412, #663; Ryan Hendrickson, William Manley, Simon McVittie)\n\n  * New `--level-prefix` option produces output that can be parsed by\n    tools like `logger --prio-prefix` and `systemd-cat --level-prefix=1`\n    (#646, Simon McVittie)\n\nBug fixes:\n\n  * Handle `EINTR` when doing I/O on files or sockets (#657, Simon McVittie)\n\n  * Don't make assumptions about alignment of socket control message data\n    (#637, Simon McVittie)\n\n  * Silence some Meson deprecation warnings (#647, @Sertonix)\n\n  * Update URLs in documentation to https (#566, @TotalCaesar659)\n\n  * Improve tests' compatibility with busybox (#627, @Sertonix)\n\n  * Improve compatibility with Meson < 1.3.0 (#664, Simon McVittie)\n\nInternal changes:\n\n  * Consistently use `<stdbool.h>` for booleans (#660, Simon McVittie)\n\n  * Avoid `-Wshadow` compiler warnings (#661, Simon McVittie)\n\n  * Update Github Actions configuration (#658, Simon McVittie)\n\n----\n\nSee also <https://github.com/containers/bubblewrap/releases>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.90234375,
          "content": "Bubblewrap\n==========\n\nMany container runtime tools like `systemd-nspawn`, `docker`,\netc. focus on providing infrastructure for system administrators and\norchestration tools (e.g. Kubernetes) to run containers.\n\nThese tools are not suitable to give to unprivileged users, because it\nis trivial to turn such access into a fully privileged root shell\non the host.\n\nUser namespaces\n---------------\n\nThere is an effort in the Linux kernel called\n[user namespaces](https://www.google.com/search?q=user+namespaces+site%3Ahttps%3A%2F%2Flwn.net)\nwhich attempts to allow unprivileged users to use container features.\nWhile significant progress has been made, there are\n[still concerns](https://lwn.net/Articles/673597/) about it, and\nit is not available to unprivileged users in several production distributions\nsuch as CentOS/Red Hat Enterprise Linux 7, Debian Jessie, etc.\n\nSee for example\n[CVE-2016-3135](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3135)\nwhich is a local root vulnerability introduced by userns.\n[This March 2016 post](https://lkml.org/lkml/2016/3/9/555) has some\nmore discussion.\n\nBubblewrap could be viewed as setuid implementation of a *subset* of\nuser namespaces.  Emphasis on subset - specifically relevant to the\nabove CVE, bubblewrap does not allow control over iptables.\n\nThe original bubblewrap code existed before user namespaces - it inherits code from\n[xdg-app helper](https://cgit.freedesktop.org/xdg-app/xdg-app/tree/common/xdg-app-helper.c?id=4c3bf179e2e4a2a298cd1db1d045adaf3f564532)\nwhich in turn distantly derives from\n[linux-user-chroot](https://git.gnome.org/browse/linux-user-chroot).\n\nSystem security\n---------------\n\nThe maintainers of this tool believe that it does not, even when used\nin combination with typical software installed on that distribution,\nallow privilege escalation.  It may increase the ability of a logged\nin user to perform denial of service attacks, however.\n\nIn particular, bubblewrap uses `PR_SET_NO_NEW_PRIVS` to turn off\nsetuid binaries, which is the [traditional way](https://en.wikipedia.org/wiki/Chroot#Limitations) to get out of things\nlike chroots.\n\nSandbox security\n----------------\n\nbubblewrap is a tool for constructing sandbox environments.\nbubblewrap is not a complete, ready-made sandbox with a specific security\npolicy.\n\nSome of bubblewrap's use-cases want a security boundary between the sandbox\nand the real system; other use-cases want the ability to change the layout of\nthe filesystem for processes inside the sandbox, but do not aim to be a\nsecurity boundary.\nAs a result, the level of protection between the sandboxed processes and\nthe host system is entirely determined by the arguments passed to\nbubblewrap.\n\nWhatever program constructs the command-line arguments for bubblewrap\n(often a larger framework like Flatpak, libgnome-desktop, sandwine\nor an ad-hoc script) is responsible for defining its own security model,\nand choosing appropriate bubblewrap command-line arguments to implement\nthat security model.\n\nSome aspects of sandbox security that require particular care are described\nin the [Limitations](#limitations) section below.\n\nUsers\n-----\n\nThis program can be shared by all container tools which perform\nnon-root operation, such as:\n\n - [Flatpak](https://www.flatpak.org)\n - [rpm-ostree unprivileged](https://github.com/projectatomic/rpm-ostree/pull/209)\n - [bwrap-oci](https://github.com/projectatomic/bwrap-oci)\n\nWe would also like to see this be available in Kubernetes/OpenShift\nclusters.  Having the ability for unprivileged users to use container\nfeatures would make it significantly easier to do interactive\ndebugging scenarios and the like.\n\nInstallation\n------------\n\nbubblewrap is available in the package repositories of the most Linux distributions\nand can be installed from there.\n\nIf you need to build bubblewrap from source, you can do this with meson:\n\n```sh\nmeson _builddir\nmeson compile -C _builddir\nmeson test -C _builddir\nmeson install -C _builddir\n```\n\nUsage\n-----\n\nbubblewrap works by creating a new, completely empty, mount\nnamespace where the root is on a tmpfs that is invisible from the\nhost, and will be automatically cleaned up when the last process\nexits. You can then use commandline options to construct the root\nfilesystem and process environment and command to run in the\nnamespace.\n\nThere's a larger [demo script](./demos/bubblewrap-shell.sh) in the\nsource code, but here's a trimmed down version which runs\na new shell reusing the host's `/usr`.\n\n```\nbwrap \\\n    --ro-bind /usr /usr \\\n    --symlink usr/lib64 /lib64 \\\n    --proc /proc \\\n    --dev /dev \\\n    --unshare-pid \\\n    --new-session \\\n    bash\n```\n\nThis is an incomplete example, but useful for purposes of\nillustration.  More often, rather than creating a container using the\nhost's filesystem tree, you want to target a chroot.  There, rather\nthan creating the symlink `lib64 -> usr/lib64` in the tmpfs, you might\nhave already created it in the target rootfs.\n\nSandboxing\n----------\n\nThe goal of bubblewrap is to run an application in a sandbox, where it\nhas restricted access to parts of the operating system or user data\nsuch as the home directory.\n\nbubblewrap always creates a new mount namespace, and the user can specify\nexactly what parts of the filesystem should be visible in the sandbox.\nAny such directories you specify mounted `nodev` by default, and can be made readonly.\n\nAdditionally you can use these kernel features:\n\nUser namespaces ([CLONE_NEWUSER](https://linux.die.net/man/2/clone)): This hides all but the current uid and gid from the\nsandbox. You can also change what the value of uid/gid should be in the sandbox.\n\nIPC namespaces ([CLONE_NEWIPC](https://linux.die.net/man/2/clone)): The sandbox will get its own copy of all the\ndifferent forms of IPCs, like SysV shared memory and semaphores.\n\nPID namespaces ([CLONE_NEWPID](https://linux.die.net/man/2/clone)): The sandbox will not see any processes outside the sandbox. Additionally, bubblewrap will run a trivial pid1 inside your container to handle the requirements of reaping children in the sandbox. This avoids what is known now as the [Docker pid 1 problem](https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/).\n\n\nNetwork namespaces ([CLONE_NEWNET](https://linux.die.net/man/2/clone)): The sandbox will not see the network. Instead it will have its own network namespace with only a loopback device.\n\nUTS namespace ([CLONE_NEWUTS](https://linux.die.net/man/2/clone)): The sandbox will have its own hostname.\n\nSeccomp filters: You can pass in seccomp filters that limit which syscalls can be done in the sandbox. For more information, see [Seccomp](https://en.wikipedia.org/wiki/Seccomp).\n\nLimitations\n-----------\n\nAs noted in the [Sandbox security](#sandbox-security) section above,\nthe level of protection between the sandboxed processes and the host system\nis entirely determined by the arguments passed to bubblewrap.\nSome aspects that require special care are noted here.\n\n- If you are not filtering out `TIOCSTI` commands using seccomp filters,\nargument `--new-session` is needed to protect against out-of-sandbox\ncommand execution\n(see [CVE-2017-5226](https://github.com/containers/bubblewrap/issues/142)).\n\n- Everything mounted into the sandbox can potentially be used to escalate\nprivileges.\nFor example, if you bind a D-Bus socket into the sandbox, it can be used to\nexecute commands via systemd. You can use\n[xdg-dbus-proxy](https://github.com/flatpak/xdg-dbus-proxy) to filter\nD-Bus communication.\n\n- Some applications deploy their own sandboxing mechanisms, and these can be\nrestricted by the constraints imposed by bubblewrap's sandboxing.\nFor example, some web browsers which configure their child proccesses via\nseccomp to not have access to the filesystem. If you limit the syscalls and\ndon't allow the seccomp syscall, a browser cannot apply these restrictions.\nSimilarly, if these rules were compiled into a file that is not available in\nthe sandbox, the browser cannot load these rules from this file and cannot\napply these restrictions.\n\nRelated project comparison: Firejail\n------------------------------------\n\n[Firejail](https://github.com/netblue30/firejail/tree/HEAD/src/firejail)\nis similar to Flatpak before bubblewrap was split out in that it combines\na setuid tool with a lot of desktop-specific sandboxing features.  For\nexample, Firejail knows about Pulseaudio, whereas bubblewrap does not.\n\nThe bubblewrap authors believe it's much easier to audit a small\nsetuid program, and keep features such as Pulseaudio filtering as an\nunprivileged process, as now occurs in Flatpak.\n\nAlso, @cgwalters thinks trying to\n[whitelist file paths](https://github.com/netblue30/firejail/blob/37a5a3545ef6d8d03dad8bbd888f53e13274c9e5/src/firejail/fs_whitelist.c#L176)\nis a bad idea given the myriad ways users have to manipulate paths,\nand the myriad ways in which system administrators may configure a\nsystem.  The bubblewrap approach is to only retain a few specific\nLinux capabilities such as `CAP_SYS_ADMIN`, but to always access the\nfilesystem as the invoking uid.  This entirely closes\n[TOCTTOU attacks](https://cwe.mitre.org/data/definitions/367.html) and\nsuch.\n\nRelated project comparison: Sandstorm.io\n----------------------------------------\n\n[Sandstorm.io](https://sandstorm.io/) requires unprivileged user\nnamespaces to set up its sandbox, though it could easily be adapted\nto operate in a setuid mode as well. @cgwalters believes their code is\nfairly good, but it could still make sense to unify on bubblewrap.\nHowever, @kentonv (of Sandstorm) feels that while this makes sense\nin principle, the switching cost outweighs the practical benefits for\nnow. This decision could be re-evaluated in the future, but it is not\nbeing actively pursued today.\n\nRelated project comparison: runc/binctr\n----------------------------------------\n\n[runC](https://github.com/opencontainers/runc) is currently working on\nsupporting [rootless containers](https://github.com/opencontainers/runc/pull/774),\nwithout needing `setuid` or any other privileges during installation of\nrunC (using unprivileged user namespaces rather than `setuid`),\ncreation, and management of containers. However, the standard mode of\nusing runC is similar to [systemd nspawn](https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html)\nin that it is tooling intended to be invoked by root.\n\nThe bubblewrap authors believe that runc and systemd-nspawn are not\ndesigned to be made setuid, and are distant from supporting such a mode.\nHowever with rootless containers, runC will be able to fulfill certain usecases\nthat bubblewrap supports (with the added benefit of being a standardised and\ncomplete OCI runtime).\n\n[binctr](https://github.com/jfrazelle/binctr) is just a wrapper for\nrunC, so inherits all of its design tradeoffs.\n\nWhat's with the name?!\n----------------------\n\nThe name bubblewrap was chosen to convey that this\ntool runs as the parent of the application (so wraps it in some sense) and creates\na protective layer (the sandbox) around it.\n\n![](bubblewrap.jpg)\n\n(Bubblewrap cat by [dancing_stupidity](https://www.flickr.com/photos/27549668@N03/))\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 1.96875,
          "content": "## Security and Disclosure Information Policy for the bubblewrap Project\n\nThe bubblewrap Project follows the [Security and Disclosure Information Policy](https://github.com/containers/common/blob/HEAD/SECURITY.md) for the Containers Projects.\n\n### System security\n\nIf bubblewrap is setuid root, then the goal is that it does not allow\na malicious local user to do anything that would not have been possible\non a kernel that allows unprivileged users to create new user namespaces.\nFor example, [CVE-2020-5291](https://github.com/containers/bubblewrap/security/advisories/GHSA-j2qp-rvxj-43vj)\nwas treated as a security vulnerability in bubblewrap.\n\nIf bubblewrap is not setuid root, then it is not a security boundary\nbetween the user and the OS, because anything bubblewrap could do, a\nmalicious user could equally well do by writing their own tool equivalent\nto bubblewrap.\n\n### Sandbox security\n\nbubblewrap is a toolkit for constructing sandbox environments.\nbubblewrap is not a complete, ready-made sandbox with a specific security\npolicy.\n\nSome of bubblewrap's use-cases want a security boundary between the sandbox\nand the real system; other use-cases want the ability to change the layout of\nthe filesystem for processes inside the sandbox, but do not aim to be a\nsecurity boundary.\nAs a result, the level of protection between the sandboxed processes and\nthe host system is entirely determined by the arguments passed to\nbubblewrap.\n\nWhatever program constructs the command-line arguments for bubblewrap\n(often a larger framework like Flatpak, libgnome-desktop, sandwine\nor an ad-hoc script) is responsible for defining its own security model,\nand choosing appropriate bubblewrap command-line arguments to implement\nthat security model.\n\nFor example,\n[CVE-2017-5226](https://github.com/flatpak/flatpak/security/advisories/GHSA-7gfv-rvfx-h87x)\n(in which a Flatpak app could send input to a parent terminal using the\n`TIOCSTI` ioctl) is considered to be a Flatpak vulnerability, not a\nbubblewrap vulnerability.\n"
        },
        {
          "name": "bind-mount.c",
          "type": "blob",
          "size": 15.4375,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"config.h\"\n\n#include <sys/mount.h>\n\n#include \"utils.h\"\n#include \"bind-mount.h\"\n\nstatic char *\nskip_token (char *line, bool eat_whitespace)\n{\n  while (*line != ' ' && *line != '\\n')\n    line++;\n\n  if (eat_whitespace && *line == ' ')\n    line++;\n\n  return line;\n}\n\nstatic char *\nunescape_inline (char *escaped)\n{\n  char *unescaped, *res;\n  const char *end;\n\n  res = escaped;\n  end = escaped + strlen (escaped);\n\n  unescaped = escaped;\n  while (escaped < end)\n    {\n      if (*escaped == '\\\\')\n        {\n          *unescaped++ =\n            ((escaped[1] - '0') << 6) |\n            ((escaped[2] - '0') << 3) |\n            ((escaped[3] - '0') << 0);\n          escaped += 4;\n        }\n      else\n        {\n          *unescaped++ = *escaped++;\n        }\n    }\n  *unescaped = 0;\n  return res;\n}\n\nstatic bool\nmatch_token (const char *token, const char *token_end, const char *str)\n{\n  while (token != token_end && *token == *str)\n    {\n      token++;\n      str++;\n    }\n  if (token == token_end)\n    return *str == 0;\n\n  return false;\n}\n\nstatic unsigned long\ndecode_mountoptions (const char *options)\n{\n  const char *token, *end_token;\n  int i;\n  unsigned long flags = 0;\n  static const struct  { int   flag;\n                         const char *name;\n  } flags_data[] = {\n    { 0, \"rw\" },\n    { MS_RDONLY, \"ro\" },\n    { MS_NOSUID, \"nosuid\" },\n    { MS_NODEV, \"nodev\" },\n    { MS_NOEXEC, \"noexec\" },\n    { MS_NOATIME, \"noatime\" },\n    { MS_NODIRATIME, \"nodiratime\" },\n    { MS_RELATIME, \"relatime\" },\n    { 0, NULL }\n  };\n\n  token = options;\n  do\n    {\n      end_token = strchr (token, ',');\n      if (end_token == NULL)\n        end_token = token + strlen (token);\n\n      for (i = 0; flags_data[i].name != NULL; i++)\n        {\n          if (match_token (token, end_token, flags_data[i].name))\n            {\n              flags |= flags_data[i].flag;\n              break;\n            }\n        }\n\n      if (*end_token != 0)\n        token = end_token + 1;\n      else\n        token = NULL;\n    }\n  while (token != NULL);\n\n  return flags;\n}\n\ntypedef struct MountInfo MountInfo;\nstruct MountInfo {\n  char *mountpoint;\n  unsigned long options;\n};\n\ntypedef MountInfo *MountTab;\n\nstatic void\nmount_tab_free (MountTab tab)\n{\n  int i;\n\n  for (i = 0; tab[i].mountpoint != NULL; i++)\n    free (tab[i].mountpoint);\n  free (tab);\n}\n\nstatic inline void\ncleanup_mount_tabp (void *p)\n{\n  void **pp = (void **) p;\n\n  if (*pp)\n    mount_tab_free ((MountTab)*pp);\n}\n\n#define cleanup_mount_tab __attribute__((cleanup (cleanup_mount_tabp)))\n\ntypedef struct MountInfoLine MountInfoLine;\nstruct MountInfoLine {\n  const char *mountpoint;\n  const char *options;\n  bool covered;\n  int id;\n  int parent_id;\n  MountInfoLine *first_child;\n  MountInfoLine *next_sibling;\n};\n\nstatic unsigned int\ncount_lines (const char *data)\n{\n  unsigned int count = 0;\n  const char *p = data;\n\n  while (*p != 0)\n    {\n      if (*p == '\\n')\n        count++;\n      p++;\n    }\n\n  /* If missing final newline, add one */\n  if (p > data && *(p-1) != '\\n')\n    count++;\n\n  return count;\n}\n\nstatic int\ncount_mounts (MountInfoLine *line)\n{\n  MountInfoLine *child;\n  int res = 0;\n\n  if (!line->covered)\n    res += 1;\n\n  child = line->first_child;\n  while (child != NULL)\n    {\n      res += count_mounts (child);\n      child = child->next_sibling;\n    }\n\n  return res;\n}\n\nstatic MountInfo *\ncollect_mounts (MountInfo *info, MountInfoLine *line)\n{\n  MountInfoLine *child;\n\n  if (!line->covered)\n    {\n      info->mountpoint = xstrdup (line->mountpoint);\n      info->options = decode_mountoptions (line->options);\n      info ++;\n    }\n\n  child = line->first_child;\n  while (child != NULL)\n    {\n      info = collect_mounts (info, child);\n      child = child->next_sibling;\n    }\n\n  return info;\n}\n\nstatic MountTab\nparse_mountinfo (int  proc_fd,\n                 const char *root_mount)\n{\n  cleanup_free char *mountinfo = NULL;\n  cleanup_free MountInfoLine *lines = NULL;\n  cleanup_free MountInfoLine **by_id = NULL;\n  cleanup_mount_tab MountTab mount_tab = NULL;\n  MountInfo *end_tab;\n  int n_mounts;\n  char *line;\n  unsigned int i;\n  int max_id;\n  unsigned int n_lines;\n  int root;\n\n  mountinfo = load_file_at (proc_fd, \"self/mountinfo\");\n  if (mountinfo == NULL)\n    die_with_error (\"Can't open /proc/self/mountinfo\");\n\n  n_lines = count_lines (mountinfo);\n  lines = xcalloc (n_lines, sizeof (MountInfoLine));\n\n  max_id = 0;\n  line = mountinfo;\n  i = 0;\n  root = -1;\n  while (*line != 0)\n    {\n      int rc, consumed = 0;\n      unsigned int maj, min;\n      char *end;\n      char *rest;\n      char *mountpoint;\n      char *mountpoint_end;\n      char *options;\n      char *options_end;\n      char *next_line;\n\n      assert (i < n_lines);\n\n      end = strchr (line, '\\n');\n      if (end != NULL)\n        {\n          *end = 0;\n          next_line = end + 1;\n        }\n      else\n        next_line = line + strlen (line);\n\n      rc = sscanf (line, \"%d %d %u:%u %n\", &lines[i].id, &lines[i].parent_id, &maj, &min, &consumed);\n      if (rc != 4)\n        die (\"Can't parse mountinfo line\");\n      rest = line + consumed;\n\n      rest = skip_token (rest, true); /* mountroot */\n      mountpoint = rest;\n      rest = skip_token (rest, false); /* mountpoint */\n      mountpoint_end = rest++;\n      options = rest;\n      rest = skip_token (rest, false); /* vfs options */\n      options_end = rest;\n\n      *mountpoint_end = 0;\n      lines[i].mountpoint = unescape_inline (mountpoint);\n\n      *options_end = 0;\n      lines[i].options = options;\n\n      if (lines[i].id > max_id)\n        max_id = lines[i].id;\n      if (lines[i].parent_id > max_id)\n        max_id = lines[i].parent_id;\n\n      if (path_equal (lines[i].mountpoint, root_mount))\n        root = i;\n\n      i++;\n      line = next_line;\n    }\n  assert (i == n_lines);\n\n  if (root == -1)\n    {\n      mount_tab = xcalloc (1, sizeof (MountInfo));\n      return steal_pointer (&mount_tab);\n    }\n\n  by_id = xcalloc (max_id + 1, sizeof (MountInfoLine*));\n  for (i = 0; i < n_lines; i++)\n    by_id[lines[i].id] = &lines[i];\n\n  for (i = 0; i < n_lines; i++)\n    {\n      MountInfoLine *this = &lines[i];\n      MountInfoLine *parent = by_id[this->parent_id];\n      MountInfoLine **to_sibling;\n      MountInfoLine *sibling;\n      bool covered = false;\n\n      if (!has_path_prefix (this->mountpoint, root_mount))\n        continue;\n\n      if (parent == NULL)\n        continue;\n\n      if (strcmp (parent->mountpoint, this->mountpoint) == 0)\n        parent->covered = true;\n\n      to_sibling = &parent->first_child;\n      sibling = parent->first_child;\n      while (sibling != NULL)\n        {\n          /* If this mountpoint is a path prefix of the sibling,\n           * say this->mp=/foo/bar and sibling->mp=/foo, then it is\n           * covered by the sibling, and we drop it. */\n          if (has_path_prefix (this->mountpoint, sibling->mountpoint))\n            {\n              covered = true;\n              break;\n            }\n\n          /* If the sibling is a path prefix of this mount point,\n           * say this->mp=/foo and sibling->mp=/foo/bar, then the sibling\n           * is covered, and we drop it.\n            */\n          if (has_path_prefix (sibling->mountpoint, this->mountpoint))\n            *to_sibling = sibling->next_sibling;\n          else\n            to_sibling = &sibling->next_sibling;\n          sibling = sibling->next_sibling;\n        }\n\n      if (covered)\n          continue;\n\n      *to_sibling = this;\n    }\n\n  n_mounts = count_mounts (&lines[root]);\n  mount_tab = xcalloc (n_mounts + 1, sizeof (MountInfo));\n\n  end_tab = collect_mounts (&mount_tab[0], &lines[root]);\n  assert (end_tab == &mount_tab[n_mounts]);\n\n  return steal_pointer (&mount_tab);\n}\n\nbind_mount_result\nbind_mount (int           proc_fd,\n            const char   *src,\n            const char   *dest,\n            bind_option_t options,\n            char        **failing_path)\n{\n  bool readonly = (options & BIND_READONLY) != 0;\n  bool devices = (options & BIND_DEVICES) != 0;\n  bool recursive = (options & BIND_RECURSIVE) != 0;\n  unsigned long current_flags, new_flags;\n  cleanup_mount_tab MountTab mount_tab = NULL;\n  cleanup_free char *resolved_dest = NULL;\n  cleanup_free char *dest_proc = NULL;\n  cleanup_free char *oldroot_dest_proc = NULL;\n  cleanup_free char *kernel_case_combination = NULL;\n  cleanup_fd int dest_fd = -1;\n  int i;\n\n  if (src)\n    {\n      if (mount (src, dest, NULL, MS_SILENT | MS_BIND | (recursive ? MS_REC : 0), NULL) != 0)\n        return BIND_MOUNT_ERROR_MOUNT;\n    }\n\n  /* The mount operation will resolve any symlinks in the destination\n     path, so to find it in the mount table we need to do that too. */\n  resolved_dest = realpath (dest, NULL);\n  if (resolved_dest == NULL)\n    return BIND_MOUNT_ERROR_REALPATH_DEST;\n\n  dest_fd = TEMP_FAILURE_RETRY (open (resolved_dest, O_PATH | O_CLOEXEC));\n  if (dest_fd < 0)\n    {\n      if (failing_path != NULL)\n        *failing_path = steal_pointer (&resolved_dest);\n\n      return BIND_MOUNT_ERROR_REOPEN_DEST;\n    }\n\n  /* If we are in a case-insensitive filesystem, mountinfo might contain a\n   * different case combination of the path we requested to mount.\n   * This is due to the fact that the kernel, as of the beginning of 2021,\n   * populates mountinfo with whatever case combination first appeared in the\n   * dcache; kernel developers plan to change this in future so that it\n   * reflects the on-disk encoding instead.\n   * To avoid throwing an error when this happens, we use readlink() result\n   * instead of the provided @root_mount, so that we can compare the mountinfo\n   * entries with the same case combination that the kernel is expected to\n   * use. */\n  dest_proc = xasprintf (\"/proc/self/fd/%d\", dest_fd);\n  oldroot_dest_proc = get_oldroot_path (dest_proc);\n  kernel_case_combination = readlink_malloc (oldroot_dest_proc);\n  if (kernel_case_combination == NULL)\n    {\n      if (failing_path != NULL)\n        *failing_path = steal_pointer (&resolved_dest);\n\n      return BIND_MOUNT_ERROR_READLINK_DEST_PROC_FD;\n    }\n\n  mount_tab = parse_mountinfo (proc_fd, kernel_case_combination);\n  if (mount_tab[0].mountpoint == NULL)\n    {\n      if (failing_path != NULL)\n        *failing_path = steal_pointer (&kernel_case_combination);\n\n      errno = EINVAL;\n      return BIND_MOUNT_ERROR_FIND_DEST_MOUNT;\n    }\n\n  assert (path_equal (mount_tab[0].mountpoint, kernel_case_combination));\n  current_flags = mount_tab[0].options;\n  new_flags = current_flags | (devices ? 0 : MS_NODEV) | MS_NOSUID | (readonly ? MS_RDONLY : 0);\n  if (new_flags != current_flags &&\n      mount (\"none\", resolved_dest,\n             NULL, MS_SILENT | MS_BIND | MS_REMOUNT | new_flags, NULL) != 0)\n    {\n      if (failing_path != NULL)\n        *failing_path = steal_pointer (&resolved_dest);\n\n      return BIND_MOUNT_ERROR_REMOUNT_DEST;\n    }\n\n  /* We need to work around the fact that a bind mount does not apply the flags, so we need to manually\n   * apply the flags to all submounts in the recursive case.\n   * Note: This does not apply the flags to mounts which are later propagated into this namespace.\n   */\n  if (recursive)\n    {\n      for (i = 1; mount_tab[i].mountpoint != NULL; i++)\n        {\n          current_flags = mount_tab[i].options;\n          new_flags = current_flags | (devices ? 0 : MS_NODEV) | MS_NOSUID | (readonly ? MS_RDONLY : 0);\n          if (new_flags != current_flags &&\n              mount (\"none\", mount_tab[i].mountpoint,\n                     NULL, MS_SILENT | MS_BIND | MS_REMOUNT | new_flags, NULL) != 0)\n            {\n              /* If we can't read the mountpoint we can't remount it, but that should\n                 be safe to ignore because its not something the user can access. */\n              if (errno != EACCES)\n                {\n                  if (failing_path != NULL)\n                    *failing_path = xstrdup (mount_tab[i].mountpoint);\n\n                  return BIND_MOUNT_ERROR_REMOUNT_SUBMOUNT;\n                }\n            }\n        }\n    }\n\n  return BIND_MOUNT_SUCCESS;\n}\n\n/**\n * Return a string representing bind_mount_result, like strerror().\n * If want_errno_p is non-NULL, *want_errno_p is used to indicate whether\n * it would make sense to print strerror(saved_errno).\n */\nstatic char *\nbind_mount_result_to_string (bind_mount_result res,\n                             const char *failing_path,\n                             bool *want_errno_p)\n{\n  char *string = NULL;\n  bool want_errno = true;\n\n  switch (res)\n    {\n      case BIND_MOUNT_ERROR_MOUNT:\n        string = xstrdup (\"Unable to mount source on destination\");\n        break;\n\n      case BIND_MOUNT_ERROR_REALPATH_DEST:\n        string = xstrdup (\"realpath(destination)\");\n        break;\n\n      case BIND_MOUNT_ERROR_REOPEN_DEST:\n        string = xasprintf (\"open(\\\"%s\\\", O_PATH)\", failing_path);\n        break;\n\n      case BIND_MOUNT_ERROR_READLINK_DEST_PROC_FD:\n        string = xasprintf (\"readlink(/proc/self/fd/N) for \\\"%s\\\"\", failing_path);\n        break;\n\n      case BIND_MOUNT_ERROR_FIND_DEST_MOUNT:\n        string = xasprintf (\"Unable to find \\\"%s\\\" in mount table\", failing_path);\n        want_errno = false;\n        break;\n\n      case BIND_MOUNT_ERROR_REMOUNT_DEST:\n        string = xasprintf (\"Unable to remount destination \\\"%s\\\" with correct flags\",\n                            failing_path);\n        break;\n\n      case BIND_MOUNT_ERROR_REMOUNT_SUBMOUNT:\n        string = xasprintf (\"Unable to apply mount flags: remount \\\"%s\\\"\",\n                            failing_path);\n        break;\n\n      case BIND_MOUNT_SUCCESS:\n        string = xstrdup (\"Success\");\n        break;\n\n      default:\n        string = xstrdup (\"(unknown/invalid bind_mount_result)\");\n        break;\n    }\n\n  if (want_errno_p != NULL)\n    *want_errno_p = want_errno;\n\n  return string;\n}\n\nvoid\ndie_with_bind_result (bind_mount_result res,\n                      int               saved_errno,\n                      const char       *failing_path,\n                      const char       *format,\n                      ...)\n{\n  va_list args;\n  bool want_errno = true;\n  char *message;\n\n  if (bwrap_level_prefix)\n    fprintf (stderr, \"<%d>\", LOG_ERR);\n\n  fprintf (stderr, \"bwrap: \");\n\n  va_start (args, format);\n  vfprintf (stderr, format, args);\n  va_end (args);\n\n  message = bind_mount_result_to_string (res, failing_path, &want_errno);\n  fprintf (stderr, \": %s\", message);\n  /* message is leaked, but we're exiting unsuccessfully anyway, so ignore */\n\n  if (want_errno)\n    {\n      switch (res)\n        {\n          case BIND_MOUNT_ERROR_MOUNT:\n          case BIND_MOUNT_ERROR_REMOUNT_DEST:\n          case BIND_MOUNT_ERROR_REMOUNT_SUBMOUNT:\n            fprintf (stderr, \": %s\", mount_strerror (saved_errno));\n            break;\n\n          case BIND_MOUNT_ERROR_REALPATH_DEST:\n          case BIND_MOUNT_ERROR_REOPEN_DEST:\n          case BIND_MOUNT_ERROR_READLINK_DEST_PROC_FD:\n          case BIND_MOUNT_ERROR_FIND_DEST_MOUNT:\n          case BIND_MOUNT_SUCCESS:\n          default:\n            fprintf (stderr, \": %s\", strerror (saved_errno));\n        }\n    }\n\n  fprintf (stderr, \"\\n\");\n  exit (1);\n}\n"
        },
        {
          "name": "bind-mount.h",
          "type": "blob",
          "size": 1.779296875,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#pragma once\n\n#include \"utils.h\"\n\ntypedef enum {\n  BIND_READONLY = (1 << 0),\n  BIND_DEVICES = (1 << 2),\n  BIND_RECURSIVE = (1 << 3),\n} bind_option_t;\n\ntypedef enum\n{\n  BIND_MOUNT_SUCCESS = 0,\n  BIND_MOUNT_ERROR_MOUNT,\n  BIND_MOUNT_ERROR_REALPATH_DEST,\n  BIND_MOUNT_ERROR_REOPEN_DEST,\n  BIND_MOUNT_ERROR_READLINK_DEST_PROC_FD,\n  BIND_MOUNT_ERROR_FIND_DEST_MOUNT,\n  BIND_MOUNT_ERROR_REMOUNT_DEST,\n  BIND_MOUNT_ERROR_REMOUNT_SUBMOUNT,\n} bind_mount_result;\n\nbind_mount_result bind_mount (int           proc_fd,\n                              const char   *src,\n                              const char   *dest,\n                              bind_option_t options,\n                              char        **failing_path);\n\nvoid die_with_bind_result (bind_mount_result res,\n                           int               saved_errno,\n                           const char       *failing_path,\n                           const char       *format,\n                           ...)\n  __attribute__((__noreturn__))\n  __attribute__((format (printf, 4, 5)));\n"
        },
        {
          "name": "bubblewrap.c",
          "type": "blob",
          "size": 113.455078125,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"config.h\"\n\n#include <poll.h>\n#include <sched.h>\n#include <pwd.h>\n#include <grp.h>\n#include <ctype.h>\n#include <sys/mount.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/eventfd.h>\n#include <sys/fsuid.h>\n#include <sys/signalfd.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <linux/sched.h>\n#include <linux/seccomp.h>\n#include <linux/filter.h>\n\n#include \"utils.h\"\n#include \"network.h\"\n#include \"bind-mount.h\"\n\n#ifndef CLONE_NEWCGROUP\n#define CLONE_NEWCGROUP 0x02000000 /* New cgroup namespace */\n#endif\n\n/* We limit the size of a tmpfs to half the architecture's address space,\n * to avoid hitting arbitrary limits in the kernel.\n * For example, on at least one x86_64 machine, the actual limit seems to be\n * 2^64 - 2^12. */\n#define MAX_TMPFS_BYTES ((size_t) (SIZE_MAX >> 1))\n\n/* Globals to avoid having to use getuid(), since the uid/gid changes during runtime */\nstatic uid_t real_uid;\nstatic gid_t real_gid;\nstatic uid_t overflow_uid;\nstatic gid_t overflow_gid;\nstatic bool is_privileged; /* See acquire_privs() */\nstatic const char *argv0;\nstatic const char *host_tty_dev;\nstatic int proc_fd = -1;\nstatic const char *opt_exec_label = NULL;\nstatic const char *opt_file_label = NULL;\nstatic bool opt_as_pid_1;\n\nstatic const char *opt_argv0 = NULL;\nstatic const char *opt_chdir_path = NULL;\nstatic bool opt_assert_userns_disabled = false;\nstatic bool opt_disable_userns = false;\nstatic bool opt_unshare_user = false;\nstatic bool opt_unshare_user_try = false;\nstatic bool opt_unshare_pid = false;\nstatic bool opt_unshare_ipc = false;\nstatic bool opt_unshare_net = false;\nstatic bool opt_unshare_uts = false;\nstatic bool opt_unshare_cgroup = false;\nstatic bool opt_unshare_cgroup_try = false;\nstatic bool opt_needs_devpts = false;\nstatic bool opt_new_session = false;\nstatic bool opt_die_with_parent = false;\nstatic uid_t opt_sandbox_uid = -1;\nstatic gid_t opt_sandbox_gid = -1;\nstatic int opt_sync_fd = -1;\nstatic int opt_block_fd = -1;\nstatic int opt_userns_block_fd = -1;\nstatic int opt_info_fd = -1;\nstatic int opt_json_status_fd = -1;\nstatic int opt_seccomp_fd = -1;\nstatic const char *opt_sandbox_hostname = NULL;\nstatic char *opt_args_data = NULL;  /* owned */\nstatic int opt_userns_fd = -1;\nstatic int opt_userns2_fd = -1;\nstatic int opt_pidns_fd = -1;\nstatic int opt_tmp_overlay_count = 0;\nstatic int next_perms = -1;\nstatic size_t next_size_arg = 0;\nstatic int next_overlay_src_count = 0;\n\n#define CAP_TO_MASK_0(x) (1L << ((x) & 31))\n#define CAP_TO_MASK_1(x) CAP_TO_MASK_0(x - 32)\n\ntypedef struct _NsInfo NsInfo;\n\nstruct _NsInfo {\n  const char *name;\n  bool       *do_unshare;\n  ino_t       id;\n};\n\nstatic NsInfo ns_infos[] = {\n  {\"cgroup\", &opt_unshare_cgroup, 0},\n  {\"ipc\",    &opt_unshare_ipc,    0},\n  {\"mnt\",    NULL,                0},\n  {\"net\",    &opt_unshare_net,    0},\n  {\"pid\",    &opt_unshare_pid,    0},\n  /* user namespace info omitted because it\n   * is not (yet) valid when we obtain the\n   * namespace info (get un-shared later) */\n  {\"uts\",    &opt_unshare_uts,    0},\n  {NULL,     NULL,                0}\n};\n\ntypedef enum {\n  SETUP_BIND_MOUNT,\n  SETUP_RO_BIND_MOUNT,\n  SETUP_DEV_BIND_MOUNT,\n  SETUP_OVERLAY_MOUNT,\n  SETUP_TMP_OVERLAY_MOUNT,\n  SETUP_RO_OVERLAY_MOUNT,\n  SETUP_OVERLAY_SRC,\n  SETUP_MOUNT_PROC,\n  SETUP_MOUNT_DEV,\n  SETUP_MOUNT_TMPFS,\n  SETUP_MOUNT_MQUEUE,\n  SETUP_MAKE_DIR,\n  SETUP_MAKE_FILE,\n  SETUP_MAKE_BIND_FILE,\n  SETUP_MAKE_RO_BIND_FILE,\n  SETUP_MAKE_SYMLINK,\n  SETUP_REMOUNT_RO_NO_RECURSIVE,\n  SETUP_SET_HOSTNAME,\n  SETUP_CHMOD,\n} SetupOpType;\n\ntypedef enum {\n  NO_CREATE_DEST = (1 << 0),\n  ALLOW_NOTEXIST = (1 << 1),\n} SetupOpFlag;\n\ntypedef struct _SetupOp SetupOp;\n\nstruct _SetupOp\n{\n  SetupOpType type;\n  const char *source;\n  const char *dest;\n  int         fd;\n  SetupOpFlag flags;\n  int         perms;\n  size_t      size;  /* number of bytes, zero means unset/default */\n  SetupOp    *next;\n};\n\ntypedef struct _LockFile LockFile;\n\nstruct _LockFile\n{\n  const char *path;\n  int         fd;\n  LockFile   *next;\n};\n\nenum {\n  PRIV_SEP_OP_DONE,\n  PRIV_SEP_OP_BIND_MOUNT,\n  PRIV_SEP_OP_OVERLAY_MOUNT,\n  PRIV_SEP_OP_PROC_MOUNT,\n  PRIV_SEP_OP_TMPFS_MOUNT,\n  PRIV_SEP_OP_DEVPTS_MOUNT,\n  PRIV_SEP_OP_MQUEUE_MOUNT,\n  PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE,\n  PRIV_SEP_OP_SET_HOSTNAME,\n};\n\ntypedef struct\n{\n  uint32_t op;\n  uint32_t flags;\n  uint32_t perms;\n  size_t   size_arg;\n  uint32_t arg1_offset;\n  uint32_t arg2_offset;\n} PrivSepOp;\n\n/*\n * DEFINE_LINKED_LIST:\n * @Type: A struct with a `Type *next` member\n * @name: Used to form the names of variables and functions\n *\n * Define a global linked list of @Type structures, with pointers\n * `NAMEs` to the head of the list and `last_NAME` to the tail of the\n * list.\n *\n * A new zero-filled item can be allocated and appended to the list\n * by calling `_NAME_append_new()`, which returns the new item.\n */\n#define DEFINE_LINKED_LIST(Type, name) \\\nstatic Type *name ## s = NULL; \\\nstatic Type *last_ ## name = NULL; \\\n\\\nstatic inline Type * \\\n_ ## name ## _append_new (void) \\\n{ \\\n  Type *self = xcalloc (1, sizeof (Type)); \\\n\\\n  if (last_ ## name != NULL) \\\n    last_ ## name ->next = self; \\\n  else \\\n    name ## s = self; \\\n\\\n  last_ ## name = self; \\\n  return self; \\\n}\n\nDEFINE_LINKED_LIST (SetupOp, op)\n\nstatic SetupOp *\nsetup_op_new (SetupOpType type)\n{\n  SetupOp *op = _op_append_new ();\n\n  op->type = type;\n  op->fd = -1;\n  op->flags = 0;\n  return op;\n}\n\nDEFINE_LINKED_LIST (LockFile, lock_file)\n\nstatic LockFile *\nlock_file_new (const char *path)\n{\n  LockFile *lock = _lock_file_append_new ();\n\n  lock->path = path;\n  return lock;\n}\n\ntypedef struct _SeccompProgram SeccompProgram;\n\nstruct _SeccompProgram\n{\n  struct sock_fprog  program;\n  SeccompProgram    *next;\n};\n\nDEFINE_LINKED_LIST (SeccompProgram, seccomp_program)\n\nstatic SeccompProgram *\nseccomp_program_new (int *fd)\n{\n  SeccompProgram *self = _seccomp_program_append_new ();\n  cleanup_free char *data = NULL;\n  size_t len;\n\n  data = load_file_data (*fd, &len);\n\n  if (data == NULL)\n    die_with_error (\"Can't read seccomp data\");\n\n  close (*fd);\n  *fd = -1;\n\n  if (len % 8 != 0)\n    die (\"Invalid seccomp data, must be multiple of 8\");\n\n  self->program.len = len / 8;\n  self->program.filter = (struct sock_filter *) steal_pointer (&data);\n  return self;\n}\n\nstatic void\nseccomp_programs_apply (void)\n{\n  SeccompProgram *program;\n\n  for (program = seccomp_programs; program != NULL; program = program->next)\n    {\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &program->program) != 0)\n        {\n          if (errno == EINVAL)\n            die (\"Unable to set up system call filtering as requested: \"\n                 \"prctl(PR_SET_SECCOMP) reported EINVAL. \"\n                 \"(Hint: this requires a kernel configured with \"\n                 \"CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER.)\");\n\n          die_with_error (\"prctl(PR_SET_SECCOMP)\");\n        }\n    }\n}\n\nstatic void\nusage (int ecode, FILE *out)\n{\n  fprintf (out, \"usage: %s [OPTIONS...] [--] COMMAND [ARGS...]\\n\\n\", argv0 ? argv0 : \"bwrap\");\n\n  fprintf (out,\n           \"    --help                       Print this help\\n\"\n           \"    --version                    Print version\\n\"\n           \"    --args FD                    Parse NUL-separated args from FD\\n\"\n           \"    --argv0 VALUE                Set argv[0] to the value VALUE before running the program\\n\"\n           \"    --level-prefix               Prepend e.g. <3> to diagnostic messages\\n\"\n           \"    --unshare-all                Unshare every namespace we support by default\\n\"\n           \"    --share-net                  Retain the network namespace (can only combine with --unshare-all)\\n\"\n           \"    --unshare-user               Create new user namespace (may be automatically implied if not setuid)\\n\"\n           \"    --unshare-user-try           Create new user namespace if possible else continue by skipping it\\n\"\n           \"    --unshare-ipc                Create new ipc namespace\\n\"\n           \"    --unshare-pid                Create new pid namespace\\n\"\n           \"    --unshare-net                Create new network namespace\\n\"\n           \"    --unshare-uts                Create new uts namespace\\n\"\n           \"    --unshare-cgroup             Create new cgroup namespace\\n\"\n           \"    --unshare-cgroup-try         Create new cgroup namespace if possible else continue by skipping it\\n\"\n           \"    --userns FD                  Use this user namespace (cannot combine with --unshare-user)\\n\"\n           \"    --userns2 FD                 After setup switch to this user namespace, only useful with --userns\\n\"\n           \"    --disable-userns             Disable further use of user namespaces inside sandbox\\n\"\n           \"    --assert-userns-disabled     Fail unless further use of user namespace inside sandbox is disabled\\n\"\n           \"    --pidns FD                   Use this pid namespace (as parent namespace if using --unshare-pid)\\n\"\n           \"    --uid UID                    Custom uid in the sandbox (requires --unshare-user or --userns)\\n\"\n           \"    --gid GID                    Custom gid in the sandbox (requires --unshare-user or --userns)\\n\"\n           \"    --hostname NAME              Custom hostname in the sandbox (requires --unshare-uts)\\n\"\n           \"    --chdir DIR                  Change directory to DIR\\n\"\n           \"    --clearenv                   Unset all environment variables\\n\"\n           \"    --setenv VAR VALUE           Set an environment variable\\n\"\n           \"    --unsetenv VAR               Unset an environment variable\\n\"\n           \"    --lock-file DEST             Take a lock on DEST while sandbox is running\\n\"\n           \"    --sync-fd FD                 Keep this fd open while sandbox is running\\n\"\n           \"    --bind SRC DEST              Bind mount the host path SRC on DEST\\n\"\n           \"    --bind-try SRC DEST          Equal to --bind but ignores non-existent SRC\\n\"\n           \"    --dev-bind SRC DEST          Bind mount the host path SRC on DEST, allowing device access\\n\"\n           \"    --dev-bind-try SRC DEST      Equal to --dev-bind but ignores non-existent SRC\\n\"\n           \"    --ro-bind SRC DEST           Bind mount the host path SRC readonly on DEST\\n\"\n           \"    --ro-bind-try SRC DEST       Equal to --ro-bind but ignores non-existent SRC\\n\"\n           \"    --bind-fd FD DEST            Bind open directory or path fd on DEST\\n\"\n           \"    --ro-bind-fd FD DEST         Bind open directory or path fd read-only on DEST\\n\"\n           \"    --remount-ro DEST            Remount DEST as readonly; does not recursively remount\\n\"\n           \"    --overlay-src SRC            Read files from SRC in the following overlay\\n\"\n           \"    --overlay RWSRC WORKDIR DEST Mount overlayfs on DEST, with RWSRC as the host path for writes and\\n\"\n           \"                                 WORKDIR an empty directory on the same filesystem as RWSRC\\n\"\n           \"    --tmp-overlay DEST           Mount overlayfs on DEST, with writes going to an invisible tmpfs\\n\"\n           \"    --ro-overlay DEST            Mount overlayfs read-only on DEST\\n\"\n           \"    --exec-label LABEL           Exec label for the sandbox\\n\"\n           \"    --file-label LABEL           File label for temporary sandbox content\\n\"\n           \"    --proc DEST                  Mount new procfs on DEST\\n\"\n           \"    --dev DEST                   Mount new dev on DEST\\n\"\n           \"    --tmpfs DEST                 Mount new tmpfs on DEST\\n\"\n           \"    --mqueue DEST                Mount new mqueue on DEST\\n\"\n           \"    --dir DEST                   Create dir at DEST\\n\"\n           \"    --file FD DEST               Copy from FD to destination DEST\\n\"\n           \"    --bind-data FD DEST          Copy from FD to file which is bind-mounted on DEST\\n\"\n           \"    --ro-bind-data FD DEST       Copy from FD to file which is readonly bind-mounted on DEST\\n\"\n           \"    --symlink SRC DEST           Create symlink at DEST with target SRC\\n\"\n           \"    --seccomp FD                 Load and use seccomp rules from FD (not repeatable)\\n\"\n           \"    --add-seccomp-fd FD          Load and use seccomp rules from FD (repeatable)\\n\"\n           \"    --block-fd FD                Block on FD until some data to read is available\\n\"\n           \"    --userns-block-fd FD         Block on FD until the user namespace is ready\\n\"\n           \"    --info-fd FD                 Write information about the running container to FD\\n\"\n           \"    --json-status-fd FD          Write container status to FD as multiple JSON documents\\n\"\n           \"    --new-session                Create a new terminal session\\n\"\n           \"    --die-with-parent            Kills with SIGKILL child process (COMMAND) when bwrap or bwrap's parent dies.\\n\"\n           \"    --as-pid-1                   Do not install a reaper process with PID=1\\n\"\n           \"    --cap-add CAP                Add cap CAP when running as privileged user\\n\"\n           \"    --cap-drop CAP               Drop cap CAP when running as privileged user\\n\"\n           \"    --perms OCTAL                Set permissions of next argument (--bind-data, --file, etc.)\\n\"\n           \"    --size BYTES                 Set size of next argument (only for --tmpfs)\\n\"\n           \"    --chmod OCTAL PATH           Change permissions of PATH (must already exist)\\n\"\n          );\n  exit (ecode);\n}\n\n/* If --die-with-parent was specified, use PDEATHSIG to ensure SIGKILL\n * is sent to the current process when our parent dies.\n */\nstatic void\nhandle_die_with_parent (void)\n{\n  if (opt_die_with_parent && prctl (PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0) != 0)\n    die_with_error (\"prctl\");\n}\n\nstatic void\nblock_sigchild (void)\n{\n  sigset_t mask;\n  int status;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_BLOCK, &mask, NULL) == -1)\n    die_with_error (\"sigprocmask\");\n\n  /* Reap any outstanding zombies that we may have inherited */\n  while (waitpid (-1, &status, WNOHANG) > 0)\n    ;\n}\n\nstatic void\nunblock_sigchild (void)\n{\n  sigset_t mask;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_UNBLOCK, &mask, NULL) == -1)\n    die_with_error (\"sigprocmask\");\n}\n\n/* Closes all fd:s except 0,1,2 and the passed in array of extra fds */\nstatic int\nclose_extra_fds (void *data, int fd)\n{\n  int *extra_fds = (int *) data;\n  int i;\n\n  for (i = 0; extra_fds[i] != -1; i++)\n    if (fd == extra_fds[i])\n      return 0;\n\n  if (fd <= 2)\n    return 0;\n\n  close (fd);\n  return 0;\n}\n\nstatic int\npropagate_exit_status (int status)\n{\n  if (WIFEXITED (status))\n    return WEXITSTATUS (status);\n\n  /* The process died of a signal, we can't really report that, but we\n   * can at least be bash-compatible. The bash manpage says:\n   *   The return value of a simple command is its\n   *   exit status, or 128+n if the command is\n   *   terminated by signal n.\n   */\n  if (WIFSIGNALED (status))\n    return 128 + WTERMSIG (status);\n\n  /* Weird? */\n  return 255;\n}\n\nstatic void\ndump_info (int fd, const char *output, bool exit_on_error)\n{\n  size_t len = strlen (output);\n  if (write_to_fd (fd, output, len))\n    {\n      if (exit_on_error)\n        die_with_error (\"Write to info_fd\");\n    }\n}\n\nstatic void\nreport_child_exit_status (int exitc, int setup_finished_fd)\n{\n  ssize_t s;\n  char data[2];\n  cleanup_free char *output = NULL;\n  if (opt_json_status_fd == -1 || setup_finished_fd == -1)\n    return;\n\n  s = TEMP_FAILURE_RETRY (read (setup_finished_fd, data, sizeof data));\n  if (s == -1 && errno != EAGAIN)\n    die_with_error (\"read eventfd\");\n  if (s != 1) // Is 0 if pipe closed before exec, is 2 if closed after exec.\n    return;\n\n  output = xasprintf (\"{ \\\"exit-code\\\": %i }\\n\", exitc);\n  dump_info (opt_json_status_fd, output, false);\n  close (opt_json_status_fd);\n  opt_json_status_fd = -1;\n  close (setup_finished_fd);\n}\n\n/* This stays around for as long as the initial process in the app does\n * and when that exits it exits, propagating the exit status. We do this\n * by having pid 1 in the sandbox detect this exit and tell the monitor\n * the exit status via a eventfd. We also track the exit of the sandbox\n * pid 1 via a signalfd for SIGCHLD, and exit with an error in this case.\n * This is to catch e.g. problems during setup. */\nstatic int\nmonitor_child (int event_fd, pid_t child_pid, int setup_finished_fd)\n{\n  int res;\n  uint64_t val;\n  ssize_t s;\n  int signal_fd;\n  sigset_t mask;\n  struct pollfd fds[2];\n  int num_fds;\n  struct signalfd_siginfo fdsi;\n  int dont_close[] = {-1, -1, -1, -1};\n  unsigned int j = 0;\n  int exitc;\n  pid_t died_pid;\n  int died_status;\n\n  /* Close all extra fds in the monitoring process.\n     Any passed in fds have been passed on to the child anyway. */\n  if (event_fd != -1)\n    dont_close[j++] = event_fd;\n  if (opt_json_status_fd != -1)\n    dont_close[j++] = opt_json_status_fd;\n  if (setup_finished_fd != -1)\n    dont_close[j++] = setup_finished_fd;\n  assert (j < sizeof(dont_close)/sizeof(*dont_close));\n  fdwalk (proc_fd, close_extra_fds, dont_close);\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  signal_fd = signalfd (-1, &mask, SFD_CLOEXEC | SFD_NONBLOCK);\n  if (signal_fd == -1)\n    die_with_error (\"Can't create signalfd\");\n\n  num_fds = 1;\n  fds[0].fd = signal_fd;\n  fds[0].events = POLLIN;\n  if (event_fd != -1)\n    {\n      fds[1].fd = event_fd;\n      fds[1].events = POLLIN;\n      num_fds++;\n    }\n\n  while (1)\n    {\n      fds[0].revents = fds[1].revents = 0;\n      res = poll (fds, num_fds, -1);\n      if (res == -1 && errno != EINTR)\n        die_with_error (\"poll\");\n\n      /* Always read from the eventfd first, if pid 2 died then pid 1 often\n       * dies too, and we could race, reporting that first and we'd lose\n       * the real exit status. */\n      if (event_fd != -1)\n        {\n          s = read (event_fd, &val, 8);\n          if (s == -1 && errno != EINTR && errno != EAGAIN)\n            die_with_error (\"read eventfd\");\n          else if (s == 8)\n            {\n              exitc = (int) val - 1;\n              report_child_exit_status (exitc, setup_finished_fd);\n              return exitc;\n            }\n        }\n\n      /* We need to read the signal_fd, or it will keep polling as read,\n       * however we ignore the details as we get them from waitpid\n       * below anyway */\n      s = read (signal_fd, &fdsi, sizeof (struct signalfd_siginfo));\n      if (s == -1 && errno != EINTR && errno != EAGAIN)\n        die_with_error (\"read signalfd\");\n\n      /* We may actually get several sigchld compressed into one\n         SIGCHLD, so we have to handle all of them. */\n      while ((died_pid = waitpid (-1, &died_status, WNOHANG)) > 0)\n        {\n          /* We may be getting sigchild from other children too. For instance if\n             someone created a child process, and then exec:ed bubblewrap. Ignore them */\n          if (died_pid == child_pid)\n            {\n              exitc = propagate_exit_status (died_status);\n              report_child_exit_status (exitc, setup_finished_fd);\n              return exitc;\n            }\n        }\n    }\n\n  die (\"Should not be reached\");\n\n  return 0;\n}\n\n/* This is pid 1 in the app sandbox. It is needed because we're using\n * pid namespaces, and someone has to reap zombies in it. We also detect\n * when the initial process (pid 2) dies and report its exit status to\n * the monitor so that it can return it to the original spawner.\n *\n * When there are no other processes in the sandbox the wait will return\n * ECHILD, and we then exit pid 1 to clean up the sandbox. */\nstatic int\ndo_init (int event_fd, pid_t initial_pid)\n{\n  int initial_exit_status = 1;\n  LockFile *lock;\n\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      int fd = TEMP_FAILURE_RETRY (open (lock->path, O_RDONLY | O_CLOEXEC));\n      if (fd == -1)\n        die_with_error (\"Unable to open lock file %s\", lock->path);\n\n      struct flock l = {\n        .l_type = F_RDLCK,\n        .l_whence = SEEK_SET,\n        .l_start = 0,\n        .l_len = 0\n      };\n\n      if (TEMP_FAILURE_RETRY (fcntl (fd, F_SETLK, &l)) < 0)\n        die_with_error (\"Unable to lock file %s\", lock->path);\n\n      /* Keep fd open to hang on to lock */\n      lock->fd = fd;\n    }\n\n  /* Optionally bind our lifecycle to that of the caller */\n  handle_die_with_parent ();\n\n  seccomp_programs_apply ();\n\n  while (true)\n    {\n      pid_t child;\n      int status;\n\n      child = TEMP_FAILURE_RETRY (wait (&status));\n      if (child == initial_pid)\n        {\n          initial_exit_status = propagate_exit_status (status);\n\n          if(event_fd != -1)\n            {\n              uint64_t val;\n              int res UNUSED;\n\n              val = initial_exit_status + 1;\n              res = TEMP_FAILURE_RETRY (write (event_fd, &val, 8));\n              /* Ignore res, if e.g. the parent died and closed event_fd\n                 we don't want to error out here */\n            }\n        }\n\n      if (child == -1 && errno != EINTR)\n        {\n          if (errno != ECHILD)\n            die_with_error (\"init wait()\");\n          break;\n        }\n    }\n\n  /* Close FDs. */\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      if (lock->fd >= 0)\n        {\n          close (lock->fd);\n          lock->fd = -1;\n        }\n    }\n\n  return initial_exit_status;\n}\n\n#define CAP_TO_MASK_0(x) (1L << ((x) & 31))\n#define CAP_TO_MASK_1(x) CAP_TO_MASK_0(x - 32)\n\n/* Set if --cap-add or --cap-drop were used */\nstatic bool opt_cap_add_or_drop_used;\n/* The capability set we'll target, used if above is true */\nstatic uint32_t requested_caps[2] = {0, 0};\n\n/* low 32bit caps needed */\n/* CAP_SYS_PTRACE is needed to dereference the symlinks in /proc/<pid>/ns/, see namespaces(7) */\n#define REQUIRED_CAPS_0 (CAP_TO_MASK_0 (CAP_SYS_ADMIN) | CAP_TO_MASK_0 (CAP_SYS_CHROOT) | CAP_TO_MASK_0 (CAP_NET_ADMIN) | CAP_TO_MASK_0 (CAP_SETUID) | CAP_TO_MASK_0 (CAP_SETGID) | CAP_TO_MASK_0 (CAP_SYS_PTRACE))\n/* high 32bit caps needed */\n#define REQUIRED_CAPS_1 0\n\nstatic void\nset_required_caps (void)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  /* Drop all non-require capabilities */\n  data[0].effective = REQUIRED_CAPS_0;\n  data[0].permitted = REQUIRED_CAPS_0;\n  data[0].inheritable = 0;\n  data[1].effective = REQUIRED_CAPS_1;\n  data[1].permitted = REQUIRED_CAPS_1;\n  data[1].inheritable = 0;\n  if (capset (&hdr, data) < 0)\n    die_with_error (\"capset failed\");\n}\n\nstatic void\ndrop_all_caps (bool keep_requested_caps)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  if (keep_requested_caps)\n    {\n      /* Avoid calling capset() unless we need to; currently\n       * systemd-nspawn at least is known to install a seccomp\n       * policy denying capset() for dubious reasons.\n       * <https://github.com/projectatomic/bubblewrap/pull/122>\n       */\n      if (!opt_cap_add_or_drop_used && real_uid == 0)\n        {\n          assert (!is_privileged);\n          return;\n        }\n      data[0].effective = requested_caps[0];\n      data[0].permitted = requested_caps[0];\n      data[0].inheritable = requested_caps[0];\n      data[1].effective = requested_caps[1];\n      data[1].permitted = requested_caps[1];\n      data[1].inheritable = requested_caps[1];\n    }\n\n  if (capset (&hdr, data) < 0)\n    {\n      /* While the above logic ensures we don't call capset() for the primary\n       * process unless configured to do so, we still try to drop privileges for\n       * the init process unconditionally. Since due to the systemd seccomp\n       * filter that will fail, let's just ignore it.\n       */\n      if (errno == EPERM && real_uid == 0 && !is_privileged)\n        return;\n      else\n        die_with_error (\"capset failed\");\n    }\n}\n\nstatic bool\nhas_caps (void)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  if (capget (&hdr, data)  < 0)\n    die_with_error (\"capget failed\");\n\n  return data[0].permitted != 0 || data[1].permitted != 0;\n}\n\n/* Most of the code here is used both to add caps to the ambient capabilities\n * and drop caps from the bounding set.  Handle both cases here and add\n * drop_cap_bounding_set/set_ambient_capabilities wrappers to facilitate its usage.\n */\nstatic void\nprctl_caps (uint32_t *caps, bool do_cap_bounding, bool do_set_ambient)\n{\n  unsigned long cap;\n\n  /* We ignore both EINVAL and EPERM, as we are actually relying\n   * on PR_SET_NO_NEW_PRIVS to ensure the right capabilities are\n   * available.  EPERM in particular can happen with old, buggy\n   * kernels.  See:\n   *  https://github.com/projectatomic/bubblewrap/pull/175#issuecomment-278051373\n   *  https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/security/commoncap.c?id=160da84dbb39443fdade7151bc63a88f8e953077\n   */\n  for (cap = 0; cap <= CAP_LAST_CAP; cap++)\n    {\n      bool keep = false;\n      if (cap < 32)\n        {\n          if (CAP_TO_MASK_0 (cap) & caps[0])\n            keep = true;\n        }\n      else\n        {\n          if (CAP_TO_MASK_1 (cap) & caps[1])\n            keep = true;\n        }\n\n      if (keep && do_set_ambient)\n        {\n#ifdef PR_CAP_AMBIENT\n          int res = prctl (PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, cap, 0, 0);\n          if (res == -1 && !(errno == EINVAL || errno == EPERM))\n            die_with_error (\"Adding ambient capability %ld\", cap);\n#else\n          /* We ignore the EINVAL that results from not having PR_CAP_AMBIENT\n           * in the current kernel at runtime, so also ignore not having it\n           * in the current kernel headers at compile-time */\n#endif\n        }\n\n      if (!keep && do_cap_bounding)\n        {\n          int res = prctl (PR_CAPBSET_DROP, cap, 0, 0, 0);\n          if (res == -1 && !(errno == EINVAL || errno == EPERM))\n            die_with_error (\"Dropping capability %ld from bounds\", cap);\n        }\n    }\n}\n\nstatic void\ndrop_cap_bounding_set (bool drop_all)\n{\n  if (!drop_all)\n    prctl_caps (requested_caps, true, false);\n  else\n    {\n      uint32_t no_caps[2] = {0, 0};\n      prctl_caps (no_caps, true, false);\n    }\n}\n\nstatic void\nset_ambient_capabilities (void)\n{\n  if (is_privileged)\n    return;\n  prctl_caps (requested_caps, false, true);\n}\n\n/* This acquires the privileges that the bwrap will need it to work.\n * If bwrap is not setuid, then this does nothing, and it relies on\n * unprivileged user namespaces to be used. This case is\n * \"is_privileged = false\".\n *\n * If bwrap is setuid, then we do things in phases.\n * The first part is run as euid 0, but with fsuid as the real user.\n * The second part, inside the child, is run as the real user but with\n * capabilities.\n * And finally we drop all capabilities.\n * The reason for the above dance is to avoid having the setup phase\n * being able to read files the user can't, while at the same time\n * working around various kernel issues. See below for details.\n */\nstatic void\nacquire_privs (void)\n{\n  uid_t euid, new_fsuid;\n\n  euid = geteuid ();\n\n  /* Are we setuid ? */\n  if (real_uid != euid)\n    {\n      if (euid != 0)\n        die (\"Unexpected setuid user %d, should be 0\", euid);\n\n      is_privileged = true;\n      /* We want to keep running as euid=0 until at the clone()\n       * operation because doing so will make the user namespace be\n       * owned by root, which makes it not ptrace:able by the user as\n       * it otherwise would be. After that we will run fully as the\n       * user, which is necessary e.g. to be able to read from a fuse\n       * mount from the user.\n       *\n       * However, we don't want to accidentally mis-use euid=0 for\n       * escalated filesystem access before the clone(), so we set\n       * fsuid to the uid.\n       */\n      if (setfsuid (real_uid) < 0)\n        die_with_error (\"Unable to set fsuid\");\n\n      /* setfsuid can't properly report errors, check that it worked (as per manpage) */\n      new_fsuid = setfsuid (-1);\n      if (new_fsuid != real_uid)\n        die (\"Unable to set fsuid (was %d)\", (int)new_fsuid);\n\n      /* We never need capabilities after execve(), so lets drop everything from the bounding set */\n      drop_cap_bounding_set (true);\n\n      /* Keep only the required capabilities for setup */\n      set_required_caps ();\n    }\n  else if (real_uid != 0 && has_caps ())\n    {\n      /* We have some capabilities in the non-setuid case, which should not happen.\n         Probably caused by the binary being setcap instead of setuid which we\n         don't support anymore */\n      die (\"Unexpected capabilities but not setuid, old file caps config?\");\n    }\n  else if (real_uid == 0)\n    {\n      /* If our uid is 0, default to inheriting all caps; the caller\n       * can drop them via --cap-drop.  This is used by at least rpm-ostree.\n       * Note this needs to happen before the argument parsing of --cap-drop.\n       */\n      struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n      struct __user_cap_data_struct data[2] = { { 0 } };\n\n      if (capget (&hdr, data) < 0)\n        die_with_error (\"capget (for uid == 0) failed\");\n\n      requested_caps[0] = data[0].effective;\n      requested_caps[1] = data[1].effective;\n    }\n\n  /* Else, we try unprivileged user namespaces */\n}\n\n/* This is called once we're inside the namespace */\nstatic void\nswitch_to_user_with_privs (void)\n{\n  /* If we're in a new user namespace, we got back the bounding set, clear it again */\n  if (opt_unshare_user || opt_userns_fd != -1)\n    drop_cap_bounding_set (false);\n\n  /* If we switched to a new user namespace it may allow other uids/gids, so switch to the target one */\n  if (opt_userns_fd != -1)\n    {\n      if (opt_sandbox_uid != real_uid && setuid (opt_sandbox_uid) < 0)\n        die_with_error (\"unable to switch to uid %d\", opt_sandbox_uid);\n\n      if (opt_sandbox_gid != real_gid && setgid (opt_sandbox_gid) < 0)\n        die_with_error (\"unable to switch to gid %d\", opt_sandbox_gid);\n    }\n\n  if (!is_privileged)\n    return;\n\n  /* Tell kernel not clear capabilities when later dropping root uid */\n  if (prctl (PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_KEEPCAPS) failed\");\n\n  if (setuid (opt_sandbox_uid) < 0)\n    die_with_error (\"unable to drop root uid\");\n\n  /* Regain effective required capabilities from permitted */\n  set_required_caps ();\n}\n\n/* Call setuid() and use capset() to adjust capabilities */\nstatic void\ndrop_privs (bool keep_requested_caps,\n            bool already_changed_uid)\n{\n  assert (!keep_requested_caps || !is_privileged);\n  /* Drop root uid */\n  if (is_privileged && !already_changed_uid &&\n      setuid (opt_sandbox_uid) < 0)\n    die_with_error (\"unable to drop root uid\");\n\n  drop_all_caps (keep_requested_caps);\n\n  /* We don't have any privs now, so mark us dumpable which makes /proc/self be owned by the user instead of root */\n  if (prctl (PR_SET_DUMPABLE, 1, 0, 0, 0) != 0)\n    die_with_error (\"can't set dumpable\");\n}\n\nstatic void\nwrite_uid_gid_map (uid_t sandbox_uid,\n                   uid_t parent_uid,\n                   uid_t sandbox_gid,\n                   uid_t parent_gid,\n                   pid_t pid,\n                   bool  deny_groups,\n                   bool  map_root)\n{\n  cleanup_free char *uid_map = NULL;\n  cleanup_free char *gid_map = NULL;\n  cleanup_free char *dir = NULL;\n  cleanup_fd int dir_fd = -1;\n  uid_t old_fsuid = (uid_t)-1;\n\n  if (pid == -1)\n    dir = xstrdup (\"self\");\n  else\n    dir = xasprintf (\"%d\", pid);\n\n  dir_fd = openat (proc_fd, dir, O_PATH);\n  if (dir_fd < 0)\n    die_with_error (\"open /proc/%s failed\", dir);\n\n  if (map_root && parent_uid != 0 && sandbox_uid != 0)\n    uid_map = xasprintf (\"0 %d 1\\n\"\n                         \"%d %d 1\\n\", overflow_uid, sandbox_uid, parent_uid);\n  else\n    uid_map = xasprintf (\"%d %d 1\\n\", sandbox_uid, parent_uid);\n\n  if (map_root && parent_gid != 0 && sandbox_gid != 0)\n    gid_map = xasprintf (\"0 %d 1\\n\"\n                         \"%d %d 1\\n\", overflow_gid, sandbox_gid, parent_gid);\n  else\n    gid_map = xasprintf (\"%d %d 1\\n\", sandbox_gid, parent_gid);\n\n  /* We have to be root to be allowed to write to the uid map\n   * for setuid apps, so temporary set fsuid to 0 */\n  if (is_privileged)\n    old_fsuid = setfsuid (0);\n\n  if (write_file_at (dir_fd, \"uid_map\", uid_map) != 0)\n    die_with_error (\"setting up uid map\");\n\n  if (deny_groups &&\n      write_file_at (dir_fd, \"setgroups\", \"deny\\n\") != 0)\n    {\n      /* If /proc/[pid]/setgroups does not exist, assume we are\n       * running a linux kernel < 3.19, i.e. we live with the\n       * vulnerability known as CVE-2014-8989 in older kernels\n       * where setgroups does not exist.\n       */\n      if (errno != ENOENT)\n        die_with_error (\"error writing to setgroups\");\n    }\n\n  if (write_file_at (dir_fd, \"gid_map\", gid_map) != 0)\n    die_with_error (\"setting up gid map\");\n\n  if (is_privileged)\n    {\n      setfsuid (old_fsuid);\n      if ((uid_t) setfsuid (-1) != real_uid)\n        die (\"Unable to re-set fsuid\");\n    }\n}\n\nstatic void\nprivileged_op (int         privileged_op_socket,\n               uint32_t    op,\n               uint32_t    flags,\n               uint32_t    perms,\n               size_t      size_arg,\n               const char *arg1,\n               const char *arg2)\n{\n  bind_mount_result bind_result;\n  char *failing_path = NULL;\n\n  if (privileged_op_socket != -1)\n    {\n      uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n      PrivSepOp *op_buffer = (PrivSepOp *) buffer;\n      size_t buffer_size = sizeof (PrivSepOp);\n      uint32_t arg1_offset = 0, arg2_offset = 0;\n\n      /* We're unprivileged, send this request to the privileged part */\n\n      if (arg1 != NULL)\n        {\n          arg1_offset = buffer_size;\n          buffer_size += strlen (arg1) + 1;\n        }\n      if (arg2 != NULL)\n        {\n          arg2_offset = buffer_size;\n          buffer_size += strlen (arg2) + 1;\n        }\n\n      if (buffer_size >= sizeof (buffer))\n        die (\"privilege separation operation to large\");\n\n      op_buffer->op = op;\n      op_buffer->flags = flags;\n      op_buffer->perms = perms;\n      op_buffer->size_arg = size_arg;\n      op_buffer->arg1_offset = arg1_offset;\n      op_buffer->arg2_offset = arg2_offset;\n      if (arg1 != NULL)\n        strcpy ((char *) buffer + arg1_offset, arg1);\n      if (arg2 != NULL)\n        strcpy ((char *) buffer + arg2_offset, arg2);\n\n      if (TEMP_FAILURE_RETRY (write (privileged_op_socket, buffer, buffer_size)) != (ssize_t)buffer_size)\n        die (\"Can't write to privileged_op_socket\");\n\n      if (TEMP_FAILURE_RETRY (read (privileged_op_socket, buffer, 1)) != 1)\n        die (\"Can't read from privileged_op_socket\");\n\n      return;\n    }\n\n  /*\n   * This runs a privileged request for the unprivileged setup\n   * code. Note that since the setup code is unprivileged it is not as\n   * trusted, so we need to verify that all requests only affect the\n   * child namespace as set up by the privileged parts of the setup,\n   * and that all the code is very careful about handling input.\n   *\n   * This means:\n   *  * Bind mounts are safe, since we always use filesystem namespace. They\n   *     must be recursive though, as otherwise you can use a non-recursive bind\n   *     mount to access an otherwise over-mounted mountpoint.\n   *  * Mounting proc, tmpfs, mqueue, devpts in the child namespace is assumed to\n   *    be safe.\n   *  * Remounting RO (even non-recursive) is safe because it decreases privileges.\n   *  * sethostname() is safe only if we set up a UTS namespace\n   */\n  switch (op)\n    {\n    case PRIV_SEP_OP_DONE:\n      break;\n\n    case PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE:\n      bind_result = bind_mount (proc_fd, NULL, arg2, BIND_READONLY, &failing_path);\n\n      if (bind_result != BIND_MOUNT_SUCCESS)\n        die_with_bind_result (bind_result, errno, failing_path,\n                              \"Can't remount readonly on %s\", arg2);\n\n      assert (failing_path == NULL);    /* otherwise we would have died */\n      break;\n\n    case PRIV_SEP_OP_BIND_MOUNT:\n      /* We always bind directories recursively, otherwise this would let us\n         access files that are otherwise covered on the host */\n      bind_result = bind_mount (proc_fd, arg1, arg2, BIND_RECURSIVE | flags, &failing_path);\n\n      if (bind_result != BIND_MOUNT_SUCCESS)\n        die_with_bind_result (bind_result, errno, failing_path,\n                              \"Can't bind mount %s on %s\", arg1, arg2);\n\n      assert (failing_path == NULL);    /* otherwise we would have died */\n      break;\n\n    case PRIV_SEP_OP_PROC_MOUNT:\n      if (mount (\"proc\", arg1, \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL) != 0)\n        die_with_mount_error (\"Can't mount proc on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_TMPFS_MOUNT:\n      {\n        cleanup_free char *mode = NULL;\n\n        /* This check should be unnecessary since we checked this when parsing\n         * the --size option as well. However, better be safe than sorry. */\n        if (size_arg > MAX_TMPFS_BYTES)\n          die_with_error (\"Specified tmpfs size too large (%zu > %zu)\", size_arg, MAX_TMPFS_BYTES);\n\n        if (size_arg != 0)\n          mode = xasprintf (\"mode=%#o,size=%zu\", perms, size_arg);\n        else\n          mode = xasprintf (\"mode=%#o\", perms);\n\n        cleanup_free char *opt = label_mount (mode, opt_file_label);\n        if (mount (\"tmpfs\", arg1, \"tmpfs\", MS_NOSUID | MS_NODEV, opt) != 0)\n          die_with_mount_error (\"Can't mount tmpfs on %s\", arg1);\n        break;\n      }\n\n    case PRIV_SEP_OP_DEVPTS_MOUNT:\n      if (mount (\"devpts\", arg1, \"devpts\", MS_NOSUID | MS_NOEXEC,\n                 \"newinstance,ptmxmode=0666,mode=620\") != 0)\n        die_with_mount_error (\"Can't mount devpts on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_MQUEUE_MOUNT:\n      if (mount (\"mqueue\", arg1, \"mqueue\", 0, NULL) != 0)\n        die_with_mount_error (\"Can't mount mqueue on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_OVERLAY_MOUNT:\n      if (mount (\"overlay\", arg2, \"overlay\", MS_MGC_VAL, arg1) != 0)\n        {\n          /* The standard message for ELOOP, \"Too many levels of symbolic\n           * links\", is not helpful here. */\n          if (errno == ELOOP)\n            die (\"Can't make overlay mount on %s with options %s: \"\n                \"Overlay directories may not overlap\",\n                arg2, arg1);\n          die_with_mount_error (\"Can't make overlay mount on %s with options %s\",\n                                arg2, arg1);\n        }\n      break;\n\n    case PRIV_SEP_OP_SET_HOSTNAME:\n      /* This is checked at the start, but lets verify it here in case\n         something manages to send hacked priv-sep operation requests. */\n      if (!opt_unshare_uts)\n        die (\"Refusing to set hostname in original namespace\");\n      if (sethostname (arg1, strlen(arg1)) != 0)\n        die_with_error (\"Can't set hostname to %s\", arg1);\n      break;\n\n    default:\n      die (\"Unexpected privileged op %d\", op);\n    }\n}\n\n/* This is run unprivileged in the child namespace but can request\n * some privileged operations (also in the child namespace) via the\n * privileged_op_socket.\n */\nstatic void\nsetup_newroot (bool unshare_pid,\n               int  privileged_op_socket)\n{\n  SetupOp *op;\n  int tmp_overlay_idx = 0;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      cleanup_free char *source = NULL;\n      cleanup_free char *dest = NULL;\n      int source_mode = 0;\n      unsigned int i;\n\n      if (op->source &&\n          op->type != SETUP_MAKE_SYMLINK)\n        {\n          source = get_oldroot_path (op->source);\n          source_mode = get_file_mode (source);\n          if (source_mode < 0)\n            {\n              if (op->flags & ALLOW_NOTEXIST && errno == ENOENT)\n                continue; /* Ignore and move on */\n              die_with_error(\"Can't get type of source %s\", op->source);\n            }\n        }\n\n      if (op->dest &&\n          (op->flags & NO_CREATE_DEST) == 0)\n        {\n          unsigned parent_mode = 0755;\n\n          /* If we're creating a file that is inaccessible by the owning group,\n           * try to achieve least-astonishment by creating parents also\n           * inaccessible by that group. */\n          if (op->perms >= 0 &&\n              (op->perms & 0070) == 0)\n            parent_mode &= ~0050U;\n\n          /* The same, but for users other than the owner and group. */\n          if (op->perms >= 0 &&\n              (op->perms & 0007) == 0)\n            parent_mode &= ~0005U;\n\n          dest = get_newroot_path (op->dest);\n          if (mkdir_with_parents (dest, parent_mode, false) != 0)\n            die_with_error (\"Can't mkdir parents for %s\", op->dest);\n        }\n\n      switch (op->type)\n        {\n        case SETUP_RO_BIND_MOUNT:\n        case SETUP_DEV_BIND_MOUNT:\n        case SETUP_BIND_MOUNT:\n          if (source_mode == S_IFDIR)\n            {\n              if (ensure_dir (dest, 0755) != 0)\n                die_with_error (\"Can't mkdir %s\", op->dest);\n            }\n          else if (ensure_file (dest, 0444) != 0)\n            die_with_error (\"Can't create file at %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_BIND_MOUNT,\n                         (op->type == SETUP_RO_BIND_MOUNT ? BIND_READONLY : 0) |\n                         (op->type == SETUP_DEV_BIND_MOUNT ? BIND_DEVICES : 0),\n                         0, 0, source, dest);\n\n          if (op->fd >= 0)\n            {\n              struct stat fd_st, mount_st;\n\n              /* When using bind-fd, there is a race condition between resolving the fd as a magic symlink\n               * and mounting it, where someone could replace what is at the symlink target. Ideally\n               * we would not even resolve the symlink and directly bind-mount from the fd, but unfortunately\n               * we can't do that, because its not permitted to bind mount a fd from another user namespace.\n               * So, we resolve, mount and then compare fstat+stat to detect the race. */\n\n              if (fstat(op->fd, &fd_st) != 0)\n                die_with_error(\"Can't stat fd %d\", op->fd);\n              if (lstat(dest, &mount_st) != 0)\n                die_with_error(\"Can't stat mount at %s\", dest);\n\n              if (fd_st.st_ino != mount_st.st_ino ||\n                  fd_st.st_dev != mount_st.st_dev)\n                die_with_error(\"Race condition binding dirfd\");\n\n              close(op->fd);\n              op->fd = -1;\n            }\n\n          break;\n\n        case SETUP_OVERLAY_MOUNT:\n        case SETUP_RO_OVERLAY_MOUNT:\n        case SETUP_TMP_OVERLAY_MOUNT:\n          {\n            StringBuilder sb = {0};\n            bool multi_src = false;\n\n            if (ensure_dir (dest, 0755) != 0)\n              die_with_error (\"Can't mkdir %s\", op->dest);\n\n            if (op->source != NULL)\n              {\n                strappend (&sb, \"upperdir=/oldroot\");\n                strappend_escape_for_mount_options (&sb, op->source);\n                strappend (&sb, \",workdir=/oldroot\");\n                op = op->next;\n                strappend_escape_for_mount_options (&sb, op->source);\n                strappend (&sb, \",\");\n              }\n            else if (op->type == SETUP_TMP_OVERLAY_MOUNT)\n              strappendf (&sb, \"upperdir=/tmp-overlay-upper-%1$d,workdir=/tmp-overlay-work-%1$d,\",\n                          tmp_overlay_idx++);\n\n            strappend (&sb, \"lowerdir=/oldroot\");\n            while (op->next != NULL && op->next->type == SETUP_OVERLAY_SRC)\n              {\n                op = op->next;\n                if (multi_src)\n                  strappend (&sb, \":/oldroot\");\n                strappend_escape_for_mount_options (&sb, op->source);\n                multi_src = true;\n              }\n\n            strappend (&sb, \",userxattr\");\n\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_OVERLAY_MOUNT, 0, 0, 0, sb.str, dest);\n            free (sb.str);\n          }\n          break;\n\n        case SETUP_REMOUNT_RO_NO_RECURSIVE:\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE, 0, 0, 0, NULL, dest);\n          break;\n\n        case SETUP_MOUNT_PROC:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          if (unshare_pid || opt_pidns_fd != -1)\n            {\n              /* Our own procfs */\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_PROC_MOUNT, 0, 0, 0,\n                             dest, NULL);\n            }\n          else\n            {\n              /* Use system procfs, as we share pid namespace anyway */\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, 0, 0, 0,\n                             \"oldroot/proc\", dest);\n            }\n\n          /* There are a bunch of weird old subdirs of /proc that could potentially be\n             problematic (for instance /proc/sysrq-trigger lets you shut down the machine\n             if you have write access). We should not have access to these as a non-privileged\n             user, but lets cover them anyway just to make sure */\n          static const char * const cover_proc_dirs[] = { \"sys\", \"sysrq-trigger\", \"irq\", \"bus\" };\n          for (i = 0; i < N_ELEMENTS (cover_proc_dirs); i++)\n            {\n              cleanup_free char *subdir = strconcat3 (dest, \"/\", cover_proc_dirs[i]);\n              if (access (subdir, W_OK) < 0)\n                {\n                  /* The file is already read-only or doesn't exist.  */\n                  if (errno == EACCES || errno == ENOENT || errno == EROFS)\n                    continue;\n\n                  die_with_error (\"Can't access %s\", subdir);\n                }\n\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_READONLY, 0, 0,\n                             subdir, subdir);\n            }\n\n          break;\n\n        case SETUP_MOUNT_DEV:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_TMPFS_MOUNT, 0, 0755, 0,\n                         dest, NULL);\n\n          static const char *const devnodes[] = { \"null\", \"zero\", \"full\", \"random\", \"urandom\", \"tty\" };\n          for (i = 0; i < N_ELEMENTS (devnodes); i++)\n            {\n              cleanup_free char *node_dest = strconcat3 (dest, \"/\", devnodes[i]);\n              cleanup_free char *node_src = strconcat (\"/oldroot/dev/\", devnodes[i]);\n              if (create_file (node_dest, 0444, NULL) != 0)\n                die_with_error (\"Can't create file %s/%s\", op->dest, devnodes[i]);\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_DEVICES, 0, 0,\n                             node_src, node_dest);\n            }\n\n          static const char *const stdionodes[] = { \"stdin\", \"stdout\", \"stderr\" };\n          for (i = 0; i < N_ELEMENTS (stdionodes); i++)\n            {\n              cleanup_free char *target = xasprintf (\"/proc/self/fd/%d\", i);\n              cleanup_free char *node_dest = strconcat3 (dest, \"/\", stdionodes[i]);\n              if (symlink (target, node_dest) < 0)\n                die_with_error (\"Can't create symlink %s/%s\", op->dest, stdionodes[i]);\n            }\n\n          /* /dev/fd and /dev/core - legacy, but both nspawn and docker do these */\n          { cleanup_free char *dev_fd = strconcat (dest, \"/fd\");\n            if (symlink (\"/proc/self/fd\", dev_fd) < 0)\n              die_with_error (\"Can't create symlink %s\", dev_fd);\n          }\n          { cleanup_free char *dev_core = strconcat (dest, \"/core\");\n            if (symlink (\"/proc/kcore\", dev_core) < 0)\n              die_with_error (\"Can't create symlink %s\", dev_core);\n          }\n\n          {\n            cleanup_free char *pts = strconcat (dest, \"/pts\");\n            cleanup_free char *ptmx = strconcat (dest, \"/ptmx\");\n            cleanup_free char *shm = strconcat (dest, \"/shm\");\n\n            if (mkdir (shm, 0755) == -1)\n              die_with_error (\"Can't create %s/shm\", op->dest);\n\n            if (mkdir (pts, 0755) == -1)\n              die_with_error (\"Can't create %s/devpts\", op->dest);\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_DEVPTS_MOUNT, 0, 0, 0, pts, NULL);\n\n            if (symlink (\"pts/ptmx\", ptmx) != 0)\n              die_with_error (\"Can't make symlink at %s/ptmx\", op->dest);\n          }\n\n          /* If stdout is a tty, that means the sandbox can write to the\n             outside-sandbox tty. In that case we also create a /dev/console\n             that points to this tty device. This should not cause any more\n             access than we already have, and it makes ttyname() work in the\n             sandbox. */\n          if (host_tty_dev != NULL && *host_tty_dev != 0)\n            {\n              cleanup_free char *src_tty_dev = strconcat (\"/oldroot\", host_tty_dev);\n              cleanup_free char *dest_console = strconcat (dest, \"/console\");\n\n              if (create_file (dest_console, 0444, NULL) != 0)\n                die_with_error (\"creating %s/console\", op->dest);\n\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_DEVICES, 0, 0,\n                             src_tty_dev, dest_console);\n            }\n\n          break;\n\n        case SETUP_MOUNT_TMPFS:\n          assert (dest != NULL);\n          assert (op->perms >= 0);\n          assert (op->perms <= 07777);\n\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_TMPFS_MOUNT, 0, op->perms, op->size,\n                         dest, NULL);\n          break;\n\n        case SETUP_MOUNT_MQUEUE:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_MQUEUE_MOUNT, 0, 0, 0,\n                         dest, NULL);\n          break;\n\n        case SETUP_MAKE_DIR:\n          assert (dest != NULL);\n          assert (op->perms >= 0);\n          assert (op->perms <= 07777);\n\n          if (ensure_dir (dest, op->perms) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          break;\n\n        case SETUP_CHMOD:\n          assert (op->dest != NULL);\n          /* We used NO_CREATE_DEST so we have to use get_newroot_path()\n           * explicitly */\n          assert (dest == NULL);\n          dest = get_newroot_path (op->dest);\n          assert (dest != NULL);\n          assert (op->perms >= 0);\n          assert (op->perms <= 07777);\n\n          if (chmod (dest, op->perms) != 0)\n            die_with_error (\"Can't chmod %#o %s\", op->perms, op->dest);\n\n          break;\n\n        case SETUP_MAKE_FILE:\n          {\n            cleanup_fd int dest_fd = -1;\n\n            assert (dest != NULL);\n            assert (op->perms >= 0);\n            assert (op->perms <= 07777);\n\n            dest_fd = creat (dest, op->perms);\n            if (dest_fd == -1)\n              die_with_error (\"Can't create file %s\", op->dest);\n\n            if (copy_file_data (op->fd, dest_fd) != 0)\n              die_with_error (\"Can't write data to file %s\", op->dest);\n\n            close (op->fd);\n            op->fd = -1;\n          }\n          break;\n\n        case SETUP_MAKE_BIND_FILE:\n        case SETUP_MAKE_RO_BIND_FILE:\n          {\n            cleanup_fd int dest_fd = -1;\n            char tempfile[] = \"/bindfileXXXXXX\";\n\n            assert (dest != NULL);\n            assert (op->perms >= 0);\n            assert (op->perms <= 07777);\n\n            dest_fd = mkstemp (tempfile);\n            if (dest_fd == -1)\n              die_with_error (\"Can't create tmpfile for %s\", op->dest);\n\n            if (fchmod (dest_fd, op->perms) != 0)\n              die_with_error (\"Can't set mode %#o on file to be used for %s\",\n                              op->perms, op->dest);\n\n            if (copy_file_data (op->fd, dest_fd) != 0)\n              die_with_error (\"Can't write data to file %s\", op->dest);\n\n            close (op->fd);\n            op->fd = -1;\n\n            assert (dest != NULL);\n\n            if (ensure_file (dest, 0444) != 0)\n              die_with_error (\"Can't create file at %s\", op->dest);\n\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_BIND_MOUNT,\n                           (op->type == SETUP_MAKE_RO_BIND_FILE ? BIND_READONLY : 0),\n                           0, 0, tempfile, dest);\n\n            /* Remove the file so we're sure the app can't get to it in any other way.\n               Its outside the container chroot, so it shouldn't be possible, but lets\n               make it really sure. */\n            unlink (tempfile);\n          }\n          break;\n\n        case SETUP_MAKE_SYMLINK:\n          assert (op->source != NULL);  /* guaranteed by the constructor */\n          if (symlink (op->source, dest) != 0)\n            {\n              if (errno == EEXIST)\n                {\n                  cleanup_free char *existing = readlink_malloc (dest);\n                  if (existing == NULL)\n                    {\n                      if (errno == EINVAL)\n                        die (\"Can't make symlink at %s: destination exists and is not a symlink\", op->dest);\n                      else\n                        die_with_error (\"Can't make symlink at %s: destination exists, and cannot read symlink target\", op->dest);\n                    }\n\n                  if (strcmp (existing, op->source) == 0)\n                    break;\n\n                  die (\"Can't make symlink at %s: existing destination is %s\", op->dest, existing);\n                }\n              die_with_error (\"Can't make symlink at %s\", op->dest);\n            }\n          break;\n\n        case SETUP_SET_HOSTNAME:\n          assert (op->dest != NULL);  /* guaranteed by the constructor */\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_SET_HOSTNAME, 0, 0, 0,\n                         op->dest, NULL);\n          break;\n\n        case SETUP_OVERLAY_SRC:  /* handled by SETUP_OVERLAY_MOUNT */\n        default:\n          die (\"Unexpected type %d\", op->type);\n        }\n    }\n  privileged_op (privileged_op_socket,\n                 PRIV_SEP_OP_DONE, 0, 0, 0, NULL, NULL);\n}\n\n/* Do not leak file descriptors already used by setup_newroot () */\nstatic void\nclose_ops_fd (void)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      if (op->fd != -1)\n        {\n          (void) close (op->fd);\n          op->fd = -1;\n        }\n    }\n}\n\n/* We need to resolve relative symlinks in the sandbox before we\n   chroot so that absolute symlinks are handled correctly. We also\n   need to do this after we've switched to the real uid so that\n   e.g. paths on fuse mounts work */\nstatic void\nresolve_symlinks_in_ops (void)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      const char *old_source;\n\n      switch (op->type)\n        {\n        case SETUP_RO_BIND_MOUNT:\n        case SETUP_DEV_BIND_MOUNT:\n        case SETUP_BIND_MOUNT:\n        case SETUP_OVERLAY_SRC:\n        case SETUP_OVERLAY_MOUNT:\n          old_source = op->source;\n          op->source = realpath (old_source, NULL);\n          if (op->source == NULL)\n            {\n              if (op->flags & ALLOW_NOTEXIST && errno == ENOENT)\n                op->source = old_source;\n              else\n                die_with_error(\"Can't find source path %s\", old_source);\n            }\n          break;\n\n        case SETUP_RO_OVERLAY_MOUNT:\n        case SETUP_TMP_OVERLAY_MOUNT:\n        case SETUP_MOUNT_PROC:\n        case SETUP_MOUNT_DEV:\n        case SETUP_MOUNT_TMPFS:\n        case SETUP_MOUNT_MQUEUE:\n        case SETUP_MAKE_DIR:\n        case SETUP_MAKE_FILE:\n        case SETUP_MAKE_BIND_FILE:\n        case SETUP_MAKE_RO_BIND_FILE:\n        case SETUP_MAKE_SYMLINK:\n        case SETUP_REMOUNT_RO_NO_RECURSIVE:\n        case SETUP_SET_HOSTNAME:\n        case SETUP_CHMOD:\n        default:\n          break;\n        }\n    }\n}\n\n\nstatic const char *\nresolve_string_offset (void    *buffer,\n                       size_t   buffer_size,\n                       uint32_t offset)\n{\n  if (offset == 0)\n    return NULL;\n\n  if (offset > buffer_size)\n    die (\"Invalid string offset %d (buffer size %zd)\", offset, buffer_size);\n\n  return (const char *) buffer + offset;\n}\n\nstatic uint32_t\nread_priv_sec_op (int          read_socket,\n                  void        *buffer,\n                  size_t       buffer_size,\n                  uint32_t    *flags,\n                  uint32_t    *perms,\n                  size_t      *size_arg,\n                  const char **arg1,\n                  const char **arg2)\n{\n  const PrivSepOp *op = (const PrivSepOp *) buffer;\n  ssize_t rec_len;\n\n  do\n    rec_len = read (read_socket, buffer, buffer_size - 1);\n  while (rec_len == -1 && errno == EINTR);\n\n  if (rec_len < 0)\n    die_with_error (\"Can't read from unprivileged helper\");\n\n  if (rec_len == 0)\n    exit (1); /* Privileged helper died and printed error, so exit silently */\n\n  if ((size_t)rec_len < sizeof (PrivSepOp))\n    die (\"Invalid size %zd from unprivileged helper\", rec_len);\n\n  /* Guarantee zero termination of any strings */\n  ((char *) buffer)[rec_len] = 0;\n\n  *flags = op->flags;\n  *perms = op->perms;\n  *size_arg = op->size_arg;\n  *arg1 = resolve_string_offset (buffer, rec_len, op->arg1_offset);\n  *arg2 = resolve_string_offset (buffer, rec_len, op->arg2_offset);\n\n  return op->op;\n}\n\nstatic void __attribute__ ((noreturn))\nprint_version_and_exit (void)\n{\n  printf (\"%s\\n\", PACKAGE_STRING);\n  exit (0);\n}\n\nstatic int\nis_modifier_option (const char *option)\n{\n  return strcmp (option, \"--perms\") == 0\n         || strcmp(option, \"--size\") == 0;\n}\n\nstatic void\nwarn_only_last_option (const char *name)\n{\n  warn (\"Only the last %s option will take effect\", name);\n}\n\nstatic void\nmake_setup_overlay_src_ops (const char *const *const argv)\n{\n  /* SETUP_OVERLAY_SRC is unlike other SETUP_* ops in that it exists to hold\n   * data for SETUP_{,TMP_,RO_}OVERLAY_MOUNT ops, not to be its own operation.\n   * This lets us reuse existing code paths to handle resolving the realpaths\n   * of each source, as no other operations involve multiple sources the way\n   * the *_OVERLAY_MOUNT ops do.\n   *\n   * While the --overlay-src arguments are expected to (directly) precede the\n   * --overlay argument, in bottom-to-top order, the SETUP_OVERLAY_SRC ops\n   * follow their corresponding *_OVERLAY_MOUNT op, in top-to-bottom order\n   * (the order in which overlayfs will want them). They are handled specially\n   * in setup_new_root () during the processing of *_OVERLAY_MOUNT.\n   */\n  int i;\n  SetupOp *op;\n\n  for (i = 1; i <= next_overlay_src_count; i++)\n    {\n      op = setup_op_new (SETUP_OVERLAY_SRC);\n      op->source = argv[1 - 2 * i];\n    }\n  next_overlay_src_count = 0;\n}\n\nstatic void\nparse_args_recurse (int          *argcp,\n                    const char ***argvp,\n                    bool          in_file,\n                    int          *total_parsed_argc_p)\n{\n  SetupOp *op;\n  int argc = *argcp;\n  const char **argv = *argvp;\n  /* I can't imagine a case where someone wants more than this.\n   * If you do...you should be able to pass multiple files\n   * via a single tmpfs and linking them there, etc.\n   *\n   * We're adding this hardening due to precedent from\n   * http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html\n   *\n   * I picked 9000 because the Internet told me to and it was hard to\n   * resist.\n   */\n  static const int32_t MAX_ARGS = 9000;\n\n  if (*total_parsed_argc_p > MAX_ARGS)\n    die (\"Exceeded maximum number of arguments %u\", MAX_ARGS);\n\n  while (argc > 0)\n    {\n      const char *arg = argv[0];\n\n      if (strcmp (arg, \"--help\") == 0)\n        {\n          usage (EXIT_SUCCESS, stdout);\n        }\n      else if (strcmp (arg, \"--version\") == 0)\n        {\n          print_version_and_exit ();\n        }\n      else if (strcmp (arg, \"--args\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n          const char *p, *data_end;\n          size_t data_len;\n          cleanup_free const char **data_argv = NULL;\n          const char **data_argv_copy;\n          int data_argc;\n          int i;\n\n          if (in_file)\n            die (\"--args not supported in arguments file\");\n\n          if (argc < 2)\n            die (\"--args takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          /* opt_args_data is essentially a recursive argv array, which we must\n           * keep allocated until exit time, since its argv entries get used\n           * by the other cases in parse_args_recurse() when we recurse. */\n          opt_args_data = load_file_data (the_fd, &data_len);\n          if (opt_args_data == NULL)\n            die_with_error (\"Can't read --args data\");\n          (void) close (the_fd);\n\n          data_end = opt_args_data + data_len;\n          data_argc = 0;\n\n          p = opt_args_data;\n          while (p != NULL && p < data_end)\n            {\n              data_argc++;\n              (*total_parsed_argc_p)++;\n              if (*total_parsed_argc_p > MAX_ARGS)\n                die (\"Exceeded maximum number of arguments %u\", MAX_ARGS);\n              p = memchr (p, 0, data_end - p);\n              if (p != NULL)\n                p++;\n            }\n\n          data_argv = xcalloc (data_argc + 1, sizeof (char *));\n\n          i = 0;\n          p = opt_args_data;\n          while (p != NULL && p < data_end)\n            {\n              /* Note: load_file_data always adds a nul terminator, so this is safe\n               * even for the last string. */\n              data_argv[i++] = p;\n              p = memchr (p, 0, data_end - p);\n              if (p != NULL)\n                p++;\n            }\n\n          data_argv_copy = data_argv; /* Don't change data_argv, we need to free it */\n          parse_args_recurse (&data_argc, &data_argv_copy, true, total_parsed_argc_p);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--argv0\") == 0)\n        {\n          if (argc < 2)\n            die (\"--argv0 takes one argument\");\n\n          if (opt_argv0 != NULL)\n            die (\"--argv0 used multiple times\");\n\n          opt_argv0 = argv[1];\n          argv++;\n          argc--;\n        }\n      else if (strcmp (arg, \"--level-prefix\") == 0)\n        {\n          bwrap_level_prefix = true;\n        }\n      else if (strcmp (arg, \"--unshare-all\") == 0)\n        {\n          /* Keep this in order with the older (legacy) --unshare arguments,\n           * we use the --try variants of user and cgroup, since we want\n           * to support systems/kernels without support for those.\n           */\n          opt_unshare_user_try = opt_unshare_ipc = opt_unshare_pid =\n            opt_unshare_uts = opt_unshare_cgroup_try =\n            opt_unshare_net = true;\n        }\n      /* Begin here the older individual --unshare variants */\n      else if (strcmp (arg, \"--unshare-user\") == 0)\n        {\n          opt_unshare_user = true;\n        }\n      else if (strcmp (arg, \"--unshare-user-try\") == 0)\n        {\n          opt_unshare_user_try = true;\n        }\n      else if (strcmp (arg, \"--unshare-ipc\") == 0)\n        {\n          opt_unshare_ipc = true;\n        }\n      else if (strcmp (arg, \"--unshare-pid\") == 0)\n        {\n          opt_unshare_pid = true;\n        }\n      else if (strcmp (arg, \"--unshare-net\") == 0)\n        {\n          opt_unshare_net = true;\n        }\n      else if (strcmp (arg, \"--unshare-uts\") == 0)\n        {\n          opt_unshare_uts = true;\n        }\n      else if (strcmp (arg, \"--unshare-cgroup\") == 0)\n        {\n          opt_unshare_cgroup = true;\n        }\n      else if (strcmp (arg, \"--unshare-cgroup-try\") == 0)\n        {\n          opt_unshare_cgroup_try = true;\n        }\n      /* Begin here the newer --share variants */\n      else if (strcmp (arg, \"--share-net\") == 0)\n        {\n          opt_unshare_net = false;\n        }\n      /* End --share variants, other arguments begin */\n      else if (strcmp (arg, \"--chdir\") == 0)\n        {\n          if (argc < 2)\n            die (\"--chdir takes one argument\");\n\n          if (opt_chdir_path != NULL)\n            warn_only_last_option (\"--chdir\");\n\n          opt_chdir_path = argv[1];\n          argv++;\n          argc--;\n        }\n      else if (strcmp (arg, \"--disable-userns\") == 0)\n        {\n          opt_disable_userns = true;\n        }\n      else if (strcmp (arg, \"--assert-userns-disabled\") == 0)\n        {\n          opt_assert_userns_disabled = true;\n        }\n      else if (strcmp (arg, \"--remount-ro\") == 0)\n        {\n          if (argc < 2)\n            die (\"--remount-ro takes one argument\");\n\n          op = setup_op_new (SETUP_REMOUNT_RO_NO_RECURSIVE);\n          op->dest = argv[1];\n\n          argv++;\n          argc--;\n        }\n      else if (strcmp(arg, \"--bind\") == 0 ||\n               strcmp(arg, \"--bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp(arg, \"--ro-bind\") == 0 ||\n               strcmp(arg, \"--ro-bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_RO_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--ro-bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--dev-bind\") == 0 ||\n               strcmp (arg, \"--dev-bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_DEV_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--dev-bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--bind-fd\") == 0 ||\n               strcmp (arg, \"--ro-bind-fd\") == 0)\n        {\n          int src_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--bind-fd takes two arguments\");\n\n          src_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || src_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          if (strcmp(arg, \"--ro-bind-fd\") == 0)\n            op = setup_op_new (SETUP_RO_BIND_MOUNT);\n          else\n            op = setup_op_new (SETUP_BIND_MOUNT);\n          op->source = xasprintf (\"/proc/self/fd/%d\", src_fd);\n          op->fd = src_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--overlay-src\") == 0)\n        {\n          if (is_privileged)\n            die (\"The --overlay-src option is not permitted in setuid mode\");\n\n          next_overlay_src_count++;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--overlay\") == 0)\n        {\n          SetupOp *workdir_op;\n\n          if (is_privileged)\n            die (\"The --overlay option is not permitted in setuid mode\");\n\n          if (argc < 4)\n            die (\"--overlay takes three arguments\");\n\n          if (next_overlay_src_count < 1)\n            die (\"--overlay requires at least one --overlay-src\");\n\n          op = setup_op_new (SETUP_OVERLAY_MOUNT);\n          op->source = argv[1];\n          workdir_op = setup_op_new (SETUP_OVERLAY_SRC);\n          workdir_op->source = argv[2];\n          op->dest = argv[3];\n          make_setup_overlay_src_ops (argv);\n\n          argv += 3;\n          argc -= 3;\n        }\n      else if (strcmp (arg, \"--tmp-overlay\") == 0)\n        {\n          if (is_privileged)\n            die (\"The --tmp-overlay option is not permitted in setuid mode\");\n\n          if (argc < 2)\n            die (\"--tmp-overlay takes an argument\");\n\n          if (next_overlay_src_count < 1)\n            die (\"--tmp-overlay requires at least one --overlay-src\");\n\n          op = setup_op_new (SETUP_TMP_OVERLAY_MOUNT);\n          op->dest = argv[1];\n          make_setup_overlay_src_ops (argv);\n          opt_tmp_overlay_count++;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--ro-overlay\") == 0)\n        {\n          if (is_privileged)\n            die (\"The --ro-overlay option is not permitted in setuid mode\");\n\n          if (argc < 2)\n            die (\"--ro-overlay takes an argument\");\n\n          if (next_overlay_src_count < 2)\n            die (\"--ro-overlay requires at least two --overlay-src\");\n\n          op = setup_op_new (SETUP_RO_OVERLAY_MOUNT);\n          op->dest = argv[1];\n          make_setup_overlay_src_ops (argv);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--proc\") == 0)\n        {\n          if (argc < 2)\n            die (\"--proc takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_PROC);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--exec-label\") == 0)\n        {\n          if (argc < 2)\n            die (\"--exec-label takes an argument\");\n\n          if (opt_exec_label != NULL)\n            warn_only_last_option (\"--exec-label\");\n\n          opt_exec_label = argv[1];\n          die_unless_label_valid (opt_exec_label);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--file-label\") == 0)\n        {\n          if (argc < 2)\n            die (\"--file-label takes an argument\");\n\n          if (opt_file_label != NULL)\n            warn_only_last_option (\"--file-label\");\n\n          opt_file_label = argv[1];\n          die_unless_label_valid (opt_file_label);\n          if (label_create_file (opt_file_label))\n            die_with_error (\"--file-label setup failed\");\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--dev\") == 0)\n        {\n          if (argc < 2)\n            die (\"--dev takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_DEV);\n          op->dest = argv[1];\n          opt_needs_devpts = true;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--tmpfs\") == 0)\n        {\n          if (argc < 2)\n            die (\"--tmpfs takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_TMPFS);\n          op->dest = argv[1];\n\n          /* We historically hard-coded the mode of a tmpfs as 0755. */\n          if (next_perms >= 0)\n            op->perms = next_perms;\n          else\n            op->perms = 0755;\n\n          next_perms = -1;\n\n          /* If the option is unset, next_size_arg is zero, which results in\n           * the default tmpfs size. This is exactly what we want. */\n          op->size = next_size_arg;\n\n          next_size_arg = 0;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--mqueue\") == 0)\n        {\n          if (argc < 2)\n            die (\"--mqueue takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_MQUEUE);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--dir\") == 0)\n        {\n          if (argc < 2)\n            die (\"--dir takes an argument\");\n\n          op = setup_op_new (SETUP_MAKE_DIR);\n          op->dest = argv[1];\n\n          /* We historically hard-coded the mode of a --dir as 0755. */\n          if (next_perms >= 0)\n            op->perms = next_perms;\n          else\n            op->perms = 0755;\n\n          next_perms = -1;\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--file\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--file takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          /* We historically hard-coded the mode of a --file as 0666. */\n          if (next_perms >= 0)\n            op->perms = next_perms;\n          else\n            op->perms = 0666;\n\n          next_perms = -1;\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--bind-data\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--bind-data takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_BIND_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          /* This is consistent with previous bubblewrap behaviour:\n           * before implementing --perms, we took the permissions\n           * given to us by mkstemp(), which are documented to be 0600. */\n          if (next_perms >= 0)\n            op->perms = next_perms;\n          else\n            op->perms = 0600;\n\n          next_perms = -1;\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--ro-bind-data\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--ro-bind-data takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_RO_BIND_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          /* This is consistent with previous bubblewrap behaviour:\n           * before implementing --perms, we took the permissions\n           * given to us by mkstemp(), which are documented to be 0600. */\n          if (next_perms >= 0)\n            op->perms = next_perms;\n          else\n            op->perms = 0600;\n\n          next_perms = -1;\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--symlink\") == 0)\n        {\n          if (argc < 3)\n            die (\"--symlink takes two arguments\");\n\n          op = setup_op_new (SETUP_MAKE_SYMLINK);\n          op->source = argv[1];\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--lock-file\") == 0)\n        {\n          if (argc < 2)\n            die (\"--lock-file takes an argument\");\n\n          (void) lock_file_new (argv[1]);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--sync-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--sync-fd takes an argument\");\n\n          if (opt_sync_fd != -1)\n            warn_only_last_option (\"--sync-fd\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_sync_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--block-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--block-fd takes an argument\");\n\n          if (opt_block_fd != -1)\n            warn_only_last_option (\"--block-fd\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_block_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--userns-block-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--userns-block-fd takes an argument\");\n\n          if (opt_userns_block_fd != -1)\n            warn_only_last_option (\"--userns-block-fd\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_userns_block_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--info-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--info-fd takes an argument\");\n\n          if (opt_info_fd != -1)\n            warn_only_last_option (\"--info-fd\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_info_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--json-status-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--json-status-fd takes an argument\");\n\n          if (opt_json_status_fd != -1)\n            warn_only_last_option (\"--json-status-fd\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_json_status_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--seccomp\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--seccomp takes an argument\");\n\n          if (seccomp_programs != NULL)\n            die (\"--seccomp cannot be combined with --add-seccomp-fd\");\n\n          if (opt_seccomp_fd != -1)\n            warn_only_last_option (\"--seccomp\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_seccomp_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--add-seccomp-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--add-seccomp-fd takes an argument\");\n\n          if (opt_seccomp_fd != -1)\n            die (\"--add-seccomp-fd cannot be combined with --seccomp\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          /* takes ownership of fd */\n          seccomp_program_new (&the_fd);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--userns\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--userns takes an argument\");\n\n          if (opt_userns_fd != -1)\n            warn_only_last_option (\"--userns\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_userns_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--userns2\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--userns2 takes an argument\");\n\n          if (opt_userns2_fd != -1)\n            warn_only_last_option (\"--userns2\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_userns2_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--pidns\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--pidns takes an argument\");\n\n          if (opt_pidns_fd != -1)\n            warn_only_last_option (\"--pidns\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_pidns_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--clearenv\") == 0)\n        {\n          xclearenv ();\n        }\n      else if (strcmp (arg, \"--setenv\") == 0)\n        {\n          if (argc < 3)\n            die (\"--setenv takes two arguments\");\n\n          xsetenv (argv[1], argv[2], 1);\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--unsetenv\") == 0)\n        {\n          if (argc < 2)\n            die (\"--unsetenv takes an argument\");\n\n          xunsetenv (argv[1]);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--uid\") == 0)\n        {\n          int the_uid;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--uid takes an argument\");\n\n          if (opt_sandbox_uid != (uid_t)-1)\n            warn_only_last_option (\"--uid\");\n\n          the_uid = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_uid < 0)\n            die (\"Invalid uid: %s\", argv[1]);\n\n          opt_sandbox_uid = the_uid;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--gid\") == 0)\n        {\n          int the_gid;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--gid takes an argument\");\n\n          if (opt_sandbox_gid != (gid_t)-1)\n            warn_only_last_option (\"--gid\");\n\n          the_gid = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_gid < 0)\n            die (\"Invalid gid: %s\", argv[1]);\n\n          opt_sandbox_gid = the_gid;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--hostname\") == 0)\n        {\n          if (argc < 2)\n            die (\"--hostname takes an argument\");\n\n          if (opt_sandbox_hostname != NULL)\n            warn_only_last_option (\"--hostname\");\n\n          op = setup_op_new (SETUP_SET_HOSTNAME);\n          op->dest = argv[1];\n          op->flags = NO_CREATE_DEST;\n\n          opt_sandbox_hostname = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--new-session\") == 0)\n        {\n          opt_new_session = true;\n        }\n      else if (strcmp (arg, \"--die-with-parent\") == 0)\n        {\n          opt_die_with_parent = true;\n        }\n      else if (strcmp (arg, \"--as-pid-1\") == 0)\n        {\n          opt_as_pid_1 = true;\n        }\n      else if (strcmp (arg, \"--cap-add\") == 0)\n        {\n          cap_value_t cap;\n          if (argc < 2)\n            die (\"--cap-add takes an argument\");\n\n          opt_cap_add_or_drop_used = true;\n\n          if (strcasecmp (argv[1], \"ALL\") == 0)\n            {\n              requested_caps[0] = requested_caps[1] = 0xFFFFFFFF;\n            }\n          else\n            {\n              if (cap_from_name (argv[1], &cap) < 0)\n                die (\"unknown cap: %s\", argv[1]);\n\n              if (cap < 32)\n                requested_caps[0] |= CAP_TO_MASK_0 (cap);\n              else\n                requested_caps[1] |= CAP_TO_MASK_1 (cap - 32);\n            }\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--cap-drop\") == 0)\n        {\n          cap_value_t cap;\n          if (argc < 2)\n            die (\"--cap-drop takes an argument\");\n\n          opt_cap_add_or_drop_used = true;\n\n          if (strcasecmp (argv[1], \"ALL\") == 0)\n            {\n              requested_caps[0] = requested_caps[1] = 0;\n            }\n          else\n            {\n              if (cap_from_name (argv[1], &cap) < 0)\n                die (\"unknown cap: %s\", argv[1]);\n\n              if (cap < 32)\n                requested_caps[0] &= ~CAP_TO_MASK_0 (cap);\n              else\n                requested_caps[1] &= ~CAP_TO_MASK_1 (cap - 32);\n            }\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--perms\") == 0)\n        {\n          unsigned long perms;\n          char *endptr = NULL;\n\n          if (argc < 2)\n            die (\"--perms takes an argument\");\n\n          if (next_perms != -1)\n            die (\"--perms given twice for the same action\");\n\n          perms = strtoul (argv[1], &endptr, 8);\n\n          if (argv[1][0] == '\\0'\n              || endptr == NULL\n              || *endptr != '\\0'\n              || perms > 07777)\n            die (\"--perms takes an octal argument <= 07777\");\n\n          next_perms = (int) perms;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--size\") == 0)\n        {\n          unsigned long long size;\n          char *endptr = NULL;\n\n          if (is_privileged)\n            die (\"The --size option is not permitted in setuid mode\");\n\n          if (argc < 2)\n            die (\"--size takes an argument\");\n\n          if (next_size_arg != 0)\n            die (\"--size given twice for the same action\");\n\n          errno = 0;  /* reset errno so we can detect ERANGE from strtoull */\n\n          size = strtoull (argv[1], &endptr, 0);\n\n          /* isdigit: Not only check that the first digit is not '\\0', but\n           * simultaneously guard against negative numbers or preceding\n           * spaces. */\n          if (errno != 0  /* from strtoull */\n              || !isdigit(argv[1][0])\n              || endptr == NULL\n              || *endptr != '\\0'\n              || size == 0)\n            die (\"--size takes a non-zero number of bytes\");\n\n          if (size > MAX_TMPFS_BYTES)\n            die (\"--size (for tmpfs) is limited to %zu\", MAX_TMPFS_BYTES);\n\n          next_size_arg = (size_t) size;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--chmod\") == 0)\n        {\n          unsigned long perms;\n          char *endptr = NULL;\n\n          if (argc < 3)\n            die (\"--chmod takes two arguments\");\n\n          perms = strtoul (argv[1], &endptr, 8);\n\n          if (argv[1][0] == '\\0'\n              || endptr == NULL\n              || *endptr != '\\0'\n              || perms > 07777)\n            die (\"--chmod takes an octal argument <= 07777\");\n\n          op = setup_op_new (SETUP_CHMOD);\n          op->flags = NO_CREATE_DEST;\n          op->perms = (int) perms;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--\") == 0)\n        {\n          argv += 1;\n          argc -= 1;\n          break;\n        }\n      else if (*arg == '-')\n        {\n          die (\"Unknown option %s\", arg);\n        }\n      else\n        {\n          break;\n        }\n\n      /* If --perms was set for the current action but the current action\n       * didn't consume the setting, apparently --perms wasn't suitable for\n       * this action. */\n      if (!is_modifier_option(arg) && next_perms >= 0)\n        die (\"--perms must be followed by an option that creates a file\");\n\n      /* Similarly for --size. */\n      if (!is_modifier_option(arg) && next_size_arg != 0)\n        die (\"--size must be followed by --tmpfs\");\n\n      /* Similarly for --overlay-src. */\n      if (strcmp (arg, \"--overlay-src\") != 0 && next_overlay_src_count > 0)\n        die (\"--overlay-src must be followed by another --overlay-src or one of --overlay, --tmp-overlay, or --ro-overlay\");\n\n      argv++;\n      argc--;\n    }\n\n  *argcp = argc;\n  *argvp = argv;\n}\n\nstatic void\nparse_args (int          *argcp,\n            const char ***argvp)\n{\n  int total_parsed_argc = *argcp;\n\n  parse_args_recurse (argcp, argvp, false, &total_parsed_argc);\n\n  if (next_overlay_src_count > 0)\n    die (\"--overlay-src must be followed by another --overlay-src or one of --overlay, --tmp-overlay, or --ro-overlay\");\n}\n\nstatic void\nread_overflowids (void)\n{\n  cleanup_free char *uid_data = NULL;\n  cleanup_free char *gid_data = NULL;\n\n  uid_data = load_file_at (AT_FDCWD, \"/proc/sys/kernel/overflowuid\");\n  if (uid_data == NULL)\n    die_with_error (\"Can't read /proc/sys/kernel/overflowuid\");\n\n  overflow_uid = strtol (uid_data, NULL, 10);\n  if (overflow_uid == 0)\n    die (\"Can't parse /proc/sys/kernel/overflowuid\");\n\n  gid_data = load_file_at (AT_FDCWD, \"/proc/sys/kernel/overflowgid\");\n  if (gid_data == NULL)\n    die_with_error (\"Can't read /proc/sys/kernel/overflowgid\");\n\n  overflow_gid = strtol (gid_data, NULL, 10);\n  if (overflow_gid == 0)\n    die (\"Can't parse /proc/sys/kernel/overflowgid\");\n}\n\nstatic void\nnamespace_ids_read (pid_t  pid)\n{\n  cleanup_free char *dir = NULL;\n  cleanup_fd int ns_fd = -1;\n  NsInfo *info;\n\n  dir = xasprintf (\"%d/ns\", pid);\n  ns_fd = TEMP_FAILURE_RETRY (openat (proc_fd, dir, O_PATH));\n\n  if (ns_fd < 0)\n    die_with_error (\"open /proc/%s/ns failed\", dir);\n\n  for (info = ns_infos; info->name; info++)\n    {\n      bool *do_unshare = info->do_unshare;\n      struct stat st;\n      int r;\n\n      /* if we don't unshare this ns, ignore it */\n      if (do_unshare && *do_unshare == false)\n        continue;\n\n      r = fstatat (ns_fd, info->name, &st, 0);\n\n      /* if we can't get the information, ignore it */\n      if (r != 0)\n        continue;\n\n      info->id = st.st_ino;\n    }\n}\n\nstatic void\nnamespace_ids_write (int    fd,\n                     bool   in_json)\n{\n  NsInfo *info;\n\n  for (info = ns_infos; info->name; info++)\n    {\n      cleanup_free char *output = NULL;\n      const char *indent;\n      uintmax_t nsid;\n\n      nsid = (uintmax_t) info->id;\n\n      /* if we don't have the information, we don't write it */\n      if (nsid == 0)\n        continue;\n\n      indent = in_json ? \" \" : \"\\n    \";\n      output = xasprintf (\",%s\\\"%s-namespace\\\": %ju\",\n                          indent, info->name, nsid);\n\n      dump_info (fd, output, true);\n    }\n}\n\nint\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  const char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *args_data UNUSED = NULL;\n  int intermediate_pids_sockets[2] = {-1, -1};\n  const char *exec_path = NULL;\n  int i;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_PRIVS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc <= 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\"--cap-add in setuid mode can be used only by root\");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\"--userns-block-fd requires --unshare-user\");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\"--userns-block-fd requires --info-fd\");\n\n  if (opt_userns_fd != -1 && opt_unshare_user)\n    die (\"--userns not compatible --unshare-user\");\n\n  if (opt_userns_fd != -1 && opt_unshare_user_try)\n    die (\"--userns not compatible --unshare-user-try\");\n\n  if (opt_disable_userns && !opt_unshare_user)\n    die (\"--disable-userns requires --unshare-user\");\n\n  if (opt_disable_userns && opt_userns_block_fd != -1)\n    die (\"--disable-userns is not compatible with  --userns-block-fd\");\n\n  /* Technically using setns() is probably safe even in the privileged\n   * case, because we got passed in a file descriptor to the\n   * namespace, and that can only be gotten if you have ptrace\n   * permissions against the target, and then you could do whatever to\n   * the namespace anyway.\n   *\n   * However, for practical reasons this isn't possible to use,\n   * because (as described in acquire_privs()) setuid bwrap causes\n   * root to own the namespaces that it creates, so you will not be\n   * able to access these namespaces anyway. So, best just not support\n   * it anyway.\n   */\n  if (opt_userns_fd != -1 && is_privileged)\n    die (\"--userns doesn't work in setuid mode\");\n\n  if (opt_userns2_fd != -1 && is_privileged)\n    die (\"--userns2 doesn't work in setuid mode\");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0 && opt_userns_fd == -1)\n    opt_unshare_user = true;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0 && opt_userns_fd == -1)\n    opt_unshare_user = true;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = false;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = true;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)\n            disabled = true;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is true\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = true;\n    }\n\n  if (argc <= 0)\n    usage (EXIT_FAILURE, stderr);\n\n  debug (\"Creating root mount point\");\n\n  if (opt_sandbox_uid == (uid_t)-1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == (gid_t)-1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_userns_fd == -1 && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user or --userns\");\n\n  if (!opt_unshare_user && opt_userns_fd == -1 && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user or --userns\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\"Specifying --as-pid-1 requires --unshare-pid\");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\"Specifying --as-pid-1 and --lock-file is not permitted\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = TEMP_FAILURE_RETRY (open (\"/proc\", O_PATH));\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n   * Because we use pivot_root, it won't appear to be mounted from\n   * the perspective of the sandboxed process, so we can use anywhere\n   * that is sure to exist, that is sure to not be a symlink controlled\n   * by someone malicious, and that we won't immediately need to\n   * access ourselves. */\n  base_path = \"/tmp\";\n\n  debug (\"creating new namespace\");\n\n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid && opt_pidns_fd == -1)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    {\n      opt_unshare_cgroup = !stat (\"/proc/self/ns/cgroup\", &sbuf);\n      if (opt_unshare_cgroup)\n        clone_flags |= CLONE_NEWCGROUP;\n    }\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\"pipe2()\");\n    }\n\n  /* Switch to the custom user ns before the clone, gets us privs in that ns (assuming its a child of the current and thus allowed) */\n  if (opt_userns_fd > 0 && setns (opt_userns_fd, CLONE_NEWUSER) != 0)\n    {\n      if (errno == EINVAL)\n        die (\"Joining the specified user namespace failed, it might not be a descendant of the current user namespace.\");\n      die_with_error (\"Joining specified user namespace failed\");\n    }\n\n  /* Sometimes we have uninteresting intermediate pids during the setup, set up code to pass the real pid down */\n  if (opt_pidns_fd != -1)\n    {\n      /* Mark us as a subreaper, this way we can get exit status from grandchildren */\n      prctl (PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0);\n      create_pid_socketpair (intermediate_pids_sockets);\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      if (errno == ENOSPC)\n        die (\"Creating new namespace failed: nesting depth or /proc/sys/user/max_*_namespaces exceeded (ENOSPC)\");\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (intermediate_pids_sockets[0] != -1)\n        {\n          close (intermediate_pids_sockets[1]);\n          pid = read_pid_from_socket (intermediate_pids_sockets[0]);\n          close (intermediate_pids_sockets[0]);\n        }\n\n      /* Discover namespace ids before we drop privileges */\n      namespace_ids_read (pid);\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, true, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for pid 1 or exec:ed command to exit */\n\n      if (opt_userns2_fd > 0 && setns (opt_userns2_fd, CLONE_NEWUSER) != 0)\n        die_with_error (\"Setting userns2 failed\");\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (false, false);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\", pid);\n          dump_info (opt_info_fd, output, true);\n          namespace_ids_write (opt_info_fd, false);\n          dump_info (opt_info_fd, \"\\n}\\n\", true);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i\", pid);\n          dump_info (opt_json_status_fd, output, true);\n          namespace_ids_write (opt_json_status_fd, true);\n          dump_info (opt_json_status_fd, \" }\\n\", true);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = TEMP_FAILURE_RETRY (write (child_wait_fd, &val, 8));\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  if (opt_pidns_fd > 0)\n    {\n      if (setns (opt_pidns_fd, CLONE_NEWPID) != 0)\n        die_with_error (\"Setting pidns failed\");\n\n      /* fork to get the passed in pid ns */\n      fork_intermediate_child ();\n\n      /* We might both have specified an --pidns *and* --unshare-pid, so set up a new child pid namespace under the specified one */\n      if (opt_unshare_pid)\n        {\n          if (unshare (CLONE_NEWPID))\n            die_with_error (\"unshare pid ns\");\n\n          /* fork to get the new pid ns */\n          fork_intermediate_child ();\n        }\n\n      /* We're back, either in a child or grandchild, so message the actual pid to the monitor */\n\n      close (intermediate_pids_sockets[0]);\n      send_pid_on_socket (intermediate_pids_sockets[1]);\n      close (intermediate_pids_sockets[1]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, true, false);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SILENT | MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_mount_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_mount_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / (or\n   * over /tmp, now that we use that for base_path). */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mount (\"newroot\", \"newroot\", NULL, MS_SILENT | MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_mount_error (\"setting up newroot bind\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  for (i = 0; i < opt_tmp_overlay_count; i++)\n    {\n      char *dirname;\n      dirname = xasprintf (\"tmp-overlay-upper-%d\", i);\n      if (mkdir (dirname, 0755))\n        die_with_error (\"Creating --tmp-overlay upperdir failed\");\n      free (dirname);\n      dirname = xasprintf (\"tmp-overlay-work-%d\", i);\n      if (mkdir (dirname, 0755))\n        die_with_error (\"Creating --tmp-overlay workdir failed\");\n      free (dirname);\n    }\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (false, true);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags, perms;\n          size_t size_arg;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &perms, &size_arg, &arg1, &arg2);\n              privileged_op (-1, op, flags, perms, size_arg, arg1, arg2);\n              if (TEMP_FAILURE_RETRY (write (unpriv_socket, buffer, 1)) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          TEMP_FAILURE_RETRY (waitpid (child, &status, 0));\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_SILENT | MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_mount_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = TEMP_FAILURE_RETRY (open (\"/\", O_DIRECTORY | O_RDONLY));\n    if (oldrootfd < 0)\n      die_with_error (\"can't open /\");\n    if (chdir (\"/newroot\") != 0)\n      die_with_error (\"chdir /newroot\");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \"alternative\" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/HEAD/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/HEAD/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\".\", \".\") != 0)\n      die_with_error (\"pivot_root(/newroot)\");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\"fchdir to oldroot\");\n    if (umount2 (\".\", MNT_DETACH) < 0)\n      die_with_error (\"umount old root\");\n    if (chdir (\"/\") != 0)\n      die_with_error (\"chdir /\");\n  }\n\n  if (opt_userns2_fd > 0 && setns (opt_userns2_fd, CLONE_NEWUSER) != 0)\n    die_with_error (\"Setting userns2 failed\");\n\n  if (opt_unshare_user && opt_userns_block_fd == -1 &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ||\n       opt_disable_userns))\n    {\n      /* Here we create a second level userns inside the first one. This is\n         used for one or more of these reasons:\n\n         * The 1st level namespace has a different uid/gid than the\n           requested due to requirements of beeing root in the first\n           level due for mounting devpts (opt_needs_devpts).\n\n         * To disable user namespaces we set max_user_namespaces and then\n           create the second namespace so that the sandbox cannot undo this\n           change.\n      */\n\n      if (opt_disable_userns)\n        {\n          cleanup_fd int sysctl_fd = -1;\n\n          sysctl_fd = TEMP_FAILURE_RETRY (openat (proc_fd, \"sys/user/max_user_namespaces\", O_WRONLY));\n\n          if (sysctl_fd < 0)\n            die_with_error (\"cannot open /proc/sys/user/max_user_namespaces\");\n\n          if (write_to_fd (sysctl_fd, \"1\", 1) < 0)\n            die_with_error (\"sysctl user.max_user_namespaces = 1\");\n        }\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      /* We're in a new user namespace, we got back the bounding set, clear it again */\n      drop_cap_bounding_set (false);\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, false, false);\n    }\n\n  if (opt_disable_userns || opt_assert_userns_disabled)\n    {\n      /* Verify that we can't make a new userns again */\n      res = unshare (CLONE_NEWUSER);\n\n      if (res == 0)\n        die (\"creation of new user namespaces was not disabled as requested\");\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged, true);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      assert (seccomp_programs == NULL);\n      /* takes ownership of fd */\n      seccomp_program_new (&opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  debug (\"forking for child\");\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          drop_all_caps (false);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  debug (\"launch executable %s\", argv[0]);\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  seccomp_programs_apply ();\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  exec_path = argv[0];\n  if (opt_argv0 != NULL)\n    argv[0] = (char *) opt_argv0;\n\n  if (execvp (exec_path, argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\"execvp %s\", exec_path);\n    }\n\n  return 0;\n}\n"
        },
        {
          "name": "bubblewrap.jpg",
          "type": "blob",
          "size": 39.2958984375,
          "content": null
        },
        {
          "name": "bwrap.xml",
          "type": "blob",
          "size": 31.318359375,
          "content": "<?xml version=\"1.0\"?>\n<!DOCTYPE refentry PUBLIC \"-//OASIS//DTD DocBook XML V4.3//EN\"\n               \"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd\" [\n]>\n<refentry id=\"bwrap\">\n\n<refentryinfo>\n  <title>bwrap</title>\n  <productname>Containers</productname>\n  <authorgroup>\n    <author>\n      <contrib>Developer</contrib>\n      <firstname>Alexander</firstname>\n      <surname>Larsson</surname>\n    </author>\n    <author>\n      <contrib>Developer</contrib>\n      <firstname>Colin</firstname>\n      <surname>Walters</surname>\n    </author>\n  </authorgroup>\n</refentryinfo>\n\n<refmeta>\n  <refentrytitle>bwrap</refentrytitle>\n  <manvolnum>1</manvolnum>\n  <refmiscinfo class=\"manual\">User Commands</refmiscinfo>\n</refmeta>\n\n<refnamediv>\n  <refname>bwrap</refname>\n  <refpurpose>container setup utility</refpurpose>\n</refnamediv>\n\n<refsynopsisdiv>\n<cmdsynopsis>\n<command>bwrap</command>\n<arg choice=\"opt\" rep=\"repeat\"><replaceable>OPTION</replaceable></arg>\n<arg choice=\"opt\"><replaceable>COMMAND</replaceable></arg>\n</cmdsynopsis>\n</refsynopsisdiv>\n\n<refsect1><title>Description</title>\n<para>\n  <command>bwrap</command> is a unprivileged low-level sandboxing tool\n  (optionally setuid on older distributions). You\n  are unlikely to use it directly from the commandline, although that is possible.\n</para>\n<para>\n  It works by creating a new, completely empty, filesystem namespace where the root\n  is on a tmpfs that is invisible from the host, and which will be automatically\n  cleaned up when the last process exits. You can then use commandline options to\n  construct the root filesystem and process environment for the command to run in\n  the namespace.\n</para>\n<para>\n  By default, <command>bwrap</command> creates a new mount namespace for the sandbox.\n  Optionally it also sets up new user, ipc, pid, network and uts namespaces (but note the\n  user namespace is required if bwrap is not installed setuid root).\n  The application in the sandbox can be made to run with a different UID and GID.\n</para>\n<para>\n  If needed (e.g. when using a PID namespace) <command>bwrap</command>\n  is running a minimal pid 1 process in the sandbox that is\n  responsible for reaping zombies. It also detects when the initial\n  application process (pid 2) dies and reports its exit status back to\n  the original spawner.  The pid 1 process exits to clean up the\n  sandbox when there are no other processes in the sandbox left.\n</para>\n</refsect1>\n\n<refsect1><title>Options</title>\n  <para>\n    When options are used multiple times, the last option wins, unless otherwise\n    specified.\n  </para>\n  <para>General options:</para>\n  <variablelist>\n    <varlistentry>\n      <term><option>--help</option></term>\n      <listitem><para>Print help and exit</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--version</option></term>\n      <listitem><para>Print version</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--args <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n        Parse nul-separated arguments from the given file descriptor.\n        This option can be used multiple times to parse options from\n        multiple sources.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--argv0 <arg choice=\"plain\">VALUE</arg></option></term>\n      <listitem><para>Set argv[0] to the value <arg choice=\"plain\">VALUE</arg> before running the program</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--level-prefix</option></term>\n      <listitem>\n        <para>\n          Prefix each line of diagnostic output with a numeric severity\n          level enclosed in angle brackets.\n          The severity levels used are based on the constants used by\n          <citerefentry><refentrytitle>syslog</refentrytitle><manvolnum>3</manvolnum></citerefentry>:\n          for example, <literal>&lt;4&gt;</literal> indicates a warning,\n          because <literal>LOG_WARNING</literal> has numeric value 4.\n          Numbers smaller than 4 indicate fatal errors, and numbers larger\n          than 4 indicate informational messages.\n          These prefixes can be parsed by tools compatible with\n          <literal>logger --prio-prefix</literal> (see\n          <citerefentry><refentrytitle>logger</refentrytitle><manvolnum>1</manvolnum></citerefentry>)\n          or <literal>systemd-cat --level-prefix=1</literal> (see\n          <citerefentry><refentrytitle>systemd-cat</refentrytitle><manvolnum>1</manvolnum></citerefentry>).\n        </para>\n      </listitem>\n    </varlistentry>\n  </variablelist>\n  <para>Options related to kernel namespaces:</para>\n  <variablelist>\n    <varlistentry>\n      <term><option>--unshare-user</option></term>\n      <listitem><para>Create a new user namespace</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-user-try</option></term>\n      <listitem><para>Create a new user namespace if possible else skip it</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-ipc</option></term>\n      <listitem><para>Create a new ipc namespace</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-pid</option></term>\n      <listitem><para>Create a new pid namespace</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-net</option></term>\n      <listitem><para>Create a new network namespace</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-uts</option></term>\n      <listitem><para>Create a new uts namespace</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-cgroup</option></term>\n      <listitem><para>Create a new cgroup namespace</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-cgroup-try</option></term>\n      <listitem><para>Create a new cgroup namespace if possible else skip it</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unshare-all</option></term>\n      <listitem><para>Unshare all possible namespaces. Currently equivalent with: <option>--unshare-user-try</option> <option>--unshare-ipc</option> <option>--unshare-pid</option> <option>--unshare-net</option> <option>--unshare-uts</option> <option>--unshare-cgroup-try</option></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--share-net</option></term>\n      <listitem><para>Retain the network namespace, overriding an earlier <option>--unshare-all</option> or <option>--unshare-net</option></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--userns <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>Use an existing user namespace instead of creating a new one. The namespace must fulfil the permission requirements for setns(), which generally means that it must be a descendant of the currently active user namespace, owned by the same user. </para>\n      <para>This is incompatible with --unshare-user, and doesn't work in the setuid version of bubblewrap.</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--userns2 <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>After setting up the new namespace, switch into the specified namespace. For this to work the specified namespace must be a descendant of the user namespace used for the setup, so this is only useful in combination with --userns.</para>\n      <para>This is useful because sometimes bubblewrap itself creates nested user namespaces (to work around some kernel issues) and --userns2 can be used to enter these.</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--disable-userns</option></term>\n      <listitem><para>\n        Prevent the process in the sandbox from creating further user namespaces,\n        so that it cannot rearrange the filesystem namespace or do other more\n        complex namespace modification.\n        This is currently implemented by setting the\n        <literal>user.max_user_namespaces</literal> sysctl to 1, and then\n        entering a nested user namespace which is unable to raise that limit\n        in the outer namespace.\n        This option requires <option>--unshare-user</option>, and doesn't work\n        in the setuid version of bubblewrap.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--assert-userns-disabled</option></term>\n      <listitem><para>\n        Confirm that the process in the sandbox has been prevented from\n        creating further user namespaces, but without taking any particular\n        action to prevent that. For example, this can be combined with\n        <option>--userns</option> to check that the given user namespace\n        has already been set up to prevent the creation of further user\n        namespaces.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--pidns <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>Use an existing pid namespace instead of creating one. This is often used with --userns, because the pid namespace must be owned by the same user namespace that bwrap uses. </para>\n      <para>Note that this can be combined with --unshare-pid, and in that case it means that the sandbox will be in its own pid namespace, which is a child of the passed in one.</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--uid <arg choice=\"plain\">UID</arg></option></term>\n      <listitem><para>Use a custom user id in the sandbox (requires <option>--unshare-user</option>)</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--gid <arg choice=\"plain\">GID</arg></option></term>\n      <listitem><para>Use a custom group id in the sandbox (requires <option>--unshare-user</option>)</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--hostname <arg choice=\"plain\">HOSTNAME</arg></option></term>\n      <listitem><para>Use a custom hostname in the sandbox (requires <option>--unshare-uts</option>)</para></listitem>\n    </varlistentry>\n  </variablelist>\n  <para>Options about environment setup:</para>\n  <variablelist>\n    <varlistentry>\n      <term><option>--chdir <arg choice=\"plain\">DIR</arg></option></term>\n      <listitem><para>Change directory to <arg choice=\"plain\">DIR</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--setenv <arg choice=\"plain\">VAR</arg> <arg choice=\"plain\">VALUE</arg></option></term>\n      <listitem><para>Set an environment variable</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--unsetenv <arg choice=\"plain\">VAR</arg></option></term>\n      <listitem><para>Unset an environment variable</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--clearenv</option></term>\n      <listitem><para>Unset all environment variables, except for\n        <envar>PWD</envar> and any that are subsequently set by\n        <option>--setenv</option></para></listitem>\n    </varlistentry>\n  </variablelist>\n  <para>Options for monitoring the sandbox from the outside:</para>\n  <variablelist>\n    <varlistentry>\n      <term><option>--lock-file <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>\n        Take a lock on <arg choice=\"plain\">DEST</arg> while the sandbox is running.\n        This option can be used multiple times to take locks on multiple files.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--sync-fd <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>Keep this file descriptor open while the sandbox is running</para></listitem>\n    </varlistentry>\n  </variablelist>\n  <para>\n    Filesystem related options. These are all operations that modify the filesystem directly, or\n    mounts stuff in the filesystem. These are applied in the order they are given as arguments.\n  </para>\n  <para>\n    Any missing parent directories that are required to create a specified destination are\n    automatically created as needed. Their permissions are normally set to 0755\n    (rwxr-xr-x). However, if a <option>--perms</option> option is in effect, and\n    it sets the permissions for group or other to zero, then newly-created\n    parent directories will also have their corresponding permission set to zero.\n    <option>--size</option> modifies the size of the created mount when preceding a\n    <option>--tmpfs</option> action; <option>--perms</option> and <option>--size</option>\n    can be combined.\n  </para>\n  <variablelist>\n    <varlistentry>\n      <term><option>--perms <arg choice=\"plain\">OCTAL</arg></option></term>\n      <listitem><para>This option does nothing on its own, and must be followed\n        by one of the options that it affects. It sets the permissions\n        for the next operation to <arg choice=\"plain\">OCTAL</arg>.\n        Subsequent operations are not affected: for example,\n        <literal>--perms 0700 --tmpfs /a --tmpfs /b</literal> will mount\n        <filename>/a</filename> with permissions 0700, then return to\n        the default permissions for <filename>/b</filename>.\n        Note that <option>--perms</option> and <option>--size</option> can be\n        combined: <literal>--perms 0700 --size 10485760 --tmpfs /s</literal> will apply\n        permissions as well as a maximum size to the created tmpfs.</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--size <arg choice=\"plain\">BYTES</arg></option></term>\n      <listitem><para>This option does nothing on its own, and must be followed\n        by <literal>--tmpfs</literal>. It sets the size in bytes for the next tmpfs.\n        For example, <literal>--size 10485760 --tmpfs /tmp</literal> will create a tmpfs\n        at <filename>/tmp</filename> of size 10MiB. Subsequent operations are not\n        affected: for example,\n        <literal>--size 10485760 --tmpfs /a --tmpfs /b</literal> will mount\n        <filename>/a</filename> with size 10MiB, then return to the default size for\n        <filename>/b</filename>.\n        Note that <option>--perms</option> and <option>--size</option> can be\n        combined: <literal>--size 10485760 --perms 0700 --tmpfs /s</literal> will apply\n        permissions as well as a maximum size to the created tmpfs.</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--bind <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Bind mount the host path <arg choice=\"plain\">SRC</arg> on <arg choice=\"plain\">DEST</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--bind-try <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Equal to <option>--bind</option> but ignores non-existent <arg choice=\"plain\">SRC</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--dev-bind <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Bind mount the host path <arg choice=\"plain\">SRC</arg> on <arg choice=\"plain\">DEST</arg>, allowing device access</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--dev-bind-try <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Equal to <option>--dev-bind</option> but ignores non-existent <arg choice=\"plain\">SRC</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--ro-bind <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Bind mount the host path <arg choice=\"plain\">SRC</arg> readonly on <arg choice=\"plain\">DEST</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--ro-bind-try <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Equal to <option>--ro-bind</option> but ignores non-existent <arg choice=\"plain\">SRC</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--remount-ro <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Remount the path <arg choice=\"plain\">DEST</arg> as readonly.  It works only on the specified mount point, without changing any other mount point under the specified path</para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--overlay-src <arg choice=\"plain\">SRC</arg></option></term>\n      <listitem>\n        <para>\n          This option does nothing on its own, and must be followed by one of\n          the other <literal>overlay</literal> options. It specifies a host\n          path from which files should be read if they aren't present in a\n          higher layer.\n        </para>\n        <para>\n          This option can be used multiple times to provide multiple sources.\n          The sources are overlaid in the order given, with the first source on\n          the command line at the bottom of the stack: if a given path to be\n          read exists in more than one source, the file is read from the last\n          such source specified.\n        </para>\n        <para>\n          (For readers familiar with overlayfs, note that this is the\n          reverse of the order used by the kernel's <literal>lowerdir</literal>\n          mount option.)\n        </para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--overlay <arg choice=\"plain\">RWSRC</arg> <arg choice=\"plain\">WORKDIR</arg> <arg choice=\"plain\">DEST</arg></option></term>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--tmp-overlay <arg choice=\"plain\">DEST</arg></option></term>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--ro-overlay <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>\n          Use overlayfs to mount the host paths specified by\n          <arg choice=\"plain\">RWSRC</arg> and all immediately preceding\n          <option>--overlay-src</option> on <arg choice=\"plain\">DEST</arg>.\n          <arg choice=\"plain\">DEST</arg> will contain the union of all the files\n          in all the layers.\n        </para>\n        <para>\n          With <arg choice=\"plain\">--overlay</arg> all writes will go to\n          <arg choice=\"plain\">RWSRC</arg>. Reads will come preferentially from\n          <arg choice=\"plain\">RWSRC</arg>, and then from any\n          <option>--overlay-src</option> paths.\n          <arg choice=\"plain\">WORKDIR</arg> must be an empty directory on the\n          same filesystem as <arg choice=\"plain\">RWSRC</arg>, and is used\n          internally by the kernel.\n        </para>\n        <para>\n          With <arg choice=\"plain\">--tmp-overlay</arg> all writes will go to\n          the tmpfs that hosts the sandbox root, in a location not accessible\n          from either the host or the child process. Writes will therefore not\n          be persisted across multiple runs.\n        </para>\n        <para>\n          With <arg choice=\"plain\">--ro-overlay</arg> the filesystem will be\n          mounted read-only. This option requires at least two\n          <option>--overlay-src</option> to precede it.\n        </para>\n        <para>\n          None of these options are available in the setuid version of\n          bubblewrap. Using <arg choice=\"plain\">--ro-overlay</arg> or providing\n          more than one <option>--overlay-src</option> requires a Linux kernel\n          version of 4.0 or later.\n        </para>\n        <para>\n          Due to limitations of overlayfs, no host directory given via\n          <arg choice=\"plain\">--overlay-src</arg> or\n          <arg choice=\"plain\">--overlay</arg> may be an ancestor of another,\n          after resolving symlinks. Depending on version, the Linux kernel may\n          or may not enforce this, but if not then overlayfs's behavior is\n          undefined.\n        </para>\n        <para>\n          For more information see the Overlay Filesystem documentation in the\n          Linux kernel at\n          https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt\n        </para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--proc <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Mount procfs on <arg choice=\"plain\">DEST</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--dev <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Mount new devtmpfs on <arg choice=\"plain\">DEST</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--tmpfs <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>Mount new tmpfs on <arg choice=\"plain\">DEST</arg>.\n          If the previous option was <option>--perms</option>, it sets the\n          mode of the tmpfs. Otherwise, the tmpfs has mode 0755.\n          If the previous option was <option>--size</option>, it sets the\n          size in bytes of the tmpfs. Otherwise, the tmpfs has the default size.</para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--mqueue <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem><para>Mount new mqueue on <arg choice=\"plain\">DEST</arg></para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--dir <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>Create a directory at <arg choice=\"plain\">DEST</arg>.\n          If the directory already exists, its permissions are unmodified,\n          ignoring <option>--perms</option> (use <option>--chmod</option>\n          if the permissions of an existing directory need to be changed).\n          If the directory is newly created and the previous option was\n          <option>--perms</option>, it sets the mode of the directory.\n          Otherwise, newly-created directories have mode 0755.</para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--file <arg choice=\"plain\">FD</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>Copy from the file descriptor <arg choice=\"plain\">FD</arg> to\n          <arg choice=\"plain\">DEST</arg>.\n          If the previous option was <option>--perms</option>, it sets the\n          mode of the new file. Otherwise, the file has mode 0666\n          (note that this is not the same as <option>--bind-data</option>).</para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--bind-data <arg choice=\"plain\">FD</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>Copy from the file descriptor <arg choice=\"plain\">FD</arg> to\n          a file which is bind-mounted on <arg choice=\"plain\">DEST</arg>.\n          If the previous option was <option>--perms</option>, it sets the\n          mode of the new file. Otherwise, the file has mode 0600\n          (note that this is not the same as <option>--file</option>).</para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--ro-bind-data <arg choice=\"plain\">FD</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>Copy from the file descriptor <arg choice=\"plain\">FD</arg> to\n          a file which is bind-mounted read-only on\n          <arg choice=\"plain\">DEST</arg>.\n          If the previous option was <option>--perms</option>, it sets the\n          mode of the new file. Otherwise, the file has mode 0600\n          (note that this is not the same as <option>--file</option>).</para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--symlink <arg choice=\"plain\">SRC</arg> <arg choice=\"plain\">DEST</arg></option></term>\n      <listitem>\n        <para>Create a symlink at <arg choice=\"plain\">DEST</arg> with target\n          <arg choice=\"plain\">SRC</arg>.</para>\n        <para>Since version 0.9.0, it is not considered to be an error if\n          <arg choice=\"plain\">DEST</arg> already exists as a symbolic link and its\n          target is exactly <arg choice=\"plain\">SRC</arg>.</para>\n        <para>Before version 0.9.0, if <arg choice=\"plain\">DEST</arg> already\n          existed, this would be treated as an error (even if its target\n          was identical to <arg choice=\"plain\">SRC</arg>).</para>\n      </listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--chmod <arg choice=\"plain\">OCTAL</arg> <arg choice=\"plain\">PATH</arg></option></term>\n      <listitem>\n        <para>\n          Set the permissions of <arg choice=\"plain\">PATH</arg>, which\n          must already exist, to <arg choice=\"plain\">OCTAL</arg>.\n        </para>\n      </listitem>\n    </varlistentry>\n  </variablelist>\n  <para>Lockdown options:</para>\n  <variablelist>\n    <varlistentry>\n      <term><option>--seccomp <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n        Load and use seccomp rules from <arg choice=\"plain\">FD</arg>.\n        The rules need to be in the form of a compiled cBPF program,\n        as generated by seccomp_export_bpf.\n        If this option is given more than once, only the last one is used.\n        Use <option>--add-seccomp-fd</option> if multiple seccomp programs\n        are needed.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--add-seccomp-fd <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n        Load and use seccomp rules from <arg choice=\"plain\">FD</arg>.\n        The rules need to be in the form of a compiled cBPF program,\n        as generated by seccomp_export_bpf.\n        This option can be repeated, in which case all the seccomp\n        programs will be loaded in the order given (note that the kernel\n        will evaluate them in reverse order, so the last program on the\n        bwrap command-line is evaluated first). All of them, except\n        possibly the last, must allow use of the PR_SET_SECCOMP prctl.\n        This option cannot be combined with <option>--seccomp</option>.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--exec-label <arg choice=\"plain\">LABEL</arg></option></term>\n      <listitem><para>\n\tExec Label from the sandbox. On an SELinux system you can specify the SELinux\n\tcontext for the sandbox process(s).\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--file-label <arg choice=\"plain\">LABEL</arg></option></term>\n      <listitem><para>\n\tFile label for temporary sandbox content. On an SELinux system you can specify\n\tthe SELinux context for the sandbox content.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--block-fd <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n\tBlock the sandbox on reading from FD until some data is available.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--userns-block-fd <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n\tDo not initialize the user namespace but wait on FD until it is ready.  This allow\n        external processes (like newuidmap/newgidmap) to setup the user namespace before it\n        is used by the sandbox process.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--info-fd <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n\tWrite information in JSON format about the sandbox to FD.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--json-status-fd <arg choice=\"plain\">FD</arg></option></term>\n      <listitem><para>\n        Multiple JSON documents are written to <arg choice=\"plain\">FD</arg>,\n        one per line (<ulink url=\"https://jsonlines.org/\">\"JSON lines\" format</ulink>).\n        Each line is a single JSON object.\n        After <command>bwrap</command> has started the child process inside the sandbox,\n        it writes an object with a <literal>child-pid</literal> member to the\n        <option>--json-status-fd</option> (this duplicates the older <option>--info-fd</option>).\n        The corresponding value is the process ID of the child process in the pid namespace from\n        which <command>bwrap</command> was run.\n        If available, the namespace IDs are also included in the object with the <literal>child-pid</literal>;\n        again, this duplicates the older <option>--info-fd</option>.\n        When the child process inside the sandbox exits, <command>bwrap</command> writes an object\n        with an exit-code member, and then closes the <option>--json-status-fd</option>. The value\n        corresponding to <literal>exit-code</literal> is the exit status of the child, in the usual\n        shell encoding (n if it exited normally with status n, or 128+n if it was killed by signal n).\n        Other members may be added to those objects in future versions of <command>bwrap</command>,\n        and other JSON objects may be added before or after the current objects, so readers must\n        ignore members and objects that they do not understand.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--new-session</option></term>\n      <listitem><para>\n\tCreate a new terminal session for the sandbox (calls setsid()). This\n        disconnects the sandbox from the controlling terminal which means\n        the sandbox can't for instance inject input into the terminal.\n        </para><para>\n        Note: In a general sandbox, if you don't use --new-session, it is\n        recommended to use seccomp to disallow the TIOCSTI ioctl, otherwise\n        the application can feed keyboard input to the terminal\n        which can e.g. lead to out-of-sandbox command execution\n        (see CVE-2017-5226).\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--die-with-parent</option></term>\n      <listitem><para>\n    Ensures child process (COMMAND) dies when bwrap's parent dies. Kills (SIGKILL)\n        all bwrap sandbox processes in sequence from parent to child\n        including COMMAND process when bwrap or bwrap's parent dies.\n        See prctl, PR_SET_PDEATHSIG.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--as-pid-1</option></term>\n      <listitem><para>\n\tDo not create a process with PID=1 in the sandbox to reap child processes.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--cap-add <arg choice=\"plain\">CAP</arg></option></term>\n      <listitem><para>\n        Add the specified capability <arg choice=\"plain\">CAP</arg>, e.g.\n        CAP_DAC_READ_SEARCH, when running as privileged user.  It accepts\n        the special value ALL to add all the permitted caps.\n      </para></listitem>\n    </varlistentry>\n    <varlistentry>\n      <term><option>--cap-drop <arg choice=\"plain\">CAP</arg></option></term>\n      <listitem><para>\n        Drop the specified capability when running as privileged user.  It accepts\n        the special value ALL to drop all the caps.\n\n        By default no caps are left in the sandboxed process.  The\n        <option>--cap-add</option> and <option>--cap-drop</option>\n        options are processed in the order they are specified on the\n        command line.  Please be careful to the order they are specified.\n      </para></listitem>\n    </varlistentry>\n  </variablelist>\n</refsect1>\n\n<refsect1>\n  <title>Environment</title>\n\n  <variablelist>\n    <varlistentry>\n      <term><envar>HOME</envar></term>\n      <listitem><para>\n        Used as the cwd in the sandbox if <option>--chdir</option> has not been\n        explicitly specified and the current cwd is not present inside the sandbox.\n        The <option>--setenv</option> option can be used to override the value\n        that is used here.\n      </para></listitem>\n    </varlistentry>\n  </variablelist>\n</refsect1>\n\n<refsect1>\n  <title>Exit status</title>\n\n  <para>\n    The <command>bwrap</command> command returns the exit status of the\n    initial application process (pid 2 in the sandbox).\n  </para>\n</refsect1>\n\n</refentry>\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "completions",
          "type": "tree",
          "content": null
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 4.21875,
          "content": "project(\n  'bubblewrap',\n  'c',\n  version : '0.11.0',\n  meson_version : '>=0.49.0',\n  default_options : [\n    'warning_level=2',\n  ],\n)\n\ncc = meson.get_compiler('c')\nadd_project_arguments('-D_GNU_SOURCE', language : 'c')\ncommon_include_directories = include_directories('.')\n\n# Keep this in sync with ostree, except remove -Wall (part of Meson\n# warning_level 2) and -Werror=declaration-after-statement\nadd_project_arguments(\n  cc.get_supported_arguments([\n    '-Werror=shadow',\n    '-Werror=empty-body',\n    '-Werror=strict-prototypes',\n    '-Werror=missing-prototypes',\n    '-Werror=implicit-function-declaration',\n    '-Werror=pointer-arith',\n    '-Werror=init-self',\n    '-Werror=missing-declarations',\n    '-Werror=return-type',\n    '-Werror=overflow',\n    '-Werror=int-conversion',\n    '-Werror=parenthesis',\n    '-Werror=incompatible-pointer-types',\n    '-Werror=misleading-indentation',\n    '-Werror=missing-include-dirs',\n    '-Werror=aggregate-return',\n\n    # Extra warnings specific to bubblewrap\n    '-Werror=switch-default',\n    '-Wswitch-enum',\n\n    # Deliberately not warning about these, ability to zero-initialize\n    # a struct is a feature\n    '-Wno-missing-field-initializers',\n    '-Wno-error=missing-field-initializers',\n  ]),\n  language : 'c',\n)\n\nif (\n  cc.has_argument('-Werror=format=2')\n  and cc.has_argument('-Werror=format-security')\n  and cc.has_argument('-Werror=format-nonliteral')\n)\n  add_project_arguments([\n    '-Werror=format=2',\n    '-Werror=format-security',\n    '-Werror=format-nonliteral',\n  ], language : 'c')\nendif\n\nbash = find_program('bash', required : false)\n\nif get_option('python') == ''\n  python = find_program('python3')\nelse\n  python = find_program(get_option('python'))\nendif\n\nlibcap_dep = dependency('libcap', required : true)\n\nselinux_dep = dependency(\n  'libselinux',\n  version : '>=2.1.9',\n  # if disabled, Meson will behave as though libselinux was not found\n  required : get_option('selinux'),\n)\n\ncdata = configuration_data()\ncdata.set_quoted(\n  'PACKAGE_STRING',\n  '@0@ @1@'.format(meson.project_name(), meson.project_version()),\n)\n\nif selinux_dep.found()\n  cdata.set('HAVE_SELINUX', 1)\n  if selinux_dep.version().version_compare('>=2.3')\n    cdata.set('HAVE_SELINUX_2_3', 1)\n  endif\nendif\n\nif get_option('require_userns')\n  cdata.set('ENABLE_REQUIRE_USERNS', 1)\nendif\n\nconfigure_file(\n  output : 'config.h',\n  configuration : cdata,\n)\n\nif meson.is_subproject() and get_option('program_prefix') == ''\n  error('program_prefix option must be set when bwrap is a subproject')\nendif\n\nif get_option('bwrapdir') != ''\n  bwrapdir = get_option('bwrapdir')\nelif meson.is_subproject()\n  bwrapdir = get_option('libexecdir')\nelse\n  bwrapdir = get_option('bindir')\nendif\n\nbwrap = executable(\n  get_option('program_prefix') + 'bwrap',\n  [\n    'bubblewrap.c',\n    'bind-mount.c',\n    'network.c',\n    'utils.c',\n  ],\n  build_rpath : get_option('build_rpath'),\n  install : true,\n  install_dir : bwrapdir,\n  install_rpath : get_option('install_rpath'),\n  dependencies : [selinux_dep, libcap_dep],\n)\n\nmanpages_xsl = 'http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl'\nxsltproc = find_program('xsltproc', required : get_option('man'))\nbuild_man_page = false\n\nif xsltproc.found() and not meson.is_subproject()\n  if run_command([\n    xsltproc, '--nonet', manpages_xsl,\n  ], check : false).returncode() == 0\n    message('Docbook XSL found, man page enabled')\n    build_man_page = true\n  elif get_option('man').enabled()\n    error('Man page requested, but Docbook XSL stylesheets not found')\n  else\n    message('Docbook XSL not found, man page disabled automatically')\n  endif\nendif\n\nif build_man_page\n  custom_target(\n    'bwrap.1',\n    output : 'bwrap.1',\n    input : 'bwrap.xml',\n    command : [\n      xsltproc,\n      '--nonet',\n      '--stringparam', 'man.output.quietly', '1',\n      '--stringparam', 'funcsynopsis.style', 'ansi',\n      '--stringparam', 'man.th.extra1.suppress', '1',\n      '--stringparam', 'man.authors.section.enabled', '0',\n      '--stringparam', 'man.copyright.section.enabled', '0',\n      '-o', '@OUTPUT@',\n      manpages_xsl,\n      '@INPUT@',\n    ],\n    install : true,\n    install_dir : get_option('mandir') / 'man1',\n  )\nendif\n\nif not meson.is_subproject()\n  subdir('completions')\nendif\n\nif get_option('tests')\n  subdir('tests')\nendif\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 1.517578125,
          "content": "option(\n  'bash_completion',\n  type : 'feature',\n  description : 'install bash completion script',\n  value : 'enabled',\n)\noption(\n  'bash_completion_dir',\n  type : 'string',\n  description : 'install bash completion script in this directory',\n  value : '',\n)\noption(\n  'bwrapdir',\n  type : 'string',\n  description : 'install bwrap in this directory [default: bindir, or libexecdir in subprojects]',\n)\noption(\n  'build_rpath',\n  type : 'string',\n  description : 'set a RUNPATH or RPATH on the bwrap executable',\n)\noption(\n  'install_rpath',\n  type : 'string',\n  description : 'set a RUNPATH or RPATH on the bwrap executable',\n)\noption(\n  'man',\n  type : 'feature',\n  description : 'generate man pages',\n  value : 'auto',\n)\noption(\n  'program_prefix',\n  type : 'string',\n  description : 'Prepend string to bwrap executable name, for use with subprojects',\n)\noption(\n  'python',\n  type : 'string',\n  description : 'Path to Python 3, or empty to use python3',\n)\noption(\n  'require_userns',\n  type : 'boolean',\n  description : 'require user namespaces by default when installed setuid',\n  value : false,\n)\noption(\n  'selinux',\n  type : 'feature',\n  description : 'enable optional SELINUX support',\n  value : 'auto',\n)\noption(\n  'tests',\n  type : 'boolean',\n  description : 'build tests',\n  value : true,\n)\noption(\n  'zsh_completion',\n  type : 'feature',\n  description : 'install zsh completion script',\n  value : 'enabled',\n)\noption(\n  'zsh_completion_dir',\n  type : 'string',\n  description : 'install zsh completion script in this directory',\n  value : '',\n)\n"
        },
        {
          "name": "network.c",
          "type": "blob",
          "size": 5.3017578125,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"config.h\"\n\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <linux/loop.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n\n#include \"utils.h\"\n#include \"network.h\"\n\nstatic void *\nadd_rta (struct nlmsghdr *header,\n         int              type,\n         size_t           size)\n{\n  struct rtattr *rta;\n  size_t rta_size = RTA_LENGTH (size);\n\n  rta = (struct rtattr *) ((char *) header + NLMSG_ALIGN (header->nlmsg_len));\n  rta->rta_type = type;\n  rta->rta_len = rta_size;\n\n  header->nlmsg_len = NLMSG_ALIGN (header->nlmsg_len) + rta_size;\n\n  return RTA_DATA (rta);\n}\n\nstatic int\nrtnl_send_request (int              rtnl_fd,\n                   struct nlmsghdr *header)\n{\n  struct sockaddr_nl dst_addr = { AF_NETLINK, 0 };\n  ssize_t sent;\n\n  sent = TEMP_FAILURE_RETRY (sendto (rtnl_fd, (void *) header, header->nlmsg_len, 0,\n                                     (struct sockaddr *) &dst_addr, sizeof (dst_addr)));\n  if (sent < 0)\n    return -1;\n\n  return 0;\n}\n\nstatic int\nrtnl_read_reply (int          rtnl_fd,\n                 unsigned int seq_nr)\n{\n  char buffer[1024];\n  ssize_t received;\n  struct nlmsghdr *rheader;\n\n  while (1)\n    {\n      received = TEMP_FAILURE_RETRY (recv (rtnl_fd, buffer, sizeof (buffer), 0));\n      if (received < 0)\n        return -1;\n\n      rheader = (struct nlmsghdr *) buffer;\n      while (received >= NLMSG_HDRLEN)\n        {\n          if (rheader->nlmsg_seq != seq_nr)\n            return -1;\n          if ((pid_t)rheader->nlmsg_pid != getpid ())\n            return -1;\n          if (rheader->nlmsg_type == NLMSG_ERROR)\n            {\n              uint32_t *err = NLMSG_DATA (rheader);\n              if (*err == 0)\n                return 0;\n\n              return -1;\n            }\n          if (rheader->nlmsg_type == NLMSG_DONE)\n            return 0;\n\n          rheader = NLMSG_NEXT (rheader, received);\n        }\n    }\n}\n\nstatic int\nrtnl_do_request (int              rtnl_fd,\n                 struct nlmsghdr *header)\n{\n  if (rtnl_send_request (rtnl_fd, header) != 0)\n    return -1;\n\n  if (rtnl_read_reply (rtnl_fd, header->nlmsg_seq) != 0)\n    return -1;\n\n  return 0;\n}\n\nstatic struct nlmsghdr *\nrtnl_setup_request (char  *buffer,\n                    int    type,\n                    int    flags,\n                    size_t size)\n{\n  struct nlmsghdr *header;\n  size_t len = NLMSG_LENGTH (size);\n  static uint32_t counter = 0;\n\n  memset (buffer, 0, len);\n\n  header = (struct nlmsghdr *) buffer;\n  header->nlmsg_len = len;\n  header->nlmsg_type = type;\n  header->nlmsg_flags = flags | NLM_F_REQUEST;\n  header->nlmsg_seq = counter++;\n  header->nlmsg_pid = getpid ();\n\n  return header;\n}\n\nvoid\nloopback_setup (void)\n{\n  int r, if_loopback;\n  cleanup_fd int rtnl_fd = -1;\n  char buffer[1024];\n  struct sockaddr_nl src_addr = { AF_NETLINK, 0 };\n  struct nlmsghdr *header;\n  struct ifaddrmsg *addmsg;\n  struct ifinfomsg *infomsg;\n  struct in_addr *ip_addr;\n\n  src_addr.nl_pid = getpid ();\n\n  if_loopback = (int) if_nametoindex (\"lo\");\n  if (if_loopback <= 0)\n    die_with_error (\"loopback: Failed to look up lo\");\n\n  rtnl_fd = socket (PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);\n  if (rtnl_fd < 0)\n    die_with_error (\"loopback: Failed to create NETLINK_ROUTE socket\");\n\n  r = bind (rtnl_fd, (struct sockaddr *) &src_addr, sizeof (src_addr));\n  if (r < 0)\n    die_with_error (\"loopback: Failed to bind NETLINK_ROUTE socket\");\n\n  header = rtnl_setup_request (buffer, RTM_NEWADDR,\n                               NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,\n                               sizeof (struct ifaddrmsg));\n  addmsg = NLMSG_DATA (header);\n\n  addmsg->ifa_family = AF_INET;\n  addmsg->ifa_prefixlen = 8;\n  addmsg->ifa_flags = IFA_F_PERMANENT;\n  addmsg->ifa_scope = RT_SCOPE_HOST;\n  addmsg->ifa_index = if_loopback;\n\n  ip_addr = add_rta (header, IFA_LOCAL, sizeof (*ip_addr));\n  ip_addr->s_addr = htonl (INADDR_LOOPBACK);\n\n  ip_addr = add_rta (header, IFA_ADDRESS, sizeof (*ip_addr));\n  ip_addr->s_addr = htonl (INADDR_LOOPBACK);\n\n  assert (header->nlmsg_len < sizeof (buffer));\n\n  if (rtnl_do_request (rtnl_fd, header) != 0)\n    die_with_error (\"loopback: Failed RTM_NEWADDR\");\n\n  header = rtnl_setup_request (buffer, RTM_NEWLINK,\n                               NLM_F_ACK,\n                               sizeof (struct ifinfomsg));\n  infomsg = NLMSG_DATA (header);\n\n  infomsg->ifi_family = AF_UNSPEC;\n  infomsg->ifi_type = 0;\n  infomsg->ifi_index = if_loopback;\n  infomsg->ifi_flags = IFF_UP;\n  infomsg->ifi_change = IFF_UP;\n\n  assert (header->nlmsg_len < sizeof (buffer));\n\n  if (rtnl_do_request (rtnl_fd, header) != 0)\n    die_with_error (\"loopback: Failed RTM_NEWLINK\");\n}\n"
        },
        {
          "name": "network.h",
          "type": "blob",
          "size": 0.7998046875,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#pragma once\n\nvoid loopback_setup (void);\n"
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "release-checklist.md",
          "type": "blob",
          "size": 0.75,
          "content": "bubblewrap release checklist\n============================\n\n* Collect release notes in `NEWS`\n* Update version number in `meson.build` and release date in `NEWS`\n* Commit the changes\n* `meson dist -C ${builddir}`\n* Do any final smoke-testing, e.g. update a package, install and test it\n* `git evtag sign v$VERSION`\n    * Include the release notes from `NEWS` in the tag message\n* `git push --atomic origin main v$VERSION`\n* https://github.com/containers/bubblewrap/releases/new\n    * Fill in the new version's tag in the \"Tag version\" box\n    * Title: `$VERSION`\n    * Copy the release notes into the description\n    * Upload the tarball that you built with `meson dist`\n    * Get the `sha256sum` of the tarball and append it to the description\n    * `Publish release`\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "uncrustify.cfg",
          "type": "blob",
          "size": 4.369140625,
          "content": "newlines                lf\n\ninput_tab_size          8\noutput_tab_size         8\n\nstring_escape_char      92\nstring_escape_char2     0\n\n# indenting\nindent_columns          2\nindent_with_tabs        0\nindent_align_string     True\nindent_brace            2\nindent_braces           false\nindent_braces_no_func   True\nindent_func_call_param  false\nindent_func_def_param   false\nindent_func_proto_param false\nindent_switch_case      0\nindent_case_brace       2\nindent_paren_close      1\n\n# spacing\nsp_arith                        Add\nsp_assign                       Add\nsp_enum_assign                  Add\nsp_bool                         Add\nsp_compare                      Add\nsp_inside_paren                 Remove\nsp_inside_fparens               Remove\nsp_func_def_paren               Force\nsp_func_proto_paren             Force\nsp_paren_paren                  Remove\nsp_balance_nested_parens        False\nsp_paren_brace                  Remove\nsp_before_square                Remove\nsp_before_squares               Remove\nsp_inside_square                Remove\nsp_before_ptr_star              Add\nsp_between_ptr_star             Remove\nsp_after_comma                  Add\nsp_before_comma                 Remove\nsp_after_cast                   Add\nsp_sizeof_paren                 Add\nsp_not                          Remove\nsp_inv                          Remove\nsp_addr                         Remove\nsp_member                       Remove\nsp_deref                        Remove\nsp_sign                         Remove\nsp_incdec                       Remove\nsp_attribute_paren              remove\nsp_macro                        Force\nsp_func_call_paren              Force\nsp_func_call_user_paren         Remove\nset func_call_user _ N_ C_ g_autoptr g_auto\nsp_brace_typedef                add\nsp_cond_colon                   add\nsp_cond_question                add\nsp_defined_paren                remove\n\n# alignment\nalign_keep_tabs                 False\nalign_with_tabs                 False\nalign_on_tabstop                False\nalign_number_left               True\nalign_func_params               True\nalign_var_def_span              0\nalign_var_def_amp_style         1\nalign_var_def_colon             true\nalign_enum_equ_span             0\nalign_var_struct_span           2\nalign_var_def_star_style        2\nalign_var_def_amp_style         2\nalign_typedef_span              2\nalign_typedef_func              0\nalign_typedef_star_style        2\nalign_typedef_amp_style         2\n\n# newlines\nnl_assign_leave_one_liners      True\nnl_enum_leave_one_liners        False\nnl_func_leave_one_liners        False\nnl_if_leave_one_liners          False\nnl_end_of_file                  Add\nnl_assign_brace                 Remove\nnl_func_var_def_blk             1\nnl_fcall_brace                  Add\nnl_enum_brace                   Remove\nnl_struct_brace                 Force\nnl_union_brace                  Force\nnl_if_brace                     Force\nnl_brace_else                   Force\nnl_elseif_brace                 Force\nnl_else_brace                   Add\nnl_for_brace                    Force\nnl_while_brace                  Force\nnl_do_brace                     Force\nnl_brace_while                  Force\nnl_switch_brace                 Force\nnl_before_case                  True\nnl_after_case                   False\nnl_func_type_name               Force\nnl_func_proto_type_name         Remove\nnl_func_paren                   Remove\nnl_func_decl_start              Remove\nnl_func_decl_args               Force\nnl_func_decl_end                Remove\nnl_fdef_brace                   Force\nnl_after_return                 False\nnl_define_macro                 False\nnl_create_if_one_liner          False\nnl_create_for_one_liner         False\nnl_create_while_one_liner       False\nnl_after_semicolon              True\nnl_multi_line_cond              true\n\n# mod\n# I'd like these to be remove, but that removes brackets in if { if { foo } }, which i dislike\n# Not clear what to do about that...\nmod_full_brace_for              Remove\nmod_full_brace_if               Remove\nmod_full_brace_if_chain         True\nmod_full_brace_while            Remove\nmod_full_brace_do               Remove\nmod_full_brace_nl               3\nmod_paren_on_return             Remove\n\n# line splitting\n#code_width                     = 78\nls_for_split_full               True\nls_func_split_full              True\n\n# positioning\npos_bool                        Trail\npos_conditional                 Trail\n"
        },
        {
          "name": "uncrustify.sh",
          "type": "blob",
          "size": 0.099609375,
          "content": "#!/bin/sh\nuncrustify -c uncrustify.cfg --no-backup `git ls-tree --name-only -r HEAD | grep \\\\\\.[ch]$`\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 21.0224609375,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n#include \"config.h\"\n\n#include \"utils.h\"\n#include <limits.h>\n#include <stdint.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#ifdef HAVE_SELINUX\n#include <selinux/selinux.h>\n#endif\n\n#ifndef HAVE_SELINUX_2_3\n/* libselinux older than 2.3 weren't const-correct */\n#define setexeccon(x) setexeccon ((security_context_t) x)\n#define setfscreatecon(x) setfscreatecon ((security_context_t) x)\n#define security_check_context(x) security_check_context ((security_context_t) x)\n#endif\n\nbool bwrap_level_prefix = false;\n\n__attribute__((format(printf, 2, 0))) static void\nbwrap_logv (int severity,\n            const char *format,\n            va_list args,\n            const char *detail)\n{\n  if (bwrap_level_prefix)\n    fprintf (stderr, \"<%d>\", severity);\n\n  fprintf (stderr, \"bwrap: \");\n  vfprintf (stderr, format, args);\n\n  if (detail != NULL)\n    fprintf (stderr, \": %s\", detail);\n\n  fprintf (stderr, \"\\n\");\n}\n\nvoid\nbwrap_log (int severity,\n           const char *format, ...)\n{\n  va_list args;\n\n  va_start (args, format);\n  bwrap_logv (severity, format, args, NULL);\n  va_end (args);\n}\n\nvoid\ndie_with_error (const char *format, ...)\n{\n  va_list args;\n  int errsv;\n\n  errsv = errno;\n\n  va_start (args, format);\n  bwrap_logv (LOG_ERR, format, args, strerror (errsv));\n  va_end (args);\n\n  exit (1);\n}\n\nvoid\ndie_with_mount_error (const char *format, ...)\n{\n  va_list args;\n  int errsv;\n\n  errsv = errno;\n\n  va_start (args, format);\n  bwrap_logv (LOG_ERR, format, args, mount_strerror (errsv));\n  va_end (args);\n\n  exit (1);\n}\n\nvoid\ndie (const char *format, ...)\n{\n  va_list args;\n\n  va_start (args, format);\n  bwrap_logv (LOG_ERR, format, args, NULL);\n  va_end (args);\n\n  exit (1);\n}\n\nvoid\ndie_unless_label_valid (UNUSED const char *label)\n{\n#ifdef HAVE_SELINUX\n  if (is_selinux_enabled () == 1)\n    {\n      if (security_check_context (label) < 0)\n        die_with_error (\"invalid label %s\", label);\n      return;\n    }\n#endif\n  die (\"labeling not supported on this system\");\n}\n\nvoid\ndie_oom (void)\n{\n  fputs (\"Out of memory\\n\", stderr);\n  exit (1);\n}\n\n/* Fork, return in child, exiting the previous parent */\nvoid\nfork_intermediate_child (void)\n{\n  int pid = fork ();\n  if (pid == -1)\n    die_with_error (\"Can't fork for --pidns\");\n\n  /* Parent is an process not needed */\n  if (pid != 0)\n    exit (0);\n}\n\nvoid *\nxmalloc (size_t size)\n{\n  void *res = malloc (size);\n\n  if (res == NULL)\n    die_oom ();\n  return res;\n}\n\nvoid *\nxcalloc (size_t nmemb, size_t size)\n{\n  void *res = calloc (nmemb, size);\n\n  if (res == NULL)\n    die_oom ();\n  return res;\n}\n\nvoid *\nxrealloc (void *ptr, size_t size)\n{\n  void *res;\n\n  assert (size != 0);\n\n  res = realloc (ptr, size);\n\n  if (res == NULL)\n    die_oom ();\n  return res;\n}\n\nchar *\nxstrdup (const char *str)\n{\n  char *res;\n\n  assert (str != NULL);\n\n  res = strdup (str);\n  if (res == NULL)\n    die_oom ();\n\n  return res;\n}\n\nvoid\nstrfreev (char **str_array)\n{\n  if (str_array)\n    {\n      int i;\n\n      for (i = 0; str_array[i] != NULL; i++)\n        free (str_array[i]);\n\n      free (str_array);\n    }\n}\n\n/* Compares if str has a specific path prefix. This differs\n   from a regular prefix in two ways. First of all there may\n   be multiple slashes separating the path elements, and\n   secondly, if a prefix is matched that has to be en entire\n   path element. For instance /a/prefix matches /a/prefix/foo/bar,\n   but not /a/prefixfoo/bar. */\nbool\nhas_path_prefix (const char *str,\n                 const char *prefix)\n{\n  while (true)\n    {\n      /* Skip consecutive slashes to reach next path\n         element */\n      while (*str == '/')\n        str++;\n      while (*prefix == '/')\n        prefix++;\n\n      /* No more prefix path elements? Done! */\n      if (*prefix == 0)\n        return true;\n\n      /* Compare path element */\n      while (*prefix != 0 && *prefix != '/')\n        {\n          if (*str != *prefix)\n            return false;\n          str++;\n          prefix++;\n        }\n\n      /* Matched prefix path element,\n         must be entire str path element */\n      if (*str != '/' && *str != 0)\n        return false;\n    }\n}\n\nbool\npath_equal (const char *path1,\n            const char *path2)\n{\n  while (true)\n    {\n      /* Skip consecutive slashes to reach next path\n         element */\n      while (*path1 == '/')\n        path1++;\n      while (*path2 == '/')\n        path2++;\n\n      /* No more prefix path elements? Done! */\n      if (*path1 == 0 || *path2 == 0)\n        return *path1 == 0 && *path2 == 0;\n\n      /* Compare path element */\n      while (*path1 != 0 && *path1 != '/')\n        {\n          if (*path1 != *path2)\n            return false;\n          path1++;\n          path2++;\n        }\n\n      /* Matched path1 path element, must be entire path element */\n      if (*path2 != '/' && *path2 != 0)\n        return false;\n    }\n}\n\n\nbool\nhas_prefix (const char *str,\n            const char *prefix)\n{\n  return strncmp (str, prefix, strlen (prefix)) == 0;\n}\n\nvoid\nxclearenv (void)\n{\n  if (clearenv () != 0)\n    die_with_error (\"clearenv failed\");\n}\n\nvoid\nxsetenv (const char *name, const char *value, int overwrite)\n{\n  if (setenv (name, value, overwrite))\n    die (\"setenv failed\");\n}\n\nvoid\nxunsetenv (const char *name)\n{\n  if (unsetenv (name))\n    die (\"unsetenv failed\");\n}\n\nchar *\nstrconcat (const char *s1,\n           const char *s2)\n{\n  size_t len = 0;\n  char *res;\n\n  if (s1)\n    len += strlen (s1);\n  if (s2)\n    len += strlen (s2);\n\n  res = xmalloc (len + 1);\n  *res = 0;\n  if (s1)\n    strcat (res, s1);\n  if (s2)\n    strcat (res, s2);\n\n  return res;\n}\n\nchar *\nstrconcat3 (const char *s1,\n            const char *s2,\n            const char *s3)\n{\n  size_t len = 0;\n  char *res;\n\n  if (s1)\n    len += strlen (s1);\n  if (s2)\n    len += strlen (s2);\n  if (s3)\n    len += strlen (s3);\n\n  res = xmalloc (len + 1);\n  *res = 0;\n  if (s1)\n    strcat (res, s1);\n  if (s2)\n    strcat (res, s2);\n  if (s3)\n    strcat (res, s3);\n\n  return res;\n}\n\nchar *\nxasprintf (const char *format,\n           ...)\n{\n  char *buffer = NULL;\n  va_list args;\n\n  va_start (args, format);\n  if (vasprintf (&buffer, format, args) == -1)\n    die_oom ();\n  va_end (args);\n\n  return buffer;\n}\n\nint\nfdwalk (int proc_fd, int (*cb)(void *data,\n                               int   fd), void *data)\n{\n  int open_max;\n  int fd;\n  int dfd;\n  int res = 0;\n  DIR *d;\n\n  dfd = TEMP_FAILURE_RETRY (openat (proc_fd, \"self/fd\", O_DIRECTORY | O_RDONLY | O_NONBLOCK | O_CLOEXEC | O_NOCTTY));\n  if (dfd == -1)\n    return res;\n\n  if ((d = fdopendir (dfd)))\n    {\n      struct dirent *de;\n\n      while ((de = readdir (d)))\n        {\n          long l;\n          char *e = NULL;\n\n          if (de->d_name[0] == '.')\n            continue;\n\n          errno = 0;\n          l = strtol (de->d_name, &e, 10);\n          if (errno != 0 || !e || *e)\n            continue;\n\n          fd = (int) l;\n\n          if ((long) fd != l)\n            continue;\n\n          if (fd == dirfd (d))\n            continue;\n\n          if ((res = cb (data, fd)) != 0)\n            break;\n        }\n\n      closedir (d);\n      return res;\n    }\n\n  open_max = sysconf (_SC_OPEN_MAX);\n\n  for (fd = 0; fd < open_max; fd++)\n    if ((res = cb (data, fd)) != 0)\n      break;\n\n  return res;\n}\n\n/* Sets errno on error (!= 0), ENOSPC on short write */\nint\nwrite_to_fd (int         fd,\n             const char *content,\n             ssize_t     len)\n{\n  ssize_t res;\n\n  while (len > 0)\n    {\n      res = write (fd, content, len);\n      if (res < 0 && errno == EINTR)\n        continue;\n      if (res <= 0)\n        {\n          if (res == 0) /* Unexpected short write, should not happen when writing to a file */\n            errno = ENOSPC;\n          return -1;\n        }\n      len -= res;\n      content += res;\n    }\n\n  return 0;\n}\n\n/* Sets errno on error (!= 0), ENOSPC on short write */\nint\nwrite_file_at (int         dfd,\n               const char *path,\n               const char *content)\n{\n  int fd;\n  bool res;\n  int errsv;\n\n  fd = TEMP_FAILURE_RETRY (openat (dfd, path, O_RDWR | O_CLOEXEC, 0));\n  if (fd == -1)\n    return -1;\n\n  res = 0;\n  if (content)\n    res = write_to_fd (fd, content, strlen (content));\n\n  errsv = errno;\n  close (fd);\n  errno = errsv;\n\n  return res;\n}\n\n/* Sets errno on error (!= 0), ENOSPC on short write */\nint\ncreate_file (const char *path,\n             mode_t      mode,\n             const char *content)\n{\n  int fd;\n  int res;\n  int errsv;\n\n  fd = TEMP_FAILURE_RETRY (creat (path, mode));\n  if (fd == -1)\n    return -1;\n\n  res = 0;\n  if (content)\n    res = write_to_fd (fd, content, strlen (content));\n\n  errsv = errno;\n  close (fd);\n  errno = errsv;\n\n  return res;\n}\n\nint\nensure_file (const char *path,\n             mode_t      mode)\n{\n  struct stat buf;\n\n  /* We check this ahead of time, otherwise\n     the create file will fail in the read-only\n     case with EROFS instead of EEXIST.\n\n     We're trying to set up a mount point for a non-directory, so any\n     non-directory, non-symlink is acceptable - it doesn't necessarily\n     have to be a regular file. */\n  if (stat (path, &buf) ==  0 &&\n      !S_ISDIR (buf.st_mode) &&\n      !S_ISLNK (buf.st_mode))\n    return 0;\n\n  if (create_file (path, mode, NULL) != 0 &&  errno != EEXIST)\n    return -1;\n\n  return 0;\n}\n\n\n#define BUFSIZE 8192\n/* Sets errno on error (!= 0), ENOSPC on short write */\nint\ncopy_file_data (int sfd,\n                int dfd)\n{\n  char buffer[BUFSIZE];\n  ssize_t bytes_read;\n\n  while (true)\n    {\n      bytes_read = read (sfd, buffer, BUFSIZE);\n      if (bytes_read == -1)\n        {\n          if (errno == EINTR)\n            continue;\n\n          return -1;\n        }\n\n      if (bytes_read == 0)\n        break;\n\n      if (write_to_fd (dfd, buffer, bytes_read) != 0)\n        return -1;\n    }\n\n  return 0;\n}\n\n/* Sets errno on error (!= 0), ENOSPC on short write */\nint\ncopy_file (const char *src_path,\n           const char *dst_path,\n           mode_t      mode)\n{\n  int sfd;\n  int dfd;\n  int res;\n  int errsv;\n\n  sfd = TEMP_FAILURE_RETRY (open (src_path, O_CLOEXEC | O_RDONLY));\n  if (sfd == -1)\n    return -1;\n\n  dfd = TEMP_FAILURE_RETRY (creat (dst_path, mode));\n  if (dfd == -1)\n    {\n      errsv = errno;\n      close (sfd);\n      errno = errsv;\n      return -1;\n    }\n\n  res = copy_file_data (sfd, dfd);\n\n  errsv = errno;\n  close (sfd);\n  close (dfd);\n  errno = errsv;\n\n  return res;\n}\n\n/* Sets errno on error (== NULL),\n * Always ensures terminating zero */\nchar *\nload_file_data (int     fd,\n                size_t *size)\n{\n  cleanup_free char *data = NULL;\n  ssize_t data_read;\n  ssize_t data_len;\n  ssize_t res;\n\n  data_read = 0;\n  data_len = 4080;\n  data = xmalloc (data_len);\n\n  do\n    {\n      if (data_len == data_read + 1)\n        {\n          if (data_len > SSIZE_MAX / 2)\n            {\n              errno = EFBIG;\n              return NULL;\n            }\n\n          data_len *= 2;\n          data = xrealloc (data, data_len);\n        }\n\n      do\n        res = read (fd, data + data_read, data_len - data_read - 1);\n      while (res < 0 && errno == EINTR);\n\n      if (res < 0)\n        return NULL;\n\n      data_read += res;\n    }\n  while (res > 0);\n\n  data[data_read] = 0;\n\n  if (size)\n    *size = (size_t) data_read;\n\n  return steal_pointer (&data);\n}\n\n/* Sets errno on error (== NULL),\n * Always ensures terminating zero */\nchar *\nload_file_at (int         dfd,\n              const char *path)\n{\n  int fd;\n  char *data;\n  int errsv;\n\n  fd = TEMP_FAILURE_RETRY (openat (dfd, path, O_CLOEXEC | O_RDONLY));\n  if (fd == -1)\n    return NULL;\n\n  data = load_file_data (fd, NULL);\n\n  errsv = errno;\n  close (fd);\n  errno = errsv;\n\n  return data;\n}\n\n/* Sets errno on error (< 0) */\nint\nget_file_mode (const char *pathname)\n{\n  struct stat buf;\n\n  if (stat (pathname, &buf) !=  0)\n    return -1;\n\n  return buf.st_mode & S_IFMT;\n}\n\nint\nensure_dir (const char *path,\n            mode_t      mode)\n{\n  struct stat buf;\n\n  /* We check this ahead of time, otherwise\n     the mkdir call can fail in the read-only\n     case with EROFS instead of EEXIST on some\n     filesystems (such as NFS) */\n  if (stat (path, &buf) == 0)\n    {\n      if (!S_ISDIR (buf.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n\n      return 0;\n    }\n\n  if (mkdir (path, mode) == -1 && errno != EEXIST)\n    return -1;\n\n  return 0;\n}\n\n\n/* Sets errno on error (!= 0) */\nint\nmkdir_with_parents (const char *pathname,\n                    mode_t      mode,\n                    bool        create_last)\n{\n  cleanup_free char *fn = NULL;\n  char *p;\n\n  if (pathname == NULL || *pathname == '\\0')\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  fn = xstrdup (pathname);\n\n  p = fn;\n  while (*p == '/')\n    p++;\n\n  do\n    {\n      while (*p && *p != '/')\n        p++;\n\n      if (!*p)\n        p = NULL;\n      else\n        *p = '\\0';\n\n      if (!create_last && p == NULL)\n        break;\n\n      if (ensure_dir (fn, mode) != 0)\n        return -1;\n\n      if (p)\n        {\n          *p++ = '/';\n          while (*p && *p == '/')\n            p++;\n        }\n    }\n  while (p);\n\n  return 0;\n}\n\n/* Send an ucred with current pid/uid/gid over a socket, it can be\n   read back with read_pid_from_socket(), and then the kernel has\n   translated it between namespaces as needed. */\nvoid\nsend_pid_on_socket (int sockfd)\n{\n  char buf[1] = { 0 };\n  struct msghdr msg = {};\n  struct iovec iov = { buf, sizeof (buf) };\n  const ssize_t control_len_snd = CMSG_SPACE(sizeof(struct ucred));\n  _Alignas(struct cmsghdr) char control_buf_snd[control_len_snd];\n  struct cmsghdr *cmsg;\n  struct ucred cred;\n\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = control_buf_snd;\n  msg.msg_controllen = control_len_snd;\n\n  cmsg = CMSG_FIRSTHDR(&msg);\n  cmsg->cmsg_level = SOL_SOCKET;\n  cmsg->cmsg_type = SCM_CREDENTIALS;\n  cmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n\n  cred.pid = getpid ();\n  cred.uid = geteuid ();\n  cred.gid = getegid ();\n  memcpy (CMSG_DATA (cmsg), &cred, sizeof (cred));\n\n  if (TEMP_FAILURE_RETRY (sendmsg (sockfd, &msg, 0)) < 0)\n    die_with_error (\"Can't send pid\");\n}\n\nvoid\ncreate_pid_socketpair (int sockets[2])\n{\n  int enable = 1;\n\n  if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sockets) != 0)\n    die_with_error (\"Can't create intermediate pids socket\");\n\n  if (setsockopt (sockets[0], SOL_SOCKET, SO_PASSCRED, &enable, sizeof (enable)) < 0)\n    die_with_error (\"Can't set SO_PASSCRED\");\n}\n\nint\nread_pid_from_socket (int sockfd)\n{\n  char recv_buf[1] = { 0 };\n  struct msghdr msg = {};\n  struct iovec iov = { recv_buf, sizeof (recv_buf) };\n  const ssize_t control_len_rcv = CMSG_SPACE(sizeof(struct ucred));\n  _Alignas(struct cmsghdr) char control_buf_rcv[control_len_rcv];\n  struct cmsghdr* cmsg;\n\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = control_buf_rcv;\n  msg.msg_controllen = control_len_rcv;\n\n  if (TEMP_FAILURE_RETRY (recvmsg (sockfd, &msg, 0)) < 0)\n    die_with_error (\"Can't read pid from socket\");\n\n  if (msg.msg_controllen <= 0)\n    die (\"Unexpected short read from pid socket\");\n\n  for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg))\n    {\n      const unsigned payload_len = cmsg->cmsg_len - CMSG_LEN(0);\n      if (cmsg->cmsg_level == SOL_SOCKET &&\n          cmsg->cmsg_type == SCM_CREDENTIALS &&\n          payload_len == sizeof(struct ucred))\n        {\n          struct ucred cred;\n\n          memcpy (&cred, CMSG_DATA (cmsg), sizeof (cred));\n          return cred.pid;\n        }\n    }\n  die (\"No pid returned on socket\");\n}\n\n/* Sets errno on error (== NULL),\n * Always ensures terminating zero */\nchar *\nreadlink_malloc (const char *pathname)\n{\n  size_t size = 50;\n  ssize_t n;\n  cleanup_free char *value = NULL;\n\n  do\n    {\n      if (size > SIZE_MAX / 2)\n        die (\"Symbolic link target pathname too long\");\n      size *= 2;\n      value = xrealloc (value, size);\n      n = readlink (pathname, value, size - 1);\n      if (n < 0)\n        return NULL;\n    }\n  while (size - 2 < (size_t)n);\n\n  value[n] = 0;\n  return steal_pointer (&value);\n}\n\nchar *\nget_oldroot_path (const char *path)\n{\n  while (*path == '/')\n    path++;\n  return strconcat (\"/oldroot/\", path);\n}\n\nchar *\nget_newroot_path (const char *path)\n{\n  while (*path == '/')\n    path++;\n  return strconcat (\"/newroot/\", path);\n}\n\nint\nraw_clone (unsigned long flags,\n           void         *child_stack)\n{\n#if defined(__s390__) || defined(__CRIS__)\n  /* On s390 and cris the order of the first and second arguments\n   * of the raw clone() system call is reversed. */\n  return (int) syscall (__NR_clone, child_stack, flags);\n#else\n  return (int) syscall (__NR_clone, flags, child_stack);\n#endif\n}\n\nint\npivot_root (const char * new_root, const char * put_old)\n{\n#ifdef __NR_pivot_root\n  return syscall (__NR_pivot_root, new_root, put_old);\n#else\n  errno = ENOSYS;\n  return -1;\n#endif\n}\n\nchar *\nlabel_mount (const char *opt, UNUSED const char *mount_label)\n{\n#ifdef HAVE_SELINUX\n  if (mount_label)\n    {\n      if (opt)\n        return xasprintf (\"%s,context=\\\"%s\\\"\", opt, mount_label);\n      else\n        return xasprintf (\"context=\\\"%s\\\"\", mount_label);\n    }\n#endif\n  if (opt)\n    return xstrdup (opt);\n  return NULL;\n}\n\nint\nlabel_create_file (UNUSED const char *file_label)\n{\n#ifdef HAVE_SELINUX\n  if (is_selinux_enabled () > 0 && file_label)\n    return setfscreatecon (file_label);\n#endif\n  return 0;\n}\n\nint\nlabel_exec (UNUSED const char *exec_label)\n{\n#ifdef HAVE_SELINUX\n  if (is_selinux_enabled () > 0 && exec_label)\n    return setexeccon (exec_label);\n#endif\n  return 0;\n}\n\n/*\n * Like strerror(), but specialized for a failed mount(2) call.\n */\nconst char *\nmount_strerror (int errsv)\n{\n  switch (errsv)\n    {\n      case ENOSPC:\n        /* \"No space left on device\" misleads users into thinking there\n         * is some sort of disk-space problem, but mount(2) uses that\n         * errno value to mean something more like \"limit exceeded\". */\n        return (\"Limit exceeded (ENOSPC). \"\n                \"(Hint: Check that /proc/sys/fs/mount-max is sufficient, \"\n                \"typically 100000)\");\n\n      default:\n        return strerror (errsv);\n    }\n}\n\n/*\n * Return a + b if it would not overflow.\n * Die with an \"out of memory\" error if it would.\n */\nstatic size_t\nxadd (size_t a, size_t b)\n{\n#if defined(__GNUC__) && __GNUC__ >= 5\n  size_t result;\n  if (__builtin_add_overflow (a, b, &result))\n    die_oom ();\n  return result;\n#else\n  if (a > SIZE_MAX - b)\n    die_oom ();\n\n  return a + b;\n#endif\n}\n\n/*\n * Return a * b if it would not overflow.\n * Die with an \"out of memory\" error if it would.\n */\nstatic size_t\nxmul (size_t a, size_t b)\n{\n#if defined(__GNUC__) && __GNUC__ >= 5\n  size_t result;\n  if (__builtin_mul_overflow (a, b, &result))\n    die_oom ();\n  return result;\n#else\n  if (b != 0 && a > SIZE_MAX / b)\n    die_oom ();\n\n  return a * b;\n#endif\n}\n\nvoid\nstrappend (StringBuilder *dest, const char *src)\n{\n  size_t len = strlen (src);\n  size_t new_offset = xadd (dest->offset, len);\n\n  if (new_offset >= dest->size)\n    {\n      dest->size = xmul (xadd (new_offset, 1), 2);\n      dest->str = xrealloc (dest->str, dest->size);\n    }\n\n  /* Preserves the invariant that dest->str is always null-terminated, even\n   * though the offset is positioned at the null byte for the next write.\n   */\n  strncpy (dest->str + dest->offset, src, len + 1);\n  dest->offset = new_offset;\n}\n\n__attribute__((format (printf, 2, 3)))\nvoid\nstrappendf (StringBuilder *dest, const char *fmt, ...)\n{\n  va_list args;\n  int len;\n  size_t new_offset;\n\n  va_start (args, fmt);\n  len = vsnprintf (dest->str + dest->offset, dest->size - dest->offset, fmt, args);\n  va_end (args);\n  if (len < 0)\n    die_with_error (\"vsnprintf\");\n  new_offset = xadd (dest->offset, len);\n  if (new_offset >= dest->size)\n    {\n      dest->size = xmul (xadd (new_offset, 1), 2);\n      dest->str = xrealloc (dest->str, dest->size);\n      va_start (args, fmt);\n      len = vsnprintf (dest->str + dest->offset, dest->size - dest->offset, fmt, args);\n      va_end (args);\n      if (len < 0)\n        die_with_error (\"vsnprintf\");\n    }\n\n  dest->offset = new_offset;\n}\n\nvoid\nstrappend_escape_for_mount_options (StringBuilder *dest, const char *src)\n{\n  bool unescaped = true;\n\n  for (;;)\n    {\n      if (dest->offset == dest->size)\n        {\n          dest->size = MAX (64, xmul (dest->size, 2));\n          dest->str = xrealloc (dest->str, dest->size);\n        }\n      switch (*src)\n        {\n        case '\\0':\n          dest->str[dest->offset] = '\\0';\n          return;\n\n        case '\\\\':\n        case ',':\n        case ':':\n          if (unescaped)\n            {\n              dest->str[dest->offset++] = '\\\\';\n              unescaped = false;\n              continue;\n            }\n          /* else fall through */\n\n        default:\n          dest->str[dest->offset++] = *src;\n          unescaped = true;\n          break;\n        }\n      src++;\n    }\n}\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 6.2841796875,
          "content": "/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n * SPDX-License-Identifier: LGPL-2.0-or-later\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#pragma once\n\n#include <assert.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if 0\n#define debug(...) bwrap_log (LOG_DEBUG, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define UNUSED __attribute__((__unused__))\n\n#define N_ELEMENTS(arr) (sizeof (arr) / sizeof ((arr)[0]))\n\n#ifndef TEMP_FAILURE_RETRY\n#define TEMP_FAILURE_RETRY(expression) \\\n  (__extension__                                                              \\\n    ({ long int __result;                                                     \\\n       do __result = (long int) (expression);                                 \\\n       while (__result == -1L && errno == EINTR);                             \\\n       __result; }))\n#endif\n\n#define PIPE_READ_END 0\n#define PIPE_WRITE_END 1\n\n#ifndef PR_SET_CHILD_SUBREAPER\n#define PR_SET_CHILD_SUBREAPER 36\n#endif\n\nextern bool bwrap_level_prefix;\n\nvoid  bwrap_log (int severity,\n                 const char *format,\n                 ...) __attribute__((format (printf, 2, 3)));\n#define warn(...) bwrap_log (LOG_WARNING, __VA_ARGS__)\n\nvoid  die_with_error (const char *format,\n                      ...) __attribute__((__noreturn__)) __attribute__((format (printf, 1, 2)));\nvoid  die_with_mount_error (const char *format,\n                            ...) __attribute__((__noreturn__)) __attribute__((format (printf, 1, 2)));\nvoid  die (const char *format,\n           ...) __attribute__((__noreturn__)) __attribute__((format (printf, 1, 2)));\nvoid  die_oom (void) __attribute__((__noreturn__));\nvoid  die_unless_label_valid (const char *label);\n\nvoid  fork_intermediate_child (void);\n\nvoid *xmalloc (size_t size);\nvoid *xcalloc (size_t nmemb, size_t size);\nvoid *xrealloc (void  *ptr,\n                size_t size);\nchar *xstrdup (const char *str);\nvoid  strfreev (char **str_array);\nvoid  xclearenv (void);\nvoid  xsetenv (const char *name,\n               const char *value,\n               int         overwrite);\nvoid  xunsetenv (const char *name);\nchar *strconcat (const char *s1,\n                 const char *s2);\nchar *strconcat3 (const char *s1,\n                  const char *s2,\n                  const char *s3);\nchar * xasprintf (const char *format,\n                  ...) __attribute__((format (printf, 1, 2)));\nbool  has_prefix (const char *str,\n                  const char *prefix);\nbool  has_path_prefix (const char *str,\n                       const char *prefix);\nbool  path_equal (const char *path1,\n                  const char *path2);\nint   fdwalk (int                     proc_fd,\n              int                     (*cb)(void *data,\n                                  int fd),\n              void                   *data);\nchar *load_file_data (int     fd,\n                      size_t *size);\nchar *load_file_at (int         dirfd,\n                    const char *path);\nint   write_file_at (int         dirfd,\n                     const char *path,\n                     const char *content);\nint   write_to_fd (int         fd,\n                   const char *content,\n                   ssize_t     len);\nint   copy_file_data (int sfd,\n                      int dfd);\nint   copy_file (const char *src_path,\n                 const char *dst_path,\n                 mode_t      mode);\nint   create_file (const char *path,\n                   mode_t      mode,\n                   const char *content);\nint   ensure_file (const char *path,\n                   mode_t      mode);\nint   ensure_dir (const char *path,\n                  mode_t      mode);\nint   get_file_mode (const char *pathname);\nint   mkdir_with_parents (const char *pathname,\n                          mode_t      mode,\n                          bool        create_last);\nvoid create_pid_socketpair (int sockets[2]);\nvoid send_pid_on_socket (int socket);\nint  read_pid_from_socket (int socket);\nchar *get_oldroot_path (const char *path);\nchar *get_newroot_path (const char *path);\nchar *readlink_malloc (const char *pathname);\n\n/* syscall wrappers */\nint   raw_clone (unsigned long flags,\n                 void         *child_stack);\nint   pivot_root (const char *new_root,\n                  const char *put_old);\nchar *label_mount (const char *opt,\n                   const char *mount_label);\nint   label_exec (const char *exec_label);\nint   label_create_file (const char *file_label);\n\nconst char *mount_strerror (int errsv);\n\nstatic inline void\ncleanup_freep (void *p)\n{\n  void **pp = (void **) p;\n\n  if (*pp)\n    free (*pp);\n}\n\nstatic inline void\ncleanup_strvp (void *p)\n{\n  void **pp = (void **) p;\n\n  strfreev (*pp);\n}\n\nstatic inline void\ncleanup_fdp (int *fdp)\n{\n  int fd;\n\n  assert (fdp);\n\n  fd = *fdp;\n  if (fd != -1)\n    (void) close (fd);\n}\n\n#define cleanup_free __attribute__((cleanup (cleanup_freep)))\n#define cleanup_fd __attribute__((cleanup (cleanup_fdp)))\n#define cleanup_strv __attribute__((cleanup (cleanup_strvp)))\n\nstatic inline void *\nsteal_pointer (void *pp)\n{\n  void **ptr = (void **) pp;\n  void *ref;\n\n  ref = *ptr;\n  *ptr = NULL;\n\n  return ref;\n}\n\n/* type safety */\n#define steal_pointer(pp) \\\n  (0 ? (*(pp)) : (steal_pointer) (pp))\n\ntypedef struct _StringBuilder StringBuilder;\n\nstruct _StringBuilder\n{\n  char * str;\n  size_t size;\n  size_t offset;\n};\n\nvoid strappend (StringBuilder *dest,\n                const char    *src);\nvoid strappendf (StringBuilder *dest,\n                 const char    *fmt,\n                 ...);\nvoid strappend_escape_for_mount_options (StringBuilder *dest,\n                                         const char    *src);\n"
        }
      ]
    }
  ]
}