{
  "metadata": {
    "timestamp": 1736709689278,
    "page": 58,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "karlstav/cava",
      "stars": 4429,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0908203125,
          "content": "BasedOnStyle: LLVM\n---\nLanguage: Cpp\nPointerAlignment: Right\nColumnLimit: 100\nIndentWidth: 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.224609375,
          "content": "*.so.0\n*.o\n*.a\n.deps/\n.libs/\nMakefile\nMakefile.in\naclocal.m4\nar-lib\nautom4te.cache/\ncompile\nconfig.guess\nconfig.log\nconfig.status\nconfig.sub\nconfigure\ndepcomp\ninstall-sh\nlibtool\nltmain.sh\nm4/\nmissing\nversion\nconfig_file.h\n.*\ncava\n"
        },
        {
          "name": "CAVACORE.md",
          "type": "blob",
          "size": 1.8828125,
          "content": "cavacore\n=========\n\nCore processing engine of cava.\n\n# How it works\n\ncava core works as a wrapper around [fftw](http://www.fftw.org/). While fftw does the job with the discrete Fourier transform\nwhich transforms the audio from the time domain (series of samples) to the frequency domain (series of frequencies),\nthe raw output data from fftw will not look very nice when used directly in a visualization. The cavacore engine does several things\nto improve the look of the visualization:\n\n\n## adjustable bandwith\n\nTheoretically the human ear can hear frequencies up to 20kHz, but the information above 10k is hard to separate from eachother\nand does not give much feedback by itself when visualizing audio. Similarly audio down to 20Hz can be heard, but the frequencies\nbelow 50Hz does not directly provide anything to the visualizing of the audio.\n\n\n## spread the output logarithmically\n\nThe human ear hears different frequencies logarithmically, so notes that are 2x and 4x higher than eachother, will be preceived\nas beeing a fixed amount higher than eachother. Therefore cavacore outputs the frequencies logarithmically. Cavacore will also\ngroup the output in the desired number of samples.\n\n\n## noise reduction\n\nthe raw output of fftw is very noisy, cavacore processes the output signal in two ways to provide a smooth output:\n\n  * an integral filter calculates a weighted average of the last values\n  * fall off filter, when values is lower than last value it uses a  fall down effect instead of the new value\n\nThis feature can be adjusted.\n\n\n## real-time sensitivity adjustment\n\nThe range of an input signal can vary a lot. cavacore can keep the output signal within range in real-time. This feature can be disabled.\n\n\n# Building\n\nuse the root CMakeLists.txt to build it:\n\n```\nmkdir build\ncd build\ncmake ..\ncmake --build .\n```\n\n# Usage\n\nSee cavacore.h for documentation and the cavacore_test.c application for how to use.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.0712890625,
          "content": "# This is only for the cavacore lib, see CAVACORE.md for details\n# to build cava don't use this, use the automake stuff\n\ncmake_minimum_required(VERSION 3.13.0)\nproject(cavacore)\nif (ANDROID)\n\tadd_library(cavacore SHARED cavacore.c)\n\tif (NOT DEFINED FFTW_DIR)\n\t\tmessage(FATAL_ERROR \"FFTW_DIR not set, required by android, see cavandroid/README.md\")\n\tendif()\n\tif (NOT EXISTS ${FFTW_DIR})\n\t\tmessage(FATAL_ERROR \"given FFTW_DIR: ${FFTW_DIR} does not exist\")\n\tendif()\n\tif (NOT EXISTS \"${FFTW_DIR}/jni/fftw3/api/\")\n\t\tmessage(FATAL_ERROR \"given fftw include dir: ${FFTW_DIR}/jni/fftw3/api/ does not exist\")\n\tendif()\n\tif (NOT EXISTS \"${FFTW_DIR}/obj/local/${CMAKE_ANDROID_ARCH_ABI}/\")\n\t\tmessage(FATAL_ERROR \"given lib dir: ${FFTW_DIR}/obj/local/${CMAKE_ANDROID_ARCH_ABI}/ does not exist, did you build it? See cavandroid/README.md\")\n\tendif()\n\ttarget_include_directories(cavacore PRIVATE \"${FFTW_DIR}/jni/fftw3/api/\")\n\ttarget_link_directories(cavacore PRIVATE \"${FFTW_DIR}/obj/local/${CMAKE_ANDROID_ARCH_ABI}/\")\n\ttarget_link_libraries(cavacore fftw3)\nelse()\n\tadd_library(cavacore STATIC cavacore.c)\nendif()"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.7509765625,
          "content": "# How to contribute\nThank you for wanting to contribute to this project. In order to get the development of this project to run as smooth as possible, we will encourage all contributions to follw this simple process:\n\n1. Before any pull request is submitted a github issue must be created for the task.\n2. The new github task is to be opened for suggestions from other contributors.\n3. A pull request is published.\n4. Contributors code review pull request and approve/reject pull request.\n5. Pull request either gets approved or rejected.\n5. Github task is updated and everyone is notified.\n\n# Coding conventions\n* 4 spaces for indents\n* curly braces on same line as if, while, for statements\n\nGenerally please try to keep the style consistent with the code as it is. \n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "Copyright (c) 2015 Karl Stavestrand <karl@stavestrand.no>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 2.15625,
          "content": "AUTOMAKE_OPTIONS = foreign\n\nACLOCAL_AMFLAGS = -I m4\n\nbin_PROGRAMS = cava\ncavadir = $(top_srcdir)\ncava_SOURCES = cava.c cavacore.c config.c input/common.c input/fifo.c input/shmem.c \\\n               output/terminal_noncurses.c output/raw.c output/noritake.c \\\n               cavacore.h config.h input/common.h input/fifo.h input/shmem.h \\\n               output/terminal_noncurses.h output/raw.h output/noritake.h \\\n               debug.h util.h third_party/incbin.h\ncava_CPPFLAGS = -DPACKAGE=\\\"$(PACKAGE)\\\" -DVERSION=\\\"$(VERSION)\\\" \\\n           -D_POSIX_SOURCE -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE_EXTENDED \\\n\t   -DFONTDIR=\\\"@FONT_DIR@\\\" -DFONTFILE=\\\"@FONT_FILE@\\\"\ncava_CFLAGS = -std=c99 -Wall -Wextra -Wno-unused-result -Wno-unknown-warning-option -Wno-maybe-uninitialized -Wno-vla-parameter\n\nEXTRA_DIST = \\\n    output/shaders/pass_through.vert \\\n    output/shaders/bar_spectrum.frag \\\n    output/shaders/northern_lights.frag \\\n    example_files/config \\\n    cava.psf \\\n    LICENSE \\\n    run_all_tests.sh \\\n    SHADERS.md \\\n    .clang-format\n\nif OSX\n    cava_CFLAGS += -DNORT\n    cava_LDADD =\nelse\n    cava_LDADD = -lrt\n    cava_font_dir = @FONT_DIR@\n    cava_font__DATA = @FONT_FILE@\nendif\n\nif FREEBSD\nif CAVAFONT\n    CLEANFILES = cava.bdf cava.fnt\n\ncava.fnt: ${srcdir}/cava.psf\n\t${PSF2BDF} --fontname=\"-gnu-cava-medium-r-normal--16-160-75-75-c-80-iso10646-1\" ${srcdir}/cava.psf cava.bdf\n\t${VTFONTCVT} -o cava.fnt cava.bdf\nendif\nendif\n\nif ALSA\n    cava_SOURCES += input/alsa.c input/alsa.h\nendif\n\nif PORTAUDIO\n    cava_SOURCES += input/portaudio.c input/portaudio.h\nendif\n\nif PIPEWIRE\n    cava_SOURCES += input/pipewire.c input/pipewire.h\nendif\n\nif PULSE\n    cava_SOURCES += input/pulse.c input/pulse.h\nendif\n\nif SNDIO\n    cava_SOURCES += input/sndio.c input/sndio.h\nendif\n\nif OSS\n    cava_SOURCES += input/oss.c input/oss.h\nendif\n\nif JACK\n    cava_SOURCES += input/jack.c input/jack.h\nendif\n\nif NCURSES\n    cava_SOURCES += output/terminal_ncurses.c output/terminal_bcircle.c \\\n                    output/terminal_ncurses.h output/terminal_bcircle.h\n\nendif\n\nif SDL\n    cava_SOURCES += output/sdl_cava.c output/sdl_cava.h\nendif\n\nif SDL_GLSL\n    cava_SOURCES += output/sdl_glsl.c output/sdl_glsl.h\nendif\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.6416015625,
          "content": "CAVA [![Build Status](https://github.com/karlstav/cava/workflows/build-and-test/badge.svg)](https://github.com/karlstav/cava/actions)\n====================\n\n**C**ross-platform **A**udio **V**isu**a**lizer\n\nby [Karl Stavestrand](mailto:karl@stavestrand.no)\n\n<a href='https://play.google.com/store/apps/details?id=com.karlstav.cava&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img alt='Get it on Google Play' src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png' width=\"200\"/></a>\n\n![spectrum](https://github.com/karlstav/cava/blob/master/example_files/cava.gif \"spectrum\")\n\n[Demo video](https://youtu.be/9PSp8VA6yjU)\n\n- [What it is](#what-it-is)\n- [Installing](#installing)\n  - [From Source](#from-source)\n  - [Package managers](#package-managers)\n- [Capturing audio](#capturing-audio)\n  - [Pulseaudio](#pulseaudio)\n  - [Pipewire](#pipewire)\n  - [ALSA](#alsa)\n  - [MPD](#mpd)\n  - [Sndio](#sndio)\n  - [OSS](#oss)\n  - [JACK](#jack)\n  - [squeezelite](#squeezelite)\n  - [macOS](#macos-1)\n  - [Windows](#windows)\n- [Running via ssh](#running-via-ssh)\n- [Troubleshooting](#troubleshooting)\n- [Usage](#usage)\n  - [Controls](#controls)\n- [Configuration](#configuration)\n- [Using cava in other applications](#using-cava-in-other-applications)\n  - [cavacore](#cavacore-library)\n  - [Raw Output](#raw-output)\n- [Contribution](#contribution)\n\n\n\nWhat it is\n----------\n\nCava is a bar spectrum audio visualizer for terminal or desktop (SDL).\n\nworks on:\n* Linux\n* FreeBSD\n* macOS\n* Windows\n\nThis program is not intended for scientific use. It's written to look responsive and aesthetic when used to visualize music. \n\n\nInstalling\n------------------\n\n### From Source\n\n#### Installing Build Requirements\n\nRequired components:\n* [FFTW](http://www.fftw.org/)\n* libtool\n* automake\n* pkgconf\n* build-essentials\n* [iniparser](https://github.com/ndevilla/iniparser)\n\n\nRecomended components:\n\nThe development lib of one of these audio frameworks, depending on your distro:\n* ALSA\n* Pulseaudio\n* Pipewire\n* Portaudio\n* Sndio\n* JACK\n\n\nOptional components:\n* SDL2 dev files\n* autoconf-archive (needed for setting up OpenGL)\n* [ncursesw dev files](http://www.gnu.org/software/ncurses/) (bundled in ncurses in arch)\n\nOnly FFTW, iniparser and the build tools are actually required for CAVA to compile, but this will only give you the ability to read from fifo files. To capture audio directlty from your system pipewire, pulseaudio, alsa, sndio, jack or portaudio dev files are required (depending on what audio system you are using).\n\nNcurses can be used as an alternative output method if you have issues with the default one. But it is not required.\n\nAll the requirements can be installed easily in all major distros:\n\nFreeBSD\n\n    pkg install autoconf automake fftw3 iniparser jackit libglvnd libtool pkgconf psftools sdl2 sndio\n\nAdditionally, run these commands on FreeBSD before building:\n\n    export CFLAGS=\"-I/usr/local/include\"\n    export LDFLAGS=\"-L/usr/local/lib\"\n\n\nDebian/Ubuntu:\n\n    sudo apt install build-essential libfftw3-dev libasound2-dev libpulse-dev libtool automake libiniparser-dev libsdl2-2.0-0 libsdl2-dev libpipewire-0.3-dev libjack-jackd2-dev pkgconf\n\n\nArchLinux:\n\n    pacman -S base-devel fftw alsa-lib iniparser pulseaudio pkgconf\n\n\nopenSUSE:\n\n    zypper install alsa-devel fftw3-devel libpulse-devel libtool pkgconf\n\n\nFedora:\n\n    dnf install alsa-lib-devel fftw3-devel pulseaudio-libs-devel libtool iniparser-devel pkgconf\n\n    \nmacOS:\n\nFirst install homebrew if you have't already:\n\n    /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\nThen install prerequisites:\n\n    brew install fftw libtool automake pkgconf portaudio iniparser\n    \nThe installation location for Homebrew packages is different between Intel Macs and Apple Silicon Macs.\nAs such, the commands will be a little bit different.\nYou can find out which type you have [here](https://support.apple.com/en-us/HT211814#:~:text=To%20open%20About%20This%20Mac,as%20an%20Intel%2Dbased%20Mac.)\n\nFor both machines, run these commands to fix macOS not finding libtool:\n\n    export LIBTOOL=`which glibtool`\n    export LIBTOOLIZE=`which glibtoolize`\n    ln -s `which glibtoolize` /usr/local/bin/libtoolize\n\nNote that the file name may be a little bit different depending on the versions, but the directory should be the same.\n\nAdditionally, run these commands on Apple Silicon Macs so that ./configure can find the Homebrew packages:\n\n    export LDFLAGS=\"-L/opt/homebrew/lib\"\n    export CPPFLAGS=\"-I/opt/homebrew/include\"\n\nIntel Mac instructions tested on macOS Big Sur.\n\nApple Silicon instructions tested on macOS Ventura.\n\n\nWindows:\n\nsee separate readme in `cava_win` folder.\n\n#### Building\n First of all clone this repo and cd in to it, then run:\n \n    ./autogen.sh\n    ./configure\n    make\n\nIf you have a recommended component installed, but do not wish to use it (perhaps if building a binary on one machine to be used on another), then the corresponding feature can be disabled during configuration (see configure --help for details).\n\nFor windows there is a VS solution file in the `cava_win` folder.\n    \n#### Installing \n\nInstall `cava` to default `/usr/local`:\n\n    make install\n\nOr you can change `PREFIX`, for example:\n\n   ./configure --prefix=PREFIX\n\n#### Uninstalling\n\n    make uninstall\n\n\n### Package managers\n\nAll distro specific instalation sources might be out of date. Please check version before reporting any issues here.\n\n\n#### FreeBSD\n\n    pkg install cava\n\n#### openSUSE\n\nTumbleweed users have cava in their repo. They can just use:\n\n    zypper in cava\n\nLeap users need to add the multimedia:apps repository first:\n\n    zypper ar -f obs://multimedia:apps/openSUSE_Leap_42.2 multimedia\n\nIf you use another version just replace *openSUSE_Leap_42.2* with *openSUSE_13.2*, adjust it to your version.\n\n#### Fedora\n\nCava is available in Fedora 26 and later.  You can install Cava by\nrunning:\n\n    dnf install cava\n\n#### Arch\n\nCava is in [AUR](https://aur.archlinux.org/packages/cava/).\n\n    pacaur -S cava\n\n#### Ubuntu/Debian\n\n##### Ubuntu 20.10 or more recent / Debian (unstable)\n\n    sudo apt install cava\n    \n##### Older Ubuntu\n\nHarshal Sheth has added CAVA to his PPA, it can be installed with:\n\n    add-apt-repository ppa:hsheth2/ppa\n    apt update\n    apt install cava\n    \n#### macOS\n\ncava is in homebrew.\n\n    brew install cava\n\n\n\nCapturing audio\n---------------\n\nAll config options are set in the [config file](#configuration).\n\n### Pipewire\n\n    method = pipewire\n\nThis is the default input method if supported on your system. The default source is `auto` and will most likely be your currently selected output.\nIf you run wireplumber you can use `wpctl` to get the `object.path` or `object.serial` of the desired device to visualize.\n\ne.g.\n\n    source = alsa:pcm:3:front:3:playback\n\n\n### Pulseaudio\n\n    method = pulse\n\nThe default source is `auto` and should be your currently selected output.\n \nIf nothing happens you might have to use a different source than the default. The default might also be your microphone.\n\n\n### ALSA\n\n    method = alsa\n\n\nALSA can be difficult because there is no native way to grab audio from an output. If you want to capture audio straight fom the output (not just mic or line-in), you must create an ALSA loopback interface, then output the audio simultaneously to both the loopback and your normal interface.\n\nTo create a loopback interface simply run:\n\n`sudo modprobe snd_aloop`\n\nHopefully your `aplay -l` should now contain a loopback interface.\n\nTo make it persistent across boot add the line `snd-aloop` to \"/etc/modules\". To keep it from being loaded as the first soundcard add the line `options snd-aloop index=1` to \"/etc/modprobe.d/alsa-base.conf\", this will load it at '1'. You can replace '1' with whatever makes most sense in your audio setup.\n\nPlaying the audio through your Loopback interface makes it possible for cava to capture it, but there will be no sound in your speakers. In order to play audio on the loopback interface and your actual interface you must make use of the ALSA multi channel.\n\nLook at the included example file `example_files/etc/asound.conf` on how to use the multi channel. I was able to make this work with a HDA Intel PCH sound card, but I had no luck with the an USB DAC.\n\nRead more about the ALSA method [here](http://stackoverflow.com/questions/12984089/capture-playback-on-play-only-sound-card-with-alsa).\n\nIf you are having problems with the alsa method on Rasberry PI, try enabling `mmap` by adding the following line to `/boot/config.txt` and reboot:\n\n```\ndtoverlay=i2s-mmap\n```\n\n#### dmix\n\n@reluekiss, was able to make cava work with dmix. Check out the example config in `example_files/etc/asound_dmix.conf` and issue [534](https://github.com/karlstav/cava/issues/534).\n\n\n\n### mpd\n\nAdd these lines in mpd:\n\n    audio_output {\n        type                    \"fifo\"\n        name                    \"my_fifo\"\n        path                    \"/tmp/mpd.fifo\"\n        format                  \"44100:16:2\"\n    }\n\nUncomment and change input method to `fifo` in the [config](#configuration) file.\n\nThe path of the fifo can be specified with the `source` parameter.\n\nI had some trouble with sync (the visualizer was ahead of the sound). Reducing the ALSA buffer in mpd fixed it:\n\n    audio_output {\n            type            \"alsa\"\n            name            \"My ALSA\"\n            buffer_time     \"50000\"   # (50ms); default is 500000 microseconds (0.5s)\n    }\n\n### Sndio\n\n    method = sndio\n\nSndio is the audio framework used on OpenBSD, but it's also available on FreeBSD, NetBSD and Linux.\nSo far this is only tested on FreeBSD, but it's probably very similar on other operating systems. The\nfollowing example demonstrates how to setup CAVA for sndio on FreeBSD (please consult the [OSS](#oss)\nsection for a deeper explanation of the various `pcmX` sound devices and the corresponding `/dev/dspX`\naudio devices in this example).\n```sh\n$ cat /dev/sndstat\nInstalled devices:\npcm0: <Realtek ALC1220 (Rear Analog)> (play/rec) default\npcm1: <Realtek ALC1220 (Front Analog Mic)> (rec)\npcm2: <USB audio> (play/rec)\nNo devices installed from userspace.\n```\nSndio operates on device descriptors. In general for every `/dev/dspX` audio device there is a corresponding\n`rsnd/X` sndio raw device descriptor. In this example there are `rsnd/0`, `rsnd/1` and `rsnd/2` (they\nare not listed in `/dev`, sndio uses these descriptors to access the corresponding audio devices internally).\nSndio also handles the implicit `default` device descriptor, which acts like a symlink to the raw device\ndescriptor corresponding to the default audio device `/dev/dsp`. In this example it acts like a symlink\nto `rsnd/0` because the default audio device `/dev/dsp` symlinks to `/dev/dsp0`. Sndio also evaluates\nthe environment variables `AUDIODEVICE` and `AUDIORECDEVICE`. If one of these is set (`AUDIORECDEVICE`\noverrides `AUDIODEVICE` if both are set) and a sndio-aware program tries to open the `default` device\ndescriptor or an unspecified device descriptor, then the program will use the device descriptor specified\nin the environment variable.\n\nNow in order to visualize the mic input in CAVA, the `source` value in the configuration file must\nbe set to the corresponding audio descriptor:\n\n    source = default    # default; symlink to rsnd/0 in this example; AUDIORECDEVICE and AUDIODEVICE evaluation\n    source =            # unspecified device descriptor; same as default above\n    source = rsnd/0     # for the pcm0 mic on the rear\n    source = rsnd/1     # for the pcm1 mic on the front\n    source = rsnd/2     # for the pcm2 mic on the USB headset\n\nWith `source = default` one can switch the visualization on the commandline without changing the configuration\nfile again:\n```sh\n$ AUDIODEVICE=rsnd/0 cava\n$ AUDIODEVICE=rsnd/1 cava\n$ AUDIODEVICE=rsnd/2 cava\n```\nSndio can't record the played back audio with just the raw device descriptors, i.e. the sounds from\na music player or a browser which play on the external stereo speakers through `rsnd/0` are not visualized\nin CAVA. For this to work the sndio server has to be started and a monitoring sub-device has to be\ncreated. The following example shows how to start the server and create a monitoring sub-device `snd/0`\nfrom `rsnd/0` and then start CAVA with `AUDIODEVICE` pointing to the new monitoring sub-device:\n```sh\n$ sndiod -f rsnd/0 -m play,mon\n$ AUDIODEVICE=snd/0 cava\n```\nSwitch between the speakers and the USB headset:\n```sh\n$ sndiod -f rsnd/2 -m play,mon -s usb -f rsnd/0 -m play,mon -s speakers\n$ AUDIODEVICE=snd/usb cava\n$ AUDIODEVICE=snd/speakers cava\n```\nConsult the manpage `sndiod(8)` for further information regarding configuration and startup of a sndio\nserver.\n\n### OSS\n\n    method = oss\n\nThe audio system used on FreeBSD is the Open Sound System (OSS).\nThe following example demonstrates how to setup CAVA for OSS on FreeBSD:\n```sh\n$ cat /dev/sndstat\nInstalled devices:\npcm0: <Realtek ALC1220 (Rear Analog)> (play/rec) default\npcm1: <Realtek ALC1220 (Front Analog Mic)> (rec)\npcm2: <USB audio> (play/rec)\nNo devices installed from userspace.\n```\nThe system has three `pcm` sound devices, `pcm0`, `pcm1` and `pcm2`. `pcm0` corresponds to the analog\noutput jack on the rear, in which external stereo speakers are plugged in, and the analog input jack,\nin which one could plug in a microphone. Because it encapsulates both, output and input, it is marked\nas `play/rec`. It is also set as the `default` sound device. `pcm1` corresponds to another analog input\njack for a mic on the front side and is marked `rec`. A USB headset with an integrated mic is plugged\nin an USB port and the system has created the `pcm2` sound device with `play/rec` capabilities for\nit.\n\nIn general for every `pcmX` device there is a corresponding `/dev/dspX` audio device. In this example\nthere are `/dev/dsp0`, `/dev/dsp1` and `/dev/dsp2` (the system creates them when needed, they are not\nlisted via `ls /dev` if they are currently not in use). The system also creates an implicit `/dev/dsp`,\nwhich acts like a symlink to the `default` audio device, in this example to `/dev/dsp0`.\n\nNow in order to visualize the mic input in CAVA, the `source` value in the configuration file must\nbe set to the corresponding audio device:\n\n    source = /dev/dsp     # default; symlink to /dev/dsp0 in this example\n    source = /dev/dsp0    # for the pcm0 mic on the rear\n    source = /dev/dsp1    # for the pcm1 mic on the front\n    source = /dev/dsp2    # for the pcm2 mic on the USB headset\n\nOSS can't record the outgoing audio on its own, i.e. the sounds from a music player or a browser which\nplay on the external stereo speakers through `/dev/dsp0` are not visualized in CAVA. A solution is\nto use Virtual OSS. It can create virtual audio devices from existing audio devices, in particular\nit can create a loopback audio device from `/dev/dsp0` and from which the played back audio can be\nfed into CAVA:\n```sh\n$ doas pkg install virtual_oss\n$ doas virtual_oss -r44100 -b16 -c2 -s4ms -O /dev/dsp0 -R /dev/null -T /dev/sndstat -l dsp.cava\n\n$ cat /dev/sndstat\nInstalled devices:\npcm0: <Realtek ALC1220 (Rear Analog)> (play/rec) default\npcm1: <Realtek ALC1220 (Front Analog Mic)> (rec)\npcm2: <USB audio> (play/rec)\nInstalled devices from userspace:\ndsp.cava: <Virtual OSS> (play/rec)\n```\nIt created a virtual loopback device `/dev/dsp.cava` from `/dev/dsp0`. Now the audio is visualized\nin CAVA with `source = /dev/dsp.cava` in the configuration file. The playback program must have a configuration\nto use the `/dev/dsp.cava` device. For programs where this is not possible, e.g. which always use `/dev/dsp`,\nreplace `-l dsp.cava` with `-l dsp`. Virtual OSS can be configured and started as a service on FreeBSD.\n\n### JACK\n\n    method = jack\n\nThe JACK Audio Connection Kit (JACK) is a professional sound server API which is available on several\noperating systems, e.g. FreeBSD and Linux.\n\nCAVA is a JACK client with the base client name `cava` and adheres to the standard server start and\nstop behaviour, i.e. CAVA starts a JACK server if none is already running and the environment variable\n`JACK_START_SERVER` is defined, in which case the server also stops when all clients have exited. The\n`source` in the CAVA configuration file specifies the name of the JACK server to which CAVA tries to\nconnect to. The default value is `default`, which is also the default JACK server name. The value can\nbe empty, in which case it implies `default`. Therefore the following three entries are equivalent:\n\n    ; source = default\n    source = default\n    source =\n\nOne exception is the combination of an empty `source` entry and the environment variable `JACK_DEFAULT_SERVER`.\nIf the environment variable is defined, e.g. `export JACK_DEFAULT_SERVER=foo`, then the following entries\nare equivalent:\n\n    source = foo\n    source =\n\nConsult the manpage `jackd(1)` for further information regarding configuration and startup of a JACK\nserver.\n\nCAVA creates terminal audio-typed (so no MIDI support) input ports. These ports can connect to output\nports of other JACK clients, e.g. connect to the output ports of a music player and CAVA will visualize\nthe music. Currently CAVA supports up to two input ports, i.e. it supports mono and stereo. The number\nof input ports can be controlled via the `channels` option in the input section of the configuration\nfile:\n\n    channels = 1    # one input port, mono\n    channels = 2    # two input ports, stereo (default)\n\nThe port's short name is simply `M` for mono, and `L` and `R` for stereo. The full name of the input\nport according to the base client name is `cava:M` for mono, and `cava:L` and `cava:R` for stereo.\n\nThe option `autoconnect` controls the connection strategy for CAVA's ports to other client's ports:\n\n    autoconnect = 0    # don't connect to other ports automatically\n    autoconnect = 1    # only connect to other ports during startup\n    autoconnect = 2    # reconnect to new ports regularly (default)\n\nThe automatic connection strategies scan the physical terminal input-ports, i.e. the real audio device\nwhich actually outputs the sound, and applies the same connections to CAVA's ports. In this way CAVA\nvisualizes the played back audio from JACK clients by default.\n\nIn order to control and manage the connection between CAVA's ports and ports of other client programs,\nthere are connection management programs for JACK. Some well known connection managers with a graphical\nuser interface are QjackCtl and Cadence. The JACK package itself often comes with CLI tools. Depending\non the operating system it could be necessary to install them separately, e.g. on FreeBSD:\n```sh\n$ doas pkg install jack-example-tools\n```\nAmong the tools are the programs `jack_lsp` and `jack_connect`. These two tools are enough to list\nand connect ports on the commandline. The following example demonstrates how to setup connections with\nthese tools:\n```sh\n$ jack_lsp\nsystem:capture_1\nsystem:capture_2\nsystem:playback_1\nsystem:playback_2\ncava:L\nmoc:output0\nmoc:output1\ncava:R\n```\nThis listing shows all full port names that are currently available. These correspond to two external\nJACK clients, `cava` and `moc`, and one internal JACK client `system`. The types and current active\nconnections between the ports can be listed with the `-p` and `-c` switches for `jack_lsp`. In order\nto connect the ports of CAVA and MOC, `jack_connect` is used:\n```sh\n$ jack_connect cava:L moc:output0\n$ jack_connect cava:R moc:output1\n```\nNow CAVA visualizes the outgoing audio from MOC.\n\n### squeezelite\n[squeezelite](https://en.wikipedia.org/wiki/Squeezelite) is one of several software clients available for the Logitech Media Server. Squeezelite can export its audio data as shared memory, which is what this input module uses.\nJust adapt your [config](#configuration):\n```\nmethod = shmem\nsource = /squeezelite-AA:BB:CC:DD:EE:FF\n```\nwhere `AA:BB:CC:DD:EE:FF` is squeezelite's MAC address (check the LMS Web GUI (Settings>Information) if unsure).\nNote: squeezelite must be started with the `-v` flag to enable visualizer support.\n\n### macOS\n```\nmethod = portaudio\n```\n\nPortaudio is the default and only supported way of capturing audio on macOS. Unfortunately portaudio can not capture audio directly from the output, but there are severeal ways to achive this: \n\n**Background Music**\n\nInstall [Background Music](https://github.com/kyleneideck/BackgroundMusic) which provides a loopback interface automatically. Once installed and running just edit your [config](#configuration) to use this interface with portaudio:\n\n```\nsource = \"Background Music\"\n```\n\n**Sound Flower**\n\n[Soundflower](https://github.com/mattingalls/Soundflower) also works to create a loopback interface. Use Audio MIDI Setup to configure a virtual interface that outputs audio to both your speakers and the loopback interface, following [this](https://github.com/RogueAmoeba/Soundflower-Original/issues/44#issuecomment-151586106) recipe. By creating a multi-output device you lose the ability to control the volume on your keyboard. Because of this, we recommend the Background Music app which still gives you keyboard controls.\n\nThen edit your [config](#configuration) to use this interface with portaudio:\n\n```\nmethod = portaudio\nsource = \"Soundflower (2ch)\"\n```\n\n\n\nNote: Cava doesn't render correctly within the default macOS terminal. In order to achieve an optimal display, install [Kitty](https://sw.kovidgoyal.net/kitty/index.html). Beware that you may run in to the issue presented in #109; however, it can be resolved with [this](https://stackoverflow.com/questions/7165108/in-os-x-lion-lang-is-not-set-to-utf-8-how-to-fix-it).\n\n\n### Windows\n\nShould capture the audio from the default output device automatically. No config needed.\n\n\nRunning via ssh\n---------------\n\nTo run via ssh to an external monitor, redirect output to `/dev/console`:\n\n     ~# ./cava  <> /dev/console >&0 2>&1\n\nexit with ctrl+z then run 'bg' to keep it running after you log out.\n\n(You must be root to redirect to console. Simple sudo is not enough: Run `sudo su` first.)\n\n\n## Troubleshooting\n\n### No bars in terminal\n\nMost likley issue [#399](https://github.com/karlstav/cava/issues/399). Locale settings need to be set correctly in order for cava to work.\n\n### Bars not moving\n\nRead the chapter on [capturing audio](#capturing-audio). Depending on your system this might not work automatically. For example if you have pipewire dev files on your system, but are still using pulseaudio, you will have to specify `pulse` as your input method in the cava config file.\n\n### Visualizer reacts to microphone instead of output\n\nThis is a known issue with pipewire. Try the workaround described [here](https://github.com/karlstav/cava/issues/422#issuecomment-994270910)\n\n### Vertical lines in bars\n\nThis is either an issue with the font, or line spacing being enabled in the terminal emulator. Try to change font or disable line spacing.\n\n### Low resolution\n\nSince the graphics are simply based on characters, try decreasing the font size.\n\n### Low frame rate\n\nSome terminal emulators are just slow. Cava will look best in a GPU based terminal like kitty or alacritty. You can also try to increase the font size\n\n### Font is changed in ttys after exit\n\nIf you run cava in a TTY (like ctrl+alt+F2) the program will change the font to the included `cava.psf` (actually a slightly modified \"unifont\").\n\nIn console fonts it seems that only 256 Unicode characters are supported, probably because they are bitmap fonts. I could not find a font with Unicode characters 2581-2587 (the 1/8 - 7/8 blocks used on the top of each bar to increase resolution).\n\nSo in `cava.psf`, the characters 1-7 are actually replaced by Unicode characters 2581-2587. When cava exits, it changes the font back. If cava exits abnormally and you notice that 1-7 are replaced by partial blocks, just change the font with `setfont`.\n\nActually, `setfont` is supposed to return the default font, but this usually isn't set. I haven't found another way to get the current font. So cava sets the font to \"Lat2-Fixed16\" when interrupted. All major distros should have it. It will revert to your default font at reboot.\n\n### Gradient not working in Konsole\n\nKonsole simply does not support this. [#194](https://github.com/karlstav/cava/issues/194)\n\nUsage\n-----\n\n    Usage : cava [options]\n    Visualize audio input in terminal. \n\n    Options:\n    \t    -p          path to config file\n    \t    -v          print version\n\n\n\nExit with ctrl+c or q.\n\nIf cava quits unexpectedly or is force killed, echo must be turned on manually with `stty -echo`.\n\n### Controls\n\n| Key | Description |\n| --- | ----------- |\n| <kbd>up</kbd> / <kbd>down</kbd>| increase/decrease sensitivity |\n| <kbd>left</kbd> / <kbd>right</kbd>| increase/decrease bar width |\n| <kbd>f</kbd> / <kbd>b</kbd>| change foreground/background color |\n| <kbd>r</kbd> | Reload configuration |\n| <kbd>c</kbd> | Reload colors only |\n| <kbd>q</kbd> or <kbd>CTRL-C</kbd>| Quit C.A.V.A. |\n\nConfiguration\n-------------\n\nBy default a configuration file is created upon first launch in `$XDG_CONFIG_HOME/cava/config` or `$HOME/.config/cava/config`, but cava can also be made to use a different file with the `-p` option.\n\nSending cava a SIGUSR1 signal, will force cava to reload its configuration file. Thus, it behaves as if the user pressed <kbd>r</kbd> in the terminal. One might send a SIGUSR1 signal using `pkill` or `killall`.\nFor example:\n```\n$ pkill -USR1 cava\n```\n\nSimilarly, sending cava a SIGUSR2 signal will only reload the colors from the configuration file, which is the same as pressing <kbd>c</kbd> in the terminal. This is slightly faster than reloading the entire config as the audio processing does not need to reinitialize.  \n```\n$ pkill -USR2 cava\n```\n\n**Examples on how the equalizer works:**\n\n    [eq]\n    1=0\n    2=1\n    3=0\n    4=1\n    5=0\n\n![3_138](https://cloud.githubusercontent.com/assets/6376571/8670183/a54a851e-29e8-11e5-9eff-346bf6ed91e0.png)\n\n    [eq]\n    1=2\n    2=2\n    3=1\n    4=1\n    5=0.5\n\n![3_139](https://cloud.githubusercontent.com/assets/6376571/8670181/9db0ef50-29e8-11e5-81bc-3e2bb9892da0.png)\n\n\nUsing cava in other applications\n--------------------------------\n\n### cavacore library\n\nThe core processing engine in cava has been split into a separate library `cavacore`. See CAVACORE.md for details.\n\n### Raw Output\n\nYou can also use Cava's output for other programs by using raw output mode, which will write bar data to `STDOUT` that can be piped into other processes. More information on this option is documented in [the example config file](/example_files/config).\n\nA useful starting point example script written in python that consumes raw data can be found [here](https://github.com/karlstav/cava/issues/123#issuecomment-307891020).\n\n\nContribution\n------\n\nPlease read CONTRIBUTING.md before opening a pull request.\n\nThanks to:\n* [CelestialWalrus](https://github.com/CelestialWalrus)\n* [anko](https://github.com/anko)\n* [livibetter](https://github.com/livibetter)\n\nfor major contributions in the early development of this project.\n\nAlso thanks to [dpayne](https://github.com/dpayne/) for figuring out how to find the pulseaudio default sink name.\n"
        },
        {
          "name": "SHADERS.md",
          "type": "blob",
          "size": 0.7158203125,
          "content": "custom shaders\n==============\n\nWrite your own shaders for cava!\n\ncava can use SDL/OpenGL to render custom glsl shaders.\n\nThe shader files must be placed in $HOME/.config/cava/shaders\n\nunder [output] set `method` to 'sdl_glsl'\n\nuse the config options `vertex_shader` and `fragment_shader` to select file.\n\nlook in the `bar_spectrum.frag` shader for how the shaders interact with cava.\n\nthe custom shaders will use some of the same config parameters as the other output modes, like number of bars.\n\nfeel free to commit your own shaders (or improvements to the sdl_glsl output mode) and create pull request.\n\nTo add a shader to the cava repo put it under output/shaders here, and add it to the INCTXT at the top of the config.c file.\n\n\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.205078125,
          "content": "#!/bin/sh\n\nif [ -d .git ]; then\n  git describe --always --tags --dirty > version # get version from git\nelse\n  echo 0.10.2 > version # hard coded versions\nfi\n\nlibtoolize\naclocal\nautoconf\nautomake --add-missing\n"
        },
        {
          "name": "cava.c",
          "type": "blob",
          "size": 45.251953125,
          "content": "#include <locale.h>\n\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#else\n#include <stdlib.h>\n#endif\n\n#include <fcntl.h>\n#include <math.h>\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932385\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#ifndef _MSC_VER\n#include <ctype.h>\n#include <dirent.h>\n#include <getopt.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <unistd.h>\n#endif\n\n#ifdef _MSC_VER\n#include \"input/winscap.h\"\n#include <windows.h>\n#define PATH_MAX 260\n#define PACKAGE \"cava\"\n#define _CRT_SECURE_NO_WARNINGS 1\n#endif // _MSC_VER\n\n#include <signal.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n\n#include \"cavacore.h\"\n\n#include \"config.h\"\n\n#include \"debug.h\"\n#include \"util.h\"\n\n#ifdef SDL\n#include \"output/sdl_cava.h\"\n#endif\n\n#ifdef SDL_GLSL\n#include \"output/sdl_glsl.h\"\n#endif\n\n#include \"input/common.h\"\n\n#include \"output/terminal_noncurses.h\"\n\n#ifndef _MSC_VER\n#ifdef NCURSES\n#include \"output/terminal_bcircle.h\"\n#include \"output/terminal_ncurses.h\"\n#include <curses.h>\n#endif\n\n#include \"output/noritake.h\"\n#include \"output/raw.h\"\n\n#include \"input/alsa.h\"\n#include \"input/fifo.h\"\n#include \"input/jack.h\"\n#include \"input/oss.h\"\n#include \"input/pipewire.h\"\n#include \"input/portaudio.h\"\n#include \"input/pulse.h\"\n#include \"input/shmem.h\"\n#include \"input/sndio.h\"\n#endif\n\n#ifdef __GNUC__\n// curses.h or other sources may already define\n#undef GCC_UNUSED\n#define GCC_UNUSED __attribute__((unused))\n#else\n#define GCC_UNUSED /* nothing */\n#endif\n\n// used by sig handler\n// needs to know output mode in order to clean up terminal\nint output_mode;\n// whether we should reload the config or not\nint should_reload = 0;\n// whether we should only reload colors or not\nint reload_colors = 0;\n// whether we should quit\nint should_quit = 0;\n\n// these variables are used only in main, but making them global\n// will allow us to not free them on exit without ASan complaining\nstruct config_params p;\n\n// general: cleanup\nvoid cleanup(void) {\n    if (output_mode == OUTPUT_NCURSES) {\n#ifdef NCURSES\n        cleanup_terminal_ncurses();\n#else\n        ;\n#endif\n    } else if (output_mode == OUTPUT_NONCURSES) {\n        cleanup_terminal_noncurses();\n    } else if (output_mode == OUTPUT_SDL) {\n#ifdef SDL\n        cleanup_sdl();\n#else\n        ;\n#endif\n#ifdef SDL_GLSL\n    } else if (output_mode == OUTPUT_SDL_GLSL) {\n        cleanup_sdl_glsl();\n#else\n        ;\n#endif\n    }\n}\n\n// general: handle signals\nvoid sig_handler(int sig_no) {\n#ifndef _MSC_VER\n\n    if (sig_no == SIGUSR1) {\n        should_reload = 1;\n        return;\n    }\n\n    if (sig_no == SIGUSR2) {\n        reload_colors = 1;\n        return;\n    }\n#endif\n\n    cleanup();\n\n#ifdef _MSC_VER\n    if (sig_no == CTRL_C_EVENT || sig_no == CTRL_CLOSE_EVENT) {\n        sig_no = SIGINT;\n    } else {\n        return;\n    }\n#endif\n    if (sig_no == SIGINT) {\n        printf(\"CTRL-C pressed -- goodbye\\n\");\n    }\n\n    signal(sig_no, SIG_DFL);\n    raise(sig_no);\n}\n\n#ifdef ALSA\nstatic bool is_loop_device_for_sure(const char *text) {\n    const char *const LOOPBACK_DEVICE_PREFIX = \"hw:Loopback,\";\n    return strncmp(text, LOOPBACK_DEVICE_PREFIX, strlen(LOOPBACK_DEVICE_PREFIX)) == 0;\n}\n\nstatic bool directory_exists(const char *path) {\n    DIR *const dir = opendir(path);\n    if (dir == NULL)\n        return false;\n\n    closedir(dir);\n    return true;\n}\n\n#endif\n\nfloat *monstercat_filter(float *bars, int number_of_bars, int waves, double monstercat,\n                         int height) {\n\n    int z;\n\n    // process [smoothing]: monstercat-style \"average\"\n\n    int m_y, de;\n    float height_normalizer = 1.0;\n    if (height > 1000) {\n        height_normalizer = height / 912.76;\n    }\n    if (waves > 0) {\n        for (z = 0; z < number_of_bars; z++) { // waves\n            bars[z] = bars[z] / 1.25;\n            // if (bars[z] < 1) bars[z] = 1;\n            for (m_y = z - 1; m_y >= 0; m_y--) {\n                de = z - m_y;\n                bars[m_y] = max(bars[z] - height_normalizer * pow(de, 2), bars[m_y]);\n            }\n            for (m_y = z + 1; m_y < number_of_bars; m_y++) {\n                de = m_y - z;\n                bars[m_y] = max(bars[z] - height_normalizer * pow(de, 2), bars[m_y]);\n            }\n        }\n    } else if (monstercat > 0) {\n        for (z = 0; z < number_of_bars; z++) {\n            // if (bars[z] < 1)bars[z] = 1;\n            for (m_y = z - 1; m_y >= 0; m_y--) {\n                de = z - m_y;\n                bars[m_y] = max(bars[z] / pow(monstercat * 1.5, de), bars[m_y]);\n            }\n            for (m_y = z + 1; m_y < number_of_bars; m_y++) {\n                de = m_y - z;\n                bars[m_y] = max(bars[z] / pow(monstercat * 1.5, de), bars[m_y]);\n            }\n        }\n    }\n    return bars;\n}\n\n// general: entry point\nint main(int argc, char **argv) {\n\n#ifndef _MSC_VER\n    // general: console title\n    printf(\"%c]0;%s%c\", '\\033', PACKAGE, '\\007');\n#endif // !_MSC_VER\n\n    // general: handle command-line arguments\n    char configPath[PATH_MAX];\n    configPath[0] = '\\0';\n#ifdef _MSC_VER\n    if (!SetConsoleCtrlHandler(sig_handler, TRUE)) {\n        fprintf(stderr, \"ERROR: Could not set control handler\");\n        exit(EXIT_FAILURE);\n    }\n#else\n    // general: handle Ctrl+C\n    struct sigaction action;\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = &sig_handler;\n    sigaction(SIGINT, &action, NULL);\n    sigaction(SIGTERM, &action, NULL);\n    sigaction(SIGUSR1, &action, NULL);\n    sigaction(SIGUSR2, &action, NULL);\n#endif\n    char *usage = \"\\n\\\nUsage : \" PACKAGE \" [options]\\n\\\nVisualize audio input in terminal. \\n\\\n\\n\\\nOptions:\\n\\\n\t-p          path to config file\\n\\\n\t-v          print version\\n\\\n\\n\\\nKeys:\\n\\\n        Up        Increase sensitivity\\n\\\n        Down      Decrease sensitivity\\n\\\n        Left      Decrease number of bars\\n\\\n        Right     Increase number of bars\\n\\\n        r         Reload config\\n\\\n        c         Reload colors only\\n\\\n        f         Cycle foreground color\\n\\\n        b         Cycle background color\\n\\\n        q         Quit\\n\\\n\\n\\\nas of 0.4.0 all options are specified in config file, see in '/home/username/.config/cava/' \\n\";\n#ifndef _MSC_VER\n\n    int c;\n    while ((c = getopt(argc, argv, \"p:vh\")) != -1) {\n        switch (c) {\n        case 'p': // argument: fifo path\n            snprintf(configPath, sizeof(configPath), \"%s\", optarg);\n            break;\n        case 'h': // argument: print usage\n            printf(\"%s\", usage);\n            return 1;\n        case '?': // argument: print usage\n            printf(\"%s\", usage);\n            return 1;\n        case 'v': // argument: print version\n            printf(PACKAGE \" \" VERSION \"\\n\");\n            return 0;\n        default: // argument: no arguments; exit\n            abort();\n        }\n    }\n#else\n    if (argc > 1)\n        snprintf(configPath, sizeof(configPath), \"%s\", argv[1]);\n#endif\n\n    // general: main loop\n    while (1) {\n\n        debug(\"loading config\\n\");\n        // config: load\n        struct error_s error;\n        error.length = 0;\n        if (!load_config(configPath, &p, 0, &error)) {\n            fprintf(stderr, \"Error loading config. %s\", error.message);\n            exit(EXIT_FAILURE);\n        }\n\n        int inAtty = 0;\n\n        output_mode = p.output;\n#ifndef _MSC_VER\n        if (output_mode == OUTPUT_NCURSES || output_mode == OUTPUT_NONCURSES) {\n            // Check if we're running in a tty\n            if (strncmp(ttyname(0), \"/dev/tty\", 8) == 0 || strcmp(ttyname(0), \"/dev/console\") == 0)\n                inAtty = 1;\n\n            // in macos vitual terminals are called ttys(xyz) and there are no ttys\n            if (strncmp(ttyname(0), \"/dev/ttys\", 9) == 0)\n                inAtty = 0;\n            if (inAtty) {\n#ifdef CAVAFONT\n                // checking if cava psf font is installed in FONTDIR\n                FILE *font_file;\n                font_file = fopen(FONTDIR \"/\" FONTFILE, \"r\");\n                if (font_file) {\n                    fclose(font_file);\n#ifdef __FreeBSD__\n                    system(\"vidcontrol -f \" FONTDIR \"/\" FONTFILE \" >/dev/null 2>&1\");\n#else\n                    system(\"setfont \" FONTDIR \"/\" FONTFILE \" >/dev/null 2>&1\");\n#endif\n                } else {\n                    // if not it might still be available, we dont know, must try\n#ifdef __FreeBSD__\n                    system(\"vidcontrol -f \" FONTFILE \" >/dev/null 2>&1\");\n#else\n                    system(\"setfont \" FONTFILE \" >/dev/null 2>&1\");\n#endif\n                }\n#endif // CAVAFONT\n#ifndef __FreeBSD__\n                if (p.disable_blanking)\n                    system(\"setterm -blank 0\");\n#endif\n                if (p.orientation != ORIENT_BOTTOM) {\n                    cleanup();\n                    fprintf(stderr, \"only default bottom orientation is supported in tty\\n\");\n                    exit(EXIT_FAILURE);\n                }\n            }\n\n            // We use unicode block characters to draw the bars and\n            // the locale var LANG must be set to use unicode chars.\n            // For some reason this var can't be retrieved with\n            // setlocale(LANG, NULL), so we get it with getenv.\n            // Also we can't set it with setlocale(LANG \"\") so we\n            // must set LC_ALL instead.\n            // Attempting to set to en_US if not set, if that lang\n            // is not installed and LANG is not set there will be\n            // no output, for more info see #109 #344\n            if (!getenv(\"LANG\"))\n                setlocale(LC_ALL, \"en_US.utf8\");\n            else\n                setlocale(LC_ALL, \"\");\n        }\n#endif\n        // input: init\n\n        struct audio_data audio;\n        memset(&audio, 0, sizeof(audio));\n\n        audio.source = malloc(1 + strlen(p.audio_source));\n        strcpy(audio.source, p.audio_source);\n\n        audio.format = -1;\n        audio.rate = 0;\n        audio.samples_counter = 0;\n        audio.channels = 2;\n        audio.IEEE_FLOAT = 0;\n        audio.autoconnect = 0;\n\n        audio.input_buffer_size = BUFFER_SIZE * audio.channels;\n        audio.cava_buffer_size = audio.input_buffer_size * 8;\n\n        audio.cava_in = (double *)malloc(audio.cava_buffer_size * sizeof(double));\n        memset(audio.cava_in, 0, sizeof(int) * audio.cava_buffer_size);\n\n        audio.threadparams = 0; // most input threads don't adjust the parameters\n        audio.terminate = 0;\n\n        debug(\"starting audio thread\\n\");\n\n        pthread_t p_thread;\n        int timeout_counter = 0;\n        int total_bar_height = 0;\n\n        struct timespec timeout_timer = {.tv_sec = 0, .tv_nsec = 1000000};\n        int thr_id GCC_UNUSED;\n\n        pthread_mutex_init(&audio.lock, NULL);\n\n        switch (p.input) {\n#ifndef _MSC_VER\n\n#ifdef ALSA\n        case INPUT_ALSA:\n            if (is_loop_device_for_sure(audio.source)) {\n                if (directory_exists(\"/sys/\")) {\n                    if (!directory_exists(\"/sys/module/snd_aloop/\")) {\n                        cleanup();\n                        fprintf(stderr,\n                                \"Linux kernel module \\\"snd_aloop\\\" does not seem to  be loaded.\\n\"\n                                \"Maybe run \\\"sudo modprobe snd_aloop\\\".\\n\");\n                        exit(EXIT_FAILURE);\n                    }\n                }\n            }\n\n            thr_id = pthread_create(&p_thread, NULL, input_alsa, (void *)&audio);\n            break;\n#endif\n\n        case INPUT_FIFO:\n            audio.rate = p.samplerate;\n            audio.format = p.samplebits;\n            thr_id = pthread_create(&p_thread, NULL, input_fifo, (void *)&audio);\n            break;\n#ifdef PULSE\n        case INPUT_PULSE:\n            audio.format = 16;\n            audio.rate = 44100;\n            if (strcmp(audio.source, \"auto\") == 0) {\n                getPulseDefaultSink((void *)&audio);\n            }\n            thr_id = pthread_create(&p_thread, NULL, input_pulse, (void *)&audio);\n            break;\n#endif\n#ifdef SNDIO\n        case INPUT_SNDIO:\n            audio.format = p.samplebits;\n            audio.rate = p.samplerate;\n            audio.channels = p.channels;\n            audio.threadparams = 1; // Sndio can adjust parameters\n            thr_id = pthread_create(&p_thread, NULL, input_sndio, (void *)&audio);\n            break;\n#endif\n#ifdef OSS\n        case INPUT_OSS:\n            audio.format = p.samplebits;\n            audio.rate = p.samplerate;\n            audio.channels = p.channels;\n            audio.threadparams = 1; // OSS can adjust parameters\n            thr_id = pthread_create(&p_thread, NULL, input_oss, (void *)&audio);\n            break;\n#endif\n#ifdef JACK\n        case INPUT_JACK:\n            audio.channels = p.channels;\n            audio.autoconnect = p.autoconnect;\n            audio.threadparams = 1; // JACK server provides parameters\n            thr_id = pthread_create(&p_thread, NULL, input_jack, (void *)&audio);\n            break;\n#endif\n        case INPUT_SHMEM:\n            audio.format = 16;\n            thr_id = pthread_create(&p_thread, NULL, input_shmem, (void *)&audio);\n            break;\n#ifdef PORTAUDIO\n        case INPUT_PORTAUDIO:\n            audio.format = 16;\n            audio.rate = 44100;\n            audio.threadparams = 1;\n            if (!strcmp(audio.source, \"list\")) {\n                input_portaudio((void *)&audio);\n            } else {\n                thr_id = pthread_create(&p_thread, NULL, input_portaudio, (void *)&audio);\n            }\n            break;\n#endif\n#ifdef PIPEWIRE\n        case INPUT_PIPEWIRE:\n            audio.format = p.samplebits;\n            audio.rate = p.samplerate;\n            thr_id = pthread_create(&p_thread, NULL, input_pipewire, (void *)&audio);\n            break;\n#endif\n#endif\n#ifdef _MSC_VER\n        case INPUT_WINSCAP:\n            thr_id = pthread_create(&p_thread, NULL, input_winscap, (void *)&audio);\n            break;\n#endif\n        default:\n            exit(EXIT_FAILURE); // Can't happen.\n        }\n\n        timeout_counter = 0;\n        while (true) {\n#ifdef _MSC_VER\n            Sleep(1);\n#else\n            nanosleep(&timeout_timer, NULL);\n#endif\n            pthread_mutex_lock(&audio.lock);\n            if ((audio.threadparams == 0) && (audio.format != -1) && (audio.rate != 0))\n                break;\n\n            pthread_mutex_unlock(&audio.lock);\n            timeout_counter++;\n            if (timeout_counter > 5000) {\n                cleanup();\n                fprintf(stderr, \"could not get rate and/or format, problems with audio thread? \"\n                                \"quitting...\\n\");\n                exit(EXIT_FAILURE);\n            }\n        }\n        pthread_mutex_unlock(&audio.lock);\n        debug(\"got format: %d and rate %d\\n\", audio.format, audio.rate);\n\n        int audio_channels = audio.channels;\n\n        if (p.upper_cut_off > audio.rate / 2) {\n            cleanup();\n            fprintf(stderr, \"higher cutoff frequency can't be higher than sample rate / 2\");\n            exit(EXIT_FAILURE);\n        }\n\n        int *bars;\n        int *previous_frame;\n\n        float *bars_left, *bars_right;\n        double *cava_out;\n        float *bars_raw;\n\n        int height, lines, width, remainder, fp;\n        int *dimension_bar, *dimension_value;\n\n        if (p.orientation == ORIENT_LEFT || p.orientation == ORIENT_RIGHT) {\n            dimension_bar = &height;\n            dimension_value = &width;\n        } else {\n            dimension_bar = &width;\n            dimension_value = &height;\n        }\n\n#ifdef SDL\n        // output: start sdl mode\n        if (output_mode == OUTPUT_SDL) {\n            init_sdl_window(p.sdl_width, p.sdl_height, p.sdl_x, p.sdl_y, p.sdl_full_screen);\n            height = p.sdl_height;\n            width = p.sdl_width;\n        }\n#endif\n#ifdef SDL_GLSL\n        if (output_mode == OUTPUT_SDL_GLSL) {\n            init_sdl_glsl_window(p.sdl_width, p.sdl_height, p.sdl_x, p.sdl_y, p.sdl_full_screen,\n                                 p.vertex_shader, p.fragment_shader);\n            height = p.sdl_height;\n            width = p.sdl_width;\n        }\n#endif\n\n        bool reloadConf = false;\n        while (!reloadConf) { // jumping back to this loop means that you resized the screen\n\n            // frequencies on x axis require a bar width of four or more\n            if (p.xaxis == FREQUENCY && p.bar_width < 4)\n                p.bar_width = 4;\n\n            switch (output_mode) {\n#ifdef NCURSES\n            // output: start ncurses mode\n            case OUTPUT_NCURSES:\n                init_terminal_ncurses(p.color, p.bcolor, p.col, p.bgcol, p.gradient,\n                                      p.gradient_count, p.gradient_colors, &width, &lines);\n                if (p.xaxis != NONE)\n                    lines--;\n                height = lines;\n                *dimension_value *=\n                    8; // we have 8 times as much height due to using 1/8 block characters\n                break;\n#endif\n#ifdef SDL\n            // output: get sdl window size\n            case OUTPUT_SDL:\n                init_sdl_surface(&width, &height, p.color, p.bcolor, p.gradient, p.gradient_count,\n                                 p.gradient_colors);\n                break;\n#endif\n#ifdef SDL_GLSL\n            // output: get sdl window size\n            case OUTPUT_SDL_GLSL:\n                init_sdl_glsl_surface(&width, &height, p.color, p.bcolor, p.bar_width,\n                                      p.bar_spacing, p.gradient, p.gradient_count,\n                                      p.gradient_colors);\n                break;\n#endif\n            case OUTPUT_NONCURSES:\n                get_terminal_dim_noncurses(&width, &lines);\n\n                if (p.xaxis != NONE)\n                    lines--;\n\n                init_terminal_noncurses(inAtty, p.color, p.bcolor, p.col, p.bgcol, p.gradient,\n                                        p.gradient_count, p.gradient_colors, width, lines,\n                                        p.bar_width, p.orientation);\n                height = lines * 8;\n                break;\n#ifndef _MSC_VER\n            case OUTPUT_RAW:\n            case OUTPUT_NORITAKE:\n                if (strcmp(p.raw_target, \"/dev/stdout\") != 0) {\n\n                    int fptest;\n                    // checking if file exists\n                    if (access(p.raw_target, F_OK) != -1) {\n                        // file exists, testopening in case it's a fifo\n                        fptest = open(p.raw_target, O_RDONLY | O_NONBLOCK, 0644);\n\n                        if (fptest == -1) {\n                            fprintf(stderr, \"could not open file %s for writing\\n\", p.raw_target);\n                            exit(1);\n                        }\n                    } else {\n                        printf(\"creating fifo %s\\n\", p.raw_target);\n                        if (mkfifo(p.raw_target, 0664) == -1) {\n                            fprintf(stderr, \"could not create fifo %s\\n\", p.raw_target);\n                            exit(1);\n                        }\n                        // fifo needs to be open for reading in order to write to it\n                        fptest = open(p.raw_target, O_RDONLY | O_NONBLOCK, 0644);\n                    }\n                    fp = open(p.raw_target, O_WRONLY | O_NONBLOCK | O_CREAT, 0644);\n                } else {\n                    fp = fileno(stdout);\n                }\n                if (fp == -1) {\n                    fprintf(stderr, \"could not open file %s for writing\\n\", p.raw_target);\n                    exit(1);\n                }\n\n#ifndef NDEBUG\n                debug(\"open file %s for writing raw output\\n\", p.raw_target);\n#endif\n\n                // width must be hardcoded for raw output.\n                width = 512;\n\n                p.bar_width = 1; // not used\n                p.bar_spacing = 1;\n\n                if (strcmp(p.data_format, \"ascii\") != 0) {\n                    // \"binary\" or \"noritake\"\n                    height = pow(2, p.bit_format) - 1;\n                } else {\n                    height = p.ascii_range;\n                }\n                break;\n#endif\n            default:\n                exit(EXIT_FAILURE); // Can't happen.\n            }\n\n            // force stereo if only one channel is available\n            if (p.stereo && audio_channels == 1)\n                p.stereo = 0;\n\n            // handle for user setting too many bars\n            if (p.fixedbars) {\n                p.autobars = 0;\n                if (p.fixedbars * p.bar_width + p.fixedbars * p.bar_spacing - p.bar_spacing > width)\n                    p.autobars = 1;\n            }\n\n            // getting numbers of bars\n            int number_of_bars = p.fixedbars;\n\n            if (p.autobars == 1)\n                number_of_bars = (*dimension_bar + p.bar_spacing) / (p.bar_width + p.bar_spacing);\n\n            if (number_of_bars <= 1) {\n                number_of_bars = 1; // must have at least 1 bars\n                if (p.stereo) {\n                    number_of_bars = 2; // stereo have at least 2 bars\n                }\n            }\n            if (number_of_bars > 512)\n                number_of_bars = 512; // cant have more than 512 bars on 44100 rate\n\n            int output_channels = 1;\n            if (p.stereo) { // stereo must have even numbers of bars\n                output_channels = 2;\n                if (number_of_bars % 2 != 0)\n                    number_of_bars--;\n            }\n            int raw_number_of_bars = (number_of_bars / output_channels) * audio_channels;\n            if (p.waveform) {\n                raw_number_of_bars = number_of_bars;\n            }\n            // checks if there is stil extra room, will use this to center\n            remainder = (*dimension_bar - number_of_bars * p.bar_width -\n                         number_of_bars * p.bar_spacing + p.bar_spacing) /\n                        2;\n            if (remainder < 0)\n                remainder = 0;\n\n#ifndef NDEBUG\n            debug(\"height: %d width: %d dimension_bar: %d dimension_value: %d bars:%d bar width: \"\n                  \"%d remainder: %d\\n\",\n                  height, width, *dimension_bar, *dimension_value, number_of_bars, p.bar_width,\n                  remainder);\n#endif\n\n            double userEQ_keys_to_bars_ratio;\n\n            if (p.userEQ_enabled && (number_of_bars / output_channels > 0)) {\n                userEQ_keys_to_bars_ratio = (double)(((double)p.userEQ_keys) /\n                                                     ((double)(number_of_bars / output_channels)));\n            }\n\n            struct cava_plan *plan =\n                cava_init(number_of_bars / output_channels, audio.rate, audio.channels, p.autosens,\n                          p.noise_reduction, p.lower_cut_off, p.upper_cut_off);\n\n            if (plan->status == -1) {\n                cleanup();\n                fprintf(stderr, \"Error initializing cava . %s\", plan->error_message);\n                exit(EXIT_FAILURE);\n            }\n\n            bars_left = (float *)malloc(number_of_bars / output_channels * sizeof(float));\n            bars_right = (float *)malloc(number_of_bars / output_channels * sizeof(float));\n            memset(bars_left, 0, sizeof(float) * number_of_bars / output_channels);\n            memset(bars_right, 0, sizeof(float) * number_of_bars / output_channels);\n\n            bars = (int *)malloc(number_of_bars * sizeof(int));\n            bars_raw = (float *)malloc(number_of_bars * sizeof(float));\n            previous_frame = (int *)malloc(number_of_bars * sizeof(int));\n            cava_out = (double *)malloc(number_of_bars * audio.channels / output_channels *\n                                        sizeof(double));\n\n            memset(bars, 0, sizeof(int) * number_of_bars);\n            memset(bars_raw, 0, sizeof(float) * number_of_bars);\n            memset(previous_frame, 0, sizeof(int) * number_of_bars);\n            memset(cava_out, 0, sizeof(double) * number_of_bars * audio.channels / output_channels);\n\n            int x_axis_info = 0;\n            // process: calculate x axis values\n            if (p.xaxis != NONE) {\n                x_axis_info = 1;\n                double cut_off_frequency;\n                if (output_mode == OUTPUT_NONCURSES) {\n                    printf(\"\\r\\033[%dB\", lines + 1);\n                    if (remainder)\n                        printf(\"\\033[%dC\", remainder);\n                }\n                for (int n = 0; n < number_of_bars; n++) {\n                    if (p.stereo) {\n                        if (n < number_of_bars / 2)\n                            cut_off_frequency = plan->cut_off_frequency[number_of_bars / 2 - 1 - n];\n                        else\n                            cut_off_frequency = plan->cut_off_frequency[n - number_of_bars / 2];\n                    } else {\n                        cut_off_frequency = plan->cut_off_frequency[n];\n                    }\n\n                    float freq_kilohz = cut_off_frequency / 1000;\n                    int freq_floor = cut_off_frequency;\n\n                    if (output_mode == OUTPUT_NCURSES) {\n#ifdef NCURSES\n                        if (cut_off_frequency < 1000)\n                            mvprintw(lines, n * (p.bar_width + p.bar_spacing) + remainder, \"%-4d\",\n                                     freq_floor);\n                        else if (cut_off_frequency > 1000 && cut_off_frequency < 10000)\n                            mvprintw(lines, n * (p.bar_width + p.bar_spacing) + remainder, \"%.2f\",\n                                     freq_kilohz);\n                        else\n                            mvprintw(lines, n * (p.bar_width + p.bar_spacing) + remainder, \"%.1f\",\n                                     freq_kilohz);\n#endif\n                    } else if (output_mode == OUTPUT_NONCURSES) {\n                        if (cut_off_frequency < 1000)\n                            printf(\"%-4d\", freq_floor);\n                        else if (cut_off_frequency > 1000 && cut_off_frequency < 10000)\n                            printf(\"%.2f\", freq_kilohz);\n                        else\n                            printf(\"%.1f\", freq_kilohz);\n\n                        if (n < number_of_bars - 1)\n                            printf(\"\\033[%dC\", p.bar_width + p.bar_spacing - 4);\n                    }\n                }\n                printf(\"\\r\\033[%dA\", lines + 1);\n            }\n\n            bool resizeTerminal = false;\n\n            int frame_time_msec = (1 / (float)p.framerate) * 1000;\n            struct timespec framerate_timer = {.tv_sec = 0, .tv_nsec = 0};\n            if (p.framerate <= 1) {\n                framerate_timer.tv_sec = frame_time_msec / 1000;\n            } else {\n                framerate_timer.tv_sec = 0;\n                framerate_timer.tv_nsec = frame_time_msec * 1e6;\n            }\n#ifdef _MSC_VER\n            LARGE_INTEGER frequency; // ticks per second\n            LARGE_INTEGER t1, t2;    // ticks\n            double elapsedTime;\n            QueryPerformanceFrequency(&frequency);\n#endif // _MSC_VER\n\n            int sleep_counter = 0;\n            bool silence = false;\n            char ch = '\\0';\n\n#ifndef NDEBUG\n            int maxvalue = 0;\n            int minvalue = 0;\n#endif\n\n            struct timespec sleep_mode_timer = {.tv_sec = 1, .tv_nsec = 0};\n\n            int total_frames = 0;\n\n            while (!resizeTerminal) {\n\n// general: keyboard controls\n#ifdef NCURSES\n                if (output_mode == OUTPUT_NCURSES)\n                    ch = getch();\n#endif\n\n#ifndef _MSC_VER\n                if (output_mode == OUTPUT_NONCURSES)\n                    read(0, &ch, sizeof(ch));\n#endif\n\n                switch (ch) {\n                case 65: // key up\n                    p.sens = p.sens * 1.05;\n                    break;\n                case 66: // key down\n                    p.sens = p.sens * 0.95;\n                    break;\n                case 68: // key right\n                    p.bar_width++;\n                    resizeTerminal = true;\n                    break;\n                case 67: // key left\n                    if (p.bar_width > 1)\n                        p.bar_width--;\n                    resizeTerminal = true;\n                    break;\n                case 'r': // reload config\n                    should_reload = 1;\n                    break;\n                case 'c': // reload colors\n                    reload_colors = 1;\n                    break;\n                case 'f': // change forground color\n                    if (p.col < 7)\n                        p.col++;\n                    else\n                        p.col = 0;\n                    resizeTerminal = true;\n                    break;\n                case 'b': // change backround color\n                    if (p.bgcol < 7)\n                        p.bgcol++;\n                    else\n                        p.bgcol = 0;\n                    resizeTerminal = true;\n                    break;\n\n                case 'q':\n                    should_reload = 1;\n                    should_quit = 1;\n                }\n\n                ch = 0;\n\n                if (should_reload) {\n\n                    reloadConf = true;\n                    resizeTerminal = true;\n                    should_reload = 0;\n                }\n\n                if (reload_colors) {\n                    struct error_s error;\n                    error.length = 0;\n                    if (!load_config(configPath, (void *)&p, 1, &error)) {\n                        cleanup();\n                        fprintf(stderr, \"Error loading config. %s\", error.message);\n                        exit(EXIT_FAILURE);\n                    }\n                    resizeTerminal = true;\n                    reload_colors = 0;\n                }\n\n#ifndef NDEBUG\n                // clear();\n#ifndef _MSC_VER\n                refresh();\n#endif\n#endif\n\n                // process: check if input is present\n                silence = true;\n\n                for (int n = 0; n < audio.input_buffer_size * 4; n++) {\n                    if (audio.cava_in[n]) {\n                        silence = false;\n                        break;\n                    }\n                }\n#ifndef _MSC_VER\n\n                if (output_mode != OUTPUT_SDL) {\n                    if (p.sleep_timer) {\n                        if (silence && sleep_counter <= p.framerate * p.sleep_timer)\n                            sleep_counter++;\n                        else if (!silence)\n                            sleep_counter = 0;\n\n                        if (sleep_counter > p.framerate * p.sleep_timer) {\n#ifndef NDEBUG\n                            printw(\"no sound detected for 30 sec, going to sleep mode\\n\");\n#endif\n                            nanosleep(&sleep_mode_timer, NULL);\n                            continue;\n                        }\n                    }\n                }\n\n#endif // !_MSC_VER\n\n                // process: execute cava\n                pthread_mutex_lock(&audio.lock);\n                if (p.waveform) {\n                    for (int n = 0; n < audio.samples_counter; n++) {\n\n                        for (int i = number_of_bars - 1; i > 0; i--) {\n                            cava_out[i] = cava_out[i - 1];\n                        }\n                        if (audio_channels == 2) {\n                            cava_out[0] =\n                                p.sens * (audio.cava_in[n] / 2 + audio.cava_in[n + 1] / 2);\n                            n++;\n                        } else {\n                            cava_out[0] = p.sens * audio.cava_in[n];\n                        }\n                    }\n                } else {\n                    cava_execute(audio.cava_in, audio.samples_counter, cava_out, plan);\n                }\n                if (audio.samples_counter > 0) {\n                    audio.samples_counter = 0;\n                }\n                pthread_mutex_unlock(&audio.lock);\n\n                for (int n = 0; n < raw_number_of_bars; n++) {\n\n                    if (!p.waveform) {\n                        cava_out[n] *= p.sens;\n                    } else {\n                        if (cava_out[n] > 1.0)\n                            p.sens *= 0.999;\n                        else\n                            p.sens *= 1.00001;\n\n                        if (p.orientation != ORIENT_SPLIT_H)\n                            cava_out[n] = (cava_out[n] + 1.0) / 2.0;\n                    }\n\n                    if (output_mode == OUTPUT_SDL_GLSL) {\n                        if (cava_out[n] > 1.0)\n                            cava_out[n] = 1.0;\n                        else if (cava_out[n] < 0.0)\n                            cava_out[n] = 0.0;\n                    } else {\n                        cava_out[n] *= *dimension_value;\n                        if (p.orientation == ORIENT_SPLIT_H || p.orientation == ORIENT_SPLIT_V) {\n                            cava_out[n] /= 2;\n                        }\n                    }\n                    if (p.waveform) {\n                        bars_raw[n] = cava_out[n];\n                    }\n                }\n                if (!p.waveform) {\n                    if (audio_channels == 2) {\n                        for (int n = 0; n < number_of_bars / output_channels; n++) {\n                            if (p.userEQ_enabled)\n                                cava_out[n] *=\n                                    p.userEQ[(int)floor(((double)n) * userEQ_keys_to_bars_ratio)];\n                            bars_left[n] = cava_out[n];\n                        }\n                        for (int n = 0; n < number_of_bars / output_channels; n++) {\n                            if (p.userEQ_enabled)\n                                cava_out[n + number_of_bars / output_channels] *=\n                                    p.userEQ[(int)floor(((double)n) * userEQ_keys_to_bars_ratio)];\n                            bars_right[n] = cava_out[n + number_of_bars / output_channels];\n                        }\n                    } else {\n                        for (int n = 0; n < number_of_bars; n++) {\n                            if (p.userEQ_enabled)\n                                cava_out[n] *=\n                                    p.userEQ[(int)floor(((double)n) * userEQ_keys_to_bars_ratio)];\n                            bars_raw[n] = cava_out[n];\n                        }\n                    }\n\n                    // process [filter]\n                    if (p.monstercat) {\n                        if (audio_channels == 2) {\n                            bars_left =\n                                monstercat_filter(bars_left, number_of_bars / output_channels,\n                                                  p.waves, p.monstercat, *dimension_value);\n                            bars_right =\n                                monstercat_filter(bars_right, number_of_bars / output_channels,\n                                                  p.waves, p.monstercat, *dimension_value);\n                        } else {\n                            bars_raw = monstercat_filter(bars_raw, number_of_bars, p.waves,\n                                                         p.monstercat, *dimension_value);\n                        }\n                    }\n                    if (audio_channels == 2) {\n                        if (p.stereo) {\n                            // mirroring stereo channels\n                            for (int n = 0; n < number_of_bars; n++) {\n                                if (n < number_of_bars / 2) {\n                                    if (p.reverse) {\n                                        bars_raw[n] = bars_left[n];\n                                    } else {\n                                        bars_raw[n] = bars_left[number_of_bars / 2 - n - 1];\n                                    }\n                                } else {\n                                    if (p.reverse) {\n                                        bars_raw[n] = bars_right[number_of_bars - n - 1];\n                                    } else {\n                                        bars_raw[n] = bars_right[n - number_of_bars / 2];\n                                    }\n                                }\n                            }\n                        } else {\n                            // stereo mono output\n                            for (int n = 0; n < number_of_bars; n++) {\n                                if (p.reverse) {\n                                    if (p.mono_opt == AVERAGE) {\n                                        bars_raw[number_of_bars - n - 1] =\n                                            (bars_left[n] + bars_right[n]) / 2;\n                                    } else if (p.mono_opt == LEFT) {\n                                        bars_raw[number_of_bars - n - 1] = bars_left[n];\n                                    } else if (p.mono_opt == RIGHT) {\n                                        bars_raw[number_of_bars - n - 1] = bars_right[n];\n                                    }\n                                } else {\n                                    if (p.mono_opt == AVERAGE) {\n                                        bars_raw[n] = (bars_left[n] + bars_right[n]) / 2;\n                                    } else if (p.mono_opt == LEFT) {\n                                        bars_raw[n] = bars_left[n];\n                                    } else if (p.mono_opt == RIGHT) {\n                                        bars_raw[n] = bars_right[n];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n#ifdef SDL_GLSL\n                int re_paint = 0;\n#endif\n                for (int n = 0; n < number_of_bars; n++) {\n                    bars[n] = bars_raw[n];\n                    // show idle bar heads\n                    if (output_mode != OUTPUT_RAW && output_mode != OUTPUT_NORITAKE &&\n                        bars[n] < 1 && p.waveform == 0 && p.show_idle_bar_heads == 1)\n                        bars[n] = 1;\n#ifdef SDL_GLSL\n\n                    if (output_mode == OUTPUT_SDL_GLSL)\n                        bars[n] =\n                            bars_raw[n] * 1000; // values are 0-1, only used to check for changes\n\n                    if (bars[n] != previous_frame[n])\n                        re_paint = 1;\n#endif\n\n#ifndef NDEBUG\n                    mvprintw(n, 0, \"%d: f:%f->%f (%d->%d), eq:\\\n\t\t\t\t\t\t%15e, peak:%d \\n\",\n                             n, plan->cut_off_frequency[n], plan->cut_off_frequency[n + 1],\n                             plan->FFTbuffer_lower_cut_off[n], plan->FFTbuffer_upper_cut_off[n],\n                             plan->eq[n], bars[n]);\n\n                    if (bars[n] < minvalue) {\n                        minvalue = bars[n];\n                        debug(\"min value: %d\\n\", minvalue); // checking maxvalue 10000\n                    }\n                    if (bars[n] > maxvalue) {\n                        maxvalue = bars[n];\n                    }\n                    if (bars[n] < 0) {\n                        debug(\"negative bar value!! %d\\n\", bars[n]);\n                        //    exit(EXIT_FAILURE); // Can't happen.\n                    }\n\n#endif\n                }\n\n#ifndef NDEBUG\n                mvprintw(number_of_bars + 1, 0, \"sensitivity %.10e\", p.sens);\n                mvprintw(number_of_bars + 2, 0, \"min value: %d\\n\",\n                         minvalue); // checking maxvalue 10000\n                mvprintw(number_of_bars + 3, 0, \"max value: %d\\n\",\n                         maxvalue); // checking maxvalue 10000\n#ifndef _MSC_VER\n                (void)x_axis_info;\n#endif // !_MSC_VER\n#endif\n\n// output: draw processed input\n#ifdef NDEBUG\n                if (p.sync_updates) {\n                    printf(\"\\033[2026h\\033\\\\\");\n                    fflush(stdout);\n                    printf(\"\\033[2026l\\033\\\\\");\n                }\n                int rc;\n#ifdef _MSC_VER\n                QueryPerformanceCounter(&t1);\n#endif\n                switch (output_mode) {\n#ifdef SDL\n                case OUTPUT_SDL:\n                    rc = draw_sdl(number_of_bars, p.bar_width, p.bar_spacing, remainder,\n                                  *dimension_value, bars, previous_frame, frame_time_msec,\n                                  p.orientation, p.gradient);\n\n                    break;\n#endif\n#ifdef SDL_GLSL\n                case OUTPUT_SDL_GLSL:\n                    rc = draw_sdl_glsl(number_of_bars, bars_raw, frame_time_msec, re_paint,\n                                       p.continuous_rendering);\n                    break;\n#endif\n                case OUTPUT_NONCURSES:\n                    if (p.orientation == ORIENT_SPLIT_H) {\n                        rc = draw_terminal_noncurses(inAtty, lines, width, number_of_bars,\n                                                     p.bar_width, p.bar_spacing, remainder, bars,\n                                                     previous_frame, p.gradient, x_axis_info,\n                                                     ORIENT_BOTTOM, 1);\n                        rc = draw_terminal_noncurses(inAtty, lines, width, number_of_bars,\n                                                     p.bar_width, p.bar_spacing, remainder, bars,\n                                                     previous_frame, p.gradient, x_axis_info,\n                                                     ORIENT_TOP, 1);\n                    } else {\n                        rc = draw_terminal_noncurses(inAtty, lines, width, number_of_bars,\n                                                     p.bar_width, p.bar_spacing, remainder, bars,\n                                                     previous_frame, p.gradient, x_axis_info,\n                                                     p.orientation, 0);\n                    }\n                    break;\n                case OUTPUT_NCURSES:\n#ifdef NCURSES\n                    rc = draw_terminal_ncurses(inAtty, *dimension_value / 8, *dimension_bar,\n                                               number_of_bars, p.bar_width, p.bar_spacing,\n                                               remainder, bars, previous_frame, p.gradient,\n                                               x_axis_info, p.orientation);\n                    break;\n#endif\n#ifndef _MSC_VER\n                case OUTPUT_RAW:\n                    rc = print_raw_out(number_of_bars, fp, p.raw_format, p.bit_format,\n                                       p.ascii_range, p.bar_delim, p.frame_delim, bars);\n                    break;\n                case OUTPUT_NORITAKE:\n                    rc = print_ntk_out(number_of_bars, fp, p.bit_format, p.bar_width, p.bar_spacing,\n                                       p.bar_height, bars);\n                    break;\n\n#endif // !_MSC_VER\n                default:\n                    exit(EXIT_FAILURE); // Can't happen.\n                }\n\n                if (p.sync_updates) {\n                    printf(\"\\033[2026h\\033\\\\\");\n                    fflush(stdout);\n                    printf(\"\\033[2026l\\033\\\\\");\n                }\n                // terminal has been resized breaking to recalibrating values\n                if (rc == -1)\n                    resizeTerminal = true;\n\n                if (rc == -2) {\n                    resizeTerminal = true;\n                    reloadConf = true;\n                    should_quit = true;\n                }\n\n#endif\n\n                memcpy(previous_frame, bars, number_of_bars * sizeof(int));\n\n                // checking if audio thread has exited unexpectedly\n                pthread_mutex_lock(&audio.lock);\n                if (audio.terminate == 1) {\n                    cleanup();\n                    fprintf(stderr, \"Audio thread exited unexpectedly. %s\\n\", audio.error_message);\n                    exit(EXIT_FAILURE);\n                }\n                pthread_mutex_unlock(&audio.lock);\n#ifdef _MSC_VER\n                QueryPerformanceCounter(&t2);\n                elapsedTime = (t2.QuadPart - t1.QuadPart) * 1000.0 / frequency.QuadPart;\n                int fps_sync_time = frame_time_msec;\n                if (elapsedTime < 1.0)\n                    fps_sync_time = frame_time_msec;\n                else if ((int)elapsedTime > frame_time_msec)\n                    fps_sync_time = 0;\n                else\n                    fps_sync_time = (frame_time_msec - (int)elapsedTime) / 2;\n#endif\n                if (output_mode != OUTPUT_SDL && output_mode != OUTPUT_SDL_GLSL) {\n#ifdef _MSC_VER\n                    Sleep(fps_sync_time);\n#else\n                    nanosleep(&framerate_timer, NULL);\n#endif\n                }\n\n                if (p.draw_and_quit > 0) {\n                    total_frames++;\n                    if (total_frames >= p.draw_and_quit) {\n                        for (int n = 0; n < number_of_bars; n++) {\n                            if (output_mode != OUTPUT_RAW && output_mode != OUTPUT_NORITAKE &&\n                                bars[n] == 1) {\n                                bars[n] = 0;\n                            }\n                            total_bar_height += bars[n];\n                        }\n                        resizeTerminal = true;\n                        reloadConf = true;\n                        should_quit = true;\n                        break;\n                    }\n                }\n            } // resize terminal\n            cava_destroy(plan);\n            free(plan);\n            if (audio_channels == 2) {\n                free(bars_left);\n                free(bars_right);\n            }\n            free(cava_out);\n            free(bars);\n            free(bars_raw);\n            free(previous_frame);\n        } // reloading config\n\n        //**telling audio thread to terminate**//\n        pthread_mutex_lock(&audio.lock);\n        audio.terminate = 1;\n        pthread_mutex_unlock(&audio.lock);\n        pthread_join(p_thread, NULL);\n\n        if (p.userEQ_enabled)\n            free(p.userEQ);\n\n        free(audio.source);\n        free(audio.cava_in);\n        cleanup();\n\n        if (should_quit) {\n            if (p.zero_test && total_bar_height > 0) {\n                fprintf(stderr, \"Test mode: expected total bar height to be zero, but was: %d\\n\",\n                        total_bar_height);\n                return EXIT_FAILURE;\n            } else if (p.non_zero_test && total_bar_height == 0) {\n                fprintf(stderr,\n                        \"Test mode: expected total bar height to be non-zero, but was zero\\n\");\n                return EXIT_FAILURE;\n            } else {\n                return EXIT_SUCCESS;\n            }\n        }\n        // fclose(fp);\n    }\n}\n"
        },
        {
          "name": "cava.psf",
          "type": "blob",
          "size": 4.724609375,
          "content": null
        },
        {
          "name": "cava_win",
          "type": "tree",
          "content": null
        },
        {
          "name": "cavacore.c",
          "type": "blob",
          "size": 24.591796875,
          "content": "#include \"cavacore.h\"\n#ifndef M_PI\n#define M_PI 3.1415926535897932385\n#endif\n#include <fftw3.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef __ANDROID__\n#include <jni.h>\nstruct cava_plan *plan;\ndouble *cava_in;\ndouble *cava_out;\n#endif\n\nstruct cava_plan *cava_init(int number_of_bars, unsigned int rate, int channels, int autosens,\n                            double noise_reduction, int low_cut_off, int high_cut_off) {\n    struct cava_plan *p = malloc(sizeof(struct cava_plan));\n    p->status = 0;\n\n    // sanity checks:\n    if (channels < 1 || channels > 2) {\n        snprintf(p->error_message, 1024,\n                 \"cava_init called with illegal number of channels: %d, number of channels \"\n                 \"supported are \"\n                 \"1 and 2\",\n                 channels);\n        p->status = -1;\n        return p;\n    }\n    if (rate < 1 || rate > 384000) {\n        snprintf(p->error_message, 1024, \"cava_init called with illegal sample rate: %d\\n\", rate);\n        p->status = -1;\n        return p;\n    }\n\n    int treble_buffer_size = 128;\n\n    if (rate > 8125 && rate <= 16250)\n        treble_buffer_size *= 2;\n    else if (rate > 16250 && rate <= 32500)\n        treble_buffer_size *= 4;\n    else if (rate > 32500 && rate <= 75000)\n        treble_buffer_size *= 8;\n    else if (rate > 75000 && rate <= 150000)\n        treble_buffer_size *= 16;\n    else if (rate > 150000 && rate <= 300000)\n        treble_buffer_size *= 32;\n    else if (rate > 300000)\n        treble_buffer_size *= 64;\n\n    if (number_of_bars < 1) {\n        snprintf(p->error_message, 1024,\n                 \"cava_init called with illegal number of bars: %d, number of channels must be \"\n                 \"positive integer\\n\",\n                 number_of_bars);\n        p->status = -1;\n        return p;\n    }\n\n    if (number_of_bars > treble_buffer_size / 2 + 1) {\n        snprintf(p->error_message, 1024,\n                 \"cava_init called with illegal number of bars: %d, for %d sample rate number of \"\n                 \"bars can't be more than %d\\n\",\n                 number_of_bars, rate, treble_buffer_size / 2 + 1);\n        p->status = -1;\n        return p;\n    }\n    if (low_cut_off < 1 || high_cut_off < 1) {\n        snprintf(p->error_message, 1024, \"low_cut_off must be a positive value\\n\");\n        p->status = -1;\n        return p;\n    }\n    if (low_cut_off >= high_cut_off) {\n        snprintf(p->error_message, 1024, \"high_cut_off must be a higher than low_cut_off\\n\");\n        p->status = -1;\n        return p;\n    }\n    if ((unsigned int)high_cut_off > rate / 2) {\n        snprintf(p->error_message, 1024,\n                 \"high_cut_off can't be higher than sample rate / 2. (Nyquist Sampling Theorem)\\n\");\n        p->status = -1;\n        return p;\n    }\n\n    p->number_of_bars = number_of_bars;\n    p->audio_channels = channels;\n    p->rate = rate;\n    p->autosens = 1;\n    p->sens_init = 1;\n    p->sens = 1.0;\n    p->autosens = autosens;\n    p->framerate = 75;\n    p->frame_skip = 1;\n    p->noise_reduction = noise_reduction;\n\n    int fftw_flag = FFTW_MEASURE;\n#ifdef __ANDROID__\n    fftw_flag = FFTW_ESTIMATE;\n#endif\n\n    p->FFTbassbufferSize = treble_buffer_size * 8;\n    p->FFTmidbufferSize = treble_buffer_size * 4;\n    p->FFTtreblebufferSize = treble_buffer_size;\n\n    p->input_buffer_size = p->FFTbassbufferSize * channels;\n\n    p->input_buffer = (double *)malloc(p->input_buffer_size * sizeof(double));\n\n    p->FFTbuffer_lower_cut_off = (int *)malloc((number_of_bars + 1) * sizeof(int));\n    p->FFTbuffer_upper_cut_off = (int *)malloc((number_of_bars + 1) * sizeof(int));\n    p->eq = (double *)malloc((number_of_bars + 1) * sizeof(double));\n    p->cut_off_frequency = (float *)malloc((number_of_bars + 1) * sizeof(float));\n\n    p->cava_fall = (double *)malloc(number_of_bars * channels * sizeof(double));\n    p->cava_mem = (double *)malloc(number_of_bars * channels * sizeof(double));\n    p->cava_peak = (double *)malloc(number_of_bars * channels * sizeof(double));\n    p->prev_cava_out = (double *)malloc(number_of_bars * channels * sizeof(double));\n\n    // Hann Window calculate multipliers\n    p->bass_multiplier = (double *)malloc(p->FFTbassbufferSize * sizeof(double));\n    p->mid_multiplier = (double *)malloc(p->FFTmidbufferSize * sizeof(double));\n    p->treble_multiplier = (double *)malloc(p->FFTtreblebufferSize * sizeof(double));\n    for (int i = 0; i < p->FFTbassbufferSize; i++) {\n        p->bass_multiplier[i] = 0.5 * (1 - cos(2 * M_PI * i / (p->FFTbassbufferSize - 1)));\n    }\n    for (int i = 0; i < p->FFTmidbufferSize; i++) {\n        p->mid_multiplier[i] = 0.5 * (1 - cos(2 * M_PI * i / (p->FFTmidbufferSize - 1)));\n    }\n    for (int i = 0; i < p->FFTtreblebufferSize; i++) {\n        p->treble_multiplier[i] = 0.5 * (1 - cos(2 * M_PI * i / (p->FFTtreblebufferSize - 1)));\n    }\n\n    // BASS\n    p->in_bass_l = fftw_alloc_real(p->FFTbassbufferSize);\n    p->in_bass_l_raw = fftw_alloc_real(p->FFTbassbufferSize);\n    p->out_bass_l = fftw_alloc_complex(p->FFTbassbufferSize / 2 + 1);\n    p->p_bass_l =\n        fftw_plan_dft_r2c_1d(p->FFTbassbufferSize, p->in_bass_l, p->out_bass_l, fftw_flag);\n\n    // MID\n    p->in_mid_l = fftw_alloc_real(p->FFTmidbufferSize);\n    p->in_mid_l_raw = fftw_alloc_real(p->FFTmidbufferSize);\n    p->out_mid_l = fftw_alloc_complex(p->FFTmidbufferSize / 2 + 1);\n    p->p_mid_l = fftw_plan_dft_r2c_1d(p->FFTmidbufferSize, p->in_mid_l, p->out_mid_l, fftw_flag);\n\n    // TREBLE\n    p->in_treble_l = fftw_alloc_real(p->FFTtreblebufferSize);\n    p->in_treble_l_raw = fftw_alloc_real(p->FFTtreblebufferSize);\n    p->out_treble_l = fftw_alloc_complex(p->FFTtreblebufferSize / 2 + 1);\n    p->p_treble_l =\n        fftw_plan_dft_r2c_1d(p->FFTtreblebufferSize, p->in_treble_l, p->out_treble_l, fftw_flag);\n\n    memset(p->in_bass_l, 0, sizeof(double) * p->FFTbassbufferSize);\n    memset(p->in_mid_l, 0, sizeof(double) * p->FFTmidbufferSize);\n    memset(p->in_treble_l, 0, sizeof(double) * p->FFTtreblebufferSize);\n    memset(p->in_bass_l_raw, 0, sizeof(double) * p->FFTbassbufferSize);\n    memset(p->in_mid_l_raw, 0, sizeof(double) * p->FFTmidbufferSize);\n    memset(p->in_treble_l_raw, 0, sizeof(double) * p->FFTtreblebufferSize);\n    memset(p->out_bass_l, 0, (p->FFTbassbufferSize / 2 + 1) * sizeof(fftw_complex));\n    memset(p->out_mid_l, 0, (p->FFTmidbufferSize / 2 + 1) * sizeof(fftw_complex));\n    memset(p->out_treble_l, 0, (p->FFTtreblebufferSize / 2 + 1) * sizeof(fftw_complex));\n    if (p->audio_channels == 2) {\n        // BASS\n        p->in_bass_r = fftw_alloc_real(p->FFTbassbufferSize);\n        p->in_bass_r_raw = fftw_alloc_real(p->FFTbassbufferSize);\n        p->out_bass_r = fftw_alloc_complex(p->FFTbassbufferSize / 2 + 1);\n        p->p_bass_r =\n            fftw_plan_dft_r2c_1d(p->FFTbassbufferSize, p->in_bass_r, p->out_bass_r, fftw_flag);\n\n        // MID\n        p->in_mid_r = fftw_alloc_real(p->FFTmidbufferSize);\n        p->in_mid_r_raw = fftw_alloc_real(p->FFTmidbufferSize);\n        p->out_mid_r = fftw_alloc_complex(p->FFTmidbufferSize / 2 + 1);\n        p->p_mid_r =\n            fftw_plan_dft_r2c_1d(p->FFTmidbufferSize, p->in_mid_r, p->out_mid_r, fftw_flag);\n\n        // TREBLE\n        p->in_treble_r = fftw_alloc_real(p->FFTtreblebufferSize);\n        p->in_treble_r_raw = fftw_alloc_real(p->FFTtreblebufferSize);\n        p->out_treble_r = fftw_alloc_complex(p->FFTtreblebufferSize / 2 + 1);\n\n        p->p_treble_r = fftw_plan_dft_r2c_1d(p->FFTtreblebufferSize, p->in_treble_r,\n                                             p->out_treble_r, fftw_flag);\n\n        memset(p->in_bass_r, 0, sizeof(double) * p->FFTbassbufferSize);\n        memset(p->in_mid_r, 0, sizeof(double) * p->FFTmidbufferSize);\n        memset(p->in_treble_r, 0, sizeof(double) * p->FFTtreblebufferSize);\n        memset(p->in_bass_r_raw, 0, sizeof(double) * p->FFTbassbufferSize);\n        memset(p->in_mid_r_raw, 0, sizeof(double) * p->FFTmidbufferSize);\n        memset(p->in_treble_r_raw, 0, sizeof(double) * p->FFTtreblebufferSize);\n        memset(p->out_bass_r, 0, (p->FFTbassbufferSize / 2 + 1) * sizeof(fftw_complex));\n        memset(p->out_mid_r, 0, (p->FFTmidbufferSize / 2 + 1) * sizeof(fftw_complex));\n        memset(p->out_treble_r, 0, (p->FFTtreblebufferSize / 2 + 1) * sizeof(fftw_complex));\n    }\n\n    memset(p->input_buffer, 0, sizeof(double) * p->input_buffer_size);\n\n    memset(p->cava_fall, 0, sizeof(int) * number_of_bars * channels);\n    memset(p->cava_mem, 0, sizeof(double) * number_of_bars * channels);\n    memset(p->cava_peak, 0, sizeof(double) * number_of_bars * channels);\n    memset(p->prev_cava_out, 0, sizeof(double) * number_of_bars * channels);\n\n    // process: calculate cutoff frequencies and eq\n    int lower_cut_off = low_cut_off;\n    int upper_cut_off = high_cut_off;\n    int bass_cut_off = 100;\n    int treble_cut_off = 500;\n\n    // calculate frequency constant (used to distribute bars across the frequency band)\n    double frequency_constant = log10((float)lower_cut_off / (float)upper_cut_off) /\n                                (1 / ((float)p->number_of_bars + 1) - 1);\n\n    float *relative_cut_off = (float *)malloc((p->number_of_bars + 1) * sizeof(float));\n\n    p->bass_cut_off_bar = -1;\n    p->treble_cut_off_bar = -1;\n    int first_bar = 1;\n    int first_treble_bar = 0;\n    int *bar_buffer = (int *)malloc((p->number_of_bars + 1) * sizeof(int));\n\n    for (int n = 0; n < p->number_of_bars + 1; n++) {\n        double bar_distribution_coefficient = frequency_constant * (-1);\n        bar_distribution_coefficient +=\n            ((float)n + 1) / ((float)p->number_of_bars + 1) * frequency_constant;\n        p->cut_off_frequency[n] = upper_cut_off * pow(10, bar_distribution_coefficient);\n\n        if (n > 0) {\n            if (p->cut_off_frequency[n - 1] >= p->cut_off_frequency[n] &&\n                p->cut_off_frequency[n - 1] > bass_cut_off)\n                p->cut_off_frequency[n] =\n                    p->cut_off_frequency[n - 1] +\n                    (p->cut_off_frequency[n - 1] - p->cut_off_frequency[n - 2]);\n        }\n\n        relative_cut_off[n] = p->cut_off_frequency[n] / (p->rate / 2);\n        // remember nyquist!, per my calculations this should be rate/2\n        // and nyquist freq in M/2 but testing shows it is not...\n        // or maybe the nq freq is in M/4\n\n        p->eq[n] = pow(p->cut_off_frequency[n], 1);\n\n        // the numbers that come out of the FFT are verry high\n        // the EQ is used to \"normalize\" them by dividing with this very huge number\n        p->eq[n] /= pow(2, 29);\n\n        p->eq[n] /= log2(p->FFTbassbufferSize);\n\n        if (p->cut_off_frequency[n] < bass_cut_off) {\n            // BASS\n            bar_buffer[n] = 1;\n            p->FFTbuffer_lower_cut_off[n] = relative_cut_off[n] * (p->FFTbassbufferSize / 2);\n            p->bass_cut_off_bar++;\n            p->treble_cut_off_bar++;\n            if (p->bass_cut_off_bar > 0)\n                first_bar = 0;\n\n            if (p->FFTbuffer_lower_cut_off[n] > p->FFTbassbufferSize / 2) {\n                p->FFTbuffer_lower_cut_off[n] = p->FFTbassbufferSize / 2;\n            }\n        } else if (p->cut_off_frequency[n] > bass_cut_off &&\n                   p->cut_off_frequency[n] < treble_cut_off) {\n            // MID\n            bar_buffer[n] = 2;\n            p->FFTbuffer_lower_cut_off[n] = relative_cut_off[n] * (p->FFTmidbufferSize / 2);\n            p->treble_cut_off_bar++;\n            if ((p->treble_cut_off_bar - p->bass_cut_off_bar) == 1) {\n                first_bar = 1;\n                if (n > 0) {\n                    p->FFTbuffer_upper_cut_off[n - 1] =\n                        relative_cut_off[n] * (p->FFTbassbufferSize / 2);\n                }\n            } else {\n                first_bar = 0;\n            }\n\n            if (p->FFTbuffer_lower_cut_off[n] > p->FFTmidbufferSize / 2) {\n                p->FFTbuffer_lower_cut_off[n] = p->FFTmidbufferSize / 2;\n            }\n        } else {\n            // TREBLE\n            bar_buffer[n] = 3;\n            p->FFTbuffer_lower_cut_off[n] = relative_cut_off[n] * (p->FFTtreblebufferSize / 2);\n            first_treble_bar++;\n            if (first_treble_bar == 1) {\n                first_bar = 1;\n                if (n > 0) {\n                    p->FFTbuffer_upper_cut_off[n - 1] =\n                        relative_cut_off[n] * (p->FFTmidbufferSize / 2);\n                }\n            } else {\n                first_bar = 0;\n            }\n\n            if (p->FFTbuffer_lower_cut_off[n] > p->FFTtreblebufferSize / 2) {\n                p->FFTbuffer_lower_cut_off[n] = p->FFTtreblebufferSize / 2;\n            }\n        }\n\n        if (n > 0) {\n            if (!first_bar) {\n                p->FFTbuffer_upper_cut_off[n - 1] = p->FFTbuffer_lower_cut_off[n] - 1;\n\n                // pushing the spectrum up if the exponential function gets \"clumped\" in the\n                // bass and caluclating new cut off frequencies\n                if (p->FFTbuffer_lower_cut_off[n] <= p->FFTbuffer_lower_cut_off[n - 1]) {\n\n                    // check if there is room for more first\n                    int room_for_more = 0;\n\n                    if (bar_buffer[n] == 1) {\n                        if (p->FFTbuffer_lower_cut_off[n - 1] + 1 < p->FFTbassbufferSize / 2 + 1)\n                            room_for_more = 1;\n                    } else if (bar_buffer[n] == 2) {\n                        if (p->FFTbuffer_lower_cut_off[n - 1] + 1 < p->FFTmidbufferSize / 2 + 1)\n                            room_for_more = 1;\n                    } else if (bar_buffer[n] == 3) {\n                        if (p->FFTbuffer_lower_cut_off[n - 1] + 1 < p->FFTtreblebufferSize / 2 + 1)\n                            room_for_more = 1;\n                    }\n\n                    if (room_for_more) {\n                        // push the spectrum up\n                        p->FFTbuffer_lower_cut_off[n] = p->FFTbuffer_lower_cut_off[n - 1] + 1;\n                        p->FFTbuffer_upper_cut_off[n - 1] = p->FFTbuffer_lower_cut_off[n] - 1;\n\n                        // calculate new cut off frequency\n                        if (bar_buffer[n] == 1)\n                            relative_cut_off[n] = (float)(p->FFTbuffer_lower_cut_off[n]) /\n                                                  ((float)p->FFTbassbufferSize / 2);\n                        else if (bar_buffer[n] == 2)\n                            relative_cut_off[n] = (float)(p->FFTbuffer_lower_cut_off[n]) /\n                                                  ((float)p->FFTmidbufferSize / 2);\n                        else if (bar_buffer[n] == 3)\n                            relative_cut_off[n] = (float)(p->FFTbuffer_lower_cut_off[n]) /\n                                                  ((float)p->FFTtreblebufferSize / 2);\n\n                        p->cut_off_frequency[n] = relative_cut_off[n] * ((float)p->rate / 2);\n                    }\n                }\n            } else {\n                if (p->FFTbuffer_upper_cut_off[n - 1] <= p->FFTbuffer_lower_cut_off[n - 1])\n                    p->FFTbuffer_upper_cut_off[n - 1] = p->FFTbuffer_lower_cut_off[n - 1] + 1;\n            }\n        }\n    }\n    free(bar_buffer);\n    free(relative_cut_off);\n    return p;\n}\n\nvoid cava_execute(double *cava_in, int new_samples, double *cava_out, struct cava_plan *p) {\n\n    // do not overflow\n    if (new_samples > p->input_buffer_size) {\n        new_samples = p->input_buffer_size;\n    }\n\n    int silence = 1;\n    if (new_samples > 0) {\n        p->framerate -= p->framerate / 64;\n        p->framerate += (double)((p->rate * p->audio_channels * p->frame_skip) / new_samples) / 64;\n        p->frame_skip = 1;\n        // shifting input buffer\n        for (uint16_t n = p->input_buffer_size - 1; n >= new_samples; n--) {\n            p->input_buffer[n] = p->input_buffer[n - new_samples];\n        }\n\n        // fill the input buffer\n        for (uint16_t n = 0; n < new_samples; n++) {\n            p->input_buffer[new_samples - n - 1] = cava_in[n];\n            if (cava_in[n]) {\n                silence = 0;\n            }\n        }\n    } else {\n        p->frame_skip++;\n    }\n\n    // fill the bass, mid and treble buffers\n    for (uint16_t n = 0; n < p->FFTbassbufferSize; n++) {\n        if (p->audio_channels == 2) {\n            p->in_bass_r_raw[n] = p->input_buffer[n * 2];\n            p->in_bass_l_raw[n] = p->input_buffer[n * 2 + 1];\n        } else {\n            p->in_bass_l_raw[n] = p->input_buffer[n];\n        }\n    }\n    for (uint16_t n = 0; n < p->FFTmidbufferSize; n++) {\n        if (p->audio_channels == 2) {\n            p->in_mid_r_raw[n] = p->input_buffer[n * 2];\n            p->in_mid_l_raw[n] = p->input_buffer[n * 2 + 1];\n        } else {\n            p->in_mid_l_raw[n] = p->input_buffer[n];\n        }\n    }\n    for (uint16_t n = 0; n < p->FFTtreblebufferSize; n++) {\n        if (p->audio_channels == 2) {\n            p->in_treble_r_raw[n] = p->input_buffer[n * 2];\n            p->in_treble_l_raw[n] = p->input_buffer[n * 2 + 1];\n        } else {\n            p->in_treble_l_raw[n] = p->input_buffer[n];\n        }\n    }\n\n    // Hann Window\n    for (int i = 0; i < p->FFTbassbufferSize; i++) {\n        p->in_bass_l[i] = p->bass_multiplier[i] * p->in_bass_l_raw[i];\n        if (p->audio_channels == 2)\n            p->in_bass_r[i] = p->bass_multiplier[i] * p->in_bass_r_raw[i];\n    }\n    for (int i = 0; i < p->FFTmidbufferSize; i++) {\n        p->in_mid_l[i] = p->mid_multiplier[i] * p->in_mid_l_raw[i];\n        if (p->audio_channels == 2)\n            p->in_mid_r[i] = p->mid_multiplier[i] * p->in_mid_r_raw[i];\n    }\n    for (int i = 0; i < p->FFTtreblebufferSize; i++) {\n        p->in_treble_l[i] = p->treble_multiplier[i] * p->in_treble_l_raw[i];\n        if (p->audio_channels == 2)\n            p->in_treble_r[i] = p->treble_multiplier[i] * p->in_treble_r_raw[i];\n    }\n\n    // process: execute FFT and sort frequency bands\n\n    fftw_execute(p->p_bass_l);\n    fftw_execute(p->p_mid_l);\n    fftw_execute(p->p_treble_l);\n    if (p->audio_channels == 2) {\n        fftw_execute(p->p_bass_r);\n        fftw_execute(p->p_mid_r);\n        fftw_execute(p->p_treble_r);\n    }\n\n    // process: separate frequency bands\n    for (int n = 0; n < p->number_of_bars; n++) {\n\n        double temp_l = 0;\n        double temp_r = 0;\n\n        // process: add upp FFT values within bands\n        for (int i = p->FFTbuffer_lower_cut_off[n]; i <= p->FFTbuffer_upper_cut_off[n]; i++) {\n\n            if (n <= p->bass_cut_off_bar) {\n                temp_l += hypot(p->out_bass_l[i][0], p->out_bass_l[i][1]);\n                if (p->audio_channels == 2)\n                    temp_r += hypot(p->out_bass_r[i][0], p->out_bass_r[i][1]);\n\n            } else if (n > p->bass_cut_off_bar && n <= p->treble_cut_off_bar) {\n\n                temp_l += hypot(p->out_mid_l[i][0], p->out_mid_l[i][1]);\n                if (p->audio_channels == 2)\n                    temp_r += hypot(p->out_mid_r[i][0], p->out_mid_r[i][1]);\n\n            } else if (n > p->treble_cut_off_bar) {\n\n                temp_l += hypot(p->out_treble_l[i][0], p->out_treble_l[i][1]);\n                if (p->audio_channels == 2)\n                    temp_r += hypot(p->out_treble_r[i][0], p->out_treble_r[i][1]);\n            }\n        }\n\n        // getting average multiply with eq\n        temp_l /= p->FFTbuffer_upper_cut_off[n] - p->FFTbuffer_lower_cut_off[n] + 1;\n        temp_l *= p->eq[n];\n        cava_out[n] = temp_l;\n\n        if (p->audio_channels == 2) {\n            temp_r /= p->FFTbuffer_upper_cut_off[n] - p->FFTbuffer_lower_cut_off[n] + 1;\n            temp_r *= p->eq[n];\n            cava_out[n + p->number_of_bars] = temp_r;\n        }\n    }\n\n    // applying sens or getting max value\n    if (p->autosens) {\n        for (int n = 0; n < p->number_of_bars * p->audio_channels; n++) {\n            cava_out[n] *= p->sens;\n        }\n    }\n    // process [smoothing]\n    int overshoot = 0;\n    double gravity_mod = pow((60 / p->framerate), 2.5) * 1.54 / p->noise_reduction;\n\n    if (gravity_mod < 1)\n        gravity_mod = 1;\n\n    for (int n = 0; n < p->number_of_bars * p->audio_channels; n++) {\n\n        // process [smoothing]: falloff\n\n        if (cava_out[n] < p->prev_cava_out[n] && p->noise_reduction > 0.1) {\n            cava_out[n] =\n                p->cava_peak[n] * (1.0 - (p->cava_fall[n] * p->cava_fall[n] * gravity_mod));\n\n            if (cava_out[n] < 0.0)\n                cava_out[n] = 0.0;\n            p->cava_fall[n] += 0.028;\n        } else {\n            p->cava_peak[n] = cava_out[n];\n            p->cava_fall[n] = 0.0;\n        }\n        p->prev_cava_out[n] = cava_out[n];\n\n        // process [smoothing]: integral\n        cava_out[n] = p->cava_mem[n] * p->noise_reduction + cava_out[n];\n        p->cava_mem[n] = cava_out[n];\n        if (p->autosens) {\n            // check if we overshoot target height\n            if (cava_out[n] > 1.0) {\n                overshoot = 1;\n            }\n        }\n    }\n\n    // calculating automatic sense adjustment\n    if (p->autosens) {\n        if (overshoot) {\n            p->sens = p->sens * 0.98;\n            p->sens_init = 0;\n        } else {\n            if (!silence) {\n                p->sens = p->sens * 1.002;\n                if (p->sens_init)\n                    p->sens = p->sens * 1.1;\n            }\n        }\n    }\n}\n\nvoid cava_destroy(struct cava_plan *p) {\n\n    free(p->input_buffer);\n    free(p->bass_multiplier);\n    free(p->mid_multiplier);\n    free(p->treble_multiplier);\n    free(p->eq);\n    free(p->cut_off_frequency);\n    free(p->FFTbuffer_lower_cut_off);\n    free(p->FFTbuffer_upper_cut_off);\n    free(p->cava_fall);\n    free(p->cava_mem);\n    free(p->cava_peak);\n    free(p->prev_cava_out);\n\n    fftw_free(p->in_bass_l);\n    fftw_free(p->in_bass_l_raw);\n    fftw_free(p->out_bass_l);\n    fftw_destroy_plan(p->p_bass_l);\n\n    fftw_free(p->in_mid_l);\n    fftw_free(p->in_mid_l_raw);\n    fftw_free(p->out_mid_l);\n    fftw_destroy_plan(p->p_mid_l);\n\n    fftw_free(p->in_treble_l);\n    fftw_free(p->in_treble_l_raw);\n    fftw_free(p->out_treble_l);\n    fftw_destroy_plan(p->p_treble_l);\n\n    if (p->audio_channels == 2) {\n        fftw_free(p->in_bass_r);\n        fftw_free(p->in_bass_r_raw);\n        fftw_free(p->out_bass_r);\n        fftw_destroy_plan(p->p_bass_r);\n\n        fftw_free(p->in_mid_r);\n        fftw_free(p->in_mid_r_raw);\n        fftw_free(p->out_mid_r);\n        fftw_destroy_plan(p->p_mid_r);\n\n        fftw_free(p->in_treble_r);\n        fftw_free(p->out_treble_r);\n        fftw_free(p->in_treble_r_raw);\n        fftw_destroy_plan(p->p_treble_r);\n    }\n}\n\n#ifdef __ANDROID__\nJNIEXPORT jfloatArray JNICALL Java_com_karlstav_cava_MyGLRenderer_InitCava(\n    JNIEnv *env, jobject thiz, jint number_of_bars_set, jint refresh_rate, jint lower_cut_off,\n    jint higher_cut_off) {\n    jfloatArray cuttOffFreq = (*env)->NewFloatArray(env, number_of_bars_set + 1);\n    float noise_reduction = pow((float)refresh_rate / 130, 0.75);\n\n    plan =\n        cava_init(number_of_bars_set, 44100, 1, 1, noise_reduction, lower_cut_off, higher_cut_off);\n    cava_in = (double *)malloc(plan->FFTbassbufferSize * sizeof(double));\n    cava_out = (double *)malloc(plan->number_of_bars * sizeof(double));\n    (*env)->SetFloatArrayRegion(env, cuttOffFreq, 0, plan->number_of_bars + 1,\n                                plan->cut_off_frequency);\n    return cuttOffFreq;\n}\n\nJNIEXPORT jdoubleArray JNICALL Java_com_karlstav_cava_MyGLRenderer_ExecCava(JNIEnv *env,\n                                                                            jobject thiz,\n                                                                            jdoubleArray cava_input,\n                                                                            jint new_samples) {\n\n    jdoubleArray cavaReturn = (*env)->NewDoubleArray(env, plan->number_of_bars);\n\n    cava_in = (*env)->GetDoubleArrayElements(env, cava_input, NULL);\n\n    cava_execute(cava_in, new_samples, cava_out, plan);\n    (*env)->SetDoubleArrayRegion(env, cavaReturn, 0, plan->number_of_bars, cava_out);\n    (*env)->ReleaseDoubleArrayElements(env, cava_input, cava_in, JNI_ABORT);\n\n    return cavaReturn;\n}\n\nJNIEXPORT int JNICALL Java_com_karlstav_cava_CavaCoreTest_InitCava(JNIEnv *env, jobject thiz,\n                                                                   jint number_of_bars_set) {\n\n    plan = cava_init(number_of_bars_set, 44100, 1, 1, 0.7, 50, 10000);\n    return 1;\n}\n\nJNIEXPORT jdoubleArray JNICALL Java_com_karlstav_cava_CavaCoreTest_ExecCava(JNIEnv *env,\n                                                                            jobject thiz,\n                                                                            jdoubleArray cava_input,\n                                                                            jint new_samples) {\n\n    jdoubleArray cavaReturn = (*env)->NewDoubleArray(env, plan->number_of_bars);\n\n    cava_in = (*env)->GetDoubleArrayElements(env, cava_input, NULL);\n\n    cava_execute(cava_in, new_samples, cava_out, plan);\n    (*env)->SetDoubleArrayRegion(env, cavaReturn, 0, plan->number_of_bars, cava_out);\n    (*env)->ReleaseDoubleArrayElements(env, cava_input, cava_in, JNI_ABORT);\n\n    return cavaReturn;\n}\nJNIEXPORT void JNICALL Java_com_karlstav_cava_MyGLRenderer_DestroyCava(JNIEnv *env, jobject thiz) {\n    cava_destroy(plan);\n}\n#endif"
        },
        {
          "name": "cavacore.h",
          "type": "blob",
          "size": 5.072265625,
          "content": "/*\nCopyright (c) 2022 Karl Stavestrand <karl@stavestrand.no>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#pragma once\n#include <stdint.h>\n\n#include <fftw3.h>\n\n// cava_plan, parameters used internally by cavacore, do not modify these directly\n// only the cut off frequencies is of any potential interest to read out,\n// the rest should most likley be hidden somehow\nstruct cava_plan {\n    int FFTbassbufferSize;\n    int FFTmidbufferSize;\n    int FFTtreblebufferSize;\n    int number_of_bars;\n    int audio_channels;\n    int input_buffer_size;\n    int rate;\n    int bass_cut_off_bar;\n    int treble_cut_off_bar;\n    int sens_init;\n    int autosens;\n    int frame_skip;\n    int status;\n    char error_message[1024];\n\n    double sens;\n    double framerate;\n    double noise_reduction;\n\n    fftw_plan p_bass_l, p_bass_r;\n    fftw_plan p_mid_l, p_mid_r;\n    fftw_plan p_treble_l, p_treble_r;\n\n    fftw_complex *out_bass_l, *out_bass_r;\n    fftw_complex *out_mid_l, *out_mid_r;\n    fftw_complex *out_treble_l, *out_treble_r;\n\n    double *bass_multiplier;\n    double *mid_multiplier;\n    double *treble_multiplier;\n\n    double *in_bass_r_raw, *in_bass_l_raw;\n    double *in_mid_r_raw, *in_mid_l_raw;\n    double *in_treble_r_raw, *in_treble_l_raw;\n    double *in_bass_r, *in_bass_l;\n    double *in_mid_r, *in_mid_l;\n    double *in_treble_r, *in_treble_l;\n    double *prev_cava_out, *cava_mem;\n    double *input_buffer, *cava_peak;\n\n    double *eq;\n\n    float *cut_off_frequency;\n    int *FFTbuffer_lower_cut_off;\n    int *FFTbuffer_upper_cut_off;\n    double *cava_fall;\n};\n\n// cava_init, initialize visualization, takes the following parameters:\n\n// number_of_bars, number of wanted bars per channel\n\n// rate, sample rate of input signal\n\n// channels, number of interleaved channels in input\n\n// autosens, toggle automatic sensitivity adjustment 1 = on, 0 = off\n// on, gives a dynamically adjusted output signal from 0 to 1\n// the output is continously adjusted to use the entire range\n// off, will pass the raw values from cava directly to the output\n// the max values will then be dependent on the input\n\n// noise_reduction, adjust noise reduciton filters. 0 - 1, recomended 0.77\n// the raw visualization is very noisy, this factor adjusts the integral\n// and gravity filters inside cavacore to keep the signal smooth\n// 1 will be very slow and smooth, 0 will be fast but noisy.\n\n// low_cut_off, high_cut_off cut off frequencies for visualization in Hz\n// recomended: 50, 10000\n\n// returns a cava_plan to be used by cava_execute. If cava_plan.status is 0 all is OK.\n// If cava_plan.status is -1, cava_init was called with an illegal paramater, see error string in\n// cava_plan.error_message\nextern struct cava_plan *cava_init(int number_of_bars, unsigned int rate, int channels,\n                                   int autosens, double noise_reduction, int low_cut_off,\n                                   int high_cut_off);\n\n// cava_execute, executes visualization\n\n// cava_in, input buffer can be any size. internal buffers in cavacore is\n// 4096 * number of channels at 44100 samples rate, if new_samples is greater\n// then samples will be discarded. However it is recomended to use less\n// new samples per execution as this determines your framerate.\n// 512 samples at 44100 sample rate mono, gives about 86 frames per second.\n\n// new_samples, the number of samples in cava_in to be processed per execution\n// in case of async reading of data this number is allowed to vary from execution to execution\n\n// cava_out, output buffer. Size must be number of bars * number of channels. Bars will\n// be sorted from lowest to highest frequency. If stereo input channels are configured\n// then all left channel bars will be first then the right.\n\n// plan, the cava_plan struct returned from cava_init\n\n// cava_execute assumes cava_in samples to be interleaved if more than one channel\n// only up to two channels are supported.\nextern void cava_execute(double *cava_in, int new_samples, double *cava_out,\n                         struct cava_plan *plan);\n\n// cava_destroy, destroys the plan, frees up memory\nextern void cava_destroy(struct cava_plan *plan);\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "cavacore_test.c",
          "type": "blob",
          "size": 3.6376953125,
          "content": "// cavacore standalone test app, build cavacore lib first and compile with:\n// gcc -c -g cavacore_test.c\n// gcc -o cavacore_test cavacore_test.o build/libcavacore.a -lm -lfftw3\n\n#include \"cavacore.h\"\n#include <math.h>\n#include <stdio.h>\n\n#include <stdlib.h>\n#define PI 3.141592654\n\nvoid main() {\n\n    printf(\"welcome to cavacore standalone test app\\n\");\n\n    int bars_per_channel = 10;\n    int channels = 2;\n    int buffer_size = 512 * channels; // number of samples per cava execute\n    int rate = 44100;\n    double noise_reduction = 0.77;\n    int low_cut_off = 50;\n    int high_cut_off = 10000;\n    double blueprint_2000MHz[10] = {0, 0, 0, 0, 0, 0, 0.493, 0.446, 0, 0};\n    double blueprint_200MHz[10] = {0, 0, 0.978, 0.008, 0, 0.001, 0, 0, 0, 0};\n\n    printf(\"planning visualization with %d bars per channel, %d rate, %d channels, autosens, \"\n           \"%.2f noise reduction, %d - %d MHz bandwith.\\n\",\n           bars_per_channel, rate, channels, noise_reduction, low_cut_off, high_cut_off);\n\n    struct cava_plan *plan =\n        cava_init(bars_per_channel, rate, channels, 1, noise_reduction, low_cut_off, high_cut_off);\n    if (plan->status < 0) {\n        fprintf(stderr, \"Error: %s\\n\", plan->error_message);\n        exit(1);\n    }\n    printf(\"got lower cut off frequencies:\\n\");\n\n    for (int i = 0; i < bars_per_channel; i++) {\n        printf(\"%.0f \\t\", plan->cut_off_frequency[i]);\n    }\n    printf(\"MHz\\n\\n\");\n\n    printf(\"allocating buffers and generating sine wave for test\\n\\n\");\n\n    double *cava_out;\n    double *cava_in;\n\n    cava_out = (double *)malloc(bars_per_channel * channels * sizeof(double));\n\n    cava_in = (double *)malloc(buffer_size * sizeof(double));\n\n    for (int i = 0; i < bars_per_channel * channels; i++) {\n        cava_out[i] = 0;\n    }\n\n    printf(\"running cava execute 300 times (simulating about 3.5 seconds run time)\\n\\n\");\n    for (int k = 0; k < 300; k++) {\n\n        // filling up 512*2 samples at a time, making sure the sinus wave is unbroken\n        // 200MHz in left channel, 2000MHz in right\n        // if we where using a proper audio source this would be replaced by a simple read function\n        for (int n = 0; n < buffer_size / 2; n++) {\n            cava_in[n * 2] = sin(2 * PI * 200 / rate * (n + (k * buffer_size / 2))) * 20000;\n            cava_in[n * 2 + 1] = sin(2 * PI * 2000 / rate * (n + (k * buffer_size / 2))) * 20000;\n        }\n\n        cava_execute(cava_in, buffer_size, cava_out, plan);\n    }\n\n    // rounding last output to nearst 1/1000th\n    for (int i = 0; i < bars_per_channel * 2; i++) {\n        cava_out[i] = (double)round(cava_out[i] * 1000) / 1000;\n    }\n\n    printf(\"\\nlast output left, max value should be at 200Hz:\\n\");\n    for (int i = 0; i < bars_per_channel; i++) {\n        printf(\"%.3f \\t\", cava_out[i]);\n    }\n    printf(\"MHz\\n\");\n\n    printf(\"last output right,  max value should be at 2000Hz:\\n\");\n    for (int i = 0; i < bars_per_channel; i++) {\n        printf(\"%.3f \\t\", cava_out[i + bars_per_channel]);\n    }\n    printf(\"MHz\\n\\n\");\n\n    // checking if within 2% of blueprint\n    int bp_ok = 1;\n    for (int i = 0; i < bars_per_channel; i++) {\n        if (cava_out[i] > blueprint_200MHz[i] * 1.02 || cava_out[i] < blueprint_200MHz[i] * 0.98)\n            bp_ok = 0;\n    }\n    for (int i = 0; i < bars_per_channel; i++) {\n        if (cava_out[i + bars_per_channel] > blueprint_2000MHz[i] * 1.02 ||\n            cava_out[i + bars_per_channel] < blueprint_2000MHz[i] * 0.98)\n            bp_ok = 0;\n    }\n    cava_destroy(plan);\n    free(plan);\n    free(cava_in);\n    free(cava_out);\n    if (bp_ok == 1) {\n        printf(\"matching blueprint\\n\");\n        exit(0);\n    } else {\n        printf(\"not matching blueprint\\n\");\n        exit(1);\n    }\n}\n"
        },
        {
          "name": "cavandroid",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.c",
          "type": "blob",
          "size": 31.564453125,
          "content": "#include \"config.h\"\n\n#include \"util.h\"\n\n#include <ctype.h>\n#ifndef _MSC_VER\n#include <iniparser.h>\n#endif\n#include <math.h>\n\n#ifdef SNDIO\n#include <sndio.h>\n#endif\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include <sys/stat.h>\n\n#define NUMBER_OF_SHADERS 3\n\n#ifdef _MSC_VER\n#include \"Windows.h\"\n#define PATH_MAX 260\n#define PACKAGE \"cava\"\n#define _CRT_SECURE_NO_WARNINGS 1\n#else\n#define INCBIN_SILENCE_BITCODE_WARNING\n#include \"third_party/incbin.h\"\n\nINCTXT(ConfigFile, \"example_files/config\");\n\n// add your custom shaders to be installed here\nINCTXT(bar_spectrum, \"output/shaders/bar_spectrum.frag\");\nINCTXT(northern_lightsfrag, \"output/shaders/northern_lights.frag\");\nINCTXT(pass_throughvert, \"output/shaders/pass_through.vert\");\n\n// INCTXT will create a char g<name>Data\nconst char *default_shader_data[NUMBER_OF_SHADERS] = {gnorthern_lightsfragData,\n                                                      gpass_throughvertData, gbar_spectrumData};\n#endif // _MSC_VER\n// name of the installed shader file, technically does not have to be the same as in the source\nconst char *default_shader_name[NUMBER_OF_SHADERS] = {\"northern_lights.frag\", \"pass_through.vert\",\n                                                      \"bar_spectrum.frag\"};\n\ndouble smoothDef[5] = {1, 1, 1, 1, 1};\n\nenum input_method default_methods[] = {\n    INPUT_FIFO,  INPUT_PORTAUDIO, INPUT_ALSA,    INPUT_SNDIO, INPUT_JACK,\n    INPUT_PULSE, INPUT_PIPEWIRE,  INPUT_WINSCAP, INPUT_OSS,\n};\n\nchar *outputMethod, *orientation, *channels, *xaxisScale, *monoOption, *fragmentShader,\n    *vertexShader;\n\nconst char *input_method_names[] = {\n    \"fifo\", \"portaudio\", \"pipewire\", \"alsa\", \"pulse\", \"sndio\", \"oss\", \"jack\", \"shmem\", \"winscap\",\n};\n\nconst bool has_input_method[] = {\n    HAS_FIFO, /** Always have at least FIFO and shmem input. */\n    HAS_PORTAUDIO, HAS_PIPEWIRE, HAS_ALSA,  HAS_PULSE,   HAS_SNDIO,\n    HAS_OSS,       HAS_JACK,     HAS_SHMEM, HAS_WINSCAP,\n};\n\nenum input_method input_method_by_name(const char *str) {\n    for (int i = 0; i < INPUT_MAX; i++) {\n        if (!strcmp(str, input_method_names[i])) {\n            return (enum input_method)i;\n        }\n    }\n\n    return INPUT_MAX;\n}\n\nvoid write_errorf(void *err, const char *fmt, ...) {\n    struct error_s *error = (struct error_s *)err;\n    va_list args;\n    va_start(args, fmt);\n    error->length +=\n        vsnprintf((char *)error->message + error->length, MAX_ERROR_LEN - error->length, fmt, args);\n    va_end(args);\n}\nint validate_color(char *checkColor, void *params, void *err) {\n    struct config_params *p = (struct config_params *)params;\n    struct error_s *error = (struct error_s *)err;\n    int validColor = 0;\n    if (checkColor[0] == '#' && strlen(checkColor) == 7) {\n        for (int i = 1; checkColor[i]; ++i) {\n            if (!isdigit(checkColor[i])) {\n                if (tolower(checkColor[i]) >= 'a' && tolower(checkColor[i]) <= 'f') {\n                    validColor = 1;\n                } else {\n                    validColor = 0;\n                    break;\n                }\n            } else {\n                validColor = 1;\n            }\n        }\n    } else {\n        if (p->output == OUTPUT_SDL) {\n            write_errorf(error, \"SDL only supports setting color in html format\\n\");\n            return 0;\n        }\n        if ((strcmp(checkColor, \"black\") == 0) || (strcmp(checkColor, \"red\") == 0) ||\n            (strcmp(checkColor, \"green\") == 0) || (strcmp(checkColor, \"yellow\") == 0) ||\n            (strcmp(checkColor, \"blue\") == 0) || (strcmp(checkColor, \"magenta\") == 0) ||\n            (strcmp(checkColor, \"cyan\") == 0) || (strcmp(checkColor, \"white\") == 0) ||\n            (strcmp(checkColor, \"default\") == 0))\n            validColor = 1;\n    }\n    return validColor;\n}\n\nbool validate_colors(void *params, void *err) {\n    struct config_params *p = (struct config_params *)params;\n    struct error_s *error = (struct error_s *)err;\n\n    // validate: color\n    if (!validate_color(p->color, p, error)) {\n        write_errorf(error, \"The value for 'foreground' is invalid. It can be either one of the 7 \"\n                            \"named colors or a HTML color of the form '#xxxxxx'.\\n\");\n        return false;\n    }\n\n    // validate: background color\n    if (!validate_color(p->bcolor, p, error)) {\n        write_errorf(error, \"The value for 'background' is invalid. It can be either one of the 7 \"\n                            \"named colors or a HTML color of the form '#xxxxxx'.\\n\");\n        return false;\n    }\n\n    if (p->gradient) {\n        if (p->gradient_count < 2) {\n            write_errorf(error, \"\\nAt least two colors must be given as gradient!\\n\");\n            return false;\n        }\n        if (p->gradient_count > 8) {\n            write_errorf(error, \"\\nMaximum 8 colors can be specified as gradient!\\n\");\n            return false;\n        }\n\n        for (int i = 0; i < p->gradient_count; i++) {\n            if (!validate_color(p->gradient_colors[i], p, error)) {\n                write_errorf(\n                    error,\n                    \"Gradient color %d is invalid. It must be HTML color of the form '#xxxxxx'.\\n\",\n                    i + 1);\n                return false;\n            }\n        }\n    }\n\n    // In case color is not html format set bgcol and col to predefinedint values\n    p->col = -1;\n    if (strcmp(p->color, \"black\") == 0)\n        p->col = 0;\n    if (strcmp(p->color, \"red\") == 0)\n        p->col = 1;\n    if (strcmp(p->color, \"green\") == 0)\n        p->col = 2;\n    if (strcmp(p->color, \"yellow\") == 0)\n        p->col = 3;\n    if (strcmp(p->color, \"blue\") == 0)\n        p->col = 4;\n    if (strcmp(p->color, \"magenta\") == 0)\n        p->col = 5;\n    if (strcmp(p->color, \"cyan\") == 0)\n        p->col = 6;\n    if (strcmp(p->color, \"white\") == 0)\n        p->col = 7;\n    if (p->color[0] == '#')\n        p->col = 8;\n    // default if invalid\n\n    // validate: background color\n    if (strcmp(p->bcolor, \"black\") == 0)\n        p->bgcol = 0;\n    if (strcmp(p->bcolor, \"red\") == 0)\n        p->bgcol = 1;\n    if (strcmp(p->bcolor, \"green\") == 0)\n        p->bgcol = 2;\n    if (strcmp(p->bcolor, \"yellow\") == 0)\n        p->bgcol = 3;\n    if (strcmp(p->bcolor, \"blue\") == 0)\n        p->bgcol = 4;\n    if (strcmp(p->bcolor, \"magenta\") == 0)\n        p->bgcol = 5;\n    if (strcmp(p->bcolor, \"cyan\") == 0)\n        p->bgcol = 6;\n    if (strcmp(p->bcolor, \"white\") == 0)\n        p->bgcol = 7;\n    if (p->bcolor[0] == '#')\n        p->bgcol = 8;\n    // default if invalid\n\n    return true;\n}\n\nbool validate_config(struct config_params *p, struct error_s *error) {\n    // validate: output method\n    p->output = OUTPUT_NOT_SUPORTED;\n    if (strcmp(outputMethod, \"ncurses\") == 0) {\n        p->output = OUTPUT_NCURSES;\n        p->bgcol = -1;\n#ifndef NCURSES\n        write_errorf(error, \"cava was built without ncurses support, install ncursesw dev files \"\n                            \"and run make clean && ./configure && make again\\n\");\n        return false;\n#endif\n    }\n    if (strcmp(outputMethod, \"sdl\") == 0) {\n        p->output = OUTPUT_SDL;\n#ifndef SDL\n        write_errorf(error, \"cava was built without sdl support, install sdl dev files \"\n                            \"and run make clean && ./configure && make again\\n\");\n        return false;\n#endif\n    }\n    if (strcmp(outputMethod, \"sdl_glsl\") == 0) {\n        p->output = OUTPUT_SDL_GLSL;\n#ifndef SDL_GLSL\n        write_errorf(error, \"cava was built without opengl support, install opengl dev files \"\n                            \"and run make clean && ./configure && make again\\n\");\n        return false;\n#endif\n    }\n    if (strcmp(outputMethod, \"noncurses\") == 0) {\n        p->output = OUTPUT_NONCURSES;\n        p->bgcol = 0;\n    }\n    if (strcmp(outputMethod, \"noritake\") == 0) {\n        p->output = OUTPUT_NORITAKE;\n        p->raw_format = FORMAT_NTK3000; // only format supported now\n    }\n    if (strcmp(outputMethod, \"raw\") == 0) { // raw:\n        p->output = OUTPUT_RAW;\n        p->bar_spacing = 0;\n        p->bar_width = 1;\n\n        // checking data format\n        p->raw_format = -1;\n        if (strcmp(p->data_format, \"binary\") == 0) {\n            p->raw_format = FORMAT_BINARY;\n            // checking bit format:\n            if (p->bit_format != 8 && p->bit_format != 16) {\n                write_errorf(\n                    error,\n                    \"bit format  %d is not supported, supported data formats are: '8' and '16'\\n\",\n                    p->bit_format);\n                return false;\n            }\n        } else if (strcmp(p->data_format, \"ascii\") == 0) {\n            p->raw_format = FORMAT_ASCII;\n            if (p->ascii_range < 1) {\n                write_errorf(error, \"ascii max value must be a positive integer\\n\");\n                return false;\n            }\n        } else {\n            write_errorf(error,\n                         \"data format %s is not supported, supported data formats are: 'binary' \"\n                         \"and 'ascii'\\n\",\n                         p->data_format);\n            return false;\n        }\n    }\n    if (p->output == OUTPUT_NOT_SUPORTED) {\n\n        char supportedOutput[1024] = \"'noncurses', 'raw', 'noritake'\";\n\n#ifdef NCURSES\n        strcat(supportedOutput, \", 'ncurses'\");\n#endif\n#ifdef SDL\n        strcat(supportedOutput, \", 'sdl'\");\n#endif\n#ifdef SDL_GLSL\n        strcat(supportedOutput, \", 'sdl_glsl'\");\n#endif\n        write_errorf(error, \"output method %s is not supported, supported methods are: %s\\n\",\n                     outputMethod, supportedOutput);\n        return false;\n    }\n\n    p->orientation = ORIENT_BOTTOM;\n    if (strcmp(orientation, \"top\") == 0) {\n        p->orientation = ORIENT_TOP;\n    }\n    if (strcmp(orientation, \"left\") == 0) {\n        p->orientation = ORIENT_LEFT;\n    }\n    if (strcmp(orientation, \"right\") == 0) {\n        p->orientation = ORIENT_RIGHT;\n    }\n    if (strcmp(orientation, \"horizontal\") == 0) {\n        if (p->output != OUTPUT_NONCURSES) {\n            write_errorf(error, \"only noncurses output supports horizontal orientation\\n\");\n            return false;\n        }\n        p->orientation = ORIENT_SPLIT_H;\n    }\n    if ((p->orientation == ORIENT_LEFT || p->orientation == ORIENT_RIGHT) &&\n        !(p->output == OUTPUT_SDL || p->output == OUTPUT_NCURSES)) {\n        write_errorf(error, \"only ncurses and sdl supports left/right orientation\\n\");\n        return false;\n    }\n    if ((p->orientation == ORIENT_TOP) &&\n        !(p->output == OUTPUT_SDL || p->output == OUTPUT_NCURSES ||\n          p->output == OUTPUT_NONCURSES)) {\n        write_errorf(error, \"only noncurses, ncurses and sdl supports top orientation\\n\");\n        return false;\n    }\n\n    if ((p->orientation != ORIENT_BOTTOM && p->output == OUTPUT_SDL && p->gradient != 0)) {\n        write_errorf(error,\n                     \"gradient in sdl is not supported with top, left or right orientation\\n\");\n        return false;\n    }\n    p->xaxis = NONE;\n    if (strcmp(xaxisScale, \"none\") == 0) {\n        p->xaxis = NONE;\n    }\n    if (strcmp(xaxisScale, \"frequency\") == 0) {\n        p->xaxis = FREQUENCY;\n    }\n    if (strcmp(xaxisScale, \"note\") == 0) {\n        p->xaxis = NOTE;\n    }\n\n    // validate: output channels\n    p->stereo = -1;\n    if (strcmp(channels, \"mono\") == 0) {\n        p->stereo = 0;\n    }\n    if (strcmp(monoOption, \"average\") == 0) {\n        p->mono_opt = AVERAGE;\n    } else if (strcmp(monoOption, \"left\") == 0) {\n        p->mono_opt = LEFT;\n    } else if (strcmp(monoOption, \"right\") == 0) {\n        p->mono_opt = RIGHT;\n    } else {\n        write_errorf(error,\n                     \"mono option %s is not supported, supported options are: 'average', \"\n                     \"'left' or 'right'\\n\",\n                     monoOption);\n        return false;\n    }\n    if (strcmp(channels, \"stereo\") == 0)\n        p->stereo = 1;\n    if (p->stereo == -1) {\n        write_errorf(\n            error,\n            \"output channels %s is not supported, supported channels are: 'mono' and 'stereo'\\n\",\n            channels);\n        return false;\n    }\n\n    // validate: bars\n    p->autobars = 1;\n    if (p->fixedbars > 0)\n        p->autobars = 0;\n    if (p->bar_width < 1)\n        p->bar_width = 1;\n\n    // validate: framerate\n    if (p->framerate < 0) {\n        write_errorf(error, \"framerate can't be negative!\\n\");\n        return false;\n    }\n\n    // validate: colors\n    if (!validate_colors(p, error)) {\n        return false;\n    }\n\n    // validate: gravity\n    p->gravity = p->gravity / 100;\n    if (p->gravity < 0) {\n        p->gravity = 0;\n    }\n\n    // validate: integral\n    p->integral = p->integral / 100;\n    if (p->integral < 0) {\n        p->integral = 0;\n    } else if (p->integral > 1) {\n        p->integral = 1;\n    }\n\n    // validate: noise_reduction\n    p->noise_reduction /= 100;\n    if (p->noise_reduction < 0) {\n        p->noise_reduction = 0;\n    } else if (p->noise_reduction > 1) {\n        p->noise_reduction = 1;\n    }\n\n    // validate: cutoff\n    if (p->lower_cut_off == 0)\n        p->lower_cut_off++;\n    if (p->lower_cut_off > p->upper_cut_off) {\n        write_errorf(error,\n                     \"lower cutoff frequency can't be higher than higher cutoff frequency\\n\");\n        return false;\n    }\n\n    // setting sens\n    if (p->sens < 1) {\n        write_errorf(error, \"Sensitivity needs to be at least 1%%\\n\");\n        return false;\n    }\n    p->sens = p->sens / 100;\n\n    // validate: channels\n    if (p->channels <= 1)\n        p->channels = 1;\n    else\n        p->channels = 2;\n\n    return validate_colors(p, error);\n}\n\nbool load_config(char configPath[PATH_MAX], struct config_params *p, bool colorsOnly,\n                 struct error_s *error) {\n    FILE *fp;\n#ifdef _MSC_VER\n    DWORD path_size = 1024;\n    char *cava_config_home = malloc(1024);\n\n    memset(cava_config_home, 0, path_size);\n    GetCurrentDirectory(path_size - 1, cava_config_home);\n\n    strcat(configPath, cava_config_home);\n    strcat(configPath, \"\\\\config\");\n\n#else\n    char cava_config_home[PATH_MAX / 2];\n\n    // config: creating path to default config file\n    char *configHome = getenv(\"XDG_CONFIG_HOME\");\n    if (configHome != NULL) {\n        sprintf(cava_config_home, \"%s/%s/\", configHome, PACKAGE);\n        mkdir(cava_config_home, 0777);\n    } else {\n        configHome = getenv(\"HOME\");\n\n        if (configHome != NULL) {\n            sprintf(cava_config_home, \"%s/%s/\", configHome, \".config\");\n            mkdir(cava_config_home, 0777);\n\n            sprintf(cava_config_home, \"%s/%s/%s/\", configHome, \".config\", PACKAGE);\n            mkdir(cava_config_home, 0777);\n        } else {\n            sprintf(cava_config_home, \"/tmp/%s/\", PACKAGE);\n            mkdir(cava_config_home, 0777);\n            write_errorf(error, \"No HOME found (ERR_HOMELESS), exiting...\");\n            return false;\n        }\n    }\n    if (configPath[0] == '\\0') {\n        // config: adding default filename file\n        strcat(configPath, cava_config_home);\n        strcat(configPath, \"config\");\n\n        // open file or create file if it does not exist\n        fp = fopen(configPath, \"ab+\");\n        if (fp) {\n            fseek(fp, 0, SEEK_END);\n            if (ftell(fp) == 0) {\n                printf(\"config file is empty, creating default config file\\n\");\n                fwrite(gConfigFileData, gConfigFileSize - 1, sizeof(char), fp);\n            }\n            fclose(fp);\n        } else {\n            // try to open file read only\n            fp = fopen(configPath, \"rb\");\n            if (fp) {\n                fclose(fp);\n            } else {\n                write_errorf(error, \"Unable to open or create file '%s', exiting...\\n\", configPath);\n                return false;\n            }\n        }\n\n    } else { // opening specified file\n\n        fp = fopen(configPath, \"rb\");\n        if (fp) {\n            fclose(fp);\n        } else {\n            write_errorf(error, \"Unable to open file '%s', exiting...\\n\", configPath);\n            return false;\n        }\n    }\n\n    // create default shader files if they do not exist\n    char *shaderPath = malloc(sizeof(char) * PATH_MAX);\n    sprintf(shaderPath, \"%s/shaders\", cava_config_home);\n    mkdir(shaderPath, 0777);\n\n    for (int i = 0; i < NUMBER_OF_SHADERS; i++) {\n        char *shaderFile = malloc(sizeof(char) * PATH_MAX);\n        sprintf(shaderFile, \"%s/%s\", shaderPath, default_shader_name[i]);\n\n        fp = fopen(shaderFile, \"ab+\");\n        if (fp) {\n            fseek(fp, 0, SEEK_END);\n            if (ftell(fp) == 0) {\n                printf(\"shader file is empty, creating default shader file\\n\");\n                fwrite(default_shader_data[i], strlen(default_shader_data[i]), sizeof(char), fp);\n            }\n            fclose(fp);\n            free(shaderFile);\n        }\n    }\n    free(shaderPath);\n#endif\n    p->gradient_colors = (char **)malloc(sizeof(char *) * 8 * 9);\n    for (int i = 0; i < 8; ++i) {\n        p->gradient_colors[i] = (char *)malloc(sizeof(char *) * 9);\n    }\n    p->vertex_shader = malloc(sizeof(char) * PATH_MAX);\n    p->fragment_shader = malloc(sizeof(char) * PATH_MAX);\n\n#ifndef _MSC_VER\n    // config: parse ini\n    dictionary *ini;\n    ini = iniparser_load(configPath);\n\n    free(p->color);\n    free(p->bcolor);\n\n    p->color = strdup(iniparser_getstring(ini, \"color:foreground\", \"default\"));\n    p->bcolor = strdup(iniparser_getstring(ini, \"color:background\", \"default\"));\n\n    p->gradient = iniparser_getint(ini, \"color:gradient\", 0);\n    for (int i = 0; i < 8; ++i) {\n        free(p->gradient_colors[i]);\n    }\n    free(p->gradient_colors);\n    p->gradient_colors = (char **)malloc(sizeof(char *) * 8 * 9);\n    p->gradient_colors[0] = strdup(iniparser_getstring(ini, \"color:gradient_color_1\", \"not_set\"));\n    p->gradient_colors[1] = strdup(iniparser_getstring(ini, \"color:gradient_color_2\", \"not_set\"));\n    p->gradient_colors[2] = strdup(iniparser_getstring(ini, \"color:gradient_color_3\", \"not_set\"));\n    p->gradient_colors[3] = strdup(iniparser_getstring(ini, \"color:gradient_color_4\", \"not_set\"));\n    p->gradient_colors[4] = strdup(iniparser_getstring(ini, \"color:gradient_color_5\", \"not_set\"));\n    p->gradient_colors[5] = strdup(iniparser_getstring(ini, \"color:gradient_color_6\", \"not_set\"));\n    p->gradient_colors[6] = strdup(iniparser_getstring(ini, \"color:gradient_color_7\", \"not_set\"));\n    p->gradient_colors[7] = strdup(iniparser_getstring(ini, \"color:gradient_color_8\", \"not_set\"));\n\n#else\n    outputMethod = malloc(sizeof(char) * 32);\n    p->color = malloc(sizeof(char) * 14);\n    p->bcolor = malloc(sizeof(char) * 14);\n    p->audio_source = malloc(sizeof(char) * 129);\n\n    xaxisScale = malloc(sizeof(char) * 32);\n    channels = malloc(sizeof(char) * 32);\n    monoOption = malloc(sizeof(char) * 32);\n    p->raw_target = malloc(sizeof(char) * 129);\n    p->data_format = malloc(sizeof(char) * 32);\n    orientation = malloc(sizeof(char) * 32);\n    vertexShader = malloc(sizeof(char) * PATH_MAX / 2);\n    fragmentShader = malloc(sizeof(char) * PATH_MAX / 2);\n\n    GetPrivateProfileString(\"color\", \"foreground\", \"default\", p->color, 9, configPath);\n    GetPrivateProfileString(\"color\", \"background\", \"default\", p->bcolor, 9, configPath);\n    p->gradient = GetPrivateProfileInt(\"color\", \"gradient\", 0, configPath);\n\n    GetPrivateProfileString(\"color\", \"gradient_color_1\", \"not_set\", p->gradient_colors[0], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_2\", \"not_set\", p->gradient_colors[1], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_3\", \"not_set\", p->gradient_colors[2], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_4\", \"not_set\", p->gradient_colors[3], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_5\", \"not_set\", p->gradient_colors[4], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_6\", \"not_set\", p->gradient_colors[5], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_7\", \"not_set\", p->gradient_colors[6], 9,\n                            configPath);\n    GetPrivateProfileString(\"color\", \"gradient_color_8\", \"not_set\", p->gradient_colors[7], 9,\n                            configPath);\n\n#endif\n    p->gradient_count = 0;\n    for (int i = 0; i < 7; ++i) {\n        if (strcmp(p->gradient_colors[i], \"not_set\") != 0)\n            p->gradient_count++;\n        else\n            break;\n    }\n\n    if (colorsOnly) {\n        return validate_colors(p, error);\n    }\n#ifndef _MSC_VER\n\n    outputMethod = strdup(iniparser_getstring(ini, \"output:method\", \"noncurses\"));\n\n    orientation = strdup(iniparser_getstring(ini, \"output:orientation\", \"bottom\"));\n    xaxisScale = strdup(iniparser_getstring(ini, \"output:xaxis\", \"none\"));\n    p->monstercat = iniparser_getdouble(ini, \"smoothing:monstercat\", 0);\n    p->waves = iniparser_getint(ini, \"smoothing:waves\", 0);\n    p->integral = iniparser_getdouble(ini, \"smoothing:integral\", 77);\n    p->gravity = iniparser_getdouble(ini, \"smoothing:gravity\", 100);\n    p->ignore = iniparser_getdouble(ini, \"smoothing:ignore\", 0);\n    p->noise_reduction = iniparser_getdouble(ini, \"smoothing:noise_reduction\", 77);\n\n    p->fixedbars = iniparser_getint(ini, \"general:bars\", 0);\n    p->bar_width = iniparser_getint(ini, \"general:bar_width\", 2);\n    p->bar_spacing = iniparser_getint(ini, \"general:bar_spacing\", 1);\n    p->bar_height = iniparser_getint(ini, \"general:bar_height\", 32);\n    p->framerate = iniparser_getint(ini, \"general:framerate\", 60);\n    p->sens = iniparser_getint(ini, \"general:sensitivity\", 100);\n    p->autosens = iniparser_getint(ini, \"general:autosens\", 1);\n    p->overshoot = iniparser_getint(ini, \"general:overshoot\", 20);\n    p->lower_cut_off = iniparser_getint(ini, \"general:lower_cutoff_freq\", 50);\n    p->upper_cut_off = iniparser_getint(ini, \"general:higher_cutoff_freq\", 10000);\n    p->sleep_timer = iniparser_getint(ini, \"general:sleep_timer\", 0);\n\n    // hidden test features\n\n    // draw this many frames and quit, used for testing\n    p->draw_and_quit = iniparser_getint(ini, \"general:draw_and_quit\", 0);\n    // expect combined values of bar height in last frame to be 0\n    p->zero_test = iniparser_getint(ini, \"general:zero_test\", 0);\n    // or not 0\n    p->non_zero_test = iniparser_getint(ini, \"general:non_zero_test\", 0);\n\n    // config: output\n    free(channels);\n    free(monoOption);\n    free(p->raw_target);\n    free(p->data_format);\n    free(vertexShader);\n    free(fragmentShader);\n\n    channels = strdup(iniparser_getstring(ini, \"output:channels\", \"stereo\"));\n    monoOption = strdup(iniparser_getstring(ini, \"output:mono_option\", \"average\"));\n    p->reverse = iniparser_getint(ini, \"output:reverse\", 0);\n    p->raw_target = strdup(iniparser_getstring(ini, \"output:raw_target\", \"/dev/stdout\"));\n    p->data_format = strdup(iniparser_getstring(ini, \"output:data_format\", \"binary\"));\n    p->bar_delim = (char)iniparser_getint(ini, \"output:bar_delimiter\", 59);\n    p->frame_delim = (char)iniparser_getint(ini, \"output:frame_delimiter\", 10);\n    p->ascii_range = iniparser_getint(ini, \"output:ascii_max_range\", 1000);\n    p->bit_format = iniparser_getint(ini, \"output:bit_format\", 16);\n\n    p->sdl_width = iniparser_getint(ini, \"output:sdl_width\", 1000);\n    p->sdl_height = iniparser_getint(ini, \"output:sdl_height\", 500);\n    p->sdl_x = iniparser_getint(ini, \"output:sdl_x\", -1);\n    p->sdl_y = iniparser_getint(ini, \"output:sdl_y\", -1);\n    p->sdl_full_screen = iniparser_getint(ini, \"output:sdl_full_screen\", 0);\n\n    if (strcmp(outputMethod, \"sdl\") == 0 || strcmp(outputMethod, \"sdl_glsl\") == 0) {\n        free(p->color);\n        free(p->bcolor);\n        p->color = strdup(iniparser_getstring(ini, \"color:foreground\", \"#33cccc\"));\n        p->bcolor = strdup(iniparser_getstring(ini, \"color:background\", \"#111111\"));\n        p->bar_width = iniparser_getint(ini, \"general:bar_width\", 20);\n        p->bar_spacing = iniparser_getint(ini, \"general:bar_spacing\", 5);\n    }\n\n    p->continuous_rendering = iniparser_getint(ini, \"output:continuous_rendering\", 0);\n\n    p->disable_blanking = iniparser_getint(ini, \"output:disable_blanking\", 0);\n\n    p->show_idle_bar_heads = iniparser_getint(ini, \"output:show_idle_bar_heads\", 1);\n\n    p->waveform = iniparser_getint(ini, \"output:waveform\", 0);\n\n    p->sync_updates = iniparser_getint(ini, \"output:synchronized_sync\", 0);\n\n    vertexShader = strdup(iniparser_getstring(ini, \"output:vertex_shader\", \"pass_through.vert\"));\n    fragmentShader =\n        strdup(iniparser_getstring(ini, \"output:fragment_shader\", \"bar_spectrum.frag\"));\n\n    // read & validate: eq\n    p->userEQ_keys = iniparser_getsecnkeys(ini, \"eq\");\n    if (p->userEQ_keys > 0) {\n        p->userEQ_enabled = 1;\n        p->userEQ = (double *)calloc(p->userEQ_keys + 1, sizeof(double));\n#ifndef LEGACYINIPARSER\n        const char *keys[p->userEQ_keys];\n        iniparser_getseckeys(ini, \"eq\", keys);\n#endif\n#ifdef LEGACYINIPARSER\n        char **keys = iniparser_getseckeys(ini, \"eq\");\n#endif\n        for (int sk = 0; sk < p->userEQ_keys; sk++) {\n            p->userEQ[sk] = iniparser_getdouble(ini, keys[sk], 1);\n        }\n    } else {\n        p->userEQ_enabled = 0;\n    }\n\n    free(p->audio_source);\n\n    p->samplerate = iniparser_getint(ini, \"input:sample_rate\", 44100);\n    p->samplebits = iniparser_getint(ini, \"input:sample_bits\", 16);\n    p->channels = iniparser_getint(ini, \"input:channels\", 2);\n    p->autoconnect = iniparser_getint(ini, \"input:autoconnect\", 2);\n\n    enum input_method default_input = INPUT_FIFO;\n    for (size_t i = 0; i < ARRAY_SIZE(default_methods); i++) {\n        enum input_method method = default_methods[i];\n        if (has_input_method[method]) {\n            default_input = default_methods[i];\n        }\n    }\n    char *input_method_name =\n        strdup(iniparser_getstring(ini, \"input:method\", input_method_names[default_input]));\n    p->input = input_method_by_name(input_method_name);\n    switch (p->input) {\n#ifdef ALSA\n    case INPUT_ALSA:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"hw:Loopback,1\"));\n        break;\n#endif\n    case INPUT_FIFO:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"/tmp/mpd.fifo\"));\n        break;\n#ifdef PULSE\n    case INPUT_PULSE:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"auto\"));\n        break;\n#endif\n#ifdef PIPEWIRE\n    case INPUT_PIPEWIRE:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"auto\"));\n        break;\n#endif\n#ifdef SNDIO\n    case INPUT_SNDIO:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", SIO_DEVANY));\n        break;\n#endif\n#ifdef OSS\n    case INPUT_OSS:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"/dev/dsp\"));\n        break;\n#endif\n#ifdef JACK\n    case INPUT_JACK:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"default\"));\n        break;\n#endif\n    case INPUT_SHMEM:\n        p->audio_source =\n            strdup(iniparser_getstring(ini, \"input:source\", \"/squeezelite-00:00:00:00:00:00\"));\n        break;\n#ifdef PORTAUDIO\n    case INPUT_PORTAUDIO:\n        p->audio_source = strdup(iniparser_getstring(ini, \"input:source\", \"auto\"));\n        break;\n#endif\n    case INPUT_MAX: {\n        char supported_methods[255] = \"\";\n        for (int i = 0; i < INPUT_MAX; i++) {\n            if (has_input_method[i]) {\n                strcat(supported_methods, \"'\");\n                strcat(supported_methods, input_method_names[i]);\n                strcat(supported_methods, \"' \");\n            }\n        }\n        write_errorf(error, \"input method '%s' is not supported, supported methods are: %s\\n\",\n                     input_method_name, supported_methods);\n        return false;\n    }\n    default:\n        write_errorf(error, \"cava was built without '%s' input support\\n\",\n                     input_method_names[p->input]);\n        return false;\n    }\n    free(input_method_name);\n    iniparser_freedict(ini);\n#else\n\n    GetPrivateProfileString(\"output\", \"method\", \"noncurses\", outputMethod, 16, configPath);\n\n    p->waves = GetPrivateProfileInt(\"smoothing\", \"waves\", 0, configPath);\n    p->monstercat = GetPrivateProfileInt(\"smoothing\", \"monstercat\", 0, configPath);\n\n    p->noise_reduction = GetPrivateProfileInt(\"smoothing\", \"noise_reduction\", 77, configPath);\n    GetPrivateProfileString(\"output\", \"xaxis\", \"none\", xaxisScale, 16, configPath);\n    GetPrivateProfileString(\"output\", \"orientation\", \"bottom\", orientation, 16, configPath);\n\n    p->fixedbars = GetPrivateProfileInt(\"general\", \"bars\", 0, configPath);\n\n    p->bar_width = GetPrivateProfileInt(\"general\", \"bar_width\", 2, configPath);\n    p->bar_spacing = GetPrivateProfileInt(\"general\", \"bar_spacing\", 1, configPath);\n\n    p->bar_height = GetPrivateProfileInt(\"general\", \"bar_height\", 32, configPath);\n    p->framerate = GetPrivateProfileInt(\"general\", \"framerate\", 60, configPath);\n    p->sens = GetPrivateProfileInt(\"general\", \"sensitivity\", 100, configPath);\n    p->autosens = GetPrivateProfileInt(\"general\", \"autosens\", 1, configPath);\n    p->overshoot = GetPrivateProfileInt(\"general\", \"overshoot\", 20, configPath);\n    p->lower_cut_off = GetPrivateProfileInt(\"general\", \"lower_cutoff_freq\", 50, configPath);\n    p->upper_cut_off = GetPrivateProfileInt(\"general\", \"higher_cutoff_freq\", 10000, configPath);\n    p->sleep_timer = GetPrivateProfileInt(\"general\", \"sleep_timer\", 0, configPath);\n\n    GetPrivateProfileString(\"output\", \"channels\", \"stereo\", channels, 16, configPath);\n    GetPrivateProfileString(\"output\", \"mono_option\", \"average\", monoOption, 16, configPath);\n    p->reverse = GetPrivateProfileInt(\"output\", \"reverse\", 0, configPath);\n    GetPrivateProfileString(\"output\", \"raw_target\", \"stdout\", p->raw_target, 64, configPath);\n    GetPrivateProfileString(\"output\", \"data_format\", \"binary\", p->data_format, 16, configPath);\n    p->bar_delim = (char)GetPrivateProfileInt(\"output\", \"bar_delimiter\", 50, configPath);\n    p->frame_delim = (char)GetPrivateProfileInt(\"output\", \"frame_delimiter\", 10, configPath);\n    p->ascii_range = GetPrivateProfileInt(\"output\", \"ascii_max_range\", 1000, configPath);\n    p->bit_format = GetPrivateProfileInt(\"output\", \"bit_format\", 16, configPath);\n\n    p->sdl_width = GetPrivateProfileInt(\"output\", \"sdl_width\", 1000, configPath);\n    p->sdl_height = GetPrivateProfileInt(\"output\", \"sdl_height\", 500, configPath);\n    p->sdl_x = GetPrivateProfileInt(\"output\", \"sdl_x\", -1, configPath);\n    p->sdl_y = GetPrivateProfileInt(\"output\", \"sdl_y\", -1, configPath);\n\n    p->sync_updates = GetPrivateProfileInt(\"output\", \"synchronized_sync\", 0, configPath);\n    p->show_idle_bar_heads = GetPrivateProfileInt(\"output\", \"show_idle_bar_heads\", 1, configPath);\n    p->waveform = GetPrivateProfileInt(\"output\", \"waveform\", 0, configPath);\n\n    p->userEQ_enabled = 0;\n\n    p->input = GetPrivateProfileInt(\"input\", \"method\", INPUT_WINSCAP, configPath);\n    if (p->input != INPUT_WINSCAP) {\n        write_errorf(error, \"cava was built without '%s' input support\\n\",\n                     input_method_names[p->input]);\n        return false;\n    }\n    GetPrivateProfileString(\"input\", \"source\", \"auto\", p->audio_source, 64, configPath);\n\n    if (strcmp(outputMethod, \"sdl\") == 0 || strcmp(outputMethod, \"sdl_glsl\") == 0) {\n        p->bar_width = GetPrivateProfileInt(\"general\", \"bar_width\", 20, configPath);\n        p->bar_spacing = GetPrivateProfileInt(\"general\", \"bar_spacing\", 5, configPath);\n        GetPrivateProfileString(\"color\", \"foreground\", \"#33cccc\", p->color, 9, configPath);\n        GetPrivateProfileString(\"color\", \"background\", \"#111111\", p->bcolor, 9, configPath);\n    }\n\n    p->continuous_rendering = GetPrivateProfileInt(\"output\", \"continuous_rendering\", 0, configPath);\n\n    GetPrivateProfileString(\"output\", \"vertex_shader\", \"pass_through.vert\", vertexShader, 64,\n                            configPath);\n    GetPrivateProfileString(\"output\", \"fragment_shader\", \"bar_spectrum.frag\", fragmentShader, 64,\n                            configPath);\n\n#endif\n\n    sprintf(p->vertex_shader, \"%s/shaders/%s\", cava_config_home, vertexShader);\n    sprintf(p->fragment_shader, \"%s/shaders/%s\", cava_config_home, fragmentShader);\n\n    bool result = validate_config(p, error);\n\n    return result;\n}\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 2.826171875,
          "content": "#pragma once\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ERROR_LEN 1024\n\n#ifdef PORTAUDIO\n#define HAS_PORTAUDIO true\n#else\n#define HAS_PORTAUDIO false\n#endif\n\n#ifdef ALSA\n#define HAS_ALSA true\n#else\n#define HAS_ALSA false\n#endif\n\n#ifdef PULSE\n#define HAS_PULSE true\n#else\n#define HAS_PULSE false\n#endif\n\n#ifdef PIPEWIRE\n#define HAS_PIPEWIRE true\n#else\n#define HAS_PIPEWIRE false\n#endif\n\n#ifdef SNDIO\n#define HAS_SNDIO true\n#else\n#define HAS_SNDIO false\n#endif\n\n#ifdef OSS\n#define HAS_OSS true\n#else\n#define HAS_OSS false\n#endif\n\n#ifdef JACK\n#define HAS_JACK true\n#else\n#define HAS_JACK false\n#endif\n\n#ifdef _MSC_VER\n#define HAS_WINSCAP true\n#define SDL true\n#define HAS_FIFO false\n#define HAS_SHMEM false\n#define PATH_MAX 260\n#else\n#define HAS_WINSCAP false\n#define HAS_FIFO true\n#define HAS_SHMEM true\n\n#endif\n\n// These are in order of least-favourable to most-favourable choices, in case\n// multiple are supported and configured.\nenum input_method {\n    INPUT_FIFO,\n    INPUT_PORTAUDIO,\n    INPUT_PIPEWIRE,\n    INPUT_ALSA,\n    INPUT_PULSE,\n    INPUT_SNDIO,\n    INPUT_OSS,\n    INPUT_JACK,\n    INPUT_SHMEM,\n    INPUT_WINSCAP,\n    INPUT_MAX,\n};\n\nenum output_method {\n    OUTPUT_NCURSES,\n    OUTPUT_NONCURSES,\n    OUTPUT_RAW,\n    OUTPUT_SDL,\n    OUTPUT_SDL_GLSL,\n    OUTPUT_NORITAKE,\n    OUTPUT_NOT_SUPORTED\n};\n\nenum mono_option { LEFT, RIGHT, AVERAGE };\nenum data_format { FORMAT_ASCII = 0, FORMAT_BINARY = 1, FORMAT_NTK3000 = 2 };\n\nenum xaxis_scale { NONE, FREQUENCY, NOTE };\n\nenum orientation {\n    ORIENT_BOTTOM,\n    ORIENT_TOP,\n    ORIENT_LEFT,\n    ORIENT_RIGHT,\n    ORIENT_SPLIT_H,\n    ORIENT_SPLIT_V\n};\n\nstruct config_params {\n    char *color, *bcolor, *raw_target, *audio_source,\n        /**gradient_color_1, *gradient_color_2,*/ **gradient_colors, *data_format, *vertex_shader,\n        *fragment_shader;\n\n    char bar_delim, frame_delim;\n    double monstercat, integral, gravity, ignore, sens, noise_reduction;\n    unsigned int lower_cut_off, upper_cut_off;\n    double *userEQ;\n    enum input_method input;\n    enum output_method output;\n    enum xaxis_scale xaxis;\n    enum mono_option mono_opt;\n    enum orientation orientation;\n    int userEQ_keys, userEQ_enabled, col, bgcol, autobars, stereo, raw_format, ascii_range,\n        bit_format, gradient, gradient_count, fixedbars, framerate, bar_width, bar_spacing,\n        bar_height, autosens, overshoot, waves, samplerate, samplebits, channels, autoconnect,\n        sleep_timer, sdl_width, sdl_height, sdl_x, sdl_y, sdl_full_screen, draw_and_quit, zero_test,\n        non_zero_test, reverse, sync_updates, continuous_rendering, disable_blanking,\n        show_idle_bar_heads, waveform;\n};\n\nstruct error_s {\n    char message[MAX_ERROR_LEN];\n    int length;\n};\n\nbool load_config(char configPath[PATH_MAX], struct config_params *p, bool colorsOnly,\n                 struct error_s *error);\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 12.537109375,
          "content": "AC_INIT([cava], [m4_esyscmd_s([cat version])], [karl@stavestrand.no])\nAM_INIT_AUTOMAKE([subdir-objects -Wall -Werror foreign])\ndnl AC_CONFIG_MACRO_DIRS([m4])\nAM_PROG_AR\nLT_INIT\nAC_PROG_CC\nAC_PROG_CC_STDC\n\nAM_PROG_LIBTOOL\n\n\nAC_CANONICAL_HOST\n\nbuild_linux=no\nbuild_windows=no\nbuild_mac=no\nbuild_freebsd=no\n\nAC_MSG_NOTICE([Checking OS])\n# Detect the target system\ncase \"${host_os}\" in\n    linux*)\n        AC_MSG_NOTICE([Linux detected])\n        build_linux=yes\n        ;;\n    darwin*)\n        AC_MSG_NOTICE([OSX detected])\n        build_mac=yes\n        ;;\n    freebsd*)\n        AC_MSG_NOTICE([FreeBSD detected])\n        build_freebsd=yes\n        ;;\n    *)\n        AC_MSG_ERROR([\"OS $host_os is not supported\"])\n        ;;\nesac\n\n# Pass the conditionals to automake\nAM_CONDITIONAL([LINUX], [test \"$build_linux\" = \"yes\"])\nAM_CONDITIONAL([OSX], [test \"$build_mac\" = \"yes\"])\nAM_CONDITIONAL([FREEBSD], [test \"$build_freebsd\" = \"yes\"])\n\n\ndnl ############################\ndnl checking if debug is enabled\ndnl ############################\n\nAC_ARG_ENABLE([debug-output],\n  AS_HELP_STRING([--enable-debug-output],\n    [enable debug messages and frequency table output])\n)\n\nAS_IF([test \"x$enable_debug_output\" != \"xyes\"], [\n  dnl enabling debug output mode\n  CPPFLAGS=\"$CPPFLAGS -DNDEBUG\"\n])\n\nAC_ARG_ENABLE([asan],\n  AS_HELP_STRING([--enable-asan],\n    [build with AddressSanitizer])\n)\n\nAS_IF([test \"x$enable_asan\" = \"xyes\"], [\n  dnl enabling asan\n  CPPFLAGS=\"$CPPFLAGS -fsanitize=address\"\n  LDFLAGS=\"$LDFLAGS -fsanitize=address\"\n])\n\nAC_ARG_ENABLE([tsan],\n  AS_HELP_STRING([--enable-tsan],\n    [build with ThreadSanitizer])\n)\n\nAS_IF([test \"x$enable_tsan\" = \"xyes\"], [\n  dnl enabling tsan\n  CPPFLAGS=\"$CPPFLAGS -fsanitize=thread\"\n  LDFLAGS=\"$LDFLAGS -fsanitize=thread\"\n])\n\nAC_ARG_ENABLE([ubsan],\n  AS_HELP_STRING([--enable-ubsan],\n    [build with UndefinedBehaviorSanitizer])\n)\n\nAS_IF([test \"x$enable_ubsan\" = \"xyes\"], [\n  dnl enabling ubsan\n  CPPFLAGS=\"$CPPFLAGS -fsanitize=undefined\"\n  LDFLAGS=\"$LDFLAGS -fsanitize=undefined\"\n])\n\n\ndnl ######################\ndnl checking for pthread\ndnl ######################\n\nAC_CHECK_HEADERS([pthread.h],\n\tAC_CHECK_LIB(pthread, pthread_create, LIBS=\"$LIBS -lpthread\",\n\t\tAC_MSG_ERROR([pthread.h found but there is no pthread library to make use of])\n\t),\n\tAC_MSG_ERROR([no pthread.h header header file found])\n)\n\ndnl ######################\ndnl checking for alloca.h\ndnl ######################\n\nAC_CHECK_HEADER([alloca.h], [CPPFLAGS=\"$CPPFLAGS -DHAVE_ALLOCA_H\"])\n\ndnl ######################\ndnl checking for alsa dev\ndnl ######################\nAC_ARG_ENABLE([input_alsa],\n  AS_HELP_STRING([--disable-input-alsa],\n    [do not include support for input from alsa streams])\n)\n\nAS_IF([test \"x$enable_input_alsa\" != \"xno\"], [\n  AC_CHECK_LIB(asound, snd_pcm_open, have_alsa=yes, have_alsa=no)\n  if [[ $have_alsa = \"yes\" ]] ; then\n    LIBS=\"$LIBS -lasound\"\n    CPPFLAGS=\"$CPPFLAGS -DALSA\"\n  fi\n  if [[ $have_alsa = \"no\" ]] ; then\n    AC_MSG_NOTICE([WARNING: No alsa dev files found building without alsa support])\n  fi],\n  [have_alsa=no]\n)\n\nAM_CONDITIONAL([ALSA], [test \"x$have_alsa\" = \"xyes\"])\n\ndnl ######################\ndnl checking for pipewire dev\ndnl ######################\nAC_ARG_ENABLE([input_pipewire],\n  AS_HELP_STRING([--disable-input-pipewire],\n    [do not include support for input from pipewire])\n)\n\nAS_IF([test \"x$enable_input_pipewire\" != \"xno\"], [\n  PKG_CHECK_MODULES(PIPEWIRE, libpipewire-0.3, have_pipewire=yes, have_pipewire=no)\n  if [[ $have_pipewire = \"yes\" ]] ; then\n    LIBS=\"$LIBS $PIPEWIRE_LIBS\"\n    CPPFLAGS=\"$CPPFLAGS -DPIPEWIRE $PIPEWIRE_CFLAGS\"\n  fi\n\n  if [[ $have_pipewire = \"no\" ]] ; then\n    AC_MSG_NOTICE([WARNING: No pipewire dev files found building without pipewire support])\n  fi],\n  [have_pipewire=no]\n)\n\nAM_CONDITIONAL([PIPEWIRE], [test \"x$have_pipewire\" = \"xyes\"])\n\n\ndnl ######################\ndnl checking for pulse dev\ndnl ######################\nAC_ARG_ENABLE([input_pulse],\n  AS_HELP_STRING([--disable-input-pulse],\n    [do not include support for input from pulseaudio])\n)\n\nAS_IF([test \"x$enable_input_pulse\" != \"xno\"], [\n  AC_CHECK_LIB(pulse-simple, pa_simple_new, have_pulse=yes, have_pulse=no)\n  if [[ $have_pulse = \"yes\" ]] ; then\n    LIBS=\"$LIBS -lpulse-simple -lpulse\"\n    CPPFLAGS=\"$CPPFLAGS -DPULSE\"\n  fi\n\n  if [[ $have_pulse = \"no\" ]] ; then\n    AC_MSG_NOTICE([WARNING: No pulseaudio dev files found building without pulseaudio support])\n  fi],\n  [have_pulse=no]\n)\n\nAM_CONDITIONAL([PULSE], [test \"x$have_pulse\" = \"xyes\"])\n\ndnl ######################\ndnl checking for portaudio dev\ndnl ######################\nAC_ARG_ENABLE([input_portaudio],\n  AS_HELP_STRING([--disable-input-portaudio],\n    [do not include support for input from portaudio])\n)\n\nAS_IF([test \"x$enable_input_portaudio\" != \"xno\"], [\n  AC_CHECK_LIB(portaudio, Pa_Initialize, have_portaudio=yes, have_portaudio=no)\n  if [[ $have_portaudio = \"yes\" ]] ; then\n    LIBS=\"$LIBS -lportaudio\"\n    CPPFLAGS=\"$CPPFLAGS -DPORTAUDIO\"\n  fi\n\n  if [[ $have_portaudio = \"no\" ]] ; then\n    AC_MSG_NOTICE([WARNING: No portaudio dev files found building without portaudio support])\n  fi],\n  [have_portaudio=no]\n)\n\nAM_CONDITIONAL([PORTAUDIO], [test \"x$have_portaudio\" = \"xyes\"])\n\ndnl ######################\ndnl checking for sndio dev\ndnl ######################\nAC_ARG_ENABLE([input_sndio],\n  AS_HELP_STRING([--disable-input-sndio],\n    [do not include support for input from sndio])\n)\n\nAS_IF([test \"x$enable_input_sndio\" != \"xno\"], [\n  AC_CHECK_LIB(sndio, sio_open, have_sndio=yes, have_sndio=no)\n  if [[ $have_sndio = \"yes\" ]] ; then\n    LIBS=\"$LIBS -lsndio\"\n    CPPFLAGS=\"$CPPFLAGS -DSNDIO\"\n  fi\n\n  if [[ $have_sndio = \"no\" ]] ; then\n    AC_MSG_NOTICE([WARNING: No sndio dev files found building without sndio support])\n  fi],\n  [have_sndio=no]\n)\n\nAM_CONDITIONAL([SNDIO], [test \"x$have_sndio\" = \"xyes\"])\n\ndnl ######################\ndnl checking for oss dev\ndnl ######################\nAC_ARG_ENABLE([input_oss],\n  AS_HELP_STRING([--disable-input-oss],\n    [do not include support for input from oss])\n)\n\nAS_IF([test \"x$enable_input_oss\" != \"xno\"], [\n  have_oss=no\n\n  if [[ $build_freebsd = \"yes\" ]] ; then\n    AC_CHECK_HEADERS(sys/soundcard.h, have_oss=yes, have_oss=no)\n    if [[ $have_oss = \"yes\" ]] ; then\n      CPPFLAGS=\"$CPPFLAGS -DOSS -D__BSD_VISIBLE\"\n    fi\n\n    if [[ $have_oss = \"no\" ]] ; then\n      AC_MSG_NOTICE([WARNING: No oss dev files found building without oss support])\n    fi\n  fi],\n  [have_oss=no]\n)\n\nAM_CONDITIONAL([OSS], [test \"x$have_oss\" = \"xyes\"])\n\ndnl ######################\ndnl checking for jack dev\ndnl ######################\nAC_ARG_ENABLE([input_jack],\n  AS_HELP_STRING([--disable-input-jack],\n    [do not include support for input from jack])\n)\n\nAS_IF([test \"x$enable_input_jack\" != \"xno\"], [\n  PKG_CHECK_MODULES(JACK, jack, have_jack=yes, have_jack=no)\n  if [[ $have_jack = \"yes\" ]] ; then\n    LIBS=\"$LIBS $JACK_LIBS\"\n    CPPFLAGS=\"$CPPFLAGS -DJACK $JACK_CFLAGS\"\n  fi\n\n  if [[ $have_jack = \"no\" ]] ; then\n    AC_MSG_NOTICE([WARNING: No jack dev files found building without jack support])\n  fi],\n  [have_jack=no]\n)\n\nAM_CONDITIONAL([JACK], [test \"x$have_jack\" = \"xyes\"])\n\ndnl ######################\ndnl checking for math lib\ndnl ######################\nAC_CHECK_LIB(m, sqrt, have_m=yes, have_m=no)\n    if [[ $have_m = \"yes\" ]] ; then\n      LIBS=\"$LIBS -lm\"\n    fi\n\n    if [[ $have_m = \"no\" ]] ; then\n      AC_MSG_ERROR([math library is required!])\n    fi\n\n\ndnl ######################\ndnl checking for fftw3 \ndnl ######################\nAC_CHECK_LIB(fftw3,fftw_execute, have_fftw=yes, have_fftw=no)\n    if [[ $have_fftw = \"yes\" ]] ; then\n      LIBS=\"$LIBS -lfftw3\"\n    fi\n\n    if [[ $have_fftw = \"no\" ]] ; then\n      AC_MSG_ERROR([fftw library is required!])\n    fi\n\ndnl ######################\ndnl checking for sdl2\ndnl ######################\nAC_ARG_ENABLE([output_sdl],\n  AS_HELP_STRING([--disable-output-sdl],\n    [do not include support for output with sdl])\n)\nAS_IF([test \"x$enable_output_sdl\" != \"xno\"], [\nAC_CHECK_LIB(SDL2,SDL_Init, have_sdl=yes, have_sdl=no)\n    if [[ $have_sdl = \"yes\" ]] ; then\n      LIBS=\"$LIBS -lSDL2\"\n      CPPFLAGS=\"$CPPFLAGS -DSDL\"\n\n      dnl ######################\n      dnl checking for opengl (only if we know we have sdl)\n      dnl ######################\n      AC_ARG_ENABLE([output_sdl_glsl],\n        AS_HELP_STRING([--disable-output-sdl-glsl],\n          [do not include support for output with sdl_glsl])\n      )\n      AS_IF([test \"x$enable_output_sdl_glsl\" != \"xno\"], [\n             m4_ifdef([AX_CHECK_GL], [\n                       AX_CHECK_GL(have_opengl=yes, have_opengl=no)\n                       ], [\n                           AC_MSG_NOTICE([You need to install the autoconf archives to check for opengl. Remember to re-run autogen.sh.])\n                           have_opengl=no\n                           ])\n      if [[ $have_opengl = \"yes\" ]] ; then\n        LIBS=\"$LIBS $GL_LIBS\"\n        CPPFLAGS=\"$CPPFLAGS -DSDL_GLSL $GL_CFLAGS\"\n      fi\n\n      if [[ $have_opengl = \"no\" ]] ; then\n        AC_MSG_NOTICE([INFO: building without sdl_glsl (opengl) support])\n      fi\n      ],\n        [have_opengl=no]\n      )\n    fi\n\n    if [[ $have_sdl = \"no\" ]] ; then\n      AC_MSG_NOTICE([INFO: building without sdl support])\n    fi\n],\n  [have_sdl=no]\n)\n\nAM_CONDITIONAL([SDL], [test \"x$have_sdl\" = \"xyes\"])\nAM_CONDITIONAL([SDL_GLSL], [test \"x$have_opengl\" = \"xyes\"])\n\ndnl ######################\ndnl checking for ncursesw\ndnl ######################\nAC_ARG_ENABLE([output_ncurses],\n  AS_HELP_STRING([--disable-output-ncurses],\n    [do not include support for output with ncurses])\n)\n\nAS_IF([test \"x$enable_output_ncurses\" != \"xno\"], [\n  curses_config_bin=\"ncursesw6-config ncursesw5-config\"\n\n  AC_PATH_PROGS(CURSES_CONFIG, $curses_config_bin)\n\n  AC_CHECK_LIB(ncursesw, initscr,\n    curses_lib=ncursesw\n  )\n\n  AC_CHECK_LIB($curses_lib, initscr,\n    if test \"$CURSES_CONFIG\" = \"\" ; then\n      LIBS=\"$LIBS -l$curses_lib\"\n      CPPFLAGS=\"$CPPFLAGS -DNCURSES\"\n    fi\n    if test \"$CURSES_CONFIG\" != \"\" ; then\n      CPPFLAGS=\"$CPPFLAGS `$CURSES_CONFIG --cflags` -DNCURSES\"\n      LIBS=\"$LIBS `$CURSES_CONFIG --libs`\"\n    fi\n\n    AC_CHECK_HEADERS([curses.h], , AC_MSG_ERROR([missing curses.h header]))\n    have_ncurses=yes,\n\n    AC_MSG_NOTICE([WARNING: building without ncursesw support ncursesw is recomended!])\n    have_ncurses=no\n  )],\n  [have_ncurses=no]\n)\n\nAM_CONDITIONAL([NCURSES], [test \"x$have_ncurses\" = \"xyes\"])\n\n\ndnl ######################\ndnl checking for cava font\ndnl ######################\nAC_ARG_ENABLE([cava_font],\n  AS_HELP_STRING([--disable-cava-font],\n    [do not include support for the console cava font])\n)\n\nAS_IF([test \"x$enable_cava_font\" != \"xno\"], [\n  have_cava_font=yes\n\n  if [[ $build_freebsd = \"yes\" ]] ; then\n    AC_PATH_PROG(VTFONTCVT, vtfontcvt)\n    if [[ -z \"$VTFONTCVT\" ]] ; then\n      AC_MSG_NOTICE([WARNING: vtfontcvt not found])\n      have_cava_font=no\n    fi\n    AC_PATH_PROG(PSF2BDF, psf2bdf)\n    if [[ -z \"$PSF2BDF\" ]] ; then\n      AC_MSG_NOTICE([WARNING: psf2bdf not found])\n      have_cava_font=no\n    fi\n    if [[ $have_cava_font = \"no\" ]] ; then\n      AC_MSG_NOTICE([WARNING: Font conversion tool missing. Building without cava font supported!])\n    fi\n  fi],\n  [have_cava_font=no]\n)\n\nAS_IF([test \"x$have_cava_font\" = \"xyes\"], [CPPFLAGS=\"$CPPFLAGS -DCAVAFONT\"], [])\nAM_CONDITIONAL([CAVAFONT], [test \"x$have_cava_font\" = \"xyes\"])\n\n\ndnl ######################\ndnl checking for iniparser\ndnl ######################\n\nAC_CHECK_LIB(iniparser,iniparser_load, have_iniparser=yes, have_iniparser=no)\n    if [[ $have_iniparser = \"yes\" ]] ; then\n    LIBS=\"$LIBS -liniparser\"\n    if [[ $build_mac = \"yes\" ]] ; then\n        CPPFLAGS=\"$CPPFLAGS -I/usr/local/include/iniparser/\"\n        CPPFLAGS=\"$CPPFLAGS -I/opt/homebrew/include/iniparser/\"\n    else\n        CPPFLAGS=\"$CPPFLAGS -I/usr/include/iniparser\"\n    fi\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <iniparser.h>]],\n      [[dictionary* ini;\n      const char *keys[3];\n      iniparser_getseckeys(ini, \"eq\", keys);]])],\n      [AC_MSG_RESULT(iniparser > 3.2 test OK)],\n      [AC_MSG_RESULT(iniparser > 3.2 test failed falling back to legacy iniparser mode)\n      CPPFLAGS=\"$CPPFLAGS -DLEGACYINIPARSER\"])\n    fi\n    if [[ $have_iniparser = \"no\" ]] ; then\n      AC_MSG_ERROR([iniparser library is required!])\n    fi\n\ndnl ############################\ndnl Set font directory\ndnl ############################\nAC_ARG_VAR(FONT_DIR, [Directory where the font will be installed.])\nAC_SUBST([FONT_FILE])\n\nAS_IF([test \"x$have_cava_font\" = \"xyes\"], [\n  if [[ \"$build_freebsd\" = \"yes\" ]] ; then\n    DEFAULT_FONT_DIR=\"${datarootdir}/cava\"\n    FONT_FILE=\"cava.fnt\"\n  else\n    DEFAULT_FONT_DIR=\"${datarootdir}/consolefonts\"\n    FONT_FILE=\"cava.psf\"\n  fi], [\n    DEFAULT_FONT_DIR=\n    FONT_FILE=]\n)\n\nif test -z \"$FONT_DIR\" ; then\n  FONT_DIR=\"$DEFAULT_FONT_DIR\"\nfi\n\n\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n\n\n\n\n\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 0.3056640625,
          "content": "#include <stdio.h>\n\n#ifdef NDEBUG\n#define debug(...)                                                                                 \\\n    do {                                                                                           \\\n    } while (0)\n#else\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#endif\n"
        },
        {
          "name": "example_files",
          "type": "tree",
          "content": null
        },
        {
          "name": "input",
          "type": "tree",
          "content": null
        },
        {
          "name": "output",
          "type": "tree",
          "content": null
        },
        {
          "name": "run_all_tests.sh",
          "type": "blob",
          "size": 0.42578125,
          "content": "#!/bin/bash\nset -e\n\n## run these commands before testing:\n# squeezelite -v -m 51:fb:32:f8:e6:9f -z\n# sudo modprobe snd-aloop\n# arecord -D hw:Loopback,1 -c 2 -r 44100 > /tmp/fifo &\n\nTESTCFGS=\"example_files/test_configs/*\"\nfor f in $TESTCFGS\ndo\n    echo \"testing $f\"\n    ./cava -p $f > /dev/null\n    echo \"OK!\"\ndone\necho \"all tets completed successfully\"\n\n## clean up:\n# killall squeezelite\n# sudo rmmod snd_aloop\n# killall arecord\nexit 0"
        },
        {
          "name": "third_party",
          "type": "tree",
          "content": null
        },
        {
          "name": "todo",
          "type": "blob",
          "size": 0.2255859375,
          "content": "TODO\n----\n\n\n* config option print cut-off frequencies on x-axis\n* config option different color for different threshold amplitude\n* possibility to save settings to config file\n* openGL\n* plug-in api\n* new demo video\n* JACK support\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 0.630859375,
          "content": "#pragma once\n\n#ifndef _MSC_VER\n#define max(a, b)                                                                                  \\\n    ({                                                                                             \\\n        __typeof__(a) _a = (a);                                                                    \\\n        __typeof__(b) _b = (b);                                                                    \\\n        _a > _b ? _a : _b;                                                                         \\\n    })\n#endif\n\n#define ARRAY_SIZE(x) ((sizeof(x) / sizeof(0 [x])) / ((size_t)(!(sizeof(x) % sizeof(0 [x])))))\n"
        }
      ]
    }
  ]
}