{
  "metadata": {
    "timestamp": 1736710106653,
    "page": 731,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "notro/fbtft",
      "stars": 1868,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.041015625,
          "content": "# This file is copied from the Linux kernel sources\n#\n# NOTE! Don't add files that are generated in specific\n# subdirectories here. Add them in the \".gitignore\" file\n# in that subdirectory instead.\n#\n# NOTE! Please use 'git ls-files -i --exclude-standard'\n# command after changing this file, to see if there are\n# any tracked files which get ignored after the change.\n#\n# Normal rules\n#\n.*\n*.o\n*.o.*\n*.a\n*.s\n*.ko\n*.so\n*.so.dbg\n*.mod.c\n*.i\n*.lst\n*.symtypes\n*.order\nmodules.builtin\n*.elf\n*.bin\n*.gz\n*.bz2\n*.lzma\n*.xz\n*.lzo\n*.patch\n*.gcno\n\n#\n# Top-level generic files\n#\n/tags\n/TAGS\n/linux\n/vmlinux\n/vmlinuz\n/System.map\n/Module.markers\n/Module.symvers\n\n#\n# Debian directory (make deb-pkg)\n#\n/debian/\n\n#\n# git files that we don't want to ignore even it they are dot-files\n#\n!.gitignore\n!.mailmap\n\n#\n# Generated include files\n#\ninclude/config\ninclude/linux/version.h\ninclude/generated\narch/*/include/generated\n\n# stgit generated dirs\npatches-*\n\n# quilt's files\npatches\nseries\n\n# cscope files\ncscope.*\nncscope.*\n\n# gnu global files\nGPATH\nGRTAGS\nGSYMS\nGTAGS\n\n*.orig\n*~\n\\#*#\n"
        },
        {
          "name": "Kconfig",
          "type": "blob",
          "size": 4.0380859375,
          "content": "menuconfig FB_TFT\n\ttristate \"Support for small TFT LCD display modules\"\n\tdepends on FB && SPI && GPIOLIB\n\tselect FB_SYS_FILLRECT\n\tselect FB_SYS_COPYAREA\n\tselect FB_SYS_IMAGEBLIT\n\tselect FB_SYS_FOPS\n\tselect FB_DEFERRED_IO\n\tselect FB_BACKLIGHT\n\nconfig FB_TFT_AGM1264K_FL\n\ttristate \"FB driver for the AGM1264K-FL LCD display\"\n\tdepends on FB_TFT\n\thelp\n\t  Framebuffer support for the AGM1264K-FL LCD display (two Samsung KS0108 compatable chips)\n\nconfig FB_TFT_BD663474\n\ttristate \"FB driver for the BD663474 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for BD663474\n\nconfig FB_TFT_HX8340BN\n\ttristate \"FB driver for the HX8340BN LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for HX8340BN\n\nconfig FB_TFT_HX8347D\n\ttristate \"FB driver for the HX8347D LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for HX8347D\n\nconfig FB_TFT_HX8353D\n\ttristate \"FB driver for the HX8353D LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for HX8353D\n\nconfig FB_TFT_ILI9320\n\ttristate \"FB driver for the ILI9320 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ILI9320\n\nconfig FB_TFT_ILI9325\n\ttristate \"FB driver for the ILI9325 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ILI9325\n\nconfig FB_TFT_ILI9340\n\ttristate \"FB driver for the ILI9340 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ILI9340\n\nconfig FB_TFT_ILI9341\n\ttristate \"FB driver for the ILI9341 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ILI9341\n\nconfig FB_TFT_ILI9481\n\ttristate \"FB driver for the ILI9481 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ILI9481\n\nconfig FB_TFT_ILI9486\n\ttristate \"FB driver for the ILI9486 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ILI9486\n\nconfig FB_TFT_PCD8544\n\ttristate \"FB driver for the PCD8544 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for PCD8544\n\nconfig FB_TFT_RA8875\n        tristate \"FB driver for the RA8875 LCD Controller\"\n        depends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for RA8875\n\nconfig FB_TFT_S6D02A1\n\ttristate \"FB driver for the S6D02A1 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for S6D02A1\n\nconfig FB_TFT_S6D1121\n\ttristate \"FB driver for the S6D1211 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for S6D1121\n\nconfig FB_TFT_SSD1289\n\ttristate \"FB driver for the SSD1289 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Framebuffer support for SSD1289\n\nconfig FB_TFT_SSD1306\n\ttristate \"FB driver for the SSD1306 OLED Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Framebuffer support for SSD1306\n\nconfig FB_TFT_SSD1331\n\ttristate \"FB driver for the SSD1331 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Framebuffer support for SSD1331\n\nconfig FB_TFT_SSD1351\n\ttristate \"FB driver for the SSD1351 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Framebuffer support for SSD1351\n\nconfig FB_TFT_ST7735R\n\ttristate \"FB driver for the ST7735R LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for ST7735R\n\nconfig FB_TFT_TINYLCD\n\ttristate \"FB driver for tinylcd.com display\"\n\tdepends on FB_TFT\n\thelp\n\t  Custom Framebuffer support for tinylcd.com display\n\nconfig FB_TFT_TLS8204\n\ttristate \"FB driver for the TLS8204 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for TLS8204\n\nconfig FB_TFT_UC1701\n\ttristate \"FB driver for the UC1701 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for UC1701\n\nconfig FB_TFT_UPD161704\n\ttristate \"FB driver for the uPD161704 LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for uPD161704\n\nconfig FB_TFT_WATTEROTT\n\ttristate \"FB driver for the WATTEROTT LCD Controller\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for WATTEROTT\n\nconfig FB_FLEX\n\ttristate \"Generic FB driver for TFT LCD displays\"\n\tdepends on FB_TFT\n\thelp\n\t  Generic Framebuffer support for TFT LCD displays.\n\nconfig FB_TFT_FBTFT_DEVICE\n\ttristate \"Module to for adding FBTFT devices\"\n\tdepends on FB_TFT\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.984375,
          "content": "ifneq ($(KERNELRELEASE),)\n# kbuild part of makefile\n\n# Optionally, include config file to allow out of tree kernel modules build\n-include $(src)/.config\n\n# Core module\nobj-$(CONFIG_FB_TFT)             += fbtft.o\nfbtft-y                          += fbtft-core.o fbtft-sysfs.o fbtft-bus.o fbtft-io.o\n\n# drivers\nobj-$(CONFIG_FB_TFT_AGM1264K_FL) += fb_agm1264k-fl.o\nobj-$(CONFIG_FB_TFT_BD663474)    += fb_bd663474.o\nobj-$(CONFIG_FB_TFT_HX8340BN)    += fb_hx8340bn.o\nobj-$(CONFIG_FB_TFT_HX8347D)     += fb_hx8347d.o\nobj-$(CONFIG_FB_TFT_HX8353D)     += fb_hx8353d.o\nobj-$(CONFIG_FB_TFT_ILI9320)     += fb_ili9320.o\nobj-$(CONFIG_FB_TFT_ILI9325)     += fb_ili9325.o\nobj-$(CONFIG_FB_TFT_ILI9340)     += fb_ili9340.o\nobj-$(CONFIG_FB_TFT_ILI9341)     += fb_ili9341.o\nobj-$(CONFIG_FB_TFT_ILI9481)     += fb_ili9481.o\nobj-$(CONFIG_FB_TFT_ILI9486)     += fb_ili9486.o\nobj-$(CONFIG_FB_TFT_PCD8544)     += fb_pcd8544.o\nobj-$(CONFIG_FB_TFT_RA8875)      += fb_ra8875.o\nobj-$(CONFIG_FB_TFT_S6D02A1)     += fb_s6d02a1.o\nobj-$(CONFIG_FB_TFT_S6D1121)     += fb_s6d1121.o\nobj-$(CONFIG_FB_TFT_SSD1289)     += fb_ssd1289.o\nobj-$(CONFIG_FB_TFT_SSD1306)     += fb_ssd1306.o\nobj-$(CONFIG_FB_TFT_SSD1331)     += fb_ssd1331.o\nobj-$(CONFIG_FB_TFT_SSD1351)     += fb_ssd1351.o\nobj-$(CONFIG_FB_TFT_ST7735R)     += fb_st7735r.o\nobj-$(CONFIG_FB_TFT_TINYLCD)     += fb_tinylcd.o\nobj-$(CONFIG_FB_TFT_TLS8204)     += fb_tls8204.o\nobj-$(CONFIG_FB_TFT_UC1701)      += fb_uc1701.o\nobj-$(CONFIG_FB_TFT_UPD161704)   += fb_upd161704.o\nobj-$(CONFIG_FB_TFT_WATTEROTT)   += fb_watterott.o\nobj-$(CONFIG_FB_FLEX)            += flexfb.o\n\n# Device modules\nobj-$(CONFIG_FB_TFT_FBTFT_DEVICE) += fbtft_device.o\n\nelse\n# normal makefile\nKDIR ?= /lib/modules/`uname -r`/build\n\ndefault: .config\n\t$(MAKE) -C $(KDIR) M=$$PWD modules\n\n.config:\n\tgrep config Kconfig | cut -d' ' -f2 | sed 's@^@CONFIG_@; s@$$@=m@' > .config\n\ninstall:\n\t$(MAKE) -C $(KDIR) M=$$PWD modules_install\n\n\nclean:\n\trm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions \\\n\t       modules.order Module.symvers\n\nendif\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 1.119140625,
          "content": "  FBTFT\n=========\n\n2015-01-19\nThe FBTFT drivers are now in the Linux kernel staging tree: https://git.kernel.org/cgit/linux/kernel/git/gregkh/staging.git/tree/drivers/staging/fbtft?h=staging-testing\nDevelopment in this github repo has ceased.\n\n\nLinux Framebuffer drivers for small TFT LCD display modules.\nThe module 'fbtft' makes writing drivers for some of these displays very easy.\n\nDevelopment is done on a Raspberry Pi running the Raspbian \"wheezy\" distribution.\n\nINSTALLATION\n  Download kernel sources\n\n  From Linux 3.15  \n    cd drivers/video/fbdev\n    git clone https://github.com/notro/fbtft.git\n    \n    Add to drivers/video/fbdev/Kconfig:   source \"drivers/video/fbdev/fbtft/Kconfig\"\n    Add to drivers/video/fbdev/Makefile:  obj-y += fbtft/\n  \n  Before Linux 3.15  \n    cd drivers/video\n    git clone https://github.com/notro/fbtft.git\n    \n    Add to drivers/video/Kconfig:   source \"drivers/video/fbtft/Kconfig\"\n    Add to drivers/video/Makefile:  obj-y += fbtft/\n  \n  Enable driver(s) in menuconfig and build the kernel\n\n\nSee wiki for more information: https://github.com/notro/fbtft/wiki\n\n\nSource: https://github.com/notro/fbtft/\n"
        },
        {
          "name": "dts",
          "type": "tree",
          "content": null
        },
        {
          "name": "fb_agm1264k-fl.c",
          "type": "blob",
          "size": 11.37109375,
          "content": "/*\n * FB driver for Two KS0108 LCD controllers in AGM1264K-FL display\n *\n * Copyright (C) 2014 ololoshka2871\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"fbtft.h\"\n\n/* Uncomment text line to use negative image on display */\n/*#define NEGATIVE*/\n\n#define WHITE\t\t0xff\n#define BLACK\t\t0\n\n#define DRVNAME\t\t\"fb_agm1264k-fl\"\n#define WIDTH\t\t64\n#define HEIGHT\t\t64\n#define TOTALWIDTH\t(WIDTH * 2)\t /* because 2 x ks0108 in one display */\n#define FPS\t\t\t20\n\n#define EPIN\t\tgpio.wr\n#define RS\t\t\tgpio.dc\n#define RW\t\t\tgpio.aux[2]\n#define CS0\t\t\tgpio.aux[0]\n#define CS1\t\t\tgpio.aux[1]\n\n\n/* diffusing error (“Floyd-Steinberg”) */\n#define DIFFUSING_MATRIX_WIDTH\t2\n#define DIFFUSING_MATRIX_HEIGHT\t2\n\nstatic const signed char\ndiffusing_matrix[DIFFUSING_MATRIX_WIDTH][DIFFUSING_MATRIX_HEIGHT] = {\n\t{-1, 3},\n\t{3, 2},\n};\n\nstatic const unsigned char gamma_correction_table[] = {\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6,\n6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13,\n13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21,\n22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32,\n33, 33, 34, 35, 35, 36, 37, 38, 39, 39, 40, 41, 42, 43, 43, 44, 45,\n46, 47, 48, 49, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 81,\n82, 83, 84, 85, 87, 88, 89, 90, 91, 93, 94, 95, 97, 98, 99, 100, 102,\n103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 119, 120, 121,\n123, 124, 126, 127, 129, 130, 132, 133, 135, 137, 138, 140, 141, 143,\n145, 146, 148, 149, 151, 153, 154, 156, 158, 159, 161, 163, 165, 166,\n168, 170, 172, 173, 175, 177, 179, 181, 182, 184, 186, 188, 190, 192,\n194, 196, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219,\n221, 223, 225, 227, 229, 231, 234, 236, 238, 240, 242, 244, 246, 248,\n251, 253, 255\n};\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tu8 i;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tfor (i = 0; i < 2; ++i) {\n\t\twrite_reg(par, i, 0x3f); /* display on */\n\t\twrite_reg(par, i, 0x40); /* set x to 0 */\n\t\twrite_reg(par, i, 0xb0); /* set page to 0 */\n\t\twrite_reg(par, i, 0xc0); /* set start line to 0 */\n\t}\n\n\treturn 0;\n}\n\nvoid reset(struct fbtft_par *par)\n{\n\tif (par->gpio.reset == -1)\n\t\treturn;\n\n\tfbtft_dev_dbg(DEBUG_RESET, par, par->info->device, \"%s()\\n\", __func__);\n\n\tgpio_set_value(par->gpio.reset, 0);\n\tudelay(20);\n\tgpio_set_value(par->gpio.reset, 1);\n\tmdelay(120);\n}\n\n/* Check if all necessary GPIOS defined */\nstatic int verify_gpios(struct fbtft_par *par)\n{\n\tint i;\n\n\tfbtft_dev_dbg(DEBUG_VERIFY_GPIOS, par, par->info->device,\n\t\t\"%s()\\n\", __func__);\n\n\tif (par->EPIN < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'wr' (aka E) gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (par->gpio.db[i] < 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Missing info about 'db[%i]' gpio. Aborting.\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (par->CS0 < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'cs0' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->CS1 < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'cs1' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->RW < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'rw' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long\nrequest_gpios_match(struct fbtft_par *par, const struct fbtft_gpio *gpio)\n{\n\tfbtft_dev_dbg(DEBUG_REQUEST_GPIOS_MATCH, par, par->info->device,\n\t\t\"%s('%s')\\n\", __func__, gpio->name);\n\n\tif (strcasecmp(gpio->name, \"wr\") == 0) {\n\t\t/* left ks0108 E pin */\n\t\tpar->EPIN = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_LOW;\n\t} else if (strcasecmp(gpio->name, \"cs0\") == 0) {\n\t\t/* left ks0108 controller pin */\n\t\tpar->CS0 = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t} else if (strcasecmp(gpio->name, \"cs1\") == 0) {\n\t\t/* right ks0108 controller pin */\n\t\tpar->CS1 = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t}\n\n\t/* if write (rw = 0) e(1->0) perform write */\n\t/* if read (rw = 1) e(0->1) set data on D0-7*/\n\telse if (strcasecmp(gpio->name, \"rw\") == 0) {\n\t\tpar->RW = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_LOW;\n\t}\n\n\treturn FBTFT_GPIO_NO_MATCH;\n}\n\n/* This function oses to enter commands\n * first byte - destination controller 0 or 1\n * folowing - commands\n */\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = (u8 *)par->buf;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = (u8)va_arg(args, unsigned int);\n\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,\n\t\t\tpar->info->device, u8, buf, len, \"%s: \", __func__);\n\t}\n\n\tva_start(args, len);\n\n\t*buf = (u8)va_arg(args, unsigned int);\n\n\tif (*buf > 1) {\n\t\tva_end(args);\n\t\tdev_err(par->info->device, \"%s: Incorrect chip sellect request (%d)\\n\",\n\t\t\t__func__, *buf);\n\t\treturn;\n\t}\n\n\t/* select chip */\n\tif (*buf) {\n\t\t/* cs1 */\n\t\tgpio_set_value(par->CS0, 1);\n\t\tgpio_set_value(par->CS1, 0);\n\t} else {\n\t\t/* cs0 */\n\t\tgpio_set_value(par->CS0, 0);\n\t\tgpio_set_value(par->CS1, 1);\n\t}\n\n\tgpio_set_value(par->RS, 0); /* RS->0 (command mode) */\n\tlen--;\n\n\tif (len) {\n\t\ti = len;\n\t\twhile (i--)\n\t\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\t\tret = par->fbtftops.write(par, par->buf, len * (sizeof(u8)));\n\t\tif (ret < 0) {\n\t\t\tva_end(args);\n\t\t\tdev_err(par->info->device, \"%s: write() failed and returned %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tva_end(args);\n}\n\nstatic struct\n{\n\tint xs, ys_page, xe, ye_page;\n} addr_win;\n\n/* save display writing zone */\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\taddr_win.xs = xs;\n\taddr_win.ys_page = ys / 8;\n\taddr_win.xe = xe;\n\taddr_win.ye_page = ye / 8;\n\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys_page=%d, xe=%d, ye_page=%d)\\n\", __func__,\n\t\taddr_win.xs, addr_win.ys_page, addr_win.xe, addr_win.ye_page);\n}\n\nstatic void\nconstruct_line_bitmap(struct fbtft_par *par, u8 *dest, signed short *src,\n\t\t\t\t\t\tint xs, int xe, int y)\n{\n\tint x, i;\n\n\tfor (x = xs; x < xe; ++x) {\n\t\tu8 res = 0;\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (src[(y * 8 + i) * par->info->var.xres + x])\n\t\t\t\tres |= 1 << i;\n#ifdef NEGATIVE\n\t\t*dest++ = res;\n#else\n\t\t*dest++ = ~res;\n#endif\n\t}\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_base;\n\tu8 *buf = par->txbuf.buf;\n\tint x, y;\n\tint ret = 0;\n\n\t/* buffer to convert RGB565 -> grayscale16 -> Ditherd image 1bpp */\n\tsigned short *convert_buf = kmalloc(par->info->var.xres *\n\t\tpar->info->var.yres * sizeof(signed short), GFP_NOIO);\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\t/* converting to grayscale16 */\n\tfor (x = 0; x < par->info->var.xres; ++x)\n\t\tfor (y = 0; y < par->info->var.yres; ++y) {\n\t\t\tu16 pixel = vmem16[y *  par->info->var.xres + x];\n\t\t\tu16 b = pixel & 0x1f;\n\t\t\tu16 g = (pixel & (0x3f << 5)) >> 5;\n\t\t\tu16 r = (pixel & (0x1f << (5 + 6))) >> (5 + 6);\n\n\t\t\tpixel = (299 * r + 587 * g + 114 * b) / 200;\n\t\t\tif (pixel > 255)\n\t\t\t\tpixel = 255;\n\n\t\t\t/* gamma-correction by table */\n\t\t\tconvert_buf[y *  par->info->var.xres + x] =\n\t\t\t\t(signed short)gamma_correction_table[pixel];\n\t\t}\n\n\t/* Image Dithering */\n\tfor (x = 0; x < par->info->var.xres; ++x)\n\t\tfor (y = 0; y < par->info->var.yres; ++y) {\n\t\t\tsigned short pixel =\n\t\t\t\tconvert_buf[y *  par->info->var.xres + x];\n\t\t\tsigned short error_b = pixel - BLACK;\n\t\t\tsigned short error_w = pixel - WHITE;\n\t\t\tsigned short error;\n\t\t\tu16 i, j;\n\n\t\t\t/* what color close? */\n\t\t\tif (abs(error_b) >= abs(error_w)) {\n\t\t\t\t/* white */\n\t\t\t\terror = error_w;\n\t\t\t\tpixel = 0xff;\n\t\t\t} else {\n\t\t\t\t/* black */\n\t\t\t\terror = error_b;\n\t\t\t\tpixel = 0;\n\t\t\t}\n\n\t\t\terror /= 8;\n\n\t\t\t/* diffusion matrix row */\n\t\t\tfor (i = 0; i < DIFFUSING_MATRIX_WIDTH; ++i)\n\t\t\t\t/* diffusion matrix column */\n\t\t\t\tfor (j = 0; j < DIFFUSING_MATRIX_HEIGHT; ++j) {\n\t\t\t\t\tsigned short *write_pos;\n\t\t\t\t\tsigned char coeff;\n\n\t\t\t\t\t/* skip pixels out of zone */\n\t\t\t\t\tif (x + i < 0 ||\n\t\t\t\t\t\tx + i >= par->info->var.xres\n\t\t\t\t\t\t|| y + j >= par->info->var.yres)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\twrite_pos = &convert_buf[\n\t\t\t\t\t\t(y + j) * par->info->var.xres +\n\t\t\t\t\t\tx + i];\n\t\t\t\t\tcoeff = diffusing_matrix[i][j];\n\t\t\t\t\tif (coeff == -1)\n\t\t\t\t\t\t/* pixel itself */\n\t\t\t\t\t\t*write_pos = pixel;\n\t\t\t\t\telse {\n\t\t\t\t\t\tsigned short p = *write_pos +\n\t\t\t\t\t\t\terror * coeff;\n\n\t\t\t\t\t\tif (p > WHITE)\n\t\t\t\t\t\t\tp = WHITE;\n\t\t\t\t\t\tif (p < BLACK)\n\t\t\t\t\t\t\tp = BLACK;\n\t\t\t\t\t\t*write_pos = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t /* 1 string = 2 pages */\n\t for (y = addr_win.ys_page; y <= addr_win.ye_page; ++y) {\n\t\t/* left half of display */\n\t\tif (addr_win.xs < par->info->var.xres / 2) {\n\t\t\tconstruct_line_bitmap(par, buf, convert_buf,\n\t\t\t\taddr_win.xs, par->info->var.xres / 2, y);\n\n\t\t\tlen = par->info->var.xres / 2 - addr_win.xs;\n\n\t\t\t/* select left side (sc0)\n\t\t\t * set addr\n\t\t\t */\n\t\t\twrite_reg(par, 0x00, (1 << 6) | (u8)addr_win.xs);\n\t\t\twrite_reg(par, 0x00, (0x17 << 3) | (u8)y);\n\n\t\t\t/* write bitmap */\n\t\t\tgpio_set_value(par->RS, 1); /* RS->1 (data mode) */\n\t\t\tret = par->fbtftops.write(par, buf, len);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"%s: write failed and returned: %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t\t/* right half of display */\n\t\tif (addr_win.xe >= par->info->var.xres / 2) {\n\t\t\tconstruct_line_bitmap(par, buf,\n\t\t\t\tconvert_buf, par->info->var.xres / 2,\n\t\t\t\taddr_win.xe + 1, y);\n\n\t\t\tlen = addr_win.xe + 1 - par->info->var.xres / 2;\n\n\t\t\t/* select right side (sc1)\n\t\t\t * set addr\n\t\t\t */\n\t\t\twrite_reg(par, 0x01, (1 << 6));\n\t\t\twrite_reg(par, 0x01, (0x17 << 3) | (u8)y);\n\n\t\t\t/* write bitmap */\n\t\t\tgpio_set_value(par->RS, 1); /* RS->1 (data mode) */\n\t\t\tpar->fbtftops.write(par, buf, len);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"%s: write failed and returned: %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\tkfree(convert_buf);\n\n\tgpio_set_value(par->CS0, 1);\n\tgpio_set_value(par->CS1, 1);\n\n\treturn ret;\n}\n\nstatic int write(struct fbtft_par *par, void *buf, size_t len)\n{\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\tgpio_set_value(par->RW, 0); /* set write mode */\n\n\n\twhile (len--) {\n\t\tu8 i, data;\n\n\t\tdata = *(u8 *) buf++;\n\n\t\t/* set data bus */\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tgpio_set_value(par->gpio.db[i], data & (1 << i));\n\t\t/* set E */\n\t\tgpio_set_value(par->EPIN, 1);\n\t\tudelay(5);\n\t\t/* unset E - write */\n\t\tgpio_set_value(par->EPIN, 0);\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = TOTALWIDTH,\n\t.height = HEIGHT,\n\t.fps = FPS,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.verify_gpios = verify_gpios,\n\t\t.request_gpios_match = request_gpios_match,\n\t\t.reset = reset,\n\t\t.write = write,\n\t\t.write_register = write_reg8_bus8,\n\t\t.write_vmem = write_vmem,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"displaytronic,fb_agm1264k-fl\", &display);\n\nMODULE_ALIAS(\"platform:\" DRVNAME);\n\nMODULE_DESCRIPTION(\"Two KS0108 LCD controllers in AGM1264K-FL display\");\nMODULE_AUTHOR(\"ololoshka2871\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_bd663474.c",
          "type": "blob",
          "size": 5.0771484375,
          "content": "/*\n * FB driver for the uPD161704 LCD Controller\n *\n * Copyright (C) 2014 Seong-Woo Kim\n *\n * Based on fb_ili9325.c by Noralf Tronnes\n * Based on ili9325.c by Jeroen Domburg\n * Init code from UTFT library by Henning Karlsen\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_bd663474\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define BPP\t\t16\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tif (par->gpio.cs != -1)\n\t\tgpio_set_value(par->gpio.cs, 0);  /* Activate chip */\n\n\tpar->fbtftops.reset(par);\n\n\t/* Initialization sequence from Lib_UTFT */\n\n\t/* oscillator start */\n\twrite_reg(par, 0x000,0x0001);\t/*oscillator 0: stop, 1: operation */\n\tmdelay(10);\n\n\t/* Power settings */\n\twrite_reg(par, 0x100, 0x0000 ); /* power supply setup */\n\twrite_reg(par, 0x101, 0x0000 );\n\twrite_reg(par, 0x102, 0x3110 );\n\twrite_reg(par, 0x103, 0xe200 );\n\twrite_reg(par, 0x110, 0x009d );\n\twrite_reg(par, 0x111, 0x0022 );\n\twrite_reg(par, 0x100, 0x0120 );\n\tmdelay( 20 );\n\n\twrite_reg(par, 0x100, 0x3120 );\n\tmdelay( 80 );\n\t/* Display control */\n\twrite_reg(par, 0x001, 0x0100 );\n\twrite_reg(par, 0x002, 0x0000 );\n\twrite_reg(par, 0x003, 0x1230 );\n\twrite_reg(par, 0x006, 0x0000 );\n\twrite_reg(par, 0x007, 0x0101 );\n\twrite_reg(par, 0x008, 0x0808 );\n\twrite_reg(par, 0x009, 0x0000 );\n\twrite_reg(par, 0x00b, 0x0000 );\n\twrite_reg(par, 0x00c, 0x0000 );\n\twrite_reg(par, 0x00d, 0x0018 );\n\t/* LTPS control settings */\n\twrite_reg(par, 0x012, 0x0000 );\n\twrite_reg(par, 0x013, 0x0000 );\n\twrite_reg(par, 0x018, 0x0000 );\n\twrite_reg(par, 0x019, 0x0000 );\n\n\twrite_reg(par, 0x203, 0x0000 );\n\twrite_reg(par, 0x204, 0x0000 );\n\n\twrite_reg(par, 0x210, 0x0000 );\n\twrite_reg(par, 0x211, 0x00ef );\n\twrite_reg(par, 0x212, 0x0000 );\n\twrite_reg(par, 0x213, 0x013f );\n\twrite_reg(par, 0x214, 0x0000 );\n\twrite_reg(par, 0x215, 0x0000 );\n\twrite_reg(par, 0x216, 0x0000 );\n\twrite_reg(par, 0x217, 0x0000 );\n\n\t/* Gray scale settings */\n\twrite_reg(par, 0x300, 0x5343);\n\twrite_reg(par, 0x301, 0x1021);\n\twrite_reg(par, 0x302, 0x0003);\n\twrite_reg(par, 0x303, 0x0011);\n\twrite_reg(par, 0x304, 0x050a);\n\twrite_reg(par, 0x305, 0x4342);\n\twrite_reg(par, 0x306, 0x1100);\n\twrite_reg(par, 0x307, 0x0003);\n\twrite_reg(par, 0x308, 0x1201);\n\twrite_reg(par, 0x309, 0x050a);\n\n\t/* RAM access settings */\n\twrite_reg(par, 0x400, 0x4027 );\n\twrite_reg(par, 0x401, 0x0000 );\n\twrite_reg(par, 0x402, 0x0000 );  /* First screen drive position (1) */\n\twrite_reg(par, 0x403, 0x013f );  /* First screen drive position (2) */\n\twrite_reg(par, 0x404, 0x0000 );\n\n\twrite_reg(par, 0x200, 0x0000 );\n\twrite_reg(par, 0x201, 0x0000 );\n\twrite_reg(par, 0x100, 0x7120 );\n\twrite_reg(par, 0x007, 0x0103 );\n\tmdelay( 10 );\n\twrite_reg(par, 0x007, 0x0113 );\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\tswitch (par->info->var.rotate) {\n\t/* R200h = Horizontal GRAM Start Address */\n\t/* R201h = Vertical GRAM Start Address */\n\tcase 0:\n\t\twrite_reg(par, 0x0200, xs);\n\t\twrite_reg(par, 0x0201, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0200, WIDTH - 1 - xs);\n\t\twrite_reg(par, 0x0201, HEIGHT - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0200, WIDTH - 1 - ys);\n\t\twrite_reg(par, 0x0201, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0200, ys);\n\t\twrite_reg(par, 0x0201, HEIGHT - 1 - xs);\n\t\tbreak;\n\t}\n\twrite_reg(par, 0x202); /* Write Data to GRAM */\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\t/* AM: GRAM update direction */\n\tcase 0:\n\t\twrite_reg(par, 0x003, 0x1230);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x003, 0x1200);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x003, 0x1228);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x003, 0x1218);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.bpp = BPP,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"hitachi,bd663474\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:bd663474\");\nMODULE_ALIAS(\"platform:bd663474\");\n\nMODULE_DESCRIPTION(\"FB driver for the uPD161704 LCD Controller\");\nMODULE_AUTHOR(\"Seong-Woo Kim\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_hx8340bn.c",
          "type": "blob",
          "size": 6.509765625,
          "content": "/*\n * FB driver for the HX8340BN LCD Controller\n *\n * This display uses 9-bit SPI: Data/Command bit + 8 data bits\n * For platforms that doesn't support 9-bit, the driver is capable\n * of emulating this using 8-bit transfer.\n * This is done by transfering eight 9-bit words in 9 bytes.\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_hx8340bn\"\n#define WIDTH\t\t176\n#define HEIGHT\t\t220\n#define TXBUFLEN\t(4 * PAGE_SIZE)\n#define DEFAULT_GAMMA\t\"1 3 0E 5 0 2 09 0 6 1 7 1 0 2 2\\n\" \\\n\t\t\t\"3 3 17 8 4 7 05 7 6 0 3 1 6 0 0 \"\n\n\nstatic bool emulate;\nmodule_param(emulate, bool, 0);\nMODULE_PARM_DESC(emulate, \"Force emulation in 9-bit mode\");\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\t/* BTL221722-276L startup sequence, from datasheet */\n\n\t/* SETEXTCOM: Set extended command set (C1h)\n\t   This command is used to set extended command set access enable.\n\t   Enable: After command (C1h), must write: ffh,83h,40h */\n\twrite_reg(par, 0xC1, 0xFF, 0x83, 0x40);\n\n\t/* Sleep out\n\t   This command turns off sleep mode.\n\t   In this mode the DC/DC converter is enabled, Internal oscillator\n\t   is started, and panel scanning is started. */\n\twrite_reg(par, 0x11);\n\tmdelay(150);\n\n\t/* Undoc'd register? */\n\twrite_reg(par, 0xCA, 0x70, 0x00, 0xD9);\n\n\t/* SETOSC: Set Internal Oscillator (B0h)\n\t   This command is used to set internal oscillator related settings */\n\t/*\tOSC_EN: Enable internal oscillator */\n\t/*\tInternal oscillator frequency: 125% x 2.52MHz */\n\twrite_reg(par, 0xB0, 0x01, 0x11);\n\n\t/* Drive ability setting */\n\twrite_reg(par, 0xC9, 0x90, 0x49, 0x10, 0x28, 0x28, 0x10, 0x00, 0x06);\n\tmdelay(20);\n\n\t/* SETPWCTR5: Set Power Control 5(B5h)\n\t   This command is used to set VCOM Low and VCOM High Voltage */\n\t/* VCOMH 0110101 :  3.925 */\n\t/* VCOML 0100000 : -1.700 */\n\t/* 45h=69  VCOMH: \"VMH\" + 5d   VCOML: \"VMH\" + 5d */\n\twrite_reg(par, 0xB5, 0x35, 0x20, 0x45);\n\n\t/* SETPWCTR4: Set Power Control 4(B4h)\n\t\tVRH[4:0]:\tSpecify the VREG1 voltage adjusting.\n\t\t\t\tVREG1 voltage is for gamma voltage setting.\n\t\tBT[2:0]:\tSwitch the output factor of step-up circuit 2\n\t\t\t\tfor VGH and VGL voltage generation. */\n\twrite_reg(par, 0xB4, 0x33, 0x25, 0x4C);\n\tmdelay(10);\n\n\t/* Interface Pixel Format (3Ah)\n\t   This command is used to define the format of RGB picture data,\n\t   which is to be transfer via the system and RGB interface. */\n\t/* RGB interface: 16 Bit/Pixel\t*/\n\twrite_reg(par, 0x3A, 0x05);\n\n\t/* Display on (29h)\n\t   This command is used to recover from DISPLAY OFF mode.\n\t   Output from the Frame Memory is enabled. */\n\twrite_reg(par, 0x29);\n\tmdelay(10);\n\n\treturn 0;\n}\n\nvoid set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\twrite_reg(par, FBTFT_CASET, 0x00, xs, 0x00, xe);\n\twrite_reg(par, FBTFT_RASET, 0x00, ys, 0x00, ye);\n\twrite_reg(par, FBTFT_RAMWR);\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* MADCTL - Memory data access control */\n\t/* RGB/BGR can be set with H/W pin SRGB and MADCTL BGR bit */\n#define MY (1 << 7)\n#define MX (1 << 6)\n#define MV (1 << 5)\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x36, (par->bgr << 3));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x36, MX | MV | (par->bgr << 3));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, MX | MY | (par->bgr << 3));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, MY | MV | (par->bgr << 3));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  Gamma Curve selection, GC (only GC0 can be customized):\n    0 = 2.2, 1 = 1.8, 2 = 2.5, 3 = 1.0\n  Gamma string format:\n    OP0 OP1 CP0 CP1 CP2 CP3 CP4 MP0 MP1 MP2 MP3 MP4 MP5 CGM0 CGM1\n    ON0 ON1 CN0 CN1 CN2 CN3 CN4 MN0 MN1 MN2 MN3 MN4 MN5 XXXX  GC\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long mask[] = {\n\t\t0b1111, 0b1111, 0b11111, 0b1111, 0b1111, 0b1111, 0b11111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111, 0b111, 0b11, 0b11,\n\t\t0b1111, 0b1111, 0b11111, 0b1111, 0b1111, 0b1111, 0b11111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111, 0b111, 0b0, 0b0 };\n\tint i, j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < par->gamma.num_curves; i++)\n\t\tfor (j = 0; j < par->gamma.num_values; j++)\n\t\t\tCURVE(i, j) &= mask[i * par->gamma.num_values + j];\n\n\twrite_reg(par, 0x26, 1 << CURVE(1, 14)); /* Gamma Set (26h) */\n\n\tif (CURVE(1, 14))\n\t\treturn 0; /* only GC0 can be customized */\n\n\twrite_reg(par, 0xC2,\n\t\t(CURVE(0, 8) << 4) | CURVE(0, 7),\n\t\t(CURVE(0, 10) << 4) | CURVE(0, 9),\n\t\t(CURVE(0, 12) << 4) | CURVE(0, 11),\n\t\tCURVE(0, 2),\n\t\t(CURVE(0, 4) << 4) | CURVE(0, 3),\n\t\tCURVE(0, 5),\n\t\tCURVE(0, 6),\n\t\t(CURVE(0, 1) << 4) | CURVE(0, 0),\n\t\t(CURVE(0, 14) << 2) | CURVE(0, 13));\n\n\twrite_reg(par, 0xC3,\n\t\t(CURVE(1, 8) << 4) | CURVE(1, 7),\n\t\t(CURVE(1, 10) << 4) | CURVE(1, 9),\n\t\t(CURVE(1, 12) << 4) | CURVE(1, 11),\n\t\tCURVE(1, 2),\n\t\t(CURVE(1, 4) << 4) | CURVE(1, 3),\n\t\tCURVE(1, 5),\n\t\tCURVE(1, 6),\n\t\t(CURVE(1, 1) << 4) | CURVE(1, 0));\n\n\tmdelay(10);\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.txbuflen = TXBUFLEN,\n\t.gamma_num = 2,\n\t.gamma_len = 15,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"himax,hx8340bn\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:hx8340bn\");\nMODULE_ALIAS(\"platform:hx8340bn\");\n\nMODULE_DESCRIPTION(\"FB driver for the HX8340BN LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_hx8347d.c",
          "type": "blob",
          "size": 4.9453125,
          "content": "/*\n * FB driver for the HX8347D LCD Controller\n *\n * Copyright (C) 2013 Christian Vogelgsang\n *\n * Based on driver code found here: https://github.com/watterott/r61505u-Adapter\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_hx8347d\"\n#define WIDTH\t\t320\n#define HEIGHT\t\t240\n#define DEFAULT_GAMMA\t\"0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\" \\\n\t\t\t\"0 0 0 0 0 0 0 0 0 0 0 0 0 0\"\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\t/* driving ability */\n\twrite_reg(par, 0xEA, 0x00);\n\twrite_reg(par, 0xEB, 0x20);\n\twrite_reg(par, 0xEC, 0x0C);\n\twrite_reg(par, 0xED, 0xC4);\n\twrite_reg(par, 0xE8, 0x40);\n\twrite_reg(par, 0xE9, 0x38);\n\twrite_reg(par, 0xF1, 0x01);\n\twrite_reg(par, 0xF2, 0x10);\n\twrite_reg(par, 0x27, 0xA3);\n\n\t/* power voltage */\n\twrite_reg(par, 0x1B, 0x1B);\n\twrite_reg(par, 0x1A, 0x01);\n\twrite_reg(par, 0x24, 0x2F);\n\twrite_reg(par, 0x25, 0x57);\n\n\t/* VCOM offset */\n\twrite_reg(par, 0x23, 0x8D); /* for flicker adjust */\n\n\t/* power on */\n\twrite_reg(par, 0x18, 0x36);\n\twrite_reg(par, 0x19, 0x01); /* start osc */\n\twrite_reg(par, 0x01, 0x00); /* wakeup */\n\twrite_reg(par, 0x1F, 0x88);\n\tmdelay(5);\n\twrite_reg(par, 0x1F, 0x80);\n\tmdelay(5);\n\twrite_reg(par, 0x1F, 0x90);\n\tmdelay(5);\n\twrite_reg(par, 0x1F, 0xD0);\n\tmdelay(5);\n\n\t/* color selection */\n\twrite_reg(par, 0x17, 0x05); /* 65k */\n\n\t/*panel characteristic */\n\twrite_reg(par, 0x36, 0x00);\n\n\t/*display on */\n\twrite_reg(par, 0x28, 0x38);\n\tmdelay(40);\n\twrite_reg(par, 0x28, 0x3C);\n\n\t/* orientation */\n\twrite_reg(par, 0x16, 0x60 | (par->bgr << 3));\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\twrite_reg(par, 0x02, (xs >> 8) & 0xFF);\n\twrite_reg(par, 0x03, xs & 0xFF);\n\twrite_reg(par, 0x04, (xe >> 8) & 0xFF);\n\twrite_reg(par, 0x05, xe & 0xFF);\n\twrite_reg(par, 0x06, (ys >> 8) & 0xFF);\n\twrite_reg(par, 0x07, ys & 0xFF);\n\twrite_reg(par, 0x08, (ye >> 8) & 0xFF);\n\twrite_reg(par, 0x09, ye & 0xFF);\n\twrite_reg(par, 0x22);\n}\n\n/*\n  Gamma string format:\n    VRP0 VRP1 VRP2 VRP3 VRP4 VRP5 PRP0 PRP1 PKP0 PKP1 PKP2 PKP3 PKP4 CGM\n    VRN0 VRN1 VRN2 VRN3 VRN4 VRN5 PRN0 PRN1 PKN0 PKN1 PKN2 PKN3 PKN4 CGM\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long mask[] = {\n\t\t0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,\n\t\t0b1111111, 0b1111111,\n\t\t0b11111, 0b11111, 0b11111, 0b11111, 0b11111,\n\t\t0b1111};\n\tint i, j;\n\tint acc = 0;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < par->gamma.num_curves; i++)\n\t\tfor (j = 0; j < par->gamma.num_values; j++) {\n\t\t\tacc += CURVE(i, j);\n\t\t\tCURVE(i, j) &= mask[j];\n\t\t}\n\n\tif (acc == 0) /* skip if all values are zero */\n\t\treturn 0;\n\n\tfor (i = 0; i < par->gamma.num_curves; i++) {\n\t\twrite_reg(par, 0x40 + (i * 0x10), CURVE(i, 0));\n\t\twrite_reg(par, 0x41 + (i * 0x10), CURVE(i, 1));\n\t\twrite_reg(par, 0x42 + (i * 0x10), CURVE(i, 2));\n\t\twrite_reg(par, 0x43 + (i * 0x10), CURVE(i, 3));\n\t\twrite_reg(par, 0x44 + (i * 0x10), CURVE(i, 4));\n\t\twrite_reg(par, 0x45 + (i * 0x10), CURVE(i, 5));\n\t\twrite_reg(par, 0x46 + (i * 0x10), CURVE(i, 6));\n\t\twrite_reg(par, 0x47 + (i * 0x10), CURVE(i, 7));\n\t\twrite_reg(par, 0x48 + (i * 0x10), CURVE(i, 8));\n\t\twrite_reg(par, 0x49 + (i * 0x10), CURVE(i, 9));\n\t\twrite_reg(par, 0x4A + (i * 0x10), CURVE(i, 10));\n\t\twrite_reg(par, 0x4B + (i * 0x10), CURVE(i, 11));\n\t\twrite_reg(par, 0x4C + (i * 0x10), CURVE(i, 12));\n\t}\n\twrite_reg(par, 0x5D, (CURVE(1, 0) << 4) | CURVE(0, 0));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = 2,\n\t.gamma_len = 14,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"himax,hx8347d\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:hx8347d\");\nMODULE_ALIAS(\"platform:hx8347d\");\n\nMODULE_DESCRIPTION(\"FB driver for the HX8347D LCD Controller\");\nMODULE_AUTHOR(\"Christian Vogelgsang\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_hx8353d.c",
          "type": "blob",
          "size": 4.275390625,
          "content": "/*\n * FB driver for the HX8353D LCD Controller\n *\n * Copyright (c) 2014 Petr Olivka\n * Copyright (c) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME \"fb_hx8353d\"\n#define DEFAULT_GAMMA \"50 77 40 08 BF 00 03 0F 00 01 73 00 72 03 B0 0F 08 00 0F\"\n\nstatic int init_display(struct fbtft_par *par)\n{\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\tmdelay(150);\n\n\t/* SETEXTC */\n\twrite_reg(par, 0xB9, 0xFF, 0x83, 0x53);\n\n\t/* RADJ */\n\twrite_reg(par, 0xB0, 0x3C, 0x01);\n\n\t/* VCOM */\n\twrite_reg(par, 0xB6, 0x94, 0x6C, 0x50);\n\n\t/* PWR */\n\twrite_reg(par, 0xB1, 0x00, 0x01, 0x1B, 0x03, 0x01, 0x08, 0x77, 0x89);\n\n\t/* COLMOD */\n\twrite_reg(par, 0x3A, 0x05);\n\n\t/* MEM ACCESS */\n\twrite_reg(par, 0x36, 0xC0);\n\n\t/* SLPOUT - Sleep out & booster on */\n\twrite_reg(par, 0x11);\n\tmdelay(150);\n\n\t/* DISPON - Display On */\n\twrite_reg(par, 0x29);\n\n\t/* RGBSET */\n\twrite_reg(par, 0x2D,\n\t\t 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,\n\t\t32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t\t16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n\t\t32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n\t\t48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n\t\t 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,\n\t\t32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62);\n\n\treturn 0;\n};\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* column address */\n\twrite_reg(par, 0x2a, xs >> 8, xs & 0xff, xe >> 8, xe & 0xff);\n\n\t/* row adress */\n\twrite_reg(par, 0x2b, ys >> 8, ys & 0xff, ye >> 8, ye & 0xff);\n\n\t/* memory write */\n\twrite_reg(par, 0x2c);\n}\n\n#define my (1 << 7)\n#define mx (1 << 6)\n#define mv (1 << 5)\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* madctl - memory data access control\n\t     rgb/bgr:\n\t     1. mode selection pin srgb\n\t\trgb h/w pin for color filter setting: 0=rgb, 1=bgr\n\t     2. madctl rgb bit\n\t\trgb-bgr order color filter panel: 0=rgb, 1=bgr */\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x36, mx | my | (par->bgr << 3));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x36, my | mv | (par->bgr << 3));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, (par->bgr << 3));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, mx | mv | (par->bgr << 3));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  gamma string format:\n*/\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\twrite_reg(par, 0xE0,\n\t\tcurves[0], curves[1], curves[2], curves[3],\n\t\tcurves[4], curves[5], curves[6], curves[7],\n\t\tcurves[8], curves[9], curves[10], curves[11],\n\t\tcurves[12], curves[13], curves[14], curves[15],\n\t\tcurves[16], curves[17], curves[18]);\n\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = 128,\n\t.height = 160,\n\t.gamma_num = 1,\n\t.gamma_len = 19,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"himax,hx8353d\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:hx8353d\");\nMODULE_ALIAS(\"platform:hx8353d\");\n\nMODULE_DESCRIPTION(\"FB driver for the HX8353D LCD Controller\");\nMODULE_AUTHOR(\"Petr Olivka\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ili9320.c",
          "type": "blob",
          "size": 7.3857421875,
          "content": "/*\n * FB driver for the ILI9320 LCD Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ili9320\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define DEFAULT_GAMMA\t\"07 07 6 0 0 0 5 5 4 0\\n\" \\\n\t\t\t\"07 08 4 7 5 1 2 0 7 7\"\n\n\nstatic unsigned read_devicecode(struct fbtft_par *par)\n{\n\tint ret;\n\tu8 rxbuf[8] = {0, };\n\n\twrite_reg(par, 0x0000);\n\tret = par->fbtftops.read(par, rxbuf, 4);\n\treturn (rxbuf[2] << 8) | rxbuf[3];\n}\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tunsigned devcode;\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tdevcode = read_devicecode(par);\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"Device code: 0x%04X\\n\",\n\t\tdevcode);\n\tif ((devcode != 0x0000) && (devcode != 0x9320))\n\t\tdev_warn(par->info->device,\n\t\t\t\"Unrecognized Device code: 0x%04X (expected 0x9320)\\n\",\n\t\t\tdevcode);\n\n\t/* Initialization sequence from ILI9320 Application Notes */\n\n\t/* *********** Start Initial Sequence ********* */\n\twrite_reg(par, 0x00E5, 0x8000); /* Set the Vcore voltage and this setting is must. */\n\twrite_reg(par, 0x0000, 0x0001); /* Start internal OSC. */\n\twrite_reg(par, 0x0001, 0x0100); /* set SS and SM bit */\n\twrite_reg(par, 0x0002, 0x0700); /* set 1 line inversion */\n\twrite_reg(par, 0x0004, 0x0000); /* Resize register */\n\twrite_reg(par, 0x0008, 0x0202); /* set the back and front porch */\n\twrite_reg(par, 0x0009, 0x0000); /* set non-display area refresh cycle */\n\twrite_reg(par, 0x000A, 0x0000); /* FMARK function */\n\twrite_reg(par, 0x000C, 0x0000); /* RGB interface setting */\n\twrite_reg(par, 0x000D, 0x0000); /* Frame marker Position */\n\twrite_reg(par, 0x000F, 0x0000); /* RGB interface polarity */\n\n\t/* ***********Power On sequence *************** */\n\twrite_reg(par, 0x0010, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */\n\twrite_reg(par, 0x0011, 0x0007); /* DC1[2:0], DC0[2:0], VC[2:0] */\n\twrite_reg(par, 0x0012, 0x0000); /* VREG1OUT voltage */\n\twrite_reg(par, 0x0013, 0x0000); /* VDV[4:0] for VCOM amplitude */\n\tmdelay(200); /* Dis-charge capacitor power voltage */\n\twrite_reg(par, 0x0010, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */\n\twrite_reg(par, 0x0011, 0x0031); /* R11h=0x0031 at VCI=3.3V DC1[2:0], DC0[2:0], VC[2:0] */\n\tmdelay(50);\n\twrite_reg(par, 0x0012, 0x0138); /* R12h=0x0138 at VCI=3.3V VREG1OUT voltage */\n\tmdelay(50);\n\twrite_reg(par, 0x0013, 0x1800); /* R13h=0x1800 at VCI=3.3V VDV[4:0] for VCOM amplitude */\n\twrite_reg(par, 0x0029, 0x0008); /* R29h=0x0008 at VCI=3.3V VCM[4:0] for VCOMH */\n\tmdelay(50);\n\twrite_reg(par, 0x0020, 0x0000); /* GRAM horizontal Address */\n\twrite_reg(par, 0x0021, 0x0000); /* GRAM Vertical Address */\n\n\t/* ------------------ Set GRAM area --------------- */\n\twrite_reg(par, 0x0050, 0x0000); /* Horizontal GRAM Start Address */\n\twrite_reg(par, 0x0051, 0x00EF); /* Horizontal GRAM End Address */\n\twrite_reg(par, 0x0052, 0x0000); /* Vertical GRAM Start Address */\n\twrite_reg(par, 0x0053, 0x013F); /* Vertical GRAM Start Address */\n\twrite_reg(par, 0x0060, 0x2700); /* Gate Scan Line */\n\twrite_reg(par, 0x0061, 0x0001); /* NDL,VLE, REV */\n\twrite_reg(par, 0x006A, 0x0000); /* set scrolling line */\n\n\t/* -------------- Partial Display Control --------- */\n\twrite_reg(par, 0x0080, 0x0000);\n\twrite_reg(par, 0x0081, 0x0000);\n\twrite_reg(par, 0x0082, 0x0000);\n\twrite_reg(par, 0x0083, 0x0000);\n\twrite_reg(par, 0x0084, 0x0000);\n\twrite_reg(par, 0x0085, 0x0000);\n\n\t/* -------------- Panel Control ------------------- */\n\twrite_reg(par, 0x0090, 0x0010);\n\twrite_reg(par, 0x0092, 0x0000);\n\twrite_reg(par, 0x0093, 0x0003);\n\twrite_reg(par, 0x0095, 0x0110);\n\twrite_reg(par, 0x0097, 0x0000);\n\twrite_reg(par, 0x0098, 0x0000);\n\twrite_reg(par, 0x0007, 0x0173); /* 262K color and display ON */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\tswitch (par->info->var.rotate) {\n\t/* R20h = Horizontal GRAM Start Address */\n\t/* R21h = Vertical GRAM Start Address */\n\tcase 0:\n\t\twrite_reg(par, 0x0020, xs);\n\t\twrite_reg(par, 0x0021, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - xs);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - ys);\n\t\twrite_reg(par, 0x0021, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0020, ys);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - xs);\n\t\tbreak;\n\t}\n\twrite_reg(par, 0x0022); /* Write Data to GRAM */\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x3, (par->bgr << 12) | 0x30);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x3, (par->bgr << 12) | 0x28);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x3, (par->bgr << 12) | 0x00);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x3, (par->bgr << 12) | 0x18);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*\n  Gamma string format:\n    VRP0 VRP1 RP0 RP1 KP0 KP1 KP2 KP3 KP4 KP5\n    VRN0 VRN1 RN0 RN1 KN0 KN1 KN2 KN3 KN4 KN5\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long mask[] = {\n\t\t0b11111, 0b11111, 0b111, 0b111, 0b111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111,\n\t\t0b11111, 0b11111, 0b111, 0b111, 0b111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111 };\n\tint i, j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tCURVE(i, j) &= mask[i*par->gamma.num_values + j];\n\n\twrite_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));\n\twrite_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));\n\twrite_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));\n\twrite_reg(par, 0x0035, CURVE(0, 3) << 8 | CURVE(0, 2));\n\twrite_reg(par, 0x0036, CURVE(0, 1) << 8 | CURVE(0, 0));\n\n\twrite_reg(par, 0x0037, CURVE(1, 5) << 8 | CURVE(1, 4));\n\twrite_reg(par, 0x0038, CURVE(1, 7) << 8 | CURVE(1, 6));\n\twrite_reg(par, 0x0039, CURVE(1, 9) << 8 | CURVE(1, 8));\n\twrite_reg(par, 0x003C, CURVE(1, 3) << 8 | CURVE(1, 2));\n\twrite_reg(par, 0x003D, CURVE(1, 1) << 8 | CURVE(1, 0));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = 2,\n\t.gamma_len = 10,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9320\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9320\");\nMODULE_ALIAS(\"platform:ili9320\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9320 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ili9325.c",
          "type": "blob",
          "size": 9.041015625,
          "content": "/*\n * FB driver for the ILI9325 LCD Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * Based on ili9325.c by Jeroen Domburg\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ili9325\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define BPP\t\t16\n#define FPS\t\t20\n#define DEFAULT_GAMMA\t\"0F 00 7 2 0 0 6 5 4 1\\n\" \\\n\t\t\t\"04 16 2 7 6 3 2 1 7 7\"\n\n\nstatic unsigned bt = 6; /* VGL=Vci*4 , VGH=Vci*4 */\nmodule_param(bt, uint, 0);\nMODULE_PARM_DESC(bt, \"Sets the factor used in the step-up circuits\");\n\nstatic unsigned vc = 0b011; /* Vci1=Vci*0.80 */\nmodule_param(vc, uint, 0);\nMODULE_PARM_DESC(vc,\n\"Sets the ratio factor of Vci to generate the reference voltages Vci1\");\n\nstatic unsigned vrh = 0b1101; /* VREG1OUT=Vci*1.85 */\nmodule_param(vrh, uint, 0);\nMODULE_PARM_DESC(vrh,\n\"Set the amplifying rate (1.6 ~ 1.9) of Vci applied to output the VREG1OUT\");\n\nstatic unsigned vdv = 0b10010; /* VCOMH amplitude=VREG1OUT*0.98 */\nmodule_param(vdv, uint, 0);\nMODULE_PARM_DESC(vdv,\n\"Select the factor of VREG1OUT to set the amplitude of Vcom\");\n\nstatic unsigned vcm = 0b001010; /* VCOMH=VREG1OUT*0.735 */\nmodule_param(vcm, uint, 0);\nMODULE_PARM_DESC(vcm, \"Set the internal VcomH voltage\");\n\n\n/*\nVerify that this configuration is within the Voltage limits\n\nDisplay module configuration: Vcc = IOVcc = Vci = 3.3V\n\n Voltages\n----------\nVci                                =   3.3\nVci1           =  Vci * 0.80       =   2.64\nDDVDH          =  Vci1 * 2         =   5.28\nVCL            = -Vci1             =  -2.64\nVREG1OUT       =  Vci * 1.85       =   4.88\nVCOMH          =  VREG1OUT * 0.735 =   3.59\nVCOM amplitude =  VREG1OUT * 0.98  =   4.79\nVGH            =  Vci * 4          =  13.2\nVGL            = -Vci * 4          = -13.2\n\n Limits\n--------\nPower supplies\n1.65 < IOVcc < 3.30   =>  1.65 < 3.3 < 3.30\n2.40 < Vcc   < 3.30   =>  2.40 < 3.3 < 3.30\n2.50 < Vci   < 3.30   =>  2.50 < 3.3 < 3.30\n\nSource/VCOM power supply voltage\n 4.50 < DDVDH < 6.0   =>  4.50 <  5.28 <  6.0\n-3.0  < VCL   < -2.0  =>  -3.0 < -2.64 < -2.0\nVCI - VCL < 6.0       =>  5.94 < 6.0\n\nGate driver output voltage\n 10  < VGH   < 20     =>   10 <  13.2  < 20\n-15  < VGL   < -5     =>  -15 < -13.2  < -5\nVGH - VGL < 32        =>   26.4 < 32\n\nVCOM driver output voltage\nVCOMH - VCOML < 6.0   =>  4.79 < 6.0\n*/\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tif (par->gpio.cs != -1)\n\t\tgpio_set_value(par->gpio.cs, 0);  /* Activate chip */\n\n\tbt &= 0b111;\n\tvc &= 0b111;\n\tvrh &= 0b1111;\n\tvdv &= 0b11111;\n\tvcm &= 0b111111;\n\n\t/* Initialization sequence from ILI9325 Application Notes */\n\n\t/* ----------- Start Initial Sequence ----------- */\n\twrite_reg(par, 0x00E3, 0x3008); /* Set internal timing */\n\twrite_reg(par, 0x00E7, 0x0012); /* Set internal timing */\n\twrite_reg(par, 0x00EF, 0x1231); /* Set internal timing */\n\twrite_reg(par, 0x0001, 0x0100); /* set SS and SM bit */\n\twrite_reg(par, 0x0002, 0x0700); /* set 1 line inversion */\n\twrite_reg(par, 0x0004, 0x0000); /* Resize register */\n\twrite_reg(par, 0x0008, 0x0207); /* set the back porch and front porch */\n\twrite_reg(par, 0x0009, 0x0000); /* set non-display area refresh cycle */\n\twrite_reg(par, 0x000A, 0x0000); /* FMARK function */\n\twrite_reg(par, 0x000C, 0x0000); /* RGB interface setting */\n\twrite_reg(par, 0x000D, 0x0000); /* Frame marker Position */\n\twrite_reg(par, 0x000F, 0x0000); /* RGB interface polarity */\n\n\t/* ----------- Power On sequence ----------- */\n\twrite_reg(par, 0x0010, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */\n\twrite_reg(par, 0x0011, 0x0007); /* DC1[2:0], DC0[2:0], VC[2:0] */\n\twrite_reg(par, 0x0012, 0x0000); /* VREG1OUT voltage */\n\twrite_reg(par, 0x0013, 0x0000); /* VDV[4:0] for VCOM amplitude */\n\tmdelay(200); /* Dis-charge capacitor power voltage */\n\twrite_reg(par, 0x0010, /* SAP, BT[3:0], AP, DSTB, SLP, STB */\n\t\t(1 << 12) | (bt << 8) | (1 << 7) | (0b001 << 4));\n\twrite_reg(par, 0x0011, 0x220 | vc); /* DC1[2:0], DC0[2:0], VC[2:0] */\n\tmdelay(50); /* Delay 50ms */\n\twrite_reg(par, 0x0012, vrh); /* Internal reference voltage= Vci; */\n\tmdelay(50); /* Delay 50ms */\n\twrite_reg(par, 0x0013, vdv << 8); /* Set VDV[4:0] for VCOM amplitude */\n\twrite_reg(par, 0x0029, vcm); /* Set VCM[5:0] for VCOMH */\n\twrite_reg(par, 0x002B, 0x000C); /* Set Frame Rate */\n\tmdelay(50); /* Delay 50ms */\n\twrite_reg(par, 0x0020, 0x0000); /* GRAM horizontal Address */\n\twrite_reg(par, 0x0021, 0x0000); /* GRAM Vertical Address */\n\n\t/*------------------ Set GRAM area --------------- */\n\twrite_reg(par, 0x0050, 0x0000); /* Horizontal GRAM Start Address */\n\twrite_reg(par, 0x0051, 0x00EF); /* Horizontal GRAM End Address */\n\twrite_reg(par, 0x0052, 0x0000); /* Vertical GRAM Start Address */\n\twrite_reg(par, 0x0053, 0x013F); /* Vertical GRAM Start Address */\n\twrite_reg(par, 0x0060, 0xA700); /* Gate Scan Line */\n\twrite_reg(par, 0x0061, 0x0001); /* NDL,VLE, REV */\n\twrite_reg(par, 0x006A, 0x0000); /* set scrolling line */\n\n\t/*-------------- Partial Display Control --------- */\n\twrite_reg(par, 0x0080, 0x0000);\n\twrite_reg(par, 0x0081, 0x0000);\n\twrite_reg(par, 0x0082, 0x0000);\n\twrite_reg(par, 0x0083, 0x0000);\n\twrite_reg(par, 0x0084, 0x0000);\n\twrite_reg(par, 0x0085, 0x0000);\n\n\t/*-------------- Panel Control ------------------- */\n\twrite_reg(par, 0x0090, 0x0010);\n\twrite_reg(par, 0x0092, 0x0600);\n\twrite_reg(par, 0x0007, 0x0133); /* 262K color and display ON */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\tswitch (par->info->var.rotate) {\n\t/* R20h = Horizontal GRAM Start Address */\n\t/* R21h = Vertical GRAM Start Address */\n\tcase 0:\n\t\twrite_reg(par, 0x0020, xs);\n\t\twrite_reg(par, 0x0021, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - xs);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - ys);\n\t\twrite_reg(par, 0x0021, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0020, ys);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - xs);\n\t\tbreak;\n\t}\n\twrite_reg(par, 0x0022); /* Write Data to GRAM */\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\t/* AM: GRAM update direction */\n\tcase 0:\n\t\twrite_reg(par, 0x03, 0x0030 | (par->bgr << 12));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x03, 0x0000 | (par->bgr << 12));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x03, 0x0028 | (par->bgr << 12));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x03, 0x0018 | (par->bgr << 12));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  Gamma string format:\n    VRP0 VRP1 RP0 RP1 KP0 KP1 KP2 KP3 KP4 KP5\n    VRN0 VRN1 RN0 RN1 KN0 KN1 KN2 KN3 KN4 KN5\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long mask[] = {\n\t\t0b11111, 0b11111, 0b111, 0b111, 0b111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111,\n\t\t0b11111, 0b11111, 0b111, 0b111, 0b111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111 };\n\tint i, j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tCURVE(i, j) &= mask[i*par->gamma.num_values + j];\n\n\twrite_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));\n\twrite_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));\n\twrite_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));\n\twrite_reg(par, 0x0035, CURVE(0, 3) << 8 | CURVE(0, 2));\n\twrite_reg(par, 0x0036, CURVE(0, 1) << 8 | CURVE(0, 0));\n\n\twrite_reg(par, 0x0037, CURVE(1, 5) << 8 | CURVE(1, 4));\n\twrite_reg(par, 0x0038, CURVE(1, 7) << 8 | CURVE(1, 6));\n\twrite_reg(par, 0x0039, CURVE(1, 9) << 8 | CURVE(1, 8));\n\twrite_reg(par, 0x003C, CURVE(1, 3) << 8 | CURVE(1, 2));\n\twrite_reg(par, 0x003D, CURVE(1, 1) << 8 | CURVE(1, 0));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.bpp = BPP,\n\t.fps = FPS,\n\t.gamma_num = 2,\n\t.gamma_len = 10,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9325\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9325\");\nMODULE_ALIAS(\"platform:ili9325\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9325 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ili9340.c",
          "type": "blob",
          "size": 3.9267578125,
          "content": "/*\n * FB driver for the ILI9340 LCD Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ili9340\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n\n\n/* Init sequence taken from: Arduino Library for the Adafruit 2.2\" display */\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\twrite_reg(par, 0xEF, 0x03, 0x80, 0x02);\n\twrite_reg(par, 0xCF, 0x00 , 0XC1 , 0X30);\n\twrite_reg(par, 0xED, 0x64 , 0x03 , 0X12 , 0X81);\n\twrite_reg(par, 0xE8, 0x85 , 0x00 , 0x78);\n\twrite_reg(par, 0xCB, 0x39 , 0x2C , 0x00 , 0x34 , 0x02);\n\twrite_reg(par, 0xF7, 0x20);\n\twrite_reg(par, 0xEA, 0x00 , 0x00);\n\n\t/* Power Control 1 */\n\twrite_reg(par, 0xC0, 0x23);\n\n\t/* Power Control 2 */\n\twrite_reg(par, 0xC1, 0x10);\n\n\t/* VCOM Control 1 */\n\twrite_reg(par, 0xC5, 0x3e, 0x28);\n\n\t/* VCOM Control 2 */\n\twrite_reg(par, 0xC7, 0x86);\n\n\t/* COLMOD: Pixel Format Set */\n\t/* 16 bits/pixel */\n\twrite_reg(par, 0x3A, 0x55);\n\n\t/* Frame Rate Control */\n\t/* Division ratio = fosc, Frame Rate = 79Hz */\n\twrite_reg(par, 0xB1, 0x00, 0x18);\n\n\t/* Display Function Control */\n\twrite_reg(par, 0xB6, 0x08, 0x82, 0x27);\n\n\t/* Gamma Function Disable */\n\twrite_reg(par, 0xF2, 0x00);\n\n\t/* Gamma curve selected  */\n\twrite_reg(par, 0x26, 0x01);\n\n\t/* Positive Gamma Correction */\n\twrite_reg(par, 0xE0,\n\t\t0x0F, 0x31, 0x2B, 0x0C, 0x0E, 0x08, 0x4E, 0xF1,\n\t\t0x37, 0x07, 0x10, 0x03, 0x0E, 0x09, 0x00);\n\n\t/* Negative Gamma Correction */\n\twrite_reg(par, 0xE1,\n\t\t0x00, 0x0E, 0x14, 0x03, 0x11, 0x07, 0x31, 0xC1,\n\t\t0x48, 0x08, 0x0F, 0x0C, 0x31, 0x36, 0x0F);\n\n\t/* Sleep OUT */\n\twrite_reg(par, 0x11);\n\n\tmdelay(120);\n\n\t/* Display ON */\n\twrite_reg(par, 0x29);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address */\n\twrite_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);\n\n\t/* Row adress */\n\twrite_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\n#define ILI9340_MADCTL_MV  0x20\n#define ILI9340_MADCTL_MX  0x40\n#define ILI9340_MADCTL_MY  0x80\nstatic int set_var(struct fbtft_par *par)\n{\n\tu8 val;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\tcase 270:\n\t\tval = ILI9340_MADCTL_MV;\n\t\tbreak;\n\tcase 180:\n\t\tval = ILI9340_MADCTL_MY;\n\t\tbreak;\n\tcase 90:\n\t\tval = ILI9340_MADCTL_MV | ILI9340_MADCTL_MY | ILI9340_MADCTL_MX;\n\t\tbreak;\n\tdefault:\n\t\tval = ILI9340_MADCTL_MX;\n\t\tbreak;\n\t}\n\t/* Memory Access Control  */\n\twrite_reg(par, 0x36, val | (par->bgr << 3));\n\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9340\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9340\");\nMODULE_ALIAS(\"platform:ili9340\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9340 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ili9341.c",
          "type": "blob",
          "size": 5.30859375,
          "content": "/*\n * FB driver for the ILI9341 LCD display controller\n *\n * This display uses 9-bit SPI: Data/Command bit + 8 data bits\n * For platforms that doesn't support 9-bit, the driver is capable\n * of emulating this using 8-bit transfer.\n * This is done by transfering eight 9-bit words in 9 bytes.\n *\n * Copyright (C) 2013 Christian Vogelgsang\n * Based on adafruit22fb.c by Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ili9341\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define TXBUFLEN\t(4 * PAGE_SIZE)\n#define DEFAULT_GAMMA\t\"1F 1A 18 0A 0F 06 45 87 32 0A 07 02 07 05 00\\n\" \\\n\t\t\t\"00 25 27 05 10 09 3A 78 4D 05 18 0D 38 3A 1F\"\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\t/* startup sequence for MI0283QT-9A */\n\twrite_reg(par, 0x01); /* software reset */\n\tmdelay(5);\n\twrite_reg(par, 0x28); /* display off */\n\t/* --------------------------------------------------------- */\n\twrite_reg(par, 0xCF, 0x00, 0x83, 0x30);\n\twrite_reg(par, 0xED, 0x64, 0x03, 0x12, 0x81);\n\twrite_reg(par, 0xE8, 0x85, 0x01, 0x79);\n\twrite_reg(par, 0xCB, 0x39, 0X2C, 0x00, 0x34, 0x02);\n\twrite_reg(par, 0xF7, 0x20);\n\twrite_reg(par, 0xEA, 0x00, 0x00);\n\t/* ------------power control-------------------------------- */\n\twrite_reg(par, 0xC0, 0x26);\n\twrite_reg(par, 0xC1, 0x11);\n\t/* ------------VCOM --------- */\n\twrite_reg(par, 0xC5, 0x35, 0x3E);\n\twrite_reg(par, 0xC7, 0xBE);\n\t/* ------------memory access control------------------------ */\n\twrite_reg(par, 0x3A, 0x55); /* 16bit pixel */\n\t/* ------------frame rate----------------------------------- */\n\twrite_reg(par, 0xB1, 0x00, 0x1B);\n\t/* ------------Gamma---------------------------------------- */\n\t/* write_reg(par, 0xF2, 0x08); */ /* Gamma Function Disable */\n\twrite_reg(par, 0x26, 0x01);\n\t/* ------------display-------------------------------------- */\n\twrite_reg(par, 0xB7, 0x07); /* entry mode set */\n\twrite_reg(par, 0xB6, 0x0A, 0x82, 0x27, 0x00);\n\twrite_reg(par, 0x11); /* sleep out */\n\tmdelay(100);\n\twrite_reg(par, 0x29); /* display on */\n\tmdelay(20);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address set */\n\twrite_reg(par, 0x2A,\n\t\t(xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);\n\n\t/* Row adress set */\n\twrite_reg(par, 0x2B,\n\t\t(ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\n#define MEM_Y   (7) /* MY row address order */\n#define MEM_X   (6) /* MX column address order */\n#define MEM_V   (5) /* MV row / column exchange */\n#define MEM_L   (4) /* ML vertical refresh order */\n#define MEM_H   (2) /* MH horizontal refresh order */\n#define MEM_BGR (3) /* RGB-BGR Order */\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x36, (1 << MEM_X) | (par->bgr << MEM_BGR));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x36,\n\t\t\t(1<<MEM_V) | (1 << MEM_L) | (par->bgr << MEM_BGR));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, (1 << MEM_Y) | (par->bgr << MEM_BGR));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, (1 << MEM_Y) | (1 << MEM_X) |\n\t\t\t\t     (1 << MEM_V) | (par->bgr << MEM_BGR));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  Gamma string format:\n    Positive: Par1 Par2 [...] Par15\n    Negative: Par1 Par2 [...] Par15\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tint i;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tfor (i = 0; i < par->gamma.num_curves; i++)\n\t\twrite_reg(par, 0xE0 + i,\n\t\t\tCURVE(i, 0), CURVE(i, 1), CURVE(i, 2),\n\t\t\tCURVE(i, 3), CURVE(i, 4), CURVE(i, 5),\n\t\t\tCURVE(i, 6), CURVE(i, 7), CURVE(i, 8),\n\t\t\tCURVE(i, 9), CURVE(i, 10), CURVE(i, 11),\n\t\t\tCURVE(i, 12), CURVE(i, 13), CURVE(i, 14));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.txbuflen = TXBUFLEN,\n\t.gamma_num = 2,\n\t.gamma_len = 15,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9341\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9341\");\nMODULE_ALIAS(\"platform:ili9341\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9341 LCD display controller\");\nMODULE_AUTHOR(\"Christian Vogelgsang\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ili9481.c",
          "type": "blob",
          "size": 2.896484375,
          "content": "/*\n * FB driver for the ILI9481 LCD Controller\n *\n * Copyright (c) 2014 Petr Olivka\n * Copyright (c) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\"fb_ili9481\"\n#define WIDTH\t\t320\n#define HEIGHT\t\t480\n\nstatic int default_init_sequence[] = {\n\n\t/* SLP_OUT - Sleep out */\n\t-1, 0x11,\n\t-2, 50,\n\t/* Power setting */\n\t-1, 0xD0, 0x07, 0x42, 0x18,\n\t/* VCOM */\n\t-1, 0xD1, 0x00, 0x07, 0x10,\n\t/* Power setting for norm. mode */\n\t-1, 0xD2, 0x01, 0x02,\n\t/* Panel driving setting */\n\t-1, 0xC0, 0x10, 0x3B, 0x00, 0x02, 0x11,\n\t/* Frame rate & inv. */\n\t-1, 0xC5, 0x03,\n\t/* Pixel format */\n\t-1, 0x3A, 0x55,\n\t/* Gamma */\n\t-1, 0xC8, 0x00, 0x32, 0x36, 0x45, 0x06, 0x16,\n\t\t  0x37, 0x75, 0x77, 0x54, 0x0C, 0x00,\n\t/* DISP_ON */\n\t-1, 0x29,\n\t-3\n};\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* column address */\n\twrite_reg(par, 0x2a, xs >> 8, xs & 0xff, xe >> 8, xe & 0xff);\n\n\t/* row adress */\n\twrite_reg(par, 0x2b, ys >> 8, ys & 0xff, ye >> 8, ye & 0xff);\n\n\t/* memory write */\n\twrite_reg(par, 0x2c);\n}\n\n#define HFLIP 0x01\n#define VFLIP 0x02\n#define ROWxCOL 0x20\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\tcase 270:\n\t\twrite_reg(par, 0x36, ROWxCOL | HFLIP | VFLIP | (par->bgr << 3));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, VFLIP | (par->bgr << 3));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, ROWxCOL | (par->bgr << 3));\n\t\tbreak;\n\tdefault:\n\t\twrite_reg(par, 0x36, HFLIP | (par->bgr << 3));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.init_sequence = default_init_sequence,\n\t.fbtftops = {\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9481\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9481\");\nMODULE_ALIAS(\"platform:ili9481\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9481 LCD Controller\");\nMODULE_AUTHOR(\"Petr Olivka\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ili9486.c",
          "type": "blob",
          "size": 3.0927734375,
          "content": "/*\n * FB driver for the ILI9486 LCD Controller\n *\n * Copyright (C) 2014 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ili9486\"\n#define WIDTH\t\t320\n#define HEIGHT\t\t480\n\n\n/* this init sequence matches PiScreen */\nstatic int default_init_sequence[] = {\n\t/* Interface Mode Control */\n\t-1, 0xb0, 0x0,\n\t/* Sleep OUT */\n\t-1, 0x11,\n\t-2, 250,\n\t/* Interface Pixel Format */\n\t-1, 0x3A, 0x55,\n\t/* Power Control 3 */\n\t-1, 0xC2, 0x44,\n\t/* VCOM Control 1 */\n\t-1, 0xC5, 0x00, 0x00, 0x00, 0x00,\n\t/* PGAMCTRL(Positive Gamma Control) */\n\t-1, 0xE0, 0x0F, 0x1F, 0x1C, 0x0C, 0x0F, 0x08, 0x48, 0x98,\n\t          0x37, 0x0A, 0x13, 0x04, 0x11, 0x0D, 0x00,\n\t/* NGAMCTRL(Negative Gamma Control) */\n\t-1, 0xE1, 0x0F, 0x32, 0x2E, 0x0B, 0x0D, 0x05, 0x47, 0x75,\n\t          0x37, 0x06, 0x10, 0x03, 0x24, 0x20, 0x00,\n\t/* Digital Gamma Control 1 */\n\t-1, 0xE2, 0x0F, 0x32, 0x2E, 0x0B, 0x0D, 0x05, 0x47, 0x75,\n\t          0x37, 0x06, 0x10, 0x03, 0x24, 0x20, 0x00,\n\t/* Sleep OUT */\n\t-1, 0x11,\n\t/* Display ON */\n\t-1, 0x29,\n\t/* end marker */\n\t-3\n};\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address */\n\twrite_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);\n\n\t/* Row adress */\n\twrite_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x36, 0x80 | (par->bgr << 3));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, 0x20 | (par->bgr << 3));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, 0x40 | (par->bgr << 3));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x36, 0xE0 | (par->bgr << 3));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.init_sequence = default_init_sequence,\n\t.fbtftops = {\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9486\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9486\");\nMODULE_ALIAS(\"platform:ili9486\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9486 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_pcd8544.c",
          "type": "blob",
          "size": 4.693359375,
          "content": "/*\n * FB driver for the PCD8544 LCD Controller\n *\n * The display is monochrome and the video memory is RGB565.\n * Any pixel value except 0 turns the pixel on.\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t       \"fb_pcd8544\"\n#define WIDTH          84\n#define HEIGHT         48\n#define TXBUFLEN       84*6\n#define DEFAULT_GAMMA  \"40\" /* gamma is used to control contrast in this driver */\n\nstatic unsigned tc = 0;\nmodule_param(tc, uint, 0);\nMODULE_PARM_DESC(tc, \"TC[1:0] Temperature coefficient: 0-3 (default: 0)\");\n\nstatic unsigned bs = 4;\nmodule_param(bs, uint, 0);\nMODULE_PARM_DESC(bs, \"BS[2:0] Bias voltage level: 0-7 (default: 4)\");\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\t/* Function set */\n\twrite_reg(par, 0x21); /* 5:1  1\n\t                         2:0  PD - Powerdown control: chip is active\n\t\t\t\t\t\t\t 1:0  V  - Entry mode: horizontal addressing\n\t\t\t\t\t\t\t 0:1  H  - Extended instruction set control: extended\n\t\t\t\t\t\t  */\n\n\t/* H=1 Temperature control */\n\twrite_reg(par, 0x04 | (tc & 0x3)); /* \n\t                         2:1  1\n\t                         1:x  TC1 - Temperature Coefficient: 0x10\n\t\t\t\t\t\t\t 0:x  TC0\n\t\t\t\t\t\t  */\n\n\t/* H=1 Bias system */\n\twrite_reg(par, 0x10 | (bs & 0x7)); /* \n\t                         4:1  1\n\t                         3:0  0\n\t\t\t\t\t\t\t 2:x  BS2 - Bias System\n\t\t\t\t\t\t\t 1:x  BS1\n\t\t\t\t\t\t\t 0:x  BS0\n\t                      */\n\n\t/* Function set */\n\twrite_reg(par, 0x22); /* 5:1  1\n\t                         2:0  PD - Powerdown control: chip is active\n\t\t\t\t\t\t\t 1:1  V  - Entry mode: vertical addressing\n\t\t\t\t\t\t\t 0:0  H  - Extended instruction set control: basic\n\t\t\t\t\t\t  */\n\n\t/* H=0 Display control */\n\twrite_reg(par, 0x08 | 4); /* \n\t                         3:1  1\n\t                         2:1  D  - DE: 10=normal mode\n\t\t\t\t\t\t\t 1:0  0\n\t\t\t\t\t\t\t 0:0  E\n\t\t\t\t\t\t  */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, \"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* H=0 Set X address of RAM */\n\twrite_reg(par, 0x80); /* 7:1  1\n\t                         6-0: X[6:0] - 0x00\n\t                      */\n\n\t/* H=0 Set Y address of RAM */\n\twrite_reg(par, 0x40); /* 7:0  0\n\t                         6:1  1\n\t                         2-0: Y[2:0] - 0x0\n\t                      */\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_base;\n\tu8 *buf = par->txbuf.buf;\n\tint x, y, i;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\tfor (x=0;x<84;x++) {\n\t\tfor (y=0;y<6;y++) {\n\t\t\t*buf = 0x00;\n\t\t\tfor (i=0;i<8;i++) {\n\t\t\t\t*buf |= (vmem16[(y*8+i)*84+x] ? 1 : 0) << i;\n\t\t\t}\n\t\t\tbuf++;\n\t\t}\n\t}\n\n\t/* Write data */\n\tgpio_set_value(par->gpio.dc, 1);\n\tret = par->fbtftops.write(par, par->txbuf.buf, 6*84);\n\tif (ret < 0)\n\t\tdev_err(par->info->device, \"%s: write failed and returned: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tcurves[0] &= 0x7F;\n\n\twrite_reg(par, 0x23); /* turn on extended instruction set */\n\twrite_reg(par, 0x80 | curves[0]);\n\twrite_reg(par, 0x22); /* turn off extended instruction set */\n\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.txbuflen = TXBUFLEN,\n\t.gamma_num = 1,\n\t.gamma_len = 1,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.write_vmem = write_vmem,\n\t\t.set_gamma = set_gamma,\n\t},\n\t.backlight = 1,\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"philips,pdc8544\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"spi:pdc8544\");\n\nMODULE_DESCRIPTION(\"FB driver for the PCD8544 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ra8875.c",
          "type": "blob",
          "size": 9.0263671875,
          "content": "/******************************************************************************\n\n  ProjectName: FBTFT driver                       ***** *****\n\t       for the RA8875 LCD Controller     *     *      ************\n\t\t\t\t\t\t*   **   **   *           *\n  Copyright © by Pf@nne & NOTRO                *   *   *   *   *   ****\t   *\n\t\t\t\t\t\t*   *       *   *   *   *   *\n  Last modification by:                        *   *       *   *   ****    *\n  - Pf@nne (pf@nne-mail.de)                     *   *     *****           *\n\t\t\t\t\t\t *   *        *   *******\n\t\t\t\t\t\t  *****      *   *\n  Date    : 10.06.2014                                      *   *\n  Version : V1.13                                          *****\n  Revison : 5\n\n*******************************************************************************\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include <linux/gpio.h>\n#include \"fbtft.h\"\n\n#define DRVNAME \"fb_ra8875\"\n\nstatic int write_spi(struct fbtft_par *par, void *buf, size_t len)\n{\n\tstruct spi_transfer t = {\n\t\t.tx_buf = buf,\n\t\t.len = len,\n\t\t.speed_hz = 1000000,\n\t};\n\tstruct spi_message m;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\tif (!par->spi) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: par->spi is unexpectedly NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tspi_message_init(&m);\n\tif (par->txbuf.dma && buf == par->txbuf.buf) {\n\t\tt.tx_dma = par->txbuf.dma;\n\t\tm.is_dma_mapped = 1;\n\t}\n\tspi_message_add_tail(&t, &m);\n\treturn spi_sync(par->spi, &m);\n}\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tgpio_set_value(par->gpio.dc, 1);\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\"%s()\\n\", __func__);\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\"display size %dx%d\\n\", par->info->var.xres, par->info->var.yres);\n\n\tpar->fbtftops.reset(par);\n\n\tif ((par->info->var.xres == 320) && (par->info->var.yres == 240)) {\n\t\t/* PLL clock frequency */\n\t\twrite_reg(par, 0x88 , 0x0A);\n\t\twrite_reg(par, 0x89 , 0x02);\n\t\tmdelay(10);\n\t\t/* color deep / MCU Interface */\n\t\twrite_reg(par, 0x10 , 0x0C);\n\t\t/* pixel clock period  */\n\t\twrite_reg(par, 0x04 , 0x03);\n\t\tmdelay(1);\n\t\t/* horizontal settings */\n\t\twrite_reg(par, 0x14 , 0x27);\n\t\twrite_reg(par, 0x15 , 0x00);\n\t\twrite_reg(par, 0x16 , 0x05);\n\t\twrite_reg(par, 0x17 , 0x04);\n\t\twrite_reg(par, 0x18 , 0x03);\n\t\t/* vertical settings */\n\t\twrite_reg(par, 0x19 , 0xEF);\n\t\twrite_reg(par, 0x1A , 0x00);\n\t\twrite_reg(par, 0x1B , 0x05);\n\t\twrite_reg(par, 0x1C , 0x00);\n\t\twrite_reg(par, 0x1D , 0x0E);\n\t\twrite_reg(par, 0x1E , 0x00);\n\t\twrite_reg(par, 0x1F , 0x02);\n\t} else if ((par->info->var.xres == 480) && (par->info->var.yres == 272)) {\n\t\t/* PLL clock frequency  */\n\t\twrite_reg(par, 0x88 , 0x0A);\n\t\twrite_reg(par, 0x89 , 0x02);\n\t\tmdelay(10);\n\t\t/* color deep / MCU Interface */\n\t\twrite_reg(par, 0x10 , 0x0C);\n\t\t/* pixel clock period  */\n\t\twrite_reg(par, 0x04 , 0x82);\n\t\tmdelay(1);\n\t\t/* horizontal settings */\n\t\twrite_reg(par, 0x14 , 0x3B);\n\t\twrite_reg(par, 0x15 , 0x00);\n\t\twrite_reg(par, 0x16 , 0x01);\n\t\twrite_reg(par, 0x17 , 0x00);\n\t\twrite_reg(par, 0x18 , 0x05);\n\t\t/* vertical settings */\n\t\twrite_reg(par, 0x19 , 0x0F);\n\t\twrite_reg(par, 0x1A , 0x01);\n\t\twrite_reg(par, 0x1B , 0x02);\n\t\twrite_reg(par, 0x1C , 0x00);\n\t\twrite_reg(par, 0x1D , 0x07);\n\t\twrite_reg(par, 0x1E , 0x00);\n\t\twrite_reg(par, 0x1F , 0x09);\n\t} else if ((par->info->var.xres == 640) && (par->info->var.yres == 480)) {\n\t\t/* PLL clock frequency */\n\t\twrite_reg(par, 0x88 , 0x0B);\n\t\twrite_reg(par, 0x89 , 0x02);\n\t\tmdelay(10);\n\t\t/* color deep / MCU Interface */\n\t\twrite_reg(par, 0x10 , 0x0C);\n\t\t/* pixel clock period */\n\t\twrite_reg(par, 0x04 , 0x01);\n\t\tmdelay(1);\n\t\t/* horizontal settings */\n\t\twrite_reg(par, 0x14 , 0x4F);\n\t\twrite_reg(par, 0x15 , 0x05);\n\t\twrite_reg(par, 0x16 , 0x0F);\n\t\twrite_reg(par, 0x17 , 0x01);\n\t\twrite_reg(par, 0x18 , 0x00);\n\t\t/* vertical settings */\n\t\twrite_reg(par, 0x19 , 0xDF);\n\t\twrite_reg(par, 0x1A , 0x01);\n\t\twrite_reg(par, 0x1B , 0x0A);\n\t\twrite_reg(par, 0x1C , 0x00);\n\t\twrite_reg(par, 0x1D , 0x0E);\n\t\twrite_reg(par, 0x1E , 0x00);\n\t\twrite_reg(par, 0x1F , 0x01);\n\t} else if ((par->info->var.xres == 800) && (par->info->var.yres == 480)) {\n\t\t/* PLL clock frequency */\n\t\twrite_reg(par, 0x88 , 0x0B);\n\t\twrite_reg(par, 0x89 , 0x02);\n\t\tmdelay(10);\n\t\t/* color deep / MCU Interface */\n\t\twrite_reg(par, 0x10 , 0x0C);\n\t\t/* pixel clock period */\n\t\twrite_reg(par, 0x04 , 0x81);\n\t\tmdelay(1);\n\t\t/* horizontal settings */\n\t\twrite_reg(par, 0x14 , 0x63);\n\t\twrite_reg(par, 0x15 , 0x03);\n\t\twrite_reg(par, 0x16 , 0x03);\n\t\twrite_reg(par, 0x17 , 0x02);\n\t\twrite_reg(par, 0x18 , 0x00);\n\t\t/* vertical settings */\n\t\twrite_reg(par, 0x19 , 0xDF);\n\t\twrite_reg(par, 0x1A , 0x01);\n\t\twrite_reg(par, 0x1B , 0x14);\n\t\twrite_reg(par, 0x1C , 0x00);\n\t\twrite_reg(par, 0x1D , 0x06);\n\t\twrite_reg(par, 0x1E , 0x00);\n\t\twrite_reg(par, 0x1F , 0x01);\n\t} else {\n\t\tdev_err(par->info->device, \"display size is not supported!!\");\n\t\treturn -1;\n\t}\n\n\t/* PWM clock */\n\twrite_reg(par, 0x8a , 0x81);\n\twrite_reg(par, 0x8b , 0xFF);\n\tmdelay(10);\n\n\t/* Display ON */\n\twrite_reg(par, 0x01 , 0x80);\n\tmdelay(10);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Set_Active_Window */\n\twrite_reg(par, 0x30 , xs & 0x00FF);\n\twrite_reg(par, 0x31 , (xs & 0xFF00) >> 8);\n\twrite_reg(par, 0x32 , ys & 0x00FF);\n\twrite_reg(par, 0x33 , (ys & 0xFF00) >> 8);\n\twrite_reg(par, 0x34 , (xs+xe) & 0x00FF);\n\twrite_reg(par, 0x35 , ((xs+xe) & 0xFF00) >> 8);\n\twrite_reg(par, 0x36 , (ys+ye) & 0x00FF);\n\twrite_reg(par, 0x37 , ((ys+ye) & 0xFF00) >> 8);\n\n\t/* Set_Memory_Write_Cursor */\n\twrite_reg(par, 0x46,  xs & 0xff);\n\twrite_reg(par, 0x47, (xs >> 8) & 0x03);\n\twrite_reg(par, 0x48,  ys & 0xff);\n\twrite_reg(par, 0x49, (ys >> 8) & 0x01);\n\n\twrite_reg(par, 0x02);\n}\n\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = (u8 *)par->buf;\n\n\t/* slow down spi-speed for writing registers */\n\tpar->fbtftops.write = write_spi;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = (u8)va_arg(args, unsigned int);\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device,\n\t\t\tu8, buf, len, \"%s: \", __func__);\n\t}\n\n\tva_start(args, len);\n\t*buf++ = 0x80;\n\t*buf = (u8)va_arg(args, unsigned int);\n\tret = par->fbtftops.write(par, par->buf, 2);\n\tif (ret < 0) {\n\t\tva_end(args);\n\t\tdev_err(par->info->device, \"%s: write() failed and returned %dn\",\n\t\t\t__func__, ret);\n\t\treturn;\n\t}\n\tlen--;\n\n\tudelay(100);\n\n\tif (len) {\n\t\tbuf = (u8 *)par->buf;\n\t\t*buf++ = 0x00;\n\t\ti = len;\n\t\twhile (i--)\n\t\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\n\t\tret = par->fbtftops.write(par, par->buf, len + 1);\n\t\tif (ret < 0) {\n\t\t\tva_end(args);\n\t\t\tdev_err(par->info->device, \"%s: write() failed and returned %dn\",\n\t\t\t\t__func__, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\tva_end(args);\n\n\t/* restore user spi-speed */\n\tpar->fbtftops.write = fbtft_write_spi;\n\tudelay(100);\n}\n\nstatic int write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16;\n\tu16 *txbuf16 = (u16 *)par->txbuf.buf;\n\tsize_t remain;\n\tsize_t to_copy;\n\tsize_t tx_array_size;\n\tint i;\n\tint ret = 0;\n\tsize_t startbyte_size = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t__func__, offset, len);\n\n\tremain = len / 2;\n\tvmem16 = (u16 *)(par->info->screen_base + offset);\n\ttx_array_size = par->txbuf.len / 2;\n\t\ttxbuf16 = (u16 *)(par->txbuf.buf + 1);\n\t\ttx_array_size -= 2;\n\t\t*(u8 *)(par->txbuf.buf) = 0x00;\n\t\tstartbyte_size = 1;\n\n\twhile (remain) {\n\t\tto_copy = remain > tx_array_size ? tx_array_size : remain;\n\t\tdev_dbg(par->info->device, \"    to_copy=%zu, remain=%zu\\n\",\n\t\t\tto_copy, remain - to_copy);\n\n\t\tfor (i = 0; i < to_copy; i++)\n\t\t\ttxbuf16[i] = cpu_to_be16(vmem16[i]);\n\n\t\tvmem16 = vmem16 + to_copy;\n\t\tret = par->fbtftops.write(par, par->txbuf.buf,\n\t\t\tstartbyte_size + to_copy * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tremain -= to_copy;\n\t}\n\n\treturn ret;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.write_register = write_reg8_bus8,\n\t\t.write_vmem = write_vmem16_bus8,\n\t\t.write = write_spi,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"raio,ra8875\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ra8875\");\nMODULE_ALIAS(\"platform:ra8875\");\n\nMODULE_DESCRIPTION(\"FB driver for the RA8875 LCD Controller\");\nMODULE_AUTHOR(\"Pf@nne\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_s6d02a1.c",
          "type": "blob",
          "size": 4.15234375,
          "content": "/*\n * FB driver for the S6D02A1 LCD Controller\n *\n * Based on fb_st7735r.c by Noralf Tronnes\n * Init code from UTFT library by Henning Karlsen\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME \"fb_s6d02a1\"\n\nstatic int default_init_sequence[] = {\n\n\t-1, 0xf0, 0x5a, 0x5a,\n\n\t-1, 0xfc, 0x5a, 0x5a,\n\n\t-1, 0xfa, 0x02, 0x1f, 0x00, 0x10, 0x22, 0x30, 0x38, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3d, 0x02, 0x01,\n\n\t-1, 0xfb, 0x21, 0x00, 0x02, 0x04, 0x07, 0x0a, 0x0b, 0x0c, 0x0c, 0x16, 0x1e, 0x30, 0x3f, 0x01, 0x02,\n\n\t/* power setting sequence */\n\t-1, 0xfd, 0x00, 0x00, 0x00, 0x17, 0x10, 0x00, 0x01, 0x01, 0x00, 0x1f, 0x1f,\n\n\t-1, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x07, 0x00, 0x3C, 0x36, 0x00, 0x3C, 0x36, 0x00,\n\n\t-1, 0xf5, 0x00, 0x70, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x66, 0x06,\n\n\t-1, 0xf6, 0x02, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x06, 0x01, 0x00,\n\n\t-1, 0xf2, 0x00, 0x01, 0x03, 0x08, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x08, 0x08,\n\n\t-1, 0xf8, 0x11,\n\n\t-1, 0xf7, 0xc8, 0x20, 0x00, 0x00,\n\n\t-1, 0xf3, 0x00, 0x00,\n\n\t-1, 0x11,\n\t-2, 50,\n\n\t-1, 0xf3, 0x00, 0x01,\n\t-2, 50,\n\t-1, 0xf3, 0x00, 0x03,\n\t-2, 50,\n\t-1, 0xf3, 0x00, 0x07,\n\t-2, 50,\n\t-1, 0xf3, 0x00, 0x0f,\n\t-2, 50,\n\n\t-1, 0xf4, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x07, 0x00, 0x3C, 0x36, 0x00, 0x3C, 0x36, 0x00,\n\t-2, 50,\n\n\t-1, 0xf3, 0x00, 0x1f,\n\t-2, 50,\n\t-1, 0xf3, 0x00, 0x7f,\n\t-2, 50,\n\n\t-1, 0xf3, 0x00, 0xff,\n\t-2, 50,\n\n\t-1, 0xfd, 0x00, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x01, 0x00, 0x16, 0x16,\n\n\t-1, 0xf4, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x07, 0x00, 0x3C, 0x36, 0x00, 0x3C, 0x36, 0x00,\n\n\t/* initializing sequence */\n\n\t-1, 0x36, 0x08,\n\n\t-1, 0x35, 0x00,\n\n\t-1, 0x3a, 0x05,\n\n\t/* gamma setting sequence */\n\t-1, 0x26, 0x01,\t/* preset gamma curves, possible values 0x01, 0x02, 0x04, 0x08 */\n\n\t-2, 150,\n\t-1, 0x29,\n\t-1, 0x2c,\n\t/* end marker */\n\t-3\n\n};\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address */\n\twrite_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);\n\n\t/* Row adress */\n\twrite_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\n#define MY (1 << 7)\n#define MX (1 << 6)\n#define MV (1 << 5)\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* MADCTL - Memory data access control\n\t     RGB/BGR:\n\t\t1. Mode selection pin SRGB\n\t\t\tRGB H/W pin for color filter setting: 0=RGB, 1=BGR\n\t\t2. MADCTL RGB bit\n\t\t\tRGB-BGR ORDER color filter panel: 0=RGB, 1=BGR */\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x36, MX | MY | (par->bgr << 3));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x36, MY | MV | (par->bgr << 3));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, (par->bgr << 3));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, MX | MV | (par->bgr << 3));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = 128,\n\t.height = 160,\n\t.init_sequence = default_init_sequence,\n\t.fbtftops = {\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"samsung,s6d02a1\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:s6d02a1\");\nMODULE_ALIAS(\"platform:s6d02a1\");\n\nMODULE_DESCRIPTION(\"FB driver for the S6D02A1 LCD Controller\");\nMODULE_AUTHOR(\"WOLFGANG BUENING\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_s6d1121.c",
          "type": "blob",
          "size": 5.93359375,
          "content": "/*\n * FB driver for the S6D1121 LCD Controller\n *\n * Copyright (C) 2013 Roman Rolinsky\n *\n * Based on fb_ili9325.c by Noralf Tronnes\n * Based on ili9325.c by Jeroen Domburg\n * Init code from UTFT library by Henning Karlsen\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_s6d1121\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define BPP\t\t16\n#define FPS\t\t20\n#define DEFAULT_GAMMA\t\"26 09 24 2C 1F 23 24 25 22 26 25 23 0D 00\\n\" \\\n\t\t\t\"1C 1A 13 1D 0B 11 12 10 13 15 36 19 00 0D\"\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tif (par->gpio.cs != -1)\n\t\tgpio_set_value(par->gpio.cs, 0);  /* Activate chip */\n\n\t/* Initialization sequence from Lib_UTFT */\n\n\twrite_reg(par, 0x0011, 0x2004);\n\twrite_reg(par, 0x0013, 0xCC00);\n\twrite_reg(par, 0x0015, 0x2600);\n\twrite_reg(par, 0x0014, 0x252A);\n\twrite_reg(par, 0x0012, 0x0033);\n\twrite_reg(par, 0x0013, 0xCC04);\n\twrite_reg(par, 0x0013, 0xCC06);\n\twrite_reg(par, 0x0013, 0xCC4F);\n\twrite_reg(par, 0x0013, 0x674F);\n\twrite_reg(par, 0x0011, 0x2003);\n\twrite_reg(par, 0x0016, 0x0007);\n\twrite_reg(par, 0x0002, 0x0013);\n\twrite_reg(par, 0x0003, 0x0003);\n\twrite_reg(par, 0x0001, 0x0127);\n\twrite_reg(par, 0x0008, 0x0303);\n\twrite_reg(par, 0x000A, 0x000B);\n\twrite_reg(par, 0x000B, 0x0003);\n\twrite_reg(par, 0x000C, 0x0000);\n\twrite_reg(par, 0x0041, 0x0000);\n\twrite_reg(par, 0x0050, 0x0000);\n\twrite_reg(par, 0x0060, 0x0005);\n\twrite_reg(par, 0x0070, 0x000B);\n\twrite_reg(par, 0x0071, 0x0000);\n\twrite_reg(par, 0x0078, 0x0000);\n\twrite_reg(par, 0x007A, 0x0000);\n\twrite_reg(par, 0x0079, 0x0007);\n\twrite_reg(par, 0x0007, 0x0051);\n\twrite_reg(par, 0x0007, 0x0053);\n\twrite_reg(par, 0x0079, 0x0000);\n\n\twrite_reg(par, 0x0022); /* Write Data to GRAM */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\tswitch (par->info->var.rotate) {\n\t/* R20h = Horizontal GRAM Start Address */\n\t/* R21h = Vertical GRAM Start Address */\n\tcase 0:\n\t\twrite_reg(par, 0x0020, xs);\n\t\twrite_reg(par, 0x0021, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - xs);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - ys);\n\t\twrite_reg(par, 0x0021, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0020, ys);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - xs);\n\t\tbreak;\n\t}\n\twrite_reg(par, 0x0022); /* Write Data to GRAM */\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\t/* AM: GRAM update direction */\n\tcase 0:\n\t\twrite_reg(par, 0x03, 0x0003 | (par->bgr << 12));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x03, 0x0000 | (par->bgr << 12));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x03, 0x000A | (par->bgr << 12));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x03, 0x0009 | (par->bgr << 12));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  Gamma string format:\n    PKP0 PKP1 PKP2 PKP3 PKP4 PKP5 PKP6 PKP7 PKP8 PKP9 PKP10 PKP11 VRP0 VRP1\n    PKN0 PKN1 PKN2 PKN3 PKN4 PKN5 PKN6 PKN7 PRN8 PRN9 PRN10 PRN11 VRN0 VRN1\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long mask[] = {\n\t\t0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111, \n\t\t0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,\n\t\t0b11111, 0b11111,\n\t\t0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,\n\t\t0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,\n\t\t0b11111, 0b11111 };\n\tint i, j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 14; j++)\n\t\t\tCURVE(i, j) &= mask[i*par->gamma.num_values + j];\n\n\twrite_reg(par, 0x0030, CURVE(0, 1) << 8 | CURVE(0, 0));\n\twrite_reg(par, 0x0031, CURVE(0, 3) << 8 | CURVE(0, 2));\n\twrite_reg(par, 0x0032, CURVE(0, 5) << 8 | CURVE(0, 3));\n\twrite_reg(par, 0x0033, CURVE(0, 7) << 8 | CURVE(0, 6));\n\twrite_reg(par, 0x0034, CURVE(0, 9) << 8 | CURVE(0, 8));\n\twrite_reg(par, 0x0035, CURVE(0, 11) << 8 | CURVE(0, 10));\n\n\twrite_reg(par, 0x0036, CURVE(1, 1) << 8 | CURVE(1, 0));\n\twrite_reg(par, 0x0037, CURVE(1, 3) << 8 | CURVE(1, 2));\n\twrite_reg(par, 0x0038, CURVE(1, 5) << 8 | CURVE(1, 4));\n\twrite_reg(par, 0x0039, CURVE(1, 7) << 8 | CURVE(1, 6));\n\twrite_reg(par, 0x003A, CURVE(1, 9) << 8 | CURVE(1, 8));\n\twrite_reg(par, 0x003B, CURVE(1, 11) << 8 | CURVE(1, 10));\n\n\twrite_reg(par, 0x003C, CURVE(0, 13) << 8 | CURVE(0, 12));\n\twrite_reg(par, 0x003D, CURVE(1, 13) << 8 | CURVE(1, 12));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.bpp = BPP,\n\t.fps = FPS,\n\t.gamma_num = 2,\n\t.gamma_len = 14,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"samsung,s6d1121\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:s6d1121\");\nMODULE_ALIAS(\"platform:s6d1121\");\n\nMODULE_DESCRIPTION(\"FB driver for the S6D1121 LCD Controller\");\nMODULE_AUTHOR(\"Roman Rolinsky\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ssd1289.c",
          "type": "blob",
          "size": 5.6025390625,
          "content": "/*\n * FB driver for the SSD1289 LCD Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * Init sequence taken from ITDB02_Graph16.cpp - (C)2010-2011 Henning Karlsen\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ssd1289\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define DEFAULT_GAMMA\t\"02 03 2 5 7 7 4 2 4 2\\n\" \\\n\t\t\t\"02 03 2 5 7 5 4 2 4 2\"\n\nstatic unsigned reg11 = 0x6040;\nmodule_param(reg11, uint, 0);\nMODULE_PARM_DESC(reg11, \"Register 11h value\");\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tif (par->gpio.cs != -1)\n\t\tgpio_set_value(par->gpio.cs, 0);  /* Activate chip */\n\n\twrite_reg(par, 0x00, 0x0001);\n\twrite_reg(par, 0x03, 0xA8A4);\n\twrite_reg(par, 0x0C, 0x0000);\n\twrite_reg(par, 0x0D, 0x080C);\n\twrite_reg(par, 0x0E, 0x2B00);\n\twrite_reg(par, 0x1E, 0x00B7);\n\twrite_reg(par, 0x01,\n\t\t(1 << 13) | (par->bgr << 11) | (1 << 9) | (HEIGHT - 1));\n\twrite_reg(par, 0x02, 0x0600);\n\twrite_reg(par, 0x10, 0x0000);\n\twrite_reg(par, 0x05, 0x0000);\n\twrite_reg(par, 0x06, 0x0000);\n\twrite_reg(par, 0x16, 0xEF1C);\n\twrite_reg(par, 0x17, 0x0003);\n\twrite_reg(par, 0x07, 0x0233);\n\twrite_reg(par, 0x0B, 0x0000);\n\twrite_reg(par, 0x0F, 0x0000);\n\twrite_reg(par, 0x41, 0x0000);\n\twrite_reg(par, 0x42, 0x0000);\n\twrite_reg(par, 0x48, 0x0000);\n\twrite_reg(par, 0x49, 0x013F);\n\twrite_reg(par, 0x4A, 0x0000);\n\twrite_reg(par, 0x4B, 0x0000);\n\twrite_reg(par, 0x44, 0xEF00);\n\twrite_reg(par, 0x45, 0x0000);\n\twrite_reg(par, 0x46, 0x013F);\n\twrite_reg(par, 0x23, 0x0000);\n\twrite_reg(par, 0x24, 0x0000);\n\twrite_reg(par, 0x25, 0x8000);\n\twrite_reg(par, 0x4f, 0x0000);\n\twrite_reg(par, 0x4e, 0x0000);\n\twrite_reg(par, 0x22);\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\tswitch (par->info->var.rotate) {\n\t/* R4Eh - Set GDDRAM X address counter */\n\t/* R4Fh - Set GDDRAM Y address counter */\n\tcase 0:\n\t\twrite_reg(par, 0x4e, xs);\n\t\twrite_reg(par, 0x4f, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x4e, par->info->var.xres - 1 - xs);\n\t\twrite_reg(par, 0x4f, par->info->var.yres - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x4e, par->info->var.yres - 1 - ys);\n\t\twrite_reg(par, 0x4f, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x4e, ys);\n\t\twrite_reg(par, 0x4f, par->info->var.xres - 1 - xs);\n\t\tbreak;\n\t}\n\n\t/* R22h - RAM data write */\n\twrite_reg(par, 0x22);\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tif (par->fbtftops.init_display != init_display) {\n\t\t/* don't risk messing up register 11h */\n\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\"%s: skipping since custom init_display() is used\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x11, reg11 | 0b110000);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x11, reg11 | 0b101000);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x11, reg11 | 0b000000);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x11, reg11 | 0b011000);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  Gamma string format:\n    VRP0 VRP1 PRP0 PRP1 PKP0 PKP1 PKP2 PKP3 PKP4 PKP5\n    VRN0 VRN1 PRN0 PRN1 PKN0 PKN1 PKN2 PKN3 PKN4 PKN5\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long mask[] = {\n\t\t0b11111, 0b11111, 0b111, 0b111, 0b111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111,\n\t\t0b11111, 0b11111, 0b111, 0b111, 0b111,\n\t\t0b111, 0b111, 0b111, 0b111, 0b111 };\n\tint i, j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tCURVE(i, j) &= mask[i*par->gamma.num_values + j];\n\n\twrite_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));\n\twrite_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));\n\twrite_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));\n\twrite_reg(par, 0x0033, CURVE(0, 3) << 8 | CURVE(0, 2));\n\twrite_reg(par, 0x0034, CURVE(1, 5) << 8 | CURVE(1, 4));\n\twrite_reg(par, 0x0035, CURVE(1, 7) << 8 | CURVE(1, 6));\n\twrite_reg(par, 0x0036, CURVE(1, 9) << 8 | CURVE(1, 8));\n\twrite_reg(par, 0x0037, CURVE(1, 3) << 8 | CURVE(1, 2));\n\twrite_reg(par, 0x003A, CURVE(0, 1) << 8 | CURVE(0, 0));\n\twrite_reg(par, 0x003B, CURVE(1, 1) << 8 | CURVE(1, 0));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = 2,\n\t.gamma_len = 10,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"solomon,ssd1289\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ssd1289\");\nMODULE_ALIAS(\"platform:ssd1289\");\n\nMODULE_DESCRIPTION(\"FB driver for the SSD1289 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ssd1306.c",
          "type": "blob",
          "size": 5.42578125,
          "content": "/*\n * FB driver for the SSD1306 OLED Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ssd1306\"\n#define WIDTH\t\t128\n#define HEIGHT\t\t64\n\n\n/*\n  write_reg() caveat:\n\n     This doesn't work because D/C has to be LOW for both values:\n       write_reg(par, val1, val2);\n\n     Do it like this:\n       write_reg(par, val1);\n       write_reg(par, val2);\n*/\n\n/* Init sequence taken from the Adafruit SSD1306 Arduino library */\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tif (par->gamma.curves[0] == 0) {\n\t\tmutex_lock(&par->gamma.lock);\n\t\tif (par->info->var.yres == 64)\n\t\t\tpar->gamma.curves[0] = 0xCF;\n\t\telse\n\t\t\tpar->gamma.curves[0] = 0x8F;\n\t\tmutex_unlock(&par->gamma.lock);\n\t}\n\n\t/* Set Display OFF */\n\twrite_reg(par, 0xAE);\n\n\t/* Set Display Clock Divide Ratio/ Oscillator Frequency */\n\twrite_reg(par, 0xD5);\n\twrite_reg(par, 0x80);\n\n\t/* Set Multiplex Ratio */\n\twrite_reg(par, 0xA8);\n\tif (par->info->var.yres == 64)\n\t\twrite_reg(par, 0x3F);\n\telse\n\t\twrite_reg(par, 0x1F);\n\n\t/* Set Display Offset */\n\twrite_reg(par, 0xD3);\n\twrite_reg(par, 0x0);\n\n\t/* Set Display Start Line */\n\twrite_reg(par, 0x40 | 0x0);\n\n\t/* Charge Pump Setting */\n\twrite_reg(par, 0x8D);\n\t/* A[2] = 1b, Enable charge pump during display on */\n\twrite_reg(par, 0x14);\n\n\t/* Set Memory Addressing Mode */\n\twrite_reg(par, 0x20);\n\t/* Vertical addressing mode  */\n\twrite_reg(par, 0x01);\n\n\t/*Set Segment Re-map */\n\t/* column address 127 is mapped to SEG0 */\n\twrite_reg(par, 0xA0 | 0x1);\n\n\t/* Set COM Output Scan Direction */\n\t/* remapped mode. Scan from COM[N-1] to COM0 */\n\twrite_reg(par, 0xC8);\n\n\t/* Set COM Pins Hardware Configuration */\n\twrite_reg(par, 0xDA);\n\tif (par->info->var.yres == 64)\n\t\t/* A[4]=1b, Alternative COM pin configuration */\n\t\twrite_reg(par, 0x12);\n\telse\n\t\t/* A[4]=0b, Sequential COM pin configuration */\n\t\twrite_reg(par, 0x02);\n\n\t/* Set Pre-charge Period */\n\twrite_reg(par, 0xD9);\n\twrite_reg(par, 0xF1);\n\n\t/* Set VCOMH Deselect Level */\n\twrite_reg(par, 0xDB);\n\t/* according to the datasheet, this value is out of bounds */\n\twrite_reg(par, 0x40);\n\n\t/* Entire Display ON */\n\t/* Resume to RAM content display. Output follows RAM content */\n\twrite_reg(par, 0xA4);\n\n\t/* Set Normal Display\n\t   0 in RAM: OFF in display panel\n\t   1 in RAM: ON in display panel */\n\twrite_reg(par, 0xA6);\n\n\t/* Set Display ON */\n\twrite_reg(par, 0xAF);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Set Lower Column Start Address for Page Addressing Mode */\n\twrite_reg(par, 0x00 | 0x0);\n\t/* Set Higher Column Start Address for Page Addressing Mode */\n\twrite_reg(par, 0x10 | 0x0);\n\t/* Set Display Start Line */\n\twrite_reg(par, 0x40 | 0x0);\n}\n\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tfbtft_par_dbg(DEBUG_BLANK, par, \"%s(blank=%s)\\n\",\n\t\t__func__, on ? \"true\" : \"false\");\n\n\tif (on)\n\t\twrite_reg(par, 0xAE);\n\telse\n\t\twrite_reg(par, 0xAF);\n\treturn 0;\n}\n\n/* Gamma is used to control Contrast */\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tcurves[0] &= 0xFF;\n\n\t/* Set Contrast Control for BANK0 */\n\twrite_reg(par, 0x81);\n\twrite_reg(par, curves[0]);\n\n\treturn 0;\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_base;\n\tu8 *buf = par->txbuf.buf;\n\tint x, y, i;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\tfor (x = 0; x < par->info->var.xres; x++) {\n\t\tfor (y = 0; y < par->info->var.yres/8; y++) {\n\t\t\t*buf = 0x00;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t*buf |= (vmem16[(y*8+i)*par->info->var.xres+x] ? 1 : 0) << i;\n\t\t\tbuf++;\n\t\t}\n\t}\n\n\t/* Write data */\n\tgpio_set_value(par->gpio.dc, 1);\n\tret = par->fbtftops.write(par, par->txbuf.buf,\n\t\t\t\tpar->info->var.xres*par->info->var.yres/8);\n\tif (ret < 0)\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: write failed and returned: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = 1,\n\t.gamma_len = 1,\n\t.gamma = \"00\",\n\t.fbtftops = {\n\t\t.write_vmem = write_vmem,\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.blank = blank,\n\t\t.set_gamma = set_gamma,\n\t},\n};\n\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"solomon,ssd1306\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ssd1306\");\nMODULE_ALIAS(\"platform:ssd1306\");\n\nMODULE_DESCRIPTION(\"SSD1306 OLED Driver\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ssd1331.c",
          "type": "blob",
          "size": 5.505859375,
          "content": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ssd1331\"\n#define WIDTH\t\t96\n#define HEIGHT\t\t64\n#define GAMMA_NUM\t1\n#define GAMMA_LEN\t63\n#define DEFAULT_GAMMA\t\"0 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2\" \\\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\twrite_reg(par, 0xae); /* Display Off */\n\twrite_reg(par, 0xa0, 0x70 | (par->bgr << 2)); /* Set Colour Depth */\n\twrite_reg(par, 0x72); // RGB colour\n\twrite_reg(par, 0xa1, 0x00); /* Set Display Start Line */\n\twrite_reg(par, 0xa2, 0x00); /* Set Display Offset */\n\twrite_reg(par, 0xa4); /* NORMALDISPLAY */\n\twrite_reg(par, 0xa8, 0x3f); // Set multiplex\n\twrite_reg(par, 0xad, 0x8e); // Set master\n\t// write_reg(par, 0xb0, 0x0b); // Set power mode\n\twrite_reg(par, 0xb1, 0x31); // Precharge\n\twrite_reg(par, 0xb3, 0xf0); // Clock div\n\twrite_reg(par, 0x8a, 0x64); // Precharge A\n\twrite_reg(par, 0x8b, 0x78); // Precharge B\n\twrite_reg(par, 0x8c, 0x64); // Precharge C\n\twrite_reg(par, 0xbb, 0x3a); // Precharge level\n\twrite_reg(par, 0xbe, 0x3e); // vcomh\n\twrite_reg(par, 0x87, 0x06); // Master current\n\twrite_reg(par, 0x81, 0x91); // Contrast A\n\twrite_reg(par, 0x82, 0x50); // Contrast B\n\twrite_reg(par, 0x83, 0x7d); // Contrast C\n\twrite_reg(par, 0xaf); /* Set Sleep Mode Display On */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\twrite_reg(par, 0x15, xs, xe);\n\twrite_reg(par, 0x75, ys, ye);\n}\n\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = (u8 *)par->buf;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tbuf[i] = (u8)va_arg(args, unsigned int);\n\t\t}\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device, u8, buf, len, \"%s: \", __func__);\n\t}\n\n\tva_start(args, len);\n\n\t*buf = (u8)va_arg(args, unsigned int);\n\tif (par->gpio.dc != -1)\n\t\tgpio_set_value(par->gpio.dc, 0);\n\tret = par->fbtftops.write(par, par->buf, sizeof(u8));\n\tif (ret < 0) {\n\t\tva_end(args);\n\t\tdev_err(par->info->device, \"%s: write() failed and returned %d\\n\", __func__, ret);\n\t\treturn;\n\t}\n\tlen--;\n\n\tif (len) {\n\t\ti = len;\n\t\twhile (i--) {\n\t\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\t\t}\n\t\tret = par->fbtftops.write(par, par->buf, len * (sizeof(u8)));\n\t\tif (ret < 0) {\n\t\t\tva_end(args);\n\t\t\tdev_err(par->info->device, \"%s: write() failed and returned %d\\n\", __func__, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (par->gpio.dc != -1)\n\t\tgpio_set_value(par->gpio.dc, 1);\n\tva_end(args);\n}\n\n/*\n\tGrayscale Lookup Table\n\tGS1 - GS63\n\tThe driver Gamma curve contains the relative values between the entries\n\tin the Lookup table.\n\n\tFrom datasheet:\n\t8.8 Gray Scale Decoder\n\n\t\tthere are total 180 Gamma Settings (Setting 0 to Setting 180)\n\t\tavailable for the Gray Scale table.\n\n\t\tThe gray scale is defined in incremental way, with reference\n\t\tto the length of previous table entry:\n\t\t\tSetting of GS1 has to be >= 0\n\t\t\tSetting of GS2 has to be > Setting of GS1 +1\n\t\t\tSetting of GS3 has to be > Setting of GS2 +1\n\t\t\t:\n\t\t\tSetting of GS63 has to be > Setting of GS62 +1\n\n\n*/\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long tmp[GAMMA_NUM * GAMMA_LEN];\n\tint i, acc = 0;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tfor (i = 0; i < 63; i++) {\n\t\tif (i > 0 && curves[i] < 2) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Illegal value in Grayscale Lookup Table at index %d. \" \\\n\t\t\t\t\"Must be greater than 1\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tacc += curves[i];\n\t\ttmp[i] = acc;\n\t\tif (acc > 180) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Illegal value(s) in Grayscale Lookup Table. \" \\\n\t\t\t\t\"At index=%d, the accumulated value has exceeded 180\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twrite_reg(par, 0xB8,\n\ttmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7],\n\ttmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14], tmp[15],\n\ttmp[16], tmp[17], tmp[18], tmp[19], tmp[20], tmp[21], tmp[22], tmp[23],\n\ttmp[24], tmp[25], tmp[26], tmp[27], tmp[28], tmp[29], tmp[30], tmp[31],\n\ttmp[32], tmp[33], tmp[34], tmp[35], tmp[36], tmp[37], tmp[38], tmp[39],\n\ttmp[40], tmp[41], tmp[42], tmp[43], tmp[44], tmp[45], tmp[46], tmp[47],\n\ttmp[48], tmp[49], tmp[50], tmp[51], tmp[52], tmp[53], tmp[54], tmp[55],\n\ttmp[56], tmp[57], tmp[58], tmp[59], tmp[60], tmp[61], tmp[62]);\n\n\treturn 0;\n}\n\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tfbtft_par_dbg(DEBUG_BLANK, par, \"%s(blank=%s)\\n\",\n\t\t__func__, on ? \"true\" : \"false\");\n\tif (on)\n\t\twrite_reg(par, 0xAE);\n\telse\n\t\twrite_reg(par, 0xAF);\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = GAMMA_NUM,\n\t.gamma_len = GAMMA_LEN,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.write_register = write_reg8_bus8,\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_gamma = set_gamma,\n\t\t.blank = blank,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"solomon,ssd1331\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ssd1331\");\nMODULE_ALIAS(\"platform:ssd1331\");\n\nMODULE_DESCRIPTION(\"SSD1331 OLED Driver\");\nMODULE_AUTHOR(\"Alec Smecher (adapted from SSD1351 by James Davies)\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_ssd1351.c",
          "type": "blob",
          "size": 6.9609375,
          "content": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ssd1351\"\n#define WIDTH\t\t128\n#define HEIGHT\t\t128\n#define GAMMA_NUM\t1\n#define GAMMA_LEN\t63\n#define DEFAULT_GAMMA\t\"0 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2\" \\\n\nstatic void register_onboard_backlight(struct fbtft_par *par);\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tif (par->pdata\n\t\t&& par->pdata->display.backlight == FBTFT_ONBOARD_BACKLIGHT) {\n\t\t/* module uses onboard GPIO for panel power */\n\t\tpar->fbtftops.register_backlight = register_onboard_backlight;\n\t}\n\n\tpar->fbtftops.reset(par);\n\n\twrite_reg(par, 0xfd, 0x12); /* Command Lock */\n\twrite_reg(par, 0xfd, 0xb1); /* Command Lock */\n\twrite_reg(par, 0xae); /* Display Off */\n\twrite_reg(par, 0xb3, 0xf1); /* Front Clock Div */\n\twrite_reg(par, 0xca, 0x7f); /* Set Mux Ratio */\n\twrite_reg(par, 0x15, 0x00, 0x7f); /* Set Column Address */\n\twrite_reg(par, 0x75, 0x00, 0x7f); /* Set Row Address */\n\twrite_reg(par, 0xa1, 0x00); /* Set Display Start Line */\n\twrite_reg(par, 0xa2, 0x00); /* Set Display Offset */\n\twrite_reg(par, 0xb5, 0x00); /* Set GPIO */\n\twrite_reg(par, 0xab, 0x01); /* Set Function Selection */\n\twrite_reg(par, 0xb1, 0x32); /* Set Phase Length */\n\twrite_reg(par, 0xb4, 0xa0, 0xb5, 0x55); /* Set Segment Low Voltage */\n\twrite_reg(par, 0xbb, 0x17); /* Set Precharge Voltage */\n\twrite_reg(par, 0xbe, 0x05); /* Set VComH Voltage */\n\twrite_reg(par, 0xc1, 0xc8, 0x80, 0xc8); /* Set Contrast */\n\twrite_reg(par, 0xc7, 0x0f); /* Set Master Contrast */\n\twrite_reg(par, 0xb6, 0x01); /* Set Second Precharge Period */\n\twrite_reg(par, 0xa6); /* Set Display Mode Reset */\n\twrite_reg(par, 0xaf); /* Set Sleep Mode Display On */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\twrite_reg(par, 0x15, xs, xe);\n\twrite_reg(par, 0x75, ys, ye);\n\twrite_reg(par, 0x5c);\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tunsigned remap;\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tif (par->fbtftops.init_display != init_display) {\n\t\t/* don't risk messing up register A0h */\n\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\"%s: skipping since custom init_display() is used\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tremap = 0x60 | (par->bgr << 2); /* Set Colour Depth */\n\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0xA0, remap | 0b00 | 1<<4);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0xA0, remap | 0b11 | 1<<4);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0xA0, remap | 0b10);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0xA0, remap | 0b01);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n\tGrayscale Lookup Table\n\tGS1 - GS63\n\tThe driver Gamma curve contains the relative values between the entries\n\tin the Lookup table.\n\n\tFrom datasheet:\n\t8.8 Gray Scale Decoder\n\n\t\tthere are total 180 Gamma Settings (Setting 0 to Setting 180)\n\t\tavailable for the Gray Scale table.\n\n\t\tThe gray scale is defined in incremental way, with reference\n\t\tto the length of previous table entry:\n\t\t\tSetting of GS1 has to be >= 0\n\t\t\tSetting of GS2 has to be > Setting of GS1 +1\n\t\t\tSetting of GS3 has to be > Setting of GS2 +1\n\t\t\t:\n\t\t\tSetting of GS63 has to be > Setting of GS62 +1\n\n\n*/\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tunsigned long tmp[GAMMA_NUM * GAMMA_LEN];\n\tint i, acc = 0;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tfor (i = 0; i < 63; i++) {\n\t\tif (i > 0 && curves[i] < 2) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Illegal value in Grayscale Lookup Table at index %d. \" \\\n\t\t\t\t\"Must be greater than 1\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tacc += curves[i];\n\t\ttmp[i] = acc;\n\t\tif (acc > 180) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Illegal value(s) in Grayscale Lookup Table. \" \\\n\t\t\t\t\"At index=%d, the accumulated value has exceeded 180\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twrite_reg(par, 0xB8,\n\ttmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7],\n\ttmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14], tmp[15],\n\ttmp[16], tmp[17], tmp[18], tmp[19], tmp[20], tmp[21], tmp[22], tmp[23],\n\ttmp[24], tmp[25], tmp[26], tmp[27], tmp[28], tmp[29], tmp[30], tmp[31],\n\ttmp[32], tmp[33], tmp[34], tmp[35], tmp[36], tmp[37], tmp[38], tmp[39],\n\ttmp[40], tmp[41], tmp[42], tmp[43], tmp[44], tmp[45], tmp[46], tmp[47],\n\ttmp[48], tmp[49], tmp[50], tmp[51], tmp[52], tmp[53], tmp[54], tmp[55],\n\ttmp[56], tmp[57], tmp[58], tmp[59], tmp[60], tmp[61], tmp[62]);\n\n\treturn 0;\n}\n\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tfbtft_par_dbg(DEBUG_BLANK, par, \"%s(blank=%s)\\n\",\n\t\t__func__, on ? \"true\" : \"false\");\n\tif (on)\n\t\twrite_reg(par, 0xAE);\n\telse\n\t\twrite_reg(par, 0xAF);\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = GAMMA_NUM,\n\t.gamma_len = GAMMA_LEN,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t\t.blank = blank,\n\t},\n};\n\n#ifdef CONFIG_FB_BACKLIGHT\nstatic int update_onboard_backlight(struct backlight_device *bd)\n{\n\tstruct fbtft_par *par = bl_get_data(bd);\n\tbool on;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par,\n\t\t\"%s: power=%d, fb_blank=%d\\n\",\n\t\t__func__, bd->props.power, bd->props.fb_blank);\n\n\ton = (bd->props.power == FB_BLANK_UNBLANK)\n\t\t&& (bd->props.fb_blank == FB_BLANK_UNBLANK);\n\t/* Onboard backlight connected to GPIO0 on SSD1351, GPIO1 unused */\n\twrite_reg(par, 0xB5, on ? 0x03 : 0x02);\n\n\treturn 0;\n}\n\nstatic void register_onboard_backlight(struct fbtft_par *par)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties bl_props = { 0, };\n\tstruct backlight_ops *bl_ops;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par, \"%s()\\n\", __func__);\n\n\tbl_ops = devm_kzalloc(par->info->device, sizeof(struct backlight_ops),\n\t\t\t\tGFP_KERNEL);\n\tif (!bl_ops) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: could not allocate memory for backlight operations.\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tbl_ops->update_status = update_onboard_backlight;\n\tbl_props.type = BACKLIGHT_RAW;\n\tbl_props.power = FB_BLANK_POWERDOWN;\n\n\tbd = backlight_device_register(dev_driver_string(par->info->device),\n\t\t\t\tpar->info->device, par, bl_ops, &bl_props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(par->info->device,\n\t\t\t\"cannot register backlight device (%ld)\\n\",\n\t\t\tPTR_ERR(bd));\n\t\treturn;\n\t}\n\tpar->info->bl_dev = bd;\n\n\tif (!par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight = fbtft_unregister_backlight;\n}\n#else\nstatic void register_onboard_backlight(struct fbtft_par *par) { };\n#endif\n\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"solomon,ssd1351\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ssd1351\");\nMODULE_ALIAS(\"platform:ssd1351\");\n\nMODULE_DESCRIPTION(\"SSD1351 OLED Driver\");\nMODULE_AUTHOR(\"James Davies\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_st7735r.c",
          "type": "blob",
          "size": 5.185546875,
          "content": "/*\n * FB driver for the ST7735R LCD Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME \"fb_st7735r\"\n#define DEFAULT_GAMMA \"0F 1A 0F 18 2F 28 20 22 1F 1B 23 37 00 07 02 10\\n\" \\\n                      \"0F 1B 0F 17 33 2C 29 2E 30 30 39 3F 00 07 03 10\"\n\n\nstatic int default_init_sequence[] = {\n\t/* SWRESET - Software reset */\n\t-1, 0x01,                                \n\t-2, 150,                               /* delay */\n\n\t/* SLPOUT - Sleep out & booster on */\n\t-1, 0x11,                          \n\t-2, 500,                               /* delay */\n\n\t/* FRMCTR1 - frame rate control: normal mode\n\t     frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D) */\n\t-1, 0xB1, 0x01, 0x2C, 0x2D, \n\n\t/* FRMCTR2 - frame rate control: idle mode\n\t     frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D) */\n\t-1, 0xB2, 0x01, 0x2C, 0x2D, \n\n\t/* FRMCTR3 - frame rate control - partial mode\n\t     dot inversion mode, line inversion mode */\n\t-1, 0xB3, 0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D,\n\n\t/* INVCTR - display inversion control\n\t     no inversion */\n\t-1, 0xB4, 0x07,\n\n\t/* PWCTR1 - Power Control\n\t     -4.6V, AUTO mode */\n\t-1, 0xC0, 0xA2, 0x02, 0x84,\n\n\t/* PWCTR2 - Power Control\n\t     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD */\n\t-1, 0xC1, 0xC5,\n\n\t/* PWCTR3 - Power Control\n\t     Opamp current small, Boost frequency */\n\t-1, 0xC2, 0x0A, 0x00,\n\n\t/* PWCTR4 - Power Control\n\t     BCLK/2, Opamp current small & Medium low */\n\t-1, 0xC3,0x8A,0x2A,\n\n\t/* PWCTR5 - Power Control */\n\t-1, 0xC4, 0x8A, 0xEE,\n\n\t/* VMCTR1 - Power Control */\n\t-1, 0xC5, 0x0E,\n\n\t/* INVOFF - Display inversion off */\n\t-1, 0x20,\n\n\t/* COLMOD - Interface pixel format */\n\t-1, 0x3A, 0x05,\n\n\t/* DISPON - Display On */\n\t-1, 0x29,\n\t-2, 100,                               /* delay */\n\n\t/* NORON - Partial off (Normal) */\n\t-1, 0x13,\n\t-2, 10,                               /* delay */\n\n\t/* end marker */\n\t-3                                  \n};\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address */\n\twrite_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);\n\n\t/* Row adress */\n\twrite_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\n#define MY (1 << 7)\n#define MX (1 << 6)\n#define MV (1 << 5)\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* MADCTL - Memory data access control\n\t     RGB/BGR:\n\t     1. Mode selection pin SRGB\n\t        RGB H/W pin for color filter setting: 0=RGB, 1=BGR\n\t     2. MADCTL RGB bit\n\t        RGB-BGR ORDER color filter panel: 0=RGB, 1=BGR */\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\twrite_reg(par, 0x36, MX | MY | (par->bgr << 3));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x36, MY | MV | (par->bgr << 3));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x36, (par->bgr << 3));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x36, MX | MV | (par->bgr << 3));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n  Gamma string format:\n    VRF0P VOS0P PK0P PK1P PK2P PK3P PK4P PK5P PK6P PK7P PK8P PK9P SELV0P SELV1P SELV62P SELV63P\n    VRF0N VOS0N PK0N PK1N PK2N PK3N PK4N PK5N PK6N PK7N PK8N PK9N SELV0N SELV1N SELV62N SELV63N\n*/\n#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tint i,j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tfor (i = 0; i < par->gamma.num_curves; i++)\n\t\tfor (j = 0; j < par->gamma.num_values; j++)\n\t\t\tCURVE(i,j) &= 0b111111;\n\n\tfor (i = 0; i < par->gamma.num_curves; i++)\n\t\twrite_reg(par, 0xE0 + i,\n\t\t\tCURVE(i, 0), CURVE(i, 1), CURVE(i, 2), CURVE(i, 3),\n\t\t\tCURVE(i, 4), CURVE(i, 5), CURVE(i, 6), CURVE(i, 7),\n\t\t\tCURVE(i, 8), CURVE(i, 9), CURVE(i, 10), CURVE(i, 11),\n\t\t\tCURVE(i, 12), CURVE(i, 13), CURVE(i, 14), CURVE(i,15));\n\n\treturn 0;\n}\n#undef CURVE\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = 128,\n\t.height = 160,\n\t.init_sequence = default_init_sequence,\n\t.gamma_num = 2,\n\t.gamma_len = 16,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"sitronix,st7735r\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:st7735r\");\nMODULE_ALIAS(\"platform:st7735r\");\n\nMODULE_DESCRIPTION(\"FB driver for the ST7735R LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_tinylcd.c",
          "type": "blob",
          "size": 3.1669921875,
          "content": "/*\n * Custom FB driver for tinylcd.com display\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_tinylcd\"\n#define WIDTH\t\t320\n#define HEIGHT\t\t480\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\twrite_reg(par, 0xB0, 0x80);\n\twrite_reg(par, 0xC0, 0x0A, 0x0A);\n\twrite_reg(par, 0xC1, 0x45, 0x07);\n\twrite_reg(par, 0xC2, 0x33);\n\twrite_reg(par, 0xC5, 0x00, 0x42, 0x80);\n\twrite_reg(par, 0xB1, 0xD0, 0x11);\n\twrite_reg(par, 0xB4, 0x02);\n\twrite_reg(par, 0xB6, 0x00, 0x22, 0x3B);\n\twrite_reg(par, 0xB7, 0x07);\n\twrite_reg(par, 0x36, 0x58);\n\twrite_reg(par, 0xF0, 0x36, 0xA5, 0xD3);\n\twrite_reg(par, 0xE5, 0x80);\n\twrite_reg(par, 0xE5, 0x01);\n\twrite_reg(par, 0xB3, 0x00);\n\twrite_reg(par, 0xE5, 0x00);\n\twrite_reg(par, 0xF0, 0x36, 0xA5, 0x53);\n\twrite_reg(par, 0xE0, 0x00, 0x35, 0x33, 0x00, 0x00, 0x00,\n\t                     0x00, 0x35, 0x33, 0x00, 0x00, 0x00);\n\twrite_reg(par, 0x3A, 0x55);\n\twrite_reg(par, 0x11);\n\tudelay(250);\n\twrite_reg(par, 0x29);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address */\n\twrite_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);\n\n\t/* Row adress */\n\twrite_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\tcase 270:\n\t\twrite_reg(par, 0xB6, 0x00, 0x02, 0x3B);\n\t\twrite_reg(par, 0x36, 0x28);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0xB6, 0x00, 0x22, 0x3B);\n\t\twrite_reg(par, 0x36, 0x58);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0xB6, 0x00, 0x22, 0x3B);\n\t\twrite_reg(par, 0x36, 0x38);\n\t\tbreak;\n\tdefault:\n\t\twrite_reg(par, 0xB6, 0x00, 0x22, 0x3B);\n\t\twrite_reg(par, 0x36, 0x08);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"neosec,tinylcd\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"spi:tinylcd\");\n\nMODULE_DESCRIPTION(\"Custom FB driver for tinylcd.com display\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_tls8204.c",
          "type": "blob",
          "size": 4.4189453125,
          "content": "/*\n * FB driver for the TLS8204 LCD Controller\n *\n * The display is monochrome and the video memory is RGB565.\n * Any pixel value except 0 turns the pixel on.\n *\n * Copyright (C) 2013 Noralf Tronnes\n * Copyright (C) 2014 Michael Hope (adapted for the TLS8204)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_tls8204\"\n#define WIDTH\t\t84\n#define HEIGHT\t\t48\n#define TXBUFLEN\tWIDTH\n#define DEFAULT_GAMMA\t\"40\" /* gamma is used to control contrast in this driver */\n\nstatic unsigned bs = 4;\nmodule_param(bs, uint, 0);\nMODULE_PARM_DESC(bs, \"BS[2:0] Bias voltage level: 0-7 (default: 4)\");\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\t/* Enter extended command mode */\n\twrite_reg(par, 0x21); /* 5:1  1\n\t\t\t\t 2:0  PD - Powerdown control: chip is active\n\t\t\t\t 1:0  V  - Entry mode: horizontal addressing\n\t\t\t\t 0:1  H  - Extended instruction set control: extended\n\t\t\t      */\n\n\t/* H=1 Bias system */\n\twrite_reg(par, 0x10 | (bs & 0x7)); /*\n\t\t\t\t 4:1  1\n\t\t\t\t 3:0  0\n\t\t\t\t 2:x  BS2 - Bias System\n\t\t\t\t 1:x  BS1\n\t\t\t\t 0:x  BS0\n\t\t\t      */\n\n\t/* Set the address of the first display line. */\n\twrite_reg(par, 0x04 | (64 >> 6));\n\twrite_reg(par, 0x40 | (64 & 0x3F));\n\n\t/* Enter H=0 standard command mode */\n\twrite_reg(par, 0x20);\n\n\t/* H=0 Display control */\n\twrite_reg(par, 0x08 | 4); /*\n\t\t\t\t 3:1  1\n\t\t\t\t 2:1  D  - DE: 10=normal mode\n\t\t\t\t 1:0  0\n\t\t\t\t 0:0  E\n\t\t\t      */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, \"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* H=0 Set X address of RAM */\n\twrite_reg(par, 0x80); /* 7:1  1\n\t\t\t\t 6-0: X[6:0] - 0x00\n\t\t\t      */\n\n\t/* H=0 Set Y address of RAM */\n\twrite_reg(par, 0x40); /* 7:0  0\n\t\t\t\t 6:1  1\n\t\t\t\t 2-0: Y[2:0] - 0x0\n\t\t\t      */\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_base;\n\tint x, y, i;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\tfor (y = 0; y < HEIGHT/8; y++) {\n\t\tu8 *buf = par->txbuf.buf;\n\t\t/* The display is 102x68 but the LCD is 84x48.  Set\n\t\t   the write pointer at the start of each row. */\n\t\tgpio_set_value(par->gpio.dc, 0);\n\t\twrite_reg(par, 0x80 | 0);\n\t\twrite_reg(par, 0x40 | y);\n\n\t\tfor (x = 0; x < WIDTH; x++) {\n\t\t\tu8 ch = 0;\n\t\t\tfor (i = 0; i < 8*WIDTH; i += WIDTH) {\n\t\t\t\tch >>= 1;\n\t\t\t\tif (vmem16[(y*8*WIDTH)+i+x])\n\t\t\t\t\tch |= 0x80;\n\t\t\t}\n\t\t\t*buf++ = ch;\n\t\t}\n\t\t/* Write the row */\n\t\tgpio_set_value(par->gpio.dc, 1);\n\t\tret = par->fbtftops.write(par, par->txbuf.buf, WIDTH);\n\t\tif (ret < 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"%s: write failed and returned: %d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* apply mask */\n\tcurves[0] &= 0x7F;\n\n\twrite_reg(par, 0x21); /* turn on extended instruction set */\n\twrite_reg(par, 0x80 | curves[0]);\n\twrite_reg(par, 0x20); /* turn off extended instruction set */\n\n\treturn 0;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.txbuflen = TXBUFLEN,\n\t.gamma_num = 1,\n\t.gamma_len = 1,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.write_vmem = write_vmem,\n\t\t.set_gamma = set_gamma,\n\t},\n\t.backlight = 1,\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"teralane,tls8204\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"spi:tls8204\");\n\nMODULE_DESCRIPTION(\"FB driver for the TLS8204 LCD Controller\");\nMODULE_AUTHOR(\"Michael Hope\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_uc1701.c",
          "type": "blob",
          "size": 6.0185546875,
          "content": "/*\n * FB driver for the UC1701 LCD Controller\n *\n * The display is monochrome and the video memory is RGB565.\n * Any pixel value except 0 turns the pixel on.\n *\n * Copyright (C) 2014 Juergen Holzmann\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\"fb_uc1701\"\n#define WIDTH\t  102\n#define HEIGHT\t 64\n#define PAGES\t  (HEIGHT/8)\n\n/* 1: Display on/off */\n#define LCD_DISPLAY_ENABLE    0xAE\n/* 2: display start line set */\n#define LCD_START_LINE\t0x40\n/* 3: Page address set (lower 4 bits select one of the pages) */\n#define LCD_PAGE_ADDRESS      0xB0\n/* 4: column address */\n#define LCD_COL_ADDRESS       0x10\n/* 8: select orientation */\n#define LCD_BOTTOMVIEW\t0xA0\n/* 9: inverted display */\n#define LCD_DISPLAY_INVERT    0xA6\n/* 10: show memory content or switch all pixels on */\n#define LCD_ALL_PIXEL\t 0xA4\n/* 11: lcd bias set */\n#define LCD_BIAS\t      0xA2\n/* 14: Reset Controller */\n#define LCD_RESET_CMD\t 0xE2\n/* 15: output mode select (turns display upside-down) */\n#define LCD_SCAN_DIR\t  0xC0\n/* 16: power control set */\n#define LCD_POWER_CONTROL     0x28\n/* 17: voltage regulator resistor ratio set */\n#define LCD_VOLTAGE\t   0x20\n/* 18: Volume mode set */\n#define LCD_VOLUME_MODE       0x81\n/* 22: NOP command */\n#define LCD_NO_OP\t     0xE3\n/* 25: advanced program control */\n#define LCD_ADV_PROG_CTRL     0xFA\n/* 25: advanced program control2 */\n#define LCD_ADV_PROG_CTRL2    0x10\n#define LCD_TEMPCOMP_HIGH     0x80\n/* column offset for normal orientation */\n#define SHIFT_ADDR_NORMAL     0\n/* column offset for bottom view orientation */\n#define SHIFT_ADDR_TOPVIEW    30\n\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\t/* softreset of LCD */\n\twrite_reg(par, LCD_RESET_CMD);\n\tmdelay(10);\n\n\t/* set startpoint */\n\t/* LCD_START_LINE | (pos & 0x3F) */\n\twrite_reg(par, LCD_START_LINE);\n\n\t/* select orientation BOTTOMVIEW */\n\twrite_reg(par, LCD_BOTTOMVIEW | 1);\n\t/* output mode select (turns display upside-down) */\n\twrite_reg(par, LCD_SCAN_DIR | 0x00);\n\n\t/* Normal Pixel mode */\n\twrite_reg(par, LCD_ALL_PIXEL | 0);\n\n\t/* positive display */\n\twrite_reg(par, LCD_DISPLAY_INVERT | 0);\n\n\t/* bias 1/9 */\n\twrite_reg(par, LCD_BIAS | 0);\n\n\t/* power control mode: all features on */\n\t/* LCD_POWER_CONTROL | (val&0x07) */\n\twrite_reg(par, LCD_POWER_CONTROL | 0x07);\n\n\t/* set voltage regulator R/R */\n\t/* LCD_VOLTAGE | (val&0x07) */\n\twrite_reg(par, LCD_VOLTAGE | 0x07);\n\n\t/* volume mode set */\n\t/* LCD_VOLUME_MODE,val&0x3f,LCD_NO_OP */\n\twrite_reg(par, LCD_VOLUME_MODE);\n\t/* LCD_VOLUME_MODE,val&0x3f,LCD_NO_OP */\n\twrite_reg(par, 0x09);\n\t/* ???? */\n\t/* LCD_VOLUME_MODE,val&0x3f,LCD_NO_OP */\n\twrite_reg(par, LCD_NO_OP);\n\n\t/* advanced program control */\n\twrite_reg(par, LCD_ADV_PROG_CTRL);\n\twrite_reg(par, LCD_ADV_PROG_CTRL2|LCD_TEMPCOMP_HIGH);\n\n\t/* enable display */\n\twrite_reg(par, LCD_DISPLAY_ENABLE | 1);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, \"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* goto address */\n\t/* LCD_PAGE_ADDRESS | ((page) & 0x1F),\n\t (((col)+SHIFT_ADDR_NORMAL) & 0x0F),\n\t LCD_COL_ADDRESS | ((((col)+SHIFT_ADDR_NORMAL)>>4) & 0x0F) */\n\twrite_reg(par, LCD_PAGE_ADDRESS);\n\t/* LCD_PAGE_ADDRESS | ((page) & 0x1F),\n\t (((col)+SHIFT_ADDR_NORMAL) & 0x0F),\n\t  LCD_COL_ADDRESS | ((((col)+SHIFT_ADDR_NORMAL)>>4) & 0x0F) */\n\twrite_reg(par, 0x00);\n\t/* LCD_PAGE_ADDRESS | ((page) & 0x1F),\n\t (((col)+SHIFT_ADDR_NORMAL) & 0x0F),\n\t  LCD_COL_ADDRESS | ((((col)+SHIFT_ADDR_NORMAL)>>4) & 0x0F) */\n\twrite_reg(par, LCD_COL_ADDRESS);\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_base;\n\tu8 *buf = par->txbuf.buf;\n\tint x, y, i;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\tfor (y = 0; y < PAGES; y++) {\n\t\tbuf = par->txbuf.buf;\n\t\tfor (x = 0; x < WIDTH; x++) {\n\t\t\t*buf = 0x00;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t*buf |= (vmem16[((y*8*WIDTH)+(i*WIDTH))+x] ? 1 : 0) << i;\n\t\t\tbuf++;\n\t\t}\n\t\t/* LCD_PAGE_ADDRESS | ((page) & 0x1F),\n\t\t (((col)+SHIFT_ADDR_NORMAL) & 0x0F),\n\t\t  LCD_COL_ADDRESS | ((((col)+SHIFT_ADDR_NORMAL)>>4) & 0x0F) */\n\t\twrite_reg(par, LCD_PAGE_ADDRESS|(u8)y);\n\t\t/* LCD_PAGE_ADDRESS | ((page) & 0x1F),\n\t\t (((col)+SHIFT_ADDR_NORMAL) & 0x0F),\n\t\t  LCD_COL_ADDRESS | ((((col)+SHIFT_ADDR_NORMAL)>>4) & 0x0F) */\n\t\twrite_reg(par, 0x00);\n\t\t/* LCD_PAGE_ADDRESS | ((page) & 0x1F),\n\t\t (((col)+SHIFT_ADDR_NORMAL) & 0x0F),\n\t\t  LCD_COL_ADDRESS | ((((col)+SHIFT_ADDR_NORMAL)>>4) & 0x0F) */\n\t\twrite_reg(par, LCD_COL_ADDRESS);\n\t\tgpio_set_value(par->gpio.dc, 1);\n\t\tret = par->fbtftops.write(par, par->txbuf.buf, WIDTH);\n\t\tgpio_set_value(par->gpio.dc, 0);\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(par->info->device, \"%s: write failed and returned: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.write_vmem = write_vmem,\n\t},\n\t.backlight = 1,\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"UltraChip,uc1701\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"spi:uc1701\");\n\nMODULE_DESCRIPTION(\"FB driver for the UC1701 LCD Controller\");\nMODULE_AUTHOR(\"Juergen Holzmann\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_upd161704.c",
          "type": "blob",
          "size": 6.0146484375,
          "content": "/*\n * FB driver for the uPD161704 LCD Controller\n *\n * Copyright (C) 2014 Seong-Woo Kim\n *\n * Based on fb_ili9325.c by Noralf Tronnes\n * Based on ili9325.c by Jeroen Domburg\n * Init code from UTFT library by Henning Karlsen\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_upd161704\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define BPP\t\t16\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tpar->fbtftops.reset(par);\n\n\tif (par->gpio.cs != -1)\n\t\tgpio_set_value(par->gpio.cs, 0);  /* Activate chip */\n\n\t/* Initialization sequence from Lib_UTFT */\n\n\t/* register reset */\n\twrite_reg(par, 0x0003,0x0001);\t/* Soft reset */\n\n\t/* oscillator start */\n\twrite_reg(par, 0x003A,0x0001);\t/*Oscillator 0: stop, 1: operation */\n\tudelay(100);\n\n\t/* y-setting */\n\twrite_reg(par, 0x0024,0x007B);\t/* amplitude setting */\n\tudelay(10);\n\twrite_reg(par, 0x0025,0x003B);\t/* amplitude setting */\n\twrite_reg(par, 0x0026,0x0034);\t/* amplitude setting */\n\tudelay(10);\n\twrite_reg(par, 0x0027,0x0004);\t/* amplitude setting */\n\twrite_reg(par, 0x0052,0x0025);\t/* circuit setting 1 */\n\tudelay(10);\n\twrite_reg(par, 0x0053,0x0033);\t/* circuit setting 2 */\n\twrite_reg(par, 0x0061,0x001C);\t/* adjustment V10 positive polarity */\n\tudelay(10);\n\twrite_reg(par, 0x0062,0x002C);\t/* adjustment V9 negative polarity */\n\twrite_reg(par, 0x0063,0x0022);\t/* adjustment V34 positive polarity */\n\tudelay(10);\n\twrite_reg(par, 0x0064,0x0027);\t/* adjustment V31 negative polarity */\n\tudelay(10);\n\twrite_reg(par, 0x0065,0x0014);\t/* adjustment V61 negative polarity */\n\tudelay(10);\n\twrite_reg(par, 0x0066,0x0010);\t/* adjustment V61 negative polarity */\n\t\n\t/* Basical clock for 1 line (BASECOUNT[7:0]) number specified */\n\twrite_reg(par, 0x002E,0x002D);\n\t\n\t/* Power supply setting */\n\twrite_reg(par, 0x0019,0x0000);\t/* DC/DC output setting */\n\tudelay(200);\n\twrite_reg(par, 0x001A,0x1000);\t/* DC/DC frequency setting */\n\twrite_reg(par, 0x001B,0x0023);\t/* DC/DC rising setting */\n\twrite_reg(par, 0x001C,0x0C01);\t/* Regulator voltage setting */\n\twrite_reg(par, 0x001D,0x0000);\t/* Regulator current setting */\n\twrite_reg(par, 0x001E,0x0009);\t/* VCOM output setting */\n\twrite_reg(par, 0x001F,0x0035);\t/* VCOM amplitude setting */\n\twrite_reg(par, 0x0020,0x0015);\t/* VCOMM cencter setting */\n\twrite_reg(par, 0x0018,0x1E7B);\t/* DC/DC operation setting */\n\n\t/* windows setting */\n\twrite_reg(par, 0x0008,0x0000);\t/* Minimum X address */\n\twrite_reg(par, 0x0009,0x00EF);\t/* Maximum X address */\n\twrite_reg(par, 0x000a,0x0000);\t/* Minimum Y address */\n\twrite_reg(par, 0x000b,0x013F);\t/* Maximum Y address */\n\n\t/* LCD display area setting */\n\twrite_reg(par, 0x0029,0x0000);\t/* [LCDSIZE]  X MIN. size set */\n\twrite_reg(par, 0x002A,0x0000);\t/* [LCDSIZE]  Y MIN. size set */\n\twrite_reg(par, 0x002B,0x00EF);\t/* [LCDSIZE]  X MAX. size set */\n\twrite_reg(par, 0x002C,0x013F);\t/* [LCDSIZE]  Y MAX. size set */\n\n\t/* Gate scan setting */\n\twrite_reg(par, 0x0032,0x0002);\n\t\n\t/* n line inversion line number */\n\twrite_reg(par, 0x0033,0x0000);\n\n\t/* Line inversion/frame inversion/interlace setting */\n\twrite_reg(par, 0x0037,0x0000);\n\t\n\t/* Gate scan operation setting register */\n\twrite_reg(par, 0x003B,0x0001);\n\t\n\t/* Color mode */\n\t/*GS = 0: 260-k color (64 gray scale), GS = 1: 8 color (2 gray scale) */\n\twrite_reg(par, 0x0004,0x0000);\n\n\t/* RAM control register */\n\twrite_reg(par, 0x0005,0x0000);\t/*Window access 00:Normal, 10:Window */\n\n\t/* Display setting register 2 */\n\twrite_reg(par, 0x0001,0x0000);\n\n\t/* display setting */\n\twrite_reg(par, 0x0000,0x0000);\t/* display on */\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\tswitch (par->info->var.rotate) {\n\t/* R20h = Horizontal GRAM Start Address */\n\t/* R21h = Vertical GRAM Start Address */\n\tcase 0:\n\t\twrite_reg(par, 0x0006, xs);\n\t\twrite_reg(par, 0x0007, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0006, WIDTH - 1 - xs);\n\t\twrite_reg(par, 0x0007, HEIGHT - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0006, WIDTH - 1 - ys);\n\t\twrite_reg(par, 0x0007, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0006, ys);\n\t\twrite_reg(par, 0x0007, HEIGHT - 1 - xs);\n\t\tbreak;\n\t}\n\n\twrite_reg(par, 0x0e); /* Write Data to GRAM */\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tswitch (par->info->var.rotate) {\n\t/* AM: GRAM update direction */\n\tcase 0:\n\t\twrite_reg(par, 0x01, 0x0000);\n\t\twrite_reg(par, 0x05, 0x0000);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x01, 0x00C0);\n\t\twrite_reg(par, 0x05, 0x0000);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x01, 0x0080);\n\t\twrite_reg(par, 0x05, 0x0001);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x01, 0x0040);\n\t\twrite_reg(par, 0x05, 0x0001);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"nec,upd161704\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:upd161704\");\nMODULE_ALIAS(\"platform:upd161704\");\n\nMODULE_DESCRIPTION(\"FB driver for the uPD161704 LCD Controller\");\nMODULE_AUTHOR(\"Seong-Woo Kim\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fb_watterott.c",
          "type": "blob",
          "size": 8.0439453125,
          "content": "/*\n * FB driver for the Watterott LCD Controller\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\t\"fb_watterott\"\n#define WIDTH\t\t\t320\n#define HEIGHT\t\t\t240\n#define FPS\t\t\t5\n#define TXBUFLEN\t\t1024\n#define DEFAULT_BRIGHTNESS\t50\n\n#define CMD_VERSION\t\t0x01\n#define CMD_LCD_LED\t\t0x10\n#define CMD_LCD_RESET\t\t0x11\n#define CMD_LCD_ORIENTATION\t0x20\n#define CMD_LCD_DRAWIMAGE\t0x27\n#define COLOR_RGB323\t\t8\n#define COLOR_RGB332\t\t9\n#define COLOR_RGB233\t\t10\n#define COLOR_RGB565\t\t16\n\n\nstatic short mode = 565;\nmodule_param(mode, short, 0);\nMODULE_PARM_DESC(mode, \"RGB color transfer mode: 332, 565 (default)\");\n\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = par->buf;\n\n\tva_start(args, len);\n\tfor (i = 0; i < len; i++)\n\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\tva_end(args);\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,\n\t\tpar->info->device, u8, par->buf, len, \"%s: \", __func__);\n\n\tret = par->fbtftops.write(par, par->buf, len);\n\tif (ret < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: write() failed and returned %d\\n\", __func__, ret);\n\t\treturn;\n\t}\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tunsigned start_line, end_line;\n\tu16 *vmem16 = (u16 *)(par->info->screen_base + offset);\n\tu16 *pos = par->txbuf.buf + 1;\n\tu16 *buf16 = par->txbuf.buf + 10;\n\tint i, j;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\tstart_line = offset / par->info->fix.line_length;\n\tend_line = start_line + (len / par->info->fix.line_length) - 1;\n\n\t/* Set command header. pos: x, y, w, h */\n\t((u8 *)par->txbuf.buf)[0] = CMD_LCD_DRAWIMAGE;\n\tpos[0] = 0;\n\tpos[2] = cpu_to_be16(par->info->var.xres);\n\tpos[3] = cpu_to_be16(1);\n\t((u8 *)par->txbuf.buf)[9] = COLOR_RGB565;\n\n\tfor (i = start_line; i <= end_line; i++) {\n\t\tpos[1] = cpu_to_be16(i);\n\t\tfor (j = 0; j < par->info->var.xres; j++)\n\t\t\tbuf16[j] = cpu_to_be16(*vmem16++);\n\t\tret = par->fbtftops.write(par,\n\t\t\tpar->txbuf.buf, 10 + par->info->fix.line_length);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tudelay(300);\n\t}\n\n\treturn 0;\n}\n\n#define RGB565toRGB323(c) (((c&0xE000)>>8) | ((c&0600)>>6) | ((c&0x001C)>>2))\n#define RGB565toRGB332(c) (((c&0xE000)>>8) | ((c&0700)>>6) | ((c&0x0018)>>3))\n#define RGB565toRGB233(c) (((c&0xC000)>>8) | ((c&0700)>>5) | ((c&0x001C)>>2))\n\nstatic int write_vmem_8bit(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tunsigned start_line, end_line;\n\tu16 *vmem16 = (u16 *)(par->info->screen_base + offset);\n\tu16 *pos = par->txbuf.buf + 1;\n\tu8 *buf8 = par->txbuf.buf + 10;\n\tint i, j;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s()\\n\", __func__);\n\n\tstart_line = offset / par->info->fix.line_length;\n\tend_line = start_line + (len / par->info->fix.line_length) - 1;\n\n\t/* Set command header. pos: x, y, w, h */\n\t((u8 *)par->txbuf.buf)[0] = CMD_LCD_DRAWIMAGE;\n\tpos[0] = 0;\n\tpos[2] = cpu_to_be16(par->info->var.xres);\n\tpos[3] = cpu_to_be16(1);\n\t((u8 *)par->txbuf.buf)[9] = COLOR_RGB332;\n\n\tfor (i = start_line; i <= end_line; i++) {\n\t\tpos[1] = cpu_to_be16(i);\n\t\tfor (j = 0; j < par->info->var.xres; j++) {\n\t\t\tbuf8[j] = RGB565toRGB332(*vmem16);\n\t\t\tvmem16++;\n\t\t}\n\t\tret = par->fbtftops.write(par,\n\t\t\tpar->txbuf.buf, 10 + par->info->var.xres);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tudelay(700);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned firmware_version(struct fbtft_par *par)\n{\n\tu8 rxbuf[4] = {0, };\n\n\twrite_reg(par, CMD_VERSION);\n\tpar->fbtftops.read(par, rxbuf, 4);\n\tif (rxbuf[1] != '.')\n\t\treturn 0;\n\n\treturn (rxbuf[0] - '0') << 8 | (rxbuf[2] - '0') << 4 | (rxbuf[3] - '0');\n}\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tint ret;\n\tunsigned version;\n\tu8 save_mode;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* enable SPI interface by having CS and MOSI low during reset */\n\tsave_mode = par->spi->mode;\n\tpar->spi->mode |= SPI_CS_HIGH;\n\tret = par->spi->master->setup(par->spi); /* set CS inactive low */\n\tif (ret) {\n\t\tdev_err(par->info->device, \"Could not set SPI_CS_HIGH\\n\");\n\t\treturn ret;\n\t}\n\twrite_reg(par, 0x00); /* make sure mode is set */\n\n\tmdelay(50);\n\tpar->fbtftops.reset(par);\n\tmdelay(1000);\n\tpar->spi->mode = save_mode;\n\tret = par->spi->master->setup(par->spi);\n\tif (ret) {\n\t\tdev_err(par->info->device, \"Could not restore SPI mode\\n\");\n\t\treturn ret;\n\t}\n\twrite_reg(par, 0x00);\n\n\tversion = firmware_version(par);\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"Firmware version: %x.%02x\\n\",\n\t\t\t\t\t\tversion >> 8, version & 0xFF);\n\n\tif (mode == 332)\n\t\tpar->fbtftops.write_vmem = write_vmem_8bit;\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\t/* not used on this controller */\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tu8 rotate;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* this controller rotates clock wise */\n\tswitch (par->info->var.rotate) {\n\tcase 90:\n\t\trotate = 27;\n\t\tbreak;\n\tcase 180:\n\t\trotate = 18;\n\t\tbreak;\n\tcase 270:\n\t\trotate = 9;\n\t\tbreak;\n\tdefault:\n\t\trotate = 0;\n\t}\n\twrite_reg(par, CMD_LCD_ORIENTATION, rotate);\n\n\treturn 0;\n}\n\nstatic int verify_gpios(struct fbtft_par *par)\n{\n\tif (par->gpio.reset < 0) {\n\t\tdev_err(par->info->device, \"Missing 'reset' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_FB_BACKLIGHT\nstatic int backlight_chip_update_status(struct backlight_device *bd)\n{\n\tstruct fbtft_par *par = bl_get_data(bd);\n\tint brightness = bd->props.brightness;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par,\n\t\t\"%s: brightness=%d, power=%d, fb_blank=%d\\n\",\n\t\t__func__, bd->props.brightness, bd->props.power,\n\t\tbd->props.fb_blank);\n\n\tif (bd->props.power != FB_BLANK_UNBLANK)\n\t\tbrightness = 0;\n\n\tif (bd->props.fb_blank != FB_BLANK_UNBLANK)\n\t\tbrightness = 0;\n\n\twrite_reg(par, CMD_LCD_LED, brightness);\n\n\treturn 0;\n}\n\nstatic void register_chip_backlight(struct fbtft_par *par)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties bl_props = { 0, };\n\tstruct backlight_ops *bl_ops;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par, \"%s()\\n\", __func__);\n\n\tbl_ops = devm_kzalloc(par->info->device, sizeof(struct backlight_ops),\n\t\t\t\tGFP_KERNEL);\n\tif (!bl_ops) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: could not allocate memory for backlight operations.\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tbl_ops->update_status = backlight_chip_update_status;\n\tbl_props.type = BACKLIGHT_RAW;\n\tbl_props.power = FB_BLANK_POWERDOWN;\n\tbl_props.max_brightness = 100;\n\tbl_props.brightness = DEFAULT_BRIGHTNESS;\n\n\tbd = backlight_device_register(dev_driver_string(par->info->device),\n\t\t\t\tpar->info->device, par, bl_ops, &bl_props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(par->info->device,\n\t\t\t\"cannot register backlight device (%ld)\\n\",\n\t\t\tPTR_ERR(bd));\n\t\treturn;\n\t}\n\tpar->info->bl_dev = bd;\n\n\tif (!par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight = fbtft_unregister_backlight;\n}\n#else\n#define register_chip_backlight NULL\n#endif\n\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.buswidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.fps = FPS,\n\t.txbuflen = TXBUFLEN,\n\t.fbtftops = {\n\t\t.write_register = write_reg8_bus8,\n\t\t.write_vmem = write_vmem,\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.verify_gpios = verify_gpios,\n\t\t.register_backlight = register_chip_backlight,\n\t},\n};\nFBTFT_REGISTER_DRIVER(DRVNAME, \"watterott,openlcd\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\n\nMODULE_DESCRIPTION(\"FB driver for the Watterott LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fbtft-bus.c",
          "type": "blob",
          "size": 8.3974609375,
          "content": "#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include \"fbtft.h\"\n\n\n\n\n/*****************************************************************************\n *\n *   void (*write_reg)(struct fbtft_par *par, int len, ...);\n *\n *****************************************************************************/\n\n#define define_fbtft_write_reg(func, type, modifier)                          \\\nvoid func(struct fbtft_par *par, int len, ...)                                \\\n{                                                                             \\\n\tva_list args;                                                         \\\n\tint i, ret;                                                           \\\n\tint offset = 0;                                                       \\\n\ttype *buf = (type *)par->buf;                                         \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {                    \\\n\t\tva_start(args, len);                                          \\\n\t\tfor (i = 0; i < len; i++) {                                   \\\n\t\t\tbuf[i] = (type)va_arg(args, unsigned int);            \\\n\t\t}                                                             \\\n\t\tva_end(args);                                                 \\\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device, type, buf, len, \"%s: \", __func__);   \\\n\t}                                                                     \\\n\t\t\t\t\t\t\t\t\t      \\\n\tva_start(args, len);                                                  \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (par->startbyte) {                                                 \\\n\t\t*(u8 *)par->buf = par->startbyte;                             \\\n\t\tbuf = (type *)(par->buf + 1);                                 \\\n\t\toffset = 1;                                                   \\\n\t}                                                                     \\\n\t\t\t\t\t\t\t\t\t      \\\n\t*buf = modifier((type)va_arg(args, unsigned int));                    \\\n\tif (par->gpio.dc != -1)                                               \\\n\t\tgpio_set_value(par->gpio.dc, 0);                              \\\n\tret = par->fbtftops.write(par, par->buf, sizeof(type)+offset);        \\\n\tif (ret < 0) {                                                        \\\n\t\tva_end(args);                                                 \\\n\t\tdev_err(par->info->device, \"%s: write() failed and returned %d\\n\", __func__, ret); \\\n\t\treturn;                                                       \\\n\t}                                                                     \\\n\tlen--;                                                                \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (par->startbyte)                                                   \\\n\t\t*(u8 *)par->buf = par->startbyte | 0x2;                       \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (len) {                                                            \\\n\t\ti = len;                                                      \\\n\t\twhile (i--) {                                                 \\\n\t\t\t*buf++ = modifier((type)va_arg(args, unsigned int));  \\\n\t\t}                                                             \\\n\t\tif (par->gpio.dc != -1)                                       \\\n\t\t\tgpio_set_value(par->gpio.dc, 1);                      \\\n\t\tret = par->fbtftops.write(par, par->buf, len * (sizeof(type)+offset)); \\\n\t\tif (ret < 0) {                                                \\\n\t\t\tva_end(args);                                         \\\n\t\t\tdev_err(par->info->device, \"%s: write() failed and returned %d\\n\", __func__, ret); \\\n\t\t\treturn;                                               \\\n\t\t}                                                             \\\n\t}                                                                     \\\n\tva_end(args);                                                         \\\n}                                                                             \\\nEXPORT_SYMBOL(func);\n\ndefine_fbtft_write_reg(fbtft_write_reg8_bus8, u8, )\ndefine_fbtft_write_reg(fbtft_write_reg16_bus8, u16, cpu_to_be16)\ndefine_fbtft_write_reg(fbtft_write_reg16_bus16, u16, )\n\nvoid fbtft_write_reg8_bus9(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tint pad = 0;\n\tu16 *buf = (u16 *)par->buf;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*(((u8 *)buf) + i) = (u8)va_arg(args, unsigned int);\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,\n\t\t\tpar->info->device, u8, buf, len, \"%s: \", __func__);\n\t}\n\tif (len <= 0)\n\t\treturn;\n\n\tif (par->spi && (par->spi->bits_per_word == 8)) {\n\t\t/* we're emulating 9-bit, pad start of buffer with no-ops\n\t\t   (assuming here that zero is a no-op) */\n\t\tpad = (len % 4) ? 4 - (len % 4) : 0;\n\t\tfor (i = 0; i < pad; i++)\n\t\t\t*buf++ = 0x000;\n\t}\n\n\tva_start(args, len);\n\t*buf++ = (u8)va_arg(args, unsigned int);\n\ti = len - 1;\n\twhile (i--) {\n\t\t*buf = (u8)va_arg(args, unsigned int);\n\t\t*buf++ |= 0x100; /* dc=1 */\n\t}\n\tva_end(args);\n\tret = par->fbtftops.write(par, par->buf, (len + pad) * sizeof(u16));\n\tif (ret < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: write() failed and returned %d\\n\", __func__, ret);\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL(fbtft_write_reg8_bus9);\n\n\n\n\n/*****************************************************************************\n *\n *   int (*write_vmem)(struct fbtft_par *par);\n *\n *****************************************************************************/\n\n/* 16 bit pixel over 8-bit databus */\nint fbtft_write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16;\n\tu16 *txbuf16 = (u16 *)par->txbuf.buf;\n\tsize_t remain;\n\tsize_t to_copy;\n\tsize_t tx_array_size;\n\tint i;\n\tint ret = 0;\n\tsize_t startbyte_size = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t__func__, offset, len);\n\n\tremain = len / 2;\n\tvmem16 = (u16 *)(par->info->screen_base + offset);\n\n\tif (par->gpio.dc != -1)\n\t\tgpio_set_value(par->gpio.dc, 1);\n\n\t/* non buffered write */\n\tif (!par->txbuf.buf)\n\t\treturn par->fbtftops.write(par, vmem16, len);\n\n\t/* buffered write */\n\ttx_array_size = par->txbuf.len / 2;\n\n\tif (par->startbyte) {\n\t\ttxbuf16 = (u16 *)(par->txbuf.buf + 1);\n\t\ttx_array_size -= 2;\n\t\t*(u8 *)(par->txbuf.buf) = par->startbyte | 0x2;\n\t\tstartbyte_size = 1;\n\t}\n\n\twhile (remain) {\n\t\tto_copy = remain > tx_array_size ? tx_array_size : remain;\n\t\tdev_dbg(par->info->device, \"    to_copy=%zu, remain=%zu\\n\",\n\t\t\t\t\t\tto_copy, remain - to_copy);\n\n\t\tfor (i = 0; i < to_copy; i++)\n\t\t\ttxbuf16[i] = cpu_to_be16(vmem16[i]);\n\n\t\tvmem16 = vmem16 + to_copy;\n\t\tret = par->fbtftops.write(par, par->txbuf.buf,\n\t\t\t\t\t\tstartbyte_size + to_copy * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tremain -= to_copy;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_write_vmem16_bus8);\n\n/* 16 bit pixel over 9-bit SPI bus: dc + high byte, dc + low byte */\nint fbtft_write_vmem16_bus9(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu8 *vmem8;\n\tu16 *txbuf16 = par->txbuf.buf;\n\tsize_t remain;\n\tsize_t to_copy;\n\tsize_t tx_array_size;\n\tint i;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t__func__, offset, len);\n\n\tif (!par->txbuf.buf) {\n\t\tdev_err(par->info->device, \"%s: txbuf.buf is NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tremain = len;\n\tvmem8 = par->info->screen_base + offset;\n\n\ttx_array_size = par->txbuf.len / 2;\n\n\twhile (remain) {\n\t\tto_copy = remain > tx_array_size ? tx_array_size : remain;\n\t\tdev_dbg(par->info->device, \"    to_copy=%zu, remain=%zu\\n\",\n\t\t\t\t\t\tto_copy, remain - to_copy);\n\n#ifdef __LITTLE_ENDIAN\n\t\tfor (i = 0; i < to_copy; i += 2) {\n\t\t\ttxbuf16[i]   = 0x0100 | vmem8[i+1];\n\t\t\ttxbuf16[i+1] = 0x0100 | vmem8[i];\n\t\t}\n#else\n\t\tfor (i = 0; i < to_copy; i++)\n\t\t\ttxbuf16[i]   = 0x0100 | vmem8[i];\n#endif\n\t\tvmem8 = vmem8 + to_copy;\n\t\tret = par->fbtftops.write(par, par->txbuf.buf, to_copy*2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tremain -= to_copy;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_write_vmem16_bus9);\n\nint fbtft_write_vmem8_bus8(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tdev_err(par->info->device, \"%s: function not implemented\\n\", __func__);\n\treturn -1;\n}\nEXPORT_SYMBOL(fbtft_write_vmem8_bus8);\n\n/* 16 bit pixel over 16-bit databus */\nint fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t__func__, offset, len);\n\n\tvmem16 = (u16 *)(par->info->screen_base + offset);\n\n\tif (par->gpio.dc != -1)\n\t\tgpio_set_value(par->gpio.dc, 1);\n\n\t/* no need for buffered write with 16-bit bus */\n\treturn par->fbtftops.write(par, vmem16, len);\n}\nEXPORT_SYMBOL(fbtft_write_vmem16_bus16);\n"
        },
        {
          "name": "fbtft-core.c",
          "type": "blob",
          "size": 39.826171875,
          "content": "/*\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This driver is inspired by:\n *   st7735fb.c, Copyright (C) 2011, Matt Porter\n *   broadsheetfb.c, Copyright (C) 2008, Jaya Kumar\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/backlight.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n\n#include \"fbtft.h\"\n\nextern void fbtft_sysfs_init(struct fbtft_par *par);\nextern void fbtft_sysfs_exit(struct fbtft_par *par);\nextern void fbtft_expand_debug_value(unsigned long *debug);\nextern int fbtft_gamma_parse_str(struct fbtft_par *par, unsigned long *curves,\n\t\t\t\t\t\tconst char *str, int size);\n\nstatic unsigned long debug;\nmodule_param(debug, ulong , 0);\nMODULE_PARM_DESC(debug, \"override device debug level\");\n\nstatic bool dma = true;\nmodule_param(dma, bool, 0);\nMODULE_PARM_DESC(dma, \"Use DMA buffer\");\n\n\nvoid fbtft_dbg_hex(const struct device *dev, int groupsize,\n\t\t\tvoid *buf, size_t len, const char *fmt, ...)\n{\n\tva_list args;\n\tstatic char textbuf[512];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\n\tva_start(args, fmt);\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\tva_end(args);\n\n\thex_dump_to_buffer(buf, len, 32, groupsize, text + text_len,\n\t\t\t\t512 - text_len, false);\n\n\tif (len > 32)\n\t\tdev_info(dev, \"%s ...\\n\", text);\n\telse\n\t\tdev_info(dev, \"%s\\n\", text);\n}\nEXPORT_SYMBOL(fbtft_dbg_hex);\n\nunsigned long fbtft_request_gpios_match(struct fbtft_par *par,\n\t\t\t\t\tconst struct fbtft_gpio *gpio)\n{\n\tint ret;\n\tlong val;\n\n\tfbtft_par_dbg(DEBUG_REQUEST_GPIOS_MATCH, par, \"%s('%s')\\n\",\n\t\t__func__, gpio->name);\n\n\tif (strcasecmp(gpio->name, \"reset\") == 0) {\n\t\tpar->gpio.reset = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t} else if (strcasecmp(gpio->name, \"dc\") == 0) {\n\t\tpar->gpio.dc = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_LOW;\n\t} else if (strcasecmp(gpio->name, \"cs\") == 0) {\n\t\tpar->gpio.cs = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t} else if (strcasecmp(gpio->name, \"wr\") == 0) {\n\t\tpar->gpio.wr = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t} else if (strcasecmp(gpio->name, \"rd\") == 0) {\n\t\tpar->gpio.rd = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t} else if (strcasecmp(gpio->name, \"latch\") == 0) {\n\t\tpar->gpio.latch = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_LOW;\n\t} else if (gpio->name[0] == 'd' && gpio->name[1] == 'b') {\n\t\tret = kstrtol(&gpio->name[2], 10, &val);\n\t\tif (ret == 0 && val < 16) {\n\t\t\tpar->gpio.db[val] = gpio->gpio;\n\t\t\treturn GPIOF_OUT_INIT_LOW;\n\t\t}\n\t} else if (strcasecmp(gpio->name, \"led\") == 0) {\n\t\tpar->gpio.led[0] = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_LOW;\n\t} else if (strcasecmp(gpio->name, \"led_\") == 0) {\n\t\tpar->gpio.led[0] = gpio->gpio;\n\t\treturn GPIOF_OUT_INIT_HIGH;\n\t}\n\n\treturn FBTFT_GPIO_NO_MATCH;\n}\n\nint fbtft_request_gpios(struct fbtft_par *par)\n{\n\tstruct fbtft_platform_data *pdata = par->pdata;\n\tconst struct fbtft_gpio *gpio;\n\tunsigned long flags;\n\tint ret;\n\n\tif (pdata && pdata->gpios) {\n\t\tgpio = pdata->gpios;\n\t\twhile (gpio->name[0]) {\n\t\t\tflags = FBTFT_GPIO_NO_MATCH;\n\t\t\t/* if driver provides match function, try it first,\n\t\t\t   if no match use our own */\n\t\t\tif (par->fbtftops.request_gpios_match)\n\t\t\t\tflags = par->fbtftops.request_gpios_match(par, gpio);\n\t\t\tif (flags == FBTFT_GPIO_NO_MATCH)\n\t\t\t\tflags = fbtft_request_gpios_match(par, gpio);\n\t\t\tif (flags != FBTFT_GPIO_NO_MATCH) {\n\t\t\t\tret = devm_gpio_request_one(par->info->device,\n\t\t\t\t\t\tgpio->gpio, flags,\n\t\t\t\t\t\tpar->info->device->driver->name);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\t\"%s: gpio_request_one('%s'=%d) failed with %d\\n\",\n\t\t\t\t\t\t__func__, gpio->name,\n\t\t\t\t\t\tgpio->gpio, ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfbtft_par_dbg(DEBUG_REQUEST_GPIOS, par,\n\t\t\t\t\t\"%s: '%s' = GPIO%d\\n\",\n\t\t\t\t\t__func__, gpio->name, gpio->gpio);\n\t\t\t}\n\t\t\tgpio++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic int fbtft_request_one_gpio(struct fbtft_par *par,\n\t\t\t\t  const char *name, int index, int *gpiop)\n{\n\tstruct device *dev = par->info->device;\n\tstruct device_node *node = dev->of_node;\n\tint gpio, flags, ret = 0;\n\tenum of_gpio_flags of_flags;\n\n\tif (of_find_property(node, name, NULL)) {\n\t\tgpio = of_get_named_gpio_flags(node, name, index, &of_flags);\n\t\tif (gpio == -ENOENT)\n\t\t\treturn 0;\n\t\tif (gpio == -EPROBE_DEFER)\n\t\t\treturn gpio;\n\t\tif (gpio < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to get '%s' from DT\\n\", name);\n\t\t\treturn gpio;\n\t\t}\n\n\t\t/* active low translates to initially low */\n\t\tflags = (of_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_LOW :\n\t\t\t\t\t\t\tGPIOF_OUT_INIT_HIGH;\n\t\tret = devm_gpio_request_one(dev, gpio, flags,\n\t\t\t\t\t\tdev->driver->name);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"gpio_request_one('%s'=%d) failed with %d\\n\",\n\t\t\t\tname, gpio, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (gpiop)\n\t\t\t*gpiop = gpio;\n\t\tfbtft_par_dbg(DEBUG_REQUEST_GPIOS, par, \"%s: '%s' = GPIO%d\\n\",\n\t\t\t\t\t\t\t__func__, name, gpio);\n\t}\n\n\treturn ret;\n}\n\nstatic int fbtft_request_gpios_dt(struct fbtft_par *par)\n{\n\tint i;\n\tint ret;\n\n\tif (!par->info->device->of_node)\n\t\treturn -EINVAL;\n\n\tret = fbtft_request_one_gpio(par, \"reset-gpios\", 0, &par->gpio.reset);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"dc-gpios\", 0, &par->gpio.dc);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"rd-gpios\", 0, &par->gpio.rd);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"wr-gpios\", 0, &par->gpio.wr);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"cs-gpios\", 0, &par->gpio.cs);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"latch-gpios\", 0, &par->gpio.latch);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < 16; i++) {\n\t\tret = fbtft_request_one_gpio(par, \"db-gpios\", i,\n\t\t\t\t\t\t&par->gpio.db[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fbtft_request_one_gpio(par, \"led-gpios\", i,\n\t\t\t\t\t\t&par->gpio.led[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fbtft_request_one_gpio(par, \"aux-gpios\", i,\n\t\t\t\t\t\t&par->gpio.aux[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_FB_BACKLIGHT\nint fbtft_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct fbtft_par *par = bl_get_data(bd);\n\tbool polarity = !!(bd->props.state & BL_CORE_DRIVER1);\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par,\n\t\t\"%s: polarity=%d, power=%d, fb_blank=%d\\n\",\n\t\t__func__, polarity, bd->props.power, bd->props.fb_blank);\n\n\tif ((bd->props.power == FB_BLANK_UNBLANK) && (bd->props.fb_blank == FB_BLANK_UNBLANK))\n\t\tgpio_set_value(par->gpio.led[0], polarity);\n\telse\n\t\tgpio_set_value(par->gpio.led[0], !polarity);\n\n\treturn 0;\n}\n\nint fbtft_backlight_get_brightness(struct backlight_device *bd)\n{\n\treturn bd->props.brightness;\n}\n\nvoid fbtft_unregister_backlight(struct fbtft_par *par)\n{\n\tconst struct backlight_ops *bl_ops;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par, \"%s()\\n\", __func__);\n\n\tif (par->info->bl_dev) {\n\t\tpar->info->bl_dev->props.power = FB_BLANK_POWERDOWN;\n\t\tbacklight_update_status(par->info->bl_dev);\n\t\tbl_ops = par->info->bl_dev->ops;\n\t\tbacklight_device_unregister(par->info->bl_dev);\n\t\tpar->info->bl_dev = NULL;\n\t}\n}\n\nvoid fbtft_register_backlight(struct fbtft_par *par)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties bl_props = { 0, };\n\tstruct backlight_ops *bl_ops;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par, \"%s()\\n\", __func__);\n\n\tif (par->gpio.led[0] == -1) {\n\t\tfbtft_par_dbg(DEBUG_BACKLIGHT, par,\n\t\t\t\"%s(): led pin not set, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tbl_ops = devm_kzalloc(par->info->device, sizeof(struct backlight_ops),\n\t\t\t\tGFP_KERNEL);\n\tif (!bl_ops) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: could not allocate memeory for backlight operations.\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tbl_ops->get_brightness = fbtft_backlight_get_brightness;\n\tbl_ops->update_status = fbtft_backlight_update_status;\n\tbl_props.type = BACKLIGHT_RAW;\n\t/* Assume backlight is off, get polarity from current state of pin */\n\tbl_props.power = FB_BLANK_POWERDOWN;\n\tif (!gpio_get_value(par->gpio.led[0]))\n\t\tbl_props.state |= BL_CORE_DRIVER1;\n\n\tbd = backlight_device_register(dev_driver_string(par->info->device),\n\t\t\t\tpar->info->device, par, bl_ops, &bl_props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(par->info->device,\n\t\t\t\"cannot register backlight device (%ld)\\n\",\n\t\t\tPTR_ERR(bd));\n\t\treturn;\n\t}\n\tpar->info->bl_dev = bd;\n\n\tif (!par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight = fbtft_unregister_backlight;\n}\n#else\nvoid fbtft_register_backlight(struct fbtft_par *par) { };\nvoid fbtft_unregister_backlight(struct fbtft_par *par) { };\n#endif\nEXPORT_SYMBOL(fbtft_register_backlight);\nEXPORT_SYMBOL(fbtft_unregister_backlight);\n\nvoid fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\t/* Column address set */\n\twrite_reg(par, 0x2A,\n\t\t(xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);\n\n\t/* Row adress set */\n\twrite_reg(par, 0x2B,\n\t\t(ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);\n\n\t/* Memory write */\n\twrite_reg(par, 0x2C);\n}\n\n\nvoid fbtft_reset(struct fbtft_par *par)\n{\n\tif (par->gpio.reset == -1)\n\t\treturn;\n\tfbtft_par_dbg(DEBUG_RESET, par, \"%s()\\n\", __func__);\n\tgpio_set_value(par->gpio.reset, 0);\n\tudelay(20);\n\tgpio_set_value(par->gpio.reset, 1);\n\tmdelay(120);\n}\n\n\nvoid fbtft_update_display(struct fbtft_par *par, unsigned start_line, unsigned end_line)\n{\n\tsize_t offset, len;\n\tstruct timespec ts_start, ts_end, ts_fps, ts_duration;\n\tlong fps_ms, fps_us, duration_ms, duration_us;\n\tlong fps, throughput;\n\tbool timeit = false;\n\tint ret = 0;\n\n\tif (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE | DEBUG_TIME_EACH_UPDATE))) {\n\t\tif ((par->debug & DEBUG_TIME_EACH_UPDATE) || \\\n\t\t\t\t((par->debug & DEBUG_TIME_FIRST_UPDATE) && !par->first_update_done)) {\n\t\t\tgetnstimeofday(&ts_start);\n\t\t\ttimeit = true;\n\t\t}\n\t}\n\n\t/* Sanity checks */\n\tif (start_line > end_line) {\n\t\tdev_warn(par->info->device,\n\t\t\t\"%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\\n\",\n\t\t\t__func__, start_line, end_line);\n\t\tstart_line = 0;\n\t\tend_line = par->info->var.yres - 1;\n\t}\n\tif (start_line > par->info->var.yres - 1 || end_line > par->info->var.yres - 1) {\n\t\tdev_warn(par->info->device,\n\t\t\t\"%s: start_line=%u or end_line=%u is larger than max=%d. Shouldn't happen, will do full display update\\n\",\n\t\t\t__func__, start_line, end_line, par->info->var.yres - 1);\n\t\tstart_line = 0;\n\t\tend_line = par->info->var.yres - 1;\n\t}\n\n\tfbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, \"%s(start_line=%u, end_line=%u)\\n\",\n\t\t__func__, start_line, end_line);\n\n\tif (par->fbtftops.set_addr_win)\n\t\tpar->fbtftops.set_addr_win(par, 0, start_line,\n\t\t\t\tpar->info->var.xres-1, end_line);\n\n\toffset = start_line * par->info->fix.line_length;\n\tlen = (end_line - start_line + 1) * par->info->fix.line_length;\n\tret = par->fbtftops.write_vmem(par, offset, len);\n\tif (ret < 0)\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: write_vmem failed to update display buffer\\n\",\n\t\t\t__func__);\n\n\tif (unlikely(timeit)) {\n\t\tgetnstimeofday(&ts_end);\n\t\tif (par->update_time.tv_nsec == 0 && par->update_time.tv_sec == 0) {\n\t\t\tpar->update_time.tv_sec = ts_start.tv_sec;\n\t\t\tpar->update_time.tv_nsec = ts_start.tv_nsec;\n\t\t}\n\t\tts_fps = timespec_sub(ts_start, par->update_time);\n\t\tpar->update_time.tv_sec = ts_start.tv_sec;\n\t\tpar->update_time.tv_nsec = ts_start.tv_nsec;\n\t\tfps_ms = (ts_fps.tv_sec * 1000) + ((ts_fps.tv_nsec / 1000000) % 1000);\n\t\tfps_us = (ts_fps.tv_nsec / 1000) % 1000;\n\t\tfps = fps_ms * 1000 + fps_us;\n\t\tfps = fps ? 1000000 / fps : 0;\n\n\t\tts_duration = timespec_sub(ts_end, ts_start);\n\t\tduration_ms = (ts_duration.tv_sec * 1000) + ((ts_duration.tv_nsec / 1000000) % 1000);\n\t\tduration_us = (ts_duration.tv_nsec / 1000) % 1000;\n\t\tthroughput = duration_ms * 1000 + duration_us;\n\t\tthroughput = throughput ? (len * 1000) / throughput : 0;\n\t\tthroughput = throughput * 1000 / 1024;\n\n\t\tdev_info(par->info->device,\n\t\t\t\"Display update: %ld kB/s (%ld.%.3ld ms), fps=%ld (%ld.%.3ld ms)\\n\",\n\t\t\tthroughput, duration_ms, duration_us,\n\t\t\tfps, fps_ms, fps_us);\n\t\tpar->first_update_done = true;\n\t}\n}\n\n\nvoid fbtft_mkdirty(struct fb_info *info, int y, int height)\n{\n\tstruct fbtft_par *par = info->par;\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\t/* special case, needed ? */\n\tif (y == -1) {\n\t\ty = 0;\n\t\theight = info->var.yres - 1;\n\t}\n\n\t/* Mark display lines/area as dirty */\n\tspin_lock(&par->dirty_lock);\n\tif (y < par->dirty_lines_start)\n\t\tpar->dirty_lines_start = y;\n\tif (y + height - 1 > par->dirty_lines_end)\n\t\tpar->dirty_lines_end = y + height - 1;\n\tspin_unlock(&par->dirty_lock);\n\n\t/* Schedule deferred_io to update display (no-op if already on queue)*/\n\tschedule_delayed_work(&info->deferred_work, fbdefio->delay);\n}\n\nvoid fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)\n{\n\tstruct fbtft_par *par = info->par;\n\tunsigned dirty_lines_start, dirty_lines_end;\n\tstruct page *page;\n\tunsigned long index;\n\tunsigned y_low = 0, y_high = 0;\n\tint count = 0;\n\n\tspin_lock(&par->dirty_lock);\n\tdirty_lines_start = par->dirty_lines_start;\n\tdirty_lines_end = par->dirty_lines_end;\n\t/* set display line markers as clean */\n\tpar->dirty_lines_start = par->info->var.yres - 1;\n\tpar->dirty_lines_end = 0;\n\tspin_unlock(&par->dirty_lock);\n\n\t/* Mark display lines as dirty */\n\tlist_for_each_entry(page, pagelist, lru) {\n\t\tcount++;\n\t\tindex = page->index << PAGE_SHIFT;\n\t\ty_low = index / info->fix.line_length;\n\t\ty_high = (index + PAGE_SIZE - 1) / info->fix.line_length;\n\t\tfbtft_dev_dbg(DEBUG_DEFERRED_IO, par, info->device,\n\t\t\t\"page->index=%lu y_low=%d y_high=%d\\n\",\n\t\t\tpage->index, y_low, y_high);\n\t\tif (y_high > info->var.yres - 1)\n\t\t\ty_high = info->var.yres - 1;\n\t\tif (y_low < dirty_lines_start)\n\t\t\tdirty_lines_start = y_low;\n\t\tif (y_high > dirty_lines_end)\n\t\t\tdirty_lines_end = y_high;\n\t}\n\n\tpar->fbtftops.update_display(info->par,\n\t\t\t\t\tdirty_lines_start, dirty_lines_end);\n}\n\n\nvoid fbtft_fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\n{\n\tstruct fbtft_par *par = info->par;\n\n\tfbtft_dev_dbg(DEBUG_FB_FILLRECT, par, info->dev,\n\t\t\"%s: dx=%d, dy=%d, width=%d, height=%d\\n\",\n\t\t__func__, rect->dx, rect->dy, rect->width, rect->height);\n\tsys_fillrect(info, rect);\n\n\tpar->fbtftops.mkdirty(info, rect->dy, rect->height);\n}\n\nvoid fbtft_fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\n{\n\tstruct fbtft_par *par = info->par;\n\n\tfbtft_dev_dbg(DEBUG_FB_COPYAREA, par, info->dev,\n\t\t\"%s: dx=%d, dy=%d, width=%d, height=%d\\n\",\n\t\t__func__,  area->dx, area->dy, area->width, area->height);\n\tsys_copyarea(info, area);\n\n\tpar->fbtftops.mkdirty(info, area->dy, area->height);\n}\n\nvoid fbtft_fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tstruct fbtft_par *par = info->par;\n\n\tfbtft_dev_dbg(DEBUG_FB_IMAGEBLIT, par, info->dev,\n\t\t\"%s: dx=%d, dy=%d, width=%d, height=%d\\n\",\n\t\t__func__,  image->dx, image->dy, image->width, image->height);\n\tsys_imageblit(info, image);\n\n\tpar->fbtftops.mkdirty(info, image->dy, image->height);\n}\n\nssize_t fbtft_fb_write(struct fb_info *info,\n\t\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct fbtft_par *par = info->par;\n\tssize_t res;\n\n\tfbtft_dev_dbg(DEBUG_FB_WRITE, par, info->dev,\n\t\t\"%s: count=%zd, ppos=%llu\\n\", __func__,  count, *ppos);\n\tres = fb_sys_write(info, buf, count, ppos);\n\n\t/* TODO: only mark changed area\n\t   update all for now */\n\tpar->fbtftops.mkdirty(info, -1, 0);\n\n\treturn res;\n}\n\n/* from pxafb.c */\nunsigned int chan_to_field(unsigned chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nint fbtft_fb_setcolreg(unsigned regno,\n\t\t\t       unsigned red, unsigned green, unsigned blue,\n\t\t\t       unsigned transp, struct fb_info *info)\n{\n\tstruct fbtft_par *par = info->par;\n\tunsigned val;\n\tint ret = 1;\n\n\tfbtft_dev_dbg(DEBUG_FB_SETCOLREG, par, info->dev,\n\t\t\"%s(regno=%u, red=0x%X, green=0x%X, blue=0x%X, trans=0x%X)\\n\",\n\t\t__func__, regno, red, green, blue, transp);\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\tu32 *pal = info->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red,   &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue,  &info->var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\t}\n\treturn ret;\n}\n\nint fbtft_fb_blank(int blank, struct fb_info *info)\n{\n\tstruct fbtft_par *par = info->par;\n\tint ret = -EINVAL;\n\n\tfbtft_dev_dbg(DEBUG_FB_BLANK, par, info->dev, \"%s(blank=%d)\\n\",\n\t\t__func__, blank);\n\n\tif (!par->fbtftops.blank)\n\t\treturn ret;\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\tret = par->fbtftops.blank(par, true);\n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\n\t\tret = par->fbtftops.blank(par, false);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nvoid fbtft_merge_fbtftops(struct fbtft_ops *dst, struct fbtft_ops *src)\n{\n\tif (src->write)\n\t\tdst->write = src->write;\n\tif (src->read)\n\t\tdst->read = src->read;\n\tif (src->write_vmem)\n\t\tdst->write_vmem = src->write_vmem;\n\tif (src->write_register)\n\t\tdst->write_register = src->write_register;\n\tif (src->set_addr_win)\n\t\tdst->set_addr_win = src->set_addr_win;\n\tif (src->reset)\n\t\tdst->reset = src->reset;\n\tif (src->mkdirty)\n\t\tdst->mkdirty = src->mkdirty;\n\tif (src->update_display)\n\t\tdst->update_display = src->update_display;\n\tif (src->init_display)\n\t\tdst->init_display = src->init_display;\n\tif (src->blank)\n\t\tdst->blank = src->blank;\n\tif (src->request_gpios_match)\n\t\tdst->request_gpios_match = src->request_gpios_match;\n\tif (src->request_gpios)\n\t\tdst->request_gpios = src->request_gpios;\n\tif (src->verify_gpios)\n\t\tdst->verify_gpios = src->verify_gpios;\n\tif (src->register_backlight)\n\t\tdst->register_backlight = src->register_backlight;\n\tif (src->unregister_backlight)\n\t\tdst->unregister_backlight = src->unregister_backlight;\n\tif (src->set_var)\n\t\tdst->set_var = src->set_var;\n\tif (src->set_gamma)\n\t\tdst->set_gamma = src->set_gamma;\n}\n\n/**\n * fbtft_framebuffer_alloc - creates a new frame buffer info structure\n *\n * @display: pointer to structure describing the display\n * @dev: pointer to the device for this fb, this can be NULL\n *\n * Creates a new frame buffer info structure.\n *\n * Also creates and populates the following structures:\n *   info->fbops\n *   info->fbdefio\n *   info->pseudo_palette\n *   par->fbtftops\n *   par->txbuf\n *\n * Returns the new structure, or NULL if an error occurred.\n *\n */\nstruct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,\n\t\t\t\t\tstruct device *dev)\n{\n\tstruct fb_info *info;\n\tstruct fbtft_par *par;\n\tstruct fb_ops *fbops = NULL;\n\tstruct fb_deferred_io *fbdefio = NULL;\n\tstruct fbtft_platform_data *pdata = dev->platform_data;\n\tu8 *vmem = NULL;\n\tvoid *txbuf = NULL;\n\tvoid *buf = NULL;\n\tunsigned width;\n\tunsigned height;\n\tint txbuflen = display->txbuflen;\n\tunsigned bpp = display->bpp;\n\tunsigned fps = display->fps;\n\tint vmem_size, i;\n\tint *init_sequence = display->init_sequence;\n\tchar *gamma = display->gamma;\n\tunsigned long *gamma_curves = NULL;\n\n\t/* sanity check */\n\tif (display->gamma_num * display->gamma_len > FBTFT_GAMMA_MAX_VALUES_TOTAL) {\n\t\tdev_err(dev,\n\t\t\t\"%s: FBTFT_GAMMA_MAX_VALUES_TOTAL=%d is exceeded\\n\",\n\t\t\t__func__, FBTFT_GAMMA_MAX_VALUES_TOTAL);\n\t\treturn NULL;\n\t}\n\n\t/* defaults */\n\tif (!fps)\n\t\tfps = 20;\n\tif (!bpp)\n\t\tbpp = 16;\n\n\tif (!pdata) {\n\t\tdev_err(dev, \"platform data is missing\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* override driver values? */\n\tif (pdata->fps)\n\t\tfps = pdata->fps;\n\tif (pdata->txbuflen)\n\t\ttxbuflen = pdata->txbuflen;\n\tif (pdata->display.init_sequence)\n\t\tinit_sequence = pdata->display.init_sequence;\n\tif (pdata->gamma)\n\t\tgamma = pdata->gamma;\n\tif (pdata->display.debug)\n\t\tdisplay->debug = pdata->display.debug;\n\tif (pdata->display.backlight)\n\t\tdisplay->backlight = pdata->display.backlight;\n\tif (pdata->display.width)\n\t\tdisplay->width = pdata->display.width;\n\tif (pdata->display.height)\n\t\tdisplay->height = pdata->display.height;\n\tif (pdata->display.buswidth)\n\t\tdisplay->buswidth = pdata->display.buswidth;\n\tif (pdata->display.regwidth)\n\t\tdisplay->regwidth = pdata->display.regwidth;\n\n\tdisplay->debug |= debug;\n\tfbtft_expand_debug_value(&display->debug);\n\n\tswitch (pdata->rotate) {\n\tcase 90:\n\tcase 270:\n\t\twidth =  display->height;\n\t\theight = display->width;\n\t\tbreak;\n\tdefault:\n\t\twidth =  display->width;\n\t\theight = display->height;\n\t}\n\n\tvmem_size = display->width * display->height * bpp / 8;\n\tvmem = vzalloc(vmem_size);\n\tif (!vmem)\n\t\tgoto alloc_fail;\n\n\tfbops = devm_kzalloc(dev, sizeof(struct fb_ops), GFP_KERNEL);\n\tif (!fbops)\n\t\tgoto alloc_fail;\n\n\tfbdefio = devm_kzalloc(dev, sizeof(struct fb_deferred_io), GFP_KERNEL);\n\tif (!fbdefio)\n\t\tgoto alloc_fail;\n\n\tbuf = devm_kzalloc(dev, 128, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto alloc_fail;\n\n\tif (display->gamma_num && display->gamma_len) {\n\t\tgamma_curves = devm_kzalloc(dev, display->gamma_num * display->gamma_len * sizeof(gamma_curves[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!gamma_curves)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct fbtft_par), dev);\n\tif (!info)\n\t\tgoto alloc_fail;\n\n\tinfo->screen_base = (u8 __force __iomem *)vmem;\n\tinfo->fbops = fbops;\n\tinfo->fbdefio = fbdefio;\n\n\tfbops->owner        =      dev->driver->owner;\n\tfbops->fb_read      =      fb_sys_read;\n\tfbops->fb_write     =      fbtft_fb_write;\n\tfbops->fb_fillrect  =      fbtft_fb_fillrect;\n\tfbops->fb_copyarea  =      fbtft_fb_copyarea;\n\tfbops->fb_imageblit =      fbtft_fb_imageblit;\n\tfbops->fb_setcolreg =      fbtft_fb_setcolreg;\n\tfbops->fb_blank     =      fbtft_fb_blank;\n\n\tfbdefio->delay =           HZ/fps;\n\tfbdefio->deferred_io =     fbtft_deferred_io;\n\tfb_deferred_io_init(info);\n\n\tstrncpy(info->fix.id, dev->driver->name, 16);\n\tinfo->fix.type =           FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual =         FB_VISUAL_TRUECOLOR;\n\tinfo->fix.xpanstep =\t   0;\n\tinfo->fix.ypanstep =\t   0;\n\tinfo->fix.ywrapstep =\t   0;\n\tinfo->fix.line_length =    width*bpp/8;\n\tinfo->fix.accel =          FB_ACCEL_NONE;\n\tinfo->fix.smem_len =       vmem_size;\n\n\tinfo->var.rotate =         pdata->rotate;\n\tinfo->var.xres =           width;\n\tinfo->var.yres =           height;\n\tinfo->var.xres_virtual =   info->var.xres;\n\tinfo->var.yres_virtual =   info->var.yres;\n\tinfo->var.bits_per_pixel = bpp;\n\tinfo->var.nonstd =         1;\n\n\t/* RGB565 */\n\tinfo->var.red.offset =     11;\n\tinfo->var.red.length =     5;\n\tinfo->var.green.offset =   5;\n\tinfo->var.green.length =   6;\n\tinfo->var.blue.offset =    0;\n\tinfo->var.blue.length =    5;\n\tinfo->var.transp.offset =  0;\n\tinfo->var.transp.length =  0;\n\n\tinfo->flags =              FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;\n\n\tpar = info->par;\n\tpar->info = info;\n\tpar->pdata = dev->platform_data;\n\tpar->debug = display->debug;\n\tpar->buf = buf;\n\tspin_lock_init(&par->dirty_lock);\n\tpar->bgr = pdata->bgr;\n\tpar->startbyte = pdata->startbyte;\n\tpar->init_sequence = init_sequence;\n\tpar->gamma.curves = gamma_curves;\n\tpar->gamma.num_curves = display->gamma_num;\n\tpar->gamma.num_values = display->gamma_len;\n\tmutex_init(&par->gamma.lock);\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tif (par->gamma.curves && gamma) {\n\t\tif (fbtft_gamma_parse_str(par,\n\t\t\tpar->gamma.curves, gamma, strlen(gamma)))\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Transmit buffer */\n\tif (txbuflen == -1)\n\t\ttxbuflen = vmem_size + 2; /* add in case startbyte is used */\n\n#ifdef __LITTLE_ENDIAN\n\tif ((!txbuflen) && (bpp > 8))\n\t\ttxbuflen = PAGE_SIZE; /* need buffer for byteswapping */\n#endif\n\n\tif (txbuflen > 0) {\n\t\tif (dma) {\n\t\t\tdev->coherent_dma_mask = ~0;\n\t\t\ttxbuf = dmam_alloc_coherent(dev, txbuflen, &par->txbuf.dma, GFP_DMA);\n\t\t} else {\n\t\t\ttxbuf = devm_kzalloc(par->info->device, txbuflen, GFP_KERNEL);\n\t\t}\n\t\tif (!txbuf)\n\t\t\tgoto alloc_fail;\n\t\tpar->txbuf.buf = txbuf;\n\t\tpar->txbuf.len = txbuflen;\n\t}\n\n\t/* Initialize gpios to disabled */\n\tpar->gpio.reset = -1;\n\tpar->gpio.dc = -1;\n\tpar->gpio.rd = -1;\n\tpar->gpio.wr = -1;\n\tpar->gpio.cs = -1;\n\tpar->gpio.latch = -1;\n\tfor (i = 0; i < 16; i++) {\n\t\tpar->gpio.db[i] = -1;\n\t\tpar->gpio.led[i] = -1;\n\t\tpar->gpio.aux[i] = -1;\n\t}\n\n\t/* default fbtft operations */\n\tpar->fbtftops.write = fbtft_write_spi;\n\tpar->fbtftops.read = fbtft_read_spi;\n\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\n\tpar->fbtftops.write_register = fbtft_write_reg8_bus8;\n\tpar->fbtftops.set_addr_win = fbtft_set_addr_win;\n\tpar->fbtftops.reset = fbtft_reset;\n\tpar->fbtftops.mkdirty = fbtft_mkdirty;\n\tpar->fbtftops.update_display = fbtft_update_display;\n\tpar->fbtftops.request_gpios = fbtft_request_gpios;\n\tif (display->backlight)\n\t\tpar->fbtftops.register_backlight = fbtft_register_backlight;\n\n\t/* use driver provided functions */\n\tfbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);\n\n\treturn info;\n\nalloc_fail:\n\tvfree(vmem);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(fbtft_framebuffer_alloc);\n\n/**\n * fbtft_framebuffer_release - frees up all memory used by the framebuffer\n *\n * @info: frame buffer info structure\n *\n */\nvoid fbtft_framebuffer_release(struct fb_info *info)\n{\n\tfb_deferred_io_cleanup(info);\n\tvfree(info->screen_base);\n\tframebuffer_release(info);\n}\nEXPORT_SYMBOL(fbtft_framebuffer_release);\n\n/**\n *\tfbtft_register_framebuffer - registers a tft frame buffer device\n *\t@fb_info: frame buffer info structure\n *\n *  Sets SPI driverdata if needed\n *  Requests needed gpios.\n *  Initializes display\n *  Updates display.\n *\tRegisters a frame buffer device @fb_info.\n *\n *\tReturns negative errno on error, or zero for success.\n *\n */\nint fbtft_register_framebuffer(struct fb_info *fb_info)\n{\n\tint ret;\n\tchar text1[50] = \"\";\n\tchar text2[50] = \"\";\n\tstruct fbtft_par *par = fb_info->par;\n\tstruct spi_device *spi = par->spi;\n\n\t/* sanity checks */\n\tif (!par->fbtftops.init_display) {\n\t\tdev_err(fb_info->device, \"missing fbtftops.init_display()\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (spi)\n\t\tspi_set_drvdata(spi, fb_info);\n\tif (par->pdev)\n\t\tplatform_set_drvdata(par->pdev, fb_info);\n\n\tret = par->fbtftops.request_gpios(par);\n\tif (ret < 0)\n\t\tgoto reg_fail;\n\n\tif (par->fbtftops.verify_gpios) {\n\t\tret = par->fbtftops.verify_gpios(par);\n\t\tif (ret < 0)\n\t\t\tgoto reg_fail;\n\t}\n\n\tret = par->fbtftops.init_display(par);\n\tif (ret < 0)\n\t\tgoto reg_fail;\n\tif (par->fbtftops.set_var) {\n\t\tret = par->fbtftops.set_var(par);\n\t\tif (ret < 0)\n\t\t\tgoto reg_fail;\n\t}\n\n\t/* update the entire display */\n\tpar->fbtftops.update_display(par, 0, par->info->var.yres - 1);\n\n\tif (par->fbtftops.set_gamma && par->gamma.curves) {\n\t\tret = par->fbtftops.set_gamma(par, par->gamma.curves);\n\t\tif (ret)\n\t\t\tgoto reg_fail;\n\t}\n\n\tif (par->fbtftops.register_backlight)\n\t\tpar->fbtftops.register_backlight(par);\n\n\tret = register_framebuffer(fb_info);\n\tif (ret < 0)\n\t\tgoto reg_fail;\n\n\tfbtft_sysfs_init(par);\n\n\tif (par->txbuf.buf)\n\t\tsprintf(text1, \", %d KiB %sbuffer memory\",\n\t\t\tpar->txbuf.len >> 10, par->txbuf.dma ? \"DMA \" : \"\");\n\tif (spi)\n\t\tsprintf(text2, \", spi%d.%d at %d MHz\", spi->master->bus_num,\n\t\t\t\tspi->chip_select, spi->max_speed_hz/1000000);\n\tdev_info(fb_info->dev,\n\t\t\"%s frame buffer, %dx%d, %d KiB video memory%s, fps=%lu%s\\n\",\n\t\tfb_info->fix.id, fb_info->var.xres, fb_info->var.yres,\n\t\tfb_info->fix.smem_len >> 10, text1,\n\t\tHZ/fb_info->fbdefio->delay, text2);\n\n#ifdef CONFIG_FB_BACKLIGHT\n\t/* Turn on backlight if available */\n\tif (fb_info->bl_dev) {\n\t\tfb_info->bl_dev->props.power = FB_BLANK_UNBLANK;\n\t\tfb_info->bl_dev->ops->update_status(fb_info->bl_dev);\n\t}\n#endif\n\n\treturn 0;\n\nreg_fail:\n\tif (par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight(par);\n\tif (spi)\n\t\tspi_set_drvdata(spi, NULL);\n\tif (par->pdev)\n\t\tplatform_set_drvdata(par->pdev, NULL);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_register_framebuffer);\n\n/**\n *\tfbtft_unregister_framebuffer - releases a tft frame buffer device\n *\t@fb_info: frame buffer info structure\n *\n *  Frees SPI driverdata if needed\n *  Frees gpios.\n *\tUnregisters frame buffer device.\n *\n */\nint fbtft_unregister_framebuffer(struct fb_info *fb_info)\n{\n\tstruct fbtft_par *par = fb_info->par;\n\tstruct spi_device *spi = par->spi;\n\tint ret;\n\n\tif (spi)\n\t\tspi_set_drvdata(spi, NULL);\n\tif (par->pdev)\n\t\tplatform_set_drvdata(par->pdev, NULL);\n\tif (par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight(par);\n\tfbtft_sysfs_exit(par);\n\tret = unregister_framebuffer(fb_info);\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_unregister_framebuffer);\n\n#ifdef CONFIG_OF\n/**\n * fbtft_init_display_dt() - Device Tree init_display() function\n * @par: Driver data\n *\n * Return: 0 if successful, negative if error\n */\nstatic int fbtft_init_display_dt(struct fbtft_par *par)\n{\n\tstruct device_node *node = par->info->device->of_node;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tu32 val;\n\tint buf[64], i, j;\n\tchar msg[128];\n\tchar str[16];\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tprop = of_find_property(node, \"init\", NULL);\n\tp = of_prop_next_u32(prop, NULL, &val);\n\tif (!p)\n\t\treturn -EINVAL;\n\twhile (p) {\n\t\tif (val & FBTFT_OF_INIT_CMD) {\n\t\t\tval &= 0xFFFF;\n\t\t\ti = 0;\n\t\t\twhile (p && !(val & 0xFFFF0000)) {\n\t\t\t\tif (i > 63) {\n\t\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"%s: Maximum register values exceeded\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbuf[i++] = val;\n\t\t\t\tp = of_prop_next_u32(prop, p, &val);\n\t\t\t}\n\t\t\t/* make debug message */\n\t\t\tmsg[0] = '\\0';\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tsnprintf(str, 128, \" %02X\", buf[j]);\n\t\t\t\tstrcat(msg, str);\n\t\t\t}\n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t\"init: write_register:%s\\n\", msg);\n\n\t\t\tpar->fbtftops.write_register(par, i,\n\t\t\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\t\t\tbuf[4], buf[5], buf[6], buf[7],\n\t\t\t\tbuf[8], buf[9], buf[10], buf[11],\n\t\t\t\tbuf[12], buf[13], buf[14], buf[15],\n\t\t\t\tbuf[16], buf[17], buf[18], buf[19],\n\t\t\t\tbuf[20], buf[21], buf[22], buf[23],\n\t\t\t\tbuf[24], buf[25], buf[26], buf[27],\n\t\t\t\tbuf[28], buf[29], buf[30], buf[31],\n\t\t\t\tbuf[32], buf[33], buf[34], buf[35],\n\t\t\t\tbuf[36], buf[37], buf[38], buf[39],\n\t\t\t\tbuf[40], buf[41], buf[42], buf[43],\n\t\t\t\tbuf[44], buf[45], buf[46], buf[47],\n\t\t\t\tbuf[48], buf[49], buf[50], buf[51],\n\t\t\t\tbuf[52], buf[53], buf[54], buf[55],\n\t\t\t\tbuf[56], buf[57], buf[58], buf[59],\n\t\t\t\tbuf[60], buf[61], buf[62], buf[63]);\n\t\t} else if (val & FBTFT_OF_INIT_DELAY) {\n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t\"init: msleep(%u)\\n\", val & 0xFFFF);\n\t\t\tmsleep(val & 0xFFFF);\n\t\t\tp = of_prop_next_u32(prop, p, &val);\n\t\t} else {\n\t\t\tdev_err(par->info->device, \"illegal init value 0x%X\\n\",\n\t\t\t\t\t\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n/**\n * fbtft_init_display() - Generic init_display() function\n * @par: Driver data\n *\n * Uses par->init_sequence to do the initialization\n *\n * Return: 0 if successful, negative if error\n */\nint fbtft_init_display(struct fbtft_par *par)\n{\n\tint buf[64];\n\tchar msg[128];\n\tchar str[16];\n\tint i = 0;\n\tint j;\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, \"%s()\\n\", __func__);\n\n\t/* sanity check */\n\tif (!par->init_sequence) {\n\t\tdev_err(par->info->device,\n\t\t\t\"error: init_sequence is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* make sure stop marker exists */\n\tfor (i = 0; i < FBTFT_MAX_INIT_SEQUENCE; i++)\n\t\tif (par->init_sequence[i] == -3)\n\t\t\tbreak;\n\tif (i == FBTFT_MAX_INIT_SEQUENCE) {\n\t\tdev_err(par->info->device,\n\t\t\t\"missing stop marker at end of init sequence\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpar->fbtftops.reset(par);\n\tif (par->gpio.cs != -1)\n\t\tgpio_set_value(par->gpio.cs, 0);  /* Activate chip */\n\n\ti = 0;\n\twhile (i < FBTFT_MAX_INIT_SEQUENCE) {\n\t\tif (par->init_sequence[i] == -3) {\n\t\t\t/* done */\n\t\t\treturn 0;\n\t\t}\n\t\tif (par->init_sequence[i] >= 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"missing delimiter at position %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (par->init_sequence[i+1] < 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"missing value after delimiter %d at position %d\\n\",\n\t\t\t\tpar->init_sequence[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (par->init_sequence[i]) {\n\t\tcase -1:\n\t\t\ti++;\n\t\t\t/* make debug message */\n\t\t\tstrcpy(msg, \"\");\n\t\t\tj = i + 1;\n\t\t\twhile (par->init_sequence[j] >= 0) {\n\t\t\t\tsprintf(str, \"0x%02X \", par->init_sequence[j]);\n\t\t\t\tstrcat(msg, str);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t\"init: write(0x%02X) %s\\n\",\n\t\t\t\tpar->init_sequence[i], msg);\n\n\t\t\t/* Write */\n\t\t\tj = 0;\n\t\t\twhile (par->init_sequence[i] >= 0) {\n\t\t\t\tif (j > 63) {\n\t\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"%s: Maximum register values exceeded\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbuf[j++] = par->init_sequence[i++];\n\t\t\t}\n\t\t\tpar->fbtftops.write_register(par, j,\n\t\t\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\t\t\tbuf[4], buf[5], buf[6], buf[7],\n\t\t\t\tbuf[8], buf[9], buf[10], buf[11],\n\t\t\t\tbuf[12], buf[13], buf[14], buf[15],\n\t\t\t\tbuf[16], buf[17], buf[18], buf[19],\n\t\t\t\tbuf[20], buf[21], buf[22], buf[23],\n\t\t\t\tbuf[24], buf[25], buf[26], buf[27],\n\t\t\t\tbuf[28], buf[29], buf[30], buf[31],\n\t\t\t\tbuf[32], buf[33], buf[34], buf[35],\n\t\t\t\tbuf[36], buf[37], buf[38], buf[39],\n\t\t\t\tbuf[40], buf[41], buf[42], buf[43],\n\t\t\t\tbuf[44], buf[45], buf[46], buf[47],\n\t\t\t\tbuf[48], buf[49], buf[50], buf[51],\n\t\t\t\tbuf[52], buf[53], buf[54], buf[55],\n\t\t\t\tbuf[56], buf[57], buf[58], buf[59],\n\t\t\t\tbuf[60], buf[61], buf[62], buf[63]);\n\t\t\tbreak;\n\t\tcase -2:\n\t\t\ti++;\n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t\"init: mdelay(%d)\\n\", par->init_sequence[i]);\n\t\t\tmdelay(par->init_sequence[i++]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"unknown delimiter %d at position %d\\n\",\n\t\t\t\tpar->init_sequence[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_err(par->info->device,\n\t\t\"%s: something is wrong. Shouldn't get here.\\n\", __func__);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(fbtft_init_display);\n\n/**\n * fbtft_verify_gpios() - Generic verify_gpios() function\n * @par: Driver data\n *\n * Uses @spi, @pdev and @buswidth to determine which GPIOs is needed\n *\n * Return: 0 if successful, negative if error\n */\nint fbtft_verify_gpios(struct fbtft_par *par)\n{\n\tstruct fbtft_platform_data *pdata;\n\tint i;\n\n\tfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, \"%s()\\n\", __func__);\n\n\tpdata = par->info->device->platform_data;\n\tif (pdata->display.buswidth != 9 && par->startbyte == 0 && \\\n\t\t\t\t\t\t\tpar->gpio.dc < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'dc' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!par->pdev)\n\t\treturn 0;\n\n\tif (par->gpio.wr < 0) {\n\t\tdev_err(par->info->device, \"Missing 'wr' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < pdata->display.buswidth; i++) {\n\t\tif (par->gpio.db[i] < 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Missing 'db%02d' gpio. Aborting.\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\n/* returns 0 if the property is not present */\nstatic u32 fbtft_of_value(struct device_node *node, const char *propname)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tret = of_property_read_u32(node, propname, &val);\n\tif (ret == 0)\n\t\tpr_info(\"%s: %s = %u\\n\", __func__, propname, val);\n\n\treturn val;\n}\n\nstatic struct fbtft_platform_data *fbtft_probe_dt(struct device *dev)\n{\n\tstruct device_node *node = dev->of_node;\n\tstruct fbtft_platform_data *pdata;\n\n\tif (!node) {\n\t\tdev_err(dev, \"Missing platform data or DT\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->display.width = fbtft_of_value(node, \"width\");\n\tpdata->display.height = fbtft_of_value(node, \"height\");\n\tpdata->display.regwidth = fbtft_of_value(node, \"regwidth\");\n\tpdata->display.buswidth = fbtft_of_value(node, \"buswidth\");\n\tpdata->display.backlight = fbtft_of_value(node, \"backlight\");\n\tpdata->display.bpp = fbtft_of_value(node, \"bpp\");\n\tpdata->display.debug = fbtft_of_value(node, \"debug\");\n\tpdata->rotate = fbtft_of_value(node, \"rotate\");\n\tpdata->bgr = of_property_read_bool(node, \"bgr\");\n\tpdata->fps = fbtft_of_value(node, \"fps\");\n\tpdata->txbuflen = fbtft_of_value(node, \"txbuflen\");\n\tpdata->startbyte = fbtft_of_value(node, \"startbyte\");\n\tof_property_read_string(node, \"gamma\", (const char **)&pdata->gamma);\n\n\tif (of_find_property(node, \"led-gpios\", NULL))\n\t\tpdata->display.backlight = 1;\n\tif (of_find_property(node, \"init\", NULL))\n\t\tpdata->display.fbtftops.init_display = fbtft_init_display_dt;\n\tpdata->display.fbtftops.request_gpios = fbtft_request_gpios_dt;\n\n\treturn pdata;\n}\n#else\nstatic struct fbtft_platform_data *fbtft_probe_dt(struct device *dev)\n{\n\tdev_err(dev, \"Missing platform data\\n\");\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\n/**\n * fbtft_probe_common() - Generic device probe() helper function\n * @display: Display properties\n * @sdev: SPI device\n * @pdev: Platform device\n *\n * Allocates, initializes and registers a framebuffer\n *\n * Either @sdev or @pdev should be NULL\n *\n * Return: 0 if successful, negative if error\n */\nint fbtft_probe_common(struct fbtft_display *display,\n\t\t\tstruct spi_device *sdev, struct platform_device *pdev)\n{\n\tstruct device *dev;\n\tstruct fb_info *info;\n\tstruct fbtft_par *par;\n\tstruct fbtft_platform_data *pdata;\n\tint ret;\n\n\tif (sdev)\n\t\tdev = &sdev->dev;\n\telse\n\t\tdev = &pdev->dev;\n\n\tif (unlikely(display->debug & DEBUG_DRIVER_INIT_FUNCTIONS))\n\t\tdev_info(dev, \"%s()\\n\", __func__);\n\n\tpdata = dev->platform_data;\n\tif (!pdata) {\n\t\tpdata = fbtft_probe_dt(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t\tdev->platform_data = pdata;\n\t}\n\n\tinfo = fbtft_framebuffer_alloc(display, dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->spi = sdev;\n\tpar->pdev = pdev;\n\n\tif (display->buswidth == 0) {\n\t\tdev_err(dev, \"buswidth is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* write register functions */\n\tif (display->regwidth == 8 && display->buswidth == 8) {\n\t\tpar->fbtftops.write_register = fbtft_write_reg8_bus8;\n\t} else\n\tif (display->regwidth == 8 && display->buswidth == 9 && par->spi) {\n\t\tpar->fbtftops.write_register = fbtft_write_reg8_bus9;\n\t} else if (display->regwidth == 16 && display->buswidth == 8) {\n\t\tpar->fbtftops.write_register = fbtft_write_reg16_bus8;\n\t} else if (display->regwidth == 16 && display->buswidth == 16) {\n\t\tpar->fbtftops.write_register = fbtft_write_reg16_bus16;\n\t} else {\n\t\tdev_warn(dev,\n\t\t\t\"no default functions for regwidth=%d and buswidth=%d\\n\",\n\t\t\tdisplay->regwidth, display->buswidth);\n\t}\n\n\t/* write_vmem() functions */\n\tif (display->buswidth == 8)\n\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\n\telse if (display->buswidth == 9)\n\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus9;\n\telse if (display->buswidth == 16)\n\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus16;\n\n\t/* GPIO write() functions */\n\tif (par->pdev) {\n\t\tif (display->buswidth == 8)\n\t\t\tpar->fbtftops.write = fbtft_write_gpio8_wr;\n\t\telse if (display->buswidth == 16)\n\t\t\tpar->fbtftops.write = fbtft_write_gpio16_wr;\n\t}\n\n\t/* 9-bit SPI setup */\n\tif (par->spi && display->buswidth == 9) {\n\t\tpar->spi->bits_per_word = 9;\n\t\tret = par->spi->master->setup(par->spi);\n\t\tif (ret) {\n\t\t\tdev_warn(&par->spi->dev,\n\t\t\t\t\"9-bit SPI not available, emulating using 8-bit.\\n\");\n\t\t\tpar->spi->bits_per_word = 8;\n\t\t\tret = par->spi->master->setup(par->spi);\n\t\t\tif (ret)\n\t\t\t\tgoto out_release;\n\t\t\t/* allocate buffer with room for dc bits */\n\t\t\tpar->extra = devm_kzalloc(par->info->device,\n\t\t\t\tpar->txbuf.len + (par->txbuf.len / 8) + 8,\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!par->extra) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t\tpar->fbtftops.write = fbtft_write_spi_emulate_9;\n\t\t}\n\t}\n\n\tif (!par->fbtftops.verify_gpios)\n\t\tpar->fbtftops.verify_gpios = fbtft_verify_gpios;\n\n\t/* make sure we still use the driver provided functions */\n\tfbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);\n\n\t/* use init_sequence if provided */\n\tif (par->init_sequence)\n\t\tpar->fbtftops.init_display = fbtft_init_display;\n\n\t/* use platform_data provided functions above all */\n\tfbtft_merge_fbtftops(&par->fbtftops, &pdata->display.fbtftops);\n\n\tret = fbtft_register_framebuffer(info);\n\tif (ret < 0)\n\t\tgoto out_release;\n\n\treturn 0;\n\nout_release:\n\tfbtft_framebuffer_release(info);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_probe_common);\n\n/**\n * fbtft_remove_common() - Generic device remove() helper function\n * @dev: Device\n * @info: Framebuffer\n *\n * Unregisters and releases the framebuffer\n *\n * Return: 0 if successful, negative if error\n */\nint fbtft_remove_common(struct device *dev, struct fb_info *info)\n{\n\tstruct fbtft_par *par;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tpar = info->par;\n\tif (par)\n\t\tfbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par,\n\t\t\t\"%s()\\n\", __func__);\n\tfbtft_unregister_framebuffer(info);\n\tfbtft_framebuffer_release(info);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_remove_common);\n\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "fbtft-io.c",
          "type": "blob",
          "size": 9.5166015625,
          "content": "#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#ifdef CONFIG_ARCH_BCM2708\n#include <mach/platform.h>\n#endif\n#include \"fbtft.h\"\n\nint fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len)\n{\n\tstruct spi_transfer t = {\n\t\t.tx_buf = buf,\n\t\t.len = len,\n\t};\n\tstruct spi_message m;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\tif (!par->spi) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: par->spi is unexpectedly NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tspi_message_init(&m);\n\tif (par->txbuf.dma && buf == par->txbuf.buf) {\n\t\tt.tx_dma = par->txbuf.dma;\n\t\tm.is_dma_mapped = 1;\n\t}\n\tspi_message_add_tail(&t, &m);\n\treturn spi_sync(par->spi, &m);\n}\nEXPORT_SYMBOL(fbtft_write_spi);\n\n/**\n * fbtft_write_spi_emulate_9() - write SPI emulating 9-bit\n * @par: Driver data\n * @buf: Buffer to write\n * @len: Length of buffer (must be divisible by 8)\n *\n * When 9-bit SPI is not available, this function can be used to emulate that.\n * par->extra must hold a transformation buffer used for transfer.\n */\nint fbtft_write_spi_emulate_9(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu16 *src = buf;\n\tu8 *dst = par->extra;\n\tsize_t size = len / 2;\n\tsize_t added = 0;\n\tint bits, i, j;\n\tu64 val, dc, tmp;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\tif (!par->extra) {\n\t\tdev_err(par->info->device, \"%s: error: par->extra is NULL\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tif ((len % 8) != 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: error: len=%d must be divisible by 8\\n\",\n\t\t\t__func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i += 8) {\n\t\ttmp = 0;\n\t\tbits = 63;\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tdc = (*src & 0x0100) ? 1 : 0;\n\t\t\tval = *src & 0x00FF;\n\t\t\ttmp |= dc << bits;\n\t\t\tbits -= 8;\n\t\t\ttmp |= val << bits--;\n\t\t\tsrc++;\n\t\t}\n\t\ttmp |= ((*src & 0x0100) ? 1 : 0);\n\t\t*(u64 *)dst = cpu_to_be64(tmp);\n\t\tdst += 8;\n\t\t*dst++ = (u8)(*src++ & 0x00FF);\n\t\tadded++;\n\t}\n\n\treturn spi_write(par->spi, par->extra, size + added);\n}\nEXPORT_SYMBOL(fbtft_write_spi_emulate_9);\n\nint fbtft_read_spi(struct fbtft_par *par, void *buf, size_t len)\n{\n\tint ret;\n\tu8 txbuf[32] = { 0, };\n\tstruct spi_transfer\tt = {\n\t\t\t.speed_hz = 2000000,\n\t\t\t.rx_buf\t\t= buf,\n\t\t\t.len\t\t= len,\n\t\t};\n\tstruct spi_message\tm;\n\n\tif (!par->spi) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: par->spi is unexpectedly NULL\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (par->startbyte) {\n\t\tif (len > 32) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"%s: len=%d can't be larger than 32 when using 'startbyte'\\n\",\n\t\t\t\t__func__, len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttxbuf[0] = par->startbyte | 0x3;\n\t\tt.tx_buf = txbuf;\n\t\tfbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8,\n\t\t\ttxbuf, len, \"%s(len=%d) txbuf => \", __func__, len);\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\tret = spi_sync(par->spi, &m);\n\tfbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d) buf <= \", __func__, len);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_read_spi);\n\n\n#ifdef CONFIG_ARCH_BCM2708\n\n/*\n *  Raspberry Pi\n *  -  writing directly to the registers is 40-50% faster than\n *     optimized use of gpiolib\n */\n\n#define GPIOSET(no, ishigh)           \\\ndo {                                  \\\n\tif (ishigh)                   \\\n\t\tset |= (1 << (no));   \\\n\telse                          \\\n\t\treset |= (1 << (no)); \\\n} while (0)\n\nint fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len)\n{\n\tunsigned int set = 0;\n\tunsigned int reset = 0;\n\tu8 data;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\twhile (len--) {\n\t\tdata = *(u8 *) buf;\n\t\tbuf++;\n\n\t\t/* Set data */\n\t\tGPIOSET(par->gpio.db[0], (data&0x01));\n\t\tGPIOSET(par->gpio.db[1], (data&0x02));\n\t\tGPIOSET(par->gpio.db[2], (data&0x04));\n\t\tGPIOSET(par->gpio.db[3], (data&0x08));\n\t\tGPIOSET(par->gpio.db[4], (data&0x10));\n\t\tGPIOSET(par->gpio.db[5], (data&0x20));\n\t\tGPIOSET(par->gpio.db[6], (data&0x40));\n\t\tGPIOSET(par->gpio.db[7], (data&0x80));\n\t\twritel(set, __io_address(GPIO_BASE+0x1C));\n\t\twritel(reset, __io_address(GPIO_BASE+0x28));\n\n\t\t/* Pulse /WR low */\n\t\twritel((1<<par->gpio.wr),  __io_address(GPIO_BASE+0x28));\n\t\twritel(0,  __io_address(GPIO_BASE+0x28)); /* used as a delay */\n\t\twritel((1<<par->gpio.wr),  __io_address(GPIO_BASE+0x1C));\n\n\t\tset = 0;\n\t\treset = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio8_wr);\n\nint fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len)\n{\n\tunsigned int set = 0;\n\tunsigned int reset = 0;\n\tu16 data;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\twhile (len) {\n\t\tlen -= 2;\n\t\tdata = *(u16 *) buf;\n\t\tbuf += 2;\n\n\t\t/* Start writing by pulling down /WR */\n\t\tgpio_set_value(par->gpio.wr, 0);\n\n\t\t/* Set data */\n\t\tGPIOSET(par->gpio.db[0],  (data&0x0001));\n\t\tGPIOSET(par->gpio.db[1],  (data&0x0002));\n\t\tGPIOSET(par->gpio.db[2],  (data&0x0004));\n\t\tGPIOSET(par->gpio.db[3],  (data&0x0008));\n\t\tGPIOSET(par->gpio.db[4],  (data&0x0010));\n\t\tGPIOSET(par->gpio.db[5],  (data&0x0020));\n\t\tGPIOSET(par->gpio.db[6],  (data&0x0040));\n\t\tGPIOSET(par->gpio.db[7],  (data&0x0080));\n\n\t\tGPIOSET(par->gpio.db[8],  (data&0x0100));\n\t\tGPIOSET(par->gpio.db[9],  (data&0x0200));\n\t\tGPIOSET(par->gpio.db[10], (data&0x0400));\n\t\tGPIOSET(par->gpio.db[11], (data&0x0800));\n\t\tGPIOSET(par->gpio.db[12], (data&0x1000));\n\t\tGPIOSET(par->gpio.db[13], (data&0x2000));\n\t\tGPIOSET(par->gpio.db[14], (data&0x4000));\n\t\tGPIOSET(par->gpio.db[15], (data&0x8000));\n\n\t\twritel(set, __io_address(GPIO_BASE+0x1C));\n\t\twritel(reset, __io_address(GPIO_BASE+0x28));\n\n\t\t/* Pullup /WR */\n\t\tgpio_set_value(par->gpio.wr, 1);\n\n\t\tset = 0;\n\t\treset = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio16_wr);\n\nint fbtft_write_gpio16_wr_latched(struct fbtft_par *par, void *buf, size_t len)\n{\n\tunsigned int set = 0;\n\tunsigned int reset = 0;\n\tu16 data;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\twhile (len) {\n\t\tlen -= 2;\n\t\tdata = *(u16 *) buf;\n\t\tbuf += 2;\n\n\t\t/* Start writing by pulling down /WR */\n\t\tgpio_set_value(par->gpio.wr, 0);\n\n\t\t/* Low byte */\n\t\tGPIOSET(par->gpio.db[0],  (data&0x0001));\n\t\tGPIOSET(par->gpio.db[1],  (data&0x0002));\n\t\tGPIOSET(par->gpio.db[2],  (data&0x0004));\n\t\tGPIOSET(par->gpio.db[3],  (data&0x0008));\n\t\tGPIOSET(par->gpio.db[4],  (data&0x0010));\n\t\tGPIOSET(par->gpio.db[5],  (data&0x0020));\n\t\tGPIOSET(par->gpio.db[6],  (data&0x0040));\n\t\tGPIOSET(par->gpio.db[7],  (data&0x0080));\n\t\twritel(set, __io_address(GPIO_BASE+0x1C));\n\t\twritel(reset, __io_address(GPIO_BASE+0x28));\n\n\t\t/* Pulse 'latch' high */\n\t\tgpio_set_value(par->gpio.latch, 1);\n\t\tgpio_set_value(par->gpio.latch, 0);\n\n\t\t/* High byte */\n\t\tGPIOSET(par->gpio.db[0], (data&0x0100));\n\t\tGPIOSET(par->gpio.db[1], (data&0x0200));\n\t\tGPIOSET(par->gpio.db[2], (data&0x0400));\n\t\tGPIOSET(par->gpio.db[3], (data&0x0800));\n\t\tGPIOSET(par->gpio.db[4], (data&0x1000));\n\t\tGPIOSET(par->gpio.db[5], (data&0x2000));\n\t\tGPIOSET(par->gpio.db[6], (data&0x4000));\n\t\tGPIOSET(par->gpio.db[7], (data&0x8000));\n\t\twritel(set, __io_address(GPIO_BASE+0x1C));\n\t\twritel(reset, __io_address(GPIO_BASE+0x28));\n\n\t\t/* Pullup /WR */\n\t\tgpio_set_value(par->gpio.wr, 1);\n\n\t\tset = 0;\n\t\treset = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio16_wr_latched);\n\n#undef GPIOSET\n\n#else\n\n/*\n * Optimized use of gpiolib is twice as fast as no optimization\n * only one driver can use the optimized version at a time\n */\nint fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu8 data;\n\tint i;\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\tstatic u8 prev_data;\n#endif\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\twhile (len--) {\n\t\tdata = *(u8 *) buf;\n\n\t\t/* Start writing by pulling down /WR */\n\t\tgpio_set_value(par->gpio.wr, 0);\n\n\t\t/* Set data */\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tif (data == prev_data) {\n\t\t\tgpio_set_value(par->gpio.wr, 0); /* used as delay */\n\t\t} else {\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif ((data & 1) != (prev_data & 1))\n\t\t\t\t\tgpio_set_value(par->gpio.db[i],\n\t\t\t\t\t\t\t\t(data & 1));\n\t\t\t\tdata >>= 1;\n\t\t\t\tprev_data >>= 1;\n\t\t\t}\n\t\t}\n#else\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tgpio_set_value(par->gpio.db[i], (data & 1));\n\t\t\tdata >>= 1;\n\t\t}\n#endif\n\n\t\t/* Pullup /WR */\n\t\tgpio_set_value(par->gpio.wr, 1);\n\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tprev_data = *(u8 *) buf;\n#endif\n\t\tbuf++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio8_wr);\n\nint fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu16 data;\n\tint i;\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\tstatic u16 prev_data;\n#endif\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\twhile (len) {\n\t\tdata = *(u16 *) buf;\n\n\t\t/* Start writing by pulling down /WR */\n\t\tgpio_set_value(par->gpio.wr, 0);\n\n\t\t/* Set data */\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tif (data == prev_data) {\n\t\t\tgpio_set_value(par->gpio.wr, 0); /* used as delay */\n\t\t} else {\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tif ((data & 1) != (prev_data & 1))\n\t\t\t\t\tgpio_set_value(par->gpio.db[i],\n\t\t\t\t\t\t\t\t(data & 1));\n\t\t\t\tdata >>= 1;\n\t\t\t\tprev_data >>= 1;\n\t\t\t}\n\t\t}\n#else\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tgpio_set_value(par->gpio.db[i], (data & 1));\n\t\t\tdata >>= 1;\n\t\t}\n#endif\n\n\t\t/* Pullup /WR */\n\t\tgpio_set_value(par->gpio.wr, 1);\n\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tprev_data = *(u16 *) buf;\n#endif\n\t\tbuf += 2;\n\t\tlen -= 2;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio16_wr);\n\nint fbtft_write_gpio16_wr_latched(struct fbtft_par *par, void *buf, size_t len)\n{\n\tdev_err(par->info->device, \"%s: function not implemented\\n\", __func__);\n\treturn -1;\n}\nEXPORT_SYMBOL(fbtft_write_gpio16_wr_latched);\n\n#endif /* CONFIG_ARCH_BCM2708 */\n"
        },
        {
          "name": "fbtft-sysfs.c",
          "type": "blob",
          "size": 4.7236328125,
          "content": "#include \"fbtft.h\"\n\n\nstatic int get_next_ulong(char **str_p, unsigned long *val, char *sep, int base)\n{\n\tchar *p_val;\n\tint ret;\n\n\tif (!str_p || !(*str_p))\n\t\treturn -EINVAL;\n\n\tp_val = strsep(str_p, sep);\n\n\tif (!p_val)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(p_val, base, val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint fbtft_gamma_parse_str(struct fbtft_par *par, unsigned long *curves,\n\t\t\t\t\t\tconst char *str, int size)\n{\n\tchar *str_p, *curve_p = NULL;\n\tchar *tmp;\n\tunsigned long val = 0;\n\tint ret = 0;\n\tint curve_counter, value_counter;\n\n\tfbtft_par_dbg(DEBUG_SYSFS, par, \"%s() str=\\n\", __func__);\n\n\tif (!str || !curves)\n\t\treturn -EINVAL;\n\n\tfbtft_par_dbg(DEBUG_SYSFS, par, \"%s\\n\", str);\n\n\ttmp = kmalloc(size+1, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\tmemcpy(tmp, str, size+1);\n\n\t/* replace optional separators */\n\tstr_p = tmp;\n\twhile (*str_p) {\n\t\tif (*str_p == ',')\n\t\t\t*str_p = ' ';\n\t\tif (*str_p == ';')\n\t\t\t*str_p = '\\n';\n\t\tstr_p++;\n\t}\n\n\tstr_p = strim(tmp);\n\n\tcurve_counter = 0;\n\twhile (str_p) {\n\t\tif (curve_counter == par->gamma.num_curves) {\n\t\t\tdev_err(par->info->device, \"Gamma: Too many curves\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcurve_p = strsep(&str_p, \"\\n\");\n\t\tvalue_counter = 0;\n\t\twhile (curve_p) {\n\t\t\tif (value_counter == par->gamma.num_values) {\n\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"Gamma: Too many values\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = get_next_ulong(&curve_p, &val, \" \", 16);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcurves[curve_counter * par->gamma.num_values + value_counter] = val;\n\t\t\tvalue_counter++;\n\t\t}\n\t\tif (value_counter != par->gamma.num_values) {\n\t\t\tdev_err(par->info->device, \"Gamma: Too few values\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcurve_counter++;\n\t}\n\tif (curve_counter != par->gamma.num_curves) {\n\t\tdev_err(par->info->device, \"Gamma: Too few curves\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic ssize_t\nsprintf_gamma(struct fbtft_par *par, unsigned long *curves, char *buf)\n{\n\tssize_t len = 0;\n\tunsigned int i, j;\n\n\tmutex_lock(&par->gamma.lock);\n\tfor (i = 0; i < par->gamma.num_curves; i++) {\n\t\tfor (j = 0; j < par->gamma.num_values; j++)\n\t\t\tlen += scnprintf(&buf[len], PAGE_SIZE,\n\t\t\t\t\"%04lx \", curves[i*par->gamma.num_values + j]);\n\t\tbuf[len-1] = '\\n';\n\t}\n\tmutex_unlock(&par->gamma.lock);\n\n\treturn len;\n}\n\nstatic ssize_t store_gamma_curve(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\tunsigned long tmp_curves[FBTFT_GAMMA_MAX_VALUES_TOTAL];\n\tint ret;\n\n\tret = fbtft_gamma_parse_str(par, tmp_curves, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = par->fbtftops.set_gamma(par, tmp_curves);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&par->gamma.lock);\n\tmemcpy(par->gamma.curves, tmp_curves,\n\t\tpar->gamma.num_curves * par->gamma.num_values * sizeof(tmp_curves[0]));\n\tmutex_unlock(&par->gamma.lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_gamma_curve(struct device *device,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\n\treturn sprintf_gamma(par, par->gamma.curves, buf);\n}\n\nstatic struct device_attribute gamma_device_attrs[] = {\n\t__ATTR(gamma, 0660, show_gamma_curve, store_gamma_curve),\n};\n\n\nvoid fbtft_expand_debug_value(unsigned long *debug)\n{\n\tswitch (*debug & 0b111) {\n\tcase 1:\n\t\t*debug |= DEBUG_LEVEL_1;\n\t\tbreak;\n\tcase 2:\n\t\t*debug |= DEBUG_LEVEL_2;\n\t\tbreak;\n\tcase 3:\n\t\t*debug |= DEBUG_LEVEL_3;\n\t\tbreak;\n\tcase 4:\n\t\t*debug |= DEBUG_LEVEL_4;\n\t\tbreak;\n\tcase 5:\n\t\t*debug |= DEBUG_LEVEL_5;\n\t\tbreak;\n\tcase 6:\n\t\t*debug |= DEBUG_LEVEL_6;\n\t\tbreak;\n\tcase 7:\n\t\t*debug = 0xFFFFFFFF;\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t store_debug(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &par->debug);\n\tif (ret)\n\t\treturn ret;\n\tfbtft_expand_debug_value(&par->debug);\n\n\treturn count;\n}\n\nstatic ssize_t show_debug(struct device *device,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%lu\\n\", par->debug);\n}\n\nstatic struct device_attribute debug_device_attr = \\\n\t__ATTR(debug, 0660, show_debug, store_debug);\n\n\nvoid fbtft_sysfs_init(struct fbtft_par *par)\n{\n\tdevice_create_file(par->info->dev, &debug_device_attr);\n\tif (par->gamma.curves && par->fbtftops.set_gamma)\n\t\tdevice_create_file(par->info->dev, &gamma_device_attrs[0]);\n}\n\nvoid fbtft_sysfs_exit(struct fbtft_par *par)\n{\n\tdevice_remove_file(par->info->dev, &debug_device_attr);\n\tif (par->gamma.curves && par->fbtftops.set_gamma)\n\t\tdevice_remove_file(par->info->dev, &gamma_device_attrs[0]);\n}\n"
        },
        {
          "name": "fbtft.h",
          "type": "blob",
          "size": 17.2607421875,
          "content": "/*\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#ifndef __LINUX_FBTFT_H\n#define __LINUX_FBTFT_H\n\n#include <linux/fb.h>\n#include <linux/spinlock.h>\n#include <linux/spi/spi.h>\n#include <linux/platform_device.h>\n\n\n#define FBTFT_NOP\t\t0x00\n#define FBTFT_SWRESET\t0x01\n#define FBTFT_RDDID\t\t0x04\n#define FBTFT_RDDST\t\t0x09\n#define FBTFT_CASET\t\t0x2A\n#define FBTFT_RASET\t\t0x2B\n#define FBTFT_RAMWR\t\t0x2C\n\n#define FBTFT_ONBOARD_BACKLIGHT 2\n\n#define FBTFT_GPIO_NO_MATCH\t\t0xFFFF\n#define FBTFT_GPIO_NAME_SIZE\t32\n#define FBTFT_MAX_INIT_SEQUENCE      512\n#define FBTFT_GAMMA_MAX_VALUES_TOTAL 128\n\n#define FBTFT_OF_INIT_CMD\tBIT(24)\n#define FBTFT_OF_INIT_DELAY\tBIT(25)\n\n/**\n * struct fbtft_gpio - Structure that holds one pinname to gpio mapping\n * @name: pinname (reset, dc, etc.)\n * @gpio: GPIO number\n *\n */\nstruct fbtft_gpio {\n\tchar name[FBTFT_GPIO_NAME_SIZE];\n\tunsigned gpio;\n};\n\nstruct fbtft_par;\n\n/**\n * struct fbtft_ops - FBTFT operations structure\n * @write: Writes to interface bus\n * @read: Reads from interface bus\n * @write_vmem: Writes video memory to display\n * @write_reg: Writes to controller register\n * @set_addr_win: Set the GRAM update window\n * @reset: Reset the LCD controller\n * @mkdirty: Marks display lines for update\n * @update_display: Updates the display\n * @init_display: Initializes the display\n * @blank: Blank the display (optional)\n * @request_gpios_match: Do pinname to gpio matching\n * @request_gpios: Request gpios from the kernel\n * @free_gpios: Free previously requested gpios\n * @verify_gpios: Verify that necessary gpios is present (optional)\n * @register_backlight: Used to register backlight device (optional)\n * @unregister_backlight: Unregister backlight device (optional)\n * @set_var: Configure LCD with values from variables like @rotate and @bgr\n *           (optional)\n * @set_gamma: Set Gamma curve (optional)\n *\n * Most of these operations have default functions assigned to them in\n *     fbtft_framebuffer_alloc()\n */\nstruct fbtft_ops {\n\tint (*write)(struct fbtft_par *par, void *buf, size_t len);\n\tint (*read)(struct fbtft_par *par, void *buf, size_t len);\n\tint (*write_vmem)(struct fbtft_par *par, size_t offset, size_t len);\n\tvoid (*write_register)(struct fbtft_par *par, int len, ...);\n\n\tvoid (*set_addr_win)(struct fbtft_par *par,\n\t\tint xs, int ys, int xe, int ye);\n\tvoid (*reset)(struct fbtft_par *par);\n\tvoid (*mkdirty)(struct fb_info *info, int from, int to);\n\tvoid (*update_display)(struct fbtft_par *par,\n\t\t\t\tunsigned start_line, unsigned end_line);\n\tint (*init_display)(struct fbtft_par *par);\n\tint (*blank)(struct fbtft_par *par, bool on);\n\n\tunsigned long (*request_gpios_match)(struct fbtft_par *par,\n\t\tconst struct fbtft_gpio *gpio);\n\tint (*request_gpios)(struct fbtft_par *par);\n\tint (*verify_gpios)(struct fbtft_par *par);\n\n\tvoid (*register_backlight)(struct fbtft_par *par);\n\tvoid (*unregister_backlight)(struct fbtft_par *par);\n\n\tint (*set_var)(struct fbtft_par *par);\n\tint (*set_gamma)(struct fbtft_par *par, unsigned long *curves);\n};\n\n/**\n * struct fbtft_display - Describes the display properties\n * @width: Width of display in pixels\n * @height: Height of display in pixels\n * @regwidth: LCD Controller Register width in bits\n * @buswidth: Display interface bus width in bits\n * @backlight: Backlight type.\n * @fbtftops: FBTFT operations provided by driver or device (platform_data)\n * @bpp: Bits per pixel\n * @fps: Frames per second\n * @txbuflen: Size of transmit buffer\n * @init_sequence: Pointer to LCD initialization array\n * @gamma: String representation of Gamma curve(s)\n * @gamma_num: Number of Gamma curves\n * @gamma_len: Number of values per Gamma curve\n * @debug: Initial debug value\n *\n * This structure is not stored by FBTFT except for init_sequence.\n */\nstruct fbtft_display {\n\tunsigned width;\n\tunsigned height;\n\tunsigned regwidth;\n\tunsigned buswidth;\n\tunsigned backlight;\n\tstruct fbtft_ops fbtftops;\n\tunsigned bpp;\n\tunsigned fps;\n\tint txbuflen;\n\tint *init_sequence;\n\tchar *gamma;\n\tint gamma_num;\n\tint gamma_len;\n\tunsigned long debug;\n};\n\n/**\n * struct fbtft_platform_data - Passes display specific data to the driver\n * @display: Display properties\n * @gpios: Pointer to an array of piname to gpio mappings\n * @rotate: Display rotation angle\n * @bgr: LCD Controller BGR bit\n * @fps: Frames per second (this will go away, use @fps in @fbtft_display)\n * @txbuflen: Size of transmit buffer\n * @startbyte: When set, enables use of Startbyte in transfers\n * @gamma: String representation of Gamma curve(s)\n * @extra: A way to pass extra info\n */\nstruct fbtft_platform_data {\n\tstruct fbtft_display display;\n\tconst struct fbtft_gpio *gpios;\n\tunsigned rotate;\n\tbool bgr;\n\tunsigned fps;\n\tint txbuflen;\n\tu8 startbyte;\n\tchar *gamma;\n\tvoid *extra;\n};\n\n/**\n * struct fbtft_par - Main FBTFT data structure\n *\n * This structure holds all relevant data to operate the display\n *\n * See sourcefile for documentation since nested structs is not\n * supported by kernel-doc.\n *\n */\n/* @spi: Set if it is a SPI device\n * @pdev: Set if it is a platform device\n * @info: Pointer to framebuffer fb_info structure\n * @pdata: Pointer to platform data\n * @ssbuf: Not used\n * @pseudo_palette: Used by fb_set_colreg()\n * @txbuf.buf: Transmit buffer\n * @txbuf.len: Transmit buffer length\n * @buf: Small buffer used when writing init data over SPI\n * @startbyte: Used by some controllers when in SPI mode.\n *             Format: 6 bit Device id + RS bit + RW bit\n * @fbtftops: FBTFT operations provided by driver or device (platform_data)\n * @dirty_lock: Protects dirty_lines_start and dirty_lines_end\n * @dirty_lines_start: Where to begin updating display\n * @dirty_lines_end: Where to end updating display\n * @gpio.reset: GPIO used to reset display\n * @gpio.dc: Data/Command signal, also known as RS\n * @gpio.rd: Read latching signal\n * @gpio.wr: Write latching signal\n * @gpio.latch: Bus latch signal, eg. 16->8 bit bus latch\n * @gpio.cs: LCD Chip Select with parallel interface bus\n * @gpio.db[16]: Parallel databus\n * @gpio.led[16]: Led control signals\n * @gpio.aux[16]: Auxillary signals, not used by core\n * @init_sequence: Pointer to LCD initialization array\n * @gamma.lock: Mutex for Gamma curve locking\n * @gamma.curves: Pointer to Gamma curve array\n * @gamma.num_values: Number of values per Gamma curve\n * @gamma.num_curves: Number of Gamma curves\n * @debug: Pointer to debug value\n * @current_debug:\n * @first_update_done: Used to only time the first display update\n * @update_time: Used to calculate 'fps' in debug output\n * @bgr: BGR mode/\\n\n * @extra: Extra info needed by driver\n */\nstruct fbtft_par {\n\tstruct spi_device *spi;\n\tstruct platform_device *pdev;\n\tstruct fb_info *info;\n\tstruct fbtft_platform_data *pdata;\n\tu16 *ssbuf;\n\tu32 pseudo_palette[16];\n\tstruct {\n\t\tvoid *buf;\n\t\tdma_addr_t dma;\n\t\tsize_t len;\n\t} txbuf;\n\tu8 *buf;\n\tu8 startbyte;\n\tstruct fbtft_ops fbtftops;\n\tspinlock_t dirty_lock;\n\tunsigned dirty_lines_start;\n\tunsigned dirty_lines_end;\n\tstruct {\n\t\tint reset;\n\t\tint dc;\n\t\tint rd;\n\t\tint wr;\n\t\tint latch;\n\t\tint cs;\n\t\tint db[16];\n\t\tint led[16];\n\t\tint aux[16];\n\t} gpio;\n\tint *init_sequence;\n\tstruct {\n\t\tstruct mutex lock;\n\t\tunsigned long *curves;\n\t\tint num_values;\n\t\tint num_curves;\n\t} gamma;\n\tunsigned long debug;\n\tbool first_update_done;\n\tstruct timespec update_time;\n\tbool bgr;\n\tvoid *extra;\n};\n\n#define NUMARGS(...)  (sizeof((int[]){__VA_ARGS__})/sizeof(int))\n\n#define write_reg(par, ...)                                              \\\ndo {                                                                     \\\n\tpar->fbtftops.write_register(par, NUMARGS(__VA_ARGS__), __VA_ARGS__); \\\n} while (0)\n\n/* fbtft-core.c */\nextern void fbtft_dbg_hex(const struct device *dev,\n\tint groupsize, void *buf, size_t len, const char *fmt, ...);\nextern struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,\n\tstruct device *dev);\nextern void fbtft_framebuffer_release(struct fb_info *info);\nextern int fbtft_register_framebuffer(struct fb_info *fb_info);\nextern int fbtft_unregister_framebuffer(struct fb_info *fb_info);\nextern void fbtft_register_backlight(struct fbtft_par *par);\nextern void fbtft_unregister_backlight(struct fbtft_par *par);\nextern int fbtft_init_display(struct fbtft_par *par);\nextern int fbtft_probe_common(struct fbtft_display *display,\n\tstruct spi_device *sdev, struct platform_device *pdev);\nextern int fbtft_remove_common(struct device *dev, struct fb_info *info);\n\n/* fbtft-io.c */\nextern int fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len);\nextern int fbtft_write_spi_emulate_9(struct fbtft_par *par,\n\tvoid *buf, size_t len);\nextern int fbtft_read_spi(struct fbtft_par *par, void *buf, size_t len);\nextern int fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len);\nextern int fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len);\nextern int fbtft_write_gpio16_wr_latched(struct fbtft_par *par,\n\tvoid *buf, size_t len);\n\n/* fbtft-bus.c */\nextern int fbtft_write_vmem8_bus8(struct fbtft_par *par, size_t offset, size_t len);\nextern int fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len);\nextern int fbtft_write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len);\nextern int fbtft_write_vmem16_bus9(struct fbtft_par *par, size_t offset, size_t len);\nextern void fbtft_write_reg8_bus8(struct fbtft_par *par, int len, ...);\nextern void fbtft_write_reg8_bus9(struct fbtft_par *par, int len, ...);\nextern void fbtft_write_reg16_bus8(struct fbtft_par *par, int len, ...);\nextern void fbtft_write_reg16_bus16(struct fbtft_par *par, int len, ...);\n\n\n#define FBTFT_REGISTER_DRIVER(_name, _compatible, _display)                \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic int fbtft_driver_probe_spi(struct spi_device *spi)                  \\\n{                                                                          \\\n\treturn fbtft_probe_common(_display, spi, NULL);                    \\\n}                                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic int fbtft_driver_remove_spi(struct spi_device *spi)                 \\\n{                                                                          \\\n\tstruct fb_info *info = spi_get_drvdata(spi);                       \\\n\t\t\t\t\t\t\t\t\t   \\\n\treturn fbtft_remove_common(&spi->dev, info);                       \\\n}                                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic int fbtft_driver_probe_pdev(struct platform_device *pdev)           \\\n{                                                                          \\\n\treturn fbtft_probe_common(_display, NULL, pdev);                   \\\n}                                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic int fbtft_driver_remove_pdev(struct platform_device *pdev)          \\\n{                                                                          \\\n\tstruct fb_info *info = platform_get_drvdata(pdev);                 \\\n\t\t\t\t\t\t\t\t\t   \\\n\treturn fbtft_remove_common(&pdev->dev, info);                      \\\n}                                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic const struct of_device_id dt_ids[] = {                              \\\n        { .compatible = _compatible },                                     \\\n        {},                                                                \\\n};                                                                         \\\n\t\t\t\t\t\t\t\t\t   \\\nMODULE_DEVICE_TABLE(of, dt_ids);                                           \\\n\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic struct spi_driver fbtft_driver_spi_driver = {                       \\\n\t.driver = {                                                        \\\n\t\t.name   = _name,                                           \\\n\t\t.owner  = THIS_MODULE,                                     \\\n                .of_match_table = of_match_ptr(dt_ids),                    \\\n\t},                                                                 \\\n\t.probe  = fbtft_driver_probe_spi,                                  \\\n\t.remove = fbtft_driver_remove_spi,                                 \\\n};                                                                         \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic struct platform_driver fbtft_driver_platform_driver = {             \\\n\t.driver = {                                                        \\\n\t\t.name   = _name,                                           \\\n\t\t.owner  = THIS_MODULE,                                     \\\n                .of_match_table = of_match_ptr(dt_ids),                    \\\n\t},                                                                 \\\n\t.probe  = fbtft_driver_probe_pdev,                                 \\\n\t.remove = fbtft_driver_remove_pdev,                                \\\n};                                                                         \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic int __init fbtft_driver_module_init(void)                           \\\n{                                                                          \\\n\tint ret;                                                           \\\n\t\t\t\t\t\t\t\t\t   \\\n\tret = spi_register_driver(&fbtft_driver_spi_driver);               \\\n\tif (ret < 0)                                                       \\\n\t\treturn ret;                                                \\\n\treturn platform_driver_register(&fbtft_driver_platform_driver);    \\\n}                                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic void __exit fbtft_driver_module_exit(void)                          \\\n{                                                                          \\\n\tspi_unregister_driver(&fbtft_driver_spi_driver);                   \\\n\tplatform_driver_unregister(&fbtft_driver_platform_driver);         \\\n}                                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\nmodule_init(fbtft_driver_module_init);                                     \\\nmodule_exit(fbtft_driver_module_exit);\n\n\n/* Debug macros */\n\n/* shorthand debug levels */\n#define DEBUG_LEVEL_1\tDEBUG_REQUEST_GPIOS\n#define DEBUG_LEVEL_2\t(DEBUG_LEVEL_1 | DEBUG_DRIVER_INIT_FUNCTIONS | DEBUG_TIME_FIRST_UPDATE)\n#define DEBUG_LEVEL_3\t(DEBUG_LEVEL_2 | DEBUG_RESET | DEBUG_INIT_DISPLAY | DEBUG_BLANK | DEBUG_REQUEST_GPIOS | DEBUG_FREE_GPIOS | DEBUG_VERIFY_GPIOS | DEBUG_BACKLIGHT | DEBUG_SYSFS)\n#define DEBUG_LEVEL_4\t(DEBUG_LEVEL_2 | DEBUG_FB_READ | DEBUG_FB_WRITE | DEBUG_FB_FILLRECT | DEBUG_FB_COPYAREA | DEBUG_FB_IMAGEBLIT | DEBUG_FB_BLANK)\n#define DEBUG_LEVEL_5\t(DEBUG_LEVEL_3 | DEBUG_UPDATE_DISPLAY)\n#define DEBUG_LEVEL_6\t(DEBUG_LEVEL_4 | DEBUG_LEVEL_5)\n#define DEBUG_LEVEL_7\t0xFFFFFFFF\n\n#define DEBUG_DRIVER_INIT_FUNCTIONS (1<<3)\n#define DEBUG_TIME_FIRST_UPDATE     (1<<4)\n#define DEBUG_TIME_EACH_UPDATE      (1<<5)\n#define DEBUG_DEFERRED_IO           (1<<6)\n#define DEBUG_FBTFT_INIT_FUNCTIONS  (1<<7)\n\n/* fbops */\n#define DEBUG_FB_READ               (1<<8)\n#define DEBUG_FB_WRITE              (1<<9)\n#define DEBUG_FB_FILLRECT           (1<<10)\n#define DEBUG_FB_COPYAREA           (1<<11)\n#define DEBUG_FB_IMAGEBLIT          (1<<12)\n#define DEBUG_FB_SETCOLREG          (1<<13)\n#define DEBUG_FB_BLANK              (1<<14)\n\n#define DEBUG_SYSFS                 (1<<16)\n\n/* fbtftops */\n#define DEBUG_BACKLIGHT             (1<<17)\n#define DEBUG_READ                  (1<<18)\n#define DEBUG_WRITE                 (1<<19)\n#define DEBUG_WRITE_VMEM            (1<<20)\n#define DEBUG_WRITE_REGISTER        (1<<21)\n#define DEBUG_SET_ADDR_WIN          (1<<22)\n#define DEBUG_RESET                 (1<<23)\n#define DEBUG_MKDIRTY               (1<<24)\n#define DEBUG_UPDATE_DISPLAY        (1<<25)\n#define DEBUG_INIT_DISPLAY          (1<<26)\n#define DEBUG_BLANK                 (1<<27)\n#define DEBUG_REQUEST_GPIOS         (1<<28)\n#define DEBUG_FREE_GPIOS            (1<<29)\n#define DEBUG_REQUEST_GPIOS_MATCH   (1<<30)\n#define DEBUG_VERIFY_GPIOS          (1<<31)\n\n\n#define fbtft_init_dbg(dev, format, arg...)                  \\\ndo {                                                         \\\n\tif (unlikely((dev)->platform_data &&                 \\\n\t    (((struct fbtft_platform_data *)(dev)->platform_data)->display.debug & DEBUG_DRIVER_INIT_FUNCTIONS))) \\\n\t\tdev_info(dev, format, ##arg);                \\\n} while (0)\n\n#define fbtft_par_dbg(level, par, format, arg...)            \\\ndo {                                                         \\\n\tif (unlikely(par->debug & level))                    \\\n\t\tdev_info(par->info->device, format, ##arg);  \\\n} while (0)\n\n#define fbtft_dev_dbg(level, par, dev, format, arg...)       \\\ndo {                                                         \\\n\tif (unlikely(par->debug & level))                    \\\n\t\tdev_info(dev, format, ##arg);                \\\n} while (0)\n\n#define fbtft_par_dbg_hex(level, par, dev, type, buf, num, format, arg...) \\\ndo {                                                                       \\\n\tif (unlikely(par->debug & level))                                  \\\n\t\tfbtft_dbg_hex(dev, sizeof(type), buf, num * sizeof(type), format, ##arg); \\\n} while (0)\n\n#endif /* __LINUX_FBTFT_H */\n"
        },
        {
          "name": "fbtft_device.c",
          "type": "blob",
          "size": 33.064453125,
          "content": "/*\n *\n * Copyright (C) 2013, Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME \"fbtft_device\"\n\n#define MAX_GPIOS 32\n\nstruct spi_device *spi_device;\nstruct platform_device *p_device;\n\nstatic char *name;\nmodule_param(name, charp, 0);\nMODULE_PARM_DESC(name, \"Devicename (required). \" \\\n\"name=list => list all supported devices.\");\n\nstatic unsigned rotate;\nmodule_param(rotate, uint, 0);\nMODULE_PARM_DESC(rotate,\n\"Angle to rotate display counter clockwise: 0, 90, 180, 270\");\n\nstatic unsigned busnum;\nmodule_param(busnum, uint, 0);\nMODULE_PARM_DESC(busnum, \"SPI bus number (default=0)\");\n\nstatic unsigned cs;\nmodule_param(cs, uint, 0);\nMODULE_PARM_DESC(cs, \"SPI chip select (default=0)\");\n\nstatic unsigned speed;\nmodule_param(speed, uint, 0);\nMODULE_PARM_DESC(speed, \"SPI speed (override device default)\");\n\nstatic int mode = -1;\nmodule_param(mode, int, 0);\nMODULE_PARM_DESC(mode, \"SPI mode (override device default)\");\n\nstatic char *gpios;\nmodule_param(gpios, charp, 0);\nMODULE_PARM_DESC(gpios,\n\"List of gpios. Comma separated with the form: reset:23,dc:24 \" \\\n\"(when overriding the default, all gpios must be specified)\");\n\nstatic unsigned fps;\nmodule_param(fps, uint, 0);\nMODULE_PARM_DESC(fps, \"Frames per second (override driver default)\");\n\nstatic char *gamma;\nmodule_param(gamma, charp, 0);\nMODULE_PARM_DESC(gamma,\n\"String representation of Gamma Curve(s). Driver specific.\");\n\nstatic int txbuflen;\nmodule_param(txbuflen, int, 0);\nMODULE_PARM_DESC(txbuflen, \"txbuflen (override driver default)\");\n\nstatic int bgr = -1;\nmodule_param(bgr, int, 0);\nMODULE_PARM_DESC(bgr,\n\"BGR bit (supported by some drivers).\");\n\nstatic unsigned startbyte;\nmodule_param(startbyte, uint, 0);\nMODULE_PARM_DESC(startbyte, \"Sets the Start byte used by some SPI displays.\");\n\nstatic bool custom;\nmodule_param(custom, bool, 0);\nMODULE_PARM_DESC(custom, \"Add a custom display device. \" \\\n\"Use speed= argument to make it a SPI device, else platform_device\");\n\nstatic unsigned width;\nmodule_param(width, uint, 0);\nMODULE_PARM_DESC(width, \"Display width, used with the custom argument\");\n\nstatic unsigned height;\nmodule_param(height, uint, 0);\nMODULE_PARM_DESC(height, \"Display height, used with the custom argument\");\n\nstatic unsigned buswidth = 8;\nmodule_param(buswidth, uint, 0);\nMODULE_PARM_DESC(buswidth, \"Display bus width, used with the custom argument\");\n\nstatic int init[FBTFT_MAX_INIT_SEQUENCE];\nstatic int init_num;\nmodule_param_array(init, int, &init_num, 0);\nMODULE_PARM_DESC(init, \"Init sequence, used with the custom argument\");\n\nstatic unsigned long debug;\nmodule_param(debug, ulong , 0);\nMODULE_PARM_DESC(debug,\n\"level: 0-7 (the remaining 29 bits is for advanced usage)\");\n\nstatic unsigned verbose = 3;\nmodule_param(verbose, uint, 0);\nMODULE_PARM_DESC(verbose,\n\"0 silent, >0 show gpios, >1 show devices, >2 show devices before (default=3)\");\n\n\nstruct fbtft_device_display {\n\tchar *name;\n\tstruct spi_board_info *spi;\n\tstruct platform_device *pdev;\n};\n\nstatic void fbtft_device_pdev_release(struct device *dev);\n\nstatic int write_gpio16_wr_slow(struct fbtft_par *par, void *buf, size_t len);\nstatic void adafruit18_green_tab_set_addr_win(struct fbtft_par *par,\n\tint xs, int ys, int xe, int ye);\n\n#define ADAFRUIT18_GAMMA \\\n\t\t\"02 1c 07 12 37 32 29 2d 29 25 2B 39 00 01 03 10\\n\" \\\n\t\t\"03 1d 07 06 2E 2C 29 2D 2E 2E 37 3F 00 00 02 10\"\n\nstatic int hy28b_init_sequence[] = {\n\t-1,0x00e7,0x0010,-1,0x0000,0x0001,-1,0x0001,0x0100,-1,0x0002,0x0700,\n\t-1,0x0003,0x1030,-1,0x0004,0x0000,-1,0x0008,0x0207,-1,0x0009,0x0000,\n\t-1,0x000a,0x0000,-1,0x000c,0x0001,-1,0x000d,0x0000,-1,0x000f,0x0000,\n\t-1,0x0010,0x0000,-1,0x0011,0x0007,-1,0x0012,0x0000,-1,0x0013,0x0000,\n\t-2,50,-1,0x0010,0x1590,-1,0x0011,0x0227,-2,50,-1,0x0012,0x009c,-2,50,\n\t-1,0x0013,0x1900,-1,0x0029,0x0023,-1,0x002b,0x000e,-2,50,\n\t-1,0x0020,0x0000,-1,0x0021,0x0000,-2,50,-1,0x0050,0x0000,\n\t-1,0x0051,0x00ef,-1,0x0052,0x0000,-1,0x0053,0x013f,-1,0x0060,0xa700,\n\t-1,0x0061,0x0001,-1,0x006a,0x0000,-1,0x0080,0x0000,-1,0x0081,0x0000,\n\t-1,0x0082,0x0000,-1,0x0083,0x0000,-1,0x0084,0x0000,-1,0x0085,0x0000,\n\t-1,0x0090,0x0010,-1,0x0092,0x0000,-1,0x0093,0x0003,-1,0x0095,0x0110,\n\t-1,0x0097,0x0000,-1,0x0098,0x0000,-1,0x0007,0x0133,-1,0x0020,0x0000,\n\t-1,0x0021,0x0000,-2,100,-3 };\n\n#define HY28B_GAMMA \\\n\t\"04 1F 4 7 7 0 7 7 6 0\\n\" \\\n\t\"0F 00 1 7 4 0 0 0 6 7\"\n\nstatic int pitft_init_sequence[] = {\n\t-1,0x01,-2,5,-1,0x28,-1,0xEF,0x03,0x80,0x02,-1,0xCF,0x00,0xC1,0x30,\n\t-1,0xED,0x64,0x03,0x12,0x81,-1,0xE8,0x85,0x00,0x78,\n\t-1,0xCB,0x39,0x2C,0x00,0x34,0x02,-1,0xF7,0x20,-1,0xEA,0x00,0x00,\n\t-1,0xC0,0x23,-1,0xC1,0x10,-1,0xC5,0x3e,0x28,-1,0xC7,0x86,-1,0x3A,0x55,\n\t-1,0xB1,0x00,0x18,-1,0xB6,0x08,0x82,0x27,-1,0xF2,0x00,-1,0x26,0x01,\n\t-1,0xE0,0x0F,0x31,0x2B,0x0C,0x0E,0x08,0x4E,0xF1,0x37,0x07,0x10,0x03,\n\t0x0E,0x09,0x00,-1,0xE1,0x00,0x0E,0x14,0x03,0x11,0x07,0x31,0xC1,0x48,\n\t0x08,0x0F,0x0C,0x31,0x36,0x0F,-1,0x11,-2,100,-1,0x29,-2,20,-3 };\n\nstatic int waveshare32b_init_sequence[] = {\n\t-1,0xCB,0x39,0x2C,0x00,0x34,0x02,-1,0xCF,0x00,0xC1,0x30,\n\t-1,0xE8,0x85,0x00,0x78,-1,0xEA,0x00,0x00,-1,0xED,0x64,0x03,0x12,0x81,\n\t-1,0xF7,0x20,-1,0xC0,0x23,-1,0xC1,0x10,-1,0xC5,0x3e,0x28,-1,0xC7,0x86,\n\t-1,0x36,0x28,-1,0x3A,0x55,-1,0xB1,0x00,0x18,-1,0xB6,0x08,0x82,0x27,\n\t-1,0xF2,0x00,-1,0x26,0x01,\n\t-1,0xE0,0x0F,0x31,0x2B,0x0C,0x0E,0x08,0x4E,0xF1,0x37,0x07,0x10,0x03,0x0E,0x09,0x00,\n\t-1,0xE1,0x00,0x0E,0x14,0x03,0x11,0x07,0x31,0xC1,0x48,0x08,0x0F,0x0C,0x31,0x36,0x0F,\n\t-1,0x11,-2,120,-1,0x29,-1,0x2c,-3 };\n\n/* Supported displays in alphabetical order */\nstatic struct fbtft_device_display displays[] = {\n\t{\n\t\t.name = \"adafruit18\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_st7735r\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t\t.gamma = ADAFRUIT18_GAMMA,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"adafruit18_green\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_st7735r\",\n\t\t\t.max_speed_hz = 4000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.fbtftops.set_addr_win = \\\n\t\t\t\t\t    adafruit18_green_tab_set_addr_win,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t\t.gamma = ADAFRUIT18_GAMMA,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"adafruit22\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_hx8340bn\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 9,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"led\", 23 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"adafruit22a\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9340\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"adafruit28\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9341\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"adafruit13m\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ssd1306\",\n\t\t\t.max_speed_hz = 16000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"agm1264k-fl\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"fb_agm1264k-fl\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = FBTFT_ONBOARD_BACKLIGHT,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"dogs102\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_uc1701\",\n\t\t\t.max_speed_hz = 8000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 13 },\n\t\t\t\t\t{ \"dc\", 6 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"er_tftm050_2\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ra8875\",\n\t\t\t.max_speed_hz = 5000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.width = 480,\n\t\t\t\t\t.height = 272,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"er_tftm070_5\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ra8875\",\n\t\t\t.max_speed_hz = 5000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.width = 800,\n\t\t\t\t\t.height = 480,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"flexfb\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"flexfb\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"flexpfb\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"flexpfb\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 17 },\n\t\t\t\t\t{ \"dc\", 1 },\n\t\t\t\t\t{ \"wr\", 0 },\n\t\t\t\t\t{ \"cs\", 21 },\n\t\t\t\t\t{ \"db00\", 9 },\n\t\t\t\t\t{ \"db01\", 11 },\n\t\t\t\t\t{ \"db02\", 18 },\n\t\t\t\t\t{ \"db03\", 23 },\n\t\t\t\t\t{ \"db04\", 24 },\n\t\t\t\t\t{ \"db05\", 25 },\n\t\t\t\t\t{ \"db06\", 8 },\n\t\t\t\t\t{ \"db07\", 7 },\n\t\t\t\t\t{ \"led\", 4 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"freetronicsoled128\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ssd1351\",\n\t\t\t.max_speed_hz = 20000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = FBTFT_ONBOARD_BACKLIGHT,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 24 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"hx8353d\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_hx8353d\",\n\t\t\t.max_speed_hz = 16000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 23 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"hy28a\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9320\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.startbyte = 0b01110000,\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"hy28b\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9325\",\n\t\t\t.max_speed_hz = 48000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.init_sequence = hy28b_init_sequence,\n\t\t\t\t},\n\t\t\t\t.startbyte = 0b01110000,\n\t\t\t\t.bgr = true,\n\t\t\t\t.fps= 50,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t\t.gamma = HY28B_GAMMA,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"ili9481\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9481\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.regwidth = 16,\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 22 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"itdb24\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"fb_s6d1121\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = false,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t/* Wiring for LCD adapter kit */\n\t\t\t\t\t{ \"reset\", 7 },\n\t\t\t\t\t{ \"dc\", 0 }, \t/* rev 2: 2 */\n\t\t\t\t\t{ \"wr\", 1 }, \t/* rev 2: 3 */\n\t\t\t\t\t{ \"cs\", 8 },\n\t\t\t\t\t{ \"db00\", 17 },\n\t\t\t\t\t{ \"db01\", 18 },\n\t\t\t\t\t{ \"db02\", 21 }, /* rev 2: 27 */\n\t\t\t\t\t{ \"db03\", 22 },\n\t\t\t\t\t{ \"db04\", 23 },\n\t\t\t\t\t{ \"db05\", 24 },\n\t\t\t\t\t{ \"db06\", 25 },\n\t\t\t\t\t{ \"db07\", 4 },\n\t\t\t\t\t{}\n\t\t\t\t},\n\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"itdb28\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"fb_ili9325\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"itdb28_spi\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9325\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"mi0283qt-2\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_hx8347d\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.startbyte = 0b01110000,\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"mi0283qt-9a\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9341\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 9,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"mi0283qt-v2\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_watterott\",\n\t\t\t.max_speed_hz = 4000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"nokia3310\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_pcd8544\",\n\t\t\t.max_speed_hz = 400000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 23 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"nokia3310a\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_tls8204\",\n\t\t\t.max_speed_hz = 1000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 23 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"piscreen\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9486\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.regwidth = 16,\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 22 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"pitft\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9340\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.chip_select = 0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.init_sequence = pitft_init_sequence,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"pioled\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ssd1351\",\n\t\t\t.max_speed_hz = 20000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 24 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t\t.gamma =\t\"0 2 2 2 2 2 2 2 \" \\\n\t\t\t\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\t\t\t\"2 2 2 2 2 2 2 3 \" \\\n\t\t\t\t\t\t\"3 3 3 3 3 3 3 3 \" \\\n\t\t\t\t\t\t\"3 3 3 3 3 3 3 3 \" \\\n\t\t\t\t\t\t\"3 3 3 4 4 4 4 4 \" \\\n\t\t\t\t\t\t\"4 4 4 4 4 4 4\"\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"rpi-display\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9341\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 23 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"s6d02a1\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_s6d02a1\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 23 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"sainsmart18\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_st7735r\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"sainsmart32\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"fb_ssd1289\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 16,\n\t\t\t\t\t.txbuflen = -2, /* disable buffer */\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.fbtftops.write = write_gpio16_wr_slow,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t}\n\t}, {\n\t\t.name = \"sainsmart32_fast\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"fb_ssd1289\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 16,\n\t\t\t\t\t.txbuflen = -2, /* disable buffer */\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t}\n\t}, {\n\t\t.name = \"sainsmart32_latched\",\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"fb_ssd1289\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 16,\n\t\t\t\t\t.txbuflen = -2, /* disable buffer */\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.fbtftops.write = \\\n\t\t\t\t\t\tfbtft_write_gpio16_wr_latched,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t}\n\t}, {\n\t\t.name = \"sainsmart32_spi\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ssd1289\",\n\t\t\t.max_speed_hz = 16000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"spidev\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"spidev\",\n\t\t\t.max_speed_hz = 500000,\n\t\t\t.bus_num = 0,\n\t\t\t.chip_select = 0,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"ssd1331\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ssd1331\",\n\t\t\t.max_speed_hz = 20000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 24 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"tinylcd35\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_tinylcd\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"tm022hdh26\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9341\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 25 },\n\t\t\t\t\t{ \"dc\", 24 },\n\t\t\t\t\t{ \"led\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"tontec35_9481\", /* boards before 02 July 2014 */\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9481\",\n\t\t\t.max_speed_hz = 128000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 15 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{ \"led_\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"tontec35_9486\", /* boards after 02 July 2014 */\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9486\",\n\t\t\t.max_speed_hz = 128000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 15 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{ \"led_\", 18 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"upd161704\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_upd161704\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 24 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"waveshare32b\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_ili9340\",\n\t\t\t.max_speed_hz = 48000000,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t\t.backlight = 1,\n\t\t\t\t\t.init_sequence = waveshare32b_init_sequence,\n\t\t\t\t},\n\t\t\t\t.bgr = true,\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 27 },\n\t\t\t\t\t{ \"dc\", 22 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.name = \"waveshare22\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"fb_bd663474\",\n\t\t\t.max_speed_hz = 32000000,\n\t\t\t.mode = SPI_MODE_3,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.display = {\n\t\t\t\t\t.buswidth = 8,\n\t\t\t\t},\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{ \"reset\", 24 },\n\t\t\t\t\t{ \"dc\", 25 },\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}, {\n\t\t/* This should be the last item.\n\t\t   Used with the custom argument */\n\t\t.name = \"\",\n\t\t.spi = &(struct spi_board_info) {\n\t\t\t.modalias = \"\",\n\t\t\t.max_speed_hz = 0,\n\t\t\t.mode = SPI_MODE_0,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t.pdev = &(struct platform_device) {\n\t\t\t.name = \"\",\n\t\t\t.id = 0,\n\t\t\t.dev = {\n\t\t\t.release = fbtft_device_pdev_release,\n\t\t\t.platform_data = &(struct fbtft_platform_data) {\n\t\t\t\t.gpios = (const struct fbtft_gpio []) {\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t},\n\t}\n};\n\nstatic int write_gpio16_wr_slow(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu16 data;\n\tint i;\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\tstatic u16 prev_data;\n#endif\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\"%s(len=%d): \", __func__, len);\n\n\twhile (len) {\n\t\tdata = *(u16 *) buf;\n\n\t\t/* Start writing by pulling down /WR */\n\t\tgpio_set_value(par->gpio.wr, 0);\n\n\t\t/* Set data */\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tif (data == prev_data) {\n\t\t\tgpio_set_value(par->gpio.wr, 0); /* used as delay */\n\t\t} else {\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tif ((data & 1) != (prev_data & 1))\n\t\t\t\t\tgpio_set_value(par->gpio.db[i],\n\t\t\t\t\t\t\t\t(data & 1));\n\t\t\t\tdata >>= 1;\n\t\t\t\tprev_data >>= 1;\n\t\t\t}\n\t\t}\n#else\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tgpio_set_value(par->gpio.db[i], (data & 1));\n\t\t\tdata >>= 1;\n\t\t}\n#endif\n\n\t\t/* Pullup /WR */\n\t\tgpio_set_value(par->gpio.wr, 1);\n\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tprev_data = *(u16 *) buf;\n#endif\n\t\tbuf += 2;\n\t\tlen -= 2;\n\t}\n\n\treturn 0;\n}\n\nstatic void adafruit18_green_tab_set_addr_win(struct fbtft_par *par,\n\t\t\t\t\t\tint xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\n\t\t\"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\twrite_reg(par, 0x2A, 0, xs + 2, 0, xe + 2);\n\twrite_reg(par, 0x2B, 0, ys + 1, 0, ye + 1);\n\twrite_reg(par, 0x2C);\n}\n\n/* used if gpios parameter is present */\nstatic struct fbtft_gpio fbtft_device_param_gpios[MAX_GPIOS+1] = { };\n\nstatic void fbtft_device_pdev_release(struct device *dev)\n{\n/* Needed to silence this message:\nDevice 'xxx' does not have a release() function, it is broken and must be fixed\n*/\n}\n\nstatic int spi_device_found(struct device *dev, void *data)\n{\n\tstruct spi_device *spi = container_of(dev, struct spi_device, dev);\n\n\tpr_info(DRVNAME\":      %s %s %dkHz %d bits mode=0x%02X\\n\",\n\t\tspi->modalias, dev_name(dev), spi->max_speed_hz/1000,\n\t\tspi->bits_per_word, spi->mode);\n\n\treturn 0;\n}\n\nstatic void pr_spi_devices(void)\n{\n\tpr_info(DRVNAME\":  SPI devices registered:\\n\");\n\tbus_for_each_dev(&spi_bus_type, NULL, NULL, spi_device_found);\n}\n\nstatic int p_device_found(struct device *dev, void *data)\n{\n\tstruct platform_device\n\t*pdev = container_of(dev, struct platform_device, dev);\n\n\tif (strstr(pdev->name, \"fb\"))\n\t\tpr_info(DRVNAME\":      %s id=%d pdata? %s\\n\",\n\t\t\t\tpdev->name, pdev->id,\n\t\t\t\tpdev->dev.platform_data ? \"yes\" : \"no\");\n\n\treturn 0;\n}\n\nstatic void pr_p_devices(void)\n{\n\tpr_info(DRVNAME\":  'fb' Platform devices registered:\\n\");\n\tbus_for_each_dev(&platform_bus_type, NULL, NULL, p_device_found);\n}\n\n#ifdef MODULE\nstatic void fbtft_device_spi_delete(struct spi_master *master, unsigned cs)\n{\n\tstruct device *dev;\n\tchar str[32];\n\n\tsnprintf(str, sizeof(str), \"%s.%u\", dev_name(&master->dev), cs);\n\n\tdev = bus_find_device_by_name(&spi_bus_type, NULL, str);\n\tif (dev) {\n\t\tif (verbose)\n\t\t\tpr_info(DRVNAME\": Deleting %s\\n\", str);\n\t\tdevice_del(dev);\n\t}\n}\n\nstatic int fbtft_device_spi_device_register(struct spi_board_info *spi)\n{\n\tstruct spi_master *master;\n\n\tmaster = spi_busnum_to_master(spi->bus_num);\n\tif (!master) {\n\t\tpr_err(DRVNAME \":  spi_busnum_to_master(%d) returned NULL\\n\",\n\t\t\t\t\t\t\t\tspi->bus_num);\n\t\treturn -EINVAL;\n\t}\n\t/* make sure it's available */\n\tfbtft_device_spi_delete(master, spi->chip_select);\n\tspi_device = spi_new_device(master, spi);\n\tput_device(&master->dev);\n\tif (!spi_device) {\n\t\tpr_err(DRVNAME \":    spi_new_device() returned NULL\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n#else\nstatic int fbtft_device_spi_device_register(struct spi_board_info *spi)\n{\n\treturn spi_register_board_info(spi, 1);\n}\n#endif\n\nstatic int __init fbtft_device_init(void)\n{\n\tstruct spi_board_info *spi = NULL;\n\tstruct fbtft_platform_data *pdata;\n\tconst struct fbtft_gpio *gpio = NULL;\n\tchar *p_gpio, *p_name, *p_num;\n\tbool found = false;\n\tint i = 0;\n\tlong val;\n\tint ret = 0;\n\n\tpr_debug(\"\\n\\n\"DRVNAME\": init\\n\");\n\n\tif (name == NULL) {\n#ifdef MODULE\n\t\tpr_err(DRVNAME\":  missing module parameter: 'name'\\n\");\n\t\treturn -EINVAL;\n#else\n\t\treturn 0;\n#endif\n\t}\n\n\tif (init_num > FBTFT_MAX_INIT_SEQUENCE) {\n\t\tpr_err(DRVNAME \\\n\t\t\t\":  init parameter: exceeded max array size: %d\\n\",\n\t\t\tFBTFT_MAX_INIT_SEQUENCE);\n\t\treturn -EINVAL;\n\t}\n\n\t/* parse module parameter: gpios */\n\twhile ((p_gpio = strsep(&gpios, \",\"))) {\n\t\tif (strchr(p_gpio, ':') == NULL) {\n\t\t\tpr_err(DRVNAME \\\n\t\t\t\t\":  error: missing ':' in gpios parameter: %s\\n\",\n\t\t\t\tp_gpio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp_num = p_gpio;\n\t\tp_name = strsep(&p_num, \":\");\n\t\tif (p_name == NULL || p_num == NULL) {\n\t\t\tpr_err(DRVNAME \\\n\t\t\t\t\":  something bad happened parsing gpios parameter: %s\\n\",\n\t\t\t\tp_gpio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = kstrtol(p_num, 10, &val);\n\t\tif (ret) {\n\t\t\tpr_err(DRVNAME \\\n\t\t\t\t\":  could not parse number in gpios parameter: %s:%s\\n\",\n\t\t\t\tp_name, p_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrcpy(fbtft_device_param_gpios[i].name, p_name);\n\t\tfbtft_device_param_gpios[i++].gpio = (int) val;\n\t\tif (i == MAX_GPIOS) {\n\t\t\tpr_err(DRVNAME \\\n\t\t\t\t\":  gpios parameter: exceeded max array size: %d\\n\",\n\t\t\t\tMAX_GPIOS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (fbtft_device_param_gpios[0].name[0])\n\t\tgpio = fbtft_device_param_gpios;\n\n\tif (verbose > 2)\n\t\tpr_spi_devices(); /* print list of registered SPI devices */\n\n\tif (verbose > 2)\n\t\tpr_p_devices(); /* print list of 'fb' platform devices */\n\n\tpr_debug(DRVNAME\":  name='%s', busnum=%d, cs=%d\\n\", name, busnum, cs);\n\n\tif (rotate > 0 && rotate < 4) {\n\t\trotate = (4 - rotate) * 90;\n\t\tpr_warn(\"argument 'rotate' should be an angle. Values 1-3 is deprecated. Setting it to %d.\\n\",\n\t\t\trotate);\n\t}\n\tif (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270) {\n\t\tpr_warn(\"argument 'rotate' illegal value: %d. Setting it to 0.\\n\",\n\t\t\trotate);\n\t\trotate = 0;\n\t}\n\n\t/* name=list lists all supported displays */\n\tif (strncmp(name, \"list\", 32) == 0) {\n\t\tpr_info(DRVNAME\":  Supported displays:\\n\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(displays); i++)\n\t\t\tpr_info(DRVNAME\":      %s\\n\", displays[i].name);\n\t\treturn -ECANCELED;\n\t}\n\n\tif (custom) {\n\t\ti = ARRAY_SIZE(displays) - 1;\n\t\tdisplays[i].name = name;\n\t\tif (speed == 0) {\n\t\t\tdisplays[i].pdev->name = name;\n\t\t\tdisplays[i].spi = NULL;\n\t\t} else {\n\t\t\tstrncpy(displays[i].spi->modalias, name, SPI_NAME_SIZE);\n\t\t\tdisplays[i].pdev = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(displays); i++) {\n\t\tif (strncmp(name, displays[i].name, 32) == 0) {\n\t\t\tif (displays[i].spi) {\n\t\t\t\tspi = displays[i].spi;\n\t\t\t\tspi->chip_select = cs;\n\t\t\t\tspi->bus_num = busnum;\n\t\t\t\tif (speed)\n\t\t\t\t\tspi->max_speed_hz = speed;\n\t\t\t\tif (mode != -1)\n\t\t\t\t\tspi->mode = mode;\n\t\t\t\tpdata = (void *)spi->platform_data;\n\t\t\t} else if (displays[i].pdev) {\n\t\t\t\tp_device = displays[i].pdev;\n\t\t\t\tpdata = p_device->dev.platform_data;\n\t\t\t} else {\n\t\t\t\tpr_err(DRVNAME\": broken displays array\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpdata->rotate = rotate;\n\t\t\tif (bgr == 0)\n\t\t\t\tpdata->bgr = false;\n\t\t\telse if (bgr == 1)\n\t\t\t\tpdata->bgr = true;\n\t\t\tif (startbyte)\n\t\t\t\tpdata->startbyte = startbyte;\n\t\t\tif (gamma)\n\t\t\t\tpdata->gamma = gamma;\n\t\t\tpdata->display.debug = debug;\n\t\t\tif (fps)\n\t\t\t\tpdata->fps = fps;\n\t\t\tif (txbuflen)\n\t\t\t\tpdata->txbuflen = txbuflen;\n\t\t\tif (init_num)\n\t\t\t\tpdata->display.init_sequence = init;\n\t\t\tif (gpio)\n\t\t\t\tpdata->gpios = gpio;\n\t\t\tif (custom) {\n\t\t\t\tpdata->display.width = width;\n\t\t\t\tpdata->display.height = height;\n\t\t\t\tpdata->display.buswidth = buswidth;\n\t\t\t\tpdata->display.backlight = 1;\n\t\t\t}\n\n\t\t\tif (displays[i].spi) {\n\t\t\t\tret = fbtft_device_spi_device_register(spi);\n\t\t\t\tif (ret) {\n\t\t\t\t\tpr_err(DRVNAME \\\n\t\t\t\t\t\t\": failed to register SPI device\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret = platform_device_register(p_device);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tpr_err(DRVNAME \\\n\t\t\t\t\t\t\":    platform_device_register() returned %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tpr_err(DRVNAME\":  display not supported: '%s'\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (verbose && pdata && pdata->gpios) {\n\t\tgpio = pdata->gpios;\n\t\tpr_info(DRVNAME\":  GPIOS used by '%s':\\n\", name);\n\t\tfound = false;\n\t\twhile (verbose && gpio->name[0]) {\n\t\t\tpr_info(DRVNAME\":    '%s' = GPIO%d\\n\",\n\t\t\t\tgpio->name, gpio->gpio);\n\t\t\tgpio++;\n\t\t\tfound = true;\n\t\t}\n\t\tif (!found)\n\t\t\tpr_info(DRVNAME\":    (none)\\n\");\n\t}\n\n\tif (spi_device && (verbose > 1))\n\t\tpr_spi_devices();\n\tif (p_device && (verbose > 1))\n\t\tpr_p_devices();\n\n\treturn 0;\n}\n\nstatic void __exit fbtft_device_exit(void)\n{\n\tpr_debug(DRVNAME\" - exit\\n\");\n\n\tif (spi_device) {\n\t\tdevice_del(&spi_device->dev);\n\t\tkfree(spi_device);\n\t}\n\n\tif (p_device)\n\t\tplatform_device_unregister(p_device);\n\n}\n\narch_initcall(fbtft_device_init);\nmodule_exit(fbtft_device_exit);\n\nMODULE_DESCRIPTION(\"Add a FBTFT device.\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        },
        {
          "name": "flexfb.c",
          "type": "blob",
          "size": 17.4169921875,
          "content": "/*\n * Generic FB driver for TFT LCD displays\n *\n * Copyright (C) 2013 Noralf Tronnes\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t    \"flexfb\"\n\n\nstatic char *chip = NULL;\nmodule_param(chip, charp, 0);\nMODULE_PARM_DESC(chip, \"LCD controller\");\n\nstatic unsigned int width = 0;\nmodule_param(width, uint, 0);\nMODULE_PARM_DESC(width, \"Display width\");\n\nstatic unsigned int height = 0;\nmodule_param(height, uint, 0);\nMODULE_PARM_DESC(height, \"Display height\");\n\nstatic int init[512];\nstatic int init_num = 0;\nmodule_param_array(init, int, &init_num, 0);\nMODULE_PARM_DESC(init, \"Init sequence\");\n\nstatic unsigned int setaddrwin = 0;\nmodule_param(setaddrwin, uint, 0);\nMODULE_PARM_DESC(setaddrwin, \"Which set_addr_win() implementation to use\");\n\nstatic unsigned int buswidth = 8;\nmodule_param(buswidth, uint, 0);\nMODULE_PARM_DESC(buswidth, \"Width of databus (default: 8)\");\n\nstatic unsigned int regwidth = 8;\nmodule_param(regwidth, uint, 0);\nMODULE_PARM_DESC(regwidth, \"Width of controller register (default: 8)\");\n\nstatic bool nobacklight = false;\nmodule_param(nobacklight, bool, 0);\nMODULE_PARM_DESC(nobacklight, \"Turn off backlight functionality.\");\n\nstatic bool latched = false;\nmodule_param(latched, bool, 0);\nMODULE_PARM_DESC(latched, \"Use with latched 16-bit databus\");\n\n\nstatic int *initp = NULL;\nstatic int initp_num = 0;\n\n/* default init sequences */\nstatic int st7735r_init[] = { \\\n-1,0x01,-2,150,-1,0x11,-2,500,-1,0xB1,0x01,0x2C,0x2D,-1,0xB2,0x01,0x2C,0x2D,-1,0xB3,0x01,0x2C,0x2D,0x01,0x2C,0x2D, \\\n-1,0xB4,0x07,-1,0xC0,0xA2,0x02,0x84,-1,0xC1,0xC5,-1,0xC2,0x0A,0x00,-1,0xC3,0x8A,0x2A,-1,0xC4,0x8A,0xEE,-1,0xC5,0x0E, \\\n-1,0x20,-1,0x36,0xC0,-1,0x3A,0x05,-1,0xE0,0x0f,0x1a,0x0f,0x18,0x2f,0x28,0x20,0x22,0x1f,0x1b,0x23,0x37,0x00,0x07,0x02,0x10, \\\n-1,0xE1,0x0f,0x1b,0x0f,0x17,0x33,0x2c,0x29,0x2e,0x30,0x30,0x39,0x3f,0x00,0x07,0x03,0x10,-1,0x29,-2,100,-1,0x13,-2,10,-3 };\n\nstatic int ssd1289_init[] = { \\\n-1,0x00,0x0001,-1,0x03,0xA8A4,-1,0x0C,0x0000,-1,0x0D,0x080C,-1,0x0E,0x2B00,-1,0x1E,0x00B7,-1,0x01,0x2B3F,-1,0x02,0x0600, \\\n-1,0x10,0x0000,-1,0x11,0x6070,-1,0x05,0x0000,-1,0x06,0x0000,-1,0x16,0xEF1C,-1,0x17,0x0003,-1,0x07,0x0233,-1,0x0B,0x0000, \\\n-1,0x0F,0x0000,-1,0x41,0x0000,-1,0x42,0x0000,-1,0x48,0x0000,-1,0x49,0x013F,-1,0x4A,0x0000,-1,0x4B,0x0000,-1,0x44,0xEF00, \\\n-1,0x45,0x0000,-1,0x46,0x013F,-1,0x30,0x0707,-1,0x31,0x0204,-1,0x32,0x0204,-1,0x33,0x0502,-1,0x34,0x0507,-1,0x35,0x0204, \\\n-1,0x36,0x0204,-1,0x37,0x0502,-1,0x3A,0x0302,-1,0x3B,0x0302,-1,0x23,0x0000,-1,0x24,0x0000,-1,0x25,0x8000,-1,0x4f,0x0000, \\\n-1,0x4e,0x0000,-1,0x22,-3 };\n\nstatic int hx8340bn_init[] = { \\\n-1,0xC1,0xFF,0x83,0x40,-1,0x11,-2,150,-1,0xCA,0x70,0x00,0xD9,-1,0xB0,0x01,0x11, \\\n-1,0xC9,0x90,0x49,0x10,0x28,0x28,0x10,0x00,0x06,-2,20,-1,0xC2,0x60,0x71,0x01,0x0E,0x05,0x02,0x09,0x31,0x0A, \\\n-1,0xC3,0x67,0x30,0x61,0x17,0x48,0x07,0x05,0x33,-2,10,-1,0xB5,0x35,0x20,0x45,-1,0xB4,0x33,0x25,0x4C,-2,10, \\\n-1,0x3A,0x05,-1,0x29,-2,10,-3 };\n\nstatic int ili9225_init[] = { \\\n-1,0x0001,0x011C,-1,0x0002,0x0100,-1,0x0003,0x1030,-1,0x0008,0x0808,-1,0x000C,0x0000,-1,0x000F,0x0A01,-1,0x0020,0x0000, \\\n-1,0x0021,0x0000,-2,50,-1,0x0010,0x0A00,-1,0x0011,0x1038,-2,50,-1,0x0012,0x1121,-1,0x0013,0x004E,-1,0x0014,0x676F, \\\n-1,0x0030,0x0000,-1,0x0031,0x00DB,-1,0x0032,0x0000,-1,0x0033,0x0000,-1,0x0034,0x00DB,-1,0x0035,0x0000,-1,0x0036,0x00AF, \\\n-1,0x0037,0x0000,-1,0x0038,0x00DB,-1,0x0039,0x0000,-1,0x0050,0x0000,-1,0x0051,0x060A,-1,0x0052,0x0D0A,-1,0x0053,0x0303, \\\n-1,0x0054,0x0A0D,-1,0x0055,0x0A06,-1,0x0056,0x0000,-1,0x0057,0x0303,-1,0x0058,0x0000,-1,0x0059,0x0000,-2,50, \\\n-1,0x0007,0x1017,-2,50,-3 };\n\nstatic int ili9320_init[] = { \\\n-1,0x00E5,0x8000,-1,0x0000,0x0001,-1,0x0001,0x0100,-1,0x0002,0x0700,-1,0x0003,0x1030,-1,0x0004,0x0000,-1,0x0008,0x0202, \\\n-1,0x0009,0x0000,-1,0x000A,0x0000,-1,0x000C,0x0000,-1,0x000D,0x0000,-1,0x000F,0x0000,-1,0x0010,0x0000,-1,0x0011,0x0007, \\\n-1,0x0012,0x0000,-1,0x0013,0x0000,-2,200,-1,0x0010,0x17B0,-1,0x0011,0x0031,-2,50,-1,0x0012,0x0138,-2,50,-1,0x0013,0x1800, \\\n-1,0x0029,0x0008,-2,50,-1,0x0020,0x0000,-1,0x0021,0x0000,-1,0x0030,0x0000,-1,0x0031,0x0505,-1,0x0032,0x0004, \\\n-1,0x0035,0x0006,-1,0x0036,0x0707,-1,0x0037,0x0105,-1,0x0038,0x0002,-1,0x0039,0x0707,-1,0x003C,0x0704,-1,0x003D,0x0807, \\\n-1,0x0050,0x0000,-1,0x0051,0x00EF,-1,0x0052,0x0000,-1,0x0053,0x013F,-1,0x0060,0x2700,-1,0x0061,0x0001,-1,0x006A,0x0000, \\\n-1,0x0080,0x0000,-1,0x0081,0x0000,-1,0x0082,0x0000,-1,0x0083,0x0000,-1,0x0084,0x0000,-1,0x0085,0x0000,-1,0x0090,0x0010, \\\n-1,0x0092,0x0000,-1,0x0093,0x0003,-1,0x0095,0x0110,-1,0x0097,0x0000,-1,0x0098,0x0000,-1,0x0007,0x0173,-3 };\n\nstatic int ili9325_init[] = { \\\n-1,0x00E3,0x3008,-1,0x00E7,0x0012,-1,0x00EF,0x1231,-1,0x0001,0x0100,-1,0x0002,0x0700,-1,0x0003,0x1030,-1,0x0004,0x0000, \\\n-1,0x0008,0x0207,-1,0x0009,0x0000,-1,0x000A,0x0000,-1,0x000C,0x0000,-1,0x000D,0x0000,-1,0x000F,0x0000,-1,0x0010,0x0000, \\\n-1,0x0011,0x0007,-1,0x0012,0x0000,-1,0x0013,0x0000,-2,200,-1,0x0010,0x1690,-1,0x0011,0x0223,-2,50,-1,0x0012,0x000D,-2,50, \\\n-1,0x0013,0x1200,-1,0x0029,0x000A,-1,0x002B,0x000C,-2,50,-1,0x0020,0x0000,-1,0x0021,0x0000,-1,0x0030,0x0000, \\\n-1,0x0031,0x0506,-1,0x0032,0x0104,-1,0x0035,0x0207,-1,0x0036,0x000F,-1,0x0037,0x0306,-1,0x0038,0x0102,-1,0x0039,0x0707, \\\n-1,0x003C,0x0702,-1,0x003D,0x1604,-1,0x0050,0x0000,-1,0x0051,0x00EF,-1,0x0052,0x0000,-1,0x0053,0x013F,-1,0x0060,0xA700, \\\n-1,0x0061,0x0001,-1,0x006A,0x0000,-1,0x0080,0x0000,-1,0x0081,0x0000,-1,0x0082,0x0000,-1,0x0083,0x0000,-1,0x0084,0x0000, \\\n-1,0x0085,0x0000,-1,0x0090,0x0010,-1,0x0092,0x0600,-1,0x0007,0x0133,-3 };\n\nstatic int ili9341_init[] = { \\\n-1,0x28,-2,20,-1,0xCF,0x00,0x83,0x30,-1,0xED,0x64,0x03,0x12,0x81,-1,0xE8,0x85,0x01,0x79, \\\n-1,0xCB,0x39,0x2c,0x00,0x34,0x02,-1,0xF7,0x20,-1,0xEA,0x00,0x00,-1,0xC0,0x26,-1,0xC1,0x11, \\\n-1,0xC5,0x35,0x3E,-1,0xC7,0xBE,-1,0xB1,0x00,0x1B,-1,0xB6,0x0a,0x82,0x27,0x00,-1,0xB7,0x07, \\\n-1,0x3A,0x55,-1,0x36,0x48,-1,0x11,-2,120,-1,0x29,-2,20,-3 };\n\nstatic int ssd1351_init[] = { -1,0xfd,0x12,-1,0xfd,0xb1,-1,0xae,-1,0xb3,0xf1,-1,0xca,0x7f,-1,0xa0,0x74, \\\n                              -1,0x15,0x00,0x7f,-1,0x75,0x00,0x7f,-1,0xa1,0x00,-1,0xa2,0x00,-1,0xb5,0x00, \\\n                              -1,0xab,0x01,-1,0xb1,0x32,-1,0xb4,0xa0,0xb5,0x55,-1,0xbb,0x17,-1,0xbe,0x05, \\\n                              -1,0xc1,0xc8,0x80,0xc8,-1,0xc7,0x0f,-1,0xb6,0x01,-1,0xa6,-1,0xaf,-3 };\n\n\n/* ili9320, ili9325 */\nstatic void flexfb_set_addr_win_1(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, \"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\tswitch (par->info->var.rotate) {\n\t/* R20h = Horizontal GRAM Start Address */\n\t/* R21h = Vertical GRAM Start Address */\n\tcase 0:\n\t\twrite_reg(par, 0x0020, xs);\n\t\twrite_reg(par, 0x0021, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0020, width - 1 - xs);\n\t\twrite_reg(par, 0x0021, height - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0020, width - 1 - ys);\n\t\twrite_reg(par, 0x0021, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0020, ys);\n\t\twrite_reg(par, 0x0021, height - 1 - xs);\n\t\tbreak;\n\t}\n\twrite_reg(par, 0x0022); /* Write Data to GRAM */\n}\n\n/* ssd1289 */\nstatic void flexfb_set_addr_win_2(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, \"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\tswitch (par->info->var.rotate) {\n\t/* R4Eh - Set GDDRAM X address counter */\n\t/* R4Fh - Set GDDRAM Y address counter */\n\tcase 0:\n\t\twrite_reg(par, 0x4e, xs);\n\t\twrite_reg(par, 0x4f, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x4e, par->info->var.xres - 1 - xs);\n\t\twrite_reg(par, 0x4f, par->info->var.yres - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x4e, par->info->var.yres - 1 - ys);\n\t\twrite_reg(par, 0x4f, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x4e, ys);\n\t\twrite_reg(par, 0x4f, par->info->var.xres - 1 - xs);\n\t\tbreak;\n\t}\n\n\t/* R22h - RAM data write */\n\twrite_reg(par, 0x22, 0);\n}\n\n/* ssd1351 */\nstatic void set_addr_win_3(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, \"%s(xs=%d, ys=%d, xe=%d, ye=%d)\\n\", __func__, xs, ys, xe, ye);\n\n\twrite_reg(par, 0x15, xs, xe);\n\twrite_reg(par, 0x75, ys, ye);\n\twrite_reg(par, 0x5C);\n}\n\nstatic int flexfb_verify_gpios_dc(struct fbtft_par *par)\n{\n\tfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, \"%s()\\n\", __func__);\n\n\tif (par->gpio.dc < 0) {\n\t\tdev_err(par->info->device, \"Missing info about 'dc' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int flexfb_verify_gpios_db(struct fbtft_par *par)\n{\n\tint i;\n\tint num_db = buswidth;\n\n\tfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, \"%s()\\n\", __func__);\n\n\tif (par->gpio.dc < 0) {\n\t\tdev_err(par->info->device, \"Missing info about 'dc' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->gpio.wr < 0) {\n\t\tdev_err(par->info->device, \"Missing info about 'wr' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (latched && (par->gpio.latch < 0)) {\n\t\tdev_err(par->info->device, \"Missing info about 'latch' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (latched)\n\t\tnum_db=buswidth/2;\n\tfor (i=0;i < num_db;i++) {\n\t\tif (par->gpio.db[i] < 0) {\n\t\t\tdev_err(par->info->device, \"Missing info about 'db%02d' gpio. Aborting.\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display flex_display = { };\n\nstatic int flexfb_probe_common(struct spi_device *sdev, struct platform_device *pdev)\n{\n\tstruct device *dev;\n\tstruct fb_info *info;\n\tstruct fbtft_par *par;\n\tint ret;\n\n\tinitp = init;\n\tinitp_num = init_num;\n\n\tif (sdev)\n\t\tdev = &sdev->dev;\n\telse\n\t\tdev = &pdev->dev;\n\n\tfbtft_init_dbg(dev, \"%s(%s)\\n\", __func__, sdev ? \"'SPI device'\" : \"'Platform device'\");\n\n\tif (chip) {\n\n\t\tif (!strcmp(chip, \"st7735r\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 128;\n\t\t\tif (!height)\n\t\t\t\theight = 160;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = st7735r_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(st7735r_init);\n\t\t\t}\n\n\n\t\t} else if (!strcmp(chip, \"hx8340bn\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 176;\n\t\t\tif (!height)\n\t\t\t\theight = 220;\n\t\t\tsetaddrwin = 0;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = hx8340bn_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(hx8340bn_init);\n\t\t\t}\n\n\n\t\t} else if (!strcmp(chip, \"ili9225\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 176;\n\t\t\tif (!height)\n\t\t\t\theight = 220;\n\t\t\tsetaddrwin = 0;\n\t\t\tregwidth = 16;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = ili9225_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(ili9225_init);\n\t\t\t}\n\n\n\n\t\t} else if (!strcmp(chip, \"ili9320\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 240;\n\t\t\tif (!height)\n\t\t\t\theight = 320;\n\t\t\tsetaddrwin = 1;\n\t\t\tregwidth = 16;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = ili9320_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(ili9320_init);\n\t\t\t}\n\n\n\t\t} else if (!strcmp(chip, \"ili9325\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 240;\n\t\t\tif (!height)\n\t\t\t\theight = 320;\n\t\t\tsetaddrwin = 1;\n\t\t\tregwidth = 16;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = ili9325_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(ili9325_init);\n\t\t\t}\n\n\t\t} else if (!strcmp(chip, \"ili9341\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 240;\n\t\t\tif (!height)\n\t\t\t\theight = 320;\n\t\t\tsetaddrwin = 0;\n\t\t\tregwidth = 8;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = ili9341_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(ili9341_init);\n\t\t\t}\n\n\n\t\t} else if (!strcmp(chip, \"ssd1289\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 240;\n\t\t\tif (!height)\n\t\t\t\theight = 320;\n\t\t\tsetaddrwin = 2;\n\t\t\tregwidth = 16;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = ssd1289_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(ssd1289_init);\n\t\t\t}\n\n\n\n\t\t} else if (!strcmp(chip, \"ssd1351\")) {\n\t\t\tif (!width)\n\t\t\t\twidth = 128;\n\t\t\tif (!height)\n\t\t\t\theight = 128;\n\t\t\tsetaddrwin = 3;\n\t\t\tif (init_num == 0) {\n\t\t\t\tinitp = ssd1351_init;\n\t\t\t\tinitp_num = ARRAY_SIZE(ssd1351_init);\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"chip=%s is not supported\\n\", chip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (width == 0 || height == 0) {\n\t\tdev_err(dev, \"argument(s) missing: width and height has to be set.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tflex_display.width = width;\n\tflex_display.height = height;\n\tfbtft_init_dbg(dev, \"Display resolution: %dx%d\\n\", width, height);\n\tfbtft_init_dbg(dev, \"chip = %s\\n\", chip ? chip : \"not set\");\n\tfbtft_init_dbg(dev, \"setaddrwin = %d\\n\", setaddrwin);\n\tfbtft_init_dbg(dev, \"regwidth = %d\\n\", regwidth);\n\tfbtft_init_dbg(dev, \"buswidth = %d\\n\", buswidth);\n\n\tinfo = fbtft_framebuffer_alloc(&flex_display, dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tif (sdev)\n\t\tpar->spi = sdev;\n\telse\n\t\tpar->pdev = pdev;\n\tif (!par->init_sequence)\n\t\tpar->init_sequence = initp;\n\tpar->fbtftops.init_display = fbtft_init_display;\n\n\t/* registerwrite functions */\n\tswitch (regwidth) {\n\tcase 8:\n\t\tpar->fbtftops.write_register = fbtft_write_reg8_bus8;\n\t\tbreak;\n\tcase 16:\n\t\tpar->fbtftops.write_register = fbtft_write_reg16_bus8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"argument 'regwidth': %d is not supported.\\n\", regwidth);\n\t\treturn -EINVAL;\n\t}\n\n\t/* bus functions */\n\tif (sdev) {\n\t\tpar->fbtftops.write = fbtft_write_spi;\n\t\tswitch (buswidth) {\n\t\tcase 8:\n\t\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\n\t\t\tif (!par->startbyte)\n\t\t\t\tpar->fbtftops.verify_gpios = flexfb_verify_gpios_dc;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tif (regwidth == 16) {\n\t\t\t\tdev_err(dev, \"argument 'regwidth': %d is not supported with buswidth=%d and SPI.\\n\", regwidth, buswidth);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpar->fbtftops.write_register = fbtft_write_reg8_bus9;\n\t\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus9;\n\t\t\tsdev->bits_per_word=9;\n\t\t\tret = sdev->master->setup(sdev);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\"9-bit SPI not available, emulating using 8-bit.\\n\");\n\t\t\t\tsdev->bits_per_word = 8;\n\t\t\t\tret = sdev->master->setup(sdev);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_release;\n\t\t\t\t/* allocate buffer with room for dc bits */\n\t\t\t\tpar->extra = devm_kzalloc(par->info->device,\n\t\t\t\t\t\tpar->txbuf.len + (par->txbuf.len / 8) + 8,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!par->extra) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out_release;\n\t\t\t\t}\n\t\t\t\tpar->fbtftops.write = fbtft_write_spi_emulate_9;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"argument 'buswidth': %d is not supported with SPI.\\n\", buswidth);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tpar->fbtftops.verify_gpios = flexfb_verify_gpios_db;\n\t\tswitch (buswidth) {\n\t\tcase 8:\n\t\t\tpar->fbtftops.write = fbtft_write_gpio8_wr;\n\t\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tpar->fbtftops.write_register = fbtft_write_reg16_bus16;\n\t\t\tif (latched)\n\t\t\t\tpar->fbtftops.write = fbtft_write_gpio16_wr_latched;\n\t\t\telse\n\t\t\t\tpar->fbtftops.write = fbtft_write_gpio16_wr;\n\t\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"argument 'buswidth': %d is not supported with parallel.\\n\", buswidth);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* set_addr_win function */\n\tswitch (setaddrwin) {\n\tcase 0:\n\t\t/* use default */\n\t\tbreak;\n\tcase 1:\n\t\tpar->fbtftops.set_addr_win = flexfb_set_addr_win_1;\n\t\tbreak;\n\tcase 2:\n\t\tpar->fbtftops.set_addr_win = flexfb_set_addr_win_2;\n\t\tbreak;\n\tcase 3:\n\t\tpar->fbtftops.set_addr_win = set_addr_win_3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"argument 'setaddrwin': unknown value %d.\\n\", setaddrwin);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!nobacklight)\n\t\tpar->fbtftops.register_backlight = fbtft_register_backlight;\n\n\tret = fbtft_register_framebuffer(info);\n\tif (ret < 0)\n\t\tgoto out_release;\n\n\treturn 0;\n\nout_release:\n\tfbtft_framebuffer_release(info);\n\n\treturn ret;\n}\n\nstatic int flexfb_remove_common(struct device *dev, struct fb_info *info)\n{\n\tstruct fbtft_par *par;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tpar = info->par;\n\tif (par)\n\t\tfbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par,\n\t\t\t\"%s()\\n\", __func__);\n\tfbtft_unregister_framebuffer(info);\n\tfbtft_framebuffer_release(info);\n\n\treturn 0;\n}\n\nstatic int flexfb_probe_spi(struct spi_device *spi)\n{\n\treturn flexfb_probe_common(spi, NULL);\n}\n\nstatic int flexfb_remove_spi(struct spi_device *spi)\n{\n\tstruct fb_info *info = spi_get_drvdata(spi);\n\n\treturn flexfb_remove_common(&spi->dev, info);\n}\n\nstatic int flexfb_probe_pdev(struct platform_device *pdev)\n{\n\treturn flexfb_probe_common(NULL, pdev);\n}\n\nstatic int flexfb_remove_pdev(struct platform_device *pdev)\n{\n\tstruct fb_info *info = platform_get_drvdata(pdev);\n\n\treturn flexfb_remove_common(&pdev->dev, info);\n}\n\nstatic struct spi_driver flexfb_spi_driver = {\n\t.driver = {\n\t\t.name   = DRVNAME,\n\t\t.owner  = THIS_MODULE,\n\t},\n\t.probe  = flexfb_probe_spi,\n\t.remove = flexfb_remove_spi,\n};\n\nstatic const struct platform_device_id flexfb_platform_ids[] = {\n\t{ \"flexpfb\", 0 },\n\t{ },\n};\n\nstatic struct platform_driver flexfb_platform_driver = {\n\t.driver = {\n\t\t.name   = DRVNAME,\n\t\t.owner  = THIS_MODULE,\n\t},\n\t.id_table = flexfb_platform_ids,\n\t.probe  = flexfb_probe_pdev,\n\t.remove = flexfb_remove_pdev,\n};\n\nstatic int __init flexfb_init(void)\n{\n\tint ret, ret2;\n\n\tret = spi_register_driver(&flexfb_spi_driver);\n\tret2 = platform_driver_register(&flexfb_platform_driver);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret2;\n}\n\nstatic void __exit flexfb_exit(void)\n{\n\tspi_unregister_driver(&flexfb_spi_driver);\n\tplatform_driver_unregister(&flexfb_platform_driver);\n}\n\n/* ------------------------------------------------------------------------- */\n\nmodule_init(flexfb_init);\nmodule_exit(flexfb_exit);\n\nMODULE_DESCRIPTION(\"Generic FB driver for TFT LCD displays\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n"
        }
      ]
    }
  ]
}