{
  "metadata": {
    "timestamp": 1736710246696,
    "page": 992,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMDA=",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pellepl/spiffs",
      "stars": 1539,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2138671875,
          "content": "language: c\n\ncompiler:\n  - gcc\n\nbefore_script:\n\nscript: >\n  make all && make clean && make test && make build-all &&\n  make clean test FLAGS=-DSPIFFS_OBJ_META_LEN=8 &&\n  make clean test FLAGS=-DSPIFFS_NO_BLIND_WRITES=1\n"
        },
        {
          "name": "FUZZING.md",
          "type": "blob",
          "size": 1.55859375,
          "content": "# Fuzzing SPIFFS\n\nThe SPIFFS test suite includes a test program designed for fuzzing with\n[AFL](http://lcamtuf.coredump.cx/afl/). This automatically exercises the \nSPIFFS API and verifies that the file system does not crash or interact incorrectly\nwith the flash chip. \n\nThere are two steps to fuzzing. The first is to build the test suite with\nthe AFL version of gcc. The CC variable should point to your copy of afl-gcc.\n\n```\nmake clean test CC=/usr/local/bin/afl-gcc\n```\n\nThere is a new test `afl_test` that reads from stdin a list of commands\nand arguments. These are interpreted and executed on the API. The `afltests`\ndirectory contains a number of test cases that can be fed to the `afl_test` test.\n\n\nThe second is to run this test suite under afl as follows (where findings is \nthe output directory):\n\n```\nafl-fuzz -i afltests -o findings ./build/linux_spiffs_test -f afl_test\n```\n\nThis run will take hours (or days) and will (hopefully) not find any crashes.\nIf a crash (or hang) is found, then the input file that caused the crash is \nsaved. This allows the specific test case to be debugged.\n\n## Reducing the size of the file\n\nAFL comes with `afl-tmin` which can reduce the size of the test input file to\nmake it easier to debug.\n\n```\nafl-tmin -i findings/crashes/<somefile> -o smalltest -- build/linux_spiffs_test -f afl_test\n```\n\nThis will write a short version of the testcase file to `smalltest`. This can then be\nfed into the test program for debugging:\n\n```\nbuild/linux_spiffs_test -f afl_test < smalltest\n```\n\nThis should still crash, but allows it to be run under a debugger. \n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0908203125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-2017 Peter Andersson (pelleplutt1976<at>gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.9609375,
          "content": "# SPIFFS (SPI Flash File System) \n**V0.3.7**\n\n[![Build Status](https://travis-ci.org/pellepl/spiffs.svg?branch=master)](https://travis-ci.org/pellepl/spiffs)\n\nCopyright (c) 2013-2017 Peter Andersson (pelleplutt1976 at gmail.com)\n\nFor legal stuff, see [LICENSE](https://github.com/pellepl/spiffs/blob/master/LICENSE). Basically, you may do whatever you want with the source. Use, modify, sell, print it out, roll it and smoke it - as long as I won't be held responsible.\n\nLove to hear feedback though!\n\n\n## INTRODUCTION\n\nSpiffs is a file system intended for SPI NOR flash devices on embedded targets.\n\nSpiffs is designed with following characteristics in mind:\n - Small (embedded) targets, sparse RAM without heap\n - Only big areas of data (blocks) can be erased\n - An erase will reset all bits in block to ones\n - Writing pulls one to zeroes\n - Zeroes can only be pulled to ones by erase\n - Wear leveling\n\n\n## BUILDING\n\n`mkdir build; make`\n\nOtherwise, configure the `builddir` variable towards the top of `makefile` as something opposed to the default `build`. Sanity check on the host via `make test` and refer to `.travis.yml` for the official in-depth testing procedure. See the wiki for [integrating](https://github.com/pellepl/spiffs/wiki/Integrate-spiffs) spiffs into projects and [spiffsimg](https://github.com/nodemcu/nodemcu-firmware/tree/master/tools/spiffsimg) from [nodemcu](https://github.com/nodemcu) is a good example on the subject.\n\n\n## FEATURES\n\nWhat spiffs does:\n - Specifically designed for low ram usage\n - Uses statically sized ram buffers, independent of number of files\n - Posix-like api: open, close, read, write, seek, stat, etc\n - It can run on any NOR flash, not only SPI flash - theoretically also on embedded flash of a microprocessor\n - Multiple spiffs configurations can run on same target - and even on same SPI flash device\n - Implements static wear leveling \n - Built in file system consistency checks\n - Highly configurable\n \nWhat spiffs does not:\n - Presently, spiffs does not support directories. It produces a flat structure. Creating a file with path *tmp/myfile.txt* will create a file called *tmp/myfile.txt* instead of a *myfile.txt* under directory *tmp*. \n - It is not a realtime stack. One write operation might last much longer than another.\n - Poor scalability. Spiffs is intended for small memory devices - the normal sizes for SPI flashes. Going beyond ~128Mbyte is probably a bad idea. This is a side effect of the design goal to use as little ram as possible.\n - Presently, it does not detect or handle bad blocks.\n - One configuration, one binary. There's no generic spiffs binary that handles all types of configurations.\n\n## NOTICE\n\n0.4.0 is under construction. This is a full rewrite and will change the underlying structure. Hence, it will not be compatible with earlier versions of the filesystem. The API is the same, with minor modifications. Some config flags will be removed (as they are mandatory in 0.4.0) and some features might fall away until 0.4.1. If you have any worries or questions, it can be discussed in issue [#179](https://github.com/pellepl/spiffs/issues/179)\n \n## MORE INFO \n \nSee the [wiki](https://github.com/pellepl/spiffs/wiki) for [configuring](https://github.com/pellepl/spiffs/wiki/Configure-spiffs), [integrating](https://github.com/pellepl/spiffs/wiki/Integrate-spiffs), [using](https://github.com/pellepl/spiffs/wiki/Using-spiffs), and [optimizing](https://github.com/pellepl/spiffs/wiki/Performance-and-Optimizing) spiffs.\n \nFor design, see [docs/TECH_SPEC](https://github.com/pellepl/spiffs/blob/master/docs/TECH_SPEC).\n\nFor a generic spi flash driver, see [this](https://github.com/pellepl/spiflash_driver).\n\n## HISTORY\n\n### 0.3.7\n- fixed prevent seeking to negative offsets #158\n- fixed file descriptor offsets not updated for multiple fds on same file #157\n- fixed cache page not closed for removed files #156\n- fixed a lseek bug when seeking exactly to end of a fully indexed first level LUT #148\n- fixed wear leveling issue #145\n- fixed attempt to write out of bounds in flash #130, \n- set file offset when seeking over end #121 (thanks @sensslen)\n- fixed seeking in virgin files #120 (thanks @sensslen)\n- Optional file metadata #128 (thanks @cesanta)\n- AFL testing framework #100 #143 (thanks @pjsg)\n- Testframe updates\n\nNew API functions:\n- `SPIFFS_update_meta, SPIFFS_fupdate_meta` - updates metadata for a file\n\nNew config defines:\n- `SPIFFS_OBJ_META_LEN` - enable possibility to add extra metadata to files\n\n### 0.3.6\n- Fix range bug in index memory mapping #98\n- Add index memory mapping #97\n- Optimize SPIFFS_read for large files #96\n- Add temporal cache for opening files #95\n- More robust gc #93 (thanks @dismirlian)\n- Fixed a double write of same data in certain cache situations\n- Fixed an open bug in READ_ONLY builds\n- File not visible in SPIFFS_readdir #90 (thanks @benpicco-tmp)\n- Cache load code cleanup #92 (thanks @niclash)\n- Fixed lock/unlock asymmetry #88 #87 (thanks @JackJefferson, @dpruessner)\n- Testframe updates\n\nNew API functions:\n- `SPIFFS_ix_map` - map index meta data to memory for a file\n- `SPIFFS_ix_unmap` - unmaps index meta data for a file\n- `SPIFFS_ix_remap` - changes file offset for index metadata map\n- `SPIFFS_bytes_to_ix_map_entries` - utility, get length of needed vector for given amount of bytes\n- `SPIFFS_ix_map_entries_to_bytes` - utility, get number of bytes a vector can represent given length\n \nNew config defines:\n- `SPIFFS_IX_MAP` - enable possibility to map index meta data to memory for reading faster \n- `SPIFFS_TEMPORAL_FD_CACHE` - enable temporal cache for opening files faster\n- `SPIFFS_TEMPORAL_CACHE_HIT_SCORE` - for tuning the temporal cache\n\n### 0.3.5\n- Fixed a bug in fs check\n- API returns actual error codes #84) (thanks @Nails)\n- Fix compiler warnings for non-gcc #83 #81 (thanks @Nails)\n- Unable to recover from full fs #82 (thanks @rojer)\n- Define SPIFFS_O_* flags #80\n- Problem with long filenames #79 (thanks @psjg)\n- Duplicate file name bug fix #74 (thanks @igrr)\n- SPIFFS_eof and SPIFFS_tell return wrong value #72 (thanks @ArtemPisarenko)\n- Bunch of testframe updates #77 #78 #86 (thanks @dpreussner, @psjg a.o)  \n\n### 0.3.4\n- Added user callback file func.\n- Fixed a stat bug with obj id.\n- SPIFFS_probe_fs added\n- Add possibility to compile a read-only version of spiffs\n- Make magic dependent on fs length, if needed (see #59 & #66) (thanks @hreintke)\n- Exposed SPIFFS_open_by_page_function\n- Zero-size file cannot be seek #57 (thanks @lishen2)\n- Add tell and eof functions #54 (thanks @raburton)\n- Make api string params const #53 (thanks @raburton)\n- Preserve user_data during mount() #51 (thanks @rojer)\n\nNew API functions:\n- `SPIFFS_set_file_callback_func` - register a callback informing about file events\n- `SPIFFS_probe_fs` - probe a spi flash trying to figure out size of fs\n- `SPIFFS_open_by_page` - open a file by page index\n- `SPIFFS_eof` - checks if end of file is reached\n- `SPIFFS_tell` - returns current file offset\n\nNew config defines:\n- `SPIFFS_READ_ONLY`\n- `SPIFFS_USE_MAGIC_LENGTH`\n\n### 0.3.3\n**Might not be compatible with 0.3.2 structures. See issue #40**\n- Possibility to add integer offset to file handles\n- Truncate function presumes too few free pages #49\n- Bug in truncate function #48 (thanks @PawelDefee)\n- Update spiffs_gc.c - remove unnecessary parameter (thanks @PawelDefee)\n- Update INTEGRATION docs (thanks @PawelDefee)\n- Fix pointer truncation in 64-bit platforms (thanks @igrr)\n- Zero-sized files cannot be read #44 (thanks @rojer)\n- (More) correct calculation of max_id in obj_lu_find #42 #41 (thanks @lishen2)\n- Check correct error code in obj_lu_find_free #41 (thanks @lishen2)\n- Moar comments for SPIFFS_lseek (thanks @igrr)\n- Fixed padding in spiffs_page_object_ix #40 (thanks @jmattsson @lishen2)\n- Fixed gc_quick test (thanks @jmattsson)\n- Add SPIFFS_EXCL flag #36 \n- SPIFFS_close may fail silently if cache is enabled #37 \n- User data in callbacks #34\n- Ignoring SINGLETON build in cache setup (thanks Luca)\n- Compilation error fixed #32 (thanks @chotasanjiv)\n- Align cand_scores (thanks @hefloryd)\n- Fix build warnings when SPIFFS_CACHE is 0 (thanks @ajaybhargav)\n\nNew config defines:\n- `SPIFFS_FILEHDL_OFFSET`\n\n### 0.3.2\n- Limit cache size if too much cache is given (thanks pgeiem)\n- New feature - Controlled erase. #23\n- SPIFFS_rename leaks file descriptors #28 (thanks benpicco)\n- moved dbg print defines in test framework to params_test.h\n- lseek should return the resulting offset (thanks hefloryd)\n- fixed type on dbg ifdefs\n- silence warning about signed/unsigned comparison when spiffs_obj_id is 32 bit (thanks benpicco)\n- Possible error in test_spiffs.c #21 (thanks yihcdaso-yeskela)\n- Cache might writethrough too often #16\n- even moar testrunner updates\n- Test framework update and some added tests\n- Some thoughts for next gen\n- Test sigsevs when having too many sectors #13  (thanks alonewolfx2)\n- GC might be suboptimal #11\n- Fix eternal readdir when objheader at last block, last entry\n  \nNew API functions:\n- `SPIFFS_gc_quick` - call a nonintrusive gc\n- `SPIFFS_gc` - call a full-scale intrusive gc\n\n### 0.3.1\n- Removed two return warnings, was too triggerhappy on release\n\n### 0.3.0\n- Added existing namecheck when creating files\n- Lots of static analysis bugs #6\n- Added rename func\n- Fix SPIFFS_read length when reading beyond file size\n- Added reading beyond file length testcase\n- Made build a bit more configurable\n- Changed name in spiffs from \"errno\" to \"err_code\" due to conflicts compiling in mingw\n- Improved GC checks, fixed an append bug, more robust truncate for very special case\n- GC checks preempts GC, truncate even less picky\n- Struct alignment needed for some targets, define in spiffs config #10\n- Spiffs filesystem magic, definable in config\n\nNew config defines:\n- `SPIFFS_USE_MAGIC` - enable or disable magic check upon mount\n- `SPIFFS_ALIGNED_OBJECT_INDEX_TABLES` - alignment for certain targets\n\nNew API functions:\n- `SPIFFS_rename` - rename files\n- `SPIFFS_clearerr` - clears last errno\n- `SPIFFS_info` - returns info on used and total bytes in fs\n- `SPIFFS_format` - formats the filesystem\n- `SPIFFS_mounted` - checks if filesystem is mounted\n"
        },
        {
          "name": "afltests",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "files.mk",
          "type": "blob",
          "size": 0.3173828125,
          "content": "ifndef spiffs\n$(warn defaulting path to generic spiffs module, spiffs variable not set)\nspiffs = ../generic/spiffs\nendif\nFLAGS\t+= -DCONFIG_BUILD_SPIFFS\nINC\t+= -I${spiffs}/src\nCPATH\t+= ${spiffs}/src\nCFILES\t+= spiffs_nucleus.c\nCFILES\t+= spiffs_gc.c\nCFILES\t+= spiffs_hydrogen.c\nCFILES\t+= spiffs_cache.c\nCFILES\t+= spiffs_check.c\n"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 3.6953125,
          "content": "BINARY = linux_spiffs_test\n\n############\n#\n# Paths\n#\n############\n\nsourcedir = src\nbuilddir = build\n\n\n#############\n#\n# Build tools\n#\n#############\n\nCC ?= gcc\nLD ?= ld\nGDB ?= gdb\nOBJCOPY ?= objcopy\nOBJDUMP ?= objdump\nMKDIR ?= mkdir -p\n\n###############\n#\n# Files and libs\n#\n###############\n\nNO_TEST ?= 0\nCFLAGS = $(FLAGS)\nifeq (1, $(strip $(NO_TEST)))\nCFILES_TEST = main.c\nCFLAGS += -DNO_TEST -Werror\nelse\nCFILES_TEST = main.c \\\n\ttest_spiffs.c \\\n\ttest_dev.c \\\n\ttest_check.c \\\n\ttest_hydrogen.c \\\n\ttest_bugreports.c \\\n\ttestsuites.c \\\n\ttestrunner.c\nCFLAGS += -D_SPIFFS_TEST\nendif\ninclude files.mk\nINCLUDE_DIRECTIVES = -I./${sourcedir} -I./${sourcedir}/default -I./${sourcedir}/test \nCOMPILEROPTIONS = $(INCLUDE_DIRECTIVES)\n\nCOMPILEROPTIONS_APP = $(INCLUDE_DIRECTIVES) \\\n-Wall -Wno-format-y2k -W -Wstrict-prototypes -Wmissing-prototypes \\\n-Wpointer-arith -Wreturn-type -Wcast-qual -Wwrite-strings -Wswitch \\\n-Wshadow -Wcast-align -Wchar-subscripts -Winline -Wnested-externs\\\n-Wredundant-decls\n\t\t\n############\n#\n# Tasks\n#\n############\n\nvpath %.c ${sourcedir} ${sourcedir}/default ${sourcedir}/test\n\nOBJFILES = $(CFILES:%.c=${builddir}/%.o)\nOBJFILES_TEST = $(CFILES_TEST:%.c=${builddir}/%.o)\n\nDEPFILES = $(CFILES:%.c=${builddir}/%.d) $(CFILES_TEST:%.c=${builddir}/%.d)\n\nALLOBJFILES += $(OBJFILES) $(OBJFILES_TEST)\n\nDEPENDENCIES = $(DEPFILES) \n\n# link object files, create binary\n$(BINARY): $(ALLOBJFILES)\n\t@echo \"... linking\"\n\t@${CC} $(LINKEROPTIONS) -o ${builddir}/$(BINARY) $(ALLOBJFILES) $(LIBS)\nifeq (1, $(strip $(NO_TEST)))\n\t@echo \"size: `du -b ${builddir}/${BINARY} | sed 's/\\([0-9]*\\).*/\\1/g '` bytes\"\nendif\n\n\n-include $(DEPENDENCIES)\t   \t\n\n# compile c files\n$(OBJFILES) : ${builddir}/%.o:%.c\n\t\t@echo \"... compile $@\"\n\t\t@${CC} $(COMPILEROPTIONS_APP) $(CFLAGS) -g -c -o $@ $<\n\n$(OBJFILES_TEST) : ${builddir}/%.o:%.c\n\t\t@echo \"... compile $@\"\n\t\t@${CC} ${COMPILEROPTIONS} $(CFLAGS) -g -c -o $@ $<\n\n# make dependencies\n#\t\t@echo \"... depend $@\"; \n$(DEPFILES) : ${builddir}/%.d:%.c\n\t\t@rm -f $@; \\\n\t\t${CC} $(COMPILEROPTIONS) -M $< > $@.$$$$; \\\n\t\tsed 's,\\($*\\)\\.o[ :]*, ${builddir}/\\1.o $@ : ,g' < $@.$$$$ > $@; \\\n\t\trm -f $@.$$$$\n\nall: mkdirs $(BINARY) \n\nmkdirs:\n\t-@${MKDIR} ${builddir}\n\t-@${MKDIR} test_data\n\nFILTER ?=\n\ntest: $(BINARY)\nifdef $(FILTER)\n\t\t./build/$(BINARY)\nelse\n\t\t./build/$(BINARY) -f $(FILTER)\nendif\n\ntest_failed: $(BINARY)\n\t\t./build/$(BINARY) _tests_fail\n\t\nclean:\n\t@echo ... removing build files in ${builddir}\n\t@rm -f ${builddir}/*.o\n\t@rm -f ${builddir}/*.d\n\t@rm -f ${builddir}/*.elf\n\t\nONOFF = 1 0\nOFFON = 0 1\nbuild-all:\n\t@for rdonly in $(ONOFF); do \\\n\t\tfor singleton in $(ONOFF); do \\\n\t\t\tfor hal_cb_xtra in $(OFFON); do \\\n\t\t\t\tfor cache in $(OFFON); do \\\n\t\t\t\t\tfor magic in $(OFFON); do \\\n\t\t\t\t\t\tfor temporal_cache in $(OFFON); do \\\n  \t\t\t\t\t\tfor ix_map in $(OFFON); do \\\n  \t\t\t\t\t\t\techo; \\\n  \t\t\t\t\t\t\techo ============================================================; \\\n  \t\t\t\t\t\t\techo SPIFFS_READ_ONLY=$$rdonly; \\\n  \t\t\t\t\t\t\techo SPIFFS_SINGLETON=$$singleton; \\\n  \t\t\t\t\t\t\techo SPIFFS_HAL_CALLBACK_EXTRA=$$hal_cb_xtra; \\\n  \t\t\t\t\t\t\techo SPIFFS_CACHE, SPIFFS_CACHE_WR=$$cache; \\\n  \t\t\t\t\t\t\techo SPIFFS_USE_MAGIC, SPIFFS_USE_MAGIC_LENGTH=$$magic; \\\n  \t\t\t\t\t\t\techo SPIFFS_TEMPORAL_FD_CACHE=$$temporal_cache; \\\n  \t\t\t\t\t\t\techo SPIFFS_IX_MAP=$$ix_map; \\\n  \t\t\t\t\t\t\t$(MAKE) clean && $(MAKE) FLAGS=\"\\\n  \t\t\t\t\t\t\t\t-DSPIFFS_HAL_CALLBACK_EXTRA=$$hal_cb_xtra \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_SINGLETON=$$singleton \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_CACHE=$$cache \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_CACHE_WR=$$cache \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_READ_ONLY=$$rdonly \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_USE_MAGIC=$$magic \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_USE_MAGIC_LENGTH=$$magic \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_TEMPORAL_FD_CACHE=$$temporal_cache \\\n  \t\t\t\t\t\t\t\t-DSPIFFS_IX_MAP=$$ix_map \\\n  \t\t\t\t\t\t\t\t\" NO_TEST=1; \\\n  \t\t\t\t\t\tdone || exit 1; \\\n\t\t\t\t\t\tdone \\\n\t\t\t\t\tdone \\\n\t\t\t\tdone \\\n\t\t\tdone \\\n\t\tdone \\\n\tdone \n"
        },
        {
          "name": "py",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}