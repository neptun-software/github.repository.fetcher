{
  "metadata": {
    "timestamp": 1736710150381,
    "page": 811,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symisc/sod",
      "stars": 1760,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.041015625,
          "content": "language: c\r\ncompiler: clang\r\nscript: make"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.9912109375,
          "content": "/*\n* SOD - An Embedded Computer Vision & Machine Learning Library.\n* Copyright (C) 2018 - 2020 PixLab| Symisc Systems. https://sod.pixlab.io\n* Version 1.1.8\n*\n* Symisc Systems employs a dual licensing model that offers customers\n* a choice of either our open source license (GPLv3) or a commercial\n* license.\n*\n* For information on licensing, redistribution of the SOD library, and for a DISCLAIMER OF ALL WARRANTIES\n* please visit:\n*     https://pixlab.io/sod\n* or contact:\n*     licensing@symisc.net\n*     support@pixlab.io\n*/\n---------------------------------------------------------------------------------------\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) 2018  2018 PixLab| Symisc Systems. https://sod.pixlab.io\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    Symisc SOD  Copyright (C) 2018  2018 PixLab| Symisc Systems. https://sod.pixlab.io\n\t\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2890625,
          "content": "# SOD does not generally require a Makefile to build. Just drop sod.c and its accompanying\r\n# header files on your source tree and you are done.\r\nCC = clang\r\nCFLAGS = -lm -Ofast -march=native -Wall -std=c99\r\n\r\nsod: sod.c\r\n\t$(CC) sod.c samples/cnn_face_detection.c -o sod_face_detect -I. $(CFLAGS)"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.2392578125,
          "content": "<h1 align=\"center\">SOD<br/><br/>An Embedded Computer Vision & Machine Learning Library<br/><a href=\"https://sod.pixlab.io\">sod.pixlab.io</a></h1>\n\n[![API documentation](https://img.shields.io/badge/API%20documentation-Ready-green.svg)](https://sod.pixlab.io/api.html)\n[![dependency](https://img.shields.io/badge/dependency-none-ff96b4.svg)](https://pixlab.io/downloads)\n[![Getting Started](https://img.shields.io/badge/Getting%20Started-Now-f49242.svg)](https://sod.pixlab.io/intro.html)\n[![license](https://img.shields.io/badge/License-dual--licensed-blue.svg)](https://pixlab.io/downloads)\n[![Forum](https://img.shields.io/gitter/room/nwjs/nw.js.svg)](https://community.faceio.net/)\n[![Tiny Dreal](https://pixlab.io/images/logo.png)](https://pixlab.io/tiny-dream)\n\n![Output](https://i.imgur.com/YIbb8wr.jpg)\n\n* [Introduction](#sod-embedded).\n* [Features](#notable-sod-features).\n* [Programming with SOD](#programming-interfaces).\n* [Useful Links](#other-useful-links).\n\n## SOD Embedded\n\n### Release 1.1.9 (July 2023) | [Changelog](https://sod.pixlab.io/changelog.html) |  [Downloads](https://pixlab.io/downloads)\n\nSOD is an embedded, modern cross-platform computer vision and machine learning software library that exposes a set of APIs for deep-learning, advanced media analysis & processing including real-time, multi-class object detection and model training on embedded systems with limited computational resource and IoT devices.\n\nSOD was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in open source as well commercial products.\n\nDesigned for computational efficiency and with a strong focus on real-time applications. SOD includes a comprehensive set of both classic and state-of-the-art deep-neural networks with their <a href=\"https://pixlab.io/downloads\">pre-trained models</a>. Built with SOD:\n* <a href=\"https://sod.pixlab.io/intro.html#cnn\">Convolutional Neural Networks (CNN)</a> for multi-class (20 and 80) object detection & classification.\n* <a href=\"https://sod.pixlab.io/api.html#cnn\">Recurrent Neural Networks (RNN)</a> for text generation (i.e. Shakespeare, 4chan, Kant, Python code, etc.).\n* <a href=\"https://sod.pixlab.io/samples.html\">Decision trees</a> for single class, real-time object detection.\n* A brand new architecture written specifically for SOD named <a href=\"https://sod.pixlab.io/intro.html#realnets\">RealNets</a>.\n\n![Multi-class object detection](https://i.imgur.com/Mq98uTv.png) \n\nCross platform, dependency free, amalgamated (single C file) and heavily optimized. Real world use cases includes:\n* Detect & recognize objects (faces included) at Real-time.\n* License plate extraction.\n* Intrusion detection.\n* Mimic Snapchat filters.\n* Classify human actions.\n* Object identification.\n* Eye & Pupil tracking.\n* Facial & Body shape extraction.\n* Image/Frame segmentation.\n\n## Notable SOD features\n\n* Built for real world and real-time applications.\n* State-of-the-art, CPU optimized deep-neural networks including the brand new, exclusive <a href=\"https://sod.pixlab.io/intro.html#realnets\">RealNets architecture</a>.\n* Patent-free, advanced computer vision <a href=\"https://sod.pixlab.io/samples.html\">algorithms</a>.\n* Support major <a href=\"https://sod.pixlab.io/api.html#imgproc\">image format</a>.\n* Simple, clean and easy to use <a href=\"https://sod.pixlab.io/api.html\">API</a>.\n* Brings deep learning on limited computational resource, embedded systems and IoT devices.\n* Easy interpolatable with <a href=\"https://sod.pixlab.io/api.html#cvinter\">OpenCV</a> or any other proprietary API.\n* <a href=\"https://pixlab.io/downloads\">Pre-trained models</a> available for most architectures.</li>\n* CPU capable, <a href=\"https://sod.pixlab.io/c_api/sod_realnet_train_start.html\">RealNets model training</a>.\n* Production ready, cross-platform, high quality source code.\n* SOD is dependency free, written in C, compile and run unmodified on virtually any platform &amp; architecture with a decent C compiler.\n* <a href=\"https://pixlab.io/downloads\">Amalgamated</a> - All SOD source files are combined into a single C file (*sod.c*) for easy deployment.\n* Open-source, actively developed & maintained product.\n* Developer friendly <a href=\"https://sod.pixlab.io/support.html\">support channels.</a>\n\n## Programming Interfaces\n\nThe documentation works both as an API reference and a programming tutorial. It describes the internal structure of the library and guides one in creating applications with a few lines of code. Note that SOD is straightforward to learn, even for new programmer.\n\n Resources |  Description\n------------ | -------------\n<a href=\"https://sod.pixlab.io/intro.html\">SOD in 5 minutes or less</a> | A quick introduction to programming with the SOD Embedded C/C++ API with real-world code samples implemented in C.\n<a href=\"https://sod.pixlab.io/api.html\">C/C++ API Reference Guide</a> | This document describes each API function in details. This is the reference document you should rely on.\n<a href=\"https://sod.pixlab.io/samples.html\">C/C++ Code Samples</a> | Real world code samples on how to embed, load models and start experimenting with SOD.\n<a href=\"https://sod.pixlab.io/articles/license-plate-detection.html\">License Plate Detection</a> | Learn how to detect vehicles license plates without heavy Machine Learning techniques, just standard image processing routines already implemented in SOD.\n<a href=\"https://sod.pixlab.io/articles/porting-c-face-detector-webassembly.html\">Porting our Face Detector to WebAssembly</a> | Learn how we ported the <a href=\"https://sod.pixlab.io/c_api/sod_realnet_detect.html\">SOD Realnets face detector</a> into WebAssembly to achieve Real-time performance in the browser.\n\n## Other useful links\n\n Resources |  Description\n------------ | -------------\n<a href=\"https://pixlab.io/downloads\">Downloads</a> | Get a copy of the last public release of SOD, pre-trained models, extensions and more. Start embedding and enjoy programming with.\n<a href=\"https://pixlab.io/sod\">Copyright/Licensing</a> | SOD is an open-source, dual-licensed product. Find out more about the licensing situation there.\n<a href=\"https://sod.pixlab.io/support.html\">Online Support Channels</a> | Having some trouble integrating SOD? Take a look at our numerous support channels.\n\n![face detection using RealNets](https://i.imgur.com/ZLno8Lz.jpg)\n"
        },
        {
          "name": "WebAssemby",
          "type": "tree",
          "content": null
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "sod.c",
          "type": "blob",
          "size": 409.302734375,
          "content": "/*\r\n* SOD - An Embedded Computer Vision & Machine Learning Library.\r\n* Copyright (C) 2018 - 2023 PixLab| Symisc Systems. https://sod.pixlab.io\r\n* Version 1.1.8\r\n*\r\n* Symisc Systems employs a dual licensing model that offers customers\r\n* a choice of either our open source license (GPLv3) or a commercial\r\n* license.\r\n*\r\n* For information on licensing, redistribution of the SOD library, and for a DISCLAIMER OF ALL WARRANTIES\r\n* please visit:\r\n*     https://pixlab.io/sod\r\n* or contact:\r\n*     licensing@symisc.net\r\n*     support@pixlab.io\r\n*/\r\n/*\r\n* This file is part of Symisc SOD - Open Source Release (GPLv3)\r\n*\r\n* SOD is free software : you can redistribute it and/or modify\r\n* it under the terms of the GNU General Public License as published by\r\n* the Free Software Foundation, either version 3 of the License, or\r\n* (at your option) any later version.\r\n*\r\n* SOD is distributed in the hope that it will be useful,\r\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\r\n* GNU General Public License for more details.\r\n*\r\n* You should have received a copy of the GNU General Public License\r\n* along with SOD. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n/* $SymiscID: sod.c v1.1.9 Win10 2023-07-26 02:50 stable <devel@symisc.net> $ */\r\n#ifdef _MSC_VER\r\n#ifndef _CRT_SECURE_NO_WARNINGS\r\n/*\r\n* Ignore Microsoft compilers warnings on fopen() which is used only\r\n* by the CNN layer for reading SOD models or saving Realnets models to disk.\r\n*/\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif /*_CRT_SECURE_NO_WARNINGS*/\r\n/* Disable the double to float warning */\r\n#pragma warning(disable:4244)\r\n#pragma warning(disable:4305)\r\n#endif /* _MSC_VER */\r\n/* Standard C library includes */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <stdint.h>\r\n#include <ctype.h>\r\n#ifdef SOD_MEM_DEBUG\r\n/* Memory leak detection which is done under Visual Studio only */\r\n#define _CRTDBG_MAP_ALLOC\r\n#include <crtdbg.h>\r\n#endif /* SOD_MEM_DEBUG */\r\n#include <float.h>\r\n#ifndef _USE_MATH_DEFINES\r\n#define _USE_MATH_DEFINES\r\n#endif /* _USE_MATH_DEFINES */\r\n#include <math.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n/* Local includes */\r\n#include \"sod.h\"\r\n/* Forward declaration */\r\ntypedef struct SySet SySet;\r\ntypedef struct SyBlob SyBlob;\r\ntypedef struct SyString SyString;\r\ntypedef struct sod_vfs sod_vfs;\r\n/*\r\n* A generic dynamic set.\r\n*/\r\nstruct SySet\r\n{\r\n\tvoid *pBase;               /* Base pointer */\r\n\tsize_t nUsed;              /* Total number of used slots  */\r\n\tsize_t nSize;              /* Total number of available slots */\r\n\tsize_t eSize;              /* Size of a single slot */\r\n\tvoid *pUserData;           /* User private data associated with this container */\r\n};\r\n#define SySetBasePtr(S)           ((S)->pBase)\r\n#define SySetBasePtrJump(S, OFFT)  (&((char *)(S)->pBase)[OFFT*(S)->eSize])\r\n#define SySetUsed(S)              ((S)->nUsed)\r\n#define SySetSize(S)              ((S)->nSize)\r\n#define SySetElemSize(S)          ((S)->eSize)\r\n#define SySetSetUserData(S, DATA)  ((S)->pUserData = DATA)\r\n#define SySetGetUserData(S)       ((S)->pUserData)\r\n/*\r\n* A variable length containers for generic data (Mostly dynamic string).\r\n*/\r\nstruct SyBlob\r\n{\r\n\tvoid   *pBlob;\t          /* Base pointer */\r\n\tsize_t  nByte;\t          /* Total number of used bytes */\r\n\tsize_t  mByte;\t          /* Total number of available bytes */\r\n\tint  nFlags;\t          /* Blob internal flags, see below */\r\n};\r\n/*\r\n* Container for non null terminated strings.\r\n*/\r\nstruct SyString\r\n{\r\n\tconst char *zString;  /* Raw string (May not be null terminated) */\r\n\tsize_t     nByte;     /* Raw string length */\r\n};\r\n#define SXBLOB_LOCKED\t0x01\t/* Blob is locked [i.e: Cannot auto grow] */\r\n#define SXBLOB_STATIC\t0x02\t/* Not allocated from heap   */\r\n#define SXBLOB_RDONLY   0x04    /* Read-Only data */\r\n\r\n#define SyBlobFreeSpace(BLOB)\t ((BLOB)->mByte - (BLOB)->nByte)\r\n#define SyBlobLength(BLOB)\t     ((BLOB)->nByte)\r\n#define SyBlobData(BLOB)\t     ((BLOB)->pBlob)\r\n#define SyBlobCurData(BLOB)\t     ((void*)(&((char*)(BLOB)->pBlob)[(BLOB)->nByte]))\r\n#define SyBlobDataAt(BLOB, OFFT)\t ((void *)(&((char *)(BLOB)->pBlob)[OFFT]))\r\n#define SyBlobGetAllocator(BLOB) ((BLOB)->pAllocator)\r\n#define SyStringData(RAW)\t((RAW)->zString)\r\n#define SyStringLength(RAW)\t((RAW)->nByte)\r\n#define SyStringInitFromBuf(RAW, ZBUF, NLEN){\\\r\n\t(RAW)->zString \t= (const char *)ZBUF;\\\r\n\t(RAW)->nByte\t= (size_t)(NLEN);\\\r\n}\r\n#define SyStringDupPtr(RAW1, RAW2)\\\r\n\t(RAW1)->zString = (RAW2)->zString;\\\r\n\t(RAW1)->nByte = (RAW2)->nByte;\r\n\r\n#define SyStringTrimLeadingChar(RAW, CHAR)\\\r\n\twhile((RAW)->nByte > 0 && (RAW)->zString[0] == CHAR ){\\\r\n\t\t\t(RAW)->zString++;\\\r\n\t\t\t(RAW)->nByte--;\\\r\n\t}\r\n#define SyStringTrimTrailingChar(RAW, CHAR)\\\r\n\twhile((RAW)->nByte > 0 && (RAW)->zString[(RAW)->nByte - 1] == CHAR){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t}\r\n#define SyStringCmp(RAW1, RAW2, xCMP)\\\r\n\t(((RAW1)->nByte == (RAW2)->nByte) ? xCMP((RAW1)->zString, (RAW2)->zString, (RAW2)->nByte) : (int)((RAW1)->nByte - (RAW2)->nByte))\r\n/*\r\n* value pathinfo(string $path [,int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ])\r\n* Returns information about a file path.\r\n* Taken from the Symisc PH7 source tree, http://ph7.symisc.net\r\n*/\r\ntypedef struct sod_path_info sod_path_info;\r\nstruct sod_path_info\r\n{\r\n\tSyString sDir; /* Directory [i.e: /var/www] */\r\n\tSyString sBasename; /* Basename [i.e httpd.conf] */\r\n\tSyString sExtension; /* File extension [i.e xml,pdf..] */\r\n\tSyString sFilename;  /* Filename */\r\n};\r\n#ifndef MAX\r\n#define MAX(a, b) ((a)>(b)?(a):(b))\r\n#endif /* MAX */\r\n#ifndef MIN\r\n#define MIN(a, b) ((a)<(b)?(a):(b))\r\n#endif /* MIN */\r\n/*\r\n* CAPIREF: OS Interface Object\r\n*\r\n* An instance of the sod_vfs object defines the interface between\r\n* the sod core and the underlying operating system.  The \"vfs\"\r\n* in the name of the object stands for \"Virtual File System\".\r\n*\r\n* Only a single vfs can be registered within the sod core.\r\n* Vfs registration is done using the [sod_lib_config()] interface\r\n* with a configuration verb set to LIBCOX_LIB_CONFIG_VFS.\r\n* Note that Windows and UNIX (Linux, FreeBSD, Solaris, Mac OS X, etc.) users\r\n* does not have to worry about registering and installing a vfs since sod\r\n* come with a built-in vfs for these platforms that implements most the methods\r\n* defined below.\r\n*\r\n* Clients running on exotic systems (ie: Other than Windows and UNIX systems)\r\n* must register their own vfs in order to be able to use the sod library.\r\n*\r\n* The value of the iVersion field is initially 1 but may be larger in\r\n* future versions of sod.\r\n*\r\n* The szOsFile field is the size of the subclassed [sod_file] structure\r\n* used by this VFS. mxPathname is the maximum length of a pathname in this VFS.\r\n*\r\n* At least szOsFile bytes of memory are allocated by sod to hold the [sod_file]\r\n* structure passed as the third argument to xOpen. The xOpen method does not have to\r\n* allocate the structure; it should just fill it in. Note that the xOpen method must\r\n* set the sod_file.pMethods to either a valid [sod_io_methods] object or to NULL.\r\n* xOpen must do this even if the open fails. sod expects that the sod_file.pMethods\r\n* element will be valid after xOpen returns regardless of the success or failure of the\r\n* xOpen call.\r\n*/\r\n#define LIBCOX_VFS_VERSION 2900 /* 2.9 */\r\nstruct sod_vfs {\r\n\tconst char *zName;       /* Name of this virtual file system [i.e: Windows, UNIX, etc.] */\r\n\tint iVersion;            /* Structure version number (currently 2.6) */\r\n\tint szOsFile;           \r\n\tint mxPathname;          /* Maximum file pathname length */\r\n\t\t\t\t\t\t\t /* Directory functions */\r\n\tint(*xChdir)(const char *);                     /* Change directory */\r\n\tint(*xGetcwd)(SyBlob *);                /* Get the current working directory */\r\n\tint(*xMkdir)(const char *, int, int);           /* Make directory */\r\n\tint(*xRmdir)(const char *);                     /* Remove directory */\r\n\tint(*xIsdir)(const char *);                     /* Tells whether the filename is a directory */\r\n\tint(*xRename)(const char *, const char *);       /* Renames a file or directory */\r\n\tint(*xRealpath)(const char *, SyBlob *);    /* Return canonicalized absolute pathname*/\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* Dir handle */\r\n\tint(*xOpenDir)(const char *, void **);    /* Open directory handle */\r\n\tvoid(*xCloseDir)(void *pHandle);                           /* Close directory handle */\r\n\tint(*xDirRead)(void *pHandle, SyBlob *);     /* Read the next entry from the directory handle */\r\n\tvoid(*xDirRewind)(void *pHandle);                   /* Rewind the cursor */\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Systems functions */\r\n\tint(*xUnlink)(const char *);                    /* Deletes a file */\r\n\tint(*xFileExists)(const char *);                /* Checks whether a file or directory exists */\r\n\tint64_t(*xFreeSpace)(const char *);        /* Available space on filesystem or disk partition */\r\n\tint64_t(*xTotalSpace)(const char *);       /* Total space on filesystem or disk partition */\r\n\tint64_t(*xFileSize)(const char *);         /* Gets file size */\r\n\tint(*xIsfile)(const char *);                    /* Tells whether the filename is a regular file */\r\n\tint(*xReadable)(const char *);                  /* Tells whether a file exists and is readable */\r\n\tint(*xWritable)(const char *);                  /* Tells whether the filename is writable */\r\n\tint(*xExecutable)(const char *);                /* Tells whether the filename is executable */\r\n\tint(*xGetenv)(const char *, SyBlob *);      /* Gets the value of an environment variable */\r\n\tint(*xSetenv)(const char *, const char *);       /* Sets the value of an environment variable */\r\n\tint(*xMmap)(const char *, void **, size_t *); /* Read-only memory map of the whole file */\r\n\tvoid(*xUnmap)(void *, size_t);                /* Unmap a memory view */\r\n\tvoid(*xTempDir)(SyBlob *);                 /* Get path of the temporary directory */\r\n\tfloat(*xTicks)();                          /* High precision timer */\r\n};\r\n/* @Implementation */\r\nstatic int SyBlobInit(SyBlob *pBlob)\r\n{\r\n\tpBlob->pBlob = 0;\r\n\tpBlob->mByte = pBlob->nByte = 0;\r\n\tpBlob->nFlags = 0;\r\n\treturn SOD_OK;\r\n}\r\n#ifndef SXBLOB_MIN_GROWTH\r\n#define SXBLOB_MIN_GROWTH 16\r\n#endif\r\nstatic int BlobPrepareGrow(SyBlob *pBlob, size_t *pByte)\r\n{\r\n\tsize_t nByte;\r\n\tvoid *pNew;\r\n\tnByte = *pByte;\r\n\tif (pBlob->nFlags & (SXBLOB_LOCKED | SXBLOB_STATIC)) {\r\n\t\tif (SyBlobFreeSpace(pBlob) < nByte) {\r\n\t\t\t*pByte = SyBlobFreeSpace(pBlob);\r\n\t\t\tif ((*pByte) == 0) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn SOD_OK;\r\n\t}\r\n\tif (pBlob->nFlags & SXBLOB_RDONLY) {\r\n\t\t/* Make a copy of the read-only item */\r\n\t\tif (pBlob->nByte > 0) {\r\n\t\t\tpNew = realloc(pBlob->pBlob, pBlob->nByte);\r\n\t\t\tif (pNew == 0) {\r\n\t\t\t\treturn SOD_OUTOFMEM;\r\n\t\t\t}\r\n\t\t\tpBlob->pBlob = pNew;\r\n\t\t\tpBlob->mByte = pBlob->nByte;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpBlob->pBlob = 0;\r\n\t\t\tpBlob->mByte = 0;\r\n\t\t}\r\n\t\t/* Remove the read-only flag */\r\n\t\tpBlob->nFlags &= ~SXBLOB_RDONLY;\r\n\t}\r\n\tif (SyBlobFreeSpace(pBlob) >= nByte) {\r\n\t\treturn SOD_OK;\r\n\t}\r\n\tif (pBlob->mByte > 0) {\r\n\t\tnByte = nByte + pBlob->mByte * 2 + SXBLOB_MIN_GROWTH;\r\n\t}\r\n\telse if (nByte < SXBLOB_MIN_GROWTH) {\r\n\t\tnByte = SXBLOB_MIN_GROWTH;\r\n\t}\r\n\tpNew = realloc(pBlob->pBlob, nByte);\r\n\tif (pNew == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tpBlob->pBlob = pNew;\r\n\tpBlob->mByte = nByte;\r\n\treturn SOD_OK;\r\n}\r\nstatic int SyBlobAppend(SyBlob *pBlob, const void *pData, size_t nSize)\r\n{\r\n\tuint8_t *zBlob;\r\n\tint rc;\r\n\tif (nSize < 1) {\r\n\t\treturn SOD_OK;\r\n\t}\r\n\trc = BlobPrepareGrow(&(*pBlob), &nSize);\r\n\tif (SOD_OK != rc) {\r\n\t\treturn rc;\r\n\t}\r\n\tif (pData) {\r\n\t\tzBlob = (uint8_t *)pBlob->pBlob;\r\n\t\tzBlob = &zBlob[pBlob->nByte];\r\n\t\tpBlob->nByte += nSize;\r\n\t\tmemcpy(zBlob, pData, nSize);\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n#define SyBlobStrAppend(pBlob,STR) SyBlobAppend(&(*pBlob), (const void *)STR,strlen(STR))\r\n#define SyBlobNullAppend(pBlob)   if( SOD_OK == SyBlobAppend(&(*pBlob), (const void *)\"\\0\", sizeof(char)) ){(pBlob)->nByte--;}\r\nstatic inline int SyBlobReset(SyBlob *pBlob)\r\n{\r\n\tpBlob->nByte = 0;\r\n\tif (pBlob->nFlags & SXBLOB_RDONLY) {\r\n\t\t/* Read-only (Not malloced chunk) */\r\n\t\tpBlob->pBlob = 0;\r\n\t\tpBlob->mByte = 0;\r\n\t\tpBlob->nFlags &= ~SXBLOB_RDONLY;\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\nstatic int SyBlobRelease(SyBlob *pBlob)\r\n{\r\n\tif ((pBlob->nFlags & (SXBLOB_STATIC | SXBLOB_RDONLY)) == 0 && pBlob->mByte > 0) {\r\n\t\tfree(pBlob->pBlob);\r\n\t}\r\n\tpBlob->pBlob = 0;\r\n\tpBlob->nByte = pBlob->mByte = 0;\r\n\tpBlob->nFlags = 0;\r\n\treturn SOD_OK;\r\n}\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\n/* SyRunTimeApi: sxfmt.c */\r\n#define SXFMT_BUFSIZ 1024 /* Conversion buffer size */\r\n/* Signature of the consumer routine */\r\ntypedef int(*ProcConsumer)(const void *, unsigned int, void *);\r\n/*\r\n** Conversion types fall into various categories as defined by the\r\n** following enumeration.\r\n*/\r\n#define SXFMT_RADIX       1 /* Integer types.%d, %x, %o, and so forth */\r\n#define SXFMT_FLOAT       2 /* Floating point.%f */\r\n#define SXFMT_EXP         3 /* Exponentional notation.%e and %E */\r\n#define SXFMT_GENERIC     4 /* Floating or exponential, depending on exponent.%g */\r\n#define SXFMT_SIZE        5 /* Total number of characters processed so far.%n */\r\n#define SXFMT_STRING      6 /* Strings.%s */\r\n#define SXFMT_PERCENT     7 /* Percent symbol.%% */\r\n#define SXFMT_CHARX       8 /* Characters.%c */\r\n#define SXFMT_ERROR       9 /* Used to indicate no such conversion type */\r\n/* Extension by Symisc Systems */\r\n#define SXFMT_RAWSTR     13 /* %z Pointer to raw string (SyString *) */\r\n#define SXFMT_UNUSED     15 \r\n/*\r\n** Allowed values for SyFmtInfo.flags\r\n*/\r\n#define SXFLAG_SIGNED\t0x01\r\n#define SXFLAG_UNSIGNED 0x02\r\n/* Allowed values for SyFmtConsumer.nType */\r\n#define SXFMT_CONS_PROC\t\t1\t/* Consumer is a procedure */\r\n#define SXFMT_CONS_STR\t\t2\t/* Consumer is a managed string */\r\n#define SXFMT_CONS_FILE\t\t5\t/* Consumer is an open File */\r\n#define SXFMT_CONS_BLOB\t\t6\t/* Consumer is a BLOB */\r\n/*\r\n** Each built-in conversion character (ex: the 'd' in \"%d\") is described\r\n** by an instance of the following structure\r\n*/\r\ntypedef struct SyFmtInfo SyFmtInfo;\r\nstruct SyFmtInfo\r\n{\r\n\tchar fmttype;  /* The format field code letter [i.e: 'd', 's', 'x'] */\r\n\tuint8_t base;     /* The base for radix conversion */\r\n\tint flags;    /* One or more of SXFLAG_ constants below */\r\n\tuint8_t type;     /* Conversion paradigm */\r\n\tchar *charset; /* The character set for conversion */\r\n\tchar *prefix;  /* Prefix on non-zero values in alt format */\r\n};\r\ntypedef struct SyFmtConsumer SyFmtConsumer;\r\nstruct SyFmtConsumer\r\n{\r\n\tsize_t nLen; /* Total output length */\r\n\tint nType; /* Type of the consumer see below */\r\n\tint rc;\t/* Consumer return value;Abort processing if rc != SOD_OK */\r\n\tunion {\r\n\t\tstruct {\r\n\t\t\tProcConsumer xUserConsumer;\r\n\t\t\tvoid *pUserData;\r\n\t\t}sFunc;\r\n\t\tSyBlob *pBlob;\r\n\t}uConsumer;\r\n};\r\nstatic int getdigit(long double *val, int *cnt)\r\n{\r\n\tlong double d;\r\n\tint digit;\r\n\r\n\tif ((*cnt)++ >= 16) {\r\n\t\treturn '0';\r\n\t}\r\n\tdigit = (int)*val;\r\n\td = digit;\r\n\t*val = (*val - d)*10.0;\r\n\treturn digit + '0';\r\n}\r\n/*\r\n* The following routine was taken from the SQLITE2 source tree and was\r\n* extended by Symisc Systems to fit its need.\r\n* Status: Public Domain\r\n*/\r\nstatic int InternFormat(ProcConsumer xConsumer, void *pUserData, const char *zFormat, va_list ap)\r\n{\r\n\t/*\r\n\t* The following table is searched linearly, so it is good to put the most frequently\r\n\t* used conversion types first.\r\n\t*/\r\n\tstatic const SyFmtInfo aFmt[] = {\r\n\t\t{ 'd', 10, SXFLAG_SIGNED, SXFMT_RADIX, \"0123456789\", 0 },\r\n\t{ 's',  0, 0, SXFMT_STRING,     0,                  0 },\r\n\t{ 'c',  0, 0, SXFMT_CHARX,      0,                  0 },\r\n\t{ 'x', 16, 0, SXFMT_RADIX,      \"0123456789abcdef\", \"x0\" },\r\n\t{ 'X', 16, 0, SXFMT_RADIX,      \"0123456789ABCDEF\", \"X0\" },\r\n\t/* -- Extensions by Symisc Systems -- */\r\n\t{ 'z',  0, 0, SXFMT_RAWSTR,     0,                   0 }, /* Pointer to a raw string (SyString *) */\r\n\t{ 'B',  2, 0, SXFMT_RADIX,      \"01\",                \"b0\" },\r\n\t/* -- End of Extensions -- */\r\n\t{ 'o',  8, 0, SXFMT_RADIX,      \"01234567\",         \"0\" },\r\n\t{ 'u', 10, 0, SXFMT_RADIX,      \"0123456789\",       0 },\r\n\t{ 'f',  0, SXFLAG_SIGNED, SXFMT_FLOAT,       0,     0 },\r\n\t{ 'e',  0, SXFLAG_SIGNED, SXFMT_EXP,        \"e\",    0 },\r\n\t{ 'E',  0, SXFLAG_SIGNED, SXFMT_EXP,        \"E\",    0 },\r\n\t{ 'g',  0, SXFLAG_SIGNED, SXFMT_GENERIC,    \"e\",    0 },\r\n\t{ 'G',  0, SXFLAG_SIGNED, SXFMT_GENERIC,    \"E\",    0 },\r\n\t{ 'i', 10, SXFLAG_SIGNED, SXFMT_RADIX, \"0123456789\", 0 },\r\n\t{ 'n',  0, 0, SXFMT_SIZE,       0,                  0 },\r\n\t{ '%',  0, 0, SXFMT_PERCENT,    0,                  0 },\r\n\t{ 'p', 10, 0, SXFMT_RADIX,      \"0123456789\",       0 }\r\n\t};\r\n\tint c;                     /* Next character in the format string */\r\n\tchar *bufpt;               /* Pointer to the conversion buffer */\r\n\tint precision;             /* Precision of the current field */\r\n\tint length;                /* Length of the field */\r\n\tint idx;                   /* A general purpose loop counter */\r\n\tint width;                 /* Width of the current field */\r\n\tuint8_t flag_leftjustify;   /* True if \"-\" flag is present */\r\n\tuint8_t flag_plussign;      /* True if \"+\" flag is present */\r\n\tuint8_t flag_blanksign;     /* True if \" \" flag is present */\r\n\tuint8_t flag_alternateform; /* True if \"#\" flag is present */\r\n\tuint8_t flag_zeropad;       /* True if field width constant starts with zero */\r\n\tuint8_t flag_long;          /* True if \"l\" flag is present */\r\n\tint64_t longvalue;         /* Value for integer types */\r\n\tconst SyFmtInfo *infop;  /* Pointer to the appropriate info structure */\r\n\tchar buf[SXFMT_BUFSIZ];  /* Conversion buffer */\r\n\tchar prefix;             /* Prefix character.\"+\" or \"-\" or \" \" or '\\0'.*/\r\n\tuint8_t errorflag = 0;      /* True if an error is encountered */\r\n\tuint8_t xtype;              /* Conversion paradigm */\r\n\tstatic char spaces[] = \"                                                  \";\r\n#define etSPACESIZE ((int)sizeof(spaces)-1)\r\n\tlong double realvalue;    /* Value for real types */\r\n\tint  exp;                /* exponent of real numbers */\r\n\tdouble rounder;          /* Used for rounding floating point values */\r\n\tuint8_t flag_dp;            /* True if decimal point should be shown */\r\n\tuint8_t flag_rtz;           /* True if trailing zeros should be removed */\r\n\tuint8_t flag_exp;           /* True to force display of the exponent */\r\n\tint nsd;                 /* Number of significant digits returned */\r\n\tint rc;\r\n\r\n\tlength = 0;\r\n\tbufpt = 0;\r\n\tfor (; (c = (*zFormat)) != 0; ++zFormat) {\r\n\t\tif (c != '%') {\r\n\t\t\tunsigned int amt;\r\n\t\t\tbufpt = (char *)zFormat;\r\n\t\t\tamt = 1;\r\n\t\t\twhile ((c = (*++zFormat)) != '%' && c != 0) amt++;\r\n\t\t\trc = xConsumer((const void *)bufpt, amt, pUserData);\r\n\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t\tif (c == 0) {\r\n\t\t\t\treturn errorflag > 0 ? -1 : SOD_OK;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((c = (*++zFormat)) == 0) {\r\n\t\t\terrorflag = 1;\r\n\t\t\trc = xConsumer(\"%\", sizeof(\"%\") - 1, pUserData);\r\n\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t\treturn errorflag > 0 ? -1 : SOD_OK;\r\n\t\t}\r\n\t\t/* Find out what flags are present */\r\n\t\tflag_leftjustify = flag_plussign = flag_blanksign =\r\n\t\t\tflag_alternateform = flag_zeropad = 0;\r\n\t\tdo {\r\n\t\t\tswitch (c) {\r\n\t\t\tcase '-':   flag_leftjustify = 1;     c = 0;   break;\r\n\t\t\tcase '+':   flag_plussign = 1;        c = 0;   break;\r\n\t\t\tcase ' ':   flag_blanksign = 1;       c = 0;   break;\r\n\t\t\tcase '#':   flag_alternateform = 1;   c = 0;   break;\r\n\t\t\tcase '0':   flag_zeropad = 1;         c = 0;   break;\r\n\t\t\tdefault:                                       break;\r\n\t\t\t}\r\n\t\t} while (c == 0 && (c = (*++zFormat)) != 0);\r\n\t\t/* Get the field width */\r\n\t\twidth = 0;\r\n\t\tif (c == '*') {\r\n\t\t\twidth = va_arg(ap, int);\r\n\t\t\tif (width<0) {\r\n\t\t\t\tflag_leftjustify = 1;\r\n\t\t\t\twidth = -width;\r\n\t\t\t}\r\n\t\t\tc = *++zFormat;\r\n\t\t}\r\n\t\telse {\r\n\t\t\twhile (c >= '0' && c <= '9') {\r\n\t\t\t\twidth = width * 10 + c - '0';\r\n\t\t\t\tc = *++zFormat;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (width > SXFMT_BUFSIZ - 10) {\r\n\t\t\twidth = SXFMT_BUFSIZ - 10;\r\n\t\t}\r\n\t\t/* Get the precision */\r\n\t\tprecision = -1;\r\n\t\tif (c == '.') {\r\n\t\t\tprecision = 0;\r\n\t\t\tc = *++zFormat;\r\n\t\t\tif (c == '*') {\r\n\t\t\t\tprecision = va_arg(ap, int);\r\n\t\t\t\tif (precision<0) precision = -precision;\r\n\t\t\t\tc = *++zFormat;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\twhile (c >= '0' && c <= '9') {\r\n\t\t\t\t\tprecision = precision * 10 + c - '0';\r\n\t\t\t\t\tc = *++zFormat;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Get the conversion type modifier */\r\n\t\tflag_long = 0;\r\n\t\tif (c == 'l' || c == 'q' /* BSD quad (expect a 64-bit integer) */) {\r\n\t\t\tflag_long = (c == 'q') ? 2 : 1;\r\n\t\t\tc = *++zFormat;\r\n\t\t\tif (c == 'l') {\r\n\t\t\t\t/* Standard printf emulation 'lld' (expect a 64bit integer) */\r\n\t\t\t\tflag_long = 2;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Fetch the info entry for the field */\r\n\t\tinfop = 0;\r\n\t\txtype = SXFMT_ERROR;\r\n\t\tfor (idx = 0; idx< (int)sizeof(aFmt) / sizeof(aFmt[0]); idx++) {\r\n\t\t\tif (c == aFmt[idx].fmttype) {\r\n\t\t\t\tinfop = &aFmt[idx];\r\n\t\t\t\txtype = infop->type;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t** At this point, variables are initialized as follows:\r\n\t\t**\r\n\t\t**   flag_alternateform          TRUE if a '#' is present.\r\n\t\t**   flag_plussign               TRUE if a '+' is present.\r\n\t\t**   flag_leftjustify            TRUE if a '-' is present or if the\r\n\t\t**                               field width was negative.\r\n\t\t**   flag_zeropad                TRUE if the width began with 0.\r\n\t\t**   flag_long                   TRUE if the letter 'l' (ell) or 'q'(BSD quad) prefixed\r\n\t\t**                               the conversion character.\r\n\t\t**   flag_blanksign              TRUE if a ' ' is present.\r\n\t\t**   width                       The specified field width.This is\r\n\t\t**                               always non-negative.Zero is the default.\r\n\t\t**   precision                   The specified precision.The default\r\n\t\t**                               is -1.\r\n\t\t**   xtype                       The object of the conversion.\r\n\t\t**   infop                       Pointer to the appropriate info struct.\r\n\t\t*/\r\n\t\tswitch (xtype) {\r\n\t\tcase SXFMT_RADIX:\r\n\t\t\tif (flag_long > 0) {\r\n\t\t\t\tif (flag_long > 1) {\r\n\t\t\t\t\t/* BSD quad: expect a 64-bit integer */\r\n\t\t\t\t\tlongvalue = va_arg(ap, int64_t);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlongvalue = va_arg(ap, long double);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (infop->flags & SXFLAG_SIGNED) {\r\n\t\t\t\t\tlongvalue = va_arg(ap, int);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlongvalue = va_arg(ap, unsigned int);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* Limit the precision to prevent overflowing buf[] during conversion */\r\n\t\t\tif (precision>SXFMT_BUFSIZ - 40) precision = SXFMT_BUFSIZ - 40;\r\n#if 1\r\n\t\t\t/* For the format %#x, the value zero is printed \"0\" not \"0x0\".\r\n\t\t\t** I think this is stupid.*/\r\n\t\t\tif (longvalue == 0) flag_alternateform = 0;\r\n#else\r\n\t\t\t/* More sensible: turn off the prefix for octal (to prevent \"00\"),\r\n\t\t\t** but leave the prefix for hex.*/\r\n\t\t\tif (longvalue == 0 && infop->base == 8) flag_alternateform = 0;\r\n#endif\r\n\t\t\tif (infop->flags & SXFLAG_SIGNED) {\r\n\t\t\t\tif (longvalue<0) {\r\n\t\t\t\t\tlongvalue = -longvalue;\r\n\t\t\t\t\t/* Ticket 1433-003 */\r\n\t\t\t\t\tif (longvalue < 0) {\r\n\t\t\t\t\t\t/* Overflow */\r\n\t\t\t\t\t\tlongvalue = 0x7FFFFFFFFFFFFFFF;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprefix = '-';\r\n\t\t\t\t}\r\n\t\t\t\telse if (flag_plussign)  prefix = '+';\r\n\t\t\t\telse if (flag_blanksign)  prefix = ' ';\r\n\t\t\t\telse                       prefix = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (longvalue<0) {\r\n\t\t\t\t\tlongvalue = -longvalue;\r\n\t\t\t\t\t/* Ticket 1433-003 */\r\n\t\t\t\t\tif (longvalue < 0) {\r\n\t\t\t\t\t\t/* Overflow */\r\n\t\t\t\t\t\tlongvalue = 0x7FFFFFFFFFFFFFFF;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprefix = 0;\r\n\t\t\t}\r\n\t\t\tif (flag_zeropad && precision<width - (prefix != 0)) {\r\n\t\t\t\tprecision = width - (prefix != 0);\r\n\t\t\t}\r\n\t\t\tbufpt = &buf[SXFMT_BUFSIZ - 1];\r\n\t\t\t{\r\n\t\t\t\tregister char *cset;      /* Use registers for speed */\r\n\t\t\t\tregister int base;\r\n\t\t\t\tcset = infop->charset;\r\n\t\t\t\tbase = infop->base;\r\n\t\t\t\tdo {                                           /* Convert to ascii */\r\n\t\t\t\t\t*(--bufpt) = cset[longvalue%base];\r\n\t\t\t\t\tlongvalue = longvalue / base;\r\n\t\t\t\t} while (longvalue>0);\r\n\t\t\t}\r\n\t\t\tlength = &buf[SXFMT_BUFSIZ - 1] - bufpt;\r\n\t\t\tfor (idx = precision - length; idx>0; idx--) {\r\n\t\t\t\t*(--bufpt) = '0';                             /* Zero pad */\r\n\t\t\t}\r\n\t\t\tif (prefix) *(--bufpt) = prefix;               /* Add sign */\r\n\t\t\tif (flag_alternateform && infop->prefix) {      /* Add \"0\" or \"0x\" */\r\n\t\t\t\tchar *pre, x;\r\n\t\t\t\tpre = infop->prefix;\r\n\t\t\t\tif (*bufpt != pre[0]) {\r\n\t\t\t\t\tfor (pre = infop->prefix; (x = (*pre)) != 0; pre++) *(--bufpt) = x;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlength = &buf[SXFMT_BUFSIZ - 1] - bufpt;\r\n\t\t\tbreak;\r\n\t\tcase SXFMT_FLOAT:\r\n\t\tcase SXFMT_EXP:\r\n\t\tcase SXFMT_GENERIC:\r\n\t\t\trealvalue = va_arg(ap, double);\r\n\t\t\tif (precision<0) precision = 6;         /* Set default precision */\r\n\t\t\tif (precision>SXFMT_BUFSIZ - 40) precision = SXFMT_BUFSIZ - 40;\r\n\t\t\tif (realvalue<0.0) {\r\n\t\t\t\trealvalue = -realvalue;\r\n\t\t\t\tprefix = '-';\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (flag_plussign)          prefix = '+';\r\n\t\t\t\telse if (flag_blanksign)    prefix = ' ';\r\n\t\t\t\telse                         prefix = 0;\r\n\t\t\t}\r\n\t\t\tif (infop->type == SXFMT_GENERIC && precision>0) precision--;\r\n\t\t\trounder = 0.0;\r\n#if 0\r\n\t\t\t/* Rounding works like BSD when the constant 0.4999 is used.Wierd! */\r\n\t\t\tfor (idx = precision, rounder = 0.4999; idx>0; idx--, rounder *= 0.1);\r\n#else\r\n\t\t\t/* It makes more sense to use 0.5 */\r\n\t\t\tfor (idx = precision, rounder = 0.5; idx>0; idx--, rounder *= 0.1);\r\n#endif\r\n\t\t\tif (infop->type == SXFMT_FLOAT) realvalue += rounder;\r\n\t\t\t/* Normalize realvalue to within 10.0 > realvalue >= 1.0 */\r\n\t\t\texp = 0;\r\n\t\t\tif (realvalue>0.0) {\r\n\t\t\t\twhile (realvalue >= 1e8 && exp <= 350) { realvalue *= 1e-8; exp += 8; }\r\n\t\t\t\twhile (realvalue >= 10.0 && exp <= 350) { realvalue *= 0.1; exp++; }\r\n\t\t\t\twhile (realvalue<1e-8 && exp >= -350) { realvalue *= 1e8; exp -= 8; }\r\n\t\t\t\twhile (realvalue<1.0 && exp >= -350) { realvalue *= 10.0; exp--; }\r\n\t\t\t\tif (exp>350 || exp<-350) {\r\n\t\t\t\t\tbufpt = \"NaN\";\r\n\t\t\t\t\tlength = 3;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbufpt = buf;\r\n\t\t\t/*\r\n\t\t\t** If the field type is etGENERIC, then convert to either etEXP\r\n\t\t\t** or etFLOAT, as appropriate.\r\n\t\t\t*/\r\n\t\t\tflag_exp = xtype == SXFMT_EXP;\r\n\t\t\tif (xtype != SXFMT_FLOAT) {\r\n\t\t\t\trealvalue += rounder;\r\n\t\t\t\tif (realvalue >= 10.0) { realvalue *= 0.1; exp++; }\r\n\t\t\t}\r\n\t\t\tif (xtype == SXFMT_GENERIC) {\r\n\t\t\t\tflag_rtz = !flag_alternateform;\r\n\t\t\t\tif (exp<-4 || exp>precision) {\r\n\t\t\t\t\txtype = SXFMT_EXP;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tprecision = precision - exp;\r\n\t\t\t\t\txtype = SXFMT_FLOAT;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tflag_rtz = 0;\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t** The \"exp+precision\" test causes output to be of type etEXP if\r\n\t\t\t** the precision is too large to fit in buf[].\r\n\t\t\t*/\r\n\t\t\tnsd = 0;\r\n\t\t\tif (xtype == SXFMT_FLOAT && exp + precision<SXFMT_BUFSIZ - 30) {\r\n\t\t\t\tflag_dp = (precision>0 || flag_alternateform);\r\n\t\t\t\tif (prefix) *(bufpt++) = prefix;         /* Sign */\r\n\t\t\t\tif (exp<0)  *(bufpt++) = '0';            /* Digits before \".\" */\r\n\t\t\t\telse for (; exp >= 0; exp--) *(bufpt++) = (char)getdigit(&realvalue, &nsd);\r\n\t\t\t\tif (flag_dp) *(bufpt++) = '.';           /* The decimal point */\r\n\t\t\t\tfor (exp++; exp<0 && precision>0; precision--, exp++) {\r\n\t\t\t\t\t*(bufpt++) = '0';\r\n\t\t\t\t}\r\n\t\t\t\twhile ((precision--)>0) *(bufpt++) = (char)getdigit(&realvalue, &nsd);\r\n\t\t\t\t*(bufpt--) = 0;                           /* Null terminate */\r\n\t\t\t\tif (flag_rtz && flag_dp) {     /* Remove trailing zeros and \".\" */\r\n\t\t\t\t\twhile (bufpt >= buf && *bufpt == '0') *(bufpt--) = 0;\r\n\t\t\t\t\tif (bufpt >= buf && *bufpt == '.') *(bufpt--) = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbufpt++;                            /* point to next free slot */\r\n\t\t\t}\r\n\t\t\telse {    /* etEXP or etGENERIC */\r\n\t\t\t\tflag_dp = (precision>0 || flag_alternateform);\r\n\t\t\t\tif (prefix) *(bufpt++) = prefix;   /* Sign */\r\n\t\t\t\t*(bufpt++) = (char)getdigit(&realvalue, &nsd);  /* First digit */\r\n\t\t\t\tif (flag_dp) *(bufpt++) = '.';     /* Decimal point */\r\n\t\t\t\twhile ((precision--)>0) *(bufpt++) = (char)getdigit(&realvalue, &nsd);\r\n\t\t\t\tbufpt--;                            /* point to last digit */\r\n\t\t\t\tif (flag_rtz && flag_dp) {          /* Remove tail zeros */\r\n\t\t\t\t\twhile (bufpt >= buf && *bufpt == '0') *(bufpt--) = 0;\r\n\t\t\t\t\tif (bufpt >= buf && *bufpt == '.') *(bufpt--) = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbufpt++;                            /* point to next free slot */\r\n\t\t\t\tif (exp || flag_exp) {\r\n\t\t\t\t\t*(bufpt++) = infop->charset[0];\r\n\t\t\t\t\tif (exp<0) { *(bufpt++) = '-'; exp = -exp; } /* sign of exp */\r\n\t\t\t\t\telse { *(bufpt++) = '+'; }\r\n\t\t\t\t\tif (exp >= 100) {\r\n\t\t\t\t\t\t*(bufpt++) = (char)((exp / 100) + '0');                /* 100's digit */\r\n\t\t\t\t\t\texp %= 100;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t*(bufpt++) = (char)(exp / 10 + '0');                     /* 10's digit */\r\n\t\t\t\t\t*(bufpt++) = (char)(exp % 10 + '0');                     /* 1's digit */\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* The converted number is in buf[] and zero terminated.Output it.\r\n\t\t\t** Note that the number is in the usual order, not reversed as with\r\n\t\t\t** integer conversions.*/\r\n\t\t\tlength = bufpt - buf;\r\n\t\t\tbufpt = buf;\r\n\r\n\t\t\t/* Special case:  Add leading zeros if the flag_zeropad flag is\r\n\t\t\t** set and we are not left justified */\r\n\t\t\tif (flag_zeropad && !flag_leftjustify && length < width) {\r\n\t\t\t\tint i;\r\n\t\t\t\tint nPad = width - length;\r\n\t\t\t\tfor (i = width; i >= nPad; i--) {\r\n\t\t\t\t\tbufpt[i] = bufpt[i - nPad];\r\n\t\t\t\t}\r\n\t\t\t\ti = prefix != 0;\r\n\t\t\t\twhile (nPad--) bufpt[i++] = '0';\r\n\t\t\t\tlength = width;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase SXFMT_SIZE: {\r\n\t\t\tsize_t *pSize = va_arg(ap, size_t *);\r\n\t\t\t*pSize = ((SyFmtConsumer *)pUserData)->nLen;\r\n\t\t\tlength = width = 0;\r\n\t\t}\r\n\t\t\t\t\t\t break;\r\n\t\tcase SXFMT_PERCENT:\r\n\t\t\tbuf[0] = '%';\r\n\t\t\tbufpt = buf;\r\n\t\t\tlength = 1;\r\n\t\t\tbreak;\r\n\t\tcase SXFMT_CHARX:\r\n\t\t\tc = va_arg(ap, int);\r\n\t\t\tbuf[0] = (char)c;\r\n\t\t\t/* Limit the precision to prevent overflowing buf[] during conversion */\r\n\t\t\tif (precision>SXFMT_BUFSIZ - 40) precision = SXFMT_BUFSIZ - 40;\r\n\t\t\tif (precision >= 0) {\r\n\t\t\t\tfor (idx = 1; idx<precision; idx++) buf[idx] = (char)c;\r\n\t\t\t\tlength = precision;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlength = 1;\r\n\t\t\t}\r\n\t\t\tbufpt = buf;\r\n\t\t\tbreak;\r\n\t\tcase SXFMT_STRING:\r\n\t\t\tbufpt = va_arg(ap, char*);\r\n\t\t\tif (bufpt == 0) {\r\n\t\t\t\tbufpt = \" \";\r\n\t\t\t\tlength = (int)sizeof(\" \") - 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tlength = precision;\r\n\t\t\tif (precision < 0) {\r\n\t\t\t\t/* Symisc extension */\r\n\t\t\t\tlength = (int)strlen(bufpt);\r\n\t\t\t}\r\n\t\t\tif (precision >= 0 && precision<length) length = precision;\r\n\t\t\tbreak;\r\n\t\tcase SXFMT_RAWSTR: {\r\n\t\t\t/* Symisc extension */\r\n\t\t\tSyString *pStr = va_arg(ap, SyString *);\r\n\t\t\tif (pStr == 0 || pStr->zString == 0) {\r\n\t\t\t\tbufpt = \" \";\r\n\t\t\t\tlength = (int)sizeof(char);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tbufpt = (char *)pStr->zString;\r\n\t\t\tlength = (int)pStr->nByte;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase SXFMT_ERROR:\r\n\t\t\tbuf[0] = '?';\r\n\t\t\tbufpt = buf;\r\n\t\t\tlength = (int)sizeof(char);\r\n\t\t\tif (c == 0) zFormat--;\r\n\t\t\tbreak;\r\n\t\t}/* End switch over the format type */\r\n\t\t /*\r\n\t\t ** The text of the conversion is pointed to by \"bufpt\" and is\r\n\t\t ** \"length\" characters long.The field width is \"width\".Do\r\n\t\t ** the output.\r\n\t\t */\r\n\t\tif (!flag_leftjustify) {\r\n\t\t\tregister int nspace;\r\n\t\t\tnspace = width - length;\r\n\t\t\tif (nspace>0) {\r\n\t\t\t\twhile (nspace >= etSPACESIZE) {\r\n\t\t\t\t\trc = xConsumer(spaces, etSPACESIZE, pUserData);\r\n\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnspace -= etSPACESIZE;\r\n\t\t\t\t}\r\n\t\t\t\tif (nspace>0) {\r\n\t\t\t\t\trc = xConsumer(spaces, (unsigned int)nspace, pUserData);\r\n\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (length>0) {\r\n\t\t\trc = xConsumer(bufpt, (unsigned int)length, pUserData);\r\n\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag_leftjustify) {\r\n\t\t\tregister int nspace;\r\n\t\t\tnspace = width - length;\r\n\t\t\tif (nspace>0) {\r\n\t\t\t\twhile (nspace >= etSPACESIZE) {\r\n\t\t\t\t\trc = xConsumer(spaces, etSPACESIZE, pUserData);\r\n\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnspace -= etSPACESIZE;\r\n\t\t\t\t}\r\n\t\t\t\tif (nspace>0) {\r\n\t\t\t\t\trc = xConsumer(spaces, (unsigned int)nspace, pUserData);\r\n\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\treturn SOD_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}/* End for loop over the format string */\r\n\treturn errorflag ? -1 : SOD_OK;\r\n}\r\nstatic int FormatConsumer(const void *pSrc, unsigned int nLen, void *pData)\r\n{\r\n\tSyFmtConsumer *pConsumer = (SyFmtConsumer *)pData;\r\n\tint rc = SOD_ABORT;\r\n\tswitch (pConsumer->nType) {\r\n\tcase SXFMT_CONS_PROC:\r\n\t\t/* User callback */\r\n\t\trc = pConsumer->uConsumer.sFunc.xUserConsumer(pSrc, nLen, pConsumer->uConsumer.sFunc.pUserData);\r\n\t\tbreak;\r\n\tcase SXFMT_CONS_BLOB:\r\n\t\t/* Blob consumer */\r\n\t\trc = SyBlobAppend(pConsumer->uConsumer.pBlob, pSrc, (unsigned int)nLen);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t/* Unknown consumer */\r\n\t\tbreak;\r\n\t}\r\n\t/* Update total number of bytes consumed so far */\r\n\tpConsumer->nLen += nLen;\r\n\tpConsumer->rc = rc;\r\n\treturn rc;\r\n}\r\nstatic int32_t FormatMount(int32_t nType, void *pConsumer, ProcConsumer xUserCons, void *pUserData, size_t *pOutLen, const char *zFormat, va_list ap)\r\n{\r\n\tSyFmtConsumer sCons;\r\n\tsCons.nType = nType;\r\n\tsCons.rc = SOD_OK;\r\n\tsCons.nLen = 0;\r\n\tif (pOutLen) {\r\n\t\t*pOutLen = 0;\r\n\t}\r\n\tswitch (nType) {\r\n\tcase SXFMT_CONS_PROC:\r\n\t\tsCons.uConsumer.sFunc.xUserConsumer = xUserCons;\r\n\t\tsCons.uConsumer.sFunc.pUserData = pUserData;\r\n\t\tbreak;\r\n\tcase SXFMT_CONS_BLOB:\r\n\t\tsCons.uConsumer.pBlob = (SyBlob *)pConsumer;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\treturn -1; /* Unknown */\r\n\t}\r\n\tInternFormat(FormatConsumer, &sCons, zFormat, ap);\r\n\tif (pOutLen) {\r\n\t\t*pOutLen = sCons.nLen;\r\n\t}\r\n\treturn sCons.rc;\r\n}\r\nstatic size_t SyBlobFormatAp(SyBlob *pBlob, const char *zFormat, va_list ap)\r\n{\r\n\tsize_t n = 0; /* cc warning */\r\n\tFormatMount(SXFMT_CONS_BLOB, &(*pBlob), 0, 0, &n, zFormat, ap);\r\n\tSyBlobNullAppend(pBlob);\r\n\treturn n;\r\n}\r\n#endif /* SOD_ENABLE_NET_TRAIN */\r\n/*\r\n* Dynamic Set Implementation.\r\n*/\r\nstatic int SySetInit(SySet *pSet, size_t ElemSize)\r\n{\r\n\tpSet->nSize = 0;\r\n\tpSet->nUsed = 0;\r\n\tpSet->eSize = ElemSize;\r\n\tpSet->pBase = 0;\r\n\tpSet->pUserData = 0;\r\n\treturn 0;\r\n}\r\nstatic int SySetPut(SySet *pSet, const void *pItem)\r\n{\r\n\tunsigned char *zbase;\r\n\tif (pSet->nUsed >= pSet->nSize) {\r\n\t\tvoid *pNew;\r\n\t\tif (pSet->nSize < 1) {\r\n\t\t\tpSet->nSize = 8;\r\n\t\t}\r\n\t\tpNew = realloc(pSet->pBase, pSet->eSize * pSet->nSize * 2);\r\n\t\tif (pNew == 0) {\r\n\t\t\treturn SOD_OUTOFMEM;\r\n\t\t}\r\n\t\tpSet->pBase = pNew;\r\n\t\tpSet->nSize <<= 1;\r\n\t}\r\n\tif (pItem) {\r\n\t\tzbase = (unsigned char *)pSet->pBase;\r\n\t\tmemcpy((void *)&zbase[pSet->nUsed * pSet->eSize], pItem, pSet->eSize);\r\n\t\tpSet->nUsed++;\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\nstatic inline void SySetReset(SySet *pSet)\r\n{\r\n\tpSet->nUsed = 0;\r\n}\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\nstatic void * SySetPeek(SySet *pSet)\r\n{\r\n\tconst char *zBase;\r\n\tif (pSet->nUsed <= 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tzBase = (const char *)pSet->pBase;\r\n\treturn (void *)&zBase[(pSet->nUsed - 1) * pSet->eSize];\r\n}\r\n#endif /* SOD_ENABLE_NET_TRAIN */\r\nstatic void * SySetFetch(SySet *pSet, size_t idx)\r\n{\r\n\tconst char *zBase;\r\n\tif (idx >= pSet->nUsed) {\r\n\t\treturn 0;\r\n\t}\r\n\tzBase = (const char *)pSet->pBase;\r\n\treturn (void *)&zBase[idx * pSet->eSize];\r\n}\r\nstatic void SySetRelease(SySet *pSet)\r\n{\r\n\tif (pSet->pBase) {\r\n\t\tfree(pSet->pBase);\r\n\t}\r\n\tpSet->pBase = 0;\r\n\tpSet->nUsed = 0;\r\n}\r\nstatic int SySetAlloc(SySet *pSet, int nItem)\r\n{\r\n\tif (pSet->nSize > 0) {\r\n\t\treturn SOD_LIMIT;\r\n\t}\r\n\tif (nItem < 8) {\r\n\t\tnItem = 8;\r\n\t}\r\n\tpSet->pBase = realloc(pSet->pBase, pSet->eSize * nItem);\r\n\tif (pSet->pBase == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tpSet->nSize = nItem;\r\n\treturn SOD_OK;\r\n}\r\n#if defined (_WIN32) || defined (WIN32) ||  defined (_WIN64) || defined (WIN64) || defined(__MINGW32__) || defined (_MSC_VER)\r\n/* Windows Systems */\r\n#if !defined(__WINNT__)\r\n#define __WINNT__\r\n#endif \r\n#else\r\n/*\r\n* By default we will assume that we are compiling on a UNIX like (iOS and Android included) system.\r\n* Otherwise the OS_OTHER directive must be defined.\r\n*/\r\n#if !defined(OS_OTHER)\r\n#if !defined(__UNIXES__)\r\n#define __UNIXES__\r\n#endif /* __UNIXES__ */\r\n#else\r\n#endif /* OS_OTHER */\r\n#endif /* __WINNT__/__UNIXES__ */\r\n/*\r\n* SOD Built-in VFS which is Based on Libcox another open source library developed by Symisc Systems.\r\n*/\r\n/*\r\n* Symisc libcox: Cross Platform Utilities & System Calls.\r\n* Copyright (C) 2014, 2015 Symisc Systems http://libcox.symisc.net/\r\n* Version 1.7\r\n* For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n* please contact Symisc Systems via:\r\n*       legal@symisc.net\r\n*       licensing@symisc.net\r\n*       contact@symisc.net\r\n* or visit:\r\n*      http://libcox.symisc.net/\r\n*/\r\n/* $SymiscID: vfs.c v1.3 FreeBSD 2017-05-22 01:19 stable <chm@symisc.net> $ */\r\n/*\r\n* Virtual File System (VFS) for libcox (SOD modified).\r\n*/\r\n/*\r\n* Wrapper function used to mimic some Libcox code that is no longer needed here.\r\n*/\r\nstatic inline int libcox_result_string(SyBlob *pBlob, const char *zBuf, int nLen)\r\n{\r\n\tint rc;\r\n\tif (nLen < 0) {\r\n\t\tnLen = (int)strlen(zBuf);\r\n\t}\r\n\trc = SyBlobAppend(&(*pBlob), zBuf, (size_t)nLen);\r\n\tSyBlobNullAppend(&(*pBlob));\r\n\treturn rc;\r\n}\r\n#ifdef __WINNT__\r\n/*\r\n* Windows VFS implementation for the LIBCOX engine.\r\n* Authors:\r\n*    Symisc Systems, devel@symisc.net.\r\n*    Copyright (C) Symisc Systems, http://libcox.symisc.net\r\n* Status:\r\n*    Stable.\r\n*/\r\n/* What follows here is code that is specific to windows systems. */\r\n#include <Windows.h>\r\n/*\r\n** Convert a UTF-8 string to microsoft unicode (UTF-16?).\r\n**\r\n** Space to hold the returned string is obtained from HeapAlloc().\r\n** Taken from the sqlite3 source tree\r\n** status: Public Domain\r\n*/\r\nstatic WCHAR *utf8ToUnicode(const char *zFilename) {\r\n\tint nChar;\r\n\tWCHAR *zWideFilename;\r\n\r\n\tnChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, 0, 0);\r\n\tzWideFilename = (WCHAR *)HeapAlloc(GetProcessHeap(), 0, nChar * sizeof(zWideFilename[0]));\r\n\tif (zWideFilename == 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tnChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename, nChar);\r\n\tif (nChar == 0) {\r\n\t\tHeapFree(GetProcessHeap(), 0, zWideFilename);\r\n\t\treturn 0;\r\n\t}\r\n\treturn zWideFilename;\r\n}\r\n/*\r\n** Convert a UTF-8 filename into whatever form the underlying\r\n** operating system wants filenames in.Space to hold the result\r\n** is obtained from HeapAlloc() and must be freed by the calling\r\n** function.\r\n** Taken from the sqlite3 source tree\r\n** status: Public Domain\r\n*/\r\nstatic void *convertUtf8Filename(const char *zFilename) {\r\n\tvoid *zConverted;\r\n\tzConverted = utf8ToUnicode(zFilename);\r\n\treturn zConverted;\r\n}\r\n/*\r\n** Convert microsoft unicode to UTF-8.  Space to hold the returned string is\r\n** obtained from HeapAlloc().\r\n** Taken from the sqlite3 source tree\r\n** status: Public Domain\r\n*/\r\nstatic char *unicodeToUtf8(const WCHAR *zWideFilename) {\r\n\tchar *zFilename;\r\n\tint nByte;\r\n\r\n\tnByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0);\r\n\tzFilename = (char *)HeapAlloc(GetProcessHeap(), 0, nByte);\r\n\tif (zFilename == 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tnByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte, 0, 0);\r\n\tif (nByte == 0) {\r\n\t\tHeapFree(GetProcessHeap(), 0, zFilename);\r\n\t\treturn 0;\r\n\t}\r\n\treturn zFilename;\r\n}\r\n/* int (*xchdir)(const char *) */\r\nstatic int WinVfs_chdir(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tBOOL rc;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\trc = SetCurrentDirectoryW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int (*xGetcwd)(SyBlob *) */\r\nstatic int WinVfs_getcwd(SyBlob *pCtx)\r\n{\r\n\tWCHAR zDir[2048];\r\n\tchar *zConverted;\r\n\tDWORD rc;\r\n\t/* Get the current directory */\r\n\trc = GetCurrentDirectoryW(sizeof(zDir), zDir);\r\n\tif (rc < 1) {\r\n\t\treturn -1;\r\n\t}\r\n\tzConverted = unicodeToUtf8(zDir);\r\n\tif (zConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tlibcox_result_string(pCtx, zConverted, -1/*Compute length automatically*/); /* Will make it's own copy */\r\n\tHeapFree(GetProcessHeap(), 0, zConverted);\r\n\treturn SOD_OK;\r\n}\r\n/* int (*xMkdir)(const char *, int, int) */\r\nstatic int WinVfs_mkdir(const char *zPath, int mode, int recursive)\r\n{\r\n\tvoid * pConverted;\r\n\tBOOL rc;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tmode = 0; /* MSVC warning */\r\n\trecursive = 0;\r\n\trc = CreateDirectoryW((LPCWSTR)pConverted, 0);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int (*xRmdir)(const char *) */\r\nstatic int WinVfs_rmdir(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tBOOL rc;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\trc = RemoveDirectoryW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int (*xIsdir)(const char *) */\r\nstatic int WinVfs_isdir(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tDWORD dwAttr;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tdwAttr = GetFileAttributesW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (dwAttr == INVALID_FILE_ATTRIBUTES) {\r\n\t\treturn -1;\r\n\t}\r\n\treturn (dwAttr & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;\r\n}\r\n/* int (*xRename)(const char *, const char *) */\r\nstatic int WinVfs_Rename(const char *zOld, const char *zNew)\r\n{\r\n\tvoid *pOld, *pNew;\r\n\tBOOL rc = 0;\r\n\tpOld = convertUtf8Filename(zOld);\r\n\tif (pOld == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tpNew = convertUtf8Filename(zNew);\r\n\tif (pNew) {\r\n\t\trc = MoveFileW((LPCWSTR)pOld, (LPCWSTR)pNew);\r\n\t}\r\n\tHeapFree(GetProcessHeap(), 0, pOld);\r\n\tif (pNew) {\r\n\t\tHeapFree(GetProcessHeap(), 0, pNew);\r\n\t}\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int (*xRealpath)(const char *, SyBlob *) */\r\nstatic int WinVfs_Realpath(const char *zPath, SyBlob *pCtx)\r\n{\r\n\tWCHAR zTemp[2048];\r\n\tvoid *pPath;\r\n\tchar *zReal;\r\n\tDWORD n;\r\n\tpPath = convertUtf8Filename(zPath);\r\n\tif (pPath == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tn = GetFullPathNameW((LPCWSTR)pPath, 0, 0, 0);\r\n\tif (n > 0) {\r\n\t\tif (n >= sizeof(zTemp)) {\r\n\t\t\tn = sizeof(zTemp) - 1;\r\n\t\t}\r\n\t\tGetFullPathNameW((LPCWSTR)pPath, n, zTemp, 0);\r\n\t}\r\n\tHeapFree(GetProcessHeap(), 0, pPath);\r\n\tif (!n) {\r\n\t\treturn -1;\r\n\t}\r\n\tzReal = unicodeToUtf8(zTemp);\r\n\tif (zReal == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tlibcox_result_string(pCtx, zReal, -1); /* Will make it's own copy */\r\n\tHeapFree(GetProcessHeap(), 0, zReal);\r\n\treturn SOD_OK;\r\n}\r\n/* int (*xUnlink)(const char *) */\r\nstatic int WinVfs_unlink(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tBOOL rc;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\trc = DeleteFileW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int64_t (*xFreeSpace)(const char *) */\r\nstatic int64_t WinVfs_DiskFreeSpace(const char *zPath)\r\n{\r\n\tDWORD dwSectPerClust, dwBytesPerSect, dwFreeClusters, dwTotalClusters;\r\n\tvoid * pConverted;\r\n\tWCHAR *p;\r\n\tBOOL rc;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tp = (WCHAR *)pConverted;\r\n\tfor (; *p; p++) {\r\n\t\tif (*p == '\\\\' || *p == '/') {\r\n\t\t\t*p = '\\0';\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\trc = GetDiskFreeSpaceW((LPCWSTR)pConverted, &dwSectPerClust, &dwBytesPerSect, &dwFreeClusters, &dwTotalClusters);\r\n\tif (!rc) {\r\n\t\treturn 0;\r\n\t}\r\n\treturn (int64_t)dwFreeClusters * dwSectPerClust * dwBytesPerSect;\r\n}\r\n/* int64_t (*xTotalSpace)(const char *) */\r\nstatic int64_t WinVfs_DiskTotalSpace(const char *zPath)\r\n{\r\n\tDWORD dwSectPerClust, dwBytesPerSect, dwFreeClusters, dwTotalClusters;\r\n\tvoid * pConverted;\r\n\tWCHAR *p;\r\n\tBOOL rc;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tp = (WCHAR *)pConverted;\r\n\tfor (; *p; p++) {\r\n\t\tif (*p == '\\\\' || *p == '/') {\r\n\t\t\t*p = '\\0';\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\trc = GetDiskFreeSpaceW((LPCWSTR)pConverted, &dwSectPerClust, &dwBytesPerSect, &dwFreeClusters, &dwTotalClusters);\r\n\tif (!rc) {\r\n\t\treturn 0;\r\n\t}\r\n\treturn (int64_t)dwTotalClusters * dwSectPerClust * dwBytesPerSect;\r\n}\r\n/* int (*xFileExists)(const char *) */\r\nstatic int WinVfs_FileExists(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tDWORD dwAttr;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tdwAttr = GetFileAttributesW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (dwAttr == INVALID_FILE_ATTRIBUTES) {\r\n\t\treturn -1;\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/* Open a file in a read-only mode */\r\nstatic HANDLE OpenReadOnly(LPCWSTR pPath)\r\n{\r\n\tDWORD dwType = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;\r\n\tDWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;\r\n\tDWORD dwAccess = GENERIC_READ;\r\n\tDWORD dwCreate = OPEN_EXISTING;\r\n\tHANDLE pHandle;\r\n\tpHandle = CreateFileW(pPath, dwAccess, dwShare, 0, dwCreate, dwType, 0);\r\n\tif (pHandle == INVALID_HANDLE_VALUE) {\r\n\t\treturn 0;\r\n\t}\r\n\treturn pHandle;\r\n}\r\n/* int64_t (*xFileSize)(const char *) */\r\nstatic int64_t WinVfs_FileSize(const char *zPath)\r\n{\r\n\tDWORD dwLow, dwHigh;\r\n\tvoid * pConverted;\r\n\tint64_t nSize;\r\n\tHANDLE pHandle;\r\n\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\t/* Open the file in read-only mode */\r\n\tpHandle = OpenReadOnly((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (pHandle) {\r\n\t\tdwLow = GetFileSize(pHandle, &dwHigh);\r\n\t\tnSize = dwHigh;\r\n\t\tnSize <<= 32;\r\n\t\tnSize += dwLow;\r\n\t\tCloseHandle(pHandle);\r\n\t}\r\n\telse {\r\n\t\tnSize = -1;\r\n\t}\r\n\treturn nSize;\r\n}\r\n/* int (*xIsfile)(const char *) */\r\nstatic int WinVfs_isfile(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tDWORD dwAttr;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tdwAttr = GetFileAttributesW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (dwAttr == INVALID_FILE_ATTRIBUTES) {\r\n\t\treturn -1;\r\n\t}\r\n\treturn (dwAttr & (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE)) ? SOD_OK : -1;\r\n}\r\n/* int (*xWritable)(const char *) */\r\nstatic int WinVfs_iswritable(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tDWORD dwAttr;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tdwAttr = GetFileAttributesW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (dwAttr == INVALID_FILE_ATTRIBUTES) {\r\n\t\treturn -1;\r\n\t}\r\n\tif ((dwAttr & (FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL)) == 0) {\r\n\t\t/* Not a regular file */\r\n\t\treturn -1;\r\n\t}\r\n\tif (dwAttr & FILE_ATTRIBUTE_READONLY) {\r\n\t\t/* Read-only file */\r\n\t\treturn -1;\r\n\t}\r\n\t/* File is writable */\r\n\treturn SOD_OK;\r\n}\r\n/* int (*xExecutable)(const char *) */\r\nstatic int WinVfs_isexecutable(const char *zPath)\r\n{\r\n\tvoid * pConverted;\r\n\tDWORD dwAttr;\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tdwAttr = GetFileAttributesW((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (dwAttr == INVALID_FILE_ATTRIBUTES) {\r\n\t\treturn -1;\r\n\t}\r\n\tif ((dwAttr & FILE_ATTRIBUTE_NORMAL) == 0) {\r\n\t\t/* Not a regular file */\r\n\t\treturn -1;\r\n\t}\r\n\t/* FIXEME: GetBinaryType or another call to make sure this thing is executable  */\r\n\r\n\t/* File is executable */\r\n\treturn SOD_OK;\r\n}\r\n/* int (*xGetenv)(const char *, SyBlob *) */\r\nstatic int WinVfs_Getenv(const char *zVar, SyBlob *pCtx)\r\n{\r\n\tchar zValue[1024];\r\n\tDWORD n;\r\n\t/*\r\n\t* According to MSDN\r\n\t* If lpBuffer is not large enough to hold the data, the return\r\n\t* value is the buffer size, in characters, required to hold the\r\n\t* string and its terminating null character and the contents\r\n\t* of lpBuffer are undefined.\r\n\t*/\r\n\tn = sizeof(zValue);\r\n\t/* Extract the environment value */\r\n\tn = GetEnvironmentVariableA(zVar, zValue, sizeof(zValue));\r\n\tif (!n) {\r\n\t\t/* No such variable*/\r\n\t\treturn -1;\r\n\t}\r\n\tlibcox_result_string(pCtx, zValue, (int)n);\r\n\treturn SOD_OK;\r\n}\r\n/* int (*xSetenv)(const char *, const char *) */\r\nstatic int WinVfs_Setenv(const char *zName, const char *zValue)\r\n{\r\n\tBOOL rc;\r\n\trc = SetEnvironmentVariableA(zName, zValue);\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int (*xMmap)(const char *, void **, size_t *) */\r\nstatic int WinVfs_Mmap(const char *zPath, void **ppMap, size_t *pSize)\r\n{\r\n\tDWORD dwSizeLow, dwSizeHigh;\r\n\tHANDLE pHandle, pMapHandle;\r\n\tvoid *pConverted, *pView;\r\n\r\n\tpConverted = convertUtf8Filename(zPath);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tpHandle = OpenReadOnly((LPCWSTR)pConverted);\r\n\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\tif (pHandle == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\t/* Get the file size */\r\n\tdwSizeLow = GetFileSize(pHandle, &dwSizeHigh);\r\n\t/* Create the mapping */\r\n\tpMapHandle = CreateFileMappingW(pHandle, 0, PAGE_READONLY, dwSizeHigh, dwSizeLow, 0);\r\n\tif (pMapHandle == 0) {\r\n\t\tCloseHandle(pHandle);\r\n\t\treturn -1;\r\n\t}\r\n\t*pSize = ((int64_t)dwSizeHigh << 32) | dwSizeLow;\r\n\t/* Obtain the view */\r\n\tpView = MapViewOfFile(pMapHandle, FILE_MAP_READ, 0, 0, (SIZE_T)(*pSize));\r\n\tif (pView) {\r\n\t\t/* Let the upper layer point to the view */\r\n\t\t*ppMap = pView;\r\n\t}\r\n\t/* Close the handle\r\n\t* According to MSDN it's OK the close the HANDLES.\r\n\t*/\r\n\tCloseHandle(pMapHandle);\r\n\tCloseHandle(pHandle);\r\n\treturn pView ? SOD_OK : -1;\r\n}\r\n/* void (*xUnmap)(void *, size_t)  */\r\nstatic void WinVfs_Unmap(void *pView, size_t nSize)\r\n{\r\n\tnSize = 0; /* Compiler warning */\r\n\tUnmapViewOfFile(pView);\r\n}\r\n/* void (*xTempDir)(SyBlob *) */\r\nstatic void WinVfs_TempDir(SyBlob *pCtx)\r\n{\r\n\tCHAR zTemp[1024];\r\n\tDWORD n;\r\n\tn = GetTempPathA(sizeof(zTemp), zTemp);\r\n\tif (n < 1) {\r\n\t\t/* Assume the default windows temp directory */\r\n\t\tlibcox_result_string(pCtx, \"C:\\\\Windows\\\\Temp\", -1/*Compute length automatically*/);\r\n\t}\r\n\telse {\r\n\t\tlibcox_result_string(pCtx, zTemp, (int)n);\r\n\t}\r\n}\r\n/* void (*GetTicks)() */\r\nstatic float WinVfs_GetTicks()\r\n{\r\n\tstatic double freq = -1.0;\r\n\tLARGE_INTEGER lint;\r\n\r\n\tif (freq < 0.0) {\r\n\t\tif (!QueryPerformanceFrequency(&lint))\r\n\t\t\treturn -1.0f;\r\n\t\tfreq = lint.QuadPart;\r\n\t}\r\n\tif (!QueryPerformanceCounter(&lint))\r\n\t\treturn -1.0f;\r\n\treturn (float)(lint.QuadPart / freq);\r\n}\r\n/* An instance of the following structure is used to record state information\r\n* while iterating throw directory entries.\r\n*/\r\ntypedef struct WinDir_Info WinDir_Info;\r\nstruct WinDir_Info\r\n{\r\n\tHANDLE pDirHandle;\r\n\tvoid *pPath;\r\n\tWIN32_FIND_DATAW sInfo;\r\n\tint rc;\r\n};\r\n/* int (*xOpenDir)(const char *, void **) */\r\nstatic int WinDir_Open(const char *zPath, void **ppHandle)\r\n{\r\n\tWinDir_Info *pDirInfo;\r\n\tvoid *pConverted;\r\n\tchar *zPrep;\r\n\tsize_t n;\r\n\t/* Prepare the path */\r\n\tn = strlen(zPath);\r\n\tzPrep = (char *)HeapAlloc(GetProcessHeap(), 0, n + sizeof(\"\\\\*\") + 4);\r\n\tif (zPrep == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tmemcpy(zPrep, (const void *)zPath, n);\r\n\tzPrep[n] = '\\\\';\r\n\tzPrep[n + 1] = '*';\r\n\tzPrep[n + 2] = 0;\r\n\tpConverted = convertUtf8Filename(zPrep);\r\n\tHeapFree(GetProcessHeap(), 0, zPrep);\r\n\tif (pConverted == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\t/* Allocate a new instance */\r\n\tpDirInfo = (WinDir_Info *)HeapAlloc(GetProcessHeap(), 0, sizeof(WinDir_Info));\r\n\tif (pDirInfo == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tpDirInfo->rc = SOD_OK;\r\n\tpDirInfo->pDirHandle = FindFirstFileW((LPCWSTR)pConverted, &pDirInfo->sInfo);\r\n\tif (pDirInfo->pDirHandle == INVALID_HANDLE_VALUE) {\r\n\t\t/* Cannot open directory */\r\n\t\tHeapFree(GetProcessHeap(), 0, pConverted);\r\n\t\tHeapFree(GetProcessHeap(), 0, pDirInfo);\r\n\t\treturn -1;\r\n\t}\r\n\t/* Save the path */\r\n\tpDirInfo->pPath = pConverted;\r\n\t/* Save our structure */\r\n\t*ppHandle = pDirInfo;\r\n\treturn SOD_OK;\r\n}\r\n/* void (*xCloseDir)(void *) */\r\nstatic void WinDir_Close(void *pUserData)\r\n{\r\n\tWinDir_Info *pDirInfo = (WinDir_Info *)pUserData;\r\n\tif (pDirInfo->pDirHandle != INVALID_HANDLE_VALUE) {\r\n\t\tFindClose(pDirInfo->pDirHandle);\r\n\t}\r\n\tHeapFree(GetProcessHeap(), 0, pDirInfo->pPath);\r\n\tHeapFree(GetProcessHeap(), 0, pDirInfo);\r\n}\r\n/* int (*xDirRead)(void *, SyBlob *) */\r\nstatic int WinDir_Read(void *pUserData, SyBlob *pVal)\r\n{\r\n\tWinDir_Info *pDirInfo = (WinDir_Info *)pUserData;\r\n\tLPWIN32_FIND_DATAW pData;\r\n\tchar *zName;\r\n\tBOOL rc;\r\n\tsize_t n;\r\n\tif (pDirInfo->rc != SOD_OK) {\r\n\t\t/* No more entry to process */\r\n\t\treturn -1;\r\n\t}\r\n\tpData = &pDirInfo->sInfo;\r\n\tfor (;;) {\r\n\t\tzName = unicodeToUtf8(pData->cFileName);\r\n\t\tif (zName == 0) {\r\n\t\t\t/* Out of memory */\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tn = strlen(zName);\r\n\t\t/* Ignore '.' && '..' */\r\n\t\tif (n > sizeof(\"..\") - 1 || zName[0] != '.' || (n == sizeof(\"..\") - 1 && zName[1] != '.')) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tHeapFree(GetProcessHeap(), 0, zName);\r\n\t\trc = FindNextFileW(pDirInfo->pDirHandle, &pDirInfo->sInfo);\r\n\t\tif (!rc) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\t/* Return the current file name */\r\n\tlibcox_result_string(pVal, zName, -1);\r\n\tHeapFree(GetProcessHeap(), 0, zName);\r\n\t/* Point to the next entry */\r\n\trc = FindNextFileW(pDirInfo->pDirHandle, &pDirInfo->sInfo);\r\n\tif (!rc) {\r\n\t\tpDirInfo->rc = -1;\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/* void (*xRewindDir)(void *) */\r\nstatic void WinDir_Rewind(void *pUserData)\r\n{\r\n\tWinDir_Info *pDirInfo = (WinDir_Info *)pUserData;\r\n\tFindClose(pDirInfo->pDirHandle);\r\n\tpDirInfo->pDirHandle = FindFirstFileW((LPCWSTR)pDirInfo->pPath, &pDirInfo->sInfo);\r\n\tif (pDirInfo->pDirHandle == INVALID_HANDLE_VALUE) {\r\n\t\tpDirInfo->rc = -1;\r\n\t}\r\n\telse {\r\n\t\tpDirInfo->rc = SOD_OK;\r\n\t}\r\n}\r\n#ifndef MAX_PATH\r\n#define MAX_PATH 260\r\n#endif /* MAX_PATH */\r\n/* Export the windows vfs */\r\nstatic const sod_vfs sWinVfs = {\r\n\t\"Windows_vfs\",\r\n\tLIBCOX_VFS_VERSION,\r\n\t0,\r\n\tMAX_PATH,\r\n\tWinVfs_chdir,    /* int (*xChdir)(const char *) */\r\n\tWinVfs_getcwd,   /* int (*xGetcwd)(SyBlob *) */\r\n\tWinVfs_mkdir,    /* int (*xMkdir)(const char *, int, int) */\r\n\tWinVfs_rmdir,    /* int (*xRmdir)(const char *) */\r\n\tWinVfs_isdir,    /* int (*xIsdir)(const char *) */\r\n\tWinVfs_Rename,   /* int (*xRename)(const char *, const char *) */\r\n\tWinVfs_Realpath, /*int (*xRealpath)(const char *, SyBlob *)*/\r\n   /* Directory */\r\n\tWinDir_Open,\r\n\tWinDir_Close,\r\n\tWinDir_Read,\r\n\tWinDir_Rewind,\r\n\t/* Systems function */\r\n\tWinVfs_unlink, /* int (*xUnlink)(const char *) */\r\n\tWinVfs_FileExists, /* int (*xFileExists)(const char *) */\r\n\tWinVfs_DiskFreeSpace, /* int64_t (*xFreeSpace)(const char *) */\r\n\tWinVfs_DiskTotalSpace, /* int64_t (*xTotalSpace)(const char *) */\r\n\tWinVfs_FileSize, /* int64_t (*xFileSize)(const char *) */\r\n\tWinVfs_isfile,     /* int (*xIsfile)(const char *) */\r\n\tWinVfs_isfile,     /* int (*xReadable)(const char *) */\r\n\tWinVfs_iswritable, /* int (*xWritable)(const char *) */\r\n\tWinVfs_isexecutable, /* int (*xExecutable)(const char *) */\r\n\tWinVfs_Getenv,     /* int (*xGetenv)(const char *, SyBlob *) */\r\n\tWinVfs_Setenv,     /* int (*xSetenv)(const char *, const char *) */\r\n\tWinVfs_Mmap,       /* int (*xMmap)(const char *, void **, size_t *) */\r\n\tWinVfs_Unmap,      /* void (*xUnmap)(void *, size_t);  */\r\n\tWinVfs_TempDir,    /* void (*xTempDir)(SyBlob *) */\r\n\tWinVfs_GetTicks  /* float (*xTicks)(void) */\r\n};\r\n\r\n#elif defined(__UNIXES__)\r\n/*\r\n* UNIX VFS implementation for the LIBCOX engine.\r\n* Authors:\r\n*    Symisc Systems, devel@symisc.net.\r\n*    Copyright (C) Symisc Systems, http://libcox.symisc.net\r\n* Status:\r\n*    Stable.\r\n*/\r\n#include <sys/types.h>\r\n#include <limits.h>\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\n#include <sys/time.h>\r\n#else\r\n#include <time.h>\r\n#endif /* SOD_ENABLE_NET_TRAIN */\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n#include <sys/uio.h>\r\n#include <sys/stat.h>\r\n#ifndef SOD_NO_MMAP\r\n#include <sys/mman.h>\r\n#endif\r\n#include <sys/file.h>\r\n#include <dirent.h>\r\n#include <utime.h>\r\n\r\n#ifndef PATH_MAX\r\n#define PATH_MAX 4096\r\n#endif /* PATH_MAX */\r\n\r\n/* int (*xchdir)(const char *) */\r\nstatic int UnixVfs_chdir(const char *zPath)\r\n{\r\n\tint rc;\r\n\trc = chdir(zPath);\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int (*xGetcwd)(SyBlob *) */\r\nstatic int UnixVfs_getcwd(SyBlob *pCtx)\r\n{\r\n\tchar zBuf[4096];\r\n\tchar *zDir;\r\n\t/* Get the current directory */\r\n\tzDir = getcwd(zBuf, sizeof(zBuf));\r\n\tif (zDir == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tlibcox_result_string(pCtx, zDir, -1/*Compute length automatically*/);\r\n\treturn SOD_OK;\r\n}\r\n/* int (*xMkdir)(const char *, int, int) */\r\nstatic int UnixVfs_mkdir(const char *zPath, int mode, int recursive)\r\n{\r\n\tint rc;\r\n\trc = mkdir(zPath, mode);\r\n\trecursive = 0; /* cc warning */\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int (*xIsdir)(const char *) */\r\nstatic int UnixVfs_isdir(const char *zPath)\r\n{\r\n\tstruct stat st;\r\n\tint rc;\r\n\trc = stat(zPath, &st);\r\n\tif (rc != 0) {\r\n\t\treturn -1;\r\n\t}\r\n\trc = S_ISDIR(st.st_mode);\r\n\treturn rc ? 1 : 0;\r\n}\r\n/* int (*xUnlink)(const char *) */\r\nstatic int UnixVfs_unlink(const char *zPath)\r\n{\r\n\tint rc;\r\n\trc = unlink(zPath);\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int (*xFileExists)(const char *) */\r\nstatic int UnixVfs_FileExists(const char *zPath)\r\n{\r\n\tint rc;\r\n\trc = access(zPath, F_OK);\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int64_t (*xFileSize)(const char *) */\r\nstatic int64_t UnixVfs_FileSize(const char *zPath)\r\n{\r\n\tstruct stat st;\r\n\tint rc;\r\n\trc = stat(zPath, &st);\r\n\tif (rc != 0) {\r\n\t\treturn -1;\r\n\t}\r\n\treturn (int64_t)st.st_size;\r\n}\r\n/* int (*xIsfile)(const char *) */\r\nstatic int UnixVfs_isfile(const char *zPath)\r\n{\r\n\tstruct stat st;\r\n\tint rc;\r\n\trc = stat(zPath, &st);\r\n\tif (rc != 0) {\r\n\t\treturn -1;\r\n\t}\r\n\trc = S_ISREG(st.st_mode);\r\n\treturn rc ? SOD_OK : -1;\r\n}\r\n/* int (*xReadable)(const char *) */\r\nstatic int UnixVfs_isreadable(const char *zPath)\r\n{\r\n\tint rc;\r\n\trc = access(zPath, R_OK);\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int (*xWritable)(const char *) */\r\nstatic int UnixVfs_iswritable(const char *zPath)\r\n{\r\n\tint rc;\r\n\trc = access(zPath, W_OK);\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int (*xExecutable)(const char *) */\r\nstatic int UnixVfs_isexecutable(const char *zPath)\r\n{\r\n\tint rc;\r\n\trc = access(zPath, X_OK);\r\n\treturn rc == 0 ? SOD_OK : -1;\r\n}\r\n/* int (*xMmap)(const char *, void **, size_t *) */\r\nstatic int UnixVfs_Mmap(const char *zPath, void **ppMap, size_t *pSize)\r\n{\r\n#ifndef SOD_NO_MMAP\r\n\tstruct stat st;\r\n\tvoid *pMap;\r\n\tint fd;\r\n\tint rc;\r\n\t/* Open the file in a read-only mode */\r\n\tfd = open(zPath, O_RDONLY);\r\n\tif (fd < 0) {\r\n\t\treturn -1;\r\n\t}\r\n\t/* stat the handle */\r\n\tfstat(fd, &st);\r\n\t/* Obtain a memory view of the whole file */\r\n\tpMap = mmap(0, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\r\n\trc = SOD_OK;\r\n\tif (pMap == MAP_FAILED) {\r\n\t\trc = -1;\r\n\t}\r\n\telse {\r\n\t\t/* Point to the memory view */\r\n\t\t*ppMap = pMap;\r\n\t\t*pSize = st.st_size;\r\n\t}\r\n\tclose(fd);\r\n\treturn rc;\r\n#else\r\n\treturn -1;\r\n#endif\r\n}\r\n/* void (*xUnmap)(void *, size_t)  */\r\nstatic void UnixVfs_Unmap(void *pView, size_t nSize)\r\n{\r\n#ifndef SOD_NO_MMAP\r\n\tmunmap(pView, nSize);\r\n#endif\r\n}\r\n/* int (*xOpenDir)(const char *, void **) */\r\nstatic int UnixDir_Open(const char *zPath, void **ppHandle)\r\n{\r\n\tDIR *pDir;\r\n\t/* Open the target directory */\r\n\tpDir = opendir(zPath);\r\n\tif (pDir == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\t/* Save our structure */\r\n\t*ppHandle = pDir;\r\n\treturn SOD_OK;\r\n}\r\n/* void (*xCloseDir)(void *) */\r\nstatic void UnixDir_Close(void *pUserData)\r\n{\r\n\tclosedir((DIR *)pUserData);\r\n}\r\n/* (*xReadDir)(void *, SyBlob *) */\r\nstatic int UnixDir_Read(void *pUserData, SyBlob *pVal)\r\n{\r\n\tDIR *pDir = (DIR *)pUserData;\r\n\tstruct dirent *pEntry;\r\n\tchar *zName = 0; /* cc warning */\r\n\tuint32_t n = 0;\r\n\tfor (;;) {\r\n\t\tpEntry = readdir(pDir);\r\n\t\tif (pEntry == 0) {\r\n\t\t\t/* No more entries to process */\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tzName = pEntry->d_name;\r\n\t\tn = strlen(zName);\r\n\t\t/* Ignore '.' && '..' */\r\n\t\tif (n > sizeof(\"..\") - 1 || zName[0] != '.' || (n == sizeof(\"..\") - 1 && zName[1] != '.')) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Next entry */\r\n\t}\r\n\t/* Return the current file name */\r\n\tlibcox_result_string(pVal, zName, (int)n);\r\n\treturn SOD_OK;\r\n}\r\n/* void (*xRewindDir)(void *) */\r\nstatic void UnixDir_Rewind(void *pUserData)\r\n{\r\n\trewinddir((DIR *)pUserData);\r\n}\r\n/* float xTicks() */\r\nstatic float UnixVfs_get_ticks()\r\n{\r\n\t/* This is merely used for reporting training time between\r\n\t* epochs so we really don't care about precision here.\r\n\t*/\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\n\tstruct timeval time;\r\n\tgettimeofday(&time, 0);\r\n\treturn (float)time.tv_sec + 1000*time.tv_usec;\r\n#else\r\n\treturn (float)time(0);\r\n#endif\r\n}\r\n/* Export the UNIX vfs */\r\nstatic const sod_vfs sUnixVfs = {\r\n\t\"Unix_vfs\",\r\n\tLIBCOX_VFS_VERSION,\r\n\t0,\r\n\tPATH_MAX,\r\n\tUnixVfs_chdir,    /* int (*xChdir)(const char *) */\r\n\tUnixVfs_getcwd,   /* int (*xGetcwd)(SyBlob *) */\r\n\tUnixVfs_mkdir,    /* int (*xMkdir)(const char *, int, int) */\r\n\t0,    /* int (*xRmdir)(const char *) */\r\n\tUnixVfs_isdir,    /* int (*xIsdir)(const char *) */\r\n\t0,   /* int (*xRename)(const char *, const char *) */\r\n\t0, /*int (*xRealpath)(const char *, SyBlob *)*/\r\n\t/* Directory */\r\n\tUnixDir_Open,\r\n\tUnixDir_Close,\r\n\tUnixDir_Read,\r\n\tUnixDir_Rewind,\r\n   /* Systems */\r\n    UnixVfs_unlink,   /* int (*xUnlink)(const char *) */\r\n    UnixVfs_FileExists, /* int (*xFileExists)(const char *) */\r\n\t0,             /* int64_t (*xFreeSpace)(const char *) */\r\n\t0,             /* int64_t (*xTotalSpace)(const char *) */\r\n\tUnixVfs_FileSize, /* int64_t (*xFileSize)(const char *) */\r\n\tUnixVfs_isfile,     /* int (*xIsfile)(const char *) */\r\n\tUnixVfs_isreadable, /* int (*xReadable)(const char *) */\r\n\tUnixVfs_iswritable, /* int (*xWritable)(const char *) */\r\n\tUnixVfs_isexecutable, /* int (*xExecutable)(const char *) */\r\n\t0,     /* int (*xGetenv)(const char *, SyBlob *) */\r\n\t0,     /* int (*xSetenv)(const char *, const char *) */\r\n\tUnixVfs_Mmap,       /* int (*xMmap)(const char *, void **, int64_t *) */\r\n\tUnixVfs_Unmap,      /* void (*xUnmap)(void *, int64_t);  */\r\n\t0,    /* void (*xTempDir)(SyBlob *) */\r\n\tUnixVfs_get_ticks   /* float (*xTicks)() */\r\n};\r\n#else\r\n/* Export the NULL VFS for OS_OTHER */\r\nstatic const sod_vfs sNullVfs = {\r\n\t\"Null_vfs\",\r\n\tLIBCOX_VFS_VERSION,\r\n\t0,\r\n\t255,\r\n\t0,    /* int (*xChdir)(const char *) */\r\n\t0,   /* int (*xGetcwd)(SyBlob *) */\r\n\t0,    /* int (*xMkdir)(const char *, int, int) */\r\n\t0,    /* int (*xRmdir)(const char *) */\r\n\t0,    /* int (*xIsdir)(const char *) */\r\n\t0,   /* int (*xRename)(const char *, const char *) */\r\n\t0, /*int (*xRealpath)(const char *, SyBlob *)*/\r\n\t/* Directory */\r\n\t0,\r\n\t0,\r\n\t0,\r\n\t0,\r\n\t0,   /* int (*xUnlink)(const char *) */\r\n\t0, /* int (*xFileExists)(const char *) */\r\n\t0,             /* int64_t (*xFreeSpace)(const char *) */\r\n\t0,             /* int64_t (*xTotalSpace)(const char *) */\r\n\t0, /* int64_t (*xFileSize)(const char *) */\r\n\t0,     /* int (*xIsfile)(const char *) */\r\n\t0, /* int (*xReadable)(const char *) */\r\n\t0, /* int (*xWritable)(const char *) */\r\n\t0, /* int (*xExecutable)(const char *) */\r\n\t0,     /* int (*xGetenv)(const char *, SyBlob *) */\r\n\t0,     /* int (*xSetenv)(const char *, const char *) */\r\n\t0,       /* int (*xMmap)(const char *, void **, int64_t *) */\r\n\t0,      /* void (*xUnmap)(void *, int64_t);  */\r\n\t0,    /* void (*xTempDir)(SyBlob *) */\r\n\t0   /* float (*xTicks)() */\r\n};\r\n#endif /* __WINNT__/__UNIXES__/OS_OTHER */\r\n/*\r\n* Export the builtin vfs.\r\n* Return a pointer to the builtin vfs if available.\r\n* Otherwise return the null_vfs [i.e: a no-op vfs] instead.\r\n* Note:\r\n*  The built-in vfs is always available for Windows/UNIX systems.\r\n* Note:\r\n*  If the engine is compiled with the LIBCOX_DISABLE_DISK_IO/LIBCOX_DISABLE_BUILTIN_FUNC\r\n*  directives defined then this function return the null_vfs instead.\r\n*/\r\nstatic const sod_vfs * sodExportBuiltinVfs(void)\r\n{\r\n#ifdef __WINNT__\r\n\treturn &sWinVfs;\r\n#elif defined(OS_OTHER)\r\n\treturn &sNullVfs;\r\n#else\r\n\t/* Assume UNIX-Like */\r\n\treturn &sUnixVfs;\r\n#endif /* __WINNT__/__UNIXES__ */\r\n}\r\n/* @VFS */\r\n#ifdef TWO_PI\r\n#undef TWO_PI\r\n#endif /* Important */\r\n/* From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform */\r\n#define TWO_PI 6.2831853071795864769252866\r\nstatic float rand_normal()\r\n{\r\n\tstatic int haveSpare = 0;\r\n\tstatic double rand1, rand2;\r\n\r\n\tif (haveSpare)\r\n\t{\r\n\t\thaveSpare = 0;\r\n\t\treturn sqrt(rand1) * sin(rand2);\r\n\t}\r\n\r\n\thaveSpare = 1;\r\n\r\n\trand1 = rand() / ((double)RAND_MAX);\r\n\tif (rand1 < 1e-100) rand1 = 1e-100;\r\n\trand1 = -2 * log(rand1);\r\n\trand2 = (rand() / ((double)RAND_MAX)) * TWO_PI;\r\n\r\n\treturn sqrt(rand1) * cos(rand2);\r\n}\r\nstatic float rand_uniform(float min, float max)\r\n{\r\n\tif (max < min) {\r\n\t\tfloat swap = min;\r\n\t\tmin = max;\r\n\t\tmax = swap;\r\n\t}\r\n\treturn ((float)rand() / RAND_MAX * (max - min)) + min;\r\n}\r\nstatic int constrain_int(int a, int min, int max)\r\n{\r\n\tif (a < min) return min;\r\n\tif (a > max) return max;\r\n\treturn a;\r\n}\r\nstatic int rand_int(int min, int max)\r\n{\r\n\tif (max < min) {\r\n\t\tint s = min;\r\n\t\tmin = max;\r\n\t\tmax = s;\r\n\t}\r\n\tint r = (rand() % (max - min + 1)) + min;\r\n\treturn r;\r\n}\r\nstatic float rand_scale(float s)\r\n{\r\n\tfloat scale = rand_uniform(1, s);\r\n\tif (rand() % 2) return scale;\r\n\treturn 1. / scale;\r\n}\r\nstatic inline void sod_md_alloc_dyn_img(sod_img *pFrame, int w, int h, int c)\r\n{\r\n\tif (pFrame->data == 0 || pFrame->w < w || pFrame->h < h || pFrame->c != c) {\r\n\t\tpFrame->w = w;\r\n\t\tpFrame->h = h;\r\n\t\tpFrame->c = c;\r\n\t\tpFrame->data = realloc(pFrame->data, w * h * c * sizeof(float));\r\n\t}\r\n}\r\n#ifndef SOD_DISABLE_CNN\r\n/*\r\n * List of implemented layers (excluding LSTM).\r\n */\r\ntypedef enum {\r\n\tCONVOLUTIONAL,\r\n\tDECONVOLUTIONAL,\r\n\tCONNECTED,\r\n\tMAXPOOL,\r\n\tSOFTMAX,\r\n\tDETECTION,\r\n\tDROPOUT,\r\n\tCROP,\r\n\tROUTE,\r\n\tCOST,\r\n\tNORMALIZATION,\r\n\tAVGPOOL,\r\n\tLOCAL,\r\n\tSHORTCUT,\r\n\tACTIVE,\r\n\tRNN,\r\n\tGRU,\r\n\tCRNN,\r\n\tBATCHNORM,\r\n\tNETWORK,\r\n\tXNOR,\r\n\tREGION,\r\n\tREORG,\r\n\tLSTM,\r\n\tBLANK\r\n} SOD_CNN_LAYER_TYPE;\r\n/* Forward declaration */\r\ntypedef struct tree tree;\r\ntypedef struct network network;\r\ntypedef struct network_state network_state;\r\ntypedef struct layer layer;\r\ntypedef enum {\r\n\tCONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM\r\n} learning_rate_policy;\r\ntypedef enum {\r\n\tLOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN\r\n}ACTIVATION;\r\ntypedef enum {\r\n\tSSE, MASKED, SMOOTH\r\n} COST_TYPE;\r\nstruct tree {\r\n\tint *leaf;\r\n\tint n;\r\n\tint *parent;\r\n\tint *child;\r\n\tint *group;\r\n\tchar **name;\r\n\r\n\tint groups;\r\n\tint *group_size;\r\n\tint *group_offset;\r\n};\r\nstruct network {\r\n\tsod_cnn *pNet;\r\n\tfloat *workspace;\r\n\tint n;\r\n\tint batch;\r\n\tuint64_t *seen;\r\n\tfloat epoch;\r\n\tint subdivisions;\r\n\tfloat momentum;\r\n\tfloat decay;\r\n\tlayer *layers;\r\n\tint outputs;\r\n\tfloat *output;\r\n\tlearning_rate_policy policy;\r\n\tsize_t workspace_size;\r\n\tfloat learning_rate;\r\n\tfloat gamma;\r\n\tfloat scale;\r\n\tfloat power;\r\n\tint time_steps;\r\n\tint step;\r\n\tint max_batches;\r\n\tfloat *scales;\r\n\tint   *steps;\r\n\tint num_steps;\r\n\tint burn_in;\r\n\r\n\tint adam;\r\n\tfloat B1;\r\n\tfloat B2;\r\n\tfloat eps;\r\n\r\n\tint inputs;\r\n\tint h, w, c;\r\n\tint max_crop;\r\n\tint min_crop;\r\n\tfloat angle;\r\n\tfloat aspect;\r\n\tfloat exposure;\r\n\tfloat saturation;\r\n\tfloat hue;\r\n\r\n\tint gpu_index;\r\n\ttree *hierarchy;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tfloat **input_gpu;\r\n\tfloat **truth_gpu;\r\n#endif\r\n};\r\nstruct network_state {\r\n\tfloat *truth;\r\n\tfloat *input;\r\n\tfloat *delta;\r\n\tfloat *workspace;\r\n\tint train;\r\n\tint index;\r\n\tnetwork *net;\r\n};\r\nstruct layer {\r\n\tSOD_CNN_LAYER_TYPE type;\r\n\tACTIVATION activation;\r\n\tCOST_TYPE cost_type;\r\n\tvoid(*forward)   (struct layer, struct network_state);\r\n\tvoid(*backward)  (struct layer, struct network_state);\r\n\tvoid(*update)    (struct layer, int, float, float, float);\r\n\tvoid(*forward_gpu)   (struct layer, struct network_state);\r\n\tvoid(*backward_gpu)  (struct layer, struct network_state);\r\n\tvoid(*update_gpu)    (struct layer, int, float, float, float);\r\n\tint batch_normalize;\r\n\tint shortcut;\r\n\tint batch;\r\n\tint forced;\r\n\tint flipped;\r\n\tint inputs;\r\n\tint outputs;\r\n\tint truths;\r\n\tint h, w, c;\r\n\tint out_h, out_w, out_c;\r\n\tint n;\r\n\tint max_boxes;\r\n\tint groups;\r\n\tint size;\r\n\tint side;\r\n\tint stride;\r\n\tint reverse;\r\n\tint pad;\r\n\tint sqrt;\r\n\tint flip;\r\n\tint index;\r\n\tint binary;\r\n\tint xnor;\r\n\tint steps;\r\n\tint hidden;\r\n\tfloat dot;\r\n\tfloat angle;\r\n\tfloat jitter;\r\n\tfloat saturation;\r\n\tfloat exposure;\r\n\tfloat shift;\r\n\tfloat ratio;\r\n\tint softmax;\r\n\tint classes;\r\n\tint coords;\r\n\tint background;\r\n\tint rescore;\r\n\tint objectness;\r\n\tint does_cost;\r\n\tint joint;\r\n\tint noadjust;\r\n\tint reorg;\r\n\tint log;\r\n\r\n\tint adam;\r\n\tfloat B1;\r\n\tfloat B2;\r\n\tfloat eps;\r\n\tint t;\r\n\r\n\tfloat alpha;\r\n\tfloat beta;\r\n\tfloat kappa;\r\n\r\n\tfloat coord_scale;\r\n\tfloat object_scale;\r\n\tfloat noobject_scale;\r\n\tfloat mask_scale;\r\n\tfloat class_scale;\r\n\tint bias_match;\r\n\tint random;\r\n\tfloat thresh;\r\n\tint classfix;\r\n\tint absolute;\r\n\r\n\tint dontload;\r\n\tint dontloadscales;\r\n\r\n\tfloat temperature;\r\n\tfloat probability;\r\n\tfloat scale;\r\n\r\n\tchar  * cweights;\r\n\tint   * indexes;\r\n\tint   * input_layers;\r\n\tint   * input_sizes;\r\n\tint   * map;\r\n\tfloat * rand;\r\n\tfloat * cost;\r\n\tfloat * state;\r\n\tfloat * prev_state;\r\n\tfloat * forgot_state;\r\n\tfloat * forgot_delta;\r\n\tfloat * state_delta;\r\n\r\n\tfloat * concat;\r\n\tfloat * concat_delta;\r\n\r\n\tfloat * binary_weights;\r\n\r\n\tfloat * biases;\r\n\tfloat * bias_updates;\r\n\r\n\tfloat * scales;\r\n\tfloat * scale_updates;\r\n\r\n\tfloat * weights;\r\n\tfloat * weight_updates;\r\n\r\n\tfloat * col_image;\r\n\tfloat * delta;\r\n\tfloat * output;\r\n\tfloat * squared;\r\n\tfloat * norms;\r\n\r\n\tfloat * spatial_mean;\r\n\tfloat * mean;\r\n\tfloat * variance;\r\n\r\n\tfloat * mean_delta;\r\n\tfloat * variance_delta;\r\n\r\n\tfloat * rolling_mean;\r\n\tfloat * rolling_variance;\r\n\r\n\tfloat * x;\r\n\tfloat * x_norm;\r\n\r\n\tfloat * m;\r\n\tfloat * v;\r\n\r\n\tfloat * z_cpu;\r\n\tfloat * r_cpu;\r\n\tfloat * h_cpu;\r\n\r\n\tfloat * binary_input;\r\n\r\n\tstruct layer *input_layer;\r\n\tstruct layer *self_layer;\r\n\tstruct layer *output_layer;\r\n\r\n\tstruct layer *input_gate_layer;\r\n\tstruct layer *state_gate_layer;\r\n\tstruct layer *input_save_layer;\r\n\tstruct layer *state_save_layer;\r\n\tstruct layer *input_state_layer;\r\n\tstruct layer *state_state_layer;\r\n\r\n\tstruct layer *input_z_layer;\r\n\tstruct layer *state_z_layer;\r\n\r\n\tstruct layer *input_r_layer;\r\n\tstruct layer *state_r_layer;\r\n\r\n\tstruct layer *input_h_layer;\r\n\tstruct layer *state_h_layer;\r\n\r\n\ttree *softmax_tree;\r\n\r\n\tsize_t workspace_size;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tint *indexes_gpu;\r\n\r\n\tfloat *z_gpu;\r\n\tfloat *r_gpu;\r\n\tfloat *h_gpu;\r\n\r\n\tfloat *m_gpu;\r\n\tfloat *v_gpu;\r\n\r\n\tfloat * prev_state_gpu;\r\n\tfloat * forgot_state_gpu;\r\n\tfloat * forgot_delta_gpu;\r\n\tfloat * state_gpu;\r\n\tfloat * state_delta_gpu;\r\n\tfloat * gate_gpu;\r\n\tfloat * gate_delta_gpu;\r\n\tfloat * save_gpu;\r\n\tfloat * save_delta_gpu;\r\n\tfloat * concat_gpu;\r\n\tfloat * concat_delta_gpu;\r\n\r\n\tfloat *binary_input_gpu;\r\n\tfloat *binary_weights_gpu;\r\n\r\n\tfloat * mean_gpu;\r\n\tfloat * variance_gpu;\r\n\r\n\tfloat * rolling_mean_gpu;\r\n\tfloat * rolling_variance_gpu;\r\n\r\n\tfloat * variance_delta_gpu;\r\n\tfloat * mean_delta_gpu;\r\n\r\n\tfloat * col_image_gpu;\r\n\r\n\tfloat * x_gpu;\r\n\tfloat * x_norm_gpu;\r\n\tfloat * weights_gpu;\r\n\tfloat * weight_updates_gpu;\r\n\r\n\tfloat * biases_gpu;\r\n\tfloat * bias_updates_gpu;\r\n\r\n\tfloat * scales_gpu;\r\n\tfloat * scale_updates_gpu;\r\n\r\n\tfloat * output_gpu;\r\n\tfloat * delta_gpu;\r\n\tfloat * rand_gpu;\r\n\tfloat * squared_gpu;\r\n\tfloat * norms_gpu;\r\n#ifdef CUDNN\r\n\tcudnnTensorDescriptor_t srcTensorDesc, dstTensorDesc;\r\n\tcudnnTensorDescriptor_t dsrcTensorDesc, ddstTensorDesc;\r\n\tcudnnFilterDescriptor_t weightDesc;\r\n\tcudnnFilterDescriptor_t dweightDesc;\r\n\tcudnnConvolutionDescriptor_t convDesc;\r\n\tcudnnConvolutionFwdAlgo_t fw_algo;\r\n\tcudnnConvolutionBwdDataAlgo_t bd_algo;\r\n\tcudnnConvolutionBwdFilterAlgo_t bf_algo;\r\n#endif\r\n#endif\r\n};\r\ntypedef struct {\r\n\tfloat x, y, w, h;\r\n} box;\r\n#define SOD_NET_ALLOCATED 1 /* Memory allocated for th network */\r\n#define SOD_NET_STATE_READY 7 /* Network ready for prediction */\r\n/* Processing Flags */\r\n#define SOD_LAYER_RNN    0x001  /* RNN Layer detected */\r\n#define SOD_RNN_MAP_FILE 0x002  /* Mapped RNN training file */\r\nstruct sod_cnn {\r\n\tconst sod_vfs *pVfs;\r\n\tSySet aBoxes;\r\n\tsod_img sRz;\r\n\tsod_img sPart;\r\n\tsod_img sTmpim;\r\n\tfloat nms;\r\n\tfloat temp;\r\n\tfloat hier_thresh;\r\n\tfloat thresh;\r\n\tint nInput;\r\n\tfloat *aInput;\r\n\tint flags;\r\n\tconst char *zRnnSeed;\r\n\tint rnn_gen_len;\r\n\tint c_rnn;\r\n\tint ow;\r\n\tint oh;\r\n\tnetwork net; /* The network  */\r\n\tlayer det;  /* Detection layer */\r\n\tbox *boxes;\r\n\tfloat **probs;\r\n\tfloat *pOut;      /* Prediction output */\r\n\tint nOuput;       /* pOut[] length */\r\n\tconst char *zErr; /* Error message if any */\r\n\tuint32_t nErr;    /* Parse error count */\r\n\tint state;        /* Network state */\r\n\tconst char **azNames; /**/\r\n\tSyBlob sRnnConsumer;\r\n\tSyBlob sLogConsumer;\r\n\tProcRnnCallback xRnn; /* RNN callback */\r\n\tvoid *pRnnData;\r\n\tProcLogCallback xLog; /* Log callback */\r\n\tvoid *pLogData;\r\n};\r\n/*\r\n* CNN Built-in Configurations.\r\n*/\r\nstatic const char zYolo[] = {\r\n\t\"[net]\\n\"\r\n\t\"batch=1\\n\"\r\n\t\"subdivisions=1\\n\"\r\n\t\"width=416\\n\"\r\n\t\"height=416\\n\"\r\n\t\"channels=3\\n\"\r\n\t\"momentum=0.9\\n\"\r\n\t\"decay=0.0005\\n\"\r\n\t\"angle=0\\n\"\r\n\t\"saturation = 1.5\\n\"\r\n\t\"exposure = 1.5\\n\"\r\n\t\"hue=.1\\n\"\r\n\t\"\\n\"\r\n\t\"learning_rate=0.001\\n\"\r\n\t\"max_batches = 120000\\n\"\r\n\t\"policy=steps\\n\"\r\n\t\"steps=-1,100,80000,100000\\n\"\r\n\t\"scales=.1,10,.1,.1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=32\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=128\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=128\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=256\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=128\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=256\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=256\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=256\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"\\n\"\r\n\t\"#######\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[route]\\n\"\r\n\t\"layers=-9\\n\"\r\n\t\"\\n\"\r\n\t\"[reorg]\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[route]\\n\"\r\n\t\"layers=-1,-3\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=425\\n\"\r\n\t\"activation=linear\\n\"\r\n\t\"\\n\"\r\n\t\"[region]\\n\"\r\n\t\"anchors = 0.738768,0.874946,  2.42204,2.65704,  4.30971,7.04493,  10.246,4.59428,  12.6868,11.8741\\n\"\r\n\t\"bias_match=1\\n\"\r\n\t\"classes=80\\n\"\r\n\t\"coords=4\\n\"\r\n\t\"num=5\\n\"\r\n\t\"softmax=1\\n\"\r\n\t\"jitter=.2\\n\"\r\n\t\"rescore=1\\n\"\r\n\t\"\\n\"\r\n\t\"object_scale=5\\n\"\r\n\t\"noobject_scale=1\\n\"\r\n\t\"class_scale=1\\n\"\r\n\t\"coord_scale=1\\n\"\r\n\t\"\\n\"\r\n\t\"absolute=1\\n\"\r\n\t\"thresh = .6\\n\"\r\n\t\"random=0\\n\"\r\n};\r\nstatic const char zTiny[] = {\r\n\t\"[net]\\n\"\r\n\t\"batch=64\\n\"\r\n\t\"subdivisions=8\\n\"\r\n\t\"width=416\\n\"\r\n\t\"height=416\\n\"\r\n\t\"channels=3\\n\"\r\n\t\"momentum=0.9\\n\"\r\n\t\"decay=0.0005\\n\"\r\n\t\"angle=0\\n\"\r\n\t\"saturation = 1.5\\n\"\r\n\t\"exposure = 1.5\\n\"\r\n\t\"hue=.1\\n\"\r\n\t\"\\n\"\r\n\t\"learning_rate=0.001\\n\"\r\n\t\"max_batches = 120000\\n\"\r\n\t\"policy=steps\\n\"\r\n\t\"steps=-1,100,80000,100000\\n\"\r\n\t\"scales=.1,10,.1,.1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=16\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=32\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=128\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=256\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"###########\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=425\\n\"\r\n\t\"activation=linear\\n\"\r\n\t\"\\n\"\r\n\t\"[region]\\n\"\r\n\t\"anchors = 0.738768,0.874946,  2.42204,2.65704,  4.30971,7.04493,  10.246,4.59428,  12.6868,11.8741\\n\"\r\n\t\"bias_match=1\\n\"\r\n\t\"classes=80\\n\"\r\n\t\"coords=4\\n\"\r\n\t\"num=5\\n\"\r\n\t\"softmax=1\\n\"\r\n\t\"jitter=.2\\n\"\r\n\t\"rescore=1\\n\"\r\n\t\"\\n\"\r\n\t\"object_scale=5\\n\"\r\n\t\"noobject_scale=1\\n\"\r\n\t\"class_scale=1\\n\"\r\n\t\"coord_scale=1\\n\"\r\n\t\"\\n\"\r\n\t\"absolute=1\\n\"\r\n\t\"thresh = .6\\n\"\r\n\t\"random=1\\n\"\r\n};\r\nstatic const char zfaceCnn[] = {\r\n\t\"[net]\\n\"\r\n\t\"batch=128\\n\"\r\n\t\"subdivisions=8\\n\"\r\n\t\"width=416\\n\"\r\n\t\"height=416\\n\"\r\n\t\"channels=3\\n\"\r\n\t\"momentum=0.9\\n\"\r\n\t\"decay=0.0005\\n\"\r\n\t\"angle=0\\n\"\r\n\t\"saturation = 1.5\\n\"\r\n\t\"exposure = 1.5\\n\"\r\n\t\"hue=.1\\n\"\r\n\t\"#adam=1\\n\"\r\n\t\"\\n\"\r\n\t\"learning_rate=0.001\\n\"\r\n\t\"max_batches = 50000\\n\"\r\n\t\"policy=steps\\n\"\r\n\t\"steps=-1,500,5000,10000\\n\"\r\n\t\"scales=.1,10,.1,.1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=8\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=16\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=32\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=32\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"#[maxpool]\\n\"\r\n\t\"#size=2\\n\"\r\n\t\"#stride=1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=32\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"###########\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=30\\n\"\r\n\t\"activation=linear\\n\"\r\n\t\"\\n\"\r\n\t\"[region]\\n\"\r\n\t\"anchors = 0.7,0.86,2.1,2.1,4.0,4.16,8.1,8.1,12.0,12.16\\n\"\r\n\t\"bias_match=1\\n\"\r\n\t\"classes=1\\n\"\r\n\t\"coords=4\\n\"\r\n\t\"num=5\\n\"\r\n\t\"softmax=1\\n\"\r\n\t\"jitter=.2\\n\"\r\n\t\"rescore=1\\n\"\r\n\t\"\\n\"\r\n\t\"object_scale=5\\n\"\r\n\t\"noobject_scale=1\\n\"\r\n\t\"class_scale=1\\n\"\r\n\t\"coord_scale=1\\n\"\r\n\t\"\\n\"\r\n\t\"absolute=1\\n\"\r\n\t\"thresh = .6\\n\"\r\n\t\"random=1\\n\"\r\n\t\"\"\r\n};\r\nstatic const char zRnn[] = {\r\n\t\"[net]\\n\"\r\n\t\"subdivisions=1\\n\"\r\n\t\"inputs=256\\n\"\r\n\t\"batch = 1\\n\"\r\n\t\"momentum=0.9\\n\"\r\n\t\"decay=0.001\\n\"\r\n\t\"max_batches = 2000\\n\"\r\n\t\"time_steps=1\\n\"\r\n\t\"learning_rate=0.1\\n\"\r\n\t\"policy=steps\\n\"\r\n\t\"steps=1000,1500\\n\"\r\n\t\"scales=.1,.1\\n\"\r\n\t\"\\n\"\r\n\t\"[rnn]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"output = 1024\\n\"\r\n\t\"hidden=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[rnn]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"output = 1024\\n\"\r\n\t\"hidden=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[rnn]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"output = 1024\\n\"\r\n\t\"hidden=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[connected]\\n\"\r\n\t\"output=256\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[softmax]\\n\"\r\n\t\"\\n\"\r\n\t\"[cost]\\n\"\r\n\t\"type=sse\\n\"\r\n\t\"\\n\"\r\n};\r\nstatic const char zTinyVoc[] = {\r\n\t\"[net]\\n\"\r\n\t\"batch=64\\n\"\r\n\t\"subdivisions=8\\n\"\r\n\t\"width=416\\n\"\r\n\t\"height=416\\n\"\r\n\t\"channels=3\\n\"\r\n\t\"momentum=0.9\\n\"\r\n\t\"decay=0.0005\\n\"\r\n\t\"angle=0\\n\"\r\n\t\"saturation = 1.5\\n\"\r\n\t\"exposure = 1.5\\n\"\r\n\t\"hue=.1\\n\"\r\n\t\"\\n\"\r\n\t\"learning_rate=0.001\\n\"\r\n\t\"max_batches = 40200\\n\"\r\n\t\"policy=steps\\n\"\r\n\t\"steps=-1,100,20000,30000\\n\"\r\n\t\"scales=.1,10,.1,.1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=16\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=32\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=64\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=128\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=256\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=2\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=512\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[maxpool]\\n\"\r\n\t\"size=2\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"###########\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"batch_normalize=1\\n\"\r\n\t\"size=3\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=1024\\n\"\r\n\t\"activation=leaky\\n\"\r\n\t\"\\n\"\r\n\t\"[convolutional]\\n\"\r\n\t\"size=1\\n\"\r\n\t\"stride=1\\n\"\r\n\t\"pad=1\\n\"\r\n\t\"filters=125\\n\"\r\n\t\"activation=linear\\n\"\r\n\t\"\\n\"\r\n\t\"[region]\\n\"\r\n\t\"anchors = 1.08,1.19,  3.42,4.41,  6.63,11.38,  9.42,5.11,  16.62,10.52\\n\"\r\n\t\"bias_match=1\\n\"\r\n\t\"classes=20\\n\"\r\n\t\"coords=4\\n\"\r\n\t\"num=5\\n\"\r\n\t\"softmax=1\\n\"\r\n\t\"jitter=.2\\n\"\r\n\t\"rescore=1\\n\"\r\n\t\"\\n\"\r\n\t\"object_scale=5\\n\"\r\n\t\"noobject_scale=1\\n\"\r\n\t\"class_scale=1\\n\"\r\n\t\"coord_scale=1\\n\"\r\n\t\"\\n\"\r\n\t\"absolute=1\\n\"\r\n\t\"thresh = .6\\n\"\r\n\t\"random=1\\n\"\r\n};\r\nstatic const char *zCoco[] = {\r\n\t\"person\",\r\n\t\"bicycle\",\r\n\t\"car\",\r\n\t\"motorbike\",\r\n\t\"aeroplane\",\r\n\t\"bus\",\r\n\t\"train\",\r\n\t\"truck\",\r\n\t\"boat\",\r\n\t\"traffic light\",\r\n\t\"fire hydrant\",\r\n\t\"stop sign\",\r\n\t\"parking meter\",\r\n\t\"bench\",\r\n\t\"bird\",\r\n\t\"cat\",\r\n\t\"dog\",\r\n\t\"horse\",\r\n\t\"sheep\",\r\n\t\"cow\",\r\n\t\"elephant\",\r\n\t\"bear\",\r\n\t\"zebra\",\r\n\t\"giraffe\",\r\n\t\"backpack\",\r\n\t\"umbrella\",\r\n\t\"handbag\",\r\n\t\"tie\",\r\n\t\"suitcase\",\r\n\t\"frisbee\",\r\n\t\"skis\",\r\n\t\"snowboard\",\r\n\t\"sports ball\",\r\n\t\"kite\",\r\n\t\"baseball bat\",\r\n\t\"baseball glove\",\r\n\t\"skateboard\",\r\n\t\"surfboard\",\r\n\t\"tennis racket\",\r\n\t\"bottle\",\r\n\t\"wine glass\",\r\n\t\"cup\",\r\n\t\"fork\",\r\n\t\"knife\",\r\n\t\"spoon\",\r\n\t\"bowl\",\r\n\t\"banana\",\r\n\t\"apple\",\r\n\t\"sandwich\",\r\n\t\"orange\",\r\n\t\"broccoli\",\r\n\t\"carrot\",\r\n\t\"hot dog\",\r\n\t\"pizza\",\r\n\t\"donut\",\r\n\t\"cake\",\r\n\t\"chair\",\r\n\t\"sofa\",\r\n\t\"pottedplant\",\r\n\t\"bed\",\r\n\t\"diningtable\",\r\n\t\"toilet\",\r\n\t\"tvmonitor\",\r\n\t\"laptop\",\r\n\t\"mouse\",\r\n\t\"remote\",\r\n\t\"keyboard\",\r\n\t\"cell phone\",\r\n\t\"microwave\",\r\n\t\"oven\",\r\n\t\"toaster\",\r\n\t\"sink\",\r\n\t\"refrigerator\",\r\n\t\"book\",\r\n\t\"clock\",\r\n\t\"vase\",\r\n\t\"scissors\",\r\n\t\"teddy bear\",\r\n\t\"hair drier\",\r\n\t\"toothbrush\"\r\n};\r\nstatic const char *zVoc[] = {\r\n\t\"aeroplane\",\r\n\t\"bicycle\",\r\n\t\"bird\",\r\n\t\"boat\",\r\n\t\"bottle\",\r\n\t\"bus\",\r\n\t\"car\",\r\n\t\"cat\",\r\n\t\"chair\",\r\n\t\"cow\",\r\n\t\"diningtable\",\r\n\t\"dog\",\r\n\t\"horse\",\r\n\t\"motorbike\",\r\n\t\"person\",\r\n\t\"pottedplant\",\r\n\t\"sheep\",\r\n\t\"sofa\",\r\n\t\"train\",\r\n\t\"tvmonitor\"\r\n};\r\nstatic const char *zFace[] = {\r\n\t\"face\"\r\n};\r\n\r\n/*\r\n* Cross platform srtncmp\r\n*/\r\nstatic int sy_strcmp(const char *zA, const char *zB)\r\n{\r\n\tfor (;;) {\r\n\t\tint c = tolower(zA[0]);\r\n\t\tint d = tolower(zB[0]);\r\n\t\tint e = c - d;\r\n\t\tif (e != 0) return e;\r\n\t\tif (c == 0) break;\r\n\t\tzA++;\r\n\t\tzB++;\r\n\t}\r\n\treturn 0; /* Equal string */\r\n}\r\nstatic inline float stair_activate(float x)\r\n{\r\n\tint n = floor(x);\r\n\tif (n % 2 == 0) return floor(x / 2.);\r\n\telse return (x - n) + floor(x / 2.);\r\n}\r\nstatic inline float hardtan_activate(float x)\r\n{\r\n\tif (x < -1) return -1;\r\n\tif (x > 1) return 1;\r\n\treturn x;\r\n}\r\nstatic inline float linear_activate(float x) { return x; }\r\nstatic inline float logistic_activate(float x) { return 1. / (1. + exp(-x)); }\r\nstatic inline float loggy_activate(float x) { return 2. / (1. + exp(-x)) - 1; }\r\nstatic inline float relu_activate(float x) { return x * (x>0); }\r\nstatic inline float elu_activate(float x) { return (x >= 0)*x + (x < 0)*(exp(x) - 1); }\r\nstatic inline float relie_activate(float x) { return (x>0) ? x : .01*x; }\r\nstatic inline float ramp_activate(float x) { return x * (x>0) + .1*x; }\r\nstatic inline float leaky_activate(float x) { return (x>0) ? x : .1*x; }\r\nstatic inline float tanh_activate(float x) { return (exp(2 * x) - 1) / (exp(2 * x) + 1); }\r\nstatic inline float plse_activate(float x)\r\n{\r\n\tif (x < -4) return .01 * (x + 4);\r\n\tif (x > 4)  return .01 * (x - 4) + 1;\r\n\treturn .125*x + .5;\r\n}\r\nstatic inline float lhtan_activate(float x)\r\n{\r\n\tif (x < 0) return .001*x;\r\n\tif (x > 1) return .001*(x - 1) + 1;\r\n\treturn x;\r\n}\r\nstatic inline float lhtan_gradient(float x)\r\n{\r\n\tif (x > 0 && x < 1) return 1;\r\n\treturn .001;\r\n}\r\nstatic inline float hardtan_gradient(float x)\r\n{\r\n\tif (x > -1 && x < 1) return 1;\r\n\treturn 0;\r\n}\r\nstatic inline float linear_gradient() { return 1; }\r\nstatic inline float logistic_gradient(float x) { return (1 - x)*x; }\r\nstatic inline float loggy_gradient(float x)\r\n{\r\n\tfloat y = (x + 1.) / 2.;\r\n\treturn 2 * (1 - y)*y;\r\n}\r\nstatic inline float stair_gradient(float x)\r\n{\r\n\tif (floor(x) == x) return 0;\r\n\treturn 1;\r\n}\r\nstatic inline float relu_gradient(float x) { return (x>0); }\r\nstatic inline float elu_gradient(float x) { return (x >= 0) + (x < 0)*(x + 1); }\r\nstatic inline float relie_gradient(float x) { return (x>0) ? 1 : .01; }\r\nstatic inline float ramp_gradient(float x) { return (x>0) + .1; }\r\nstatic inline float leaky_gradient(float x) { return (x>0) ? 1 : .1; }\r\nstatic inline float tanh_gradient(float x) { return 1 - x * x; }\r\nstatic inline float plse_gradient(float x) { return (x < 0 || x > 1) ? .01 : .125; }\r\nstatic void reorg_cpu(float *x, int w, int h, int c, int batch, int stride, int forward, float *out)\r\n{\r\n\tint b, i, j, k;\r\n\tint out_c = c / (stride*stride);\r\n\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tfor (k = 0; k < c; ++k) {\r\n\t\t\tfor (j = 0; j < h; ++j) {\r\n\t\t\t\tfor (i = 0; i < w; ++i) {\r\n\t\t\t\t\tint in_index = i + w * (j + h * (k + c * b));\r\n\t\t\t\t\tint c2 = k % out_c;\r\n\t\t\t\t\tint offset = k / out_c;\r\n\t\t\t\t\tint w2 = i * stride + offset % stride;\r\n\t\t\t\t\tint h2 = j * stride + offset / stride;\r\n\t\t\t\t\tint out_index = w2 + w * stride*(h2 + h * stride*(c2 + out_c * b));\r\n\t\t\t\t\tif (forward) out[out_index] = x[in_index];\r\n\t\t\t\t\telse out[in_index] = x[out_index];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void flatten(float *x, int size, int layers, int batch, int forward)\r\n{\r\n\tfloat *swap = calloc(size*layers*batch, sizeof(float));\r\n\tint i, c, b;\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tfor (c = 0; c < layers; ++c) {\r\n\t\t\tfor (i = 0; i < size; ++i) {\r\n\t\t\t\tint i1 = b * layers*size + c * size + i;\r\n\t\t\t\tint i2 = b * layers*size + i * layers + c;\r\n\t\t\t\tif (forward) swap[i2] = x[i1];\r\n\t\t\t\telse swap[i1] = x[i2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmemcpy(x, swap, size*layers*batch * sizeof(float));\r\n\tfree(swap);\r\n}\r\nstatic void weighted_sum_cpu(float *a, float *b, float *s, int n, float *c)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\tc[i] = s[i] * a[i] + (1 - s[i])*(b ? b[i] : 0);\r\n\t}\r\n}\r\nstatic void col2im_add_pixel(float *im, int height, int width,\r\n\tint row, int col, int channel, int pad, float val)\r\n{\r\n\trow -= pad;\r\n\tcol -= pad;\r\n\r\n\tif (row < 0 || col < 0 ||\r\n\t\trow >= height || col >= width) return;\r\n\tim[col + width * (row + height * channel)] += val;\r\n}\r\n/* This one might be too, can't remember. */\r\nstatic inline void col2im_cpu(float* data_col,\r\n\tint channels, int height, int width,\r\n\tint ksize, int stride, int pad, float* data_im)\r\n{\r\n\tint c, h, w;\r\n\tint height_col = (height + 2 * pad - ksize) / stride + 1;\r\n\tint width_col = (width + 2 * pad - ksize) / stride + 1;\r\n\r\n\tint channels_col = channels * ksize * ksize;\r\n\tfor (c = 0; c < channels_col; ++c) {\r\n\t\tint w_offset = c % ksize;\r\n\t\tint h_offset = (c / ksize) % ksize;\r\n\t\tint c_im = c / ksize / ksize;\r\n\t\tfor (h = 0; h < height_col; ++h) {\r\n\t\t\tfor (w = 0; w < width_col; ++w) {\r\n\t\t\t\tint im_row = h_offset + h * stride;\r\n\t\t\t\tint im_col = w_offset + w * stride;\r\n\t\t\t\tint col_index = (c * height_col + h) * width_col + w;\r\n\t\t\t\tdouble val = data_col[col_index];\r\n\t\t\t\tcol2im_add_pixel(data_im, height, width,\r\n\t\t\t\t\tim_row, im_col, c_im, pad, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic inline void shortcut_cpu(int batch, int w1, int h1, int c1, float *add, int w2, int h2, int c2, float *out)\r\n{\r\n\tint stride = w1 / w2;\r\n\tint sample = w2 / w1;\r\n\r\n\tif (stride < 1) stride = 1;\r\n\tif (sample < 1) sample = 1;\r\n\tint minw = (w1 < w2) ? w1 : w2;\r\n\tint minh = (h1 < h2) ? h1 : h2;\r\n\tint minc = (c1 < c2) ? c1 : c2;\r\n\r\n\tint i, j, k, b;\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tfor (k = 0; k < minc; ++k) {\r\n\t\t\tfor (j = 0; j < minh; ++j) {\r\n\t\t\t\tfor (i = 0; i < minw; ++i) {\r\n\t\t\t\t\tint out_index = i * sample + w2 * (j*sample + h2 * (k + c2 * b));\r\n\t\t\t\t\tint add_index = i * stride + w1 * (j*stride + h1 * (k + c1 * b));\r\n\t\t\t\t\tout[out_index] += add[add_index];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic inline void mean_cpu(float *x, int batch, int filters, int spatial, float *mean)\r\n{\r\n\tfloat scale = 1. / (batch * spatial);\r\n\tint i, j, k;\r\n\tfor (i = 0; i < filters; ++i) {\r\n\t\tmean[i] = 0;\r\n\t\tfor (j = 0; j < batch; ++j) {\r\n\t\t\tfor (k = 0; k < spatial; ++k) {\r\n\t\t\t\tint index = j * filters*spatial + i * spatial + k;\r\n\t\t\t\tmean[i] += x[index];\r\n\t\t\t}\r\n\t\t}\r\n\t\tmean[i] *= scale;\r\n\t}\r\n}\r\nstatic inline void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)\r\n{\r\n\tfloat scale = 1. / (batch * spatial - 1);\r\n\tint i, j, k;\r\n\tfor (i = 0; i < filters; ++i) {\r\n\t\tvariance[i] = 0;\r\n\t\tfor (j = 0; j < batch; ++j) {\r\n\t\t\tfor (k = 0; k < spatial; ++k) {\r\n\t\t\t\tint index = j * filters*spatial + i * spatial + k;\r\n\t\t\t\tvariance[i] += pow((x[index] - mean[i]), 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvariance[i] *= scale;\r\n\t}\r\n}\r\nstatic inline void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial)\r\n{\r\n\tint b, f, i;\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tfor (f = 0; f < filters; ++f) {\r\n\t\t\tfor (i = 0; i < spatial; ++i) {\r\n\t\t\t\tint index = b * filters*spatial + f * spatial + i;\r\n\t\t\t\tx[index] = (x[index] - mean[f]) / (sqrt(variance[f]) + .000001f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic inline void const_cpu(int N, float ALPHA, float *X, int INCX)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; X[i*INCX] = ALPHA; i++; }\r\n}\r\nstatic inline void mul_cpu(int N, float *X, int INCX, float *Y, int INCY)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; Y[i*INCY] *= X[i*INCX]; i++; }\r\n}\r\nstatic inline void pow_cpu(int N, float ALPHA, float *X, int INCX, float *Y, int INCY)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; Y[i*INCY] = pow(X[i*INCX], ALPHA); i++; }\r\n}\r\nstatic inline void axpy_cpu(int N, float ALPHA, float *X, int INCX, float *Y, int INCY)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; Y[i*INCY] += ALPHA * X[i*INCX]; i++; }\r\n}\r\nstatic inline void scal_cpu(int N, float ALPHA, float *X, int INCX)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; X[i*INCX] *= ALPHA; i++; }\r\n}\r\nstatic inline void fill_cpu(int N, float ALPHA, float *X, int INCX)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; X[i*INCX] = ALPHA; i++; }\r\n}\r\nstatic inline void copy_cpu(int N, float *X, int INCX, float *Y, int INCY)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) { if (i >= N)break; Y[i*INCY] = X[i*INCX]; i++; }\r\n}\r\nstatic void smooth_l1_cpu(int n, float *pred, float *truth, float *delta, float *error)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\tfloat diff = truth[i] - pred[i];\r\n\t\tfloat abs_val = fabs(diff);\r\n\t\tif (abs_val < 1) {\r\n\t\t\terror[i] = diff * diff;\r\n\t\t\tdelta[i] = diff;\r\n\t\t}\r\n\t\telse {\r\n\t\t\terror[i] = 2 * abs_val - 1;\r\n\t\t\tdelta[i] = (diff < 0) ? -1 : 1;\r\n\t\t}\r\n\t}\r\n}\r\nstatic inline void l2_cpu(int n, float *pred, float *truth, float *delta, float *error)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) {\r\n\t\tif (i >= n)break;\r\n\t\tfloat diff = truth[i] - pred[i];\r\n\t\terror[i] = diff * diff;\r\n\t\tdelta[i] = diff;\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic void softmax(float *input, int n, float temp, float *output)\r\n{\r\n\tint i = 0;\r\n\tfloat sum = 0;\r\n\tfloat largest = -FLT_MAX;\r\n\tfor (;;) {\r\n\t\tif (i >= n)break;\r\n\t\tif (input[i] > largest) largest = input[i];\r\n\t\ti++;\r\n\t}\r\n\ti = 0;\r\n\tfor (;;) {\r\n\t\tif (i >= n)break;\r\n\t\tfloat e = exp(input[i] / temp - largest / temp);\r\n\t\tsum += e;\r\n\t\toutput[i] = e;\r\n\t\ti++;\r\n\t}\r\n\ti = 0;\r\n\tfor (;;) {\r\n\t\tif (i >= n)break;\r\n\t\toutput[i] /= sum;\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic inline float mag_array(float *a, int n)\r\n{\r\n\tint i;\r\n\tfloat sum = 0;\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\tsum += a[i] * a[i];\r\n\t}\r\n\treturn sqrt(sum);\r\n}\r\nstatic inline float sum_array(float *a, int n)\r\n{\r\n\tint i;\r\n\tfloat sum = 0;\r\n\tfor (i = 0; i < n; ++i) sum += a[i];\r\n\treturn sum;\r\n}\r\nstatic inline void scale_array(float *a, int n, float s)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\ta[i] *= s;\r\n\t}\r\n}\r\nstatic int sample_array(float *a, int n)\r\n{\r\n\tfloat sum = sum_array(a, n);\r\n\tscale_array(a, n, 1. / sum);\r\n\tfloat r = rand_uniform(0, 1);\r\n\tint i;\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\tr = r - a[i];\r\n\t\tif (r <= 0) return i;\r\n\t}\r\n\treturn n - 1;\r\n}\r\nstatic void make_network(int n, network *out)\r\n{\r\n\tnetwork net;\r\n\tmemset(&net, 0, sizeof(network));\r\n\tnet.n = n;\r\n\tnet.layers = calloc(net.n, sizeof(layer));\r\n\tnet.seen = calloc(1, sizeof(uint64_t));\r\n#if 0 /* SOD_GPU */\r\n\tnet.input_gpu = calloc(1, sizeof(float *));\r\n\tnet.truth_gpu = calloc(1, sizeof(float *));\r\n#endif\r\n\t*out = net;\r\n}\r\nstatic void free_layer(layer *l, layer *p)\r\n{\r\n\tif (l->type == DROPOUT) {\r\n\t\tif (l->rand)           free(l->rand);\r\n#if 0 /* SOD_GPU */\r\n\t\tif (l->rand_gpu)             cuda_free(l->rand_gpu);\r\n#endif\r\n\t\treturn;\r\n\t}\r\n\tif (l->cweights) {\r\n\t\tfree(l->cweights);\r\n\t}\r\n\tif (l->indexes) {\r\n\t\tfree(l->indexes);\r\n\t}\r\n\tif (l->input_layers) {\r\n\t\tfree(l->input_layers);\r\n\r\n\t}\r\n\tif (l->input_sizes) {\r\n\t\tfree(l->input_sizes);\r\n\r\n\t}\r\n\tif (l->map) {\r\n\t\tfree(l->map);\r\n\r\n\t}\r\n\tif (l->rand) {\r\n\t\tfree(l->rand);\r\n\r\n\t}\r\n\tif (l->cost) {\r\n\t\tfree(l->cost);\r\n\r\n\t}\r\n\tif (l->state) {\r\n\t\tfree(l->state);\r\n\r\n\t}\r\n\tif (l->prev_state) {\r\n\t\tfree(l->prev_state);\r\n\r\n\t}\r\n\tif (l->forgot_state) {\r\n\t\tfree(l->forgot_state);\r\n\r\n\t}\r\n\tif (l->forgot_delta) {\r\n\t\tfree(l->forgot_delta);\r\n\r\n\t}\r\n\tif (l->state_delta) {\r\n\t\tfree(l->state_delta);\r\n\r\n\t}\r\n\tif (l->concat) {\r\n\t\tfree(l->concat);\r\n\r\n\t}\r\n\tif (l->concat_delta) {\r\n\t\tfree(l->concat_delta);\r\n\r\n\t}\r\n\tif (l->binary_weights) {\r\n\t\tfree(l->binary_weights);\r\n\r\n\t}\r\n\tif (l->biases) {\r\n\t\tfree(l->biases);\r\n\r\n\t}\r\n\tif (l->bias_updates) {\r\n\t\tfree(l->bias_updates);\r\n\r\n\t}\r\n\tif (l->scales) {\r\n\t\tfree(l->scales);\r\n\r\n\t}\r\n\tif (l->scale_updates) {\r\n\t\tfree(l->scale_updates);\r\n\r\n\t}\r\n\tif (l->weights) {\r\n\t\tfree(l->weights);\r\n\r\n\t}\r\n\tif (l->weight_updates) {\r\n\t\tfree(l->weight_updates);\r\n\r\n\t}\r\n\tif (l->delta && (!p || p->delta != l->delta)) {\r\n\t\tfree(l->delta);\r\n\r\n\t}\r\n\tif (l->output && (!p || p->output != l->output)) {\r\n\t\tfree(l->output);\r\n\r\n\t}\r\n\tif (l->squared) {\r\n\t\tfree(l->squared);\r\n\r\n\t}\r\n\tif (l->norms) {\r\n\t\tfree(l->norms);\r\n\r\n\t}\r\n\tif (l->spatial_mean) {\r\n\t\tfree(l->spatial_mean);\r\n\r\n\t}\r\n\tif (l->mean) {\r\n\t\tfree(l->mean);\r\n\r\n\t}\r\n\tif (l->variance) {\r\n\t\tfree(l->variance);\r\n\r\n\t}\r\n\tif (l->mean_delta) {\r\n\t\tfree(l->mean_delta);\r\n\r\n\t}\r\n\tif (l->variance_delta) {\r\n\t\tfree(l->variance_delta);\r\n\r\n\t}\r\n\tif (l->rolling_mean) {\r\n\t\tfree(l->rolling_mean);\r\n\r\n\t}\r\n\tif (l->rolling_variance) {\r\n\t\tfree(l->rolling_variance);\r\n\r\n\t}\r\n\tif (l->x) {\r\n\t\tfree(l->x);\r\n\r\n\t}\r\n\tif (l->x_norm) {\r\n\t\tfree(l->x_norm);\r\n\r\n\t}\r\n\tif (l->m) {\r\n\t\tfree(l->m);\r\n\r\n\t}\r\n\tif (l->v) {\r\n\t\tfree(l->v);\r\n\r\n\t}\r\n\tif (l->z_cpu) {\r\n\t\tfree(l->z_cpu);\r\n\r\n\t}\r\n\tif (l->r_cpu) {\r\n\t\tfree(l->r_cpu);\r\n\r\n\t}\r\n\tif (l->h_cpu) {\r\n\t\tfree(l->h_cpu);\r\n\r\n\t}\r\n\tif (l->binary_input) {\r\n\t\tfree(l->binary_input);\r\n\r\n\t}\r\n#if 0 /* SOD_GPU */\r\n\tif (l->indexes_gpu)           cuda_free((float *)l->indexes_gpu);\r\n\r\n\tif (l->z_gpu)                   cuda_free(l->z_gpu);\r\n\tif (l->r_gpu)                   cuda_free(l->r_gpu);\r\n\tif (l->h_gpu)                   cuda_free(l->h_gpu);\r\n\tif (l->m_gpu)                   cuda_free(l->m_gpu);\r\n\tif (l->v_gpu)                   cuda_free(l->v_gpu);\r\n\tif (l->prev_state_gpu)          cuda_free(l->prev_state_gpu);\r\n\tif (l->forgot_state_gpu)        cuda_free(l->forgot_state_gpu);\r\n\tif (l->forgot_delta_gpu)        cuda_free(l->forgot_delta_gpu);\r\n\tif (l->state_gpu)               cuda_free(l->state_gpu);\r\n\tif (l->state_delta_gpu)         cuda_free(l->state_delta_gpu);\r\n\tif (l->gate_gpu)                cuda_free(l->gate_gpu);\r\n\tif (l->gate_delta_gpu)          cuda_free(l->gate_delta_gpu);\r\n\tif (l->save_gpu)                cuda_free(l->save_gpu);\r\n\tif (l->save_delta_gpu)          cuda_free(l->save_delta_gpu);\r\n\tif (l->concat_gpu)              cuda_free(l->concat_gpu);\r\n\tif (l->concat_delta_gpu)        cuda_free(l->concat_delta_gpu);\r\n\tif (l->binary_input_gpu)        cuda_free(l->binary_input_gpu);\r\n\tif (l->binary_weights_gpu)      cuda_free(l->binary_weights_gpu);\r\n\tif (l->mean_gpu)                cuda_free(l->mean_gpu);\r\n\tif (l->variance_gpu)            cuda_free(l->variance_gpu);\r\n\tif (l->rolling_mean_gpu)        cuda_free(l->rolling_mean_gpu);\r\n\tif (l->rolling_variance_gpu)    cuda_free(l->rolling_variance_gpu);\r\n\tif (l->variance_delta_gpu)      cuda_free(l->variance_delta_gpu);\r\n\tif (l->mean_delta_gpu)          cuda_free(l->mean_delta_gpu);\r\n\tif (l->x_gpu)                   cuda_free(l->x_gpu);\r\n\tif (l->x_norm_gpu)              cuda_free(l->x_norm_gpu);\r\n\tif (l->weights_gpu)             cuda_free(l->weights_gpu);\r\n\tif (l->weight_updates_gpu)      cuda_free(l->weight_updates_gpu);\r\n\tif (l->biases_gpu)              cuda_free(l->biases_gpu);\r\n\tif (l->bias_updates_gpu)        cuda_free(l->bias_updates_gpu);\r\n\tif (l->scales_gpu)              cuda_free(l->scales_gpu);\r\n\tif (l->scale_updates_gpu)       cuda_free(l->scale_updates_gpu);\r\n\tif (l->output_gpu)              cuda_free(l->output_gpu);\r\n\tif (l->delta_gpu)               cuda_free(l->delta_gpu);\r\n\tif (l->rand_gpu)                cuda_free(l->rand_gpu);\r\n\tif (l->squared_gpu)             cuda_free(l->squared_gpu);\r\n\tif (l->norms_gpu)               cuda_free(l->norms_gpu);\r\n#endif\r\n}\r\nstatic void free_network(network *net)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < net->n; ++i) {\r\n\t\tlayer *l = &net->layers[i];\r\n\t\tif (l->input_layer) {\r\n\t\t\tfree_layer(l->input_layer, l);\r\n\t\t\tfree(l->input_layer);\r\n\t\t}\r\n\t\tif (l->self_layer) {\r\n\t\t\tfree_layer(l->self_layer, l);\r\n\t\t\tfree(l->self_layer);\r\n\t\t}\r\n\t\tif (l->output_layer) {\r\n\t\t\tfree_layer(l->output_layer, l);\r\n\t\t\tfree(l->output_layer);\r\n\t\t}\r\n\t\tif (l->input_z_layer) {\r\n\t\t\tfree_layer(l->input_z_layer, l);\r\n\t\t\tfree(l->input_z_layer);\r\n\t\t}\r\n\t\tif (l->state_z_layer) {\r\n\t\t\tfree_layer(l->state_z_layer, l);\r\n\t\t\tfree(l->state_z_layer);\r\n\t\t}\r\n\t\tif (l->input_r_layer) {\r\n\t\t\tfree_layer(l->input_r_layer, l);\r\n\t\t\tfree(l->input_r_layer);\r\n\t\t}\r\n\t\tif (l->state_r_layer) {\r\n\t\t\tfree_layer(l->state_r_layer, l);\r\n\t\t\tfree(l->state_r_layer);\r\n\t\t}\r\n\t\tif (l->input_h_layer) {\r\n\t\t\tfree_layer(l->input_h_layer, l);\r\n\t\t\tfree(l->input_h_layer);\r\n\t\t}\r\n\t\tif (l->state_h_layer) {\r\n\t\t\tfree_layer(l->state_h_layer, l);\r\n\t\t\tfree(l->state_h_layer);\r\n\t\t}\r\n\t\tfree_layer(l, 0);\r\n\t}\r\n\tif (net->layers) {\r\n\t\tfree(net->layers);\r\n\t}\r\n\tif (net->seen) {\r\n\t\tfree(net->seen);\r\n\t}\r\n\tif (net->scales) {\r\n\t\tfree(net->scales);\r\n\t}\r\n\tif (net->steps) {\r\n\t\tfree(net->steps);\r\n\t}\r\n\tif (net->workspace_size) {\r\n#if 0 /* SOD_GPU */\r\n\t\tif (net.gpu_index >= 0) {\r\n\t\t\tcuda_free(net->workspace);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfree(net->workspace);\r\n\t\t}\r\n#else\r\n\t\tfree(net->workspace);\r\n#endif\r\n\t}\r\n}\r\nstatic void forward_network(network *net, network_state state)\r\n{\r\n\tint i = 0;\r\n\tlayer l;\r\n\tstate.workspace = net->workspace;\r\n\tfor (;;) {\r\n\t\tif (i >= net->n) break;\r\n\t\tl = net->layers[i];\r\n\t\tstate.index = i;\r\n\t\tif (l.delta) {\r\n\t\t\tfill_cpu(l.outputs * l.batch, 0, l.delta, 1);\r\n\t\t}\r\n\t\tl.forward(l, state);\r\n\t\tstate.input = l.output;\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic float *get_network_output(network *net)\r\n{\r\n#if 0 /* SOD_GPU */\r\n\tif (gpu_index >= 0) return get_network_output_gpu(net);\r\n#endif\r\n\tint i;\r\n\tfor (i = net->n - 1; i > 0; --i) if (net->layers[i].type != COST) break;\r\n\tnet->pNet->nOuput = net->layers[i].inputs;\r\n\treturn net->layers[i].output;\r\n}\r\nstatic int get_network_output_size(network *net)\r\n{\r\n\tint i;\r\n\tfor (i = net->n - 1; i > 0; --i) if (net->layers[i].type != COST) break;\r\n\treturn net->layers[i].outputs;\r\n}\r\nstatic int get_network_input_size(network *net)\r\n{\r\n\treturn net->layers[0].inputs;\r\n}\r\n#if 0\r\nstatic void backward_network(network *net, network_state state)\r\n{\r\n\tint i;\r\n\tfloat *original_input = state.input;\r\n\tfloat *original_delta = state.delta;\r\n\tstate.workspace = net->workspace;\r\n\tfor (i = net->n - 1; i >= 0; --i) {\r\n\t\tstate.index = i;\r\n\t\tif (i == 0) {\r\n\t\t\tstate.input = original_input;\r\n\t\t\tstate.delta = original_delta;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlayer prev = net->layers[i - 1];\r\n\t\t\tstate.input = prev.output;\r\n\t\t\tstate.delta = prev.delta;\r\n\t\t}\r\n\t\tlayer l = net->layers[i];\r\n\t\tl.backward(l, state);\r\n\t}\r\n}\r\n#endif\r\nstatic float *network_predict(network *net, float *input)\r\n{\r\n#if 0 /* SOD_GPU */\r\n\tif (gpu_index >= 0)  return network_predict_gpu(net, input);\r\n#else\r\n\tnetwork_state state;\r\n\tfloat *out;\r\n\tstate.net = net;\r\n\tstate.index = 0;\r\n\tstate.input = input;\r\n\tstate.truth = 0;\r\n\tstate.train = 0;\r\n\tstate.delta = 0;\r\n\tforward_network(net, state);\r\n\tout = get_network_output(net);\r\n\treturn out;\r\n#endif /* SOD_GPU */\r\n}\r\nstatic void set_batch_network(network *net, int b)\r\n{\r\n\tnet->batch = b;\r\n\tint i;\r\n\tfor (i = 0; i < net->n; ++i) {\r\n\t\tnet->layers[i].batch = b;\r\n#ifdef CUDNN\r\n\t\tif (net->layers[i].type == CONVOLUTIONAL) {\r\n\t\t\tcudnn_convolutional_setup(net->layers + i);\r\n\t\t}\r\n#endif\r\n\t}\r\n}\r\nstatic void transpose_matrix(float *a, int rows, int cols)\r\n{\r\n\tfloat *transpose = calloc(rows*cols, sizeof(float));\r\n\tint x, y;\r\n\tfor (x = 0; x < rows; ++x) {\r\n\t\tfor (y = 0; y < cols; ++y) {\r\n\t\t\ttranspose[y*rows + x] = a[x*cols + y];\r\n\t\t}\r\n\t}\r\n\tmemcpy(a, transpose, rows*cols * sizeof(float));\r\n\tfree(transpose);\r\n}\r\nstatic void load_convolutional_weights(layer l, FILE *fp)\r\n{\r\n\tint num = l.n*l.c*l.size*l.size;\r\n\tfread(l.biases, sizeof(float), l.n, fp);\r\n\tif (l.batch_normalize && (!l.dontloadscales)) {\r\n\t\tfread(l.scales, sizeof(float), l.n, fp);\r\n\t\tfread(l.rolling_mean, sizeof(float), l.n, fp);\r\n\t\tfread(l.rolling_variance, sizeof(float), l.n, fp);\r\n\t}\r\n\tfread(l.weights, sizeof(float), num, fp);\r\n\tif (l.adam) {\r\n\t\tfread(l.m, sizeof(float), num, fp);\r\n\t\tfread(l.v, sizeof(float), num, fp);\r\n\t}\r\n\tif (l.flipped) {\r\n\t\ttranspose_matrix(l.weights, l.c*l.size*l.size, l.n);\r\n\t}\r\n#if 0 /* SOD_GPU */\r\n\tif (gpu_index >= 0) {\r\n\t\tpush_convolutional_layer(l);\r\n\t}\r\n#endif\r\n}\r\nstatic void load_connected_weights(layer l, FILE *fp, int transpose)\r\n{\r\n\tfread(l.biases, sizeof(float), l.outputs, fp);\r\n\tfread(l.weights, sizeof(float), l.outputs*l.inputs, fp);\r\n\tif (transpose) {\r\n\t\ttranspose_matrix(l.weights, l.inputs, l.outputs);\r\n\t}\r\n\tif (l.batch_normalize && (!l.dontloadscales)) {\r\n\t\tfread(l.scales, sizeof(float), l.outputs, fp);\r\n\t\tfread(l.rolling_mean, sizeof(float), l.outputs, fp);\r\n\t\tfread(l.rolling_variance, sizeof(float), l.outputs, fp);\r\n\t}\r\n#if 0 /* SOD_GPU */\r\n\tif (gpu_index >= 0) {\r\n\t\tpush_connected_layer(l);\r\n\t}\r\n#endif\r\n}\r\nstatic void load_batchnorm_weights(layer l, FILE *fp)\r\n{\r\n\tfread(l.scales, sizeof(float), l.c, fp);\r\n\tfread(l.rolling_mean, sizeof(float), l.c, fp);\r\n\tfread(l.rolling_variance, sizeof(float), l.c, fp);\r\n#if 0 /* SOD_GPU */\r\n\tif (gpu_index >= 0) {\r\n\t\tpush_batchnorm_layer(l);\r\n\t}\r\n#endif\r\n}\r\nstatic int load_weights_upto(network *net, const char *filename, int cutoff)\r\n{\r\n\tint i, major;\r\n\tint minor;\r\n\tint revision;\r\n\tint transpose;\r\n\tFILE *fp;\r\n#if 0 /* SOD_GPU */\r\n\tif (net->gpu_index >= 0) {\r\n\t\tcuda_set_device(net->gpu_index);\r\n\t}\r\n#endif\r\n\tfp = fopen(filename, \"rb\");\r\n\tif (!fp) {\r\n\t\tnet->pNet->nErr++;\r\n\t\tnet->pNet->zErr = \"Cannot open SOD model\";\r\n\t\treturn SOD_IOERR;\r\n\t}\r\n\r\n\tfread(&major, sizeof(int), 1, fp);\r\n\tfread(&minor, sizeof(int), 1, fp);\r\n\tfread(&revision, sizeof(int), 1, fp);\r\n\tif ((major * 10 + minor) >= 2 && major < 1000 && minor < 1000) {\r\n\t\tfread(net->seen, sizeof(uint64_t), 1, fp);\r\n\t}\r\n\telse {\r\n\t\tint iseen = 0;\r\n\t\tfread(&iseen, sizeof(int), 1, fp);\r\n\t\t*net->seen = iseen;\r\n\t}\r\n\ttranspose = (major > 1000) || (minor > 1000);\r\n\tfor (i = 0; i < net->n && i < cutoff; ++i) {\r\n\t\tlayer l = net->layers[i];\r\n\t\tif (l.dontload) continue;\r\n\t\tif (l.type == CONVOLUTIONAL /*|| l.type == DECONVOLUTIONAL*/) {\r\n\t\t\tload_convolutional_weights(l, fp);\r\n\t\t}\r\n\t\tif (l.type == CONNECTED) {\r\n\t\t\tload_connected_weights(l, fp, transpose);\r\n\t\t}\r\n\t\tif (l.type == BATCHNORM) {\r\n\t\t\tload_batchnorm_weights(l, fp);\r\n\t\t}\r\n\t\tif (l.type == CRNN) {\r\n\t\t\tload_convolutional_weights(*(l.input_layer), fp);\r\n\t\t\tload_convolutional_weights(*(l.self_layer), fp);\r\n\t\t\tload_convolutional_weights(*(l.output_layer), fp);\r\n\t\t}\r\n\t\tif (l.type == RNN) {\r\n\t\t\tload_connected_weights(*(l.input_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.self_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.output_layer), fp, transpose);\r\n\t\t}\r\n\t\tif (l.type == GRU) {\r\n\t\t\tload_connected_weights(*(l.input_z_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.input_r_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.input_h_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.state_z_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.state_r_layer), fp, transpose);\r\n\t\t\tload_connected_weights(*(l.state_h_layer), fp, transpose);\r\n\t\t}\r\n\t\tif (l.type == LOCAL) {\r\n\t\t\tint locations = l.out_w*l.out_h;\r\n\t\t\tint size = l.size*l.size*l.c*l.n*locations;\r\n\t\t\tfread(l.biases, sizeof(float), l.outputs, fp);\r\n\t\t\tfread(l.weights, sizeof(float), size, fp);\r\n#if 0 /* SOD_GPU */\r\n\t\t\tif (gpu_index >= 0) {\r\n\t\t\t\tpush_local_layer(l);\r\n\t\t\t}\r\n#endif\r\n\t\t}\r\n\t}\r\n\tfclose(fp);\r\n\treturn SOD_OK;\r\n}\r\nstatic int load_weights(network *net, const char *filename)\r\n{\r\n\treturn load_weights_upto(net, filename, net->n);\r\n}\r\n/* =============== CFG Parser ====================== */\r\ntypedef struct node {\r\n\tvoid *val;\r\n\tstruct node *next;\r\n\tstruct node *prev;\r\n} node;\r\n\r\ntypedef struct list {\r\n\tint size;\r\n\tnode *front;\r\n\tnode *back;\r\n} list;\r\ntypedef struct size_params {\r\n\tint batch;\r\n\tint inputs;\r\n\tint h;\r\n\tint w;\r\n\tint c;\r\n\tint index;\r\n\tint time_steps;\r\n\tnetwork net;\r\n} size_params;\r\ntypedef struct {\r\n\tchar *type;\r\n\tlist *options;\r\n}section;\r\nstatic int is_network(section *s)\r\n{\r\n\treturn (strcmp(s->type, \"[net]\") == 0\r\n\t\t|| strcmp(s->type, \"[network]\") == 0);\r\n}\r\nstatic char *fgetl(FILE *fp)\r\n{\r\n\tif (feof(fp)) return 0;\r\n\tsize_t size = 512;\r\n\tchar *line = malloc(size * sizeof(char));\r\n\tif (!fgets(line, (int)size, fp)) {\r\n\t\tfree(line);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tsize_t curr = strlen(line);\r\n\r\n\twhile ((line[curr - 1] != '\\n') && !feof(fp)) {\r\n\t\tif (curr == size - 1) {\r\n\t\t\tsize *= 2;\r\n\t\t\tline = realloc(line, size * sizeof(char));\r\n\t\t\tif (!line) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsize_t readsize = size - curr;\r\n\t\tif (readsize > INT_MAX) readsize = INT_MAX - 1;\r\n\t\tfgets(&line[curr], (int)readsize, fp);\r\n\t\tcurr = strlen(line);\r\n\t}\r\n\tif (line[curr - 1] == '\\n') line[curr - 1] = '\\0';\r\n\r\n\treturn line;\r\n}\r\nstatic list *make_list()\r\n{\r\n\tlist *l = malloc(sizeof(list));\r\n\tl->size = 0;\r\n\tl->front = 0;\r\n\tl->back = 0;\r\n\treturn l;\r\n}\r\nstatic void list_insert(list *l, void *val)\r\n{\r\n\tnode *lnew = malloc(sizeof(node));\r\n\tlnew->val = val;\r\n\tlnew->next = 0;\r\n\r\n\tif (!l->back) {\r\n\t\tl->front = lnew;\r\n\t\tlnew->prev = 0;\r\n\t}\r\n\telse {\r\n\t\tl->back->next = lnew;\r\n\t\tlnew->prev = l->back;\r\n\t}\r\n\tl->back = lnew;\r\n\t++l->size;\r\n}\r\nstatic void free_node(node *n)\r\n{\r\n\tnode *next;\r\n\twhile (n) {\r\n\t\tnext = n->next;\r\n\t\tfree(n);\r\n\t\tn = next;\r\n\t}\r\n}\r\nstatic void free_list(list *l)\r\n{\r\n\tfree_node(l->front);\r\n\tfree(l);\r\n}\r\nstatic void strip(char *s)\r\n{\r\n\tsize_t i;\r\n\tsize_t len = strlen(s);\r\n\tsize_t offset = 0;\r\n\tfor (i = 0; i < len; ++i) {\r\n\t\tchar c = s[i];\r\n\t\tif (c == ' ' || c == '\\t' || c == '\\n') ++offset;\r\n\t\telse s[i - offset] = c;\r\n\t}\r\n\ts[len - offset] = '\\0';\r\n}\r\ntypedef struct {\r\n\tchar *key;\r\n\tchar *val;\r\n\tint used;\r\n} kvp;\r\nstatic void option_insert(list *l, char *key, char *val)\r\n{\r\n\tkvp *p = malloc(sizeof(kvp));\r\n\tp->key = key;\r\n\tp->val = val;\r\n\tp->used = 0;\r\n\tlist_insert(l, p);\r\n}\r\nstatic int read_option(char *s, list *options)\r\n{\r\n\tsize_t i;\r\n\tsize_t len = strlen(s);\r\n\tchar *val = 0;\r\n\tfor (i = 0; i < len; ++i) {\r\n\t\tif (s[i] == '=') {\r\n\t\t\ts[i] = '\\0';\r\n\t\t\tval = s + i + 1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (i == len - 1) return 0;\r\n\tchar *key = s;\r\n\toption_insert(options, key, val);\r\n\treturn 1;\r\n}\r\nstatic void free_section(section *s)\r\n{\r\n\tfree(s->type);\r\n\tnode *n = s->options->front;\r\n\twhile (n) {\r\n\t\tkvp *pair = (kvp *)n->val;\r\n\t\tfree(pair->key);\r\n\t\tfree(pair);\r\n\t\tnode *next = n->next;\r\n\t\tfree(n);\r\n\t\tn = next;\r\n\t}\r\n\tfree(s->options);\r\n\tfree(s);\r\n}\r\nstatic int next_line(const char **pzPtr, char **pzBuf)\r\n{\r\n\tconst char *zPtr = *pzPtr; /* Must be null terminated */\r\n\tconst char *zCur = zPtr;\r\n\tif (zPtr[0] == 0) {\r\n\t\treturn -1;\r\n\t}\r\n\tfor (;;) {\r\n\t\tif (zPtr[0] == '\\n' || zPtr[0] == 0) break;\r\n\t\tzPtr++;\r\n\t}\r\n\tsize_t n = (size_t)(zPtr - zCur);\r\n\tif (zPtr[0] == '\\n') zPtr++;\r\n\tchar *zBuf = malloc(n + 1);\r\n\tif (!zBuf) return -1;\r\n\tmemcpy(zBuf, zCur, n);\r\n\tzBuf[n] = 0;\r\n\t*pzBuf = zBuf;\r\n\t*pzPtr = zPtr;\r\n\treturn SOD_OK;\r\n}\r\nstatic list *read_cfg(const char *zConf)\r\n{\r\n\tchar *line;\r\n\tint nu = 0;\r\n\tlist *sections;\r\n\tsection *current = 0;\r\n\r\n\tsections = make_list();\r\n\r\n\twhile (next_line(&zConf, &line) == SOD_OK) {\r\n\t\t++nu;\r\n\t\tstrip(line);\r\n\t\tswitch (line[0]) {\r\n\t\tcase '[':\r\n\t\t\tcurrent = malloc(sizeof(section));\r\n\t\t\tlist_insert(sections, current);\r\n\t\t\tcurrent->options = make_list();\r\n\t\t\tcurrent->type = line;\r\n\t\t\tbreak;\r\n\t\tcase '\\0':\r\n\t\tcase '#':\r\n\t\tcase ';':\r\n\t\t\tfree(line);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tif (!read_option(line, current->options)) {\r\n\t\t\t\tfree(line);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn sections;\r\n}\r\nstatic char *option_find(list *l, char *key)\r\n{\r\n\tnode *n = l->front;\r\n\twhile (n) {\r\n\t\tkvp *p = (kvp *)n->val;\r\n\t\tif (strcmp(p->key, key) == 0) {\r\n\t\t\tp->used = 1;\r\n\t\t\treturn p->val;\r\n\t\t}\r\n\t\tn = n->next;\r\n\t}\r\n\treturn 0;\r\n}\r\nstatic int option_find_int(list *l, char *key, int def)\r\n{\r\n\tchar *v = option_find(l, key);\r\n\tif (v) return atoi(v);\r\n\treturn def;\r\n}\r\nstatic float option_find_float(list *l, char *key, float def)\r\n{\r\n\tchar *v = option_find(l, key);\r\n\tif (v) return atof(v);\r\n\treturn def;\r\n}\r\nstatic char *option_find_str(list *l, char *key, char *def)\r\n{\r\n\tchar *v = option_find(l, key);\r\n\tif (v) return v;\r\n\treturn def;\r\n}\r\nstatic learning_rate_policy get_policy(char *s)\r\n{\r\n\tif (strcmp(s, \"random\") == 0) return RANDOM;\r\n\tif (strcmp(s, \"poly\") == 0) return POLY;\r\n\tif (strcmp(s, \"constant\") == 0) return CONSTANT;\r\n\tif (strcmp(s, \"step\") == 0) return STEP;\r\n\tif (strcmp(s, \"exp\") == 0) return EXP;\r\n\tif (strcmp(s, \"sigmoid\") == 0) return SIG;\r\n\tif (strcmp(s, \"steps\") == 0) return STEPS;\r\n\r\n\treturn CONSTANT;\r\n}\r\nstatic SOD_CNN_LAYER_TYPE string_to_layer_type(char * type)\r\n{\r\n\tif (strcmp(type, \"[shortcut]\") == 0) return SHORTCUT;\r\n\tif (strcmp(type, \"[crop]\") == 0) return CROP;\r\n\tif (strcmp(type, \"[cost]\") == 0) return COST;\r\n\tif (strcmp(type, \"[detection]\") == 0) return DETECTION;\r\n\tif (strcmp(type, \"[region]\") == 0) return REGION;\r\n\tif (strcmp(type, \"[local]\") == 0) return LOCAL;\r\n\tif (strcmp(type, \"[conv]\") == 0\r\n\t\t|| strcmp(type, \"[convolutional]\") == 0) return CONVOLUTIONAL;\r\n\tif (strcmp(type, \"[activation]\") == 0) return ACTIVE;\r\n\tif (strcmp(type, \"[net]\") == 0\r\n\t\t|| strcmp(type, \"[network]\") == 0) return NETWORK;\r\n\tif (strcmp(type, \"[crnn]\") == 0) return CRNN;\r\n\tif (strcmp(type, \"[gru]\") == 0) return GRU;\r\n\tif (strcmp(type, \"[rnn]\") == 0) return RNN;\r\n\tif (strcmp(type, \"[conn]\") == 0\r\n\t\t|| strcmp(type, \"[connected]\") == 0) return CONNECTED;\r\n\tif (strcmp(type, \"[max]\") == 0\r\n\t\t|| strcmp(type, \"[maxpool]\") == 0) return MAXPOOL;\r\n\tif (strcmp(type, \"[reorg]\") == 0) return REORG;\r\n\tif (strcmp(type, \"[avg]\") == 0\r\n\t\t|| strcmp(type, \"[avgpool]\") == 0) return AVGPOOL;\r\n\tif (strcmp(type, \"[dropout]\") == 0) return DROPOUT;\r\n\tif (strcmp(type, \"[lrn]\") == 0\r\n\t\t|| strcmp(type, \"[normalization]\") == 0) return NORMALIZATION;\r\n\tif (strcmp(type, \"[batchnorm]\") == 0) return BATCHNORM;\r\n\tif (strcmp(type, \"[soft]\") == 0\r\n\t\t|| strcmp(type, \"[softmax]\") == 0) return SOFTMAX;\r\n\tif (strcmp(type, \"[route]\") == 0) return ROUTE;\r\n\treturn BLANK;\r\n}\r\nstatic int parse_net_options(list *options, network *net)\r\n{\r\n\tint subdivs;\r\n\tnet->batch = option_find_int(options, \"batch\", 1);\r\n\tnet->learning_rate = option_find_float(options, \"learning_rate\", .001);\r\n\tnet->momentum = option_find_float(options, \"momentum\", .9);\r\n\tnet->decay = option_find_float(options, \"decay\", .0001);\r\n\tsubdivs = option_find_int(options, \"subdivisions\", 1);\r\n\tnet->time_steps = option_find_int(options, \"time_steps\", 1);\r\n\tnet->batch /= subdivs;\r\n\tnet->batch *= net->time_steps;\r\n\tnet->subdivisions = subdivs;\r\n\r\n\tnet->adam = option_find_int(options, \"adam\", 0);\r\n\tif (net->adam) {\r\n\t\tnet->B1 = option_find_float(options, \"B1\", .9);\r\n\t\tnet->B2 = option_find_float(options, \"B2\", .999);\r\n\t\tnet->eps = option_find_float(options, \"eps\", .000001);\r\n\t}\r\n\r\n\tnet->h = option_find_int(options, \"height\", 0);\r\n\tnet->w = option_find_int(options, \"width\", 0);\r\n\tnet->c = option_find_int(options, \"channels\", 0);\r\n\tnet->inputs = option_find_int(options, \"inputs\", net->h * net->w * net->c);\r\n\tnet->max_crop = option_find_int(options, \"max_crop\", net->w * 2);\r\n\tnet->min_crop = option_find_int(options, \"min_crop\", net->w);\r\n\r\n\tnet->angle = option_find_float(options, \"angle\", 0);\r\n\tnet->aspect = option_find_float(options, \"aspect\", 1);\r\n\tnet->saturation = option_find_float(options, \"saturation\", 1);\r\n\tnet->exposure = option_find_float(options, \"exposure\", 1);\r\n\tnet->hue = option_find_float(options, \"hue\", 0);\r\n\r\n\tif (!net->inputs && !(net->h && net->w && net->c)) {\r\n\t\tnet->pNet->nErr++;\r\n\t\tnet->pNet->zErr = \"No input parameters supplied\";\r\n\t\treturn -1;\r\n\t}\r\n\tchar *policy_s = option_find_str(options, \"policy\", \"constant\");\r\n\tnet->policy = get_policy(policy_s);\r\n\tnet->burn_in = option_find_int(options, \"burn_in\", 0);\r\n\tif (net->policy == STEP) {\r\n\t\tnet->step = option_find_int(options, \"step\", 1);\r\n\t\tnet->scale = option_find_float(options, \"scale\", 1);\r\n\t}\r\n\telse if (net->policy == STEPS) {\r\n\t\tchar *l = option_find(options, \"steps\");\r\n\t\tchar *p = option_find(options, \"scales\");\r\n\t\tif (!l || !p) {\r\n\t\t\tnet->pNet->nErr++;\r\n\t\t\tnet->pNet->zErr = \"STEPS policy must have steps and scales in cfg file\";\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tint len = (int)strlen(l);\r\n\t\tint n = 1;\r\n\t\tint i;\r\n\t\tfor (i = 0; i < len; ++i) {\r\n\t\t\tif (l[i] == ',') ++n;\r\n\t\t}\r\n\t\tint *steps = calloc(n, sizeof(int));\r\n\t\tfloat *scales = calloc(n, sizeof(float));\r\n\t\tfor (i = 0; i < n; ++i) {\r\n\t\t\tint step = atoi(l);\r\n\t\t\tfloat scale = atof(p);\r\n\t\t\tl = strchr(l, ',') + 1;\r\n\t\t\tp = strchr(p, ',') + 1;\r\n\t\t\tsteps[i] = step;\r\n\t\t\tscales[i] = scale;\r\n\t\t}\r\n\t\tnet->scales = scales;\r\n\t\tnet->steps = steps;\r\n\t\tnet->num_steps = n;\r\n\t}\r\n\telse if (net->policy == EXP) {\r\n\t\tnet->gamma = option_find_float(options, \"gamma\", 1);\r\n\t}\r\n\telse if (net->policy == SIG) {\r\n\t\tnet->gamma = option_find_float(options, \"gamma\", 1);\r\n\t\tnet->step = option_find_int(options, \"step\", 1);\r\n\t}\r\n\telse if (net->policy == POLY || net->policy == RANDOM) {\r\n\t\tnet->power = option_find_float(options, \"power\", 1);\r\n\t}\r\n\tnet->max_batches = option_find_int(options, \"max_batches\", 0);\r\n\treturn 0;\r\n}\r\ntypedef layer convolutional_layer;\r\nstatic ACTIVATION get_activation(char *s)\r\n{\r\n\tif (strcmp(s, \"logistic\") == 0) return LOGISTIC;\r\n\tif (strcmp(s, \"loggy\") == 0) return LOGGY;\r\n\tif (strcmp(s, \"relu\") == 0) return RELU;\r\n\tif (strcmp(s, \"elu\") == 0) return ELU;\r\n\tif (strcmp(s, \"relie\") == 0) return RELIE;\r\n\tif (strcmp(s, \"plse\") == 0) return PLSE;\r\n\tif (strcmp(s, \"hardtan\") == 0) return HARDTAN;\r\n\tif (strcmp(s, \"lhtan\") == 0) return LHTAN;\r\n\tif (strcmp(s, \"linear\") == 0) return LINEAR;\r\n\tif (strcmp(s, \"ramp\") == 0) return RAMP;\r\n\tif (strcmp(s, \"leaky\") == 0) return LEAKY;\r\n\tif (strcmp(s, \"tanh\") == 0) return TANH;\r\n\tif (strcmp(s, \"stair\") == 0) return STAIR;\r\n\r\n\treturn RELU;\r\n}\r\n/* =============================================================== Convolution =============================================================== */\r\nstatic inline void swap_binary(convolutional_layer *l)\r\n{\r\n\tfloat *swap = l->weights;\r\n\tl->weights = l->binary_weights;\r\n\tl->binary_weights = swap;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tswap = l->weights_gpu;\r\n\tl->weights_gpu = l->binary_weights_gpu;\r\n\tl->binary_weights_gpu = swap;\r\n#endif\r\n}\r\nstatic void binarize_weights(float *weights, int n, int size, float *binary)\r\n{\r\n\tint i, f;\r\n\tfor (f = 0; f < n; ++f) {\r\n\t\tfloat mean = 0;\r\n\t\tfor (i = 0; i < size; ++i) {\r\n\t\t\tmean += fabs(weights[f*size + i]);\r\n\t\t}\r\n\t\tmean = mean / size;\r\n\t\tfor (i = 0; i < size; ++i) {\r\n\t\t\tbinary[f*size + i] = (weights[f*size + i] > 0) ? mean : -mean;\r\n\t\t}\r\n\t}\r\n}\r\nstatic inline void binarize_cpu(float *input, int n, float *binary)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) {\r\n\t\tif (i >= n)break;\r\n\t\tbinary[i] = (input[i] > 0) ? 1 : -1;\r\n\t\ti++;\r\n\t}\r\n}\r\n#define convolutional_out_height(l) ((l.h + 2 * l.pad - l.size) / l.stride + 1)\r\n#define convolutional_out_width(l) ((l.w + 2 * l.pad - l.size) / l.stride + 1)\r\nstatic inline float im2col_get_pixel(float *im, int height, int width,\r\n\tint row, int col, int channel, int pad)\r\n{\r\n\trow -= pad;\r\n\tcol -= pad;\r\n\r\n\tif (row < 0 || col < 0 ||\r\n\t\trow >= height || col >= width) return 0;\r\n\treturn im[col + width * (row + height * channel)];\r\n}\r\n/*\r\n* From Berkeley Vision's Caffe!\r\n* https://github.com/BVLC/caffe/blob/master/LICENSE\r\n*/\r\nstatic inline void im2col_cpu(float* data_im,\r\n\tint channels, int height, int width,\r\n\tint ksize, int stride, int pad, float* data_col)\r\n{\r\n\tint c, h, w;\r\n\tint height_col = (height + 2 * pad - ksize) / stride + 1;\r\n\tint width_col = (width + 2 * pad - ksize) / stride + 1;\r\n\tint channels_col = channels * ksize * ksize;\r\n\tint w_offset, h_offset, c_im, im_row, im_col, col_index;\r\n\tc = 0;\r\n\tfor (;;) {\r\n\t\tif (c >= channels_col) break;\r\n\t\tw_offset = c % ksize;\r\n\t\th_offset = (c / ksize) % ksize;\r\n\t\tc_im = c / ksize / ksize;\r\n\t\tfor (h = 0; h < height_col; ++h) {\r\n\t\t\tfor (w = 0; w < width_col; ++w) {\r\n\t\t\t\tim_row = h_offset + h * stride;\r\n\t\t\t\tim_col = w_offset + w * stride;\r\n\t\t\t\tcol_index = (c * height_col + h) * width_col + w;\r\n\t\t\t\tdata_col[col_index] = im2col_get_pixel(data_im, height, width,\r\n\t\t\t\t\tim_row, im_col, c_im, pad);\r\n\t\t\t}\r\n\t\t}\r\n\t\tc++;\r\n\t}\r\n}\r\n#ifdef SOD_EMBEDDED_COMMERCIAL_LICENSE\r\n/* \r\n * Multi-core CPU support for SOD which is available in the commercial version of the library.\r\n * You can obtain your commercial license from https://pixlab.io/downloads.\r\n *\r\n * Advantages includes:\r\n *\r\n *\tMulti-core CPU support for all platforms - Up to 3 ~ 10 times faster processing speed.\r\n *\tBuilt-in (C Code), high performance RealNets frontal face detector.\r\n *\t75 days of integration & technical assistance.\r\n *\tRoyalty-free commercial licenses without any GPL restrictions.\r\n *\tApplication source code stays private.\r\n */\r\n#include \"sod_threads.h\"\r\n#else\r\nstatic inline void gemm_nn(int M, int N, int K, float ALPHA,\r\n\tfloat *A, int lda,\r\n\tfloat *B, int ldb,\r\n\tfloat *C, int ldc)\r\n{\r\n\tregister int i, j, k;\r\n\ti = 0;\r\n\tfor (;;) {\r\n\t\tif (i >= M)break;\r\n\t\tk = 0;\r\n\t\tfor (;;) {\r\n\t\t\tregister float A_PART;\r\n\t\t\tif (k >= K)break;\r\n\t\t\tA_PART = ALPHA * A[i*lda + k];\r\n\t\t\tfor (j = 0; j < N; ++j) {\r\n\t\t\t\tC[i*ldc + j] += A_PART * B[k*ldb + j];\r\n\t\t\t}\r\n\t\t\tk++;\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n}\r\n#endif /*  SOD_EMBEDDED_COMMERCIAL_LICENSE */\r\nstatic inline void gemm_nt(int M, int N, int K, float ALPHA,\r\n\tfloat *A, int lda,\r\n\tfloat *B, int ldb,\r\n\tfloat *C, int ldc)\r\n{\r\n\tint i = 0, j, k;\r\n\r\n\tfor (;;) {\r\n\t\tif (i >= M)break;\r\n\t\tfor (j = 0; j < N; ++j) {\r\n\t\t\tregister float sum = 0;\r\n\t\t\tfor (k = 0; k < K; ++k) {\r\n\t\t\t\tsum += ALPHA * A[i*lda + k] * B[j*ldb + k];\r\n\t\t\t}\r\n\t\t\tC[i*ldc + j] += sum;\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic inline void gemm_tn(int M, int N, int K, float ALPHA,\r\n\tfloat *A, int lda,\r\n\tfloat *B, int ldb,\r\n\tfloat *C, int ldc)\r\n{\r\n\tint i = 0, j, k;\r\n\r\n\tfor (;;) {\r\n\t\tif (i >= M)break;\r\n\t\tfor (k = 0; k < K; ++k) {\r\n\t\t\tregister float A_PART = ALPHA * A[k*lda + i];\r\n\t\t\tfor (j = 0; j < N; ++j) {\r\n\t\t\t\tC[i*ldc + j] += A_PART * B[k*ldb + j];\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic inline void gemm_tt(int M, int N, int K, float ALPHA,\r\n\tfloat *A, int lda,\r\n\tfloat *B, int ldb,\r\n\tfloat *C, int ldc)\r\n{\r\n\tint i = 0, j, k;\r\n\r\n\tfor (;;) {\r\n\t\tif (i >= M)break;\r\n\t\tfor (j = 0; j < N; ++j) {\r\n\t\t\tregister float sum = 0;\r\n\t\t\tfor (k = 0; k < K; ++k) {\r\n\t\t\t\tsum += ALPHA * A[i + k * lda] * B[k + j * ldb];\r\n\t\t\t}\r\n\t\t\tC[i*ldc + j] += sum;\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic inline void gemm_cpu(int TA, int TB, int M, int N, int K, float ALPHA,\r\n\tfloat *A, int lda,\r\n\tfloat *B, int ldb,\r\n\tfloat BETA,\r\n\tfloat *C, int ldc)\r\n{\r\n\tint i = 0, j;\r\n\r\n\tfor (;;) {\r\n\t\tif (i >= M)break;\r\n\t\tj = 0;\r\n\t\tfor (;;) {\r\n\t\t\tif (j >= N) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tC[i*ldc + j] *= BETA; j++;\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n\tif (!TA && !TB) {\r\n\t\tgemm_nn(M, N, K, ALPHA, A, lda, B, ldb, C, ldc);\r\n\t}\r\n\telse if (TA && !TB) {\r\n\t\tgemm_tn(M, N, K, ALPHA, A, lda, B, ldb, C, ldc);\r\n\t}\r\n\telse if (!TA && TB) {\r\n\t\tgemm_nt(M, N, K, ALPHA, A, lda, B, ldb, C, ldc);\r\n\t}\r\n\telse {\r\n\t\tgemm_tt(M, N, K, ALPHA, A, lda, B, ldb, C, ldc);\r\n\t}\r\n}\r\nstatic inline void gemm(int TA, int TB, int M, int N, int K, float ALPHA,\r\n\tfloat *A, int lda,\r\n\tfloat *B, int ldb,\r\n\tfloat BETA,\r\n\tfloat *C, int ldc)\r\n{\r\n\tgemm_cpu(TA, TB, M, N, K, ALPHA, A, lda, B, ldb, BETA, C, ldc);\r\n}\r\nstatic void scale_bias(float *output, float *scales, int batch, int n, int size)\r\n{\r\n\tint i, j, b;\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tfor (i = 0; i < n; ++i) {\r\n\t\t\tfor (j = 0; j < size; ++j) {\r\n\t\t\t\toutput[(b*n + i)*size + j] *= scales[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void forward_batchnorm_layer(layer l, network_state state)\r\n{\r\n\tif (l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, state.input, 1, l.output, 1);\r\n\tif (l.type == CONNECTED) {\r\n\t\tl.out_c = l.outputs;\r\n\t\tl.out_h = l.out_w = 1;\r\n\t}\r\n\tif (state.train) {\r\n\t\tmean_cpu(l.output, l.batch, l.out_c, l.out_h*l.out_w, l.mean);\r\n\t\tvariance_cpu(l.output, l.mean, l.batch, l.out_c, l.out_h*l.out_w, l.variance);\r\n\r\n\t\tscal_cpu(l.out_c, .9, l.rolling_mean, 1);\r\n\t\taxpy_cpu(l.out_c, .1, l.mean, 1, l.rolling_mean, 1);\r\n\t\tscal_cpu(l.out_c, .9, l.rolling_variance, 1);\r\n\t\taxpy_cpu(l.out_c, .1, l.variance, 1, l.rolling_variance, 1);\r\n\r\n\t\tcopy_cpu(l.outputs*l.batch, l.output, 1, l.x, 1);\r\n\t\tnormalize_cpu(l.output, l.mean, l.variance, l.batch, l.out_c, l.out_h*l.out_w);\r\n\t\tcopy_cpu(l.outputs*l.batch, l.output, 1, l.x_norm, 1);\r\n\t}\r\n\telse {\r\n\t\tnormalize_cpu(l.output, l.rolling_mean, l.rolling_variance, l.batch, l.out_c, l.out_h*l.out_w);\r\n\t}\r\n\tscale_bias(l.output, l.scales, l.batch, l.out_c, l.out_h*l.out_w);\r\n}\r\nstatic inline float activate(float x, ACTIVATION a)\r\n{\r\n\tswitch (a) {\r\n\tcase LINEAR:\r\n\t\treturn linear_activate(x);\r\n\tcase LOGISTIC:\r\n\t\treturn logistic_activate(x);\r\n\tcase LOGGY:\r\n\t\treturn loggy_activate(x);\r\n\tcase RELU:\r\n\t\treturn relu_activate(x);\r\n\tcase ELU:\r\n\t\treturn elu_activate(x);\r\n\tcase RELIE:\r\n\t\treturn relie_activate(x);\r\n\tcase RAMP:\r\n\t\treturn ramp_activate(x);\r\n\tcase LEAKY:\r\n\t\treturn leaky_activate(x);\r\n\tcase TANH:\r\n\t\treturn tanh_activate(x);\r\n\tcase PLSE:\r\n\t\treturn plse_activate(x);\r\n\tcase STAIR:\r\n\t\treturn stair_activate(x);\r\n\tcase HARDTAN:\r\n\t\treturn hardtan_activate(x);\r\n\tcase LHTAN:\r\n\t\treturn lhtan_activate(x);\r\n\t}\r\n\treturn 0;\r\n}\r\nstatic inline void activate_array(float *x, const int n, const ACTIVATION a)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\tx[i] = activate(x[i], a);\r\n\t}\r\n}\r\nstatic float gradient(float x, ACTIVATION a)\r\n{\r\n\tswitch (a) {\r\n\tcase LINEAR:\r\n\t\treturn linear_gradient();\r\n\tcase LOGISTIC:\r\n\t\treturn logistic_gradient(x);\r\n\tcase LOGGY:\r\n\t\treturn loggy_gradient(x);\r\n\tcase RELU:\r\n\t\treturn relu_gradient(x);\r\n\tcase ELU:\r\n\t\treturn elu_gradient(x);\r\n\tcase RELIE:\r\n\t\treturn relie_gradient(x);\r\n\tcase RAMP:\r\n\t\treturn ramp_gradient(x);\r\n\tcase LEAKY:\r\n\t\treturn leaky_gradient(x);\r\n\tcase TANH:\r\n\t\treturn tanh_gradient(x);\r\n\tcase PLSE:\r\n\t\treturn plse_gradient(x);\r\n\tcase STAIR:\r\n\t\treturn stair_gradient(x);\r\n\tcase HARDTAN:\r\n\t\treturn hardtan_gradient(x);\r\n\tcase LHTAN:\r\n\t\treturn lhtan_gradient(x);\r\n\t}\r\n\treturn 0;\r\n}\r\nstatic inline void gradient_array(const float *x, const int n, const ACTIVATION a, float *delta)\r\n{\r\n\tint i = 0;\r\n\tfor (;;) {\r\n\t\tif (i >= n)break;\r\n\t\tdelta[i] *= gradient(x[i], a);\r\n\t\ti++;\r\n\t}\r\n}\r\nstatic void forward_convolutional_layer(convolutional_layer l, network_state state)\r\n{\r\n\tint out_h = convolutional_out_height(l);\r\n\tint out_w = convolutional_out_width(l);\r\n\tint i, bx, j;\r\n\tint m, k, n;\r\n\tfloat *a, *b, *c;\r\n\r\n\tfill_cpu(l.outputs*l.batch, 0, l.output, 1);\r\n\r\n\tif (l.xnor) {\r\n\t\tbinarize_weights(l.weights, l.n, l.c*l.size*l.size, l.binary_weights);\r\n\t\tswap_binary(&l);\r\n\t\tbinarize_cpu(state.input, l.c*l.h*l.w*l.batch, l.binary_input);\r\n\t\tstate.input = l.binary_input;\r\n\t}\r\n\r\n\tm = l.n;\r\n\tk = l.size*l.size*l.c;\r\n\tn = out_h * out_w;\r\n\r\n\r\n\ta = l.weights;\r\n\tb = state.workspace;\r\n\tc = l.output;\r\n\r\n\ti = 0;\r\n\r\n\tfor (;;) {\r\n\t\tif (i >= l.batch)break;\r\n\r\n\t\tim2col_cpu(state.input, l.c, l.h, l.w,\r\n\t\t\tl.size, l.stride, l.pad, b);\r\n\t\tgemm(0, 0, m, n, k, 1, a, k, b, n, 1, c, n);\r\n\t\tc += n * m;\r\n\t\tstate.input += l.c*l.h*l.w;\r\n\r\n\t\ti++;\r\n\t}\r\n\r\n\tif (l.batch_normalize) {\r\n\t\tforward_batchnorm_layer(l, state);\r\n\t}\r\n\r\n\tbx = 0;\r\n\r\n\tfor (;;) {\r\n\t\tif (bx >= l.batch) break;\r\n\t\tfor (i = 0; i < l.n; ++i) {\r\n\t\t\tfor (j = 0; j < n; ++j) {\r\n\t\t\t\tl.output[(bx*n + i)*n + j] += l.biases[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tbx++;\r\n\t}\r\n\ti = 0;\r\n\t/* \tactivate_array(l.output, m*n*l.batch, l.activation); */\r\n\r\n\tfor (;;) {\r\n\t\tif (i >= m * n*l.batch)break;\r\n\t\tl.output[i] = activate(l.output[i], l.activation);\r\n\t\ti++;\r\n\t}\r\n\tif (l.binary || l.xnor) swap_binary(&l);\r\n}\r\nstatic void backward_bias(float *bias_updates, float *delta, int batch, int n, int size)\r\n{\r\n\tint i, b;\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tfor (i = 0; i < n; ++i) {\r\n\t\t\tbias_updates[i] += sum_array(delta + size * (i + b * n), size);\r\n\t\t}\r\n\t}\r\n}\r\nstatic void backward_scale_cpu(float *x_norm, float *delta, int batch, int n, int size, float *scale_updates)\r\n{\r\n\tint i, b, f;\r\n\tfor (f = 0; f < n; ++f) {\r\n\t\tfloat sum = 0;\r\n\t\tfor (b = 0; b < batch; ++b) {\r\n\t\t\tfor (i = 0; i < size; ++i) {\r\n\t\t\t\tint index = i + size * (f + n * b);\r\n\t\t\t\tsum += delta[index] * x_norm[index];\r\n\t\t\t}\r\n\t\t}\r\n\t\tscale_updates[f] += sum;\r\n\t}\r\n}\r\nstatic void mean_delta_cpu(float *delta, float *variance, int batch, int filters, int spatial, float *mean_delta)\r\n{\r\n\r\n\tint i, j, k;\r\n\tfor (i = 0; i < filters; ++i) {\r\n\t\tmean_delta[i] = 0;\r\n\t\tfor (j = 0; j < batch; ++j) {\r\n\t\t\tfor (k = 0; k < spatial; ++k) {\r\n\t\t\t\tint index = j * filters*spatial + i * spatial + k;\r\n\t\t\t\tmean_delta[i] += delta[index];\r\n\t\t\t}\r\n\t\t}\r\n\t\tmean_delta[i] *= (-1. / sqrt(variance[i] + .00001f));\r\n\t}\r\n}\r\nstatic void  variance_delta_cpu(float *x, float *delta, float *mean, float *variance, int batch, int filters, int spatial, float *variance_delta)\r\n{\r\n\r\n\tint i, j, k;\r\n\tfor (i = 0; i < filters; ++i) {\r\n\t\tvariance_delta[i] = 0;\r\n\t\tfor (j = 0; j < batch; ++j) {\r\n\t\t\tfor (k = 0; k < spatial; ++k) {\r\n\t\t\t\tint index = j * filters*spatial + i * spatial + k;\r\n\t\t\t\tvariance_delta[i] += delta[index] * (x[index] - mean[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvariance_delta[i] *= -.5 * pow(variance[i] + .00001f, (float)(-3. / 2.));\r\n\t}\r\n}\r\nstatic void normalize_delta_cpu(float *x, float *mean, float *variance, float *mean_delta, float *variance_delta, int batch, int filters, int spatial, float *delta)\r\n{\r\n\tint f, j, k;\r\n\tfor (j = 0; j < batch; ++j) {\r\n\t\tfor (f = 0; f < filters; ++f) {\r\n\t\t\tfor (k = 0; k < spatial; ++k) {\r\n\t\t\t\tint index = j * filters*spatial + f * spatial + k;\r\n\t\t\t\tdelta[index] = delta[index] * 1. / (sqrt(variance[f]) + .00001f) + variance_delta[f] * 2. * (x[index] - mean[f]) / (spatial * batch) + mean_delta[f] / (spatial*batch);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void backward_batchnorm_layer(const layer l, network_state state)\r\n{\r\n\tbackward_scale_cpu(l.x_norm, l.delta, l.batch, l.out_c, l.out_w*l.out_h, l.scale_updates);\r\n\r\n\tscale_bias(l.delta, l.scales, l.batch, l.out_c, l.out_h*l.out_w);\r\n\r\n\tmean_delta_cpu(l.delta, l.variance, l.batch, l.out_c, l.out_w*l.out_h, l.mean_delta);\r\n\tvariance_delta_cpu(l.x, l.delta, l.mean, l.variance, l.batch, l.out_c, l.out_w*l.out_h, l.variance_delta);\r\n\tnormalize_delta_cpu(l.x, l.mean, l.variance, l.mean_delta, l.variance_delta, l.batch, l.out_c, l.out_w*l.out_h, l.delta);\r\n\tif (l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, l.delta, 1, state.delta, 1);\r\n}\r\nstatic void backward_convolutional_layer(convolutional_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tint m = l.n;\r\n\tint n = l.size*l.size*l.c;\r\n\tint k = convolutional_out_height(l)*\r\n\t\tconvolutional_out_width(l);\r\n\r\n\tgradient_array(l.output, m*k*l.batch, l.activation, l.delta);\r\n\tbackward_bias(l.bias_updates, l.delta, l.batch, l.n, k);\r\n\r\n\tif (l.batch_normalize) {\r\n\t\tbackward_batchnorm_layer(l, state);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tfloat *a = l.delta + i * m*k;\r\n\t\tfloat *b = state.workspace;\r\n\t\tfloat *c = l.weight_updates;\r\n\r\n\t\tfloat *im = state.input + i * l.c*l.h*l.w;\r\n\r\n\t\tim2col_cpu(im, l.c, l.h, l.w,\r\n\t\t\tl.size, l.stride, l.pad, b);\r\n\t\tgemm(0, 1, m, n, k, 1, a, k, b, k, 1, c, n);\r\n\r\n\t\tif (state.delta) {\r\n\t\t\ta = l.weights;\r\n\t\t\tb = l.delta + i * m*k;\r\n\t\t\tc = state.workspace;\r\n\r\n\t\t\tgemm(1, 0, n, k, m, 1, a, n, b, k, 0, c, k);\r\n\r\n\t\t\tcol2im_cpu(state.workspace, l.c, l.h, l.w, l.size, l.stride, l.pad, state.delta + i * l.c*l.h*l.w);\r\n\t\t}\r\n\t}\r\n}\r\nstatic void update_convolutional_layer(convolutional_layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tint size = l.size*l.size*l.c*l.n;\r\n\taxpy_cpu(l.n, learning_rate / batch, l.bias_updates, 1, l.biases, 1);\r\n\tscal_cpu(l.n, momentum, l.bias_updates, 1);\r\n\r\n\tif (l.scales) {\r\n\t\taxpy_cpu(l.n, learning_rate / batch, l.scale_updates, 1, l.scales, 1);\r\n\t\tscal_cpu(l.n, momentum, l.scale_updates, 1);\r\n\t}\r\n\r\n\taxpy_cpu(size, -decay * batch, l.weights, 1, l.weight_updates, 1);\r\n\taxpy_cpu(size, learning_rate / batch, l.weight_updates, 1, l.weights, 1);\r\n\tscal_cpu(size, momentum, l.weight_updates, 1);\r\n}\r\nstatic size_t get_workspace_size(layer l) {\r\n\treturn (size_t)l.out_h*l.out_w*l.size*l.size*l.c * sizeof(float);\r\n}\r\nstatic convolutional_layer make_convolutional_layer(int batch, int h, int w, int c, int n, int size, int stride, int padding, ACTIVATION activation, int batch_normalize, int binary, int xnor, int adam)\r\n{\r\n\tint i;\r\n\tconvolutional_layer l = { 0 };\r\n\tl.type = CONVOLUTIONAL;\r\n\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tl.n = n;\r\n\tl.binary = binary;\r\n\tl.xnor = xnor;\r\n\tl.batch = batch;\r\n\tl.stride = stride;\r\n\tl.size = size;\r\n\tl.pad = padding;\r\n\tl.batch_normalize = batch_normalize;\r\n\r\n\tl.weights = calloc(c*n*size*size, sizeof(float));\r\n\tl.weight_updates = calloc(c*n*size*size, sizeof(float));\r\n\r\n\tl.biases = calloc(n, sizeof(float));\r\n\tl.bias_updates = calloc(n, sizeof(float));\r\n\r\n\t/* float scale = 1./sqrt(size*size*c); */\r\n\tfloat scale = sqrt(2. / (size*size*c));\r\n\tfor (i = 0; i < c*n*size*size; ++i) l.weights[i] = scale * rand_uniform(-1, 1);\r\n\tint out_h = convolutional_out_height(l);\r\n\tint out_w = convolutional_out_width(l);\r\n\tl.out_h = out_h;\r\n\tl.out_w = out_w;\r\n\tl.out_c = n;\r\n\tl.outputs = l.out_h * l.out_w * l.out_c;\r\n\tl.inputs = l.w * l.h * l.c;\r\n\r\n\tl.output = calloc(l.batch*l.outputs, sizeof(float));\r\n\tl.delta = calloc(l.batch*l.outputs, sizeof(float));\r\n\r\n\tl.forward = forward_convolutional_layer;\r\n\tl.backward = backward_convolutional_layer;\r\n\tl.update = update_convolutional_layer;\r\n\tif (binary) {\r\n\t\tl.binary_weights = calloc(c*n*size*size, sizeof(float));\r\n\t\tl.cweights = calloc(c*n*size*size, sizeof(char));\r\n\t\tl.scales = calloc(n, sizeof(float));\r\n\t}\r\n\tif (xnor) {\r\n\t\tl.binary_weights = calloc(c*n*size*size, sizeof(float));\r\n\t\tl.binary_input = calloc(l.inputs*l.batch, sizeof(float));\r\n\t}\r\n\r\n\tif (batch_normalize) {\r\n\t\tl.scales = calloc(n, sizeof(float));\r\n\t\tl.scale_updates = calloc(n, sizeof(float));\r\n\t\tfor (i = 0; i < n; ++i) {\r\n\t\t\tl.scales[i] = 1;\r\n\t\t}\r\n\r\n\t\tl.mean = calloc(n, sizeof(float));\r\n\t\tl.variance = calloc(n, sizeof(float));\r\n\r\n\t\tl.mean_delta = calloc(n, sizeof(float));\r\n\t\tl.variance_delta = calloc(n, sizeof(float));\r\n\r\n\t\tl.rolling_mean = calloc(n, sizeof(float));\r\n\t\tl.rolling_variance = calloc(n, sizeof(float));\r\n\t\tl.x = calloc(l.batch*l.outputs, sizeof(float));\r\n\t\tl.x_norm = calloc(l.batch*l.outputs, sizeof(float));\r\n\t}\r\n\tif (adam) {\r\n\t\tl.adam = 1;\r\n\t\tl.m = calloc(c*n*size*size, sizeof(float));\r\n\t\tl.v = calloc(c*n*size*size, sizeof(float));\r\n\t}\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_convolutional_layer_gpu;\r\n\tl.backward_gpu = backward_convolutional_layer_gpu;\r\n\tl.update_gpu = update_convolutional_layer_gpu;\r\n\r\n\tif (gpu_index >= 0) {\r\n\t\tif (adam) {\r\n\t\t\tl.m_gpu = cuda_make_array(l.m, c*n*size*size);\r\n\t\t\tl.v_gpu = cuda_make_array(l.v, c*n*size*size);\r\n\t\t}\r\n\r\n\t\tl.weights_gpu = cuda_make_array(l.weights, c*n*size*size);\r\n\t\tl.weight_updates_gpu = cuda_make_array(l.weight_updates, c*n*size*size);\r\n\r\n\t\tl.biases_gpu = cuda_make_array(l.biases, n);\r\n\t\tl.bias_updates_gpu = cuda_make_array(l.bias_updates, n);\r\n\r\n\t\tl.delta_gpu = cuda_make_array(l.delta, l.batch*out_h*out_w*n);\r\n\t\tl.output_gpu = cuda_make_array(l.output, l.batch*out_h*out_w*n);\r\n\r\n\t\tif (binary) {\r\n\t\t\tl.binary_weights_gpu = cuda_make_array(l.weights, c*n*size*size);\r\n\t\t}\r\n\t\tif (xnor) {\r\n\t\t\tl.binary_weights_gpu = cuda_make_array(l.weights, c*n*size*size);\r\n\t\t\tl.binary_input_gpu = cuda_make_array(0, l.inputs*l.batch);\r\n\t\t}\r\n\r\n\t\tif (batch_normalize) {\r\n\t\t\tl.mean_gpu = cuda_make_array(l.mean, n);\r\n\t\t\tl.variance_gpu = cuda_make_array(l.variance, n);\r\n\r\n\t\t\tl.rolling_mean_gpu = cuda_make_array(l.mean, n);\r\n\t\t\tl.rolling_variance_gpu = cuda_make_array(l.variance, n);\r\n\r\n\t\t\tl.mean_delta_gpu = cuda_make_array(l.mean, n);\r\n\t\t\tl.variance_delta_gpu = cuda_make_array(l.variance, n);\r\n\r\n\t\t\tl.scales_gpu = cuda_make_array(l.scales, n);\r\n\t\t\tl.scale_updates_gpu = cuda_make_array(l.scale_updates, n);\r\n\r\n\t\t\tl.x_gpu = cuda_make_array(l.output, l.batch*out_h*out_w*n);\r\n\t\t\tl.x_norm_gpu = cuda_make_array(l.output, l.batch*out_h*out_w*n);\r\n\t\t}\r\n#ifdef CUDNN\r\n\t\tcudnnCreateTensorDescriptor(&l.srcTensorDesc);\r\n\t\tcudnnCreateTensorDescriptor(&l.dstTensorDesc);\r\n\t\tcudnnCreateFilterDescriptor(&l.weightDesc);\r\n\t\tcudnnCreateTensorDescriptor(&l.dsrcTensorDesc);\r\n\t\tcudnnCreateTensorDescriptor(&l.ddstTensorDesc);\r\n\t\tcudnnCreateFilterDescriptor(&l.dweightDesc);\r\n\t\tcudnnCreateConvolutionDescriptor(&l.convDesc);\r\n\t\tcudnn_convolutional_setup(&l);\r\n#endif\r\n\t}\r\n#endif\r\n\tl.workspace_size = get_workspace_size(l);\r\n\tl.activation = activation;\r\n\treturn l;\r\n}\r\nstatic int parse_convolutional(convolutional_layer *l, list *options, size_params params, sod_cnn *pNet)\r\n{\r\n\tint n = option_find_int(options, \"filters\", 1);\r\n\tint size = option_find_int(options, \"size\", 1);\r\n\tint stride = option_find_int(options, \"stride\", 1);\r\n\tint pad = option_find_int(options, \"pad\", 0);\r\n\tint padding = option_find_int(options, \"padding\", 0);\r\n\tif (pad) padding = size / 2;\r\n\r\n\tchar *activation_s = option_find_str(options, \"activation\", \"logistic\");\r\n\tACTIVATION activation = get_activation(activation_s);\r\n\r\n\tint batch, h, w, c;\r\n\th = params.h;\r\n\tw = params.w;\r\n\tc = params.c;\r\n\tbatch = params.batch;\r\n\tif (!(h && w && c)) {\r\n\t\tpNet->zErr = \"before convolutional, layer must output an image.\";\r\n\t\tpNet->nErr++;\r\n\t\treturn -1;\r\n\t}\r\n\tint batch_normalize = option_find_int(options, \"batch_normalize\", 0);\r\n\tint binary = option_find_int(options, \"binary\", 0);\r\n\tint xnor = option_find_int(options, \"xnor\", 0);\r\n\r\n\t*l = make_convolutional_layer(batch, h, w, c, n, size, stride, padding, activation, batch_normalize, binary, xnor, params.net.adam);\r\n\tl->flipped = option_find_int(options, \"flipped\", 0);\r\n\tl->dot = option_find_float(options, \"dot\", 0);\r\n\tif (params.net.adam) {\r\n\t\tl->B1 = params.net.B1;\r\n\t\tl->B2 = params.net.B2;\r\n\t\tl->eps = params.net.eps;\r\n\t}\r\n\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== LOCAL =============================================================== */\r\ntypedef layer local_layer;\r\n\r\nstatic int local_out_height(local_layer l)\r\n{\r\n\tint h = l.h;\r\n\tif (!l.pad) h -= l.size;\r\n\telse h -= 1;\r\n\treturn h / l.stride + 1;\r\n}\r\nstatic int local_out_width(local_layer l)\r\n{\r\n\tint w = l.w;\r\n\tif (!l.pad) w -= l.size;\r\n\telse w -= 1;\r\n\treturn w / l.stride + 1;\r\n}\r\nstatic void forward_local_layer(const local_layer l, network_state state)\r\n{\r\n\tint out_h = local_out_height(l);\r\n\tint out_w = local_out_width(l);\r\n\tint i, j;\r\n\tint locations = out_h * out_w;\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tcopy_cpu(l.outputs, l.biases, 1, l.output + i * l.outputs, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tfloat *input = state.input + i * l.w*l.h*l.c;\r\n\t\tim2col_cpu(input, l.c, l.h, l.w,\r\n\t\t\tl.size, l.stride, l.pad, l.col_image);\r\n\t\tfloat *output = l.output + i * l.outputs;\r\n\t\tfor (j = 0; j < locations; ++j) {\r\n\t\t\tfloat *a = l.weights + j * l.size*l.size*l.c*l.n;\r\n\t\t\tfloat *b = l.col_image + j;\r\n\t\t\tfloat *c = output + j;\r\n\r\n\t\t\tint m = l.n;\r\n\t\t\tint n = 1;\r\n\t\t\tint k = l.size*l.size*l.c;\r\n\r\n\t\t\tgemm(0, 0, m, n, k, 1, a, k, b, locations, 1, c, locations);\r\n\t\t}\r\n\t}\r\n\tactivate_array(l.output, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_local_layer(local_layer l, network_state state)\r\n{\r\n\tint i, j;\r\n\tint locations = l.out_w*l.out_h;\r\n\r\n\tgradient_array(l.output, l.outputs*l.batch, l.activation, l.delta);\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\taxpy_cpu(l.outputs, 1, l.delta + i * l.outputs, 1, l.bias_updates, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tfloat *input = state.input + i * l.w*l.h*l.c;\r\n\t\tim2col_cpu(input, l.c, l.h, l.w,\r\n\t\t\tl.size, l.stride, l.pad, l.col_image);\r\n\r\n\t\tfor (j = 0; j < locations; ++j) {\r\n\t\t\tfloat *a = l.delta + i * l.outputs + j;\r\n\t\t\tfloat *b = l.col_image + j;\r\n\t\t\tfloat *c = l.weight_updates + j * l.size*l.size*l.c*l.n;\r\n\t\t\tint m = l.n;\r\n\t\t\tint n = l.size*l.size*l.c;\r\n\t\t\tint k = 1;\r\n\r\n\t\t\tgemm(0, 1, m, n, k, 1, a, locations, b, locations, 1, c, n);\r\n\t\t}\r\n\r\n\t\tif (state.delta) {\r\n\t\t\tfor (j = 0; j < locations; ++j) {\r\n\t\t\t\tfloat *a = l.weights + j * l.size*l.size*l.c*l.n;\r\n\t\t\t\tfloat *b = l.delta + i * l.outputs + j;\r\n\t\t\t\tfloat *c = l.col_image + j;\r\n\r\n\t\t\t\tint m = l.size*l.size*l.c;\r\n\t\t\t\tint n = 1;\r\n\t\t\t\tint k = l.n;\r\n\r\n\t\t\t\tgemm(1, 0, m, n, k, 1, a, m, b, locations, 0, c, locations);\r\n\t\t\t}\r\n\r\n\t\t\tcol2im_cpu(l.col_image, l.c, l.h, l.w, l.size, l.stride, l.pad, state.delta + i * l.c*l.h*l.w);\r\n\t\t}\r\n\t}\r\n}\r\nstatic void update_local_layer(local_layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tint locations = l.out_w*l.out_h;\r\n\tint size = l.size*l.size*l.c*l.n*locations;\r\n\taxpy_cpu(l.outputs, learning_rate / batch, l.bias_updates, 1, l.biases, 1);\r\n\tscal_cpu(l.outputs, momentum, l.bias_updates, 1);\r\n\r\n\taxpy_cpu(size, -decay * batch, l.weights, 1, l.weight_updates, 1);\r\n\taxpy_cpu(size, learning_rate / batch, l.weight_updates, 1, l.weights, 1);\r\n\tscal_cpu(size, momentum, l.weight_updates, 1);\r\n}\r\n#if 0 /* SOD_GPU */\r\nstatic void forward_local_layer_gpu(const local_layer l, network_state state)\r\n{\r\n\tint out_h = local_out_height(l);\r\n\tint out_w = local_out_width(l);\r\n\tint i, j;\r\n\tint locations = out_h * out_w;\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tcopy_ongpu(l.outputs, l.biases_gpu, 1, l.output_gpu + i * l.outputs, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tfloat *input = state.input + i * l.w*l.h*l.c;\r\n\t\tim2col_ongpu(input, l.c, l.h, l.w,\r\n\t\t\tl.size, l.stride, l.pad, l.col_image_gpu);\r\n\t\tfloat *output = l.output_gpu + i * l.outputs;\r\n\t\tfor (j = 0; j < locations; ++j) {\r\n\t\t\tfloat *a = l.weights_gpu + j * l.size*l.size*l.c*l.n;\r\n\t\t\tfloat *b = l.col_image_gpu + j;\r\n\t\t\tfloat *c = output + j;\r\n\r\n\t\t\tint m = l.n;\r\n\t\t\tint n = 1;\r\n\t\t\tint k = l.size*l.size*l.c;\r\n\r\n\t\t\tgemm_ongpu(0, 0, m, n, k, 1, a, k, b, locations, 1, c, locations);\r\n\t\t}\r\n\t}\r\n\tactivate_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_local_layer_gpu(local_layer l, network_state state)\r\n{\r\n\tint i, j;\r\n\tint locations = l.out_w*l.out_h;\r\n\r\n\tgradient_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation, l.delta_gpu);\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\taxpy_ongpu(l.outputs, 1, l.delta_gpu + i * l.outputs, 1, l.bias_updates_gpu, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\tfloat *input = state.input + i * l.w*l.h*l.c;\r\n\t\tim2col_ongpu(input, l.c, l.h, l.w,\r\n\t\t\tl.size, l.stride, l.pad, l.col_image_gpu);\r\n\r\n\t\tfor (j = 0; j < locations; ++j) {\r\n\t\t\tfloat *a = l.delta_gpu + i * l.outputs + j;\r\n\t\t\tfloat *b = l.col_image_gpu + j;\r\n\t\t\tfloat *c = l.weight_updates_gpu + j * l.size*l.size*l.c*l.n;\r\n\t\t\tint m = l.n;\r\n\t\t\tint n = l.size*l.size*l.c;\r\n\t\t\tint k = 1;\r\n\r\n\t\t\tgemm_ongpu(0, 1, m, n, k, 1, a, locations, b, locations, 1, c, n);\r\n\t\t}\r\n\r\n\t\tif (state.delta) {\r\n\t\t\tfor (j = 0; j < locations; ++j) {\r\n\t\t\t\tfloat *a = l.weights_gpu + j * l.size*l.size*l.c*l.n;\r\n\t\t\t\tfloat *b = l.delta_gpu + i * l.outputs + j;\r\n\t\t\t\tfloat *c = l.col_image_gpu + j;\r\n\r\n\t\t\t\tint m = l.size*l.size*l.c;\r\n\t\t\t\tint n = 1;\r\n\t\t\t\tint k = l.n;\r\n\r\n\t\t\t\tgemm_ongpu(1, 0, m, n, k, 1, a, m, b, locations, 0, c, locations);\r\n\t\t\t}\r\n\r\n\t\t\tcol2im_ongpu(l.col_image_gpu, l.c, l.h, l.w, l.size, l.stride, l.pad, state.delta + i * l.c*l.h*l.w);\r\n\t\t}\r\n\t}\r\n}\r\nstatic void update_local_layer_gpu(local_layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tint locations = l.out_w*l.out_h;\r\n\tint size = l.size*l.size*l.c*l.n*locations;\r\n\taxpy_ongpu(l.outputs, learning_rate / batch, l.bias_updates_gpu, 1, l.biases_gpu, 1);\r\n\tscal_ongpu(l.outputs, momentum, l.bias_updates_gpu, 1);\r\n\r\n\taxpy_ongpu(size, -decay * batch, l.weights_gpu, 1, l.weight_updates_gpu, 1);\r\n\taxpy_ongpu(size, learning_rate / batch, l.weight_updates_gpu, 1, l.weights_gpu, 1);\r\n\tscal_ongpu(size, momentum, l.weight_updates_gpu, 1);\r\n}\r\nstatic void pull_local_layer(local_layer l)\r\n{\r\n\tint locations = l.out_w*l.out_h;\r\n\tint size = l.size*l.size*l.c*l.n*locations;\r\n\tcuda_pull_array(l.weights_gpu, l.weights, size);\r\n\tcuda_pull_array(l.biases_gpu, l.biases, l.outputs);\r\n}\r\nstatic void push_local_layer(local_layer l)\r\n{\r\n\tint locations = l.out_w*l.out_h;\r\n\tint size = l.size*l.size*l.c*l.n*locations;\r\n\tcuda_push_array(l.weights_gpu, l.weights, size);\r\n\tcuda_push_array(l.biases_gpu, l.biases, l.outputs);\r\n}\r\n#endif\r\nstatic local_layer make_local_layer(int batch, int h, int w, int c, int n, int size, int stride, int pad, ACTIVATION activation)\r\n{\r\n\tint i;\r\n\tlocal_layer l = { 0 };\r\n\tl.type = LOCAL;\r\n\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tl.n = n;\r\n\tl.batch = batch;\r\n\tl.stride = stride;\r\n\tl.size = size;\r\n\tl.pad = pad;\r\n\r\n\tint out_h = local_out_height(l);\r\n\tint out_w = local_out_width(l);\r\n\tint locations = out_h * out_w;\r\n\tl.out_h = out_h;\r\n\tl.out_w = out_w;\r\n\tl.out_c = n;\r\n\tl.outputs = l.out_h * l.out_w * l.out_c;\r\n\tl.inputs = l.w * l.h * l.c;\r\n\r\n\tl.weights = calloc(c*n*size*size*locations, sizeof(float));\r\n\tl.weight_updates = calloc(c*n*size*size*locations, sizeof(float));\r\n\r\n\tl.biases = calloc(l.outputs, sizeof(float));\r\n\tl.bias_updates = calloc(l.outputs, sizeof(float));\r\n\r\n\t/* float scale = 1./sqrt(size*size*c); */\r\n\tfloat scale = sqrt(2. / (size*size*c));\r\n\tfor (i = 0; i < c*n*size*size; ++i) l.weights[i] = scale * rand_uniform(-1, 1);\r\n\r\n\tl.col_image = calloc(out_h*out_w*size*size*c, sizeof(float));\r\n\tl.output = calloc(l.batch*out_h * out_w * n, sizeof(float));\r\n\tl.delta = calloc(l.batch*out_h * out_w * n, sizeof(float));\r\n\r\n\tl.forward = forward_local_layer;\r\n\tl.backward = backward_local_layer;\r\n\tl.update = update_local_layer;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_local_layer_gpu;\r\n\tl.backward_gpu = backward_local_layer_gpu;\r\n\tl.update_gpu = update_local_layer_gpu;\r\n\r\n\tl.weights_gpu = cuda_make_array(l.weights, c*n*size*size*locations);\r\n\tl.weight_updates_gpu = cuda_make_array(l.weight_updates, c*n*size*size*locations);\r\n\r\n\tl.biases_gpu = cuda_make_array(l.biases, l.outputs);\r\n\tl.bias_updates_gpu = cuda_make_array(l.bias_updates, l.outputs);\r\n\r\n\tl.col_image_gpu = cuda_make_array(l.col_image, out_h*out_w*size*size*c);\r\n\tl.delta_gpu = cuda_make_array(l.delta, l.batch*out_h*out_w*n);\r\n\tl.output_gpu = cuda_make_array(l.output, l.batch*out_h*out_w*n);\r\n\r\n#endif\r\n\tl.activation = activation;\r\n\treturn l;\r\n}\r\nstatic int parse_local(local_layer *l, list *options, size_params params, sod_cnn *pNet)\r\n{\r\n\tint n = option_find_int(options, \"filters\", 1);\r\n\tint size = option_find_int(options, \"size\", 1);\r\n\tint stride = option_find_int(options, \"stride\", 1);\r\n\tint pad = option_find_int(options, \"pad\", 0);\r\n\tchar *activation_s = option_find_str(options, \"activation\", \"logistic\");\r\n\tACTIVATION activation = get_activation(activation_s);\r\n\r\n\tint batch, h, w, c;\r\n\th = params.h;\r\n\tw = params.w;\r\n\tc = params.c;\r\n\tbatch = params.batch;\r\n\tif (!(h && w && c)) {\r\n\t\tpNet->zErr = \"Layer before local layer must output image.\";\r\n\t\tpNet->nErr++;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t*l = make_local_layer(batch, h, w, c, n, size, stride, pad, activation);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== Activation =============================================================== */\r\nstatic void forward_activation_layer(layer l, network_state state)\r\n{\r\n\tcopy_cpu(l.outputs*l.batch, state.input, 1, l.output, 1);\r\n\tactivate_array(l.output, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_activation_layer(layer l, network_state state)\r\n{\r\n\tgradient_array(l.output, l.outputs*l.batch, l.activation, l.delta);\r\n\tcopy_cpu(l.outputs*l.batch, l.delta, 1, state.delta, 1);\r\n}\r\n\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void forward_activation_layer_gpu(layer l, network_state state)\r\n{\r\n\tcopy_ongpu(l.outputs*l.batch, state.input, 1, l.output_gpu, 1);\r\n\tactivate_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_activation_layer_gpu(layer l, network_state state)\r\n{\r\n\tgradient_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation, l.delta_gpu);\r\n\tcopy_ongpu(l.outputs*l.batch, l.delta_gpu, 1, state.delta, 1);\r\n}\r\n#endif\r\nstatic layer make_activation_layer(int batch, int inputs, ACTIVATION activation)\r\n{\r\n\tlayer l = { 0 };\r\n\tl.type = ACTIVE;\r\n\r\n\tl.inputs = inputs;\r\n\tl.outputs = inputs;\r\n\tl.batch = batch;\r\n\r\n\tl.output = calloc(batch*inputs, sizeof(float));\r\n\tl.delta = calloc(batch*inputs, sizeof(float));\r\n\r\n\tl.forward = forward_activation_layer;\r\n\tl.backward = backward_activation_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_activation_layer_gpu;\r\n\tl.backward_gpu = backward_activation_layer_gpu;\r\n\r\n\tl.output_gpu = cuda_make_array(l.output, inputs*batch);\r\n\tl.delta_gpu = cuda_make_array(l.delta, inputs*batch);\r\n#endif\r\n\tl.activation = activation;\r\n\treturn l;\r\n}\r\nstatic int parse_activation(layer *la, list *options, size_params params)\r\n{\r\n\tchar *activation_s = option_find_str(options, \"activation\", \"linear\");\r\n\tACTIVATION activation = get_activation(activation_s);\r\n\r\n\t*la = make_activation_layer(params.batch, params.inputs, activation);\r\n\r\n\tla->out_h = params.h;\r\n\tla->out_w = params.w;\r\n\tla->out_c = params.c;\r\n\tla->h = params.h;\r\n\tla->w = params.w;\r\n\tla->c = params.c;\r\n\treturn SOD_OK;\r\n}\r\n/* ============================== Connected Layer ==============================*/\r\ntypedef layer connected_layer;\r\nstatic void update_connected_layer(connected_layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\taxpy_cpu(l.outputs, learning_rate / batch, l.bias_updates, 1, l.biases, 1);\r\n\tscal_cpu(l.outputs, momentum, l.bias_updates, 1);\r\n\r\n\tif (l.batch_normalize) {\r\n\t\taxpy_cpu(l.outputs, learning_rate / batch, l.scale_updates, 1, l.scales, 1);\r\n\t\tscal_cpu(l.outputs, momentum, l.scale_updates, 1);\r\n\t}\r\n\r\n\taxpy_cpu(l.inputs*l.outputs, -decay * batch, l.weights, 1, l.weight_updates, 1);\r\n\taxpy_cpu(l.inputs*l.outputs, learning_rate / batch, l.weight_updates, 1, l.weights, 1);\r\n\tscal_cpu(l.inputs*l.outputs, momentum, l.weight_updates, 1);\r\n}\r\nstatic void forward_connected_layer(connected_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tfill_cpu(l.outputs*l.batch, 0, l.output, 1);\r\n\tint m = l.batch;\r\n\tint k = l.inputs;\r\n\tint n = l.outputs;\r\n\tfloat *a = state.input;\r\n\tfloat *b = l.weights;\r\n\tfloat *c = l.output;\r\n\tgemm(0, 1, m, n, k, 1, a, k, b, k, 1, c, n);\r\n\tif (l.batch_normalize) {\r\n\t\tif (state.train) {\r\n\t\t\tmean_cpu(l.output, l.batch, l.outputs, 1, l.mean);\r\n\t\t\tvariance_cpu(l.output, l.mean, l.batch, l.outputs, 1, l.variance);\r\n\r\n\t\t\tscal_cpu(l.outputs, .95, l.rolling_mean, 1);\r\n\t\t\taxpy_cpu(l.outputs, .05, l.mean, 1, l.rolling_mean, 1);\r\n\t\t\tscal_cpu(l.outputs, .95, l.rolling_variance, 1);\r\n\t\t\taxpy_cpu(l.outputs, .05, l.variance, 1, l.rolling_variance, 1);\r\n\r\n\t\t\tcopy_cpu(l.outputs*l.batch, l.output, 1, l.x, 1);\r\n\t\t\tnormalize_cpu(l.output, l.mean, l.variance, l.batch, l.outputs, 1);\r\n\t\t\tcopy_cpu(l.outputs*l.batch, l.output, 1, l.x_norm, 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnormalize_cpu(l.output, l.rolling_mean, l.rolling_variance, l.batch, l.outputs, 1);\r\n\t\t}\r\n\t\tscale_bias(l.output, l.scales, l.batch, l.outputs, 1);\r\n\t}\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\taxpy_cpu(l.outputs, 1, l.biases, 1, l.output + i * l.outputs, 1);\r\n\t}\r\n\tactivate_array(l.output, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_connected_layer(connected_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tgradient_array(l.output, l.outputs*l.batch, l.activation, l.delta);\r\n\tfor (i = 0; i < l.batch; ++i) {\r\n\t\taxpy_cpu(l.outputs, 1, l.delta + i * l.outputs, 1, l.bias_updates, 1);\r\n\t}\r\n\tif (l.batch_normalize) {\r\n\t\tbackward_scale_cpu(l.x_norm, l.delta, l.batch, l.outputs, 1, l.scale_updates);\r\n\r\n\t\tscale_bias(l.delta, l.scales, l.batch, l.outputs, 1);\r\n\r\n\t\tmean_delta_cpu(l.delta, l.variance, l.batch, l.outputs, 1, l.mean_delta);\r\n\t\tvariance_delta_cpu(l.x, l.delta, l.mean, l.variance, l.batch, l.outputs, 1, l.variance_delta);\r\n\t\tnormalize_delta_cpu(l.x, l.mean, l.variance, l.mean_delta, l.variance_delta, l.batch, l.outputs, 1, l.delta);\r\n\t}\r\n\r\n\tint m = l.outputs;\r\n\tint k = l.batch;\r\n\tint n = l.inputs;\r\n\tfloat *a = l.delta;\r\n\tfloat *b = state.input;\r\n\tfloat *c = l.weight_updates;\r\n\tgemm(1, 0, m, n, k, 1, a, m, b, n, 1, c, n);\r\n\r\n\tm = l.batch;\r\n\tk = l.outputs;\r\n\tn = l.inputs;\r\n\r\n\ta = l.delta;\r\n\tb = l.weights;\r\n\tc = state.delta;\r\n\r\n\tif (c) gemm(0, 0, m, n, k, 1, a, k, b, n, 1, c, n);\r\n}\r\nstatic connected_layer make_connected_layer(int batch, int inputs, int outputs, ACTIVATION activation, int batch_normalize)\r\n{\r\n\tint i;\r\n\tconnected_layer l = { 0 };\r\n\tl.type = CONNECTED;\r\n\r\n\tl.inputs = inputs;\r\n\tl.outputs = outputs;\r\n\tl.batch = batch;\r\n\tl.batch_normalize = batch_normalize;\r\n\tl.h = 1;\r\n\tl.w = 1;\r\n\tl.c = inputs;\r\n\tl.out_h = 1;\r\n\tl.out_w = 1;\r\n\tl.out_c = outputs;\r\n\r\n\tl.output = calloc(batch*outputs, sizeof(float));\r\n\tl.delta = calloc(batch*outputs, sizeof(float));\r\n\r\n\tl.weight_updates = calloc(inputs*outputs, sizeof(float));\r\n\tl.bias_updates = calloc(outputs, sizeof(float));\r\n\r\n\tl.weights = calloc(outputs*inputs, sizeof(float));\r\n\tl.biases = calloc(outputs, sizeof(float));\r\n\r\n\tl.forward = forward_connected_layer;\r\n\tl.backward = backward_connected_layer;\r\n\tl.update = update_connected_layer;\r\n\r\n\tfloat scale = sqrt(2. / inputs);\r\n\tfor (i = 0; i < outputs*inputs; ++i) {\r\n\t\tl.weights[i] = scale * rand_uniform(-1, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < outputs; ++i) {\r\n\t\tl.biases[i] = 0;\r\n\t}\r\n\r\n\tif (batch_normalize) {\r\n\t\tl.scales = calloc(outputs, sizeof(float));\r\n\t\tl.scale_updates = calloc(outputs, sizeof(float));\r\n\t\tfor (i = 0; i < outputs; ++i) {\r\n\t\t\tl.scales[i] = 1;\r\n\t\t}\r\n\r\n\t\tl.mean = calloc(outputs, sizeof(float));\r\n\t\tl.mean_delta = calloc(outputs, sizeof(float));\r\n\t\tl.variance = calloc(outputs, sizeof(float));\r\n\t\tl.variance_delta = calloc(outputs, sizeof(float));\r\n\r\n\t\tl.rolling_mean = calloc(outputs, sizeof(float));\r\n\t\tl.rolling_variance = calloc(outputs, sizeof(float));\r\n\r\n\t\tl.x = calloc(batch*outputs, sizeof(float));\r\n\t\tl.x_norm = calloc(batch*outputs, sizeof(float));\r\n\t}\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_connected_layer_gpu;\r\n\tl.backward_gpu = backward_connected_layer_gpu;\r\n\tl.update_gpu = update_connected_layer_gpu;\r\n\r\n\tl.weights_gpu = cuda_make_array(l.weights, outputs*inputs);\r\n\tl.biases_gpu = cuda_make_array(l.biases, outputs);\r\n\r\n\tl.weight_updates_gpu = cuda_make_array(l.weight_updates, outputs*inputs);\r\n\tl.bias_updates_gpu = cuda_make_array(l.bias_updates, outputs);\r\n\r\n\tl.output_gpu = cuda_make_array(l.output, outputs*batch);\r\n\tl.delta_gpu = cuda_make_array(l.delta, outputs*batch);\r\n\tif (batch_normalize) {\r\n\t\tl.scales_gpu = cuda_make_array(l.scales, outputs);\r\n\t\tl.scale_updates_gpu = cuda_make_array(l.scale_updates, outputs);\r\n\r\n\t\tl.mean_gpu = cuda_make_array(l.mean, outputs);\r\n\t\tl.variance_gpu = cuda_make_array(l.variance, outputs);\r\n\r\n\t\tl.rolling_mean_gpu = cuda_make_array(l.mean, outputs);\r\n\t\tl.rolling_variance_gpu = cuda_make_array(l.variance, outputs);\r\n\r\n\t\tl.mean_delta_gpu = cuda_make_array(l.mean, outputs);\r\n\t\tl.variance_delta_gpu = cuda_make_array(l.variance, outputs);\r\n\r\n\t\tl.x_gpu = cuda_make_array(l.output, l.batch*outputs);\r\n\t\tl.x_norm_gpu = cuda_make_array(l.output, l.batch*outputs);\r\n\t}\r\n#endif\r\n\tl.activation = activation;\r\n\treturn l;\r\n}\r\n/* =============================================================== RNN =============================================================== */\r\nstatic void increment_rnn_layer(layer *l, int steps)\r\n{\r\n\tint num = l->outputs*l->batch*steps;\r\n\tl->output += num;\r\n\tl->delta += num;\r\n\tl->x += num;\r\n\tl->x_norm += num;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl->output_gpu += num;\r\n\tl->delta_gpu += num;\r\n\tl->x_gpu += num;\r\n\tl->x_norm_gpu += num;\r\n#endif\r\n}\r\nstatic void update_rnn_layer(layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tupdate_connected_layer(*(l.input_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer(*(l.self_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer(*(l.output_layer), batch, learning_rate, momentum, decay);\r\n}\r\nstatic void forward_rnn_layer(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, output_layer.delta, 1);\r\n\tfill_cpu(l.hidden * l.batch * l.steps, 0, self_layer.delta, 1);\r\n\tfill_cpu(l.hidden * l.batch * l.steps, 0, input_layer.delta, 1);\r\n\tif (state.train) fill_cpu(l.hidden * l.batch, 0, l.state, 1);\r\n\r\n\tfor (i = 0; i < l.steps; ++i) {\r\n\t\ts.input = state.input;\r\n\t\tforward_connected_layer(input_layer, s);\r\n\r\n\t\ts.input = l.state;\r\n\t\tforward_connected_layer(self_layer, s);\r\n\r\n\t\tfloat *old_state = l.state;\r\n\t\tif (state.train) l.state += l.hidden*l.batch;\r\n\t\tif (l.shortcut) {\r\n\t\t\tcopy_cpu(l.hidden * l.batch, old_state, 1, l.state, 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfill_cpu(l.hidden * l.batch, 0, l.state, 1);\r\n\t\t}\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, input_layer.output, 1, l.state, 1);\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, self_layer.output, 1, l.state, 1);\r\n\r\n\t\ts.input = l.state;\r\n\t\tforward_connected_layer(output_layer, s);\r\n\r\n\t\tstate.input += l.inputs*l.batch;\r\n\t\tincrement_rnn_layer(&input_layer, 1);\r\n\t\tincrement_rnn_layer(&self_layer, 1);\r\n\t\tincrement_rnn_layer(&output_layer, 1);\r\n\t}\r\n}\r\nstatic void backward_rnn_layer(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\r\n\tincrement_rnn_layer(&input_layer, l.steps - 1);\r\n\tincrement_rnn_layer(&self_layer, l.steps - 1);\r\n\tincrement_rnn_layer(&output_layer, l.steps - 1);\r\n\r\n\tl.state += l.hidden*l.batch*l.steps;\r\n\tfor (i = l.steps - 1; i >= 0; --i) {\r\n\t\tcopy_cpu(l.hidden * l.batch, input_layer.output, 1, l.state, 1);\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, self_layer.output, 1, l.state, 1);\r\n\r\n\t\ts.input = l.state;\r\n\t\ts.delta = self_layer.delta;\r\n\t\tbackward_connected_layer(output_layer, s);\r\n\r\n\t\tl.state -= l.hidden*l.batch;\r\n\t\t/*\r\n\t\tif(i > 0){\r\n\t\tcopy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1);\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1);\r\n\t\t}else{\r\n\t\tfill_cpu(l.hidden * l.batch, 0, l.state, 1);\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\ts.input = l.state;\r\n\t\ts.delta = self_layer.delta - l.hidden*l.batch;\r\n\t\tif (i == 0) s.delta = 0;\r\n\t\tbackward_connected_layer(self_layer, s);\r\n\r\n\t\tcopy_cpu(l.hidden*l.batch, self_layer.delta, 1, input_layer.delta, 1);\r\n\t\tif (i > 0 && l.shortcut) axpy_cpu(l.hidden*l.batch, 1, self_layer.delta, 1, self_layer.delta - l.hidden*l.batch, 1);\r\n\t\ts.input = state.input + i * l.inputs*l.batch;\r\n\t\tif (state.delta) s.delta = state.delta + i * l.inputs*l.batch;\r\n\t\telse s.delta = 0;\r\n\t\tbackward_connected_layer(input_layer, s);\r\n\r\n\t\tincrement_rnn_layer(&input_layer, -1);\r\n\t\tincrement_rnn_layer(&self_layer, -1);\r\n\t\tincrement_rnn_layer(&output_layer, -1);\r\n\t}\r\n}\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void pull_rnn_layer(layer l)\r\n{\r\n\tpull_connected_layer(*(l.input_layer));\r\n\tpull_connected_layer(*(l.self_layer));\r\n\tpull_connected_layer(*(l.output_layer));\r\n}\r\nstatic void push_rnn_layer(layer l)\r\n{\r\n\tpush_connected_layer(*(l.input_layer));\r\n\tpush_connected_layer(*(l.self_layer));\r\n\tpush_connected_layer(*(l.output_layer));\r\n}\r\nstatic void update_rnn_layer_gpu(layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tupdate_connected_layer_gpu(*(l.input_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.self_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.output_layer), batch, learning_rate, momentum, decay);\r\n}\r\nstatic void forward_rnn_layer_gpu(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, output_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.hidden * l.batch * l.steps, 0, self_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.hidden * l.batch * l.steps, 0, input_layer.delta_gpu, 1);\r\n\tif (state.train) fill_ongpu(l.hidden * l.batch, 0, l.state_gpu, 1);\r\n\r\n\tfor (i = 0; i < l.steps; ++i) {\r\n\t\ts.input = state.input;\r\n\t\tforward_connected_layer_gpu(input_layer, s);\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\tforward_connected_layer_gpu(self_layer, s);\r\n\r\n\t\tfloat *old_state = l.state_gpu;\r\n\t\tif (state.train) l.state_gpu += l.hidden*l.batch;\r\n\t\tif (l.shortcut) {\r\n\t\t\tcopy_ongpu(l.hidden * l.batch, old_state, 1, l.state_gpu, 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfill_ongpu(l.hidden * l.batch, 0, l.state_gpu, 1);\r\n\t\t}\r\n\t\taxpy_ongpu(l.hidden * l.batch, 1, input_layer.output_gpu, 1, l.state_gpu, 1);\r\n\t\taxpy_ongpu(l.hidden * l.batch, 1, self_layer.output_gpu, 1, l.state_gpu, 1);\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\tforward_connected_layer_gpu(output_layer, s);\r\n\r\n\t\tstate.input += l.inputs*l.batch;\r\n\t\tincrement_layer(&input_layer, 1);\r\n\t\tincrement_layer(&self_layer, 1);\r\n\t\tincrement_layer(&output_layer, 1);\r\n\t}\r\n}\r\nstatic void backward_rnn_layer_gpu(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\tincrement_layer(&input_layer, l.steps - 1);\r\n\tincrement_layer(&self_layer, l.steps - 1);\r\n\tincrement_layer(&output_layer, l.steps - 1);\r\n\tl.state_gpu += l.hidden*l.batch*l.steps;\r\n\tfor (i = l.steps - 1; i >= 0; --i) {\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\ts.delta = self_layer.delta_gpu;\r\n\t\tbackward_connected_layer_gpu(output_layer, s);\r\n\r\n\t\tl.state_gpu -= l.hidden*l.batch;\r\n\r\n\t\tcopy_ongpu(l.hidden*l.batch, self_layer.delta_gpu, 1, input_layer.delta_gpu, 1);\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\ts.delta = self_layer.delta_gpu - l.hidden*l.batch;\r\n\t\tif (i == 0) s.delta = 0;\r\n\t\tbackward_connected_layer_gpu(self_layer, s);\r\n\r\n\t\t//copy_ongpu(l.hidden*l.batch, self_layer.delta_gpu, 1, input_layer.delta_gpu, 1);\r\n\t\tif (i > 0 && l.shortcut) axpy_ongpu(l.hidden*l.batch, 1, self_layer.delta_gpu, 1, self_layer.delta_gpu - l.hidden*l.batch, 1);\r\n\t\ts.input = state.input + i * l.inputs*l.batch;\r\n\t\tif (state.delta) s.delta = state.delta + i * l.inputs*l.batch;\r\n\t\telse s.delta = 0;\r\n\t\tbackward_connected_layer_gpu(input_layer, s);\r\n\r\n\t\tincrement_layer(&input_layer, -1);\r\n\t\tincrement_layer(&self_layer, -1);\r\n\t\tincrement_layer(&output_layer, -1);\r\n\t}\r\n}\r\n#endif\r\nstatic layer make_rnn_layer(int batch, int inputs, int hidden, int outputs, int steps, ACTIVATION activation, int batch_normalize, int log)\r\n{\r\n\tbatch = batch / steps;\r\n\tlayer l = { 0 };\r\n\tl.batch = batch;\r\n\tl.type = RNN;\r\n\tl.steps = steps;\r\n\tl.hidden = hidden;\r\n\tl.inputs = inputs;\r\n\r\n\tl.state = calloc(batch*hidden*(steps + 1), sizeof(float));\r\n\r\n\tl.input_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.input_layer) = make_connected_layer(batch*steps, inputs, hidden, activation, batch_normalize);\r\n\tl.input_layer->batch = batch;\r\n\r\n\tl.self_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.self_layer) = make_connected_layer(batch*steps, hidden, hidden, (log == 2) ? LOGGY : (log == 1 ? LOGISTIC : activation), batch_normalize);\r\n\tl.self_layer->batch = batch;\r\n\r\n\tl.output_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.output_layer) = make_connected_layer(batch*steps, hidden, outputs, activation, batch_normalize);\r\n\tl.output_layer->batch = batch;\r\n\r\n\tl.outputs = outputs;\r\n\tl.output = l.output_layer->output;\r\n\tl.delta = l.output_layer->delta;\r\n\r\n\tl.forward = forward_rnn_layer;\r\n\tl.backward = backward_rnn_layer;\r\n\tl.update = update_rnn_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_rnn_layer_gpu;\r\n\tl.backward_gpu = backward_rnn_layer_gpu;\r\n\tl.update_gpu = update_rnn_layer_gpu;\r\n\tl.state_gpu = cuda_make_array(l.state, batch*hidden*(steps + 1));\r\n\tl.output_gpu = l.output_layer->output_gpu;\r\n\tl.delta_gpu = l.output_layer->delta_gpu;\r\n#endif\r\n\r\n\treturn l;\r\n}\r\nstatic int parse_rnn(layer *rl, list *options, size_params params)\r\n{\r\n\tint output = option_find_int(options, \"output\", 1);\r\n\tint hidden = option_find_int(options, \"hidden\", 1);\r\n\tchar *activation_s = option_find_str(options, \"activation\", \"logistic\");\r\n\tACTIVATION activation = get_activation(activation_s);\r\n\tint batch_normalize = option_find_int(options, \"batch_normalize\", 0);\r\n\tint logistic = option_find_int(options, \"logistic\", 0);\r\n\r\n\t*rl = make_rnn_layer(params.batch, params.inputs, hidden, output, params.time_steps, activation, batch_normalize, logistic);\r\n\r\n\trl->shortcut = option_find_int(options, \"shortcut\", 0);\r\n\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== GRU =============================================================== */\r\nstatic void increment_layer_gru(layer *l, int steps)\r\n{\r\n\tint num = l->outputs*l->batch*steps;\r\n\tl->output += num;\r\n\tl->delta += num;\r\n\tl->x += num;\r\n\tl->x_norm += num;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl->output_gpu += num;\r\n\tl->delta_gpu += num;\r\n\tl->x_gpu += num;\r\n\tl->x_norm_gpu += num;\r\n#endif\r\n}\r\nstatic void update_gru_layer(layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tupdate_connected_layer(*(l.input_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer(*(l.self_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer(*(l.output_layer), batch, learning_rate, momentum, decay);\r\n}\r\nstatic void forward_gru_layer(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_z_layer = *(l.input_z_layer);\r\n\tlayer input_r_layer = *(l.input_r_layer);\r\n\tlayer input_h_layer = *(l.input_h_layer);\r\n\r\n\tlayer state_z_layer = *(l.state_z_layer);\r\n\tlayer state_r_layer = *(l.state_r_layer);\r\n\tlayer state_h_layer = *(l.state_h_layer);\r\n\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, input_z_layer.delta, 1);\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, input_r_layer.delta, 1);\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, input_h_layer.delta, 1);\r\n\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, state_z_layer.delta, 1);\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, state_r_layer.delta, 1);\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, state_h_layer.delta, 1);\r\n\tif (state.train) {\r\n\t\tfill_cpu(l.outputs * l.batch * l.steps, 0, l.delta, 1);\r\n\t\tcopy_cpu(l.outputs*l.batch, l.state, 1, l.prev_state, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.steps; ++i) {\r\n\t\ts.input = l.state;\r\n\t\tforward_connected_layer(state_z_layer, s);\r\n\t\tforward_connected_layer(state_r_layer, s);\r\n\r\n\t\ts.input = state.input;\r\n\t\tforward_connected_layer(input_z_layer, s);\r\n\t\tforward_connected_layer(input_r_layer, s);\r\n\t\tforward_connected_layer(input_h_layer, s);\r\n\r\n\r\n\t\tcopy_cpu(l.outputs*l.batch, input_z_layer.output, 1, l.z_cpu, 1);\r\n\t\taxpy_cpu(l.outputs*l.batch, 1, state_z_layer.output, 1, l.z_cpu, 1);\r\n\r\n\t\tcopy_cpu(l.outputs*l.batch, input_r_layer.output, 1, l.r_cpu, 1);\r\n\t\taxpy_cpu(l.outputs*l.batch, 1, state_r_layer.output, 1, l.r_cpu, 1);\r\n\r\n\t\tactivate_array(l.z_cpu, l.outputs*l.batch, LOGISTIC);\r\n\t\tactivate_array(l.r_cpu, l.outputs*l.batch, LOGISTIC);\r\n\r\n\t\tcopy_cpu(l.outputs*l.batch, l.state, 1, l.forgot_state, 1);\r\n\t\tmul_cpu(l.outputs*l.batch, l.r_cpu, 1, l.forgot_state, 1);\r\n\r\n\t\ts.input = l.forgot_state;\r\n\t\tforward_connected_layer(state_h_layer, s);\r\n\r\n\t\tcopy_cpu(l.outputs*l.batch, input_h_layer.output, 1, l.h_cpu, 1);\r\n\t\taxpy_cpu(l.outputs*l.batch, 1, state_h_layer.output, 1, l.h_cpu, 1);\r\n\r\n#ifdef SOD_USET\r\n\t\tactivate_array(l.h_cpu, l.outputs*l.batch, TANH);\r\n#else\r\n\t\tactivate_array(l.h_cpu, l.outputs*l.batch, LOGISTIC);\r\n#endif\r\n\r\n\t\tweighted_sum_cpu(l.state, l.h_cpu, l.z_cpu, l.outputs*l.batch, l.output);\r\n\r\n\t\tcopy_cpu(l.outputs*l.batch, l.output, 1, l.state, 1);\r\n\r\n\t\tstate.input += l.inputs*l.batch;\r\n\t\tl.output += l.outputs*l.batch;\r\n\t\tincrement_layer_gru(&input_z_layer, 1);\r\n\t\tincrement_layer_gru(&input_r_layer, 1);\r\n\t\tincrement_layer_gru(&input_h_layer, 1);\r\n\r\n\t\tincrement_layer_gru(&state_z_layer, 1);\r\n\t\tincrement_layer_gru(&state_r_layer, 1);\r\n\t\tincrement_layer_gru(&state_h_layer, 1);\r\n\t}\r\n}\r\nstatic void backward_gru_layer(layer l, network_state state) { (void)l; (void)state; /* shut up the compiler */ }\r\n\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void pull_gru_layer(layer l) {}\r\nstatic void push_gru_layer(layer l) {}\r\nstatic void update_gru_layer_gpu(layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tupdate_connected_layer_gpu(*(l.input_r_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.input_z_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.input_h_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.state_r_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.state_z_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_connected_layer_gpu(*(l.state_h_layer), batch, learning_rate, momentum, decay);\r\n}\r\nstatic void forward_gru_layer_gpu(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_z_layer = *(l.input_z_layer);\r\n\tlayer input_r_layer = *(l.input_r_layer);\r\n\tlayer input_h_layer = *(l.input_h_layer);\r\n\r\n\tlayer state_z_layer = *(l.state_z_layer);\r\n\tlayer state_r_layer = *(l.state_r_layer);\r\n\tlayer state_h_layer = *(l.state_h_layer);\r\n\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, input_z_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, input_r_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, input_h_layer.delta_gpu, 1);\r\n\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, state_z_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, state_r_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, state_h_layer.delta_gpu, 1);\r\n\tif (state.train) {\r\n\t\tfill_ongpu(l.outputs * l.batch * l.steps, 0, l.delta_gpu, 1);\r\n\t\tcopy_ongpu(l.outputs*l.batch, l.state_gpu, 1, l.prev_state_gpu, 1);\r\n\t}\r\n\r\n\tfor (i = 0; i < l.steps; ++i) {\r\n\t\ts.input = l.state_gpu;\r\n\t\tforward_connected_layer_gpu(state_z_layer, s);\r\n\t\tforward_connected_layer_gpu(state_r_layer, s);\r\n\r\n\t\ts.input = state.input;\r\n\t\tforward_connected_layer_gpu(input_z_layer, s);\r\n\t\tforward_connected_layer_gpu(input_r_layer, s);\r\n\t\tforward_connected_layer_gpu(input_h_layer, s);\r\n\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_z_layer.output_gpu, 1, l.z_gpu, 1);\r\n\t\taxpy_ongpu(l.outputs*l.batch, 1, state_z_layer.output_gpu, 1, l.z_gpu, 1);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_r_layer.output_gpu, 1, l.r_gpu, 1);\r\n\t\taxpy_ongpu(l.outputs*l.batch, 1, state_r_layer.output_gpu, 1, l.r_gpu, 1);\r\n\r\n\t\tactivate_array_ongpu(l.z_gpu, l.outputs*l.batch, LOGISTIC);\r\n\t\tactivate_array_ongpu(l.r_gpu, l.outputs*l.batch, LOGISTIC);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, l.state_gpu, 1, l.forgot_state_gpu, 1);\r\n\t\tmul_ongpu(l.outputs*l.batch, l.r_gpu, 1, l.forgot_state_gpu, 1);\r\n\r\n\t\ts.input = l.forgot_state_gpu;\r\n\t\tforward_connected_layer_gpu(state_h_layer, s);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_h_layer.output_gpu, 1, l.h_gpu, 1);\r\n\t\taxpy_ongpu(l.outputs*l.batch, 1, state_h_layer.output_gpu, 1, l.h_gpu, 1);\r\n\r\n#ifdef SOD_USET\r\n\t\tactivate_array_ongpu(l.h_gpu, l.outputs*l.batch, TANH);\r\n#else\r\n\t\tactivate_array_ongpu(l.h_gpu, l.outputs*l.batch, LOGISTIC);\r\n#endif\r\n\r\n\t\tweighted_sum_gpu(l.state_gpu, l.h_gpu, l.z_gpu, l.outputs*l.batch, l.output_gpu);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, l.output_gpu, 1, l.state_gpu, 1);\r\n\r\n\t\tstate.input += l.inputs*l.batch;\r\n\t\tl.output_gpu += l.outputs*l.batch;\r\n\t\tincrement_layer_gru(&input_z_layer, 1);\r\n\t\tincrement_layer_gru(&input_r_layer, 1);\r\n\t\tincrement_layer_gru(&input_h_layer, 1);\r\n\r\n\t\tincrement_layer_gru(&state_z_layer, 1);\r\n\t\tincrement_layer_gru(&state_r_layer, 1);\r\n\t\tincrement_layer_gru(&state_h_layer, 1);\r\n\t}\r\n}\r\nstatic void backward_gru_layer_gpu(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_z_layer = *(l.input_z_layer);\r\n\tlayer input_r_layer = *(l.input_r_layer);\r\n\tlayer input_h_layer = *(l.input_h_layer);\r\n\r\n\tlayer state_z_layer = *(l.state_z_layer);\r\n\tlayer state_r_layer = *(l.state_r_layer);\r\n\tlayer state_h_layer = *(l.state_h_layer);\r\n\r\n\tincrement_layer_gru(&input_z_layer, l.steps - 1);\r\n\tincrement_layer_gru(&input_r_layer, l.steps - 1);\r\n\tincrement_layer_gru(&input_h_layer, l.steps - 1);\r\n\r\n\tincrement_layer_gru(&state_z_layer, l.steps - 1);\r\n\tincrement_layer_gru(&state_r_layer, l.steps - 1);\r\n\tincrement_layer_gru(&state_h_layer, l.steps - 1);\r\n\r\n\tstate.input += l.inputs*l.batch*(l.steps - 1);\r\n\tif (state.delta) state.delta += l.inputs*l.batch*(l.steps - 1);\r\n\tl.output_gpu += l.outputs*l.batch*(l.steps - 1);\r\n\tl.delta_gpu += l.outputs*l.batch*(l.steps - 1);\r\n\tfor (i = l.steps - 1; i >= 0; --i) {\r\n\t\tif (i != 0) copy_ongpu(l.outputs*l.batch, l.output_gpu - l.outputs*l.batch, 1, l.prev_state_gpu, 1);\r\n\t\tfloat *prev_delta_gpu = (i == 0) ? 0 : l.delta_gpu - l.outputs*l.batch;\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_z_layer.output_gpu, 1, l.z_gpu, 1);\r\n\t\taxpy_ongpu(l.outputs*l.batch, 1, state_z_layer.output_gpu, 1, l.z_gpu, 1);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_r_layer.output_gpu, 1, l.r_gpu, 1);\r\n\t\taxpy_ongpu(l.outputs*l.batch, 1, state_r_layer.output_gpu, 1, l.r_gpu, 1);\r\n\r\n\t\tactivate_array_ongpu(l.z_gpu, l.outputs*l.batch, LOGISTIC);\r\n\t\tactivate_array_ongpu(l.r_gpu, l.outputs*l.batch, LOGISTIC);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_h_layer.output_gpu, 1, l.h_gpu, 1);\r\n\t\taxpy_ongpu(l.outputs*l.batch, 1, state_h_layer.output_gpu, 1, l.h_gpu, 1);\r\n\r\n#ifdef SOD_USET\r\n\t\tactivate_array_ongpu(l.h_gpu, l.outputs*l.batch, TANH);\r\n#else\r\n\t\tactivate_array_ongpu(l.h_gpu, l.outputs*l.batch, LOGISTIC);\r\n#endif\r\n\r\n\t\tweighted_delta_gpu(l.prev_state_gpu, l.h_gpu, l.z_gpu, prev_delta_gpu, input_h_layer.delta_gpu, input_z_layer.delta_gpu, l.outputs*l.batch, l.delta_gpu);\r\n\r\n#ifdef SOD_USET\r\n\t\tgradient_array_ongpu(l.h_gpu, l.outputs*l.batch, TANH, input_h_layer.delta_gpu);\r\n#else\r\n\t\tgradient_array_ongpu(l.h_gpu, l.outputs*l.batch, LOGISTIC, input_h_layer.delta_gpu);\r\n#endif\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_h_layer.delta_gpu, 1, state_h_layer.delta_gpu, 1);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, l.prev_state_gpu, 1, l.forgot_state_gpu, 1);\r\n\t\tmul_ongpu(l.outputs*l.batch, l.r_gpu, 1, l.forgot_state_gpu, 1);\r\n\t\tfill_ongpu(l.outputs*l.batch, 0, l.forgot_delta_gpu, 1);\r\n\r\n\t\ts.input = l.forgot_state_gpu;\r\n\t\ts.delta = l.forgot_delta_gpu;\r\n\r\n\t\tbackward_connected_layer_gpu(state_h_layer, s);\r\n\t\tif (prev_delta_gpu) mult_add_into_gpu(l.outputs*l.batch, l.forgot_delta_gpu, l.r_gpu, prev_delta_gpu);\r\n\t\tmult_add_into_gpu(l.outputs*l.batch, l.forgot_delta_gpu, l.prev_state_gpu, input_r_layer.delta_gpu);\r\n\r\n\t\tgradient_array_ongpu(l.r_gpu, l.outputs*l.batch, LOGISTIC, input_r_layer.delta_gpu);\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_r_layer.delta_gpu, 1, state_r_layer.delta_gpu, 1);\r\n\r\n\t\tgradient_array_ongpu(l.z_gpu, l.outputs*l.batch, LOGISTIC, input_z_layer.delta_gpu);\r\n\t\tcopy_ongpu(l.outputs*l.batch, input_z_layer.delta_gpu, 1, state_z_layer.delta_gpu, 1);\r\n\r\n\t\ts.input = l.prev_state_gpu;\r\n\t\ts.delta = prev_delta_gpu;\r\n\r\n\t\tbackward_connected_layer_gpu(state_r_layer, s);\r\n\t\tbackward_connected_layer_gpu(state_z_layer, s);\r\n\r\n\t\ts.input = state.input;\r\n\t\ts.delta = state.delta;\r\n\r\n\t\tbackward_connected_layer_gpu(input_h_layer, s);\r\n\t\tbackward_connected_layer_gpu(input_r_layer, s);\r\n\t\tbackward_connected_layer_gpu(input_z_layer, s);\r\n\r\n\r\n\t\tstate.input -= l.inputs*l.batch;\r\n\t\tif (state.delta) state.delta -= l.inputs*l.batch;\r\n\t\tl.output_gpu -= l.outputs*l.batch;\r\n\t\tl.delta_gpu -= l.outputs*l.batch;\r\n\t\tincrement_layer_gru(&input_z_layer, -1);\r\n\t\tincrement_layer_gru(&input_r_layer, -1);\r\n\t\tincrement_layer_gru(&input_h_layer, -1);\r\n\r\n\t\tincrement_layer_gru(&state_z_layer, -1);\r\n\t\tincrement_layer_gru(&state_r_layer, -1);\r\n\t\tincrement_layer_gru(&state_h_layer, -1);\r\n\t}\r\n}\r\n#endif\r\nstatic layer make_gru_layer(int batch, int inputs, int outputs, int steps, int batch_normalize)\r\n{\r\n\tbatch = batch / steps;\r\n\tlayer l = { 0 };\r\n\tl.batch = batch;\r\n\tl.type = GRU;\r\n\tl.steps = steps;\r\n\tl.inputs = inputs;\r\n\r\n\tl.input_z_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.input_z_layer) = make_connected_layer(batch*steps, inputs, outputs, LINEAR, batch_normalize);\r\n\tl.input_z_layer->batch = batch;\r\n\r\n\tl.state_z_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.state_z_layer) = make_connected_layer(batch*steps, outputs, outputs, LINEAR, batch_normalize);\r\n\tl.state_z_layer->batch = batch;\r\n\r\n\tl.input_r_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.input_r_layer) = make_connected_layer(batch*steps, inputs, outputs, LINEAR, batch_normalize);\r\n\tl.input_r_layer->batch = batch;\r\n\r\n\tl.state_r_layer = malloc(sizeof(layer));\r\n\t*(l.state_r_layer) = make_connected_layer(batch*steps, outputs, outputs, LINEAR, batch_normalize);\r\n\tl.state_r_layer->batch = batch;\r\n\r\n\tl.input_h_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.input_h_layer) = make_connected_layer(batch*steps, inputs, outputs, LINEAR, batch_normalize);\r\n\tl.input_h_layer->batch = batch;\r\n\r\n\tl.state_h_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.state_h_layer) = make_connected_layer(batch*steps, outputs, outputs, LINEAR, batch_normalize);\r\n\tl.state_h_layer->batch = batch;\r\n\r\n\tl.batch_normalize = batch_normalize;\r\n\r\n\tl.outputs = outputs;\r\n\tl.output = calloc(outputs*batch*steps, sizeof(float));\r\n\tl.delta = calloc(outputs*batch*steps, sizeof(float));\r\n\tl.state = calloc(outputs*batch, sizeof(float));\r\n\tl.prev_state = calloc(outputs*batch, sizeof(float));\r\n\tl.forgot_state = calloc(outputs*batch, sizeof(float));\r\n\tl.forgot_delta = calloc(outputs*batch, sizeof(float));\r\n\r\n\tl.r_cpu = calloc(outputs*batch, sizeof(float));\r\n\tl.z_cpu = calloc(outputs*batch, sizeof(float));\r\n\tl.h_cpu = calloc(outputs*batch, sizeof(float));\r\n\r\n\tl.forward = forward_gru_layer;\r\n\tl.backward = backward_gru_layer;\r\n\tl.update = update_gru_layer;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_gru_layer_gpu;\r\n\tl.backward_gpu = backward_gru_layer_gpu;\r\n\tl.update_gpu = update_gru_layer_gpu;\r\n\r\n\tl.forgot_state_gpu = cuda_make_array(l.output, batch*outputs);\r\n\tl.forgot_delta_gpu = cuda_make_array(l.output, batch*outputs);\r\n\tl.prev_state_gpu = cuda_make_array(l.output, batch*outputs);\r\n\tl.state_gpu = cuda_make_array(l.output, batch*outputs);\r\n\tl.output_gpu = cuda_make_array(l.output, batch*outputs*steps);\r\n\tl.delta_gpu = cuda_make_array(l.delta, batch*outputs*steps);\r\n\tl.r_gpu = cuda_make_array(l.output_gpu, batch*outputs);\r\n\tl.z_gpu = cuda_make_array(l.output_gpu, batch*outputs);\r\n\tl.h_gpu = cuda_make_array(l.output_gpu, batch*outputs);\r\n#endif\r\n\r\n\treturn l;\r\n}\r\nstatic int parse_gru(layer *l, list *options, size_params params)\r\n{\r\n\tint output = option_find_int(options, \"output\", 1);\r\n\tint batch_normalize = option_find_int(options, \"batch_normalize\", 0);\r\n\t*l = make_gru_layer(params.batch, params.inputs, output, params.time_steps, batch_normalize);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== CRNN =============================================================== */\r\nstatic void increment_layer_crnn(layer *l, int steps)\r\n{\r\n\tint num = l->outputs*l->batch*steps;\r\n\tl->output += num;\r\n\tl->delta += num;\r\n\tl->x += num;\r\n\tl->x_norm += num;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl->output_gpu += num;\r\n\tl->delta_gpu += num;\r\n\tl->x_gpu += num;\r\n\tl->x_norm_gpu += num;\r\n#endif\r\n}\r\nstatic void update_crnn_layer(layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tupdate_convolutional_layer(*(l.input_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_convolutional_layer(*(l.self_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_convolutional_layer(*(l.output_layer), batch, learning_rate, momentum, decay);\r\n}\r\nstatic void forward_crnn_layer(layer l, network_state state)\r\n{\r\n\tint i;\r\n\tnetwork_state s = { 0 };\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\ts.train = state.train;\r\n\tfill_cpu(l.outputs * l.batch * l.steps, 0, output_layer.delta, 1);\r\n\tfill_cpu(l.hidden * l.batch * l.steps, 0, self_layer.delta, 1);\r\n\tfill_cpu(l.hidden * l.batch * l.steps, 0, input_layer.delta, 1);\r\n\tif (state.train) fill_cpu(l.hidden * l.batch, 0, l.state, 1);\r\n\r\n\tfor (i = 0; i < l.steps; ++i) {\r\n\t\tfloat *old_state;\r\n\t\ts.input = state.input;\r\n\t\tforward_convolutional_layer(input_layer, s);\r\n\r\n\t\ts.input = l.state;\r\n\t\tforward_convolutional_layer(self_layer, s);\r\n\r\n\t\told_state = l.state;\r\n\t\tif (state.train) l.state += l.hidden*l.batch;\r\n\t\tif (l.shortcut) {\r\n\t\t\tcopy_cpu(l.hidden * l.batch, old_state, 1, l.state, 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfill_cpu(l.hidden * l.batch, 0, l.state, 1);\r\n\t\t}\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, input_layer.output, 1, l.state, 1);\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, self_layer.output, 1, l.state, 1);\r\n\r\n\t\ts.input = l.state;\r\n\t\tforward_convolutional_layer(output_layer, s);\r\n\r\n\t\tstate.input += l.inputs*l.batch;\r\n\t\tincrement_layer_crnn(&input_layer, 1);\r\n\t\tincrement_layer_crnn(&self_layer, 1);\r\n\t\tincrement_layer_crnn(&output_layer, 1);\r\n\t}\r\n}\r\nstatic void backward_crnn_layer(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\ts.train = state.train;\r\n\tincrement_layer_crnn(&input_layer, l.steps - 1);\r\n\tincrement_layer_crnn(&self_layer, l.steps - 1);\r\n\tincrement_layer_crnn(&output_layer, l.steps - 1);\r\n\r\n\tl.state += l.hidden*l.batch*l.steps;\r\n\tfor (i = l.steps - 1; i >= 0; --i) {\r\n\t\tcopy_cpu(l.hidden * l.batch, input_layer.output, 1, l.state, 1);\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, self_layer.output, 1, l.state, 1);\r\n\r\n\t\ts.input = l.state;\r\n\t\ts.delta = self_layer.delta;\r\n\t\tbackward_convolutional_layer(output_layer, s);\r\n\r\n\t\tl.state -= l.hidden*l.batch;\r\n\t\t/*\r\n\t\tif(i > 0){\r\n\t\tcopy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1);\r\n\t\taxpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1);\r\n\t\t}else{\r\n\t\tfill_cpu(l.hidden * l.batch, 0, l.state, 1);\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\ts.input = l.state;\r\n\t\ts.delta = self_layer.delta - l.hidden*l.batch;\r\n\t\tif (i == 0) s.delta = 0;\r\n\t\tbackward_convolutional_layer(self_layer, s);\r\n\r\n\t\tcopy_cpu(l.hidden*l.batch, self_layer.delta, 1, input_layer.delta, 1);\r\n\t\tif (i > 0 && l.shortcut) axpy_cpu(l.hidden*l.batch, 1, self_layer.delta, 1, self_layer.delta - l.hidden*l.batch, 1);\r\n\t\ts.input = state.input + i * l.inputs*l.batch;\r\n\t\tif (state.delta) s.delta = state.delta + i * l.inputs*l.batch;\r\n\t\telse s.delta = 0;\r\n\t\tbackward_convolutional_layer(input_layer, s);\r\n\r\n\t\tincrement_layer_crnn(&input_layer, -1);\r\n\t\tincrement_layer_crnn(&self_layer, -1);\r\n\t\tincrement_layer_crnn(&output_layer, -1);\r\n\t}\r\n}\r\n\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void pull_crnn_layer(layer l)\r\n{\r\n\tpull_convolutional_layer(*(l.input_layer));\r\n\tpull_convolutional_layer(*(l.self_layer));\r\n\tpull_convolutional_layer(*(l.output_layer));\r\n}\r\nstatic void push_crnn_layer(layer l)\r\n{\r\n\tpush_convolutional_layer(*(l.input_layer));\r\n\tpush_convolutional_layer(*(l.self_layer));\r\n\tpush_convolutional_layer(*(l.output_layer));\r\n}\r\nstatic void update_crnn_layer_gpu(layer l, int batch, float learning_rate, float momentum, float decay)\r\n{\r\n\tupdate_convolutional_layer_gpu(*(l.input_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_convolutional_layer_gpu(*(l.self_layer), batch, learning_rate, momentum, decay);\r\n\tupdate_convolutional_layer_gpu(*(l.output_layer), batch, learning_rate, momentum, decay);\r\n}\r\nstatic void forward_crnn_layer_gpu(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\r\n\tfill_ongpu(l.outputs * l.batch * l.steps, 0, output_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.hidden * l.batch * l.steps, 0, self_layer.delta_gpu, 1);\r\n\tfill_ongpu(l.hidden * l.batch * l.steps, 0, input_layer.delta_gpu, 1);\r\n\tif (state.train) fill_ongpu(l.hidden * l.batch, 0, l.state_gpu, 1);\r\n\r\n\tfor (i = 0; i < l.steps; ++i) {\r\n\t\ts.input = state.input;\r\n\t\tforward_convolutional_layer_gpu(input_layer, s);\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\tforward_convolutional_layer_gpu(self_layer, s);\r\n\r\n\t\tfloat *old_state = l.state_gpu;\r\n\t\tif (state.train) l.state_gpu += l.hidden*l.batch;\r\n\t\tif (l.shortcut) {\r\n\t\t\tcopy_ongpu(l.hidden * l.batch, old_state, 1, l.state_gpu, 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfill_ongpu(l.hidden * l.batch, 0, l.state_gpu, 1);\r\n\t\t}\r\n\t\taxpy_ongpu(l.hidden * l.batch, 1, input_layer.output_gpu, 1, l.state_gpu, 1);\r\n\t\taxpy_ongpu(l.hidden * l.batch, 1, self_layer.output_gpu, 1, l.state_gpu, 1);\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\tforward_convolutional_layer_gpu(output_layer, s);\r\n\r\n\t\tstate.input += l.inputs*l.batch;\r\n\t\tincrement_layer_crnn(&input_layer, 1);\r\n\t\tincrement_layer_crnn(&self_layer, 1);\r\n\t\tincrement_layer_crnn(&output_layer, 1);\r\n\t}\r\n}\r\nstatic void backward_crnn_layer_gpu(layer l, network_state state)\r\n{\r\n\tnetwork_state s = { 0 };\r\n\ts.train = state.train;\r\n\tint i;\r\n\tlayer input_layer = *(l.input_layer);\r\n\tlayer self_layer = *(l.self_layer);\r\n\tlayer output_layer = *(l.output_layer);\r\n\tincrement_layer(&input_layer, l.steps - 1);\r\n\tincrement_layer(&self_layer, l.steps - 1);\r\n\tincrement_layer(&output_layer, l.steps - 1);\r\n\tl.state_gpu += l.hidden*l.batch*l.steps;\r\n\tfor (i = l.steps - 1; i >= 0; --i) {\r\n\t\tcopy_ongpu(l.hidden * l.batch, input_layer.output_gpu, 1, l.state_gpu, 1);\r\n\t\taxpy_ongpu(l.hidden * l.batch, 1, self_layer.output_gpu, 1, l.state_gpu, 1);\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\ts.delta = self_layer.delta_gpu;\r\n\t\tbackward_convolutional_layer_gpu(output_layer, s);\r\n\r\n\t\tl.state_gpu -= l.hidden*l.batch;\r\n\r\n\t\ts.input = l.state_gpu;\r\n\t\ts.delta = self_layer.delta_gpu - l.hidden*l.batch;\r\n\t\tif (i == 0) s.delta = 0;\r\n\t\tbackward_convolutional_layer_gpu(self_layer, s);\r\n\r\n\t\tcopy_ongpu(l.hidden*l.batch, self_layer.delta_gpu, 1, input_layer.delta_gpu, 1);\r\n\t\tif (i > 0 && l.shortcut) axpy_ongpu(l.hidden*l.batch, 1, self_layer.delta_gpu, 1, self_layer.delta_gpu - l.hidden*l.batch, 1);\r\n\t\ts.input = state.input + i * l.inputs*l.batch;\r\n\t\tif (state.delta) s.delta = state.delta + i * l.inputs*l.batch;\r\n\t\telse s.delta = 0;\r\n\t\tbackward_convolutional_layer_gpu(input_layer, s);\r\n\r\n\t\tincrement_layer_crnn(&input_layer, -1);\r\n\t\tincrement_layer_crnn(&self_layer, -1);\r\n\t\tincrement_layer_crnn(&output_layer, -1);\r\n\t}\r\n}\r\n#endif\r\nstatic layer make_crnn_layer(int batch, int h, int w, int c, int hidden_filters, int output_filters, int steps, ACTIVATION activation, int batch_normalize)\r\n{\r\n\tlayer l = { 0 };\r\n\tbatch = batch / steps;\r\n\tl.batch = batch;\r\n\tl.type = CRNN;\r\n\tl.steps = steps;\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tl.out_h = h;\r\n\tl.out_w = w;\r\n\tl.out_c = output_filters;\r\n\tl.inputs = h * w*c;\r\n\tl.hidden = h * w * hidden_filters;\r\n\tl.outputs = l.out_h * l.out_w * l.out_c;\r\n\r\n\tl.state = calloc(l.hidden*batch*(steps + 1), sizeof(float));\r\n\r\n\tl.input_layer = malloc(sizeof(layer));\r\n\r\n\t*(l.input_layer) = make_convolutional_layer(batch*steps, h, w, c, hidden_filters, 3, 1, 1, activation, batch_normalize, 0, 0, 0);\r\n\tl.input_layer->batch = batch;\r\n\r\n\tl.self_layer = malloc(sizeof(layer));\r\n\t*(l.self_layer) = make_convolutional_layer(batch*steps, h, w, hidden_filters, hidden_filters, 3, 1, 1, activation, batch_normalize, 0, 0, 0);\r\n\tl.self_layer->batch = batch;\r\n\r\n\tl.output_layer = malloc(sizeof(layer));\r\n\t*(l.output_layer) = make_convolutional_layer(batch*steps, h, w, hidden_filters, output_filters, 3, 1, 1, activation, batch_normalize, 0, 0, 0);\r\n\tl.output_layer->batch = batch;\r\n\r\n\tl.output = l.output_layer->output;\r\n\tl.delta = l.output_layer->delta;\r\n\r\n\tl.forward = forward_crnn_layer;\r\n\tl.backward = backward_crnn_layer;\r\n\tl.update = update_crnn_layer;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_crnn_layer_gpu;\r\n\tl.backward_gpu = backward_crnn_layer_gpu;\r\n\tl.update_gpu = update_crnn_layer_gpu;\r\n\r\n\tl.state_gpu = cuda_make_array(l.state, l.hidden*batch*(steps + 1));\r\n\tl.output_gpu = l.output_layer->output_gpu;\r\n\tl.delta_gpu = l.output_layer->delta_gpu;\r\n#endif\r\n\r\n\treturn l;\r\n}\r\nstatic int parse_crnn(layer *l, list *options, size_params params)\r\n{\r\n\tint output_filters = option_find_int(options, \"output_filters\", 1);\r\n\tint hidden_filters = option_find_int(options, \"hidden_filters\", 1);\r\n\tchar *activation_s = option_find_str(options, \"activation\", \"logistic\");\r\n\tACTIVATION activation = get_activation(activation_s);\r\n\tint batch_normalize = option_find_int(options, \"batch_normalize\", 0);\r\n\r\n\t*l = make_crnn_layer(params.batch, params.w, params.h, params.c, hidden_filters, output_filters, params.time_steps, activation, batch_normalize);\r\n\tl->shortcut = option_find_int(options, \"shortcut\", 0);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== CONNECTED =============================================================== */\r\nstatic int parse_connected(connected_layer *l, list *options, size_params params)\r\n{\r\n\tint output = option_find_int(options, \"output\", 1);\r\n\tchar *activation_s = option_find_str(options, \"activation\", \"logistic\");\r\n\tACTIVATION activation = get_activation(activation_s);\r\n\tint batch_normalize = option_find_int(options, \"batch_normalize\", 0);\r\n\t*l = make_connected_layer(params.batch, params.inputs, output, activation, batch_normalize);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== CROP =============================================================== */\r\ntypedef layer crop_layer;\r\nstatic void forward_crop_layer(const crop_layer l, network_state state)\r\n{\r\n\tint i, j, c, b, row, col;\r\n\tint index;\r\n\tint count = 0;\r\n\tint flip = (l.flip && rand() % 2);\r\n\tint dh = rand() % (l.h - l.out_h + 1);\r\n\tint dw = rand() % (l.w - l.out_w + 1);\r\n\tfloat scale = 2;\r\n\tfloat trans = -1;\r\n\tif (l.noadjust) {\r\n\t\tscale = 1;\r\n\t\ttrans = 0;\r\n\t}\r\n\tif (!state.train) {\r\n\t\tflip = 0;\r\n\t\tdh = (l.h - l.out_h) / 2;\r\n\t\tdw = (l.w - l.out_w) / 2;\r\n\t}\r\n\tfor (b = 0; b < l.batch; ++b) {\r\n\t\tfor (c = 0; c < l.c; ++c) {\r\n\t\t\tfor (i = 0; i < l.out_h; ++i) {\r\n\t\t\t\tfor (j = 0; j < l.out_w; ++j) {\r\n\t\t\t\t\tif (flip) {\r\n\t\t\t\t\t\tcol = l.w - dw - j - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcol = j + dw;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trow = i + dh;\r\n\t\t\t\t\tindex = col + l.w*(row + l.h*(c + l.c*b));\r\n\t\t\t\t\tl.output[count++] = state.input[index] * scale + trans;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void backward_crop_layer(const crop_layer l, network_state state) { (void)l; (void)state; /* shut up the compiler */ }\r\nstatic crop_layer make_crop_layer(int batch, int h, int w, int c, int crop_height, int crop_width, int flip, float angle, float saturation, float exposure)\r\n{\r\n\tcrop_layer l = { 0 };\r\n\tl.type = CROP;\r\n\tl.batch = batch;\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tl.scale = (float)crop_height / h;\r\n\tl.flip = flip;\r\n\tl.angle = angle;\r\n\tl.saturation = saturation;\r\n\tl.exposure = exposure;\r\n\tl.out_w = crop_width;\r\n\tl.out_h = crop_height;\r\n\tl.out_c = c;\r\n\tl.inputs = l.w * l.h * l.c;\r\n\tl.outputs = l.out_w * l.out_h * l.out_c;\r\n\tl.output = calloc(l.outputs*batch, sizeof(float));\r\n\tl.forward = forward_crop_layer;\r\n\tl.backward = backward_crop_layer;\r\n\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_crop_layer_gpu;\r\n\tl.backward_gpu = backward_crop_layer_gpu;\r\n\tl.output_gpu = cuda_make_array(l.output, l.outputs*batch);\r\n\tl.rand_gpu = cuda_make_array(0, l.batch * 8);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_crop(crop_layer *l, list *options, size_params params, sod_cnn *pNet)\r\n{\r\n\tint crop_height = option_find_int(options, \"crop_height\", 1);\r\n\tint crop_width = option_find_int(options, \"crop_width\", 1);\r\n\tint flip = option_find_int(options, \"flip\", 0);\r\n\tfloat angle = option_find_float(options, \"angle\", 0);\r\n\tfloat saturation = option_find_float(options, \"saturation\", 1);\r\n\tfloat exposure = option_find_float(options, \"exposure\", 1);\r\n\r\n\tint batch, h, w, c;\r\n\th = params.h;\r\n\tw = params.w;\r\n\tc = params.c;\r\n\tbatch = params.batch;\r\n\tif (!(h && w && c)) {\r\n\t\tpNet->zErr = \"Layer before crop layer must output image.\";\r\n\t\tpNet->nErr++;\r\n\t\treturn -1;\r\n\t}\r\n\t*l = make_crop_layer(batch, h, w, c, crop_height, crop_width, flip, angle, saturation, exposure);\r\n\tl->shift = option_find_float(options, \"shift\", 0);\r\n\tl->noadjust = option_find_int(options, \"noadjust\", 0);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== COST =============================================================== */\r\ntypedef layer cost_layer;\r\n#define SECRET_NUM -1234\r\nstatic COST_TYPE get_cost_type(char *s)\r\n{\r\n\tif (strcmp(s, \"sse\") == 0) return SSE;\r\n\tif (strcmp(s, \"masked\") == 0) return MASKED;\r\n\tif (strcmp(s, \"smooth\") == 0) return SMOOTH;\r\n\r\n\treturn SSE;\r\n}\r\nstatic void forward_cost_layer(cost_layer l, network_state state)\r\n{\r\n\tif (!state.truth) return;\r\n\tif (l.cost_type == MASKED) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < l.batch*l.inputs; ++i) {\r\n\t\t\tif (state.truth[i] == SECRET_NUM) state.input[i] = SECRET_NUM;\r\n\t\t}\r\n\t}\r\n\tif (l.cost_type == SMOOTH) {\r\n\t\tsmooth_l1_cpu(l.batch*l.inputs, state.input, state.truth, l.delta, l.output);\r\n\t}\r\n\telse {\r\n\t\tl2_cpu(l.batch*l.inputs, state.input, state.truth, l.delta, l.output);\r\n\t}\r\n\tl.cost[0] = sum_array(l.output, l.batch*l.inputs);\r\n}\r\nstatic void backward_cost_layer(const cost_layer l, network_state state)\r\n{\r\n\taxpy_cpu(l.batch*l.inputs, l.scale, l.delta, 1, state.delta, 1);\r\n}\r\n\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void pull_cost_layer(cost_layer l)\r\n{\r\n\tcuda_pull_array(l.delta_gpu, l.delta, l.batch*l.inputs);\r\n}\r\nstatic void push_cost_layer(cost_layer l)\r\n{\r\n\tcuda_push_array(l.delta_gpu, l.delta, l.batch*l.inputs);\r\n}\r\nstatic int float_abs_compare(const void * a, const void * b)\r\n{\r\n\tfloat fa = *(const float*)a;\r\n\tif (fa < 0) fa = -fa;\r\n\tfloat fb = *(const float*)b;\r\n\tif (fb < 0) fb = -fb;\r\n\treturn (fa > fb) - (fa < fb);\r\n}\r\nstatic void forward_cost_layer_gpu(cost_layer l, network_state state)\r\n{\r\n\tif (!state.truth) return;\r\n\tif (l.cost_type == MASKED) {\r\n\t\tmask_ongpu(l.batch*l.inputs, state.input, SECRET_NUM, state.truth);\r\n\t}\r\n\r\n\tif (l.cost_type == SMOOTH) {\r\n\t\tsmooth_l1_gpu(l.batch*l.inputs, state.input, state.truth, l.delta_gpu, l.output_gpu);\r\n\t}\r\n\telse {\r\n\t\tl2_gpu(l.batch*l.inputs, state.input, state.truth, l.delta_gpu, l.output_gpu);\r\n\t}\r\n\r\n\tif (l.ratio) {\r\n\t\tcuda_pull_array(l.delta_gpu, l.delta, l.batch*l.inputs);\r\n\t\tqsort(l.delta, l.batch*l.inputs, sizeof(float), float_abs_compare);\r\n\t\tint n = (1 - l.ratio) * l.batch*l.inputs;\r\n\t\tfloat thresh = l.delta[n];\r\n\t\tthresh = 0;\r\n\t\tsupp_ongpu(l.batch*l.inputs, thresh, l.delta_gpu, 1);\r\n\t}\r\n\r\n\tcuda_pull_array(l.output_gpu, l.output, l.batch*l.inputs);\r\n\tl.cost[0] = sum_array(l.output, l.batch*l.inputs);\r\n}\r\nstatic void backward_cost_layer_gpu(const cost_layer l, network_state state)\r\n{\r\n\taxpy_ongpu(l.batch*l.inputs, l.scale, l.delta_gpu, 1, state.delta, 1);\r\n}\r\n#endif\r\nstatic cost_layer make_cost_layer(int batch, int inputs, COST_TYPE cost_type, float scale)\r\n{\r\n\tcost_layer l = { 0 };\r\n\tl.type = COST;\r\n\r\n\tl.scale = scale;\r\n\tl.batch = batch;\r\n\tl.inputs = inputs;\r\n\tl.outputs = inputs;\r\n\tl.cost_type = cost_type;\r\n\tl.delta = calloc(inputs*batch, sizeof(float));\r\n\tl.output = calloc(inputs*batch, sizeof(float));\r\n\tl.cost = calloc(1, sizeof(float));\r\n\r\n\tl.forward = forward_cost_layer;\r\n\tl.backward = backward_cost_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_cost_layer_gpu;\r\n\tl.backward_gpu = backward_cost_layer_gpu;\r\n\r\n\tl.delta_gpu = cuda_make_array(l.output, inputs*batch);\r\n\tl.output_gpu = cuda_make_array(l.delta, inputs*batch);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_cost(cost_layer *l, list *options, size_params params)\r\n{\r\n\tchar *type_s = option_find_str(options, \"type\", \"sse\");\r\n\tCOST_TYPE type = get_cost_type(type_s);\r\n\tfloat scale = option_find_float(options, \"scale\", 1);\r\n\t*l = make_cost_layer(params.batch, params.inputs, type, scale);\r\n\tl->ratio = option_find_float(options, \"ratio\", 0);\r\n\treturn SOD_OK;\r\n}\r\n/* ================================================ Softmax =============================== */\r\ntypedef layer softmax_layer;\r\nstatic void softmax_tree(float *input, int batch, int inputs, float temp, tree *hierarchy, float *output)\r\n{\r\n\tint b;\r\n\tfor (b = 0; b < batch; ++b) {\r\n\t\tint i;\r\n\t\tint count = 0;\r\n\t\tfor (i = 0; i < hierarchy->groups; ++i) {\r\n\t\t\tint group_size = hierarchy->group_size[i];\r\n\t\t\tsoftmax(input + b * inputs + count, group_size, temp, output + b * inputs + count);\r\n\t\t\tcount += group_size;\r\n\t\t}\r\n\t}\r\n}\r\nstatic void forward_softmax_layer(const softmax_layer l, network_state state)\r\n{\r\n\tint b;\r\n\tint inputs = l.inputs / l.groups;\r\n\tint batch = l.batch * l.groups;\r\n\tif (l.softmax_tree) {\r\n\t\tsoftmax_tree(state.input, batch, inputs, l.temperature, l.softmax_tree, l.output);\r\n\t}\r\n\telse {\r\n\t\tfor (b = 0; b < batch; ++b) {\r\n\t\t\tsoftmax(state.input + b * inputs, inputs, l.temperature, l.output + b * inputs);\r\n\t\t}\r\n\t}\r\n}\r\nstatic void backward_softmax_layer(const softmax_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < l.inputs*l.batch; ++i) {\r\n\t\tstate.delta[i] += l.delta[i];\r\n\t}\r\n}\r\n\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void pull_softmax_layer_output(const softmax_layer layer)\r\n{\r\n\tcuda_pull_array(layer.output_gpu, layer.output, layer.inputs*layer.batch);\r\n}\r\nstatic void forward_softmax_layer_gpu(const softmax_layer l, network_state state)\r\n{\r\n\tint inputs = l.inputs / l.groups;\r\n\tint batch = l.batch * l.groups;\r\n\tif (l.softmax_tree) {\r\n\t\tint i;\r\n\t\tint count = 0;\r\n\t\tfor (i = 0; i < l.softmax_tree->groups; ++i) {\r\n\t\t\tint group_size = l.softmax_tree->group_size[i];\r\n\t\t\tsoftmax_gpu(state.input + count, group_size, inputs, batch, l.temperature, l.output_gpu + count);\r\n\t\t\tcount += group_size;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tsoftmax_gpu(state.input, inputs, inputs, batch, l.temperature, l.output_gpu);\r\n\t}\r\n}\r\nstatic void backward_softmax_layer_gpu(const softmax_layer layer, network_state state)\r\n{\r\n\taxpy_ongpu(layer.batch*layer.inputs, 1, layer.delta_gpu, 1, state.delta, 1);\r\n}\r\n\r\n#endif\r\nstatic softmax_layer make_softmax_layer(int batch, int inputs, int groups)\r\n{\r\n\tsoftmax_layer l = { 0 };\r\n\tl.type = SOFTMAX;\r\n\tl.batch = batch;\r\n\tl.groups = groups;\r\n\tl.inputs = inputs;\r\n\tl.outputs = inputs;\r\n\tl.output = calloc(inputs*batch, sizeof(float));\r\n\tl.delta = calloc(inputs*batch, sizeof(float));\r\n\r\n\tl.forward = forward_softmax_layer;\r\n\tl.backward = backward_softmax_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_softmax_layer_gpu;\r\n\tl.backward_gpu = backward_softmax_layer_gpu;\r\n\r\n\tl.output_gpu = cuda_make_array(l.output, inputs*batch);\r\n\tl.delta_gpu = cuda_make_array(l.delta, inputs*batch);\r\n#endif\r\n\treturn l;\r\n}\r\n/* ============================== BOX ================================= */\r\nstatic box float_to_box(float *f)\r\n{\r\n\tbox b;\r\n\tb.x = f[0];\r\n\tb.y = f[1];\r\n\tb.w = f[2];\r\n\tb.h = f[3];\r\n\treturn b;\r\n}\r\nstatic float overlap(float x1, float w1, float x2, float w2)\r\n{\r\n\tfloat l1 = x1 - w1 / 2;\r\n\tfloat l2 = x2 - w2 / 2;\r\n\tfloat left = l1 > l2 ? l1 : l2;\r\n\tfloat r1 = x1 + w1 / 2;\r\n\tfloat r2 = x2 + w2 / 2;\r\n\tfloat right = r1 < r2 ? r1 : r2;\r\n\treturn right - left;\r\n}\r\nstatic float box_intersection(box a, box b)\r\n{\r\n\tfloat w = overlap(a.x, a.w, b.x, b.w);\r\n\tfloat h = overlap(a.y, a.h, b.y, b.h);\r\n\tif (w < 0 || h < 0) return 0;\r\n\tfloat area = w * h;\r\n\treturn area;\r\n}\r\nstatic float box_union(box a, box b)\r\n{\r\n\tfloat i = box_intersection(a, b);\r\n\tfloat u = a.w*a.h + b.w*b.h - i;\r\n\treturn u;\r\n}\r\nstatic float box_iou(box a, box b)\r\n{\r\n\treturn box_intersection(a, b) / box_union(a, b);\r\n}\r\nstatic float box_rmse(box a, box b)\r\n{\r\n\treturn sqrt(pow(a.x - b.x, 2) +\r\n\t\tpow(a.y - b.y, 2) +\r\n\t\tpow(a.w - b.w, 2) +\r\n\t\tpow(a.h - b.h, 2));\r\n}\r\n/* ============================== NMS ================================= */\r\ntypedef struct {\r\n\tint index;\r\n\tint class;\r\n\tfloat **probs;\r\n} sortable_bbox;\r\nstatic int nms_comparator(const void *pa, const void *pb)\r\n{\r\n\tsortable_bbox a = *(sortable_bbox *)pa;\r\n\tsortable_bbox b = *(sortable_bbox *)pb;\r\n\tfloat diff = a.probs[a.index][b.class] - b.probs[b.index][b.class];\r\n\tif (diff < 0) return 1;\r\n\telse if (diff > 0) return -1;\r\n\treturn 0;\r\n}\r\nstatic void do_nms_obj(box *boxes, float **probs, int total, int classes, float thresh)\r\n{\r\n\tint i, j, k;\r\n\tsortable_bbox *s = calloc(total, sizeof(sortable_bbox));\r\n\tfor (i = 0; i < total; ++i) {\r\n\t\ts[i].index = i;\r\n\t\ts[i].class = classes;\r\n\t\ts[i].probs = probs;\r\n\t}\r\n\r\n\tqsort(s, total, sizeof(sortable_bbox), nms_comparator);\r\n\tfor (i = 0; i < total; ++i) {\r\n\t\tif (probs[s[i].index][classes] == 0) continue;\r\n\t\tbox a = boxes[s[i].index];\r\n\t\tfor (j = i + 1; j < total; ++j) {\r\n\t\t\tbox b = boxes[s[j].index];\r\n\t\t\tif (box_iou(a, b) > thresh) {\r\n\t\t\t\tfor (k = 0; k < classes + 1; ++k) {\r\n\t\t\t\t\tprobs[s[j].index][k] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree(s);\r\n}\r\nstatic void do_nms_sort(box *boxes, float **probs, int total, int classes, float thresh)\r\n{\r\n\tint i, j, k;\r\n\tsortable_bbox *s = calloc(total, sizeof(sortable_bbox));\r\n\r\n\tfor (i = 0; i < total; ++i) {\r\n\t\ts[i].index = i;\r\n\t\ts[i].class = 0;\r\n\t\ts[i].probs = probs;\r\n\t}\r\n\r\n\tfor (k = 0; k < classes; ++k) {\r\n\t\tfor (i = 0; i < total; ++i) {\r\n\t\t\ts[i].class = k;\r\n\t\t}\r\n\t\tqsort(s, total, sizeof(sortable_bbox), nms_comparator);\r\n\t\tfor (i = 0; i < total; ++i) {\r\n\t\t\tif (probs[s[i].index][k] == 0) continue;\r\n\t\t\tbox a = boxes[s[i].index];\r\n\t\t\tfor (j = i + 1; j < total; ++j) {\r\n\t\t\t\tbox b = boxes[s[j].index];\r\n\t\t\t\tif (box_iou(a, b) > thresh) {\r\n\t\t\t\t\tprobs[s[j].index][k] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree(s);\r\n}\r\n/* =============================================================== Region =============================================================== */\r\nstatic float get_hierarchy_probability(float *x, tree *hier, int c)\r\n{\r\n\tfloat p = 1;\r\n\twhile (c >= 0) {\r\n\t\tp = p * x[c];\r\n\t\tc = hier->parent[c];\r\n\t}\r\n\treturn p;\r\n}\r\nstatic void delta_region_class(float *output, float *delta, int index, int class, int classes, tree *hier, float scale, float *avg_cat)\r\n{\r\n\tint i, n;\r\n\tif (hier) {\r\n\t\tfloat pred = 1;\r\n\t\twhile (class >= 0) {\r\n\t\t\tpred *= output[index + class];\r\n\t\t\tint g = hier->group[class];\r\n\t\t\tint offset = hier->group_offset[g];\r\n\t\t\tfor (i = 0; i < hier->group_size[g]; ++i) {\r\n\t\t\t\tdelta[index + offset + i] = scale * (0 - output[index + offset + i]);\r\n\t\t\t}\r\n\t\t\tdelta[index + class] = scale * (1 - output[index + class]);\r\n\r\n\t\t\tclass = hier->parent[class];\r\n\t\t}\r\n\t\t*avg_cat += pred;\r\n\t}\r\n\telse {\r\n\t\tfor (n = 0; n < classes; ++n) {\r\n\t\t\tdelta[index + n] = scale * (((n == class) ? 1 : 0) - output[index + n]);\r\n\t\t\tif (n == class) *avg_cat += output[index + n];\r\n\t\t}\r\n\t}\r\n}\r\nstatic box get_region_box(float *x, float *biases, int n, int index, int i, int j, int w, int h)\r\n{\r\n\tbox b;\r\n\tb.x = (i + logistic_activate(x[index + 0])) / w;\r\n\tb.y = (j + logistic_activate(x[index + 1])) / h;\r\n\tb.w = exp(x[index + 2]) * biases[2 * n] / w;\r\n\tb.h = exp(x[index + 3]) * biases[2 * n + 1] / h;\r\n\treturn b;\r\n}\r\nstatic float delta_region_box(box truth, float *x, float *biases, int n, int index, int i, int j, int w, int h, float *delta, float scale)\r\n{\r\n\tbox pred = get_region_box(x, biases, n, index, i, j, w, h);\r\n\tfloat iou = box_iou(pred, truth);\r\n\r\n\tfloat tx = (truth.x*w - i);\r\n\tfloat ty = (truth.y*h - j);\r\n\tfloat tw = log(truth.w*w / biases[2 * n]);\r\n\tfloat th = log(truth.h*h / biases[2 * n + 1]);\r\n\r\n\tdelta[index + 0] = scale * (tx - logistic_activate(x[index + 0])) * logistic_gradient(logistic_activate(x[index + 0]));\r\n\tdelta[index + 1] = scale * (ty - logistic_activate(x[index + 1])) * logistic_gradient(logistic_activate(x[index + 1]));\r\n\tdelta[index + 2] = scale * (tw - x[index + 2]);\r\n\tdelta[index + 3] = scale * (th - x[index + 3]);\r\n\treturn iou;\r\n}\r\nstatic void hierarchy_predictions(float *predictions, int n, tree *hier, int only_leaves)\r\n{\r\n\tint j;\r\n\tfor (j = 0; j < n; ++j) {\r\n\t\tint parent = hier->parent[j];\r\n\t\tif (parent >= 0) {\r\n\t\t\tpredictions[j] *= predictions[parent];\r\n\t\t}\r\n\t}\r\n\tif (only_leaves) {\r\n\t\tfor (j = 0; j < n; ++j) {\r\n\t\t\tif (!hier->leaf[j]) predictions[j] = 0;\r\n\t\t}\r\n\t}\r\n}\r\nstatic int hierarchy_top_prediction(float *predictions, tree *hier, float thresh)\r\n{\r\n\tfloat p = 1;\r\n\tint group = 0;\r\n\tint i;\r\n\twhile (1) {\r\n\t\tfloat max = 0;\r\n\t\tint max_i = 0;\r\n\r\n\t\tfor (i = 0; i < hier->group_size[group]; ++i) {\r\n\t\t\tint index = i + hier->group_offset[group];\r\n\t\t\tfloat val = predictions[i + hier->group_offset[group]];\r\n\t\t\tif (val > max) {\r\n\t\t\t\tmax_i = index;\r\n\t\t\t\tmax = val;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (p*max > thresh) {\r\n\t\t\tp = p * max;\r\n\t\t\tgroup = hier->child[max_i];\r\n\t\t\tif (hier->child[max_i] < 0) return max_i;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn hier->parent[hier->group_offset[group]];\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\nstatic void get_region_boxes(layer l, int w, int h, float thresh, float **probs, box *boxes, int only_objectness, int *map, float tree_thresh)\r\n{\r\n\tint i, j, n;\r\n\tfloat *predictions = l.output;\r\n\tfor (i = 0; i < l.w*l.h; ++i) {\r\n\t\tint row = i / l.w;\r\n\t\tint col = i % l.w;\r\n\t\tfor (n = 0; n < l.n; ++n) {\r\n\t\t\tint index = i * l.n + n;\r\n\t\t\tint p_index = index * (l.classes + 5) + 4;\r\n\t\t\tfloat scale = predictions[p_index];\r\n\t\t\tint box_index = index * (l.classes + 5);\r\n\t\t\tboxes[index] = get_region_box(predictions, l.biases, n, box_index, col, row, l.w, l.h);\r\n\t\t\tboxes[index].x *= w;\r\n\t\t\tboxes[index].y *= h;\r\n\t\t\tboxes[index].w *= w;\r\n\t\t\tboxes[index].h *= h;\r\n\r\n\t\t\tint class_index = index * (l.classes + 5) + 5;\r\n\t\t\tif (l.softmax_tree) {\r\n\t\t\t\thierarchy_predictions(predictions + class_index, l.classes, l.softmax_tree, 0);\r\n\t\t\t\tif (map) {\r\n\t\t\t\t\tfor (j = 0; j < 200; ++j) {\r\n\t\t\t\t\t\tfloat prob = scale * predictions[class_index + map[j]];\r\n\t\t\t\t\t\tprobs[index][j] = (prob > thresh) ? prob : 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tj = hierarchy_top_prediction(predictions + class_index, l.softmax_tree, tree_thresh);\r\n\t\t\t\t\tprobs[index][j] = (scale > thresh) ? scale : 0;\r\n\t\t\t\t\tprobs[index][l.classes] = scale;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (j = 0; j < l.classes; ++j) {\r\n\t\t\t\t\tfloat prob = scale * predictions[class_index + j];\r\n\t\t\t\t\tprobs[index][j] = (prob > thresh) ? prob : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (only_objectness) {\r\n\t\t\t\tprobs[index][0] = scale;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void forward_region_layer(const layer l, network_state state)\r\n{\r\n\tint i, j, b, t, n;\r\n\tint size = l.coords + l.classes + 1;\r\n\tmemcpy(l.output, state.input, l.outputs*l.batch * sizeof(float));\r\n#ifndef SOD_GPU\r\n\tflatten(l.output, l.w*l.h, size*l.n, l.batch, 1);\r\n#endif\r\n\tfor (b = 0; b < l.batch; ++b) {\r\n\t\tfor (i = 0; i < l.h*l.w*l.n; ++i) {\r\n\t\t\tint index = size * i + b * l.outputs;\r\n\t\t\tl.output[index + 4] = logistic_activate(l.output[index + 4]);\r\n\t\t}\r\n\t}\r\n#ifndef SOD_GPU\r\n\tif (l.softmax_tree) {\r\n\t\tfor (b = 0; b < l.batch; ++b) {\r\n\t\t\tfor (i = 0; i < l.h*l.w*l.n; ++i) {\r\n\t\t\t\tint index = size * i + b * l.outputs;\r\n\t\t\t\tsoftmax_tree(l.output + index + 5, 1, 0, 1, l.softmax_tree, l.output + index + 5);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if (l.softmax) {\r\n\t\tfor (b = 0; b < l.batch; ++b) {\r\n\t\t\tfor (i = 0; i < l.h*l.w*l.n; ++i) {\r\n\t\t\t\tint index = size * i + b * l.outputs;\r\n\t\t\t\tsoftmax(l.output + index + 5, l.classes, 1, l.output + index + 5);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n#endif\r\n\tif (!state.train) return;\r\n\tmemset(l.delta, 0, l.outputs * l.batch * sizeof(float));\r\n\tfloat avg_iou = 0;\r\n\tfloat recall = 0;\r\n\tfloat avg_cat = 0;\r\n\tfloat avg_obj = 0;\r\n\tfloat avg_anyobj = 0;\r\n\tint count = 0;\r\n\tint class_count = 0;\r\n\t*(l.cost) = 0;\r\n\tfor (b = 0; b < l.batch; ++b) {\r\n\t\tif (l.softmax_tree) {\r\n\t\t\tint onlyclass = 0;\r\n\t\t\tfor (t = 0; t < 30; ++t) {\r\n\t\t\t\tbox truth = float_to_box(state.truth + t * 5 + b * l.truths);\r\n\t\t\t\tif (!truth.x) break;\r\n\t\t\t\tint class = state.truth[t * 5 + b * l.truths + 4];\r\n\t\t\t\tfloat maxp = 0;\r\n\t\t\t\tint maxi = 0;\r\n\t\t\t\tif (truth.x > 100000 && truth.y > 100000) {\r\n\t\t\t\t\tfor (n = 0; n < l.n*l.w*l.h; ++n) {\r\n\t\t\t\t\t\tint index = size * n + b * l.outputs + 5;\r\n\t\t\t\t\t\tfloat scale = l.output[index - 1];\r\n\t\t\t\t\t\tl.delta[index - 1] = l.noobject_scale * ((0 - l.output[index - 1]) * logistic_gradient(l.output[index - 1]));\r\n\t\t\t\t\t\tfloat p = scale * get_hierarchy_probability(l.output + index, l.softmax_tree, class);\r\n\t\t\t\t\t\tif (p > maxp) {\r\n\t\t\t\t\t\t\tmaxp = p;\r\n\t\t\t\t\t\t\tmaxi = n;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tint index = size * maxi + b * l.outputs + 5;\r\n\t\t\t\t\tdelta_region_class(l.output, l.delta, index, class, l.classes, l.softmax_tree, l.class_scale, &avg_cat);\r\n\t\t\t\t\tif (l.output[index - 1] < .3) l.delta[index - 1] = l.object_scale * ((.3 - l.output[index - 1]) * logistic_gradient(l.output[index - 1]));\r\n\t\t\t\t\telse  l.delta[index - 1] = 0;\r\n\t\t\t\t\t++class_count;\r\n\t\t\t\t\tonlyclass = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (onlyclass) continue;\r\n\t\t}\r\n\t\tfor (j = 0; j < l.h; ++j) {\r\n\t\t\tfor (i = 0; i < l.w; ++i) {\r\n\t\t\t\tfor (n = 0; n < l.n; ++n) {\r\n\t\t\t\t\tint index = size * (j*l.w*l.n + i * l.n + n) + b * l.outputs;\r\n\t\t\t\t\tbox pred = get_region_box(l.output, l.biases, n, index, i, j, l.w, l.h);\r\n\t\t\t\t\tfloat best_iou = 0;\r\n\t\t\t\t\tfor (t = 0; t < 30; ++t) {\r\n\t\t\t\t\t\tbox truth = float_to_box(state.truth + t * 5 + b * l.truths);\r\n\t\t\t\t\t\tif (!truth.x) break;\r\n\t\t\t\t\t\tfloat iou = box_iou(pred, truth);\r\n\t\t\t\t\t\tif (iou > best_iou) {\r\n\t\t\t\t\t\t\tbest_iou = iou;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tavg_anyobj += l.output[index + 4];\r\n\t\t\t\t\tl.delta[index + 4] = l.noobject_scale * ((0 - l.output[index + 4]) * logistic_gradient(l.output[index + 4]));\r\n\t\t\t\t\tif (best_iou > l.thresh) {\r\n\t\t\t\t\t\tl.delta[index + 4] = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (*(state.net->seen) < 12800) {\r\n\t\t\t\t\t\tbox truth = { 0 };\r\n\t\t\t\t\t\ttruth.x = (i + .5) / l.w;\r\n\t\t\t\t\t\ttruth.y = (j + .5) / l.h;\r\n\t\t\t\t\t\ttruth.w = l.biases[2 * n] / l.w;\r\n\t\t\t\t\t\ttruth.h = l.biases[2 * n + 1] / l.h;\r\n\t\t\t\t\t\tdelta_region_box(truth, l.output, l.biases, n, index, i, j, l.w, l.h, l.delta, .01);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (t = 0; t < 30; ++t) {\r\n\t\t\tbox truth = float_to_box(state.truth + t * 5 + b * l.truths);\r\n\r\n\t\t\tif (!truth.x) break;\r\n\t\t\tfloat best_iou = 0;\r\n\t\t\tint best_index = 0;\r\n\t\t\tint best_n = 0;\r\n\t\t\ti = (truth.x * l.w);\r\n\t\t\tj = (truth.y * l.h);\r\n\r\n\t\t\tbox truth_shift = truth;\r\n\t\t\ttruth_shift.x = 0;\r\n\t\t\ttruth_shift.y = 0;\r\n\r\n\t\t\tfor (n = 0; n < l.n; ++n) {\r\n\t\t\t\tint index = size * (j*l.w*l.n + i * l.n + n) + b * l.outputs;\r\n\t\t\t\tbox pred = get_region_box(l.output, l.biases, n, index, i, j, l.w, l.h);\r\n\t\t\t\tif (l.bias_match) {\r\n\t\t\t\t\tpred.w = l.biases[2 * n] / l.w;\r\n\t\t\t\t\tpred.h = l.biases[2 * n + 1] / l.h;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpred.x = 0;\r\n\t\t\t\tpred.y = 0;\r\n\t\t\t\tfloat iou = box_iou(pred, truth_shift);\r\n\t\t\t\tif (iou > best_iou) {\r\n\t\t\t\t\tbest_index = index;\r\n\t\t\t\t\tbest_iou = iou;\r\n\t\t\t\t\tbest_n = n;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfloat iou = delta_region_box(truth, l.output, l.biases, best_n, best_index, i, j, l.w, l.h, l.delta, l.coord_scale);\r\n\t\t\tif (iou > .5) recall += 1;\r\n\t\t\tavg_iou += iou;\r\n\r\n\t\t\t/*l.delta[best_index + 4] = iou - l.output[best_index + 4];*/\r\n\t\t\tavg_obj += l.output[best_index + 4];\r\n\t\t\tl.delta[best_index + 4] = l.object_scale * (1 - l.output[best_index + 4]) * logistic_gradient(l.output[best_index + 4]);\r\n\t\t\tif (l.rescore) {\r\n\t\t\t\tl.delta[best_index + 4] = l.object_scale * (iou - l.output[best_index + 4]) * logistic_gradient(l.output[best_index + 4]);\r\n\t\t\t}\r\n\t\t\tint class = state.truth[t * 5 + b * l.truths + 4];\r\n\t\t\tif (l.map) class = l.map[class];\r\n\t\t\tdelta_region_class(l.output, l.delta, best_index + 5, class, l.classes, l.softmax_tree, l.class_scale, &avg_cat);\r\n\t\t\t++count;\r\n\t\t\t++class_count;\r\n\t\t}\r\n\t}\r\n#ifndef SOD_GPU\r\n\tflatten(l.delta, l.w*l.h, size*l.n, l.batch, 0);\r\n#endif\r\n\t*(l.cost) = pow(mag_array(l.delta, l.outputs * l.batch), 2);\r\n}\r\nstatic void backward_region_layer(const layer l, network_state state)\r\n{\r\n\taxpy_cpu(l.batch*l.inputs, 1, l.delta, 1, state.delta, 1);\r\n}\r\nstatic layer make_region_layer(int batch, int w, int h, int n, int classes, int coords)\r\n{\r\n\tlayer l = { 0 };\r\n\tl.type = REGION;\r\n\r\n\tl.n = n;\r\n\tl.batch = batch;\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.classes = classes;\r\n\tl.coords = coords;\r\n\tl.cost = calloc(1, sizeof(float));\r\n\tl.biases = calloc(n * 2, sizeof(float));\r\n\tl.bias_updates = calloc(n * 2, sizeof(float));\r\n\tl.outputs = h * w*n*(classes + coords + 1);\r\n\tl.inputs = l.outputs;\r\n\tl.truths = 30 * (5);\r\n\tl.delta = calloc(batch*l.outputs, sizeof(float));\r\n\tl.output = calloc(batch*l.outputs, sizeof(float));\r\n\tint i;\r\n\tfor (i = 0; i < n * 2; ++i) {\r\n\t\tl.biases[i] = .5;\r\n\t}\r\n\r\n\tl.forward = forward_region_layer;\r\n\tl.backward = backward_region_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_region_layer_gpu;\r\n\tl.backward_gpu = backward_region_layer_gpu;\r\n\tl.output_gpu = cuda_make_array(l.output, batch*l.outputs);\r\n\tl.delta_gpu = cuda_make_array(l.delta, batch*l.outputs);\r\n#endif\r\n\r\n\tsrand(0);\r\n\r\n\treturn l;\r\n}\r\nstatic int *read_map(char *filename)\r\n{\r\n\tint n = 0;\r\n\tint *map = 0;\r\n\tchar *str;\r\n\tFILE *file = fopen(filename, \"r\");\r\n\tif (!file) {\r\n\t\treturn 0;\r\n\t}\r\n\twhile ((str = fgetl(file)) != 0) {\r\n\t\t++n;\r\n\t\tmap = realloc(map, n * sizeof(int));\r\n\t\tmap[n - 1] = atoi(str);\r\n\t}\r\n\treturn map;\r\n}\r\n/* Forward declaration */\r\nstatic tree *read_tree(char *filename);\r\nstatic int parse_region(layer *l, list *options, size_params params)\r\n{\r\n\tint coords = option_find_int(options, \"coords\", 4);\r\n\tint classes = option_find_int(options, \"classes\", 20);\r\n\tint num = option_find_int(options, \"num\", 1);\r\n\r\n\t*l = make_region_layer(params.batch, params.w, params.h, num, classes, coords);\r\n\r\n\tl->log = option_find_int(options, \"log\", 0);\r\n\tl->sqrt = option_find_int(options, \"sqrt\", 0);\r\n\r\n\tl->softmax = option_find_int(options, \"softmax\", 0);\r\n\tl->background = option_find_int(options, \"background\", 0);\r\n\tl->max_boxes = option_find_int(options, \"max\", 30);\r\n\tl->jitter = option_find_float(options, \"jitter\", .2);\r\n\tl->rescore = option_find_int(options, \"rescore\", 0);\r\n\r\n\tl->thresh = option_find_float(options, \"thresh\", .5);\r\n\tl->classfix = option_find_int(options, \"classfix\", 0);\r\n\tl->absolute = option_find_int(options, \"absolute\", 0);\r\n\tl->random = option_find_int(options, \"random\", 0);\r\n\r\n\tl->coord_scale = option_find_float(options, \"coord_scale\", 1);\r\n\tl->object_scale = option_find_float(options, \"object_scale\", 1);\r\n\tl->noobject_scale = option_find_float(options, \"noobject_scale\", 1);\r\n\tl->mask_scale = option_find_float(options, \"mask_scale\", 1);\r\n\tl->class_scale = option_find_float(options, \"class_scale\", 1);\r\n\tl->bias_match = option_find_int(options, \"bias_match\", 0);\r\n\r\n\tchar *tree_file = option_find_str(options, \"tree\", 0);\r\n\tif (tree_file) l->softmax_tree = read_tree(tree_file);\r\n\tchar *map_file = option_find_str(options, \"map\", 0);\r\n\tif (map_file) l->map = read_map(map_file);\r\n\r\n\tchar *a = option_find_str(options, \"anchors\", 0);\r\n\tif (a) {\r\n\t\tint len = (int)strlen(a);\r\n\t\tint n = 1;\r\n\t\tint i;\r\n\t\tfor (i = 0; i < len; ++i) {\r\n\t\t\tif (a[i] == ',') ++n;\r\n\t\t}\r\n\t\tfor (i = 0; i < n; ++i) {\r\n\t\t\tfloat bias = atof(a);\r\n\t\t\tl->biases[i] = bias;\r\n\t\t\ta = strchr(a, ',') + 1;\r\n\t\t}\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== Detection  =============================================================== */\r\ntypedef layer detection_layer;\r\n\r\nstatic void forward_detection_layer(const detection_layer l, network_state state)\r\n{\r\n\tint locations = l.side*l.side;\r\n\tint i, j;\r\n\tint b;\r\n\tmemcpy(l.output, state.input, l.outputs*l.batch * sizeof(float));\r\n\t/*if(l.reorg) reorg(l.output, l.w*l.h, size*l.n, l.batch, 1);*/\r\n\r\n\tif (l.softmax) {\r\n\t\tfor (b = 0; b < l.batch; ++b) {\r\n\t\t\tint index = b * l.inputs;\r\n\t\t\tfor (i = 0; i < locations; ++i) {\r\n\t\t\t\tint offset = i * l.classes;\r\n\t\t\t\tsoftmax(l.output + index + offset, l.classes, 1,\r\n\t\t\t\t\tl.output + index + offset);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (state.train) {\r\n\t\tfloat avg_iou = 0;\r\n\t\tfloat avg_cat = 0;\r\n\t\tfloat avg_allcat = 0;\r\n\t\tfloat avg_obj = 0;\r\n\t\tfloat avg_anyobj = 0;\r\n\t\tint count = 0;\r\n\t\tint size = l.inputs * l.batch;\r\n\t\t*(l.cost) = 0;\r\n\r\n\t\tmemset(l.delta, 0, size * sizeof(float));\r\n\t\tfor (b = 0; b < l.batch; ++b) {\r\n\t\t\tint index = b * l.inputs;\r\n\t\t\tfor (i = 0; i < locations; ++i) {\r\n\t\t\t\tint truth_index = (b*locations + i)*(1 + l.coords + l.classes);\r\n\t\t\t\tint is_obj = state.truth[truth_index];\r\n\t\t\t\tint best_index;\r\n\t\t\t\tfloat best_iou;\r\n\t\t\t\tfloat best_rmse;\r\n\t\t\t\tint class_index;\r\n\t\t\t\tbox truth;\r\n\t\t\t\tfor (j = 0; j < l.n; ++j) {\r\n\t\t\t\t\tint p_index = index + locations * l.classes + i * l.n + j;\r\n\t\t\t\t\tl.delta[p_index] = l.noobject_scale*(0 - l.output[p_index]);\r\n\t\t\t\t\t*(l.cost) += l.noobject_scale*pow(l.output[p_index], 2);\r\n\t\t\t\t\tavg_anyobj += l.output[p_index];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbest_index = -1;\r\n\t\t\t\tbest_iou = 0;\r\n\t\t\t\tbest_rmse = 20;\r\n\r\n\t\t\t\tif (!is_obj) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclass_index = index + i * l.classes;\r\n\t\t\t\tfor (j = 0; j < l.classes; ++j) {\r\n\t\t\t\t\tl.delta[class_index + j] = l.class_scale * (state.truth[truth_index + 1 + j] - l.output[class_index + j]);\r\n\t\t\t\t\t*(l.cost) += l.class_scale * pow(state.truth[truth_index + 1 + j] - l.output[class_index + j], 2);\r\n\t\t\t\t\tif (state.truth[truth_index + 1 + j]) avg_cat += l.output[class_index + j];\r\n\t\t\t\t\tavg_allcat += l.output[class_index + j];\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttruth = float_to_box(state.truth + truth_index + 1 + l.classes);\r\n\t\t\t\ttruth.x /= l.side;\r\n\t\t\t\ttruth.y /= l.side;\r\n\r\n\t\t\t\tfor (j = 0; j < l.n; ++j) {\r\n\t\t\t\t\tfloat iou;\r\n\t\t\t\t\tfloat rmse;\r\n\t\t\t\t\tint box_index = index + locations * (l.classes + l.n) + (i*l.n + j) * l.coords;\r\n\t\t\t\t\tbox out = float_to_box(l.output + box_index);\r\n\t\t\t\t\tout.x /= l.side;\r\n\t\t\t\t\tout.y /= l.side;\r\n\r\n\t\t\t\t\tif (l.sqrt) {\r\n\t\t\t\t\t\tout.w = out.w*out.w;\r\n\t\t\t\t\t\tout.h = out.h*out.h;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tiou = box_iou(out, truth);\r\n\r\n\t\t\t\t\trmse = box_rmse(out, truth);\r\n\t\t\t\t\tif (best_iou > 0 || iou > 0) {\r\n\t\t\t\t\t\tif (iou > best_iou) {\r\n\t\t\t\t\t\t\tbest_iou = iou;\r\n\t\t\t\t\t\t\tbest_index = j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif (rmse < best_rmse) {\r\n\t\t\t\t\t\t\tbest_rmse = rmse;\r\n\t\t\t\t\t\t\tbest_index = j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (l.forced) {\r\n\t\t\t\t\tif (truth.w*truth.h < .1) {\r\n\t\t\t\t\t\tbest_index = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tbest_index = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (l.random && *(state.net->seen) < 64000) {\r\n\t\t\t\t\tbest_index = rand() % l.n;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tint box_index = index + locations * (l.classes + l.n) + (i*l.n + best_index) * l.coords;\r\n\t\t\t\tint tbox_index = truth_index + 1 + l.classes;\r\n\r\n\t\t\t\tbox out = float_to_box(l.output + box_index);\r\n\t\t\t\tout.x /= l.side;\r\n\t\t\t\tout.y /= l.side;\r\n\t\t\t\tif (l.sqrt) {\r\n\t\t\t\t\tout.w = out.w*out.w;\r\n\t\t\t\t\tout.h = out.h*out.h;\r\n\t\t\t\t}\r\n\t\t\t\tfloat iou = box_iou(out, truth);\r\n\r\n\t\t\t\tint p_index = index + locations * l.classes + i * l.n + best_index;\r\n\t\t\t\t*(l.cost) -= l.noobject_scale * pow(l.output[p_index], 2);\r\n\t\t\t\t*(l.cost) += l.object_scale * pow(1 - l.output[p_index], 2);\r\n\t\t\t\tavg_obj += l.output[p_index];\r\n\t\t\t\tl.delta[p_index] = l.object_scale * (1. - l.output[p_index]);\r\n\r\n\t\t\t\tif (l.rescore) {\r\n\t\t\t\t\tl.delta[p_index] = l.object_scale * (iou - l.output[p_index]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tl.delta[box_index + 0] = l.coord_scale*(state.truth[tbox_index + 0] - l.output[box_index + 0]);\r\n\t\t\t\tl.delta[box_index + 1] = l.coord_scale*(state.truth[tbox_index + 1] - l.output[box_index + 1]);\r\n\t\t\t\tl.delta[box_index + 2] = l.coord_scale*(state.truth[tbox_index + 2] - l.output[box_index + 2]);\r\n\t\t\t\tl.delta[box_index + 3] = l.coord_scale*(state.truth[tbox_index + 3] - l.output[box_index + 3]);\r\n\t\t\t\tif (l.sqrt) {\r\n\t\t\t\t\tl.delta[box_index + 2] = l.coord_scale*(sqrt(state.truth[tbox_index + 2]) - l.output[box_index + 2]);\r\n\t\t\t\t\tl.delta[box_index + 3] = l.coord_scale*(sqrt(state.truth[tbox_index + 3]) - l.output[box_index + 3]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t*(l.cost) += pow(1 - iou, 2);\r\n\t\t\t\tavg_iou += iou;\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t}\r\n\t\t*(l.cost) = pow(mag_array(l.delta, l.outputs * l.batch), 2);\r\n\r\n\t\t/*if(l.reorg) reorg(l.delta, l.w*l.h, size*l.n, l.batch, 0);*/\r\n\t}\r\n}\r\nstatic void backward_detection_layer(const detection_layer l, network_state state)\r\n{\r\n\taxpy_cpu(l.batch*l.inputs, 1, l.delta, 1, state.delta, 1);\r\n}\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void forward_detection_layer_gpu(const detection_layer l, network_state state)\r\n{\r\n\tif (!state.train) {\r\n\t\tcopy_ongpu(l.batch*l.inputs, state.input, 1, l.output_gpu, 1);\r\n\t\treturn;\r\n\t}\r\n\r\n\tfloat *in_cpu = calloc(l.batch*l.inputs, sizeof(float));\r\n\tfloat *truth_cpu = 0;\r\n\tif (state.truth) {\r\n\t\tint num_truth = l.batch*l.side*l.side*(1 + l.coords + l.classes);\r\n\t\ttruth_cpu = calloc(num_truth, sizeof(float));\r\n\t\tcuda_pull_array(state.truth, truth_cpu, num_truth);\r\n\t}\r\n\tcuda_pull_array(state.input, in_cpu, l.batch*l.inputs);\r\n\tnetwork_state cpu_state = state;\r\n\tcpu_state.train = state.train;\r\n\tcpu_state.truth = truth_cpu;\r\n\tcpu_state.input = in_cpu;\r\n\tforward_detection_layer(l, cpu_state);\r\n\tcuda_push_array(l.output_gpu, l.output, l.batch*l.outputs);\r\n\tcuda_push_array(l.delta_gpu, l.delta, l.batch*l.inputs);\r\n\tfree(cpu_state.input);\r\n\tif (cpu_state.truth) free(cpu_state.truth);\r\n}\r\nstatic void backward_detection_layer_gpu(detection_layer l, network_state state)\r\n{\r\n\taxpy_ongpu(l.batch*l.inputs, 1, l.delta_gpu, 1, state.delta, 1);\r\n\t/*copy_ongpu(l.batch*l.inputs, l.delta_gpu, 1, state.delta, 1);*/\r\n}\r\n#endif\r\nstatic void get_detection_boxes(layer l, int w, int h, float thresh, float **probs, box *boxes, int only_objectness)\r\n{\r\n\tint i, j, n;\r\n\tfloat *predictions = l.output;\r\n\r\n\tfor (i = 0; i < l.side*l.side; ++i) {\r\n\t\tint row = i / l.side;\r\n\t\tint col = i % l.side;\r\n\t\tfor (n = 0; n < l.n; ++n) {\r\n\t\t\tint index = i * l.n + n;\r\n\t\t\tint p_index = l.side*l.side*l.classes + i * l.n + n;\r\n\t\t\tfloat scale = predictions[p_index];\r\n\t\t\tint box_index = l.side*l.side*(l.classes + l.n) + (i*l.n + n) * 4;\r\n\t\t\tboxes[index].x = (predictions[box_index + 0] + col) / l.side * w;\r\n\t\t\tboxes[index].y = (predictions[box_index + 1] + row) / l.side * h;\r\n\t\t\tboxes[index].w = pow(predictions[box_index + 2], (l.sqrt ? 2 : 1)) * w;\r\n\t\t\tboxes[index].h = pow(predictions[box_index + 3], (l.sqrt ? 2 : 1)) * h;\r\n\t\t\tfor (j = 0; j < l.classes; ++j) {\r\n\t\t\t\tint class_index = i * l.classes;\r\n\t\t\t\tfloat prob = scale * predictions[class_index + j];\r\n\t\t\t\tprobs[index][j] = (prob > thresh) ? prob : 0;\r\n\t\t\t}\r\n\t\t\tif (only_objectness) {\r\n\t\t\t\tprobs[index][0] = scale;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic detection_layer make_detection_layer(int batch, int inputs, int n, int side, int classes, int coords, int rescore)\r\n{\r\n\tdetection_layer l = { 0 };\r\n\tl.type = DETECTION;\r\n\r\n\tl.n = n;\r\n\tl.batch = batch;\r\n\tl.inputs = inputs;\r\n\tl.classes = classes;\r\n\tl.coords = coords;\r\n\tl.rescore = rescore;\r\n\tl.side = side;\r\n\tl.w = side;\r\n\tl.h = side;\r\n\r\n\tl.cost = calloc(1, sizeof(float));\r\n\tl.outputs = l.inputs;\r\n\tl.truths = l.side*l.side*(1 + l.coords + l.classes);\r\n\tl.output = calloc(batch*l.outputs, sizeof(float));\r\n\tl.delta = calloc(batch*l.outputs, sizeof(float));\r\n\r\n\tl.forward = forward_detection_layer;\r\n\tl.backward = backward_detection_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_detection_layer_gpu;\r\n\tl.backward_gpu = backward_detection_layer_gpu;\r\n\tl.output_gpu = cuda_make_array(l.output, batch*l.outputs);\r\n\tl.delta_gpu = cuda_make_array(l.delta, batch*l.outputs);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_detection(detection_layer *l, list *options, size_params params)\r\n{\r\n\tint coords = option_find_int(options, \"coords\", 1);\r\n\tint classes = option_find_int(options, \"classes\", 1);\r\n\tint rescore = option_find_int(options, \"rescore\", 0);\r\n\tint num = option_find_int(options, \"num\", 1);\r\n\tint side = option_find_int(options, \"side\", 7);\r\n\t*l = make_detection_layer(params.batch, params.inputs, num, side, classes, coords, rescore);\r\n\r\n\tl->softmax = option_find_int(options, \"softmax\", 0);\r\n\tl->sqrt = option_find_int(options, \"sqrt\", 0);\r\n\r\n\tl->max_boxes = option_find_int(options, \"max\", 30);\r\n\tl->coord_scale = option_find_float(options, \"coord_scale\", 1);\r\n\tl->forced = option_find_int(options, \"forced\", 0);\r\n\tl->object_scale = option_find_float(options, \"object_scale\", 1);\r\n\tl->noobject_scale = option_find_float(options, \"noobject_scale\", 1);\r\n\tl->class_scale = option_find_float(options, \"class_scale\", 1);\r\n\tl->jitter = option_find_float(options, \"jitter\", .2);\r\n\tl->random = option_find_int(options, \"random\", 0);\r\n\tl->reorg = option_find_int(options, \"reorg\", 0);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== Softmax  =============================================================== */\r\nstatic tree *read_tree(char *filename)\r\n{\r\n\ttree t = { 0 };\r\n\tFILE *fp = fopen(filename, \"r\");\r\n\r\n\tchar *line;\r\n\tint last_parent = -1;\r\n\tint group_size = 0;\r\n\tint groups = 0;\r\n\tint n = 0;\r\n\twhile ((line = fgetl(fp)) != 0) {\r\n\t\tchar *id = calloc(256, sizeof(char));\r\n\t\tint parent = -1;\r\n\t\tsscanf(line, \"%255s %d\", id, &parent);\r\n\t\tt.parent = realloc(t.parent, (n + 1) * sizeof(int));\r\n\t\tt.parent[n] = parent;\r\n\r\n\t\tt.child = realloc(t.child, (n + 1) * sizeof(int));\r\n\t\tt.child[n] = -1;\r\n\r\n\t\tt.name = realloc(t.name, (n + 1) * sizeof(char *));\r\n\t\tt.name[n] = id;\r\n\t\tif (parent != last_parent) {\r\n\t\t\t++groups;\r\n\t\t\tt.group_offset = realloc(t.group_offset, groups * sizeof(int));\r\n\t\t\tt.group_offset[groups - 1] = n - group_size;\r\n\t\t\tt.group_size = realloc(t.group_size, groups * sizeof(int));\r\n\t\t\tt.group_size[groups - 1] = group_size;\r\n\t\t\tgroup_size = 0;\r\n\t\t\tlast_parent = parent;\r\n\t\t}\r\n\t\tt.group = realloc(t.group, (n + 1) * sizeof(int));\r\n\t\tt.group[n] = groups;\r\n\t\tif (parent >= 0) {\r\n\t\t\tt.child[parent] = groups;\r\n\t\t}\r\n\t\t++n;\r\n\t\t++group_size;\r\n\t}\r\n\t++groups;\r\n\tt.group_offset = realloc(t.group_offset, groups * sizeof(int));\r\n\tt.group_offset[groups - 1] = n - group_size;\r\n\tt.group_size = realloc(t.group_size, groups * sizeof(int));\r\n\tt.group_size[groups - 1] = group_size;\r\n\tt.n = n;\r\n\tt.groups = groups;\r\n\tt.leaf = calloc(n, sizeof(int));\r\n\tint i;\r\n\tfor (i = 0; i < n; ++i) t.leaf[i] = 1;\r\n\tfor (i = 0; i < n; ++i) if (t.parent[i] >= 0) t.leaf[t.parent[i]] = 0;\r\n\r\n\tfclose(fp);\r\n\ttree *tree_ptr = calloc(1, sizeof(tree));\r\n\t*tree_ptr = t;\r\n\r\n\treturn tree_ptr;\r\n}\r\nstatic int parse_softmax(softmax_layer *l, list *options, size_params params)\r\n{\r\n\tint groups = option_find_int(options, \"groups\", 1);\r\n\t*l = make_softmax_layer(params.batch, params.inputs, groups);\r\n\tl->temperature = option_find_float(options, \"temperature\", 1);\r\n\tchar *tree_file = option_find_str(options, \"tree\", 0);\r\n\tif (tree_file) l->softmax_tree = read_tree(tree_file);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== Normalization  =============================================================== */\r\nstatic void forward_normalization_layer(const layer layer, network_state state)\r\n{\r\n\tint k, b;\r\n\tint w = layer.w;\r\n\tint h = layer.h;\r\n\tint c = layer.c;\r\n\tscal_cpu(w*h*c*layer.batch, 0, layer.squared, 1);\r\n\r\n\tfor (b = 0; b < layer.batch; ++b) {\r\n\t\tfloat *squared = layer.squared + w * h*c*b;\r\n\t\tfloat *norms = layer.norms + w * h*c*b;\r\n\t\tfloat *input = state.input + w * h*c*b;\r\n\t\tpow_cpu(w*h*c, 2, input, 1, squared, 1);\r\n\r\n\t\tconst_cpu(w*h, layer.kappa, norms, 1);\r\n\t\tfor (k = 0; k < layer.size / 2; ++k) {\r\n\t\t\taxpy_cpu(w*h, layer.alpha, squared + w * h*k, 1, norms, 1);\r\n\t\t}\r\n\r\n\t\tfor (k = 1; k < layer.c; ++k) {\r\n\t\t\tcopy_cpu(w*h, norms + w * h*(k - 1), 1, norms + w * h*k, 1);\r\n\t\t\tint prev = k - ((layer.size - 1) / 2) - 1;\r\n\t\t\tint next = k + (layer.size / 2);\r\n\t\t\tif (prev >= 0)      axpy_cpu(w*h, -layer.alpha, squared + w * h*prev, 1, norms + w * h*k, 1);\r\n\t\t\tif (next < layer.c) axpy_cpu(w*h, layer.alpha, squared + w * h*next, 1, norms + w * h*k, 1);\r\n\t\t}\r\n\t}\r\n\tpow_cpu(w*h*c*layer.batch, -layer.beta, layer.norms, 1, layer.output, 1);\r\n\tmul_cpu(w*h*c*layer.batch, state.input, 1, layer.output, 1);\r\n}\r\nstatic void backward_normalization_layer(const layer layer, network_state state)\r\n{\r\n\t/* TODO This is approximate ;-)\r\n\t* Also this should add in to delta instead of overwritting.\r\n\t*/\r\n\tint w = layer.w;\r\n\tint h = layer.h;\r\n\tint c = layer.c;\r\n\tpow_cpu(w*h*c*layer.batch, -layer.beta, layer.norms, 1, state.delta, 1);\r\n\tmul_cpu(w*h*c*layer.batch, layer.delta, 1, state.delta, 1);\r\n}\r\n\r\n#if 0 /* SOD_GPU */\r\nvoid forward_normalization_layer_gpu(const layer layer, network_state state)\r\n{\r\n\tint k, b;\r\n\tint w = layer.w;\r\n\tint h = layer.h;\r\n\tint c = layer.c;\r\n\tscal_ongpu(w*h*c*layer.batch, 0, layer.squared_gpu, 1);\r\n\r\n\tfor (b = 0; b < layer.batch; ++b) {\r\n\t\tfloat *squared = layer.squared_gpu + w * h*c*b;\r\n\t\tfloat *norms = layer.norms_gpu + w * h*c*b;\r\n\t\tfloat *input = state.input + w * h*c*b;\r\n\t\tpow_ongpu(w*h*c, 2, input, 1, squared, 1);\r\n\r\n\t\tconst_ongpu(w*h, layer.kappa, norms, 1);\r\n\t\tfor (k = 0; k < layer.size / 2; ++k) {\r\n\t\t\taxpy_ongpu(w*h, layer.alpha, squared + w * h*k, 1, norms, 1);\r\n\t\t}\r\n\r\n\t\tfor (k = 1; k < layer.c; ++k) {\r\n\t\t\tcopy_ongpu(w*h, norms + w * h*(k - 1), 1, norms + w * h*k, 1);\r\n\t\t\tint prev = k - ((layer.size - 1) / 2) - 1;\r\n\t\t\tint next = k + (layer.size / 2);\r\n\t\t\tif (prev >= 0)      axpy_ongpu(w*h, -layer.alpha, squared + w * h*prev, 1, norms + w * h*k, 1);\r\n\t\t\tif (next < layer.c) axpy_ongpu(w*h, layer.alpha, squared + w * h*next, 1, norms + w * h*k, 1);\r\n\t\t}\r\n\t}\r\n\tpow_ongpu(w*h*c*layer.batch, -layer.beta, layer.norms_gpu, 1, layer.output_gpu, 1);\r\n\tmul_ongpu(w*h*c*layer.batch, state.input, 1, layer.output_gpu, 1);\r\n}\r\n\r\nvoid backward_normalization_layer_gpu(const layer layer, network_state state)\r\n{\r\n\t// TODO This is approximate ;-)\r\n\r\n\tint w = layer.w;\r\n\tint h = layer.h;\r\n\tint c = layer.c;\r\n\tpow_ongpu(w*h*c*layer.batch, -layer.beta, layer.norms_gpu, 1, state.delta, 1);\r\n\tmul_ongpu(w*h*c*layer.batch, layer.delta_gpu, 1, state.delta, 1);\r\n}\r\n#endif\r\nstatic layer make_normalization_layer(int batch, int w, int h, int c, int size, float alpha, float beta, float kappa)\r\n{\r\n\tlayer layer = { 0 };\r\n\tlayer.type = NORMALIZATION;\r\n\tlayer.batch = batch;\r\n\tlayer.h = layer.out_h = h;\r\n\tlayer.w = layer.out_w = w;\r\n\tlayer.c = layer.out_c = c;\r\n\tlayer.kappa = kappa;\r\n\tlayer.size = size;\r\n\tlayer.alpha = alpha;\r\n\tlayer.beta = beta;\r\n\tlayer.output = calloc(h * w * c * batch, sizeof(float));\r\n\tlayer.delta = calloc(h * w * c * batch, sizeof(float));\r\n\tlayer.squared = calloc(h * w * c * batch, sizeof(float));\r\n\tlayer.norms = calloc(h * w * c * batch, sizeof(float));\r\n\tlayer.inputs = w * h*c;\r\n\tlayer.outputs = layer.inputs;\r\n\r\n\tlayer.forward = forward_normalization_layer;\r\n\tlayer.backward = backward_normalization_layer;\r\n#if 0 /* SOD_GPU */\r\n\tlayer.forward_gpu = forward_normalization_layer_gpu;\r\n\tlayer.backward_gpu = backward_normalization_layer_gpu;\r\n\r\n\tlayer.output_gpu = cuda_make_array(layer.output, h * w * c * batch);\r\n\tlayer.delta_gpu = cuda_make_array(layer.delta, h * w * c * batch);\r\n\tlayer.squared_gpu = cuda_make_array(layer.squared, h * w * c * batch);\r\n\tlayer.norms_gpu = cuda_make_array(layer.norms, h * w * c * batch);\r\n#endif\r\n\treturn layer;\r\n}\r\nstatic int parse_normalization(layer *l, list *options, size_params params)\r\n{\r\n\tfloat alpha = option_find_float(options, \"alpha\", .0001);\r\n\tfloat beta = option_find_float(options, \"beta\", .75);\r\n\tfloat kappa = option_find_float(options, \"kappa\", 1);\r\n\tint size = option_find_int(options, \"size\", 5);\r\n\t*l = make_normalization_layer(params.batch, params.w, params.h, params.c, size, alpha, beta, kappa);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== BATCHNORM  =============================================================== */\r\n#if 0 /* SOD_GPU */\r\n\r\nstatic void pull_batchnorm_layer(layer l)\r\n{\r\n\tcuda_pull_array(l.scales_gpu, l.scales, l.c);\r\n\tcuda_pull_array(l.rolling_mean_gpu, l.rolling_mean, l.c);\r\n\tcuda_pull_array(l.rolling_variance_gpu, l.rolling_variance, l.c);\r\n}\r\nstatic void push_batchnorm_layer(layer l)\r\n{\r\n\tcuda_push_array(l.scales_gpu, l.scales, l.c);\r\n\tcuda_push_array(l.rolling_mean_gpu, l.rolling_mean, l.c);\r\n\tcuda_push_array(l.rolling_variance_gpu, l.rolling_variance, l.c);\r\n}\r\nstatic void forward_batchnorm_layer_gpu(layer l, network_state state)\r\n{\r\n\tif (l.type == BATCHNORM) copy_ongpu(l.outputs*l.batch, state.input, 1, l.output_gpu, 1);\r\n\tif (l.type == CONNECTED) {\r\n\t\tl.out_c = l.outputs;\r\n\t\tl.out_h = l.out_w = 1;\r\n\t}\r\n\tif (state.train) {\r\n\t\tfast_mean_gpu(l.output_gpu, l.batch, l.out_c, l.out_h*l.out_w, l.mean_gpu);\r\n\t\tfast_variance_gpu(l.output_gpu, l.mean_gpu, l.batch, l.out_c, l.out_h*l.out_w, l.variance_gpu);\r\n\r\n\t\tscal_ongpu(l.out_c, .99, l.rolling_mean_gpu, 1);\r\n\t\taxpy_ongpu(l.out_c, .01, l.mean_gpu, 1, l.rolling_mean_gpu, 1);\r\n\t\tscal_ongpu(l.out_c, .99, l.rolling_variance_gpu, 1);\r\n\t\taxpy_ongpu(l.out_c, .01, l.variance_gpu, 1, l.rolling_variance_gpu, 1);\r\n\r\n\t\tcopy_ongpu(l.outputs*l.batch, l.output_gpu, 1, l.x_gpu, 1);\r\n\t\tnormalize_gpu(l.output_gpu, l.mean_gpu, l.variance_gpu, l.batch, l.out_c, l.out_h*l.out_w);\r\n\t\tcopy_ongpu(l.outputs*l.batch, l.output_gpu, 1, l.x_norm_gpu, 1);\r\n\t}\r\n\telse {\r\n\t\tnormalize_gpu(l.output_gpu, l.rolling_mean_gpu, l.rolling_variance_gpu, l.batch, l.out_c, l.out_h*l.out_w);\r\n\t}\r\n\r\n\tscale_bias_gpu(l.output_gpu, l.scales_gpu, l.batch, l.out_c, l.out_h*l.out_w);\r\n}\r\nstatic void backward_batchnorm_layer_gpu(const layer l, network_state state)\r\n{\r\n\tbackward_scale_gpu(l.x_norm_gpu, l.delta_gpu, l.batch, l.out_c, l.out_w*l.out_h, l.scale_updates_gpu);\r\n\r\n\tscale_bias_gpu(l.delta_gpu, l.scales_gpu, l.batch, l.out_c, l.out_h*l.out_w);\r\n\r\n\tfast_mean_delta_gpu(l.delta_gpu, l.variance_gpu, l.batch, l.out_c, l.out_w*l.out_h, l.mean_delta_gpu);\r\n\tfast_variance_delta_gpu(l.x_gpu, l.delta_gpu, l.mean_gpu, l.variance_gpu, l.batch, l.out_c, l.out_w*l.out_h, l.variance_delta_gpu);\r\n\tnormalize_delta_gpu(l.x_gpu, l.mean_gpu, l.variance_gpu, l.mean_delta_gpu, l.variance_delta_gpu, l.batch, l.out_c, l.out_w*l.out_h, l.delta_gpu);\r\n\tif (l.type == BATCHNORM) copy_ongpu(l.outputs*l.batch, l.delta_gpu, 1, state.delta, 1);\r\n}\r\n#endif\r\nstatic layer make_batchnorm_layer(int batch, int w, int h, int c)\r\n{\r\n\tlayer layer = { 0 };\r\n\tlayer.type = BATCHNORM;\r\n\tlayer.batch = batch;\r\n\tlayer.h = layer.out_h = h;\r\n\tlayer.w = layer.out_w = w;\r\n\tlayer.c = layer.out_c = c;\r\n\tlayer.output = calloc(h * w * c * batch, sizeof(float));\r\n\tlayer.delta = calloc(h * w * c * batch, sizeof(float));\r\n\tlayer.inputs = w * h*c;\r\n\tlayer.outputs = layer.inputs;\r\n\r\n\tlayer.scales = calloc(c, sizeof(float));\r\n\tlayer.scale_updates = calloc(c, sizeof(float));\r\n\tint i;\r\n\tfor (i = 0; i < c; ++i) {\r\n\t\tlayer.scales[i] = 1;\r\n\t}\r\n\r\n\tlayer.mean = calloc(c, sizeof(float));\r\n\tlayer.variance = calloc(c, sizeof(float));\r\n\r\n\tlayer.rolling_mean = calloc(c, sizeof(float));\r\n\tlayer.rolling_variance = calloc(c, sizeof(float));\r\n\r\n\tlayer.forward = forward_batchnorm_layer;\r\n\tlayer.backward = backward_batchnorm_layer;\r\n#if 0 /* SOD_GPU */\r\n\tlayer.forward_gpu = forward_batchnorm_layer_gpu;\r\n\tlayer.backward_gpu = backward_batchnorm_layer_gpu;\r\n\r\n\tlayer.output_gpu = cuda_make_array(layer.output, h * w * c * batch);\r\n\tlayer.delta_gpu = cuda_make_array(layer.delta, h * w * c * batch);\r\n\r\n\tlayer.scales_gpu = cuda_make_array(layer.scales, c);\r\n\tlayer.scale_updates_gpu = cuda_make_array(layer.scale_updates, c);\r\n\r\n\tlayer.mean_gpu = cuda_make_array(layer.mean, c);\r\n\tlayer.variance_gpu = cuda_make_array(layer.variance, c);\r\n\r\n\tlayer.rolling_mean_gpu = cuda_make_array(layer.mean, c);\r\n\tlayer.rolling_variance_gpu = cuda_make_array(layer.variance, c);\r\n\r\n\tlayer.mean_delta_gpu = cuda_make_array(layer.mean, c);\r\n\tlayer.variance_delta_gpu = cuda_make_array(layer.variance, c);\r\n\r\n\tlayer.x_gpu = cuda_make_array(layer.output, layer.batch*layer.outputs);\r\n\tlayer.x_norm_gpu = cuda_make_array(layer.output, layer.batch*layer.outputs);\r\n#endif\r\n\treturn layer;\r\n}\r\nstatic int parse_batchnorm(layer *l, list *options, size_params params)\r\n{\r\n\t(void)options; /* cc warn on unused var */\r\n\t*l = make_batchnorm_layer(params.batch, params.w, params.h, params.c);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== MAXPOOL  =============================================================== */\r\ntypedef layer maxpool_layer;\r\nstatic void forward_maxpool_layer(const maxpool_layer l, network_state state)\r\n{\r\n\tint b, i, j, k, m, n;\r\n\tint w_offset = -l.pad;\r\n\tint h_offset = -l.pad;\r\n\r\n\tint h = l.out_h;\r\n\tint w = l.out_w;\r\n\tint c = l.c;\r\n\r\n\tfor (b = 0; b < l.batch; ++b) {\r\n\t\tfor (k = 0; k < c; ++k) {\r\n\t\t\tfor (i = 0; i < h; ++i) {\r\n\t\t\t\tfor (j = 0; j < w; ++j) {\r\n\t\t\t\t\tint out_index = j + w * (i + h * (k + c * b));\r\n\t\t\t\t\tfloat max = -FLT_MAX;\r\n\t\t\t\t\tint max_i = -1;\r\n\t\t\t\t\tfor (n = 0; n < l.size; ++n) {\r\n\t\t\t\t\t\tfor (m = 0; m < l.size; ++m) {\r\n\t\t\t\t\t\t\tint cur_h = h_offset + i * l.stride + n;\r\n\t\t\t\t\t\t\tint cur_w = w_offset + j * l.stride + m;\r\n\t\t\t\t\t\t\tint index = cur_w + l.w*(cur_h + l.h*(k + b * l.c));\r\n\t\t\t\t\t\t\tint valid = (cur_h >= 0 && cur_h < l.h &&\r\n\t\t\t\t\t\t\t\tcur_w >= 0 && cur_w < l.w);\r\n\t\t\t\t\t\t\tfloat val = (valid != 0) ? state.input[index] : -FLT_MAX;\r\n\t\t\t\t\t\t\tmax_i = (val > max) ? index : max_i;\r\n\t\t\t\t\t\t\tmax = (val > max) ? val : max;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tl.output[out_index] = max;\r\n\t\t\t\t\tl.indexes[out_index] = max_i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void backward_maxpool_layer(const maxpool_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tint h = l.out_h;\r\n\tint w = l.out_w;\r\n\tint c = l.c;\r\n\tfor (i = 0; i < h*w*c*l.batch; ++i) {\r\n\t\tint index = l.indexes[i];\r\n\t\tstate.delta[index] += l.delta[i];\r\n\t}\r\n}\r\nstatic maxpool_layer make_maxpool_layer(int batch, int h, int w, int c, int size, int stride, int padding)\r\n{\r\n\tmaxpool_layer l = { 0 };\r\n\tl.type = MAXPOOL;\r\n\tl.batch = batch;\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tl.pad = padding;\r\n\tl.out_w = (w + 2 * padding) / stride;\r\n\tl.out_h = (h + 2 * padding) / stride;\r\n\tl.out_c = c;\r\n\tl.outputs = l.out_h * l.out_w * l.out_c;\r\n\tl.inputs = h * w*c;\r\n\tl.size = size;\r\n\tl.stride = stride;\r\n\tint output_size = l.out_h * l.out_w * l.out_c * batch;\r\n\tl.indexes = calloc(output_size, sizeof(int));\r\n\tl.output = calloc(output_size, sizeof(float));\r\n\tl.delta = calloc(output_size, sizeof(float));\r\n\tl.forward = forward_maxpool_layer;\r\n\tl.backward = backward_maxpool_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_maxpool_layer_gpu;\r\n\tl.backward_gpu = backward_maxpool_layer_gpu;\r\n\tl.indexes_gpu = cuda_make_int_array(output_size);\r\n\tl.output_gpu = cuda_make_array(l.output, output_size);\r\n\tl.delta_gpu = cuda_make_array(l.delta, output_size);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_maxpool(maxpool_layer *l, list *options, size_params params, sod_cnn *pNet)\r\n{\r\n\tint stride = option_find_int(options, \"stride\", 1);\r\n\tint size = option_find_int(options, \"size\", stride);\r\n\tint padding = option_find_int(options, \"padding\", (size - 1) / 2);\r\n\r\n\tint batch, h, w, c;\r\n\th = params.h;\r\n\tw = params.w;\r\n\tc = params.c;\r\n\tbatch = params.batch;\r\n\tif (!(h && w && c)) {\r\n\t\tpNet->zErr = \"Layer before maxpool layer must output image.\";\r\n\t\tpNet->nErr++;\r\n\t\treturn -1;\r\n\t}\r\n\t*l = make_maxpool_layer(batch, h, w, c, size, stride, padding);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== REORG =============================================================== */\r\nstatic void forward_reorg_layer(const layer l, network_state state)\r\n{\r\n\tif (l.reverse) {\r\n\t\treorg_cpu(state.input, l.w, l.h, l.c, l.batch, l.stride, 1, l.output);\r\n\t}\r\n\telse {\r\n\t\treorg_cpu(state.input, l.w, l.h, l.c, l.batch, l.stride, 0, l.output);\r\n\t}\r\n}\r\nstatic void backward_reorg_layer(const layer l, network_state state)\r\n{\r\n\tif (l.reverse) {\r\n\t\treorg_cpu(l.delta, l.w, l.h, l.c, l.batch, l.stride, 0, state.delta);\r\n\t}\r\n\telse {\r\n\t\treorg_cpu(l.delta, l.w, l.h, l.c, l.batch, l.stride, 1, state.delta);\r\n\t}\r\n}\r\n#if 0 /* SOD_GPU */\r\nstatic void forward_reorg_layer_gpu(layer l, network_state state)\r\n{\r\n\tif (l.reverse) {\r\n\t\treorg_ongpu(state.input, l.w, l.h, l.c, l.batch, l.stride, 1, l.output_gpu);\r\n\t}\r\n\telse {\r\n\t\treorg_ongpu(state.input, l.w, l.h, l.c, l.batch, l.stride, 0, l.output_gpu);\r\n\t}\r\n}\r\nstatic void backward_reorg_layer_gpu(layer l, network_state state)\r\n{\r\n\tif (l.reverse) {\r\n\t\treorg_ongpu(l.delta_gpu, l.w, l.h, l.c, l.batch, l.stride, 0, state.delta);\r\n\t}\r\n\telse {\r\n\t\treorg_ongpu(l.delta_gpu, l.w, l.h, l.c, l.batch, l.stride, 1, state.delta);\r\n\t}\r\n}\r\n#endif\r\nstatic layer make_reorg_layer(int batch, int w, int h, int c, int stride, int reverse)\r\n{\r\n\tlayer l = { 0 };\r\n\tl.type = REORG;\r\n\tl.batch = batch;\r\n\tl.stride = stride;\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tif (reverse) {\r\n\t\tl.out_w = w * stride;\r\n\t\tl.out_h = h * stride;\r\n\t\tl.out_c = c / (stride*stride);\r\n\t}\r\n\telse {\r\n\t\tl.out_w = w / stride;\r\n\t\tl.out_h = h / stride;\r\n\t\tl.out_c = c * (stride*stride);\r\n\t}\r\n\tl.reverse = reverse;\r\n\r\n\tl.outputs = l.out_h * l.out_w * l.out_c;\r\n\tl.inputs = h * w*c;\r\n\tint output_size = l.out_h * l.out_w * l.out_c * batch;\r\n\tl.output = calloc(output_size, sizeof(float));\r\n\tl.delta = calloc(output_size, sizeof(float));\r\n\r\n\tl.forward = forward_reorg_layer;\r\n\tl.backward = backward_reorg_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_reorg_layer_gpu;\r\n\tl.backward_gpu = backward_reorg_layer_gpu;\r\n\r\n\tl.output_gpu = cuda_make_array(l.output, output_size);\r\n\tl.delta_gpu = cuda_make_array(l.delta, output_size);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_reorg(layer *l, list *options, size_params params, sod_cnn *pNet)\r\n{\r\n\tint stride = option_find_int(options, \"stride\", 1);\r\n\tint reverse = option_find_int(options, \"reverse\", 0);\r\n\r\n\tint batch, h, w, c;\r\n\th = params.h;\r\n\tw = params.w;\r\n\tc = params.c;\r\n\tbatch = params.batch;\r\n\tif (!(h && w && c)) {\r\n\t\tpNet->zErr = \"Layer before reorg layer must output image.\";\r\n\t\tpNet->nErr++;\r\n\t\treturn -1;\r\n\t}\r\n\t*l = make_reorg_layer(batch, w, h, c, stride, reverse);\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== AVGPOOL =============================================================== */\r\ntypedef layer avgpool_layer;\r\nstatic void forward_avgpool_layer(const avgpool_layer l, network_state state)\r\n{\r\n\tint b, i, k;\r\n\r\n\tfor (b = 0; b < l.batch; ++b) {\r\n\t\tfor (k = 0; k < l.c; ++k) {\r\n\t\t\tint out_index = k + b * l.c;\r\n\t\t\tl.output[out_index] = 0;\r\n\t\t\tfor (i = 0; i < l.h*l.w; ++i) {\r\n\t\t\t\tint in_index = i + l.h*l.w*(k + b * l.c);\r\n\t\t\t\tl.output[out_index] += state.input[in_index];\r\n\t\t\t}\r\n\t\t\tl.output[out_index] /= l.h*l.w;\r\n\t\t}\r\n\t}\r\n}\r\nstatic void backward_avgpool_layer(const avgpool_layer l, network_state state)\r\n{\r\n\tint b, i, k;\r\n\r\n\tfor (b = 0; b < l.batch; ++b) {\r\n\t\tfor (k = 0; k < l.c; ++k) {\r\n\t\t\tint out_index = k + b * l.c;\r\n\t\t\tfor (i = 0; i < l.h*l.w; ++i) {\r\n\t\t\t\tint in_index = i + l.h*l.w*(k + b * l.c);\r\n\t\t\t\tstate.delta[in_index] += l.delta[out_index] / (l.h*l.w);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic avgpool_layer make_avgpool_layer(int batch, int w, int h, int c)\r\n{\r\n\tavgpool_layer l = { 0 };\r\n\tl.type = AVGPOOL;\r\n\tl.batch = batch;\r\n\tl.h = h;\r\n\tl.w = w;\r\n\tl.c = c;\r\n\tl.out_w = 1;\r\n\tl.out_h = 1;\r\n\tl.out_c = c;\r\n\tl.outputs = l.out_c;\r\n\tl.inputs = h * w*c;\r\n\tint output_size = l.outputs * batch;\r\n\tl.output = calloc(output_size, sizeof(float));\r\n\tl.delta = calloc(output_size, sizeof(float));\r\n\tl.forward = forward_avgpool_layer;\r\n\tl.backward = backward_avgpool_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_avgpool_layer_gpu;\r\n\tl.backward_gpu = backward_avgpool_layer_gpu;\r\n\tl.output_gpu = cuda_make_array(l.output, output_size);\r\n\tl.delta_gpu = cuda_make_array(l.delta, output_size);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_avgpool(avgpool_layer *l, list *options, size_params params, sod_cnn *pNet)\r\n{\r\n\tint batch, w, h, c;\r\n\tw = params.w;\r\n\th = params.h;\r\n\tc = params.c;\r\n\tbatch = params.batch;\r\n\tif (!(h && w && c)) {\r\n\t\tpNet->zErr = \"Layer before avgpool layer must output image.\";\r\n\t\tpNet->nErr++;\r\n\t\toptions = 0; /* cc warn on unused var */\r\n\t\treturn -1;\r\n\t}\r\n\t*l = make_avgpool_layer(batch, w, h, c);\r\n\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== ROUTE =============================================================== */\r\ntypedef layer route_layer;\r\nstatic void forward_route_layer(const route_layer l, network_state state)\r\n{\r\n\tint i, j;\r\n\tint offset = 0;\r\n\tfor (i = 0; i < l.n; ++i) {\r\n\t\tint index = l.input_layers[i];\r\n\t\tfloat *input = state.net->layers[index].output;\r\n\t\tint input_size = l.input_sizes[i];\r\n\t\tfor (j = 0; j < l.batch; ++j) {\r\n\t\t\tcopy_cpu(input_size, input + j * input_size, 1, l.output + offset + j * l.outputs, 1);\r\n\t\t}\r\n\t\toffset += input_size;\r\n\t}\r\n}\r\nstatic void backward_route_layer(const route_layer l, network_state state)\r\n{\r\n\tint i, j;\r\n\tint offset = 0;\r\n\tfor (i = 0; i < l.n; ++i) {\r\n\t\tint index = l.input_layers[i];\r\n\t\tfloat *delta = state.net->layers[index].delta;\r\n\t\tint input_size = l.input_sizes[i];\r\n\t\tfor (j = 0; j < l.batch; ++j) {\r\n\t\t\taxpy_cpu(input_size, 1, l.delta + offset + j * l.outputs, 1, delta + j * input_size, 1);\r\n\t\t}\r\n\t\toffset += input_size;\r\n\t}\r\n}\r\n#if 0 /* SOD_GPU */\r\nstatic void forward_route_layer_gpu(const route_layer l, network_state state)\r\n{\r\n\tint i, j;\r\n\tint offset = 0;\r\n\tfor (i = 0; i < l.n; ++i) {\r\n\t\tint index = l.input_layers[i];\r\n\t\tfloat *input = state.net.layers[index].output_gpu;\r\n\t\tint input_size = l.input_sizes[i];\r\n\t\tfor (j = 0; j < l.batch; ++j) {\r\n\t\t\tcopy_ongpu(input_size, input + j * input_size, 1, l.output_gpu + offset + j * l.outputs, 1);\r\n\t\t}\r\n\t\toffset += input_size;\r\n\t}\r\n}\r\nstatic void backward_route_layer_gpu(const route_layer l, network_state state)\r\n{\r\n\tint i, j;\r\n\tint offset = 0;\r\n\tfor (i = 0; i < l.n; ++i) {\r\n\t\tint index = l.input_layers[i];\r\n\t\tfloat *delta = state.net.layers[index].delta_gpu;\r\n\t\tint input_size = l.input_sizes[i];\r\n\t\tfor (j = 0; j < l.batch; ++j) {\r\n\t\t\taxpy_ongpu(input_size, 1, l.delta_gpu + offset + j * l.outputs, 1, delta + j * input_size, 1);\r\n\t\t}\r\n\t\toffset += input_size;\r\n\t}\r\n}\r\n#endif\r\nstatic route_layer make_route_layer(int batch, int n, int *input_layers, int *input_sizes)\r\n{\r\n\r\n\troute_layer l = { 0 };\r\n\tl.type = ROUTE;\r\n\tl.batch = batch;\r\n\tl.n = n;\r\n\tl.input_layers = input_layers;\r\n\tl.input_sizes = input_sizes;\r\n\tint i;\r\n\tint outputs = 0;\r\n\tfor (i = 0; i < n; ++i) {\r\n\r\n\t\toutputs += input_sizes[i];\r\n\t}\r\n\r\n\tl.outputs = outputs;\r\n\tl.inputs = outputs;\r\n\tl.delta = calloc(outputs*batch, sizeof(float));\r\n\tl.output = calloc(outputs*batch, sizeof(float));;\r\n\r\n\tl.forward = forward_route_layer;\r\n\tl.backward = backward_route_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_route_layer_gpu;\r\n\tl.backward_gpu = backward_route_layer_gpu;\r\n\r\n\tl.delta_gpu = cuda_make_array(l.delta, outputs*batch);\r\n\tl.output_gpu = cuda_make_array(l.output, outputs*batch);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_route(route_layer *lr, list *options, size_params params, network *net, sod_cnn *pNet)\r\n{\r\n\tchar *l = option_find(options, \"layers\");\r\n\tif (!l) {\r\n\t\tpNet->zErr = \"Route Layer must specify input layers\";\r\n\t\tpNet->nErr++;\r\n\t\treturn -1;\r\n\t}\r\n\tint len = (int)strlen(l);\r\n\tint n = 1;\r\n\tint i;\r\n\tfor (i = 0; i < len; ++i) {\r\n\t\tif (l[i] == ',') ++n;\r\n\t}\r\n\r\n\tint *layers = calloc(n, sizeof(int));\r\n\tint *sizes = calloc(n, sizeof(int));\r\n\tfor (i = 0; i < n; ++i) {\r\n\t\tint index = atoi(l);\r\n\t\tl = strchr(l, ',') + 1;\r\n\t\tif (index < 0) index = params.index + index;\r\n\t\tlayers[i] = index;\r\n\t\tsizes[i] = net->layers[index].outputs;\r\n\t}\r\n\tint batch = params.batch;\r\n\r\n\troute_layer layer = make_route_layer(batch, n, layers, sizes);\r\n\r\n\tconvolutional_layer first = net->layers[layers[0]];\r\n\tlayer.out_w = first.out_w;\r\n\tlayer.out_h = first.out_h;\r\n\tlayer.out_c = first.out_c;\r\n\tfor (i = 1; i < n; ++i) {\r\n\t\tint index = layers[i];\r\n\t\tconvolutional_layer next = net->layers[index];\r\n\t\tif (next.out_w == first.out_w && next.out_h == first.out_h) {\r\n\t\t\tlayer.out_c += next.out_c;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlayer.out_h = layer.out_w = layer.out_c = 0;\r\n\t\t}\r\n\t}\r\n\t*lr = layer;\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== SHORTCUT =============================================================== */\r\nstatic void forward_shortcut_layer(const layer l, network_state state)\r\n{\r\n\tcopy_cpu(l.outputs*l.batch, state.input, 1, l.output, 1);\r\n\tshortcut_cpu(l.batch, l.w, l.h, l.c, state.net->layers[l.index].output, l.out_w, l.out_h, l.out_c, l.output);\r\n\tactivate_array(l.output, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_shortcut_layer(const layer l, network_state state)\r\n{\r\n\tgradient_array(l.output, l.outputs*l.batch, l.activation, l.delta);\r\n\taxpy_cpu(l.outputs*l.batch, 1, l.delta, 1, state.delta, 1);\r\n\tshortcut_cpu(l.batch, l.out_w, l.out_h, l.out_c, l.delta, l.w, l.h, l.c, state.net->layers[l.index].delta);\r\n}\r\n\r\n#if 0 /* SOD_GPU */\r\nstatic void forward_shortcut_layer_gpu(const layer l, network_state state)\r\n{\r\n\tcopy_ongpu(l.outputs*l.batch, state.input, 1, l.output_gpu, 1);\r\n\tshortcut_gpu(l.batch, l.w, l.h, l.c, state.net.layers[l.index].output_gpu, l.out_w, l.out_h, l.out_c, l.output_gpu);\r\n\tactivate_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation);\r\n}\r\nstatic void backward_shortcut_layer_gpu(const layer l, network_state state)\r\n{\r\n\tgradient_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation, l.delta_gpu);\r\n\taxpy_ongpu(l.outputs*l.batch, 1, l.delta_gpu, 1, state.delta, 1);\r\n\tshortcut_gpu(l.batch, l.out_w, l.out_h, l.out_c, l.delta_gpu, l.w, l.h, l.c, state.net.layers[l.index].delta_gpu);\r\n}\r\n#endif\r\nstatic layer make_shortcut_layer(int batch, int index, int w, int h, int c, int w2, int h2, int c2)\r\n{\r\n\tlayer l = { 0 };\r\n\tl.type = SHORTCUT;\r\n\tl.batch = batch;\r\n\tl.w = w2;\r\n\tl.h = h2;\r\n\tl.c = c2;\r\n\tl.out_w = w;\r\n\tl.out_h = h;\r\n\tl.out_c = c;\r\n\tl.outputs = w * h*c;\r\n\tl.inputs = l.outputs;\r\n\r\n\tl.index = index;\r\n\r\n\tl.delta = calloc(l.outputs*batch, sizeof(float));\r\n\tl.output = calloc(l.outputs*batch, sizeof(float));;\r\n\r\n\tl.forward = forward_shortcut_layer;\r\n\tl.backward = backward_shortcut_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_shortcut_layer_gpu;\r\n\tl.backward_gpu = backward_shortcut_layer_gpu;\r\n\r\n\tl.delta_gpu = cuda_make_array(l.delta, l.outputs*batch);\r\n\tl.output_gpu = cuda_make_array(l.output, l.outputs*batch);\r\n#endif\r\n\treturn l;\r\n}\r\nstatic int parse_shortcut(layer *rl, list *options, size_params params, network *net)\r\n{\r\n\tchar *l = option_find(options, \"from\");\r\n\tint index = atoi(l);\r\n\tif (index < 0) index = params.index + index;\r\n\r\n\tint batch = params.batch;\r\n\tlayer from = net->layers[index];\r\n\r\n\t*rl = make_shortcut_layer(batch, index, params.w, params.h, params.c, from.out_w, from.out_h, from.out_c);\r\n\trl->activation = get_activation(option_find_str(options, \"activation\", \"linear\"));\r\n\r\n\treturn SOD_OK;\r\n}\r\n/* =============================================================== DROPOUT =============================================================== */\r\ntypedef layer dropout_layer;\r\nstatic void forward_dropout_layer(dropout_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tif (!state.train) return;\r\n\tfor (i = 0; i < l.batch * l.inputs; ++i) {\r\n\t\tfloat r = rand_uniform(0, 1);\r\n\t\tl.rand[i] = r;\r\n\t\tif (r < l.probability) state.input[i] = 0;\r\n\t\telse state.input[i] *= l.scale;\r\n\t}\r\n}\r\nstatic void backward_dropout_layer(dropout_layer l, network_state state)\r\n{\r\n\tint i;\r\n\tif (!state.delta) return;\r\n\tfor (i = 0; i < l.batch * l.inputs; ++i) {\r\n\t\tfloat r = l.rand[i];\r\n\t\tif (r < l.probability) state.delta[i] = 0;\r\n\t\telse state.delta[i] *= l.scale;\r\n\t}\r\n}\r\nstatic dropout_layer make_dropout_layer(int batch, int inputs, float probability)\r\n{\r\n\tdropout_layer l = { 0 };\r\n\tl.type = DROPOUT;\r\n\tl.probability = probability;\r\n\tl.inputs = inputs;\r\n\tl.outputs = inputs;\r\n\tl.batch = batch;\r\n\tl.rand = calloc(inputs*batch, sizeof(float));\r\n\tl.scale = 1. / (1. - probability);\r\n\tl.forward = forward_dropout_layer;\r\n\tl.backward = backward_dropout_layer;\r\n#if 0 /* SOD_GPU */\r\n\tl.forward_gpu = forward_dropout_layer_gpu;\r\n\tl.backward_gpu = backward_dropout_layer_gpu;\r\n\tl.rand_gpu = cuda_make_array(l.rand, inputs*batch);\r\n#endif\r\n\r\n\treturn l;\r\n}\r\nstatic int parse_dropout(dropout_layer *l, list *options, size_params params)\r\n{\r\n\tfloat probability = option_find_float(options, \"probability\", .5);\r\n\t*l = make_dropout_layer(params.batch, params.inputs, probability);\r\n\tl->out_w = params.w;\r\n\tl->out_h = params.h;\r\n\tl->out_c = params.c;\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Network architecture Parser & Processor.\r\n*/\r\nstatic int parse_network_cfg(const char *zConf, sod_cnn *pNet)\r\n{\r\n\tlist *sections = read_cfg(zConf);\r\n\tnode *n = sections->front;\r\n\tnetwork net;\r\n\tsize_params params;\r\n\tsection *s;\r\n\tlist *options;\r\n\tlayer l;\r\n\r\n\tif (!n) {\r\n\t\tpNet->nErr++;\r\n\t\tpNet->zErr = \"Model has no sections\";\r\n\t\tfree_list(sections);\r\n\t\treturn SOD_UNSUPPORTED;\r\n\t}\r\n\tmake_network(sections->size - 1, &net);\r\n\tnet.pNet = pNet;\r\n\tnet.gpu_index = 0;\r\n\r\n\ts = (section *)n->val;\r\n\toptions = s->options;\r\n\tif (!is_network(s)) {\r\n\t\tpNet->nErr++;\r\n\t\tpNet->zErr = \"First section must be [net] or [network]\";\r\n\t\tfree_section(s);\r\n\t\tfree_list(sections);\r\n\t\treturn -1;\r\n\t}\r\n\tparse_net_options(options, &net);\r\n\r\n\tparams.h = net.h;\r\n\tparams.w = net.w;\r\n\tparams.c = net.c;\r\n\tparams.inputs = net.inputs;\r\n\tparams.batch = net.batch;\r\n\tparams.time_steps = net.time_steps;\r\n\tparams.net = net;\r\n\r\n\tsize_t workspace_size = 0;\r\n\tn = n->next;\r\n\tint count = 0;\r\n\tfree_section(s);\r\n\r\n\twhile (n) {\r\n\t\tmemset(&l, 0, sizeof(layer));\r\n\t\tparams.index = count;\r\n\t\ts = (section *)n->val;\r\n\t\toptions = s->options;\r\n\r\n\t\tSOD_CNN_LAYER_TYPE lt = string_to_layer_type(s->type);\r\n\t\tswitch (lt) {\r\n\t\tcase CONVOLUTIONAL: {\r\n\t\t\tparse_convolutional(&l, options, params, pNet);\r\n\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\tcase LOCAL: {\r\n\t\t\tparse_local(&l, options, params, pNet);\r\n\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\tcase ACTIVE: {\r\n\t\t\tparse_activation(&l, options, params);\r\n\t\t}\r\n\t\t\t\t\t break;\r\n\t\tcase RNN: {\r\n\t\t\tparse_rnn(&l, options, params);\r\n\t\t\tpNet->flags |= SOD_LAYER_RNN;\r\n\t\t}\r\n\t\t\t\t  break;\r\n\t\tcase GRU: {\r\n\t\t\tparse_gru(&l, options, params);\r\n\t\t}\r\n\t\t\t\t  break;\r\n\t\tcase CRNN: {\r\n\t\t\tparse_crnn(&l, options, params);\r\n\t\t}\r\n\t\t\t\t   break;\r\n\t\tcase CONNECTED: {\r\n\t\t\tparse_connected(&l, options, params);\r\n\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\tcase CROP: {\r\n\t\t\tparse_crop(&l, options, params, pNet);\r\n\t\t}\r\n\t\t\t\t   break;\r\n\t\tcase COST: {\r\n\t\t\tparse_cost(&l, options, params);\r\n\t\t}\r\n\t\t\t\t   break;\r\n\t\tcase REGION: {\r\n\t\t\tparse_region(&l, options, params);\r\n\t\t}\r\n\t\t\t\t\t break;\r\n\t\tcase DETECTION: {\r\n\t\t\tparse_detection(&l, options, params);\r\n\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\tcase SOFTMAX: {\r\n\t\t\tparse_softmax(&l, options, params);\r\n\t\t\tnet.hierarchy = l.softmax_tree;\r\n\t\t}\r\n\t\t\t\t\t  break;\r\n\t\tcase NORMALIZATION: {\r\n\t\t\tparse_normalization(&l, options, params);\r\n\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\tcase BATCHNORM: {\r\n\t\t\tparse_batchnorm(&l, options, params);\r\n\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\tcase MAXPOOL: {\r\n\t\t\tparse_maxpool(&l, options, params, pNet);\r\n\t\t}\r\n\t\t\t\t\t  break;\r\n\t\tcase REORG: {\r\n\t\t\tparse_reorg(&l, options, params, pNet);\r\n\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\tcase AVGPOOL: {\r\n\t\t\tparse_avgpool(&l, options, params, pNet);\r\n\t\t}\r\n\t\t\t\t\t  break;\r\n\t\tcase ROUTE: {\r\n\t\t\tparse_route(&l, options, params, &net, pNet);\r\n\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\tcase SHORTCUT: {\r\n\t\t\tparse_shortcut(&l, options, params, &net);\r\n\t\t}\r\n\t\t\t\t\t   break;\r\n\t\tcase DROPOUT: {\r\n\t\t\tparse_dropout(&l, options, params);\r\n\t\t\tl.output = net.layers[count - 1].output;\r\n\t\t\tl.delta = net.layers[count - 1].delta;\r\n#if 0 /* SOD_GPU */\r\n\t\t\tl.output_gpu = net.layers[count - 1].output_gpu;\r\n\t\t\tl.delta_gpu = net.layers[count - 1].delta_gpu;\r\n#endif\r\n\t\t}\r\n\t\t\t\t\t  break;\r\n\t\tdefault:\r\n\t\t\t/* Unknown layer, simply ignore */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tl.dontload = option_find_int(options, \"dontload\", 0);\r\n\t\tl.dontloadscales = option_find_int(options, \"dontloadscales\", 0);\r\n\t\tnet.layers[count] = l;\r\n\t\tif (l.workspace_size > workspace_size) workspace_size = l.workspace_size;\r\n\t\tfree_section(s);\r\n\t\tn = n->next;\r\n\t\t++count;\r\n\t\tif (n) {\r\n\t\t\tparams.h = l.out_h;\r\n\t\t\tparams.w = l.out_w;\r\n\t\t\tparams.c = l.out_c;\r\n\t\t\tparams.inputs = l.outputs;\r\n\t\t}\r\n\t}\r\n\tfree_list(sections);\r\n\tnet.outputs = get_network_output_size(&net);\r\n\tnet.output = get_network_output(&net);\r\n\tnet.workspace_size = workspace_size;\r\n\tif (workspace_size) {\r\n#if 0 /* SOD_GPU */\r\n\t\tif (gpu_index >= 0) {\r\n\t\t\tnet.workspace = cuda_make_array(0, (workspace_size - 1) / sizeof(float) + 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnet.workspace = calloc(1, workspace_size);\r\n\t\t}\r\n#else\r\n\t\tnet.workspace = calloc(1, workspace_size);\r\n#endif\r\n\t}\r\n\tpNet->net = net;\r\n\treturn pNet->nErr > 0 ? SOD_ABORT : SOD_OK;\r\n}\r\n/*\r\n* Convolutional/Recurrent Neural Networks (CNN/RNN) Exported Interfaces.\r\n*/\r\n/*\r\n* Each magic word is defined by an instance of the following structure.\r\n*/\r\nstruct sod_cnn_magic\r\n{\r\n\tconst char *zMagic; /* Magic work */\r\n\tconst char *zModel; /* Associated model */\r\n\tconst char **azNameSet; /* Class names */\r\n};\r\n/*\r\n* Seed a RNN network.\r\n*/\r\nstatic void prepare_rnn_seed(sod_cnn *pNet, int len) {\r\n\tint i;\r\n\tfor (i = 0; i < len - 1; ++i) {\r\n\t\tpNet->c_rnn = pNet->zRnnSeed[i];\r\n\t\tpNet->aInput[pNet->c_rnn] = 1;\r\n\t\tnetwork_predict(&pNet->net, pNet->aInput);\r\n\t\tpNet->aInput[pNet->c_rnn] = 0;\r\n\t}\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nint sod_cnn_create(sod_cnn **ppOut, const char *zArch, const char *zModelPath, const char **pzErr)\r\n{\r\n\tsod_cnn *pNet = malloc(sizeof(sod_cnn));\r\n\tvoid *pMap = 0;\r\n\tsize_t sz;\r\n\tint rc, j;\r\n\tif (pNet == 0 || zArch == 0 || zArch[0] == 0) {\r\n\t\tif (pzErr) {\r\n\t\t\t*pzErr = \"Out of Memory/Empty network architecture\";\r\n\t\t}\r\n\t\t*ppOut = 0;\r\n\t\tfree(pNet);\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\t*ppOut = pNet;\r\n\t/* Zero */\r\n\tmemset(pNet, 0, sizeof(sod_cnn));\r\n\t/* Export the built-in VFS */\r\n\tpNet->pVfs = sodExportBuiltinVfs();\r\n\tsrand((unsigned int)pNet->pVfs->xTicks());\r\n\t/* Check if we are dealing with a memory buffer or with a file path */\r\n\twhile (isspace(zArch[0])) zArch++;\r\n\t/* Assume a null terminated memory buffer by default */\r\n\tsz = strlen(zArch);\r\n\tif (zArch[0] == ':') {\r\n\t\t/* Magic word */\r\n\t\tstatic const struct sod_cnn_magic aMagic[] = {\r\n\t\t\t{ \"fast\",  zTinyVoc, zVoc },\r\n\t\t\t{ \"voc\",  zTinyVoc, zVoc },\r\n\t\t\t{ \"tiny80\", zTiny, zCoco },\r\n\t\t\t{ \"coco\", zTiny, zCoco },\r\n\t\t\t{ \"tiny\", zTiny, zCoco },\r\n\t\t\t{ \"full\", zYolo,   zCoco },\r\n\t\t\t{ \"yolo\", zYolo,   zCoco },\r\n\t\t\t{ \"face\", zfaceCnn, zFace },\r\n\t\t\t{ \"rnn\",  zRnn,     0 },\r\n\t\t\t{ 0, 0, 0 } /* Marker */\r\n\t\t};\r\n\t\tfor (j = 0; aMagic[j].zMagic != 0; j++) {\r\n\t\t\tif (sy_strcmp(aMagic[j].zMagic, &zArch[1]) == 0) {\r\n\t\t\t\tzArch = aMagic[j].zModel;\r\n\t\t\t\tpNet->azNames = aMagic[j].azNameSet;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (aMagic[j].zModel == 0) {\r\n\t\t\tif (pzErr) *pzErr = \"No such model for the given magic keyword\";\r\n\t\t\t*ppOut = 0;\r\n\t\t\tfree(pNet);\r\n\t\t\treturn SOD_UNSUPPORTED;\r\n\t\t}\r\n\t}\r\n\telse if (zArch[0] != '[' || zArch[0] != '#' || sz < 170) {\r\n\t\t/* Assume a file path, open read-only  */\r\n\t\trc = pNet->pVfs->xMmap(zArch, &pMap, &sz);\r\n\t\tif (rc != SOD_OK) {\r\n\t\t\tif (pzErr) *pzErr = \"Error loading network architecture file\";\r\n\t\t\t*ppOut = 0;\r\n\t\t\tfree(pNet);\r\n\t\t\treturn SOD_IOERR;\r\n\t\t}\r\n\t\tzArch = (const char *)pMap;\r\n\t}\r\n\t/* Parse the network architecture */\r\n\trc = parse_network_cfg(zArch, pNet);\r\n\tif (pMap) {\r\n\t\tpNet->pVfs->xUnmap((void *)zArch, (int64_t)sz);\r\n\t}\r\n\tif (rc != SOD_OK) {\r\n\t\tgoto fail;\r\n\t}\r\n\tif (zModelPath) {\r\n\t\trc = load_weights(&pNet->net, zModelPath);\r\n\t\tif (rc != SOD_OK) {\r\n\t\t\tgoto fail;\r\n\t\t}\r\n\t}\r\n\t/* Fill with default configuration */\r\n\tSySetInit(&pNet->aBoxes, sizeof(sod_box));\r\n\tSySetAlloc(&pNet->aBoxes, 8);\r\n\tSyBlobInit(&pNet->sRnnConsumer);\r\n\tSyBlobInit(&pNet->sLogConsumer);\r\n\tpNet->det = pNet->net.layers[pNet->net.n - 1];\r\n\tif ((pNet->flags & SOD_LAYER_RNN) == 0) {\r\n\t\tset_batch_network(&pNet->net, 1);\r\n\t}\r\n\tpNet->nInput = get_network_input_size(&pNet->net);\r\n\tpNet->nms = .45;\r\n\tpNet->thresh = .24;\r\n\tpNet->hier_thresh = .5;\r\n\tpNet->temp = .7;\r\n#define S_RNN_SEED \"\\n\\n\"\r\n\tpNet->zRnnSeed = S_RNN_SEED;\r\n\tpNet->rnn_gen_len = 100;\r\n\tif (pNet->det.classes > 0) {\r\n\t\tpNet->sRz = sod_make_image(pNet->net.w, pNet->net.h, pNet->net.c);\r\n\t\tif (pNet->det.type == REGION || pNet->det.type == DETECTION) {\r\n\t\t\tpNet->boxes = calloc(pNet->det.w*pNet->det.h*pNet->det.n, sizeof(box));\r\n\t\t}\r\n\t\tpNet->probs = calloc(pNet->det.w*pNet->det.h*pNet->det.n, sizeof(float *));\r\n\t\tfor (j = 0; j < pNet->det.w*pNet->det.h*pNet->det.n; ++j) pNet->probs[j] = calloc(pNet->det.classes + 1, sizeof(float));\r\n\t}\r\n\tif (pNet->flags & SOD_LAYER_RNN) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < pNet->net.n; ++i) {\r\n\t\t\tpNet->net.layers[i].temperature = pNet->temp;\r\n\t\t}\r\n\t\tpNet->aInput = (float *)calloc(pNet->nInput, sizeof(float));\r\n\t\t/*prepare_rnn_seed(pNet, sizeof(S_RNN_SEED) - 1);*/\r\n\t\tpNet->c_rnn = pNet->zRnnSeed[sizeof(S_RNN_SEED) - 2];\r\n\t}\r\n\tpNet->state = SOD_NET_STATE_READY;\r\n\treturn SOD_OK;\r\nfail:\r\n\tif (pzErr) {\r\n\t\t*pzErr = pNet->zErr ? pNet->zErr : \"Invalid network model\";\r\n\t}\r\n\t*ppOut = 0;\r\n\tfree_network(&pNet->net);\r\n\tfree(pNet);\r\n#ifdef SOD_MEM_DEBUG\r\n\t_CrtDumpMemoryLeaks();\r\n#endif /* SOD_MEM_DEBUG */\r\n\treturn rc;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nint sod_cnn_config(sod_cnn * pNet, SOD_CNN_CONFIG conf, ...)\r\n{\r\n\tint rc = SOD_OK;\r\n\tva_list ap;\r\n\tva_start(ap, conf);\r\n\tswitch (conf) {\r\n\tcase SOD_CNN_NETWORK_OUTPUT: {\r\n\t\tfloat **vector = va_arg(ap, float **);\r\n\t\tint *pCount = va_arg(ap, int *);\r\n\t\t*vector = pNet->pOut;\r\n\t\tif (pCount) {\r\n\t\t\t*pCount = pNet->nOuput;\r\n\t\t}\r\n\t}\r\n\t\tbreak;\r\n\tcase SOD_CNN_LOG_CALLBACK: {\r\n\t\t/* Log callback */\r\n\t\tProcLogCallback xLog = va_arg(ap, ProcLogCallback);\r\n\t\tvoid *pLogData = va_arg(ap, void *);\r\n\t\t/* Register the callback */\r\n\t\tpNet->xLog = xLog;\r\n\t\tpNet->pLogData = pLogData;\r\n\t}\r\n\t\t\tbreak;\r\n\tcase SOD_CNN_DETECTION_THRESHOLD: {\r\n\t\tdouble thresh = va_arg(ap, double);\r\n\t\tpNet->thresh = (float)thresh;\r\n\t}\r\n\t\t\tbreak;\r\n\tcase SOD_CNN_NMS: {\r\n\t\tdouble nms = va_arg(ap, double);\r\n\t\tpNet->nms = (float)nms;\r\n\t}\r\n\t\t\t\t\t\t\t\t\t  break;\r\n\tcase SOD_RNN_CALLBACK: {\r\n\t\t/* RNN callback */\r\n\t\tProcRnnCallback xCB = va_arg(ap, ProcRnnCallback);\r\n\t\tvoid *pUserdata = va_arg(ap, void *);\r\n\t\t/* Register the callback */\r\n\t\tpNet->xRnn = xCB;\r\n\t\tpNet->pRnnData = pUserdata;\r\n\t}\r\n\t\t\t\t\t\t   break;\r\n\tcase SOD_RNN_TEXT_LENGTH:\r\n\tcase SOD_RNN_DATA_LENGTH: {\r\n\t\t/* Maximum text length to be generated */\r\n\t\tint len = va_arg(ap, int);\r\n\t\tif (len > 0) {\r\n\t\t\tpNet->rnn_gen_len = len;\r\n\t\t}\r\n\t}\r\n\t\t\t\t\t\t\t  break;\r\n\tcase SOD_RNN_SEED: {\r\n\t\t/* Seed for the rnn */\r\n\t\tconst char *zSeed = va_arg(ap, const char *); /* Must be null terminated */\r\n\t\tif (zSeed) {\r\n\t\t\tint len = (int)strlen(zSeed);\r\n\t\t\tif (len > 0) {\r\n\t\t\t\tpNet->zRnnSeed = zSeed;\r\n\t\t\t\tprepare_rnn_seed(pNet, len);\r\n\t\t\t\tpNet->c_rnn = pNet->zRnnSeed[len - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\t\t\t\t   break;\r\n\tcase SOD_CNN_TEMPERATURE: {\r\n\t\tdouble temp = va_arg(ap, double);\r\n\t\tint i;\r\n\t\tpNet->temp = (float)temp;\r\n\t\tfor (i = 0; i < pNet->net.n; ++i) {\r\n\t\t\tpNet->net.layers[i].temperature = pNet->temp;\r\n\t\t}\r\n\t}\r\n\t\t\t\t\t\t\t  break;\r\n\tdefault:\r\n\t\trc = SOD_UNSUPPORTED;\r\n\t\tbreak;\r\n\t}\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_cnn_destroy(sod_cnn *pNet)\r\n{\r\n\tif (pNet->state > 0) {\r\n\t\tif (pNet->probs) {\r\n\t\t\tint j;\r\n\t\t\tfor (j = 0; j < pNet->det.w*pNet->det.h*pNet->det.n; ++j) free(pNet->probs[j]);\r\n\t\t\tfree(pNet->probs);\r\n\t\t}\r\n\t\tif (pNet->boxes) {\r\n\t\t\tfree(pNet->boxes);\r\n\t\t}\r\n\t\tif (pNet->aInput) {\r\n\t\t\tfree(pNet->aInput);\r\n\t\t}\r\n\t\tfree_network(&pNet->net);\r\n\t\tSySetRelease(&pNet->aBoxes);\r\n\t\tSyBlobRelease(&pNet->sRnnConsumer);\r\n\t\tSyBlobRelease(&pNet->sLogConsumer);\r\n\t\tsod_free_image(pNet->sTmpim);\r\n\t\tsod_free_image(pNet->sRz);\r\n\t\tsod_free_image(pNet->sPart);\r\n\t\tfree(pNet);\r\n\t}\r\n#ifdef SOD_MEM_DEBUG\r\n\t_CrtDumpMemoryLeaks();\r\n#endif /* SOD_MEM_DEBUG */\r\n}\r\n/* Forward declaration */\r\nstatic void sodFastImageResize(sod_img im, sod_img resized, sod_img part, int w, int h);\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nfloat * sod_cnn_prepare_image(sod_cnn *pNet, sod_img in)\r\n{\r\n\tsod_img *pCur;\r\n\tif (pNet->state != SOD_NET_STATE_READY) {\r\n\t\treturn 0;\r\n\t}\r\n\tif (pNet->net.w < 1 && pNet->net.h < 1) {\r\n\t\t/* Not a detection network */\r\n\t\treturn 0;\r\n\t}\r\n\tif (in.c != pNet->net.c) {\r\n\t\t/* Must comply with the trained channels for this network */\r\n\t\treturn 0;\r\n\t}\r\n\tpNet->ow = in.w;\r\n\tpNet->oh = in.h;\r\n\tpCur = &pNet->sRz;\r\n\tif (in.h != pNet->net.h || in.w != pNet->net.w) {\r\n\t\tsod_md_alloc_dyn_img(pCur, pNet->net.w, pNet->net.h, pNet->net.c);\r\n\t\tsod_md_alloc_dyn_img(&pNet->sPart, pNet->net.w, in.h, pNet->net.c);\r\n\t\tsodFastImageResize(in, pNet->sRz, pNet->sPart, pNet->net.w, pNet->net.h);\r\n\t}\r\n\treturn pCur->data;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nint sod_cnn_get_network_size(sod_cnn * pNet, int * pWidth, int * pHeight, int * pChannels)\r\n{\r\n\tif (pNet->state != SOD_NET_STATE_READY) {\r\n\t\treturn -1;\r\n\t}\r\n\tif (pWidth) *pWidth = pNet->net.w;\r\n\tif (pHeight) *pHeight = pNet->net.h;\r\n\tif (pChannels) *pChannels = pNet->net.c;\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nint sod_cnn_predict(sod_cnn * pNet, float * pInput, sod_box **paBox, int *pnBox)\r\n{\r\n\tint i, j, nRun = 1;\r\n\tif (pNet->flags & SOD_LAYER_RNN) {\r\n\t\tpInput = pNet->aInput;\r\n\t\tnRun = pNet->rnn_gen_len;\r\n\t\tSyBlobReset(&pNet->sRnnConsumer);\r\n\t}\r\n\tfor (i = 0; i < nRun; ++i) {\r\n\t\tif (pNet->flags & SOD_LAYER_RNN) {\r\n\t\t\tpNet->aInput[pNet->c_rnn] = 1;\r\n\t\t}\r\n\t\tpNet->pOut = network_predict(&pNet->net, pInput);\r\n\t\tif (pNet->flags & SOD_LAYER_RNN) {\r\n\t\t\tpNet->aInput[pNet->c_rnn] = 0;\r\n\t\t\tfor (j = 0; j < pNet->nInput; ++j) {\r\n\t\t\t\tif (pNet->pOut[j] < .0001) pNet->pOut[j] = 0;\r\n\t\t\t}\r\n\t\t\tpNet->c_rnn = sample_array(pNet->pOut, pNet->nInput);\r\n\t\t\t/* Append character output */\r\n\t\t\tSyBlobAppend(&pNet->sRnnConsumer, (const void *)&pNet->c_rnn, sizeof(char));\r\n\t\t}\r\n\t}\r\n\tif (pnBox) {\r\n\t\tsod_box sBox;\r\n\t\tSySetReset(&pNet->aBoxes);\r\n\t\tif (pNet->det.classes > 0) {\r\n\t\t\tif (pNet->det.type == REGION) {\r\n\t\t\t\tget_region_boxes(pNet->det, 1, 1, pNet->thresh, pNet->probs, pNet->boxes, 0, 0, pNet->hier_thresh);\r\n\t\t\t\tif (pNet->det.softmax_tree && pNet->nms) {\r\n\t\t\t\t\tdo_nms_obj(pNet->boxes, pNet->probs, pNet->det.w*pNet->det.h*pNet->det.n, pNet->det.classes, pNet->nms);\r\n\t\t\t\t}\r\n\t\t\t\telse if (pNet->nms) {\r\n\t\t\t\t\tdo_nms_sort(pNet->boxes, pNet->probs, pNet->det.w*pNet->det.h*pNet->det.n, pNet->det.classes, pNet->nms);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pNet->det.type == DETECTION) {\r\n\t\t\t\tget_detection_boxes(pNet->det, 1, 1, pNet->thresh, pNet->probs, pNet->boxes, 0);\r\n\t\t\t\tif (pNet->nms) {\r\n\t\t\t\t\tdo_nms_sort(pNet->boxes, pNet->probs, pNet->det.side*pNet->det.side*pNet->det.n, pNet->det.classes, pNet->nms);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < pNet->det.w*pNet->det.h*pNet->det.n; ++i) {\r\n\t\t\t\tfloat max = pNet->probs[i][0];\r\n\t\t\t\tint class = 0, v;\r\n\t\t\t\tfloat prob;\r\n\t\t\t\tfor (v = 1; v < pNet->det.classes; ++v) {\r\n\t\t\t\t\tif (pNet->probs[i][v] > max) {\r\n\t\t\t\t\t\tmax = pNet->probs[i][v];\r\n\t\t\t\t\t\tclass = v;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprob = pNet->probs[i][class];\r\n\t\t\t\tif (prob > pNet->thresh) {\r\n\t\t\t\t\tbox b = pNet->boxes[i];\r\n\t\t\t\t\tint left = (b.x - b.w / 2.)*pNet->ow;\r\n\t\t\t\t\tint top = (b.y - b.h / 2.)*pNet->oh;\r\n\t\t\t\t\tint right = (b.x + b.w / 2.)*pNet->ow;\r\n\t\t\t\t\tint bot = (b.y + b.h / 2.)*pNet->oh;\r\n\t\t\t\t\tif (left < 0) left = 0;\r\n\t\t\t\t\tif (top < 0) top = 0;\r\n\t\t\t\t\tif (right > pNet->ow - 1) right = pNet->ow - 1;\r\n\t\t\t\t\tif (bot > pNet->oh - 1) bot = pNet->oh - 1;\r\n\t\t\t\t\tsBox.score = prob;\r\n\t\t\t\t\tsBox.x = left;\r\n\t\t\t\t\tsBox.y = top;\r\n\t\t\t\t\tsBox.w = right - left;\r\n\t\t\t\t\tsBox.h = bot - top;\r\n\t\t\t\t\tif (pNet->azNames) {\r\n\t\t\t\t\t\t/* WARNING: azNames[] must hold at least n 'class' entries. This is fine with the\r\n\t\t\t\t\t\t* built-in magic words such as :tiny, :full, etc. Otherwise, expect a SEGFAULT.\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t\tsBox.zName = pNet->azNames[class];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsBox.zName = \"object\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsBox.pUserData = 0;\r\n\t\t\t\t\t/* Insert in the set */\r\n\t\t\t\t\tSySetPut(&pNet->aBoxes, &sBox);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (paBox) {\r\n\t\t\t*paBox = (sod_box *)SySetBasePtr(&pNet->aBoxes);\r\n\t\t}\r\n\t\t*pnBox = (int)SySetUsed(&pNet->aBoxes);\r\n\t}\r\n\tif (pNet->flags & SOD_LAYER_RNN) {\r\n\t\tSyBlobNullAppend(&pNet->sRnnConsumer); /* Append the null terminator */\r\n\t\tif (pNet->xRnn) {\r\n\t\t\t/* Run the user callback */\r\n\t\t\tpNet->xRnn((const char *)SyBlobData(&pNet->sRnnConsumer), SyBlobLength(&pNet->sRnnConsumer), pNet->pRnnData);\r\n\t\t}\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n#endif /* SOD_DISABLE_CNN */\r\n/*\r\n* Image Processing Interfaces.\r\n*/\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_make_empty_image(int w, int h, int c)\r\n{\r\n\tsod_img out;\r\n\tout.data = 0;\r\n\tout.h = h;\r\n\tout.w = w;\r\n\tout.c = c;\r\n\treturn out;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_make_image(int w, int h, int c)\r\n{\r\n\tsod_img out = sod_make_empty_image(w, h, c);\r\n\tout.data = calloc(h*w*c, sizeof(float));\r\n\treturn out;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_grow_image(sod_img *pImg, int w, int h, int c)\r\n{\r\n\tsod_md_alloc_dyn_img(&(*pImg), w, h, c);\r\n\treturn pImg->data == 0 ? SOD_OUTOFMEM : SOD_OK;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_make_random_image(int w, int h, int c)\r\n{\r\n\tsod_img out = sod_make_empty_image(w, h, c);\r\n\tout.data = calloc(h*w*c, sizeof(float));\r\n\tif (out.data) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < w*h*c; ++i) {\r\n\t\t\tout.data[i] = (rand_normal() * .25) + .5;\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_img_get_layer(sod_img m, int l)\r\n{\r\n\tsod_img out = sod_make_image(m.w, m.h, 1);\r\n\tint i;\r\n\tif (out.data && l >= 0 && l < m.c) {\r\n\t\tfor (i = 0; i < m.h*m.w; ++i) {\r\n\t\t\tout.data[i] = m.data[i + l * m.h*m.w];\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_copy_image(sod_img m)\r\n{\r\n\tsod_img copy = m;\r\n\tcopy.data = calloc(m.h*m.w*m.c, sizeof(float));\r\n\tif (copy.data && m.data) {\r\n\t\tmemcpy(copy.data, m.data, m.h*m.w*m.c * sizeof(float));\r\n\t}\r\n\treturn copy;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_free_image(sod_img m)\r\n{\r\n\tif (m.data) {\r\n\t\tfree(m.data);\r\n\t}\r\n}\r\nstatic inline float get_pixel(sod_img m, int x, int y, int c)\r\n{\r\n\treturn (m.data ? m.data[c*m.h*m.w + y * m.w + x] : 0.0f);\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nfloat sod_img_get_pixel(sod_img m, int x, int y, int c)\r\n{\r\n\tif (x < 0) x = 0;\r\n\tif (x >= m.w) x = m.w - 1;\r\n\tif (y < 0) y = 0;\r\n\tif (y >= m.h) y = m.h - 1;\r\n\tif (c < 0 || c >= m.c) return 0;\r\n\treturn get_pixel(m, x, y, c);\r\n}\r\nstatic inline void set_pixel(sod_img m, int x, int y, int c, float val)\r\n{\r\n\t/* x, y, c are already validated by upper layers */\r\n\tif (m.data)\r\n\t\tm.data[c*m.h*m.w + y * m.w + x] = val;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_img_set_pixel(sod_img m, int x, int y, int c, float val)\r\n{\r\n\tif (x < 0 || y < 0 || c < 0 || x >= m.w || y >= m.h || c >= m.c) return;\r\n\tset_pixel(m, x, y, c, val);\r\n}\r\nstatic inline void add_pixel(sod_img m, int x, int y, int c, float val)\r\n{\r\n\t/* x, y, c are already validated by upper layers */\r\n\tif (m.data)\r\n\t\tm.data[c*m.h*m.w + y * m.w + x] += val;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_img_add_pixel(sod_img m, int x, int y, int c, float val)\r\n{\r\n\tif (!(x < m.w && y < m.h && c < m.c)) {\r\n\t\treturn;\r\n\t}\r\n\tadd_pixel(m, x, y, c, val);\r\n}\r\nstatic inline float three_way_max(float a, float b, float c)\r\n{\r\n\treturn (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);\r\n}\r\nstatic inline float three_way_min(float a, float b, float c)\r\n{\r\n\treturn (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);\r\n}\r\n/* http://www.cs.rit.edu/~ncs/color/t_convert.html */\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_img_rgb_to_hsv(sod_img im)\r\n{\r\n\tint i, j;\r\n\tfloat r, g, b;\r\n\tfloat h, s, v;\r\n\tif (im.c != 3) {\r\n\t\treturn;\r\n\t}\r\n\tfor (j = 0; j < im.h; ++j) {\r\n\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\tr = get_pixel(im, i, j, 0);\r\n\t\t\tg = get_pixel(im, i, j, 1);\r\n\t\t\tb = get_pixel(im, i, j, 2);\r\n\t\t\tfloat max = three_way_max(r, g, b);\r\n\t\t\tfloat min = three_way_min(r, g, b);\r\n\t\t\tfloat delta = max - min;\r\n\t\t\tv = max;\r\n\t\t\tif (max == 0) {\r\n\t\t\t\ts = 0;\r\n\t\t\t\th = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ts = delta / max;\r\n\t\t\t\tif (r == max) {\r\n\t\t\t\t\th = (g - b) / delta;\r\n\t\t\t\t}\r\n\t\t\t\telse if (g == max) {\r\n\t\t\t\t\th = 2 + (b - r) / delta;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\th = 4 + (r - g) / delta;\r\n\t\t\t\t}\r\n\t\t\t\tif (h < 0) h += 6;\r\n\t\t\t\th = h / 6.;\r\n\t\t\t}\r\n\t\t\tset_pixel(im, i, j, 0, h);\r\n\t\t\tset_pixel(im, i, j, 1, s);\r\n\t\t\tset_pixel(im, i, j, 2, v);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_img_hsv_to_rgb(sod_img im)\r\n{\r\n\tint i, j;\r\n\tfloat r, g, b;\r\n\tfloat h, s, v;\r\n\tfloat f, p, q, t;\r\n\tif (im.c != 3) {\r\n\t\treturn;\r\n\t}\r\n\tfor (j = 0; j < im.h; ++j) {\r\n\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\th = 6 * get_pixel(im, i, j, 0);\r\n\t\t\ts = get_pixel(im, i, j, 1);\r\n\t\t\tv = get_pixel(im, i, j, 2);\r\n\t\t\tif (s == 0) {\r\n\t\t\t\tr = g = b = v;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tint index = floor(h);\r\n\t\t\t\tf = h - index;\r\n\t\t\t\tp = v * (1 - s);\r\n\t\t\t\tq = v * (1 - s * f);\r\n\t\t\t\tt = v * (1 - s * (1 - f));\r\n\t\t\t\tif (index == 0) {\r\n\t\t\t\t\tr = v; g = t; b = p;\r\n\t\t\t\t}\r\n\t\t\t\telse if (index == 1) {\r\n\t\t\t\t\tr = q; g = v; b = p;\r\n\t\t\t\t}\r\n\t\t\t\telse if (index == 2) {\r\n\t\t\t\t\tr = p; g = v; b = t;\r\n\t\t\t\t}\r\n\t\t\t\telse if (index == 3) {\r\n\t\t\t\t\tr = p; g = q; b = v;\r\n\t\t\t\t}\r\n\t\t\t\telse if (index == 4) {\r\n\t\t\t\t\tr = t; g = p; b = v;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tr = v; g = p; b = q;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tset_pixel(im, i, j, 0, r);\r\n\t\t\tset_pixel(im, i, j, 1, g);\r\n\t\t\tset_pixel(im, i, j, 2, b);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_grayscale_image(sod_img im)\r\n{\r\n\tif (im.c != 1) {\r\n\t\tint i, j, k;\r\n\t\tsod_img gray = sod_make_image(im.w, im.h, 1);\r\n\t\tif (gray.data) {\r\n\t\t\tfloat scale[] = { 0.587, 0.299, 0.114 };\r\n\t\t\tfor (k = 0; k < im.c; ++k) {\r\n\t\t\t\tfor (j = 0; j < im.h; ++j) {\r\n\t\t\t\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\t\t\t\tgray.data[i + im.w*j] += scale[k] * get_pixel(im, i, j, k);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn gray;\r\n\t}\r\n\treturn sod_copy_image(im); /* Already grayscaled */\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nvoid sod_grayscale_image_3c(sod_img im)\r\n{\r\n\tif (im.c == 3) {\r\n\t\tint i, j, k;\r\n\t\tfloat scale[] = { 0.299, 0.587, 0.114 };\r\n\t\tfor (j = 0; j < im.h; ++j) {\r\n\t\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\t\tfloat val = 0;\r\n\t\t\t\tfor (k = 0; k < 3; ++k) {\r\n\t\t\t\t\tval += scale[k] * get_pixel(im, i, j, k);\r\n\t\t\t\t}\r\n\t\t\t\tim.data[0 * im.h*im.w + im.w*j + i] = val;\r\n\t\t\t\tim.data[1 * im.h*im.w + im.w*j + i] = val;\r\n\t\t\t\tim.data[2 * im.h*im.w + im.w*j + i] = val;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_threshold_image(sod_img im, float thresh)\r\n{\r\n\tsod_img t = sod_make_image(im.w, im.h, im.c);\r\n\tif (t.data) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < im.w*im.h*im.c; ++i) {\r\n\t\t\tt.data[i] = im.data[i] > thresh ? 1 : 0;\r\n\t\t}\r\n\t}\r\n\treturn t;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_otsu_binarize_image(sod_img im)\r\n{\r\n#define OTSU_GRAYLEVEL 256\r\n\tsod_img t = sod_make_image(im.w, im.h, im.c);\r\n\tif (t.data) {\r\n\t\t/* binarization by Otsu's method based on maximization of inter-class variance */\r\n\t\tint hist[OTSU_GRAYLEVEL];\r\n\t\tdouble prob[OTSU_GRAYLEVEL], omega[OTSU_GRAYLEVEL]; /* prob of graylevels */\r\n\t\tdouble myu[OTSU_GRAYLEVEL];   /* mean value for separation */\r\n\t\tdouble max_sigma, sigma[OTSU_GRAYLEVEL]; /* inter-class variance */\r\n\t\tfloat threshold; /* threshold for binarization */\r\n\t\tint i; /* Loop variable */\r\n\r\n\t\t\t   /* Histogram generation */\r\n\t\tfor (i = 0; i < OTSU_GRAYLEVEL; i++) hist[i] = 0;\r\n\t\tfor (i = 0; i < im.w*im.h*im.c; ++i) {\r\n\t\t\thist[(unsigned char)(255. * im.data[i])]++;\r\n\t\t}\r\n\t\t/* calculation of probability density */\r\n\t\tfor (i = 0; i < OTSU_GRAYLEVEL; i++) {\r\n\t\t\tprob[i] = (double)hist[i] / (im.w * im.h);\r\n\t\t}\r\n\t\tomega[0] = prob[0];\r\n\t\tmyu[0] = 0.0;       /* 0.0 times prob[0] equals zero */\r\n\t\tfor (i = 1; i < OTSU_GRAYLEVEL; i++) {\r\n\t\t\tomega[i] = omega[i - 1] + prob[i];\r\n\t\t\tmyu[i] = myu[i - 1] + i * prob[i];\r\n\t\t}\r\n\r\n\t\t/* sigma maximization\r\n\t\tsigma stands for inter-class variance\r\n\t\tand determines optimal threshold value */\r\n\t\tthreshold = 0.0;\r\n\t\tmax_sigma = 0.0;\r\n\t\tfor (i = 0; i < OTSU_GRAYLEVEL - 1; i++) {\r\n\t\t\tif (omega[i] != 0.0 && omega[i] != 1.0)\r\n\t\t\t\tsigma[i] = pow(myu[OTSU_GRAYLEVEL - 1] * omega[i] - myu[i], 2) /\r\n\t\t\t\t(omega[i] * (1.0 - omega[i]));\r\n\t\t\telse\r\n\t\t\t\tsigma[i] = 0.0;\r\n\t\t\tif (sigma[i] > max_sigma) {\r\n\t\t\t\tmax_sigma = sigma[i];\r\n\t\t\t\tthreshold = (float)i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthreshold /= 255.;\r\n\t\t/* binarization output */\r\n\t\tfor (i = 0; i < im.w*im.h*im.c; ++i) {\r\n\t\t\tt.data[i] = im.data[i] > threshold ? 1 : 0;\r\n\t\t}\r\n\t}\r\n\treturn t;\r\n}\r\n/*\r\n* Taken from the libpipi project. http://caca.zoy.org/browser/libpipi/trunk/pipi/filter/dilate.c\r\n* License: WTFPL\r\n* http://sam.zoy.org/wtfpl/COPYING for more details.\r\n*/\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_dilate_image(sod_img im, int times)\r\n{\r\n\tsod_img out;\r\n\tif (im.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Only grayscale or binary images */\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tout = sod_make_image(im.w, im.h, im.c);\r\n\tif (out.data && im.data) {\r\n\t\tint x, y, w, h;\r\n\t\tfloat *srcdata = im.data;\r\n\t\tfloat *dstdata = out.data;\r\n\t\tfloat *tmp = malloc(im.w*im.h * sizeof(float));\r\n\t\tw = im.w;\r\n\t\th = im.h;\r\n\t\tif (tmp) {\r\n\t\t\twhile (times-- > 0) {\r\n\t\t\t\tfor (y = 0; y < h; y++)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (x = 0; x < w; x++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfloat t;\r\n\t\t\t\t\t\tint x2, y2, x3, y3;\r\n\r\n\t\t\t\t\t\ty2 = y - 1;\r\n\t\t\t\t\t\tif (y2 < 0) y2 = h - 1;\r\n\t\t\t\t\t\ty3 = y + 1;\r\n\t\t\t\t\t\tif (y3 >= h) y3 = 0;\r\n\r\n\t\t\t\t\t\tx2 = x - 1;\r\n\t\t\t\t\t\tif (x2 < 0) x2 = w - 1;\r\n\t\t\t\t\t\tx3 = x + 1;\r\n\t\t\t\t\t\tif (x3 >= w) x3 = 0;\r\n\r\n\r\n\t\t\t\t\t\tt = srcdata[y * w + x];\r\n\t\t\t\t\t\tif (srcdata[y2 * w + x] > t) t = srcdata[y2 * w + x];\r\n\t\t\t\t\t\tif (srcdata[y3 * w + x] > t) t = srcdata[y3 * w + x];\r\n\t\t\t\t\t\tif (srcdata[y * w + x2] > t) t = srcdata[y * w + x2];\r\n\t\t\t\t\t\tif (srcdata[y * w + x3] > t) t = srcdata[y * w + x3];\r\n\t\t\t\t\t\tdstdata[y * w + x] = t;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tmemcpy(tmp, dstdata, w*h * sizeof(float));\r\n\t\t\t\tsrcdata = tmp;\r\n\t\t\t}\r\n\t\t\tfree(tmp);\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n/*\r\n* Taken from the libpipi project. http://caca.zoy.org/browser/libpipi/trunk/pipi/filter/dilate.c\r\n* License: WTFPL\r\n* http://sam.zoy.org/wtfpl/COPYING for more details.\r\n*/\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_erode_image(sod_img im, int times)\r\n{\r\n\tsod_img out;\r\n\tif (im.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Only grayscale or binary images */\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tout = sod_make_image(im.w, im.h, im.c);\r\n\tif (out.data && im.data) {\r\n\t\tint x, y, w, h;\r\n\t\tfloat *srcdata = im.data;\r\n\t\tfloat *dstdata = out.data;\r\n\t\tfloat *tmp = malloc(im.w*im.h * sizeof(float));\r\n\t\tw = im.w;\r\n\t\th = im.h;\r\n\t\tif (tmp) {\r\n\t\t\twhile (times-- > 0) {\r\n\t\t\t\tfor (y = 0; y < h; y++)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (x = 0; x < w; x++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfloat t;\r\n\t\t\t\t\t\tint x2, y2, x3, y3;\r\n\r\n\t\t\t\t\t\ty2 = y - 1;\r\n\t\t\t\t\t\tif (y2 < 0) y2 = h - 1;\r\n\t\t\t\t\t\ty3 = y + 1;\r\n\t\t\t\t\t\tif (y3 >= h) y3 = 0;\r\n\r\n\t\t\t\t\t\tx2 = x - 1;\r\n\t\t\t\t\t\tif (x2 < 0) x2 = w - 1;\r\n\t\t\t\t\t\tx3 = x + 1;\r\n\t\t\t\t\t\tif (x3 >= w) x3 = 0;\r\n\r\n\r\n\t\t\t\t\t\tt = srcdata[y * w + x];\r\n\t\t\t\t\t\tif (srcdata[y2 * w + x] < t) t = srcdata[y2 * w + x];\r\n\t\t\t\t\t\tif (srcdata[y3 * w + x] < t) t = srcdata[y3 * w + x];\r\n\t\t\t\t\t\tif (srcdata[y * w + x2] < t) t = srcdata[y * w + x2];\r\n\t\t\t\t\t\tif (srcdata[y * w + x3] < t) t = srcdata[y * w + x3];\r\n\t\t\t\t\t\tdstdata[y * w + x] = t;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tmemcpy(tmp, dstdata, w*h * sizeof(float));\r\n\t\t\t\tsrcdata = tmp;\r\n\t\t\t}\r\n\t\t\tfree(tmp);\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n/* Based on the work: http://cis.k.hosei.ac.jp/~wakahara/ */\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_sharpen_filtering_image(sod_img im)\r\n{\r\n\t/* Spatial filtering of image data */\r\n\t/* Sharpening filter by 8-neighbor Laplacian subtraction */\r\n\tsod_img out;\r\n\tif (im.c != SOD_IMG_GRAYSCALE || !im.data) {\r\n\t\t/* Only grayscale image */\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\t/* Clone the input image */\r\n\tout = sod_copy_image(im);\r\n\tif (out.data) {\r\n\t\t/* Definition of sharpening filter */\r\n\t\tint weight[3][3] = { { 1,  1,  1 },\r\n\t\t{ 1,  -8,  1 },\r\n\t\t{ 1,  1,  1 } };\r\n\t\tconst double alpha = 0.2;\r\n\t\tdouble pixel_value;\r\n\t\tint x, y, i, j;  /* Loop variable */\r\n\t\tint new_value;\r\n\t\t/* Original image minus Laplacian image */\r\n\t\tfor (y = 1; y < im.h - 1; y++) {\r\n\t\t\tfor (x = 1; x < im.w - 1; x++) {\r\n\t\t\t\tpixel_value = 0.0;\r\n\t\t\t\tfor (j = -1; j < 2; j++) {\r\n\t\t\t\t\tfor (i = -1; i < 2; i++) {\r\n\t\t\t\t\t\tpixel_value += weight[j + 1][i + 1] * im.data[((y + j) * im.w) + x + i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tnew_value = (int)(im.data[y * im.w + x] - alpha * pixel_value);\r\n\t\t\t\tif (new_value < 0) new_value = 0;\r\n\t\t\t\tif (new_value > 1) new_value = 1;\r\n\t\t\t\tout.data[y * out.w + x] = (float)new_value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n/* Based on the work: http://cis.k.hosei.ac.jp/~wakahara/ */\r\n/* connectivity detection for each point */\r\nstatic int hilditch_func_nc8(int *b)\r\n{\r\n\tint n_odd[4] = { 1, 3, 5, 7 };  /* odd-number neighbors */\r\n\tint i, j, sum, d[10];           /* control variable */\r\n\r\n\tfor (i = 0; i <= 9; i++) {\r\n\t\tj = i;\r\n\t\tif (i == 9) j = 1;\r\n\t\tif (abs(*(b + j)) == 1) {\r\n\t\t\td[i] = 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\td[i] = 0;\r\n\t\t}\r\n\t}\r\n\tsum = 0;\r\n\tfor (i = 0; i < 4; i++) {\r\n\t\tj = n_odd[i];\r\n\t\tsum = sum + d[j] - d[j] * d[j + 1] * d[j + 2];\r\n\t}\r\n\treturn sum;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_hilditch_thin_image(sod_img im)\r\n{\r\n\t/* thinning of binary image via Hilditch's algorithm */\r\n\tint offset[9][2] = { { 0,0 },{ 1,0 },{ 1,-1 },{ 0,-1 },{ -1,-1 },\r\n\t{ -1,0 },{ -1,1 },{ 0,1 },{ 1,1 } }; /* offsets for neighbors */\r\n\tint n_odd[4] = { 1, 3, 5, 7 };      /* odd-number neighbors */\r\n\tint px, py;                         /* X/Y coordinates  */\r\n\tint b[9];                           /* gray levels for 9 neighbors */\r\n\tint condition[6];                   /* valid for conditions 1-6 */\r\n\tint counter;                        /* number of changing points  */\r\n\tint i, x, y, copy, sum;             /* control variable          */\r\n\tsod_img out;\r\n\r\n\tif (im.data == 0 || im.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Must be a binary image (canny_edge, thresholding, etc..) */\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\t/* initialization of output */\r\n\tout = sod_copy_image(im);\r\n\tif (out.data == 0) {\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\t/* processing starts */\r\n\tdo {\r\n\t\tcounter = 0;\r\n\t\tfor (y = 0; y < im.h; y++) {\r\n\t\t\tfor (x = 0; x < im.w; x++) {\r\n\t\t\t\t/* substitution of 9-neighbor gray values */\r\n\t\t\t\tfor (i = 0; i < 9; i++) {\r\n\t\t\t\t\tb[i] = 0;\r\n\t\t\t\t\tpx = x + offset[i][0];\r\n\t\t\t\t\tpy = y + offset[i][1];\r\n\t\t\t\t\tif (px >= 0 && px < im.w &&\r\n\t\t\t\t\t\tpy >= 0 && py < im.h) {\r\n\t\t\t\t\t\tif (out.data[py * im.w + px] == 0) {\r\n\t\t\t\t\t\t\tb[i] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (out.data[py * im.w + px] == 2 /* Temp marker */) {\r\n\t\t\t\t\t\t\tb[i] = -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (i = 0; i < 6; i++) {\r\n\t\t\t\t\tcondition[i] = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* condition 1: figure point */\r\n\t\t\t\tif (b[0] == 1) condition[0] = 1;\r\n\r\n\t\t\t\t/* condition 2: boundary point */\r\n\t\t\t\tsum = 0;\r\n\t\t\t\tfor (i = 0; i < 4; i++) {\r\n\t\t\t\t\tsum = sum + 1 - abs(b[n_odd[i]]);\r\n\t\t\t\t}\r\n\t\t\t\tif (sum >= 1) condition[1] = 1;\r\n\r\n\t\t\t\t/* condition 3: endpoint conservation */\r\n\t\t\t\tsum = 0;\r\n\t\t\t\tfor (i = 1; i <= 8; i++) {\r\n\t\t\t\t\tsum = sum + abs(b[i]);\r\n\t\t\t\t}\r\n\t\t\t\tif (sum >= 2) condition[2] = 1;\r\n\r\n\t\t\t\t/* condition 4: isolated point conservation */\r\n\t\t\t\tsum = 0;\r\n\t\t\t\tfor (i = 1; i <= 8; i++) {\r\n\t\t\t\t\tif (b[i] == 1) sum++;\r\n\t\t\t\t}\r\n\t\t\t\tif (sum >= 1) condition[3] = 1;\r\n\r\n\t\t\t\t/* condition 5: connectivity conservation */\r\n\t\t\t\tif (hilditch_func_nc8(b) == 1) condition[4] = 1;\r\n\r\n\t\t\t\t/* condition 6: one-side elimination for line-width of two */\r\n\t\t\t\tsum = 0;\r\n\t\t\t\tfor (i = 1; i <= 8; i++) {\r\n\t\t\t\t\tif (b[i] != -1) {\r\n\t\t\t\t\t\tsum++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcopy = b[i];\r\n\t\t\t\t\t\tb[i] = 0;\r\n\t\t\t\t\t\tif (hilditch_func_nc8(b) == 1) sum++;\r\n\t\t\t\t\t\tb[i] = copy;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (sum == 8) condition[5] = 1;\r\n\r\n\t\t\t\t/* final decision */\r\n\t\t\t\tif (condition[0] && condition[1] && condition[2] &&\r\n\t\t\t\t\tcondition[3] && condition[4] && condition[5]) {\r\n\t\t\t\t\tout.data[y * im.w + x] = 2; /* Temp */\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t}\r\n\t\t\t} /* end of x */\r\n\t\t} /* end of y */\r\n\r\n\t\tif (counter != 0) {\r\n\t\t\tfor (y = 0; y < im.h; y++) {\r\n\t\t\t\tfor (x = 0; x < im.w; x++) {\r\n\t\t\t\t\tif (out.data[y * im.w + x] == 2) out.data[y *im.w + x] = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} while (counter != 0);\r\n\r\n\treturn out;\r\n}\r\n/* Based on the work: http://cis.k.hosei.ac.jp/~wakahara/ */\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_sobel_image(sod_img im)\r\n{\r\n\tsod_img out;\r\n\tint weight[3][3] = { { -1,  0,  1 },\r\n\t{ -2,  0,  2 },\r\n\t{ -1,  0,  1 } };\r\n\tdouble pixel_value;\r\n\tdouble min, max;\r\n\tint x, y, i, j;  /* Loop variable */\r\n\r\n\tif (!im.data || im.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Only grayscale images */\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\t}\r\n\tout = sod_make_image(im.w, im.h, im.c);\r\n\tif (!out.data) {\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\t}\r\n\t/* Maximum values calculation after filtering*/\r\n\tmin = DBL_MAX;\r\n\tmax = -DBL_MAX;\r\n\tfor (y = 1; y < im.h - 1; y++) {\r\n\t\tfor (x = 1; x < im.w - 1; x++) {\r\n\t\t\tpixel_value = 0.0;\r\n\t\t\tfor (j = -1; j <= 1; j++) {\r\n\t\t\t\tfor (i = -1; i <= 1; i++) {\r\n\t\t\t\t\tpixel_value += weight[j + 1][i + 1] * im.data[(im.w * (y + j)) + x + i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pixel_value < min) min = pixel_value;\r\n\t\t\tif (pixel_value > max) max = pixel_value;\r\n\t\t}\r\n\t}\r\n\tif ((int)(max - min) == 0) {\r\n\t\treturn out;\r\n\t}\r\n\t/* Generation of image2 after linear transformation */\r\n\tfor (y = 1; y < out.h - 1; y++) {\r\n\t\tfor (x = 1; x < out.w - 1; x++) {\r\n\t\t\tpixel_value = 0.0;\r\n\t\t\tfor (j = -1; j <= 1; j++) {\r\n\t\t\t\tfor (i = -1; i <= 1; i++) {\r\n\t\t\t\t\tpixel_value += weight[j + 1][i + 1] * im.data[(im.w * (y + j)) + x + i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpixel_value = (pixel_value - min) / (max - min);\r\n\t\t\tout.data[out.w * y + x] = (float)pixel_value;\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n/*\r\n* Connected Component Labeling.\r\n*/\r\ntypedef struct sod_label_coord sod_label_coord;\r\nstruct sod_label_coord\r\n{\r\n\tint xmin;\r\n\tint xmax;\r\n\tint ymin;\r\n\tint ymax;\r\n\tsod_label_coord *pNext; /* Next recorded label on the list */\r\n};\r\n/*\r\n* License CPOL, https://www.codeproject.com/Articles/825200/An-Implementation-Of-The-Connected-Component-Label\r\n*/\r\n#define CALL_LabelComponent(x,y,returnLabel) { STACK[SP] = x; STACK[SP+1] = y; STACK[SP+2] = returnLabel; SP += 3; goto START; }\r\n#define ST_RETURN { SP -= 3;                \\\r\n                 switch (STACK[SP+2])    \\\r\n                 {                       \\\r\n                 case 1 : goto RETURN1;  \\\r\n                 case 2 : goto RETURN2;  \\\r\n                 case 3 : goto RETURN3;  \\\r\n                 case 4 : goto RETURN4;  \\\r\n                 default: return;        \\\r\n                 }                       \\\r\n               }\r\n#define XS (STACK[SP-3])\r\n#define YS (STACK[SP-2])\r\nstatic void LabelComponent(uint16_t* STACK, uint16_t width, uint16_t height, float* input, sod_label_coord **output, sod_label_coord *pCord, uint16_t x, uint16_t y)\r\n{\r\n\tSTACK[0] = x;\r\n\tSTACK[1] = y;\r\n\tSTACK[2] = 0;  /* return - component is labeled */\r\n\tint SP = 3;\r\n\tint index;\r\n\r\nSTART: /* Recursive routine starts here */\r\n\r\n\tindex = XS + width * YS;\r\n\tif (input[index] == 0) ST_RETURN;   /* This pixel is not part of a component */\r\n\tif (output[index] != 0) ST_RETURN;   /* This pixel has already been labeled  */\r\n\toutput[index] = pCord;\r\n\r\n\tif (pCord->xmin > XS) pCord->xmin = XS;\r\n\tif (pCord->xmax < XS) pCord->xmax = XS;\r\n\tif (pCord->ymin > YS) pCord->ymin = YS;\r\n\tif (pCord->ymax < YS) pCord->ymax = YS;\r\n\r\n\tif (XS > 0) CALL_LabelComponent(XS - 1, YS, 1);   /* left  pixel */\r\nRETURN1:\r\n\r\n\tif (XS < width - 1) CALL_LabelComponent(XS + 1, YS, 2);   /* right pixel */\r\nRETURN2:\r\n\r\n\tif (YS > 0) CALL_LabelComponent(XS, YS - 1, 3);   /* upper pixel */\r\nRETURN3:\r\n\r\n\tif (YS < height - 1) CALL_LabelComponent(XS, YS + 1, 4);   /* lower pixel */\r\nRETURN4:\r\n\r\n\tST_RETURN;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nstatic sod_label_coord * LabelImage(sod_img *pImg)\r\n{\r\n\tsod_label_coord **apCord, *pEntry, *pList = 0;\r\n\tuint16_t width = (uint16_t)pImg->w;\r\n\tuint16_t height = (uint16_t)pImg->h;\r\n\tuint16_t* STACK;\r\n\tint labelNo = 0;\r\n\tint index = -1;\r\n\tfloat *input;\r\n\tuint16_t x, y;\r\n\tSTACK = (uint16_t *)malloc(3 * sizeof(uint16_t)*(width*height + 1));\r\n\tif (STACK == 0) return 0;\r\n\tapCord = (sod_label_coord **)malloc(width * height * sizeof(sod_label_coord *));\r\n\tif (apCord == 0) {\r\n\t\tfree(STACK);\r\n\t\treturn 0;\r\n\t}\r\n\tmemset(apCord, 0, width * height * sizeof(sod_label_coord *));\r\n\tinput = pImg->data;\r\n\tfor (y = 0; y < height; y++)\r\n\t{\r\n\t\tfor (x = 0; x < width; x++)\r\n\t\t{\r\n\t\t\tindex++;\r\n\t\t\tif (input[index] == 0) continue;   /* This pixel is not part of a component */\r\n\t\t\tif (apCord[index] != 0) continue;   /* This pixel has already been labeled  */\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* New component found */\r\n\t\t\tpEntry = (sod_label_coord *)malloc(sizeof(sod_label_coord));\r\n\t\t\tif (pEntry == 0) {\r\n\t\t\t\tgoto finish;\r\n\t\t\t}\r\n\t\t\tlabelNo++;\r\n\t\t\tpEntry->xmax = pEntry->ymax = -100;\r\n\t\t\tpEntry->xmin = pEntry->ymin = 2147483647;\r\n\t\t\tpEntry->pNext = pList;\r\n\t\t\tpList = pEntry;\r\n\t\t\tLabelComponent(STACK, width, height, input, apCord, pEntry, x, y);\r\n\t\t}\r\n\t}\r\nfinish:\r\n\tfree(STACK);\r\n\tfree(apCord);\r\n\treturn pList;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_image_find_blobs(sod_img im, sod_box ** paBox, int * pnBox, int(*xFilter)(int width, int height))\r\n{\r\n\tif (im.c != SOD_IMG_GRAYSCALE || im.data == 0) {\r\n\t\t/* Must be a binary image */\r\n\t\tif (pnBox) {\r\n\t\t\t*pnBox = 0;\r\n\t\t}\r\n\t\treturn SOD_UNSUPPORTED;\r\n\t}\r\n\tif (pnBox) {\r\n\t\tsod_label_coord *pList, *pNext;\r\n\t\tsod_box sRect;\r\n\t\tSySet aBox;\r\n\t\t/* Label that image */\r\n\t\tpList = LabelImage(&im);\r\n\t\tSySetInit(&aBox, sizeof(sod_box));\r\n\t\twhile (pList) {\r\n\t\t\tpNext = pList->pNext;\r\n\t\t\tif (pList->xmax >= 0) {\r\n\t\t\t\tint allow = 1;\r\n\t\t\t\tint h = pList->ymax - pList->ymin;\r\n\t\t\t\tint w = pList->xmax - pList->xmin;\r\n\t\t\t\tif (xFilter) {\r\n\t\t\t\t\tallow = xFilter(w, h);\r\n\t\t\t\t}\r\n\t\t\t\tif (allow) {\r\n\t\t\t\t\tsRect.pUserData = 0;\r\n\t\t\t\t\tsRect.score = 0;\r\n\t\t\t\t\tsRect.zName = \"blob\";\r\n\t\t\t\t\tsRect.x = pList->xmin;\r\n\t\t\t\t\tsRect.y = pList->ymin;\r\n\t\t\t\t\tsRect.w = w;\r\n\t\t\t\t\tsRect.h = h;\r\n\t\t\t\t\t/* Save the box */\r\n\t\t\t\t\tSySetPut(&aBox, (const void *)&sRect);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(pList);\r\n\t\t\tpList = pNext;\r\n\t\t}\r\n\t\t*pnBox = (int)SySetUsed(&aBox);\r\n\t\tif (paBox) {\r\n\t\t\t*paBox = (sod_box *)SySetBasePtr(&aBox);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tSySetRelease(&aBox);\r\n\t\t}\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_blob_boxes_release(sod_box * pBox)\r\n{\r\n\tfree(pBox);\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_blend_image(sod_img fore, sod_img back, float alpha)\r\n{\r\n\tsod_img blend = sod_make_image(fore.w, fore.h, fore.c);\r\n\tif (!(fore.w == back.w && fore.h == back.h && fore.c == back.c)) {\r\n\t\treturn blend;\r\n\t}\r\n\tint i, j, k;\r\n\tfor (k = 0; k < fore.c; ++k) {\r\n\t\tfor (j = 0; j < fore.h; ++j) {\r\n\t\t\tfor (i = 0; i < fore.w; ++i) {\r\n\t\t\t\tfloat val = alpha * get_pixel(fore, i, j, k) + (1 - alpha)* get_pixel(back, i, j, k);\r\n\t\t\t\tset_pixel(blend, i, j, k, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn blend;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_scale_image_channel(sod_img im, int c, float v)\r\n{\r\n\tint i, j;\r\n\tfor (j = 0; j < im.h; ++j) {\r\n\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\tfloat pix = get_pixel(im, i, j, c);\r\n\t\t\tpix = pix * v;\r\n\t\t\tset_pixel(im, i, j, c, pix);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_translate_image_channel(sod_img im, int c, float v)\r\n{\r\n\tint i, j;\r\n\tfor (j = 0; j < im.h; ++j) {\r\n\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\tfloat pix = get_pixel(im, i, j, c);\r\n\t\t\tpix = pix + v;\r\n\t\t\tset_pixel(im, i, j, c, pix);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_binarize_image(sod_img im, int reverse)\r\n{\r\n\tsod_img c = sod_copy_image(im);\r\n\tif (c.data) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < im.w * im.h * im.c; ++i) {\r\n\t\t\tif (c.data[i] > .5) c.data[i] = reverse ? 1 : 0;\r\n\t\t\telse c.data[i] = reverse ? 0 : 1;\r\n\t\t}\r\n\t}\r\n\treturn c;\r\n}\r\nstatic float get_pixel_extend(sod_img m, int x, int y, int c)\r\n{\r\n\tif (x < 0 || x >= m.w || y < 0 || y >= m.h) return 0;\r\n\tif (c < 0 || c >= m.c) return 0;\r\n\treturn get_pixel(m, x, y, c);\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_composite_image(sod_img source, sod_img dest, int dx, int dy)\r\n{\r\n\tint x, y, k;\r\n\tfor (k = 0; k < source.c; ++k) {\r\n\t\tfor (y = 0; y < source.h; ++y) {\r\n\t\t\tfor (x = 0; x < source.w; ++x) {\r\n\t\t\t\tfloat val = get_pixel(source, x, y, k);\r\n\t\t\t\tfloat val2 = get_pixel_extend(dest, dx + x, dy + y, k);\r\n\t\t\t\tset_pixel(dest, dx + x, dy + y, k, val * val2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void sodFastImageResize(sod_img im, sod_img resized, sod_img part, int w, int h)\r\n{\r\n\tint r, c, k;\r\n\tfloat w_scale = (float)(im.w - 1) / (w - 1);\r\n\tfloat h_scale = (float)(im.h - 1) / (h - 1);\r\n\tfor (k = 0; k < im.c; ++k) {\r\n\t\tfor (r = 0; r < im.h; ++r) {\r\n\t\t\tfor (c = 0; c < w; ++c) {\r\n\t\t\t\tfloat val = 0;\r\n\t\t\t\tif (c == w - 1 || im.w == 1) {\r\n\t\t\t\t\tval = get_pixel(im, im.w - 1, r, k);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfloat sx = c * w_scale;\r\n\t\t\t\t\tint ix = (int)sx;\r\n\t\t\t\t\tfloat dx = sx - ix;\r\n\t\t\t\t\tval = (1 - dx) * get_pixel(im, ix, r, k) + dx * get_pixel(im, ix + 1, r, k);\r\n\t\t\t\t}\r\n\t\t\t\tset_pixel(part, c, r, k, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (k = 0; k < im.c; ++k) {\r\n\t\tfor (r = 0; r < h; ++r) {\r\n\t\t\tfloat sy = r * h_scale;\r\n\t\t\tint iy = (int)sy;\r\n\t\t\tfloat dy = sy - iy;\r\n\t\t\tfor (c = 0; c < w; ++c) {\r\n\t\t\t\tfloat val = (1 - dy) * get_pixel(part, c, iy, k);\r\n\t\t\t\tset_pixel(resized, c, r, k, val);\r\n\t\t\t}\r\n\t\t\tif (r == h - 1 || im.h == 1) continue;\r\n\t\t\tfor (c = 0; c < w; ++c) {\r\n\t\t\t\tfloat val = dy * get_pixel(part, c, iy + 1, k);\r\n\t\t\t\tadd_pixel(resized, c, r, k, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_resize_image(sod_img im, int w, int h)\r\n{\r\n\tsod_img resized = sod_make_image(w, h, im.c);\r\n\tsod_img part = sod_make_image(w, im.h, im.c);\r\n\tsodFastImageResize(im, resized, part, w, h);\r\n\tsod_free_image(part);\r\n\treturn resized;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_resize_max(sod_img im, int max)\r\n{\r\n\tint w = im.w;\r\n\tint h = im.h;\r\n\tif (w > h) {\r\n\t\th = (h * max) / w;\r\n\t\tw = max;\r\n\t}\r\n\telse {\r\n\t\tw = (w * max) / h;\r\n\t\th = max;\r\n\t}\r\n\tif (w == im.w && h == im.h) return im;\r\n\tsod_img resized = sod_resize_image(im, w, h);\r\n\treturn resized;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_resize_min(sod_img im, int min)\r\n{\r\n\tint w = im.w;\r\n\tint h = im.h;\r\n\tif (w < h) {\r\n\t\th = (h * min) / w;\r\n\t\tw = min;\r\n\t}\r\n\telse {\r\n\t\tw = (w * min) / h;\r\n\t\th = min;\r\n\t}\r\n\tif (w == im.w && h == im.h) return im;\r\n\tsod_img resized = sod_resize_image(im, w, h);\r\n\treturn resized;\r\n}\r\nstatic float bilinear_interpolate(sod_img im, float x, float y, int c)\r\n{\r\n#if defined(__BORLANDC__) && defined(_WIN32)\r\n\tint ix = (int)floor(x);\r\n\tint iy = (int)floor(y);\r\n#else\r\n\tint ix = (int)floorf(x);\r\n\tint iy = (int)floorf(y);\r\n#endif\r\n\tfloat dx = x - ix;\r\n\tfloat dy = y - iy;\r\n\tfloat val = (1 - dy) * (1 - dx) * get_pixel_extend(im, ix, iy, c) +\r\n\t\tdy * (1 - dx) * get_pixel_extend(im, ix, iy + 1, c) +\r\n\t\t(1 - dy) *   dx   * get_pixel_extend(im, ix + 1, iy, c) +\r\n\t\tdy * dx   * get_pixel_extend(im, ix + 1, iy + 1, c);\r\n\treturn val;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_rotate_crop_image(sod_img im, float rad, float s, int w, int h, float dx, float dy, float aspect)\r\n{\r\n\tint x, y, c;\r\n\tfloat cx = im.w / 2.;\r\n\tfloat cy = im.h / 2.;\r\n\tsod_img rot = sod_make_image(w, h, im.c);\r\n\tif (rot.data) {\r\n\t\tfor (c = 0; c < im.c; ++c) {\r\n\t\t\tfor (y = 0; y < h; ++y) {\r\n\t\t\t\tfor (x = 0; x < w; ++x) {\r\n\t\t\t\t\tfloat rx = cos(rad)*((x - w / 2.) / s * aspect + dx / s * aspect) - sin(rad)*((y - h / 2.) / s + dy / s) + cx;\r\n\t\t\t\t\tfloat ry = sin(rad)*((x - w / 2.) / s * aspect + dx / s * aspect) + cos(rad)*((y - h / 2.) / s + dy / s) + cy;\r\n\t\t\t\t\tfloat val = bilinear_interpolate(im, rx, ry, c);\r\n\t\t\t\t\tset_pixel(rot, x, y, c, val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn rot;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_rotate_image(sod_img im, float rad)\r\n{\r\n\tint x, y, c;\r\n\tfloat cx = im.w / 2.;\r\n\tfloat cy = im.h / 2.;\r\n\tsod_img rot = sod_make_image(im.w, im.h, im.c);\r\n\tif (rot.data) {\r\n\t\tfor (c = 0; c < im.c; ++c) {\r\n\t\t\tfor (y = 0; y < im.h; ++y) {\r\n\t\t\t\tfor (x = 0; x < im.w; ++x) {\r\n\t\t\t\t\tfloat rx = cos(rad)*(x - cx) - sin(rad)*(y - cy) + cx;\r\n\t\t\t\t\tfloat ry = sin(rad)*(x - cx) + cos(rad)*(y - cy) + cy;\r\n\t\t\t\t\tfloat val = bilinear_interpolate(im, rx, ry, c);\r\n\t\t\t\t\tset_pixel(rot, x, y, c, val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn rot;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_translate_image(sod_img m, float s)\r\n{\r\n\tif (m.data) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < m.h*m.w*m.c; ++i) m.data[i] += s;\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_scale_image(sod_img m, float s)\r\n{\r\n\tif (m.data) {\r\n\t\tint i;\r\n\t\tfor (i = 0; i < m.h*m.w*m.c; ++i) m.data[i] *= s;\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_crop_image(sod_img im, int dx, int dy, int w, int h)\r\n{\r\n\tsod_img cropped = sod_make_image(w, h, im.c);\r\n\tint i, j, k;\r\n\tfor (k = 0; k < im.c; ++k) {\r\n\t\tfor (j = 0; j < h; ++j) {\r\n\t\t\tfor (i = 0; i < w; ++i) {\r\n\t\t\t\tint r = j + dy;\r\n\t\t\t\tint c = i + dx;\r\n\t\t\t\tfloat val = 0;\r\n\t\t\t\tr = constrain_int(r, 0, im.h - 1);\r\n\t\t\t\tc = constrain_int(c, 0, im.w - 1);\r\n\t\t\t\tif (r >= 0 && r < im.h && c >= 0 && c < im.w) {\r\n\t\t\t\t\tval = get_pixel(im, c, r, k);\r\n\t\t\t\t}\r\n\t\t\t\tset_pixel(cropped, i, j, k, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn cropped;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_random_crop_image(sod_img im, int w, int h)\r\n{\r\n\tint dx = rand_int(0, im.w - w);\r\n\tint dy = rand_int(0, im.h - h);\r\n\tsod_img crop = sod_crop_image(im, dx, dy, w, h);\r\n\treturn crop;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_transpose_image(sod_img im)\r\n{\r\n\tint n, m;\r\n\tint c;\r\n\tif (im.w != im.h) {\r\n\t\treturn;\r\n\t}\r\n\tif (im.data) {\r\n\t\tfor (c = 0; c < im.c; ++c) {\r\n\t\t\tfor (n = 0; n < im.w - 1; ++n) {\r\n\t\t\t\tfor (m = n + 1; m < im.w; ++m) {\r\n\t\t\t\t\tfloat swap = im.data[m + im.w*(n + im.h*c)];\r\n\t\t\t\t\tim.data[m + im.w*(n + im.h*c)] = im.data[n + im.w*(m + im.h*c)];\r\n\t\t\t\t\tim.data[n + im.w*(m + im.h*c)] = swap;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n#define GRAYLEVEL 256\r\n#define FINAL_LEVEL 64  /* No. of final gray levels */\r\n/* Based on the work: http://cis.k.hosei.ac.jp/~wakahara/ */\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nsod_img sod_equalize_histogram(sod_img im)\r\n{\r\n\tsod_img out;\r\n\tint hist1[GRAYLEVEL], hist2[GRAYLEVEL];\r\n\tint trans_table[GRAYLEVEL]; /* Table of gray level transformation */\r\n\tint i, x, y;      /* Loop variable */\r\n\tint target_value; /* Target occurrences after transformation */\r\n\tint gray;\r\n\tdouble gray_step; /* Descriptive gray level interval */\r\n\tfloat min, max;\r\n\tint x_size2, y_size2;\r\n\r\n\tif (im.data == 0 || im.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Must be a grayscale image */\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tout = sod_make_image(im.w, im.h, im.c);\r\n\tif (out.data == 0) {\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\r\n\t/* Generation of gray level histogram of input image */\r\n\tfor (i = 0; i < GRAYLEVEL; i++) hist1[i] = 0;\r\n\tfor (y = 0; y < im.h; y++) {\r\n\t\tfor (x = 0; x < im.w; x++) {\r\n\t\t\thist1[(unsigned char)(255 * im.data[y * im.w + x])]++;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Generation of transformation table */\r\n\ttarget_value = (int)((double)(im.w * im.h) / FINAL_LEVEL);\r\n\tfor (i = 0; i < FINAL_LEVEL; i++)\r\n\t\thist2[i] = 0;\r\n\r\n\tgray = 0;\r\n\tfor (i = 0; i < GRAYLEVEL; i++) {\r\n\t\tif (abs(target_value - hist2[gray]) <\r\n\t\t\tabs(target_value - (hist2[gray] + hist1[i]))) {\r\n\t\t\tgray++;\r\n\t\t\tif (gray >= FINAL_LEVEL) gray = FINAL_LEVEL - 1;\r\n\t\t}\r\n\t\ttrans_table[i] = gray;\r\n\t\thist2[gray] = hist2[gray] + hist1[i];\r\n\t}\r\n\r\n\t/* Output of image2 subject to histogram equalization */\r\n\tx_size2 = im.w;\r\n\ty_size2 = im.h;\r\n\tgray_step = (double)GRAYLEVEL / FINAL_LEVEL;\r\n\tfor (y = 0; y < y_size2; y++) {\r\n\t\tfor (x = 0; x < x_size2; x++) {\r\n\t\t\tout.data[y * out.w + x] = (trans_table[(unsigned char)(255 * im.data[y * im.w + x])] * gray_step) / 255.;\r\n\t\t}\r\n\t}\r\n\t/* linear transformation of gray level histogram of output image */\r\n\tmax = min = out.data[0];\r\n\tfor (y = 0; y < y_size2; y++) {\r\n\t\tfor (x = 0; x < x_size2; x++) {\r\n\t\t\tif (min > out.data[y * out.w + x]) min = out.data[y * out.w + x];\r\n\t\t\tif (max < out.data[y * out.w + x]) max = out.data[y * out.w + x];\r\n\t\t}\r\n\t}\r\n\tif ((max - min) == 0) {\r\n\t\treturn out;\r\n\t}\r\n\tfor (y = 0; y < y_size2; y++) {\r\n\t\tfor (x = 0; x < x_size2; x++) {\r\n\t\t\tout.data[y * out.w + x] = ((out.data[y * out.w + x] - min) / (max - min));\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n}\r\n\r\n#ifndef M_PI\r\n#define M_PI       3.14159265358979323846\r\n#endif /* M_PI */\r\n/*\r\nAdapted from the FAST-EDGE Repo\r\n\r\nCopyright (c) 2009 Benjamin C. Haynor\r\n\r\nPermission is hereby granted, free of charge, to any person\r\nobtaining a copy of this software and associated documentation\r\nfiles (the \"Software\"), to deal in the Software without\r\nrestriction, including without limitation the rights to use,\r\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the\r\nSoftware is furnished to do so, subject to the following\r\nconditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\nOTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\nstatic void canny_calc_gradient_sobel(sod_img * img_in, int *g, int *dir) {\r\n\tint w, h, x, y, max_x, max_y, g_x, g_y;\r\n\tfloat g_div;\r\n\tw = img_in->w;\r\n\th = img_in->h;\r\n\tmax_x = w - 3;\r\n\tmax_y = w * (h - 3);\r\n\tfor (y = w * 3; y < max_y; y += w) {\r\n\t\tfor (x = 3; x < max_x; x++) {\r\n\t\t\tg_x = (int)(255 * (2 * img_in->data[x + y + 1]\r\n\t\t\t\t+ img_in->data[x + y - w + 1]\r\n\t\t\t\t+ img_in->data[x + y + w + 1]\r\n\t\t\t\t- 2 * img_in->data[x + y - 1]\r\n\t\t\t\t- img_in->data[x + y - w - 1]\r\n\t\t\t\t- img_in->data[x + y + w - 1]));\r\n\t\t\tg_y = (int)(255 * (2 * img_in->data[x + y - w]\r\n\t\t\t\t+ img_in->data[x + y - w + 1]\r\n\t\t\t\t+ img_in->data[x + y - w - 1]\r\n\t\t\t\t- 2 * img_in->data[x + y + w]\r\n\t\t\t\t- img_in->data[x + y + w + 1]\r\n\t\t\t\t- img_in->data[x + y + w - 1]));\r\n\r\n\t\t\tg[x + y] = sqrt(g_x * g_x + g_y * g_y);\r\n\r\n\t\t\tif (g_x == 0) {\r\n\t\t\t\tdir[x + y] = 2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tg_div = g_y / (float)g_x;\r\n\t\t\t\tif (g_div < 0) {\r\n\t\t\t\t\tif (g_div < -2.41421356237) {\r\n\t\t\t\t\t\tdir[x + y] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif (g_div < -0.414213562373) {\r\n\t\t\t\t\t\t\tdir[x + y] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tdir[x + y] = 2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (g_div > 2.41421356237) {\r\n\t\t\t\t\t\tdir[x + y] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif (g_div > 0.414213562373) {\r\n\t\t\t\t\t\t\tdir[x + y] = 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tdir[x + y] = 2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\nNON_MAX_SUPPRESSION\r\nusing the estimates of the Gx and Gy image gradients and the edge direction angle determines whether the magnitude of the gradient assumes a local  maximum in the gradient direction\r\nif the rounded edge direction angle is 0 degrees, checks the north and south directions\r\nif the rounded edge direction angle is 45 degrees, checks the northwest and southeast directions\r\nif the rounded edge direction angle is 90 degrees, checks the east and west directions\r\nif the rounded edge direction angle is 135 degrees, checks the northeast and southwest directions\r\n*/\r\nstatic void canny_non_max_suppression(sod_img * img, int *g, int *dir) {\r\n\r\n\tint w, h, x, y, max_x, max_y;\r\n\tw = img->w;\r\n\th = img->h;\r\n\tmax_x = w;\r\n\tmax_y = w * h;\r\n\tfor (y = 0; y < max_y; y += w) {\r\n\t\tfor (x = 0; x < max_x; x++) {\r\n\t\t\tswitch (dir[x + y]) {\r\n\t\t\tcase 0:\r\n\t\t\t\tif (g[x + y] > g[x + y - w] && g[x + y] > g[x + y + w]) {\r\n\t\t\t\t\tif (g[x + y] > 255) {\r\n\t\t\t\t\t\timg->data[x + y] = 255.;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\timg->data[x + y] = (float)g[x + y];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\timg->data[x + y] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tif (g[x + y] > g[x + y - w - 1] && g[x + y] > g[x + y + w + 1]) {\r\n\t\t\t\t\tif (g[x + y] > 255) {\r\n\t\t\t\t\t\timg->data[x + y] = 255.;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\timg->data[x + y] = (float)g[x + y];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\timg->data[x + y] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif (g[x + y] > g[x + y - 1] && g[x + y] > g[x + y + 1]) {\r\n\t\t\t\t\tif (g[x + y] > 255) {\r\n\t\t\t\t\t\timg->data[x + y] = 255.;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\timg->data[x + y] = (float)g[x + y];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\timg->data[x + y] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tif (g[x + y] > g[x + y - w + 1] && g[x + y] > g[x + y + w - 1]) {\r\n\t\t\t\t\tif (g[x + y] > 255) {\r\n\t\t\t\t\t\timg->data[x + y] = 255.;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\timg->data[x + y] = (float)g[x + y];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\timg->data[x + y] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n#define LOW_THRESHOLD_PERCENTAGE 0.8 /* percentage of the high threshold value that the low threshold shall be set at */\r\n#define HIGH_THRESHOLD_PERCENTAGE 0.10 /* percentage of pixels that meet the high threshold - for example 0.15 will ensure that at least 15% of edge pixels are considered to meet the high threshold */\r\n/*\r\n* ESTIMATE_THRESHOLD\r\n* estimates hysteresis threshold, assuming that the top X% (as defined by the HIGH_THRESHOLD_PERCENTAGE) of edge pixels with the greatest\r\n* intensity are true edges and that the low threshold is equal to the quantity of the high threshold plus the total number of 0s at\r\n* the low end of the histogram divided by 2.\r\n*/\r\nstatic void canny_estimate_threshold(sod_img * img, int * high, int * low) {\r\n\r\n\tint i, max, pixels, high_cutoff;\r\n\tint histogram[256];\r\n\tmax = img->w * img->h;\r\n\tfor (i = 0; i < 256; i++) {\r\n\t\thistogram[i] = 0;\r\n\t}\r\n\tfor (i = 0; i < max; i++) {\r\n\t\thistogram[(int)img->data[i]]++;\r\n\t}\r\n\tpixels = (max - histogram[0]) * HIGH_THRESHOLD_PERCENTAGE;\r\n\thigh_cutoff = 0;\r\n\ti = 255;\r\n\twhile (high_cutoff < pixels) {\r\n\t\thigh_cutoff += histogram[i];\r\n\t\ti--;\r\n\t}\r\n\t*high = i;\r\n\ti = 1;\r\n\twhile (histogram[i] == 0) {\r\n\t\ti++;\r\n\t}\r\n\t*low = (*high + i) * LOW_THRESHOLD_PERCENTAGE;\r\n}\r\nstatic int canny_range(sod_img * img, int x, int y)\r\n{\r\n\tif ((x < 0) || (x >= img->w)) {\r\n\t\treturn(0);\r\n\t}\r\n\tif ((y < 0) || (y >= img->h)) {\r\n\t\treturn(0);\r\n\t}\r\n\treturn(1);\r\n}\r\nstatic int canny_trace(int x, int y, int low, sod_img * img_in, sod_img * img_out)\r\n{\r\n\tint y_off, x_off;\r\n\tif (img_out->data[y * img_out->w + x] == 0)\r\n\t{\r\n\t\timg_out->data[y * img_out->w + x] = 1;\r\n\t\tfor (y_off = -1; y_off <= 1; y_off++)\r\n\t\t{\r\n\t\t\tfor (x_off = -1; x_off <= 1; x_off++)\r\n\t\t\t{\r\n\t\t\t\tif (!(y == 0 && x_off == 0) && canny_range(img_in, x + x_off, y + y_off) && (int)(img_in->data[(y + y_off) * img_out->w + x + x_off]) >= low) {\r\n\t\t\t\t\tif (canny_trace(x + x_off, y + y_off, low, img_in, img_out))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn(1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn(1);\r\n\t}\r\n\treturn(0);\r\n}\r\nstatic void canny_hysteresis(int high, int low, sod_img * img_in, sod_img * img_out)\r\n{\r\n\tint x, y, n, max;\r\n\tmax = img_in->w * img_in->h;\r\n\tfor (n = 0; n < max; n++) {\r\n\t\timg_out->data[n] = 0;\r\n\t}\r\n\tfor (y = 0; y < img_out->h; y++) {\r\n\t\tfor (x = 0; x < img_out->w; x++) {\r\n\t\t\tif ((int)(img_in->data[y * img_out->w + x]) >= high) {\r\n\t\t\t\tcanny_trace(x, y, low, img_in, img_out);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/* Based on the work: http://cis.k.hosei.ac.jp/~wakahara/ */\r\nstatic int minutiae_crossnumber(float *pixels,int y, int x, int w)\r\n{\r\n\tint i, data[8];\r\n\tint cross;\r\n\r\n\tdata[0] = pixels[y * w + x + 1] == 0 ? 1 : 0;\r\n\tdata[1] = pixels[(y - 1) * w + x + 1] == 0 ? 1 : 0;\r\n\tdata[2] = pixels[(y - 1) * w + x] == 0 ? 1 : 0;\r\n\tdata[3] = pixels[(y - 1) * w + (x - 1)] == 0 ? 1 : 0;\r\n\tdata[4] = pixels[y * w + (x - 1)] == 0 ? 1 : 0;\r\n\tdata[5] = pixels[(y + 1) * w + (x - 1)] == 0 ? 1 : 0;\r\n\tdata[6] = pixels[(y + 1) * w + x] == 0 ? 1 : 0;\r\n\tdata[7] = pixels[(y + 1) * w + x + 1] == 0 ? 1 : 0;\r\n\tcross = 0;\r\n\tfor (i = 0; i < 8; i++) {\r\n\t\tcross += abs(data[(i + 1) % 8] - data[i]);\r\n\t}\r\n\tcross /= 2;\r\n\treturn cross;\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_constrain_image(sod_img im)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < im.w * im.h * im.c; ++i) {\r\n\t\tif (im.data[i] < 0) im.data[i] = 0;\r\n\t\tif (im.data[i] > 1) im.data[i] = 1;\r\n\t}\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nstatic inline float get_color(int c, int x, int max)\r\n{\r\n\tstatic const float colors[6][3] = { {1,0,1}, {0,0,1},{0,1,1},{0,1,0},{1,1,0},{1,0,0} };\r\n\tfloat ratio = ((float)x / max) * 5;\r\n\tint i = floor(ratio);\r\n\tint j = ceil(ratio);\r\n\tratio -= i;\r\n\tfloat r = (1 - ratio) * colors[i][c] + ratio * colors[j][c];\r\n\treturn r;\r\n}\r\nSOD_APIEXPORT sod_img sod_img_mask_to_rgb(sod_img mask)\r\n{\r\n\tsod_img im = sod_make_image(mask.w, mask.h, 3);\r\n\tint n = mask.c;\r\n\tint i, j;\r\n\tif (!im.data)\r\n\t\treturn sod_make_empty_image(mask.w, mask.h, 3);\r\n\tfor (j = 0; j < n; ++j) {\r\n\t\tint offset = j * 123457 % n;\r\n\t\tfloat red = get_color(2, offset, n);\r\n\t\tfloat green = get_color(1, offset, n);\r\n\t\tfloat blue = get_color(0, offset, n);\r\n\t\tfor (i = 0; i < im.w * im.h; ++i) {\r\n\t\t\tim.data[i + 0 * im.w * im.h] += mask.data[j * im.h * im.w + i] * red;\r\n\t\t\tim.data[i + 1 * im.w * im.h] += mask.data[j * im.h * im.w + i] * green;\r\n\t\t\tim.data[i + 2 * im.w * im.h] += mask.data[j * im.h * im.w + i] * blue;\r\n\t\t}\r\n\t}\r\n\treturn im;\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_censor_image(sod_img im, int dx, int dy, int w, int h)\r\n{\r\n\tconst int s = 32;\r\n\tint i, j, k;\r\n\tif (dx < 0) dx = 0;\r\n\tif (dy < 0) dy = 0;\r\n\tfor (k = 0; k < im.c; ++k) {\r\n\t\tfor (j = dy; j < dy + h && j < im.h; ++j) {\r\n\t\t\tfor (i = dx; i < dx + w && i < im.w; ++i) {\r\n\t\t\t\tim.data[i + im.w * (j + im.h * k)] = im.data[i / s * s + im.w * (j / s * s + im.h * k)];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_saturate_image(sod_img im, float sat)\r\n{\r\n\tsod_img_rgb_to_hsv(im);\r\n\tsod_scale_image_channel(im, 1, sat);\r\n\tsod_img_hsv_to_rgb(im);\r\n\tsod_constrain_image(im);\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_saturate_exposure_image(sod_img im, float sat, float exposure)\r\n{\r\n\tsod_img_rgb_to_hsv(im);\r\n\tsod_scale_image_channel(im, 1, sat);\r\n\tsod_scale_image_channel(im, 2, exposure);\r\n\tsod_img_hsv_to_rgb(im);\r\n\tsod_constrain_image(im);\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_hue_image(sod_img im, float hue)\r\n{\r\n\tint i;\r\n\tsod_img_rgb_to_hsv(im);\r\n\tfor (i = 0; i < im.w * im.h; ++i) {\r\n\t\tim.data[i] = im.data[i] + hue;\r\n\t\tif (im.data[i] > 1) im.data[i] -= 1;\r\n\t\tif (im.data[i] < 0) im.data[i] += 1;\r\n\t}\r\n\tsod_img_hsv_to_rgb(im);\r\n\tsod_constrain_image(im);\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_exposure_image(sod_img im, float sat)\r\n{\r\n\tsod_img_rgb_to_hsv(im);\r\n\tsod_scale_image_channel(im, 2, sat);\r\n\tsod_img_hsv_to_rgb(im);\r\n\tsod_constrain_image(im);\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_distort_image(sod_img im, float hue, float sat, float val)\r\n{\r\n\tsod_img_rgb_to_hsv(im);\r\n\tsod_scale_image_channel(im, 1, sat);\r\n\tsod_scale_image_channel(im, 2, val);\r\n\tint i;\r\n\tfor (i = 0; i < im.w * im.h; ++i) {\r\n\t\tim.data[i] = im.data[i] + hue;\r\n\t\tif (im.data[i] > 1) im.data[i] -= 1;\r\n\t\tif (im.data[i] < 0) im.data[i] += 1;\r\n\t}\r\n\tsod_img_hsv_to_rgb(im);\r\n\tsod_constrain_image(im);\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_random_distort_image(sod_img im, float hue, float saturation, float exposure)\r\n{\r\n\tfloat dhue = rand_uniform(-hue, hue);\r\n\tfloat dsat = rand_scale(saturation);\r\n\tfloat dexp = rand_scale(exposure);\r\n\tsod_distort_image(im, dhue, dsat, dexp);\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT void sod_image_sepia_filter(sod_img rgb)\r\n{\r\n\tint x, y;\r\n\tif (rgb.c != 3)\r\n\t\treturn;\r\n\tsod_img_rgb_to_yuv(rgb);\r\n\tfor (x = 0; x < rgb.w; x++) {\r\n\t\tfor (y = 0; y < rgb.h; y++) {\r\n\t\t\tfloat r, g, b;\r\n\t\t\tr = .393 * get_pixel(rgb, x, y, 0) + .769 * get_pixel(rgb, x, y, 1) + .189 * get_pixel(rgb, x, y, 2);\r\n\t\t\tg = .349 * get_pixel(rgb, x, y, 0) + .686 * get_pixel(rgb, x, y, 1) + .168 * get_pixel(rgb, x, y, 2);\r\n\t\t\tb = .272 * get_pixel(rgb, x, y, 0) + .534 * get_pixel(rgb, x, y, 1) + .131 * get_pixel(rgb, x, y, 2);\r\n\t\t\tif (r > 255.)\r\n\t\t\t\tr = 255.;\r\n\t\t\tset_pixel(rgb, x, y, 0, r);\r\n\t\t\tif (g > 255.)\r\n\t\t\t\tg = 255.;\r\n\t\t\tset_pixel(rgb, x, y, 1, g);\r\n\t\t\tif (b > 255.)\r\n\t\t\t\tb = 255.;\r\n\t\t\tset_pixel(rgb, x, y, 2, b);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT sod_img sod_box_blur_image(sod_img im)\r\n{\r\n\t/* to blur we need to take pixel in the center and equalize to it neighboring pixels */\r\n\tint x, y;\r\n\tfloat sum = 0.0;\r\n\tsod_img blurred;\r\n\tconst int filter[3][3] = {\r\n\t\t{1, 2, 1},\r\n\t\t{2, 4, 2},\r\n\t\t{1, 2, 1}\r\n\t};\r\n\tconst int filterDiv = 16;\r\n\tconst int filterWidth = 3;\r\n\tconst int filterHeight = 3;\r\n\tif( im.c != 3 )\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\tblurred = sod_make_image(im.w, im.h, im.c);\r\n\tif (!blurred.data)\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\tfor (x = 0; x < im.w; x++) {\r\n\t\tfor (y = 0; y < im.h; y++) {\r\n\t\t\tfloat sumr = 0, sumg = 0, sumb = 0;\r\n\t\t\tint filterY, filterX;\r\n\t\t\tfor (filterY = 0; filterY < filterHeight; filterY++) {\r\n\t\t\t\tfor (filterX = 0; filterX < filterWidth; filterX++) {\r\n\t\t\t\t\tint imageX = (x - filterWidth / 2 + filterX + im.w) % im.w;\r\n\t\t\t\t\tint imageY = (y - filterHeight / 2 + filterY + im.h) % im.h;\r\n\t\t\t\t\tsumr += get_pixel(im, imageX, imageY, 0) * filter[filterY][filterX];\r\n\t\t\t\t\tsumg += get_pixel(im, imageX, imageY, 1) * filter[filterY][filterX];\r\n\t\t\t\t\tsumb += get_pixel(im, imageX, imageY, 2) * filter[filterY][filterX];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tset_pixel(blurred, x, y, 0, sumr / filterDiv);\r\n\t\t\tset_pixel(blurred, x, y, 1, sumg / filterDiv);\r\n\t\t\tset_pixel(blurred, x, y, 2, sumb / filterDiv);\r\n\t\t}\r\n\t}\r\n\treturn blurred;\r\n}\r\nstatic double gaussianModel(double x, double y, double sigma) {\r\n\treturn 1. / exp(-(x * x + y * y) / (2 * sigma * sigma));\r\n}\r\nstatic double* generate_coeff(int radius, double sigma) {\r\n\tdouble* coeff;\r\n\tdouble sum = 0.0;\r\n\tcoeff = malloc(sizeof(double) * radius * radius);\r\n\tif (!coeff)\r\n\t\treturn 0;\r\n\tfor (int i = 0; i < radius; i++) {\r\n\t\tfor (int j = 0; j < radius; j++) {\r\n\t\t\tcoeff[i * radius + j] = gaussianModel(i - radius / 2, j - radius / 2, sigma);\r\n\t\t\tsum += coeff[i * radius + j];\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i < radius * radius; i++)\r\n\t\tcoeff[i] /= sum;\r\n\treturn coeff;\r\n}\r\n/*\r\n * CAPIREF (Version 1.1.9): Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT sod_img sod_gaussian_blur_image(sod_img im, int radius, double sigma)\r\n{\r\n\tfloat b, g, r;\r\n\tdouble* coeff;\r\n\tint i, j, m, n;\r\n\tsod_img blurred;\r\n\tif (im.c != 3)\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\tblurred = sod_make_image(im.w, im.h, im.c);\r\n\tif (!blurred.data)\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\tcoeff = generate_coeff(radius, sigma);\r\n\tif (!coeff) {\r\n\t\tsod_free_image(blurred);\r\n\t\treturn sod_make_empty_image(im.w, im.h, im.c);\r\n\t}\r\n\tfor (i = 0; i < im.h - radius; i++) {\r\n\t\tfor (j = 0; j < im.w - radius; j++) {\r\n\t\t\tb = g = r = 0.0;\r\n\t\t\tfor (m = 0; m < radius; m++) {\r\n\t\t\t\tfor (n = 0; n < radius; n++) {\r\n\t\t\t\t\tr += coeff[m * radius + n] * get_pixel(im, j + n, i + m, 0);\r\n\t\t\t\t\tg += coeff[m * radius + n] * get_pixel(im, j + n, i + m, 1);\r\n\t\t\t\t\tb += coeff[m * radius + n] * get_pixel(im, j + n, i + m, 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tset_pixel(blurred, j, i, 0, r);\r\n\t\t\tset_pixel(blurred, j, i, 1, g);\r\n\t\t\tset_pixel(blurred, j, i, 2, b);\r\n\t\t}\r\n\t}\r\n\tfree(coeff);\r\n\treturn blurred;\r\n}\r\n/*\r\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n */\r\nSOD_APIEXPORT sod_img sod_minutiae(sod_img bin, int *pTotal, int *pEp, int *pBp)\r\n{\r\n\tif (pTotal) {\r\n\t\t*pTotal = 0;\r\n\t}\r\n\tif (pEp) {\r\n\t\t*pEp = 0;\r\n\t}\r\n\tif (pBp) {\r\n\t\t*pBp = 0;\r\n\t}\r\n\t/* Extraction of minutiae candidates in skeletonized fingerprint image */\r\n\tif (bin.data == 0 || bin.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Must be a binary image  processed via sod_hilditch_thin_image() */\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tsod_img out = sod_make_image(bin.w, bin.h, bin.c);\r\n\tif (out.data) {\r\n\t\tint x, y;\r\n\t\tint total, np1, np2;  /* number of black and minutiae points */\r\n\t\tint cross;\r\n\t\tint i;\r\n\t\tfor (i = 0; i < out.w*out.h; i++) {\r\n\t\t\tif (bin.data[i] == 1) {\r\n\t\t\t\tout.data[i] = 200;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.data[i] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* finding minutiae in 3 x 3 window \r\n\t\t * Minutiae extraction is applied to skeletonized fingerprint.\r\n\t\t */\r\n\t\ttotal = 0;\r\n\t\tnp1 = 0;  /* number of ending points */\r\n\t\tnp2 = 0;  /* number of bifurcations */\r\n\t\tfor (y = 1; y < bin.h - 1; y++) {\r\n\t\t\tfor (x = 1; x < bin.w - 1; x++) {\r\n\t\t\t\tif (bin.data[y * bin.w + x] == 0) {\r\n\t\t\t\t\ttotal++;\r\n\t\t\t\t\tcross = minutiae_crossnumber(bin.data, y, x, bin.w);\r\n\t\t\t\t\tif (cross == 1) {\r\n\t\t\t\t\t\tnp1++;\r\n\t\t\t\t\t\tout.data[y * bin.w + x] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (cross >= 3) {\r\n\t\t\t\t\t\tnp2++;\r\n\t\t\t\t\t\tout.data[y * bin.w + x] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (pTotal) {\r\n\t\t\t*pTotal = total;\r\n\t\t}\r\n\t\tif (pEp) {\r\n\t\t\t*pEp = np1;\r\n\t\t}\r\n\t\tif (pBp) {\r\n\t\t\t*pBp = np2;\r\n\t\t}\t\r\n\t}\r\n\treturn out;\r\n}\r\n/*\r\n* Gaussian Noise Reduce on a grayscale image.\r\n* apply 5x5 Gaussian convolution filter, shrinks the image by 4 pixels in each direction, using Gaussian filter found here:\r\n* http://en.wikipedia.org/wiki/Canny_edge_detector\r\n*/\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_gaussian_noise_reduce(sod_img grayscale)\r\n{\r\n\tint w, h, x, y, max_x, max_y;\r\n\tsod_img img_out;\r\n\tif (!grayscale.data || grayscale.c != SOD_IMG_GRAYSCALE) {\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tw = grayscale.w;\r\n\th = grayscale.h;\r\n\timg_out = sod_make_image(w, h, 1);\r\n\tif (img_out.data) {\r\n\t\tmax_x = w - 2;\r\n\t\tmax_y = w * (h - 2);\r\n\t\tfor (y = w * 2; y < max_y; y += w) {\r\n\t\t\tfor (x = 2; x < max_x; x++) {\r\n\t\t\t\timg_out.data[x + y] = (2 * grayscale.data[x + y - 2 - w - w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y - 1 - w - w] +\r\n\t\t\t\t\t5 * grayscale.data[x + y - w - w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y + 1 - w - w] +\r\n\t\t\t\t\t2 * grayscale.data[x + y + 2 - w - w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y - 2 - w] +\r\n\t\t\t\t\t9 * grayscale.data[x + y - 1 - w] +\r\n\t\t\t\t\t12 * grayscale.data[x + y - w] +\r\n\t\t\t\t\t9 * grayscale.data[x + y + 1 - w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y + 2 - w] +\r\n\t\t\t\t\t5 * grayscale.data[x + y - 2] +\r\n\t\t\t\t\t12 * grayscale.data[x + y - 1] +\r\n\t\t\t\t\t15 * grayscale.data[x + y] +\r\n\t\t\t\t\t12 * grayscale.data[x + y + 1] +\r\n\t\t\t\t\t5 * grayscale.data[x + y + 2] +\r\n\t\t\t\t\t4 * grayscale.data[x + y - 2 + w] +\r\n\t\t\t\t\t9 * grayscale.data[x + y - 1 + w] +\r\n\t\t\t\t\t12 * grayscale.data[x + y + w] +\r\n\t\t\t\t\t9 * grayscale.data[x + y + 1 + w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y + 2 + w] +\r\n\t\t\t\t\t2 * grayscale.data[x + y - 2 + w + w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y - 1 + w + w] +\r\n\t\t\t\t\t5 * grayscale.data[x + y + w + w] +\r\n\t\t\t\t\t4 * grayscale.data[x + y + 1 + w + w] +\r\n\t\t\t\t\t2 * grayscale.data[x + y + 2 + w + w]) / 159;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn img_out;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_canny_edge_image(sod_img im, int reduce_noise)\r\n{\r\n\tif (im.data && im.c == SOD_IMG_GRAYSCALE) {\r\n\t\tsod_img out, sobel, clean;\r\n\t\tint high, low, *g, *dir;\r\n\t\tif (reduce_noise) {\r\n\t\t\tclean = sod_gaussian_noise_reduce(im);\r\n\t\t\tif (!clean.data)return sod_make_empty_image(0, 0, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tclean = im;\r\n\t\t}\r\n\t\tsobel = sod_make_image(im.w, im.h, 1);\r\n\t\tout = sod_make_image(im.w, im.h, 1);\r\n\t\tg = malloc(im.w *(im.h + 16) * sizeof(int));\r\n\t\tdir = malloc(im.w *(im.h + 16) * sizeof(int));\r\n\t\tif (g && dir && sobel.data && out.data) {\r\n\t\t\tcanny_calc_gradient_sobel(&clean, g, dir);\r\n\t\t\tcanny_non_max_suppression(&sobel, g, dir);\r\n\t\t\tcanny_estimate_threshold(&sobel, &high, &low);\r\n\t\t\tcanny_hysteresis(high, low, &sobel, &out);\r\n\t\t}\r\n\t\tif (g)free(g);\r\n\t\tif (dir)free(dir);\r\n\t\tif (reduce_noise)sod_free_image(clean);\r\n\t\tsod_free_image(sobel);\r\n\t\treturn out;\r\n\t}\r\n\t/* Make a grayscale version of your image using sod_grayscale_image() or sod_img_load_grayscale() first */\r\n\treturn sod_make_empty_image(0, 0, 0);\r\n}\r\n/*\r\n* Hough Transform - Portion based on the work of Bruno Keymolen under the BSD License.\r\n* see: http://www.keymolen.com/2013/05/hough-transformation-c-implementation.html\r\n*/\r\n/* Copyright (c) 2013, Bruno Keymolen, email: bruno.keymolen@gmail.com\r\n* All rights reserved.\r\n*\r\n* Redistribution and use in source and binary forms, with or without modification,\r\n* are permitted provided that the following conditions are met:\r\n*\r\n* Redistributions of source code must retain the above copyright notice,\r\n* this list of conditions and the following disclaimer.\r\n* Redistributions in binary form must reproduce the above copyright notice, this\r\n* list of conditions and the following disclaimer in the documentation and/or other\r\n* materials provided with the distribution.\r\n* Neither the name of \"Bruno Keymolen\" nor the names of its contributors may be\r\n* used to endorse or promote products derived from this software without specific\r\n* prior written permission.\r\n*\r\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n* POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_pts * sod_hough_lines_detect(sod_img im, int threshold, int *nPts)\r\n{\r\n#define DEG2RAD 0.017453293f\r\n\tdouble center_x, center_y;\r\n\tunsigned int *accu;\r\n\tint accu_w, accu_h;\r\n\tint img_w, img_h;\r\n\tdouble hough_h;\r\n\tSySet aLines;\r\n\tsod_pts pts;\r\n\tint x, y;\r\n\tint r, t;\r\n\r\n\tif (!im.data || im.c != SOD_IMG_GRAYSCALE) {\r\n\t\t/* Require a binary image using sod_canny_edge_image() */\r\n\t\t*nPts = 0;\r\n\t\treturn 0;\r\n\t}\r\n\tSySetInit(&aLines, sizeof(sod_pts));\r\n\timg_w = im.w;\r\n\timg_h = im.h;\r\n\r\n\though_h = ((sqrt(2.0) * (double)(im.h>im.w ? im.h : im.w)) / 2.0);\r\n\taccu_h = hough_h * 2.0; /* -r -> +r */\r\n\taccu_w = 180;\r\n\r\n\taccu = (unsigned int*)calloc(accu_h * accu_w, sizeof(unsigned int));\r\n\tif (accu == 0) {\r\n\t\t*nPts = 0;\r\n\t\treturn 0;\r\n\t}\r\n\tcenter_x = im.w / 2;\r\n\tcenter_y = im.h / 2;\r\n\tfor (y = 0; y < img_h; y++)\r\n\t{\r\n\t\tfor (x = 0; x < img_w; x++)\r\n\t\t{\r\n\t\t\tif (im.data[y * img_w + x] == 1 /*> 250/255.*/)\r\n\t\t\t{\r\n\t\t\t\tfor (t = 0; t < 180; t++)\r\n\t\t\t\t{\r\n\t\t\t\t\tdouble ra = (((double)x - center_x) * cos((double)t * DEG2RAD)) + (((double)y - center_y) * sin((double)t * DEG2RAD));\r\n\t\t\t\t\taccu[(int)((round(ra + hough_h) * 180.0)) + t]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (threshold < 1) threshold = im.w > im.h ? im.w / 3 : im.h / 3;\r\n\tfor (r = 0; r < accu_h; r++)\r\n\t{\r\n\t\tfor (t = 0; t < accu_w; t++)\r\n\t\t{\r\n\t\t\tif ((int)accu[(r*accu_w) + t] >= threshold)\r\n\t\t\t{\r\n\t\t\t\tint ly, lx;\r\n\t\t\t\t/* Is this point a local maxima (9x9) */\r\n\t\t\t\tint max = (int)accu[(r*accu_w) + t];\r\n\t\t\t\tfor (ly = -4; ly <= 4; ly++)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (lx = -4; lx <= 4; lx++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ((ly + r >= 0 && ly + r < accu_h) && (lx + t >= 0 && lx + t < accu_w))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ((int)accu[((r + ly)*accu_w) + (t + lx)] > max)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmax = (int)accu[((r + ly)*accu_w) + (t + lx)];\r\n\t\t\t\t\t\t\t\tly = lx = 5;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (max >(int)accu[(r*accu_w) + t])\r\n\t\t\t\t\tcontinue;\r\n\r\n\r\n\t\t\t\tint x1, y1, x2, y2;\r\n\t\t\t\tx1 = y1 = x2 = y2 = 0;\r\n\r\n\t\t\t\tif (t >= 45 && t <= 135)\r\n\t\t\t\t{\r\n\t\t\t\t\t/*y = (r - x cos(t)) / sin(t)*/\r\n\t\t\t\t\tx1 = 0;\r\n\t\t\t\t\ty1 = ((double)(r - (accu_h / 2)) - ((x1 - (img_w / 2)) * cos(t * DEG2RAD))) / sin(t * DEG2RAD) + (img_h / 2);\r\n\t\t\t\t\tx2 = img_w - 0;\r\n\t\t\t\t\ty2 = ((double)(r - (accu_h / 2)) - ((x2 - (img_w / 2)) * cos(t * DEG2RAD))) / sin(t * DEG2RAD) + (img_h / 2);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t/* x = (r - y sin(t)) / cos(t);*/\r\n\t\t\t\t\ty1 = 0;\r\n\t\t\t\t\tx1 = ((double)(r - (accu_h / 2)) - ((y1 - (img_h / 2)) * sin(t * DEG2RAD))) / cos(t * DEG2RAD) + (img_w / 2);\r\n\t\t\t\t\ty2 = img_h - 0;\r\n\t\t\t\t\tx2 = ((double)(r - (accu_h / 2)) - ((y2 - (img_h / 2)) * sin(t * DEG2RAD))) / cos(t * DEG2RAD) + (img_w / 2);\r\n\t\t\t\t}\r\n\t\t\t\tpts.x = x1; pts.y = y1;\r\n\t\t\t\tSySetPut(&aLines, &pts);\r\n\t\t\t\tpts.x = x2; pts.y = y2;\r\n\t\t\t\tSySetPut(&aLines, &pts);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree(accu);\r\n\t*nPts = (int)SySetUsed(&aLines);\r\n\treturn (sod_pts *)SySetBasePtr(&aLines);\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_hough_lines_release(sod_pts * pLines)\r\n{\r\n\tfree(pLines);\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_random_augment_image(sod_img im, float angle, float aspect, int low, int high, int size)\r\n{\r\n\taspect = rand_scale(aspect);\r\n\tint r = rand_int(low, high);\r\n\tint min = (im.h < im.w*aspect) ? im.h : im.w*aspect;\r\n\tfloat scale = (float)r / min;\r\n\tfloat rad = rand_uniform(-angle, angle) * TWO_PI / 360.;\r\n\tfloat dx = (im.w*scale / aspect - size) / 2.;\r\n\tfloat dy = (im.h*scale - size) / 2.;\r\n\tif (dx < 0) dx = 0;\r\n\tif (dy < 0) dy = 0;\r\n\tdx = rand_uniform(-dx, dx);\r\n\tdy = rand_uniform(-dy, dy);\r\n\tsod_img crop = sod_rotate_crop_image(im, rad, scale, size, size, dx, dy, aspect);\r\n\treturn crop;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_img_rgb_to_bgr(sod_img im)\r\n{\r\n\tint i;\r\n\tif (im.c != 3 || !im.data) {\r\n\t\treturn;\r\n\t}\r\n\tfor (i = 0; i < im.w*im.h; ++i) {\r\n\t\tfloat swap = im.data[i];\r\n\t\tim.data[i] = im.data[i + im.w*im.h * 2];\r\n\t\tim.data[i + im.w*im.h * 2] = swap;\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_img_bgr_to_rgb(sod_img im)\r\n{\r\n\tint i;\r\n\tif (im.c != 3 || !im.data) {\r\n\t\treturn;\r\n\t}\r\n\tfor (i = 0; i < im.w*im.h; ++i) {\r\n\t\tfloat swap = im.data[i + im.w*im.h * 2];\r\n\t\tim.data[i + im.w*im.h * 2] = im.data[i];\r\n\t\tim.data[i] = swap;\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_img_yuv_to_rgb(sod_img im)\r\n{\r\n\tint i, j;\r\n\tfloat r, g, b;\r\n\tfloat y, u, v;\r\n\tif (im.c != 3) {\r\n\t\treturn;\r\n\t}\r\n\tfor (j = 0; j < im.h; ++j) {\r\n\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\ty = get_pixel(im, i, j, 0);\r\n\t\t\tu = get_pixel(im, i, j, 1);\r\n\t\t\tv = get_pixel(im, i, j, 2);\r\n\r\n\t\t\tr = y + 1.13983*v;\r\n\t\t\tg = y + -.39465*u + -.58060*v;\r\n\t\t\tb = y + 2.03211*u;\r\n\r\n\t\t\tset_pixel(im, i, j, 0, r);\r\n\t\t\tset_pixel(im, i, j, 1, g);\r\n\t\t\tset_pixel(im, i, j, 2, b);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_img_rgb_to_yuv(sod_img im)\r\n{\r\n\tint i, j;\r\n\tfloat r, g, b;\r\n\tfloat y, u, v;\r\n\tif (im.c != 3) {\r\n\t\treturn;\r\n\t}\r\n\tfor (j = 0; j < im.h; ++j) {\r\n\t\tfor (i = 0; i < im.w; ++i) {\r\n\t\t\tr = get_pixel(im, i, j, 0);\r\n\t\t\tg = get_pixel(im, i, j, 1);\r\n\t\t\tb = get_pixel(im, i, j, 2);\r\n\r\n\t\t\ty = .299*r + .587*g + .114*b;\r\n\t\t\tu = -.14713*r + -.28886*g + .436*b;\r\n\t\t\tv = .615*r + -.51499*g + -.10001*b;\r\n\r\n\t\t\tset_pixel(im, i, j, 0, y);\r\n\t\t\tset_pixel(im, i, j, 1, u);\r\n\t\t\tset_pixel(im, i, j, 2, v);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_flip_image(sod_img input)\r\n{\r\n\tint i, j, k;\r\n\tfor (k = 0; k < input.c; ++k) {\r\n\t\tfor (i = 0; i < input.h; ++i) {\r\n\t\t\tfor (j = 0; j < input.w / 2; ++j) {\r\n\t\t\t\tint index = j + input.w*(i + input.h*(k));\r\n\t\t\t\tint flip = (input.w - j - 1) + input.w*(i + input.h*(k));\r\n\t\t\t\tfloat swap = input.data[flip];\r\n\t\t\t\tinput.data[flip] = input.data[index];\r\n\t\t\t\tinput.data[index] = swap;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_image_distance(sod_img a, sod_img b)\r\n{\r\n\tint i, j;\r\n\tsod_img dist = sod_make_image(a.w, a.h, 1);\r\n\tif (dist.data && b.c >= a.c && b.h >= a.h && b.w >= a.w) {\r\n\t\tfor (i = 0; i < a.c; ++i) {\r\n\t\t\tfor (j = 0; j < a.h*a.w; ++j) {\r\n\t\t\t\tdist.data[j] += pow(a.data[i*a.h*a.w + j] - b.data[i*a.h*a.w + j], 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (j = 0; j < a.h*a.w; ++j) {\r\n\t\t\tdist.data[j] = sqrt(dist.data[j]);\r\n\t\t}\r\n\t}\r\n\treturn dist;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_embed_image(sod_img source, sod_img dest, int dx, int dy)\r\n{\r\n\tint x, y, k;\r\n\tfor (k = 0; k < source.c; ++k) {\r\n\t\tfor (y = 0; y < source.h; ++y) {\r\n\t\t\tfor (x = 0; x < source.w; ++x) {\r\n\t\t\t\tfloat val = get_pixel(source, x, y, k);\r\n\t\t\t\tset_pixel(dest, dx + x, dy + y, k, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_box_grayscale(sod_img im, int x1, int y1, int x2, int y2, float g)\r\n{\r\n\tif (im.data) {\r\n\t\tint i;\r\n\t\t\tif (x1 < 0) x1 = 0;\r\n\t\tif (x1 >= im.w) x1 = im.w - 1;\r\n\t\tif (x2 < 0) x2 = 0;\r\n\t\tif (x2 >= im.w) x2 = im.w - 1;\r\n\r\n\t\tif (y1 < 0) y1 = 0;\r\n\t\tif (y1 >= im.h) y1 = im.h - 1;\r\n\t\tif (y2 < 0) y2 = 0;\r\n\t\tif (y2 >= im.h) y2 = im.h - 1;\r\n\r\n\t\tfor (i = x1; i <= x2; ++i) {\r\n\t\t\tim.data[i + y1 * im.w] = g;\r\n\t\t\tim.data[i + y2 * im.w] = g;\r\n\t\t}\r\n\t\tfor (i = y1; i <= y2; ++i) {\r\n\t\t\tim.data[x1 + i * im.w] = g;\r\n\t\t\tim.data[x2 + i * im.w] = g;\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_circle(sod_img im, int x0, int y0, int radius, float r, float g, float b)\r\n{\r\n#define plot(x, y) sod_img_set_pixel(im,x,y,0,r);sod_img_set_pixel(im,x,y,1,g);sod_img_set_pixel(im,x,y,2,b);\r\n\tint f, ddF_x, ddF_y, x, y;\r\n\tif (im.data) {\r\n\t\tr = r / 255.;\r\n\t\tg = g / 255.;\r\n\t\tb = b / 255.;\r\n\t\tif (im.c == 1) {\r\n\t\t\t/* Draw on grayscale image */\r\n\t\t\tr = b * 0.114 + g * 0.587 + r * 0.299;\r\n\t\t}\r\n\t\tf = 1 - radius;\r\n\t\tddF_x = 0;\r\n\t\tddF_y = -2 * radius;\r\n\t\tx = 0;\r\n\t\ty = radius;\r\n\r\n\t\tplot(x0, y0 + radius);\r\n\t\tplot(x0, y0 - radius);\r\n\t\tplot(x0 + radius, y0);\r\n\t\tplot(x0 - radius, y0);\r\n\r\n\t\twhile (x < y)\r\n\t\t{\r\n\t\t\tif (f >= 0)\r\n\t\t\t{\r\n\t\t\t\ty--;\r\n\t\t\t\tddF_y += 2;\r\n\t\t\t\tf += ddF_y;\r\n\t\t\t}\r\n\t\t\tx++;\r\n\t\t\tddF_x += 2;\r\n\t\t\tf += ddF_x + 1;\r\n\t\t\tplot(x0 + x, y0 + y);\r\n\t\t\tplot(x0 - x, y0 + y);\r\n\t\t\tplot(x0 + x, y0 - y);\r\n\t\t\tplot(x0 - x, y0 - y);\r\n\t\t\tplot(x0 + y, y0 + x);\r\n\t\t\tplot(x0 - y, y0 + x);\r\n\t\t\tplot(x0 + y, y0 - x);\r\n\t\t\tplot(x0 - y, y0 - x);\r\n\t\t}\r\n\t}\r\n#undef plot\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_box(sod_img im, int x1, int y1, int x2, int y2, float r, float g, float b)\r\n{\r\n\tr = r / 255.;\r\n\tg = g / 255.;\r\n\tb = b / 255.;\r\n\tif (im.c == 1) {\r\n\t\t/* Draw on grayscale image */\r\n\t\tsod_image_draw_box_grayscale(im, x1, y1, x2, y2, b * 0.114 + g * 0.587 + r * 0.299);\r\n\t\treturn;\r\n\t}\r\n\tif (im.data) {\r\n\t\tint i;\r\n\t\tif (x1 < 0) x1 = 0;\r\n\t\tif (x1 >= im.w) x1 = im.w - 1;\r\n\t\tif (x2 < 0) x2 = 0;\r\n\t\tif (x2 >= im.w) x2 = im.w - 1;\r\n\r\n\t\tif (y1 < 0) y1 = 0;\r\n\t\tif (y1 >= im.h) y1 = im.h - 1;\r\n\t\tif (y2 < 0) y2 = 0;\r\n\t\tif (y2 >= im.h) y2 = im.h - 1;\r\n\r\n\t\tfor (i = x1; i <= x2; ++i) {\r\n\t\t\tim.data[i + y1 * im.w + 0 * im.w*im.h] = r;\r\n\t\t\tim.data[i + y2 * im.w + 0 * im.w*im.h] = r;\r\n\r\n\t\t\tim.data[i + y1 * im.w + 1 * im.w*im.h] = g;\r\n\t\t\tim.data[i + y2 * im.w + 1 * im.w*im.h] = g;\r\n\r\n\t\t\tim.data[i + y1 * im.w + 2 * im.w*im.h] = b;\r\n\t\t\tim.data[i + y2 * im.w + 2 * im.w*im.h] = b;\r\n\t\t}\r\n\t\tfor (i = y1; i <= y2; ++i) {\r\n\t\t\tim.data[x1 + i * im.w + 0 * im.w*im.h] = r;\r\n\t\t\tim.data[x2 + i * im.w + 0 * im.w*im.h] = r;\r\n\r\n\t\t\tim.data[x1 + i * im.w + 1 * im.w*im.h] = g;\r\n\t\t\tim.data[x2 + i * im.w + 1 * im.w*im.h] = g;\r\n\r\n\t\t\tim.data[x1 + i * im.w + 2 * im.w*im.h] = b;\r\n\t\t\tim.data[x2 + i * im.w + 2 * im.w*im.h] = b;\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_bbox(sod_img im, sod_box bbox, float r, float g, float b)\r\n{\r\n\tsod_image_draw_box(im, bbox.x, bbox.y, bbox.x + bbox.w, bbox.y + bbox.h, r, g, b);\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_bbox_width(sod_img im, sod_box bbox, int width, float r, float g, float b)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < width; i++) {\r\n\t\tsod_image_draw_box(im, bbox.x + i, bbox.y + i, (bbox.x + bbox.w) - i, (bbox.y + bbox.h) - i, r, g, b);\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_circle_thickness(sod_img im, int x0, int y0, int radius, int width, float r, float g, float b)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < width; i++) {\r\n\t\tsod_image_draw_circle(im, x0, y0, radius - i, r, g, b);\r\n\t}\r\n\t/* @chm: Fill empty pixels */\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_draw_line(sod_img im, sod_pts start, sod_pts end, float r, float g, float b)\r\n{\r\n\tint x1, x2, y1, y2, dx, dy, err, sx, sy, e2;\r\n\tr = r / 255.;\r\n\tg = g / 255.;\r\n\tb = b / 255.;\r\n\tif (im.c == 1) {\r\n\t\t/* Draw on grayscale image */\r\n\t\tr = b * 0.114 + g * 0.587 + r * 0.299;\r\n\t}\r\n\tx1 = start.x;\r\n\tx2 = end.x;\r\n\ty1 = start.y;\r\n\ty2 = end.y;\r\n\tif (x1 < 0) x1 = 0;\r\n\tif (x1 >= im.w) x1 = im.w - 1;\r\n\tif (x2 < 0) x2 = 0;\r\n\tif (x2 >= im.w) x2 = im.w - 1;\r\n\r\n\tif (y1 < 0) y1 = 0;\r\n\tif (y1 >= im.h) y1 = im.h - 1;\r\n\tif (y2 < 0) y2 = 0;\r\n\tif (y2 >= im.h) y2 = im.h - 1;\r\n\r\n\tdx = abs(x2 - x1), sx = x1 < x2 ? 1 : -1;\r\n\tdy = abs(y2 - y1), sy = y1 < y2 ? 1 : -1;\r\n\terr = (dx > dy ? dx : -dy) / 2;\r\n\r\n\tfor (;;) {\r\n\t\tset_pixel(im, x1, y1, 0, r);\r\n\t\tif (im.c == 3) {\r\n\t\t\tset_pixel(im, x1, y1, 1, g);\r\n\t\t\tset_pixel(im, x1, y1, 2, b);\r\n\t\t}\r\n\t\tif (x1 == x2 && y1 == y2) break;\r\n\t\te2 = err;\r\n\t\tif (e2 > -dx) { err -= dy; x1 += sx; }\r\n\t\tif (e2 < dy) { err += dx; y1 += sy; }\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_normalize_image(sod_img p)\r\n{\r\n\tif (p.data) {\r\n\t\tint i;\r\n\t\tfloat min = 9999999;\r\n\t\tfloat max = -999999;\r\n\r\n\t\tfor (i = 0; i < p.h*p.w*p.c; ++i) {\r\n\t\t\tfloat v = p.data[i];\r\n\t\t\tif (v < min) min = v;\r\n\t\t\tif (v > max) max = v;\r\n\t\t}\r\n\t\tif (max - min < .000000001) {\r\n\t\t\tmin = 0;\r\n\t\t\tmax = 1;\r\n\t\t}\r\n\t\tfor (i = 0; i < p.c*p.w*p.h; ++i) {\r\n\t\t\tp.data[i] = (p.data[i] - min) / (max - min);\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nunsigned char * sod_image_to_blob(sod_img im)\r\n{\r\n\tunsigned char *data = 0;\r\n\tint i, k;\r\n\tif (im.data) {\r\n\t\tdata = calloc(im.w*im.h*im.c, sizeof(unsigned char));\r\n\t\tif (data) {\r\n\t\t\tfor (k = 0; k < im.c; ++k) {\r\n\t\t\t\tfor (i = 0; i < im.w*im.h; ++i) {\r\n\t\t\t\t\tdata[i*im.c + k] = (unsigned char)(255 * im.data[i + k * im.w*im.h]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn data;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_image_free_blob(unsigned char *zBlob)\r\n{\r\n\tfree(zBlob);\r\n}\r\n/*\r\n* The RealNets training layer implementation.\r\n*/\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\n#ifdef SOD_DISABLE_IMG_READER\r\n#error The training layer require that the SOD_DISABLE_IMG_READER compile-time directive be enabled, please remove the SOD_DISABLE_IMG_READER compile-time directive from this build\r\n#endif /* SOD_DISABLE_IMG_READER */\r\n/*\r\n* Each configuration (key/value) entry is identified by an instance of the following structure.\r\n*/\r\ntypedef struct sod_config_node sod_config_node;\r\nstruct sod_config_node {\r\n\tSyString sKey;\r\n\tSyString sVal;\r\n};\r\n/*\r\n* Each collected path is stored in an instance of the following structure.\r\n*/\r\ntypedef struct sod_paths sod_paths;\r\nstruct sod_paths\r\n{\r\n\tsize_t max_samples_collect; /* Maximum samples to collect (Optional) */\r\n\tSyString sRootPath; /* Root path of any */\r\n\tSyString sPosPath;  /* Where the positive samples reside */\r\n\tSyString sNegPath;  /* Where the negative samples reside */\r\n\tSyString sTestPath; /* Where the test samples reside */\r\n\tint recurse;        /* True to recurse on sub-directory */\r\n};\r\n/*\r\n* Each registered layer is identified by an instance of the following structure.\r\n*/\r\ntypedef int(*ProcLayerLoad)(sod_realnet_trainer *, sod_config_node *, int, void **);\r\ntypedef int(*ProcLayerExec)(void *, sod_paths *);\r\ntypedef void(*ProcLayerRelease)(void *);\r\n\r\ntypedef struct sod_layer sod_layer;\r\nstruct sod_layer {\r\n\tSyString sName;\r\n\tvoid *pLayerData;          /* Layer private data */\r\n\tProcLayerLoad xLoad;       /* Load callback */\r\n\tProcLayerExec xExec;       /* Training exec callback */\r\n\tProcLayerRelease xRelease; /* Clean-up callback */\r\n};\r\n/*\r\n* Each configuration layer is identified by an instance of the following structure.\r\n*/\r\ntypedef struct sod_config_layer sod_config_layer;\r\nstruct sod_config_layer {\r\n\tSyString sName; /* Layer name */\r\n\tSySet   aNode;  /* Array of 'sod_config_node' entries*/\r\n\tsod_config_layer *pNext; /* Next Layer on the list */\r\n\tsod_config_layer *pPrev; /* Previous Layer on the list */\r\n};\r\ntypedef enum {\r\n\tSOD_TR_SAMPLE_NEG = 0, /* Negative Sample */\r\n\tSOD_TR_SAMPLE_POS,     /* Positive Sample */\r\n\tSOD_TR_SAMPLE_TEST     /* Test Sample */\r\n}SOD_TR_SAMPLE_TYPE;\r\n/*\r\n* Each training sample is identified by an instance of the following structure.\r\n*/\r\ntypedef struct sod_tr_sample sod_tr_sample;\r\nstruct sod_tr_sample\r\n{\r\n\tSOD_TR_SAMPLE_TYPE id;\r\n\tsod_img sRaw;\r\n\tfloat tv;\r\n\tfloat score;\r\n\tint rs;\r\n\tint cs;\r\n\tint ss;\r\n};\r\n/*\r\n* Current training state is held in an instance of this structure.\r\n*/\r\nstruct sod_realnet_trainer\r\n{\r\n\tconst sod_vfs *pVfs;\r\n\tsod_config_layer *pFirst;\r\n\tsod_config_layer *pLast;\r\n\tint nLayers;\r\n\tSySet aBuiltin; /* Built-in layers */\r\n\tSyBlob sWorker;\r\n\tProcLogCallback xLog;\r\n\tvoid *pLogData;\r\n\tconst char *zOutPath; /* Where to store the output cascade */\r\n\tSySet aSample;        /* Collected samples for this epoch */\r\n\tSySet aPos;\r\n\tSySet aNeg;\r\n\tSySet aTest;\r\n\tint nEpoch;\r\n\t/*[paths]*/\r\n\tSySet aPaths;\r\n};\r\n/*\r\n* @Training Code Implementation\r\n*/\r\nstatic inline void sod_config_log_msg(sod_realnet_trainer *pTrainer, const char *zFmt, ...)\r\n{\r\n\tva_list ap;\r\n\tva_start(ap, zFmt);\r\n\tif (pTrainer->xLog) {\r\n\t\tSyBlobReset(&pTrainer->sWorker);\r\n\t\tSyBlobFormatAp(&pTrainer->sWorker, zFmt, ap);\r\n\t\tpTrainer->xLog((const char *)SyBlobData(&pTrainer->sWorker), SyBlobLength(&pTrainer->sWorker), pTrainer->pLogData);\r\n\t}\r\n\tva_end(ap);\r\n}\r\n/* Forward declaration defined below: Make sure to compile WITHOUT this directive defined: SOD_DISABLE_IMG_READER */\r\nstatic int ExtractPathInfo(const char *zPath, size_t nByte, sod_path_info *pOut);\r\n/* forward declaration */\r\nstatic int sy_strnicmp(const char *zA, const char *zB, size_t len);\r\n/*\r\n* Point to the next line from the given memory buffer.\r\n*/\r\nstatic int sod_config_get_next_line(const char **pzPtr, const char *zEnd, SyString *pBuf, int *pLine)\r\n{\r\n\tconst char *zPtr = *pzPtr;\r\n\tconst char *zCur;\r\n\t/* Trim leading white spaces */\r\n\twhile (zPtr < zEnd && isspace(zPtr[0])) {\r\n\t\tif (zPtr[0] == '\\n') (*pLine)++;\r\n\t\tzPtr++;\r\n\t}\r\n\tzCur = zPtr;\r\n\twhile (zPtr < zEnd && zPtr[0] != '\\n') zPtr++;\r\n\tsize_t n = (size_t)(zPtr - zCur);\r\n\tif (n < 1) {\r\n\t\treturn -1; /* EOF */\r\n\t}\r\n\t/* Next Line  */\r\n\t*pzPtr = zPtr;\r\n\t/* Trailing white spaces shall be trimmed later */\r\n\tn = (size_t)(zPtr - zCur);\r\n\tpBuf->zString = zCur;\r\n\tpBuf->nByte = n;\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Extract a layer name if any.\r\n*/\r\nstatic void sod_config_get_layer_name(SyString *pBuf)\r\n{\r\n\tconst char *zIn = pBuf->zString;\r\n\tconst char *zEnd = &zIn[pBuf->nByte];\r\n\tconst char *zCur;\r\n\twhile (zIn < zEnd && (isspace(zIn[0]) || !isalnum(zIn[0]))) zIn++;\r\n\tzCur = zIn;\r\n\twhile (zIn < zEnd && (isalnum(zIn[0]) || zIn[0] == '_'))  zIn++;\r\n\tpBuf->zString = zCur;\r\n\tpBuf->nByte = (size_t)(zIn - zCur);\r\n}\r\n/*\r\n* Extract a name/value pair.\r\n*/\r\nstatic void sod_config_get_name_value_pair(SyString *pBuf, SyString *pName, SyString *pVal, sod_realnet_trainer *pTrainer, int line)\r\n{\r\n\tconst char *zIn = pBuf->zString;\r\n\tconst char *zEnd = &zIn[pBuf->nByte];\r\n\tconst char *zCur;\r\n\tzCur = zIn;\r\n\tpVal->nByte = 0;\r\n\tpVal->zString = 0;\r\n\t/* White space already trimmed */\r\n\twhile (zIn < zEnd && (isalnum(zIn[0]) || zIn[0] == '_')) zIn++;\r\n\tpName->zString = zCur;\r\n\tpName->nByte = (size_t)(zIn - zCur);\r\n\twhile (zIn < zEnd && isspace(zIn[0])) zIn++;\r\n\tif (zIn < zEnd) {\r\n\t\tif (zIn[0] != '=') {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"[Line: %d] Expecting '=' next to the key: '%z', got '%c'. Any remaining value will be ignored\\n\", line, pName, zIn[0]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tzIn++;\r\n\t\t\twhile (zIn < zEnd && isspace(zIn[0])) zIn++;\r\n\t\t\tpVal->zString = zIn;\r\n\t\t\tpVal->nByte = (size_t)(zEnd - zIn);\r\n\t\t\tzEnd--;\r\n\t\t\twhile (zEnd > zIn && isspace(zEnd[0]) && pVal->nByte > 0) {\r\n\t\t\t\t/* Trailing white spaces */\r\n\t\t\t\tpVal->nByte--;\r\n\t\t\t\tzEnd--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* Allocate a new configuration layer.\r\n*/\r\nstatic int sod_config_create_new_layer(sod_realnet_trainer *pTrainer, SyString *pName)\r\n{\r\n\tsod_config_layer *pLayer = malloc(sizeof(sod_config_layer));\r\n\tif (pLayer == 0) {\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Running out of memory\\n\");\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tmemset(pLayer, 0, sizeof(sod_config_layer));\r\n\tpLayer->sName = *pName;\r\n\tSySetInit(&pLayer->aNode, sizeof(sod_config_node));\r\n\t/* Push */\r\n\tpLayer->pNext = pTrainer->pLast;\r\n\tif (pTrainer->pLast) {\r\n\t\tpTrainer->pLast->pPrev = pLayer;\r\n\t}\r\n\tpTrainer->pLast = pLayer;\r\n\tif (pTrainer->pFirst == 0) {\r\n\t\tpTrainer->pFirst = pLayer;\r\n\t}\r\n\tpTrainer->nLayers++;\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Parse the whole configuration buffer.\r\n*/\r\nstatic int sod_parse_config(sod_realnet_trainer *pTrainer, const char *zConf, size_t conf_len)\r\n{\r\n\tconst char *zIn = zConf;\r\n\tconst char *zEnd = &zConf[conf_len];\r\n\tSyString sEntry, sKey, sVal;\r\n\tint line = 1;\r\n\tsod_config_log_msg(&(*pTrainer), \"Parsing training configuration...\\n\");\r\n\twhile (SOD_OK == sod_config_get_next_line(&zIn, zEnd, &sEntry, &line)) {\r\n\t\tsod_config_layer *pLayer;\r\n\t\t/* Discard any comment */\r\n\t\tif (sEntry.zString[0] == '#' || sEntry.zString[0] == ';') continue;\r\n\t\tif (sEntry.zString[0] == '[') {\r\n\t\t\t/* Extract layer name */\r\n\t\t\tsod_config_get_layer_name(&sEntry);\r\n\t\t\t/* Log */\r\n\t\t\tif (sEntry.nByte < 1) {\r\n\t\t\t\tsod_config_log_msg(&(*pTrainer), \"[Line: %d] Empty layer found..ignoring\\n\", line);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsod_config_log_msg(&(*pTrainer), \"[Line: %d] new layer found: '%z'\\n\", line, &sEntry);\r\n\t\t\t\t/* Register this layer */\r\n\t\t\t\tif (SOD_OK != sod_config_create_new_layer(&(*pTrainer), &sEntry)) {\r\n\t\t\t\t\treturn SOD_OUTOFMEM;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Extract key/value pair */\r\n\t\tsod_config_get_name_value_pair(&sEntry, &sKey, &sVal, &(*pTrainer), line);\r\n\t\tif (sKey.nByte < 1) {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"[Line: %d] Missing configuration key..discarding\\n\", line);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Extract the upper layer */\r\n\t\tpLayer = pTrainer->pLast;\r\n\t\tif (pLayer == 0) {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"[Line: %d] No upper layer associated with the key: '%z'..discarding\\n\", line, &sKey);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsod_config_node sNode;\r\n\t\t\t/* Store the key/value pair in the node set */\r\n\t\t\tsNode.sKey = sKey;\r\n\t\t\tsNode.sVal = sVal;\r\n\t\t\tSySetPut(&pLayer->aNode, (const void *)&sNode);\r\n\t\t}\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Convert a non-nil terminated string to double value.\r\n*/\r\nstatic int SyStrToDouble(const char *zSrc, size_t nLen, double * pOutVal, const char **zRest)\r\n{\r\n#define SXDBL_DIG        15\r\n#define SXDBL_MAX_EXP    308\r\n#define SXDBL_MIN_EXP_PLUS\t307\r\n\tstatic const double aTab[] = {\r\n\t\t10,\r\n\t\t1.0e2,\r\n\t\t1.0e4,\r\n\t\t1.0e8,\r\n\t\t1.0e16,\r\n\t\t1.0e32,\r\n\t\t1.0e64,\r\n\t\t1.0e128,\r\n\t\t1.0e256\r\n\t};\r\n\tshort int neg = 0;\r\n\tdouble Val = 0.0;\r\n\tconst char *zEnd;\r\n\tint Lim, exp;\r\n\tdouble *p = 0;\r\n\r\n\tzEnd = &zSrc[nLen];\r\n\twhile (zSrc < zEnd && isspace(zSrc[0])) {\r\n\t\tzSrc++;\r\n\t}\r\n\tif (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {\r\n\t\tneg = zSrc[0] == '-' ? 1 : 0;\r\n\t\tzSrc++;\r\n\t}\r\n\tLim = SXDBL_DIG;\r\n\tfor (;;) {\r\n\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;\r\n\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;\r\n\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;\r\n\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;\r\n\t}\r\n\tif (zSrc < zEnd && (zSrc[0] == '.' || zSrc[0] == ',')) {\r\n\t\tdouble dec = 1.0;\r\n\t\tzSrc++;\r\n\t\tfor (;;) {\r\n\t\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;\r\n\t\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;\r\n\t\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;\r\n\t\t\tif (zSrc >= zEnd || !Lim || !isdigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;\r\n\t\t}\r\n\t\tVal /= dec;\r\n\t}\r\n\tif (neg == 1 && Val != 0.0) {\r\n\t\tVal = -Val;\r\n\t}\r\n\tif (Lim <= 0) {\r\n\t\t/* jump overflow digit */\r\n\t\twhile (zSrc < zEnd) {\r\n\t\t\tif (zSrc[0] == 'e' || zSrc[0] == 'E') {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tzSrc++;\r\n\t\t}\r\n\t}\r\n\tneg = 0;\r\n\tif (zSrc < zEnd && (zSrc[0] == 'e' || zSrc[0] == 'E')) {\r\n\t\tzSrc++;\r\n\t\tif (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {\r\n\t\t\tneg = zSrc[0] == '-' ? 1 : 0;\r\n\t\t\tzSrc++;\r\n\t\t}\r\n\t\texp = 0;\r\n\t\twhile (zSrc < zEnd && isdigit(zSrc[0]) && exp < SXDBL_MAX_EXP) {\r\n\t\t\texp = exp * 10 + (zSrc[0] - '0');\r\n\t\t\tzSrc++;\r\n\t\t}\r\n\t\tif (neg) {\r\n\t\t\tif (exp > SXDBL_MIN_EXP_PLUS) exp = SXDBL_MIN_EXP_PLUS;\r\n\t\t}\r\n\t\telse if (exp > SXDBL_MAX_EXP) {\r\n\t\t\texp = SXDBL_MAX_EXP;\r\n\t\t}\r\n\t\tfor (p = (double *)aTab; exp; exp >>= 1, p++) {\r\n\t\t\tif (exp & 01) {\r\n\t\t\t\tif (neg) {\r\n\t\t\t\t\tVal /= *p;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tVal *= *p;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\twhile (zSrc < zEnd && isspace(zSrc[0])) {\r\n\t\tzSrc++;\r\n\t}\r\n\tif (zRest) {\r\n\t\t*zRest = zSrc;\r\n\t}\r\n\tif (pOutVal) {\r\n\t\t*pOutVal = Val;\r\n\t}\r\n\treturn zSrc >= zEnd ? SOD_OK : -1;\r\n}\r\n/*\r\n* Convert a string to 64-bit integer.\r\n*/\r\n#define SXINT32_MIN_STR\t\t\"2147483648\"\r\n#define SXINT32_MAX_STR\t\t\"2147483647\"\r\nstatic int SyStrToInt32(const char *zSrc, size_t nLen, int32_t *pOutVal, const char **zRest)\r\n{\r\n\tconst char *zEnd;\r\n\tint isNeg = 0;\r\n\tint32_t nVal;\r\n\tshort int i;\r\n\r\n\tzEnd = &zSrc[nLen];\r\n\twhile (zSrc < zEnd && isspace(zSrc[0])) {\r\n\t\tzSrc++;\r\n\t}\r\n\tif (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {\r\n\t\tisNeg = (zSrc[0] == '-') ? 1 : 0;\r\n\t\tzSrc++;\r\n\t}\r\n\t/* Skip leading zero */\r\n\twhile (zSrc < zEnd && zSrc[0] == '0') {\r\n\t\tzSrc++;\r\n\t}\r\n\ti = 10;\r\n\tif ((size_t)(zEnd - zSrc) >= 10) {\r\n\t\ti = memcmp(zSrc, isNeg ? SXINT32_MIN_STR : SXINT32_MAX_STR, 10) <= 0 ? 10 : 9;\r\n\t}\r\n\tnVal = 0;\r\n\tfor (;;) {\r\n\t\tif (zSrc >= zEnd || !i || !isdigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;\r\n\t\tif (zSrc >= zEnd || !i || !isdigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;\r\n\t\tif (zSrc >= zEnd || !i || !isdigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;\r\n\t\tif (zSrc >= zEnd || !i || !isdigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;\r\n\t}\r\n\t/* Skip trailing spaces */\r\n\twhile (zSrc < zEnd && isspace(zSrc[0])) {\r\n\t\tzSrc++;\r\n\t}\r\n\tif (zRest) {\r\n\t\t*zRest = (char *)zSrc;\r\n\t}\r\n\tif (pOutVal) {\r\n\t\tif (isNeg && nVal != 0) {\r\n\t\t\tnVal = -nVal;\r\n\t\t}\r\n\t\t*pOutVal = nVal;\r\n\t}\r\n\treturn (zSrc >= zEnd) ? SOD_OK : -1;\r\n}\r\n/* Forward declaration */\r\nstatic int CmpSyString(SyString *pStr, const char *zIn);\r\n/*\r\n* Duplicate a non-nil terminated string.\r\n*/\r\nstatic int DupSyString(SyString *pIn, SyString *pOut)\r\n{\r\n\tchar *z = 0;\r\n\tpOut->nByte = 0; /* Marker */\r\n\tif (pOut->zString != 0) {\r\n\t\tz = (char *)pOut->zString;\r\n\t\tz = realloc(z, pIn->nByte);\r\n\t}\r\n\telse {\r\n\t\tz = malloc(pIn->nByte + 1);\r\n\t\tpOut->nByte = 0; /* Marker */\r\n\t}\r\n\tif (z == 0) return SOD_OUTOFMEM;\r\n\tmemcpy(z, (const void *)pIn->zString, pIn->nByte);\r\n\tz[pIn->nByte] = 0;\r\n\tpOut->zString = z;\r\n\tpOut->nByte = pIn->nByte;\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Release a dynamically allocated string.\r\n*/\r\nstatic void FreeSyString(SyString *pIn)\r\n{\r\n\tif (pIn->nByte > 0) {\r\n\t\tchar *z = (char *)pIn->zString;\r\n\t\tfree(z);\r\n\t}\r\n}\r\nstatic void PathConfRelease(sod_paths *pPath)\r\n{\r\n\tFreeSyString(&pPath->sRootPath);\r\n\tFreeSyString(&pPath->sPosPath);\r\n\tFreeSyString(&pPath->sNegPath);\r\n\tFreeSyString(&pPath->sTestPath);\r\n}\r\n/*\r\n* @ [paths] layer implementation.\r\n*/\r\n/*\r\n* Load method for the [paths] layer. Get the of list of supplied paths.\r\n* Actually, the [paths] is a special one and works directly with the trainer pointer. That is,\r\n* it does not store any private data.\r\n*/\r\nstatic int paths_layer_load(sod_realnet_trainer *pTrainer, sod_config_node *aNode, int nNode, void **ppPrivate)\r\n{\r\n\tstatic const SyString aName[] = {\r\n\t{ \"root\",     sizeof(\"root\") - 1 },\r\n\t{ \"recurse\",  sizeof(\"recurse\") - 1 },\r\n\t{ \"pos\",      sizeof(\"pos\") - 1 },\r\n\t{ \"positive\", sizeof(\"positive\") - 1 },\r\n\t{ \"neg\",      sizeof(\"neg\") - 1 },\r\n\t{ \"negative\",  sizeof(\"negative\") - 1 },\r\n\t{ \"background\",  sizeof(\"background\") - 1 },\r\n\t{ \"test\",        sizeof(\"test\") - 1 },\r\n\t{ \"max_samples\",        sizeof(\"max_samples\") - 1 }\r\n\t};\r\n\tsod_paths sPath;\r\n\tint i, j;\r\n\t*ppPrivate = 0;\r\n\tmemset(&sPath, 0, sizeof(sod_paths));\r\n\t/* Iterate all over the available entries */\r\n\tfor (i = 0; i < nNode; i++) {\r\n\t\tsod_config_node *pNode = &aNode[i];\r\n\t\tSyString *pKey = &pNode->sKey;\r\n\t\tfor (j = 0; j < (int)sizeof(aName) / sizeof(aName[0]); ++j) {\r\n\t\t\tconst SyString *pName = &aName[j];\r\n\t\t\tif (SyStringCmp(pName, pKey, sy_strnicmp) == 0) {\r\n\t\t\t\tint c = pName->zString[0];\r\n\t\t\t\tint32_t iVal = 0;\r\n\t\t\t\tswitch (c) {\r\n\t\t\t\tcase 'm':\r\n\t\t\t\t\t/* Max samples to collect */\r\n\t\t\t\t\tSyStrToInt32(pNode->sVal.zString, pNode->sVal.nByte, &iVal, 0);\r\n\t\t\t\t\tif (iVal < 10) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Minimum samples to collect must be greater than 10\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsPath.max_samples_collect = (size_t)iVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'r':\r\n\t\t\t\t\tif (pName->zString[1] == 'e') {\r\n\t\t\t\t\t\t/* Recurse on sub-directory  */\r\n\t\t\t\t\t\tif (CmpSyString(&pNode->sVal, \"true\") == 0 || CmpSyString(&pNode->sVal, \"1\") == 0) {\r\n\t\t\t\t\t\t\tsPath.recurse = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t/* Root path */\r\n\t\t\t\t\t\tDupSyString(&pNode->sVal, &sPath.sRootPath);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'p':\r\n\t\t\t\t\t/* Positive samples path */\r\n\t\t\t\t\tDupSyString(&pNode->sVal, &sPath.sPosPath);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'n':\r\n\t\t\t\tcase 'b':\r\n\t\t\t\t\t/* Negative samples path */\r\n\t\t\t\t\tDupSyString(&pNode->sVal, &sPath.sNegPath);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 't':\r\n\t\t\t\t\t/* Test samples path */\r\n\t\t\t\t\tDupSyString(&pNode->sVal, &sPath.sTestPath);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t/*Can't happen*/\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Validate the configuration */\r\n\tif (sPath.sPosPath.nByte < 1 || sPath.sNegPath.nByte < 1) {\r\n\t\tPathConfRelease(&sPath);\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Missing positive or negatives samples path..aborting\\n\");\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\tif (SOD_OK != SySetPut(&pTrainer->aPaths, (const void *)&sPath)) {\r\n\t\tPathConfRelease(&sPath);\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Running out of memory for the [paths] layer\\n\");\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* @ [detector] layer implementation.\r\n*/\r\ntypedef struct sod_realnet_detector sod_realnet_detector;\r\n/*\r\n* Each built tree is identified by instance of the following structure.\r\n*/\r\ntypedef struct sod_tree sod_tree;\r\nstruct sod_tree\r\n{\r\n\tsod_realnet_detector *pDet;\r\n\tint depth;\r\n\tfloat threshold;\r\n\tfloat *aLeafs; /* Lead table */\r\n\tint *aNodes;   /* Internal node table */\r\n};\r\nstruct sod_realnet_detector\r\n{\r\n\tsod_realnet_trainer *pTrainer;\r\n\tint flag; /* Control flags */\r\n\tint min_tree_depth; /* Minimum tree depth */\r\n\tint max_tree_depth; /* Maximum tree depth */\r\n\tint max_trees;      /* Maximum decision trees for the output model */\r\n\tchar bbox[4];\r\n\tint version; /* Output model version format */\r\n\tfloat tpr;   /* True positive rate */\r\n\tfloat fpr;   /* False positive rate */\r\n\tfloat target_fpr; /* Target false positive rate to achieve (i.e. 1e-6)*/\r\n\tint data_aug;     /* True to perform some random perturbation on the training set. */\r\n\tint norm_samples; /* Normalize positive samples */\r\n\tSyString sName;   /* Classifier name */\r\n\tSyString sCopyright; /* Copyright info associated with this classifier if any */\r\n\tSySet aTree;         /* Regression trees */\r\n\tsize_t max_samples_collect; /* Maximum samples to collect if any */\r\n};\r\n#define SOD_DET_PROCESS_STARTED 0x001\r\n/*\r\n* List of supported feature extraction algorithms.\r\n*/\r\n#define SOD_DET_PIXEL_ALGO 1 /* Pixel intensity (default) */\r\n#define SOD_DET_LBP_ALGO   2 /* LBP (Support dropped) */\r\n/*\r\n* Load method for the [detector] layer.\r\n*/\r\nenum sod_realnet_entries {\r\n\tSOD_DET_STEP_SIZE = 1,    /* Step size (percentage) [step_size = 10%] */\r\n\tSOD_DET_SCALE_FACTOR,     /* Scale factor (float) [scale_factor = 1.1] */\r\n\tSOD_DET_MIN_TREE_DEPTH,   /* Minimum tree depth [min_tree_depth = 6]*/\r\n\tSOD_DET_MAX_TREE_DEPTH,   /* Maximum tree depth [max_tree_depth = 12] */\r\n\tSOD_DET_MAX_TREES,        /* Maximum trees to generate [max_trees = 2048] */\r\n\tSOD_DET_DATA_AUGMENT,     /* Introduce small perturbation to the input positive samples */\r\n\tSOD_DET_TPR,              /* True positive rate [tpr  = 0.9900f] */\r\n\tSOD_DET_FPR,              /* False positive rate [fpr = 0.5f] */\r\n\tSOD_DET_TARGET_FPR,       /* Target FPR to achieve [target_fpr = 0.01]*/\r\n\tSOD_DET_NORMALIZE_SAMPLES,/* Normalize the training positive samples  [normalize = false]*/\r\n\tSOD_DET_NAME,             /* Name of the target classifier [name = 'object'] */\r\n\tSOD_DET_ABOUT             /* Description & Copyright information about this classifier if any */\r\n};\r\nstatic int detector_layer_load(sod_realnet_trainer *pTrainer, sod_config_node *aNode, int nNode, void **ppPrivate)\r\n{\r\n\tstatic const struct sod_det_conf {\r\n\t\tconst char *zConf;\r\n\t\tint nId;\r\n\t}aConf[] = {\r\n\t{ \"min_tree_depth\",      SOD_DET_MIN_TREE_DEPTH },\r\n\t{ \"max_tree_depth\",      SOD_DET_MAX_TREE_DEPTH },\r\n\t{ \"max_trees\",           SOD_DET_MAX_TREES },\r\n\t{ \"tpr\",                 SOD_DET_TPR },\r\n\t{ \"fpr\",                 SOD_DET_FPR },\r\n\t{ \"data_augment\",        SOD_DET_DATA_AUGMENT },\r\n\t{ \"target_fpr\",          SOD_DET_TARGET_FPR },\r\n\t{ \"normalize\",           SOD_DET_NORMALIZE_SAMPLES },\r\n\t{ \"name\",                SOD_DET_NAME },\r\n\t{ \"about\",               SOD_DET_ABOUT }\r\n\t};\r\n\tsod_realnet_detector *pDet;\r\n\tint i, j;\r\n\tint nErr = 0;\r\n\t/* Allocate the layer private data */\r\n\tpDet = malloc(sizeof(sod_realnet_detector));\r\n\tif (pDet == 0) {\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Running out of memory for the [detector] layer\\n\");\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\t/* Fill with default values */\r\n\tmemset(pDet, 0, sizeof(sod_realnet_detector));\r\n\tpDet->pTrainer = pTrainer;\r\n\tpDet->fpr = 0.5f;\r\n\tpDet->tpr = 0.9975f;\r\n\tpDet->min_tree_depth = 6;\r\n\tpDet->max_tree_depth = 12;\r\n\tpDet->max_trees = 2048;\r\n\tpDet->norm_samples = 0;\r\n\tpDet->version = 3; /* Increment on each new format */\r\n\tpDet->bbox[0] = -127;\r\n\tpDet->bbox[1] = +127;\r\n\tpDet->bbox[2] = -127;\r\n\tpDet->bbox[3] = +127;\r\n\tpDet->target_fpr = 1e-6f; /* Stop when the false positive rate (FPR) fall below this value */\r\n\tSyStringInitFromBuf(&pDet->sName, \"object\", sizeof(\"object\") - 1);\r\n\tSySetInit(&pDet->aTree, sizeof(sod_tree));\r\n\t/* Iterate all over the available entries */\r\n\tfor (i = 0; i < nNode; i++) {\r\n\t\tsod_config_node *pNode = &aNode[i];\r\n\t\tSyString *pKey = &pNode->sKey;\r\n\t\tfor (j = 0; j < (int)sizeof(aConf) / sizeof(aConf[0]); j++) {\r\n\t\t\tif (CmpSyString(pKey, aConf[j].zConf) == 0) {\r\n\t\t\t\tSyString *pVal = &pNode->sVal;\r\n\t\t\t\tdouble dVal = 0.0;\r\n\t\t\t\tint32_t iVal = 0;\r\n\t\t\t\t/* Process this configuration entry */\r\n\t\t\t\tswitch (aConf[j].nId) {\r\n\t\t\t\tcase SOD_DET_NAME:\r\n\t\t\t\t\tif (SyStringLength(&pNode->sVal) > 0) {\r\n\t\t\t\t\t\tSyStringDupPtr(&pDet->sName, &pNode->sVal);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_ABOUT:\r\n\t\t\t\t\tif (SyStringLength(&pNode->sVal) > 0) {\r\n\t\t\t\t\t\tSyStringDupPtr(&pDet->sCopyright, &pNode->sVal);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_NORMALIZE_SAMPLES:\r\n\t\t\t\t\tif (CmpSyString(&pNode->sVal, \"true\") == 0 || CmpSyString(&pNode->sVal, \"1\") == 0) {\r\n\t\t\t\t\t\tpDet->norm_samples = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_FPR:\r\n\t\t\t\t\t/* False positive rate */\r\n\t\t\t\t\tSyStrToDouble(pVal->zString, pVal->nByte, &dVal, 0);\r\n\t\t\t\t\tif (dVal >= 1 || dVal < 0.1) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Maximum False Positive Rate (FPR) must be a float value set between 0.1 .. 1\\n\");\r\n\t\t\t\t\t\tnErr++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpDet->fpr = (float)dVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_TPR:\r\n\t\t\t\t\t/* True positive rate */\r\n\t\t\t\t\tSyStrToDouble(pVal->zString, pVal->nByte, &dVal, 0);\r\n\t\t\t\t\tif (dVal >= 1 || dVal < 0.1) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Minimum True Positive Rate (TPR) must be a float value set between 0.1 .. 1\\n\");\r\n\t\t\t\t\t\tnErr++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpDet->tpr = (float)dVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_DATA_AUGMENT:\r\n\t\t\t\t\tif (CmpSyString(&pNode->sVal, \"true\") == 0 || CmpSyString(&pNode->sVal, \"1\") == 0) {\r\n\t\t\t\t\t\tpDet->data_aug = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_TARGET_FPR:\r\n\t\t\t\t\t/* Target false positive rate */\r\n\t\t\t\t\tSyStrToDouble(pVal->zString, pVal->nByte, &dVal, 0);\r\n\t\t\t\t\tif (dVal < 0.0) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Target false Positive Rate (TFPR) cannot take a negative value\\n\");\r\n\t\t\t\t\t\tnErr++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpDet->target_fpr = (float)dVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_MAX_TREE_DEPTH:\r\n\t\t\t\t\t/* Max tree depth */\r\n\t\t\t\t\tSyStrToInt32(pVal->zString, pVal->nByte, &iVal, 0);\r\n\t\t\t\t\tif (iVal < 5 || iVal > 30) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Maximum tree depth must be an integer set between 5 .. 30\\n\");\r\n\t\t\t\t\t\tnErr++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpDet->max_tree_depth = iVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_MIN_TREE_DEPTH:\r\n\t\t\t\t\t/* Min tree depth */\r\n\t\t\t\t\tSyStrToInt32(pVal->zString, pVal->nByte, &iVal, 0);\r\n\t\t\t\t\tif (iVal < 1 || iVal > 12) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Minimum tree depth must be an integer set between 1 .. 12\\n\");\r\n\t\t\t\t\t\tnErr++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpDet->min_tree_depth = iVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SOD_DET_MAX_TREES:\r\n\t\t\t\t\t/* Max trees */\r\n\t\t\t\t\tSyStrToInt32(pVal->zString, pVal->nByte, &iVal, 0);\r\n\t\t\t\t\tif (iVal < 100) {\r\n\t\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Maximum number of trees allowed is: 100\\n\");\r\n\t\t\t\t\t\tnErr++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpDet->max_trees = iVal;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nErr > 0) {\r\n\t\t/* Invalid configuration entry */\r\n\t\tsod_config_log_msg(&(*pTrainer), \"%d error(s) were recorded. Please check your network configuration again\\n\", nErr);\r\n\t\tfree(pDet);\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\t*ppPrivate = pDet;\r\n\treturn SOD_OK;\r\n}\r\n#ifndef SQR\r\n#define SQR(x) ((x)*(x))\r\n#endif /* SQR */\r\n#define SOD_CMP_FIXED_PT 256\r\n/*\r\n* Pixel intensity comparison function. MIT Licensed from the pico project.\r\n*/\r\nstatic int BinTest(int iNode, int rs, int cs, int ss, sod_img *pTarget)\r\n{\r\n\tconst char *zNode = (const char *)&iNode;\r\n\tint r1, r2, c1, c2, p1, p2;\r\n\tr1 = (rs * SOD_CMP_FIXED_PT + zNode[0] * ss) / SOD_CMP_FIXED_PT;\r\n\tc1 = (cs * SOD_CMP_FIXED_PT + zNode[1] * ss) / SOD_CMP_FIXED_PT;\r\n\tr2 = (rs * SOD_CMP_FIXED_PT + zNode[2] * ss) / SOD_CMP_FIXED_PT;\r\n\tc2 = (cs * SOD_CMP_FIXED_PT + zNode[3] * ss) / SOD_CMP_FIXED_PT;\r\n\t/* Check for overflow/underflow */\r\n\tr1 = MIN(MAX(0, r1), pTarget->h - 1);\r\n\tc1 = MIN(MAX(0, c1), pTarget->w - 1);\r\n\tr2 = MIN(MAX(0, r2), pTarget->h - 1);\r\n\tc2 = MIN(MAX(0, c2), pTarget->w - 1);\r\n\t/* Finally, compare */\r\n\tp1 = (unsigned char)(255 * pTarget->data[r1 * pTarget->w + c1]);\r\n\tp2 = (unsigned char)(255 * pTarget->data[r2 * pTarget->w + c2]);\r\n\treturn p1 <= p2;\r\n}\r\n/*\r\n* Run across the tree and get its output.\r\n*/\r\nstatic float DetectorGetTreeOutput(sod_tree *pTree, int rs, int cs, int ss, sod_img *pTarget)\r\n{\r\n\tint j, idx = 1;\r\n\tfor (j = 0; j < pTree->depth; j++) {\r\n\t\tint iNode = pTree->aNodes[idx - 1];\r\n\t\tidx = 2 * idx + BinTest(iNode, rs, cs, ss, &(*pTarget));\r\n\t}\r\n\treturn pTree->aLeafs[idx - (1 << pTree->depth)];\r\n}\r\n/*\r\n* Classify an image using the currently built tree\r\n*/\r\nstatic inline int DetectorClassifyBlob(sod_realnet_detector *pDet, float *score, int rs, int cs, int ss, sod_img *pTarget)\r\n{\r\n\tsod_tree *aTree = (sod_tree *)SySetBasePtr(&pDet->aTree);\r\n\tsize_t n;\r\n\t*score = 0.0f;\r\n\tfor (n = 0; n < SySetUsed(&pDet->aTree); n++) {\r\n\t\t*score += DetectorGetTreeOutput(&aTree[n], rs, cs, ss, &(*pTarget));\r\n\t\tif (*score <= aTree[n].threshold)\r\n\t\t\treturn -1;\r\n\t}\r\n\t/* False/True positive, upper layers will verify that. */\r\n\treturn 1;\r\n}\r\n/*\r\n* Split the training samples into two groups using the selected pair of pixels (iCode).\r\n*/\r\nstatic uint32_t SplitNodes(int iCode, uint32_t *aInd, sod_tr_sample *aSample, uint32_t nSample)\r\n{\r\n\tuint32_t i = 0, j = nSample - 1;\r\n\tfor (;;) {\r\n\t\twhile (!BinTest(iCode, aSample[aInd[i]].rs, aSample[aInd[i]].cs, aSample[aInd[i]].ss, &aSample[aInd[i]].sRaw)) {\r\n\t\t\tif (i == j)\r\n\t\t\t\tbreak;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\twhile (BinTest(iCode, aSample[aInd[j]].rs, aSample[aInd[j]].cs, aSample[aInd[j]].ss, &aSample[aInd[j]].sRaw)) {\r\n\t\t\tif (i == j)\r\n\t\t\t\tbreak;\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tif (i >= j) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse {\r\n\t\t\taInd[i] = aInd[i] ^ aInd[j];\r\n\t\t\taInd[j] = aInd[i] ^ aInd[j];\r\n\t\t\taInd[i] = aInd[i] ^ aInd[j];\r\n\t\t}\r\n\t}\r\n\tj = 0;\r\n\tfor (i = 0; i < nSample; ++i) {\r\n\t\tif (!BinTest(iCode, aSample[aInd[i]].rs, aSample[aInd[i]].cs, aSample[aInd[i]].ss, &aSample[aInd[i]].sRaw)) {\r\n\t\t\tj++;\r\n\t\t}\r\n\t}\r\n\treturn j;\r\n}\r\n/*\r\n* Compute split entropy.\r\n*/\r\nstatic float ComputeSplitEntropy(int iCode, double *ws, uint32_t *inds, sod_tr_sample *aSample, uint32_t nSample)\r\n{\r\n\tdouble wtvalsum0, wtvalsumsqr0, wtvalsum1, wtvalsumsqr1;\r\n\tdouble wsum, wsum0, wsum1;\r\n\tdouble wmse0, wmse1;\r\n\tuint32_t i;\r\n\twsum = wsum0 = wsum1 = wtvalsum0 = wtvalsum1 = wtvalsumsqr0 = wtvalsumsqr1 = 0.0;\r\n\tfor (i = 0; i < nSample; ++i) {\r\n\t\tsod_tr_sample *pSample = &aSample[inds[i]];\r\n\t\tif (BinTest(iCode, pSample->rs, pSample->cs, pSample->ss, &pSample->sRaw)) {\r\n\t\t\twsum1 += ws[inds[i]];\r\n\t\t\twtvalsum1 += ws[inds[i]] * pSample->tv;\r\n\t\t\twtvalsumsqr1 += ws[inds[i]] * SQR(pSample->tv);\r\n\t\t}\r\n\t\telse {\r\n\t\t\twsum0 += ws[inds[i]];\r\n\t\t\twtvalsum0 += ws[inds[i]] * pSample->tv;\r\n\t\t\twtvalsumsqr0 += ws[inds[i]] * SQR(pSample->tv);\r\n\t\t}\r\n\t\twsum += ws[inds[i]];\r\n\t}\r\n\twmse0 = wtvalsumsqr0 - SQR(wtvalsum0) / wsum0;\r\n\twmse1 = wtvalsumsqr1 - SQR(wtvalsum1) / wsum1;\r\n\treturn (float)((wmse0 + wmse1) / wsum);\r\n}\r\n/*\r\n* Generate random internal node codes.\r\n*/\r\nstatic int GenerateRandomNodeCodes(const char *zBox)\r\n{\r\n\tint iCode = 0; /* cc warning */\r\n\tchar *z;\r\n\tz = (char *)&iCode;\r\n\tz[0] = zBox[0] + rand() % (zBox[1] - zBox[0] + 1);\r\n\tz[1] = zBox[2] + rand() % (zBox[3] - zBox[2] + 1);\r\n\tz[2] = zBox[0] + rand() % (zBox[1] - zBox[0] + 1);\r\n\tz[3] = zBox[2] + rand() % (zBox[3] - zBox[2] + 1);\r\n\treturn iCode;\r\n}\r\n/*\r\n* Gen table\r\n*/\r\nstruct gen_table\r\n{\r\n\tint iCode; /* Random code */\r\n\tfloat es;  /* Error split probability */\r\n};\r\n/*\r\n* Grow a regression tree.\r\n*/\r\nstatic void DetectorGrowTree(sod_tree *pTree, int nodeidx, int cur_depth, int max_depth, double *wt, uint32_t *aInd, sod_tr_sample *aSample, uint32_t nSample)\r\n{\r\n\tuint32_t i;\r\n\tif (cur_depth >= max_depth) {\r\n\t\tint tidx = nodeidx - ((1 << max_depth) - 1); /* Index of this node on the lookup table */\r\n\t\tdouble sum, tvacc;\r\n\t\tsum = tvacc = 0.0;\r\n\t\t/* Compute the average */\r\n\t\tfor (i = 0; i < nSample; i++) {\r\n\t\t\ttvacc += wt[aInd[i]] * aSample[aInd[i]].tv;\r\n\t\t\tsum += wt[aInd[i]];\r\n\t\t}\r\n\t\tif (sum == 0.0)\r\n\t\t\tpTree->aLeafs[tidx] = 0.0f;\r\n\t\telse\r\n\t\t\tpTree->aLeafs[tidx] = (float)(tvacc / sum);\r\n\t}\r\n\telse if (nSample < 2) {\r\n\t\tpTree->aNodes[nodeidx] = 0;\r\n\t\t/* Recurse on this subtree until we reach a leaf node */\r\n\t\tDetectorGrowTree(pTree, 2 * nodeidx + 1, cur_depth + 1, max_depth, wt, aInd, aSample, nSample);\r\n\t\tDetectorGrowTree(pTree, 2 * nodeidx + 2, cur_depth + 1, max_depth, wt, aInd, aSample, nSample);\r\n\t}\r\n\telse {\r\n\t\tint best;\r\n\t\tfloat emin;\r\n#define GEN_TABLE_RAND 1024\r\n\t\tstruct gen_table aGen[GEN_TABLE_RAND];\r\n\t\tfor (i = 0; i < GEN_TABLE_RAND; i++) {\r\n\t\t\tstruct gen_table *pGen = &aGen[i];\r\n\t\t\tpGen->iCode = GenerateRandomNodeCodes(pTree->pDet->bbox);\r\n\t\t\tpGen->es = ComputeSplitEntropy(pGen->iCode, wt, aInd, aSample, nSample);\r\n\t\t}\r\n\t\t/* Grab the best candidate for this internal node */\r\n\t\tbest = aGen[0].iCode;\r\n\t\temin = aGen[0].es;\r\n\t\tfor (i = 1; i < GEN_TABLE_RAND; i++) {\r\n\t\t\tif (emin > aGen[i].es) {\r\n\t\t\t\temin = aGen[i].es;\r\n\t\t\t\tbest = aGen[i].iCode;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpTree->aNodes[nodeidx] = best;\r\n\t\t/* Split the subtree */\r\n\t\ti = SplitNodes(best, aInd, aSample, nSample);\r\n\t\tDetectorGrowTree(&(*pTree), 2 * nodeidx + 1, cur_depth + 1, max_depth, wt, &aInd[0], aSample, i);\r\n\t\tDetectorGrowTree(&(*pTree), 2 * nodeidx + 2, cur_depth + 1, max_depth, wt, &aInd[i], aSample, nSample - i);\r\n\t}\r\n}\r\n/*\r\n* Build a regression tree for the current epoch.\r\n*/\r\nstatic int DetectorBuildTree(sod_tree *pTree, int depth, double *wt, sod_tr_sample *aSample, size_t nSample)\r\n{\r\n\tuint32_t nNode = (1 << depth) - 1;\r\n\tuint32_t i, *aInd;\r\n\tfloat *table;\r\n\tint *pBin;\r\n\t/* Allocate the necessary tables */\r\n\tpBin = (int *)malloc(nNode * sizeof(int));\r\n\tif (pBin == 0) return SOD_ABORT;\r\n\ttable = (float *)malloc((1 << depth) * sizeof(float));\r\n\tif (table == 0) {\r\n\t\tfree(pBin);\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\taInd = (uint32_t *)malloc((uint32_t)nSample * sizeof(uint32_t));\r\n\tif (aInd == 0) {\r\n\t\tfree(pBin);\r\n\t\tfree(table);\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\t/* Initialize */\r\n\tmemset(pBin, 0, nNode * sizeof(int));\r\n\tmemset(table, 0, (1 << depth) * sizeof(float)); /* Please ignore the annoying VS2017 compiler warning on 32-bit shift */\r\n\tpTree->aNodes = pBin;\r\n\tpTree->aLeafs = table;\r\n\tpTree->depth = depth;\r\n\t/* Build */\r\n\tfor (i = 0; i < (uint32_t)nSample; i++) {\r\n\t\taInd[i] = i;\r\n\t}\r\n\tDetectorGrowTree(&(*pTree), 0, 0, depth, wt, aInd, aSample, (uint32_t)nSample);\r\n\t/* Cleanup */\r\n\tfree(aInd);\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Learn a new stage.\r\n*/\r\nstatic int DetectorLearnNewStage(sod_realnet_detector *pDet, float mintpr, float maxfpr, size_t maxtree, size_t nPos, size_t nNeg)\r\n{\r\n\tsod_realnet_trainer *pTrainer = pDet->pTrainer;\r\n\tsod_tr_sample *aSample = (sod_tr_sample *)SySetBasePtr(&pTrainer->aSample);\r\n\tsize_t i, nSample = SySetUsed(&pTrainer->aSample);\r\n\tfloat threshold = 0.0f;\r\n\tfloat tpr, fpr;\r\n\tdouble *wt;\r\n\t/* Allocate the weights table */\r\n\twt = (double *)malloc(nSample * sizeof(double));\r\n\tif (wt == 0) {\r\n\t\tsod_config_log_msg(pTrainer, \"Running out-of-memory...aborting\\n\");\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\tmaxtree = SySetUsed(&pDet->aTree) + maxtree;\r\n\tfpr = 1.0f;\r\n\tnNeg = SySetUsed(&pTrainer->aSample) - nPos;\r\n\t/* Start the learning process */\r\n\tsod_config_log_msg(pTrainer, \"Learning new detection stage for epoch#%d\\n\", pTrainer->nEpoch);\r\n\twhile (SySetUsed(&pDet->aTree) < maxtree && fpr > maxfpr) {\r\n\t\tfloat end, start = pTrainer->pVfs->xTicks();\r\n\t\tsod_tr_sample *pEntry;\r\n\t\tdouble ws = 0.0;\r\n\t\tsod_tree sTree;\r\n\t\t/* Compute the weights first */\r\n\t\tfor (i = 0; i < nSample; ++i) {\r\n\t\t\tpEntry = &aSample[i];\r\n\t\t\tif (pEntry->tv > 0) {\r\n\t\t\t\twt[i] = exp(-1.0 * pEntry->score) / nPos;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\twt[i] = exp(+1.0 * pEntry->score) / nNeg;\r\n\t\t\t}\r\n\t\t\tws += wt[i];\r\n\t\t}\r\n\t\t/* Compute the average */\r\n\t\tfor (i = 0; i < nSample; ++i) wt[i] /= ws;\r\n\t\t/* Build the tree */\r\n\t\tmemset(&sTree, 0, sizeof(sod_tree));\r\n\t\tsTree.pDet = pDet;\r\n\t\tif (SOD_OK != DetectorBuildTree(&sTree, pDet->min_tree_depth, wt, aSample, nSample)) {\r\n\t\t\t/* Mostly out of memory, abort */\r\n\t\t\tfree(wt);\r\n\t\t\treturn SOD_ABORT;\r\n\t\t}\r\n\t\t/* Set a low confidence threshold first */\r\n\t\tsTree.threshold = -1337.0f /* -FLT_MAX */;\r\n\t\t/* Insert */\r\n\t\tif (SOD_OK != SySetPut(&pDet->aTree, &sTree)) {\r\n\t\t\tfree(sTree.aNodes);\r\n\t\t\tfree(sTree.aLeafs);\r\n\t\t\tfree(wt);\r\n\t\t\tsod_config_log_msg(pTrainer, \"Running out-of-memory...aborting\\n\");\r\n\t\t\treturn SOD_ABORT;\r\n\t\t}\r\n\t\t/* Update score */\r\n\t\tfor (i = 0; i < nSample; ++i) {\r\n\t\t\tfloat score;\r\n\t\t\tpEntry = &aSample[i];\r\n\t\t\tscore = DetectorGetTreeOutput(&sTree, pEntry->rs, pEntry->cs, pEntry->ss, &pEntry->sRaw);\r\n\t\t\tpEntry->score += score;\r\n\t\t}\r\n\t\t/* Calculate threshold */\r\n\t\tthreshold = 5.0f;\r\n\t\tdo {\r\n\t\t\tuint32_t ntps, nfps;\r\n\t\t\tntps = nfps = 0;\r\n\t\t\t/* Adjust threshold */\r\n\t\t\tthreshold -= 0.005f;\r\n\t\t\tfor (i = 0; i < nSample; ++i) {\r\n\t\t\t\tpEntry = &aSample[i];\r\n\t\t\t\tif (pEntry->tv > 0 && pEntry->score > threshold) ntps++;\r\n\t\t\t\tif (pEntry->tv < 0 && pEntry->score > threshold) nfps++;\r\n\t\t\t}\r\n\t\t\ttpr = ntps / (float)nPos;\r\n\t\t\tfpr = nfps / (float)nNeg;\r\n\t\t} while (tpr < mintpr);\r\n\t\t/* Tree generated, log that */\r\n\t\tend = pTrainer->pVfs->xTicks();\r\n\t\tsod_config_log_msg(pTrainer, \"Tree#%d of depth %d built in %d seconds: FPR: %f TPR: %f\\n\",\r\n\t\t(int)SySetUsed(&pDet->aTree),\r\n\t\tpDet->min_tree_depth,\r\n\t\t(int)(end - start),\r\n\t\tfpr,\r\n\t\ttpr\r\n\t\t);\r\n\t}\r\n\tif (SySetUsed(&pDet->aTree) > 0) {\r\n\t\t/* Set the final threshold */\r\n\t\tsod_tree *aTree = (sod_tree *)SySetBasePtr(&pDet->aTree);\r\n\t\taTree[SySetUsed(&pDet->aTree) - 1].threshold = threshold;\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Final threshold value for tree#%d set to: %f\\n\",\r\n\t\t\t(int)SySetUsed(&pDet->aTree),\r\n\t\t\tthreshold\r\n\t\t);\r\n\t}\r\n\tif (fpr > maxfpr && pDet->min_tree_depth < pDet->max_tree_depth) {\r\n\t\t/* Increment the tree depth due to high false positive rate */\r\n\t\t/* \r\n\t\tpDet->min_tree_depth++;\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Tree depth incremented to %d due to high false positive rate\\n\", pDet->min_tree_depth);\r\n\t\t*/\r\n\t}\r\n\t/* Cleanup */\r\n\tfree(wt);\r\n\treturn SOD_OK;\r\n}\r\n/* Directory recursion limit while gathering samples. */\r\n#ifndef SOD_MAX_RECURSE_COUNT\r\n#define SOD_MAX_RECURSE_COUNT 3\r\n#endif /* SOD_MAX_RECURSE_COUNT */\r\nstatic float aug_rand(float M, float N)\r\n{\r\n\treturn M + (rand() / (RAND_MAX / (N - M)));\r\n}\r\n/*\r\n* Collect image samples from a given path.\r\n* Only png, jpeg, bmp, pgm, pbm image format are allowed.\r\n*/\r\nstatic int DetectorCollectSamples(sod_realnet_detector *pDet, const char *zPath, SOD_TR_SAMPLE_TYPE iType, int recurse, int rec_count)\r\n{\r\n\tstatic const char *zAllowed[] = { \"png\",\"jpg\",\"jpeg\",\"bmp\",\"pgm\",\"ppm\",\"pbm\", 0 /*Marker*/ };\r\n\tsod_realnet_trainer *pTrainer = pDet->pTrainer;\r\n\tconst sod_vfs *pVfs = pTrainer->pVfs;\r\n\tsod_path_info sPath;\r\n\tSySet *\tpTarget;\r\n\tSyBlob sReader;\r\n\tvoid *pHandle;\r\n\tsod_img sRaw;\r\n\tint i, rc;\r\n\t/* Iterate over the target directory */\r\n\trc = pVfs->xOpenDir(zPath, &pHandle);\r\n\tif (rc != SOD_OK) {\r\n\t\tsod_config_log_msg(&(*pTrainer), \"IO error while entering directory: '%s'\\n\", zPath);\r\n\t\treturn rc;\r\n\t}\r\n\tSyBlobInit(&sReader);\r\n\tsod_config_log_msg(&(*pTrainer), \"Entering directory: '%s'..\\n\", zPath);\r\n\tpVfs->xChdir(zPath);\r\n\tif (iType == SOD_TR_SAMPLE_POS) {\r\n\t\tpTarget = &pTrainer->aPos;\r\n\t}\r\n\telse {\r\n\t\tpTarget = (iType == SOD_TR_SAMPLE_TEST ? &pTrainer->aTest : &pTrainer->aNeg);\r\n\t}\r\n\twhile (pVfs->xDirRead(pHandle, &sReader) == SOD_OK) {\r\n\t\tconst char *zEntry = (const char *)SyBlobData(&sReader);\r\n\t\tsize_t nByte = SyBlobLength(&sReader);\r\n\t\tsod_img tmp;\r\n\t\t/* Reset the blob */\r\n\t\tSyBlobReset(&sReader);\r\n\t\tif (pVfs->xIsdir(zEntry)) {\r\n\t\t\t/* Entry is a directory, recurse if allowed */\r\n\t\t\tif (recurse) {\r\n\t\t\t\tif (rec_count < SOD_MAX_RECURSE_COUNT) {\r\n\t\t\t\t\t/* Recurse */\r\n\t\t\t\t\trec_count++;\r\n\t\t\t\t\tif (SOD_OK == DetectorCollectSamples(&(*pDet), zEntry, iType, 1, rec_count)) {\r\n\t\t\t\t\t\t/* Return to the upper directory */\r\n\t\t\t\t\t\tpVfs->xChdir(\"../\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\trec_count--;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Recursion limit (%d) reached while entering directory: '%s'..aborting\\n\", SOD_MAX_RECURSE_COUNT, zEntry);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* Ignore */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Make sure the file is of the correct extension */\r\n\t\tExtractPathInfo(zEntry, nByte, &sPath);\r\n\t\trc = 0;\r\n\t\tfor (i = 0; zAllowed[i] != 0; i++) {\r\n\t\t\tif (CmpSyString(&sPath.sExtension, zAllowed[i]) == 0) {\r\n\t\t\t\trc = 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!rc) {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"Discarding file not of the expected extension: '%s'\\n\", zEntry);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (pDet->max_samples_collect > 0 && pTarget->nUsed >= pDet->max_samples_collect) {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"Maximum samples to collect limit reached: %u..stopping\\n\", (unsigned int)pTarget->nUsed);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Prepare the insertion */\r\n\t\tmemset(&sRaw, 0, sizeof(sod_img));\r\n\t\t/* Load the image */\r\n\t\tsRaw = sod_img_load_from_file(zEntry, 1);\r\n\t\tif (sRaw.data == 0) {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"Cannot load sample: '%s'..ignoring\\n\", zEntry);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Insert in the target set */\r\n\t\trc = SySetPut(pTarget, (const void *)&sRaw);\r\n\t\tif (rc != SOD_OK) {\r\n\t\t\t/* Avoid memory leaks */\r\n\t\t\tsod_free_image(sRaw);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (iType == SOD_TR_SAMPLE_POS) {\r\n\t\t\t\t/* Sum-up the average */\r\n\t\t\t\tif (pDet->data_aug) {\r\n\t\t\t\t\tfloat rand = aug_rand(1.0f, 40.0f);\r\n\t\t\t\t\ttmp = sod_rotate_image(sRaw, rand);\r\n\t\t\t\t\tif (tmp.data) {\r\n\t\t\t\t\t\tsRaw = tmp;\r\n\t\t\t\t\t\trc = SySetPut(pTarget, (const void *)&sRaw);\r\n\t\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\t\tsod_free_image(sRaw);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttmp = sod_copy_image(sRaw);\r\n\t\t\t\t\tif (tmp.data) {\r\n\t\t\t\t\t\tsod_flip_image(tmp);\r\n\t\t\t\t\t\tsRaw = tmp;\r\n\t\t\t\t\t\trc = SySetPut(pTarget, (const void *)&sRaw);\r\n\t\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\t\tsod_free_image(tmp);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttmp = sod_copy_image(sRaw);\r\n\t\t\t\t\tif (tmp.data) {\r\n\t\t\t\t\t\trand = aug_rand(0.1f, 1.0f);\r\n\t\t\t\t\t\tsod_scale_image(tmp, rand);\r\n\t\t\t\t\t\tsRaw = tmp;\r\n\t\t\t\t\t\trc = SySetPut(pTarget, (const void *)&sRaw);\r\n\t\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\t\tsod_free_image(tmp);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttmp = sod_copy_image(sRaw);\r\n\t\t\t\t\tif (tmp.data) {\r\n\t\t\t\t\t\trand = aug_rand(0.1f, 1.0f);\r\n\t\t\t\t\t\tsod_translate_image(tmp, rand);\r\n\t\t\t\t\t\tsRaw = tmp;\r\n\t\t\t\t\t\trc = SySetPut(pTarget, (const void *)&sRaw);\r\n\t\t\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t\t\tsod_free_image(tmp);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pTarget->nUsed > 0 && ((pTarget->nUsed % 300) == 0)) {\r\n\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Over %u %s samples were collected so far..\\n\", (unsigned int)pTarget->nUsed, (iType == SOD_TR_SAMPLE_POS ? \"positive\" : \"negative/test\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Cleanup */\r\n\tpVfs->xCloseDir(pHandle);\r\n\tSyBlobRelease(&sReader);\r\n\tif (rec_count < 1) {\r\n\t\tif (pTarget->nUsed < 1) {\r\n\t\t\tif (iType == SOD_TR_SAMPLE_POS) {\r\n\t\t\t\tsod_config_log_msg(&(*pTrainer), \"no positive samples were collected on directory: '%s'..aborting\\n\", zPath);\r\n\t\t\t\treturn SOD_ABORT;\r\n\t\t\t}\r\n\t\t\t/* Does not hurt when working with test samples */\r\n\t\t\treturn SOD_OK;\r\n\t\t}\r\n\t\t/* log */\r\n\t\tsod_config_log_msg(&(*pTrainer), \"%u %s samples were collected on directory: '%s'\\n\", (unsigned int)pTarget->nUsed, (iType == SOD_TR_SAMPLE_POS ? \"positive\" : \"negative/test\"), zPath);\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Arrange the N elements of ARRAY in random order. Only effective if N is much smaller than RAND_MAX;\r\n* if this may not be the case, use a better random number generator.\r\n*/\r\nstatic void shuffleImgArray(sod_img *array, size_t n)\r\n{\r\n\tif (n > 1)\r\n\t{\r\n\t\tsize_t i;\r\n\t\tfor (i = 0; i < n - 1; i++)\r\n\t\t{\r\n\t\t\tsize_t j = i + rand() / (RAND_MAX / (n - i) + 1);\r\n\t\t\tsod_img t = array[j];\r\n\t\t\tarray[j] = array[i];\r\n\t\t\tarray[i] = t;\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* Load training sample for the current Epoch.\r\n*/\r\nstatic float DetectorPrepareEpochSamples(sod_realnet_detector *pDet, size_t *nPos, size_t *nNeg)\r\n{\r\n\tsod_realnet_trainer *pTrainer = pDet->pTrainer;\r\n\tfloat score = 0.0f;\r\n\tsod_tr_sample sTr;\r\n\tfloat etpr, efpr;\r\n\tsod_img *aRaw;\r\n\tsize_t nc, i;\r\n\tint round, rc;\r\n\tsod_config_log_msg(&(*pTrainer), \"Sampling started [epoch#%d]\\n\", ++pTrainer->nEpoch);\r\n\t/* Reset the collector */\r\n\tSySetReset(&pTrainer->aSample);\r\n\t/* Iterate through the positive sample first */\r\n\taRaw = (sod_img *)SySetBasePtr(&pTrainer->aPos);\r\n\tfor (i = 0; i < SySetUsed(&pTrainer->aPos); ++i) {\r\n\t\tsod_img *pRaw = &aRaw[i];\r\n\t\t/* Prepare classification */\r\n\t\tmemset(&sTr, 0, sizeof(sod_tr_sample));\r\n\t\tsTr.id = SOD_TR_SAMPLE_POS;\r\n\t\tsTr.score = score;\r\n\t\tsTr.tv = +1;\r\n\t\tsTr.sRaw = *pRaw;\r\n\t\tsTr.rs = pRaw->h / 2;\r\n\t\tsTr.cs = pRaw->w / 2;\r\n\t\tsTr.ss = 2 * MIN(pRaw->w, pRaw->h) / 3;\r\n\t\t/* Classify */\r\n\t\trc = DetectorClassifyBlob(&(*pDet), &score, sTr.rs, sTr.cs, sTr.ss, pRaw);\r\n\t\tif (rc != 1) {\r\n\t\t\t/* Sadly mistaken as a false negative, cannot recover from this */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tSySetPut(&pTrainer->aSample, (const void *)&sTr);\r\n\t}\r\n\t/* Total positive samples for this epoch */\r\n\t*nPos = SySetUsed(&pTrainer->aSample);\r\n\tsod_config_log_msg(&(*pTrainer), \"%u positive samples were prepared for epoch#%d\\n\", (unsigned int)*nPos, pTrainer->nEpoch);\r\n\t*nNeg = nc = 0;\r\n\tif (SySetUsed(&pTrainer->aNeg) > 0) {\r\n\t\t/* Shuffle the negative samples array */\r\n\t\taRaw = (sod_img *)SySetBasePtr(&pTrainer->aNeg);\r\n\t\tshuffleImgArray(aRaw, SySetUsed(&pTrainer->aNeg));\r\n\t\t/* Iterate through the negative samples */\r\n\t\tround = 0;\r\n\t\ti = 0;\r\n\t\tfor (;;) {\r\n\t\t\tsod_img *pRaw = &aRaw[i];\r\n\t\t\tsod_tr_sample *pSam;\r\n\t\t\tint r, c, s;\r\n\t\t\t/* Data mine hard negatives */\r\n\t\t\tr = rand() % pRaw->h;\r\n\t\t\tc = rand() % pRaw->w;\r\n\t\t\t/* sample the size of a random object in the pool */\r\n\t\t\tpSam = SySetFetch(&pTrainer->aSample, rand() % *nPos);\r\n\t\t\ts = pSam->ss;\r\n\t\t\t/* Classify */\r\n\t\t\trc = DetectorClassifyBlob(&(*pDet), &score, r, c, s, pRaw);\r\n\t\t\tif (rc == 1) {\r\n\t\t\t\tif (*nNeg >= *nPos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t/* We have a false positive, prepare the insertion */\r\n\t\t\t\tmemset(&sTr, 0, sizeof(sod_tr_sample));\r\n\t\t\t\tsTr.id = SOD_TR_SAMPLE_NEG;\r\n\t\t\t\tsTr.score = score;\r\n\t\t\t\tsTr.tv = -1;\r\n\t\t\t\tsTr.sRaw = *pRaw;\r\n\t\t\t\tsTr.rs = r;\r\n\t\t\t\tsTr.cs = c;\r\n\t\t\t\tsTr.ss = s;\r\n\t\t\t\tSySetPut(&pTrainer->aSample, (const void *)&sTr);\r\n\t\t\t\t(*nNeg)++;\r\n\t\t\t}\r\n\t\t\tnc++;\r\n\t\t\ti++;\r\n\t\t\tif (i >= SySetUsed(&pTrainer->aNeg)) {\r\n\t\t\t\tround++;\r\n\t\t\t\tif (round > 10000 ) {\r\n\t\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Too many background image collection rounds (> 10K). Perhaps should you stop training and test the accuracy of your model?\\n\");\r\n\t\t\t\t\tround = 0;\r\n\t\t\t\t}\r\n\t\t\t\t/* Reset back */\r\n\t\t\t\ti = 0;\r\n\t\t\t\t/* Shuffle again */\r\n\t\t\t\tshuffleImgArray(aRaw, SySetUsed(&pTrainer->aNeg));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tnc = 1;\r\n\t}\r\n\t/* Calculate the epoch true/false positive rate */\r\n\tetpr = *nPos / ((float)SySetUsed(&pTrainer->aPos));\r\n\tefpr = (float)(*nNeg / (double)nc);\r\n\r\n\tsod_config_log_msg(&(*pTrainer),\r\n\t\t\"sampling finished [Epoch#%d]:\\n\\tTrue Positive Rate (TPR): %0.8f\\n\\tFalse Positive Rate (FPR): %0.8f\\n\",\r\n\t\tpTrainer->nEpoch,\r\n\t\tetpr,\r\n\t\tefpr\r\n\t);\r\n\treturn efpr;\r\n}\r\n/*\r\n* Generate a binary classifier to be used with the realnet network.\r\n*/\r\nstatic int DetectorSaveCascadetoDisk(sod_realnet_detector *pDet)\r\n{\r\n\tint nTrees = (int)SySetUsed(&pDet->aTree);\r\n\tsod_tree *aTrees;\r\n\tint i;\r\n\tFILE* file;\r\n\tif (pDet->pTrainer->zOutPath == 0) {\r\n\t\t/* No output model path were specified, return */\r\n\t\treturn SOD_OK;\r\n\t}\r\n\tif (nTrees < 1) {\r\n\t\t/* No regression trees were actually generated, return immediately */\r\n\t\treturn SOD_OK;\r\n\t}\r\n\tfile = fopen(pDet->pTrainer->zOutPath, \"wb\");\r\n\tif (!file) {\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\t/* Magic headers */\r\n\tfwrite(&pDet->version, sizeof(int32_t), 1, file);\r\n\tfwrite(&pDet->bbox[0], sizeof(int8_t), 4, file);\r\n\tfwrite(&pDet->min_tree_depth, sizeof(int), 1, file);\r\n\tfwrite(&nTrees, sizeof(int), 1, file);\r\n\t/* Generated tress */\r\n\taTrees = SySetBasePtr(&pDet->aTree);\r\n\tfor (i = 0; i<nTrees; ++i)\r\n\t{\r\n\t\tsod_tree *pTree = &aTrees[i];\r\n\t\t/* Nodes, lookup table and thresholds. */\r\n\t\tfwrite(pTree->aNodes, sizeof(int32_t), (1 << pTree->depth) - 1, file);\r\n\t\tfwrite(pTree->aLeafs, sizeof(float), 1 << pTree->depth, file);\r\n\t\tfwrite(&pTree->threshold, sizeof(float), 1, file);\r\n\t}\r\n\tfclose(file);\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Exec method for the [detector] layer.\r\n*/\r\nstatic int detector_layer_exec(void *pPrivate, sod_paths *pPath)\r\n{\r\n\tsod_realnet_detector *pDet = (sod_realnet_detector *)pPrivate;\r\n\tsod_realnet_trainer *pTr = pDet->pTrainer;\r\n\tfloat xEnd, xStart;\r\n\tsize_t nPos, nNeg;\r\n\tfloat fpr;\r\n\tint rc;\r\n\tif (pPath == 0) {\r\n\t\tsod_config_log_msg(pTr, \"Missing training samples paths for detector [%z]..aborting\\n\", &pDet->sName);\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\t/* Change root path if any */\r\n\tif (SyStringLength(&pPath->sRootPath) > 0) {\r\n\t\tpTr->pVfs->xChdir(pPath->sRootPath.zString);\r\n\t}\r\n\tpDet->max_samples_collect = pPath->max_samples_collect;\r\n\t/* Collect samples first */\r\n\tsod_config_log_msg(pTr, \"Collecting positive samples..\\n\");\r\n\trc = DetectorCollectSamples(pDet, pPath->sPosPath.zString, SOD_TR_SAMPLE_POS, pPath->recurse, 0);\r\n\tif (rc != SOD_OK) return rc;\r\n\tsod_config_log_msg(pTr, \"Collecting negative samples..\\n\");\r\n\trc = DetectorCollectSamples(pDet, pPath->sNegPath.zString, SOD_TR_SAMPLE_NEG, pPath->recurse, 0);\r\n\tif (rc != SOD_OK) return rc;\r\n\tif (SyStringLength(&pPath->sTestPath) > 0) {\r\n\t\tsod_config_log_msg(pTr, \"Collecting test samples..\\n\");\r\n\t\t/* Not so fatal if this fail */\r\n\t\tDetectorCollectSamples(pDet, pPath->sTestPath.zString, SOD_TR_SAMPLE_TEST, pPath->recurse, 0);\r\n\t}\r\n\t/* Start the learning process */\r\n\tsod_config_log_msg(pTr, \"Learning process started for classifier [%z]\\n\", &pDet->sName);\r\n\txStart = pTr->pVfs->xTicks();\r\n\r\n\tDetectorPrepareEpochSamples(pDet, &nPos, &nNeg);\r\n\trc = DetectorLearnNewStage(pDet, 0.9800f, 0.5f, 4, nPos, nNeg);\r\n\tif (rc != SOD_OK) return rc;\r\n\r\n\tDetectorPrepareEpochSamples(pDet, &nPos, &nNeg);\r\n\trc = DetectorLearnNewStage(pDet, 0.9850f, 0.5f, 8, nPos, nNeg);\r\n\tif (rc != SOD_OK) return rc;\r\n\r\n\tDetectorPrepareEpochSamples(pDet, &nPos, &nNeg);\r\n\trc = DetectorLearnNewStage(pDet, 0.9900f, 0.5f, 16, nPos, nNeg);\r\n\tif (rc != SOD_OK) return rc;\r\n\r\n\tDetectorPrepareEpochSamples(pDet, &nPos, &nNeg);\r\n\trc = DetectorLearnNewStage(pDet, 0.9950f, 0.5f, 32, nPos, nNeg);\r\n\tif (rc != SOD_OK) return rc;\r\n\t/* Save the cascade */\r\n\tif (SOD_OK != DetectorSaveCascadetoDisk(pDet)) {\r\n\t\tsod_config_log_msg(pTr, \"IO error while saving cascade to disk..stopping\\n\");\r\n\t\treturn rc;\r\n\t}\r\n\r\n\t/* Train until the target FPR is reached */\r\n\tfor (;;) {\r\n\t\tfpr = DetectorPrepareEpochSamples(pDet, &nPos, &nNeg);\r\n\t\tif (fpr <= pDet->target_fpr) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\trc = DetectorLearnNewStage(pDet, pDet->tpr, pDet->fpr, 64, nPos, nNeg);\r\n\t\tif (rc != SOD_OK) return rc;\r\n\t\tif (SOD_OK != DetectorSaveCascadetoDisk(pDet)) {\r\n\t\t\tsod_config_log_msg(pTr, \"IO error while saving cascade to disk\\n\");\r\n\t\t}\r\n\t\tif (pDet->max_trees > 0 && (int)SySetUsed(&pDet->aTree) > pDet->max_trees) {\r\n\t\t\tsod_config_log_msg(pTr, \"Maximum number of allowed tree in the classifier [%z] is reached..stopping\\n\", &pDet->sName);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\txEnd = pTr->pVfs->xTicks();\r\n\tsod_config_log_msg(pTr, \"Target FPR for the classifier [%z] reached in %u seconds. Final cascade classifier (%u Trees) already generated..training done!\", &pDet->sName, (unsigned int)(xEnd - xStart), (unsigned int)SySetUsed(&pDet->aTree));\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Release method for the [detector] layer.\r\n*/\r\nstatic void detector_layer_release(void *pPrivate)\r\n{\r\n\tif (pPrivate) {\r\n\t\tsod_realnet_detector *pDet = (sod_realnet_detector *)pPrivate;\r\n\t\tsod_tree *aTree = (sod_tree *)SySetBasePtr(&pDet->aTree);\r\n\t\tsize_t i;\r\n\t\tfor (i = 0; i < SySetUsed(&pDet->aTree); i++) {\r\n\t\t\tsod_tree *pTree = &aTree[i];\r\n\t\t\tfree(pTree->aNodes);\r\n\t\t\tfree(pTree->aLeafs);\r\n\t\t}\r\n\t\tSySetRelease(&pDet->aTree);\r\n\t\tfree(pDet);\r\n\t}\r\n}\r\n/*\r\n* Each built-in layer is defined by an instance of the following\r\n* structure.\r\n*/\r\ntypedef struct sod_builtin_layer sod_builtin_layer;\r\nstruct sod_builtin_layer {\r\n\tconst char *zName; /* Layer name */\r\n\tProcLayerLoad    xLoad; /* Load callback */\r\n\tProcLayerExec    xExec; /* Exec callback */\r\n\tProcLayerRelease xRelease; /* Release callback */\r\n}aBuiltLayers[] = {\r\n\t{ \"paths\", paths_layer_load, 0, 0 },\r\n\t{ \"path\",  paths_layer_load, 0, 0 }, /* Alias for [paths] */\r\n\t{ \"detector\", detector_layer_load, detector_layer_exec, detector_layer_release },\r\n\t{ \"det\",      detector_layer_load, detector_layer_exec, detector_layer_release }, /* Alias for [detector] */\r\n};\r\n/*\r\n* Register the built-in layers.\r\n*/\r\nstatic void sod_realnet_trainer_register_builtin_layers(sod_realnet_trainer *pTrainer)\r\n{\r\n\tsize_t n;\r\n\tfor (n = 0; n < sizeof(aBuiltLayers) / sizeof(aBuiltLayers[0]); ++n) {\r\n\t\tsod_layer sLayer;\r\n\t\t/* Fill in */\r\n\t\tSyStringInitFromBuf(&sLayer.sName, aBuiltLayers[n].zName, strlen(aBuiltLayers[n].zName));\r\n\t\tsLayer.xLoad = aBuiltLayers[n].xLoad;\r\n\t\tsLayer.xExec = aBuiltLayers[n].xExec;\r\n\t\tsLayer.xRelease = aBuiltLayers[n].xRelease;\r\n\t\tsLayer.pLayerData = 0;\r\n\t\t/* Register this one */\r\n\t\tSySetPut(&pTrainer->aBuiltin, (const void *)&sLayer);\r\n\t}\r\n}\r\n/*\r\n* Find a layer from the set of built-in one.\r\n*/\r\nstatic sod_layer * sod_find_builtin_layer(sod_realnet_trainer *pTrainer, SyString *pConf)\r\n{\r\n\tsod_layer *aLayers = SySetBasePtr(&pTrainer->aBuiltin);\r\n\tsize_t n;\r\n\tfor (n = 0; n < SySetUsed(&pTrainer->aBuiltin); ++n) {\r\n\t\tsod_layer *pLayer = &aLayers[n];\r\n\t\tSyString *pName = &pLayer->sName;\r\n\t\tif (pConf->nByte == pName->nByte && sy_strnicmp(pConf->zString, pName->zString, pConf->nByte) == 0) {\r\n\t\t\t/* found layer */\r\n\t\t\treturn pLayer;\r\n\t\t}\r\n\t}\r\n\t/* No such layer */\r\n\treturn 0;\r\n}\r\n/*\r\n* Release the training samples from a given set.\r\n*/\r\nstatic void sod_realnet_release_samples(SySet *pSet)\r\n{\r\n\tsod_img *aSample = (sod_img *)SySetBasePtr(pSet);\r\n\tsize_t n;\r\n\tfor (n = 0; n < SySetUsed(pSet); n++) {\r\n\t\tsod_free_image(aSample[n]);\r\n\t}\r\n\tSySetRelease(&(*pSet));\r\n}\r\n/*\r\n* @Trainer Public Interface\r\n*/\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_train_init(sod_realnet_trainer ** ppOut)\r\n{\r\n\tsod_realnet_trainer *pTrainer = malloc(sizeof(sod_realnet_trainer));\r\n\t*ppOut = pTrainer;\r\n\tif (pTrainer == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\t/* Zero the structure */\r\n\tmemset(pTrainer, 0, sizeof(sod_realnet_trainer));\r\n\t/* Init */\r\n\tSySetInit(&pTrainer->aBuiltin, sizeof(sod_layer));\r\n\tSySetInit(&pTrainer->aSample, sizeof(sod_tr_sample));\r\n\tSyBlobInit(&pTrainer->sWorker);\r\n\tSySetInit(&pTrainer->aPaths, sizeof(sod_paths));\r\n\t/* Training samples */\r\n\tSySetInit(&pTrainer->aPos, sizeof(sod_img));\r\n\tSySetInit(&pTrainer->aNeg, sizeof(sod_img));\r\n\tSySetInit(&pTrainer->aTest, sizeof(sod_img));\r\n\tpTrainer->pVfs = sodExportBuiltinVfs();\r\n\t/* Register the built-in layers */\r\n\tsod_realnet_trainer_register_builtin_layers(&(*pTrainer));\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_train_config(sod_realnet_trainer * pTrainer, SOD_REALNET_TRAINER_CONFIG op, ...)\r\n{\r\n\tint rc = SOD_OK;\r\n\tva_list ap;\r\n\tva_start(ap, op);\r\n\tswitch (op) {\r\n\tcase SOD_REALNET_TR_LOG_CALLBACK: {\r\n\t\t/* Trainer log callback */\r\n\t\tProcLogCallback xLog = va_arg(ap, ProcLogCallback);\r\n\t\tvoid *pLogData = va_arg(ap, void *);\r\n\t\t/* Register the callback */\r\n\t\tpTrainer->xLog = xLog;\r\n\t\tpTrainer->pLogData = pLogData;\r\n\t}\r\n\tbreak;\r\n\tcase SOD_REALNET_TR_OUTPUT_MODEL: {\r\n\t\tconst char *zPath = va_arg(ap, const char *);\r\n\t\tpTrainer->zOutPath = zPath;\r\n\t}\r\n\tbreak;\r\n\tdefault:\r\n\t\trc = SOD_UNSUPPORTED;\r\n\t\tbreak;\r\n\t}\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_train_start(sod_realnet_trainer *pTrainer, const char * zConf)\r\n{\r\n\tsod_config_layer *pConf;\r\n\tvoid *pMap = 0;\r\n\tint nAbort = 0;\r\n\tsize_t sz;\r\n\tint rc;\r\n\tstatic const char zBanner[] = {\r\n\t\t\"============================================================\\n\"\r\n\t\t\"RealNets Model Training                                     \\n\"\r\n\t\t\"         Copyright (C) Symisc Systems. All rights reserved  \\n\"\r\n\t\t\"============================================================\\n\"\r\n\t};\r\n\t/* Check if we are dealing with a memory buffer or with a file path */\r\n\twhile (isspace(zConf[0])) zConf++;\r\n\t/* Assume a null terminated memory buffer */\r\n\tsz = strlen(zConf);\r\n\tif (zConf[0] != '[' || zConf[0] != '#' || zConf[0] != ';' || sz < 170) {\r\n\t\t/* Assume a file path, open read-only  */\r\n\t\trc = pTrainer->pVfs->xMmap(zConf, &pMap, &sz);\r\n\t\tif (rc != SOD_OK) {\r\n\t\t\tsod_config_log_msg(&(*pTrainer), \"Error while reading training configuration file: '%s'\\n\", zConf);\r\n\t\t\treturn SOD_IOERR;\r\n\t\t}\r\n\t\tzConf = (const char *)pMap;\r\n\t}\r\n\tsod_config_log_msg(&(*pTrainer), zBanner);\r\n\t/* Parse the configuration */\r\n\trc = sod_parse_config(&(*pTrainer), zConf, sz);\r\n\tif (rc != SOD_OK) {\r\n\t\t/* Something went wrong, log should tell you more */\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Parsing finished with errors..aborting\\n\");\r\n\t\tnAbort++;\r\n\t}\r\n\telse {\r\n\t\tsod_config_log_msg(&(*pTrainer), \"Parsing done. Processing network layers now..\\n\");\r\n\t\tsrand((unsigned int)pTrainer->pVfs->xTicks());\r\n\t\tpConf = pTrainer->pFirst;\r\n\t\t/* Process our config */\r\n\t\twhile (pConf) {\r\n\t\t\t/* Get the target layer */\r\n\t\t\tsod_layer *pLayer = sod_find_builtin_layer(&(*pTrainer), &pConf->sName);\r\n\t\t\tif (pLayer == 0) {\r\n\t\t\t\t/* No such layer, discard */\r\n\t\t\t\tsod_config_log_msg(&(*pTrainer), \"No built-in layer(s) were found for this configuration: '%z'..discarding\\n\", &pConf->sName);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsod_config_log_msg(&(*pTrainer), \"Processing layer: '%z'..\\n\", &pConf->sName);\r\n\t\t\t\t/* Run the init callback */\r\n\t\t\t\trc = pLayer->xLoad(&(*pTrainer), (sod_config_node *)SySetBasePtr(&pConf->aNode), (int)SySetUsed(&pConf->aNode), &pLayer->pLayerData);\r\n\t\t\t\tif (rc == SOD_OK && pLayer->xExec) {\r\n\t\t\t\t\t/* Run the exec callback */\r\n\t\t\t\t\trc = pLayer->xExec(pLayer->pLayerData, (sod_paths *)SySetPeek(&pTrainer->aPaths)/* Peek the last path */);\r\n\t\t\t\t}\r\n\t\t\t\tif (rc != SOD_OK) {\r\n\t\t\t\t\t/* Callback requested an operation abort for invalid parameters...*/\r\n\t\t\t\t\tnAbort++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpConf = pConf->pPrev;\r\n\t\t}\r\n\t}\r\n\t/* Clean up */\r\n\tpConf = pTrainer->pLast;\r\n\twhile (pTrainer->nLayers > 0 && pConf) {\r\n\t\tsod_config_layer *pNext = pConf->pNext;\r\n\t\tsod_layer *pLayer = sod_find_builtin_layer(&(*pTrainer), &pConf->sName);\r\n\t\tif (pLayer && pLayer->xRelease) {\r\n\t\t\tpLayer->xRelease(pLayer->pLayerData);\r\n\t\t}\r\n\t\t/* Release */\r\n\t\tSySetRelease(&pConf->aNode);\r\n\t\tfree(pConf);\r\n\t\tpConf = pNext;\r\n\t\tpTrainer->nLayers--;\r\n\t}\r\n\tif (pMap) {\r\n\t\t/* Discard the memory view */\r\n\t\tpTrainer->pVfs->xUnmap(pMap, sz);\r\n\t}\r\n\treturn nAbort > 0 ? SOD_ABORT /* Callback request an operation abort, check log */ : SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_realnet_train_release(sod_realnet_trainer * pTrainer)\r\n{\r\n\tsod_paths *aPaths = (sod_paths *)SySetBasePtr(&pTrainer->aPaths);\r\n\tsize_t i;\r\n\r\n\tSyBlobRelease(&pTrainer->sWorker);\r\n\tfor (i = 0; i < SySetUsed(&pTrainer->aPaths); i++) {\r\n\t\tPathConfRelease(&aPaths[i]);\r\n\t}\r\n\tSySetRelease(&pTrainer->aPaths);\r\n\tSySetRelease(&pTrainer->aBuiltin);\r\n\tsod_realnet_release_samples(&pTrainer->aPos);\r\n\tsod_realnet_release_samples(&pTrainer->aNeg);\r\n\tsod_realnet_release_samples(&pTrainer->aTest);\r\n\tSySetRelease(&pTrainer->aSample);\r\n\tfree(pTrainer);\r\n#ifdef SOD_MEM_DEBUG\r\n\t_CrtDumpMemoryLeaks();\r\n#endif /* #ifdSOD_MEM_DEBUG */\r\n}\r\n#endif /* SOD_ENABLE_NET_TRAIN */\r\nstruct sod_realnet\r\n{\r\n\tSySet aModels;     /* Set of loaded models */\r\n\tSySet aBox;        /* Detection box */\r\n};\r\ntypedef enum {\r\n\tSOD_REALNET_DETECTION = 1 /* An object detection network */\r\n}SOD_REALNET_NET_TYPE;\r\ntypedef struct sod_realnet_model sod_realnet_model;\r\nstruct sod_realnet_model\r\n{\r\n\tconst char *zName; /* Model name if any */\r\n\tconst char *zAbout;\r\n\tSOD_REALNET_NET_TYPE iType;\r\n\t/* Decision trees */\r\n\tint depth;\r\n\tint ntrees;\r\n\tint version;\r\n\tint bbox;\r\n\tvoid *pTrees;\r\n\tvoid *pMmap;\r\n\tsize_t mapSz;\r\n\tsize_t offset;\r\n\t/* Detection parameters */\r\n\tint minsize;\r\n\tint maxsize;\r\n\tfloat scalefactor;\r\n\tfloat stridefactor;\r\n\tfloat threshold;\r\n\tfloat nms;\r\n};\r\n/*\r\n * Parse a given binary cascade trained for detection tasks.\r\n */\r\nstatic int RealnetParseDetectionCascade(const void *pRaw, size_t nSz, sod_realnet_model *pModel, int is_mmaped)\r\n{\r\n\tint *cascade = (int *)pRaw;\r\n\tif (nSz < 100) return SOD_ABORT;\r\n\tpModel->version = cascade[0];\r\n\tif (pModel->version != 3 && pModel->version != 4) {\r\n\t\t/* Corrupt model */\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\tpModel->bbox = cascade[1];\r\n\tif (pModel->version == 3) {\r\n\t\tpModel->depth = cascade[2];\r\n\t}\r\n\tpModel->ntrees = cascade[3];\r\n\t/* Calculate the offset */\r\n\tpModel->pTrees = (void *)&cascade[4];\r\n\tif (is_mmaped) {\r\n\t\tpModel->pMmap = (void *)pRaw;\r\n\t\tpModel->mapSz = nSz;\r\n\t}\r\n\telse {\r\n\t\t/* Already zeroed */\r\n\t\tpModel->pMmap = 0; \r\n\t}\r\n\tpModel->offset = ((1 << pModel->depth) - 1) * sizeof(int) /* Node table */ + (1 << pModel->depth) * sizeof(float)/* Leaf table*/ + 1 * sizeof(float) /* Tree threshold */;\r\n\tif (nSz < (4 *sizeof(int) + pModel->ntrees * pModel->offset) ) {\r\n\t\t/* Corrupt model */\r\n\t\treturn SOD_ABORT;\r\n\t}\r\n\tpModel->zName = \"object\";\r\n\treturn SOD_OK;\r\n}\r\n/* \r\n * Fill a Realnet model with default values.\r\n */\r\nstatic void RealnetFillModel(sod_realnet_model *pModel)\r\n{\r\n\tpModel->minsize = 128;\r\n\tpModel->maxsize = 1024;\r\n\tpModel->scalefactor = 1.1f;\r\n\tpModel->stridefactor = 0.1f;\r\n\tpModel->threshold = 5.0f;\r\n\tpModel->nms = 0.4f;\r\n\tpModel->iType = SOD_REALNET_DETECTION;\r\n}\r\n/*\r\n * Run a Realnet cascade for object detection tasks. \r\n * Implementation based on the work on Nenad Markus pico project. License MIT.\r\n */\r\nstatic int RealnetRunDetectionCascade(sod_realnet_model *pModel, int r, int c, int s, float *threshold, const unsigned char *zPixels, int w, int h)\r\n{\r\n\tconst char *zTree = (const char*)pModel->pTrees;\r\n\tfloat tree_thresh;\r\n\tint i;\r\n\tr = r * 256;\r\n\tc = c * 256;\r\n\tif ((r + 128 * s) / 256 >= h || (r - 128 * s) / 256 < 0 || (c + 128 * s) / 256 >= w || (c - 128 * s) / 256 < 0) {\r\n\t\treturn -1;\r\n\t}\r\n\ttree_thresh = 0.0f;\r\n\tfor (i = 0; i < pModel->ntrees; i++) {\r\n\t\tconst char *zNodes = zTree - 4;\r\n\t\tfloat *aLeafs = (float *)(zTree + ((1 << pModel->depth) - 1) * sizeof(int));\r\n\t\tint idx = 1;\r\n\t\tint j;\r\n\t\ttree_thresh = *(float *)(zTree + ((1 << pModel->depth) - 1) * sizeof(int) + (1 << pModel->depth) * sizeof(float));\r\n\t\tfor (j = 0; j < pModel->depth; ++j) {\r\n\t\t\tidx = 2 * idx + (zPixels[((r + zNodes[4 * idx + 0] * s) / 256) * w + (c + zNodes[4 * idx + 1] * s) / 256] <= zPixels[((r + zNodes[4 * idx + 2] * s) / 256) * w + (c + zNodes[4 * idx + 3] * s) / 256]);\r\n\t\t}\r\n\t\t*threshold = *threshold + aLeafs[idx - (1 << pModel->depth)];\r\n\t\tif (*threshold <= tree_thresh) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tzTree += pModel->offset;\r\n\t}\r\n\t*threshold = *threshold - tree_thresh;\r\n\treturn +1;\r\n}\r\n/*\r\n * Non-Maximum Suppression (NMS) on sod_boxes.\r\n */\r\nstatic float sodBoxOverlap(int x1, int w1, int x2, int w2)\r\n{\r\n\tfloat l1 = (float)x1 - w1 / 2;\r\n\tfloat l2 = (float)x2 - w2 / 2;\r\n\tfloat left = l1 > l2 ? l1 : l2;\r\n\tfloat r1 = x1 + w1 / 2;\r\n\tfloat r2 = x2 + w2 / 2;\r\n\tfloat right = r1 < r2 ? r1 : r2;\r\n\treturn right - left;\r\n}\r\nstatic float sodBoxInter(sod_box a, sod_box b)\r\n{\r\n\tfloat w = sodBoxOverlap(a.x, a.w, b.x, b.w);\r\n\tfloat h = sodBoxOverlap(a.y, a.h, b.y, b.h);\r\n\tif (w < 0 || h < 0) return 0;\r\n\tfloat area = w * h;\r\n\treturn area;\r\n}\r\nstatic float sodBoxUnion(sod_box a, sod_box b)\r\n{\r\n\tfloat i = sodBoxInter(a, b);\r\n\tfloat u = a.w*a.h + b.w*b.h - i;\r\n\treturn u;\r\n}\r\nstatic float sodBoxIou(sod_box a, sod_box b)\r\n{\r\n\treturn sodBoxInter(a, b) / sodBoxUnion(a, b);\r\n}\r\nstatic int sodBoxNmsCmp(const void *pa, const void *pb)\r\n{\r\n\tsod_box *a = (sod_box *)pa;\r\n\tsod_box *b = (sod_box *)pb;\r\n\tfloat diff = a->score - b->score;\r\n\tif (diff < 0) return 1;\r\n\telse if (diff > 0) return -1;\r\n\treturn 0;\r\n}\r\nstatic void sodBoxesdoNms(sod_box *aBoxes, size_t nCount, float thresh)\r\n{\r\n\tsize_t i, j;\r\n\tqsort(aBoxes, nCount, sizeof(sod_box), sodBoxNmsCmp);\r\n\tfor (i = 0; i < nCount; ++i) {\r\n\t\tsod_box a = aBoxes[i];\r\n\t\tif (a.score == 0) continue;\r\n\t\tfor (j = i + 1; j < nCount; ++j) {\r\n\t\t\tsod_box b = aBoxes[j];\r\n\t\t\tif (sodBoxIou(a, b) > thresh) {\r\n\t\t\t\taBoxes[j].score = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nstatic void sodNmsDiscardBoxes(SySet *pBox)\r\n{\r\n\tsod_box *aBoxes = SySetBasePtr(pBox);\r\n\tsize_t nNewCount = 0;\r\n\tsod_box *pPtr, *pEnd;\r\n\tpPtr = &aBoxes[0];\r\n\tpEnd = &aBoxes[SySetUsed(pBox)];\r\n\twhile(pPtr < pEnd){\r\n\t\tif (pPtr->score != 0) {\r\n\t\t\tnNewCount++;\r\n\t\t\tpPtr++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tmemmove(pPtr, &pPtr[1], sizeof(sod_box)*(pEnd - pPtr));\r\n\t\tpEnd--;\r\n\t}\r\n\tpBox->nUsed = nNewCount;\r\n}\r\n#ifndef SOD_DISABLE_REALNET\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_create(sod_realnet **ppOut)\r\n{\r\n\tsod_realnet *pNet = malloc(sizeof(sod_realnet));\r\n\t*ppOut = pNet;\r\n\tif (pNet == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tmemset(pNet, 0, sizeof(sod_realnet));\r\n\tSySetInit(&pNet->aModels, sizeof(sod_realnet_model));\r\n\tSySetAlloc(&pNet->aModels, 8);\r\n\tSySetInit(&pNet->aBox, sizeof(sod_box));\r\n\tSySetAlloc(&pNet->aBox, 16);\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_load_model_from_mem(sod_realnet *pNet, const void * pModel, unsigned int nBytes, sod_realnet_model_handle *pOutHandle)\r\n{\r\n\tsod_realnet_model sModel;\r\n\tint rc;\r\n\t/* Parse the model */\r\n\tmemset(&sModel, 0, sizeof(sod_realnet_model));\r\n\trc = RealnetParseDetectionCascade(pModel, nBytes, &sModel, 0);\r\n\tif (rc != SOD_OK) {\r\n\t\t/* Corrupt model */\r\n\t\treturn rc;\r\n\t}\r\n\t/* Fill with default values */\r\n\tRealnetFillModel(&sModel);\r\n\t/* Register that model */\r\n\tif (SOD_OK != SySetPut(&pNet->aModels, &sModel)) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tif (pOutHandle) {\r\n\t\t*pOutHandle = (sod_realnet_model_handle)(SySetUsed(&pNet->aModels) - 1);\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n#ifndef SOD_NO_MMAP\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_load_model_from_disk(sod_realnet *pNet, const char * zPath, sod_realnet_model_handle *pOutHandle)\r\n{\r\n\tconst sod_vfs *pVfs = sodExportBuiltinVfs();\r\n\tsod_realnet_model sModel;\r\n\tvoid *pMap = 0;\r\n\tsize_t sz;\r\n\tint rc;\r\n\tif (!pVfs->xMmap)\r\n\t\treturn SOD_IOERR;\r\n\tif (SOD_OK != pVfs->xMmap(zPath, &pMap, &sz)) {\r\n\t\treturn SOD_IOERR;\r\n\t}\r\n\t/* Parse the model */\r\n\tmemset(&sModel, 0, sizeof(sod_realnet_model));\r\n\trc = RealnetParseDetectionCascade(pMap, sz, &sModel, 1);\r\n\tif (rc != SOD_OK) {\r\n\t\t/* Corrupt model */\r\n\t\treturn rc;\r\n\t}\r\n\t/* Fill with default values */\r\n\tRealnetFillModel(&sModel);\r\n\t/* Register that model */\r\n\tif (SOD_OK != SySetPut(&pNet->aModels, &sModel)) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tif (pOutHandle) {\r\n\t\t*pOutHandle = (sod_realnet_model_handle)(SySetUsed(&pNet->aModels) - 1);\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n#endif\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_model_config(sod_realnet *pNet, sod_realnet_model_handle handle, SOD_REALNET_MODEL_CONFIG conf, ...)\r\n{\r\n\tsod_realnet_model *pModel;\r\n\tint rc = SOD_OK;\r\n\tva_list ap;\r\n\t/* Fetch the target model */\r\n\tpModel = SySetFetch(&pNet->aBox, handle);\r\n\tva_start(ap, conf);\r\n\tif (pModel) {\r\n\t\tswitch (conf) {\r\n\t\tcase SOD_REALNET_MODEL_NMS: {\r\n\t\t\tdouble nms = va_arg(ap, double);\r\n\t\t\tpModel->nms = (float)nms;\r\n\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\tcase SOD_RELANET_MODEL_DETECTION_THRESHOLD: {\r\n\t\t\tdouble thresh = va_arg(ap, double);\r\n\t\t\tpModel->threshold = (float)thresh;\r\n\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\tcase SOD_REALNET_MODEL_MINSIZE: {\r\n\t\t\tint minsize = va_arg(ap, int);\r\n\t\t\tif (minsize >= 8) pModel->minsize = minsize;\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\tcase SOD_REALNET_MODEL_MAXSIZE: {\r\n\t\t\tint maxsize = va_arg(ap, int);\r\n\t\t\tif (maxsize >= 16) pModel->maxsize = maxsize;\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\tcase SOD_REALNET_MODEL_SCALEFACTOR: {\r\n\t\t\tdouble scalefactor = va_arg(ap, double);\r\n\t\t\tpModel->scalefactor = (float)scalefactor;\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\tcase SOD_REALNET_MODEL_STRIDEFACTOR: {\r\n\t\t\tdouble stridefactor = va_arg(ap, double);\r\n\t\t\tpModel->stridefactor = (float)stridefactor;\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t break;\r\n\t\tcase SOD_REALNET_MODEL_NAME: {\r\n\t\t\tconst char *zName = va_arg(ap, const char *);\r\n\t\t\tpModel->zName = zName;\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t break;\r\n\t\tcase SOD_REALNET_MODEL_ABOUT_INFO: {\r\n\t\t\tconst char *zAbout = va_arg(ap, const char *);\r\n\t\t\tpModel->zAbout = zAbout;\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\t break;\r\n\r\n\t\tdefault:\r\n\t\t\trc = SOD_UNSUPPORTED;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\trc = SOD_UNSUPPORTED;\r\n\t}\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_realnet_detect(sod_realnet *pNet, const unsigned char *zGrayImg, int width, int height, sod_box **apBox, int *pnBox)\r\n{\r\n\tsod_realnet_model *aModel = (sod_realnet_model *)SySetBasePtr(&pNet->aModels);\r\n\tsize_t n;\r\n\tSySetReset(&pNet->aBox);\r\n\t/* Loaded models */\r\n\tfor (n = 0; n < SySetUsed(&pNet->aModels); ++n) {\r\n\t\tsod_realnet_model *pMl = &aModel[n];\r\n\t\tsize_t nCur = SySetUsed(&pNet->aBox);\r\n\t\tfloat s;\r\n\t\t/* Start detection */\r\n\t\ts = pMl->minsize;\r\n\t\twhile (s <= pMl->maxsize) {\r\n\t\t\tfloat r, c, dr, dc;\r\n\t\t\tdc = dr = MAX(s*pMl->stridefactor, 1.0f);\r\n\t\t\tfor (r = s / 2 + 1; r <= height - s / 2 - 1; r += dr) {\r\n\t\t\t\tfor (c = s / 2 + 1; c <= width - s / 2 - 1; c += dc) {\r\n\t\t\t\t\tfloat thresh = 0.0f; /* cc warning */\r\n\t\t\t\t\tif (1 == RealnetRunDetectionCascade(pMl, r, c, s, &thresh, zGrayImg, width, height) && thresh >= pMl->threshold) {\r\n\t\t\t\t\t\tsod_box bbox;\r\n\t\t\t\t\t\tbbox.score = thresh;\r\n\t\t\t\t\t\tbbox.zName = pMl->zName;\r\n\t\t\t\t\t\tbbox.pUserData = 0;\r\n\t\t\t\t\t\tbbox.x = MAX((int)(c - 0.5*s), 0);\r\n\t\t\t\t\t\tbbox.y = MAX((int)(r - 0.5*s), 0);\r\n\t\t\t\t\t\tbbox.w = MIN((int)(c + 0.5*s), width)  - bbox.x;\r\n\t\t\t\t\t\tbbox.h = MIN((int)(r + 0.5*s), height) - bbox.y;\r\n\t\t\t\t\t\tSySetPut(&pNet->aBox, &bbox);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ts = s * pMl->scalefactor;\r\n\t\t}\r\n\t\tif (pMl->nms) {\r\n\t\t\t/* Non-Maximum Suppression */\r\n\t\t\tsodBoxesdoNms((sod_box *)SySetBasePtrJump(&pNet->aBox, nCur), SySetUsed(&pNet->aBox) - nCur, pMl->nms);\r\n\t\t\tsodNmsDiscardBoxes(&pNet->aBox);\r\n\t\t}\r\n\t}\r\n\tif (pnBox) {\r\n\t\t*pnBox = (int)SySetUsed(&pNet->aBox);\r\n\t}\r\n\tif (apBox) {\r\n\t\t*apBox = SySetBasePtr(&pNet->aBox);\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_realnet_destroy(sod_realnet * pNet)\r\n{\r\n\tsod_realnet_model *aModel = (sod_realnet_model *)SySetBasePtr(&pNet->aModels);\r\n\tconst sod_vfs *pVfs = sodExportBuiltinVfs();\r\n\tsize_t n;\r\n\t/* Release the memory view if any for each loaded model */\r\n\tfor (n = 0; n < SySetUsed(&pNet->aModels); ++n) {\r\n\t\tsod_realnet_model *pMl = &aModel[n];\r\n\t\t/* For models */\r\n\t\tif (pMl->pMmap) {\r\n\t\t\tpVfs->xUnmap(pMl->pMmap, pMl->mapSz);\r\n\t\t}\r\n\t}\r\n\tSySetRelease(&pNet->aBox);\r\n\tSySetRelease(&pNet->aModels);\r\n\tfree(pNet);\r\n#ifdef SOD_MEM_DEBUG\r\n\t_CrtDumpMemoryLeaks();\r\n#endif /* #ifdSOD_MEM_DEBUG */\r\n}\r\n#endif /* SOD_DISABLE_REALNET */\r\n#ifndef SOD_DISABLE_IMG_READER\r\n#ifdef _MSC_VER\r\n/* Disable the nonstandard extension used: non-constant aggregate initializer warning */\r\n#pragma warning(disable:4204)\r\n#endif /* _MSC_VER */\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include \"sod_img_reader.h\"\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_img_load_from_mem(const unsigned char * zBuf, int buf_len, int nChannels)\r\n{\r\n\tint w, h, c;\r\n\tint i, j, k;\r\n\tunsigned char *data = stbi_load_from_memory(zBuf, buf_len, &w, &h, &c, nChannels);\r\n\tif (!data) {\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tif (nChannels) c = nChannels;\r\n\tsod_img im = sod_make_image(w, h, c);\r\n\tif (im.data) {\r\n\t\tfor (k = 0; k < c; ++k) {\r\n\t\t\tfor (j = 0; j < h; ++j) {\r\n\t\t\t\tfor (i = 0; i < w; ++i) {\r\n\t\t\t\t\tint dst_index = i + w * j + w * h*k;\r\n\t\t\t\t\tint src_index = k + c * i + c * w*j;\r\n\t\t\t\t\tim.data[dst_index] = (float)data[src_index] / 255.;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree(data);\r\n\treturn im;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_img_load_from_file(const char *zFile, int nChannels)\r\n{\r\n\tconst sod_vfs *pVfs = sodExportBuiltinVfs();\r\n\tunsigned char *data;\r\n\tvoid *pMap = 0;\r\n\tsize_t sz = 0; /* gcc warn */\r\n\tint w, h, c;\r\n\tint i, j, k;\r\n\tif (!pVfs->xMmap || SOD_OK != pVfs->xMmap(zFile, &pMap, &sz)) {\r\n\t\tdata = stbi_load(zFile, &w, &h, &c, nChannels);\r\n\t}\r\n\telse {\r\n\t\tdata = stbi_load_from_memory((const unsigned char *)pMap, (int)sz, &w, &h, &c, nChannels);\r\n\t}\r\n\tif (!data) {\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tif (nChannels) c = nChannels;\r\n\tsod_img im = sod_make_image(w, h, c);\r\n\tif (im.data) {\r\n\t\tfor (k = 0; k < c; ++k) {\r\n\t\t\tfor (j = 0; j < h; ++j) {\r\n\t\t\t\tfor (i = 0; i < w; ++i) {\r\n\t\t\t\t\tint dst_index = i + w * j + w * h*k;\r\n\t\t\t\t\tint src_index = k + c * i + c * w*j;\r\n\t\t\t\t\tim.data[dst_index] = (float)data[src_index] / 255.;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree(data);\r\n\tif (pMap) {\r\n\t\tpVfs->xUnmap(pMap, sz);\r\n\t}\r\n\treturn im;\r\n}\r\n/*\r\n* Extract path fields.\r\n*/\r\nstatic int ExtractPathInfo(const char *zPath, size_t nByte, sod_path_info *pOut)\r\n{\r\n\tconst char *zPtr, *zEnd = &zPath[nByte - 1];\r\n\tSyString *pCur;\r\n\tint c, d;\r\n\tc = d = '/';\r\n#ifdef __WINNT__\r\n\td = '\\\\';\r\n#endif\r\n\t/* Zero the structure */\r\n\tmemset(pOut, 0, sizeof(sod_path_info));\r\n\t/* Handle special case */\r\n\tif (nByte == sizeof(char) && ((int)zPath[0] == c || (int)zPath[0] == d)) {\r\n#ifdef __WINNT__\r\n\t\tSyStringInitFromBuf(&pOut->sDir, \"\\\\\", sizeof(char));\r\n#else\r\n\t\tSyStringInitFromBuf(&pOut->sDir, \"/\", sizeof(char));\r\n#endif\r\n\t\treturn SOD_OK;\r\n\t}\r\n\t/* Extract the basename */\r\n\twhile (zEnd > zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {\r\n\t\tzEnd--;\r\n\t}\r\n\tzPtr = (zEnd > zPath) ? &zEnd[1] : zPath;\r\n\tzEnd = &zPath[nByte];\r\n\t/* dirname */\r\n\tpCur = &pOut->sDir;\r\n\tSyStringInitFromBuf(pCur, zPath, zPtr - zPath);\r\n\tif (pCur->nByte > 1) {\r\n\t\tSyStringTrimTrailingChar(pCur, '/');\r\n#ifdef __WINNT__\r\n\t\tSyStringTrimTrailingChar(pCur, '\\\\');\r\n#endif\r\n\t}\r\n\telse if ((int)zPath[0] == c || (int)zPath[0] == d) {\r\n#ifdef __WINNT__\r\n\t\tSyStringInitFromBuf(&pOut->sDir, \"\\\\\", sizeof(char));\r\n#else\r\n\t\tSyStringInitFromBuf(&pOut->sDir, \"/\", sizeof(char));\r\n#endif\r\n\t}\r\n\t/* basename/filename */\r\n\tpCur = &pOut->sBasename;\r\n\tSyStringInitFromBuf(pCur, zPtr, zEnd - zPtr);\r\n\tSyStringTrimLeadingChar(pCur, '/');\r\n#ifdef __WINNT__\r\n\tSyStringTrimLeadingChar(pCur, '\\\\');\r\n#endif\r\n\tSyStringDupPtr(&pOut->sFilename, pCur);\r\n\tif (pCur->nByte > 0) {\r\n\t\t/* extension */\r\n\t\tzEnd--;\r\n\t\twhile (zEnd > pCur->zString /*basename*/ && zEnd[0] != '.') {\r\n\t\t\tzEnd--;\r\n\t\t}\r\n\t\tif (zEnd > pCur->zString) {\r\n\t\t\tzEnd++; /* Jump leading dot */\r\n\t\t\tSyStringInitFromBuf(&pOut->sExtension, zEnd, &zPath[nByte] - zEnd);\r\n\t\t\t/* Fix filename */\r\n\t\t\tpCur = &pOut->sFilename;\r\n\t\t\tif (pCur->nByte > SyStringLength(&pOut->sExtension)) {\r\n\t\t\t\tpCur->nByte -= 1 + SyStringLength(&pOut->sExtension);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* Cross platform srtnicmp\r\n*/\r\nstatic int sy_strnicmp(const char *zA, const char *zB, size_t len)\r\n{\r\n\tfor (;;) {\r\n\t\tif (len < 1) break;\r\n\t\tint c = tolower(zA[0]);\r\n\t\tint d = tolower(zB[0]);\r\n\t\tint e = c - d;\r\n\t\tif (e != 0) return e;\r\n\t\tif (c == 0) break;\r\n\t\tzA++;\r\n\t\tzB++;\r\n\t\tlen--;\r\n\t}\r\n\treturn 0; /* Equal string */\r\n}\r\n/*\r\n* Compare two strings. One is nil-terminated, the other may be not.\r\n*/\r\nstatic int CmpSyString(SyString *pStr, const char *zIn)\r\n{\r\n\tSyString sStr;\r\n\tSyStringInitFromBuf(&sStr, zIn, strlen(zIn));\r\n\treturn SyStringCmp(&sStr, pStr, sy_strnicmp);\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_set_load_from_directory(const char * zPath, sod_img ** apLoaded, int * pnLoaded, int max_entries)\r\n{\r\n\tstatic const char *zAllowed[] = { \"png\",\"jpg\",\"jpeg\",\"bmp\",\"pgm\",\"ppm\",\"pbm\",\"hdr\",\"psd\",\"tga\",\"pic\", 0 /*Marker*/ };\r\n\tconst sod_vfs *pVfs = sodExportBuiltinVfs();\r\n\tsod_path_info sPath;\r\n\tSySet aEntries;\r\n\tSyBlob sReader;\r\n\tvoid *pHandle;\r\n\tsod_img img;\r\n\tint i, rc;\r\n\tif (!pVfs->xOpenDir)\r\n\t\treturn SOD_IOERR;\r\n\t/* Open the target directory */\r\n\trc = pVfs->xOpenDir(zPath, &pHandle);\r\n\tif (rc != SOD_OK) {\r\n\t\t*apLoaded = 0;\r\n\t\t*pnLoaded = 0;\r\n\t\treturn rc;\r\n\t}\r\n\tSySetInit(&aEntries, sizeof(sod_img));\r\n\tSyBlobInit(&sReader);\r\n\r\n\t/* Iterate over the target directory */\r\n\tpVfs->xChdir(zPath);\r\n\twhile (pVfs->xDirRead(pHandle, &sReader) == SOD_OK) {\r\n\t\tconst char *zEntry = (const char *)SyBlobData(&sReader);\r\n\t\tsize_t nByte = SyBlobLength(&sReader);\r\n\t\t/* Reset the blob */\r\n\t\tSyBlobReset(&sReader);\r\n\t\tif (pVfs->xIsdir(zEntry)) {\r\n\t\t\t/* Entry is a directory, ignore */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Make sure the file is of the correct extension */\r\n\t\tExtractPathInfo(zEntry, nByte, &sPath);\r\n\t\trc = 0;\r\n\t\tfor (i = 0; zAllowed[i] != 0; i++) {\r\n\t\t\tif (CmpSyString(&sPath.sExtension, zAllowed[i]) == 0) {\r\n\t\t\t\trc = 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!rc) {\r\n\t\t\t/* Not of the expected extension */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (max_entries > 0 && (int)SySetUsed(&aEntries) >= max_entries) {\r\n\t\t\t/* Maximum samples to collect limit reached */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Load the image */\r\n\t\timg = sod_img_load_from_file(zEntry, SOD_IMG_COLOR);\r\n\t\tif (img.data == 0) {\r\n\t\t\t/* Cannot load image, ignore */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Insert in the target set */\r\n\t\trc = SySetPut(&aEntries, (const void *)&img);\r\n\t\tif (rc != SOD_OK) {\r\n\t\t\t/* Avoid memory leaks */\r\n\t\t\tsod_free_image(img);\r\n\t\t}\r\n\t}\r\n\t/* Cleanup */\r\n\tpVfs->xCloseDir(pHandle);\r\n\tSyBlobRelease(&sReader);\r\n\t/* Total loaded images from this directory */\r\n\t*apLoaded = (sod_img *)SySetBasePtr(&aEntries);\r\n\t*pnLoaded = (int)SySetUsed(&aEntries);\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_img_set_release(sod_img *aLoaded, int nEntries)\r\n{\r\n\tint i;\r\n\tfor (i = 0; i < nEntries; i++) {\r\n\t\tsod_free_image(aLoaded[i]);\r\n\t}\r\n\tfree(aLoaded);\r\n}\r\n#ifndef SOD_DISABLE_IMG_WRITER\r\n#define STB_IMAGE_WRITE_IMPLEMENTATION\r\n#include\"sod_img_writer.h\"\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_save_as_png(sod_img input, const char * zPath)\r\n{\r\n\tunsigned char *zPng = sod_image_to_blob(input);\r\n\tint rc;\r\n\tif (zPng == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\trc = stbi_write_png(zPath, input.w, input.h, input.c, (const void *)zPng, input.w * input.c);\r\n\tsod_image_free_blob(zPng);\r\n\treturn rc ? SOD_OK : SOD_IOERR;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_save_as_jpeg(sod_img input, const char *zPath, int Quality)\r\n{\r\n\tunsigned char *zJpeg = sod_image_to_blob(input);\r\n\tint rc;\r\n\tif (zJpeg == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\trc = stbi_write_jpg(zPath, input.w, input.h, input.c, (const void *)zJpeg, Quality < 0 ? 100 : Quality);\r\n\tsod_image_free_blob(zJpeg);\r\n\treturn rc ? SOD_OK : SOD_IOERR;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_blob_save_as_png(const char * zPath, const unsigned char *zBlob, int width, int height, int nChannels)\r\n{\r\n\tint rc;\r\n\trc = stbi_write_png(zPath, width, height, nChannels, (const void *)zBlob, width * nChannels);\r\n\treturn rc ? SOD_OK : SOD_IOERR;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_blob_save_as_jpeg(const char * zPath, const unsigned char *zBlob, int width, int height, int nChannels, int Quality)\r\n{\r\n\tint rc;\r\n\trc = stbi_write_jpg(zPath, width, height, nChannels, (const void *)zBlob, Quality < 0 ? 100 : Quality);\r\n\treturn rc ? SOD_OK : SOD_IOERR;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_blob_save_as_bmp(const char * zPath, const unsigned char *zBlob, int width, int height, int nChannels)\r\n{\r\n\tint rc;\r\n\trc = stbi_write_bmp(zPath, width, height, nChannels, (const void *)zBlob);\r\n\treturn rc ? SOD_OK : SOD_IOERR;\r\n}\r\n#endif /* SOD_DISABLE_IMG_WRITER  */\r\n#endif /* SOD_DISABLE_IMG_READER */\r\n#ifdef SOD_ENABLE_OPENCV\r\n/*\r\n* OpenCV integration with the SOD library.\r\n*/\r\nstatic void ipl_into_image(IplImage* src, sod_img im)\r\n{\r\n\tunsigned char *data = (unsigned char *)src->imageData;\r\n\tint h = src->height;\r\n\tint w = src->width;\r\n\tint c = src->nChannels;\r\n\tint step = src->widthStep;\r\n\tint i, j, k;\r\n\r\n\tfor (i = 0; i < h; ++i) {\r\n\t\tfor (k = 0; k < c; ++k) {\r\n\t\t\tfor (j = 0; j < w; ++j) {\r\n\t\t\t\tim.data[k*w*h + i * w + j] = data[i*step + j * c + k] / 255.;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_img_load_cv_ipl(IplImage* src)\r\n{\r\n\tint h = src->height;\r\n\tint w = src->width;\r\n\tint c = src->nChannels;\r\n\tsod_img out = sod_make_image(w, h, c);\r\n\tipl_into_image(src, out);\r\n\treturn out;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_img_load_from_cv(const char *filename, int channels)\r\n{\r\n\tIplImage* src = 0;\r\n\tint flag = -1;\r\n\tif (channels == 0) flag = -1;\r\n\telse if (channels == 1) flag = 0;\r\n\telse if (channels == 3) flag = 1;\r\n\telse {\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\r\n\tif ((src = cvLoadImage(filename, flag)) == 0)\r\n\t{\r\n\t\treturn sod_make_empty_image(0, 0, 0);\r\n\t}\r\n\tsod_img out = sod_img_load_cv_ipl(src);\r\n\tcvReleaseImage(&src);\r\n\tsod_img_rgb_to_bgr(out);\r\n\treturn out;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nsod_img sod_img_load_from_cv_stream(CvCapture *cap)\r\n{\r\n\tIplImage* src = cvQueryFrame(cap);\r\n\tif (!src) return sod_make_empty_image(0, 0, 0);\r\n\tsod_img im = sod_img_load_cv_ipl(src);\r\n\tsod_img_rgb_to_bgr(im);\r\n\treturn im;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nint sod_img_fill_from_cv_stream(CvCapture *cap, sod_img *pImg)\r\n{\r\n\tIplImage* src = cvQueryFrame(cap);\r\n\tif (!src) {\r\n\t\treturn -1;\r\n\t}\r\n\t/* Make sure we have enough space to hold this chunk */\r\n\tsod_md_alloc_dyn_img(&(*pImg), src->width, src->height, src->nChannels);\r\n\tif (pImg->data == 0) {\r\n\t\treturn SOD_OUTOFMEM;\r\n\t}\r\n\tipl_into_image(src, *pImg);\r\n\tsod_img_rgb_to_bgr(*pImg); /* noop if grayscale IPL which is required for the real-time object detector */\r\n\treturn SOD_OK;\r\n}\r\n/*\r\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\r\n*/\r\nvoid sod_img_save_to_cv_jpg(sod_img im, const char *zPath)\r\n{\r\n\tsod_img copy = sod_copy_image(im);\r\n\tif (im.c == 3) sod_img_rgb_to_bgr(copy);\r\n\tint x, y, k;\r\n\r\n\tIplImage *disp = cvCreateImage(cvSize(im.w, im.h), IPL_DEPTH_8U, im.c);\r\n\tint step = disp->widthStep;\r\n\tfor (y = 0; y < im.h; ++y) {\r\n\t\tfor (x = 0; x < im.w; ++x) {\r\n\t\t\tfor (k = 0; k < im.c; ++k) {\r\n\t\t\t\tdisp->imageData[y*step + x * im.c + k] = (unsigned char)(get_pixel(copy, x, y, k) * 255);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcvSaveImage(zPath, disp, 0);\r\n\tcvReleaseImage(&disp);\r\n\tsod_free_image(copy);\r\n}\r\n#endif /* SOD_ENABLE_OPENCV */\r\n/*\r\n * SOD Embedded Release Information & Copyright Notice.\r\n */\r\nconst char * sod_lib_copyright(void)\r\n{\r\n\treturn SOD_LIB_INFO;\r\n}\r\n"
        },
        {
          "name": "sod.h",
          "type": "blob",
          "size": 19.337890625,
          "content": "#ifndef _SOD_H_\r\n#define _SOD_H_\r\n/*\r\n* SOD - An Embedded Computer Vision & Machine Learning Library.\r\n* Copyright (C) 2018 - 2023 PixLab| Symisc Systems. https://sod.pixlab.io\r\n* Version 1.1.9\r\n*\r\n* Symisc Systems employs a dual licensing model that offers customers\r\n* a choice of either our open source license (GPLv3) or a commercial \r\n* license.\r\n*\r\n* For information on licensing, redistribution of the SOD library, and for a DISCLAIMER OF ALL WARRANTIES\r\n* please visit:\r\n*     https://pixlab.io/sod\r\n* or contact:\r\n*     licensing@symisc.net\r\n*     support@pixlab.io\r\n*/\r\n/*\r\n * This file is part of Symisc SOD - Open Source Release (GPLv3)\r\n *\r\n * SOD is free software : you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * SOD is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with SOD. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/* Make sure we can call this stuff from C++ */\r\n#ifdef __cplusplus\r\n extern \"C\" {\r\n#endif \r\n/*\r\n * Marker for exported interfaces.\r\n */\r\n#if defined (_MSC_VER) || defined (__MINGW32__) ||  defined (__GNUC__) && defined (__declspec)\r\n#define SOD_APIIMPORT\t__declspec(dllimport)\r\n#define SOD_APIEXPORT\t__declspec(dllexport)\r\n#else\r\n#define\tSOD_APIIMPORT\r\n#define\tSOD_APIEXPORT\r\n#endif\r\n/*\r\n * The SOD_VERSION C preprocessor macro evaluates to a string literal\r\n * that is the SOD version in the format \"X.Y.Z\" where X is the major\r\n * version number and Y is the minor version number and Z is the release\r\n * number.\r\n */\r\n#define SOD_VERSION \"1.1.9\"\r\n /*\r\n * The SOD_VERSION_NUMBER C preprocessor macro resolves to an integer\r\n * with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same\r\n * numbers used in [SOD_VERSION].\r\n */\r\n#define SOD_VERSION_NUMBER 1001009\r\n/*\r\n * Forward declarations. \r\n */\r\n/* \r\n * RealNets handle documented at https://sod.pixlab.io/api.html#sod_realnet. */\r\ntypedef struct sod_realnet sod_realnet;\r\n/*\r\n * Convolutional/Recurrent Neural Networks (CNN/RNN) handle documented at https://sod.pixlab.io/api.html#sod_cnn. */\r\ntypedef struct sod_cnn sod_cnn;\r\n/*\r\n * bounding box structure documented at https://sod.pixlab.io/api.html#sod_box. */\r\ntypedef struct sod_box sod_box;\r\n/*\r\n * Image/Frame container documented at https://sod.pixlab.io/api.html#sod_img. */\r\ntypedef struct sod_img sod_img;\r\n/* \r\n * Point instance documented at https://sod.pixlab.io/api.html#sod_pts. */\r\ntypedef struct sod_pts sod_pts;\r\n/* \r\n * RealNets model handle documented at https://sod.pixlab.io/api.html#sod_realnet_model_handle. */\r\ntypedef unsigned int sod_realnet_model_handle;\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\n/* \r\n * RealNets trainer handle documented at https://sod.pixlab.io/api.html#sod_realnet_trainer. */\r\ntypedef struct sod_realnet_trainer sod_realnet_trainer;\r\n#endif\r\n/*\r\n * A bounding box or bbox for short is represented by an instance of the `sod_box` structure.\r\n * A sod_box instance always store the coordinates of a rectangle obtained from a prior successful\r\n * call to one of the object detection routines of a sod_cnn or sod_realnet handle such as\r\n * `sod_cnn_predict()` or from the connected component labeling interface `sod_image_find_blobs()`.\r\n *\r\n * Besides the rectangle coordinates. The `zName` and `score` fields member of this structure hold\r\n * useful information about the object it surround.\r\n *\r\n * This structure and related interfaces are documented at https://sod.pixlab.io/api.html#sod_box.\r\n */\r\nstruct sod_box {\r\n\tint x;  /* The x-coordinate of the upper-left corner of the rectangle */\r\n\tint y;  /* The y-coordinate of the upper-left corner of the rectangle */\r\n\tint w;  /* Rectangle width */\r\n\tint h;  /* Rectangle height */\r\n\tfloat score;       /* Confidence threshold. */\r\n\tconst char *zName; /* Detected object name. I.e. person, face, dog, car, plane, cat, bicycle, etc. */\r\n\tvoid *pUserData;   /* External pointer used by some modules such as the face landmarks, NSFW classifier, pose estimator, etc. */\r\n};\r\n/*\r\n * Internally, each in-memory representation of an input image or video frame\r\n * is kept in an instance of the `sod_img` structure. Basically, a `sod_img` is just a record\r\n * of the width, height and number of color channels in an image, and also the pixel values\r\n * for every pixel. Images pixels are arranged in CHW format. This means in a 3 channel \r\n * image with width 400 and height 300, the first 400 values are the 1st row of the 1st channel\r\n * of the image. The second 400 pixels are the 2nd row. after 120,000 values we get to pixels\r\n * in the 2nd channel, and so forth.\r\n *\r\n * This structure and related interfaces are documented at https://sod.pixlab.io/api.html#sod_img.\r\n */\r\nstruct sod_img {\r\n\tint h;   /* Image/frame height */\r\n\tint w;   /* Image/frame width */\r\n\tint c;   /* Image depth/Total number of color channels e.g. 1 for grayscale images, 3 RGB, etc. */\r\n\tunion\r\n\t{\r\n\t\tfloat* data; /* Blob */\r\n\t\tunsigned char* zdata;\r\n\t};\r\n};\r\n/*\r\n * An instance of the `sod_pts` structure describe a 2D point in space with integer coordinates\r\n * (usually zero-based). This structure is rarely manipulated by SOD and is used mostly by \r\n * the Hough line detection interface `sod_hough_lines_detect()` and line drawing routine `sod_image_draw_line()`.\r\n *\r\n * This structure and related interfaces are documented at https://sod.pixlab.io/api.html#sod_pts.\r\n */\r\nstruct sod_pts {\r\n\tint x; /* The x-coordinate, in logical units of the point offset. */\r\n\tint y; /* The y-coordinate, in logical units of the point offset. */\r\n};\r\n/*\r\n * An integer configuration option that determines what property of a `sod_cnn` handle is to be configured. \r\n * Subsequent arguments vary depending on the configuration verb.\r\n *\r\n * The documentation (including expected arguments for each configuration verb) is available to consult\r\n * at https://sod.pixlab.io/c_api/sod_cnn_config.html.\r\n */\r\ntypedef enum {\r\n\tSOD_CNN_NETWORK_OUTPUT = 1,\r\n\tSOD_CNN_DETECTION_THRESHOLD,\r\n\tSOD_CNN_NMS,\r\n\tSOD_CNN_DETECTION_CLASSES,\r\n\tSOD_CNN_RAND_SEED,\r\n\tSOD_CNN_HIER_THRESHOLD,\r\n\tSOD_CNN_TEMPERATURE,\r\n\tSOD_CNN_LOG_CALLBACK,\r\n\tSOD_RNN_CALLBACK,\r\n\tSOD_RNN_TEXT_LENGTH,\r\n\tSOD_RNN_DATA_LENGTH,\r\n\tSOD_RNN_SEED\r\n}SOD_CNN_CONFIG;\r\n/* \r\n * RNN Consumer callback to be used in conjunction with the `SOD_RNN_CALLBACK` configuration verb.\r\n * \r\n * The documentation is available to consult at https://sod.pixlab.io/c_api/sod_cnn_config.html.\r\n */\r\ntypedef void (*ProcRnnCallback)(const char *, size_t, void *);\r\n/*\r\n* Log Consumer callback to be used in conjunction with the `SOD_CNN_LOG_CALLBACK` or\r\n* the `SOD_REALNET_TR_LOG_CALLBACK` configuration verb.\r\n*\r\n* The documentation is available to consult at https://sod.pixlab.io/c_api/sod_cnn_config.html.\r\n*/\r\ntypedef void(*ProcLogCallback)(const char *, size_t, void *);\r\n/* \r\n * Macros to be used in conjunction with the `sod_img_load_from_file()` or `sod_img_load_from_mem()` interfaces.\r\n */\r\n#define SOD_IMG_COLOR     0 /* Load full color channels. */\r\n#define SOD_IMG_GRAYSCALE 1 /* Load an image in the grayscale colorpsace only (single channel). */\r\n/* \r\n * Macros around a stack allocated `sod_img` instance.\r\n */\r\n#define SOD_IMG_2_INPUT(IMG)  (IMG.data)  /* Pointer to raw binary contents (blobs) of an image or frame. */\r\n#define SOD_IS_EMPTY_IMG(IMG) (!IMG.data) /* NIL pointer test (marker for an empty or broken image format). */\r\n/*\r\n * Possible return value from each exported SOD interface defined below.\r\n */\r\n#define SOD_OK           0 /* Everything went well */\r\n#define SOD_UNSUPPORTED -1 /* Unsupported Pixel format */\r\n#define SOD_OUTOFMEM    -4 /* Out-of-Memory */\r\n#define SOD_ABORT\t    -5 /* User callback request an operation abort */\r\n#define SOD_IOERR       -6 /* IO error */\r\n#define SOD_LIMIT       -7 /* Limit reached */\r\n/*\r\n * An integer configuration option that determines what property of a `sod_realnet_trainer` handle is to be configured.\r\n * Subsequent arguments vary depending on the configuration verb.\r\n *\r\n * The documentation (including expected arguments for each configuration verb) is available to consult\r\n * at https://sod.pixlab.io/c_api/sod_realnet_train_config.html.\r\n */\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\ntypedef enum {\r\n\tSOD_REALNET_TR_LOG_CALLBACK = 1,\r\n\tSOD_REALNET_TR_OUTPUT_MODEL\r\n}SOD_REALNET_TRAINER_CONFIG;\r\n#endif /* SOD_ENABLE_NET_TRAIN */\r\n/*\r\n* An integer configuration option that determines what property of a `sod_realnet` handle is to be configured.\r\n* Subsequent arguments vary depending on the configuration verb.\r\n*\r\n* The documentation (including expected arguments for each configuration verb) is available to consult\r\n* at https://sod.pixlab.io/c_api/sod_realnet_model_config.html.\r\n*/\r\ntypedef enum {\r\n\tSOD_REALNET_MODEL_MINSIZE = 1,\r\n\tSOD_REALNET_MODEL_MAXSIZE,\r\n\tSOD_REALNET_MODEL_SCALEFACTOR,\r\n\tSOD_REALNET_MODEL_STRIDEFACTOR,\r\n\tSOD_RELANET_MODEL_DETECTION_THRESHOLD,\r\n\tSOD_REALNET_MODEL_NMS,\r\n\tSOD_REALNET_MODEL_DISCARD_NULL_BOXES,\r\n\tSOD_REALNET_MODEL_NAME,\r\n\tSOD_REALNET_MODEL_ABOUT_INFO\r\n}SOD_REALNET_MODEL_CONFIG;\r\n/*\r\n * SOD Embedded C/C++ API. \r\n *\r\n * The API documentation is available to consult at https://sod.pixlab.io/api.html.\r\n * The introduction course is available to consult at https://sod.pixlab.io/intro.html.\r\n */\r\n#ifndef SOD_DISABLE_CNN\r\n/*\r\n * Convolutional/Recurrent Neural Networks (CNN/RNN) API.\r\n *\r\n * The interfaces are documented at https://sod.pixlab.io/api.html#cnn.\r\n */\r\nSOD_APIEXPORT int  sod_cnn_create(sod_cnn **ppOut, const char *zArch, const char *zModelPath, const char **pzErr);\r\nSOD_APIEXPORT int  sod_cnn_config(sod_cnn *pNet, SOD_CNN_CONFIG conf, ...);\r\nSOD_APIEXPORT int  sod_cnn_predict(sod_cnn *pNet, float *pInput, sod_box **paBox, int *pnBox);\r\nSOD_APIEXPORT void sod_cnn_destroy(sod_cnn *pNet);\r\nSOD_APIEXPORT float *  sod_cnn_prepare_image(sod_cnn *pNet, sod_img in);\r\nSOD_APIEXPORT int sod_cnn_get_network_size(sod_cnn *pNet, int *pWidth, int *pHeight, int *pChannels);\r\n#endif /* SOD_DISABLE_CNN */\r\n#ifndef SOD_DISABLE_REALNET\r\n/*\r\n * RealNets API.\r\n *\r\n * The interfaces are documented at https://sod.pixlab.io/api.html#realnet.\r\n */\r\nSOD_APIEXPORT int sod_realnet_create(sod_realnet **ppOut);\r\nSOD_APIEXPORT int sod_realnet_load_model_from_mem(sod_realnet *pNet, const void * pModel, unsigned int nBytes, sod_realnet_model_handle *pOutHandle);\r\n#ifdef SOD_NO_MMAP\r\nSOD_APIEXPORT int sod_realnet_load_model_from_disk(sod_realnet *pNet, const char * zPath, sod_realnet_model_handle *pOutHandle);\r\n#endif\r\nSOD_APIEXPORT int sod_realnet_model_config(sod_realnet *pNet, sod_realnet_model_handle handle, SOD_REALNET_MODEL_CONFIG conf, ...);\r\nSOD_APIEXPORT int sod_realnet_detect(sod_realnet *pNet, const unsigned char *zGrayImg, int width, int height, sod_box **apBox, int *pnBox);\r\nSOD_APIEXPORT void sod_realnet_destroy(sod_realnet *pNet);\r\n#endif /* SOD_DISABLE_REALNET */\r\n#ifdef SOD_ENABLE_NET_TRAIN\r\n/*\r\n * RealNets Training API.\r\n *\r\n * The interfaces are documented at https://sod.pixlab.io/api.html#realnet_train.\r\n */\r\nSOD_APIEXPORT int  sod_realnet_train_init(sod_realnet_trainer **ppOut);\r\nSOD_APIEXPORT int  sod_realnet_train_config(sod_realnet_trainer *pTrainer, SOD_REALNET_TRAINER_CONFIG op, ...);\r\nSOD_APIEXPORT int  sod_realnet_train_start(sod_realnet_trainer *pTrainer, const char *zConf);\r\nSOD_APIEXPORT void sod_realnet_train_release(sod_realnet_trainer *pTrainer);\r\n#endif /* SOD_ENABLE_NET_TRAIN */\r\n/* \r\n * Image Processing API.\r\n *\r\n * The interfaces are documented at https://sod.pixlab.io/api.html#imgproc.\r\n */\r\nSOD_APIEXPORT sod_img sod_make_empty_image(int w, int h, int c);\r\nSOD_APIEXPORT sod_img sod_make_image(int w, int h, int c);\r\nSOD_APIEXPORT int sod_grow_image(sod_img *pImg,int w, int h, int c);\r\nSOD_APIEXPORT sod_img sod_make_random_image(int w, int h, int c);\r\nSOD_APIEXPORT sod_img sod_copy_image(sod_img m);\r\nSOD_APIEXPORT void sod_free_image(sod_img m);\r\n\r\n#ifndef SOD_DISABLE_IMG_READER\r\nSOD_APIEXPORT sod_img sod_img_load_from_file(const char *zFile, int nChannels);\r\nSOD_APIEXPORT sod_img sod_img_load_from_mem(const unsigned char *zBuf, int buf_len, int nChannels);\r\nSOD_APIEXPORT int  sod_img_set_load_from_directory(const char *zPath, sod_img ** apLoaded, int * pnLoaded, int max_entries);\r\nSOD_APIEXPORT void sod_img_set_release(sod_img *aLoaded, int nEntries);\r\n#ifndef SOD_DISABLE_IMG_WRITER\r\nSOD_APIEXPORT int sod_img_save_as_png(sod_img input, const char *zPath);\r\nSOD_APIEXPORT int sod_img_save_as_jpeg(sod_img input, const char *zPath, int Quality);\r\nSOD_APIEXPORT int sod_img_blob_save_as_png(const char * zPath, const unsigned char *zBlob, int width, int height, int nChannels);\r\nSOD_APIEXPORT int sod_img_blob_save_as_jpeg(const char * zPath, const unsigned char *zBlob, int width, int height, int nChannels, int Quality);\r\nSOD_APIEXPORT int sod_img_blob_save_as_bmp(const char * zPath, const unsigned char *zBlob, int width, int height, int nChannels);\r\n#endif /* SOD_DISABLE_IMG_WRITER */\r\n#define sod_img_load_color(zPath) sod_img_load_from_file(zPath, SOD_IMG_COLOR)\r\n#define sod_img_load_grayscale(zPath) sod_img_load_from_file(zPath, SOD_IMG_GRAYSCALE)\r\n#endif /* SOD_DISABLE_IMG_READER */\r\n\r\nSOD_APIEXPORT float sod_img_get_pixel(sod_img m, int x, int y, int c);\r\nSOD_APIEXPORT void sod_img_set_pixel(sod_img m, int x, int y, int c, float val);\r\nSOD_APIEXPORT void sod_img_add_pixel(sod_img m, int x, int y, int c, float val);\r\nSOD_APIEXPORT sod_img sod_img_get_layer(sod_img m, int l);\r\n\r\nSOD_APIEXPORT void sod_img_rgb_to_hsv(sod_img im);\r\nSOD_APIEXPORT void sod_img_hsv_to_rgb(sod_img im);\r\nSOD_APIEXPORT void sod_img_rgb_to_bgr(sod_img im);\r\nSOD_APIEXPORT void sod_img_bgr_to_rgb(sod_img im);\r\nSOD_APIEXPORT void sod_img_yuv_to_rgb(sod_img im);\r\nSOD_APIEXPORT void sod_img_rgb_to_yuv(sod_img im);\r\n\r\n/* Introduced in version 1.1.9 */\r\nSOD_APIEXPORT void sod_constrain_image(sod_img im);\r\nSOD_APIEXPORT sod_img sod_img_mask_to_rgb(sod_img mask);\r\nSOD_APIEXPORT void sod_censor_image(sod_img im, int dx, int dy, int w, int h);\r\nSOD_APIEXPORT void sod_saturate_image(sod_img im, float sat);\r\nSOD_APIEXPORT void sod_saturate_exposure_image(sod_img im, float sat, float exposure);\r\nSOD_APIEXPORT void sod_hue_image(sod_img im, float hue);\r\nSOD_APIEXPORT void sod_exposure_image(sod_img im, float sat);\r\nSOD_APIEXPORT void sod_distort_image(sod_img im, float hue, float sat, float val);\r\nSOD_APIEXPORT void sod_random_distort_image(sod_img im, float hue, float saturation, float exposure);\r\nSOD_APIEXPORT sod_img sod_box_blur_image(sod_img im);\r\nSOD_APIEXPORT void sod_image_sepia_filter(sod_img rgb);\r\nSOD_APIEXPORT sod_img sod_gaussian_blur_image(sod_img im, int radius, double sigma);\r\n\r\nSOD_APIEXPORT sod_img sod_minutiae(sod_img bin, int *pTotal, int *pEp, int *pBp);\r\nSOD_APIEXPORT sod_img sod_gaussian_noise_reduce(sod_img grayscale);\r\nSOD_APIEXPORT sod_img sod_equalize_histogram(sod_img im);\r\n\r\nSOD_APIEXPORT sod_img sod_grayscale_image(sod_img im);\r\nSOD_APIEXPORT void sod_grayscale_image_3c(sod_img im);\r\n\r\nSOD_APIEXPORT sod_img sod_threshold_image(sod_img im, float thresh);\r\nSOD_APIEXPORT sod_img sod_otsu_binarize_image(sod_img im);\r\nSOD_APIEXPORT sod_img sod_binarize_image(sod_img im, int reverse);\r\nSOD_APIEXPORT sod_img sod_dilate_image(sod_img im, int times);\r\nSOD_APIEXPORT sod_img sod_erode_image(sod_img im, int times);\r\n\r\nSOD_APIEXPORT sod_img sod_sharpen_filtering_image(sod_img im);\r\nSOD_APIEXPORT sod_img sod_hilditch_thin_image(sod_img im);\r\n\r\nSOD_APIEXPORT sod_img sod_sobel_image(sod_img im);\r\nSOD_APIEXPORT sod_img sod_canny_edge_image(sod_img im, int reduce_noise);\r\n\r\nSOD_APIEXPORT sod_pts * sod_hough_lines_detect(sod_img im, int threshold, int *nPts);\r\nSOD_APIEXPORT void sod_hough_lines_release(sod_pts *pLines);\r\n\r\nSOD_APIEXPORT int sod_image_find_blobs(sod_img im, sod_box **paBox, int *pnBox, int(*xFilter)(int width, int height));\r\nSOD_APIEXPORT void sod_image_blob_boxes_release(sod_box *pBox);\r\n\r\nSOD_APIEXPORT void sod_composite_image(sod_img source, sod_img dest, int dx, int dy);\r\nSOD_APIEXPORT void sod_flip_image(sod_img input);\r\nSOD_APIEXPORT sod_img sod_image_distance(sod_img a, sod_img b);\r\n\r\nSOD_APIEXPORT void sod_embed_image(sod_img source, sod_img dest, int dx, int dy);\r\nSOD_APIEXPORT sod_img sod_blend_image(sod_img fore, sod_img back, float alpha);\r\nSOD_APIEXPORT void sod_scale_image_channel(sod_img im, int c, float v);\r\nSOD_APIEXPORT void sod_translate_image_channel(sod_img im, int c, float v);\r\n\r\nSOD_APIEXPORT sod_img sod_resize_image(sod_img im, int w, int h);\r\nSOD_APIEXPORT sod_img sod_resize_max(sod_img im, int max);\r\nSOD_APIEXPORT sod_img sod_resize_min(sod_img im, int min);\r\nSOD_APIEXPORT sod_img sod_rotate_crop_image(sod_img im, float rad, float s, int w, int h, float dx, float dy, float aspect);\r\nSOD_APIEXPORT sod_img sod_rotate_image(sod_img im, float rad);\r\n\r\nSOD_APIEXPORT void sod_translate_image(sod_img m, float s);\r\nSOD_APIEXPORT void sod_scale_image(sod_img m, float s);\r\nSOD_APIEXPORT void sod_normalize_image(sod_img p);\r\nSOD_APIEXPORT void sod_transpose_image(sod_img im);\r\n\r\nSOD_APIEXPORT sod_img sod_crop_image(sod_img im, int dx, int dy, int w, int h);\r\nSOD_APIEXPORT sod_img sod_random_crop_image(sod_img im, int w, int h);\r\nSOD_APIEXPORT sod_img sod_random_augment_image(sod_img im, float angle, float aspect, int low, int high, int size);\r\n\r\nSOD_APIEXPORT void sod_image_draw_box(sod_img im, int x1, int y1, int x2, int y2, float r, float g, float b);\r\nSOD_APIEXPORT void sod_image_draw_box_grayscale(sod_img im, int x1, int y1, int x2, int y2, float g);\r\nSOD_APIEXPORT void sod_image_draw_circle(sod_img im, int x0, int y0, int radius, float r, float g, float b);\r\nSOD_APIEXPORT void sod_image_draw_circle_thickness(sod_img im, int x0, int y0, int radius, int width, float r, float g, float b);\r\nSOD_APIEXPORT void sod_image_draw_bbox(sod_img im, sod_box bbox, float r, float g, float b);\r\nSOD_APIEXPORT void sod_image_draw_bbox_width(sod_img im, sod_box bbox, int width, float r, float g, float b);\r\nSOD_APIEXPORT void sod_image_draw_line(sod_img im, sod_pts start, sod_pts end, float r, float g, float b);\r\n\r\nSOD_APIEXPORT unsigned char * sod_image_to_blob(sod_img im);\r\nSOD_APIEXPORT void sod_image_free_blob(unsigned char *zBlob);\r\n/*\r\n * OpenCV Integration API. The library must be compiled against OpenCV\r\n * with the compile-time directive SOD_ENABLE_OPENCV defined.\r\n *\r\n * The documentation is available to consult at https://sod.pixlab.io/api.html#cmpl_opencv.\r\n * The interfaces are documented at https://sod.pixlab.io/api.html#cvinter.\r\n */\r\n#ifdef SOD_ENABLE_OPENCV\r\n/*\r\n * Change the include paths to the directory where OpenCV reside\r\n * if those headers are not found by your compiler.\r\n */\r\n#include <opencv2/highgui/highgui_c.h>\r\n#include <opencv2/imgproc/imgproc_c.h>\r\n\r\nSOD_APIEXPORT sod_img sod_img_load_cv_ipl(IplImage* src);\r\nSOD_APIEXPORT sod_img sod_img_load_from_cv(const char *filename, int channels);\r\nSOD_APIEXPORT sod_img sod_img_load_from_cv_stream(CvCapture *cap);\r\nSOD_APIEXPORT int  sod_img_fill_from_cv_stream(CvCapture *cap, sod_img *pImg);\r\nSOD_APIEXPORT void sod_img_save_to_cv_jpg(sod_img im, const char *zPath);\r\n#endif /* SOD_ENABLE_OPENCV */\r\n/*\r\n * SOD Embedded Release Information & Copyright Notice.\r\n */\r\nSOD_APIEXPORT const char * sod_lib_copyright(void);\r\n#define SOD_LIB_INFO \"SOD Embedded - Release 1.1.9 under GPLv3/Commercial Licensing. Copyright (C) 2018 - 2023 PixLab| Symisc Systems, https://sod.pixlab.io\"\r\n#ifdef __cplusplus\r\n }\r\n#endif \r\n#endif /* _SOD_H_ */\r\n"
        },
        {
          "name": "sod_img_reader.h",
          "type": "blob",
          "size": 297.193359375,
          "content": "/*\r\n* SOD - An Embedded Computer Vision & Machine Learning Library.\r\n* Copyright (C) 2018 - 2023 PixLab| Symisc Systems. https://sod.pixlab.io\r\n* Version 1.1.9\r\n*\r\n* Symisc Systems employs a dual licensing model that offers customers\r\n* a choice of either our open source license (GPLv3) or a commercial\r\n* license.\r\n*\r\n* For information on licensing, redistribution of the SOD library, and for a DISCLAIMER OF ALL WARRANTIES\r\n* please visit:\r\n*     https://pixlab.io/sod\r\n* or contact:\r\n*     licensing@symisc.net\r\n*     support@pixlab.io\r\n*/\r\n/* stb_image - v2.28 - public domain image loader - http://nothings.org/stb\r\n                                  no warranty implied; use at your own risk\r\n\r\n   Do this:\r\n      #define STB_IMAGE_IMPLEMENTATION\r\n   before you include this file in *one* C or C++ file to create the implementation.\r\n\r\n   // i.e. it should look like this:\r\n   #include ...\r\n   #include ...\r\n   #include ...\r\n   #define STB_IMAGE_IMPLEMENTATION\r\n   #include \"stb_image.h\"\r\n\r\n   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.\r\n   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free\r\n\r\n\r\n   QUICK NOTES:\r\n      Primarily of interest to game developers and other people who can\r\n          avoid problematic images and only need the trivial interface\r\n\r\n      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)\r\n      PNG 1/2/4/8/16-bit-per-channel\r\n\r\n      TGA (not sure what subset, if a subset)\r\n      BMP non-1bpp, non-RLE\r\n      PSD (composited view only, no extra channels, 8/16 bit-per-channel)\r\n\r\n      GIF (*comp always reports as 4-channel)\r\n      HDR (radiance rgbE format)\r\n      PIC (Softimage PIC)\r\n      PNM (PPM and PGM binary only)\r\n\r\n      Animated GIF still needs a proper API, but here's one way to do it:\r\n          http://gist.github.com/urraka/685d9a6340b26b830d49\r\n\r\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\r\n      - decode from arbitrary I/O callbacks\r\n      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)\r\n\r\n   Full documentation under \"DOCUMENTATION\" below.\r\n\r\n\r\nLICENSE\r\n\r\n  See end of file for license information.\r\n\r\nRECENT REVISION HISTORY:\r\n\r\n      2.28  (2023-01-29) many error fixes, security errors, just tons of stuff\r\n      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes\r\n      2.26  (2020-07-13) many minor fixes\r\n      2.25  (2020-02-02) fix warnings\r\n      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically\r\n      2.23  (2019-08-11) fix clang static analysis warning\r\n      2.22  (2019-03-04) gif fixes, fix warnings\r\n      2.21  (2019-02-25) fix typo in comment\r\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\r\n      2.19  (2018-02-11) fix warning\r\n      2.18  (2018-01-30) fix warnings\r\n      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings\r\n      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes\r\n      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC\r\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\r\n      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes\r\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\r\n      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64\r\n                         RGB-format JPEG; remove white matting in PSD;\r\n                         allocate large structures on the stack;\r\n                         correct channel count for PNG & BMP\r\n      2.10  (2016-01-22) avoid warning introduced in 2.09\r\n      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED\r\n\r\n   See end of file for full revision history.\r\n\r\n\r\n ============================    Contributors    =========================\r\n\r\n Image formats                          Extensions, features\r\n    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)\r\n    Nicolas Schulz (hdr, psd)              Martin \"SpartanJ\" Golini (stbi_info)\r\n    Jonathan Dummer (tga)                  James \"moose2000\" Brown (iPhone PNG)\r\n    Jean-Marc Lienher (gif)                Ben \"Disch\" Wenger (io callbacks)\r\n    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)\r\n    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)\r\n    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)\r\n    github:urraka (animated gif)           Junggon Kim (PNM comments)\r\n    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)\r\n                                           socks-the-fox (16-bit PNG)\r\n                                           Jeremy Sawicki (handle all ImageNet JPGs)\r\n Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)\r\n    Fabian \"ryg\" Giesen                    Anael Seghezzi (is-16-bit query)\r\n    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)\r\n    John-Mark Allen\r\n    Carmelo J Fdez-Aguera\r\n\r\n Bug & warning fixes\r\n    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko\r\n    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski\r\n    Phil Jordan                                Dave Moore           Roy Eltham\r\n    Hayaki Saito            Nathan Reed        Won Chun\r\n    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community\r\n    Thomas Ruf              Ronny Chevalier                         github:rlyeh\r\n    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou\r\n    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk\r\n    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar\r\n    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex\r\n    Cass Everitt            Ryamond Barbiero                        github:grim210\r\n    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw\r\n    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus\r\n    Josh Tobin              Neil Bickford      Matthew Gregan       github:poppolopoppo\r\n    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji\r\n    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007\r\n                            Brad Weinberger    Matvey Cherevko      github:mosra\r\n    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]\r\n    Ryan C. Gordon          [reserved]                              [reserved]\r\n                     DO NOT ADD YOUR NAME HERE\r\n\r\n                     Jacko Dirks\r\n\r\n  To add your name to the credits, pick a random blank space in the middle and fill it.\r\n  80% of merge conflicts on stb PRs are due to people adding their name at the end\r\n  of the credits.\r\n*/\r\n\r\n#ifndef STBI_INCLUDE_STB_IMAGE_H\r\n#define STBI_INCLUDE_STB_IMAGE_H\r\n\r\n// DOCUMENTATION\r\n//\r\n// Limitations:\r\n//    - no 12-bit-per-channel JPEG\r\n//    - no JPEGs with arithmetic coding\r\n//    - GIF always returns *comp=4\r\n//\r\n// Basic usage (see HDR discussion below for HDR usage):\r\n//    int x,y,n;\r\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\r\n//    // ... process data if not NULL ...\r\n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\r\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\r\n//    // ... but 'n' will always be the number that it would have been if you said 0\r\n//    stbi_image_free(data);\r\n//\r\n// Standard parameters:\r\n//    int *x                 -- outputs image width in pixels\r\n//    int *y                 -- outputs image height in pixels\r\n//    int *channels_in_file  -- outputs # of image components in image file\r\n//    int desired_channels   -- if non-zero, # of image components requested in result\r\n//\r\n// The return value from an image loader is an 'unsigned char *' which points\r\n// to the pixel data, or NULL on an allocation failure or if the image is\r\n// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,\r\n// with each pixel consisting of N interleaved 8-bit components; the first\r\n// pixel pointed to is top-left-most in the image. There is no padding between\r\n// image scanlines or between pixels, regardless of format. The number of\r\n// components N is 'desired_channels' if desired_channels is non-zero, or\r\n// *channels_in_file otherwise. If desired_channels is non-zero,\r\n// *channels_in_file has the number of components that _would_ have been\r\n// output otherwise. E.g. if you set desired_channels to 4, you will always\r\n// get RGBA output, but you can check *channels_in_file to see if it's trivially\r\n// opaque because e.g. there were only 3 channels in the source image.\r\n//\r\n// An output image with N components has the following components interleaved\r\n// in this order in each pixel:\r\n//\r\n//     N=#comp     components\r\n//       1           grey\r\n//       2           grey, alpha\r\n//       3           red, green, blue\r\n//       4           red, green, blue, alpha\r\n//\r\n// If image loading fails for any reason, the return value will be NULL,\r\n// and *x, *y, *channels_in_file will be unchanged. The function\r\n// stbi_failure_reason() can be queried for an extremely brief, end-user\r\n// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS\r\n// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\r\n// more user-friendly ones.\r\n//\r\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\r\n//\r\n// To query the width, height and component count of an image without having to\r\n// decode the full file, you can use the stbi_info family of functions:\r\n//\r\n//   int x,y,n,ok;\r\n//   ok = stbi_info(filename, &x, &y, &n);\r\n//   // returns ok=1 and sets x, y, n if image is a supported format,\r\n//   // 0 otherwise.\r\n//\r\n// Note that stb_image pervasively uses ints in its public API for sizes,\r\n// including sizes of memory buffers. This is now part of the API and thus\r\n// hard to change without causing breakage. As a result, the various image\r\n// loaders all have certain limits on image size; these differ somewhat\r\n// by format but generally boil down to either just under 2GB or just under\r\n// 1GB. When the decoded image would be larger than this, stb_image decoding\r\n// will fail.\r\n//\r\n// Additionally, stb_image will reject image files that have any of their\r\n// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,\r\n// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,\r\n// the only way to have an image with such dimensions load correctly\r\n// is for it to have a rather extreme aspect ratio. Either way, the\r\n// assumption here is that such larger images are likely to be malformed\r\n// or malicious. If you do need to load an image with individual dimensions\r\n// larger than that, and it still fits in the overall size limit, you can\r\n// #define STBI_MAX_DIMENSIONS on your own to be something larger.\r\n//\r\n// ===========================================================================\r\n//\r\n// UNICODE:\r\n//\r\n//   If compiling for Windows and you wish to use Unicode filenames, compile\r\n//   with\r\n//       #define STBI_WINDOWS_UTF8\r\n//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert\r\n//   Windows wchar_t filenames to utf8.\r\n//\r\n// ===========================================================================\r\n//\r\n// Philosophy\r\n//\r\n// stb libraries are designed with the following priorities:\r\n//\r\n//    1. easy to use\r\n//    2. easy to maintain\r\n//    3. good performance\r\n//\r\n// Sometimes I let \"good performance\" creep up in priority over \"easy to maintain\",\r\n// and for best performance I may provide less-easy-to-use APIs that give higher\r\n// performance, in addition to the easy-to-use ones. Nevertheless, it's important\r\n// to keep in mind that from the standpoint of you, a client of this library,\r\n// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.\r\n//\r\n// Some secondary priorities arise directly from the first two, some of which\r\n// provide more explicit reasons why performance can't be emphasized.\r\n//\r\n//    - Portable (\"ease of use\")\r\n//    - Small source code footprint (\"easy to maintain\")\r\n//    - No dependencies (\"ease of use\")\r\n//\r\n// ===========================================================================\r\n//\r\n// I/O callbacks\r\n//\r\n// I/O callbacks allow you to read from arbitrary sources, like packaged\r\n// files or some other source. Data read from callbacks are processed\r\n// through a small internal buffer (currently 128 bytes) to try to reduce\r\n// overhead.\r\n//\r\n// The three functions you must define are \"read\" (reads some bytes of data),\r\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\r\n//\r\n// ===========================================================================\r\n//\r\n// SIMD support\r\n//\r\n// The JPEG decoder will try to automatically use SIMD kernels on x86 when\r\n// supported by the compiler. For ARM Neon support, you must explicitly\r\n// request it.\r\n//\r\n// (The old do-it-yourself SIMD API is no longer supported in the current\r\n// code.)\r\n//\r\n// On x86, SSE2 will automatically be used when available based on a run-time\r\n// test; if not, the generic C versions are used as a fall-back. On ARM targets,\r\n// the typical path is to have separate builds for NEON and non-NEON devices\r\n// (at least this is true for iOS and Android). Therefore, the NEON support is\r\n// toggled by a build flag: define STBI_NEON to get NEON loops.\r\n//\r\n// If for some reason you do not want to use any of SIMD code, or if\r\n// you have issues compiling it, you can disable it entirely by\r\n// defining STBI_NO_SIMD.\r\n//\r\n// ===========================================================================\r\n//\r\n// HDR image support   (disable by defining STBI_NO_HDR)\r\n//\r\n// stb_image supports loading HDR images in general, and currently the Radiance\r\n// .HDR file format specifically. You can still load any file through the existing\r\n// interface; if you attempt to load an HDR file, it will be automatically remapped\r\n// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\r\n// both of these constants can be reconfigured through this interface:\r\n//\r\n//     stbi_hdr_to_ldr_gamma(2.2f);\r\n//     stbi_hdr_to_ldr_scale(1.0f);\r\n//\r\n// (note, do not use _inverse_ constants; stbi_image will invert them\r\n// appropriately).\r\n//\r\n// Additionally, there is a new, parallel interface for loading files as\r\n// (linear) floats to preserve the full dynamic range:\r\n//\r\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\r\n//\r\n// If you load LDR images through this interface, those images will\r\n// be promoted to floating point values, run through the inverse of\r\n// constants corresponding to the above:\r\n//\r\n//     stbi_ldr_to_hdr_scale(1.0f);\r\n//     stbi_ldr_to_hdr_gamma(2.2f);\r\n//\r\n// Finally, given a filename (or an open file or memory block--see header\r\n// file for details) containing image data, you can query for the \"most\r\n// appropriate\" interface to use (that is, whether the image is HDR or\r\n// not), using:\r\n//\r\n//     stbi_is_hdr(char *filename);\r\n//\r\n// ===========================================================================\r\n//\r\n// iPhone PNG support:\r\n//\r\n// We optionally support converting iPhone-formatted PNGs (which store\r\n// premultiplied BGRA) back to RGB, even though they're internally encoded\r\n// differently. To enable this conversion, call\r\n// stbi_convert_iphone_png_to_rgb(1).\r\n//\r\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\r\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\r\n// says there's premultiplied data (currently only happens in iPhone images,\r\n// and only if iPhone convert-to-rgb processing is on).\r\n//\r\n// ===========================================================================\r\n//\r\n// ADDITIONAL CONFIGURATION\r\n//\r\n//  - You can suppress implementation of any of the decoders to reduce\r\n//    your code footprint by #defining one or more of the following\r\n//    symbols before creating the implementation.\r\n//\r\n//        STBI_NO_JPEG\r\n//        STBI_NO_PNG\r\n//        STBI_NO_BMP\r\n//        STBI_NO_PSD\r\n//        STBI_NO_TGA\r\n//        STBI_NO_GIF\r\n//        STBI_NO_HDR\r\n//        STBI_NO_PIC\r\n//        STBI_NO_PNM   (.ppm and .pgm)\r\n//\r\n//  - You can request *only* certain decoders and suppress all other ones\r\n//    (this will be more forward-compatible, as addition of new decoders\r\n//    doesn't require you to disable them explicitly):\r\n//\r\n//        STBI_ONLY_JPEG\r\n//        STBI_ONLY_PNG\r\n//        STBI_ONLY_BMP\r\n//        STBI_ONLY_PSD\r\n//        STBI_ONLY_TGA\r\n//        STBI_ONLY_GIF\r\n//        STBI_ONLY_HDR\r\n//        STBI_ONLY_PIC\r\n//        STBI_ONLY_PNM   (.ppm and .pgm)\r\n//\r\n//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still\r\n//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB\r\n//\r\n//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater\r\n//    than that size (in either width or height) without further processing.\r\n//    This is to let programs in the wild set an upper bound to prevent\r\n//    denial-of-service attacks on untrusted data, as one could generate a\r\n//    valid image of gigantic dimensions and force stb_image to allocate a\r\n//    huge block of memory and spend disproportionate time decoding it. By\r\n//    default this is set to (1 << 24), which is 16777216, but that's still\r\n//    very big.\r\n\r\n#ifndef STBI_NO_STDIO\r\n#include <stdio.h>\r\n#endif // STBI_NO_STDIO\r\n\r\n#define STBI_VERSION 1\r\n\r\nenum\r\n{\r\n    STBI_default = 0, // only used for desired_channels\r\n\r\n    STBI_grey = 1,\r\n    STBI_grey_alpha = 2,\r\n    STBI_rgb = 3,\r\n    STBI_rgb_alpha = 4\r\n};\r\n\r\n#include <stdlib.h>\r\ntypedef unsigned char stbi_uc;\r\ntypedef unsigned short stbi_us;\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifndef STBIDEF\r\n#ifdef STB_IMAGE_STATIC\r\n#define STBIDEF static\r\n#else\r\n#define STBIDEF extern\r\n#endif\r\n#endif\r\n\r\n    //////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // PRIMARY API - works on images of any type\r\n    //\r\n\r\n    //\r\n    // load image by filename, open file, or memory buffer\r\n    //\r\n\r\n    typedef struct\r\n    {\r\n        int      (*read)  (void* user, char* data, int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read\r\n        void     (*skip)  (void* user, int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\r\n        int      (*eof)   (void* user);                       // returns nonzero if we are at end of file/data\r\n    } stbi_io_callbacks;\r\n\r\n    ////////////////////////////////////\r\n    //\r\n    // 8-bits-per-channel interface\r\n    //\r\n\r\n    STBIDEF stbi_uc* stbi_load_from_memory(stbi_uc           const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    STBIDEF stbi_uc* stbi_load_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\n    STBIDEF stbi_uc* stbi_load(char const* filename, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    STBIDEF stbi_uc* stbi_load_from_file(FILE* f, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    // for stbi_load_from_file, file pointer is left pointing immediately after image\r\n#endif\r\n\r\n#ifndef STBI_NO_GIF\r\n    STBIDEF stbi_uc* stbi_load_gif_from_memory(stbi_uc const* buffer, int len, int** delays, int* x, int* y, int* z, int* comp, int req_comp);\r\n#endif\r\n\r\n#ifdef STBI_WINDOWS_UTF8\r\n    STBIDEF int stbi_convert_wchar_to_utf8(char* buffer, size_t bufferlen, const wchar_t* input);\r\n#endif\r\n\r\n    ////////////////////////////////////\r\n    //\r\n    // 16-bits-per-channel interface\r\n    //\r\n\r\n    STBIDEF stbi_us* stbi_load_16_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    STBIDEF stbi_us* stbi_load_16_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\n    STBIDEF stbi_us* stbi_load_16(char const* filename, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    STBIDEF stbi_us* stbi_load_from_file_16(FILE* f, int* x, int* y, int* channels_in_file, int desired_channels);\r\n#endif\r\n\r\n    ////////////////////////////////////\r\n    //\r\n    // float-per-channel interface\r\n    //\r\n#ifndef STBI_NO_LINEAR\r\n    STBIDEF float* stbi_loadf_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    STBIDEF float* stbi_loadf_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\n    STBIDEF float* stbi_loadf(char const* filename, int* x, int* y, int* channels_in_file, int desired_channels);\r\n    STBIDEF float* stbi_loadf_from_file(FILE* f, int* x, int* y, int* channels_in_file, int desired_channels);\r\n#endif\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n    STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\r\n    STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\r\n#endif // STBI_NO_HDR\r\n\r\n#ifndef STBI_NO_LINEAR\r\n    STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\r\n    STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\r\n#endif // STBI_NO_LINEAR\r\n\r\n    // stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR\r\n    STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const* clbk, void* user);\r\n    STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const* buffer, int len);\r\n#ifndef STBI_NO_STDIO\r\n    STBIDEF int      stbi_is_hdr(char const* filename);\r\n    STBIDEF int      stbi_is_hdr_from_file(FILE* f);\r\n#endif // STBI_NO_STDIO\r\n\r\n\r\n    // get a VERY brief reason for failure\r\n    // on most compilers (and ALL modern mainstream compilers) this is threadsafe\r\n    STBIDEF const char* stbi_failure_reason(void);\r\n\r\n    // free the loaded image -- this is just free()\r\n    STBIDEF void     stbi_image_free(void* retval_from_stbi_load);\r\n\r\n    // get image dimensions & components without fully decoding\r\n    STBIDEF int      stbi_info_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp);\r\n    STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* comp);\r\n    STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const* buffer, int len);\r\n    STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const* clbk, void* user);\r\n\r\n#ifndef STBI_NO_STDIO\r\n    STBIDEF int      stbi_info(char const* filename, int* x, int* y, int* comp);\r\n    STBIDEF int      stbi_info_from_file(FILE* f, int* x, int* y, int* comp);\r\n    STBIDEF int      stbi_is_16_bit(char const* filename);\r\n    STBIDEF int      stbi_is_16_bit_from_file(FILE* f);\r\n#endif\r\n\r\n\r\n\r\n    // for image formats that explicitly notate that they have premultiplied alpha,\r\n    // we just return the colors as stored in the file. set this flag to force\r\n    // unpremultiplication. results are undefined if the unpremultiply overflow.\r\n    STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\r\n\r\n    // indicate whether we should process iphone images back to canonical format,\r\n    // or just pass them through \"as-is\"\r\n    STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\r\n\r\n    // flip the image vertically, so the first pixel in the output array is the bottom left\r\n    STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);\r\n\r\n    // as above, but only applies to images loaded on the thread that calls the function\r\n    // this function is only available if your compiler supports thread-local variables;\r\n    // calling it will fail to link if your compiler doesn't\r\n    STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);\r\n    STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);\r\n    STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);\r\n\r\n    // ZLIB client - used by PNG, available for other purposes\r\n\r\n    STBIDEF char* stbi_zlib_decode_malloc_guesssize(const char* buffer, int len, int initial_size, int* outlen);\r\n    STBIDEF char* stbi_zlib_decode_malloc_guesssize_headerflag(const char* buffer, int len, int initial_size, int* outlen, int parse_header);\r\n    STBIDEF char* stbi_zlib_decode_malloc(const char* buffer, int len, int* outlen);\r\n    STBIDEF int   stbi_zlib_decode_buffer(char* obuffer, int olen, const char* ibuffer, int ilen);\r\n\r\n    STBIDEF char* stbi_zlib_decode_noheader_malloc(const char* buffer, int len, int* outlen);\r\n    STBIDEF int   stbi_zlib_decode_noheader_buffer(char* obuffer, int olen, const char* ibuffer, int ilen);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n//\r\n//\r\n////   end header file   /////////////////////////////////////////////////////\r\n#endif // STBI_INCLUDE_STB_IMAGE_H\r\n\r\n#ifdef STB_IMAGE_IMPLEMENTATION\r\n\r\n#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \\\r\n  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \\\r\n  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \\\r\n  || defined(STBI_ONLY_ZLIB)\r\n#ifndef STBI_ONLY_JPEG\r\n#define STBI_NO_JPEG\r\n#endif\r\n#ifndef STBI_ONLY_PNG\r\n#define STBI_NO_PNG\r\n#endif\r\n#ifndef STBI_ONLY_BMP\r\n#define STBI_NO_BMP\r\n#endif\r\n#ifndef STBI_ONLY_PSD\r\n#define STBI_NO_PSD\r\n#endif\r\n#ifndef STBI_ONLY_TGA\r\n#define STBI_NO_TGA\r\n#endif\r\n#ifndef STBI_ONLY_GIF\r\n#define STBI_NO_GIF\r\n#endif\r\n#ifndef STBI_ONLY_HDR\r\n#define STBI_NO_HDR\r\n#endif\r\n#ifndef STBI_ONLY_PIC\r\n#define STBI_NO_PIC\r\n#endif\r\n#ifndef STBI_ONLY_PNM\r\n#define STBI_NO_PNM\r\n#endif\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)\r\n#define STBI_NO_ZLIB\r\n#endif\r\n\r\n\r\n#include <stdarg.h>\r\n#include <stddef.h> // ptrdiff_t on osx\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n\r\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)\r\n#include <math.h>  // ldexp, pow\r\n#endif\r\n\r\n#ifndef STBI_NO_STDIO\r\n#include <stdio.h>\r\n#endif\r\n\r\n#ifndef STBI_ASSERT\r\n#include <assert.h>\r\n#define STBI_ASSERT(x) assert(x)\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n#define STBI_EXTERN extern \"C\"\r\n#else\r\n#define STBI_EXTERN extern\r\n#endif\r\n\r\n\r\n#ifndef _MSC_VER\r\n#ifdef __cplusplus\r\n#define stbi_inline inline\r\n#else\r\n#define stbi_inline\r\n#endif\r\n#else\r\n#define stbi_inline __forceinline\r\n#endif\r\n\r\n#ifndef STBI_NO_THREAD_LOCALS\r\n#if defined(__cplusplus) &&  __cplusplus >= 201103L\r\n#define STBI_THREAD_LOCAL       thread_local\r\n#elif defined(__GNUC__) && __GNUC__ < 5\r\n#define STBI_THREAD_LOCAL       __thread\r\n#elif defined(_MSC_VER)\r\n#define STBI_THREAD_LOCAL       __declspec(thread)\r\n#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\r\n#define STBI_THREAD_LOCAL       _Thread_local\r\n#endif\r\n\r\n#ifndef STBI_THREAD_LOCAL\r\n#if defined(__GNUC__)\r\n#define STBI_THREAD_LOCAL       __thread\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#if defined(_MSC_VER) || defined(__SYMBIAN32__)\r\ntypedef unsigned short stbi__uint16;\r\ntypedef   signed short stbi__int16;\r\ntypedef unsigned int   stbi__uint32;\r\ntypedef   signed int   stbi__int32;\r\n#else\r\n#include <stdint.h>\r\ntypedef uint16_t stbi__uint16;\r\ntypedef int16_t  stbi__int16;\r\ntypedef uint32_t stbi__uint32;\r\ntypedef int32_t  stbi__int32;\r\n#endif\r\n\r\n// should produce compiler error if size is wrong\r\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32) == 4 ? 1 : -1];\r\n\r\n#ifdef _MSC_VER\r\n#define STBI_NOTUSED(v)  (void)(v)\r\n#else\r\n#define STBI_NOTUSED(v)  (void)sizeof(v)\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#define STBI_HAS_LROTL\r\n#endif\r\n\r\n#ifdef STBI_HAS_LROTL\r\n#define stbi_lrot(x,y)  _lrotl(x,y)\r\n#else\r\n#define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))\r\n#endif\r\n\r\n#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))\r\n// ok\r\n#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)\r\n// ok\r\n#else\r\n#error \"Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED).\"\r\n#endif\r\n\r\n#ifndef STBI_MALLOC\r\n#define STBI_MALLOC(sz)           malloc(sz)\r\n#define STBI_REALLOC(p,newsz)     realloc(p,newsz)\r\n#define STBI_FREE(p)              free(p)\r\n#endif\r\n\r\n#ifndef STBI_REALLOC_SIZED\r\n#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)\r\n#endif\r\n\r\n// x86/x64 detection\r\n#if defined(__x86_64__) || defined(_M_X64)\r\n#define STBI__X64_TARGET\r\n#elif defined(__i386) || defined(_M_IX86)\r\n#define STBI__X86_TARGET\r\n#endif\r\n\r\n#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)\r\n// gcc doesn't support sse2 intrinsics unless you compile with -msse2,\r\n// which in turn means it gets to use SSE2 everywhere. This is unfortunate,\r\n// but previous attempts to provide the SSE2 functions with runtime\r\n// detection caused numerous issues. The way architecture extensions are\r\n// exposed in GCC/Clang is, sadly, not really suited for one-file libs.\r\n// New behavior: if compiled with -msse2, we use SSE2 without any\r\n// detection; if not, we don't use it at all.\r\n#define STBI_NO_SIMD\r\n#endif\r\n\r\n#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)\r\n// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET\r\n//\r\n// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the\r\n// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.\r\n// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not\r\n// simultaneously enabling \"-mstackrealign\".\r\n//\r\n// See https://github.com/nothings/stb/issues/81 for more information.\r\n//\r\n// So default to no SSE2 on 32-bit MinGW. If you've read this far and added\r\n// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.\r\n#define STBI_NO_SIMD\r\n#endif\r\n\r\n#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))\r\n#define STBI_SSE2\r\n#include <emmintrin.h>\r\n\r\n#ifdef _MSC_VER\r\n\r\n#if _MSC_VER >= 1400  // not VC6\r\n#include <intrin.h> // __cpuid\r\nstatic int stbi__cpuid3(void)\r\n{\r\n    int info[4];\r\n    __cpuid(info, 1);\r\n    return info[3];\r\n}\r\n#else\r\nstatic int stbi__cpuid3(void)\r\n{\r\n    int res;\r\n    __asm {\r\n        mov  eax, 1\r\n        cpuid\r\n        mov  res, edx\r\n    }\r\n    return res;\r\n}\r\n#endif\r\n\r\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\r\n\r\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\r\nstatic int stbi__sse2_available(void)\r\n{\r\n    int info3 = stbi__cpuid3();\r\n    return ((info3 >> 26) & 1) != 0;\r\n}\r\n#endif\r\n\r\n#else // assume GCC-style if not VC++\r\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\r\n\r\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\r\nstatic int stbi__sse2_available(void)\r\n{\r\n    // If we're even attempting to compile this on GCC/Clang, that means\r\n    // -msse2 is on, which means the compiler is allowed to use SSE2\r\n    // instructions at will, and so are we.\r\n    return 1;\r\n}\r\n#endif\r\n\r\n#endif\r\n#endif\r\n\r\n// ARM NEON\r\n#if defined(STBI_NO_SIMD) && defined(STBI_NEON)\r\n#undef STBI_NEON\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n#include <arm_neon.h>\r\n#ifdef _MSC_VER\r\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\r\n#else\r\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\r\n#endif\r\n#endif\r\n\r\n#ifndef STBI_SIMD_ALIGN\r\n#define STBI_SIMD_ALIGN(type, name) type name\r\n#endif\r\n\r\n#ifndef STBI_MAX_DIMENSIONS\r\n#define STBI_MAX_DIMENSIONS (1 << 24)\r\n#endif\r\n\r\n///////////////////////////////////////////////\r\n//\r\n//  stbi__context struct and start_xxx functions\r\n\r\n// stbi__context structure is our basic context used by all images, so it\r\n// contains all the IO context, plus some basic image information\r\ntypedef struct\r\n{\r\n    stbi__uint32 img_x, img_y;\r\n    int img_n, img_out_n;\r\n\r\n    stbi_io_callbacks io;\r\n    void* io_user_data;\r\n\r\n    int read_from_callbacks;\r\n    int buflen;\r\n    stbi_uc buffer_start[128];\r\n    int callback_already_read;\r\n\r\n    stbi_uc* img_buffer, * img_buffer_end;\r\n    stbi_uc* img_buffer_original, * img_buffer_original_end;\r\n} stbi__context;\r\n\r\n\r\nstatic void stbi__refill_buffer(stbi__context* s);\r\n\r\n// initialize a memory-decode context\r\nstatic void stbi__start_mem(stbi__context* s, stbi_uc const* buffer, int len)\r\n{\r\n    s->io.read = NULL;\r\n    s->read_from_callbacks = 0;\r\n    s->callback_already_read = 0;\r\n    s->img_buffer = s->img_buffer_original = (stbi_uc*)buffer;\r\n    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc*)buffer + len;\r\n}\r\n\r\n// initialize a callback-based context\r\nstatic void stbi__start_callbacks(stbi__context* s, stbi_io_callbacks* c, void* user)\r\n{\r\n    s->io = *c;\r\n    s->io_user_data = user;\r\n    s->buflen = sizeof(s->buffer_start);\r\n    s->read_from_callbacks = 1;\r\n    s->callback_already_read = 0;\r\n    s->img_buffer = s->img_buffer_original = s->buffer_start;\r\n    stbi__refill_buffer(s);\r\n    s->img_buffer_original_end = s->img_buffer_end;\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\n\r\nstatic int stbi__stdio_read(void* user, char* data, int size)\r\n{\r\n    return (int)fread(data, 1, size, (FILE*)user);\r\n}\r\n\r\nstatic void stbi__stdio_skip(void* user, int n)\r\n{\r\n    int ch;\r\n    fseek((FILE*)user, n, SEEK_CUR);\r\n    ch = fgetc((FILE*)user);  /* have to read a byte to reset feof()'s flag */\r\n    if (ch != EOF) {\r\n        ungetc(ch, (FILE*)user);  /* push byte back onto stream if valid. */\r\n    }\r\n}\r\n\r\nstatic int stbi__stdio_eof(void* user)\r\n{\r\n    return feof((FILE*)user) || ferror((FILE*)user);\r\n}\r\n\r\nstatic stbi_io_callbacks stbi__stdio_callbacks =\r\n{\r\n   stbi__stdio_read,\r\n   stbi__stdio_skip,\r\n   stbi__stdio_eof,\r\n};\r\n\r\nstatic void stbi__start_file(stbi__context* s, FILE* f)\r\n{\r\n    stbi__start_callbacks(s, &stbi__stdio_callbacks, (void*)f);\r\n}\r\n\r\n//static void stop_file(stbi__context *s) { }\r\n\r\n#endif // !STBI_NO_STDIO\r\n\r\nstatic void stbi__rewind(stbi__context* s)\r\n{\r\n    // conceptually rewind SHOULD rewind to the beginning of the stream,\r\n    // but we just rewind to the beginning of the initial buffer, because\r\n    // we only use it after doing 'test', which only ever looks at at most 92 bytes\r\n    s->img_buffer = s->img_buffer_original;\r\n    s->img_buffer_end = s->img_buffer_original_end;\r\n}\r\n\r\nenum\r\n{\r\n    STBI_ORDER_RGB,\r\n    STBI_ORDER_BGR\r\n};\r\n\r\ntypedef struct\r\n{\r\n    int bits_per_channel;\r\n    int num_channels;\r\n    int channel_order;\r\n} stbi__result_info;\r\n\r\n#ifndef STBI_NO_JPEG\r\nstatic int      stbi__jpeg_test(stbi__context* s);\r\nstatic void* stbi__jpeg_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__jpeg_info(stbi__context* s, int* x, int* y, int* comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PNG\r\nstatic int      stbi__png_test(stbi__context* s);\r\nstatic void* stbi__png_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__png_info(stbi__context* s, int* x, int* y, int* comp);\r\nstatic int      stbi__png_is16(stbi__context* s);\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int      stbi__bmp_test(stbi__context* s);\r\nstatic void* stbi__bmp_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__bmp_info(stbi__context* s, int* x, int* y, int* comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_TGA\r\nstatic int      stbi__tga_test(stbi__context* s);\r\nstatic void* stbi__tga_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__tga_info(stbi__context* s, int* x, int* y, int* comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int      stbi__psd_test(stbi__context* s);\r\nstatic void* stbi__psd_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri, int bpc);\r\nstatic int      stbi__psd_info(stbi__context* s, int* x, int* y, int* comp);\r\nstatic int      stbi__psd_is16(stbi__context* s);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic int      stbi__hdr_test(stbi__context* s);\r\nstatic float* stbi__hdr_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__hdr_info(stbi__context* s, int* x, int* y, int* comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int      stbi__pic_test(stbi__context* s);\r\nstatic void* stbi__pic_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__pic_info(stbi__context* s, int* x, int* y, int* comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_GIF\r\nstatic int      stbi__gif_test(stbi__context* s);\r\nstatic void* stbi__gif_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic void* stbi__load_gif_main(stbi__context* s, int** delays, int* x, int* y, int* z, int* comp, int req_comp);\r\nstatic int      stbi__gif_info(stbi__context* s, int* x, int* y, int* comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PNM\r\nstatic int      stbi__pnm_test(stbi__context* s);\r\nstatic void* stbi__pnm_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);\r\nstatic int      stbi__pnm_info(stbi__context* s, int* x, int* y, int* comp);\r\nstatic int      stbi__pnm_is16(stbi__context* s);\r\n#endif\r\n\r\nstatic\r\n#ifdef STBI_THREAD_LOCAL\r\nSTBI_THREAD_LOCAL\r\n#endif\r\nconst char* stbi__g_failure_reason;\r\n\r\nSTBIDEF const char* stbi_failure_reason(void)\r\n{\r\n    return stbi__g_failure_reason;\r\n}\r\n\r\n#ifndef STBI_NO_FAILURE_STRINGS\r\nstatic int stbi__err(const char* str)\r\n{\r\n    stbi__g_failure_reason = str;\r\n    return 0;\r\n}\r\n#endif\r\n\r\nstatic void* stbi__malloc(size_t size)\r\n{\r\n    return STBI_MALLOC(size);\r\n}\r\n\r\n// stb_image uses ints pervasively, including for offset calculations.\r\n// therefore the largest decoded image size we can support with the\r\n// current code, even on 64-bit targets, is INT_MAX. this is not a\r\n// significant limitation for the intended use case.\r\n//\r\n// we do, however, need to make sure our size calculations don't\r\n// overflow. hence a few helper functions for size calculations that\r\n// multiply integers together, making sure that they're non-negative\r\n// and no overflow occurs.\r\n\r\n// return 1 if the sum is valid, 0 on overflow.\r\n// negative terms are considered invalid.\r\nstatic int stbi__addsizes_valid(int a, int b)\r\n{\r\n    if (b < 0) return 0;\r\n    // now 0 <= b <= INT_MAX, hence also\r\n    // 0 <= INT_MAX - b <= INTMAX.\r\n    // And \"a + b <= INT_MAX\" (which might overflow) is the\r\n    // same as a <= INT_MAX - b (no overflow)\r\n    return a <= INT_MAX - b;\r\n}\r\n\r\n// returns 1 if the product is valid, 0 on overflow.\r\n// negative factors are considered invalid.\r\nstatic int stbi__mul2sizes_valid(int a, int b)\r\n{\r\n    if (a < 0 || b < 0) return 0;\r\n    if (b == 0) return 1; // mul-by-0 is always safe\r\n    // portable way to check for no overflows in a*b\r\n    return a <= INT_MAX / b;\r\n}\r\n\r\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\r\n// returns 1 if \"a*b + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad2sizes_valid(int a, int b, int add)\r\n{\r\n    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a * b, add);\r\n}\r\n#endif\r\n\r\n// returns 1 if \"a*b*c + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad3sizes_valid(int a, int b, int c, int add)\r\n{\r\n    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&\r\n        stbi__addsizes_valid(a * b * c, add);\r\n}\r\n\r\n// returns 1 if \"a*b*c*d + add\" has no negative terms/factors and doesn't overflow\r\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\r\nstatic int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)\r\n{\r\n    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&\r\n        stbi__mul2sizes_valid(a * b * c, d) && stbi__addsizes_valid(a * b * c * d, add);\r\n}\r\n#endif\r\n\r\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\r\n// mallocs with size overflow checking\r\nstatic void* stbi__malloc_mad2(int a, int b, int add)\r\n{\r\n    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;\r\n    return stbi__malloc(a * b + add);\r\n}\r\n#endif\r\n\r\nstatic void* stbi__malloc_mad3(int a, int b, int c, int add)\r\n{\r\n    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\r\n    return stbi__malloc(a * b * c + add);\r\n}\r\n\r\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\r\nstatic void* stbi__malloc_mad4(int a, int b, int c, int d, int add)\r\n{\r\n    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;\r\n    return stbi__malloc(a * b * c * d + add);\r\n}\r\n#endif\r\n\r\n// returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.\r\nstatic int stbi__addints_valid(int a, int b)\r\n{\r\n    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow\r\n    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.\r\n    return a <= INT_MAX - b;\r\n}\r\n\r\n// returns 1 if the product of two signed shorts is valid, 0 on overflow.\r\nstatic int stbi__mul2shorts_valid(short a, short b)\r\n{\r\n    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow\r\n    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX / b; // product is positive, so similar to mul2sizes_valid\r\n    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN\r\n    return a >= SHRT_MIN / b;\r\n}\r\n\r\n// stbi__err - error\r\n// stbi__errpf - error returning pointer to float\r\n// stbi__errpuc - error returning pointer to unsigned char\r\n\r\n#ifdef STBI_NO_FAILURE_STRINGS\r\n#define stbi__err(x,y)  0\r\n#elif defined(STBI_FAILURE_USERMSG)\r\n#define stbi__err(x,y)  stbi__err(y)\r\n#else\r\n#define stbi__err(x,y)  stbi__err(x)\r\n#endif\r\n\r\n#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))\r\n#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))\r\n\r\nSTBIDEF void stbi_image_free(void* retval_from_stbi_load)\r\n{\r\n    STBI_FREE(retval_from_stbi_load);\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float* stbi__ldr_to_hdr(stbi_uc* data, int x, int y, int comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic stbi_uc* stbi__hdr_to_ldr(float* data, int x, int y, int comp);\r\n#endif\r\n\r\nstatic int stbi__vertically_flip_on_load_global = 0;\r\n\r\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)\r\n{\r\n    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;\r\n}\r\n\r\n#ifndef STBI_THREAD_LOCAL\r\n#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global\r\n#else\r\nstatic STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;\r\n\r\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)\r\n{\r\n    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;\r\n    stbi__vertically_flip_on_load_set = 1;\r\n}\r\n\r\n#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \\\r\n                                         ? stbi__vertically_flip_on_load_local  \\\r\n                                         : stbi__vertically_flip_on_load_global)\r\n#endif // STBI_THREAD_LOCAL\r\n\r\nstatic void* stbi__load_main(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri, int bpc)\r\n{\r\n    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields\r\n    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed\r\n    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order\r\n    ri->num_channels = 0;\r\n\r\n    // test the formats with a very explicit header first (at least a FOURCC\r\n    // or distinctive magic number first)\r\n#ifndef STBI_NO_PNG\r\n    if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n#ifndef STBI_NO_BMP\r\n    if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n#ifndef STBI_NO_GIF\r\n    if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n#ifndef STBI_NO_PSD\r\n    if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp, ri, bpc);\r\n#else\r\n    STBI_NOTUSED(bpc);\r\n#endif\r\n#ifndef STBI_NO_PIC\r\n    if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n\r\n    // then the formats that can end up attempting to load with just 1 or 2\r\n    // bytes matching expectations; these are prone to false positives, so\r\n    // try them later\r\n#ifndef STBI_NO_JPEG\r\n    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n#ifndef STBI_NO_PNM\r\n    if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n    if (stbi__hdr_test(s)) {\r\n        float* hdr = stbi__hdr_load(s, x, y, comp, req_comp, ri);\r\n        return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\r\n    }\r\n#endif\r\n\r\n#ifndef STBI_NO_TGA\r\n    // test tga last because it's a crappy test!\r\n    if (stbi__tga_test(s))\r\n        return stbi__tga_load(s, x, y, comp, req_comp, ri);\r\n#endif\r\n\r\n    return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nstatic stbi_uc* stbi__convert_16_to_8(stbi__uint16* orig, int w, int h, int channels)\r\n{\r\n    int i;\r\n    int img_len = w * h * channels;\r\n    stbi_uc* reduced;\r\n\r\n    reduced = (stbi_uc*)stbi__malloc(img_len);\r\n    if (reduced == NULL) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n    for (i = 0; i < img_len; ++i)\r\n        reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling\r\n\r\n    STBI_FREE(orig);\r\n    return reduced;\r\n}\r\n\r\nstatic stbi__uint16* stbi__convert_8_to_16(stbi_uc* orig, int w, int h, int channels)\r\n{\r\n    int i;\r\n    int img_len = w * h * channels;\r\n    stbi__uint16* enlarged;\r\n\r\n    enlarged = (stbi__uint16*)stbi__malloc(img_len * 2);\r\n    if (enlarged == NULL) return (stbi__uint16*)stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n    for (i = 0; i < img_len; ++i)\r\n        enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff\r\n\r\n    STBI_FREE(orig);\r\n    return enlarged;\r\n}\r\n\r\nstatic void stbi__vertical_flip(void* image, int w, int h, int bytes_per_pixel)\r\n{\r\n    int row;\r\n    size_t bytes_per_row = (size_t)w * bytes_per_pixel;\r\n    stbi_uc temp[2048];\r\n    stbi_uc* bytes = (stbi_uc*)image;\r\n\r\n    for (row = 0; row < (h >> 1); row++) {\r\n        stbi_uc* row0 = bytes + row * bytes_per_row;\r\n        stbi_uc* row1 = bytes + (h - row - 1) * bytes_per_row;\r\n        // swap row0 with row1\r\n        size_t bytes_left = bytes_per_row;\r\n        while (bytes_left) {\r\n            size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);\r\n            memcpy(temp, row0, bytes_copy);\r\n            memcpy(row0, row1, bytes_copy);\r\n            memcpy(row1, temp, bytes_copy);\r\n            row0 += bytes_copy;\r\n            row1 += bytes_copy;\r\n            bytes_left -= bytes_copy;\r\n        }\r\n    }\r\n}\r\n\r\n#ifndef STBI_NO_GIF\r\nstatic void stbi__vertical_flip_slices(void* image, int w, int h, int z, int bytes_per_pixel)\r\n{\r\n    int slice;\r\n    int slice_size = w * h * bytes_per_pixel;\r\n\r\n    stbi_uc* bytes = (stbi_uc*)image;\r\n    for (slice = 0; slice < z; ++slice) {\r\n        stbi__vertical_flip(bytes, w, h, bytes_per_pixel);\r\n        bytes += slice_size;\r\n    }\r\n}\r\n#endif\r\n\r\nstatic unsigned char* stbi__load_and_postprocess_8bit(stbi__context* s, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__result_info ri;\r\n    void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);\r\n\r\n    if (result == NULL)\r\n        return NULL;\r\n\r\n    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\r\n    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\r\n\r\n    if (ri.bits_per_channel != 8) {\r\n        result = stbi__convert_16_to_8((stbi__uint16*)result, *x, *y, req_comp == 0 ? *comp : req_comp);\r\n        ri.bits_per_channel = 8;\r\n    }\r\n\r\n    // @TODO: move stbi__convert_format to here\r\n\r\n    if (stbi__vertically_flip_on_load) {\r\n        int channels = req_comp ? req_comp : *comp;\r\n        stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));\r\n    }\r\n\r\n    return (unsigned char*)result;\r\n}\r\n\r\nstatic stbi__uint16* stbi__load_and_postprocess_16bit(stbi__context* s, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__result_info ri;\r\n    void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);\r\n\r\n    if (result == NULL)\r\n        return NULL;\r\n\r\n    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\r\n    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\r\n\r\n    if (ri.bits_per_channel != 16) {\r\n        result = stbi__convert_8_to_16((stbi_uc*)result, *x, *y, req_comp == 0 ? *comp : req_comp);\r\n        ri.bits_per_channel = 16;\r\n    }\r\n\r\n    // @TODO: move stbi__convert_format16 to here\r\n    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision\r\n\r\n    if (stbi__vertically_flip_on_load) {\r\n        int channels = req_comp ? req_comp : *comp;\r\n        stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));\r\n    }\r\n\r\n    return (stbi__uint16*)result;\r\n}\r\n\r\n#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)\r\nstatic void stbi__float_postprocess(float* result, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    if (stbi__vertically_flip_on_load && result != NULL) {\r\n        int channels = req_comp ? req_comp : *comp;\r\n        stbi__vertical_flip(result, *x, *y, channels * sizeof(float));\r\n    }\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_STDIO\r\n\r\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\r\nSTBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char* str, int cbmb, wchar_t* widestr, int cchwide);\r\nSTBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t* widestr, int cchwide, char* str, int cbmb, const char* defchar, int* used_default);\r\n#endif\r\n\r\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\r\nSTBIDEF int stbi_convert_wchar_to_utf8(char* buffer, size_t bufferlen, const wchar_t* input)\r\n{\r\n    return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int)bufferlen, NULL, NULL);\r\n}\r\n#endif\r\n\r\nstatic FILE* stbi__fopen(char const* filename, char const* mode)\r\n{\r\n    FILE* f;\r\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\r\n    wchar_t wMode[64];\r\n    wchar_t wFilename[1024];\r\n    if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename) / sizeof(*wFilename)))\r\n        return 0;\r\n\r\n    if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode) / sizeof(*wMode)))\r\n        return 0;\r\n\r\n#if defined(_MSC_VER) && _MSC_VER >= 1400\r\n    if (0 != _wfopen_s(&f, wFilename, wMode))\r\n        f = 0;\r\n#else\r\n    f = _wfopen(wFilename, wMode);\r\n#endif\r\n\r\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\r\n    if (0 != fopen_s(&f, filename, mode))\r\n        f = 0;\r\n#else\r\n    f = fopen(filename, mode);\r\n#endif\r\n    return f;\r\n}\r\n\r\n\r\nSTBIDEF stbi_uc* stbi_load(char const* filename, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    FILE* f = stbi__fopen(filename, \"rb\");\r\n    unsigned char* result;\r\n    if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_load_from_file(f, x, y, comp, req_comp);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\nSTBIDEF stbi_uc* stbi_load_from_file(FILE* f, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    unsigned char* result;\r\n    stbi__context s;\r\n    stbi__start_file(&s, f);\r\n    result = stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);\r\n    if (result) {\r\n        // need to 'unget' all the characters in the IO buffer\r\n        fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);\r\n    }\r\n    return result;\r\n}\r\n\r\nSTBIDEF stbi__uint16* stbi_load_from_file_16(FILE* f, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__uint16* result;\r\n    stbi__context s;\r\n    stbi__start_file(&s, f);\r\n    result = stbi__load_and_postprocess_16bit(&s, x, y, comp, req_comp);\r\n    if (result) {\r\n        // need to 'unget' all the characters in the IO buffer\r\n        fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);\r\n    }\r\n    return result;\r\n}\r\n\r\nSTBIDEF stbi_us* stbi_load_16(char const* filename, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    FILE* f = stbi__fopen(filename, \"rb\");\r\n    stbi__uint16* result;\r\n    if (!f) return (stbi_us*)stbi__errpuc(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_load_from_file_16(f, x, y, comp, req_comp);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\n\r\n#endif //!STBI_NO_STDIO\r\n\r\nSTBIDEF stbi_us* stbi_load_16_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels)\r\n{\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n    return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);\r\n}\r\n\r\nSTBIDEF stbi_us* stbi_load_16_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels)\r\n{\r\n    stbi__context s;\r\n    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);\r\n    return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);\r\n}\r\n\r\nSTBIDEF stbi_uc* stbi_load_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n    return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);\r\n}\r\n\r\nSTBIDEF stbi_uc* stbi_load_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);\r\n    return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);\r\n}\r\n\r\n#ifndef STBI_NO_GIF\r\nSTBIDEF stbi_uc* stbi_load_gif_from_memory(stbi_uc const* buffer, int len, int** delays, int* x, int* y, int* z, int* comp, int req_comp)\r\n{\r\n    unsigned char* result;\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n\r\n    result = (unsigned char*)stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);\r\n    if (stbi__vertically_flip_on_load) {\r\n        stbi__vertical_flip_slices(result, *x, *y, *z, *comp);\r\n    }\r\n\r\n    return result;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float* stbi__loadf_main(stbi__context* s, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    unsigned char* data;\r\n#ifndef STBI_NO_HDR\r\n    if (stbi__hdr_test(s)) {\r\n        stbi__result_info ri;\r\n        float* hdr_data = stbi__hdr_load(s, x, y, comp, req_comp, &ri);\r\n        if (hdr_data)\r\n            stbi__float_postprocess(hdr_data, x, y, comp, req_comp);\r\n        return hdr_data;\r\n    }\r\n#endif\r\n    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);\r\n    if (data)\r\n        return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\r\n    return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nSTBIDEF float* stbi_loadf_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n    return stbi__loadf_main(&s, x, y, comp, req_comp);\r\n}\r\n\r\nSTBIDEF float* stbi_loadf_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);\r\n    return stbi__loadf_main(&s, x, y, comp, req_comp);\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF float* stbi_loadf(char const* filename, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    float* result;\r\n    FILE* f = stbi__fopen(filename, \"rb\");\r\n    if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_loadf_from_file(f, x, y, comp, req_comp);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\nSTBIDEF float* stbi_loadf_from_file(FILE* f, int* x, int* y, int* comp, int req_comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_file(&s, f);\r\n    return stbi__loadf_main(&s, x, y, comp, req_comp);\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\n#endif // !STBI_NO_LINEAR\r\n\r\n// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is\r\n// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always\r\n// reports false!\r\n\r\nSTBIDEF int stbi_is_hdr_from_memory(stbi_uc const* buffer, int len)\r\n{\r\n#ifndef STBI_NO_HDR\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n    return stbi__hdr_test(&s);\r\n#else\r\n    STBI_NOTUSED(buffer);\r\n    STBI_NOTUSED(len);\r\n    return 0;\r\n#endif\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_is_hdr(char const* filename)\r\n{\r\n    FILE* f = stbi__fopen(filename, \"rb\");\r\n    int result = 0;\r\n    if (f) {\r\n        result = stbi_is_hdr_from_file(f);\r\n        fclose(f);\r\n    }\r\n    return result;\r\n}\r\n\r\nSTBIDEF int stbi_is_hdr_from_file(FILE* f)\r\n{\r\n#ifndef STBI_NO_HDR\r\n    long pos = ftell(f);\r\n    int res;\r\n    stbi__context s;\r\n    stbi__start_file(&s, f);\r\n    res = stbi__hdr_test(&s);\r\n    fseek(f, pos, SEEK_SET);\r\n    return res;\r\n#else\r\n    STBI_NOTUSED(f);\r\n    return 0;\r\n#endif\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const* clbk, void* user)\r\n{\r\n#ifndef STBI_NO_HDR\r\n    stbi__context s;\r\n    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);\r\n    return stbi__hdr_test(&s);\r\n#else\r\n    STBI_NOTUSED(clbk);\r\n    STBI_NOTUSED(user);\r\n    return 0;\r\n#endif\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float stbi__l2h_gamma = 2.2f, stbi__l2h_scale = 1.0f;\r\n\r\nSTBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\r\nSTBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\r\n#endif\r\n\r\nstatic float stbi__h2l_gamma_i = 1.0f / 2.2f, stbi__h2l_scale_i = 1.0f;\r\n\r\nSTBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }\r\nSTBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Common code used by all image loaders\r\n//\r\n\r\nenum\r\n{\r\n    STBI__SCAN_load = 0,\r\n    STBI__SCAN_type,\r\n    STBI__SCAN_header\r\n};\r\n\r\nstatic void stbi__refill_buffer(stbi__context* s)\r\n{\r\n    int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);\r\n    s->callback_already_read += (int)(s->img_buffer - s->img_buffer_original);\r\n    if (n == 0) {\r\n        // at end of file, treat same as if from memory, but need to handle case\r\n        // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\r\n        s->read_from_callbacks = 0;\r\n        s->img_buffer = s->buffer_start;\r\n        s->img_buffer_end = s->buffer_start + 1;\r\n        *s->img_buffer = 0;\r\n    }\r\n    else {\r\n        s->img_buffer = s->buffer_start;\r\n        s->img_buffer_end = s->buffer_start + n;\r\n    }\r\n}\r\n\r\nstbi_inline static stbi_uc stbi__get8(stbi__context* s)\r\n{\r\n    if (s->img_buffer < s->img_buffer_end)\r\n        return *s->img_buffer++;\r\n    if (s->read_from_callbacks) {\r\n        stbi__refill_buffer(s);\r\n        return *s->img_buffer++;\r\n    }\r\n    return 0;\r\n}\r\n\r\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\r\n// nothing\r\n#else\r\nstbi_inline static int stbi__at_eof(stbi__context* s)\r\n{\r\n    if (s->io.read) {\r\n        if (!(s->io.eof)(s->io_user_data)) return 0;\r\n        // if feof() is true, check if buffer = end\r\n        // special case: we've only got the special 0 character at the end\r\n        if (s->read_from_callbacks == 0) return 1;\r\n    }\r\n\r\n    return s->img_buffer >= s->img_buffer_end;\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)\r\n// nothing\r\n#else\r\nstatic void stbi__skip(stbi__context* s, int n)\r\n{\r\n    if (n == 0) return;  // already there!\r\n    if (n < 0) {\r\n        s->img_buffer = s->img_buffer_end;\r\n        return;\r\n    }\r\n    if (s->io.read) {\r\n        int blen = (int)(s->img_buffer_end - s->img_buffer);\r\n        if (blen < n) {\r\n            s->img_buffer = s->img_buffer_end;\r\n            (s->io.skip)(s->io_user_data, n - blen);\r\n            return;\r\n        }\r\n    }\r\n    s->img_buffer += n;\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)\r\n// nothing\r\n#else\r\nstatic int stbi__getn(stbi__context* s, stbi_uc* buffer, int n)\r\n{\r\n    if (s->io.read) {\r\n        int blen = (int)(s->img_buffer_end - s->img_buffer);\r\n        if (blen < n) {\r\n            int res, count;\r\n\r\n            memcpy(buffer, s->img_buffer, blen);\r\n\r\n            count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);\r\n            res = (count == (n - blen));\r\n            s->img_buffer = s->img_buffer_end;\r\n            return res;\r\n        }\r\n    }\r\n\r\n    if (s->img_buffer + n <= s->img_buffer_end) {\r\n        memcpy(buffer, s->img_buffer, n);\r\n        s->img_buffer += n;\r\n        return 1;\r\n    }\r\n    else\r\n        return 0;\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\r\n// nothing\r\n#else\r\nstatic int stbi__get16be(stbi__context* s)\r\n{\r\n    int z = stbi__get8(s);\r\n    return (z << 8) + stbi__get8(s);\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\r\n// nothing\r\n#else\r\nstatic stbi__uint32 stbi__get32be(stbi__context* s)\r\n{\r\n    stbi__uint32 z = stbi__get16be(s);\r\n    return (z << 16) + stbi__get16be(s);\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)\r\n// nothing\r\n#else\r\nstatic int stbi__get16le(stbi__context* s)\r\n{\r\n    int z = stbi__get8(s);\r\n    return z + (stbi__get8(s) << 8);\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic stbi__uint32 stbi__get32le(stbi__context* s)\r\n{\r\n    stbi__uint32 z = stbi__get16le(s);\r\n    z += (stbi__uint32)stbi__get16le(s) << 16;\r\n    return z;\r\n}\r\n#endif\r\n\r\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\r\n\r\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\r\n// nothing\r\n#else\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  generic converter from built-in img_n to req_comp\r\n//    individual types do this automatically as much as possible (e.g. jpeg\r\n//    does all cases internally since it needs to colorspace convert anyway,\r\n//    and it never has alpha, so very few cases ). png can automatically\r\n//    interleave an alpha=255 channel, but falls back to this for other cases\r\n//\r\n//  assume data buffer is malloced, so malloc a new one and free that one\r\n//  only failure mode is malloc failing\r\n\r\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\r\n{\r\n    return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\r\n// nothing\r\n#else\r\nstatic unsigned char* stbi__convert_format(unsigned char* data, int img_n, int req_comp, unsigned int x, unsigned int y)\r\n{\r\n    int i, j;\r\n    unsigned char* good;\r\n\r\n    if (req_comp == img_n) return data;\r\n    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\r\n\r\n    good = (unsigned char*)stbi__malloc_mad3(req_comp, x, y, 0);\r\n    if (good == NULL) {\r\n        STBI_FREE(data);\r\n        return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    }\r\n\r\n    for (j = 0; j < (int)y; ++j) {\r\n        unsigned char* src = data + j * x * img_n;\r\n        unsigned char* dest = good + j * x * req_comp;\r\n\r\n#define STBI__COMBO(a,b)  ((a)*8+(b))\r\n#define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\r\n        // convert source image with img_n components to one with req_comp components;\r\n        // avoid switch per pixel, so use switch per scanline and massive macros\r\n        switch (STBI__COMBO(img_n, req_comp)) {\r\n            STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 255; } break;\r\n            STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;\r\n            STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 255; } break;\r\n            STBI__CASE(2, 1) { dest[0] = src[0]; } break;\r\n            STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;\r\n            STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;\r\n            STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 255; } break;\r\n            STBI__CASE(3, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;\r\n            STBI__CASE(3, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = 255; } break;\r\n            STBI__CASE(4, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;\r\n            STBI__CASE(4, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = src[3]; } break;\r\n            STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;\r\n        default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\r\n        }\r\n#undef STBI__CASE\r\n    }\r\n\r\n    STBI_FREE(data);\r\n    return good;\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\r\n// nothing\r\n#else\r\nstatic stbi__uint16 stbi__compute_y_16(int r, int g, int b)\r\n{\r\n    return (stbi__uint16)(((r * 77) + (g * 150) + (29 * b)) >> 8);\r\n}\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\r\n// nothing\r\n#else\r\nstatic stbi__uint16* stbi__convert_format16(stbi__uint16* data, int img_n, int req_comp, unsigned int x, unsigned int y)\r\n{\r\n    int i, j;\r\n    stbi__uint16* good;\r\n\r\n    if (req_comp == img_n) return data;\r\n    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\r\n\r\n    good = (stbi__uint16*)stbi__malloc(req_comp * x * y * 2);\r\n    if (good == NULL) {\r\n        STBI_FREE(data);\r\n        return (stbi__uint16*)stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    }\r\n\r\n    for (j = 0; j < (int)y; ++j) {\r\n        stbi__uint16* src = data + j * x * img_n;\r\n        stbi__uint16* dest = good + j * x * req_comp;\r\n\r\n#define STBI__COMBO(a,b)  ((a)*8+(b))\r\n#define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\r\n        // convert source image with img_n components to one with req_comp components;\r\n        // avoid switch per pixel, so use switch per scanline and massive macros\r\n        switch (STBI__COMBO(img_n, req_comp)) {\r\n            STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 0xffff; } break;\r\n            STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;\r\n            STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 0xffff; } break;\r\n            STBI__CASE(2, 1) { dest[0] = src[0]; } break;\r\n            STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;\r\n            STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;\r\n            STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 0xffff; } break;\r\n            STBI__CASE(3, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;\r\n            STBI__CASE(3, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = 0xffff; } break;\r\n            STBI__CASE(4, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;\r\n            STBI__CASE(4, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = src[3]; } break;\r\n            STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;\r\n        default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*)stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\r\n        }\r\n#undef STBI__CASE\r\n    }\r\n\r\n    STBI_FREE(data);\r\n    return good;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float* stbi__ldr_to_hdr(stbi_uc* data, int x, int y, int comp)\r\n{\r\n    int i, k, n;\r\n    float* output;\r\n    if (!data) return NULL;\r\n    output = (float*)stbi__malloc_mad4(x, y, comp, sizeof(float), 0);\r\n    if (output == NULL) { STBI_FREE(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\r\n    // compute number of non-alpha components\r\n    if (comp & 1) n = comp; else n = comp - 1;\r\n    for (i = 0; i < x * y; ++i) {\r\n        for (k = 0; k < n; ++k) {\r\n            output[i * comp + k] = (float)(pow(data[i * comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\r\n        }\r\n    }\r\n    if (n < comp) {\r\n        for (i = 0; i < x * y; ++i) {\r\n            output[i * comp + n] = data[i * comp + n] / 255.0f;\r\n        }\r\n    }\r\n    STBI_FREE(data);\r\n    return output;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n#define stbi__float2int(x)   ((int) (x))\r\nstatic stbi_uc* stbi__hdr_to_ldr(float* data, int x, int y, int comp)\r\n{\r\n    int i, k, n;\r\n    stbi_uc* output;\r\n    if (!data) return NULL;\r\n    output = (stbi_uc*)stbi__malloc_mad3(x, y, comp, 0);\r\n    if (output == NULL) { STBI_FREE(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n    // compute number of non-alpha components\r\n    if (comp & 1) n = comp; else n = comp - 1;\r\n    for (i = 0; i < x * y; ++i) {\r\n        for (k = 0; k < n; ++k) {\r\n            float z = (float)pow(data[i * comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\r\n            if (z < 0) z = 0;\r\n            if (z > 255) z = 255;\r\n            output[i * comp + k] = (stbi_uc)stbi__float2int(z);\r\n        }\r\n        if (k < comp) {\r\n            float z = data[i * comp + k] * 255 + 0.5f;\r\n            if (z < 0) z = 0;\r\n            if (z > 255) z = 255;\r\n            output[i * comp + k] = (stbi_uc)stbi__float2int(z);\r\n        }\r\n    }\r\n    STBI_FREE(data);\r\n    return output;\r\n}\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  \"baseline\" JPEG/JFIF decoder\r\n//\r\n//    simple implementation\r\n//      - doesn't support delayed output of y-dimension\r\n//      - simple interface (only one output format: 8-bit interleaved RGB)\r\n//      - doesn't try to recover corrupt jpegs\r\n//      - doesn't allow partial loading, loading multiple at once\r\n//      - still fast on x86 (copying globals into locals doesn't help x86)\r\n//      - allocates lots of intermediate memory (full size of all components)\r\n//        - non-interleaved case requires this anyway\r\n//        - allows good upsampling (see next)\r\n//    high-quality\r\n//      - upsampled channels are bilinearly interpolated, even across blocks\r\n//      - quality integer IDCT derived from IJG's 'slow'\r\n//    performance\r\n//      - fast huffman; reasonable integer IDCT\r\n//      - some SIMD kernels for common paths on targets with SSE2/NEON\r\n//      - uses a lot of intermediate memory, could cache poorly\r\n\r\n#ifndef STBI_NO_JPEG\r\n\r\n// huffman decoding acceleration\r\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\r\n\r\ntypedef struct\r\n{\r\n    stbi_uc  fast[1 << FAST_BITS];\r\n    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\r\n    stbi__uint16 code[256];\r\n    stbi_uc  values[256];\r\n    stbi_uc  size[257];\r\n    unsigned int maxcode[18];\r\n    int    delta[17];   // old 'firstsymbol' - old 'firstcode'\r\n} stbi__huffman;\r\n\r\ntypedef struct\r\n{\r\n    stbi__context* s;\r\n    stbi__huffman huff_dc[4];\r\n    stbi__huffman huff_ac[4];\r\n    stbi__uint16 dequant[4][64];\r\n    stbi__int16 fast_ac[4][1 << FAST_BITS];\r\n\r\n    // sizes for components, interleaved MCUs\r\n    int img_h_max, img_v_max;\r\n    int img_mcu_x, img_mcu_y;\r\n    int img_mcu_w, img_mcu_h;\r\n\r\n    // definition of jpeg image component\r\n    struct\r\n    {\r\n        int id;\r\n        int h, v;\r\n        int tq;\r\n        int hd, ha;\r\n        int dc_pred;\r\n\r\n        int x, y, w2, h2;\r\n        stbi_uc* data;\r\n        void* raw_data, * raw_coeff;\r\n        stbi_uc* linebuf;\r\n        short* coeff;   // progressive only\r\n        int      coeff_w, coeff_h; // number of 8x8 coefficient blocks\r\n    } img_comp[4];\r\n\r\n    stbi__uint32   code_buffer; // jpeg entropy-coded buffer\r\n    int            code_bits;   // number of valid bits\r\n    unsigned char  marker;      // marker seen while filling entropy buffer\r\n    int            nomore;      // flag if we saw a marker so must stop\r\n\r\n    int            progressive;\r\n    int            spec_start;\r\n    int            spec_end;\r\n    int            succ_high;\r\n    int            succ_low;\r\n    int            eob_run;\r\n    int            jfif;\r\n    int            app14_color_transform; // Adobe APP14 tag\r\n    int            rgb;\r\n\r\n    int scan_n, order[4];\r\n    int restart_interval, todo;\r\n\r\n    // kernels\r\n    void (*idct_block_kernel)(stbi_uc* out, int out_stride, short data[64]);\r\n    void (*YCbCr_to_RGB_kernel)(stbi_uc* out, const stbi_uc* y, const stbi_uc* pcb, const stbi_uc* pcr, int count, int step);\r\n    stbi_uc* (*resample_row_hv_2_kernel)(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs);\r\n} stbi__jpeg;\r\n\r\nstatic int stbi__build_huffman(stbi__huffman* h, int* count)\r\n{\r\n    int i, j, k = 0;\r\n    unsigned int code;\r\n    // build size list for each symbol (from JPEG spec)\r\n    for (i = 0; i < 16; ++i) {\r\n        for (j = 0; j < count[i]; ++j) {\r\n            h->size[k++] = (stbi_uc)(i + 1);\r\n            if (k >= 257) return stbi__err(\"bad size list\", \"Corrupt JPEG\");\r\n        }\r\n    }\r\n    h->size[k] = 0;\r\n\r\n    // compute actual symbols (from jpeg spec)\r\n    code = 0;\r\n    k = 0;\r\n    for (j = 1; j <= 16; ++j) {\r\n        // compute delta to add to code to compute symbol id\r\n        h->delta[j] = k - code;\r\n        if (h->size[k] == j) {\r\n            while (h->size[k] == j)\r\n                h->code[k++] = (stbi__uint16)(code++);\r\n            if (code - 1 >= (1u << j)) return stbi__err(\"bad code lengths\", \"Corrupt JPEG\");\r\n        }\r\n        // compute largest code + 1 for this size, preshifted as needed later\r\n        h->maxcode[j] = code << (16 - j);\r\n        code <<= 1;\r\n    }\r\n    h->maxcode[j] = 0xffffffff;\r\n\r\n    // build non-spec acceleration table; 255 is flag for not-accelerated\r\n    memset(h->fast, 255, 1 << FAST_BITS);\r\n    for (i = 0; i < k; ++i) {\r\n        int s = h->size[i];\r\n        if (s <= FAST_BITS) {\r\n            int c = h->code[i] << (FAST_BITS - s);\r\n            int m = 1 << (FAST_BITS - s);\r\n            for (j = 0; j < m; ++j) {\r\n                h->fast[c + j] = (stbi_uc)i;\r\n            }\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\n// build a table that decodes both magnitude and value of small ACs in\r\n// one go.\r\nstatic void stbi__build_fast_ac(stbi__int16* fast_ac, stbi__huffman* h)\r\n{\r\n    int i;\r\n    for (i = 0; i < (1 << FAST_BITS); ++i) {\r\n        stbi_uc fast = h->fast[i];\r\n        fast_ac[i] = 0;\r\n        if (fast < 255) {\r\n            int rs = h->values[fast];\r\n            int run = (rs >> 4) & 15;\r\n            int magbits = rs & 15;\r\n            int len = h->size[fast];\r\n\r\n            if (magbits && len + magbits <= FAST_BITS) {\r\n                // magnitude code followed by receive_extend code\r\n                int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);\r\n                int m = 1 << (magbits - 1);\r\n                if (k < m) k += (~0U << magbits) + 1;\r\n                // if the result is small enough, we can fit it in fast_ac table\r\n                if (k >= -128 && k <= 127)\r\n                    fast_ac[i] = (stbi__int16)((k * 256) + (run * 16) + (len + magbits));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg* j)\r\n{\r\n    do {\r\n        unsigned int b = j->nomore ? 0 : stbi__get8(j->s);\r\n        if (b == 0xff) {\r\n            int c = stbi__get8(j->s);\r\n            while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes\r\n            if (c != 0) {\r\n                j->marker = (unsigned char)c;\r\n                j->nomore = 1;\r\n                return;\r\n            }\r\n        }\r\n        j->code_buffer |= b << (24 - j->code_bits);\r\n        j->code_bits += 8;\r\n    } while (j->code_bits <= 24);\r\n}\r\n\r\n// (1 << n) - 1\r\nstatic const stbi__uint32 stbi__bmask[17] = { 0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535 };\r\n\r\n// decode a jpeg huffman value from the bitstream\r\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg* j, stbi__huffman* h)\r\n{\r\n    unsigned int temp;\r\n    int c, k;\r\n\r\n    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n\r\n    // look at the top FAST_BITS and determine what symbol ID it is,\r\n    // if the code is <= FAST_BITS\r\n    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);\r\n    k = h->fast[c];\r\n    if (k < 255) {\r\n        int s = h->size[k];\r\n        if (s > j->code_bits)\r\n            return -1;\r\n        j->code_buffer <<= s;\r\n        j->code_bits -= s;\r\n        return h->values[k];\r\n    }\r\n\r\n    // naive test is to shift the code_buffer down so k bits are\r\n    // valid, then test against maxcode. To speed this up, we've\r\n    // preshifted maxcode left so that it has (16-k) 0s at the\r\n    // end; in other words, regardless of the number of bits, it\r\n    // wants to be compared against something shifted to have 16;\r\n    // that way we don't need to shift inside the loop.\r\n    temp = j->code_buffer >> 16;\r\n    for (k = FAST_BITS + 1; ; ++k)\r\n        if (temp < h->maxcode[k])\r\n            break;\r\n    if (k == 17) {\r\n        // error! code not found\r\n        j->code_bits -= 16;\r\n        return -1;\r\n    }\r\n\r\n    if (k > j->code_bits)\r\n        return -1;\r\n\r\n    // convert the huffman code to the symbol id\r\n    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\r\n    if (c < 0 || c >= 256) // symbol id out of bounds!\r\n        return -1;\r\n    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\r\n\r\n    // convert the id to a symbol\r\n    j->code_bits -= k;\r\n    j->code_buffer <<= k;\r\n    return h->values[c];\r\n}\r\n\r\n// bias[n] = (-1<<n) + 1\r\nstatic const int stbi__jbias[16] = { 0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767 };\r\n\r\n// combined JPEG 'receive' and JPEG 'extend', since baseline\r\n// always extends everything it receives.\r\nstbi_inline static int stbi__extend_receive(stbi__jpeg* j, int n)\r\n{\r\n    unsigned int k;\r\n    int sgn;\r\n    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\r\n    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing\r\n\r\n    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)\r\n    k = stbi_lrot(j->code_buffer, n);\r\n    j->code_buffer = k & ~stbi__bmask[n];\r\n    k &= stbi__bmask[n];\r\n    j->code_bits -= n;\r\n    return k + (stbi__jbias[n] & (sgn - 1));\r\n}\r\n\r\n// get some unsigned bits\r\nstbi_inline static int stbi__jpeg_get_bits(stbi__jpeg* j, int n)\r\n{\r\n    unsigned int k;\r\n    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\r\n    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing\r\n    k = stbi_lrot(j->code_buffer, n);\r\n    j->code_buffer = k & ~stbi__bmask[n];\r\n    k &= stbi__bmask[n];\r\n    j->code_bits -= n;\r\n    return k;\r\n}\r\n\r\nstbi_inline static int stbi__jpeg_get_bit(stbi__jpeg* j)\r\n{\r\n    unsigned int k;\r\n    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);\r\n    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing\r\n    k = j->code_buffer;\r\n    j->code_buffer <<= 1;\r\n    --j->code_bits;\r\n    return k & 0x80000000;\r\n}\r\n\r\n// given a value that's at position X in the zigzag stream,\r\n// where does it appear in the 8x8 matrix coded as row-major?\r\nstatic const stbi_uc stbi__jpeg_dezigzag[64 + 15] =\r\n{\r\n    0,  1,  8, 16,  9,  2,  3, 10,\r\n   17, 24, 32, 25, 18, 11,  4,  5,\r\n   12, 19, 26, 33, 40, 48, 41, 34,\r\n   27, 20, 13,  6,  7, 14, 21, 28,\r\n   35, 42, 49, 56, 57, 50, 43, 36,\r\n   29, 22, 15, 23, 30, 37, 44, 51,\r\n   58, 59, 52, 45, 38, 31, 39, 46,\r\n   53, 60, 61, 54, 47, 55, 62, 63,\r\n   // let corrupt input sample past end\r\n   63, 63, 63, 63, 63, 63, 63, 63,\r\n   63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\n// decode one 64-entry block--\r\nstatic int stbi__jpeg_decode_block(stbi__jpeg* j, short data[64], stbi__huffman* hdc, stbi__huffman* hac, stbi__int16* fac, int b, stbi__uint16* dequant)\r\n{\r\n    int diff, dc, k;\r\n    int t;\r\n\r\n    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n    t = stbi__jpeg_huff_decode(j, hdc);\r\n    if (t < 0 || t > 15) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n\r\n    // 0 all the ac values now so we can do it 32-bits at a time\r\n    memset(data, 0, 64 * sizeof(data[0]));\r\n\r\n    diff = t ? stbi__extend_receive(j, t) : 0;\r\n    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(\"bad delta\", \"Corrupt JPEG\");\r\n    dc = j->img_comp[b].dc_pred + diff;\r\n    j->img_comp[b].dc_pred = dc;\r\n    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n    data[0] = (short)(dc * dequant[0]);\r\n\r\n    // decode AC components, see JPEG spec\r\n    k = 1;\r\n    do {\r\n        unsigned int zig;\r\n        int c, r, s;\r\n        if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n        c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);\r\n        r = fac[c];\r\n        if (r) { // fast-AC path\r\n            k += (r >> 4) & 15; // run\r\n            s = r & 15; // combined length\r\n            if (s > j->code_bits) return stbi__err(\"bad huffman code\", \"Combined length longer than code bits available\");\r\n            j->code_buffer <<= s;\r\n            j->code_bits -= s;\r\n            // decode into unzigzag'd location\r\n            zig = stbi__jpeg_dezigzag[k++];\r\n            data[zig] = (short)((r >> 8) * dequant[zig]);\r\n        }\r\n        else {\r\n            int rs = stbi__jpeg_huff_decode(j, hac);\r\n            if (rs < 0) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n            s = rs & 15;\r\n            r = rs >> 4;\r\n            if (s == 0) {\r\n                if (rs != 0xf0) break; // end block\r\n                k += 16;\r\n            }\r\n            else {\r\n                k += r;\r\n                // decode into unzigzag'd location\r\n                zig = stbi__jpeg_dezigzag[k++];\r\n                data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);\r\n            }\r\n        }\r\n    } while (k < 64);\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__jpeg_decode_block_prog_dc(stbi__jpeg* j, short data[64], stbi__huffman* hdc, int b)\r\n{\r\n    int diff, dc;\r\n    int t;\r\n    if (j->spec_end != 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n\r\n    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n\r\n    if (j->succ_high == 0) {\r\n        // first scan for DC coefficient, must be first\r\n        memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now\r\n        t = stbi__jpeg_huff_decode(j, hdc);\r\n        if (t < 0 || t > 15) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n        diff = t ? stbi__extend_receive(j, t) : 0;\r\n\r\n        if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(\"bad delta\", \"Corrupt JPEG\");\r\n        dc = j->img_comp[b].dc_pred + diff;\r\n        j->img_comp[b].dc_pred = dc;\r\n        if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n        data[0] = (short)(dc * (1 << j->succ_low));\r\n    }\r\n    else {\r\n        // refinement scan for DC coefficient\r\n        if (stbi__jpeg_get_bit(j))\r\n            data[0] += (short)(1 << j->succ_low);\r\n    }\r\n    return 1;\r\n}\r\n\r\n// @OPTIMIZE: store non-zigzagged during the decode passes,\r\n// and only de-zigzag when dequantizing\r\nstatic int stbi__jpeg_decode_block_prog_ac(stbi__jpeg* j, short data[64], stbi__huffman* hac, stbi__int16* fac)\r\n{\r\n    int k;\r\n    if (j->spec_start == 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n\r\n    if (j->succ_high == 0) {\r\n        int shift = j->succ_low;\r\n\r\n        if (j->eob_run) {\r\n            --j->eob_run;\r\n            return 1;\r\n        }\r\n\r\n        k = j->spec_start;\r\n        do {\r\n            unsigned int zig;\r\n            int c, r, s;\r\n            if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n            c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);\r\n            r = fac[c];\r\n            if (r) { // fast-AC path\r\n                k += (r >> 4) & 15; // run\r\n                s = r & 15; // combined length\r\n                if (s > j->code_bits) return stbi__err(\"bad huffman code\", \"Combined length longer than code bits available\");\r\n                j->code_buffer <<= s;\r\n                j->code_bits -= s;\r\n                zig = stbi__jpeg_dezigzag[k++];\r\n                data[zig] = (short)((r >> 8) * (1 << shift));\r\n            }\r\n            else {\r\n                int rs = stbi__jpeg_huff_decode(j, hac);\r\n                if (rs < 0) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n                s = rs & 15;\r\n                r = rs >> 4;\r\n                if (s == 0) {\r\n                    if (r < 15) {\r\n                        j->eob_run = (1 << r);\r\n                        if (r)\r\n                            j->eob_run += stbi__jpeg_get_bits(j, r);\r\n                        --j->eob_run;\r\n                        break;\r\n                    }\r\n                    k += 16;\r\n                }\r\n                else {\r\n                    k += r;\r\n                    zig = stbi__jpeg_dezigzag[k++];\r\n                    data[zig] = (short)(stbi__extend_receive(j, s) * (1 << shift));\r\n                }\r\n            }\r\n        } while (k <= j->spec_end);\r\n    }\r\n    else {\r\n        // refinement scan for these AC coefficients\r\n\r\n        short bit = (short)(1 << j->succ_low);\r\n\r\n        if (j->eob_run) {\r\n            --j->eob_run;\r\n            for (k = j->spec_start; k <= j->spec_end; ++k) {\r\n                short* p = &data[stbi__jpeg_dezigzag[k]];\r\n                if (*p != 0)\r\n                    if (stbi__jpeg_get_bit(j))\r\n                        if ((*p & bit) == 0) {\r\n                            if (*p > 0)\r\n                                *p += bit;\r\n                            else\r\n                                *p -= bit;\r\n                        }\r\n            }\r\n        }\r\n        else {\r\n            k = j->spec_start;\r\n            do {\r\n                int r, s;\r\n                int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh\r\n                if (rs < 0) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n                s = rs & 15;\r\n                r = rs >> 4;\r\n                if (s == 0) {\r\n                    if (r < 15) {\r\n                        j->eob_run = (1 << r) - 1;\r\n                        if (r)\r\n                            j->eob_run += stbi__jpeg_get_bits(j, r);\r\n                        r = 64; // force end of block\r\n                    }\r\n                    else {\r\n                        // r=15 s=0 should write 16 0s, so we just do\r\n                        // a run of 15 0s and then write s (which is 0),\r\n                        // so we don't have to do anything special here\r\n                    }\r\n                }\r\n                else {\r\n                    if (s != 1) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n                    // sign bit\r\n                    if (stbi__jpeg_get_bit(j))\r\n                        s = bit;\r\n                    else\r\n                        s = -bit;\r\n                }\r\n\r\n                // advance by r\r\n                while (k <= j->spec_end) {\r\n                    short* p = &data[stbi__jpeg_dezigzag[k++]];\r\n                    if (*p != 0) {\r\n                        if (stbi__jpeg_get_bit(j))\r\n                            if ((*p & bit) == 0) {\r\n                                if (*p > 0)\r\n                                    *p += bit;\r\n                                else\r\n                                    *p -= bit;\r\n                            }\r\n                    }\r\n                    else {\r\n                        if (r == 0) {\r\n                            *p = (short)s;\r\n                            break;\r\n                        }\r\n                        --r;\r\n                    }\r\n                }\r\n            } while (k <= j->spec_end);\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\n// take a -128..127 value and stbi__clamp it and convert to 0..255\r\nstbi_inline static stbi_uc stbi__clamp(int x)\r\n{\r\n    // trick to use a single test to catch both cases\r\n    if ((unsigned int)x > 255) {\r\n        if (x < 0) return 0;\r\n        if (x > 255) return 255;\r\n    }\r\n    return (stbi_uc)x;\r\n}\r\n\r\n#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))\r\n#define stbi__fsh(x)  ((x) * 4096)\r\n\r\n// derived from jidctint -- DCT_ISLOW\r\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \\\r\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\r\n   p2 = s2;                                    \\\r\n   p3 = s6;                                    \\\r\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \\\r\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \\\r\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \\\r\n   p2 = s0;                                    \\\r\n   p3 = s4;                                    \\\r\n   t0 = stbi__fsh(p2+p3);                      \\\r\n   t1 = stbi__fsh(p2-p3);                      \\\r\n   x0 = t0+t3;                                 \\\r\n   x3 = t0-t3;                                 \\\r\n   x1 = t1+t2;                                 \\\r\n   x2 = t1-t2;                                 \\\r\n   t0 = s7;                                    \\\r\n   t1 = s5;                                    \\\r\n   t2 = s3;                                    \\\r\n   t3 = s1;                                    \\\r\n   p3 = t0+t2;                                 \\\r\n   p4 = t1+t3;                                 \\\r\n   p1 = t0+t3;                                 \\\r\n   p2 = t1+t2;                                 \\\r\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \\\r\n   t0 = t0*stbi__f2f( 0.298631336f);           \\\r\n   t1 = t1*stbi__f2f( 2.053119869f);           \\\r\n   t2 = t2*stbi__f2f( 3.072711026f);           \\\r\n   t3 = t3*stbi__f2f( 1.501321110f);           \\\r\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \\\r\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \\\r\n   p3 = p3*stbi__f2f(-1.961570560f);           \\\r\n   p4 = p4*stbi__f2f(-0.390180644f);           \\\r\n   t3 += p1+p4;                                \\\r\n   t2 += p2+p3;                                \\\r\n   t1 += p2+p4;                                \\\r\n   t0 += p1+p3;\r\n\r\nstatic void stbi__idct_block(stbi_uc* out, int out_stride, short data[64])\r\n{\r\n    int i, val[64], * v = val;\r\n    stbi_uc* o;\r\n    short* d = data;\r\n\r\n    // columns\r\n    for (i = 0; i < 8; ++i, ++d, ++v) {\r\n        // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\r\n        if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0\r\n            && d[40] == 0 && d[48] == 0 && d[56] == 0) {\r\n            //    no shortcut                 0     seconds\r\n            //    (1|2|3|4|5|6|7)==0          0     seconds\r\n            //    all separate               -0.047 seconds\r\n            //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\r\n            int dcterm = d[0] * 4;\r\n            v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\r\n        }\r\n        else {\r\n            STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])\r\n                // constants scaled things up by 1<<12; let's bring them back\r\n                // down, but keep 2 extra bits of precision\r\n                x0 += 512; x1 += 512; x2 += 512; x3 += 512;\r\n            v[0] = (x0 + t3) >> 10;\r\n            v[56] = (x0 - t3) >> 10;\r\n            v[8] = (x1 + t2) >> 10;\r\n            v[48] = (x1 - t2) >> 10;\r\n            v[16] = (x2 + t1) >> 10;\r\n            v[40] = (x2 - t1) >> 10;\r\n            v[24] = (x3 + t0) >> 10;\r\n            v[32] = (x3 - t0) >> 10;\r\n        }\r\n    }\r\n\r\n    for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {\r\n        // no fast case since the first 1D IDCT spread components out\r\n        STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])\r\n            // constants scaled things up by 1<<12, plus we had 1<<2 from first\r\n            // loop, plus horizontal and vertical each scale by sqrt(8) so together\r\n            // we've got an extra 1<<3, so 1<<17 total we need to remove.\r\n            // so we want to round that, which means adding 0.5 * 1<<17,\r\n            // aka 65536. Also, we'll end up with -128 to 127 that we want\r\n            // to encode as 0..255 by adding 128, so we'll add that before the shift\r\n            x0 += 65536 + (128 << 17);\r\n        x1 += 65536 + (128 << 17);\r\n        x2 += 65536 + (128 << 17);\r\n        x3 += 65536 + (128 << 17);\r\n        // tried computing the shifts into temps, or'ing the temps to see\r\n        // if any were out of range, but that was slower\r\n        o[0] = stbi__clamp((x0 + t3) >> 17);\r\n        o[7] = stbi__clamp((x0 - t3) >> 17);\r\n        o[1] = stbi__clamp((x1 + t2) >> 17);\r\n        o[6] = stbi__clamp((x1 - t2) >> 17);\r\n        o[2] = stbi__clamp((x2 + t1) >> 17);\r\n        o[5] = stbi__clamp((x2 - t1) >> 17);\r\n        o[3] = stbi__clamp((x3 + t0) >> 17);\r\n        o[4] = stbi__clamp((x3 - t0) >> 17);\r\n    }\r\n}\r\n\r\n#ifdef STBI_SSE2\r\n// sse2 integer IDCT. not the fastest possible implementation but it\r\n// produces bit-identical results to the generic C version so it's\r\n// fully \"transparent\".\r\nstatic void stbi__idct_simd(stbi_uc* out, int out_stride, short data[64])\r\n{\r\n    // This is constructed to match our regular (generic) integer IDCT exactly.\r\n    __m128i row0, row1, row2, row3, row4, row5, row6, row7;\r\n    __m128i tmp;\r\n\r\n    // dot product constant: even elems=x, odd elems=y\r\n#define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))\r\n\r\n// out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)\r\n// out(1) = c1[even]*x + c1[odd]*y\r\n#define dct_rot(out0,out1, x,y,c0,c1) \\\r\n      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \\\r\n      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \\\r\n      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \\\r\n      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \\\r\n      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \\\r\n      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)\r\n\r\n   // out = in << 12  (in 16-bit, out 32-bit)\r\n#define dct_widen(out, in) \\\r\n      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \\\r\n      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)\r\n\r\n   // wide add\r\n#define dct_wadd(out, a, b) \\\r\n      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \\\r\n      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)\r\n\r\n   // wide sub\r\n#define dct_wsub(out, a, b) \\\r\n      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \\\r\n      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)\r\n\r\n   // butterfly a/b, add bias, then shift by \"s\" and pack\r\n#define dct_bfly32o(out0, out1, a,b,bias,s) \\\r\n      { \\\r\n         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \\\r\n         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \\\r\n         dct_wadd(sum, abiased, b); \\\r\n         dct_wsub(dif, abiased, b); \\\r\n         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \\\r\n         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \\\r\n      }\r\n\r\n   // 8-bit interleave step (for transposes)\r\n#define dct_interleave8(a, b) \\\r\n      tmp = a; \\\r\n      a = _mm_unpacklo_epi8(a, b); \\\r\n      b = _mm_unpackhi_epi8(tmp, b)\r\n\r\n   // 16-bit interleave step (for transposes)\r\n#define dct_interleave16(a, b) \\\r\n      tmp = a; \\\r\n      a = _mm_unpacklo_epi16(a, b); \\\r\n      b = _mm_unpackhi_epi16(tmp, b)\r\n\r\n#define dct_pass(bias,shift) \\\r\n      { \\\r\n         /* even part */ \\\r\n         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \\\r\n         __m128i sum04 = _mm_add_epi16(row0, row4); \\\r\n         __m128i dif04 = _mm_sub_epi16(row0, row4); \\\r\n         dct_widen(t0e, sum04); \\\r\n         dct_widen(t1e, dif04); \\\r\n         dct_wadd(x0, t0e, t3e); \\\r\n         dct_wsub(x3, t0e, t3e); \\\r\n         dct_wadd(x1, t1e, t2e); \\\r\n         dct_wsub(x2, t1e, t2e); \\\r\n         /* odd part */ \\\r\n         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \\\r\n         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \\\r\n         __m128i sum17 = _mm_add_epi16(row1, row7); \\\r\n         __m128i sum35 = _mm_add_epi16(row3, row5); \\\r\n         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \\\r\n         dct_wadd(x4, y0o, y4o); \\\r\n         dct_wadd(x5, y1o, y5o); \\\r\n         dct_wadd(x6, y2o, y5o); \\\r\n         dct_wadd(x7, y3o, y4o); \\\r\n         dct_bfly32o(row0,row7, x0,x7,bias,shift); \\\r\n         dct_bfly32o(row1,row6, x1,x6,bias,shift); \\\r\n         dct_bfly32o(row2,row5, x2,x5,bias,shift); \\\r\n         dct_bfly32o(row3,row4, x3,x4,bias,shift); \\\r\n      }\r\n\r\n    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));\r\n    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f(0.765366865f), stbi__f2f(0.5411961f));\r\n    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));\r\n    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));\r\n    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f(0.298631336f), stbi__f2f(-1.961570560f));\r\n    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f(3.072711026f));\r\n    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f(2.053119869f), stbi__f2f(-0.390180644f));\r\n    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f(1.501321110f));\r\n\r\n    // rounding biases in column/row passes, see stbi__idct_block for explanation.\r\n    __m128i bias_0 = _mm_set1_epi32(512);\r\n    __m128i bias_1 = _mm_set1_epi32(65536 + (128 << 17));\r\n\r\n    // load\r\n    row0 = _mm_load_si128((const __m128i*) (data + 0 * 8));\r\n    row1 = _mm_load_si128((const __m128i*) (data + 1 * 8));\r\n    row2 = _mm_load_si128((const __m128i*) (data + 2 * 8));\r\n    row3 = _mm_load_si128((const __m128i*) (data + 3 * 8));\r\n    row4 = _mm_load_si128((const __m128i*) (data + 4 * 8));\r\n    row5 = _mm_load_si128((const __m128i*) (data + 5 * 8));\r\n    row6 = _mm_load_si128((const __m128i*) (data + 6 * 8));\r\n    row7 = _mm_load_si128((const __m128i*) (data + 7 * 8));\r\n\r\n    // column pass\r\n    dct_pass(bias_0, 10);\r\n\r\n    {\r\n        // 16bit 8x8 transpose pass 1\r\n        dct_interleave16(row0, row4);\r\n        dct_interleave16(row1, row5);\r\n        dct_interleave16(row2, row6);\r\n        dct_interleave16(row3, row7);\r\n\r\n        // transpose pass 2\r\n        dct_interleave16(row0, row2);\r\n        dct_interleave16(row1, row3);\r\n        dct_interleave16(row4, row6);\r\n        dct_interleave16(row5, row7);\r\n\r\n        // transpose pass 3\r\n        dct_interleave16(row0, row1);\r\n        dct_interleave16(row2, row3);\r\n        dct_interleave16(row4, row5);\r\n        dct_interleave16(row6, row7);\r\n    }\r\n\r\n    // row pass\r\n    dct_pass(bias_1, 17);\r\n\r\n    {\r\n        // pack\r\n        __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7\r\n        __m128i p1 = _mm_packus_epi16(row2, row3);\r\n        __m128i p2 = _mm_packus_epi16(row4, row5);\r\n        __m128i p3 = _mm_packus_epi16(row6, row7);\r\n\r\n        // 8bit 8x8 transpose pass 1\r\n        dct_interleave8(p0, p2); // a0e0a1e1...\r\n        dct_interleave8(p1, p3); // c0g0c1g1...\r\n\r\n        // transpose pass 2\r\n        dct_interleave8(p0, p1); // a0c0e0g0...\r\n        dct_interleave8(p2, p3); // b0d0f0h0...\r\n\r\n        // transpose pass 3\r\n        dct_interleave8(p0, p2); // a0b0c0d0...\r\n        dct_interleave8(p1, p3); // a4b4c4d4...\r\n\r\n        // store\r\n        _mm_storel_epi64((__m128i*) out, p0); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, p2); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, p1); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, p3); out += out_stride;\r\n        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p3, 0x4e));\r\n    }\r\n\r\n#undef dct_const\r\n#undef dct_rot\r\n#undef dct_widen\r\n#undef dct_wadd\r\n#undef dct_wsub\r\n#undef dct_bfly32o\r\n#undef dct_interleave8\r\n#undef dct_interleave16\r\n#undef dct_pass\r\n}\r\n\r\n#endif // STBI_SSE2\r\n\r\n#ifdef STBI_NEON\r\n\r\n// NEON integer IDCT. should produce bit-identical\r\n// results to the generic C version.\r\nstatic void stbi__idct_simd(stbi_uc* out, int out_stride, short data[64])\r\n{\r\n    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;\r\n\r\n    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));\r\n    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));\r\n    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f(0.765366865f));\r\n    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f(1.175875602f));\r\n    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));\r\n    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));\r\n    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));\r\n    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));\r\n    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f(0.298631336f));\r\n    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f(2.053119869f));\r\n    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f(3.072711026f));\r\n    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f(1.501321110f));\r\n\r\n#define dct_long_mul(out, inq, coeff) \\\r\n   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \\\r\n   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)\r\n\r\n#define dct_long_mac(out, acc, inq, coeff) \\\r\n   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \\\r\n   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)\r\n\r\n#define dct_widen(out, inq) \\\r\n   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \\\r\n   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)\r\n\r\n    // wide add\r\n#define dct_wadd(out, a, b) \\\r\n   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \\\r\n   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)\r\n\r\n// wide sub\r\n#define dct_wsub(out, a, b) \\\r\n   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \\\r\n   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)\r\n\r\n// butterfly a/b, then shift using \"shiftop\" by \"s\" and pack\r\n#define dct_bfly32o(out0,out1, a,b,shiftop,s) \\\r\n   { \\\r\n      dct_wadd(sum, a, b); \\\r\n      dct_wsub(dif, a, b); \\\r\n      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \\\r\n      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \\\r\n   }\r\n\r\n#define dct_pass(shiftop, shift) \\\r\n   { \\\r\n      /* even part */ \\\r\n      int16x8_t sum26 = vaddq_s16(row2, row6); \\\r\n      dct_long_mul(p1e, sum26, rot0_0); \\\r\n      dct_long_mac(t2e, p1e, row6, rot0_1); \\\r\n      dct_long_mac(t3e, p1e, row2, rot0_2); \\\r\n      int16x8_t sum04 = vaddq_s16(row0, row4); \\\r\n      int16x8_t dif04 = vsubq_s16(row0, row4); \\\r\n      dct_widen(t0e, sum04); \\\r\n      dct_widen(t1e, dif04); \\\r\n      dct_wadd(x0, t0e, t3e); \\\r\n      dct_wsub(x3, t0e, t3e); \\\r\n      dct_wadd(x1, t1e, t2e); \\\r\n      dct_wsub(x2, t1e, t2e); \\\r\n      /* odd part */ \\\r\n      int16x8_t sum15 = vaddq_s16(row1, row5); \\\r\n      int16x8_t sum17 = vaddq_s16(row1, row7); \\\r\n      int16x8_t sum35 = vaddq_s16(row3, row5); \\\r\n      int16x8_t sum37 = vaddq_s16(row3, row7); \\\r\n      int16x8_t sumodd = vaddq_s16(sum17, sum35); \\\r\n      dct_long_mul(p5o, sumodd, rot1_0); \\\r\n      dct_long_mac(p1o, p5o, sum17, rot1_1); \\\r\n      dct_long_mac(p2o, p5o, sum35, rot1_2); \\\r\n      dct_long_mul(p3o, sum37, rot2_0); \\\r\n      dct_long_mul(p4o, sum15, rot2_1); \\\r\n      dct_wadd(sump13o, p1o, p3o); \\\r\n      dct_wadd(sump24o, p2o, p4o); \\\r\n      dct_wadd(sump23o, p2o, p3o); \\\r\n      dct_wadd(sump14o, p1o, p4o); \\\r\n      dct_long_mac(x4, sump13o, row7, rot3_0); \\\r\n      dct_long_mac(x5, sump24o, row5, rot3_1); \\\r\n      dct_long_mac(x6, sump23o, row3, rot3_2); \\\r\n      dct_long_mac(x7, sump14o, row1, rot3_3); \\\r\n      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \\\r\n      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \\\r\n      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \\\r\n      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \\\r\n   }\r\n\r\n   // load\r\n    row0 = vld1q_s16(data + 0 * 8);\r\n    row1 = vld1q_s16(data + 1 * 8);\r\n    row2 = vld1q_s16(data + 2 * 8);\r\n    row3 = vld1q_s16(data + 3 * 8);\r\n    row4 = vld1q_s16(data + 4 * 8);\r\n    row5 = vld1q_s16(data + 5 * 8);\r\n    row6 = vld1q_s16(data + 6 * 8);\r\n    row7 = vld1q_s16(data + 7 * 8);\r\n\r\n    // add DC bias\r\n    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));\r\n\r\n    // column pass\r\n    dct_pass(vrshrn_n_s32, 10);\r\n\r\n    // 16bit 8x8 transpose\r\n    {\r\n        // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.\r\n        // whether compilers actually get this is another story, sadly.\r\n#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }\r\n#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }\r\n#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }\r\n\r\n      // pass 1\r\n        dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6\r\n        dct_trn16(row2, row3);\r\n        dct_trn16(row4, row5);\r\n        dct_trn16(row6, row7);\r\n\r\n        // pass 2\r\n        dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4\r\n        dct_trn32(row1, row3);\r\n        dct_trn32(row4, row6);\r\n        dct_trn32(row5, row7);\r\n\r\n        // pass 3\r\n        dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0\r\n        dct_trn64(row1, row5);\r\n        dct_trn64(row2, row6);\r\n        dct_trn64(row3, row7);\r\n\r\n#undef dct_trn16\r\n#undef dct_trn32\r\n#undef dct_trn64\r\n    }\r\n\r\n    // row pass\r\n    // vrshrn_n_s32 only supports shifts up to 16, we need\r\n    // 17. so do a non-rounding shift of 16 first then follow\r\n    // up with a rounding shift by 1.\r\n    dct_pass(vshrn_n_s32, 16);\r\n\r\n    {\r\n        // pack and round\r\n        uint8x8_t p0 = vqrshrun_n_s16(row0, 1);\r\n        uint8x8_t p1 = vqrshrun_n_s16(row1, 1);\r\n        uint8x8_t p2 = vqrshrun_n_s16(row2, 1);\r\n        uint8x8_t p3 = vqrshrun_n_s16(row3, 1);\r\n        uint8x8_t p4 = vqrshrun_n_s16(row4, 1);\r\n        uint8x8_t p5 = vqrshrun_n_s16(row5, 1);\r\n        uint8x8_t p6 = vqrshrun_n_s16(row6, 1);\r\n        uint8x8_t p7 = vqrshrun_n_s16(row7, 1);\r\n\r\n        // again, these can translate into one instruction, but often don't.\r\n#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }\r\n#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }\r\n#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }\r\n\r\n      // sadly can't use interleaved stores here since we only write\r\n      // 8 bytes to each scan line!\r\n\r\n      // 8x8 8-bit transpose pass 1\r\n        dct_trn8_8(p0, p1);\r\n        dct_trn8_8(p2, p3);\r\n        dct_trn8_8(p4, p5);\r\n        dct_trn8_8(p6, p7);\r\n\r\n        // pass 2\r\n        dct_trn8_16(p0, p2);\r\n        dct_trn8_16(p1, p3);\r\n        dct_trn8_16(p4, p6);\r\n        dct_trn8_16(p5, p7);\r\n\r\n        // pass 3\r\n        dct_trn8_32(p0, p4);\r\n        dct_trn8_32(p1, p5);\r\n        dct_trn8_32(p2, p6);\r\n        dct_trn8_32(p3, p7);\r\n\r\n        // store\r\n        vst1_u8(out, p0); out += out_stride;\r\n        vst1_u8(out, p1); out += out_stride;\r\n        vst1_u8(out, p2); out += out_stride;\r\n        vst1_u8(out, p3); out += out_stride;\r\n        vst1_u8(out, p4); out += out_stride;\r\n        vst1_u8(out, p5); out += out_stride;\r\n        vst1_u8(out, p6); out += out_stride;\r\n        vst1_u8(out, p7);\r\n\r\n#undef dct_trn8_8\r\n#undef dct_trn8_16\r\n#undef dct_trn8_32\r\n    }\r\n\r\n#undef dct_long_mul\r\n#undef dct_long_mac\r\n#undef dct_widen\r\n#undef dct_wadd\r\n#undef dct_wsub\r\n#undef dct_bfly32o\r\n#undef dct_pass\r\n}\r\n\r\n#endif // STBI_NEON\r\n\r\n#define STBI__MARKER_none  0xff\r\n// if there's a pending marker from the entropy stream, return that\r\n// otherwise, fetch from the stream and get a marker. if there's no\r\n// marker, return 0xff, which is never a valid marker value\r\nstatic stbi_uc stbi__get_marker(stbi__jpeg* j)\r\n{\r\n    stbi_uc x;\r\n    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\r\n    x = stbi__get8(j->s);\r\n    if (x != 0xff) return STBI__MARKER_none;\r\n    while (x == 0xff)\r\n        x = stbi__get8(j->s); // consume repeated 0xff fill bytes\r\n    return x;\r\n}\r\n\r\n// in each scan, we'll have scan_n components, and the order\r\n// of the components is specified by order[]\r\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\r\n\r\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\r\n// the dc prediction\r\nstatic void stbi__jpeg_reset(stbi__jpeg* j)\r\n{\r\n    j->code_bits = 0;\r\n    j->code_buffer = 0;\r\n    j->nomore = 0;\r\n    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;\r\n    j->marker = STBI__MARKER_none;\r\n    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\r\n    j->eob_run = 0;\r\n    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\r\n    // since we don't even allow 1<<30 pixels\r\n}\r\n\r\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg* z)\r\n{\r\n    stbi__jpeg_reset(z);\r\n    if (!z->progressive) {\r\n        if (z->scan_n == 1) {\r\n            int i, j;\r\n            STBI_SIMD_ALIGN(short, data[64]);\r\n            int n = z->order[0];\r\n            // non-interleaved data, we just need to process one block at a time,\r\n            // in trivial scanline order\r\n            // number of blocks to do just depends on how many actual \"pixels\" this\r\n            // component has, independent of interleaved MCU blocking and such\r\n            int w = (z->img_comp[n].x + 7) >> 3;\r\n            int h = (z->img_comp[n].y + 7) >> 3;\r\n            for (j = 0; j < h; ++j) {\r\n                for (i = 0; i < w; ++i) {\r\n                    int ha = z->img_comp[n].ha;\r\n                    if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\r\n                    z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);\r\n                    // every data block is an MCU, so countdown the restart interval\r\n                    if (--z->todo <= 0) {\r\n                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                        // if it's NOT a restart, then just bail, so we get corrupt data\r\n                        // rather than no data\r\n                        if (!STBI__RESTART(z->marker)) return 1;\r\n                        stbi__jpeg_reset(z);\r\n                    }\r\n                }\r\n            }\r\n            return 1;\r\n        }\r\n        else { // interleaved\r\n            int i, j, k, x, y;\r\n            STBI_SIMD_ALIGN(short, data[64]);\r\n            for (j = 0; j < z->img_mcu_y; ++j) {\r\n                for (i = 0; i < z->img_mcu_x; ++i) {\r\n                    // scan an interleaved mcu... process scan_n components in order\r\n                    for (k = 0; k < z->scan_n; ++k) {\r\n                        int n = z->order[k];\r\n                        // scan out an mcu's worth of this component; that's just determined\r\n                        // by the basic H and V specified for the component\r\n                        for (y = 0; y < z->img_comp[n].v; ++y) {\r\n                            for (x = 0; x < z->img_comp[n].h; ++x) {\r\n                                int x2 = (i * z->img_comp[n].h + x) * 8;\r\n                                int y2 = (j * z->img_comp[n].v + y) * 8;\r\n                                int ha = z->img_comp[n].ha;\r\n                                if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\r\n                                z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * y2 + x2, z->img_comp[n].w2, data);\r\n                            }\r\n                        }\r\n                    }\r\n                    // after all interleaved components, that's an interleaved MCU,\r\n                    // so now count down the restart interval\r\n                    if (--z->todo <= 0) {\r\n                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                        if (!STBI__RESTART(z->marker)) return 1;\r\n                        stbi__jpeg_reset(z);\r\n                    }\r\n                }\r\n            }\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        if (z->scan_n == 1) {\r\n            int i, j;\r\n            int n = z->order[0];\r\n            // non-interleaved data, we just need to process one block at a time,\r\n            // in trivial scanline order\r\n            // number of blocks to do just depends on how many actual \"pixels\" this\r\n            // component has, independent of interleaved MCU blocking and such\r\n            int w = (z->img_comp[n].x + 7) >> 3;\r\n            int h = (z->img_comp[n].y + 7) >> 3;\r\n            for (j = 0; j < h; ++j) {\r\n                for (i = 0; i < w; ++i) {\r\n                    short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\r\n                    if (z->spec_start == 0) {\r\n                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\r\n                            return 0;\r\n                    }\r\n                    else {\r\n                        int ha = z->img_comp[n].ha;\r\n                        if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))\r\n                            return 0;\r\n                    }\r\n                    // every data block is an MCU, so countdown the restart interval\r\n                    if (--z->todo <= 0) {\r\n                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                        if (!STBI__RESTART(z->marker)) return 1;\r\n                        stbi__jpeg_reset(z);\r\n                    }\r\n                }\r\n            }\r\n            return 1;\r\n        }\r\n        else { // interleaved\r\n            int i, j, k, x, y;\r\n            for (j = 0; j < z->img_mcu_y; ++j) {\r\n                for (i = 0; i < z->img_mcu_x; ++i) {\r\n                    // scan an interleaved mcu... process scan_n components in order\r\n                    for (k = 0; k < z->scan_n; ++k) {\r\n                        int n = z->order[k];\r\n                        // scan out an mcu's worth of this component; that's just determined\r\n                        // by the basic H and V specified for the component\r\n                        for (y = 0; y < z->img_comp[n].v; ++y) {\r\n                            for (x = 0; x < z->img_comp[n].h; ++x) {\r\n                                int x2 = (i * z->img_comp[n].h + x);\r\n                                int y2 = (j * z->img_comp[n].v + y);\r\n                                short* data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);\r\n                                if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\r\n                                    return 0;\r\n                            }\r\n                        }\r\n                    }\r\n                    // after all interleaved components, that's an interleaved MCU,\r\n                    // so now count down the restart interval\r\n                    if (--z->todo <= 0) {\r\n                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                        if (!STBI__RESTART(z->marker)) return 1;\r\n                        stbi__jpeg_reset(z);\r\n                    }\r\n                }\r\n            }\r\n            return 1;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void stbi__jpeg_dequantize(short* data, stbi__uint16* dequant)\r\n{\r\n    int i;\r\n    for (i = 0; i < 64; ++i)\r\n        data[i] *= dequant[i];\r\n}\r\n\r\nstatic void stbi__jpeg_finish(stbi__jpeg* z)\r\n{\r\n    if (z->progressive) {\r\n        // dequantize and idct the data\r\n        int i, j, n;\r\n        for (n = 0; n < z->s->img_n; ++n) {\r\n            int w = (z->img_comp[n].x + 7) >> 3;\r\n            int h = (z->img_comp[n].y + 7) >> 3;\r\n            for (j = 0; j < h; ++j) {\r\n                for (i = 0; i < w; ++i) {\r\n                    short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\r\n                    stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);\r\n                    z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic int stbi__process_marker(stbi__jpeg* z, int m)\r\n{\r\n    int L;\r\n    switch (m) {\r\n    case STBI__MARKER_none: // no marker found\r\n        return stbi__err(\"expected marker\", \"Corrupt JPEG\");\r\n\r\n    case 0xDD: // DRI - specify restart interval\r\n        if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\", \"Corrupt JPEG\");\r\n        z->restart_interval = stbi__get16be(z->s);\r\n        return 1;\r\n\r\n    case 0xDB: // DQT - define quantization table\r\n        L = stbi__get16be(z->s) - 2;\r\n        while (L > 0) {\r\n            int q = stbi__get8(z->s);\r\n            int p = q >> 4, sixteen = (p != 0);\r\n            int t = q & 15, i;\r\n            if (p != 0 && p != 1) return stbi__err(\"bad DQT type\", \"Corrupt JPEG\");\r\n            if (t > 3) return stbi__err(\"bad DQT table\", \"Corrupt JPEG\");\r\n\r\n            for (i = 0; i < 64; ++i)\r\n                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));\r\n            L -= (sixteen ? 129 : 65);\r\n        }\r\n        return L == 0;\r\n\r\n    case 0xC4: // DHT - define huffman table\r\n        L = stbi__get16be(z->s) - 2;\r\n        while (L > 0) {\r\n            stbi_uc* v;\r\n            int sizes[16], i, n = 0;\r\n            int q = stbi__get8(z->s);\r\n            int tc = q >> 4;\r\n            int th = q & 15;\r\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\", \"Corrupt JPEG\");\r\n            for (i = 0; i < 16; ++i) {\r\n                sizes[i] = stbi__get8(z->s);\r\n                n += sizes[i];\r\n            }\r\n            if (n > 256) return stbi__err(\"bad DHT header\", \"Corrupt JPEG\"); // Loop over i < n would write past end of values!\r\n            L -= 17;\r\n            if (tc == 0) {\r\n                if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;\r\n                v = z->huff_dc[th].values;\r\n            }\r\n            else {\r\n                if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;\r\n                v = z->huff_ac[th].values;\r\n            }\r\n            for (i = 0; i < n; ++i)\r\n                v[i] = stbi__get8(z->s);\r\n            if (tc != 0)\r\n                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);\r\n            L -= n;\r\n        }\r\n        return L == 0;\r\n    }\r\n\r\n    // check for comment block or APP blocks\r\n    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\r\n        L = stbi__get16be(z->s);\r\n        if (L < 2) {\r\n            if (m == 0xFE)\r\n                return stbi__err(\"bad COM len\", \"Corrupt JPEG\");\r\n            else\r\n                return stbi__err(\"bad APP len\", \"Corrupt JPEG\");\r\n        }\r\n        L -= 2;\r\n\r\n        if (m == 0xE0 && L >= 5) { // JFIF APP0 segment\r\n            static const unsigned char tag[5] = { 'J','F','I','F','\\0' };\r\n            int ok = 1;\r\n            int i;\r\n            for (i = 0; i < 5; ++i)\r\n                if (stbi__get8(z->s) != tag[i])\r\n                    ok = 0;\r\n            L -= 5;\r\n            if (ok)\r\n                z->jfif = 1;\r\n        }\r\n        else if (m == 0xEE && L >= 12) { // Adobe APP14 segment\r\n            static const unsigned char tag[6] = { 'A','d','o','b','e','\\0' };\r\n            int ok = 1;\r\n            int i;\r\n            for (i = 0; i < 6; ++i)\r\n                if (stbi__get8(z->s) != tag[i])\r\n                    ok = 0;\r\n            L -= 6;\r\n            if (ok) {\r\n                stbi__get8(z->s); // version\r\n                stbi__get16be(z->s); // flags0\r\n                stbi__get16be(z->s); // flags1\r\n                z->app14_color_transform = stbi__get8(z->s); // color transform\r\n                L -= 6;\r\n            }\r\n        }\r\n\r\n        stbi__skip(z->s, L);\r\n        return 1;\r\n    }\r\n\r\n    return stbi__err(\"unknown marker\", \"Corrupt JPEG\");\r\n}\r\n\r\n// after we see SOS\r\nstatic int stbi__process_scan_header(stbi__jpeg* z)\r\n{\r\n    int i;\r\n    int Ls = stbi__get16be(z->s);\r\n    z->scan_n = stbi__get8(z->s);\r\n    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err(\"bad SOS component count\", \"Corrupt JPEG\");\r\n    if (Ls != 6 + 2 * z->scan_n) return stbi__err(\"bad SOS len\", \"Corrupt JPEG\");\r\n    for (i = 0; i < z->scan_n; ++i) {\r\n        int id = stbi__get8(z->s), which;\r\n        int q = stbi__get8(z->s);\r\n        for (which = 0; which < z->s->img_n; ++which)\r\n            if (z->img_comp[which].id == id)\r\n                break;\r\n        if (which == z->s->img_n) return 0; // no match\r\n        z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\", \"Corrupt JPEG\");\r\n        z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\", \"Corrupt JPEG\");\r\n        z->order[i] = which;\r\n    }\r\n\r\n    {\r\n        int aa;\r\n        z->spec_start = stbi__get8(z->s);\r\n        z->spec_end = stbi__get8(z->s); // should be 63, but might be 0\r\n        aa = stbi__get8(z->s);\r\n        z->succ_high = (aa >> 4);\r\n        z->succ_low = (aa & 15);\r\n        if (z->progressive) {\r\n            if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)\r\n                return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\r\n        }\r\n        else {\r\n            if (z->spec_start != 0) return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\r\n            if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\r\n            z->spec_end = 63;\r\n        }\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__free_jpeg_components(stbi__jpeg* z, int ncomp, int why)\r\n{\r\n    int i;\r\n    for (i = 0; i < ncomp; ++i) {\r\n        if (z->img_comp[i].raw_data) {\r\n            STBI_FREE(z->img_comp[i].raw_data);\r\n            z->img_comp[i].raw_data = NULL;\r\n            z->img_comp[i].data = NULL;\r\n        }\r\n        if (z->img_comp[i].raw_coeff) {\r\n            STBI_FREE(z->img_comp[i].raw_coeff);\r\n            z->img_comp[i].raw_coeff = 0;\r\n            z->img_comp[i].coeff = 0;\r\n        }\r\n        if (z->img_comp[i].linebuf) {\r\n            STBI_FREE(z->img_comp[i].linebuf);\r\n            z->img_comp[i].linebuf = NULL;\r\n        }\r\n    }\r\n    return why;\r\n}\r\n\r\nstatic int stbi__process_frame_header(stbi__jpeg* z, int scan)\r\n{\r\n    stbi__context* s = z->s;\r\n    int Lf, p, i, q, h_max = 1, v_max = 1, c;\r\n    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\", \"Corrupt JPEG\"); // JPEG\r\n    p = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\", \"JPEG format not supported: 8-bit only\"); // JPEG baseline\r\n    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\r\n    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\", \"Corrupt JPEG\"); // JPEG requires\r\n    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\", \"Very large image (corrupt?)\");\r\n    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\", \"Very large image (corrupt?)\");\r\n    c = stbi__get8(s);\r\n    if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\", \"Corrupt JPEG\");\r\n    s->img_n = c;\r\n    for (i = 0; i < c; ++i) {\r\n        z->img_comp[i].data = NULL;\r\n        z->img_comp[i].linebuf = NULL;\r\n    }\r\n\r\n    if (Lf != 8 + 3 * s->img_n) return stbi__err(\"bad SOF len\", \"Corrupt JPEG\");\r\n\r\n    z->rgb = 0;\r\n    for (i = 0; i < s->img_n; ++i) {\r\n        static const unsigned char rgb[3] = { 'R', 'G', 'B' };\r\n        z->img_comp[i].id = stbi__get8(s);\r\n        if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\r\n            ++z->rgb;\r\n        q = stbi__get8(s);\r\n        z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\", \"Corrupt JPEG\");\r\n        z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\", \"Corrupt JPEG\");\r\n        z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\", \"Corrupt JPEG\");\r\n    }\r\n\r\n    if (scan != STBI__SCAN_load) return 1;\r\n\r\n    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\r\n\r\n    for (i = 0; i < s->img_n; ++i) {\r\n        if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\r\n        if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\r\n    }\r\n\r\n    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios\r\n    // and I've never seen a non-corrupted JPEG file actually use them\r\n    for (i = 0; i < s->img_n; ++i) {\r\n        if (h_max % z->img_comp[i].h != 0) return stbi__err(\"bad H\", \"Corrupt JPEG\");\r\n        if (v_max % z->img_comp[i].v != 0) return stbi__err(\"bad V\", \"Corrupt JPEG\");\r\n    }\r\n\r\n    // compute interleaved mcu info\r\n    z->img_h_max = h_max;\r\n    z->img_v_max = v_max;\r\n    z->img_mcu_w = h_max * 8;\r\n    z->img_mcu_h = v_max * 8;\r\n    // these sizes can't be more than 17 bits\r\n    z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;\r\n    z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;\r\n\r\n    for (i = 0; i < s->img_n; ++i) {\r\n        // number of effective pixels (e.g. for non-interleaved MCU)\r\n        z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;\r\n        z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;\r\n        // to simplify generation, we'll allocate enough memory to decode\r\n        // the bogus oversized data from using interleaved MCUs and their\r\n        // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\r\n        // discard the extra data until colorspace conversion\r\n        //\r\n        // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\r\n        // so these muls can't overflow with 32-bit ints (which we require)\r\n        z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\r\n        z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\r\n        z->img_comp[i].coeff = 0;\r\n        z->img_comp[i].raw_coeff = 0;\r\n        z->img_comp[i].linebuf = NULL;\r\n        z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\r\n        if (z->img_comp[i].raw_data == NULL)\r\n            return stbi__free_jpeg_components(z, i + 1, stbi__err(\"outofmem\", \"Out of memory\"));\r\n        // align blocks for idct using mmx/sse\r\n        z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);\r\n        if (z->progressive) {\r\n            // w2, h2 are multiples of 8 (see above)\r\n            z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\r\n            z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\r\n            z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\r\n            if (z->img_comp[i].raw_coeff == NULL)\r\n                return stbi__free_jpeg_components(z, i + 1, stbi__err(\"outofmem\", \"Out of memory\"));\r\n            z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);\r\n        }\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\n// use comparisons since in some cases we handle more than one case (e.g. SOF)\r\n#define stbi__DNL(x)         ((x) == 0xdc)\r\n#define stbi__SOI(x)         ((x) == 0xd8)\r\n#define stbi__EOI(x)         ((x) == 0xd9)\r\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)\r\n#define stbi__SOS(x)         ((x) == 0xda)\r\n\r\n#define stbi__SOF_progressive(x)   ((x) == 0xc2)\r\n\r\nstatic int stbi__decode_jpeg_header(stbi__jpeg* z, int scan)\r\n{\r\n    int m;\r\n    z->jfif = 0;\r\n    z->app14_color_transform = -1; // valid values are 0,1,2\r\n    z->marker = STBI__MARKER_none; // initialize cached marker to empty\r\n    m = stbi__get_marker(z);\r\n    if (!stbi__SOI(m)) return stbi__err(\"no SOI\", \"Corrupt JPEG\");\r\n    if (scan == STBI__SCAN_type) return 1;\r\n    m = stbi__get_marker(z);\r\n    while (!stbi__SOF(m)) {\r\n        if (!stbi__process_marker(z, m)) return 0;\r\n        m = stbi__get_marker(z);\r\n        while (m == STBI__MARKER_none) {\r\n            // some files have extra padding after their blocks, so ok, we'll scan\r\n            if (stbi__at_eof(z->s)) return stbi__err(\"no SOF\", \"Corrupt JPEG\");\r\n            m = stbi__get_marker(z);\r\n        }\r\n    }\r\n    z->progressive = stbi__SOF_progressive(m);\r\n    if (!stbi__process_frame_header(z, scan)) return 0;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__skip_jpeg_junk_at_end(stbi__jpeg* j)\r\n{\r\n    // some JPEGs have junk at end, skip over it but if we find what looks\r\n    // like a valid marker, resume there\r\n    while (!stbi__at_eof(j->s)) {\r\n        int x = stbi__get8(j->s);\r\n        while (x == 255) { // might be a marker\r\n            if (stbi__at_eof(j->s)) return STBI__MARKER_none;\r\n            x = stbi__get8(j->s);\r\n            if (x != 0x00 && x != 0xff) {\r\n                // not a stuffed zero or lead-in to another marker, looks\r\n                // like an actual marker, return it\r\n                return x;\r\n            }\r\n            // stuffed zero has x=0 now which ends the loop, meaning we go\r\n            // back to regular scan loop.\r\n            // repeated 0xff keeps trying to read the next byte of the marker.\r\n        }\r\n    }\r\n    return STBI__MARKER_none;\r\n}\r\n\r\n// decode image to YCbCr format\r\nstatic int stbi__decode_jpeg_image(stbi__jpeg* j)\r\n{\r\n    int m;\r\n    for (m = 0; m < 4; m++) {\r\n        j->img_comp[m].raw_data = NULL;\r\n        j->img_comp[m].raw_coeff = NULL;\r\n    }\r\n    j->restart_interval = 0;\r\n    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;\r\n    m = stbi__get_marker(j);\r\n    while (!stbi__EOI(m)) {\r\n        if (stbi__SOS(m)) {\r\n            if (!stbi__process_scan_header(j)) return 0;\r\n            if (!stbi__parse_entropy_coded_data(j)) return 0;\r\n            if (j->marker == STBI__MARKER_none) {\r\n                j->marker = stbi__skip_jpeg_junk_at_end(j);\r\n                // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\r\n            }\r\n            m = stbi__get_marker(j);\r\n            if (STBI__RESTART(m))\r\n                m = stbi__get_marker(j);\r\n        }\r\n        else if (stbi__DNL(m)) {\r\n            int Ld = stbi__get16be(j->s);\r\n            stbi__uint32 NL = stbi__get16be(j->s);\r\n            if (Ld != 4) return stbi__err(\"bad DNL len\", \"Corrupt JPEG\");\r\n            if (NL != j->s->img_y) return stbi__err(\"bad DNL height\", \"Corrupt JPEG\");\r\n            m = stbi__get_marker(j);\r\n        }\r\n        else {\r\n            if (!stbi__process_marker(j, m)) return 1;\r\n            m = stbi__get_marker(j);\r\n        }\r\n    }\r\n    if (j->progressive)\r\n        stbi__jpeg_finish(j);\r\n    return 1;\r\n}\r\n\r\n// static jfif-centered resampling (across block boundaries)\r\n\r\ntypedef stbi_uc* (*resample_row_func)(stbi_uc* out, stbi_uc* in0, stbi_uc* in1,\r\n    int w, int hs);\r\n\r\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\r\n\r\nstatic stbi_uc* resample_row_1(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)\r\n{\r\n    STBI_NOTUSED(out);\r\n    STBI_NOTUSED(in_far);\r\n    STBI_NOTUSED(w);\r\n    STBI_NOTUSED(hs);\r\n    return in_near;\r\n}\r\n\r\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)\r\n{\r\n    // need to generate two samples vertically for every one in input\r\n    int i;\r\n    STBI_NOTUSED(hs);\r\n    for (i = 0; i < w; ++i)\r\n        out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);\r\n    return out;\r\n}\r\n\r\nstatic stbi_uc* stbi__resample_row_h_2(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)\r\n{\r\n    // need to generate two samples horizontally for every one in input\r\n    int i;\r\n    stbi_uc* input = in_near;\r\n\r\n    if (w == 1) {\r\n        // if only one sample, can't do any interpolation\r\n        out[0] = out[1] = input[0];\r\n        return out;\r\n    }\r\n\r\n    out[0] = input[0];\r\n    out[1] = stbi__div4(input[0] * 3 + input[1] + 2);\r\n    for (i = 1; i < w - 1; ++i) {\r\n        int n = 3 * input[i] + 2;\r\n        out[i * 2 + 0] = stbi__div4(n + input[i - 1]);\r\n        out[i * 2 + 1] = stbi__div4(n + input[i + 1]);\r\n    }\r\n    out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);\r\n    out[i * 2 + 1] = input[w - 1];\r\n\r\n    STBI_NOTUSED(in_far);\r\n    STBI_NOTUSED(hs);\r\n\r\n    return out;\r\n}\r\n\r\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\r\n\r\nstatic stbi_uc* stbi__resample_row_hv_2(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)\r\n{\r\n    // need to generate 2x2 samples for every one in input\r\n    int i, t0, t1;\r\n    if (w == 1) {\r\n        out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);\r\n        return out;\r\n    }\r\n\r\n    t1 = 3 * in_near[0] + in_far[0];\r\n    out[0] = stbi__div4(t1 + 2);\r\n    for (i = 1; i < w; ++i) {\r\n        t0 = t1;\r\n        t1 = 3 * in_near[i] + in_far[i];\r\n        out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);\r\n        out[i * 2] = stbi__div16(3 * t1 + t0 + 8);\r\n    }\r\n    out[w * 2 - 1] = stbi__div4(t1 + 2);\r\n\r\n    STBI_NOTUSED(hs);\r\n\r\n    return out;\r\n}\r\n\r\n#if defined(STBI_SSE2) || defined(STBI_NEON)\r\nstatic stbi_uc* stbi__resample_row_hv_2_simd(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)\r\n{\r\n    // need to generate 2x2 samples for every one in input\r\n    int i = 0, t0, t1;\r\n\r\n    if (w == 1) {\r\n        out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);\r\n        return out;\r\n    }\r\n\r\n    t1 = 3 * in_near[0] + in_far[0];\r\n    // process groups of 8 pixels for as long as we can.\r\n    // note we can't handle the last pixel in a row in this loop\r\n    // because we need to handle the filter boundary conditions.\r\n    for (; i < ((w - 1) & ~7); i += 8) {\r\n#if defined(STBI_SSE2)\r\n        // load and perform the vertical filtering pass\r\n        // this uses 3*x + y = 4*x + (y - x)\r\n        __m128i zero = _mm_setzero_si128();\r\n        __m128i farb = _mm_loadl_epi64((__m128i*) (in_far + i));\r\n        __m128i nearb = _mm_loadl_epi64((__m128i*) (in_near + i));\r\n        __m128i farw = _mm_unpacklo_epi8(farb, zero);\r\n        __m128i nearw = _mm_unpacklo_epi8(nearb, zero);\r\n        __m128i diff = _mm_sub_epi16(farw, nearw);\r\n        __m128i nears = _mm_slli_epi16(nearw, 2);\r\n        __m128i curr = _mm_add_epi16(nears, diff); // current row\r\n\r\n        // horizontal filter works the same based on shifted vers of current\r\n        // row. \"prev\" is current row shifted right by 1 pixel; we need to\r\n        // insert the previous pixel value (from t1).\r\n        // \"next\" is current row shifted left by 1 pixel, with first pixel\r\n        // of next block of 8 pixels added in.\r\n        __m128i prv0 = _mm_slli_si128(curr, 2);\r\n        __m128i nxt0 = _mm_srli_si128(curr, 2);\r\n        __m128i prev = _mm_insert_epi16(prv0, t1, 0);\r\n        __m128i next = _mm_insert_epi16(nxt0, 3 * in_near[i + 8] + in_far[i + 8], 7);\r\n\r\n        // horizontal filter, polyphase implementation since it's convenient:\r\n        // even pixels = 3*cur + prev = cur*4 + (prev - cur)\r\n        // odd  pixels = 3*cur + next = cur*4 + (next - cur)\r\n        // note the shared term.\r\n        __m128i bias = _mm_set1_epi16(8);\r\n        __m128i curs = _mm_slli_epi16(curr, 2);\r\n        __m128i prvd = _mm_sub_epi16(prev, curr);\r\n        __m128i nxtd = _mm_sub_epi16(next, curr);\r\n        __m128i curb = _mm_add_epi16(curs, bias);\r\n        __m128i even = _mm_add_epi16(prvd, curb);\r\n        __m128i odd = _mm_add_epi16(nxtd, curb);\r\n\r\n        // interleave even and odd pixels, then undo scaling.\r\n        __m128i int0 = _mm_unpacklo_epi16(even, odd);\r\n        __m128i int1 = _mm_unpackhi_epi16(even, odd);\r\n        __m128i de0 = _mm_srli_epi16(int0, 4);\r\n        __m128i de1 = _mm_srli_epi16(int1, 4);\r\n\r\n        // pack and write output\r\n        __m128i outv = _mm_packus_epi16(de0, de1);\r\n        _mm_storeu_si128((__m128i*) (out + i * 2), outv);\r\n#elif defined(STBI_NEON)\r\n        // load and perform the vertical filtering pass\r\n        // this uses 3*x + y = 4*x + (y - x)\r\n        uint8x8_t farb = vld1_u8(in_far + i);\r\n        uint8x8_t nearb = vld1_u8(in_near + i);\r\n        int16x8_t diff = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));\r\n        int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));\r\n        int16x8_t curr = vaddq_s16(nears, diff); // current row\r\n\r\n        // horizontal filter works the same based on shifted vers of current\r\n        // row. \"prev\" is current row shifted right by 1 pixel; we need to\r\n        // insert the previous pixel value (from t1).\r\n        // \"next\" is current row shifted left by 1 pixel, with first pixel\r\n        // of next block of 8 pixels added in.\r\n        int16x8_t prv0 = vextq_s16(curr, curr, 7);\r\n        int16x8_t nxt0 = vextq_s16(curr, curr, 1);\r\n        int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);\r\n        int16x8_t next = vsetq_lane_s16(3 * in_near[i + 8] + in_far[i + 8], nxt0, 7);\r\n\r\n        // horizontal filter, polyphase implementation since it's convenient:\r\n        // even pixels = 3*cur + prev = cur*4 + (prev - cur)\r\n        // odd  pixels = 3*cur + next = cur*4 + (next - cur)\r\n        // note the shared term.\r\n        int16x8_t curs = vshlq_n_s16(curr, 2);\r\n        int16x8_t prvd = vsubq_s16(prev, curr);\r\n        int16x8_t nxtd = vsubq_s16(next, curr);\r\n        int16x8_t even = vaddq_s16(curs, prvd);\r\n        int16x8_t odd = vaddq_s16(curs, nxtd);\r\n\r\n        // undo scaling and round, then store with even/odd phases interleaved\r\n        uint8x8x2_t o;\r\n        o.val[0] = vqrshrun_n_s16(even, 4);\r\n        o.val[1] = vqrshrun_n_s16(odd, 4);\r\n        vst2_u8(out + i * 2, o);\r\n#endif\r\n\r\n        // \"previous\" value for next iter\r\n        t1 = 3 * in_near[i + 7] + in_far[i + 7];\r\n    }\r\n\r\n    t0 = t1;\r\n    t1 = 3 * in_near[i] + in_far[i];\r\n    out[i * 2] = stbi__div16(3 * t1 + t0 + 8);\r\n\r\n    for (++i; i < w; ++i) {\r\n        t0 = t1;\r\n        t1 = 3 * in_near[i] + in_far[i];\r\n        out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);\r\n        out[i * 2] = stbi__div16(3 * t1 + t0 + 8);\r\n    }\r\n    out[w * 2 - 1] = stbi__div4(t1 + 2);\r\n\r\n    STBI_NOTUSED(hs);\r\n\r\n    return out;\r\n}\r\n#endif\r\n\r\nstatic stbi_uc* stbi__resample_row_generic(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)\r\n{\r\n    // resample with nearest-neighbor\r\n    int i, j;\r\n    STBI_NOTUSED(in_far);\r\n    for (i = 0; i < w; ++i)\r\n        for (j = 0; j < hs; ++j)\r\n            out[i * hs + j] = in_near[i];\r\n    return out;\r\n}\r\n\r\n// this is a reduced-precision calculation of YCbCr-to-RGB introduced\r\n// to make sure the code produces the same results in both SIMD and scalar\r\n#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)\r\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc* out, const stbi_uc* y, const stbi_uc* pcb, const stbi_uc* pcr, int count, int step)\r\n{\r\n    int i;\r\n    for (i = 0; i < count; ++i) {\r\n        int y_fixed = (y[i] << 20) + (1 << 19); // rounding\r\n        int r, g, b;\r\n        int cr = pcr[i] - 128;\r\n        int cb = pcb[i] - 128;\r\n        r = y_fixed + cr * stbi__float2fixed(1.40200f);\r\n        g = y_fixed + (cr * -stbi__float2fixed(0.71414f)) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);\r\n        b = y_fixed + cb * stbi__float2fixed(1.77200f);\r\n        r >>= 20;\r\n        g >>= 20;\r\n        b >>= 20;\r\n        if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }\r\n        if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }\r\n        if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }\r\n        out[0] = (stbi_uc)r;\r\n        out[1] = (stbi_uc)g;\r\n        out[2] = (stbi_uc)b;\r\n        out[3] = 255;\r\n        out += step;\r\n    }\r\n}\r\n\r\n#if defined(STBI_SSE2) || defined(STBI_NEON)\r\nstatic void stbi__YCbCr_to_RGB_simd(stbi_uc* out, stbi_uc const* y, stbi_uc const* pcb, stbi_uc const* pcr, int count, int step)\r\n{\r\n    int i = 0;\r\n\r\n#ifdef STBI_SSE2\r\n    // step == 3 is pretty ugly on the final interleave, and i'm not convinced\r\n    // it's useful in practice (you wouldn't use it for textures, for example).\r\n    // so just accelerate step == 4 case.\r\n    if (step == 4) {\r\n        // this is a fairly straightforward implementation and not super-optimized.\r\n        __m128i signflip = _mm_set1_epi8(-0x80);\r\n        __m128i cr_const0 = _mm_set1_epi16((short)(1.40200f * 4096.0f + 0.5f));\r\n        __m128i cr_const1 = _mm_set1_epi16(-(short)(0.71414f * 4096.0f + 0.5f));\r\n        __m128i cb_const0 = _mm_set1_epi16(-(short)(0.34414f * 4096.0f + 0.5f));\r\n        __m128i cb_const1 = _mm_set1_epi16((short)(1.77200f * 4096.0f + 0.5f));\r\n        __m128i y_bias = _mm_set1_epi8((char)(unsigned char)128);\r\n        __m128i xw = _mm_set1_epi16(255); // alpha channel\r\n\r\n        for (; i + 7 < count; i += 8) {\r\n            // load\r\n            __m128i y_bytes = _mm_loadl_epi64((__m128i*) (y + i));\r\n            __m128i cr_bytes = _mm_loadl_epi64((__m128i*) (pcr + i));\r\n            __m128i cb_bytes = _mm_loadl_epi64((__m128i*) (pcb + i));\r\n            __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128\r\n            __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128\r\n\r\n            // unpack to short (and left-shift cr, cb by 8)\r\n            __m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);\r\n            __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);\r\n            __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);\r\n\r\n            // color transform\r\n            __m128i yws = _mm_srli_epi16(yw, 4);\r\n            __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);\r\n            __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);\r\n            __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);\r\n            __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);\r\n            __m128i rws = _mm_add_epi16(cr0, yws);\r\n            __m128i gwt = _mm_add_epi16(cb0, yws);\r\n            __m128i bws = _mm_add_epi16(yws, cb1);\r\n            __m128i gws = _mm_add_epi16(gwt, cr1);\r\n\r\n            // descale\r\n            __m128i rw = _mm_srai_epi16(rws, 4);\r\n            __m128i bw = _mm_srai_epi16(bws, 4);\r\n            __m128i gw = _mm_srai_epi16(gws, 4);\r\n\r\n            // back to byte, set up for transpose\r\n            __m128i brb = _mm_packus_epi16(rw, bw);\r\n            __m128i gxb = _mm_packus_epi16(gw, xw);\r\n\r\n            // transpose to interleave channels\r\n            __m128i t0 = _mm_unpacklo_epi8(brb, gxb);\r\n            __m128i t1 = _mm_unpackhi_epi8(brb, gxb);\r\n            __m128i o0 = _mm_unpacklo_epi16(t0, t1);\r\n            __m128i o1 = _mm_unpackhi_epi16(t0, t1);\r\n\r\n            // store\r\n            _mm_storeu_si128((__m128i*) (out + 0), o0);\r\n            _mm_storeu_si128((__m128i*) (out + 16), o1);\r\n            out += 32;\r\n        }\r\n    }\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n    // in this version, step=3 support would be easy to add. but is there demand?\r\n    if (step == 4) {\r\n        // this is a fairly straightforward implementation and not super-optimized.\r\n        uint8x8_t signflip = vdup_n_u8(0x80);\r\n        int16x8_t cr_const0 = vdupq_n_s16((short)(1.40200f * 4096.0f + 0.5f));\r\n        int16x8_t cr_const1 = vdupq_n_s16(-(short)(0.71414f * 4096.0f + 0.5f));\r\n        int16x8_t cb_const0 = vdupq_n_s16(-(short)(0.34414f * 4096.0f + 0.5f));\r\n        int16x8_t cb_const1 = vdupq_n_s16((short)(1.77200f * 4096.0f + 0.5f));\r\n\r\n        for (; i + 7 < count; i += 8) {\r\n            // load\r\n            uint8x8_t y_bytes = vld1_u8(y + i);\r\n            uint8x8_t cr_bytes = vld1_u8(pcr + i);\r\n            uint8x8_t cb_bytes = vld1_u8(pcb + i);\r\n            int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));\r\n            int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));\r\n\r\n            // expand to s16\r\n            int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));\r\n            int16x8_t crw = vshll_n_s8(cr_biased, 7);\r\n            int16x8_t cbw = vshll_n_s8(cb_biased, 7);\r\n\r\n            // color transform\r\n            int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);\r\n            int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);\r\n            int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);\r\n            int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);\r\n            int16x8_t rws = vaddq_s16(yws, cr0);\r\n            int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);\r\n            int16x8_t bws = vaddq_s16(yws, cb1);\r\n\r\n            // undo scaling, round, convert to byte\r\n            uint8x8x4_t o;\r\n            o.val[0] = vqrshrun_n_s16(rws, 4);\r\n            o.val[1] = vqrshrun_n_s16(gws, 4);\r\n            o.val[2] = vqrshrun_n_s16(bws, 4);\r\n            o.val[3] = vdup_n_u8(255);\r\n\r\n            // store, interleaving r/g/b/a\r\n            vst4_u8(out, o);\r\n            out += 8 * 4;\r\n        }\r\n    }\r\n#endif\r\n\r\n    for (; i < count; ++i) {\r\n        int y_fixed = (y[i] << 20) + (1 << 19); // rounding\r\n        int r, g, b;\r\n        int cr = pcr[i] - 128;\r\n        int cb = pcb[i] - 128;\r\n        r = y_fixed + cr * stbi__float2fixed(1.40200f);\r\n        g = y_fixed + cr * -stbi__float2fixed(0.71414f) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);\r\n        b = y_fixed + cb * stbi__float2fixed(1.77200f);\r\n        r >>= 20;\r\n        g >>= 20;\r\n        b >>= 20;\r\n        if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }\r\n        if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }\r\n        if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }\r\n        out[0] = (stbi_uc)r;\r\n        out[1] = (stbi_uc)g;\r\n        out[2] = (stbi_uc)b;\r\n        out[3] = 255;\r\n        out += step;\r\n    }\r\n}\r\n#endif\r\n\r\n// set up the kernels\r\nstatic void stbi__setup_jpeg(stbi__jpeg* j)\r\n{\r\n    j->idct_block_kernel = stbi__idct_block;\r\n    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;\r\n    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;\r\n\r\n#ifdef STBI_SSE2\r\n    if (stbi__sse2_available()) {\r\n        j->idct_block_kernel = stbi__idct_simd;\r\n        j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\r\n        j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\r\n    }\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n    j->idct_block_kernel = stbi__idct_simd;\r\n    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\r\n    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\r\n#endif\r\n}\r\n\r\n// clean up the temporary component buffers\r\nstatic void stbi__cleanup_jpeg(stbi__jpeg* j)\r\n{\r\n    stbi__free_jpeg_components(j, j->s->img_n, 0);\r\n}\r\n\r\ntypedef struct\r\n{\r\n    resample_row_func resample;\r\n    stbi_uc* line0, * line1;\r\n    int hs, vs;   // expansion factor in each axis\r\n    int w_lores; // horizontal pixels pre-expansion\r\n    int ystep;   // how far through vertical expansion we are\r\n    int ypos;    // which pre-expansion row we're on\r\n} stbi__resample;\r\n\r\n// fast 0..255 * 0..255 => 0..255 rounded multiplication\r\nstatic stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)\r\n{\r\n    unsigned int t = x * y + 128;\r\n    return (stbi_uc)((t + (t >> 8)) >> 8);\r\n}\r\n\r\nstatic stbi_uc* load_jpeg_image(stbi__jpeg* z, int* out_x, int* out_y, int* comp, int req_comp)\r\n{\r\n    int n, decode_n, is_rgb;\r\n    z->s->img_n = 0; // make stbi__cleanup_jpeg safe\r\n\r\n    // validate req_comp\r\n    if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\r\n\r\n    // load a jpeg image from whichever source, but leave in YCbCr format\r\n    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\r\n\r\n    // determine actual number of components to generate\r\n    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;\r\n\r\n    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));\r\n\r\n    if (z->s->img_n == 3 && n < 3 && !is_rgb)\r\n        decode_n = 1;\r\n    else\r\n        decode_n = z->s->img_n;\r\n\r\n    // nothing to do if no components requested; check this now to avoid\r\n    // accessing uninitialized coutput[0] later\r\n    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }\r\n\r\n    // resample and color-convert\r\n    {\r\n        int k;\r\n        unsigned int i, j;\r\n        stbi_uc* output;\r\n        stbi_uc* coutput[4] = { NULL, NULL, NULL, NULL };\r\n\r\n        stbi__resample res_comp[4];\r\n\r\n        for (k = 0; k < decode_n; ++k) {\r\n            stbi__resample* r = &res_comp[k];\r\n\r\n            // allocate line buffer big enough for upsampling off the edges\r\n            // with upsample factor of 4\r\n            z->img_comp[k].linebuf = (stbi_uc*)stbi__malloc(z->s->img_x + 3);\r\n            if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n\r\n            r->hs = z->img_h_max / z->img_comp[k].h;\r\n            r->vs = z->img_v_max / z->img_comp[k].v;\r\n            r->ystep = r->vs >> 1;\r\n            r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;\r\n            r->ypos = 0;\r\n            r->line0 = r->line1 = z->img_comp[k].data;\r\n\r\n            if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\r\n            else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\r\n            else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\r\n            else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;\r\n            else                               r->resample = stbi__resample_row_generic;\r\n        }\r\n\r\n        // can't error after this so, this is safe\r\n        output = (stbi_uc*)stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);\r\n        if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n\r\n        // now go ahead and resample\r\n        for (j = 0; j < z->s->img_y; ++j) {\r\n            stbi_uc* out = output + n * z->s->img_x * j;\r\n            for (k = 0; k < decode_n; ++k) {\r\n                stbi__resample* r = &res_comp[k];\r\n                int y_bot = r->ystep >= (r->vs >> 1);\r\n                coutput[k] = r->resample(z->img_comp[k].linebuf,\r\n                    y_bot ? r->line1 : r->line0,\r\n                    y_bot ? r->line0 : r->line1,\r\n                    r->w_lores, r->hs);\r\n                if (++r->ystep >= r->vs) {\r\n                    r->ystep = 0;\r\n                    r->line0 = r->line1;\r\n                    if (++r->ypos < z->img_comp[k].y)\r\n                        r->line1 += z->img_comp[k].w2;\r\n                }\r\n            }\r\n            if (n >= 3) {\r\n                stbi_uc* y = coutput[0];\r\n                if (z->s->img_n == 3) {\r\n                    if (is_rgb) {\r\n                        for (i = 0; i < z->s->img_x; ++i) {\r\n                            out[0] = y[i];\r\n                            out[1] = coutput[1][i];\r\n                            out[2] = coutput[2][i];\r\n                            out[3] = 255;\r\n                            out += n;\r\n                        }\r\n                    }\r\n                    else {\r\n                        z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n                    }\r\n                }\r\n                else if (z->s->img_n == 4) {\r\n                    if (z->app14_color_transform == 0) { // CMYK\r\n                        for (i = 0; i < z->s->img_x; ++i) {\r\n                            stbi_uc m = coutput[3][i];\r\n                            out[0] = stbi__blinn_8x8(coutput[0][i], m);\r\n                            out[1] = stbi__blinn_8x8(coutput[1][i], m);\r\n                            out[2] = stbi__blinn_8x8(coutput[2][i], m);\r\n                            out[3] = 255;\r\n                            out += n;\r\n                        }\r\n                    }\r\n                    else if (z->app14_color_transform == 2) { // YCCK\r\n                        z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n                        for (i = 0; i < z->s->img_x; ++i) {\r\n                            stbi_uc m = coutput[3][i];\r\n                            out[0] = stbi__blinn_8x8(255 - out[0], m);\r\n                            out[1] = stbi__blinn_8x8(255 - out[1], m);\r\n                            out[2] = stbi__blinn_8x8(255 - out[2], m);\r\n                            out += n;\r\n                        }\r\n                    }\r\n                    else { // YCbCr + alpha?  Ignore the fourth channel for now\r\n                        z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n                    }\r\n                }\r\n                else\r\n                    for (i = 0; i < z->s->img_x; ++i) {\r\n                        out[0] = out[1] = out[2] = y[i];\r\n                        out[3] = 255; // not used if n==3\r\n                        out += n;\r\n                    }\r\n            }\r\n            else {\r\n                if (is_rgb) {\r\n                    if (n == 1)\r\n                        for (i = 0; i < z->s->img_x; ++i)\r\n                            *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\r\n                    else {\r\n                        for (i = 0; i < z->s->img_x; ++i, out += 2) {\r\n                            out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\r\n                            out[1] = 255;\r\n                        }\r\n                    }\r\n                }\r\n                else if (z->s->img_n == 4 && z->app14_color_transform == 0) {\r\n                    for (i = 0; i < z->s->img_x; ++i) {\r\n                        stbi_uc m = coutput[3][i];\r\n                        stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);\r\n                        stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);\r\n                        stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);\r\n                        out[0] = stbi__compute_y(r, g, b);\r\n                        out[1] = 255;\r\n                        out += n;\r\n                    }\r\n                }\r\n                else if (z->s->img_n == 4 && z->app14_color_transform == 2) {\r\n                    for (i = 0; i < z->s->img_x; ++i) {\r\n                        out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);\r\n                        out[1] = 255;\r\n                        out += n;\r\n                    }\r\n                }\r\n                else {\r\n                    stbi_uc* y = coutput[0];\r\n                    if (n == 1)\r\n                        for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];\r\n                    else\r\n                        for (i = 0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }\r\n                }\r\n            }\r\n        }\r\n        stbi__cleanup_jpeg(z);\r\n        *out_x = z->s->img_x;\r\n        *out_y = z->s->img_y;\r\n        if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output\r\n        return output;\r\n    }\r\n}\r\n\r\nstatic void* stbi__jpeg_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    unsigned char* result;\r\n    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\r\n    if (!j) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    memset(j, 0, sizeof(stbi__jpeg));\r\n    STBI_NOTUSED(ri);\r\n    j->s = s;\r\n    stbi__setup_jpeg(j);\r\n    result = load_jpeg_image(j, x, y, comp, req_comp);\r\n    STBI_FREE(j);\r\n    return result;\r\n}\r\n\r\nstatic int stbi__jpeg_test(stbi__context* s)\r\n{\r\n    int r;\r\n    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\r\n    if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\r\n    memset(j, 0, sizeof(stbi__jpeg));\r\n    j->s = s;\r\n    stbi__setup_jpeg(j);\r\n    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);\r\n    stbi__rewind(s);\r\n    STBI_FREE(j);\r\n    return r;\r\n}\r\n\r\nstatic int stbi__jpeg_info_raw(stbi__jpeg* j, int* x, int* y, int* comp)\r\n{\r\n    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {\r\n        stbi__rewind(j->s);\r\n        return 0;\r\n    }\r\n    if (x) *x = j->s->img_x;\r\n    if (y) *y = j->s->img_y;\r\n    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__jpeg_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    int result;\r\n    stbi__jpeg* j = (stbi__jpeg*)(stbi__malloc(sizeof(stbi__jpeg)));\r\n    if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\r\n    memset(j, 0, sizeof(stbi__jpeg));\r\n    j->s = s;\r\n    result = stbi__jpeg_info_raw(j, x, y, comp);\r\n    STBI_FREE(j);\r\n    return result;\r\n}\r\n#endif\r\n\r\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\r\n//    simple implementation\r\n//      - all input must be provided in an upfront buffer\r\n//      - all output is written to a single output buffer (can malloc/realloc)\r\n//    performance\r\n//      - fast huffman\r\n\r\n#ifndef STBI_NO_ZLIB\r\n\r\n// fast-way is faster to check than jpeg huffman, but slow way is slower\r\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\r\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\r\n#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet\r\n\r\n// zlib-style huffman encoding\r\n// (jpegs packs from left, zlib from right, so can't share code)\r\ntypedef struct\r\n{\r\n    stbi__uint16 fast[1 << STBI__ZFAST_BITS];\r\n    stbi__uint16 firstcode[16];\r\n    int maxcode[17];\r\n    stbi__uint16 firstsymbol[16];\r\n    stbi_uc  size[STBI__ZNSYMS];\r\n    stbi__uint16 value[STBI__ZNSYMS];\r\n} stbi__zhuffman;\r\n\r\nstbi_inline static int stbi__bitreverse16(int n)\r\n{\r\n    n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);\r\n    n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);\r\n    n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);\r\n    n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);\r\n    return n;\r\n}\r\n\r\nstbi_inline static int stbi__bit_reverse(int v, int bits)\r\n{\r\n    STBI_ASSERT(bits <= 16);\r\n    // to bit reverse n bits, reverse 16 and shift\r\n    // e.g. 11 bits, bit reverse and shift away 5\r\n    return stbi__bitreverse16(v) >> (16 - bits);\r\n}\r\n\r\nstatic int stbi__zbuild_huffman(stbi__zhuffman* z, const stbi_uc* sizelist, int num)\r\n{\r\n    int i, k = 0;\r\n    int code, next_code[16], sizes[17];\r\n\r\n    // DEFLATE spec for generating codes\r\n    memset(sizes, 0, sizeof(sizes));\r\n    memset(z->fast, 0, sizeof(z->fast));\r\n    for (i = 0; i < num; ++i)\r\n        ++sizes[sizelist[i]];\r\n    sizes[0] = 0;\r\n    for (i = 1; i < 16; ++i)\r\n        if (sizes[i] > (1 << i))\r\n            return stbi__err(\"bad sizes\", \"Corrupt PNG\");\r\n    code = 0;\r\n    for (i = 1; i < 16; ++i) {\r\n        next_code[i] = code;\r\n        z->firstcode[i] = (stbi__uint16)code;\r\n        z->firstsymbol[i] = (stbi__uint16)k;\r\n        code = (code + sizes[i]);\r\n        if (sizes[i])\r\n            if (code - 1 >= (1 << i)) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n        z->maxcode[i] = code << (16 - i); // preshift for inner loop\r\n        code <<= 1;\r\n        k += sizes[i];\r\n    }\r\n    z->maxcode[16] = 0x10000; // sentinel\r\n    for (i = 0; i < num; ++i) {\r\n        int s = sizelist[i];\r\n        if (s) {\r\n            int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\r\n            stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);\r\n            z->size[c] = (stbi_uc)s;\r\n            z->value[c] = (stbi__uint16)i;\r\n            if (s <= STBI__ZFAST_BITS) {\r\n                int j = stbi__bit_reverse(next_code[s], s);\r\n                while (j < (1 << STBI__ZFAST_BITS)) {\r\n                    z->fast[j] = fastv;\r\n                    j += (1 << s);\r\n                }\r\n            }\r\n            ++next_code[s];\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\n// zlib-from-memory implementation for PNG reading\r\n//    because PNG allows splitting the zlib stream arbitrarily,\r\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\r\n//    we require PNG read all the IDATs and combine them into a single\r\n//    memory buffer\r\n\r\ntypedef struct\r\n{\r\n    stbi_uc* zbuffer, * zbuffer_end;\r\n    int num_bits;\r\n    stbi__uint32 code_buffer;\r\n\r\n    char* zout;\r\n    char* zout_start;\r\n    char* zout_end;\r\n    int   z_expandable;\r\n\r\n    stbi__zhuffman z_length, z_distance;\r\n} stbi__zbuf;\r\n\r\nstbi_inline static int stbi__zeof(stbi__zbuf* z)\r\n{\r\n    return (z->zbuffer >= z->zbuffer_end);\r\n}\r\n\r\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf* z)\r\n{\r\n    return stbi__zeof(z) ? 0 : *z->zbuffer++;\r\n}\r\n\r\nstatic void stbi__fill_bits(stbi__zbuf* z)\r\n{\r\n    do {\r\n        if (z->code_buffer >= (1U << z->num_bits)) {\r\n            z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */\r\n            return;\r\n        }\r\n        z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;\r\n        z->num_bits += 8;\r\n    } while (z->num_bits <= 24);\r\n}\r\n\r\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf* z, int n)\r\n{\r\n    unsigned int k;\r\n    if (z->num_bits < n) stbi__fill_bits(z);\r\n    k = z->code_buffer & ((1 << n) - 1);\r\n    z->code_buffer >>= n;\r\n    z->num_bits -= n;\r\n    return k;\r\n}\r\n\r\nstatic int stbi__zhuffman_decode_slowpath(stbi__zbuf* a, stbi__zhuffman* z)\r\n{\r\n    int b, s, k;\r\n    // not resolved by fast table, so compute it the slow way\r\n    // use jpeg approach, which requires MSbits at top\r\n    k = stbi__bit_reverse(a->code_buffer, 16);\r\n    for (s = STBI__ZFAST_BITS + 1; ; ++s)\r\n        if (k < z->maxcode[s])\r\n            break;\r\n    if (s >= 16) return -1; // invalid code!\r\n    // code size is s, so:\r\n    b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];\r\n    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!\r\n    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.\r\n    a->code_buffer >>= s;\r\n    a->num_bits -= s;\r\n    return z->value[b];\r\n}\r\n\r\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf* a, stbi__zhuffman* z)\r\n{\r\n    int b, s;\r\n    if (a->num_bits < 16) {\r\n        if (stbi__zeof(a)) {\r\n            return -1;   /* report error for unexpected end of data. */\r\n        }\r\n        stbi__fill_bits(a);\r\n    }\r\n    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\r\n    if (b) {\r\n        s = b >> 9;\r\n        a->code_buffer >>= s;\r\n        a->num_bits -= s;\r\n        return b & 511;\r\n    }\r\n    return stbi__zhuffman_decode_slowpath(a, z);\r\n}\r\n\r\nstatic int stbi__zexpand(stbi__zbuf* z, char* zout, int n)  // need to make room for n bytes\r\n{\r\n    char* q;\r\n    unsigned int cur, limit, old_limit;\r\n    z->zout = zout;\r\n    if (!z->z_expandable) return stbi__err(\"output buffer limit\", \"Corrupt PNG\");\r\n    cur = (unsigned int)(z->zout - z->zout_start);\r\n    limit = old_limit = (unsigned)(z->zout_end - z->zout_start);\r\n    if (UINT_MAX - cur < (unsigned)n) return stbi__err(\"outofmem\", \"Out of memory\");\r\n    while (cur + n > limit) {\r\n        if (limit > UINT_MAX / 2) return stbi__err(\"outofmem\", \"Out of memory\");\r\n        limit *= 2;\r\n    }\r\n    q = (char*)STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);\r\n    STBI_NOTUSED(old_limit);\r\n    if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n    z->zout_start = q;\r\n    z->zout = q + cur;\r\n    z->zout_end = q + limit;\r\n    return 1;\r\n}\r\n\r\nstatic const int stbi__zlength_base[31] = {\r\n   3,4,5,6,7,8,9,10,11,13,\r\n   15,17,19,23,27,31,35,43,51,59,\r\n   67,83,99,115,131,163,195,227,258,0,0 };\r\n\r\nstatic const int stbi__zlength_extra[31] =\r\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\r\n\r\nstatic const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\r\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0 };\r\n\r\nstatic const int stbi__zdist_extra[32] =\r\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };\r\n\r\nstatic int stbi__parse_huffman_block(stbi__zbuf* a)\r\n{\r\n    char* zout = a->zout;\r\n    for (;;) {\r\n        int z = stbi__zhuffman_decode(a, &a->z_length);\r\n        if (z < 256) {\r\n            if (z < 0) return stbi__err(\"bad huffman code\", \"Corrupt PNG\"); // error in huffman codes\r\n            if (zout >= a->zout_end) {\r\n                if (!stbi__zexpand(a, zout, 1)) return 0;\r\n                zout = a->zout;\r\n            }\r\n            *zout++ = (char)z;\r\n        }\r\n        else {\r\n            stbi_uc* p;\r\n            int len, dist;\r\n            if (z == 256) {\r\n                a->zout = zout;\r\n                return 1;\r\n            }\r\n            if (z >= 286) return stbi__err(\"bad huffman code\", \"Corrupt PNG\"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data\r\n            z -= 257;\r\n            len = stbi__zlength_base[z];\r\n            if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\r\n            z = stbi__zhuffman_decode(a, &a->z_distance);\r\n            if (z < 0 || z >= 30) return stbi__err(\"bad huffman code\", \"Corrupt PNG\"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data\r\n            dist = stbi__zdist_base[z];\r\n            if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\r\n            if (zout - a->zout_start < dist) return stbi__err(\"bad dist\", \"Corrupt PNG\");\r\n            if (zout + len > a->zout_end) {\r\n                if (!stbi__zexpand(a, zout, len)) return 0;\r\n                zout = a->zout;\r\n            }\r\n            p = (stbi_uc*)(zout - dist);\r\n            if (dist == 1) { // run of one byte; common in images.\r\n                stbi_uc v = *p;\r\n                if (len) { do *zout++ = v; while (--len); }\r\n            }\r\n            else {\r\n                if (len) { do *zout++ = *p++; while (--len); }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic int stbi__compute_huffman_codes(stbi__zbuf* a)\r\n{\r\n    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\r\n    stbi__zhuffman z_codelength;\r\n    stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op\r\n    stbi_uc codelength_sizes[19];\r\n    int i, n;\r\n\r\n    int hlit = stbi__zreceive(a, 5) + 257;\r\n    int hdist = stbi__zreceive(a, 5) + 1;\r\n    int hclen = stbi__zreceive(a, 4) + 4;\r\n    int ntot = hlit + hdist;\r\n\r\n    memset(codelength_sizes, 0, sizeof(codelength_sizes));\r\n    for (i = 0; i < hclen; ++i) {\r\n        int s = stbi__zreceive(a, 3);\r\n        codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;\r\n    }\r\n    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\r\n\r\n    n = 0;\r\n    while (n < ntot) {\r\n        int c = stbi__zhuffman_decode(a, &z_codelength);\r\n        if (c < 0 || c >= 19) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n        if (c < 16)\r\n            lencodes[n++] = (stbi_uc)c;\r\n        else {\r\n            stbi_uc fill = 0;\r\n            if (c == 16) {\r\n                c = stbi__zreceive(a, 2) + 3;\r\n                if (n == 0) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n                fill = lencodes[n - 1];\r\n            }\r\n            else if (c == 17) {\r\n                c = stbi__zreceive(a, 3) + 3;\r\n            }\r\n            else if (c == 18) {\r\n                c = stbi__zreceive(a, 7) + 11;\r\n            }\r\n            else {\r\n                return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n            }\r\n            if (ntot - n < c) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n            memset(lencodes + n, fill, c);\r\n            n += c;\r\n        }\r\n    }\r\n    if (n != ntot) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\r\n    if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__parse_uncompressed_block(stbi__zbuf* a)\r\n{\r\n    stbi_uc header[4];\r\n    int len, nlen, k;\r\n    if (a->num_bits & 7)\r\n        stbi__zreceive(a, a->num_bits & 7); // discard\r\n     // drain the bit-packed data into header\r\n    k = 0;\r\n    while (a->num_bits > 0) {\r\n        header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check\r\n        a->code_buffer >>= 8;\r\n        a->num_bits -= 8;\r\n    }\r\n    if (a->num_bits < 0) return stbi__err(\"zlib corrupt\", \"Corrupt PNG\");\r\n    // now fill header the normal way\r\n    while (k < 4)\r\n        header[k++] = stbi__zget8(a);\r\n    len = header[1] * 256 + header[0];\r\n    nlen = header[3] * 256 + header[2];\r\n    if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\", \"Corrupt PNG\");\r\n    if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\", \"Corrupt PNG\");\r\n    if (a->zout + len > a->zout_end)\r\n        if (!stbi__zexpand(a, a->zout, len)) return 0;\r\n    memcpy(a->zout, a->zbuffer, len);\r\n    a->zbuffer += len;\r\n    a->zout += len;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__parse_zlib_header(stbi__zbuf* a)\r\n{\r\n    int cmf = stbi__zget8(a);\r\n    int cm = cmf & 15;\r\n    /* int cinfo = cmf >> 4; */\r\n    int flg = stbi__zget8(a);\r\n    if (stbi__zeof(a)) return stbi__err(\"bad zlib header\", \"Corrupt PNG\"); // zlib spec\r\n    if ((cmf * 256 + flg) % 31 != 0) return stbi__err(\"bad zlib header\", \"Corrupt PNG\"); // zlib spec\r\n    if (flg & 32) return stbi__err(\"no preset dict\", \"Corrupt PNG\"); // preset dictionary not allowed in png\r\n    if (cm != 8) return stbi__err(\"bad compression\", \"Corrupt PNG\"); // DEFLATE required for png\r\n    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\r\n    return 1;\r\n}\r\n\r\nstatic const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =\r\n{\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8\r\n};\r\nstatic const stbi_uc stbi__zdefault_distance[32] =\r\n{\r\n   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\r\n};\r\n/*\r\nInit algorithm:\r\n{\r\n   int i;   // use <= to match clearly with spec\r\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\r\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\r\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\r\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\r\n\r\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\r\n}\r\n*/\r\n\r\nstatic int stbi__parse_zlib(stbi__zbuf* a, int parse_header)\r\n{\r\n    int final, type;\r\n    if (parse_header)\r\n        if (!stbi__parse_zlib_header(a)) return 0;\r\n    a->num_bits = 0;\r\n    a->code_buffer = 0;\r\n    do {\r\n        final = stbi__zreceive(a, 1);\r\n        type = stbi__zreceive(a, 2);\r\n        if (type == 0) {\r\n            if (!stbi__parse_uncompressed_block(a)) return 0;\r\n        }\r\n        else if (type == 3) {\r\n            return 0;\r\n        }\r\n        else {\r\n            if (type == 1) {\r\n                // use fixed code lengths\r\n                if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, STBI__ZNSYMS)) return 0;\r\n                if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;\r\n            }\r\n            else {\r\n                if (!stbi__compute_huffman_codes(a)) return 0;\r\n            }\r\n            if (!stbi__parse_huffman_block(a)) return 0;\r\n        }\r\n    } while (!final);\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__do_zlib(stbi__zbuf* a, char* obuf, int olen, int exp, int parse_header)\r\n{\r\n    a->zout_start = obuf;\r\n    a->zout = obuf;\r\n    a->zout_end = obuf + olen;\r\n    a->z_expandable = exp;\r\n\r\n    return stbi__parse_zlib(a, parse_header);\r\n}\r\n\r\nSTBIDEF char* stbi_zlib_decode_malloc_guesssize(const char* buffer, int len, int initial_size, int* outlen)\r\n{\r\n    stbi__zbuf a;\r\n    char* p = (char*)stbi__malloc(initial_size);\r\n    if (p == NULL) return NULL;\r\n    a.zbuffer = (stbi_uc*)buffer;\r\n    a.zbuffer_end = (stbi_uc*)buffer + len;\r\n    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\r\n        if (outlen) *outlen = (int)(a.zout - a.zout_start);\r\n        return a.zout_start;\r\n    }\r\n    else {\r\n        STBI_FREE(a.zout_start);\r\n        return NULL;\r\n    }\r\n}\r\n\r\nSTBIDEF char* stbi_zlib_decode_malloc(char const* buffer, int len, int* outlen)\r\n{\r\n    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\r\n}\r\n\r\nSTBIDEF char* stbi_zlib_decode_malloc_guesssize_headerflag(const char* buffer, int len, int initial_size, int* outlen, int parse_header)\r\n{\r\n    stbi__zbuf a;\r\n    char* p = (char*)stbi__malloc(initial_size);\r\n    if (p == NULL) return NULL;\r\n    a.zbuffer = (stbi_uc*)buffer;\r\n    a.zbuffer_end = (stbi_uc*)buffer + len;\r\n    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\r\n        if (outlen) *outlen = (int)(a.zout - a.zout_start);\r\n        return a.zout_start;\r\n    }\r\n    else {\r\n        STBI_FREE(a.zout_start);\r\n        return NULL;\r\n    }\r\n}\r\n\r\nSTBIDEF int stbi_zlib_decode_buffer(char* obuffer, int olen, char const* ibuffer, int ilen)\r\n{\r\n    stbi__zbuf a;\r\n    a.zbuffer = (stbi_uc*)ibuffer;\r\n    a.zbuffer_end = (stbi_uc*)ibuffer + ilen;\r\n    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\r\n        return (int)(a.zout - a.zout_start);\r\n    else\r\n        return -1;\r\n}\r\n\r\nSTBIDEF char* stbi_zlib_decode_noheader_malloc(char const* buffer, int len, int* outlen)\r\n{\r\n    stbi__zbuf a;\r\n    char* p = (char*)stbi__malloc(16384);\r\n    if (p == NULL) return NULL;\r\n    a.zbuffer = (stbi_uc*)buffer;\r\n    a.zbuffer_end = (stbi_uc*)buffer + len;\r\n    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\r\n        if (outlen) *outlen = (int)(a.zout - a.zout_start);\r\n        return a.zout_start;\r\n    }\r\n    else {\r\n        STBI_FREE(a.zout_start);\r\n        return NULL;\r\n    }\r\n}\r\n\r\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char* obuffer, int olen, const char* ibuffer, int ilen)\r\n{\r\n    stbi__zbuf a;\r\n    a.zbuffer = (stbi_uc*)ibuffer;\r\n    a.zbuffer_end = (stbi_uc*)ibuffer + ilen;\r\n    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\r\n        return (int)(a.zout - a.zout_start);\r\n    else\r\n        return -1;\r\n}\r\n#endif\r\n\r\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\r\n//    simple implementation\r\n//      - only 8-bit samples\r\n//      - no CRC checking\r\n//      - allocates lots of intermediate memory\r\n//        - avoids problem of streaming data between subsystems\r\n//        - avoids explicit window management\r\n//    performance\r\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\r\n\r\n#ifndef STBI_NO_PNG\r\ntypedef struct\r\n{\r\n    stbi__uint32 length;\r\n    stbi__uint32 type;\r\n} stbi__pngchunk;\r\n\r\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context* s)\r\n{\r\n    stbi__pngchunk c;\r\n    c.length = stbi__get32be(s);\r\n    c.type = stbi__get32be(s);\r\n    return c;\r\n}\r\n\r\nstatic int stbi__check_png_header(stbi__context* s)\r\n{\r\n    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\r\n    int i;\r\n    for (i = 0; i < 8; ++i)\r\n        if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\", \"Not a PNG\");\r\n    return 1;\r\n}\r\n\r\ntypedef struct\r\n{\r\n    stbi__context* s;\r\n    stbi_uc* idata, * expanded, * out;\r\n    int depth;\r\n} stbi__png;\r\n\r\n\r\nenum {\r\n    STBI__F_none = 0,\r\n    STBI__F_sub = 1,\r\n    STBI__F_up = 2,\r\n    STBI__F_avg = 3,\r\n    STBI__F_paeth = 4,\r\n    // synthetic filters used for first scanline to avoid needing a dummy row of 0s\r\n    STBI__F_avg_first,\r\n    STBI__F_paeth_first\r\n};\r\n\r\nstatic stbi_uc first_row_filter[5] =\r\n{\r\n   STBI__F_none,\r\n   STBI__F_sub,\r\n   STBI__F_none,\r\n   STBI__F_avg_first,\r\n   STBI__F_paeth_first\r\n};\r\n\r\nstatic int stbi__paeth(int a, int b, int c)\r\n{\r\n    int p = a + b - c;\r\n    int pa = abs(p - a);\r\n    int pb = abs(p - b);\r\n    int pc = abs(p - c);\r\n    if (pa <= pb && pa <= pc) return a;\r\n    if (pb <= pc) return b;\r\n    return c;\r\n}\r\n\r\nstatic const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };\r\n\r\n// create the png data from post-deflated data\r\nstatic int stbi__create_png_image_raw(stbi__png* a, stbi_uc* raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)\r\n{\r\n    int bytes = (depth == 16 ? 2 : 1);\r\n    stbi__context* s = a->s;\r\n    stbi__uint32 i, j, stride = x * out_n * bytes;\r\n    stbi__uint32 img_len, img_width_bytes;\r\n    int k;\r\n    int img_n = s->img_n; // copy it into a local for later\r\n\r\n    int output_bytes = out_n * bytes;\r\n    int filter_bytes = img_n * bytes;\r\n    int width = x;\r\n\r\n    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);\r\n    a->out = (stbi_uc*)stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into\r\n    if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\r\n\r\n    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(\"too large\", \"Corrupt PNG\");\r\n    img_width_bytes = (((img_n * x * depth) + 7) >> 3);\r\n    img_len = (img_width_bytes + 1) * y;\r\n\r\n    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,\r\n    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),\r\n    // so just check for raw_len < img_len always.\r\n    if (raw_len < img_len) return stbi__err(\"not enough pixels\", \"Corrupt PNG\");\r\n\r\n    for (j = 0; j < y; ++j) {\r\n        stbi_uc* cur = a->out + stride * j;\r\n        stbi_uc* prior;\r\n        int filter = *raw++;\r\n\r\n        if (filter > 4)\r\n            return stbi__err(\"invalid filter\", \"Corrupt PNG\");\r\n\r\n        if (depth < 8) {\r\n            if (img_width_bytes > x) return stbi__err(\"invalid width\", \"Corrupt PNG\");\r\n            cur += x * out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place\r\n            filter_bytes = 1;\r\n            width = img_width_bytes;\r\n        }\r\n        prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above\r\n\r\n        // if first row, use special filter that doesn't sample previous row\r\n        if (j == 0) filter = first_row_filter[filter];\r\n\r\n        // handle first byte explicitly\r\n        for (k = 0; k < filter_bytes; ++k) {\r\n            switch (filter) {\r\n            case STBI__F_none: cur[k] = raw[k]; break;\r\n            case STBI__F_sub: cur[k] = raw[k]; break;\r\n            case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\r\n            case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;\r\n            case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;\r\n            case STBI__F_avg_first: cur[k] = raw[k]; break;\r\n            case STBI__F_paeth_first: cur[k] = raw[k]; break;\r\n            }\r\n        }\r\n\r\n        if (depth == 8) {\r\n            if (img_n != out_n)\r\n                cur[img_n] = 255; // first pixel\r\n            raw += img_n;\r\n            cur += out_n;\r\n            prior += out_n;\r\n        }\r\n        else if (depth == 16) {\r\n            if (img_n != out_n) {\r\n                cur[filter_bytes] = 255; // first pixel top byte\r\n                cur[filter_bytes + 1] = 255; // first pixel bottom byte\r\n            }\r\n            raw += filter_bytes;\r\n            cur += output_bytes;\r\n            prior += output_bytes;\r\n        }\r\n        else {\r\n            raw += 1;\r\n            cur += 1;\r\n            prior += 1;\r\n        }\r\n\r\n        // this is a little gross, so that we don't switch per-pixel or per-component\r\n        if (depth < 8 || img_n == out_n) {\r\n            int nk = (width - 1) * filter_bytes;\r\n#define STBI__CASE(f) \\\r\n             case f:     \\\r\n                for (k=0; k < nk; ++k)\r\n            switch (filter) {\r\n                // \"none\" filter turns into a memcpy here; make that explicit.\r\n            case STBI__F_none:         memcpy(cur, raw, nk); break;\r\n                STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); } break;\r\n                STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\r\n                STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); } break;\r\n                STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); } break;\r\n                STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); } break;\r\n                STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); } break;\r\n            }\r\n#undef STBI__CASE\r\n            raw += nk;\r\n        }\r\n        else {\r\n            STBI_ASSERT(img_n + 1 == out_n);\r\n#define STBI__CASE(f) \\\r\n             case f:     \\\r\n                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \\\r\n                   for (k=0; k < filter_bytes; ++k)\r\n            switch (filter) {\r\n                STBI__CASE(STBI__F_none) { cur[k] = raw[k]; } break;\r\n                STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - output_bytes]); } break;\r\n                STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\r\n                STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)); } break;\r\n                STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes])); } break;\r\n                STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - output_bytes] >> 1)); } break;\r\n                STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0)); } break;\r\n            }\r\n#undef STBI__CASE\r\n\r\n            // the loop above sets the high byte of the pixels' alpha, but for\r\n            // 16 bit png files we also need the low byte set. we'll do that here.\r\n            if (depth == 16) {\r\n                cur = a->out + stride * j; // start at the beginning of the row again\r\n                for (i = 0; i < x; ++i, cur += output_bytes) {\r\n                    cur[filter_bytes + 1] = 255;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // we make a separate pass to expand bits to pixels; for performance,\r\n    // this could run two scanlines behind the above code, so it won't\r\n    // intefere with filtering but will still be in the cache.\r\n    if (depth < 8) {\r\n        for (j = 0; j < y; ++j) {\r\n            stbi_uc* cur = a->out + stride * j;\r\n            stbi_uc* in = a->out + stride * j + x * out_n - img_width_bytes;\r\n            // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit\r\n            // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop\r\n            stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range\r\n\r\n            // note that the final byte might overshoot and write more data than desired.\r\n            // we can allocate enough data that this never writes out of memory, but it\r\n            // could also overwrite the next scanline. can it overwrite non-empty data\r\n            // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.\r\n            // so we need to explicitly clamp the final ones\r\n\r\n            if (depth == 4) {\r\n                for (k = x * img_n; k >= 2; k -= 2, ++in) {\r\n                    *cur++ = scale * ((*in >> 4));\r\n                    *cur++ = scale * ((*in) & 0x0f);\r\n                }\r\n                if (k > 0) *cur++ = scale * ((*in >> 4));\r\n            }\r\n            else if (depth == 2) {\r\n                for (k = x * img_n; k >= 4; k -= 4, ++in) {\r\n                    *cur++ = scale * ((*in >> 6));\r\n                    *cur++ = scale * ((*in >> 4) & 0x03);\r\n                    *cur++ = scale * ((*in >> 2) & 0x03);\r\n                    *cur++ = scale * ((*in) & 0x03);\r\n                }\r\n                if (k > 0) *cur++ = scale * ((*in >> 6));\r\n                if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);\r\n                if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);\r\n            }\r\n            else if (depth == 1) {\r\n                for (k = x * img_n; k >= 8; k -= 8, ++in) {\r\n                    *cur++ = scale * ((*in >> 7));\r\n                    *cur++ = scale * ((*in >> 6) & 0x01);\r\n                    *cur++ = scale * ((*in >> 5) & 0x01);\r\n                    *cur++ = scale * ((*in >> 4) & 0x01);\r\n                    *cur++ = scale * ((*in >> 3) & 0x01);\r\n                    *cur++ = scale * ((*in >> 2) & 0x01);\r\n                    *cur++ = scale * ((*in >> 1) & 0x01);\r\n                    *cur++ = scale * ((*in) & 0x01);\r\n                }\r\n                if (k > 0) *cur++ = scale * ((*in >> 7));\r\n                if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);\r\n                if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);\r\n                if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);\r\n                if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);\r\n                if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);\r\n                if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);\r\n            }\r\n            if (img_n != out_n) {\r\n                int q;\r\n                // insert alpha = 255\r\n                cur = a->out + stride * j;\r\n                if (img_n == 1) {\r\n                    for (q = x - 1; q >= 0; --q) {\r\n                        cur[q * 2 + 1] = 255;\r\n                        cur[q * 2 + 0] = cur[q];\r\n                    }\r\n                }\r\n                else {\r\n                    STBI_ASSERT(img_n == 3);\r\n                    for (q = x - 1; q >= 0; --q) {\r\n                        cur[q * 4 + 3] = 255;\r\n                        cur[q * 4 + 2] = cur[q * 3 + 2];\r\n                        cur[q * 4 + 1] = cur[q * 3 + 1];\r\n                        cur[q * 4 + 0] = cur[q * 3 + 0];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (depth == 16) {\r\n        // force the image data from big-endian to platform-native.\r\n        // this is done in a separate pass due to the decoding relying\r\n        // on the data being untouched, but could probably be done\r\n        // per-line during decode if care is taken.\r\n        stbi_uc* cur = a->out;\r\n        stbi__uint16* cur16 = (stbi__uint16*)cur;\r\n\r\n        for (i = 0; i < x * y * out_n; ++i, cur16++, cur += 2) {\r\n            *cur16 = (cur[0] << 8) | cur[1];\r\n        }\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__create_png_image(stbi__png* a, stbi_uc* image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)\r\n{\r\n    int bytes = (depth == 16 ? 2 : 1);\r\n    int out_bytes = out_n * bytes;\r\n    stbi_uc* final;\r\n    int p;\r\n    if (!interlaced)\r\n        return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);\r\n\r\n    // de-interlacing\r\n    final = (stbi_uc*)stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);\r\n    if (!final) return stbi__err(\"outofmem\", \"Out of memory\");\r\n    for (p = 0; p < 7; ++p) {\r\n        int xorig[] = { 0,4,0,2,0,1,0 };\r\n        int yorig[] = { 0,0,4,0,2,0,1 };\r\n        int xspc[] = { 8,8,4,4,2,2,1 };\r\n        int yspc[] = { 8,8,8,4,4,2,2 };\r\n        int i, j, x, y;\r\n        // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\r\n        x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];\r\n        y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];\r\n        if (x && y) {\r\n            stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;\r\n            if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {\r\n                STBI_FREE(final);\r\n                return 0;\r\n            }\r\n            for (j = 0; j < y; ++j) {\r\n                for (i = 0; i < x; ++i) {\r\n                    int out_y = j * yspc[p] + yorig[p];\r\n                    int out_x = i * xspc[p] + xorig[p];\r\n                    memcpy(final + out_y * a->s->img_x * out_bytes + out_x * out_bytes,\r\n                        a->out + (j * x + i) * out_bytes, out_bytes);\r\n                }\r\n            }\r\n            STBI_FREE(a->out);\r\n            image_data += img_len;\r\n            image_data_len -= img_len;\r\n        }\r\n    }\r\n    a->out = final;\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__compute_transparency(stbi__png* z, stbi_uc tc[3], int out_n)\r\n{\r\n    stbi__context* s = z->s;\r\n    stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n    stbi_uc* p = z->out;\r\n\r\n    // compute color-based transparency, assuming we've\r\n    // already got 255 as the alpha value in the output\r\n    STBI_ASSERT(out_n == 2 || out_n == 4);\r\n\r\n    if (out_n == 2) {\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            p[1] = (p[0] == tc[0] ? 0 : 255);\r\n            p += 2;\r\n        }\r\n    }\r\n    else {\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\r\n                p[3] = 0;\r\n            p += 4;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__compute_transparency16(stbi__png* z, stbi__uint16 tc[3], int out_n)\r\n{\r\n    stbi__context* s = z->s;\r\n    stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n    stbi__uint16* p = (stbi__uint16*)z->out;\r\n\r\n    // compute color-based transparency, assuming we've\r\n    // already got 65535 as the alpha value in the output\r\n    STBI_ASSERT(out_n == 2 || out_n == 4);\r\n\r\n    if (out_n == 2) {\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            p[1] = (p[0] == tc[0] ? 0 : 65535);\r\n            p += 2;\r\n        }\r\n    }\r\n    else {\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\r\n                p[3] = 0;\r\n            p += 4;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__expand_png_palette(stbi__png* a, stbi_uc* palette, int len, int pal_img_n)\r\n{\r\n    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\r\n    stbi_uc* p, * temp_out, * orig = a->out;\r\n\r\n    p = (stbi_uc*)stbi__malloc_mad2(pixel_count, pal_img_n, 0);\r\n    if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n\r\n    // between here and free(out) below, exitting would leak\r\n    temp_out = p;\r\n\r\n    if (pal_img_n == 3) {\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            int n = orig[i] * 4;\r\n            p[0] = palette[n];\r\n            p[1] = palette[n + 1];\r\n            p[2] = palette[n + 2];\r\n            p += 3;\r\n        }\r\n    }\r\n    else {\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            int n = orig[i] * 4;\r\n            p[0] = palette[n];\r\n            p[1] = palette[n + 1];\r\n            p[2] = palette[n + 2];\r\n            p[3] = palette[n + 3];\r\n            p += 4;\r\n        }\r\n    }\r\n    STBI_FREE(a->out);\r\n    a->out = temp_out;\r\n\r\n    STBI_NOTUSED(len);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__unpremultiply_on_load_global = 0;\r\nstatic int stbi__de_iphone_flag_global = 0;\r\n\r\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\r\n{\r\n    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;\r\n}\r\n\r\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\r\n{\r\n    stbi__de_iphone_flag_global = flag_true_if_should_convert;\r\n}\r\n\r\n#ifndef STBI_THREAD_LOCAL\r\n#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global\r\n#define stbi__de_iphone_flag  stbi__de_iphone_flag_global\r\n#else\r\nstatic STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;\r\nstatic STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;\r\n\r\nSTBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)\r\n{\r\n    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;\r\n    stbi__unpremultiply_on_load_set = 1;\r\n}\r\n\r\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)\r\n{\r\n    stbi__de_iphone_flag_local = flag_true_if_should_convert;\r\n    stbi__de_iphone_flag_set = 1;\r\n}\r\n\r\n#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \\\r\n                                       ? stbi__unpremultiply_on_load_local      \\\r\n                                       : stbi__unpremultiply_on_load_global)\r\n#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \\\r\n                                ? stbi__de_iphone_flag_local                    \\\r\n                                : stbi__de_iphone_flag_global)\r\n#endif // STBI_THREAD_LOCAL\r\n\r\nstatic void stbi__de_iphone(stbi__png* z)\r\n{\r\n    stbi__context* s = z->s;\r\n    stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n    stbi_uc* p = z->out;\r\n\r\n    if (s->img_out_n == 3) {  // convert bgr to rgb\r\n        for (i = 0; i < pixel_count; ++i) {\r\n            stbi_uc t = p[0];\r\n            p[0] = p[2];\r\n            p[2] = t;\r\n            p += 3;\r\n        }\r\n    }\r\n    else {\r\n        STBI_ASSERT(s->img_out_n == 4);\r\n        if (stbi__unpremultiply_on_load) {\r\n            // convert bgr to rgb and unpremultiply\r\n            for (i = 0; i < pixel_count; ++i) {\r\n                stbi_uc a = p[3];\r\n                stbi_uc t = p[0];\r\n                if (a) {\r\n                    stbi_uc half = a / 2;\r\n                    p[0] = (p[2] * 255 + half) / a;\r\n                    p[1] = (p[1] * 255 + half) / a;\r\n                    p[2] = (t * 255 + half) / a;\r\n                }\r\n                else {\r\n                    p[0] = p[2];\r\n                    p[2] = t;\r\n                }\r\n                p += 4;\r\n            }\r\n        }\r\n        else {\r\n            // convert bgr to rgb\r\n            for (i = 0; i < pixel_count; ++i) {\r\n                stbi_uc t = p[0];\r\n                p[0] = p[2];\r\n                p[2] = t;\r\n                p += 4;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))\r\n\r\nstatic int stbi__parse_png_file(stbi__png* z, int scan, int req_comp)\r\n{\r\n    stbi_uc palette[1024], pal_img_n = 0;\r\n    stbi_uc has_trans = 0, tc[3] = { 0 };\r\n    stbi__uint16 tc16[3];\r\n    stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;\r\n    int first = 1, k, interlace = 0, color = 0, is_iphone = 0;\r\n    stbi__context* s = z->s;\r\n\r\n    z->expanded = NULL;\r\n    z->idata = NULL;\r\n    z->out = NULL;\r\n\r\n    if (!stbi__check_png_header(s)) return 0;\r\n\r\n    if (scan == STBI__SCAN_type) return 1;\r\n\r\n    for (;;) {\r\n        stbi__pngchunk c = stbi__get_chunk_header(s);\r\n        switch (c.type) {\r\n        case STBI__PNG_TYPE('C', 'g', 'B', 'I'):\r\n            is_iphone = 1;\r\n            stbi__skip(s, c.length);\r\n            break;\r\n        case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {\r\n            int comp, filter;\r\n            if (!first) return stbi__err(\"multiple IHDR\", \"Corrupt PNG\");\r\n            first = 0;\r\n            if (c.length != 13) return stbi__err(\"bad IHDR len\", \"Corrupt PNG\");\r\n            s->img_x = stbi__get32be(s);\r\n            s->img_y = stbi__get32be(s);\r\n            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\", \"Very large image (corrupt?)\");\r\n            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\", \"Very large image (corrupt?)\");\r\n            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(\"1/2/4/8/16-bit only\", \"PNG not supported: 1/2/4/8/16-bit only\");\r\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\", \"Corrupt PNG\");\r\n            if (color == 3 && z->depth == 16)                  return stbi__err(\"bad ctype\", \"Corrupt PNG\");\r\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\", \"Corrupt PNG\");\r\n            comp = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\", \"Corrupt PNG\");\r\n            filter = stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\", \"Corrupt PNG\");\r\n            interlace = stbi__get8(s); if (interlace > 1) return stbi__err(\"bad interlace method\", \"Corrupt PNG\");\r\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\", \"Corrupt PNG\");\r\n            if (!pal_img_n) {\r\n                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\r\n                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\r\n            }\r\n            else {\r\n                // if paletted, then pal_n is our final components, and\r\n                // img_n is # components to decompress/filter.\r\n                s->img_n = 1;\r\n                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\", \"Corrupt PNG\");\r\n            }\r\n            // even with SCAN_header, have to scan to see if we have a tRNS\r\n            break;\r\n        }\r\n\r\n        case STBI__PNG_TYPE('P', 'L', 'T', 'E'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (c.length > 256 * 3) return stbi__err(\"invalid PLTE\", \"Corrupt PNG\");\r\n            pal_len = c.length / 3;\r\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\", \"Corrupt PNG\");\r\n            for (i = 0; i < pal_len; ++i) {\r\n                palette[i * 4 + 0] = stbi__get8(s);\r\n                palette[i * 4 + 1] = stbi__get8(s);\r\n                palette[i * 4 + 2] = stbi__get8(s);\r\n                palette[i * 4 + 3] = 255;\r\n            }\r\n            break;\r\n        }\r\n\r\n        case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (z->idata) return stbi__err(\"tRNS after IDAT\", \"Corrupt PNG\");\r\n            if (pal_img_n) {\r\n                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }\r\n                if (pal_len == 0) return stbi__err(\"tRNS before PLTE\", \"Corrupt PNG\");\r\n                if (c.length > pal_len) return stbi__err(\"bad tRNS len\", \"Corrupt PNG\");\r\n                pal_img_n = 4;\r\n                for (i = 0; i < c.length; ++i)\r\n                    palette[i * 4 + 3] = stbi__get8(s);\r\n            }\r\n            else {\r\n                if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\", \"Corrupt PNG\");\r\n                if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err(\"bad tRNS len\", \"Corrupt PNG\");\r\n                has_trans = 1;\r\n                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.\r\n                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }\r\n                if (z->depth == 16) {\r\n                    for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is\r\n                }\r\n                else {\r\n                    for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\", \"Corrupt PNG\");\r\n            if (scan == STBI__SCAN_header) {\r\n                // header scan definitely stops at first IDAT\r\n                if (pal_img_n)\r\n                    s->img_n = pal_img_n;\r\n                return 1;\r\n            }\r\n            if (c.length > (1u << 30)) return stbi__err(\"IDAT size limit\", \"IDAT section larger than 2^30 bytes\");\r\n            if ((int)(ioff + c.length) < (int)ioff) return 0;\r\n            if (ioff + c.length > idata_limit) {\r\n                stbi__uint32 idata_limit_old = idata_limit;\r\n                stbi_uc* p;\r\n                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\r\n                while (ioff + c.length > idata_limit)\r\n                    idata_limit *= 2;\r\n                STBI_NOTUSED(idata_limit_old);\r\n                p = (stbi_uc*)STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n                z->idata = p;\r\n            }\r\n            if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err(\"outofdata\", \"Corrupt PNG\");\r\n            ioff += c.length;\r\n            break;\r\n        }\r\n\r\n        case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {\r\n            stbi__uint32 raw_len, bpl;\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (scan != STBI__SCAN_load) return 1;\r\n            if (z->idata == NULL) return stbi__err(\"no IDAT\", \"Corrupt PNG\");\r\n            // initial guess for decoded data size to avoid unnecessary reallocs\r\n            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component\r\n            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;\r\n            z->expanded = (stbi_uc*)stbi_zlib_decode_malloc_guesssize_headerflag((char*)z->idata, ioff, raw_len, (int*)&raw_len, !is_iphone);\r\n            if (z->expanded == NULL) return 0; // zlib should set error\r\n            STBI_FREE(z->idata); z->idata = NULL;\r\n            if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)\r\n                s->img_out_n = s->img_n + 1;\r\n            else\r\n                s->img_out_n = s->img_n;\r\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;\r\n            if (has_trans) {\r\n                if (z->depth == 16) {\r\n                    if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;\r\n                }\r\n                else {\r\n                    if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\r\n                }\r\n            }\r\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\r\n                stbi__de_iphone(z);\r\n            if (pal_img_n) {\r\n                // pal_img_n == 3 or 4\r\n                s->img_n = pal_img_n; // record the actual colors we had\r\n                s->img_out_n = pal_img_n;\r\n                if (req_comp >= 3) s->img_out_n = req_comp;\r\n                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\r\n                    return 0;\r\n            }\r\n            else if (has_trans) {\r\n                // non-paletted image with tRNS -> source image has (constant) alpha\r\n                ++s->img_n;\r\n            }\r\n            STBI_FREE(z->expanded); z->expanded = NULL;\r\n            // end of PNG chunk, read and skip CRC\r\n            stbi__get32be(s);\r\n            return 1;\r\n        }\r\n\r\n        default:\r\n            // if critical, fail\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if ((c.type & (1 << 29)) == 0) {\r\n#ifndef STBI_NO_FAILURE_STRINGS\r\n                // not threadsafe\r\n                static char invalid_chunk[] = \"XXXX PNG chunk not known\";\r\n                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\r\n                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\r\n                invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);\r\n                invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);\r\n#endif\r\n                return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\r\n            }\r\n            stbi__skip(s, c.length);\r\n            break;\r\n        }\r\n        // end of PNG chunk, read and skip CRC\r\n        stbi__get32be(s);\r\n    }\r\n}\r\n\r\nstatic void* stbi__do_png(stbi__png* p, int* x, int* y, int* n, int req_comp, stbi__result_info* ri)\r\n{\r\n    void* result = NULL;\r\n    if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\r\n    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {\r\n        if (p->depth <= 8)\r\n            ri->bits_per_channel = 8;\r\n        else if (p->depth == 16)\r\n            ri->bits_per_channel = 16;\r\n        else\r\n            return stbi__errpuc(\"bad bits_per_channel\", \"PNG not supported: unsupported color depth\");\r\n        result = p->out;\r\n        p->out = NULL;\r\n        if (req_comp && req_comp != p->s->img_out_n) {\r\n            if (ri->bits_per_channel == 8)\r\n                result = stbi__convert_format((unsigned char*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\r\n            else\r\n                result = stbi__convert_format16((stbi__uint16*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\r\n            p->s->img_out_n = req_comp;\r\n            if (result == NULL) return result;\r\n        }\r\n        *x = p->s->img_x;\r\n        *y = p->s->img_y;\r\n        if (n) *n = p->s->img_n;\r\n    }\r\n    STBI_FREE(p->out);      p->out = NULL;\r\n    STBI_FREE(p->expanded); p->expanded = NULL;\r\n    STBI_FREE(p->idata);    p->idata = NULL;\r\n\r\n    return result;\r\n}\r\n\r\nstatic void* stbi__png_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    stbi__png p;\r\n    p.s = s;\r\n    return stbi__do_png(&p, x, y, comp, req_comp, ri);\r\n}\r\n\r\nstatic int stbi__png_test(stbi__context* s)\r\n{\r\n    int r;\r\n    r = stbi__check_png_header(s);\r\n    stbi__rewind(s);\r\n    return r;\r\n}\r\n\r\nstatic int stbi__png_info_raw(stbi__png* p, int* x, int* y, int* comp)\r\n{\r\n    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {\r\n        stbi__rewind(p->s);\r\n        return 0;\r\n    }\r\n    if (x) *x = p->s->img_x;\r\n    if (y) *y = p->s->img_y;\r\n    if (comp) *comp = p->s->img_n;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__png_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    stbi__png p;\r\n    p.s = s;\r\n    return stbi__png_info_raw(&p, x, y, comp);\r\n}\r\n\r\nstatic int stbi__png_is16(stbi__context* s)\r\n{\r\n    stbi__png p;\r\n    p.s = s;\r\n    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))\r\n        return 0;\r\n    if (p.depth != 16) {\r\n        stbi__rewind(p.s);\r\n        return 0;\r\n    }\r\n    return 1;\r\n}\r\n#endif\r\n\r\n// Microsoft/Windows BMP image\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int stbi__bmp_test_raw(stbi__context* s)\r\n{\r\n    int r;\r\n    int sz;\r\n    if (stbi__get8(s) != 'B') return 0;\r\n    if (stbi__get8(s) != 'M') return 0;\r\n    stbi__get32le(s); // discard filesize\r\n    stbi__get16le(s); // discard reserved\r\n    stbi__get16le(s); // discard reserved\r\n    stbi__get32le(s); // discard data offset\r\n    sz = stbi__get32le(s);\r\n    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\r\n    return r;\r\n}\r\n\r\nstatic int stbi__bmp_test(stbi__context* s)\r\n{\r\n    int r = stbi__bmp_test_raw(s);\r\n    stbi__rewind(s);\r\n    return r;\r\n}\r\n\r\n\r\n// returns 0..31 for the highest set bit\r\nstatic int stbi__high_bit(unsigned int z)\r\n{\r\n    int n = 0;\r\n    if (z == 0) return -1;\r\n    if (z >= 0x10000) { n += 16; z >>= 16; }\r\n    if (z >= 0x00100) { n += 8; z >>= 8; }\r\n    if (z >= 0x00010) { n += 4; z >>= 4; }\r\n    if (z >= 0x00004) { n += 2; z >>= 2; }\r\n    if (z >= 0x00002) { n += 1;/* >>=  1;*/ }\r\n    return n;\r\n}\r\n\r\nstatic int stbi__bitcount(unsigned int a)\r\n{\r\n    a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2\r\n    a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4\r\n    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\r\n    a = (a + (a >> 8)); // max 16 per 8 bits\r\n    a = (a + (a >> 16)); // max 32 per 8 bits\r\n    return a & 0xff;\r\n}\r\n\r\n// extract an arbitrarily-aligned N-bit value (N=bits)\r\n// from v, and then make it 8-bits long and fractionally\r\n// extend it to full full range.\r\nstatic int stbi__shiftsigned(unsigned int v, int shift, int bits)\r\n{\r\n    static unsigned int mul_table[9] = {\r\n       0,\r\n       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,\r\n       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,\r\n    };\r\n    static unsigned int shift_table[9] = {\r\n       0, 0,0,1,0,2,4,6,0,\r\n    };\r\n    if (shift < 0)\r\n        v <<= -shift;\r\n    else\r\n        v >>= shift;\r\n    STBI_ASSERT(v < 256);\r\n    v >>= (8 - bits);\r\n    STBI_ASSERT(bits >= 0 && bits <= 8);\r\n    return (int)((unsigned)v * mul_table[bits]) >> shift_table[bits];\r\n}\r\n\r\ntypedef struct\r\n{\r\n    int bpp, offset, hsz;\r\n    unsigned int mr, mg, mb, ma, all_a;\r\n    int extra_read;\r\n} stbi__bmp_data;\r\n\r\nstatic int stbi__bmp_set_mask_defaults(stbi__bmp_data* info, int compress)\r\n{\r\n    // BI_BITFIELDS specifies masks explicitly, don't override\r\n    if (compress == 3)\r\n        return 1;\r\n\r\n    if (compress == 0) {\r\n        if (info->bpp == 16) {\r\n            info->mr = 31u << 10;\r\n            info->mg = 31u << 5;\r\n            info->mb = 31u << 0;\r\n        }\r\n        else if (info->bpp == 32) {\r\n            info->mr = 0xffu << 16;\r\n            info->mg = 0xffu << 8;\r\n            info->mb = 0xffu << 0;\r\n            info->ma = 0xffu << 24;\r\n            info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0\r\n        }\r\n        else {\r\n            // otherwise, use defaults, which is all-0\r\n            info->mr = info->mg = info->mb = info->ma = 0;\r\n        }\r\n        return 1;\r\n    }\r\n    return 0; // error\r\n}\r\n\r\nstatic void* stbi__bmp_parse_header(stbi__context* s, stbi__bmp_data* info)\r\n{\r\n    int hsz;\r\n    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\r\n    stbi__get32le(s); // discard filesize\r\n    stbi__get16le(s); // discard reserved\r\n    stbi__get16le(s); // discard reserved\r\n    info->offset = stbi__get32le(s);\r\n    info->hsz = hsz = stbi__get32le(s);\r\n    info->mr = info->mg = info->mb = info->ma = 0;\r\n    info->extra_read = 14;\r\n\r\n    if (info->offset < 0) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n\r\n    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\r\n    if (hsz == 12) {\r\n        s->img_x = stbi__get16le(s);\r\n        s->img_y = stbi__get16le(s);\r\n    }\r\n    else {\r\n        s->img_x = stbi__get32le(s);\r\n        s->img_y = stbi__get32le(s);\r\n    }\r\n    if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n    info->bpp = stbi__get16le(s);\r\n    if (hsz != 12) {\r\n        int compress = stbi__get32le(s);\r\n        if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\r\n        if (compress >= 4) return stbi__errpuc(\"BMP JPEG/PNG\", \"BMP type not supported: unsupported compression\"); // this includes PNG/JPEG modes\r\n        if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(\"bad BMP\", \"bad BMP\"); // bitfields requires 16 or 32 bits/pixel\r\n        stbi__get32le(s); // discard sizeof\r\n        stbi__get32le(s); // discard hres\r\n        stbi__get32le(s); // discard vres\r\n        stbi__get32le(s); // discard colorsused\r\n        stbi__get32le(s); // discard max important\r\n        if (hsz == 40 || hsz == 56) {\r\n            if (hsz == 56) {\r\n                stbi__get32le(s);\r\n                stbi__get32le(s);\r\n                stbi__get32le(s);\r\n                stbi__get32le(s);\r\n            }\r\n            if (info->bpp == 16 || info->bpp == 32) {\r\n                if (compress == 0) {\r\n                    stbi__bmp_set_mask_defaults(info, compress);\r\n                }\r\n                else if (compress == 3) {\r\n                    info->mr = stbi__get32le(s);\r\n                    info->mg = stbi__get32le(s);\r\n                    info->mb = stbi__get32le(s);\r\n                    info->extra_read += 12;\r\n                    // not documented, but generated by photoshop and handled by mspaint\r\n                    if (info->mr == info->mg && info->mg == info->mb) {\r\n                        // ?!?!?\r\n                        return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n                    }\r\n                }\r\n                else\r\n                    return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n            }\r\n        }\r\n        else {\r\n            // V4/V5 header\r\n            int i;\r\n            if (hsz != 108 && hsz != 124)\r\n                return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n            info->mr = stbi__get32le(s);\r\n            info->mg = stbi__get32le(s);\r\n            info->mb = stbi__get32le(s);\r\n            info->ma = stbi__get32le(s);\r\n            if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs\r\n                stbi__bmp_set_mask_defaults(info, compress);\r\n            stbi__get32le(s); // discard color space\r\n            for (i = 0; i < 12; ++i)\r\n                stbi__get32le(s); // discard color space parameters\r\n            if (hsz == 124) {\r\n                stbi__get32le(s); // discard rendering intent\r\n                stbi__get32le(s); // discard offset of profile data\r\n                stbi__get32le(s); // discard size of profile data\r\n                stbi__get32le(s); // discard reserved\r\n            }\r\n        }\r\n    }\r\n    return (void*)1;\r\n}\r\n\r\n\r\nstatic void* stbi__bmp_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    stbi_uc* out;\r\n    unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a;\r\n    stbi_uc pal[256][4];\r\n    int psize = 0, i, j, width;\r\n    int flip_vertically, pad, target;\r\n    stbi__bmp_data info;\r\n    STBI_NOTUSED(ri);\r\n\r\n    info.all_a = 255;\r\n    if (stbi__bmp_parse_header(s, &info) == NULL)\r\n        return NULL; // error code already set\r\n\r\n    flip_vertically = ((int)s->img_y) > 0;\r\n    s->img_y = abs((int)s->img_y);\r\n\r\n    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    mr = info.mr;\r\n    mg = info.mg;\r\n    mb = info.mb;\r\n    ma = info.ma;\r\n    all_a = info.all_a;\r\n\r\n    if (info.hsz == 12) {\r\n        if (info.bpp < 24)\r\n            psize = (info.offset - info.extra_read - 24) / 3;\r\n    }\r\n    else {\r\n        if (info.bpp < 16)\r\n            psize = (info.offset - info.extra_read - info.hsz) >> 2;\r\n    }\r\n    if (psize == 0) {\r\n        // accept some number of extra bytes after the header, but if the offset points either to before\r\n        // the header ends or implies a large amount of extra data, reject the file as malformed\r\n        int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);\r\n        int header_limit = 1024; // max we actually read is below 256 bytes currently.\r\n        int extra_data_limit = 256 * 4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.\r\n        if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {\r\n            return stbi__errpuc(\"bad header\", \"Corrupt BMP\");\r\n        }\r\n        // we established that bytes_read_so_far is positive and sensible.\r\n        // the first half of this test rejects offsets that are either too small positives, or\r\n        // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn\r\n        // ensures the number computed in the second half of the test can't overflow.\r\n        if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {\r\n            return stbi__errpuc(\"bad offset\", \"Corrupt BMP\");\r\n        }\r\n        else {\r\n            stbi__skip(s, info.offset - bytes_read_so_far);\r\n        }\r\n    }\r\n\r\n    if (info.bpp == 24 && ma == 0xff000000)\r\n        s->img_n = 3;\r\n    else\r\n        s->img_n = ma ? 4 : 3;\r\n    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\r\n        target = req_comp;\r\n    else\r\n        target = s->img_n; // if they want monochrome, we'll post-convert\r\n\r\n     // sanity-check size\r\n    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))\r\n        return stbi__errpuc(\"too large\", \"Corrupt BMP\");\r\n\r\n    out = (stbi_uc*)stbi__malloc_mad3(target, s->img_x, s->img_y, 0);\r\n    if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    if (info.bpp < 16) {\r\n        int z = 0;\r\n        if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\r\n        for (i = 0; i < psize; ++i) {\r\n            pal[i][2] = stbi__get8(s);\r\n            pal[i][1] = stbi__get8(s);\r\n            pal[i][0] = stbi__get8(s);\r\n            if (info.hsz != 12) stbi__get8(s);\r\n            pal[i][3] = 255;\r\n        }\r\n        stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));\r\n        if (info.bpp == 1) width = (s->img_x + 7) >> 3;\r\n        else if (info.bpp == 4) width = (s->img_x + 1) >> 1;\r\n        else if (info.bpp == 8) width = s->img_x;\r\n        else { STBI_FREE(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\r\n        pad = (-width) & 3;\r\n        if (info.bpp == 1) {\r\n            for (j = 0; j < (int)s->img_y; ++j) {\r\n                int bit_offset = 7, v = stbi__get8(s);\r\n                for (i = 0; i < (int)s->img_x; ++i) {\r\n                    int color = (v >> bit_offset) & 0x1;\r\n                    out[z++] = pal[color][0];\r\n                    out[z++] = pal[color][1];\r\n                    out[z++] = pal[color][2];\r\n                    if (target == 4) out[z++] = 255;\r\n                    if (i + 1 == (int)s->img_x) break;\r\n                    if ((--bit_offset) < 0) {\r\n                        bit_offset = 7;\r\n                        v = stbi__get8(s);\r\n                    }\r\n                }\r\n                stbi__skip(s, pad);\r\n            }\r\n        }\r\n        else {\r\n            for (j = 0; j < (int)s->img_y; ++j) {\r\n                for (i = 0; i < (int)s->img_x; i += 2) {\r\n                    int v = stbi__get8(s), v2 = 0;\r\n                    if (info.bpp == 4) {\r\n                        v2 = v & 15;\r\n                        v >>= 4;\r\n                    }\r\n                    out[z++] = pal[v][0];\r\n                    out[z++] = pal[v][1];\r\n                    out[z++] = pal[v][2];\r\n                    if (target == 4) out[z++] = 255;\r\n                    if (i + 1 == (int)s->img_x) break;\r\n                    v = (info.bpp == 8) ? stbi__get8(s) : v2;\r\n                    out[z++] = pal[v][0];\r\n                    out[z++] = pal[v][1];\r\n                    out[z++] = pal[v][2];\r\n                    if (target == 4) out[z++] = 255;\r\n                }\r\n                stbi__skip(s, pad);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;\r\n        int z = 0;\r\n        int easy = 0;\r\n        stbi__skip(s, info.offset - info.extra_read - info.hsz);\r\n        if (info.bpp == 24) width = 3 * s->img_x;\r\n        else if (info.bpp == 16) width = 2 * s->img_x;\r\n        else /* bpp = 32 and pad = 0 */ width = 0;\r\n        pad = (-width) & 3;\r\n        if (info.bpp == 24) {\r\n            easy = 1;\r\n        }\r\n        else if (info.bpp == 32) {\r\n            if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\r\n                easy = 2;\r\n        }\r\n        if (!easy) {\r\n            if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\r\n            // right shift amt to put high bit in position #7\r\n            rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);\r\n            gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);\r\n            bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);\r\n            ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);\r\n            if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\r\n        }\r\n        for (j = 0; j < (int)s->img_y; ++j) {\r\n            if (easy) {\r\n                for (i = 0; i < (int)s->img_x; ++i) {\r\n                    unsigned char a;\r\n                    out[z + 2] = stbi__get8(s);\r\n                    out[z + 1] = stbi__get8(s);\r\n                    out[z + 0] = stbi__get8(s);\r\n                    z += 3;\r\n                    a = (easy == 2 ? stbi__get8(s) : 255);\r\n                    all_a |= a;\r\n                    if (target == 4) out[z++] = a;\r\n                }\r\n            }\r\n            else {\r\n                int bpp = info.bpp;\r\n                for (i = 0; i < (int)s->img_x; ++i) {\r\n                    stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));\r\n                    unsigned int a;\r\n                    out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\r\n                    out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\r\n                    out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\r\n                    a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\r\n                    all_a |= a;\r\n                    if (target == 4) out[z++] = STBI__BYTECAST(a);\r\n                }\r\n            }\r\n            stbi__skip(s, pad);\r\n        }\r\n    }\r\n\r\n    // if alpha channel is all 0s, replace with all 255s\r\n    if (target == 4 && all_a == 0)\r\n        for (i = 4 * s->img_x * s->img_y - 1; i >= 0; i -= 4)\r\n            out[i] = 255;\r\n\r\n    if (flip_vertically) {\r\n        stbi_uc t;\r\n        for (j = 0; j < (int)s->img_y >> 1; ++j) {\r\n            stbi_uc* p1 = out + j * s->img_x * target;\r\n            stbi_uc* p2 = out + (s->img_y - 1 - j) * s->img_x * target;\r\n            for (i = 0; i < (int)s->img_x * target; ++i) {\r\n                t = p1[i]; p1[i] = p2[i]; p2[i] = t;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (req_comp && req_comp != target) {\r\n        out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\r\n        if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n    }\r\n\r\n    *x = s->img_x;\r\n    *y = s->img_y;\r\n    if (comp) *comp = s->img_n;\r\n    return out;\r\n}\r\n#endif\r\n\r\n// Targa Truevision - TGA\r\n// by Jonathan Dummer\r\n#ifndef STBI_NO_TGA\r\n// returns STBI_rgb or whatever, 0 on error\r\nstatic int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)\r\n{\r\n    // only RGB or RGBA (incl. 16bit) or grey allowed\r\n    if (is_rgb16) *is_rgb16 = 0;\r\n    switch (bits_per_pixel) {\r\n    case 8:  return STBI_grey;\r\n    case 16: if (is_grey) return STBI_grey_alpha;\r\n        // fallthrough\r\n    case 15: if (is_rgb16) *is_rgb16 = 1;\r\n        return STBI_rgb;\r\n    case 24: // fallthrough\r\n    case 32: return bits_per_pixel / 8;\r\n    default: return 0;\r\n    }\r\n}\r\n\r\nstatic int stbi__tga_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;\r\n    int sz, tga_colormap_type;\r\n    stbi__get8(s);                   // discard Offset\r\n    tga_colormap_type = stbi__get8(s); // colormap type\r\n    if (tga_colormap_type > 1) {\r\n        stbi__rewind(s);\r\n        return 0;      // only RGB or indexed allowed\r\n    }\r\n    tga_image_type = stbi__get8(s); // image type\r\n    if (tga_colormap_type == 1) { // colormapped (paletted) image\r\n        if (tga_image_type != 1 && tga_image_type != 9) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        stbi__skip(s, 4);       // skip index of first colormap entry and number of entries\r\n        sz = stbi__get8(s);    //   check bits per palette color entry\r\n        if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        stbi__skip(s, 4);       // skip image x and y origin\r\n        tga_colormap_bpp = sz;\r\n    }\r\n    else { // \"normal\" image w/o colormap - only RGB or grey allowed, +/- RLE\r\n        if ((tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11)) {\r\n            stbi__rewind(s);\r\n            return 0; // only RGB or grey allowed, +/- RLE\r\n        }\r\n        stbi__skip(s, 9); // skip colormap specification and image x/y origin\r\n        tga_colormap_bpp = 0;\r\n    }\r\n    tga_w = stbi__get16le(s);\r\n    if (tga_w < 1) {\r\n        stbi__rewind(s);\r\n        return 0;   // test width\r\n    }\r\n    tga_h = stbi__get16le(s);\r\n    if (tga_h < 1) {\r\n        stbi__rewind(s);\r\n        return 0;   // test height\r\n    }\r\n    tga_bits_per_pixel = stbi__get8(s); // bits per pixel\r\n    stbi__get8(s); // ignore alpha bits\r\n    if (tga_colormap_bpp != 0) {\r\n        if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {\r\n            // when using a colormap, tga_bits_per_pixel is the size of the indexes\r\n            // I don't think anything but 8 or 16bit indexes makes sense\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);\r\n    }\r\n    else {\r\n        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);\r\n    }\r\n    if (!tga_comp) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if (x) *x = tga_w;\r\n    if (y) *y = tga_h;\r\n    if (comp) *comp = tga_comp;\r\n    return 1;                   // seems to have passed everything\r\n}\r\n\r\nstatic int stbi__tga_test(stbi__context* s)\r\n{\r\n    int res = 0;\r\n    int sz, tga_color_type;\r\n    stbi__get8(s);      //   discard Offset\r\n    tga_color_type = stbi__get8(s);   //   color type\r\n    if (tga_color_type > 1) goto errorEnd;   //   only RGB or indexed allowed\r\n    sz = stbi__get8(s);   //   image type\r\n    if (tga_color_type == 1) { // colormapped (paletted) image\r\n        if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9\r\n        stbi__skip(s, 4);       // skip index of first colormap entry and number of entries\r\n        sz = stbi__get8(s);    //   check bits per palette color entry\r\n        if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;\r\n        stbi__skip(s, 4);       // skip image x and y origin\r\n    }\r\n    else { // \"normal\" image w/o colormap\r\n        if ((sz != 2) && (sz != 3) && (sz != 10) && (sz != 11)) goto errorEnd; // only RGB or grey allowed, +/- RLE\r\n        stbi__skip(s, 9); // skip colormap specification and image x/y origin\r\n    }\r\n    if (stbi__get16le(s) < 1) goto errorEnd;      //   test width\r\n    if (stbi__get16le(s) < 1) goto errorEnd;      //   test height\r\n    sz = stbi__get8(s);   //   bits per pixel\r\n    if ((tga_color_type == 1) && (sz != 8) && (sz != 16)) goto errorEnd; // for colormapped images, bpp is size of an index\r\n    if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;\r\n\r\n    res = 1; // if we got this far, everything's good and we can return 1 instead of 0\r\n\r\nerrorEnd:\r\n    stbi__rewind(s);\r\n    return res;\r\n}\r\n\r\n// read 16bit value and convert to 24bit RGB\r\nstatic void stbi__tga_read_rgb16(stbi__context* s, stbi_uc* out)\r\n{\r\n    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);\r\n    stbi__uint16 fiveBitMask = 31;\r\n    // we have 3 channels with 5bits each\r\n    int r = (px >> 10) & fiveBitMask;\r\n    int g = (px >> 5) & fiveBitMask;\r\n    int b = px & fiveBitMask;\r\n    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later\r\n    out[0] = (stbi_uc)((r * 255) / 31);\r\n    out[1] = (stbi_uc)((g * 255) / 31);\r\n    out[2] = (stbi_uc)((b * 255) / 31);\r\n\r\n    // some people claim that the most significant bit might be used for alpha\r\n    // (possibly if an alpha-bit is set in the \"image descriptor byte\")\r\n    // but that only made 16bit test images completely translucent..\r\n    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.\r\n}\r\n\r\nstatic void* stbi__tga_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    //   read in the TGA header stuff\r\n    int tga_offset = stbi__get8(s);\r\n    int tga_indexed = stbi__get8(s);\r\n    int tga_image_type = stbi__get8(s);\r\n    int tga_is_RLE = 0;\r\n    int tga_palette_start = stbi__get16le(s);\r\n    int tga_palette_len = stbi__get16le(s);\r\n    int tga_palette_bits = stbi__get8(s);\r\n    int tga_x_origin = stbi__get16le(s);\r\n    int tga_y_origin = stbi__get16le(s);\r\n    int tga_width = stbi__get16le(s);\r\n    int tga_height = stbi__get16le(s);\r\n    int tga_bits_per_pixel = stbi__get8(s);\r\n    int tga_comp, tga_rgb16 = 0;\r\n    int tga_inverted = stbi__get8(s);\r\n    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)\r\n    //   image data\r\n    unsigned char* tga_data;\r\n    unsigned char* tga_palette = NULL;\r\n    int i, j;\r\n    unsigned char raw_data[4] = { 0 };\r\n    int RLE_count = 0;\r\n    int RLE_repeating = 0;\r\n    int read_next_pixel = 1;\r\n    STBI_NOTUSED(ri);\r\n    STBI_NOTUSED(tga_x_origin); // @TODO\r\n    STBI_NOTUSED(tga_y_origin); // @TODO\r\n\r\n    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    //   do a tiny bit of precessing\r\n    if (tga_image_type >= 8)\r\n    {\r\n        tga_image_type -= 8;\r\n        tga_is_RLE = 1;\r\n    }\r\n    tga_inverted = 1 - ((tga_inverted >> 5) & 1);\r\n\r\n    //   If I'm paletted, then I'll use the number of bits from the palette\r\n    if (tga_indexed) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);\r\n    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);\r\n\r\n    if (!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency\r\n        return stbi__errpuc(\"bad format\", \"Can't find out TGA pixelformat\");\r\n\r\n    //   tga info\r\n    *x = tga_width;\r\n    *y = tga_height;\r\n    if (comp) *comp = tga_comp;\r\n\r\n    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))\r\n        return stbi__errpuc(\"too large\", \"Corrupt TGA\");\r\n\r\n    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);\r\n    if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n    // skip to the data's starting position (offset usually = 0)\r\n    stbi__skip(s, tga_offset);\r\n\r\n    if (!tga_indexed && !tga_is_RLE && !tga_rgb16) {\r\n        for (i = 0; i < tga_height; ++i) {\r\n            int row = tga_inverted ? tga_height - i - 1 : i;\r\n            stbi_uc* tga_row = tga_data + row * tga_width * tga_comp;\r\n            stbi__getn(s, tga_row, tga_width * tga_comp);\r\n        }\r\n    }\r\n    else {\r\n        //   do I need to load a palette?\r\n        if (tga_indexed)\r\n        {\r\n            if (tga_palette_len == 0) {  /* you have to have at least one entry! */\r\n                STBI_FREE(tga_data);\r\n                return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\r\n            }\r\n\r\n            //   any data to skip? (offset usually = 0)\r\n            stbi__skip(s, tga_palette_start);\r\n            //   load the palette\r\n            tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);\r\n            if (!tga_palette) {\r\n                STBI_FREE(tga_data);\r\n                return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n            }\r\n            if (tga_rgb16) {\r\n                stbi_uc* pal_entry = tga_palette;\r\n                STBI_ASSERT(tga_comp == STBI_rgb);\r\n                for (i = 0; i < tga_palette_len; ++i) {\r\n                    stbi__tga_read_rgb16(s, pal_entry);\r\n                    pal_entry += tga_comp;\r\n                }\r\n            }\r\n            else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {\r\n                STBI_FREE(tga_data);\r\n                STBI_FREE(tga_palette);\r\n                return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\r\n            }\r\n        }\r\n        //   load the data\r\n        for (i = 0; i < tga_width * tga_height; ++i)\r\n        {\r\n            //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\r\n            if (tga_is_RLE)\r\n            {\r\n                if (RLE_count == 0)\r\n                {\r\n                    //   yep, get the next byte as a RLE command\r\n                    int RLE_cmd = stbi__get8(s);\r\n                    RLE_count = 1 + (RLE_cmd & 127);\r\n                    RLE_repeating = RLE_cmd >> 7;\r\n                    read_next_pixel = 1;\r\n                }\r\n                else if (!RLE_repeating)\r\n                {\r\n                    read_next_pixel = 1;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                read_next_pixel = 1;\r\n            }\r\n            //   OK, if I need to read a pixel, do it now\r\n            if (read_next_pixel)\r\n            {\r\n                //   load however much data we did have\r\n                if (tga_indexed)\r\n                {\r\n                    // read in index, then perform the lookup\r\n                    int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);\r\n                    if (pal_idx >= tga_palette_len) {\r\n                        // invalid index\r\n                        pal_idx = 0;\r\n                    }\r\n                    pal_idx *= tga_comp;\r\n                    for (j = 0; j < tga_comp; ++j) {\r\n                        raw_data[j] = tga_palette[pal_idx + j];\r\n                    }\r\n                }\r\n                else if (tga_rgb16) {\r\n                    STBI_ASSERT(tga_comp == STBI_rgb);\r\n                    stbi__tga_read_rgb16(s, raw_data);\r\n                }\r\n                else {\r\n                    //   read in the data raw\r\n                    for (j = 0; j < tga_comp; ++j) {\r\n                        raw_data[j] = stbi__get8(s);\r\n                    }\r\n                }\r\n                //   clear the reading flag for the next pixel\r\n                read_next_pixel = 0;\r\n            } // end of reading a pixel\r\n\r\n            // copy data\r\n            for (j = 0; j < tga_comp; ++j)\r\n                tga_data[i * tga_comp + j] = raw_data[j];\r\n\r\n            //   in case we're in RLE mode, keep counting down\r\n            --RLE_count;\r\n        }\r\n        //   do I need to invert the image?\r\n        if (tga_inverted)\r\n        {\r\n            for (j = 0; j * 2 < tga_height; ++j)\r\n            {\r\n                int index1 = j * tga_width * tga_comp;\r\n                int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\r\n                for (i = tga_width * tga_comp; i > 0; --i)\r\n                {\r\n                    unsigned char temp = tga_data[index1];\r\n                    tga_data[index1] = tga_data[index2];\r\n                    tga_data[index2] = temp;\r\n                    ++index1;\r\n                    ++index2;\r\n                }\r\n            }\r\n        }\r\n        //   clear my palette, if I had one\r\n        if (tga_palette != NULL)\r\n        {\r\n            STBI_FREE(tga_palette);\r\n        }\r\n    }\r\n\r\n    // swap RGB - if the source data was RGB16, it already is in the right order\r\n    if (tga_comp >= 3 && !tga_rgb16)\r\n    {\r\n        unsigned char* tga_pixel = tga_data;\r\n        for (i = 0; i < tga_width * tga_height; ++i)\r\n        {\r\n            unsigned char temp = tga_pixel[0];\r\n            tga_pixel[0] = tga_pixel[2];\r\n            tga_pixel[2] = temp;\r\n            tga_pixel += tga_comp;\r\n        }\r\n    }\r\n\r\n    // convert to target component count\r\n    if (req_comp && req_comp != tga_comp)\r\n        tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\r\n\r\n    //   the things I do to get rid of an error message, and yet keep\r\n    //   Microsoft's C compilers happy... [8^(\r\n    tga_palette_start = tga_palette_len = tga_palette_bits =\r\n        tga_x_origin = tga_y_origin = 0;\r\n    STBI_NOTUSED(tga_palette_start);\r\n    //   OK, done\r\n    return tga_data;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int stbi__psd_test(stbi__context* s)\r\n{\r\n    int r = (stbi__get32be(s) == 0x38425053);\r\n    stbi__rewind(s);\r\n    return r;\r\n}\r\n\r\nstatic int stbi__psd_decode_rle(stbi__context* s, stbi_uc* p, int pixelCount)\r\n{\r\n    int count, nleft, len;\r\n\r\n    count = 0;\r\n    while ((nleft = pixelCount - count) > 0) {\r\n        len = stbi__get8(s);\r\n        if (len == 128) {\r\n            // No-op.\r\n        }\r\n        else if (len < 128) {\r\n            // Copy next len+1 bytes literally.\r\n            len++;\r\n            if (len > nleft) return 0; // corrupt data\r\n            count += len;\r\n            while (len) {\r\n                *p = stbi__get8(s);\r\n                p += 4;\r\n                len--;\r\n            }\r\n        }\r\n        else if (len > 128) {\r\n            stbi_uc   val;\r\n            // Next -len+1 bytes in the dest are replicated from next source byte.\r\n            // (Interpret len as a negative 8-bit int.)\r\n            len = 257 - len;\r\n            if (len > nleft) return 0; // corrupt data\r\n            val = stbi__get8(s);\r\n            count += len;\r\n            while (len) {\r\n                *p = val;\r\n                p += 4;\r\n                len--;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nstatic void* stbi__psd_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri, int bpc)\r\n{\r\n    int pixelCount;\r\n    int channelCount, compression;\r\n    int channel, i;\r\n    int bitdepth;\r\n    int w, h;\r\n    stbi_uc* out;\r\n    STBI_NOTUSED(ri);\r\n\r\n    // Check identifier\r\n    if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\r\n        return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\r\n\r\n    // Check file type version.\r\n    if (stbi__get16be(s) != 1)\r\n        return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\r\n\r\n    // Skip 6 reserved bytes.\r\n    stbi__skip(s, 6);\r\n\r\n    // Read the number of channels (R, G, B, A, etc).\r\n    channelCount = stbi__get16be(s);\r\n    if (channelCount < 0 || channelCount > 16)\r\n        return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\r\n\r\n    // Read the rows and columns of the image.\r\n    h = stbi__get32be(s);\r\n    w = stbi__get32be(s);\r\n\r\n    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    // Make sure the depth is 8 bits.\r\n    bitdepth = stbi__get16be(s);\r\n    if (bitdepth != 8 && bitdepth != 16)\r\n        return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 or 16 bit\");\r\n\r\n    // Make sure the color mode is RGB.\r\n    // Valid options are:\r\n    //   0: Bitmap\r\n    //   1: Grayscale\r\n    //   2: Indexed color\r\n    //   3: RGB color\r\n    //   4: CMYK color\r\n    //   7: Multichannel\r\n    //   8: Duotone\r\n    //   9: Lab color\r\n    if (stbi__get16be(s) != 3)\r\n        return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\r\n\r\n    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\r\n    stbi__skip(s, stbi__get32be(s));\r\n\r\n    // Skip the image resources.  (resolution, pen tool paths, etc)\r\n    stbi__skip(s, stbi__get32be(s));\r\n\r\n    // Skip the reserved data.\r\n    stbi__skip(s, stbi__get32be(s));\r\n\r\n    // Find out if the data is compressed.\r\n    // Known values:\r\n    //   0: no compression\r\n    //   1: RLE compressed\r\n    compression = stbi__get16be(s);\r\n    if (compression > 1)\r\n        return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\r\n\r\n    // Check size\r\n    if (!stbi__mad3sizes_valid(4, w, h, 0))\r\n        return stbi__errpuc(\"too large\", \"Corrupt PSD\");\r\n\r\n    // Create the destination image.\r\n\r\n    if (!compression && bitdepth == 16 && bpc == 16) {\r\n        out = (stbi_uc*)stbi__malloc_mad3(8, w, h, 0);\r\n        ri->bits_per_channel = 16;\r\n    }\r\n    else\r\n        out = (stbi_uc*)stbi__malloc(4 * w * h);\r\n\r\n    if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    pixelCount = w * h;\r\n\r\n    // Initialize the data to zero.\r\n    //memset( out, 0, pixelCount * 4 );\r\n\r\n    // Finally, the image data.\r\n    if (compression) {\r\n        // RLE as used by .PSD and .TIFF\r\n        // Loop until you get the number of unpacked bytes you are expecting:\r\n        //     Read the next source byte into n.\r\n        //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\r\n        //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\r\n        //     Else if n is 128, noop.\r\n        // Endloop\r\n\r\n        // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,\r\n        // which we're going to just skip.\r\n        stbi__skip(s, h * channelCount * 2);\r\n\r\n        // Read the RLE data by channel.\r\n        for (channel = 0; channel < 4; channel++) {\r\n            stbi_uc* p;\r\n\r\n            p = out + channel;\r\n            if (channel >= channelCount) {\r\n                // Fill this channel with default data.\r\n                for (i = 0; i < pixelCount; i++, p += 4)\r\n                    *p = (channel == 3 ? 255 : 0);\r\n            }\r\n            else {\r\n                // Read the RLE data.\r\n                if (!stbi__psd_decode_rle(s, p, pixelCount)) {\r\n                    STBI_FREE(out);\r\n                    return stbi__errpuc(\"corrupt\", \"bad RLE data\");\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    else {\r\n        // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\r\n        // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.\r\n\r\n        // Read the data by channel.\r\n        for (channel = 0; channel < 4; channel++) {\r\n            if (channel >= channelCount) {\r\n                // Fill this channel with default data.\r\n                if (bitdepth == 16 && bpc == 16) {\r\n                    stbi__uint16* q = ((stbi__uint16*)out) + channel;\r\n                    stbi__uint16 val = channel == 3 ? 65535 : 0;\r\n                    for (i = 0; i < pixelCount; i++, q += 4)\r\n                        *q = val;\r\n                }\r\n                else {\r\n                    stbi_uc* p = out + channel;\r\n                    stbi_uc val = channel == 3 ? 255 : 0;\r\n                    for (i = 0; i < pixelCount; i++, p += 4)\r\n                        *p = val;\r\n                }\r\n            }\r\n            else {\r\n                if (ri->bits_per_channel == 16) {    // output bpc\r\n                    stbi__uint16* q = ((stbi__uint16*)out) + channel;\r\n                    for (i = 0; i < pixelCount; i++, q += 4)\r\n                        *q = (stbi__uint16)stbi__get16be(s);\r\n                }\r\n                else {\r\n                    stbi_uc* p = out + channel;\r\n                    if (bitdepth == 16) {  // input bpc\r\n                        for (i = 0; i < pixelCount; i++, p += 4)\r\n                            *p = (stbi_uc)(stbi__get16be(s) >> 8);\r\n                    }\r\n                    else {\r\n                        for (i = 0; i < pixelCount; i++, p += 4)\r\n                            *p = stbi__get8(s);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // remove weird white matte from PSD\r\n    if (channelCount >= 4) {\r\n        if (ri->bits_per_channel == 16) {\r\n            for (i = 0; i < w * h; ++i) {\r\n                stbi__uint16* pixel = (stbi__uint16*)out + 4 * i;\r\n                if (pixel[3] != 0 && pixel[3] != 65535) {\r\n                    float a = pixel[3] / 65535.0f;\r\n                    float ra = 1.0f / a;\r\n                    float inv_a = 65535.0f * (1 - ra);\r\n                    pixel[0] = (stbi__uint16)(pixel[0] * ra + inv_a);\r\n                    pixel[1] = (stbi__uint16)(pixel[1] * ra + inv_a);\r\n                    pixel[2] = (stbi__uint16)(pixel[2] * ra + inv_a);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0; i < w * h; ++i) {\r\n                unsigned char* pixel = out + 4 * i;\r\n                if (pixel[3] != 0 && pixel[3] != 255) {\r\n                    float a = pixel[3] / 255.0f;\r\n                    float ra = 1.0f / a;\r\n                    float inv_a = 255.0f * (1 - ra);\r\n                    pixel[0] = (unsigned char)(pixel[0] * ra + inv_a);\r\n                    pixel[1] = (unsigned char)(pixel[1] * ra + inv_a);\r\n                    pixel[2] = (unsigned char)(pixel[2] * ra + inv_a);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // convert to desired output format\r\n    if (req_comp && req_comp != 4) {\r\n        if (ri->bits_per_channel == 16)\r\n            out = (stbi_uc*)stbi__convert_format16((stbi__uint16*)out, 4, req_comp, w, h);\r\n        else\r\n            out = stbi__convert_format(out, 4, req_comp, w, h);\r\n        if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n    }\r\n\r\n    if (comp) *comp = 4;\r\n    *y = h;\r\n    *x = w;\r\n\r\n    return out;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Softimage PIC loader\r\n// by Tom Seddon\r\n//\r\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\r\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int stbi__pic_is4(stbi__context* s, const char* str)\r\n{\r\n    int i;\r\n    for (i = 0; i < 4; ++i)\r\n        if (stbi__get8(s) != (stbi_uc)str[i])\r\n            return 0;\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__pic_test_core(stbi__context* s)\r\n{\r\n    int i;\r\n\r\n    if (!stbi__pic_is4(s, \"\\x53\\x80\\xF6\\x34\"))\r\n        return 0;\r\n\r\n    for (i = 0; i < 84; ++i)\r\n        stbi__get8(s);\r\n\r\n    if (!stbi__pic_is4(s, \"PICT\"))\r\n        return 0;\r\n\r\n    return 1;\r\n}\r\n\r\ntypedef struct\r\n{\r\n    stbi_uc size, type, channel;\r\n} stbi__pic_packet;\r\n\r\nstatic stbi_uc* stbi__readval(stbi__context* s, int channel, stbi_uc* dest)\r\n{\r\n    int mask = 0x80, i;\r\n\r\n    for (i = 0; i < 4; ++i, mask >>= 1) {\r\n        if (channel & mask) {\r\n            if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\", \"PIC file too short\");\r\n            dest[i] = stbi__get8(s);\r\n        }\r\n    }\r\n\r\n    return dest;\r\n}\r\n\r\nstatic void stbi__copyval(int channel, stbi_uc* dest, const stbi_uc* src)\r\n{\r\n    int mask = 0x80, i;\r\n\r\n    for (i = 0; i < 4; ++i, mask >>= 1)\r\n        if (channel & mask)\r\n            dest[i] = src[i];\r\n}\r\n\r\nstatic stbi_uc* stbi__pic_load_core(stbi__context* s, int width, int height, int* comp, stbi_uc* result)\r\n{\r\n    int act_comp = 0, num_packets = 0, y, chained;\r\n    stbi__pic_packet packets[10];\r\n\r\n    // this will (should...) cater for even some bizarre stuff like having data\r\n     // for the same channel in multiple packets.\r\n    do {\r\n        stbi__pic_packet* packet;\r\n\r\n        if (num_packets == sizeof(packets) / sizeof(packets[0]))\r\n            return stbi__errpuc(\"bad format\", \"too many packets\");\r\n\r\n        packet = &packets[num_packets++];\r\n\r\n        chained = stbi__get8(s);\r\n        packet->size = stbi__get8(s);\r\n        packet->type = stbi__get8(s);\r\n        packet->channel = stbi__get8(s);\r\n\r\n        act_comp |= packet->channel;\r\n\r\n        if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\", \"file too short (reading packets)\");\r\n        if (packet->size != 8)  return stbi__errpuc(\"bad format\", \"packet isn't 8bpp\");\r\n    } while (chained);\r\n\r\n    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\r\n\r\n    for (y = 0; y < height; ++y) {\r\n        int packet_idx;\r\n\r\n        for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {\r\n            stbi__pic_packet* packet = &packets[packet_idx];\r\n            stbi_uc* dest = result + y * width * 4;\r\n\r\n            switch (packet->type) {\r\n            default:\r\n                return stbi__errpuc(\"bad format\", \"packet has bad compression type\");\r\n\r\n            case 0: {//uncompressed\r\n                int x;\r\n\r\n                for (x = 0; x < width; ++x, dest += 4)\r\n                    if (!stbi__readval(s, packet->channel, dest))\r\n                        return 0;\r\n                break;\r\n            }\r\n\r\n            case 1://Pure RLE\r\n            {\r\n                int left = width, i;\r\n\r\n                while (left > 0) {\r\n                    stbi_uc count, value[4];\r\n\r\n                    count = stbi__get8(s);\r\n                    if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\", \"file too short (pure read count)\");\r\n\r\n                    if (count > left)\r\n                        count = (stbi_uc)left;\r\n\r\n                    if (!stbi__readval(s, packet->channel, value))  return 0;\r\n\r\n                    for (i = 0; i < count; ++i, dest += 4)\r\n                        stbi__copyval(packet->channel, dest, value);\r\n                    left -= count;\r\n                }\r\n            }\r\n            break;\r\n\r\n            case 2: {//Mixed RLE\r\n                int left = width;\r\n                while (left > 0) {\r\n                    int count = stbi__get8(s), i;\r\n                    if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\", \"file too short (mixed read count)\");\r\n\r\n                    if (count >= 128) { // Repeated\r\n                        stbi_uc value[4];\r\n\r\n                        if (count == 128)\r\n                            count = stbi__get16be(s);\r\n                        else\r\n                            count -= 127;\r\n                        if (count > left)\r\n                            return stbi__errpuc(\"bad file\", \"scanline overrun\");\r\n\r\n                        if (!stbi__readval(s, packet->channel, value))\r\n                            return 0;\r\n\r\n                        for (i = 0; i < count; ++i, dest += 4)\r\n                            stbi__copyval(packet->channel, dest, value);\r\n                    }\r\n                    else { // Raw\r\n                        ++count;\r\n                        if (count > left) return stbi__errpuc(\"bad file\", \"scanline overrun\");\r\n\r\n                        for (i = 0; i < count; ++i, dest += 4)\r\n                            if (!stbi__readval(s, packet->channel, dest))\r\n                                return 0;\r\n                    }\r\n                    left -= count;\r\n                }\r\n                break;\r\n            }\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nstatic void* stbi__pic_load(stbi__context* s, int* px, int* py, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    stbi_uc* result;\r\n    int i, x, y, internal_comp;\r\n    STBI_NOTUSED(ri);\r\n\r\n    if (!comp) comp = &internal_comp;\r\n\r\n    for (i = 0; i < 92; ++i)\r\n        stbi__get8(s);\r\n\r\n    x = stbi__get16be(s);\r\n    y = stbi__get16be(s);\r\n\r\n    if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n    if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\", \"file too short (pic header)\");\r\n    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\"too large\", \"PIC image too large to decode\");\r\n\r\n    stbi__get32be(s); //skip `ratio'\r\n    stbi__get16be(s); //skip `fields'\r\n    stbi__get16be(s); //skip `pad'\r\n\r\n    // intermediate buffer is RGBA\r\n    result = (stbi_uc*)stbi__malloc_mad3(x, y, 4, 0);\r\n    if (!result) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    memset(result, 0xff, x * y * 4);\r\n\r\n    if (!stbi__pic_load_core(s, x, y, comp, result)) {\r\n        STBI_FREE(result);\r\n        result = 0;\r\n    }\r\n    *px = x;\r\n    *py = y;\r\n    if (req_comp == 0) req_comp = *comp;\r\n    result = stbi__convert_format(result, 4, req_comp, x, y);\r\n\r\n    return result;\r\n}\r\n\r\nstatic int stbi__pic_test(stbi__context* s)\r\n{\r\n    int r = stbi__pic_test_core(s);\r\n    stbi__rewind(s);\r\n    return r;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\r\n\r\n#ifndef STBI_NO_GIF\r\ntypedef struct\r\n{\r\n    stbi__int16 prefix;\r\n    stbi_uc first;\r\n    stbi_uc suffix;\r\n} stbi__gif_lzw;\r\n\r\ntypedef struct\r\n{\r\n    int w, h;\r\n    stbi_uc* out;                 // output buffer (always 4 components)\r\n    stbi_uc* background;          // The current \"background\" as far as a gif is concerned\r\n    stbi_uc* history;\r\n    int flags, bgindex, ratio, transparent, eflags;\r\n    stbi_uc  pal[256][4];\r\n    stbi_uc lpal[256][4];\r\n    stbi__gif_lzw codes[8192];\r\n    stbi_uc* color_table;\r\n    int parse, step;\r\n    int lflags;\r\n    int start_x, start_y;\r\n    int max_x, max_y;\r\n    int cur_x, cur_y;\r\n    int line_size;\r\n    int delay;\r\n} stbi__gif;\r\n\r\nstatic int stbi__gif_test_raw(stbi__context* s)\r\n{\r\n    int sz;\r\n    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\r\n    sz = stbi__get8(s);\r\n    if (sz != '9' && sz != '7') return 0;\r\n    if (stbi__get8(s) != 'a') return 0;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__gif_test(stbi__context* s)\r\n{\r\n    int r = stbi__gif_test_raw(s);\r\n    stbi__rewind(s);\r\n    return r;\r\n}\r\n\r\nstatic void stbi__gif_parse_colortable(stbi__context* s, stbi_uc pal[256][4], int num_entries, int transp)\r\n{\r\n    int i;\r\n    for (i = 0; i < num_entries; ++i) {\r\n        pal[i][2] = stbi__get8(s);\r\n        pal[i][1] = stbi__get8(s);\r\n        pal[i][0] = stbi__get8(s);\r\n        pal[i][3] = transp == i ? 0 : 255;\r\n    }\r\n}\r\n\r\nstatic int stbi__gif_header(stbi__context* s, stbi__gif* g, int* comp, int is_info)\r\n{\r\n    stbi_uc version;\r\n    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\r\n        return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n\r\n    version = stbi__get8(s);\r\n    if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n    if (stbi__get8(s) != 'a')                return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n\r\n    stbi__g_failure_reason = \"\";\r\n    g->w = stbi__get16le(s);\r\n    g->h = stbi__get16le(s);\r\n    g->flags = stbi__get8(s);\r\n    g->bgindex = stbi__get8(s);\r\n    g->ratio = stbi__get8(s);\r\n    g->transparent = -1;\r\n\r\n    if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\", \"Very large image (corrupt?)\");\r\n    if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\r\n\r\n    if (is_info) return 1;\r\n\r\n    if (g->flags & 0x80)\r\n        stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__gif_info_raw(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));\r\n    if (!g) return stbi__err(\"outofmem\", \"Out of memory\");\r\n    if (!stbi__gif_header(s, g, comp, 1)) {\r\n        STBI_FREE(g);\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if (x) *x = g->w;\r\n    if (y) *y = g->h;\r\n    STBI_FREE(g);\r\n    return 1;\r\n}\r\n\r\nstatic void stbi__out_gif_code(stbi__gif* g, stbi__uint16 code)\r\n{\r\n    stbi_uc* p, * c;\r\n    int idx;\r\n\r\n    // recurse to decode the prefixes, since the linked-list is backwards,\r\n    // and working backwards through an interleaved image would be nasty\r\n    if (g->codes[code].prefix >= 0)\r\n        stbi__out_gif_code(g, g->codes[code].prefix);\r\n\r\n    if (g->cur_y >= g->max_y) return;\r\n\r\n    idx = g->cur_x + g->cur_y;\r\n    p = &g->out[idx];\r\n    g->history[idx / 4] = 1;\r\n\r\n    c = &g->color_table[g->codes[code].suffix * 4];\r\n    if (c[3] > 128) { // don't render transparent pixels;\r\n        p[0] = c[2];\r\n        p[1] = c[1];\r\n        p[2] = c[0];\r\n        p[3] = c[3];\r\n    }\r\n    g->cur_x += 4;\r\n\r\n    if (g->cur_x >= g->max_x) {\r\n        g->cur_x = g->start_x;\r\n        g->cur_y += g->step;\r\n\r\n        while (g->cur_y >= g->max_y && g->parse > 0) {\r\n            g->step = (1 << g->parse) * g->line_size;\r\n            g->cur_y = g->start_y + (g->step >> 1);\r\n            --g->parse;\r\n        }\r\n    }\r\n}\r\n\r\nstatic stbi_uc* stbi__process_gif_raster(stbi__context* s, stbi__gif* g)\r\n{\r\n    stbi_uc lzw_cs;\r\n    stbi__int32 len, init_code;\r\n    stbi__uint32 first;\r\n    stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\r\n    stbi__gif_lzw* p;\r\n\r\n    lzw_cs = stbi__get8(s);\r\n    if (lzw_cs > 12) return NULL;\r\n    clear = 1 << lzw_cs;\r\n    first = 1;\r\n    codesize = lzw_cs + 1;\r\n    codemask = (1 << codesize) - 1;\r\n    bits = 0;\r\n    valid_bits = 0;\r\n    for (init_code = 0; init_code < clear; init_code++) {\r\n        g->codes[init_code].prefix = -1;\r\n        g->codes[init_code].first = (stbi_uc)init_code;\r\n        g->codes[init_code].suffix = (stbi_uc)init_code;\r\n    }\r\n\r\n    // support no starting clear code\r\n    avail = clear + 2;\r\n    oldcode = -1;\r\n\r\n    len = 0;\r\n    for (;;) {\r\n        if (valid_bits < codesize) {\r\n            if (len == 0) {\r\n                len = stbi__get8(s); // start new block\r\n                if (len == 0)\r\n                    return g->out;\r\n            }\r\n            --len;\r\n            bits |= (stbi__int32)stbi__get8(s) << valid_bits;\r\n            valid_bits += 8;\r\n        }\r\n        else {\r\n            stbi__int32 code = bits & codemask;\r\n            bits >>= codesize;\r\n            valid_bits -= codesize;\r\n            // @OPTIMIZE: is there some way we can accelerate the non-clear path?\r\n            if (code == clear) {  // clear code\r\n                codesize = lzw_cs + 1;\r\n                codemask = (1 << codesize) - 1;\r\n                avail = clear + 2;\r\n                oldcode = -1;\r\n                first = 0;\r\n            }\r\n            else if (code == clear + 1) { // end of stream code\r\n                stbi__skip(s, len);\r\n                while ((len = stbi__get8(s)) > 0)\r\n                    stbi__skip(s, len);\r\n                return g->out;\r\n            }\r\n            else if (code <= avail) {\r\n                if (first) {\r\n                    return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\r\n                }\r\n\r\n                if (oldcode >= 0) {\r\n                    p = &g->codes[avail++];\r\n                    if (avail > 8192) {\r\n                        return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\r\n                    }\r\n\r\n                    p->prefix = (stbi__int16)oldcode;\r\n                    p->first = g->codes[oldcode].first;\r\n                    p->suffix = (code == avail) ? p->first : g->codes[code].first;\r\n                }\r\n                else if (code == avail)\r\n                    return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\r\n\r\n                stbi__out_gif_code(g, (stbi__uint16)code);\r\n\r\n                if ((avail & codemask) == 0 && avail <= 0x0FFF) {\r\n                    codesize++;\r\n                    codemask = (1 << codesize) - 1;\r\n                }\r\n\r\n                oldcode = code;\r\n            }\r\n            else {\r\n                return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// this function is designed to support animated gifs, although stb_image doesn't support it\r\n// two back is the image from two frames ago, used for a very specific disposal format\r\nstatic stbi_uc* stbi__gif_load_next(stbi__context* s, stbi__gif* g, int* comp, int req_comp, stbi_uc* two_back)\r\n{\r\n    int dispose;\r\n    int first_frame;\r\n    int pi;\r\n    int pcount;\r\n    STBI_NOTUSED(req_comp);\r\n\r\n    // on first frame, any non-written pixels get the background colour (non-transparent)\r\n    first_frame = 0;\r\n    if (g->out == 0) {\r\n        if (!stbi__gif_header(s, g, comp, 0)) return 0; // stbi__g_failure_reason set by stbi__gif_header\r\n        if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))\r\n            return stbi__errpuc(\"too large\", \"GIF image is too large\");\r\n        pcount = g->w * g->h;\r\n        g->out = (stbi_uc*)stbi__malloc(4 * pcount);\r\n        g->background = (stbi_uc*)stbi__malloc(4 * pcount);\r\n        g->history = (stbi_uc*)stbi__malloc(pcount);\r\n        if (!g->out || !g->background || !g->history)\r\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n        // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background;\r\n        // background colour is only used for pixels that are not rendered first frame, after that \"background\"\r\n        // color refers to the color that was there the previous frame.\r\n        memset(g->out, 0x00, 4 * pcount);\r\n        memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)\r\n        memset(g->history, 0x00, pcount);        // pixels that were affected previous frame\r\n        first_frame = 1;\r\n    }\r\n    else {\r\n        // second frame - how do we dispose of the previous one?\r\n        dispose = (g->eflags & 0x1C) >> 2;\r\n        pcount = g->w * g->h;\r\n\r\n        if ((dispose == 3) && (two_back == 0)) {\r\n            dispose = 2; // if I don't have an image to revert back to, default to the old background\r\n        }\r\n\r\n        if (dispose == 3) { // use previous graphic\r\n            for (pi = 0; pi < pcount; ++pi) {\r\n                if (g->history[pi]) {\r\n                    memcpy(&g->out[pi * 4], &two_back[pi * 4], 4);\r\n                }\r\n            }\r\n        }\r\n        else if (dispose == 2) {\r\n            // restore what was changed last frame to background before that frame;\r\n            for (pi = 0; pi < pcount; ++pi) {\r\n                if (g->history[pi]) {\r\n                    memcpy(&g->out[pi * 4], &g->background[pi * 4], 4);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // This is a non-disposal case eithe way, so just\r\n            // leave the pixels as is, and they will become the new background\r\n            // 1: do not dispose\r\n            // 0:  not specified.\r\n        }\r\n\r\n        // background is what out is after the undoing of the previou frame;\r\n        memcpy(g->background, g->out, 4 * g->w * g->h);\r\n    }\r\n\r\n    // clear my history;\r\n    memset(g->history, 0x00, g->w * g->h);        // pixels that were affected previous frame\r\n\r\n    for (;;) {\r\n        int tag = stbi__get8(s);\r\n        switch (tag) {\r\n        case 0x2C: /* Image Descriptor */\r\n        {\r\n            stbi__int32 x, y, w, h;\r\n            stbi_uc* o;\r\n\r\n            x = stbi__get16le(s);\r\n            y = stbi__get16le(s);\r\n            w = stbi__get16le(s);\r\n            h = stbi__get16le(s);\r\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\r\n                return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\r\n\r\n            g->line_size = g->w * 4;\r\n            g->start_x = x * 4;\r\n            g->start_y = y * g->line_size;\r\n            g->max_x = g->start_x + w * 4;\r\n            g->max_y = g->start_y + h * g->line_size;\r\n            g->cur_x = g->start_x;\r\n            g->cur_y = g->start_y;\r\n\r\n            // if the width of the specified rectangle is 0, that means\r\n            // we may not see *any* pixels or the image is malformed;\r\n            // to make sure this is caught, move the current y down to\r\n            // max_y (which is what out_gif_code checks).\r\n            if (w == 0)\r\n                g->cur_y = g->max_y;\r\n\r\n            g->lflags = stbi__get8(s);\r\n\r\n            if (g->lflags & 0x40) {\r\n                g->step = 8 * g->line_size; // first interlaced spacing\r\n                g->parse = 3;\r\n            }\r\n            else {\r\n                g->step = g->line_size;\r\n                g->parse = 0;\r\n            }\r\n\r\n            if (g->lflags & 0x80) {\r\n                stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\r\n                g->color_table = (stbi_uc*)g->lpal;\r\n            }\r\n            else if (g->flags & 0x80) {\r\n                g->color_table = (stbi_uc*)g->pal;\r\n            }\r\n            else\r\n                return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\r\n\r\n            o = stbi__process_gif_raster(s, g);\r\n            if (!o) return NULL;\r\n\r\n            // if this was the first frame,\r\n            pcount = g->w * g->h;\r\n            if (first_frame && (g->bgindex > 0)) {\r\n                // if first frame, any pixel not drawn to gets the background color\r\n                for (pi = 0; pi < pcount; ++pi) {\r\n                    if (g->history[pi] == 0) {\r\n                        g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;\r\n                        memcpy(&g->out[pi * 4], &g->pal[g->bgindex], 4);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return o;\r\n        }\r\n\r\n        case 0x21: // Comment Extension.\r\n        {\r\n            int len;\r\n            int ext = stbi__get8(s);\r\n            if (ext == 0xF9) { // Graphic Control Extension.\r\n                len = stbi__get8(s);\r\n                if (len == 4) {\r\n                    g->eflags = stbi__get8(s);\r\n                    g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.\r\n\r\n                    // unset old transparent\r\n                    if (g->transparent >= 0) {\r\n                        g->pal[g->transparent][3] = 255;\r\n                    }\r\n                    if (g->eflags & 0x01) {\r\n                        g->transparent = stbi__get8(s);\r\n                        if (g->transparent >= 0) {\r\n                            g->pal[g->transparent][3] = 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // don't need transparent\r\n                        stbi__skip(s, 1);\r\n                        g->transparent = -1;\r\n                    }\r\n                }\r\n                else {\r\n                    stbi__skip(s, len);\r\n                    break;\r\n                }\r\n            }\r\n            while ((len = stbi__get8(s)) != 0) {\r\n                stbi__skip(s, len);\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 0x3B: // gif stream termination code\r\n            return (stbi_uc*)s; // using '1' causes warning on some compilers\r\n\r\n        default:\r\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\r\n        }\r\n    }\r\n}\r\n\r\nstatic void* stbi__load_gif_main_outofmem(stbi__gif* g, stbi_uc* out, int** delays)\r\n{\r\n    STBI_FREE(g->out);\r\n    STBI_FREE(g->history);\r\n    STBI_FREE(g->background);\r\n\r\n    if (out) STBI_FREE(out);\r\n    if (delays && *delays) STBI_FREE(*delays);\r\n    return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n}\r\n\r\nstatic void* stbi__load_gif_main(stbi__context* s, int** delays, int* x, int* y, int* z, int* comp, int req_comp)\r\n{\r\n    if (stbi__gif_test(s)) {\r\n        int layers = 0;\r\n        stbi_uc* u = 0;\r\n        stbi_uc* out = 0;\r\n        stbi_uc* two_back = 0;\r\n        stbi__gif g;\r\n        int stride;\r\n        int out_size = 0;\r\n        int delays_size = 0;\r\n\r\n        STBI_NOTUSED(out_size);\r\n        STBI_NOTUSED(delays_size);\r\n\r\n        memset(&g, 0, sizeof(g));\r\n        if (delays) {\r\n            *delays = 0;\r\n        }\r\n\r\n        do {\r\n            u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);\r\n            if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker\r\n\r\n            if (u) {\r\n                *x = g.w;\r\n                *y = g.h;\r\n                ++layers;\r\n                stride = g.w * g.h * 4;\r\n\r\n                if (out) {\r\n                    void* tmp = (stbi_uc*)STBI_REALLOC_SIZED(out, out_size, layers * stride);\r\n                    if (!tmp)\r\n                        return stbi__load_gif_main_outofmem(&g, out, delays);\r\n                    else {\r\n                        out = (stbi_uc*)tmp;\r\n                        out_size = layers * stride;\r\n                    }\r\n\r\n                    if (delays) {\r\n                        int* new_delays = (int*)STBI_REALLOC_SIZED(*delays, delays_size, sizeof(int) * layers);\r\n                        if (!new_delays)\r\n                            return stbi__load_gif_main_outofmem(&g, out, delays);\r\n                        *delays = new_delays;\r\n                        delays_size = layers * sizeof(int);\r\n                    }\r\n                }\r\n                else {\r\n                    out = (stbi_uc*)stbi__malloc(layers * stride);\r\n                    if (!out)\r\n                        return stbi__load_gif_main_outofmem(&g, out, delays);\r\n                    out_size = layers * stride;\r\n                    if (delays) {\r\n                        *delays = (int*)stbi__malloc(layers * sizeof(int));\r\n                        if (!*delays)\r\n                            return stbi__load_gif_main_outofmem(&g, out, delays);\r\n                        delays_size = layers * sizeof(int);\r\n                    }\r\n                }\r\n                memcpy(out + ((layers - 1) * stride), u, stride);\r\n                if (layers >= 2) {\r\n                    two_back = out - 2 * stride;\r\n                }\r\n\r\n                if (delays) {\r\n                    (*delays)[layers - 1U] = g.delay;\r\n                }\r\n            }\r\n        } while (u != 0);\r\n\r\n        // free temp buffer;\r\n        STBI_FREE(g.out);\r\n        STBI_FREE(g.history);\r\n        STBI_FREE(g.background);\r\n\r\n        // do the final conversion after loading everything;\r\n        if (req_comp && req_comp != 4)\r\n            out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);\r\n\r\n        *z = layers;\r\n        return out;\r\n    }\r\n    else {\r\n        return stbi__errpuc(\"not GIF\", \"Image was not as a gif type.\");\r\n    }\r\n}\r\n\r\nstatic void* stbi__gif_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    stbi_uc* u = 0;\r\n    stbi__gif g;\r\n    memset(&g, 0, sizeof(g));\r\n    STBI_NOTUSED(ri);\r\n\r\n    u = stbi__gif_load_next(s, &g, comp, req_comp, 0);\r\n    if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker\r\n    if (u) {\r\n        *x = g.w;\r\n        *y = g.h;\r\n\r\n        // moved conversion to after successful load so that the same\r\n        // can be done for multiple frames.\r\n        if (req_comp && req_comp != 4)\r\n            u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\r\n    }\r\n    else if (g.out) {\r\n        // if there was an error and we allocated an image buffer, free it!\r\n        STBI_FREE(g.out);\r\n    }\r\n\r\n    // free buffers needed for multiple frame loading;\r\n    STBI_FREE(g.history);\r\n    STBI_FREE(g.background);\r\n\r\n    return u;\r\n}\r\n\r\nstatic int stbi__gif_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    return stbi__gif_info_raw(s, x, y, comp);\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Radiance RGBE HDR loader\r\n// originally by Nicolas Schulz\r\n#ifndef STBI_NO_HDR\r\nstatic int stbi__hdr_test_core(stbi__context* s, const char* signature)\r\n{\r\n    int i;\r\n    for (i = 0; signature[i]; ++i)\r\n        if (stbi__get8(s) != signature[i])\r\n            return 0;\r\n    stbi__rewind(s);\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__hdr_test(stbi__context* s)\r\n{\r\n    int r = stbi__hdr_test_core(s, \"#?RADIANCE\\n\");\r\n    stbi__rewind(s);\r\n    if (!r) {\r\n        r = stbi__hdr_test_core(s, \"#?RGBE\\n\");\r\n        stbi__rewind(s);\r\n    }\r\n    return r;\r\n}\r\n\r\n#define STBI__HDR_BUFLEN  1024\r\nstatic char* stbi__hdr_gettoken(stbi__context* z, char* buffer)\r\n{\r\n    int len = 0;\r\n    char c = '\\0';\r\n\r\n    c = (char)stbi__get8(z);\r\n\r\n    while (!stbi__at_eof(z) && c != '\\n') {\r\n        buffer[len++] = c;\r\n        if (len == STBI__HDR_BUFLEN - 1) {\r\n            // flush to end of line\r\n            while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\r\n                ;\r\n            break;\r\n        }\r\n        c = (char)stbi__get8(z);\r\n    }\r\n\r\n    buffer[len] = 0;\r\n    return buffer;\r\n}\r\n\r\nstatic void stbi__hdr_convert(float* output, stbi_uc* input, int req_comp)\r\n{\r\n    if (input[3] != 0) {\r\n        float f1;\r\n        // Exponent\r\n        f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));\r\n        if (req_comp <= 2)\r\n            output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\r\n        else {\r\n            output[0] = input[0] * f1;\r\n            output[1] = input[1] * f1;\r\n            output[2] = input[2] * f1;\r\n        }\r\n        if (req_comp == 2) output[1] = 1;\r\n        if (req_comp == 4) output[3] = 1;\r\n    }\r\n    else {\r\n        switch (req_comp) {\r\n        case 4: output[3] = 1; /* fallthrough */\r\n        case 3: output[0] = output[1] = output[2] = 0;\r\n            break;\r\n        case 2: output[1] = 1; /* fallthrough */\r\n        case 1: output[0] = 0;\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nstatic float* stbi__hdr_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    char buffer[STBI__HDR_BUFLEN];\r\n    char* token;\r\n    int valid = 0;\r\n    int width, height;\r\n    stbi_uc* scanline;\r\n    float* hdr_data;\r\n    int len;\r\n    unsigned char count, value;\r\n    int i, j, k, c1, c2, z;\r\n    const char* headerToken;\r\n    STBI_NOTUSED(ri);\r\n\r\n    // Check identifier\r\n    headerToken = stbi__hdr_gettoken(s, buffer);\r\n    if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\r\n        return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\r\n\r\n    // Parse header\r\n    for (;;) {\r\n        token = stbi__hdr_gettoken(s, buffer);\r\n        if (token[0] == 0) break;\r\n        if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\r\n    }\r\n\r\n    if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\r\n\r\n    // Parse width and height\r\n    // can't use sscanf() if we're not using stdio!\r\n    token = stbi__hdr_gettoken(s, buffer);\r\n    if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\r\n    token += 3;\r\n    height = (int)strtol(token, &token, 10);\r\n    while (*token == ' ') ++token;\r\n    if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\r\n    token += 3;\r\n    width = (int)strtol(token, NULL, 10);\r\n\r\n    if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\", \"Very large image (corrupt?)\");\r\n    if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    *x = width;\r\n    *y = height;\r\n\r\n    if (comp) *comp = 3;\r\n    if (req_comp == 0) req_comp = 3;\r\n\r\n    if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\r\n        return stbi__errpf(\"too large\", \"HDR image is too large\");\r\n\r\n    // Read data\r\n    hdr_data = (float*)stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\r\n    if (!hdr_data)\r\n        return stbi__errpf(\"outofmem\", \"Out of memory\");\r\n\r\n    // Load image data\r\n    // image data is stored as some number of sca\r\n    if (width < 8 || width >= 32768) {\r\n        // Read flat data\r\n        for (j = 0; j < height; ++j) {\r\n            for (i = 0; i < width; ++i) {\r\n                stbi_uc rgbe[4];\r\n            main_decode_loop:\r\n                stbi__getn(s, rgbe, 4);\r\n                stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // Read RLE-encoded data\r\n        scanline = NULL;\r\n\r\n        for (j = 0; j < height; ++j) {\r\n            c1 = stbi__get8(s);\r\n            c2 = stbi__get8(s);\r\n            len = stbi__get8(s);\r\n            if (c1 != 2 || c2 != 2 || (len & 0x80)) {\r\n                // not run-length encoded, so we have to actually use THIS data as a decoded\r\n                // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\r\n                stbi_uc rgbe[4];\r\n                rgbe[0] = (stbi_uc)c1;\r\n                rgbe[1] = (stbi_uc)c2;\r\n                rgbe[2] = (stbi_uc)len;\r\n                rgbe[3] = (stbi_uc)stbi__get8(s);\r\n                stbi__hdr_convert(hdr_data, rgbe, req_comp);\r\n                i = 1;\r\n                j = 0;\r\n                STBI_FREE(scanline);\r\n                goto main_decode_loop; // yes, this makes no sense\r\n            }\r\n            len <<= 8;\r\n            len |= stbi__get8(s);\r\n            if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\r\n            if (scanline == NULL) {\r\n                scanline = (stbi_uc*)stbi__malloc_mad2(width, 4, 0);\r\n                if (!scanline) {\r\n                    STBI_FREE(hdr_data);\r\n                    return stbi__errpf(\"outofmem\", \"Out of memory\");\r\n                }\r\n            }\r\n\r\n            for (k = 0; k < 4; ++k) {\r\n                int nleft;\r\n                i = 0;\r\n                while ((nleft = width - i) > 0) {\r\n                    count = stbi__get8(s);\r\n                    if (count > 128) {\r\n                        // Run\r\n                        value = stbi__get8(s);\r\n                        count -= 128;\r\n                        if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\r\n                        for (z = 0; z < count; ++z)\r\n                            scanline[i++ * 4 + k] = value;\r\n                    }\r\n                    else {\r\n                        // Dump\r\n                        if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\r\n                        for (z = 0; z < count; ++z)\r\n                            scanline[i++ * 4 + k] = stbi__get8(s);\r\n                    }\r\n                }\r\n            }\r\n            for (i = 0; i < width; ++i)\r\n                stbi__hdr_convert(hdr_data + (j * width + i) * req_comp, scanline + i * 4, req_comp);\r\n        }\r\n        if (scanline)\r\n            STBI_FREE(scanline);\r\n    }\r\n\r\n    return hdr_data;\r\n}\r\n\r\nstatic int stbi__hdr_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    char buffer[STBI__HDR_BUFLEN];\r\n    char* token;\r\n    int valid = 0;\r\n    int dummy;\r\n\r\n    if (!x) x = &dummy;\r\n    if (!y) y = &dummy;\r\n    if (!comp) comp = &dummy;\r\n\r\n    if (stbi__hdr_test(s) == 0) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n\r\n    for (;;) {\r\n        token = stbi__hdr_gettoken(s, buffer);\r\n        if (token[0] == 0) break;\r\n        if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\r\n    }\r\n\r\n    if (!valid) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    token = stbi__hdr_gettoken(s, buffer);\r\n    if (strncmp(token, \"-Y \", 3)) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    token += 3;\r\n    *y = (int)strtol(token, &token, 10);\r\n    while (*token == ' ') ++token;\r\n    if (strncmp(token, \"+X \", 3)) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    token += 3;\r\n    *x = (int)strtol(token, NULL, 10);\r\n    *comp = 3;\r\n    return 1;\r\n}\r\n#endif // STBI_NO_HDR\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int stbi__bmp_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    void* p;\r\n    stbi__bmp_data info;\r\n\r\n    info.all_a = 255;\r\n    p = stbi__bmp_parse_header(s, &info);\r\n    if (p == NULL) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if (x) *x = s->img_x;\r\n    if (y) *y = s->img_y;\r\n    if (comp) {\r\n        if (info.bpp == 24 && info.ma == 0xff000000)\r\n            *comp = 3;\r\n        else\r\n            *comp = info.ma ? 4 : 3;\r\n    }\r\n    return 1;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int stbi__psd_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    int channelCount, dummy, depth;\r\n    if (!x) x = &dummy;\r\n    if (!y) y = &dummy;\r\n    if (!comp) comp = &dummy;\r\n    if (stbi__get32be(s) != 0x38425053) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if (stbi__get16be(s) != 1) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    stbi__skip(s, 6);\r\n    channelCount = stbi__get16be(s);\r\n    if (channelCount < 0 || channelCount > 16) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    *y = stbi__get32be(s);\r\n    *x = stbi__get32be(s);\r\n    depth = stbi__get16be(s);\r\n    if (depth != 8 && depth != 16) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if (stbi__get16be(s) != 3) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    *comp = 4;\r\n    return 1;\r\n}\r\n\r\nstatic int stbi__psd_is16(stbi__context* s)\r\n{\r\n    int channelCount, depth;\r\n    if (stbi__get32be(s) != 0x38425053) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if (stbi__get16be(s) != 1) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    stbi__skip(s, 6);\r\n    channelCount = stbi__get16be(s);\r\n    if (channelCount < 0 || channelCount > 16) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    STBI_NOTUSED(stbi__get32be(s));\r\n    STBI_NOTUSED(stbi__get32be(s));\r\n    depth = stbi__get16be(s);\r\n    if (depth != 16) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    return 1;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int stbi__pic_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    int act_comp = 0, num_packets = 0, chained, dummy;\r\n    stbi__pic_packet packets[10];\r\n\r\n    if (!x) x = &dummy;\r\n    if (!y) y = &dummy;\r\n    if (!comp) comp = &dummy;\r\n\r\n    if (!stbi__pic_is4(s, \"\\x53\\x80\\xF6\\x34\")) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n\r\n    stbi__skip(s, 88);\r\n\r\n    *x = stbi__get16be(s);\r\n    *y = stbi__get16be(s);\r\n    if (stbi__at_eof(s)) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n\r\n    stbi__skip(s, 8);\r\n\r\n    do {\r\n        stbi__pic_packet* packet;\r\n\r\n        if (num_packets == sizeof(packets) / sizeof(packets[0]))\r\n            return 0;\r\n\r\n        packet = &packets[num_packets++];\r\n        chained = stbi__get8(s);\r\n        packet->size = stbi__get8(s);\r\n        packet->type = stbi__get8(s);\r\n        packet->channel = stbi__get8(s);\r\n        act_comp |= packet->channel;\r\n\r\n        if (stbi__at_eof(s)) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        if (packet->size != 8) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n    } while (chained);\r\n\r\n    *comp = (act_comp & 0x10 ? 4 : 3);\r\n\r\n    return 1;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Portable Gray Map and Portable Pixel Map loader\r\n// by Ken Miller\r\n//\r\n// PGM: http://netpbm.sourceforge.net/doc/pgm.html\r\n// PPM: http://netpbm.sourceforge.net/doc/ppm.html\r\n//\r\n// Known limitations:\r\n//    Does not support comments in the header section\r\n//    Does not support ASCII image data (formats P2 and P3)\r\n\r\n#ifndef STBI_NO_PNM\r\n\r\nstatic int      stbi__pnm_test(stbi__context* s)\r\n{\r\n    char p, t;\r\n    p = (char)stbi__get8(s);\r\n    t = (char)stbi__get8(s);\r\n    if (p != 'P' || (t != '5' && t != '6')) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n    return 1;\r\n}\r\n\r\nstatic void* stbi__pnm_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)\r\n{\r\n    stbi_uc* out;\r\n    STBI_NOTUSED(ri);\r\n\r\n    ri->bits_per_channel = stbi__pnm_info(s, (int*)&s->img_x, (int*)&s->img_y, (int*)&s->img_n);\r\n    if (ri->bits_per_channel == 0)\r\n        return 0;\r\n\r\n    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\", \"Very large image (corrupt?)\");\r\n\r\n    *x = s->img_x;\r\n    *y = s->img_y;\r\n    if (comp) *comp = s->img_n;\r\n\r\n    if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\r\n        return stbi__errpuc(\"too large\", \"PNM too large\");\r\n\r\n    out = (stbi_uc*)stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\r\n    if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n    if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\r\n        STBI_FREE(out);\r\n        return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\r\n    }\r\n\r\n    if (req_comp && req_comp != s->img_n) {\r\n        if (ri->bits_per_channel == 16) {\r\n            out = (stbi_uc*)stbi__convert_format16((stbi__uint16*)out, s->img_n, req_comp, s->img_x, s->img_y);\r\n        }\r\n        else {\r\n            out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\r\n        }\r\n        if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n    }\r\n    return out;\r\n}\r\n\r\nstatic int      stbi__pnm_isspace(char c)\r\n{\r\n    return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\r\n}\r\n\r\nstatic void     stbi__pnm_skip_whitespace(stbi__context* s, char* c)\r\n{\r\n    for (;;) {\r\n        while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))\r\n            *c = (char)stbi__get8(s);\r\n\r\n        if (stbi__at_eof(s) || *c != '#')\r\n            break;\r\n\r\n        while (!stbi__at_eof(s) && *c != '\\n' && *c != '\\r')\r\n            *c = (char)stbi__get8(s);\r\n    }\r\n}\r\n\r\nstatic int      stbi__pnm_isdigit(char c)\r\n{\r\n    return c >= '0' && c <= '9';\r\n}\r\n\r\nstatic int      stbi__pnm_getinteger(stbi__context* s, char* c)\r\n{\r\n    int value = 0;\r\n\r\n    while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {\r\n        value = value * 10 + (*c - '0');\r\n        *c = (char)stbi__get8(s);\r\n        if ((value > 214748364) || (value == 214748364 && *c > '7'))\r\n            return stbi__err(\"integer parse overflow\", \"Parsing an integer in the PPM header overflowed a 32-bit int\");\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nstatic int      stbi__pnm_info(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n    int maxv, dummy;\r\n    char c, p, t;\r\n\r\n    if (!x) x = &dummy;\r\n    if (!y) y = &dummy;\r\n    if (!comp) comp = &dummy;\r\n\r\n    stbi__rewind(s);\r\n\r\n    // Get identifier\r\n    p = (char)stbi__get8(s);\r\n    t = (char)stbi__get8(s);\r\n    if (p != 'P' || (t != '5' && t != '6')) {\r\n        stbi__rewind(s);\r\n        return 0;\r\n    }\r\n\r\n    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm\r\n\r\n    c = (char)stbi__get8(s);\r\n    stbi__pnm_skip_whitespace(s, &c);\r\n\r\n    *x = stbi__pnm_getinteger(s, &c); // read width\r\n    if (*x == 0)\r\n        return stbi__err(\"invalid width\", \"PPM image header had zero or overflowing width\");\r\n    stbi__pnm_skip_whitespace(s, &c);\r\n\r\n    *y = stbi__pnm_getinteger(s, &c); // read height\r\n    if (*y == 0)\r\n        return stbi__err(\"invalid width\", \"PPM image header had zero or overflowing width\");\r\n    stbi__pnm_skip_whitespace(s, &c);\r\n\r\n    maxv = stbi__pnm_getinteger(s, &c);  // read max value\r\n    if (maxv > 65535)\r\n        return stbi__err(\"max value > 65535\", \"PPM image supports only 8-bit and 16-bit images\");\r\n    else if (maxv > 255)\r\n        return 16;\r\n    else\r\n        return 8;\r\n}\r\n\r\nstatic int stbi__pnm_is16(stbi__context* s)\r\n{\r\n    if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)\r\n        return 1;\r\n    return 0;\r\n}\r\n#endif\r\n\r\nstatic int stbi__info_main(stbi__context* s, int* x, int* y, int* comp)\r\n{\r\n#ifndef STBI_NO_JPEG\r\n    if (stbi__jpeg_info(s, x, y, comp)) return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_PNG\r\n    if (stbi__png_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_GIF\r\n    if (stbi__gif_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\n    if (stbi__bmp_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\n    if (stbi__psd_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\n    if (stbi__pic_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_PNM\r\n    if (stbi__pnm_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n    if (stbi__hdr_info(s, x, y, comp))  return 1;\r\n#endif\r\n\r\n    // test tga last because it's a crappy test!\r\n#ifndef STBI_NO_TGA\r\n    if (stbi__tga_info(s, x, y, comp))\r\n        return 1;\r\n#endif\r\n    return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nstatic int stbi__is_16_main(stbi__context* s)\r\n{\r\n#ifndef STBI_NO_PNG\r\n    if (stbi__png_is16(s))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\n    if (stbi__psd_is16(s))  return 1;\r\n#endif\r\n\r\n#ifndef STBI_NO_PNM\r\n    if (stbi__pnm_is16(s))  return 1;\r\n#endif\r\n    return 0;\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int stbi_info(char const* filename, int* x, int* y, int* comp)\r\n{\r\n    FILE* f = stbi__fopen(filename, \"rb\");\r\n    int result;\r\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_info_from_file(f, x, y, comp);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\nSTBIDEF int stbi_info_from_file(FILE* f, int* x, int* y, int* comp)\r\n{\r\n    int r;\r\n    stbi__context s;\r\n    long pos = ftell(f);\r\n    stbi__start_file(&s, f);\r\n    r = stbi__info_main(&s, x, y, comp);\r\n    fseek(f, pos, SEEK_SET);\r\n    return r;\r\n}\r\n\r\nSTBIDEF int stbi_is_16_bit(char const* filename)\r\n{\r\n    FILE* f = stbi__fopen(filename, \"rb\");\r\n    int result;\r\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_is_16_bit_from_file(f);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\nSTBIDEF int stbi_is_16_bit_from_file(FILE* f)\r\n{\r\n    int r;\r\n    stbi__context s;\r\n    long pos = ftell(f);\r\n    stbi__start_file(&s, f);\r\n    r = stbi__is_16_main(&s);\r\n    fseek(f, pos, SEEK_SET);\r\n    return r;\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\nSTBIDEF int stbi_info_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n    return stbi__info_main(&s, x, y, comp);\r\n}\r\n\r\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const* c, void* user, int* x, int* y, int* comp)\r\n{\r\n    stbi__context s;\r\n    stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);\r\n    return stbi__info_main(&s, x, y, comp);\r\n}\r\n\r\nSTBIDEF int stbi_is_16_bit_from_memory(stbi_uc const* buffer, int len)\r\n{\r\n    stbi__context s;\r\n    stbi__start_mem(&s, buffer, len);\r\n    return stbi__is_16_main(&s);\r\n}\r\n\r\nSTBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const* c, void* user)\r\n{\r\n    stbi__context s;\r\n    stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);\r\n    return stbi__is_16_main(&s);\r\n}\r\n\r\n#endif // STB_IMAGE_IMPLEMENTATION\r\n\r\n/*\r\n   revision history:\r\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\r\n      2.19  (2018-02-11) fix warning\r\n      2.18  (2018-01-30) fix warnings\r\n      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug\r\n                         1-bit BMP\r\n                         *_is_16_bit api\r\n                         avoid warnings\r\n      2.16  (2017-07-23) all functions have 16-bit variants;\r\n                         STBI_NO_STDIO works again;\r\n                         compilation fixes;\r\n                         fix rounding in unpremultiply;\r\n                         optimize vertical flip;\r\n                         disable raw_len validation;\r\n                         documentation fixes\r\n      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;\r\n                         warning fixes; disable run-time SSE detection on gcc;\r\n                         uniform handling of optional \"return\" values;\r\n                         thread-safe initialization of zlib tables\r\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\r\n      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now\r\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\r\n      2.11  (2016-04-02) allocate large structures on the stack\r\n                         remove white matting for transparent PSD\r\n                         fix reported channel count for PNG & BMP\r\n                         re-enable SSE2 in non-gcc 64-bit\r\n                         support RGB-formatted JPEG\r\n                         read 16-bit PNGs (only as 8-bit)\r\n      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED\r\n      2.09  (2016-01-16) allow comments in PNM files\r\n                         16-bit-per-pixel TGA (not bit-per-component)\r\n                         info() for TGA could break due to .hdr handling\r\n                         info() for BMP to shares code instead of sloppy parse\r\n                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc\r\n                         code cleanup\r\n      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA\r\n      2.07  (2015-09-13) fix compiler warnings\r\n                         partial animated GIF support\r\n                         limited 16-bpc PSD support\r\n                         #ifdef unused functions\r\n                         bug with < 92 byte PIC,PNM,HDR,TGA\r\n      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value\r\n      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning\r\n      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit\r\n      2.03  (2015-04-12) extra corruption checking (mmozeiko)\r\n                         stbi_set_flip_vertically_on_load (nguillemot)\r\n                         fix NEON support; fix mingw support\r\n      2.02  (2015-01-19) fix incorrect assert, fix warning\r\n      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2\r\n      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG\r\n      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)\r\n                         progressive JPEG (stb)\r\n                         PGM/PPM support (Ken Miller)\r\n                         STBI_MALLOC,STBI_REALLOC,STBI_FREE\r\n                         GIF bugfix -- seemingly never worked\r\n                         STBI_NO_*, STBI_ONLY_*\r\n      1.48  (2014-12-14) fix incorrectly-named assert()\r\n      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)\r\n                         optimize PNG (ryg)\r\n                         fix bug in interlaced PNG with user-specified channel count (stb)\r\n      1.46  (2014-08-26)\r\n              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\r\n      1.45  (2014-08-16)\r\n              fix MSVC-ARM internal compiler error by wrapping malloc\r\n      1.44  (2014-08-07)\r\n              various warning fixes from Ronny Chevalier\r\n      1.43  (2014-07-15)\r\n              fix MSVC-only compiler problem in code changed in 1.42\r\n      1.42  (2014-07-09)\r\n              don't define _CRT_SECURE_NO_WARNINGS (affects user code)\r\n              fixes to stbi__cleanup_jpeg path\r\n              added STBI_ASSERT to avoid requiring assert.h\r\n      1.41  (2014-06-25)\r\n              fix search&replace from 1.36 that messed up comments/error messages\r\n      1.40  (2014-06-22)\r\n              fix gcc struct-initialization warning\r\n      1.39  (2014-06-15)\r\n              fix to TGA optimization when req_comp != number of components in TGA;\r\n              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\r\n              add support for BMP version 5 (more ignored fields)\r\n      1.38  (2014-06-06)\r\n              suppress MSVC warnings on integer casts truncating values\r\n              fix accidental rename of 'skip' field of I/O\r\n      1.37  (2014-06-04)\r\n              remove duplicate typedef\r\n      1.36  (2014-06-03)\r\n              convert to header file single-file library\r\n              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\r\n      1.35  (2014-05-27)\r\n              various warnings\r\n              fix broken STBI_SIMD path\r\n              fix bug where stbi_load_from_file no longer left file pointer in correct place\r\n              fix broken non-easy path for 32-bit BMP (possibly never used)\r\n              TGA optimization by Arseny Kapoulkine\r\n      1.34  (unknown)\r\n              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\r\n      1.33  (2011-07-14)\r\n              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\r\n      1.32  (2011-07-13)\r\n              support for \"info\" function for all supported filetypes (SpartanJ)\r\n      1.31  (2011-06-20)\r\n              a few more leak fixes, bug in PNG handling (SpartanJ)\r\n      1.30  (2011-06-11)\r\n              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\r\n              removed deprecated format-specific test/load functions\r\n              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\r\n              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\r\n              fix inefficiency in decoding 32-bit BMP (David Woo)\r\n      1.29  (2010-08-16)\r\n              various warning fixes from Aurelien Pocheville\r\n      1.28  (2010-08-01)\r\n              fix bug in GIF palette transparency (SpartanJ)\r\n      1.27  (2010-08-01)\r\n              cast-to-stbi_uc to fix warnings\r\n      1.26  (2010-07-24)\r\n              fix bug in file buffering for PNG reported by SpartanJ\r\n      1.25  (2010-07-17)\r\n              refix trans_data warning (Won Chun)\r\n      1.24  (2010-07-12)\r\n              perf improvements reading from files on platforms with lock-heavy fgetc()\r\n              minor perf improvements for jpeg\r\n              deprecated type-specific functions so we'll get feedback if they're needed\r\n              attempt to fix trans_data warning (Won Chun)\r\n      1.23    fixed bug in iPhone support\r\n      1.22  (2010-07-10)\r\n              removed image *writing* support\r\n              stbi_info support from Jetro Lauha\r\n              GIF support from Jean-Marc Lienher\r\n              iPhone PNG-extensions from James Brown\r\n              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\r\n      1.21    fix use of 'stbi_uc' in header (reported by jon blow)\r\n      1.20    added support for Softimage PIC, by Tom Seddon\r\n      1.19    bug in interlaced PNG corruption check (found by ryg)\r\n      1.18  (2008-08-02)\r\n              fix a threading bug (local mutable static)\r\n      1.17    support interlaced PNG\r\n      1.16    major bugfix - stbi__convert_format converted one too many pixels\r\n      1.15    initialize some fields for thread safety\r\n      1.14    fix threadsafe conversion bug\r\n              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\r\n      1.13    threadsafe\r\n      1.12    const qualifiers in the API\r\n      1.11    Support installable IDCT, colorspace conversion routines\r\n      1.10    Fixes for 64-bit (don't use \"unsigned long\")\r\n              optimized upsampling by Fabian \"ryg\" Giesen\r\n      1.09    Fix format-conversion for PSD code (bad global variables!)\r\n      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz\r\n      1.07    attempt to fix C++ warning/errors again\r\n      1.06    attempt to fix C++ warning/errors again\r\n      1.05    fix TGA loading to return correct *comp and use good luminance calc\r\n      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free\r\n      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR\r\n      1.02    support for (subset of) HDR files, float interface for preferred access to them\r\n      1.01    fix bug: possible bug in handling right-side up bmps... not sure\r\n              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\r\n      1.00    interface to zlib that skips zlib header\r\n      0.99    correct handling of alpha in palette\r\n      0.98    TGA loader by lonesock; dynamically add loaders (untested)\r\n      0.97    jpeg errors on too large a file; also catch another malloc failure\r\n      0.96    fix detection of invalid v value - particleman@mollyrocket forum\r\n      0.95    during header scan, seek to markers in case of padding\r\n      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same\r\n      0.93    handle jpegtran output; verbose errors\r\n      0.92    read 4,8,16,24,32-bit BMP files of several formats\r\n      0.91    output 24-bit Windows 3.0 BMP files\r\n      0.90    fix a few more warnings; bump version number to approach 1.0\r\n      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd\r\n      0.60    fix compiling as c++\r\n      0.59    fix warnings: merge Dave Moore's -Wall fixes\r\n      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian\r\n      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\r\n      0.56    fix bug: zlib uncompressed mode len vs. nlen\r\n      0.55    fix bug: restart_interval not initialized to 0\r\n      0.54    allow NULL for 'int *comp'\r\n      0.53    fix bug in png 3->4; speedup png decoding\r\n      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments\r\n      0.51    obey req_comp requests, 1-component jpegs return as 1-component,\r\n              on 'test' only check type, not whether we support this variant\r\n      0.50  (2006-11-19)\r\n              first released version\r\n*/\r\n\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\nof the Software, and to permit persons to whom the Software is furnished to do\r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\r\nsoftware, either in source code form or as a compiled binary, for any purpose,\r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this\r\nsoftware dedicate any and all copyright interest in the software to the public\r\ndomain. We make this dedication for the benefit of the public at large and to\r\nthe detriment of our heirs and successors. We intend this dedication to be an\r\novert act of relinquishment in perpetuity of all present and future rights to\r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/"
        },
        {
          "name": "sod_img_writer.h",
          "type": "blob",
          "size": 74.2890625,
          "content": "/*\r\n* SOD - An Embedded Computer Vision & Machine Learning Library.\r\n* Copyright (C) 2018 - 2023 PixLab| Symisc Systems. https://sod.pixlab.io\r\n* Version 1.1.9\r\n*\r\n* Symisc Systems employs a dual licensing model that offers customers\r\n* a choice of either our open source license (GPLv3) or a commercial\r\n* license.\r\n*\r\n* For information on licensing, redistribution of the SOD library, and for a DISCLAIMER OF ALL WARRANTIES\r\n* please visit:\r\n*     https://pixlab.io/sod\r\n* or contact:\r\n*     licensing@symisc.net\r\n*     support@pixlab.io\r\n*/\r\n/* stb_image_write - v1.16 - public domain - http://nothings.org/stb\r\n   writes out PNG/BMP/TGA/JPEG/HDR images to C stdio - Sean Barrett 2010-2015\r\n                                     no warranty implied; use at your own risk\r\n\r\n   Before #including,\r\n\r\n       #define STB_IMAGE_WRITE_IMPLEMENTATION\r\n\r\n   in the file that you want to have the implementation.\r\n\r\n   Will probably not work correctly with strict-aliasing optimizations.\r\n\r\nABOUT:\r\n\r\n   This header file is a library for writing images to C stdio or a callback.\r\n\r\n   The PNG output is not optimal; it is 20-50% larger than the file\r\n   written by a decent optimizing implementation; though providing a custom\r\n   zlib compress function (see STBIW_ZLIB_COMPRESS) can mitigate that.\r\n   This library is designed for source code compactness and simplicity,\r\n   not optimal image file size or run-time performance.\r\n\r\nBUILDING:\r\n\r\n   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.\r\n   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace\r\n   malloc,realloc,free.\r\n   You can #define STBIW_MEMMOVE() to replace memmove()\r\n   You can #define STBIW_ZLIB_COMPRESS to use a custom zlib-style compress function\r\n   for PNG compression (instead of the builtin one), it must have the following signature:\r\n   unsigned char * my_compress(unsigned char *data, int data_len, int *out_len, int quality);\r\n   The returned data will be freed with STBIW_FREE() (free() by default),\r\n   so it must be heap allocated with STBIW_MALLOC() (malloc() by default),\r\n\r\nUNICODE:\r\n\r\n   If compiling for Windows and you wish to use Unicode filenames, compile\r\n   with\r\n       #define STBIW_WINDOWS_UTF8\r\n   and pass utf8-encoded filenames. Call stbiw_convert_wchar_to_utf8 to convert\r\n   Windows wchar_t filenames to utf8.\r\n\r\nUSAGE:\r\n\r\n   There are five functions, one for each image file format:\r\n\r\n     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);\r\n     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);\r\n     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);\r\n     int stbi_write_jpg(char const *filename, int w, int h, int comp, const void *data, int quality);\r\n     int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);\r\n\r\n     void stbi_flip_vertically_on_write(int flag); // flag is non-zero to flip data vertically\r\n\r\n   There are also five equivalent functions that use an arbitrary write function. You are\r\n   expected to open/close your file-equivalent before and after calling these:\r\n\r\n     int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);\r\n     int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\r\n     int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\r\n     int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);\r\n     int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality);\r\n\r\n   where the callback is:\r\n      void stbi_write_func(void *context, void *data, int size);\r\n\r\n   You can configure it with these global variables:\r\n      int stbi_write_tga_with_rle;             // defaults to true; set to 0 to disable RLE\r\n      int stbi_write_png_compression_level;    // defaults to 8; set to higher for more compression\r\n      int stbi_write_force_png_filter;         // defaults to -1; set to 0..5 to force a filter mode\r\n\r\n\r\n   You can define STBI_WRITE_NO_STDIO to disable the file variant of these\r\n   functions, so the library will not use stdio.h at all. However, this will\r\n   also disable HDR writing, because it requires stdio for formatted output.\r\n\r\n   Each function returns 0 on failure and non-0 on success.\r\n\r\n   The functions create an image file defined by the parameters. The image\r\n   is a rectangle of pixels stored from left-to-right, top-to-bottom.\r\n   Each pixel contains 'comp' channels of data stored interleaved with 8-bits\r\n   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is\r\n   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.\r\n   The *data pointer points to the first byte of the top-left-most pixel.\r\n   For PNG, \"stride_in_bytes\" is the distance in bytes from the first byte of\r\n   a row of pixels to the first byte of the next row of pixels.\r\n\r\n   PNG creates output files with the same number of components as the input.\r\n   The BMP format expands Y to RGB in the file format and does not\r\n   output alpha.\r\n\r\n   PNG supports writing rectangles of data even when the bytes storing rows of\r\n   data are not consecutive in memory (e.g. sub-rectangles of a larger image),\r\n   by supplying the stride between the beginning of adjacent rows. The other\r\n   formats do not. (Thus you cannot write a native-format BMP through the BMP\r\n   writer, both because it is in BGR order and because it may have padding\r\n   at the end of the line.)\r\n\r\n   PNG allows you to set the deflate compression level by setting the global\r\n   variable 'stbi_write_png_compression_level' (it defaults to 8).\r\n\r\n   HDR expects linear float data. Since the format is always 32-bit rgb(e)\r\n   data, alpha (if provided) is discarded, and for monochrome data it is\r\n   replicated across all three channels.\r\n\r\n   TGA supports RLE or non-RLE compressed data. To use non-RLE-compressed\r\n   data, set the global variable 'stbi_write_tga_with_rle' to 0.\r\n\r\n   JPEG does ignore alpha channels in input data; quality is between 1 and 100.\r\n   Higher quality looks better but results in a bigger image.\r\n   JPEG baseline (no JPEG progressive).\r\n\r\nCREDITS:\r\n\r\n\r\n   Sean Barrett           -    PNG/BMP/TGA\r\n   Baldur Karlsson        -    HDR\r\n   Jean-Sebastien Guay    -    TGA monochrome\r\n   Tim Kelsey             -    misc enhancements\r\n   Alan Hickman           -    TGA RLE\r\n   Emmanuel Julien        -    initial file IO callback implementation\r\n   Jon Olick              -    original jo_jpeg.cpp code\r\n   Daniel Gibson          -    integrate JPEG, allow external zlib\r\n   Aarni Koskela          -    allow choosing PNG filter\r\n\r\n   bugfixes:\r\n      github:Chribba\r\n      Guillaume Chereau\r\n      github:jry2\r\n      github:romigrou\r\n      Sergio Gonzalez\r\n      Jonas Karlsson\r\n      Filip Wasil\r\n      Thatcher Ulrich\r\n      github:poppolopoppo\r\n      Patrick Boettcher\r\n      github:xeekworx\r\n      Cap Petschulat\r\n      Simon Rodriguez\r\n      Ivan Tikhonov\r\n      github:ignotion\r\n      Adam Schackart\r\n      Andrew Kensler\r\n\r\nLICENSE\r\n\r\n  See end of file for license information.\r\n\r\n*/\r\n\r\n#ifndef INCLUDE_STB_IMAGE_WRITE_H\r\n#define INCLUDE_STB_IMAGE_WRITE_H\r\n\r\n#include <stdlib.h>\r\n\r\n// if STB_IMAGE_WRITE_STATIC causes problems, try defining STBIWDEF to 'inline' or 'static inline'\r\n#ifndef STBIWDEF\r\n#ifdef STB_IMAGE_WRITE_STATIC\r\n#define STBIWDEF  static\r\n#else\r\n#ifdef __cplusplus\r\n#define STBIWDEF  extern \"C\"\r\n#else\r\n#define STBIWDEF  extern\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#ifndef STB_IMAGE_WRITE_STATIC  // C++ forbids static forward declarations\r\nSTBIWDEF int stbi_write_tga_with_rle;\r\nSTBIWDEF int stbi_write_png_compression_level;\r\nSTBIWDEF int stbi_write_force_png_filter;\r\n#endif\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_png(char const* filename, int w, int h, int comp, const void* data, int stride_in_bytes);\r\nSTBIWDEF int stbi_write_bmp(char const* filename, int w, int h, int comp, const void* data);\r\nSTBIWDEF int stbi_write_tga(char const* filename, int w, int h, int comp, const void* data);\r\nSTBIWDEF int stbi_write_hdr(char const* filename, int w, int h, int comp, const float* data);\r\nSTBIWDEF int stbi_write_jpg(char const* filename, int x, int y, int comp, const void* data, int quality);\r\n\r\n#ifdef STBIW_WINDOWS_UTF8\r\nSTBIWDEF int stbiw_convert_wchar_to_utf8(char* buffer, size_t bufferlen, const wchar_t* input);\r\n#endif\r\n#endif\r\n\r\ntypedef void stbi_write_func(void* context, void* data, int size);\r\n\r\nSTBIWDEF int stbi_write_png_to_func(stbi_write_func* func, void* context, int w, int h, int comp, const void* data, int stride_in_bytes);\r\nSTBIWDEF int stbi_write_bmp_to_func(stbi_write_func* func, void* context, int w, int h, int comp, const void* data);\r\nSTBIWDEF int stbi_write_tga_to_func(stbi_write_func* func, void* context, int w, int h, int comp, const void* data);\r\nSTBIWDEF int stbi_write_hdr_to_func(stbi_write_func* func, void* context, int w, int h, int comp, const float* data);\r\nSTBIWDEF int stbi_write_jpg_to_func(stbi_write_func* func, void* context, int x, int y, int comp, const void* data, int quality);\r\n\r\nSTBIWDEF void stbi_flip_vertically_on_write(int flip_boolean);\r\n\r\n#endif//INCLUDE_STB_IMAGE_WRITE_H\r\n\r\n#ifdef STB_IMAGE_WRITE_IMPLEMENTATION\r\n\r\n#ifdef _WIN32\r\n#ifndef _CRT_SECURE_NO_WARNINGS\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n#ifndef _CRT_NONSTDC_NO_DEPRECATE\r\n#define _CRT_NONSTDC_NO_DEPRECATE\r\n#endif\r\n#endif\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\n#include <stdio.h>\r\n#endif // STBI_WRITE_NO_STDIO\r\n\r\n#include <stdarg.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))\r\n// ok\r\n#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED)\r\n// ok\r\n#else\r\n#error \"Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED).\"\r\n#endif\r\n\r\n#ifndef STBIW_MALLOC\r\n#define STBIW_MALLOC(sz)        malloc(sz)\r\n#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)\r\n#define STBIW_FREE(p)           free(p)\r\n#endif\r\n\r\n#ifndef STBIW_REALLOC_SIZED\r\n#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)\r\n#endif\r\n\r\n\r\n#ifndef STBIW_MEMMOVE\r\n#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)\r\n#endif\r\n\r\n\r\n#ifndef STBIW_ASSERT\r\n#include <assert.h>\r\n#define STBIW_ASSERT(x) assert(x)\r\n#endif\r\n\r\n#define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)\r\n\r\n#ifdef STB_IMAGE_WRITE_STATIC\r\nstatic int stbi_write_png_compression_level = 8;\r\nstatic int stbi_write_tga_with_rle = 1;\r\nstatic int stbi_write_force_png_filter = -1;\r\n#else\r\nint stbi_write_png_compression_level = 8;\r\nint stbi_write_tga_with_rle = 1;\r\nint stbi_write_force_png_filter = -1;\r\n#endif\r\n\r\nstatic int stbi__flip_vertically_on_write = 0;\r\n\r\nSTBIWDEF void stbi_flip_vertically_on_write(int flag)\r\n{\r\n    stbi__flip_vertically_on_write = flag;\r\n}\r\n\r\ntypedef struct\r\n{\r\n    stbi_write_func* func;\r\n    void* context;\r\n    unsigned char buffer[64];\r\n    int buf_used;\r\n} stbi__write_context;\r\n\r\n// initialize a callback-based context\r\nstatic void stbi__start_write_callbacks(stbi__write_context* s, stbi_write_func* c, void* context)\r\n{\r\n    s->func = c;\r\n    s->context = context;\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\n\r\nstatic void stbi__stdio_write(void* context, void* data, int size)\r\n{\r\n    fwrite(data, 1, size, (FILE*)context);\r\n}\r\n\r\n#if defined(_WIN32) && defined(STBIW_WINDOWS_UTF8)\r\n#ifdef __cplusplus\r\n#define STBIW_EXTERN extern \"C\"\r\n#else\r\n#define STBIW_EXTERN extern\r\n#endif\r\nSTBIW_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char* str, int cbmb, wchar_t* widestr, int cchwide);\r\nSTBIW_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t* widestr, int cchwide, char* str, int cbmb, const char* defchar, int* used_default);\r\n\r\nSTBIWDEF int stbiw_convert_wchar_to_utf8(char* buffer, size_t bufferlen, const wchar_t* input)\r\n{\r\n    return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int)bufferlen, NULL, NULL);\r\n}\r\n#endif\r\n\r\nstatic FILE* stbiw__fopen(char const* filename, char const* mode)\r\n{\r\n    FILE* f;\r\n#if defined(_WIN32) && defined(STBIW_WINDOWS_UTF8)\r\n    wchar_t wMode[64];\r\n    wchar_t wFilename[1024];\r\n    if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename) / sizeof(*wFilename)))\r\n        return 0;\r\n\r\n    if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode) / sizeof(*wMode)))\r\n        return 0;\r\n\r\n#if defined(_MSC_VER) && _MSC_VER >= 1400\r\n    if (0 != _wfopen_s(&f, wFilename, wMode))\r\n        f = 0;\r\n#else\r\n    f = _wfopen(wFilename, wMode);\r\n#endif\r\n\r\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\r\n    if (0 != fopen_s(&f, filename, mode))\r\n        f = 0;\r\n#else\r\n    f = fopen(filename, mode);\r\n#endif\r\n    return f;\r\n}\r\n\r\nstatic int stbi__start_write_file(stbi__write_context* s, const char* filename)\r\n{\r\n    FILE* f = stbiw__fopen(filename, \"wb\");\r\n    stbi__start_write_callbacks(s, stbi__stdio_write, (void*)f);\r\n    return f != NULL;\r\n}\r\n\r\nstatic void stbi__end_write_file(stbi__write_context* s)\r\n{\r\n    fclose((FILE*)s->context);\r\n}\r\n\r\n#endif // !STBI_WRITE_NO_STDIO\r\n\r\ntypedef unsigned int stbiw_uint32;\r\ntypedef int stb_image_write_test[sizeof(stbiw_uint32) == 4 ? 1 : -1];\r\n\r\nstatic void stbiw__writefv(stbi__write_context* s, const char* fmt, va_list v)\r\n{\r\n    while (*fmt) {\r\n        switch (*fmt++) {\r\n        case ' ': break;\r\n        case '1': { unsigned char x = STBIW_UCHAR(va_arg(v, int));\r\n            s->func(s->context, &x, 1);\r\n            break; }\r\n        case '2': { int x = va_arg(v, int);\r\n            unsigned char b[2];\r\n            b[0] = STBIW_UCHAR(x);\r\n            b[1] = STBIW_UCHAR(x >> 8);\r\n            s->func(s->context, b, 2);\r\n            break; }\r\n        case '4': { stbiw_uint32 x = va_arg(v, int);\r\n            unsigned char b[4];\r\n            b[0] = STBIW_UCHAR(x);\r\n            b[1] = STBIW_UCHAR(x >> 8);\r\n            b[2] = STBIW_UCHAR(x >> 16);\r\n            b[3] = STBIW_UCHAR(x >> 24);\r\n            s->func(s->context, b, 4);\r\n            break; }\r\n        default:\r\n            STBIW_ASSERT(0);\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void stbiw__writef(stbi__write_context* s, const char* fmt, ...)\r\n{\r\n    va_list v;\r\n    va_start(v, fmt);\r\n    stbiw__writefv(s, fmt, v);\r\n    va_end(v);\r\n}\r\n\r\nstatic void stbiw__write_flush(stbi__write_context* s)\r\n{\r\n    if (s->buf_used) {\r\n        s->func(s->context, &s->buffer, s->buf_used);\r\n        s->buf_used = 0;\r\n    }\r\n}\r\n\r\nstatic void stbiw__putc(stbi__write_context* s, unsigned char c)\r\n{\r\n    s->func(s->context, &c, 1);\r\n}\r\n\r\nstatic void stbiw__write1(stbi__write_context* s, unsigned char a)\r\n{\r\n    if ((size_t)s->buf_used + 1 > sizeof(s->buffer))\r\n        stbiw__write_flush(s);\r\n    s->buffer[s->buf_used++] = a;\r\n}\r\n\r\nstatic void stbiw__write3(stbi__write_context* s, unsigned char a, unsigned char b, unsigned char c)\r\n{\r\n    int n;\r\n    if ((size_t)s->buf_used + 3 > sizeof(s->buffer))\r\n        stbiw__write_flush(s);\r\n    n = s->buf_used;\r\n    s->buf_used = n + 3;\r\n    s->buffer[n + 0] = a;\r\n    s->buffer[n + 1] = b;\r\n    s->buffer[n + 2] = c;\r\n}\r\n\r\nstatic void stbiw__write_pixel(stbi__write_context* s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char* d)\r\n{\r\n    unsigned char bg[3] = { 255, 0, 255 }, px[3];\r\n    int k;\r\n\r\n    if (write_alpha < 0)\r\n        stbiw__write1(s, d[comp - 1]);\r\n\r\n    switch (comp) {\r\n    case 2: // 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case\r\n    case 1:\r\n        if (expand_mono)\r\n            stbiw__write3(s, d[0], d[0], d[0]); // monochrome bmp\r\n        else\r\n            stbiw__write1(s, d[0]);  // monochrome TGA\r\n        break;\r\n    case 4:\r\n        if (!write_alpha) {\r\n            // composite against pink background\r\n            for (k = 0; k < 3; ++k)\r\n                px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;\r\n            stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);\r\n            break;\r\n        }\r\n        /* FALLTHROUGH */\r\n    case 3:\r\n        stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);\r\n        break;\r\n    }\r\n    if (write_alpha > 0)\r\n        stbiw__write1(s, d[comp - 1]);\r\n}\r\n\r\nstatic void stbiw__write_pixels(stbi__write_context* s, int rgb_dir, int vdir, int x, int y, int comp, void* data, int write_alpha, int scanline_pad, int expand_mono)\r\n{\r\n    stbiw_uint32 zero = 0;\r\n    int i, j, j_end;\r\n\r\n    if (y <= 0)\r\n        return;\r\n\r\n    if (stbi__flip_vertically_on_write)\r\n        vdir *= -1;\r\n\r\n    if (vdir < 0) {\r\n        j_end = -1; j = y - 1;\r\n    }\r\n    else {\r\n        j_end = y; j = 0;\r\n    }\r\n\r\n    for (; j != j_end; j += vdir) {\r\n        for (i = 0; i < x; ++i) {\r\n            unsigned char* d = (unsigned char*)data + (j * x + i) * comp;\r\n            stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);\r\n        }\r\n        stbiw__write_flush(s);\r\n        s->func(s->context, &zero, scanline_pad);\r\n    }\r\n}\r\n\r\nstatic int stbiw__outfile(stbi__write_context* s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void* data, int alpha, int pad, const char* fmt, ...)\r\n{\r\n    if (y < 0 || x < 0) {\r\n        return 0;\r\n    }\r\n    else {\r\n        va_list v;\r\n        va_start(v, fmt);\r\n        stbiw__writefv(s, fmt, v);\r\n        va_end(v);\r\n        stbiw__write_pixels(s, rgb_dir, vdir, x, y, comp, data, alpha, pad, expand_mono);\r\n        return 1;\r\n    }\r\n}\r\n\r\nstatic int stbi_write_bmp_core(stbi__write_context* s, int x, int y, int comp, const void* data)\r\n{\r\n    if (comp != 4) {\r\n        // write RGB bitmap\r\n        int pad = (-x * 3) & 3;\r\n        return stbiw__outfile(s, -1, -1, x, y, comp, 1, (void*)data, 0, pad,\r\n            \"11 4 22 4\" \"4 44 22 444444\",\r\n            'B', 'M', 14 + 40 + (x * 3 + pad) * y, 0, 0, 14 + 40,  // file header\r\n            40, x, y, 1, 24, 0, 0, 0, 0, 0, 0);             // bitmap header\r\n    }\r\n    else {\r\n        // RGBA bitmaps need a v4 header\r\n        // use BI_BITFIELDS mode with 32bpp and alpha mask\r\n        // (straight BI_RGB with alpha mask doesn't work in most readers)\r\n        return stbiw__outfile(s, -1, -1, x, y, comp, 1, (void*)data, 1, 0,\r\n            \"11 4 22 4\" \"4 44 22 444444 4444 4 444 444 444 444\",\r\n            'B', 'M', 14 + 108 + x * y * 4, 0, 0, 14 + 108, // file header\r\n            108, x, y, 1, 32, 3, 0, 0, 0, 0, 0, 0xff0000, 0xff00, 0xff, 0xff000000u, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); // bitmap V4 header\r\n    }\r\n}\r\n\r\nSTBIWDEF int stbi_write_bmp_to_func(stbi_write_func* func, void* context, int x, int y, int comp, const void* data)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    stbi__start_write_callbacks(&s, func, context);\r\n    return stbi_write_bmp_core(&s, x, y, comp, data);\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_bmp(char const* filename, int x, int y, int comp, const void* data)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    if (stbi__start_write_file(&s, filename)) {\r\n        int r = stbi_write_bmp_core(&s, x, y, comp, data);\r\n        stbi__end_write_file(&s);\r\n        return r;\r\n    }\r\n    else\r\n        return 0;\r\n}\r\n#endif //!STBI_WRITE_NO_STDIO\r\n\r\nstatic int stbi_write_tga_core(stbi__write_context* s, int x, int y, int comp, void* data)\r\n{\r\n    int has_alpha = (comp == 2 || comp == 4);\r\n    int colorbytes = has_alpha ? comp - 1 : comp;\r\n    int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3\r\n\r\n    if (y < 0 || x < 0)\r\n        return 0;\r\n\r\n    if (!stbi_write_tga_with_rle) {\r\n        return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void*)data, has_alpha, 0,\r\n            \"111 221 2222 11\", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);\r\n    }\r\n    else {\r\n        int i, j, k;\r\n        int jend, jdir;\r\n\r\n        stbiw__writef(s, \"111 221 2222 11\", 0, 0, format + 8, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);\r\n\r\n        if (stbi__flip_vertically_on_write) {\r\n            j = 0;\r\n            jend = y;\r\n            jdir = 1;\r\n        }\r\n        else {\r\n            j = y - 1;\r\n            jend = -1;\r\n            jdir = -1;\r\n        }\r\n        for (; j != jend; j += jdir) {\r\n            unsigned char* row = (unsigned char*)data + j * x * comp;\r\n            int len;\r\n\r\n            for (i = 0; i < x; i += len) {\r\n                unsigned char* begin = row + i * comp;\r\n                int diff = 1;\r\n                len = 1;\r\n\r\n                if (i < x - 1) {\r\n                    ++len;\r\n                    diff = memcmp(begin, row + (i + 1) * comp, comp);\r\n                    if (diff) {\r\n                        const unsigned char* prev = begin;\r\n                        for (k = i + 2; k < x && len < 128; ++k) {\r\n                            if (memcmp(prev, row + k * comp, comp)) {\r\n                                prev += comp;\r\n                                ++len;\r\n                            }\r\n                            else {\r\n                                --len;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (k = i + 2; k < x && len < 128; ++k) {\r\n                            if (!memcmp(begin, row + k * comp, comp)) {\r\n                                ++len;\r\n                            }\r\n                            else {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (diff) {\r\n                    unsigned char header = STBIW_UCHAR(len - 1);\r\n                    stbiw__write1(s, header);\r\n                    for (k = 0; k < len; ++k) {\r\n                        stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);\r\n                    }\r\n                }\r\n                else {\r\n                    unsigned char header = STBIW_UCHAR(len - 129);\r\n                    stbiw__write1(s, header);\r\n                    stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);\r\n                }\r\n            }\r\n        }\r\n        stbiw__write_flush(s);\r\n    }\r\n    return 1;\r\n}\r\n\r\nSTBIWDEF int stbi_write_tga_to_func(stbi_write_func* func, void* context, int x, int y, int comp, const void* data)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    stbi__start_write_callbacks(&s, func, context);\r\n    return stbi_write_tga_core(&s, x, y, comp, (void*)data);\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_tga(char const* filename, int x, int y, int comp, const void* data)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    if (stbi__start_write_file(&s, filename)) {\r\n        int r = stbi_write_tga_core(&s, x, y, comp, (void*)data);\r\n        stbi__end_write_file(&s);\r\n        return r;\r\n    }\r\n    else\r\n        return 0;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Radiance RGBE HDR writer\r\n// by Baldur Karlsson\r\n\r\n#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\n\r\nstatic void stbiw__linear_to_rgbe(unsigned char* rgbe, float* linear)\r\n{\r\n    int exponent;\r\n    float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));\r\n\r\n    if (maxcomp < 1e-32f) {\r\n        rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;\r\n    }\r\n    else {\r\n        float normalize = (float)frexp(maxcomp, &exponent) * 256.0f / maxcomp;\r\n\r\n        rgbe[0] = (unsigned char)(linear[0] * normalize);\r\n        rgbe[1] = (unsigned char)(linear[1] * normalize);\r\n        rgbe[2] = (unsigned char)(linear[2] * normalize);\r\n        rgbe[3] = (unsigned char)(exponent + 128);\r\n    }\r\n}\r\n\r\nstatic void stbiw__write_run_data(stbi__write_context* s, int length, unsigned char databyte)\r\n{\r\n    unsigned char lengthbyte = STBIW_UCHAR(length + 128);\r\n    STBIW_ASSERT(length + 128 <= 255);\r\n    s->func(s->context, &lengthbyte, 1);\r\n    s->func(s->context, &databyte, 1);\r\n}\r\n\r\nstatic void stbiw__write_dump_data(stbi__write_context* s, int length, unsigned char* data)\r\n{\r\n    unsigned char lengthbyte = STBIW_UCHAR(length);\r\n    STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code\r\n    s->func(s->context, &lengthbyte, 1);\r\n    s->func(s->context, data, length);\r\n}\r\n\r\nstatic void stbiw__write_hdr_scanline(stbi__write_context* s, int width, int ncomp, unsigned char* scratch, float* scanline)\r\n{\r\n    unsigned char scanlineheader[4] = { 2, 2, 0, 0 };\r\n    unsigned char rgbe[4];\r\n    float linear[3];\r\n    int x;\r\n\r\n    scanlineheader[2] = (width & 0xff00) >> 8;\r\n    scanlineheader[3] = (width & 0x00ff);\r\n\r\n    /* skip RLE for images too small or large */\r\n    if (width < 8 || width >= 32768) {\r\n        for (x = 0; x < width; x++) {\r\n            switch (ncomp) {\r\n            case 4: /* fallthrough */\r\n            case 3: linear[2] = scanline[x * ncomp + 2];\r\n                linear[1] = scanline[x * ncomp + 1];\r\n                linear[0] = scanline[x * ncomp + 0];\r\n                break;\r\n            default:\r\n                linear[0] = linear[1] = linear[2] = scanline[x * ncomp + 0];\r\n                break;\r\n            }\r\n            stbiw__linear_to_rgbe(rgbe, linear);\r\n            s->func(s->context, rgbe, 4);\r\n        }\r\n    }\r\n    else {\r\n        int c, r;\r\n        /* encode into scratch buffer */\r\n        for (x = 0; x < width; x++) {\r\n            switch (ncomp) {\r\n            case 4: /* fallthrough */\r\n            case 3: linear[2] = scanline[x * ncomp + 2];\r\n                linear[1] = scanline[x * ncomp + 1];\r\n                linear[0] = scanline[x * ncomp + 0];\r\n                break;\r\n            default:\r\n                linear[0] = linear[1] = linear[2] = scanline[x * ncomp + 0];\r\n                break;\r\n            }\r\n            stbiw__linear_to_rgbe(rgbe, linear);\r\n            scratch[x + width * 0] = rgbe[0];\r\n            scratch[x + width * 1] = rgbe[1];\r\n            scratch[x + width * 2] = rgbe[2];\r\n            scratch[x + width * 3] = rgbe[3];\r\n        }\r\n\r\n        s->func(s->context, scanlineheader, 4);\r\n\r\n        /* RLE each component separately */\r\n        for (c = 0; c < 4; c++) {\r\n            unsigned char* comp = &scratch[width * c];\r\n\r\n            x = 0;\r\n            while (x < width) {\r\n                // find first run\r\n                r = x;\r\n                while (r + 2 < width) {\r\n                    if (comp[r] == comp[r + 1] && comp[r] == comp[r + 2])\r\n                        break;\r\n                    ++r;\r\n                }\r\n                if (r + 2 >= width)\r\n                    r = width;\r\n                // dump up to first run\r\n                while (x < r) {\r\n                    int len = r - x;\r\n                    if (len > 128) len = 128;\r\n                    stbiw__write_dump_data(s, len, &comp[x]);\r\n                    x += len;\r\n                }\r\n                // if there's a run, output it\r\n                if (r + 2 < width) { // same test as what we break out of in search loop, so only true if we break'd\r\n                   // find next byte after run\r\n                    while (r < width && comp[r] == comp[x])\r\n                        ++r;\r\n                    // output run up to r\r\n                    while (x < r) {\r\n                        int len = r - x;\r\n                        if (len > 127) len = 127;\r\n                        stbiw__write_run_data(s, len, comp[x]);\r\n                        x += len;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic int stbi_write_hdr_core(stbi__write_context* s, int x, int y, int comp, float* data)\r\n{\r\n    if (y <= 0 || x <= 0 || data == NULL)\r\n        return 0;\r\n    else {\r\n        // Each component is stored separately. Allocate scratch space for full output scanline.\r\n        unsigned char* scratch = (unsigned char*)STBIW_MALLOC(x * 4);\r\n        int i, len;\r\n        char buffer[128];\r\n        char header[] = \"#?RADIANCE\\n# Written by stb_image_write.h\\nFORMAT=32-bit_rle_rgbe\\n\";\r\n        s->func(s->context, header, sizeof(header) - 1);\r\n\r\n#ifdef __STDC_LIB_EXT1__\r\n        len = sprintf_s(buffer, sizeof(buffer), \"EXPOSURE=          1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x);\r\n#else\r\n        len = sprintf(buffer, \"EXPOSURE=          1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x);\r\n#endif\r\n        s->func(s->context, buffer, len);\r\n\r\n        for (i = 0; i < y; i++)\r\n            stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp * x * (stbi__flip_vertically_on_write ? y - 1 - i : i));\r\n        STBIW_FREE(scratch);\r\n        return 1;\r\n    }\r\n}\r\n\r\nSTBIWDEF int stbi_write_hdr_to_func(stbi_write_func* func, void* context, int x, int y, int comp, const float* data)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    stbi__start_write_callbacks(&s, func, context);\r\n    return stbi_write_hdr_core(&s, x, y, comp, (float*)data);\r\n}\r\n\r\nSTBIWDEF int stbi_write_hdr(char const* filename, int x, int y, int comp, const float* data)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    if (stbi__start_write_file(&s, filename)) {\r\n        int r = stbi_write_hdr_core(&s, x, y, comp, (float*)data);\r\n        stbi__end_write_file(&s);\r\n        return r;\r\n    }\r\n    else\r\n        return 0;\r\n}\r\n#endif // STBI_WRITE_NO_STDIO\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// PNG writer\r\n//\r\n\r\n#ifndef STBIW_ZLIB_COMPRESS\r\n// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()\r\n#define stbiw__sbraw(a) ((int *) (void *) (a) - 2)\r\n#define stbiw__sbm(a)   stbiw__sbraw(a)[0]\r\n#define stbiw__sbn(a)   stbiw__sbraw(a)[1]\r\n\r\n#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))\r\n#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)\r\n#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))\r\n\r\n#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))\r\n#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)\r\n#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)\r\n\r\nstatic void* stbiw__sbgrowf(void** arr, int increment, int itemsize)\r\n{\r\n    int m = *arr ? 2 * stbiw__sbm(*arr) + increment : increment + 1;\r\n    void* p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr) * itemsize + sizeof(int) * 2) : 0, itemsize * m + sizeof(int) * 2);\r\n    STBIW_ASSERT(p);\r\n    if (p) {\r\n        if (!*arr) ((int*)p)[1] = 0;\r\n        *arr = (void*)((int*)p + 2);\r\n        stbiw__sbm(*arr) = m;\r\n    }\r\n    return *arr;\r\n}\r\n\r\nstatic unsigned char* stbiw__zlib_flushf(unsigned char* data, unsigned int* bitbuffer, int* bitcount)\r\n{\r\n    while (*bitcount >= 8) {\r\n        stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));\r\n        *bitbuffer >>= 8;\r\n        *bitcount -= 8;\r\n    }\r\n    return data;\r\n}\r\n\r\nstatic int stbiw__zlib_bitrev(int code, int codebits)\r\n{\r\n    int res = 0;\r\n    while (codebits--) {\r\n        res = (res << 1) | (code & 1);\r\n        code >>= 1;\r\n    }\r\n    return res;\r\n}\r\n\r\nstatic unsigned int stbiw__zlib_countm(unsigned char* a, unsigned char* b, int limit)\r\n{\r\n    int i;\r\n    for (i = 0; i < limit && i < 258; ++i)\r\n        if (a[i] != b[i]) break;\r\n    return i;\r\n}\r\n\r\nstatic unsigned int stbiw__zhash(unsigned char* data)\r\n{\r\n    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);\r\n    hash ^= hash << 3;\r\n    hash += hash >> 5;\r\n    hash ^= hash << 4;\r\n    hash += hash >> 17;\r\n    hash ^= hash << 25;\r\n    hash += hash >> 6;\r\n    return hash;\r\n}\r\n\r\n#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))\r\n#define stbiw__zlib_add(code,codebits) \\\r\n      (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())\r\n#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)\r\n// default huffman tables\r\n#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)\r\n#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)\r\n#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)\r\n#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)\r\n#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))\r\n#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))\r\n\r\n#define stbiw__ZHASH   16384\r\n\r\n#endif // STBIW_ZLIB_COMPRESS\r\n\r\nSTBIWDEF unsigned char* stbi_zlib_compress(unsigned char* data, int data_len, int* out_len, int quality)\r\n{\r\n#ifdef STBIW_ZLIB_COMPRESS\r\n    // user provided a zlib compress implementation, use that\r\n    return STBIW_ZLIB_COMPRESS(data, data_len, out_len, quality);\r\n#else // use builtin\r\n    static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };\r\n    static unsigned char  lengtheb[] = { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };\r\n    static unsigned short distc[] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };\r\n    static unsigned char  disteb[] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };\r\n    unsigned int bitbuf = 0;\r\n    int i, j, bitcount = 0;\r\n    unsigned char* out = NULL;\r\n    unsigned char*** hash_table = (unsigned char***)STBIW_MALLOC(stbiw__ZHASH * sizeof(unsigned char**));\r\n    if (hash_table == NULL)\r\n        return NULL;\r\n    if (quality < 5) quality = 5;\r\n\r\n    stbiw__sbpush(out, 0x78);   // DEFLATE 32K window\r\n    stbiw__sbpush(out, 0x5e);   // FLEVEL = 1\r\n    stbiw__zlib_add(1, 1);  // BFINAL = 1\r\n    stbiw__zlib_add(1, 2);  // BTYPE = 1 -- fixed huffman\r\n\r\n    for (i = 0; i < stbiw__ZHASH; ++i)\r\n        hash_table[i] = NULL;\r\n\r\n    i = 0;\r\n    while (i < data_len - 3) {\r\n        // hash next 3 bytes of data to be compressed\r\n        int h = stbiw__zhash(data + i) & (stbiw__ZHASH - 1), best = 3;\r\n        unsigned char* bestloc = 0;\r\n        unsigned char** hlist = hash_table[h];\r\n        int n = stbiw__sbcount(hlist);\r\n        for (j = 0; j < n; ++j) {\r\n            if (hlist[j] - data > i - 32768) { // if entry lies within window\r\n                int d = stbiw__zlib_countm(hlist[j], data + i, data_len - i);\r\n                if (d >= best) { best = d; bestloc = hlist[j]; }\r\n            }\r\n        }\r\n        // when hash table entry is too long, delete half the entries\r\n        if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2 * quality) {\r\n            STBIW_MEMMOVE(hash_table[h], hash_table[h] + quality, sizeof(hash_table[h][0]) * quality);\r\n            stbiw__sbn(hash_table[h]) = quality;\r\n        }\r\n        stbiw__sbpush(hash_table[h], data + i);\r\n\r\n        if (bestloc) {\r\n            // \"lazy matching\" - check match at *next* byte, and if it's better, do cur byte as literal\r\n            h = stbiw__zhash(data + i + 1) & (stbiw__ZHASH - 1);\r\n            hlist = hash_table[h];\r\n            n = stbiw__sbcount(hlist);\r\n            for (j = 0; j < n; ++j) {\r\n                if (hlist[j] - data > i - 32767) {\r\n                    int e = stbiw__zlib_countm(hlist[j], data + i + 1, data_len - i - 1);\r\n                    if (e > best) { // if next match is better, bail on current match\r\n                        bestloc = NULL;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (bestloc) {\r\n            int d = (int)(data + i - bestloc); // distance back\r\n            STBIW_ASSERT(d <= 32767 && best <= 258);\r\n            for (j = 0; best > lengthc[j + 1] - 1; ++j);\r\n            stbiw__zlib_huff(j + 257);\r\n            if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);\r\n            for (j = 0; d > distc[j + 1] - 1; ++j);\r\n            stbiw__zlib_add(stbiw__zlib_bitrev(j, 5), 5);\r\n            if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);\r\n            i += best;\r\n        }\r\n        else {\r\n            stbiw__zlib_huffb(data[i]);\r\n            ++i;\r\n        }\r\n    }\r\n    // write out final bytes\r\n    for (; i < data_len; ++i)\r\n        stbiw__zlib_huffb(data[i]);\r\n    stbiw__zlib_huff(256); // end of block\r\n    // pad with 0 bits to byte boundary\r\n    while (bitcount)\r\n        stbiw__zlib_add(0, 1);\r\n\r\n    for (i = 0; i < stbiw__ZHASH; ++i)\r\n        (void)stbiw__sbfree(hash_table[i]);\r\n    STBIW_FREE(hash_table);\r\n\r\n    // store uncompressed instead if compression was worse\r\n    if (stbiw__sbn(out) > data_len + 2 + ((data_len + 32766) / 32767) * 5) {\r\n        stbiw__sbn(out) = 2;  // truncate to DEFLATE 32K window and FLEVEL = 1\r\n        for (j = 0; j < data_len;) {\r\n            int blocklen = data_len - j;\r\n            if (blocklen > 32767) blocklen = 32767;\r\n            stbiw__sbpush(out, data_len - j == blocklen); // BFINAL = ?, BTYPE = 0 -- no compression\r\n            stbiw__sbpush(out, STBIW_UCHAR(blocklen)); // LEN\r\n            stbiw__sbpush(out, STBIW_UCHAR(blocklen >> 8));\r\n            stbiw__sbpush(out, STBIW_UCHAR(~blocklen)); // NLEN\r\n            stbiw__sbpush(out, STBIW_UCHAR(~blocklen >> 8));\r\n            memcpy(out + stbiw__sbn(out), data + j, blocklen);\r\n            stbiw__sbn(out) += blocklen;\r\n            j += blocklen;\r\n        }\r\n    }\r\n\r\n    {\r\n        // compute adler32 on input\r\n        unsigned int s1 = 1, s2 = 0;\r\n        int blocklen = (int)(data_len % 5552);\r\n        j = 0;\r\n        while (j < data_len) {\r\n            for (i = 0; i < blocklen; ++i) { s1 += data[j + i]; s2 += s1; }\r\n            s1 %= 65521; s2 %= 65521;\r\n            j += blocklen;\r\n            blocklen = 5552;\r\n        }\r\n        stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));\r\n        stbiw__sbpush(out, STBIW_UCHAR(s2));\r\n        stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));\r\n        stbiw__sbpush(out, STBIW_UCHAR(s1));\r\n    }\r\n    *out_len = stbiw__sbn(out);\r\n    // make returned pointer freeable\r\n    STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);\r\n    return (unsigned char*)stbiw__sbraw(out);\r\n#endif // STBIW_ZLIB_COMPRESS\r\n}\r\n\r\nstatic unsigned int stbiw__crc32(unsigned char* buffer, int len)\r\n{\r\n#ifdef STBIW_CRC32\r\n    return STBIW_CRC32(buffer, len);\r\n#else\r\n    static unsigned int crc_table[256] =\r\n    {\r\n       0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\r\n       0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\r\n       0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\r\n       0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\r\n       0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\r\n       0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\r\n       0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\r\n       0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\r\n       0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\r\n       0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\r\n       0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\r\n       0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\r\n       0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\r\n       0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\r\n       0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\r\n       0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\r\n       0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\r\n       0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\r\n       0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\r\n       0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\r\n       0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\r\n       0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\r\n       0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\r\n       0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\r\n       0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\r\n       0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\r\n       0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\r\n       0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\r\n       0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\r\n       0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\r\n       0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\r\n       0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\r\n    };\r\n\r\n    unsigned int crc = ~0u;\r\n    int i;\r\n    for (i = 0; i < len; ++i)\r\n        crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];\r\n    return ~crc;\r\n#endif\r\n}\r\n\r\n#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)\r\n#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));\r\n#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])\r\n\r\nstatic void stbiw__wpcrc(unsigned char** data, int len)\r\n{\r\n    unsigned int crc = stbiw__crc32(*data - len - 4, len + 4);\r\n    stbiw__wp32(*data, crc);\r\n}\r\n\r\nstatic unsigned char stbiw__paeth(int a, int b, int c)\r\n{\r\n    int p = a + b - c, pa = abs(p - a), pb = abs(p - b), pc = abs(p - c);\r\n    if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);\r\n    if (pb <= pc) return STBIW_UCHAR(b);\r\n    return STBIW_UCHAR(c);\r\n}\r\n\r\n// @OPTIMIZE: provide an option that always forces left-predict or paeth predict\r\nstatic void stbiw__encode_png_line(unsigned char* pixels, int stride_bytes, int width, int height, int y, int n, int filter_type, signed char* line_buffer)\r\n{\r\n    static int mapping[] = { 0,1,2,3,4 };\r\n    static int firstmap[] = { 0,1,0,5,6 };\r\n    int* mymap = (y != 0) ? mapping : firstmap;\r\n    int i;\r\n    int type = mymap[filter_type];\r\n    unsigned char* z = pixels + stride_bytes * (stbi__flip_vertically_on_write ? height - 1 - y : y);\r\n    int signed_stride = stbi__flip_vertically_on_write ? -stride_bytes : stride_bytes;\r\n\r\n    if (type == 0) {\r\n        memcpy(line_buffer, z, width * n);\r\n        return;\r\n    }\r\n\r\n    // first loop isn't optimized since it's just one pixel\r\n    for (i = 0; i < n; ++i) {\r\n        switch (type) {\r\n        case 1: line_buffer[i] = z[i]; break;\r\n        case 2: line_buffer[i] = z[i] - z[i - signed_stride]; break;\r\n        case 3: line_buffer[i] = z[i] - (z[i - signed_stride] >> 1); break;\r\n        case 4: line_buffer[i] = (signed char)(z[i] - stbiw__paeth(0, z[i - signed_stride], 0)); break;\r\n        case 5: line_buffer[i] = z[i]; break;\r\n        case 6: line_buffer[i] = z[i]; break;\r\n        }\r\n    }\r\n    switch (type) {\r\n    case 1: for (i = n; i < width * n; ++i) line_buffer[i] = z[i] - z[i - n]; break;\r\n    case 2: for (i = n; i < width * n; ++i) line_buffer[i] = z[i] - z[i - signed_stride]; break;\r\n    case 3: for (i = n; i < width * n; ++i) line_buffer[i] = z[i] - ((z[i - n] + z[i - signed_stride]) >> 1); break;\r\n    case 4: for (i = n; i < width * n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i - n], z[i - signed_stride], z[i - signed_stride - n]); break;\r\n    case 5: for (i = n; i < width * n; ++i) line_buffer[i] = z[i] - (z[i - n] >> 1); break;\r\n    case 6: for (i = n; i < width * n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i - n], 0, 0); break;\r\n    }\r\n}\r\n\r\nSTBIWDEF unsigned char* stbi_write_png_to_mem(const unsigned char* pixels, int stride_bytes, int x, int y, int n, int* out_len)\r\n{\r\n    int force_filter = stbi_write_force_png_filter;\r\n    int ctype[5] = { -1, 0, 4, 2, 6 };\r\n    unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };\r\n    unsigned char* out, * o, * filt, * zlib;\r\n    signed char* line_buffer;\r\n    int j, zlen;\r\n\r\n    if (stride_bytes == 0)\r\n        stride_bytes = x * n;\r\n\r\n    if (force_filter >= 5) {\r\n        force_filter = -1;\r\n    }\r\n\r\n    filt = (unsigned char*)STBIW_MALLOC((x * n + 1) * y); if (!filt) return 0;\r\n    line_buffer = (signed char*)STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }\r\n    for (j = 0; j < y; ++j) {\r\n        int filter_type;\r\n        if (force_filter > -1) {\r\n            filter_type = force_filter;\r\n            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, force_filter, line_buffer);\r\n        }\r\n        else { // Estimate the best filter by running through all of them:\r\n            int best_filter = 0, best_filter_val = 0x7fffffff, est, i;\r\n            for (filter_type = 0; filter_type < 5; filter_type++) {\r\n                stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);\r\n\r\n                // Estimate the entropy of the line using this filter; the less, the better.\r\n                est = 0;\r\n                for (i = 0; i < x * n; ++i) {\r\n                    est += abs((signed char)line_buffer[i]);\r\n                }\r\n                if (est < best_filter_val) {\r\n                    best_filter_val = est;\r\n                    best_filter = filter_type;\r\n                }\r\n            }\r\n            if (filter_type != best_filter) {  // If the last iteration already got us the best filter, don't redo it\r\n                stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, best_filter, line_buffer);\r\n                filter_type = best_filter;\r\n            }\r\n        }\r\n        // when we get here, filter_type contains the filter type, and line_buffer contains the data\r\n        filt[j * (x * n + 1)] = (unsigned char)filter_type;\r\n        STBIW_MEMMOVE(filt + j * (x * n + 1) + 1, line_buffer, x * n);\r\n    }\r\n    STBIW_FREE(line_buffer);\r\n    zlib = stbi_zlib_compress(filt, y * (x * n + 1), &zlen, stbi_write_png_compression_level);\r\n    STBIW_FREE(filt);\r\n    if (!zlib) return 0;\r\n\r\n    // each tag requires 12 bytes of overhead\r\n    out = (unsigned char*)STBIW_MALLOC(8 + 12 + 13 + 12 + zlen + 12);\r\n    if (!out) return 0;\r\n    *out_len = 8 + 12 + 13 + 12 + zlen + 12;\r\n\r\n    o = out;\r\n    STBIW_MEMMOVE(o, sig, 8); o += 8;\r\n    stbiw__wp32(o, 13); // header length\r\n    stbiw__wptag(o, \"IHDR\");\r\n    stbiw__wp32(o, x);\r\n    stbiw__wp32(o, y);\r\n    *o++ = 8;\r\n    *o++ = STBIW_UCHAR(ctype[n]);\r\n    *o++ = 0;\r\n    *o++ = 0;\r\n    *o++ = 0;\r\n    stbiw__wpcrc(&o, 13);\r\n\r\n    stbiw__wp32(o, zlen);\r\n    stbiw__wptag(o, \"IDAT\");\r\n    STBIW_MEMMOVE(o, zlib, zlen);\r\n    o += zlen;\r\n    STBIW_FREE(zlib);\r\n    stbiw__wpcrc(&o, zlen);\r\n\r\n    stbiw__wp32(o, 0);\r\n    stbiw__wptag(o, \"IEND\");\r\n    stbiw__wpcrc(&o, 0);\r\n\r\n    STBIW_ASSERT(o == out + *out_len);\r\n\r\n    return out;\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_png(char const* filename, int x, int y, int comp, const void* data, int stride_bytes)\r\n{\r\n    FILE* f;\r\n    int len;\r\n    unsigned char* png = stbi_write_png_to_mem((const unsigned char*)data, stride_bytes, x, y, comp, &len);\r\n    if (png == NULL) return 0;\r\n\r\n    f = stbiw__fopen(filename, \"wb\");\r\n    if (!f) { STBIW_FREE(png); return 0; }\r\n    fwrite(png, 1, len, f);\r\n    fclose(f);\r\n    STBIW_FREE(png);\r\n    return 1;\r\n}\r\n#endif\r\n\r\nSTBIWDEF int stbi_write_png_to_func(stbi_write_func* func, void* context, int x, int y, int comp, const void* data, int stride_bytes)\r\n{\r\n    int len;\r\n    unsigned char* png = stbi_write_png_to_mem((const unsigned char*)data, stride_bytes, x, y, comp, &len);\r\n    if (png == NULL) return 0;\r\n    func(context, png, len);\r\n    STBIW_FREE(png);\r\n    return 1;\r\n}\r\n\r\n\r\n/* ***************************************************************************\r\n *\r\n * JPEG writer\r\n *\r\n * This is based on Jon Olick's jo_jpeg.cpp:\r\n * public domain Simple, Minimalistic JPEG writer - http://www.jonolick.com/code.html\r\n */\r\n\r\nstatic const unsigned char stbiw__jpg_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,\r\n      24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };\r\n\r\nstatic void stbiw__jpg_writeBits(stbi__write_context* s, int* bitBufP, int* bitCntP, const unsigned short* bs) {\r\n    int bitBuf = *bitBufP, bitCnt = *bitCntP;\r\n    bitCnt += bs[1];\r\n    bitBuf |= bs[0] << (24 - bitCnt);\r\n    while (bitCnt >= 8) {\r\n        unsigned char c = (bitBuf >> 16) & 255;\r\n        stbiw__putc(s, c);\r\n        if (c == 255) {\r\n            stbiw__putc(s, 0);\r\n        }\r\n        bitBuf <<= 8;\r\n        bitCnt -= 8;\r\n    }\r\n    *bitBufP = bitBuf;\r\n    *bitCntP = bitCnt;\r\n}\r\n\r\nstatic void stbiw__jpg_DCT(float* d0p, float* d1p, float* d2p, float* d3p, float* d4p, float* d5p, float* d6p, float* d7p) {\r\n    float d0 = *d0p, d1 = *d1p, d2 = *d2p, d3 = *d3p, d4 = *d4p, d5 = *d5p, d6 = *d6p, d7 = *d7p;\r\n    float z1, z2, z3, z4, z5, z11, z13;\r\n\r\n    float tmp0 = d0 + d7;\r\n    float tmp7 = d0 - d7;\r\n    float tmp1 = d1 + d6;\r\n    float tmp6 = d1 - d6;\r\n    float tmp2 = d2 + d5;\r\n    float tmp5 = d2 - d5;\r\n    float tmp3 = d3 + d4;\r\n    float tmp4 = d3 - d4;\r\n\r\n    // Even part\r\n    float tmp10 = tmp0 + tmp3;   // phase 2\r\n    float tmp13 = tmp0 - tmp3;\r\n    float tmp11 = tmp1 + tmp2;\r\n    float tmp12 = tmp1 - tmp2;\r\n\r\n    d0 = tmp10 + tmp11;       // phase 3\r\n    d4 = tmp10 - tmp11;\r\n\r\n    z1 = (tmp12 + tmp13) * 0.707106781f; // c4\r\n    d2 = tmp13 + z1;       // phase 5\r\n    d6 = tmp13 - z1;\r\n\r\n    // Odd part\r\n    tmp10 = tmp4 + tmp5;       // phase 2\r\n    tmp11 = tmp5 + tmp6;\r\n    tmp12 = tmp6 + tmp7;\r\n\r\n    // The rotator is modified from fig 4-8 to avoid extra negations.\r\n    z5 = (tmp10 - tmp12) * 0.382683433f; // c6\r\n    z2 = tmp10 * 0.541196100f + z5; // c2-c6\r\n    z4 = tmp12 * 1.306562965f + z5; // c2+c6\r\n    z3 = tmp11 * 0.707106781f; // c4\r\n\r\n    z11 = tmp7 + z3;      // phase 5\r\n    z13 = tmp7 - z3;\r\n\r\n    *d5p = z13 + z2;         // phase 6\r\n    *d3p = z13 - z2;\r\n    *d1p = z11 + z4;\r\n    *d7p = z11 - z4;\r\n\r\n    *d0p = d0;  *d2p = d2;  *d4p = d4;  *d6p = d6;\r\n}\r\n\r\nstatic void stbiw__jpg_calcBits(int val, unsigned short bits[2]) {\r\n    int tmp1 = val < 0 ? -val : val;\r\n    val = val < 0 ? val - 1 : val;\r\n    bits[1] = 1;\r\n    while (tmp1 >>= 1) {\r\n        ++bits[1];\r\n    }\r\n    bits[0] = val & ((1 << bits[1]) - 1);\r\n}\r\n\r\nstatic int stbiw__jpg_processDU(stbi__write_context* s, int* bitBuf, int* bitCnt, float* CDU, int du_stride, float* fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {\r\n    const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };\r\n    const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };\r\n    int dataOff, i, j, n, diff, end0pos, x, y;\r\n    int DU[64];\r\n\r\n    // DCT rows\r\n    for (dataOff = 0, n = du_stride * 8; dataOff < n; dataOff += du_stride) {\r\n        stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff + 1], &CDU[dataOff + 2], &CDU[dataOff + 3], &CDU[dataOff + 4], &CDU[dataOff + 5], &CDU[dataOff + 6], &CDU[dataOff + 7]);\r\n    }\r\n    // DCT columns\r\n    for (dataOff = 0; dataOff < 8; ++dataOff) {\r\n        stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff + du_stride], &CDU[dataOff + du_stride * 2], &CDU[dataOff + du_stride * 3], &CDU[dataOff + du_stride * 4],\r\n            &CDU[dataOff + du_stride * 5], &CDU[dataOff + du_stride * 6], &CDU[dataOff + du_stride * 7]);\r\n    }\r\n    // Quantize/descale/zigzag the coefficients\r\n    for (y = 0, j = 0; y < 8; ++y) {\r\n        for (x = 0; x < 8; ++x, ++j) {\r\n            float v;\r\n            i = y * du_stride + x;\r\n            v = CDU[i] * fdtbl[j];\r\n            // DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));\r\n            // ceilf() and floorf() are C99, not C89, but I /think/ they're not needed here anyway?\r\n            DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? v - 0.5f : v + 0.5f);\r\n        }\r\n    }\r\n\r\n    // Encode DC\r\n    diff = DU[0] - DC;\r\n    if (diff == 0) {\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0]);\r\n    }\r\n    else {\r\n        unsigned short bits[2];\r\n        stbiw__jpg_calcBits(diff, bits);\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]]);\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);\r\n    }\r\n    // Encode ACs\r\n    end0pos = 63;\r\n    for (; (end0pos > 0) && (DU[end0pos] == 0); --end0pos) {\r\n    }\r\n    // end0pos = first element in reverse order !=0\r\n    if (end0pos == 0) {\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);\r\n        return DU[0];\r\n    }\r\n    for (i = 1; i <= end0pos; ++i) {\r\n        int startpos = i;\r\n        int nrzeroes;\r\n        unsigned short bits[2];\r\n        for (; DU[i] == 0 && i <= end0pos; ++i) {\r\n        }\r\n        nrzeroes = i - startpos;\r\n        if (nrzeroes >= 16) {\r\n            int lng = nrzeroes >> 4;\r\n            int nrmarker;\r\n            for (nrmarker = 1; nrmarker <= lng; ++nrmarker)\r\n                stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes);\r\n            nrzeroes &= 15;\r\n        }\r\n        stbiw__jpg_calcBits(DU[i], bits);\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes << 4) + bits[1]]);\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);\r\n    }\r\n    if (end0pos != 63) {\r\n        stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);\r\n    }\r\n    return DU[0];\r\n}\r\n\r\nstatic int stbi_write_jpg_core(stbi__write_context* s, int width, int height, int comp, const void* data, int quality) {\r\n    // Constants that don't pollute global namespace\r\n    static const unsigned char std_dc_luminance_nrcodes[] = { 0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0 };\r\n    static const unsigned char std_dc_luminance_values[] = { 0,1,2,3,4,5,6,7,8,9,10,11 };\r\n    static const unsigned char std_ac_luminance_nrcodes[] = { 0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d };\r\n    static const unsigned char std_ac_luminance_values[] = {\r\n       0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,\r\n       0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,\r\n       0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,\r\n       0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\r\n       0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,\r\n       0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,\r\n       0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa\r\n    };\r\n    static const unsigned char std_dc_chrominance_nrcodes[] = { 0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };\r\n    static const unsigned char std_dc_chrominance_values[] = { 0,1,2,3,4,5,6,7,8,9,10,11 };\r\n    static const unsigned char std_ac_chrominance_nrcodes[] = { 0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77 };\r\n    static const unsigned char std_ac_chrominance_values[] = {\r\n       0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,\r\n       0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,\r\n       0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,\r\n       0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,\r\n       0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,\r\n       0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,\r\n       0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa\r\n    };\r\n    // Huffman tables\r\n    static const unsigned short YDC_HT[256][2] = { {0,2},{2,3},{3,3},{4,3},{5,3},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9} };\r\n    static const unsigned short UVDC_HT[256][2] = { {0,2},{1,2},{2,2},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9},{1022,10},{2046,11} };\r\n    static const unsigned short YAC_HT[256][2] = {\r\n       {10,4},{0,2},{1,2},{4,3},{11,4},{26,5},{120,7},{248,8},{1014,10},{65410,16},{65411,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {12,4},{27,5},{121,7},{502,9},{2038,11},{65412,16},{65413,16},{65414,16},{65415,16},{65416,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {28,5},{249,8},{1015,10},{4084,12},{65417,16},{65418,16},{65419,16},{65420,16},{65421,16},{65422,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {58,6},{503,9},{4085,12},{65423,16},{65424,16},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {59,6},{1016,10},{65430,16},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {122,7},{2039,11},{65438,16},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {123,7},{4086,12},{65446,16},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {250,8},{4087,12},{65454,16},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {504,9},{32704,15},{65462,16},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {505,9},{65470,16},{65471,16},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {506,9},{65479,16},{65480,16},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {1017,10},{65488,16},{65489,16},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {1018,10},{65497,16},{65498,16},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {2040,11},{65506,16},{65507,16},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {65515,16},{65516,16},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {2041,11},{65525,16},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}\r\n    };\r\n    static const unsigned short UVAC_HT[256][2] = {\r\n       {0,2},{1,2},{4,3},{10,4},{24,5},{25,5},{56,6},{120,7},{500,9},{1014,10},{4084,12},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {11,4},{57,6},{246,8},{501,9},{2038,11},{4085,12},{65416,16},{65417,16},{65418,16},{65419,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {26,5},{247,8},{1015,10},{4086,12},{32706,15},{65420,16},{65421,16},{65422,16},{65423,16},{65424,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {27,5},{248,8},{1016,10},{4087,12},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{65430,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {58,6},{502,9},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{65438,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {59,6},{1017,10},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{65446,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {121,7},{2039,11},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{65454,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {122,7},{2040,11},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{65462,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {249,8},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{65470,16},{65471,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {503,9},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{65479,16},{65480,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {504,9},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{65488,16},{65489,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {505,9},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{65497,16},{65498,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {506,9},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{65506,16},{65507,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {2041,11},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{65515,16},{65516,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {16352,14},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{65525,16},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n       {1018,10},{32707,15},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}\r\n    };\r\n    static const int YQT[] = { 16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,\r\n                              37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99 };\r\n    static const int UVQT[] = { 17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,\r\n                               99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99 };\r\n    static const float aasf[] = { 1.0f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f, 1.175875602f * 2.828427125f,\r\n                                  1.0f * 2.828427125f, 0.785694958f * 2.828427125f, 0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f };\r\n\r\n    int row, col, i, k, subsample;\r\n    float fdtbl_Y[64], fdtbl_UV[64];\r\n    unsigned char YTable[64], UVTable[64];\r\n\r\n    if (!data || !width || !height || comp > 4 || comp < 1) {\r\n        return 0;\r\n    }\r\n\r\n    quality = quality ? quality : 90;\r\n    subsample = quality <= 90 ? 1 : 0;\r\n    quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;\r\n    quality = quality < 50 ? 5000 / quality : 200 - quality * 2;\r\n\r\n    for (i = 0; i < 64; ++i) {\r\n        int uvti, yti = (YQT[i] * quality + 50) / 100;\r\n        YTable[stbiw__jpg_ZigZag[i]] = (unsigned char)(yti < 1 ? 1 : yti > 255 ? 255 : yti);\r\n        uvti = (UVQT[i] * quality + 50) / 100;\r\n        UVTable[stbiw__jpg_ZigZag[i]] = (unsigned char)(uvti < 1 ? 1 : uvti > 255 ? 255 : uvti);\r\n    }\r\n\r\n    for (row = 0, k = 0; row < 8; ++row) {\r\n        for (col = 0; col < 8; ++col, ++k) {\r\n            fdtbl_Y[k] = 1 / (YTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);\r\n            fdtbl_UV[k] = 1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);\r\n        }\r\n    }\r\n\r\n    // Write Headers\r\n    {\r\n        static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };\r\n        static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };\r\n        const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height >> 8),STBIW_UCHAR(height),(unsigned char)(width >> 8),STBIW_UCHAR(width),\r\n                                        3,1,(unsigned char)(subsample ? 0x22 : 0x11),0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };\r\n        s->func(s->context, (void*)head0, sizeof(head0));\r\n        s->func(s->context, (void*)YTable, sizeof(YTable));\r\n        stbiw__putc(s, 1);\r\n        s->func(s->context, UVTable, sizeof(UVTable));\r\n        s->func(s->context, (void*)head1, sizeof(head1));\r\n        s->func(s->context, (void*)(std_dc_luminance_nrcodes + 1), sizeof(std_dc_luminance_nrcodes) - 1);\r\n        s->func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values));\r\n        stbiw__putc(s, 0x10); // HTYACinfo\r\n        s->func(s->context, (void*)(std_ac_luminance_nrcodes + 1), sizeof(std_ac_luminance_nrcodes) - 1);\r\n        s->func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values));\r\n        stbiw__putc(s, 1); // HTUDCinfo\r\n        s->func(s->context, (void*)(std_dc_chrominance_nrcodes + 1), sizeof(std_dc_chrominance_nrcodes) - 1);\r\n        s->func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values));\r\n        stbiw__putc(s, 0x11); // HTUACinfo\r\n        s->func(s->context, (void*)(std_ac_chrominance_nrcodes + 1), sizeof(std_ac_chrominance_nrcodes) - 1);\r\n        s->func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values));\r\n        s->func(s->context, (void*)head2, sizeof(head2));\r\n    }\r\n\r\n    // Encode 8x8 macroblocks\r\n    {\r\n        static const unsigned short fillBits[] = { 0x7F, 7 };\r\n        int DCY = 0, DCU = 0, DCV = 0;\r\n        int bitBuf = 0, bitCnt = 0;\r\n        // comp == 2 is grey+alpha (alpha is ignored)\r\n        int ofsG = comp > 2 ? 1 : 0, ofsB = comp > 2 ? 2 : 0;\r\n        const unsigned char* dataR = (const unsigned char*)data;\r\n        const unsigned char* dataG = dataR + ofsG;\r\n        const unsigned char* dataB = dataR + ofsB;\r\n        int x, y, pos;\r\n        if (subsample) {\r\n            for (y = 0; y < height; y += 16) {\r\n                for (x = 0; x < width; x += 16) {\r\n                    float Y[256], U[256], V[256];\r\n                    for (row = y, pos = 0; row < y + 16; ++row) {\r\n                        // row >= height => use last input row\r\n                        int clamped_row = (row < height) ? row : height - 1;\r\n                        int base_p = (stbi__flip_vertically_on_write ? (height - 1 - clamped_row) : clamped_row) * width * comp;\r\n                        for (col = x; col < x + 16; ++col, ++pos) {\r\n                            // if col >= width => use pixel from last input column\r\n                            int p = base_p + ((col < width) ? col : (width - 1)) * comp;\r\n                            float r = dataR[p], g = dataG[p], b = dataB[p];\r\n                            Y[pos] = +0.29900f * r + 0.58700f * g + 0.11400f * b - 128;\r\n                            U[pos] = -0.16874f * r - 0.33126f * g + 0.50000f * b;\r\n                            V[pos] = +0.50000f * r - 0.41869f * g - 0.08131f * b;\r\n                        }\r\n                    }\r\n                    DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y + 0, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\r\n                    DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y + 8, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\r\n                    DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y + 128, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\r\n                    DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y + 136, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\r\n\r\n                    // subsample U,V\r\n                    {\r\n                        float subU[64], subV[64];\r\n                        int yy, xx;\r\n                        for (yy = 0, pos = 0; yy < 8; ++yy) {\r\n                            for (xx = 0; xx < 8; ++xx, ++pos) {\r\n                                int j = yy * 32 + xx * 2;\r\n                                subU[pos] = (U[j + 0] + U[j + 1] + U[j + 16] + U[j + 17]) * 0.25f;\r\n                                subV[pos] = (V[j + 0] + V[j + 1] + V[j + 16] + V[j + 17]) * 0.25f;\r\n                            }\r\n                        }\r\n                        DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subU, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\r\n                        DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subV, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (y = 0; y < height; y += 8) {\r\n                for (x = 0; x < width; x += 8) {\r\n                    float Y[64], U[64], V[64];\r\n                    for (row = y, pos = 0; row < y + 8; ++row) {\r\n                        // row >= height => use last input row\r\n                        int clamped_row = (row < height) ? row : height - 1;\r\n                        int base_p = (stbi__flip_vertically_on_write ? (height - 1 - clamped_row) : clamped_row) * width * comp;\r\n                        for (col = x; col < x + 8; ++col, ++pos) {\r\n                            // if col >= width => use pixel from last input column\r\n                            int p = base_p + ((col < width) ? col : (width - 1)) * comp;\r\n                            float r = dataR[p], g = dataG[p], b = dataB[p];\r\n                            Y[pos] = +0.29900f * r + 0.58700f * g + 0.11400f * b - 128;\r\n                            U[pos] = -0.16874f * r - 0.33126f * g + 0.50000f * b;\r\n                            V[pos] = +0.50000f * r - 0.41869f * g - 0.08131f * b;\r\n                        }\r\n                    }\r\n\r\n                    DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y, 8, fdtbl_Y, DCY, YDC_HT, YAC_HT);\r\n                    DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, U, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\r\n                    DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, V, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Do the bit alignment of the EOI marker\r\n        stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits);\r\n    }\r\n\r\n    // EOI\r\n    stbiw__putc(s, 0xFF);\r\n    stbiw__putc(s, 0xD9);\r\n\r\n    return 1;\r\n}\r\n\r\nSTBIWDEF int stbi_write_jpg_to_func(stbi_write_func* func, void* context, int x, int y, int comp, const void* data, int quality)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    stbi__start_write_callbacks(&s, func, context);\r\n    return stbi_write_jpg_core(&s, x, y, comp, (void*)data, quality);\r\n}\r\n\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_jpg(char const* filename, int x, int y, int comp, const void* data, int quality)\r\n{\r\n    stbi__write_context s = { 0 };\r\n    if (stbi__start_write_file(&s, filename)) {\r\n        int r = stbi_write_jpg_core(&s, x, y, comp, data, quality);\r\n        stbi__end_write_file(&s);\r\n        return r;\r\n    }\r\n    else\r\n        return 0;\r\n}\r\n#endif\r\n\r\n#endif // STB_IMAGE_WRITE_IMPLEMENTATION\r\n\r\n/* Revision history\r\n      1.16  (2021-07-11)\r\n             make Deflate code emit uncompressed blocks when it would otherwise expand\r\n             support writing BMPs with alpha channel\r\n      1.15  (2020-07-13) unknown\r\n      1.14  (2020-02-02) updated JPEG writer to downsample chroma channels\r\n      1.13\r\n      1.12\r\n      1.11  (2019-08-11)\r\n\r\n      1.10  (2019-02-07)\r\n             support utf8 filenames in Windows; fix warnings and platform ifdefs\r\n      1.09  (2018-02-11)\r\n             fix typo in zlib quality API, improve STB_I_W_STATIC in C++\r\n      1.08  (2018-01-29)\r\n             add stbi__flip_vertically_on_write, external zlib, zlib quality, choose PNG filter\r\n      1.07  (2017-07-24)\r\n             doc fix\r\n      1.06 (2017-07-23)\r\n             writing JPEG (using Jon Olick's code)\r\n      1.05   ???\r\n      1.04 (2017-03-03)\r\n             monochrome BMP expansion\r\n      1.03   ???\r\n      1.02 (2016-04-02)\r\n             avoid allocating large structures on the stack\r\n      1.01 (2016-01-16)\r\n             STBIW_REALLOC_SIZED: support allocators with no realloc support\r\n             avoid race-condition in crc initialization\r\n             minor compile issues\r\n      1.00 (2015-09-14)\r\n             installable file IO function\r\n      0.99 (2015-09-13)\r\n             warning fixes; TGA rle support\r\n      0.98 (2015-04-08)\r\n             added STBIW_MALLOC, STBIW_ASSERT etc\r\n      0.97 (2015-01-18)\r\n             fixed HDR asserts, rewrote HDR rle logic\r\n      0.96 (2015-01-17)\r\n             add HDR output\r\n             fix monochrome BMP\r\n      0.95 (2014-08-17)\r\n             add monochrome TGA output\r\n      0.94 (2014-05-31)\r\n             rename private functions to avoid conflicts with stb_image.h\r\n      0.93 (2014-05-27)\r\n             warning fixes\r\n      0.92 (2010-08-01)\r\n             casts to unsigned char to fix warnings\r\n      0.91 (2010-07-17)\r\n             first public release\r\n      0.90   first internal release\r\n*/\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\nof the Software, and to permit persons to whom the Software is furnished to do\r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\r\nsoftware, either in source code form or as a compiled binary, for any purpose,\r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this\r\nsoftware dedicate any and all copyright interest in the software to the public\r\ndomain. We make this dedication for the benefit of the public at large and to\r\nthe detriment of our heirs and successors. We intend this dedication to be an\r\novert act of relinquishment in perpetuity of all present and future rights to\r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/"
        }
      ]
    }
  ]
}