{
  "metadata": {
    "timestamp": 1736709947214,
    "page": 486,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ChrisJohnsen/tmux-MacOSX-pasteboard",
      "stars": 2382,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03515625,
          "content": "*.o\ntest\nreattach-to-user-namespace\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.333984375,
          "content": "Copyright (c) 2011-2013, Chris Johnsen <chris_johnsen@pobox.com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n    1. Redistributions of source code must retain the above\n       copyright notice, this list of conditions and the following\n       disclaimer.\n\n    2. Redistributions in binary form must reproduce the above\n       copyright notice, this list of conditions and the following\n       disclaimer in the documentation and/or other materials\n       provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5390625,
          "content": "# use for ppc or i386 support:\n# ARCHES = i386 ppc x86_64\nARCHES = x86_64\nARCH_FLAGS = $(ARCHES:%=-arch %)\n\nCFLAGS ?= -Wall -Wextra -ansi -pedantic -std=c99\nCFLAGS += $(ARCH_FLAGS) -mmacosx-version-min=10.5\nLDFLAGS += $(ARCH_FLAGS)\n\nMSG_BINARIES = test reattach-to-user-namespace\nMSG_OBJECTS = $(MSG_BINARIES:%=%.o) msg.o move_to_user_namespace.o\n\nOBJECTS = $(MSG_OBJECTS)\nBINARIES = $(MSG_BINARIES)\n\nall: $(BINARIES)\n\n$(MSG_BINARIES): msg.o move_to_user_namespace.o\n$(MSG_OBJECTS): msg.h move_to_user_namespace.h\n\nclean:\n\trm -f $(BINARIES) $(OBJECTS)\n"
        },
        {
          "name": "NOTES",
          "type": "blob",
          "size": 6.51171875,
          "content": "Processes started under \"stock\" tmux and screen can not access the\nMac OS X pasteboard.\n\nApple publishes their modified source for screen.\n\n    10.4     http://www.opensource.apple.com/source/screen/screen-6.1/\n    10.4.11  http://www.opensource.apple.com/source/screen/screen-6.2/\n    10.5     http://www.opensource.apple.com/source/screen/screen-12/\n    10.5.8   http://www.opensource.apple.com/source/screen/screen-12/\n    10.6     http://www.opensource.apple.com/source/screen/screen-16/\n    10.6.6   http://www.opensource.apple.com/source/screen/screen-19/\n\nSomeone adapted Apple's 10.6 screen changes to tmux.\n\n    https://gist.github.com/644805\n\nBasically, it involves replacing the call to daemon() with a\ncall to the undocumented function _vprocmgr_detach_from_console().\n\n    Note: 'upstream' screen vs. Apple's 10.6.6 screen\n        http://git.savannah.gnu.org/cgit/screen.git/tree/src/screen.c\n        http://www.opensource.apple.com/source/screen/screen-19/screen/screen.c\n\n        The call to _vprocmgr_detach_from_console was a pure\n        addition, not a replacement for daemon(3) like the above\n        patch does in tmux.\n\nWhen I patched recent tmux HEAD (via\ngit://github.com/ThomasAdam/tmux.git master), the resulting\nunder-tmux shells could access the pasteboard (e.g. pbpaste).\nHowever, it resulted in many warning messages from libevent.\n\n    [warn] event_del: event has no event_base set.\n\nI see eleven of these messages just doing\n\n    ./tmux new 'echo something'\n\nAdditionally, if I start a shell (instead of just an \"echo\"), I see\nthe message after every key press, until I press ESC. Then the\nmessage per key press disappears and I only see ten of the messages\nafter tmux exiting the shell (and thus tmux).\n\nThis appears to be a bad interaction between not forking (via\ndaemon(3)) and the way libevent is used (maybe just libevent 2.0).\n\nWhat I want to do here is to make a minimal test rig for\ndaemon()/_vprocmgr_detach_from_console() and libevent to see what\ncan be done to ameliorate the problem.\n\nFindings from testing on 10.6.6:\n\n    Calling _vprocmgr_detach_from_console() by itself does not\n    impede a child from successfully using pbpaste. The result from\n    getpid() is the same before and after the call, so whatever it\n    does, it does not fork internally.\n    \n    Calling daemon() does prevent a child from successfully using pbpaste.\n\n    A hand-rolled daemon() (fork, setsid, open(/dev/null), dup2 for\n    0-2) does not impede a child from successfully using pbpaste.\n\nI was able to dig up daemon() and the vproc functions. Here are the\nsources for 10.6.6:\n\n    http://www.opensource.apple.com/source/Libc/Libc-594.9.4/gen/daemon-fbsd.c\n    http://www.opensource.apple.com/source/launchd/launchd-329.3.3/launchd/src/libvproc.c\n\nThe annoying thing that the system daemon(3) is doing is that it\nmoves to the root \"bootstrap namespace\". The bootstrap service is\nwhat programs use to get access to other services. Being in the root\nnamespace prevents the process from accessing the pasteboard service\n(which is only in a per-user namespace in 10.5 and beyond).\n\nAfter some more subtle testing, I found that (when using\na hand-rolled daemon()) the call to _vprocmgr_detach_from_console()\nlets the children of tmux (the whole per-session bootstrap\nnamespace?) maintain access to the pasteboard even after the session\ninitiator has exited. For example: during a GUI login, SSH back to\nlocalhost, start a new tmux server there, detach from it. Attach\nfrom elsewhere and pbpaste still works. Exit from the SSH connection\n(the one that started the tmux process). If we used\n_vprocmgr_detach_from_console, then the children of tmux can still\naccess the pasteboard. If we did not call it, then they lose access\nto the pasteboard (the namespace was revoked?).\n\nPossible Resolutions\n--------------------\n\n  Use daemon() from compat/daemon.c and _vprocmgr_detach_from_console()\n\n    autoconf\n      check for 'broken' daemon would require Darwin-specific stuff\n        Not even sure how best to do that. Could check whether\n        (after a call to daemon())  the output from `launchctl\n        bslist` contains \"com.apple.pasteboard\" (or do the\n        equivalent in straight C, if it does not use even more\n        private APIs).\n      assume Darwin daemon(3) is broken for our purposes\n        use compat/daemon\n          would it be deterministically used instead of libSystem daemon()?\n            could #define daemon compat_daemon for compat/daemon.c and server.c\n        still need call to _vprocmgr_detach_from_console()\n          make osdep_daemon() and call it after (compat) daemon()\n\n  Use system daemon(3) and find a way to re-attach to the/a user\n  session.\n\n    Per TN2083, launchd creates non-GUI per-session namespaces for\n    accepted SSH connections based on the SSH launchd plist having\n    a SessionCreate key. Looking at the launchd code, it seems that\n    it does this via CreateSession(0,0) from the Security Framework.\n\n        launchd_SessionCreate in\n            http://www.opensource.apple.com/source/launchd/launchd-329.3.3/launchd/src/launchd.c\n\n    Or maybe _vprocmgr_move_subset_to_user(), like the 10.5(?)\n    screen code used?\n\nCurrent Thinking\n----------------\n\n  Adding calls to undocumented (private?) Apple APIs in tmux seems\n  like a fragile solution. Each release of Mac OS X might break\n  pre-built tmux binaries. The risks of \"hard\" breaks (tmux errors\n  out on startup) could be eliminated by using dlsym(3) to access\n  the required function(s). Even with that precaution, Apple may\n  break the functions in incompatible ways (they added a parameter\n  to _vprocmgr_move_subset_to_user() in 10.6; the parameter seems to\n  be unused, so we may be able to \"get away\" with calling it without\n  the extra parameter, but that depends entirely on the calling\n  convention).\n\n  Since tmux's call to daemon(3) effectively isolates it from the\n  per-user bootstrap namespace, there is no way to \"reconnect\" tmux\n  itself without patching it. But, we can arrange for (some of)\n  tmux's children to be reconnected. Any child can make its own call\n  to _vprocmgr_move_subset_to_user() to reconnect itself (and its\n  future(?) children).\n\n  I have written a wrapper program that calls the private function\n  and then execs into the command specified in its arguments. I have\n  configured tmux's default-command to be \"wrapper -l shell\" (-l\n  makes the shell's argv[0] be \"-shell\"). This has successfully let\n  me run pbpaste(1) (and other commands that access the pasteboard)\n  from inside tmux sessions. Not all children of tmux are covered by\n  this workaround, but it seems that it is a \"90% solution\".\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.2236328125,
          "content": "# Quick Summary\n\n* Using the Mac OS X programs *pbpaste* and *pbcopy* under old\n  versions of *tmux* may not work.  \n  Other services and unpatched builds of *screen* are also affected.\n\n* You may not even need the program from this repository!\n\n  *tmux* version 2.6 (2017 September) incorporated the functionality\n  of the wrapper program. If you are using a new enough *tmux*, you\n  may be able to skip using the wrapper in your *tmux*\n  configuration.\n\n* Certain undocumented, private API functions can fix the problem.\n\n* Because the functions are private, undocumented, and unstable (one\n  acquired an extra argument in 10.6), I think using a small wrapper\n  program might be better than patching *tmux*.\n\nThus, my wrapper-based workaround:\n\n1. Compile *reattach-to-user-namespace* from this repository.  \n   Make it available in your PATH (or use the absolute pathname in\n   the next step).\n\n        make reattach-to-user-namespace &&\n        cp reattach-to-user-namespace ~/bin\n\n   Alternatively, you can install it with [*MacPorts*][MacPorts] or\n   [*Homebrew*][Homebrew]:\n\n        port install tmux-pasteboard\n\n        brew install reattach-to-user-namespace\n\n[MacPorts]: http://www.macports.org\n[Homebrew]: http://brew.sh\n\n1. Configure *tmux* to use this wrapper program to start the shell\n   for each new window.\n\n    In `.tmux.conf`:\n\n        set-option -g default-command \"reattach-to-user-namespace -l zsh\"\n\n    See the file `Usage.md` for other configuration and usage\n    techniques (conditional use for cross-platform configurations,\n    fine-grained usage, etc.)\n\n1. Restart your *tmux* server (or start a new one, or just\n   reconfigure your existing one).\n\n    To kill your existing *tmux* server (and everything running\n    “inside” it!):\n\n        tmux kill-server\n\n1. Enjoy being able to use *pbpaste*, *pbcopy*, etc. in new shell\n   windows.\n\n# Purpose of These Programs\n\nThe programs in this repository were created to diagnose and enable\nreliable access to the Mac OS X pasteboard for programs run under\n[*tmux*][1] and unmodified versions of [*screen*][2].\n\nSee the “Beyond Pasteboard Access” section of the `Usage.md` file\nfor other programs that benefit from the wrapper.\n\n[1]: http://tmux.sourceforge.net/\n[2]: http://www.gnu.org/software/screen/\n\n# Mac OS X Pasteboard Access Under *tmux* And *screen*\n\n## The Problem\n\nThe most commonly reported broken behavior is that the [*pbcopy* and\n*pbpaste*][3] command-line programs that come with Mac OS X fail to\nfunction properly when run under *tmux* and (sometimes) under\n“unpatched” *screen*.\n\nApple has patched their builds of *screen* (included with Mac OS X)\nto fix the problem; the [*screen* “port”][4] in the [MacPorts][5]\nsystem has [adopted][6] Apple’s *screen* patches.\n\nTheir *screen* patch allows (for example) the user to create\na *screen* session under a normal GUI login session and access the\npasteboard (inside the *screen* session) anytime that user is logged\ninto the GUI. Programs that are run in a session of “unpatched” *screen* will\nonly encounter the problem when the *screen* session outlives its\nparent Mac OS X login session (e.g. a normal GUI login or an SSH\nlogin).\n\nThird-party programs (run under *tmux* or unpatched *screen*) are\nalso affected (e.g. non-GUI builds of [Vim][7] [7.3][8] can access\nthe pasteboard when compiled with the `+clipboard` feature).\n\n[3]: http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/pbcopy.1.html\n[4]: https://trac.macports.org/browser/trunk/dports/sysutils/screen/Portfile\n[5]: http://www.macports.org/\n[6]: https://trac.macports.org/browser/trunk/dports/sysutils/screen/files/patch-screen.c\n[7]: http://www.vim.org/\n[8]: http://vimhelp.appspot.com/version7.txt.html#added-7.3\n\n## Why Pasteboard Breaks\n\n### Access to the Mac OS X Pasteboard Service\n\nThe pasteboard service in Mac OS X is registered in a \"bootstrap\nnamespace\" (see Apple’s [TN2083][9]). The namespaces exist in\na hierarchy: “higher” namespaces include access to “lower”\nnamespaces. A process in a lower namespace can not access higher\nnamespaces. So, all process can access the lowest, “root” bootstrap\nnamespace, but only processes in a higher namespace can access that\nnamespace. Processes created as a part of a Mac OS X login session\nare automatically included in the user’s “per-user” bootstrap\nnamespace. The pasteboard service is only available to processes in\nthe per-user bootstrap namespace.\n\n[9]: http://developer.apple.com/library/mac/#technotes/tn2083/_index.html\n\n### Interaction with *tmux*\n\n*tmux* uses the *daemon(3)* library function when starting its\nserver process. In Mac OS X 10.5, Apple changed *daemon(3)* to move\nthe resulting process from its original bootstrap namespace to the\nroot bootstrap namespace. This means that the *tmux* server, and its\nchildren, will automatically and uncontrollably lose access to what\nwould have been their original bootstrap namespace (i.e. the one\nthat has access to the pasteboard service).\n\n### Interaction with Unpatched *screen*\n\nThe situation with *screen* is a bit different since it does not use\n*daemon(3)*. Unpatched *screen*, and its children, only lose access\nto the per-user bootstrap namespace when its parent login session\nexits.\n\n## Solution Space\n\nApple (and MacPorts) have already handled *screen*. Apple prevents\n*screen* from losing access to the per-user bootstrap namespace by\n“migrating to [the] background session” ([in 10.5][10] using\n*\\_vprocmgr\\_move\\_subset\\_to\\_user*) or “detach[ing] from console”\n([in 10.6][11] using *\\_vprocmgr\\_detach\\_from\\_console*). For the\npurposes of *screen*, both of these let the *screen* process access\nthe per-user bootstrap namespace even after the processes initial\nMac OS X login session has ended.\n\n[10]: http://www.opensource.apple.com/source/screen/screen-12/patches/screen.c.diff\n[11]: http://www.opensource.apple.com/source/screen/screen-19/screen/screen.c\n\n### Patch *tmux*?\n\nIdeally, we could port Apple’s patch to *tmux*. Practically, there\nare problems with a direct port.\n\nThe undocumented, private function used in Apple’s 10.6 patch,\n*\\_vprocmgr\\_detach\\_from\\_console*, is not effective if called before\n*daemon(3)* (since it forcibly moves the process to the root\nbootstrap namespace); if called after *daemon(3)*, it just returns\nan error.\n\nThe undocumented, private function used in Apple’s 10.5 patch,\n*\\_vprocmgr\\_move\\_subset\\_to\\_user*, is also available in 10.6 (though\nan extra parameter has been added to it in 10.6). Again, there is no\npoint in calling it before *daemon(3)*, but it is effective if\ncalled after *daemon(3)*.\n\nThe functionality of *\\_vprocmgr\\_move\\_subset\\_to\\_user* seems to be\na sort of superset of that of *\\_vprocmgr\\_detach\\_from\\_console* in\nthat both move to the `\"Background\"` session, but the former does\nsome extra work that can attach to a user namespace even if the\nprocess has been previously moved out of it.\n\nSo, another approach that works is to call either the private\nfunction after invoking a custom *daemon* that does not forcibly\nmove its resulting process to the root bootstrap namespace (*tmux*\neven already has one).\n\nThe fact that the signature of *\\_vprocmgr\\_move\\_subset\\_to\\_user*\nchanged between 10.5 and 10.6 is a strong indication that Apple sees\nthese functions as part of a private API that is liable to change or\nbecome available in any (major?) release. It seems inappropriate to\nask upstream *tmux* to incorporate calls to functions such as these.\nIt might be appropriate for MacPorts to apply a patch to its port\nthough.\n\n### Use a “Reattaching” Wrapper Program\n\nWhile it would be nice to have the *tmux* server itself reattached\nto the per-user bootstrap namespace, it is probably enough to\nselectively reattach just some of its children. A small wrapper\ncould do the work of reattaching to the appropriate namespace and\nthen execing some other program that will (eventually) need\naccess to the per-user namespace.\n\nSuch a wrapper could be used to run *pbcopy*, *pbpaste*, *vim*, et\ncetera. This would require the user to remember to use the wrapper\n(or write scripts/shell-functions/aliases to always do it; or notice\nit fail then re-run it under the wrapper).\n\nA more automated solution that probably covers most of the problem\nscenarios for most users would be to set *tmux*&rsquo;s `default-command`\noption so that new windows start shells via the wrapper by default.\nThe major area this would not cover would be commands given directly\nto `new-session` and `new-window` (there are some other commands\nthat start new children, but those are the major ones).\n\n# Some New Programs For Your Consideration\n\n## The Wrapper Program\n\nThe *reattach-to-user-namespace* program implements the “wrapper”\nsolution described above.\n\n        reattach-to-user-namespace program args...\n\nIts `-l` option causes it to rewrite the execed program’s `argv[0]` to\nstart with a dash (`-`). Most shells take this as a signal that they should\nstart as “login” shells.\n\n        exec reattach-to-user-namespace -l \"$SHELL\"\n\nIn `.tmux.conf`:\n\n        set-option -g default-command \"reattach-to-user-namespace -l zsh\"\n\n## The Diagnostic Program\n\nThe *test* program was created to easily examine the effects and\ninteractions of some of the “functions of interest” (primarily\n*daemon(3)*, and the private “vproc” functions).\n\nIts arguments are interpreted as instructions to call various\nfunctions and/or display some result.\n\nExamples:\n\nEmulate calling *pbpaste* under plain *tmux*:\n\n        ./test daemon=sys system=pbpaste\n\nEmulate a *tmux* patch that would automatically reattach to the user\nnamespace (also equivalent to using the wrapper program under an\nunpatched *tmux*):\n\n        ./test daemon=sys move-to-user=10.6 system=pbpaste\n\nEmulate a *tmux* patch that uses compat/daemon.c and “detaches from\nthe console”:\n\n        ./test daemon=ours deatch system=pbpaste\n\nDemonstrate revocation of access to the per-user bootstrap namespace\nwhen the Mac OS X login session ends:\n\n        # while logged into the GUI\n    \n        # login session ends before pbpaste happens: failure\n        cp /dev/null /tmp/f &&\n        ssh localhost `pwd`/test \\\n          daemon=ours \\\n          msg=sleeping... sleep=1 msg='done\\ sleeping' \\\n          system=pbpaste 2\\> /tmp/f &&\n        { cat /tmp/f; tail -f /tmp/f; }\n    \n        # pbpaste happens before login session ends: success\n        cp /dev/null /tmp/f &&\n        ssh localhost `pwd`/test \\\n          daemon=ours \\\n          msg=sleeping... msg='done\\ sleeping' \\\n          system=pbpaste 2\\> /tmp/f \\; sleep 1 &&\n        { cat /tmp/f; tail -f /tmp/f; }\n\nTest workarounds to prevent the above end-of-login revocation:\n\n        # while logged into the GUI\n    \n        # emulate tmux patched to move to the user namespace\n        # or, equivalently, unpatched *tmux* and wrapper\n        cp /dev/null /tmp/f &&\n        ssh localhost `pwd`/test \\\n          daemon=sys \\\n          move-to-user=10.6 \\\n          msg=sleeping... sleep=1 msg='done\\ sleeping' \\\n          system=pbpaste 2\\> /tmp/f &&\n        { cat /tmp/f; tail -f /tmp/f; }\n    \n        # emuate tmux patched to use compat/daemon + detach\n        cp /dev/null /tmp/f &&\n        ssh localhost `pwd`/test \\\n          daemon=ours \\\n          detach \\\n          msg=sleeping... sleep=1 msg='done\\ sleeping' \\\n          system=pbpaste 2\\> /tmp/f &&\n        { cat /tmp/f; tail -f /tmp/f; }\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.0361328125,
          "content": "test: Explore uses for SessionCreate\n"
        },
        {
          "name": "Usage.md",
          "type": "blob",
          "size": 8.353515625,
          "content": "# Basic Configuration\n\nThe basic configuration is to set *tmux*’s `default-command` so that\nyour interactive shell ends up reattached to the user bootstrap\nnamespace:\n\n    set-option -g default-command 'reattach-to-user-namespace -l zsh'\n\nSince the “attachment status” is inherited by child processes, this\nconfiguration will ensure that all the commands started from your\nshell will also be properly attached.\n\n# Configuration Alternatives\n\n## Cross-Platform Conditional Usage\n\nSome users like to share identical configuration files (including\n`.tmux.conf`) with systems where the wrapper program is not\navailable (e.g. same files on both OS X and Linux). Starting with\n*tmux* 1.9, it is safe to use `if-shell` to conditionally configure\nthe use of the wrapper program:\n\n    if-shell 'test \"$(uname -s)\" = Darwin' 'set-option -g default-command \"exec reattach-to-user-namespace -l zsh\"'\n\nOr, if you have other platform specific configuration, you can\nconditionally source another file.\n\nIn `.tmux.conf`:\n\n    if-shell 'test \"$(uname -s)\" = Darwin' 'source-file ~/.tmux-osx.conf'\n\nThen in `.tmux-osx.conf`, include the `default-command` setting and\nany other bits of OS X configuration (e.g. the buffer-to-pasteboard\nbindings shown below):\n\n    set-option -g default-command 'exec reattach-to-user-namespace -l zsh'\n\nWith *tmux* 1.8 and earlier, the above configuration has a race\ncondition (the `if-shell` command is run in the background) and/or\ndoes not affect the initial session/window/pane. Instead, the basic\n`default-command` can be extended with a bit of shell code to\nconditionally use the wrapper only where it is present:\n\n    set-option -g default-command 'command -v reattach-to-user-namespace >/dev/null && exec reattach-to-user-namespace -l \"$SHELL\" || exec \"$SHELL\"'\n\nThe `default-command` will be run using your `default-shell` (which\ndefaults to SHELL, your login shell, or `/bin/sh`). This particular\ncode should work on most systems, but it may fail if the effective\nshell is not POSIX compliant (old-style `/bin/sh`, a *csh* variant,\n*fish*, etc.). If one of your systems does not understand `command\n-v` (or if it does something unrelated that returns the wrong exit\nvalue), then you might try using `which` instead. Exotic shells may\nalso require different syntax.\n\n## Fine-Grained Usage\n\nInstead of using `default-command` to “wrap” your top-level shells,\nyou can instead use the wrapper on just the tools that need it (see\n“Beyond Pasteboard Access” (below) for other commands that may also\nneed the wrapper).\n\nYou might want to adopt this approach if part of your shell\ninitialization takes a long time to run: the `default-command` will\nstart your shell twice (once to process the `default-command`, and\nonce more for the final, interactive shell that is started by the\n`default-command`). For example if your SHELL is *zsh*, then your\n`.zshenv` (if you have one) will be run twice (the other\ninitialization files will only be run once).\n\nFor example, you could leave your shell “detached” and run\n`reattach-to-user-namespace pbpaste` to read from the pasteboard. If\nyou take this approach, you may want to use a small script, shell\nalias, or shell function to supply a shorter name for the wrapper\nprogram (or wrap the individual commands—the\n`reattach-to-user-namespace` *Homebrew* recipe has some support for\nthis).\n\nYou will also need to apply this fine-grained “wrapping” if you want\nto have *tmux* directly run commands that need to be reattached.\n\nFor example, you might use bindings like the following to write\na *tmux* buffer to the OS X pasteboard or to paste the OS X\npasteboard into the current *tmux* pane.\n\n    bind-key C-c run-shell 'tmux save-buffer - | reattach-to-user-namespace pbcopy'\n    bind-key C-v run-shell 'reattach-to-user-namespace pbpaste | tmux load-buffer - \\; paste-buffer -d'\n\nSimilarly, for the `copy-pipe` command (new in *tmux* 1.8):\n\n    bind-key -t    vi-copy y   copy-pipe 'reattach-to-user-namespace pbcopy'\n    bind-key -t emacs-copy M-w copy-pipe 'reattach-to-user-namespace pbcopy'\n\n\n\n# Beyond Pasteboard Access\n\nBecause the fix applied by the wrapper program is not limited to\njust pasteboard access, there are other bugs/issues/problems that\ncome up when running under *tmux* that the wrapper can help\nalleviate.\n\n* `nohup`\n\n    The *nohup* program aborts if it cannot “detach from console”.\n    Normally, processes running “inside” *tmux* (on the other side\n    of a daemon(3) call) are already detached; the wrapper\n    reattaches so that *nohup* can successfully detach itself.\n\n    *nohup* does generate an error message if it aborts due to\n    failing to detach, but it happens after the output has been\n    redirected so it ends up in the `nohup.out` file (or wherever\n    you sent stdout):\n\n        nohup: can't detach from console: Undefined error: 0\n\n    References: [problem using nohup within tmux on OSX 10.6][ml nohup]\n\n[ml nohup]: http://thread.gmane.org/gmane.comp.terminal-emulators.tmux.user/4450\n\n* The `export`, `getenv`, `setenv` subcommands of `launchctl`\n\n    Notably, the `setenv` subcommand will issue an error when it is\n    run from a “detached” context:\n\n        launch_msg(\"SetUserEnvironment\"): Socket is not connected\n\n    The `getenv` and `export` commands will simply not have access\n    to some variables that have otherwise been configured in the\n    user’s *launchd* instance.\n\n    References: [tmux “Socket is not connected” error on OS X Lion][so setenv]\n\n[so setenv]: http://stackoverflow.com/q/10193561/193688\n\n* `subl -w` `subl --wait`\n\n[su subl]: http://superuser.com/q/522055/14827\n[so subl]: http://stackoverflow.com/q/13917095/193688\n\n    The *subl* command from *Sublime Text* can be used to open files\n    in the GUI window from a shell command line. The `-w` (or\n    `--wait`) option tells it to wait for the file to be closed in\n    the editor before exiting the `subl` command.\n\n    Whatever mechanism *Sublime Text* uses to coordinate between the\n    `subl` instance and the main *Sublime Text* instance is affected\n    by being “detached”. The result is that `subl -w` commands\n    issued inside *tmux* will not exit after the file is closed in\n    the GUI. The wrapper lets the `subl` command successfully\n    synchronize with the GUI instance.\n\n    References: ['subl -w' doesn't ever un-block when running under tmux on OS X][su subl] and [subl --wait doesn't work within tmux][so subl]\n\n* Retina rendering of apps launched under *tmux* (10.9 Mavericks)\n\n    From feedback in [issue #22][issue 22]:\n\n[issue 22]: https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard/issues/22\n\n    > Under Mavericks, applications launched from inside a tmux\n    > session cannot enable retina rendering (for reasons I don't\n    > understand -- this worked under Mountain Lion). If the shell\n    > inside the tmux session is reattached to the user namespace,\n    > then applications launched from the reattached shell do enable\n    > retina rendering when appropriate.\n\n* `ABAddressBook` (via custom program)\n\n     [Issue #43][issue 43] mentions a custom Swift program using\n     `ABAddressBook` that does not work under *tmux* unless run with\n     the wrapper (tested on Yosemite).\n\n[issue 43]: https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard/issues/43\n\n* MacVim using a font from ~/Library/Fonts for `guifont`\n\n    [Issue #54][issue 54] mentions MacVim (8.0; possibly older\n    versions, too) not being able to use a font from ~/Library/Fonts\n    for its `guifont` setting when run under *tmux* unless run with\n    the wrapper (tested under Sierra).\n\n[issue 54]: https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard/issues/54\n\n* `curl` using certificates in Keychain to verify peer\n\n    > `--cacert`\n    > (iOS and macOS only) If curl is built against Secure Transport [...] then\n    > curl will use the certificates in the system and user Keychain to verify\n    > the peer, which is the preferred method of verifying the peer's\n    > certificate chain.\n    \n    As of macOS Sierra, under tmux without `reattach-to-user-namespace`, `curl`\n    will fail to verify peers against Keychain-stored certificates.\n\n* `ssh` - Keychain access for Secure Shell\n\n    On macOS Sierra *tmux* can only add your SSH keys to `ssh-agent`\n    with `reattach-to-user-namespace`,\n    see [\"macOS Sierra without SSH-passphrase\"](https://youtu.be/w5iZkhlg24M)\n    on YouTube.\n\nThere may also be other contexts (aside from “inside *tmux*”) where\nthese same problems occur, but I have not yet heard of any.\n"
        },
        {
          "name": "move_to_user_namespace.c",
          "type": "blob",
          "size": 2.3701171875,
          "content": "#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <mach/mach.h>\n\n#include \"msg.h\"\n\n#define FIND_SYMBOL(NAME, RET, SIG) \\\n    static const char fn_ ## NAME [] = # NAME; \\\n    typedef RET (*ft_ ## NAME) SIG; \\\n    ft_ ## NAME f_ ## NAME; \\\n    if (!(f_ ## NAME = (ft_ ## NAME)dlsym(RTLD_NEXT, fn_ ## NAME))) { \\\n        warn(\"unable to find %s: %s\", fn_ ## NAME, dlerror()); \\\n        return -1; \\\n    }\n\nstatic int move_to_user_namespace__100500(void)\n{\n    FIND_SYMBOL(_vprocmgr_move_subset_to_user, void *, (uid_t, const char *))\n\n    if (f__vprocmgr_move_subset_to_user(getuid(), \"Background\") != NULL) {\n        warn(\"%s failed\", fn__vprocmgr_move_subset_to_user);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int move_to_user_namespace__100600(void)\n{\n    FIND_SYMBOL(_vprocmgr_move_subset_to_user, void *, (uid_t, const char *, uint64_t))\n\n    if (f__vprocmgr_move_subset_to_user(getuid(), \"Background\", 0) != NULL) {\n        warn(\"%s failed\", fn__vprocmgr_move_subset_to_user);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int move_to_user_namespace__101000(void)\n{\n    mach_port_t puc = MACH_PORT_NULL;\n    mach_port_t rootbs = MACH_PORT_NULL;\n\n    FIND_SYMBOL(bootstrap_get_root, kern_return_t, (mach_port_t, mach_port_t *))\n    FIND_SYMBOL(bootstrap_look_up_per_user, kern_return_t, (mach_port_t, const char *, uid_t, mach_port_t *))\n\n    if (f_bootstrap_get_root(bootstrap_port, &rootbs) != KERN_SUCCESS) {\n        warn(\"%s failed\", fn_bootstrap_get_root);\n        return -1;\n    }\n    if (f_bootstrap_look_up_per_user(rootbs, NULL, getuid(), &puc) != KERN_SUCCESS) {\n        warn(\"%s failed\", fn_bootstrap_look_up_per_user);\n        return -1;\n    }\n\n    if (task_set_bootstrap_port(mach_task_self(), puc) != KERN_SUCCESS) {\n        warn(\"task_set_bootstrap_port failed\");\n        return -1;\n    }\n    if (mach_port_deallocate(mach_task_self(), bootstrap_port) != KERN_SUCCESS) {\n        warn(\"mach_port_deallocate failed\");\n        return -1;\n    }\n\n    bootstrap_port = puc;\n\n    return 0;\n}\n\nint move_to_user_namespace(unsigned int os)\n{\n    switch (os) {\n    case 100500:\n        return move_to_user_namespace__100500();\n\n    case 100600:\n        return move_to_user_namespace__100600();\n\n    case 101000:\n        return move_to_user_namespace__101000();\n\n    default:\n        warn(\"move_to_user_namespace: unhandled os value: %u\", os);\n        return -1;\n    }\n}\n"
        },
        {
          "name": "move_to_user_namespace.h",
          "type": "blob",
          "size": 0.0439453125,
          "content": "int move_to_user_namespace(unsigned int os);\n"
        },
        {
          "name": "msg.c",
          "type": "blob",
          "size": 3.689453125,
          "content": "/*\n * Copyright (c) 2011, Chris Johnsen <chris_johnsen@pobox.com>\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     1. Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n * \n *     2. Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <string.h>    /* strlen, strcpy, strerror */\n#include <stdarg.h>    /* va_...   */\n#include <stdio.h>     /* vfprintf */\n#include <stdlib.h>    /* malloc, exit, free */\n#include <sys/errno.h> /* errno    */\n\n#include \"msg.h\"\n\nvoid vfmsg(FILE *f,\n        const char *pre, const char *suf, const char *fmt,\n        va_list ap) {\n    int prelen = 0, fmtlen = 0, suflen = 0;\n    if (pre) prelen = strlen(pre);\n    if (fmt) fmtlen = strlen(fmt);\n    if (suf) suflen = strlen(suf);\n    char *newfmt = malloc(\n            prelen*2 + /* %-doubled pre */\n            fmtlen +\n            2 + /* ':' and SP */\n            suflen*2 + /* %-doubled suf */\n            2 /* NL and NUL */\n            );\n    if (!newfmt)\n        goto finish;\n\n    char *newfmt_end = newfmt;\n    if (prelen)\n        while(*pre)\n            if ((*newfmt_end++ = *pre++) == '%')\n                *newfmt_end++ = '%';\n    if (fmtlen) {\n        strcpy(newfmt_end, fmt);\n        newfmt_end += fmtlen;\n    }\n    if (suflen) {\n        *newfmt_end++ = ':';\n        *newfmt_end++ = ' ';\n        while (*suf)\n            if ((*newfmt_end++ = *suf++) == '%')\n                *newfmt_end++ = '%';\n    }\n    *newfmt_end++ = '\\n';\n    *newfmt_end++ = '\\0';\n    fmt = newfmt;\n\nfinish:\n    vfprintf(f, fmt, ap);\n    fflush(f);\n\n    if (newfmt)\n        free(newfmt);\n}\n\nFILE *msgout = NULL;\n\nvoid vmsg(const char *pre, const char *suf, const char *fmt, va_list ap) {\n    vfmsg(msgout ? msgout : stderr, pre, suf, fmt, ap);\n}\n\nvoid msg(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vmsg(NULL, NULL, fmt, ap);\n    va_end(ap);\n}\n\nvoid warn(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vmsg(\"warning: \", NULL, fmt, ap);\n    va_end(ap);\n}\n\nvoid warn_errno(const char *fmt, ...) {\n    int err = errno; /* just in case it gets clobbered */\n    va_list ap;\n    va_start(ap, fmt);\n    vmsg(\"warning: \", strerror(err), fmt, ap);\n    va_end(ap);\n    errno = err;\n}\n\nvoid die(int ev, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vmsg(\"fatal: \", NULL, fmt, ap);\n    va_end(ap);\n    exit(ev);\n}\n\nvoid die_errno(int ev, const char *fmt, ...) {\n    int err = errno; /* just in case it gets clobbered */\n    va_list ap;\n    va_start(ap, fmt);\n    vmsg(\"fatal: \", strerror(err), fmt, ap);\n    va_end(ap);\n    exit(ev);\n}\n"
        },
        {
          "name": "msg.h",
          "type": "blob",
          "size": 1.8837890625,
          "content": "/*\n * Copyright (c) 2011, Chris Johnsen <chris_johnsen@pobox.com>\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     1. Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n * \n *     2. Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid vfmsg(FILE *f,\n        const char *pre, const char *suf, const char *fmt,\n        va_list ap);\nextern FILE *msgout;\nvoid vmsg(const char *pre, const char *suf, const char *fmt, va_list ap);\nvoid msg(const char *fmt, ...);\nvoid warn(const char *fmt, ...);\nvoid warn_errno(const char *fmt, ...);\nvoid die(int ev, const char *fmt, ...) __attribute__((noreturn));\nvoid die_errno(int ev, const char *fmt, ...) __attribute__((noreturn));\n"
        },
        {
          "name": "reattach-to-user-namespace.c",
          "type": "blob",
          "size": 5.8193359375,
          "content": "/*\n * Copyright (c) 2011-2014, Chris Johnsen <chris_johnsen@pobox.com>\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     1. Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n * \n *     2. Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <string.h>    /* strlen, strcpy, strcmp, strrchr */\n#include <stdarg.h>    /* va_...   */\n#include <stdio.h>     /* fprintf, vfprintf  */\n#include <stdlib.h>    /* malloc, exit, free, atoi */\n#include <unistd.h>    /* execvp   */\n#include <sys/utsname.h> /* uname  */\n\n#include \"msg.h\"\n#include \"move_to_user_namespace.h\"\n\nstatic const char version[] = \"2.9\";\nstatic const char supported_oses[] = \"OS X 10.5-11.0\";\n\n#if 0\nvoid * _vprocmgr_move_subset_to_user(uid_t target_user, const char *session_type, uint64_t flags); /* 10.6 */\nvoid * _vprocmgr_move_subset_to_user(uid_t target_user, const char *session_type); /* 10.5 */\n#endif\n\nstatic const char usage_msg[] = \"\\n\"\n    \"    Reattach to the per-user bootstrap namespace in its \\\"Background\\\"\\n\"\n    \"    session then exec the program with args. If \\\"-l\\\" is given,\\n\"\n    \"    rewrite the program's argv[0] so that it starts with a '-'.\\n\";\n\nint main(int argc, char *argv[]) {\n    unsigned int login = 0, usage = 0;\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"-l\")) {\n            login = 1;\n            argv[1] = argv[0];\n            argv++;\n            argc--;\n        } else if (!strcmp(argv[1], \"-v\") ||\n                !strcmp(argv[1], \"--version\")) {\n            printf(\"%s version %s\\n    Supported OSes: %s\\n\",\n                    argv[0], version, supported_oses);\n            exit(0);\n        } else if (*argv[1] == '-') {\n            warn(\"unknown option: %s\", argv[1]);\n            usage = 2;\n        }\n    }\n    if (argc < 2)\n        usage = 1;\n    if (usage)\n        die(usage, \"usage: %s [-l] <program> [args...]\\n%s\", argv[0], usage_msg);\n\n    unsigned int os = 0;\n\n    struct utsname u;\n    if (uname(&u)) {\n        warn_errno(\"uname failed\");\n        goto reattach_failed;\n    }\n    if (strcmp(u.sysname, \"Darwin\")) {\n        warn(\"unsupported OS sysname: %s\", u.sysname);\n        goto reattach_failed;\n    }\n\n    char *rest, *whole = strdup(u.release);\n    if (!whole) {\n        warn_errno(\"strdup failed\");\n        goto reattach_failed;\n    }\n    rest = whole;\n    strsep(&rest, \".\");\n    if (whole && *whole && whole != rest) {\n        int major = atoi(whole);\n        os = 100000;    /* 10.1, 10.0 and prior betas/previews */\n        if (major >= 6) /* 10.2 and newer */\n            os += (major-4) * 100;\n    }\n    else\n        warn(\"unparsable major release number: '%s'\", u.release);\n\n    free(whole);\n\n    /*\n     * change the 'os' variable to represent the \"reattach variation\"\n     * instead of the major OS release\n     *\n     *  older => 100500 with warning\n     *   10.5 => 100500\n     *   10.6 => 100600\n     *   10.7 => 100600\n     *   10.8 => 100600\n     *   10.9 => 100600\n     *   10.10=> 101000\n     *   10.11=> 101000\n     *   10.12=> 101000\n     *   10.13=> 101000\n     *   10.14=> 101000\n     *   10.15=> 101000\n     *  newer => 101000\n     */\n    if (100600 <= os && os <= 100900)\n        os = 100600;\n    else if (101000 <= os && os <= 101500)\n        os = 101000;\n    else if (os < 100500) {\n        warn(\"%s: unsupported old OS, trying as if it were 10.5\", argv[0]);\n        os = 100500;\n    } else if (os > 101500) {\n        /*\n        warn(\"%s: unsupported new OS, trying as if it were 10.10\", argv[0]);\n        */\n        os = 101000;\n    }\n\n    if (move_to_user_namespace(os) != 0) {\nreattach_failed:\n        warn(\"%s: unable to reattach\", argv[0]);\n    }\n\n    char **newargs = NULL;\n    const char *file = argv[1];\n    if (login) {\n        /*\n         * For their argv[0], take the bit of file after the\n         * last slash (the whole thing if there is no slash\n         * or if that bit would be zero length) and prefix\n         * it with '-'.\n         */\n        char *arg0 = malloc(strlen(file) + 2);\n        if (!arg0)\n            goto exec_it;\n        *arg0 = '-';\n        char *slash = strrchr(file, '/');\n        if (slash && slash[1])\n            strcpy(arg0+1, slash+1);\n        else\n            strcpy(arg0+1, file);\n\n        /* use the rest of the args as they are */\n        newargs = malloc(sizeof(*newargs) * (argc));\n        if (!newargs) {\n            free(arg0);\n            goto exec_it;\n        }\n        newargs[0] = arg0;\n        int arg = 2;\n        for(; arg < argc; arg++)\n            newargs[arg-1] = argv[arg];\n        newargs[arg-1] = NULL;\n    }\n\nexec_it:\n    if (execvp(file, newargs ? newargs : argv+1) < 0)\n        die_errno(3, \"%s: execv failed\", argv[0]);\n\n    if (newargs) {\n        free(newargs[0]);\n        free(newargs);\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 8.779296875,
          "content": "/*\n * Copyright (c) 2011, Chris Johnsen <chris_johnsen@pobox.com>\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     1. Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n * \n *     2. Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n\n#include \"msg.h\"\n#include \"move_to_user_namespace.h\"\n\n#define UNUSED __attribute__ ((unused))\n\nstatic int our_daemon(int nochdir, int noclose) {\n    /*\n     * Implementation based on description in daemon(3).\n     * Hmm, got pretty close.\n     * http://www.opensource.apple.com/source/Libc/Libc-594.9.4/gen/daemon-fbsd.c\n     * Theirs touches on signal handling, too. And, it does the\n     * unwanted bit about moving to the root bootstrap namespace.\n     */\n    pid_t p;\n    int fd, i;\n    if ((p = fork()) < 0) return -1;\n    if (p>0) exit(0);\n    if ((p = setsid()) < 0) return -1;\n    if (!nochdir) chdir(\"/\");\n    if (!noclose &&\n        !((fd = open(\"/dev/null\", O_RDWR)) < 0)) {\n        for (i = 0; i < 3; i++) { dup2(fd,i); }\n        if (fd > 2) close(fd);\n    }\n    return 0;\n}\n\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\nstatic int sys_daemon(int nocd, int nocl) { return daemon(nocd, nocl); }\n#pragma GCC diagnostic warning \"-Wdeprecated-declarations\"\n\nstatic void do_daemon(const char *opt) {\n    if (!(opt && *opt))\n        die(2, \"daemon requires an option (i.e. daemon=sys)\");\n\n    int (*daemon_)(int,int);\n    if (!strcmp(opt,\"sys\"))\n        daemon_ = sys_daemon;\n    else if (!strcmp(opt, \"ours\"))\n        daemon_ = our_daemon;\n    else\n        die(2, \"daemon: unknown option: %s\", opt);\n\n    int r = daemon_(1,0);\n    if (r) die_errno(2, \"%s daemon() failed = %d\", opt, r);\n}\n\nstatic void show_pid(const char *opt) {\n    msg(\"pid: %d (%s)\", getpid(), opt ? opt : \"\");\n}\n\nstatic void move_to_user(const char *opt) {\n    if (!(opt && *opt))\n        die(3, \"move-to-user: requires an option (i.e. move-to-user=10.6)\");\n\n    int r;\n    if (!strcmp(opt, \"10.5\"))\n        r = move_to_user_namespace(100500);\n    else if (!strcmp(opt, \"10.6\"))\n        r = move_to_user_namespace(100600);\n    else if (!strcmp(opt, \"10.10\"))\n        r = move_to_user_namespace(101000);\n    else\n        die(3, \"move-to-user: unknown option: %s\", opt);\n    if (r) die(3, \"move_to_user_namespace failed\");\n}\n\ntypedef void *(*detach_from_console_f)(unsigned int flags);\nstatic void detach_from_console(const char *opt UNUSED) {\n    static const char detach_fn[] = \"_vprocmgr_detach_from_console\";\n    void *f = dlsym(RTLD_NEXT, detach_fn);\n    if (!f) die(4, \"unable to find %s: %s\", detach_fn, dlerror());\n    if (((detach_from_console_f)f)(0) != NULL)\n        die(4, \"%s failed\", detach_fn);\n}\n\nstatic int out_fd;\nstatic void do_system(const char *opt) {\n    if (dup2(out_fd,1) < 0)\n        die_errno(5, \"dup2(out_fd,1) failed\");\n    if (dup2(out_fd,2) < 0)\n        die_errno(5, \"dup2(out_fd,2) failed\");\n\n    int r = system(opt);\n    if (r < 0)\n        die(5, \"system() failed\");\n\n    if (WIFEXITED(r))\n        msg(\"system(%s) process exited %d\", opt, WEXITSTATUS(r));\n    else if (WIFSIGNALED(r))\n        msg(\"system(%s) process terminated by signal %d\", opt, WTERMSIG(r));\n    else if (WIFSTOPPED(r))\n        msg(\"system(%s) process stopped with signal %d\", opt, WSTOPSIG(r));\n}\n\nstatic int parse_int(const char *str, char **rest_,\n        char expected_stop) {\n    char *rest;\n    errno = 0;\n    int v = strtoul(str, &rest, 0);\n    if (errno)\n        die_errno(1, \"error parsing \\\"%s\\\" as int\", str);\n    if (rest && *rest != expected_stop)\n        die(1, \"unexpected char '%c' (%d) while parsing int from \\\"%s\\\"\",\n                *rest, *rest, str);\n    if (rest_) *rest_ = rest;\n    return v;\n}\n\ntypedef int (*session_create_f)(int, int);\nstatic void session_create(const char *opt) {\n    static const char fw[] =\n        \"/System/Library/Frameworks/Security.framework/Versions/Current/Security\";\n    static const char fn[] = \"SessionCreate\";\n    if (!(opt && *opt && strchr(opt, ',')))\n        die(6, \"session-createn needs two args (e.g. 0,0)\");\n    char *rest;\n    int a = parse_int(opt, &rest, ',');\n    int b = parse_int(rest+1, NULL, '\\0');\n    void *lib = dlopen(fw, RTLD_LAZY|RTLD_LOCAL);\n    if (!lib)\n        die(6, \"unable to load Security framework (%s): %s\", fw, dlerror());\n    void *f = dlsym(lib, fn);\n    msg(\"calling %s(0x%x,0x%x)\", fn, a, b);\n    int r = ((session_create_f)f)(a, b);\n    if (r) die(6, \"%s failed: %d\", fn, r);\n    if (dlclose(lib))\n        die(6, \"unable to close Security framework: %s\", dlerror());\n    /*\n    OSStatus result = SessionCreate(0, 0x30);\n     * 0x1,0x11,0x21,0x1001,0x1011,0x1021,0x1031 -> -60501\n     * (invalid attribute bits)\n     */\n}\n\nstatic void do_sleep(const char *opt) {\n    int s = parse_int(opt, NULL, '\\0');\n    sleep(s);\n}\n\nstatic void show_msg(const char *opt) {\n    msg(\"%s\", opt);\n}\n\ntypedef void cmd_func(const char *opt);\nstruct cmd {\n    cmd_func * const func;\n    const char * const str;\n    const char * const desc;\n};\n\nstatic cmd_func\n    show_msg, show_pid, do_sleep, do_daemon, detach_from_console,\n    do_system, move_to_user, session_create, help;\n\nstatic struct cmd all_cmds[] = {\n    { show_msg,       \"msg\",    \"=<text>   print text to stderr\" },\n    { show_pid,       \"pid\",    \"=<text>   print pid and text to stderr\" },\n    { do_sleep,       \"sleep\",  \"=<secs>   sleep(secs)\" },\n    { do_daemon,      \"daemon\", \"=sys      system daemon(3)\\n\"\n                                \"=ours     non-Apple version\" },\n    { detach_from_console,\n                      \"detach\", \"          _vprocmgr_detach_from_console(0)\", },\n    { do_system,      \"system\", \"=<cmd>    system(cmd)\"},\n    { move_to_user,   \"move-to-user\",\n                                \"=10.5     _vprocmgr_move_subset_to_user(uid,\\\"Background\\\")\\n\"\n                                \"=10.6         call with extra arg == 0\\n\"\n                                \"=10.10    custom implementation simulating _vprocmgr_move_subset_to_user\" },\n    { session_create, \"session-create\",\n                                \"=<a>,<b>  SessionCreate(a,b) (numeric a and b)\" },\n    { help,           \"help\",   \"          show this help text\" },\n    { NULL, \"\", \"\" }\n};\n\nstatic void help(const char *opt UNUSED) {\n    struct cmd *c = all_cmds;\n    int w, cmd_width = 0;\n    for (c = all_cmds; c->func; c++) {\n        w = strlen(c->str);\n        cmd_width = w > cmd_width ? w : cmd_width;\n    }\n    for (c = all_cmds; c->func; c++) {\n        const char *nl, *s = c->desc;\n        while ((nl = strchr(s, '\\n'))) {\n            msg(\"    %*s%.*s\", cmd_width, c->str, nl-s, s);\n            s = nl+1;\n        }\n        msg(\"    %*s%s\", cmd_width, c->str, s);\n    }\n}\n\nstatic void run_cmd(const char *cmd) {\n    const char *opt = strchr(cmd, '=');\n    size_t cmd_len = opt ? (size_t)(opt-cmd) : strlen(cmd);\n    if (!cmd_len)\n        die(1, \"no command in argument: %s\", cmd);\n    if (opt)\n        opt++;\n    struct cmd *c;\n    for (c = all_cmds; c->func; c++)\n        if (!strncmp(cmd, c->str, cmd_len) &&\n                c->str[cmd_len] == '\\0') {\n            c->func(opt);\n            return;\n        }\n    die(1, \"unknown command: %s (try help)\", cmd);\n}\n\nint main(int argc, const char * const argv[]) {\n    if ((out_fd = dup(2)) < 0)\n        die_errno(1, \"dup msgout\");\n    FILE *out = fdopen(out_fd, \"w\");\n    if (!out) die_errno(1, \"fdopen for msgout\");\n    msgout = out;\n\n    if (argc < 2)\n        die(1, \"usage: %s <command>...\\n\\n\"\n                \"    Execute the given commands.\\n\"\n                \"    Run \\\"%s help\\\" for command list.\\n\",\n                argv[0], argv[0]);\n\n    const char * const * cmds = argv+1;\n    while(*cmds)\n        run_cmd(*cmds++);\n\n    return 0;\n}\n"
        }
      ]
    }
  ]
}