{
  "metadata": {
    "timestamp": 1736710075156,
    "page": 692,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mendsley/bsdiff",
      "stars": 1928,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.09375,
          "content": ".deps/*\n.libs/*\n*.lo\n*.o\n.dirstamp\nMakefile-bsdiff.am.inc\nAUTHORS\nNEWS\nREADME\nChangeLog\nCOPYING\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2724609375,
          "content": " Copyright 2003-2005 Colin Percival\n Copyright 2012 Matthew Endsley\n All rights reserved\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted providing that the following conditions \n are met:\n 1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile-bsdiff.am",
          "type": "blob",
          "size": 1.53515625,
          "content": "# Copyright (C) 2015 Giuseppe Scrivano <gscrivan@redhat.com>\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted providing that the following conditions \n# are met:\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n#\n\nEXTRA_DIST += $(libbsdiff_srcpath)/bsdiff.h $(libbsdiff_srcpath)/bspatch.h $(libbsdiff_srcpath)/LICENSE $(libbsdiff_srcpath)/README.md\n\nlibbsdiff_la_SOURCES = \\\n\t$(libbsdiff_srcpath)/bsdiff.c \\\n\t$(libbsdiff_srcpath)/bspatch.c \\\n\t$(NULL)\n\nlibbsdiff_la_CFLAGS = $(AM_CFLAGS)\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 0.1904296875,
          "content": "bin_PROGRAMS = bsdiff bspatch\n\nbsdiff_SOURCES = bsdiff.c\n\nbspatch_SOURCES = bspatch.c\n\nbsdiff_CFLAGS = -DBSDIFF_EXECUTABLE\nbspatch_CFLAGS = -DBSPATCH_EXECUTABLE\n\nEXTRA_DIST = bsdiff.h bspatch.h\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.90234375,
          "content": "bsdiff/bspatch\n==============\nbsdiff and bspatch are libraries for building and applying patches to binary\nfiles.\n\nThe original algorithm and implementation was developed by Colin Percival.  The\nalgorithm is detailed in his paper, [Naïve Differences of Executable Code](http://www.daemonology.net/papers/bsdiff.pdf).  For more information, visit his\nwebsite at <http://www.daemonology.net/bsdiff/>.\n\nI maintain this project separately from Colin's work, with the goal of making\nthe core functionality easily embeddable in existing projects.\n\nContact\n-------\n[@MatthewEndsley](https://twitter.com/#!/MatthewEndsley)  \n<https://github.com/mendsley/bsdiff>\n\nLicense\n-------\nCopyright 2003-2005 Colin Percival  \nCopyright 2012 Matthew Endsley\n\nThis project is governed by the BSD 2-clause license. For details see the file\ntitled LICENSE in the project root folder.\n\nOverview\n--------\nThere are two separate libraries in the project, bsdiff and bspatch. Each are\nself contained in bsdiff.c and bspatch.c The easiest way to integrate is to\nsimply copy the c file to your source folder and build it.\n\nThe overarching goal was to modify the original bsdiff/bspatch code from Colin\nand eliminate external dependencies and provide a simple interface to the core\nfunctionality.\n\nI've exposed relevant functions via the `_stream` classes. The only external\ndependency not exposed is `memcmp` in `bsdiff`.\n\nThis library generates patches that are not compatible with the original bsdiff\ntool. The incompatibilities were motivated by the patching needs for the game\nAirMech <https://www.carbongames.com> and the following requirements:\n\n* Eliminate/minimize any seek operations when applying patches\n* Eliminate any required disk I/O and support embedded streams\n* Ability to easily embed the routines as a library instead of an external binary\n* Compile+run on all platforms we use to build the game (Windows, Linux, NaCl, OSX)\n\nCompiling\n---------\nThe libraries should compile warning free in any moderately recent version of\ngcc. The project uses `<stdint.h>` which is technically a C99 file and not\navailable in Microsoft Visual Studio. The easiest solution here is to use the\nmsinttypes version of stdint.h from <https://code.google.com/p/msinttypes/>.\nThe direct link for the lazy people is:\n<https://msinttypes.googlecode.com/svn/trunk/stdint.h>.\n\nIf your compiler does not provide an implementation of `<stdint.h>` you can\nremove the header from the bsdiff/bspatch files and provide your own typedefs\nfor the following symbols: `uint8_t`, `uint64_t` and `int64_t`.\n\nExamples\n--------\nEach project has an optional main function that serves as an example for using\nthe library. Simply defined `BSDIFF_EXECUTABLE` or `BSPATCH_EXECUTABLE` to\nenable building the standalone tools.\n\nReference\n---------\n### bsdiff\n\n\tstruct bsdiff_stream\n\t{\n\t\tvoid* opaque;\n\t\tvoid* (*malloc)(size_t size);\n\t\tvoid  (*free)(void* ptr);\n\t\tint   (*write)(struct bsdiff_stream* stream,\n\t\t\t\t\t   const void* buffer, int size);\n\t};\n\n\tint bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new,\n\t           int64_t newsize, struct bsdiff_stream* stream);\n\t\t\n\nIn order to use `bsdiff`, you need to define functions for allocating memory and\nwriting binary data. This behavior is controlled by the `stream` parameter\npassed to to `bsdiff(...)`.\n\nThe `opaque` field is never read or modified from within the `bsdiff` function.\nThe caller can use this field to store custom state data needed for the callback\nfunctions.\n\nThe `malloc` and `free` members should point to functions that behave like the\nstandard `malloc` and `free` C functions.\n\nThe `write` function is called by bsdiff to write a block of binary data to the\nstream. The return value for `write` should be `0` on success and non-zero if\nthe callback failed to write all data. In the default example, bzip2 is used to\ncompress output data.\n\n`bsdiff` returns `0` on success and `-1` on failure.\n\n### bspatch\n\n\tstruct bspatch_stream\n\t{\n\t\tvoid* opaque;\n\t\tint (*read)(const struct bspatch_stream* stream,\n\t\t            void* buffer, int length);\n\t};\n\n\tint bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new,\n\t            int64_t newsize, struct bspatch_stream* stream);\n\nThe `bspatch` function transforms the data for a file using data generated from\n`bsdiff`. The caller takes care of loading the old file and allocating space for\nnew file data.  The `stream` parameter controls the process for reading binary\npatch data.\n\nThe `opaque` field is never read or modified from within the bspatch function.\nThe caller can use this field to store custom state data needed for the read\nfunction.\n\nThe `read` function is called by `bspatch` to read a block of binary data from\nthe stream.  The return value for `read` should be `0` on success and non-zero\nif the callback failed to read the requested amount of data. In the default\nexample, bzip2 is used to decompress input data.\n\n`bspatch` returns `0` on success and `-1` on failure. On success, `new` contains\nthe data for the patched file.\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.0810546875,
          "content": "#!/bin/sh\n\ntouch AUTHORS NEWS README ChangeLog\ncp LICENSE COPYING\n\nautoreconf -fis\n"
        },
        {
          "name": "bsdiff.c",
          "type": "blob",
          "size": 10.072265625,
          "content": "/*-\n * Copyright 2003-2005 Colin Percival\n * Copyright 2012 Matthew Endsley\n * All rights reserved\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted providing that the following conditions \n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"bsdiff.h\"\n\n#include <limits.h>\n#include <string.h>\n\n#define MIN(x,y) (((x)<(y)) ? (x) : (y))\n\nstatic void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h)\n{\n\tint64_t i,j,k,x,tmp,jj,kk;\n\n\tif(len<16) {\n\t\tfor(k=start;k<start+len;k+=j) {\n\t\t\tj=1;x=V[I[k]+h];\n\t\t\tfor(i=1;k+i<start+len;i++) {\n\t\t\t\tif(V[I[k+i]+h]<x) {\n\t\t\t\t\tx=V[I[k+i]+h];\n\t\t\t\t\tj=0;\n\t\t\t\t};\n\t\t\t\tif(V[I[k+i]+h]==x) {\n\t\t\t\t\ttmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp;\n\t\t\t\t\tj++;\n\t\t\t\t};\n\t\t\t};\n\t\t\tfor(i=0;i<j;i++) V[I[k+i]]=k+j-1;\n\t\t\tif(j==1) I[k]=-1;\n\t\t};\n\t\treturn;\n\t};\n\n\tx=V[I[start+len/2]+h];\n\tjj=0;kk=0;\n\tfor(i=start;i<start+len;i++) {\n\t\tif(V[I[i]+h]<x) jj++;\n\t\tif(V[I[i]+h]==x) kk++;\n\t};\n\tjj+=start;kk+=jj;\n\n\ti=start;j=0;k=0;\n\twhile(i<jj) {\n\t\tif(V[I[i]+h]<x) {\n\t\t\ti++;\n\t\t} else if(V[I[i]+h]==x) {\n\t\t\ttmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp;\n\t\t\tj++;\n\t\t} else {\n\t\t\ttmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp;\n\t\t\tk++;\n\t\t};\n\t};\n\n\twhile(jj+j<kk) {\n\t\tif(V[I[jj+j]+h]==x) {\n\t\t\tj++;\n\t\t} else {\n\t\t\ttmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp;\n\t\t\tk++;\n\t\t};\n\t};\n\n\tif(jj>start) split(I,V,start,jj-start,h);\n\n\tfor(i=0;i<kk-jj;i++) V[I[jj+i]]=kk-1;\n\tif(jj==kk-1) I[jj]=-1;\n\n\tif(start+len>kk) split(I,V,kk,start+len-kk,h);\n}\n\nstatic void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize)\n{\n\tint64_t buckets[256];\n\tint64_t i,h,len;\n\n\tfor(i=0;i<256;i++) buckets[i]=0;\n\tfor(i=0;i<oldsize;i++) buckets[old[i]]++;\n\tfor(i=1;i<256;i++) buckets[i]+=buckets[i-1];\n\tfor(i=255;i>0;i--) buckets[i]=buckets[i-1];\n\tbuckets[0]=0;\n\n\tfor(i=0;i<oldsize;i++) I[++buckets[old[i]]]=i;\n\tI[0]=oldsize;\n\tfor(i=0;i<oldsize;i++) V[i]=buckets[old[i]];\n\tV[oldsize]=0;\n\tfor(i=1;i<256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1;\n\tI[0]=-1;\n\n\tfor(h=1;I[0]!=-(oldsize+1);h+=h) {\n\t\tlen=0;\n\t\tfor(i=0;i<oldsize+1;) {\n\t\t\tif(I[i]<0) {\n\t\t\t\tlen-=I[i];\n\t\t\t\ti-=I[i];\n\t\t\t} else {\n\t\t\t\tif(len) I[i-len]=-len;\n\t\t\t\tlen=V[I[i]]+1-i;\n\t\t\t\tsplit(I,V,i,len,h);\n\t\t\t\ti+=len;\n\t\t\t\tlen=0;\n\t\t\t};\n\t\t};\n\t\tif(len) I[i-len]=-len;\n\t};\n\n\tfor(i=0;i<oldsize+1;i++) I[V[i]]=i;\n}\n\nstatic int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize)\n{\n\tint64_t i;\n\n\tfor(i=0;(i<oldsize)&&(i<newsize);i++)\n\t\tif(old[i]!=new[i]) break;\n\n\treturn i;\n}\n\nstatic int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize,\n\t\tconst uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos)\n{\n\tint64_t x,y;\n\n\tif(en-st<2) {\n\t\tx=matchlen(old+I[st],oldsize-I[st],new,newsize);\n\t\ty=matchlen(old+I[en],oldsize-I[en],new,newsize);\n\n\t\tif(x>y) {\n\t\t\t*pos=I[st];\n\t\t\treturn x;\n\t\t} else {\n\t\t\t*pos=I[en];\n\t\t\treturn y;\n\t\t}\n\t};\n\n\tx=st+(en-st)/2;\n\tif(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))<0) {\n\t\treturn search(I,old,oldsize,new,newsize,x,en,pos);\n\t} else {\n\t\treturn search(I,old,oldsize,new,newsize,st,x,pos);\n\t};\n}\n\nstatic void offtout(int64_t x,uint8_t *buf)\n{\n\tint64_t y;\n\n\tif(x<0) y=-x; else y=x;\n\n\tbuf[0]=y%256;y-=buf[0];\n\ty=y/256;buf[1]=y%256;y-=buf[1];\n\ty=y/256;buf[2]=y%256;y-=buf[2];\n\ty=y/256;buf[3]=y%256;y-=buf[3];\n\ty=y/256;buf[4]=y%256;y-=buf[4];\n\ty=y/256;buf[5]=y%256;y-=buf[5];\n\ty=y/256;buf[6]=y%256;y-=buf[6];\n\ty=y/256;buf[7]=y%256;\n\n\tif(x<0) buf[7]|=0x80;\n}\n\nstatic int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length)\n{\n\tint64_t result = 0;\n\n\twhile (length > 0)\n\t{\n\t\tconst int smallsize = (int)MIN(length, INT_MAX);\n\t\tconst int writeresult = stream->write(stream, buffer, smallsize);\n\t\tif (writeresult == -1)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tresult += writeresult;\n\t\tlength -= smallsize;\n\t\tbuffer = (uint8_t*)buffer + smallsize;\n\t}\n\n\treturn result;\n}\n\nstruct bsdiff_request\n{\n\tconst uint8_t* old;\n\tint64_t oldsize;\n\tconst uint8_t* new;\n\tint64_t newsize;\n\tstruct bsdiff_stream* stream;\n\tint64_t *I;\n\tuint8_t *buffer;\n};\n\nstatic int bsdiff_internal(const struct bsdiff_request req)\n{\n\tint64_t *I,*V;\n\tint64_t scan,pos,len;\n\tint64_t lastscan,lastpos,lastoffset;\n\tint64_t oldscore,scsc;\n\tint64_t s,Sf,lenf,Sb,lenb;\n\tint64_t overlap,Ss,lens;\n\tint64_t i;\n\tuint8_t *buffer;\n\tuint8_t buf[8 * 3];\n\n\tif((V=req.stream->malloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1;\n\tI = req.I;\n\n\tqsufsort(I,V,req.old,req.oldsize);\n\treq.stream->free(V);\n\n\tbuffer = req.buffer;\n\n\t/* Compute the differences, writing ctrl as we go */\n\tscan=0;len=0;pos=0;\n\tlastscan=0;lastpos=0;lastoffset=0;\n\twhile(scan<req.newsize) {\n\t\toldscore=0;\n\n\t\tfor(scsc=scan+=len;scan<req.newsize;scan++) {\n\t\t\tlen=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan,\n\t\t\t\t\t0,req.oldsize,&pos);\n\n\t\t\tfor(;scsc<scan+len;scsc++)\n\t\t\tif((scsc+lastoffset<req.oldsize) &&\n\t\t\t\t(req.old[scsc+lastoffset] == req.new[scsc]))\n\t\t\t\toldscore++;\n\n\t\t\tif(((len==oldscore) && (len!=0)) || \n\t\t\t\t(len>oldscore+8)) break;\n\n\t\t\tif((scan+lastoffset<req.oldsize) &&\n\t\t\t\t(req.old[scan+lastoffset] == req.new[scan]))\n\t\t\t\toldscore--;\n\t\t};\n\n\t\tif((len!=oldscore) || (scan==req.newsize)) {\n\t\t\ts=0;Sf=0;lenf=0;\n\t\t\tfor(i=0;(lastscan+i<scan)&&(lastpos+i<req.oldsize);) {\n\t\t\t\tif(req.old[lastpos+i]==req.new[lastscan+i]) s++;\n\t\t\t\ti++;\n\t\t\t\tif(s*2-i>Sf*2-lenf) { Sf=s; lenf=i; };\n\t\t\t};\n\n\t\t\tlenb=0;\n\t\t\tif(scan<req.newsize) {\n\t\t\t\ts=0;Sb=0;\n\t\t\t\tfor(i=1;(scan>=lastscan+i)&&(pos>=i);i++) {\n\t\t\t\t\tif(req.old[pos-i]==req.new[scan-i]) s++;\n\t\t\t\t\tif(s*2-i>Sb*2-lenb) { Sb=s; lenb=i; };\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tif(lastscan+lenf>scan-lenb) {\n\t\t\t\toverlap=(lastscan+lenf)-(scan-lenb);\n\t\t\t\ts=0;Ss=0;lens=0;\n\t\t\t\tfor(i=0;i<overlap;i++) {\n\t\t\t\t\tif(req.new[lastscan+lenf-overlap+i]==\n\t\t\t\t\t   req.old[lastpos+lenf-overlap+i]) s++;\n\t\t\t\t\tif(req.new[scan-lenb+i]==\n\t\t\t\t\t   req.old[pos-lenb+i]) s--;\n\t\t\t\t\tif(s>Ss) { Ss=s; lens=i+1; };\n\t\t\t\t};\n\n\t\t\t\tlenf+=lens-overlap;\n\t\t\t\tlenb-=lens;\n\t\t\t};\n\n\t\t\tofftout(lenf,buf);\n\t\t\tofftout((scan-lenb)-(lastscan+lenf),buf+8);\n\t\t\tofftout((pos-lenb)-(lastpos+lenf),buf+16);\n\n\t\t\t/* Write control data */\n\t\t\tif (writedata(req.stream, buf, sizeof(buf)))\n\t\t\t\treturn -1;\n\n\t\t\t/* Write diff data */\n\t\t\tfor(i=0;i<lenf;i++)\n\t\t\t\tbuffer[i]=req.new[lastscan+i]-req.old[lastpos+i];\n\t\t\tif (writedata(req.stream, buffer, lenf))\n\t\t\t\treturn -1;\n\n\t\t\t/* Write extra data */\n\t\t\tfor(i=0;i<(scan-lenb)-(lastscan+lenf);i++)\n\t\t\t\tbuffer[i]=req.new[lastscan+lenf+i];\n\t\t\tif (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf)))\n\t\t\t\treturn -1;\n\n\t\t\tlastscan=scan-lenb;\n\t\t\tlastpos=pos-lenb;\n\t\t\tlastoffset=pos-scan;\n\t\t};\n\t};\n\n\treturn 0;\n}\n\nint bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream)\n{\n\tint result;\n\tstruct bsdiff_request req;\n\n\tif((req.I=stream->malloc((oldsize+1)*sizeof(int64_t)))==NULL)\n\t\treturn -1;\n\n\tif((req.buffer=stream->malloc(newsize+1))==NULL)\n\t{\n\t\tstream->free(req.I);\n\t\treturn -1;\n\t}\n\n\treq.old = old;\n\treq.oldsize = oldsize;\n\treq.new = new;\n\treq.newsize = newsize;\n\treq.stream = stream;\n\n\tresult = bsdiff_internal(req);\n\n\tstream->free(req.buffer);\n\tstream->free(req.I);\n\n\treturn result;\n}\n\n#if defined(BSDIFF_EXECUTABLE)\n\n#include <sys/types.h>\n\n#include <bzlib.h>\n#include <err.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstatic int bz2_write(struct bsdiff_stream* stream, const void* buffer, int size)\n{\n\tint bz2err;\n\tBZFILE* bz2;\n\n\tbz2 = (BZFILE*)stream->opaque;\n\tBZ2_bzWrite(&bz2err, bz2, (void*)buffer, size);\n\tif (bz2err != BZ_STREAM_END && bz2err != BZ_OK)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint main(int argc,char *argv[])\n{\n\tint fd;\n\tint bz2err;\n\tuint8_t *old,*new;\n\toff_t oldsize,newsize;\n\tuint8_t buf[8];\n\tFILE * pf;\n\tstruct bsdiff_stream stream;\n\tBZFILE* bz2;\n\n\tmemset(&bz2, 0, sizeof(bz2));\n\tstream.malloc = malloc;\n\tstream.free = free;\n\tstream.write = bz2_write;\n\n\tif(argc!=4) errx(1,\"usage: %s oldfile newfile patchfile\\n\",argv[0]);\n\n\t/* Allocate oldsize+1 bytes instead of oldsize bytes to ensure\n\t\tthat we never try to malloc(0) and get a NULL pointer */\n\tif(((fd=open(argv[1],O_RDONLY,0))<0) ||\n\t\t((oldsize=lseek(fd,0,SEEK_END))==-1) ||\n\t\t((old=malloc(oldsize+1))==NULL) ||\n\t\t(lseek(fd,0,SEEK_SET)!=0) ||\n\t\t(read(fd,old,oldsize)!=oldsize) ||\n\t\t(close(fd)==-1)) err(1,\"%s\",argv[1]);\n\n\n\t/* Allocate newsize+1 bytes instead of newsize bytes to ensure\n\t\tthat we never try to malloc(0) and get a NULL pointer */\n\tif(((fd=open(argv[2],O_RDONLY,0))<0) ||\n\t\t((newsize=lseek(fd,0,SEEK_END))==-1) ||\n\t\t((new=malloc(newsize+1))==NULL) ||\n\t\t(lseek(fd,0,SEEK_SET)!=0) ||\n\t\t(read(fd,new,newsize)!=newsize) ||\n\t\t(close(fd)==-1)) err(1,\"%s\",argv[2]);\n\n\t/* Create the patch file */\n\tif ((pf = fopen(argv[3], \"w\")) == NULL)\n\t\terr(1, \"%s\", argv[3]);\n\n\t/* Write header (signature+newsize)*/\n\tofftout(newsize, buf);\n\tif (fwrite(\"ENDSLEY/BSDIFF43\", 16, 1, pf) != 1 ||\n\t\tfwrite(buf, sizeof(buf), 1, pf) != 1)\n\t\terr(1, \"Failed to write header\");\n\n\n\tif (NULL == (bz2 = BZ2_bzWriteOpen(&bz2err, pf, 9, 0, 0)))\n\t\terrx(1, \"BZ2_bzWriteOpen, bz2err=%d\", bz2err);\n\n\tstream.opaque = bz2;\n\tif (bsdiff(old, oldsize, new, newsize, &stream))\n\t\terr(1, \"bsdiff\");\n\n\tBZ2_bzWriteClose(&bz2err, bz2, 0, NULL, NULL);\n\tif (bz2err != BZ_OK)\n\t\terr(1, \"BZ2_bzWriteClose, bz2err=%d\", bz2err);\n\n\tif (fclose(pf))\n\t\terr(1, \"fclose\");\n\n\t/* Free the memory we used */\n\tfree(old);\n\tfree(new);\n\n\treturn 0;\n}\n\n#endif\n"
        },
        {
          "name": "bsdiff.h",
          "type": "blob",
          "size": 1.697265625,
          "content": "/*-\n * Copyright 2003-2005 Colin Percival\n * Copyright 2012 Matthew Endsley\n * All rights reserved\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted providing that the following conditions \n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef BSDIFF_H\n# define BSDIFF_H\n\n# include <stddef.h>\n# include <stdint.h>\n\nstruct bsdiff_stream\n{\n\tvoid* opaque;\n\n\tvoid* (*malloc)(size_t size);\n\tvoid (*free)(void* ptr);\n\tint (*write)(struct bsdiff_stream* stream, const void* buffer, int size);\n};\n\nint bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream);\n\n#endif\n"
        },
        {
          "name": "bspatch.c",
          "type": "blob",
          "size": 4.6708984375,
          "content": "﻿/*-\n * Copyright 2003-2005 Colin Percival\n * Copyright 2012 Matthew Endsley\n * All rights reserved\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted providing that the following conditions \n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <limits.h>\n#include \"bspatch.h\"\n\nstatic int64_t offtin(uint8_t *buf)\n{\n\tint64_t y;\n\n\ty=buf[7]&0x7F;\n\ty=y*256;y+=buf[6];\n\ty=y*256;y+=buf[5];\n\ty=y*256;y+=buf[4];\n\ty=y*256;y+=buf[3];\n\ty=y*256;y+=buf[2];\n\ty=y*256;y+=buf[1];\n\ty=y*256;y+=buf[0];\n\n\tif(buf[7]&0x80) y=-y;\n\n\treturn y;\n}\n\nint bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream)\n{\n\tuint8_t buf[8];\n\tint64_t oldpos,newpos;\n\tint64_t ctrl[3];\n\tint64_t i;\n\n\toldpos=0;newpos=0;\n\twhile(newpos<newsize) {\n\t\t/* Read control data */\n\t\tfor(i=0;i<=2;i++) {\n\t\t\tif (stream->read(stream, buf, 8))\n\t\t\t\treturn -1;\n\t\t\tctrl[i]=offtin(buf);\n\t\t};\n\n\t\t/* Sanity-check */\n\t\tif (ctrl[0]<0 || ctrl[0]>INT_MAX ||\n\t\t\tctrl[1]<0 || ctrl[1]>INT_MAX ||\n\t\t\tnewpos+ctrl[0]>newsize)\n\t\t\treturn -1;\n\n\t\t/* Read diff string */\n\t\tif (stream->read(stream, new + newpos, ctrl[0]))\n\t\t\treturn -1;\n\n\t\t/* Add old data to diff string */\n\t\tfor(i=0;i<ctrl[0];i++)\n\t\t\tif((oldpos+i>=0) && (oldpos+i<oldsize))\n\t\t\t\tnew[newpos+i]+=old[oldpos+i];\n\n\t\t/* Adjust pointers */\n\t\tnewpos+=ctrl[0];\n\t\toldpos+=ctrl[0];\n\n\t\t/* Sanity-check */\n\t\tif(newpos+ctrl[1]>newsize)\n\t\t\treturn -1;\n\n\t\t/* Read extra string */\n\t\tif (stream->read(stream, new + newpos, ctrl[1]))\n\t\t\treturn -1;\n\n\t\t/* Adjust pointers */\n\t\tnewpos+=ctrl[1];\n\t\toldpos+=ctrl[2];\n\t};\n\n\treturn 0;\n}\n\n#if defined(BSPATCH_EXECUTABLE)\n\n#include <bzlib.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <err.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nstatic int bz2_read(const struct bspatch_stream* stream, void* buffer, int length)\n{\n\tint n;\n\tint bz2err;\n\tBZFILE* bz2;\n\n\tbz2 = (BZFILE*)stream->opaque;\n\tn = BZ2_bzRead(&bz2err, bz2, buffer, length);\n\tif (n != length)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint main(int argc,char * argv[])\n{\n\tFILE * f;\n\tint fd;\n\tint bz2err;\n\tuint8_t header[24];\n\tuint8_t *old, *new;\n\tint64_t oldsize, newsize;\n\tBZFILE* bz2;\n\tstruct bspatch_stream stream;\n\tstruct stat sb;\n\n\tif(argc!=4) errx(1,\"usage: %s oldfile newfile patchfile\\n\",argv[0]);\n\n\t/* Open patch file */\n\tif ((f = fopen(argv[3], \"r\")) == NULL)\n\t\terr(1, \"fopen(%s)\", argv[3]);\n\n\t/* Read header */\n\tif (fread(header, 1, 24, f) != 24) {\n\t\tif (feof(f))\n\t\t\terrx(1, \"Corrupt patch\\n\");\n\t\terr(1, \"fread(%s)\", argv[3]);\n\t}\n\n\t/* Check for appropriate magic */\n\tif (memcmp(header, \"ENDSLEY/BSDIFF43\", 16) != 0)\n\t\terrx(1, \"Corrupt patch\\n\");\n\n\t/* Read lengths from header */\n\tnewsize=offtin(header+16);\n\tif(newsize<0)\n\t\terrx(1,\"Corrupt patch\\n\");\n\n\t/* Close patch file and re-open it via libbzip2 at the right places */\n\tif(((fd=open(argv[1],O_RDONLY,0))<0) ||\n\t\t((oldsize=lseek(fd,0,SEEK_END))==-1) ||\n\t\t((old=malloc(oldsize+1))==NULL) ||\n\t\t(lseek(fd,0,SEEK_SET)!=0) ||\n\t\t(read(fd,old,oldsize)!=oldsize) ||\n\t\t(fstat(fd, &sb)) ||\n\t\t(close(fd)==-1)) err(1,\"%s\",argv[1]);\n\tif((new=malloc(newsize+1))==NULL) err(1,NULL);\n\n\tif (NULL == (bz2 = BZ2_bzReadOpen(&bz2err, f, 0, 0, NULL, 0)))\n\t\terrx(1, \"BZ2_bzReadOpen, bz2err=%d\", bz2err);\n\n\tstream.read = bz2_read;\n\tstream.opaque = bz2;\n\tif (bspatch(old, oldsize, new, newsize, &stream))\n\t\terrx(1, \"bspatch\");\n\n\t/* Clean up the bzip2 reads */\n\tBZ2_bzReadClose(&bz2err, bz2);\n\tfclose(f);\n\n\t/* Write the new file */\n\tif(((fd=open(argv[2],O_CREAT|O_TRUNC|O_WRONLY,sb.st_mode))<0) ||\n\t\t(write(fd,new,newsize)!=newsize) || (close(fd)==-1))\n\t\terr(1,\"%s\",argv[2]);\n\n\tfree(new);\n\tfree(old);\n\n\treturn 0;\n}\n\n#endif\n"
        },
        {
          "name": "bspatch.h",
          "type": "blob",
          "size": 1.6220703125,
          "content": "/*-\n * Copyright 2003-2005 Colin Percival\n * Copyright 2012 Matthew Endsley\n * All rights reserved\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted providing that the following conditions \n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef BSPATCH_H\n# define BSPATCH_H\n\n# include <stdint.h>\n\nstruct bspatch_stream\n{\n\tvoid* opaque;\n\tint (*read)(const struct bspatch_stream* stream, void* buffer, int length);\n};\n\nint bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream);\n\n#endif\n\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 0.7119140625,
          "content": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_INIT([bsdiff], [0.1])\nAC_CONFIG_SRCDIR([bsdiff.c])\nAC_CONFIG_HEADERS([config.h])\nAM_INIT_AUTOMAKE([1.9])\n\n# Checks for programs.\nAC_PROG_CC\n\n# Checks for libraries.\n# FIXME: Replace `main' with a function in `-lbz2':\nAC_CHECK_LIB([bz2], [BZ2_bzReadOpen])\n\nAC_CHECK_HEADERS([fcntl.h limits.h stddef.h stdint.h stdlib.h string.h unistd.h])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_TYPE_INT64_T\nAC_TYPE_OFF_T\nAC_TYPE_SIZE_T\nAC_TYPE_UINT8_T\n\n# Checks for library functions.\nAC_FUNC_MALLOC\nAC_CHECK_FUNCS([memset])\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n"
        }
      ]
    }
  ]
}