{
  "metadata": {
    "timestamp": 1736709818043,
    "page": 276,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "RsyncProject/rsync",
      "stars": 3072,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.73828125,
          "content": "*.[oa]\n*~\ndummy\nID\nMakefile\nMakefile.old\nconfigure.sh\nconfigure.sh.old\nconfig.cache\nconfig.h\nconfig.h.in\nconfig.h.in.old\nconfig.log\nconfig.status\naclocal.m4\n/proto.h\n/proto.h-tstamp\n/rsync*.[15]\n/rrsync\n/rrsync*.1\n/rsync*.html\n/rrsync*.html\n/help-rsync*.h\n/default-cvsignore.h\n/default-dont-compress.h\n/daemon-parm.h\n/.md2man-works\n/autom4te*.cache\n/confdefs.h\n/conftest*\n/dox\n/getgroups\n/gists\n/gmon.out\n/rsync\n/stunnel-rsyncd.conf\n/shconfig\n/git-version.h\n/testdir\n/tests-dont-exist\n/testtmp\n/tls\n/testrun\n/trimslash\n/t_unsafe\n/wildtest\n/getfsdev\n/rounding.h\n/doc/rsync.pdf\n/doc/rsync.ps\n/support/savetransfer\n/testsuite/chown-fake.test\n/testsuite/devices-fake.test\n/testsuite/xattrs-hlink.test\n/patches\n/patches.gen\n/build\n/auto-build-save\n.deps\n/*.exe\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 34.732421875,
          "content": "REGARDING OPENSSL AND XXHASH\n\nIn addition, as a special exception, the copyright holders give\npermission to dynamically link rsync with the OpenSSL and xxhash\nlibraries when those libraries are being distributed in compliance\nwith their license terms, and to distribute a dynamically linked\ncombination of rsync and these libraries.  This is also considered\nto be covered under the GPL's System Libraries exception.\n\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "Doxyfile",
          "type": "blob",
          "size": 6.982421875,
          "content": "# Doxyfile 1.2.15\n\n#---------------------------------------------------------------------------\n# General configuration options\n#---------------------------------------------------------------------------\nPROJECT_NAME           = rsync\nPROJECT_NUMBER         = HEAD\nOUTPUT_DIRECTORY       = dox\nOUTPUT_LANGUAGE        = English\nEXTRACT_ALL            = YES\nEXTRACT_PRIVATE        = YES\nEXTRACT_STATIC         = YES\nEXTRACT_LOCAL_CLASSES  = YES\nHIDE_UNDOC_MEMBERS     = NO\nHIDE_UNDOC_CLASSES     = NO\nBRIEF_MEMBER_DESC      = YES\nREPEAT_BRIEF           = YES\nALWAYS_DETAILED_SEC    = NO\nINLINE_INHERITED_MEMB  = NO\nFULL_PATH_NAMES        = NO\nSTRIP_FROM_PATH        = *source\nINTERNAL_DOCS          = YES\nSTRIP_CODE_COMMENTS    = NO\nCASE_SENSE_NAMES       = YES\nSHORT_NAMES            = NO\nHIDE_SCOPE_NAMES       = YES\nVERBATIM_HEADERS       = YES\nSHOW_INCLUDE_FILES     = YES\nJAVADOC_AUTOBRIEF      = YES\nINHERIT_DOCS           = YES\nINLINE_INFO            = YES\nSORT_MEMBER_DOCS       = NO\nDISTRIBUTE_GROUP_DOC   = NO\nTAB_SIZE               = 8\nGENERATE_TODOLIST      = YES\nGENERATE_TESTLIST      = YES\nGENERATE_BUGLIST       = YES\nALIASES                = \nENABLED_SECTIONS       = \nMAX_INITIALIZER_LINES  = 30\nOPTIMIZE_OUTPUT_FOR_C  = YES\nOPTIMIZE_OUTPUT_JAVA   = NO\nSHOW_USED_FILES        = YES\n#---------------------------------------------------------------------------\n# configuration options related to warning and progress messages\n#---------------------------------------------------------------------------\nQUIET                  = NO\nWARNINGS               = NO\nWARN_IF_UNDOCUMENTED   = NO\nWARN_FORMAT            = \"$file:$line: $text\"\nWARN_LOGFILE           = \n#---------------------------------------------------------------------------\n# configuration options related to the input files\n#---------------------------------------------------------------------------\nINPUT                  = .\nFILE_PATTERNS          = *.c \\\n                         *.h\nRECURSIVE              = YES\nEXCLUDE                = proto.h \\\n                         zlib \\\n                         popt\nEXCLUDE_SYMLINKS       = NO\nEXCLUDE_PATTERNS       = \nEXAMPLE_PATH           = \nEXAMPLE_PATTERNS       = \nEXAMPLE_RECURSIVE      = NO\nIMAGE_PATH             = \nINPUT_FILTER           = \nFILTER_SOURCE_FILES    = NO\n#---------------------------------------------------------------------------\n# configuration options related to source browsing\n#---------------------------------------------------------------------------\nSOURCE_BROWSER         = YES\nINLINE_SOURCES         = YES\nREFERENCED_BY_RELATION = YES\nREFERENCES_RELATION    = YES\n#---------------------------------------------------------------------------\n# configuration options related to the alphabetical class index\n#---------------------------------------------------------------------------\nALPHABETICAL_INDEX     = YES\nCOLS_IN_ALPHA_INDEX    = 3\nIGNORE_PREFIX          = \n#---------------------------------------------------------------------------\n# configuration options related to the HTML output\n#---------------------------------------------------------------------------\nGENERATE_HTML          = YES\nHTML_OUTPUT            = html\nHTML_FILE_EXTENSION    = .html\nHTML_HEADER            = \nHTML_FOOTER            = \nHTML_STYLESHEET        = \nHTML_ALIGN_MEMBERS     = YES\nGENERATE_HTMLHELP      = NO\nGENERATE_CHI           = NO\nBINARY_TOC             = NO\nTOC_EXPAND             = NO\nDISABLE_INDEX          = NO\nENUM_VALUES_PER_LINE   = 3\nGENERATE_TREEVIEW      = NO\nTREEVIEW_WIDTH         = 250\n#---------------------------------------------------------------------------\n# configuration options related to the LaTeX output\n#---------------------------------------------------------------------------\nGENERATE_LATEX         = NO\nLATEX_OUTPUT           = latex\nLATEX_CMD_NAME         = latex\nMAKEINDEX_CMD_NAME     = makeindex\nCOMPACT_LATEX          = NO\nPAPER_TYPE             = a4wide\nEXTRA_PACKAGES         = \nLATEX_HEADER           = \nPDF_HYPERLINKS         = YES\nUSE_PDFLATEX           = YES\nLATEX_BATCHMODE        = YES\n#---------------------------------------------------------------------------\n# configuration options related to the RTF output\n#---------------------------------------------------------------------------\nGENERATE_RTF           = NO\nRTF_OUTPUT             = rtf\nCOMPACT_RTF            = NO\nRTF_HYPERLINKS         = NO\nRTF_STYLESHEET_FILE    = \nRTF_EXTENSIONS_FILE    = \n#---------------------------------------------------------------------------\n# configuration options related to the man page output\n#---------------------------------------------------------------------------\nGENERATE_MAN           = NO\nMAN_OUTPUT             = man\nMAN_EXTENSION          = .3\nMAN_LINKS              = NO\n#---------------------------------------------------------------------------\n# configuration options related to the XML output\n#---------------------------------------------------------------------------\nGENERATE_XML           = NO\n#---------------------------------------------------------------------------\n# configuration options for the AutoGen Definitions output\n#---------------------------------------------------------------------------\nGENERATE_AUTOGEN_DEF   = NO\n#---------------------------------------------------------------------------\n# Configuration options related to the preprocessor   \n#---------------------------------------------------------------------------\nENABLE_PREPROCESSING   = NO\nMACRO_EXPANSION        = NO\nEXPAND_ONLY_PREDEF     = NO\nSEARCH_INCLUDES        = YES\nINCLUDE_PATH           = \nINCLUDE_FILE_PATTERNS  = \nPREDEFINED             = \nEXPAND_AS_DEFINED      = \nSKIP_FUNCTION_MACROS   = YES\n#---------------------------------------------------------------------------\n# Configuration::addtions related to external references   \n#---------------------------------------------------------------------------\nTAGFILES               = \nGENERATE_TAGFILE       = \nALLEXTERNALS           = NO\nEXTERNAL_GROUPS        = YES\nPERL_PATH              = /usr/bin/perl\n#---------------------------------------------------------------------------\n# Configuration options related to the dot tool   \n#---------------------------------------------------------------------------\nCLASS_DIAGRAMS         = YES\nHAVE_DOT               = YES\nCLASS_GRAPH            = YES\nCOLLABORATION_GRAPH    = YES\nTEMPLATE_RELATIONS     = YES\nHIDE_UNDOC_RELATIONS   = YES\nINCLUDE_GRAPH          = YES\nINCLUDED_BY_GRAPH      = YES\nGRAPHICAL_HIERARCHY    = YES\nDOT_IMAGE_FORMAT       = png\nDOT_PATH               = \nDOTFILE_DIRS           = \nMAX_DOT_GRAPH_WIDTH    = 1024\nMAX_DOT_GRAPH_HEIGHT   = 1024\nGENERATE_LEGEND        = YES\nDOT_CLEANUP            = YES\n#---------------------------------------------------------------------------\n# Configuration::addtions related to the search engine   \n#---------------------------------------------------------------------------\nSEARCHENGINE           = NO\nCGI_NAME               = search.cgi\nCGI_URL                = \nDOC_URL                = \nDOC_ABSPATH            = \nBIN_ABSPATH            = /usr/local/bin/\nEXT_DOC_PATHS          = \n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 9.5078125,
          "content": "# How to build and install rsync\n\nWhen building rsync, you'll want to install various libraries in order to get\nall the features enabled.  The configure script will alert you when the\nnewest libraries are missing and tell you the appropriate `--disable-LIB`\noption to use if you want to just skip that feature.  What follows are various\nsupport libraries that you may want to install to build rsync with the maximum\nfeatures (the impatient can skip down to the package summary):\n\n## The basic setup\n\nYou need to have a C compiler installed and optionally a C++ compiler in order\nto try to build some hardware-accelerated checksum routines.  Rsync also needs\na modern awk, which might be provided via gawk or nawk on some OSes.\n\n## Autoconf & manpages\n\nIf you're installing from the git repo (instead of a release tar file) you'll\nalso need the GNU autotools (autoconf & automake) and your choice of 2 python3\nmarkdown libraries: cmarkgfm or commonmark (needed to generate the manpages).\nIf your OS doesn't provide a python3-cmarkgfm or python3-commonmark package,\nyou can run the following to install the commonmark python library for your\nbuild user (after installing python3's pip package):\n\n>     python3 -mpip install --user commonmark\n\nYou can test if you've got it fixed by running (from the rsync checkout):\n\n>     ./md-convert --test rsync-ssl.1.md\n\nAlternately, you can avoid generating the manpages by fetching the very latest\nversions (that match the latest git source) from the [generated-files][6] dir.\nOne way to do that is to run:\n\n>     ./prepare-source fetchgen\n\n[6]: https://download.samba.org/pub/rsync/generated-files/\n\n## ACL support\n\nTo support copying ACL file information, make sure you have an acl\ndevelopment library installed. It also helps to have the helper programs\ninstalled to manipulate ACLs and to run the rsync testsuite.\n\n## Xattr support\n\nTo support copying xattr file information, make sure you have an attr\ndevelopment library installed. It also helps to have the helper programs\ninstalled to manipulate xattrs and to run the rsync testsuite.\n\n## xxhash\n\nThe [xxHash library][1] provides extremely fast checksum functions that can\nmake the \"rsync algorithm\" run much more quickly, especially when matching\nblocks in large files.  Installing this development library adds xxhash\nchecksums as the default checksum algorithm.  You'll need at least v0.8.0\nif you want rsync to include the full range of its checksum algorithms.\n\n[1]: https://cyan4973.github.io/xxHash/\n\n## zstd\n\nThe [zstd library][2] compression algorithm that uses less CPU than\nthe default zlib algorithm at the same compression level.  Note that you\nneed at least version 1.4, so you might need to skip the zstd compression if\nyou can only install a 1.3 release.  Installing this development library\nadds zstd compression as the default compression algorithm.\n\n[2]: http://facebook.github.io/zstd/\n\n## lz4\n\nThe [lz4 library][3] compression algorithm that uses very little CPU, though\nit also has the smallest compression ratio of other algorithms.  Installing\nthis development library adds lz4 compression as an available compression\nalgorithm.\n\n[3]: https://lz4.github.io/lz4/\n\n## openssl crypto\n\nThe [openssl crypto library][4] provides some hardware accelerated checksum\nalgorithms for MD4 and MD5.  Installing this development library makes rsync\nuse the (potentially) faster checksum routines when computing MD4 & MD5\nchecksums.\n\n[4]: https://www.openssl.org/docs/man1.0.2/man3/crypto.html\n\n## Package summary\n\nTo help you get the libraries installed, here are some package install commands\nfor various OSes.  The commands are split up to correspond with the above\nitems, but feel free to combine the package names into a single install, if you\nlike.\n\n -  For Debian and Ubuntu (Debian Buster users may want to briefly(?) enable\n    buster-backports to update zstd from 1.3 to 1.4):\n\n    >     sudo apt install -y gcc g++ gawk autoconf automake python3-cmarkgfm\n    >     sudo apt install -y acl libacl1-dev\n    >     sudo apt install -y attr libattr1-dev\n    >     sudo apt install -y libxxhash-dev\n    >     sudo apt install -y libzstd-dev\n    >     sudo apt install -y liblz4-dev\n    >     sudo apt install -y libssl-dev\n\nOr run support/install_deps_ubuntu.sh\n\n -  For CentOS (use EPEL for python3-pip):\n\n    >     sudo yum -y install epel-release\n    >     sudo yum -y install gcc g++ gawk autoconf automake python3-pip\n    >     sudo yum -y install acl libacl-devel\n    >     sudo yum -y install attr libattr-devel\n    >     sudo yum -y install xxhash-devel\n    >     sudo yum -y install libzstd-devel\n    >     sudo yum -y install lz4-devel\n    >     sudo yum -y install openssl-devel\n    >     python3 -mpip install --user commonmark\n\n -  For Fedora 33:\n\n    >     sudo dnf -y install acl libacl-devel\n    >     sudo dnf -y install attr libattr-devel\n    >     sudo dnf -y install xxhash-devel\n    >     sudo dnf -y install libzstd-devel\n    >     sudo dnf -y install lz4-devel\n    >     sudo dnf -y install openssl-devel\n\n -  For FreeBSD (this assumes that the python3 version is 3.7):\n\n    >     sudo pkg install -y autotools python3 py37-CommonMark\n    >     sudo pkg install -y xxhash\n    >     sudo pkg install -y zstd\n    >     sudo pkg install -y liblz4\n\n -  For macOS:\n\n    >     brew install automake\n    >     brew install xxhash\n    >     brew install zstd\n    >     brew install lz4\n    >     brew install openssl\n\n -  For Cygwin (with all cygwin programs stopped, run the appropriate setup program from a cmd shell):\n\n    >     setup-x86_64 --quiet-mode -P make,gawk,autoconf,automake,gcc-core,python38,python38-pip\n    >     setup-x86_64 --quiet-mode -P attr,libattr-devel\n    >     setup-x86_64 --quiet-mode -P libzstd-devel\n    >     setup-x86_64 --quiet-mode -P liblz4-devel\n    >     setup-x86_64 --quiet-mode -P libssl-devel\n\n    Sometimes cygwin has commonmark packaged and sometimes it doesn't. Now that\n    its python38 has stabilized, you could install python38-commonmark. Or just\n    avoid the issue by running this from a bash shell as your build user:\n\n    >     python3 -mpip install --user commonmark\n\n## Build and install\n\nAfter installing the various libraries, you need to configure, build, and\ninstall the source:\n\n>      ./configure\n>      make\n>      sudo make install\n\nThe default install path is /usr/local/bin, but you can set the installation\ndirectory and other parameters using options to ./configure.  To see them, use:\n\n>     ./configure --help\n\nConfigure tries to figure out if the local system uses group \"nobody\" or\n\"nogroup\" by looking in the /etc/group file.  (This is only used for the\ndefault group of an rsync daemon, which attempts to run with \"nobody\"\nuser and group permissions.)  You can change the default user and group\nfor the daemon by editing the NOBODY_USER and NOBODY_GROUP defines in\nconfig.h, or just override them in your /etc/rsyncd.conf file.\n\nAs of 2.4.7, rsync uses Eric Troan's popt option-parsing library.  A\ncut-down copy of a recent release is included in the rsync distribution,\nand will be used if there is no popt library on your build host, or if\nthe `--with-included-popt` option is passed to ./configure.\n\nIf you configure using `--enable-maintainer-mode`, then rsync will try\nto pop up an xterm on DISPLAY=:0 if it crashes.  You might find this\nuseful, but it should be turned off for production builds.\n\nIf you want to automatically use a separate \"build\" directory based on\nthe current git branch name, start with a pristine git checkout and run\n\"mkdir auto-build-save\" before you run the first ./configure command.\nThat will cause a fresh build dir to spring into existence along with a\nspecial Makefile symlink that allows you to run \"make\" and \"./configure\"\nfrom the source dir (the \"build\" dir gets auto switched based on branch).\nThis is helpful when using the branch-from-patch and patch-update scripts\nto maintain the official rsync patches.  If you ever need to build from\na \"detached head\" git position then you'll need to manually chdir into\nthe build dir to run make.  I also like to create 2 more symlinks in the\nsource dir:  `ln -s build/rsync . ; ln -s build/testtmp .`\n\n## Make compatibility\n\nNote that Makefile.in has a rule that uses a wildcard in a prerequisite.  If\nyour make has a problem with this rule, you will see an error like this:\n\n    Don't know how to make ./*.c\n\nYou can change the \"proto.h-tstamp\" target in Makefile.in to list all the \\*.c\nfilenames explicitly in order to avoid this issue.\n\n## RPM notes\n\nUnder packaging you will find .spec files for several distributions.\nThe .spec file in packaging/lsb can be used for Linux systems that\nadhere to the Linux Standards Base (e.g., RedHat and others).\n\n## HP-UX notes\n\nThe HP-UX 10.10 \"bundled\" C compiler seems not to be able to cope with\nANSI C.  You may see this error message in config.log if ./configure\nfails:\n\n    (Bundled) cc: \"configure\", line 2162: error 1705: Function prototypes are an ANSI feature.\n\nInstall gcc or HP's \"ANSI/C Compiler\".\n\n## Mac OS X notes\n\nSome versions of Mac OS X (Darwin) seem to have an IPv6 stack, but do\nnot completely implement the \"New Sockets\" API.\n\n[This site][5] says that Apple started to support IPv6 in 10.2 (Jaguar).  If\nyour build fails, try again after running configure with `--disable-ipv6`.\n\nApple Silicon macs may install packages in a slightly different location and require flags.\nCFLAGS=\"-I /opt/homebrew/include\" LDFLAGS=\"-L /opt/homebrew/lib\"\n\n[5]: http://www.ipv6.org/impl/mac.html\n\n## IBM AIX notes\n\nIBM AIX has a largefile problem with mkstemp.  See IBM PR-51921.\nThe workaround is to append the following to config.h:\n\n>     #ifdef _LARGE_FILES\n>     #undef HAVE_SECURE_MKSTEMP\n>     #endif\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 12.1572265625,
          "content": "# The Makefile for rsync (configure creates it from Makefile.in).\n\nprefix=@prefix@\ndatarootdir=@datarootdir@\nexec_prefix=@exec_prefix@\nbindir=@bindir@\nlibdir=@libdir@/rsync\nmandir=@mandir@\nwith_rrsync=@with_rrsync@\n\nLIBS=@LIBS@\nCC=@CC@\nAWK=@AWK@\nCFLAGS=@CFLAGS@\nCPPFLAGS=@CPPFLAGS@\nCXX=@CXX@\nCXXFLAGS=@CXXFLAGS@\nEXEEXT=@EXEEXT@\nLDFLAGS=@LDFLAGS@\nLIBOBJDIR=lib/\n\nINSTALLCMD=@INSTALL@\nINSTALLMAN=@INSTALL@\n\nsrcdir=@srcdir@\nMKDIR_P=@MKDIR_P@\nVPATH=$(srcdir)\nSHELL=/bin/sh\n\n.SUFFIXES:\n.SUFFIXES: .c .o\n\nROLL_SIMD_x86_64=simd-checksum-x86_64.o\nROLL_ASM_x86_64=simd-checksum-avx2.o\nMD5_ASM_x86_64=lib/md5-asm-x86_64.o\n\nGENFILES=configure.sh aclocal.m4 config.h.in rsync.1 rsync.1.html \\\n\t rsync-ssl.1 rsync-ssl.1.html rsyncd.conf.5 rsyncd.conf.5.html \\\n\t @GEN_RRSYNC@\nHEADERS=byteorder.h config.h errcode.h proto.h rsync.h ifuncs.h itypes.h inums.h \\\n\tlib/pool_alloc.h lib/mdigest.h lib/md-defines.h\nLIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o lib/md5.o \\\n\tlib/permstring.o lib/pool_alloc.o lib/sysacls.o lib/sysxattrs.o @LIBOBJS@\nzlib_OBJS=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \\\n\tzlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o\nOBJS1=flist.o rsync.o generator.o receiver.o cleanup.o sender.o exclude.o \\\n\tutil1.o util2.o main.o checksum.o match.o syscall.o log.o backup.o delete.o\nOBJS2=options.o io.o compat.o hlink.o token.o uidlist.o socket.o hashtable.o \\\n\tusage.o fileio.o batch.o clientname.o chmod.o acls.o xattrs.o\nOBJS3=progress.o pipe.o @MD5_ASM@ @ROLL_SIMD@ @ROLL_ASM@\nDAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o\npopt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \\\n\tpopt/popthelp.o popt/poptparse.o popt/poptint.o\nOBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) @BUILD_ZLIB@ @BUILD_POPT@\n\nTLS_OBJ = tls.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o @BUILD_POPT@\n\n# Programs we must have to run the test cases\nCHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \\\n\ttestrun$(EXEEXT) trimslash$(EXEEXT) t_unsafe$(EXEEXT) wildtest$(EXEEXT)\n\nCHECK_SYMLINKS = testsuite/chown-fake.test testsuite/devices-fake.test testsuite/xattrs-hlink.test\n\n# Objects for CHECK_PROGS to clean\nCHECK_OBJS=tls.o testrun.o getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.o wildtest.o\n\n# note that the -I. is needed to handle config.h when using VPATH\n.c.o:\n@OBJ_SAVE@\n\t$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@\n@OBJ_RESTORE@\n\n# NOTE: consider running \"packaging/smart-make\" instead of \"make\" to auto-handle\n# any changes to configure.sh and the main Makefile prior to a \"make all\".\nall: Makefile rsync$(EXEEXT) stunnel-rsyncd.conf @MAKE_RRSYNC@ @MAKE_MAN@\n.PHONY: all\n\n.PHONY: install\ninstall: all\n\t-$(MKDIR_P) $(DESTDIR)$(bindir)\n\t$(INSTALLCMD) $(INSTALL_STRIP) -m 755 rsync$(EXEEXT) $(DESTDIR)$(bindir)\n\t$(INSTALLCMD) -m 755 $(srcdir)/rsync-ssl $(DESTDIR)$(bindir)\n\t-$(MKDIR_P) $(DESTDIR)$(mandir)/man1\n\t-$(MKDIR_P) $(DESTDIR)$(mandir)/man5\n\tif test -f rsync.1; then $(INSTALLMAN) -m 644 rsync.1 $(DESTDIR)$(mandir)/man1; fi\n\tif test -f rsync-ssl.1; then $(INSTALLMAN) -m 644 rsync-ssl.1 $(DESTDIR)$(mandir)/man1; fi\n\tif test -f rsyncd.conf.5; then $(INSTALLMAN) -m 644 rsyncd.conf.5 $(DESTDIR)$(mandir)/man5; fi\n\tif test \"$(with_rrsync)\" = yes; then \\\n\t    $(INSTALLCMD) -m 755 rrsync $(DESTDIR)$(bindir); \\\n\t    if test -f rrsync.1; then $(INSTALLMAN) -m 644 rrsync.1 $(DESTDIR)$(mandir)/man1; fi; \\\n\tfi\n\ninstall-ssl-daemon: stunnel-rsyncd.conf\n\t-$(MKDIR_P) $(DESTDIR)/etc/stunnel\n\t$(INSTALLCMD) -m 644 stunnel-rsyncd.conf $(DESTDIR)/etc/stunnel/rsyncd.conf\n\t@if ! ls /etc/rsync-ssl/certs/server.* >/dev/null 2>/dev/null; then \\\n\t    echo \"Note that you'll need to install the certificate used by /etc/stunnel/rsyncd.conf\"; \\\n\tfi\n\ninstall-all: install install-ssl-daemon\n\ninstall-strip:\n\t$(MAKE) INSTALL_STRIP='-s' install\n\nrsync$(EXEEXT): $(OBJS)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)\n\nrrsync: support/rrsync\n\tcp -p $(srcdir)/support/rrsync rrsync\n\n$(OBJS): $(HEADERS)\n$(CHECK_OBJS): $(HEADERS)\ntls.o xattrs.o: lib/sysxattrs.h\nusage.o: version.h latest-year.h help-rsync.h help-rsyncd.h git-version.h default-cvsignore.h\nloadparm.o: default-dont-compress.h daemon-parm.h\n\nflist.o: rounding.h\n\ndefault-cvsignore.h default-dont-compress.h: rsync.1.md define-from-md.awk\n\t$(AWK) -f $(srcdir)/define-from-md.awk -v hfile=$@ $(srcdir)/rsync.1.md\n\nhelp-rsync.h help-rsyncd.h: rsync.1.md help-from-md.awk\n\t$(AWK) -f $(srcdir)/help-from-md.awk -v hfile=$@ $(srcdir)/rsync.1.md\n\ndaemon-parm.h: daemon-parm.txt daemon-parm.awk\n\t$(AWK) -f $(srcdir)/daemon-parm.awk $(srcdir)/daemon-parm.txt\n\nrounding.h: rounding.c rsync.h proto.h\n\t@for r in 0 1 3; do \\\n\t    if $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o rounding -DEXTRA_ROUNDING=$$r -I. $(srcdir)/rounding.c >rounding.out 2>&1; then \\\n\t\techo \"#define EXTRA_ROUNDING $$r\" >rounding.h; \\\n\t\tif test -f \"$$HOME/build_farm/build_test.fns\"; then \\\n\t\t    echo \"EXTRA_ROUNDING is $$r\" >&2; \\\n\t\tfi; \\\n\t\tbreak; \\\n\t    fi; \\\n\tdone\n\t@rm -f rounding\n\t@if test -f rounding.h; then : ; else \\\n\t    cat rounding.out 1>&2; \\\n\t    echo \"Failed to create rounding.h!\" 1>&2; \\\n\t    exit 1; \\\n\tfi\n\t@rm -f rounding.out\n\ngit-version.h: ALWAYS_RUN\n\t$(srcdir)/mkgitver\n\n.PHONY: ALWAYS_RUN\nALWAYS_RUN:\n\nsimd-checksum-x86_64.o: simd-checksum-x86_64.cpp\n\t@$(srcdir)/cmd-or-msg disable-roll-simd $(CXX) -I. $(CXXFLAGS) $(CPPFLAGS) -c -o $@ $(srcdir)/simd-checksum-x86_64.cpp\n\nsimd-checksum-avx2.o: simd-checksum-avx2.S\n\t@$(srcdir)/cmd-or-msg disable-roll-asm $(CC) $(CFLAGS) -I. @NOEXECSTACK@ -c -o $@ $(srcdir)/simd-checksum-avx2.S\n\nlib/md5-asm-x86_64.o: lib/md5-asm-x86_64.S lib/md-defines.h\n\t@$(srcdir)/cmd-or-msg disable-md5-asm $(CC) -I. @NOEXECSTACK@ -c -o $@ $(srcdir)/lib/md5-asm-x86_64.S\n\ntls$(EXEEXT): $(TLS_OBJ)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)\n\ntestrun$(EXEEXT): testrun.o\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ testrun.o\n\ngetgroups$(EXEEXT): getgroups.o\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)\n\ngetfsdev$(EXEEXT): getfsdev.o\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getfsdev.o $(LIBS)\n\nTRIMSLASH_OBJ = trimslash.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o\ntrimslash$(EXEEXT): $(TRIMSLASH_OBJ)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)\n\nT_UNSAFE_OBJ = t_unsafe.o syscall.o util1.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/wildmatch.o\nt_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)\n\n.PHONY: conf\nconf: configure.sh config.h.in\n\n.PHONY: gen\ngen: conf proto.h man git-version.h\n\naclocal.m4: $(srcdir)/m4/*.m4\n\taclocal -I $(srcdir)/m4\n\nconfigure.sh config.h.in: configure.ac aclocal.m4\n\t@if test -f configure.sh; then cp -p configure.sh configure.sh.old; else touch configure.sh.old; fi\n\t@if test -f config.h.in; then cp -p config.h.in config.h.in.old; else touch config.h.in.old; fi\n\tautoconf -o configure.sh\n\tautoheader && touch config.h.in\n\t@if diff configure.sh configure.sh.old >/dev/null 2>&1; then \\\n\t    echo \"configure.sh is unchanged.\"; \\\n\t    rm configure.sh.old; \\\n\telse \\\n\t    echo \"configure.sh has CHANGED.\"; \\\n\tfi\n\t@if diff config.h.in config.h.in.old >/dev/null 2>&1; then \\\n\t    echo \"config.h.in is unchanged.\"; \\\n\t    rm config.h.in.old; \\\n\telse \\\n\t    echo \"config.h.in has CHANGED.\"; \\\n\tfi\n\t@if test -f configure.sh.old || test -f config.h.in.old; then \\\n\t    if test \"$(MAKECMDGOALS)\" = reconfigure; then \\\n\t\techo 'Continuing with \"make reconfigure\".'; \\\n\t    else \\\n\t\techo 'You may need to run:'; \\\n\t\techo '  make reconfigure'; \\\n\t\texit 1; \\\n\t    fi \\\n\tfi\n\n.PHONY: reconfigure\nreconfigure: configure.sh\n\t./config.status --recheck\n\t./config.status\n\n.PHONY: restatus\nrestatus:\n\t./config.status\n\nMakefile: Makefile.in config.status configure.sh config.h.in\n\t@if test -f Makefile; then cp -p Makefile Makefile.old; else touch Makefile.old; fi\n\t@./config.status\n\t@if diff Makefile Makefile.old >/dev/null 2>&1; then \\\n\t    echo \"Makefile is unchanged.\"; \\\n\t    rm Makefile.old; \\\n\telse \\\n\t    if test \"$(MAKECMDGOALS)\" = reconfigure; then \\\n\t\techo 'Continuing with \"make reconfigure\".'; \\\n\t    else \\\n\t\techo \"Makefile updated -- rerun your make command.\"; \\\n\t\texit 1; \\\n\t    fi \\\n\tfi\n\nstunnel-rsyncd.conf: $(srcdir)/stunnel-rsyncd.conf.in Makefile\n\tsed 's;\\@bindir\\@;$(bindir);g' <$(srcdir)/stunnel-rsyncd.conf.in >stunnel-rsyncd.conf\n\n.PHONY: proto\nproto: proto.h-tstamp\n\nproto.h: proto.h-tstamp\n\t@if test -f proto.h; then :; else cp -p $(srcdir)/proto.h .; fi\n\nproto.h-tstamp: $(srcdir)/*.c $(srcdir)/lib/compat.c daemon-parm.h\n\t$(AWK) -f $(srcdir)/mkproto.awk $(srcdir)/*.c $(srcdir)/lib/compat.c daemon-parm.h\n\n.PHONY: man\nman: rsync.1 rsync-ssl.1 rsyncd.conf.5 @MAKE_RRSYNC_1@\n\nrsync.1: rsync.1.md md-convert version.h Makefile\n\t@$(srcdir)/maybe-make-man rsync.1.md\n\nrsync-ssl.1: rsync-ssl.1.md md-convert version.h Makefile\n\t@$(srcdir)/maybe-make-man rsync-ssl.1.md\n\nrsyncd.conf.5: rsyncd.conf.5.md md-convert version.h Makefile\n\t@$(srcdir)/maybe-make-man rsyncd.conf.5.md\n\nrrsync.1: support/rrsync.1.md md-convert Makefile\n\t@$(srcdir)/maybe-make-man support/rrsync.1.md\n\n.PHONY: clean\nclean: cleantests\n\trm -f *~ $(OBJS) $(CHECK_PROGS) $(CHECK_OBJS) $(CHECK_SYMLINKS) @MAKE_RRSYNC@ \\\n\t\tgit-version.h rounding rounding.h *.old rsync*.1 rsync*.5 @MAKE_RRSYNC_1@ \\\n\t\t*.html daemon-parm.h help-*.h default-*.h proto.h proto.h-tstamp\n\n.PHONY: cleantests\ncleantests:\n\trm -rf ./testtmp*\n\n# We try to delete built files from both the source and build\n# directories, just in case somebody previously configured things in\n# the source directory.\n.PHONY: distclean\ndistclean: clean\n\tfor dir in $(srcdir) . ; do \\\n\t    (cd \"$$dir\" && rm -rf Makefile config.h config.status stunnel-rsyncd.conf \\\n\t     lib/dummy popt/dummy zlib/dummy config.cache config.log shconfig \\\n\t     $(GENFILES) autom4te.cache) ; \\\n\tdone\n\n# this target is really just for my use. It only works on a limited\n# range of machines and is used to produce a list of potentially\n# dead (ie. unused) functions in the code. (tridge)\n.PHONY: finddead\nfinddead:\n\tnm *.o */*.o |grep 'U ' | awk '{print $$2}' | sort -u > nmused.txt\n\tnm *.o */*.o |grep 'T ' | awk '{print $$3}' | sort -u > nmfns.txt\n\tcomm -13 nmused.txt nmfns.txt\n\t@rm nmused.txt nmfns.txt\n\n# 'check' is the GNU name, 'test' is the name for everybody else :-)\n.PHONY: test\ntest: check\n\n# There seems to be no standard way to specify some variables as\n# exported from a Makefile apart from listing them like this.\n\n# This depends on building rsync; if we need any helper programs it\n# should depend on them too.\n\n# We try to run the scripts with POSIX mode on, in the hope that will\n# catch Bash-isms earlier even if we're running on GNU.  Of course, we\n# might lose in the future where POSIX diverges from old sh.\n\n.PHONY: check\ncheck: all $(CHECK_PROGS) $(CHECK_SYMLINKS)\n\trsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh\n\n.PHONY: check29\ncheck29: all $(CHECK_PROGS) $(CHECK_SYMLINKS)\n\trsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh --protocol=29\n\n.PHONY: check30\ncheck30: all $(CHECK_PROGS) $(CHECK_SYMLINKS)\n\trsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh --protocol=30\n\nwildtest.o: wildtest.c t_stub.o lib/wildmatch.c rsync.h config.h\nwildtest$(EXEEXT): wildtest.o lib/compat.o lib/snprintf.o @BUILD_POPT@\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o lib/compat.o lib/snprintf.o @BUILD_POPT@ $(LIBS)\n\ntestsuite/chown-fake.test:\n\tln -s chown.test $(srcdir)/testsuite/chown-fake.test\n\ntestsuite/devices-fake.test:\n\tln -s devices.test $(srcdir)/testsuite/devices-fake.test\n\ntestsuite/xattrs-hlink.test:\n\tln -s xattrs.test $(srcdir)/testsuite/xattrs-hlink.test\n\n# This does *not* depend on building or installing: you can use it to\n# check a version installed from a binary or some other source tree,\n# if you want.\n\n.PHONY: installcheck\ninstallcheck: $(CHECK_PROGS) $(CHECK_SYMLINKS)\n\tPOSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin=\"$(bindir)/rsync$(EXEEXT)\" srcdir=\"$(srcdir)\" $(srcdir)/runtests.sh\n\n# TODO: Add 'dist' target; need to know which files will be included\n\n# Run the SPLINT (Secure Programming Lint) tool.  <www.splint.org>\n.PHONY: splint\nsplint:\n\tsplint +unixlib +gnuextensions -weak rsync.c\n\n.PHONY: doxygen\ndoxygen:\n\tcd $(srcdir) && rm dox/html/* && doxygen\n\n# for maintainers only\n.PHONY: doxygen-upload\ndoxygen-upload:\n\trsync -avzv $(srcdir)/dox/html/ --delete \\\n\t$${RSYNC_SAMBA_HOST-samba.org}:/home/httpd/html/rsync/doxygen/head/\n"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 206.501953125,
          "content": "# NEWS for rsync 3.3.1 (UNRELEASED)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n- Fixed a buffer overflow when the sum2 digest algorithm is SHA1.\n\n### BUG FIXES:\n\n- Fixed the included popt to avoid a memory error on modern gcc versions.\n\n- Fixed an incorrect extern variable's type that caused an ACL issue on macOS.\n\n### INTERNAL:\n\n- Updated included popt to version 1.19.\n\n### DEVELOPER RELATED:\n\n- Various improvements to the release scripts and git setup.\n\n- Improved packaging/var-checker to identify variable type issues.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.3.0 (6 Apr 2024)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n- Fixed a bug with `--sparse --inplace` where a trailing gap in the source\n  file would not clear out the trailing data in the destination file.\n\n- Fixed an buffer overflow in the checksum2 code if SHA1 is being used for\n  the checksum2 algorithm.\n\n- Fixed an issue when rsync is compiled using `_FORTIFY_SOURCE` so that the\n  extra tests don't complain about a strlcpy() limit value (which was too\n  large, even though it wasn't possible for the larger value to cause an\n  overflow).\n\n- Add a backtick to the list of characters that the filename quoting needs to\n  escape using backslashes.\n\n- Fixed a string-comparison issue in the internal handling of `--progress` (a\n  locale such as tr_TR.utf-8 needed the internal triggering of `--info` options\n  to use upper-case flag names to ensure that they match).\n\n- Make sure that a local transfer marks the sender side as trusted.\n\n- Change the argv handling to work with a newer popt library -- one that likes\n  to free more data than it used to.\n\n- Rsync now calls `OpenSSL_add_all_algorithms()` when compiled against an older\n  openssl library.\n\n- Fixed a problem in the daemon auth for older protocols (29 and before) if the\n  openssl library is being used to compute MD4 checksums.\n\n- Fixed `rsync -VV` on Cygwin -- it needed a flush of stdout.\n\n- Fixed an old stats bug that counted devices as symlinks.\n\n### ENHANCEMENTS:\n\n- Enhanced rrsync with the `-no-overwrite` option that allows you to ensure\n  that existing files on your restricted but writable directory can't be\n  modified.\n\n- Enhanced the manpages to mark links with .UR & .UE. If your nroff doesn't\n  support these idioms, touch the file `.md2man-force` in the source directory\n  so that `md-convert` gets called with the `--force-link-text` option, and\n  that should ensure that your manpages are still readable even with the\n  ignored markup.\n\n- Some manpage improvements on the handling of [global] modules.\n\n- Changed the mapfrom & mapto perl scripts (in the support dir) into a single\n  python script named idmap.  Converted a couple more perl scripts into python.\n\n- Changed the mnt-excl perl script (in the support dir) into a python script.\n\n### DEVELOPER RELATED:\n\n - Updated config.guess (timestamp 2023-01-01) and config.sub (timestamp\n   2023-01-21).\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.7 (20 Oct 2022)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n- Fixed the client-side validating of the remote sender's filtering behavior.\n\n- More fixes for the \"unrequested file-list name\" name, including a copy of\n  \"/\" with `--relative` enabled and a copy with a lot of related paths with\n  `--relative` enabled (often derived from a `--files-from` list).\n\n- When rsync gets an unpack error on an ACL, mention the filename.\n\n- Avoid over-setting sanitize_paths when a daemon is serving \"/\" (even if\n  \"use chroot\" is false).\n\n### ENHANCEMENTS:\n\n- Added negotiated daemon-auth support that allows a stronger checksum digest\n  to be used to validate a user's login to the daemon.  Added SHA512, SHA256,\n  and SHA1 digests to MD5 & MD4.  These new digests are at the highest priority\n  in the new daemon-auth negotiation list.\n\n- Added support for the SHA1 digest in file checksums.  While this tends to be\n  overkill, it is available if someone really needs it.  This overly-long\n  checksum is at the lowest priority in the normal checksum negotiation list.\n  See [`--checksum-choice`](rsync.1#opt) (`--cc`) and the `RSYNC_CHECKSUM_LIST`\n  environment var for how to customize this.\n\n- Improved the xattr hash table to use a 64-bit key without slowing down the\n  key's computation.  This should make extra sure that a hash collision doesn't\n  happen.\n\n- If the `--version` option is repeated (e.g. `-VV`) then the information is\n  output in a (still readable) JSON format.  Client side only.\n\n- The script `support/json-rsync-version` is available to get the JSON style\n  version output from any rsync.  The script accepts either text on stdin\n  **or** an arg that specifies an rsync executable to run with a doubled\n  `--version` option.  If the text we get isn't already in JSON format, it is\n  converted. Newer rsync versions will provide more complete json info than\n  older rsync versions. Various tweaks are made to keep the flag names\n  consistent across versions.\n\n- The [`use chroot`](rsyncd.conf.5#) daemon parameter now defaults to \"unset\"\n  so that rsync can use chroot when it works and a sanitized copy when chroot\n  is not supported (e.g., for a non-root daemon).  Explicitly setting the\n  parameter to true or false (on or off) behaves the same way as before.\n\n- The `--fuzzy` option was optimized a bit to try to cut down on the amount of\n  computations when considering a big pool of files. The simple heuristic from\n  Kenneth Finnegan resulted in about a 2x speedup.\n\n- If rsync is forced to use protocol 29 or before (perhaps due to talking to an\n  rsync before 3.0.0), the modify time of a file is limited to 4-bytes.  Rsync\n  now interprets this value as an unsigned integer so that a current year past\n  2038 can continue to be represented. This does mean that years prior to 1970\n  cannot be represented in an older protocol, but this trade-off seems like the\n  right choice given that (1) 2038 is very rapidly approaching, and (2) newer\n  protocols support a much wider range of old and new dates.\n\n- The rsync client now treats an empty destination arg as an error, just like\n  it does for an empty source arg. This doesn't affect a `host:` arg (which is\n  treated the same as `host:.`) since the arg is not completely empty.  The use\n  of [`--old-args`](rsync.1#opt) (including via `RSYNC_OLD_ARGS`) allows the\n  prior behavior of treating an empty destination arg as a \".\".\n\n### PACKAGING RELATED:\n\n- The checksum code now uses openssl's EVP methods, which gets rid of various\n  deprecation warnings and makes it easy to support more digest methods.  On\n  newer systems, the MD4 digest is marked as legacy in the openssl code, which\n  makes openssl refuse to support it via EVP.  You can choose to ignore this\n  and allow rsync's MD4 code to be used for older rsync connections (when\n  talking to an rsync prior to 3.0.0) or you can choose to configure rsync to\n  tell openssl to enable legacy algorithms (see below).\n\n- A simple openssl config file is supplied that can be installed for rsync to\n  use.  If you install packaging/openssl-rsync.cnf to a public spot (such as\n  `/etc/ssl/openssl-rsync.cnf`) and then run configure with the option\n  `--with-openssl-conf=/path/name.cnf`, this will cause rsync to export the\n  configured path in the OPENSSL_CONF environment variable (when the variable\n  is not already set).  This will enable openssl's MD4 code for rsync to use.\n\n- The packager may wish to include an explicit \"use chroot = true\" in the top\n  section of their supplied /etc/rsyncd.conf file if the daemon is being\n  installed to run as the root user (though rsync should behave the same even\n  with the value unset, a little extra paranoia doesn't hurt).\n\n- I've noticed that some packagers haven't installed support/nameconvert for\n  users to use in their chrooted rsync configs.  Even if it is not installed\n  as an executable script (to avoid a python3 dependency) it would be good to\n  install it with the other rsync-related support scripts.\n\n- It would be good to add support/json-rsync-version to the list of installed\n  support scripts.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.6 (9 Sep 2022)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n- More path-cleaning improvements in the file-list validation code to avoid\n  rejecting of valid args.\n\n- A file-list validation fix for a [`--files-from`](rsync.1#opt) file that ends\n  without a line-terminating character.\n\n- Added a safety check that prevents the sender from removing destination files\n  when a local copy using [`--remove-source-files`](rsync.1#opt) has some files\n  that are shared between the sending & receiving hierarchies, including the\n  case where the source dir & destination dir are identical.\n\n- Fixed a bug in the internal MD4 checksum code that could cause the digest\n  to be sporadically incorrect (the openssl version was/is fine).\n\n- A minor tweak to rrsync added \"copy-devices\" to the list of known args, but\n  left it disabled by default.\n\n### ENHANCEMENTS:\n\n- Rename `--protect-args` to [`--secluded-args`](rsync.1#opt) to make it\n  clearer how it differs from the default backslash-escaped arg-protecting\n  behavior of rsync.  The old option names are still accepted.  The\n  environment-variable override did not change its name.\n\n### PACKAGING RELATED:\n\n- The configure option `--with-protected-args` was renamed to\n  `--with-secluded-args`.  This option makes `--secluded-args` the default\n  rsync behavior instead of using backslash escaping for protecting args.\n\n- The mkgitver script now makes sure that a `.git` dir/file is in the top-level\n  source dir before calling `git describe`. It also runs a basic check on the\n  version value. This should avoid using an unrelated git description for\n  rsync's version.\n\n### DEVELOPER RELATED:\n\n- The configure script no longer sets the -pedantic-errors CFLAG (which it\n  used to try to do only for gcc).\n\n- The name_num_obj struct was modified to allow its dynamic name_num_item list\n  to be initialized in a better way.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.5 (14 Aug 2022)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n- Added some file-list safety checking that helps to ensure that a rogue\n  sending rsync can't add unrequested top-level names and/or include recursive\n  names that should have been excluded by the sender.  These extra safety\n  checks only require the receiver rsync to be updated.  When dealing with an\n  untrusted sending host, it is safest to copy into a dedicated destination\n  directory for the remote content (i.e. don't copy into a destination\n  directory that contains files that aren't from the remote host unless you\n  trust the remote host). Fixes CVE-2022-29154.\n\n - A fix for CVE-2022-37434 in the bundled zlib (buffer overflow issue).\n\n### BUG FIXES:\n\n- Fixed the handling of filenames specified with backslash-quoted wildcards\n  when the default remote-arg-escaping is enabled.\n\n- Fixed the configure check for signed char that was causing a host that\n  defaults to unsigned characters to generate bogus rolling checksums. This\n  made rsync send mostly literal data for a copy instead of finding matching\n  data in the receiver's basis file (for a file that contains high-bit\n  characters).\n\n- Lots of manpage improvements, including an attempt to better describe how\n  include/exclude filters work.\n\n- If rsync is compiled with an xxhash 0.8 library and then moved to a system\n  with a dynamically linked xxhash 0.7 library, we now detect this and disable\n  the XX3 hashes (since these routines didn't stabilize until 0.8).\n\n### ENHANCEMENTS:\n\n- The [`--trust-sender`](rsync.1#opt) option was added as a way to bypass the\n  extra file-list safety checking (should that be required).\n\n### PACKAGING RELATED:\n\n- A note to those wanting to patch older rsync versions: the changes in this\n  release requires the quoted argument change from 3.2.4. Then, you'll want\n  every single code change from 3.2.5 since there is no fluff in this release.\n\n- The build date that goes into the manpages is now based on the developer's\n  release date, not on the build's local-timezone interpretation of the date.\n\n### DEVELOPER RELATED:\n\n- Configure now defaults GETGROUPS_T to gid_t when cross compiling.\n\n- Configure now looks for the bsd/string.h include file in order to fix the\n  build on a host that has strlcpy() in the main libc but not defined in the\n  main string.h file.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.4 (15 Apr 2022)\n\n## Changes in this version:\n\n### BEHAVIOR CHANGES:\n\n - A new form of arg protection was added that works similarly to the older\n   `--protect-args` ([`-s`](rsync.1#opt)) option but in a way that avoids\n   breaking things like rrsync (the restricted rsync script): rsync now uses\n   backslash escaping for sending \"shell-active\" characters to the remote shell\n   (such as `$(){}<>#&` and others). This includes spaces, so fetching a remote\n   file via a quoted filename value now works by default without any extra\n   quoting:\n\n   ```shell\n       rsync -aiv host:'a simple file.pdf' .\n   ```\n\n   Wildcards are not escaped in filename args, but they are escaped in options\n   like the [`--suffix`](rsync.1#opt) and [`--usermap`](rsync.1#opt) values.\n\n   If a script depends on the old arg behavior (perhaps because it quotes or\n   protects the args already, or perhaps because it expects arg splitting),\n   there are two easy ways to get things going with a modern rsync: either\n   `export RSYNC_OLD_ARGS=1` in the script's environment (perhaps in the script\n   itself) or add the option [`--old-args`](rsync.1#opt) to the rsync commands\n   that are run.  See also the [ADVANCED USAGE](rsync.1#) section of rsync's\n   manpage for how to use a more modern arg style.\n\n - A long-standing bug was preventing rsync from figuring out the current\n   locale's decimal point character, which made rsync always output numbers\n   using the \"C\" locale.  Since this is now fixed in 3.2.4, a script that\n   parses rsync's decimal numbers (e.g. from the verbose footer) may want to\n   setup the environment in a way that the output continues to be in the C\n   locale.  For instance, one of the following should work fine:\n\n   ```shell\n       export LC_ALL=C.UTF-8\n   ```\n\n   or if iconv translations are needed:\n\n   ```shell\n       if [ \"${LC_ALL:-}\" ]; then\n           export LANG=\"$LC_ALL\"\n           export LC_CTYPE=\"$LC_ALL\"\n           unset LC_ALL\n       fi\n       export LC_NUMERIC=C.UTF-8\n   ```\n\n### SECURITY FIXES:\n\n - A fix for CVE-2018-25032 in the bundled zlib (memory corruption issue).\n\n### BUG FIXES:\n\n - Fixed a bug with [`--inplace`](rsync.1#opt) + [`--sparse`](rsync.1#opt) (and\n   a lack of [`--whole-file`](rsync.1#opt)) where the destination file could\n   get reconstructed with bogus data.  Since the bug can also be avoided by\n   using (the seemingly redundant) [`--no-W`](rsync.1#opt) on the receiving\n   side, the latest rsync will now send `--no-W` to a remote receiver when this\n   option combination occurs.  If your client rsync is not new enough to do\n   this for you (or if you're just paranoid), you can manually specify `--no-W\n   -M--no-W` (when not using [`--whole-file`](rsync.1#opt)) to make sure the\n   bug is avoided.\n\n - Fixed a bug with [`--mkpath`](rsync.1#opt) if a single-file copy specifies\n   an existing destination dir with a non-existing destination filename.\n\n - Fixed `--update -vv` to output \"is uptodate\" instead of \"is newer\" messages\n   for files that are being skipped due to an identical modify time.  (This was\n   a new output quirk in 3.2.3.)\n\n - When doing an append transfer, the sending side's file must not get shorter\n   or it is skipped. Fixes a crash that could occur when the size changes to 0\n   in the middle of the send negotiations.\n\n - When dealing with special files (see [`--specials`](rsync.1#opt)) in an\n   alt-dest hierarchy, rsync now checks the non-permission mode bits to ensure\n   that the 2 special files are really the same before hard-linking them\n   together.\n\n - Fixed a bug where [`--delay-updates`](rsync.1#opt) with stale partial data\n   could cause a file to fail to update.\n\n - Fixed a few places that would output an INFO message with\n   [`--info=NAME`](rsync.1#opt) that should only have been output given\n   [`--verbose`](rsync.1#opt) or [`--itemize-changes`](rsync.1#opt).\n\n - Avoid a weird failure if you run a local copy with a (useless)\n   [`--rsh`](rsync.1#opt) option that contains a `V` in the command.\n\n - Fixed a long-standing compression bug where the compression level of the\n   first file transferred affected the level for all future files.  Also, the\n   per-file compression skipping has apparently never worked, so it is now\n   documented as being ineffective.\n\n - Fixed a truncate error when a `--write-devices` copy wrote a file onto a\n   device that was shorter than the device.\n\n - Made `--write-devices` support both `--checksum` and `--no-whole-file` when\n   copying to a device.\n\n - Improved how the [`--stop-at`](rsync.1#opt), [`--stop-after`](rsync.1#opt),\n   and (the deprecated) [`--time-limit`](rsync.1#opt) options check to see if\n   the allowed time is over, which should make rsync exit more consistently.\n\n - Tweak --progress to display \"`??:??:??`\" when the time-remaining value is so\n   large as to be meaningless.\n\n - Silence some chmod warnings about symlinks when it looks like we have a\n   function to set their permissions but they can't really be set.\n\n - Fixed a potential issue in git-set-file-times when handling commits with\n   high-bit characters in the description & when handling a description that\n   might mimic the git raw-commit deliniators.  (See the support dir.)\n\n - The bundled systemd/rsync.service file now includes `Restart=on-failure`.\n\n### ENHANCEMENTS:\n\n - Use openssl's `-verify_hostname` option in the rsync-ssl script.\n\n - Added extra info to the \"FILENAME exists\" output of\n   [`--ignore-existing`](rsync.1#opt) when [`--info=skip2`](rsync.1#opt) is\n   used.  The skip message becomes \"FILENAME exists (INFO)\" where the INFO is\n   one of \"type change\", \"sum change\" (requires [`--checksum`](rsync.1#opt)),\n   \"file change\" (based on the quick check), \"attr change\", or \"uptodate\".\n   Prior versions only supported `--info=skip1`.\n\n - Added the [`--fsync`](rsync.1#opt) option (promoted from the patches repo).\n\n - Added the [`--copy-devices`](rsync.1#opt) option.  Compared to the\n   historical version from the rsync-patches repo, this version: properly\n   handles `--checksum`; fixes a truncation bug when doing an `--inplace` copy\n   onto a longer file; fixes several bugs in the `--itemize` output; and only\n   the sending side needs the enhanced rsync for the copy to work.\n\n - Reduced memory usage for an incremental transfer that has a bunch of small\n   directories.\n\n - The rsync daemon can now handle a client address with an implied \"%scope\"\n   suffix.\n\n - Added support for [`--atimes`](rsync.1#opt) on macOS and fixed a bug where\n   it wouldn't work without [`--times`](rsync.1#opt).\n\n - Rsync can now update the xattrs on a read-only file when your user can\n   temporarily add user-write permission to the file. (It always worked for a\n   root transfer.)\n\n - Rsync can now work around an [`--inplace`](rsync.1#opt) update of a file\n   that is being refused due to the Linux fs.protected_regular sysctl setting.\n\n - When [`--chown`](rsync.1#opt), [`--usermap`](rsync.1#opt), or\n   [`--groupmap`](rsync.1#opt) is specified, rsync now makes sure that the\n   appropriate [`--owner`](rsync.1#opt) and/or [`--group`](rsync.1#opt) options\n   are enabled.\n\n - Added the [`--info=NONREG`](rsync.1#opt) setting to control if rsync should\n   warn about non-regular files in the transfer.  This is enabled by default\n   (keeping the behavior the same as before), so specifying `--info=nonreg0`\n   can be used to turn the warnings off.\n\n - An optional asm optimization for the rolling checksum from Shark64. Enable\n   it with `./configure --enable-roll-asm`.\n\n - Using `--debug=FILTER` now outputs a caution message if a filter rule\n   has trailing whitespace.\n\n - Transformed rrsync into a python script with improvements:\n   - Security has been beefed up.\n   - The known rsync options were updated to include recent additions.\n   - Make rrsync reject [`--copy-links`](rsync.1#opt) (`-L`),\n     [`--copy-dirlinks`](rsync.1#opt) (`-k`), &\n     [`--keep-dirlinks`](rsync.1#opt) (`-K`) by default to make it harder to\n     exploit any out-of-subdir symlinks.\n   - A new rrsync option of [`-munge`](rrsync.1#opt) tells rrsync to always\n     enable rsync's [`--munge-links`](rsync.1#opt) option on the server side.\n   - A new rrsync option of [`-no-lock`](rrsync.1#opt) disables a new\n     single-use locking idiom that is the default when [`-ro`](rrsync.1#opt) is\n     not used (useful with [`-munge`](rrsync.1#opt)).\n   - A new rrsync option of [`-no-del`](rrsync.1#opt) disables all `--remove*`\n     and `--delete*` rsync options on the server side.\n   - The log format has been tweaked slightly to add seconds to the timestamp\n     and to output the command executed as a tuple (making the args clearer).\n   - An rrsync.1 manpage was added (in the support dir with rrsync).\n\n - Added options to the lsh script to facilitate rrsync testing. (See the\n   support dir.)\n\n - Transformed the atomic-rsync script into a python script and added the\n   ability to ignore one or more non-zero exit codes.  By default, it now\n   ignores code 24, the file-vanished exit code. (See the support dir.)\n\n - Transformed the munge-symlinks script into python. (See the support dir.)\n\n - Improved the rsync-no-vanished script to not join stdout & stderr together.\n   (See the support dir.)\n\n - Work around a glibc bug where lchmod() breaks in a chroot w/o /proc mounted.\n\n - Try to support a client that sent a remote rsync a wacko stderr file handle\n   (such as an older File::RsyncP perl library used by BackupPC).\n\n - Lots of manpage improvements, including better HTML versions.\n\n### PACKAGING RELATED:\n\n - Give configure the `--with-rrsync` option if you want `make install` to\n   install the (now python3) rrsync script and its new manpage.\n\n - If the rrsync script is installed, its package should be changed to depend\n   on python3 and the (suggested but not mandatory) python3 braceexpand lib.\n\n - When creating a package from a non-release version (w/o a git checkout), the\n   packager can elect to create git-version.h and define RSYNC_GITVER to the\n   string they want `--version` to output.  (The file is still auto-generated\n   using the output of `git describe` when building inside a non-shallow git\n   checkout, though.)\n\n - Renamed configure's `--enable-simd` option to `--enable-roll-simd` and added\n   the option `--enable-roll-asm` to use the new asm version of the code.  Both\n   are x86_64/amd64 only.\n\n - Renamed configure's `--enable-asm` option to `--enable-md5-asm` to avoid\n   confusion with the asm option for the rolling checksum.  It is also honored\n   even when openssl crypto is in use.  This allows: normal MD4 & MD5, normal\n   MD4 + asm MD5, openssl MD4 & MD5, or openssl MD4 + asm MD5 depending on the\n   configure options selected.\n\n - Made SIMD & asm configure checks default to \"no\" on non-Linux hosts due to\n   various reports of problems on NetBSD & macOS hosts.  These were also\n   tweaked to allow enabling the feature on a host_cpu of amd64 (was only\n   allowed on x86_64 before).\n\n - Fixed configure to not fail at the SIMD check when cross-compiling.\n\n - Improved the IPv6 determination in configure.\n\n - Compile the C files with `-pedantic-errors` (when possible) so that we will\n   get warned if a static initialization overflows in the future (among other\n   things).\n\n - When linking with an external zlib, rsync renames its `read_buf()` function\n   to `read_buf_()` to avoid a symbol clash on an unpatched zlib.\n\n - Added a SECURITY.md file.\n\n### DEVELOPER RELATED:\n\n - Made it easier to write rsync tests that diff the output while also checking\n   the status code, and used the idiom to improve the existing tests. (See the\n   `checkdiff` and `checkdiff2` idioms in the `testsuite/*.test` files.\n\n - The packaging scripts & related python lib got some minor enhancements.\n\n### INTERNAL\n\n - Use setenv() instead of putenv() when it is available.\n\n - Improve the logic in compat.c so that we don't need to try to remember to\n   sprinkle `!local_server` exceptions throughout the protocol logic.\n\n - One more C99 Flexible Array improvement (started in the last release) and\n   make use of the C99 `%zd` format string when printing size_t values (when\n   possible).\n\n - Use mallinfo2() instead of mallinfo(), when available.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.3 (6 Aug 2020)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a bug in the xattr code that was freeing the wrong object when trying\n   to cleanup the xattr list.\n\n - Fixed a bug in the xattr code that was not leaving room for the \"rsync.\"\n   prefix in some instances where it needed to be added.\n\n - Restored the ability to use [`--bwlimit=0`](rsync.1#opt) to specify no\n   bandwidth limit.  (It was accidentally broken in 3.2.2.)\n\n - Fixed a bug when combining [`--delete-missing-args`](rsync.1#opt) with\n   [`--no-implied-dirs`](rsync.1#opt) & [`-R`](rsync.1#opt) where rsync might\n   create the destination path of a missing arg.  The code also avoids some\n   superfluous warnings for nested paths of removed args.\n\n - Fixed an issue where hard-linked devices could cause the rdev_major value to\n   get out of sync between the sender and the receiver, which could cause a\n   device to get created with the wrong major value in its major,minor pair.\n\n - Rsync now complains about a missing [`--temp-dir`](rsync.1#opt) before\n   starting any file transfers.\n\n - A completely empty source arg is now a fatal error.  This doesn't change\n   the handling of implied dot-dir args such as \"localhost:\" and such.\n\n### ENHANCEMENTS:\n\n - Allow [`--max-alloc=0`](rsync.1#opt) to specify no limit to the alloc sanity\n   check.\n\n - Allow [`--block-size=SIZE`](rsync.1#opt) to specify the size using units\n   (e.g. \"100K\").\n\n - The name of the id-0 user & group are now sent to the receiver along with\n   the other user/group names in the transfer (instead of assuming that both\n   sides have the same id-0 names).\n\n - Added the [`--stop-after`](rsync.1#opt) and [`--stop-at`](rsync.1#opt)\n   options (with a [`--time-limit`](rsync.1#opt) alias for `--stop-after`).\n   This is an enhanced version of the time-limit patch from the patches repo.\n\n - Added the [`name converter`](rsyncd.conf.5#opt) daemon parameter to make it\n   easier to convert user & group names inside a chrooted daemon module.  This\n   is based on the nameconverter patch with some improvements, including a\n   tweak to the request protocol (so if you used this patch in the past, be\n   sure to update your converter script to use newlines instead of null chars).\n\n - Added [`--crtimes`](rsync.1#opt) (`-N`) option for preserving the file's\n   create time (I believe that this is macOS only at the moment).\n\n - Added [`--mkpath`](rsync.1#opt) option to tell rsync that it should create a\n   non-existing path component of the destination arg.\n\n - Added [`--stderr=errors|all|client`](rsync.1#opt) to replace the\n   `--msgs2stderr` and `--no-msgs2stderr` options (which are still accepted).\n   The default use of stderr was changed to be `--stderr=errors` where all the\n   processes that have stderr available output directly to stderr, which should\n   help error messages get to the user more quickly, especially when doing a\n   push (which includes local copying).  This also allows rsync to exit quickly\n   when a receiver failure occurs, since rsync doesn't need to try to keep the\n   connection alive long enough for the fatal error to go from the receiver to\n   the generator to the sender.  The old default can be requested via\n   `--stderr=client`.  Also changed is that a non-default stderr mode is\n   conveyed to the remote rsync (using the older option names) instead of\n   requiring the user to use [`--remote-option`](rsync.1#opt) (`-M`) to tell\n   the remote rsync what to do.\n\n - Added the ability to specify \"@netgroup\" names to the [`hosts\n   allow`](rsyncd.conf.5#opt) and [`hosts deny`](rsyncd.conf.5#opt) daemon\n   parameters.  This is a finalized version of the netgroup-auth patch from the\n   patches repo.\n\n - Rsync can now hard-link symlinks on FreeBSD due to it making use of the\n   linkat() function when it is available.\n\n - Output file+line info on out-of-memory & overflow errors while also avoiding\n   the output of alternate build-dir path info that is not useful to the user.\n\n - Change configure to know that Cygwin supports Linux xattrs.\n\n - Improved the testsuite on FreeBSD & Cygwin.\n\n - Added some compatibility code for HPE NonStop platforms.\n\n - Improved the INSTALL.md info.\n\n - Added a few more suffixes to the default skip-compress list.\n\n - Improved configure's error handling to notify about several issues at once\n   instead of one by one (for the newest optional features).\n\n### INTERNAL:\n\n - Use a simpler overflow check idiom in a few spots.\n\n - Use a C99 Flexible Array for a trailing variable-size filename in a struct\n   (with a fallback to the old 1-char string kluge for older compilers).\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.2 (4 Jul 2020)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Avoid a crash when a daemon module enables `transfer logging` without\n   setting a `log format` value.\n\n - Fixed installing rsync-ssl script from an alternate build dir.\n\n - Fixed the updating of configure.sh from an alternate build dir.\n\n - Apple requires the asm function name to begin with an underscore.\n\n - Avoid a test failure in the daemon test when `--atimes` is disabled.\n\n### ENHANCEMENTS:\n\n - Allow the server side to restrict checksum & compression choices via the\n   same environment variables the client uses.  The env vars can be divided\n   into \"client list & server list\" by the \"`&`\" char or the same list can\n   apply to both.\n\n - Simplify how the negotiation environment variables apply when interacting\n   with an older rsync and also when a list contains only invalid names.\n\n - Do not allow a negotiated checksum or compression choice of \"none\" unless\n   the user authorized it via an environment variable or command-line option.\n\n - Added the `--max-alloc=SIZE` option to be able to override the memory\n   allocator's sanity-check limit.  It defaults to 1G (as before) but the error\n   message when exceeding it specifically mentions the new option so that you\n   can differentiate an out-of-memory error from a failure of this limit.  It\n   also allows you to specify the value via the RSYNC_MAX_ALLOC environment\n   variable.\n\n - Add the \"open atime\" daemon parameter to allow a daemon to always enable or\n   disable the use of O_NOATIME (the default is to let the user control it).\n\n - The default systemd config was changed to remove the `ProtectHome=on`\n   setting since rsync is often used to serve files in /home and /root and this\n   seemed a bit too strict.  Feel free to use `systemctl edit rsync` to add\n   that restriction (or maybe `ProtectHome=read-only`), if you like.  See the\n   3.2.0 NEWS for the other restrictions that were added compared to 3.1.3.\n\n - The memory allocation functions now automatically check for a failure and\n   die when out of memory.  This eliminated some caller-side check-and-die\n   code and added some missing sanity-checking of allocations.\n\n - Put optimizations into their own list in the `--version` output.\n\n - Improved the manpage a bit more.\n\n### PACKAGING RELATED:\n\n - Prepared the checksum code for an upcoming xxHash release that provides new\n   XXH3 (64-bit) & XXH128 (128-bit) checksum routines.  These will not be\n   compiled into rsync until the xxhash v0.8.0 include files are installed on\n   the build host, and that release is a few weeks away at the time this was\n   written.  So, if it's now the future and you have packaged and installed\n   xxhash-0.8.0-devel, a fresh rebuild of rsync 3.2.2 will give you the new\n   checksum routines.  Just make sure that the new rsync package depends on\n   xxhash >= 0.8.0.\n\n### DEVELOPER RELATED:\n\n - Moved the version number out of configure.ac into its own version.h file so\n   that we don't need to reconfigure just because the version number changes.\n\n - Moved the daemon parameter list into daemon-parm.txt so that an awk script\n   can create the interrelated structs and accessors that loadparm.c needs.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.1 (22 Jun 2020)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a potential build issue with the MD5 assembly-language code by\n   removing some non-portable directives.\n\n - Use the preprocessor with the asm file to ensure that if the code is\n   unneeded, it doesn't get built.\n\n - Avoid the stack getting set to executable when including the asm code.\n\n - Some improvements in the SIMD configure testing to try to avoid build\n   issues, such as avoiding a clang++ core dump when `-g` is combined with\n   `-O2`.  Note that clang++ is quite buggy in this area, and it does still\n   crash for some folks, so just use `--disable-simd` if you need to avoid\n   their buggy compiler (since the configure test is apparently not finding\n   all the compilers that will to crash and burn).\n\n - Fixed an issue in the md2man script when building from an alternate dir.\n\n - Disable `--atimes` on macOS (it apparently just ignores the atime change).\n\n### ENHANCEMENTS:\n\n - The use of `--backup-dir=STR` now implies `--backup`.\n\n - Added `--zl=NUM` as a short-hand for `--compress-level=NUM`.\n\n - Added `--early-input=FILE` option that allows the client to send some\n   data to a daemon's (optional) \"early exec\" script on its stdin.\n\n - Mention atimes in the capabilities list that `--version` outputs.\n\n - Mention either \"default protect-args\" or \"optional protect-args\" in the\n   `--version` capabilities depending on how rsync was configured.\n\n - Some info on optimizations is now elided from the `--version` capabilities\n   since they aren't really user-facing capabilities.  You can still see the\n   info (plus the status of a couple extra optimizations) by repeating the\n   `--version` option (e.g. `-VV`).\n\n - Updated various URLs to be https instead of http.\n\n - Some documentation improvements.\n\n### PACKAGING RELATED:\n\n - If you had to use `--disable-simd` for 3.2.0, you might want to try removing\n   that and see if it will succeed or auto-disable.  Some buggy clang++\n   compilers are still not auto disabled, though.\n\n - The MD5 asm code is now under its own configure flag (not shared with the\n   SIMD setting), so if you have any issues compiling it, re-run configure with\n   `--disable-asm`.\n\n - Merged the OLDNEWS.md file into NEWS.md.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.2.0 (19 Jun 2020)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Avoid a potential out-of-bounds read in daemon mode if argc can be made to\n   become 0.\n\n - Fix the default list of skip-compress files for non-daemon transfers.\n\n - Fix xattr filter rules losing an 'x' attribute in a non-local transfer.\n\n - Avoid an error when a check for a potential fuzzy file happens to reference\n   a directory.\n\n - Make the atomic-rsync helper script have a more consistent error-exit.\n\n - Make sure that a signal handler's use of exit_cleanup() calls `_exit()`\n   instead of exit().\n\n - Various zlib fixes, including security fixes for CVE-2016-9843,\n   CVE-2016-9842, CVE-2016-9841, and CVE-2016-9840.\n\n - Fixed an issue with `--remove-source-files` not removing a source symlink\n   when combined with `--copy-links`.\n\n - Fixed a bug where the daemon would fail to write early fatal error messages\n   to the client, such as refused or unknown command-line options.\n\n - Fixed the block-size validation logic when dealing with older protocols.\n\n - Some rrsync fixes and enhancements to handle the latest options.\n\n - Fixed a problem with the `--link-dest`|`--copy-dest` code when `--xattrs`\n   was specified along with multiple alternate-destination directories (it\n   could possibly choose a bad file match while trying to find a better xattr\n   match).\n\n - Fixed a couple bugs in the handling of files with the `--sparse` option.\n\n - Fixed a bug in the writing of the batch.sh file (w/`--write-batch`) when the\n   source & destination args were not last on the command-line.\n\n - Avoid a hang when an overabundance of messages clogs up all the I/O buffers.\n\n - Fixed a mismatch in the RSYNC_PID values put into the environment of\n   `pre-xfer exec` and a `post-xfer exec`.\n\n - Fixed a crash in the `--iconv` code.\n\n - Fixed a rare crash in the popt_unalias() code.\n\n### ENHANCEMENTS:\n\n - The default systemd config was made stricter by default.  For instance,\n   `ProtectHome=on` (which hides content in /root and /home/USER dirs),\n   `ProtectSystem=full` (which makes /usr, /boot, & /etc dirs read-only), and\n   `PrivateDevices=on` (which hides devices).  You can override any of these\n   using the standard `systemctl edit rsync` and add one or more directives\n   under a `[Service]` heading (and restart the rsync service).\n\n - Various checksum enhancements, including the optional use of openssl's MD4 &\n   MD5 checksum algorithms, some x86-64 optimizations for the rolling checksum,\n   some x86-64 optimizations for the (non-openssl) MD5 checksum, the addition\n   of xxHash checksum support, and a negotiation heuristic that ensures that it\n   is easier to add new checksum algorithms in the future.  The environment\n   variable `RSYNC_CHECKSUM_LIST` can be used to customize the preference order\n   of the negotiation, or use `--checksum-choice` (`--cc`) to force a choice.\n\n - Various compression enhancements, including the addition of zstd and lz4\n   compression algorithms and a negotiation heuristic that picks the best\n   compression option supported by both sides.  The environment variable\n   `RSYNC_COMPRESS_LIST` can be used to customize the preference order of the\n   negotiation, or use `--compress-choice` (`--zc`) to force a choice.\n\n - Added a `--debug=NSTR` option that outputs details of the new negotiation\n   strings (for checksums and compression).  The first level just outputs the\n   result of each negotiation on the client, level 2 outputs the values of the\n   strings that were sent to and received from the server, and level 3 outputs\n   all those values on the server side too (when the server was given the debug\n   option).\n\n - The `--debug=OPTS` command-line option is no longer auto-forwarded to the\n   remote rsync which allows for the client and server to have different levels\n   of debug specified. This also allows for newer debug options to be\n   specified, such as using `--debug=NSTR` to see the negotiated hash result,\n   without having the command fail if the server version is too old to handle\n   that debug item. Use `-M--debug=OPTS` to send the options to the remote side.\n\n - Added the `--atimes` option based on the long-standing patch (just with some\n   fixes that the patch has been needing).\n\n - Added `--open-noatime` option to open files using `O_NOATIME`.\n\n - Added the `--write-devices` option based on the long-standing patch.\n\n - Added openssl & preliminary gnutls support to the rsync-ssl script, which is\n   now installed by default.  This was unified with the old stunnel-rsync\n   helper script to simplify packaging.  Note that the script accepts the use\n   of `--type=gnutls` for gnutls testing, but does not look for gnutls-cli on\n   the path yet.  The use of `--type=gnutls` will not work right until\n   gnutls-cli no longer drops data.\n\n - Rsync was enhanced to set the `RSYNC_PORT` environment variable when running\n   a daemon-over-rsh script. Its value is the user-specified port number (set\n   via `--port` or an rsync:// URL) or 0 if the user didn't override the port.\n\n - Added the `proxy protocol` daemon parameter that allows your rsyncd to know\n   the real remote IP when it is setup behind a proxy.\n\n - Added negated matching to the daemon's `refuse options` setting by using\n   match strings that start with a `!` (such as `!compress*`).  This lets you\n   refuse all options except for a particular approved list, for example.  It\n   also lets rsync refuse certain options by default (such as `write-devices`)\n   while allowing the config to override that, as desired.\n\n - Added the `early exec` daemon parameter that runs a script before the\n   transfer parameters are known, allowing some early setup based on module\n   name.\n\n - Added status output in response to a signal (via both SIGINFO & SIGVTALRM).\n\n - Added `--copy-as=USER` option to give some extra security to root-run rsync\n   commands into/from untrusted directories (such as backups and restores).\n\n - When resuming the transfer of a file in the `--partial-dir`, rsync will now\n   update that partial file in-place instead of creating yet another tmp file\n   copy.  This requires both sender & receiver to be at least v3.2.0.\n\n - Added support for `RSYNC_SHELL` & `RSYNC_NO_XFER_EXEC` environment variables\n   that affect the early, pre-xfer, and post-xfer exec rsync daemon parameters.\n\n - Optimize the `--fuzzy --fuzzy` heuristic to avoid the fuzzy directory scan\n   until all other basis-file options are exhausted (such as `--link-dest`).\n\n - Have the daemon log include the normal-exit sent/received stats when the\n   transfer exited with an error when possible (i.e. if it is the sender).\n\n - The daemon now locks its pid file (when configured to use one) so that it\n   will not fail to start when the file exists but no daemon is running.\n\n - Various manpage improvements, including some html representations (that\n   aren't installed by default).\n\n - Made `-V` the short option for `--version` and improved its information.\n\n - Pass the `-4` or `-6` option to the ssh command, making it easier to type\n   than `--rsh='ssh -4'` (or the `-6` equivalent).\n\n - Added example config for rsyncd SSL proxy configs to rsyncd.conf.\n\n - More errors messages now mention if the error is coming from the sender or\n   the receiver.\n\n### PACKAGING RELATED:\n\n - Add installed bash script: /usr/bin/rsync-ssl\n\n - Add installed manpage: /usr/man/man1/rsync-ssl.1\n\n - Tweak auxiliary doc file names, such as: README.md, INSTALL.md, & NEWS.md.\n\n - The rsync-ssl script wants to run openssl or stunnel4, so consider adding a\n   dependency for one of those options (though it's probably fine to just let\n   it complain about being unable to find the program and let the user decide\n   if they want to install one or the other).\n\n - If you packaged rsync + rsync-ssl + rsync-ssl-daemon as separate packages,\n   the rsync-ssl package is now gone (rsync-ssl should be considered to be\n   mainstream now that Samba requires SSL for its rsync daemon).\n\n - Add _build_ dependency for liblz4-dev, libxxhash-dev, libzstd-dev, and\n   libssl-dev.  These development libraries will give rsync extra compression\n   algorithms, extra checksum algorithms, and allow use of openssl's crypto\n   lib for (potentially) faster MD4/MD5 checksums.\n\n - Add _build_ dependency for g++ or clang++ on x86_64 systems to enable the\n   SIMD checksum optimizations.\n\n - Add _build_ dependency for _either_ python3-cmarkcfm or python3-commonmark\n   to allow for patching of manpages or building a git release.  This is not\n   required for a release-tar build, since it comes with pre-built manpages.\n   Note that cmarkcfm is faster than commonmark, but they generate the same\n   data.  The commonmark dependency is easiest to install since it's native\n   python, and can even be installed via `pip3 install --user commonmark` if\n   you want to just install it for the build user.\n\n - Remove yodl _build_ dependency (if it was even listed before).\n\n### DEVELOPER RELATED:\n\n - Silenced some annoying warnings about major() & minor() by improving an\n   autoconf include-file check.\n\n - Converted the manpages from yodl to markdown. They are now processed via a\n   simple python3 script using the cmarkgfm **or** commonmark library.  This\n   should make it easier to package rsync, since yodl is rather obscure.\n\n - Improved some configure checks to work better with strict C99 compilers.\n\n - Some perl building/packaging scripts were recoded into awk and python3.\n\n - Some defines in byteorder.h were changed into static inline functions that\n   will help to ensure that the args don't get evaluated multiple times on\n   \"careful alignment\" hosts.\n\n - Some code typos were fixed (as pointed out by a Fossies run).\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.1.3 (28 Jan 2018)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - Fixed a buffer overrun in the protocol's handling of xattr names and ensure\n   that the received name is null terminated.\n\n - Fix an issue with `--protect-args` where the user could specify the arg in the\n   protected-arg list and short-circuit some of the arg-sanitizing code.\n\n### BUG FIXES:\n\n - Don't output about a new backup dir without appropriate info verbosity.\n\n - Fixed some issues with the sort functions in the rsyncstats script (in the\n   support dir).\n\n - Added a way to specify daemon config lists (e.g. users, groups, etc) that\n   contain spaces (see `auth users` in the latest rsyncd.conf manpage).\n\n - If a backup fails (e.g. full disk) rsync exits with an error.\n\n - Fixed a problem with a doubled `--fuzzy` option combined with `--link-dest`.\n\n - Avoid invalid output in the summary if either the start or end time had an\n   error.\n\n - We don't allow a popt alias to affect the `--daemon` or `--server` options.\n\n - Fix daemon exclude code to disallow attribute changes in addition to\n   disallowing transfers.\n\n - Don't force nanoseconds to match if a non-transferred, non-checksummed file\n   only passed the quick-check w/o comparing nanoseconds.\n\n### ENHANCEMENTS:\n\n - Added the ability for rsync to compare nanosecond times in its file-check\n   comparisons, and added support nanosecond times on Mac OS X.\n\n - Added a short-option (`-@`) for `--modify-window`.\n\n - Added the `--checksum-choice=NAME[,NAME]` option to choose the checksum\n   algorithms.\n\n - Added hashing of xattr names (with using `-X`) to improve the handling of\n   files with large numbers of xattrs.\n\n - Added a way to filter xattr names using include/exclude/filter rules (see\n   the `--xattrs` option in the manpage for details).\n\n - Added `daemon chroot|uid|gid` to the daemon config (in addition to the old\n   chroot|uid|gid settings that affect the daemon's transfer process).\n\n - Added `syslog tag` to the daemon configuration.\n\n - Some manpage improvements.\n\n### DEVELOPER RELATED:\n\n - Tweak the `make` output when yodl isn't around to create the manpages.\n\n - Changed an obsolete autoconf compile macro.\n\n - Support newer yodl versions when converting manpages.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.1.2 (21 Dec 2015)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - Make sure that all transferred files use only path names from inside the\n   transfer. This makes it impossible for a malicious sender to try to make the\n   receiver use an unsafe destination path for a transferred file, such as a\n   just-sent symlink.\n\n### BUG FIXES:\n\n - Change the checksum seed order in the per-block checksums. This prevents\n   someone from trying to create checksum blocks that match in sum but not\n   content.\n\n - Fixed a with the per-dir filter files (using `-FF`) that could trigger an\n   assert failure.\n\n - Only skip `set_modtime()` on a transferred file if the time is exactly\n   right.\n\n - Don't create an empty backup dir for a transferred file that doesn't exist\n   yet.\n\n - Fixed a bug where `--link-dest` and `--xattrs` could cause rsync to exit if\n   a filename had a matching dir of the same name in the alt-dest area.\n\n - Allow more than 32 group IDs per user in the daemon's gid=LIST config.\n\n - Fix the logging of %b & %c via `--log-file` (daemon logging was already\n   correct, as was `--out-format='%b/%c'`).\n\n - Fix erroneous acceptance of `--info=5` & `--debug=5` (an empty flag name is\n   not valid).\n\n### ENHANCEMENTS:\n\n - Added `(DRY RUN)` info to the `--debug=exit` output line.\n\n - Use usleep() for our msleep() function if it is available.\n\n - Added a few extra long-option names to rrsync script, which will make\n   BackupPC happier.\n\n - Made configure choose to use Linux xattrs on NetBSD (rather than not\n   supporting xattrs).\n\n - Added `-wo` (write-only) option to rrsync support script.\n\n - Misc. manpage tweaks.\n\n### DEVELOPER RELATED:\n\n - Fixed a bug with the Makefile's use of `INSTALL_STRIP`.\n\n - Improve a test in the suite that could get an erroneous timestamp error.\n\n - Tweaks for newer versions of git in the packaging tools.\n\n - Improved the m4 generation rules and some autoconf idioms.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.1.1 (22 Jun 2014)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - If the receiver gets bogus filenames from the sender (an unexpected leading\n   slash or a `..` infix dir), exit with an error. This prevents a malicious\n   sender from trying to inject filenames that would affect an area outside the\n   destination directories.\n\n - Fixed a failure to remove the partial-transfer temp file when interrupted\n   (and rsync is not saving the partial files).\n\n - Changed the chown/group/xattr-set order to avoid losing some security-\n   related xattr info (that would get cleared by a chown).\n\n - Fixed a bug in the xattr-finding code that could make a non-root-run\n   receiver not able to find some xattr numbers.\n\n - Fixed a bug in the early daemon protocol where a timeout failed to be\n   honored (e.g. if the remote side fails to send us the initial protocol\n   greeting).\n\n - Fixed unintended inclusion of commas in file numbers in the daemon log.\n\n - We once again send the 'f' sub-flag (of `-e`) to the server side so it knows\n   that we can handle incremental-recursion directory errors properly in older\n   protocols.\n\n - Fixed an issue with too-aggressive keep-alive messages causing a problem for\n   older rsync versions early in the transfer.\n\n - Fixed an incorrect message about backup-directory-creation when using\n   `--dry-run` and the backup dir is not an absolute path.\n\n - Fixed a bug where a failed deletion and/or a failed sender-side removal\n   would not affect the exit code.\n\n - Fixed a bug that caused a failure when combining `--delete-missing-args`\n   with `--xattrs` and/or `--acls`.\n\n - Fixed a strange `dir_depth` assertion error that was caused by empty-dir\n   removals and/or duplicate files in the transfer.\n\n - Fixed a problem with `--info=progress2`'s output stats where rsync would\n   only update the stats at the end of each file's transfer. It now uses the\n   data that is flowing for the current file, making the stats more accurate\n   and less jumpy.\n\n - Fixed an itemize bug that affected the combo of `--link-dest`, `-X`, and\n   `-n`.\n\n - Fixed a problem with delete messages not appearing in the log file when the\n   user didn't use `--verbose`.\n\n - Improve chunked xattr reading for OS X.\n\n - Removed an attempted hard-link xattr optimization that was causing a\n   transfer failure. This removal is flagged in the compatibility code, so if a\n   better fix can be discovered, we have a way to flip it on again.\n\n - Fixed a bug when the receiver is not configured to be able to hard link\n   symlimks/devices/special-file items but the sender sent some of these items\n   flagged as hard-linked.\n\n - We now generate a better error if the buffer overflows in `do_mknod()`.\n\n - Fixed a problem reading more than 16 ACLs on some OSes.\n\n - Fixed the reading of the secrets file to avoid an infinite wait when the\n   username is missing.\n\n - Fixed a parsing problem in the `--usermap`/`--groupmap` options when using\n   MIN-MAX numbers.\n\n - Switched Cygwin back to using socketpair `pipes` to try to speed it up.\n\n - Added knowledge of a few new options to rrsync.\n\n### ENHANCEMENTS:\n\n - Tweaked the temp-file naming when `--temp-dir=DIR` is used: the temp-file\n   names will not get a '.' prepended.\n\n - Added support for a new-compression idiom that does not compress all the\n   matching data in a transfer. This can help rsync to use less cpu when a\n   transfer has a lot of matching data, and also makes rsync compatible with a\n   non-bundled zlib. See the `--new-compress` and `--old-compress` options in\n   the manpage.\n\n - Added the rsync-no-vanished shell script. (See the support dir.)\n\n - Made configure more prominently mention when we failed to find yodl (in case\n   the user wants to be able to generate manpages from `*.yo` files).\n\n - Have manpage mention how a daemon's max-verbosity setting affects info and\n   debug options. Also added more clarification on backslash removals for\n   excludes that contain wildcards.\n\n - Have configure check if for the attr lib (for getxattr) for those systems\n   that need to link against it explicitly.\n\n - Change the early dir-creation logic to only use that idiom in an\n   inc-recursive copy that is preserving directory times. e.g. using\n   `--omit-dir-times` will avoid these early directories being created.\n\n - Fix a bug in `cmp_time()` that would return a wrong result if the 2 times\n   differed by an amount greater than what a `time_t` can hold.\n\n### DEVELOPER RELATED:\n\n - We now include an example systemd file (in packaging/systemd).\n\n - Tweaked configure to make sure that any intended use of the included popt\n   and/or zlib code is put early in the CFLAGS.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.1.0 (28 Sep 2013)\n\n## Changes in this version:\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 31.\n\n### OUTPUT CHANGES:\n\n - Output numbers in 3-digit groups by default (e.g. 1,234,567). See the\n   `--human-readable` option for a way to turn it off. See also the daemon's\n   `log format` parameter and related command-line options (including\n   `--out-format`) for a modifier that can be used to request digit-grouping or\n   human-readable output in log escapes. (Note that log output is unchanged by\n   default.)\n\n - The `--list-only` option is now affected by the `--human-readable` setting.\n   It will display digit groupings by default, and unit suffixes if higher\n   levels of readability are requested. Also, the column width for the size\n   output has increased from 11 to 14 characters when human readability is\n   enabled. Use `--no-h` to get the old-style output and column size.\n\n - The output of the `--progress` option has changed: the string `xfer` was\n   shortened to `xfr`, and the string `to-check` was shortened to `to-chk`,\n   both designed to make room for the (by default) wider display of file size\n   numbers without making the total line-length longer. Also, when incremental\n   recursion is enabled, the string `ir-chk` will be used instead of `to-chk`\n   up until the incremental-recursion scan is done, letting you know that the\n   value to check and the total value will still be increasing as new files are\n   found.\n\n - Enhanced the `--stats` output: 1) to mention how many files were created\n   (protocol >= 28), 2) to mention how many files were deleted (a new line for\n   protocol 31, but only output when `--delete` is in effect), and 3) to follow\n   the file-count, created-count, and deleted-count with a subcount list that\n   shows the counts by type. The wording of the transferred count has also\n   changed so that it is clearer that it is only a count of regular files.\n\n### BUG FIXES:\n\n - Fixed a bug in the iconv code when EINVAL or EILSEQ is returned with a full\n   output buffer.\n\n - Fixed some rare bugs in `--iconv` processing that might cause a multi-byte\n   character to get translated incorrectly.\n\n - Fixed a bogus `vanished file` error if some files were specified with `./`\n   prefixes and others were not.\n\n - Fixed a bug in `--sparse` where an extra gap could get inserted after a\n   partial write.\n\n - Changed the way `--progress` overwrites its prior output in order to make it\n   nearly impossible for the progress to get overwritten by an error.\n\n - Improved the propagation of abnormal-exit error messages. This should help\n   the client side to receive errors from the server when it is exiting\n   abnormally, and should also avoid dying with an `connection unexpectedly\n   closed` exit when the closed connection is really expected.\n\n - The sender now checks each file it plans to remove to ensure that it hasn't\n   changed from the first stat's info. This helps to avoid losing file data\n   when the user is not using the option in a safe manner.\n\n - Fixed a data-duplication bug in the compress option that made compression\n   less efficient. This improves protocol 31 onward, while behaving in a\n   compatible (buggy) manner with older rsync protocols.\n\n - When creating a temp-file, rsync is now a bit smarter about it dot-char\n   choices, which can fix a problem on OS X with names that start with `..`.\n\n - Rsync now sets a cleanup flag for `--inplace` and `--append` transfers that\n   will flush the write buffer if the transfer aborts. This ensures that more\n   received data gets written out to the disk on an aborted transfer (which is\n   quite helpful on a slow, flaky connection).\n\n - The reads that `map_ptr()` now does are aligned on 1K boundaries. This helps\n   some filesystems and/or files that don't like unaligned reads.\n\n - Fix an issue in the msleep() function if time jumps backwards.\n\n - Fix daemon-server module-name splitting bug where an arg would get split\n   even if `--protect-args` was used.\n\n### ENHANCEMENTS:\n\n - Added the `--remote-option=OPT` (`-M OPT`) command-line option that is\n   useful for things like sending a remote `--log-file=FILE` or `--fake-super`\n   option.\n\n - Added the `--info=FLAGS` and `--debug=FLAGS` options to allow finer-grained\n   control over what is output. Added an extra type of `--progress` output\n   using `--info=progress2`.\n\n - The `--msgs2stderr` option can help with debugging rsync by allowing the\n   debug messages to get output to stderr rather than travel via the socket\n   protocol.\n\n - Added the `--delete-missing-args` and `--ignore-missing-args` options to\n   either delete or ignore user-specified files on the receiver that are\n   missing on the sender (normally the absence of user-specified files\n   generates an error).\n\n - Added a `T` (terabyte) category to the `--human-readable` size suffixes.\n\n - Added the `--usermap`/`--groupmap`/`--chown` options for manipulating file\n   ownership during the copy.\n\n - Added the `%C` escape to the log-output handling, which will output the MD5\n   checksum of any transferred file, or all files if `--checksum` was specified\n   (when protocol 30 or above is in effect).\n\n - Added the `reverse lookup` parameter to the rsync daemon config file to\n   allow reverse-DNS lookups to be disabled.\n\n - Added a forward-DNS lookup for the daemon's hosts allow/deny config. Can be\n   disabled via `forward lookup` parameter (defaults to enabled).\n\n - Added a way for more than one group to be specified in the daemon's config\n   file, including a way to specify that you want all of the specified user's\n   groups without having to name them. Also changed the daemon to complain\n   about an inability to set explicitly-specified uid/gid values, even when not\n   run by a super-user.\n\n - The daemon now tries to send the user the error messages from the pre-xfer\n   exec script when it fails.\n\n - Improved the use of alt-dest options into an existing hierarchy of files: If\n   a match is found in an alt-dir, it takes precedence over an existing file.\n   (We'll need to wait for a future version before attribute-changes on\n   otherwise unchanged files are safe when using an existing hierarchy.)\n\n - Added per-user authorization options and group-authorization support to the\n   daemon's `auth users` parameter.\n\n - Added a way to reference environment variables in a daemon's config file\n   (using %VAR% references).\n\n - When replacing a non-dir with a symlink/hard-link/device/special-file, the\n   update should now be done in an atomic manner.\n\n - Avoid re-sending xattr info for hard-linked files w/the same xattrs\n   (protocol 31).\n\n - The backup code was improved to use better logic maintaining the backup\n   directory hierarchy. Also, when a file is being backed up, rsync tries to\n   hard-link it into place so that the upcoming replacement of the destination\n   file will be atomic (for the normal, non-inplace logic).\n\n - Added the ability to synchronize nanosecond modified times.\n\n - Added a few more default suffixes for the `dont compress` settings.\n\n - Added the checking of the `RSYNC_PROTECT_ARGS` environment variable to allow\n   the default for the `--protect-args` command-line option to be overridden.\n\n - Added the `--preallocate` command-line option.\n\n - Allow `--password-file=-` to read the password from stdin (filename `-`).\n\n - Rsync now comes packaged with an rsync-ssl helper script that can be used to\n   contact a remote rsync daemon using a piped-stunnel command.  It also\n   includes an stunnel config file to run the server side to support ssl daemon\n   connections. See the packaging/lsb/rsync.spec file for one way to package\n   the resulting files. (Suggestions for how to make this even easier to\n   install & use are welcomed.)\n\n - Improved the speed of some `--inplace` updates when there are lots of\n   identical checksum blocks that end up being unusable.\n\n - Added the `--outbuf=N|L|B` option for choosing the output buffering.\n\n - Repeating the `--fuzzy` option now causes the code to look for fuzzy matches\n   inside alt-dest directories too.\n\n - The `--chmod` option now supports numeric modes, e.g. `--chmod=644,D755`\n\n - Added some Solaris xattr code.\n\n - Made an rsync daemon (the listening process) exit with a 0 status when it\n   was signaled to die. This helps launchd.\n\n - Improved the `RSYNC_*` environment variables for the pre-xfer exec script:\n   when a daemon is sent multiple request args, they are now joined into a\n   single return value (separated by spaces) so that the `RSYNC_REQUEST`\n   environment variable is accurate for any `pre-xfer exec`. The values in\n   `RSYNC_ARG#` vars are no longer truncated at the `.` arg (prior to the\n   request dirs/files), so that all the requested values are also listed\n   (separately) in `RSYNC_ARG#` variables.\n\n### EXTRAS:\n\n - Added an `instant-rsyncd` script to the support directory, which makes it\n   easy to configure a simple rsync daemon in the current directory.\n\n - Added the `mapfrom` and `mapto` scripts to the support directory, which\n   makes it easier to do user/group mapping in a local transfer based on\n   passwd/group files from another machine.\n\n - There's a new, improved version of the lsh script in the support dir: it's\n   written in perl and supports `-u` without resorting to using sudo (when run\n   as root). The old shell version is now named lsh.sh.\n\n - There is a helper script named rsync-slash-strip in the support directory\n   for anyone that wants to change the way rsync handles args with trailing\n   slashes. (e.g. arg/ would get stripped to arg while arg/. would turn into\n   arg/).\n\n### INTERNAL:\n\n - The I/O code was rewritten to be simpler and do bigger buffered reads over\n   the socket. The I/O between the receiver and the generator was changed to be\n   standard multiplexed-I/O (like that over the socket).\n\n - The sender tries to use any dead time while the generator is looking for\n   files to transfer in order to do sender-side directory scanning in a more\n   parallel manner.\n\n - A daemon can now inform a client about a daemon-configured timeout value so\n   that the client can assist in the keep-alive activity (protocol 31).\n\n - The filter code received some refactoring to make it more extendable, to\n   read better, and do better sanity checking.\n\n - Really big numbers are now output using our own big-num routine rather than\n   casting them to a double and using a %.0f conversion.\n\n - The `pool_alloc` library has received some minor improvements in alignment\n   handling.\n\n - Added `init_stat_x()` function to avoid duplication of acl/xattr init code.\n\n - The included zlib was upgraded from 1.2.3 to 1.2.8.\n\n - Rsync can now be compiled to use an unmodified zlib library instead of the\n   tweaked one that is included with rsync. This will eventually become the\n   default, at which point we'll start the countdown to removing the included\n   zlib. Until then, feel free to configure using:\n\n   ./configure `--with-included-zlib=no`\n\n### DEVELOPER RELATED:\n\n - Added more conditional debug output.\n\n - Fixed some build issues for Android and Minix.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.9 (23 Sep 2011)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fix a crash bug in checksum scanning when `--inplace` is used.\n\n - Fix a hang if a hard-linked file cannot be opened by the sender (e.g.  if it\n   has no read permission).\n\n - Fix preservation of a symlink's system xattrs (e.g. selinux) on Linux.\n\n - Fix a memory leak in the xattr code.\n\n - Fixed a bug with `--delete-excluded` when a filter merge file has a rule\n   that specifies a receiver-only side restriction.\n\n - Fix a bug with the modifying of unwritable directories.\n\n - Fix `--fake-super`'s interaction with `--link-dest` same-file comparisons.\n\n - Fix the updating of the `curr_dir` buffer to avoid a duplicate slash.\n\n - Fix the directory permissions on an implied dot-dir when using `--relative`\n   (e.g. /outside/path/././send/path).\n\n - Fixed some too-long sleeping instances when using `--bwlimit`.\n\n - Fixed when symlink ownership difference-checking gets compiled into\n   `unchanged_attrs()`.\n\n - Improved the socket-error reporting when multiple protocols fail.\n\n - Fixed a case where a socket error could reference just-freed memory.\n\n - Failing to use a password file that was specified on the command-line is now\n   a fatal error.\n\n - Fix the non-root updating of directories that don't have the read and/or\n   execute permission.\n\n - Make daemon-excluded file errors more error-like.\n\n - Fix a compilation issue on older C compilers (due to a misplaced var\n   declaration).\n\n - Make configure avoid finding socketpair on Cygwin.\n\n - Avoid trying to reference `SO_BROADCAST` if the OS doesn't support it.\n\n - Fix some issues with the post-processing of the manpages.\n\n - Fixed the user home-dir handling in the lsh script. (See the support dir.)\n\n - Some minor manpage improvements.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.8 (26 Mar 2011)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed two buffer-overflow issues: one where a directory path that is exactly\n   MAXPATHLEN was not handled correctly, and one handling a `--backup-dir` that\n   is extra extra large.\n\n - Fixed a data-corruption issue when preserving hard-links without preserving\n   file ownership, and doing deletions either before or during the transfer\n   (CVE-2011-1097). This fixes some assert errors in the hard-linking code, and\n   some potential failed checksums (via `-c`) that should have matched.\n\n - Fixed a potential crash when an rsync daemon has a filter/exclude list and\n   the transfer is using ACLs or xattrs.\n\n - Fixed a hang if a really large file is being processed by an rsync that\n   can't handle 64-bit numbers. Rsync will now complain about the file being\n   too big and skip it.\n\n - For devices and special files, we now avoid gathering useless ACL and/or\n   xattr information for files that aren't being copied. (The un-copied files\n   are still put into the file list, but there's no need to gather data that is\n   not going to be used.) This ensures that if the user uses `--no-D`, that\n   rsync can't possibly complain about being unable to gather extended\n   information from special files that are in the file list (but not in the\n   transfer).\n\n - Properly handle requesting remote filenames that start with a dash. This\n   avoids a potential error where a filename could be interpreted as a (usually\n   invalid) option.\n\n - Fixed a bug in the comparing of upper-case letters in file suffixes for\n   `--skip-compress`.\n\n - If an rsync daemon has a module configured without a path setting, rsync\n   will now disallow access to that module.\n\n - If the destination arg is an empty string, it will be treated as a reference\n   to the current directory (as 2.x used to do).\n\n - If rsync was compiled with a newer time-setting function (such as lutimes),\n   rsync will fall-back to an older function (such as utimes) on a system where\n   the newer function is not around. This helps to make the rsync binary more\n   portable in mixed-OS-release situations.\n\n - Fixed a batch-file writing bug that would not write out the full set of\n   compatibility flags that the transfer was using. This fixes a potential\n   protocol problem for a batch file that contains a sender-side I/O error: it\n   would have been sent in a way that the batch-reader wasn't expecting.\n\n - Some improvements to the hard-linking code to ensure that device-number\n   hashing is working right, and to supply more information if the hard-link\n   code fails.\n\n - The `--inplace` code was improved to not search for an impossible checksum\n   position. The quadruple-verbose chunk[N] message will now mention when an\n   inplace chunk was handled by a seek rather than a read+write.\n\n - Improved ACL mask handling, e.g. for Solaris.\n\n - Fixed a bug that prevented `--numeric-ids` from disabling the translation of\n   user/group IDs for ACLs.\n\n - Fixed an issue where an xattr and/or ACL transfer that used an alt-dest\n   option (e.g. `--link-dest`) could output an error trying to itemize the\n   changes against the alt-dest directory's xattr/ACL info but was instead\n   trying to access the not-yet-existing new destination directory.\n\n - Improved xattr system-error messages to mention the full path to the file.\n\n - The `--link-dest` checking for identical symlinks now avoids considering\n   attribute differences that cannot be changed on the receiver.\n\n - Avoid trying to read/write xattrs on certain file types for certain OSes.\n   Improved configure to set `NO_SYMLINK_XATTRS`, `NO_DEVICE_XATTRS`, and/or\n   `NO_SPECIAL_XATTRS` defines in config.h.\n\n - Improved the unsafe-symlink errors messages.\n\n - Fixed a bug setting xattrs on new files that aren't user writable.\n\n - Avoid re-setting xattrs on a hard-linked file w/the same xattrs.\n\n - Fixed a bug with `--fake-super` when copying files and dirs that aren't user\n   writable.\n\n - Fixed a bug where a sparse file could have its last sparse block turned into\n   a real block when rsync sets the file size (requires ftruncate).\n\n - If a temp-file name is too long, rsync now avoids truncating the name in the\n   middle of adjacent high-bit characters. This prevents a potential filename\n   error if the filesystem doesn't allow a name to contain an invalid\n   multi-byte sequence.\n\n - If a muli-protocol socket connection fails (i.e., when contacting a daemon),\n   we now report all the failures, not just the last one. This avoids losing a\n   relevant error (e.g. an IPv4 connection-refused error) that happened before\n   the final error (e.g. an IPv6 protocol-not-supported error).\n\n - Generate a transfer error if we try to call chown with a `-1` for a uid or a\n   gid (which is not settable).\n\n - Fixed the working of `--force` when used with `--one-file-system`.\n\n - Fix the popt arg parsing so that an option that doesn't take an arg will\n   reject an attempt to supply one (can configure `--with-included-popt` if\n   your system's popt library doesn't yet have this fix).\n\n - A couple minor option tweaks to the rrsync script, and also some regex\n   changes that make vim highlighting happier. (See the support dir.)\n\n - Fixed some issues in the mnt-excl script. (See the support dir.)\n\n - Various manpage improvements.\n\n### ENHANCEMENTS:\n\n - Added `.hg/` to the default cvs excludes (see `-C` & `--cvs-exclude`).\n\n### DEVELOPER RELATED:\n\n - Use lchmod() whenever it is available (not just on symlinks).\n\n - A couple fixes to the `socketpair_tcp()` routine.\n\n - Updated the helper scripts in the packaging subdirectory.\n\n - Renamed configure.in to configure.ac.\n\n - Fixed configure's checking for iconv routines for newer OS X versions.\n\n - Fixed the testsuite/xattrs.test script on OS X.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.7 (31 Dec 2009)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a bogus free when using `--xattrs` with `--backup`.\n\n - Avoid an error when `--dry-run` was trying to stat a prior hard-link file\n   that hasn't really been created.\n\n - Fixed a problem with `--compress` (`-z`) where the receiving side could\n   return the error \"`inflate (token) returned -5`\".\n\n - Fixed a bug where `--delete-during` could delete in a directory before it\n   noticed that the sending side sent an I/O error for that directory (both\n   sides of the transfer must be at least 3.0.7).\n\n - Improved `--skip-compress`'s error handling of bad character-sets and got\n   rid of a lingering debug fprintf().\n\n - Fixed the daemon's conveyance of `io_error` value from the sender.\n\n - An rsync daemon use seteuid() (when available) if it used setuid().\n\n - Get the permissions right on a `--fake-super` transferred directory that\n   needs more owner permissions to emulate root behavior.\n\n - An absolute-path filter rule (i.e. with a '/' modifier) no longer loses its\n   modifier when sending the filter rules to the remote rsync.\n\n - Improved the \"`--delete does not work without -r or -d`\" message.\n\n - Improved rsync's handling of `--timeout` to avoid a weird timeout case where\n   the sender could timeout even though it has recently written data to the\n   socket (but hasn't read data recently, due to the writing).\n\n - Some misc manpage improvements.\n\n - Fixed the chmod-temp-dir testsuite on a system without /var/tmp.\n\n - Make sure that a timeout specified in the daemon's config is used as a\n   maximum timeout value when the user also specifies a timeout.\n\n - Improved the error-exit reporting when rsync gets an error trying to cleanup\n   after an error: the initial error is reported.\n\n - Improved configure's detection of IPv6 for Solaris and Cygwin.\n\n - The AIX sysacls routines will now return ENOSYS if ENOTSUP is missing.\n\n - Made our (only used if missing) getaddrinfo() routine use `inet_pton()`\n   (which we also provide) instead of `inet_aton()`.\n\n - The exit-related debug messages now mention the program's role so it is\n   clear who output what message.\n\n### DEVELOPER RELATED:\n\n - Got rid of type-punned compiler warnings output by newer gcc versions.\n\n - The Makefile now ensures that proto.h will be rebuilt if config.h changes.\n\n - The testsuite no longer uses `id -u`, so it works better on Solaris.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.6 (8 May 2009)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a `--read-batch` hang when rsync is reading a batch file that was\n   created from an incremental-recursion transfer.\n\n - Fixed the daemon's socket code to handle the simultaneous arrival of\n   multiple connections.\n\n - Fix `--safe-links`/`--copy-unsafe-links` to properly handle symlinks that\n   have consecutive slashes in the value.\n\n - Fixed the parsing of an `[IPv6_LITERAL_ADDR]` when a USER@ is prefixed.\n\n - The sender now skips a (bogus) symlink that has a 0-length value, which\n   avoids a transfer error in the receiver.\n\n - Fixed a case where the sender could die with a tag-0 error if there was an\n   I/O during the sending of the file list.\n\n - Fixed the rrsync script to avoid a server-side problem when `-e` is at the\n   start of the short options.\n\n - Fixed a problem where a vanished directory could turn into an exit code 23\n   instead of the proper exit code 24.\n\n - Fixed the `--iconv` conversion of symlinks when doing a local copy.\n\n - Fixed a problem where `--one-file-system` was not stopping deletions on the\n   receiving side when a mount-point directory did not match a directory in the\n   transfer.\n\n - Fixed the dropping of an ACL mask when no named ACL values were present.\n\n - Fixed an ACL/xattr corruption issue where the `--backup` option could cause\n   rsync to associate the wrong ACL/xattr information with received files.\n\n - Fixed the use of `--xattrs` with `--only-write-batch`.\n\n - Fixed the use of `--dry-run` with `--read-batch`.\n\n - Fixed configure's erroneous use of target.\n\n - Fixed configure's `--disable-debug` option.\n\n - Fixed a run-time issue for systems that can't find `iconv_open()` by adding\n   the `--disable-iconv-open` configure option.\n\n - Complain and die if the user tries to combine `--remove-source-files` (or\n   the deprecated `--remove-sent-files`) with `--read-batch`.\n\n - Fixed an failure transferring special files from Solaris to Linux.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.5 (28 Dec 2008)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Initialize xattr data in a couple spots in the hlink code, which avoids a\n   crash when the xattr pointer's memory happens to start out non-zero.  Also\n   fixed the itemizing of an alt-dest file's xattrs when hard-linking.\n\n - Don't send a bogus `-` option to an older server if there were no short\n   options specified.\n\n - Fixed skipping of unneeded updates in a batch file when incremental\n   recursion is active. Added a test for this. Made batch-mode handle `redo`\n   files properly (and without hanging).\n\n - Fix the %P logfile escape when the daemon logs from inside a chroot.\n\n - Fixed the use of `-s` (`--protect-args`) when used with a remote source or\n   destination that had an empty path (e.g. `host:`). Also fixed a problem when\n   `-s` was used when accessing a daemon via a remote-shell.\n\n - Fixed the use of a dot-dir path (e.g. foo/./bar) inside a `--files-from`\n   file when the root of the transfer isn't the current directory.\n\n - Fixed a bug with `-K --delete` removing symlinks to directories when\n   incremental recursion is active.\n\n - Fixed a hard to trigger hang when using `--remove-source-files`.\n\n - Got rid of an annoying delay when accessing a daemon via a remote-shell.\n\n - Properly ignore (superfluous) source args on a `--read-batch` command.\n\n - Improved the manpage's description of the `*` wildcard to remove the\n   confusing `non-empty` qualifier.\n\n - Fixed reverse lookups in the compatibility-library version of getnameinfo().\n\n - Fixed a bug when using `--sparse` on a sparse file that has over 2GB of\n   consecutive sparse data.\n\n - Avoid a hang when using at least 3 `--verbose` options on a transfer with a\n   client sender (which includes local copying).\n\n - Fixed a problem with `--delete-delay` reporting an error when it was ready\n   to remove a directory that was now gone.\n\n - Got rid of a bunch of `warn_unused_result` compiler warnings.\n\n - If an ftruncate() on a received file fails, it now causes a partial-\n   transfer warning.\n\n - Allow a path with a leading `//` to be preserved (CYGWIN only).\n\n### ENHANCEMENTS:\n\n - Made the atomic-rsync script able to perform a fully atomic update of the\n   copied hierarchy when the destination is setup using a particular symlink\n   idiom. (See the support dir.)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.4 (6 Sep 2008)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a bug in the hard-linking code where it would sometimes try to\n   allocate 0 bytes of memory (which fails on some OSes, such as AIX).\n\n - Fixed the hard-linking of files from a device that has a device number of 0\n   (which seems to be a common device number on NetBSD).\n\n - Fixed the handling of a `--partial-dir` that cannot be created. This\n   particularly impacts the `--delay-updates` option (since the files cannot be\n   delayed without a partial-dir), and was potentially destructive if the\n   `--remove-source-files` was also specified.\n\n - Fixed a couple issues in the `--fake-super` handling of xattrs when the\n   destination files have root-level attributes (e.g. selinux values) that a\n   non-root copy can't affect.\n\n - Improved the keep-alive check in the generator to fire consistently in\n   incremental-recursion mode when `--timeout` is enabled.\n\n - The `--iconv` option now converts the content of a symlink too, instead of\n   leaving it in the wrong character-set (requires 3.0.4 on both sides of the\n   transfer).\n\n - When using `--iconv`, if a filename fails to convert on the receiving side,\n   this no longer makes deletions in the root-dir of the transfer fail silently\n   (the user now gets a warning about deletions being disabled due to IO error\n   as long as `--ignore-errors` was not specified).\n\n - When using `--iconv`, if a server-side receiver can't convert a filename,\n   the error message sent back to the client no longer mangles the name with\n   the wrong charset conversion.\n\n - Fixed a potential alignment issue in the IRIX ACL code when allocating the\n   initial `struct acl` object. Also, cast mallocs to avoid warnings.\n\n - Changed some errors that were going to stdout to go to stderr.\n\n - Made `human_num()` and `human_dnum()` able to output a negative number\n   (rather than outputting a cryptic string of punctuation).\n\n### ENHANCEMENTS:\n\n - Rsync will avoid sending an `-e` option to the server if an older protocol\n   is requested (and thus the option would not be useful). This lets the user\n   specify the `--protocol=29` option to access an overly-restrictive server\n   that is rejecting the protocol-30 use of `-e` to the server.\n\n - Improved the message output for an `RERR_PARTIAL` exit.\n\n### DEVELOPER RELATED:\n\n - The Makefile will not halt for just a timestamp change on the Makefile or\n   the configure files, only for actual changes in content.\n\n - Changed some commands in the testsuite's xattrs.test that called `rsync`\n   instead of `$RSYNC`.\n\n - Enhanced the release scripts to be able to handle a branch release and to do\n   even more consistency checks on the files.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.3 (29 Jun 2008)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a wildcard matching problem in the daemon when a module has `use\n   chroot` enabled.\n\n - Fixed a crash bug in the hard-link code.\n\n - Fixed the sending of xattr directory information when the code finds a\n   `--link-dest` or `--copy-dest` directory with unchanged xattrs -- the\n   destination directory now gets these unchanged xattrs properly applied.\n\n - Fixed an xattr-sending glitch that could cause an `Internal abbrev` error.\n\n - Fixed the combination of `--xattrs` and `--backup`.\n\n - The generator no longer allows a '.' dir to be excluded by a daemon-exclude\n   rule.\n\n - Fixed deletion handling when copying a single, empty directory (with no\n   files) to a differently named, non-existent directory.\n\n - Fixed the conversion of spaces into dashes in the %M log escape.\n\n - Fixed several places in the code that were not returning the right errno\n   when a function failed.\n\n - Fixed the backing up of a device or special file into a backup dir.\n\n - Moved the setting of the socket options prior to the connect().\n\n - If rsync exits in the middle of a `--progress` output, it now outputs a\n   newline to help prevent the progress line from being overwritten.\n\n - Fixed a problem with how a destination path with a trailing slash or a\n   trailing dot-dir was compared against the daemon excludes.\n\n - Fixed the sending of large (size > 16GB) files when talking to an older\n   rsync (protocols < 30): we now use a compatible block size limit.\n\n - If a file's length is so huge that we overflow a checksum buffer count (i.e.\n   several hundred TB), warn the user and avoid sending an invalid checksum\n   struct over the wire.\n\n - If a source arg is excluded, `--relative` no longer adds the excluded arg's\n   implied dirs to the transfer. This fix also made the exclude check happen in\n   the better place in the sending code.\n\n - Use the `overflow_exit()` function for overflows, not `out_of_memory()`.\n\n - Improved the code to better handle a system that has only 32-bit file\n   offsets.\n\n### ENHANCEMENTS:\n\n - The rsyncd.conf manpage now consistently refers to the parameters in the\n   daemon config file as `parameters`.\n\n - The description of the `--inplace` option was improved.\n\n### EXTRAS:\n\n - Added a new script in the support directory, deny-rsync, which allows an\n   admin to (temporarily) replace the rsync command with a script that sends an\n   error message to the remote client via the rsync protocol.\n\n### DEVELOPER RELATED:\n\n - Fixed a testcase failure if the tests are run as root and made some\n   compatibility improvements.\n\n - Improved the daemon tests, including checking module comments, the listing\n   of files, and the ensuring that daemon excludes can't affect a dot-dir arg.\n\n - Improved some build rules for those that build in a separate directory from\n   the source, including better install rules for the manpages, and the fixing\n   of a proto.h-tstamp rule that could make the binaries get rebuild without\n   cause.\n\n - Improved the testsuite to work around a problem with some utilities (e.g.\n   `cp -p` & `touch -r`) rounding sub-second timestamps.\n\n - Ensure that the early patches don't cause any generated-file hunks to\n   bleed-over into patches that follow.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.2 (8 Apr 2008)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a potential buffer overflow in the xattr code.\n\n### ENHANCEMENTS:\n\n - None.\n\n### DEVELOPER RELATED:\n\n - The RPM spec file was improved to install more useful files.\n\n - A few developer-oriented scripts were moved from the support dir to the\n   packaging dir.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.1 (3 Apr 2008)\n\n## Changes in this version:\n\n### NOTABLE CHANGES IN BEHAVIOR:\n\n - Added the 'c'-flag to the itemizing of non-regular files so that the\n   itemized output doesn't get hidden if there were no attribute changes, and\n   also so that the itemizing of a `--copy-links` run will distinguish between\n   copying an identical non-regular file and the creation of a revised version\n   with a new value (e.g. a changed symlink referent, a new device number,\n   etc.).\n\n### BUG FIXES:\n\n - Fixed a crash bug when a single-use rsync daemon (via remote shell) was run\n   without specifying a `--config=FILE` option.\n\n - Fixed a crash when backing up a directory that has a default ACL.\n\n - Fixed a bug in the handling of xattr values that could cause rsync to not\n   think that a file's extended attributes are up-to-date.\n\n - Fixed the working of `--fake-super` with `--link-dest` and `--xattrs`.\n\n - Fixed a hang when combining `--dry-run` with `--remove-source-files`.\n\n - Fixed a bug with `--iconv`'s handling of files that cannot be converted: a\n   failed name can no longer cause a transfer failure.\n\n - Fixed the building of the rounding.h file on systems that need custom\n   CPPFLAGS to be used. Also improved the error reporting if the building of\n   rounding.h fails.\n\n - Fixed the use of the `--protect-args` (`-s`) option when talking to a\n   daemon.\n\n - Fixed the `--ignore-existing` option's protection of files on the receiver\n   that are non-regular files on the sender (e.g. if a symlink or a dir on the\n   sender is trying to replace a file on the receiver). The reverse protection\n   (protecting a dir/symlink/device from being replaced by a file) was already\n   working.\n\n - Fixed an assert failure if `--hard-links` is combined with an option that\n   can skip a file in a set of hard-linked files (i.e. `--ignore-existing`,\n   `--append`, etc.), without skipping all the files in the set.\n\n - Avoid setting the modify time on a directory that already has the right\n   modify time set. This avoids tweaking the dir's ctime.\n\n - Improved the daemon-exclude handling to do a better job of applying the\n   exclude rules to path entries. It also sends the user an error just as if\n   the files were actually missing (instead of silently ignoring the user's\n   args), and avoids sending the user the filter-action messages for these\n   non-user-initiated rules.\n\n - Fixed some glitches with the dry-run code's missing-directory handling,\n   including a problem when combined with `--fuzzy`.\n\n - Fixed some glitches with the skipped-directory handling.\n\n - Fixed the 'T'-flag itemizing of symlinks when `--time` isn't preserved.\n\n - Fixed a glitch in the itemizing of permissions with the `-E` option.\n\n - The `--append` option's restricting of transfers to those that add data no\n   longer prevents the updating of non-content changes to otherwise up-to-date\n   files (i.e. those with the same content but differing permissions,\n   ownership, xattrs, etc.).\n\n - Don't allow `--fake-super` to be specified with `-XX` (double `--xattrs`)\n   because the options conflict. If a daemon has `fake super` enabled, it\n   automatically downgrades a `-XX` request to `-X`.\n\n - Fixed a couple bugs in the parsing of daemon-config excludes that could make\n   a floating exclude rule get treated as matching an absolute path.\n\n - A daemon doesn't try to auto-refuse the `iconv` option if iconv-support\n   wasn't compiled in to the daemon (avoiding a warning in the logs).\n\n - Fixed the inclusion of per-dir merge files from implied dirs.\n\n - Fixed the rrsync script to work with the latest options that rsync sends,\n   including its flag-specifying use of `-e` to the server. (See the support\n   dir.)\n\n### ENHANCEMENTS:\n\n - Added the `--old-dirs` (`--old-d`) option to make it easier for a user to\n   ask for file-listings with older rsync versions (this is easier than having\n   to type `-r --exclude='/*/*'` manually).\n\n - When getting an error while asking an older rsync daemon for a file listing,\n   rsync will try to notice if the error is a rejection of the `--dirs` (`-d`)\n   option and let the user know how to work around the issue.\n\n - Added a few more `--no-OPTION` overrides.\n\n - Improved the documentation of the `--append` option.\n\n - Improved the documentation of the filter/exclude/include daemon parameters.\n\n### INTERNAL:\n\n - Fixed a couple minor bugs in the included popt library (ones which I sent to\n   the official popt project for inclusion in the 1.14 release).\n\n - Fixed a stat() call that should have been `do_stat()` so that the proper\n   normal/64-bit stat() function gets called. (Was in an area that should not\n   have caused problems, though.)\n\n - Changed the file-glob code to do a directory scan without using the `glob`\n   and `glob.h`. This lets us do the globbing with less memory churn, and also\n   avoid adding daemon-excluded items to the returned args.\n\n### DEVELOPER RELATED:\n\n - The configure script tries to get the user's compiler to not warn about\n   unused function parameters if the build is not including one or more of the\n   ACL/xattrs/iconv features.\n\n - The configure script now has better checks for figuring out if the included\n   popt code should be used or not.\n\n - Fixed two testsuite glitches: avoid a failure if someone's `cd` command\n   outputs the current directory when cd-ing to a relative path, and made the\n   itemized test query how rsync was built to determine if it should expect\n   hard-linked symlinks or not.\n\n - Updated the testsuite to verify that various bug fixes remain fixed.\n\n - The RPM spec file was updated to have: (1) comments for how to use the\n   rsync-patch tar file, and (2) an /etc/xinetd.d/rsync file.\n\n - Updated the build scripts to work with a revised FTP directory structure.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 3.0.0 (1 Mar 2008)\n\n## Changes in this version:\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 30.\n\n### NOTABLE CHANGES IN BEHAVIOR:\n\n - The handling of implied directories when using `--relative` has changed to\n   send them as directories (e.g. no implied dir is ever sent as a symlink).\n   This avoids unexpected behavior and should not adversely affect most people.\n   If you're one of those rare individuals who relied upon having an implied\n   dir be duplicated as a symlink, you should specify the transfer of the\n   symlink and the transfer of the referent directory as separate args. (See\n   also `--keep-dirlinks` and `--no-implied-dirs`.) Also, exclude rules no\n   longer have a partial effect on implied dirs.\n\n - Requesting a remote file-listing without specifying `-r` (`--recursive`) now\n   sends the `-d` (`--dirs`) option to the remote rsync rather than sending\n   `-r` along with an extra exclude of `/*/*`. If the remote rsync does not\n   understand the `-d` option (i.e. it is 2.6.3 or older), you will need to\n   either turn off `-d` (`--no-d`), or specify `-r --exclude='/*/*'` manually.\n\n - In `--dry-run` mode, the last line of the verbose summary text is output\n   with a \"(DRY RUN)\" suffix to help remind you that no updates were made.\n   Similarly, `--only-write-batch` outputs `(BATCH ONLY)`.\n\n - A writable rsync daemon with `use chroot` disabled now defaults to a\n   symlink-munging behavior designed to make symlinks safer while also allowing\n   absolute symlinks to be stored and retrieved. This also has the effect of\n   making symlinks unusable while they're in the daemon's hierarchy. See the\n   daemon's `munge symlinks` parameter for details.\n\n - Starting up an extra copy of an rsync daemon will not clobber the pidfile\n   for the running daemon -- if the pidfile exists, the new daemon will exit\n   with an error. This means that your wrapper script that starts the rsync\n   daemon should be made to handle lock-breaking (if you want any automatic\n   breaking of locks to be done).\n\n### BUG FIXES:\n\n - A daemon with `use chroot = no` and excluded items listed in the daemon\n   config file now properly checks an absolute-path arg specified for these\n   options: `--compare-dest`, `--link-dest`, `--copy-dest`, `--partial-dir`,\n   `--backup-dir`, `--temp-dir`, and `--files-from`.\n\n - A daemon can now be told to disable all user- and group-name translation on\n   a per-module basis. This avoids a potential problem with a writable daemon\n   module that has `use chroot` enabled -- if precautions weren't taken, a user\n   could try to add a missing library and get rsync to use it. This makes rsync\n   safer by default, and more configurable when id-translation is not desired.\n   See the daemon's `numeric ids` parameter for full details.\n\n - A chroot daemon can now indicate which part of its path should affect the\n   chroot call, and which part should become an inside-chroot path for the\n   module. This allows you to have outside-the-transfer paths (such as for\n   libraries) even when you enable chroot protection. The idiom used in the\n   rsyncd.conf file is: `path = /chroot/dirs/./dirs/inside`\n\n - If a file's data arrived successfully on the receiving side but the rename\n   of the temporary file to the destination file failed AND the\n   `--remove-source-files` (or the deprecated `--remove-sent-files`) option was\n   specified, rsync no longer erroneously removes the associated source file.\n\n - Fixed the output of `-ii` when combined with one of the `--*-dest` options:\n   it now itemizes all the items, not just the changed ones.\n\n - Made the output of all file types consistent when using a `--*-dest` option.\n   Prior versions would output too many creation events for matching items.\n\n - The code that waits for a child pid now handles being interrupted by a\n   signal. This fixes a problem with the pre-xfer exec function not being able\n   to get the exit status from the script.\n\n - A negated filter rule (i.e. with a '!' modifier) no longer loses the\n   negation when sending the filter rules to the remote rsync.\n\n - Fixed a problem with the `--out-format` (aka `--log-format`) option %f: it\n   no longer outputs superfluous directory info for a non-daemon rsync.\n\n - Fixed a problem with `-vv` (double `--verbose`) and `--stats` when `pushing`\n   files (which includes local copies). Version 2.6.9 would complete the copy,\n   but exit with an error when the receiver output its memory stats.\n\n - If `--password-file` is used on a non-daemon transfer, rsync now complains\n   and exits. This should help users figure out that they can't use this option\n   to control a remote shell's password prompt.\n\n - Make sure that directory permissions of a newly-created destination\n   directory are handled right when `--perms` is left off.\n\n - The itemized output of a newly-created destination directory is now output\n   as a creation event, not a change event.\n\n - Improved `--hard-link` so that more corner cases are handled correctly when\n   combined with options such as `--link-dest` and/or `--ignore-existing`.\n\n - The `--append` option no longer updates a file that has the same size.\n\n - Fixed a bug when combining `--backup` and `--backup-dir` with `--inplace`:\n   any missing backup directories are now created.\n\n - Fixed a bug when using `--backup` and `--inplace` with `--whole-file` or\n   `--read-batch`: backup files are actually created now.\n\n - The daemon pidfile is checked and created sooner in the startup sequence.\n\n - If a daemon module's `path` value is not an absolute pathname, the code now\n   makes it absolute internally (making it work properly).\n\n - Ensure that a temporary file always has owner-write permission while we are\n   writing to it. This avoids problems with some network filesystems when\n   transferring read-only files.\n\n - Any errors output about password-file reading no longer cause an error at\n   the end of the run about a partial transfer.\n\n - The `--read-batch` option for protocol 30 now ensures that several more\n   options are set correctly for the current batch file: `--iconv`, `--acls`,\n   `--xattrs`, `--inplace`, `--append`, and `--append-verify`.\n\n - Using `--only-write-batch` to a daemon receiver now works properly (older\n   versions would update some files while writing the batch).\n\n - Avoid outputting a \"file has vanished\" message when the file is a broken\n   symlink and `--copy-unsafe-links` or `--copy-dirlinks` is used (the code\n   already handled this for `--copy-links`).\n\n - Fixed the combination of `--only-write-batch` and `--dry-run`.\n\n - Fixed rsync's ability to remove files that are not writable by the file's\n   owner when rsync is running as the same user.\n\n - When transferring large files, the sender's hashtable of checksums is kept\n   at a more reasonable state of fullness (no more than 80% full) so that the\n   scanning of the hashtable will not bog down as the number of blocks\n   increases.\n\n### ENHANCEMENTS:\n\n - A new incremental-recursion algorithm is now used when rsync is talking to\n   another 3.x version. This starts the transfer going more quickly (before all\n   the files have been found), and requires much less memory.  See the\n   `--recursive` option in the manpage for some restrictions.\n\n - Lowered memory use in the non-incremental-recursion algorithm for typical\n   option values (usually saving from 21-29 bytes per file).\n\n - The default `--delete` algorithm is now `--delete-during` when talking to a\n   3.x rsync. This is a faster scan than using `--delete-before` (which is the\n   default when talking to older rsync versions), and is compatible with the\n   new incremental recursion mode.\n\n - Rsync now allows multiple remote-source args to be specified rather than\n   having to rely on a special space-splitting side-effect of the remote-\n   shell. Additional remote args must specify the same host or an empty one\n   (e.g. empty: `:file1` or `::module/file2`). For example, this means that\n   local use of brace expansion now works: `rsync -av host:dir/{f1,f2} .`\n\n - Added the `--protect-args` (`-s`) option, that tells rsync to send most of\n   the command-line args at the start of the transfer rather than as args to\n   the remote-shell command. This protects them from space-splitting, and only\n   interprets basic wildcard special shell characters (`*?[`).\n\n - Added the `--delete-delay` option, which is a more efficient way to delete\n   files at the end of the transfer without needing a separate delete pass.\n\n - Added the `--acls` (`-A`) option to preserve Access Control Lists. This is\n   an improved version of the prior patch that was available, and it even\n   supports OS X ACLs. If you need to have backward compatibility with old,\n   ACL-patched versions of rsync, apply the acls.diff file from the patches\n   dir.\n\n - Added the `--xattrs` (`-X`) option to preserve extended attributes. This is\n   an improved version of the prior patch that was available, and it even\n   supports OS X xattrs (which includes their resource fork data). If you need\n   to have backward compatibility with old, xattr-patched versions of rsync,\n   apply the xattrs.diff file from the patches dir.\n\n - Added the `--fake-super` option that allows a non-super user to preserve all\n   attributes of a file by using a special extended-attribute idiom.  It even\n   supports the storing of foreign ACL data on your backup server.  There is\n   also an analogous `fake super` parameter for an rsync daemon.\n\n - Added the `--iconv` option, which allows rsync to convert filenames from one\n   character-set to another during the transfer. The default is to make this\n   feature available as long as your system has `iconv_open()`.  If compilation\n   fails, specify `--disable-iconv` to configure, and then rebuild. If you want\n   rsync to perform character-set conversions by default, you can specify\n   `--enable-iconv=CONVERT_STRING` with the default value for the `--iconv`\n   option that you wish to use. For example, `--enable-iconv=.` is a good\n   choice. See the rsync manpage for an explanation of the `--iconv` option's\n   settings.\n\n - A new daemon config parameter, `charset`, lets you control the character-\n   set that is used during an `--iconv` transfer to/from a daemon module. You\n   can also set your daemon to refuse `no-iconv` if you want to force the\n   client to use an `--iconv` transfer (requiring an rsync 3.x client).\n\n - Added the `--skip-compress=LIST` option to override the default list of file\n   suffixes that will not be compressed when using `--compress` (`-z`).\n\n - The daemon's default for `dont compress` was extended to include: `*.7z`\n   `*.mp[34]` `*.mov` `*.avi` `*.ogg` `*.jpg` `*.jpeg` and the name-matching routine was also\n   optimized to run more quickly.\n\n - The `--max-delete` option now outputs a warning if it skipped any file\n   deletions, including a count of how many deletions were skipped. (Older\n   versions just silently stopped deleting things.)\n\n - You may specify `--max-delete=0` to a 3.0.0 client to request that it warn\n   about extraneous files without deleting anything. If you're not sure what\n   version the client is, you can use the less-obvious `--max-delete=-1`, as\n   both old and new versions will treat that as the same request (though older\n   versions don't warn).\n\n - The `--hard-link` option now uses less memory on both the sending and\n   receiving side for all protocol versions. For protocol 30, the use of a\n   hashtable on the sending side allows us to more efficiently convey to the\n   receiver what files are linked together. This reduces the amount of data\n   sent over the socket by a considerable margin (rather than adding more\n   data), and limits the in-memory storage of the device+inode information to\n   just the sending side for the new protocol 30, or to the receiving side when\n   speaking an older protocol (note that older rsync versions kept the\n   device+inode information on both sides).\n\n - The filter rules now support a perishable (`p`) modifier that marks rules\n   that should not have an effect in a directory that is being deleted. e.g.\n   `-f '-p .svn/'` would only affect `live` .svn directories.\n\n - Rsync checks all the alternate-destination args for validity (e.g.\n   `--link-dest`). This lets the user know when they specified a directory that\n   does not exist.\n\n - If we get an ENOSYS error setting the time on a symlink, we don't complain\n   about it anymore (for those systems that even support the setting of the\n   modify-time on a symlink).\n\n - Protocol 30 now uses MD5 checksums instead of MD4.\n\n - Changed the `--append` option to not checksum the existing data in the\n   destination file, which speeds up file appending.\n\n - Added the `--append-verify` option, which works like the older `--append`\n   option (verifying the existing data in the destination file). For\n   compatibility with older rsync versions, any use of `--append` that is\n   talking protocol 29 or older will revert to the `--append-verify` method.\n\n - Added the `--contimeout=SECONDS` option that lets the user specify a\n   connection timeout for rsync daemon access.\n\n - Documented and extended the support for the `RSYNC_CONNECT_PROG` variable\n   that can be used to enhance the client side of a daemon connection.\n\n - Improved the dashes and double-quotes in the nroff manpage output.\n\n - Rsync now supports a lot more `--no-OPTION` override options.\n\n### INTERNAL:\n\n - The file-list sorting algorithm now uses a sort that keeps any same-named\n   items in the same order as they were specified. This allows rsync to always\n   ensure that the first of the duplicates is the one that will be included in\n   the copy. The new sort is also faster than the glibc version of qsort() and\n   mergesort().\n\n - Rsync now supports the transfer of 64-bit timestamps (`time_t` values).\n\n - Made the file-deletion code use a little less stack when recursing through a\n   directory hierarchy of extraneous files.\n\n - Fixed a build problem with older (2.x) versions of gcc.\n\n - Added some isType() functions that make dealing with signed characters\n   easier without forcing variables via casts.\n\n - Changed strcat/strcpy/sprintf function calls to use safer versions.\n\n - Upgraded the included popt version to 1.10.2 and improved its use of\n   string-handling functions.\n\n - Added missing prototypes for compatibility functions from the lib dir.\n\n - Configure determines if iconv() has a const arg, allowing us to avoid a\n   compiler warning.\n\n - Made the sending of some numbers more efficient for protocol 30.\n\n - Make sure that a daemon process doesn't mind if the client was weird and\n   omitted the `--server` option.\n\n - There are more internal logging categories available in protocol 30 than the\n   age-old FINFO and FERROR, including `FERROR_XFER` and FWARN. These new\n   categories allow some errors and warnings to go to stderr without causing an\n   erroneous end-of-run warning about some files not being able to be\n   transferred.\n\n - Improved the use of `const` on pointers.\n\n - Improved J.W.'s `pool_alloc` routines to add a way of incrementally freeing\n   older sections of a pool's memory.\n\n - The getaddrinfo.c compatibility code in the `lib` dir was replaced with some\n   new code (derived from samba, derived from PostgreSQL) that has a better\n   license than the old code.\n\n### DEVELOPER RELATED:\n\n - Rsync is now licensed under the GPLv3 or later.\n\n - Rsync is now being maintained in a `git` repository instead of CVS (though\n   the old CVS repository still exists for historical access).  Several\n   maintenance scripts were updated to work with git.\n\n - Generated files are no longer committed into the source repository. The\n   autoconf and autoheader commands are now automatically run during the normal\n   use of `configure` and `make`. The latest dev versions of all generated\n   files can also be copied from the samba.org web site (see the prepare-source\n   script's fetch option).\n\n - The `patches` directory of diff files is now built from branches in the\n   rsync git repository (branch patch/FOO creates file patches/FOO.diff).  This\n   directory is now distributed in a separate separate tar file named\n   rsync-patches-VERSION.tar.gz instead of the main rsync-VERSION.tar.gz.\n\n - The proto.h file is now built using a simple perl script rather than a\n   complex awk script, which proved to be more widely compatible.\n\n - When running the tests, we now put our per-test temp dirs into a sub-\n   directory named testtmp (which is created, if missing). This allows someone\n   to symlink the testtmp directory to another filesystem (which is useful if\n   the build dir's filesystem does not support ACLs and xattrs, but another\n   filesystem does).\n\n - Rsync now has a way of handling protocol-version changes during the\n   development of a new protocol version. This causes any out-of-sync versions\n   to speak an older protocol rather than fail in a cryptic manner.  This\n   addition makes it safer to deploy a pre-release version that may interact\n   with the public. This new exchange of sub-version info does not interfere\n   with the `{MIN,MAX}_PROTOCOL_VERSION` checking algorithm (which does not\n   have enough range to allow the main protocol number to be incremented for\n   every minor tweak in that happens during development).\n\n - The csprotocol.txt file was updated to mention the daemon protocol change in\n   the 3.0.0 release.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.9 (6 Nov 2006)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - If rsync is interrupted via a handled signal (such as SIGINT), it will once\n   again clean-up its temp file from the destination dir.\n\n - Fixed an overzealous sanitizing bug in the handling of the `--link-dest`,\n   `--copy-dest`, and `--compare-dest` options to a daemon without chroot: if\n   the copy's destination dir is deeper than the top of the module's path,\n   these options now accept a safe number of parent-dir (../) references (since\n   these options are relative to the destination dir). The old code incorrectly\n   chopped off all `../` prefixes for these options, no matter how deep the\n   destination directory was in the module's hierarchy.\n\n - Fixed a bug where a deferred info/error/log message could get sent directly\n   to the sender instead of being handled by rwrite() in the generator. This\n   fixes an `unexpected tag 3` fatal error, and should also fix a potential\n   problem where a deferred info/error message from the receiver might bypass\n   the log file and get sent only to the client process. (These problems could\n   only affect an rsync daemon that was receiving files.)\n\n - Fixed a bug when `--inplace` was combined with a `--*-dest` option and we\n   update a file's data using an alternate basis file. The code now notices\n   that it needs to copy the matching data from the basis file instead of\n   (wrongly) assuming that it was already present in the file.\n\n - Fixed a bug where using `--dry-run` with a `--*-dest` option with a path\n   relative to a directory that does not yet exist: the affected option gets\n   its proper path value so that the output of the dry-run is right.\n\n - Fixed a bug in the %f logfile escape when receiving files: the destination\n   path is now included in the output (e.g. you can now tell when a user\n   specifies a subdir inside a module).\n\n - If the receiving side fails to create a directory, it will now skip trying\n   to update everything that is inside that directory.\n\n - If `--link-dest` is specified with `--checksum` but without `--times`, rsync\n   will now allow a hard-link to be created to a matching link-dest file even\n   when the file's modify-time doesn't match the server's file.\n\n - The daemon now calls more timezone-using functions prior to doing a chroot.\n   This should help some C libraries to generate proper timestamps from inside\n   a chrooted daemon (and to not try to access /etc/timezone over and over\n   again).\n\n - Fixed a bug in the handling of an absolute `--partial-dir=ABS_PATH` option:\n   it now deletes an alternate basis file from the partial-dir that was used to\n   successfully update a destination file.\n\n - Fixed a bug in the handling of `--delete-excluded` when using a per-dir\n   merge file: the merge file is now honored on the receiving side, and only\n   its unqualified include/exclude commands are ignored (just as is done for\n   global include/excludes).\n\n - Fixed a recent bug where `--delete` was not working when transferring from\n   the root (/) of the filesystem with `--relative` enabled.\n\n - Fixed a recent bug where an `--exclude='*'` could affect the root (/) of the\n   filesystem with `--relative` enabled.\n\n - When `--inplace` creates a file, it is now created with owner read/write\n   permissions (0600) instead of no permissions at all. This avoids a problem\n   continuing a transfer that was interrupted (since `--inplace` will not\n   update a file that has no write permissions).\n\n - If either `--remove-source-files` or `--remove-sent-files` is enabled and we\n   are unable to remove the source file, rsync now outputs an error.\n\n - Fixed a bug in the daemon's `incoming chmod` rule: newly-created directories\n   no longer get the 'F' (file) rules applied to them.\n\n - Fixed an infinite loop bug when a filter rule was rejected due to being\n   overly long.\n\n - When the server receives a `--partial-dir` option from the client, it no\n   longer runs the client-side code that adds an assumed filter rule (since the\n   client will be sending us the rules in the usual manner, and they may have\n   chosen to override the auto-added rule).\n\n### ENHANCEMENTS:\n\n - Added the `--log-file=FILE` and `--log-file-format=FORMAT` options. These\n   can be used to tell any rsync to output what it is doing to a log file.\n   They work with a client rsync, a non-daemon server rsync (see the manpage\n   for instructions), and also allows the overriding of rsyncd.conf settings\n   when starting a daemon.\n\n - The `--log-format` option was renamed to be `--out-format` to avoid\n   confusing it with affecting the log-file output. (The old option remains as\n   an alias for the new to preserve backward compatibility.)\n\n - Made `log file` and `syslog facility` settable on a per-module basis in the\n   daemon's config file.\n\n - Added the `--remove-source-files` option as a replacement for the (now\n   deprecated) `--remove-sent-files` option. This new option removes all\n   non-dirs from the source directories, even if the file was already\n   up-to-date. This fixes a problem where interrupting an rsync that was using\n   `--remove-sent-files` and restarting it could leave behind a file that the\n   earlier rsync synchronized, but didn't get to remove.  (The deprecated\n   `--remove-sent-files` is still understood for now, and still behaves in the\n   same way as before.)\n\n - Added the option `--no-motd` to suppress the message-of-the-day output from\n   a daemon when doing a copy. (See the manpage for a caveat.)\n\n - Added a new environment variable to the pre-/post-xfer exec commands (in the\n   daemon's config file): `RSYNC_PID`. This value will be the same in both the\n   pre- and post-xfer commands, so it can be used as a unique ID if the\n   pre-xfer command wants to cache some arg/request info for the post-xfer\n   command.\n\n### INTERNAL:\n\n - Did a code audit using IBM's code-checker program and made several changes,\n   including: replacing most of the strcpy() and sprintf() calls with\n   strlcpy(), snprintf(), and memcpy(), adding a 0-value to an enum that had\n   been intermingling a literal 0 with the defined enum values, silencing some\n   uninitialized memory checks, marking some functions with a `noreturn`\n   attribute, and changing an `if` that could never succeed on some platforms\n   into a pre-processor directive that conditionally compiles the code.\n\n - Fixed a potential bug in `f_name_cmp()` when both the args are a top-level\n   `.` dir (which doesn't happen in normal operations).\n\n - Changed `exit_cleanup()` so that it can never return instead of exit.  The\n   old code might return if it found the `exit_cleanup()` function was being\n   called recursively. The new code is segmented so that any recursive calls\n   move on to the next step of the exit-processing.\n\n - The macro WIFEXITED(stat) will now be defined if the OS didn't already\n   define it.\n\n### DEVELOPER RELATED:\n\n - The acls.diff and xattrs.diff patches have received a bunch of work to make\n   them much closer to being acceptable in the main distribution.  The xattrs\n   patch also has some preliminary Mac OS X and FreeBSD compatibility code that\n   various system types to exchange extended file-attributes.\n\n - A new diff in the patches dir, fake-root.diff, allows rsync to maintain a\n   backup hierarchy with full owner, group, and device info without actually\n   running as root. It does this using a special extended attribute, so it\n   depends on xattrs.diff (which depends on acls.diff).\n\n - The rsync.yo and rsyncd.conf.yo files have been updated to work better with\n   the latest yodl 2.x releases.\n\n - Updated config.guess and config.sub to their 2006-07-02 versions.\n\n - Updated various files to include the latest FSF address and to have\n   consistent opening comments.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.8 (22 Apr 2006)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a bug in the exclude code where an anchored exclude without any\n   wildcards fails to match an absolute source arg, but only when `--relative`\n   is in effect.\n\n - Improved the I/O code for the generator to fix a potential hang when the\n   receiver gets an EOF on the socket but the generator's select() call never\n   indicates that the socket is writable for it to be notified about the EOF.\n   (This can happen when using stunnel).\n\n - Fixed a problem with the file-reading code where a failed read (such as that\n   caused by a bad sector) would not advance the file's read-position beyond\n   the failed read's data.\n\n - Fixed a logging bug where the `log file` directive was not being honored in\n   a single-use daemon (one spawned by a remote-shell connection or by init).\n\n - If rsync cannot honor the `--delete` option, we output an error and exit\n   instead of silently ignoring the option.\n\n - Fixed a bug in the `--link-dest` code that prevented special files (such as\n   fifos) from being linked.\n\n - The ability to hard-link symlinks and special files is now determined at\n   configure time instead of at runtime. This fixes a bug with `--link-dest`\n   creating a hard-link to a symlink's referent on a BSD system.\n\n### ENHANCEMENTS:\n\n - In daemon mode, if rsync fails to bind to the requested port, the error(s)\n   returned by socket() and/or bind() are now logged.\n\n - When we output a fatal error, we now output the version of rsync in the\n   message.\n\n - Improved the documentation for the `--owner` and `--group` options.\n\n - The rsyncstats script in `support` has an improved line-parsing regex that\n   is easier to read and also makes it to parse syslog-generated lines.\n\n - A new script in `support`: file-attr-restore, can be used to restore the\n   attributes of a file-set (the permissions, ownership, and group info) taken\n   from the cached output of a `find ARG... -ls` command.\n\n### DEVELOPER RELATED:\n\n - Removed the unused function `write_int_named()`, the unused variable\n   `io_read_phase`, and the rarely used variable `io_write_phase`. This also\n   elides the confusing 'phase \"unknown\"' part of one error message.\n\n - Removed two unused configure checks and two related (also unused)\n   compatibility functions.\n\n - The xattrs.diff patch received a security fix that prevents a potential\n   buffer overflow in the `receive_xattr()` code.\n\n - The acls.diff patch has been improved quite a bit, with more to come.\n\n - A new patch was added: log-file.diff. This contains an early version of a\n   future option, `--log-file=FILE`, that will allow any rsync to log its\n   actions to a file (something that only a daemon supports at present).\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.7 (11 Mar 2006)\n\n## Changes in this version:\n\n### OUTPUT CHANGES:\n\n - The letter 'D' in the itemized output was being used for both devices\n   (character or block) as well as other special files (such as fifos and named\n   sockets). This has changed to separate non-device special files under the\n   'S' designation (e.g. `cS+++++++ path/fifo`). See also the `--specials`\n   option, below.\n\n - The way rsync escapes unreadable characters has changed. First, rsync now\n   has support for recognizing valid multi-byte character sequences in your\n   current locale, allowing it to escape fewer characters than before for a\n   locale such as UTF-8. Second, it now uses an escape idiom of `\\#123`, which\n   is the literal string `\\#` followed by exactly 3 octal digits. Rsync no\n   longer doubles a backslash character in a filename (e.g. it used to output\n   `foo\\\\bar` when copying `foo\\bar`) -- now it only escapes a backslash that\n   is followed by a hash-sign and 3 digits (0-9) (e.g. it will output\n   `foo\\#134#789` when copying `foo\\#789`). See also the `--8-bit-output`\n   (`-8`) option, mentioned below.\n\n   Script writers: the local rsync is the one that outputs escaped names, so if\n   you need to support unescaping of filenames for older rsyncs, I'd suggest\n   that you parse the output of `rsync --version` and only use the old\n   unescaping rules for 2.6.5 and 2.6.6.\n\n### BUG FIXES:\n\n - Fixed a really old bug that caused `--checksum` (`-c`) to checksum all the\n   files encountered during the delete scan (ouch).\n\n - Fixed a potential hang in a remote generator: when the receiver gets a\n   read-error on the socket, it now signals the generator about this so that\n   the generator does not try to send any of the terminating error messages to\n   the client (avoiding a potential hang in some setups).\n\n - Made hard-links work with symlinks and devices again.\n\n - If the sender gets an early EOF reading a source file, we propagate this\n   error to the receiver so that it can discard the file and try requesting it\n   again (which is the existing behavior for other kinds of read errors).\n\n - If a device-file/special-file changes permissions, rsync now updates the\n   permissions without recreating the file.\n\n - If the user specifies a remote-host for both the source and destination, we\n   now output a syntax error rather than trying to open the destination\n   hostspec as a filename.\n\n - When `--inplace` creates a new destination file, rsync now creates it with\n   permissions 0600 instead of 0000 -- this makes restarting possible when the\n   transfer gets interrupted in the middle of sending a new file.\n\n - Reject the combination of `--inplace` and `--sparse` since the sparse-output\n   algorithm doesn't work when overwriting existing data.\n\n - Fixed the directory name in the error that is output when `pop_dir()` fails.\n\n - Really fixed the parsing of a `!` entry in .cvsignore files this time.\n\n - If the generator gets a stat() error on a file, output it (this used to\n   require at least `-vv` for the error to be seen).\n\n - If waitpid() fails or the child rsync didn't exit cleanly, we now handle the\n   exit status properly and generate a better error.\n\n - Fixed some glitches in the double-verbose output when using `--copy-dest`,\n   `--link-dest`, or `--compare-dest`. Also improved how the verbose output\n   handles hard-links (within the transfer) that had an up-to-date alternate\n   `dest` file, and copied files (via `--copy-dest`).\n\n - Fixed the matching of the dont-compress items (e.g. `*.gz`) against files\n   that have a path component containing a slash.\n\n - If the code reading a filter/exclude file gets an EINTR error, rsync now\n   clears the error flag on the file handle so it can keep on reading.\n\n - If `--relative` is active, the sending side cleans up trailing `/` or `/.`\n   suffixes to avoid triggering a bug in older rsync versions. Also, we now\n   reject a `..` dir if it would be sent as a relative dir.\n\n - If a non-directory is in the way of a directory and rsync is run with\n   `--dry-run` and `--delete`, rsync no longer complains about not being able\n   to opendir() the not-yet present directory.\n\n - When `--list-only` is used and a non-existent local destination dir was also\n   specified as a destination, rsync no longer generates a warning about being\n   unable to create the missing directory.\n\n - Fixed some problems with `--relative --no-implied-dirs` when the destination\n   directory did not yet exist: we can now create a symlink or device when it\n   is the first thing in the missing dir, and `--fuzzy` no longer complains\n   about being unable to open the missing dir.\n\n - Fixed a bug where the `--copy-links` option would not affect implied\n   directories without `--copy-unsafe-links` (see `--relative`).\n\n - Got rid of the need for `--force` to be used in some circumstances with\n   `--delete-after` (making it consistent with\n   `--delete-before`/`--delete-during`).\n\n - Rsync now ignores the SIGXFSZ signal, just in case your OS sends this when a\n   file is too large (rsync handles the write error).\n\n - Fixed a bug in the Proxy-Authorization header's base64-encoded value: it was\n   not properly padded with trailing '=' chars. This only affects a user that\n   need to use a password-authenticated proxy for an outgoing daemon-rsync\n   connection.\n\n - If we're transferring an empty directory to a new name, rsync no longer\n   forces `S_IWUSR` if it wasn't already set, nor does it accidentally leave it\n   set.\n\n - Fixed a bug in the debug output (`-vvvvv`) that could mention the wrong\n   checksum for the current file offset.\n\n - Rsync no longer allows a single directory to be copied over a non-directory\n   destination arg.\n\n### ENHANCEMENTS:\n\n - Added the `--append` option that makes rsync append data onto files that are\n   longer on the source than the destination (this includes new files).\n\n - Added the `--min-size=SIZE` option to exclude small files from the transfer.\n\n - Added the `--compress-level` option to allow you to set how aggressive\n   rsync's compression should be (this option implies `--compress`).\n\n - Enhanced the parsing of the SIZE value for `--min-size` and `--max-size` to\n   allow easy entry of multiples of 1000 (instead of just multiples of 1024)\n   and off-by-one values too (e.g. `--max-size=8mb-1`).\n\n - Added the `--8-bit-output` (`-8`) option, which tells rsync to avoid\n   escaping high-bit characters that it thinks are unreadable in the current\n   locale.\n\n - The new option `--human-readable` (`-h`) changes the output of `--progress`,\n   `--stats`, and the end-of-run summary to be easier to read. If repeated, the\n   units become powers of 1024 instead of powers of 1000. (The old meaning of\n   `-h`, as a shorthand for `--help`, still works as long as you just use it on\n   its own, as in `rsync -h`.)\n\n - If lutimes() and/or lchmod() are around, use them to allow the preservation\n   of attributes on symlinks.\n\n - The `--link-dest` option now affects symlinks and devices (when possible).\n\n - Added two config items to the rsyncd.conf parsing: `pre-xfer exec` and\n   `post-xfer exec`. These allow a command to be specified on a per-module\n   basis that will be run before and/or after a daemon-mode transfer. (See the\n   manpage for a list of the environment variables that are set with\n   information about the transfer.)\n\n - When using the `--relative` option, you can now insert a dot dir in the\n   source path to indicate where the replication of the source dirs should\n   start. For example, if you specify a source path of\n   rsync://host/module/foo/bar/./baz/dir with `-R`, rsync will now only\n   replicate the `baz/dir` part of the source path (note: a trailing dot dir is\n   unaffected unless it also has a trailing slash).\n\n - Added some new `--no-FOO` options that make it easier to override unwanted\n   implied or default options. For example, `-a --no-o` (aka `--archive\n   --no-owner`) can be used to turn off the preservation of file ownership that\n   is implied by `-a`.\n\n - Added the `--chmod=MODE` option that allows the destination permissions to\n   be changed from the source permissions. E.g. `--chmod=g+w,o-rwx`\n\n - Added the `incoming chmod` and `outgoing chmod` daemon options that allow a\n   module to specify what permissions changes should be applied to all files\n   copied to and from the daemon.\n\n - Allow the `--temp-dir` option to be specified when starting a daemon, which\n   sets the default temporary directory for incoming files.\n\n - If `--delete` is combined with `--dirs` without `--recursive`, rsync will\n   now delete in any directory whose content is being synchronized.\n\n - If `--backup` is combined with `--delete` without `--backup-dir` (and\n   without `--delete-excluded`), we add a `protect` filter-rule to ensure that\n   files with the backup suffix are not deleted.\n\n - The file-count stats that are output by `--progress` were improved to better\n   indicate what the numbers mean. For instance, the output: `(xfer#5,\n   to-check=8383/9999)` indicates that this was the fifth file to be\n   transferred, and we still need to check 8383 more files out of a total of\n   9999.\n\n - The include/exclude code now allows a `dir/***` directive (with 3 trailing\n   stars) to match both the dir itself as well as all the content below the dir\n   (`dir/**` would not match the dir).\n\n - Added the `--prune-empty-dirs` (`-m`) option that makes the receiving rsync\n   discard empty chains of directories from the file-list. This makes it easier\n   to selectively copy files from a source hierarchy and end up with just the\n   directories needed to hold the resulting files.\n\n - If the `--itemize-changes` (`-i`) option is repeated, rsync now includes\n   unchanged files in the itemized output (similar to `-vv`, but without all\n   the other verbose messages that can get in the way). Of course, the client\n   must be version 2.6.7 for this to work, but the remote rsync only needs to\n   be 2.6.7 if you're pushing files.\n\n - Added the `--specials` option to tell rsync to copy non-device special files\n   (which rsync now attempts even as a normal user). The `--devices` option now\n   requests the copying of just devices (character and block).  The `-D` option\n   still requests both (e.g. `--devices` and `--specials`), `-a` still implies\n   `-D`, and non-root users still get a silent downgrade that omits device\n   copying.\n\n - Added the `--super` option to make the receiver always attempt super-user\n   activities. This is useful for systems that allow things such as devices to\n   be created or ownership to be set without being UID 0, and is also useful\n   for someone who wants to ensure that errors will be output if the receiving\n   rsync isn't being run as root.\n\n - Added the `--sockopts` option for those few who want to customize the TCP\n   options used to contact a daemon rsync.\n\n - Added a way for the `--temp-dir` option to be combined with a partial-dir\n   setting that lets rsync avoid non-atomic updates (for those times when\n   `--temp-dir` is not being used because space is tight).\n\n - A new support script, files-to-excludes, will transform a list of files into\n   a set of include/exclude directives that will copy those files.\n\n - A new option, `--executability` (`-E`) can be used to preserve just the\n   execute bit on files, for those times when using the `--perms` option is not\n   desired.\n\n - The daemon now logs each connection and also each module-list request that\n   it receives.\n\n - New log-format options: %M (modtime), %U (uid), %G (gid), and %B (permission\n   bits, e.g. `rwxr-xrwt`).\n\n - The `--dry-run` option no longer forces the enabling of `--verbose`.\n\n - The `--remove-sent-files` option now does a better job of incrementally\n   removing the sent files on the sending side (older versions tended to clump\n   up all the removals at the end).\n\n - A daemon now supersedes its minimal SIGCHLD handler with the standard\n   PID-remembering version after forking. This ensures that the generator can\n   get the child-exit status from the receiver.\n\n - Use of the `--bwlimit` option no longer interferes with the remote rsync\n   sending error messages about invalid/refused options.\n\n - Rsync no longer returns a usage error when used with one local source arg\n   and no destination: this now implies the `--list-only` option, just like the\n   comparable situation with a remote source arg.\n\n - Added the `--copy-dirlinks` option, a more limited version of\n   `--copy-links`.\n\n - Various documentation improvements, including: a better synopsis, some\n   improved examples, a better discussion of the presence and absence of\n   `--perms` (including how it interacts with the new `--executability` and\n   `--chmod` options), an extended discussion of `--temp-dir`, an improved\n   discussion of `--partial-dir`, a better description of rsync's pattern\n   matching characters, an improved `--no-implied-dirs` section, and the\n   documenting of what the `--stats` option outputs.\n\n - Various new and updated diffs in the patches dir, including: acls.diff,\n   xattrs.diff, atimes.diff, detect-renamed.diff, and slp.diff.\n\n### INTERNAL:\n\n - We now use sigaction() and sigprocmask() if possible, and fall back on\n   signal() if not. Using sigprocmask() ensures that rsync enables all the\n   signals that it needs, just in case it was started in a masked state.\n\n - Some buffer sizes were expanded a bit, particularly on systems where\n   MAXPATHLEN is overly small (e.g. Cygwin).\n\n - If `io_printf()` tries to format more data than fits in the buffer, exit\n   with an error instead of transmitting a truncated buffer.\n\n - If a `va_copy` macro is defined, lib/snprintf.c will use it when defining\n   the `VA_COPY` macro.\n\n - Reduced the amount of stack memory needed for each level of directory\n   recursion by nearly MAXPATHLEN bytes.\n\n - The wildmatch function was extended to allow an array of strings to be\n   supplied as the string to match. This allows the exclude code to do less\n   string copying.\n\n - Got rid of the `safe_fname()` function (and all the myriad calls) and\n   replaced it with a new function in the log.c code that filters all the\n   output going to the terminal.\n\n - Unified the `f_name()` and the `f_name_to()` functions.\n\n - Improved the hash-table code the sender uses to handle checksums to make it\n   use slightly less memory and run just a little faster.\n\n### DEVELOPER RELATED:\n\n - The diffs in the patches dir now require `patch -p1 <DIFF` instead of the\n   previous `-p0`. Also, the version included in the release tar now affect\n   generated files (e.g. configure, rsync.1, proto.h, etc.), so it is no longer\n   necessary to run autoconf and/or yodl unless you're applying a patch that\n   was checked out from CVS.\n\n - Several diffs in the patches dir now use the proper `--enable-FOO` configure\n   option instead of `--with-FOO` to turn on the inclusion of the newly patched\n   feature.\n\n - There is a new script, `prepare-source` than can be used to update the\n   various generated files (proto.h, configure, etc.) even before configure has\n   created the Makefile (this is mainly useful when patching the source with a\n   patch that doesn't affect generated files).\n\n - The testsuite now sets HOME so that it won't be affected by a file such as\n   ~/.popt.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.6 (28 Jul 2005)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - The zlib code was upgraded to version 1.2.3 in order to make it more secure.\n   While the widely-publicized security problem in zlib 1.2.2 did not affect\n   rsync, another security problem surfaced that affects rsync's zlib 1.1.4.\n\n### BUG FIXES:\n\n - The setting of `flist->high` in `clean_flist()` was wrong for an empty list.\n   This could cause `flist_find()` to crash in certain rare circumstances (e.g.\n   if just the right directory setup was around when `--fuzzy` was combined\n   with `--link-dest`).\n\n - The outputting of hard-linked files when verbosity was > 1 was not right:\n   (1) Without `-i` it would output the name of each hard-linked file as though\n   it had been changed; it now outputs a `is hard linked` message for the file.\n   (2) With `-i` it would output all dots for the unchanged attributes of a\n   hard-link; it now changes those dots to spaces, as is done for other totally\n   unchanged items.\n\n - When backing up a changed symlink or device, get rid of any old backup item\n   so that we don't get an `already exists` error.\n\n - A couple places that were comparing a local and a remote modification-time\n   were not honoring the `--modify-window` option.\n\n - Fixed a bug where the 'p' (permissions) itemized-changes flag might get set\n   too often (if some non-significant mode bits differed).\n\n - Fixed a really old, minor bug that could cause rsync to warn about being\n   unable to mkdir() a path that ends in `/.` because it just created the\n   directory (required `--relative`, `--no-implied-dirs`, a source path that\n   ended in either a trailing slash or a trailing `/.`, and a non-existing\n   destination dir to tickle the bug in a recent version).\n\n### ENHANCEMENTS:\n\n - Made the `max verbosity` setting in the rsyncd.conf file settable on a\n   per-module basis (which now matches the documentation).\n\n - The rrsync script has been upgraded to verify the args of options that take\n   args (instead of rejecting any such options). It was also changed to try to\n   be more secure and to fix a problem in the parsing of a pull operation that\n   has multiple source args. (See the support dir.)\n\n - Improved the documentation that explains the difference between a normal\n   daemon transfer and a daemon-over remote-shell transfer.\n\n - Some of the diffs supplied in the patches dir were fixed and/or improved.\n\n### BUILD CHANGES:\n\n - Made configure define `NOBODY_USER` (currently hard-wired to `nobody`) and\n   `NOBODY_GROUP` (set to either `nobody` or `nogroup` depending on what we\n   find in the /etc/group file).\n\n - Added a test to the test suite, itemized.test, that tests the output of `-i`\n   (log-format w/%i) and some double-verbose messages.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.5 (1 Jun 2005)\n\n## Changes in this version:\n\n### OUTPUT CHANGES:\n\n - Non-printable chars in filenames are now output using backslash-escaped\n   characters rather than '?'s. Any non-printable character is output using 3\n   digits of octal (e.g. `\\n` -> `\\012`), and a backslash is now output as\n   `\\\\`. Rsync also uses your locale setting, which can make it treat fewer\n   high-bit characters as non-printable.\n\n - If rsync received an empty file-list when pulling files, it would output a\n   `nothing to do` message and exit with a 0 (success) exit status, even if the\n   remote rsync returned an error (it did not do this under the same conditions\n   when pushing files). This was changed to make the pulling behavior the same\n   as the pushing behavior: we now do the normal end-of-run outputting\n   (depending on options) and exit with the appropriate exit status.\n\n### BUG FIXES:\n\n - A crash bug was fixed when a daemon had its `path` set to `/`, did not have\n   chroot enabled, and used some anchored excludes in the rsyncd.conf file.\n\n - Fixed a bug in the transfer of a single file when `-H` is specified (rsync\n   would either infinite loop or perhaps crash).\n\n - Fixed a case where the generator might try (and fail) to tweak the\n   write-permissions of a read-only directory in list-only mode (this only\n   caused an annoying warning message).\n\n - If `--compare-dest` or `--link-dest` uses a locally-copied file as the basis\n   for an updated version, log this better when `--verbose` or `-i` is in\n   effect.\n\n - Fixed the accidental disabling of `--backup` during the `--delete-after`\n   processing.\n\n - Restored the ability to use the `--address` option in client mode (in\n   addition to its use in daemon mode).\n\n - Make sure that some temporary progress information from the delete\n   processing does not get left on the screen when it is followed by a newline.\n\n - When `--existing` skips a directory with extra verbosity, refer to it as a\n   `directory`, not a `file`.\n\n - When transferring a single file to a different-named file, any generator\n   messages that are source-file related no longer refer to the file by the\n   destination filename.\n\n - Fixed a bug where hard-linking a group of files might fail if the generator\n   hasn't created a needed destination directory yet.\n\n - Fixed a bug where a hard-linked group of files that is newly-linked to a\n   file in a `--link-dest` dir doesn't link the files from the rest of the\n   cluster.\n\n - When deleting files with the `--one-file-system` (`-x`) option set, rsync no\n   longer tries to remove files from inside a mount-point on the receiving\n   side. Also, we don't complain about being unable to remove the mount-point\n   dir.\n\n - Fixed a compatibility problem when using `--cvs-ignore` (`-C`) and sending\n   files to an older rsync without using `--delete`.\n\n - Make sure that a `- !` or `+ !` include/exclude pattern does not trigger the\n   list-clearing action that is reserved for `!`.\n\n - Avoid a timeout in the generator when the sender/receiver aren't handling\n   the generator's checksum output quickly enough.\n\n - Fixed the omission of some directories in the delete processing when\n   `--relative` (`-R`) was combined with a source path that had a trailing\n   slash.\n\n - Fixed a case where rsync would erroneously delete some files and then\n   re-transfer them when the options `--relative` (`-R`) and `--recursive`\n   (`-r`) were both enabled (along with `--delete`) and a source path had a\n   trailing slash.\n\n - Make sure that `--max-size` doesn't affect a device or a symlink.\n\n - Make sure that a system with a really small MAXPATHLEN does not cause the\n   buffers in `readfd_unbuffered()` to be too small to receive normal messages.\n   (This mainly affected Cygwin.)\n\n - If a source pathname ends with a filename of `..`, treat it as if `../` had\n   been specified (so that we don't copy files to the parent dir of the\n   destination).\n\n - If `--delete` is combined with a file-listing rsync command (i.e. no\n   transfer is happening), avoid outputting a warning that we couldn't delete\n   anything.\n\n - If `--stats` is specified with `--delete-after`, ensure that all the\n   `deleting` messages are output before the statistics.\n\n - Improved one `if` in the deletion code that was only checking errno for\n   ENOTEMPTY when it should have also been checking for EEXIST (for\n   compatibility with OS variations).\n\n### ENHANCEMENTS:\n\n - Added the `--only-write-batch=FILE` option that may be used (instead of\n   `--write-batch=FILE`) to create a batch file without doing any actual\n   updating of the destination. This allows you to divert all the file-updating\n   data away from a slow data link (as long as you are pushing the data to the\n   remote server when creating the batch).\n\n - When the generator is taking a long time to fill up its output buffer (e.g.\n   if the transferred files are few, small, or missing), it now periodically\n   flushes the output buffer so that the sender/receiver can get started on the\n   files sooner rather than later.\n\n - Improved the keep-alive code to handle a long silence between the sender and\n   the receiver that can occur when the sender is receiving the checksum data\n   for a large file.\n\n - Improved the auth-errors that are logged by the daemon to include some\n   information on why the authorization failed: wrong user, password mismatch,\n   etc. (The client-visible message is unchanged!)\n\n - Improved the client's handling of an `@ERROR` from a daemon so that it does\n   not complain about an unexpectedly closed socket (since we really did expect\n   the socket to close).\n\n - If the daemon can't open the log-file specified in rsyncd.conf, fall back to\n   using syslog and log an appropriate warning. This is better than what was\n   typically a totally silent (and fatal) failure (since a daemon is not\n   usually run with the `--no-detach` option that was necessary to see the\n   error on stderr).\n\n - The manpages now consistently refer to an rsync daemon as a `daemon`\n   instead of a `server` (to distinguish it from the server process in a\n   non-daemon transfer).\n\n - Made a small change to the rrsync script (restricted rsync -- in the support\n   dir) to make a read-only server reject all `--remove-*` options when sending\n   files (to future-proof it against the possibility of other similar options\n   being added at some point).\n\n### INTERNAL:\n\n - Rsync now calls `setlocale(LC_CTYPE, \"\")`. This enables isprint() to better\n   discern which filename characters need to be escaped in messages (which\n   should result in fewer escaped characters in some locales).\n\n - Improved the naming of the log-file open/reopen/close functions.\n\n - Removed some protocol-compatibility code that was only needed to help\n   someone running a pre-release of 2.6.4.\n\n### BUILD CHANGES:\n\n - Added configure option `--disable-locale` to disable any use of setlocale()\n   in the binary.\n\n - Fixed a bug in the `SUPPORT{,_HARD}_LINKS` #defines which prevented rsync\n   from being built without symlink or hard-link support.\n\n - Only #define `HAVE_REMSH` if it is going to be set to 1.\n\n - Configure now disables the use of mkstemp() under HP-UX (since they refuse\n   to fix its broken handling of large files).\n\n - Configure now explicitly checks for the lseek64() function so that the code\n   can use `HAVE_LSEEK64` instead of inferring lseek64()'s presence based on\n   the presence of the `off64_t` type.\n\n - Configure no longer mentions the change in the default remote-shell (from\n   rsh to ssh) that occurred for the 2.6.0 release.\n\n - Some minor enhancements to the test scripts.\n\n - Added a few new `*.diff` files to the patches dir, including a patch that\n   enables the optional copying of extended attributes.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.4 (30 March 2005)\n\n## Changes in this version:\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 29.\n\n### OUTPUT CHANGES:\n\n - When rsync deletes a directory and outputs a verbose message about it, it\n   now appends a trailing slash to the name instead of (only sometimes)\n   outputting a preceding \"directory \" string.\n\n - The `--stats` output will contain file-list time-statistics if both sides\n   are 2.6.4, or if the local side is 2.6.4 and the files are being pushed\n   (since the stats come from the sending side).  (Requires protocol 29 for a\n   pull.)\n\n - The `%o` (operation) log-format escape now has a third value (besides `send`\n   and `recv`): `del.` (with trailing dot to make it 4 chars).  This changes\n   the way deletions are logged in the daemon's log file.\n\n - When the `--log-format` option is combined with `--verbose`, rsync now\n   avoids outputting the name of the file twice in most circumstances.  As long\n   as the `--log-format` item does not refer to any post-transfer items (such\n   as %b or %c), the `--log-format` message is output prior to the transfer, so\n   `--verbose` is now the equivalent of a `--log-format` of '%n%L' (which\n   outputs the name and any link info). If the log output must occur after the\n   transfer to be complete, the only time the name is also output prior to the\n   transfer is when `--progress` was specified (so that the name will precede\n   the progress stats, and the full `--log-format` output will come after).\n\n - Non-printable characters in filenames are replaced with a '?' to avoid\n   corrupting the screen or generating empty lines in the output.\n\n### BUG FIXES:\n\n - Restore the list-clearing behavior of `!` in a .cvsignore file (2.6.3 was\n   only treating it as a special token in an rsync include/exclude file).\n\n - The combination of `--verbose` and `--dry-run` now mentions the full list of\n   changes that would be output without `--dry-run`.\n\n - Avoid a mkdir warning when removing a directory in the destination that\n   already exists in the `--backup-dir`.\n\n - An OS that has a binary mode for its files (such as Cygwin) needed\n   `setmode(fd, O_BINARY)` called on the temp-file we opened with mkstemp().\n   (Fix derived from Cygwin's 2.6.3 rsync package.)\n\n - Fixed a potential hang when verbosity is high, the client side is the\n   sender, and the file-list is large.\n\n - Fixed a potential protocol-corrupting bug where the generator could merge a\n   message from the receiver into the middle of a multiplexed packet of data if\n   only part of that data had been written out to the socket when the message\n   from the generator arrived.\n\n - We now check if the OS doesn't support using mknod() for creating FIFOs and\n   sockets, and compile-in some compatibility code using mkfifo() and socket()\n   when necessary.\n\n - Fixed an off-by-one error in the handling of `--max-delete=N`. Also, if the\n   `--max-delete` limit is exceeded during a run, we now output a warning about\n   this at the end of the run and exit with a new error code (25).\n\n - One place in the code wasn't checking if fork() failed.\n\n - The `ignore nonreadable` daemon parameter used to erroneously affect\n   readable symlinks that pointed to a non-existent file.\n\n - If the OS does not have lchown() and a chown() of a symlink will affect the\n   referent of a symlink (as it should), we no longer try to set the user and\n   group of a symlink.\n\n - The generator now properly runs the hard-link loop and the dir-time\n   rewriting loop after we're sure that the redo phase is complete.\n\n - When `--backup` was specified with `--partial-dir=DIR`, where DIR is a\n   relative path, the backup code was erroneously trying to backup a file that\n   was put into the partial-dir.\n\n - If a file gets resent in a single transfer and the `--backup` option is\n   enabled along with `--inplace`, rsync no longer performs a duplicate backup\n   (it used to overwrite the first backup with the failed file).\n\n - One call to `flush_write_file()` was not being checked for an error.\n\n - The `--no-relative` option was not being sent from the client to a server\n   sender.\n\n - If an rsync daemon specified `dont compress = ...` for a file and the client\n   tried to specify `--compress`, the libz code was not handling a compression\n   level of 0 properly. This could cause a transfer failure if the block-size\n   for a file was large enough (e.g. rsync might have exited with an error for\n   large files).\n\n - Fixed a bug that would sometimes surface when using `--compress` and sending\n   a file with a block-size larger than 64K (either manually specified, or\n   computed due to the file being really large). Prior versions of rsync would\n   sometimes fail to decompress the data properly, and thus the transferred\n   file would fail its verification.\n\n - If a daemon can't open the specified log file (i.e. syslog is not being\n   used), die without crashing. We also output an error about the failure on\n   stderr (which will only be seen if `--no-detach` was specified) and exit\n   with a new error code (6).\n\n - A local transfer no longer duplicates all its include/exclude options (since\n   the forked process already has a copy of the exclude list, there's no need\n   to send them a set of duplicates).\n\n - The output of the items that are being updated by the generator (dirs,\n   symlinks, devices) is now intermingled in the proper order with the output\n   from the items that the receiver is updating (regular files) when pulling.\n   This misordering was particularly bad when `--progress` was specified.\n   (Requires protocol 29.)\n\n - When `--timeout` is specified, lulls that occur in the transfer while the\n   generator is doing work that does not generate socket traffic (looking for\n   changed files, deleting files, doing directory-time touch-ups, etc.) will\n   cause a new keep-alive packet to be sent that should keep the transfer going\n   as long as the generator continues to make progress. (Requires protocol 29.)\n\n - The stat size of a device is not added to the total file size of the items\n   in the transfer (the size might be undefined on some OSes).\n\n - Fixed a problem with refused-option messages sometimes not making it back to\n   the client side when a remote `--files-from` was in effect and the daemon\n   was the receiver.\n\n - The `--compare-dest` option was not updating a file that differed in (the\n   preserved) attributes from the version in the compare-dest DIR.\n\n - When rsync is copying files into a write-protected directory, fixed the\n   change-report output for the directory so that we don't report an identical\n   directory as changed.\n\n### ENHANCEMENTS:\n\n - Rsync now supports popt's option aliases, which means that you can use\n   /etc/popt and/or ~/.popt to create your own option aliases.\n\n - Added the `--delete-during` (`--del`) option which will delete files from\n   the receiving side incrementally as each directory in the transfer is being\n   processed. This makes it more efficient than the default,\n   before-the-transfer behavior, which is now also available as\n   `--delete-before` (and is still the default `--delete-WHEN` option that will\n   be chosen if `--delete` or `--delete-excluded` is specified without a\n   `--delete-WHEN` choice). All the `--del*` options infer `--delete`, so an\n   rsync daemon that refuses `delete` will still refuse to allow any\n   file-deleting options (including the new `--remove-sent-files` option).\n\n - All the `--delete-WHEN` options are now more memory efficient: Previously an\n   duplicate set of file-list objects was created on the receiving side for the\n   entire destination hierarchy. The new algorithm only creates one directory\n   of objects at a time (for files inside the transfer).\n\n - Added the `--copy-dest` option, which works like `--link-dest` except that\n   it locally copies identical files instead of hard-linking them.\n\n - Added support for specifying multiple `--compare-dest`, `--copy-dest`, or\n   `--link-dest` options, but only of a single type. (Promoted from the patches\n   dir and enhanced.) (Requires protocol 29.)\n\n - Added the `--max-size` option. (Promoted from the patches dir.)\n\n - The daemon-mode options are now separated from the normal rsync options so\n   that they can't be mixed together. This makes it impossible to start a\n   daemon that has improper default option values (which could cause problems\n   when a client connects, such as hanging or crashing).\n\n - The `--bwlimit` option may now be used in combination with `--daemon` to\n   specify both a default value for the daemon side and a value that cannot be\n   exceeded by a user-specified `--bwlimit` option.\n\n - Added the `port` parameter to the rsyncd.conf file. (Promoted from the\n   patches dir.) Also added `address`. The command-line options take precedence\n   over a config-file option, as expected.\n\n - In `_exit_cleanup()`: when we are exiting with a partially-received file, we\n   now flush any data in the write-cache before closing the partial file.\n\n - The `--inplace` support was enhanced to work with `--compare-dest`,\n   `--link-dest`, and (the new) `--copy-dest` options. (Requires protocol 29.)\n\n - Added the `--dirs` (`-d`) option for an easier way to copy directories\n   without recursion. Any directories that are encountered are created on the\n   destination. Specifying a directory with a trailing slash copies its\n   immediate contents to the destination.\n\n - The `--files-from` option now implies `--dirs` (`-d`).\n\n - Added the `--list-only` option, which is mainly a way for the client to put\n   the server into listing mode without needing to resort to any internal\n   option kluges (e.g. the age-old use of `-r --exclude='/*/*'` for a\n   non-recursive listing). This option is used automatically (behind the\n   scenes) when a modern rsync speaks to a modern daemon, but may also be\n   specified manually if you want to force the use of the `--list-only` option\n   over a remote-shell connection.\n\n - Added the `--omit-dir-times` (`-O`) option, which will avoid updating the\n   modified time for directories when `--times` was specified. This option will\n   avoid an extra pass through the file-list at the end of the transfer (to\n   tweak all the directory times), which may provide an appreciable speedup for\n   a really large transfer. (Promoted from the patches dir.)\n\n - Added the `--filter` (`-f`) option and its helper option, `-F`. Filter rules\n   are an extension to the existing include/exclude handling that also supports\n   nested filter files as well as per-directory filter files (like .cvsignore,\n   but with full filter-rule parsing).  This new option was chosen in order to\n   ensure that all existing include/exclude processing remained 100% compatible\n   with older versions. Protocol 29 is needed for full filter-rule support, but\n   backward-compatible rules work with earlier protocol versions.  (Promoted\n   from the patches dir and enhanced.)\n\n - Added the `--delay-updates` option that puts all updated files into a\n   temporary directory (by default `.~tmp~`, but settable via the\n   `--partial-dir=DIR` option) until the end of the transfer. This makes the\n   updates a little more atomic for a large transfer.\n\n - If rsync is put into the background, any output from `--progress` is\n   reduced.\n\n - Documented the `max verbosity` setting for rsyncd.conf. (This setting was\n   added a couple releases ago, but left undocumented.)\n\n - The sender and the generator now double-check the file-list index they are\n   given, and refuse to try to do a file transfer on a non-file index (since\n   that would indicate that something had gone very wrong).\n\n - Added the `--itemize-changes` (`-i`) option, which is a way to output a more\n   detailed list of what files changed and in what way. The effect is the same\n   as specifying a `--log-format` of `%i %n%L` (see both the rsync and\n   rsyncd.conf manpages). Works with `--dry-run` too.\n\n - Added the `--fuzzy` (`-y`) option, which attempts to find a basis file for a\n   file that is being created from scratch. The current algorithm only looks in\n   the destination directory for the created file, but it does attempt to find\n   a match based on size/mod-time (in case the file was renamed with no other\n   changes) as well as based on a fuzzy name-matching algorithm. This option\n   requires protocol 29 because it needs the new file-sorting order. (Promoted\n   from patches dir and enhanced.) (Requires protocol 29.)\n\n - Added the `--remove-sent-files` option, which lets you move files between\n   systems.\n\n - The hostname in HOST:PATH or HOST::PATH may now be an IPv6 literal enclosed\n   in '[' and ']' (e.g. `[::1]`). (We already allowed IPv6 literals in the\n   rsync://HOST:PORT/PATH format.)\n\n - When rsync recurses to build the file list, it no longer keeps open one or\n   more directory handles from the dir's parent dirs.\n\n - When building under windows, the default for `--daemon` is now to avoid\n   detaching, requiring the new `--detach` option to force rsync to detach.\n\n - The `--dry-run` option can now be combined with either `--write-batch` or\n   `--read-batch`, allowing you to run a do-nothing test command to see what\n   would happen without `--dry-run`.\n\n - The daemon's `read only` config item now sets an internal `read_only`\n   variable that makes extra sure that no write/delete calls on the read-only\n   side can succeed.\n\n - The log-format % escapes can now have a numeric field width in between the %\n   and the escape letter (e.g. `%-40n %08p`).\n\n - Improved the option descriptions in the `--help` text.\n\n### SUPPORT FILES:\n\n - Added atomic-rsync to the support dir: a perl script that will transfer some\n   files using rsync, and then move the updated files into place all at once at\n   the end of the transfer. Only works when pulling, and uses `--link-dest` and\n   a parallel hierarchy of files to effect its update.\n\n - Added mnt-excl to the support dir: a perl script that takes the /proc/mounts\n   file and translates it into a set of excludes that will exclude all mount\n   points (even mapped mounts to the same disk). The excludes are made relative\n   to the specified source dir and properly anchored.\n\n - Added savetransfer.c to the support dir: a C program that can make a copy of\n   all the data that flows over the wire. This lets you test for data\n   corruption (by saving the data on both the sending side and the receiving\n   side) and provides one way to debug a protocol error.\n\n - Added rrsync to the support dir: this is an updated version of Joe Smith's\n   restricted rsync perl script. This helps to ensure that only certain rsync\n   commands can be run by an ssh invocation.\n\n### INTERNAL:\n\n - Added better checking of the checksum-header values that come over the\n   socket.\n\n - Merged a variety of file-deleting functions into a single function so that\n   it is easier to maintain.\n\n - Improved the type of some variables (particularly blocksize vars) for\n   consistency and proper size.\n\n - Got rid of the uint64 type (which we didn't need).\n\n - Use a slightly more compatible set of core #include directives.\n\n - Defined int32 in a way that ensures that the build dies if we can't find a\n   variable with at least 32 bits.\n\n### PROTOCOL DIFFERENCES FOR VERSION 29:\n\n - A 16-bit flag-word is transmitted after every file-list index. This\n   indicates what is changing between the sender and the receiver. The\n   generator now transmits an index and a flag-word to indicate when dirs and\n   symlinks have changed (instead of producing a message), which makes the\n   outputting of the information more consistent and less prone to screen\n   corruption (because the local receiver/sender is now outputting all the\n   file-change info messages).\n\n - If a file is being hard-linked, the `ITEM_XNAME_FOLLOWS` bit is enabled in\n   the flag-word and the name of the file that was linked immediately follows\n   in vstring format (see below).\n\n - If a file is being transferred with an alternate-basis file, the\n   `ITEM_BASIS_TYPE_FOLLOWS` bit is enabled in the flag-word and a single byte\n   follows, indicating what type of basis file was chosen. If that indicates\n   that a fuzzy-match was selected, the `ITEM_XNAME_FOLLOWS` bit is set in the\n   flag-word and the name of the match in vstring format follows the basis\n   byte. A vstring is a variable length string that has its size written prior\n   to the string, and no terminating null.  If the string is from 1-127 bytes,\n   the length is a single byte. If it is from 128-32767 bytes, the length is\n   written as ((len >> 8) | 0x80) followed by (len % 0x100).\n\n - The sending of exclude names is done using filter-rule syntax. This means\n   that all names have a prefixed rule indicator, even excludes (which used to\n   be sent as a bare pattern, when possible). The `-C` option will include the\n   per-dir .cvsignore merge file in the list of filter rules so it is\n   positioned correctly (unlike in some older transfer scenarios).\n\n - Rsync sorts the filename list in a different way: it sorts the subdir names\n   after the non-subdir names for each dir's contents, and it always puts a\n   dir's contents immediately after the dir's name in the list. (Previously an\n   item named `foo.txt` would sort in between directory `foo/` and `foo/bar`.)\n\n - When talking to a protocol 29 rsync daemon, a list-only request is able to\n   note this before the options are sent over the wire and the new\n   `--list-only` option is included in the options.\n\n - When the `--stats` bytes are sent over the wire (or stored in a batch), they\n   now include two elapsed-time values: one for how long it took to build the\n   file-list, and one for how long it took to send it over the wire (each\n   expressed in thousandths of a second).\n\n - When `--delete-excluded` is specified with some filter rules (AKA excludes),\n   a client sender will now initiate a send of the rules to the receiver (older\n   protocols used to omit the sending of excludes in this situation since there\n   were no receiver-specific rules that survived `--delete-excluded` back\n   then). Note that, as with all the filter-list sending, only items that are\n   significant to the other side will actually be sent over the wire, so the\n   filter-rule list that is sent in this scenario is often empty.\n\n - An index equal to the file-list count is sent as a keep-alive packet from\n   the generator to the sender, which then forwards it on to the receiver. This\n   normally invalid index is only a valid keep-alive packet if the 16-bit\n   flag-word that follows it contains a single bit (`ITEM_IS_NEW`, which is\n   normally an illegal flag to appear alone).\n\n - A protocol-29 batch file includes a bit for the setting of the `--dirs`\n   option and for the setting of the `--compress` option. Also, the shell\n   script created by `--write-batch` will use the `--filter` option instead of\n   `--exclude-from` to capture any filter rules.\n\n### BUILD CHANGES:\n\n - Handle an operating system that use mkdev() in place of makedev().\n\n - Improved configure to better handle cross-compiling.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.3 (30 Sep 2004)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - A bug in the `sanitize_path` routine (which affects a non-chrooted rsync\n   daemon) could allow a user to craft a pathname that would get transformed\n   into an absolute path for certain options (but not for file-transfer names).\n   If you're running an rsync daemon with chroot disabled, **please upgrade**,\n   ESPECIALLY if the user privs you run rsync under is anything above `nobody`.\n\n   OUTPUT CHANGES (ATTN: those using a script to parse the verbose output):\n\n - Please note that the 2-line footer (output when verbose) now uses the term\n   `sent` instead of `wrote` and `received` instead of `read`. If you are not\n   parsing the numeric values out of this footer, a script would be better off\n   using the empty line prior to the footer as the indicator that the verbose\n   output is over.\n\n - The output from the `--stats` option was similarly affected to change\n   `written` to `sent` and `read` to `received`.\n\n - Rsync ensures that a filename that contains a newline gets mentioned with\n   each newline transformed into a question mark (which prevents a filename\n   from causing an empty line to be output).\n\n - The `backed up ...` message that is output when at least 2 `--verbose`\n   options are specified is now the same both with and without the\n   `--backup-dir` option.\n\n### BUG FIXES:\n\n - Fixed a crash bug that might appear when `--delete` was used and multiple\n   source directories were specified.\n\n - Fixed a 32-bit truncation of the file length when generating the checksums.\n\n - The `--backup` code no longer attempts to create some directories over and\n   over again (generating warnings along the way).\n\n - Fixed a bug in the reading of the secrets file (by the daemon) and the\n   password file (by the client): the files no longer need to be terminated by\n   a newline for their content to be read in.\n\n - If a file has a read error on the sending side or the reconstructed data\n   doesn't match the expected checksum (perhaps due to the basis file changing\n   during the transfer), the receiver will no longer retain the resulting file\n   unless the `--partial` option was specified.  (Note: for the read-error\n   detection to work, neither side can be older than 2.6.3 -- older receivers\n   will always retain the file, and older senders don't tell the receiver that\n   the file had a read error.)\n\n - If a file gets resent in a single transfer and the `--backup` option is\n   enabled, rsync no longer performs a duplicate backup (it used to overwrite\n   the original file in the backup area).\n\n - Files specified in the daemon's `exclude` or `exclude from` config items are\n   now excluded from being uploaded (assuming that the module allows uploading\n   at all) in addition to the old download exclusion.\n\n - Got rid of a potential hang in the receiver when near the end of a phase.\n\n - When using `--backup` without a `--backup-dir`, rsync no longer preserves\n   the modify time on directories. This avoids confusing NFS.\n\n - When `--copy-links` (`-L`) is specified, we now output a separate error for\n   a symlink that has no referent instead of claiming that a file `vanished`.\n\n - The `--copy-links` (`-L`) option no longer has the side-effect of telling\n   the receiving side to follow symlinks. See the `--keep-dirlinks` option\n   (mentioned below) for a way to specify that behavior.\n\n - Error messages from the daemon server's option-parsing (such as refused\n   options) are now successfully transferred back to the client (the server\n   used to fail to send the message because the socket wasn't in the right\n   state for the message to get through).\n\n - Most transfer errors that occur during a daemon transfer are now returned to\n   the user in addition to being logged (some messages are intended to be\n   daemon-only and are not affected by this).\n\n - Fixed a bug in the daemon authentication code when using one of the\n   batch-processing options.\n\n - We try to work around some buggy IPv6 implementations that fail to implement\n   `IPV6_V6ONLY`. This should fix the `address in use` error that some daemons\n   get when running on an OS with a buggy IPv6 implementation. Also, if the new\n   code gets this error, we might suggest that the user specify `--ipv4` or\n   `--ipv6` (if we think it will help).\n\n - When the remote rsync dies, make a better effort to recover any error\n   messages it may have sent before dying (the local rsync used to just die\n   with a socket-write error).\n\n - When using `--delete` and a `--backup-dir` that contains files that are\n   hard-linked to their destination equivalents, rsync now makes sure that\n   removed files really get removed (avoids a really weird rename() behavior).\n\n - Avoid a bogus run-time complaint about a lack of 64-bit integers when the\n   int64 type is defined as an `off_t` and it actually has 64-bits.\n\n - Added a configure check for open64() without mkstemp64() so that we can\n   avoid using mkstemp() when such a combination is encountered.  This bypasses\n   a problem writing out large temp files on OSes such as AIX and HP-UX.\n\n - Fixed an age-old crash problem with `--read-batch` on a local copy (rsync\n   was improperly assuming `--whole-file` for the local copy).\n\n - When `--dry-run` (`-n`) is used and the destination directory does not\n   exist, rsync now produces a correct report of files that would be sent\n   instead of dying with a chdir() error.\n\n - Fixed a bug that could cause a slow-to-connect rsync daemon to die with an\n   error instead of waiting for the connection to finish.\n\n - Fixed an ssh interaction that could cause output to be lost when the user\n   chose to combine the output of rsync's stdout and stderr (e.g.  using the\n   `2>&1`).\n\n - Fixed an option-parsing bug when `--files-from` got passed to a daemon.\n\n### ENHANCEMENTS:\n\n - Added the `--partial-dir=DIR` option that lets you specify where to\n   (temporarily) put a partially transferred file (instead of overwriting the\n   destination file). E.g. `--partial-dir=.rsync-partial` Also added support\n   for the `RSYNC_PARTIAL_DIR` environment variable that, when found,\n   transforms a regular `--partial` option (such as the convenient `-P` option)\n   into one that also specifies a directory.\n\n - Added `--keep-dirlinks` (`-K`), which allows you to symlink a directory onto\n   another partition on the receiving side and have rsync treat it as matching\n   a normal directory from the sender.\n\n - Added the `--inplace` option that tells rsync to write each destination file\n   without using a temporary file. The matching of existing data in the\n   destination file can be severely limited by this, but there are also cases\n   where this is more efficient (such as appending data).  Use only when needed\n   (see the manpage for more details).\n\n - Added the `write only` option for the daemon's config file.\n\n - Added long-option names for `-4` and `-6` (namely `--ipv4` and `--ipv6`) and\n   documented all these options in the manpage.\n\n - Improved the handling of the `--bwlimit` option so that it's less bursty,\n   more accurate, and works properly over a larger range of values.\n\n - The rsync daemon-over-ssh code now looks for `SSH_CONNECTION` and\n   `SSH2_CLIENT` in addition to `SSH_CLIENT` to figure out the IP address.\n\n - Added the `--checksum-seed=N` option for advanced users.\n\n - Batch writing/reading has a brand-new implementation that is simpler, fixes\n   a few weird problems with the old code (such as no longer sprinkling the\n   batch files into different dirs or even onto different systems), and is much\n   less intrusive into the code (making it easier to maintain for the future).\n   The new code generates just one data file instead of three, which makes it\n   possible to read the batch on stdin via a remote shell. Also, the old\n   requirement of forcing the same fixed checksum-seed for all batch processing\n   has been removed.\n\n - If an rsync daemon has a module set with `list = no` (which hides its\n   presence in the list of available modules), a user that fails to\n   authenticate gets the same `unknown module` error that they would get if the\n   module were actually unknown (while still logging the real error to the\n   daemon's log file). This prevents fishing for module names.\n\n - The daemon's `refuse options` config item now allows you to match option\n   names using wildcards and/or the single-letter option names.\n\n - Each transferred file now gets its permissions and modified-time updated\n   before the temp-file gets moved into place. Previously, the finished file\n   would have a very brief window where its permissions disallowed all group\n   and world access.\n\n - Added the ability to parse a literal IPv6 address in an `rsync:` URL (e.g.\n   rsync://[2001:638:500:101::21]:873/module/dir).\n\n - The daemon's wildcard expanding code can now handle more than 1000 filenames\n   (it's now limited by memory instead of having a hard-wired limit).\n\n### INTERNAL:\n\n - Some cleanup in the exclude code has saved some per-exclude memory and made\n   the code easier to maintain.\n\n - Improved the argv-overflow checking for a remote command that has a lot of\n   args.\n\n - Use rsyserr() in the various places that were still calling rprintf() with\n   strerror() as an arg.\n\n - If an rsync daemon is listening on multiple sockets (to handle both IPv4 and\n   IPv6 to a single port), we now close all the unneeded file handles after we\n   accept a connection (we used to close just one of them).\n\n - Optimized the handling of larger block sizes (rsync used to slow to a crawl\n   if the block size got too large).\n\n - Optimized away a loop in `hash_search()`.\n\n - Some improvements to the `sanitize_path()` and `clean_fname()` functions\n   makes them more efficient and produce better results (while still being\n   compatible with the file-name cleaning that gets done on both sides when\n   sending the file-list).\n\n - Got rid of `alloc_sanitize_path()` after adding a destination-buffer arg to\n   `sanitize_path()` made it possible to put all the former's functionality\n   into the latter.\n\n - The file-list that is output when at least 4 verbose options are specified\n   reports the uid value on the sender even when rsync is not running as root\n   (since we might be sending to a root receiver).\n\n### BUILD CHANGES:\n\n - Added a `gen` target to rebuild most of the generated files, including\n   configure, config.h.in, the manpages, and proto.h.\n\n - If `make proto` doesn't find some changes in the prototypes, the proto.h\n   file is left untouched (its time-stamp used to always be updated).\n\n - The variable `$STRIP` (that is optionally set by the install-strip target's\n   rule) was changed to `$INSTALL_STRIP` because some systems have `$STRIP`\n   already set in the environment.\n\n - Fixed a build problem when `SUPPORT_HARD_LINKS` isn't defined.\n\n - When cross-compiling, the gettimeofday() function is now assumed to be a\n   modern version that takes two-args (since we can't test it).\n\n### DEVELOPER RELATED:\n\n - The scripts in the testsuite dir were cleaned up a bit and a few new tests\n   added.\n\n - Some new diffs were added to the patches dir, and some accepted ones were\n   removed.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.2 (30 Apr 2004)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fixed a major bug in the sorting of the filenames when `--relative` is used\n   for some sources (just sources such as `/` and `/*` were affected). This fix\n   ensures that we ask for the right file-list item when requesting changes\n   from the sender.\n\n - Rsync now checks the return value of the close() function to better report\n   disk-full problems on an NFS file system.\n\n - Restored the old daemon-server behavior of logging error messages rather\n   than returning them to the user. (A better long-term fix will be sought in\n   the future.)\n\n - An obscure uninitialized-variable bug was fixed in the uid/gid code. (This\n   bug probably had no ill effects.)\n\n### BUILD CHANGES:\n\n - Got rid of the configure check for sys/sysctl.h (it wasn't used and was\n   causing a problem on some systems). Also improved the\n   broken-largefile-locking test to try to avoid failure due to an NFS\n   build-dir.\n\n - Fixed a compile problem on systems that don't define `AI_NUMERICHOST`.\n\n - Fixed a compile problem in the popt source for compilers that don't support\n   `__attribute__`.\n\n### DEVELOPER RELATED:\n\n - Improved the testsuite's `merge` test to work on OSF1.\n\n - Two new diffs were added to the patches dir.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.1 (26 Apr 2004)\n\n## Changes in this version:\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 28.\n\n### SECURITY FIXES:\n\n - Paths sent to an rsync daemon are more thoroughly sanitized when chroot is\n   not used. If you're running a non-read-only rsync daemon with chroot\n   disabled, **please upgrade**, ESPECIALLY if the user privs you run rsync\n   under is anything above `nobody`.\n\n### ENHANCEMENTS:\n\n - Lower memory use, more optimal transfer of data over the socket, and lower\n   CPU usage (see the INTERNAL section for details).\n\n - The `RSYNC_PROXY` environment variable can now contain a `USER:PASS@` prefix\n   before the `HOST:PORT` information.  (Bardur Arantsson)\n\n - The `--progress` output now mentions how far along in the transfer we are,\n   including both a count of files transferred and a percentage of the total\n   file-count that we've processed. It also shows better\n   current-rate-of-transfer and remaining-transfer-time values.\n\n - Documentation changes now attempt to describe some often misunderstood\n   features more clearly.\n\n### BUG FIXES:\n\n - When `-x` (`--one-file-system`) is combined with `-L` (`--copy-links`) or\n   `--copy-unsafe-links,` no symlinked files are skipped, even if the referent\n   file is on a different filesystem.\n\n - The `--link-dest` code now works properly for a non-root user when (1) the\n   UIDs of the source and destination differ and `-o` was specified, or (2)\n   when the group of the source can't be used on the destination and `-g` was\n   specified.\n\n - Fixed a bug in the handling of `-H` (hard-links) that might cause the\n   expanded PATH/NAME value of the current item to get overwritten (due to an\n   expanded-name caching bug).\n\n - We now reset the `new data has been sent` flag at the start of each file we\n   send. This makes sure that an interrupted transfer with the `--partial`\n   option set doesn't keep a shorter temp file than the current basis file when\n   no new data has been transferred over the wire for that file.\n\n - Fixed a byte-order problem in `--batch-mode` on big-endian machines.  (Jay\n   Fenlason)\n\n - When using `--cvs-exclude`, the exclude items we get from a per-directory's\n   .cvsignore file once again only affect that one directory (not all following\n   directories too). The items are also now properly word-split and parsed\n   without any +/- prefix parsing.\n\n - When specifying the USER@HOST: prefix for a file, the USER part can now\n   contain an '@', if needed (i.e. the last '@' is used to find the HOST, not\n   the first).\n\n - Fixed some bugs in the handling of group IDs for non-root users: (1) It\n   properly handles a group that the sender didn't have a name for (it would\n   previously skip changing the group on any files in that group). (2) If\n   `--numeric-ids` is used, rsync no longer attempts to set groups that the\n   user doesn't have the permission to set.\n\n - Fixed the `refuse options` setting in the rsyncd.conf file.\n\n - Improved the `-x` (`--one-file-system`) flag's handling of any mount-point\n   directories we encounter. It is both more optimal (in that it no longer does\n   a useless scan of the contents of the mount-point dirs) and also fixes a\n   bug where a remapped mount of the original filesystem could get discovered\n   in a subdir we should be ignoring.\n\n - Rsync no longer discards a double-slash at the start of a filename when\n   trying to open the file. It also no longer constructs names that start with\n   a double slash (unless the user supplied them).\n\n - Path-specifying options to a daemon should now work the same with or without\n   chroot turned on. Previously, such a option (such as `--link-dest`) would\n   get its absolute path munged into a relative one if chroot was not on,\n   making that setting fairly useless.  Rsync now transforms the path into one\n   that is based on the module's base dir when chroot is not enabled.\n\n - Fixed a compatibility problem interacting with older rsync versions that\n   might send us an empty `--suffix` value without telling us that\n   `--backup-dir` was specified.\n\n - The `hosts allow` option for a daemon-over-remote-shell process now has\n   improved support for IPv6 addresses and a fix for systems that have a length\n   field in their socket structs.\n\n - Fixed the ability to request an empty backup `--suffix` when sending files\n   to an rsync daemon.\n\n - Fixed an option-parsing bug when `--files-from` was sent to a server sender.\n\n### INTERNAL:\n\n - Most of the I/O is now buffered, which results in a pretty large speedup\n   when running under MS Windows. (Craig Barratt)\n\n - Optimizations to the name-handling/comparing code have made some significant\n   reductions in user-CPU time for large file sets.\n\n - Some cleanup of the variable types make the code more consistent.\n\n - Reduced memory requirements of hard link preservation.  (J.W. Schultz)\n\n - Implemented a new algorithm for hard-link handling that speeds up the code\n   significantly. (J.W. Schultz and Wayne Davison)\n\n - The `--hard-link` option now uses the first existing file in the group of\n   linked files as the basis for the transfer. This prevents the sub-optimal\n   transfer of a file's data when a new hardlink is added on the sending side\n   and it sorts alphabetically earlier in the list than the files that are\n   already present on the receiving side.\n\n - Dropped support for protocol versions less than 20 (2.3.0 released 15 Mar\n   1999) and activated warnings for protocols less than 25 (2.5.0 released 23\n   Aug 2001). (Wayne Davison and J.W. Schultz, severally)\n\n - More optimal data transmission for `--hard-links` (protocol 28).\n\n - More optimal data transmission for `--checksum` (protocol 28).\n\n - Less memory is used when `--checksum` is specified.\n\n - Less memory is used in the file list (a per-file savings).\n\n - The generator is now better about not modifying the file list during the\n   transfer in order to avoid a copy-on-write memory bifurcation (on systems\n   where fork() uses shared memory).  Previously, rsync's shared memory would\n   slowly become unshared, resulting in real memory usage nearly doubling on\n   the receiving side by the end of the transfer. Now, as long as permissions\n   are being preserved, the shared memory should remain that way for the entire\n   transfer.\n\n - Changed hardlink info and `file_struct` + strings to use allocation pools.\n   This reduces memory use for large file-sets and permits freeing memory to\n   the OS. (J.W. Schultz)\n\n - The 2 pipes used between the receiver and generator processes (which are\n   forked on the same machine) were reduced to 1 pipe and the protocol improved\n   so that (1) it is now impossible to have the `redo` pipe fill up and hang\n   rsync, and (2) trailing messages from the receiver don't get lost on their\n   way through the generator over to the sender (which mainly affected\n   hard-link messages and verbose `--stats` output).\n\n - Improved the internal uid/gid code to be more portable and a little more\n   optimized.\n\n - The device numbers sent when using `--devices` are now sent as separate\n   major/minor values with 32-bit accuracy (protocol 28).  Previously, the\n   copied devices were sent as a single 32-bit number. This will make\n   inter-operation of 64-bit binaries more compatible with their 32-bit\n   brethren (with both ends of the connection are using protocol 28). Note that\n   optimizations in the binary protocol for sending the device numbers often\n   results in fewer bytes being used than before, even though more precision is\n   now available.\n\n - Some cleanup of the exclude/include structures and its code made things\n   clearer (internally), simpler, and more efficient.\n\n - The reading & writing of the file-list in batch-mode is now handled by the\n   same code that sends & receives the list over the wire. This makes it much\n   easier to maintain. (Note that the batch code is still considered to be\n   experimental.)\n\n### BUILD CHANGES:\n\n - The configure script now accepts `--with-rsyncd-conf=PATH` to override the\n   default value of the /etc/rsyncd.conf file.\n\n - Fixed configure bug when running `./configure --disable-ipv6`.\n\n - Fixed compilation problem on Tru64 Unix (having to do with `sockaddr.sa_len`\n   and `sockaddr.sin_len`).\n\n### DEVELOPER RELATED:\n\n - Fixed `make test` bug when build dir is not the source dir.\n\n - Added a couple extra diffs in the `patches` dir, removed the ones that got\n   applied, and rebuilt the rest.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.6.0 (1 Jan 2004)\n\n## Changes in this version:\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 27.  The maximum accepted protocol number\n   was increased from 30 to 40.\n\n### ENHANCEMENTS:\n\n - `ssh` is now the default remote shell for rsync. If you want to change this,\n   configure like this: `./configure --with-rsh=rsh`.\n\n - Added `--files-from`, `--no-relative`, `--no-implied-dirs`, and `--from0`.\n   Note that `--from0` affects the line-ending character for all the files read\n   by the `--*-from` options. (Wayne Davison)\n\n - Length of csum2 is now per-file starting with protocol version\n   27. (J.W. Schultz)\n\n - Per-file dynamic block size is now sqrt(file length). The per-file checksum\n   size is determined according to an algorithm provided by Donovan Baarda\n   which reduces the probability of rsync algorithm corrupting data and falling\n   back using the whole md4 checksums. (J.W. Schultz, Donovan Baarda)\n\n - The `--stats` option no longer includes the (debug) malloc summary unless\n   the verbose option was specified at least twice.\n\n - Added a new error/warning code for when files vanish from the sending side.\n   Made vanished source files not interfere with the file-deletion pass when\n   `--delete-after` was specified.\n\n - Various trailing-info sections are now preceded by a newline.\n\n### BUG FIXES:\n\n - Fixed several exclude/include matching bugs when using wild-cards.  This has\n   a several user-visible effects, all of which make the matching more\n   consistent and intuitive. This should hopefully not cause anyone problems\n   since it makes the matching work more like what people are expecting. (Wayne\n   Davison)\n\n - A pattern with a `**` no longer causes a `*` to match slashes.  For example,\n   with `/*/foo/**`, `foo` must be 2 levels deep.  [If your string has BOTH `*`\n   and `**` wildcards, changing the `*` wildcards to `**` will provide the old\n   behavior in all versions.]\n\n - `**/foo` now matches at the base of the transfer (like /foo does). [Use\n   `/**/foo` to get the old behavior in all versions.]\n\n - A non-anchored wildcard term floats to match beyond the base of the\n   transfer. E.g. `CVS/R*` matches at the end of the path, just like the\n   non-wildcard term `CVS/Root` does. [Use `/CVS/R*` to get the old behavior in\n   all versions.]\n\n - Including a `**` in the match term causes it to be matched against the\n   entire path, not just the name portion, even if there aren't any interior\n   slashes in the term. E.g. `foo**bar` would exclude `/path/foo-bar` (just\n   like before) as well as `/foo-path/baz-bar` (unlike before). [Use `foo*bar`\n   to get the old behavior in all versions.]\n\n - The exclude list specified in the daemon's config file is now properly\n   applied to the pulled items no matter how deep the user's file-args are in\n   the source tree. (Wayne Davison)\n\n - For protocol version >= 27, `mdfour_tail()` is called when the block size\n   (including `checksum_seed`) is a multiple of 64.  Previously it was not\n   called, giving the wrong MD4 checksum.  (Craig Barratt)\n\n - For protocol version >= 27, a 64 bit bit counter is used in mdfour.c as\n   required by the RFC. Previously only a 32 bit bit counter was used, causing\n   incorrect MD4 file checksums for file sizes >= 512MB - 4. (Craig Barratt)\n\n - Fixed a crash bug when interacting with older rsync versions and multiple\n   files of the same name are destined for the same dir.  (Wayne Davison)\n\n - Keep tmp names from overflowing MAXPATHLEN.\n\n - Make `--link-dest` honor the absence of `-p`, `-o`, and `-g`.\n\n - Made rsync treat a trailing slash in the destination in a more consistent\n   manner.\n\n - Fixed file I/O error detection. (John Van Essen)\n\n - Fixed bogus `malformed address {hostname}` message in rsyncd log when\n   checking IP address against hostnames from `hosts allow` and `hosts deny`\n   parameters in config file.\n\n - Print heap statistics when verbose >= 2 instead of when >= 1.\n\n - Fixed a compression (`-z`) bug when syncing a mostly-matching file that\n   contains already-compressed data. (Yasuoka Masahiko and Wayne Davison)\n\n - Fixed a bug in the `--backup` code that could cause deleted files to not get\n   backed up.\n\n - When the backup code makes new directories, create them with mode 0700\n   instead of 0755 (since the directory permissions in the backup tree are not\n   yet copied from the main tree).\n\n - Call setgroups() in a more portable manner.\n\n - Improved file-related error messages to better indicate exactly what\n   pathname failed. (Wayne Davison)\n\n - Fixed some bugs in the handling of `--delete` and `--exclude` when using the\n   `--relative` (`-R`) option. (Wayne Davison)\n\n - Fixed bug that prevented regular files from replacing special files and\n   caused a directory in `--link-dest` or `--compare-dest` to block the\n   creation of a file with the same path. A directory still cannot be replaced\n   by a regular file unless `--delete` specified. (J.W. Schultz)\n\n - Detect and report when open or opendir succeed but read and readdir fail\n   caused by network filesystem issues and truncated files. (David Norwood,\n   Michael Brown, J.W. Schultz)\n\n - Added a fix that should give ssh time to restore the tty settings if the\n   user presses Ctrl-C at an ssh password prompt.\n\n### INTERNAL:\n\n - Eliminated vestigial support for old versions that we stopped supporting.\n   (J.W. Schultz)\n\n - Simplified some of the option-parsing code. (Wayne Davison)\n\n - Some cleanup made to the exclude code, as well as some new defines added to\n   enhance readability. (Wayne Davison)\n\n - Changed the protocol-version code so that it can interact at a lower\n   protocol level than the maximum supported by both sides.  Added an\n   undocumented option, `--protocol=N`, to force the value we advertise to the\n   other side (primarily for testing purposes).  (Wayne Davison)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.7 (4 Dec 2003)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - Fix buffer handling bugs. (Andrew Tridgell, Martin Pool, Paul Russell,\n   Andrea Barisani)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.6, aka \"the dwd-between-jobs release\" (26 Jan 2003)\n\n## Changes in this version:\n\n### ENHANCEMENTS:\n\n - The `--delete-after` option now implies `--delete`. (Wayne Davison)\n\n - The `--suffix` option can now be used with `--backup-dir`. (Michael\n   Zimmerman)\n\n - Combining `::` syntax with the `--rsh`/`-e` option now uses the specified\n   remote-shell as a transport to talk to a (newly-spawned) server-daemon. This\n   allows someone to use daemon features, such as modules, over a secure\n   protocol, such as ssh. (JD Paul)\n\n - The rsync:// syntax for daemon connections is now accepted in the\n   destination field.\n\n - If the file name given to `--include-from` or `--exclude-from` is `-`, rsync\n   will read from standard input. (J.W. Schultz)\n\n - New option `--link-dest` which is like `--compare-dest` except that\n   unchanged files are hard-linked in to the destination directory.  (J.W.\n   Schultz)\n\n - Don't report an error if an excluded file disappears during an rsync run.\n   (Eugene Chupriyanov and Bo Kersey)\n\n - Added .svn to `--cvs-exclude` list to support subversion. (Jon Middleton)\n\n - Properly support IPv6 addresses in the rsyncd.conf `hosts allow` and `hosts\n   deny` fields. (Hideaki Yoshifuji)\n\n - Changed exclude file handling to permit DOS or MAC style line terminations.\n   (J.W. Schultz)\n\n - Ignore errors from chmod when `-p`/`-a`/`--preserve-perms` is not set.\n   (Dave Dykstra)\n\n### BUG FIXES:\n\n - Fix `forward name lookup failed` errors on AIX 4.3.3. (John L. Allen, Martin\n   Pool)\n\n - Generate each file's rolling-checksum data as we send it, not in a separate\n   (memory-eating) pass before hand. This prevents timeout errors on really\n   large files. (Stefan Nehlsen)\n\n - Fix compilation on Tru64. (Albert Chin, Zoong Pham)\n\n - Better handling of some client-server errors. (Martin Pool)\n\n - Fixed a crash that would occur when sending a list of files that contains a\n   duplicate name (if it sorts to the end of the file list) and using\n   `--delete`. (Wayne Davison)\n\n - Fixed the file-name duplicate-removal code when dealing with multiple dups\n   in a row. (Wayne Davison)\n\n - Fixed a bug that caused rsync to lose the exit status of its child processes\n   and sometimes return an exit code of 0 instead of showing an error. (David\n   R. Staples, Dave Dykstra)\n\n - Fixed bug in `--copy-unsafe-links` that caused it to be completely broken.\n   (Dave Dykstra)\n\n - Prevent infinite recursion in cleanup code under certain circumstances.\n   (Sviatoslav Sviridov and Marc Espie)\n\n - Fixed a bug that prevented rsync from creating intervening directories when\n   `--relative-paths`/`-R` is set. (Craig Barratt)\n\n - Prevent `Connection reset by peer` messages from Cygwin. (Randy O'Meara)\n\n### INTERNAL:\n\n - Many code cleanups and improved internal documentation. (Martin Pool, Nelson\n   Beebe)\n\n - Portability fixes. (Dave Dykstra and Wayne Davison)\n\n - More test cases. (Martin Pool)\n\n - Some test-case fixes. (Brian Poole, Wayne Davison)\n\n - Updated included popt to the latest vendor drop, version 1.6.4.  (Jos\n   Backus)\n\n - Updated config.guess and config.sub to latest versions; this means rsync\n   should build on more platforms. (Paul Green)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.5, aka Snowy River (2 Apr 2002)\n\n## Changes in this version:\n\n### ENHANCEMENTS:\n\n - With `--progress`, when a transfer is complete show the time taken;\n   otherwise show expected time to complete. (Cameron Simpson)\n\n - Make `make install-strip` works properly, and `make install` accepts a\n   DESTDIR variable for help in building binary packages.  (Peter\n   Breitenlohner, Greg Louis)\n\n - If configured with `--enable-maintainer-mode`, then on receipt of a fatal\n   signal rsync will try to open an xterm running gdb, similarly to Samba's\n   `panic action` or GNOME's bug-buddy.  (Martin Pool)\n\n### BUG FIXES:\n\n - Fix situation where failure to fork (e.g. because out of process slots)\n   would cause rsync to kill all processes owned by the current user. Yes,\n   really! (Paul Haas, Martin Pool)\n\n - Fix test suite on Solaris. (Jos Backus, Martin Pool)\n\n - Fix minor memory leak in socket code. (Dave Dykstra, Martin Pool.)\n\n - Fix `--whole-file` problem that caused it to be the default even for remote\n   connections. (Martin Pool, Frank Schulz)\n\n - Work around bug in Mac OS X mkdir(2), which cannot handle trailing slashes.\n   <http://www.opensource.apple.com/bugs/X/BSD%20Kernel/2734739.html> (Martin\n   Pool)\n\n - Improved network error handling. (Greg A. Woods)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.4, aka \"Imitation lizard skin\" (13 Mar 2002)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Additional fix for zlib double-free bug. (Martin Pool, Andrew Tridgell) (CVE\n   CAN-2002-0059)\n\n### ENHANCEMENTS:\n\n - Merge in changes from zlib 1.1.3 to zlib 1.1.4. (Jos Backus) (Note that\n   rsync still uses a custom version of zlib; you can not just link against a\n   system library. See zlib/README.rsync)\n\n - Additional test cases for `--compress`. (Martin Pool)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.3, aka \"Happy 26\" (11 Mar 2002)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - Make sure that supplementary groups are removed from a server\n   process after changing uid and gid. (Ethan Benson) (Debian bug\n   #132272, CVE CAN-2002-0080)\n\n### BUG FIXES:\n\n - Fix zlib double-free bug. (Owen Taylor, Mark J Cox) (CVE CAN-2002-0059)\n\n - Fixed problem that in many cases caused the error message unexpected read\n   size of 0 in `map_ptr` and resulted in the wrong data being copied.\n\n - Fixed compilation errors on some systems caused by the use of `unsigned\n   int64` in rsync.h.\n\n - Fixed problem on systems such as Sunos4 that do not support realloc on a\n   NULL pointer; error was 'out of memory in \"flist_expand\"'.\n\n - Fix for rsync server processes hanging around after the client unexpectedly\n   disconnects. (Colin Walters) (Debian bug #128632)\n\n - Cope with BSD systems on which mkdir() will not accept a trailing slash.\n\n### ENHANCEMENTS:\n\n - Merge in changes from zlib 1.1.2 to zlib 1.1.3. (Note that rsync still uses\n   a custom version of zlib; you can not just link against a system library.\n   See zlib/README.rsync)\n\n - Command to initiate connections is only shown with `-vv`, rather than `-v`\n   as in 2.5.2. Output from plain `-v` is more similar to what was historically\n   used so as not to break scripts that try to parse the output.\n\n - Added `--no-whole-file` and `--no-blocking-io` options (Dave Dykstra)\n\n - Made the `--write-batch` and `--read-batch` options actually work and added\n   documentation in the manpage (Jos Backus)\n\n - If the daemon is unable to fork a child to accept a connection, print an\n   error message. (Colin Walters)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.2 (26 Jan 2002)\n\n## Changes in this version:\n\n### SECURITY FIXES:\n\n - Signedness security patch from Sebastian Krahmer <krahmer@suse.de> -- in\n   some cases we were not sufficiently careful about reading integers from the\n   network.\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 26.\n\n### BUG FIXES:\n\n - Fix possible string mangling in log files.\n\n - Fix for setting local address of outgoing sockets.\n\n - Better handling of hardlinks and devices on platforms with 64-bit `dev_t` or\n   `ino_t`.\n\n - Name resolution on machines supporting IPv6 is improved.\n\n - Fix for device nodes. (dann frazier) (Debian #129135)\n\n### ENHANCEMENTS:\n\n - With `-v`, rsync now shows the command used to initiate an ssh/rsh\n   connection.\n\n - `--statistics` now shows memory heap usage on platforms that support\n   mallinfo().\n\n - \"The Ted T'so school of program optimization\": make progress visible and\n   people will think it's faster. (With `--progress`, rsync will show you how\n   many files it has seen as it builds the `file_list`, giving some indication\n   that it has not hung.)\n\n - Improvements to batch mode support. This is still experimental but testing\n   would be welcome. (Jos Backus)\n\n - New `--ignore-existing` option, patch previously distributed with Vipul's\n   Razor. (Debian #124286)\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.1 (3 Jan 2002)\n\n## Changes in this version:\n\n### BUG FIXES:\n\n - Fix for segfault in `--daemon` mode configuration parser. (Paul Mackerras)\n\n - Correct `string<->address` parsing for both IPv4 and 6.  (YOSHIFUJI Hideaki,\n   SUMIKAWA Munechika and Jun-ichiro `itojun` Hagino)\n\n - Various fixes for IPv6 support. (Dave Dykstra)\n\n - rsync.1 typo fix. (Matt Kraai)\n\n - Test suite typo fixes. (Tom Schmidt)\n\n - rsync.1 grammar and clarity improvements. (Edward Welbourne)\n\n - Correction to ./configure tests for `inet_ntop`. (Jeff Garzik)\n\n### ENHANCEMENTS:\n\n - `--progress` and `-P` now show estimated data transfer rate (in a multiple\n   of bytes/s) and estimated time to completion. (Rik Faith)\n\n - `--no-detach` option, required to run as a W32 service and also useful when\n   running on Unix under daemontools, AIX's SRC, or a debugger. (Max Bowsher,\n   Jos Backus)\n\n - Clearer error messages for some conditions.\n\n------------------------------------------------------------------------------\n\n# NEWS for rsync 2.5.0 (30 Nov 2001)\n\n## Changes in this version:\n\n### PROTOCOL NUMBER:\n\n - The protocol number was changed to 25.\n\n### ANNOUNCEMENTS:\n\n - Martin Pool <mbp@samba.org> is now a co-maintainer.\n\n### NEW FEATURES:\n\n - Support for LSB-compliant packaging <http://www.linuxbase.org/>\n\n - Shell wildcards are allowed in `auth users` lines.\n\n - Merged UNC rsync+ patch to support creation of standalone patch sets. By\n   Bert J. Dempsey and Debra Weiss, updated by Jos Backus.\n   <http://www.ils.unc.edu/i2dsi/unc_rsync+.html>\n\n - IPv6 support based on a patch from KAME.net, on systems including modern\n   versions of Linux, Solaris, and HP-UX. Also includes IPv6 compatibility\n   functions for old OSs by the Internet Software Consortium, Paul Vixie, the\n   OpenSSH portability project, and OpenBSD.\n\n### ENHANCEMENTS:\n\n - Include/exclude cluestick: with `-vv`, print out whether files are included\n   or excluded and why.\n\n - Many error messages have more friendly explanations and more details.\n\n - Manual page improvements plus scanty protocol documentation.\n\n - When running as `--daemon` in the background and using a `log file`\n   rsyncd.conf directive, close the log file every time it is open when going\n   to sleep on the socket. This allows the log file to get cleaned out by\n   another process.\n\n - Change to using libpopt rather than getopt for processing options. This\n   makes the code cleaner and the behaviour more consistent across platforms.\n   popt is included and built if not installed on the platform.\n\n - More details in `--version`, including note about whether 64-bit files,\n   symlinks and hardlinks are supported.\n\n - MD4 code may use less CPU cycles.\n\n - Use mkstemp on systems where it is secure. If we use mktemp, explain that we\n   do it in a secure way.\n\n - `--whole-file` is the default when source and target are on the local\n   machine.\n\n### BUG FIXES:\n\n - Fix for various bugs causing rsync to hang.\n\n - Attempt to fix Large File Summit support on AIX.\n\n - Attempt to fix error handling lockup bug.\n\n - Give a non-0 exit code if **any** of the files we have been asked to\n   transfer fail to transfer.\n\n - For log messages containing ridiculously long strings that might overflow a\n   buffer rsync no longer aborts, but rather prints an ellipsis at the end of\n   the string. (Patch from Ed Santiago.)\n\n### PLATFORMS:\n\n - Improved support for UNICOS (tested on Cray T3E and Cray SV1)\n\n - autoconf2.52 (or later) is now required to rebuild the autoconf scripts. It\n   is not required to simply build rsync.\n\n - Platforms thought to work in this release:\n\n   - Cray SV1 UNICOS 10.0.0.8 cc\n   - Debian Linux 2.2 UltraSparc gcc\n   - Debian Linux testing/unstable ARM gcc\n   - FreeBSD 3.3-RELEASE i386 cc\n   - FreeBSD 4.1.1-RELEASE i386 cc\n   - FreeBSD 4.3-STABLE i386 cc\n   - HP PA-RISC HP-UX 10.20 gcc\n   - HP PA-RISC HP-UX 11.11 cc\n   - IRIX 6.5 MIPS cc\n   - IRIX 6.5 MIPS gcc\n   - Mac OS X PPC (`--disable-ipv6`) cc\n   - NetBSD 1.5 i386 gcc\n   - NetBSD Current i386 cc\n   - OpenBSD 2.5 Sparc gcc\n   - OpenBSD 2.9 i386 cc\n   - OpenBSD Current i386 cc\n   - RedHat 6.2 i386 gcc\n   - RedHat 6.2 i386 insure++\n   - RedHat 7.0 i386 gcc\n   - RedHat 7.1 i386 (Kernel 2.4.10) gcc\n   - Slackware 8.0 i686 (Kernel 2.4.10)\n   - Solaris 8 UltraSparc cc\n   - Solaris 8 UltraSparc gcc\n   - Solaris 8 i386 gcc\n   - SuSE 7.1 i386 gcc2.95.2\n   - SuSE 7.1 ppc gcc2.95.2\n   - i386-pc-sco3.2v5.0.5 cc\n   - i386-pc-sco3.2v5.0.5 gcc\n   - powerpc-ibm-aix4.3.3.0 cc\n   - i686-unknown-sysv5UnixWare7.1.0 gcc\n   - i686-unknown-sysv5UnixWare7.1.0 cc\n\n### TESTING:\n\n - The existing test.sh script by Phil Hands has been merged into a\n   test framework that works from both `make check` and the Samba\n   build farm.\n\n------------------------------------------------------------------------------\n\n## Partial Protocol History\n\n| RELEASE DATE | VER.   | DATE OF COMMIT\\* | PROTOCOL    |\n|--------------|--------|------------------|-------------|\n| ?? Nov 2024  | 3.3.1  |                  | 31          |\n| 06 Apr 2024  | 3.3.0  |                  | 31          |\n| 20 Oct 2022  | 3.2.7  |                  | 31          |\n| 09 Sep 2022  | 3.2.6  |                  | 31          |\n| 14 Aug 2022  | 3.2.5  |                  | 31          |\n| 15 Apr 2022  | 3.2.4  |                  | 31          |\n| 06 Aug 2020  | 3.2.3  |                  | 31          |\n| 04 Jul 2020  | 3.2.2  |                  | 31          |\n| 22 Jun 2020  | 3.2.1  |                  | 31          |\n| 19 Jun 2020  | 3.2.0  |                  | 31          |\n| 28 Jan 2018  | 3.1.3  |                  | 31          |\n| 21 Dec 2015  | 3.1.2  |                  | 31          |\n| 22 Jun 2014  | 3.1.1  |                  | 31          |\n| 28 Sep 2013  | 3.1.0  | 31 Aug 2008      | 31          |\n| 23 Sep 2011  | 3.0.9  |                  | 30          |\n| 26 Mar 2011  | 3.0.8  |                  | 30          |\n| 31 Dec 2009  | 3.0.7  |                  | 30          |\n| 08 May 2009  | 3.0.6  |                  | 30          |\n| 28 Dec 2008  | 3.0.5  |                  | 30          |\n| 06 Sep 2008  | 3.0.4  |                  | 30          |\n| 29 Jun 2008  | 3.0.3  |                  | 30          |\n| 08 Apr 2008  | 3.0.2  |                  | 30          |\n| 03 Apr 2008  | 3.0.1  |                  | 30          |\n| 01 Mar 2008  | 3.0.0  | 11 Nov 2006      | 30          |\n| 06 Nov 2006  | 2.6.9  |                  | 29          |\n| 22 Apr 2006  | 2.6.8  |                  | 29          |\n| 11 Mar 2006  | 2.6.7  |                  | 29          |\n| 28 Jul 2005  | 2.6.6  |                  | 29          |\n| 01 Jun 2005  | 2.6.5  |                  | 29          |\n| 30 Mar 2005  | 2.6.4  | 17 Jan 2005      | 29          |\n| 30 Sep 2004  | 2.6.3  |                  | 28          |\n| 30 Apr 2004  | 2.6.2  |                  | 28          |\n| 26 Apr 2004  | 2.6.1  | 08 Jan 2004      | 28          |\n| 01 Jan 2004  | 2.6.0  | 10 Apr 2003      | 27 (MAX=40) |\n| 04 Dec 2003  | 2.5.7  |                  | 26          |\n| 26 Jan 2003  | 2.5.6  |                  | 26          |\n| 02 Apr 2002  | 2.5.5  |                  | 26          |\n| 13 Mar 2002  | 2.5.4  |                  | 26          |\n| 11 Mar 2002  | 2.5.3  |                  | 26          |\n| 26 Jan 2002  | 2.5.2  | 11 Jan 2002      | 26          |\n| 03 Jan 2002  | 2.5.1  |                  | 25          |\n| 30 Nov 2001  | 2.5.0  | 23 Aug 2001      | 25          |\n| 06 Sep 2000  | 2.4.6  |                  | 24          |\n| 19 Aug 2000  | 2.4.5  |                  | 24          |\n| 29 Jul 2000  | 2.4.4  |                  | 24          |\n| 09 Apr 2000  | 2.4.3  |                  | 24          |\n| 30 Mar 2000  | 2.4.2  |                  | 24          |\n| 30 Jan 2000  | 2.4.1  | 29 Jan 2000      | 24          |\n| 29 Jan 2000  | 2.4.0  | 28 Jan 2000      | 23          |\n| 25 Jan 2000  | 2.3.3  | 23 Jan 2000      | 22          |\n| 08 Nov 1999  | 2.3.2  | 26 Jun 1999      | 21          |\n| 06 Apr 1999  | 2.3.1  |                  | 20          |\n| 15 Mar 1999  | 2.3.0  | 15 Mar 1999      | 20          |\n| 25 Nov 1998  | 2.2.1  |                  | 19          |\n| 03 Nov 1998  | 2.2.0  |                  | 19          |\n| 09 Sep 1998  | 2.1.1  |                  | 19          |\n| 20 Jul 1998  | 2.1.0  |                  | 19          |\n| 17 Jul 1998  | 2.0.19 |                  | 19          |\n| 18 Jun 1998  | 2.0.17 |                  | 19          |\n| 01 Jun 1998  | 2.0.16 |                  | 19          |\n| 27 May 1998  | 2.0.13 | 27 May 1998      | 19          |\n| 26 May 1998  | 2.0.12 |                  | 18          |\n| 22 May 1998  | 2.0.11 |                  | 18          |\n| 18 May 1998  | 2.0.9  | 18 May 1998      | 18          |\n| 17 May 1998  | 2.0.8  |                  | 17          |\n| 15 May 1998  | 2.0.1  |                  | 17          |\n| 14 May 1998  | 2.0.0  |                  | 17          |\n| 17 Apr 1998  | 1.7.4  |                  | 17          |\n| 13 Apr 1998  | 1.7.3  |                  | 17          |\n| 05 Apr 1998  | 1.7.2  |                  | 17          |\n| 26 Mar 1998  | 1.7.1  |                  | 17          |\n| 26 Mar 1998  | 1.7.0  | 26 Mar 1998      | 17 (MAX=30) |\n| 13 Jan 1998  | 1.6.9  | 13 Jan 1998      | 15 (MAX=20) |\n\n\\* DATE OF COMMIT is the date the protocol change was committed to version\ncontrol.\n\n@USE_GFM_PARSER@\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.5048828125,
          "content": "WHAT IS RSYNC?\n--------------\n\nRsync is a fast and extraordinarily versatile file copying tool for\nboth remote and local files.\n\nRsync uses a delta-transfer algorithm which provides a very fast method\nfor bringing remote files into sync.  It does this by sending just the\ndifferences in the files across the link, without requiring that both\nsets of files are present at one of the ends of the link beforehand.  At\nfirst glance this may seem impossible because the calculation of diffs\nbetween two files normally requires local access to both files.\n\nA technical report describing the rsync algorithm is included with this\npackage.\n\n\nUSAGE\n-----\n\nBasically you use rsync just like scp, but rsync has many additional\noptions.  To get a complete list of supported options type:\n\n    rsync --help\n\nSee the [manpage][0] for more detailed information.\n\n[0]: https://download.samba.org/pub/rsync/rsync.1\n\nBUILDING AND INSTALLING\n-----------------------\n\nIf you need to build rsync yourself, check out the [INSTALL][1] page for\ninformation on what libraries and packages you can use to get the maximum\nfeatures in your build.\n\n[1]: https://github.com/RsyncProject/rsync/blob/master/INSTALL.md\n\nSETUP\n-----\n\nRsync normally uses ssh or rsh for communication with remote systems.\nIt does not need to be setuid and requires no special privileges for\ninstallation.  You must, however, have a working ssh or rsh system.\nUsing ssh is recommended for its security features.\n\nAlternatively, rsync can run in `daemon' mode, listening on a socket.\nThis is generally used for public file distribution, although\nauthentication and access control are available.\n\nTo install rsync, first run the \"configure\" script.  This will create a\nMakefile and config.h appropriate for your system.  Then type \"make\".\n\nNote that on some systems you will have to force configure not to use\ngcc because gcc may not support some features (such as 64 bit file\noffsets) that your system may support.  Set the environment variable CC\nto the name of your native compiler before running configure in this\ncase.\n\nOnce built put a copy of rsync in your search path on the local and\nremote systems (or use \"make install\").  That's it!\n\n\nRSYNC DAEMONS\n-------------\n\nRsync can also talk to \"rsync daemons\" which can provide anonymous or\nauthenticated rsync.  See the rsyncd.conf(5) manpage for details on how\nto setup an rsync daemon.  See the rsync(1) manpage for info on how to\nconnect to an rsync daemon.\n\n\nWEB SITE\n--------\n\nFor more information, visit the [main rsync web site][2].\n\n[2]: https://rsync.samba.org/\n\nYou'll find a FAQ list, downloads, resources, HTML versions of the\nmanpages, etc.\n\n\nMAILING LISTS\n-------------\n\nThere is a mailing list for the discussion of rsync and its applications\nthat is open to anyone to join.  New releases are announced on this\nlist, and there is also an announcement-only mailing list for those that\nwant official announcements.  See the [mailing-list page][3] for full\ndetails.\n\n[3]: https://rsync.samba.org/lists.html\n\n\nBUG REPORTS\n-----------\n\nThe [bug-tracking web page][4] has full details on bug reporting.\n\n[4]: https://rsync.samba.org/bug-tracking.html\n\nThat page contains links to the current bug list, and information on how to\ndo a good job when reporting a bug.  You might also like to try searching\nthe Internet for the error message you've received, or looking in the\n[mailing list archives][5].\n\n[5]: https://mail-archive.com/rsync@lists.samba.org/\n\nTo send a bug report, follow the instructions on the bug-tracking\npage of the web site.\n\nAlternately, email your bug report to <rsync@lists.samba.org>.\n\nFor security issues please email details of the issue to <rsync.project@gmail.com>.\n\nGIT REPOSITORY\n--------------\n\nIf you want to get the very latest version of rsync direct from the\nsource code repository, then you will need to use git.  The git repo\nis hosted [on GitHub][6] and [on Samba's site][7].\n\n[6]: https://github.com/RsyncProject/rsync\n[7]: https://git.samba.org/?p=rsync.git;a=summary\n\nSee [the download page][8] for full details on all the ways to grab the\nsource.\n\n[8]: https://rsync.samba.org/download.html\n\n\nCOPYRIGHT\n---------\n\nRsync was originally written by Andrew Tridgell and Paul Mackerras.  Many\npeople from around the world have helped to maintain and improve it.\n\nRsync may be used, modified and redistributed only under the terms of\nthe GNU General Public License, found in the file [COPYING][9] in this\ndistribution, or at [the Free Software Foundation][10].\n\n[9]: https://github.com/RsyncProject/rsync/blob/master/COPYING\n[10]: https://www.fsf.org/licenses/gpl.html\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.3056640625,
          "content": "# Security Policy\n\n## Supported Versions\n\nOnly the current release of the software is actively supported.  If you need\nhelp backporting fixes into an older release, feel free to ask.\n\n## Reporting a Vulnerability\n\nEmail your vulnerability information to rsync's maintainer:\n\n  Wayne Davison <wayne@opencoder.net>\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 15.251953125,
          "content": "-*- indented-text -*-\n\nFEATURES ------------------------------------------------------------\nUse chroot only if supported\nAllow supplementary groups in rsyncd.conf\t\t\t2002/04/09\nHandling IPv6 on old machines\nOther IPv6 stuff\nAdd ACL support\t\t\t\t\t\t\t2001/12/02\nproxy authentication\t\t\t\t\t\t2002/01/23\nSOCKS\t\t\t\t\t\t\t\t2002/01/23\nFAT support\n--diff\t\t\t\t\t\tdavid.e.sewell\t2002/03/15\nAdd daemon --no-fork option\nCreate more granular verbosity\t\t\t\t\t2003/05/15\n\nDOCUMENTATION --------------------------------------------------------\nKeep list of open issues and todos on the web site\nPerhaps redo manual as SGML\n\nLOGGING --------------------------------------------------------------\nMemory accounting\nImprove error messages\nBetter statistics\t\t\t\t\tRasmus\t2002/03/08\nPerhaps flush stdout like syslog\nLog child death on signal\nverbose output\t\t\t\t\tDavid Stein\t2001/12/20\ninternationalization\n\nDEVELOPMENT --------------------------------------------------------\nHandling duplicate names\nUse generic zlib\t\t\t\t\t\t2002/02/25\nTDB\t\t\t\t\t\t\t\t2002/03/12\nSplint\t\t\t\t\t\t\t\t2002/03/12\n\nPERFORMANCE ----------------------------------------------------------\nTraverse just one directory at a time\nAllow skipping MD4 file_sum\t\t\t\t\t2002/04/08\nAccelerate MD4\n\nTESTING --------------------------------------------------------------\nTorture test\nCross-test versions\t\t\t\t\t\t2001/08/22\nTest on kernel source\nTest large files\nCreate mutator program for testing\nCreate configure option to enable dangerous tests\nCreate pipe program for testing\nCreate test makefile target for some tests\n\nRELATED PROJECTS -----------------------------------------------------\nrsyncsh\nhttps://rsync.samba.org/rsync-and-debian/\nrsyncable gzip patch\nrsyncsplit as alternative to real integration with gzip?\nreverse rsync over HTTP Range\n\n\n\nFEATURES ------------------------------------------------------------\n\n\nUse chroot only if supported\n\n  If the platform doesn't support it, then don't even try.\n\n  If running as non-root, then don't fail, just give a warning.\n  (There was a thread about this a while ago?)\n\n    https://lists.samba.org/pipermail/rsync/2001-August/thread.html\n    https://lists.samba.org/pipermail/rsync/2001-September/thread.html\n\n                      --          --\n\n\nAllow supplementary groups in rsyncd.conf\t\t\t2002/04/09\n\n  Perhaps allow supplementary groups to be specified in rsyncd.conf;\n  then make the first one the primary gid and all the rest be\n  supplementary gids.\n\n                      --          --\n\n\nHandling IPv6 on old machines\n\n  The KAME IPv6 patch is nice in theory but has proved a bit of a\n  nightmare in practice.  The basic idea of their patch is that rsync\n  is rewritten to use the new getaddrinfo()/getnameinfo() interface,\n  rather than gethostbyname()/gethostbyaddr() as in rsync 2.4.6.\n  Systems that don't have the new interface are handled by providing\n  our own implementation in lib/, which is selectively linked in.\n\n  The problem with this is that it is really hard to get right on\n  platforms that have a half-working implementation, so redefining\n  these functions clashes with system headers, and leaving them out\n  breaks.  This affects at least OSF/1, RedHat 5, and Cobalt, which\n  are moderately important.\n\n  Perhaps the simplest solution would be to have two different files\n  implementing the same interface, and choose either the new or the\n  old API.  This is probably necessary for systems that e.g. have\n  IPv6, but gethostbyaddr() can't handle it.  The Linux manpage claims\n  this is currently the case.\n\n  In fact, our internal sockets interface (things like\n  open_socket_out(), etc) is much narrower than the getaddrinfo()\n  interface, and so probably simpler to get right.  In addition, the\n  old code is known to work well on old machines.\n\n  We could drop the rather large lib/getaddrinfo files.\n\n                      --          --\n\n\nOther IPv6 stuff\n  \n  Implement suggestions from http://www.kame.net/newsletter/19980604/\n  and ftp://ftp.iij.ad.jp/pub/RFC/rfc2553.txt\n\n  If a host has multiple addresses, then listen try to connect to all\n  in order until we get through.  (getaddrinfo may return multiple\n  addresses.)  This is kind of implemented already.\n\n  Possibly also when starting as a server we may need to listen on\n  multiple passive addresses.  This might be a bit harder, because we\n  may need to select on all of them.  Hm.\n\n                      --          --\n\n\nAdd ACL support\t\t\t\t\t\t\t2001/12/02\n\n  Transfer ACLs.  Need to think of a standard representation.\n  Probably better not to even try to convert between NT and POSIX.\n  Possibly can share some code with Samba.\n  NOTE: there is a patch that implements this in the \"patches\" subdir.\n\n                      --          --\n\n\nproxy authentication\t\t\t\t\t\t2002/01/23\n\n  Allow RSYNC_PROXY to be http://user:pass@proxy.foo:3128/, and do\n  HTTP Basic Proxy-Authentication.\n\n  Multiple schemes are possible, up to and including the insanity that\n  is NTLM, but Basic probably covers most cases.\n\n                      --          --\n\n\nSOCKS\t\t\t\t\t\t\t\t2002/01/23\n\n  Add --with-socks, and then perhaps a command-line option to put them\n  on or off.  This might be more reliable than LD_PRELOAD hacks.\n\n                      --          --\n\n\nFAT support\n\n  rsync to a FAT partition on a Unix machine doesn't work very well at\n  the moment.  I think we get errors about invalid filenames and\n  perhaps also trying to do atomic renames.\n\n  I guess the code to do this is currently #ifdef'd on Windows;\n  perhaps we ought to intelligently fall back to it on Unix too.\n\n                      --          --\n\n\n--diff\t\t\t\t\t\tdavid.e.sewell\t2002/03/15\n\n  Allow people to specify the diff command.  (Might want to use wdiff,\n  gnudiff, etc.)\n\n  Just diff the temporary file with the destination file, and delete\n  the tmp file rather than moving it into place.\n\n  Interaction with --partial.\n\n  Security interactions with daemon mode?\n\n                      --          --\n\n\nAdd daemon --no-fork option\n\n  Very useful for debugging.  Also good when running under a\n  daemon-monitoring process that tries to restart the service when the\n  parent exits.\n\n                      --          --\n\n\nCreate more granular verbosity\t\t\t\t\t2003/05/15\n\n  Control output with the --report option.\n\n  The option takes as a single argument (no whitespace) a\n  comma delimited lists of keywords.\n\n  This would separate debugging from \"logging\" as well as\n  fine grained selection of statistical reporting and what\n  actions are logged.\n\n  https://lists.samba.org/archive/rsync/2003-May/006059.html\n\n                      --          --\n\nDOCUMENTATION --------------------------------------------------------\n\n\nKeep list of open issues and todos on the web site\n\n                      --          --\n\n\nPerhaps redo manual as SGML\n\n  The man page is getting rather large, and there is more information\n  that ought to be added.\n\n  TexInfo source is probably a dying format.\n\n  Linuxdoc looks like the most likely contender.  I know DocBook is\n  favoured by some people, but it's so bloody verbose, even with emacs\n  support.\n\n                      --          --\n\nLOGGING --------------------------------------------------------------\n\n\nMemory accounting\n\n  At exit, show how much memory was used for the file list, etc.\n\n  We also do a weird exponential-growth allocation in flist.c.  I'm\n  not sure this makes sense with modern mallocs.  At any rate it will\n  make us allocate a huge amount of memory for large file lists.\n\n                      --          --\n\n\nImprove error messages\n\n  If we hang or get SIGINT, then explain where we were up to.  Perhaps\n  have a static buffer that contains the current function name, or\n  some kind of description of what we were trying to do.  This is a\n  little easier on people than needing to run strace/truss.\n\n  \"The dungeon collapses!  You are killed.\"  Rather than \"unexpected\n  eof\" give a message that is more detailed if possible and also more\n  helpful.\n\n  If we get an error writing to a socket, then we should perhaps\n  continue trying to read to see if an error message comes across\n  explaining why the socket is closed.  I'm not sure if this would\n  work, but it would certainly make our messages more helpful.\n\n  What happens if a directory is missing -x attributes.  Do we lose\n  our load?  (Debian #28416) Probably fixed now, but a test case would\n  be good.\n\n                      --          --\n\n\nBetter statistics\t\t\t\t\tRasmus\t2002/03/08\n\n  <Rasmus>\n      hey, how about an rsync option that just gives you the\n      summary without the list of files?  And perhaps gives\n      more information like the number of new files, number\n      of changed, deleted, etc. ?\n\n  <mbp>\n      nice idea there is --stats but at the moment it's very\n      tridge-oriented rather than user-friendly it would be\n      nice to improve it that would also work well with\n      --dryrun\n\n                      --          --\n\n\nPerhaps flush stdout like syslog\n\n  Perhaps flush stdout after each filename, so that people trying to\n  monitor progress in a log file can do so more easily.  See\n  https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=48108\n\n                      --          --\n\n\nLog child death on signal\n\n  If a child of the rsync daemon dies with a signal, we should notice\n  that when we reap it and log a message.\n\n                      --          --\n\n\nverbose output\t\t\t\t\tDavid Stein\t2001/12/20\n  \n  At end of transfer, show how many files were or were not transferred\n  correctly.\n\n                      --          --\n\n\ninternationalization\n\n  Change to using gettext().  Probably need to ship this for platforms\n  that don't have it.\n\n  Solicit translations.\n\n  Does anyone care?  Before we bother modifying the code, we ought to\n  get the manual translated first, because that's possibly more useful\n  and at any rate demonstrates desire.\n\n                      --          --\n\nDEVELOPMENT --------------------------------------------------------\n\nHandling duplicate names\n\n  Some folks would like rsync to be deterministic in how it handles\n  duplicate names that come from mering multiple source directories\n  into a single destination directory; e.g. the last name wins.  We\n  could do this by switching our sort algorithm to one that will\n  guarantee that the names won't be reordered.  Alternately, we could\n  assign an ever-increasing number to each item as we insert it into\n  the list and then make sure that we leave the largest number when\n  cleaning the file list (see clean_flist()).  Another solution would\n  be to add a hash table, and thus never put any duplicate names into\n  the file list (and bump the protocol to handle this).\n\n                      --          --\n\n\nUse generic zlib\t\t\t\t\t\t2002/02/25\n\n  Perhaps don't use our own zlib.\n\n  Advantages:\n   \n    - will automatically be up to date with bugfixes in zlib\n\n    - can leave it out for small rsync on e.g. recovery disks\n\n    - can use a shared library\n\n    - avoids people breaking rsync by trying to do this themselves and\n      messing up\n\n  Should we ship zlib for systems that don't have it, or require\n  people to install it separately?\n\n  Apparently this will make us incompatible with versions of rsync\n  that use the patched version of rsync.  Probably the simplest way to\n  do this is to just disable gzip (with a warning) when talking to old\n  versions.\n\n                      --          --\n\n\nSplint\t\t\t\t\t\t\t\t2002/03/12\n\n  Build rsync with SPLINT to try to find security holes.  Add\n  annotations as necessary.  Keep track of the number of warnings\n  found initially, and see how many of them are real bugs, or real\n  security bugs.  Knowing the percentage of likely hits would be\n  really interesting for other projects.\n\n                      --          --\n\nPERFORMANCE ----------------------------------------------------------\n\nAllow skipping MD4 file_sum\t\t\t\t\t2002/04/08\n\n  If we're doing a local transfer, or using -W, then perhaps don't\n  send the file checksum.  If we're doing a local transfer, then\n  calculating MD4 checksums uses 90% of CPU and is unlikely to be\n  useful.\n\n  We should not allow it to be disabled separately from -W, though\n  as it is the only thing that lets us know when the rsync algorithm\n  got out of sync and messed the file up (i.e. if the basis file\n  changed between checksum generation and reception).\n\n                      --          --\n\n\nAccelerate MD4\n\n  Perhaps borrow an assembler MD4 from someone?\n\n  Make sure we call MD4 with properly-sized blocks whenever possible\n  to avoid copying into the residue region?\n\n                      --          --\n\nTESTING --------------------------------------------------------------\n\nTorture test\n\n  Something that just keeps running rsync continuously over a data set\n  likely to generate problems.\n\n                      --          --\n\n\nCross-test versions\t\t\t\t\t\t2001/08/22\n\n  Part of the regression suite should be making sure that we\n  don't break backwards compatibility: old clients vs new\n  servers and so on.  Ideally we would test both up and down\n  from the current release to all old versions.\n\n  Run current rsync versions against significant past releases.\n\n  We might need to omit broken old versions, or versions in which\n  particular functionality is broken\n\n  It might be sufficient to test downloads from well-known public\n  rsync servers running different versions of rsync.  This will give\n  some testing and also be the most common case for having different\n  versions and not being able to upgrade.\n\n  The new --protocol option may help in this.\n\n                      --          --\n\n\nTest on kernel source\n\n  Download all versions of kernel; unpack, sync between them.  Also\n  sync between uncompressed tarballs.  Compare directories after\n  transfer.\n\n  Use local mode; ssh; daemon; --whole-file and --no-whole-file.\n\n  Use awk to pull out the 'speedup' number for each transfer.  Make\n  sure it is >= x.\n\n                      --          --\n\n\nTest large files\n\n  Sparse and non-sparse\n\n                      --          --\n\n\nCreate mutator program for testing\n\n  Insert bytes, delete bytes, swap blocks, ...\n\n                      --          --\n\n\nCreate configure option to enable dangerous tests\n\n                      --          --\n\n\nCreate pipe program for testing\n\n  Create pipe program that makes slow/jerky connections for\n  testing Versions of read() and write() that corrupt the\n  stream, or abruptly fail\n\n                      --          --\n\n\nCreate test makefile target for some tests\n\n  Separate makefile target to run rough tests -- or perhaps\n  just run them every time?\n\n                      --          --\n\nRELATED PROJECTS -----------------------------------------------------\n\nrsyncsh\n\n   Write a small emulation of interactive ftp as a Pythonn program\n   that calls rsync.  Commands such as \"cd\", \"ls\", \"ls *.c\" etc map\n   fairly directly into rsync commands: it just needs to remember the\n   current host, directory and so on.  We can probably even do\n   completion of remote filenames.\n\n                      --          --\n\n\nhttps://rsync.samba.org/rsync-and-debian/\n\n\n                      --          --\n\n\nrsyncable gzip patch\n\n  Exhaustive, tortuous testing\n\n  Cleanups?\n\n                      --          --\n\n\nrsyncsplit as alternative to real integration with gzip?\n\n                      --          --\n\n\nreverse rsync over HTTP Range\n\n  Goswin Brederlow suggested this on Debian; I think tridge and I\n  talked about it previous in relation to rproxy.\n\n  Addendum:  It looks like someone is working on a version of this:\n\n    http://zsync.moria.org.uk/\n\n                      --          --\n\n"
        },
        {
          "name": "access.c",
          "type": "blob",
          "size": 6.107421875,
          "content": "/*\n * Routines to authenticate access to a daemon (hosts allow/deny).\n *\n * Copyright (C) 1998 Andrew Tridgell\n * Copyright (C) 2004-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#ifdef HAVE_NETGROUP_H\n#include <netgroup.h>\n#endif\n\nstatic int allow_forward_dns;\n\nextern const char undetermined_hostname[];\n\nstatic int match_hostname(const char **host_ptr, const char *addr, const char *tok)\n{\n\tstruct hostent *hp;\n\tunsigned int i;\n\tconst char *host = *host_ptr;\n\n\tif (!host || !*host)\n\t\treturn 0;\n\n#ifdef HAVE_INNETGR\n\tif (*tok == '@' && tok[1])\n\t\treturn innetgr(tok + 1, host, NULL, NULL);\n#endif\n\n\t/* First check if the reverse-DNS-determined hostname matches. */\n\tif (iwildmatch(tok, host))\n\t\treturn 1;\n\n\tif (!allow_forward_dns)\n\t\treturn 0;\n\n\t/* Fail quietly if tok is an address or wildcarded entry, not a simple hostname. */\n\tif (!tok[strspn(tok, \".0123456789\")] || tok[strcspn(tok, \":/*?[\")])\n\t\treturn 0;\n\n\t/* Now try forward-DNS on the token (config-specified hostname) and see if the IP matches. */\n\tif (!(hp = gethostbyname(tok)))\n\t\treturn 0;\n\n\tfor (i = 0; hp->h_addr_list[i] != NULL; i++) {\n\t\tif (strcmp(addr, inet_ntoa(*(struct in_addr*)(hp->h_addr_list[i]))) == 0) {\n\t\t\t/* If reverse lookups are off, we'll use the conf-specified\n\t\t\t * hostname in preference to UNDETERMINED. */\n\t\t\tif (host == undetermined_hostname)\n\t\t\t\t*host_ptr = strdup(tok);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int match_binary(const char *b1, const char *b2, const char *mask, int addrlen)\n{\n\tint i;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\tif ((b1[i] ^ b2[i]) & mask[i])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void make_mask(char *mask, int plen, int addrlen)\n{\n\tint w, b;\n\n\tw = plen >> 3;\n\tb = plen & 0x7;\n\n\tif (w)\n\t\tmemset(mask, 0xff, w);\n\tif (w < addrlen)\n\t\tmask[w] = 0xff & (0xff<<(8-b));\n\tif (w+1 < addrlen)\n\t\tmemset(mask+w+1, 0, addrlen-w-1);\n\n\treturn;\n}\n\nstatic int match_address(const char *addr, const char *tok)\n{\n\tchar *p;\n\tstruct addrinfo hints, *resa, *rest;\n\tint gai;\n\tint ret = 0;\n\tint addrlen = 0;\n#ifdef HAVE_STRTOL\n\tlong int bits;\n#else\n\tint bits;\n#endif\n\tchar mask[16];\n\tchar *a = NULL, *t = NULL;\n\n\tif (!addr || !*addr)\n\t\treturn 0;\n\n\tp = strchr(tok,'/');\n\tif (p)\n\t\t*p = '\\0';\n\n\t/* Fail quietly if tok is a hostname, not an address. */\n\tif (tok[strspn(tok, \".0123456789\")] && strchr(tok, ':') == NULL) {\n\t\tif (p)\n\t\t\t*p = '/';\n\t\treturn 0;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_NUMERICHOST\n\thints.ai_flags = AI_NUMERICHOST;\n#endif\n\n\tif (getaddrinfo(addr, NULL, &hints, &resa) != 0) {\n\t\tif (p)\n\t\t\t*p = '/';\n\t\treturn 0;\n\t}\n\n\tgai = getaddrinfo(tok, NULL, &hints, &rest);\n\tif (p)\n\t\t*p++ = '/';\n\tif (gai != 0) {\n\t\trprintf(FLOG, \"error matching address %s: %s\\n\",\n\t\t\ttok, gai_strerror(gai));\n\t\tfreeaddrinfo(resa);\n\t\treturn 0;\n\t}\n\n\tif (rest->ai_family != resa->ai_family) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tswitch(resa->ai_family) {\n\tcase PF_INET:\n\t\ta = (char *)&((struct sockaddr_in *)resa->ai_addr)->sin_addr;\n\t\tt = (char *)&((struct sockaddr_in *)rest->ai_addr)->sin_addr;\n\t\taddrlen = 4;\n\n\t\tbreak;\n\n#ifdef INET6\n\tcase PF_INET6: {\n\t\tstruct sockaddr_in6 *sin6a, *sin6t;\n\n\t\tsin6a = (struct sockaddr_in6 *)resa->ai_addr;\n\t\tsin6t = (struct sockaddr_in6 *)rest->ai_addr;\n\n\t\ta = (char *)&sin6a->sin6_addr;\n\t\tt = (char *)&sin6t->sin6_addr;\n\n\t\taddrlen = 16;\n\n#ifdef HAVE_SOCKADDR_IN6_SCOPE_ID\n\t\tif (sin6t->sin6_scope_id && sin6a->sin6_scope_id != sin6t->sin6_scope_id) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n#endif\n\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\trprintf(FLOG, \"unknown family %u\\n\", rest->ai_family);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbits = -1;\n\tif (p) {\n\t\tif (inet_pton(resa->ai_addr->sa_family, p, mask) <= 0) {\n#ifdef HAVE_STRTOL\n\t\t\tchar *ep = NULL;\n#else\n\t\t\tunsigned char *pp;\n#endif\n\n#ifdef HAVE_STRTOL\n\t\t\tbits = strtol(p, &ep, 10);\n\t\t\tif (!*p || *ep) {\n\t\t\t\trprintf(FLOG, \"malformed mask in %s\\n\", tok);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n#else\n\t\t\tfor (pp = (unsigned char *)p; *pp; pp++) {\n\t\t\t\tif (!isascii(*pp) || !isdigit(*pp)) {\n\t\t\t\t\trprintf(FLOG, \"malformed mask in %s\\n\", tok);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbits = atoi(p);\n#endif\n\t\t\tif (bits == 0) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (bits < 0 || bits > (addrlen << 3)) {\n\t\t\t\trprintf(FLOG, \"malformed mask in %s\\n\", tok);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbits = 128;\n\t}\n\n\tif (bits >= 0)\n\t\tmake_mask(mask, bits, addrlen);\n\n\tret = match_binary(a, t, mask, addrlen);\n\n  out:\n\tfreeaddrinfo(resa);\n\tfreeaddrinfo(rest);\n\treturn ret;\n}\n\nstatic int access_match(const char *list, const char *addr, const char **host_ptr)\n{\n\tchar *tok;\n\tchar *list2 = strdup(list);\n\n\tstrlower(list2);\n\n\tfor (tok = strtok(list2, \" ,\\t\"); tok; tok = strtok(NULL, \" ,\\t\")) {\n\t\tif (match_hostname(host_ptr, addr, tok) || match_address(addr, tok)) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nint allow_access(const char *addr, const char **host_ptr, int i)\n{\n\tconst char *allow_list = lp_hosts_allow(i);\n\tconst char *deny_list = lp_hosts_deny(i);\n\n\tif (allow_list && !*allow_list)\n\t\tallow_list = NULL;\n\tif (deny_list && !*deny_list)\n\t\tdeny_list = NULL;\n\n\tallow_forward_dns = lp_forward_lookup(i);\n\n\t/* If we match an allow-list item, we always allow access. */\n\tif (allow_list) {\n\t\tif (access_match(allow_list, addr, host_ptr))\n\t\t\treturn 1;\n\t\t/* For an allow-list w/o a deny-list, disallow non-matches. */\n\t\tif (!deny_list)\n\t\t\treturn 0;\n\t}\n\n\t/* If we match a deny-list item (and got past any allow-list\n\t * items), we always disallow access. */\n\tif (deny_list && access_match(deny_list, addr, host_ptr))\n\t\treturn 0;\n\n\t/* Allow all other access. */\n\treturn 1;\n}\n"
        },
        {
          "name": "acls.c",
          "type": "blob",
          "size": 29.912109375,
          "content": "/*\n * Handle passing Access Control Lists between systems.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2006-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"lib/sysacls.h\"\n\n#ifdef SUPPORT_ACLS\n\nextern int dry_run;\nextern int am_root;\nextern int read_only;\nextern int list_only;\nextern mode_t orig_umask;\nextern int numeric_ids;\nextern int inc_recurse;\nextern int preserve_devices;\nextern int preserve_specials;\n\n/* Flags used to indicate what items are being transmitted for an entry. */\n#define XMIT_USER_OBJ (1<<0)\n#define XMIT_GROUP_OBJ (1<<1)\n#define XMIT_MASK_OBJ (1<<2)\n#define XMIT_OTHER_OBJ (1<<3)\n#define XMIT_NAME_LIST (1<<4)\n\n#define NO_ENTRY ((uchar)0x80) /* Default value of a NON-name-list entry. */\n\n#define NAME_IS_USER (1u<<31) /* Bit used only on a name-list entry. */\n\n/* When we send the access bits over the wire, we shift them 2 bits to the\n * left and use the lower 2 bits as flags (relevant only to a name entry).\n * This makes the protocol more efficient than sending a value that would\n * be likely to have its highest bits set. */\n#define XFLAG_NAME_FOLLOWS 0x0001u\n#define XFLAG_NAME_IS_USER 0x0002u\n\n/* === ACL structures === */\n\ntypedef struct {\n\tid_t id;\n\tuint32 access;\n} id_access;\n\ntypedef struct {\n\tid_access *idas;\n\tint count;\n} ida_entries;\n\ntypedef struct {\n\tchar *name;\n\tuchar len;\n} idname;\n\ntypedef struct rsync_acl {\n\tida_entries names;\n\t/* These will be NO_ENTRY if there's no such entry. */\n\tuchar user_obj;\n\tuchar group_obj;\n\tuchar mask_obj;\n\tuchar other_obj;\n} rsync_acl;\n\ntypedef struct {\n\trsync_acl racl;\n\tSMB_ACL_T sacl;\n} acl_duo;\n\nstatic const rsync_acl empty_rsync_acl = {\n\t{NULL, 0}, NO_ENTRY, NO_ENTRY, NO_ENTRY, NO_ENTRY\n};\n\nstatic item_list access_acl_list = EMPTY_ITEM_LIST;\nstatic item_list default_acl_list = EMPTY_ITEM_LIST;\n\nstatic size_t prior_access_count = (size_t)-1;\nstatic size_t prior_default_count = (size_t)-1;\n\n/* === Calculations on ACL types === */\n\nstatic const char *str_acl_type(SMB_ACL_TYPE_T type)\n{\n\tswitch (type) {\n\tcase SMB_ACL_TYPE_ACCESS:\n#ifdef HAVE_OSX_ACLS\n\t\treturn \"ACL_TYPE_EXTENDED\";\n#else\n\t\treturn \"ACL_TYPE_ACCESS\";\n#endif\n\tcase SMB_ACL_TYPE_DEFAULT:\n\t\treturn \"ACL_TYPE_DEFAULT\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn \"unknown ACL type!\";\n}\n\nstatic int calc_sacl_entries(const rsync_acl *racl)\n{\n\t/* A System ACL always gets user/group/other permission entries. */\n\treturn racl->names.count\n#ifdef ACLS_NEED_MASK\n\t     + 1\n#else\n\t     + (racl->mask_obj != NO_ENTRY)\n#endif\n\t     + 3;\n}\n\n/* Extracts and returns the permission bits from the ACL.  This cannot be\n * called on an rsync_acl that has NO_ENTRY in any spot but the mask. */\nstatic int rsync_acl_get_perms(const rsync_acl *racl)\n{\n\treturn (racl->user_obj << 6)\n\t     + ((racl->mask_obj != NO_ENTRY ? racl->mask_obj : racl->group_obj) << 3)\n\t     + racl->other_obj;\n}\n\n/* Removes the permission-bit entries from the ACL because these\n * can be reconstructed from the file's mode. */\nstatic void rsync_acl_strip_perms(stat_x *sxp)\n{\n\trsync_acl *racl = sxp->acc_acl;\n\n\tracl->user_obj = NO_ENTRY;\n\tif (racl->mask_obj == NO_ENTRY)\n\t\tracl->group_obj = NO_ENTRY;\n\telse {\n\t\tint group_perms = (sxp->st.st_mode >> 3) & 7;\n\t\tif (racl->group_obj == group_perms)\n\t\t\tracl->group_obj = NO_ENTRY;\n#ifndef HAVE_SOLARIS_ACLS\n\t\tif (racl->names.count != 0 && racl->mask_obj == group_perms)\n\t\t\tracl->mask_obj = NO_ENTRY;\n#endif\n\t}\n\tracl->other_obj = NO_ENTRY;\n}\n\n/* Given an empty rsync_acl, fake up the permission bits. */\nstatic void rsync_acl_fake_perms(rsync_acl *racl, mode_t mode)\n{\n\tracl->user_obj = (mode >> 6) & 7;\n\tracl->group_obj = (mode >> 3) & 7;\n\tracl->other_obj = mode & 7;\n}\n\n/* === Rsync ACL functions === */\n\nstatic rsync_acl *create_racl(void)\n{\n\trsync_acl *racl = new(rsync_acl);\n\n\t*racl = empty_rsync_acl;\n\n\treturn racl;\n}\n\nstatic BOOL ida_entries_equal(const ida_entries *ial1, const ida_entries *ial2)\n{\n\tid_access *ida1, *ida2;\n\tint count = ial1->count;\n\tif (count != ial2->count)\n\t\treturn False;\n\tida1 = ial1->idas;\n\tida2 = ial2->idas;\n\tfor (; count--; ida1++, ida2++) {\n\t\tif (ida1->access != ida2->access || ida1->id != ida2->id)\n\t\t\treturn False;\n\t}\n\treturn True;\n}\n\nstatic BOOL rsync_acl_equal(const rsync_acl *racl1, const rsync_acl *racl2)\n{\n\treturn racl1->user_obj == racl2->user_obj\n\t    && racl1->group_obj == racl2->group_obj\n\t    && racl1->mask_obj == racl2->mask_obj\n\t    && racl1->other_obj == racl2->other_obj\n\t    && ida_entries_equal(&racl1->names, &racl2->names);\n}\n\n/* Are the extended (non-permission-bit) entries equal?  If so, the rest of\n * the ACL will be handled by the normal mode-preservation code.  This is\n * only meaningful for access ACLs!  Note: the 1st arg is a fully-populated\n * rsync_acl, but the 2nd parameter can be a condensed rsync_acl, which means\n * that it might have several of its permission objects set to NO_ENTRY. */\nstatic BOOL rsync_acl_equal_enough(const rsync_acl *racl1,\n\t\t\t\t   const rsync_acl *racl2, mode_t m)\n{\n\tif ((racl1->mask_obj ^ racl2->mask_obj) & NO_ENTRY)\n\t\treturn False; /* One has a mask and the other doesn't */\n\n\t/* When there's a mask, the group_obj becomes an extended entry. */\n\tif (racl1->mask_obj != NO_ENTRY) {\n\t\t/* A condensed rsync_acl with a mask can only have no\n\t\t * group_obj when it was identical to the mask.  This\n\t\t * means that it was also identical to the group attrs\n\t\t * from the mode. */\n\t\tif (racl2->group_obj == NO_ENTRY) {\n\t\t\tif (racl1->group_obj != ((m >> 3) & 7))\n\t\t\t\treturn False;\n\t\t} else if (racl1->group_obj != racl2->group_obj)\n\t\t\treturn False;\n\t}\n\treturn ida_entries_equal(&racl1->names, &racl2->names);\n}\n\nstatic void rsync_acl_free(rsync_acl *racl)\n{\n\tif (racl->names.idas)\n\t\tfree(racl->names.idas);\n\t*racl = empty_rsync_acl;\n}\n\nvoid free_acl(stat_x *sxp)\n{\n\tif (sxp->acc_acl) {\n\t\trsync_acl_free(sxp->acc_acl);\n\t\tfree(sxp->acc_acl);\n\t\tsxp->acc_acl = NULL;\n\t}\n\tif (sxp->def_acl) {\n\t\trsync_acl_free(sxp->def_acl);\n\t\tfree(sxp->def_acl);\n\t\tsxp->def_acl = NULL;\n\t}\n}\n\n#ifdef SMB_ACL_NEED_SORT\nstatic int id_access_sorter(const void *r1, const void *r2)\n{\n\tid_access *ida1 = (id_access *)r1;\n\tid_access *ida2 = (id_access *)r2;\n\tid_t rid1 = ida1->id, rid2 = ida2->id;\n\tif ((ida1->access ^ ida2->access) & NAME_IS_USER)\n\t\treturn ida1->access & NAME_IS_USER ? -1 : 1;\n\treturn rid1 == rid2 ? 0 : rid1 < rid2 ? -1 : 1;\n}\n#endif\n\n/* === System ACLs === */\n\n/* Unpack system ACL -> rsync ACL verbatim.  Return whether we succeeded. */\nstatic BOOL unpack_smb_acl(SMB_ACL_T sacl, rsync_acl *racl)\n{\n\tstatic item_list temp_ida_list = EMPTY_ITEM_LIST;\n\tSMB_ACL_ENTRY_T entry;\n\tconst char *errfun;\n\tint rc;\n\n\terrfun = \"sys_acl_get_entry\";\n\tfor (rc = sys_acl_get_entry(sacl, SMB_ACL_FIRST_ENTRY, &entry);\n\t     rc == 1;\n\t     rc = sys_acl_get_entry(sacl, SMB_ACL_NEXT_ENTRY, &entry)) {\n\t\tSMB_ACL_TAG_T tag_type;\n\t\tuint32 access;\n\t\tid_t g_u_id;\n\t\tid_access *ida;\n\t\tif ((rc = sys_acl_get_info(entry, &tag_type, &access, &g_u_id)) != 0) {\n\t\t\terrfun = \"sys_acl_get_info\";\n\t\t\tbreak;\n\t\t}\n\t\t/* continue == done with entry; break == store in temporary ida list */\n\t\tswitch (tag_type) {\n#ifndef HAVE_OSX_ACLS\n\t\tcase SMB_ACL_USER_OBJ:\n\t\t\tif (racl->user_obj == NO_ENTRY)\n\t\t\t\tracl->user_obj = access;\n\t\t\telse\n\t\t\t\trprintf(FINFO, \"unpack_smb_acl: warning: duplicate USER_OBJ entry ignored\\n\");\n\t\t\tcontinue;\n\t\tcase SMB_ACL_GROUP_OBJ:\n\t\t\tif (racl->group_obj == NO_ENTRY)\n\t\t\t\tracl->group_obj = access;\n\t\t\telse\n\t\t\t\trprintf(FINFO, \"unpack_smb_acl: warning: duplicate GROUP_OBJ entry ignored\\n\");\n\t\t\tcontinue;\n\t\tcase SMB_ACL_MASK:\n\t\t\tif (racl->mask_obj == NO_ENTRY)\n\t\t\t\tracl->mask_obj = access;\n\t\t\telse\n\t\t\t\trprintf(FINFO, \"unpack_smb_acl: warning: duplicate MASK entry ignored\\n\");\n\t\t\tcontinue;\n\t\tcase SMB_ACL_OTHER:\n\t\t\tif (racl->other_obj == NO_ENTRY)\n\t\t\t\tracl->other_obj = access;\n\t\t\telse\n\t\t\t\trprintf(FINFO, \"unpack_smb_acl: warning: duplicate OTHER entry ignored\\n\");\n\t\t\tcontinue;\n#endif\n\t\tcase SMB_ACL_USER:\n\t\t\taccess |= NAME_IS_USER;\n\t\t\tbreak;\n\t\tcase SMB_ACL_GROUP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trprintf(FINFO, \"unpack_smb_acl: warning: entry with unrecognized tag type ignored\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tida = EXPAND_ITEM_LIST(&temp_ida_list, id_access, -10);\n\t\tida->id = g_u_id;\n\t\tida->access = access;\n\t}\n\tif (rc) {\n\t\trsyserr(FERROR_XFER, errno, \"unpack_smb_acl: %s()\", errfun);\n\t\trsync_acl_free(racl);\n\t\treturn False;\n\t}\n\n\t/* Transfer the count id_access items out of the temp_ida_list\n\t * into the names ida_entries list in racl. */\n\tif (temp_ida_list.count) {\n#ifdef SMB_ACL_NEED_SORT\n\t\tif (temp_ida_list.count > 1) {\n\t\t\tqsort(temp_ida_list.items, temp_ida_list.count, sizeof (id_access), id_access_sorter);\n\t\t}\n#endif\n\t\tracl->names.idas = new_array(id_access, temp_ida_list.count);\n\t\tmemcpy(racl->names.idas, temp_ida_list.items, temp_ida_list.count * sizeof (id_access));\n\t} else\n\t\tracl->names.idas = NULL;\n\n\tracl->names.count = temp_ida_list.count;\n\n\t/* Truncate the temporary list now that its idas have been saved. */\n\ttemp_ida_list.count = 0;\n\n\treturn True;\n}\n\n/* Synactic sugar for system calls */\n\n#define CALL_OR_ERROR(func,args,str) \\\n\tdo { \\\n\t\tif (func args) { \\\n\t\t\terrfun = str; \\\n\t\t\tgoto error_exit; \\\n\t\t} \\\n\t} while (0)\n\n#define COE(func,args) CALL_OR_ERROR(func,args,#func)\n#define COE2(func,args) CALL_OR_ERROR(func,args,NULL)\n\n#ifndef HAVE_OSX_ACLS\n/* Store the permissions in the system ACL entry. */\nstatic int store_access_in_entry(uint32 access, SMB_ACL_ENTRY_T entry)\n{\n\tif (sys_acl_set_access_bits(entry, access)) {\n\t\trsyserr(FERROR_XFER, errno, \"store_access_in_entry sys_acl_set_access_bits()\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif\n\n/* Pack rsync ACL -> system ACL verbatim.  Return whether we succeeded. */\nstatic BOOL pack_smb_acl(SMB_ACL_T *smb_acl, const rsync_acl *racl)\n{\n#ifdef ACLS_NEED_MASK\n\tuchar mask_bits;\n#endif\n\tsize_t count;\n\tid_access *ida;\n\tconst char *errfun = NULL;\n\tSMB_ACL_ENTRY_T entry;\n\n\tif (!(*smb_acl = sys_acl_init(calc_sacl_entries(racl)))) {\n\t\trsyserr(FERROR_XFER, errno, \"pack_smb_acl: sys_acl_init()\");\n\t\treturn False;\n\t}\n\n#ifndef HAVE_OSX_ACLS\n\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\tCOE( sys_acl_set_info,(entry, SMB_ACL_USER_OBJ, racl->user_obj & ~NO_ENTRY, 0) );\n#endif\n\n\tfor (ida = racl->names.idas, count = racl->names.count; count; ida++, count--) {\n#ifdef SMB_ACL_NEED_SORT\n\t\tif (!(ida->access & NAME_IS_USER))\n\t\t\tbreak;\n#endif\n\t\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\t\tCOE( sys_acl_set_info,\n\t\t    (entry,\n\t\t     ida->access & NAME_IS_USER ? SMB_ACL_USER : SMB_ACL_GROUP,\n\t\t     ida->access & ~NAME_IS_USER, ida->id) );\n\t}\n\n#ifndef HAVE_OSX_ACLS\n\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\tCOE( sys_acl_set_info,(entry, SMB_ACL_GROUP_OBJ, racl->group_obj & ~NO_ENTRY, 0) );\n\n#ifdef SMB_ACL_NEED_SORT\n\tfor ( ; count; ida++, count--) {\n\t\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\t\tCOE( sys_acl_set_info,(entry, SMB_ACL_GROUP, ida->access, ida->id) );\n\t}\n#endif\n\n#ifdef ACLS_NEED_MASK\n\tmask_bits = racl->mask_obj == NO_ENTRY ? racl->group_obj & ~NO_ENTRY : racl->mask_obj;\n\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\tCOE( sys_acl_set_info,(entry, SMB_ACL_MASK, mask_bits, 0) );\n#else\n\tif (racl->mask_obj != NO_ENTRY) {\n\t\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\t\tCOE( sys_acl_set_info,(entry, SMB_ACL_MASK, racl->mask_obj, 0) );\n\t}\n#endif\n\n\tCOE( sys_acl_create_entry,(smb_acl, &entry) );\n\tCOE( sys_acl_set_info,(entry, SMB_ACL_OTHER, racl->other_obj & ~NO_ENTRY, 0) );\n#endif\n\n#ifdef DEBUG\n\tif (sys_acl_valid(*smb_acl) < 0)\n\t\trprintf(FERROR_XFER, \"pack_smb_acl: warning: system says the ACL I packed is invalid\\n\");\n#endif\n\n\treturn True;\n\n  error_exit:\n\tif (errfun) {\n\t\trsyserr(FERROR_XFER, errno, \"pack_smb_acl %s()\", errfun);\n\t}\n\tsys_acl_free_acl(*smb_acl);\n\treturn False;\n}\n\nstatic int find_matching_rsync_acl(const rsync_acl *racl, SMB_ACL_TYPE_T type,\n\t\t\t\t   const item_list *racl_list)\n{\n\tstatic int access_match = -1, default_match = -1;\n\tint *match = type == SMB_ACL_TYPE_ACCESS ? &access_match : &default_match;\n\tsize_t count = racl_list->count;\n\n\t/* If this is the first time through or we didn't match the last\n\t * time, then start at the end of the list, which should be the\n\t * best place to start hunting. */\n\tif (*match == -1)\n\t\t*match = racl_list->count - 1;\n\twhile (count--) {\n\t\trsync_acl *base = racl_list->items;\n\t\tif (rsync_acl_equal(base + *match, racl))\n\t\t\treturn *match;\n\t\tif (!(*match)--)\n\t\t\t*match = racl_list->count - 1;\n\t}\n\n\t*match = -1;\n\treturn *match;\n}\n\nstatic int get_rsync_acl(const char *fname, rsync_acl *racl,\n\t\t\t SMB_ACL_TYPE_T type, mode_t mode)\n{\n\tSMB_ACL_T sacl;\n\n#ifdef SUPPORT_XATTRS\n\t/* --fake-super support: load ACLs from an xattr. */\n\tif (am_root < 0) {\n\t\tchar *buf;\n\t\tsize_t len;\n\t\tint cnt;\n\n\t\tif ((buf = get_xattr_acl(fname, type == SMB_ACL_TYPE_ACCESS, &len)) == NULL)\n\t\t\treturn 0;\n\t\tcnt = (len - 4*4) / (4+4);\n\t\tif (len < 4*4 || len != (size_t)cnt*(4+4) + 4*4) {\n\t\t\tfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tracl->user_obj = IVAL(buf, 0);\n\t\tif (racl->user_obj == NO_ENTRY)\n\t\t\tracl->user_obj = (mode >> 6) & 7;\n\t\tracl->group_obj = IVAL(buf, 4);\n\t\tif (racl->group_obj == NO_ENTRY)\n\t\t\tracl->group_obj = (mode >> 3) & 7;\n\t\tracl->mask_obj = IVAL(buf, 8);\n\t\tracl->other_obj = IVAL(buf, 12);\n\t\tif (racl->other_obj == NO_ENTRY)\n\t\t\tracl->other_obj = mode & 7;\n\n\t\tif (cnt) {\n\t\t\tchar *bp = buf + 4*4;\n\t\t\tid_access *ida = racl->names.idas = new_array(id_access, cnt);\n\t\t\tracl->names.count = cnt;\n\t\t\tfor ( ; cnt--; ida++, bp += 4+4) {\n\t\t\t\tida->id = IVAL(bp, 0);\n\t\t\t\tida->access = IVAL(bp, 4);\n\t\t\t}\n\t\t}\n\t\tfree(buf);\n\t\treturn 0;\n\t}\n#endif\n\n\tif ((sacl = sys_acl_get_file(fname, type)) != 0) {\n\t\tBOOL ok = unpack_smb_acl(sacl, racl);\n\n\t\tsys_acl_free_acl(sacl);\n\t\tif (!ok) {\n\t\t\trsyserr(FERROR_XFER, errno, \"get_acl: unpack_smb_acl(%s)\", fname);\n\t\t\treturn -1;\n\t\t}\n\t} else if (no_acl_syscall_error(errno)) {\n\t\t/* ACLs are not supported, so pretend we have a basic ACL. */\n\t\tif (type == SMB_ACL_TYPE_ACCESS)\n\t\t\trsync_acl_fake_perms(racl, mode);\n\t} else {\n\t\trsyserr(FERROR_XFER, errno, \"get_acl: sys_acl_get_file(%s, %s)\",\n\t\t\tfname, str_acl_type(type));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* Return the Access Control List for the given filename. */\nint get_acl(const char *fname, stat_x *sxp)\n{\n\tsxp->acc_acl = create_racl();\n\n\tif (S_ISREG(sxp->st.st_mode) || S_ISDIR(sxp->st.st_mode)) {\n\t\t/* Everyone supports this. */\n\t} else if (S_ISLNK(sxp->st.st_mode)) {\n\t\treturn 0;\n\t} else if (IS_SPECIAL(sxp->st.st_mode)) {\n#ifndef NO_SPECIAL_ACLS\n\t\tif (!preserve_specials)\n#endif\n\t\t\treturn 0;\n\t} else if (IS_DEVICE(sxp->st.st_mode)) {\n#ifndef NO_DEVICE_ACLS\n\t\tif (!preserve_devices)\n#endif\n\t\t\treturn 0;\n\t} else if (IS_MISSING_FILE(sxp->st))\n\t\treturn 0;\n\n\tif (get_rsync_acl(fname, sxp->acc_acl, SMB_ACL_TYPE_ACCESS,\n\t\t\t  sxp->st.st_mode) < 0) {\n\t\tfree_acl(sxp);\n\t\treturn -1;\n\t}\n\n\tif (S_ISDIR(sxp->st.st_mode)) {\n\t\tsxp->def_acl = create_racl();\n\t\tif (get_rsync_acl(fname, sxp->def_acl, SMB_ACL_TYPE_DEFAULT,\n\t\t\t\t  sxp->st.st_mode) < 0) {\n\t\t\tfree_acl(sxp);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* === Send functions === */\n\n/* Send the ida list over the file descriptor. */\nstatic void send_ida_entries(int f, const ida_entries *idal)\n{\n\tid_access *ida;\n\tsize_t count = idal->count;\n\n\twrite_varint(f, idal->count);\n\n\tfor (ida = idal->idas; count--; ida++) {\n\t\tuint32 xbits = ida->access << 2;\n\t\tconst char *name;\n\t\tif (ida->access & NAME_IS_USER) {\n\t\t\txbits |= XFLAG_NAME_IS_USER;\n\t\t\tname = numeric_ids ? NULL : add_uid(ida->id);\n\t\t} else\n\t\t\tname = numeric_ids ? NULL : add_gid(ida->id);\n\t\twrite_varint(f, ida->id);\n\t\tif (inc_recurse && name) {\n\t\t\tint len = strlen(name);\n\t\t\twrite_varint(f, xbits | XFLAG_NAME_FOLLOWS);\n\t\t\twrite_byte(f, len);\n\t\t\twrite_buf(f, name, len);\n\t\t} else\n\t\t\twrite_varint(f, xbits);\n\t}\n}\n\nstatic void send_rsync_acl(int f, rsync_acl *racl, SMB_ACL_TYPE_T type,\n\t\t\t   item_list *racl_list)\n{\n\tint ndx = find_matching_rsync_acl(racl, type, racl_list);\n\n\t/* Send 0 (-1 + 1) to indicate that literal ACL data follows. */\n\twrite_varint(f, ndx + 1);\n\n\tif (ndx < 0) {\n\t\trsync_acl *new_racl = EXPAND_ITEM_LIST(racl_list, rsync_acl, 1000);\n\t\tuchar flags = 0;\n\n\t\tif (racl->user_obj != NO_ENTRY)\n\t\t\tflags |= XMIT_USER_OBJ;\n\t\tif (racl->group_obj != NO_ENTRY)\n\t\t\tflags |= XMIT_GROUP_OBJ;\n\t\tif (racl->mask_obj != NO_ENTRY)\n\t\t\tflags |= XMIT_MASK_OBJ;\n\t\tif (racl->other_obj != NO_ENTRY)\n\t\t\tflags |= XMIT_OTHER_OBJ;\n\t\tif (racl->names.count)\n\t\t\tflags |= XMIT_NAME_LIST;\n\n\t\twrite_byte(f, flags);\n\n\t\tif (flags & XMIT_USER_OBJ)\n\t\t\twrite_varint(f, racl->user_obj);\n\t\tif (flags & XMIT_GROUP_OBJ)\n\t\t\twrite_varint(f, racl->group_obj);\n\t\tif (flags & XMIT_MASK_OBJ)\n\t\t\twrite_varint(f, racl->mask_obj);\n\t\tif (flags & XMIT_OTHER_OBJ)\n\t\t\twrite_varint(f, racl->other_obj);\n\t\tif (flags & XMIT_NAME_LIST)\n\t\t\tsend_ida_entries(f, &racl->names);\n\n\t\t/* Give the allocated data to the new list object. */\n\t\t*new_racl = *racl;\n\t\t*racl = empty_rsync_acl;\n\t}\n}\n\n/* Send the ACL from the stat_x structure down the indicated file descriptor.\n * This also frees the ACL data. */\nvoid send_acl(int f, stat_x *sxp)\n{\n\tif (!sxp->acc_acl) {\n\t\tsxp->acc_acl = create_racl();\n\t\trsync_acl_fake_perms(sxp->acc_acl, sxp->st.st_mode);\n\t}\n\t/* Avoid sending values that can be inferred from other data. */\n\trsync_acl_strip_perms(sxp);\n\n\tsend_rsync_acl(f, sxp->acc_acl, SMB_ACL_TYPE_ACCESS, &access_acl_list);\n\n\tif (S_ISDIR(sxp->st.st_mode)) {\n\t\tif (!sxp->def_acl)\n\t\t\tsxp->def_acl = create_racl();\n\n\t\tsend_rsync_acl(f, sxp->def_acl, SMB_ACL_TYPE_DEFAULT, &default_acl_list);\n\t}\n}\n\n/* === Receive functions === */\n\nstatic uint32 recv_acl_access(int f, uchar *name_follows_ptr)\n{\n\tuint32 access = read_varint(f);\n\n\tif (name_follows_ptr) {\n\t\tint flags = access & 3;\n\t\taccess >>= 2;\n\t\tif (am_root >= 0 && access & ~SMB_ACL_VALID_NAME_BITS)\n\t\t\tgoto value_error;\n\t\tif (flags & XFLAG_NAME_FOLLOWS)\n\t\t\t*name_follows_ptr = 1;\n\t\telse\n\t\t\t*name_follows_ptr = 0;\n\t\tif (flags & XFLAG_NAME_IS_USER)\n\t\t\taccess |= NAME_IS_USER;\n\t} else if (am_root >= 0 && access & ~SMB_ACL_VALID_OBJ_BITS) {\n\t  value_error:\n\t\trprintf(FERROR_XFER, \"recv_acl_access: value out of range: %x\\n\",\n\t\t\taccess);\n\t\texit_cleanup(RERR_STREAMIO);\n\t}\n\n\treturn access;\n}\n\nstatic uchar recv_ida_entries(int f, ida_entries *ent)\n{\n\tuchar computed_mask_bits = 0;\n\tint i, count = read_varint(f);\n\n\tent->idas = count ? new_array(id_access, count) : NULL;\n\tent->count = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tuchar has_name;\n\t\tid_t id = read_varint(f);\n\t\tuint32 access = recv_acl_access(f, &has_name);\n\n\t\tif (has_name) {\n\t\t\tif (access & NAME_IS_USER)\n\t\t\t\tid = recv_user_name(f, id);\n\t\t\telse\n\t\t\t\tid = recv_group_name(f, id, NULL);\n\t\t} else if (access & NAME_IS_USER) {\n\t\t\tif (inc_recurse && am_root && !numeric_ids)\n\t\t\t\tid = match_uid(id);\n\t\t} else {\n\t\t\tif (inc_recurse && (!am_root || !numeric_ids))\n\t\t\t\tid = match_gid(id, NULL);\n\t\t}\n\n\t\tent->idas[i].id = id;\n\t\tent->idas[i].access = access;\n\t\tcomputed_mask_bits |= access;\n\t}\n\n\treturn computed_mask_bits & ~NO_ENTRY;\n}\n\nstatic int recv_rsync_acl(int f, item_list *racl_list, SMB_ACL_TYPE_T type, mode_t mode)\n{\n\tuchar computed_mask_bits = 0;\n\tacl_duo *duo_item;\n\tuchar flags;\n\tint ndx = read_varint(f);\n\n\tif (ndx < 0 || (size_t)ndx > racl_list->count) {\n\t\trprintf(FERROR_XFER, \"recv_acl_index: %s ACL index %d > %d\\n\",\n\t\t\tstr_acl_type(type), ndx, (int)racl_list->count);\n\t\texit_cleanup(RERR_STREAMIO);\n\t}\n\n\tif (ndx != 0)\n\t\treturn ndx - 1;\n\n\tndx = racl_list->count;\n\tduo_item = EXPAND_ITEM_LIST(racl_list, acl_duo, 1000);\n\tduo_item->racl = empty_rsync_acl;\n\n\tflags = read_byte(f);\n\n\tif (flags & XMIT_USER_OBJ)\n\t\tduo_item->racl.user_obj = recv_acl_access(f, NULL);\n\tif (flags & XMIT_GROUP_OBJ)\n\t\tduo_item->racl.group_obj = recv_acl_access(f, NULL);\n\tif (flags & XMIT_MASK_OBJ)\n\t\tduo_item->racl.mask_obj = recv_acl_access(f, NULL);\n\tif (flags & XMIT_OTHER_OBJ)\n\t\tduo_item->racl.other_obj = recv_acl_access(f, NULL);\n\tif (flags & XMIT_NAME_LIST)\n\t\tcomputed_mask_bits |= recv_ida_entries(f, &duo_item->racl.names);\n\n#ifdef HAVE_OSX_ACLS\n\t/* If we received a superfluous mask, throw it away. */\n\tduo_item->racl.mask_obj = NO_ENTRY;\n\t(void)mode;\n\t(void)computed_mask_bits;\n#else\n\tif (duo_item->racl.names.count && duo_item->racl.mask_obj == NO_ENTRY) {\n\t\t/* Mask must be non-empty with lists. */\n\t\tif (type == SMB_ACL_TYPE_ACCESS)\n\t\t\tcomputed_mask_bits = (mode >> 3) & 7;\n\t\telse\n\t\t\tcomputed_mask_bits |= duo_item->racl.group_obj & ~NO_ENTRY;\n\t\tduo_item->racl.mask_obj = computed_mask_bits;\n\t}\n#endif\n\n\tduo_item->sacl = NULL;\n\n\treturn ndx;\n}\n\n/* Receive the ACL info the sender has included for this file-list entry. */\nvoid receive_acl(int f, struct file_struct *file)\n{\n\tF_ACL(file) = recv_rsync_acl(f, &access_acl_list, SMB_ACL_TYPE_ACCESS, file->mode);\n\n\tif (S_ISDIR(file->mode))\n\t\tF_DIR_DEFACL(file) = recv_rsync_acl(f, &default_acl_list, SMB_ACL_TYPE_DEFAULT, 0);\n}\n\nstatic int cache_rsync_acl(rsync_acl *racl, SMB_ACL_TYPE_T type, item_list *racl_list)\n{\n\tint ndx;\n\n\tif (!racl)\n\t\tndx = -1;\n\telse if ((ndx = find_matching_rsync_acl(racl, type, racl_list)) == -1) {\n\t\tacl_duo *new_duo;\n\t\tndx = racl_list->count;\n\t\tnew_duo = EXPAND_ITEM_LIST(racl_list, acl_duo, 1000);\n\t\tnew_duo->racl = *racl;\n\t\tnew_duo->sacl = NULL;\n\t\t*racl = empty_rsync_acl;\n\t}\n\n\treturn ndx;\n}\n\n/* Turn the ACL data in stat_x into cached ACL data, setting the index\n * values in the file struct. */\nvoid cache_tmp_acl(struct file_struct *file, stat_x *sxp)\n{\n\tif (prior_access_count == (size_t)-1)\n\t\tprior_access_count = access_acl_list.count;\n\n\tF_ACL(file) = cache_rsync_acl(sxp->acc_acl, SMB_ACL_TYPE_ACCESS, &access_acl_list);\n\n\tif (S_ISDIR(sxp->st.st_mode)) {\n\t\tif (prior_default_count == (size_t)-1)\n\t\t\tprior_default_count = default_acl_list.count;\n\t\tF_DIR_DEFACL(file) = cache_rsync_acl(sxp->def_acl, SMB_ACL_TYPE_DEFAULT, &default_acl_list);\n\t}\n}\n\nstatic void uncache_duo_acls(item_list *duo_list, size_t start)\n{\n\tacl_duo *duo_item = duo_list->items;\n\tacl_duo *duo_start = duo_item + start;\n\n\tduo_item += duo_list->count;\n\tduo_list->count = start;\n\n\twhile (duo_item-- > duo_start) {\n\t\trsync_acl_free(&duo_item->racl);\n\t\tif (duo_item->sacl)\n\t\t\tsys_acl_free_acl(duo_item->sacl);\n\t}\n}\n\nvoid uncache_tmp_acls(void)\n{\n\tif (prior_access_count != (size_t)-1) {\n\t\tuncache_duo_acls(&access_acl_list, prior_access_count);\n\t\tprior_access_count = (size_t)-1;\n\t}\n\n\tif (prior_default_count != (size_t)-1) {\n\t\tuncache_duo_acls(&default_acl_list, prior_default_count);\n\t\tprior_default_count = (size_t)-1;\n\t}\n}\n\n#ifndef HAVE_OSX_ACLS\nstatic mode_t change_sacl_perms(SMB_ACL_T sacl, rsync_acl *racl, mode_t old_mode, mode_t mode)\n{\n\tSMB_ACL_ENTRY_T entry;\n\tconst char *errfun;\n\tint rc;\n\n\tif (S_ISDIR(mode)) {\n\t\t/* If the sticky bit is going on, it's not safe to allow all\n\t\t * the new ACL to go into effect before it gets set. */\n#ifdef SMB_ACL_LOSES_SPECIAL_MODE_BITS\n\t\tif (mode & S_ISVTX)\n\t\t\tmode &= ~0077;\n#else\n\t\tif (mode & S_ISVTX && !(old_mode & S_ISVTX))\n\t\t\tmode &= ~0077;\n\t} else {\n\t\t/* If setuid or setgid is going off, it's not safe to allow all\n\t\t * the new ACL to go into effect before they get cleared. */\n\t\tif ((old_mode & S_ISUID && !(mode & S_ISUID))\n\t\t || (old_mode & S_ISGID && !(mode & S_ISGID)))\n\t\t\tmode &= ~0077;\n#endif\n\t}\n\n\terrfun = \"sys_acl_get_entry\";\n\tfor (rc = sys_acl_get_entry(sacl, SMB_ACL_FIRST_ENTRY, &entry);\n\t     rc == 1;\n\t     rc = sys_acl_get_entry(sacl, SMB_ACL_NEXT_ENTRY, &entry)) {\n\t\tSMB_ACL_TAG_T tag_type;\n\t\tif ((rc = sys_acl_get_tag_type(entry, &tag_type)) != 0) {\n\t\t\terrfun = \"sys_acl_get_tag_type\";\n\t\t\tbreak;\n\t\t}\n\t\tswitch (tag_type) {\n\t\tcase SMB_ACL_USER_OBJ:\n\t\t\tCOE2( store_access_in_entry,((mode >> 6) & 7, entry) );\n\t\t\tbreak;\n\t\tcase SMB_ACL_GROUP_OBJ:\n\t\t\t/* group is only empty when identical to group perms. */\n\t\t\tif (racl->group_obj != NO_ENTRY)\n\t\t\t\tbreak;\n\t\t\tCOE2( store_access_in_entry,((mode >> 3) & 7, entry) );\n\t\t\tbreak;\n\t\tcase SMB_ACL_MASK:\n#ifndef HAVE_SOLARIS_ACLS\n#ifndef ACLS_NEED_MASK\n\t\t\t/* mask is only empty when we don't need it. */\n\t\t\tif (racl->mask_obj == NO_ENTRY)\n\t\t\t\tbreak;\n#endif\n\t\t\tCOE2( store_access_in_entry,((mode >> 3) & 7, entry) );\n#endif\n\t\t\tbreak;\n\t\tcase SMB_ACL_OTHER:\n\t\t\tCOE2( store_access_in_entry,(mode & 7, entry) );\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc) {\n\t  error_exit:\n\t\tif (errfun) {\n\t\t\trsyserr(FERROR_XFER, errno, \"change_sacl_perms: %s()\",\n\t\t\t\terrfun);\n\t\t}\n\t\treturn (mode_t)-1;\n\t}\n\n#ifdef SMB_ACL_LOSES_SPECIAL_MODE_BITS\n\t/* Ensure that chmod() will be called to restore any lost setid bits. */\n\tif (old_mode & (S_ISUID | S_ISGID | S_ISVTX)\n\t && BITS_EQUAL(old_mode, mode, CHMOD_BITS))\n\t\told_mode &= ~(S_ISUID | S_ISGID | S_ISVTX);\n#endif\n\n\t/* Return the mode of the file on disk, as we will set them. */\n\treturn (old_mode & ~ACCESSPERMS) | (mode & ACCESSPERMS);\n}\n#endif\n\nstatic int set_rsync_acl(const char *fname, acl_duo *duo_item,\n\t\t\t SMB_ACL_TYPE_T type, stat_x *sxp, mode_t mode)\n{\n\tif (type == SMB_ACL_TYPE_DEFAULT\n\t && duo_item->racl.user_obj == NO_ENTRY) {\n\t\tint rc;\n#ifdef SUPPORT_XATTRS\n\t\t/* --fake-super support: delete default ACL from xattrs. */\n\t\tif (am_root < 0)\n\t\t\trc = del_def_xattr_acl(fname);\n\t\telse\n#endif\n\t\t\trc = sys_acl_delete_def_file(fname);\n\t\tif (rc < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"set_acl: sys_acl_delete_def_file(%s)\",\n\t\t\t\tfname);\n\t\t\treturn -1;\n\t\t}\n#ifdef SUPPORT_XATTRS\n\t} else if (am_root < 0) {\n\t\t/* --fake-super support: store ACLs in an xattr. */\n\t\tint cnt = duo_item->racl.names.count;\n\t\tsize_t len = 4*4 + cnt * (4+4);\n\t\tchar *buf = new_array(char, len);\n\t\tint rc;\n\n\t\tSIVAL(buf, 0, duo_item->racl.user_obj);\n\t\tSIVAL(buf, 4, duo_item->racl.group_obj);\n\t\tSIVAL(buf, 8, duo_item->racl.mask_obj);\n\t\tSIVAL(buf, 12, duo_item->racl.other_obj);\n\n\t\tif (cnt) {\n\t\t\tchar *bp = buf + 4*4;\n\t\t\tid_access *ida = duo_item->racl.names.idas;\n\t\t\tfor ( ; cnt--; ida++, bp += 4+4) {\n\t\t\t\tSIVAL(bp, 0, ida->id);\n\t\t\t\tSIVAL(bp, 4, ida->access);\n\t\t\t}\n\t\t}\n\t\trc = set_xattr_acl(fname, type == SMB_ACL_TYPE_ACCESS, buf, len);\n\t\tfree(buf);\n\t\treturn rc;\n#endif\n\t} else {\n\t\tmode_t cur_mode = sxp->st.st_mode;\n\t\tif (!duo_item->sacl\n\t\t && !pack_smb_acl(&duo_item->sacl, &duo_item->racl))\n\t\t\treturn -1;\n#ifdef HAVE_OSX_ACLS\n\t\t(void)mode; /* eliminate compiler warning */\n#else\n\t\tif (type == SMB_ACL_TYPE_ACCESS) {\n\t\t\tcur_mode = change_sacl_perms(duo_item->sacl, &duo_item->racl, cur_mode, mode);\n\t\t\tif (cur_mode == (mode_t)-1)\n\t\t\t\treturn 0;\n\t\t}\n#endif\n\t\tif (sys_acl_set_file(fname, type, duo_item->sacl) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"set_acl: sys_acl_set_file(%s, %s)\",\n\t\t\t\tfname, str_acl_type(type));\n\t\t\treturn -1;\n\t\t}\n\t\tif (type == SMB_ACL_TYPE_ACCESS)\n\t\t\tsxp->st.st_mode = cur_mode;\n\t}\n\n\treturn 0;\n}\n\n/* Given a fname, this sets extended access ACL entries, the default ACL (for a\n * dir), and the regular mode bits on the file.  Call this with fname set to\n * NULL to just check if the ACL is different.\n *\n * If the ACL operation has a side-effect of changing the file's mode, the\n * sxp->st.st_mode value will be changed to match.\n *\n * Returns 0 for an unchanged ACL, 1 for changed, -1 for failed. */\nint set_acl(const char *fname, const struct file_struct *file, stat_x *sxp, mode_t new_mode)\n{\n\tint changed = 0;\n\tint32 ndx;\n\tBOOL eq;\n\n\tif (!dry_run && (read_only || list_only)) {\n\t\terrno = EROFS;\n\t\treturn -1;\n\t}\n\n\tndx = F_ACL(file);\n\tif (ndx >= 0 && (size_t)ndx < access_acl_list.count) {\n\t\tacl_duo *duo_item = access_acl_list.items;\n\t\tduo_item += ndx;\n\t\teq = sxp->acc_acl\n\t\t  && rsync_acl_equal_enough(sxp->acc_acl, &duo_item->racl, new_mode);\n\t\tif (!eq) {\n\t\t\tchanged = 1;\n\t\t\tif (!dry_run && fname\n\t\t\t && set_rsync_acl(fname, duo_item, SMB_ACL_TYPE_ACCESS,\n\t\t\t\t\t  sxp, new_mode) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!S_ISDIR(new_mode))\n\t\treturn changed;\n\n\tndx = F_DIR_DEFACL(file);\n\tif (ndx >= 0 && (size_t)ndx < default_acl_list.count) {\n\t\tacl_duo *duo_item = default_acl_list.items;\n\t\tduo_item += ndx;\n\t\teq = sxp->def_acl && rsync_acl_equal(sxp->def_acl, &duo_item->racl);\n\t\tif (!eq) {\n\t\t\tchanged = 1;\n\t\t\tif (!dry_run && fname\n\t\t\t && set_rsync_acl(fname, duo_item, SMB_ACL_TYPE_DEFAULT,\n\t\t\t\t\t  sxp, new_mode) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn changed;\n}\n\n/* Non-incremental recursion needs to convert all the received IDs.\n * This is done in a single pass after receiving the whole file-list. */\nstatic void match_racl_ids(const item_list *racl_list)\n{\n\tint list_cnt, name_cnt;\n\tacl_duo *duo_item = racl_list->items;\n\tfor (list_cnt = racl_list->count; list_cnt--; duo_item++) {\n\t\tida_entries *idal = &duo_item->racl.names;\n\t\tid_access *ida = idal->idas;\n\t\tfor (name_cnt = idal->count; name_cnt--; ida++) {\n\t\t\tif (ida->access & NAME_IS_USER)\n\t\t\t\tida->id = match_uid(ida->id);\n\t\t\telse\n\t\t\t\tida->id = match_gid(ida->id, NULL);\n\t\t}\n\t}\n}\n\nvoid match_acl_ids(void)\n{\n\tmatch_racl_ids(&access_acl_list);\n\tmatch_racl_ids(&default_acl_list);\n}\n\n/* This is used by dest_mode(). */\nint default_perms_for_dir(const char *dir)\n{\n\trsync_acl racl;\n\tSMB_ACL_T sacl;\n\tBOOL ok;\n\tint perms;\n\n\tif (dir == NULL)\n\t\tdir = \".\";\n\tperms = ACCESSPERMS & ~orig_umask;\n\t/* Read the directory's default ACL.  If it has none, this will successfully return an empty ACL. */\n\tsacl = sys_acl_get_file(dir, SMB_ACL_TYPE_DEFAULT);\n\tif (sacl == NULL) {\n\t\t/* Couldn't get an ACL.  Darn. */\n\t\tswitch (errno) {\n\t\tcase EINVAL:\n\t\t\t/* If SMB_ACL_TYPE_DEFAULT isn't valid, then the ACLs must be non-POSIX. */\n\t\t\tbreak;\n#ifdef ENOTSUP\n\t\tcase ENOTSUP:\n#endif\n\t\tcase ENOSYS:\n\t\t\t/* No ACLs are available. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (dry_run && errno == ENOENT) {\n\t\t\t\t/* We're doing a dry run, so the containing directory\n\t\t\t\t * wasn't actually created.  Don't worry about it. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trprintf(FWARNING,\n\t\t\t\t\"default_perms_for_dir: sys_acl_get_file(%s, %s): %s, falling back on umask\\n\",\n\t\t\t\tdir, str_acl_type(SMB_ACL_TYPE_DEFAULT), strerror(errno));\n\t\t}\n\t\treturn perms;\n\t}\n\n\t/* Convert it. */\n\tracl = empty_rsync_acl;\n\tok = unpack_smb_acl(sacl, &racl);\n\tsys_acl_free_acl(sacl);\n\tif (!ok) {\n\t\trprintf(FWARNING, \"default_perms_for_dir: unpack_smb_acl failed, falling back on umask\\n\");\n\t\treturn perms;\n\t}\n\n\t/* Apply the permission-bit entries of the default ACL, if any. */\n\tif (racl.user_obj != NO_ENTRY) {\n\t\tperms = rsync_acl_get_perms(&racl);\n\t\tif (DEBUG_GTE(ACL, 1))\n\t\t\trprintf(FINFO, \"got ACL-based default perms %o for directory %s\\n\", perms, dir);\n\t}\n\n\trsync_acl_free(&racl);\n\treturn perms;\n}\n\n#endif /* SUPPORT_ACLS */\n"
        },
        {
          "name": "authenticate.c",
          "type": "blob",
          "size": 9.81640625,
          "content": "/*\n * Support rsync daemon authentication.\n *\n * Copyright (C) 1998-2000 Andrew Tridgell\n * Copyright (C) 2002-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"ifuncs.h\"\n\nextern int read_only;\nextern char *password_file;\nextern struct name_num_obj valid_auth_checksums;\n\n/***************************************************************************\nencode a buffer using base64 - simple and slow algorithm. null terminates\nthe result.\n  ***************************************************************************/\nvoid base64_encode(const char *buf, int len, char *out, int pad)\n{\n\tchar *b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tint bit_offset, byte_offset, idx, i;\n\tconst uchar *d = (const uchar *)buf;\n\tint bytes = (len*8 + 5)/6;\n\n\tfor (i = 0; i < bytes; i++) {\n\t\tbyte_offset = (i*6)/8;\n\t\tbit_offset = (i*6)%8;\n\t\tif (bit_offset < 3) {\n\t\t\tidx = (d[byte_offset] >> (2-bit_offset)) & 0x3F;\n\t\t} else {\n\t\t\tidx = (d[byte_offset] << (bit_offset-2)) & 0x3F;\n\t\t\tif (byte_offset+1 < len) {\n\t\t\t\tidx |= (d[byte_offset+1] >> (8-(bit_offset-2)));\n\t\t\t}\n\t\t}\n\t\tout[i] = b64[idx];\n\t}\n\n\twhile (pad && (i % 4))\n\t\tout[i++] = '=';\n\n\tout[i] = '\\0';\n}\n\n/* Generate a challenge buffer and return it base64-encoded. */\nstatic void gen_challenge(const char *addr, char *challenge)\n{\n\tchar input[32];\n\tchar digest[MAX_DIGEST_LEN];\n\tstruct timeval tv;\n\tint len;\n\n\tmemset(input, 0, sizeof input);\n\n\tstrlcpy(input, addr, 17);\n\tsys_gettimeofday(&tv);\n\tSIVAL(input, 16, tv.tv_sec);\n\tSIVAL(input, 20, tv.tv_usec);\n\tSIVAL(input, 24, getpid());\n\n\tlen = sum_init(valid_auth_checksums.negotiated_nni, 0);\n\tsum_update(input, sizeof input);\n\tsum_end(digest);\n\n\tbase64_encode(digest, len, challenge, 0);\n}\n\n/* Generate an MD4 hash created from the combination of the password\n * and the challenge string and return it base64-encoded. */\nstatic void generate_hash(const char *in, const char *challenge, char *out)\n{\n\tchar buf[MAX_DIGEST_LEN];\n\tint len;\n\n\tlen = sum_init(valid_auth_checksums.negotiated_nni, 0);\n\tsum_update(in, strlen(in));\n\tsum_update(challenge, strlen(challenge));\n\tsum_end(buf);\n\n\tbase64_encode(buf, len, out, 0);\n}\n\n/* Return the secret for a user from the secret file, null terminated.\n * Maximum length is len (not counting the null). */\nstatic const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n\tchar pass2[MAX_DIGEST_LEN*2];\n\tconst char *fname = lp_secrets_file(module);\n\tSTRUCT_STAT st;\n\tint ok = 1;\n\tint user_len = strlen(user);\n\tint group_len = group ? strlen(group) : 0;\n\tchar *err;\n\tFILE *fh;\n\n\tif (!fname || !*fname || (fh = fopen(fname, \"r\")) == NULL)\n\t\treturn \"no secrets file\";\n\n\tif (do_fstat(fileno(fh), &st) == -1) {\n\t\trsyserr(FLOG, errno, \"fstat(%s)\", fname);\n\t\tok = 0;\n\t} else if (lp_strict_modes(module)) {\n\t\tif ((st.st_mode & 06) != 0) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == ROOT_UID && st.st_uid != ROOT_UID) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tfclose(fh);\n\t\treturn \"ignoring secrets file\";\n\t}\n\n\tif (*user == '#') {\n\t\t/* Reject attempt to match a comment. */\n\t\tfclose(fh);\n\t\treturn \"invalid username\";\n\t}\n\n\t/* Try to find a line that starts with the user (or @group) name and a ':'. */\n\terr = \"secret not found\";\n\twhile ((user || group) && fgets(line, sizeof line, fh) != NULL) {\n\t\tconst char **ptr, *s = strtok(line, \"\\n\\r\");\n\t\tint len;\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tif (*s == '@') {\n\t\t\tptr = &group;\n\t\t\tlen = group_len;\n\t\t\ts++;\n\t\t} else {\n\t\t\tptr = &user;\n\t\t\tlen = user_len;\n\t\t}\n\t\tif (!*ptr || strncmp(s, *ptr, len) != 0 || s[len] != ':')\n\t\t\tcontinue;\n\t\tgenerate_hash(s+len+1, challenge, pass2);\n\t\tif (strcmp(pass, pass2) == 0) {\n\t\t\terr = NULL;\n\t\t\tbreak;\n\t\t}\n\t\terr = \"password mismatch\";\n\t\t*ptr = NULL; /* Don't look for name again. */\n\t}\n\n\tfclose(fh);\n\n\tforce_memzero(line, sizeof line);\n\tforce_memzero(pass2, sizeof pass2);\n\n\treturn err;\n}\n\nstatic const char *getpassf(const char *filename)\n{\n\tSTRUCT_STAT st;\n\tchar buffer[512], *p;\n\tint n;\n\n\tif (!filename)\n\t\treturn NULL;\n\n\tif (strcmp(filename, \"-\") == 0) {\n\t\tn = fgets(buffer, sizeof buffer, stdin) == NULL ? -1 : (int)strlen(buffer);\n\t} else {\n\t\tint fd;\n\n\t\tif ((fd = open(filename,O_RDONLY)) < 0) {\n\t\t\trsyserr(FERROR, errno, \"could not open password file %s\", filename);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\n\t\tif (do_stat(filename, &st) == -1) {\n\t\t\trsyserr(FERROR, errno, \"stat(%s)\", filename);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tif ((st.st_mode & 06) != 0) {\n\t\t\trprintf(FERROR, \"ERROR: password file must not be other-accessible\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tif (MY_UID() == ROOT_UID && st.st_uid != ROOT_UID) {\n\t\t\trprintf(FERROR, \"ERROR: password file must be owned by root when running as root\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\n\t\tn = read(fd, buffer, sizeof buffer - 1);\n\t\tclose(fd);\n\t}\n\n\tif (n > 0) {\n\t\tbuffer[n] = '\\0';\n\t\tif ((p = strtok(buffer, \"\\n\\r\")) != NULL)\n\t\t\treturn strdup(p);\n\t}\n\n\trprintf(FERROR, \"ERROR: failed to read a password from %s\\n\", filename);\n\texit_cleanup(RERR_SYNTAX);\n}\n\n/* Possibly negotiate authentication with the client.  Use \"leader\" to\n * start off the auth if necessary.\n *\n * Return NULL if authentication failed.  Return \"\" if anonymous access.\n * Otherwise return username.\n */\nchar *auth_server(int f_in, int f_out, int module, const char *host,\n\t\t  const char *addr, const char *leader)\n{\n\tchar *users = lp_auth_users(module);\n\tchar challenge[MAX_DIGEST_LEN*2];\n\tchar line[BIGPATHBUFLEN];\n\tconst char **auth_uid_groups = NULL;\n\tint auth_uid_groups_cnt = -1;\n\tconst char *err = NULL;\n\tint group_match = -1;\n\tchar *tok, *pass;\n\tchar opt_ch = '\\0';\n\n\t/* if no auth list then allow anyone in! */\n\tif (!users || !*users)\n\t\treturn \"\";\n\n\tnegotiate_daemon_auth(f_out, 0);\n\tgen_challenge(addr, challenge);\n\n\tio_printf(f_out, \"%s%s\\n\", leader, challenge);\n\n\tif (!read_line_old(f_in, line, sizeof line, 0)\n\t || (pass = strchr(line, ' ')) == NULL) {\n\t\trprintf(FLOG, \"auth failed on module %s from %s (%s): \"\n\t\t\t\"invalid challenge response\\n\",\n\t\t\tlp_name(module), host, addr);\n\t\treturn NULL;\n\t}\n\t*pass++ = '\\0';\n\n\tusers = strdup(users);\n\n\tfor (tok = strtok(users, \" ,\\t\"); tok; tok = strtok(NULL, \" ,\\t\")) {\n\t\tchar *opts;\n\t\t/* See if the user appended :deny, :ro, or :rw. */\n\t\tif ((opts = strchr(tok, ':')) != NULL) {\n\t\t\t*opts++ = '\\0';\n\t\t\topt_ch = isUpper(opts) ? toLower(opts) : *opts;\n\t\t\tif (opt_ch == 'r') { /* handle ro and rw */\n\t\t\t\topt_ch = isUpper(opts+1) ? toLower(opts+1) : opts[1];\n\t\t\t\tif (opt_ch == 'o')\n\t\t\t\t\topt_ch = 'r';\n\t\t\t\telse if (opt_ch != 'w')\n\t\t\t\t\topt_ch = '\\0';\n\t\t\t} else if (opt_ch != 'd') /* if it's not deny, ignore it */\n\t\t\t\topt_ch = '\\0';\n\t\t} else\n\t\t\topt_ch = '\\0';\n\t\tif (*tok != '@') {\n\t\t\t/* Match the username */\n\t\t\tif (wildmatch(tok, line))\n\t\t\t\tbreak;\n\t\t} else {\n#ifdef HAVE_GETGROUPLIST\n\t\t\tint j;\n\t\t\t/* See if authorizing user is a real user, and if so, see\n\t\t\t * if it is in a group that matches tok+1 wildmat. */\n\t\t\tif (auth_uid_groups_cnt < 0) {\n\t\t\t\titem_list gid_list = EMPTY_ITEM_LIST;\n\t\t\t\tuid_t auth_uid;\n\t\t\t\tif (!user_to_uid(line, &auth_uid, False)\n\t\t\t\t || getallgroups(auth_uid, &gid_list) != NULL)\n\t\t\t\t\tauth_uid_groups_cnt = 0;\n\t\t\t\telse {\n\t\t\t\t\tgid_t *gid_array = gid_list.items;\n\t\t\t\t\tauth_uid_groups_cnt = gid_list.count;\n\t\t\t\t\tauth_uid_groups = new_array(const char *, auth_uid_groups_cnt);\n\t\t\t\t\tfor (j = 0; j < auth_uid_groups_cnt; j++)\n\t\t\t\t\t\tauth_uid_groups[j] = gid_to_group(gid_array[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < auth_uid_groups_cnt; j++) {\n\t\t\t\tif (auth_uid_groups[j] && wildmatch(tok+1, auth_uid_groups[j])) {\n\t\t\t\t\tgroup_match = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (group_match >= 0)\n\t\t\t\tbreak;\n#else\n\t\t\trprintf(FLOG, \"your computer doesn't support getgrouplist(), so no @group authorization is possible.\\n\");\n#endif\n\t\t}\n\t}\n\n\tfree(users);\n\n\tif (!tok)\n\t\terr = \"no matching rule\";\n\telse if (opt_ch == 'd')\n\t\terr = \"denied by rule\";\n\telse {\n\t\tconst char *group = group_match >= 0 ? auth_uid_groups[group_match] : NULL;\n\t\terr = check_secret(module, line, group, challenge, pass);\n\t}\n\n\tforce_memzero(challenge, sizeof challenge);\n\tforce_memzero(pass, strlen(pass));\n\n\tif (auth_uid_groups) {\n\t\tint j;\n\t\tfor (j = 0; j < auth_uid_groups_cnt; j++) {\n\t\t\tif (auth_uid_groups[j])\n\t\t\t\tfree((char*)auth_uid_groups[j]);\n\t\t}\n\t\tfree(auth_uid_groups);\n\t}\n\n\tif (err) {\n\t\trprintf(FLOG, \"auth failed on module %s from %s (%s) for %s: %s\\n\",\n\t\t\tlp_name(module), host, addr, line, err);\n\t\treturn NULL;\n\t}\n\n\tif (opt_ch == 'r')\n\t\tread_only = 1;\n\telse if (opt_ch == 'w')\n\t\tread_only = 0;\n\n\treturn strdup(line);\n}\n\nvoid auth_client(int fd, const char *user, const char *challenge)\n{\n\tconst char *pass;\n\tchar pass2[MAX_DIGEST_LEN*2];\n\n\tif (!user || !*user)\n\t\tuser = \"nobody\";\n\tnegotiate_daemon_auth(-1, 1);\n\n\tif (!(pass = getpassf(password_file))\n\t && !(pass = getenv(\"RSYNC_PASSWORD\"))) {\n\t\t/* XXX: cyeoh says that getpass is deprecated, because\n\t\t * it may return a truncated password on some systems,\n\t\t * and it is not in the LSB.\n\t\t *\n\t\t * Andrew Klein says that getpassphrase() is present\n\t\t * on Solaris and reads up to 256 characters.\n\t\t *\n\t\t * OpenBSD has a readpassphrase() that might be more suitable.\n\t\t */\n\t\tpass = getpass(\"Password: \");\n\t}\n\n\tif (!pass)\n\t\tpass = \"\";\n\n\tgenerate_hash(pass, challenge, pass2);\n\tio_printf(fd, \"%s %s\\n\", user, pass2);\n}\n"
        },
        {
          "name": "backup.c",
          "type": "blob",
          "size": 9.1162109375,
          "content": "/*\n * Backup handling code.\n *\n * Copyright (C) 1999 Andrew Tridgell\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n\nextern int am_root;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int preserve_devices;\nextern int preserve_specials;\nextern int preserve_links;\nextern int safe_symlinks;\nextern int backup_dir_len;\nextern unsigned int backup_dir_remainder;\nextern char backup_dir_buf[MAXPATHLEN];\nextern char *backup_suffix;\nextern char *backup_dir;\n\n/* Returns -1 on error, 0 on missing dir, and 1 on present dir. */\nstatic int validate_backup_dir(void)\n{\n\tSTRUCT_STAT st;\n\n\tif (do_lstat(backup_dir_buf, &st) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\trsyserr(FERROR, errno, \"backup lstat %s failed\", backup_dir_buf);\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(st.st_mode)) {\n\t\tint flags = get_del_for_flag(st.st_mode) | DEL_FOR_BACKUP | DEL_RECURSE;\n\t\tif (delete_item(backup_dir_buf, st.st_mode, flags) == 0)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n/* Create a backup path from the given fname, putting the result into\n * backup_dir_buf.  Any new directories (compared to the prior backup\n * path) are ensured to exist as directories, replacing anything else\n * that may be in the way (e.g. a symlink). */\nstatic BOOL copy_valid_path(const char *fname)\n{\n\tconst char *f;\n\tint val;\n\tBOOL ret = True;\n\tstat_x sx;\n\tchar *b, *rel = backup_dir_buf + backup_dir_len, *name = rel;\n\n\tfor (f = fname, b = rel; *f && *f == *b; f++, b++) {\n\t\tif (*b == '/')\n\t\t\tname = b + 1;\n\t}\n\n\tif (stringjoin(rel, backup_dir_remainder, fname, backup_suffix, NULL) >= backup_dir_remainder) {\n\t\trprintf(FERROR, \"backup filename too long\\n\");\n\t\t*name = '\\0';\n\t\treturn False;\n\t}\n\n\tfor ( ; ; name = b + 1) {\n\t\tif ((b = strchr(name, '/')) == NULL)\n\t\t\treturn True;\n\t\t*b = '\\0';\n\n\t\tval = validate_backup_dir();\n\t\tif (val == 0)\n\t\t\tbreak;\n\t\tif (val < 0) {\n\t\t\t*name = '\\0';\n\t\t\treturn False;\n\t\t}\n\n\t\t*b = '/';\n\t}\n\n\tinit_stat_x(&sx);\n\n\tfor ( ; b; name = b + 1, b = strchr(name, '/')) {\n\t\t*b = '\\0';\n\n\t\twhile (do_mkdir(backup_dir_buf, ACCESSPERMS) < 0) {\n\t\t\tif (errno == EEXIST) {\n\t\t\t\tval = validate_backup_dir();\n\t\t\t\tif (val > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (val == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\trsyserr(FERROR, errno, \"backup mkdir %s failed\", backup_dir_buf);\n\t\t\t*name = '\\0';\n\t\t\tret = False;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Try to transfer the directory settings of the actual dir\n\t\t * that the files are coming from. */\n\t\tif (x_stat(rel, &sx.st, NULL) < 0)\n\t\t\trsyserr(FERROR, errno, \"backup stat %s failed\", full_fname(rel));\n\t\telse {\n\t\t\tstruct file_struct *file;\n\t\t\tif (!(file = make_file(rel, NULL, NULL, 0, NO_FILTERS)))\n\t\t\t\tcontinue;\n#ifdef SUPPORT_ACLS\n\t\t\tif (preserve_acls && !S_ISLNK(file->mode)) {\n\t\t\t\tget_acl(rel, &sx);\n\t\t\t\tcache_tmp_acl(file, &sx);\n\t\t\t\tfree_acl(&sx);\n\t\t\t}\n#endif\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs) {\n\t\t\t\tget_xattr(rel, &sx);\n\t\t\t\tcache_tmp_xattr(file, &sx);\n\t\t\t\tfree_xattr(&sx);\n\t\t\t}\n#endif\n\t\t\tset_file_attrs(backup_dir_buf, file, NULL, NULL, 0);\n\t\t\tunmake_file(file);\n\t\t}\n\n\t\t*b = '/';\n\t}\n\n  cleanup:\n\n#ifdef SUPPORT_ACLS\n\tuncache_tmp_acls();\n#endif\n#ifdef SUPPORT_XATTRS\n\tuncache_tmp_xattrs();\n#endif\n\n\treturn ret;\n}\n\n/* Make a complete pathname for backup file and verify any new path elements. */\nchar *get_backup_name(const char *fname)\n{\n\tif (backup_dir) {\n\t\tstatic int initialized = 0;\n\t\tif (!initialized) {\n\t\t\tint ret;\n\t\t\tif (backup_dir_len > 1)\n\t\t\t\tbackup_dir_buf[backup_dir_len-1] = '\\0';\n\t\t\tret = make_path(backup_dir_buf, 0);\n\t\t\tif (backup_dir_len > 1)\n\t\t\t\tbackup_dir_buf[backup_dir_len-1] = '/';\n\t\t\tif (ret < 0)\n\t\t\t\treturn NULL;\n\t\t\tinitialized = 1;\n\t\t}\n\t\t/* copy fname into backup_dir_buf while validating the dirs. */\n\t\tif (copy_valid_path(fname))\n\t\t\treturn backup_dir_buf;\n\t\t/* copy_valid_path() has printed an error message. */\n\t\treturn NULL;\n\t}\n\n\tif (stringjoin(backup_dir_buf, MAXPATHLEN, fname, backup_suffix, NULL) < MAXPATHLEN)\n\t\treturn backup_dir_buf;\n\n\trprintf(FERROR, \"backup filename too long\\n\");\n\treturn NULL;\n}\n\n/* Has same return codes as make_backup(). */\nstatic inline int link_or_rename(const char *from, const char *to,\n\t\t\t\t BOOL prefer_rename, STRUCT_STAT *stp)\n{\n#ifdef SUPPORT_HARD_LINKS\n\tif (!prefer_rename) {\n#ifndef CAN_HARDLINK_SYMLINK\n\t\tif (S_ISLNK(stp->st_mode))\n\t\t\treturn 0; /* Use copy code. */\n#endif\n#ifndef CAN_HARDLINK_SPECIAL\n\t\tif (IS_SPECIAL(stp->st_mode) || IS_DEVICE(stp->st_mode))\n\t\t\treturn 0; /* Use copy code. */\n#endif\n\t\tif (do_link(from, to) == 0) {\n\t\t\tif (DEBUG_GTE(BACKUP, 1))\n\t\t\t\trprintf(FINFO, \"make_backup: HLINK %s successful.\\n\", from);\n\t\t\treturn 2;\n\t\t}\n\t\t/* We prefer to rename a regular file rather than copy it. */\n\t\tif (!S_ISREG(stp->st_mode) || errno == EEXIST || errno == EISDIR)\n\t\t\treturn 0;\n\t}\n#endif\n\tif (do_rename(from, to) == 0) {\n\t\tif (stp->st_nlink > 1 && !S_ISDIR(stp->st_mode)) {\n\t\t\t/* If someone has hard-linked the file into the backup\n\t\t\t * dir, rename() might return success but do nothing! */\n\t\t\trobust_unlink(from); /* Just in case... */\n\t\t}\n\t\tif (DEBUG_GTE(BACKUP, 1))\n\t\t\trprintf(FINFO, \"make_backup: RENAME %s successful.\\n\", from);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Hard-link, rename, or copy an item to the backup name.  Returns 0 for\n * failure, 1 if item was moved, 2 if item was duplicated or hard linked\n * into backup area, or 3 if item doesn't exist or isn't a regular file. */\nint make_backup(const char *fname, BOOL prefer_rename)\n{\n\tstat_x sx;\n\tstruct file_struct *file;\n\tint save_preserve_xattrs;\n\tchar *buf;\n\tint ret = 0;\n\n\tinit_stat_x(&sx);\n\t/* Return success if no file to keep. */\n\tif (x_lstat(fname, &sx.st, NULL) < 0)\n\t\treturn 3;\n\n\tif (!(buf = get_backup_name(fname)))\n\t\treturn 0;\n\n\t/* Try a hard-link or a rename first.  Using rename is not atomic, but\n\t * is more efficient than forcing a copy for larger files when no hard-\n\t * linking is possible. */\n\tif ((ret = link_or_rename(fname, buf, prefer_rename, &sx.st)) != 0)\n\t\tgoto success;\n\tif (errno == EEXIST || errno == EISDIR) {\n\t\tSTRUCT_STAT bakst;\n\t\tif (do_lstat(buf, &bakst) == 0) {\n\t\t\tint flags = get_del_for_flag(bakst.st_mode) | DEL_FOR_BACKUP | DEL_RECURSE;\n\t\t\tif (delete_item(buf, bakst.st_mode, flags) != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif ((ret = link_or_rename(fname, buf, prefer_rename, &sx.st)) != 0)\n\t\t\tgoto success;\n\t}\n\n\t/* Fall back to making a copy. */\n\tif (!(file = make_file(fname, NULL, &sx.st, 0, NO_FILTERS)))\n\t\treturn 3; /* the file could have disappeared */\n\n#ifdef SUPPORT_ACLS\n\tif (preserve_acls && !S_ISLNK(file->mode)) {\n\t\tget_acl(fname, &sx);\n\t\tcache_tmp_acl(file, &sx);\n\t\tfree_acl(&sx);\n\t}\n#endif\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs) {\n\t\tget_xattr(fname, &sx);\n\t\tcache_tmp_xattr(file, &sx);\n\t\tfree_xattr(&sx);\n\t}\n#endif\n\n\t/* Check to see if this is a device file, or link */\n\tif ((am_root && preserve_devices && IS_DEVICE(file->mode))\n\t || (preserve_specials && IS_SPECIAL(file->mode))) {\n\t\tif (do_mknod(buf, file->mode, sx.st.st_rdev) < 0)\n\t\t\trsyserr(FERROR, errno, \"mknod %s failed\", full_fname(buf));\n\t\telse if (DEBUG_GTE(BACKUP, 1))\n\t\t\trprintf(FINFO, \"make_backup: DEVICE %s successful.\\n\", fname);\n\t\tret = 2;\n\t}\n\n#ifdef SUPPORT_LINKS\n\tif (!ret && preserve_links && S_ISLNK(file->mode)) {\n\t\tconst char *sl = F_SYMLINK(file);\n\t\tif (safe_symlinks && unsafe_symlink(sl, fname)) {\n\t\t\tif (INFO_GTE(SYMSAFE, 1)) {\n\t\t\t\trprintf(FINFO, \"not backing up unsafe symlink \\\"%s\\\" -> \\\"%s\\\"\\n\",\n\t\t\t\t\tfname, sl);\n\t\t\t}\n\t\t\tret = 2;\n\t\t} else {\n\t\t\tif (do_symlink(sl, buf) < 0)\n\t\t\t\trsyserr(FERROR, errno, \"link %s -> \\\"%s\\\"\", full_fname(buf), sl);\n\t\t\telse if (DEBUG_GTE(BACKUP, 1))\n\t\t\t\trprintf(FINFO, \"make_backup: SYMLINK %s successful.\\n\", fname);\n\t\t\tret = 2;\n\t\t}\n\t}\n#endif\n\n\tif (!ret && !S_ISREG(file->mode)) {\n\t\tif (INFO_GTE(NONREG, 1))\n\t\t\trprintf(FINFO, \"make_bak: skipping non-regular file %s\\n\", fname);\n\t\tunmake_file(file);\n#ifdef SUPPORT_ACLS\n\t\tuncache_tmp_acls();\n#endif\n#ifdef SUPPORT_XATTRS\n\t\tuncache_tmp_xattrs();\n#endif\n\t\treturn 3;\n\t}\n\n\t/* Copy to backup tree if a file. */\n\tif (!ret) {\n\t\tif (copy_file(fname, buf, -1, file->mode) < 0) {\n\t\t\trsyserr(FERROR, errno, \"keep_backup failed: %s -> \\\"%s\\\"\",\n\t\t\t\tfull_fname(fname), buf);\n\t\t\tunmake_file(file);\n#ifdef SUPPORT_ACLS\n\t\t\tuncache_tmp_acls();\n#endif\n#ifdef SUPPORT_XATTRS\n\t\t\tuncache_tmp_xattrs();\n#endif\n\t\t\treturn 0;\n\t\t}\n\t\tif (DEBUG_GTE(BACKUP, 1))\n\t\t\trprintf(FINFO, \"make_backup: COPY %s successful.\\n\", fname);\n\t\tret = 2;\n\t}\n\n\tsave_preserve_xattrs = preserve_xattrs;\n\tpreserve_xattrs = 0;\n\tset_file_attrs(buf, file, NULL, fname, ATTRS_ACCURATE_TIME);\n\tpreserve_xattrs = save_preserve_xattrs;\n\n\tunmake_file(file);\n#ifdef SUPPORT_ACLS\n\tuncache_tmp_acls();\n#endif\n#ifdef SUPPORT_XATTRS\n\tuncache_tmp_xattrs();\n#endif\n\n  success:\n\tif (INFO_GTE(BACKUP, 1))\n\t\trprintf(FINFO, \"backed up %s to %s\\n\", fname, buf);\n\treturn ret;\n}\n"
        },
        {
          "name": "batch.c",
          "type": "blob",
          "size": 7.873046875,
          "content": "/*\n * Support for the batch-file options.\n *\n * Copyright (C) 1999 Weiss\n * Copyright (C) 2004 Chris Shoemaker\n * Copyright (C) 2004-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include <zlib.h>\n#include <time.h>\n\nextern int eol_nulls;\nextern int recurse;\nextern int xfer_dirs;\nextern int preserve_links;\nextern int preserve_hard_links;\nextern int preserve_devices;\nextern int preserve_uid;\nextern int preserve_gid;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int always_checksum;\nextern int do_compression;\nextern int inplace;\nextern int append_mode;\nextern int write_batch;\nextern int protocol_version;\nextern int raw_argc, cooked_argc;\nextern char **raw_argv, **cooked_argv;\nextern char *batch_name;\n#ifdef ICONV_OPTION\nextern char *iconv_opt;\n#endif\n\nextern filter_rule_list filter_list;\n\nint batch_fd = -1;\nint batch_sh_fd = -1;\nint batch_stream_flags;\n\nstatic int tweaked_append;\nstatic int tweaked_append_verify;\nstatic int tweaked_iconv;\n\nstatic int *flag_ptr[] = {\n\t&recurse,\t\t/* 0 */\n\t&preserve_uid,\t\t/* 1 */\n\t&preserve_gid,\t\t/* 2 */\n\t&preserve_links,\t/* 3 */\n\t&preserve_devices,\t/* 4 */\n\t&preserve_hard_links,\t/* 5 */\n\t&always_checksum,\t/* 6 */\n\t&xfer_dirs,\t\t/* 7 (protocol 29) */\n\t&do_compression,\t/* 8 (protocol 29) */\n\t&tweaked_iconv,\t\t/* 9  (protocol 30) */\n\t&preserve_acls,\t\t/* 10 (protocol 30) */\n\t&preserve_xattrs,\t/* 11 (protocol 30) */\n\t&inplace,\t\t/* 12 (protocol 30) */\n\t&tweaked_append,\t/* 13 (protocol 30) */\n\t&tweaked_append_verify,\t/* 14 (protocol 30) */\n\tNULL\n};\n\nstatic char *flag_name[] = {\n\t\"--recurse (-r)\",\n\t\"--owner (-o)\",\n\t\"--group (-g)\",\n\t\"--links (-l)\",\n\t\"--devices (-D)\",\n\t\"--hard-links (-H)\",\n\t\"--checksum (-c)\",\n\t\"--dirs (-d)\",\n\t\"--compress (-z)\",\n\t\"--iconv\",\n\t\"--acls (-A)\",\n\t\"--xattrs (-X)\",\n\t\"--inplace\",\n\t\"--append\",\n\t\"--append-verify\",\n\tNULL\n};\n\nvoid write_stream_flags(int fd)\n{\n\tint i, flags;\n\n\ttweaked_append = append_mode == 1;\n\ttweaked_append_verify = append_mode == 2;\n#ifdef ICONV_OPTION\n\ttweaked_iconv = iconv_opt != NULL;\n#endif\n\n\t/* Start the batch file with a bitmap of data-stream-affecting\n\t * flags. */\n\tfor (i = 0, flags = 0; flag_ptr[i]; i++) {\n\t\tif (*flag_ptr[i])\n\t\t\tflags |= 1 << i;\n\t}\n\twrite_int(fd, flags);\n}\n\nvoid read_stream_flags(int fd)\n{\n\tbatch_stream_flags = read_int(fd);\n}\n\nvoid check_batch_flags(void)\n{\n\tint i;\n\n\tif (protocol_version < 29)\n\t\tflag_ptr[7] = NULL;\n\telse if (protocol_version < 30)\n\t\tflag_ptr[9] = NULL;\n\ttweaked_append = append_mode == 1;\n\ttweaked_append_verify = append_mode == 2;\n#ifdef ICONV_OPTION\n\ttweaked_iconv = iconv_opt != NULL;\n#endif\n\tfor (i = 0; flag_ptr[i]; i++) {\n\t\tint set = batch_stream_flags & (1 << i) ? 1 : 0;\n\t\tif (*flag_ptr[i] != set) {\n\t\t\tif (i == 9) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"%s specify the --iconv option to use this batch file.\\n\",\n\t\t\t\t\tset ? \"Please\" : \"Do not\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (INFO_GTE(MISC, 1)) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"%sing the %s option to match the batchfile.\\n\",\n\t\t\t\t\tset ? \"Sett\" : \"Clear\", flag_name[i]);\n\t\t\t}\n\t\t\t*flag_ptr[i] = set;\n\t\t}\n\t}\n\tif (protocol_version < 29) {\n\t\tif (recurse)\n\t\t\txfer_dirs |= 1;\n\t\telse if (xfer_dirs < 2)\n\t\t\txfer_dirs = 0;\n\t}\n\n\tif (tweaked_append)\n\t\tappend_mode = 1;\n\telse if (tweaked_append_verify)\n\t\tappend_mode = 2;\n}\n\nstatic int write_arg(const char *arg)\n{\n\tconst char *x, *s;\n\tint len, err = 0;\n\n\tif (*arg == '-' && (x = strchr(arg, '=')) != NULL) {\n\t\terr |= write(batch_sh_fd, arg, x - arg + 1) != x - arg + 1;\n\t\targ += x - arg + 1;\n\t}\n\n\tif (strpbrk(arg, \" \\\"'&;|[]()$#!*?^\\\\\") != NULL) {\n\t\terr |= write(batch_sh_fd, \"'\", 1) != 1;\n\t\tfor (s = arg; (x = strchr(s, '\\'')) != NULL; s = x + 1) {\n\t\t\terr |= write(batch_sh_fd, s, x - s + 1) != x - s + 1;\n\t\t\terr |= write(batch_sh_fd, \"'\", 1) != 1;\n\t\t}\n\t\tlen = strlen(s);\n\t\terr |= write(batch_sh_fd, s, len) != len;\n\t\terr |= write(batch_sh_fd, \"'\", 1) != 1;\n\t\treturn err;\n\t}\n\n\tlen = strlen(arg);\n\terr |= write(batch_sh_fd, arg, len) != len;\n\n\treturn err;\n}\n\n/* Writes out a space and then an option (or other string) with an optional \"=\" + arg suffix. */\nstatic int write_opt(const char *opt, const char *arg)\n{\n\tint len = strlen(opt);\n\tint err = write(batch_sh_fd, \" \", 1) != 1;\n\terr = write(batch_sh_fd, opt, len) != len ? 1 : 0;\n\tif (arg) {\n\t\terr |= write(batch_sh_fd, \"=\", 1) != 1;\n\t\terr |= write_arg(arg);\n\t}\n\treturn err;\n}\n\nstatic void write_filter_rules(int fd)\n{\n\tfilter_rule *ent;\n\n\twrite_sbuf(fd, \" <<'#E#'\\n\");\n\tfor (ent = filter_list.head; ent; ent = ent->next) {\n\t\tunsigned int plen;\n\t\tchar *p = get_rule_prefix(ent, \"- \", 0, &plen);\n\t\twrite_buf(fd, p, plen);\n\t\twrite_sbuf(fd, ent->pattern);\n\t\tif (ent->rflags & FILTRULE_DIRECTORY)\n\t\t\twrite_byte(fd, '/');\n\t\twrite_byte(fd, eol_nulls ? 0 : '\\n');\n\t}\n\tif (eol_nulls)\n\t\twrite_sbuf(fd, \";\\n\");\n\twrite_sbuf(fd, \"#E#\");\n}\n\n/* This sets batch_fd and (for --write-batch) batch_sh_fd. */\nvoid open_batch_files(void)\n{\n\tif (write_batch) {\n\t\tchar filename[MAXPATHLEN];\n\n\t\tstringjoin(filename, sizeof filename, batch_name, \".sh\", NULL);\n\n\t\tbatch_sh_fd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IXUSR);\n\t\tif (batch_sh_fd < 0) {\n\t\t\trsyserr(FERROR, errno, \"Batch file %s open error\", full_fname(filename));\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\n\t\tbatch_fd = do_open(batch_name, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n\t} else if (strcmp(batch_name, \"-\") == 0)\n\t\tbatch_fd = STDIN_FILENO;\n\telse\n\t\tbatch_fd = do_open(batch_name, O_RDONLY, S_IRUSR | S_IWUSR);\n\n\tif (batch_fd < 0) {\n\t\trsyserr(FERROR, errno, \"Batch file %s open error\", full_fname(batch_name));\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n}\n\n/* This routine tries to write out an equivalent --read-batch command\n * given the user's --write-batch args.  However, it doesn't really\n * understand most of the options, so it uses some overly simple\n * heuristics to munge the command line into something that will\n * (hopefully) work. */\nvoid write_batch_shell_file(void)\n{\n\tint i, j, len, err = 0;\n\tchar *p, *p2;\n\n\t/* Write argvs info to BATCH.sh file */\n\terr |= write_arg(raw_argv[0]);\n\tif (filter_list.head) {\n\t\tif (protocol_version >= 29)\n\t\t\terr |= write_opt(\"--filter\", \"._-\");\n\t\telse\n\t\t\terr |= write_opt(\"--exclude-from\", \"-\");\n\t}\n\n\t/* Elide the filename args from the option list, but scan for them in reverse. */\n\tfor (i = raw_argc-1, j = cooked_argc-1; i > 0 && j >= 0; i--) {\n\t\tif (strcmp(raw_argv[i], cooked_argv[j]) == 0) {\n\t\t\traw_argv[i] = NULL;\n\t\t\tj--;\n\t\t}\n\t}\n\n\tfor (i = 1; i < raw_argc; i++) {\n\t\tif (!(p = raw_argv[i]))\n\t\t\tcontinue;\n\t\tif (strncmp(p, \"--files-from\", 12) == 0\n\t\t || strncmp(p, \"--filter\", 8) == 0\n\t\t || strncmp(p, \"--include\", 9) == 0\n\t\t || strncmp(p, \"--exclude\", 9) == 0) {\n\t\t\tif (strchr(p, '=') == NULL)\n\t\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(p, \"-f\") == 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncmp(p, \"--write-batch\", len = 13) == 0\n\t\t || strncmp(p, \"--only-write-batch\", len = 18) == 0)\n\t\t\terr |= write_opt(\"--read-batch\", p[len] == '=' ? p + len + 1 : NULL);\n\t\telse {\n\t\t\terr |= write(batch_sh_fd, \" \", 1) != 1;\n\t\t\terr |= write_arg(p);\n\t\t}\n\t}\n\tif (!(p = check_for_hostspec(cooked_argv[cooked_argc - 1], &p2, &i)))\n\t\tp = cooked_argv[cooked_argc - 1];\n\terr |= write_opt(\"${1:-\", NULL);\n\terr |= write_arg(p);\n\terr |= write(batch_sh_fd, \"}\", 1) != 1;\n\tif (filter_list.head)\n\t\twrite_filter_rules(batch_sh_fd);\n\tif (write(batch_sh_fd, \"\\n\", 1) != 1 || close(batch_sh_fd) < 0 || err) {\n\t\trsyserr(FERROR, errno, \"Batch file %s.sh write error\", batch_name);\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n\tbatch_sh_fd = -1;\n}\n"
        },
        {
          "name": "byteorder.h",
          "type": "blob",
          "size": 2.8671875,
          "content": "/*\n * Simple byteorder handling.\n *\n * Copyright (C) 1992-1995 Andrew Tridgell\n * Copyright (C) 2007-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#undef CAREFUL_ALIGNMENT\n\n/* We know that the x86 can handle misalignment and has the same\n * byte order (LSB-first) as the 32-bit numbers we transmit. */\n#if defined __i386__ || defined __i486__ || defined __i586__ || defined __i686__ || __amd64\n#define CAREFUL_ALIGNMENT 0\n#endif\n\n#ifndef CAREFUL_ALIGNMENT\n#define CAREFUL_ALIGNMENT 1\n#endif\n\n#define CVAL(buf,pos) (((unsigned char *)(buf))[pos])\n#define UVAL(buf,pos) ((uint32)CVAL(buf,pos))\n\n#if CAREFUL_ALIGNMENT\n\nstatic inline uint32\nIVALu(const uchar *buf, int pos)\n{\n\treturn UVAL(buf, pos)\n\t     | UVAL(buf, pos + 1) << 8\n\t     | UVAL(buf, pos + 2) << 16\n\t     | UVAL(buf, pos + 3) << 24;\n}\n\nstatic inline void\nSIVALu(uchar *buf, int pos, uint32 val)\n{\n\tCVAL(buf, pos)     = val;\n\tCVAL(buf, pos + 1) = val >> 8;\n\tCVAL(buf, pos + 2) = val >> 16;\n\tCVAL(buf, pos + 3) = val >> 24;\n}\n\nstatic inline int64\nIVAL64(const char *buf, int pos)\n{\n\treturn IVALu((uchar*)buf, pos) | (int64)IVALu((uchar*)buf, pos + 4) << 32;\n}\n\nstatic inline void\nSIVAL64(char *buf, int pos, int64 val)\n{\n\tSIVALu((uchar*)buf, pos, val);\n\tSIVALu((uchar*)buf, pos + 4, val >> 32);\n}\n\n#else /* !CAREFUL_ALIGNMENT */\n\n/* This handles things for architectures like the 386 that can handle alignment errors.\n * WARNING: This section is dependent on the length of an int32 (and thus a uint32)\n * being correct (4 bytes)!  Set CAREFUL_ALIGNMENT if it is not. */\n\nstatic inline uint32\nIVALu(const uchar *buf, int pos)\n{\n\tunion {\n\t\tconst uchar *b;\n\t\tconst uint32 *num;\n\t} u;\n\tu.b = buf + pos;\n\treturn *u.num;\n}\n\nstatic inline void\nSIVALu(uchar *buf, int pos, uint32 val)\n{\n\tunion {\n\t\tuchar *b;\n\t\tuint32 *num;\n\t} u;\n\tu.b = buf + pos;\n\t*u.num = val;\n}\n\nstatic inline int64\nIVAL64(const char *buf, int pos)\n{\n\tunion {\n\t\tconst char *b;\n\t\tconst int64 *num;\n\t} u;\n\tu.b = buf + pos;\n\treturn *u.num;\n}\n\nstatic inline void\nSIVAL64(char *buf, int pos, int64 val)\n{\n\tunion {\n\t\tchar *b;\n\t\tint64 *num;\n\t} u;\n\tu.b = buf + pos;\n\t*u.num = val;\n}\n\n#endif /* !CAREFUL_ALIGNMENT */\n\nstatic inline uint32\nIVAL(const char *buf, int pos)\n{\n\treturn IVALu((uchar*)buf, pos);\n}\n\nstatic inline void\nSIVAL(char *buf, int pos, uint32 val)\n{\n\tSIVALu((uchar*)buf, pos, val);\n}\n"
        },
        {
          "name": "case_N.h",
          "type": "blob",
          "size": 2.2666015625,
          "content": "/*\n * Allow an arbitrary sequence of case labels.\n *\n * Copyright (C) 2006-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* This is included multiple times, once for every segment in a switch statement.\n * This produces the next \"case N:\" statement in sequence. */\n\n#if !defined CASE_N_STATE_0\n#define CASE_N_STATE_0\n\tcase 0:\n#elif !defined CASE_N_STATE_1\n#define CASE_N_STATE_1\n\t/* FALLTHROUGH */\n\tcase 1:\n#elif !defined CASE_N_STATE_2\n#define CASE_N_STATE_2\n\t/* FALLTHROUGH */\n\tcase 2:\n#elif !defined CASE_N_STATE_3\n#define CASE_N_STATE_3\n\t/* FALLTHROUGH */\n\tcase 3:\n#elif !defined CASE_N_STATE_4\n#define CASE_N_STATE_4\n\t/* FALLTHROUGH */\n\tcase 4:\n#elif !defined CASE_N_STATE_5\n#define CASE_N_STATE_5\n\t/* FALLTHROUGH */\n\tcase 5:\n#elif !defined CASE_N_STATE_6\n#define CASE_N_STATE_6\n\t/* FALLTHROUGH */\n\tcase 6:\n#elif !defined CASE_N_STATE_7\n#define CASE_N_STATE_7\n\t/* FALLTHROUGH */\n\tcase 7:\n#elif !defined CASE_N_STATE_8\n#define CASE_N_STATE_8\n\t/* FALLTHROUGH */\n\tcase 8:\n#elif !defined CASE_N_STATE_9\n#define CASE_N_STATE_9\n\t/* FALLTHROUGH */\n\tcase 9:\n#elif !defined CASE_N_STATE_10\n#define CASE_N_STATE_10\n\t/* FALLTHROUGH */\n\tcase 10:\n#elif !defined CASE_N_STATE_11\n#define CASE_N_STATE_11\n\t/* FALLTHROUGH */\n\tcase 11:\n#elif !defined CASE_N_STATE_12\n#define CASE_N_STATE_12\n\t/* FALLTHROUGH */\n\tcase 12:\n#elif !defined CASE_N_STATE_13\n#define CASE_N_STATE_13\n\t/* FALLTHROUGH */\n\tcase 13:\n#elif !defined CASE_N_STATE_14\n#define CASE_N_STATE_14\n\t/* FALLTHROUGH */\n\tcase 14:\n#elif !defined CASE_N_STATE_15\n#define CASE_N_STATE_15\n\t/* FALLTHROUGH */\n\tcase 15:\n#elif !defined CASE_N_STATE_16\n#define CASE_N_STATE_16\n\t/* FALLTHROUGH */\n\tcase 16:\n#else\n#error Need to add more case statements!\n#endif\n"
        },
        {
          "name": "checksum.c",
          "type": "blob",
          "size": 20.5029296875,
          "content": "/*\n * Routines to support checksumming of bytes.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2004-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * In addition, as a special exception, the copyright holders give\n * permission to dynamically link rsync with the OpenSSL and xxhash\n * libraries when those libraries are being distributed in compliance\n * with their license terms, and to distribute a dynamically linked\n * combination of rsync and these libraries.  This is also considered\n * to be covered under the GPL's System Libraries exception.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n#ifdef SUPPORT_XXHASH\n#include <xxhash.h>\n# if XXH_VERSION_NUMBER >= 800\n#  define SUPPORT_XXH3 1\n# endif\n#endif\n\nextern int am_server;\nextern int whole_file;\nextern int checksum_seed;\nextern int protocol_version;\nextern int proper_seed_order;\nextern const char *checksum_choice;\n\n#define NNI_BUILTIN (1<<0)\n#define NNI_EVP (1<<1)\n#define NNI_EVP_OK (1<<2)\n\nstruct name_num_item valid_checksums_items[] = {\n#ifdef SUPPORT_XXH3\n\t{ CSUM_XXH3_128, 0, \"xxh128\", NULL },\n\t{ CSUM_XXH3_64, 0, \"xxh3\", NULL },\n#endif\n#ifdef SUPPORT_XXHASH\n\t{ CSUM_XXH64, 0, \"xxh64\", NULL },\n\t{ CSUM_XXH64, 0, \"xxhash\", NULL },\n#endif\n\t{ CSUM_MD5, NNI_BUILTIN|NNI_EVP, \"md5\", NULL },\n\t{ CSUM_MD4, NNI_BUILTIN|NNI_EVP, \"md4\", NULL },\n#ifdef SHA_DIGEST_LENGTH\n\t{ CSUM_SHA1, NNI_EVP, \"sha1\", NULL },\n#endif\n\t{ CSUM_NONE, 0, \"none\", NULL },\n\t{ 0, 0, NULL, NULL }\n};\n\nstruct name_num_obj valid_checksums = {\n\t\"checksum\", NULL, 0, 0, valid_checksums_items\n};\n\nstruct name_num_item valid_auth_checksums_items[] = {\n#ifdef SHA512_DIGEST_LENGTH\n\t{ CSUM_SHA512, NNI_EVP, \"sha512\", NULL },\n#endif\n#ifdef SHA256_DIGEST_LENGTH\n\t{ CSUM_SHA256, NNI_EVP, \"sha256\", NULL },\n#endif\n#ifdef SHA_DIGEST_LENGTH\n\t{ CSUM_SHA1, NNI_EVP, \"sha1\", NULL },\n#endif\n\t{ CSUM_MD5, NNI_BUILTIN|NNI_EVP, \"md5\", NULL },\n\t{ CSUM_MD4, NNI_BUILTIN|NNI_EVP, \"md4\", NULL },\n\t{ 0, 0, NULL, NULL }\n};\n\nstruct name_num_obj valid_auth_checksums = {\n\t\"daemon auth checksum\", NULL, 0, 0, valid_auth_checksums_items\n};\n\n/* These cannot make use of openssl, so they're marked just as built-in */\nstruct name_num_item implied_checksum_md4 =\n    { CSUM_MD4, NNI_BUILTIN, \"md4\", NULL };\nstruct name_num_item implied_checksum_md5 =\n    { CSUM_MD5, NNI_BUILTIN, \"md5\", NULL };\n\nstruct name_num_item *xfer_sum_nni; /* used for the transfer checksum2 computations */\nint xfer_sum_len;\nstruct name_num_item *file_sum_nni; /* used for the pre-transfer --checksum computations */\nint file_sum_len, file_sum_extra_cnt;\n\n#ifdef USE_OPENSSL\nconst EVP_MD *xfer_sum_evp_md;\nconst EVP_MD *file_sum_evp_md;\nEVP_MD_CTX *ctx_evp = NULL;\n#endif\n\nstatic int initialized_choices = 0;\n\nstruct name_num_item *parse_csum_name(const char *name, int len)\n{\n\tstruct name_num_item *nni;\n\n\tif (len < 0 && name)\n\t\tlen = strlen(name);\n\n\tinit_checksum_choices();\n\n\tif (!name || (len == 4 && strncasecmp(name, \"auto\", 4) == 0)) {\n\t\tif (protocol_version >= 30) {\n\t\t\tif (!proper_seed_order)\n\t\t\t\treturn &implied_checksum_md5;\n\t\t\tname = \"md5\";\n\t\t\tlen = 3;\n\t\t} else {\n\t\t\tif (protocol_version >= 27)\n\t\t\t\timplied_checksum_md4.num = CSUM_MD4_OLD;\n\t\t\telse if (protocol_version >= 21)\n\t\t\t\timplied_checksum_md4.num = CSUM_MD4_BUSTED;\n\t\t\telse\n\t\t\t\timplied_checksum_md4.num = CSUM_MD4_ARCHAIC;\n\t\t\treturn &implied_checksum_md4;\n\t\t}\n\t}\n\n\tnni = get_nni_by_name(&valid_checksums, name, len);\n\n\tif (!nni) {\n\t\trprintf(FERROR, \"unknown checksum name: %s\\n\", name);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\treturn nni;\n}\n\n#ifdef USE_OPENSSL\nstatic const EVP_MD *csum_evp_md(struct name_num_item *nni)\n{\n\tconst EVP_MD *emd;\n\tif (!(nni->flags & NNI_EVP))\n\t\treturn NULL;\n\n#ifdef USE_MD5_ASM\n\tif (nni->num == CSUM_MD5)\n\t\temd = NULL;\n\telse\n#endif\n\t\temd = EVP_get_digestbyname(nni->name);\n\tif (emd && !(nni->flags & NNI_EVP_OK)) { /* Make sure it works before we advertise it */\n\t\tif (!ctx_evp && !(ctx_evp = EVP_MD_CTX_create()))\n\t\t\tout_of_memory(\"csum_evp_md\");\n\t\t/* Some routines are marked as legacy and are not enabled in the openssl.cnf file.\n\t\t * If we can't init the emd, we'll fall back to our built-in code. */\n\t\tif (EVP_DigestInit_ex(ctx_evp, emd, NULL) == 0)\n\t\t\temd = NULL;\n\t\telse\n\t\t\tnni->flags = (nni->flags & ~NNI_BUILTIN) | NNI_EVP_OK;\n\t}\n\tif (!emd)\n\t\tnni->flags &= ~NNI_EVP;\n\treturn emd;\n}\n#endif\n\nvoid parse_checksum_choice(int final_call)\n{\n\tif (valid_checksums.negotiated_nni)\n\t\txfer_sum_nni = file_sum_nni = valid_checksums.negotiated_nni;\n\telse {\n\t\tchar *cp = checksum_choice ? strchr(checksum_choice, ',') : NULL;\n\t\tif (cp) {\n\t\t\txfer_sum_nni = parse_csum_name(checksum_choice, cp - checksum_choice);\n\t\t\tfile_sum_nni = parse_csum_name(cp+1, -1);\n\t\t} else\n\t\t\txfer_sum_nni = file_sum_nni = parse_csum_name(checksum_choice, -1);\n\t\tif (am_server && checksum_choice)\n\t\t\tvalidate_choice_vs_env(NSTR_CHECKSUM, xfer_sum_nni->num, file_sum_nni->num);\n\t}\n\txfer_sum_len = csum_len_for_type(xfer_sum_nni->num, 0);\n\tfile_sum_len = csum_len_for_type(file_sum_nni->num, 0);\n#ifdef USE_OPENSSL\n\txfer_sum_evp_md = csum_evp_md(xfer_sum_nni);\n\tfile_sum_evp_md = csum_evp_md(file_sum_nni);\n#endif\n\n\tfile_sum_extra_cnt = (file_sum_len + EXTRA_LEN - 1) / EXTRA_LEN;\n\n\tif (xfer_sum_nni->num == CSUM_NONE)\n\t\twhole_file = 1;\n\n\t/* Snag the checksum name for both write_batch's option output & the following debug output. */\n\tif (valid_checksums.negotiated_nni)\n\t\tchecksum_choice = valid_checksums.negotiated_nni->name;\n\telse if (checksum_choice == NULL)\n\t\tchecksum_choice = xfer_sum_nni->name;\n\n\tif (final_call && DEBUG_GTE(NSTR, am_server ? 3 : 1)) {\n\t\trprintf(FINFO, \"%s%s checksum: %s\\n\",\n\t\t\tam_server ? \"Server\" : \"Client\",\n\t\t\tvalid_checksums.negotiated_nni ? \" negotiated\" : \"\",\n\t\t\tchecksum_choice);\n\t}\n}\n\nint csum_len_for_type(int cst, BOOL flist_csum)\n{\n\tswitch (cst) {\n\t  case CSUM_NONE:\n\t\treturn 1;\n\t  case CSUM_MD4_ARCHAIC:\n\t\t/* The oldest checksum code is rather weird: the file-list code only sent\n\t\t * 2-byte checksums, but all other checksums were full MD4 length. */\n\t\treturn flist_csum ? 2 : MD4_DIGEST_LEN;\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t\treturn MD4_DIGEST_LEN;\n\t  case CSUM_MD5:\n\t\treturn MD5_DIGEST_LEN;\n#ifdef SHA_DIGEST_LENGTH\n\t  case CSUM_SHA1:\n\t\treturn SHA_DIGEST_LENGTH;\n#endif\n#ifdef SHA256_DIGEST_LENGTH\n\t  case CSUM_SHA256:\n\t\treturn SHA256_DIGEST_LENGTH;\n#endif\n#ifdef SHA512_DIGEST_LENGTH\n\t  case CSUM_SHA512:\n\t\treturn SHA512_DIGEST_LENGTH;\n#endif\n\t  case CSUM_XXH64:\n\t  case CSUM_XXH3_64:\n\t\treturn 64/8;\n\t  case CSUM_XXH3_128:\n\t\treturn 128/8;\n\t  default: /* paranoia to prevent missing case values */\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\treturn 0;\n}\n\n/* Returns 0 if the checksum is not canonical (i.e. it includes a seed value).\n * Returns 1 if the public sum order matches our internal sum order.\n * Returns -1 if the public sum order is the reverse of our internal sum order.\n */\nint canonical_checksum(int csum_type)\n{\n\tswitch (csum_type) {\n\t  case CSUM_NONE:\n\t  case CSUM_MD4_ARCHAIC:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t\tbreak;\n\t  case CSUM_MD4:\n\t  case CSUM_MD5:\n\t  case CSUM_SHA1:\n\t  case CSUM_SHA256:\n\t  case CSUM_SHA512:\n\t\treturn -1;\n\t  case CSUM_XXH64:\n\t  case CSUM_XXH3_64:\n\t  case CSUM_XXH3_128:\n\t\treturn 1;\n\t  default: /* paranoia to prevent missing case values */\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\treturn 0;\n}\n\n#ifndef USE_ROLL_SIMD /* See simd-checksum-*.cpp. */\n/*\n  a simple 32 bit checksum that can be updated from either end\n  (inspired by Mark Adler's Adler-32 checksum)\n  */\nuint32 get_checksum1(char *buf1, int32 len)\n{\n\tint32 i;\n\tuint32 s1, s2;\n\tschar *buf = (schar *)buf1;\n\n\ts1 = s2 = 0;\n\tfor (i = 0; i < (len-4); i+=4) {\n\t\ts2 += 4*(s1 + buf[i]) + 3*buf[i+1] + 2*buf[i+2] + buf[i+3] + 10*CHAR_OFFSET;\n\t\ts1 += (buf[i+0] + buf[i+1] + buf[i+2] + buf[i+3] + 4*CHAR_OFFSET);\n\t}\n\tfor (; i < len; i++) {\n\t\ts1 += (buf[i]+CHAR_OFFSET); s2 += s1;\n\t}\n\treturn (s1 & 0xffff) + (s2 << 16);\n}\n#endif\n\n/* The \"sum\" buffer must be at least MAX_DIGEST_LEN bytes! */\nvoid get_checksum2(char *buf, int32 len, char *sum)\n{\n#ifdef USE_OPENSSL\n\tif (xfer_sum_evp_md) {\n\t\tstatic EVP_MD_CTX *evp = NULL;\n\t\tuchar seedbuf[4];\n\t\tif (!evp && !(evp = EVP_MD_CTX_create()))\n\t\t\tout_of_memory(\"get_checksum2\");\n\t\tEVP_DigestInit_ex(evp, xfer_sum_evp_md, NULL);\n\t\tif (checksum_seed) {\n\t\t\tSIVALu(seedbuf, 0, checksum_seed);\n\t\t\tEVP_DigestUpdate(evp, seedbuf, 4);\n\t\t}\n\t\tEVP_DigestUpdate(evp, (uchar *)buf, len);\n\t\tEVP_DigestFinal_ex(evp, (uchar *)sum, NULL);\n\t} else\n#endif\n\tswitch (xfer_sum_nni->num) {\n#ifdef SUPPORT_XXHASH\n\t  case CSUM_XXH64:\n\t\tSIVAL64(sum, 0, XXH64(buf, len, checksum_seed));\n\t\tbreak;\n#endif\n#ifdef SUPPORT_XXH3\n\t  case CSUM_XXH3_64:\n\t\tSIVAL64(sum, 0, XXH3_64bits_withSeed(buf, len, checksum_seed));\n\t\tbreak;\n\t  case CSUM_XXH3_128: {\n\t\tXXH128_hash_t digest = XXH3_128bits_withSeed(buf, len, checksum_seed);\n\t\tSIVAL64(sum, 0, digest.low64);\n\t\tSIVAL64(sum, 8, digest.high64);\n\t\tbreak;\n\t  }\n#endif\n\t  case CSUM_MD5: {\n\t\tmd_context m5;\n\t\tuchar seedbuf[4];\n\t\tmd5_begin(&m5);\n\t\tif (proper_seed_order) {\n\t\t\tif (checksum_seed) {\n\t\t\t\tSIVALu(seedbuf, 0, checksum_seed);\n\t\t\t\tmd5_update(&m5, seedbuf, 4);\n\t\t\t}\n\t\t\tmd5_update(&m5, (uchar *)buf, len);\n\t\t} else {\n\t\t\tmd5_update(&m5, (uchar *)buf, len);\n\t\t\tif (checksum_seed) {\n\t\t\t\tSIVALu(seedbuf, 0, checksum_seed);\n\t\t\t\tmd5_update(&m5, seedbuf, 4);\n\t\t\t}\n\t\t}\n\t\tmd5_result(&m5, (uchar *)sum);\n\t\tbreak;\n\t  }\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t  case CSUM_MD4_ARCHAIC: {\n\t\tmd_context m;\n\t\tint32 i;\n\t\tstatic char *buf1;\n\t\tstatic int32 len1;\n\n\t\tmdfour_begin(&m);\n\n\t\tif (len > len1) {\n\t\t\tif (buf1)\n\t\t\t\tfree(buf1);\n\t\t\tbuf1 = new_array(char, len+4);\n\t\t\tlen1 = len;\n\t\t}\n\n\t\tmemcpy(buf1, buf, len);\n\t\tif (checksum_seed) {\n\t\t\tSIVAL(buf1,len,checksum_seed);\n\t\t\tlen += 4;\n\t\t}\n\n\t\tfor (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK)\n\t\t\tmdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);\n\n\t\t/*\n\t\t * Prior to version 27 an incorrect MD4 checksum was computed\n\t\t * by failing to call mdfour_tail() for block sizes that\n\t\t * are multiples of 64.  This is fixed by calling mdfour_update()\n\t\t * even when there are no more bytes.\n\t\t */\n\t\tif (len - i > 0 || xfer_sum_nni->num > CSUM_MD4_BUSTED)\n\t\t\tmdfour_update(&m, (uchar *)(buf1+i), len-i);\n\n\t\tmdfour_result(&m, (uchar *)sum);\n\t\tbreak;\n\t  }\n\t  default: /* paranoia to prevent missing case values */\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n}\n\nvoid file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)\n{\n\tstruct map_struct *buf;\n\tOFF_T i, len = st_p->st_size;\n\tint32 remainder;\n\tint fd;\n\n\tfd = do_open(fname, O_RDONLY, 0);\n\tif (fd == -1) {\n\t\tmemset(sum, 0, file_sum_len);\n\t\treturn;\n\t}\n\n\tbuf = map_file(fd, len, MAX_MAP_SIZE, CHUNK_SIZE);\n\n#ifdef USE_OPENSSL\n\tif (file_sum_evp_md) {\n\t\tstatic EVP_MD_CTX *evp = NULL;\n\t\tif (!evp && !(evp = EVP_MD_CTX_create()))\n\t\t\tout_of_memory(\"file_checksum\");\n\n\t\tEVP_DigestInit_ex(evp, file_sum_evp_md, NULL);\n\n\t\tfor (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)\n\t\t\tEVP_DigestUpdate(evp, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);\n\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0)\n\t\t\tEVP_DigestUpdate(evp, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tEVP_DigestFinal_ex(evp, (uchar *)sum, NULL);\n\t} else\n#endif\n\tswitch (file_sum_nni->num) {\n#ifdef SUPPORT_XXHASH\n\t  case CSUM_XXH64: {\n\t\tstatic XXH64_state_t* state = NULL;\n\t\tif (!state && !(state = XXH64_createState()))\n\t\t\tout_of_memory(\"file_checksum\");\n\n\t\tXXH64_reset(state, 0);\n\n\t\tfor (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)\n\t\t\tXXH64_update(state, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);\n\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0)\n\t\t\tXXH64_update(state, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tSIVAL64(sum, 0, XXH64_digest(state));\n\t\tbreak;\n\t  }\n#endif\n#ifdef SUPPORT_XXH3\n\t  case CSUM_XXH3_64: {\n\t\tstatic XXH3_state_t* state = NULL;\n\t\tif (!state && !(state = XXH3_createState()))\n\t\t\tout_of_memory(\"file_checksum\");\n\n\t\tXXH3_64bits_reset(state);\n\n\t\tfor (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)\n\t\t\tXXH3_64bits_update(state, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);\n\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0)\n\t\t\tXXH3_64bits_update(state, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tSIVAL64(sum, 0, XXH3_64bits_digest(state));\n\t\tbreak;\n\t  }\n\t  case CSUM_XXH3_128: {\n\t\tXXH128_hash_t digest;\n\t\tstatic XXH3_state_t* state = NULL;\n\t\tif (!state && !(state = XXH3_createState()))\n\t\t\tout_of_memory(\"file_checksum\");\n\n\t\tXXH3_128bits_reset(state);\n\n\t\tfor (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)\n\t\t\tXXH3_128bits_update(state, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);\n\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0)\n\t\t\tXXH3_128bits_update(state, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tdigest = XXH3_128bits_digest(state);\n\t\tSIVAL64(sum, 0, digest.low64);\n\t\tSIVAL64(sum, 8, digest.high64);\n\t\tbreak;\n\t  }\n#endif\n\t  case CSUM_MD5: {\n\t\tmd_context m5;\n\n\t\tmd5_begin(&m5);\n\n\t\tfor (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)\n\t\t\tmd5_update(&m5, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);\n\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0)\n\t\t\tmd5_update(&m5, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tmd5_result(&m5, (uchar *)sum);\n\t\tbreak;\n\t  }\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t  case CSUM_MD4_ARCHAIC: {\n\t\tmd_context m;\n\n\t\tmdfour_begin(&m);\n\n\t\tfor (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK)\n\t\t\tmdfour_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK), CSUM_CHUNK);\n\n\t\t/* Prior to version 27 an incorrect MD4 checksum was computed\n\t\t * by failing to call mdfour_tail() for block sizes that\n\t\t * are multiples of 64.  This is fixed by calling mdfour_update()\n\t\t * even when there are no more bytes. */\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0 || file_sum_nni->num > CSUM_MD4_BUSTED)\n\t\t\tmdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tmdfour_result(&m, (uchar *)sum);\n\t\tbreak;\n\t  }\n\t  default:\n\t\trprintf(FERROR, \"Invalid checksum-choice for --checksum: %s (%d)\\n\",\n\t\t\tfile_sum_nni->name, file_sum_nni->num);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tclose(fd);\n\tunmap_file(buf);\n}\n\nstatic int32 sumresidue;\nstatic md_context ctx_md;\n#ifdef SUPPORT_XXHASH\nstatic XXH64_state_t* xxh64_state;\n#endif\n#ifdef SUPPORT_XXH3\nstatic XXH3_state_t* xxh3_state;\n#endif\nstatic struct name_num_item *cur_sum_nni;\nint cur_sum_len;\n\n#ifdef USE_OPENSSL\nstatic const EVP_MD *cur_sum_evp_md;\n#endif\n\n/* Initialize a hash digest accumulator.  Data is supplied via\n * sum_update() and the resulting binary digest is retrieved via\n * sum_end().  This only supports one active sum at a time. */\nint sum_init(struct name_num_item *nni, int seed)\n{\n\tchar s[4];\n\n\tif (!nni)\n\t\tnni = parse_csum_name(NULL, 0);\n\tcur_sum_nni = nni;\n\tcur_sum_len = csum_len_for_type(nni->num, 0);\n#ifdef USE_OPENSSL\n\tcur_sum_evp_md = csum_evp_md(nni);\n#endif\n\n#ifdef USE_OPENSSL\n\tif (cur_sum_evp_md) {\n\t\tif (!ctx_evp && !(ctx_evp = EVP_MD_CTX_create()))\n\t\t\tout_of_memory(\"file_checksum\");\n\t\tEVP_DigestInit_ex(ctx_evp, cur_sum_evp_md, NULL);\n\t} else\n#endif\n\tswitch (cur_sum_nni->num) {\n#ifdef SUPPORT_XXHASH\n\t  case CSUM_XXH64:\n\t\tif (!xxh64_state && !(xxh64_state = XXH64_createState()))\n\t\t\tout_of_memory(\"sum_init\");\n\t\tXXH64_reset(xxh64_state, 0);\n\t\tbreak;\n#endif\n#ifdef SUPPORT_XXH3\n\t  case CSUM_XXH3_64:\n\t\tif (!xxh3_state && !(xxh3_state = XXH3_createState()))\n\t\t\tout_of_memory(\"sum_init\");\n\t\tXXH3_64bits_reset(xxh3_state);\n\t\tbreak;\n\t  case CSUM_XXH3_128:\n\t\tif (!xxh3_state && !(xxh3_state = XXH3_createState()))\n\t\t\tout_of_memory(\"sum_init\");\n\t\tXXH3_128bits_reset(xxh3_state);\n\t\tbreak;\n#endif\n\t  case CSUM_MD5:\n\t\tmd5_begin(&ctx_md);\n\t\tbreak;\n\t  case CSUM_MD4:\n\t\tmdfour_begin(&ctx_md);\n\t\tsumresidue = 0;\n\t\tbreak;\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t  case CSUM_MD4_ARCHAIC:\n\t\tmdfour_begin(&ctx_md);\n\t\tsumresidue = 0;\n\t\tSIVAL(s, 0, seed);\n\t\tsum_update(s, 4);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t  default: /* paranoia to prevent missing case values */\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\treturn cur_sum_len;\n}\n\n/* Feed data into a hash digest accumulator. */\nvoid sum_update(const char *p, int32 len)\n{\n#ifdef USE_OPENSSL\n\tif (cur_sum_evp_md) {\n\t\tEVP_DigestUpdate(ctx_evp, (uchar *)p, len);\n\t} else\n#endif\n\tswitch (cur_sum_nni->num) {\n#ifdef SUPPORT_XXHASH\n\t  case CSUM_XXH64:\n\t\tXXH64_update(xxh64_state, p, len);\n\t\tbreak;\n#endif\n#ifdef SUPPORT_XXH3\n\t  case CSUM_XXH3_64:\n\t\tXXH3_64bits_update(xxh3_state, p, len);\n\t\tbreak;\n\t  case CSUM_XXH3_128:\n\t\tXXH3_128bits_update(xxh3_state, p, len);\n\t\tbreak;\n#endif\n\t  case CSUM_MD5:\n\t\tmd5_update(&ctx_md, (uchar *)p, len);\n\t\tbreak;\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t  case CSUM_MD4_ARCHAIC:\n\t\tif (len + sumresidue < CSUM_CHUNK) {\n\t\t\tmemcpy(ctx_md.buffer + sumresidue, p, len);\n\t\t\tsumresidue += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(ctx_md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&ctx_md, (uchar *)ctx_md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&ctx_md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(ctx_md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t  default: /* paranoia to prevent missing case values */\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n}\n\n/* The sum buffer only needs to be as long as the current checksum's digest\n * len, not MAX_DIGEST_LEN. Note that for CSUM_MD4_ARCHAIC that is the full\n * MD4_DIGEST_LEN even if the file-list code is going to ignore all but the\n * first 2 bytes of it. */\nvoid sum_end(char *sum)\n{\n#ifdef USE_OPENSSL\n\tif (cur_sum_evp_md) {\n\t\tEVP_DigestFinal_ex(ctx_evp, (uchar *)sum, NULL);\n\t} else\n#endif\n\tswitch (cur_sum_nni->num) {\n#ifdef SUPPORT_XXHASH\n\t  case CSUM_XXH64:\n\t\tSIVAL64(sum, 0, XXH64_digest(xxh64_state));\n\t\tbreak;\n#endif\n#ifdef SUPPORT_XXH3\n\t  case CSUM_XXH3_64:\n\t\tSIVAL64(sum, 0, XXH3_64bits_digest(xxh3_state));\n\t\tbreak;\n\t  case CSUM_XXH3_128: {\n\t\tXXH128_hash_t digest = XXH3_128bits_digest(xxh3_state);\n\t\tSIVAL64(sum, 0, digest.low64);\n\t\tSIVAL64(sum, 8, digest.high64);\n\t\tbreak;\n\t  }\n#endif\n\t  case CSUM_MD5:\n\t\tmd5_result(&ctx_md, (uchar *)sum);\n\t\tbreak;\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t\tmdfour_update(&ctx_md, (uchar *)ctx_md.buffer, sumresidue);\n\t\tmdfour_result(&ctx_md, (uchar *)sum);\n\t\tbreak;\n\t  case CSUM_MD4_BUSTED:\n\t  case CSUM_MD4_ARCHAIC:\n\t\tif (sumresidue)\n\t\t\tmdfour_update(&ctx_md, (uchar *)ctx_md.buffer, sumresidue);\n\t\tmdfour_result(&ctx_md, (uchar *)sum);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\t*sum = '\\0';\n\t\tbreak;\n\t  default: /* paranoia to prevent missing case values */\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n}\n\n#if defined SUPPORT_XXH3 || defined USE_OPENSSL\nstatic void verify_digest(struct name_num_item *nni, BOOL check_auth_list)\n{\n#ifdef SUPPORT_XXH3\n\tstatic int xxh3_result = 0;\n#endif\n#ifdef USE_OPENSSL\n\tstatic int prior_num = 0, prior_flags = 0, prior_result = 0;\n#endif\n\n#ifdef SUPPORT_XXH3\n\tif (nni->num == CSUM_XXH3_64 || nni->num == CSUM_XXH3_128) {\n\t\tif (!xxh3_result) {\n\t\t\tchar buf[32816];\n\t\t\tint j;\n\t\t\tfor (j = 0; j < (int)sizeof buf; j++)\n\t\t\t\tbuf[j] = ' ' + (j % 96);\n\t\t\tsum_init(nni, 0);\n\t\t\tsum_update(buf, 32816);\n\t\t\tsum_update(buf, 31152);\n\t\t\tsum_update(buf, 32474);\n\t\t\tsum_update(buf, 9322);\n\t\t\txxh3_result = XXH3_64bits_digest(xxh3_state) != 0xadbcf16d4678d1de ? -1 : 1;\n\t\t}\n\t\tif (xxh3_result < 0)\n\t\t\tnni->num = CSUM_gone;\n\t\treturn;\n\t}\n#endif\n\n#ifdef USE_OPENSSL\n\tif (BITS_SETnUNSET(nni->flags, NNI_EVP, NNI_BUILTIN|NNI_EVP_OK)) {\n\t\tif (nni->num == prior_num && nni->flags == prior_flags) {\n\t\t\tnni->flags = prior_result;\n\t\t\tif (!(nni->flags & NNI_EVP))\n\t\t\t\tnni->num = CSUM_gone;\n\t\t} else {\n\t\t\tprior_num = nni->num;\n\t\t\tprior_flags = nni->flags;\n\t\t\tif (!csum_evp_md(nni))\n\t\t\t\tnni->num = CSUM_gone;\n\t\t\tprior_result = nni->flags;\n\t\t\tif (check_auth_list && (nni = get_nni_by_num(&valid_auth_checksums, prior_num)) != NULL)\n\t\t\t\tverify_digest(nni, False);\n\t\t}\n\t}\n#endif\n}\n#endif\n\nvoid init_checksum_choices()\n{\n#if defined SUPPORT_XXH3 || defined USE_OPENSSL\n\tstruct name_num_item *nni;\n#endif\n\n\tif (initialized_choices)\n\t\treturn;\n\n#if defined USE_OPENSSL && OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOpenSSL_add_all_algorithms();\n#endif\n\n#if defined SUPPORT_XXH3 || defined USE_OPENSSL\n\tfor (nni = valid_checksums.list; nni->name; nni++)\n\t\tverify_digest(nni, True);\n\n\tfor (nni = valid_auth_checksums.list; nni->name; nni++)\n\t\tverify_digest(nni, False);\n#endif\n\n\tinitialized_choices = 1;\n}\n"
        },
        {
          "name": "chmod.c",
          "type": "blob",
          "size": 5.466796875,
          "content": "/*\n * Implement the core of the --chmod option.\n *\n * Copyright (C) 2002 Scott Howard\n * Copyright (C) 2005-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n\nextern mode_t orig_umask;\n\n#define FLAG_X_KEEP (1<<0)\n#define FLAG_DIRS_ONLY (1<<1)\n#define FLAG_FILES_ONLY (1<<2)\n\nstruct chmod_mode_struct {\n\tstruct chmod_mode_struct *next;\n\tint ModeAND, ModeOR;\n\tchar flags;\n};\n\n#define CHMOD_ADD 1\n#define CHMOD_SUB 2\n#define CHMOD_EQ  3\n#define CHMOD_SET 4\n\n#define STATE_ERROR 0\n#define STATE_1ST_HALF 1\n#define STATE_2ND_HALF 2\n#define STATE_OCTAL_NUM 3\n\n/* Parse a chmod-style argument, and break it down into one or more AND/OR\n * pairs in a linked list.  We return a pointer to new items on success\n * (appending the items to the specified list), or NULL on error. */\nstruct chmod_mode_struct *parse_chmod(const char *modestr,\n\t\t\t\t      struct chmod_mode_struct **root_mode_ptr)\n{\n\tint state = STATE_1ST_HALF;\n\tint where = 0, what = 0, op = 0, topbits = 0, topoct = 0, flags = 0;\n\tstruct chmod_mode_struct *first_mode = NULL, *curr_mode = NULL,\n\t\t\t\t *prev_mode = NULL;\n\n\twhile (state != STATE_ERROR) {\n\t\tif (!*modestr || *modestr == ',') {\n\t\t\tint bits;\n\n\t\t\tif (!op) {\n\t\t\t\tstate = STATE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev_mode = curr_mode;\n\t\t\tcurr_mode = new_array(struct chmod_mode_struct, 1);\n\t\t\tif (prev_mode)\n\t\t\t\tprev_mode->next = curr_mode;\n\t\t\telse\n\t\t\t\tfirst_mode = curr_mode;\n\t\t\tcurr_mode->next = NULL;\n\n\t\t\tif (where)\n\t\t\t\tbits = where * what;\n\t\t\telse {\n\t\t\t\twhere = 0111;\n\t\t\t\tbits = (where * what) & ~orig_umask;\n\t\t\t}\n\n\t\t\tswitch (op) {\n\t\t\tcase CHMOD_ADD:\n\t\t\t\tcurr_mode->ModeAND = CHMOD_BITS;\n\t\t\t\tcurr_mode->ModeOR  = bits + topoct;\n\t\t\t\tbreak;\n\t\t\tcase CHMOD_SUB:\n\t\t\t\tcurr_mode->ModeAND = CHMOD_BITS - bits - topoct;\n\t\t\t\tcurr_mode->ModeOR  = 0;\n\t\t\t\tbreak;\n\t\t\tcase CHMOD_EQ:\n\t\t\t\tcurr_mode->ModeAND = CHMOD_BITS - (where * 7) - (topoct ? topbits : 0);\n\t\t\t\tcurr_mode->ModeOR  = bits + topoct;\n\t\t\t\tbreak;\n\t\t\tcase CHMOD_SET:\n\t\t\t\tcurr_mode->ModeAND = 0;\n\t\t\t\tcurr_mode->ModeOR  = bits;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcurr_mode->flags = flags;\n\n\t\t\tif (!*modestr)\n\t\t\t\tbreak;\n\t\t\tmodestr++;\n\n\t\t\tstate = STATE_1ST_HALF;\n\t\t\twhere = what = op = topoct = topbits = flags = 0;\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase STATE_1ST_HALF:\n\t\t\tswitch (*modestr) {\n\t\t\tcase 'D':\n\t\t\t\tif (flags & FLAG_FILES_ONLY)\n\t\t\t\t\tstate = STATE_ERROR;\n\t\t\t\tflags |= FLAG_DIRS_ONLY;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tif (flags & FLAG_DIRS_ONLY)\n\t\t\t\t\tstate = STATE_ERROR;\n\t\t\t\tflags |= FLAG_FILES_ONLY;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhere |= 0100;\n\t\t\t\ttopbits |= 04000;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\twhere |= 0010;\n\t\t\t\ttopbits |= 02000;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\twhere |= 0001;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\twhere |= 0111;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\top = CHMOD_ADD;\n\t\t\t\tstate = STATE_2ND_HALF;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\top = CHMOD_SUB;\n\t\t\t\tstate = STATE_2ND_HALF;\n\t\t\t\tbreak;\n\t\t\tcase '=':\n\t\t\t\top = CHMOD_EQ;\n\t\t\t\tstate = STATE_2ND_HALF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (isDigit(modestr) && *modestr < '8' && !where) {\n\t\t\t\t\top = CHMOD_SET;\n\t\t\t\t\tstate =  STATE_OCTAL_NUM;\n\t\t\t\t\twhere = 1;\n\t\t\t\t\twhat = *modestr - '0';\n\t\t\t\t} else\n\t\t\t\t\tstate = STATE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_2ND_HALF:\n\t\t\tswitch (*modestr) {\n\t\t\tcase 'r':\n\t\t\t\twhat |= 4;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\twhat |= 2;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tflags |= FLAG_X_KEEP;\n\t\t\t\t/* FALL THROUGH */\n\t\t\tcase 'x':\n\t\t\t\twhat |= 1;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (topbits)\n\t\t\t\t\ttopoct |= topbits;\n\t\t\t\telse\n\t\t\t\t\ttopoct = 04000;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\ttopoct |= 01000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = STATE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_OCTAL_NUM:\n\t\t\tif (isDigit(modestr) && *modestr < '8') {\n\t\t\t\twhat = what*8 + *modestr - '0';\n\t\t\t\tif (what > CHMOD_BITS)\n\t\t\t\t\tstate = STATE_ERROR;\n\t\t\t} else\n\t\t\t\tstate = STATE_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tmodestr++;\n\t}\n\n\tif (state == STATE_ERROR) {\n\t\tfree_chmod_mode(first_mode);\n\t\treturn NULL;\n\t}\n\n\tif (!(curr_mode = *root_mode_ptr))\n\t\t*root_mode_ptr = first_mode;\n\telse {\n\t\twhile (curr_mode->next)\n\t\t\tcurr_mode = curr_mode->next;\n\t\tcurr_mode->next = first_mode;\n\t}\n\n\treturn first_mode;\n}\n\n\n/* Takes an existing file permission and a list of AND/OR changes, and\n * create a new permissions. */\nint tweak_mode(int mode, struct chmod_mode_struct *chmod_modes)\n{\n\tint IsX = mode & 0111;\n\tint NonPerm = mode & ~CHMOD_BITS;\n\n\tfor ( ; chmod_modes; chmod_modes = chmod_modes->next) {\n\t\tif ((chmod_modes->flags & FLAG_DIRS_ONLY) && !S_ISDIR(NonPerm))\n\t\t\tcontinue;\n\t\tif ((chmod_modes->flags & FLAG_FILES_ONLY) && S_ISDIR(NonPerm))\n\t\t\tcontinue;\n\t\tmode &= chmod_modes->ModeAND;\n\t\tif ((chmod_modes->flags & FLAG_X_KEEP) && !IsX && !S_ISDIR(NonPerm))\n\t\t\tmode |= chmod_modes->ModeOR & ~0111;\n\t\telse\n\t\t\tmode |= chmod_modes->ModeOR;\n\t}\n\n\treturn mode | NonPerm;\n}\n\n/* Free the linked list created by parse_chmod. */\nint free_chmod_mode(struct chmod_mode_struct *chmod_modes)\n{\n\tstruct chmod_mode_struct *next;\n\n\twhile (chmod_modes) {\n\t\tnext = chmod_modes->next;\n\t\tfree(chmod_modes);\n\t\tchmod_modes = next;\n\t}\n\treturn 0;\n}\n"
        },
        {
          "name": "cleanup.c",
          "type": "blob",
          "size": 7.615234375,
          "content": "/*\n * End-of-run cleanup routines.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2003-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\nextern int dry_run;\nextern int am_server;\nextern int am_daemon;\nextern int am_receiver;\nextern int am_sender;\nextern int io_error;\nextern int keep_partial;\nextern int got_xfer_error;\nextern int protocol_version;\nextern int output_needs_newline;\nextern char *partial_dir;\nextern char *logfile_name;\n\nint called_from_signal_handler = 0;\nBOOL shutting_down = False;\nBOOL flush_ok_after_signal = False;\n\n#ifdef HAVE_SIGACTION\nstatic struct sigaction sigact;\n#endif\n\n/**\n * Close all open sockets and files, allowing a (somewhat) graceful\n * shutdown() of socket connections.  This eliminates the abortive\n * TCP RST sent by a Winsock-based system when the close() occurs.\n **/\nvoid close_all(void)\n{\n#ifdef SHUTDOWN_ALL_SOCKETS\n\tint max_fd;\n\tint fd;\n\tint ret;\n\tSTRUCT_STAT st;\n\n\tmax_fd = sysconf(_SC_OPEN_MAX) - 1;\n\tfor (fd = max_fd; fd >= 0; fd--) {\n\t\tif ((ret = do_fstat(fd, &st)) == 0) {\n\t\t\tif (is_a_socket(fd))\n\t\t\t\tret = shutdown(fd, 2);\n\t\t\tret = close(fd);\n\t\t}\n\t}\n#endif\n}\n\n/**\n * @file cleanup.c\n *\n * Code for handling interrupted transfers.  Depending on the @c\n * --partial option, we may either delete the temporary file, or go\n * ahead and overwrite the destination.  This second behaviour only\n * occurs if we've sent literal data and therefore hopefully made\n * progress on the transfer.\n **/\n\n/**\n * Set to True once literal data has been sent across the link for the\n * current file. (????)\n *\n * Handling the cleanup when a transfer is interrupted is tricky when\n * --partial is selected.  We need to ensure that the partial file is\n * kept if any real data has been transferred.\n **/\nint cleanup_got_literal = 0;\n\nstatic const char *cleanup_fname;\nstatic const char *cleanup_new_fname;\nstatic struct file_struct *cleanup_file;\nstatic int cleanup_fd_r = -1, cleanup_fd_w = -1;\nstatic pid_t cleanup_pid = 0;\n\npid_t cleanup_child_pid = -1;\n\n/**\n * Eventually calls exit(), passing @p code, therefore does not return.\n *\n * @param code one of the RERR_* codes from errcode.h.\n **/\nNORETURN void _exit_cleanup(int code, const char *file, int line)\n{\n\tstatic int switch_step = 0;\n\tstatic int exit_code = 0, exit_line = 0;\n\tstatic const char *exit_file = NULL;\n\tstatic int first_code = 0;\n\n\tSIGACTION(SIGUSR1, SIG_IGN);\n\tSIGACTION(SIGUSR2, SIG_IGN);\n\n\tif (!exit_code) { /* Preserve first error exit info when recursing. */\n\t\texit_code = code;\n\t\texit_file = file;\n\t\texit_line = line < 0 ? -line : line;\n\t}\n\n\t/* If this is the exit at the end of the run, the server side\n\t * should not attempt to output a message (see log_exit()). */\n\tif (am_server && code == 0)\n\t\tam_server = 2;\n\n\t/* Some of our actions might cause a recursive call back here, so we\n\t * keep track of where we are in the cleanup and never repeat a step. */\n\tswitch (switch_step) {\n#include \"case_N.h\" /* case 0: */\n\t\tswitch_step++;\n\n\t\tfirst_code = code;\n\n\t\tif (output_needs_newline) {\n\t\t\tfputc('\\n', stdout);\n\t\t\toutput_needs_newline = 0;\n\t\t}\n\n\t\tif (DEBUG_GTE(EXIT, 2)) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"[%s] _exit_cleanup(code=%d, file=%s, line=%d): entered\\n\",\n\t\t\t\twho_am_i(), code, src_file(file), line);\n\t\t}\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (cleanup_child_pid != -1) {\n\t\t\tint status;\n\t\t\tint pid = wait_process(cleanup_child_pid, &status, WNOHANG);\n\t\t\tif (pid == cleanup_child_pid) {\n\t\t\t\tstatus = WEXITSTATUS(status);\n\t\t\t\tif (status > exit_code)\n\t\t\t\t\texit_code = status;\n\t\t\t}\n\t\t}\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (cleanup_got_literal && (cleanup_fname || cleanup_fd_w != -1)) {\n\t\t\tif (cleanup_fd_r != -1) {\n\t\t\t\tclose(cleanup_fd_r);\n\t\t\t\tcleanup_fd_r = -1;\n\t\t\t}\n\t\t\tif (cleanup_fd_w != -1) {\n\t\t\t\tflush_write_file(cleanup_fd_w);\n\t\t\t\tclose(cleanup_fd_w);\n\t\t\t\tcleanup_fd_w = -1;\n\t\t\t}\n\t\t\tif (cleanup_fname && cleanup_new_fname && keep_partial\n\t\t\t && handle_partial_dir(cleanup_new_fname, PDIR_CREATE)) {\n\t\t\t\tint tweak_modtime = 0;\n\t\t\t\tconst char *fname = cleanup_fname;\n\t\t\t\tcleanup_fname = NULL;\n\t\t\t\tif (!partial_dir) {\n\t\t\t\t\t/* We don't want to leave a partial file with a modern time or it\n\t\t\t\t\t * could be skipped via --update.  Setting the time to something\n\t\t\t\t\t * really old also helps it to stand out as unfinished in an ls. */\n\t\t\t\t\ttweak_modtime = 1;\n\t\t\t\t\tcleanup_file->modtime = 0;\n\t\t\t\t}\n\t\t\t\tfinish_transfer(cleanup_new_fname, fname, NULL, NULL,\n\t\t\t\t\t\tcleanup_file, tweak_modtime, !partial_dir);\n\t\t\t}\n\t\t}\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (flush_ok_after_signal) {\n\t\t\tflush_ok_after_signal = False;\n\t\t\tif (code == RERR_SIGNAL)\n\t\t\t\tio_flush(FULL_FLUSH);\n\t\t}\n\t\tif (!exit_code && !code)\n\t\t\tio_flush(FULL_FLUSH);\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (cleanup_fname)\n\t\t\tdo_unlink(cleanup_fname);\n\t\tif (exit_code)\n\t\t\tkill_all(SIGUSR1);\n\t\tif (cleanup_pid && cleanup_pid == getpid()) {\n\t\t\tchar *pidf = lp_pid_file();\n\t\t\tif (pidf && *pidf)\n\t\t\t\tunlink(lp_pid_file());\n\t\t}\n\n\t\tif (exit_code == 0) {\n\t\t\tif (code)\n\t\t\t\texit_code = code;\n\t\t\tif (io_error & IOERR_DEL_LIMIT)\n\t\t\t\texit_code = RERR_DEL_LIMIT;\n\t\t\tif (io_error & IOERR_VANISHED)\n\t\t\t\texit_code = RERR_VANISHED;\n\t\t\tif (io_error & IOERR_GENERAL || got_xfer_error)\n\t\t\t\texit_code = RERR_PARTIAL;\n\t\t}\n\n\t\t/* If line < 0, this exit is after a MSG_ERROR_EXIT event, so\n\t\t * we don't want to output a duplicate error. */\n\t\tif ((exit_code && line > 0)\n\t\t || am_daemon || (logfile_name && (am_server || !INFO_GTE(STATS, 1)))) {\n\t\t\tlog_exit(exit_code, exit_file, exit_line);\n\t\t}\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (DEBUG_GTE(EXIT, 1)) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"[%s] _exit_cleanup(code=%d, file=%s, line=%d): \"\n\t\t\t\t\"about to call exit(%d)%s\\n\",\n\t\t\t\twho_am_i(), first_code, exit_file, exit_line, exit_code,\n\t\t\t\tdry_run ? \" (DRY RUN)\" : \"\");\n\t\t}\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (exit_code && exit_code != RERR_SOCKETIO && exit_code != RERR_STREAMIO && exit_code != RERR_SIGNAL1\n\t\t && exit_code != RERR_TIMEOUT && !shutting_down) {\n\t\t\tif (protocol_version >= 31 || am_receiver) {\n\t\t\t\tif (line > 0) {\n\t\t\t\t\tif (DEBUG_GTE(EXIT, 3)) {\n\t\t\t\t\t\trprintf(FINFO, \"[%s] sending MSG_ERROR_EXIT with exit_code %d\\n\",\n\t\t\t\t\t\t\twho_am_i(), exit_code);\n\t\t\t\t\t}\n\t\t\t\t\tsend_msg_int(MSG_ERROR_EXIT, exit_code);\n\t\t\t\t}\n\t\t\t\tif (!am_sender)\n\t\t\t\t\tio_flush(MSG_FLUSH); /* Be sure to send all messages */\n\t\t\t\tnoop_io_until_death();\n\t\t\t}\n\t\t\telse if (!am_sender)\n\t\t\t\tio_flush(MSG_FLUSH); /* Be sure to send all messages */\n\t\t}\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\n\t\tif (am_server && exit_code)\n\t\t\tmsleep(100);\n\t\tclose_all();\n\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (called_from_signal_handler)\n\t\t_exit(exit_code);\n\texit(exit_code);\n}\n\nvoid cleanup_disable(void)\n{\n\tcleanup_fname = cleanup_new_fname = NULL;\n\tcleanup_fd_r = cleanup_fd_w = -1;\n\tcleanup_got_literal = 0;\n}\n\n\nvoid cleanup_set(const char *fnametmp, const char *fname, struct file_struct *file,\n\t\t int fd_r, int fd_w)\n{\n\tcleanup_fname = fnametmp;\n\tcleanup_new_fname = fname; /* can be NULL on a partial-dir failure */\n\tcleanup_file = file;\n\tcleanup_fd_r = fd_r;\n\tcleanup_fd_w = fd_w;\n}\n\nvoid cleanup_set_pid(pid_t pid)\n{\n\tcleanup_pid = pid;\n}\n"
        },
        {
          "name": "clientname.c",
          "type": "blob",
          "size": 13.6884765625,
          "content": "/*\n * Functions for looking up the remote name or addr of a socket.\n *\n * Copyright (C) 1992-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2002-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/*\n * This file is now converted to use the new-style getaddrinfo()\n * interface, which supports IPv6 but is also supported on recent\n * IPv4-only machines.  On systems that don't have that interface, we\n * emulate it using the KAME implementation.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n\nextern int am_daemon;\n\nstatic const char default_name[] = \"UNKNOWN\";\nstatic const char proxyv2sig[] = \"\\r\\n\\r\\n\\0\\r\\nQUIT\\n\";\n\nstatic char ipaddr_buf[100];\n\n#define PROXY_V2_SIG_SIZE ((int)sizeof proxyv2sig - 1)\n#define PROXY_V2_HEADER_SIZE (PROXY_V2_SIG_SIZE + 1 + 1 + 2)\n\n#define CMD_LOCAL 0\n#define CMD_PROXY 1\n\n#define PROXY_FAM_TCPv4 0x11\n#define PROXY_FAM_TCPv6 0x21\n\n#define GET_SOCKADDR_FAMILY(ss) ((struct sockaddr*)ss)->sa_family\n\nstatic void client_sockaddr(int fd, struct sockaddr_storage *ss, socklen_t *ss_len);\nstatic int check_name(const char *ipaddr, const struct sockaddr_storage *ss, char *name_buf, size_t name_buf_size);\nstatic int valid_ipaddr(const char *s, int allow_scope);\n\n/* Return the IP addr of the client as a string. */\nchar *client_addr(int fd)\n{\n\tstruct sockaddr_storage ss;\n\tsocklen_t length = sizeof ss;\n\n\tif (*ipaddr_buf)\n\t\treturn ipaddr_buf;\n\n\tif (am_daemon < 0) {\t/* daemon over --rsh mode */\n\t\tchar *env_str;\n\t\tstrlcpy(ipaddr_buf, \"0.0.0.0\", sizeof ipaddr_buf);\n\t\tif ((env_str = getenv(\"REMOTE_HOST\")) != NULL\n\t\t || (env_str = getenv(\"SSH_CONNECTION\")) != NULL\n\t\t || (env_str = getenv(\"SSH_CLIENT\")) != NULL\n\t\t || (env_str = getenv(\"SSH2_CLIENT\")) != NULL) {\n\t\t\tchar *p;\n\t\t\tstrlcpy(ipaddr_buf, env_str, sizeof ipaddr_buf);\n\t\t\t/* Truncate the value to just the IP address. */\n\t\t\tif ((p = strchr(ipaddr_buf, ' ')) != NULL)\n\t\t\t\t*p = '\\0';\n\t\t}\n\t\tif (valid_ipaddr(ipaddr_buf, True))\n\t\t\treturn ipaddr_buf;\n\t}\n\n\tclient_sockaddr(fd, &ss, &length);\n\tgetnameinfo((struct sockaddr *)&ss, length, ipaddr_buf, sizeof ipaddr_buf, NULL, 0, NI_NUMERICHOST);\n\n\treturn ipaddr_buf;\n}\n\n\n/**\n * Return the DNS name of the client.\n *\n * The name is statically cached so that repeated lookups are quick,\n * so there is a limit of one lookup per customer.\n *\n * If anything goes wrong, including the name->addr->name check, then\n * we just use \"UNKNOWN\", so you can use that value in hosts allow\n * lines.\n *\n * After translation from sockaddr to name we do a forward lookup to\n * make sure nobody is spoofing PTR records.\n **/\nchar *client_name(const char *ipaddr)\n{\n\tstatic char name_buf[100];\n\tchar port_buf[100];\n\tstruct sockaddr_storage ss;\n\tsocklen_t ss_len;\n\tstruct addrinfo hint, *answer;\n\tint err;\n\n\tif (*name_buf)\n\t\treturn name_buf;\n\n\tstrlcpy(name_buf, default_name, sizeof name_buf);\n\n\tif (strcmp(ipaddr, \"0.0.0.0\") == 0)\n\t\treturn name_buf;\n\n\tmemset(&ss, 0, sizeof ss);\n\tmemset(&hint, 0, sizeof hint);\n\n#ifdef AI_NUMERICHOST\n\thint.ai_flags = AI_NUMERICHOST;\n#endif\n\thint.ai_socktype = SOCK_STREAM;\n\n\tif ((err = getaddrinfo(ipaddr, NULL, &hint, &answer)) != 0) {\n\t\trprintf(FLOG, \"malformed address %s: %s\\n\", ipaddr, gai_strerror(err));\n\t\treturn name_buf;\n\t}\n\n\tswitch (answer->ai_family) {\n\tcase AF_INET:\n\t\tss_len = sizeof (struct sockaddr_in);\n\t\tmemcpy(&ss, answer->ai_addr, ss_len);\n\t\tbreak;\n#ifdef INET6\n\tcase AF_INET6:\n\t\tss_len = sizeof (struct sockaddr_in6);\n\t\tmemcpy(&ss, answer->ai_addr, ss_len);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tNOISY_DEATH(\"Unknown ai_family value\");\n\t}\n\tfreeaddrinfo(answer);\n\n\t/* reverse lookup */\n\terr = getnameinfo((struct sockaddr*)&ss, ss_len, name_buf, sizeof name_buf,\n\t\t\t  port_buf, sizeof port_buf, NI_NAMEREQD | NI_NUMERICSERV);\n\tif (err) {\n\t\tstrlcpy(name_buf, default_name, sizeof name_buf);\n\t\trprintf(FLOG, \"name lookup failed for %s: %s\\n\", ipaddr, gai_strerror(err));\n\t} else\n\t\tcheck_name(ipaddr, &ss, name_buf, sizeof name_buf);\n\n\treturn name_buf;\n}\n\n\n/* Try to read a proxy protocol header (V1 or V2). Returns 1 on success or 0 on failure. */\nint read_proxy_protocol_header(int fd)\n{\n\tunion {\n\t\tstruct {\n\t\t\tchar line[108];\n\t\t} v1;\n\t\tstruct {\n\t\t\tchar sig[PROXY_V2_SIG_SIZE];\n\t\t\tchar ver_cmd;\n\t\t\tchar fam;\n\t\t\tchar len[2];\n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\tchar src_addr[4];\n\t\t\t\t\tchar dst_addr[4];\n\t\t\t\t\tchar src_port[2];\n\t\t\t\t\tchar dst_port[2];\n\t\t\t\t} ip4;\n\t\t\t\tstruct {\n\t\t\t\t\tchar src_addr[16];\n\t\t\t\t\tchar dst_addr[16];\n\t\t\t\t\tchar src_port[2];\n\t\t\t\t\tchar dst_port[2];\n\t\t\t\t} ip6;\n\t\t\t\tstruct {\n\t\t\t\t\tchar src_addr[108];\n\t\t\t\t\tchar dst_addr[108];\n\t\t\t\t} unx;\n\t\t\t} addr;\n\t\t} v2;\n\t} hdr;\n\n\tread_buf(fd, (char*)&hdr, PROXY_V2_SIG_SIZE);\n\n\tif (memcmp(hdr.v2.sig, proxyv2sig, PROXY_V2_SIG_SIZE) == 0) { /* Proxy V2 */\n\t\tint ver, cmd, size;\n\n\t\tread_buf(fd, (char*)&hdr + PROXY_V2_SIG_SIZE, PROXY_V2_HEADER_SIZE - PROXY_V2_SIG_SIZE);\n\n\t\tver = (hdr.v2.ver_cmd & 0xf0) >> 4;\n\t\tcmd = (hdr.v2.ver_cmd & 0x0f);\n\t\tsize = (hdr.v2.len[0] << 8) + hdr.v2.len[1];\n\n\t\tif (ver != 2 || size + PROXY_V2_HEADER_SIZE > (int)sizeof hdr)\n\t\t\treturn 0;\n\n\t\t/* Grab all the remaining data in the binary request. */\n\t\tread_buf(fd, (char*)&hdr + PROXY_V2_HEADER_SIZE, size);\n\n\t\tswitch (cmd) {\n\t\tcase CMD_PROXY:\n\t\t\tswitch (hdr.v2.fam) {\n\t\t\tcase PROXY_FAM_TCPv4:\n\t\t\t\tif (size != sizeof hdr.v2.addr.ip4)\n\t\t\t\t\treturn 0;\n\t\t\t\tinet_ntop(AF_INET, hdr.v2.addr.ip4.src_addr, ipaddr_buf, sizeof ipaddr_buf);\n\t\t\t\treturn valid_ipaddr(ipaddr_buf, False);\n#ifdef INET6\n\t\t\tcase PROXY_FAM_TCPv6:\n\t\t\t\tif (size != sizeof hdr.v2.addr.ip6)\n\t\t\t\t\treturn 0;\n\t\t\t\tinet_ntop(AF_INET6, hdr.v2.addr.ip6.src_addr, ipaddr_buf, sizeof ipaddr_buf);\n\t\t\t\treturn valid_ipaddr(ipaddr_buf, False);\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For an unsupported protocol we'll ignore the proxy data (leaving ipaddr_buf unset)\n\t\t\t * and accept the connection, which will get handled as a normal socket addr. */\n\t\t\treturn 1;\n\t\tcase CMD_LOCAL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (memcmp(hdr.v1.line, \"PROXY\", 5) == 0) { /* Proxy V1 */\n\t\tchar *endc, *sp, *p = hdr.v1.line + PROXY_V2_SIG_SIZE;\n\t\tint port_chk;\n\n\t\t*p = '\\0';\n\t\tif (!strchr(hdr.v1.line, '\\n')) {\n\t\t\twhile (1) {\n\t\t\t\tread_buf(fd, p, 1);\n\t\t\t\tif (*p++ == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tif (p - hdr.v1.line >= (int)sizeof hdr.v1.line - 1)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\tendc = strchr(hdr.v1.line, '\\r');\n\t\tif (!endc || endc[1] != '\\n' || endc[2])\n\t\t\treturn 0;\n\t\t*endc = '\\0';\n\n\t\tp = hdr.v1.line + 5;\n\n\t\tif (!isSpace(p++))\n\t\t\treturn 0;\n\t\tif (strncmp(p, \"TCP4\", 4) == 0)\n\t\t\tp += 4;\n\t\telse if (strncmp(p, \"TCP6\", 4) == 0)\n\t\t\tp += 4;\n\t\telse if (strncmp(p, \"UNKNOWN\", 7) == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\n\t\tif (!isSpace(p++))\n\t\t\treturn 0;\n\n\t\tif ((sp = strchr(p, ' ')) == NULL)\n\t\t\treturn 0;\n\t\t*sp = '\\0';\n\t\tif (!valid_ipaddr(p, False))\n\t\t\treturn 0;\n\t\tstrlcpy(ipaddr_buf, p, sizeof ipaddr_buf); /* It will always fit when valid. */\n\n\t\tp = sp + 1;\n\t\tif ((sp = strchr(p, ' ')) == NULL)\n\t\t\treturn 0;\n\t\t*sp = '\\0';\n\t\tif (!valid_ipaddr(p, False))\n\t\t\treturn 0;\n\t\t/* Ignore destination address. */\n\n\t\tp = sp + 1;\n\t\tif ((sp = strchr(p, ' ')) == NULL)\n\t\t\treturn 0;\n\t\t*sp = '\\0';\n\t\tport_chk = strtol(p, &endc, 10);\n\t\tif (*endc || port_chk == 0)\n\t\t\treturn 0;\n\t\t/* Ignore source port. */\n\n\t\tp = sp + 1;\n\t\tport_chk = strtol(p, &endc, 10);\n\t\tif (*endc || port_chk == 0)\n\t\t\treturn 0;\n\t\t/* Ignore destination port. */\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n/**\n * Get the sockaddr for the client.\n *\n * If it comes in as an ipv4 address mapped into IPv6 format then we\n * convert it back to a regular IPv4.\n **/\nstatic void client_sockaddr(int fd, struct sockaddr_storage *ss, socklen_t *ss_len)\n{\n\tmemset(ss, 0, sizeof *ss);\n\n\tif (getpeername(fd, (struct sockaddr *) ss, ss_len)) {\n\t\t/* FIXME: Can we really not continue? */\n\t\trsyserr(FLOG, errno, \"getpeername on fd%d failed\", fd);\n\t\texit_cleanup(RERR_SOCKETIO);\n\t}\n\n#ifdef INET6\n\tif (GET_SOCKADDR_FAMILY(ss) == AF_INET6\n\t && IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)ss)->sin6_addr)) {\n\t\t/* OK, so ss is in the IPv6 family, but it is really\n\t\t * an IPv4 address: something like\n\t\t * \"::ffff:10.130.1.2\".  If we use it as-is, then the\n\t\t * reverse lookup might fail or perhaps something else\n\t\t * bad might happen.  So instead we convert it to an\n\t\t * equivalent address in the IPv4 address family.  */\n\t\tstruct sockaddr_in6 sin6;\n\t\tstruct sockaddr_in *sin;\n\n\t\tmemcpy(&sin6, ss, sizeof sin6);\n\t\tsin = (struct sockaddr_in *)ss;\n\t\tmemset(sin, 0, sizeof *sin);\n\t\tsin->sin_family = AF_INET;\n\t\t*ss_len = sizeof (struct sockaddr_in);\n#ifdef HAVE_SOCKADDR_IN_LEN\n\t\tsin->sin_len = *ss_len;\n#endif\n\t\tsin->sin_port = sin6.sin6_port;\n\n\t\t/* There is a macro to extract the mapped part\n\t\t * (IN6_V4MAPPED_TO_SINADDR ?), but it does not seem\n\t\t * to be present in the Linux headers. */\n\t\tmemcpy(&sin->sin_addr, &sin6.sin6_addr.s6_addr[12], sizeof sin->sin_addr);\n\t}\n#endif\n}\n\n\n/**\n * Compare an addrinfo from the resolver to a sockinfo.\n *\n * Like strcmp, returns 0 for identical.\n **/\nstatic int compare_addrinfo_sockaddr(const struct addrinfo *ai, const struct sockaddr_storage *ss)\n{\n\tint ss_family = GET_SOCKADDR_FAMILY(ss);\n\tconst char fn[] = \"compare_addrinfo_sockaddr\";\n\n\tif (ai->ai_family != ss_family) {\n\t\trprintf(FLOG, \"%s: response family %d != %d\\n\",\n\t\t\tfn, ai->ai_family, ss_family);\n\t\treturn 1;\n\t}\n\n\t/* The comparison method depends on the particular AF. */\n\tif (ss_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin1, *sin2;\n\n\t\tsin1 = (const struct sockaddr_in *) ss;\n\t\tsin2 = (const struct sockaddr_in *) ai->ai_addr;\n\n\t\treturn memcmp(&sin1->sin_addr, &sin2->sin_addr, sizeof sin1->sin_addr);\n\t}\n\n#ifdef INET6\n\tif (ss_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin1, *sin2;\n\n\t\tsin1 = (const struct sockaddr_in6 *) ss;\n\t\tsin2 = (const struct sockaddr_in6 *) ai->ai_addr;\n\n\t\tif (ai->ai_addrlen < (int)sizeof (struct sockaddr_in6)) {\n\t\t\trprintf(FLOG, \"%s: too short sockaddr_in6; length=%d\\n\",\n\t\t\t\tfn, (int)ai->ai_addrlen);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (memcmp(&sin1->sin6_addr, &sin2->sin6_addr, sizeof sin1->sin6_addr))\n\t\t\treturn 1;\n\n#ifdef HAVE_SOCKADDR_IN6_SCOPE_ID\n\t\tif (sin1->sin6_scope_id != sin2->sin6_scope_id)\n\t\t\treturn 1;\n#endif\n\t\treturn 0;\n\t}\n#endif /* INET6 */\n\n\t/* don't know */\n\treturn 1;\n}\n\n\n/**\n * Do a forward lookup on @p name_buf and make sure it corresponds to\n * @p ss -- otherwise we may be being spoofed.  If we suspect we are,\n * then we don't abort the connection but just emit a warning, and\n * change @p name_buf to be \"UNKNOWN\".\n *\n * We don't do anything with the service when checking the name,\n * because it doesn't seem that it could be spoofed in any way, and\n * getaddrinfo on random service names seems to cause problems on AIX.\n **/\nstatic int check_name(const char *ipaddr, const struct sockaddr_storage *ss, char *name_buf, size_t name_buf_size)\n{\n\tstruct addrinfo hints, *res, *res0;\n\tint error;\n\tint ss_family = GET_SOCKADDR_FAMILY(ss);\n\n\tmemset(&hints, 0, sizeof hints);\n\thints.ai_family = ss_family;\n\thints.ai_flags = AI_CANONNAME;\n\thints.ai_socktype = SOCK_STREAM;\n\terror = getaddrinfo(name_buf, NULL, &hints, &res0);\n\tif (error) {\n\t\trprintf(FLOG, \"forward name lookup for %s failed: %s\\n\",\n\t\t\tname_buf, gai_strerror(error));\n\t\tstrlcpy(name_buf, default_name, name_buf_size);\n\t\treturn error;\n\t}\n\n\t/* Given all these results, we expect that one of them will be\n\t * the same as ss.  The comparison is a bit complicated. */\n\tfor (res = res0; res; res = res->ai_next) {\n\t\tif (!compare_addrinfo_sockaddr(res, ss))\n\t\t\tbreak;\t/* OK, identical */\n\t}\n\n\tif (!res0) {\n\t\t/* We hit the end of the list without finding an\n\t\t * address that was the same as ss. */\n\t\trprintf(FLOG, \"no known address for \\\"%s\\\": \"\n\t\t\t\"spoofed address?\\n\", name_buf);\n\t\tstrlcpy(name_buf, default_name, name_buf_size);\n\t} else if (res == NULL) {\n\t\t/* We hit the end of the list without finding an\n\t\t * address that was the same as ss. */\n\t\trprintf(FLOG, \"%s is not a known address for \\\"%s\\\": \"\n\t\t\t\"spoofed address?\\n\", ipaddr, name_buf);\n\t\tstrlcpy(name_buf, default_name, name_buf_size);\n\t}\n\n\tfreeaddrinfo(res0);\n\treturn 0;\n}\n\n/* Returns 1 for a valid IPv4 or IPv6 addr, or 0 for a bad one. */\nstatic int valid_ipaddr(const char *s, int allow_scope)\n{\n\tint i;\n\n\tif (strchr(s, ':') != NULL) { /* Only IPv6 has a colon. */\n\t\tint count, saw_double_colon = 0;\n\t\tint ipv4_at_end = 0;\n\n\t\tif (*s == ':') { /* A colon at the start must be a :: */\n\t\t\tif (*++s != ':')\n\t\t\t\treturn 0;\n\t\t\tsaw_double_colon = 1;\n\t\t\ts++;\n\t\t}\n\n\t\tfor (count = 0; count < 8; count++) {\n\t\t\tif (!*s)\n\t\t\t\treturn saw_double_colon;\n\t\t\tif (allow_scope && *s == '%') {\n\t\t\t\tif (saw_double_colon)\n\t\t\t\t\tbreak;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (strchr(s, ':') == NULL && strchr(s, '.') != NULL) {\n\t\t\t\tif ((!saw_double_colon && count != 6) || (saw_double_colon && count > 6))\n\t\t\t\t\treturn 0;\n\t\t\t\tipv4_at_end = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!isHexDigit(s++)) /* Need 1-4 hex digits */\n\t\t\t\treturn 0;\n\t\t\tif (isHexDigit(s) && isHexDigit(++s) && isHexDigit(++s) && isHexDigit(++s))\n\t\t\t\treturn 0;\n\n\t\t\tif (*s == ':') {\n\t\t\t\tif (!*++s)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (*s == ':') {\n\t\t\t\t\tif (saw_double_colon)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tsaw_double_colon = 1;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ipv4_at_end) {\n\t\t\tif (allow_scope && *s == '%')\n\t\t\t\tfor (s++; isAlNum(s); s++) { }\n\t\t\treturn !*s && s[-1] != '%';\n\t\t}\n\t}\n\n\t/* IPv4 */\n\tfor (i = 0; i < 4; i++) {\n\t\tlong n;\n\t\tchar *end;\n\n\t\tif (i && *s++ != '.')\n\t\t\treturn 0;\n\t\tn = strtol(s, &end, 10);\n\t\tif (n > 255 || n < 0 || end <= s || end > s+3)\n\t\t\treturn 0;\n\t\ts = end;\n\t}\n\n\treturn !*s;\n}\n"
        },
        {
          "name": "clientserver.c",
          "type": "blob",
          "size": 39.8857421875,
          "content": "/*\n * The socket based protocol for setting up a connection with rsyncd.\n *\n * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 2001-2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2002-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"ifuncs.h\"\n\nextern int quiet;\nextern int dry_run;\nextern int output_motd;\nextern int list_only;\nextern int am_sender;\nextern int am_server;\nextern int am_daemon;\nextern int am_root;\nextern int msgs2stderr;\nextern int rsync_port;\nextern int protect_args;\nextern int ignore_errors;\nextern int preserve_xattrs;\nextern int kluge_around_eof;\nextern int munge_symlinks;\nextern int open_noatime;\nextern int sanitize_paths;\nextern int numeric_ids;\nextern int filesfrom_fd;\nextern int remote_protocol;\nextern int protocol_version;\nextern int io_timeout;\nextern int no_detach;\nextern int write_batch;\nextern int old_style_args;\nextern int default_af_hint;\nextern int logfile_format_has_i;\nextern int logfile_format_has_o_or_i;\nextern char *bind_address;\nextern char *config_file;\nextern char *logfile_format;\nextern char *files_from;\nextern char *tmpdir;\nextern char *early_input_file;\nextern struct chmod_mode_struct *chmod_modes;\nextern filter_rule_list daemon_filter_list;\n#ifdef ICONV_OPTION\nextern char *iconv_opt;\nextern iconv_t ic_send, ic_recv;\n#endif\nextern uid_t our_uid;\nextern gid_t our_gid;\n\nchar *auth_user;\nchar *daemon_auth_choices;\nint read_only = 0;\nint module_id = -1;\nint pid_file_fd = -1;\nint early_input_len = 0;\nchar *early_input = NULL;\npid_t namecvt_pid = 0;\nstruct chmod_mode_struct *daemon_chmod_modes;\n\n#define EARLY_INPUT_CMD \"#early_input=\"\n#define EARLY_INPUT_CMDLEN (sizeof EARLY_INPUT_CMD - 1)\n\n/* module_dirlen is the length of the module_dir string when in daemon\n * mode and module_dir is not \"/\"; otherwise 0.  (Note that a chroot-\n * enabled module can have a non-\"/\" module_dir these days.) */\nchar *module_dir = NULL;\nunsigned int module_dirlen = 0;\n\nchar *full_module_path;\n\nstatic int rl_nulls = 0;\nstatic int namecvt_fd_req = -1, namecvt_fd_ans = -1;\n\n#ifdef HAVE_SIGACTION\nstatic struct sigaction sigact;\n#endif\n\nstatic item_list gid_list = EMPTY_ITEM_LIST;\n\n/* Used when \"reverse lookup\" is off. */\nconst char undetermined_hostname[] = \"UNDETERMINED\";\n\n/**\n * Run a client connected to an rsyncd.  The alternative to this\n * function for remote-shell connections is do_cmd().\n *\n * After negotiating which module to use and reading the server's\n * motd, this hands over to client_run().  Telling the server the\n * module will cause it to chroot/setuid/etc.\n *\n * Instead of doing a transfer, the client may at this stage instead\n * get a listing of remote modules and exit.\n *\n * @return -1 for error in startup, or the result of client_run().\n * Either way, it eventually gets passed to exit_cleanup().\n **/\nint start_socket_client(char *host, int remote_argc, char *remote_argv[],\n\t\t\tint argc, char *argv[])\n{\n\tint fd, ret;\n\tchar *p, *user = NULL;\n\n\t/* This is redundant with code in start_inband_exchange(), but this\n\t * short-circuits a problem in the client before we open a socket,\n\t * and the extra check won't hurt. */\n\tif (**remote_argv == '/') {\n\t\trprintf(FERROR,\n\t\t\t\"ERROR: The remote path must start with a module name not a /\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((p = strrchr(host, '@')) != NULL) {\n\t\tuser = host;\n\t\thost = p+1;\n\t\t*p = '\\0';\n\t}\n\n\tfd = open_socket_out_wrapped(host, rsync_port, bind_address, default_af_hint);\n\tif (fd == -1)\n\t\texit_cleanup(RERR_SOCKETIO);\n\n#ifdef ICONV_CONST\n\tsetup_iconv();\n#endif\n\n\tret = start_inband_exchange(fd, fd, user, remote_argc, remote_argv);\n\n\treturn ret ? ret : client_run(fd, fd, -1, argc, argv);\n}\n\nstatic int exchange_protocols(int f_in, int f_out, char *buf, size_t bufsiz, int am_client)\n{\n\tint remote_sub = -1;\n\tint our_sub = get_subprotocol_version();\n\n\toutput_daemon_greeting(f_out, am_client);\n\tif (!am_client) {\n\t\tchar *motd = lp_motd_file();\n\t\tif (motd && *motd) {\n\t\t\tFILE *f = fopen(motd, \"r\");\n\t\t\twhile (f && !feof(f)) {\n\t\t\t\tint len = fread(buf, 1, bufsiz - 1, f);\n\t\t\t\tif (len > 0)\n\t\t\t\t\twrite_buf(f_out, buf, len);\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tfclose(f);\n\t\t\twrite_sbuf(f_out, \"\\n\");\n\t\t}\n\t}\n\n\t/* This strips the \\n. */\n\tif (!read_line_old(f_in, buf, bufsiz, 0)) {\n\t\tif (am_client)\n\t\t\trprintf(FERROR, \"rsync: did not see server greeting\\n\");\n\t\treturn -1;\n\t}\n\n\tif (sscanf(buf, \"@RSYNCD: %d.%d\", &remote_protocol, &remote_sub) < 1) {\n\t\tif (am_client)\n\t\t\trprintf(FERROR, \"rsync: server sent \\\"%s\\\" rather than greeting\\n\", buf);\n\t\telse\n\t\t\tio_printf(f_out, \"@ERROR: protocol startup error\\n\");\n\t\treturn -1;\n\t}\n\n\tif (remote_sub < 0) {\n\t\tif (remote_protocol >= 30) {\n\t\t\tif (am_client)\n\t\t\t\trprintf(FERROR, \"rsync: the server omitted the subprotocol value: %s\\n\", buf);\n\t\t\telse\n\t\t\t\tio_printf(f_out, \"@ERROR: your client omitted the subprotocol value: %s\\n\", buf);\n\t\t\treturn -1;\n\t\t}\n\t\tremote_sub = 0;\n\t}\n\n\tdaemon_auth_choices = strchr(buf + 9, ' ');\n\tif (daemon_auth_choices) {\n\t\tchar *cp;\n\t\tdaemon_auth_choices = strdup(daemon_auth_choices + 1);\n\t\tif ((cp = strchr(daemon_auth_choices, '\\n')) != NULL)\n\t\t\t*cp = '\\0';\n\t} else if (remote_protocol > 31) {\n\t\tif (am_client)\n\t\t\trprintf(FERROR, \"rsync: the server omitted the digest name list: %s\\n\", buf);\n\t\telse\n\t\t\tio_printf(f_out, \"@ERROR: your client omitted the digest name list: %s\\n\", buf);\n\t\treturn -1;\n\t}\n\n\tif (protocol_version > remote_protocol) {\n\t\tprotocol_version = remote_protocol;\n\t\tif (remote_sub)\n\t\t\tprotocol_version--;\n\t} else if (protocol_version == remote_protocol) {\n\t\tif (remote_sub != our_sub)\n\t\t\tprotocol_version--;\n\t}\n#if SUBPROTOCOL_VERSION != 0\n\telse if (protocol_version < remote_protocol) {\n\t\tif (our_sub)\n\t\t\tprotocol_version--;\n\t}\n#endif\n\n\tif (protocol_version >= 30)\n\t\trl_nulls = 1;\n\n\treturn 0;\n}\n\nint start_inband_exchange(int f_in, int f_out, const char *user, int argc, char *argv[])\n{\n\tint i, modlen;\n\tchar line[BIGPATHBUFLEN];\n\tchar *sargs[MAX_ARGS];\n\tint sargc = 0;\n\tchar *p, *modname;\n\n\tassert(argc > 0 && *argv != NULL);\n\n\tif (**argv == '/') {\n\t\trprintf(FERROR,\n\t\t\t\"ERROR: The remote path must start with a module name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!(p = strchr(*argv, '/')))\n\t\tmodlen = strlen(*argv);\n\telse\n\t\tmodlen = p - *argv;\n\n\tmodname = new_array(char, modlen+1+1); /* room for '/' & '\\0' */\n\tstrlcpy(modname, *argv, modlen + 1);\n\tmodname[modlen] = '/';\n\tmodname[modlen+1] = '\\0';\n\n\tif (!user)\n\t\tuser = getenv(\"USER\");\n\tif (!user)\n\t\tuser = getenv(\"LOGNAME\");\n\n\tif (exchange_protocols(f_in, f_out, line, sizeof line, 1) < 0)\n\t\treturn -1;\n\n\tif (early_input_file) {\n\t\tSTRUCT_STAT st;\n\t\tFILE *f = fopen(early_input_file, \"rb\");\n\t\tif (!f || do_fstat(fileno(f), &st) < 0) {\n\t\t\trsyserr(FERROR, errno, \"failed to open %s\", early_input_file);\n\t\t\treturn -1;\n\t\t}\n\t\tearly_input_len = st.st_size;\n\t\tif (early_input_len > (int)sizeof line) {\n\t\t\trprintf(FERROR, \"%s is > %d bytes.\\n\", early_input_file, (int)sizeof line);\n\t\t\treturn -1;\n\t\t}\n\t\tif (early_input_len > 0) {\n\t\t\tio_printf(f_out, EARLY_INPUT_CMD \"%d\\n\", early_input_len);\n\t\t\twhile (early_input_len > 0) {\n\t\t\t\tint len;\n\t\t\t\tif (feof(f)) {\n\t\t\t\t\trprintf(FERROR, \"Early EOF in %s\\n\", early_input_file);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tlen = fread(line, 1, early_input_len, f);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\twrite_buf(f_out, line, len);\n\t\t\t\t\tearly_input_len -= len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(f);\n\t}\n\n\tserver_options(sargs, &sargc);\n\n\tif (sargc >= MAX_ARGS - 2)\n\t\tgoto arg_overflow;\n\n\tsargs[sargc++] = \".\";\n\n\tif (!old_style_args)\n\t\tsnprintf(line, sizeof line, \" %.*s/\", modlen, modname);\n\n\twhile (argc > 0) {\n\t\tif (sargc >= MAX_ARGS - 1) {\n\t\t  arg_overflow:\n\t\t\trprintf(FERROR, \"internal: args[] overflowed in do_cmd()\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tif (strncmp(*argv, modname, modlen) == 0 && argv[0][modlen] == '\\0')\n\t\t\tsargs[sargc++] = modname; /* we send \"modname/\" */\n\t\telse {\n\t\t\tchar *arg = *argv;\n\t\t\tint extra_chars = *arg == '-' ? 2 : 0; /* a leading dash needs a \"./\" prefix. */\n\t\t\t/* If --old-args was not specified, make sure that the arg won't split at a mod name! */\n\t\t\tif (!old_style_args && (p = strstr(arg, line)) != NULL) {\n\t\t\t\tdo {\n\t\t\t\t\textra_chars += 2;\n\t\t\t\t} while ((p = strstr(p+1, line)) != NULL);\n\t\t\t}\n\t\t\tif (extra_chars) {\n\t\t\t\tchar *f = arg;\n\t\t\t\tchar *t = arg = new_array(char, strlen(arg) + extra_chars + 1);\n\t\t\t\tif (*f == '-') {\n\t\t\t\t\t*t++ = '.';\n\t\t\t\t\t*t++ = '/';\n\t\t\t\t}\n\t\t\t\twhile (*f) {\n\t\t\t\t\tif (*f == ' ' && strncmp(f, line, modlen+2) == 0) {\n\t\t\t\t\t\t*t++ = '[';\n\t\t\t\t\t\t*t++ = *f++;\n\t\t\t\t\t\t*t++ = ']';\n\t\t\t\t\t} else\n\t\t\t\t\t\t*t++ = *f++;\n\t\t\t\t}\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tsargs[sargc++] = arg;\n\t\t}\n\t\targv++;\n\t\targc--;\n\t}\n\n\tsargs[sargc] = NULL;\n\n\tif (DEBUG_GTE(CMD, 1))\n\t\tprint_child_argv(\"sending daemon args:\", sargs);\n\n\tio_printf(f_out, \"%.*s\\n\", modlen, modname);\n\n\t/* Old servers may just drop the connection here,\n\t rather than sending a proper EXIT command.  Yuck. */\n\tkluge_around_eof = list_only && protocol_version < 25 ? 1 : 0;\n\n\twhile (1) {\n\t\tif (!read_line_old(f_in, line, sizeof line, 0)) {\n\t\t\trprintf(FERROR, \"rsync: didn't get server startup line\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (strncmp(line,\"@RSYNCD: AUTHREQD \",18) == 0) {\n\t\t\tauth_client(f_out, user, line+18);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(line,\"@RSYNCD: OK\") == 0)\n\t\t\tbreak;\n\n\t\tif (strcmp(line,\"@RSYNCD: EXIT\") == 0) {\n\t\t\t/* This is sent by recent versions of the\n\t\t\t * server to terminate the listing of modules.\n\t\t\t * We don't want to go on and transfer\n\t\t\t * anything; just exit. */\n\t\t\texit(0);\n\t\t}\n\n\t\tif (strncmp(line, \"@ERROR\", 6) == 0) {\n\t\t\trprintf(FERROR, \"%s\\n\", line);\n\t\t\t/* This is always fatal; the server will now\n\t\t\t * close the socket. */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* This might be a MOTD line or a module listing, but there is\n\t\t * no way to differentiate it.  The manpage mentions this. */\n\t\tif (output_motd)\n\t\t\trprintf(FINFO, \"%s\\n\", line);\n\t}\n\tkluge_around_eof = 0;\n\n\tif (rl_nulls) {\n\t\tfor (i = 0; i < sargc; i++) {\n\t\t\tif (!sargs[i]) /* stop at --secluded-args NULL */\n\t\t\t\tbreak;\n\t\t\twrite_sbuf(f_out, sargs[i]);\n\t\t\twrite_byte(f_out, 0);\n\t\t}\n\t\twrite_byte(f_out, 0);\n\t} else {\n\t\tfor (i = 0; i < sargc; i++)\n\t\t\tio_printf(f_out, \"%s\\n\", sargs[i]);\n\t\twrite_sbuf(f_out, \"\\n\");\n\t}\n\n\tif (protect_args)\n\t\tsend_protected_args(f_out, sargs);\n\n\tif (protocol_version < 23) {\n\t\tif (protocol_version == 22 || !am_sender)\n\t\t\tio_start_multiplex_in(f_in);\n\t}\n\n\tfree(modname);\n\n\treturn 0;\n}\n\n#if defined HAVE_SETENV || defined HAVE_PUTENV\nstatic int read_arg_from_pipe(int fd, char *buf, int limit)\n{\n\tchar *bp = buf, *eob = buf + limit - 1;\n\n\twhile (1) {\n\t\tint got = read(fd, bp, 1);\n\t\tif (got != 1) {\n\t\t\tif (got < 0 && errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (*bp == '\\0')\n\t\t\tbreak;\n\t\tif (bp < eob)\n\t\t\tbp++;\n\t}\n\t*bp = '\\0';\n\n\treturn bp - buf;\n}\n#endif\n\nvoid set_env_str(const char *var, const char *str)\n{\n#ifdef HAVE_SETENV\n\tif (setenv(var, str, 1) < 0)\n\t\tout_of_memory(\"set_env_str\");\n#else\n#ifdef HAVE_PUTENV\n\tchar *mem;\n\tif (asprintf(&mem, \"%s=%s\", var, str) < 0)\n\t\tout_of_memory(\"set_env_str\");\n\tputenv(mem);\n#else\n\t(void)var;\n\t(void)str;\n#endif\n#endif\n}\n\n#if defined HAVE_SETENV || defined HAVE_PUTENV\n\nstatic void set_envN_str(const char *var, int num, const char *str)\n{\n#ifdef HAVE_SETENV\n\tchar buf[128];\n\t(void)snprintf(buf, sizeof buf, \"%s%d\", var, num);\n\tif (setenv(buf, str, 1) < 0)\n\t\tout_of_memory(\"set_env_str\");\n#else\n#ifdef HAVE_PUTENV\n\tchar *mem;\n\tif (asprintf(&mem, \"%s%d=%s\", var, num, str) < 0)\n\t\tout_of_memory(\"set_envN_str\");\n\tputenv(mem);\n#endif\n#endif\n}\n\nvoid set_env_num(const char *var, long num)\n{\n#ifdef HAVE_SETENV\n\tchar val[64];\n\t(void)snprintf(val, sizeof val, \"%ld\", num);\n\tif (setenv(var, val, 1) < 0)\n\t\tout_of_memory(\"set_env_str\");\n#else\n#ifdef HAVE_PUTENV\n\tchar *mem;\n\tif (asprintf(&mem, \"%s=%ld\", var, num) < 0)\n\t\tout_of_memory(\"set_env_num\");\n\tputenv(mem);\n#endif\n#endif\n}\n\n/* Used for \"early exec\", \"pre-xfer exec\", and the \"name converter\" script. */\nstatic pid_t start_pre_exec(const char *cmd, int *arg_fd_ptr, int *error_fd_ptr)\n{\n\tint arg_fds[2], error_fds[2], arg_fd;\n\tpid_t pid;\n\n\tif ((error_fd_ptr && pipe(error_fds) < 0) || pipe(arg_fds) < 0 || (pid = fork()) < 0)\n\t\treturn (pid_t)-1;\n\n\tif (pid == 0) {\n\t\tchar buf[BIGPATHBUFLEN];\n\t\tint j, len, status;\n\n\t\tif (error_fd_ptr) {\n\t\t\tclose(error_fds[0]);\n\t\t\tset_blocking(error_fds[1]);\n\t\t}\n\n\t\tclose(arg_fds[1]);\n\t\targ_fd = arg_fds[0];\n\t\tset_blocking(arg_fd);\n\n\t\tlen = read_arg_from_pipe(arg_fd, buf, BIGPATHBUFLEN);\n\t\tif (len <= 0)\n\t\t\t_exit(1);\n\t\tset_env_str(\"RSYNC_REQUEST\", buf);\n\n\t\tfor (j = 0; ; j++) {\n\t\t\tlen = read_arg_from_pipe(arg_fd, buf, BIGPATHBUFLEN);\n\t\t\tif (len <= 0) {\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tset_envN_str(\"RSYNC_ARG\", j, buf);\n\t\t}\n\n\t\tdup2(arg_fd, STDIN_FILENO);\n\t\tclose(arg_fd);\n\n\t\tif (error_fd_ptr) {\n\t\t\tdup2(error_fds[1], STDOUT_FILENO);\n\t\t\tclose(error_fds[1]);\n\t\t}\n\n\t\tstatus = shell_exec(cmd);\n\n\t\tif (!WIFEXITED(status))\n\t\t\t_exit(1);\n\t\t_exit(WEXITSTATUS(status));\n\t}\n\n\tif (error_fd_ptr) {\n\t\tclose(error_fds[1]);\n\t\t*error_fd_ptr = error_fds[0];\n\t\tset_blocking(error_fds[0]);\n\t}\n\n\tclose(arg_fds[0]);\n\targ_fd = *arg_fd_ptr = arg_fds[1];\n\tset_blocking(arg_fd);\n\n\treturn pid;\n}\n\n#endif\n\nstatic void write_pre_exec_args(int write_fd, char *request, char **early_argv, char **argv, int exec_type)\n{\n\tint j = 0;\n\n\tif (!request)\n\t\trequest = \"(NONE)\";\n\n\twrite_buf(write_fd, request, strlen(request)+1);\n\tif (early_argv) {\n\t\tfor ( ; *early_argv; early_argv++)\n\t\t\twrite_buf(write_fd, *early_argv, strlen(*early_argv)+1);\n\t\tj = 1; /* Skip arg0 name in argv. */\n\t}\n\tif (argv) {\n\t\tfor ( ; argv[j]; j++)\n\t\t\twrite_buf(write_fd, argv[j], strlen(argv[j])+1);\n\t}\n\twrite_byte(write_fd, 0);\n\n\tif (exec_type == 1 && early_input_len)\n\t\twrite_buf(write_fd, early_input, early_input_len);\n\n\tif (exec_type != 2) /* the name converter needs this left open */\n\t\tclose(write_fd);\n}\n\nstatic char *finish_pre_exec(const char *desc, pid_t pid, int read_fd)\n{\n\tchar buf[BIGPATHBUFLEN], *bp, *cr;\n\tint j, status = -1, msglen = sizeof buf - 1;\n\n\tif (read_fd >= 0) {\n\t\t/* Read the stdout from the program.  This it is only displayed\n\t\t * to the user if the script also returns an error status. */\n\t\tfor (bp = buf, cr = buf; msglen > 0; msglen -= j) {\n\t\t\tif ((j = read(read_fd, bp, msglen)) <= 0) {\n\t\t\t\tif (j == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak; /* Just ignore the read error for now... */\n\t\t\t}\n\t\t\tbp[j] = '\\0';\n\t\t\twhile (1) {\n\t\t\t\tif ((cr = strchr(cr, '\\r')) == NULL) {\n\t\t\t\t\tcr = bp + j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!cr[1])\n\t\t\t\t\tbreak; /* wait for more data before we decide what to do */\n\t\t\t\tif (cr[1] == '\\n') {\n\t\t\t\t\tmemmove(cr, cr+1, j - (cr - bp));\n\t\t\t\t\tj--;\n\t\t\t\t} else\n\t\t\t\t\tcr++;\n\t\t\t}\n\t\t\tbp += j;\n\t\t}\n\t\t*bp = '\\0';\n\n\t\tclose(read_fd);\n\t} else\n\t\t*buf = '\\0';\n\n\tif (wait_process(pid, &status, 0) < 0\n\t || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n\t\tchar *e;\n\t\tif (asprintf(&e, \"%s returned failure (%d)%s%s%s\\n%s\",\n\t\t\t     desc, status, status < 0 ? \": \" : \"\",\n\t\t\t     status < 0 ? strerror(errno) : \"\",\n\t\t\t     *buf ? \":\" : \"\", buf) < 0)\n\t\t\treturn \"out_of_memory in finish_pre_exec\\n\";\n\t\treturn e;\n\t}\n\treturn NULL;\n}\n\nstatic int path_failure(int f_out, const char *dir, BOOL was_chdir)\n{\n\tif (was_chdir)\n\t\trsyserr(FLOG, errno, \"chdir %s failed\", dir);\n\telse\n\t\trprintf(FLOG, \"normalize_path(%s) failed\\n\", dir);\n\tio_printf(f_out, \"@ERROR: chdir failed\\n\");\n\treturn -1;\n}\n\nstatic int add_a_group(int f_out, const char *gname)\n{\n\tgid_t gid, *gid_p;\n\tif (!group_to_gid(gname, &gid, True)) {\n\t\trprintf(FLOG, \"Invalid gid %s\\n\", gname);\n\t\tio_printf(f_out, \"@ERROR: invalid gid %s\\n\", gname);\n\t\treturn -1;\n\t}\n\tgid_p = EXPAND_ITEM_LIST(&gid_list, gid_t, -32);\n\t*gid_p = gid;\n\treturn 0;\n}\n\n#ifdef HAVE_GETGROUPLIST\nstatic int want_all_groups(int f_out, uid_t uid)\n{\n\tconst char *err;\n\tif ((err = getallgroups(uid, &gid_list)) != NULL) {\n\t\trsyserr(FLOG, errno, \"%s\", err);\n\t\tio_printf(f_out, \"@ERROR: %s\\n\", err);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#elif defined HAVE_INITGROUPS\nstatic struct passwd *want_all_groups(int f_out, uid_t uid)\n{\n\tstruct passwd *pw;\n\tgid_t *gid_p;\n\tif ((pw = getpwuid(uid)) == NULL) {\n\t\trsyserr(FLOG, errno, \"getpwuid failed\");\n\t\tio_printf(f_out, \"@ERROR: getpwuid failed\\n\");\n\t\treturn NULL;\n\t}\n\t/* Start with the default group and initgroups() will add the rest. */\n\tgid_p = EXPAND_ITEM_LIST(&gid_list, gid_t, -32);\n\t*gid_p = pw->pw_gid;\n\treturn pw;\n}\n#endif\n\nstatic int rsync_module(int f_in, int f_out, int i, const char *addr, const char *host)\n{\n\tint argc;\n\tchar **argv, **orig_argv, **orig_early_argv, *module_chdir;\n\tchar line[BIGPATHBUFLEN];\n#if defined HAVE_INITGROUPS && !defined HAVE_GETGROUPLIST\n\tstruct passwd *pw = NULL;\n#endif\n\tuid_t uid;\n\tint set_uid;\n\tchar *p, *err_msg = NULL;\n\tchar *name = lp_name(i);\n\tint use_chroot = lp_use_chroot(i); /* might be 1 (yes), 0 (no), or -1 (unset) */\n\tint ret, pre_exec_arg_fd = -1, pre_exec_error_fd = -1;\n\tint save_munge_symlinks;\n\tpid_t pre_exec_pid = 0;\n\tchar *request = NULL;\n\n\tset_env_str(\"RSYNC_MODULE_NAME\", name);\n\n#ifdef ICONV_OPTION\n\ticonv_opt = lp_charset(i);\n\tif (*iconv_opt)\n\t\tsetup_iconv();\n\ticonv_opt = NULL;\n#endif\n\n\t/* If reverse lookup is disabled globally but enabled for this module,\n\t * we need to do it now before the access check. */\n\tif (host == undetermined_hostname && lp_reverse_lookup(i))\n\t\thost = client_name(client_addr(f_in));\n\tset_env_str(\"RSYNC_HOST_NAME\", host);\n\tset_env_str(\"RSYNC_HOST_ADDR\", addr);\n\n\tif (!allow_access(addr, &host, i)) {\n\t\trprintf(FLOG, \"rsync denied on module %s from %s (%s)\\n\",\n\t\t\tname, host, addr);\n\t\tif (!lp_list(i))\n\t\t\tio_printf(f_out, \"@ERROR: Unknown module '%s'\\n\", name);\n\t\telse {\n\t\t\tio_printf(f_out,\n\t\t\t\t  \"@ERROR: access denied to %s from %s (%s)\\n\",\n\t\t\t\t  name, host, addr);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (am_daemon > 0) {\n\t\trprintf(FLOG, \"rsync allowed access on module %s from %s (%s)\\n\",\n\t\t\tname, host, addr);\n\t}\n\n\tif (!claim_connection(lp_lock_file(i), lp_max_connections(i))) {\n\t\tif (errno) {\n\t\t\trsyserr(FLOG, errno, \"failed to open lock file %s\",\n\t\t\t\tlp_lock_file(i));\n\t\t\tio_printf(f_out, \"@ERROR: failed to open lock file\\n\");\n\t\t} else {\n\t\t\trprintf(FLOG, \"max connections (%d) reached\\n\",\n\t\t\t\tlp_max_connections(i));\n\t\t\tio_printf(f_out, \"@ERROR: max connections (%d) reached -- try again later\\n\",\n\t\t\t\tlp_max_connections(i));\n\t\t}\n\t\treturn -1;\n\t}\n\n\tread_only = lp_read_only(i); /* may also be overridden by auth_server() */\n\tauth_user = auth_server(f_in, f_out, i, host, addr, \"@RSYNCD: AUTHREQD \");\n\n\tif (!auth_user) {\n\t\tio_printf(f_out, \"@ERROR: auth failed on module %s\\n\", name);\n\t\treturn -1;\n\t}\n\tset_env_str(\"RSYNC_USER_NAME\", auth_user);\n\n\tmodule_id = i;\n\n\tif (lp_transfer_logging(module_id) && !logfile_format)\n\t\tlogfile_format = lp_log_format(module_id);\n\tif (log_format_has(logfile_format, 'i'))\n\t\tlogfile_format_has_i = 1;\n\tif (logfile_format_has_i || log_format_has(logfile_format, 'o'))\n\t\tlogfile_format_has_o_or_i = 1;\n\n\tuid = MY_UID();\n\tam_root = (uid == ROOT_UID);\n\n\tp = *lp_uid(module_id) ? lp_uid(module_id) : am_root ? NOBODY_USER : NULL;\n\tif (p) {\n\t\tif (!user_to_uid(p, &uid, True)) {\n\t\t\trprintf(FLOG, \"Invalid uid %s\\n\", p);\n\t\t\tio_printf(f_out, \"@ERROR: invalid uid %s\\n\", p);\n\t\t\treturn -1;\n\t\t}\n\t\tset_uid = 1;\n\t} else\n\t\tset_uid = 0;\n\n\tp = *lp_gid(module_id) ? conf_strtok(lp_gid(module_id)) : NULL;\n\tif (p) {\n\t\t/* The \"*\" gid must be the first item in the list. */\n\t\tif (strcmp(p, \"*\") == 0) {\n#ifdef HAVE_GETGROUPLIST\n\t\t\tif (want_all_groups(f_out, uid) < 0)\n\t\t\t\treturn -1;\n#elif defined HAVE_INITGROUPS\n\t\t\tif ((pw = want_all_groups(f_out, uid)) == NULL)\n\t\t\t\treturn -1;\n#else\n\t\t\trprintf(FLOG, \"This rsync does not support a gid of \\\"*\\\"\\n\");\n\t\t\tio_printf(f_out, \"@ERROR: invalid gid setting.\\n\");\n\t\t\treturn -1;\n#endif\n\t\t} else if (add_a_group(f_out, p) < 0)\n\t\t\treturn -1;\n\t\twhile ((p = conf_strtok(NULL)) != NULL) {\n#if defined HAVE_INITGROUPS && !defined HAVE_GETGROUPLIST\n\t\t\tif (pw) {\n\t\t\t\trprintf(FLOG, \"This rsync cannot add groups after \\\"*\\\".\\n\");\n\t\t\t\tio_printf(f_out, \"@ERROR: invalid gid setting.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n#endif\n\t\t\tif (add_a_group(f_out, p) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t} else if (am_root) {\n\t\tif (add_a_group(f_out, NOBODY_GROUP) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmodule_dir = lp_path(module_id);\n\tif (*module_dir == '\\0') {\n\t\trprintf(FLOG, \"No path specified for module %s\\n\", name);\n\t\tio_printf(f_out, \"@ERROR: no path setting.\\n\");\n\t\treturn -1;\n\t}\n\tif (use_chroot < 0) {\n\t\tif (strstr(module_dir, \"/./\") != NULL)\n\t\t\tuse_chroot = 1; /* The module is expecting a chroot inner & outer path. */\n\t\telse if (chroot(\"/\") < 0) {\n\t\t\trprintf(FLOG, \"chroot test failed: %s. \"\n\t\t\t\t      \"Switching 'use chroot' from unset to false.\\n\",\n\t\t\t\t      strerror(errno));\n\t\t\tuse_chroot = 0;\n\t\t} else {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t    rsyserr(FLOG, errno, \"chdir(\\\"/\\\") failed\");\n\t\t\tuse_chroot = 1;\n\t\t}\n\t}\n\tif (use_chroot) {\n\t\tif ((p = strstr(module_dir, \"/./\")) != NULL) {\n\t\t\t*p = '\\0'; /* Temporary... */\n\t\t\tif (!(module_chdir = normalize_path(module_dir, True, NULL)))\n\t\t\t\treturn path_failure(f_out, module_dir, False);\n\t\t\t*p = '/';\n\t\t\tif (!(p = normalize_path(p + 2, True, &module_dirlen)))\n\t\t\t\treturn path_failure(f_out, strstr(module_dir, \"/./\"), False);\n\t\t\tif (!(full_module_path = normalize_path(module_dir, False, NULL)))\n\t\t\t\tfull_module_path = module_dir;\n\t\t\tmodule_dir = p;\n\t\t} else {\n\t\t\tif (!(module_chdir = normalize_path(module_dir, False, NULL)))\n\t\t\t\treturn path_failure(f_out, module_dir, False);\n\t\t\tfull_module_path = module_chdir;\n\t\t\tmodule_dir = \"/\";\n\t\t\tmodule_dirlen = 1;\n\t\t}\n\t} else {\n\t\tif (!(module_chdir = normalize_path(module_dir, False, &module_dirlen)))\n\t\t\treturn path_failure(f_out, module_dir, False);\n\t\tfull_module_path = module_dir = module_chdir;\n\t}\n\tset_env_str(\"RSYNC_MODULE_PATH\", full_module_path);\n\n\tif (module_dirlen == 1) {\n\t\tmodule_dirlen = 0;\n\t\tset_filter_dir(\"/\", 1);\n\t} else\n\t\tset_filter_dir(module_dir, module_dirlen);\n\n\tp = lp_filter(module_id);\n\tparse_filter_str(&daemon_filter_list, p, rule_template(FILTRULE_WORD_SPLIT),\n\t\tXFLG_ABS_IF_SLASH | XFLG_DIR2WILD3);\n\n\tp = lp_include_from(module_id);\n\tparse_filter_file(&daemon_filter_list, p, rule_template(FILTRULE_INCLUDE),\n\t\tXFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);\n\n\tp = lp_include(module_id);\n\tparse_filter_str(&daemon_filter_list, p,\n\t\trule_template(FILTRULE_INCLUDE | FILTRULE_WORD_SPLIT),\n\t\tXFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES);\n\n\tp = lp_exclude_from(module_id);\n\tparse_filter_file(&daemon_filter_list, p, rule_template(0),\n\t\tXFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);\n\n\tp = lp_exclude(module_id);\n\tparse_filter_str(&daemon_filter_list, p, rule_template(FILTRULE_WORD_SPLIT),\n\t\tXFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES);\n\n\tlog_init(1);\n\n#if defined HAVE_SETENV || defined HAVE_PUTENV\n\tif ((*lp_early_exec(module_id) || *lp_prexfer_exec(module_id)\n\t  || *lp_postxfer_exec(module_id) || *lp_name_converter(module_id))\n\t && !getenv(\"RSYNC_NO_XFER_EXEC\")) {\n\t\tset_env_num(\"RSYNC_PID\", (long)getpid());\n\n\t\t/* For post-xfer exec, fork a new process to run the rsync\n\t\t * daemon while this process waits for the exit status and\n\t\t * runs the indicated command at that point. */\n\t\tif (*lp_postxfer_exec(module_id)) {\n\t\t\tpid_t pid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\trsyserr(FLOG, errno, \"fork failed\");\n\t\t\t\tio_printf(f_out, \"@ERROR: fork failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (pid) {\n\t\t\t\tint status;\n\t\t\t\tclose(f_in);\n\t\t\t\tif (f_out != f_in)\n\t\t\t\t\tclose(f_out);\n\t\t\t\tif (wait_process(pid, &status, 0) < 0)\n\t\t\t\t\tstatus = -1;\n\t\t\t\tset_env_num(\"RSYNC_RAW_STATUS\", status);\n\t\t\t\tif (WIFEXITED(status))\n\t\t\t\t\tstatus = WEXITSTATUS(status);\n\t\t\t\telse\n\t\t\t\t\tstatus = -1;\n\t\t\t\tset_env_num(\"RSYNC_EXIT_STATUS\", status);\n\t\t\t\tif (shell_exec(lp_postxfer_exec(module_id)) < 0)\n\t\t\t\t\tstatus = -1;\n\t\t\t\t_exit(status);\n\t\t\t}\n\t\t}\n\n\t\t/* For early exec, fork a child process to run the indicated\n\t\t * command and wait for it to exit. */\n\t\tif (*lp_early_exec(module_id)) {\n\t\t\tint arg_fd;\n\t\t\tpid_t pid = start_pre_exec(lp_early_exec(module_id), &arg_fd, NULL);\n\t\t\tif (pid == (pid_t)-1) {\n\t\t\t\trsyserr(FLOG, errno, \"early exec preparation failed\");\n\t\t\t\tio_printf(f_out, \"@ERROR: early exec preparation failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twrite_pre_exec_args(arg_fd, NULL, NULL, NULL, 1);\n\t\t\tif (finish_pre_exec(\"early exec\", pid, -1) != NULL) {\n\t\t\t\trsyserr(FLOG, errno, \"early exec failed\");\n\t\t\t\tio_printf(f_out, \"@ERROR: early exec failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* For pre-xfer exec, fork a child process to run the indicated\n\t\t * command, though it first waits for the parent process to\n\t\t * send us the user's request via a pipe. */\n\t\tif (*lp_prexfer_exec(module_id)) {\n\t\t\tpre_exec_pid = start_pre_exec(lp_prexfer_exec(module_id), &pre_exec_arg_fd, &pre_exec_error_fd);\n\t\t\tif (pre_exec_pid == (pid_t)-1) {\n\t\t\t\trsyserr(FLOG, errno, \"pre-xfer exec preparation failed\");\n\t\t\t\tio_printf(f_out, \"@ERROR: pre-xfer exec preparation failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (*lp_name_converter(module_id)) {\n\t\t\tnamecvt_pid = start_pre_exec(lp_name_converter(module_id), &namecvt_fd_req, &namecvt_fd_ans);\n\t\t\tif (namecvt_pid == (pid_t)-1) {\n\t\t\t\trsyserr(FLOG, errno, \"name-converter exec preparation failed\");\n\t\t\t\tio_printf(f_out, \"@ERROR: name-converter exec preparation failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (early_input) {\n\t\tfree(early_input);\n\t\tearly_input = NULL;\n\t}\n\n\tif (use_chroot) {\n\t\tif (chroot(module_chdir)) {\n\t\t\trsyserr(FLOG, errno, \"chroot(\\\"%s\\\") failed\", module_chdir);\n\t\t\tio_printf(f_out, \"@ERROR: chroot failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmodule_chdir = module_dir;\n\t}\n\n\tif (!change_dir(module_chdir, CD_NORMAL))\n\t\treturn path_failure(f_out, module_chdir, True);\n\tif (module_dirlen)\n\t\tsanitize_paths = 1;\n\n\tif ((munge_symlinks = lp_munge_symlinks(module_id)) < 0)\n\t\tmunge_symlinks = !use_chroot || module_dirlen;\n\tif (munge_symlinks) {\n\t\tSTRUCT_STAT st;\n\t\tchar prefix[SYMLINK_PREFIX_LEN]; /* NOT +1 ! */\n\t\tstrlcpy(prefix, SYMLINK_PREFIX, sizeof prefix); /* trim the trailing slash */\n\t\tif (do_stat(prefix, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\t\trprintf(FLOG, \"Symlink munging is unsafe when a %s directory exists.\\n\",\n\t\t\t\tprefix);\n\t\t\tio_printf(f_out, \"@ERROR: daemon security issue -- contact admin\\n\", name);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t}\n\n\tif (gid_list.count) {\n\t\tgid_t *gid_array = gid_list.items;\n\t\tif (setgid(gid_array[0])) {\n\t\t\trsyserr(FLOG, errno, \"setgid %ld failed\", (long)gid_array[0]);\n\t\t\tio_printf(f_out, \"@ERROR: setgid failed\\n\");\n\t\t\treturn -1;\n\t\t}\n#ifdef HAVE_SETGROUPS\n\t\t/* Set the group(s) we want to be active. */\n\t\tif (setgroups(gid_list.count, gid_array)) {\n\t\t\trsyserr(FLOG, errno, \"setgroups failed\");\n\t\t\tio_printf(f_out, \"@ERROR: setgroups failed\\n\");\n\t\t\treturn -1;\n\t\t}\n#endif\n#if defined HAVE_INITGROUPS && !defined HAVE_GETGROUPLIST\n\t\t/* pw is set if the user wants all the user's groups. */\n\t\tif (pw && initgroups(pw->pw_name, pw->pw_gid) < 0) {\n\t\t\trsyserr(FLOG, errno, \"initgroups failed\");\n\t\t\tio_printf(f_out, \"@ERROR: initgroups failed\\n\");\n\t\t\treturn -1;\n\t\t}\n#endif\n\t\tour_gid = MY_GID();\n\t}\n\n\tif (set_uid) {\n\t\tif (setuid(uid) < 0\n#ifdef HAVE_SETEUID\n\t\t || seteuid(uid) < 0\n#endif\n\t\t) {\n\t\t\trsyserr(FLOG, errno, \"setuid %ld failed\", (long)uid);\n\t\t\tio_printf(f_out, \"@ERROR: setuid failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tour_uid = MY_UID();\n\t\tam_root = (our_uid == ROOT_UID);\n\t}\n\n\tif (lp_temp_dir(module_id) && *lp_temp_dir(module_id)) {\n\t\ttmpdir = lp_temp_dir(module_id);\n\t\tif (strlen(tmpdir) >= MAXPATHLEN - 10) {\n\t\t\trprintf(FLOG,\n\t\t\t\t\"the 'temp dir' value for %s is WAY too long -- ignoring.\\n\",\n\t\t\t\tname);\n\t\t\ttmpdir = NULL;\n\t\t}\n\t}\n\n\tio_printf(f_out, \"@RSYNCD: OK\\n\");\n\n\tread_args(f_in, name, line, sizeof line, rl_nulls, &argv, &argc, &request);\n\torig_argv = argv;\n\n\tsave_munge_symlinks = munge_symlinks;\n\n\treset_output_levels(); /* future verbosity is controlled by client options */\n\tret = parse_arguments(&argc, (const char ***) &argv);\n\tif (protect_args && ret) {\n\t\torig_early_argv = orig_argv;\n\t\tprotect_args = 2;\n\t\tread_args(f_in, name, line, sizeof line, 1, &argv, &argc, &request);\n\t\torig_argv = argv;\n\t\tret = parse_arguments(&argc, (const char ***) &argv);\n\t} else\n\t\torig_early_argv = NULL;\n\n\t/* The default is to use the user's setting unless the module sets True or False. */\n\tif (lp_open_noatime(module_id) >= 0)\n\t\topen_noatime = lp_open_noatime(module_id);\n\n\tmunge_symlinks = save_munge_symlinks; /* The client mustn't control this. */\n\n\tif (am_daemon > 0)\n\t\tmsgs2stderr = 0; /* A non-rsh-run daemon doesn't have stderr for msgs. */\n\n\tif (pre_exec_pid) {\n\t\twrite_pre_exec_args(pre_exec_arg_fd, request, orig_early_argv, orig_argv, 0);\n\t\terr_msg = finish_pre_exec(\"pre-xfer exec\", pre_exec_pid, pre_exec_error_fd);\n\t}\n\n\tif (namecvt_pid)\n\t\twrite_pre_exec_args(namecvt_fd_req, request, orig_early_argv, orig_argv, 2);\n\n\tif (orig_early_argv)\n\t\tfree(orig_early_argv);\n\n\tam_server = 1; /* Don't let someone try to be tricky. */\n\tquiet = 0;\n\tif (lp_ignore_errors(module_id))\n\t\tignore_errors = 1;\n\tif (write_batch < 0)\n\t\tdry_run = 1;\n\n\tif (lp_fake_super(module_id)) {\n\t\tif (preserve_xattrs > 1)\n\t\t\tpreserve_xattrs = 1;\n\t\tam_root = -1;\n\t} else if (am_root < 0) /* Treat --fake-super from client as --super. */\n\t\tam_root = 2;\n\n\tif (filesfrom_fd == 0)\n\t\tfilesfrom_fd = f_in;\n\n\tif (request) {\n\t\tif (*auth_user) {\n\t\t\trprintf(FLOG, \"rsync %s %s from %s@%s (%s)\\n\",\n\t\t\t\tam_sender ? \"on\" : \"to\",\n\t\t\t\trequest, auth_user, host, addr);\n\t\t} else {\n\t\t\trprintf(FLOG, \"rsync %s %s from %s (%s)\\n\",\n\t\t\t\tam_sender ? \"on\" : \"to\",\n\t\t\t\trequest, host, addr);\n\t\t}\n\t\tfree(request);\n\t}\n\n#ifndef DEBUG\n\t/* don't allow the logs to be flooded too fast */\n\tlimit_output_verbosity(lp_max_verbosity(module_id));\n#endif\n\n\tif (protocol_version < 23 && (protocol_version == 22 || am_sender))\n\t\tio_start_multiplex_out(f_out);\n\telse if (!ret || err_msg) {\n\t\t/* We have to get I/O multiplexing started so that we can\n\t\t * get the error back to the client.  This means getting\n\t\t * the protocol setup finished first in later versions. */\n\t\tsetup_protocol(f_out, f_in);\n\t\tif (!am_sender) {\n\t\t\t/* Since we failed in our option parsing, we may not\n\t\t\t * have finished parsing that the client sent us a\n\t\t\t * --files-from option, so look for it manually.\n\t\t\t * Without this, the socket would be in the wrong\n\t\t\t * state for the upcoming error message. */\n\t\t\tif (!files_from) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < argc; i++) {\n\t\t\t\t\tif (strncmp(argv[i], \"--files-from\", 12) == 0) {\n\t\t\t\t\t\tfiles_from = \"\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (files_from)\n\t\t\t\twrite_byte(f_out, 0);\n\t\t}\n\t\tio_start_multiplex_out(f_out);\n\t}\n\n\tif (!ret || err_msg) {\n\t\tif (err_msg) {\n\t\t\twhile ((p = strchr(err_msg, '\\n')) != NULL) {\n\t\t\t\tint len = p - err_msg + 1;\n\t\t\t\trwrite(FERROR, err_msg, len, 0);\n\t\t\t\terr_msg += len;\n\t\t\t}\n\t\t\tif (*err_msg)\n\t\t\t\trprintf(FERROR, \"%s\\n\", err_msg);\n\t\t\tio_flush(MSG_FLUSH);\n\t\t} else\n\t\t\toption_error();\n\t\tmsleep(400);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n#ifdef ICONV_OPTION\n\tif (!iconv_opt) {\n\t\tif (ic_send != (iconv_t)-1) {\n\t\t\ticonv_close(ic_send);\n\t\t\tic_send = (iconv_t)-1;\n\t\t}\n\t\tif (ic_recv != (iconv_t)-1) {\n\t\t\ticonv_close(ic_recv);\n\t\t\tic_recv = (iconv_t)-1;\n\t\t}\n\t}\n#endif\n\n\tif (!numeric_ids\n\t && (use_chroot ? lp_numeric_ids(module_id) != False && !*lp_name_converter(module_id)\n\t\t        : lp_numeric_ids(module_id) == True))\n\t\tnumeric_ids = -1; /* Set --numeric-ids w/o breaking protocol. */\n\n\tif (lp_timeout(module_id) && (!io_timeout || lp_timeout(module_id) < io_timeout))\n\t\tset_io_timeout(lp_timeout(module_id));\n\n\t/* If we have some incoming/outgoing chmod changes, append them to\n\t * any user-specified changes (making our changes have priority).\n\t * We also get a pointer to just our changes so that a receiver\n\t * process can use them separately if --perms wasn't specified. */\n\tif (am_sender)\n\t\tp = lp_outgoing_chmod(module_id);\n\telse\n\t\tp = lp_incoming_chmod(module_id);\n\tif (*p && !(daemon_chmod_modes = parse_chmod(p, &chmod_modes))) {\n\t\trprintf(FLOG, \"Invalid \\\"%sing chmod\\\" directive: %s\\n\",\n\t\t\tam_sender ? \"outgo\" : \"incom\", p);\n\t}\n\n\tstart_server(f_in, f_out, argc, argv);\n\n\treturn 0;\n}\n\nBOOL namecvt_call(const char *cmd, const char **name_p, id_t *id_p)\n{\n\tchar buf[1024];\n\tint got, len;\n\n\tif (*name_p)\n\t\tlen = snprintf(buf, sizeof buf, \"%s %s\\n\", cmd, *name_p);\n\telse\n\t\tlen = snprintf(buf, sizeof buf, \"%s %ld\\n\", cmd, (long)*id_p);\n\tif (len >= (int)sizeof buf) {\n\t\trprintf(FERROR, \"namecvt_call() request was too large.\\n\");\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\twhile ((got = write(namecvt_fd_req, buf, len)) != len) {\n\t\tif (got < 0 && errno == EINTR)\n\t\t\tcontinue;\n\t\trprintf(FERROR, \"Connection to name-converter failed.\\n\");\n\t\texit_cleanup(RERR_SOCKETIO);\n\t}\n\n\tif (!read_line_old(namecvt_fd_ans, buf, sizeof buf, 0))\n\t\treturn False;\n\n\tif (*name_p)\n\t\t*id_p = (id_t)atol(buf);\n\telse\n\t\t*name_p = strdup(buf);\n\n\treturn True;\n}\n\n/* send a list of available modules to the client. Don't list those\n   with \"list = False\". */\nstatic void send_listing(int fd)\n{\n\tint n = lp_num_modules();\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (lp_list(i))\n\t\t\tio_printf(fd, \"%-15s\\t%s\\n\", lp_name(i), lp_comment(i));\n\t}\n\n\tif (protocol_version >= 25)\n\t\tio_printf(fd,\"@RSYNCD: EXIT\\n\");\n}\n\nstatic int load_config(int globals_only)\n{\n\tif (!config_file) {\n\t\tif (am_daemon < 0 && am_root <= 0)\n\t\t\tconfig_file = RSYNCD_USERCONF;\n\t\telse\n\t\t\tconfig_file = RSYNCD_SYSCONF;\n\t}\n\treturn lp_load(config_file, globals_only);\n}\n\n/* this is called when a connection is established to a client\n   and we want to start talking. The setup of the system is done from\n   here */\nint start_daemon(int f_in, int f_out)\n{\n\tchar line[1024];\n\tconst char *addr, *host;\n\tchar *p;\n\tint i;\n\n\t/* At this point, am_server is only set for a daemon started via rsh.\n\t * Because am_server gets forced on soon, we'll set am_daemon to -1 as\n\t * a flag that can be checked later on to distinguish a normal daemon\n\t * from an rsh-run daemon. */\n\tif (am_server)\n\t\tam_daemon = -1;\n\n\tio_set_sock_fds(f_in, f_out);\n\n\t/* We must load the config file before calling any function that\n\t * might cause log-file output to occur.  This ensures that the\n\t * \"log file\" param gets honored for the 2 non-forked use-cases\n\t * (when rsync is run by init and run by a remote shell). */\n\tif (!load_config(0))\n\t\texit_cleanup(RERR_SYNTAX);\n\n\tif (lp_proxy_protocol() && !read_proxy_protocol_header(f_in))\n\t\treturn -1;\n\n\tp = lp_daemon_chroot();\n\tif (*p) {\n\t\tlog_init(0); /* Make use we've initialized syslog before chrooting. */\n\t\tif (chroot(p) < 0) {\n\t\t\trsyserr(FLOG, errno, \"daemon chroot(\\\"%s\\\") failed\", p);\n\t\t\treturn -1;\n\t\t}\n\t\tif (chdir(\"/\") < 0) {\n\t\t\trsyserr(FLOG, errno, \"daemon chdir(\\\"/\\\") failed\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tp = lp_daemon_gid();\n\tif (*p) {\n\t\tgid_t gid;\n\t\tif (!group_to_gid(p, &gid, True)) {\n\t\t\trprintf(FLOG, \"Invalid daemon gid: %s\\n\", p);\n\t\t\treturn -1;\n\t\t}\n\t\tif (setgid(gid) < 0) {\n\t\t\trsyserr(FLOG, errno, \"Unable to set group to daemon gid %ld\", (long)gid);\n\t\t\treturn -1;\n\t\t}\n\t\tour_gid = MY_GID();\n\t}\n\tp = lp_daemon_uid();\n\tif (*p) {\n\t\tuid_t uid;\n\t\tif (!user_to_uid(p, &uid, True)) {\n\t\t\trprintf(FLOG, \"Invalid daemon uid: %s\\n\", p);\n\t\t\treturn -1;\n\t\t}\n\t\tif (setuid(uid) < 0) {\n\t\t\trsyserr(FLOG, errno, \"Unable to set user to daemon uid %ld\", (long)uid);\n\t\t\treturn -1;\n\t\t}\n\t\tour_uid = MY_UID();\n\t\tam_root = (our_uid == ROOT_UID);\n\t}\n\n\taddr = client_addr(f_in);\n\thost = lp_reverse_lookup(-1) ? client_name(addr) : undetermined_hostname;\n\trprintf(FLOG, \"connect from %s (%s)\\n\", host, addr);\n\n\tif (am_daemon > 0) {\n\t\tset_socket_options(f_in, \"SO_KEEPALIVE\");\n\t\tset_nonblocking(f_in);\n\t}\n\n\tif (exchange_protocols(f_in, f_out, line, sizeof line, 0) < 0)\n\t\treturn -1;\n\n\tline[0] = 0;\n\tif (!read_line_old(f_in, line, sizeof line, 0))\n\t\treturn -1;\n\n\tif (strncmp(line, EARLY_INPUT_CMD, EARLY_INPUT_CMDLEN) == 0) {\n\t\tearly_input_len = strtol(line + EARLY_INPUT_CMDLEN, NULL, 10);\n\t\tif (early_input_len <= 0 || early_input_len > BIGPATHBUFLEN) {\n\t\t\tio_printf(f_out, \"@ERROR: invalid early_input length\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tearly_input = new_array(char, early_input_len);\n\t\tread_buf(f_in, early_input, early_input_len);\n\n\t\tif (!read_line_old(f_in, line, sizeof line, 0))\n\t\t\treturn -1;\n\t}\n\n\tif (!*line || strcmp(line, \"#list\") == 0) {\n\t\trprintf(FLOG, \"module-list request from %s (%s)\\n\",\n\t\t\thost, addr);\n\t\tsend_listing(f_out);\n\t\treturn -1;\n\t}\n\n\tif (*line == '#') {\n\t\t/* it's some sort of command that I don't understand */\n\t\tio_printf(f_out, \"@ERROR: Unknown command '%s'\\n\", line);\n\t\treturn -1;\n\t}\n\n\tif ((i = lp_number(line)) < 0) {\n\t\trprintf(FLOG, \"unknown module '%s' tried from %s (%s)\\n\",\n\t\t\tline, host, addr);\n\t\tio_printf(f_out, \"@ERROR: Unknown module '%s'\\n\", line);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_SIGACTION\n\tsigact.sa_flags = SA_NOCLDSTOP;\n#endif\n\tSIGACTION(SIGCHLD, remember_children);\n\n\treturn rsync_module(f_in, f_out, i, addr, host);\n}\n\nstatic void create_pid_file(void)\n{\n\tchar *pid_file = lp_pid_file();\n\tchar pidbuf[32];\n\tSTRUCT_STAT st1, st2;\n\tchar *fail = NULL;\n\n\tif (!pid_file || !*pid_file)\n\t\treturn;\n\n#ifdef O_NOFOLLOW\n#define SAFE_OPEN_FLAGS (O_CREAT|O_NOFOLLOW)\n#else\n#define SAFE_OPEN_FLAGS (O_CREAT)\n#endif\n\n\t/* These tests make sure that a temp-style lock dir is handled safely. */\n\tst1.st_mode = 0;\n\tif (do_lstat(pid_file, &st1) == 0 && !S_ISREG(st1.st_mode) && unlink(pid_file) < 0)\n\t\tfail = \"unlink\";\n\telse if ((pid_file_fd = do_open(pid_file, O_RDWR|SAFE_OPEN_FLAGS, 0664)) < 0)\n\t\tfail = S_ISREG(st1.st_mode) ? \"open\" : \"create\";\n\telse if (!lock_range(pid_file_fd, 0, 4))\n\t\tfail = \"lock\";\n\telse if (do_fstat(pid_file_fd, &st1) < 0)\n\t\tfail = \"fstat opened\";\n\telse if (st1.st_size > (int)sizeof pidbuf)\n\t\tfail = \"find small\";\n\telse if (do_lstat(pid_file, &st2) < 0)\n\t\tfail = \"lstat\";\n\telse if (!S_ISREG(st1.st_mode))\n\t\tfail = \"avoid file overwrite race for\";\n\telse if (st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino)\n\t\tfail = \"verify stat info for\";\n#ifdef HAVE_FTRUNCATE\n\telse if (do_ftruncate(pid_file_fd, 0) < 0)\n\t\tfail = \"truncate\";\n#endif\n\telse {\n\t\tpid_t pid = getpid();\n\t\tint len = snprintf(pidbuf, sizeof pidbuf, \"%d\\n\", (int)pid);\n#ifndef HAVE_FTRUNCATE\n\t\t/* What can we do with a too-long file and no truncate? I guess we'll add extra newlines. */\n\t\twhile (len < st1.st_size) /* We already verified that st_size chars fits in the buffer. */\n\t\t\tpidbuf[len++] = '\\n';\n\t\t/* We don't need the buffer to end in a '\\0' (and we may not have room to add it). */\n#endif\n\t\tif (write(pid_file_fd, pidbuf, len) != len)\n\t\t\t fail = \"write\";\n\t\tcleanup_set_pid(pid); /* Mark the file for removal on exit, even if the write failed. */\n\t}\n\n\tif (fail) {\n\t\tchar msg[1024];\n\t\tsnprintf(msg, sizeof msg, \"failed to %s pid file %s: %s\\n\",\n\t\t\tfail, pid_file, strerror(errno));\n\t\tfputs(msg, stderr);\n\t\trprintf(FLOG, \"%s\", msg);\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n\n\t/* The file is left open so that the lock remains valid. It is closed in our forked child procs. */\n}\n\n/* Become a daemon, discarding the controlling terminal. */\nstatic void become_daemon(void)\n{\n\tint i;\n\tpid_t pid = fork();\n\n\tif (pid) {\n\t\tif (pid < 0) {\n\t\t\tfprintf(stderr, \"failed to fork: %s\\n\", strerror(errno));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t\t_exit(0);\n\t}\n\n\tcreate_pid_file();\n\n\t/* detach from the terminal */\n#ifdef HAVE_SETSID\n\tsetsid();\n#elif defined TIOCNOTTY\n\ti = open(\"/dev/tty\", O_RDWR);\n\tif (i >= 0) {\n\t\tioctl(i, (int)TIOCNOTTY, (char *)0);\n\t\tclose(i);\n\t}\n#endif\n\t/* make sure that stdin, stdout an stderr don't stuff things\n\t * up (library functions, for example) */\n\tfor (i = 0; i < 3; i++) {\n\t\tclose(i);\n\t\topen(\"/dev/null\", O_RDWR);\n\t}\n}\n\nint daemon_main(void)\n{\n\tif (is_a_socket(STDIN_FILENO)) {\n\t\tint i;\n\n\t\t/* we are running via inetd - close off stdout and\n\t\t * stderr so that library functions (and getopt) don't\n\t\t * try to use them. Redirect them to /dev/null */\n\t\tfor (i = 1; i < 3; i++) {\n\t\t\tclose(i);\n\t\t\topen(\"/dev/null\", O_RDWR);\n\t\t}\n\n\t\treturn start_daemon(STDIN_FILENO, STDIN_FILENO);\n\t}\n\n\tif (!load_config(1)) {\n\t\tfprintf(stderr, \"Failed to parse config file: %s\\n\", config_file);\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\tset_dparams(0);\n\n\tif (no_detach)\n\t\tcreate_pid_file();\n\telse\n\t\tbecome_daemon();\n\n\tif (rsync_port == 0 && (rsync_port = lp_rsync_port()) == 0)\n\t\trsync_port = RSYNC_PORT;\n\tif (bind_address == NULL && *lp_bind_address())\n\t\tbind_address = lp_bind_address();\n\n\tlog_init(0);\n\n\trprintf(FLOG, \"rsyncd version %s starting, listening on port %d\\n\",\n\t\trsync_version(), rsync_port);\n\t/* TODO: If listening on a particular address, then show that\n\t * address too.  In fact, why not just do getnameinfo on the\n\t * local address??? */\n\n\tstart_accept_loop(rsync_port, start_daemon);\n\treturn -1;\n}\n"
        },
        {
          "name": "cmd-or-msg",
          "type": "blob",
          "size": 0.162109375,
          "content": "#!/bin/sh\n\nsrcdir=`dirname $0`\nopt=\"$1\"\nshift\n\necho \"$*\"\nif ! \"${@}\"; then\n    echo \"If you can't fix the issue, re-run $srcdir/configure with --$opt.\"\n    exit 1\nfi\n"
        },
        {
          "name": "compat.c",
          "type": "blob",
          "size": 25.5546875,
          "content": "/*\n * Compatibility routines for older rsync protocol versions.\n *\n * Copyright (C) Andrew Tridgell 1996\n * Copyright (C) Paul Mackerras 1996\n * Copyright (C) 2004-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"ifuncs.h\"\n\nextern int am_server;\nextern int am_sender;\nextern int local_server;\nextern int inplace;\nextern int recurse;\nextern int use_qsort;\nextern int allow_inc_recurse;\nextern int preallocate_files;\nextern int append_mode;\nextern int fuzzy_basis;\nextern int read_batch;\nextern int write_batch;\nextern int delay_updates;\nextern int checksum_seed;\nextern int basis_dir_cnt;\nextern int prune_empty_dirs;\nextern int protocol_version;\nextern int protect_args;\nextern int preserve_uid;\nextern int preserve_gid;\nextern int preserve_atimes;\nextern int preserve_crtimes;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int xfer_flags_as_varint;\nextern int need_messages_from_generator;\nextern int delete_mode, delete_before, delete_during, delete_after;\nextern int do_compression;\nextern int do_compression_level;\nextern int saw_stderr_opt;\nextern int msgs2stderr;\nextern char *shell_cmd;\nextern char *partial_dir;\nextern char *files_from;\nextern char *filesfrom_host;\nextern const char *checksum_choice;\nextern const char *compress_choice;\nextern char *daemon_auth_choices;\nextern filter_rule_list filter_list;\nextern int need_unsorted_flist;\n#ifdef ICONV_OPTION\nextern iconv_t ic_send, ic_recv;\nextern char *iconv_opt;\n#endif\nextern struct name_num_obj valid_checksums, valid_auth_checksums;\n\nextern struct name_num_item *xfer_sum_nni;\n\nint remote_protocol = 0;\nint file_extra_cnt = 0; /* count of file-list extras that everyone gets */\nint inc_recurse = 0;\nint compat_flags = 0;\nint use_safe_inc_flist = 0;\nint want_xattr_optim = 0;\nint proper_seed_order = 0;\nint inplace_partial = 0;\nint do_negotiated_strings = 0;\nint xmit_id0_names = 0;\n\nstruct name_num_item *xattr_sum_nni;\nint xattr_sum_len = 0;\n\n/* These index values are for the file-list's extra-attribute array. */\nint pathname_ndx, depth_ndx, atimes_ndx, crtimes_ndx, uid_ndx, gid_ndx, acls_ndx, xattrs_ndx, unsort_ndx;\n\nint receiver_symlink_times = 0; /* receiver can set the time on a symlink */\nint sender_symlink_iconv = 0;\t/* sender should convert symlink content */\n\n#ifdef ICONV_OPTION\nint filesfrom_convert = 0;\n#endif\n\n#define MAX_NSTR_STRLEN 256\n\nstruct name_num_item valid_compressions_items[] = {\n#ifdef SUPPORT_ZSTD\n\t{ CPRES_ZSTD, 0, \"zstd\", NULL },\n#endif\n#ifdef SUPPORT_LZ4\n\t{ CPRES_LZ4, 0, \"lz4\", NULL },\n#endif\n\t{ CPRES_ZLIBX, 0, \"zlibx\", NULL },\n\t{ CPRES_ZLIB, 0, \"zlib\", NULL },\n\t{ CPRES_NONE, 0, \"none\", NULL },\n\t{ 0, 0, NULL, NULL }\n};\n\nstruct name_num_obj valid_compressions = {\n\t\"compress\", NULL, 0, 0, valid_compressions_items\n};\n\n#define CF_INC_RECURSE\t (1<<0)\n#define CF_SYMLINK_TIMES (1<<1)\n#define CF_SYMLINK_ICONV (1<<2)\n#define CF_SAFE_FLIST\t (1<<3)\n#define CF_AVOID_XATTR_OPTIM (1<<4)\n#define CF_CHKSUM_SEED_FIX (1<<5)\n#define CF_INPLACE_PARTIAL_DIR (1<<6)\n#define CF_VARINT_FLIST_FLAGS (1<<7)\n#define CF_ID0_NAMES (1<<8)\n\nstatic const char *client_info;\n\n/* The server makes sure that if either side only supports a pre-release\n * version of a protocol, that both sides must speak a compatible version\n * of that protocol for it to be advertised as available. */\nstatic void check_sub_protocol(void)\n{\n\tchar *dot;\n\tint their_protocol, their_sub;\n\tint our_sub = get_subprotocol_version();\n\n\t/* client_info starts with VER.SUB string if client is a pre-release. */\n\tif (!(their_protocol = atoi(client_info))\n\t || !(dot = strchr(client_info, '.'))\n\t || !(their_sub = atoi(dot+1))) {\n#if SUBPROTOCOL_VERSION != 0\n\t\tif (our_sub)\n\t\t\tprotocol_version--;\n#endif\n\t\treturn;\n\t}\n\n\tif (their_protocol < protocol_version) {\n\t\tif (their_sub)\n\t\t\tprotocol_version = their_protocol - 1;\n\t\treturn;\n\t}\n\n\tif (their_protocol > protocol_version)\n\t\ttheir_sub = 0; /* 0 == final version of older protocol */\n\tif (their_sub != our_sub)\n\t\tprotocol_version--;\n}\n\nvoid set_allow_inc_recurse(void)\n{\n\tif (!local_server)\n\t\tclient_info = shell_cmd ? shell_cmd : \"\";\n\telse if (am_server) {\n\t\tchar buf[64];\n\t\tmaybe_add_e_option(buf, sizeof buf);\n\t\tclient_info = *buf ? strdup(buf+1) : \"\"; /* The +1 skips the leading \"e\". */\n\t}\n\n\tif (!recurse || use_qsort)\n\t\tallow_inc_recurse = 0;\n\telse if (!am_sender\n\t && (delete_before || delete_after\n\t  || delay_updates || prune_empty_dirs))\n\t\tallow_inc_recurse = 0;\n\telse if (am_server && strchr(client_info, 'i') == NULL)\n\t\tallow_inc_recurse = 0;\n}\n\nvoid parse_compress_choice(int final_call)\n{\n\tif (valid_compressions.negotiated_nni)\n\t\tdo_compression = valid_compressions.negotiated_nni->num;\n\telse if (compress_choice) {\n\t\tstruct name_num_item *nni = get_nni_by_name(&valid_compressions, compress_choice, -1);\n\t\tif (!nni) {\n\t\t\trprintf(FERROR, \"unknown compress name: %s\\n\", compress_choice);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t\tdo_compression = nni->num;\n\t\tif (am_server)\n\t\t\tvalidate_choice_vs_env(NSTR_COMPRESS, do_compression, -1);\n\t} else if (do_compression)\n\t\tdo_compression = CPRES_ZLIB;\n\telse\n\t\tdo_compression = CPRES_NONE;\n\n\tif (do_compression != CPRES_NONE && final_call)\n\t\tinit_compression_level(); /* There's a chance this might turn compression off! */\n\n\tif (do_compression == CPRES_NONE)\n\t\tcompress_choice = NULL;\n\n\t/* Snag the compression name for both write_batch's option output & the following debug output. */\n\tif (valid_compressions.negotiated_nni)\n\t\tcompress_choice = valid_compressions.negotiated_nni->name;\n\telse if (compress_choice == NULL) {\n\t\tstruct name_num_item *nni = get_nni_by_num(&valid_compressions, do_compression);\n\t\tcompress_choice = nni ? nni->name : \"UNKNOWN\";\n\t}\n\n\tif (final_call && DEBUG_GTE(NSTR, am_server ? 3 : 1)\n\t && (do_compression != CPRES_NONE || do_compression_level != CLVL_NOT_SPECIFIED)) {\n\t\trprintf(FINFO, \"%s%s compress: %s (level %d)\\n\",\n\t\t\tam_server ? \"Server\" : \"Client\",\n\t\t\tvalid_compressions.negotiated_nni ? \" negotiated\" : \"\",\n\t\t\tcompress_choice, do_compression_level);\n\t}\n}\n\nstruct name_num_item *get_nni_by_name(struct name_num_obj *nno, const char *name, int len)\n{\n\tstruct name_num_item *nni;\n\n\tif (len < 0)\n\t\tlen = strlen(name);\n\n\tfor (nni = nno->list; nni->name; nni++) {\n\t\tif (nni->num == CSUM_gone)\n\t\t\tcontinue;\n\t\tif (strncasecmp(name, nni->name, len) == 0 && nni->name[len] == '\\0')\n\t\t\treturn nni;\n\t}\n\n\treturn NULL;\n}\n\nstruct name_num_item *get_nni_by_num(struct name_num_obj *nno, int num)\n{\n\tstruct name_num_item *nni;\n\n\tfor (nni = nno->list; nni->name; nni++) {\n\t\tif (num == nni->num)\n\t\t\treturn nni;\n\t}\n\n\treturn NULL;\n}\n\nstatic void init_nno_saw(struct name_num_obj *nno, int val)\n{\n\tstruct name_num_item *nni;\n\tint cnt;\n\n\tif (!nno->saw_len) {\n\t\tfor (nni = nno->list; nni->name; nni++) {\n\t\t\tif (nni->num >= nno->saw_len)\n\t\t\t\tnno->saw_len = nni->num + 1;\n\t\t}\n\t}\n\n\tif (!nno->saw) {\n\t\tnno->saw = new_array0(uchar, nno->saw_len);\n\n\t\t/* We'll take this opportunity to set the main_nni values for duplicates. */\n\t\tfor (cnt = 1, nni = nno->list; nni->name; nni++, cnt++) {\n\t\t\tif (nni->num == CSUM_gone)\n\t\t\t\tcontinue;\n\t\t\tif (nno->saw[nni->num])\n\t\t\t\tnni->main_nni = &nno->list[nno->saw[nni->num]-1];\n\t\t\telse\n\t\t\t\tnno->saw[nni->num] = cnt;\n\t\t}\n\t}\n\n\tmemset(nno->saw, val, nno->saw_len);\n}\n\n/* Simplify the user-provided string so that it contains valid names without any duplicates.\n * It also sets the \"saw\" flags to a 1-relative count of which name was seen first. */\nstatic int parse_nni_str(struct name_num_obj *nno, const char *from, char *tobuf, int tobuf_len)\n{\n\tchar *to = tobuf, *tok = NULL;\n\tint saw_tok = 0, cnt = 0;\n\n\twhile (1) {\n\t\tint at_space = isSpace(from);\n\t\tchar ch = *from++;\n\t\tif (ch == '&')\n\t\t\tch = '\\0';\n\t\tif (!ch || at_space) {\n\t\t\tif (tok) {\n\t\t\t\tstruct name_num_item *nni = get_nni_by_name(nno, tok, to - tok);\n\t\t\t\tif (nni && !nno->saw[nni->num]) {\n\t\t\t\t\tnno->saw[nni->num] = ++cnt;\n\t\t\t\t\tif (nni->main_nni) {\n\t\t\t\t\t\tto = tok + strlcpy(tok, nni->main_nni->name, tobuf_len - (tok - tobuf));\n\t\t\t\t\t\tif (to - tobuf >= tobuf_len) {\n\t\t\t\t\t\t\tto = tok - 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tto = tok - (tok != tobuf);\n\t\t\t\tsaw_tok = 1;\n\t\t\t\ttok = NULL;\n\t\t\t}\n\t\t\tif (!ch)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!tok) {\n\t\t\tif (to != tobuf)\n\t\t\t\t*to++ = ' ';\n\t\t\ttok = to;\n\t\t}\n\t\tif (to - tobuf >= tobuf_len - 1) {\n\t\t\tto = tok - (tok != tobuf);\n\t\t\tbreak;\n\t\t}\n\t\t*to++ = ch;\n\t}\n\t*to = '\\0';\n\n\tif (saw_tok && to == tobuf)\n\t\treturn strlcpy(tobuf, \"INVALID\", MAX_NSTR_STRLEN);\n\n\treturn to - tobuf;\n}\n\nstatic int parse_negotiate_str(struct name_num_obj *nno, char *tmpbuf)\n{\n\tstruct name_num_item *nni, *ret = NULL;\n\tint best = nno->saw_len; /* We want best == 1 from the client list, so start with a big number. */\n\tchar *space, *tok = tmpbuf;\n\twhile (tok) {\n\t\twhile (*tok == ' ') tok++; /* Should be unneeded... */\n\t\tif (!*tok)\n\t\t\tbreak;\n\t\tif ((space = strchr(tok, ' ')) != NULL)\n\t\t\t*space = '\\0';\n\t\tnni = get_nni_by_name(nno, tok, -1);\n\t\tif (space) {\n\t\t\t*space = ' ';\n\t\t\ttok = space + 1;\n\t\t} else\n\t\t\ttok = NULL;\n\t\tif (!nni || !nno->saw[nni->num] || best <= nno->saw[nni->num])\n\t\t\tcontinue;\n\t\tret = nni;\n\t\tbest = nno->saw[nni->num];\n\t\tif (best == 1 || am_server) /* The server side stops at the first acceptable client choice */\n\t\t\tbreak;\n\t}\n\tif (ret) {\n\t\tfree(nno->saw);\n\t\tnno->saw = NULL;\n\t\tnno->negotiated_nni = ret->main_nni ? ret->main_nni : ret;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* This routine is always called with a tmpbuf of MAX_NSTR_STRLEN length, but the\n * buffer may be pre-populated with a \"len\" length string to use OR a len of -1\n * to tell us to read a string from the fd. */\nstatic void recv_negotiate_str(int f_in, struct name_num_obj *nno, char *tmpbuf, int len)\n{\n\tif (len < 0)\n\t\tlen = read_vstring(f_in, tmpbuf, MAX_NSTR_STRLEN);\n\n\tif (DEBUG_GTE(NSTR, am_server ? 3 : 2)) {\n\t\tif (am_server)\n\t\t\trprintf(FINFO, \"Client %s list (on server): %s\\n\", nno->type, tmpbuf);\n\t\telse\n\t\t\trprintf(FINFO, \"Server %s list (on client): %s\\n\", nno->type, tmpbuf);\n\t}\n\n\tif (len > 0 && parse_negotiate_str(nno, tmpbuf))\n\t\treturn;\n\n\tif (!am_server || !do_negotiated_strings) {\n\t\tchar *cp = tmpbuf;\n\t\tint j;\n\t\trprintf(FERROR, \"Failed to negotiate a %s choice.\\n\", nno->type);\n\t\trprintf(FERROR, \"%s list: %s\\n\", am_server ? \"Client\" : \"Server\", tmpbuf);\n\t\t/* Recreate our original list from the saw values. This can't overflow our huge\n\t\t * buffer because we don't have enough valid entries to get anywhere close. */\n\t\tfor (j = 1, *cp = '\\0'; j <= nno->saw_len; j++) {\n\t\t\tstruct name_num_item *nni;\n\t\t\tfor (nni = nno->list; nni->name; nni++) {\n\t\t\t\tif (nno->saw[nni->num] == j) {\n\t\t\t\t\t*cp++ = ' ';\n\t\t\t\t\tcp += strlcpy(cp, nni->name, MAX_NSTR_STRLEN - (cp - tmpbuf));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!*tmpbuf)\n\t\t\tstrlcpy(cp, \" INVALID\", MAX_NSTR_STRLEN);\n\t\trprintf(FERROR, \"%s list:%s\\n\", am_server ? \"Server\" : \"Client\", tmpbuf);\n\t}\n\n\texit_cleanup(RERR_UNSUPPORTED);\n}\n\nstatic const char *getenv_nstr(int ntype)\n{\n\tconst char *env_str = getenv(ntype == NSTR_COMPRESS ? \"RSYNC_COMPRESS_LIST\" : \"RSYNC_CHECKSUM_LIST\");\n\n\t/* When writing a batch file, we always negotiate an old-style choice. */\n\tif (write_batch)\n\t\tenv_str = ntype == NSTR_COMPRESS ? \"zlib\" : protocol_version >= 30 ? \"md5\" : \"md4\";\n\n\tif (am_server && env_str) {\n\t\tchar *cp = strchr(env_str, '&');\n\t\tif (cp)\n\t\t\tenv_str = cp + 1;\n\t}\n\n\treturn env_str;\n}\n\nvoid validate_choice_vs_env(int ntype, int num1, int num2)\n{\n\tstruct name_num_obj *nno = ntype == NSTR_COMPRESS ? &valid_compressions : &valid_checksums;\n\tconst char *list_str = getenv_nstr(ntype);\n\tchar tmpbuf[MAX_NSTR_STRLEN];\n\n\tif (!list_str)\n\t\treturn;\n\n\twhile (isSpace(list_str)) list_str++;\n\n\tif (!*list_str)\n\t\treturn;\n\n\tinit_nno_saw(nno, 0);\n\tparse_nni_str(nno, list_str, tmpbuf, MAX_NSTR_STRLEN);\n\n\tif (ntype == NSTR_CHECKSUM) /* If \"md4\" is in the env list, all the old MD4 choices are OK too. */\n\t\tnno->saw[CSUM_MD4_ARCHAIC] = nno->saw[CSUM_MD4_BUSTED] = nno->saw[CSUM_MD4_OLD] = nno->saw[CSUM_MD4];\n\n\tif (!nno->saw[num1] || (num2 >= 0 && !nno->saw[num2])) {\n\t\trprintf(FERROR, \"Your --%s-choice value (%s) was refused by the server.\\n\",\n\t\t\tntype == NSTR_COMPRESS ? \"compress\" : \"checksum\",\n\t\t\tntype == NSTR_COMPRESS ? compress_choice : checksum_choice);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tfree(nno->saw);\n\tnno->saw = NULL;\n}\n\n/* The saw buffer is initialized and used to store ordinal values from 1 to N\n * for the order of the args in the array.  If dup_markup == '\\0', duplicates\n * are removed otherwise the char is prefixed to the duplicate term and, if it\n * is an opening paren/bracket/brace, the matching closing char is suffixed.\n * \"none\" is removed on the client side unless dup_markup != '\\0'. */\nint get_default_nno_list(struct name_num_obj *nno, char *to_buf, int to_buf_len, char dup_markup)\n{\n\tstruct name_num_item *nni;\n\tint len = 0, cnt = 0;\n\tchar delim = '\\0', post_delim;\n\n\tswitch (dup_markup) {\n\tcase '(': post_delim = ')'; break;\n\tcase '[': post_delim = ']'; break;\n\tcase '{': post_delim = '}'; break;\n\tdefault: post_delim = '\\0'; break;\n\t}\n\n\tinit_nno_saw(nno, 0);\n\n\tfor (nni = nno->list, len = 0; nni->name; nni++) {\n\t\tif (nni->num == CSUM_gone)\n\t\t\tcontinue;\n\t\tif (nni->main_nni) {\n\t\t\tif (!dup_markup || nni->main_nni->num == CSUM_gone)\n\t\t\t\tcontinue;\n\t\t\tdelim = dup_markup;\n\t\t}\n\t\tif (nni->num == 0 && !am_server && !dup_markup)\n\t\t\tcontinue;\n\t\tif (len)\n\t\t\tto_buf[len++]= ' ';\n\t\tif (delim) {\n\t\t\tto_buf[len++]= delim;\n\t\t\tdelim = post_delim;\n\t\t}\n\t\tlen += strlcpy(to_buf+len, nni->name, to_buf_len - len);\n\t\tif (len >= to_buf_len - 3)\n\t\t\texit_cleanup(RERR_UNSUPPORTED); /* IMPOSSIBLE... */\n\t\tif (delim) {\n\t\t\tto_buf[len++]= delim;\n\t\t\tdelim = '\\0';\n\t\t}\n\t\tnno->saw[nni->num] = ++cnt;\n\t}\n\n\treturn len;\n}\n\nstatic void send_negotiate_str(int f_out, struct name_num_obj *nno, int ntype)\n{\n\tchar tmpbuf[MAX_NSTR_STRLEN];\n\tconst char *list_str = getenv_nstr(ntype);\n\tint len;\n\n\tif (list_str && *list_str) {\n\t\tinit_nno_saw(nno, 0);\n\t\tlen = parse_nni_str(nno, list_str, tmpbuf, MAX_NSTR_STRLEN);\n\t\tlist_str = tmpbuf;\n\t} else\n\t\tlist_str = NULL;\n\n\tif (!list_str || !*list_str)\n\t\tlen = get_default_nno_list(nno, tmpbuf, MAX_NSTR_STRLEN, '\\0');\n\n\tif (DEBUG_GTE(NSTR, am_server ? 3 : 2)) {\n\t\tif (am_server)\n\t\t\trprintf(FINFO, \"Server %s list (on server): %s\\n\", nno->type, tmpbuf);\n\t\telse\n\t\t\trprintf(FINFO, \"Client %s list (on client): %s\\n\", nno->type, tmpbuf);\n\t}\n\n\t/* Each side sends their list of valid names to the other side and then both sides\n\t * pick the first name in the client's list that is also in the server's list. */\n\tif (do_negotiated_strings)\n\t\twrite_vstring(f_out, tmpbuf, len);\n}\n\nstatic void negotiate_the_strings(int f_in, int f_out)\n{\n\t/* We send all the negotiation strings before we start to read them to help avoid a slow startup. */\n\n\tinit_checksum_choices();\n\n\tif (!checksum_choice)\n\t\tsend_negotiate_str(f_out, &valid_checksums, NSTR_CHECKSUM);\n\n\tif (do_compression && !compress_choice)\n\t\tsend_negotiate_str(f_out, &valid_compressions, NSTR_COMPRESS);\n\n\tif (valid_checksums.saw) {\n\t\tchar tmpbuf[MAX_NSTR_STRLEN];\n\t\tint len;\n\t\tif (do_negotiated_strings)\n\t\t\tlen = -1;\n\t\telse\n\t\t\tlen = strlcpy(tmpbuf, protocol_version >= 30 ? \"md5\" : \"md4\", MAX_NSTR_STRLEN);\n\t\trecv_negotiate_str(f_in, &valid_checksums, tmpbuf, len);\n\t}\n\n\tif (valid_compressions.saw) {\n\t\tchar tmpbuf[MAX_NSTR_STRLEN];\n\t\tint len;\n\t\tif (do_negotiated_strings)\n\t\t\tlen = -1;\n\t\telse\n\t\t\tlen = strlcpy(tmpbuf, \"zlib\", MAX_NSTR_STRLEN);\n\t\trecv_negotiate_str(f_in, &valid_compressions, tmpbuf, len);\n\t}\n\n\t/* If the other side is too old to negotiate, the above steps just made sure that\n\t * the env didn't disallow the old algorithm. Mark things as non-negotiated. */\n\tif (!do_negotiated_strings)\n\t\tvalid_checksums.negotiated_nni = valid_compressions.negotiated_nni = NULL;\n}\n\nvoid setup_protocol(int f_out,int f_in)\n{\n\tassert(file_extra_cnt == 0);\n\tassert(EXTRA64_CNT == 2 || EXTRA64_CNT == 1);\n\n\t/* All int64 values must be set first so that they are guaranteed to be\n\t * aligned for direct int64-pointer memory access. */\n\tif (preserve_atimes)\n\t\tatimes_ndx = (file_extra_cnt += EXTRA64_CNT);\n\tif (preserve_crtimes)\n\t\tcrtimes_ndx = (file_extra_cnt += EXTRA64_CNT);\n\tif (am_sender) /* This is most likely in the file_extras64 union as well. */\n\t\tpathname_ndx = (file_extra_cnt += PTR_EXTRA_CNT);\n\telse\n\t\tdepth_ndx = ++file_extra_cnt;\n\tif (preserve_uid)\n\t\tuid_ndx = ++file_extra_cnt;\n\tif (preserve_gid)\n\t\tgid_ndx = ++file_extra_cnt;\n\tif (preserve_acls && !am_sender)\n\t\tacls_ndx = ++file_extra_cnt;\n\tif (preserve_xattrs)\n\t\txattrs_ndx = ++file_extra_cnt;\n\n\tif (am_server)\n\t\tset_allow_inc_recurse();\n\n\tif (remote_protocol == 0) {\n\t\tif (am_server && !local_server)\n\t\t\tcheck_sub_protocol();\n\t\tif (!read_batch)\n\t\t\twrite_int(f_out, protocol_version);\n\t\tremote_protocol = read_int(f_in);\n\t\tif (protocol_version > remote_protocol)\n\t\t\tprotocol_version = remote_protocol;\n\t}\n\tif (read_batch && remote_protocol > protocol_version) {\n\t\trprintf(FERROR, \"The protocol version in the batch file is too new (%d > %d).\\n\",\n\t\t\tremote_protocol, protocol_version);\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\n\tif (DEBUG_GTE(PROTO, 1)) {\n\t\trprintf(FINFO, \"(%s) Protocol versions: remote=%d, negotiated=%d\\n\",\n\t\t\tam_server? \"Server\" : \"Client\", remote_protocol, protocol_version);\n\t}\n\tif (remote_protocol < MIN_PROTOCOL_VERSION\n\t || remote_protocol > MAX_PROTOCOL_VERSION) {\n\t\trprintf(FERROR,\"protocol version mismatch -- is your shell clean?\\n\");\n\t\trprintf(FERROR,\"(see the rsync manpage for an explanation)\\n\");\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tif (remote_protocol < OLD_PROTOCOL_VERSION) {\n\t\trprintf(FINFO,\"%s is very old version of rsync, upgrade recommended.\\n\",\n\t\t\tam_server? \"Client\" : \"Server\");\n\t}\n\tif (protocol_version < MIN_PROTOCOL_VERSION) {\n\t\trprintf(FERROR, \"--protocol must be at least %d on the %s.\\n\",\n\t\t\tMIN_PROTOCOL_VERSION, am_server? \"Server\" : \"Client\");\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tif (protocol_version > PROTOCOL_VERSION) {\n\t\trprintf(FERROR, \"--protocol must be no more than %d on the %s.\\n\",\n\t\t\tPROTOCOL_VERSION, am_server? \"Server\" : \"Client\");\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tif (read_batch)\n\t\tcheck_batch_flags();\n\n\tif (!saw_stderr_opt && protocol_version <= 28 && am_server)\n\t\tmsgs2stderr = 0; /* The client side may not have stderr setup for us. */\n\n#ifndef SUPPORT_PREALLOCATION\n\tif (preallocate_files && !am_sender) {\n\t\trprintf(FERROR, \"preallocation is not supported on this %s\\n\",\n\t\t\tam_server ? \"Server\" : \"Client\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n#endif\n\n\tif (protocol_version < 30) {\n\t\tif (append_mode == 1)\n\t\t\tappend_mode = 2;\n\t\tif (preserve_acls && !local_server) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"--acls requires protocol 30 or higher\"\n\t\t\t\t\" (negotiated %d).\\n\",\n\t\t\t\tprotocol_version);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (preserve_xattrs && !local_server) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"--xattrs requires protocol 30 or higher\"\n\t\t\t\t\" (negotiated %d).\\n\",\n\t\t\t\tprotocol_version);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t}\n\n\tif (delete_mode && !(delete_before+delete_during+delete_after)) {\n\t\tif (protocol_version < 30)\n\t\t\tdelete_before = 1;\n\t\telse\n\t\t\tdelete_during = 1;\n\t}\n\n\tif (protocol_version < 29) {\n\t\tif (fuzzy_basis) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"--fuzzy requires protocol 29 or higher\"\n\t\t\t\t\" (negotiated %d).\\n\",\n\t\t\t\tprotocol_version);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (basis_dir_cnt && inplace) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"%s with --inplace requires protocol 29 or higher\"\n\t\t\t\t\" (negotiated %d).\\n\",\n\t\t\t\talt_dest_opt(0), protocol_version);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (basis_dir_cnt > 1) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"Using more than one %s option requires protocol\"\n\t\t\t\t\" 29 or higher (negotiated %d).\\n\",\n\t\t\t\talt_dest_opt(0), protocol_version);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (prune_empty_dirs) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"--prune-empty-dirs requires protocol 29 or higher\"\n\t\t\t\t\" (negotiated %d).\\n\",\n\t\t\t\tprotocol_version);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t} else if (protocol_version >= 30) {\n\t\tif (am_server) {\n\t\t\tcompat_flags = allow_inc_recurse ? CF_INC_RECURSE : 0;\n#ifdef CAN_SET_SYMLINK_TIMES\n\t\t\tcompat_flags |= CF_SYMLINK_TIMES;\n#endif\n#ifdef ICONV_OPTION\n\t\t\tcompat_flags |= CF_SYMLINK_ICONV;\n#endif\n\t\t\tif (strchr(client_info, 'f') != NULL)\n\t\t\t\tcompat_flags |= CF_SAFE_FLIST;\n\t\t\tif (strchr(client_info, 'x') != NULL)\n\t\t\t\tcompat_flags |= CF_AVOID_XATTR_OPTIM;\n\t\t\tif (strchr(client_info, 'C') != NULL)\n\t\t\t\tcompat_flags |= CF_CHKSUM_SEED_FIX;\n\t\t\tif (strchr(client_info, 'I') != NULL)\n\t\t\t\tcompat_flags |= CF_INPLACE_PARTIAL_DIR;\n\t\t\tif (strchr(client_info, 'u') != NULL)\n\t\t\t\tcompat_flags |= CF_ID0_NAMES;\n\t\t\tif (strchr(client_info, 'v') != NULL) {\n\t\t\t\tdo_negotiated_strings = 1;\n\t\t\t\tcompat_flags |= CF_VARINT_FLIST_FLAGS;\n\t\t\t}\n\t\t\tif (strchr(client_info, 'V') != NULL) { /* Support a pre-release 'V' that got superseded */\n\t\t\t\tif (!write_batch)\n\t\t\t\t\tcompat_flags |= CF_VARINT_FLIST_FLAGS;\n\t\t\t\twrite_byte(f_out, compat_flags);\n\t\t\t} else\n\t\t\t\twrite_varint(f_out, compat_flags);\n\t\t} else { /* read_varint() is compatible with the older write_byte() when the 0x80 bit isn't on. */\n\t\t\tcompat_flags = read_varint(f_in);\n\t\t\tif  (compat_flags & CF_VARINT_FLIST_FLAGS)\n\t\t\t\tdo_negotiated_strings = 1;\n\t\t}\n\t\t/* The inc_recurse var MUST be set to 0 or 1. */\n\t\tinc_recurse = compat_flags & CF_INC_RECURSE ? 1 : 0;\n\t\twant_xattr_optim = protocol_version >= 31 && !(compat_flags & CF_AVOID_XATTR_OPTIM);\n\t\tproper_seed_order = compat_flags & CF_CHKSUM_SEED_FIX ? 1 : 0;\n\t\txfer_flags_as_varint = compat_flags & CF_VARINT_FLIST_FLAGS ? 1 : 0;\n\t\txmit_id0_names = compat_flags & CF_ID0_NAMES ? 1 : 0;\n\t\tif (!xfer_flags_as_varint && preserve_crtimes) {\n\t\t\tfprintf(stderr, \"Both rsync versions must be at least 3.2.0 for --crtimes.\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (am_sender) {\n\t\t\treceiver_symlink_times = am_server\n\t\t\t    ? strchr(client_info, 'L') != NULL\n\t\t\t    : !!(compat_flags & CF_SYMLINK_TIMES);\n\t\t}\n#ifdef CAN_SET_SYMLINK_TIMES\n\t\telse\n\t\t\treceiver_symlink_times = 1;\n#endif\n#ifdef ICONV_OPTION\n\t\tsender_symlink_iconv = iconv_opt && (am_server\n\t\t    ? strchr(client_info, 's') != NULL\n\t\t    : !!(compat_flags & CF_SYMLINK_ICONV));\n#endif\n\t\tif (inc_recurse && !allow_inc_recurse) {\n\t\t\t/* This should only be able to happen in a batch. */\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Incompatible options specified for inc-recursive %s.\\n\",\n\t\t\t\tread_batch ? \"batch file\" : \"connection\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tuse_safe_inc_flist = (compat_flags & CF_SAFE_FLIST) || protocol_version >= 31;\n\t\tneed_messages_from_generator = 1;\n\t\tif (compat_flags & CF_INPLACE_PARTIAL_DIR)\n\t\t\tinplace_partial = 1;\n#ifdef CAN_SET_SYMLINK_TIMES\n\t} else if (!am_sender) {\n\t\treceiver_symlink_times = 1;\n#endif\n\t}\n\n\tif (read_batch)\n\t\tdo_negotiated_strings = 0;\n\n\tif (need_unsorted_flist && (!am_sender || inc_recurse))\n\t\tunsort_ndx = ++file_extra_cnt;\n\n\tif (partial_dir && *partial_dir != '/' && (!am_server || local_server)) {\n\t\tint rflags = FILTRULE_NO_PREFIXES | FILTRULE_DIRECTORY;\n\t\tif (!am_sender || protocol_version >= 30)\n\t\t\trflags |= FILTRULE_PERISHABLE;\n\t\tparse_filter_str(&filter_list, partial_dir, rule_template(rflags), 0);\n\t}\n\n\n#ifdef ICONV_OPTION\n\tif (protect_args && files_from) {\n\t\tif (am_sender)\n\t\t\tfilesfrom_convert = filesfrom_host && ic_send != (iconv_t)-1;\n\t\telse\n\t\t\tfilesfrom_convert = !filesfrom_host && ic_recv != (iconv_t)-1;\n\t}\n#endif\n\n\tnegotiate_the_strings(f_in, f_out);\n\n\tif (am_server) {\n\t\tif (!checksum_seed)\n\t\t\tchecksum_seed = time(NULL) ^ (getpid() << 6);\n\t\twrite_int(f_out, checksum_seed);\n\t} else {\n\t\tchecksum_seed = read_int(f_in);\n\t}\n\n\tparse_checksum_choice(1); /* Sets file_sum_nni & xfer_sum_nni */\n\tparse_compress_choice(1); /* Sets do_compression */\n\n\t/* TODO in the future allow this algorithm to be chosen somehow, but it can't get too\n\t * long or the size starts to cause a problem in the xattr abbrev/non-abbrev code. */\n\txattr_sum_nni = parse_csum_name(NULL, 0);\n\txattr_sum_len = csum_len_for_type(xattr_sum_nni->num, 0);\n\n\tif (write_batch && !am_server)\n\t\twrite_batch_shell_file();\n\n\tinit_flist();\n}\n\nvoid output_daemon_greeting(int f_out, int am_client)\n{\n\tchar tmpbuf[MAX_NSTR_STRLEN];\n\tint our_sub = get_subprotocol_version();\n\n\tinit_checksum_choices();\n\n\tget_default_nno_list(&valid_auth_checksums, tmpbuf, MAX_NSTR_STRLEN, '\\0');\n\n\tio_printf(f_out, \"@RSYNCD: %d.%d %s\\n\", protocol_version, our_sub, tmpbuf);\n\n\tif (am_client && DEBUG_GTE(NSTR, 2))\n\t\trprintf(FINFO, \"Client %s list (on client): %s\\n\", valid_auth_checksums.type, tmpbuf);\n}\n\nvoid negotiate_daemon_auth(int f_out, int am_client)\n{\n\tchar tmpbuf[MAX_NSTR_STRLEN];\n\tint save_am_server = am_server;\n\tint md4_is_old = 0;\n\n\tif (!am_client)\n\t\tam_server = 1;\n\n\tif (daemon_auth_choices)\n\t\tstrlcpy(tmpbuf, daemon_auth_choices, MAX_NSTR_STRLEN);\n\telse {\n\t\tstrlcpy(tmpbuf, protocol_version >= 30 ? \"md5\" : \"md4\", MAX_NSTR_STRLEN);\n\t\tmd4_is_old = 1;\n\t}\n\n\tif (am_client) {\n\t\trecv_negotiate_str(-1, &valid_auth_checksums, tmpbuf, strlen(tmpbuf));\n\t\tif (DEBUG_GTE(NSTR, 1)) {\n\t\t\trprintf(FINFO, \"Client negotiated %s: %s\\n\", valid_auth_checksums.type,\n\t\t\t\tvalid_auth_checksums.negotiated_nni->name);\n\t\t}\n\t} else {\n\t\tif (!parse_negotiate_str(&valid_auth_checksums, tmpbuf)) {\n\t\t\tget_default_nno_list(&valid_auth_checksums, tmpbuf, MAX_NSTR_STRLEN, '\\0');\n\t\t\tio_printf(f_out, \"@ERROR: your client does not support one of our daemon-auth checksums: %s\\n\",\n\t\t\t\t  tmpbuf);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t}\n\tam_server = save_am_server;\n\tif (md4_is_old && valid_auth_checksums.negotiated_nni->num == CSUM_MD4) {\n\t\tvalid_auth_checksums.negotiated_nni->num = CSUM_MD4_OLD;\n\t\tvalid_auth_checksums.negotiated_nni->flags = 0;\n\t}\n}\n\nint get_subprotocol_version()\n{\n#if SUBPROTOCOL_VERSION != 0\n\treturn protocol_version < PROTOCOL_VERSION ? 0 : SUBPROTOCOL_VERSION;\n#else\n\treturn 0;\n#endif\n}\n"
        },
        {
          "name": "config.guess",
          "type": "blob",
          "size": 48.767578125,
          "content": "#! /bin/sh\n# Attempt to guess a canonical system name.\n#   Copyright 1992-2023 Free Software Foundation, Inc.\n\n# shellcheck disable=SC2006,SC2268 # see below for rationale\n\ntimestamp='2023-01-01'\n\n# This file is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that\n# program.  This Exception is an additional permission under section 7\n# of the GNU General Public License, version 3 (\"GPLv3\").\n#\n# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.\n#\n# You can get the latest version of this script from:\n# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess\n#\n# Please send patches to <config-patches@gnu.org>.\n\n\n# The \"shellcheck disable\" line above the timestamp inhibits complaints\n# about features and limitations of the classic Bourne shell that were\n# superseded or lifted in POSIX.  However, this script identifies a wide\n# variety of pre-POSIX systems that do not have POSIX shells at all, and\n# even some reasonably current systems (Solaris 10 as case-in-point) still\n# have a pre-POSIX /bin/sh.\n\n\nme=`echo \"$0\" | sed -e 's,.*/,,'`\n\nusage=\"\\\nUsage: $0 [OPTION]\n\nOutput the configuration name of the system \\`$me' is run on.\n\nOptions:\n  -h, --help         print this help, then exit\n  -t, --time-stamp   print date of last modification, then exit\n  -v, --version      print version number, then exit\n\nReport bugs and patches to <config-patches@gnu.org>.\"\n\nversion=\"\\\nGNU config.guess ($timestamp)\n\nOriginally written by Per Bothner.\nCopyright 1992-2023 Free Software Foundation, Inc.\n\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n\nhelp=\"\nTry \\`$me --help' for more information.\"\n\n# Parse command line\nwhile test $# -gt 0 ; do\n  case $1 in\n    --time-stamp | --time* | -t )\n       echo \"$timestamp\" ; exit ;;\n    --version | -v )\n       echo \"$version\" ; exit ;;\n    --help | --h* | -h )\n       echo \"$usage\"; exit ;;\n    -- )     # Stop option processing\n       shift; break ;;\n    - )\t# Use stdin as input.\n       break ;;\n    -* )\n       echo \"$me: invalid option $1$help\" >&2\n       exit 1 ;;\n    * )\n       break ;;\n  esac\ndone\n\nif test $# != 0; then\n  echo \"$me: too many arguments$help\" >&2\n  exit 1\nfi\n\n# Just in case it came from the environment.\nGUESS=\n\n# CC_FOR_BUILD -- compiler used by this script. Note that the use of a\n# compiler to aid in system detection is discouraged as it requires\n# temporary files to be created and, as you can see below, it is a\n# headache to deal with in a portable fashion.\n\n# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still\n# use `HOST_CC' if defined, but it is deprecated.\n\n# Portable tmp directory creation inspired by the Autoconf team.\n\ntmp=\n# shellcheck disable=SC2172\ntrap 'test -z \"$tmp\" || rm -fr \"$tmp\"' 0 1 2 13 15\n\nset_cc_for_build() {\n    # prevent multiple calls if $tmp is already set\n    test \"$tmp\" && return 0\n    : \"${TMPDIR=/tmp}\"\n    # shellcheck disable=SC2039,SC3028\n    { tmp=`(umask 077 && mktemp -d \"$TMPDIR/cgXXXXXX\") 2>/dev/null` && test -n \"$tmp\" && test -d \"$tmp\" ; } ||\n\t{ test -n \"$RANDOM\" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir \"$tmp\" 2>/dev/null) ; } ||\n\t{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir \"$tmp\" 2>/dev/null) && echo \"Warning: creating insecure temp directory\" >&2 ; } ||\n\t{ echo \"$me: cannot create a temporary directory in $TMPDIR\" >&2 ; exit 1 ; }\n    dummy=$tmp/dummy\n    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in\n\t,,)    echo \"int x;\" > \"$dummy.c\"\n\t       for driver in cc gcc c89 c99 ; do\n\t\t   if ($driver -c -o \"$dummy.o\" \"$dummy.c\") >/dev/null 2>&1 ; then\n\t\t       CC_FOR_BUILD=$driver\n\t\t       break\n\t\t   fi\n\t       done\n\t       if test x\"$CC_FOR_BUILD\" = x ; then\n\t\t   CC_FOR_BUILD=no_compiler_found\n\t       fi\n\t       ;;\n\t,,*)   CC_FOR_BUILD=$CC ;;\n\t,*,*)  CC_FOR_BUILD=$HOST_CC ;;\n    esac\n}\n\n# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n# (ghazi@noc.rutgers.edu 1994-08-24)\nif test -f /.attbin/uname ; then\n\tPATH=$PATH:/.attbin ; export PATH\nfi\n\nUNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\nUNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\nUNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown\nUNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n\ncase $UNAME_SYSTEM in\nLinux|GNU|GNU/*)\n\tLIBC=unknown\n\n\tset_cc_for_build\n\tcat <<-EOF > \"$dummy.c\"\n\t#include <features.h>\n\t#if defined(__UCLIBC__)\n\tLIBC=uclibc\n\t#elif defined(__dietlibc__)\n\tLIBC=dietlibc\n\t#elif defined(__GLIBC__)\n\tLIBC=gnu\n\t#else\n\t#include <stdarg.h>\n\t/* First heuristic to detect musl libc.  */\n\t#ifdef __DEFINED_va_list\n\tLIBC=musl\n\t#endif\n\t#endif\n\tEOF\n\tcc_set_libc=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`\n\teval \"$cc_set_libc\"\n\n\t# Second heuristic to detect musl libc.\n\tif [ \"$LIBC\" = unknown ] &&\n\t   command -v ldd >/dev/null &&\n\t   ldd --version 2>&1 | grep -q ^musl; then\n\t\tLIBC=musl\n\tfi\n\n\t# If the system lacks a compiler, then just pick glibc.\n\t# We could probably try harder.\n\tif [ \"$LIBC\" = unknown ]; then\n\t\tLIBC=gnu\n\tfi\n\t;;\nesac\n\n# Note: order is significant - the case branches are not exclusive.\n\ncase $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in\n    *:NetBSD:*:*)\n\t# NetBSD (nbsd) targets should (where applicable) match one or\n\t# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,\n\t# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently\n\t# switched to ELF, *-*-netbsd* would select the old\n\t# object file format.  This provides both forward\n\t# compatibility and a consistent mechanism for selecting the\n\t# object file format.\n\t#\n\t# Note: NetBSD doesn't particularly care about the vendor\n\t# portion of the name.  We always set it to \"unknown\".\n\tUNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \\\n\t    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \\\n\t    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \\\n\t    echo unknown)`\n\tcase $UNAME_MACHINE_ARCH in\n\t    aarch64eb) machine=aarch64_be-unknown ;;\n\t    armeb) machine=armeb-unknown ;;\n\t    arm*) machine=arm-unknown ;;\n\t    sh3el) machine=shl-unknown ;;\n\t    sh3eb) machine=sh-unknown ;;\n\t    sh5el) machine=sh5le-unknown ;;\n\t    earmv*)\n\t\tarch=`echo \"$UNAME_MACHINE_ARCH\" | sed -e 's,^e\\(armv[0-9]\\).*$,\\1,'`\n\t\tendian=`echo \"$UNAME_MACHINE_ARCH\" | sed -ne 's,^.*\\(eb\\)$,\\1,p'`\n\t\tmachine=${arch}${endian}-unknown\n\t\t;;\n\t    *) machine=$UNAME_MACHINE_ARCH-unknown ;;\n\tesac\n\t# The Operating System including object format, if it has switched\n\t# to ELF recently (or will in the future) and ABI.\n\tcase $UNAME_MACHINE_ARCH in\n\t    earm*)\n\t\tos=netbsdelf\n\t\t;;\n\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n\t\tset_cc_for_build\n\t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t\t\t| grep -q __ELF__\n\t\tthen\n\t\t    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).\n\t\t    # Return netbsd for either.  FIX?\n\t\t    os=netbsd\n\t\telse\n\t\t    os=netbsdelf\n\t\tfi\n\t\t;;\n\t    *)\n\t\tos=netbsd\n\t\t;;\n\tesac\n\t# Determine ABI tags.\n\tcase $UNAME_MACHINE_ARCH in\n\t    earm*)\n\t\texpr='s/^earmv[0-9]/-eabi/;s/eb$//'\n\t\tabi=`echo \"$UNAME_MACHINE_ARCH\" | sed -e \"$expr\"`\n\t\t;;\n\tesac\n\t# The OS release\n\t# Debian GNU/NetBSD machines have a different userland, and\n\t# thus, need a distinct triplet. However, they do not need\n\t# kernel version information, so it can be replaced with a\n\t# suitable tag, in the style of linux-gnu.\n\tcase $UNAME_VERSION in\n\t    Debian*)\n\t\trelease='-gnu'\n\t\t;;\n\t    *)\n\t\trelease=`echo \"$UNAME_RELEASE\" | sed -e 's/[-_].*//' | cut -d. -f1,2`\n\t\t;;\n\tesac\n\t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n\t# contains redundant information, the shorter form:\n\t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n\tGUESS=$machine-${os}${release}${abi-}\n\t;;\n    *:Bitrig:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE\n\t;;\n    *:OpenBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE\n\t;;\n    *:SecBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE\n\t;;\n    *:LibertyBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\\.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE\n\t;;\n    *:MidnightBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE\n\t;;\n    *:ekkoBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE\n\t;;\n    *:SolidBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE\n\t;;\n    *:OS108:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE\n\t;;\n    macppc:MirBSD:*:*)\n\tGUESS=powerpc-unknown-mirbsd$UNAME_RELEASE\n\t;;\n    *:MirBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE\n\t;;\n    *:Sortix:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-sortix\n\t;;\n    *:Twizzler:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-twizzler\n\t;;\n    *:Redox:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-redox\n\t;;\n    mips:OSF1:*.*)\n\tGUESS=mips-dec-osf1\n\t;;\n    alpha:OSF1:*:*)\n\t# Reset EXIT trap before exiting to avoid spurious non-zero exit code.\n\ttrap '' 0\n\tcase $UNAME_RELEASE in\n\t*4.0)\n\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n\t\t;;\n\t*5.*)\n\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`\n\t\t;;\n\tesac\n\t# According to Compaq, /usr/sbin/psrinfo has been available on\n\t# OSF/1 and Tru64 systems produced since 1995.  I hope that\n\t# covers most systems running today.  This code pipes the CPU\n\t# types through head -n 1, so we only detect the type of CPU 0.\n\tALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \\(.*\\) processor.*$/\\1/p' | head -n 1`\n\tcase $ALPHA_CPU_TYPE in\n\t    \"EV4 (21064)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"EV4.5 (21064)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"LCA4 (21066/21068)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"EV5 (21164)\")\n\t\tUNAME_MACHINE=alphaev5 ;;\n\t    \"EV5.6 (21164A)\")\n\t\tUNAME_MACHINE=alphaev56 ;;\n\t    \"EV5.6 (21164PC)\")\n\t\tUNAME_MACHINE=alphapca56 ;;\n\t    \"EV5.7 (21164PC)\")\n\t\tUNAME_MACHINE=alphapca57 ;;\n\t    \"EV6 (21264)\")\n\t\tUNAME_MACHINE=alphaev6 ;;\n\t    \"EV6.7 (21264A)\")\n\t\tUNAME_MACHINE=alphaev67 ;;\n\t    \"EV6.8CB (21264C)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.8AL (21264B)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.8CX (21264D)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.9A (21264/EV69A)\")\n\t\tUNAME_MACHINE=alphaev69 ;;\n\t    \"EV7 (21364)\")\n\t\tUNAME_MACHINE=alphaev7 ;;\n\t    \"EV7.9 (21364A)\")\n\t\tUNAME_MACHINE=alphaev79 ;;\n\tesac\n\t# A Pn.n version is a patched version.\n\t# A Vn.n version is a released version.\n\t# A Tn.n version is a released field test version.\n\t# A Xn.n version is an unreleased experimental baselevel.\n\t# 1.2 uses \"1.2\" for uname -r.\n\tOSF_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`\n\tGUESS=$UNAME_MACHINE-dec-osf$OSF_REL\n\t;;\n    Amiga*:UNIX_System_V:4.0:*)\n\tGUESS=m68k-unknown-sysv4\n\t;;\n    *:[Aa]miga[Oo][Ss]:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-amigaos\n\t;;\n    *:[Mm]orph[Oo][Ss]:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-morphos\n\t;;\n    *:OS/390:*:*)\n\tGUESS=i370-ibm-openedition\n\t;;\n    *:z/VM:*:*)\n\tGUESS=s390-ibm-zvmoe\n\t;;\n    *:OS400:*:*)\n\tGUESS=powerpc-ibm-os400\n\t;;\n    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n\tGUESS=arm-acorn-riscix$UNAME_RELEASE\n\t;;\n    arm*:riscos:*:*|arm*:RISCOS:*:*)\n\tGUESS=arm-unknown-riscos\n\t;;\n    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)\n\tGUESS=hppa1.1-hitachi-hiuxmpp\n\t;;\n    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n\tcase `(/bin/universe) 2>/dev/null` in\n\t    att) GUESS=pyramid-pyramid-sysv3 ;;\n\t    *)   GUESS=pyramid-pyramid-bsd   ;;\n\tesac\n\t;;\n    NILE*:*:*:dcosx)\n\tGUESS=pyramid-pyramid-svr4\n\t;;\n    DRS?6000:unix:4.0:6*)\n\tGUESS=sparc-icl-nx6\n\t;;\n    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)\n\tcase `/usr/bin/uname -p` in\n\t    sparc) GUESS=sparc-icl-nx7 ;;\n\tesac\n\t;;\n    s390x:SunOS:*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL\n\t;;\n    sun4H:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-hal-solaris2$SUN_REL\n\t;;\n    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-sun-solaris2$SUN_REL\n\t;;\n    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n\tGUESS=i386-pc-auroraux$UNAME_RELEASE\n\t;;\n    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n\tset_cc_for_build\n\tSUN_ARCH=i386\n\t# If there is a compiler, see if it is configured for 64-bit objects.\n\t# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.\n\t# This test works for both compilers.\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \\\n\t\t(CCOPTS=\"\" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \\\n\t\tgrep IS_64BIT_ARCH >/dev/null\n\t    then\n\t\tSUN_ARCH=x86_64\n\t    fi\n\tfi\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=$SUN_ARCH-pc-solaris2$SUN_REL\n\t;;\n    sun4*:SunOS:6*:*)\n\t# According to config.sub, this is the proper way to canonicalize\n\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n\t# it's likely to be more like Solaris than SunOS4.\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-sun-solaris3$SUN_REL\n\t;;\n    sun4*:SunOS:*:*)\n\tcase `/usr/bin/arch -k` in\n\t    Series*|S4*)\n\t\tUNAME_RELEASE=`uname -v`\n\t\t;;\n\tesac\n\t# Japanese Language versions have a version number like `4.1.3-JL'.\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/-/_/'`\n\tGUESS=sparc-sun-sunos$SUN_REL\n\t;;\n    sun3*:SunOS:*:*)\n\tGUESS=m68k-sun-sunos$UNAME_RELEASE\n\t;;\n    sun*:*:4.2BSD:*)\n\tUNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n\ttest \"x$UNAME_RELEASE\" = x && UNAME_RELEASE=3\n\tcase `/bin/arch` in\n\t    sun3)\n\t\tGUESS=m68k-sun-sunos$UNAME_RELEASE\n\t\t;;\n\t    sun4)\n\t\tGUESS=sparc-sun-sunos$UNAME_RELEASE\n\t\t;;\n\tesac\n\t;;\n    aushp:SunOS:*:*)\n\tGUESS=sparc-auspex-sunos$UNAME_RELEASE\n\t;;\n    # The situation for MiNT is a little confusing.  The machine name\n    # can be virtually everything (everything which is not\n    # \"atarist\" or \"atariste\" at least should have a processor\n    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n    # the system name \"TOS\" denotes a system which is actually not\n    # MiNT.  But MiNT is downward compatible to TOS, so this should\n    # be no problem.\n    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n\tGUESS=m68k-milan-mint$UNAME_RELEASE\n\t;;\n    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n\tGUESS=m68k-hades-mint$UNAME_RELEASE\n\t;;\n    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n\tGUESS=m68k-unknown-mint$UNAME_RELEASE\n\t;;\n    m68k:machten:*:*)\n\tGUESS=m68k-apple-machten$UNAME_RELEASE\n\t;;\n    powerpc:machten:*:*)\n\tGUESS=powerpc-apple-machten$UNAME_RELEASE\n\t;;\n    RISC*:Mach:*:*)\n\tGUESS=mips-dec-mach_bsd4.3\n\t;;\n    RISC*:ULTRIX:*:*)\n\tGUESS=mips-dec-ultrix$UNAME_RELEASE\n\t;;\n    VAX*:ULTRIX*:*:*)\n\tGUESS=vax-dec-ultrix$UNAME_RELEASE\n\t;;\n    2020:CLIX:*:* | 2430:CLIX:*:*)\n\tGUESS=clipper-intergraph-clix$UNAME_RELEASE\n\t;;\n    mips:*:*:UMIPS | mips:*:*:RISCos)\n\tset_cc_for_build\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n#ifdef __cplusplus\n#include <stdio.h>  /* for printf() prototype */\n\tint main (int argc, char *argv[]) {\n#else\n\tint main (argc, argv) int argc; char *argv[]; {\n#endif\n\t#if defined (host_mips) && defined (MIPSEB)\n\t#if defined (SYSTYPE_SYSV)\n\t  printf (\"mips-mips-riscos%ssysv\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#if defined (SYSTYPE_SVR4)\n\t  printf (\"mips-mips-riscos%ssvr4\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n\t  printf (\"mips-mips-riscos%sbsd\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#endif\n\t  exit (-1);\n\t}\nEOF\n\t$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" &&\n\t  dummyarg=`echo \"$UNAME_RELEASE\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` &&\n\t  SYSTEM_NAME=`\"$dummy\" \"$dummyarg\"` &&\n\t    { echo \"$SYSTEM_NAME\"; exit; }\n\tGUESS=mips-mips-riscos$UNAME_RELEASE\n\t;;\n    Motorola:PowerMAX_OS:*:*)\n\tGUESS=powerpc-motorola-powermax\n\t;;\n    Motorola:*:4.3:PL8-*)\n\tGUESS=powerpc-harris-powermax\n\t;;\n    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)\n\tGUESS=powerpc-harris-powermax\n\t;;\n    Night_Hawk:Power_UNIX:*:*)\n\tGUESS=powerpc-harris-powerunix\n\t;;\n    m88k:CX/UX:7*:*)\n\tGUESS=m88k-harris-cxux7\n\t;;\n    m88k:*:4*:R4*)\n\tGUESS=m88k-motorola-sysv4\n\t;;\n    m88k:*:3*:R3*)\n\tGUESS=m88k-motorola-sysv3\n\t;;\n    AViiON:dgux:*:*)\n\t# DG/UX returns AViiON for all architectures\n\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n\tif test \"$UNAME_PROCESSOR\" = mc88100 || test \"$UNAME_PROCESSOR\" = mc88110\n\tthen\n\t    if test \"$TARGET_BINARY_INTERFACE\"x = m88kdguxelfx || \\\n\t       test \"$TARGET_BINARY_INTERFACE\"x = x\n\t    then\n\t\tGUESS=m88k-dg-dgux$UNAME_RELEASE\n\t    else\n\t\tGUESS=m88k-dg-dguxbcs$UNAME_RELEASE\n\t    fi\n\telse\n\t    GUESS=i586-dg-dgux$UNAME_RELEASE\n\tfi\n\t;;\n    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n\tGUESS=m88k-dolphin-sysv3\n\t;;\n    M88*:*:R3*:*)\n\t# Delta 88k system running SVR3\n\tGUESS=m88k-motorola-sysv3\n\t;;\n    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n\tGUESS=m88k-tektronix-sysv3\n\t;;\n    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n\tGUESS=m68k-tektronix-bsd\n\t;;\n    *:IRIX*:*:*)\n\tIRIX_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/-/_/g'`\n\tGUESS=mips-sgi-irix$IRIX_REL\n\t;;\n    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n\tGUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id\n\t;;                    # Note that: echo \"'`uname -s`'\" gives 'AIX '\n    i*86:AIX:*:*)\n\tGUESS=i386-ibm-aix\n\t;;\n    ia64:AIX:*:*)\n\tif test -x /usr/bin/oslevel ; then\n\t\tIBM_REV=`/usr/bin/oslevel`\n\telse\n\t\tIBM_REV=$UNAME_VERSION.$UNAME_RELEASE\n\tfi\n\tGUESS=$UNAME_MACHINE-ibm-aix$IBM_REV\n\t;;\n    *:AIX:2:3)\n\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n\t\tset_cc_for_build\n\t\tsed 's/^\t\t//' << EOF > \"$dummy.c\"\n\t\t#include <sys/systemcfg.h>\n\n\t\tmain()\n\t\t\t{\n\t\t\tif (!__power_pc())\n\t\t\t\texit(1);\n\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n\t\t\texit(0);\n\t\t\t}\nEOF\n\t\tif $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" && SYSTEM_NAME=`\"$dummy\"`\n\t\tthen\n\t\t\tGUESS=$SYSTEM_NAME\n\t\telse\n\t\t\tGUESS=rs6000-ibm-aix3.2.5\n\t\tfi\n\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n\t\tGUESS=rs6000-ibm-aix3.2.4\n\telse\n\t\tGUESS=rs6000-ibm-aix3.2\n\tfi\n\t;;\n    *:AIX:*:[4567])\n\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`\n\tif /usr/sbin/lsattr -El \"$IBM_CPU_ID\" | grep ' POWER' >/dev/null 2>&1; then\n\t\tIBM_ARCH=rs6000\n\telse\n\t\tIBM_ARCH=powerpc\n\tfi\n\tif test -x /usr/bin/lslpp ; then\n\t\tIBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \\\n\t\t\t   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`\n\telse\n\t\tIBM_REV=$UNAME_VERSION.$UNAME_RELEASE\n\tfi\n\tGUESS=$IBM_ARCH-ibm-aix$IBM_REV\n\t;;\n    *:AIX:*:*)\n\tGUESS=rs6000-ibm-aix\n\t;;\n    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)\n\tGUESS=romp-ibm-bsd4.4\n\t;;\n    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and\n\tGUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to\n\t;;                                  # report: romp-ibm BSD 4.3\n    *:BOSX:*:*)\n\tGUESS=rs6000-bull-bosx\n\t;;\n    DPX/2?00:B.O.S.:*:*)\n\tGUESS=m68k-bull-sysv3\n\t;;\n    9000/[34]??:4.3bsd:1.*:*)\n\tGUESS=m68k-hp-bsd\n\t;;\n    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n\tGUESS=m68k-hp-bsd4.4\n\t;;\n    9000/[34678]??:HP-UX:*:*)\n\tHPUX_REV=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*.[0B]*//'`\n\tcase $UNAME_MACHINE in\n\t    9000/31?)            HP_ARCH=m68000 ;;\n\t    9000/[34]??)         HP_ARCH=m68k ;;\n\t    9000/[678][0-9][0-9])\n\t\tif test -x /usr/bin/getconf; then\n\t\t    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`\n\t\t    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`\n\t\t    case $sc_cpu_version in\n\t\t      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0\n\t\t      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1\n\t\t      532)                      # CPU_PA_RISC2_0\n\t\t\tcase $sc_kernel_bits in\n\t\t\t  32) HP_ARCH=hppa2.0n ;;\n\t\t\t  64) HP_ARCH=hppa2.0w ;;\n\t\t\t  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20\n\t\t\tesac ;;\n\t\t    esac\n\t\tfi\n\t\tif test \"$HP_ARCH\" = \"\"; then\n\t\t    set_cc_for_build\n\t\t    sed 's/^\t\t//' << EOF > \"$dummy.c\"\n\n\t\t#define _HPUX_SOURCE\n\t\t#include <stdlib.h>\n\t\t#include <unistd.h>\n\n\t\tint main ()\n\t\t{\n\t\t#if defined(_SC_KERNEL_BITS)\n\t\t    long bits = sysconf(_SC_KERNEL_BITS);\n\t\t#endif\n\t\t    long cpu  = sysconf (_SC_CPU_VERSION);\n\n\t\t    switch (cpu)\n\t\t\t{\n\t\t\tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n\t\t\tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n\t\t\tcase CPU_PA_RISC2_0:\n\t\t#if defined(_SC_KERNEL_BITS)\n\t\t\t    switch (bits)\n\t\t\t\t{\n\t\t\t\tcase 64: puts (\"hppa2.0w\"); break;\n\t\t\t\tcase 32: puts (\"hppa2.0n\"); break;\n\t\t\t\tdefault: puts (\"hppa2.0\"); break;\n\t\t\t\t} break;\n\t\t#else  /* !defined(_SC_KERNEL_BITS) */\n\t\t\t    puts (\"hppa2.0\"); break;\n\t\t#endif\n\t\t\tdefault: puts (\"hppa1.0\"); break;\n\t\t\t}\n\t\t    exit (0);\n\t\t}\nEOF\n\t\t    (CCOPTS=\"\" $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null) && HP_ARCH=`\"$dummy\"`\n\t\t    test -z \"$HP_ARCH\" && HP_ARCH=hppa\n\t\tfi ;;\n\tesac\n\tif test \"$HP_ARCH\" = hppa2.0w\n\tthen\n\t    set_cc_for_build\n\n\t    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating\n\t    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler\n\t    # generating 64-bit code.  GNU and HP use different nomenclature:\n\t    #\n\t    # $ CC_FOR_BUILD=cc ./config.guess\n\t    # => hppa2.0w-hp-hpux11.23\n\t    # $ CC_FOR_BUILD=\"cc +DA2.0w\" ./config.guess\n\t    # => hppa64-hp-hpux11.23\n\n\t    if echo __LP64__ | (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) |\n\t\tgrep -q __LP64__\n\t    then\n\t\tHP_ARCH=hppa2.0w\n\t    else\n\t\tHP_ARCH=hppa64\n\t    fi\n\tfi\n\tGUESS=$HP_ARCH-hp-hpux$HPUX_REV\n\t;;\n    ia64:HP-UX:*:*)\n\tHPUX_REV=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*.[0B]*//'`\n\tGUESS=ia64-hp-hpux$HPUX_REV\n\t;;\n    3050*:HI-UX:*:*)\n\tset_cc_for_build\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n\t#include <unistd.h>\n\tint\n\tmain ()\n\t{\n\t  long cpu = sysconf (_SC_CPU_VERSION);\n\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n\t     results, however.  */\n\t  if (CPU_IS_PA_RISC (cpu))\n\t    {\n\t      switch (cpu)\n\t\t{\n\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n\t\t}\n\t    }\n\t  else if (CPU_IS_HP_MC68K (cpu))\n\t    puts (\"m68k-hitachi-hiuxwe2\");\n\t  else puts (\"unknown-hitachi-hiuxwe2\");\n\t  exit (0);\n\t}\nEOF\n\t$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" && SYSTEM_NAME=`\"$dummy\"` &&\n\t\t{ echo \"$SYSTEM_NAME\"; exit; }\n\tGUESS=unknown-hitachi-hiuxwe2\n\t;;\n    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)\n\tGUESS=hppa1.1-hp-bsd\n\t;;\n    9000/8??:4.3bsd:*:*)\n\tGUESS=hppa1.0-hp-bsd\n\t;;\n    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)\n\tGUESS=hppa1.0-hp-mpeix\n\t;;\n    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)\n\tGUESS=hppa1.1-hp-osf\n\t;;\n    hp8??:OSF1:*:*)\n\tGUESS=hppa1.0-hp-osf\n\t;;\n    i*86:OSF1:*:*)\n\tif test -x /usr/sbin/sysversion ; then\n\t    GUESS=$UNAME_MACHINE-unknown-osf1mk\n\telse\n\t    GUESS=$UNAME_MACHINE-unknown-osf1\n\tfi\n\t;;\n    parisc*:Lites*:*:*)\n\tGUESS=hppa1.1-hp-lites\n\t;;\n    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n\tGUESS=c1-convex-bsd\n\t;;\n    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n\tif getsysinfo -f scalar_acc\n\tthen echo c32-convex-bsd\n\telse echo c2-convex-bsd\n\tfi\n\texit ;;\n    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n\tGUESS=c34-convex-bsd\n\t;;\n    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n\tGUESS=c38-convex-bsd\n\t;;\n    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n\tGUESS=c4-convex-bsd\n\t;;\n    CRAY*Y-MP:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=ymp-cray-unicos$CRAY_REL\n\t;;\n    CRAY*[A-Z]90:*:*:*)\n\techo \"$UNAME_MACHINE\"-cray-unicos\"$UNAME_RELEASE\" \\\n\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \\\n\t      -e 's/\\.[^.]*$/.X/'\n\texit ;;\n    CRAY*TS:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=t90-cray-unicos$CRAY_REL\n\t;;\n    CRAY*T3E:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=alphaev5-cray-unicosmk$CRAY_REL\n\t;;\n    CRAY*SV1:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=sv1-cray-unicos$CRAY_REL\n\t;;\n    *:UNICOS/mp:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=craynv-cray-unicosmp$CRAY_REL\n\t;;\n    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)\n\tFUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`\n\tFUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\\///'`\n\tFUJITSU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/ /_/'`\n\tGUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\n\t;;\n    5000:UNIX_System_V:4.*:*)\n\tFUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\\///'`\n\tFUJITSU_REL=`echo \"$UNAME_RELEASE\" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`\n\tGUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\n\t;;\n    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\\ Embedded/OS:*:*)\n\tGUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE\n\t;;\n    sparc*:BSD/OS:*:*)\n\tGUESS=sparc-unknown-bsdi$UNAME_RELEASE\n\t;;\n    *:BSD/OS:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE\n\t;;\n    arm:FreeBSD:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tset_cc_for_build\n\tif echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t    | grep -q __ARM_PCS_VFP\n\tthen\n\t    FREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\t    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi\n\telse\n\t    FREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\t    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf\n\tfi\n\t;;\n    *:FreeBSD:*:*)\n\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n\tcase $UNAME_PROCESSOR in\n\t    amd64)\n\t\tUNAME_PROCESSOR=x86_64 ;;\n\t    i386)\n\t\tUNAME_PROCESSOR=i586 ;;\n\tesac\n\tFREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL\n\t;;\n    i*:CYGWIN*:*)\n\tGUESS=$UNAME_MACHINE-pc-cygwin\n\t;;\n    *:MINGW64*:*)\n\tGUESS=$UNAME_MACHINE-pc-mingw64\n\t;;\n    *:MINGW*:*)\n\tGUESS=$UNAME_MACHINE-pc-mingw32\n\t;;\n    *:MSYS*:*)\n\tGUESS=$UNAME_MACHINE-pc-msys\n\t;;\n    i*:PW*:*)\n\tGUESS=$UNAME_MACHINE-pc-pw32\n\t;;\n    *:SerenityOS:*:*)\n        GUESS=$UNAME_MACHINE-pc-serenity\n        ;;\n    *:Interix*:*)\n\tcase $UNAME_MACHINE in\n\t    x86)\n\t\tGUESS=i586-pc-interix$UNAME_RELEASE\n\t\t;;\n\t    authenticamd | genuineintel | EM64T)\n\t\tGUESS=x86_64-unknown-interix$UNAME_RELEASE\n\t\t;;\n\t    IA64)\n\t\tGUESS=ia64-unknown-interix$UNAME_RELEASE\n\t\t;;\n\tesac ;;\n    i*:UWIN*:*)\n\tGUESS=$UNAME_MACHINE-pc-uwin\n\t;;\n    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n\tGUESS=x86_64-pc-cygwin\n\t;;\n    prep*:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=powerpcle-unknown-solaris2$SUN_REL\n\t;;\n    *:GNU:*:*)\n\t# the GNU system\n\tGNU_ARCH=`echo \"$UNAME_MACHINE\" | sed -e 's,[-/].*$,,'`\n\tGNU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's,/.*$,,'`\n\tGUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL\n\t;;\n    *:GNU/*:*:*)\n\t# other systems with GNU libc and userland\n\tGNU_SYS=`echo \"$UNAME_SYSTEM\" | sed 's,^[^/]*/,,' | tr \"[:upper:]\" \"[:lower:]\"`\n\tGNU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC\n\t;;\n    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)\n\tGUESS=\"$UNAME_MACHINE-pc-managarm-mlibc\"\n\t;;\n    *:[Mm]anagarm:*:*)\n\tGUESS=\"$UNAME_MACHINE-unknown-managarm-mlibc\"\n\t;;\n    *:Minix:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-minix\n\t;;\n    aarch64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    aarch64_be:Linux:*:*)\n\tUNAME_MACHINE=aarch64_be\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    alpha:Linux:*:*)\n\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' /proc/cpuinfo 2>/dev/null` in\n\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n\tesac\n\tobjdump --private-headers /bin/sh | grep -q ld.so.1\n\tif test \"$?\" = 0 ; then LIBC=gnulibc1 ; fi\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    arm*:Linux:*:*)\n\tset_cc_for_build\n\tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t    | grep -q __ARM_EABI__\n\tthen\n\t    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\telse\n\t    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t\t| grep -q __ARM_PCS_VFP\n\t    then\n\t\tGUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi\n\t    else\n\t\tGUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf\n\t    fi\n\tfi\n\t;;\n    avr32*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    cris:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-axis-linux-$LIBC\n\t;;\n    crisv32:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-axis-linux-$LIBC\n\t;;\n    e2k:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    frv:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    hexagon:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    i*86:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-pc-linux-$LIBC\n\t;;\n    ia64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    k1om:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    loongarch32:Linux:*:* | loongarch64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    m32r*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    m68*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    mips:Linux:*:* | mips64:Linux:*:*)\n\tset_cc_for_build\n\tIS_GLIBC=0\n\ttest x\"${LIBC}\" = xgnu && IS_GLIBC=1\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n\t#undef CPU\n\t#undef mips\n\t#undef mipsel\n\t#undef mips64\n\t#undef mips64el\n\t#if ${IS_GLIBC} && defined(_ABI64)\n\tLIBCABI=gnuabi64\n\t#else\n\t#if ${IS_GLIBC} && defined(_ABIN32)\n\tLIBCABI=gnuabin32\n\t#else\n\tLIBCABI=${LIBC}\n\t#endif\n\t#endif\n\n\t#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6\n\tCPU=mipsisa64r6\n\t#else\n\t#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6\n\tCPU=mipsisa32r6\n\t#else\n\t#if defined(__mips64)\n\tCPU=mips64\n\t#else\n\tCPU=mips\n\t#endif\n\t#endif\n\t#endif\n\n\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n\tMIPS_ENDIAN=el\n\t#else\n\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n\tMIPS_ENDIAN=\n\t#else\n\tMIPS_ENDIAN=\n\t#endif\n\t#endif\nEOF\n\tcc_set_vars=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^CPU\\|^MIPS_ENDIAN\\|^LIBCABI'`\n\teval \"$cc_set_vars\"\n\ttest \"x$CPU\" != x && { echo \"$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI\"; exit; }\n\t;;\n    mips64el:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    openrisc*:Linux:*:*)\n\tGUESS=or1k-unknown-linux-$LIBC\n\t;;\n    or32:Linux:*:* | or1k*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    padre:Linux:*:*)\n\tGUESS=sparc-unknown-linux-$LIBC\n\t;;\n    parisc64:Linux:*:* | hppa64:Linux:*:*)\n\tGUESS=hppa64-unknown-linux-$LIBC\n\t;;\n    parisc:Linux:*:* | hppa:Linux:*:*)\n\t# Look for CPU level\n\tcase `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in\n\t  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;\n\t  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;\n\t  *)    GUESS=hppa-unknown-linux-$LIBC ;;\n\tesac\n\t;;\n    ppc64:Linux:*:*)\n\tGUESS=powerpc64-unknown-linux-$LIBC\n\t;;\n    ppc:Linux:*:*)\n\tGUESS=powerpc-unknown-linux-$LIBC\n\t;;\n    ppc64le:Linux:*:*)\n\tGUESS=powerpc64le-unknown-linux-$LIBC\n\t;;\n    ppcle:Linux:*:*)\n\tGUESS=powerpcle-unknown-linux-$LIBC\n\t;;\n    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    s390:Linux:*:* | s390x:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-ibm-linux-$LIBC\n\t;;\n    sh64*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    sh*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    sparc:Linux:*:* | sparc64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    tile*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    vax:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-dec-linux-$LIBC\n\t;;\n    x86_64:Linux:*:*)\n\tset_cc_for_build\n\tCPU=$UNAME_MACHINE\n\tLIBCABI=$LIBC\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    ABI=64\n\t    sed 's/^\t    //' << EOF > \"$dummy.c\"\n\t    #ifdef __i386__\n\t    ABI=x86\n\t    #else\n\t    #ifdef __ILP32__\n\t    ABI=x32\n\t    #endif\n\t    #endif\nEOF\n\t    cc_set_abi=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`\n\t    eval \"$cc_set_abi\"\n\t    case $ABI in\n\t\tx86) CPU=i686 ;;\n\t\tx32) LIBCABI=${LIBC}x32 ;;\n\t    esac\n\tfi\n\tGUESS=$CPU-pc-linux-$LIBCABI\n\t;;\n    xtensa*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    i*86:DYNIX/ptx:4*:*)\n\t# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.\n\t# earlier versions are messed up and put the nodename in both\n\t# sysname and nodename.\n\tGUESS=i386-sequent-sysv4\n\t;;\n    i*86:UNIX_SV:4.2MP:2.*)\n\t# Unixware is an offshoot of SVR4, but it has its own version\n\t# number series starting with 2...\n\t# I am not positive that other SVR4 systems won't match this,\n\t# I just have to hope.  -- rms.\n\t# Use sysv4.2uw... so that sysv4* matches it.\n\tGUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION\n\t;;\n    i*86:OS/2:*:*)\n\t# If we were able to find `uname', then EMX Unix compatibility\n\t# is probably installed.\n\tGUESS=$UNAME_MACHINE-pc-os2-emx\n\t;;\n    i*86:XTS-300:*:STOP)\n\tGUESS=$UNAME_MACHINE-unknown-stop\n\t;;\n    i*86:atheos:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-atheos\n\t;;\n    i*86:syllable:*:*)\n\tGUESS=$UNAME_MACHINE-pc-syllable\n\t;;\n    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)\n\tGUESS=i386-unknown-lynxos$UNAME_RELEASE\n\t;;\n    i*86:*DOS:*:*)\n\tGUESS=$UNAME_MACHINE-pc-msdosdjgpp\n\t;;\n    i*86:*:4.*:*)\n\tUNAME_REL=`echo \"$UNAME_RELEASE\" | sed 's/\\/MP$//'`\n\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n\t\tGUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL\n\telse\n\t\tGUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL\n\tfi\n\t;;\n    i*86:*:5:[678]*)\n\t# UnixWare 7.x, OpenUNIX and OpenServer 6.\n\tcase `/bin/uname -X | grep \"^Machine\"` in\n\t    *486*)\t     UNAME_MACHINE=i486 ;;\n\t    *Pentium)\t     UNAME_MACHINE=i586 ;;\n\t    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;\n\tesac\n\tGUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}\n\t;;\n    i*86:*:3.2:*)\n\tif test -f /usr/options/cb.name; then\n\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n\t\tGUESS=$UNAME_MACHINE-pc-isc$UNAME_REL\n\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n\t\tUNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`\n\t\t(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486\n\t\t(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i586\n\t\t(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i686\n\t\t(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i686\n\t\tGUESS=$UNAME_MACHINE-pc-sco$UNAME_REL\n\telse\n\t\tGUESS=$UNAME_MACHINE-pc-sysv32\n\tfi\n\t;;\n    pc:*:*:*)\n\t# Left here for compatibility:\n\t# uname -m prints for DJGPP always 'pc', but it prints nothing about\n\t# the processor, so we play safe by assuming i586.\n\t# Note: whatever this is, it MUST be the same as what config.sub\n\t# prints for the \"djgpp\" host, or else GDB configure will decide that\n\t# this is a cross-build.\n\tGUESS=i586-pc-msdosdjgpp\n\t;;\n    Intel:Mach:3*:*)\n\tGUESS=i386-pc-mach3\n\t;;\n    paragon:*:*:*)\n\tGUESS=i860-intel-osf1\n\t;;\n    i860:*:4.*:*) # i860-SVR4\n\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n\t  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4\n\telse # Add other i860-SVR4 vendors below as they are discovered.\n\t  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4\n\tfi\n\t;;\n    mini*:CTIX:SYS*5:*)\n\t# \"miniframe\"\n\tGUESS=m68010-convergent-sysv\n\t;;\n    mc68k:UNIX:SYSTEM5:3.51m)\n\tGUESS=m68k-convergent-sysv\n\t;;\n    M680?0:D-NIX:5.3:*)\n\tGUESS=m68k-diab-dnix\n\t;;\n    M68*:*:R3V[5678]*:*)\n\ttest -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;\n    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)\n\tOS_REL=''\n\ttest -r /etc/.relid \\\n\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t  && { echo i486-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n\t  && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; } ;;\n    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t  && { echo i486-ncr-sysv4; exit; } ;;\n    NCR*:*:4.2:* | MPRAS*:*:4.2:*)\n\tOS_REL='.3'\n\ttest -r /etc/.relid \\\n\t    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t    && { echo i486-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n\t    && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \\\n\t    && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; } ;;\n    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)\n\tGUESS=m68k-unknown-lynxos$UNAME_RELEASE\n\t;;\n    mc68030:UNIX_System_V:4.*:*)\n\tGUESS=m68k-atari-sysv4\n\t;;\n    TSUNAMI:LynxOS:2.*:*)\n\tGUESS=sparc-unknown-lynxos$UNAME_RELEASE\n\t;;\n    rs6000:LynxOS:2.*:*)\n\tGUESS=rs6000-unknown-lynxos$UNAME_RELEASE\n\t;;\n    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)\n\tGUESS=powerpc-unknown-lynxos$UNAME_RELEASE\n\t;;\n    SM[BE]S:UNIX_SV:*:*)\n\tGUESS=mips-dde-sysv$UNAME_RELEASE\n\t;;\n    RM*:ReliantUNIX-*:*:*)\n\tGUESS=mips-sni-sysv4\n\t;;\n    RM*:SINIX-*:*:*)\n\tGUESS=mips-sni-sysv4\n\t;;\n    *:SINIX-*:*:*)\n\tif uname -p 2>/dev/null >/dev/null ; then\n\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n\t\tGUESS=$UNAME_MACHINE-sni-sysv4\n\telse\n\t\tGUESS=ns32k-sni-sysv\n\tfi\n\t;;\n    PENTIUM:*:4.0*:*)\t# Unisys `ClearPath HMP IX 4000' SVR4/MP effort\n\t\t\t# says <Richard.M.Bartel@ccMail.Census.GOV>\n\tGUESS=i586-unisys-sysv4\n\t;;\n    *:UNIX_System_V:4*:FTX*)\n\t# From Gerald Hewes <hewes@openmarket.com>.\n\t# How about differentiating between stratus architectures? -djm\n\tGUESS=hppa1.1-stratus-sysv4\n\t;;\n    *:*:*:FTX*)\n\t# From seanf@swdc.stratus.com.\n\tGUESS=i860-stratus-sysv4\n\t;;\n    i*86:VOS:*:*)\n\t# From Paul.Green@stratus.com.\n\tGUESS=$UNAME_MACHINE-stratus-vos\n\t;;\n    *:VOS:*:*)\n\t# From Paul.Green@stratus.com.\n\tGUESS=hppa1.1-stratus-vos\n\t;;\n    mc68*:A/UX:*:*)\n\tGUESS=m68k-apple-aux$UNAME_RELEASE\n\t;;\n    news*:NEWS-OS:6*:*)\n\tGUESS=mips-sony-newsos6\n\t;;\n    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n\tif test -d /usr/nec; then\n\t\tGUESS=mips-nec-sysv$UNAME_RELEASE\n\telse\n\t\tGUESS=mips-unknown-sysv$UNAME_RELEASE\n\tfi\n\t;;\n    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n\tGUESS=powerpc-be-beos\n\t;;\n    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n\tGUESS=powerpc-apple-beos\n\t;;\n    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n\tGUESS=i586-pc-beos\n\t;;\n    BePC:Haiku:*:*)\t# Haiku running on Intel PC compatible.\n\tGUESS=i586-pc-haiku\n\t;;\n    ppc:Haiku:*:*)\t# Haiku running on Apple PowerPC\n\tGUESS=powerpc-apple-haiku\n\t;;\n    *:Haiku:*:*)\t# Haiku modern gcc (not bound by BeOS compat)\n\tGUESS=$UNAME_MACHINE-unknown-haiku\n\t;;\n    SX-4:SUPER-UX:*:*)\n\tGUESS=sx4-nec-superux$UNAME_RELEASE\n\t;;\n    SX-5:SUPER-UX:*:*)\n\tGUESS=sx5-nec-superux$UNAME_RELEASE\n\t;;\n    SX-6:SUPER-UX:*:*)\n\tGUESS=sx6-nec-superux$UNAME_RELEASE\n\t;;\n    SX-7:SUPER-UX:*:*)\n\tGUESS=sx7-nec-superux$UNAME_RELEASE\n\t;;\n    SX-8:SUPER-UX:*:*)\n\tGUESS=sx8-nec-superux$UNAME_RELEASE\n\t;;\n    SX-8R:SUPER-UX:*:*)\n\tGUESS=sx8r-nec-superux$UNAME_RELEASE\n\t;;\n    SX-ACE:SUPER-UX:*:*)\n\tGUESS=sxace-nec-superux$UNAME_RELEASE\n\t;;\n    Power*:Rhapsody:*:*)\n\tGUESS=powerpc-apple-rhapsody$UNAME_RELEASE\n\t;;\n    *:Rhapsody:*:*)\n\tGUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE\n\t;;\n    arm64:Darwin:*:*)\n\tGUESS=aarch64-apple-darwin$UNAME_RELEASE\n\t;;\n    *:Darwin:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tcase $UNAME_PROCESSOR in\n\t    unknown) UNAME_PROCESSOR=powerpc ;;\n\tesac\n\tif command -v xcode-select > /dev/null 2> /dev/null && \\\n\t\t! xcode-select --print-path > /dev/null 2> /dev/null ; then\n\t    # Avoid executing cc if there is no toolchain installed as\n\t    # cc will be a stub that puts up a graphical alert\n\t    # prompting the user to install developer tools.\n\t    CC_FOR_BUILD=no_compiler_found\n\telse\n\t    set_cc_for_build\n\tfi\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \\\n\t\t   (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) | \\\n\t\t   grep IS_64BIT_ARCH >/dev/null\n\t    then\n\t\tcase $UNAME_PROCESSOR in\n\t\t    i386) UNAME_PROCESSOR=x86_64 ;;\n\t\t    powerpc) UNAME_PROCESSOR=powerpc64 ;;\n\t\tesac\n\t    fi\n\t    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc\n\t    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \\\n\t\t   (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) | \\\n\t\t   grep IS_PPC >/dev/null\n\t    then\n\t\tUNAME_PROCESSOR=powerpc\n\t    fi\n\telif test \"$UNAME_PROCESSOR\" = i386 ; then\n\t    # uname -m returns i386 or x86_64\n\t    UNAME_PROCESSOR=$UNAME_MACHINE\n\tfi\n\tGUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE\n\t;;\n    *:procnto*:*:* | *:QNX:[0123456789]*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tif test \"$UNAME_PROCESSOR\" = x86; then\n\t\tUNAME_PROCESSOR=i386\n\t\tUNAME_MACHINE=pc\n\tfi\n\tGUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE\n\t;;\n    *:QNX:*:4*)\n\tGUESS=i386-pc-qnx\n\t;;\n    NEO-*:NONSTOP_KERNEL:*:*)\n\tGUESS=neo-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSE-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nse-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSR-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsr-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSV-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsv-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSX-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsx-tandem-nsk$UNAME_RELEASE\n\t;;\n    *:NonStop-UX:*:*)\n\tGUESS=mips-compaq-nonstopux\n\t;;\n    BS2000:POSIX*:*:*)\n\tGUESS=bs2000-siemens-sysv\n\t;;\n    DS/*:UNIX_System_V:*:*)\n\tGUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE\n\t;;\n    *:Plan9:*:*)\n\t# \"uname -m\" is not consistent, so use $cputype instead. 386\n\t# is converted to i386 for consistency with other x86\n\t# operating systems.\n\tif test \"${cputype-}\" = 386; then\n\t    UNAME_MACHINE=i386\n\telif test \"x${cputype-}\" != x; then\n\t    UNAME_MACHINE=$cputype\n\tfi\n\tGUESS=$UNAME_MACHINE-unknown-plan9\n\t;;\n    *:TOPS-10:*:*)\n\tGUESS=pdp10-unknown-tops10\n\t;;\n    *:TENEX:*:*)\n\tGUESS=pdp10-unknown-tenex\n\t;;\n    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)\n\tGUESS=pdp10-dec-tops20\n\t;;\n    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)\n\tGUESS=pdp10-xkl-tops20\n\t;;\n    *:TOPS-20:*:*)\n\tGUESS=pdp10-unknown-tops20\n\t;;\n    *:ITS:*:*)\n\tGUESS=pdp10-unknown-its\n\t;;\n    SEI:*:*:SEIUX)\n\tGUESS=mips-sei-seiux$UNAME_RELEASE\n\t;;\n    *:DragonFly:*:*)\n\tDRAGONFLY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL\n\t;;\n    *:*VMS:*:*)\n\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n\tcase $UNAME_MACHINE in\n\t    A*) GUESS=alpha-dec-vms ;;\n\t    I*) GUESS=ia64-dec-vms ;;\n\t    V*) GUESS=vax-dec-vms ;;\n\tesac ;;\n    *:XENIX:*:SysV)\n\tGUESS=i386-pc-xenix\n\t;;\n    i*86:skyos:*:*)\n\tSKYOS_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/ .*$//'`\n\tGUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL\n\t;;\n    i*86:rdos:*:*)\n\tGUESS=$UNAME_MACHINE-pc-rdos\n\t;;\n    i*86:Fiwix:*:*)\n\tGUESS=$UNAME_MACHINE-pc-fiwix\n\t;;\n    *:AROS:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-aros\n\t;;\n    x86_64:VMkernel:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-esx\n\t;;\n    amd64:Isilon\\ OneFS:*:*)\n\tGUESS=x86_64-unknown-onefs\n\t;;\n    *:Unleashed:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE\n\t;;\nesac\n\n# Do we have a guess based on uname results?\nif test \"x$GUESS\" != x; then\n    echo \"$GUESS\"\n    exit\nfi\n\n# No uname command or uname output not recognized.\nset_cc_for_build\ncat > \"$dummy.c\" <<EOF\n#ifdef _SEQUENT_\n#include <sys/types.h>\n#include <sys/utsname.h>\n#endif\n#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)\n#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)\n#include <signal.h>\n#if defined(_SIZE_T_) || defined(SIGLOST)\n#include <sys/utsname.h>\n#endif\n#endif\n#endif\nmain ()\n{\n#if defined (sony)\n#if defined (MIPSEB)\n  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n     I don't know....  */\n  printf (\"mips-sony-bsd\\n\"); exit (0);\n#else\n#include <sys/param.h>\n  printf (\"m68k-sony-newsos%s\\n\",\n#ifdef NEWSOS4\n  \"4\"\n#else\n  \"\"\n#endif\n  ); exit (0);\n#endif\n#endif\n\n#if defined (NeXT)\n#if !defined (__ARCHITECTURE__)\n#define __ARCHITECTURE__ \"m68k\"\n#endif\n  int version;\n  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n  if (version < 4)\n    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n  else\n    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n  exit (0);\n#endif\n\n#if defined (MULTIMAX) || defined (n16)\n#if defined (UMAXV)\n  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n#else\n#if defined (CMU)\n  printf (\"ns32k-encore-mach\\n\"); exit (0);\n#else\n  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n#endif\n#endif\n#endif\n\n#if defined (__386BSD__)\n  printf (\"i386-pc-bsd\\n\"); exit (0);\n#endif\n\n#if defined (sequent)\n#if defined (i386)\n  printf (\"i386-sequent-dynix\\n\"); exit (0);\n#endif\n#if defined (ns32000)\n  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n#endif\n#endif\n\n#if defined (_SEQUENT_)\n  struct utsname un;\n\n  uname(&un);\n  if (strncmp(un.version, \"V2\", 2) == 0) {\n    printf (\"i386-sequent-ptx2\\n\"); exit (0);\n  }\n  if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n    printf (\"i386-sequent-ptx1\\n\"); exit (0);\n  }\n  printf (\"i386-sequent-ptx\\n\"); exit (0);\n#endif\n\n#if defined (vax)\n#if !defined (ultrix)\n#include <sys/param.h>\n#if defined (BSD)\n#if BSD == 43\n  printf (\"vax-dec-bsd4.3\\n\"); exit (0);\n#else\n#if BSD == 199006\n  printf (\"vax-dec-bsd4.3reno\\n\"); exit (0);\n#else\n  printf (\"vax-dec-bsd\\n\"); exit (0);\n#endif\n#endif\n#else\n  printf (\"vax-dec-bsd\\n\"); exit (0);\n#endif\n#else\n#if defined(_SIZE_T_) || defined(SIGLOST)\n  struct utsname un;\n  uname (&un);\n  printf (\"vax-dec-ultrix%s\\n\", un.release); exit (0);\n#else\n  printf (\"vax-dec-ultrix\\n\"); exit (0);\n#endif\n#endif\n#endif\n#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)\n#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)\n#if defined(_SIZE_T_) || defined(SIGLOST)\n  struct utsname *un;\n  uname (&un);\n  printf (\"mips-dec-ultrix%s\\n\", un.release); exit (0);\n#else\n  printf (\"mips-dec-ultrix\\n\"); exit (0);\n#endif\n#endif\n#endif\n\n#if defined (alliant) && defined (i860)\n  printf (\"i860-alliant-bsd\\n\"); exit (0);\n#endif\n\n  exit (1);\n}\nEOF\n\n$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null && SYSTEM_NAME=`\"$dummy\"` &&\n\t{ echo \"$SYSTEM_NAME\"; exit; }\n\n# Apollos put the system type in the environment.\ntest -d /usr/apollo && { echo \"$ISP-apollo-$SYSTYPE\"; exit; }\n\necho \"$0: unable to guess system type\" >&2\n\ncase $UNAME_MACHINE:$UNAME_SYSTEM in\n    mips:Linux | mips64:Linux)\n\t# If we got here on MIPS GNU/Linux, output extra information.\n\tcat >&2 <<EOF\n\nNOTE: MIPS GNU/Linux systems require a C compiler to fully recognize\nthe system type. Please install a C compiler and try again.\nEOF\n\t;;\nesac\n\ncat >&2 <<EOF\n\nThis script (version $timestamp), has failed to recognize the\noperating system you are using. If your script is old, overwrite *all*\ncopies of config.guess and config.sub with the latest versions from:\n\n  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess\nand\n  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub\nEOF\n\nour_year=`echo $timestamp | sed 's,-.*,,'`\nthisyear=`date +%Y`\n# shellcheck disable=SC2003\nscript_age=`expr \"$thisyear\" - \"$our_year\"`\nif test \"$script_age\" -lt 3 ; then\n   cat >&2 <<EOF\n\nIf $0 has already been updated, send the following data and any\ninformation you think might be pertinent to config-patches@gnu.org to\nprovide the necessary information to handle your system.\n\nconfig.guess timestamp = $timestamp\n\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`\n\nhostinfo               = `(hostinfo) 2>/dev/null`\n/bin/universe          = `(/bin/universe) 2>/dev/null`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`\n/bin/arch              = `(/bin/arch) 2>/dev/null`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`\n\nUNAME_MACHINE = \"$UNAME_MACHINE\"\nUNAME_RELEASE = \"$UNAME_RELEASE\"\nUNAME_SYSTEM  = \"$UNAME_SYSTEM\"\nUNAME_VERSION = \"$UNAME_VERSION\"\nEOF\nfi\n\nexit 1\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"timestamp='\"\n# time-stamp-format: \"%:y-%02m-%02d\"\n# time-stamp-end: \"'\"\n# End:\n"
        },
        {
          "name": "config.sub",
          "type": "blob",
          "size": 34.978515625,
          "content": "#! /bin/sh\n# Configuration validation subroutine script.\n#   Copyright 1992-2023 Free Software Foundation, Inc.\n\n# shellcheck disable=SC2006,SC2268 # see below for rationale\n\ntimestamp='2023-01-21'\n\n# This file is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that\n# program.  This Exception is an additional permission under section 7\n# of the GNU General Public License, version 3 (\"GPLv3\").\n\n\n# Please send patches to <config-patches@gnu.org>.\n#\n# Configuration subroutine to validate and canonicalize a configuration type.\n# Supply the specified configuration type as an argument.\n# If it is invalid, we print an error message on stderr and exit with code 1.\n# Otherwise, we print the canonical config type on stdout and succeed.\n\n# You can get the latest version of this script from:\n# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub\n\n# This file is supposed to be the same for all GNU packages\n# and recognize all the CPU types, system types and aliases\n# that are meaningful with *any* GNU software.\n# Each package is responsible for reporting which valid configurations\n# it does not support.  The user should be able to distinguish\n# a failure to support a valid configuration from a meaningless\n# configuration.\n\n# The goal of this file is to map all the various variations of a given\n# machine specification into a single specification in the form:\n#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n# or in some cases, the newer four-part form:\n#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n# It is wrong to echo any other type of specification.\n\n# The \"shellcheck disable\" line above the timestamp inhibits complaints\n# about features and limitations of the classic Bourne shell that were\n# superseded or lifted in POSIX.  However, this script identifies a wide\n# variety of pre-POSIX systems that do not have POSIX shells at all, and\n# even some reasonably current systems (Solaris 10 as case-in-point) still\n# have a pre-POSIX /bin/sh.\n\nme=`echo \"$0\" | sed -e 's,.*/,,'`\n\nusage=\"\\\nUsage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS\n\nCanonicalize a configuration name.\n\nOptions:\n  -h, --help         print this help, then exit\n  -t, --time-stamp   print date of last modification, then exit\n  -v, --version      print version number, then exit\n\nReport bugs and patches to <config-patches@gnu.org>.\"\n\nversion=\"\\\nGNU config.sub ($timestamp)\n\nCopyright 1992-2023 Free Software Foundation, Inc.\n\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n\nhelp=\"\nTry \\`$me --help' for more information.\"\n\n# Parse command line\nwhile test $# -gt 0 ; do\n  case $1 in\n    --time-stamp | --time* | -t )\n       echo \"$timestamp\" ; exit ;;\n    --version | -v )\n       echo \"$version\" ; exit ;;\n    --help | --h* | -h )\n       echo \"$usage\"; exit ;;\n    -- )     # Stop option processing\n       shift; break ;;\n    - )\t# Use stdin as input.\n       break ;;\n    -* )\n       echo \"$me: invalid option $1$help\" >&2\n       exit 1 ;;\n\n    *local*)\n       # First pass through any local machine types.\n       echo \"$1\"\n       exit ;;\n\n    * )\n       break ;;\n  esac\ndone\n\ncase $# in\n 0) echo \"$me: missing argument$help\" >&2\n    exit 1;;\n 1) ;;\n *) echo \"$me: too many arguments$help\" >&2\n    exit 1;;\nesac\n\n# Split fields of configuration type\n# shellcheck disable=SC2162\nsaved_IFS=$IFS\nIFS=\"-\" read field1 field2 field3 field4 <<EOF\n$1\nEOF\nIFS=$saved_IFS\n\n# Separate into logical components for further validation\ncase $1 in\n\t*-*-*-*-*)\n\t\techo Invalid configuration \\`\"$1\"\\': more than four components >&2\n\t\texit 1\n\t\t;;\n\t*-*-*-*)\n\t\tbasic_machine=$field1-$field2\n\t\tbasic_os=$field3-$field4\n\t\t;;\n\t*-*-*)\n\t\t# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two\n\t\t# parts\n\t\tmaybe_os=$field2-$field3\n\t\tcase $maybe_os in\n\t\t\tnto-qnx* | linux-* | uclinux-uclibc* \\\n\t\t\t| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \\\n\t\t\t| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \\\n\t\t\t| storm-chaos* | os2-emx* | rtmk-nova* | managarm-*)\n\t\t\t\tbasic_machine=$field1\n\t\t\t\tbasic_os=$maybe_os\n\t\t\t\t;;\n\t\t\tandroid-linux)\n\t\t\t\tbasic_machine=$field1-unknown\n\t\t\t\tbasic_os=linux-android\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tbasic_machine=$field1-$field2\n\t\t\t\tbasic_os=$field3\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-*)\n\t\t# A lone config we happen to match not fitting any pattern\n\t\tcase $field1-$field2 in\n\t\t\tdecstation-3100)\n\t\t\t\tbasic_machine=mips-dec\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\t*-*)\n\t\t\t\t# Second component is usually, but not always the OS\n\t\t\t\tcase $field2 in\n\t\t\t\t\t# Prevent following clause from handling this valid os\n\t\t\t\t\tsun*os*)\n\t\t\t\t\t\tbasic_machine=$field1\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\t\tzephyr*)\n\t\t\t\t\t\tbasic_machine=$field1-unknown\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\t\t# Manufacturers\n\t\t\t\t\tdec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \\\n\t\t\t\t\t| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \\\n\t\t\t\t\t| unicom* | ibm* | next | hp | isi* | apollo | altos* \\\n\t\t\t\t\t| convergent* | ncr* | news | 32* | 3600* | 3100* \\\n\t\t\t\t\t| hitachi* | c[123]* | convex* | sun | crds | omron* | dg \\\n\t\t\t\t\t| ultra | tti* | harris | dolphin | highlevel | gould \\\n\t\t\t\t\t| cbm | ns | masscomp | apple | axis | knuth | cray \\\n\t\t\t\t\t| microblaze* | sim | cisco \\\n\t\t\t\t\t| oki | wec | wrs | winbond)\n\t\t\t\t\t\tbasic_machine=$field1-$field2\n\t\t\t\t\t\tbasic_os=\n\t\t\t\t\t\t;;\n\t\t\t\t\t*)\n\t\t\t\t\t\tbasic_machine=$field1\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t*)\n\t\t# Convert single-component short-hands not valid as part of\n\t\t# multi-component configurations.\n\t\tcase $field1 in\n\t\t\t386bsd)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\ta29khif)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tadobe68k)\n\t\t\t\tbasic_machine=m68010-adobe\n\t\t\t\tbasic_os=scout\n\t\t\t\t;;\n\t\t\talliant)\n\t\t\t\tbasic_machine=fx80-alliant\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\taltos | altos3068)\n\t\t\t\tbasic_machine=m68k-altos\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tam29k)\n\t\t\t\tbasic_machine=a29k-none\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tamdahl)\n\t\t\t\tbasic_machine=580-amdahl\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tamiga)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tamigaos | amigados)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=amigaos\n\t\t\t\t;;\n\t\t\tamigaunix | amix)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tapollo68)\n\t\t\t\tbasic_machine=m68k-apollo\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tapollo68bsd)\n\t\t\t\tbasic_machine=m68k-apollo\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\taros)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=aros\n\t\t\t\t;;\n\t\t\taux)\n\t\t\t\tbasic_machine=m68k-apple\n\t\t\t\tbasic_os=aux\n\t\t\t\t;;\n\t\t\tbalance)\n\t\t\t\tbasic_machine=ns32k-sequent\n\t\t\t\tbasic_os=dynix\n\t\t\t\t;;\n\t\t\tblackfin)\n\t\t\t\tbasic_machine=bfin-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tcegcc)\n\t\t\t\tbasic_machine=arm-unknown\n\t\t\t\tbasic_os=cegcc\n\t\t\t\t;;\n\t\t\tconvex-c1)\n\t\t\t\tbasic_machine=c1-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c2)\n\t\t\t\tbasic_machine=c2-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c32)\n\t\t\t\tbasic_machine=c32-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c34)\n\t\t\t\tbasic_machine=c34-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tconvex-c38)\n\t\t\t\tbasic_machine=c38-convex\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tcray)\n\t\t\t\tbasic_machine=j90-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tcrds | unos)\n\t\t\t\tbasic_machine=m68k-crds\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tda30)\n\t\t\t\tbasic_machine=m68k-da30\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdecstation | pmax | pmin | dec3100 | decstatn)\n\t\t\t\tbasic_machine=mips-dec\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdelta88)\n\t\t\t\tbasic_machine=m88k-motorola\n\t\t\t\tbasic_os=sysv3\n\t\t\t\t;;\n\t\t\tdicos)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=dicos\n\t\t\t\t;;\n\t\t\tdjgpp)\n\t\t\t\tbasic_machine=i586-pc\n\t\t\t\tbasic_os=msdosdjgpp\n\t\t\t\t;;\n\t\t\tebmon29k)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=ebmon\n\t\t\t\t;;\n\t\t\tes1800 | OSE68k | ose68k | ose | OSE)\n\t\t\t\tbasic_machine=m68k-ericsson\n\t\t\t\tbasic_os=ose\n\t\t\t\t;;\n\t\t\tgmicro)\n\t\t\t\tbasic_machine=tron-gmicro\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tgo32)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=go32\n\t\t\t\t;;\n\t\t\th8300hms)\n\t\t\t\tbasic_machine=h8300-hitachi\n\t\t\t\tbasic_os=hms\n\t\t\t\t;;\n\t\t\th8300xray)\n\t\t\t\tbasic_machine=h8300-hitachi\n\t\t\t\tbasic_os=xray\n\t\t\t\t;;\n\t\t\th8500hms)\n\t\t\t\tbasic_machine=h8500-hitachi\n\t\t\t\tbasic_os=hms\n\t\t\t\t;;\n\t\t\tharris)\n\t\t\t\tbasic_machine=m88k-harris\n\t\t\t\tbasic_os=sysv3\n\t\t\t\t;;\n\t\t\thp300 | hp300hpux)\n\t\t\t\tbasic_machine=m68k-hp\n\t\t\t\tbasic_os=hpux\n\t\t\t\t;;\n\t\t\thp300bsd)\n\t\t\t\tbasic_machine=m68k-hp\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\thppaosf)\n\t\t\t\tbasic_machine=hppa1.1-hp\n\t\t\t\tbasic_os=osf\n\t\t\t\t;;\n\t\t\thppro)\n\t\t\t\tbasic_machine=hppa1.1-hp\n\t\t\t\tbasic_os=proelf\n\t\t\t\t;;\n\t\t\ti386mach)\n\t\t\t\tbasic_machine=i386-mach\n\t\t\t\tbasic_os=mach\n\t\t\t\t;;\n\t\t\tisi68 | isi)\n\t\t\t\tbasic_machine=m68k-isi\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tm68knommu)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tmagnum | m3230)\n\t\t\t\tbasic_machine=mips-mips\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tmerlin)\n\t\t\t\tbasic_machine=ns32k-utek\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tmingw64)\n\t\t\t\tbasic_machine=x86_64-pc\n\t\t\t\tbasic_os=mingw64\n\t\t\t\t;;\n\t\t\tmingw32)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=mingw32\n\t\t\t\t;;\n\t\t\tmingw32ce)\n\t\t\t\tbasic_machine=arm-unknown\n\t\t\t\tbasic_os=mingw32ce\n\t\t\t\t;;\n\t\t\tmonitor)\n\t\t\t\tbasic_machine=m68k-rom68k\n\t\t\t\tbasic_os=coff\n\t\t\t\t;;\n\t\t\tmorphos)\n\t\t\t\tbasic_machine=powerpc-unknown\n\t\t\t\tbasic_os=morphos\n\t\t\t\t;;\n\t\t\tmoxiebox)\n\t\t\t\tbasic_machine=moxie-unknown\n\t\t\t\tbasic_os=moxiebox\n\t\t\t\t;;\n\t\t\tmsdos)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=msdos\n\t\t\t\t;;\n\t\t\tmsys)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=msys\n\t\t\t\t;;\n\t\t\tmvs)\n\t\t\t\tbasic_machine=i370-ibm\n\t\t\t\tbasic_os=mvs\n\t\t\t\t;;\n\t\t\tnacl)\n\t\t\t\tbasic_machine=le32-unknown\n\t\t\t\tbasic_os=nacl\n\t\t\t\t;;\n\t\t\tncr3000)\n\t\t\t\tbasic_machine=i486-ncr\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tnetbsd386)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=netbsd\n\t\t\t\t;;\n\t\t\tnetwinder)\n\t\t\t\tbasic_machine=armv4l-rebel\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tnews | news700 | news800 | news900)\n\t\t\t\tbasic_machine=m68k-sony\n\t\t\t\tbasic_os=newsos\n\t\t\t\t;;\n\t\t\tnews1000)\n\t\t\t\tbasic_machine=m68030-sony\n\t\t\t\tbasic_os=newsos\n\t\t\t\t;;\n\t\t\tnecv70)\n\t\t\t\tbasic_machine=v70-nec\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tnh3000)\n\t\t\t\tbasic_machine=m68k-harris\n\t\t\t\tbasic_os=cxux\n\t\t\t\t;;\n\t\t\tnh[45]000)\n\t\t\t\tbasic_machine=m88k-harris\n\t\t\t\tbasic_os=cxux\n\t\t\t\t;;\n\t\t\tnindy960)\n\t\t\t\tbasic_machine=i960-intel\n\t\t\t\tbasic_os=nindy\n\t\t\t\t;;\n\t\t\tmon960)\n\t\t\t\tbasic_machine=i960-intel\n\t\t\t\tbasic_os=mon960\n\t\t\t\t;;\n\t\t\tnonstopux)\n\t\t\t\tbasic_machine=mips-compaq\n\t\t\t\tbasic_os=nonstopux\n\t\t\t\t;;\n\t\t\tos400)\n\t\t\t\tbasic_machine=powerpc-ibm\n\t\t\t\tbasic_os=os400\n\t\t\t\t;;\n\t\t\tOSE68000 | ose68000)\n\t\t\t\tbasic_machine=m68000-ericsson\n\t\t\t\tbasic_os=ose\n\t\t\t\t;;\n\t\t\tos68k)\n\t\t\t\tbasic_machine=m68k-none\n\t\t\t\tbasic_os=os68k\n\t\t\t\t;;\n\t\t\tparagon)\n\t\t\t\tbasic_machine=i860-intel\n\t\t\t\tbasic_os=osf\n\t\t\t\t;;\n\t\t\tparisc)\n\t\t\t\tbasic_machine=hppa-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tpsp)\n\t\t\t\tbasic_machine=mipsallegrexel-sony\n\t\t\t\tbasic_os=psp\n\t\t\t\t;;\n\t\t\tpw32)\n\t\t\t\tbasic_machine=i586-unknown\n\t\t\t\tbasic_os=pw32\n\t\t\t\t;;\n\t\t\trdos | rdos64)\n\t\t\t\tbasic_machine=x86_64-pc\n\t\t\t\tbasic_os=rdos\n\t\t\t\t;;\n\t\t\trdos32)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=rdos\n\t\t\t\t;;\n\t\t\trom68k)\n\t\t\t\tbasic_machine=m68k-rom68k\n\t\t\t\tbasic_os=coff\n\t\t\t\t;;\n\t\t\tsa29200)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tsei)\n\t\t\t\tbasic_machine=mips-sei\n\t\t\t\tbasic_os=seiux\n\t\t\t\t;;\n\t\t\tsequent)\n\t\t\t\tbasic_machine=i386-sequent\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsps7)\n\t\t\t\tbasic_machine=m68k-bull\n\t\t\t\tbasic_os=sysv2\n\t\t\t\t;;\n\t\t\tst2000)\n\t\t\t\tbasic_machine=m68k-tandem\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tstratus)\n\t\t\t\tbasic_machine=i860-stratus\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tsun2)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun2os3)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun2os4)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun3)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun3os3)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun3os4)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun4)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun4os3)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun4os4)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun4sol2)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=solaris2\n\t\t\t\t;;\n\t\t\tsun386 | sun386i | roadrunner)\n\t\t\t\tbasic_machine=i386-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsv1)\n\t\t\t\tbasic_machine=sv1-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tsymmetry)\n\t\t\t\tbasic_machine=i386-sequent\n\t\t\t\tbasic_os=dynix\n\t\t\t\t;;\n\t\t\tt3e)\n\t\t\t\tbasic_machine=alphaev5-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tt90)\n\t\t\t\tbasic_machine=t90-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\ttoad1)\n\t\t\t\tbasic_machine=pdp10-xkl\n\t\t\t\tbasic_os=tops20\n\t\t\t\t;;\n\t\t\ttpf)\n\t\t\t\tbasic_machine=s390x-ibm\n\t\t\t\tbasic_os=tpf\n\t\t\t\t;;\n\t\t\tudi29k)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tultra3)\n\t\t\t\tbasic_machine=a29k-nyu\n\t\t\t\tbasic_os=sym1\n\t\t\t\t;;\n\t\t\tv810 | necv810)\n\t\t\t\tbasic_machine=v810-nec\n\t\t\t\tbasic_os=none\n\t\t\t\t;;\n\t\t\tvaxv)\n\t\t\t\tbasic_machine=vax-dec\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tvms)\n\t\t\t\tbasic_machine=vax-dec\n\t\t\t\tbasic_os=vms\n\t\t\t\t;;\n\t\t\tvsta)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=vsta\n\t\t\t\t;;\n\t\t\tvxworks960)\n\t\t\t\tbasic_machine=i960-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\tvxworks68)\n\t\t\t\tbasic_machine=m68k-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\tvxworks29k)\n\t\t\t\tbasic_machine=a29k-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\txbox)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=mingw32\n\t\t\t\t;;\n\t\t\tymp)\n\t\t\t\tbasic_machine=ymp-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tbasic_machine=$1\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\n# Decode 1-component or ad-hoc basic machines\ncase $basic_machine in\n\t# Here we handle the default manufacturer of certain CPU types.  It is in\n\t# some cases the only manufacturer, in others, it is the most popular.\n\tw89k)\n\t\tcpu=hppa1.1\n\t\tvendor=winbond\n\t\t;;\n\top50n)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\t;;\n\top60c)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\t;;\n\tibm*)\n\t\tcpu=i370\n\t\tvendor=ibm\n\t\t;;\n\torion105)\n\t\tcpu=clipper\n\t\tvendor=highlevel\n\t\t;;\n\tmac | mpw | mac-mpw)\n\t\tcpu=m68k\n\t\tvendor=apple\n\t\t;;\n\tpmac | pmac-mpw)\n\t\tcpu=powerpc\n\t\tvendor=apple\n\t\t;;\n\n\t# Recognize the various machine names and aliases which stand\n\t# for a CPU type and a company and sometimes even an OS.\n\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n\t\tcpu=m68000\n\t\tvendor=att\n\t\t;;\n\t3b*)\n\t\tcpu=we32k\n\t\tvendor=att\n\t\t;;\n\tbluegene*)\n\t\tcpu=powerpc\n\t\tvendor=ibm\n\t\tbasic_os=cnk\n\t\t;;\n\tdecsystem10* | dec10*)\n\t\tcpu=pdp10\n\t\tvendor=dec\n\t\tbasic_os=tops10\n\t\t;;\n\tdecsystem20* | dec20*)\n\t\tcpu=pdp10\n\t\tvendor=dec\n\t\tbasic_os=tops20\n\t\t;;\n\tdelta | 3300 | motorola-3300 | motorola-delta \\\n\t      | 3300-motorola | delta-motorola)\n\t\tcpu=m68k\n\t\tvendor=motorola\n\t\t;;\n\tdpx2*)\n\t\tcpu=m68k\n\t\tvendor=bull\n\t\tbasic_os=sysv3\n\t\t;;\n\tencore | umax | mmax)\n\t\tcpu=ns32k\n\t\tvendor=encore\n\t\t;;\n\telxsi)\n\t\tcpu=elxsi\n\t\tvendor=elxsi\n\t\tbasic_os=${basic_os:-bsd}\n\t\t;;\n\tfx2800)\n\t\tcpu=i860\n\t\tvendor=alliant\n\t\t;;\n\tgenix)\n\t\tcpu=ns32k\n\t\tvendor=ns\n\t\t;;\n\th3050r* | hiux*)\n\t\tcpu=hppa1.1\n\t\tvendor=hitachi\n\t\tbasic_os=hiuxwe2\n\t\t;;\n\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\thp9k2[0-9][0-9] | hp9k31[0-9])\n\t\tcpu=m68000\n\t\tvendor=hp\n\t\t;;\n\thp9k3[2-9][0-9])\n\t\tcpu=m68k\n\t\tvendor=hp\n\t\t;;\n\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k78[0-9] | hp78[0-9])\n\t\t# FIXME: really hppa2.0-hp\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n\t\t# FIXME: really hppa2.0-hp\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[0-9][13679] | hp8[0-9][13679])\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\ti*86v32)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv32\n\t\t;;\n\ti*86v4*)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv4\n\t\t;;\n\ti*86v)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv\n\t\t;;\n\ti*86sol2)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=solaris2\n\t\t;;\n\tj90 | j90-cray)\n\t\tcpu=j90\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicos}\n\t\t;;\n\tiris | iris4d)\n\t\tcpu=mips\n\t\tvendor=sgi\n\t\tcase $basic_os in\n\t\t    irix*)\n\t\t\t;;\n\t\t    *)\n\t\t\tbasic_os=irix4\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tminiframe)\n\t\tcpu=m68000\n\t\tvendor=convergent\n\t\t;;\n\t*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)\n\t\tcpu=m68k\n\t\tvendor=atari\n\t\tbasic_os=mint\n\t\t;;\n\tnews-3600 | risc-news)\n\t\tcpu=mips\n\t\tvendor=sony\n\t\tbasic_os=newsos\n\t\t;;\n\tnext | m*-next)\n\t\tcpu=m68k\n\t\tvendor=next\n\t\tcase $basic_os in\n\t\t    openstep*)\n\t\t        ;;\n\t\t    nextstep*)\n\t\t\t;;\n\t\t    ns2*)\n\t\t      basic_os=nextstep2\n\t\t\t;;\n\t\t    *)\n\t\t      basic_os=nextstep3\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tnp1)\n\t\tcpu=np1\n\t\tvendor=gould\n\t\t;;\n\top50n-* | op60c-*)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\tbasic_os=proelf\n\t\t;;\n\tpa-hitachi)\n\t\tcpu=hppa1.1\n\t\tvendor=hitachi\n\t\tbasic_os=hiuxwe2\n\t\t;;\n\tpbd)\n\t\tcpu=sparc\n\t\tvendor=tti\n\t\t;;\n\tpbb)\n\t\tcpu=m68k\n\t\tvendor=tti\n\t\t;;\n\tpc532)\n\t\tcpu=ns32k\n\t\tvendor=pc532\n\t\t;;\n\tpn)\n\t\tcpu=pn\n\t\tvendor=gould\n\t\t;;\n\tpower)\n\t\tcpu=power\n\t\tvendor=ibm\n\t\t;;\n\tps2)\n\t\tcpu=i386\n\t\tvendor=ibm\n\t\t;;\n\trm[46]00)\n\t\tcpu=mips\n\t\tvendor=siemens\n\t\t;;\n\trtpc | rtpc-*)\n\t\tcpu=romp\n\t\tvendor=ibm\n\t\t;;\n\tsde)\n\t\tcpu=mipsisa32\n\t\tvendor=sde\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tsimso-wrs)\n\t\tcpu=sparclite\n\t\tvendor=wrs\n\t\tbasic_os=vxworks\n\t\t;;\n\ttower | tower-32)\n\t\tcpu=m68k\n\t\tvendor=ncr\n\t\t;;\n\tvpp*|vx|vx-*)\n\t\tcpu=f301\n\t\tvendor=fujitsu\n\t\t;;\n\tw65)\n\t\tcpu=w65\n\t\tvendor=wdc\n\t\t;;\n\tw89k-*)\n\t\tcpu=hppa1.1\n\t\tvendor=winbond\n\t\tbasic_os=proelf\n\t\t;;\n\tnone)\n\t\tcpu=none\n\t\tvendor=none\n\t\t;;\n\tleon|leon[3-9])\n\t\tcpu=sparc\n\t\tvendor=$basic_machine\n\t\t;;\n\tleon-*|leon[3-9]-*)\n\t\tcpu=sparc\n\t\tvendor=`echo \"$basic_machine\" | sed 's/-.*//'`\n\t\t;;\n\n\t*-*)\n\t\t# shellcheck disable=SC2162\n\t\tsaved_IFS=$IFS\n\t\tIFS=\"-\" read cpu vendor <<EOF\n$basic_machine\nEOF\n\t\tIFS=$saved_IFS\n\t\t;;\n\t# We use `pc' rather than `unknown'\n\t# because (1) that's what they normally are, and\n\t# (2) the word \"unknown\" tends to confuse beginning users.\n\ti*86 | x86_64)\n\t\tcpu=$basic_machine\n\t\tvendor=pc\n\t\t;;\n\t# These rules are duplicated from below for sake of the special case above;\n\t# i.e. things that normalized to x86 arches should also default to \"pc\"\n\tpc98)\n\t\tcpu=i386\n\t\tvendor=pc\n\t\t;;\n\tx64 | amd64)\n\t\tcpu=x86_64\n\t\tvendor=pc\n\t\t;;\n\t# Recognize the basic CPU types without company name.\n\t*)\n\t\tcpu=$basic_machine\n\t\tvendor=unknown\n\t\t;;\nesac\n\nunset -v basic_machine\n\n# Decode basic machines in the full and proper CPU-Company form.\ncase $cpu-$vendor in\n\t# Here we handle the default manufacturer of certain CPU types in canonical form. It is in\n\t# some cases the only manufacturer, in others, it is the most popular.\n\tcraynv-unknown)\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicosmp}\n\t\t;;\n\tc90-unknown | c90-cray)\n\t\tvendor=cray\n\t\tbasic_os=${Basic_os:-unicos}\n\t\t;;\n\tfx80-unknown)\n\t\tvendor=alliant\n\t\t;;\n\tromp-unknown)\n\t\tvendor=ibm\n\t\t;;\n\tmmix-unknown)\n\t\tvendor=knuth\n\t\t;;\n\tmicroblaze-unknown | microblazeel-unknown)\n\t\tvendor=xilinx\n\t\t;;\n\trs6000-unknown)\n\t\tvendor=ibm\n\t\t;;\n\tvax-unknown)\n\t\tvendor=dec\n\t\t;;\n\tpdp11-unknown)\n\t\tvendor=dec\n\t\t;;\n\twe32k-unknown)\n\t\tvendor=att\n\t\t;;\n\tcydra-unknown)\n\t\tvendor=cydrome\n\t\t;;\n\ti370-ibm*)\n\t\tvendor=ibm\n\t\t;;\n\torion-unknown)\n\t\tvendor=highlevel\n\t\t;;\n\txps-unknown | xps100-unknown)\n\t\tcpu=xps100\n\t\tvendor=honeywell\n\t\t;;\n\n\t# Here we normalize CPU types with a missing or matching vendor\n\tarmh-unknown | armh-alt)\n\t\tcpu=armv7l\n\t\tvendor=alt\n\t\tbasic_os=${basic_os:-linux-gnueabihf}\n\t\t;;\n\tdpx20-unknown | dpx20-bull)\n\t\tcpu=rs6000\n\t\tvendor=bull\n\t\tbasic_os=${basic_os:-bosx}\n\t\t;;\n\n\t# Here we normalize CPU types irrespective of the vendor\n\tamd64-*)\n\t\tcpu=x86_64\n\t\t;;\n\tblackfin-*)\n\t\tcpu=bfin\n\t\tbasic_os=linux\n\t\t;;\n\tc54x-*)\n\t\tcpu=tic54x\n\t\t;;\n\tc55x-*)\n\t\tcpu=tic55x\n\t\t;;\n\tc6x-*)\n\t\tcpu=tic6x\n\t\t;;\n\te500v[12]-*)\n\t\tcpu=powerpc\n\t\tbasic_os=${basic_os}\"spe\"\n\t\t;;\n\tmips3*-*)\n\t\tcpu=mips64\n\t\t;;\n\tms1-*)\n\t\tcpu=mt\n\t\t;;\n\tm68knommu-*)\n\t\tcpu=m68k\n\t\tbasic_os=linux\n\t\t;;\n\tm9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)\n\t\tcpu=s12z\n\t\t;;\n\topenrisc-*)\n\t\tcpu=or32\n\t\t;;\n\tparisc-*)\n\t\tcpu=hppa\n\t\tbasic_os=linux\n\t\t;;\n\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n\t\tcpu=i586\n\t\t;;\n\tpentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)\n\t\tcpu=i686\n\t\t;;\n\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n\t\tcpu=i686\n\t\t;;\n\tpentium4-*)\n\t\tcpu=i786\n\t\t;;\n\tpc98-*)\n\t\tcpu=i386\n\t\t;;\n\tppc-* | ppcbe-*)\n\t\tcpu=powerpc\n\t\t;;\n\tppcle-* | powerpclittle-*)\n\t\tcpu=powerpcle\n\t\t;;\n\tppc64-*)\n\t\tcpu=powerpc64\n\t\t;;\n\tppc64le-* | powerpc64little-*)\n\t\tcpu=powerpc64le\n\t\t;;\n\tsb1-*)\n\t\tcpu=mipsisa64sb1\n\t\t;;\n\tsb1el-*)\n\t\tcpu=mipsisa64sb1el\n\t\t;;\n\tsh5e[lb]-*)\n\t\tcpu=`echo \"$cpu\" | sed 's/^\\(sh.\\)e\\(.\\)$/\\1\\2e/'`\n\t\t;;\n\tspur-*)\n\t\tcpu=spur\n\t\t;;\n\tstrongarm-* | thumb-*)\n\t\tcpu=arm\n\t\t;;\n\ttx39-*)\n\t\tcpu=mipstx39\n\t\t;;\n\ttx39el-*)\n\t\tcpu=mipstx39el\n\t\t;;\n\tx64-*)\n\t\tcpu=x86_64\n\t\t;;\n\txscale-* | xscalee[bl]-*)\n\t\tcpu=`echo \"$cpu\" | sed 's/^xscale/arm/'`\n\t\t;;\n\tarm64-* | aarch64le-*)\n\t\tcpu=aarch64\n\t\t;;\n\n\t# Recognize the canonical CPU Types that limit and/or modify the\n\t# company names they are paired with.\n\tcr16-*)\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tcrisv32-* | etraxfs*-*)\n\t\tcpu=crisv32\n\t\tvendor=axis\n\t\t;;\n\tcris-* | etrax*-*)\n\t\tcpu=cris\n\t\tvendor=axis\n\t\t;;\n\tcrx-*)\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tneo-tandem)\n\t\tcpu=neo\n\t\tvendor=tandem\n\t\t;;\n\tnse-tandem)\n\t\tcpu=nse\n\t\tvendor=tandem\n\t\t;;\n\tnsr-tandem)\n\t\tcpu=nsr\n\t\tvendor=tandem\n\t\t;;\n\tnsv-tandem)\n\t\tcpu=nsv\n\t\tvendor=tandem\n\t\t;;\n\tnsx-tandem)\n\t\tcpu=nsx\n\t\tvendor=tandem\n\t\t;;\n\tmipsallegrexel-sony)\n\t\tcpu=mipsallegrexel\n\t\tvendor=sony\n\t\t;;\n\ttile*-*)\n\t\tbasic_os=${basic_os:-linux-gnu}\n\t\t;;\n\n\t*)\n\t\t# Recognize the canonical CPU types that are allowed with any\n\t\t# company name.\n\t\tcase $cpu in\n\t\t\t1750a | 580 \\\n\t\t\t| a29k \\\n\t\t\t| aarch64 | aarch64_be \\\n\t\t\t| abacus \\\n\t\t\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \\\n\t\t\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \\\n\t\t\t| alphapca5[67] | alpha64pca5[67] \\\n\t\t\t| am33_2.0 \\\n\t\t\t| amdgcn \\\n\t\t\t| arc | arceb | arc32 | arc64 \\\n\t\t\t| arm | arm[lb]e | arme[lb] | armv* \\\n\t\t\t| avr | avr32 \\\n\t\t\t| asmjs \\\n\t\t\t| ba \\\n\t\t\t| be32 | be64 \\\n\t\t\t| bfin | bpf | bs2000 \\\n\t\t\t| c[123]* | c30 | [cjt]90 | c4x \\\n\t\t\t| c8051 | clipper | craynv | csky | cydra \\\n\t\t\t| d10v | d30v | dlx | dsp16xx \\\n\t\t\t| e2k | elxsi | epiphany \\\n\t\t\t| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \\\n\t\t\t| h8300 | h8500 \\\n\t\t\t| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n\t\t\t| hexagon \\\n\t\t\t| i370 | i*86 | i860 | i960 | ia16 | ia64 \\\n\t\t\t| ip2k | iq2000 \\\n\t\t\t| k1om \\\n\t\t\t| le32 | le64 \\\n\t\t\t| lm32 \\\n\t\t\t| loongarch32 | loongarch64 \\\n\t\t\t| m32c | m32r | m32rle \\\n\t\t\t| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \\\n\t\t\t| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \\\n\t\t\t| m88110 | m88k | maxq | mb | mcore | mep | metag \\\n\t\t\t| microblaze | microblazeel \\\n\t\t\t| mips | mipsbe | mipseb | mipsel | mipsle \\\n\t\t\t| mips16 \\\n\t\t\t| mips64 | mips64eb | mips64el \\\n\t\t\t| mips64octeon | mips64octeonel \\\n\t\t\t| mips64orion | mips64orionel \\\n\t\t\t| mips64r5900 | mips64r5900el \\\n\t\t\t| mips64vr | mips64vrel \\\n\t\t\t| mips64vr4100 | mips64vr4100el \\\n\t\t\t| mips64vr4300 | mips64vr4300el \\\n\t\t\t| mips64vr5000 | mips64vr5000el \\\n\t\t\t| mips64vr5900 | mips64vr5900el \\\n\t\t\t| mipsisa32 | mipsisa32el \\\n\t\t\t| mipsisa32r2 | mipsisa32r2el \\\n\t\t\t| mipsisa32r3 | mipsisa32r3el \\\n\t\t\t| mipsisa32r5 | mipsisa32r5el \\\n\t\t\t| mipsisa32r6 | mipsisa32r6el \\\n\t\t\t| mipsisa64 | mipsisa64el \\\n\t\t\t| mipsisa64r2 | mipsisa64r2el \\\n\t\t\t| mipsisa64r3 | mipsisa64r3el \\\n\t\t\t| mipsisa64r5 | mipsisa64r5el \\\n\t\t\t| mipsisa64r6 | mipsisa64r6el \\\n\t\t\t| mipsisa64sb1 | mipsisa64sb1el \\\n\t\t\t| mipsisa64sr71k | mipsisa64sr71kel \\\n\t\t\t| mipsr5900 | mipsr5900el \\\n\t\t\t| mipstx39 | mipstx39el \\\n\t\t\t| mmix \\\n\t\t\t| mn10200 | mn10300 \\\n\t\t\t| moxie \\\n\t\t\t| mt \\\n\t\t\t| msp430 \\\n\t\t\t| nds32 | nds32le | nds32be \\\n\t\t\t| nfp \\\n\t\t\t| nios | nios2 | nios2eb | nios2el \\\n\t\t\t| none | np1 | ns16k | ns32k | nvptx \\\n\t\t\t| open8 \\\n\t\t\t| or1k* \\\n\t\t\t| or32 \\\n\t\t\t| orion \\\n\t\t\t| picochip \\\n\t\t\t| pdp10 | pdp11 | pj | pjl | pn | power \\\n\t\t\t| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \\\n\t\t\t| pru \\\n\t\t\t| pyramid \\\n\t\t\t| riscv | riscv32 | riscv32be | riscv64 | riscv64be \\\n\t\t\t| rl78 | romp | rs6000 | rx \\\n\t\t\t| s390 | s390x \\\n\t\t\t| score \\\n\t\t\t| sh | shl \\\n\t\t\t| sh[1234] | sh[24]a | sh[24]ae[lb] | sh[23]e | she[lb] | sh[lb]e \\\n\t\t\t| sh[1234]e[lb] |  sh[12345][lb]e | sh[23]ele | sh64 | sh64le \\\n\t\t\t| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet \\\n\t\t\t| sparclite \\\n\t\t\t| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \\\n\t\t\t| spu \\\n\t\t\t| tahoe \\\n\t\t\t| thumbv7* \\\n\t\t\t| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \\\n\t\t\t| tron \\\n\t\t\t| ubicom32 \\\n\t\t\t| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \\\n\t\t\t| vax \\\n\t\t\t| visium \\\n\t\t\t| w65 \\\n\t\t\t| wasm32 | wasm64 \\\n\t\t\t| we32k \\\n\t\t\t| x86 | x86_64 | xc16x | xgate | xps100 \\\n\t\t\t| xstormy16 | xtensa* \\\n\t\t\t| ymp \\\n\t\t\t| z8k | z80)\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\techo Invalid configuration \\`\"$1\"\\': machine \\`\"$cpu-$vendor\"\\' not recognized 1>&2\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\n# Here we canonicalize certain aliases for manufacturers.\ncase $vendor in\n\tdigital*)\n\t\tvendor=dec\n\t\t;;\n\tcommodore*)\n\t\tvendor=cbm\n\t\t;;\n\t*)\n\t\t;;\nesac\n\n# Decode manufacturer-specific aliases for certain operating systems.\n\nif test x$basic_os != x\nthen\n\n# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just\n# set os.\ncase $basic_os in\n\tgnu/linux*)\n\t\tkernel=linux\n\t\tos=`echo \"$basic_os\" | sed -e 's|gnu/linux|gnu|'`\n\t\t;;\n\tos2-emx)\n\t\tkernel=os2\n\t\tos=`echo \"$basic_os\" | sed -e 's|os2-emx|emx|'`\n\t\t;;\n\tnto-qnx*)\n\t\tkernel=nto\n\t\tos=`echo \"$basic_os\" | sed -e 's|nto-qnx|qnx|'`\n\t\t;;\n\t*-*)\n\t\t# shellcheck disable=SC2162\n\t\tsaved_IFS=$IFS\n\t\tIFS=\"-\" read kernel os <<EOF\n$basic_os\nEOF\n\t\tIFS=$saved_IFS\n\t\t;;\n\t# Default OS when just kernel was specified\n\tnto*)\n\t\tkernel=nto\n\t\tos=`echo \"$basic_os\" | sed -e 's|nto|qnx|'`\n\t\t;;\n\tlinux*)\n\t\tkernel=linux\n\t\tos=`echo \"$basic_os\" | sed -e 's|linux|gnu|'`\n\t\t;;\n\tmanagarm*)\n\t\tkernel=managarm\n\t\tos=`echo \"$basic_os\" | sed -e 's|managarm|mlibc|'`\n\t\t;;\n\t*)\n\t\tkernel=\n\t\tos=$basic_os\n\t\t;;\nesac\n\n# Now, normalize the OS (knowing we just have one component, it's not a kernel,\n# etc.)\ncase $os in\n\t# First match some system type aliases that might get confused\n\t# with valid system types.\n\t# solaris* is a basic system type, with this one exception.\n\tauroraux)\n\t\tos=auroraux\n\t\t;;\n\tbluegene*)\n\t\tos=cnk\n\t\t;;\n\tsolaris1 | solaris1.*)\n\t\tos=`echo \"$os\" | sed -e 's|solaris1|sunos4|'`\n\t\t;;\n\tsolaris)\n\t\tos=solaris2\n\t\t;;\n\tunixware*)\n\t\tos=sysv4.2uw\n\t\t;;\n\t# es1800 is here to avoid being matched by es* (a different OS)\n\tes1800*)\n\t\tos=ose\n\t\t;;\n\t# Some version numbers need modification\n\tchorusos*)\n\t\tos=chorusos\n\t\t;;\n\tisc)\n\t\tos=isc2.2\n\t\t;;\n\tsco6)\n\t\tos=sco5v6\n\t\t;;\n\tsco5)\n\t\tos=sco3.2v5\n\t\t;;\n\tsco4)\n\t\tos=sco3.2v4\n\t\t;;\n\tsco3.2.[4-9]*)\n\t\tos=`echo \"$os\" | sed -e 's/sco3.2./sco3.2v/'`\n\t\t;;\n\tsco*v* | scout)\n\t\t# Don't match below\n\t\t;;\n\tsco*)\n\t\tos=sco3.2v2\n\t\t;;\n\tpsos*)\n\t\tos=psos\n\t\t;;\n\tqnx*)\n\t\tos=qnx\n\t\t;;\n\thiux*)\n\t\tos=hiuxwe2\n\t\t;;\n\tlynx*178)\n\t\tos=lynxos178\n\t\t;;\n\tlynx*5)\n\t\tos=lynxos5\n\t\t;;\n\tlynxos*)\n\t\t# don't get caught up in next wildcard\n\t\t;;\n\tlynx*)\n\t\tos=lynxos\n\t\t;;\n\tmac[0-9]*)\n\t\tos=`echo \"$os\" | sed -e 's|mac|macos|'`\n\t\t;;\n\topened*)\n\t\tos=openedition\n\t\t;;\n\tos400*)\n\t\tos=os400\n\t\t;;\n\tsunos5*)\n\t\tos=`echo \"$os\" | sed -e 's|sunos5|solaris2|'`\n\t\t;;\n\tsunos6*)\n\t\tos=`echo \"$os\" | sed -e 's|sunos6|solaris3|'`\n\t\t;;\n\twince*)\n\t\tos=wince\n\t\t;;\n\tutek*)\n\t\tos=bsd\n\t\t;;\n\tdynix*)\n\t\tos=bsd\n\t\t;;\n\tacis*)\n\t\tos=aos\n\t\t;;\n\tatheos*)\n\t\tos=atheos\n\t\t;;\n\tsyllable*)\n\t\tos=syllable\n\t\t;;\n\t386bsd)\n\t\tos=bsd\n\t\t;;\n\tctix* | uts*)\n\t\tos=sysv\n\t\t;;\n\tnova*)\n\t\tos=rtmk-nova\n\t\t;;\n\tns2)\n\t\tos=nextstep2\n\t\t;;\n\t# Preserve the version number of sinix5.\n\tsinix5.*)\n\t\tos=`echo \"$os\" | sed -e 's|sinix|sysv|'`\n\t\t;;\n\tsinix*)\n\t\tos=sysv4\n\t\t;;\n\ttpf*)\n\t\tos=tpf\n\t\t;;\n\ttriton*)\n\t\tos=sysv3\n\t\t;;\n\toss*)\n\t\tos=sysv3\n\t\t;;\n\tsvr4*)\n\t\tos=sysv4\n\t\t;;\n\tsvr3)\n\t\tos=sysv3\n\t\t;;\n\tsysvr4)\n\t\tos=sysv4\n\t\t;;\n\tose*)\n\t\tos=ose\n\t\t;;\n\t*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)\n\t\tos=mint\n\t\t;;\n\tdicos*)\n\t\tos=dicos\n\t\t;;\n\tpikeos*)\n\t\t# Until real need of OS specific support for\n\t\t# particular features comes up, bare metal\n\t\t# configurations are quite functional.\n\t\tcase $cpu in\n\t\t    arm*)\n\t\t\tos=eabi\n\t\t\t;;\n\t\t    *)\n\t\t\tos=elf\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t*)\n\t\t# No normalization, but not necessarily accepted, that comes below.\n\t\t;;\nesac\n\nelse\n\n# Here we handle the default operating systems that come with various machines.\n# The value should be what the vendor currently ships out the door with their\n# machine or put another way, the most popular os provided with the machine.\n\n# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n# \"-sun\"), then you have to tell the case statement up towards the top\n# that MANUFACTURER isn't an operating system.  Otherwise, code above\n# will signal an error saying that MANUFACTURER isn't an operating\n# system, and we'll never get to this point.\n\nkernel=\ncase $cpu-$vendor in\n\tscore-*)\n\t\tos=elf\n\t\t;;\n\tspu-*)\n\t\tos=elf\n\t\t;;\n\t*-acorn)\n\t\tos=riscix1.2\n\t\t;;\n\tarm*-rebel)\n\t\tkernel=linux\n\t\tos=gnu\n\t\t;;\n\tarm*-semi)\n\t\tos=aout\n\t\t;;\n\tc4x-* | tic4x-*)\n\t\tos=coff\n\t\t;;\n\tc8051-*)\n\t\tos=elf\n\t\t;;\n\tclipper-intergraph)\n\t\tos=clix\n\t\t;;\n\thexagon-*)\n\t\tos=elf\n\t\t;;\n\ttic54x-*)\n\t\tos=coff\n\t\t;;\n\ttic55x-*)\n\t\tos=coff\n\t\t;;\n\ttic6x-*)\n\t\tos=coff\n\t\t;;\n\t# This must come before the *-dec entry.\n\tpdp10-*)\n\t\tos=tops20\n\t\t;;\n\tpdp11-*)\n\t\tos=none\n\t\t;;\n\t*-dec | vax-*)\n\t\tos=ultrix4.2\n\t\t;;\n\tm68*-apollo)\n\t\tos=domain\n\t\t;;\n\ti386-sun)\n\t\tos=sunos4.0.2\n\t\t;;\n\tm68000-sun)\n\t\tos=sunos3\n\t\t;;\n\tm68*-cisco)\n\t\tos=aout\n\t\t;;\n\tmep-*)\n\t\tos=elf\n\t\t;;\n\tmips*-cisco)\n\t\tos=elf\n\t\t;;\n\tmips*-*)\n\t\tos=elf\n\t\t;;\n\tor32-*)\n\t\tos=coff\n\t\t;;\n\t*-tti)\t# must be before sparc entry or we get the wrong os.\n\t\tos=sysv3\n\t\t;;\n\tsparc-* | *-sun)\n\t\tos=sunos4.1.1\n\t\t;;\n\tpru-*)\n\t\tos=elf\n\t\t;;\n\t*-be)\n\t\tos=beos\n\t\t;;\n\t*-ibm)\n\t\tos=aix\n\t\t;;\n\t*-knuth)\n\t\tos=mmixware\n\t\t;;\n\t*-wec)\n\t\tos=proelf\n\t\t;;\n\t*-winbond)\n\t\tos=proelf\n\t\t;;\n\t*-oki)\n\t\tos=proelf\n\t\t;;\n\t*-hp)\n\t\tos=hpux\n\t\t;;\n\t*-hitachi)\n\t\tos=hiux\n\t\t;;\n\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n\t\tos=sysv\n\t\t;;\n\t*-cbm)\n\t\tos=amigaos\n\t\t;;\n\t*-dg)\n\t\tos=dgux\n\t\t;;\n\t*-dolphin)\n\t\tos=sysv3\n\t\t;;\n\tm68k-ccur)\n\t\tos=rtu\n\t\t;;\n\tm88k-omron*)\n\t\tos=luna\n\t\t;;\n\t*-next)\n\t\tos=nextstep\n\t\t;;\n\t*-sequent)\n\t\tos=ptx\n\t\t;;\n\t*-crds)\n\t\tos=unos\n\t\t;;\n\t*-ns)\n\t\tos=genix\n\t\t;;\n\ti370-*)\n\t\tos=mvs\n\t\t;;\n\t*-gould)\n\t\tos=sysv\n\t\t;;\n\t*-highlevel)\n\t\tos=bsd\n\t\t;;\n\t*-encore)\n\t\tos=bsd\n\t\t;;\n\t*-sgi)\n\t\tos=irix\n\t\t;;\n\t*-siemens)\n\t\tos=sysv4\n\t\t;;\n\t*-masscomp)\n\t\tos=rtu\n\t\t;;\n\tf30[01]-fujitsu | f700-fujitsu)\n\t\tos=uxpv\n\t\t;;\n\t*-rom68k)\n\t\tos=coff\n\t\t;;\n\t*-*bug)\n\t\tos=coff\n\t\t;;\n\t*-apple)\n\t\tos=macos\n\t\t;;\n\t*-atari*)\n\t\tos=mint\n\t\t;;\n\t*-wrs)\n\t\tos=vxworks\n\t\t;;\n\t*)\n\t\tos=none\n\t\t;;\nesac\n\nfi\n\n# Now, validate our (potentially fixed-up) OS.\ncase $os in\n\t# Sometimes we do \"kernel-libc\", so those need to count as OSes.\n\tmusl* | newlib* | relibc* | uclibc*)\n\t\t;;\n\t# Likewise for \"kernel-abi\"\n\teabi* | gnueabi*)\n\t\t;;\n\t# VxWorks passes extra cpu info in the 4th filed.\n\tsimlinux | simwindows | spe)\n\t\t;;\n\t# Now accept the basic system types.\n\t# The portable systems comes first.\n\t# Each alternative MUST end in a * to match a version number.\n\tgnu* | android* | bsd* | mach* | minix* | genix* | ultrix* | irix* \\\n\t     | *vms* | esix* | aix* | cnk* | sunos | sunos[34]* \\\n\t     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \\\n\t     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \\\n\t     | hiux* | abug | nacl* | netware* | windows* \\\n\t     | os9* | macos* | osx* | ios* \\\n\t     | mpw* | magic* | mmixware* | mon960* | lnews* \\\n\t     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \\\n\t     | aos* | aros* | cloudabi* | sortix* | twizzler* \\\n\t     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \\\n\t     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \\\n\t     | mirbsd* | netbsd* | dicos* | openedition* | ose* \\\n\t     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \\\n\t     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \\\n\t     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \\\n\t     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \\\n\t     | udi* | lites* | ieee* | go32* | aux* | hcos* \\\n\t     | chorusrdb* | cegcc* | glidix* | serenity* \\\n\t     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \\\n\t     | midipix* | mingw32* | mingw64* | mint* \\\n\t     | uxpv* | beos* | mpeix* | udk* | moxiebox* \\\n\t     | interix* | uwin* | mks* | rhapsody* | darwin* \\\n\t     | openstep* | oskit* | conix* | pw32* | nonstopux* \\\n\t     | storm-chaos* | tops10* | tenex* | tops20* | its* \\\n\t     | os2* | vos* | palmos* | uclinux* | nucleus* | morphos* \\\n\t     | scout* | superux* | sysv* | rtmk* | tpf* | windiss* \\\n\t     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \\\n\t     | skyos* | haiku* | rdos* | toppers* | drops* | es* \\\n\t     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \\\n\t     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \\\n\t     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \\\n\t     | fiwix* | mlibc* )\n\t\t;;\n\t# This one is extra strict with allowed versions\n\tsco3.2v2 | sco3.2v[4-9]* | sco5v6*)\n\t\t# Don't forget version if it is 3.2v4 or newer.\n\t\t;;\n\tnone)\n\t\t;;\n\tkernel* )\n\t\t# Restricted further below\n\t\t;;\n\t*)\n\t\techo Invalid configuration \\`\"$1\"\\': OS \\`\"$os\"\\' not recognized 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# As a final step for OS-related things, validate the OS-kernel combination\n# (given a valid OS), if there is a kernel.\ncase $kernel-$os in\n\tlinux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \\\n\t\t   | linux-musl* | linux-relibc* | linux-uclibc* | linux-mlibc* )\n\t\t;;\n\tuclinux-uclibc* )\n\t\t;;\n\tmanagarm-mlibc* | managarm-kernel* )\n\t\t;;\n\t-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* | -mlibc* )\n\t\t# These are just libc implementations, not actual OSes, and thus\n\t\t# require a kernel.\n\t\techo \"Invalid configuration \\`$1': libc \\`$os' needs explicit kernel.\" 1>&2\n\t\texit 1\n\t\t;;\n\t-kernel* )\n\t\techo \"Invalid configuration \\`$1': \\`$os' needs explicit kernel.\" 1>&2\n\t\texit 1\n\t\t;;\n\t*-kernel* )\n\t\techo \"Invalid configuration \\`$1': \\`$kernel' does not support \\`$os'.\" 1>&2\n\t\texit 1\n\t\t;;\n\tkfreebsd*-gnu* | kopensolaris*-gnu*)\n\t\t;;\n\tvxworks-simlinux | vxworks-simwindows | vxworks-spe)\n\t\t;;\n\tnto-qnx*)\n\t\t;;\n\tos2-emx)\n\t\t;;\n\t*-eabi* | *-gnueabi*)\n\t\t;;\n\t-*)\n\t\t# Blank kernel with real OS is always fine.\n\t\t;;\n\t*-*)\n\t\techo \"Invalid configuration \\`$1': Kernel \\`$kernel' not known to work with OS \\`$os'.\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# Here we handle the case where we know the os, and the CPU type, but not the\n# manufacturer.  We pick the logical manufacturer.\ncase $vendor in\n\tunknown)\n\t\tcase $cpu-$os in\n\t\t\t*-riscix*)\n\t\t\t\tvendor=acorn\n\t\t\t\t;;\n\t\t\t*-sunos*)\n\t\t\t\tvendor=sun\n\t\t\t\t;;\n\t\t\t*-cnk* | *-aix*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-beos*)\n\t\t\t\tvendor=be\n\t\t\t\t;;\n\t\t\t*-hpux*)\n\t\t\t\tvendor=hp\n\t\t\t\t;;\n\t\t\t*-mpeix*)\n\t\t\t\tvendor=hp\n\t\t\t\t;;\n\t\t\t*-hiux*)\n\t\t\t\tvendor=hitachi\n\t\t\t\t;;\n\t\t\t*-unos*)\n\t\t\t\tvendor=crds\n\t\t\t\t;;\n\t\t\t*-dgux*)\n\t\t\t\tvendor=dg\n\t\t\t\t;;\n\t\t\t*-luna*)\n\t\t\t\tvendor=omron\n\t\t\t\t;;\n\t\t\t*-genix*)\n\t\t\t\tvendor=ns\n\t\t\t\t;;\n\t\t\t*-clix*)\n\t\t\t\tvendor=intergraph\n\t\t\t\t;;\n\t\t\t*-mvs* | *-opened*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-os400*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\ts390-* | s390x-*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-ptx*)\n\t\t\t\tvendor=sequent\n\t\t\t\t;;\n\t\t\t*-tpf*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-vxsim* | *-vxworks* | *-windiss*)\n\t\t\t\tvendor=wrs\n\t\t\t\t;;\n\t\t\t*-aux*)\n\t\t\t\tvendor=apple\n\t\t\t\t;;\n\t\t\t*-hms*)\n\t\t\t\tvendor=hitachi\n\t\t\t\t;;\n\t\t\t*-mpw* | *-macos*)\n\t\t\t\tvendor=apple\n\t\t\t\t;;\n\t\t\t*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)\n\t\t\t\tvendor=atari\n\t\t\t\t;;\n\t\t\t*-vos*)\n\t\t\t\tvendor=stratus\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\necho \"$cpu-$vendor-${kernel:+$kernel-}$os\"\nexit\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"timestamp='\"\n# time-stamp-format: \"%:y-%02m-%02d\"\n# time-stamp-end: \"'\"\n# End:\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.6494140625,
          "content": "#!/bin/sh -e\n# This configure script ensures that the configure.sh script exists, and\n# if not, it tries to fetch rsync's generated files or build them.  We\n# then transfer control to the configure.sh script to do the real work.\n\ndir=`dirname $0`\nif test x\"$dir\" = x; then\n    dir=.\nfi\n\nif test \"$dir\" = '.'; then\n    branch=`packaging/prep-auto-dir` || exit 1\n    if test x\"$branch\" != x; then\n\tcd build || exit 1\n\tdir=..\n    fi\nfi\n\nif test ! -f configure.sh; then\n    if ! \"$dir/prepare-source\" build; then\n\techo 'Failed to build configure.sh and/or config.h.in -- giving up.' >&2\n\trm -f configure.sh\n\texit 1\n    fi\nfi\n\nexec ./configure.sh --srcdir=\"$dir\" \"${@}\"\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 46.328125,
          "content": "dnl Process this file with autoconf to produce a configure script.\n\nAC_INIT([rsync],[ ],[https://rsync.samba.org/bug-tracking.html])\n\nAC_C_BIGENDIAN\nAC_HEADER_DIRENT\nAC_HEADER_SYS_WAIT\nAC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \\\n    unistd.h utime.h compat.h sys/param.h ctype.h sys/wait.h sys/stat.h \\\n    sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h grp.h \\\n    sys/un.h sys/attr.h arpa/inet.h arpa/nameser.h locale.h sys/types.h \\\n    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h mcheck.h \\\n    sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h dl.h \\\n    popt.h popt/popt.h linux/falloc.h netinet/in_systm.h netgroup.h \\\n    zlib.h xxhash.h openssl/md4.h openssl/md5.h zstd.h lz4.h sys/file.h \\\n    bsd/string.h)\nAC_CHECK_HEADERS([netinet/ip.h], [], [], [[#include <netinet/in.h>]])\nAC_HEADER_MAJOR_FIXED\n\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_SRCDIR([byteorder.h])\nAC_CONFIG_HEADERS([config.h])\nAC_PREREQ([2.69])\n\nPACKAGE_VERSION=`sed -n 's/.*RSYNC_VERSION.*\"\\(.*\\)\".*/\\1/p' <$srcdir/version.h`\n\nAC_MSG_NOTICE([Configuring rsync $PACKAGE_VERSION])\n\nLDFLAGS=${LDFLAGS-\"\"}\n\nAC_CANONICAL_HOST\n\ndnl define the directory for replacement function since AC_LIBOBJ does not\ndnl officially support subdirs and fails with automake\nAC_CONFIG_LIBOBJ_DIR([lib])\n\n# We must decide this before testing the compiler.\n\n# Please allow this to default to yes, so that your users have more\n# chance of getting a useful stack trace if problems occur.\n\nAC_MSG_CHECKING([whether to include debugging symbols])\nAC_ARG_ENABLE(debug,\n\tAS_HELP_STRING([--disable-debug],[disable to omit debugging symbols and features]))\n\nif test x\"$enable_debug\" = x\"no\"; then\n    AC_MSG_RESULT(no)\n    ac_cv_prog_cc_g=no\nelse\n    AC_MSG_RESULT([yes])\n    dnl AC_DEFINE(DEBUG, 1, [Define to turn on debugging code that may slow normal operation])\n    # leave ac_cv_prog_cc_g alone; AC_PROG_CC will try to include -g if it can\nfi\n\ndnl Checks for programs.\nAC_PROG_CC\nAC_PROG_CPP\nAC_PROG_CXX\nAC_PROG_AWK\nAC_PROG_EGREP\nAC_PROG_INSTALL\nAC_PROG_MKDIR_P\nAC_SUBST(SHELL)\nAC_PATH_PROG([PERL], [perl])\nAC_PATH_PROG([PYTHON3], [python3])\n\nAC_DEFINE([_GNU_SOURCE], 1,\n          [Define _GNU_SOURCE so that we get all necessary prototypes])\n\nif test x\"$ac_cv_prog_cc_stdc\" = x\"no\"; then\n\tAC_MSG_WARN([rsync requires an ANSI C compiler and you do not seem to have one])\nfi\n\nno_lib=''\nerr_msg=''\nnl='\n'\n\nAC_ARG_ENABLE(profile,\n\tAS_HELP_STRING([--enable-profile],[enable to turn on CPU profiling]))\nif test x\"$enable_profile\" = x\"yes\"; then\n\tCFLAGS=\"$CFLAGS -pg\"\nfi\n\nAC_MSG_CHECKING([if md2man can create manpages])\nif test x\"$ac_cv_path_PYTHON3\" = x; then\n    AC_MSG_RESULT(no - python3 not found)\n    md2man_works=no\nelse\n    md2man_out=`\"$srcdir/md2man\" --test \"$srcdir/rsync-ssl.1.md\" 2>&1`\n    if test $? = 0; then\n\tAC_MSG_RESULT(yes)\n\tmd2man_works=yes\n    else\n\tAC_MSG_RESULT(no)\n\tmd2man_works=no\n\techo \"$md2man_out\"\n    fi\nfi\n\nAC_MSG_CHECKING([if we require man-page building])\nAC_ARG_ENABLE([md2man],\n\tAS_HELP_STRING([--disable-md2man],[disable to omit manpage creation]))\nif test x\"$enable_md2man\" != x\"no\"; then\n    if test -f \"$srcdir/rsync.1\"; then\n\tAC_MSG_RESULT(optional)\n    else\n\tAC_MSG_RESULT(required)\n\tif test x\"$md2man_works\" = x\"no\"; then\n\t    err_msg=\"$err_msg$nl- You need python3 and either the cmarkgfm OR commonmark python3 lib in order\"\n\t    err_msg=\"$err_msg$nl  to build manpages based on the git source (manpages are included in the\"\n\t    err_msg=\"$err_msg$nl  official release tar files).\"\n\t    no_lib=\"$no_lib md2man\"\n\tfi\n    fi\n    MAKE_MAN=man\nelse\n    AC_MSG_RESULT(no)\nfi\n\n# Specifically, this turns on panic_action handling.\nAC_ARG_ENABLE(maintainer-mode,\n\tAS_HELP_STRING([--enable-maintainer-mode],[enable to turn on extra debug features]))\nif test x\"$enable_maintainer_mode\" = x\"yes\"; then\n\tCFLAGS=\"$CFLAGS -DMAINTAINER_MODE\"\nfi\n\n# This is needed for our included version of popt.  Kind of silly, but\n# I don't want our version too far out of sync.\nCFLAGS=\"$CFLAGS -DHAVE_CONFIG_H\"\n\n# If GCC, turn on warnings.\nif test x\"$GCC\" = x\"yes\"; then\n\tCFLAGS=\"$CFLAGS -Wall -W\"\nfi\n\nAC_ARG_WITH(openssl-conf,\n\tAS_HELP_STRING([--with-openssl-conf=PATH],[set default OPENSSL_CONF path for rsync]))\ncase \"$with_openssl_conf\" in\n    *[^-/a-zA-Z0-9.,=@+_]*) AC_MSG_ERROR([Invalid path given to --with-openssl-conf]) ;;\n    /*) CFLAGS=\"$CFLAGS -DSET_OPENSSL_CONF=$with_openssl_conf\" ;;\n    no|'') ;;\n    yes) AC_MSG_ERROR([No path given to --with-openssl-conf]) ;;\n    *) AC_MSG_ERROR([Non absolute path given to --with-openssl-conf]) ;;\nesac\n\nAC_ARG_WITH(rrsync,\n        AS_HELP_STRING([--with-rrsync],[also install the rrsync script and its manpage]))\nif test x\"$with_rrsync\" != x\"yes\"; then\n    with_rrsync=no\nelse\n    MAKE_RRSYNC='rrsync'\n    MAKE_RRSYNC_1='rrsync.1'\n    GEN_RRSYNC='rrsync.1 rrsync.1.html'\nfi\nAC_SUBST(with_rrsync)\n\nAC_ARG_WITH(included-popt,\n        AS_HELP_STRING([--with-included-popt],[use bundled popt library, not from system]))\n\nAC_ARG_WITH(included-zlib,\n        AS_HELP_STRING([--with-included-zlib],[use bundled zlib library, not from system]))\n\nAC_ARG_WITH(secluded-args,\n        AS_HELP_STRING([--with-secluded-args],[make --secluded-args option the default]))\nif test x\"$with_secluded_args\" = x\"yes\"; then\n\tAC_DEFINE_UNQUOTED(RSYNC_USE_SECLUDED_ARGS, 1, [Define to 1 if --secluded-args should be the default])\nfi\n\nAC_ARG_WITH(rsync-path,\n\tAS_HELP_STRING([--with-rsync-path=PATH],[set default --rsync-path to PATH (default: rsync)]),\n\t[ RSYNC_PATH=\"$with_rsync_path\" ],\n\t[ RSYNC_PATH=\"rsync\" ])\n\nAC_DEFINE_UNQUOTED(RSYNC_PATH, \"$RSYNC_PATH\", [location of rsync on remote machine])\n\nAC_ARG_WITH(rsyncd-conf,\n\tAS_HELP_STRING([--with-rsyncd-conf=PATH],[set configuration file for rsync server to PATH (default: /etc/rsyncd.conf)]),\n\t[ if test ! -z \"$with_rsyncd_conf\" ; then\n\t\tcase $with_rsyncd_conf in\n\t\t\tyes|no)\n\t\t\t\tRSYNCD_SYSCONF=\"/etc/rsyncd.conf\"\n\t\t\t\t;;\n\t\t\t/*)\n\t\t\t\tRSYNCD_SYSCONF=\"$with_rsyncd_conf\"\n\t\t\t\t;;\n\t\t\t*)\n                                AC_MSG_ERROR(You must specify an absolute path to --with-rsyncd-conf=PATH)\n\t\t\t\t;;\n\t\tesac\n\telse\n\t\tRSYNCD_SYSCONF=\"/etc/rsyncd.conf\"\n\tfi ],\n\t[ RSYNCD_SYSCONF=\"/etc/rsyncd.conf\" ])\n\nAC_DEFINE_UNQUOTED(RSYNCD_SYSCONF, \"$RSYNCD_SYSCONF\", [location of configuration file for rsync server])\n\nAC_ARG_WITH(rsh,\n\tAS_HELP_STRING([--with-rsh=CMD],[set remote shell command to CMD (default: ssh)]))\n\nAC_CHECK_PROG(HAVE_REMSH, remsh, 1, 0)\nif test x$HAVE_REMSH = x1; then\n\tAC_DEFINE(HAVE_REMSH, 1, [Define to 1 if remote shell is remsh, not rsh])\nfi\n\nif test x\"$with_rsh\" != x; then\n\tRSYNC_RSH=\"$with_rsh\"\nelse\n\tRSYNC_RSH=\"ssh\"\nfi\nAC_DEFINE_UNQUOTED(RSYNC_RSH, \"$RSYNC_RSH\", [default -e command])\n\n# Some programs on solaris are only found in /usr/xpg4/bin (or work better than others versions).\nAC_PATH_PROG(SHELL_PATH, sh, /bin/sh, [/usr/xpg4/bin$PATH_SEPARATOR$PATH])\nAC_PATH_PROG(FAKEROOT_PATH, fakeroot, /usr/bin/fakeroot, [/usr/xpg4/bin$PATH_SEPARATOR$PATH])\n\nAC_ARG_WITH(nobody-user,\n    AS_HELP_STRING([--with-nobody-user=USER],[set the default unprivileged user (default nobody)]),\n    [ NOBODY_USER=\"$with_nobody_user\" ],\n    [ NOBODY_USER=\"nobody\" ])\n\nAC_ARG_WITH(nobody-group,\n    AS_HELP_STRING([--with-nobody-group=GROUP],[set the default unprivileged group (default nobody or nogroup)]),\n    [ NOBODY_GROUP=\"$with_nobody_group\" ])\n\nif test x\"$with_nobody_group\" = x; then\n    AC_MSG_CHECKING([the group for user \"nobody\"])\n    if grep '^nobody:' /etc/group >/dev/null 2>&1; then\n\tNOBODY_GROUP=nobody\n    elif grep '^nogroup:' /etc/group >/dev/null 2>&1; then\n\tNOBODY_GROUP=nogroup\n    else\n\tNOBODY_GROUP=nobody # test for others?\n    fi\n    AC_MSG_RESULT($NOBODY_GROUP)\nfi\n\nAC_DEFINE_UNQUOTED(NOBODY_USER, \"$NOBODY_USER\", [unprivileged user--e.g. nobody])\nAC_DEFINE_UNQUOTED(NOBODY_GROUP, \"$NOBODY_GROUP\", [unprivileged group for unprivileged user])\n\n# rolling-checksum SIMD optimizations\nROLL_SIMD=\n\nAC_MSG_CHECKING([whether to enable rolling-checksum SIMD optimizations])\nAC_ARG_ENABLE(roll-simd,\n    AS_HELP_STRING([--enable-roll-simd],[enable/disable to control rolling-checksum SIMD optimizations (requires c++)]))\n\n# Clag is crashing with -g -O2, so we'll get rid of -g for now.\nCXXFLAGS=`echo \"$CXXFLAGS\" | sed 's/-g //'`\nm4_define(SIMD_X86_64_TEST, [[#include <stdio.h>\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <immintrin.h>\n__attribute__ ((target(\"default\"))) int test_ssse3(int x) { return x; }\n__attribute__ ((target(\"default\"))) int test_sse2(int x) { return x; }\n__attribute__ ((target(\"default\"))) int test_avx2(int x) { return x; }\n__attribute__ ((target(\"ssse3\"))) int test_ssse3(int x) { return x; }\n__attribute__ ((target(\"sse2\"))) int test_sse2(int x) { return x; }\n__attribute__ ((target(\"avx2\"))) int test_avx2(int x) { return x; }\ntypedef long long __m128i_u __attribute__((__vector_size__(16), __may_alias__, __aligned__(1)));\ntypedef long long __m256i_u __attribute__((__vector_size__(32), __may_alias__, __aligned__(1)));\n__attribute__ ((target(\"default\"))) void more_testing(char* buf, int len) { }\n__attribute__ ((target(\"ssse3\"))) void more_testing(char* buf, int len)\n{\n    int i;\n    for (i = 0; i < (len-32); i+=32) {\n\t__m128i in8_1, in8_2;\n\tin8_1 = _mm_lddqu_si128((__m128i_u*)&buf[i]);\n\tin8_2 = _mm_lddqu_si128((__m128i_u*)&buf[i + 16]);\n    }\n}\n]])\n\nif test x\"$enable_roll_simd\" = x\"\"; then\n    case \"$host_os\" in\n\t*linux*) ;;\n\t*) enable_roll_simd=no ;;\n    esac\nfi\n\nif test x\"$enable_roll_simd\" != x\"no\"; then\n    # For x86-64 SIMD, g++ >=5 or clang++ >=7 is required\n    if test x\"$host_cpu\" = x\"x86_64\" || test x\"$host_cpu\" = x\"amd64\"; then\n\tAC_LANG(C++)\n\tif test x\"$host\" = x\"$build\"; then\n\t    AC_RUN_IFELSE([AC_LANG_PROGRAM([SIMD_X86_64_TEST],[[if (test_ssse3(42) != 42 || test_sse2(42) != 42 || test_avx2(42) != 42) exit(1);]])],\n\t\t[CXX_OK=yes],[CXX_OK=no])\n\telse\n\t    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([SIMD_X86_64_TEST])],[CXX_OK=yes],[CXX_OK=no])\n\tfi\n\tAC_LANG(C)\n\tif test x\"$CXX_OK\" = x\"yes\"; then\n\t    # AC_MSG_RESULT() is called below.\n\t    ROLL_SIMD=\"$host_cpu\"\n\telif test x\"$enable_roll_simd\" = x\"yes\"; then\n\t    AC_MSG_RESULT(error)\n\t    AC_MSG_ERROR(The rolling-checksum SIMD compilation test failed.\nOmit --enable-roll-simd to continue without it.)\n\tfi\n    elif test x\"$enable_roll_simd\" = x\"yes\"; then\n        AC_MSG_RESULT(unavailable)\n        AC_MSG_ERROR(The rolling-checksum SIMD optimizations are currently x86_64|amd64 only.\nOmit --enable-roll-simd to continue without it.)\n    fi\nfi\n\nif test x\"$ROLL_SIMD\" != x\"\"; then\n    AC_MSG_RESULT([yes ($ROLL_SIMD)])\n    AC_DEFINE(USE_ROLL_SIMD, 1, [Define to 1 to enable rolling-checksum SIMD optimizations])\n    ROLL_SIMD='$(ROLL_SIMD_'\"$ROLL_SIMD)\"\n    # We only use c++ for its target attribute dispatching, disable unneeded bulky features\n    CXXFLAGS=\"$CXXFLAGS -fno-exceptions -fno-rtti\"\n    # Apple often has \"g++\" as a symlink for clang. Try to find out the truth.\n    CXX_VERSION=`$CXX --version 2>/dev/null | head -n 2`\n    case \"$CXX_VERSION\" in\n    *clang*) CXXFLAGS=\"$CXXFLAGS -fno-slp-vectorize\" ;; # avoid a performance hit\n    esac\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(ROLL_SIMD)\n\nAC_MSG_CHECKING([if assembler accepts noexecstack])\nOLD_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Wa,--noexecstack\"\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ ]], [[return 0;]])],\n[ NOEXECSTACK='-Wa,--noexecstack' ; AC_MSG_RESULT(yes) ],\n[ NOEXECSTACK='' ; AC_MSG_RESULT(no) ])\nCFLAGS=\"$OLD_CFLAGS\"\nAC_SUBST(NOEXECSTACK)\n\n# arrgh. libc in some old debian version screwed up the largefile\n# stuff, getting byte range locking wrong\nAC_CACHE_CHECK([for broken largefile support],rsync_cv_HAVE_BROKEN_LARGEFILE,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#define _FILE_OFFSET_BITS 64\n$ac_includes_default\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#elif defined HAVE_SYS_FCNTL_H\n# include <sys/fcntl.h>\n#endif\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n\nint main(void)\n{\n\tstruct flock lock;\n\tint status;\n\tchar tpl[32] = \"/tmp/locktest.XXXXXX\";\n\tint fd = mkstemp(tpl);\n\tif (fd < 0) {\n\t\tstrcpy(tpl, \"conftest.dat\");\n\t\tfd = open(tpl, O_CREAT|O_RDWR, 0600);\n\t}\n\n\tlock.l_type = F_WRLCK;\n\tlock.l_whence = SEEK_SET;\n\tlock.l_start = 0;\n\tlock.l_len = 1;\n\tlock.l_pid = 0;\n\tfcntl(fd,F_SETLK,&lock);\n\tif (fork() == 0) {\n\t\tlock.l_start = 1;\n\t\t_exit(fcntl(fd,F_SETLK,&lock) == 0);\n\t}\n\twait(&status);\n\tunlink(tpl);\n\treturn WEXITSTATUS(status);\n}\n]])],[rsync_cv_HAVE_BROKEN_LARGEFILE=yes],[rsync_cv_HAVE_BROKEN_LARGEFILE=no],[rsync_cv_HAVE_BROKEN_LARGEFILE=cross])])\nif test x\"$rsync_cv_HAVE_BROKEN_LARGEFILE\" != x\"yes\"; then\n   AC_SYS_LARGEFILE\nfi\n\nAC_MSG_CHECKING([whether to enable ipv6])\nAC_ARG_ENABLE(ipv6,\nAS_HELP_STRING([--disable-ipv6],[disable to omit ipv6 support]),\n[ case \"$enableval\" in\n  no)\n\tAC_MSG_RESULT(no)\n\t;;\n  *)\tAC_MSG_RESULT(yes)\n\tAC_DEFINE(INET6, 1, [true if you have IPv6])\n\t;;\n  esac ],\n\n  AC_RUN_IFELSE([AC_LANG_SOURCE([[ /* AF_INET6 availability check */\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/socket.h>\nint main()\n{\n   if (socket(AF_INET6, SOCK_STREAM, 0) < 0)\n     exit(1);\n   else\n     exit(0);\n}\n]])],\n  [AC_MSG_RESULT(yes)\n  AC_DEFINE(INET6, 1, true if you have IPv6)],\n  [AC_MSG_RESULT(no)],\n  [AC_MSG_RESULT(no)]\n))\n\ndnl Do you want to disable use of locale functions\nAC_ARG_ENABLE([locale],\n\tAS_HELP_STRING([--disable-locale],[disable to omit locale features]))\nAH_TEMPLATE([CONFIG_LOCALE],\n[Undefine if you do not want locale features.  By default this is defined.])\nif test x\"$enable_locale\" != x\"no\"; then\n\tAC_DEFINE(CONFIG_LOCALE)\nfi\n\nAC_MSG_CHECKING([whether to call shutdown on all sockets])\ncase $host_os in\n\t*cygwin* ) AC_MSG_RESULT(yes)\n                   AC_DEFINE(SHUTDOWN_ALL_SOCKETS, 1,\n\t\t\t    [Define to 1 if sockets need to be shutdown])\n\t\t   ;;\n\t       * ) AC_MSG_RESULT(no);;\nesac\n\n# We default to using our zlib unless --with-included-zlib=no is given.\nif test x\"$with_included_zlib\" != x\"no\"; then\n    with_included_zlib=yes\nelif test x\"$ac_cv_header_zlib_h\" != x\"yes\"; then\n    with_included_zlib=yes\nfi\nif test x\"$with_included_zlib\" != x\"yes\"; then\n    AC_CHECK_LIB(z, deflateParams, , [with_included_zlib=yes])\nfi\n\nAC_MSG_CHECKING([whether to use included zlib])\nif test x\"$with_included_zlib\" = x\"yes\"; then\n    AC_MSG_RESULT($srcdir/zlib)\n    BUILD_ZLIB='$(zlib_OBJS)'\n    CFLAGS=\"-I$srcdir/zlib $CFLAGS\"\nelse\n    AC_DEFINE(EXTERNAL_ZLIB, 1, [Define to 1 if using external zlib])\n    AC_MSG_RESULT(no)\nfi\n\nAC_MSG_CHECKING([whether to enable use of openssl crypto library])\nAC_ARG_ENABLE([openssl],\n\tAS_HELP_STRING([--disable-openssl],[disable to omit openssl crypto library]))\nAH_TEMPLATE([USE_OPENSSL],\n[Undefine if you do not want to use openssl crypto library.  By default this is defined.])\nif test x\"$enable_openssl\" != x\"no\"; then\n    if test x\"$ac_cv_header_openssl_md4_h\" = x\"yes\" && test x\"$ac_cv_header_openssl_md5_h\" = x\"yes\"; then\n      AC_MSG_RESULT(yes)\n      AC_SEARCH_LIBS(EVP_MD_CTX_copy, crypto,\n          [AC_DEFINE(USE_OPENSSL)\n\t   enable_openssl=yes],\n          [err_msg=\"$err_msg$nl- Failed to find EVP_MD_CTX_copy function in openssl crypto lib.\";\n\t   no_lib=\"$no_lib openssl\"])\n    else\n        AC_MSG_RESULT(no)\n\terr_msg=\"$err_msg$nl- Failed to find openssl/md4.h and openssl/md5.h for openssl crypto lib support.\"\n\tno_lib=\"$no_lib openssl\"\n    fi\n    if test x\"$enable_md5_asm\" != x\"yes\"; then\n\tenable_md5_asm=no\n    fi\nelse\n    AC_MSG_RESULT(no)\nfi\n\nMD5_ASM=\n\nAC_MSG_CHECKING([whether to enable MD5 ASM optimizations])\nAC_ARG_ENABLE(md5-asm,\n    AS_HELP_STRING([--enable-md5-asm],[enable/disable to control MD5 ASM optimizations]))\n\nif test x\"$enable_md5_asm\" = x\"\"; then\n    case \"$host_os\" in\n\t*linux*) ;;\n\t*) enable_md5_asm=no ;;\n    esac\nfi\n\nif test x\"$enable_md5_asm\" != x\"no\"; then\n    if test x\"$host_cpu\" = x\"x86_64\" || test x\"$host_cpu\" = x\"amd64\"; then\n\tMD5_ASM=\"$host_cpu\"\n    elif test x\"$enable_md5_asm\" = x\"yes\"; then\n        AC_MSG_RESULT(unavailable)\n        AC_MSG_ERROR(The ASM optimizations are currently x86_64|amd64 only.\nOmit --enable-md5-asm to continue without it.)\n    fi\nfi\n\nif test x\"$MD5_ASM\" != x\"\"; then\n    AC_MSG_RESULT([yes ($MD5_ASM)])\n    AC_DEFINE(USE_MD5_ASM, 1, [Define to 1 to enable MD5 ASM optimizations])\n    MD5_ASM='$(MD5_ASM_'\"$MD5_ASM)\"\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(MD5_ASM)\n\nROLL_ASM=\n\nAC_MSG_CHECKING([whether to enable rolling-checksum ASM optimizations])\nAC_ARG_ENABLE(roll-asm,\n    AS_HELP_STRING([--enable-roll-asm],[enable/disable to control rolling-checksum ASM optimizations (requires --enable-roll-simd)]))\n\nif test x\"$ROLL_SIMD\" = x\"\"; then\n    enable_roll_asm=no\nfi\n\nif test x\"$enable_roll_asm\" = x\"yes\"; then\n    ROLL_ASM=\"$host_cpu\"\n    AC_MSG_RESULT([yes ($ROLL_ASM)])\n    AC_DEFINE(USE_ROLL_ASM, 1, [Define to 1 to enable rolling-checksum ASM optimizations (requires --enable-roll-simd)])\n    ROLL_ASM='$(ROLL_ASM_'\"$ROLL_ASM)\"\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(ROLL_ASM)\n\nAC_MSG_CHECKING([whether to enable xxhash checksum support])\nAC_ARG_ENABLE([xxhash],\n\tAS_HELP_STRING([--disable-xxhash],[disable to omit xxhash checksums]))\nAH_TEMPLATE([SUPPORT_XXHASH],\n[Undefine if you do not want xxhash checksums.  By default this is defined.])\nif test x\"$enable_xxhash\" != x\"no\"; then\n    if test x\"$ac_cv_header_xxhash_h\" = x\"yes\"; then\n\tAC_MSG_RESULT(yes)\n\tAC_SEARCH_LIBS(XXH64_createState, xxhash,\n\t    [AC_DEFINE(SUPPORT_XXHASH)],\n\t    [err_msg=\"$err_msg$nl- Failed to find XXH64_createState function in xxhash lib.\";\n\t     no_lib=\"$no_lib xxhash\"])\n    else\n\tAC_MSG_RESULT(no)\n\terr_msg=\"$err_msg$nl- Failed to find xxhash.h for xxhash checksum support.\";\n\tno_lib=\"$no_lib xxhash\"\n    fi\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_MSG_CHECKING([whether to enable zstd compression])\nAC_ARG_ENABLE([zstd],\n        AS_HELP_STRING([--disable-zstd], [disable to omit zstd compression]))\nAH_TEMPLATE([SUPPORT_ZSTD],\n[Undefine if you do not want zstd compression.  By default this is defined.])\nif test x\"$enable_zstd\" != x\"no\"; then\n    if test x\"$ac_cv_header_zstd_h\" = x\"yes\"; then\n\tAC_MSG_RESULT(yes)\n\tAC_SEARCH_LIBS(ZSTD_minCLevel, zstd,\n\t    [AC_DEFINE(SUPPORT_ZSTD)],\n\t    [err_msg=\"$err_msg$nl- Failed to find ZSTD_minCLevel function in zstd lib.\";\n\t     no_lib=\"$no_lib zstd\"])\n    else\n\tAC_MSG_RESULT(no)\n\terr_msg=\"$err_msg$nl- Failed to find zstd.h for zstd compression support.\";\n\tno_lib=\"$no_lib zstd\"\n    fi\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_MSG_CHECKING([whether to enable LZ4 compression])\nAC_ARG_ENABLE([lz4],\n        AS_HELP_STRING([--disable-lz4], [disable to omit LZ4 compression]))\nAH_TEMPLATE([SUPPORT_LZ4],\n[Undefine if you do not want LZ4 compression.  By default this is defined.])\nif test x\"$enable_lz4\" != x\"no\"; then\n    if test x\"$ac_cv_header_lz4_h\" = x\"yes\"; then\n\tAC_MSG_RESULT(yes)\n\tAC_SEARCH_LIBS(LZ4_compress_default, lz4,\n\t    [AC_DEFINE(SUPPORT_LZ4)],\n\t    [err_msg=\"$err_msg$nl- Failed to find LZ4_compress_default function in lz4 lib.\";\n\t     no_lib=\"$no_lib lz4\"])\n    else\n\tAC_MSG_RESULT(no)\n\terr_msg=\"$err_msg$nl- Failed to find lz4.h for lz4 compression support.\"\n\tno_lib=\"$no_lib lz4\"\n    fi\nelse\n    AC_MSG_RESULT(no)\nfi\n\nif test x\"$no_lib\" != x; then\n    echo \"\"\n    echo \"Configure found the following issues:\"\n    echo \"$err_msg\"\n    echo \"\"\n    echo \"See the INSTALL file for hints on how to install the missing libraries and/or\"\n    echo \"how to generate (or fetch) manpages:\"\n    echo \"    https://github.com/RsyncProject/rsync/blob/master/INSTALL.md\"\n    echo \"\"\n    echo \"To disable one or more features, the relevant configure options are:\"\n    for lib in $no_lib; do\n\techo \"    --disable-$lib\"\n    done\n    echo \"\"\n    AC_MSG_ERROR(Aborting configure run)\nfi\n\nAC_CACHE_CHECK([if makedev takes 3 args],rsync_cv_MAKEDEV_TAKES_3_ARGS,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef MAJOR_IN_MKDEV\n#include <sys/mkdev.h>\n# if !defined makedev && (defined mkdev || defined _WIN32 || defined __WIN32__)\n#  define makedev mkdev\n# endif\n#elif defined MAJOR_IN_SYSMACROS\n#include <sys/sysmacros.h>\n#endif\n\nint main(void)\n{\n\tdev_t dev = makedev(0, 5, 7);\n\tif (major(dev) != 5 || minor(dev) != 7)\n\t\treturn 1;\n\treturn 0;\n}\n]])],[rsync_cv_MAKEDEV_TAKES_3_ARGS=yes],[rsync_cv_MAKEDEV_TAKES_3_ARGS=no],[rsync_cv_MAKEDEV_TAKES_3_ARGS=no])])\nif test x\"$rsync_cv_MAKEDEV_TAKES_3_ARGS\" = x\"yes\"; then\n   AC_DEFINE(MAKEDEV_TAKES_3_ARGS, 1, [Define to 1 if makedev() takes 3 args])\nfi\n\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(long)\nAC_CHECK_SIZEOF(long long)\nAC_CHECK_SIZEOF(short)\nAC_CHECK_SIZEOF(int16_t)\nAC_CHECK_SIZEOF(uint16_t)\nAC_CHECK_SIZEOF(int32_t)\nAC_CHECK_SIZEOF(uint32_t)\nAC_CHECK_SIZEOF(int64_t)\nAC_CHECK_SIZEOF(off_t)\nAC_CHECK_SIZEOF(off64_t)\nAC_CHECK_SIZEOF(time_t)\nAC_CHECK_SIZEOF(char*)\n\nAC_C_INLINE\n\nAC_TYPE_LONG_DOUBLE_WIDER\nac_cv_c_long_double=$ac_cv_type_long_double_wider\nif test $ac_cv_c_long_double = yes; then\n  AC_DEFINE([HAVE_LONG_DOUBLE],[1],[Define to 1 if the type `long double' works and has more range or precision than `double'.])\nfi\n\nAC_TYPE_UID_T\nAC_CHECK_TYPES([mode_t,off_t,size_t,pid_t,id_t])\nif test \"$cross_compiling\" = no; then\n    AC_TYPE_GETGROUPS\nelse\n    AC_DEFINE([GETGROUPS_T],[gid_t],[Define to the type of elements in the array set by `getgroups'. Usually this is either `int' or `gid_t'.])\nfi\nAC_CHECK_MEMBERS([struct stat.st_rdev,\n\t\t  struct stat.st_mtimensec,\n\t\t  struct stat.st_mtimespec.tv_nsec,\n\t\t  struct stat.st_mtim.tv_nsec],,,[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif])\n\nTYPE_SOCKLEN_T\n\nAC_CACHE_CHECK([for errno in errno.h],rsync_cv_errno, [\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <errno.h>]], [[int i = errno]])],[rsync_cv_errno=yes],[rsync_cv_have_errno_decl=no])])\nif test x\"$rsync_cv_errno\" = x\"yes\"; then\n   AC_DEFINE(HAVE_ERRNO_DECL, 1, [Define to 1 if errno is declared in errno.h])\nfi\n\n# The following test taken from the cvs sources\n# If we can't find connect, try looking in -lsocket, -lnsl, and -linet.\n# These need checks to be before checks for any other functions that\n#    might be in the same libraries.\n# The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has\n# libsocket.so which has a bad implementation of gethostbyname (it\n# only looks in /etc/hosts), so we only look for -lsocket if we need\n# it.\nAC_CHECK_FUNCS(connect)\nif test x\"$ac_cv_func_connect\" = x\"no\"; then\n    case \"$LIBS\" in\n    *-lnsl*) ;;\n    *) AC_CHECK_LIB(nsl_s, printf) ;;\n    esac\n    case \"$LIBS\" in\n    *-lnsl*) ;;\n    *) AC_CHECK_LIB(nsl, printf) ;;\n    esac\n    case \"$LIBS\" in\n    *-lsocket*) ;;\n    *) AC_CHECK_LIB(socket, connect) ;;\n    esac\n    case \"$LIBS\" in\n    *-linet*) ;;\n    *) AC_CHECK_LIB(inet, connect) ;;\n    esac\n    dnl We can't just call AC_CHECK_FUNCS(connect) here, because the value\n    dnl has been cached.\n    if test x\"$ac_cv_lib_socket_connect\" = x\"yes\" ||\n       test x\"$ac_cv_lib_inet_connect\" = x\"yes\"; then\n        # ac_cv_func_connect=yes\n        # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run\n        AC_DEFINE(HAVE_CONNECT, 1, [Define to 1 if you have the \"connect\" function])\n    fi\nfi\n\nAC_SEARCH_LIBS(inet_ntop, resolv)\n\n# For OS X, Solaris, HP-UX, etc.: figure out if -liconv is needed.  We'll\n# accept either iconv_open or libiconv_open, since some include files map\n# the former to the latter.\nAC_SEARCH_LIBS(iconv_open, iconv)\nAC_SEARCH_LIBS(libiconv_open, iconv)\n\nAC_MSG_CHECKING([for iconv declaration])\nAC_CACHE_VAL(am_cv_proto_iconv, [\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <iconv.h>\nextern\n#ifdef __cplusplus\n\"C\"\n#endif\n#if defined(__STDC__) || defined(__cplusplus)\nsize_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n#else\nsize_t iconv();\n#endif\n]], [[]])],[am_cv_proto_iconv_arg1=\"\"],[am_cv_proto_iconv_arg1=\"const\"])\n      am_cv_proto_iconv=\"extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\"])\n    am_cv_proto_iconv=`echo \"[$]am_cv_proto_iconv\" | tr -s ' ' | sed 's/( /(/'`\nAC_MSG_RESULT([$]{ac_t:-\n         }[$]am_cv_proto_iconv)\nAC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,\n\t\t   [Define as const if the declaration of iconv() needs const.])\n\ndnl AC_MSG_NOTICE([Looking in libraries: $LIBS])\n\nAC_REPLACE_FUNCS([inet_ntop inet_pton])\n\nAC_HAVE_TYPE([struct addrinfo], [#include <netdb.h>])\nAC_HAVE_TYPE([struct sockaddr_storage], [\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif])\n\n# Irix 6.5 has getaddrinfo but not the corresponding defines, so use\n#   builtin getaddrinfo if one of the defines don't exist\nAC_CACHE_CHECK([whether defines needed by getaddrinfo exist],\n               rsync_cv_HAVE_GETADDR_DEFINES,[\n\t\t\tAC_EGREP_CPP(yes, [\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef AI_PASSIVE\nyes\n#endif],\n\t\t\trsync_cv_HAVE_GETADDR_DEFINES=yes,\n\t\t\trsync_cv_HAVE_GETADDR_DEFINES=no)])\nAS_IF([test x\"$rsync_cv_HAVE_GETADDR_DEFINES\" = x\"yes\" && test x\"$ac_cv_type_struct_addrinfo\" = x\"yes\"],[\n\t# Tru64 UNIX has getaddrinfo() but has it renamed in libc as\n\t# something else so we must include <netdb.h> to get the\n\t# redefinition.\n\tAC_CHECK_FUNCS(getaddrinfo, ,\n\t\t[AC_MSG_CHECKING([for getaddrinfo by including <netdb.h>])\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#include <netdb.h>]], [[getaddrinfo(NULL, NULL, NULL, NULL);]])],[AC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE(HAVE_GETADDRINFO, 1,\n\t\t\t\t[Define to 1 if you have the \"getaddrinfo\" function and required types.])],[AC_MSG_RESULT([no])\n\t\t\tAC_LIBOBJ([getaddrinfo])])])\n    ],[AC_LIBOBJ([getaddrinfo])])\n\nAC_CHECK_MEMBER([struct sockaddr.sa_len],\n\t\t[ AC_DEFINE(HAVE_SOCKADDR_LEN, 1, [Do we have sockaddr.sa_len?]) ],\n\t\t[],\n\t\t[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n])\n\nAC_CHECK_MEMBER([struct sockaddr_in.sin_len],\n\t\t[ AC_DEFINE(HAVE_SOCKADDR_IN_LEN, 1, [Do we have sockaddr_in.sin_len?]) ],\n\t\t[],\n\t\t[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#include <netinet/in.h>\n])\n\nAC_CHECK_MEMBER([struct sockaddr_un.sun_len],\n\t\t[ AC_DEFINE(HAVE_SOCKADDR_UN_LEN, 1, [Do we have sockaddr_un.sun_len?]) ],\n\t\t[],\n\t\t[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#include <netinet/in.h>\n])\n\nAC_CHECK_MEMBER([struct sockaddr_in6.sin6_scope_id],\n\t\t[ AC_DEFINE(HAVE_SOCKADDR_IN6_SCOPE_ID, 1, [Do we have sockaddr_in6.sin6_scope_id?]) ],\n\t\t[],\n\t\t[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#include <netinet/in.h>\n])\n\nAC_HAVE_TYPE([struct stat64], [#include <stdio.h>\n#if HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#if HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#if STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#else\n# if HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif\n])\n\n# if we can't find strcasecmp, look in -lresolv (for Unixware at least)\n#\nAC_CHECK_FUNCS(strcasecmp)\nif test x\"$ac_cv_func_strcasecmp\" = x\"no\"; then\n    AC_CHECK_LIB(resolv, strcasecmp)\nfi\n\nAC_CHECK_FUNCS(aclsort)\nif test x\"$ac_cv_func_aclsort\" = x\"no\"; then\n    AC_CHECK_LIB(sec, aclsort)\nfi\n\ndnl At the moment we don't test for a broken memcmp(), because all we\ndnl need to do is test for equality, not comparison, and it seems that\ndnl every platform has a memcmp that can do at least that.\ndnl AC_FUNC_MEMCMP\n\nAC_FUNC_UTIME_NULL\nAC_FUNC_ALLOCA\nAC_CHECK_FUNCS(waitpid wait4 getcwd chown chmod lchmod mknod mkfifo \\\n    fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \\\n    chflags getattrlist mktime innetgr linkat \\\n    memmove lchown vsnprintf snprintf vasprintf asprintf setsid strpbrk \\\n    strlcat strlcpy stpcpy strtol mallinfo mallinfo2 getgroups setgroups geteuid getegid \\\n    setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \\\n    seteuid strerror putenv iconv_open locale_charset nl_langinfo getxattr \\\n    extattr_get_link sigaction sigprocmask setattrlist getgrouplist \\\n    initgroups utimensat posix_fallocate attropen setvbuf nanosleep usleep \\\n    setenv unsetenv)\n\ndnl cygwin iconv.h defines iconv_open as libiconv_open\nif test x\"$ac_cv_func_iconv_open\" != x\"yes\"; then\n    AC_CHECK_FUNC(libiconv_open, [ac_cv_func_iconv_open=yes; AC_DEFINE(HAVE_ICONV_OPEN, 1)])\nfi\n\ndnl Preallocation stuff (also fallocate, posix_fallocate function tests above):\n\nAC_CACHE_CHECK([for useable fallocate],rsync_cv_have_fallocate,[\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <fcntl.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif]], [[fallocate(0, 0, 0, 0);]])],[rsync_cv_have_fallocate=yes],[rsync_cv_have_fallocate=no])])\nif test x\"$rsync_cv_have_fallocate\" = x\"yes\"; then\n    AC_DEFINE(HAVE_FALLOCATE, 1, [Define to 1 if you have the fallocate function and it compiles and links without error])\nfi\n\nAC_MSG_CHECKING([for FALLOC_FL_PUNCH_HOLE])\nAC_PREPROC_IFELSE([AC_LANG_SOURCE([[\n        #define _GNU_SOURCE 1\n        #include <linux/falloc.h>\n        #ifndef FALLOC_FL_PUNCH_HOLE\n        #error FALLOC_FL_PUNCH_HOLE is missing\n        #endif\n    ]])], [\n        AC_MSG_RESULT([yes])\n        AC_DEFINE([HAVE_FALLOC_FL_PUNCH_HOLE], [1], [Define if FALLOC_FL_PUNCH_HOLE is available.])\n    ], [\n        AC_MSG_RESULT([no])\n    ]\n)\n\nAC_MSG_CHECKING([for FALLOC_FL_ZERO_RANGE])\nAC_PREPROC_IFELSE([AC_LANG_SOURCE([[\n        #define _GNU_SOURCE 1\n        #include <linux/falloc.h>\n        #ifndef FALLOC_FL_ZERO_RANGE\n        #error FALLOC_FL_ZERO_RANGE is missing\n        #endif\n    ]])], [\n        AC_MSG_RESULT([yes])\n        AC_DEFINE([HAVE_FALLOC_FL_ZERO_RANGE], [1], [Define if FALLOC_FL_ZERO_RANGE is available.])\n    ], [\n        AC_MSG_RESULT([no])\n    ]\n)\n\nAC_CACHE_CHECK([for SYS_fallocate],rsync_cv_have_sys_fallocate,[\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/syscall.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif]], [[syscall(SYS_fallocate, 0, 0, (loff_t)0, (loff_t)0);]])],[rsync_cv_have_sys_fallocate=yes],[rsync_cv_have_sys_fallocate=no])])\nif test x\"$rsync_cv_have_sys_fallocate\" = x\"yes\"; then\n    AC_DEFINE(HAVE_SYS_FALLOCATE, 1, [Define to 1 if you have the SYS_fallocate syscall number])\nfi\n\nif test x\"$ac_cv_func_posix_fallocate\" = x\"yes\"; then\n    AC_MSG_CHECKING([whether posix_fallocate is efficient])\n    case $host_os in\n    *cygwin*)\n\tAC_MSG_RESULT(yes)\n\tAC_DEFINE(HAVE_EFFICIENT_POSIX_FALLOCATE, 1,\n\t\t  [Define if posix_fallocate is efficient (Cygwin)])\n\t;;\n    *)\n\tAC_MSG_RESULT(no)\n\t;;\n    esac\nfi\n\ndnl End of preallocation stuff\n\nAC_CHECK_FUNCS(getpgrp tcgetpgrp)\nif test $ac_cv_func_getpgrp = yes; then\n    AC_FUNC_GETPGRP\nfi\n\nAC_ARG_ENABLE(iconv-open,\n    AS_HELP_STRING([--disable-iconv-open],[disable to avoid all use of iconv_open()]),\n    [], [enable_iconv_open=$ac_cv_func_iconv_open])\n\nif test x\"$enable_iconv_open\" != x\"no\"; then\n    AC_DEFINE(USE_ICONV_OPEN, 1, [Define to 1 if you want rsync to make use of iconv_open()])\nfi\n\nAC_ARG_ENABLE(iconv,\n    AS_HELP_STRING([--disable-iconv],[disable to omit the --iconv option]),\n    [], [enable_iconv=$enable_iconv_open])\nAH_TEMPLATE([ICONV_OPTION],\n[Define if you want the --iconv option.  Specifying a value will set the\ndefault iconv setting (a NULL means no --iconv processing by default).])\nif test x\"$enable_iconv\" != x\"no\"; then\n\tif test x\"$enable_iconv\" = x\"yes\"; then\n\t\tAC_DEFINE(ICONV_OPTION, NULL)\n\telse\n\t\tAC_DEFINE_UNQUOTED(ICONV_OPTION, \"$enable_iconv\")\n\tfi\n\tAC_DEFINE(UTF8_CHARSET, \"UTF-8\", [String to pass to iconv() for the UTF-8 charset.])\nfi\n\nAC_CACHE_CHECK([whether chown() modifies symlinks],rsync_cv_chown_modifies_symlink,[\n  AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#if HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#include <stdlib.h>\n#include <errno.h>\nint main(void) {\n\tchar const *dangling_symlink = \"conftest.dangle\";\n\tunlink(dangling_symlink);\n\tif (symlink(\"conftest.no-such\", dangling_symlink) < 0) abort();\n\tif (chown(dangling_symlink, getuid(), getgid()) < 0 && errno == ENOENT) return 1;\n\treturn 0;\n    }]])],[rsync_cv_chown_modifies_symlink=yes],[rsync_cv_chown_modifies_symlink=no],[rsync_cv_chown_modifies_symlink=no])])\nif test $rsync_cv_chown_modifies_symlink = yes; then\n  AC_DEFINE(CHOWN_MODIFIES_SYMLINK, 1, [Define to 1 if chown modifies symlinks.])\nfi\n\nAC_CACHE_CHECK([whether link() can hard-link symlinks],rsync_cv_can_hardlink_symlink,[\n  AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#elif defined HAVE_SYS_FCNTL_H\n# include <sys/fcntl.h>\n#endif\n#if HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#include <stdlib.h>\n#include <errno.h>\n#define FILENAME \"conftest.dangle\"\nint main(void) {\n\tunlink(FILENAME);\n\tif (symlink(\"conftest.no-such\", FILENAME) < 0) abort();\n\tunlink(FILENAME \"2\");\n#ifdef HAVE_LINKAT\n\tif (linkat(AT_FDCWD, FILENAME, AT_FDCWD, FILENAME \"2\", 0) < 0) return 1;\n#else\n\tif (link(FILENAME, FILENAME \"2\") < 0) return 1;\n#endif\n\treturn 0;\n    }]])],[rsync_cv_can_hardlink_symlink=yes],[rsync_cv_can_hardlink_symlink=no],[rsync_cv_can_hardlink_symlink=no])])\nif test $rsync_cv_can_hardlink_symlink = yes; then\n  AC_DEFINE(CAN_HARDLINK_SYMLINK, 1, [Define to 1 if link() can hard-link symlinks.])\nfi\n\nAC_CACHE_CHECK([whether link() can hard-link special files],rsync_cv_can_hardlink_special,[\n  AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#if HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#include <stdlib.h>\n#include <errno.h>\n#define FILENAME \"conftest.fifi\"\nint main(void) {\n\tunlink(FILENAME);\n\tif (mkfifo(FILENAME, 0777) < 0) abort();\n\tunlink(FILENAME \"2\");\n\tif (link(FILENAME, FILENAME \"2\") < 0) return 1;\n\treturn 0;\n    }]])],[rsync_cv_can_hardlink_special=yes],[rsync_cv_can_hardlink_special=no],[rsync_cv_can_hardlink_special=no])])\nif test $rsync_cv_can_hardlink_special = yes; then\n    AC_DEFINE(CAN_HARDLINK_SPECIAL, 1, [Define to 1 if link() can hard-link special files.])\nfi\n\nAC_CACHE_CHECK([for working socketpair],rsync_cv_HAVE_SOCKETPAIR,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\nint main(void) {\n       int fd[2];\n       return (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) != -1) ? 0 : 1;\n}]])],[rsync_cv_HAVE_SOCKETPAIR=yes],[rsync_cv_HAVE_SOCKETPAIR=no],[rsync_cv_HAVE_SOCKETPAIR=cross])])\nif test x\"$rsync_cv_HAVE_SOCKETPAIR\" = x\"yes\"; then\n    AC_DEFINE(HAVE_SOCKETPAIR, 1, [Define to 1 if you have the \"socketpair\" function])\nfi\n\nAC_REPLACE_FUNCS([getpass])\n\nif test x\"$with_included_popt\" != x\"yes\"; then\n    AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])\nfi\nif test x\"$ac_cv_header_popt_popt_h\" = x\"yes\"; then\n    # If the system has /usr/include/popt/popt.h, we enable the\n    # included popt because an attempt to \"#include <popt/popt.h>\"\n    # would use our included header file anyway (due to -I.), and\n    # might conflict with the system popt.\n    with_included_popt=yes\nelif test x\"$ac_cv_header_popt_h\" != x\"yes\"; then\n    with_included_popt=yes\nfi\n\nAC_MSG_CHECKING([whether to use included libpopt])\nif test x\"$with_included_popt\" = x\"yes\"; then\n    AC_MSG_RESULT($srcdir/popt)\n    BUILD_POPT='$(popt_OBJS)'\n    CFLAGS=\"-I$srcdir/popt $CFLAGS\"\n    AC_DEFINE(POPT_SYSCONFDIR, \"/etc\", [sysconfig dir for popt])\n    AC_DEFINE(PACKAGE, \"rsync\", [package name for rsync])\n    if test x\"$ALLOCA\" != x\n    then\n\t# this can be removed when/if we add an included alloca.c;\n\t#  see autoconf documentation on AC_FUNC_ALLOCA\n\tAC_MSG_WARN([included libpopt will use malloc, not alloca (which wastes a small amount of memory)])\n    fi\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_CACHE_CHECK([for unsigned char],rsync_cv_SIGNED_CHAR_OK,[\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[signed char *s = (signed char *)\"\"]])],[rsync_cv_SIGNED_CHAR_OK=yes],[rsync_cv_SIGNED_CHAR_OK=no])])\nif test x\"$rsync_cv_SIGNED_CHAR_OK\" = x\"yes\"; then\n    AC_DEFINE(SIGNED_CHAR_OK, 1, [Define to 1 if \"signed char\" is a valid type])\nfi\n\nAC_CACHE_CHECK([for broken readdir],rsync_cv_HAVE_BROKEN_READDIR,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <dirent.h>\nint main(void) { struct dirent *di; DIR *d = opendir(\".\"); di = readdir(d);\nif (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&\ndi->d_name[0] == 0) return 0; return 1;} ]])],[rsync_cv_HAVE_BROKEN_READDIR=yes],[rsync_cv_HAVE_BROKEN_READDIR=no],[rsync_cv_HAVE_BROKEN_READDIR=cross])])\nif test x\"$rsync_cv_HAVE_BROKEN_READDIR\" = x\"yes\"; then\n    AC_DEFINE(HAVE_BROKEN_READDIR, 1, [Define to 1 if readdir() is broken])\nfi\n\nAC_CACHE_CHECK([for utimbuf],rsync_cv_HAVE_STRUCT_UTIMBUF,[\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <utime.h>]], [[struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; return utime(\"foo.c\",&tbuf);]])],[rsync_cv_HAVE_STRUCT_UTIMBUF=yes],[rsync_cv_HAVE_STRUCT_UTIMBUF=no])])\nif test x\"$rsync_cv_HAVE_STRUCT_UTIMBUF\" = x\"yes\"; then\n    AC_DEFINE(HAVE_STRUCT_UTIMBUF, 1, [Define to 1 if you have the \"struct utimbuf\" type])\nfi\n\nAC_CACHE_CHECK([if gettimeofday takes tz argument],rsync_cv_HAVE_GETTIMEOFDAY_TZ,[\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/time.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif]], [[struct timeval tv; return gettimeofday(&tv, NULL);]])],[rsync_cv_HAVE_GETTIMEOFDAY_TZ=yes],[rsync_cv_HAVE_GETTIMEOFDAY_TZ=no])])\nif test x\"$rsync_cv_HAVE_GETTIMEOFDAY_TZ\" != x\"no\"; then\n    AC_DEFINE(HAVE_GETTIMEOFDAY_TZ, 1, [Define to 1 if gettimeofday() takes a time-zone arg])\nfi\n\nAC_CACHE_CHECK([for C99 vsnprintf],rsync_cv_HAVE_C99_VSNPRINTF,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <stdarg.h>\n#include <stdio.h>\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\nvoid foo(const char *format, ...) {\n       va_list ap;\n       int len;\n       static char buf[] = \"12345678901234567890\";\n\n       va_start(ap, format);\n       len = vsnprintf(0, 0, format, ap);\n       va_end(ap);\n       if (len != 5) exit(1);\n\n       if (snprintf(buf, 3, \"hello\") != 5 || strcmp(buf, \"he\") != 0) exit(1);\n}\nint main(void) { foo(\"hello\"); return 0; }\n]])],[rsync_cv_HAVE_C99_VSNPRINTF=yes],[rsync_cv_HAVE_C99_VSNPRINTF=no],[rsync_cv_HAVE_C99_VSNPRINTF=cross])])\nif test x\"$rsync_cv_HAVE_C99_VSNPRINTF\" = x\"yes\"; then\n    AC_DEFINE(HAVE_C99_VSNPRINTF, 1, [Define to 1 if vsprintf has a C99-compatible return value])\nfi\n\n\nAC_CACHE_CHECK([for secure mkstemp],rsync_cv_HAVE_SECURE_MKSTEMP,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[#include <stdlib.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <sys/stat.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\nint main(void) {\n  struct stat st;\n  char tpl[20]=\"/tmp/test.XXXXXX\";\n  int fd = mkstemp(tpl);\n  if (fd == -1) return 1;\n  unlink(tpl);\n  if (fstat(fd, &st) != 0) return 1;\n  if ((st.st_mode & 0777) != 0600) return 1;\n  return 0;\n}]])],[rsync_cv_HAVE_SECURE_MKSTEMP=yes],[rsync_cv_HAVE_SECURE_MKSTEMP=no],[rsync_cv_HAVE_SECURE_MKSTEMP=cross])])\nif test x\"$rsync_cv_HAVE_SECURE_MKSTEMP\" = x\"yes\"; then\n    case $host_os in\n    hpux*)\n\tdnl HP-UX has a broken mkstemp() implementation they refuse to fix,\n\tdnl so we noisily skip using it.  See HP change request JAGaf34426\n\tdnl for details. (sbonds)\n\tAC_MSG_WARN(Skipping broken HP-UX mkstemp() -- using mktemp() instead)\n\t;;\n    *)\n\tAC_DEFINE(HAVE_SECURE_MKSTEMP, 1, [Define to 1 if mkstemp() is available and works right])\n\t;;\n    esac\nfi\n\n\nAC_CACHE_CHECK([if mknod creates FIFOs],rsync_cv_MKNOD_CREATES_FIFOS,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <sys/stat.h>\n#include <errno.h>\n#if HAVE_UNISTD_H\n# include <unistd.h>\n#endif\nint main(void) { int rc, ec; char *fn = \"fifo-test\";\nunlink(fn); rc = mknod(fn,S_IFIFO,0600); ec = errno; unlink(fn);\nif (rc) {printf(\"(%d %d) \",rc,ec); return ec;}\nreturn 0;}]])],[rsync_cv_MKNOD_CREATES_FIFOS=yes],[rsync_cv_MKNOD_CREATES_FIFOS=no],[rsync_cv_MKNOD_CREATES_FIFOS=cross])])\nif test x\"$rsync_cv_MKNOD_CREATES_FIFOS\" = x\"yes\"; then\n    AC_DEFINE(MKNOD_CREATES_FIFOS, 1, [Define to 1 if mknod() can create FIFOs.])\nfi\n\nAC_CACHE_CHECK([if mknod creates sockets],rsync_cv_MKNOD_CREATES_SOCKETS,[\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <sys/stat.h>\n#include <errno.h>\n#if HAVE_UNISTD_H\n# include <unistd.h>\n#endif\nint main(void) { int rc, ec; char *fn = \"sock-test\";\nunlink(fn); rc = mknod(fn,S_IFSOCK,0600); ec = errno; unlink(fn);\nif (rc) {printf(\"(%d %d) \",rc,ec); return ec;}\nreturn 0;}]])],[rsync_cv_MKNOD_CREATES_SOCKETS=yes],[rsync_cv_MKNOD_CREATES_SOCKETS=no],[rsync_cv_MKNOD_CREATES_SOCKETS=cross])])\nif test x\"$rsync_cv_MKNOD_CREATES_SOCKETS\" = x\"yes\"; then\n    AC_DEFINE(MKNOD_CREATES_SOCKETS, 1, [Define to 1 if mknod() can create sockets.])\nfi\n\n#\n# The following test was mostly taken from the tcl/tk plus patches\n#\nAC_CACHE_CHECK([whether -c -o works],rsync_cv_DASHC_WORKS_WITH_DASHO,[\nrm -rf conftest*\ncat > conftest.$ac_ext <<EOF\nint main(void) { return 0; }\nEOF\n${CC-cc} -c -o conftest..o conftest.$ac_ext\nif test -f conftest..o; then\n    rsync_cv_DASHC_WORKS_WITH_DASHO=yes\nelse\n    rsync_cv_DASHC_WORKS_WITH_DASHO=no\nfi\nrm -rf conftest*\n])\nif test x\"$rsync_cv_DASHC_WORKS_WITH_DASHO\" = x\"yes\"; then\n    OBJ_SAVE=\"#\"\n    OBJ_RESTORE=\"#\"\n    CC_SHOBJ_FLAG='-o $@'\nelse\n    OBJ_SAVE='\t@b=`basename $@ .o`;rm -f $$b.o.sav;if test -f $$b.o; then mv $$b.o $$b.o.sav;fi;'\n    OBJ_RESTORE='\t@b=`basename $@ .o`;if test \"$$b.o\" != \"$@\"; then mv $$b.o $@; if test -f $$b.o.sav; then mv $$b.o.sav $$b.o; fi; fi'\n    CC_SHOBJ_FLAG=\"\"\nfi\n\nAC_SUBST(OBJ_SAVE)\nAC_SUBST(OBJ_RESTORE)\nAC_SUBST(CC_SHOBJ_FLAG)\nAC_SUBST(BUILD_POPT)\nAC_SUBST(BUILD_ZLIB)\nAC_SUBST(MAKE_RRSYNC)\nAC_SUBST(MAKE_RRSYNC_1)\nAC_SUBST(GEN_RRSYNC)\nAC_SUBST(MAKE_MAN)\n\nAC_CHECK_FUNCS(_acl __acl _facl __facl)\n#################################################\n# check for ACL support\n\nAC_MSG_CHECKING([whether to support ACLs])\nAC_ARG_ENABLE(acl-support,\n\tAS_HELP_STRING([--disable-acl-support],[disable to omit ACL support]))\n\nif test x\"$enable_acl_support\" = x\"no\"; then\n    AC_MSG_RESULT(no)\nelse\n    case \"$host_os\" in\n    *sysv5*)\n\tAC_MSG_RESULT(Using UnixWare ACLs)\n\tAC_DEFINE(HAVE_UNIXWARE_ACLS, 1, [true if you have UnixWare ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1, [Define to 1 to add support for ACLs])\n\t;;\n    solaris*)\n\tAC_MSG_RESULT(Using solaris ACLs)\n\tAC_DEFINE(HAVE_SOLARIS_ACLS, 1, [true if you have solaris ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1)\n\t;;\n    *irix*)\n\tAC_MSG_RESULT(Using IRIX ACLs)\n\tAC_DEFINE(HAVE_IRIX_ACLS, 1, [true if you have IRIX ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1)\n\t;;\n    *aix*)\n\tAC_MSG_RESULT(Using AIX ACLs)\n\tAC_DEFINE(HAVE_AIX_ACLS, 1, [true if you have AIX ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1)\n\t;;\n    *osf*)\n\tAC_MSG_RESULT(Using Tru64 ACLs)\n\tAC_DEFINE(HAVE_TRU64_ACLS, 1, [true if you have Tru64 ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1)\n\tLIBS=\"$LIBS -lpacl\"\n\t;;\n    darwin*)\n\tAC_MSG_RESULT(Using OS X ACLs)\n\tAC_DEFINE(HAVE_OSX_ACLS, 1, [true if you have Mac OS X ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1)\n\t;;\n    *hpux*|*nsk*)\n\tAC_MSG_RESULT(Using HPUX ACLs)\n\tAC_DEFINE(HAVE_HPUX_ACLS, 1, [true if you have HPUX ACLs])\n\tAC_DEFINE(SUPPORT_ACLS, 1)\n\t;;\n    *)\n\tAC_MSG_RESULT(running tests:)\n\tAC_CHECK_LIB(acl,acl_get_file)\n\tAC_CACHE_CHECK([for ACL support],samba_cv_HAVE_POSIX_ACLS,[\n\t    AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#include <sys/acl.h>\n#endif]], [[ acl_t acl; int entry_id; acl_entry_t *entry_p; return acl_get_entry( acl, entry_id, entry_p);]])],[samba_cv_HAVE_POSIX_ACLS=yes],[samba_cv_HAVE_POSIX_ACLS=no])])\n\tAC_MSG_CHECKING(ACL test results)\n\tif test x\"$samba_cv_HAVE_POSIX_ACLS\" = x\"yes\"; then\n\t    AC_MSG_RESULT(Using posix ACLs)\n\t    AC_DEFINE(HAVE_POSIX_ACLS, 1, [true if you have posix ACLs])\n\t    AC_DEFINE(SUPPORT_ACLS, 1)\n\t    AC_CACHE_CHECK([for acl_get_perm_np],samba_cv_HAVE_ACL_GET_PERM_NP,[\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#include <sys/acl.h>\n#endif]], [[ acl_permset_t permset_d; acl_perm_t perm; return acl_get_perm_np( permset_d, perm);]])],[samba_cv_HAVE_ACL_GET_PERM_NP=yes],[samba_cv_HAVE_ACL_GET_PERM_NP=no])])\n\t    if test x\"$samba_cv_HAVE_ACL_GET_PERM_NP\" = x\"yes\"; then\n\t\tAC_DEFINE(HAVE_ACL_GET_PERM_NP, 1, [true if you have acl_get_perm_np])\n\t    fi\n\telse\n\t    if test x\"$enable_acl_support\" = x\"yes\"; then\n\t\tAC_MSG_ERROR(Failed to find ACL support)\n\t    else\n\t\tAC_MSG_RESULT(No ACL support found)\n\t    fi\n\tfi\n\t;;\n    esac\nfi\n\n#################################################\n# check for extended attribute support\nAC_MSG_CHECKING(whether to support extended attributes)\nAC_ARG_ENABLE(xattr-support,\n    AS_HELP_STRING([--disable-xattr-support],[disable to omit extended attributes]),\n    [], [case \"$ac_cv_func_getxattr$ac_cv_func_extattr_get_link$ac_cv_func_attropen\" in\n\t*yes*) enable_xattr_support=maybe ;;\n\t*) enable_xattr_support=no ;;\n\tesac])\nAH_TEMPLATE([SUPPORT_XATTRS],\n[Define to 1 to add support for extended attributes])\nif test x\"$enable_xattr_support\" = x\"no\"; then\n    AC_MSG_RESULT(no)\nelse\n    case \"$host_os\" in\n    *linux*|*netbsd*|*cygwin*)\n\tAC_MSG_RESULT(Using Linux xattrs)\n\tAC_DEFINE(HAVE_LINUX_XATTRS, 1, [True if you have Linux xattrs (or equivalent)])\n\tAC_DEFINE(SUPPORT_XATTRS, 1)\n\tAC_DEFINE(NO_SYMLINK_USER_XATTRS, 1, [True if symlinks do not support user xattrs])\n\tAC_CHECK_LIB(attr,getxattr)\n\t;;\n    darwin*)\n\tAC_MSG_RESULT(Using OS X xattrs)\n\tAC_DEFINE(HAVE_OSX_XATTRS, 1, [True if you have Mac OS X xattrs])\n\tAC_DEFINE(SUPPORT_XATTRS, 1)\n\tAC_DEFINE(NO_DEVICE_XATTRS, 1, [True if device files do not support xattrs])\n\tAC_DEFINE(NO_SPECIAL_XATTRS, 1, [True if special files do not support xattrs])\n\t;;\n    freebsd*)\n\tAC_MSG_RESULT(Using FreeBSD extattrs)\n\tAC_DEFINE(HAVE_FREEBSD_XATTRS, 1, [True if you have FreeBSD xattrs])\n\tAC_DEFINE(SUPPORT_XATTRS, 1)\n\t;;\n    solaris*)\n\tAC_MSG_RESULT(Using Solaris xattrs)\n\tAC_DEFINE(HAVE_SOLARIS_XATTRS, 1, [True if you have Solaris xattrs])\n\tAC_DEFINE(SUPPORT_XATTRS, 1)\n\tAC_DEFINE(NO_SYMLINK_XATTRS, 1, [True if symlinks do not support xattrs])\n\t;;\n    *)\n\tif test x\"$enable_xattr_support\" = x\"yes\"; then\n\t    AC_MSG_ERROR(Failed to find extended attribute support)\n\telse\n\t    AC_MSG_RESULT(No extended attribute support found)\n\tfi\n\t;;\n    esac\nfi\n\nif test x\"$enable_acl_support\" = x\"no\" || test x\"$enable_xattr_support\" = x\"no\" || test x\"$enable_iconv\" = x\"no\"; then\n    AC_MSG_CHECKING([whether $CC supports -Wno-unused-parameter])\n    OLD_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -Wno-unused-parameter\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdio.h>]], [[printf(\"hello\\n\");]])],[rsync_warn_flag=yes],[rsync_warn_flag=no])\n    AC_MSG_RESULT([$rsync_warn_flag])\n    if test x\"$rsync_warn_flag\" = x\"no\"; then\n\tCFLAGS=\"$OLD_CFLAGS\"\n    fi\nfi\n\ncase \"$CC\" in\n' checker'*|checker*)\n    AC_DEFINE(FORCE_FD_ZERO_MEMSET, 1, [Used to make \"checker\" understand that FD_ZERO() clears memory.])\n    ;;\nesac\n\nAC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])\nAC_OUTPUT\n\nAC_MSG_RESULT()\nAC_MSG_RESULT([    rsync $PACKAGE_VERSION configuration successful])\nAC_MSG_RESULT()\n"
        },
        {
          "name": "connection.c",
          "type": "blob",
          "size": 1.3349609375,
          "content": "/*\n * Support the max connections option.\n *\n * Copyright (C) 1998 Andrew Tridgell\n * Copyright (C) 2006-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n/* A simple routine to do connection counting.  This returns 1 on success\n * and 0 on failure, with errno also being set if the open() failed (errno\n * will be 0 if the lock request failed). */\nint claim_connection(char *fname, int max_connections)\n{\n\tint fd, i;\n\n\tif (max_connections == 0)\n\t\treturn 1;\n\n\tif ((fd = open(fname, O_RDWR|O_CREAT, 0600)) < 0)\n\t\treturn 0;\n\n\t/* Find a free spot. */\n\tfor (i = 0; i < max_connections; i++) {\n\t\tif (lock_range(fd, i*4, 4))\n\t\t\treturn 1;\n\t}\n\n\tclose(fd);\n\n\t/* A lock failure needs to return an errno of 0. */\n\terrno = 0;\n\treturn 0;\n}\n"
        },
        {
          "name": "csprotocol.txt",
          "type": "blob",
          "size": 4.1337890625,
          "content": "This is kind of informal and may be wrong, but it helped me.  It's\nbasically a summary of clientserver.c and authenticate.c.\n\n -- Martin Pool <mbp@samba.org>\n\n\nThis is the protocol used for rsync --daemon; i.e. connections to port\n873 rather than invocations over a remote shell.\n\nWhen the server accepts a connection, it prints a newline-terminated\ngreeting line:\n\n  @RSYNCD: <version>.<subprotocol> <digest1> <digestN>\n\nThe <version> is the numeric version (see PROTOCOL_VERSION in rsync.h)\nThe <subprotocol> is the numeric subprotocol version (which is 0 for a\nfinal protocol version, as the SUBPROTOCOL_VERSION define discusses).\nThe <digestN> names are the authentication digest algorithms that the\ndaemon supports, listed in order of preference.\n\nAn rsync prior to 3.2.7 omits the digest names.  An rsync prior to 3.0.0\nalso omits the period and the <subprotocol> value.  Since a final\nprotocol has a subprotocol value of 0, a missing subprotocol value is\nassumed to be 0 for any protocol prior to 30.  It is considered a fatal\nerror for protocol 30 and above to omit it.  It is considered a fatal\nerror for protocol 32 and above to omit the digest name list (currently\n31 is the newest protocol).\n\nThe daemon expects to see a similar greeting line back from the client.\nOnce received, the daemon follows the opening line with a free-format\ntext message-of-the-day (if any is defined).\n\nThe server is now in the connected state.  The client can either send\nthe command:\n\n  #list\n\n(to get a listing of modules) or the name of a module.  After this, the\nconnection is now bound to a particular module.  Access per host for\nthis module is now checked, as is per-module connection limits.\n\nIf authentication is required to use this module, the server will say:\n\n  @RSYNCD: AUTHREQD <challenge>\n\nwhere <challenge> is a random string of base64 characters.  The client\nmust respond with:\n\n  <user> <response>\n\nThe <user> is the username they claim to be. The <response> is the\nbase64 form of the digest hash of the challenge+password string. The\nchosen digest method is the most preferred client method that is also in\nthe server's list.  If no digest list was explicitly provided, the side\nexpecting a list assumes the other side provided either the single name\n\"md5\" (for a negotiated protocol 30 or 31), or the single name \"md4\"\n(for an older protocol).\n\nAt this point the server applies all remaining constraints before\nhanding control to the client, including switching uid/gid, setting up\ninclude and exclude lists, moving to the root of the module, and doing\nchroot.\n\nIf the login is acceptable, then the server will respond with\n\n  @RSYNCD: OK\n\nThe client now writes some rsync options, as if it were remotely\nexecuting the command.  The server parses these arguments as if it had\njust been invoked with them, but they're added to the existing state.\nSo if the client specifies a list of files to be included or excluded,\nthey'll defer to existing limits specified in the server\nconfiguration.\n\nAt this point the client and server both switch to using a\nmultiplexing layer across the socket.  The main point of this is to\nallow the server to asynchronously pass errors back, while still\nallowing streamed and pipelined data.\n\nUnfortunately, the multiplex protocol is not used at every stage.  We\nstart up in plain socket mode and then change over by calling\nio_start_buffering.  Of course both the client and the server have to\ndo this at the same point.\n\nThe server then talks to the client as normal across the socket,\npassing checksums, file lists and so on.  For documentation of that,\nstay tuned (or write it yourself!).\n\n\n\n------------\nProtocol version changes\n\n31\t(2013-09-28, 3.1.0)\n\n\tInitial release of protocol 31 had no changes.  Rsync 3.2.7\n\tintroduced the suffixed list of digest names on the greeting\n\tline.  The presence of the list is allowed even if the greeting\n\tindicates an older protocol version number.\n\n30\t(2007-10-04, 3.0.0pre1)\n\n\tThe use of a \".<subprotocol>\" number was added to\n\t@RSYNCD: <version>.<subprotocol>\n\n25\t(2001-08-20, 2.4.7pre2) \n\n\tSend an explicit \"@RSYNC EXIT\" command at the end of the\n\tmodule listing.  We never intentionally end the transmission\n\tby just closing the socket anymore.\n"
        },
        {
          "name": "daemon-parm.awk",
          "type": "blob",
          "size": 2.8095703125,
          "content": "#!/usr/bin/awk -f\n\n# The caller must pass arg: daemon-parm.txt\n# The resulting code is output into daemon-parm.h\n\nBEGIN {\n    heading = \"/* DO NOT EDIT THIS FILE!  It is auto-generated from a list of values in \" ARGV[1] \"! */\\n\\n\"\n    sect = psect = defines = accessors = prior_ptype = \"\"\n    parms = \"\\nstatic struct parm_struct parm_table[] = {\"\n    comment_fmt = \"\\n/********** %s **********/\\n\"\n    tdstruct = \"typedef struct {\"\n}\n\n/^\\s*$/ { next }\n/^#/ { next }\n\n/^Globals:/ {\n    if (defines != \"\") {\n\tprint \"The Globals section must come first!\"\n\tdefines = \"\"\n\texit\n    }\n    defines = tdstruct\n    values = \"\\nstatic const all_vars Defaults = {\\n    { /* Globals: */\\n\"\n    exps = exp_values = sprintf(comment_fmt, \"EXP\")\n    sect = \"GLOBAL\"\n    psect = \", P_GLOBAL, &Vars.g.\"\n    next\n}\n\n/^Locals:/ {\n    if (sect == \"\") {\n\tprint \"The Locals section must come after the Globals!\"\n\texit\n    }\n    defines = defines exps \"} global_vars;\\n\\n\" tdstruct\n    values = values exp_values \"\\n    }, { /* Locals: */\\n\"\n    exps = exp_values = sprintf(comment_fmt, \"EXP\")\n    sect = \"LOCAL\"\n    psect = \", P_LOCAL, &Vars.l.\"\n    next\n}\n\n/^(STRING|CHAR|PATH|INTEGER|ENUM|OCTAL|BOOL|BOOLREV|BOOL3)[ \\t]/ {\n    ptype = $1\n    name = $2\n    $1 = $2 = \"\"\n    sub(/^[ \\t]+/, \"\")\n\n    if (ptype != prior_ptype) {\n\tcomment = sprintf(comment_fmt, ptype)\n\tdefines = defines comment\n\tvalues = values comment\n\tparms = parms \"\\n\"\n\taccessors = accessors \"\\n\"\n\tprior_ptype = ptype\n    }\n\n    if (ptype == \"STRING\" || ptype == \"PATH\") {\n\tatype = \"STRING\"\n\tvtype = \"char*\"\n    } else if (ptype ~ /BOOL/) {\n\tatype = vtype = \"BOOL\"\n    } else if (ptype == \"CHAR\") {\n\tatype = \"CHAR\"\n\tvtype = \"char\"\n    } else {\n\tatype = \"INTEGER\"\n\tvtype = \"int\"\n    }\n\n    # The name might be var_name|public_name\n    pubname = name\n    sub(/\\|.*/, \"\", name)\n    sub(/.*\\|/, \"\", pubname)\n    gsub(/_/, \" \", pubname)\n    gsub(/-/, \"\", name)\n\n    if (ptype == \"ENUM\")\n\tenum = \"enum_\" name\n    else\n\tenum = \"NULL\"\n\n    defines = defines \"\\t\" vtype \" \" name \";\\n\"\n    values = values \"\\t\" $0 \", /* \" name \" */\\n\"\n    parms = parms \" {\\\"\" pubname \"\\\", P_\" ptype psect name \", \" enum \", 0},\\n\"\n    accessors = accessors \"FN_\" sect \"_\" atype \"(lp_\" name \", \" name \")\\n\"\n\n    if (vtype == \"char*\") {\n\texps = exps \"\\tBOOL \" name \"_EXP;\\n\"\n\texp_values = exp_values \"\\tFalse, /* \" name \"_EXP */\\n\"\n    }\n\n    next\n}\n\n/./ {\n    print \"Extraneous line:\" $0\n    defines = \"\"\n    exit\n}\n\nEND {\n    if (sect != \"\" && defines != \"\") {\n\tdefines = defines exps \"} local_vars;\\n\\n\"\n\tdefines = defines tdstruct \"\\n\\tglobal_vars g;\\n\\tlocal_vars l;\\n} all_vars;\\n\"\n\tvalues = values exp_values \"\\n    }\\n};\\n\\nstatic all_vars Vars;\\n\"\n\tparms = parms \"\\n {NULL, P_BOOL, P_NONE, NULL, NULL, 0}\\n};\\n\"\n\tprint heading defines values parms accessors > \"daemon-parm.h\"\n    } else {\n\tprint \"Failed to parse the data in \" ARGV[1]\n\texit 1\n    }\n}\n"
        },
        {
          "name": "daemon-parm.txt",
          "type": "blob",
          "size": 1.552734375,
          "content": "Globals: ================================================================\n\nSTRING\tbind_address|address\tNULL\nSTRING\tdaemon_chroot\t\tNULL\nSTRING\tdaemon_gid\t\tNULL\nSTRING\tdaemon_uid\t\tNULL\nSTRING\tmotd_file\t\tNULL\nSTRING\tpid_file\t\tNULL\nSTRING\tsocket_options\t\tNULL\n\nINTEGER\tlisten_backlog\t\t5\nINTEGER\trsync_port|port\t\t0\n\nBOOL\tproxy_protocol\t\tFalse\n\nLocals: =================================================================\n\nSTRING\tauth_users\t\tNULL\nSTRING\tcharset\t\t\tNULL\nSTRING\tcomment\t\t\tNULL\nSTRING\tdont_compress\t\tDEFAULT_DONT_COMPRESS\nSTRING\tearly_exec\t\tNULL\nSTRING\texclude\t\t\tNULL\nSTRING\texclude_from\t\tNULL\nSTRING\tfilter\t\t\tNULL\nSTRING\tgid\t\t\tNULL\nSTRING\thosts_allow\t\tNULL\nSTRING\thosts_deny\t\tNULL\nSTRING\tinclude\t\t\tNULL\nSTRING\tinclude_from\t\tNULL\nSTRING\tincoming_chmod\t\tNULL\nSTRING\tlock_file\t\tDEFAULT_LOCK_FILE\nSTRING\tlog_file\t\tNULL\nSTRING\tlog_format\t\t\"%o %h [%a] %m (%u) %f %l\"\nSTRING\tname\t\t\tNULL\nSTRING\tname_converter\t\tNULL\nSTRING\toutgoing_chmod\t\tNULL\nSTRING\tpost-xfer_exec\t\tNULL\nSTRING\tpre-xfer_exec\t\tNULL\nSTRING\trefuse_options\t\tNULL\nSTRING\tsecrets_file\t\tNULL\nSTRING\tsyslog_tag\t\t\"rsyncd\"\nSTRING\tuid\t\t\tNULL\n\nPATH\tpath\t\t\tNULL\nPATH\ttemp_dir\t\tNULL\n\nINTEGER\tmax_connections\t\t0\nINTEGER\tmax_verbosity\t\t1\nINTEGER\ttimeout\t\t\t0\n\nENUM\tsyslog_facility\t\tLOG_DAEMON\n\nBOOL\tfake_super\t\tFalse\nBOOL\tforward_lookup\t\tTrue\nBOOL\tignore_errors\t\tFalse\nBOOL\tignore_nonreadable\tFalse\nBOOL\tlist\t\t\tTrue\nBOOL\tread_only\t\tTrue\nBOOL\treverse_lookup\t\tTrue\nBOOL\tstrict_modes\t\tTrue\nBOOL\ttransfer_logging\tFalse\nBOOL\twrite_only\t\tFalse\n\nBOOL3\tmunge_symlinks\t\tUnset\nBOOL3\tnumeric_ids\t\tUnset\nBOOL3\topen_noatime\t\tUnset\nBOOL3\tuse_chroot\t\tUnset\n"
        },
        {
          "name": "define-from-md.awk",
          "type": "blob",
          "size": 0.80078125,
          "content": "#!/usr/bin/awk -f\n\n# The caller must pass args: -v hfile=NAME rsync.1.md\n\nBEGIN {\n    heading = \"/* DO NOT EDIT THIS FILE!  It is auto-generated from a list of values in \" ARGV[1] \"! */\"\n    if (hfile ~ /compress/) {\n\tdefine = \"#define DEFAULT_DONT_COMPRESS\"\n\tprefix = \"*.\"\n    } else {\n\tdefine = \"#define DEFAULT_CVSIGNORE\"\n\tprefix = \"\"\n    }\n    value_list = \"\"\n}\n\n/^    > [^ ]+$/ {\n    gsub(/`/, \"\")\n    if (value_list != \"\") value_list = value_list \" \"\n    value_list = value_list prefix $2\n    next\n}\n\nvalue_list ~ /\\.gz / && hfile ~ /compress/ {\n    exit\n}\n\nvalue_list ~ /SCCS / && hfile ~ /cvsignore/ {\n    exit\n}\n\nvalue_list = \"\"\n\nEND {\n    if (value_list != \"\")\n\tprint heading \"\\n\\n\" define \" \\\"\" value_list \"\\\"\" > hfile\n    else {\n\tprint \"Failed to find a value list in \" ARGV[1] \" for \" hfile\n\texit 1\n    }\n}\n"
        },
        {
          "name": "delete.c",
          "type": "blob",
          "size": 6.3447265625,
          "content": "/*\n * Deletion routines used in rsync.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2024 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\nextern int am_root;\nextern int make_backups;\nextern int max_delete;\nextern char *backup_dir;\nextern char *backup_suffix;\nextern int backup_suffix_len;\nextern struct stats stats;\n\nint ignore_perishable = 0;\nint non_perishable_cnt = 0;\nint skipped_deletes = 0;\n\nstatic inline int is_backup_file(char *fn)\n{\n\tint k = strlen(fn) - backup_suffix_len;\n\treturn k > 0 && strcmp(fn+k, backup_suffix) == 0;\n}\n\n/* The directory is about to be deleted: if DEL_RECURSE is given, delete all\n * its contents, otherwise just checks for content.  Returns DR_SUCCESS or\n * DR_NOT_EMPTY.  Note that fname must point to a MAXPATHLEN buffer!  (The\n * buffer is used for recursion, but returned unchanged.)\n */\nstatic enum delret delete_dir_contents(char *fname, uint16 flags)\n{\n\tstruct file_list *dirlist;\n\tenum delret ret;\n\tunsigned remainder;\n\tvoid *save_filters;\n\tint j, dlen;\n\tchar *p;\n\n\tif (DEBUG_GTE(DEL, 3)) {\n\t\trprintf(FINFO, \"delete_dir_contents(%s) flags=%d\\n\",\n\t\t\tfname, flags);\n\t}\n\n\tdlen = strlen(fname);\n\tsave_filters = push_local_filters(fname, dlen);\n\n\tnon_perishable_cnt = 0;\n\tdirlist = get_dirlist(fname, dlen, 0);\n\tret = non_perishable_cnt ? DR_NOT_EMPTY : DR_SUCCESS;\n\n\tif (!dirlist->used)\n\t\tgoto done;\n\n\tif (!(flags & DEL_RECURSE)) {\n\t\tret = DR_NOT_EMPTY;\n\t\tgoto done;\n\t}\n\n\tp = fname + dlen;\n\tif (dlen != 1 || *fname != '/')\n\t\t*p++ = '/';\n\tremainder = MAXPATHLEN - (p - fname);\n\n\t/* We do our own recursion, so make delete_item() non-recursive. */\n\tflags = (flags & ~(DEL_RECURSE|DEL_MAKE_ROOM|DEL_NO_UID_WRITE))\n\t      | DEL_DIR_IS_EMPTY;\n\n\tfor (j = dirlist->used; j--; ) {\n\t\tstruct file_struct *fp = dirlist->files[j];\n\n\t\tif (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {\n\t\t\tif (DEBUG_GTE(DEL, 1)) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"mount point, %s, pins parent directory\\n\",\n\t\t\t\t\tf_name(fp, NULL));\n\t\t\t}\n\t\t\tret = DR_NOT_EMPTY;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstrlcpy(p, fp->basename, remainder);\n\t\tif (!(fp->mode & S_IWUSR) && !am_root && fp->flags & FLAG_OWNED_BY_US)\n\t\t\tdo_chmod(fname, fp->mode | S_IWUSR);\n\t\t/* Save stack by recursing to ourself directly. */\n\t\tif (S_ISDIR(fp->mode)) {\n\t\t\tif (delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)\n\t\t\t\tret = DR_NOT_EMPTY;\n\t\t}\n\t\tif (delete_item(fname, fp->mode, flags) != DR_SUCCESS)\n\t\t\tret = DR_NOT_EMPTY;\n\t}\n\n\tfname[dlen] = '\\0';\n\n  done:\n\tflist_free(dirlist);\n\tpop_local_filters(save_filters);\n\n\tif (ret == DR_NOT_EMPTY) {\n\t\trprintf(FINFO, \"cannot delete non-empty directory: %s\\n\",\n\t\t\tfname);\n\t}\n\treturn ret;\n}\n\n/* Delete a file or directory.  If DEL_RECURSE is set in the flags, this will\n * delete recursively.\n *\n * Note that fbuf must point to a MAXPATHLEN buffer if the mode indicates it's\n * a directory! (The buffer is used for recursion, but returned unchanged.)\n */\nenum delret delete_item(char *fbuf, uint16 mode, uint16 flags)\n{\n\tenum delret ret;\n\tchar *what;\n\tint ok;\n\n\tif (DEBUG_GTE(DEL, 2)) {\n\t\trprintf(FINFO, \"delete_item(%s) mode=%o flags=%d\\n\",\n\t\t\tfbuf, (int)mode, (int)flags);\n\t}\n\n\tif (flags & DEL_NO_UID_WRITE)\n\t\tdo_chmod(fbuf, mode | S_IWUSR);\n\n\tif (S_ISDIR(mode) && !(flags & DEL_DIR_IS_EMPTY)) {\n\t\t/* This only happens on the first call to delete_item() since\n\t\t * delete_dir_contents() always calls us w/DEL_DIR_IS_EMPTY. */\n\t\tignore_perishable = 1;\n\t\t/* If DEL_RECURSE is not set, this just reports emptiness. */\n\t\tret = delete_dir_contents(fbuf, flags);\n\t\tignore_perishable = 0;\n\t\tif (ret == DR_NOT_EMPTY || ret == DR_AT_LIMIT)\n\t\t\tgoto check_ret;\n\t\t/* OK: try to delete the directory. */\n\t}\n\n\tif (!(flags & DEL_MAKE_ROOM) && max_delete >= 0 && stats.deleted_files >= max_delete) {\n\t\tskipped_deletes++;\n\t\treturn DR_AT_LIMIT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\twhat = \"rmdir\";\n\t\tok = do_rmdir(fbuf) == 0;\n\t} else {\n\t\tif (make_backups > 0 && !(flags & DEL_FOR_BACKUP) && (backup_dir || !is_backup_file(fbuf))) {\n\t\t\twhat = \"make_backup\";\n\t\t\tok = make_backup(fbuf, True);\n\t\t\tif (ok == 2) {\n\t\t\t\twhat = \"unlink\";\n\t\t\t\tok = robust_unlink(fbuf) == 0;\n\t\t\t}\n\t\t} else {\n\t\t\twhat = \"unlink\";\n\t\t\tok = robust_unlink(fbuf) == 0;\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tif (!(flags & DEL_MAKE_ROOM)) {\n\t\t\tlog_delete(fbuf, mode);\n\t\t\tstats.deleted_files++;\n\t\t\tif (S_ISREG(mode)) {\n\t\t\t\t/* Nothing more to count */\n\t\t\t} else if (S_ISDIR(mode))\n\t\t\t\tstats.deleted_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\telse if (S_ISLNK(mode))\n\t\t\t\tstats.deleted_symlinks++;\n#endif\n\t\t\telse if (IS_DEVICE(mode))\n\t\t\t\tstats.deleted_devices++;\n\t\t\telse\n\t\t\t\tstats.deleted_specials++;\n\t\t}\n\t\tret = DR_SUCCESS;\n\t} else {\n\t\tif (S_ISDIR(mode) && errno == ENOTEMPTY) {\n\t\t\trprintf(FINFO, \"cannot delete non-empty directory: %s\\n\",\n\t\t\t\tfbuf);\n\t\t\tret = DR_NOT_EMPTY;\n\t\t} else if (errno != ENOENT) {\n\t\t\trsyserr(FERROR_XFER, errno, \"delete_file: %s(%s) failed\",\n\t\t\t\twhat, fbuf);\n\t\t\tret = DR_FAILURE;\n\t\t} else\n\t\t\tret = DR_SUCCESS;\n\t}\n\n  check_ret:\n\tif (ret != DR_SUCCESS && flags & DEL_MAKE_ROOM) {\n\t\tconst char *desc;\n\t\tswitch (flags & DEL_MAKE_ROOM) {\n\t\tcase DEL_FOR_FILE: desc = \"regular file\"; break;\n\t\tcase DEL_FOR_DIR: desc = \"directory\"; break;\n\t\tcase DEL_FOR_SYMLINK: desc = \"symlink\"; break;\n\t\tcase DEL_FOR_DEVICE: desc = \"device file\"; break;\n\t\tcase DEL_FOR_SPECIAL: desc = \"special file\"; break;\n\t\tdefault: exit_cleanup(RERR_UNSUPPORTED); /* IMPOSSIBLE */\n\t\t}\n\t\trprintf(FERROR_XFER, \"could not make way for %s %s: %s\\n\",\n\t\t\tflags & DEL_FOR_BACKUP ? \"backup\" : \"new\",\n\t\t\tdesc, fbuf);\n\t}\n\treturn ret;\n}\n\nuint16 get_del_for_flag(uint16 mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn DEL_FOR_FILE;\n\tif (S_ISDIR(mode))\n\t\treturn DEL_FOR_DIR;\n\tif (S_ISLNK(mode))\n\t\treturn DEL_FOR_SYMLINK;\n\tif (IS_DEVICE(mode))\n\t\treturn DEL_FOR_DEVICE;\n\tif (IS_SPECIAL(mode))\n\t\treturn DEL_FOR_SPECIAL;\n\texit_cleanup(RERR_UNSUPPORTED); /* IMPOSSIBLE */\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "errcode.h",
          "type": "blob",
          "size": 2.763671875,
          "content": "/*\n * Error codes returned by rsync.\n *\n * Copyright (C) 1998-2000 Andrew Tridgell\n * Copyright (C) 2003-2019 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* If you change these, please also update the string mappings in log.c and\n * the EXIT VALUES in rsync.yo. */\n\n#define RERR_OK         0\n#define RERR_SYNTAX     1       /* syntax or usage error */\n#define RERR_PROTOCOL   2       /* protocol incompatibility */\n#define RERR_FILESELECT 3       /* errors selecting input/output files, dirs */\n#define RERR_UNSUPPORTED 4      /* requested action not supported */\n#define RERR_STARTCLIENT 5      /* error starting client-server protocol */\n\n#define RERR_SOCKETIO   10      /* error in socket IO */\n#define RERR_FILEIO     11      /* error in file IO */\n#define RERR_STREAMIO   12      /* error in rsync protocol data stream */\n#define RERR_MESSAGEIO  13      /* errors with program diagnostics */\n#define RERR_IPC        14      /* error in IPC code */\n#define RERR_CRASHED    15      /* sibling crashed */\n#define RERR_TERMINATED 16      /* sibling terminated abnormally */\n\n#define RERR_SIGNAL1    19      /* status returned when sent SIGUSR1 */\n#define RERR_SIGNAL     20      /* status returned when sent SIGINT, SIGTERM, SIGHUP */\n#define RERR_WAITCHILD  21      /* some error returned by waitpid() */\n#define RERR_MALLOC     22      /* error allocating core memory buffers */\n#define RERR_PARTIAL    23      /* partial transfer */\n#define RERR_VANISHED   24      /* file(s) vanished on sender side */\n#define RERR_DEL_LIMIT  25      /* skipped some deletes due to --max-delete */\n\n#define RERR_TIMEOUT    30      /* timeout in data send/receive */\n#define RERR_CONTIMEOUT 35      /* timeout waiting for daemon connection */\n\n/* Although it doesn't seem to be specified anywhere,\n * ssh and the shell seem to return these values:\n *\n * 124 if the command exited with status 255\n * 125 if the command is killed by a signal\n * 126 if the command cannot be run\n * 127 if the command is not found\n *\n * and we could use this to give a better explanation if the remote\n * command is not found.\n */\n#define RERR_CMD_FAILED 124\n#define RERR_CMD_KILLED 125\n#define RERR_CMD_RUN 126\n#define RERR_CMD_NOTFOUND 127\n"
        },
        {
          "name": "exclude.c",
          "type": "blob",
          "size": 48.083984375,
          "content": "/*\n * The filter include/exclude routines.\n *\n * Copyright (C) 1996-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2003-2024 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n\nextern int am_server;\nextern int am_sender;\nextern int am_generator;\nextern int eol_nulls;\nextern int io_error;\nextern int xfer_dirs;\nextern int recurse;\nextern int local_server;\nextern int prune_empty_dirs;\nextern int ignore_perishable;\nextern int relative_paths;\nextern int delete_mode;\nextern int delete_excluded;\nextern int cvs_exclude;\nextern int sanitize_paths;\nextern int protocol_version;\nextern int trust_sender_args;\nextern int module_id;\n\nextern char curr_dir[MAXPATHLEN];\nextern unsigned int curr_dir_len;\nextern unsigned int module_dirlen;\n\nfilter_rule_list filter_list = { .debug_type = \"\" };\nfilter_rule_list cvs_filter_list = { .debug_type = \" [global CVS]\" };\nfilter_rule_list daemon_filter_list = { .debug_type = \" [daemon]\" };\nfilter_rule_list implied_filter_list = { .debug_type = \" [implied]\" };\n\nint saw_xattr_filter = 0;\nint trust_sender_args = 0;\nint trust_sender_filter = 0;\n\n/* Need room enough for \":MODS \" prefix plus some room to grow. */\n#define MAX_RULE_PREFIX (16)\n\n#define SLASH_WILD3_SUFFIX \"/***\"\n\n/* The dirbuf is set by push_local_filters() to the current subdirectory\n * relative to curr_dir that is being processed.  The path always has a\n * trailing slash appended, and the variable dirbuf_len contains the length\n * of this path prefix.  The path is always absolute. */\nstatic char dirbuf[MAXPATHLEN+1];\nstatic unsigned int dirbuf_len = 0;\nstatic int dirbuf_depth;\n\n/* This is True when we're scanning parent dirs for per-dir merge-files. */\nstatic BOOL parent_dirscan = False;\n\n/* This array contains a list of all the currently active per-dir merge\n * files.  This makes it easier to save the appropriate values when we\n * \"push\" down into each subdirectory. */\nstatic filter_rule **mergelist_parents;\nstatic int mergelist_cnt = 0;\nstatic int mergelist_size = 0;\n\n#define LOCAL_RULE   1\n#define REMOTE_RULE  2\nstatic uchar cur_elide_value = REMOTE_RULE;\n\n/* Each filter_list_struct describes a singly-linked list by keeping track\n * of both the head and tail pointers.  The list is slightly unusual in that\n * a parent-dir's content can be appended to the end of the local list in a\n * special way:  the last item in the local list has its \"next\" pointer set\n * to point to the inherited list, but the local list's tail pointer points\n * at the end of the local list.  Thus, if the local list is empty, the head\n * will be pointing at the inherited content but the tail will be NULL.  To\n * help you visualize this, here are the possible list arrangements:\n *\n * Completely Empty                     Local Content Only\n * ==================================   ====================================\n * head -> NULL                         head -> Local1 -> Local2 -> NULL\n * tail -> NULL                         tail -------------^\n *\n * Inherited Content Only               Both Local and Inherited Content\n * ==================================   ====================================\n * head -> Parent1 -> Parent2 -> NULL   head -> L1 -> L2 -> P1 -> P2 -> NULL\n * tail -> NULL                         tail ---------^\n *\n * This means that anyone wanting to traverse the whole list to use it just\n * needs to start at the head and use the \"next\" pointers until it goes\n * NULL.  To add new local content, we insert the item after the tail item\n * and update the tail (obviously, if \"tail\" was NULL, we insert it at the\n * head).  To clear the local list, WE MUST NOT FREE THE INHERITED CONTENT\n * because it is shared between the current list and our parent list(s).\n * The easiest way to handle this is to simply truncate the list after the\n * tail item and then free the local list from the head.  When inheriting\n * the list for a new local dir, we just save off the filter_list_struct\n * values (so we can pop back to them later) and set the tail to NULL.\n */\n\nstatic void teardown_mergelist(filter_rule *ex)\n{\n\tint j;\n\n\tif (!ex->u.mergelist)\n\t\treturn;\n\n\tif (DEBUG_GTE(FILTER, 2)) {\n\t\trprintf(FINFO, \"[%s] deactivating mergelist #%d%s\\n\",\n\t\t\twho_am_i(), mergelist_cnt - 1,\n\t\t\tex->u.mergelist->debug_type);\n\t}\n\n\tfree(ex->u.mergelist->debug_type);\n\tfree(ex->u.mergelist);\n\n\tfor (j = 0; j < mergelist_cnt; j++) {\n\t\tif (mergelist_parents[j] == ex) {\n\t\t\tmergelist_parents[j] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (mergelist_cnt && mergelist_parents[mergelist_cnt-1] == NULL)\n\t\tmergelist_cnt--;\n}\n\nstatic void free_filter(filter_rule *ex)\n{\n\tif (ex->rflags & FILTRULE_PERDIR_MERGE)\n\t\tteardown_mergelist(ex);\n\tfree(ex->pattern);\n\tfree(ex);\n}\n\nstatic void free_filters(filter_rule *ent)\n{\n\twhile (ent) {\n\t\tfilter_rule *next = ent->next;\n\t\tfree_filter(ent);\n\t\tent = next;\n\t}\n}\n\n/* Build a filter structure given a filter pattern.  The value in \"pat\"\n * is not null-terminated.  \"rule\" is either held or freed, so the\n * caller should not free it. */\nstatic void add_rule(filter_rule_list *listp, const char *pat, unsigned int pat_len,\n\t\t     filter_rule *rule, int xflags)\n{\n\tconst char *cp;\n\tunsigned int pre_len, suf_len, slash_cnt = 0;\n\tchar *mention_rule_suffix;\n\n\tif (DEBUG_GTE(FILTER, 1) && pat_len && (pat[pat_len-1] == ' ' || pat[pat_len-1] == '\\t'))\n\t\tmention_rule_suffix = \" -- CAUTION: trailing whitespace!\";\n\telse\n\t\tmention_rule_suffix = DEBUG_GTE(FILTER, 2) ? \"\" : NULL;\n\tif (mention_rule_suffix) {\n\t\trprintf(FINFO, \"[%s] add_rule(%s%.*s%s)%s%s\\n\",\n\t\t\twho_am_i(), get_rule_prefix(rule, pat, 0, NULL),\n\t\t\t(int)pat_len, pat, (rule->rflags & FILTRULE_DIRECTORY) ? \"/\" : \"\",\n\t\t\tlistp->debug_type, mention_rule_suffix);\n\t}\n\n\t/* These flags also indicate that we're reading a list that\n\t * needs to be filtered now, not post-filtered later. */\n\tif (xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH)\n\t\t&& (rule->rflags & FILTRULES_SIDES)\n\t\t\t== (am_sender ? FILTRULE_RECEIVER_SIDE : FILTRULE_SENDER_SIDE)) {\n\t\t/* This filter applies only to the other side.  Drop it. */\n\t\tfree_filter(rule);\n\t\treturn;\n\t}\n\n\tif (pat_len > 1 && pat[pat_len-1] == '/') {\n\t\tpat_len--;\n\t\trule->rflags |= FILTRULE_DIRECTORY;\n\t}\n\n\tfor (cp = pat; cp < pat + pat_len; cp++) {\n\t\tif (*cp == '/')\n\t\t\tslash_cnt++;\n\t}\n\n\tif (!(rule->rflags & (FILTRULE_ABS_PATH | FILTRULE_MERGE_FILE))\n\t && ((xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH) && *pat == '/')\n\t  || (xflags & XFLG_ABS_IF_SLASH && slash_cnt))) {\n\t\trule->rflags |= FILTRULE_ABS_PATH;\n\t\tif (*pat == '/')\n\t\t\tpre_len = dirbuf_len - module_dirlen - 1;\n\t\telse\n\t\t\tpre_len = 0;\n\t} else\n\t\tpre_len = 0;\n\n\t/* The daemon wants dir-exclude rules to get an appended \"/\" + \"***\". */\n\tif (xflags & XFLG_DIR2WILD3\n\t && BITS_SETnUNSET(rule->rflags, FILTRULE_DIRECTORY, FILTRULE_INCLUDE)) {\n\t\trule->rflags &= ~FILTRULE_DIRECTORY;\n\t\tsuf_len = sizeof SLASH_WILD3_SUFFIX - 1;\n\t} else\n\t\tsuf_len = 0;\n\n\trule->pattern = new_array(char, pre_len + pat_len + suf_len + 1);\n\tif (pre_len) {\n\t\tmemcpy(rule->pattern, dirbuf + module_dirlen, pre_len);\n\t\tfor (cp = rule->pattern; cp < rule->pattern + pre_len; cp++) {\n\t\t\tif (*cp == '/')\n\t\t\t\tslash_cnt++;\n\t\t}\n\t}\n\trule->elide = 0;\n\tstrlcpy(rule->pattern + pre_len, pat, pat_len + 1);\n\tpat_len += pre_len;\n\tif (suf_len) {\n\t\tmemcpy(rule->pattern + pat_len, SLASH_WILD3_SUFFIX, suf_len+1);\n\t\tpat_len += suf_len;\n\t\tslash_cnt++;\n\t}\n\n\tif (strpbrk(rule->pattern, \"*[?\")) {\n\t\trule->rflags |= FILTRULE_WILD;\n\t\tif ((cp = strstr(rule->pattern, \"**\")) != NULL) {\n\t\t\trule->rflags |= FILTRULE_WILD2;\n\t\t\t/* If the pattern starts with **, note that. */\n\t\t\tif (cp == rule->pattern)\n\t\t\t\trule->rflags |= FILTRULE_WILD2_PREFIX;\n\t\t\t/* If the pattern ends with ***, note that. */\n\t\t\tif (pat_len >= 3\n\t\t\t && rule->pattern[pat_len-3] == '*'\n\t\t\t && rule->pattern[pat_len-2] == '*'\n\t\t\t && rule->pattern[pat_len-1] == '*')\n\t\t\t\trule->rflags |= FILTRULE_WILD3_SUFFIX;\n\t\t}\n\t}\n\n\tif (rule->rflags & FILTRULE_PERDIR_MERGE) {\n\t\tfilter_rule_list *lp;\n\t\tunsigned int len;\n\t\tint i;\n\n\t\tif ((cp = strrchr(rule->pattern, '/')) != NULL)\n\t\t\tcp++;\n\t\telse\n\t\t\tcp = rule->pattern;\n\n\t\t/* If the local merge file was already mentioned, don't\n\t\t * add it again. */\n\t\tfor (i = 0; i < mergelist_cnt; i++) {\n\t\t\tfilter_rule *ex = mergelist_parents[i];\n\t\t\tconst char *s;\n\t\t\tif (!ex)\n\t\t\t\tcontinue;\n\t\t\ts = strrchr(ex->pattern, '/');\n\t\t\tif (s)\n\t\t\t\ts++;\n\t\t\telse\n\t\t\t\ts = ex->pattern;\n\t\t\tlen = strlen(s);\n\t\t\tif (len == pat_len - (cp - rule->pattern) && memcmp(s, cp, len) == 0) {\n\t\t\t\tfree_filter(rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tlp = new_array0(filter_rule_list, 1);\n\t\tif (asprintf(&lp->debug_type, \" [per-dir %s]\", cp) < 0)\n\t\t\tout_of_memory(\"add_rule\");\n\t\trule->u.mergelist = lp;\n\n\t\tif (mergelist_cnt == mergelist_size) {\n\t\t\tmergelist_size += 5;\n\t\t\tmergelist_parents = realloc_array(mergelist_parents, filter_rule *, mergelist_size);\n\t\t}\n\t\tif (DEBUG_GTE(FILTER, 2)) {\n\t\t\trprintf(FINFO, \"[%s] activating mergelist #%d%s\\n\",\n\t\t\t\twho_am_i(), mergelist_cnt, lp->debug_type);\n\t\t}\n\t\tmergelist_parents[mergelist_cnt++] = rule;\n\t} else\n\t\trule->u.slash_cnt = slash_cnt;\n\n\tif (!listp->tail) {\n\t\trule->next = listp->head;\n\t\tlistp->head = listp->tail = rule;\n\t} else {\n\t\trule->next = listp->tail->next;\n\t\tlistp->tail->next = rule;\n\t\tlistp->tail = rule;\n\t}\n}\n\n/* If the wildcards failed, the remote shell might give us a file matching the literal\n * wildcards.  Since \"*\" & \"?\" already match themselves, this just needs to deal with\n * failed \"[foo]\" idioms.\n */\nstatic void maybe_add_literal_brackets_rule(filter_rule const *based_on, int arg_len)\n{\n\tfilter_rule *rule;\n\tconst char *arg = based_on->pattern, *cp;\n\tchar *p;\n\tint cnt = 0;\n\n\tif (arg_len < 0)\n\t\targ_len = strlen(arg);\n\n\tfor (cp = arg; *cp; cp++) {\n\t\tif (*cp == '\\\\' && cp[1]) {\n\t\t\tcp++;\n\t\t} else if (*cp == '[')\n\t\t\tcnt++;\n\t}\n\tif (!cnt)\n\t\treturn;\n\n\trule = new0(filter_rule);\n\trule->rflags = based_on->rflags;\n\trule->u.slash_cnt = based_on->u.slash_cnt;\n\tp = rule->pattern = new_array(char, arg_len + cnt + 1);\n\tfor (cp = arg; *cp; ) {\n\t\tif (*cp == '\\\\' && cp[1]) {\n\t\t\t*p++ = *cp++;\n\t\t} else if (*cp == '[')\n\t\t\t*p++ = '\\\\';\n\t\t*p++ = *cp++;\n\t}\n\t*p++ = '\\0';\n\n\trule->next = implied_filter_list.head;\n\timplied_filter_list.head = rule;\n\tif (DEBUG_GTE(FILTER, 3)) {\n\t\trprintf(FINFO, \"[%s] add_implied_include(%s%s)\\n\", who_am_i(), rule->pattern,\n\t\t\trule->rflags & FILTRULE_DIRECTORY ? \"/\" : \"\");\n\t}\n}\n\nstatic char *partial_string_buf = NULL;\nstatic int partial_string_len = 0;\nvoid implied_include_partial_string(const char *s_start, const char *s_end)\n{\n\tpartial_string_len = s_end - s_start;\n\tif (partial_string_len <= 0 || partial_string_len >= MAXPATHLEN) { /* too-large should be impossible... */\n\t\tpartial_string_len = 0;\n\t\treturn;\n\t}\n\tif (!partial_string_buf)\n\t\tpartial_string_buf = new_array(char, MAXPATHLEN);\n\tmemcpy(partial_string_buf, s_start, partial_string_len);\n}\n\nvoid free_implied_include_partial_string()\n{\n\tif (partial_string_buf) {\n\t\tif (partial_string_len)\n\t\t\tadd_implied_include(\"\", 0);\n\t\tfree(partial_string_buf);\n\t\tpartial_string_buf = NULL;\n\t}\n\tpartial_string_len = 0; /* paranoia */\n}\n\n/* Each arg the client sends to the remote sender turns into an implied include\n * that the receiver uses to validate the file list from the sender. */\nvoid add_implied_include(const char *arg, int skip_daemon_module)\n{\n\tint arg_len, saw_wild = 0, saw_live_open_brkt = 0, backslash_cnt = 0;\n\tint slash_cnt = 0;\n\tconst char *cp;\n\tchar *p;\n\tif (trust_sender_args)\n\t\treturn;\n\tif (partial_string_len) {\n\t\targ_len = strlen(arg);\n\t\tif (partial_string_len + arg_len >= MAXPATHLEN) {\n\t\t\tpartial_string_len = 0;\n\t\t\treturn; /* Should be impossible... */\n\t\t}\n\t\tmemcpy(partial_string_buf + partial_string_len, arg, arg_len + 1);\n\t\tpartial_string_len = 0;\n\t\targ = partial_string_buf;\n\t}\n\tif (skip_daemon_module) {\n\t\tif ((cp = strchr(arg, '/')) != NULL)\n\t\t\targ = cp + 1;\n\t\telse\n\t\t\targ = \"\";\n\t}\n\tif (relative_paths) {\n\t\tif ((cp = strstr(arg, \"/./\")) != NULL)\n\t\t\targ = cp + 3;\n\t} else if ((cp = strrchr(arg, '/')) != NULL) {\n\t\targ = cp + 1;\n\t}\n\tif (*arg == '.' && arg[1] == '\\0')\n\t\targ++;\n\targ_len = strlen(arg);\n\tif (arg_len) {\n\t\tchar *new_pat;\n\t\tif (strpbrk(arg, \"*[?\")) {\n\t\t\t/* We need to add room to escape backslashes if wildcard chars are present. */\n\t\t\tfor (cp = arg; (cp = strchr(cp, '\\\\')) != NULL; cp++)\n\t\t\t\targ_len++;\n\t\t\tsaw_wild = 1;\n\t\t}\n\t\targ_len++; /* Leave room for the prefixed slash */\n\t\tp = new_pat = new_array(char, arg_len + 1);\n\t\t*p++ = '/';\n\t\tslash_cnt++;\n\t\tfor (cp = arg; *cp; ) {\n\t\t\tswitch (*cp) {\n\t\t\t  case '\\\\':\n\t\t\t\tif (cp[1] == ']') {\n\t\t\t\t\tif (!saw_wild)\n\t\t\t\t\t\tcp++; /* A \\] in a non-wild filter causes a problem, so drop the \\ . */\n\t\t\t\t} else if (!strchr(\"*[?\", cp[1])) {\n\t\t\t\t\tbackslash_cnt++;\n\t\t\t\t\tif (saw_wild)\n\t\t\t\t\t\t*p++ = '\\\\';\n\t\t\t\t}\n\t\t\t\t*p++ = *cp++;\n\t\t\t\tbreak;\n\t\t\t  case '/':\n\t\t\t\tif (p[-1] == '/') { /* This is safe because of the initial slash. */\n\t\t\t\t\tif (*++cp == '\\0') {\n\t\t\t\t\t\tslash_cnt--;\n\t\t\t\t\t\tp--;\n\t\t\t\t\t}\n\t\t\t\t} else if (cp[1] == '\\0') {\n\t\t\t\t\tcp++;\n\t\t\t\t} else {\n\t\t\t\t\tslash_cnt++;\n\t\t\t\t\t*p++ = *cp++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t  case '.':\n\t\t\t\tif (p[-1] == '/') {\n\t\t\t\t\tif (cp[1] == '/') {\n\t\t\t\t\t\tcp += 2;\n\t\t\t\t\t\tif (!*cp) {\n\t\t\t\t\t\t\tslash_cnt--;\n\t\t\t\t\t\t\tp--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (cp[1] == '\\0') {\n\t\t\t\t\t\tcp++;\n\t\t\t\t\t\tslash_cnt--;\n\t\t\t\t\t\tp--;\n\t\t\t\t\t} else\n\t\t\t\t\t\t*p++ = *cp++;\n\t\t\t\t} else\n\t\t\t\t\t*p++ = *cp++;\n\t\t\t\tbreak;\n\t\t\t  case '[':\n\t\t\t\tsaw_live_open_brkt = 1;\n\t\t\t\t*p++ = *cp++;\n\t\t\t\tbreak;\n\t\t\t  default:\n\t\t\t\t*p++ = *cp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*p = '\\0';\n\t\targ_len = p - new_pat;\n\t\tif (!arg_len)\n\t\t\tfree(new_pat);\n\t\telse {\n\t\t\tfilter_rule *rule = new0(filter_rule);\n\t\t\trule->rflags = FILTRULE_INCLUDE + (saw_wild ? FILTRULE_WILD : 0);\n\t\t\trule->u.slash_cnt = slash_cnt;\n\t\t\targ = rule->pattern = new_pat;\n\t\t\tif (!implied_filter_list.head)\n\t\t\t\timplied_filter_list.head = implied_filter_list.tail = rule;\n\t\t\telse {\n\t\t\t\trule->next = implied_filter_list.head;\n\t\t\t\timplied_filter_list.head = rule;\n\t\t\t}\n\t\t\tif (DEBUG_GTE(FILTER, 3))\n\t\t\t\trprintf(FINFO, \"[%s] add_implied_include(%s)\\n\", who_am_i(), arg);\n\t\t\tif (saw_live_open_brkt)\n\t\t\t\tmaybe_add_literal_brackets_rule(rule, arg_len);\n\t\t\tif (relative_paths && slash_cnt) {\n\t\t\t\tint sub_slash_cnt = slash_cnt;\n\t\t\t\twhile ((p = strrchr(new_pat, '/')) != NULL && p != new_pat) {\n\t\t\t\t\tfilter_rule const *ent;\n\t\t\t\t\tfilter_rule *R_rule;\n\t\t\t\t\tint found = 0;\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tfor (ent = implied_filter_list.head; ent; ent = ent->next) {\n\t\t\t\t\t\tif (ent != rule && strcmp(ent->pattern, new_pat) == 0) {\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*p = '/';\n\t\t\t\t\t\tbreak; /* We added all parent dirs already */\n\t\t\t\t\t}\n\t\t\t\t\tR_rule = new0(filter_rule);\n\t\t\t\t\tR_rule->rflags = FILTRULE_INCLUDE | FILTRULE_DIRECTORY;\n\t\t\t\t\t/* Check if our sub-path has wildcards or escaped backslashes */\n\t\t\t\t\tif (saw_wild && strpbrk(new_pat, \"*[?\\\\\"))\n\t\t\t\t\t\tR_rule->rflags |= FILTRULE_WILD;\n\t\t\t\t\tR_rule->pattern = strdup(new_pat);\n\t\t\t\t\tR_rule->u.slash_cnt = --sub_slash_cnt;\n\t\t\t\t\tR_rule->next = implied_filter_list.head;\n\t\t\t\t\timplied_filter_list.head = R_rule;\n\t\t\t\t\tif (DEBUG_GTE(FILTER, 3)) {\n\t\t\t\t\t\trprintf(FINFO, \"[%s] add_implied_include(%s/)\\n\",\n\t\t\t\t\t\t\twho_am_i(), R_rule->pattern);\n\t\t\t\t\t}\n\t\t\t\t\tif (saw_live_open_brkt)\n\t\t\t\t\t\tmaybe_add_literal_brackets_rule(R_rule, -1);\n\t\t\t\t}\n\t\t\t\tfor (p = new_pat; sub_slash_cnt < slash_cnt; sub_slash_cnt++) {\n\t\t\t\t\tp += strlen(p);\n\t\t\t\t\t*p = '/';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (recurse || xfer_dirs) {\n\t\t/* Now create a rule with an added \"/\" & \"**\" or \"*\" at the end */\n\t\tfilter_rule *rule = new0(filter_rule);\n\t\trule->rflags = FILTRULE_INCLUDE | FILTRULE_WILD;\n\t\tif (recurse)\n\t\t\trule->rflags |= FILTRULE_WILD2;\n\t\t/* We must leave enough room for / * * \\0. */\n\t\tif (!saw_wild && backslash_cnt) {\n\t\t\t/* We are appending a wildcard, so now the backslashes need to be escaped. */\n\t\t\tp = rule->pattern = new_array(char, arg_len + backslash_cnt + 3 + 1);\n\t\t\tfor (cp = arg; *cp; ) { /* Note that arg_len != 0 because backslash_cnt > 0 */\n\t\t\t\tif (*cp == '\\\\')\n\t\t\t\t\t*p++ = '\\\\';\n\t\t\t\t*p++ = *cp++;\n\t\t\t}\n\t\t} else {\n\t\t\tp = rule->pattern = new_array(char, arg_len + 3 + 1);\n\t\t\tif (arg_len) {\n\t\t\t\tmemcpy(p, arg, arg_len);\n\t\t\t\tp += arg_len;\n\t\t\t}\n\t\t}\n\t\t*p++ = '/';\n\t\t*p++ = '*';\n\t\tif (recurse)\n\t\t\t*p++ = '*';\n\t\t*p = '\\0';\n\t\trule->u.slash_cnt = slash_cnt + 1;\n\t\trule->next = implied_filter_list.head;\n\t\timplied_filter_list.head = rule;\n\t\tif (DEBUG_GTE(FILTER, 3))\n\t\t\trprintf(FINFO, \"[%s] add_implied_include(%s)\\n\", who_am_i(), rule->pattern);\n\t\tif (saw_live_open_brkt)\n\t\t\tmaybe_add_literal_brackets_rule(rule, p - rule->pattern);\n\t}\n}\n\n/* This frees any non-inherited items, leaving just inherited items on the list. */\nstatic void pop_filter_list(filter_rule_list *listp)\n{\n\tfilter_rule *inherited;\n\n\tif (!listp->tail)\n\t\treturn;\n\n\tinherited = listp->tail->next;\n\n\t/* Truncate any inherited items from the local list. */\n\tlistp->tail->next = NULL;\n\t/* Now free everything that is left. */\n\tfree_filters(listp->head);\n\n\tlistp->head = inherited;\n\tlistp->tail = NULL;\n}\n\n/* This returns an expanded (absolute) filename for the merge-file name if\n * the name has any slashes in it OR if the parent_dirscan var is True;\n * otherwise it returns the original merge_file name.  If the len_ptr value\n * is non-NULL the merge_file name is limited by the referenced length\n * value and will be updated with the length of the resulting name.  We\n * always return a name that is null terminated, even if the merge_file\n * name was not. */\nstatic char *parse_merge_name(const char *merge_file, unsigned int *len_ptr,\n\t\t\t      unsigned int prefix_skip)\n{\n\tstatic char buf[MAXPATHLEN];\n\tchar *fn, tmpbuf[MAXPATHLEN];\n\tunsigned int fn_len;\n\n\tif (!parent_dirscan && *merge_file != '/') {\n\t\t/* Return the name unchanged it doesn't have any slashes. */\n\t\tif (len_ptr) {\n\t\t\tconst char *p = merge_file + *len_ptr;\n\t\t\twhile (--p > merge_file && *p != '/') {}\n\t\t\tif (p == merge_file) {\n\t\t\t\tstrlcpy(buf, merge_file, *len_ptr + 1);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t} else if (strchr(merge_file, '/') == NULL)\n\t\t\treturn (char *)merge_file;\n\t}\n\n\tfn = *merge_file == '/' ? buf : tmpbuf;\n\tif (sanitize_paths) {\n\t\tconst char *r = prefix_skip ? \"/\" : NULL;\n\t\t/* null-terminate the name if it isn't already */\n\t\tif (len_ptr && merge_file[*len_ptr]) {\n\t\t\tchar *to = fn == buf ? tmpbuf : buf;\n\t\t\tstrlcpy(to, merge_file, *len_ptr + 1);\n\t\t\tmerge_file = to;\n\t\t}\n\t\tif (!sanitize_path(fn, merge_file, r, dirbuf_depth, SP_DEFAULT)) {\n\t\t\trprintf(FERROR, \"merge-file name overflows: %s\\n\",\n\t\t\t\tmerge_file);\n\t\t\treturn NULL;\n\t\t}\n\t\tfn_len = strlen(fn);\n\t} else {\n\t\tstrlcpy(fn, merge_file, len_ptr ? *len_ptr + 1 : MAXPATHLEN);\n\t\tfn_len = clean_fname(fn, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t}\n\n\t/* If the name isn't in buf yet, it wasn't absolute. */\n\tif (fn != buf) {\n\t\tint d_len = dirbuf_len - prefix_skip;\n\t\tif (d_len + fn_len >= MAXPATHLEN) {\n\t\t\trprintf(FERROR, \"merge-file name overflows: %s\\n\", fn);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(buf, dirbuf + prefix_skip, d_len);\n\t\tmemcpy(buf + d_len, fn, fn_len + 1);\n\t\tfn_len = clean_fname(buf, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t}\n\n\tif (len_ptr)\n\t\t*len_ptr = fn_len;\n\treturn buf;\n}\n\n/* Sets the dirbuf and dirbuf_len values. */\nvoid set_filter_dir(const char *dir, unsigned int dirlen)\n{\n\tunsigned int len;\n\tif (*dir != '/') {\n\t\tmemcpy(dirbuf, curr_dir, curr_dir_len);\n\t\tdirbuf[curr_dir_len] = '/';\n\t\tlen = curr_dir_len + 1;\n\t\tif (len + dirlen >= MAXPATHLEN)\n\t\t\tdirlen = 0;\n\t} else\n\t\tlen = 0;\n\tmemcpy(dirbuf + len, dir, dirlen);\n\tdirbuf[dirlen + len] = '\\0';\n\tdirbuf_len = clean_fname(dirbuf, CFN_COLLAPSE_DOT_DOT_DIRS);\n\tif (dirbuf_len > 1 && dirbuf[dirbuf_len-1] == '.'\n\t    && dirbuf[dirbuf_len-2] == '/')\n\t\tdirbuf_len -= 2;\n\tif (dirbuf_len != 1)\n\t\tdirbuf[dirbuf_len++] = '/';\n\tdirbuf[dirbuf_len] = '\\0';\n\tif (sanitize_paths)\n\t\tdirbuf_depth = count_dir_elements(dirbuf + module_dirlen);\n}\n\n/* This routine takes a per-dir merge-file entry and finishes its setup.\n * If the name has a path portion then we check to see if it refers to a\n * parent directory of the first transfer dir.  If it does, we scan all the\n * dirs from that point through the parent dir of the transfer dir looking\n * for the per-dir merge-file in each one. */\nstatic BOOL setup_merge_file(int mergelist_num, filter_rule *ex,\n\t\t\t     filter_rule_list *lp)\n{\n\tchar buf[MAXPATHLEN];\n\tchar *x, *y, *pat = ex->pattern;\n\tunsigned int len;\n\n\tif (!(x = parse_merge_name(pat, NULL, 0)) || *x != '/')\n\t\treturn 0;\n\n\tif (DEBUG_GTE(FILTER, 2)) {\n\t\trprintf(FINFO, \"[%s] performing parent_dirscan for mergelist #%d%s\\n\",\n\t\t\twho_am_i(), mergelist_num, lp->debug_type);\n\t}\n\ty = strrchr(x, '/');\n\t*y = '\\0';\n\tex->pattern = strdup(y+1);\n\tif (!*x)\n\t\tx = \"/\";\n\tif (*x == '/')\n\t\tstrlcpy(buf, x, MAXPATHLEN);\n\telse\n\t\tpathjoin(buf, MAXPATHLEN, dirbuf, x);\n\n\tlen = clean_fname(buf, CFN_COLLAPSE_DOT_DOT_DIRS);\n\tif (len != 1 && len < MAXPATHLEN-1) {\n\t\tbuf[len++] = '/';\n\t\tbuf[len] = '\\0';\n\t}\n\t/* This ensures that the specified dir is a parent of the transfer. */\n\tfor (x = buf, y = dirbuf; *x && *x == *y; x++, y++) {}\n\tif (*x)\n\t\ty += strlen(y); /* nope -- skip the scan */\n\n\tparent_dirscan = True;\n\twhile (*y) {\n\t\tchar save[MAXPATHLEN];\n\t\t/* copylen is strlen(y) which is < MAXPATHLEN. +1 for \\0 */\n\t\tsize_t copylen = strlcpy(save, y, MAXPATHLEN) + 1;\n\t\t*y = '\\0';\n\t\tdirbuf_len = y - dirbuf;\n\t\tstrlcpy(x, ex->pattern, MAXPATHLEN - (x - buf));\n\t\tparse_filter_file(lp, buf, ex, XFLG_ANCHORED2ABS);\n\t\tif (ex->rflags & FILTRULE_NO_INHERIT) {\n\t\t\t/* Free the undesired rules to clean up any per-dir\n\t\t\t * mergelists they defined.  Otherwise pop_local_filters\n\t\t\t * may crash trying to restore nonexistent state for\n\t\t\t * those mergelists. */\n\t\t\tfree_filters(lp->head);\n\t\t\tlp->head = NULL;\n\t\t}\n\t\tlp->tail = NULL;\n\t\tstrlcpy(y, save, copylen);\n\t\twhile ((*x++ = *y++) != '/') {}\n\t}\n\tparent_dirscan = False;\n\tif (DEBUG_GTE(FILTER, 2)) {\n\t\trprintf(FINFO, \"[%s] completed parent_dirscan for mergelist #%d%s\\n\",\n\t\t\twho_am_i(), mergelist_num, lp->debug_type);\n\t}\n\tfree(pat);\n\treturn 1;\n}\n\nstruct local_filter_state {\n\tint mergelist_cnt;\n\tfilter_rule_list mergelists[1];\n};\n\n/* Each time rsync changes to a new directory it call this function to\n * handle all the per-dir merge-files.  The \"dir\" value is the current path\n * relative to curr_dir (which might not be null-terminated).  We copy it\n * into dirbuf so that we can easily append a file name on the end. */\nvoid *push_local_filters(const char *dir, unsigned int dirlen)\n{\n\tstruct local_filter_state *push;\n\tint i;\n\n\tset_filter_dir(dir, dirlen);\n\tif (DEBUG_GTE(FILTER, 2)) {\n\t\trprintf(FINFO, \"[%s] pushing local filters for %s\\n\",\n\t\t\twho_am_i(), dirbuf);\n\t}\n\n\tif (!mergelist_cnt) {\n\t\t/* No old state to save and no new merge files to push. */\n\t\treturn NULL;\n\t}\n\n\tpush = (struct local_filter_state *)new_array(char,\n\t\t\t  sizeof (struct local_filter_state)\n\t\t\t+ (mergelist_cnt-1) * sizeof (filter_rule_list));\n\n\tpush->mergelist_cnt = mergelist_cnt;\n\tfor (i = 0; i < mergelist_cnt; i++) {\n\t\tfilter_rule *ex = mergelist_parents[i];\n\t\tif (!ex)\n\t\t\tcontinue;\n\t\tmemcpy(&push->mergelists[i], ex->u.mergelist, sizeof (filter_rule_list));\n\t}\n\n\t/* Note: parse_filter_file() might increase mergelist_cnt, so keep\n\t * this loop separate from the above loop. */\n\tfor (i = 0; i < mergelist_cnt; i++) {\n\t\tfilter_rule *ex = mergelist_parents[i];\n\t\tfilter_rule_list *lp;\n\t\tif (!ex)\n\t\t\tcontinue;\n\t\tlp = ex->u.mergelist;\n\n\t\tif (DEBUG_GTE(FILTER, 2)) {\n\t\t\trprintf(FINFO, \"[%s] pushing mergelist #%d%s\\n\",\n\t\t\t\twho_am_i(), i, lp->debug_type);\n\t\t}\n\n\t\tlp->tail = NULL; /* Switch any local rules to inherited. */\n\t\tif (ex->rflags & FILTRULE_NO_INHERIT)\n\t\t\tlp->head = NULL;\n\n\t\tif (ex->rflags & FILTRULE_FINISH_SETUP) {\n\t\t\tex->rflags &= ~FILTRULE_FINISH_SETUP;\n\t\t\tif (setup_merge_file(i, ex, lp))\n\t\t\t\tset_filter_dir(dir, dirlen);\n\t\t}\n\n\t\tif (strlcpy(dirbuf + dirbuf_len, ex->pattern,\n\t\t    MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len) {\n\t\t\tparse_filter_file(lp, dirbuf, ex,\n\t\t\t\t\t  XFLG_ANCHORED2ABS);\n\t\t} else {\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trprintf(FERROR,\n\t\t\t    \"cannot add local filter rules in long-named directory: %s\\n\",\n\t\t\t    full_fname(dirbuf));\n\t\t}\n\t\tdirbuf[dirbuf_len] = '\\0';\n\t}\n\n\treturn (void*)push;\n}\n\nvoid pop_local_filters(void *mem)\n{\n\tstruct local_filter_state *pop = (struct local_filter_state *)mem;\n\tint i;\n\tint old_mergelist_cnt = pop ? pop->mergelist_cnt : 0;\n\n\tif (DEBUG_GTE(FILTER, 2))\n\t\trprintf(FINFO, \"[%s] popping local filters\\n\", who_am_i());\n\n\tfor (i = mergelist_cnt; i-- > 0; ) {\n\t\tfilter_rule *ex = mergelist_parents[i];\n\t\tfilter_rule_list *lp;\n\t\tif (!ex)\n\t\t\tcontinue;\n\t\tlp = ex->u.mergelist;\n\n\t\tif (DEBUG_GTE(FILTER, 2)) {\n\t\t\trprintf(FINFO, \"[%s] popping mergelist #%d%s\\n\",\n\t\t\t\twho_am_i(), i, lp->debug_type);\n\t\t}\n\n\t\tpop_filter_list(lp);\n\t\tif (i >= old_mergelist_cnt && lp->head) {\n\t\t\t/* This mergelist does not exist in the state to be restored, but it\n\t\t\t * still has inherited rules.  This can sometimes happen if a per-dir\n\t\t\t * merge file calls setup_merge_file() in push_local_filters() and that\n\t\t\t * leaves some inherited rules that aren't in the pushed list state. */\n\t\t\tif (DEBUG_GTE(FILTER, 2)) {\n\t\t\t\trprintf(FINFO, \"[%s] freeing parent_dirscan filters of mergelist #%d%s\\n\",\n\t\t\t\t\twho_am_i(), i, ex->u.mergelist->debug_type);\n\t\t\t}\n\t\t\tpop_filter_list(lp);\n\t\t}\n\t}\n\n\tif (!pop)\n\t\treturn; /* No state to restore. */\n\n\tfor (i = 0; i < old_mergelist_cnt; i++) {\n\t\tfilter_rule *ex = mergelist_parents[i];\n\t\tif (!ex)\n\t\t\tcontinue;\n\t\tmemcpy(ex->u.mergelist, &pop->mergelists[i], sizeof (filter_rule_list));\n\t}\n\n\tfree(pop);\n}\n\nvoid change_local_filter_dir(const char *dname, int dlen, int dir_depth)\n{\n\tstatic int cur_depth = -1;\n\tstatic void *filt_array[MAXPATHLEN/2+1];\n\n\tif (!dname) {\n\t\tfor ( ; cur_depth >= 0; cur_depth--) {\n\t\t\tif (filt_array[cur_depth]) {\n\t\t\t\tpop_local_filters(filt_array[cur_depth]);\n\t\t\t\tfilt_array[cur_depth] = NULL;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tassert(dir_depth < MAXPATHLEN/2+1);\n\n\tfor ( ; cur_depth >= dir_depth; cur_depth--) {\n\t\tif (filt_array[cur_depth]) {\n\t\t\tpop_local_filters(filt_array[cur_depth]);\n\t\t\tfilt_array[cur_depth] = NULL;\n\t\t}\n\t}\n\n\tcur_depth = dir_depth;\n\tfilt_array[cur_depth] = push_local_filters(dname, dlen);\n}\n\nstatic int rule_matches(const char *fname, filter_rule *ex, int name_flags)\n{\n\tint slash_handling, str_cnt = 0, anchored_match = 0;\n\tint ret_match = ex->rflags & FILTRULE_NEGATE ? 0 : 1;\n\tchar *p, *pattern = ex->pattern;\n\tconst char *strings[16]; /* more than enough */\n\tconst char *name = fname + (*fname == '/');\n\n\tif (!*name || ex->elide == cur_elide_value)\n\t\treturn 0;\n\n\tif (!(name_flags & NAME_IS_XATTR) ^ !(ex->rflags & FILTRULE_XATTR))\n\t\treturn 0;\n\n\tif (!ex->u.slash_cnt && !(ex->rflags & FILTRULE_WILD2)) {\n\t\t/* If the pattern does not have any slashes AND it does\n\t\t * not have a \"**\" (which could match a slash), then we\n\t\t * just match the name portion of the path. */\n\t\tif ((p = strrchr(name,'/')) != NULL)\n\t\t\tname = p+1;\n\t} else if (ex->rflags & FILTRULE_ABS_PATH && *fname != '/'\n\t    && curr_dir_len > module_dirlen + 1) {\n\t\t/* If we're matching against an absolute-path pattern,\n\t\t * we need to prepend our full path info. */\n\t\tstrings[str_cnt++] = curr_dir + module_dirlen + 1;\n\t\tstrings[str_cnt++] = \"/\";\n\t} else if (ex->rflags & FILTRULE_WILD2_PREFIX && *fname != '/') {\n\t\t/* Allow \"**\"+\"/\" to match at the start of the string. */\n\t\tstrings[str_cnt++] = \"/\";\n\t}\n\tstrings[str_cnt++] = name;\n\tif (name_flags & NAME_IS_DIR) {\n\t\t/* Allow a trailing \"/\"+\"***\" to match the directory. */\n\t\tif (ex->rflags & FILTRULE_WILD3_SUFFIX)\n\t\t\tstrings[str_cnt++] = \"/\";\n\t} else if (ex->rflags & FILTRULE_DIRECTORY)\n\t\treturn !ret_match;\n\tstrings[str_cnt] = NULL;\n\n\tif (*pattern == '/') {\n\t\tanchored_match = 1;\n\t\tpattern++;\n\t}\n\n\tif (!anchored_match && ex->u.slash_cnt\n\t    && !(ex->rflags & FILTRULE_WILD2)) {\n\t\t/* A non-anchored match with an infix slash and no \"**\"\n\t\t * needs to match the last slash_cnt+1 name elements. */\n\t\tslash_handling = ex->u.slash_cnt + 1;\n\t} else if (!anchored_match && !(ex->rflags & FILTRULE_WILD2_PREFIX)\n\t\t\t\t   && ex->rflags & FILTRULE_WILD2) {\n\t\t/* A non-anchored match with an infix or trailing \"**\" (but not\n\t\t * a prefixed \"**\") needs to try matching after every slash. */\n\t\tslash_handling = -1;\n\t} else {\n\t\t/* The pattern matches only at the start of the path or name. */\n\t\tslash_handling = 0;\n\t}\n\n\tif (ex->rflags & FILTRULE_WILD) {\n\t\tif (wildmatch_array(pattern, strings, slash_handling))\n\t\t\treturn ret_match;\n\t} else if (str_cnt > 1) {\n\t\tif (litmatch_array(pattern, strings, slash_handling))\n\t\t\treturn ret_match;\n\t} else if (anchored_match) {\n\t\tif (strcmp(name, pattern) == 0)\n\t\t\treturn ret_match;\n\t} else {\n\t\tint l1 = strlen(name);\n\t\tint l2 = strlen(pattern);\n\t\tif (l2 <= l1 &&\n\t\t    strcmp(name+(l1-l2),pattern) == 0 &&\n\t\t    (l1==l2 || name[l1-(l2+1)] == '/')) {\n\t\t\treturn ret_match;\n\t\t}\n\t}\n\n\treturn !ret_match;\n}\n\nstatic void report_filter_result(enum logcode code, char const *name,\n\t\t\t\t filter_rule const *ent,\n\t\t\t\t int name_flags, const char *type)\n{\n\tint log_level = am_sender || am_generator ? 1 : 3;\n\n\t/* If a trailing slash is present to match only directories,\n\t * then it is stripped out by add_rule().  So as a special\n\t * case we add it back in the log output. */\n\tif (DEBUG_GTE(FILTER, log_level)) {\n\t\tstatic char *actions[2][2]\n\t\t    = { {\"show\", \"hid\"}, {\"risk\", \"protect\"} };\n\t\tconst char *w = who_am_i();\n\t\tconst char *t = name_flags & NAME_IS_XATTR ? \"xattr\"\n\t\t\t      : name_flags & NAME_IS_DIR ? \"directory\"\n\t\t\t      : \"file\";\n\t\trprintf(code, \"[%s] %sing %s %s because of pattern %s%s%s\\n\",\n\t\t    w, actions[*w=='g'][!(ent->rflags & FILTRULE_INCLUDE)],\n\t\t    t, name, ent->pattern,\n\t\t    ent->rflags & FILTRULE_DIRECTORY ? \"/\" : \"\", type);\n\t}\n}\n\n/* This function is used to check if a file should be included/excluded\n * from the list of files based on its name and type etc.  The value of\n * filter_level is set to either SERVER_FILTERS or ALL_FILTERS. */\nint name_is_excluded(const char *fname, int name_flags, int filter_level)\n{\n\tif (daemon_filter_list.head && check_filter(&daemon_filter_list, FLOG, fname, name_flags) < 0) {\n\t\tif (!(name_flags & NAME_IS_XATTR))\n\t\t\terrno = ENOENT;\n\t\treturn 1;\n\t}\n\n\tif (filter_level != ALL_FILTERS)\n\t\treturn 0;\n\n\tif (filter_list.head && check_filter(&filter_list, FINFO, fname, name_flags) < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint check_server_filter(filter_rule_list *listp, enum logcode code, const char *name, int name_flags)\n{\n\tint ret;\n\tcur_elide_value = LOCAL_RULE;\n\tret = check_filter(listp, code, name, name_flags);\n\tcur_elide_value = REMOTE_RULE;\n\treturn ret;\n}\n\n/* Return -1 if file \"name\" is defined to be excluded by the specified\n * exclude list, 1 if it is included, and 0 if it was not matched. */\nint check_filter(filter_rule_list *listp, enum logcode code,\n\t\t const char *name, int name_flags)\n{\n\tfilter_rule *ent;\n\n\tfor (ent = listp->head; ent; ent = ent->next) {\n\t\tif (ignore_perishable && ent->rflags & FILTRULE_PERISHABLE)\n\t\t\tcontinue;\n\t\tif (ent->rflags & FILTRULE_PERDIR_MERGE) {\n\t\t\tint rc = check_filter(ent->u.mergelist, code, name, name_flags);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ent->rflags & FILTRULE_CVS_IGNORE) {\n\t\t\tint rc = check_filter(&cvs_filter_list, code, name, name_flags);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rule_matches(name, ent, name_flags)) {\n\t\t\treport_filter_result(code, name, ent, name_flags, listp->debug_type);\n\t\t\treturn ent->rflags & FILTRULE_INCLUDE ? 1 : -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define RULE_STRCMP(s,r) rule_strcmp((s), (r), sizeof (r) - 1)\n\nstatic const uchar *rule_strcmp(const uchar *str, const char *rule, int rule_len)\n{\n\tif (strncmp((char*)str, rule, rule_len) != 0)\n\t\treturn NULL;\n\tif (isspace(str[rule_len]) || str[rule_len] == '_' || !str[rule_len])\n\t\treturn str + rule_len - 1;\n\tif (str[rule_len] == ',')\n\t\treturn str + rule_len;\n\treturn NULL;\n}\n\n#define FILTRULES_FROM_CONTAINER (FILTRULE_ABS_PATH | FILTRULE_INCLUDE \\\n\t\t\t\t| FILTRULE_DIRECTORY | FILTRULE_NEGATE \\\n\t\t\t\t| FILTRULE_PERISHABLE)\n\n/* Gets the next include/exclude rule from *rulestr_ptr and advances\n * *rulestr_ptr to point beyond it.  Stores the pattern's start (within\n * *rulestr_ptr) and length in *pat_ptr and *pat_len_ptr, and returns a newly\n * allocated filter_rule containing the rest of the information.  Returns\n * NULL if there are no more rules in the input.\n *\n * The template provides defaults for the new rule to inherit, and the\n * template rflags and the xflags additionally affect parsing. */\nstatic filter_rule *parse_rule_tok(const char **rulestr_ptr,\n\t\t\t\t   const filter_rule *template, int xflags,\n\t\t\t\t   const char **pat_ptr, unsigned int *pat_len_ptr)\n{\n\tconst uchar *s = (const uchar *)*rulestr_ptr;\n\tfilter_rule *rule;\n\tunsigned int len;\n\n\tif (template->rflags & FILTRULE_WORD_SPLIT) {\n\t\t/* Skip over any initial whitespace. */\n\t\twhile (isspace(*s))\n\t\t\ts++;\n\t\t/* Update to point to real start of rule. */\n\t\t*rulestr_ptr = (const char *)s;\n\t}\n\tif (!*s)\n\t\treturn NULL;\n\n\trule = new0(filter_rule);\n\n\t/* Inherit from the template.  Don't inherit FILTRULES_SIDES; we check\n\t * that later. */\n\trule->rflags = template->rflags & FILTRULES_FROM_CONTAINER;\n\n\t/* Figure out what kind of a filter rule \"s\" is pointing at.  Note\n\t * that if FILTRULE_NO_PREFIXES is set, the rule is either an include\n\t * or an exclude based on the inheritance of the FILTRULE_INCLUDE\n\t * flag (above).  XFLG_OLD_PREFIXES indicates a compatibility mode\n\t * for old include/exclude patterns where just \"+ \" and \"- \" are\n\t * allowed as optional prefixes.  */\n\tif (template->rflags & FILTRULE_NO_PREFIXES) {\n\t\tif (*s == '!' && template->rflags & FILTRULE_CVS_IGNORE)\n\t\t\trule->rflags |= FILTRULE_CLEAR_LIST; /* Tentative! */\n\t} else if (xflags & XFLG_OLD_PREFIXES) {\n\t\tif (*s == '-' && s[1] == ' ') {\n\t\t\trule->rflags &= ~FILTRULE_INCLUDE;\n\t\t\ts += 2;\n\t\t} else if (*s == '+' && s[1] == ' ') {\n\t\t\trule->rflags |= FILTRULE_INCLUDE;\n\t\t\ts += 2;\n\t\t} else if (*s == '!')\n\t\t\trule->rflags |= FILTRULE_CLEAR_LIST; /* Tentative! */\n\t} else {\n\t\tchar ch = 0;\n\t\tBOOL prefix_specifies_side = False;\n\t\tswitch (*s) {\n\t\tcase 'c':\n\t\t\tif ((s = RULE_STRCMP(s, \"clear\")) != NULL)\n\t\t\t\tch = '!';\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif ((s = RULE_STRCMP(s, \"dir-merge\")) != NULL)\n\t\t\t\tch = ':';\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif ((s = RULE_STRCMP(s, \"exclude\")) != NULL)\n\t\t\t\tch = '-';\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif ((s = RULE_STRCMP(s, \"hide\")) != NULL)\n\t\t\t\tch = 'H';\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif ((s = RULE_STRCMP(s, \"include\")) != NULL)\n\t\t\t\tch = '+';\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif ((s = RULE_STRCMP(s, \"merge\")) != NULL)\n\t\t\t\tch = '.';\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif ((s = RULE_STRCMP(s, \"protect\")) != NULL)\n\t\t\t\tch = 'P';\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif ((s = RULE_STRCMP(s, \"risk\")) != NULL)\n\t\t\t\tch = 'R';\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif ((s = RULE_STRCMP(s, \"show\")) != NULL)\n\t\t\t\tch = 'S';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tch = *s;\n\t\t\tif (s[1] == ',')\n\t\t\t\ts++;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ch) {\n\t\tcase ':':\n\t\t\ttrust_sender_filter = 1;\n\t\t\trule->rflags |= FILTRULE_PERDIR_MERGE\n\t\t\t\t      | FILTRULE_FINISH_SETUP;\n\t\t\t/* FALL THROUGH */\n\t\tcase '.':\n\t\t\trule->rflags |= FILTRULE_MERGE_FILE;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\trule->rflags |= FILTRULE_INCLUDE;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\trule->rflags |= FILTRULE_INCLUDE;\n\t\t\t/* FALL THROUGH */\n\t\tcase 'H':\n\t\t\trule->rflags |= FILTRULE_SENDER_SIDE;\n\t\t\tprefix_specifies_side = True;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trule->rflags |= FILTRULE_INCLUDE;\n\t\t\t/* FALL THROUGH */\n\t\tcase 'P':\n\t\t\trule->rflags |= FILTRULE_RECEIVER_SIDE;\n\t\t\tprefix_specifies_side = True;\n\t\t\tbreak;\n\t\tcase '!':\n\t\t\trule->rflags |= FILTRULE_CLEAR_LIST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trprintf(FERROR, \"Unknown filter rule: `%s'\\n\", *rulestr_ptr);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\twhile (ch != '!' && *++s && *s != ' ' && *s != '_') {\n\t\t\tif (template->rflags & FILTRULE_WORD_SPLIT && isspace(*s)) {\n\t\t\t\ts--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (*s) {\n\t\t\tdefault:\n\t\t\t    invalid:\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"invalid modifier '%c' at position %d in filter rule: %s\\n\",\n\t\t\t\t\t*s, (int)(s - (const uchar *)*rulestr_ptr), *rulestr_ptr);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\tcase '-':\n\t\t\t\tif (!BITS_SETnUNSET(rule->rflags, FILTRULE_MERGE_FILE, FILTRULE_NO_PREFIXES))\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_NO_PREFIXES;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tif (!BITS_SETnUNSET(rule->rflags, FILTRULE_MERGE_FILE, FILTRULE_NO_PREFIXES))\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_NO_PREFIXES\n\t\t\t\t\t      | FILTRULE_INCLUDE;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\trule->rflags |= FILTRULE_ABS_PATH;\n\t\t\t\tbreak;\n\t\t\tcase '!':\n\t\t\t\t/* Negation really goes with the pattern, so it\n\t\t\t\t * isn't useful as a merge-file default. */\n\t\t\t\tif (rule->rflags & FILTRULE_MERGE_FILE)\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_NEGATE;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tif (rule->rflags & FILTRULE_NO_PREFIXES || prefix_specifies_side)\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_NO_PREFIXES\n\t\t\t\t\t      | FILTRULE_WORD_SPLIT\n\t\t\t\t\t      | FILTRULE_NO_INHERIT\n\t\t\t\t\t      | FILTRULE_CVS_IGNORE;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (!(rule->rflags & FILTRULE_MERGE_FILE))\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_EXCLUDE_SELF;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (!(rule->rflags & FILTRULE_MERGE_FILE))\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_NO_INHERIT;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\trule->rflags |= FILTRULE_PERISHABLE;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tif (prefix_specifies_side)\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_RECEIVER_SIDE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (prefix_specifies_side)\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_SENDER_SIDE;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tif (!(rule->rflags & FILTRULE_MERGE_FILE))\n\t\t\t\t\tgoto invalid;\n\t\t\t\trule->rflags |= FILTRULE_WORD_SPLIT;\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\trule->rflags |= FILTRULE_XATTR;\n\t\t\t\tsaw_xattr_filter = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*s)\n\t\t\ts++;\n\t}\n\tif (template->rflags & FILTRULES_SIDES) {\n\t\tif (rule->rflags & FILTRULES_SIDES) {\n\t\t\t/* The filter and template both specify side(s).  This\n\t\t\t * is dodgy (and won't work correctly if the template is\n\t\t\t * a one-sided per-dir merge rule), so reject it. */\n\t\t\trprintf(FERROR,\n\t\t\t\t\"specified-side merge file contains specified-side filter: %s\\n\",\n\t\t\t\t*rulestr_ptr);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\trule->rflags |= template->rflags & FILTRULES_SIDES;\n\t}\n\n\tif (template->rflags & FILTRULE_WORD_SPLIT) {\n\t\tconst uchar *cp = s;\n\t\t/* Token ends at whitespace or the end of the string. */\n\t\twhile (!isspace(*cp) && *cp != '\\0')\n\t\t\tcp++;\n\t\tlen = cp - s;\n\t} else\n\t\tlen = strlen((char*)s);\n\n\tif (rule->rflags & FILTRULE_CLEAR_LIST) {\n\t\tif (!(rule->rflags & FILTRULE_NO_PREFIXES)\n\t\t && !(xflags & XFLG_OLD_PREFIXES) && len) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"'!' rule has trailing characters: %s\\n\", *rulestr_ptr);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tif (len > 1)\n\t\t\trule->rflags &= ~FILTRULE_CLEAR_LIST;\n\t} else if (!len && !(rule->rflags & FILTRULE_CVS_IGNORE)) {\n\t\trprintf(FERROR, \"unexpected end of filter rule: %s\\n\", *rulestr_ptr);\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\t/* --delete-excluded turns an un-modified include/exclude into a sender-side rule.  */\n\tif (delete_excluded\n\t && !(rule->rflags & (FILTRULES_SIDES|FILTRULE_MERGE_FILE|FILTRULE_PERDIR_MERGE)))\n\t\trule->rflags |= FILTRULE_SENDER_SIDE;\n\n\t*pat_ptr = (const char *)s;\n\t*pat_len_ptr = len;\n\t*rulestr_ptr = *pat_ptr + len;\n\treturn rule;\n}\n\nstatic void get_cvs_excludes(uint32 rflags)\n{\n\tstatic int initialized = 0;\n\tchar *p, fname[MAXPATHLEN];\n\n\tif (initialized)\n\t\treturn;\n\tinitialized = 1;\n\n\tparse_filter_str(&cvs_filter_list, default_cvsignore(),\n\t\t\t rule_template(rflags | (protocol_version >= 30 ? FILTRULE_PERISHABLE : 0)),\n\t\t\t 0);\n\n\tp = module_id >= 0 && lp_use_chroot(module_id) ? \"/\" : getenv(\"HOME\");\n\tif (p && pathjoin(fname, MAXPATHLEN, p, \".cvsignore\") < MAXPATHLEN)\n\t\tparse_filter_file(&cvs_filter_list, fname, rule_template(rflags), 0);\n\n\tparse_filter_str(&cvs_filter_list, getenv(\"CVSIGNORE\"), rule_template(rflags), 0);\n}\n\nconst filter_rule *rule_template(uint32 rflags)\n{\n\tstatic filter_rule template; /* zero-initialized */\n\ttemplate.rflags = rflags;\n\treturn &template;\n}\n\nvoid parse_filter_str(filter_rule_list *listp, const char *rulestr,\n\t\t     const filter_rule *template, int xflags)\n{\n\tfilter_rule *rule;\n\tconst char *pat;\n\tunsigned int pat_len;\n\n\tif (!rulestr)\n\t\treturn;\n\n\twhile (1) {\n\t\tuint32 new_rflags;\n\n\t\t/* Remember that the returned string is NOT '\\0' terminated! */\n\t\tif (!(rule = parse_rule_tok(&rulestr, template, xflags, &pat, &pat_len)))\n\t\t\tbreak;\n\n\t\tif (pat_len >= MAXPATHLEN) {\n\t\t\trprintf(FERROR, \"discarding over-long filter: %.*s\\n\",\n\t\t\t\t(int)pat_len, pat);\n\t\t    free_continue:\n\t\t\tfree_filter(rule);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_rflags = rule->rflags;\n\t\tif (new_rflags & FILTRULE_CLEAR_LIST) {\n\t\t\tif (DEBUG_GTE(FILTER, 2)) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"[%s] clearing filter list%s\\n\",\n\t\t\t\t\twho_am_i(), listp->debug_type);\n\t\t\t}\n\t\t\tpop_filter_list(listp);\n\t\t\tlistp->head = NULL;\n\t\t\tgoto free_continue;\n\t\t}\n\n\t\tif (new_rflags & FILTRULE_MERGE_FILE) {\n\t\t\tif (!pat_len) {\n\t\t\t\tpat = \".cvsignore\";\n\t\t\t\tpat_len = 10;\n\t\t\t}\n\t\t\tif (new_rflags & FILTRULE_EXCLUDE_SELF) {\n\t\t\t\tconst char *name;\n\t\t\t\tfilter_rule *excl_self;\n\n\t\t\t\texcl_self = new0(filter_rule);\n\t\t\t\t/* Find the beginning of the basename and add an exclude for it. */\n\t\t\t\tfor (name = pat + pat_len; name > pat && name[-1] != '/'; name--) {}\n\t\t\t\tadd_rule(listp, name, (pat + pat_len) - name, excl_self, 0);\n\t\t\t\trule->rflags &= ~FILTRULE_EXCLUDE_SELF;\n\t\t\t}\n\t\t\tif (new_rflags & FILTRULE_PERDIR_MERGE) {\n\t\t\t\tif (parent_dirscan) {\n\t\t\t\t\tconst char *p;\n\t\t\t\t\tunsigned int len = pat_len;\n\t\t\t\t\tif ((p = parse_merge_name(pat, &len, module_dirlen)))\n\t\t\t\t\t\tadd_rule(listp, p, len, rule, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tfree_filter(rule);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *p;\n\t\t\t\tunsigned int len = pat_len;\n\t\t\t\tif ((p = parse_merge_name(pat, &len, 0)))\n\t\t\t\t\tparse_filter_file(listp, p, rule, XFLG_FATAL_ERRORS);\n\t\t\t\tfree_filter(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tadd_rule(listp, pat, pat_len, rule, xflags);\n\n\t\tif (new_rflags & FILTRULE_CVS_IGNORE\n\t\t    && !(new_rflags & FILTRULE_MERGE_FILE))\n\t\t\tget_cvs_excludes(new_rflags);\n\t}\n}\n\nvoid parse_filter_file(filter_rule_list *listp, const char *fname, const filter_rule *template, int xflags)\n{\n\tFILE *fp;\n\tchar line[BIGPATHBUFLEN];\n\tchar *eob = line + sizeof line - 1;\n\tBOOL word_split = (template->rflags & FILTRULE_WORD_SPLIT) != 0;\n\n\tif (!fname || !*fname)\n\t\treturn;\n\n\tif (*fname != '-' || fname[1] || am_server) {\n\t\tif (daemon_filter_list.head) {\n\t\t\tstrlcpy(line, fname, sizeof line);\n\t\t\tclean_fname(line, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t\t\tif (check_filter(&daemon_filter_list, FLOG, line, 0) < 0)\n\t\t\t\tfp = NULL;\n\t\t\telse\n\t\t\t\tfp = fopen(line, \"rb\");\n\t\t} else\n\t\t\tfp = fopen(fname, \"rb\");\n\t} else\n\t\tfp = stdin;\n\n\tif (DEBUG_GTE(FILTER, 2)) {\n\t\trprintf(FINFO, \"[%s] parse_filter_file(%s,%x,%x)%s\\n\",\n\t\t\twho_am_i(), fname, template->rflags, xflags,\n\t\t\tfp ? \"\" : \" [not found]\");\n\t}\n\n\tif (!fp) {\n\t\tif (xflags & XFLG_FATAL_ERRORS) {\n\t\t\trsyserr(FERROR, errno,\n\t\t\t\t\"failed to open %sclude file %s\",\n\t\t\t\ttemplate->rflags & FILTRULE_INCLUDE ? \"in\" : \"ex\",\n\t\t\t\tfname);\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t\treturn;\n\t}\n\tdirbuf[dirbuf_len] = '\\0';\n\n\twhile (1) {\n\t\tchar *s = line;\n\t\tint ch, overflow = 0;\n\t\twhile (1) {\n\t\t\tif ((ch = getc(fp)) == EOF) {\n\t\t\t\tif (ferror(fp) && errno == EINTR) {\n\t\t\t\t\tclearerr(fp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (word_split && isspace(ch))\n\t\t\t\tbreak;\n\t\t\tif (eol_nulls? !ch : (ch == '\\n' || ch == '\\r'))\n\t\t\t\tbreak;\n\t\t\tif (s < eob)\n\t\t\t\t*s++ = ch;\n\t\t\telse\n\t\t\t\toverflow = 1;\n\t\t}\n\t\tif (overflow) {\n\t\t\trprintf(FERROR, \"discarding over-long filter: %s...\\n\", line);\n\t\t\ts = line;\n\t\t}\n\t\t*s = '\\0';\n\t\t/* Skip an empty token and (when line parsing) comments. */\n\t\tif (*line && (word_split || (*line != ';' && *line != '#')))\n\t\t\tparse_filter_str(listp, line, template, xflags);\n\t\tif (ch == EOF)\n\t\t\tbreak;\n\t}\n\tfclose(fp);\n}\n\n/* If the \"for_xfer\" flag is set, the prefix is made compatible with the\n * current protocol_version (if possible) or a NULL is returned (if not\n * possible). */\nchar *get_rule_prefix(filter_rule *rule, const char *pat, int for_xfer,\n\t\t      unsigned int *plen_ptr)\n{\n\tstatic char buf[MAX_RULE_PREFIX+1];\n\tchar *op = buf;\n\tint legal_len = for_xfer && protocol_version < 29 ? 1 : MAX_RULE_PREFIX-1;\n\n\tif (rule->rflags & FILTRULE_PERDIR_MERGE) {\n\t\tif (legal_len == 1)\n\t\t\treturn NULL;\n\t\t*op++ = ':';\n\t} else if (rule->rflags & FILTRULE_INCLUDE)\n\t\t*op++ = '+';\n\telse if (legal_len != 1\n\t    || ((*pat == '-' || *pat == '+') && pat[1] == ' '))\n\t\t*op++ = '-';\n\telse\n\t\tlegal_len = 0;\n\n\tif (rule->rflags & FILTRULE_ABS_PATH)\n\t\t*op++ = '/';\n\tif (rule->rflags & FILTRULE_NEGATE)\n\t\t*op++ = '!';\n\tif (rule->rflags & FILTRULE_CVS_IGNORE)\n\t\t*op++ = 'C';\n\telse {\n\t\tif (rule->rflags & FILTRULE_NO_INHERIT)\n\t\t\t*op++ = 'n';\n\t\tif (rule->rflags & FILTRULE_WORD_SPLIT)\n\t\t\t*op++ = 'w';\n\t\tif (rule->rflags & FILTRULE_NO_PREFIXES) {\n\t\t\tif (rule->rflags & FILTRULE_INCLUDE)\n\t\t\t\t*op++ = '+';\n\t\t\telse\n\t\t\t\t*op++ = '-';\n\t\t}\n\t}\n\tif (rule->rflags & FILTRULE_EXCLUDE_SELF)\n\t\t*op++ = 'e';\n\tif (rule->rflags & FILTRULE_XATTR)\n\t\t*op++ = 'x';\n\tif (rule->rflags & FILTRULE_SENDER_SIDE\n\t    && (!for_xfer || protocol_version >= 29))\n\t\t*op++ = 's';\n\tif (rule->rflags & FILTRULE_RECEIVER_SIDE\n\t    && (!for_xfer || protocol_version >= 29\n\t     || (delete_excluded && am_sender)))\n\t\t*op++ = 'r';\n\tif (rule->rflags & FILTRULE_PERISHABLE) {\n\t\tif (!for_xfer || protocol_version >= 30)\n\t\t\t*op++ = 'p';\n\t\telse if (am_sender)\n\t\t\treturn NULL;\n\t}\n\tif (op - buf > legal_len)\n\t\treturn NULL;\n\tif (legal_len)\n\t\t*op++ = ' ';\n\t*op = '\\0';\n\tif (plen_ptr)\n\t\t*plen_ptr = op - buf;\n\treturn buf;\n}\n\nstatic void send_rules(int f_out, filter_rule_list *flp)\n{\n\tfilter_rule *ent;\n\n\tfor (ent = flp->head; ent; ent = ent->next) {\n\t\tunsigned int len, plen, dlen;\n\t\tint elide = 0;\n\t\tchar *p;\n\n\t\t/* Note we need to check delete_excluded here in addition to\n\t\t * the code in parse_rule_tok() because some rules may have\n\t\t * been added before we found the --delete-excluded option.\n\t\t * We must also elide any CVS merge-file rules to avoid a\n\t\t * backward compatibility problem, and we elide any no-prefix\n\t\t * merge files as an optimization (since they can only have\n\t\t * include/exclude rules). */\n\t\tif (ent->rflags & FILTRULE_SENDER_SIDE)\n\t\t\telide = am_sender ? LOCAL_RULE : REMOTE_RULE;\n\t\tif (ent->rflags & FILTRULE_RECEIVER_SIDE)\n\t\t\telide = elide ? 0 : am_sender ? REMOTE_RULE : LOCAL_RULE;\n\t\telse if (delete_excluded && !elide\n\t\t && (!(ent->rflags & FILTRULE_PERDIR_MERGE)\n\t\t  || ent->rflags & FILTRULE_NO_PREFIXES))\n\t\t\telide = am_sender ? LOCAL_RULE : REMOTE_RULE;\n\t\tent->elide = elide;\n\t\tif (elide == LOCAL_RULE)\n\t\t\tcontinue;\n\t\tif (ent->rflags & FILTRULE_CVS_IGNORE\n\t\t    && !(ent->rflags & FILTRULE_MERGE_FILE)) {\n\t\t\tint f = am_sender || protocol_version < 29 ? f_out : -2;\n\t\t\tsend_rules(f, &cvs_filter_list);\n\t\t\tif (f == f_out)\n\t\t\t\tcontinue;\n\t\t}\n\t\tp = get_rule_prefix(ent, ent->pattern, 1, &plen);\n\t\tif (!p) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"filter rules are too modern for remote rsync.\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (f_out < 0)\n\t\t\tcontinue;\n\t\tlen = strlen(ent->pattern);\n\t\tdlen = ent->rflags & FILTRULE_DIRECTORY ? 1 : 0;\n\t\tif (!(plen + len + dlen))\n\t\t\tcontinue;\n\t\twrite_int(f_out, plen + len + dlen);\n\t\tif (plen)\n\t\t\twrite_buf(f_out, p, plen);\n\t\twrite_buf(f_out, ent->pattern, len);\n\t\tif (dlen)\n\t\t\twrite_byte(f_out, '/');\n\t}\n}\n\n/* This is only called by the client. */\nvoid send_filter_list(int f_out)\n{\n\tint receiver_wants_list = prune_empty_dirs\n\t    || (delete_mode && (!delete_excluded || protocol_version >= 29));\n\n\tif (local_server || (am_sender && !receiver_wants_list))\n\t\tf_out = -1;\n\tif (cvs_exclude && am_sender) {\n\t\tif (protocol_version >= 29)\n\t\t\tparse_filter_str(&filter_list, \":C\", rule_template(0), 0);\n\t\tparse_filter_str(&filter_list, \"-C\", rule_template(0), 0);\n\t}\n\n\tsend_rules(f_out, &filter_list);\n\n\tif (f_out >= 0)\n\t\twrite_int(f_out, 0);\n\n\tif (cvs_exclude) {\n\t\tif (!am_sender || protocol_version < 29)\n\t\t\tparse_filter_str(&filter_list, \":C\", rule_template(0), 0);\n\t\tif (!am_sender)\n\t\t\tparse_filter_str(&filter_list, \"-C\", rule_template(0), 0);\n\t}\n}\n\n/* This is only called by the server. */\nvoid recv_filter_list(int f_in)\n{\n\tchar line[BIGPATHBUFLEN];\n\tint xflags = protocol_version >= 29 ? 0 : XFLG_OLD_PREFIXES;\n\tint receiver_wants_list = prune_empty_dirs\n\t    || (delete_mode && (!delete_excluded || protocol_version >= 29));\n\tunsigned int len;\n\n\tif (!local_server && (am_sender || receiver_wants_list)) {\n\t\twhile ((len = read_int(f_in)) != 0) {\n\t\t\tif (len >= sizeof line)\n\t\t\t\toverflow_exit(\"recv_rules\");\n\t\t\tread_sbuf(f_in, line, len);\n\t\t\tparse_filter_str(&filter_list, line, rule_template(0), xflags);\n\t\t}\n\t}\n\n\tif (cvs_exclude) {\n\t\tif (local_server || am_sender || protocol_version < 29)\n\t\t\tparse_filter_str(&filter_list, \":C\", rule_template(0), 0);\n\t\tif (local_server || am_sender)\n\t\t\tparse_filter_str(&filter_list, \"-C\", rule_template(0), 0);\n\t}\n\n\tif (local_server) /* filter out any rules that aren't for us. */\n\t\tsend_rules(-1, &filter_list);\n}\n"
        },
        {
          "name": "fileio.c",
          "type": "blob",
          "size": 8.4091796875,
          "content": "/*\n * File IO utilities used in rsync.\n *\n * Copyright (C) 1998 Andrew Tridgell\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2004-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n\n#ifndef ENODATA\n#define ENODATA EAGAIN\n#endif\n\n/* We want all reads to be aligned on 1K boundaries. */\n#define ALIGN_BOUNDARY 1024\n/* How far past the boundary is an offset? */\n#define ALIGNED_OVERSHOOT(oft) ((oft) & (ALIGN_BOUNDARY-1))\n/* Round up a length to the next boundary */\n#define ALIGNED_LENGTH(len) ((((len) - 1) | (ALIGN_BOUNDARY-1)) + 1)\n\nextern int sparse_files;\n\nOFF_T preallocated_len = 0;\n\nstatic OFF_T sparse_seek = 0;\nstatic OFF_T sparse_past_write = 0;\n\nint sparse_end(int f, OFF_T size, int updating_basis_or_equiv)\n{\n\tint ret = 0;\n\n\tif (updating_basis_or_equiv) {\n\t\tif (sparse_seek && do_punch_hole(f, sparse_past_write, sparse_seek) < 0)\n\t\t\tret = -1;\n#ifdef HAVE_FTRUNCATE /* A compilation formality -- in-place requires ftruncate() */\n\t\telse /* Just in case the original file was longer */\n\t\t\tret = do_ftruncate(f, size);\n#endif\n\t} else if (sparse_seek) {\n#ifdef HAVE_FTRUNCATE\n\t\tret = do_ftruncate(f, size);\n#else\n\t\tif (do_lseek(f, sparse_seek-1, SEEK_CUR) != size-1)\n\t\t\tret = -1;\n\t\telse {\n\t\t\tdo {\n\t\t\t\tret = write(f, \"\", 1);\n\t\t\t} while (ret < 0 && errno == EINTR);\n\n\t\t\tret = ret <= 0 ? -1 : 0;\n\t\t}\n#endif\n\t}\n\n\tsparse_past_write = sparse_seek = 0;\n\n\treturn ret;\n}\n\n/* Note that the offset is just the caller letting us know where\n * the current file position is in the file. The use_seek arg tells\n * us that we should seek over matching data instead of writing it. */\nstatic int write_sparse(int f, int use_seek, OFF_T offset, const char *buf, int len)\n{\n\tint l1 = 0, l2 = 0;\n\tint ret;\n\n\tfor (l1 = 0; l1 < len && buf[l1] == 0; l1++) {}\n\tfor (l2 = 0; l2 < len-l1 && buf[len-(l2+1)] == 0; l2++) {}\n\n\tsparse_seek += l1;\n\n\tif (l1 == len)\n\t\treturn len;\n\n\tif (sparse_seek) {\n\t\tif (sparse_past_write >= preallocated_len) {\n\t\t\tif (do_lseek(f, sparse_seek, SEEK_CUR) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (do_punch_hole(f, sparse_past_write, sparse_seek) < 0) {\n\t\t\tsparse_seek = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsparse_seek = l2;\n\tsparse_past_write = offset + len - l2;\n\n\tif (use_seek) {\n\t\t/* The in-place data already matches. */\n\t\tif (do_lseek(f, len - (l1+l2), SEEK_CUR) < 0)\n\t\t\treturn -1;\n\t\treturn len;\n\t}\n\n\twhile ((ret = write(f, buf + l1, len - (l1+l2))) <= 0) {\n\t\tif (ret < 0 && errno == EINTR)\n\t\t\tcontinue;\n\t\tsparse_seek = 0;\n\t\treturn ret;\n\t}\n\n\tif (ret != (int)(len - (l1+l2))) {\n\t\tsparse_seek = 0;\n\t\treturn l1+ret;\n\t}\n\n\treturn len;\n}\n\nstatic char *wf_writeBuf;\nstatic size_t wf_writeBufSize;\nstatic size_t wf_writeBufCnt;\n\nint flush_write_file(int f)\n{\n\tint ret = 0;\n\tchar *bp = wf_writeBuf;\n\n\twhile (wf_writeBufCnt > 0) {\n\t\tif ((ret = write(f, bp, wf_writeBufCnt)) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn ret;\n\t\t}\n\t\twf_writeBufCnt -= ret;\n\t\tbp += ret;\n\t}\n\treturn ret;\n}\n\n/* write_file does not allow incomplete writes.  It loops internally\n * until len bytes are written or errno is set.  Note that use_seek and\n * offset are only used in sparse processing (see write_sparse()). */\nint write_file(int f, int use_seek, OFF_T offset, const char *buf, int len)\n{\n\tint ret = 0;\n\n\twhile (len > 0) {\n\t\tint r1;\n\t\tif (sparse_files > 0) {\n\t\t\tint len1 = MIN(len, SPARSE_WRITE_SIZE);\n\t\t\tr1 = write_sparse(f, use_seek, offset, buf, len1);\n\t\t\toffset += r1;\n\t\t} else {\n\t\t\tif (!wf_writeBuf) {\n\t\t\t\twf_writeBufSize = WRITE_SIZE * 8;\n\t\t\t\twf_writeBufCnt  = 0;\n\t\t\t\twf_writeBuf = new_array(char, wf_writeBufSize);\n\t\t\t}\n\t\t\tr1 = (int)MIN((size_t)len, wf_writeBufSize - wf_writeBufCnt);\n\t\t\tif (r1) {\n\t\t\t\tmemcpy(wf_writeBuf + wf_writeBufCnt, buf, r1);\n\t\t\t\twf_writeBufCnt += r1;\n\t\t\t}\n\t\t\tif (wf_writeBufCnt == wf_writeBufSize) {\n\t\t\t\tif (flush_write_file(f) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (!r1 && len)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (r1 <= 0) {\n\t\t\tif (ret > 0)\n\t\t\t\treturn ret;\n\t\t\treturn r1;\n\t\t}\n\t\tlen -= r1;\n\t\tbuf += r1;\n\t\tret += r1;\n\t}\n\treturn ret;\n}\n\n/* An in-place update found identical data at an identical location. We either\n * just seek past it, or (for an in-place sparse update), we give the data to\n * the sparse processor with the use_seek flag set. */\nint skip_matched(int fd, OFF_T offset, const char *buf, int len)\n{\n\tOFF_T pos;\n\n\tif (sparse_files > 0) {\n\t\tif (write_file(fd, 1, offset, buf, len) != len)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif (flush_write_file(fd) < 0)\n\t\treturn -1;\n\n\tif ((pos = do_lseek(fd, len, SEEK_CUR)) != offset + len) {\n\t\trsyserr(FERROR_XFER, errno, \"lseek returned %s, not %s\",\n\t\t\tbig_num(pos), big_num(offset));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* This provides functionality somewhat similar to mmap() but using read().\n * It gives sliding window access to a file.  mmap() is not used because of\n * the possibility of another program (such as a mailer) truncating the\n * file thus giving us a SIGBUS. */\nstruct map_struct *map_file(int fd, OFF_T len, int32 read_size, int32 blk_size)\n{\n\tstruct map_struct *map;\n\n\tmap = new0(struct map_struct);\n\n\tif (blk_size && (read_size % blk_size))\n\t\tread_size += blk_size - (read_size % blk_size);\n\n\tmap->fd = fd;\n\tmap->file_size = len;\n\tmap->def_window_size = ALIGNED_LENGTH(read_size);\n\n\treturn map;\n}\n\n\n/* slide the read window in the file */\nchar *map_ptr(struct map_struct *map, OFF_T offset, int32 len)\n{\n\tOFF_T window_start, read_start;\n\tint32 window_size, read_size, read_offset, align_fudge;\n\n\tif (len == 0)\n\t\treturn NULL;\n\tif (len < 0) {\n\t\trprintf(FERROR, \"invalid len passed to map_ptr: %ld\\n\",\n\t\t\t(long)len);\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n\n\t/* in most cases the region will already be available */\n\tif (offset >= map->p_offset && offset+len <= map->p_offset+map->p_len)\n\t\treturn map->p + (offset - map->p_offset);\n\n\t/* nope, we are going to have to do a read. Work out our desired window */\n\talign_fudge = (int32)ALIGNED_OVERSHOOT(offset);\n\twindow_start = offset - align_fudge;\n\twindow_size = map->def_window_size;\n\tif (window_start + window_size > map->file_size)\n\t\twindow_size = (int32)(map->file_size - window_start);\n\tif (window_size < len + align_fudge)\n\t\twindow_size = ALIGNED_LENGTH(len + align_fudge);\n\n\t/* make sure we have allocated enough memory for the window */\n\tif (window_size > map->p_size) {\n\t\tmap->p = realloc_array(map->p, char, window_size);\n\t\tmap->p_size = window_size;\n\t}\n\n\t/* Now try to avoid re-reading any bytes by reusing any bytes from the previous buffer. */\n\tif (window_start >= map->p_offset && window_start < map->p_offset + map->p_len\n\t && window_start + window_size >= map->p_offset + map->p_len) {\n\t\tread_start = map->p_offset + map->p_len;\n\t\tread_offset = (int32)(read_start - window_start);\n\t\tread_size = window_size - read_offset;\n\t\tmemmove(map->p, map->p + (map->p_len - read_offset), read_offset);\n\t} else {\n\t\tread_start = window_start;\n\t\tread_size = window_size;\n\t\tread_offset = 0;\n\t}\n\n\tif (read_size <= 0) {\n\t\trprintf(FERROR, \"invalid read_size of %ld in map_ptr\\n\",\n\t\t\t(long)read_size);\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n\n\tif (map->p_fd_offset != read_start) {\n\t\tOFF_T ret = do_lseek(map->fd, read_start, SEEK_SET);\n\t\tif (ret != read_start) {\n\t\t\trsyserr(FERROR, errno, \"lseek returned %s, not %s\",\n\t\t\t\tbig_num(ret), big_num(read_start));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t\tmap->p_fd_offset = read_start;\n\t}\n\tmap->p_offset = window_start;\n\tmap->p_len = window_size;\n\n\twhile (read_size > 0) {\n\t\tint32 nread = read(map->fd, map->p + read_offset, read_size);\n\t\tif (nread <= 0) {\n\t\t\tif (!map->status)\n\t\t\t\tmap->status = nread ? errno : ENODATA;\n\t\t\t/* The best we can do is zero the buffer -- the file\n\t\t\t * has changed mid transfer! */\n\t\t\tmemset(map->p + read_offset, 0, read_size);\n\t\t\tbreak;\n\t\t}\n\t\tmap->p_fd_offset += nread;\n\t\tread_offset += nread;\n\t\tread_size -= nread;\n\t}\n\n\treturn map->p + align_fudge;\n}\n\nint unmap_file(struct map_struct *map)\n{\n\tint\tret;\n\n\tif (map->p) {\n\t\tfree(map->p);\n\t\tmap->p = NULL;\n\t}\n\tret = map->status;\n#if 0 /* I don't think we really need this. */\n\tforce_memzero(map, sizeof map[0]);\n#endif\n\tfree(map);\n\n\treturn ret;\n}\n"
        },
        {
          "name": "flist.c",
          "type": "blob",
          "size": 91.4130859375,
          "content": "/*\n * Generate and receive file lists.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2002-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"rounding.h\"\n#include \"inums.h\"\n#include \"io.h\"\n\nextern int am_root;\nextern int am_server;\nextern int am_daemon;\nextern int am_sender;\nextern int am_generator;\nextern int inc_recurse;\nextern int always_checksum;\nextern int module_id;\nextern int ignore_errors;\nextern int numeric_ids;\nextern int quiet;\nextern int recurse;\nextern int use_qsort;\nextern int xfer_dirs;\nextern int filesfrom_fd;\nextern int one_file_system;\nextern int copy_devices;\nextern int copy_dirlinks;\nextern int preserve_uid;\nextern int preserve_gid;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int preserve_links;\nextern int preserve_hard_links;\nextern int preserve_devices;\nextern int preserve_specials;\nextern int delete_during;\nextern int missing_args;\nextern int eol_nulls;\nextern int atimes_ndx;\nextern int crtimes_ndx;\nextern int relative_paths;\nextern int implied_dirs;\nextern int ignore_perishable;\nextern int non_perishable_cnt;\nextern int prune_empty_dirs;\nextern int copy_links;\nextern int copy_unsafe_links;\nextern int protocol_version;\nextern int sanitize_paths;\nextern int munge_symlinks;\nextern int use_safe_inc_flist;\nextern int need_unsorted_flist;\nextern int sender_symlink_iconv;\nextern int output_needs_newline;\nextern int sender_keeps_checksum;\nextern int trust_sender_filter;\nextern int unsort_ndx;\nextern uid_t our_uid;\nextern struct stats stats;\nextern char *filesfrom_host;\nextern char *usermap, *groupmap;\n\nextern struct name_num_item *file_sum_nni;\n\nextern char curr_dir[MAXPATHLEN];\n\nextern struct chmod_mode_struct *chmod_modes;\n\nextern filter_rule_list filter_list, implied_filter_list, daemon_filter_list;\n\n#ifdef ICONV_OPTION\nextern int filesfrom_convert;\nextern iconv_t ic_send, ic_recv;\n#endif\n\n#define PTR_SIZE (sizeof (struct file_struct *))\n\nint io_error;\nint flist_csum_len;\ndev_t filesystem_dev; /* used to implement -x */\n\nstruct file_list *cur_flist, *first_flist, *dir_flist;\nint send_dir_ndx = -1, send_dir_depth = -1;\nint flist_cnt = 0; /* how many (non-tmp) file list objects exist */\nint file_total = 0; /* total of all active items over all file-lists */\nint file_old_total = 0; /* total of active items that will soon be gone */\nint flist_eof = 0; /* all the file-lists are now known */\nint xfer_flags_as_varint = 0;\n\n#define NORMAL_NAME 0\n#define SLASH_ENDING_NAME 1\n#define DOTDIR_NAME 2\n#define MISSING_NAME 3\n\n/* Starting from protocol version 26, we always use 64-bit ino_t and dev_t\n * internally, even if this platform does not allow files to have 64-bit inums.\n * The only exception is if we're on a platform with no 64-bit type at all.\n *\n * Because we use read_longint() to get these off the wire, if you transfer\n * devices or (for protocols < 30) hardlinks with dev or inum > 2**32 to a\n * machine with no 64-bit types then you will get an overflow error.\n *\n * Note that if you transfer devices from a 64-bit-devt machine (say, Solaris)\n * to a 32-bit-devt machine (say, Linux-2.2/x86) then the device numbers will\n * be truncated.  But it's a kind of silly thing to do anyhow. */\n\n/* The tmp_* vars are used as a cache area by make_file() to store data\n * that the sender doesn't need to remember in its file list.  The data\n * will survive just long enough to be used by send_file_entry(). */\nstatic dev_t tmp_rdev;\n#ifdef SUPPORT_HARD_LINKS\nstatic int64 tmp_dev = -1, tmp_ino;\n#endif\nstatic char tmp_sum[MAX_DIGEST_LEN];\n\nstatic char empty_sum[MAX_DIGEST_LEN];\nstatic int flist_count_offset; /* for --delete --progress */\nstatic int show_filelist_progress;\n\nstatic struct file_list *flist_new(int flags, const char *msg);\nstatic void flist_sort_and_clean(struct file_list *flist, int strip_root);\nstatic void output_flist(struct file_list *flist);\n\nvoid init_flist(void)\n{\n\tif (DEBUG_GTE(FLIST, 4)) {\n\t\trprintf(FINFO, \"FILE_STRUCT_LEN=%d, EXTRA_LEN=%d\\n\",\n\t\t\t(int)FILE_STRUCT_LEN, (int)EXTRA_LEN);\n\t}\n\t/* Note that this isn't identical to file_sum_len in the case of CSUM_MD4_ARCHAIC: */\n\tflist_csum_len = csum_len_for_type(file_sum_nni->num, 1);\n\n\tshow_filelist_progress = INFO_GTE(FLIST, 1) && xfer_dirs && !am_server && !inc_recurse;\n}\n\nstatic void start_filelist_progress(char *kind)\n{\n\tif (quiet)\n\t\treturn;\n\trprintf(FCLIENT, \"%s ... \", kind);\n\toutput_needs_newline = 1;\n\trflush(FINFO);\n}\n\nstatic void emit_filelist_progress(int count)\n{\n\tif (quiet)\n\t\treturn;\n\tif (output_needs_newline == 2) /* avoid a newline in the middle of this filelist-progress output */\n\t\toutput_needs_newline = 0;\n\trprintf(FCLIENT, \" %d files...\\r\", count);\n\toutput_needs_newline = 2;\n}\n\nstatic void maybe_emit_filelist_progress(int count)\n{\n\tif (INFO_GTE(FLIST, 2) && show_filelist_progress && (count % 100) == 0)\n\t\temit_filelist_progress(count);\n}\n\nstatic void finish_filelist_progress(const struct file_list *flist)\n{\n\toutput_needs_newline = 0;\n\tif (INFO_GTE(FLIST, 2)) {\n\t\t/* This overwrites the progress line */\n\t\trprintf(FINFO, \"%d file%sto consider\\n\",\n\t\t\tflist->used, flist->used == 1 ? \" \" : \"s \");\n\t} else {\n\t\trprintf(FINFO, \"done\\n\");\n\t}\n}\n\nvoid show_flist_stats(void)\n{\n\t/* Nothing yet */\n}\n\n/* Stat either a symlink or its referent, depending on the settings of\n * copy_links, copy_unsafe_links, etc.  Returns -1 on error, 0 on success.\n *\n * If path is the name of a symlink, then the linkbuf buffer (which must hold\n * MAXPATHLEN chars) will be set to the symlink's target string.\n *\n * The stat structure pointed to by stp will contain information about the\n * link or the referent as appropriate, if they exist. */\nstatic int readlink_stat(const char *path, STRUCT_STAT *stp, char *linkbuf)\n{\n#ifdef SUPPORT_LINKS\n\tif (link_stat(path, stp, copy_dirlinks) < 0)\n\t\treturn -1;\n\tif (S_ISLNK(stp->st_mode)) {\n\t\tint llen = do_readlink(path, linkbuf, MAXPATHLEN - 1);\n\t\tif (llen < 0)\n\t\t\treturn -1;\n\t\tlinkbuf[llen] = '\\0';\n\t\tif (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {\n\t\t\tif (INFO_GTE(SYMSAFE, 1)) {\n\t\t\t\trprintf(FINFO,\"copying unsafe symlink \\\"%s\\\" -> \\\"%s\\\"\\n\",\n\t\t\t\t\tpath, linkbuf);\n\t\t\t}\n\t\t\treturn x_stat(path, stp, NULL);\n\t\t}\n\t\tif (munge_symlinks && am_sender && llen > SYMLINK_PREFIX_LEN\n\t\t && strncmp(linkbuf, SYMLINK_PREFIX, SYMLINK_PREFIX_LEN) == 0) {\n\t\t\tmemmove(linkbuf, linkbuf + SYMLINK_PREFIX_LEN,\n\t\t\t\tllen - SYMLINK_PREFIX_LEN + 1);\n\t\t}\n\t}\n\treturn 0;\n#else\n\treturn x_stat(path, stp, NULL);\n#endif\n}\n\nint link_stat(const char *path, STRUCT_STAT *stp, int follow_dirlinks)\n{\n#ifdef SUPPORT_LINKS\n\tif (copy_links)\n\t\treturn x_stat(path, stp, NULL);\n\tif (x_lstat(path, stp, NULL) < 0)\n\t\treturn -1;\n\tif (follow_dirlinks && S_ISLNK(stp->st_mode)) {\n\t\tSTRUCT_STAT st;\n\t\tif (x_stat(path, &st, NULL) == 0 && S_ISDIR(st.st_mode))\n\t\t\t*stp = st;\n\t}\n\treturn 0;\n#else\n\treturn x_stat(path, stp, NULL);\n#endif\n}\n\nstatic inline int path_is_daemon_excluded(char *path, int ignore_filename)\n{\n\tif (daemon_filter_list.head) {\n\t\tchar *slash = path;\n\n\t\twhile ((slash = strchr(slash+1, '/')) != NULL) {\n\t\t\tint ret;\n\t\t\t*slash = '\\0';\n\t\t\tret = check_filter(&daemon_filter_list, FLOG, path, 1);\n\t\t\t*slash = '/';\n\t\t\tif (ret < 0) {\n\t\t\t\terrno = ENOENT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!ignore_filename\n\t\t && check_filter(&daemon_filter_list, FLOG, path, 1) < 0) {\n\t\t\terrno = ENOENT;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int is_excluded(const char *fname, int is_dir, int filter_level)\n{\n\treturn name_is_excluded(fname, is_dir ? NAME_IS_DIR : NAME_IS_FILE, filter_level);\n}\n\nstatic void send_directory(int f, struct file_list *flist,\n\t\t\t   char *fbuf, int len, int flags);\n\nstatic const char *pathname, *orig_dir;\nstatic int pathname_len;\n\n/* Make sure flist can hold at least flist->used + extra entries. */\nstatic void flist_expand(struct file_list *flist, int extra)\n{\n\tstruct file_struct **new_ptr;\n\n\tif (flist->used + extra <= flist->malloced)\n\t\treturn;\n\n\tif (flist->malloced < FLIST_START)\n\t\tflist->malloced = FLIST_START;\n\telse if (flist->malloced >= FLIST_LINEAR)\n\t\tflist->malloced += FLIST_LINEAR;\n\telse if (flist->malloced < FLIST_START_LARGE/16)\n\t\tflist->malloced *= 4;\n\telse\n\t\tflist->malloced *= 2;\n\n\t/* In case count jumped or we are starting the list\n\t * with a known size just set it. */\n\tif (flist->malloced < flist->used + extra)\n\t\tflist->malloced = flist->used + extra;\n\n\tnew_ptr = realloc_array(flist->files, struct file_struct *, flist->malloced);\n\n\tif (DEBUG_GTE(FLIST, 1) && flist->files) {\n\t\trprintf(FCLIENT, \"[%s] expand file_list pointer array to %s bytes, did%s move\\n\",\n\t\t    who_am_i(),\n\t\t    big_num(sizeof flist->files[0] * flist->malloced),\n\t\t    (new_ptr == flist->files) ? \" not\" : \"\");\n\t}\n\n\tflist->files = new_ptr;\n}\n\nstatic void flist_done_allocating(struct file_list *flist)\n{\n\tvoid *ptr = pool_boundary(flist->file_pool, 8*1024);\n\tif (flist->pool_boundary == ptr)\n\t\tflist->pool_boundary = NULL; /* list didn't use any pool memory */\n\telse\n\t\tflist->pool_boundary = ptr;\n}\n\n/* Call this with EITHER (1) \"file, NULL, 0\" to chdir() to the file's\n * F_PATHNAME(), or (2) \"NULL, dir, dirlen\" to chdir() to the supplied dir,\n * with dir == NULL taken to be the starting directory, and dirlen < 0\n * indicating that strdup(dir) should be called and then the -dirlen length\n * value checked to ensure that it is not daemon-excluded. */\nint change_pathname(struct file_struct *file, const char *dir, int dirlen)\n{\n\tif (dirlen < 0) {\n\t\tchar *cpy = strdup(dir);\n\t\tif (*cpy != '/')\n\t\t\tchange_dir(orig_dir, CD_SKIP_CHDIR);\n\t\tif (path_is_daemon_excluded(cpy, 0))\n\t\t\tgoto chdir_error;\n\t\tdir = cpy;\n\t\tdirlen = -dirlen;\n\t} else {\n\t\tif (file) {\n\t\t\tif (pathname == F_PATHNAME(file))\n\t\t\t\treturn 1;\n\t\t\tdir = F_PATHNAME(file);\n\t\t\tif (dir)\n\t\t\t\tdirlen = strlen(dir);\n\t\t} else if (pathname == dir)\n\t\t\treturn 1;\n\t\tif (dir && *dir != '/')\n\t\t\tchange_dir(orig_dir, CD_SKIP_CHDIR);\n\t}\n\n\tpathname = dir;\n\tpathname_len = dirlen;\n\n\tif (!dir)\n\t\tdir = orig_dir;\n\n\tif (!change_dir(dir, CD_NORMAL)) {\n\t  chdir_error:\n\t\tio_error |= IOERR_GENERAL;\n\t\trsyserr(FERROR_XFER, errno, \"change_dir %s failed\", full_fname(dir));\n\t\tif (dir != orig_dir)\n\t\t\tchange_dir(orig_dir, CD_NORMAL);\n\t\tpathname = NULL;\n\t\tpathname_len = 0;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void send_file_entry(int f, const char *fname, struct file_struct *file,\n#ifdef SUPPORT_LINKS\n\t\t\t    const char *symlink_name, int symlink_len,\n#endif\n\t\t\t    int ndx, int first_ndx)\n{\n\tstatic time_t modtime, atime;\n#ifdef SUPPORT_CRTIMES\n\tstatic time_t crtime;\n#endif\n\tstatic mode_t mode;\n#ifdef SUPPORT_HARD_LINKS\n\tstatic int64 dev;\n#endif\n\tstatic dev_t rdev;\n\tstatic uint32 rdev_major;\n\tstatic uid_t uid;\n\tstatic gid_t gid;\n\tstatic const char *user_name, *group_name;\n\tstatic char lastname[MAXPATHLEN];\n#ifdef SUPPORT_HARD_LINKS\n\tint first_hlink_ndx = -1;\n#endif\n\tint l1, l2;\n\tint xflags;\n\n\t/* Initialize starting value of xflags and adjust counts. */\n\tif (S_ISREG(file->mode))\n\t\txflags = 0;\n\telse if (S_ISDIR(file->mode)) {\n\t\tstats.num_dirs++;\n\t\tif (protocol_version >= 30) {\n\t\t\tif (file->flags & FLAG_CONTENT_DIR)\n\t\t\t\txflags = file->flags & FLAG_TOP_DIR;\n\t\t\telse if (file->flags & FLAG_IMPLIED_DIR)\n\t\t\t\txflags = XMIT_TOP_DIR | XMIT_NO_CONTENT_DIR;\n\t\t\telse\n\t\t\t\txflags = XMIT_NO_CONTENT_DIR;\n\t\t} else\n\t\t\txflags = file->flags & FLAG_TOP_DIR; /* FLAG_TOP_DIR == XMIT_TOP_DIR */\n\t} else {\n\t\tif (S_ISLNK(file->mode))\n\t\t\tstats.num_symlinks++;\n\t\telse if (IS_DEVICE(file->mode))\n\t\t\tstats.num_devices++;\n\t\telse if (IS_SPECIAL(file->mode))\n\t\t\tstats.num_specials++;\n\t\txflags = 0;\n\t}\n\n\tif (file->mode == mode)\n\t\txflags |= XMIT_SAME_MODE;\n\telse\n\t\tmode = file->mode;\n\n\tif (preserve_devices && IS_DEVICE(mode)) {\n\t\tif (protocol_version < 28) {\n\t\t\tif (tmp_rdev == rdev)\n\t\t\t\txflags |= XMIT_SAME_RDEV_pre28;\n\t\t\telse\n\t\t\t\trdev = tmp_rdev;\n\t\t} else {\n\t\t\trdev = tmp_rdev;\n\t\t\tif ((uint32)major(rdev) == rdev_major)\n\t\t\t\txflags |= XMIT_SAME_RDEV_MAJOR;\n\t\t\telse\n\t\t\t\trdev_major = major(rdev);\n\t\t\tif (protocol_version < 30 && (uint32)minor(rdev) <= 0xFFu)\n\t\t\t\txflags |= XMIT_RDEV_MINOR_8_pre30;\n\t\t}\n\t} else if (preserve_specials && IS_SPECIAL(mode) && protocol_version < 31) {\n\t\t/* Special files don't need an rdev number, so just make\n\t\t * the historical transmission of the value efficient. */\n\t\tif (protocol_version < 28)\n\t\t\txflags |= XMIT_SAME_RDEV_pre28;\n\t\telse {\n\t\t\trdev = MAKEDEV(rdev_major, 0);\n\t\t\txflags |= XMIT_SAME_RDEV_MAJOR;\n\t\t\tif (protocol_version < 30)\n\t\t\t\txflags |= XMIT_RDEV_MINOR_8_pre30;\n\t\t}\n\t} else if (protocol_version < 28)\n\t\trdev = MAKEDEV(0, 0);\n\tif (!preserve_uid || ((uid_t)F_OWNER(file) == uid && *lastname))\n\t\txflags |= XMIT_SAME_UID;\n\telse {\n\t\tuid = F_OWNER(file);\n\t\tif (!numeric_ids) {\n\t\t\tuser_name = add_uid(uid);\n\t\t\tif (inc_recurse && user_name)\n\t\t\t\txflags |= XMIT_USER_NAME_FOLLOWS;\n\t\t}\n\t}\n\tif (!preserve_gid || ((gid_t)F_GROUP(file) == gid && *lastname))\n\t\txflags |= XMIT_SAME_GID;\n\telse {\n\t\tgid = F_GROUP(file);\n\t\tif (!numeric_ids) {\n\t\t\tgroup_name = add_gid(gid);\n\t\t\tif (inc_recurse && group_name)\n\t\t\t\txflags |= XMIT_GROUP_NAME_FOLLOWS;\n\t\t}\n\t}\n\tif (file->modtime == modtime)\n\t\txflags |= XMIT_SAME_TIME;\n\telse\n\t\tmodtime = file->modtime;\n\tif (NSEC_BUMP(file) && protocol_version >= 31)\n\t\txflags |= XMIT_MOD_NSEC;\n\tif (atimes_ndx && !S_ISDIR(mode)) {\n\t\tif (F_ATIME(file) == atime)\n\t\t\txflags |= XMIT_SAME_ATIME;\n\t\telse\n\t\t\tatime = F_ATIME(file);\n\t}\n#ifdef SUPPORT_CRTIMES\n\tif (crtimes_ndx) {\n\t\tcrtime = F_CRTIME(file);\n\t\tif (crtime == modtime)\n\t\t\txflags |= XMIT_CRTIME_EQ_MTIME;\n\t}\n#endif\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (tmp_dev != -1) {\n\t\tif (protocol_version >= 30) {\n\t\t\tstruct ht_int64_node *np = idev_find(tmp_dev, tmp_ino);\n\t\t\tfirst_hlink_ndx = (int32)(long)np->data; /* is -1 when new */\n\t\t\tif (first_hlink_ndx < 0) {\n\t\t\t\tnp->data = (void*)(long)(first_ndx + ndx);\n\t\t\t\txflags |= XMIT_HLINK_FIRST;\n\t\t\t}\n\t\t\tif (DEBUG_GTE(HLINK, 1)) {\n\t\t\t\tif (first_hlink_ndx >= 0) {\n\t\t\t\t\trprintf(FINFO, \"[%s] #%d hard-links #%d (%sabbrev)\\n\",\n\t\t\t\t\t\twho_am_i(), first_ndx + ndx, first_hlink_ndx,\n\t\t\t\t\t\tfirst_hlink_ndx >= first_ndx ? \"\" : \"un\");\n\t\t\t\t} else if (DEBUG_GTE(HLINK, 3)) {\n\t\t\t\t\trprintf(FINFO, \"[%s] dev:inode for #%d is %s:%s\\n\",\n\t\t\t\t\t\twho_am_i(), first_ndx + ndx,\n\t\t\t\t\t\tbig_num(tmp_dev), big_num(tmp_ino));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (tmp_dev == dev) {\n\t\t\t\tif (protocol_version >= 28)\n\t\t\t\t\txflags |= XMIT_SAME_DEV_pre30;\n\t\t\t} else\n\t\t\t\tdev = tmp_dev;\n\t\t}\n\t\txflags |= XMIT_HLINKED;\n\t}\n#endif\n\n\tfor (l1 = 0;\n\t    lastname[l1] && (fname[l1] == lastname[l1]) && (l1 < 255);\n\t    l1++) {}\n\tl2 = strlen(fname+l1);\n\n\tif (l1 > 0)\n\t\txflags |= XMIT_SAME_NAME;\n\tif (l2 > 255)\n\t\txflags |= XMIT_LONG_NAME;\n\n\t/* We must avoid sending a flag value of 0 (or an initial byte of\n\t * 0 for the older xflags protocol) or it will signal the end of\n\t * the list.  Note that the use of XMIT_TOP_DIR on a non-dir has\n\t * no meaning, so it's a harmless way to add a bit to the first\n\t * flag byte. */\n\tif (xfer_flags_as_varint)\n\t\twrite_varint(f, xflags ? xflags : XMIT_EXTENDED_FLAGS);\n\telse if (protocol_version >= 28) {\n\t\tif (!xflags && !S_ISDIR(mode))\n\t\t\txflags |= XMIT_TOP_DIR;\n\t\tif ((xflags & 0xFF00) || !xflags) {\n\t\t\txflags |= XMIT_EXTENDED_FLAGS;\n\t\t\twrite_shortint(f, xflags);\n\t\t} else\n\t\t\twrite_byte(f, xflags);\n\t} else {\n\t\tif (!(xflags & 0xFF))\n\t\t\txflags |= S_ISDIR(mode) ? XMIT_LONG_NAME : XMIT_TOP_DIR;\n\t\twrite_byte(f, xflags);\n\t}\n\tif (xflags & XMIT_SAME_NAME)\n\t\twrite_byte(f, l1);\n\tif (xflags & XMIT_LONG_NAME)\n\t\twrite_varint30(f, l2);\n\telse\n\t\twrite_byte(f, l2);\n\twrite_buf(f, fname + l1, l2);\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (first_hlink_ndx >= 0) {\n\t\twrite_varint(f, first_hlink_ndx);\n\t\tif (first_hlink_ndx >= first_ndx)\n\t\t\tgoto the_end;\n\t}\n#endif\n\n\twrite_varlong30(f, F_LENGTH(file), 3);\n\tif (!(xflags & XMIT_SAME_TIME)) {\n\t\tif (protocol_version >= 30)\n\t\t\twrite_varlong(f, modtime, 4);\n\t\telse\n\t\t\twrite_int(f, modtime);\n\t}\n\tif (xflags & XMIT_MOD_NSEC)\n\t\twrite_varint(f, F_MOD_NSEC(file));\n#ifdef SUPPORT_CRTIMES\n\tif (crtimes_ndx && !(xflags & XMIT_CRTIME_EQ_MTIME))\n\t\twrite_varlong(f, crtime, 4);\n#endif\n\tif (!(xflags & XMIT_SAME_MODE))\n\t\twrite_int(f, to_wire_mode(mode));\n\tif (atimes_ndx && !S_ISDIR(mode) && !(xflags & XMIT_SAME_ATIME))\n\t\twrite_varlong(f, atime, 4);\n\tif (preserve_uid && !(xflags & XMIT_SAME_UID)) {\n\t\tif (protocol_version < 30)\n\t\t\twrite_int(f, uid);\n\t\telse {\n\t\t\twrite_varint(f, uid);\n\t\t\tif (xflags & XMIT_USER_NAME_FOLLOWS) {\n\t\t\t\tint len = strlen(user_name);\n\t\t\t\twrite_byte(f, len);\n\t\t\t\twrite_buf(f, user_name, len);\n\t\t\t}\n\t\t}\n\t}\n\tif (preserve_gid && !(xflags & XMIT_SAME_GID)) {\n\t\tif (protocol_version < 30)\n\t\t\twrite_int(f, gid);\n\t\telse {\n\t\t\twrite_varint(f, gid);\n\t\t\tif (xflags & XMIT_GROUP_NAME_FOLLOWS) {\n\t\t\t\tint len = strlen(group_name);\n\t\t\t\twrite_byte(f, len);\n\t\t\t\twrite_buf(f, group_name, len);\n\t\t\t}\n\t\t}\n\t}\n\tif ((preserve_devices && IS_DEVICE(mode))\n\t || (preserve_specials && IS_SPECIAL(mode) && protocol_version < 31)) {\n\t\tif (protocol_version < 28) {\n\t\t\tif (!(xflags & XMIT_SAME_RDEV_pre28))\n\t\t\t\twrite_int(f, (int)rdev);\n\t\t} else {\n\t\t\tif (!(xflags & XMIT_SAME_RDEV_MAJOR))\n\t\t\t\twrite_varint30(f, major(rdev));\n\t\t\tif (protocol_version >= 30)\n\t\t\t\twrite_varint(f, minor(rdev));\n\t\t\telse if (xflags & XMIT_RDEV_MINOR_8_pre30)\n\t\t\t\twrite_byte(f, minor(rdev));\n\t\t\telse\n\t\t\t\twrite_int(f, minor(rdev));\n\t\t}\n\t}\n\n#ifdef SUPPORT_LINKS\n\tif (symlink_len) {\n\t\twrite_varint30(f, symlink_len);\n\t\twrite_buf(f, symlink_name, symlink_len);\n\t}\n#endif\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (tmp_dev != -1 && protocol_version < 30) {\n\t\t/* Older protocols expect the dev number to be transmitted\n\t\t * 1-incremented so that it is never zero. */\n\t\tif (protocol_version < 26) {\n\t\t\t/* 32-bit dev_t and ino_t */\n\t\t\twrite_int(f, (int32)(dev+1));\n\t\t\twrite_int(f, (int32)tmp_ino);\n\t\t} else {\n\t\t\t/* 64-bit dev_t and ino_t */\n\t\t\tif (!(xflags & XMIT_SAME_DEV_pre30))\n\t\t\t\twrite_longint(f, dev+1);\n\t\t\twrite_longint(f, tmp_ino);\n\t\t}\n\t}\n#endif\n\n\tif (always_checksum && (S_ISREG(mode) || protocol_version < 28)) {\n\t\tconst char *sum;\n\t\tif (S_ISREG(mode))\n\t\t\tsum = tmp_sum;\n\t\telse {\n\t\t\t/* Prior to 28, we sent a useless set of nulls. */\n\t\t\tsum = empty_sum;\n\t\t}\n\t\twrite_buf(f, sum, flist_csum_len);\n\t}\n\n#ifdef SUPPORT_HARD_LINKS\n  the_end:\n#endif\n\tstrlcpy(lastname, fname, MAXPATHLEN);\n\n\tif (S_ISREG(mode) || S_ISLNK(mode))\n\t\tstats.total_size += F_LENGTH(file);\n}\n\nstatic struct file_struct *recv_file_entry(int f, struct file_list *flist, int xflags)\n{\n\tstatic int64 modtime, atime;\n#ifdef SUPPORT_CRTIMES\n\tstatic time_t crtime;\n#endif\n\tstatic mode_t mode;\n#ifdef SUPPORT_HARD_LINKS\n\tstatic int64 dev;\n#endif\n\tstatic dev_t rdev;\n\tstatic uint32 rdev_major;\n\tstatic uid_t uid;\n\tstatic gid_t gid;\n\tstatic uint16 gid_flags;\n\tstatic char lastname[MAXPATHLEN], *lastdir;\n\tstatic int lastdir_depth, lastdir_len = -1;\n\tstatic unsigned int del_hier_name_len = 0;\n\tstatic int in_del_hier = 0;\n\tchar thisname[MAXPATHLEN];\n\tunsigned int l1 = 0, l2 = 0;\n\tint alloc_len, basename_len, linkname_len;\n\tint extra_len = file_extra_cnt * EXTRA_LEN;\n\tint first_hlink_ndx = -1;\n\tchar real_ISREG_entry;\n\tint64 file_length;\n#ifdef CAN_SET_NSEC\n\tuint32 modtime_nsec;\n#endif\n\tconst char *basename;\n\tstruct file_struct *file;\n\talloc_pool_t *pool;\n\tchar *bp;\n\n\tif (xflags & XMIT_SAME_NAME)\n\t\tl1 = read_byte(f);\n\n\tif (xflags & XMIT_LONG_NAME)\n\t\tl2 = read_varint30(f);\n\telse\n\t\tl2 = read_byte(f);\n\n\tif (l2 >= MAXPATHLEN - l1) {\n\t\trprintf(FERROR,\n\t\t\t\"overflow: xflags=0x%x l1=%d l2=%d lastname=%s [%s]\\n\",\n\t\t\txflags, l1, l2, lastname, who_am_i());\n\t\toverflow_exit(\"recv_file_entry\");\n\t}\n\n\tstrlcpy(thisname, lastname, l1 + 1);\n\tread_sbuf(f, &thisname[l1], l2);\n\tthisname[l1 + l2] = 0;\n\n\t/* Abuse basename_len for a moment... */\n\tbasename_len = strlcpy(lastname, thisname, MAXPATHLEN);\n\n#ifdef ICONV_OPTION\n\tif (ic_recv != (iconv_t)-1) {\n\t\txbuf outbuf, inbuf;\n\n\t\tINIT_CONST_XBUF(outbuf, thisname);\n\t\tINIT_XBUF(inbuf, lastname, basename_len, (size_t)-1);\n\n\t\tif (iconvbufs(ic_recv, &inbuf, &outbuf, ICB_INIT) < 0) {\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trprintf(FERROR_UTF8,\n\t\t\t    \"[%s] cannot convert filename: %s (%s)\\n\",\n\t\t\t    who_am_i(), lastname, strerror(errno));\n\t\t\toutbuf.len = 0;\n\t\t}\n\t\tthisname[outbuf.len] = '\\0';\n\t}\n#endif\n\n\tif (*thisname\n\t && (clean_fname(thisname, CFN_REFUSE_DOT_DOT_DIRS) < 0 || (!relative_paths && *thisname == '/'))) {\n\t\trprintf(FERROR, \"ABORTING due to unsafe pathname from sender: %s\\n\", thisname);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tif (sanitize_paths)\n\t\tsanitize_path(thisname, thisname, \"\", 0, SP_DEFAULT);\n\n\tif ((basename = strrchr(thisname, '/')) != NULL) {\n\t\tint len = basename++ - thisname;\n\t\tif (len != lastdir_len || memcmp(thisname, lastdir, len) != 0) {\n\t\t\tlastdir = new_array(char, len + 1);\n\t\t\tmemcpy(lastdir, thisname, len);\n\t\t\tlastdir[len] = '\\0';\n\t\t\tlastdir_len = len;\n\t\t\tlastdir_depth = count_dir_elements(lastdir);\n\t\t}\n\t} else\n\t\tbasename = thisname;\n\tbasename_len = strlen(basename) + 1; /* count the '\\0' */\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (protocol_version >= 30\n\t && BITS_SETnUNSET(xflags, XMIT_HLINKED, XMIT_HLINK_FIRST)) {\n\t\tfirst_hlink_ndx = read_varint(f);\n\t\tif (first_hlink_ndx < 0 || first_hlink_ndx >= flist->ndx_start + flist->used) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"hard-link reference out of range: %d (%d)\\n\",\n\t\t\t\tfirst_hlink_ndx, flist->ndx_start + flist->used);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (DEBUG_GTE(HLINK, 1)) {\n\t\t\trprintf(FINFO, \"[%s] #%d hard-links #%d (%sabbrev)\\n\",\n\t\t\t\twho_am_i(), flist->used+flist->ndx_start, first_hlink_ndx,\n\t\t\t\tfirst_hlink_ndx >= flist->ndx_start ? \"\" : \"un\");\n\t\t}\n\t\tif (first_hlink_ndx >= flist->ndx_start) {\n\t\t\tstruct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];\n\t\t\tfile_length = F_LENGTH(first);\n\t\t\tmodtime = first->modtime;\n#ifdef CAN_SET_NSEC\n\t\t\tmodtime_nsec = F_MOD_NSEC_or_0(first);\n#endif\n\t\t\tmode = first->mode;\n\t\t\tif (atimes_ndx && !S_ISDIR(mode))\n\t\t\t\tatime = F_ATIME(first);\n#ifdef SUPPORT_CRTIMES\n\t\t\tif (crtimes_ndx)\n\t\t\t\tcrtime = F_CRTIME(first);\n#endif\n\t\t\tif (preserve_uid)\n\t\t\t\tuid = F_OWNER(first);\n\t\t\tif (preserve_gid)\n\t\t\t\tgid = F_GROUP(first);\n\t\t\tif (preserve_devices && IS_DEVICE(mode)) {\n\t\t\t\tuint32 *devp = F_RDEV_P(first);\n\t\t\t\trdev_major = DEV_MAJOR(devp);\n\t\t\t\trdev = MAKEDEV(rdev_major, DEV_MINOR(devp));\n\t\t\t\textra_len += DEV_EXTRA_CNT * EXTRA_LEN;\n\t\t\t}\n\t\t\tif (preserve_links && S_ISLNK(mode))\n\t\t\t\tlinkname_len = strlen(F_SYMLINK(first)) + 1;\n\t\t\telse\n\t\t\t\tlinkname_len = 0;\n\t\t\treal_ISREG_entry = S_ISREG(mode) ? 1 : 0;\n\t\t\tgoto create_object;\n\t\t}\n\t}\n#endif\n\n\tfile_length = read_varlong30(f, 3);\n\tif (!(xflags & XMIT_SAME_TIME)) {\n\t\tif (protocol_version >= 30) {\n\t\t\tmodtime = read_varlong(f, 4);\n#if SIZEOF_TIME_T < SIZEOF_INT64\n\t\t\tif (!am_generator && (int64)(time_t)modtime != modtime) {\n\t\t\t\trprintf(FERROR_XFER,\n\t\t\t\t    \"Time value of %s truncated on receiver.\\n\",\n\t\t\t\t    lastname);\n\t\t\t}\n#endif\n\t\t} else\n\t\t\tmodtime = read_uint(f);\n\t}\n\tif (xflags & XMIT_MOD_NSEC)\n#ifndef CAN_SET_NSEC\n\t\t(void)read_varint(f);\n#else\n\t\tmodtime_nsec = read_varint(f);\n\telse\n\t\tmodtime_nsec = 0;\n#endif\n#ifdef SUPPORT_CRTIMES\n\tif (crtimes_ndx) {\n\t\tif (xflags & XMIT_CRTIME_EQ_MTIME)\n\t\t\tcrtime = modtime;\n\t\telse\n\t\t\tcrtime = read_varlong(f, 4);\n#if SIZEOF_TIME_T < SIZEOF_INT64\n\t\tif (!am_generator && (int64)(time_t)crtime != crtime) {\n\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\"Create time value of %s truncated on receiver.\\n\",\n\t\t\t\tlastname);\n\t\t}\n#endif\n\t}\n#endif\n\tif (!(xflags & XMIT_SAME_MODE))\n\t\tmode = from_wire_mode(read_int(f));\n\tif (atimes_ndx && !S_ISDIR(mode) && !(xflags & XMIT_SAME_ATIME)) {\n\t\tatime = read_varlong(f, 4);\n#if SIZEOF_TIME_T < SIZEOF_INT64\n\t\tif (!am_generator && (int64)(time_t)atime != atime) {\n\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\"Access time value of %s truncated on receiver.\\n\",\n\t\t\t\tlastname);\n\t\t}\n#endif\n\t}\n\n\tif (chmod_modes && !S_ISLNK(mode) && mode)\n\t\tmode = tweak_mode(mode, chmod_modes);\n\n\tif (preserve_uid && !(xflags & XMIT_SAME_UID)) {\n\t\tif (protocol_version < 30)\n\t\t\tuid = (uid_t)read_int(f);\n\t\telse {\n\t\t\tuid = (uid_t)read_varint(f);\n\t\t\tif (xflags & XMIT_USER_NAME_FOLLOWS)\n\t\t\t\tuid = recv_user_name(f, uid);\n\t\t\telse if (inc_recurse && am_root && (!numeric_ids || usermap))\n\t\t\t\tuid = match_uid(uid);\n\t\t}\n\t}\n\tif (preserve_gid && !(xflags & XMIT_SAME_GID)) {\n\t\tif (protocol_version < 30)\n\t\t\tgid = (gid_t)read_int(f);\n\t\telse {\n\t\t\tgid = (gid_t)read_varint(f);\n\t\t\tgid_flags = 0;\n\t\t\tif (xflags & XMIT_GROUP_NAME_FOLLOWS)\n\t\t\t\tgid = recv_group_name(f, gid, &gid_flags);\n\t\t\telse if (inc_recurse && (!am_root || !numeric_ids || groupmap))\n\t\t\t\tgid = match_gid(gid, &gid_flags);\n\t\t}\n\t}\n\n\tif ((preserve_devices && IS_DEVICE(mode))\n\t || (preserve_specials && IS_SPECIAL(mode) && protocol_version < 31)) {\n\t\tif (protocol_version < 28) {\n\t\t\tif (!(xflags & XMIT_SAME_RDEV_pre28))\n\t\t\t\trdev = (dev_t)read_int(f);\n\t\t} else {\n\t\t\tuint32 rdev_minor;\n\t\t\tif (!(xflags & XMIT_SAME_RDEV_MAJOR))\n\t\t\t\trdev_major = read_varint30(f);\n\t\t\tif (protocol_version >= 30)\n\t\t\t\trdev_minor = read_varint(f);\n\t\t\telse if (xflags & XMIT_RDEV_MINOR_8_pre30)\n\t\t\t\trdev_minor = read_byte(f);\n\t\t\telse\n\t\t\t\trdev_minor = read_int(f);\n\t\t\trdev = MAKEDEV(rdev_major, rdev_minor);\n\t\t}\n\t\tif (IS_DEVICE(mode))\n\t\t\textra_len += DEV_EXTRA_CNT * EXTRA_LEN;\n\t\tfile_length = 0;\n\t} else if (protocol_version < 28)\n\t\trdev = MAKEDEV(0, 0);\n\n#ifdef SUPPORT_LINKS\n\tif (preserve_links && S_ISLNK(mode)) {\n\t\tlinkname_len = read_varint30(f) + 1; /* count the '\\0' */\n\t\tif (linkname_len <= 0 || linkname_len > MAXPATHLEN) {\n\t\t\trprintf(FERROR, \"overflow: linkname_len=%d\\n\",\n\t\t\t\tlinkname_len - 1);\n\t\t\toverflow_exit(\"recv_file_entry\");\n\t\t}\n#ifdef ICONV_OPTION\n\t\t/* We don't know how much extra room we need to convert\n\t\t * the as-yet-unread symlink data, so let's hope that a\n\t\t * double-size buffer is plenty. */\n\t\tif (sender_symlink_iconv)\n\t\t\tlinkname_len *= 2;\n#endif\n\t\tif (munge_symlinks)\n\t\t\tlinkname_len += SYMLINK_PREFIX_LEN;\n\t}\n\telse\n#endif\n\t\tlinkname_len = 0;\n\n\tif (copy_devices && IS_DEVICE(mode)) {\n\t\t/* This is impossible in the official release, but some pre-release patches\n\t\t * didn't convert the device into a file before sending, so we'll do it here\n\t\t * (even though the length is typically 0 and any checksum data is zeros). */\n\t\tmode = S_IFREG | (mode & ACCESSPERMS);\n\t\tmodtime = time(NULL); /* The mtime on the device is not up-to-date, so set it to \"now\". */\n\t\treal_ISREG_entry = 0;\n\t} else\n\t\treal_ISREG_entry = S_ISREG(mode) ? 1 : 0;\n\n#ifdef SUPPORT_HARD_LINKS\n  create_object:\n\tif (preserve_hard_links) {\n\t\tif (protocol_version < 28 && real_ISREG_entry)\n\t\t\txflags |= XMIT_HLINKED;\n\t\tif (xflags & XMIT_HLINKED)\n\t\t\textra_len += (inc_recurse+1) * EXTRA_LEN;\n\t}\n#endif\n\n#ifdef SUPPORT_ACLS\n\t/* Directories need an extra int32 for the default ACL. */\n\tif (preserve_acls && S_ISDIR(mode))\n\t\textra_len += EXTRA_LEN;\n#endif\n\n\tif (always_checksum && S_ISREG(mode))\n\t\textra_len += SUM_EXTRA_CNT * EXTRA_LEN;\n\n#if SIZEOF_INT64 >= 8\n\tif (file_length > 0xFFFFFFFFu && S_ISREG(mode))\n\t\textra_len += EXTRA_LEN;\n#endif\n#ifdef CAN_SET_NSEC\n\tif (modtime_nsec)\n\t\textra_len += EXTRA_LEN;\n#endif\n\tif (file_length < 0) {\n\t\trprintf(FERROR, \"Offset underflow: file-length is negative\\n\");\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tif (*thisname == '/' ? thisname[1] != '.' || thisname[2] != '\\0' : *thisname != '.' || thisname[1] != '\\0') {\n\t\tint filt_flags = S_ISDIR(mode) ? NAME_IS_DIR : NAME_IS_FILE;\n\t\tif (!trust_sender_filter /* a per-dir filter rule means we must trust the sender's filtering */\n\t\t && filter_list.head && check_server_filter(&filter_list, FINFO, thisname, filt_flags) < 0) {\n\t\t\trprintf(FERROR, \"ERROR: rejecting excluded file-list name: %s\\n\", thisname);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t\tif (implied_filter_list.head && check_filter(&implied_filter_list, FINFO, thisname, filt_flags) <= 0) {\n\t\t\trprintf(FERROR, \"ERROR: rejecting unrequested file-list name: %s\\n\", thisname);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t}\n\n\tif (inc_recurse && S_ISDIR(mode)) {\n\t\tif (one_file_system) {\n\t\t\t/* Room to save the dir's device for -x */\n\t\t\textra_len += DEV_EXTRA_CNT * EXTRA_LEN;\n\t\t}\n\t\tpool = dir_flist->file_pool;\n\t} else\n\t\tpool = flist->file_pool;\n\n#if EXTRA_ROUNDING > 0\n\tif (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))\n\t\textra_len = (extra_len | (EXTRA_ROUNDING * EXTRA_LEN)) + EXTRA_LEN;\n#endif\n\n\talloc_len = FILE_STRUCT_LEN + extra_len + basename_len\n\t\t  + linkname_len;\n\tbp = pool_alloc(pool, alloc_len, \"recv_file_entry\");\n\n\tmemset(bp, 0, extra_len + FILE_STRUCT_LEN);\n\tbp += extra_len;\n\tfile = (struct file_struct *)bp;\n\tbp += FILE_STRUCT_LEN;\n\n\tmemcpy(bp, basename, basename_len);\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (xflags & XMIT_HLINKED\n#ifndef CAN_HARDLINK_SYMLINK\n\t && !S_ISLNK(mode)\n#endif\n#ifndef CAN_HARDLINK_SPECIAL\n\t && !IS_SPECIAL(mode) && !IS_DEVICE(mode)\n#endif\n\t)\n\t\tfile->flags |= FLAG_HLINKED;\n#endif\n\tfile->modtime = (time_t)modtime;\n#ifdef CAN_SET_NSEC\n\tif (modtime_nsec) {\n\t\tfile->flags |= FLAG_MOD_NSEC;\n\t\tF_MOD_NSEC(file) = modtime_nsec;\n\t}\n#endif\n\tfile->len32 = (uint32)file_length;\n#if SIZEOF_INT64 >= 8\n\tif (file_length > 0xFFFFFFFFu && S_ISREG(mode)) {\n#if SIZEOF_CAPITAL_OFF_T < 8\n\t\trprintf(FERROR, \"Offset overflow: attempted 64-bit file-length\\n\");\n\t\texit_cleanup(RERR_UNSUPPORTED);\n#else\n\t\tfile->flags |= FLAG_LENGTH64;\n\t\tF_HIGH_LEN(file) = (uint32)(file_length >> 32);\n#endif\n\t}\n#endif\n\tfile->mode = mode;\n\tif (preserve_uid)\n\t\tF_OWNER(file) = uid;\n\tif (preserve_gid) {\n\t\tF_GROUP(file) = gid;\n\t\tfile->flags |= gid_flags;\n\t}\n\tif (atimes_ndx && !S_ISDIR(mode))\n\t\tF_ATIME(file) = atime;\n#ifdef SUPPORT_CRTIMES\n\tif (crtimes_ndx)\n\t\tF_CRTIME(file) = crtime;\n#endif\n\tif (unsort_ndx)\n\t\tF_NDX(file) = flist->used + flist->ndx_start;\n\n\tif (basename != thisname) {\n\t\tfile->dirname = lastdir;\n\t\tF_DEPTH(file) = lastdir_depth + 1;\n\t} else\n\t\tF_DEPTH(file) = 1;\n\n\tif (S_ISDIR(mode)) {\n\t\tif (basename_len == 1+1 && *basename == '.') /* +1 for '\\0' */\n\t\t\tF_DEPTH(file)--;\n\t\tif (protocol_version >= 30) {\n\t\t\tif (!(xflags & XMIT_NO_CONTENT_DIR)) {\n\t\t\t\tif (xflags & XMIT_TOP_DIR)\n\t\t\t\t\tfile->flags |= FLAG_TOP_DIR;\n\t\t\t\tfile->flags |= FLAG_CONTENT_DIR;\n\t\t\t} else if (xflags & XMIT_TOP_DIR)\n\t\t\t\tfile->flags |= FLAG_IMPLIED_DIR;\n\t\t} else if (xflags & XMIT_TOP_DIR) {\n\t\t\tin_del_hier = recurse;\n\t\t\tdel_hier_name_len = F_DEPTH(file) == 0 ? 0 : l1 + l2;\n\t\t\tif (relative_paths && del_hier_name_len > 2\n\t\t\t    && lastname[del_hier_name_len-1] == '.'\n\t\t\t    && lastname[del_hier_name_len-2] == '/')\n\t\t\t\tdel_hier_name_len -= 2;\n\t\t\tfile->flags |= FLAG_TOP_DIR | FLAG_CONTENT_DIR;\n\t\t} else if (in_del_hier) {\n\t\t\tif (!relative_paths || !del_hier_name_len\n\t\t\t || (l1 >= del_hier_name_len\n\t\t\t  && lastname[del_hier_name_len] == '/'))\n\t\t\t\tfile->flags |= FLAG_CONTENT_DIR;\n\t\t\telse\n\t\t\t\tin_del_hier = 0;\n\t\t}\n\t}\n\n\tif (preserve_devices && IS_DEVICE(mode)) {\n\t\tuint32 *devp = F_RDEV_P(file);\n\t\tDEV_MAJOR(devp) = major(rdev);\n\t\tDEV_MINOR(devp) = minor(rdev);\n\t}\n\n#ifdef SUPPORT_LINKS\n\tif (linkname_len) {\n\t\tbp += basename_len;\n\t\tif (first_hlink_ndx >= flist->ndx_start) {\n\t\t\tstruct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];\n\t\t\tmemcpy(bp, F_SYMLINK(first), linkname_len);\n\t\t} else {\n\t\t\tif (munge_symlinks) {\n\t\t\t\tstrlcpy(bp, SYMLINK_PREFIX, linkname_len);\n\t\t\t\tbp += SYMLINK_PREFIX_LEN;\n\t\t\t\tlinkname_len -= SYMLINK_PREFIX_LEN;\n\t\t\t}\n#ifdef ICONV_OPTION\n\t\t\tif (sender_symlink_iconv) {\n\t\t\t\txbuf outbuf, inbuf;\n\n\t\t\t\talloc_len = linkname_len;\n\t\t\t\tlinkname_len /= 2;\n\n\t\t\t\t/* Read the symlink data into the end of our double-sized\n\t\t\t\t * buffer and then convert it into the right spot. */\n\t\t\t\tINIT_XBUF(inbuf, bp + alloc_len - linkname_len,\n\t\t\t\t\t  linkname_len - 1, (size_t)-1);\n\t\t\t\tread_sbuf(f, inbuf.buf, inbuf.len);\n\t\t\t\tINIT_XBUF(outbuf, bp, 0, alloc_len);\n\n\t\t\t\tif (iconvbufs(ic_recv, &inbuf, &outbuf, ICB_INIT) < 0) {\n\t\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\t    \"[%s] cannot convert symlink data for: %s (%s)\\n\",\n\t\t\t\t\t    who_am_i(), full_fname(thisname), strerror(errno));\n\t\t\t\t\tbp = (char*)file->basename;\n\t\t\t\t\t*bp++ = '\\0';\n\t\t\t\t\toutbuf.len = 0;\n\t\t\t\t}\n\t\t\t\tbp[outbuf.len] = '\\0';\n\t\t\t} else\n#endif\n\t\t\t\tread_sbuf(f, bp, linkname_len - 1);\n\t\t\tif (sanitize_paths && !munge_symlinks && *bp)\n\t\t\t\tsanitize_path(bp, bp, \"\", lastdir_depth, SP_DEFAULT);\n\t\t}\n\t}\n#endif\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && xflags & XMIT_HLINKED) {\n\t\tif (protocol_version >= 30) {\n\t\t\tif (xflags & XMIT_HLINK_FIRST) {\n\t\t\t\tF_HL_GNUM(file) = flist->ndx_start + flist->used;\n\t\t\t} else\n\t\t\t\tF_HL_GNUM(file) = first_hlink_ndx;\n\t\t} else {\n\t\t\tstatic int32 cnt = 0;\n\t\t\tstruct ht_int64_node *np;\n\t\t\tint64 ino;\n\t\t\tint32 ndx;\n\t\t\tif (protocol_version < 26) {\n\t\t\t\tdev = read_int(f);\n\t\t\t\tino = read_int(f);\n\t\t\t} else {\n\t\t\t\tif (!(xflags & XMIT_SAME_DEV_pre30))\n\t\t\t\t\tdev = read_longint(f);\n\t\t\t\tino = read_longint(f);\n\t\t\t}\n\t\t\tnp = idev_find(dev, ino);\n\t\t\tndx = (int32)(long)np->data; /* is -1 when new */\n\t\t\tif (ndx < 0) {\n\t\t\t\tnp->data = (void*)(long)cnt;\n\t\t\t\tndx = cnt++;\n\t\t\t}\n\t\t\tF_HL_GNUM(file) = ndx;\n\t\t}\n\t}\n#endif\n\n\tif (always_checksum && (real_ISREG_entry || protocol_version < 28)) {\n\t\tif (real_ISREG_entry)\n\t\t\tbp = F_SUM(file);\n\t\telse {\n\t\t\t/* Prior to 28, we get a useless set of nulls. */\n\t\t\tbp = tmp_sum;\n\t\t}\n\t\tif (first_hlink_ndx >= flist->ndx_start) {\n\t\t\tstruct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];\n\t\t\tmemcpy(bp, F_SUM(first), flist_csum_len);\n\t\t} else\n\t\t\tread_buf(f, bp, flist_csum_len);\n\t}\n\n#ifdef SUPPORT_ACLS\n\tif (preserve_acls && !S_ISLNK(mode))\n\t\treceive_acl(f, file);\n#endif\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs)\n\t\treceive_xattr(f, file);\n#endif\n\n\tif (S_ISREG(mode) || S_ISLNK(mode))\n\t\tstats.total_size += file_length;\n\n\treturn file;\n}\n\n/* Create a file_struct for a named file by reading its stat() information\n * and performing extensive checks against global options.\n *\n * Returns a pointer to the new file struct, or NULL if there was an error\n * or this file should be excluded.\n *\n * Note: Any error (here or in send_file_name) that results in the omission of\n * an existent source file from the file list should set\n * \"io_error |= IOERR_GENERAL\" to avoid deletion of the file from the\n * destination if --delete is on. */\nstruct file_struct *make_file(const char *fname, struct file_list *flist,\n\t\t\t      STRUCT_STAT *stp, int flags, int filter_level)\n{\n\tstatic char *lastdir;\n\tstatic int lastdir_len = -1;\n\tstruct file_struct *file;\n\tchar thisname[MAXPATHLEN];\n\tchar linkname[MAXPATHLEN];\n\tint alloc_len, basename_len, linkname_len;\n\tint extra_len = file_extra_cnt * EXTRA_LEN;\n\tconst char *basename;\n\talloc_pool_t *pool;\n\tSTRUCT_STAT st;\n\tchar *bp;\n\n\tif (strlcpy(thisname, fname, sizeof thisname) >= sizeof thisname) {\n\t\tio_error |= IOERR_GENERAL;\n\t\trprintf(FERROR_XFER, \"skipping overly long name: %s\\n\", fname);\n\t\treturn NULL;\n\t}\n\tclean_fname(thisname, 0);\n\tif (sanitize_paths)\n\t\tsanitize_path(thisname, thisname, \"\", 0, SP_DEFAULT);\n\n\tif (stp && (S_ISDIR(stp->st_mode) || IS_MISSING_FILE(*stp))) {\n\t\t/* This is needed to handle a \"symlink/.\" with a --relative\n\t\t * dir, or a request to delete a specific file. */\n\t\tst = *stp;\n\t\t*linkname = '\\0'; /* make IBM code checker happy */\n\t} else if (readlink_stat(thisname, &st, linkname) != 0) {\n\t\tint save_errno = errno;\n\t\t/* See if file is excluded before reporting an error. */\n\t\tif (filter_level != NO_FILTERS\n\t\t && (is_excluded(thisname, 0, filter_level)\n\t\t  || is_excluded(thisname, 1, filter_level))) {\n\t\t\tif (ignore_perishable && save_errno != ENOENT)\n\t\t\t\tnon_perishable_cnt++;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (save_errno == ENOENT) {\n#ifdef SUPPORT_LINKS\n\t\t\t/* When our options tell us to follow a symlink that\n\t\t\t * points nowhere, tell the user about the symlink\n\t\t\t * instead of giving a \"vanished\" message.  We only\n\t\t\t * dereference a symlink if one of the --copy*links\n\t\t\t * options was specified, so there's no need for the\n\t\t\t * extra lstat() if one of these options isn't on. */\n\t\t\tif ((copy_links || copy_unsafe_links || copy_dirlinks)\n\t\t\t && x_lstat(thisname, &st, NULL) == 0\n\t\t\t && S_ISLNK(st.st_mode)) {\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\trprintf(FERROR_XFER, \"symlink has no referent: %s\\n\",\n\t\t\t\t\tfull_fname(thisname));\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tenum logcode c = am_daemon && protocol_version < 28\n\t\t\t\t\t       ? FERROR : FWARNING;\n\t\t\t\tio_error |= IOERR_VANISHED;\n\t\t\t\trprintf(c, \"file has vanished: %s\\n\",\n\t\t\t\t\tfull_fname(thisname));\n\t\t\t}\n\t\t} else {\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trsyserr(FERROR_XFER, save_errno, \"readlink_stat(%s) failed\",\n\t\t\t\tfull_fname(thisname));\n\t\t}\n\t\treturn NULL;\n\t} else if (IS_MISSING_FILE(st)) {\n\t\tio_error |= IOERR_GENERAL;\n\t\trprintf(FINFO, \"skipping file with bogus (zero) st_mode: %s\\n\",\n\t\t\tfull_fname(thisname));\n\t\treturn NULL;\n\t}\n\n\tif (filter_level == NO_FILTERS)\n\t\tgoto skip_filters;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tif (!xfer_dirs) {\n\t\t\trprintf(FINFO, \"skipping directory %s\\n\", thisname);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* -x only affects dirs because we need to avoid recursing\n\t\t * into a mount-point directory, not to avoid copying a\n\t\t * symlinked file if -L (or similar) was specified. */\n\t\tif (one_file_system && st.st_dev != filesystem_dev\n\t\t && BITS_SETnUNSET(flags, FLAG_CONTENT_DIR, FLAG_TOP_DIR)) {\n\t\t\tif (one_file_system > 1) {\n\t\t\t\tif (INFO_GTE(MOUNT, 1)) {\n\t\t\t\t\trprintf(FINFO,\n\t\t\t\t\t    \"[%s] skipping mount-point dir %s\\n\",\n\t\t\t\t\t    who_am_i(), thisname);\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tflags |= FLAG_MOUNT_DIR;\n\t\t\tflags &= ~FLAG_CONTENT_DIR;\n\t\t}\n\t} else\n\t\tflags &= ~FLAG_CONTENT_DIR;\n\n\tif (is_excluded(thisname, S_ISDIR(st.st_mode) != 0, filter_level)) {\n\t\tif (ignore_perishable)\n\t\t\tnon_perishable_cnt++;\n\t\treturn NULL;\n\t}\n\n\tif (lp_ignore_nonreadable(module_id)) {\n#ifdef SUPPORT_LINKS\n\t\tif (!S_ISLNK(st.st_mode))\n#endif\n\t\t\tif (access(thisname, R_OK) != 0)\n\t\t\t\treturn NULL;\n\t}\n\n  skip_filters:\n\n\t/* Only divert a directory in the main transfer. */\n\tif (flist) {\n\t\tif (flist->prev && S_ISDIR(st.st_mode)\n\t\t && flags & FLAG_DIVERT_DIRS) {\n\t\t\t/* Room for parent/sibling/next-child info. */\n\t\t\textra_len += DIRNODE_EXTRA_CNT * EXTRA_LEN;\n\t\t\tif (relative_paths)\n\t\t\t\textra_len += PTR_EXTRA_CNT * EXTRA_LEN;\n\t\t\tpool = dir_flist->file_pool;\n\t\t} else\n\t\t\tpool = flist->file_pool;\n\t} else {\n#ifdef SUPPORT_ACLS\n\t\t/* Directories need an extra int32 for the default ACL. */\n\t\tif (preserve_acls && S_ISDIR(st.st_mode))\n\t\t\textra_len += EXTRA_LEN;\n#endif\n\t\tpool = NULL;\n\t}\n\n\tif (DEBUG_GTE(FLIST, 2)) {\n\t\trprintf(FINFO, \"[%s] make_file(%s,*,%d)\\n\",\n\t\t\twho_am_i(), thisname, filter_level);\n\t}\n\n\tif ((basename = strrchr(thisname, '/')) != NULL) {\n\t\tint len = basename++ - thisname;\n\t\tif (len != lastdir_len || memcmp(thisname, lastdir, len) != 0) {\n\t\t\tlastdir = new_array(char, len + 1);\n\t\t\tmemcpy(lastdir, thisname, len);\n\t\t\tlastdir[len] = '\\0';\n\t\t\tlastdir_len = len;\n\t\t}\n\t} else\n\t\tbasename = thisname;\n\tbasename_len = strlen(basename) + 1; /* count the '\\0' */\n\n#ifdef SUPPORT_LINKS\n\tlinkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;\n#else\n\tlinkname_len = 0;\n#endif\n\n\tif (copy_devices && am_sender && IS_DEVICE(st.st_mode)) {\n\t\tif (st.st_size == 0) {\n\t\t\tint fd = do_open(fname, O_RDONLY, 0);\n\t\t\tif (fd >= 0) {\n\t\t\t\tst.st_size = get_device_size(fd, fname);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t}\n\t\tst.st_mode = S_IFREG | (st.st_mode & ACCESSPERMS);\n\t\tst.st_mtime = time(NULL); /* The mtime on the device is not up-to-date, so set it to \"now\". */\n\t}\n\n#ifdef ST_MTIME_NSEC\n\tif (st.ST_MTIME_NSEC && protocol_version >= 31)\n\t\textra_len += EXTRA_LEN;\n#endif\n#if SIZEOF_CAPITAL_OFF_T >= 8\n\tif (st.st_size > 0xFFFFFFFFu && S_ISREG(st.st_mode))\n\t\textra_len += EXTRA_LEN;\n#endif\n\n\tif (always_checksum && am_sender && S_ISREG(st.st_mode)) {\n\t\tfile_checksum(thisname, &st, tmp_sum);\n\t\tif (sender_keeps_checksum)\n\t\t\textra_len += SUM_EXTRA_CNT * EXTRA_LEN;\n\t}\n\n#if EXTRA_ROUNDING > 0\n\tif (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))\n\t\textra_len = (extra_len | (EXTRA_ROUNDING * EXTRA_LEN)) + EXTRA_LEN;\n#endif\n\n\talloc_len = FILE_STRUCT_LEN + extra_len + basename_len\n\t\t  + linkname_len;\n\tif (pool)\n\t\tbp = pool_alloc(pool, alloc_len, \"make_file\");\n\telse\n\t\tbp = new_array(char, alloc_len);\n\n\tmemset(bp, 0, extra_len + FILE_STRUCT_LEN);\n\tbp += extra_len;\n\tfile = (struct file_struct *)bp;\n\tbp += FILE_STRUCT_LEN;\n\n\tmemcpy(bp, basename, basename_len);\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && flist && flist->prev) {\n\t\tif (protocol_version >= 28\n\t\t ? (!S_ISDIR(st.st_mode) && st.st_nlink > 1)\n\t\t : S_ISREG(st.st_mode)) {\n\t\t\ttmp_dev = (int64)st.st_dev;\n\t\t\ttmp_ino = (int64)st.st_ino;\n\t\t} else\n\t\t\ttmp_dev = -1;\n\t}\n#endif\n\n#ifdef HAVE_STRUCT_STAT_ST_RDEV\n\tif (IS_DEVICE(st.st_mode)) {\n\t\ttmp_rdev = st.st_rdev;\n\t\tst.st_size = 0;\n\t} else if (IS_SPECIAL(st.st_mode))\n\t\tst.st_size = 0;\n#endif\n\n\tfile->flags = flags;\n\tfile->modtime = st.st_mtime;\n#ifdef ST_MTIME_NSEC\n\tif (st.ST_MTIME_NSEC && protocol_version >= 31) {\n\t\tfile->flags |= FLAG_MOD_NSEC;\n\t\tF_MOD_NSEC(file) = st.ST_MTIME_NSEC;\n\t}\n#endif\n\tfile->len32 = (uint32)st.st_size;\n#if SIZEOF_CAPITAL_OFF_T >= 8\n\tif (st.st_size > 0xFFFFFFFFu && S_ISREG(st.st_mode)) {\n\t\tfile->flags |= FLAG_LENGTH64;\n\t\tF_HIGH_LEN(file) = (uint32)(st.st_size >> 32);\n\t}\n#endif\n\tfile->mode = st.st_mode;\n\tif (preserve_uid)\n\t\tF_OWNER(file) = st.st_uid;\n\tif (preserve_gid)\n\t\tF_GROUP(file) = st.st_gid;\n\tif (am_generator && st.st_uid == our_uid)\n\t\tfile->flags |= FLAG_OWNED_BY_US;\n\tif (atimes_ndx && !S_ISDIR(file->mode))\n\t\tF_ATIME(file) = st.st_atime;\n#ifdef SUPPORT_CRTIMES\n\tif (crtimes_ndx)\n\t\tF_CRTIME(file) = get_create_time(fname, &st);\n#endif\n\n\tif (basename != thisname)\n\t\tfile->dirname = lastdir;\n\n#ifdef SUPPORT_LINKS\n\tif (linkname_len)\n\t\tmemcpy(bp + basename_len, linkname, linkname_len);\n#endif\n\n\tif (am_sender)\n\t\tF_PATHNAME(file) = pathname;\n\telse if (!pool)\n\t\tF_DEPTH(file) = extra_len / EXTRA_LEN;\n\n\tif (basename_len == 0+1) {\n\t\tif (!pool)\n\t\t\tunmake_file(file);\n\t\treturn NULL;\n\t}\n\n\tif (sender_keeps_checksum && S_ISREG(st.st_mode))\n\t\tmemcpy(F_SUM(file), tmp_sum, flist_csum_len);\n\n\tif (unsort_ndx)\n\t\tF_NDX(file) = stats.num_dirs;\n\n\treturn file;\n}\n\nOFF_T get_device_size(int fd, const char *fname)\n{\n\tOFF_T off = lseek(fd, 0, SEEK_END);\n\n\tif (off == (OFF_T) -1) {\n\t\trsyserr(FERROR, errno, \"failed to get device size via seek: %s\", fname);\n\t\treturn 0;\n\t}\n\tif (lseek(fd, 0, SEEK_SET) != 0)\n\t\trsyserr(FERROR, errno, \"failed to seek device back to start: %s\", fname);\n\n\treturn off;\n}\n\n/* Only called for temporary file_struct entries created by make_file(). */\nvoid unmake_file(struct file_struct *file)\n{\n\tfree(REQ_EXTRA(file, F_DEPTH(file)));\n}\n\nstatic struct file_struct *send_file_name(int f, struct file_list *flist,\n\t\t\t\t\t  const char *fname, STRUCT_STAT *stp,\n\t\t\t\t\t  int flags, int filter_level)\n{\n\tstruct file_struct *file;\n\n\tfile = make_file(fname, flist, stp, flags, filter_level);\n\tif (!file)\n\t\treturn NULL;\n\n\tif (chmod_modes && !S_ISLNK(file->mode) && file->mode)\n\t\tfile->mode = tweak_mode(file->mode, chmod_modes);\n\n\tif (f >= 0) {\n\t\tchar fbuf[MAXPATHLEN];\n#ifdef SUPPORT_LINKS\n\t\tconst char *symlink_name;\n\t\tint symlink_len;\n#ifdef ICONV_OPTION\n\t\tchar symlink_buf[MAXPATHLEN];\n#endif\n#endif\n#if defined SUPPORT_ACLS || defined SUPPORT_XATTRS\n\t\tstat_x sx;\n\t\tinit_stat_x(&sx);\n#endif\n\n#ifdef SUPPORT_LINKS\n\t\tif (preserve_links && S_ISLNK(file->mode)) {\n\t\t\tsymlink_name = F_SYMLINK(file);\n\t\t\tsymlink_len = strlen(symlink_name);\n\t\t\tif (symlink_len == 0) {\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\tf_name(file, fbuf);\n\t\t\t\trprintf(FERROR_XFER,\n\t\t\t\t    \"skipping symlink with 0-length value: %s\\n\",\n\t\t\t\t    full_fname(fbuf));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tsymlink_name = NULL;\n\t\t\tsymlink_len = 0;\n\t\t}\n#endif\n\n#ifdef ICONV_OPTION\n\t\tif (ic_send != (iconv_t)-1) {\n\t\t\txbuf outbuf, inbuf;\n\n\t\t\tINIT_CONST_XBUF(outbuf, fbuf);\n\n\t\t\tif (file->dirname) {\n\t\t\t\tINIT_XBUF_STRLEN(inbuf, (char*)file->dirname);\n\t\t\t\toutbuf.size -= 2; /* Reserve room for '/' & 1 more char. */\n\t\t\t\tif (iconvbufs(ic_send, &inbuf, &outbuf, ICB_INIT) < 0)\n\t\t\t\t\tgoto convert_error;\n\t\t\t\toutbuf.size += 2;\n\t\t\t\tfbuf[outbuf.len++] = '/';\n\t\t\t}\n\n\t\t\tINIT_XBUF_STRLEN(inbuf, (char*)file->basename);\n\t\t\tif (iconvbufs(ic_send, &inbuf, &outbuf, ICB_INIT) < 0) {\n\t\t\t  convert_error:\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\trprintf(FERROR_XFER,\n\t\t\t\t    \"[%s] cannot convert filename: %s (%s)\\n\",\n\t\t\t\t    who_am_i(), f_name(file, fbuf), strerror(errno));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfbuf[outbuf.len] = '\\0';\n\n#ifdef SUPPORT_LINKS\n\t\t\tif (symlink_len && sender_symlink_iconv) {\n\t\t\t\tINIT_XBUF(inbuf, (char*)symlink_name, symlink_len, (size_t)-1);\n\t\t\t\tINIT_CONST_XBUF(outbuf, symlink_buf);\n\t\t\t\tif (iconvbufs(ic_send, &inbuf, &outbuf, ICB_INIT) < 0) {\n\t\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\t\tf_name(file, fbuf);\n\t\t\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\t    \"[%s] cannot convert symlink data for: %s (%s)\\n\",\n\t\t\t\t\t    who_am_i(), full_fname(fbuf), strerror(errno));\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tsymlink_buf[outbuf.len] = '\\0';\n\n\t\t\t\tsymlink_name = symlink_buf;\n\t\t\t\tsymlink_len = outbuf.len;\n\t\t\t}\n#endif\n\t\t} else\n#endif\n\t\t\tf_name(file, fbuf);\n\n#ifdef SUPPORT_ACLS\n\t\tif (preserve_acls && !S_ISLNK(file->mode)) {\n\t\t\tsx.st.st_mode = file->mode;\n\t\t\tif (get_acl(fname, &sx) < 0) {\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n#endif\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs) {\n\t\t\tsx.st.st_mode = file->mode;\n\t\t\tif (get_xattr(fname, &sx) < 0) {\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tsend_file_entry(f, fbuf, file,\n#ifdef SUPPORT_LINKS\n\t\t\t\tsymlink_name, symlink_len,\n#endif\n\t\t\t\tflist->used, flist->ndx_start);\n\n#ifdef SUPPORT_ACLS\n\t\tif (preserve_acls && !S_ISLNK(file->mode)) {\n\t\t\tsend_acl(f, &sx);\n\t\t\tfree_acl(&sx);\n\t\t}\n#endif\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs) {\n\t\t\tF_XATTR(file) = send_xattr(f, &sx);\n\t\t\tfree_xattr(&sx);\n\t\t}\n#endif\n\t}\n\n\tmaybe_emit_filelist_progress(flist->used + flist_count_offset);\n\n\tflist_expand(flist, 1);\n\tflist->files[flist->used++] = file;\n\n\treturn file;\n}\n\nstatic void send_if_directory(int f, struct file_list *flist,\n\t\t\t      struct file_struct *file,\n\t\t\t      char *fbuf, unsigned int ol,\n\t\t\t      int flags)\n{\n\tchar is_dot_dir = fbuf[ol-1] == '.' && (ol == 1 || fbuf[ol-2] == '/');\n\n\tif (S_ISDIR(file->mode)\n\t    && !(file->flags & FLAG_MOUNT_DIR) && f_name(file, fbuf)) {\n\t\tvoid *save_filters;\n\t\tunsigned int len = strlen(fbuf);\n\t\tif (len > 1 && fbuf[len-1] == '/')\n\t\t\tfbuf[--len] = '\\0';\n\t\tsave_filters = push_local_filters(fbuf, len);\n\t\tsend_directory(f, flist, fbuf, len, flags);\n\t\tpop_local_filters(save_filters);\n\t\tfbuf[ol] = '\\0';\n\t\tif (is_dot_dir)\n\t\t\tfbuf[ol-1] = '.';\n\t}\n}\n\nstatic int file_compare(const void *file1, const void *file2)\n{\n\treturn f_name_cmp(*(struct file_struct **)file1,\n\t\t\t  *(struct file_struct **)file2);\n}\n\n/* The guts of a merge-sort algorithm.  This was derived from the glibc\n * version, but I (Wayne) changed the merge code to do less copying and\n * to require only half the amount of temporary memory. */\nstatic void fsort_tmp(struct file_struct **fp, size_t num,\n\t\t      struct file_struct **tmp)\n{\n\tstruct file_struct **f1, **f2, **t;\n\tsize_t n1, n2;\n\n\tn1 = num / 2;\n\tn2 = num - n1;\n\tf1 = fp;\n\tf2 = fp + n1;\n\n\tif (n1 > 1)\n\t\tfsort_tmp(f1, n1, tmp);\n\tif (n2 > 1)\n\t\tfsort_tmp(f2, n2, tmp);\n\n\twhile (f_name_cmp(*f1, *f2) <= 0) {\n\t\tif (!--n1)\n\t\t\treturn;\n\t\tf1++;\n\t}\n\n\tt = tmp;\n\tmemcpy(t, f1, n1 * PTR_SIZE);\n\n\t*f1++ = *f2++, n2--;\n\n\twhile (n1 > 0 && n2 > 0) {\n\t\tif (f_name_cmp(*t, *f2) <= 0)\n\t\t\t*f1++ = *t++, n1--;\n\t\telse\n\t\t\t*f1++ = *f2++, n2--;\n\t}\n\n\tif (n1 > 0)\n\t\tmemcpy(f1, t, n1 * PTR_SIZE);\n}\n\n/* This file-struct sorting routine makes sure that any identical names in\n * the file list stay in the same order as they were in the original list.\n * This is particularly vital in inc_recurse mode where we expect a sort\n * on the flist to match the exact order of a sort on the dir_flist. */\nstatic void fsort(struct file_struct **fp, size_t num)\n{\n\tif (num <= 1)\n\t\treturn;\n\n\tif (use_qsort)\n\t\tqsort(fp, num, PTR_SIZE, file_compare);\n\telse {\n\t\tstruct file_struct **tmp = new_array(struct file_struct *, (num+1) / 2);\n\t\tfsort_tmp(fp, num, tmp);\n\t\tfree(tmp);\n\t}\n}\n\n/* We take an entire set of sibling dirs from the sorted flist and link them\n * into the tree, setting the appropriate parent/child/sibling pointers. */\nstatic void add_dirs_to_tree(int parent_ndx, struct file_list *from_flist,\n\t\t\t     int dir_cnt)\n{\n\tint i;\n\tint32 *dp = NULL;\n\tint32 *parent_dp = parent_ndx < 0 ? NULL\n\t\t\t : F_DIR_NODE_P(dir_flist->sorted[parent_ndx]);\n\n\t/* The sending side is adding entries to dir_flist in sorted order, so sorted & files are the same. */\n\tflist_expand(dir_flist, dir_cnt);\n\tdir_flist->sorted = dir_flist->files;\n\n\tfor (i = 0; dir_cnt; i++) {\n\t\tstruct file_struct *file = from_flist->sorted[i];\n\n\t\tif (!S_ISDIR(file->mode))\n\t\t\tcontinue;\n\n\t\tdir_flist->files[dir_flist->used++] = file;\n\t\tdir_cnt--;\n\n\t\tif (file->basename[0] == '.' && file->basename[1] == '\\0')\n\t\t\tcontinue;\n\n\t\tif (dp)\n\t\t\tDIR_NEXT_SIBLING(dp) = dir_flist->used - 1;\n\t\telse if (parent_dp)\n\t\t\tDIR_FIRST_CHILD(parent_dp) = dir_flist->used - 1;\n\t\telse\n\t\t\tsend_dir_ndx = dir_flist->used - 1;\n\n\t\tdp = F_DIR_NODE_P(file);\n\t\tDIR_PARENT(dp) = parent_ndx;\n\t\tDIR_FIRST_CHILD(dp) = -1;\n\t}\n\tif (dp)\n\t\tDIR_NEXT_SIBLING(dp) = -1;\n}\n\nstatic void interpret_stat_error(const char *fname, int is_dir)\n{\n\tif (errno == ENOENT) {\n\t\tio_error |= IOERR_VANISHED;\n\t\trprintf(FWARNING, \"%s has vanished: %s\\n\",\n\t\t\tis_dir ? \"directory\" : \"file\", full_fname(fname));\n\t} else {\n\t\tio_error |= IOERR_GENERAL;\n\t\trsyserr(FERROR_XFER, errno, \"link_stat %s failed\",\n\t\t\tfull_fname(fname));\n\t}\n}\n\n/* This function is normally called by the sender, but the receiving side also\n * calls it from get_dirlist() with f set to -1 so that we just construct the\n * file list in memory without sending it over the wire.  Also, get_dirlist()\n * might call this with f set to -2, which also indicates that local filter\n * rules should be ignored. */\nstatic void send_directory(int f, struct file_list *flist, char *fbuf, int len,\n\t\t\t   int flags)\n{\n\tstruct dirent *di;\n\tunsigned remainder;\n\tchar *p;\n\tDIR *d;\n\tint divert_dirs = (flags & FLAG_DIVERT_DIRS) != 0;\n\tint start = flist->used;\n\tint filter_level = f == -2 ? SERVER_FILTERS : ALL_FILTERS;\n\n\tassert(flist != NULL);\n\n\tif (!(d = opendir(fbuf))) {\n\t\tif (errno == ENOENT) {\n\t\t\tif (am_sender) /* Can abuse this for vanished error w/ENOENT: */\n\t\t\t\tinterpret_stat_error(fbuf, True);\n\t\t\treturn;\n\t\t}\n\t\tif (errno == ENOTDIR && (flags & FLAG_PERHAPS_DIR))\n\t\t\treturn;\n\t\tio_error |= IOERR_GENERAL;\n\t\trsyserr(FERROR_XFER, errno, \"opendir %s failed\", full_fname(fbuf));\n\t\treturn;\n\t}\n\n\tp = fbuf + len;\n\tif (len == 1 && *fbuf == '/')\n\t\tremainder = MAXPATHLEN - 1;\n\telse if (len < MAXPATHLEN-1) {\n\t\t*p++ = '/';\n\t\t*p = '\\0';\n\t\tremainder = MAXPATHLEN - (len + 1);\n\t} else\n\t\tremainder = 0;\n\n\tfor (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {\n\t\tunsigned name_len;\n\t\tchar *dname = d_name(di);\n\t\tif (dname[0] == '.' && (dname[1] == '\\0'\n\t\t    || (dname[1] == '.' && dname[2] == '\\0')))\n\t\t\tcontinue;\n\t\tname_len = strlcpy(p, dname, remainder);\n\t\tif (name_len >= remainder) {\n\t\t\tchar save = fbuf[len];\n\t\t\tfbuf[len] = '\\0';\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\"filename overflows max-path len by %u: %s/%s\\n\",\n\t\t\t\tname_len - remainder + 1, fbuf, dname);\n\t\t\tfbuf[len] = save;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dname[0] == '\\0') {\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\"cannot send file with empty name in %s\\n\",\n\t\t\t\tfull_fname(fbuf));\n\t\t\tcontinue;\n\t\t}\n\n\t\tsend_file_name(f, flist, fbuf, NULL, flags, filter_level);\n\t}\n\n\tfbuf[len] = '\\0';\n\n\tif (errno) {\n\t\tio_error |= IOERR_GENERAL;\n\t\trsyserr(FERROR_XFER, errno, \"readdir(%s)\", full_fname(fbuf));\n\t}\n\n\tclosedir(d);\n\n\tif (f >= 0 && recurse && !divert_dirs) {\n\t\tint i, end = flist->used - 1;\n\t\t/* send_if_directory() bumps flist->used, so use \"end\". */\n\t\tfor (i = start; i <= end; i++)\n\t\t\tsend_if_directory(f, flist, flist->files[i], fbuf, len, flags);\n\t}\n}\n\nstatic void send_implied_dirs(int f, struct file_list *flist, char *fname,\n\t\t\t      char *start, char *limit, int flags, char name_type)\n{\n\tstatic char lastpath[MAXPATHLEN] = \"\";\n\tstatic int lastpath_len = 0;\n\tstatic struct file_struct *lastpath_struct = NULL;\n\tstruct file_struct *file;\n\titem_list *relname_list;\n\trelnamecache **rnpp;\n\tint len, need_new_dir, depth = 0;\n\tfilter_rule_list save_filter_list = filter_list;\n\n\tflags = (flags | FLAG_IMPLIED_DIR) & ~(FLAG_TOP_DIR | FLAG_CONTENT_DIR);\n\tfilter_list.head = filter_list.tail = NULL; /* Don't filter implied dirs. */\n\n\tif (inc_recurse) {\n\t\tif (lastpath_struct && F_PATHNAME(lastpath_struct) == pathname\n\t\t && lastpath_len == limit - fname\n\t\t && strncmp(lastpath, fname, lastpath_len) == 0)\n\t\t\tneed_new_dir = 0;\n\t\telse\n\t\t\tneed_new_dir = 1;\n\t} else {\n\t\tchar *tp = fname, *lp = lastpath;\n\t\t/* Skip any initial directories in our path that we\n\t\t * have in common with lastpath. */\n\t\tassert(start == fname);\n\t\tfor ( ; ; tp++, lp++) {\n\t\t\tif (tp == limit) {\n\t\t\t\tif (*lp == '/' || *lp == '\\0')\n\t\t\t\t\tgoto done;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*lp != *tp)\n\t\t\t\tbreak;\n\t\t\tif (*tp == '/') {\n\t\t\t\tstart = tp;\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t}\n\t\tneed_new_dir = 1;\n\t}\n\n\tif (need_new_dir) {\n\t\tint save_copy_links = copy_links;\n\t\tint save_xfer_dirs = xfer_dirs;\n\t\tchar *slash;\n\n\t\tcopy_links = xfer_dirs = 1;\n\n\t\t*limit = '\\0';\n\n\t\tfor (slash = start; (slash = strchr(slash+1, '/')) != NULL; ) {\n\t\t\t*slash = '\\0';\n\t\t\tfile = send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);\n\t\t\tdepth++;\n\t\t\tif (!inc_recurse && file && S_ISDIR(file->mode))\n\t\t\t\tchange_local_filter_dir(fname, strlen(fname), depth);\n\t\t\t*slash = '/';\n\t\t}\n\n\t\tfile = send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);\n\t\tif (inc_recurse) {\n\t\t\tif (file && !S_ISDIR(file->mode))\n\t\t\t\tfile = NULL;\n\t\t\tlastpath_struct = file;\n\t\t} else if (file && S_ISDIR(file->mode))\n\t\t\tchange_local_filter_dir(fname, strlen(fname), ++depth);\n\n\t\tstrlcpy(lastpath, fname, sizeof lastpath);\n\t\tlastpath_len = limit - fname;\n\n\t\t*limit = '/';\n\n\t\tcopy_links = save_copy_links;\n\t\txfer_dirs = save_xfer_dirs;\n\n\t\tif (!inc_recurse)\n\t\t\tgoto done;\n\t}\n\n\tif (!lastpath_struct)\n\t\tgoto done; /* dir must have vanished */\n\n\tlen = strlen(limit+1);\n\tmemcpy(&relname_list, F_DIR_RELNAMES_P(lastpath_struct), sizeof relname_list);\n\tif (!relname_list) {\n\t\trelname_list = new0(item_list);\n\t\tmemcpy(F_DIR_RELNAMES_P(lastpath_struct), &relname_list, sizeof relname_list);\n\t}\n\trnpp = EXPAND_ITEM_LIST(relname_list, relnamecache *, 32);\n\t*rnpp = (relnamecache*)new_array(char, RELNAMECACHE_LEN + len + 1);\n\t(*rnpp)->name_type = name_type;\n\tstrlcpy((*rnpp)->fname, limit+1, len + 1);\n\ndone:\n\tfilter_list = save_filter_list;\n}\n\nstatic NORETURN void fatal_unsafe_io_error(void)\n{\n\t/* This (sadly) can only happen when pushing data because\n\t * the sender does not know about what kind of delete\n\t * is in effect on the receiving side when pulling. */\n\trprintf(FERROR_XFER, \"FATAL I/O ERROR: dying to avoid a --delete-%s issue with a pre-3.0.7 receiver.\\n\",\n\t\tdelete_during == 2 ? \"delay\" : \"during\");\n\texit_cleanup(RERR_UNSUPPORTED);\n}\n\nstatic void send1extra(int f, struct file_struct *file, struct file_list *flist)\n{\n\tchar fbuf[MAXPATHLEN];\n\titem_list *relname_list;\n\tint len, dlen, flags = FLAG_DIVERT_DIRS | FLAG_CONTENT_DIR;\n\tsize_t j;\n\n\tf_name(file, fbuf);\n\tdlen = strlen(fbuf);\n\n\tif (!change_pathname(file, NULL, 0))\n\t\texit_cleanup(RERR_FILESELECT);\n\n\tchange_local_filter_dir(fbuf, dlen, send_dir_depth);\n\n\tif (file->flags & FLAG_CONTENT_DIR) {\n\t\tif (one_file_system) {\n\t\t\tSTRUCT_STAT st;\n\t\t\tif (link_stat(fbuf, &st, copy_dirlinks) != 0) {\n\t\t\t\tinterpret_stat_error(fbuf, True);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfilesystem_dev = st.st_dev;\n\t\t}\n\t\tsend_directory(f, flist, fbuf, dlen, flags);\n\t}\n\n\tif (!relative_paths)\n\t\treturn;\n\n\tmemcpy(&relname_list, F_DIR_RELNAMES_P(file), sizeof relname_list);\n\tif (!relname_list)\n\t\treturn;\n\n\tfor (j = 0; j < relname_list->count; j++) {\n\t\tchar *slash;\n\t\trelnamecache *rnp = ((relnamecache**)relname_list->items)[j];\n\t\tchar name_type = rnp->name_type;\n\n\t\tfbuf[dlen] = '/';\n\t\tlen = strlcpy(fbuf + dlen + 1, rnp->fname, sizeof fbuf - dlen - 1);\n\t\tfree(rnp);\n\t\tif (len >= (int)sizeof fbuf)\n\t\t\tcontinue; /* Impossible... */\n\n\t\tslash = strchr(fbuf+dlen+1, '/');\n\t\tif (slash) {\n\t\t\tsend_implied_dirs(f, flist, fbuf, fbuf+dlen+1, slash, flags, name_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (name_type != NORMAL_NAME) {\n\t\t\tSTRUCT_STAT st;\n\t\t\tif (name_type == MISSING_NAME)\n\t\t\t\tmemset(&st, 0, sizeof st);\n\t\t\telse if (link_stat(fbuf, &st, 1) != 0) {\n\t\t\t\tinterpret_stat_error(fbuf, True);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsend_file_name(f, flist, fbuf, &st, FLAG_TOP_DIR | flags, ALL_FILTERS);\n\t\t} else\n\t\t\tsend_file_name(f, flist, fbuf, NULL, FLAG_TOP_DIR | flags, ALL_FILTERS);\n\t}\n\n\tfree(relname_list);\n}\n\nstatic void write_end_of_flist(int f, int send_io_error)\n{\n\tif (xfer_flags_as_varint) {\n\t\twrite_varint(f, 0);\n\t\twrite_varint(f, send_io_error ? io_error : 0);\n\t} else if (send_io_error) {\n\t\twrite_shortint(f, XMIT_EXTENDED_FLAGS|XMIT_IO_ERROR_ENDLIST);\n\t\twrite_varint(f, io_error);\n\t} else\n\t\twrite_byte(f, 0);\n}\n\nvoid send_extra_file_list(int f, int at_least)\n{\n\tstruct file_list *flist;\n\tint64 start_write;\n\tuint16 prev_flags;\n\tint save_io_error = io_error;\n\n\tif (flist_eof)\n\t\treturn;\n\n\tif (at_least < 0)\n\t\tat_least = file_total - file_old_total + 1;\n\n\t/* Keep sending data until we have the requested number of\n\t * files in the upcoming file-lists. */\n\twhile (file_total - file_old_total < at_least) {\n\t\tstruct file_struct *file = dir_flist->sorted[send_dir_ndx];\n\t\tint dir_ndx, dstart = stats.num_dirs;\n\t\tconst char *pathname = F_PATHNAME(file);\n\t\tint32 *dp;\n\n\t\tflist = flist_new(0, \"send_extra_file_list\");\n\t\tstart_write = stats.total_written;\n\n\t\tif (unsort_ndx)\n\t\t\tdir_ndx = F_NDX(file);\n\t\telse\n\t\t\tdir_ndx = send_dir_ndx;\n\t\twrite_ndx(f, NDX_FLIST_OFFSET - dir_ndx);\n\t\tflist->parent_ndx = send_dir_ndx; /* the sending side must remember the sorted ndx value */\n\n\t\tsend1extra(f, file, flist);\n\t\tprev_flags = file->flags;\n\t\tdp = F_DIR_NODE_P(file);\n\n\t\t/* If there are any duplicate directory names that follow, we\n\t\t * send all the dirs together in one file-list.  The dir_flist\n\t\t * tree links all the child subdirs onto the last dup dir. */\n\t\twhile ((dir_ndx = DIR_NEXT_SIBLING(dp)) >= 0\n\t\t    && dir_flist->sorted[dir_ndx]->flags & FLAG_DUPLICATE) {\n\t\t\tsend_dir_ndx = dir_ndx;\n\t\t\tfile = dir_flist->sorted[dir_ndx];\n\t\t\t/* Try to avoid some duplicate scanning of identical dirs. */\n\t\t\tif (F_PATHNAME(file) == pathname && prev_flags & FLAG_CONTENT_DIR)\n\t\t\t\tfile->flags &= ~FLAG_CONTENT_DIR;\n\t\t\tsend1extra(f, file, flist);\n\t\t\tprev_flags = file->flags;\n\t\t\tdp = F_DIR_NODE_P(file);\n\t\t}\n\n\t\tif (io_error == save_io_error || ignore_errors)\n\t\t\twrite_end_of_flist(f, 0);\n\t\telse if (use_safe_inc_flist)\n\t\t\twrite_end_of_flist(f, 1);\n\t\telse {\n\t\t\tif (delete_during)\n\t\t\t\tfatal_unsafe_io_error();\n\t\t\twrite_end_of_flist(f, 0);\n\t\t}\n\n\t\tif (need_unsorted_flist) {\n\t\t\tflist->sorted = new_array(struct file_struct *, flist->used);\n\t\t\tmemcpy(flist->sorted, flist->files, flist->used * PTR_SIZE);\n\t\t} else\n\t\t\tflist->sorted = flist->files;\n\n\t\tflist_sort_and_clean(flist, 0);\n\n\t\tadd_dirs_to_tree(send_dir_ndx, flist, stats.num_dirs - dstart);\n\t\tflist_done_allocating(flist);\n\n\t\tfile_total += flist->used;\n\t\tstats.flist_size += stats.total_written - start_write;\n\t\tstats.num_files += flist->used;\n\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\toutput_flist(flist);\n\n\t\tif (DIR_FIRST_CHILD(dp) >= 0) {\n\t\t\tsend_dir_ndx = DIR_FIRST_CHILD(dp);\n\t\t\tsend_dir_depth++;\n\t\t} else {\n\t\t\twhile (DIR_NEXT_SIBLING(dp) < 0) {\n\t\t\t\tif ((send_dir_ndx = DIR_PARENT(dp)) < 0) {\n\t\t\t\t\twrite_ndx(f, NDX_FLIST_EOF);\n\t\t\t\t\tflist_eof = 1;\n\t\t\t\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\t\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t\t\t\t\tchange_local_filter_dir(NULL, 0, 0);\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t\tsend_dir_depth--;\n\t\t\t\tfile = dir_flist->sorted[send_dir_ndx];\n\t\t\t\tdp = F_DIR_NODE_P(file);\n\t\t\t}\n\t\t\tsend_dir_ndx = DIR_NEXT_SIBLING(dp);\n\t\t}\n\t}\n\n  finish:\n\tif (io_error != save_io_error && protocol_version == 30 && !ignore_errors)\n\t\tsend_msg_int(MSG_IO_ERROR, io_error);\n}\n\nstruct file_list *send_file_list(int f, int argc, char *argv[])\n{\n\tstatic const char *lastdir;\n\tstatic int lastdir_len = -1;\n\tint len, dirlen;\n\tSTRUCT_STAT st;\n\tchar *p, *dir;\n\tstruct file_list *flist;\n\tstruct timeval start_tv, end_tv;\n\tint64 start_write;\n\tint use_ff_fd = 0;\n\tint disable_buffering, reenable_multiplex = -1;\n\tint flags = recurse ? FLAG_CONTENT_DIR : 0;\n\tint reading_remotely = filesfrom_host != NULL;\n\tint rl_flags = (reading_remotely ? 0 : RL_DUMP_COMMENTS)\n#ifdef ICONV_OPTION\n\t\t     | (filesfrom_convert ? RL_CONVERT : 0)\n#endif\n\t\t     | (eol_nulls || reading_remotely ? RL_EOL_NULLS : 0);\n\tint implied_dot_dir = 0;\n\n\trprintf(FLOG, \"building file list\\n\");\n\tif (show_filelist_progress)\n\t\tstart_filelist_progress(\"building file list\");\n\telse if (inc_recurse && INFO_GTE(FLIST, 1) && !am_server)\n\t\trprintf(FCLIENT, \"sending incremental file list\\n\");\n\n\tstart_write = stats.total_written;\n\tgettimeofday(&start_tv, NULL);\n\n\tif (relative_paths && protocol_version >= 30)\n\t\timplied_dirs = 1; /* We send flagged implied dirs */\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && protocol_version >= 30 && !cur_flist)\n\t\tinit_hard_links();\n#endif\n\n\tflist = cur_flist = flist_new(0, \"send_file_list\");\n\tflist_expand(flist, FLIST_START_LARGE);\n\tif (inc_recurse) {\n\t\tdir_flist = flist_new(FLIST_TEMP, \"send_file_list\");\n\t\tflist_expand(dir_flist, FLIST_START_LARGE);\n\t\tflags |= FLAG_DIVERT_DIRS;\n\t} else\n\t\tdir_flist = cur_flist;\n\n\tdisable_buffering = io_start_buffering_out(f);\n\tif (filesfrom_fd >= 0) {\n\t\tif (argv[0] && !change_dir(argv[0], CD_NORMAL)) {\n\t\t\trsyserr(FERROR_XFER, errno, \"change_dir %s failed\",\n\t\t\t\tfull_fname(argv[0]));\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t\tif (protocol_version < 31) {\n\t\t\t/* Older protocols send the files-from data w/o packaging\n\t\t\t * it in multiplexed I/O packets, so temporarily switch\n\t\t\t * to buffered I/O to match this behavior. */\n\t\t\treenable_multiplex = io_end_multiplex_in(MPLX_TO_BUFFERED);\n\t\t}\n\t\tuse_ff_fd = 1;\n\t}\n\n\tif (!orig_dir)\n\t\torig_dir = strdup(curr_dir);\n\n\twhile (1) {\n\t\tchar fbuf[MAXPATHLEN], *fn, name_type;\n\n\t\tif (use_ff_fd) {\n\t\t\tif (read_line(filesfrom_fd, fbuf, sizeof fbuf, rl_flags) == 0)\n\t\t\t\tbreak;\n\t\t\tsanitize_path(fbuf, fbuf, \"\", 0, SP_KEEP_DOT_DIRS);\n\t\t} else {\n\t\t\tif (argc-- == 0)\n\t\t\t\tbreak;\n\t\t\tstrlcpy(fbuf, *argv++, MAXPATHLEN);\n\t\t\tif (sanitize_paths)\n\t\t\t\tsanitize_path(fbuf, fbuf, \"\", 0, SP_KEEP_DOT_DIRS);\n\t\t}\n\n\t\tlen = strlen(fbuf);\n\t\tif (relative_paths) {\n\t\t\t/* We clean up fbuf below. */\n\t\t\tname_type = NORMAL_NAME;\n\t\t} else if (!len || fbuf[len - 1] == '/') {\n\t\t\tif (len == 2 && fbuf[0] == '.') {\n\t\t\t\t/* Turn \"./\" into just \".\" rather than \"./.\" */\n\t\t\t\tfbuf[--len] = '\\0';\n\t\t\t} else {\n\t\t\t\tif (len + 1 >= MAXPATHLEN)\n\t\t\t\t\toverflow_exit(\"send_file_list\");\n\t\t\t\tfbuf[len++] = '.';\n\t\t\t\tfbuf[len] = '\\0';\n\t\t\t}\n\t\t\tname_type = DOTDIR_NAME;\n\t\t} else if (len > 1 && fbuf[len-1] == '.' && fbuf[len-2] == '.'\n\t\t    && (len == 2 || fbuf[len-3] == '/')) {\n\t\t\tif (len + 2 >= MAXPATHLEN)\n\t\t\t\toverflow_exit(\"send_file_list\");\n\t\t\tfbuf[len++] = '/';\n\t\t\tfbuf[len++] = '.';\n\t\t\tfbuf[len] = '\\0';\n\t\t\tname_type = DOTDIR_NAME;\n\t\t} else if (fbuf[len-1] == '.' && (len == 1 || fbuf[len-2] == '/'))\n\t\t\tname_type = DOTDIR_NAME;\n\t\telse\n\t\t\tname_type = NORMAL_NAME;\n\n\t\tdir = NULL;\n\n\t\tif (!relative_paths) {\n\t\t\tp = strrchr(fbuf, '/');\n\t\t\tif (p) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tif (p == fbuf)\n\t\t\t\t\tdir = \"/\";\n\t\t\t\telse\n\t\t\t\t\tdir = fbuf;\n\t\t\t\tlen -= p - fbuf + 1;\n\t\t\t\tfn = p + 1;\n\t\t\t} else\n\t\t\t\tfn = fbuf;\n\t\t} else {\n\t\t\tif ((p = strstr(fbuf, \"/./\")) != NULL) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tif (p == fbuf)\n\t\t\t\t\tdir = \"/\";\n\t\t\t\telse {\n\t\t\t\t\tdir = fbuf;\n\t\t\t\t\tclean_fname(dir, 0);\n\t\t\t\t}\n\t\t\t\tfn = p + 3;\n\t\t\t\twhile (*fn == '/')\n\t\t\t\t\tfn++;\n\t\t\t\tif (!*fn)\n\t\t\t\t\t*--fn = '\\0'; /* ensure room for '.' */\n\t\t\t} else\n\t\t\t\tfn = fbuf;\n\t\t\t/* A leading ./ can be used in relative mode to affect\n\t\t\t * the dest dir without its name being in the path. */\n\t\t\tif (*fn == '.' && fn[1] == '/' && fn[2] && !implied_dot_dir)\n\t\t\t\timplied_dot_dir = -1;\n\t\t\tlen = clean_fname(fn, CFN_KEEP_TRAILING_SLASH\n\t\t\t\t\t    | CFN_DROP_TRAILING_DOT_DIR);\n\t\t\tif (len == 1) {\n\t\t\t\tif (fn[0] == '/') {\n\t\t\t\t\tfn = \"/.\";\n\t\t\t\t\tlen = 2;\n\t\t\t\t\tname_type = DOTDIR_NAME;\n\t\t\t\t} else if (fn[0] == '.')\n\t\t\t\t\tname_type = DOTDIR_NAME;\n\t\t\t} else if (fn[len-1] == '/') {\n\t\t\t\tfn[--len] = '\\0';\n\t\t\t\tif (len == 1 && *fn == '.')\n\t\t\t\t\tname_type = DOTDIR_NAME;\n\t\t\t\telse\n\t\t\t\t\tname_type = SLASH_ENDING_NAME;\n\t\t\t}\n\t\t\t/* Reject a \"..\" dir in the active part of the path. */\n\t\t\tfor (p = fn; (p = strstr(p, \"..\")) != NULL; p += 2) {\n\t\t\t\tif ((p[2] == '/' || p[2] == '\\0')\n\t\t\t\t && (p == fn || p[-1] == '/')) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t    \"found \\\"..\\\" dir in relative path: %s\\n\",\n\t\t\t\t\t    fn);\n\t\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!*fn) {\n\t\t\tlen = 1;\n\t\t\tfn = \".\";\n\t\t\tname_type = DOTDIR_NAME;\n\t\t}\n\n\t\tdirlen = dir ? strlen(dir) : 0;\n\t\tif (dirlen != lastdir_len || (dirlen && memcmp(lastdir, dir, dirlen) != 0)) {\n\t\t\tif (!change_pathname(NULL, dir, -dirlen))\n\t\t\t\tgoto bad_path;\n\t\t\tlastdir = pathname;\n\t\t\tlastdir_len = pathname_len;\n\t\t} else if (!change_pathname(NULL, lastdir, lastdir_len)) {\n\t\t    bad_path:\n\t\t\tif (implied_dot_dir < 0)\n\t\t\t\timplied_dot_dir = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (implied_dot_dir < 0) {\n\t\t\timplied_dot_dir = 1;\n\t\t\tsend_file_name(f, flist, \".\", NULL, (flags | FLAG_IMPLIED_DIR) & ~FLAG_CONTENT_DIR, ALL_FILTERS);\n\t\t}\n\n\t\tif (fn != fbuf)\n\t\t\tmemmove(fbuf, fn, len + 1);\n\n\t\tif (link_stat(fbuf, &st, copy_dirlinks || name_type != NORMAL_NAME) != 0\n\t\t || (name_type != DOTDIR_NAME && is_excluded(fbuf, S_ISDIR(st.st_mode) != 0, SERVER_FILTERS))\n\t\t || (relative_paths && path_is_daemon_excluded(fbuf, 1))) {\n\t\t\tif (errno != ENOENT || missing_args == 0) {\n\t\t\t\t/* This is a transfer error, but inhibit deletion\n\t\t\t\t * only if we might be omitting an existing file. */\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\trsyserr(FERROR_XFER, errno, \"link_stat %s failed\",\n\t\t\t\t\tfull_fname(fbuf));\n\t\t\t\tcontinue;\n\t\t\t} else if (missing_args == 1) {\n\t\t\t\t/* Just ignore the arg. */\n\t\t\t\tcontinue;\n\t\t\t} else /* (missing_args == 2) */ {\n\t\t\t\t/* Send the arg as a \"missing\" entry with\n\t\t\t\t * mode 0, which tells the generator to delete it. */\n\t\t\t\tmemset(&st, 0, sizeof st);\n\t\t\t}\n\t\t}\n\n\t\t/* A dot-dir should not be excluded! */\n\t\tif (name_type != DOTDIR_NAME && st.st_mode != 0\n\t\t && is_excluded(fbuf, S_ISDIR(st.st_mode) != 0, ALL_FILTERS))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(st.st_mode) && !xfer_dirs) {\n\t\t\trprintf(FINFO, \"skipping directory %s\\n\", fbuf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (inc_recurse && relative_paths && *fbuf) {\n\t\t\tif ((p = strchr(fbuf+1, '/')) != NULL) {\n\t\t\t\tif (p - fbuf == 1 && *fbuf == '.') {\n\t\t\t\t\tif ((fn = strchr(p+1, '/')) != NULL)\n\t\t\t\t\t\tp = fn;\n\t\t\t\t} else\n\t\t\t\t\tfn = p;\n\t\t\t\tsend_implied_dirs(f, flist, fbuf, fbuf, p, flags,\n\t\t\t\t\t\t  IS_MISSING_FILE(st) ? MISSING_NAME : name_type);\n\t\t\t\tif (fn == p)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (implied_dirs && (p=strrchr(fbuf,'/')) && p != fbuf) {\n\t\t\t/* Send the implied directories at the start of the\n\t\t\t * source spec, so we get their permissions right. */\n\t\t\tsend_implied_dirs(f, flist, fbuf, fbuf, p, flags, 0);\n\t\t}\n\n\t\tif (one_file_system)\n\t\t\tfilesystem_dev = st.st_dev;\n\n\t\tif (recurse || (xfer_dirs && name_type != NORMAL_NAME)) {\n\t\t\tstruct file_struct *file;\n\t\t\tfile = send_file_name(f, flist, fbuf, &st,\n\t\t\t\t\t      FLAG_TOP_DIR | FLAG_CONTENT_DIR | flags,\n\t\t\t\t\t      NO_FILTERS);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\tif (inc_recurse) {\n\t\t\t\tif (name_type == DOTDIR_NAME) {\n\t\t\t\t\tif (send_dir_depth < 0) {\n\t\t\t\t\t\tsend_dir_depth = 0;\n\t\t\t\t\t\tchange_local_filter_dir(fbuf, len, send_dir_depth);\n\t\t\t\t\t}\n\t\t\t\t\tsend_directory(f, flist, fbuf, len, flags);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tsend_if_directory(f, flist, file, fbuf, len, flags);\n\t\t} else\n\t\t\tsend_file_name(f, flist, fbuf, &st, flags, NO_FILTERS);\n\t}\n\n\tif (reenable_multiplex >= 0)\n\t\tio_start_multiplex_in(reenable_multiplex);\n\n\tgettimeofday(&end_tv, NULL);\n\tstats.flist_buildtime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000\n\t\t\t      + (end_tv.tv_usec - start_tv.tv_usec) / 1000;\n\tif (stats.flist_buildtime == 0)\n\t\tstats.flist_buildtime = 1;\n\tstart_tv = end_tv;\n\n\t/* Indicate end of file list */\n\tif (io_error == 0 || ignore_errors)\n\t\twrite_end_of_flist(f, 0);\n\telse if (use_safe_inc_flist)\n\t\twrite_end_of_flist(f, 1);\n\telse {\n\t\tif (delete_during && inc_recurse)\n\t\t\tfatal_unsafe_io_error();\n\t\twrite_end_of_flist(f, 0);\n\t}\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && protocol_version >= 30 && !inc_recurse)\n\t\tidev_destroy();\n#endif\n\n\tif (show_filelist_progress)\n\t\tfinish_filelist_progress(flist);\n\n\tgettimeofday(&end_tv, NULL);\n\tstats.flist_xfertime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000\n\t\t\t     + (end_tv.tv_usec - start_tv.tv_usec) / 1000;\n\n\t/* When converting names, both sides keep an unsorted file-list array\n\t * because the names will differ on the sending and receiving sides\n\t * (both sides will use the unsorted index number for each item). */\n\n\t/* Sort the list without removing any duplicates.  This allows the\n\t * receiving side to ask for whatever name it kept.  For incremental\n\t * recursion mode, the sender marks duplicate dirs so that it can\n\t * send them together in a single file-list. */\n\tif (need_unsorted_flist) {\n\t\tflist->sorted = new_array(struct file_struct *, flist->used);\n\t\tmemcpy(flist->sorted, flist->files, flist->used * PTR_SIZE);\n\t} else\n\t\tflist->sorted = flist->files;\n\tflist_sort_and_clean(flist, 0);\n\tfile_total += flist->used;\n\tfile_old_total += flist->used;\n\n\tif (numeric_ids <= 0 && !inc_recurse)\n\t\tsend_id_lists(f);\n\n\t/* send the io_error flag */\n\tif (protocol_version < 30)\n\t\twrite_int(f, ignore_errors ? 0 : io_error);\n\telse if (!use_safe_inc_flist && io_error && !ignore_errors)\n\t\tsend_msg_int(MSG_IO_ERROR, io_error);\n\n\tif (disable_buffering)\n\t\tio_end_buffering_out(IOBUF_FREE_BUFS);\n\n\tstats.flist_size = stats.total_written - start_write;\n\tstats.num_files = flist->used;\n\n\tif (DEBUG_GTE(FLIST, 3))\n\t\toutput_flist(flist);\n\n\tif (DEBUG_GTE(FLIST, 2))\n\t\trprintf(FINFO, \"send_file_list done\\n\");\n\n\tif (inc_recurse) {\n\t\tsend_dir_depth = 1;\n\t\tadd_dirs_to_tree(-1, flist, stats.num_dirs);\n\t\tif (!file_total || strcmp(flist->sorted[flist->low]->basename, \".\") != 0)\n\t\t\tflist->parent_ndx = -1;\n\t\tflist_done_allocating(flist);\n\t\tif (send_dir_ndx < 0) {\n\t\t\twrite_ndx(f, NDX_FLIST_EOF);\n\t\t\tflist_eof = 1;\n\t\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t\t}\n\t\telse if (file_total == 1) {\n\t\t\t/* If we're creating incremental file-lists and there\n\t\t\t * was just 1 item in the first file-list, send 1 more\n\t\t\t * file-list to check if this is a 1-file xfer. */\n\t\t\tsend_extra_file_list(f, 1);\n\t\t}\n\t} else {\n\t\tflist_eof = 1;\n\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t}\n\n\treturn flist;\n}\n\nstruct file_list *recv_file_list(int f, int dir_ndx)\n{\n\tconst char *good_dirname = NULL;\n\tstruct file_list *flist;\n\tint dstart, flags;\n\tint64 start_read;\n\n\tif (!first_flist) {\n\t\tif (show_filelist_progress)\n\t\t\tstart_filelist_progress(\"receiving file list\");\n\t\telse if (inc_recurse && INFO_GTE(FLIST, 1) && !am_server)\n\t\t\trprintf(FCLIENT, \"receiving incremental file list\\n\");\n\t\trprintf(FLOG, \"receiving file list\\n\");\n\t\tif (usermap)\n\t\t\tparse_name_map(usermap, True);\n\t\tif (groupmap)\n\t\t\tparse_name_map(groupmap, False);\n\t}\n\n\tstart_read = stats.total_read;\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && !first_flist)\n\t\tinit_hard_links();\n#endif\n\n\tflist = flist_new(0, \"recv_file_list\");\n\tflist_expand(flist, FLIST_START_LARGE);\n\n\tif (inc_recurse) {\n\t\tif (flist->ndx_start == 1) {\n\t\t\tdir_flist = flist_new(FLIST_TEMP, \"recv_file_list\");\n\t\t\tflist_expand(dir_flist, FLIST_START_LARGE);\n\t\t}\n\t\tdstart = dir_flist->used;\n\t} else {\n\t\tdir_flist = flist;\n\t\tdstart = 0;\n\t}\n\n\twhile (1) {\n\t\tstruct file_struct *file;\n\n\t\tif (xfer_flags_as_varint) {\n\t\t\tif ((flags = read_varint(f)) == 0) {\n\t\t\t\tint err = read_varint(f);\n\t\t\t\tif (!ignore_errors)\n\t\t\t\t\tio_error |= err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((flags = read_byte(f)) == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))\n\t\t\t\tflags |= read_byte(f) << 8;\n\n\t\t\tif (flags == (XMIT_EXTENDED_FLAGS|XMIT_IO_ERROR_ENDLIST)) {\n\t\t\t\tint err;\n\t\t\t\tif (!use_safe_inc_flist) {\n\t\t\t\t\trprintf(FERROR, \"Invalid flist flag: %x\\n\", flags);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t}\n\t\t\t\terr = read_varint(f);\n\t\t\t\tif (!ignore_errors)\n\t\t\t\t\tio_error |= err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tflist_expand(flist, 1);\n\t\tfile = recv_file_entry(f, flist, flags);\n\n\t\tif (inc_recurse) {\n\t\t\tstatic const char empty_dir[] = \"\\0\";\n\t\t\tconst char *cur_dir = file->dirname ? file->dirname : empty_dir;\n\t\t\tif (relative_paths && *cur_dir == '/')\n\t\t\t\tcur_dir++;\n\t\t\tif (cur_dir != good_dirname) {\n\t\t\t\tconst char *d = dir_ndx >= 0 ? f_name(dir_flist->files[dir_ndx], NULL) : empty_dir;\n\t\t\t\tif (strcmp(cur_dir, d) != 0) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"ABORTING due to invalid path from sender: %s/%s\\n\",\n\t\t\t\t\t\tcur_dir, file->basename);\n\t\t\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t\t\t}\n\t\t\t\tgood_dirname = cur_dir;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISREG(file->mode)) {\n\t\t\t/* Already counted */\n\t\t} else if (S_ISDIR(file->mode)) {\n\t\t\tif (inc_recurse) {\n\t\t\t\tflist_expand(dir_flist, 1);\n\t\t\t\tdir_flist->files[dir_flist->used++] = file;\n\t\t\t}\n\t\t\tstats.num_dirs++;\n\t\t} else if (S_ISLNK(file->mode))\n\t\t\tstats.num_symlinks++;\n\t\telse if (IS_DEVICE(file->mode))\n\t\t\tstats.num_devices++;\n\t\telse\n\t\t\tstats.num_specials++;\n\n\t\tflist->files[flist->used++] = file;\n\n\t\tmaybe_emit_filelist_progress(flist->used);\n\n\t\tif (DEBUG_GTE(FLIST, 2)) {\n\t\t\tchar *name = f_name(file, NULL);\n\t\t\trprintf(FINFO, \"recv_file_name(%s)\\n\", NS(name));\n\t\t}\n\t}\n\tfile_total += flist->used;\n\n\tif (DEBUG_GTE(FLIST, 2))\n\t\trprintf(FINFO, \"received %d names\\n\", flist->used);\n\n\tif (show_filelist_progress)\n\t\tfinish_filelist_progress(flist);\n\n\tif (need_unsorted_flist) {\n\t\t/* Create an extra array of index pointers that we can sort for\n\t\t * the generator's use (for wading through the files in sorted\n\t\t * order and for calling flist_find()).  We keep the \"files\"\n\t\t * list unsorted for our exchange of index numbers with the\n\t\t * other side (since their names may not sort the same). */\n\t\tflist->sorted = new_array(struct file_struct *, flist->used);\n\t\tmemcpy(flist->sorted, flist->files, flist->used * PTR_SIZE);\n\t\tif (inc_recurse && dir_flist->used > dstart) {\n\t\t\tstatic int dir_flist_malloced = 0;\n\t\t\tif (dir_flist_malloced < dir_flist->malloced) {\n\t\t\t\tdir_flist->sorted = realloc_array(dir_flist->sorted,\n\t\t\t\t\t\t\tstruct file_struct *,\n\t\t\t\t\t\t\tdir_flist->malloced);\n\t\t\t\tdir_flist_malloced = dir_flist->malloced;\n\t\t\t}\n\t\t\tmemcpy(dir_flist->sorted + dstart, dir_flist->files + dstart,\n\t\t\t       (dir_flist->used - dstart) * PTR_SIZE);\n\t\t\tfsort(dir_flist->sorted + dstart, dir_flist->used - dstart);\n\t\t}\n\t} else {\n\t\tflist->sorted = flist->files;\n\t\tif (inc_recurse && dir_flist->used > dstart) {\n\t\t\tdir_flist->sorted = dir_flist->files;\n\t\t\tfsort(dir_flist->sorted + dstart, dir_flist->used - dstart);\n\t\t}\n\t}\n\n\tif (inc_recurse)\n\t\tflist_done_allocating(flist);\n\telse if (f >= 0) {\n\t\trecv_id_list(f, flist);\n\t\tflist_eof = 1;\n\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t}\n\n\t/* The --relative option sends paths with a leading slash, so we need\n\t * to specify the strip_root option here.  We rejected leading slashes\n\t * for a non-relative transfer in recv_file_entry(). */\n\tflist_sort_and_clean(flist, relative_paths);\n\n\tif (protocol_version < 30) {\n\t\t/* Recv the io_error flag */\n\t\tint err = read_int(f);\n\t\tif (!ignore_errors)\n\t\t\tio_error |= err;\n\t} else if (inc_recurse && flist->ndx_start == 1) {\n\t\tif (!file_total || strcmp(flist->sorted[flist->low]->basename, \".\") != 0)\n\t\t\tflist->parent_ndx = -1;\n\t}\n\n\tif (DEBUG_GTE(FLIST, 3))\n\t\toutput_flist(flist);\n\n\tif (DEBUG_GTE(FLIST, 2))\n\t\trprintf(FINFO, \"recv_file_list done\\n\");\n\n\tstats.flist_size += stats.total_read - start_read;\n\tstats.num_files += flist->used;\n\n\treturn flist;\n}\n\n/* This is only used once by the receiver if the very first file-list\n * has exactly one item in it. */\nvoid recv_additional_file_list(int f)\n{\n\tstruct file_list *flist;\n\tint ndx = read_ndx(f);\n\tif (ndx == NDX_FLIST_EOF) {\n\t\tflist_eof = 1;\n\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t\tchange_local_filter_dir(NULL, 0, 0);\n\t} else {\n\t\tndx = NDX_FLIST_OFFSET - ndx;\n\t\tif (ndx < 0 || ndx >= dir_flist->used) {\n\t\t\tndx = NDX_FLIST_OFFSET - ndx;\n\t\t\trprintf(FERROR,\n\t\t\t\t\"[%s] Invalid dir index: %d (%d - %d)\\n\",\n\t\t\t\twho_am_i(), ndx, NDX_FLIST_OFFSET,\n\t\t\t\tNDX_FLIST_OFFSET - dir_flist->used + 1);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (DEBUG_GTE(FLIST, 3)) {\n\t\t\trprintf(FINFO, \"[%s] receiving flist for dir %d\\n\",\n\t\t\t\twho_am_i(), ndx);\n\t\t}\n\t\tflist = recv_file_list(f, ndx);\n\t\tflist->parent_ndx = ndx;\n\t}\n}\n\n/* Search for an identically-named item in the file list.  Note that the\n * items must agree in their directory-ness, or no match is returned. */\nint flist_find(struct file_list *flist, struct file_struct *f)\n{\n\tint low = flist->low, high = flist->high;\n\tint diff, mid, mid_up;\n\n\twhile (low <= high) {\n\t\tmid = (low + high) / 2;\n\t\tif (F_IS_ACTIVE(flist->sorted[mid]))\n\t\t\tmid_up = mid;\n\t\telse {\n\t\t\t/* Scan for the next non-empty entry using the cached\n\t\t\t * distance values.  If the value isn't fully up-to-\n\t\t\t * date, update it. */\n\t\t\tmid_up = mid + F_DEPTH(flist->sorted[mid]);\n\t\t\tif (!F_IS_ACTIVE(flist->sorted[mid_up])) {\n\t\t\t\tdo {\n\t\t\t\t    mid_up += F_DEPTH(flist->sorted[mid_up]);\n\t\t\t\t} while (!F_IS_ACTIVE(flist->sorted[mid_up]));\n\t\t\t\tF_DEPTH(flist->sorted[mid]) = mid_up - mid;\n\t\t\t}\n\t\t\tif (mid_up > high) {\n\t\t\t\t/* If there's nothing left above us, set high to\n\t\t\t\t * a non-empty entry below us and continue. */\n\t\t\t\thigh = mid - (int)flist->sorted[mid]->len32;\n\t\t\t\tif (!F_IS_ACTIVE(flist->sorted[high])) {\n\t\t\t\t\tdo {\n\t\t\t\t\t    high -= (int)flist->sorted[high]->len32;\n\t\t\t\t\t} while (!F_IS_ACTIVE(flist->sorted[high]));\n\t\t\t\t\tflist->sorted[mid]->len32 = mid - high;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdiff = f_name_cmp(flist->sorted[mid_up], f);\n\t\tif (diff == 0) {\n\t\t\tif (protocol_version < 29\n\t\t\t    && S_ISDIR(flist->sorted[mid_up]->mode)\n\t\t\t    != S_ISDIR(f->mode))\n\t\t\t\treturn -1;\n\t\t\treturn mid_up;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tlow = mid_up + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn -1;\n}\n\n/* Search for a name in the file list.  You must specify want_dir_match as:\n * 1=match directories, 0=match non-directories, or -1=match either. */\nint flist_find_name(struct file_list *flist, const char *fname, int want_dir_match)\n{\n\tstatic struct file_struct *f;\n\tchar fbuf[MAXPATHLEN];\n\tconst char *slash = strrchr(fname, '/');\n\tconst char *basename = slash ? slash+1 : fname;\n\n\tif (!f)\n\t\tf = (struct file_struct*)new_array(char, FILE_STRUCT_LEN + MAXPATHLEN + 1);\n\n\tmemset(f, 0, FILE_STRUCT_LEN);\n\tmemcpy((void*)f->basename, basename, strlen(basename)+1);\n\n\tif (slash) {\n\t\tstrlcpy(fbuf, fname, slash - fname + 1);\n\t\tf->dirname = fbuf;\n\t} else\n\t\tf->dirname = NULL;\n\n\tf->mode = want_dir_match > 0 ? S_IFDIR : S_IFREG;\n\n\tif (want_dir_match < 0)\n\t\treturn flist_find_ignore_dirness(flist, f);\n\treturn flist_find(flist, f);\n}\n\n/* Search for an identically-named item in the file list.  Differs from\n * flist_find in that an item that agrees with \"f\" in directory-ness is\n * preferred but one that does not is still found. */\nint flist_find_ignore_dirness(struct file_list *flist, struct file_struct *f)\n{\n\tmode_t save_mode;\n\tint ndx;\n\n\t/* First look for an item that agrees in directory-ness. */\n\tndx = flist_find(flist, f);\n\tif (ndx >= 0)\n\t\treturn ndx;\n\n\t/* Temporarily flip f->mode to look for an item of opposite\n\t * directory-ness. */\n\tsave_mode = f->mode;\n\tf->mode = S_ISDIR(f->mode) ? S_IFREG : S_IFDIR;\n\tndx = flist_find(flist, f);\n\tf->mode = save_mode;\n\treturn ndx;\n}\n\n/*\n * Free up any resources a file_struct has allocated\n * and clear the file.\n */\nvoid clear_file(struct file_struct *file)\n{\n\t/* The +1 zeros out the first char of the basename. */\n\tmemset(file, 0, FILE_STRUCT_LEN + 1);\n\t/* In an empty entry, F_DEPTH() is an offset to the next non-empty\n\t * entry.  Likewise for len32 in the opposite direction.  We assume\n\t * that we're alone for now since flist_find() will adjust the counts\n\t * it runs into that aren't up-to-date. */\n\tfile->len32 = F_DEPTH(file) = 1;\n}\n\n/* Allocate a new file list. */\nstatic struct file_list *flist_new(int flags, const char *msg)\n{\n\tstruct file_list *flist;\n\n\tflist = new0(struct file_list);\n\n\tif (flags & FLIST_TEMP) {\n\t\tif (!(flist->file_pool = pool_create(SMALL_EXTENT, 0, _out_of_memory, POOL_INTERN)))\n\t\t\tout_of_memory(msg);\n\t} else {\n\t\t/* This is a doubly linked list with prev looping back to\n\t\t * the end of the list, but the last next pointer is NULL. */\n\t\tif (!first_flist) {\n\t\t\tif (!(flist->file_pool = pool_create(NORMAL_EXTENT, 0, _out_of_memory, POOL_INTERN)))\n\t\t\t\tout_of_memory(msg);\n\n\t\t\tflist->ndx_start = flist->flist_num = inc_recurse ? 1 : 0;\n\n\t\t\tfirst_flist = cur_flist = flist->prev = flist;\n\t\t} else {\n\t\t\tstruct file_list *prev = first_flist->prev;\n\n\t\t\tflist->file_pool = first_flist->file_pool;\n\n\t\t\tflist->ndx_start = prev->ndx_start + prev->used + 1;\n\t\t\tflist->flist_num = prev->flist_num + 1;\n\n\t\t\tflist->prev = prev;\n\t\t\tprev->next = first_flist->prev = flist;\n\t\t}\n\t\tflist->pool_boundary = pool_boundary(flist->file_pool, 0);\n\t\tflist_cnt++;\n\t}\n\n\treturn flist;\n}\n\n/* Free up all elements in a flist. */\nvoid flist_free(struct file_list *flist)\n{\n\tif (!flist->prev) {\n\t\t/* Was FLIST_TEMP dir-list. */\n\t} else if (flist == flist->prev) {\n\t\tfirst_flist = cur_flist = NULL;\n\t\tfile_total = 0;\n\t\tflist_cnt = 0;\n\t} else {\n\t\tif (flist == cur_flist)\n\t\t\tcur_flist = flist->next;\n\t\tif (flist == first_flist)\n\t\t\tfirst_flist = first_flist->next;\n\t\telse {\n\t\t\tflist->prev->next = flist->next;\n\t\t\tif (!flist->next)\n\t\t\t\tflist->next = first_flist;\n\t\t}\n\t\tflist->next->prev = flist->prev;\n\t\tfile_total -= flist->used;\n\t\tflist_cnt--;\n\t}\n\n\tif (!flist->prev || !flist_cnt)\n\t\tpool_destroy(flist->file_pool);\n\telse\n\t\tpool_free_old(flist->file_pool, flist->pool_boundary);\n\n\tif (flist->sorted && flist->sorted != flist->files)\n\t\tfree(flist->sorted);\n\tfree(flist->files);\n\tfree(flist);\n}\n\n/* This routine ensures we don't have any duplicate names in our file list.\n * duplicate names can cause corruption because of the pipelining. */\nstatic void flist_sort_and_clean(struct file_list *flist, int strip_root)\n{\n\tchar fbuf[MAXPATHLEN];\n\tint i, prev_i;\n\n\tif (!flist)\n\t\treturn;\n\tif (flist->used == 0) {\n\t\tflist->high = -1;\n\t\tflist->low = 0;\n\t\treturn;\n\t}\n\n\tfsort(flist->sorted, flist->used);\n\n\tif (!am_sender || inc_recurse) {\n\t\tfor (i = prev_i = 0; i < flist->used; i++) {\n\t\t\tif (F_IS_ACTIVE(flist->sorted[i])) {\n\t\t\t\tprev_i = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tflist->low = prev_i;\n\t} else {\n\t\ti = prev_i = flist->used - 1;\n\t\tflist->low = 0;\n\t}\n\n\twhile (++i < flist->used) {\n\t\tint j;\n\t\tstruct file_struct *file = flist->sorted[i];\n\n\t\tif (!F_IS_ACTIVE(file))\n\t\t\tcontinue;\n\t\tif (f_name_cmp(file, flist->sorted[prev_i]) == 0)\n\t\t\tj = prev_i;\n\t\telse if (protocol_version >= 29 && S_ISDIR(file->mode)) {\n\t\t\tint save_mode = file->mode;\n\t\t\t/* Make sure that this directory doesn't duplicate a\n\t\t\t * non-directory earlier in the list. */\n\t\t\tflist->high = prev_i;\n\t\t\tfile->mode = S_IFREG;\n\t\t\tj = flist_find(flist, file);\n\t\t\tfile->mode = save_mode;\n\t\t} else\n\t\t\tj = -1;\n\t\tif (j >= 0) {\n\t\t\tint keep, drop;\n\t\t\t/* If one is a dir and the other is not, we want to\n\t\t\t * keep the dir because it might have contents in the\n\t\t\t * list.  Otherwise keep the first one. */\n\t\t\tif (S_ISDIR(file->mode)) {\n\t\t\t\tstruct file_struct *fp = flist->sorted[j];\n\t\t\t\tif (!S_ISDIR(fp->mode))\n\t\t\t\t\tkeep = i, drop = j;\n\t\t\t\telse {\n\t\t\t\t\tif (am_sender)\n\t\t\t\t\t\tfile->flags |= FLAG_DUPLICATE;\n\t\t\t\t\telse { /* Make sure we merge our vital flags. */\n\t\t\t\t\t\tfp->flags |= file->flags & (FLAG_TOP_DIR|FLAG_CONTENT_DIR);\n\t\t\t\t\t\tfp->flags &= file->flags | ~FLAG_IMPLIED_DIR;\n\t\t\t\t\t}\n\t\t\t\t\tkeep = j, drop = i;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tkeep = j, drop = i;\n\n\t\t\tif (!am_sender) {\n\t\t\t\tif (DEBUG_GTE(DUP, 1)) {\n\t\t\t\t\trprintf(FINFO,\n\t\t\t\t\t    \"removing duplicate name %s from file list (%d)\\n\",\n\t\t\t\t\t    f_name(file, fbuf), drop + flist->ndx_start);\n\t\t\t\t}\n\t\t\t\tclear_file(flist->sorted[drop]);\n\t\t\t}\n\n\t\t\tif (keep == i) {\n\t\t\t\tif (flist->low == drop) {\n\t\t\t\t\tfor (j = drop + 1;\n\t\t\t\t\t     j < i && !F_IS_ACTIVE(flist->sorted[j]);\n\t\t\t\t\t     j++) {}\n\t\t\t\t\tflist->low = j;\n\t\t\t\t}\n\t\t\t\tprev_i = i;\n\t\t\t}\n\t\t} else\n\t\t\tprev_i = i;\n\t}\n\tflist->high = prev_i;\n\n\tif (strip_root) {\n\t\t/* We need to strip off the leading slashes for relative\n\t\t * paths, but this must be done _after_ the sorting phase. */\n\t\tfor (i = flist->low; i <= flist->high; i++) {\n\t\t\tstruct file_struct *file = flist->sorted[i];\n\n\t\t\tif (!file->dirname)\n\t\t\t\tcontinue;\n\t\t\twhile (*file->dirname == '/')\n\t\t\t\tfile->dirname++;\n\t\t\tif (!*file->dirname)\n\t\t\t\tfile->dirname = NULL;\n\t\t}\n\t}\n\n\tif (prune_empty_dirs && !am_sender) {\n\t\tint j, prev_depth = 0;\n\n\t\tprev_i = 0; /* It's OK that this isn't really true. */\n\n\t\tfor (i = flist->low; i <= flist->high; i++) {\n\t\t\tstruct file_struct *fp, *file = flist->sorted[i];\n\n\t\t\t/* This temporarily abuses the F_DEPTH() value for a\n\t\t\t * directory that is in a chain that might get pruned.\n\t\t\t * We restore the old value if it gets a reprieve. */\n\t\t\tif (S_ISDIR(file->mode) && F_DEPTH(file)) {\n\t\t\t\t/* Dump empty dirs when coming back down. */\n\t\t\t\tfor (j = prev_depth; j >= F_DEPTH(file); j--) {\n\t\t\t\t\tfp = flist->sorted[prev_i];\n\t\t\t\t\tif (F_DEPTH(fp) >= 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev_i = -F_DEPTH(fp)-1;\n\t\t\t\t\tclear_file(fp);\n\t\t\t\t}\n\t\t\t\tprev_depth = F_DEPTH(file);\n\t\t\t\tif (is_excluded(f_name(file, fbuf), 1, ALL_FILTERS)) {\n\t\t\t\t\t/* Keep dirs through this dir. */\n\t\t\t\t\tfor (j = prev_depth-1; ; j--) {\n\t\t\t\t\t\tfp = flist->sorted[prev_i];\n\t\t\t\t\t\tif (F_DEPTH(fp) >= 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tprev_i = -F_DEPTH(fp)-1;\n\t\t\t\t\t\tF_DEPTH(fp) = j;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tF_DEPTH(file) = -prev_i-1;\n\t\t\t\tprev_i = i;\n\t\t\t} else {\n\t\t\t\t/* Keep dirs through this non-dir. */\n\t\t\t\tfor (j = prev_depth; ; j--) {\n\t\t\t\t\tfp = flist->sorted[prev_i];\n\t\t\t\t\tif (F_DEPTH(fp) >= 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev_i = -F_DEPTH(fp)-1;\n\t\t\t\t\tF_DEPTH(fp) = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Dump all remaining empty dirs. */\n\t\twhile (1) {\n\t\t\tstruct file_struct *fp = flist->sorted[prev_i];\n\t\t\tif (F_DEPTH(fp) >= 0)\n\t\t\t\tbreak;\n\t\t\tprev_i = -F_DEPTH(fp)-1;\n\t\t\tclear_file(fp);\n\t\t}\n\n\t\tfor (i = flist->low; i <= flist->high; i++) {\n\t\t\tif (F_IS_ACTIVE(flist->sorted[i]))\n\t\t\t\tbreak;\n\t\t}\n\t\tflist->low = i;\n\t\tfor (i = flist->high; i >= flist->low; i--) {\n\t\t\tif (F_IS_ACTIVE(flist->sorted[i]))\n\t\t\t\tbreak;\n\t\t}\n\t\tflist->high = i;\n\t}\n}\n\nstatic void output_flist(struct file_list *flist)\n{\n\tchar uidbuf[16], gidbuf[16], depthbuf[16];\n\tstruct file_struct *file;\n\tconst char *root, *dir, *slash, *name, *trail;\n\tconst char *who = who_am_i();\n\tint i;\n\n\trprintf(FINFO, \"[%s] flist start=%d, used=%d, low=%d, high=%d\\n\",\n\t\twho, flist->ndx_start, flist->used, flist->low, flist->high);\n\tfor (i = 0; i < flist->used; i++) {\n\t\tfile = flist->files[i];\n\t\tif ((am_root || am_sender) && uid_ndx) {\n\t\t\tsnprintf(uidbuf, sizeof uidbuf, \" uid=%u\",\n\t\t\t\t F_OWNER(file));\n\t\t} else\n\t\t\t*uidbuf = '\\0';\n\t\tif (gid_ndx) {\n\t\t\tstatic char parens[] = \"(\\0)\\0\\0\\0\";\n\t\t\tchar *pp = parens + (file->flags & FLAG_SKIP_GROUP ? 0 : 3);\n\t\t\tsnprintf(gidbuf, sizeof gidbuf, \" gid=%s%u%s\",\n\t\t\t\t pp, F_GROUP(file), pp + 2);\n\t\t} else\n\t\t\t*gidbuf = '\\0';\n\t\tif (!am_sender)\n\t\t\tsnprintf(depthbuf, sizeof depthbuf, \"%d\", F_DEPTH(file));\n\t\tif (F_IS_ACTIVE(file)) {\n\t\t\troot = am_sender ? NS(F_PATHNAME(file)) : depthbuf;\n\t\t\tif ((dir = file->dirname) == NULL)\n\t\t\t\tdir = slash = \"\";\n\t\t\telse\n\t\t\t\tslash = \"/\";\n\t\t\tname = file->basename;\n\t\t\ttrail = S_ISDIR(file->mode) ? \"/\" : \"\";\n\t\t} else\n\t\t\troot = dir = slash = name = trail = \"\";\n\t\trprintf(FINFO,\n\t\t\t\"[%s] i=%d %s %s%s%s%s mode=0%o len=%s%s%s flags=%x\\n\",\n\t\t\twho, i + flist->ndx_start,\n\t\t\troot, dir, slash, name, trail,\n\t\t\t(int)file->mode, comma_num(F_LENGTH(file)),\n\t\t\tuidbuf, gidbuf, file->flags);\n\t}\n}\n\nenum fnc_state { s_DIR, s_SLASH, s_BASE, s_TRAILING };\nenum fnc_type { t_PATH, t_ITEM };\n\nstatic int found_prefix;\n\n/* Compare the names of two file_struct entities, similar to how strcmp()\n * would do if it were operating on the joined strings.\n *\n * Some differences beginning with protocol_version 29: (1) directory names\n * are compared with an assumed trailing slash so that they compare in a\n * way that would cause them to sort immediately prior to any content they\n * may have; (2) a directory of any name compares after a non-directory of\n * any name at the same depth; (3) a directory with name \".\" compares prior\n * to anything else.  These changes mean that a directory and a non-dir\n * with the same name will not compare as equal (protocol_version >= 29).\n *\n * The dirname component can be an empty string, but the basename component\n * cannot (and never is in the current codebase).  The basename component\n * may be NULL (for a removed item), in which case it is considered to be\n * after any existing item. */\nint f_name_cmp(const struct file_struct *f1, const struct file_struct *f2)\n{\n\tint dif;\n\tconst uchar *c1, *c2;\n\tenum fnc_state state1, state2;\n\tenum fnc_type type1, type2;\n\tenum fnc_type t_path = protocol_version >= 29 ? t_PATH : t_ITEM;\n\n\tif (!f1 || !F_IS_ACTIVE(f1)) {\n\t\tif (!f2 || !F_IS_ACTIVE(f2))\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tif (!f2 || !F_IS_ACTIVE(f2))\n\t\treturn 1;\n\n\tc1 = (uchar*)f1->dirname;\n\tc2 = (uchar*)f2->dirname;\n\tif (c1 == c2)\n\t\tc1 = c2 = NULL;\n\tif (!c1) {\n\t\ttype1 = S_ISDIR(f1->mode) ? t_path : t_ITEM;\n\t\tc1 = (const uchar*)f1->basename;\n\t\tif (type1 == t_PATH && *c1 == '.' && !c1[1]) {\n\t\t\ttype1 = t_ITEM;\n\t\t\tstate1 = s_TRAILING;\n\t\t\tc1 = (uchar*)\"\";\n\t\t} else\n\t\t\tstate1 = s_BASE;\n\t} else {\n\t\ttype1 = t_path;\n\t\tstate1 = s_DIR;\n\t}\n\tif (!c2) {\n\t\ttype2 = S_ISDIR(f2->mode) ? t_path : t_ITEM;\n\t\tc2 = (const uchar*)f2->basename;\n\t\tif (type2 == t_PATH && *c2 == '.' && !c2[1]) {\n\t\t\ttype2 = t_ITEM;\n\t\t\tstate2 = s_TRAILING;\n\t\t\tc2 = (uchar*)\"\";\n\t\t} else\n\t\t\tstate2 = s_BASE;\n\t} else {\n\t\ttype2 = t_path;\n\t\tstate2 = s_DIR;\n\t}\n\n\tif (type1 != type2)\n\t\treturn type1 == t_PATH ? 1 : -1;\n\n\tdo {\n\t\tif (!*c1) {\n\t\t\tswitch (state1) {\n\t\t\tcase s_DIR:\n\t\t\t\tstate1 = s_SLASH;\n\t\t\t\tc1 = (uchar*)\"/\";\n\t\t\t\tbreak;\n\t\t\tcase s_SLASH:\n\t\t\t\ttype1 = S_ISDIR(f1->mode) ? t_path : t_ITEM;\n\t\t\t\tc1 = (const uchar*)f1->basename;\n\t\t\t\tif (type1 == t_PATH && *c1 == '.' && !c1[1]) {\n\t\t\t\t\ttype1 = t_ITEM;\n\t\t\t\t\tstate1 = s_TRAILING;\n\t\t\t\t\tc1 = (uchar*)\"\";\n\t\t\t\t} else\n\t\t\t\t\tstate1 = s_BASE;\n\t\t\t\tbreak;\n\t\t\tcase s_BASE:\n\t\t\t\tstate1 = s_TRAILING;\n\t\t\t\tif (type1 == t_PATH) {\n\t\t\t\t\tc1 = (uchar*)\"/\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tcase s_TRAILING:\n\t\t\t\ttype1 = t_ITEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*c2 && type1 != type2)\n\t\t\t\treturn type1 == t_PATH ? 1 : -1;\n\t\t}\n\t\tif (!*c2) {\n\t\t\tswitch (state2) {\n\t\t\tcase s_DIR:\n\t\t\t\tstate2 = s_SLASH;\n\t\t\t\tc2 = (uchar*)\"/\";\n\t\t\t\tbreak;\n\t\t\tcase s_SLASH:\n\t\t\t\ttype2 = S_ISDIR(f2->mode) ? t_path : t_ITEM;\n\t\t\t\tc2 = (const uchar*)f2->basename;\n\t\t\t\tif (type2 == t_PATH && *c2 == '.' && !c2[1]) {\n\t\t\t\t\ttype2 = t_ITEM;\n\t\t\t\t\tstate2 = s_TRAILING;\n\t\t\t\t\tc2 = (uchar*)\"\";\n\t\t\t\t} else\n\t\t\t\t\tstate2 = s_BASE;\n\t\t\t\tbreak;\n\t\t\tcase s_BASE:\n\t\t\t\tstate2 = s_TRAILING;\n\t\t\t\tif (type2 == t_PATH) {\n\t\t\t\t\tc2 = (uchar*)\"/\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tcase s_TRAILING:\n\t\t\t\tfound_prefix = 1;\n\t\t\t\tif (!*c1)\n\t\t\t\t\treturn 0;\n\t\t\t\ttype2 = t_ITEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type1 != type2)\n\t\t\t\treturn type1 == t_PATH ? 1 : -1;\n\t\t}\n\t} while ((dif = (int)*c1++ - (int)*c2++) == 0);\n\n\treturn dif;\n}\n\n/* Returns 1 if f1's filename has all of f2's filename as a prefix.  This does\n * not match if f2's basename is not an exact match of a path element in f1.\n * E.g. /path/foo is not a prefix of /path/foobar/baz, but /path/foobar is. */\nint f_name_has_prefix(const struct file_struct *f1, const struct file_struct *f2)\n{\n\tfound_prefix = 0;\n\tf_name_cmp(f1, f2);\n\treturn found_prefix;\n}\n\nchar *f_name_buf(void)\n{\n\tstatic char names[5][MAXPATHLEN];\n\tstatic unsigned int n;\n\n\tn = (n + 1) % (sizeof names / sizeof names[0]);\n\n\treturn names[n];\n}\n\n/* Return a copy of the full filename of a flist entry, using the indicated\n * buffer or one of 5 static buffers if fbuf is NULL.  No size-checking is\n * done because we checked the size when creating the file_struct entry.\n */\nchar *f_name(const struct file_struct *f, char *fbuf)\n{\n\tif (!f || !F_IS_ACTIVE(f))\n\t\treturn NULL;\n\n\tif (!fbuf)\n\t\tfbuf = f_name_buf();\n\n\tif (f->dirname) {\n\t\tint len = strlen(f->dirname);\n\t\tmemcpy(fbuf, f->dirname, len);\n\t\tfbuf[len] = '/';\n\t\tstrlcpy(fbuf + len + 1, f->basename, MAXPATHLEN - (len + 1));\n\t} else\n\t\tstrlcpy(fbuf, f->basename, MAXPATHLEN);\n\n\treturn fbuf;\n}\n\n/* Do a non-recursive scan of the named directory, possibly ignoring all\n * exclude rules except for the daemon's.  If \"dlen\" is >=0, it is the length\n * of the dirname string, and also indicates that \"dirname\" is a MAXPATHLEN\n * buffer (the functions we call will append names onto the end, but the old\n * dir value will be restored on exit). */\nstruct file_list *get_dirlist(char *dirname, int dlen, int flags)\n{\n\tstruct file_list *dirlist;\n\tchar dirbuf[MAXPATHLEN];\n\tint save_recurse = recurse;\n\tint save_xfer_dirs = xfer_dirs;\n\tint save_prune_empty_dirs = prune_empty_dirs;\n\tint senddir_fd = flags & GDL_IGNORE_FILTER_RULES ? -2 : -1;\n\tint senddir_flags = FLAG_CONTENT_DIR;\n\n\tif (dlen < 0) {\n\t\tdlen = strlcpy(dirbuf, dirname, MAXPATHLEN);\n\t\tif (dlen >= MAXPATHLEN)\n\t\t\treturn NULL;\n\t\tdirname = dirbuf;\n\t}\n\n\tdirlist = flist_new(FLIST_TEMP, \"get_dirlist\");\n\n\tif (flags & GDL_PERHAPS_DIR)\n\t\tsenddir_flags |= FLAG_PERHAPS_DIR;\n\n\trecurse = 0;\n\txfer_dirs = 1;\n\tsend_directory(senddir_fd, dirlist, dirname, dlen, senddir_flags);\n\txfer_dirs = save_xfer_dirs;\n\trecurse = save_recurse;\n\tif (INFO_GTE(PROGRESS, 1))\n\t\tflist_count_offset += dirlist->used;\n\n\tprune_empty_dirs = 0;\n\tdirlist->sorted = dirlist->files;\n\tflist_sort_and_clean(dirlist, 0);\n\tprune_empty_dirs = save_prune_empty_dirs;\n\n\tif (DEBUG_GTE(FLIST, 3))\n\t\toutput_flist(dirlist);\n\n\treturn dirlist;\n}\n"
        },
        {
          "name": "generator.c",
          "type": "blob",
          "size": 66.6962890625,
          "content": "/*\n * Routines that are exclusive to the generator process.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n#include \"ifuncs.h\"\n\nextern int dry_run;\nextern int do_xfers;\nextern int stdout_format_has_i;\nextern int logfile_format_has_i;\nextern int am_root;\nextern int am_server;\nextern int am_daemon;\nextern int inc_recurse;\nextern int relative_paths;\nextern int implied_dirs;\nextern int keep_dirlinks;\nextern int write_devices;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int preserve_links;\nextern int preserve_devices;\nextern int preserve_specials;\nextern int preserve_hard_links;\nextern int preserve_executability;\nextern int preserve_perms;\nextern int preserve_mtimes;\nextern int omit_dir_times;\nextern int omit_link_times;\nextern int delete_mode;\nextern int delete_before;\nextern int delete_during;\nextern int delete_after;\nextern int missing_args;\nextern int msgdone_cnt;\nextern int ignore_errors;\nextern int remove_source_files;\nextern int delay_updates;\nextern int update_only;\nextern int human_readable;\nextern int ignore_existing;\nextern int ignore_non_existing;\nextern int want_xattr_optim;\nextern int modify_window;\nextern int inplace;\nextern int append_mode;\nextern int make_backups;\nextern int csum_length;\nextern int ignore_times;\nextern int size_only;\nextern OFF_T max_size;\nextern OFF_T min_size;\nextern int io_error;\nextern int flist_eof;\nextern int allowed_lull;\nextern int sock_f_out;\nextern int protocol_version;\nextern int file_total;\nextern int fuzzy_basis;\nextern int always_checksum;\nextern int flist_csum_len;\nextern char *partial_dir;\nextern int alt_dest_type;\nextern int whole_file;\nextern int list_only;\nextern int read_batch;\nextern int write_batch;\nextern int safe_symlinks;\nextern int32 block_size;\nextern int unsort_ndx;\nextern int max_delete;\nextern int force_delete;\nextern int one_file_system;\nextern int skipped_deletes;\nextern dev_t filesystem_dev;\nextern mode_t orig_umask;\nextern uid_t our_uid;\nextern char *tmpdir;\nextern char *basis_dir[MAX_BASIS_DIRS+1];\nextern struct file_list *cur_flist, *first_flist, *dir_flist;\nextern filter_rule_list filter_list, daemon_filter_list;\n\nint maybe_ATTRS_REPORT = 0;\nint maybe_ATTRS_ACCURATE_TIME = 0;\n\nstatic dev_t dev_zero;\nstatic int deldelay_size = 0, deldelay_cnt = 0;\nstatic char *deldelay_buf = NULL;\nstatic int deldelay_fd = -1;\nstatic int loopchk_limit;\nstatic int dir_tweaking;\nstatic int symlink_timeset_failed_flags;\nstatic int need_retouch_dir_times;\nstatic int need_retouch_dir_perms;\nstatic const char *solo_file = NULL;\n\n/* Forward declarations. */\n#ifdef SUPPORT_HARD_LINKS\nstatic void handle_skipped_hlink(struct file_struct *file, int itemizing,\n\t\t\t\t enum logcode code, int f_out);\n#endif\n\n#define EARLY_DELAY_DONE_MSG() (!delay_updates)\n#define EARLY_DELETE_DONE_MSG() (!(delete_during == 2 || delete_after))\n\nstatic int start_delete_delay_temp(void)\n{\n\tchar fnametmp[MAXPATHLEN];\n\tint save_dry_run = dry_run;\n\n\tdry_run = 0;\n\tif (!get_tmpname(fnametmp, \"deldelay\", False)\n\t || (deldelay_fd = do_mkstemp(fnametmp, 0600)) < 0) {\n\t\trprintf(FINFO, \"NOTE: Unable to create delete-delay temp file%s.\\n\",\n\t\t\tinc_recurse ? \"\" : \" -- switching to --delete-after\");\n\t\tdelete_during = 0;\n\t\tdelete_after = !inc_recurse;\n\t\tdry_run = save_dry_run;\n\t\treturn 0;\n\t}\n\tunlink(fnametmp);\n\tdry_run = save_dry_run;\n\treturn 1;\n}\n\nstatic int flush_delete_delay(void)\n{\n\tif (deldelay_fd < 0 && !start_delete_delay_temp())\n\t\treturn 0;\n\tif (write(deldelay_fd, deldelay_buf, deldelay_cnt) != deldelay_cnt) {\n\t\trsyserr(FERROR, errno, \"flush of delete-delay buffer\");\n\t\tdelete_during = 0;\n\t\tdelete_after = !inc_recurse;\n\t\tclose(deldelay_fd);\n\t\treturn 0;\n\t}\n\tdeldelay_cnt = 0;\n\treturn 1;\n}\n\nstatic int remember_delete(struct file_struct *file, const char *fname, int flags)\n{\n\tint len;\n\n\tif (deldelay_cnt == deldelay_size && !flush_delete_delay())\n\t\treturn 0;\n\n\tif (flags & DEL_NO_UID_WRITE)\n\t\tdeldelay_buf[deldelay_cnt++] = '!';\n\n\twhile (1) {\n\t\tlen = snprintf(deldelay_buf + deldelay_cnt, deldelay_size - deldelay_cnt,\n\t\t\t       \"%x %s%c\", (int)file->mode, fname, '\\0');\n\t\tif ((deldelay_cnt += len) <= deldelay_size)\n\t\t\tbreak;\n\t\tdeldelay_cnt -= len;\n\t\tif (!flush_delete_delay())\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int read_delay_line(char *buf, int *flags_p)\n{\n\tstatic int read_pos = 0;\n\tunsigned int mode;\n\tint j, len;\n\tchar *bp, *past_space;\n\n\twhile (1) {\n\t\tfor (j = read_pos; j < deldelay_cnt && deldelay_buf[j]; j++) {}\n\t\tif (j < deldelay_cnt)\n\t\t\tbreak;\n\t\tif (deldelay_fd < 0) {\n\t\t\tif (j > read_pos)\n\t\t\t\tgoto invalid_data;\n\t\t\treturn -1;\n\t\t}\n\t\tdeldelay_cnt -= read_pos;\n\t\tif (deldelay_cnt == deldelay_size)\n\t\t\tgoto invalid_data;\n\t\tif (deldelay_cnt && read_pos) {\n\t\t\tmemmove(deldelay_buf, deldelay_buf + read_pos,\n\t\t\t\tdeldelay_cnt);\n\t\t}\n\t\tlen = read(deldelay_fd, deldelay_buf + deldelay_cnt,\n\t\t\t   deldelay_size - deldelay_cnt);\n\t\tif (len == 0) {\n\t\t\tif (deldelay_cnt) {\n\t\t\t\trprintf(FERROR, \"ERROR: unexpected EOF in delete-delay file.\\n\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < 0) {\n\t\t\trsyserr(FERROR, errno,\n\t\t\t\t\"reading delete-delay file\");\n\t\t\treturn -1;\n\t\t}\n\t\tdeldelay_cnt += len;\n\t\tread_pos = 0;\n\t}\n\n\tbp = deldelay_buf + read_pos;\n\tif (*bp == '!') {\n\t\tbp++;\n\t\t*flags_p = DEL_NO_UID_WRITE;\n\t} else\n\t\t*flags_p = 0;\n\n\tif (sscanf(bp, \"%x \", &mode) != 1) {\n\t  invalid_data:\n\t\trprintf(FERROR, \"ERROR: invalid data in delete-delay file.\\n\");\n\t\treturn -1;\n\t}\n\tpast_space = strchr(bp, ' ') + 1;\n\tlen = j - read_pos - (past_space - bp) + 1; /* count the '\\0' */\n\tread_pos = j + 1;\n\n\tif (len > MAXPATHLEN) {\n\t\trprintf(FERROR, \"ERROR: filename too long in delete-delay file.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* The caller needs the name in a MAXPATHLEN buffer, so we copy it\n\t * instead of returning a pointer to our buffer. */\n\tmemcpy(buf, past_space, len);\n\n\treturn mode;\n}\n\nstatic void do_delayed_deletions(char *delbuf)\n{\n\tint mode, flags;\n\n\tif (deldelay_fd >= 0) {\n\t\tif (deldelay_cnt && !flush_delete_delay())\n\t\t\treturn;\n\t\tlseek(deldelay_fd, 0, 0);\n\t}\n\twhile ((mode = read_delay_line(delbuf, &flags)) >= 0)\n\t\tdelete_item(delbuf, mode, flags | DEL_RECURSE);\n\tif (deldelay_fd >= 0)\n\t\tclose(deldelay_fd);\n}\n\n/* This function is used to implement per-directory deletion, and is used by\n * all the --delete-WHEN options.  Note that the fbuf pointer must point to a\n * MAXPATHLEN buffer with the name of the directory in it (the functions we\n * call will append names onto the end, but the old dir value will be restored\n * on exit). */\nstatic void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev)\n{\n\tstatic int already_warned = 0;\n\tstatic struct hashtable *dev_tbl;\n\tstruct file_list *dirlist;\n\tchar delbuf[MAXPATHLEN];\n\tint dlen, i;\n\n\tif (!fbuf) {\n\t\tchange_local_filter_dir(NULL, 0, 0);\n\t\treturn;\n\t}\n\n\tif (DEBUG_GTE(DEL, 2))\n\t\trprintf(FINFO, \"delete_in_dir(%s)\\n\", fbuf);\n\n\tif (allowed_lull)\n\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);\n\n\tif (io_error & IOERR_GENERAL && !ignore_errors) {\n\t\tif (already_warned)\n\t\t\treturn;\n\t\trprintf(FINFO,\n\t\t\t\"IO error encountered -- skipping file deletion\\n\");\n\t\talready_warned = 1;\n\t\treturn;\n\t}\n\n\tdlen = strlen(fbuf);\n\tchange_local_filter_dir(fbuf, dlen, F_DEPTH(file));\n\n\tif (one_file_system) {\n\t\tif (!dev_tbl)\n\t\t\tdev_tbl = hashtable_create(16, HT_KEY64);\n\t\tif (file->flags & FLAG_TOP_DIR) {\n\t\t\thashtable_find(dev_tbl, fs_dev+1, \"\");\n\t\t\tfilesystem_dev = fs_dev;\n\t\t} else if (filesystem_dev != fs_dev) {\n\t\t\tif (!hashtable_find(dev_tbl, fs_dev+1, NULL))\n\t\t\t\treturn;\n\t\t\tfilesystem_dev = fs_dev; /* it's a prior top-dir dev */\n\t\t}\n\t}\n\n\tdirlist = get_dirlist(fbuf, dlen, 0);\n\n\t/* If an item in dirlist is not found in flist, delete it\n\t * from the filesystem. */\n\tfor (i = dirlist->used; i--; ) {\n\t\tstruct file_struct *fp = dirlist->files[i];\n\t\tif (!F_IS_ACTIVE(fp))\n\t\t\tcontinue;\n\t\tif (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {\n\t\t\tif (INFO_GTE(MOUNT, 1))\n\t\t\t\trprintf(FINFO, \"cannot delete mount point: %s\\n\",\n\t\t\t\t\tf_name(fp, NULL));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Here we want to match regardless of file type.  Replacement\n\t\t * of a file with one of another type is handled separately by\n\t\t * a delete_item call with a DEL_MAKE_ROOM flag. */\n\t\tif (flist_find_ignore_dirness(cur_flist, fp) < 0) {\n\t\t\tint flags = DEL_RECURSE;\n\t\t\tif (!(fp->mode & S_IWUSR) && !am_root && fp->flags & FLAG_OWNED_BY_US)\n\t\t\t\tflags |= DEL_NO_UID_WRITE;\n\t\t\tf_name(fp, delbuf);\n\t\t\tif (delete_during == 2) {\n\t\t\t\tif (!remember_delete(fp, delbuf, flags))\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tdelete_item(delbuf, fp->mode, flags);\n\t\t}\n\t}\n\n\tflist_free(dirlist);\n}\n\n/* This deletes any files on the receiving side that are not present on the\n * sending side.  This is used by --delete-before and --delete-after. */\nstatic void do_delete_pass(void)\n{\n\tchar fbuf[MAXPATHLEN];\n\tSTRUCT_STAT st;\n\tint j;\n\n\t/* dry_run is incremented when the destination doesn't exist yet. */\n\tif (dry_run > 1 || list_only)\n\t\treturn;\n\n\tfor (j = 0; j < cur_flist->used; j++) {\n\t\tstruct file_struct *file = cur_flist->sorted[j];\n\n\t\tif (!F_IS_ACTIVE(file))\n\t\t\tcontinue;\n\n\t\tf_name(file, fbuf);\n\n\t\tif (!(file->flags & FLAG_CONTENT_DIR)) {\n\t\t\tchange_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(file));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (DEBUG_GTE(DEL, 1) && file->flags & FLAG_TOP_DIR)\n\t\t\trprintf(FINFO, \"deleting in %s\\n\", fbuf);\n\n\t\tif (link_stat(fbuf, &st, keep_dirlinks) < 0\n\t\t || !S_ISDIR(st.st_mode))\n\t\t\tcontinue;\n\n\t\tdelete_in_dir(fbuf, file, st.st_dev);\n\t}\n\tdelete_in_dir(NULL, NULL, dev_zero);\n\n\tif (INFO_GTE(FLIST, 2) && !am_server)\n\t\trprintf(FINFO, \"                    \\r\");\n}\n\nstatic inline int mtime_differs(STRUCT_STAT *stp, struct file_struct *file)\n{\n#ifdef ST_MTIME_NSEC\n\treturn !same_time(stp->st_mtime, stp->ST_MTIME_NSEC, file->modtime, F_MOD_NSEC_or_0(file));\n#else\n\treturn !same_time(stp->st_mtime, 0, file->modtime, 0);\n#endif\n}\n\nstatic inline int any_time_differs(stat_x *sxp, struct file_struct *file, UNUSED(const char *fname))\n{\n\tint differs = mtime_differs(&sxp->st, file);\n#ifdef SUPPORT_CRTIMES\n\tif (!differs && crtimes_ndx) {\n\t\tif (sxp->crtime == 0)\n\t\t\tsxp->crtime = get_create_time(fname, &sxp->st);\n\t\tdiffers = !same_time(sxp->crtime, 0, F_CRTIME(file), 0);\n\t}\n#endif\n\treturn differs;\n}\n\nstatic inline int perms_differ(struct file_struct *file, stat_x *sxp)\n{\n\tif (preserve_perms)\n\t\treturn !BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS);\n\n\tif (preserve_executability)\n\t\treturn (sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0);\n\n\treturn 0;\n}\n\nstatic inline int ownership_differs(struct file_struct *file, stat_x *sxp)\n{\n\tif (am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file))\n\t\treturn 1;\n\n\tif (gid_ndx && !(file->flags & FLAG_SKIP_GROUP) && sxp->st.st_gid != (gid_t)F_GROUP(file))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#ifdef SUPPORT_ACLS\nstatic inline int acls_differ(const char *fname, struct file_struct *file, stat_x *sxp)\n{\n\tif (preserve_acls) {\n\t\tif (!ACL_READY(*sxp))\n\t\t\tget_acl(fname, sxp);\n\t\tif (set_acl(NULL, file, sxp, file->mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n#endif\n\n#ifdef SUPPORT_XATTRS\nstatic inline int xattrs_differ(const char *fname, struct file_struct *file, stat_x *sxp)\n{\n\tif (preserve_xattrs) {\n\t\tif (!XATTR_READY(*sxp))\n\t\t\tget_xattr(fname, sxp);\n\t\tif (xattr_diff(file, sxp, 0))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n#endif\n\nint unchanged_attrs(const char *fname, struct file_struct *file, stat_x *sxp)\n{\n\tif (S_ISLNK(file->mode)) {\n#ifdef CAN_SET_SYMLINK_TIMES\n\t\tif (preserve_mtimes && !omit_link_times && any_time_differs(sxp, file, fname))\n\t\t\treturn 0;\n#endif\n#ifdef CAN_CHMOD_SYMLINK\n\t\tif (perms_differ(file, sxp))\n\t\t\treturn 0;\n#endif\n#ifdef CAN_CHOWN_SYMLINK\n\t\tif (ownership_differs(file, sxp))\n\t\t\treturn 0;\n#endif\n#if defined SUPPORT_ACLS && 0 /* no current symlink-ACL support */\n\t\tif (acls_differ(fname, file, sxp))\n\t\t\treturn 0;\n#endif\n#if defined SUPPORT_XATTRS && !defined NO_SYMLINK_XATTRS\n\t\tif (xattrs_differ(fname, file, sxp))\n\t\t\treturn 0;\n#endif\n\t} else {\n\t\tif (preserve_mtimes && any_time_differs(sxp, file, fname))\n\t\t\treturn 0;\n\t\tif (perms_differ(file, sxp))\n\t\t\treturn 0;\n\t\tif (ownership_differs(file, sxp))\n\t\t\treturn 0;\n#ifdef SUPPORT_ACLS\n\t\tif (acls_differ(fname, file, sxp))\n\t\t\treturn 0;\n#endif\n#ifdef SUPPORT_XATTRS\n\t\tif (xattrs_differ(fname, file, sxp))\n\t\t\treturn 0;\n#endif\n\t}\n\n\treturn 1;\n}\n\nvoid itemize(const char *fnamecmp, struct file_struct *file, int ndx, int statret,\n\t     stat_x *sxp, int32 iflags, uchar fnamecmp_type,\n\t     const char *xname)\n{\n\tif (statret >= 0) { /* A from-dest-dir statret can == 1! */\n\t\tint keep_time = !preserve_mtimes ? 0\n\t\t    : S_ISDIR(file->mode) ? !omit_dir_times\n\t\t    : S_ISLNK(file->mode) ? !omit_link_times\n\t\t    : 1;\n\n\t\tif (S_ISREG(file->mode) && F_LENGTH(file) != sxp->st.st_size)\n\t\t\tiflags |= ITEM_REPORT_SIZE;\n\t\tif (file->flags & FLAG_TIME_FAILED) { /* symlinks only */\n\t\t\tif (iflags & ITEM_LOCAL_CHANGE)\n\t\t\t\tiflags |= symlink_timeset_failed_flags;\n\t\t} else if (keep_time\n\t\t ? mtime_differs(&sxp->st, file)\n\t\t : iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !(iflags & ITEM_MATCHED)\n\t\t  && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))\n\t\t\tiflags |= ITEM_REPORT_TIME;\n\t\tif (atimes_ndx && !S_ISDIR(file->mode) && !S_ISLNK(file->mode)\n\t\t && !same_time(F_ATIME(file), 0, sxp->st.st_atime, 0))\n\t\t\tiflags |= ITEM_REPORT_ATIME;\n#ifdef SUPPORT_CRTIMES\n\t\tif (crtimes_ndx) {\n\t\t\tif (sxp->crtime == 0)\n\t\t\t\tsxp->crtime = get_create_time(fnamecmp, &sxp->st);\n\t\t\tif (!same_time(sxp->crtime, 0, F_CRTIME(file), 0))\n\t\t\t\tiflags |= ITEM_REPORT_CRTIME;\n\t\t}\n#endif\n#ifndef CAN_CHMOD_SYMLINK\n\t\tif (S_ISLNK(file->mode)) {\n\t\t\t;\n\t\t} else\n#endif\n\t\tif (preserve_perms) {\n\t\t\tif (!BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))\n\t\t\t\tiflags |= ITEM_REPORT_PERMS;\n\t\t} else if (preserve_executability\n\t\t && ((sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0)))\n\t\t\tiflags |= ITEM_REPORT_PERMS;\n\t\tif (uid_ndx && am_root && (uid_t)F_OWNER(file) != sxp->st.st_uid)\n\t\t\tiflags |= ITEM_REPORT_OWNER;\n\t\tif (gid_ndx && !(file->flags & FLAG_SKIP_GROUP) && sxp->st.st_gid != (gid_t)F_GROUP(file))\n\t\t\tiflags |= ITEM_REPORT_GROUP;\n#ifdef SUPPORT_ACLS\n\t\tif (preserve_acls && !S_ISLNK(file->mode)) {\n\t\t\tif (!ACL_READY(*sxp))\n\t\t\t\tget_acl(fnamecmp, sxp);\n\t\t\tif (set_acl(NULL, file, sxp, file->mode))\n\t\t\t\tiflags |= ITEM_REPORT_ACL;\n\t\t}\n#endif\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs) {\n\t\t\tif (!XATTR_READY(*sxp))\n\t\t\t\tget_xattr(fnamecmp, sxp);\n\t\t\tif (xattr_diff(file, sxp, 1))\n\t\t\t\tiflags |= ITEM_REPORT_XATTR;\n\t\t}\n#endif\n\t} else {\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && xattr_diff(file, NULL, 1))\n\t\t\tiflags |= ITEM_REPORT_XATTR;\n#endif\n\t\tiflags |= ITEM_IS_NEW;\n\t}\n\n\tiflags &= 0xffff;\n\tif ((iflags & (SIGNIFICANT_ITEM_FLAGS|ITEM_REPORT_XATTR) || INFO_GTE(NAME, 2)\n\t  || stdout_format_has_i > 1 || (xname && *xname)) && !read_batch) {\n\t\tif (protocol_version >= 29) {\n\t\t\tif (ndx >= 0)\n\t\t\t\twrite_ndx(sock_f_out, ndx);\n\t\t\twrite_shortint(sock_f_out, iflags);\n\t\t\tif (iflags & ITEM_BASIS_TYPE_FOLLOWS)\n\t\t\t\twrite_byte(sock_f_out, fnamecmp_type);\n\t\t\tif (iflags & ITEM_XNAME_FOLLOWS)\n\t\t\t\twrite_vstring(sock_f_out, xname, strlen(xname));\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs && do_xfers\n\t\t\t && iflags & (ITEM_REPORT_XATTR|ITEM_TRANSFER)) {\n\t\t\t\tint fd = iflags & ITEM_REPORT_XATTR\n\t\t\t\t      && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))\n\t\t\t\t       ? sock_f_out : -1;\n\t\t\t\tsend_xattr_request(NULL, file, fd);\n\t\t\t}\n#endif\n\t\t} else if (ndx >= 0) {\n\t\t\tenum logcode code = logfile_format_has_i ? FINFO : FCLIENT;\n\t\t\tlog_item(code, file, iflags, xname);\n\t\t}\n\t}\n}\n\nstatic enum filetype get_file_type(mode_t mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn FT_REG;\n\tif (S_ISLNK(mode))\n\t\treturn FT_SYMLINK;\n\tif (S_ISDIR(mode))\n\t\treturn FT_DIR;\n\tif (IS_SPECIAL(mode))\n\t\treturn FT_SPECIAL;\n\tif (IS_DEVICE(mode))\n\t\treturn FT_DEVICE;\n\treturn FT_UNSUPPORTED;\n}\n\n/* Perform our quick-check heuristic for determining if a file is unchanged. */\nint quick_check_ok(enum filetype ftype, const char *fn, struct file_struct *file, STRUCT_STAT *st)\n{\n\tswitch (ftype) {\n\t  case FT_REG:\n\t\tif (st->st_size != F_LENGTH(file))\n\t\t\treturn 0;\n\n\t\t/* If always_checksum is set then we use the checksum instead\n\t\t * of the file mtime to determine whether to sync. */\n\t\tif (always_checksum > 0) {\n\t\t\tchar sum[MAX_DIGEST_LEN];\n\t\t\tfile_checksum(fn, st, sum);\n\t\t\treturn memcmp(sum, F_SUM(file), flist_csum_len) == 0;\n\t\t}\n\n\t\tif (size_only > 0)\n\t\t\treturn 1;\n\n\t\tif (ignore_times)\n\t\t\treturn 0;\n\n\t\tif (mtime_differs(st, file))\n\t\t\treturn 0;\n\t\tbreak;\n\t  case FT_DIR:\n\t\tbreak;\n\t  case FT_SYMLINK: {\n#ifdef SUPPORT_LINKS\n\t\tchar lnk[MAXPATHLEN];\n\t\tint len = do_readlink(fn, lnk, MAXPATHLEN-1);\n\t\tif (len <= 0)\n\t\t\treturn 0;\n\t\tlnk[len] = '\\0';\n\t\tif (strcmp(lnk, F_SYMLINK(file)) != 0)\n\t\t\treturn 0;\n\t\tbreak;\n#else\n\t\treturn -1;\n#endif\n\t  }\n\t  case FT_SPECIAL:\n\t\tif (!BITS_EQUAL(file->mode, st->st_mode, _S_IFMT))\n\t\t\treturn 0;\n\t\tbreak;\n\t  case FT_DEVICE: {\n\t\tuint32 *devp = F_RDEV_P(file);\n\t\tif (st->st_rdev != MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp)))\n\t\t\treturn 0;\n\t\tbreak;\n\t  }\n\t  case FT_UNSUPPORTED:\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n/*\n * set (initialize) the size entries in the per-file sum_struct\n * calculating dynamic block and checksum sizes.\n *\n * This is only called from generate_and_send_sums() but is a separate\n * function to encapsulate the logic.\n *\n * The block size is a rounded square root of file length.\n *\n * The checksum size is determined according to:\n *     blocksum_bits = BLOCKSUM_BIAS + 2*log2(file_len) - log2(block_len)\n * provided by Donovan Baarda which gives a probability of rsync\n * algorithm corrupting data and falling back using the whole md4\n * checksums.\n *\n * This might be made one of several selectable heuristics.\n */\nstatic void sum_sizes_sqroot(struct sum_struct *sum, int64 len)\n{\n\tint32 blength;\n\tint s2length;\n\tint64 l;\n\n\tif (len < 0) {\n\t\t/* The file length overflowed our int64 var, so we can't process this file. */\n\t\tsum->count = -1; /* indicate overflow error */\n\t\treturn;\n\t}\n\n\tif (block_size)\n\t\tblength = block_size;\n\telse if (len <= BLOCK_SIZE * BLOCK_SIZE)\n\t\tblength = BLOCK_SIZE;\n\telse {\n\t\tint32 max_blength = protocol_version < 30 ? OLD_MAX_BLOCK_SIZE : MAX_BLOCK_SIZE;\n\t\tint32 c;\n\t\tint cnt;\n\t\tfor (c = 1, l = len, cnt = 0; l >>= 2; c <<= 1, cnt++) {}\n\t\tif (c < 0 || c >= max_blength)\n\t\t\tblength = max_blength;\n\t\telse {\n\t\t\tblength = 0;\n\t\t\tdo {\n\t\t\t\tblength |= c;\n\t\t\t\tif (len < (int64)blength * blength)\n\t\t\t\t\tblength &= ~c;\n\t\t\t\tc >>= 1;\n\t\t\t} while (c >= 8);\t/* round to multiple of 8 */\n\t\t\tblength = MAX(blength, BLOCK_SIZE);\n\t\t}\n\t}\n\n\tif (protocol_version < 27) {\n\t\ts2length = csum_length;\n\t} else if (csum_length == SUM_LENGTH) {\n\t\ts2length = SUM_LENGTH;\n\t} else {\n\t\tint32 c;\n\t\tint b = BLOCKSUM_BIAS;\n\t\tfor (l = len; l >>= 1; b += 2) {}\n\t\tfor (c = blength; (c >>= 1) && b; b--) {}\n\t\t/* add a bit, subtract rollsum, round up. */\n\t\ts2length = (b + 1 - 32 + 7) / 8; /* --optimize in compiler-- */\n\t\ts2length = MAX(s2length, csum_length);\n\t\ts2length = MIN(s2length, SUM_LENGTH);\n\t}\n\n\tsum->flength\t= len;\n\tsum->blength\t= blength;\n\tsum->s2length\t= s2length;\n\tsum->remainder\t= (int32)(len % blength);\n\tsum->count\t= (int32)(l = (len / blength) + (sum->remainder != 0));\n\n\tif ((int64)sum->count != l)\n\t\tsum->count = -1;\n\n\tif (sum->count && DEBUG_GTE(DELTASUM, 2)) {\n\t\trprintf(FINFO,\n\t\t\t\"count=%s rem=%ld blength=%ld s2length=%d flength=%s\\n\",\n\t\t\tbig_num(sum->count), (long)sum->remainder, (long)sum->blength,\n\t\t\tsum->s2length, big_num(sum->flength));\n\t}\n}\n\n\n/*\n * Generate and send a stream of signatures/checksums that describe a buffer\n *\n * Generate approximately one checksum every block_len bytes.\n */\nstatic int generate_and_send_sums(int fd, OFF_T len, int f_out, int f_copy)\n{\n\tint32 i;\n\tstruct map_struct *mapbuf;\n\tstruct sum_struct sum;\n\tOFF_T offset = 0;\n\n\tsum_sizes_sqroot(&sum, len);\n\tif (sum.count < 0)\n\t\treturn -1;\n\twrite_sum_head(f_out, &sum);\n\n\tif (append_mode > 0 && f_copy < 0)\n\t\treturn 0;\n\n\tif (len > 0)\n\t\tmapbuf = map_file(fd, len, MAX_MAP_SIZE, sum.blength);\n\telse\n\t\tmapbuf = NULL;\n\n\tfor (i = 0; i < sum.count; i++) {\n\t\tint32 n1 = (int32)MIN(len, (OFF_T)sum.blength);\n\t\tchar *map = map_ptr(mapbuf, offset, n1);\n\t\tchar sum2[MAX_DIGEST_LEN];\n\t\tuint32 sum1;\n\n\t\tlen -= n1;\n\t\toffset += n1;\n\n\t\tif (f_copy >= 0) {\n\t\t\tfull_write(f_copy, map, n1);\n\t\t\tif (append_mode > 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tsum1 = get_checksum1(map, n1);\n\t\tget_checksum2(map, n1, sum2);\n\n\t\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"chunk[%s] offset=%s len=%ld sum1=%08lx\\n\",\n\t\t\t\tbig_num(i), big_num(offset - n1), (long)n1,\n\t\t\t\t(unsigned long)sum1);\n\t\t}\n\t\twrite_int(f_out, sum1);\n\t\twrite_buf(f_out, sum2, sum.s2length);\n\t}\n\n\tif (mapbuf)\n\t\tunmap_file(mapbuf);\n\n\treturn 0;\n}\n\n\n/* Try to find a filename in the same dir as \"fname\" with a similar name. */\nstatic struct file_struct *find_fuzzy(struct file_struct *file, struct file_list *dirlist_array[], uchar *fnamecmp_type_ptr)\n{\n\tint fname_len, fname_suf_len;\n\tconst char *fname_suf, *fname = file->basename;\n\tuint32 lowest_dist = 25 << 16; /* ignore a distance greater than 25 */\n\tint i, j;\n\tstruct file_struct *lowest_fp = NULL;\n\n\tfname_len = strlen(fname);\n\tfname_suf = find_filename_suffix(fname, fname_len, &fname_suf_len);\n\n\t/* Try to find an exact size+mtime match first. */\n\tfor (i = 0; i < fuzzy_basis; i++) {\n\t\tstruct file_list *dirlist = dirlist_array[i];\n\n\t\tif (!dirlist)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < dirlist->used; j++) {\n\t\t\tstruct file_struct *fp = dirlist->files[j];\n\n\t\t\tif (!F_IS_ACTIVE(fp))\n\t\t\t\tcontinue;\n\n\t\t\tif (!S_ISREG(fp->mode) || !F_LENGTH(fp) || fp->flags & FLAG_FILE_SENT)\n\t\t\t\tcontinue;\n\n\t\t\tif (F_LENGTH(fp) == F_LENGTH(file) && same_time(fp->modtime, 0, file->modtime, 0)) {\n\t\t\t\tif (DEBUG_GTE(FUZZY, 2))\n\t\t\t\t\trprintf(FINFO, \"fuzzy size/modtime match for %s\\n\", f_name(fp, NULL));\n\t\t\t\t*fnamecmp_type_ptr = FNAMECMP_FUZZY + i;\n\t\t\t\treturn fp;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfor (i = 0; i < fuzzy_basis; i++) {\n\t\tstruct file_list *dirlist = dirlist_array[i];\n\n\t\tif (!dirlist)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < dirlist->used; j++) {\n\t\t\tstruct file_struct *fp = dirlist->files[j];\n\t\t\tconst char *suf, *name;\n\t\t\tint len, suf_len;\n\t\t\tuint32 dist;\n\n\t\t\tif (!F_IS_ACTIVE(fp))\n\t\t\t\tcontinue;\n\n\t\t\tif (!S_ISREG(fp->mode) || !F_LENGTH(fp) || fp->flags & FLAG_FILE_SENT)\n\t\t\t\tcontinue;\n\n\t\t\tname = fp->basename;\n\t\t\tlen = strlen(name);\n\t\t\tsuf = find_filename_suffix(name, len, &suf_len);\n\n\t\t\tdist = fuzzy_distance(name, len, fname, fname_len, lowest_dist);\n\t\t\t/* Add some extra weight to how well the suffixes match unless we've already disqualified\n\t\t\t * this file based on a heuristic. */\n\t\t\tif (dist < 0xFFFF0000U) {\n\t\t\t\tdist += fuzzy_distance(suf, suf_len, fname_suf, fname_suf_len, 0xFFFF0000U) * 10;\n\t\t\t}\n\t\t\tif (DEBUG_GTE(FUZZY, 2)) {\n\t\t\t\trprintf(FINFO, \"fuzzy distance for %s = %d.%05d\\n\",\n\t\t\t\t\tf_name(fp, NULL), (int)(dist>>16), (int)(dist&0xFFFF));\n\t\t\t}\n\t\t\tif (dist <= lowest_dist) {\n\t\t\t\tlowest_dist = dist;\n\t\t\t\tlowest_fp = fp;\n\t\t\t\t*fnamecmp_type_ptr = FNAMECMP_FUZZY + i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn lowest_fp;\n}\n\n/* Copy a file found in our --copy-dest handling. */\nstatic int copy_altdest_file(const char *src, const char *dest, struct file_struct *file)\n{\n\tchar buf[MAXPATHLEN];\n\tconst char *copy_to, *partialptr;\n\tint save_preserve_xattrs = preserve_xattrs;\n\tint ok, fd_w;\n\n\tif (inplace) {\n\t\t/* Let copy_file open the destination in place. */\n\t\tfd_w = -1;\n\t\tcopy_to = dest;\n\t} else {\n\t\tfd_w = open_tmpfile(buf, dest, file);\n\t\tif (fd_w < 0)\n\t\t\treturn -1;\n\t\tcopy_to = buf;\n\t}\n\tcleanup_set(copy_to, NULL, NULL, -1, -1);\n\tif (copy_file(src, copy_to, fd_w, file->mode) < 0) {\n\t\tif (INFO_GTE(COPY, 1)) {\n\t\t\trsyserr(FINFO, errno, \"copy_file %s => %s\",\n\t\t\t\tfull_fname(src), copy_to);\n\t\t}\n\t\t/* Try to clean up. */\n\t\tunlink(copy_to);\n\t\tcleanup_disable();\n\t\treturn -1;\n\t}\n\tpartialptr = partial_dir ? partial_dir_fname(dest) : NULL;\n\tpreserve_xattrs = 0; /* xattrs were copied with file */\n\tok = finish_transfer(dest, copy_to, src, partialptr, file, 1, 0);\n\tpreserve_xattrs = save_preserve_xattrs;\n\tcleanup_disable();\n\treturn ok ? 0 : -1;\n}\n\n/* This is only called for regular files.  We return -2 if we've finished\n * handling the file, -1 if no dest-linking occurred, or a non-negative\n * value if we found an alternate basis file.  If we're called with the\n * find_exact_for_existing flag, the destination file already exists, so\n * we only try to find an exact alt-dest match.  In this case, the returns\n * are only -2 & -1 (both as above). */\nstatic int try_dests_reg(struct file_struct *file, char *fname, int ndx,\n\t\t\t char *cmpbuf, stat_x *sxp, int find_exact_for_existing,\n\t\t\t int itemizing, enum logcode code)\n{\n\tSTRUCT_STAT real_st = sxp->st;\n\tint best_match = -1;\n\tint match_level = 0;\n\tint j = 0;\n\n\tdo {\n\t\tpathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);\n\t\tif (link_stat(cmpbuf, &sxp->st, 0) < 0 || !S_ISREG(sxp->st.st_mode))\n\t\t\tcontinue;\n\t\tif (match_level == 0) {\n\t\t\tbest_match = j;\n\t\t\tmatch_level = 1;\n\t\t}\n\t\tif (!quick_check_ok(FT_REG, cmpbuf, file, &sxp->st))\n\t\t\tcontinue;\n\t\tif (match_level == 1) {\n\t\t\tbest_match = j;\n\t\t\tmatch_level = 2;\n\t\t}\n\t\tif (unchanged_attrs(cmpbuf, file, sxp)) {\n\t\t\tbest_match = j;\n\t\t\tmatch_level = 3;\n\t\t\tbreak;\n\t\t}\n\t\tfree_stat_x(sxp);\n\t} while (basis_dir[++j] != NULL);\n\n\tif (!match_level)\n\t\tgoto got_nothing_for_ya;\n\n\tif (j != best_match) {\n\t\tj = best_match;\n\t\tpathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);\n\t\tif (link_stat(cmpbuf, &sxp->st, 0) < 0)\n\t\t\tgoto got_nothing_for_ya;\n\t}\n\n\tif (match_level == 3 && alt_dest_type != COPY_DEST) {\n\t\tif (find_exact_for_existing) {\n\t\t\tif (alt_dest_type == LINK_DEST && real_st.st_dev == sxp->st.st_dev && real_st.st_ino == sxp->st.st_ino)\n\t\t\t\treturn -1;\n\t\t\tif (do_unlink(fname) < 0 && errno != ENOENT)\n\t\t\t\tgoto got_nothing_for_ya;\n\t\t}\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (alt_dest_type == LINK_DEST) {\n\t\t\tif (!hard_link_one(file, fname, cmpbuf, 1))\n\t\t\t\tgoto try_a_copy;\n\t\t\tif (atimes_ndx)\n\t\t\t\tset_file_attrs(fname, file, sxp, NULL, 0);\n\t\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\t\tfinish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, j);\n\t\t\tif (!maybe_ATTRS_REPORT && (INFO_GTE(NAME, 2) || stdout_format_has_i > 1)) {\n\t\t\t\titemize(cmpbuf, file, ndx, 1, sxp,\n\t\t\t\t\tITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,\n\t\t\t\t\t0, \"\");\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tif (itemizing)\n\t\t\t\titemize(cmpbuf, file, ndx, 0, sxp, 0, 0, NULL);\n\t\t}\n\t\tif (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)\n\t\t\trprintf(FCLIENT, \"%s is uptodate\\n\", fname);\n\t\treturn -2;\n\t}\n\n\tif (find_exact_for_existing)\n\t\tgoto got_nothing_for_ya;\n\n\tif (match_level >= 2) {\n#ifdef SUPPORT_HARD_LINKS\n\t  try_a_copy: /* Copy the file locally. */\n#endif\n\t\tif (!dry_run && copy_altdest_file(cmpbuf, fname, file) < 0) {\n\t\t\tif (find_exact_for_existing) /* Can get here via hard-link failure */\n\t\t\t\tgoto got_nothing_for_ya;\n\t\t\treturn -1;\n\t\t}\n\t\tif (itemizing)\n\t\t\titemize(cmpbuf, file, ndx, 0, sxp, ITEM_LOCAL_CHANGE, 0, NULL);\n\t\tif (maybe_ATTRS_REPORT\n\t\t && ((!itemizing && INFO_GTE(NAME, 1) && match_level == 2)\n\t\t  || (INFO_GTE(NAME, 2) && match_level == 3))) {\n\t\t\tcode = match_level == 3 ? FCLIENT : FINFO;\n\t\t\trprintf(code, \"%s%s\\n\", fname,\n\t\t\t\tmatch_level == 3 ? \" is uptodate\" : \"\");\n\t\t}\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\tfinish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, -1);\n#endif\n\t\treturn -2;\n\t}\n\n\treturn FNAMECMP_BASIS_DIR_LOW + j;\n\ngot_nothing_for_ya:\n\tsxp->st = real_st;\n\treturn -1;\n}\n\n/* This is only called for non-regular files.  We return -2 if we've finished\n * handling the file, or -1 if no dest-linking occurred, or a non-negative\n * value if we found an alternate basis file. */\nstatic int try_dests_non(struct file_struct *file, char *fname, int ndx,\n\t\t\t char *cmpbuf, stat_x *sxp, int itemizing,\n\t\t\t enum logcode code)\n{\n\tint best_match = -1;\n\tint match_level = 0;\n\tenum filetype ftype = get_file_type(file->mode);\n\tint j = 0;\n\n#ifndef SUPPORT_LINKS\n\tif (ftype == FT_SYMLINK)\n\t\treturn -1;\n#endif\n\tif (ftype == FT_REG || ftype == FT_UNSUPPORTED) {\n\t\trprintf(FERROR,\n\t\t\t\"internal: try_dests_non() called with invalid mode (%o)\\n\",\n\t\t\t(int)file->mode);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tdo {\n\t\tpathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);\n\t\tif (link_stat(cmpbuf, &sxp->st, 0) < 0)\n\t\t\tcontinue;\n\t\tif (ftype != get_file_type(sxp->st.st_mode))\n\t\t\tcontinue;\n\t\tif (match_level < 1) {\n\t\t\tmatch_level = 1;\n\t\t\tbest_match = j;\n\t\t}\n\t\tif (!quick_check_ok(ftype, cmpbuf, file, &sxp->st))\n\t\t\tcontinue;\n\t\tif (match_level < 2) {\n\t\t\tmatch_level = 2;\n\t\t\tbest_match = j;\n\t\t}\n\t\tif (unchanged_attrs(cmpbuf, file, sxp)) {\n\t\t\tmatch_level = 3;\n\t\t\tbest_match = j;\n\t\t\tbreak;\n\t\t}\n\t} while (basis_dir[++j] != NULL);\n\n\tif (!match_level)\n\t\treturn -1;\n\n\tif (j != best_match) {\n\t\tj = best_match;\n\t\tpathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);\n\t\tif (link_stat(cmpbuf, &sxp->st, 0) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (match_level == 3) {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (alt_dest_type == LINK_DEST\n#ifndef CAN_HARDLINK_SYMLINK\n\t\t && !S_ISLNK(file->mode)\n#endif\n#ifndef CAN_HARDLINK_SPECIAL\n\t\t && !IS_SPECIAL(file->mode) && !IS_DEVICE(file->mode)\n#endif\n\t\t && !S_ISDIR(file->mode)) {\n\t\t\tif (do_link(cmpbuf, fname) < 0) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"failed to hard-link %s with %s\",\n\t\t\t\t\tcmpbuf, fname);\n\t\t\t\treturn j;\n\t\t\t}\n\t\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\t\tfinish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);\n\t\t} else\n#endif\n\t\t\tmatch_level = 2;\n\t\tif (itemizing && stdout_format_has_i\n\t\t && (INFO_GTE(NAME, 2) || stdout_format_has_i > 1)) {\n\t\t\tint chg = alt_dest_type == COMPARE_DEST && ftype != FT_DIR ? 0\n\t\t\t    : ITEM_LOCAL_CHANGE + (match_level == 3 ? ITEM_XNAME_FOLLOWS : 0);\n\t\t\tchar *lp = match_level == 3 ? \"\" : NULL;\n\t\t\titemize(cmpbuf, file, ndx, 0, sxp, chg + ITEM_MATCHED, 0, lp);\n\t\t}\n\t\tif (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT) {\n\t\t\trprintf(FCLIENT, \"%s%s is uptodate\\n\",\n\t\t\t\tfname, ftype == FT_DIR ? \"/\" : \"\");\n\t\t}\n\t\treturn -2;\n\t}\n\n\treturn j;\n}\n\nstatic void list_file_entry(struct file_struct *f)\n{\n\tchar permbuf[PERMSTRING_SIZE];\n\tconst char *mtime_str = timestring(f->modtime);\n\tint size_width = human_readable ? 14 : 11;\n\tint mtime_width = 1 + strlen(mtime_str);\n\tint atime_width = atimes_ndx ? mtime_width : 0;\n\tint crtime_width = crtimes_ndx ? mtime_width : 0;\n\n\tif (!F_IS_ACTIVE(f)) {\n\t\t/* this can happen if duplicate names were removed */\n\t\treturn;\n\t}\n\n\t/* TODO: indicate '+' if the entry has an ACL. */\n\n\tif (missing_args == 2 && f->mode == 0) {\n\t\trprintf(FINFO, \"%-*s %s\\n\",\n\t\t\t10 + 1 + size_width + mtime_width + atime_width + crtime_width, \"*missing\",\n\t\t\tf_name(f, NULL));\n\t} else {\n\t\tconst char *atime_str = atimes_ndx && !S_ISDIR(f->mode) ? timestring(F_ATIME(f)) : \"\";\n\t\tconst char *crtime_str = crtimes_ndx ? timestring(F_CRTIME(f)) : \"\";\n\t\tconst char *arrow, *lnk;\n\n\t\tpermstring(permbuf, f->mode);\n\n#ifdef SUPPORT_LINKS\n\t\tif (preserve_links && S_ISLNK(f->mode)) {\n\t\t\tarrow = \" -> \";\n\t\t\tlnk = F_SYMLINK(f);\n\t\t} else\n#endif\n\t\t\tarrow = lnk = \"\";\n\n\t\trprintf(FINFO, \"%s %*s %s%*s%*s %s%s%s\\n\",\n\t\t\tpermbuf, size_width, human_num(F_LENGTH(f)),\n\t\t\ttimestring(f->modtime), atime_width, atime_str, crtime_width, crtime_str,\n\t\t\tf_name(f, NULL), arrow, lnk);\n\t}\n}\n\nstatic int phase = 0;\nstatic int dflt_perms;\n\nstatic int implied_dirs_are_missing;\n/* Helper for recv_generator's skip_dir and dry_missing_dir tests. */\nstatic BOOL is_below(struct file_struct *file, struct file_struct *subtree)\n{\n\treturn F_DEPTH(file) > F_DEPTH(subtree)\n\t\t&& (!implied_dirs_are_missing || f_name_has_prefix(file, subtree));\n}\n\n/* Acts on the indicated item in cur_flist whose name is fname.  If a dir,\n * make sure it exists, and has the right permissions/timestamp info.  For\n * all other non-regular files (symlinks, etc.) we create them here.  For\n * regular files that have changed, we try to find a basis file and then\n * start sending checksums.  The ndx is the file's unique index value.\n *\n * The fname parameter must point to a MAXPATHLEN buffer!  (e.g it gets\n * passed to delete_item(), which can use it during a recursive delete.)\n *\n * Note that f_out is set to -1 when doing final directory-permission and\n * modification-time repair. */\nstatic void recv_generator(char *fname, struct file_struct *file, int ndx,\n\t\t\t   int itemizing, enum logcode code, int f_out)\n{\n\tstatic const char *parent_dirname = \"\";\n\tstatic struct file_struct *prior_dir_file = NULL;\n\t/* Missing dir not created due to --dry-run; will still be scanned. */\n\tstatic struct file_struct *dry_missing_dir = NULL;\n\t/* Missing dir whose contents are skipped altogether due to\n\t * --ignore-non-existing, daemon exclude, or mkdir failure. */\n\tstatic struct file_struct *skip_dir = NULL;\n\tstatic struct file_list *fuzzy_dirlist[MAX_BASIS_DIRS+1];\n\tstatic int need_fuzzy_dirlist = 0;\n\tstruct file_struct *fuzzy_file = NULL;\n\tint fd = -1, f_copy = -1;\n\tstat_x sx, real_sx;\n\tSTRUCT_STAT partial_st;\n\tstruct file_struct *back_file = NULL;\n\tint statret, real_ret, stat_errno;\n\tchar *fnamecmp, *partialptr, *backupptr = NULL;\n\tchar fnamecmpbuf[MAXPATHLEN];\n\tuchar fnamecmp_type;\n\tint del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;\n\tenum filetype stype, ftype = get_file_type(file->mode);\n\tint is_dir = ftype != FT_DIR ? 0\n\t\t   : inc_recurse && ndx != cur_flist->ndx_start - 1 ? -1\n\t\t   : 1;\n\n\tif (DEBUG_GTE(GENR, 1))\n\t\trprintf(FINFO, \"recv_generator(%s,%d)\\n\", fname, ndx);\n\n\tif (list_only) {\n\t\tif (is_dir < 0\n\t\t || (is_dir && !implied_dirs && file->flags & FLAG_IMPLIED_DIR))\n\t\t\treturn;\n\t\tlist_file_entry(file);\n\t\treturn;\n\t}\n\n\tmaybe_ATTRS_ACCURATE_TIME = always_checksum ? ATTRS_ACCURATE_TIME : 0;\n\n\tif (skip_dir) {\n\t\tif (is_below(file, skip_dir)) {\n\t\t\tif (is_dir)\n\t\t\t\tfile->flags |= FLAG_MISSING_DIR;\n#ifdef SUPPORT_HARD_LINKS\n\t\t\telse if (F_IS_HLINKED(file))\n\t\t\t\thandle_skipped_hlink(file, itemizing, code, f_out);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tskip_dir = NULL;\n\t}\n\n\tinit_stat_x(&sx);\n\tif (daemon_filter_list.head && (*fname != '.' || fname[1])) {\n\t\tif (check_filter(&daemon_filter_list, FLOG, fname, is_dir) < 0) {\n\t\t\tif (is_dir < 0)\n\t\t\t\treturn;\n#ifdef SUPPORT_HARD_LINKS\n\t\t\tif (F_IS_HLINKED(file))\n\t\t\t\thandle_skipped_hlink(file, itemizing, code, f_out);\n#endif\n\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\"ERROR: daemon refused to receive %s \\\"%s\\\"\\n\",\n\t\t\t\tis_dir ? \"directory\" : \"file\", fname);\n\t\t\tif (is_dir)\n\t\t\t\tgoto skipping_dir_contents;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dry_run > 1 || (dry_missing_dir && is_below(file, dry_missing_dir))) {\n\t\tint i;\n\t  parent_is_dry_missing:\n\t\tfor (i = 0; i < fuzzy_basis; i++) {\n\t\t\tif (fuzzy_dirlist[i]) {\n\t\t\t\tflist_free(fuzzy_dirlist[i]);\n\t\t\t\tfuzzy_dirlist[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tparent_dirname = \"\";\n\t\tstatret = -1;\n\t\tstat_errno = ENOENT;\n\t} else {\n\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\tdry_missing_dir = NULL;\n\t\tif (parent_dirname != dn && strcmp(parent_dirname, dn) != 0) {\n\t\t\t/* Each parent dir must be in the file list or the flist data is bad.\n\t\t\t * Optimization: most of the time the parent dir will be the last dir\n\t\t\t * this function was asked to process in the file list. */\n\t\t\tif (!inc_recurse\n\t\t\t && (*dn != '.' || dn[1]) /* Avoid an issue with --relative and the \".\" dir. */\n\t\t\t && (!prior_dir_file || strcmp(dn, f_name(prior_dir_file, NULL)) != 0)) {\n\t\t\t\tint ok = 0, j = flist_find_name(cur_flist, dn, -1);\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tstruct file_struct *f = cur_flist->sorted[j];\n\t\t\t\t\tif (S_ISDIR(f->mode) || (missing_args == 2 && !file->mode && !f->mode))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\t/* The --delete-missing-args option can actually put invalid entries into\n\t\t\t\t * the file list, so if that option was specified, we'll just complain about\n\t\t\t\t * it and allow it. */\n\t\t\t\tif (!ok && missing_args == 2 && file->mode == 0 && j < 0)\n\t\t\t\t\trprintf(FERROR, \"WARNING: parent dir is absent in the file list: %s\\n\", dn);\n\t\t\t\telse if (!ok) {\n\t\t\t\t\trprintf(FERROR, \"ABORTING due to invalid path from sender: %s/%s\\n\",\n\t\t\t\t\t\tdn, file->basename);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (relative_paths && !implied_dirs && file->mode != 0\n\t\t\t && do_stat(dn, &sx.st) < 0) {\n\t\t\t\tif (dry_run)\n\t\t\t\t\tgoto parent_is_dry_missing;\n\t\t\t\tif (make_path(fname, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0) {\n\t\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\t\"recv_generator: mkdir %s failed\",\n\t\t\t\t\t\tfull_fname(dn));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fuzzy_basis) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < fuzzy_basis; i++) {\n\t\t\t\t\tif (fuzzy_dirlist[i]) {\n\t\t\t\t\t\tflist_free(fuzzy_dirlist[i]);\n\t\t\t\t\t\tfuzzy_dirlist[i] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed_fuzzy_dirlist = 1;\n\t\t\t}\n#ifdef SUPPORT_ACLS\n\t\t\tif (!preserve_perms)\n\t\t\t\tdflt_perms = default_perms_for_dir(dn);\n#endif\n\t\t}\n\t\tparent_dirname = dn;\n\n\t\tstatret = link_stat(fname, &sx.st, keep_dirlinks && is_dir);\n\t\tstat_errno = errno;\n\t}\n\n\tif (missing_args == 2 && file->mode == 0) {\n\t\tif (filter_list.head && check_filter(&filter_list, FINFO, fname, is_dir) < 0)\n\t\t\treturn;\n\t\tif (statret == 0)\n\t\t\tdelete_item(fname, sx.st.st_mode, del_opts);\n\t\treturn;\n\t}\n\n\tif (ignore_non_existing > 0 && statret == -1 && stat_errno == ENOENT) {\n\t\tif (is_dir) {\n\t\t\tif (is_dir < 0)\n\t\t\t\treturn;\n\t\t\tskip_dir = file;\n\t\t\tfile->flags |= FLAG_MISSING_DIR;\n\t\t}\n#ifdef SUPPORT_HARD_LINKS\n\t\telse if (F_IS_HLINKED(file))\n\t\t\thandle_skipped_hlink(file, itemizing, code, f_out);\n#endif\n\t\tif (INFO_GTE(SKIP, 1)) {\n\t\t\trprintf(FINFO, \"not creating new %s \\\"%s\\\"\\n\",\n\t\t\t\tis_dir ? \"directory\" : \"file\", fname);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (statret == 0 && !(sx.st.st_mode & S_IWUSR)\n\t && !am_root && sx.st.st_uid == our_uid)\n\t\tdel_opts |= DEL_NO_UID_WRITE;\n\n\tif (statret == 0)\n\t\tstype = get_file_type(sx.st.st_mode);\n\telse\n\t\tstype = FT_UNSUPPORTED;\n\n\tif (ignore_existing > 0 && statret == 0\n\t && (!is_dir || stype != FT_DIR)) {\n\t\tif (INFO_GTE(SKIP, 1) && is_dir >= 0) {\n\t\t\tconst char *suf = \"\";\n\t\t\tif (INFO_GTE(SKIP, 2)) {\n\t\t\t\tif (ftype != stype)\n\t\t\t\t\tsuf = \" (type change)\";\n\t\t\t\telse if (!quick_check_ok(ftype, fname, file, &sx.st))\n\t\t\t\t\tsuf = always_checksum ? \" (sum change)\" : \" (file change)\";\n\t\t\t\telse if (!unchanged_attrs(fname, file, &sx))\n\t\t\t\t\tsuf = \" (attr change)\";\n\t\t\t\telse\n\t\t\t\t\tsuf = \" (uptodate)\";\n\t\t\t}\n\t\t\trprintf(FINFO, \"%s exists%s\\n\", fname, suf);\n\t\t}\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (F_IS_HLINKED(file))\n\t\t\thandle_skipped_hlink(file, itemizing, code, f_out);\n#endif\n\t\tgoto cleanup;\n\t}\n\n\tfnamecmp = fname;\n\n\tif (is_dir) {\n\t\tmode_t added_perms;\n\t\tif (!implied_dirs && file->flags & FLAG_IMPLIED_DIR)\n\t\t\tgoto cleanup;\n\t\tif (am_root < 0) {\n\t\t\t/* For --fake-super, the dir must be useable by the copying\n\t\t\t * user, just like it would be for root. */\n\t\t\tadded_perms = S_IRUSR|S_IWUSR|S_IXUSR;\n\t\t} else\n\t\t\tadded_perms = 0;\n\t\tif (is_dir < 0) {\n\t\t\tif (!preserve_mtimes || omit_dir_times)\n\t\t\t\tgoto cleanup;\n\t\t\t/* In inc_recurse mode we want to make sure any missing\n\t\t\t * directories get created while we're still processing\n\t\t\t * the parent dir (which allows us to touch the parent\n\t\t\t * dir's mtime right away).  We will handle the dir in\n\t\t\t * full later (right before we handle its contents). */\n\t\t\tif (statret == 0\n\t\t\t && (stype == FT_DIR\n\t\t\t  || delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0))\n\t\t\t\tgoto cleanup; /* Any errors get reported later. */\n\t\t\tif (do_mkdir(fname, (file->mode|added_perms) & 0700) == 0)\n\t\t\t\tfile->flags |= FLAG_DIR_CREATED;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* The file to be received is a directory, so we need\n\t\t * to prepare appropriately.  If there is already a\n\t\t * file of that name and it is *not* a directory, then\n\t\t * we need to delete it.  If it doesn't exist, then\n\t\t * (perhaps recursively) create it. */\n\t\tif (statret == 0 && stype != FT_DIR) {\n\t\t\tif (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0)\n\t\t\t\tgoto skipping_dir_contents;\n\t\t\tstatret = -1;\n\t\t}\n\t\tif (dry_run && statret != 0) {\n\t\t\tif (!dry_missing_dir)\n\t\t\t\tdry_missing_dir = file;\n\t\t\tfile->flags |= FLAG_MISSING_DIR;\n\t\t}\n\t\tinit_stat_x(&real_sx);\n\t\treal_sx.st = sx.st;\n\t\treal_ret = statret;\n\t\tif (file->flags & FLAG_DIR_CREATED)\n\t\t\tstatret = -1;\n\t\tif (!preserve_perms) { /* See comment in non-dir code below. */\n\t\t\tfile->mode = dest_mode(file->mode, sx.st.st_mode, dflt_perms, statret == 0);\n\t\t}\n\t\tif (statret != 0 && basis_dir[0] != NULL) {\n\t\t\tint j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx, itemizing, code);\n\t\t\tif (j == -2) {\n\t\t\t\titemizing = 0;\n\t\t\t\tcode = FNONE;\n\t\t\t\tstatret = 1;\n\t\t\t} else if (j >= 0) {\n\t\t\t\tstatret = 1;\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t}\n\t\t}\n\t\tif (itemizing && f_out != -1) {\n\t\t\titemize(fnamecmp, file, ndx, statret, &sx,\n\t\t\t\tstatret ? ITEM_LOCAL_CHANGE : 0, 0, NULL);\n\t\t}\n\t\tif (real_ret != 0 && do_mkdir(fname,file->mode|added_perms) < 0 && errno != EEXIST) {\n\t\t\tif (!relative_paths || errno != ENOENT\n\t\t\t || make_path(fname, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0\n\t\t\t || (do_mkdir(fname, file->mode|added_perms) < 0 && errno != EEXIST)) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"recv_generator: mkdir %s failed\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t  skipping_dir_contents:\n\t\t\t\trprintf(FERROR, \"*** Skipping any contents from this failed directory ***\\n\");\n\t\t\t\tskip_dir = file;\n\t\t\t\tfile->flags |= FLAG_MISSING_DIR;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && statret == 1)\n\t\t\tcopy_xattrs(fnamecmpbuf, fname);\n#endif\n\t\tif (set_file_attrs(fname, file, real_ret ? NULL : &real_sx, NULL, 0)\n\t\t && INFO_GTE(NAME, 1) && code != FNONE && f_out != -1)\n\t\t\trprintf(code, \"%s/\\n\", fname);\n\n\t\t/* We need to ensure that the dirs in the transfer have both\n\t\t * readable and writable permissions during the time we are\n\t\t * putting files within them.  This is then restored to the\n\t\t * former permissions after the transfer is done. */\n#ifdef HAVE_CHMOD\n\t\tif (!am_root && (file->mode & S_IRWXU) != S_IRWXU && dir_tweaking) {\n\t\t\tmode_t mode = file->mode | S_IRWXU;\n\t\t\tif (do_chmod(fname, mode) < 0) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"failed to modify permissions on %s\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t}\n\t\t\tneed_retouch_dir_perms = 1;\n\t\t}\n#endif\n\n\t\tif (real_ret != 0 && one_file_system)\n\t\t\treal_sx.st.st_dev = filesystem_dev;\n\t\tif (inc_recurse) {\n\t\t\tif (one_file_system) {\n\t\t\t\tuint32 *devp = F_DIR_DEV_P(file);\n\t\t\t\tDEV_MAJOR(devp) = major(real_sx.st.st_dev);\n\t\t\t\tDEV_MINOR(devp) = minor(real_sx.st.st_dev);\n\t\t\t}\n\t\t}\n\t\telse if (delete_during && f_out != -1 && !phase\n\t\t    && !(file->flags & FLAG_MISSING_DIR)) {\n\t\t\tif (file->flags & FLAG_CONTENT_DIR)\n\t\t\t\tdelete_in_dir(fname, file, real_sx.st.st_dev);\n\t\t\telse\n\t\t\t\tchange_local_filter_dir(fname, strlen(fname), F_DEPTH(file));\n\t\t}\n\t\tprior_dir_file = file;\n\t\tgoto cleanup;\n\t}\n\n\t/* If we're not preserving permissions, change the file-list's\n\t * mode based on the local permissions and some heuristics. */\n\tif (!preserve_perms) {\n\t\tint exists = statret == 0 && stype != FT_DIR;\n\t\tfile->mode = dest_mode(file->mode, sx.st.st_mode, dflt_perms, exists);\n\t}\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && F_HLINK_NOT_FIRST(file)\n\t && hard_link_check(file, ndx, fname, statret, &sx, itemizing, code))\n\t\tgoto cleanup;\n#endif\n\n\tif (preserve_links && ftype == FT_SYMLINK) {\n#ifdef SUPPORT_LINKS\n\t\tconst char *sl = F_SYMLINK(file);\n\t\tif (safe_symlinks && unsafe_symlink(sl, fname)) {\n\t\t\tif (INFO_GTE(NAME, 1)) {\n\t\t\t\tif (solo_file) {\n\t\t\t\t\t/* fname contains the destination path, but we\n\t\t\t\t\t * want to report the source path. */\n\t\t\t\t\tfname = f_name(file, NULL);\n\t\t\t\t}\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"ignoring unsafe symlink \\\"%s\\\" -> \\\"%s\\\"\\n\",\n\t\t\t\t\tfname, sl);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (statret == 0) {\n\t\t\tif (stype == FT_SYMLINK && quick_check_ok(stype, fname, file, &sx.st)) {\n\t\t\t\t/* The link is pointing to the right place. */\n\t\t\t\tset_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);\n\t\t\t\tif (itemizing)\n\t\t\t\t\titemize(fname, file, ndx, 0, &sx, 0, 0, NULL);\n#ifdef SUPPORT_HARD_LINKS\n\t\t\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\t\t\tfinish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);\n#endif\n\t\t\t\tif (remove_source_files == 1)\n\t\t\t\t\tgoto return_with_success;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else if (basis_dir[0] != NULL) {\n\t\t\tint j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx, itemizing, code);\n\t\t\tif (j == -2) {\n#ifndef CAN_HARDLINK_SYMLINK\n\t\t\t\tif (alt_dest_type == LINK_DEST) {\n\t\t\t\t\t/* Resort to --copy-dest behavior. */\n\t\t\t\t} else\n#endif\n\t\t\t\tif (alt_dest_type != COPY_DEST)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\titemizing = 0;\n\t\t\t\tcode = FNONE;\n\t\t\t} else if (j >= 0) {\n\t\t\t\tstatret = 1;\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t}\n\t\t}\n\t\tif (atomic_create(file, fname, sl, NULL, MAKEDEV(0, 0), &sx, statret == 0 ? DEL_FOR_SYMLINK : 0)) {\n\t\t\tset_file_attrs(fname, file, NULL, NULL, 0);\n\t\t\tif (itemizing) {\n\t\t\t\tif (statret == 0 && stype != FT_SYMLINK)\n\t\t\t\t\tstatret = -1;\n\t\t\t\titemize(fnamecmp, file, ndx, statret, &sx,\n\t\t\t\t\tITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);\n\t\t\t}\n\t\t\tif (code != FNONE && INFO_GTE(NAME, 1))\n\t\t\t\trprintf(code, \"%s -> %s\\n\", fname, sl);\n#ifdef SUPPORT_HARD_LINKS\n\t\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\t\tfinish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);\n#endif\n\t\t\t/* This does not check remove_source_files == 1\n\t\t\t * because this is one of the items that the old\n\t\t\t * --remove-sent-files option would remove. */\n\t\t\tif (remove_source_files)\n\t\t\t\tgoto return_with_success;\n\t\t}\n#endif\n\t\tgoto cleanup;\n\t}\n\n\tif ((am_root && preserve_devices && ftype == FT_DEVICE)\n\t || (preserve_specials && ftype == FT_SPECIAL)) {\n\t\tdev_t rdev;\n\t\tint del_for_flag;\n\t\tif (ftype == FT_DEVICE) {\n\t\t\tuint32 *devp = F_RDEV_P(file);\n\t\t\trdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));\n\t\t\tdel_for_flag = DEL_FOR_DEVICE;\n\t\t} else {\n\t\t\trdev = 0;\n\t\t\tdel_for_flag = DEL_FOR_SPECIAL;\n\t\t}\n\t\tif (statret == 0) {\n\t\t\tif (ftype != stype)\n\t\t\t\tstatret = -1;\n\t\t\telse if (quick_check_ok(ftype, fname, file, &sx.st)) {\n\t\t\t\t/* The device or special file is identical. */\n\t\t\t\tset_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);\n\t\t\t\tif (itemizing)\n\t\t\t\t\titemize(fname, file, ndx, 0, &sx, 0, 0, NULL);\n#ifdef SUPPORT_HARD_LINKS\n\t\t\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\t\t\tfinish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);\n#endif\n\t\t\t\tif (remove_source_files == 1)\n\t\t\t\t\tgoto return_with_success;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else if (basis_dir[0] != NULL) {\n\t\t\tint j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx, itemizing, code);\n\t\t\tif (j == -2) {\n#ifndef CAN_HARDLINK_SPECIAL\n\t\t\t\tif (alt_dest_type == LINK_DEST) {\n\t\t\t\t\t/* Resort to --copy-dest behavior. */\n\t\t\t\t} else\n#endif\n\t\t\t\tif (alt_dest_type != COPY_DEST)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\titemizing = 0;\n\t\t\t\tcode = FNONE;\n\t\t\t} else if (j >= 0) {\n\t\t\t\tstatret = 1;\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t}\n\t\t}\n\t\tif (DEBUG_GTE(GENR, 1)) {\n\t\t\trprintf(FINFO, \"mknod(%s, 0%o, [%ld,%ld])\\n\",\n\t\t\t\tfname, (int)file->mode,\n\t\t\t\t(long)major(rdev), (long)minor(rdev));\n\t\t}\n\t\tif (atomic_create(file, fname, NULL, NULL, rdev, &sx, del_for_flag)) {\n\t\t\tset_file_attrs(fname, file, NULL, NULL, 0);\n\t\t\tif (itemizing) {\n\t\t\t\titemize(fnamecmp, file, ndx, statret, &sx,\n\t\t\t\t\tITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);\n\t\t\t}\n\t\t\tif (code != FNONE && INFO_GTE(NAME, 1))\n\t\t\t\trprintf(code, \"%s\\n\", fname);\n#ifdef SUPPORT_HARD_LINKS\n\t\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\t\tfinish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);\n#endif\n\t\t\tif (remove_source_files == 1)\n\t\t\t\tgoto return_with_success;\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tif (ftype != FT_REG) {\n\t\tif (INFO_GTE(NONREG, 1)) {\n\t\t\tif (solo_file)\n\t\t\t\tfname = f_name(file, NULL);\n\t\t\trprintf(FINFO, \"skipping non-regular file \\\"%s\\\"\\n\", fname);\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tif (max_size >= 0 && F_LENGTH(file) > max_size) {\n\t\tif (INFO_GTE(SKIP, 1)) {\n\t\t\tif (solo_file)\n\t\t\t\tfname = f_name(file, NULL);\n\t\t\trprintf(FINFO, \"%s is over max-size\\n\", fname);\n\t\t}\n\t\tgoto cleanup;\n\t}\n\tif (min_size >= 0 && F_LENGTH(file) < min_size) {\n\t\tif (INFO_GTE(SKIP, 1)) {\n\t\t\tif (solo_file)\n\t\t\t\tfname = f_name(file, NULL);\n\t\t\trprintf(FINFO, \"%s is under min-size\\n\", fname);\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tif (update_only > 0 && statret == 0 && file->modtime - sx.st.st_mtime < modify_window) {\n\t\tif (INFO_GTE(SKIP, 1))\n\t\t\trprintf(FINFO, \"%s is newer\\n\", fname);\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (F_IS_HLINKED(file))\n\t\t\thandle_skipped_hlink(file, itemizing, code, f_out);\n#endif\n\t\tgoto cleanup;\n\t}\n\n\tfnamecmp_type = FNAMECMP_FNAME;\n\n\tif (statret == 0 && !(stype == FT_REG || (write_devices && stype == FT_DEVICE))) {\n\t\tif (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_FILE) != 0)\n\t\t\tgoto cleanup;\n\t\tstatret = -1;\n\t\tstat_errno = ENOENT;\n\t}\n\n\tif (basis_dir[0] != NULL && (statret != 0 || alt_dest_type != COPY_DEST)) {\n\t\tint j = try_dests_reg(file, fname, ndx, fnamecmpbuf, &sx, statret == 0, itemizing, code);\n\t\tif (j == -2) {\n\t\t\tif (remove_source_files == 1)\n\t\t\t\tgoto return_with_success;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (j >= 0) {\n\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\tfnamecmp_type = j;\n\t\t\tstatret = 0;\n\t\t}\n\t}\n\n\tinit_stat_x(&real_sx);\n\treal_sx.st = sx.st; /* Don't copy xattr/acl pointers, as they would free wrong. */\n\treal_ret = statret;\n\n\tif (partial_dir && (partialptr = partial_dir_fname(fname)) != NULL\n\t && link_stat(partialptr, &partial_st, 0) == 0\n\t && S_ISREG(partial_st.st_mode)) {\n\t\tif (statret != 0)\n\t\t\tgoto prepare_to_open;\n\t} else\n\t\tpartialptr = NULL;\n\n\tif (statret != 0 && fuzzy_basis) {\n\t\tif (need_fuzzy_dirlist) {\n\t\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\t\tint i;\n\t\t\tstrlcpy(fnamecmpbuf, dn, sizeof fnamecmpbuf);\n\t\t\tfor (i = 0; i < fuzzy_basis; i++) {\n\t\t\t\tif (i && pathjoin(fnamecmpbuf, MAXPATHLEN, basis_dir[i-1], dn) >= MAXPATHLEN)\n\t\t\t\t\tcontinue;\n\t\t\t\tfuzzy_dirlist[i] = get_dirlist(fnamecmpbuf, -1, GDL_IGNORE_FILTER_RULES | GDL_PERHAPS_DIR);\n\t\t\t\tif (fuzzy_dirlist[i] && fuzzy_dirlist[i]->used == 0) {\n\t\t\t\t\tflist_free(fuzzy_dirlist[i]);\n\t\t\t\t\tfuzzy_dirlist[i] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed_fuzzy_dirlist = 0;\n\t\t}\n\n\t\t/* Sets fnamecmp_type to FNAMECMP_FUZZY or above. */\n\t\tfuzzy_file = find_fuzzy(file, fuzzy_dirlist, &fnamecmp_type);\n\t\tif (fuzzy_file) {\n\t\t\tf_name(fuzzy_file, fnamecmpbuf);\n\t\t\tif (DEBUG_GTE(FUZZY, 1)) {\n\t\t\t\trprintf(FINFO, \"fuzzy basis selected for %s: %s\\n\",\n\t\t\t\t\tfname, fnamecmpbuf);\n\t\t\t}\n\t\t\tsx.st.st_size = F_LENGTH(fuzzy_file);\n\t\t\tstatret = 0;\n\t\t\tfnamecmp = fnamecmpbuf;\n\t\t}\n\t}\n\n\tif (statret != 0) {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && F_HLINK_NOT_LAST(file)) {\n\t\t\tcur_flist->in_progress++;\n\t\t\tgoto cleanup;\n\t\t}\n#endif\n\t\tif (stat_errno == ENOENT)\n\t\t\tgoto notify_others;\n\t\trsyserr(FERROR_XFER, stat_errno, \"recv_generator: failed to stat %s\",\n\t\t\tfull_fname(fname));\n\t\tgoto cleanup;\n\t}\n\n\tif (write_devices && IS_DEVICE(sx.st.st_mode) && sx.st.st_size == 0) {\n\t\t/* This early open into fd skips the regular open below. */\n\t\tif ((fd = do_open(fnamecmp, O_RDONLY, 0)) >= 0)\n\t\t\treal_sx.st.st_size = sx.st.st_size = get_device_size(fd, fnamecmp);\n\t}\n\n\tif (fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)\n\t\t;\n\telse if (fnamecmp_type >= FNAMECMP_FUZZY)\n\t\t;\n\telse if (quick_check_ok(FT_REG, fnamecmp, file, &sx.st)) {\n\t\tif (partialptr) {\n\t\t\tdo_unlink(partialptr);\n\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t}\n\t\tset_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT | maybe_ATTRS_ACCURATE_TIME);\n\t\tif (itemizing)\n\t\t\titemize(fnamecmp, file, ndx, statret, &sx, 0, 0, NULL);\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\tfinish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);\n#endif\n\t\tif (remove_source_files != 1)\n\t\t\tgoto cleanup;\n\t  return_with_success:\n\t\tif (!dry_run)\n\t\t\tsend_msg_success(fname, ndx);\n\t\tgoto cleanup;\n\t}\n\n\tif (append_mode > 0 && sx.st.st_size >= F_LENGTH(file)) {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (F_IS_HLINKED(file))\n\t\t\thandle_skipped_hlink(file, itemizing, code, f_out);\n#endif\n\t\tgoto cleanup;\n\t}\n\n  prepare_to_open:\n\tif (partialptr) {\n\t\tsx.st = partial_st;\n\t\tfnamecmp = partialptr;\n\t\tfnamecmp_type = FNAMECMP_PARTIAL_DIR;\n\t\tstatret = 0;\n\t}\n\n\tif (!do_xfers)\n\t\tgoto notify_others;\n\n\tif (read_batch || whole_file) {\n\t\tif (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {\n\t\t\tif (!(backupptr = get_backup_name(fname)))\n\t\t\t\tgoto cleanup;\n\t\t\tif (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))\n\t\t\t\tgoto pretend_missing;\n\t\t\tif (copy_file(fname, backupptr, -1, back_file->mode) < 0) {\n\t\t\t\tunmake_file(back_file);\n\t\t\t\tback_file = NULL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tgoto notify_others;\n\t}\n\n\tif (fuzzy_dirlist[0]) {\n\t\tint j = flist_find(fuzzy_dirlist[0], file);\n\t\tif (j >= 0) /* don't use changing file as future fuzzy basis */\n\t\t\tfuzzy_dirlist[0]->files[j]->flags |= FLAG_FILE_SENT;\n\t}\n\n\t/* open the file */\n\tif (fd < 0 && (fd = do_open(fnamecmp, O_RDONLY, 0)) < 0) {\n\t\trsyserr(FERROR, errno, \"failed to open %s, continuing\",\n\t\t\tfull_fname(fnamecmp));\n\t  pretend_missing:\n\t\t/* pretend the file didn't exist */\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && F_HLINK_NOT_LAST(file)) {\n\t\t\tcur_flist->in_progress++;\n\t\t\tgoto cleanup;\n\t\t}\n#endif\n\t\tstatret = real_ret = -1;\n\t\tgoto notify_others;\n\t}\n\n\tif (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {\n\t\tif (!(backupptr = get_backup_name(fname))) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS))) {\n\t\t\tgoto pretend_missing;\n\t\t}\n\t\tif (robust_unlink(backupptr) && errno != ENOENT) {\n\t\t\trsyserr(FERROR_XFER, errno, \"unlink %s\",\n\t\t\t\tfull_fname(backupptr));\n\t\t\tunmake_file(back_file);\n\t\t\tback_file = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((f_copy = do_open(backupptr, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"open %s\", full_fname(backupptr));\n\t\t\tunmake_file(back_file);\n\t\t\tback_file = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfnamecmp_type = FNAMECMP_BACKUP;\n\t}\n\n\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\trprintf(FINFO, \"gen mapped %s of size %s\\n\",\n\t\t\tfnamecmp, big_num(sx.st.st_size));\n\t}\n\n\tif (DEBUG_GTE(DELTASUM, 2))\n\t\trprintf(FINFO, \"generating and sending sums for %d\\n\", ndx);\n\n  notify_others:\n\tif (remove_source_files && !delay_updates && !phase && !dry_run)\n\t\tincrement_active_files(ndx, itemizing, code);\n\tif (inc_recurse && (!dry_run || write_batch < 0))\n\t\tcur_flist->in_progress++;\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\tfile->flags |= FLAG_FILE_SENT;\n#endif\n\twrite_ndx(f_out, ndx);\n\tif (itemizing) {\n\t\tint iflags = ITEM_TRANSFER;\n\t\tif (always_checksum > 0)\n\t\t\tiflags |= ITEM_REPORT_CHANGE;\n\t\tif (fnamecmp_type != FNAMECMP_FNAME)\n\t\t\tiflags |= ITEM_BASIS_TYPE_FOLLOWS;\n\t\tif (fnamecmp_type >= FNAMECMP_FUZZY)\n\t\t\tiflags |= ITEM_XNAME_FOLLOWS;\n\t\titemize(fnamecmp, file, -1, real_ret, &real_sx, iflags, fnamecmp_type,\n\t\t\tfuzzy_file ? fuzzy_file->basename : NULL);\n\t\tfree_stat_x(&real_sx);\n\t}\n\n\tif (!do_xfers) {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && F_IS_HLINKED(file))\n\t\t\tfinish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);\n#endif\n\t\tgoto cleanup;\n\t}\n\tif (read_batch)\n\t\tgoto cleanup;\n\n\tif (statret != 0 || whole_file)\n\t\twrite_sum_head(f_out, NULL);\n\telse if (sx.st.st_size <= 0) {\n\t\twrite_sum_head(f_out, NULL);\n\t} else {\n\t\tif (generate_and_send_sums(fd, sx.st.st_size, f_out, f_copy) < 0) {\n\t\t\trprintf(FWARNING,\n\t\t\t\t\"WARNING: file is too large for checksum sending: %s\\n\",\n\t\t\t\tfnamecmp);\n\t\t\twrite_sum_head(f_out, NULL);\n\t\t}\n\t}\n\n  cleanup:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (back_file) {\n\t\tint save_preserve_xattrs = preserve_xattrs;\n\t\tif (f_copy >= 0)\n\t\t\tclose(f_copy);\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs) {\n\t\t\tcopy_xattrs(fname, backupptr);\n\t\t\tpreserve_xattrs = 0;\n\t\t}\n#endif\n\t\tset_file_attrs(backupptr, back_file, NULL, NULL, 0);\n\t\tpreserve_xattrs = save_preserve_xattrs;\n\t\tif (INFO_GTE(BACKUP, 1)) {\n\t\t\trprintf(FINFO, \"backed up %s to %s\\n\",\n\t\t\t\tfname, backupptr);\n\t\t}\n\t\tunmake_file(back_file);\n\t}\n\n\tfree_stat_x(&sx);\n}\n\n/* If we are replacing an existing hard link, symlink, device, or special file,\n * create a temp-name item and rename it into place.  A symlimk specifies slnk,\n * a hard link specifies hlnk, otherwise we create a device based on rdev.\n * Specify 0 for the del_for_flag if there is not a file to replace.  This\n * returns 1 on success and 0 on failure. */\nint atomic_create(struct file_struct *file, char *fname, const char *slnk, const char *hlnk,\n\t\t  dev_t rdev, stat_x *sxp, int del_for_flag)\n{\n\tchar tmpname[MAXPATHLEN];\n\tconst char *create_name;\n\tint skip_atomic, dir_in_the_way = del_for_flag && S_ISDIR(sxp->st.st_mode);\n\n\tif (!del_for_flag || dir_in_the_way || tmpdir || !get_tmpname(tmpname, fname, True))\n\t\tskip_atomic = 1;\n\telse\n\t\tskip_atomic = 0;\n\n\tif (del_for_flag) {\n\t\tif (make_backups > 0 && !dir_in_the_way) {\n\t\t\tif (!make_backup(fname, skip_atomic))\n\t\t\t\treturn 0;\n\t\t} else if (skip_atomic) {\n\t\t\tint del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;\n\t\t\tif (delete_item(fname, sxp->st.st_mode, del_opts | del_for_flag) != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcreate_name = skip_atomic ? fname : tmpname;\n\n\tif (slnk) {\n#ifdef SUPPORT_LINKS\n\t\tif (do_symlink(slnk, create_name) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"symlink %s -> \\\"%s\\\" failed\",\n\t\t\t\tfull_fname(create_name), slnk);\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t} else if (hlnk) {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (!hard_link_one(file, create_name, hlnk, 0))\n\t\t\treturn 0;\n#else\n\t\treturn 0;\n#endif\n\t} else {\n\t\tif (do_mknod(create_name, file->mode, rdev) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"mknod %s failed\",\n\t\t\t\tfull_fname(create_name));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!skip_atomic) {\n\t\tif (do_rename(tmpname, fname) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"rename %s -> \\\"%s\\\" failed\",\n\t\t\t\tfull_fname(tmpname), full_fname(fname));\n\t\t\tdo_unlink(tmpname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#ifdef SUPPORT_HARD_LINKS\nstatic void handle_skipped_hlink(struct file_struct *file, int itemizing,\n\t\t\t\t enum logcode code, int f_out)\n{\n\tchar fbuf[MAXPATHLEN];\n\tint new_last_ndx;\n\tstruct file_list *save_flist = cur_flist;\n\n\t/* If we skip the last item in a chain of links and there was a\n\t * prior non-skipped hard-link waiting to finish, finish it now. */\n\tif ((new_last_ndx = skip_hard_link(file, &cur_flist)) < 0)\n\t\treturn;\n\n\tfile = cur_flist->files[new_last_ndx - cur_flist->ndx_start];\n\tcur_flist->in_progress--; /* undo prior increment */\n\tf_name(file, fbuf);\n\trecv_generator(fbuf, file, new_last_ndx, itemizing, code, f_out);\n\n\tcur_flist = save_flist;\n}\n#endif\n\nstatic void touch_up_dirs(struct file_list *flist, int ndx)\n{\n\tstatic int counter = 0;\n\tstruct file_struct *file;\n\tchar *fname;\n\tBOOL fix_dir_perms;\n\tint i, start, end;\n\n\tif (ndx < 0) {\n\t\tstart = 0;\n\t\tend = flist->used - 1;\n\t} else\n\t\tstart = end = ndx;\n\n\t/* Fix any directory permissions that were modified during the\n\t * transfer and/or re-set any tweaked modified-time values. */\n\tfor (i = start; i <= end; i++, counter++) {\n\t\tfile = flist->files[i];\n\t\tif (!F_IS_ACTIVE(file))\n\t\t\tcontinue;\n\t\tif (!S_ISDIR(file->mode)\n\t\t || (!implied_dirs && file->flags & FLAG_IMPLIED_DIR))\n\t\t\tcontinue;\n\t\tif (DEBUG_GTE(TIME, 2)) {\n\t\t\tfname = f_name(file, NULL);\n\t\t\trprintf(FINFO, \"touch_up_dirs: %s (%d)\\n\",\n\t\t\t\tNS(fname), i);\n\t\t}\n\t\t/* Be sure not to retouch permissions with --fake-super. */\n\t\tfix_dir_perms = !am_root && !(file->mode & S_IWUSR);\n\t\tif (file->flags & FLAG_MISSING_DIR || !(need_retouch_dir_times || fix_dir_perms))\n\t\t\tcontinue;\n\t\tfname = f_name(file, NULL);\n\t\tif (fix_dir_perms)\n\t\t\tdo_chmod(fname, file->mode);\n\t\tif (need_retouch_dir_times) {\n\t\t\tSTRUCT_STAT st;\n\t\t\tif (link_stat(fname, &st, 0) == 0 && mtime_differs(&st, file)) {\n\t\t\t\tst.st_mtime = file->modtime;\n#ifdef ST_MTIME_NSEC\n\t\t\t\tst.ST_MTIME_NSEC = F_MOD_NSEC_or_0(file);\n#endif\n\t\t\t\tset_times(fname, &st);\n\t\t\t}\n\t\t}\n\t\tif (counter >= loopchk_limit) {\n\t\t\tif (allowed_lull)\n\t\t\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);\n\t\t\telse\n\t\t\t\tmaybe_flush_socket(0);\n\t\t\tcounter = 0;\n\t\t}\n\t}\n}\n\nvoid check_for_finished_files(int itemizing, enum logcode code, int check_redo)\n{\n\tstruct file_struct *file;\n\tstruct file_list *flist;\n\tchar fbuf[MAXPATHLEN];\n\tint ndx;\n\n\twhile (1) {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && (ndx = get_hlink_num()) != -1) {\n\t\t\tint send_failed = (ndx == -2);\n\t\t\tif (send_failed)\n\t\t\t\tndx = get_hlink_num();\n\t\t\tflist = flist_for_ndx(ndx, \"check_for_finished_files.1\");\n\t\t\tfile = flist->files[ndx - flist->ndx_start];\n\t\t\tassert(file->flags & FLAG_HLINKED);\n\t\t\tif (send_failed)\n\t\t\t\thandle_skipped_hlink(file, itemizing, code, sock_f_out);\n\t\t\telse\n\t\t\t\tfinish_hard_link(file, f_name(file, fbuf), ndx, NULL, itemizing, code, -1);\n\t\t\tflist->in_progress--;\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif (check_redo && (ndx = get_redo_num()) != -1) {\n\t\t\tOFF_T save_max_size = max_size;\n\t\t\tOFF_T save_min_size = min_size;\n\t\t\tcsum_length = SUM_LENGTH;\n\t\t\tmax_size = -1;\n\t\t\tmin_size = -1;\n\t\t\tignore_existing = -ignore_existing;\n\t\t\tignore_non_existing = -ignore_non_existing;\n\t\t\tupdate_only = -update_only;\n\t\t\talways_checksum = -always_checksum;\n\t\t\tsize_only = -size_only;\n\t\t\tappend_mode = -append_mode;\n\t\t\tmake_backups = -make_backups; /* avoid dup backup w/inplace */\n\t\t\tignore_times++;\n\n\t\t\tflist = cur_flist;\n\t\t\tcur_flist = flist_for_ndx(ndx, \"check_for_finished_files.2\");\n\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\t\tif (solo_file)\n\t\t\t\tstrlcpy(fbuf, solo_file, sizeof fbuf);\n\t\t\telse\n\t\t\t\tf_name(file, fbuf);\n\t\t\trecv_generator(fbuf, file, ndx, itemizing, code, sock_f_out);\n\t\t\tcur_flist->to_redo--;\n\n\t\t\tcur_flist = flist;\n\n\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\tmax_size = save_max_size;\n\t\t\tmin_size = save_min_size;\n\t\t\tignore_existing = -ignore_existing;\n\t\t\tignore_non_existing = -ignore_non_existing;\n\t\t\tupdate_only = -update_only;\n\t\t\talways_checksum = -always_checksum;\n\t\t\tsize_only = -size_only;\n\t\t\tappend_mode = -append_mode;\n\t\t\tmake_backups = -make_backups;\n\t\t\tignore_times--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cur_flist == first_flist)\n\t\t\tbreak;\n\n\t\t/* We only get here if inc_recurse is enabled. */\n\t\tif (first_flist->in_progress || first_flist->to_redo)\n\t\t\tbreak;\n\n\t\twrite_ndx(sock_f_out, NDX_DONE);\n\t\tif (!read_batch && !flist_eof) {\n\t\t\tint old_total = 0;\n\t\t\tfor (flist = first_flist; flist != cur_flist; flist = flist->next)\n\t\t\t\told_total += flist->used;\n\t\t\tmaybe_flush_socket(!flist_eof && file_total - old_total < MIN_FILECNT_LOOKAHEAD/2);\n\t\t}\n\n\t\tif (delete_during == 2 || !dir_tweaking) {\n\t\t\t/* Skip directory touch-up. */\n\t\t} else if (first_flist->parent_ndx >= 0)\n\t\t\ttouch_up_dirs(dir_flist, first_flist->parent_ndx);\n\n\t\tflist_free(first_flist); /* updates first_flist */\n\t}\n}\n\nvoid generate_files(int f_out, const char *local_name)\n{\n\tint i, ndx, next_loopchk = 0;\n\tchar fbuf[MAXPATHLEN];\n\tint itemizing;\n\tenum logcode code;\n\tint save_info_flist = info_levels[INFO_FLIST];\n\tint save_info_progress = info_levels[INFO_PROGRESS];\n\n\tif (protocol_version >= 29) {\n\t\titemizing = 1;\n\t\tmaybe_ATTRS_REPORT = stdout_format_has_i ? 0 : ATTRS_REPORT;\n\t\tcode = logfile_format_has_i ? FNONE : FLOG;\n\t} else if (am_daemon) {\n\t\titemizing = logfile_format_has_i && do_xfers;\n\t\tmaybe_ATTRS_REPORT = ATTRS_REPORT;\n\t\tcode = itemizing || !do_xfers ? FCLIENT : FINFO;\n\t} else if (!am_server) {\n\t\titemizing = stdout_format_has_i;\n\t\tmaybe_ATTRS_REPORT = stdout_format_has_i ? 0 : ATTRS_REPORT;\n\t\tcode = itemizing ? FNONE : FINFO;\n\t} else {\n\t\titemizing = 0;\n\t\tmaybe_ATTRS_REPORT = ATTRS_REPORT;\n\t\tcode = FINFO;\n\t}\n\tsolo_file = local_name;\n\tdir_tweaking = !(list_only || solo_file || dry_run);\n\tneed_retouch_dir_times = preserve_mtimes && !omit_dir_times;\n\tloopchk_limit = allowed_lull ? allowed_lull * 5 : 200;\n\tsymlink_timeset_failed_flags = ITEM_REPORT_TIME\n\t    | (protocol_version >= 30 || !am_server ? ITEM_REPORT_TIMEFAIL : 0);\n\timplied_dirs_are_missing = relative_paths && !implied_dirs && protocol_version < 30;\n\n\tif (DEBUG_GTE(GENR, 1))\n\t\trprintf(FINFO, \"generator starting pid=%d\\n\", (int)getpid());\n\n\tif (delete_before && !solo_file && cur_flist->used > 0)\n\t\tdo_delete_pass();\n\tif (delete_during == 2) {\n\t\tdeldelay_size = BIGPATHBUFLEN * 4;\n\t\tdeldelay_buf = new_array(char, deldelay_size);\n\t}\n\tinfo_levels[INFO_FLIST] = info_levels[INFO_PROGRESS] = 0;\n\n\tif (append_mode > 0 || whole_file < 0)\n\t\twhole_file = 0;\n\tif (DEBUG_GTE(FLIST, 1)) {\n\t\trprintf(FINFO, \"delta-transmission %s\\n\",\n\t\t\twhole_file\n\t\t\t? \"disabled for local transfer or --whole-file\"\n\t\t\t: \"enabled\");\n\t}\n\n\tdflt_perms = (ACCESSPERMS & ~orig_umask);\n\n\tdo {\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links && inc_recurse) {\n\t\t\twhile (!flist_eof && file_total < MIN_FILECNT_LOOKAHEAD/2)\n\t\t\t\twait_for_receiver();\n\t\t}\n#endif\n\n\t\tif (inc_recurse && cur_flist->parent_ndx >= 0) {\n\t\t\tstruct file_struct *fp = dir_flist->files[cur_flist->parent_ndx];\n\t\t\tif (solo_file)\n\t\t\t\tstrlcpy(fbuf, solo_file, sizeof fbuf);\n\t\t\telse\n\t\t\t\tf_name(fp, fbuf);\n\t\t\tndx = cur_flist->ndx_start - 1;\n\t\t\trecv_generator(fbuf, fp, ndx, itemizing, code, f_out);\n\t\t\tif (delete_during && dry_run < 2 && !list_only\n\t\t\t && !(fp->flags & FLAG_MISSING_DIR)) {\n\t\t\t\tif (fp->flags & FLAG_CONTENT_DIR) {\n\t\t\t\t\tdev_t dirdev;\n\t\t\t\t\tif (one_file_system) {\n\t\t\t\t\t\tuint32 *devp = F_DIR_DEV_P(fp);\n\t\t\t\t\t\tdirdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));\n\t\t\t\t\t} else\n\t\t\t\t\t\tdirdev = MAKEDEV(0, 0);\n\t\t\t\t\tdelete_in_dir(fbuf, fp, dirdev);\n\t\t\t\t} else\n\t\t\t\t\tchange_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(fp));\n\t\t\t}\n\t\t}\n\t\tfor (i = cur_flist->low; i <= cur_flist->high; i++) {\n\t\t\tstruct file_struct *file = cur_flist->sorted[i];\n\n\t\t\tif (!F_IS_ACTIVE(file))\n\t\t\t\tcontinue;\n\n\t\t\tif (unsort_ndx)\n\t\t\t\tndx = F_NDX(file);\n\t\t\telse\n\t\t\t\tndx = i + cur_flist->ndx_start;\n\n\t\t\tif (solo_file)\n\t\t\t\tstrlcpy(fbuf, solo_file, sizeof fbuf);\n\t\t\telse\n\t\t\t\tf_name(file, fbuf);\n\t\t\trecv_generator(fbuf, file, ndx, itemizing, code, f_out);\n\n\t\t\tcheck_for_finished_files(itemizing, code, 0);\n\n\t\t\tif (i + cur_flist->ndx_start >= next_loopchk) {\n\t\t\t\tif (allowed_lull)\n\t\t\t\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);\n\t\t\t\telse\n\t\t\t\t\tmaybe_flush_socket(0);\n\t\t\t\tnext_loopchk += loopchk_limit;\n\t\t\t}\n\t\t}\n\n\t\tif (!inc_recurse) {\n\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tcheck_for_finished_files(itemizing, code, 1);\n\t\t\tif (cur_flist->next || flist_eof)\n\t\t\t\tbreak;\n\t\t\twait_for_receiver();\n\t\t}\n\t} while ((cur_flist = cur_flist->next) != NULL);\n\n\tif (delete_during)\n\t\tdelete_in_dir(NULL, NULL, dev_zero);\n\tphase++;\n\tif (DEBUG_GTE(GENR, 1))\n\t\trprintf(FINFO, \"generate_files phase=%d\\n\", phase);\n\n\twhile (1) {\n\t\tcheck_for_finished_files(itemizing, code, 1);\n\t\tif (msgdone_cnt)\n\t\t\tbreak;\n\t\twait_for_receiver();\n\t}\n\n\tphase++;\n\tif (DEBUG_GTE(GENR, 1))\n\t\trprintf(FINFO, \"generate_files phase=%d\\n\", phase);\n\n\twrite_ndx(f_out, NDX_DONE);\n\n\t/* Reduce round-trip lag-time for a useless delay-updates phase. */\n\tif (protocol_version >= 29 && EARLY_DELAY_DONE_MSG())\n\t\twrite_ndx(f_out, NDX_DONE);\n\n\tif (protocol_version >= 31 && EARLY_DELETE_DONE_MSG()) {\n\t\tif ((INFO_GTE(STATS, 2) && (delete_mode || force_delete)) || read_batch)\n\t\t\twrite_del_stats(f_out);\n\t\tif (EARLY_DELAY_DONE_MSG()) /* Can't send this before delay */\n\t\t\twrite_ndx(f_out, NDX_DONE);\n\t}\n\n\t/* Read MSG_DONE for the redo phase (and any prior messages). */\n\twhile (1) {\n\t\tcheck_for_finished_files(itemizing, code, 0);\n\t\tif (msgdone_cnt > 1)\n\t\t\tbreak;\n\t\twait_for_receiver();\n\t}\n\n\tif (protocol_version >= 29) {\n\t\tphase++;\n\t\tif (DEBUG_GTE(GENR, 1))\n\t\t\trprintf(FINFO, \"generate_files phase=%d\\n\", phase);\n\t\tif (!EARLY_DELAY_DONE_MSG()) {\n\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t\tif (protocol_version >= 31 && EARLY_DELETE_DONE_MSG())\n\t\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t}\n\t\t/* Read MSG_DONE for delay-updates phase & prior messages. */\n\t\twhile (msgdone_cnt == 2)\n\t\t\twait_for_receiver();\n\t}\n\n\tinfo_levels[INFO_FLIST] = save_info_flist;\n\tinfo_levels[INFO_PROGRESS] = save_info_progress;\n\n\tif (delete_during == 2)\n\t\tdo_delayed_deletions(fbuf);\n\tif (delete_after && !solo_file && file_total > 0)\n\t\tdo_delete_pass();\n\n\tif (max_delete >= 0 && skipped_deletes) {\n\t\trprintf(FWARNING,\n\t\t\t\"Deletions stopped due to --max-delete limit (%d skipped)\\n\",\n\t\t\tskipped_deletes);\n\t\tio_error |= IOERR_DEL_LIMIT;\n\t}\n\n\tif (protocol_version >= 31) {\n\t\tif (!EARLY_DELETE_DONE_MSG()) {\n\t\t\tif (INFO_GTE(STATS, 2) || read_batch)\n\t\t\t\twrite_del_stats(f_out);\n\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t}\n\n\t\t/* Read MSG_DONE for late-delete phase & prior messages. */\n\t\twhile (msgdone_cnt == 3)\n\t\t\twait_for_receiver();\n\t}\n\n\tif ((need_retouch_dir_perms || need_retouch_dir_times)\n\t && dir_tweaking && (!inc_recurse || delete_during == 2))\n\t\ttouch_up_dirs(dir_flist, -1);\n\n\tif (DEBUG_GTE(GENR, 1))\n\t\trprintf(FINFO, \"generate_files finished\\n\");\n}\n"
        },
        {
          "name": "getfsdev.c",
          "type": "blob",
          "size": 0.365234375,
          "content": "#include \"rsync.h\"\n\n int main(int argc, char *argv[])\n{\n\tSTRUCT_STAT st;\n\tint ret;\n\n\twhile (--argc > 0) {\n#ifdef USE_STAT64_FUNCS\n\t\tret = stat64(*++argv, &st);\n#else\n\t\tret = stat(*++argv, &st);\n#endif\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Unable to stat `%s'\\n\", *argv);\n\t\t\texit(1);\n\t\t}\n\t\tprintf(\"%ld/%ld\\n\", (long)major(st.st_dev), (long)minor(st.st_dev));\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "getgroups.c",
          "type": "blob",
          "size": 1.486328125,
          "content": "/*\n * Print out the gids of all groups for the current user.  This is like\n * `id -G` on Linux, but it's too hard to find a portable equivalent.\n *\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2003-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n int main(UNUSED(int argc), UNUSED(char *argv[]))\n{\n\tint n, i;\n\tgid_t *list;\n\tgid_t gid = MY_GID();\n\tint gid_in_list = 0;\n\n#ifdef HAVE_GETGROUPS\n\tif ((n = getgroups(0, NULL)) < 0) {\n\t\tperror(\"getgroups\");\n\t\treturn 1;\n\t}\n#else\n\tn = 0;\n#endif\n\n\tlist = (gid_t*)malloc(sizeof (gid_t) * (n + 1));\n\tif (!list) {\n\t\tfprintf(stderr, \"out of memory!\\n\");\n\t\texit(1);\n\t}\n\n#ifdef HAVE_GETGROUPS\n\tif (n > 0)\n\t\tn = getgroups(n, list);\n#endif\n\n\tfor (i = 0; i < n; i++)  {\n\t\tprintf(\"%lu \", (unsigned long)list[i]);\n\t\tif (list[i] == gid)\n\t\t\tgid_in_list = 1;\n\t}\n\t/* The default gid might not be in the list on some systems. */\n\tif (!gid_in_list)\n\t\tprintf(\"%lu\", (unsigned long)gid);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
        },
        {
          "name": "hashtable.c",
          "type": "blob",
          "size": 21.4541015625,
          "content": "/*\n * Routines to provide a memory-efficient hashtable.\n *\n * Copyright (C) 2007-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n#define HASH_LOAD_LIMIT(size) ((size)*3/4)\n\nstruct hashtable *hashtable_create(int size, int key64)\n{\n\tint req = size;\n\tstruct hashtable *tbl;\n\tint node_size = key64 ? sizeof (struct ht_int64_node)\n\t\t\t      : sizeof (struct ht_int32_node);\n\n\t/* Pick a power of 2 that can hold the requested size. */\n\tif (size & (size-1) || size < 16) {\n\t\tsize = 16;\n\t\twhile (size < req)\n\t\t\tsize *= 2;\n\t}\n\n\ttbl = new(struct hashtable);\n\ttbl->nodes = new_array0(char, size * node_size);\n\ttbl->size = size;\n\ttbl->entries = 0;\n\ttbl->node_size = node_size;\n\ttbl->key64 = key64 ? 1 : 0;\n\n\tif (DEBUG_GTE(HASH, 1)) {\n\t\tchar buf[32];\n\t\tif (req != size)\n\t\t\tsnprintf(buf, sizeof buf, \"req: %d, \", req);\n\t\telse\n\t\t\t*buf = '\\0';\n\t\trprintf(FINFO, \"[%s] created hashtable %lx (%ssize: %d, keys: %d-bit)\\n\",\n\t\t\twho_am_i(), (long)tbl, buf, size, key64 ? 64 : 32);\n\t}\n\n\treturn tbl;\n}\n\nvoid hashtable_destroy(struct hashtable *tbl)\n{\n\tif (DEBUG_GTE(HASH, 1)) {\n\t\trprintf(FINFO, \"[%s] destroyed hashtable %lx (size: %d, keys: %d-bit)\\n\",\n\t\t\twho_am_i(), (long)tbl, tbl->size, tbl->key64 ? 64 : 32);\n\t}\n\tfree(tbl->nodes);\n\tfree(tbl);\n}\n\n/* Returns the node that holds the indicated key if it exists. When it does not\n * exist, it returns either NULL (when data_when_new is NULL), or it returns a\n * new node with its node->data set to the indicated value.\n *\n * If your code doesn't know the data value for a new node in advance (usually\n * because it doesn't know if a node is new or not) you should pass in a unique\n * (non-0) value that you can use to check if the returned node is new. You can\n * then overwrite the data with any value you want (even 0) since it only needs\n * to be different than whatever data_when_new value you use later on.\n *\n * This return is a void* just because it might be pointing at a ht_int32_node\n * or a ht_int64_node, and that makes the caller's assignment a little easier. */\nvoid *hashtable_find(struct hashtable *tbl, int64 key, void *data_when_new)\n{\n\tint key64 = tbl->key64;\n\tstruct ht_int32_node *node;\n\tuint32 ndx;\n\n\tif (key64 ? key == 0 : (int32)key == 0) {\n\t\trprintf(FERROR, \"Internal hashtable error: illegal key supplied!\\n\");\n\t\texit_cleanup(RERR_MESSAGEIO);\n\t}\n\n\tif (data_when_new && tbl->entries > HASH_LOAD_LIMIT(tbl->size)) {\n\t\tvoid *old_nodes = tbl->nodes;\n\t\tint size = tbl->size * 2;\n\t\tint i;\n\n\t\ttbl->nodes = new_array0(char, size * tbl->node_size);\n\t\ttbl->size = size;\n\t\ttbl->entries = 0;\n\n\t\tif (DEBUG_GTE(HASH, 1)) {\n\t\t\trprintf(FINFO, \"[%s] growing hashtable %lx (size: %d, keys: %d-bit)\\n\",\n\t\t\t\twho_am_i(), (long)tbl, size, key64 ? 64 : 32);\n\t\t}\n\n\t\tfor (i = size / 2; i-- > 0; ) {\n\t\t\tstruct ht_int32_node *move_node = HT_NODE(tbl, old_nodes, i);\n\t\t\tint64 move_key = HT_KEY(move_node, key64);\n\t\t\tif (move_key == 0)\n\t\t\t\tcontinue;\n\t\t\tif (move_node->data)\n\t\t\t\thashtable_find(tbl, move_key, move_node->data);\n\t\t\telse {\n\t\t\t\tnode = hashtable_find(tbl, move_key, \"\");\n\t\t\t\tnode->data = 0;\n\t\t\t}\n\t\t}\n\n\t\tfree(old_nodes);\n\t}\n\n\tif (!key64) {\n\t\t/* Based on Jenkins One-at-a-time hash. */\n\t\tuchar buf[4], *keyp = buf;\n\t\tint i;\n\n\t\tSIVALu(buf, 0, key);\n\t\tfor (ndx = 0, i = 0; i < 4; i++) {\n\t\t\tndx += keyp[i];\n\t\t\tndx += (ndx << 10);\n\t\t\tndx ^= (ndx >> 6);\n\t\t}\n\t\tndx += (ndx << 3);\n\t\tndx ^= (ndx >> 11);\n\t\tndx += (ndx << 15);\n\t} else {\n\t\t/* Based on Jenkins hashword() from lookup3.c. */\n\t\tuint32 a, b, c;\n\n\t\t/* Set up the internal state */\n\t\ta = b = c = 0xdeadbeef + (8 << 2);\n\n#define rot(x,k) (((x)<<(k)) ^ ((x)>>(32-(k))))\n#if SIZEOF_INT64 >= 8\n\t\tb += (uint32)(key >> 32);\n#endif\n\t\ta += (uint32)key;\n\t\tc ^= b; c -= rot(b, 14);\n\t\ta ^= c; a -= rot(c, 11);\n\t\tb ^= a; b -= rot(a, 25);\n\t\tc ^= b; c -= rot(b, 16);\n\t\ta ^= c; a -= rot(c, 4);\n\t\tb ^= a; b -= rot(a, 14);\n\t\tc ^= b; c -= rot(b, 24);\n#undef rot\n\t\tndx = c;\n\t}\n\n\t/* If it already exists, return the node.  If we're not\n\t * allocating, return NULL if the key is not found. */\n\twhile (1) {\n\t\tint64 nkey;\n\n\t\tndx &= tbl->size - 1;\n\t\tnode = HT_NODE(tbl, tbl->nodes, ndx);\n\t\tnkey = HT_KEY(node, key64);\n\n\t\tif (nkey == key)\n\t\t\treturn node;\n\t\tif (nkey == 0) {\n\t\t\tif (!data_when_new)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\t\tndx++;\n\t}\n\n\t/* Take over this empty spot and then return the node. */\n\tif (key64)\n\t\t((struct ht_int64_node*)node)->key = key;\n\telse\n\t\tnode->key = (int32)key;\n\tnode->data = data_when_new;\n\ttbl->entries++;\n\treturn node;\n}\n\n#ifndef WORDS_BIGENDIAN\n# define HASH_LITTLE_ENDIAN 1\n# define HASH_BIG_ENDIAN 0\n#else\n# define HASH_LITTLE_ENDIAN 0\n# define HASH_BIG_ENDIAN 1\n#endif\n\n/*\n -------------------------------------------------------------------------------\n lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n\n These are functions for producing 32-bit hashes for hash table lookup.\n hash_word(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()\n are externally useful functions.  Routines to test the hash are included\n if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n the public domain.  It has no warranty.\n\n You probably want to use hashlittle().  hashlittle() and hashbig()\n hash byte arrays.  hashlittle() is is faster than hashbig() on\n little-endian machines.  Intel and AMD are little-endian machines.\n On second thought, you probably want hashlittle2(), which is identical to\n hashlittle() except it returns two 32-bit hashes for the price of one.\n You could implement hashbig2() if you wanted but I haven't bothered here.\n\n If you want to find a hash of, say, exactly 7 integers, do\n   a = i1;  b = i2;  c = i3;\n   mix(a,b,c);\n   a += i4; b += i5; c += i6;\n   mix(a,b,c);\n   a += i7;\n   final(a,b,c);\n then use c as the hash value.  If you have a variable length array of\n 4-byte integers to hash, use hash_word().  If you have a byte array (like\n a character string), use hashlittle().  If you have several byte arrays, or\n a mix of things, see the comments above hashlittle().\n\n Why is this so big?  I read 12 bytes at a time into 3 4-byte integers,\n then mix those integers.  This is fast (you can do a lot more thorough\n mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n*/\n\n#define hashsize(n) ((uint32_t)1<<(n))\n#define hashmask(n) (hashsize(n)-1)\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n/*\n -------------------------------------------------------------------------------\n mix -- mix 3 32-bit values reversibly.\n\n This is reversible, so any information in (a,b,c) before mix() is\n still in (a,b,c) after mix().\n\n If four pairs of (a,b,c) inputs are run through mix(), or through\n mix() in reverse, there are at least 32 bits of the output that\n are sometimes the same for one pair and different for another pair.\n This was tested for:\n * pairs that differed by one bit, by two bits, in any combination\n   of top bits of (a,b,c), or in any combination of bottom bits of\n   (a,b,c).\n * \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n   is commonly produced by subtraction) look like a single 1-bit\n   difference.\n * the base values were pseudorandom, all zero but one bit set, or\n   all zero plus a counter that starts at zero.\n\n Some k values for my \"a-=c; a^=rot(c,k); c+=b;\" arrangement that\n satisfy this are\n     4  6  8 16 19  4\n     9 15  3 18 27 15\n    14  9  3  7 17  3\n Well, \"9 15 3 18 27 15\" didn't quite get 32 bits diffing\n for \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n used http://burtleburtle.net/bob/hash/avalanche.html to choose\n the operations, constants, and arrangements of the variables.\n\n This does not achieve avalanche.  There are input bits of (a,b,c)\n that fail to affect some output bits of (a,b,c), especially of a.  The\n most thoroughly mixed value is c, but it doesn't really even achieve\n avalanche in c.\n\n This allows some parallelism.  Read-after-writes are good at doubling\n the number of bits affected, so the goal of mixing pulls in the opposite\n direction as the goal of parallelism.  I did what I could.  Rotates\n seem to cost as much as shifts on every machine I could lay my hands\n on, and rotates are much kinder to the top and bottom bits, so I used\n rotates.\n -------------------------------------------------------------------------------\n*/\n#define mix(a,b,c) \\\n{ \\\n  a -= c;  a ^= rot(c, 4);  c += b; \\\n  b -= a;  b ^= rot(a, 6);  a += c; \\\n  c -= b;  c ^= rot(b, 8);  b += a; \\\n  a -= c;  a ^= rot(c,16);  c += b; \\\n  b -= a;  b ^= rot(a,19);  a += c; \\\n  c -= b;  c ^= rot(b, 4);  b += a; \\\n}\n\n/*\n -------------------------------------------------------------------------------\n final -- final mixing of 3 32-bit values (a,b,c) into c\n\n Pairs of (a,b,c) values differing in only a few bits will usually\n produce values of c that look totally different.  This was tested for\n * pairs that differed by one bit, by two bits, in any combination\n   of top bits of (a,b,c), or in any combination of bottom bits of\n   (a,b,c).\n * \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n   is commonly produced by subtraction) look like a single 1-bit\n   difference.\n * the base values were pseudorandom, all zero but one bit set, or\n   all zero plus a counter that starts at zero.\n\n These constants passed:\n  14 11 25 16 4 14 24\n  12 14 25 16 4 14 24\n and these came close:\n   4  8 15 26 3 22 24\n  10  8 15 26 3 22 24\n  11  8 15 26 3 22 24\n -------------------------------------------------------------------------------\n*/\n#define final(a,b,c) \\\n{ \\\n  c ^= b; c -= rot(b,14); \\\n  a ^= c; a -= rot(c,11); \\\n  b ^= a; b -= rot(a,25); \\\n  c ^= b; c -= rot(b,16); \\\n  a ^= c; a -= rot(c,4);  \\\n  b ^= a; b -= rot(a,14); \\\n  c ^= b; c -= rot(b,24); \\\n}\n\n\n/*\n -------------------------------------------------------------------------------\n hashlittle() -- hash a variable-length key into a 32-bit value\n   k       : the key (the unaligned variable-length array of bytes)\n   length  : the length of the key, counting by bytes\n   val2    : IN: can be any 4-byte value OUT: second 32 bit hash.\n Returns a 32-bit value.  Every bit of the key affects every bit of\n the return value.  Two keys differing by one or two bits will have\n totally different hash values.  Note that the return value is better\n mixed than val2, so use that first.\n\n The best hash table sizes are powers of 2.  There is no need to do\n mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n use a bitmask.  For example, if you need only 10 bits, do\n   h = (h & hashmask(10));\n In which case, the hash table should have hashsize(10) elements.\n\n If you are hashing n strings (uint8_t **)k, do it like this:\n   for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n\n By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n code any way you wish, private, educational, or commercial.  It's free.\n\n Use for hash table lookup, or anything where one collision in 2^^32 is\n acceptable.  Do NOT use for cryptographic purposes.\n -------------------------------------------------------------------------------\n*/\n\n#define NON_ZERO_32(x) ((x) ? (x) : (uint32_t)1)\n#define NON_ZERO_64(x, y) ((x) || (y) ? (y) | (int64)(x) << 32 | (y) : (int64)1)\n\nuint32_t hashlittle(const void *key, size_t length)\n{\n  uint32_t a,b,c;                                          /* internal state */\n  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n\n  /* Set up the internal state */\n  a = b = c = 0xdeadbeef + ((uint32_t)length);\n\n  u.ptr = key;\n  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n    const uint8_t  *k8;\n\n    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      b += k[1];\n      c += k[2];\n      mix(a,b,c);\n      length -= 12;\n      k += 3;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    k8 = (const uint8_t *)k;\n    switch(length)\n    {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n    case 9 : c+=k8[8];                   /* fall through */\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n    case 5 : b+=k8[4];                   /* fall through */\n    case 4 : a+=k[0]; break;\n    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n    case 1 : a+=k8[0]; break;\n    case 0 : return NON_ZERO_32(c);\n    }\n  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n    const uint8_t  *k8;\n\n    /*--------------- all but last block: aligned reads and different mixing */\n    while (length > 12)\n    {\n      a += k[0] + (((uint32_t)k[1])<<16);\n      b += k[2] + (((uint32_t)k[3])<<16);\n      c += k[4] + (((uint32_t)k[5])<<16);\n      mix(a,b,c);\n      length -= 12;\n      k += 6;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    k8 = (const uint8_t *)k;\n    switch(length)\n    {\n    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n    case 10: c+=k[4];\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 9 : c+=k8[8];                      /* fall through */\n    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n    case 6 : b+=k[2];\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 5 : b+=k8[4];                      /* fall through */\n    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n    case 2 : a+=k[0];\n             break;\n    case 1 : a+=k8[0];\n             break;\n    case 0 : return NON_ZERO_32(c);         /* zero length requires no mixing */\n    }\n\n  } else {                        /* need to read the key one byte at a time */\n    const uint8_t *k = (const uint8_t *)key;\n\n    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      a += ((uint32_t)k[1])<<8;\n      a += ((uint32_t)k[2])<<16;\n      a += ((uint32_t)k[3])<<24;\n      b += k[4];\n      b += ((uint32_t)k[5])<<8;\n      b += ((uint32_t)k[6])<<16;\n      b += ((uint32_t)k[7])<<24;\n      c += k[8];\n      c += ((uint32_t)k[9])<<8;\n      c += ((uint32_t)k[10])<<16;\n      c += ((uint32_t)k[11])<<24;\n      mix(a,b,c);\n      length -= 12;\n      k += 12;\n    }\n\n    /*-------------------------------- last block: affect all 32 bits of (c) */\n    switch(length)                   /* all the case statements fall through */\n    {\n    case 12: c+=((uint32_t)k[11])<<24;\n\t     /* FALLTHROUGH */\n    case 11: c+=((uint32_t)k[10])<<16;\n\t     /* FALLTHROUGH */\n    case 10: c+=((uint32_t)k[9])<<8;\n\t     /* FALLTHROUGH */\n    case 9 : c+=k[8];\n\t     /* FALLTHROUGH */\n    case 8 : b+=((uint32_t)k[7])<<24;\n\t     /* FALLTHROUGH */\n    case 7 : b+=((uint32_t)k[6])<<16;\n\t     /* FALLTHROUGH */\n    case 6 : b+=((uint32_t)k[5])<<8;\n\t     /* FALLTHROUGH */\n    case 5 : b+=k[4];\n\t     /* FALLTHROUGH */\n    case 4 : a+=((uint32_t)k[3])<<24;\n\t     /* FALLTHROUGH */\n    case 3 : a+=((uint32_t)k[2])<<16;\n\t     /* FALLTHROUGH */\n    case 2 : a+=((uint32_t)k[1])<<8;\n\t     /* FALLTHROUGH */\n    case 1 : a+=k[0];\n             break;\n    case 0 : return NON_ZERO_32(c);\n    }\n  }\n\n  final(a,b,c);\n  return NON_ZERO_32(c);\n}\n\n#if SIZEOF_INT64 >= 8\n/*\n * hashlittle2: return 2 32-bit hash values joined into an int64.\n *\n * This is identical to hashlittle(), except it returns two 32-bit hash\n * values instead of just one.  This is good enough for hash table\n * lookup with 2^^64 buckets, or if you want a second hash if you're not\n * happy with the first, or if you want a probably-unique 64-bit ID for\n * the key.  *pc is better mixed than *pb, so use *pc first.  If you want\n * a 64-bit value do something like \"*pc + (((uint64_t)*pb)<<32)\".\n */\nint64 hashlittle2(const void *key, size_t length)\n{\n  uint32_t a,b,c;                                          /* internal state */\n  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n\n  /* Set up the internal state */\n  a = b = c = 0xdeadbeef + ((uint32_t)length);\n\n  u.ptr = key;\n  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n    const uint8_t  *k8;\n\n    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      b += k[1];\n      c += k[2];\n      mix(a,b,c);\n      length -= 12;\n      k += 3;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    k8 = (const uint8_t *)k;\n    switch(length)\n    {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n    case 9 : c+=k8[8];                   /* fall through */\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n    case 5 : b+=k8[4];                   /* fall through */\n    case 4 : a+=k[0]; break;\n    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n    case 1 : a+=k8[0]; break;\n    case 0 : return NON_ZERO_64(b, c);\n    }\n  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n    const uint8_t  *k8;\n\n    /*--------------- all but last block: aligned reads and different mixing */\n    while (length > 12)\n    {\n      a += k[0] + (((uint32_t)k[1])<<16);\n      b += k[2] + (((uint32_t)k[3])<<16);\n      c += k[4] + (((uint32_t)k[5])<<16);\n      mix(a,b,c);\n      length -= 12;\n      k += 6;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    k8 = (const uint8_t *)k;\n    switch(length)\n    {\n    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n    case 10: c+=k[4];\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 9 : c+=k8[8];                      /* fall through */\n    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n    case 6 : b+=k[2];\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 5 : b+=k8[4];                      /* fall through */\n    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n    case 2 : a+=k[0];\n             break;\n    case 1 : a+=k8[0];\n             break;\n    case 0 : return NON_ZERO_64(b, c);  /* zero length strings require no mixing */\n    }\n\n  } else {                        /* need to read the key one byte at a time */\n    const uint8_t *k = (const uint8_t *)key;\n\n    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      a += ((uint32_t)k[1])<<8;\n      a += ((uint32_t)k[2])<<16;\n      a += ((uint32_t)k[3])<<24;\n      b += k[4];\n      b += ((uint32_t)k[5])<<8;\n      b += ((uint32_t)k[6])<<16;\n      b += ((uint32_t)k[7])<<24;\n      c += k[8];\n      c += ((uint32_t)k[9])<<8;\n      c += ((uint32_t)k[10])<<16;\n      c += ((uint32_t)k[11])<<24;\n      mix(a,b,c);\n      length -= 12;\n      k += 12;\n    }\n\n    /*-------------------------------- last block: affect all 32 bits of (c) */\n    switch(length)                   /* all the case statements fall through */\n    {\n    case 12: c+=((uint32_t)k[11])<<24;\n\t     /* FALLTHROUGH */\n    case 11: c+=((uint32_t)k[10])<<16;\n\t     /* FALLTHROUGH */\n    case 10: c+=((uint32_t)k[9])<<8;\n\t     /* FALLTHROUGH */\n    case 9 : c+=k[8];\n\t     /* FALLTHROUGH */\n    case 8 : b+=((uint32_t)k[7])<<24;\n\t     /* FALLTHROUGH */\n    case 7 : b+=((uint32_t)k[6])<<16;\n\t     /* FALLTHROUGH */\n    case 6 : b+=((uint32_t)k[5])<<8;\n\t     /* FALLTHROUGH */\n    case 5 : b+=k[4];\n\t     /* FALLTHROUGH */\n    case 4 : a+=((uint32_t)k[3])<<24;\n\t     /* FALLTHROUGH */\n    case 3 : a+=((uint32_t)k[2])<<16;\n\t     /* FALLTHROUGH */\n    case 2 : a+=((uint32_t)k[1])<<8;\n\t     /* FALLTHROUGH */\n    case 1 : a+=k[0];\n             break;\n    case 0 : return NON_ZERO_64(b, c);\n    }\n  }\n\n  final(a,b,c);\n  return NON_ZERO_64(b, c);\n}\n#else\n#define hashlittle2(key, len) hashlittle(key, len)\n#endif\n"
        },
        {
          "name": "help-from-md.awk",
          "type": "blob",
          "size": 0.751953125,
          "content": "#!/usr/bin/awk -f\n\n# The caller must pass args: -v hfile=help-NAME.h NAME.NUM.md\n\nBEGIN {\n    heading = \"/* DO NOT EDIT THIS FILE!  It is auto-generated from the option list in \" ARGV[1] \"! */\"\n    findcomment = hfile\n    sub(\"\\\\.\", \"\\\\.\", findcomment)\n    findcomment = \"\\\\[comment\\\\].*\" findcomment\n    backtick_cnt = 0\n    prints = \"\"\n}\n\n/^```/ {\n    backtick_cnt++\n    next\n}\n\nfoundcomment {\n    if (backtick_cnt > 1) exit\n    if (backtick_cnt == 1) {\n\tgsub(/\"/, \"\\\\\\\"\")\n\tprints = prints \"\\n  rprintf(F,\\\"\" $0 \"\\\\n\\\");\"\n    }\n    next\n}\n\n$0 ~ findcomment {\n    foundcomment = 1\n    backtick_cnt = 0\n}\n\nEND {\n    if (foundcomment && backtick_cnt > 1)\n\tprint heading \"\\n\" prints > hfile\n    else {\n\tprint \"Failed to find \" hfile \" section in \" ARGV[1]\n\texit 1\n    }\n}\n"
        },
        {
          "name": "hlink.c",
          "type": "blob",
          "size": 15.5283203125,
          "content": "/*\n * Routines to support hard-linking.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2004-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n#include \"ifuncs.h\"\n\nextern int dry_run;\nextern int list_only;\nextern int am_sender;\nextern int inc_recurse;\nextern int do_xfers;\nextern int alt_dest_type;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int protocol_version;\nextern int remove_source_files;\nextern int stdout_format_has_i;\nextern int maybe_ATTRS_REPORT;\nextern int unsort_ndx;\nextern char *basis_dir[MAX_BASIS_DIRS+1];\nextern struct file_list *cur_flist;\n\n#ifdef SUPPORT_HARD_LINKS\n\n/* Starting with protocol 30, we use a simple hashtable on the sending side\n * for hashing the st_dev and st_ino info.  The receiving side gets told\n * (via flags and a \"group index\") which items are hard-linked together, so\n * we can avoid the pool of dev+inode data.  For incremental recursion mode,\n * the receiver will use a ndx hash to remember old pathnames. */\n\nstatic void *data_when_new = \"\";\n\nstatic struct hashtable *dev_tbl;\n\nstatic struct hashtable *prior_hlinks;\n\nstatic struct file_list *hlink_flist;\n\nvoid init_hard_links(void)\n{\n\tif (am_sender || protocol_version < 30)\n\t\tdev_tbl = hashtable_create(16, HT_KEY64);\n\telse if (inc_recurse)\n\t\tprior_hlinks = hashtable_create(1024, HT_KEY32);\n}\n\nstruct ht_int64_node *idev_find(int64 dev, int64 ino)\n{\n\tstatic struct ht_int64_node *dev_node = NULL;\n\n\t/* Note that some OSes have a dev == 0, so increment to avoid storing a 0. */\n\tif (!dev_node || dev_node->key != dev+1) {\n\t\t/* We keep a separate hash table of inodes for every device. */\n\t\tdev_node = hashtable_find(dev_tbl, dev+1, data_when_new);\n\t\tif (dev_node->data == data_when_new) {\n\t\t\tdev_node->data = hashtable_create(512, HT_KEY64);\n\t\t\tif (DEBUG_GTE(HLINK, 3)) {\n\t\t\t\trprintf(FINFO, \"[%s] created hashtable for dev %s\\n\",\n\t\t\t\t\twho_am_i(), big_num(dev));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hashtable_find(dev_node->data, ino, (void*)-1L);\n}\n\nvoid idev_destroy(void)\n{\n\tint i;\n\n\tfor (i = 0; i < dev_tbl->size; i++) {\n\t\tstruct ht_int32_node *node = HT_NODE(dev_tbl, dev_tbl->nodes, i);\n\t\tif (node->data)\n\t\t\thashtable_destroy(node->data);\n\t}\n\n\thashtable_destroy(dev_tbl);\n}\n\nstatic int hlink_compare_gnum(int *int1, int *int2)\n{\n\tstruct file_struct *f1 = hlink_flist->sorted[*int1];\n\tstruct file_struct *f2 = hlink_flist->sorted[*int2];\n\tint32 gnum1 = F_HL_GNUM(f1);\n\tint32 gnum2 = F_HL_GNUM(f2);\n\n\tif (gnum1 != gnum2)\n\t\treturn gnum1 > gnum2 ? 1 : -1;\n\n\treturn *int1 > *int2 ? 1 : -1;\n}\n\nstatic void match_gnums(int32 *ndx_list, int ndx_count)\n{\n\tint32 from, prev;\n\tstruct file_struct *file, *file_next;\n\tstruct ht_int32_node *node = NULL;\n\tint32 gnum, gnum_next;\n\n\tqsort(ndx_list, ndx_count, sizeof ndx_list[0], (int (*)(const void*, const void*))hlink_compare_gnum);\n\n\tfor (from = 0; from < ndx_count; from++) {\n\t\tfile = hlink_flist->sorted[ndx_list[from]];\n\t\tgnum = F_HL_GNUM(file);\n\t\tif (inc_recurse) {\n\t\t\tnode = hashtable_find(prior_hlinks, gnum, data_when_new);\n\t\t\tif (node->data == data_when_new) {\n\t\t\t\tnode->data = new_array0(char, 5);\n\t\t\t\tassert(gnum >= hlink_flist->ndx_start);\n\t\t\t\tfile->flags |= FLAG_HLINK_FIRST;\n\t\t\t\tprev = -1;\n\t\t\t} else if (CVAL(node->data, 0) == 0) {\n\t\t\t\tstruct file_list *flist;\n\t\t\t\tprev = IVAL(node->data, 1);\n\t\t\t\tflist = flist_for_ndx(prev, NULL);\n\t\t\t\tif (flist)\n\t\t\t\t\tflist->files[prev - flist->ndx_start]->flags &= ~FLAG_HLINK_LAST;\n\t\t\t\telse {\n\t\t\t\t\t/* We skipped all prior files in this\n\t\t\t\t\t * group, so mark this as a \"first\". */\n\t\t\t\t\tfile->flags |= FLAG_HLINK_FIRST;\n\t\t\t\t\tprev = -1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tprev = -1;\n\t\t} else {\n\t\t\tfile->flags |= FLAG_HLINK_FIRST;\n\t\t\tprev = -1;\n\t\t}\n\t\tfor ( ; from < ndx_count-1; file = file_next, gnum = gnum_next, from++) { /*SHARED ITERATOR*/\n\t\t\tfile_next = hlink_flist->sorted[ndx_list[from+1]];\n\t\t\tgnum_next = F_HL_GNUM(file_next);\n\t\t\tif (gnum != gnum_next)\n\t\t\t\tbreak;\n\t\t\tF_HL_PREV(file) = prev;\n\t\t\t/* The linked list uses over-the-wire ndx values. */\n\t\t\tif (unsort_ndx)\n\t\t\t\tprev = F_NDX(file);\n\t\t\telse\n\t\t\t\tprev = ndx_list[from] + hlink_flist->ndx_start;\n\t\t}\n\t\tif (prev < 0 && !inc_recurse) {\n\t\t\t/* Disable hard-link bit and set DONE so that\n\t\t\t * HLINK_BUMP()-dependent values are unaffected. */\n\t\t\tfile->flags &= ~(FLAG_HLINKED | FLAG_HLINK_FIRST);\n\t\t\tfile->flags |= FLAG_HLINK_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile->flags |= FLAG_HLINK_LAST;\n\t\tF_HL_PREV(file) = prev;\n\t\tif (inc_recurse && CVAL(node->data, 0) == 0) {\n\t\t\tif (unsort_ndx)\n\t\t\t\tprev = F_NDX(file);\n\t\t\telse\n\t\t\t\tprev = ndx_list[from] + hlink_flist->ndx_start;\n\t\t\tSIVAL(node->data, 1, prev);\n\t\t}\n\t}\n}\n\n/* Analyze the hard-links in the file-list by creating a list of all the\n * items that have hlink data, sorting them, and matching up identical\n * values into clusters.  These will be a single linked list from last\n * to first when we're done. */\nvoid match_hard_links(struct file_list *flist)\n{\n\tif (!list_only && flist->used) {\n\t\tint i, ndx_count = 0;\n\t\tint32 *ndx_list;\n\n\t\tndx_list = new_array(int32, flist->used);\n\n\t\tfor (i = 0; i < flist->used; i++) {\n\t\t\tif (F_IS_HLINKED(flist->sorted[i]))\n\t\t\t\tndx_list[ndx_count++] = i;\n\t\t}\n\n\t\thlink_flist = flist;\n\n\t\tif (ndx_count)\n\t\t\tmatch_gnums(ndx_list, ndx_count);\n\n\t\tfree(ndx_list);\n\t}\n\tif (protocol_version < 30)\n\t\tidev_destroy();\n}\n\nstatic int maybe_hard_link(struct file_struct *file, int ndx,\n\t\t\t   char *fname, int statret, stat_x *sxp,\n\t\t\t   const char *oldname, STRUCT_STAT *old_stp,\n\t\t\t   const char *realname, int itemizing, enum logcode code)\n{\n\tif (statret == 0) {\n\t\tif (sxp->st.st_dev == old_stp->st_dev\n\t\t && sxp->st.st_ino == old_stp->st_ino) {\n\t\t\tif (itemizing) {\n\t\t\t\titemize(fname, file, ndx, statret, sxp,\n\t\t\t\t\tITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,\n\t\t\t\t\t0, \"\");\n\t\t\t}\n\t\t\tif (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)\n\t\t\t\trprintf(FCLIENT, \"%s is uptodate\\n\", fname);\n\t\t\tfile->flags |= FLAG_HLINK_DONE;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (atomic_create(file, fname, NULL, oldname, MAKEDEV(0, 0), sxp, statret == 0 ? DEL_FOR_FILE : 0)) {\n\t\tif (itemizing) {\n\t\t\titemize(fname, file, ndx, statret, sxp,\n\t\t\t\tITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS, 0,\n\t\t\t\trealname);\n\t\t}\n\t\tif (code != FNONE && INFO_GTE(NAME, 1))\n\t\t\trprintf(code, \"%s => %s\\n\", fname, realname);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n/* Figure out if a prior entry is still there or if we just have a\n * cached name for it. */\nstatic char *check_prior(struct file_struct *file, int gnum,\n\t\t\t int *prev_ndx_p, struct file_list **flist_p)\n{\n\tstruct file_struct *fp;\n\tstruct ht_int32_node *node;\n\tint prev_ndx = F_HL_PREV(file);\n\n\twhile (1) {\n\t\tstruct file_list *flist;\n\t\tif (prev_ndx < 0\n\t\t || (flist = flist_for_ndx(prev_ndx, NULL)) == NULL)\n\t\t\tbreak;\n\t\tfp = flist->files[prev_ndx - flist->ndx_start];\n\t\tif (!(fp->flags & FLAG_SKIP_HLINK)) {\n\t\t\t*prev_ndx_p = prev_ndx;\n\t\t\t*flist_p = flist;\n\t\t\treturn NULL;\n\t\t}\n\t\tF_HL_PREV(file) = prev_ndx = F_HL_PREV(fp);\n\t}\n\n\tif (inc_recurse\n\t && (node = hashtable_find(prior_hlinks, gnum, NULL)) != NULL) {\n\t\tassert(node->data != NULL);\n\t\tif (CVAL(node->data, 0) != 0) {\n\t\t\t*prev_ndx_p = -1;\n\t\t\t*flist_p = NULL;\n\t\t\treturn node->data;\n\t\t}\n\t\t/* The prior file must have been skipped. */\n\t\tF_HL_PREV(file) = -1;\n\t}\n\n\t*prev_ndx_p = -1;\n\t*flist_p = NULL;\n\treturn NULL;\n}\n\n/* Only called if FLAG_HLINKED is set and FLAG_HLINK_FIRST is not.  Returns:\n * 0 = process the file, 1 = skip the file, -1 = error occurred. */\nint hard_link_check(struct file_struct *file, int ndx, char *fname,\n\t\t    int statret, stat_x *sxp, int itemizing,\n\t\t    enum logcode code)\n{\n\tSTRUCT_STAT prev_st;\n\tchar namebuf[MAXPATHLEN], altbuf[MAXPATHLEN];\n\tchar *realname, *prev_name;\n\tstruct file_list *flist;\n\tint gnum = inc_recurse ? F_HL_GNUM(file) : -1;\n\tint prev_ndx;\n\n\tprev_name = realname = check_prior(file, gnum, &prev_ndx, &flist);\n\n\tif (!prev_name) {\n\t\tstruct file_struct *prev_file;\n\n\t\tif (!flist) {\n\t\t\t/* The previous file was skipped, so this one is\n\t\t\t * treated as if it were the first in its group. */\n\t\t\tif (DEBUG_GTE(HLINK, 2)) {\n\t\t\t\trprintf(FINFO, \"hlink for %d (%s,%d): virtual first\\n\",\n\t\t\t\t\tndx, f_name(file, NULL), gnum);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tprev_file = flist->files[prev_ndx - flist->ndx_start];\n\n\t\t/* Is the previous link not complete yet? */\n\t\tif (!(prev_file->flags & FLAG_HLINK_DONE)) {\n\t\t\t/* Is the previous link being transferred? */\n\t\t\tif (prev_file->flags & FLAG_FILE_SENT) {\n\t\t\t\t/* Add ourselves to the list of files that will\n\t\t\t\t * be updated when the transfer completes, and\n\t\t\t\t * mark ourself as waiting for the transfer. */\n\t\t\t\tF_HL_PREV(file) = F_HL_PREV(prev_file);\n\t\t\t\tF_HL_PREV(prev_file) = ndx;\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t\tcur_flist->in_progress++;\n\t\t\t\tif (DEBUG_GTE(HLINK, 2)) {\n\t\t\t\t\trprintf(FINFO, \"hlink for %d (%s,%d): waiting for %d\\n\",\n\t\t\t\t\t\tndx, f_name(file, NULL), gnum, F_HL_PREV(file));\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (DEBUG_GTE(HLINK, 2)) {\n\t\t\t\trprintf(FINFO, \"hlink for %d (%s,%d): looking for a leader\\n\",\n\t\t\t\t\tndx, f_name(file, NULL), gnum);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* There is a finished file to link with! */\n\t\tif (!(prev_file->flags & FLAG_HLINK_FIRST)) {\n\t\t\t/* The previous previous is FIRST when prev is not. */\n\t\t\tprev_name = realname = check_prior(prev_file, gnum, &prev_ndx, &flist);\n\t\t\t/* Update our previous pointer to point to the FIRST. */\n\t\t\tF_HL_PREV(file) = prev_ndx;\n\t\t}\n\n\t\tif (!prev_name) {\n\t\t\tint alt_dest;\n\n\t\t\tassert(flist != NULL);\n\t\t\tprev_file = flist->files[prev_ndx - flist->ndx_start];\n\t\t\t/* F_HL_PREV() is alt_dest value when DONE && FIRST. */\n\t\t\talt_dest = F_HL_PREV(prev_file);\n\t\t\tif (DEBUG_GTE(HLINK, 2)) {\n\t\t\t\trprintf(FINFO, \"hlink for %d (%s,%d): found flist match (alt %d)\\n\",\n\t\t\t\t\tndx, f_name(file, NULL), gnum, alt_dest);\n\t\t\t}\n\n\t\t\tif (alt_dest >= 0 && dry_run) {\n\t\t\t\tpathjoin(namebuf, MAXPATHLEN, basis_dir[alt_dest],\n\t\t\t\t\t f_name(prev_file, NULL));\n\t\t\t\tprev_name = namebuf;\n\t\t\t\trealname = f_name(prev_file, altbuf);\n\t\t\t} else {\n\t\t\t\tprev_name = f_name(prev_file, namebuf);\n\t\t\t\trealname = prev_name;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (DEBUG_GTE(HLINK, 2)) {\n\t\trprintf(FINFO, \"hlink for %d (%s,%d): leader is %d (%s)\\n\",\n\t\t\tndx, f_name(file, NULL), gnum, prev_ndx, prev_name);\n\t}\n\n\tif (link_stat(prev_name, &prev_st, 0) < 0) {\n\t\tif (!dry_run || errno != ENOENT) {\n\t\t\trsyserr(FERROR_XFER, errno, \"stat %s failed\", full_fname(prev_name));\n\t\t\treturn -1;\n\t\t}\n\t\t/* A new hard-link will get a new dev & inode, so approximate\n\t\t * those values in dry-run mode by zeroing them. */\n\t\tmemset(&prev_st, 0, sizeof prev_st);\n\t}\n\n\tif (statret < 0 && basis_dir[0] != NULL) {\n\t\t/* If we match an alt-dest item, we don't output this as a change. */\n\t\tchar cmpbuf[MAXPATHLEN];\n\t\tstat_x alt_sx;\n\t\tint j = 0;\n\t\tinit_stat_x(&alt_sx);\n\t\tdo {\n\t\t\tpathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);\n\t\t\tif (link_stat(cmpbuf, &alt_sx.st, 0) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (alt_dest_type == LINK_DEST) {\n\t\t\t\tif (prev_st.st_dev != alt_sx.st.st_dev\n\t\t\t\t || prev_st.st_ino != alt_sx.st.st_ino)\n\t\t\t\t\tcontinue;\n\t\t\t\tstatret = 1;\n\t\t\t\tif (stdout_format_has_i == 0\n\t\t\t\t || (!INFO_GTE(NAME, 2) && stdout_format_has_i < 2)) {\n\t\t\t\t\titemizing = 0;\n\t\t\t\t\tcode = FNONE;\n\t\t\t\t\tif (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)\n\t\t\t\t\t\trprintf(FCLIENT, \"%s is uptodate\\n\", fname);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!quick_check_ok(FT_REG, cmpbuf, file, &alt_sx.st))\n\t\t\t\tcontinue;\n\t\t\tstatret = 1;\n\t\t\tif (unchanged_attrs(cmpbuf, file, &alt_sx))\n\t\t\t\tbreak;\n\t\t} while (basis_dir[++j] != NULL);\n\t\tif (statret == 1) {\n\t\t\tsxp->st = alt_sx.st;\n#ifdef SUPPORT_ACLS\n\t\t\tif (preserve_acls && !S_ISLNK(file->mode)) {\n\t\t\t\tfree_acl(sxp);\n\t\t\t\tif (!ACL_READY(alt_sx))\n\t\t\t\t\tget_acl(cmpbuf, sxp);\n\t\t\t\telse {\n\t\t\t\t\tsxp->acc_acl = alt_sx.acc_acl;\n\t\t\t\t\tsxp->def_acl = alt_sx.def_acl;\n\t\t\t\t\talt_sx.acc_acl = alt_sx.def_acl = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs) {\n\t\t\t\tfree_xattr(sxp);\n\t\t\t\tif (!XATTR_READY(alt_sx))\n\t\t\t\t\tget_xattr(cmpbuf, sxp);\n\t\t\t\telse {\n\t\t\t\t\tsxp->xattr = alt_sx.xattr;\n\t\t\t\t\talt_sx.xattr = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else\n\t\t\tfree_stat_x(&alt_sx);\n\t}\n\n\tif (maybe_hard_link(file, ndx, fname, statret, sxp, prev_name, &prev_st,\n\t\t\t    realname, itemizing, code) < 0)\n\t\treturn -1;\n\n\tif (remove_source_files == 1 && do_xfers)\n\t\tsend_msg_success(fname, ndx);\n\n\treturn 1;\n}\n\nint hard_link_one(struct file_struct *file, const char *fname,\n\t\t  const char *oldname, int terse)\n{\n\tif (do_link(oldname, fname) < 0) {\n\t\tenum logcode code;\n\t\tif (terse) {\n\t\t\tif (!INFO_GTE(NAME, 1))\n\t\t\t\treturn 0;\n\t\t\tcode = FINFO;\n\t\t} else\n\t\t\tcode = FERROR_XFER;\n\t\trsyserr(code, errno, \"link %s => %s failed\",\n\t\t\tfull_fname(fname), oldname);\n\t\treturn 0;\n\t}\n\n\tfile->flags |= FLAG_HLINK_DONE;\n\n\treturn 1;\n}\n\nvoid finish_hard_link(struct file_struct *file, const char *fname, int fin_ndx,\n\t\t      STRUCT_STAT *stp, int itemizing, enum logcode code,\n\t\t      int alt_dest)\n{\n\tstat_x prev_sx;\n\tSTRUCT_STAT st;\n\tchar prev_name[MAXPATHLEN], alt_name[MAXPATHLEN];\n\tconst char *our_name;\n\tstruct file_list *flist;\n\tint prev_statret, ndx, prev_ndx = F_HL_PREV(file);\n\n\tif (stp == NULL && prev_ndx >= 0) {\n\t\tif (link_stat(fname, &st, 0) < 0 && !dry_run) {\n\t\t\trsyserr(FERROR_XFER, errno, \"stat %s failed\",\n\t\t\t\tfull_fname(fname));\n\t\t\treturn;\n\t\t}\n\t\tstp = &st;\n\t}\n\n\t/* FIRST combined with DONE means we were the first to get done. */\n\tfile->flags |= FLAG_HLINK_FIRST | FLAG_HLINK_DONE;\n\tF_HL_PREV(file) = alt_dest;\n\tif (alt_dest >= 0 && dry_run) {\n\t\tpathjoin(alt_name, MAXPATHLEN, basis_dir[alt_dest],\n\t\t\t f_name(file, NULL));\n\t\tour_name = alt_name;\n\t} else\n\t\tour_name = fname;\n\n\tinit_stat_x(&prev_sx);\n\n\twhile ((ndx = prev_ndx) >= 0) {\n\t\tint val;\n\t\tflist = flist_for_ndx(ndx, \"finish_hard_link\");\n\t\tfile = flist->files[ndx - flist->ndx_start];\n\t\tfile->flags = (file->flags & ~FLAG_HLINK_FIRST) | FLAG_HLINK_DONE;\n\t\tprev_ndx = F_HL_PREV(file);\n\t\tF_HL_PREV(file) = fin_ndx;\n\t\tprev_statret = link_stat(f_name(file, prev_name), &prev_sx.st, 0);\n\t\tval = maybe_hard_link(file, ndx, prev_name, prev_statret, &prev_sx,\n\t\t\t\t      our_name, stp, fname, itemizing, code);\n\t\tflist->in_progress--;\n\t\tfree_stat_x(&prev_sx);\n\t\tif (val < 0)\n\t\t\tcontinue;\n\t\tif (remove_source_files == 1 && do_xfers)\n\t\t\tsend_msg_success(fname, ndx);\n\t}\n\n\tif (inc_recurse) {\n\t\tint gnum = F_HL_GNUM(file);\n\t\tstruct ht_int32_node *node = hashtable_find(prior_hlinks, gnum, NULL);\n\t\tif (node == NULL) {\n\t\t\trprintf(FERROR, \"Unable to find a hlink node for %d (%s)\\n\", gnum, f_name(file, prev_name));\n\t\t\texit_cleanup(RERR_MESSAGEIO);\n\t\t}\n\t\tif (node->data == NULL) {\n\t\t\trprintf(FERROR, \"Hlink node data for %d is NULL (%s)\\n\", gnum, f_name(file, prev_name));\n\t\t\texit_cleanup(RERR_MESSAGEIO);\n\t\t}\n\t\tif (CVAL(node->data, 0) != 0) {\n\t\t\trprintf(FERROR, \"Hlink node data for %d already has path=%s (%s)\\n\",\n\t\t\t\tgnum, (char*)node->data, f_name(file, prev_name));\n\t\t\texit_cleanup(RERR_MESSAGEIO);\n\t\t}\n\t\tfree(node->data);\n\t\tnode->data = strdup(our_name);\n\t}\n}\n\nint skip_hard_link(struct file_struct *file, struct file_list **flist_p)\n{\n\tstruct file_list *flist;\n\tint prev_ndx;\n\n\tfile->flags |= FLAG_SKIP_HLINK;\n\tif (!(file->flags & FLAG_HLINK_LAST))\n\t\treturn -1;\n\n\tcheck_prior(file, F_HL_GNUM(file), &prev_ndx, &flist);\n\tif (prev_ndx >= 0) {\n\t\tfile = flist->files[prev_ndx - flist->ndx_start];\n\t\tif (file->flags & (FLAG_HLINK_DONE|FLAG_FILE_SENT))\n\t\t\treturn -1;\n\t\tfile->flags |= FLAG_HLINK_LAST;\n\t\t*flist_p = flist;\n\t}\n\n\treturn prev_ndx;\n}\n#endif\n"
        },
        {
          "name": "ifuncs.h",
          "type": "blob",
          "size": 2.189453125,
          "content": "/* Inline functions for rsync.\n *\n * Copyright (C) 2007-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\nstatic inline void\nalloc_xbuf(xbuf *xb, size_t sz)\n{\n\txb->buf = new_array(char, sz);\n\txb->size = sz;\n\txb->len = xb->pos = 0;\n}\n\nstatic inline void\nrealloc_xbuf(xbuf *xb, size_t sz)\n{\n\tchar *bf = realloc_array(xb->buf, char, sz);\n\txb->buf = bf;\n\txb->size = sz;\n}\n\nstatic inline void\nfree_xbuf(xbuf *xb)\n{\n\tif (xb->buf)\n\t\tfree(xb->buf);\n\tmemset(xb, 0, sizeof (xbuf));\n}\n\nstatic inline int\nto_wire_mode(mode_t mode)\n{\n#ifdef SUPPORT_LINKS\n#if _S_IFLNK != 0120000\n\tif (S_ISLNK(mode))\n\t\treturn (mode & ~(_S_IFMT)) | 0120000;\n#endif\n#endif\n\treturn mode;\n}\n\nstatic inline mode_t\nfrom_wire_mode(int mode)\n{\n#if _S_IFLNK != 0120000\n\tif ((mode & (_S_IFMT)) == 0120000)\n\t\treturn (mode & ~(_S_IFMT)) | _S_IFLNK;\n#endif\n\treturn mode;\n}\n\nstatic inline char *\nd_name(struct dirent *di)\n{\n#ifdef HAVE_BROKEN_READDIR\n\treturn (di->d_name - 2);\n#else\n\treturn di->d_name;\n#endif\n}\n\nstatic inline void\ninit_stat_x(stat_x *sx_p)\n{\n\tsx_p->crtime = 0;\n#ifdef SUPPORT_ACLS\n\tsx_p->acc_acl = sx_p->def_acl = NULL;\n#endif\n#ifdef SUPPORT_XATTRS\n\tsx_p->xattr = NULL;\n#endif\n}\n\nstatic inline void\nfree_stat_x(stat_x *sx_p)\n{\n#ifdef SUPPORT_ACLS\n    {\n\textern int preserve_acls;\n\tif (preserve_acls)\n\t\tfree_acl(sx_p);\n    }\n#endif\n#ifdef SUPPORT_XATTRS\n    {\n\textern int preserve_xattrs;\n\tif (preserve_xattrs)\n\t\tfree_xattr(sx_p);\n    }\n#endif\n}\n\nstatic inline char *my_strdup(const char *str, const char *file, int line)\n{\n    int len = strlen(str)+1;\n    char *buf = my_alloc(NULL, len, 1, file, line);\n    memcpy(buf, str, len);\n    return buf;\n}\n"
        },
        {
          "name": "install-sh",
          "type": "blob",
          "size": 4.6650390625,
          "content": "#! /bin/sh\n#\n# install - install a program, script, or datafile\n# This comes from X11R5.\n#\n# Calling this script install-sh is preferred over install.sh, to prevent\n# `make' implicit rules from creating a file called install from it\n# when there is no Makefile.\n#\n# This script is compatible with the BSD install script, but was written\n# from scratch.\n#\n\n\n# set DOITPROG to echo to test this script\n\n# Don't use :- since 4.3BSD and earlier shells don't like it.\ndoit=\"${DOITPROG-}\"\n\n\n# put in absolute paths if you don't have them in your path; or use env. vars.\n\nmvprog=\"${MVPROG-mv}\"\ncpprog=\"${CPPROG-cp}\"\nchmodprog=\"${CHMODPROG-chmod}\"\nchownprog=\"${CHOWNPROG-chown}\"\nchgrpprog=\"${CHGRPPROG-chgrp}\"\nstripprog=\"${STRIPPROG-strip}\"\nrmprog=\"${RMPROG-rm}\"\nmkdirprog=\"${MKDIRPROG-mkdir}\"\n\ntransformbasename=\"\"\ntransform_arg=\"\"\ninstcmd=\"$mvprog\"\nchmodcmd=\"$chmodprog 0755\"\nchowncmd=\"\"\nchgrpcmd=\"\"\nstripcmd=\"\"\nrmcmd=\"$rmprog -f\"\nmvcmd=\"$mvprog\"\nsrc=\"\"\ndst=\"\"\ndir_arg=\"\"\n\nwhile [ x\"$1\" != x ]; do\n    case $1 in\n\t-c) instcmd=\"$cpprog\"\n\t    shift\n\t    continue;;\n\n\t-d) dir_arg=true\n\t    shift\n\t    continue;;\n\n\t-m) chmodcmd=\"$chmodprog $2\"\n\t    shift\n\t    shift\n\t    continue;;\n\n\t-o) chowncmd=\"$chownprog $2\"\n\t    shift\n\t    shift\n\t    continue;;\n\n\t-g) chgrpcmd=\"$chgrpprog $2\"\n\t    shift\n\t    shift\n\t    continue;;\n\n\t-s) stripcmd=\"$stripprog\"\n\t    shift\n\t    continue;;\n\n\t-t=*) transformarg=`echo $1 | sed 's/-t=//'`\n\t    shift\n\t    continue;;\n\n\t-b=*) transformbasename=`echo $1 | sed 's/-b=//'`\n\t    shift\n\t    continue;;\n\n\t*)  if [ x\"$src\" = x ]\n\t    then\n\t\tsrc=$1\n\t    else\n\t\t# this colon is to work around a 386BSD /bin/sh bug\n\t\t:\n\t\tdst=$1\n\t    fi\n\t    shift\n\t    continue;;\n    esac\ndone\n\nif [ x\"$src\" = x ]\nthen\n\techo \"install:\tno input file specified\"\n\texit 1\nelse\n\ttrue\nfi\n\nif [ x\"$dir_arg\" != x ]; then\n\tdst=$src\n\tsrc=\"\"\n\t\n\tif [ -d $dst ]; then\n\t\tinstcmd=:\n\telse\n\t\tinstcmd=mkdir\n\tfi\nelse\n\n# Waiting for this to be detected by the \"$instcmd $src $dsttmp\" command\n# might cause directories to be created, which would be especially bad \n# if $src (and thus $dsttmp) contains '*'.\n\n\tif [ -f $src ] || [ -d $src ]\n\tthen\n\t\ttrue\n\telse\n\t\techo \"install:  $src does not exist\"\n\t\texit 1\n\tfi\n\t\n\tif [ x\"$dst\" = x ]\n\tthen\n\t\techo \"install:\tno destination specified\"\n\t\texit 1\n\telse\n\t\ttrue\n\tfi\n\n# If destination is a directory, append the input filename; if your system\n# does not like double slashes in filenames, you may need to add some logic\n\n\tif [ -d $dst ]\n\tthen\n\t\tdst=\"$dst\"/`basename $src`\n\telse\n\t\ttrue\n\tfi\nfi\n\n## this sed command emulates the dirname command\ndstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`\n\n# Make sure that the destination directory exists.\n#  this part is taken from Noah Friedman's mkinstalldirs script\n\n# Skip lots of stat calls in the usual case.\nif [ ! -d \"$dstdir\" ]; then\ndefaultIFS='\t\n'\nIFS=\"${IFS-${defaultIFS}}\"\n\noIFS=\"${IFS}\"\n# Some sh's can't handle IFS=/ for some reason.\nIFS='%'\nset - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`\nIFS=\"${oIFS}\"\n\npathcomp=''\n\nwhile [ $# -ne 0 ] ; do\n\tpathcomp=\"${pathcomp}${1}\"\n\tshift\n\n\tif [ ! -d \"${pathcomp}\" ] ;\n        then\n\t\t$mkdirprog \"${pathcomp}\"\n\telse\n\t\ttrue\n\tfi\n\n\tpathcomp=\"${pathcomp}/\"\ndone\nfi\n\nif [ x\"$dir_arg\" != x ]\nthen\n\t$doit $instcmd $dst &&\n\n\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dst; else true ; fi &&\n\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&\n\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dst; else true ; fi &&\n\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dst; else true ; fi\nelse\n\n# If we're going to rename the final executable, determine the name now.\n\n\tif [ x\"$transformarg\" = x ] \n\tthen\n\t\tdstfile=`basename $dst`\n\telse\n\t\tdstfile=`basename $dst $transformbasename | \n\t\t\tsed $transformarg`$transformbasename\n\tfi\n\n# don't allow the sed command to completely eliminate the filename\n\n\tif [ x\"$dstfile\" = x ] \n\tthen\n\t\tdstfile=`basename $dst`\n\telse\n\t\ttrue\n\tfi\n\n# Make a temp file name in the proper directory.\n\n\tdsttmp=$dstdir/_inst.$$_\n\n# Move or copy the file name to the temp name\n\n\t$doit $instcmd $src $dsttmp &&\n\n\ttrap \"rm -f ${dsttmp}\" 0 &&\n\n# and set any options; do chmod last to preserve setuid bits\n\n# If any of these fail, we abort the whole thing.  If we want to\n# ignore errors from any of these, just make sure not to ignore\n# errors from the above \"$doit $instcmd $src $dsttmp\" command.\n\n\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&\n\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&\n\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&\n\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&\n\n# Now rename the file to the real destination.\n\n\t$doit $rmcmd -f $dstdir/$dstfile &&\n\t$doit $mvcmd $dsttmp $dstdir/$dstfile \n\nfi &&\n\n\nexit 0\n"
        },
        {
          "name": "inums.h",
          "type": "blob",
          "size": 1.451171875,
          "content": "/* Inline functions for rsync.\n *\n * Copyright (C) 2008-2019 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\nstatic inline char *\nbig_num(int64 num)\n{\n\treturn do_big_num(num, 0, NULL);\n}\n\nstatic inline char *\ncomma_num(int64 num)\n{\n\textern int human_readable;\n\treturn do_big_num(num, human_readable != 0, NULL);\n}\n\nstatic inline char *\nhuman_num(int64 num)\n{\n\textern int human_readable;\n\treturn do_big_num(num, human_readable, NULL);\n}\n\nstatic inline char *\nbig_dnum(double dnum, int decimal_digits)\n{\n\treturn do_big_dnum(dnum, 0, decimal_digits);\n}\n\nstatic inline char *\ncomma_dnum(double dnum, int decimal_digits)\n{\n\textern int human_readable;\n\treturn do_big_dnum(dnum, human_readable != 0, decimal_digits);\n}\n\nstatic inline char *\nhuman_dnum(double dnum, int decimal_digits)\n{\n\textern int human_readable;\n\treturn do_big_dnum(dnum, human_readable, decimal_digits);\n}\n"
        },
        {
          "name": "io.c",
          "type": "blob",
          "size": 65.455078125,
          "content": "/*\n * Socket and pipe I/O utilities used in rsync.\n *\n * Copyright (C) 1996-2001 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* Rsync provides its own multiplexing system, which is used to send\n * stderr and stdout over a single socket.\n *\n * For historical reasons this is off during the start of the\n * connection, but it's switched on quite early using\n * io_start_multiplex_out() and io_start_multiplex_in(). */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"inums.h\"\n\n/** If no timeout is specified then use a 60 second select timeout */\n#define SELECT_TIMEOUT 60\n\nextern int bwlimit;\nextern size_t bwlimit_writemax;\nextern int io_timeout;\nextern int am_server;\nextern int am_sender;\nextern int am_receiver;\nextern int am_generator;\nextern int local_server;\nextern int msgs2stderr;\nextern int inc_recurse;\nextern int io_error;\nextern int batch_fd;\nextern int eol_nulls;\nextern int flist_eof;\nextern int file_total;\nextern int file_old_total;\nextern int list_only;\nextern int read_batch;\nextern int compat_flags;\nextern int protect_args;\nextern int checksum_seed;\nextern int xfer_sum_len;\nextern int daemon_connection;\nextern int protocol_version;\nextern int remove_source_files;\nextern int preserve_hard_links;\nextern BOOL extra_flist_sending_enabled;\nextern BOOL flush_ok_after_signal;\nextern struct stats stats;\nextern time_t stop_at_utime;\nextern struct file_list *cur_flist;\n#ifdef ICONV_OPTION\nextern int filesfrom_convert;\nextern iconv_t ic_send, ic_recv;\n#endif\n\nint csum_length = SHORT_SUM_LENGTH; /* initial value */\nint allowed_lull = 0;\nint msgdone_cnt = 0;\nint forward_flist_data = 0;\nBOOL flist_receiving_enabled = False;\n\n/* Ignore an EOF error if non-zero. See whine_about_eof(). */\nint kluge_around_eof = 0;\nint got_kill_signal = -1; /* is set to 0 only after multiplexed I/O starts */\n\nint sock_f_in = -1;\nint sock_f_out = -1;\n\nint64 total_data_read = 0;\nint64 total_data_written = 0;\n\nchar num_dev_ino_buf[4 + 8 + 8];\n\nstatic struct {\n\txbuf in, out, msg;\n\tint in_fd;\n\tint out_fd; /* Both \"out\" and \"msg\" go to this fd. */\n\tint in_multiplexed;\n\tunsigned out_empty_len;\n\tsize_t raw_data_header_pos;      /* in the out xbuf */\n\tsize_t raw_flushing_ends_before; /* in the out xbuf */\n\tsize_t raw_input_ends_before;    /* in the in xbuf */\n} iobuf = { .in_fd = -1, .out_fd = -1 };\n\nstatic time_t last_io_in;\nstatic time_t last_io_out;\n\nstatic int write_batch_monitor_in = -1;\nstatic int write_batch_monitor_out = -1;\n\nstatic int ff_forward_fd = -1;\nstatic int ff_reenable_multiplex = -1;\nstatic char ff_lastchar = '\\0';\nstatic xbuf ff_xb = EMPTY_XBUF;\n#ifdef ICONV_OPTION\nstatic xbuf iconv_buf = EMPTY_XBUF;\n#endif\nstatic int select_timeout = SELECT_TIMEOUT;\nstatic int active_filecnt = 0;\nstatic OFF_T active_bytecnt = 0;\nstatic int first_message = 1;\n\nstatic char int_byte_extra[64] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (00 - 3F)/4 */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (40 - 7F)/4 */\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* (80 - BF)/4 */\n\t2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, /* (C0 - FF)/4 */\n};\n\n/* Our I/O buffers are sized with no bits on in the lowest byte of the \"size\"\n * (indeed, our rounding of sizes in 1024-byte units assures more than this).\n * This allows the code that is storing bytes near the physical end of a\n * circular buffer to temporarily reduce the buffer's size (in order to make\n * some storing idioms easier), while also making it simple to restore the\n * buffer's actual size when the buffer's \"pos\" wraps around to the start (we\n * just round the buffer's size up again). */\n\n#define IOBUF_WAS_REDUCED(siz) ((siz) & 0xFF)\n#define IOBUF_RESTORE_SIZE(siz) (((siz) | 0xFF) + 1)\n\n#define IN_MULTIPLEXED (iobuf.in_multiplexed != 0)\n#define IN_MULTIPLEXED_AND_READY (iobuf.in_multiplexed > 0)\n#define OUT_MULTIPLEXED (iobuf.out_empty_len != 0)\n\n#define PIO_NEED_INPUT (1<<0) /* The *_NEED_* flags are mutually exclusive. */\n#define PIO_NEED_OUTROOM (1<<1)\n#define PIO_NEED_MSGROOM (1<<2)\n\n#define PIO_CONSUME_INPUT (1<<4) /* Must becombined with PIO_NEED_INPUT. */\n\n#define PIO_INPUT_AND_CONSUME (PIO_NEED_INPUT | PIO_CONSUME_INPUT)\n#define PIO_NEED_FLAGS (PIO_NEED_INPUT | PIO_NEED_OUTROOM | PIO_NEED_MSGROOM)\n\n#define REMOTE_OPTION_ERROR \"rsync: on remote machine: -\"\n#define REMOTE_OPTION_ERROR2 \": unknown option\"\n\n#define FILESFROM_BUFLEN 2048\n\nenum festatus { FES_SUCCESS, FES_REDO, FES_NO_SEND };\n\nstatic flist_ndx_list redo_list, hlink_list;\n\nstatic void read_a_msg(void);\nstatic void drain_multiplex_messages(void);\nstatic void sleep_for_bwlimit(int bytes_written);\n\nstatic void check_timeout(BOOL allow_keepalive, int keepalive_flags)\n{\n\ttime_t t, chk;\n\n\t/* On the receiving side, the generator is now the one that decides\n\t * when a timeout has occurred.  When it is sifting through a lot of\n\t * files looking for work, it will be sending keep-alive messages to\n\t * the sender, and even though the receiver won't be sending/receiving\n\t * anything (not even keep-alive messages), the successful writes to\n\t * the sender will keep things going.  If the receiver is actively\n\t * receiving data, it will ensure that the generator knows that it is\n\t * not idle by sending the generator keep-alive messages (since the\n\t * generator might be blocked trying to send checksums, it needs to\n\t * know that the receiver is active).  Thus, as long as one or the\n\t * other is successfully doing work, the generator will not timeout. */\n\tif (!io_timeout)\n\t\treturn;\n\n\tt = time(NULL);\n\n\tif (allow_keepalive) {\n\t\t/* This may put data into iobuf.msg w/o flushing. */\n\t\tmaybe_send_keepalive(t, keepalive_flags);\n\t}\n\n\tif (!last_io_in)\n\t\tlast_io_in = t;\n\n\tif (am_receiver)\n\t\treturn;\n\n\tchk = MAX(last_io_out, last_io_in);\n\tif (t - chk >= io_timeout) {\n\t\tif (am_server)\n\t\t\tmsgs2stderr = 1;\n\t\trprintf(FERROR, \"[%s] io timeout after %d seconds -- exiting\\n\",\n\t\t\twho_am_i(), (int)(t-chk));\n\t\texit_cleanup(RERR_TIMEOUT);\n\t}\n}\n\n/* It's almost always an error to get an EOF when we're trying to read from the\n * network, because the protocol is (for the most part) self-terminating.\n *\n * There is one case for the receiver when it is at the end of the transfer\n * (hanging around reading any keep-alive packets that might come its way): if\n * the sender dies before the generator's kill-signal comes through, we can end\n * up here needing to loop until the kill-signal arrives.  In this situation,\n * kluge_around_eof will be < 0.\n *\n * There is another case for older protocol versions (< 24) where the module\n * listing was not terminated, so we must ignore an EOF error in that case and\n * exit.  In this situation, kluge_around_eof will be > 0. */\nstatic NORETURN void whine_about_eof(BOOL allow_kluge)\n{\n\tif (kluge_around_eof && allow_kluge) {\n\t\tint i;\n\t\tif (kluge_around_eof > 0)\n\t\t\texit_cleanup(0);\n\t\t/* If we're still here after 10 seconds, exit with an error. */\n\t\tfor (i = 10*1000/20; i--; )\n\t\t\tmsleep(20);\n\t}\n\n\trprintf(FERROR, RSYNC_NAME \": connection unexpectedly closed \"\n\t\t\"(%s bytes received so far) [%s]\\n\",\n\t\tbig_num(stats.total_read), who_am_i());\n\n\texit_cleanup(RERR_STREAMIO);\n}\n\n/* Do a safe read, handling any needed looping and error handling.\n * Returns the count of the bytes read, which will only be different\n * from \"len\" if we encountered an EOF.  This routine is not used on\n * the socket except very early in the transfer. */\nstatic size_t safe_read(int fd, char *buf, size_t len)\n{\n\tsize_t got = 0;\n\n\tassert(fd != iobuf.in_fd);\n\n\twhile (1) {\n\t\tstruct timeval tv;\n\t\tfd_set r_fds, e_fds;\n\t\tint cnt;\n\n\t\tFD_ZERO(&r_fds);\n\t\tFD_SET(fd, &r_fds);\n\t\tFD_ZERO(&e_fds);\n\t\tFD_SET(fd, &e_fds);\n\t\ttv.tv_sec = select_timeout;\n\t\ttv.tv_usec = 0;\n\n\t\tcnt = select(fd+1, &r_fds, NULL, &e_fds, &tv);\n\t\tif (cnt <= 0) {\n\t\t\tif (cnt < 0 && errno == EBADF) {\n\t\t\t\trsyserr(FERROR, errno, \"safe_read select failed\");\n\t\t\t\texit_cleanup(RERR_FILEIO);\n\t\t\t}\n\t\t\tcheck_timeout(1, MSK_ALLOW_FLUSH);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*if (FD_ISSET(fd, &e_fds))\n\t\t\trprintf(FINFO, \"select exception on fd %d\\n\", fd); */\n\n\t\tif (FD_ISSET(fd, &r_fds)) {\n\t\t\tssize_t n = read(fd, buf + got, len - got);\n\t\t\tif (DEBUG_GTE(IO, 2)) {\n\t\t\t\trprintf(FINFO, \"[%s] safe_read(%d)=%\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\t\t\twho_am_i(), fd, (SIZE_T_FMT_CAST)n);\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\trsyserr(FERROR, errno, \"safe_read failed to read %\" SIZE_T_FMT_MOD \"d bytes\",\n\t\t\t\t\t(SIZE_T_FMT_CAST)len);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t\tif ((got += (size_t)n) == len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn got;\n}\n\nstatic const char *what_fd_is(int fd)\n{\n\tstatic char buf[20];\n\n\tif (fd == sock_f_out)\n\t\treturn \"socket\";\n\telse if (fd == iobuf.out_fd)\n\t\treturn \"message fd\";\n\telse if (fd == batch_fd)\n\t\treturn \"batch file\";\n\telse {\n\t\tsnprintf(buf, sizeof buf, \"fd %d\", fd);\n\t\treturn buf;\n\t}\n}\n\n/* Do a safe write, handling any needed looping and error handling.\n * Returns only if everything was successfully written.  This routine\n * is not used on the socket except very early in the transfer. */\nstatic void safe_write(int fd, const char *buf, size_t len)\n{\n\tssize_t n;\n\n\tassert(fd != iobuf.out_fd);\n\n\tn = write(fd, buf, len);\n\tif ((size_t)n == len)\n\t\treturn;\n\tif (n < 0) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK && errno != EAGAIN) {\n\t\t  write_failed:\n\t\t\trsyserr(FERROR, errno,\n\t\t\t\t\"safe_write failed to write %\" SIZE_T_FMT_MOD \"d bytes to %s\",\n\t\t\t\t(SIZE_T_FMT_CAST)len, what_fd_is(fd));\n\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t}\n\t} else {\n\t\tbuf += n;\n\t\tlen -= n;\n\t}\n\n\twhile (len) {\n\t\tstruct timeval tv;\n\t\tfd_set w_fds;\n\t\tint cnt;\n\n\t\tFD_ZERO(&w_fds);\n\t\tFD_SET(fd, &w_fds);\n\t\ttv.tv_sec = select_timeout;\n\t\ttv.tv_usec = 0;\n\n\t\tcnt = select(fd + 1, NULL, &w_fds, NULL, &tv);\n\t\tif (cnt <= 0) {\n\t\t\tif (cnt < 0 && errno == EBADF) {\n\t\t\t\trsyserr(FERROR, errno, \"safe_write select failed on %s\", what_fd_is(fd));\n\t\t\t\texit_cleanup(RERR_FILEIO);\n\t\t\t}\n\t\t\tif (io_timeout)\n\t\t\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(fd, &w_fds)) {\n\t\t\tn = write(fd, buf, len);\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto write_failed;\n\t\t\t}\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n}\n\n/* This is only called when files-from data is known to be available.  We read\n * a chunk of data and put it into the output buffer. */\nstatic void forward_filesfrom_data(void)\n{\n\tssize_t len;\n\n\tlen = read(ff_forward_fd, ff_xb.buf + ff_xb.len, ff_xb.size - ff_xb.len);\n\tif (len <= 0) {\n\t\tif (len == 0 || errno != EINTR) {\n\t\t\t/* Send end-of-file marker */\n\t\t\tff_forward_fd = -1;\n\t\t\twrite_buf(iobuf.out_fd, \"\\0\\0\", ff_lastchar ? 2 : 1);\n\t\t\tfree_xbuf(&ff_xb);\n\t\t\tif (ff_reenable_multiplex >= 0)\n\t\t\t\tio_start_multiplex_out(ff_reenable_multiplex);\n\t\t\tfree_implied_include_partial_string();\n\t\t}\n\t\treturn;\n\t}\n\n\tif (DEBUG_GTE(IO, 2)) {\n\t\trprintf(FINFO, \"[%s] files-from read=%\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\twho_am_i(), (SIZE_T_FMT_CAST)len);\n\t}\n\n#ifdef ICONV_OPTION\n\tlen += ff_xb.len;\n#endif\n\n\tif (!eol_nulls) {\n\t\tchar *s = ff_xb.buf + len;\n\t\t/* Transform CR and/or LF into '\\0' */\n\t\twhile (s-- > ff_xb.buf) {\n\t\t\tif (*s == '\\n' || *s == '\\r')\n\t\t\t\t*s = '\\0';\n\t\t}\n\t}\n\n\tif (ff_lastchar)\n\t\tff_xb.pos = 0;\n\telse {\n\t\tchar *s = ff_xb.buf;\n\t\t/* Last buf ended with a '\\0', so don't let this buf start with one. */\n\t\twhile (len && *s == '\\0')\n\t\t\ts++, len--;\n\t\tff_xb.pos = s - ff_xb.buf;\n\t}\n\n#ifdef ICONV_OPTION\n\tif (filesfrom_convert && len) {\n\t\tchar *sob = ff_xb.buf + ff_xb.pos, *s = sob;\n\t\tchar *eob = sob + len;\n\t\tint flags = ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_CIRCULAR_OUT;\n\t\tif (ff_lastchar == '\\0')\n\t\t\tflags |= ICB_INIT;\n\t\t/* Convert/send each null-terminated string separately, skipping empties. */\n\t\twhile (s != eob) {\n\t\t\tif (*s++ == '\\0') {\n\t\t\t\tff_xb.len = s - sob - 1;\n\t\t\t\tadd_implied_include(sob, 0);\n\t\t\t\tif (iconvbufs(ic_send, &ff_xb, &iobuf.out, flags) < 0)\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL); /* impossible? */\n\t\t\t\twrite_buf(iobuf.out_fd, s-1, 1); /* Send the '\\0'. */\n\t\t\t\twhile (s != eob && *s == '\\0')\n\t\t\t\t\ts++;\n\t\t\t\tsob = s;\n\t\t\t\tff_xb.pos = sob - ff_xb.buf;\n\t\t\t\tflags |= ICB_INIT;\n\t\t\t}\n\t\t}\n\n\t\tif ((ff_xb.len = s - sob) == 0)\n\t\t\tff_lastchar = '\\0';\n\t\telse {\n\t\t\t/* Handle a partial string specially, saving any incomplete chars. */\n\t\t\timplied_include_partial_string(sob, s);\n\t\t\tflags &= ~ICB_INCLUDE_INCOMPLETE;\n\t\t\tif (iconvbufs(ic_send, &ff_xb, &iobuf.out, flags) < 0) {\n\t\t\t\tif (errno == E2BIG)\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL); /* impossible? */\n\t\t\t\tif (ff_xb.pos)\n\t\t\t\t\tmemmove(ff_xb.buf, ff_xb.buf + ff_xb.pos, ff_xb.len);\n\t\t\t}\n\t\t\tff_lastchar = 'x'; /* Anything non-zero. */\n\t\t}\n\t} else\n#endif\n\n\tif (len) {\n\t\tchar *f = ff_xb.buf + ff_xb.pos;\n\t\tchar *t = ff_xb.buf;\n\t\tchar *eob = f + len;\n\t\tchar *cur = t;\n\t\t/* Eliminate any multi-'\\0' runs. */\n\t\twhile (f != eob) {\n\t\t\tif (!(*t++ = *f++)) {\n\t\t\t\tadd_implied_include(cur, 0);\n\t\t\t\tcur = t;\n\t\t\t\twhile (f != eob && *f == '\\0')\n\t\t\t\t\tf++;\n\t\t\t}\n\t\t}\n\t\timplied_include_partial_string(cur, t);\n\t\tff_lastchar = f[-1];\n\t\tif ((len = t - ff_xb.buf) != 0) {\n\t\t\t/* This will not circle back to perform_io() because we only get\n\t\t\t * called when there is plenty of room in the output buffer. */\n\t\t\twrite_buf(iobuf.out_fd, ff_xb.buf, len);\n\t\t}\n\t}\n}\n\nvoid reduce_iobuf_size(xbuf *out, size_t new_size)\n{\n\tif (new_size < out->size) {\n\t\t/* Avoid weird buffer interactions by only outputting this to stderr. */\n\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 4)) {\n\t\t\tconst char *name = out == &iobuf.out ? \"iobuf.out\"\n\t\t\t\t\t : out == &iobuf.msg ? \"iobuf.msg\"\n\t\t\t\t\t : NULL;\n\t\t\tif (name) {\n\t\t\t\trprintf(FINFO, \"[%s] reduced size of %s (-%d)\\n\",\n\t\t\t\t\twho_am_i(), name, (int)(out->size - new_size));\n\t\t\t}\n\t\t}\n\t\tout->size = new_size;\n\t}\n}\n\nvoid restore_iobuf_size(xbuf *out)\n{\n\tif (IOBUF_WAS_REDUCED(out->size)) {\n\t\tsize_t new_size = IOBUF_RESTORE_SIZE(out->size);\n\t\t/* Avoid weird buffer interactions by only outputting this to stderr. */\n\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 4)) {\n\t\t\tconst char *name = out == &iobuf.out ? \"iobuf.out\"\n\t\t\t\t\t : out == &iobuf.msg ? \"iobuf.msg\"\n\t\t\t\t\t : NULL;\n\t\t\tif (name) {\n\t\t\t\trprintf(FINFO, \"[%s] restored size of %s (+%d)\\n\",\n\t\t\t\t\twho_am_i(), name, (int)(new_size - out->size));\n\t\t\t}\n\t\t}\n\t\tout->size = new_size;\n\t}\n}\n\nstatic void handle_kill_signal(BOOL flush_ok)\n{\n\tgot_kill_signal = -1;\n\tflush_ok_after_signal = flush_ok;\n\texit_cleanup(RERR_SIGNAL);\n}\n\n/* Perform buffered input and/or output until specified conditions are met.\n * When given a \"needed\" read or write request, this returns without doing any\n * I/O if the needed input bytes or write space is already available.  Once I/O\n * is needed, this will try to do whatever reading and/or writing is currently\n * possible, up to the maximum buffer allowances, no matter if this is a read\n * or write request.  However, the I/O stops as soon as the required input\n * bytes or output space is available.  If this is not a read request, the\n * routine may also do some advantageous reading of messages from a multiplexed\n * input source (which ensures that we don't jam up with everyone in their\n * \"need to write\" code and nobody reading the accumulated data that would make\n * writing possible).\n *\n * The iobuf.in, .out and .msg buffers are all circular.  Callers need to be\n * aware that some data copies will need to be split when the bytes wrap around\n * from the end to the start.  In order to help make writing into the output\n * buffers easier for some operations (such as the use of SIVAL() into the\n * buffer) a buffer may be temporarily shortened by a small amount, but the\n * original size will be automatically restored when the .pos wraps to the\n * start.  See also the 3 raw_* iobuf vars that are used in the handling of\n * MSG_DATA bytes as they are read-from/written-into the buffers.\n *\n * When writing, we flush data in the following priority order:\n *\n * 1. Finish writing any in-progress MSG_DATA sequence from iobuf.out.\n *\n * 2. Write out all the messages from the message buf (if iobuf.msg is active).\n *    Yes, this means that a PIO_NEED_OUTROOM call will completely flush any\n *    messages before getting to the iobuf.out flushing (except for rule 1).\n *\n * 3. Write out the raw data from iobuf.out, possibly filling in the multiplexed\n *    MSG_DATA header that was pre-allocated (when output is multiplexed).\n *\n * TODO:  items for possible future work:\n *\n *    - Make this routine able to read the generator-to-receiver batch flow?\n *\n * Unlike the old routines that this replaces, it is OK to read ahead as far as\n * we can because the read_a_msg() routine now reads its bytes out of the input\n * buffer.  In the old days, only raw data was in the input buffer, and any\n * unused raw data in the buf would prevent the reading of socket data. */\nstatic char *perform_io(size_t needed, int flags)\n{\n\tfd_set r_fds, e_fds, w_fds;\n\tstruct timeval tv;\n\tint cnt, max_fd;\n\tsize_t empty_buf_len = 0;\n\txbuf *out;\n\tchar *data;\n\n\tif (iobuf.in.len == 0 && iobuf.in.pos != 0) {\n\t\tif (iobuf.raw_input_ends_before)\n\t\t\tiobuf.raw_input_ends_before -= iobuf.in.pos;\n\t\tiobuf.in.pos = 0;\n\t}\n\n\tswitch (flags & PIO_NEED_FLAGS) {\n\tcase PIO_NEED_INPUT:\n\t\t/* We never resize the circular input buffer. */\n\t\tif (iobuf.in.size < needed) {\n\t\t\trprintf(FERROR, \"need to read %\" SIZE_T_FMT_MOD \"d bytes,\"\n\t\t\t\t\t\" iobuf.in.buf is only %\" SIZE_T_FMT_MOD \"d bytes.\\n\",\n\t\t\t\t(SIZE_T_FMT_CAST)needed, (SIZE_T_FMT_CAST)iobuf.in.size);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 3)) {\n\t\t\trprintf(FINFO, \"[%s] perform_io(%\" SIZE_T_FMT_MOD \"d, %sinput)\\n\",\n\t\t\t\twho_am_i(), (SIZE_T_FMT_CAST)needed, flags & PIO_CONSUME_INPUT ? \"consume&\" : \"\");\n\t\t}\n\t\tbreak;\n\n\tcase PIO_NEED_OUTROOM:\n\t\t/* We never resize the circular output buffer. */\n\t\tif (iobuf.out.size - iobuf.out_empty_len < needed) {\n\t\t\tfprintf(stderr, \"need to write %\" SIZE_T_FMT_MOD \"d bytes,\"\n\t\t\t\t\t\" iobuf.out.buf is only %\" SIZE_T_FMT_MOD \"d bytes.\\n\",\n\t\t\t\t(SIZE_T_FMT_CAST)needed, (SIZE_T_FMT_CAST)(iobuf.out.size - iobuf.out_empty_len));\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 3)) {\n\t\t\trprintf(FINFO, \"[%s] perform_io(%\" SIZE_T_FMT_MOD \"d,\"\n\t\t\t\t       \" outroom) needs to flush %\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\t\twho_am_i(), (SIZE_T_FMT_CAST)needed,\n\t\t\t\tiobuf.out.len + needed > iobuf.out.size\n\t\t\t\t? (SIZE_T_FMT_CAST)(iobuf.out.len + needed - iobuf.out.size) : (SIZE_T_FMT_CAST)0);\n\t\t}\n\t\tbreak;\n\n\tcase PIO_NEED_MSGROOM:\n\t\t/* We never resize the circular message buffer. */\n\t\tif (iobuf.msg.size < needed) {\n\t\t\tfprintf(stderr, \"need to write %\" SIZE_T_FMT_MOD \"d bytes,\"\n\t\t\t\t\t\" iobuf.msg.buf is only %\" SIZE_T_FMT_MOD \"d bytes.\\n\",\n\t\t\t\t(SIZE_T_FMT_CAST)needed, (SIZE_T_FMT_CAST)iobuf.msg.size);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 3)) {\n\t\t\trprintf(FINFO, \"[%s] perform_io(%\" SIZE_T_FMT_MOD \"d,\"\n\t\t\t\t       \" msgroom) needs to flush %\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\t\twho_am_i(), (SIZE_T_FMT_CAST)needed,\n\t\t\t\tiobuf.msg.len + needed > iobuf.msg.size\n\t\t\t\t? (SIZE_T_FMT_CAST)(iobuf.msg.len + needed - iobuf.msg.size) : (SIZE_T_FMT_CAST)0);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 3)) {\n\t\t\trprintf(FINFO, \"[%s] perform_io(%\" SIZE_T_FMT_MOD \"d, %d)\\n\",\n\t\t\t\twho_am_i(), (SIZE_T_FMT_CAST)needed, flags);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\twhile (1) {\n\t\tswitch (flags & PIO_NEED_FLAGS) {\n\t\tcase PIO_NEED_INPUT:\n\t\t\tif (iobuf.in.len >= needed)\n\t\t\t\tgoto double_break;\n\t\t\tbreak;\n\t\tcase PIO_NEED_OUTROOM:\n\t\t\t/* Note that iobuf.out_empty_len doesn't factor into this check\n\t\t\t * because iobuf.out.len already holds any needed header len. */\n\t\t\tif (iobuf.out.len + needed <= iobuf.out.size)\n\t\t\t\tgoto double_break;\n\t\t\tbreak;\n\t\tcase PIO_NEED_MSGROOM:\n\t\t\tif (iobuf.msg.len + needed <= iobuf.msg.size)\n\t\t\t\tgoto double_break;\n\t\t\tbreak;\n\t\t}\n\n\t\tmax_fd = -1;\n\n\t\tFD_ZERO(&r_fds);\n\t\tFD_ZERO(&e_fds);\n\t\tif (iobuf.in_fd >= 0 && iobuf.in.size - iobuf.in.len) {\n\t\t\tif (!read_batch || batch_fd >= 0) {\n\t\t\t\tFD_SET(iobuf.in_fd, &r_fds);\n\t\t\t\tFD_SET(iobuf.in_fd, &e_fds);\n\t\t\t}\n\t\t\tif (iobuf.in_fd > max_fd)\n\t\t\t\tmax_fd = iobuf.in_fd;\n\t\t}\n\n\t\t/* Only do more filesfrom processing if there is enough room in the out buffer. */\n\t\tif (ff_forward_fd >= 0 && iobuf.out.size - iobuf.out.len > FILESFROM_BUFLEN*2) {\n\t\t\tFD_SET(ff_forward_fd, &r_fds);\n\t\t\tif (ff_forward_fd > max_fd)\n\t\t\t\tmax_fd = ff_forward_fd;\n\t\t}\n\n\t\tFD_ZERO(&w_fds);\n\t\tif (iobuf.out_fd >= 0) {\n\t\t\tif (iobuf.raw_flushing_ends_before\n\t\t\t || (!iobuf.msg.len && iobuf.out.len > iobuf.out_empty_len && !(flags & PIO_NEED_MSGROOM))) {\n\t\t\t\tif (OUT_MULTIPLEXED && !iobuf.raw_flushing_ends_before) {\n\t\t\t\t\t/* The iobuf.raw_flushing_ends_before value can point off the end\n\t\t\t\t\t * of the iobuf.out buffer for a while, for easier subtracting. */\n\t\t\t\t\tiobuf.raw_flushing_ends_before = iobuf.out.pos + iobuf.out.len;\n\n\t\t\t\t\tSIVAL(iobuf.out.buf + iobuf.raw_data_header_pos, 0,\n\t\t\t\t\t      ((MPLEX_BASE + (int)MSG_DATA)<<24) + iobuf.out.len - 4);\n\n\t\t\t\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 1)) {\n\t\t\t\t\t\trprintf(FINFO, \"[%s] send_msg(%d, %\" SIZE_T_FMT_MOD \"d)\\n\",\n\t\t\t\t\t\t\twho_am_i(), (int)MSG_DATA, (SIZE_T_FMT_CAST)iobuf.out.len - 4);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* reserve room for the next MSG_DATA header */\n\t\t\t\t\tiobuf.raw_data_header_pos = iobuf.raw_flushing_ends_before;\n\t\t\t\t\tif (iobuf.raw_data_header_pos >= iobuf.out.size)\n\t\t\t\t\t\tiobuf.raw_data_header_pos -= iobuf.out.size;\n\t\t\t\t\telse if (iobuf.raw_data_header_pos + 4 > iobuf.out.size) {\n\t\t\t\t\t\t/* The 4-byte header won't fit at the end of the buffer,\n\t\t\t\t\t\t * so we'll temporarily reduce the output buffer's size\n\t\t\t\t\t\t * and put the header at the start of the buffer. */\n\t\t\t\t\t\treduce_iobuf_size(&iobuf.out, iobuf.raw_data_header_pos);\n\t\t\t\t\t\tiobuf.raw_data_header_pos = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Yes, it is possible for this to make len > size for a while. */\n\t\t\t\t\tiobuf.out.len += 4;\n\t\t\t\t}\n\n\t\t\t\tempty_buf_len = iobuf.out_empty_len;\n\t\t\t\tout = &iobuf.out;\n\t\t\t} else if (iobuf.msg.len) {\n\t\t\t\tempty_buf_len = 0;\n\t\t\t\tout = &iobuf.msg;\n\t\t\t} else\n\t\t\t\tout = NULL;\n\t\t\tif (out) {\n\t\t\t\tFD_SET(iobuf.out_fd, &w_fds);\n\t\t\t\tif (iobuf.out_fd > max_fd)\n\t\t\t\t\tmax_fd = iobuf.out_fd;\n\t\t\t}\n\t\t} else\n\t\t\tout = NULL;\n\n\t\tif (max_fd < 0) {\n\t\t\tswitch (flags & PIO_NEED_FLAGS) {\n\t\t\tcase PIO_NEED_INPUT:\n\t\t\t\tiobuf.in.len = 0;\n\t\t\t\tif (kluge_around_eof == 2)\n\t\t\t\t\texit_cleanup(0);\n\t\t\t\tif (iobuf.in_fd == -2)\n\t\t\t\t\twhine_about_eof(True);\n\t\t\t\trprintf(FERROR, \"error in perform_io: no fd for input.\\n\");\n\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\tcase PIO_NEED_OUTROOM:\n\t\t\tcase PIO_NEED_MSGROOM:\n\t\t\t\tmsgs2stderr = 1;\n\t\t\t\tdrain_multiplex_messages();\n\t\t\t\tif (iobuf.out_fd == -2)\n\t\t\t\t\twhine_about_eof(True);\n\t\t\t\trprintf(FERROR, \"error in perform_io: no fd for output.\\n\");\n\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\tdefault:\n\t\t\t\t/* No stated needs, so I guess this is OK. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (got_kill_signal > 0)\n\t\t\thandle_kill_signal(True);\n\n\t\tif (extra_flist_sending_enabled) {\n\t\t\tif (file_total - file_old_total < MAX_FILECNT_LOOKAHEAD && IN_MULTIPLEXED_AND_READY)\n\t\t\t\ttv.tv_sec = 0;\n\t\t\telse {\n\t\t\t\textra_flist_sending_enabled = False;\n\t\t\t\ttv.tv_sec = select_timeout;\n\t\t\t}\n\t\t} else\n\t\t\ttv.tv_sec = select_timeout;\n\t\ttv.tv_usec = 0;\n\n\t\tcnt = select(max_fd + 1, &r_fds, &w_fds, &e_fds, &tv);\n\n\t\tif (cnt <= 0) {\n\t\t\tif (cnt < 0 && errno == EBADF) {\n\t\t\t\tmsgs2stderr = 1;\n\t\t\t\texit_cleanup(RERR_SOCKETIO);\n\t\t\t}\n\t\t\tif (extra_flist_sending_enabled) {\n\t\t\t\textra_flist_sending_enabled = False;\n\t\t\t\tsend_extra_file_list(sock_f_out, -1);\n\t\t\t\textra_flist_sending_enabled = !flist_eof;\n\t\t\t} else\n\t\t\t\tcheck_timeout((flags & PIO_NEED_INPUT) != 0, 0);\n\t\t\tFD_ZERO(&r_fds); /* Just in case... */\n\t\t\tFD_ZERO(&w_fds);\n\t\t}\n\n\t\tif (iobuf.in_fd >= 0 && FD_ISSET(iobuf.in_fd, &r_fds)) {\n\t\t\tsize_t len, pos = iobuf.in.pos + iobuf.in.len;\n\t\t\tssize_t n;\n\t\t\tif (pos >= iobuf.in.size) {\n\t\t\t\tpos -= iobuf.in.size;\n\t\t\t\tlen = iobuf.in.size - iobuf.in.len;\n\t\t\t} else\n\t\t\t\tlen = iobuf.in.size - pos;\n\t\t\tif ((n = read(iobuf.in_fd, iobuf.in.buf + pos, len)) <= 0) {\n\t\t\t\tif (n == 0) {\n\t\t\t\t\t/* Signal that input has become invalid. */\n\t\t\t\t\tif (!read_batch || batch_fd < 0 || am_generator)\n\t\t\t\t\t\tiobuf.in_fd = -2;\n\t\t\t\t\tbatch_fd = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)\n\t\t\t\t\tn = 0;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't write errors on a dead socket. */\n\t\t\t\t\tif (iobuf.in_fd == sock_f_in) {\n\t\t\t\t\t\tif (am_sender)\n\t\t\t\t\t\t\tmsgs2stderr = 1;\n\t\t\t\t\t\trsyserr(FERROR_SOCKET, errno, \"read error\");\n\t\t\t\t\t} else\n\t\t\t\t\t\trsyserr(FERROR, errno, \"read error\");\n\t\t\t\t\texit_cleanup(RERR_SOCKETIO);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2)) {\n\t\t\t\trprintf(FINFO, \"[%s] recv=%\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\t\t\twho_am_i(), (SIZE_T_FMT_CAST)n);\n\t\t\t}\n\n\t\t\tif (io_timeout) {\n\t\t\t\tlast_io_in = time(NULL);\n\t\t\t\tif (io_timeout && flags & PIO_NEED_INPUT)\n\t\t\t\t\tmaybe_send_keepalive(last_io_in, 0);\n\t\t\t}\n\t\t\tstats.total_read += n;\n\n\t\t\tiobuf.in.len += n;\n\t\t}\n\n\t\tif (stop_at_utime && time(NULL) >= stop_at_utime) {\n\t\t\trprintf(FERROR, \"stopping at requested limit\\n\");\n\t\t\texit_cleanup(RERR_TIMEOUT);\n\t\t}\n\n\t\tif (out && FD_ISSET(iobuf.out_fd, &w_fds)) {\n\t\t\tsize_t len = iobuf.raw_flushing_ends_before ? iobuf.raw_flushing_ends_before - out->pos : out->len;\n\t\t\tssize_t n;\n\n\t\t\tif (bwlimit_writemax && len > bwlimit_writemax)\n\t\t\t\tlen = bwlimit_writemax;\n\n\t\t\tif (out->pos + len > out->size)\n\t\t\t\tlen = out->size - out->pos;\n\t\t\tif ((n = write(iobuf.out_fd, out->buf + out->pos, len)) <= 0) {\n\t\t\t\tif (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)\n\t\t\t\t\tn = 0;\n\t\t\t\telse {\n\t\t\t\t\t/* Don't write errors on a dead socket. */\n\t\t\t\t\tmsgs2stderr = 1;\n\t\t\t\t\tiobuf.out_fd = -2;\n\t\t\t\t\tiobuf.out.len = iobuf.msg.len = iobuf.raw_flushing_ends_before = 0;\n\t\t\t\t\trsyserr(FERROR_SOCKET, errno, \"write error\");\n\t\t\t\t\tdrain_multiplex_messages();\n\t\t\t\t\texit_cleanup(RERR_SOCKETIO);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2)) {\n\t\t\t\trprintf(FINFO, \"[%s] %s sent=%\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\t\t\twho_am_i(), out == &iobuf.out ? \"out\" : \"msg\", (SIZE_T_FMT_CAST)n);\n\t\t\t}\n\n\t\t\tif (io_timeout)\n\t\t\t\tlast_io_out = time(NULL);\n\t\t\tstats.total_written += n;\n\n\t\t\tif (bwlimit_writemax)\n\t\t\t\tsleep_for_bwlimit(n);\n\n\t\t\tif ((out->pos += n) == out->size) {\n\t\t\t\tif (iobuf.raw_flushing_ends_before)\n\t\t\t\t\tiobuf.raw_flushing_ends_before -= out->size;\n\t\t\t\tout->pos = 0;\n\t\t\t\trestore_iobuf_size(out);\n\t\t\t} else if (out->pos == iobuf.raw_flushing_ends_before)\n\t\t\t\tiobuf.raw_flushing_ends_before = 0;\n\t\t\tif ((out->len -= n) == empty_buf_len) {\n\t\t\t\tout->pos = 0;\n\t\t\t\trestore_iobuf_size(out);\n\t\t\t\tif (empty_buf_len)\n\t\t\t\t\tiobuf.raw_data_header_pos = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (got_kill_signal > 0)\n\t\t\thandle_kill_signal(True);\n\n\t\t/* We need to help prevent deadlock by doing what reading\n\t\t * we can whenever we are here trying to write. */\n\t\tif (IN_MULTIPLEXED_AND_READY && !(flags & PIO_NEED_INPUT)) {\n\t\t\twhile (!iobuf.raw_input_ends_before && iobuf.in.len > 512)\n\t\t\t\tread_a_msg();\n\t\t\tif (flist_receiving_enabled && iobuf.in.len > 512)\n\t\t\t\twait_for_receiver(); /* generator only */\n\t\t}\n\n\t\tif (ff_forward_fd >= 0 && FD_ISSET(ff_forward_fd, &r_fds)) {\n\t\t\t/* This can potentially flush all output and enable\n\t\t\t * multiplexed output, so keep this last in the loop\n\t\t\t * and be sure to not cache anything that would break\n\t\t\t * such a change. */\n\t\t\tforward_filesfrom_data();\n\t\t}\n\t}\n  double_break:\n\n\tif (got_kill_signal > 0)\n\t\thandle_kill_signal(True);\n\n\tdata = iobuf.in.buf + iobuf.in.pos;\n\n\tif (flags & PIO_CONSUME_INPUT) {\n\t\tiobuf.in.len -= needed;\n\t\tiobuf.in.pos += needed;\n\t\tif (iobuf.in.pos == iobuf.raw_input_ends_before)\n\t\t\tiobuf.raw_input_ends_before = 0;\n\t\tif (iobuf.in.pos >= iobuf.in.size) {\n\t\t\tiobuf.in.pos -= iobuf.in.size;\n\t\t\tif (iobuf.raw_input_ends_before)\n\t\t\t\tiobuf.raw_input_ends_before -= iobuf.in.size;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nstatic void raw_read_buf(char *buf, size_t len)\n{\n\tsize_t pos = iobuf.in.pos;\n\tchar *data = perform_io(len, PIO_INPUT_AND_CONSUME);\n\tif (iobuf.in.pos <= pos && len) {\n\t\tsize_t siz = len - iobuf.in.pos;\n\t\tmemcpy(buf, data, siz);\n\t\tmemcpy(buf + siz, iobuf.in.buf, iobuf.in.pos);\n\t} else\n\t\tmemcpy(buf, data, len);\n}\n\nstatic int32 raw_read_int(void)\n{\n\tchar *data, buf[4];\n\tif (iobuf.in.size - iobuf.in.pos >= 4)\n\t\tdata = perform_io(4, PIO_INPUT_AND_CONSUME);\n\telse\n\t\traw_read_buf(data = buf, 4);\n\treturn IVAL(data, 0);\n}\n\nvoid noop_io_until_death(void)\n{\n\tchar buf[1024];\n\n\tif (!iobuf.in.buf || !iobuf.out.buf || iobuf.in_fd < 0 || iobuf.out_fd < 0 || kluge_around_eof)\n\t\treturn;\n\n\t/* If we're talking to a daemon over a socket, don't short-circuit this logic */\n\tif (msgs2stderr && daemon_connection >= 0)\n\t\treturn;\n\n\tkluge_around_eof = 2;\n\t/* Setting an I/O timeout ensures that if something inexplicably weird\n\t * happens, we won't hang around forever. */\n\tif (!io_timeout)\n\t\tset_io_timeout(60);\n\n\twhile (1)\n\t\tread_buf(iobuf.in_fd, buf, sizeof buf);\n}\n\n/* Buffer a message for the multiplexed output stream.  Is not used for (normal) MSG_DATA. */\nint send_msg(enum msgcode code, const char *buf, size_t len, int convert)\n{\n\tchar *hdr;\n\tsize_t needed, pos;\n\tBOOL want_debug = DEBUG_GTE(IO, 1) && convert >= 0 && (msgs2stderr == 1 || code != MSG_INFO);\n\n\tif (!OUT_MULTIPLEXED)\n\t\treturn 0;\n\n\tif (want_debug) {\n\t\trprintf(FINFO, \"[%s] send_msg(%d, %\" SIZE_T_FMT_MOD \"d)\\n\",\n\t\t\twho_am_i(), (int)code, (SIZE_T_FMT_CAST)len);\n\t}\n\n\t/* When checking for enough free space for this message, we need to\n\t * make sure that there is space for the 4-byte header, plus we'll\n\t * assume that we may waste up to 3 bytes (if the header doesn't fit\n\t * at the physical end of the buffer). */\n#ifdef ICONV_OPTION\n\tif (convert > 0 && ic_send == (iconv_t)-1)\n\t\tconvert = 0;\n\tif (convert > 0) {\n\t\t/* Ensuring double-size room leaves space for maximal conversion expansion. */\n\t\tneeded = len*2 + 4 + 3;\n\t} else\n#endif\n\t\tneeded = len + 4 + 3;\n\tif (iobuf.msg.len + needed > iobuf.msg.size) {\n\t\tif (am_sender)\n\t\t\tperform_io(needed, PIO_NEED_MSGROOM);\n\t\telse { /* We sometimes allow the iobuf.msg size to increase to avoid a deadlock. */\n\t\t\tsize_t old_size = iobuf.msg.size;\n\t\t\trestore_iobuf_size(&iobuf.msg);\n\t\t\trealloc_xbuf(&iobuf.msg, iobuf.msg.size * 2);\n\t\t\tif (iobuf.msg.pos + iobuf.msg.len > old_size)\n\t\t\t\tmemcpy(iobuf.msg.buf + old_size, iobuf.msg.buf, iobuf.msg.pos + iobuf.msg.len - old_size);\n\t\t}\n\t}\n\n\tpos = iobuf.msg.pos + iobuf.msg.len; /* Must be set after any flushing. */\n\tif (pos >= iobuf.msg.size)\n\t\tpos -= iobuf.msg.size;\n\telse if (pos + 4 > iobuf.msg.size) {\n\t\t/* The 4-byte header won't fit at the end of the buffer,\n\t\t * so we'll temporarily reduce the message buffer's size\n\t\t * and put the header at the start of the buffer. */\n\t\treduce_iobuf_size(&iobuf.msg, pos);\n\t\tpos = 0;\n\t}\n\thdr = iobuf.msg.buf + pos;\n\n\tiobuf.msg.len += 4; /* Allocate room for the coming header bytes. */\n\n#ifdef ICONV_OPTION\n\tif (convert > 0) {\n\t\txbuf inbuf;\n\n\t\tINIT_XBUF(inbuf, (char*)buf, len, (size_t)-1);\n\n\t\tlen = iobuf.msg.len;\n\t\ticonvbufs(ic_send, &inbuf, &iobuf.msg,\n\t\t\t  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_CIRCULAR_OUT | ICB_INIT);\n\t\tif (inbuf.len > 0) {\n\t\t\trprintf(FERROR, \"overflowed iobuf.msg buffer in send_msg\");\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t\tlen = iobuf.msg.len - len;\n\t} else\n#endif\n\t{\n\t\tsize_t siz;\n\n\t\tif ((pos += 4) == iobuf.msg.size)\n\t\t\tpos = 0;\n\n\t\t/* Handle a split copy if we wrap around the end of the circular buffer. */\n\t\tif (pos >= iobuf.msg.pos && (siz = iobuf.msg.size - pos) < len) {\n\t\t\tmemcpy(iobuf.msg.buf + pos, buf, siz);\n\t\t\tmemcpy(iobuf.msg.buf, buf + siz, len - siz);\n\t\t} else\n\t\t\tmemcpy(iobuf.msg.buf + pos, buf, len);\n\n\t\tiobuf.msg.len += len;\n\t}\n\n\tSIVAL(hdr, 0, ((MPLEX_BASE + (int)code)<<24) + len);\n\n\tif (want_debug && convert > 0) {\n\t\trprintf(FINFO, \"[%s] converted msg len=%\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\twho_am_i(), (SIZE_T_FMT_CAST)len);\n\t}\n\n\treturn 1;\n}\n\nvoid send_msg_int(enum msgcode code, int num)\n{\n\tchar numbuf[4];\n\n\tif (DEBUG_GTE(IO, 1))\n\t\trprintf(FINFO, \"[%s] send_msg_int(%d, %d)\\n\", who_am_i(), (int)code, num);\n\n\tSIVAL(numbuf, 0, num);\n\tsend_msg(code, numbuf, 4, -1);\n}\n\nvoid send_msg_success(const char *fname, int num)\n{\n\tif (local_server) {\n\t\tSTRUCT_STAT st;\n\n\t\tif (DEBUG_GTE(IO, 1))\n\t\t\trprintf(FINFO, \"[%s] send_msg_success(%d)\\n\", who_am_i(), num);\n\n\t\tif (stat(fname, &st) < 0)\n\t\t\tmemset(&st, 0, sizeof (STRUCT_STAT));\n\t\tSIVAL(num_dev_ino_buf, 0, num);\n\t\tSIVAL64(num_dev_ino_buf, 4, st.st_dev);\n\t\tSIVAL64(num_dev_ino_buf, 4+8, st.st_ino);\n\t\tsend_msg(MSG_SUCCESS, num_dev_ino_buf, sizeof num_dev_ino_buf, -1);\n\t} else\n\t\tsend_msg_int(MSG_SUCCESS, num);\n}\n\nstatic void got_flist_entry_status(enum festatus status, int ndx)\n{\n\tstruct file_list *flist = flist_for_ndx(ndx, \"got_flist_entry_status\");\n\n\tif (remove_source_files) {\n\t\tactive_filecnt--;\n\t\tactive_bytecnt -= F_LENGTH(flist->files[ndx - flist->ndx_start]);\n\t}\n\n\tif (inc_recurse)\n\t\tflist->in_progress--;\n\n\tswitch (status) {\n\tcase FES_SUCCESS:\n\t\tif (remove_source_files) {\n\t\t\tif (local_server)\n\t\t\t\tsend_msg(MSG_SUCCESS, num_dev_ino_buf, sizeof num_dev_ino_buf, -1);\n\t\t\telse\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t}\n\t\t/* FALL THROUGH */\n\tcase FES_NO_SEND:\n#ifdef SUPPORT_HARD_LINKS\n\t\tif (preserve_hard_links) {\n\t\t\tstruct file_struct *file = flist->files[ndx - flist->ndx_start];\n\t\t\tif (F_IS_HLINKED(file)) {\n\t\t\t\tif (status == FES_NO_SEND)\n\t\t\t\t\tflist_ndx_push(&hlink_list, -2); /* indicates a failure follows */\n\t\t\t\tflist_ndx_push(&hlink_list, ndx);\n\t\t\t\tif (inc_recurse)\n\t\t\t\t\tflist->in_progress++;\n\t\t\t}\n\t\t}\n#endif\n\t\tbreak;\n\tcase FES_REDO:\n\t\tif (read_batch) {\n\t\t\tif (inc_recurse)\n\t\t\t\tflist->in_progress++;\n\t\t\tbreak;\n\t\t}\n\t\tif (inc_recurse)\n\t\t\tflist->to_redo++;\n\t\tflist_ndx_push(&redo_list, ndx);\n\t\tbreak;\n\t}\n}\n\n/* Note the fds used for the main socket (which might really be a pipe\n * for a local transfer, but we can ignore that). */\nvoid io_set_sock_fds(int f_in, int f_out)\n{\n\tsock_f_in = f_in;\n\tsock_f_out = f_out;\n}\n\nvoid set_io_timeout(int secs)\n{\n\tio_timeout = secs;\n\tallowed_lull = (io_timeout + 1) / 2;\n\n\tif (!io_timeout || allowed_lull > SELECT_TIMEOUT)\n\t\tselect_timeout = SELECT_TIMEOUT;\n\telse\n\t\tselect_timeout = allowed_lull;\n\n\tif (read_batch)\n\t\tallowed_lull = 0;\n}\n\nstatic void check_for_d_option_error(const char *msg)\n{\n\tstatic char rsync263_opts[] = \"BCDHIKLPRSTWabceghlnopqrtuvxz\";\n\tchar *colon;\n\tint saw_d = 0;\n\n\tif (*msg != 'r'\n\t || strncmp(msg, REMOTE_OPTION_ERROR, sizeof REMOTE_OPTION_ERROR - 1) != 0)\n\t\treturn;\n\n\tmsg += sizeof REMOTE_OPTION_ERROR - 1;\n\tif (*msg == '-' || (colon = strchr(msg, ':')) == NULL\n\t || strncmp(colon, REMOTE_OPTION_ERROR2, sizeof REMOTE_OPTION_ERROR2 - 1) != 0)\n\t\treturn;\n\n\tfor ( ; *msg != ':'; msg++) {\n\t\tif (*msg == 'd')\n\t\t\tsaw_d = 1;\n\t\telse if (*msg == 'e')\n\t\t\tbreak;\n\t\telse if (strchr(rsync263_opts, *msg) == NULL)\n\t\t\treturn;\n\t}\n\n\tif (saw_d) {\n\t\trprintf(FWARNING, \"*** Try using \\\"--old-d\\\" if remote rsync is <= 2.6.3 ***\\n\");\n\t}\n}\n\n/* This is used by the generator to limit how many file transfers can\n * be active at once when --remove-source-files is specified.  Without\n * this, sender-side deletions were mostly happening at the end. */\nvoid increment_active_files(int ndx, int itemizing, enum logcode code)\n{\n\twhile (1) {\n\t\t/* TODO: tune these limits? */\n\t\tint limit = active_bytecnt >= 128*1024 ? 10 : 50;\n\t\tif (active_filecnt < limit)\n\t\t\tbreak;\n\t\tcheck_for_finished_files(itemizing, code, 0);\n\t\tif (active_filecnt < limit)\n\t\t\tbreak;\n\t\twait_for_receiver();\n\t}\n\n\tactive_filecnt++;\n\tactive_bytecnt += F_LENGTH(cur_flist->files[ndx - cur_flist->ndx_start]);\n}\n\nint get_redo_num(void)\n{\n\treturn flist_ndx_pop(&redo_list);\n}\n\nint get_hlink_num(void)\n{\n\treturn flist_ndx_pop(&hlink_list);\n}\n\n/* When we're the receiver and we have a local --files-from list of names\n * that needs to be sent over the socket to the sender, we have to do two\n * things at the same time: send the sender a list of what files we're\n * processing and read the incoming file+info list from the sender.  We do\n * this by making recv_file_list() call forward_filesfrom_data(), which\n * will ensure that we forward data to the sender until we get some data\n * for recv_file_list() to use. */\nvoid start_filesfrom_forwarding(int fd)\n{\n\tif (protocol_version < 31 && OUT_MULTIPLEXED) {\n\t\t/* Older protocols send the files-from data w/o packaging\n\t\t * it in multiplexed I/O packets, so temporarily switch\n\t\t * to buffered I/O to match this behavior. */\n\t\tiobuf.msg.pos = iobuf.msg.len = 0; /* Be extra sure no messages go out. */\n\t\tff_reenable_multiplex = io_end_multiplex_out(MPLX_TO_BUFFERED);\n\t}\n\tff_forward_fd = fd;\n\n\talloc_xbuf(&ff_xb, FILESFROM_BUFLEN);\n}\n\n/* Read a line into the \"buf\" buffer. */\nint read_line(int fd, char *buf, size_t bufsiz, int flags)\n{\n\tchar ch, *s, *eob;\n\n#ifdef ICONV_OPTION\n\tif (flags & RL_CONVERT && iconv_buf.size < bufsiz)\n\t\trealloc_xbuf(&iconv_buf, ROUND_UP_1024(bufsiz) + 1024);\n#endif\n\n  start:\n#ifdef ICONV_OPTION\n\ts = flags & RL_CONVERT ? iconv_buf.buf : buf;\n#else\n\ts = buf;\n#endif\n\teob = s + bufsiz - 1;\n\twhile (1) {\n\t\t/* We avoid read_byte() for files because files can return an EOF. */\n\t\tif (fd == iobuf.in_fd)\n\t\t\tch = read_byte(fd);\n\t\telse if (safe_read(fd, &ch, 1) == 0)\n\t\t\tbreak;\n\t\tif (flags & RL_EOL_NULLS ? ch == '\\0' : (ch == '\\r' || ch == '\\n')) {\n\t\t\t/* Skip empty lines if dumping comments. */\n\t\t\tif (flags & RL_DUMP_COMMENTS && s == buf)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (s < eob)\n\t\t\t*s++ = ch;\n\t}\n\t*s = '\\0';\n\n\tif (flags & RL_DUMP_COMMENTS && (*buf == '#' || *buf == ';'))\n\t\tgoto start;\n\n#ifdef ICONV_OPTION\n\tif (flags & RL_CONVERT) {\n\t\txbuf outbuf;\n\t\tINIT_XBUF(outbuf, buf, 0, bufsiz);\n\t\ticonv_buf.pos = 0;\n\t\ticonv_buf.len = s - iconv_buf.buf;\n\t\ticonvbufs(ic_recv, &iconv_buf, &outbuf,\n\t\t\t  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT);\n\t\toutbuf.buf[outbuf.len] = '\\0';\n\t\treturn outbuf.len;\n\t}\n#endif\n\n\treturn s - buf;\n}\n\nvoid read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,\n\t       char ***argv_p, int *argc_p, char **request_p)\n{\n\tint maxargs = MAX_ARGS;\n\tint dot_pos = 0, argc = 0, request_len = 0;\n\tchar **argv, *p;\n\tint rl_flags = (rl_nulls ? RL_EOL_NULLS : 0);\n\n#ifdef ICONV_OPTION\n\trl_flags |= (protect_args && ic_recv != (iconv_t)-1 ? RL_CONVERT : 0);\n#endif\n\n\targv = new_array(char *, maxargs);\n\tif (mod_name && !protect_args)\n\t\targv[argc++] = \"rsyncd\";\n\n\tif (request_p)\n\t\t*request_p = NULL;\n\n\twhile (1) {\n\t\tif (read_line(f_in, buf, bufsiz, rl_flags) == 0)\n\t\t\tbreak;\n\n\t\tif (argc == maxargs-1) {\n\t\t\tmaxargs += MAX_ARGS;\n\t\t\targv = realloc_array(argv, char *, maxargs);\n\t\t}\n\n\t\tif (dot_pos) {\n\t\t\tif (request_p && request_len < 1024) {\n\t\t\t\tint len = strlen(buf);\n\t\t\t\tif (request_len)\n\t\t\t\t\trequest_p[0][request_len++] = ' ';\n\t\t\t\t*request_p = realloc_array(*request_p, char, request_len + len + 1);\n\t\t\t\tmemcpy(*request_p + request_len, buf, len + 1);\n\t\t\t\trequest_len += len;\n\t\t\t}\n\t\t\tif (mod_name)\n\t\t\t\tglob_expand_module(mod_name, buf, &argv, &argc, &maxargs);\n\t\t\telse\n\t\t\t\tglob_expand(buf, &argv, &argc, &maxargs);\n\t\t} else {\n\t\t\tp = strdup(buf);\n\t\t\targv[argc++] = p;\n\t\t\tif (*p == '.' && p[1] == '\\0')\n\t\t\t\tdot_pos = argc;\n\t\t}\n\t}\n\targv[argc] = NULL;\n\n\tglob_expand(NULL, NULL, NULL, NULL);\n\n\t*argc_p = argc;\n\t*argv_p = argv;\n}\n\nBOOL io_start_buffering_out(int f_out)\n{\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2))\n\t\trprintf(FINFO, \"[%s] io_start_buffering_out(%d)\\n\", who_am_i(), f_out);\n\n\tif (iobuf.out.buf) {\n\t\tif (iobuf.out_fd == -1)\n\t\t\tiobuf.out_fd = f_out;\n\t\telse\n\t\t\tassert(f_out == iobuf.out_fd);\n\t\treturn False;\n\t}\n\n\talloc_xbuf(&iobuf.out, ROUND_UP_1024(IO_BUFFER_SIZE * 2));\n\tiobuf.out_fd = f_out;\n\n\treturn True;\n}\n\nBOOL io_start_buffering_in(int f_in)\n{\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2))\n\t\trprintf(FINFO, \"[%s] io_start_buffering_in(%d)\\n\", who_am_i(), f_in);\n\n\tif (iobuf.in.buf) {\n\t\tif (iobuf.in_fd == -1)\n\t\t\tiobuf.in_fd = f_in;\n\t\telse\n\t\t\tassert(f_in == iobuf.in_fd);\n\t\treturn False;\n\t}\n\n\talloc_xbuf(&iobuf.in, ROUND_UP_1024(IO_BUFFER_SIZE));\n\tiobuf.in_fd = f_in;\n\n\treturn True;\n}\n\nvoid io_end_buffering_in(BOOL free_buffers)\n{\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2)) {\n\t\trprintf(FINFO, \"[%s] io_end_buffering_in(IOBUF_%s_BUFS)\\n\",\n\t\t\twho_am_i(), free_buffers ? \"FREE\" : \"KEEP\");\n\t}\n\n\tif (free_buffers)\n\t\tfree_xbuf(&iobuf.in);\n\telse\n\t\tiobuf.in.pos = iobuf.in.len = 0;\n\n\tiobuf.in_fd = -1;\n}\n\nvoid io_end_buffering_out(BOOL free_buffers)\n{\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2)) {\n\t\trprintf(FINFO, \"[%s] io_end_buffering_out(IOBUF_%s_BUFS)\\n\",\n\t\t\twho_am_i(), free_buffers ? \"FREE\" : \"KEEP\");\n\t}\n\n\tio_flush(FULL_FLUSH);\n\n\tif (free_buffers) {\n\t\tfree_xbuf(&iobuf.out);\n\t\tfree_xbuf(&iobuf.msg);\n\t}\n\n\tiobuf.out_fd = -1;\n}\n\nvoid maybe_flush_socket(int important)\n{\n\tif (flist_eof && iobuf.out.buf && iobuf.out.len > iobuf.out_empty_len\n\t && (important || time(NULL) - last_io_out >= 5))\n\t\tio_flush(NORMAL_FLUSH);\n}\n\n/* Older rsync versions used to send either a MSG_NOOP (protocol 30) or a\n * raw-data-based keep-alive (protocol 29), both of which implied forwarding of\n * the message through the sender.  Since the new timeout method does not need\n * any forwarding, we just send an empty MSG_DATA message, which works with all\n * rsync versions.  This avoids any message forwarding, and leaves the raw-data\n * stream alone (since we can never be quite sure if that stream is in the\n * right state for a keep-alive message). */\nvoid maybe_send_keepalive(time_t now, int flags)\n{\n\tif (flags & MSK_ACTIVE_RECEIVER)\n\t\tlast_io_in = now; /* Fudge things when we're working hard on the files. */\n\n\t/* Early in the transfer (before the receiver forks) the receiving side doesn't\n\t * care if it hasn't sent data in a while as long as it is receiving data (in\n\t * fact, a pre-3.1.0 rsync would die if we tried to send it a keep alive during\n\t * this time).  So, if we're an early-receiving proc, just return and let the\n\t * incoming data determine if we timeout. */\n\tif (!am_sender && !am_receiver && !am_generator)\n\t\treturn;\n\n\tif (now - last_io_out >= allowed_lull) {\n\t\t/* The receiver is special:  it only sends keep-alive messages if it is\n\t\t * actively receiving data.  Otherwise, it lets the generator timeout. */\n\t\tif (am_receiver && now - last_io_in >= io_timeout)\n\t\t\treturn;\n\n\t\tif (!iobuf.msg.len && iobuf.out.len == iobuf.out_empty_len)\n\t\t\tsend_msg(MSG_DATA, \"\", 0, 0);\n\t\tif (!(flags & MSK_ALLOW_FLUSH)) {\n\t\t\t/* Let the caller worry about writing out the data. */\n\t\t} else if (iobuf.msg.len)\n\t\t\tperform_io(iobuf.msg.size - iobuf.msg.len + 1, PIO_NEED_MSGROOM);\n\t\telse if (iobuf.out.len > iobuf.out_empty_len)\n\t\t\tio_flush(NORMAL_FLUSH);\n\t}\n}\n\nvoid start_flist_forward(int ndx)\n{\n\twrite_int(iobuf.out_fd, ndx);\n\tforward_flist_data = 1;\n}\n\nvoid stop_flist_forward(void)\n{\n\tforward_flist_data = 0;\n}\n\n/* Read a message from a multiplexed source. */\nstatic void read_a_msg(void)\n{\n\tchar data[BIGPATHBUFLEN];\n\tint tag, val;\n\tsize_t msg_bytes;\n\n\t/* This ensures that perform_io() does not try to do any message reading\n\t * until we've read all of the data for this message.  We should also\n\t * try to avoid calling things that will cause data to be written via\n\t * perform_io() prior to this being reset to 1. */\n\tiobuf.in_multiplexed = -1;\n\n\ttag = raw_read_int();\n\n\tmsg_bytes = tag & 0xFFFFFF;\n\ttag = (tag >> 24) - MPLEX_BASE;\n\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 1)) {\n\t\trprintf(FINFO, \"[%s] got msg=%d, len=%\" SIZE_T_FMT_MOD \"d\\n\",\n\t\t\twho_am_i(), (int)tag, (SIZE_T_FMT_CAST)msg_bytes);\n\t}\n\n\tswitch (tag) {\n\tcase MSG_DATA:\n\t\tassert(iobuf.raw_input_ends_before == 0);\n\t\t/* Though this does not yet read the data, we do mark where in\n\t\t * the buffer the msg data will end once it is read.  It is\n\t\t * possible that this points off the end of the buffer, in\n\t\t * which case the gradual reading of the input stream will\n\t\t * cause this value to wrap around and eventually become real. */\n\t\tif (msg_bytes)\n\t\t\tiobuf.raw_input_ends_before = iobuf.in.pos + msg_bytes;\n\t\tiobuf.in_multiplexed = 1;\n\t\tbreak;\n\tcase MSG_STATS:\n\t\tif (msg_bytes != sizeof stats.total_read || !am_generator)\n\t\t\tgoto invalid_msg;\n\t\traw_read_buf((char*)&stats.total_read, sizeof stats.total_read);\n\t\tiobuf.in_multiplexed = 1;\n\t\tbreak;\n\tcase MSG_REDO:\n\t\tif (msg_bytes != 4 || !am_generator)\n\t\t\tgoto invalid_msg;\n\t\tval = raw_read_int();\n\t\tiobuf.in_multiplexed = 1;\n\t\tgot_flist_entry_status(FES_REDO, val);\n\t\tbreak;\n\tcase MSG_IO_ERROR:\n\t\tif (msg_bytes != 4)\n\t\t\tgoto invalid_msg;\n\t\tval = raw_read_int();\n\t\tiobuf.in_multiplexed = 1;\n\t\tio_error |= val;\n\t\tif (am_receiver)\n\t\t\tsend_msg_int(MSG_IO_ERROR, val);\n\t\tbreak;\n\tcase MSG_IO_TIMEOUT:\n\t\tif (msg_bytes != 4 || am_server || am_generator)\n\t\t\tgoto invalid_msg;\n\t\tval = raw_read_int();\n\t\tiobuf.in_multiplexed = 1;\n\t\tif (!io_timeout || io_timeout > val) {\n\t\t\tif (INFO_GTE(MISC, 2))\n\t\t\t\trprintf(FINFO, \"Setting --timeout=%d to match server\\n\", val);\n\t\t\tset_io_timeout(val);\n\t\t}\n\t\tbreak;\n\tcase MSG_NOOP:\n\t\t/* Support protocol-30 keep-alive method. */\n\t\tif (msg_bytes != 0)\n\t\t\tgoto invalid_msg;\n\t\tiobuf.in_multiplexed = 1;\n\t\tif (am_sender)\n\t\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);\n\t\tbreak;\n\tcase MSG_DELETED:\n\t\tif (msg_bytes >= sizeof data)\n\t\t\tgoto overflow;\n\t\tif (am_generator) {\n\t\t\traw_read_buf(data, msg_bytes);\n\t\t\tiobuf.in_multiplexed = 1;\n\t\t\tsend_msg(MSG_DELETED, data, msg_bytes, 1);\n\t\t\tbreak;\n\t\t}\n#ifdef ICONV_OPTION\n\t\tif (ic_recv != (iconv_t)-1) {\n\t\t\txbuf outbuf, inbuf;\n\t\t\tchar ibuf[512];\n\t\t\tint add_null = 0;\n\t\t\tint flags = ICB_INCLUDE_BAD | ICB_INIT;\n\n\t\t\tINIT_CONST_XBUF(outbuf, data);\n\t\t\tINIT_XBUF(inbuf, ibuf, 0, (size_t)-1);\n\n\t\t\twhile (msg_bytes) {\n\t\t\t\tsize_t len = msg_bytes > sizeof ibuf - inbuf.len ? sizeof ibuf - inbuf.len : msg_bytes;\n\t\t\t\traw_read_buf(ibuf + inbuf.len, len);\n\t\t\t\tinbuf.pos = 0;\n\t\t\t\tinbuf.len += len;\n\t\t\t\tif (!(msg_bytes -= len) && !ibuf[inbuf.len-1])\n\t\t\t\t\tinbuf.len--, add_null = 1;\n\t\t\t\tif (iconvbufs(ic_send, &inbuf, &outbuf, flags) < 0) {\n\t\t\t\t\tif (errno == E2BIG)\n\t\t\t\t\t\tgoto overflow;\n\t\t\t\t\t/* Buffer ended with an incomplete char, so move the\n\t\t\t\t\t * bytes to the start of the buffer and continue. */\n\t\t\t\t\tmemmove(ibuf, ibuf + inbuf.pos, inbuf.len);\n\t\t\t\t}\n\t\t\t\tflags &= ~ICB_INIT;\n\t\t\t}\n\t\t\tif (add_null) {\n\t\t\t\tif (outbuf.len == outbuf.size)\n\t\t\t\t\tgoto overflow;\n\t\t\t\toutbuf.buf[outbuf.len++] = '\\0';\n\t\t\t}\n\t\t\tmsg_bytes = outbuf.len;\n\t\t} else\n#endif\n\t\t\traw_read_buf(data, msg_bytes);\n\t\tiobuf.in_multiplexed = 1;\n\t\t/* A directory name was sent with the trailing null */\n\t\tif (msg_bytes > 0 && !data[msg_bytes-1])\n\t\t\tlog_delete(data, S_IFDIR);\n\t\telse {\n\t\t\tdata[msg_bytes] = '\\0';\n\t\t\tlog_delete(data, S_IFREG);\n\t\t}\n\t\tbreak;\n\tcase MSG_SUCCESS:\n\t\tif (msg_bytes != (local_server ? 4+8+8 : 4)) {\n\t\t  invalid_msg:\n\t\t\trprintf(FERROR, \"invalid multi-message %d:%lu [%s%s]\\n\",\n\t\t\t\ttag, (unsigned long)msg_bytes, who_am_i(),\n\t\t\t\tinc_recurse ? \"/inc\" : \"\");\n\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t}\n\t\traw_read_buf(num_dev_ino_buf, msg_bytes);\n\t\tval = IVAL(num_dev_ino_buf, 0);\n\t\tiobuf.in_multiplexed = 1;\n\t\tif (am_generator)\n\t\t\tgot_flist_entry_status(FES_SUCCESS, val);\n\t\telse\n\t\t\tsuccessful_send(val);\n\t\tbreak;\n\tcase MSG_NO_SEND:\n\t\tif (msg_bytes != 4)\n\t\t\tgoto invalid_msg;\n\t\tval = raw_read_int();\n\t\tiobuf.in_multiplexed = 1;\n\t\tif (am_generator)\n\t\t\tgot_flist_entry_status(FES_NO_SEND, val);\n\t\telse\n\t\t\tsend_msg_int(MSG_NO_SEND, val);\n\t\tbreak;\n\tcase MSG_ERROR_SOCKET:\n\tcase MSG_ERROR_UTF8:\n\tcase MSG_CLIENT:\n\tcase MSG_LOG:\n\t\tif (!am_generator)\n\t\t\tgoto invalid_msg;\n\t\tif (tag == MSG_ERROR_SOCKET)\n\t\t\tmsgs2stderr = 1;\n\t\t/* FALL THROUGH */\n\tcase MSG_INFO:\n\tcase MSG_ERROR:\n\tcase MSG_ERROR_XFER:\n\tcase MSG_WARNING:\n\t\tif (msg_bytes >= sizeof data) {\n\t\t    overflow:\n\t\t\trprintf(FERROR,\n\t\t\t\t\"multiplexing overflow %d:%lu [%s%s]\\n\",\n\t\t\t\ttag, (unsigned long)msg_bytes, who_am_i(),\n\t\t\t\tinc_recurse ? \"/inc\" : \"\");\n\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t}\n\t\traw_read_buf(data, msg_bytes);\n\t\t/* We don't set in_multiplexed value back to 1 before writing this message\n\t\t * because the write might loop back and read yet another message, over and\n\t\t * over again, while waiting for room to put the message in the msg buffer. */\n\t\trwrite((enum logcode)tag, data, msg_bytes, !am_generator);\n\t\tiobuf.in_multiplexed = 1;\n\t\tif (first_message) {\n\t\t\tif (list_only && !am_sender && tag == 1 && msg_bytes < sizeof data) {\n\t\t\t\tdata[msg_bytes] = '\\0';\n\t\t\t\tcheck_for_d_option_error(data);\n\t\t\t}\n\t\t\tfirst_message = 0;\n\t\t}\n\t\tbreak;\n\tcase MSG_ERROR_EXIT:\n\t\tif (msg_bytes == 4)\n\t\t\tval = raw_read_int();\n\t\telse if (msg_bytes == 0)\n\t\t\tval = 0;\n\t\telse\n\t\t\tgoto invalid_msg;\n\t\tiobuf.in_multiplexed = 1;\n\t\tif (DEBUG_GTE(EXIT, 3)) {\n\t\t\trprintf(FINFO, \"[%s] got MSG_ERROR_EXIT with %\" SIZE_T_FMT_MOD \"d bytes\\n\",\n\t\t\t\t\twho_am_i(), (SIZE_T_FMT_CAST)msg_bytes);\n\t\t}\n\t\tif (msg_bytes == 0) {\n\t\t\tif (!am_sender && !am_generator) {\n\t\t\t\tif (DEBUG_GTE(EXIT, 3)) {\n\t\t\t\t\trprintf(FINFO, \"[%s] sending MSG_ERROR_EXIT (len 0)\\n\",\n\t\t\t\t\t\twho_am_i());\n\t\t\t\t}\n\t\t\t\tsend_msg(MSG_ERROR_EXIT, \"\", 0, 0);\n\t\t\t\tio_flush(FULL_FLUSH);\n\t\t\t}\n\t\t} else if (protocol_version >= 31) {\n\t\t\tif (am_generator || am_receiver) {\n\t\t\t\tif (DEBUG_GTE(EXIT, 3)) {\n\t\t\t\t\trprintf(FINFO, \"[%s] sending MSG_ERROR_EXIT with exit_code %d\\n\",\n\t\t\t\t\t\twho_am_i(), val);\n\t\t\t\t}\n\t\t\t\tsend_msg_int(MSG_ERROR_EXIT, val);\n\t\t\t} else {\n\t\t\t\tif (DEBUG_GTE(EXIT, 3)) {\n\t\t\t\t\trprintf(FINFO, \"[%s] sending MSG_ERROR_EXIT (len 0)\\n\",\n\t\t\t\t\t\twho_am_i());\n\t\t\t\t}\n\t\t\t\tsend_msg(MSG_ERROR_EXIT, \"\", 0, 0);\n\t\t\t}\n\t\t}\n\t\t/* Send a negative linenum so that we don't end up\n\t\t * with a duplicate exit message. */\n\t\t_exit_cleanup(val, __FILE__, 0 - __LINE__);\n\tdefault:\n\t\trprintf(FERROR, \"unexpected tag %d [%s%s]\\n\",\n\t\t\ttag, who_am_i(), inc_recurse ? \"/inc\" : \"\");\n\t\texit_cleanup(RERR_STREAMIO);\n\t}\n\n\tassert(iobuf.in_multiplexed > 0);\n}\n\nstatic void drain_multiplex_messages(void)\n{\n\twhile (IN_MULTIPLEXED_AND_READY && iobuf.in.len) {\n\t\tif (iobuf.raw_input_ends_before) {\n\t\t\tsize_t raw_len = iobuf.raw_input_ends_before - iobuf.in.pos;\n\t\t\tiobuf.raw_input_ends_before = 0;\n\t\t\tif (raw_len >= iobuf.in.len) {\n\t\t\t\tiobuf.in.len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiobuf.in.len -= raw_len;\n\t\t\tif ((iobuf.in.pos += raw_len) >= iobuf.in.size)\n\t\t\t\tiobuf.in.pos -= iobuf.in.size;\n\t\t}\n\t\tread_a_msg();\n\t}\n}\n\nvoid wait_for_receiver(void)\n{\n\tif (!iobuf.raw_input_ends_before)\n\t\tread_a_msg();\n\n\tif (iobuf.raw_input_ends_before) {\n\t\tint ndx = read_int(iobuf.in_fd);\n\t\tif (ndx < 0) {\n\t\t\tswitch (ndx) {\n\t\t\tcase NDX_FLIST_EOF:\n\t\t\t\tflist_eof = 1;\n\t\t\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t\t\t\tbreak;\n\t\t\tcase NDX_DONE:\n\t\t\t\tmsgdone_cnt++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct file_list *flist;\n\t\t\tflist_receiving_enabled = False;\n\t\t\tif (DEBUG_GTE(FLIST, 2)) {\n\t\t\t\trprintf(FINFO, \"[%s] receiving flist for dir %d\\n\",\n\t\t\t\t\twho_am_i(), ndx);\n\t\t\t}\n\t\t\tflist = recv_file_list(iobuf.in_fd, ndx);\n\t\t\tflist->parent_ndx = ndx;\n#ifdef SUPPORT_HARD_LINKS\n\t\t\tif (preserve_hard_links)\n\t\t\t\tmatch_hard_links(flist);\n#endif\n\t\t\tflist_receiving_enabled = True;\n\t\t}\n\t}\n}\n\nunsigned short read_shortint(int f)\n{\n\tchar b[2];\n\tread_buf(f, b, 2);\n\treturn (UVAL(b, 1) << 8) + UVAL(b, 0);\n}\n\nint32 read_int(int f)\n{\n\tchar b[4];\n\tint32 num;\n\n\tread_buf(f, b, 4);\n\tnum = IVAL(b, 0);\n#if SIZEOF_INT32 > 4\n\tif (num & (int32)0x80000000)\n\t\tnum |= ~(int32)0xffffffff;\n#endif\n\treturn num;\n}\n\nuint32 read_uint(int f)\n{\n\tchar b[4];\n\tread_buf(f, b, 4);\n\treturn IVAL(b, 0);\n}\n\nint32 read_varint(int f)\n{\n\tunion {\n\t\tchar b[5];\n\t\tint32 x;\n\t} u;\n\tuchar ch;\n\tint extra;\n\n\tu.x = 0;\n\tch = read_byte(f);\n\textra = int_byte_extra[ch / 4];\n\tif (extra) {\n\t\tuchar bit = ((uchar)1<<(8-extra));\n\t\tif (extra >= (int)sizeof u.b) {\n\t\t\trprintf(FERROR, \"Overflow in read_varint()\\n\");\n\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t}\n\t\tread_buf(f, u.b, extra);\n\t\tu.b[extra] = ch & (bit-1);\n\t} else\n\t\tu.b[0] = ch;\n#if CAREFUL_ALIGNMENT\n\tu.x = IVAL(u.b,0);\n#endif\n#if SIZEOF_INT32 > 4\n\tif (u.x & (int32)0x80000000)\n\t\tu.x |= ~(int32)0xffffffff;\n#endif\n\treturn u.x;\n}\n\nint64 read_varlong(int f, uchar min_bytes)\n{\n\tunion {\n\t\tchar b[9];\n\t\tint64 x;\n\t} u;\n\tchar b2[8];\n\tint extra;\n\n#if SIZEOF_INT64 < 8\n\tmemset(u.b, 0, 8);\n#else\n\tu.x = 0;\n#endif\n\tread_buf(f, b2, min_bytes);\n\tmemcpy(u.b, b2+1, min_bytes-1);\n\textra = int_byte_extra[CVAL(b2, 0) / 4];\n\tif (extra) {\n\t\tuchar bit = ((uchar)1<<(8-extra));\n\t\tif (min_bytes + extra > (int)sizeof u.b) {\n\t\t\trprintf(FERROR, \"Overflow in read_varlong()\\n\");\n\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t}\n\t\tread_buf(f, u.b + min_bytes - 1, extra);\n\t\tu.b[min_bytes + extra - 1] = CVAL(b2, 0) & (bit-1);\n#if SIZEOF_INT64 < 8\n\t\tif (min_bytes + extra > 5 || u.b[4] || CVAL(u.b,3) & 0x80) {\n\t\t\trprintf(FERROR, \"Integer overflow: attempted 64-bit offset\\n\");\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n#endif\n\t} else\n\t\tu.b[min_bytes + extra - 1] = CVAL(b2, 0);\n#if SIZEOF_INT64 < 8\n\tu.x = IVAL(u.b,0);\n#elif CAREFUL_ALIGNMENT\n\tu.x = IVAL64(u.b,0);\n#endif\n\treturn u.x;\n}\n\nint64 read_longint(int f)\n{\n#if SIZEOF_INT64 >= 8\n\tchar b[9];\n#endif\n\tint32 num = read_int(f);\n\n\tif (num != (int32)0xffffffff)\n\t\treturn num;\n\n#if SIZEOF_INT64 < 8\n\trprintf(FERROR, \"Integer overflow: attempted 64-bit offset\\n\");\n\texit_cleanup(RERR_UNSUPPORTED);\n#else\n\tread_buf(f, b, 8);\n\treturn IVAL(b,0) | (((int64)IVAL(b,4))<<32);\n#endif\n}\n\n/* Debugging note: this will be named read_buf_() when using an external zlib. */\nvoid read_buf(int f, char *buf, size_t len)\n{\n\tif (f != iobuf.in_fd) {\n\t\tif (safe_read(f, buf, len) != len)\n\t\t\twhine_about_eof(False); /* Doesn't return. */\n\t\tgoto batch_copy;\n\t}\n\n\tif (!IN_MULTIPLEXED) {\n\t\traw_read_buf(buf, len);\n\t\ttotal_data_read += len;\n\t\tif (forward_flist_data)\n\t\t\twrite_buf(iobuf.out_fd, buf, len);\n\t  batch_copy:\n\t\tif (f == write_batch_monitor_in)\n\t\t\tsafe_write(batch_fd, buf, len);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tsize_t siz;\n\n\t\twhile (!iobuf.raw_input_ends_before)\n\t\t\tread_a_msg();\n\n\t\tsiz = MIN(len, iobuf.raw_input_ends_before - iobuf.in.pos);\n\t\tif (siz >= iobuf.in.size)\n\t\t\tsiz = iobuf.in.size;\n\t\traw_read_buf(buf, siz);\n\t\ttotal_data_read += siz;\n\n\t\tif (forward_flist_data)\n\t\t\twrite_buf(iobuf.out_fd, buf, siz);\n\n\t\tif (f == write_batch_monitor_in)\n\t\t\tsafe_write(batch_fd, buf, siz);\n\n\t\tif ((len -= siz) == 0)\n\t\t\tbreak;\n\t\tbuf += siz;\n\t}\n}\n\nvoid read_sbuf(int f, char *buf, size_t len)\n{\n\tread_buf(f, buf, len);\n\tbuf[len] = '\\0';\n}\n\nuchar read_byte(int f)\n{\n\tuchar c;\n\tread_buf(f, (char*)&c, 1);\n\treturn c;\n}\n\nint read_vstring(int f, char *buf, int bufsize)\n{\n\tint len = read_byte(f);\n\n\tif (len & 0x80)\n\t\tlen = (len & ~0x80) * 0x100 + read_byte(f);\n\n\tif (len >= bufsize) {\n\t\trprintf(FERROR, \"over-long vstring received (%d > %d)\\n\",\n\t\t\tlen, bufsize - 1);\n\t\treturn -1;\n\t}\n\n\tif (len)\n\t\tread_buf(f, buf, len);\n\tbuf[len] = '\\0';\n\treturn len;\n}\n\n/* Populate a sum_struct with values from the socket.  This is\n * called by both the sender and the receiver. */\nvoid read_sum_head(int f, struct sum_struct *sum)\n{\n\tint32 max_blength = protocol_version < 30 ? OLD_MAX_BLOCK_SIZE : MAX_BLOCK_SIZE;\n\tsum->count = read_int(f);\n\tif (sum->count < 0) {\n\t\trprintf(FERROR, \"Invalid checksum count %ld [%s]\\n\",\n\t\t\t(long)sum->count, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tsum->blength = read_int(f);\n\tif (sum->blength < 0 || sum->blength > max_blength) {\n\t\trprintf(FERROR, \"Invalid block length %ld [%s]\\n\",\n\t\t\t(long)sum->blength, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tsum->s2length = protocol_version < 27 ? csum_length : (int)read_int(f);\n\tif (sum->s2length < 0 || sum->s2length > xfer_sum_len) {\n\t\trprintf(FERROR, \"Invalid checksum length %d [%s]\\n\",\n\t\t\tsum->s2length, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tsum->remainder = read_int(f);\n\tif (sum->remainder < 0 || sum->remainder > sum->blength) {\n\t\trprintf(FERROR, \"Invalid remainder length %ld [%s]\\n\",\n\t\t\t(long)sum->remainder, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n}\n\n/* Send the values from a sum_struct over the socket.  Set sum to\n * NULL if there are no checksums to send.  This is called by both\n * the generator and the sender. */\nvoid write_sum_head(int f, struct sum_struct *sum)\n{\n\tstatic struct sum_struct null_sum;\n\n\tif (sum == NULL)\n\t\tsum = &null_sum;\n\n\twrite_int(f, sum->count);\n\twrite_int(f, sum->blength);\n\tif (protocol_version >= 27)\n\t\twrite_int(f, sum->s2length);\n\twrite_int(f, sum->remainder);\n}\n\n/* Sleep after writing to limit I/O bandwidth usage.\n *\n * @todo Rather than sleeping after each write, it might be better to\n * use some kind of averaging.  The current algorithm seems to always\n * use a bit less bandwidth than specified, because it doesn't make up\n * for slow periods.  But arguably this is a feature.  In addition, we\n * ought to take the time used to write the data into account.\n *\n * During some phases of big transfers (file FOO is uptodate) this is\n * called with a small bytes_written every time.  As the kernel has to\n * round small waits up to guarantee that we actually wait at least the\n * requested number of microseconds, this can become grossly inaccurate.\n * We therefore keep track of the bytes we've written over time and only\n * sleep when the accumulated delay is at least 1 tenth of a second. */\nstatic void sleep_for_bwlimit(int bytes_written)\n{\n\tstatic struct timeval prior_tv;\n\tstatic long total_written = 0;\n\tstruct timeval tv, start_tv;\n\tlong elapsed_usec, sleep_usec;\n\n#define ONE_SEC\t1000000L /* # of microseconds in a second */\n\n\ttotal_written += bytes_written;\n\n\tgettimeofday(&start_tv, NULL);\n\tif (prior_tv.tv_sec) {\n\t\telapsed_usec = (start_tv.tv_sec - prior_tv.tv_sec) * ONE_SEC\n\t\t\t     + (start_tv.tv_usec - prior_tv.tv_usec);\n\t\ttotal_written -= (int64)elapsed_usec * bwlimit / (ONE_SEC/1024);\n\t\tif (total_written < 0)\n\t\t\ttotal_written = 0;\n\t}\n\n\tsleep_usec = total_written * (ONE_SEC/1024) / bwlimit;\n\tif (sleep_usec < ONE_SEC / 10) {\n\t\tprior_tv = start_tv;\n\t\treturn;\n\t}\n\n\ttv.tv_sec  = sleep_usec / ONE_SEC;\n\ttv.tv_usec = sleep_usec % ONE_SEC;\n\tselect(0, NULL, NULL, NULL, &tv);\n\n\tgettimeofday(&prior_tv, NULL);\n\telapsed_usec = (prior_tv.tv_sec - start_tv.tv_sec) * ONE_SEC\n\t\t     + (prior_tv.tv_usec - start_tv.tv_usec);\n\ttotal_written = (sleep_usec - elapsed_usec) * bwlimit / (ONE_SEC/1024);\n}\n\nvoid io_flush(int flush_type)\n{\n\tif (iobuf.out.len > iobuf.out_empty_len) {\n\t\tif (flush_type == FULL_FLUSH)\t\t/* flush everything in the output buffers */\n\t\t\tperform_io(iobuf.out.size - iobuf.out_empty_len, PIO_NEED_OUTROOM);\n\t\telse if (flush_type == NORMAL_FLUSH)\t/* flush at least 1 byte */\n\t\t\tperform_io(iobuf.out.size - iobuf.out.len + 1, PIO_NEED_OUTROOM);\n\t\t\t\t\t\t\t/* MSG_FLUSH: flush iobuf.msg only */\n\t}\n\tif (iobuf.msg.len)\n\t\tperform_io(iobuf.msg.size, PIO_NEED_MSGROOM);\n}\n\nvoid write_shortint(int f, unsigned short x)\n{\n\tchar b[2];\n\tb[0] = (char)x;\n\tb[1] = (char)(x >> 8);\n\twrite_buf(f, b, 2);\n}\n\nvoid write_int(int f, int32 x)\n{\n\tchar b[4];\n\tSIVAL(b, 0, x);\n\twrite_buf(f, b, 4);\n}\n\nvoid write_varint(int f, int32 x)\n{\n\tchar b[5];\n\tuchar bit;\n\tint cnt;\n\n\tSIVAL(b, 1, x);\n\n\tfor (cnt = 4; cnt > 1 && b[cnt] == 0; cnt--) {}\n\tbit = ((uchar)1<<(7-cnt+1));\n\n\tif (CVAL(b, cnt) >= bit) {\n\t\tcnt++;\n\t\t*b = ~(bit-1);\n\t} else if (cnt > 1)\n\t\t*b = b[cnt] | ~(bit*2-1);\n\telse\n\t\t*b = b[1];\n\n\twrite_buf(f, b, cnt);\n}\n\nvoid write_varlong(int f, int64 x, uchar min_bytes)\n{\n\tchar b[9];\n\tuchar bit;\n\tint cnt = 8;\n\n#if SIZEOF_INT64 >= 8\n\tSIVAL64(b, 1, x);\n#else\n\tSIVAL(b, 1, x);\n\tif (x <= 0x7FFFFFFF && x >= 0)\n\t\tmemset(b + 5, 0, 4);\n\telse {\n\t\trprintf(FERROR, \"Integer overflow: attempted 64-bit offset\\n\");\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n#endif\n\n\twhile (cnt > min_bytes && b[cnt] == 0)\n\t\tcnt--;\n\tbit = ((uchar)1<<(7-cnt+min_bytes));\n\tif (CVAL(b, cnt) >= bit) {\n\t\tcnt++;\n\t\t*b = ~(bit-1);\n\t} else if (cnt > min_bytes)\n\t\t*b = b[cnt] | ~(bit*2-1);\n\telse\n\t\t*b = b[cnt];\n\n\twrite_buf(f, b, cnt);\n}\n\n/*\n * Note: int64 may actually be a 32-bit type if ./configure couldn't find any\n * 64-bit types on this platform.\n */\nvoid write_longint(int f, int64 x)\n{\n\tchar b[12], * const s = b+4;\n\n\tSIVAL(s, 0, x);\n\tif (x <= 0x7FFFFFFF && x >= 0) {\n\t\twrite_buf(f, s, 4);\n\t\treturn;\n\t}\n\n#if SIZEOF_INT64 < 8\n\trprintf(FERROR, \"Integer overflow: attempted 64-bit offset\\n\");\n\texit_cleanup(RERR_UNSUPPORTED);\n#else\n\tmemset(b, 0xFF, 4);\n\tSIVAL(s, 4, x >> 32);\n\twrite_buf(f, b, 12);\n#endif\n}\n\nvoid write_bigbuf(int f, const char *buf, size_t len)\n{\n\tsize_t half_max = (iobuf.out.size - iobuf.out_empty_len) / 2;\n\n\twhile (len > half_max + 1024) {\n\t\twrite_buf(f, buf, half_max);\n\t\tbuf += half_max;\n\t\tlen -= half_max;\n\t}\n\n\twrite_buf(f, buf, len);\n}\n\nvoid write_buf(int f, const char *buf, size_t len)\n{\n\tsize_t pos, siz;\n\n\tif (f != iobuf.out_fd) {\n\t\tsafe_write(f, buf, len);\n\t\tgoto batch_copy;\n\t}\n\n\tif (iobuf.out.len + len > iobuf.out.size)\n\t\tperform_io(len, PIO_NEED_OUTROOM);\n\n\tpos = iobuf.out.pos + iobuf.out.len; /* Must be set after any flushing. */\n\tif (pos >= iobuf.out.size)\n\t\tpos -= iobuf.out.size;\n\n\t/* Handle a split copy if we wrap around the end of the circular buffer. */\n\tif (pos >= iobuf.out.pos && (siz = iobuf.out.size - pos) < len) {\n\t\tmemcpy(iobuf.out.buf + pos, buf, siz);\n\t\tmemcpy(iobuf.out.buf, buf + siz, len - siz);\n\t} else\n\t\tmemcpy(iobuf.out.buf + pos, buf, len);\n\n\tiobuf.out.len += len;\n\ttotal_data_written += len;\n\n  batch_copy:\n\tif (f == write_batch_monitor_out)\n\t\tsafe_write(batch_fd, buf, len);\n}\n\n/* Write a string to the connection */\nvoid write_sbuf(int f, const char *buf)\n{\n\twrite_buf(f, buf, strlen(buf));\n}\n\nvoid write_byte(int f, uchar c)\n{\n\twrite_buf(f, (char *)&c, 1);\n}\n\nvoid write_vstring(int f, const char *str, int len)\n{\n\tuchar lenbuf[3], *lb = lenbuf;\n\n\tif (len > 0x7F) {\n\t\tif (len > 0x7FFF) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"attempting to send over-long vstring (%d > %d)\\n\",\n\t\t\t\tlen, 0x7FFF);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\t*lb++ = len / 0x100 + 0x80;\n\t}\n\t*lb = len;\n\n\twrite_buf(f, (char*)lenbuf, lb - lenbuf + 1);\n\tif (len)\n\t\twrite_buf(f, str, len);\n}\n\n/* Send a file-list index using a byte-reduction method. */\nvoid write_ndx(int f, int32 ndx)\n{\n\tstatic int32 prev_positive = -1, prev_negative = 1;\n\tint32 diff, cnt = 0;\n\tchar b[6];\n\n\tif (protocol_version < 30 || read_batch) {\n\t\twrite_int(f, ndx);\n\t\treturn;\n\t}\n\n\t/* Send NDX_DONE as a single-byte 0 with no side effects.  Send\n\t * negative nums as a positive after sending a leading 0xFF. */\n\tif (ndx >= 0) {\n\t\tdiff = ndx - prev_positive;\n\t\tprev_positive = ndx;\n\t} else if (ndx == NDX_DONE) {\n\t\t*b = 0;\n\t\twrite_buf(f, b, 1);\n\t\treturn;\n\t} else {\n\t\tb[cnt++] = (char)0xFF;\n\t\tndx = -ndx;\n\t\tdiff = ndx - prev_negative;\n\t\tprev_negative = ndx;\n\t}\n\n\t/* A diff of 1 - 253 is sent as a one-byte diff; a diff of 254 - 32767\n\t * or 0 is sent as a 0xFE + a two-byte diff; otherwise we send 0xFE\n\t * & all 4 bytes of the (non-negative) num with the high-bit set. */\n\tif (diff < 0xFE && diff > 0)\n\t\tb[cnt++] = (char)diff;\n\telse if (diff < 0 || diff > 0x7FFF) {\n\t\tb[cnt++] = (char)0xFE;\n\t\tb[cnt++] = (char)((ndx >> 24) | 0x80);\n\t\tb[cnt++] = (char)ndx;\n\t\tb[cnt++] = (char)(ndx >> 8);\n\t\tb[cnt++] = (char)(ndx >> 16);\n\t} else {\n\t\tb[cnt++] = (char)0xFE;\n\t\tb[cnt++] = (char)(diff >> 8);\n\t\tb[cnt++] = (char)diff;\n\t}\n\twrite_buf(f, b, cnt);\n}\n\n/* Receive a file-list index using a byte-reduction method. */\nint32 read_ndx(int f)\n{\n\tstatic int32 prev_positive = -1, prev_negative = 1;\n\tint32 *prev_ptr, num;\n\tchar b[4];\n\n\tif (protocol_version < 30)\n\t\treturn read_int(f);\n\n\tread_buf(f, b, 1);\n\tif (CVAL(b, 0) == 0xFF) {\n\t\tread_buf(f, b, 1);\n\t\tprev_ptr = &prev_negative;\n\t} else if (CVAL(b, 0) == 0)\n\t\treturn NDX_DONE;\n\telse\n\t\tprev_ptr = &prev_positive;\n\tif (CVAL(b, 0) == 0xFE) {\n\t\tread_buf(f, b, 2);\n\t\tif (CVAL(b, 0) & 0x80) {\n\t\t\tb[3] = CVAL(b, 0) & ~0x80;\n\t\t\tb[0] = b[1];\n\t\t\tread_buf(f, b+1, 2);\n\t\t\tnum = IVAL(b, 0);\n\t\t} else\n\t\t\tnum = (UVAL(b,0)<<8) + UVAL(b,1) + *prev_ptr;\n\t} else\n\t\tnum = UVAL(b, 0) + *prev_ptr;\n\t*prev_ptr = num;\n\tif (prev_ptr == &prev_negative)\n\t\tnum = -num;\n\treturn num;\n}\n\n/* Read a line of up to bufsiz-1 characters into buf.  Strips\n * the (required) trailing newline and all carriage returns.\n * Returns 1 for success; 0 for I/O error or truncation. */\nint read_line_old(int fd, char *buf, size_t bufsiz, int eof_ok)\n{\n\tassert(fd != iobuf.in_fd);\n\tbufsiz--; /* leave room for the null */\n\twhile (bufsiz > 0) {\n\t\tif (safe_read(fd, buf, 1) == 0) {\n\t\t\tif (eof_ok)\n\t\t\t\tbreak;\n\t\t\treturn 0;\n\t\t}\n\t\tif (*buf == '\\0')\n\t\t\treturn 0;\n\t\tif (*buf == '\\n')\n\t\t\tbreak;\n\t\tif (*buf != '\\r') {\n\t\t\tbuf++;\n\t\t\tbufsiz--;\n\t\t}\n\t}\n\t*buf = '\\0';\n\treturn bufsiz > 0;\n}\n\nvoid io_printf(int fd, const char *format, ...)\n{\n\tva_list ap;\n\tchar buf[BIGPATHBUFLEN];\n\tint len;\n\n\tva_start(ap, format);\n\tlen = vsnprintf(buf, sizeof buf, format, ap);\n\tva_end(ap);\n\n\tif (len < 0)\n\t\texit_cleanup(RERR_PROTOCOL);\n\n\tif (len >= (int)sizeof buf) {\n\t\trprintf(FERROR, \"io_printf() was too long for the buffer.\\n\");\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\n\twrite_sbuf(fd, buf);\n}\n\n/* Setup for multiplexing a MSG_* stream with the data stream. */\nvoid io_start_multiplex_out(int fd)\n{\n\tio_flush(FULL_FLUSH);\n\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2))\n\t\trprintf(FINFO, \"[%s] io_start_multiplex_out(%d)\\n\", who_am_i(), fd);\n\n\tif (!iobuf.msg.buf)\n\t\talloc_xbuf(&iobuf.msg, ROUND_UP_1024(IO_BUFFER_SIZE));\n\n\tiobuf.out_empty_len = 4; /* See also OUT_MULTIPLEXED */\n\tio_start_buffering_out(fd);\n\tgot_kill_signal = 0;\n\n\tiobuf.raw_data_header_pos = iobuf.out.pos + iobuf.out.len;\n\tiobuf.out.len += 4;\n}\n\n/* Setup for multiplexing a MSG_* stream with the data stream. */\nvoid io_start_multiplex_in(int fd)\n{\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2))\n\t\trprintf(FINFO, \"[%s] io_start_multiplex_in(%d)\\n\", who_am_i(), fd);\n\n\tiobuf.in_multiplexed = 1; /* See also IN_MULTIPLEXED */\n\tio_start_buffering_in(fd);\n}\n\nint io_end_multiplex_in(int mode)\n{\n\tint ret = iobuf.in_multiplexed ? iobuf.in_fd : -1;\n\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2))\n\t\trprintf(FINFO, \"[%s] io_end_multiplex_in(mode=%d)\\n\", who_am_i(), mode);\n\n\tiobuf.in_multiplexed = 0;\n\tif (mode == MPLX_SWITCHING)\n\t\tiobuf.raw_input_ends_before = 0;\n\telse\n\t\tassert(iobuf.raw_input_ends_before == 0);\n\tif (mode != MPLX_TO_BUFFERED)\n\t\tio_end_buffering_in(mode);\n\n\treturn ret;\n}\n\nint io_end_multiplex_out(int mode)\n{\n\tint ret = iobuf.out_empty_len ? iobuf.out_fd : -1;\n\n\tif (msgs2stderr == 1 && DEBUG_GTE(IO, 2))\n\t\trprintf(FINFO, \"[%s] io_end_multiplex_out(mode=%d)\\n\", who_am_i(), mode);\n\n\tif (mode != MPLX_TO_BUFFERED)\n\t\tio_end_buffering_out(mode);\n\telse\n\t\tio_flush(FULL_FLUSH);\n\n\tiobuf.out.len = 0;\n\tiobuf.out_empty_len = 0;\n\tif (got_kill_signal > 0) /* Just in case... */\n\t\thandle_kill_signal(False);\n\tgot_kill_signal = -1;\n\n\treturn ret;\n}\n\nvoid start_write_batch(int fd)\n{\n\t/* Some communication has already taken place, but we don't\n\t * enable batch writing until here so that we can write a\n\t * canonical record of the communication even though the\n\t * actual communication so far depends on whether a daemon\n\t * is involved. */\n\twrite_int(batch_fd, protocol_version);\n\tif (protocol_version >= 30)\n\t\twrite_varint(batch_fd, compat_flags);\n\twrite_int(batch_fd, checksum_seed);\n\n\tif (am_sender)\n\t\twrite_batch_monitor_out = fd;\n\telse\n\t\twrite_batch_monitor_in = fd;\n}\n\nvoid stop_write_batch(void)\n{\n\twrite_batch_monitor_out = -1;\n\twrite_batch_monitor_in = -1;\n}\n"
        },
        {
          "name": "io.h",
          "type": "blob",
          "size": 1.26171875,
          "content": "/*\n * Copyright (C) 2007-2019 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\nextern int protocol_version;\n\nstatic inline int32\nread_varint30(int f)\n{\n\tif (protocol_version < 30)\n\t\treturn read_int(f);\n\treturn read_varint(f);\n}\n\nstatic inline int64\nread_varlong30(int f, uchar min_bytes)\n{\n\tif (protocol_version < 30)\n\t\treturn read_longint(f);\n\treturn read_varlong(f, min_bytes);\n}\n\nstatic inline void\nwrite_varint30(int f, int32 x)\n{\n\tif (protocol_version < 30)\n\t\twrite_int(f, x);\n\telse\n\t\twrite_varint(f, x);\n}\n\nstatic inline void\nwrite_varlong30(int f, int64 x, uchar min_bytes)\n{\n\tif (protocol_version < 30)\n\t\twrite_longint(f, x);\n\telse\n\t\twrite_varlong(f, x, min_bytes);\n}\n"
        },
        {
          "name": "itypes.h",
          "type": "blob",
          "size": 1.4853515625,
          "content": "/* Inline functions for rsync.\n *\n * Copyright (C) 2007-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\nstatic inline int\nisDigit(const char *ptr)\n{\n\treturn isdigit(*(unsigned char *)ptr);\n}\n\nstatic inline int\nisHexDigit(const char *ptr)\n{\n\treturn isxdigit(*(unsigned char *)ptr);\n}\n\nstatic inline int\nisPrint(const char *ptr)\n{\n\treturn isprint(*(unsigned char *)ptr);\n}\n\nstatic inline int\nisSpace(const char *ptr)\n{\n\treturn isspace(*(unsigned char *)ptr);\n}\n\nstatic inline int\nisAlNum(const char *ptr)\n{\n\treturn isalnum(*(unsigned char *)ptr);\n}\n\nstatic inline int\nisLower(const char *ptr)\n{\n\treturn islower(*(unsigned char *)ptr);\n}\n\nstatic inline int\nisUpper(const char *ptr)\n{\n\treturn isupper(*(unsigned char *)ptr);\n}\n\nstatic inline int\ntoLower(const char *ptr)\n{\n\treturn tolower(*(unsigned char *)ptr);\n}\n\nstatic inline int\ntoUpper(const char *ptr)\n{\n\treturn toupper(*(unsigned char *)ptr);\n}\n"
        },
        {
          "name": "latest-year.h",
          "type": "blob",
          "size": 0.0263671875,
          "content": "#define LATEST_YEAR \"2024\"\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "loadparm.c",
          "type": "blob",
          "size": 14.8671875,
          "content": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n *\n * This is based on loadparm.c from Samba, written by Andrew Tridgell\n * and Karl Auer.  Some of the changes are:\n *\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2020 Wayne Davison\n */\n\n/* Load parameters.\n *\n *  This module provides suitable callback functions for the params\n *  module. It builds the internal table of section details which is\n *  then used by the rest of the server.\n *\n * To add a parameter:\n *\n * 1) add it to the global_vars or local_vars structure definition\n * 2) add it to the parm_table\n * 3) add it to the list of available functions (eg: using FN_GLOBAL_STRING())\n * 4) initialise it in the Defaults static structure\n *\n * Notes:\n *   The configuration file is processed sequentially for speed. For this\n *   reason, there is a fair bit of sequence-dependent code here - ie., code\n *   which assumes that certain things happen before others. In particular, the\n *   code which happens at the boundary between sections is delicately poised,\n *   so be careful!\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"ifuncs.h\"\n#include \"default-dont-compress.h\"\n\nextern item_list dparam_list;\n\n#define strequal(a, b) (strcasecmp(a, b)==0)\n\n#ifndef LOG_DAEMON\n#define LOG_DAEMON 0\n#endif\n\n/* the following are used by loadparm for option lists */\ntypedef enum {\n\tP_BOOL, P_BOOLREV, P_BOOL3, P_CHAR, P_INTEGER,\n\tP_OCTAL, P_PATH, P_STRING, P_ENUM\n} parm_type;\n\ntypedef enum {\n\tP_LOCAL, P_GLOBAL, P_NONE\n} parm_class;\n\nstruct enum_list {\n\tint value;\n\tchar *name;\n};\n\nstruct parm_struct {\n\tchar *label;\n\tparm_type type;\n\tparm_class class;\n\tvoid *ptr;\n\tstruct enum_list *enum_list;\n\tunsigned flags;\n};\n\n#ifndef GLOBAL_NAME\n#define GLOBAL_NAME \"global\"\n#endif\n\n/* some helpful bits */\n#define iSECTION(i) ((local_vars*)section_list.items)[i]\n#define LP_SNUM_OK(i) ((i) >= 0 && (i) < (int)section_list.count)\n#define SECTION_PTR(s, p) (((char*)(s)) + (ptrdiff_t)(((char*)(p))-(char*)&Vars.l))\n\n/* Stack of \"Vars\" values used by the &include directive. */\nstatic item_list Vars_stack = EMPTY_ITEM_LIST;\n\n/* The array of section values that holds all the defined modules. */\nstatic item_list section_list = EMPTY_ITEM_LIST;\n\nstatic int iSectionIndex = -1;\nstatic BOOL bInGlobalSection = True;\n\nstatic struct enum_list enum_syslog_facility[] = {\n#ifdef LOG_AUTH\n\t{ LOG_AUTH, \"auth\" },\n#endif\n#ifdef LOG_AUTHPRIV\n\t{ LOG_AUTHPRIV, \"authpriv\" },\n#endif\n#ifdef LOG_CRON\n\t{ LOG_CRON, \"cron\" },\n#endif\n#ifdef LOG_DAEMON\n\t{ LOG_DAEMON, \"daemon\" },\n#endif\n#ifdef LOG_FTP\n\t{ LOG_FTP, \"ftp\" },\n#endif\n#ifdef LOG_KERN\n\t{ LOG_KERN, \"kern\" },\n#endif\n#ifdef LOG_LPR\n\t{ LOG_LPR, \"lpr\" },\n#endif\n#ifdef LOG_MAIL\n\t{ LOG_MAIL, \"mail\" },\n#endif\n#ifdef LOG_NEWS\n\t{ LOG_NEWS, \"news\" },\n#endif\n#ifdef LOG_AUTH\n\t{ LOG_AUTH, \"security\" },\n#endif\n#ifdef LOG_SYSLOG\n\t{ LOG_SYSLOG, \"syslog\" },\n#endif\n#ifdef LOG_USER\n\t{ LOG_USER, \"user\" },\n#endif\n#ifdef LOG_UUCP\n\t{ LOG_UUCP, \"uucp\" },\n#endif\n#ifdef LOG_LOCAL0\n\t{ LOG_LOCAL0, \"local0\" },\n#endif\n#ifdef LOG_LOCAL1\n\t{ LOG_LOCAL1, \"local1\" },\n#endif\n#ifdef LOG_LOCAL2\n\t{ LOG_LOCAL2, \"local2\" },\n#endif\n#ifdef LOG_LOCAL3\n\t{ LOG_LOCAL3, \"local3\" },\n#endif\n#ifdef LOG_LOCAL4\n\t{ LOG_LOCAL4, \"local4\" },\n#endif\n#ifdef LOG_LOCAL5\n\t{ LOG_LOCAL5, \"local5\" },\n#endif\n#ifdef LOG_LOCAL6\n\t{ LOG_LOCAL6, \"local6\" },\n#endif\n#ifdef LOG_LOCAL7\n\t{ LOG_LOCAL7, \"local7\" },\n#endif\n\t{ -1, NULL }\n};\n\n/* Expand %VAR% references.  Any unknown vars or unrecognized\n * syntax leaves the raw chars unchanged. */\nstatic char *expand_vars(const char *str)\n{\n\tchar *buf, *t;\n\tconst char *f;\n\tint bufsize;\n\n\tif (!str || !strchr(str, '%'))\n\t\treturn (char *)str; /* TODO change return value to const char* at some point. */\n\n\tbufsize = strlen(str) + 2048;\n\tbuf = new_array(char, bufsize+1); /* +1 for trailing '\\0' */\n\n\tfor (t = buf, f = str; bufsize && *f; ) {\n\t\tif (*f == '%' && isUpper(f+1)) {\n\t\t\tchar *percent = strchr(f+1, '%');\n\t\t\tif (percent && percent - f < bufsize) {\n\t\t\t\tchar *val;\n\t\t\t\tstrlcpy(t, f+1, percent - f);\n\t\t\t\tval = getenv(t);\n\t\t\t\tif (val) {\n\t\t\t\t\tint len = strlcpy(t, val, bufsize+1);\n\t\t\t\t\tif (len > bufsize)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbufsize -= len;\n\t\t\t\t\tt += len;\n\t\t\t\t\tf = percent + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*t++ = *f++;\n\t\tbufsize--;\n\t}\n\t*t = '\\0';\n\n\tif (*f) {\n\t\trprintf(FLOG, \"Overflowed buf in expand_vars() trying to expand: %s\\n\", str);\n\t\texit_cleanup(RERR_MALLOC);\n\t}\n\n\tif (bufsize && (buf = realloc(buf, t - buf + 1)) == NULL)\n\t\tout_of_memory(\"expand_vars\");\n\n\treturn buf;\n}\n\n/* Each \"char* foo\" has an associated \"BOOL foo_EXP\" that tracks if the string has been expanded yet or not. */\n\n/* NOTE: use this function and all the FN_{GLOBAL,LOCAL} ones WITHOUT a trailing semicolon! */\n#define RETURN_EXPANDED(val) {if (!val ## _EXP) {val = expand_vars(val); val ## _EXP = True;} return val ? val : \"\";}\n\n/* In this section all the functions that are used to access the\n * parameters from the rest of the program are defined. */\n\n#define FN_GLOBAL_STRING(fn_name, val) \\\n char *fn_name(void) RETURN_EXPANDED(Vars.g.val)\n#define FN_GLOBAL_BOOL(fn_name, val) \\\n BOOL fn_name(void) {return Vars.g.val;}\n#define FN_GLOBAL_CHAR(fn_name, val) \\\n char fn_name(void) {return Vars.g.val;}\n#define FN_GLOBAL_INTEGER(fn_name, val) \\\n int fn_name(void) {return Vars.g.val;}\n\n#define FN_LOCAL_STRING(fn_name, val) \\\n char *fn_name(int i) {if (LP_SNUM_OK(i) && iSECTION(i).val) RETURN_EXPANDED(iSECTION(i).val) else RETURN_EXPANDED(Vars.l.val)}\n#define FN_LOCAL_BOOL(fn_name, val) \\\n BOOL fn_name(int i) {return LP_SNUM_OK(i)? iSECTION(i).val : Vars.l.val;}\n#define FN_LOCAL_CHAR(fn_name, val) \\\n char fn_name(int i) {return LP_SNUM_OK(i)? iSECTION(i).val : Vars.l.val;}\n#define FN_LOCAL_INTEGER(fn_name, val) \\\n int fn_name(int i) {return LP_SNUM_OK(i)? iSECTION(i).val : Vars.l.val;}\n\n/* The following include file contains:\n *\n * typedef global_vars - describes global (ie., server-wide) parameters.\n * typedef local_vars - describes a single section.\n * typedef all_vars - a combination of global_vars & local_vars.\n * all_vars Defaults - the default values for all the variables.\n * all_vars Vars - the currently configured values for all the variables.\n * struct parm_struct parm_table - the strings & variables for the parser.\n * FN_{LOCAL,GLOBAL}_{TYPE}() definition for all the lp_var_name() accessors.\n */\n\n#include \"daemon-parm.h\"\n\n/* Initialise the Default all_vars structure. */\nvoid reset_daemon_vars(void)\n{\n\tmemcpy(&Vars, &Defaults, sizeof Vars);\n}\n\n/* Assign a copy of v to *s.  Handles NULL strings.  We don't worry\n * about overwriting a malloc'd string because the long-running\n * (port-listening) daemon only loads the config file once, and the\n * per-job (forked or xinitd-ran) daemon only re-reads the file at\n * the start, so any lost memory is inconsequential. */\nstatic inline void string_set(char **s, const char *v)\n{\n\t*s = v ? strdup(v) : NULL;\n}\n\n/* Copy local_vars into a new section. No need to strdup since we don't free. */\nstatic void copy_section(local_vars *psectionDest, local_vars *psectionSource)\n{\n\tmemcpy(psectionDest, psectionSource, sizeof psectionDest[0]);\n}\n\n/* Initialise a section to the defaults. */\nstatic void init_section(local_vars *psection)\n{\n\tmemset(psection, 0, sizeof (local_vars));\n\tcopy_section(psection, &Vars.l);\n}\n\n/* Do a case-insensitive, whitespace-ignoring string equality check. */\nstatic int strwiEQ(char *psz1, char *psz2)\n{\n\t/* If one or both strings are NULL, we return equality right away. */\n\tif (psz1 == psz2)\n\t\treturn 1;\n\tif (psz1 == NULL || psz2 == NULL)\n\t\treturn 0;\n\n\t/* sync the strings on first non-whitespace */\n\twhile (1) {\n\t\twhile (isSpace(psz1))\n\t\t\tpsz1++;\n\t\twhile (isSpace(psz2))\n\t\t\tpsz2++;\n\t\tif (*psz1 == '\\0' || *psz2 == '\\0')\n\t\t\tbreak;\n\t\tif (toUpper(psz1) != toUpper(psz2))\n\t\t\tbreak;\n\t\tpsz1++;\n\t\tpsz2++;\n\t}\n\treturn *psz1 == *psz2;\n}\n\n/* Find a section by name. Otherwise works like get_section. */\nstatic int getsectionbyname(char *name)\n{\n\tint i;\n\n\tfor (i = section_list.count - 1; i >= 0; i--) {\n\t\tif (strwiEQ(iSECTION(i).name, name))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\n/* Add a new section to the sections array w/the default values. */\nstatic int add_a_section(char *name)\n{\n\tint i;\n\tlocal_vars *s;\n\n\t/* it might already exist */\n\tif (name) {\n\t\ti = getsectionbyname(name);\n\t\tif (i >= 0)\n\t\t\treturn i;\n\t}\n\n\ti = section_list.count;\n\ts = EXPAND_ITEM_LIST(&section_list, local_vars, 2);\n\n\tinit_section(s);\n\tif (name)\n\t\tstring_set(&s->name, name);\n\n\treturn i;\n}\n\n/* Map a parameter's string representation to something we can use.\n * Returns False if the parameter string is not recognised, else TRUE. */\nstatic int map_parameter(char *parmname)\n{\n\tint iIndex;\n\n\tif (*parmname == '-')\n\t\treturn -1;\n\n\tfor (iIndex = 0; parm_table[iIndex].label; iIndex++) {\n\t\tif (strwiEQ(parm_table[iIndex].label, parmname))\n\t\t\treturn iIndex;\n\t}\n\n\trprintf(FLOG, \"Unknown Parameter encountered: \\\"%s\\\"\\n\", parmname);\n\treturn -1;\n}\n\n/* Set a boolean variable from the text value stored in the passed string.\n * Returns True in success, False if the passed string does not correctly\n * represent a boolean. */\nstatic BOOL set_boolean(BOOL *pb, char *parmvalue, int allow_unset)\n{\n\tif (strwiEQ(parmvalue, \"yes\") || strwiEQ(parmvalue, \"true\") || strwiEQ(parmvalue, \"1\"))\n\t\t*pb = True;\n\telse if (strwiEQ(parmvalue, \"no\") || strwiEQ(parmvalue, \"false\") || strwiEQ(parmvalue, \"0\"))\n\t\t*pb = False;\n\telse if (allow_unset && (strwiEQ(parmvalue, \"unset\") || strwiEQ(parmvalue, \"-1\")))\n\t\t*pb = Unset;\n\telse {\n\t\trprintf(FLOG, \"Badly formed boolean in configuration file: \\\"%s\\\".\\n\", parmvalue);\n\t\treturn False;\n\t}\n\treturn True;\n}\n\n/* Process a parameter. */\nstatic BOOL do_parameter(char *parmname, char *parmvalue)\n{\n\tint parmnum, i;\n\tvoid *parm_ptr; /* where we are going to store the result */\n\tvoid *def_ptr;\n\tchar *cp;\n\n\tparmnum = map_parameter(parmname);\n\n\tif (parmnum < 0) {\n\t\trprintf(FLOG, \"IGNORING unknown parameter \\\"%s\\\"\\n\", parmname);\n\t\treturn True;\n\t}\n\n\tdef_ptr = parm_table[parmnum].ptr;\n\n\tif (bInGlobalSection)\n\t\tparm_ptr = def_ptr;\n\telse {\n\t\tif (parm_table[parmnum].class == P_GLOBAL) {\n\t\t\trprintf(FLOG, \"Global parameter %s found in module section!\\n\", parmname);\n\t\t\treturn True;\n\t\t}\n\t\tparm_ptr = SECTION_PTR(&iSECTION(iSectionIndex), def_ptr);\n\t}\n\n\t/* now switch on the type of variable it is */\n\tswitch (parm_table[parmnum].type) {\n\tcase P_PATH:\n\tcase P_STRING:\n\t\t/* delay expansion of %VAR% strings */\n\t\tbreak;\n\tdefault:\n\t\t/* expand any %VAR% strings now */\n\t\tparmvalue = expand_vars(parmvalue);\n\t\tbreak;\n\t}\n\n\tswitch (parm_table[parmnum].type) {\n\tcase P_BOOL:\n\t\tset_boolean(parm_ptr, parmvalue, False);\n\t\tbreak;\n\n\tcase P_BOOL3:\n\t\tset_boolean(parm_ptr, parmvalue, True);\n\t\tbreak;\n\n\tcase P_BOOLREV:\n\t\tset_boolean(parm_ptr, parmvalue, False);\n\t\t*(BOOL *)parm_ptr = ! *(BOOL *)parm_ptr;\n\t\tbreak;\n\n\tcase P_INTEGER:\n\t\t*(int *)parm_ptr = atoi(parmvalue);\n\t\tbreak;\n\n\tcase P_CHAR:\n\t\t*(char *)parm_ptr = *parmvalue;\n\t\tbreak;\n\n\tcase P_OCTAL:\n\t\tsscanf(parmvalue, \"%o\", (unsigned int *)parm_ptr);\n\t\tbreak;\n\n\tcase P_PATH:\n\t\tstring_set(parm_ptr, parmvalue);\n\t\tif ((cp = *(char**)parm_ptr) != NULL) {\n\t\t\tint len = strlen(cp);\n\t\t\twhile (len > 1 && cp[len-1] == '/') len--;\n\t\t\tcp[len] = '\\0';\n\t\t}\n\t\tbreak;\n\n\tcase P_STRING:\n\t\tstring_set(parm_ptr, parmvalue);\n\t\tbreak;\n\n\tcase P_ENUM:\n\t\tfor (i=0; parm_table[parmnum].enum_list[i].name; i++) {\n\t\t\tif (strequal(parmvalue, parm_table[parmnum].enum_list[i].name)) {\n\t\t\t\t*(int *)parm_ptr = parm_table[parmnum].enum_list[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!parm_table[parmnum].enum_list[i].name) {\n\t\t\tif (atoi(parmvalue) > 0)\n\t\t\t\t*(int *)parm_ptr = atoi(parmvalue);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn True;\n}\n\n/* Process a new section (rsync module).\n * Returns True on success, False on failure. */\nstatic BOOL do_section(char *sectionname)\n{\n\tBOOL isglobal;\n\n\tif (*sectionname == ']') { /* A special push/pop/reset directive from params.c */\n\t\tbInGlobalSection = 1;\n\t\tif (strcmp(sectionname+1, \"push\") == 0) {\n\t\t\tall_vars *vp = EXPAND_ITEM_LIST(&Vars_stack, all_vars, 2);\n\t\t\tmemcpy(vp, &Vars, sizeof Vars);\n\t\t} else if (strcmp(sectionname+1, \"pop\") == 0\n\t\t || strcmp(sectionname+1, \"reset\") == 0) {\n\t\t\tall_vars *vp = ((all_vars*)Vars_stack.items) + Vars_stack.count - 1;\n\t\t\tif (!Vars_stack.count)\n\t\t\t\treturn False;\n\t\t\tmemcpy(&Vars, vp, sizeof Vars);\n\t\t\tif (sectionname[1] == 'p')\n\t\t\t\tVars_stack.count--;\n\t\t} else\n\t\t\treturn False;\n\t\treturn True;\n\t}\n\n\tisglobal = strwiEQ(sectionname, GLOBAL_NAME);\n\n\t/* At the end of the global section, add any --dparam items. */\n\tif (bInGlobalSection && !isglobal) {\n\t\tif (!section_list.count)\n\t\t\tset_dparams(0);\n\t}\n\n\t/* if we've just struck a global section, note the fact. */\n\tbInGlobalSection = isglobal;\n\n\t/* check for multiple global sections */\n\tif (bInGlobalSection)\n\t\treturn True;\n\n#if 0\n\t/* If we have a current section, tidy it up before moving on. */\n\tif (iSectionIndex >= 0) {\n\t\t/* Add any tidy work as needed ... */\n\t\tif (problem)\n\t\t\treturn False;\n\t}\n#endif\n\n\tif (strchr(sectionname, '/') != NULL) {\n\t\trprintf(FLOG, \"Warning: invalid section name in configuration file: %s\\n\", sectionname);\n\t\treturn False;\n\t}\n\n\tif ((iSectionIndex = add_a_section(sectionname)) < 0) {\n\t\trprintf(FLOG, \"Failed to add a new module\\n\");\n\t\tbInGlobalSection = True;\n\t\treturn False;\n\t}\n\n\treturn True;\n}\n\n/* Load the modules from the config file. Return True on success,\n * False on failure. */\nint lp_load(char *pszFname, int globals_only)\n{\n\tbInGlobalSection = True;\n\n\treset_daemon_vars();\n\n\t/* We get sections first, so have to start 'behind' to make up. */\n\tiSectionIndex = -1;\n\treturn pm_process(pszFname, globals_only ? NULL : do_section, do_parameter);\n}\n\nBOOL set_dparams(int syntax_check_only)\n{\n\tchar *equal, *val, **params = dparam_list.items;\n\tunsigned j;\n\n\tfor (j = 0; j < dparam_list.count; j++) {\n\t\tequal = strchr(params[j], '='); /* options.c verified this */\n\t\t*equal = '\\0';\n\t\tif (syntax_check_only) {\n\t\t\tif (map_parameter(params[j]) < 0) {\n\t\t\t\trprintf(FERROR, \"Unknown parameter \\\"%s\\\"\\n\", params[j]);\n\t\t\t\t*equal = '=';\n\t\t\t\treturn False;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (val = equal+1; isSpace(val); val++) {}\n\t\t\tdo_parameter(params[j], val);\n\t\t}\n\t\t*equal = '=';\n\t}\n\n\treturn True;\n}\n\n/* Return the max number of modules (sections). */\nint lp_num_modules(void)\n{\n\treturn section_list.count;\n}\n\n/* Return the number of the module with the given name, or -1 if it doesn't\n * exist. Note that this is a DIFFERENT ANIMAL from the internal function\n * getsectionbyname()! This works ONLY if all sections have been loaded,\n * and does not copy the found section. */\nint lp_number(char *name)\n{\n\tint i;\n\n\tfor (i = section_list.count - 1; i >= 0; i--) {\n\t\tif (strcmp(lp_name(i), name) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 24.1923828125,
          "content": "/*\n * Logging and utility functions.\n *\n * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 2000-2001 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"inums.h\"\n\nextern int dry_run;\nextern int am_daemon;\nextern int am_server;\nextern int am_sender;\nextern int am_generator;\nextern int local_server;\nextern int quiet;\nextern int module_id;\nextern int allow_8bit_chars;\nextern int protocol_version;\nextern int always_checksum;\nextern int preserve_mtimes;\nextern int msgs2stderr;\nextern int stdout_format_has_i;\nextern int stdout_format_has_o_or_i;\nextern int logfile_format_has_i;\nextern int logfile_format_has_o_or_i;\nextern int receiver_symlink_times;\nextern int64 total_data_written;\nextern int64 total_data_read;\nextern mode_t orig_umask;\nextern char *auth_user;\nextern char *stdout_format;\nextern char *logfile_format;\nextern char *logfile_name;\n#ifdef ICONV_CONST\nextern iconv_t ic_chck;\n#endif\n#ifdef ICONV_OPTION\nextern iconv_t ic_recv;\n#endif\nextern char curr_dir[MAXPATHLEN];\nextern char *full_module_path;\nextern unsigned int module_dirlen;\nextern char sender_file_sum[MAX_DIGEST_LEN];\nextern const char undetermined_hostname[];\n\nextern struct name_num_item *xfer_sum_nni, *file_sum_nni;\n\nstatic int log_initialised;\nstatic int logfile_was_closed;\nstatic FILE *logfile_fp;\nstruct stats stats;\n\nint got_xfer_error = 0;\nint output_needs_newline = 0;\nint send_msgs_to_gen = 0;\n\nstatic int64 initial_data_written;\nstatic int64 initial_data_read;\n\nstruct {\n\tint code;\n\tchar const *name;\n} const rerr_names[] = {\n\t{ RERR_SYNTAX     , \"syntax or usage error\" },\n\t{ RERR_PROTOCOL   , \"protocol incompatibility\" },\n\t{ RERR_FILESELECT , \"errors selecting input/output files, dirs\" },\n\t{ RERR_UNSUPPORTED, \"requested action not supported\" },\n\t{ RERR_STARTCLIENT, \"error starting client-server protocol\" },\n\t{ RERR_SOCKETIO   , \"error in socket IO\" },\n\t{ RERR_FILEIO     , \"error in file IO\" },\n\t{ RERR_STREAMIO   , \"error in rsync protocol data stream\" },\n\t{ RERR_MESSAGEIO  , \"errors with program diagnostics\" },\n\t{ RERR_IPC        , \"error in IPC code\" },\n\t{ RERR_CRASHED    , \"sibling process crashed\" },\n\t{ RERR_TERMINATED , \"sibling process terminated abnormally\" },\n\t{ RERR_SIGNAL1    , \"received SIGUSR1\" },\n\t{ RERR_SIGNAL     , \"received SIGINT, SIGTERM, or SIGHUP\" },\n\t{ RERR_WAITCHILD  , \"waitpid() failed\" },\n\t{ RERR_MALLOC     , \"error allocating core memory buffers\" },\n\t{ RERR_PARTIAL    , \"some files/attrs were not transferred (see previous errors)\" },\n\t{ RERR_VANISHED   , \"some files vanished before they could be transferred\" },\n\t{ RERR_DEL_LIMIT  , \"the --max-delete limit stopped deletions\" },\n\t{ RERR_TIMEOUT    , \"timeout in data send/receive\" },\n\t{ RERR_CONTIMEOUT , \"timeout waiting for daemon connection\" },\n\t{ RERR_CMD_FAILED , \"remote shell failed\" },\n\t{ RERR_CMD_KILLED , \"remote shell killed\" },\n\t{ RERR_CMD_RUN    , \"remote command could not be run\" },\n\t{ RERR_CMD_NOTFOUND,\"remote command not found\" },\n\t{ 0, NULL }\n};\n\n/*\n * Map from rsync error code to name, or return NULL.\n */\nstatic char const *rerr_name(int code)\n{\n\tint i;\n\tfor (i = 0; rerr_names[i].name; i++) {\n\t\tif (rerr_names[i].code == code)\n\t\t\treturn rerr_names[i].name;\n\t}\n\treturn NULL;\n}\n\nstatic void logit(int priority, const char *buf)\n{\n\tif (logfile_was_closed)\n\t\tlogfile_reopen();\n\tif (logfile_fp) {\n\t\tfprintf(logfile_fp, \"%s [%d] %s\", timestring(time(NULL)), (int)getpid(), buf);\n\t\tfflush(logfile_fp);\n\t} else {\n\t\tsyslog(priority, \"%s\", buf);\n\t}\n}\n\nstatic void syslog_init()\n{\n\tint options = LOG_PID;\n\n#ifdef LOG_NDELAY\n\toptions |= LOG_NDELAY;\n#endif\n\n#ifdef LOG_DAEMON\n\topenlog(lp_syslog_tag(module_id), options, lp_syslog_facility(module_id));\n#else\n\topenlog(lp_syslog_tag(module_id), options);\n#endif\n\n#ifndef LOG_NDELAY\n\tlogit(LOG_INFO, \"rsyncd started\\n\");\n#endif\n}\n\nstatic void logfile_open(void)\n{\n\tmode_t old_umask = umask(022 | orig_umask);\n\tlogfile_fp = fopen(logfile_name, \"a\");\n\tumask(old_umask);\n\tif (!logfile_fp) {\n\t\tint fopen_errno = errno;\n\t\t/* Rsync falls back to using syslog on failure. */\n\t\tsyslog_init();\n\t\trsyserr(FERROR, fopen_errno,\n\t\t\t\"failed to open log-file %s\", logfile_name);\n\t\trprintf(FINFO, \"Ignoring \\\"log file\\\" setting.\\n\");\n\t\tlogfile_name = \"\";\n\t}\n}\n\nvoid log_init(int restart)\n{\n\tif (log_initialised) {\n\t\tif (!restart) /* Note: a restart only happens with am_daemon */\n\t\t\treturn;\n\t\tassert(logfile_name); /* all am_daemon procs got at least an empty string */\n\t\tif (strcmp(logfile_name, lp_log_file(module_id)) != 0) {\n\t\t\tif (logfile_fp) {\n\t\t\t\tfclose(logfile_fp);\n\t\t\t\tlogfile_fp = NULL;\n\t\t\t} else\n\t\t\t\tcloselog();\n\t\t\tlogfile_name = NULL;\n\t\t} else if (*logfile_name)\n\t\t\treturn; /* unchanged, non-empty \"log file\" names */\n\t\telse if (lp_syslog_facility(-1) != lp_syslog_facility(module_id)\n\t\t      || strcmp(lp_syslog_tag(-1), lp_syslog_tag(module_id)) != 0)\n\t\t\tcloselog();\n\t\telse\n\t\t\treturn; /* unchanged syslog settings */\n\t} else\n\t\tlog_initialised = 1;\n\n\t/* This looks pointless, but it is needed in order for the\n\t * C library on some systems to fetch the timezone info\n\t * before the chroot. */\n\ttimestring(time(NULL));\n\n\t/* Optionally use a log file instead of syslog.  (Non-daemon\n\t * rsyncs will have already set logfile_name, as needed.) */\n\tif (am_daemon && !logfile_name)\n\t\tlogfile_name = lp_log_file(module_id);\n\tif (logfile_name && *logfile_name)\n\t\tlogfile_open();\n\telse\n\t\tsyslog_init();\n}\n\n/* Note that this close & reopen idiom intentionally ignores syslog logging. */\nvoid logfile_close(void)\n{\n\tif (logfile_fp) {\n\t\tlogfile_was_closed = 1;\n\t\tfclose(logfile_fp);\n\t\tlogfile_fp = NULL;\n\t}\n}\n\nvoid logfile_reopen(void)\n{\n\tif (logfile_was_closed) {\n\t\tlogfile_was_closed = 0;\n\t\tlogfile_open();\n\t}\n}\n\nstatic void filtered_fwrite(FILE *f, const char *in_buf, int in_len, int use_isprint, char end_char)\n{\n\tchar outbuf[1024], *ob = outbuf;\n\tconst char *end = in_buf + in_len;\n\twhile (in_buf < end) {\n\t\tif (ob - outbuf >= (int)sizeof outbuf - 10) {\n\t\t\tif (fwrite(outbuf, ob - outbuf, 1, f) != 1)\n\t\t\t\texit_cleanup(RERR_MESSAGEIO);\n\t\t\tob = outbuf;\n\t\t}\n\t\tif ((in_buf < end - 4 && *in_buf == '\\\\' && in_buf[1] == '#'\n\t\t  && isDigit(in_buf + 2) && isDigit(in_buf + 3) && isDigit(in_buf + 4))\n\t\t || (*in_buf != '\\t' && ((use_isprint && !isPrint(in_buf)) || *(uchar*)in_buf < ' ')))\n\t\t\tob += snprintf(ob, 6, \"\\\\#%03o\", *(uchar*)in_buf++);\n\t\telse\n\t\t\t*ob++ = *in_buf++;\n\t}\n\tif (end_char) /* The \"- 10\" above means that there is always room for one more char here. */\n\t\t*ob++ = end_char;\n\tif (ob != outbuf && fwrite(outbuf, ob - outbuf, 1, f) != 1)\n\t\texit_cleanup(RERR_MESSAGEIO);\n}\n\n/* this is the underlying (unformatted) rsync debugging function. Call\n * it with FINFO, FERROR_*, FWARNING, FLOG, or FCLIENT.  Note: recursion\n * can happen with certain fatal conditions. */\nvoid rwrite(enum logcode code, const char *buf, int len, int is_utf8)\n{\n\tchar trailing_CR_or_NL;\n\tFILE *f = msgs2stderr == 1 ? stderr : stdout;\n#ifdef ICONV_OPTION\n\ticonv_t ic = is_utf8 && ic_recv != (iconv_t)-1 ? ic_recv : ic_chck;\n#else\n#ifdef ICONV_CONST\n\ticonv_t ic = ic_chck;\n#endif\n#endif\n\n\tif (len < 0)\n\t\texit_cleanup(RERR_MESSAGEIO);\n\n\tif (msgs2stderr == 1) {\n\t\t/* A normal daemon can get msgs2stderr set if the socket is busted, so we\n\t\t * change the message destination into an FLOG message in order to try to\n\t\t * get some info about an abnormal-exit into the log file. An rsh daemon\n\t\t * can have this set via user request, so we'll leave the code alone so\n\t\t * that the msg gets logged and then sent to stderr after that. */\n\t\tif (am_daemon > 0 && code != FCLIENT)\n\t\t\tcode = FLOG;\n\t} else if (send_msgs_to_gen) {\n\t\tassert(!is_utf8);\n\t\t/* Pass the message to our sibling in native charset. */\n\t\tsend_msg((enum msgcode)code, buf, len, 0);\n\t\treturn;\n\t}\n\n\tif (code == FERROR_SOCKET) /* This gets simplified for a non-sibling. */\n\t\tcode = FERROR;\n\telse if (code == FERROR_UTF8) {\n\t\tis_utf8 = 1;\n\t\tcode = FERROR;\n\t}\n\n\tif (code == FCLIENT)\n\t\tcode = FINFO;\n\telse if (am_daemon || logfile_name) {\n\t\tstatic int in_block;\n\t\tchar msg[2048];\n\t\tint priority = code == FINFO || code == FLOG ? LOG_INFO :  LOG_WARNING;\n\n\t\tif (in_block)\n\t\t\treturn;\n\t\tin_block = 1;\n\t\tif (!log_initialised)\n\t\t\tlog_init(0);\n\t\tstrlcpy(msg, buf, MIN((int)sizeof msg, len + 1));\n\t\tlogit(priority, msg);\n\t\tin_block = 0;\n\n\t\tif (code == FLOG || (am_daemon && !am_server))\n\t\t\treturn;\n\t} else if (code == FLOG)\n\t\treturn;\n\n\tswitch (code) {\n\tcase FERROR_XFER:\n\t\tgot_xfer_error = 1;\n\t\t/* FALL THROUGH */\n\tcase FERROR:\n\tcase FWARNING:\n\t\tf = stderr;\n\t\tbreak;\n\tcase FINFO:\n\t\tif (quiet)\n\t\t\treturn;\n\t\tbreak;\n\t/*case FLOG:*/\n\t/*case FCLIENT:*/\n\t/*case FERROR_UTF8:*/\n\t/*case FERROR_SOCKET:*/\n\tdefault:\n\t\tfprintf(stderr, \"Bad logcode in rwrite(): %d [%s]\\n\", (int)code, who_am_i());\n\t\texit_cleanup(RERR_MESSAGEIO);\n\t}\n\n\tif (am_server && msgs2stderr != 1 && (msgs2stderr != 2 || f != stderr)) {\n\t\tenum msgcode msg = (enum msgcode)code;\n\t\tif (protocol_version < 30) {\n\t\t\tif (msg == MSG_ERROR)\n\t\t\t\tmsg = MSG_ERROR_XFER;\n\t\t\telse if (msg == MSG_WARNING)\n\t\t\t\tmsg = MSG_INFO;\n\t\t}\n\t\t/* Pass the message to the non-server side. */\n\t\tif (send_msg(msg, buf, len, !is_utf8))\n\t\t\treturn;\n\t\tif (am_daemon > 0) {\n\t\t\t/* TODO: can we send the error to the user somehow? */\n\t\t\treturn;\n\t\t}\n\t\tf = stderr;\n\t}\n\n\tif (output_needs_newline) {\n\t\tfputc('\\n', f);\n\t\toutput_needs_newline = 0;\n\t}\n\n\ttrailing_CR_or_NL = len && (buf[len-1] == '\\n' || buf[len-1] == '\\r') ? buf[--len] : '\\0';\n\n\tif (len && buf[0] == '\\r') {\n\t\tfputc('\\r', f);\n\t\tbuf++;\n\t\tlen--;\n\t}\n\n#ifdef ICONV_CONST\n\tif (ic != (iconv_t)-1) {\n\t\txbuf outbuf, inbuf;\n\t\tchar convbuf[1024];\n\t\tint ierrno;\n\n\t\tINIT_CONST_XBUF(outbuf, convbuf);\n\t\tINIT_XBUF(inbuf, (char*)buf, len, (size_t)-1);\n\n\t\twhile (inbuf.len) {\n\t\t\ticonvbufs(ic, &inbuf, &outbuf, inbuf.pos ? 0 : ICB_INIT);\n\t\t\tierrno = errno;\n\t\t\tif (outbuf.len) {\n\t\t\t\tchar trailing = inbuf.len ? '\\0' : trailing_CR_or_NL;\n\t\t\t\tfiltered_fwrite(f, convbuf, outbuf.len, 0, trailing);\n\t\t\t\tif (trailing) {\n\t\t\t\t\ttrailing_CR_or_NL = '\\0';\n\t\t\t\t\tfflush(f);\n\t\t\t\t}\n\t\t\t\toutbuf.len = 0;\n\t\t\t}\n\t\t\t/* Log one byte of illegal/incomplete sequence and continue with\n\t\t\t * the next character. Check that the buffer is non-empty for the\n\t\t\t * sake of robustness. */\n\t\t\tif ((ierrno == EILSEQ || ierrno == EINVAL) && inbuf.len) {\n\t\t\t\tfprintf(f, \"\\\\#%03o\", CVAL(inbuf.buf, inbuf.pos++));\n\t\t\t\tinbuf.len--;\n\t\t\t}\n\t\t}\n\n\t\tif (trailing_CR_or_NL) {\n\t\t\tfputc(trailing_CR_or_NL, f);\n\t\t\tfflush(f);\n\t\t}\n\t} else\n#endif\n\t{\n\t\tfiltered_fwrite(f, buf, len, !allow_8bit_chars, trailing_CR_or_NL);\n\t\tif (trailing_CR_or_NL)\n\t\t\tfflush(f);\n\t}\n}\n\n/* This is the rsync debugging function. Call it with FINFO, FERROR_*,\n * FWARNING, FLOG, or FCLIENT. */\nvoid rprintf(enum logcode code, const char *format, ...)\n{\n\tva_list ap;\n\tchar buf[BIGPATHBUFLEN];\n\tsize_t len;\n\n\tva_start(ap, format);\n\tlen = vsnprintf(buf, sizeof buf, format, ap);\n\tva_end(ap);\n\n\t/* Deal with buffer overruns.  Instead of panicking, just\n\t * truncate the resulting string.  (Note that configure ensures\n\t * that we have a vsnprintf() that doesn't ever return -1.) */\n\tif (len > sizeof buf - 1) {\n\t\tstatic const char ellipsis[] = \"[...]\";\n\n\t\t/* Reset length, and zero-terminate the end of our buffer */\n\t\tlen = sizeof buf - 1;\n\t\tbuf[len] = '\\0';\n\n\t\t/* Copy the ellipsis to the end of the string, but give\n\t\t * us one extra character:\n\t\t *\n\t\t *                  v--- null byte at buf[sizeof buf - 1]\n\t\t *        abcdefghij0\n\t\t *     -> abcd[...]00  <-- now two null bytes at end\n\t\t *\n\t\t * If the input format string has a trailing newline,\n\t\t * we copy it into that extra null; if it doesn't, well,\n\t\t * all we lose is one byte.  */\n\t\tmemcpy(buf+len-sizeof ellipsis, ellipsis, sizeof ellipsis);\n\t\tif (format[strlen(format)-1] == '\\n') {\n\t\t\tbuf[len-1] = '\\n';\n\t\t}\n\t}\n\n\trwrite(code, buf, len, 0);\n}\n\n/* This is like rprintf, but it also tries to print some\n * representation of the error code.  Normally errcode = errno.\n *\n * Unlike rprintf, this always adds a newline and there should not be\n * one in the format string.\n *\n * Note that since strerror might involve dynamically loading a\n * message catalog we need to call it once before chroot-ing. */\nvoid rsyserr(enum logcode code, int errcode, const char *format, ...)\n{\n\tva_list ap;\n\tchar buf[BIGPATHBUFLEN];\n\tsize_t len;\n\n\tlen = snprintf(buf, sizeof buf, RSYNC_NAME \": [%s] \", who_am_i());\n\n\tva_start(ap, format);\n\tlen += vsnprintf(buf + len, sizeof buf - len, format, ap);\n\tva_end(ap);\n\n\tif (len < sizeof buf) {\n\t\tlen += snprintf(buf + len, sizeof buf - len,\n\t\t\t\t\": %s (%d)\\n\", strerror(errcode), errcode);\n\t}\n\tif (len >= sizeof buf)\n\t\texit_cleanup(RERR_MESSAGEIO);\n\n\trwrite(code, buf, len, 0);\n}\n\nvoid rflush(enum logcode code)\n{\n\tFILE *f;\n\n\tif (am_daemon || code == FLOG)\n\t\treturn;\n\n\tif (!am_server && (code == FINFO || code == FCLIENT))\n\t\tf = stdout;\n\telse\n\t\tf = stderr;\n\n\tfflush(f);\n}\n\nvoid remember_initial_stats(void)\n{\n\tinitial_data_read = total_data_read;\n\tinitial_data_written = total_data_written;\n}\n\n/* A generic logging routine for send/recv, with parameter substitiution. */\nstatic void log_formatted(enum logcode code, const char *format, const char *op,\n\t\t\t  struct file_struct *file, const char *fname, int iflags,\n\t\t\t  const char *hlink)\n{\n\tchar buf[MAXPATHLEN+1024], buf2[MAXPATHLEN], fmt[32];\n\tchar *p, *s, *c;\n\tconst char *n;\n\tsize_t len, total;\n\tint64 b;\n\n\t*fmt = '%';\n\n\t/* We expand % codes one by one in place in buf.  We don't\n\t * copy in the terminating null of the inserted strings, but\n\t * rather keep going until we reach the null of the format. */\n\ttotal = strlcpy(buf, format, sizeof buf);\n\tif (total > MAXPATHLEN) {\n\t\trprintf(FERROR, \"log-format string is WAY too long!\\n\");\n\t\texit_cleanup(RERR_MESSAGEIO);\n\t}\n\tbuf[total++] = '\\n';\n\tbuf[total] = '\\0';\n\n\tfor (p = buf; (p = strchr(p, '%')) != NULL; ) {\n\t\tint humanize = 0;\n\t\ts = p++;\n\t\tc = fmt + 1;\n\t\twhile (*p == '\\'') {\n\t\t\thumanize++;\n\t\t\tp++;\n\t\t}\n\t\tif (*p == '-')\n\t\t\t*c++ = *p++;\n\t\twhile (isDigit(p) && c - fmt < (int)(sizeof fmt) - 8)\n\t\t\t*c++ = *p++;\n\t\twhile (*p == '\\'') {\n\t\t\thumanize++;\n\t\t\tp++;\n\t\t}\n\t\tif (!*p)\n\t\t\tbreak;\n\t\t*c = '\\0';\n\t\tn = NULL;\n\n\t\t/* Note for %h and %a: it doesn't matter what fd we pass to\n\t\t * client_{name,addr} because rsync_module will already have\n\t\t * forced the answer to be cached (assuming, of course, for %h\n\t\t * that lp_reverse_lookup(module_id) is true). */\n\t\tswitch (*p) {\n\t\tcase 'h':\n\t\t\tif (am_daemon) {\n\t\t\t\tn = lp_reverse_lookup(module_id)\n\t\t\t\t  ? client_name(0) : undetermined_hostname;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tif (am_daemon)\n\t\t\t\tn = client_addr(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tstrlcat(fmt, \"s\", sizeof fmt);\n\t\t\tsnprintf(buf2, sizeof buf2, fmt,\n\t\t\t\t do_big_num(F_LENGTH(file), humanize, NULL));\n\t\t\tn = buf2;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tstrlcat(fmt, \"u\", sizeof fmt);\n\t\t\tsnprintf(buf2, sizeof buf2, fmt,\n\t\t\t\t uid_ndx ? F_OWNER(file) : 0);\n\t\t\tn = buf2;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tif (!gid_ndx || file->flags & FLAG_SKIP_GROUP)\n\t\t\t\tn = \"DEFAULT\";\n\t\t\telse {\n\t\t\t\tstrlcat(fmt, \"u\", sizeof fmt);\n\t\t\t\tsnprintf(buf2, sizeof buf2, fmt,\n\t\t\t\t\t F_GROUP(file));\n\t\t\t\tn = buf2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tstrlcat(fmt, \"d\", sizeof fmt);\n\t\t\tsnprintf(buf2, sizeof buf2, fmt, (int)getpid());\n\t\t\tn = buf2;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tn = c = timestring(file->modtime);\n\t\t\twhile ((c = strchr(c, ' ')) != NULL)\n\t\t\t\t*c = '-';\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tc = buf2 + MAXPATHLEN - PERMSTRING_SIZE - 1;\n\t\t\tpermstring(c, file->mode);\n\t\t\tn = c + 1; /* skip the type char */\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tn = op;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (fname) {\n\t\t\t\tc = f_name_buf();\n\t\t\t\tstrlcpy(c, fname, MAXPATHLEN);\n\t\t\t} else\n\t\t\t\tc = f_name(file, NULL);\n\t\t\tif (am_sender && F_PATHNAME(file)) {\n\t\t\t\tpathjoin(buf2, sizeof buf2,\n\t\t\t\t\t F_PATHNAME(file), c);\n\t\t\t\tclean_fname(buf2, 0);\n\t\t\t\tif (fmt[1]) {\n\t\t\t\t\tstrlcpy(c, buf2, MAXPATHLEN);\n\t\t\t\t\tn = c;\n\t\t\t\t} else\n\t\t\t\t\tn = buf2;\n\t\t\t} else if (am_daemon && *c != '/') {\n\t\t\t\tpathjoin(buf2, sizeof buf2,\n\t\t\t\t\t curr_dir + module_dirlen, c);\n\t\t\t\tclean_fname(buf2, 0);\n\t\t\t\tif (fmt[1]) {\n\t\t\t\t\tstrlcpy(c, buf2, MAXPATHLEN);\n\t\t\t\t\tn = c;\n\t\t\t\t} else\n\t\t\t\t\tn = buf2;\n\t\t\t} else {\n\t\t\t\tclean_fname(c, 0);\n\t\t\t\tn = c;\n\t\t\t}\n\t\t\tif (*n == '/')\n\t\t\t\tn++;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (fname) {\n\t\t\t\tc = f_name_buf();\n\t\t\t\tstrlcpy(c, fname, MAXPATHLEN);\n\t\t\t} else\n\t\t\t\tc = f_name(file, NULL);\n\t\t\tif (S_ISDIR(file->mode))\n\t\t\t\tstrlcat(c, \"/\", MAXPATHLEN);\n\t\t\tn = c;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (hlink && *hlink) {\n\t\t\t\tn = hlink;\n\t\t\t\tstrlcpy(buf2, \" => \", sizeof buf2);\n\t\t\t} else if (S_ISLNK(file->mode) && !fname) {\n\t\t\t\tn = F_SYMLINK(file);\n\t\t\t\tstrlcpy(buf2, \" -> \", sizeof buf2);\n\t\t\t} else {\n\t\t\t\tn = \"\";\n\t\t\t\tif (!fmt[1])\n\t\t\t\t\tbreak;\n\t\t\t\tstrlcpy(buf2, \"    \", sizeof buf2);\n\t\t\t}\n\t\t\tstrlcat(fmt, \"s\", sizeof fmt);\n\t\t\tsnprintf(buf2 + 4, sizeof buf2 - 4, fmt, n);\n\t\t\tn = buf2;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tn = lp_name(module_id);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tn = timestring(time(NULL));\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tn = full_module_path;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tn = auth_user;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\tcase 'c':\n\t\t\tif (!(iflags & ITEM_TRANSFER))\n\t\t\t\tb = 0;\n\t\t\telse if ((!!am_sender) ^ (*p == 'c'))\n\t\t\t\tb = total_data_written - initial_data_written;\n\t\t\telse\n\t\t\t\tb = total_data_read - initial_data_read;\n\t\t\tstrlcat(fmt, \"s\", sizeof fmt);\n\t\t\tsnprintf(buf2, sizeof buf2, fmt,\n\t\t\t\t do_big_num(b, humanize, NULL));\n\t\t\tn = buf2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tn = NULL;\n\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\tif (always_checksum)\n\t\t\t\t\tn = sum_as_hex(file_sum_nni->num, F_SUM(file), 1);\n\t\t\t\telse if (iflags & ITEM_TRANSFER)\n\t\t\t\t\tn = sum_as_hex(xfer_sum_nni->num, sender_file_sum, 0);\n\t\t\t}\n\t\t\tif (!n) {\n\t\t\t\tint sum_len = csum_len_for_type(always_checksum ? file_sum_nni->num : xfer_sum_nni->num,\n\t\t\t\t\t\t\t\talways_checksum);\n\t\t\t\tmemset(buf2, ' ', sum_len*2);\n\t\t\t\tbuf2[sum_len*2] = '\\0';\n\t\t\t\tn = buf2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (iflags & ITEM_DELETED) {\n\t\t\t\tn = \"*deleting  \";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn  = c = buf2 + MAXPATHLEN - 32;\n\t\t\tc[0] = iflags & ITEM_LOCAL_CHANGE\n\t\t\t     ? iflags & ITEM_XNAME_FOLLOWS ? 'h' : 'c'\n\t\t\t     : !(iflags & ITEM_TRANSFER) ? '.'\n\t\t\t     : !local_server && *op == 's' ? '<' : '>';\n\t\t\tif (S_ISLNK(file->mode)) {\n\t\t\t\tc[1] = 'L';\n\t\t\t\tc[3] = '.';\n\t\t\t\tc[4] = !(iflags & ITEM_REPORT_TIME) ? '.'\n\t\t\t\t     : !preserve_mtimes || !receiver_symlink_times\n\t\t\t\t    || (iflags & ITEM_REPORT_TIMEFAIL) ? 'T' : 't';\n\t\t\t} else {\n\t\t\t\tc[1] = S_ISDIR(file->mode) ? 'd'\n\t\t\t\t     : IS_SPECIAL(file->mode) ? 'S'\n\t\t\t\t     : IS_DEVICE(file->mode) ? 'D' : 'f';\n\t\t\t\tc[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';\n\t\t\t\tc[4] = !(iflags & ITEM_REPORT_TIME) ? '.'\n\t\t\t\t     : !preserve_mtimes ? 'T' : 't';\n\t\t\t}\n\t\t\tc[2] = !(iflags & ITEM_REPORT_CHANGE) ? '.' : 'c';\n\t\t\tc[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';\n\t\t\tc[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';\n\t\t\tc[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';\n\t\t\tc[8] = !(iflags & (ITEM_REPORT_ATIME|ITEM_REPORT_CRTIME)) ? '.'\n\t\t\t     : BITS_SET(iflags, ITEM_REPORT_ATIME|ITEM_REPORT_CRTIME) ? 'b'\n\t\t\t     : iflags & ITEM_REPORT_ATIME ? 'u' : 'n';\n\t\t\tc[9] = !(iflags & ITEM_REPORT_ACL) ? '.' : 'a';\n\t\t\tc[10] = !(iflags & ITEM_REPORT_XATTR) ? '.' : 'x';\n\t\t\tc[11] = '\\0';\n\n\t\t\tif (iflags & (ITEM_IS_NEW|ITEM_MISSING_DATA)) {\n\t\t\t\tchar ch = iflags & ITEM_IS_NEW ? '+' : '?';\n\t\t\t\tint i;\n\t\t\t\tfor (i = 2; c[i]; i++)\n\t\t\t\t\tc[i] = ch;\n\t\t\t} else if (c[0] == '.' || c[0] == 'h' || c[0] == 'c') {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 2; c[i]; i++) {\n\t\t\t\t\tif (c[i] != '.')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c[i]) {\n\t\t\t\t\tfor (i = 2; c[i]; i++)\n\t\t\t\t\t\tc[i] = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* \"n\" is the string to be inserted in place of this % code. */\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tif (n != buf2 && fmt[1]) {\n\t\t\tstrlcat(fmt, \"s\", sizeof fmt);\n\t\t\tsnprintf(buf2, sizeof buf2, fmt, n);\n\t\t\tn = buf2;\n\t\t}\n\t\tlen = strlen(n);\n\n\t\t/* Subtract the length of the escape from the string's size. */\n\t\ttotal -= p - s + 1;\n\n\t\tif (len + total >= (size_t)sizeof buf) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"buffer overflow expanding %%%c -- exiting\\n\",\n\t\t\t\tp[0]);\n\t\t\texit_cleanup(RERR_MESSAGEIO);\n\t\t}\n\n\t\t/* Shuffle the rest of the string along to make space for n */\n\t\tif (len != (size_t)(p - s + 1))\n\t\t\tmemmove(s + len, p + 1, total - (s - buf) + 1);\n\t\ttotal += len;\n\n\t\t/* Insert the contents of string \"n\", but NOT its null. */\n\t\tif (len)\n\t\t\tmemcpy(s, n, len);\n\n\t\t/* Skip over inserted string; continue looking */\n\t\tp = s + len;\n\t}\n\n\trwrite(code, buf, total, 0);\n}\n\n/* Return 1 if the format escape is in the log-format string (e.g. look for\n * the 'b' in the \"%9b\" format escape). */\nint log_format_has(const char *format, char esc)\n{\n\tconst char *p;\n\n\tif (!format)\n\t\treturn 0;\n\n\tfor (p = format; (p = strchr(p, '%')) != NULL; ) {\n\t\tfor (p++; *p == '\\''; p++) {} /*SHARED ITERATOR*/\n\t\tif (*p == '-')\n\t\t\tp++;\n\t\twhile (isDigit(p))\n\t\t\tp++;\n\t\twhile (*p == '\\'') p++;\n\t\tif (!*p)\n\t\t\tbreak;\n\t\tif (*p == esc)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Log the transfer of a file.  If the code is FCLIENT, the output just goes\n * to stdout.  If it is FLOG, it just goes to the log file.  Otherwise we\n * output to both. */\nvoid log_item(enum logcode code, struct file_struct *file, int iflags, const char *hlink)\n{\n\tconst char *s_or_r = am_sender ? \"send\" : \"recv\";\n\n\tif (code != FLOG && stdout_format && !am_server)\n\t\tlog_formatted(FCLIENT, stdout_format, s_or_r, file, NULL, iflags, hlink);\n\tif (code != FCLIENT && logfile_format && *logfile_format)\n\t\tlog_formatted(FLOG, logfile_format, s_or_r, file, NULL, iflags, hlink);\n}\n\nvoid maybe_log_item(struct file_struct *file, int iflags, int itemizing, const char *buf)\n{\n\tint significant_flags = iflags & SIGNIFICANT_ITEM_FLAGS;\n\tint see_item = itemizing && (significant_flags || *buf\n\t\t|| stdout_format_has_i > 1 || (INFO_GTE(NAME, 2) && stdout_format_has_i));\n\tint local_change = iflags & ITEM_LOCAL_CHANGE && significant_flags;\n\tif (am_server) {\n\t\tif (logfile_name && !dry_run && see_item\n\t\t && (significant_flags || logfile_format_has_i))\n\t\t\tlog_item(FLOG, file, iflags, buf);\n\t} else if (see_item || local_change || *buf\n\t    || (S_ISDIR(file->mode) && significant_flags)) {\n\t\tenum logcode code = significant_flags || logfile_format_has_i ? FINFO : FCLIENT;\n\t\tlog_item(code, file, iflags, buf);\n\t}\n}\n\nvoid log_delete(const char *fname, int mode)\n{\n\tstatic struct file_struct *file = NULL;\n\tint len = strlen(fname);\n\tconst char *fmt;\n\n\tif (!file) {\n\t\tint extra_len = (file_extra_cnt + 2) * EXTRA_LEN;\n\t\tchar *bp;\n#if EXTRA_ROUNDING > 0\n\t\tif (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))\n\t\t\textra_len = (extra_len | (EXTRA_ROUNDING * EXTRA_LEN)) + EXTRA_LEN;\n#endif\n\n\t\tbp = new_array0(char, FILE_STRUCT_LEN + extra_len + 1);\n\t\tbp += extra_len;\n\t\tfile = (struct file_struct *)bp;\n\t}\n\n\tfile->mode = mode;\n\n\tif (am_server && protocol_version >= 29 && len < MAXPATHLEN) {\n\t\tif (S_ISDIR(mode))\n\t\t\tlen++; /* directories include trailing null */\n\t\tsend_msg(MSG_DELETED, fname, len, am_generator);\n\t} else if (!INFO_GTE(DEL, 1) && !stdout_format)\n\t\t;\n\telse {\n\t\tfmt = stdout_format_has_o_or_i ? stdout_format : \"deleting %n\";\n\t\tlog_formatted(FCLIENT, fmt, \"del.\", file, fname, ITEM_DELETED, NULL);\n\t}\n\n\tif (!logfile_name || dry_run || !logfile_format)\n\t\treturn;\n\n\tfmt = logfile_format_has_o_or_i ? logfile_format : \"deleting %n\";\n\tlog_formatted(FLOG, fmt, \"del.\", file, fname, ITEM_DELETED, NULL);\n}\n\n/*\n * Called when the transfer is interrupted for some reason.\n *\n * Code is one of the RERR_* codes from errcode.h, or terminating\n * successfully.\n */\nvoid log_exit(int code, const char *file, int line)\n{\n\t/* The receiving side's stats are split between 2 procs until the\n\t * end of the run, so only the sender can output non-final info. */\n\tif (code == 0 || am_sender) {\n\t\trprintf(FLOG,\"sent %s bytes  received %s bytes  total size %s\\n\",\n\t\t\tbig_num(stats.total_written),\n\t\t\tbig_num(stats.total_read),\n\t\t\tbig_num(stats.total_size));\n\t}\n\tif (code != 0 && am_server != 2) {\n\t\tconst char *name;\n\n\t\tname = rerr_name(code);\n\t\tif (!name)\n\t\t\tname = \"unexplained error\";\n\n\t\t/* VANISHED is not an error, only a warning */\n\t\tif (code == RERR_VANISHED) {\n\t\t\trprintf(FWARNING, \"rsync warning: %s (code %d) at %s(%d) [%s=%s]\\n\",\n\t\t\t\tname, code, src_file(file), line, who_am_i(), rsync_version());\n\t\t} else {\n\t\t\trprintf(FERROR, \"rsync error: %s (code %d) at %s(%d) [%s=%s]\\n\",\n\t\t\t\tname, code, src_file(file), line, who_am_i(), rsync_version());\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "m4",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 49.6728515625,
          "content": "/*\n * The startup routines, including main(), for rsync.\n *\n * Copyright (C) 1996-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n#include \"ifuncs.h\"\n#include \"io.h\"\n#if defined CONFIG_LOCALE && defined HAVE_LOCALE_H\n#include <locale.h>\n#endif\n#include <popt.h>\n#ifdef __TANDEM\n#include <floss.h(floss_execlp)>\n#endif\n\nextern int dry_run;\nextern int list_only;\nextern int io_timeout;\nextern int am_root;\nextern int am_server;\nextern int am_sender;\nextern int am_daemon;\nextern int inc_recurse;\nextern int blocking_io;\nextern int always_checksum;\nextern int remove_source_files;\nextern int output_needs_newline;\nextern int called_from_signal_handler;\nextern int need_messages_from_generator;\nextern int kluge_around_eof;\nextern int got_xfer_error;\nextern int old_style_args;\nextern int msgs2stderr;\nextern int module_id;\nextern int read_only;\nextern int copy_links;\nextern int copy_dirlinks;\nextern int copy_unsafe_links;\nextern int keep_dirlinks;\nextern int preserve_hard_links;\nextern int protocol_version;\nextern int mkpath_dest_arg;\nextern int file_total;\nextern int recurse;\nextern int xfer_dirs;\nextern int protect_args;\nextern int relative_paths;\nextern int sanitize_paths;\nextern int curr_dir_depth;\nextern unsigned int curr_dir_len;\nextern int module_id;\nextern int rsync_port;\nextern int whole_file;\nextern int read_batch;\nextern int write_batch;\nextern int batch_fd;\nextern int sock_f_in;\nextern int sock_f_out;\nextern int filesfrom_fd;\nextern int connect_timeout;\nextern int send_msgs_to_gen;\nextern dev_t filesystem_dev;\nextern pid_t cleanup_child_pid;\nextern size_t bwlimit_writemax;\nextern unsigned int module_dirlen;\nextern BOOL flist_receiving_enabled;\nextern BOOL want_progress_now;\nextern BOOL shutting_down;\nextern int backup_dir_len;\nextern int basis_dir_cnt;\nextern int default_af_hint;\nextern int stdout_format_has_i;\nextern int trust_sender_filter;\nextern int trust_sender_args;\nextern struct stats stats;\nextern char *stdout_format;\nextern char *logfile_format;\nextern char *filesfrom_host;\nextern char *partial_dir;\nextern char *rsync_path;\nextern char *shell_cmd;\nextern char *password_file;\nextern char *backup_dir;\nextern char *copy_as;\nextern char *tmpdir;\nextern char curr_dir[MAXPATHLEN];\nextern char backup_dir_buf[MAXPATHLEN];\nextern char *basis_dir[MAX_BASIS_DIRS+1];\nextern struct file_list *first_flist;\nextern filter_rule_list daemon_filter_list, implied_filter_list;\n\nuid_t our_uid;\ngid_t our_gid;\nint am_receiver = 0;  /* Only set to 1 after the receiver/generator fork. */\nint am_generator = 0; /* Only set to 1 after the receiver/generator fork. */\nint local_server = 0;\nint daemon_connection = 0; /* 0 = no daemon, 1 = daemon via remote shell, -1 = daemon via socket */\nmode_t orig_umask = 0;\nint batch_gen_fd = -1;\nint sender_keeps_checksum = 0;\nint raw_argc, cooked_argc;\nchar **raw_argv, **cooked_argv;\n\n/* There's probably never more than at most 2 outstanding child processes,\n * but set it higher, just in case. */\n#define MAXCHILDPROCS 7\n\n#ifdef HAVE_SIGACTION\n# ifdef HAVE_SIGPROCMASK\n#  define SIGACTMASK(n,h) SIGACTION(n,h), sigaddset(&sigmask,(n))\n# else\n#  define SIGACTMASK(n,h) SIGACTION(n,h)\n# endif\nstatic struct sigaction sigact;\n#endif\n\nstruct pid_status {\n\tpid_t pid;\n\tint status;\n} pid_stat_table[MAXCHILDPROCS];\n\nstatic time_t starttime, endtime;\nstatic int64 total_read, total_written;\n\nstatic void show_malloc_stats(void);\n\n/* Works like waitpid(), but if we already harvested the child pid in our\n * remember_children(), we succeed instead of returning an error. */\npid_t wait_process(pid_t pid, int *status_ptr, int flags)\n{\n\tpid_t waited_pid;\n\n\tdo {\n\t\twaited_pid = waitpid(pid, status_ptr, flags);\n\t} while (waited_pid == -1 && errno == EINTR);\n\n\tif (waited_pid == -1 && errno == ECHILD) {\n\t\t/* Status of requested child no longer available:  check to\n\t\t * see if it was processed by remember_children(). */\n\t\tint cnt;\n\t\tfor (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {\n\t\t\tif (pid == pid_stat_table[cnt].pid) {\n\t\t\t\t*status_ptr = pid_stat_table[cnt].status;\n\t\t\t\tpid_stat_table[cnt].pid = 0;\n\t\t\t\treturn pid;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn waited_pid;\n}\n\nint shell_exec(const char *cmd)\n{\n\tchar *shell = getenv(\"RSYNC_SHELL\");\n\tint status;\n\tpid_t pid;\n\n\tif (!shell)\n\t\treturn system(cmd);\n\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\n\tif (pid == 0) {\n\t\texeclp(shell, shell, \"-c\", cmd, NULL);\n\t\t_exit(1);\n\t}\n\n\tint ret = wait_process(pid, &status, 0);\n\treturn ret < 0 ? -1 : status;\n}\n\n/* Wait for a process to exit, calling io_flush while waiting. */\nstatic void wait_process_with_flush(pid_t pid, int *exit_code_ptr)\n{\n\tpid_t waited_pid;\n\tint status;\n\n\twhile ((waited_pid = wait_process(pid, &status, WNOHANG)) == 0) {\n\t\tmsleep(20);\n\t\tio_flush(FULL_FLUSH);\n\t}\n\n\t/* TODO: If the child exited on a signal, then log an\n\t * appropriate error message.  Perhaps we should also accept a\n\t * message describing the purpose of the child.  Also indicate\n\t * this to the caller so that they know something went wrong. */\n\tif (waited_pid < 0) {\n\t\trsyserr(FERROR, errno, \"waitpid\");\n\t\t*exit_code_ptr = RERR_WAITCHILD;\n\t} else if (!WIFEXITED(status)) {\n#ifdef WCOREDUMP\n\t\tif (WCOREDUMP(status))\n\t\t\t*exit_code_ptr = RERR_CRASHED;\n\t\telse\n#endif\n\t\tif (WIFSIGNALED(status))\n\t\t\t*exit_code_ptr = RERR_TERMINATED;\n\t\telse\n\t\t\t*exit_code_ptr = RERR_WAITCHILD;\n\t} else\n\t\t*exit_code_ptr = WEXITSTATUS(status);\n}\n\nvoid write_del_stats(int f)\n{\n\tif (read_batch)\n\t\twrite_int(f, NDX_DEL_STATS);\n\telse\n\t\twrite_ndx(f, NDX_DEL_STATS);\n\twrite_varint(f, stats.deleted_files - stats.deleted_dirs\n\t\t      - stats.deleted_symlinks - stats.deleted_devices\n\t\t      - stats.deleted_specials);\n\twrite_varint(f, stats.deleted_dirs);\n\twrite_varint(f, stats.deleted_symlinks);\n\twrite_varint(f, stats.deleted_devices);\n\twrite_varint(f, stats.deleted_specials);\n}\n\nvoid read_del_stats(int f)\n{\n\tstats.deleted_files = read_varint(f);\n\tstats.deleted_files += stats.deleted_dirs = read_varint(f);\n\tstats.deleted_files += stats.deleted_symlinks = read_varint(f);\n\tstats.deleted_files += stats.deleted_devices = read_varint(f);\n\tstats.deleted_files += stats.deleted_specials = read_varint(f);\n}\n\nstatic void become_copy_as_user()\n{\n\tchar *gname;\n\tuid_t uid;\n\tgid_t gid;\n\n\tif (!copy_as)\n\t\treturn;\n\n\tif (DEBUG_GTE(CMD, 2))\n\t\trprintf(FINFO, \"[%s] copy_as=%s\\n\", who_am_i(), copy_as);\n\n\tif ((gname = strchr(copy_as, ':')) != NULL)\n\t\t*gname++ = '\\0';\n\n\tif (!user_to_uid(copy_as, &uid, True)) {\n\t\trprintf(FERROR, \"Invalid copy-as user: %s\\n\", copy_as);\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\tif (gname) {\n\t\tif (!group_to_gid(gname, &gid, True)) {\n\t\t\trprintf(FERROR, \"Invalid copy-as group: %s\\n\", gname);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t} else {\n\t\tstruct passwd *pw;\n\t\tif ((pw = getpwuid(uid)) == NULL) {\n\t\t\trsyserr(FERROR, errno, \"getpwuid failed\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tgid = pw->pw_gid;\n\t}\n\n\tif (setgid(gid) < 0) {\n\t\trsyserr(FERROR, errno, \"setgid failed\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n#ifdef HAVE_SETGROUPS\n\tif (setgroups(1, &gid)) {\n\t\trsyserr(FERROR, errno, \"setgroups failed\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n#endif\n#ifdef HAVE_INITGROUPS\n\tif (!gname && initgroups(copy_as, gid) < 0) {\n\t\trsyserr(FERROR, errno, \"initgroups failed\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n#endif\n\n\tif (setuid(uid) < 0\n#ifdef HAVE_SETEUID\n\t || seteuid(uid) < 0\n#endif\n\t) {\n\t\trsyserr(FERROR, errno, \"setuid failed\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\tour_uid = MY_UID();\n\tour_gid = MY_GID();\n\tam_root = (our_uid == ROOT_UID);\n\n\tif (gname)\n\t\tgname[-1] = ':';\n}\n\n/* This function gets called from all 3 processes.  We want the client side\n * to actually output the text, but the sender is the only process that has\n * all the stats we need.  So, if we're a client sender, we do the report.\n * If we're a server sender, we write the stats on the supplied fd.  If\n * we're the client receiver we read the stats from the supplied fd and do\n * the report.  All processes might also generate a set of debug stats, if\n * the verbose level is high enough (this is the only thing that the\n * generator process and the server receiver ever do here). */\nstatic void handle_stats(int f)\n{\n\tendtime = time(NULL);\n\n\t/* Cache two stats because the read/write code can change it. */\n\ttotal_read = stats.total_read;\n\ttotal_written = stats.total_written;\n\n\tif (INFO_GTE(STATS, 3)) {\n\t\t/* These come out from every process */\n\t\tshow_malloc_stats();\n\t\tshow_flist_stats();\n\t}\n\n\tif (am_generator)\n\t\treturn;\n\n\tif (am_daemon) {\n\t\tif (f == -1 || !am_sender)\n\t\t\treturn;\n\t}\n\n\tif (am_server) {\n\t\tif (am_sender) {\n\t\t\twrite_varlong30(f, total_read, 3);\n\t\t\twrite_varlong30(f, total_written, 3);\n\t\t\twrite_varlong30(f, stats.total_size, 3);\n\t\t\tif (protocol_version >= 29) {\n\t\t\t\twrite_varlong30(f, stats.flist_buildtime, 3);\n\t\t\t\twrite_varlong30(f, stats.flist_xfertime, 3);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t/* this is the client */\n\n\tif (f < 0 && !am_sender) /* e.g. when we got an empty file list. */\n\t\t;\n\telse if (!am_sender) {\n\t\t/* Read the first two in opposite order because the meaning of\n\t\t * read/write swaps when switching from sender to receiver. */\n\t\ttotal_written = read_varlong30(f, 3);\n\t\ttotal_read = read_varlong30(f, 3);\n\t\tstats.total_size = read_varlong30(f, 3);\n\t\tif (protocol_version >= 29) {\n\t\t\tstats.flist_buildtime = read_varlong30(f, 3);\n\t\t\tstats.flist_xfertime = read_varlong30(f, 3);\n\t\t}\n\t} else if (write_batch) {\n\t\t/* The --read-batch process is going to be a client\n\t\t * receiver, so we need to give it the stats. */\n\t\twrite_varlong30(batch_fd, total_read, 3);\n\t\twrite_varlong30(batch_fd, total_written, 3);\n\t\twrite_varlong30(batch_fd, stats.total_size, 3);\n\t\tif (protocol_version >= 29) {\n\t\t\twrite_varlong30(batch_fd, stats.flist_buildtime, 3);\n\t\t\twrite_varlong30(batch_fd, stats.flist_xfertime, 3);\n\t\t}\n\t}\n}\n\nstatic void output_itemized_counts(const char *prefix, int *counts)\n{\n\tstatic char *labels[] = { \"reg\", \"dir\", \"link\", \"dev\", \"special\" };\n\tchar buf[1024], *pre = \" (\";\n\tint j, len = 0;\n\tint total = counts[0];\n\tif (total) {\n\t\tcounts[0] -= counts[1] + counts[2] + counts[3] + counts[4];\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tif (counts[j]) {\n\t\t\t\tlen += snprintf(buf+len, sizeof buf - len - 2,\n\t\t\t\t\t\"%s%s: %s\",\n\t\t\t\t\tpre, labels[j], comma_num(counts[j]));\n\t\t\t\tpre = \", \";\n\t\t\t}\n\t\t}\n\t\tbuf[len++] = ')';\n\t}\n\tbuf[len] = '\\0';\n\trprintf(FINFO, \"%s: %s%s\\n\", prefix, comma_num(total), buf);\n}\n\nstatic const char *bytes_per_sec_human_dnum(void)\n{\n\tif (starttime == (time_t)-1 || endtime == (time_t)-1)\n\t\treturn \"UNKNOWN\";\n\treturn human_dnum((total_written + total_read) / (0.5 + (endtime - starttime)), 2);\n}\n\nstatic void output_summary(void)\n{\n\tif (INFO_GTE(STATS, 2)) {\n\t\trprintf(FCLIENT, \"\\n\");\n\t\toutput_itemized_counts(\"Number of files\", &stats.num_files);\n\t\tif (protocol_version >= 29)\n\t\t\toutput_itemized_counts(\"Number of created files\", &stats.created_files);\n\t\tif (protocol_version >= 31)\n\t\t\toutput_itemized_counts(\"Number of deleted files\", &stats.deleted_files);\n\t\trprintf(FINFO,\"Number of regular files transferred: %s\\n\",\n\t\t\tcomma_num(stats.xferred_files));\n\t\trprintf(FINFO,\"Total file size: %s bytes\\n\",\n\t\t\thuman_num(stats.total_size));\n\t\trprintf(FINFO,\"Total transferred file size: %s bytes\\n\",\n\t\t\thuman_num(stats.total_transferred_size));\n\t\trprintf(FINFO,\"Literal data: %s bytes\\n\",\n\t\t\thuman_num(stats.literal_data));\n\t\trprintf(FINFO,\"Matched data: %s bytes\\n\",\n\t\t\thuman_num(stats.matched_data));\n\t\trprintf(FINFO,\"File list size: %s\\n\",\n\t\t\thuman_num(stats.flist_size));\n\t\tif (stats.flist_buildtime) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"File list generation time: %s seconds\\n\",\n\t\t\t\tcomma_dnum((double)stats.flist_buildtime / 1000, 3));\n\t\t\trprintf(FINFO,\n\t\t\t\t\"File list transfer time: %s seconds\\n\",\n\t\t\t\tcomma_dnum((double)stats.flist_xfertime / 1000, 3));\n\t\t}\n\t\trprintf(FINFO,\"Total bytes sent: %s\\n\",\n\t\t\thuman_num(total_written));\n\t\trprintf(FINFO,\"Total bytes received: %s\\n\",\n\t\t\thuman_num(total_read));\n\t}\n\n\tif (INFO_GTE(STATS, 1)) {\n\t\trprintf(FCLIENT, \"\\n\");\n\t\trprintf(FINFO,\n\t\t\t\"sent %s bytes  received %s bytes  %s bytes/sec\\n\",\n\t\t\thuman_num(total_written), human_num(total_read),\n\t\t\tbytes_per_sec_human_dnum());\n\t\trprintf(FINFO, \"total size is %s  speedup is %s%s\\n\",\n\t\t\thuman_num(stats.total_size),\n\t\t\tcomma_dnum((double)stats.total_size / (total_written+total_read), 2),\n\t\t\twrite_batch < 0 ? \" (BATCH ONLY)\" : dry_run ? \" (DRY RUN)\" : \"\");\n\t}\n\n\tfflush(stdout);\n\tfflush(stderr);\n}\n\n\n/**\n * If our C library can get malloc statistics, then show them to FINFO\n **/\nstatic void show_malloc_stats(void)\n{\n#ifdef MEM_ALLOC_INFO\n\tstruct MEM_ALLOC_INFO mi = MEM_ALLOC_INFO(); /* mallinfo or mallinfo2 */\n\n\trprintf(FCLIENT, \"\\n\");\n\trprintf(FINFO, RSYNC_NAME \"[%d] (%s%s%s) heap statistics:\\n\",\n\t\t(int)getpid(), am_server ? \"server \" : \"\",\n\t\tam_daemon ? \"daemon \" : \"\", who_am_i());\n\n#define PRINT_ALLOC_NUM(title, descr, num) \\\n\trprintf(FINFO, \"  %-11s%10\" SIZE_T_FMT_MOD \"d   (\" descr \")\\n\", \\\n\t\ttitle \":\", (SIZE_T_FMT_CAST)(num));\n\n\tPRINT_ALLOC_NUM(\"arena\", \"bytes from sbrk\", mi.arena);\n\tPRINT_ALLOC_NUM(\"ordblks\", \"chunks not in use\", mi.ordblks);\n\tPRINT_ALLOC_NUM(\"smblks\", \"free fastbin blocks\", mi.smblks);\n\tPRINT_ALLOC_NUM(\"hblks\", \"chunks from mmap\", mi.hblks);\n\tPRINT_ALLOC_NUM(\"hblkhd\", \"bytes from mmap\", mi.hblkhd);\n\tPRINT_ALLOC_NUM(\"allmem\", \"bytes from sbrk + mmap\", mi.arena + mi.hblkhd);\n\tPRINT_ALLOC_NUM(\"usmblks\", \"always 0\", mi.usmblks);\n\tPRINT_ALLOC_NUM(\"fsmblks\", \"bytes in freed fastbin blocks\", mi.fsmblks);\n\tPRINT_ALLOC_NUM(\"uordblks\", \"bytes used\", mi.uordblks);\n\tPRINT_ALLOC_NUM(\"fordblks\", \"bytes free\", mi.fordblks);\n\tPRINT_ALLOC_NUM(\"keepcost\", \"bytes in releasable chunk\", mi.keepcost);\n\n#undef PRINT_ALLOC_NUM\n\n#endif /* MEM_ALLOC_INFO */\n}\n\n\n/* Start the remote shell.   cmd may be NULL to use the default. */\nstatic pid_t do_cmd(char *cmd, char *machine, char *user, char **remote_argv, int remote_argc,\n\t\t    int *f_in_p, int *f_out_p)\n{\n\tint i, argc = 0;\n\tchar *args[MAX_ARGS], *need_to_free = NULL;\n\tpid_t pid;\n\tint dash_l_set = 0;\n\n\tif (!read_batch && !local_server) {\n\t\tchar *t, *f, in_quote = '\\0';\n\t\tchar *rsh_env = getenv(RSYNC_RSH_ENV);\n\t\tif (!cmd)\n\t\t\tcmd = rsh_env;\n\t\tif (!cmd)\n\t\t\tcmd = RSYNC_RSH;\n\t\tcmd = need_to_free = strdup(cmd);\n\n\t\tfor (t = f = cmd; *f; f++) {\n\t\t\tif (*f == ' ')\n\t\t\t\tcontinue;\n\t\t\t/* Comparison leaves rooms for server_options(). */\n\t\t\tif (argc >= MAX_ARGS - MAX_SERVER_ARGS)\n\t\t\t\tgoto arg_overflow;\n\t\t\targs[argc++] = t;\n\t\t\twhile (*f != ' ' || in_quote) {\n\t\t\t\tif (!*f) {\n\t\t\t\t\tif (in_quote) {\n\t\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\t\"Missing trailing-%c in remote-shell command.\\n\",\n\t\t\t\t\t\t\tin_quote);\n\t\t\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t\t\t}\n\t\t\t\t\tf--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*f == '\\'' || *f == '\"') {\n\t\t\t\t\tif (!in_quote) {\n\t\t\t\t\t\tin_quote = *f++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*f == in_quote && *++f != in_quote) {\n\t\t\t\t\t\tin_quote = '\\0';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*t++ = *f++;\n\t\t\t}\n\t\t\t*t++ = '\\0';\n\t\t}\n\n\t\t/* NOTE: must preserve t == start of command name until the end of the args handling! */\n\t\tif ((t = strrchr(cmd, '/')) != NULL)\n\t\t\tt++;\n\t\telse\n\t\t\tt = cmd;\n\n\t\t/* Check to see if we've already been given '-l user' in the remote-shell command. */\n\t\tfor (i = 0; i < argc-1; i++) {\n\t\t\tif (!strcmp(args[i], \"-l\") && args[i+1][0] != '-')\n\t\t\t\tdash_l_set = 1;\n\t\t}\n\n#ifdef HAVE_REMSH\n\t\t/* remsh (on HPUX) takes the arguments the other way around */\n\t\targs[argc++] = machine;\n\t\tif (user && !(daemon_connection && dash_l_set)) {\n\t\t\targs[argc++] = \"-l\";\n\t\t\targs[argc++] = user;\n\t\t}\n#else\n\t\tif (user && !(daemon_connection && dash_l_set)) {\n\t\t\targs[argc++] = \"-l\";\n\t\t\targs[argc++] = user;\n\t\t}\n#ifdef AF_INET\n\t\tif (default_af_hint == AF_INET && strcmp(t, \"ssh\") == 0)\n\t\t\targs[argc++] = \"-4\"; /* we're using ssh so we can add a -4 option */\n#endif\n#ifdef AF_INET6\n\t\tif (default_af_hint == AF_INET6 && strcmp(t, \"ssh\") == 0)\n\t\t\targs[argc++] = \"-6\"; /* we're using ssh so we can add a -6 option */\n#endif\n\t\targs[argc++] = machine;\n#endif\n\n\t\targs[argc++] = rsync_path;\n\n\t\tif (blocking_io < 0 && (strcmp(t, \"rsh\") == 0 || strcmp(t, \"remsh\") == 0))\n\t\t\tblocking_io = 1;\n\n\t\tif (daemon_connection > 0) {\n\t\t\targs[argc++] = \"--server\";\n\t\t\targs[argc++] = \"--daemon\";\n\t\t} else\n\t\t\tserver_options(args, &argc);\n\n\t\tif (argc >= MAX_ARGS - 2)\n\t\t\tgoto arg_overflow;\n\t}\n\n\targs[argc++] = \".\";\n\n\tif (!daemon_connection) {\n\t\twhile (remote_argc > 0) {\n\t\t\tif (argc >= MAX_ARGS - 1) {\n\t\t\t  arg_overflow:\n\t\t\t\trprintf(FERROR, \"internal: args[] overflowed in do_cmd()\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\targs[argc++] = safe_arg(NULL, *remote_argv++);\n\t\t\tremote_argc--;\n\t\t}\n\t}\n\n\targs[argc] = NULL;\n\n\tif (DEBUG_GTE(CMD, 2)) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\trprintf(FCLIENT, \"cmd[%d]=%s \", i, args[i]);\n\t\trprintf(FCLIENT, \"\\n\");\n\t}\n\n\tif (read_batch) {\n\t\tint from_gen_pipe[2];\n\t\tset_allow_inc_recurse();\n\t\tif (fd_pair(from_gen_pipe) < 0) {\n\t\t\trsyserr(FERROR, errno, \"pipe\");\n\t\t\texit_cleanup(RERR_IPC);\n\t\t}\n\t\tbatch_gen_fd = from_gen_pipe[0];\n\t\t*f_out_p = from_gen_pipe[1];\n\t\t*f_in_p = batch_fd;\n\t\tpid = (pid_t)-1; /* no child pid */\n#ifdef ICONV_CONST\n\t\tsetup_iconv();\n#endif\n\t} else if (local_server) {\n\t\t/* If the user didn't request --[no-]whole-file, force\n\t\t * it on, but only if we're not batch processing. */\n\t\tif (whole_file < 0 && !write_batch)\n\t\t\twhole_file = 1;\n\t\tset_allow_inc_recurse();\n\t\tpid = local_child(argc, args, f_in_p, f_out_p, child_main);\n#ifdef ICONV_CONST\n\t\tsetup_iconv();\n#endif\n\t} else {\n\t\tpid = piped_child(args, f_in_p, f_out_p);\n#ifdef ICONV_CONST\n\t\tsetup_iconv();\n#endif\n\t\tif (protect_args && !daemon_connection)\n\t\t\tsend_protected_args(*f_out_p, args);\n\t}\n\n\tif (need_to_free)\n\t\tfree(need_to_free);\n\n\treturn pid;\n}\n\n/* Older versions turn an empty string as a reference to the current directory.\n * We now treat this as an error unless --old-args was used. */\nstatic char *dot_dir_or_error()\n{\n\tif (old_style_args || am_server)\n\t\treturn \".\";\n\trprintf(FERROR, \"Empty destination arg specified (use \\\".\\\" or see --old-args).\\n\");\n\texit_cleanup(RERR_SYNTAX);\n}\n\n/* The receiving side operates in one of two modes:\n *\n * 1. it receives any number of files into a destination directory,\n * placing them according to their names in the file-list.\n *\n * 2. it receives a single file and saves it using the name in the\n * destination path instead of its file-list name.  This requires a\n * \"local name\" for writing out the destination file.\n *\n * So, our task is to figure out what mode/local-name we need.\n * For mode 1, we change into the destination directory and return NULL.\n * For mode 2, we change into the directory containing the destination\n * file (if we aren't already there) and return the local-name. */\nstatic char *get_local_name(struct file_list *flist, char *dest_path)\n{\n\tSTRUCT_STAT st;\n\tint statret, trailing_slash;\n\tchar *cp;\n\n\tif (DEBUG_GTE(RECV, 1)) {\n\t\trprintf(FINFO, \"get_local_name count=%d %s\\n\",\n\t\t\tfile_total, NS(dest_path));\n\t}\n\n\tif (!dest_path || list_only)\n\t\treturn NULL;\n\n\tif (!*dest_path)\n\t\tdest_path = dot_dir_or_error();\n\n\tif (daemon_filter_list.head) {\n\t\tchar *slash = strrchr(dest_path, '/');\n\t\tif (slash && (slash[1] == '\\0' || (slash[1] == '.' && slash[2] == '\\0')))\n\t\t\t*slash = '\\0';\n\t\telse\n\t\t\tslash = NULL;\n\t\tif ((*dest_path != '.' || dest_path[1] != '\\0')\n\t\t && (check_filter(&daemon_filter_list, FLOG, dest_path, 0) < 0\n\t\t  || check_filter(&daemon_filter_list, FLOG, dest_path, 1) < 0)) {\n\t\t\trprintf(FERROR, \"ERROR: daemon has excluded destination \\\"%s\\\"\\n\",\n\t\t\t\tdest_path);\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t\tif (slash)\n\t\t\t*slash = '/';\n\t}\n\n\t/* See what currently exists at the destination. */\n\tstatret = do_stat(dest_path, &st);\n\tcp = strrchr(dest_path, '/');\n\ttrailing_slash = cp && !cp[1];\n\n\tif (mkpath_dest_arg && statret < 0 && (cp || file_total > 1)) {\n\t\tint save_errno = errno;\n\t\tint ret = make_path(dest_path, file_total > 1 && !trailing_slash ? 0 : MKP_DROP_NAME);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\t\tif (ret && (INFO_GTE(NAME, 1) || stdout_format_has_i)) {\n\t\t\tif (file_total == 1 || trailing_slash)\n\t\t\t\t*cp = '\\0';\n\t\t\trprintf(FINFO, \"created %d director%s for %s\\n\", ret, ret == 1 ? \"y\" : \"ies\", dest_path);\n\t\t\tif (file_total == 1 || trailing_slash)\n\t\t\t\t*cp = '/';\n\t\t}\n\t\tif (ret)\n\t\t\tstatret = do_stat(dest_path, &st);\n\t\telse\n\t\t\terrno = save_errno;\n\t}\n\n\tif (statret == 0) {\n\t\t/* If the destination is a dir, enter it and use mode 1. */\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tif (!change_dir(dest_path, CD_NORMAL)) {\n\t\t\t\trsyserr(FERROR, errno, \"change_dir#1 %s failed\",\n\t\t\t\t\tfull_fname(dest_path));\n\t\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t\t}\n\t\t\tfilesystem_dev = st.st_dev; /* ensures --force works right w/-x */\n\t\t\treturn NULL;\n\t\t}\n\t\tif (file_total > 1) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"ERROR: destination must be a directory when\"\n\t\t\t\t\" copying more than 1 file\\n\");\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t\tif (file_total == 1 && S_ISDIR(flist->files[0]->mode)) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"ERROR: cannot overwrite non-directory\"\n\t\t\t\t\" with a directory\\n\");\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t} else if (errno != ENOENT) {\n\t\t/* If we don't know what's at the destination, fail. */\n\t\trsyserr(FERROR, errno, \"ERROR: cannot stat destination %s\",\n\t\t\tfull_fname(dest_path));\n\t\texit_cleanup(RERR_FILESELECT);\n\t}\n\n\t/* If we need a destination directory because the transfer is not\n\t * of a single non-directory or the user has requested one via a\n\t * destination path ending in a slash, create one and use mode 1. */\n\tif (file_total > 1 || trailing_slash) {\n\t\tif (trailing_slash)\n\t\t\t*cp = '\\0'; /* Lop off the final slash (if any). */\n\n\t\tif (statret == 0) {\n\t\t\trprintf(FERROR, \"ERROR: destination path is not a directory\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\n\t\tif (do_mkdir(dest_path, ACCESSPERMS) != 0) {\n\t\t    mkdir_error:\n\t\t\trsyserr(FERROR, errno, \"mkdir %s failed\",\n\t\t\t\tfull_fname(dest_path));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif (flist->high >= flist->low\n\t\t && strcmp(flist->files[flist->low]->basename, \".\") == 0)\n\t\t\tflist->files[0]->flags |= FLAG_DIR_CREATED;\n\n\t\tif (INFO_GTE(NAME, 1) || stdout_format_has_i)\n\t\t\trprintf(FINFO, \"created directory %s\\n\", dest_path);\n\n\t\tif (dry_run) {\n\t\t\t/* Indicate that dest dir doesn't really exist. */\n\t\t\tdry_run++;\n\t\t}\n\n\t\tif (!change_dir(dest_path, dry_run > 1 ? CD_SKIP_CHDIR : CD_NORMAL)) {\n\t\t\trsyserr(FERROR, errno, \"change_dir#2 %s failed\",\n\t\t\t\tfull_fname(dest_path));\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\t/* Otherwise, we are writing a single file, possibly on top of an\n\t * existing non-directory.  Change to the item's parent directory\n\t * (if it has a path component), return the basename of the\n\t * destination file as the local name, and use mode 2. */\n\tif (!cp)\n\t\treturn dest_path;\n\n\tif (cp == dest_path)\n\t\tdest_path = \"/\";\n\n\t*cp = '\\0';\n\tif (!change_dir(dest_path, CD_NORMAL)) {\n\t\trsyserr(FERROR, errno, \"change_dir#3 %s failed\",\n\t\t\tfull_fname(dest_path));\n\t\texit_cleanup(RERR_FILESELECT);\n\t}\n\t*cp = '/';\n\n\treturn cp + 1;\n}\n\n/* This function checks on our alternate-basis directories.  If we're in\n * dry-run mode and the destination dir does not yet exist, we'll try to\n * tweak any dest-relative paths to make them work for a dry-run (the\n * destination dir must be in curr_dir[] when this function is called).\n * We also warn about any arg that is non-existent or not a directory. */\nstatic void check_alt_basis_dirs(void)\n{\n\tSTRUCT_STAT st;\n\tchar *slash = strrchr(curr_dir, '/');\n\tint j;\n\n\tfor (j = 0; j < basis_dir_cnt; j++) {\n\t\tchar *bdir = basis_dir[j];\n\t\tint bd_len = strlen(bdir);\n\t\tif (bd_len > 1 && bdir[bd_len-1] == '/')\n\t\t\tbdir[--bd_len] = '\\0';\n\t\tif (dry_run > 1 && *bdir != '/') {\n\t\t\tint len = curr_dir_len + 1 + bd_len + 1;\n\t\t\tchar *new = new_array(char, len);\n\t\t\tif (slash && strncmp(bdir, \"../\", 3) == 0) {\n\t\t\t\t/* We want to remove only one leading \"../\" prefix for\n\t\t\t\t * the directory we couldn't create in dry-run mode:\n\t\t\t\t * this ensures that any other \"..\" references get\n\t\t\t\t * evaluated the same as they would for a live copy. */\n\t\t\t\t*slash = '\\0';\n\t\t\t\tpathjoin(new, len, curr_dir, bdir + 3);\n\t\t\t\t*slash = '/';\n\t\t\t} else\n\t\t\t\tpathjoin(new, len, curr_dir, bdir);\n\t\t\tbasis_dir[j] = bdir = new;\n\t\t}\n\t\tif (do_stat(bdir, &st) < 0)\n\t\t\trprintf(FWARNING, \"%s arg does not exist: %s\\n\", alt_dest_opt(0), bdir);\n\t\telse if (!S_ISDIR(st.st_mode))\n\t\t\trprintf(FWARNING, \"%s arg is not a dir: %s\\n\", alt_dest_opt(0), bdir);\n\t}\n}\n\n/* This is only called by the sender. */\nstatic void read_final_goodbye(int f_in, int f_out)\n{\n\tint i, iflags, xlen;\n\tuchar fnamecmp_type;\n\tchar xname[MAXPATHLEN];\n\n\tshutting_down = True;\n\n\tif (protocol_version < 29)\n\t\ti = read_int(f_in);\n\telse {\n\t\ti = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type, xname, &xlen);\n\t\tif (protocol_version >= 31 && i == NDX_DONE) {\n\t\t\tif (am_sender)\n\t\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t\telse {\n\t\t\t\tif (batch_gen_fd >= 0) {\n\t\t\t\t\twhile (read_int(batch_gen_fd) != NDX_DEL_STATS) {}\n\t\t\t\t\tread_del_stats(batch_gen_fd);\n\t\t\t\t}\n\t\t\t\twrite_int(f_out, NDX_DONE);\n\t\t\t}\n\t\t\ti = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type, xname, &xlen);\n\t\t}\n\t}\n\n\tif (i != NDX_DONE) {\n\t\trprintf(FERROR, \"Invalid packet at end of run (%d) [%s]\\n\",\n\t\t\ti, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n}\n\nstatic void do_server_sender(int f_in, int f_out, int argc, char *argv[])\n{\n\tstruct file_list *flist;\n\tchar *dir;\n\n\tif (DEBUG_GTE(SEND, 1))\n\t\trprintf(FINFO, \"server_sender starting pid=%d\\n\", (int)getpid());\n\n\tif (am_daemon && lp_write_only(module_id)) {\n\t\trprintf(FERROR, \"ERROR: module is write only\\n\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\tif (am_daemon && read_only && remove_source_files) {\n\t\trprintf(FERROR,\n\t\t\t\"ERROR: --remove-%s-files cannot be used with a read-only module\\n\",\n\t\t\tremove_source_files == 1 ? \"source\" : \"sent\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\tif (argc < 1) {\n\t\trprintf(FERROR, \"ERROR: do_server_sender called without args\\n\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\tbecome_copy_as_user();\n\n\tdir = argv[0];\n\tif (!relative_paths) {\n\t\tif (!change_dir(dir, CD_NORMAL)) {\n\t\t\trsyserr(FERROR, errno, \"change_dir#3 %s failed\",\n\t\t\t\tfull_fname(dir));\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t}\n\targc--;\n\targv++;\n\n\tif (argc == 0 && (recurse || xfer_dirs || list_only)) {\n\t\targc = 1;\n\t\targv--;\n\t\targv[0] = \".\";\n\t}\n\n\tflist = send_file_list(f_out,argc,argv);\n\tif (!flist || flist->used == 0) {\n\t\t/* Make sure input buffering is off so we can't hang in noop_io_until_death(). */\n\t\tio_end_buffering_in(0);\n\t\t/* TODO:  we should really exit in a more controlled manner. */\n\t\texit_cleanup(0);\n\t}\n\n\tio_start_buffering_in(f_in);\n\n\tsend_files(f_in, f_out);\n\tio_flush(FULL_FLUSH);\n\thandle_stats(f_out);\n\tif (protocol_version >= 24)\n\t\tread_final_goodbye(f_in, f_out);\n\tio_flush(FULL_FLUSH);\n\texit_cleanup(0);\n}\n\n\nstatic int do_recv(int f_in, int f_out, char *local_name)\n{\n\tint pid;\n\tint exit_code = 0;\n\tint error_pipe[2];\n\n\t/* The receiving side mustn't obey this, or an existing symlink that\n\t * points to an identical file won't be replaced by the referent. */\n\tcopy_links = copy_dirlinks = copy_unsafe_links = 0;\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && !inc_recurse)\n\t\tmatch_hard_links(first_flist);\n#endif\n\n\tif (fd_pair(error_pipe) < 0) {\n\t\trsyserr(FERROR, errno, \"pipe failed in do_recv\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tif (backup_dir) {\n\t\tSTRUCT_STAT st;\n\t\tint ret;\n\t\tif (backup_dir_len > 1)\n\t\t\tbackup_dir_buf[backup_dir_len-1] = '\\0';\n\t\tret = do_stat(backup_dir_buf, &st);\n\t\tif (ret != 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tif (ret == 0) {\n\t\t\t\trprintf(FERROR, \"The backup-dir is not a directory: %s\\n\", backup_dir_buf);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (errno != ENOENT) {\n\t\t\t\trprintf(FERROR, \"Failed to stat %s: %s\\n\", backup_dir_buf, strerror(errno));\n\t\t\t\texit_cleanup(RERR_FILEIO);\n\t\t\t}\n\t\t\tif (INFO_GTE(BACKUP, 1))\n\t\t\t\trprintf(FINFO, \"(new) backup_dir is %s\\n\", backup_dir_buf);\n\t\t} else if (INFO_GTE(BACKUP, 1))\n\t\t\trprintf(FINFO, \"backup_dir is %s\\n\", backup_dir_buf);\n\t\tif (backup_dir_len > 1)\n\t\t\tbackup_dir_buf[backup_dir_len-1] = '/';\n\t}\n\n\tif (tmpdir) {\n\t\tSTRUCT_STAT st;\n\t\tint ret = do_stat(tmpdir, &st);\n\t\tif (ret < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tif (ret == 0) {\n\t\t\t\trprintf(FERROR, \"The temp-dir is not a directory: %s\\n\", tmpdir);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (errno == ENOENT) {\n\t\t\t\trprintf(FERROR, \"The temp-dir does not exist: %s\\n\", tmpdir);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\trprintf(FERROR, \"Failed to stat temp-dir %s: %s\\n\", tmpdir, strerror(errno));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t}\n\n\tio_flush(FULL_FLUSH);\n\n\tif ((pid = do_fork()) == -1) {\n\t\trsyserr(FERROR, errno, \"fork failed in do_recv\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tif (pid == 0) {\n\t\tam_receiver = 1;\n\t\tsend_msgs_to_gen = am_server;\n\n\t\tclose(error_pipe[0]);\n\n\t\t/* We can't let two processes write to the socket at one time. */\n\t\tio_end_multiplex_out(MPLX_SWITCHING);\n\t\tif (f_in != f_out)\n\t\t\tclose(f_out);\n\t\tsock_f_out = -1;\n\t\tf_out = error_pipe[1];\n\n\t\tbwlimit_writemax = 0; /* receiver doesn't need to do this */\n\n\t\tif (read_batch)\n\t\t\tio_start_buffering_in(f_in);\n\t\tio_start_multiplex_out(f_out);\n\n\t\trecv_files(f_in, f_out, local_name);\n\t\tio_flush(FULL_FLUSH);\n\t\thandle_stats(f_in);\n\n\t\tif (output_needs_newline) {\n\t\t\tfputc('\\n', stdout);\n\t\t\toutput_needs_newline = 0;\n\t\t}\n\n\t\twrite_int(f_out, NDX_DONE);\n\t\tsend_msg(MSG_STATS, (char*)&stats.total_read, sizeof stats.total_read, 0);\n\t\tio_flush(FULL_FLUSH);\n\n\t\t/* Handle any keep-alive packets from the post-processing work\n\t\t * that the generator does. */\n\t\tif (protocol_version >= 29) {\n\t\t\tkluge_around_eof = -1;\n\n\t\t\t/* This should only get stopped via a USR2 signal. */\n\t\t\tread_final_goodbye(f_in, f_out);\n\n\t\t\trprintf(FERROR, \"Invalid packet at end of run [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\t/* Finally, we go to sleep until our parent kills us with a\n\t\t * USR2 signal.  We sleep for a short time, as on some OSes\n\t\t * a signal won't interrupt a sleep! */\n\t\twhile (1)\n\t\t\tmsleep(20);\n\t}\n\n\tam_generator = 1;\n\timplied_filter_list.head = implied_filter_list.tail = NULL;\n\tflist_receiving_enabled = True;\n\n\tio_end_multiplex_in(MPLX_SWITCHING);\n\tif (write_batch && !am_server)\n\t\tstop_write_batch();\n\n\tclose(error_pipe[1]);\n\tif (f_in != f_out)\n\t\tclose(f_in);\n\tsock_f_in = -1;\n\tf_in = error_pipe[0];\n\n\tio_start_buffering_out(f_out);\n\tio_start_multiplex_in(f_in);\n\n#ifdef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links && inc_recurse) {\n\t\tstruct file_list *flist;\n\t\tfor (flist = first_flist; flist; flist = flist->next)\n\t\t\tmatch_hard_links(flist);\n\t}\n#endif\n\n\tgenerate_files(f_out, local_name);\n\n\thandle_stats(-1);\n\tio_flush(FULL_FLUSH);\n\tshutting_down = True;\n\tif (protocol_version >= 24) {\n\t\t/* send a final goodbye message */\n\t\twrite_ndx(f_out, NDX_DONE);\n\t}\n\tio_flush(FULL_FLUSH);\n\n\tkill(pid, SIGUSR2);\n\twait_process_with_flush(pid, &exit_code);\n\treturn exit_code;\n}\n\nstatic void do_server_recv(int f_in, int f_out, int argc, char *argv[])\n{\n\tint exit_code;\n\tstruct file_list *flist;\n\tchar *local_name = NULL;\n\tint negated_levels;\n\n\tif (filesfrom_fd >= 0 && msgs2stderr != 1 && protocol_version < 31) {\n\t\t/* We can't mix messages with files-from data on the socket,\n\t\t * so temporarily turn off info/debug messages. */\n\t\tnegate_output_levels();\n\t\tnegated_levels = 1;\n\t} else\n\t\tnegated_levels = 0;\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"server_recv(%d) starting pid=%d\\n\", argc, (int)getpid());\n\n\tif (am_daemon && read_only) {\n\t\trprintf(FERROR,\"ERROR: module is read only\\n\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t\treturn;\n\t}\n\n\tbecome_copy_as_user();\n\n\tif (argc > 0) {\n\t\tchar *dir = argv[0];\n\t\targc--;\n\t\targv++;\n\t\tif (!am_daemon && !change_dir(dir, CD_NORMAL)) {\n\t\t\trsyserr(FERROR, errno, \"change_dir#4 %s failed\",\n\t\t\t\tfull_fname(dir));\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t}\n\n\tif (protocol_version >= 30)\n\t\tio_start_multiplex_in(f_in);\n\telse\n\t\tio_start_buffering_in(f_in);\n\trecv_filter_list(f_in);\n\n\tif (filesfrom_fd >= 0) {\n\t\t/* We need to send the files-from names to the sender at the\n\t\t * same time that we receive the file-list from them, so we\n\t\t * need the IO routines to automatically write out the names\n\t\t * onto our f_out socket as we read the file-list.  This\n\t\t * avoids both deadlock and extra delays/buffers. */\n\t\tstart_filesfrom_forwarding(filesfrom_fd);\n\t\tfilesfrom_fd = -1;\n\t}\n\n\tflist = recv_file_list(f_in, -1);\n\tif (!flist) {\n\t\trprintf(FERROR,\"server_recv: recv_file_list error\\n\");\n\t\texit_cleanup(RERR_FILESELECT);\n\t}\n\tif (inc_recurse && file_total == 1)\n\t\trecv_additional_file_list(f_in);\n\n\tif (negated_levels)\n\t\tnegate_output_levels();\n\n\tif (argc > 0)\n\t\tlocal_name = get_local_name(flist,argv[0]);\n\n\t/* Now that we know what our destination directory turned out to be,\n\t * we can sanitize the --link-/copy-/compare-dest args correctly. */\n\tif (sanitize_paths) {\n\t\tchar **dir_p;\n\t\tfor (dir_p = basis_dir; *dir_p; dir_p++)\n\t\t\t*dir_p = sanitize_path(NULL, *dir_p, NULL, curr_dir_depth, SP_DEFAULT);\n\t\tif (partial_dir)\n\t\t\tpartial_dir = sanitize_path(NULL, partial_dir, NULL, curr_dir_depth, SP_DEFAULT);\n\t}\n\tcheck_alt_basis_dirs();\n\n\tif (daemon_filter_list.head) {\n\t\tchar **dir_p;\n\t\tfilter_rule_list *elp = &daemon_filter_list;\n\n\t\tfor (dir_p = basis_dir; *dir_p; dir_p++) {\n\t\t\tchar *dir = *dir_p;\n\t\t\tif (*dir == '/')\n\t\t\t\tdir += module_dirlen;\n\t\t\tif (check_filter(elp, FLOG, dir, 1) < 0)\n\t\t\t\tgoto options_rejected;\n\t\t}\n\t\tif (partial_dir && *partial_dir == '/'\n\t\t && check_filter(elp, FLOG, partial_dir + module_dirlen, 1) < 0) {\n\t\t    options_rejected:\n\t\t\trprintf(FERROR, \"Your options have been rejected by the server.\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t}\n\n\texit_code = do_recv(f_in, f_out, local_name);\n\texit_cleanup(exit_code);\n}\n\n\nint child_main(int argc, char *argv[])\n{\n\tstart_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);\n\treturn 0;\n}\n\n\nvoid start_server(int f_in, int f_out, int argc, char *argv[])\n{\n\tset_nonblocking(f_in);\n\tset_nonblocking(f_out);\n\n\tio_set_sock_fds(f_in, f_out);\n\tsetup_protocol(f_out, f_in);\n\n\tif (protocol_version >= 23)\n\t\tio_start_multiplex_out(f_out);\n\tif (am_daemon && io_timeout && protocol_version >= 31)\n\t\tsend_msg_int(MSG_IO_TIMEOUT, io_timeout);\n\n\tif (am_sender) {\n\t\tkeep_dirlinks = 0; /* Must be disabled on the sender. */\n\t\tif (need_messages_from_generator)\n\t\t\tio_start_multiplex_in(f_in);\n\t\telse\n\t\t\tio_start_buffering_in(f_in);\n\t\trecv_filter_list(f_in);\n\t\tdo_server_sender(f_in, f_out, argc, argv);\n\t} else\n\t\tdo_server_recv(f_in, f_out, argc, argv);\n\texit_cleanup(0);\n}\n\n/* This is called once the connection has been negotiated.  It is used\n * for rsyncd, remote-shell, and local connections. */\nint client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[])\n{\n\tstruct file_list *flist = NULL;\n\tint exit_code = 0, exit_code2 = 0;\n\tchar *local_name = NULL;\n\n\tcleanup_child_pid = pid;\n\tif (!read_batch) {\n\t\tset_nonblocking(f_in);\n\t\tset_nonblocking(f_out);\n\t}\n\n\tio_set_sock_fds(f_in, f_out);\n\tsetup_protocol(f_out,f_in);\n\n\t/* We set our stderr file handle to blocking because ssh might have\n\t * set it to non-blocking.  This can be particularly troublesome if\n\t * stderr is a clone of stdout, because ssh would have set our stdout\n\t * to non-blocking at the same time (which can easily cause us to lose\n\t * output from our print statements).  This kluge shouldn't cause ssh\n\t * any problems for how we use it.  Note also that we delayed setting\n\t * this until after the above protocol setup so that we know for sure\n\t * that ssh is done twiddling its file descriptors.  */\n\tset_blocking(STDERR_FILENO);\n\n\tif (am_sender) {\n\t\tkeep_dirlinks = 0; /* Must be disabled on the sender. */\n\n\t\tif (always_checksum\n\t\t && (log_format_has(stdout_format, 'C')\n\t\t  || log_format_has(logfile_format, 'C')))\n\t\t\tsender_keeps_checksum = 1;\n\n\t\tif (protocol_version >= 30)\n\t\t\tio_start_multiplex_out(f_out);\n\t\telse\n\t\t\tio_start_buffering_out(f_out);\n\t\tif (protocol_version >= 31 || (!filesfrom_host && protocol_version >= 23))\n\t\t\tio_start_multiplex_in(f_in);\n\t\telse\n\t\t\tio_start_buffering_in(f_in);\n\t\tsend_filter_list(f_out);\n\t\tif (filesfrom_host)\n\t\t\tfilesfrom_fd = f_in;\n\n\t\tif (write_batch && !am_server)\n\t\t\tstart_write_batch(f_out);\n\n\t\tbecome_copy_as_user();\n\n\t\tflist = send_file_list(f_out, argc, argv);\n\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\trprintf(FINFO,\"file list sent\\n\");\n\n\t\tif (protocol_version < 31 && filesfrom_host && protocol_version >= 23)\n\t\t\tio_start_multiplex_in(f_in);\n\n\t\tio_flush(NORMAL_FLUSH);\n\t\tsend_files(f_in, f_out);\n\t\tio_flush(FULL_FLUSH);\n\t\thandle_stats(-1);\n\t\tif (protocol_version >= 24)\n\t\t\tread_final_goodbye(f_in, f_out);\n\t\tif (pid != -1) {\n\t\t\tif (DEBUG_GTE(EXIT, 2))\n\t\t\t\trprintf(FINFO,\"client_run waiting on %d\\n\", (int) pid);\n\t\t\tio_flush(FULL_FLUSH);\n\t\t\twait_process_with_flush(pid, &exit_code);\n\t\t}\n\t\toutput_summary();\n\t\tio_flush(FULL_FLUSH);\n\t\texit_cleanup(exit_code);\n\t}\n\n\tif (!read_batch) {\n\t\tif (protocol_version >= 23)\n\t\t\tio_start_multiplex_in(f_in);\n\t\tif (need_messages_from_generator)\n\t\t\tio_start_multiplex_out(f_out);\n\t\telse\n\t\t\tio_start_buffering_out(f_out);\n\t}\n\n\tbecome_copy_as_user();\n\n\tsend_filter_list(read_batch ? -1 : f_out);\n\n\tif (filesfrom_fd >= 0) {\n\t\tstart_filesfrom_forwarding(filesfrom_fd);\n\t\tfilesfrom_fd = -1;\n\t}\n\n\tif (write_batch && !am_server)\n\t\tstart_write_batch(f_in);\n\tflist = recv_file_list(f_in, -1);\n\tif (inc_recurse && file_total == 1)\n\t\trecv_additional_file_list(f_in);\n\n\tif (flist && flist->used > 0) {\n\t\tlocal_name = get_local_name(flist, argv[0]);\n\n\t\tcheck_alt_basis_dirs();\n\n\t\texit_code2 = do_recv(f_in, f_out, local_name);\n\t} else {\n\t\thandle_stats(-1);\n\t\toutput_summary();\n\t}\n\n\tif (pid != -1) {\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO,\"client_run2 waiting on %d\\n\", (int) pid);\n\t\tio_flush(FULL_FLUSH);\n\t\twait_process_with_flush(pid, &exit_code);\n\t}\n\n\treturn MAX(exit_code, exit_code2);\n}\n\n/* Start a client for either type of remote connection.  Work out\n * whether the arguments request a remote shell or rsyncd connection,\n * and call the appropriate connection function, then run_client.\n *\n * Calls either start_socket_client (for sockets) or do_cmd and\n * client_run (for ssh). */\nstatic int start_client(int argc, char *argv[])\n{\n\tchar *p, *shell_machine = NULL, *shell_user = NULL;\n\tchar **remote_argv;\n\tint remote_argc, env_port = rsync_port;\n\tint f_in, f_out;\n\tint ret;\n\tpid_t pid;\n\n\tif (!read_batch) { /* for read_batch, NO source is specified */\n\t\tchar *path = check_for_hostspec(argv[0], &shell_machine, &rsync_port);\n\t\tif (path) { /* source is remote */\n\t\t\tchar *dummy_host;\n\t\t\tint dummy_port = 0;\n\t\t\t*argv = path;\n\t\t\tremote_argv = argv;\n\t\t\tremote_argc = argc;\n\t\t\targv += argc - 1;\n\t\t\tif (argc == 1 || **argv == ':')\n\t\t\t\targc = 0; /* no dest arg */\n\t\t\telse if (check_for_hostspec(*argv, &dummy_host, &dummy_port)) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"The source and destination cannot both be remote.\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t} else {\n\t\t\t\tremote_argc--; /* don't count dest */\n\t\t\t\targc = 1;\n\t\t\t}\n\t\t\tif (filesfrom_host && *filesfrom_host && strcmp(filesfrom_host, shell_machine) != 0) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"--files-from hostname is not the same as the transfer hostname\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tam_sender = 0;\n\t\t\tif (rsync_port)\n\t\t\t\tdaemon_connection = shell_cmd ? 1 : -1;\n\t\t} else { /* source is local, check dest arg */\n\t\t\tam_sender = 1;\n\n\t\t\tif (argc > 1) {\n\t\t\t\tp = argv[--argc];\n\t\t\t\tif (!*p)\n\t\t\t\t\tp = dot_dir_or_error();\n\t\t\t\tremote_argv = argv + argc;\n\t\t\t} else {\n\t\t\t\tstatic char *dotarg[1] = { \".\" };\n\t\t\t\tp = dotarg[0];\n\t\t\t\tremote_argv = dotarg;\n\t\t\t}\n\t\t\tremote_argc = 1;\n\n\t\t\tpath = check_for_hostspec(p, &shell_machine, &rsync_port);\n\t\t\tif (path && filesfrom_host && *filesfrom_host && strcmp(filesfrom_host, shell_machine) != 0) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"--files-from hostname is not the same as the transfer hostname\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (!path) { /* no hostspec found, so src & dest are local */\n\t\t\t\tlocal_server = 1;\n\t\t\t\tif (filesfrom_host) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"--files-from cannot be remote when the transfer is local\\n\");\n\t\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t\t}\n\t\t\t\tshell_machine = NULL;\n\t\t\t\trsync_port = 0;\n\t\t\t} else { /* hostspec was found, so dest is remote */\n\t\t\t\targv[argc] = path;\n\t\t\t\tif (rsync_port)\n\t\t\t\t\tdaemon_connection = shell_cmd ? 1 : -1;\n\t\t\t}\n\t\t}\n\t} else {  /* read_batch */\n\t\tlocal_server = 1;\n\t\tif (check_for_hostspec(argv[argc-1], &shell_machine, &rsync_port)) {\n\t\t\trprintf(FERROR, \"remote destination is not allowed with --read-batch\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tremote_argv = argv += argc - 1;\n\t\tremote_argc = argc = 1;\n\t\trsync_port = 0;\n\t}\n\n\t/* A local transfer doesn't unbackslash anything, so leave the args alone. */\n\tif (local_server) {\n\t\told_style_args = 2;\n\t\ttrust_sender_args = trust_sender_filter = 1;\n\t}\n\n\tif (!rsync_port && remote_argc && !**remote_argv) /* Turn an empty arg into a dot dir. */\n\t\t*remote_argv = \".\";\n\n\tif (am_sender) {\n\t\tchar *dummy_host;\n\t\tint dummy_port = rsync_port;\n\t\tint i;\n\t\tif (!argv[0][0])\n\t\t\tgoto invalid_empty;\n\t\t/* For local source, extra source args must not have hostspec. */\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tif (!argv[i][0]) {\n\t\t\t    invalid_empty:\n\t\t\t\trprintf(FERROR, \"Empty source arg specified.\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (check_for_hostspec(argv[i], &dummy_host, &dummy_port)) {\n\t\t\t\trprintf(FERROR, \"Unexpected remote arg: %s\\n\", argv[i]);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar *dummy_host;\n\t\tint dummy_port = rsync_port;\n\t\tint i;\n\t\tif (filesfrom_fd < 0)\n\t\t\tadd_implied_include(remote_argv[0], daemon_connection);\n\t\t/* For remote source, any extra source args must have either\n\t\t * the same hostname or an empty hostname. */\n\t\tfor (i = 1; i < remote_argc; i++) {\n\t\t\tchar *arg = check_for_hostspec(remote_argv[i], &dummy_host, &dummy_port);\n\t\t\tif (!arg) {\n\t\t\t\trprintf(FERROR, \"Unexpected local arg: %s\\n\", remote_argv[i]);\n\t\t\t\trprintf(FERROR, \"If arg is a remote file/dir, prefix it with a colon (:).\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (*dummy_host && strcmp(dummy_host, shell_machine) != 0) {\n\t\t\t\trprintf(FERROR, \"All source args must come from the same machine.\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (rsync_port != dummy_port) {\n\t\t\t\tif (!rsync_port || !dummy_port)\n\t\t\t\t\trprintf(FERROR, \"All source args must use the same hostspec format.\\n\");\n\t\t\t\telse\n\t\t\t\t\trprintf(FERROR, \"All source args must use the same port number.\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (!rsync_port && !*arg) /* Turn an empty arg into a dot dir. */\n\t\t\t\targ = \".\";\n\t\t\tremote_argv[i] = arg;\n\t\t\tadd_implied_include(arg, daemon_connection);\n\t\t}\n\t}\n\n\tif (rsync_port < 0)\n\t\trsync_port = RSYNC_PORT;\n\telse\n\t\tenv_port = rsync_port;\n\n\tif (daemon_connection < 0)\n\t\treturn start_socket_client(shell_machine, remote_argc, remote_argv, argc, argv);\n\n\tif (password_file && !daemon_connection) {\n\t\trprintf(FERROR, \"The --password-file option may only be \"\n\t\t\t\t\"used when accessing an rsync daemon.\\n\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\tif (connect_timeout) {\n\t\trprintf(FERROR, \"The --contimeout option may only be \"\n\t\t\t\t\"used when connecting to an rsync daemon.\\n\");\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\tif (shell_machine) {\n\t\tp = strrchr(shell_machine,'@');\n\t\tif (p) {\n\t\t\t*p = 0;\n\t\t\tshell_user = shell_machine;\n\t\t\tshell_machine = p+1;\n\t\t}\n\t}\n\n\tif (DEBUG_GTE(CMD, 2)) {\n\t\trprintf(FINFO,\"cmd=%s machine=%s user=%s path=%s\\n\",\n\t\t\tNS(shell_cmd), NS(shell_machine), NS(shell_user),\n\t\t\tNS(remote_argv[0]));\n\t}\n\n#ifdef HAVE_PUTENV\n\tif (daemon_connection)\n\t\tset_env_num(\"RSYNC_PORT\", env_port);\n#else\n\t(void)env_port;\n#endif\n\n\tpid = do_cmd(shell_cmd, shell_machine, shell_user, remote_argv, remote_argc, &f_in, &f_out);\n\n\t/* if we're running an rsync server on the remote host over a\n\t * remote shell command, we need to do the RSYNCD protocol first */\n\tif (daemon_connection) {\n\t\tint tmpret;\n\t\ttmpret = start_inband_exchange(f_in, f_out, shell_user, remote_argc, remote_argv);\n\t\tif (tmpret < 0)\n\t\t\treturn tmpret;\n\t}\n\n\tret = client_run(f_in, f_out, pid, argc, argv);\n\n\tfflush(stdout);\n\tfflush(stderr);\n\n\treturn ret;\n}\n\n\nstatic void sigusr1_handler(UNUSED(int val))\n{\n\tcalled_from_signal_handler = 1;\n\texit_cleanup(RERR_SIGNAL1);\n}\n\nstatic void sigusr2_handler(UNUSED(int val))\n{\n\tif (!am_server)\n\t\toutput_summary();\n\tclose_all();\n\tif (got_xfer_error)\n\t\t_exit(RERR_PARTIAL);\n\t_exit(0);\n}\n\n#if defined SIGINFO || defined SIGVTALRM\nstatic void siginfo_handler(UNUSED(int val))\n{\n\tif (!am_server && !INFO_GTE(PROGRESS, 1))\n\t\twant_progress_now = True;\n}\n#endif\n\nvoid remember_children(UNUSED(int val))\n{\n#ifdef WNOHANG\n\tint cnt, status;\n\tpid_t pid;\n\t/* An empty waitpid() loop was put here by Tridge and we could never\n\t * get him to explain why he put it in, so rather than taking it\n\t * out we're instead saving the child exit statuses for later use.\n\t * The waitpid() loop presumably eliminates all possibility of leaving\n\t * zombie children, maybe that's why he did it. */\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n\t\t/* save the child's exit status */\n\t\tfor (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {\n\t\t\tif (pid_stat_table[cnt].pid == 0) {\n\t\t\t\tpid_stat_table[cnt].pid = pid;\n\t\t\t\tpid_stat_table[cnt].status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#ifndef HAVE_SIGACTION\n\tsignal(SIGCHLD, remember_children);\n#endif\n}\n\n/**\n * This routine catches signals and tries to send them to gdb.\n *\n * Because it's called from inside a signal handler it ought not to\n * use too many library routines.\n *\n * @todo Perhaps use \"screen -X\" instead/as well, to help people\n * debugging without easy access to X.  Perhaps use an environment\n * variable, or just call a script?\n *\n * @todo The /proc/ magic probably only works on Linux (and\n * Solaris?)  Can we be more portable?\n **/\n#ifdef MAINTAINER_MODE\nconst char *get_panic_action(void)\n{\n\tconst char *cmd_fmt = getenv(\"RSYNC_PANIC_ACTION\");\n\n\tif (cmd_fmt)\n\t\treturn cmd_fmt;\n\treturn \"xterm -display :0 -T Panic -n Panic -e gdb /proc/%d/exe %d\";\n}\n\n/**\n * Handle a fatal signal by launching a debugger, controlled by $RSYNC_PANIC_ACTION.\n *\n * This signal handler is only installed if we were configured with\n * --enable-maintainer-mode.  Perhaps it should always be on and we\n * should just look at the environment variable, but I'm a bit leery\n * of a signal sending us into a busy loop.\n **/\nstatic void rsync_panic_handler(UNUSED(int whatsig))\n{\n\tchar cmd_buf[300];\n\tint ret, pid_int = getpid();\n\n\tsnprintf(cmd_buf, sizeof cmd_buf, get_panic_action(), pid_int, pid_int);\n\n\t/* Unless we failed to execute gdb, we allow the process to\n\t * continue.  I'm not sure if that's right. */\n\tret = shell_exec(cmd_buf);\n\tif (ret)\n\t\t_exit(ret);\n}\n#endif\n\nstatic void unset_env_var(const char *var)\n{\n#ifdef HAVE_UNSETENV\n\tunsetenv(var);\n#else\n#ifdef HAVE_PUTENV\n\tchar *mem;\n\tif (asprintf(&mem, \"%s=\", var) < 0)\n\t\tout_of_memory(\"unset_env_var\");\n\tputenv(mem);\n#else\n\t(void)var;\n#endif\n#endif\n}\n\n\nint main(int argc,char *argv[])\n{\n\tint ret;\n\n\traw_argc = argc;\n\traw_argv = argv;\n\n#ifdef HAVE_SIGACTION\n# ifdef HAVE_SIGPROCMASK\n\tsigset_t sigmask;\n\n\tsigemptyset(&sigmask);\n# endif\n\tsigact.sa_flags = SA_NOCLDSTOP;\n#endif\n\tSIGACTMASK(SIGUSR1, sigusr1_handler);\n\tSIGACTMASK(SIGUSR2, sigusr2_handler);\n\tSIGACTMASK(SIGCHLD, remember_children);\n#ifdef MAINTAINER_MODE\n\tSIGACTMASK(SIGSEGV, rsync_panic_handler);\n\tSIGACTMASK(SIGFPE, rsync_panic_handler);\n\tSIGACTMASK(SIGABRT, rsync_panic_handler);\n\tSIGACTMASK(SIGBUS, rsync_panic_handler);\n#endif\n#ifdef SIGINFO\n\tSIGACTMASK(SIGINFO, siginfo_handler);\n#endif\n#ifdef SIGVTALRM\n\tSIGACTMASK(SIGVTALRM, siginfo_handler);\n#endif\n\n\tstarttime = time(NULL);\n\tour_uid = MY_UID();\n\tour_gid = MY_GID();\n\tam_root = our_uid == ROOT_UID;\n\n\tunset_env_var(\"DISPLAY\");\n\n#if defined USE_OPENSSL && defined SET_OPENSSL_CONF\n#define TO_STR2(x) #x\n#define TO_STR(x) TO_STR2(x)\n\t/* ./configure --with-openssl-conf=/etc/ssl/openssl-rsync.cnf\n\t * defines SET_OPENSSL_CONF as that unquoted pathname. */\n\tif (!getenv(\"OPENSSL_CONF\")) /* Don't override it if it's already set. */\n\t\tset_env_str(\"OPENSSL_CONF\", TO_STR(SET_OPENSSL_CONF));\n#undef TO_STR\n#undef TO_STR2\n#endif\n\n\tmemset(&stats, 0, sizeof(stats));\n\n\t/* Even a non-daemon runs needs the default config values to be set, e.g.\n\t * lp_dont_compress() is queried when no --skip-compress option is set. */\n\treset_daemon_vars();\n\n\tif (argc < 2) {\n\t\tusage(FERROR);\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\t/* Get the umask for use in permission calculations.  We no longer set\n\t * it to zero; that is ugly and pointless now that all the callers that\n\t * relied on it have been reeducated to work with default ACLs. */\n\tumask(orig_umask = umask(0));\n\n#if defined CONFIG_LOCALE && defined HAVE_SETLOCALE\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_NUMERIC, \"\");\n#endif\n\n\tif (!parse_arguments(&argc, (const char ***) &argv)) {\n\t\toption_error();\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\tif (write_batch\n\t && poptDupArgv(argc, (const char **)argv, &cooked_argc, (const char ***)&cooked_argv) != 0)\n\t\tout_of_memory(\"main\");\n\n\tSIGACTMASK(SIGINT, sig_int);\n\tSIGACTMASK(SIGHUP, sig_int);\n\tSIGACTMASK(SIGTERM, sig_int);\n#if defined HAVE_SIGACTION && HAVE_SIGPROCMASK\n\tsigprocmask(SIG_UNBLOCK, &sigmask, NULL);\n#endif\n\n\t/* Ignore SIGPIPE; we consistently check error codes and will\n\t * see the EPIPE. */\n\tSIGACTION(SIGPIPE, SIG_IGN);\n#ifdef SIGXFSZ\n\tSIGACTION(SIGXFSZ, SIG_IGN);\n#endif\n\n\t/* Initialize change_dir() here because on some old systems getcwd\n\t * (implemented by forking \"pwd\" and reading its output) doesn't\n\t * work when there are other child processes.  Also, on all systems\n\t * that implement getcwd that way \"pwd\" can't be found after chroot. */\n\tchange_dir(NULL, CD_NORMAL);\n\n\tif ((write_batch || read_batch) && !am_server) {\n\t\topen_batch_files(); /* sets batch_fd */\n\t\tif (read_batch)\n\t\t\tread_stream_flags(batch_fd);\n\t\telse\n\t\t\twrite_stream_flags(batch_fd);\n\t}\n\tif (write_batch < 0)\n\t\tdry_run = 1;\n\n\tif (am_server) {\n#ifdef ICONV_CONST\n\t\tsetup_iconv();\n#endif\n\t} else if (am_daemon)\n\t\treturn daemon_main();\n\n\tif (am_server && protect_args) {\n\t\tchar buf[MAXPATHLEN];\n\t\tprotect_args = 2;\n\t\tread_args(STDIN_FILENO, NULL, buf, sizeof buf, 1, &argv, &argc, NULL);\n\t\tif (!parse_arguments(&argc, (const char ***) &argv)) {\n\t\t\toption_error();\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t}\n\n\tif (argc < 1) {\n\t\tusage(FERROR);\n\t\texit_cleanup(RERR_SYNTAX);\n\t}\n\n\tif (am_server) {\n\t\tset_nonblocking(STDIN_FILENO);\n\t\tset_nonblocking(STDOUT_FILENO);\n\t\tif (am_daemon)\n\t\t\treturn start_daemon(STDIN_FILENO, STDOUT_FILENO);\n\t\tstart_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);\n\t}\n\n\tret = start_client(argc, argv);\n\tif (ret == -1)\n\t\texit_cleanup(RERR_STARTCLIENT);\n\telse\n\t\texit_cleanup(ret);\n\n\treturn ret;\n}\n"
        },
        {
          "name": "match.c",
          "type": "blob",
          "size": 12.3681640625,
          "content": "/*\n * Block matching used by the file-transfer code.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2003-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n\nextern int checksum_seed;\nextern int append_mode;\n\nextern struct name_num_item *xfer_sum_nni;\nextern int xfer_sum_len;\n\nint updating_basis_file;\nchar sender_file_sum[MAX_DIGEST_LEN];\n\nstatic int false_alarms;\nstatic int hash_hits;\nstatic int matches;\nstatic int64 data_transfer;\n\nstatic int total_false_alarms;\nstatic int total_hash_hits;\nstatic int total_matches;\n\nextern struct stats stats;\n\n#define TRADITIONAL_TABLESIZE (1<<16)\n\nstatic uint32 tablesize;\nstatic int32 *hash_table;\n\n#define SUM2HASH2(s1,s2) (((s1) + (s2)) & 0xFFFF)\n#define SUM2HASH(sum) SUM2HASH2((sum)&0xFFFF,(sum)>>16)\n\n#define BIG_SUM2HASH(sum) ((sum)%tablesize)\n\nstatic void build_hash_table(struct sum_struct *s)\n{\n\tstatic uint32 alloc_size;\n\tint32 i;\n\n\t/* Dynamically calculate the hash table size so that the hash load\n\t * for big files is about 80%.  A number greater than the traditional\n\t * size must be odd or s2 will not be able to span the entire set. */\n\ttablesize = (uint32)(s->count/8) * 10 + 11;\n\tif (tablesize < TRADITIONAL_TABLESIZE)\n\t\ttablesize = TRADITIONAL_TABLESIZE;\n\tif (tablesize > alloc_size || tablesize < alloc_size - 16*1024) {\n\t\tif (hash_table)\n\t\t\tfree(hash_table);\n\t\thash_table = new_array(int32, tablesize);\n\t\talloc_size = tablesize;\n\t}\n\n\tmemset(hash_table, 0xFF, tablesize * sizeof hash_table[0]);\n\n\tif (tablesize == TRADITIONAL_TABLESIZE) {\n\t\tfor (i = 0; i < s->count; i++) {\n\t\t\tuint32 t = SUM2HASH(s->sums[i].sum1);\n\t\t\ts->sums[i].chain = hash_table[t];\n\t\t\thash_table[t] = i;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < s->count; i++) {\n\t\t\tuint32 t = BIG_SUM2HASH(s->sums[i].sum1);\n\t\t\ts->sums[i].chain = hash_table[t];\n\t\t\thash_table[t] = i;\n\t\t}\n\t}\n}\n\n\nstatic OFF_T last_match;\n\n\n/* Transmit a literal and/or match token.\n *\n * This delightfully-named function is called either when we find a\n * match and need to transmit all the unmatched data leading up to it,\n * or when we get bored of accumulating literal data and just need to\n * transmit it.  As a result of this second case, it is called even if\n * we have not matched at all!\n *\n * If i >= 0, the number of a matched token.  If < 0, indicates we have\n * only literal data.  A -1 will send a 0-token-int too, and a -2 sends\n * only literal data, w/o any token-int. */\nstatic void matched(int f, struct sum_struct *s, struct map_struct *buf, OFF_T offset, int32 i)\n{\n\tint32 n = (int32)(offset - last_match); /* max value: block_size (int32) */\n\tint32 j;\n\n\tif (DEBUG_GTE(DELTASUM, 2) && i >= 0) {\n\t\trprintf(FINFO,\n\t\t\t\"match at %s last_match=%s j=%d len=%ld n=%ld\\n\",\n\t\t\tbig_num(offset), big_num(last_match), i,\n\t\t\t(long)s->sums[i].len, (long)n);\n\t}\n\n\tsend_token(f, i, buf, last_match, n, i < 0 ? 0 : s->sums[i].len);\n\tdata_transfer += n;\n\n\tif (i >= 0) {\n\t\tstats.matched_data += s->sums[i].len;\n\t\tn += s->sums[i].len;\n\t}\n\n\tfor (j = 0; j < n; j += CHUNK_SIZE) {\n\t\tint32 n1 = MIN(CHUNK_SIZE, n - j);\n\t\tsum_update(map_ptr(buf, last_match + j, n1), n1);\n\t}\n\n\tif (i >= 0)\n\t\tlast_match = offset + s->sums[i].len;\n\telse\n\t\tlast_match = offset;\n\n\tif (buf && INFO_GTE(PROGRESS, 1))\n\t\tshow_progress(last_match, buf->file_size);\n}\n\n\nstatic void hash_search(int f,struct sum_struct *s,\n\t\t\tstruct map_struct *buf, OFF_T len)\n{\n\tOFF_T offset, aligned_offset, end;\n\tint32 k, want_i, aligned_i, backup;\n\tchar sum2[MAX_DIGEST_LEN];\n\tuint32 s1, s2, sum;\n\tint more;\n\tschar *map;\n\n\t/* want_i is used to encourage adjacent matches, allowing the RLL\n\t * coding of the output to work more efficiently. */\n\twant_i = 0;\n\n\tif (DEBUG_GTE(DELTASUM, 2)) {\n\t\trprintf(FINFO, \"hash search b=%ld len=%s\\n\",\n\t\t\t(long)s->blength, big_num(len));\n\t}\n\n\tk = (int32)MIN(len, (OFF_T)s->blength);\n\n\tmap = (schar *)map_ptr(buf, 0, k);\n\n\tsum = get_checksum1((char *)map, k);\n\ts1 = sum & 0xFFFF;\n\ts2 = sum >> 16;\n\tif (DEBUG_GTE(DELTASUM, 3))\n\t\trprintf(FINFO, \"sum=%.8x k=%ld\\n\", sum, (long)k);\n\n\toffset = aligned_offset = aligned_i = 0;\n\n\tend = len + 1 - s->sums[s->count-1].len;\n\n\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\trprintf(FINFO, \"hash search s->blength=%ld len=%s count=%s\\n\",\n\t\t\t(long)s->blength, big_num(len), big_num(s->count));\n\t}\n\n\tdo {\n\t\tint done_csum2 = 0;\n\t\tuint32 hash_entry;\n\t\tint32 i, *prev;\n\n\t\tif (DEBUG_GTE(DELTASUM, 4)) {\n\t\t\trprintf(FINFO, \"offset=%s sum=%04x%04x\\n\",\n\t\t\t\tbig_num(offset), s2 & 0xFFFF, s1 & 0xFFFF);\n\t\t}\n\n\t\tif (tablesize == TRADITIONAL_TABLESIZE) {\n\t\t\thash_entry = SUM2HASH2(s1,s2);\n\t\t\tif ((i = hash_table[hash_entry]) < 0)\n\t\t\t\tgoto null_hash;\n\t\t\tsum = (s1 & 0xffff) | (s2 << 16);\n\t\t} else {\n\t\t\tsum = (s1 & 0xffff) | (s2 << 16);\n\t\t\thash_entry = BIG_SUM2HASH(sum);\n\t\t\tif ((i = hash_table[hash_entry]) < 0)\n\t\t\t\tgoto null_hash;\n\t\t}\n\t\tprev = &hash_table[hash_entry];\n\n\t\thash_hits++;\n\t\tdo {\n\t\t\tint32 l;\n\n\t\t\t/* When updating in-place, the chunk's offset must be\n\t\t\t * either >= our offset or identical data at that offset.\n\t\t\t * Remove any bypassed entries that we can never use. */\n\t\t\tif (updating_basis_file && s->sums[i].offset < offset\n\t\t\t && !(s->sums[i].flags & SUMFLG_SAME_OFFSET)) {\n\t\t\t\t*prev = s->sums[i].chain;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprev = &s->sums[i].chain;\n\n\t\t\tif (sum != s->sums[i].sum1)\n\t\t\t\tcontinue;\n\n\t\t\t/* also make sure the two blocks are the same length */\n\t\t\tl = (int32)MIN((OFF_T)s->blength, len-offset);\n\t\t\tif (l != s->sums[i].len)\n\t\t\t\tcontinue;\n\n\t\t\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"potential match at %s i=%ld sum=%08x\\n\",\n\t\t\t\t\tbig_num(offset), (long)i, sum);\n\t\t\t}\n\n\t\t\tif (!done_csum2) {\n\t\t\t\tmap = (schar *)map_ptr(buf,offset,l);\n\t\t\t\tget_checksum2((char *)map,l,sum2);\n\t\t\t\tdone_csum2 = 1;\n\t\t\t}\n\n\t\t\tif (memcmp(sum2, sum2_at(s, i), s->s2length) != 0) {\n\t\t\t\tfalse_alarms++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* When updating in-place, the best possible match is\n\t\t\t * one with an identical offset, so we prefer that over\n\t\t\t * the adjacent want_i optimization. */\n\t\t\tif (updating_basis_file) {\n\t\t\t\t/* All the generator's chunks start at blength boundaries. */\n\t\t\t\twhile (aligned_offset < offset) {\n\t\t\t\t\taligned_offset += s->blength;\n\t\t\t\t\taligned_i++;\n\t\t\t\t}\n\t\t\t\tif ((offset == aligned_offset\n\t\t\t\t  || (sum == 0 && l == s->blength && aligned_offset + l <= len))\n\t\t\t\t && aligned_i < s->count) {\n\t\t\t\t\tif (i != aligned_i) {\n\t\t\t\t\t\tif (sum != s->sums[aligned_i].sum1\n\t\t\t\t\t\t || l != s->sums[aligned_i].len\n\t\t\t\t\t\t || memcmp(sum2, sum2_at(s, aligned_i), s->s2length) != 0)\n\t\t\t\t\t\t\tgoto check_want_i;\n\t\t\t\t\t\ti = aligned_i;\n\t\t\t\t\t}\n\t\t\t\t\tif (offset != aligned_offset) {\n\t\t\t\t\t\t/* We've matched some zeros in a spot that is also zeros\n\t\t\t\t\t\t * further along in the basis file, if we find zeros ahead\n\t\t\t\t\t\t * in the sender's file, we'll output enough literal data\n\t\t\t\t\t\t * to re-align with the basis file, and get back to seeking\n\t\t\t\t\t\t * instead of writing. */\n\t\t\t\t\t\tbackup = (int32)(aligned_offset - last_match);\n\t\t\t\t\t\tif (backup < 0)\n\t\t\t\t\t\t\tbackup = 0;\n\t\t\t\t\t\tmap = (schar *)map_ptr(buf, aligned_offset - backup, l + backup)\n\t\t\t\t\t\t    + backup;\n\t\t\t\t\t\tsum = get_checksum1((char *)map, l);\n\t\t\t\t\t\tif (sum != s->sums[i].sum1)\n\t\t\t\t\t\t\tgoto check_want_i;\n\t\t\t\t\t\tget_checksum2((char *)map, l, sum2);\n\t\t\t\t\t\tif (memcmp(sum2, sum2_at(s, i), s->s2length) != 0)\n\t\t\t\t\t\t\tgoto check_want_i;\n\t\t\t\t\t\t/* OK, we have a re-alignment match.  Bump the offset\n\t\t\t\t\t\t * forward to the new match point. */\n\t\t\t\t\t\toffset = aligned_offset;\n\t\t\t\t\t}\n\t\t\t\t\t/* This identical chunk is in the same spot in the old and new file. */\n\t\t\t\t\ts->sums[i].flags |= SUMFLG_SAME_OFFSET;\n\t\t\t\t\twant_i = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t  check_want_i:\n\t\t\t/* we've found a match, but now check to see\n\t\t\t * if want_i can hint at a better match. */\n\t\t\tif (i != want_i && want_i < s->count\n\t\t\t && (!updating_basis_file || s->sums[want_i].offset >= offset\n\t\t\t  || s->sums[want_i].flags & SUMFLG_SAME_OFFSET)\n\t\t\t && sum == s->sums[want_i].sum1\n\t\t\t && memcmp(sum2, sum2_at(s, want_i), s->s2length) == 0) {\n\t\t\t\t/* we've found an adjacent match - the RLL coder\n\t\t\t\t * will be happy */\n\t\t\t\ti = want_i;\n\t\t\t}\n\t\t\twant_i = i + 1;\n\n\t\t\tmatched(f,s,buf,offset,i);\n\t\t\toffset += s->sums[i].len - 1;\n\t\t\tk = (int32)MIN((OFF_T)s->blength, len-offset);\n\t\t\tmap = (schar *)map_ptr(buf, offset, k);\n\t\t\tsum = get_checksum1((char *)map, k);\n\t\t\ts1 = sum & 0xFFFF;\n\t\t\ts2 = sum >> 16;\n\t\t\tmatches++;\n\t\t\tbreak;\n\t\t} while ((i = s->sums[i].chain) >= 0);\n\n\t  null_hash:\n\t\tbackup = (int32)(offset - last_match);\n\t\t/* We sometimes read 1 byte prior to last_match... */\n\t\tif (backup < 0)\n\t\t\tbackup = 0;\n\n\t\t/* Trim off the first byte from the checksum */\n\t\tmore = offset + k < len;\n\t\tmap = (schar *)map_ptr(buf, offset - backup, k + more + backup) + backup;\n\t\ts1 -= map[0] + CHAR_OFFSET;\n\t\ts2 -= k * (map[0]+CHAR_OFFSET);\n\n\t\t/* Add on the next byte (if there is one) to the checksum */\n\t\tif (more) {\n\t\t\ts1 += map[k] + CHAR_OFFSET;\n\t\t\ts2 += s1;\n\t\t} else\n\t\t\t--k;\n\n\t\t/* By matching early we avoid re-reading the\n\t\t   data 3 times in the case where a token\n\t\t   match comes a long way after last\n\t\t   match. The 3 reads are caused by the\n\t\t   running match, the checksum update and the\n\t\t   literal send. */\n\t\tif (backup >= s->blength+CHUNK_SIZE && end-offset > CHUNK_SIZE)\n\t\t\tmatched(f, s, buf, offset - s->blength, -2);\n\t} while (++offset < end);\n\n\tmatched(f, s, buf, len, -1);\n\tmap_ptr(buf, len-1, 1);\n}\n\n\n/**\n * Scan through a origin file, looking for sections that match\n * checksums from the generator, and transmit either literal or token\n * data.\n *\n * Also calculates the MD4 checksum of the whole file, using the md\n * accumulator.  This is transmitted with the file as protection\n * against corruption on the wire.\n *\n * @param s Checksums received from the generator.  If <tt>s->count ==\n * 0</tt>, then there are actually no checksums for this file.\n *\n * @param len Length of the file to send.\n **/\nvoid match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)\n{\n\tlast_match = 0;\n\tfalse_alarms = 0;\n\thash_hits = 0;\n\tmatches = 0;\n\tdata_transfer = 0;\n\n\tsum_init(xfer_sum_nni, checksum_seed);\n\n\tif (append_mode > 0) {\n\t\tif (append_mode == 2) {\n\t\t\tOFF_T j = 0;\n\t\t\tfor (j = CHUNK_SIZE; j < s->flength; j += CHUNK_SIZE) {\n\t\t\t\tif (buf && INFO_GTE(PROGRESS, 1))\n\t\t\t\t\tshow_progress(last_match, buf->file_size);\n\t\t\t\tsum_update(map_ptr(buf, last_match, CHUNK_SIZE),\n\t\t\t\t\t   CHUNK_SIZE);\n\t\t\t\tlast_match = j;\n\t\t\t}\n\t\t\tif (last_match < s->flength) {\n\t\t\t\tint32 n = (int32)(s->flength - last_match);\n\t\t\t\tif (buf && INFO_GTE(PROGRESS, 1))\n\t\t\t\t\tshow_progress(last_match, buf->file_size);\n\t\t\t\tsum_update(map_ptr(buf, last_match, n), n);\n\t\t\t}\n\t\t}\n\t\tlast_match = s->flength;\n\t\ts->count = 0;\n\t}\n\n\tif (len > 0 && s->count > 0) {\n\t\tbuild_hash_table(s);\n\n\t\tif (DEBUG_GTE(DELTASUM, 2))\n\t\t\trprintf(FINFO,\"built hash table\\n\");\n\n\t\thash_search(f, s, buf, len);\n\n\t\tif (DEBUG_GTE(DELTASUM, 2))\n\t\t\trprintf(FINFO,\"done hash search\\n\");\n\t} else {\n\t\tOFF_T j;\n\t\t/* by doing this in pieces we avoid too many seeks */\n\t\tfor (j = last_match + CHUNK_SIZE; j < len; j += CHUNK_SIZE)\n\t\t\tmatched(f, s, buf, j, -2);\n\t\tmatched(f, s, buf, len, -1);\n\t}\n\n\tsum_end(sender_file_sum);\n\n\t/* If we had a read error, send a bad checksum.  We use all bits\n\t * off as long as the checksum doesn't happen to be that, in\n\t * which case we turn the last 0 bit into a 1. */\n\tif (buf && buf->status != 0) {\n\t\tint i;\n\t\tfor (i = 0; i < xfer_sum_len && sender_file_sum[i] == 0; i++) {}\n\t\tmemset(sender_file_sum, 0, xfer_sum_len);\n\t\tif (i == xfer_sum_len)\n\t\t\tsender_file_sum[i-1]++;\n\t}\n\n\tif (DEBUG_GTE(DELTASUM, 2))\n\t\trprintf(FINFO,\"sending file_sum\\n\");\n\twrite_buf(f, sender_file_sum, xfer_sum_len);\n\n\tif (DEBUG_GTE(DELTASUM, 2)) {\n\t\trprintf(FINFO, \"false_alarms=%d hash_hits=%d matches=%d\\n\",\n\t\t\tfalse_alarms, hash_hits, matches);\n\t}\n\n\ttotal_hash_hits += hash_hits;\n\ttotal_false_alarms += false_alarms;\n\ttotal_matches += matches;\n\tstats.literal_data += data_transfer;\n}\n\nvoid match_report(void)\n{\n\tif (!DEBUG_GTE(DELTASUM, 1))\n\t\treturn;\n\n\trprintf(FINFO,\n\t\t\"total: matches=%d  hash_hits=%d  false_alarms=%d data=%s\\n\",\n\t\ttotal_matches, total_hash_hits, total_false_alarms,\n\t\tbig_num(stats.literal_data));\n}\n"
        },
        {
          "name": "maybe-make-man",
          "type": "blob",
          "size": 0.9365234375,
          "content": "#!/bin/sh\n\nif [ $# != 1 ]; then\n    echo \"Usage: $0 NAME.NUM.md\" 1>&2\n    exit 1\nfi\n\ninname=\"$1\"\nsrcdir=`dirname \"$0\"`\nflagfile=\"$srcdir/.md2man-works\"\nforce_flagfile=\"$srcdir/.md2man-force\"\n\nif [ ! -f \"$flagfile\" ]; then\n    # We test our smallest manpage just to see if the python setup works.\n    if \"$srcdir/md-convert\" --test \"$srcdir/rsync-ssl.1.md\" >/dev/null 2>&1; then\n\ttouch $flagfile\n    else\n\toutname=`echo \"$inname\" | sed 's/\\.md$//'`\n\tif [ -f \"$outname\" ]; then\n\t    exit 0\n\telif [ -f \"$srcdir/$outname\" ]; then\n\t    echo \"Copying $srcdir/$outname\"\n\t    cp -p \"$srcdir/$outname\" .\n\t    exit 0\n\telse\n\t    echo \"ERROR: $outname cannot be created.\"\n\t    if [ -f \"$HOME/build_farm/build_test.fns\" ]; then\n\t\texit 0 # No exit errorno to avoid a build failure in the samba build farm\n\t    else\n\t\texit 1\n\t    fi\n\tfi\n    fi\nfi\n\nif [ -f \"$force_flagfile\" ]; then\n    opt='--force-link-text'\nelse\n    opt=''\nfi\n\n\"$srcdir/md-convert\" $opt \"$srcdir/$inname\"\n"
        },
        {
          "name": "md-convert",
          "type": "blob",
          "size": 23.3544921875,
          "content": "#!/usr/bin/env python3\n\n# This script transforms markdown files into html and (optionally) nroff. The\n# output files are written into the current directory named for the input file\n# without the .md suffix and either the .html suffix or no suffix.\n#\n# If the input .md file has a section number at the end of the name (e.g.,\n# rsync.1.md) a nroff file is also output (PROJ.NUM.md -> PROJ.NUM).\n#\n# The markdown input format has one extra extension: if a numbered list starts\n# at 0, it is turned into a description list. The dl's dt tag is taken from the\n# contents of the first tag inside the li, which is usually a p, code, or\n# strong tag.\n#\n# The cmarkgfm or commonmark lib is used to transforms the input file into\n# html.  Then, the html.parser is used as a state machine that lets us tweak\n# the html and (optionally) output nroff data based on the html tags.\n#\n# If the string @USE_GFM_PARSER@ exists in the file, the string is removed and\n# a github-flavored-markup parser is used to parse the file.\n#\n# The man-page .md files also get the vars @VERSION@, @BINDIR@, and @LIBDIR@\n# substituted.  Some of these values depend on the Makefile $(prefix) (see the\n# generated Makefile).  If the maintainer wants to build files for /usr/local\n# while creating release-ready man-page files for /usr, use the environment to\n# set RSYNC_OVERRIDE_PREFIX=/usr.\n\n# Copyright (C) 2020 - 2021 Wayne Davison\n#\n# This program is freely redistributable.\n\nimport os, sys, re, argparse, subprocess, time\nfrom html.parser import HTMLParser\n\nVALID_PAGES = 'README INSTALL COPYING rsync.1 rrsync.1 rsync-ssl.1 rsyncd.conf.5'.split()\n\nCONSUMES_TXT = set('h1 h2 h3 p li pre'.split())\n\nHTML_START = \"\"\"\\\n<html><head>\n<title>%TITLE%</title>\n<meta charset=\"UTF-8\"/>\n<link href=\"https://fonts.googleapis.com/css2?family=Roboto&family=Roboto+Mono&display=swap\" rel=\"stylesheet\">\n<style>\nbody {\n  max-width: 50em;\n  margin: auto;\n}\nbody, b, strong, u {\n  font-family: 'Roboto', sans-serif;\n}\na.tgt { font-face: symbol; font-weight: 400; font-size: 70%; visibility: hidden; text-decoration: none; color: #ddd; padding: 0 4px; border: 0; }\na.tgt:after { content: '🔗'; }\na.tgt:hover { color: #444; background-color: #eaeaea; }\nh1:hover > a.tgt, h2:hover > a.tgt, h3:hover > a.tgt, dt:hover > a.tgt { visibility: visible; }\ncode {\n  font-family: 'Roboto Mono', monospace;\n  font-weight: bold;\n  white-space: pre;\n}\npre code {\n  display: block;\n  font-weight: normal;\n}\nblockquote pre code {\n  background: #f1f1f1;\n}\ndd p:first-of-type {\n  margin-block-start: 0em;\n}\n</style>\n</head><body>\n\"\"\"\n\nTABLE_STYLE = \"\"\"\\\ntable {\n  border-color: grey;\n  border-spacing: 0;\n}\ntr {\n  border-top: 1px solid grey;\n}\ntr:nth-child(2n) {\n  background-color: #f6f8fa;\n}\nth, td {\n  border: 1px solid #dfe2e5;\n  text-align: center;\n  padding-left: 1em;\n  padding-right: 1em;\n}\n\"\"\"\n\nMAN_HTML_END = \"\"\"\\\n<div style=\"float: right\"><p><i>%s</i></p></div>\n\"\"\"\n\nHTML_END = \"\"\"\\\n</body></html>\n\"\"\"\n\nMAN_START = r\"\"\"\n.TH \"%s\" \"%s\" \"%s\" \"%s\" \"User Commands\"\n.\\\" prefix=%s\n\"\"\".lstrip()\n\nMAN_END = \"\"\"\\\n\"\"\"\n\nNORM_FONT = ('\\1', r\"\\fP\")\nBOLD_FONT = ('\\2', r\"\\fB\")\nUNDR_FONT = ('\\3', r\"\\fI\")\nNBR_DASH = ('\\4', r\"\\-\")\nNBR_SPACE = ('\\xa0', r\"\\ \")\n\nFILENAME_RE = re.compile(r'^(?P<fn>(?P<srcdir>.+/)?(?P<name>(?P<prog>[^/]+?)(\\.(?P<sect>\\d+))?)\\.md)$')\nASSIGNMENT_RE = re.compile(r'^(\\w+)=(.+)')\nVER_RE = re.compile(r'^#define\\s+RSYNC_VERSION\\s+\"(\\d.+?)\"', re.M)\nTZ_RE = re.compile(r'^#define\\s+MAINTAINER_TZ_OFFSET\\s+(-?\\d+(\\.\\d+)?)', re.M)\nVAR_REF_RE = re.compile(r'\\$\\{(\\w+)\\}')\nVERSION_RE = re.compile(r' (\\d[.\\d]+)[, ]')\nBIN_CHARS_RE = re.compile(r'[\\1-\\7]+')\nSPACE_DOUBLE_DASH_RE = re.compile(r'\\s--(\\s)')\nNON_SPACE_SINGLE_DASH_RE = re.compile(r'(^|\\W)-')\nWHITESPACE_RE = re.compile(r'\\s')\nCODE_BLOCK_RE = re.compile(r'[%s]([^=%s]+)[=%s]' % (BOLD_FONT[0], NORM_FONT[0], NORM_FONT[0]))\nNBR_DASH_RE = re.compile(r'[%s]' % NBR_DASH[0])\nINVALID_TARGET_CHARS_RE = re.compile(r'[^-A-Za-z0-9._]')\nINVALID_START_CHAR_RE = re.compile(r'^([^A-Za-z0-9])')\nMANIFY_LINESTART_RE = re.compile(r\"^(['.])\", flags=re.M)\n\nmd_parser = None\nenv_subs = { }\n\nwarning_count = 0\n\ndef main():\n    for mdfn in args.mdfiles:\n        parse_md_file(mdfn)\n\n    if args.test:\n        print(\"The test was successful.\")\n\n\ndef parse_md_file(mdfn):\n    fi = FILENAME_RE.match(mdfn)\n    if not fi:\n        die('Failed to parse a md input file name:', mdfn)\n    fi = argparse.Namespace(**fi.groupdict())\n    fi.want_manpage = not not fi.sect\n    if fi.want_manpage:\n        fi.title = fi.prog + '(' + fi.sect + ') manpage'\n    else:\n        fi.title = fi.prog + ' for rsync'\n\n    if fi.want_manpage:\n        if not env_subs:\n            find_man_substitutions()\n        prog_ver = 'rsync ' + env_subs['VERSION']\n        if fi.prog != 'rsync':\n            prog_ver = fi.prog + ' from ' + prog_ver\n        fi.man_headings = (fi.prog, fi.sect, env_subs['date'], prog_ver, env_subs['prefix'])\n\n    with open(mdfn, 'r', encoding='utf-8') as fh:\n        txt = fh.read()\n\n    use_gfm_parser = '@USE_GFM_PARSER@' in txt\n    if use_gfm_parser:\n        txt = txt.replace('@USE_GFM_PARSER@', '')\n\n    if fi.want_manpage:\n        txt = (txt.replace('@VERSION@', env_subs['VERSION'])\n                  .replace('@BINDIR@', env_subs['bindir'])\n                  .replace('@LIBDIR@', env_subs['libdir']))\n\n    if use_gfm_parser:\n        if not gfm_parser:\n            die('Input file requires cmarkgfm parser:', mdfn)\n        fi.html_in = gfm_parser(txt)\n    else:\n        fi.html_in = md_parser(txt)\n    txt = None\n\n    TransformHtml(fi)\n\n    if args.test:\n        return\n\n    output_list = [ (fi.name + '.html', fi.html_out) ]\n    if fi.want_manpage:\n        output_list += [ (fi.name, fi.man_out) ]\n    for fn, txt in output_list:\n        if args.dest and args.dest != '.':\n            fn = os.path.join(args.dest, fn)\n        if os.path.lexists(fn):\n            os.unlink(fn)\n        print(\"Wrote:\", fn)\n        with open(fn, 'w', encoding='utf-8') as fh:\n            fh.write(txt)\n\n\ndef find_man_substitutions():\n    srcdir = os.path.dirname(sys.argv[0]) + '/'\n    mtime = 0\n\n    git_dir = srcdir + '.git'\n    if os.path.lexists(git_dir):\n        mtime = int(subprocess.check_output(['git', '--git-dir', git_dir, 'log', '-1', '--format=%at']))\n\n    # Allow \"prefix\" to be overridden via the environment:\n    env_subs['prefix'] = os.environ.get('RSYNC_OVERRIDE_PREFIX', None)\n\n    if args.test:\n        env_subs['VERSION'] = '1.0.0'\n        env_subs['bindir'] = '/usr/bin'\n        env_subs['libdir'] = '/usr/lib/rsync'\n        tz_offset = 0\n    else:\n        for fn in (srcdir + 'version.h', 'Makefile'):\n            try:\n                st = os.lstat(fn)\n            except OSError:\n                die('Failed to find', srcdir + fn)\n            if not mtime:\n                mtime = st.st_mtime\n\n        with open(srcdir + 'version.h', 'r', encoding='utf-8') as fh:\n            txt = fh.read()\n        m = VER_RE.search(txt)\n        env_subs['VERSION'] = m.group(1)\n        m = TZ_RE.search(txt) # the tzdata lib may not be installed, so we use a simple hour offset\n        tz_offset = float(m.group(1)) * 60 * 60\n\n        with open('Makefile', 'r', encoding='utf-8') as fh:\n            for line in fh:\n                m = ASSIGNMENT_RE.match(line)\n                if not m:\n                    continue\n                var, val = (m.group(1), m.group(2))\n                if var == 'prefix' and env_subs[var] is not None:\n                    continue\n                while VAR_REF_RE.search(val):\n                    val = VAR_REF_RE.sub(lambda m: env_subs[m.group(1)], val)\n                env_subs[var] = val\n                if var == 'srcdir':\n                    break\n\n    env_subs['date'] = time.strftime('%d %b %Y', time.gmtime(mtime + tz_offset)).lstrip('0')\n\n\ndef html_via_commonmark(txt):\n    return commonmark.HtmlRenderer().render(commonmark.Parser().parse(txt))\n\n\nclass TransformHtml(HTMLParser):\n    def __init__(self, fi):\n        HTMLParser.__init__(self, convert_charrefs=True)\n\n        self.fn = fi.fn\n\n        st = self.state = argparse.Namespace(\n                list_state = [ ],\n                p_macro = \".P\\n\",\n                at_first_tag_in_li = False,\n                at_first_tag_in_dd = False,\n                dt_from = None,\n                in_pre = False,\n                in_code = False,\n                html_out = [ HTML_START.replace('%TITLE%', fi.title) ],\n                man_out = [ ],\n                txt = '',\n                want_manpage = fi.want_manpage,\n                created_hashtags = set(),\n                derived_hashtags = set(),\n                referenced_hashtags = set(),\n                bad_hashtags = set(),\n                latest_targets = [ ],\n                opt_prefix = 'opt',\n                a_href = None,\n                a_href_external = False,\n                a_txt_start = None,\n                after_a_tag = False,\n                target_suf = '',\n                )\n\n        if st.want_manpage:\n            st.man_out.append(MAN_START % fi.man_headings)\n\n        if '</table>' in fi.html_in:\n            st.html_out[0] = st.html_out[0].replace('</style>', TABLE_STYLE + '</style>')\n\n        self.feed(fi.html_in)\n        fi.html_in = None\n\n        if st.want_manpage:\n            st.html_out.append(MAN_HTML_END % env_subs['date'])\n        st.html_out.append(HTML_END)\n        st.man_out.append(MAN_END)\n\n        fi.html_out = ''.join(st.html_out)\n        st.html_out = None\n\n        fi.man_out = ''.join(st.man_out)\n        st.man_out = None\n\n        for tgt, txt in st.derived_hashtags:\n            derived = txt2target(txt, tgt)\n            if derived not in st.created_hashtags:\n                txt = BIN_CHARS_RE.sub('', txt.replace(NBR_DASH[0], '-').replace(NBR_SPACE[0], ' '))\n                warn('Unknown derived hashtag link in', self.fn, 'based on:', (tgt, txt))\n\n        for bad in st.bad_hashtags:\n            if bad in st.created_hashtags:\n                warn('Missing \"#\" in hashtag link in', self.fn + ':', bad)\n            else:\n                warn('Unknown non-hashtag link in', self.fn + ':', bad)\n\n        for bad in st.referenced_hashtags - st.created_hashtags:\n            warn('Unknown hashtag link in', self.fn + ':', '#' + bad)\n\n    def handle_UE(self):\n        st = self.state\n        if st.txt.startswith(('.', ',', '!', '?', ';', ':')):\n            st.man_out[-1] = \".UE \" + st.txt[0] + \"\\n\"\n            st.txt = st.txt[1:]\n        st.after_a_tag = False\n\n    def handle_starttag(self, tag, attrs_list):\n        st = self.state\n        if args.debug:\n            self.output_debug('START', (tag, attrs_list))\n        if st.at_first_tag_in_li:\n            if st.list_state[-1] == 'dl':\n                st.dt_from = tag\n                if tag == 'p':\n                    tag = 'dt'\n                else:\n                    st.html_out.append('<dt>')\n            elif tag == 'p':\n                st.at_first_tag_in_dd = True # Kluge to suppress a .P at the start of an li.\n            st.at_first_tag_in_li = False\n        if tag == 'p':\n            if not st.at_first_tag_in_dd:\n                st.man_out.append(st.p_macro)\n        elif tag == 'li':\n            st.at_first_tag_in_li = True\n            lstate = st.list_state[-1]\n            if lstate == 'dl':\n                return\n            if lstate == 'o':\n                st.man_out.append(\".IP o\\n\")\n            else:\n                st.man_out.append(\".IP \" + str(lstate) + \".\\n\")\n                st.list_state[-1] += 1\n        elif tag == 'blockquote':\n            st.man_out.append(\".RS 4\\n\")\n        elif tag == 'pre':\n            st.in_pre = True\n            st.man_out.append(st.p_macro + \".nf\\n\")\n        elif tag == 'code' and not st.in_pre:\n            st.in_code = True\n            st.txt += BOLD_FONT[0]\n        elif tag == 'strong' or tag == 'b':\n            st.txt += BOLD_FONT[0]\n        elif tag == 'em' or  tag == 'i':\n            if st.want_manpage:\n                tag = 'u' # Change it into underline to be more like the manpage\n                st.txt += UNDR_FONT[0]\n        elif tag == 'ol':\n            start = 1\n            for var, val in attrs_list:\n                if var == 'start':\n                    start = int(val) # We only support integers.\n                    break\n            if st.list_state:\n                st.man_out.append(\".RS\\n\")\n            if start == 0:\n                tag = 'dl'\n                attrs_list = [ ]\n                st.list_state.append('dl')\n            else:\n                st.list_state.append(start)\n            st.man_out.append(st.p_macro)\n            st.p_macro = \".IP\\n\"\n        elif tag == 'ul':\n            st.man_out.append(st.p_macro)\n            if st.list_state:\n                st.man_out.append(\".RS\\n\")\n                st.p_macro = \".IP\\n\"\n            st.list_state.append('o')\n        elif tag == 'hr':\n            st.man_out.append(\".l\\n\")\n            st.html_out.append(\"<hr />\")\n            return\n        elif tag == 'a':\n            st.a_href = None\n            for var, val in attrs_list:\n                if var == 'href':\n                    if val.startswith(('https://', 'http://', 'mailto:', 'ftp:')):\n                        if st.after_a_tag:\n                            self.handle_UE()\n                        st.man_out.append(manify(st.txt.strip()) + \"\\n\")\n                        st.man_out.append(\".UR \" + val + \"\\n\")\n                        st.txt = ''\n                        st.a_href = val\n                        st.a_href_external = True\n                    elif '#' in val:\n                        pg, tgt = val.split('#', 1)\n                        if pg and pg not in VALID_PAGES or '#' in tgt:\n                            st.bad_hashtags.add(val)\n                        elif tgt in ('', 'opt', 'dopt'):\n                            st.a_href = val\n                            st.a_href_external = False\n                        elif pg == '':\n                            st.referenced_hashtags.add(tgt)\n                            if tgt in st.latest_targets:\n                                warn('Found link to the current section in', self.fn + ':', val)\n                    elif val not in VALID_PAGES:\n                        st.bad_hashtags.add(val)\n            st.a_txt_start = len(st.txt)\n        st.html_out.append('<' + tag + ''.join(' ' + var + '=\"' + htmlify(val) + '\"' for var, val in attrs_list) + '>')\n        st.at_first_tag_in_dd = False\n\n\n    def handle_endtag(self, tag):\n        st = self.state\n        if args.debug:\n            self.output_debug('END', (tag,))\n        if st.after_a_tag:\n            self.handle_UE()\n        if tag in CONSUMES_TXT or st.dt_from == tag:\n            txt = st.txt.strip()\n            st.txt = ''\n        else:\n            txt = None\n        add_to_txt = None\n        if tag == 'h1':\n            tgt = txt\n            target_suf = ''\n            if tgt.startswith('NEWS for '):\n                m = VERSION_RE.search(tgt)\n                if m:\n                    tgt = m.group(1)\n                    st.target_suf = '-' + tgt\n            self.add_targets(tag, tgt)\n        elif tag == 'h2':\n            st.man_out.append(st.p_macro + '.SH \"' + manify(txt) + '\"\\n')\n            self.add_targets(tag, txt, st.target_suf)\n            st.opt_prefix = 'dopt' if txt == 'DAEMON OPTIONS' else 'opt'\n        elif tag == 'h3':\n            st.man_out.append(st.p_macro + '.SS \"' + manify(txt) + '\"\\n')\n            self.add_targets(tag, txt, st.target_suf)\n        elif tag == 'p':\n            if st.dt_from == 'p':\n                tag = 'dt'\n                st.man_out.append('.IP \"' + manify(txt) + '\"\\n')\n                if txt.startswith(BOLD_FONT[0]):\n                    self.add_targets(tag, txt)\n                st.dt_from = None\n            elif txt != '':\n                st.man_out.append(manify(txt) + \"\\n\")\n        elif tag == 'li':\n            if st.list_state[-1] == 'dl':\n                if st.at_first_tag_in_li:\n                    die(\"Invalid 0. -> td translation\")\n                tag = 'dd'\n            if txt != '':\n                st.man_out.append(manify(txt) + \"\\n\")\n            st.at_first_tag_in_li = False\n        elif tag == 'blockquote':\n            st.man_out.append(\".RE\\n\")\n        elif tag == 'pre':\n            st.in_pre = False\n            st.man_out.append(manify(txt) + \"\\n.fi\\n\")\n        elif (tag == 'code' and not st.in_pre):\n            st.in_code = False\n            add_to_txt = NORM_FONT[0]\n        elif tag == 'strong' or tag == 'b':\n            add_to_txt = NORM_FONT[0]\n        elif tag == 'em' or  tag == 'i':\n            if st.want_manpage:\n                tag = 'u' # Change it into underline to be more like the manpage\n                add_to_txt = NORM_FONT[0]\n        elif tag == 'ol' or tag == 'ul':\n            if st.list_state.pop() == 'dl':\n                tag = 'dl'\n            if st.list_state:\n                st.man_out.append(\".RE\\n\")\n            else:\n                st.p_macro = \".P\\n\"\n            st.at_first_tag_in_dd = False\n        elif tag == 'hr':\n            return\n        elif tag == 'a':\n            if st.a_href_external:\n                st.txt = st.txt.strip()\n                if args.force_link_text or st.a_href != st.txt:\n                    st.man_out.append(manify(st.txt) + \"\\n\")\n                st.man_out.append(\".UE\\n\") # This might get replaced with a punctuation version in handle_UE()\n                st.after_a_tag = True\n                st.a_href_external = False\n                st.txt = ''\n            elif st.a_href:\n                atxt = st.txt[st.a_txt_start:]\n                find = 'href=\"' + st.a_href + '\"'\n                for j in range(len(st.html_out)-1, 0, -1):\n                    if find in st.html_out[j]:\n                        pg, tgt = st.a_href.split('#', 1)\n                        derived = txt2target(atxt, tgt)\n                        if pg == '':\n                            if derived in st.latest_targets:\n                                warn('Found link to the current section in', self.fn + ':', st.a_href)\n                            st.derived_hashtags.add((tgt, atxt))\n                        st.html_out[j] = st.html_out[j].replace(find, 'href=\"' + pg + '#' + derived + '\"')\n                        break\n                else:\n                    die('INTERNAL ERROR: failed to find href in html data:', find)\n        st.html_out.append('</' + tag + '>')\n        if add_to_txt:\n            if txt is None:\n                st.txt += add_to_txt\n            else:\n                txt += add_to_txt\n        if st.dt_from == tag:\n            st.man_out.append('.IP \"' + manify(txt) + '\"\\n')\n            st.html_out.append('</dt><dd>')\n            st.at_first_tag_in_dd = True\n            st.dt_from = None\n        elif tag == 'dt':\n            st.html_out.append('<dd>')\n            st.at_first_tag_in_dd = True\n\n\n    def handle_data(self, txt):\n        st = self.state\n        if '](' in txt:\n            warn('Malformed link in', self.fn + ':', txt)\n        if args.debug:\n            self.output_debug('DATA', (txt,))\n        if st.in_pre:\n            html = htmlify(txt)\n        else:\n            txt = SPACE_DOUBLE_DASH_RE.sub(NBR_SPACE[0] + r'--\\1', txt).replace('--', NBR_DASH[0]*2)\n            txt = NON_SPACE_SINGLE_DASH_RE.sub(r'\\1' + NBR_DASH[0], txt)\n            html = htmlify(txt)\n            if st.in_code:\n                txt = WHITESPACE_RE.sub(NBR_SPACE[0], txt)\n                html = html.replace(NBR_DASH[0], '-').replace(NBR_SPACE[0], ' ') # <code> is non-breaking in CSS\n        st.html_out.append(html.replace(NBR_SPACE[0], '&nbsp;').replace(NBR_DASH[0], '-&#8288;'))\n        st.txt += txt\n\n\n    def add_targets(self, tag, txt, suf=None):\n        st = self.state\n        tag = '<' + tag + '>'\n        targets = CODE_BLOCK_RE.findall(txt)\n        if not targets:\n            targets = [ txt ]\n        tag_pos = 0\n        for txt in targets:\n            txt = txt2target(txt, st.opt_prefix)\n            if not txt:\n                continue\n            if suf:\n                txt += suf\n            if txt in st.created_hashtags:\n                for j in range(2, 1000):\n                    chk = txt + '-' + str(j)\n                    if chk not in st.created_hashtags:\n                        print('Made link target unique:', chk)\n                        txt = chk\n                        break\n            if tag_pos == 0:\n                tag_pos -= 1\n                while st.html_out[tag_pos] != tag:\n                    tag_pos -= 1\n                st.html_out[tag_pos] = tag[:-1] + ' id=\"' + txt + '\">'\n                st.html_out.append('<a href=\"#' + txt + '\" class=\"tgt\"></a>')\n                tag_pos -= 1 # take into account the append\n            else:\n                st.html_out[tag_pos] = '<span id=\"' + txt + '\"></span>' + st.html_out[tag_pos]\n            st.created_hashtags.add(txt)\n        st.latest_targets = targets\n\n\n    def output_debug(self, event, extra):\n        import pprint\n        st = self.state\n        if args.debug < 2:\n            st = argparse.Namespace(**vars(st))\n            if len(st.html_out) > 2:\n                st.html_out = ['...'] + st.html_out[-2:]\n            if len(st.man_out) > 2:\n                st.man_out = ['...'] + st.man_out[-2:]\n        print(event, extra)\n        pprint.PrettyPrinter(indent=2).pprint(vars(st))\n\n\ndef txt2target(txt, opt_prefix):\n    txt = txt.strip().rstrip(':')\n    m = CODE_BLOCK_RE.search(txt)\n    if m:\n        txt = m.group(1)\n    txt = NBR_DASH_RE.sub('-', txt)\n    txt = BIN_CHARS_RE.sub('', txt)\n    txt = INVALID_TARGET_CHARS_RE.sub('_', txt)\n    if opt_prefix and txt.startswith('-'):\n        txt = opt_prefix + txt\n    else:\n        txt = INVALID_START_CHAR_RE.sub(r't\\1', txt)\n    return txt\n\n\ndef manify(txt):\n    return MANIFY_LINESTART_RE.sub(r'\\&\\1', txt.replace('\\\\', '\\\\\\\\')\n            .replace(NBR_SPACE[0], NBR_SPACE[1])\n            .replace(NBR_DASH[0], NBR_DASH[1])\n            .replace(NORM_FONT[0], NORM_FONT[1])\n            .replace(BOLD_FONT[0], BOLD_FONT[1])\n            .replace(UNDR_FONT[0], UNDR_FONT[1]))\n\n\ndef htmlify(txt):\n    return txt.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('\"', '&quot;')\n\n\ndef warn(*msg):\n    print(*msg, file=sys.stderr)\n    global warning_count\n    warning_count += 1\n\n\ndef die(*msg):\n    warn(*msg)\n    sys.exit(1)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description=\"Convert markdown into html and (optionally) nroff. Each input filename must have a .md suffix, which is changed to .html for the output filename. If the input filename ends with .num.md (e.g. foo.1.md) then a nroff file is also output with the input filename's .md suffix removed (e.g. foo.1).\", add_help=False)\n    parser.add_argument('--test', action='store_true', help=\"Just test the parsing without outputting any files.\")\n    parser.add_argument('--dest', metavar='DIR', help=\"Create files in DIR instead of the current directory.\")\n    parser.add_argument('--force-link-text', action='store_true', help=\"Don't remove the link text if it matches the link href. Useful when nroff doesn't understand .UR and .UE.\")\n    parser.add_argument('--debug', '-D', action='count', default=0, help='Output copious info on the html parsing. Repeat for even more.')\n    parser.add_argument(\"--help\", \"-h\", action=\"help\", help=\"Output this help message and exit.\")\n    parser.add_argument(\"mdfiles\", metavar='FILE.md', nargs='+', help=\"One or more .md files to convert.\")\n    args = parser.parse_args()\n\n    try:\n        import cmarkgfm\n        md_parser = cmarkgfm.markdown_to_html\n        gfm_parser = cmarkgfm.github_flavored_markdown_to_html\n    except:\n        try:\n            import commonmark\n            md_parser = html_via_commonmark\n        except:\n            die(\"Failed to find cmarkgfm or commonmark for python3.\")\n        gfm_parser = None\n\n    main()\n    if warning_count:\n        sys.exit(1)\n"
        },
        {
          "name": "md2man",
          "type": "blob",
          "size": 0.009765625,
          "content": "md-convert"
        },
        {
          "name": "mkgitver",
          "type": "blob",
          "size": 0.6484375,
          "content": "#!/bin/sh\n\nsrcdir=`dirname $0`\n\nif [ ! -f git-version.h ]; then\n    touch git-version.h\nfi\n\nif test -d \"$srcdir/.git\" || test -f \"$srcdir/.git\"; then\n    gitver=`git describe --abbrev=8 2>/dev/null`\n    # NOTE: I'm avoiding \"|\" in sed since I'm not sure if sed -r is portable and \"\\|\" fails on some OSes.\n    verchk=`echo \"$gitver-\" | sed -n '/^v3\\.[0-9][0-9]*\\.[0-9][0-9]*\\(pre[0-9]*\\)*-/p'`\n    if [ -n \"$verchk\" ]; then\n\techo \"#define RSYNC_GITVER \\\"$gitver\\\"\" >git-version.h.new\n\tif ! diff git-version.h.new git-version.h >/dev/null; then\n\t    echo \"Updating git-version.h\"\n\t    mv git-version.h.new git-version.h\n\telse\n\t    rm git-version.h.new\n\tfi\n    fi\nfi\n"
        },
        {
          "name": "mkproto.awk",
          "type": "blob",
          "size": 0.8798828125,
          "content": "#!/usr/bin/awk -f\n\nBEGIN {\n    while ((getline i < \"proto.h\") > 0) old_protos = old_protos ? old_protos \"\\n\" i : i\n    close(\"proto.h\")\n    protos = \"/* This file is automatically generated with \\\"make proto\\\". DO NOT EDIT */\\n\"\n}\n\ninheader {\n    protos = protos \"\\n\" ((inheader = /\\)[ \\t]*$/ ? 0 : 1) ? $0 : $0 \";\")\n    next\n}\n\n/^FN_(LOCAL|GLOBAL)_[^(]+\\([^,()]+/ {\n    local = /^FN_LOCAL/\n    gsub(/^FN_(LOC|GLOB)AL_|,.*$/, \"\")\n    sub(/^BOOL\\(/, \"BOOL \")\n    sub(/^CHAR\\(/, \"char \")\n    sub(/^INTEGER\\(/, \"int \")\n    sub(/^STRING\\(/, \"char *\")\n    protos = protos \"\\n\" $0 (local ? \"(int module_id);\" : \"(void);\")\n    next\n}\n\n/^static|^extern|;/||!/^[A-Za-z][A-Za-z0-9_]* / { next }\n\n/\\(.*\\)[ \\t]*$/ {\n    protos = protos \"\\n\" $0 \";\"\n    next\n}\n\n/\\(/ {\n    inheader = 1\n    protos = protos \"\\n\" $0\n}\n\nEND {\n    if (old_protos != protos) print protos > \"proto.h\"\n    system(\"touch proto.h-tstamp\")\n}\n"
        },
        {
          "name": "options.c",
          "type": "blob",
          "size": 94.7421875,
          "content": "/*\n * Command-line (and received via daemon-socket) option parsing.\n *\n * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 2000, 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2002-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"ifuncs.h\"\n#include <popt.h>\n\nextern int module_id;\nextern int local_server;\nextern int sanitize_paths;\nextern int trust_sender_args;\nextern int trust_sender_filter;\nextern unsigned int module_dirlen;\nextern filter_rule_list filter_list;\nextern filter_rule_list daemon_filter_list;\n\nint make_backups = 0;\n\n/**\n * If 1, send the whole file as literal data rather than trying to\n * create an incremental diff.\n *\n * If -1, then look at whether we're local or remote and go by that.\n *\n * @sa disable_deltas_p()\n **/\nint whole_file = -1;\n\nint append_mode = 0;\nint keep_dirlinks = 0;\nint copy_dirlinks = 0;\nint copy_links = 0;\nint copy_devices = 0;\nint write_devices = 0;\nint preserve_links = 0;\nint preserve_hard_links = 0;\nint preserve_acls = 0;\nint preserve_xattrs = 0;\nint preserve_perms = 0;\nint preserve_executability = 0;\nint preserve_devices = 0;\nint preserve_specials = 0;\nint preserve_uid = 0;\nint preserve_gid = 0;\nint preserve_mtimes = 0;\nint preserve_atimes = 0;\nint preserve_crtimes = 0;\nint omit_dir_times = 0;\nint omit_link_times = 0;\nint trust_sender = 0;\nint update_only = 0;\nint open_noatime = 0;\nint cvs_exclude = 0;\nint dry_run = 0;\nint do_xfers = 1;\nint do_fsync = 0;\nint ignore_times = 0;\nint delete_mode = 0;\nint delete_during = 0;\nint delete_before = 0;\nint delete_after = 0;\nint delete_excluded = 0;\nint remove_source_files = 0;\nint one_file_system = 0;\nint protocol_version = PROTOCOL_VERSION;\nint sparse_files = 0;\nint preallocate_files = 0;\nint do_compression = 0;\nint do_compression_level = CLVL_NOT_SPECIFIED;\nint am_root = 0; /* 0 = normal, 1 = root, 2 = --super, -1 = --fake-super */\nint am_server = 0;\nint am_sender = 0;\nint am_starting_up = 1;\nint relative_paths = -1;\nint implied_dirs = 1;\nint missing_args = 0; /* 0 = FERROR_XFER, 1 = ignore, 2 = delete */\nint numeric_ids = 0;\nint msgs2stderr = 2; /* Default: send errors to stderr for local & remote-shell transfers */\nint saw_stderr_opt = 0;\nint allow_8bit_chars = 0;\nint force_delete = 0;\nint io_timeout = 0;\nint prune_empty_dirs = 0;\nint use_qsort = 0;\nchar *files_from = NULL;\nint filesfrom_fd = -1;\nchar *filesfrom_host = NULL;\nint eol_nulls = 0;\nint protect_args = -1;\nint old_style_args = -1;\nint human_readable = 1;\nint recurse = 0;\nint mkpath_dest_arg = 0;\nint allow_inc_recurse = 1;\nint xfer_dirs = -1;\nint am_daemon = 0;\nint connect_timeout = 0;\nint keep_partial = 0;\nint safe_symlinks = 0;\nint copy_unsafe_links = 0;\nint munge_symlinks = 0;\nint size_only = 0;\nint daemon_bwlimit = 0;\nint bwlimit = 0;\nint fuzzy_basis = 0;\nsize_t bwlimit_writemax = 0;\nint ignore_existing = 0;\nint ignore_non_existing = 0;\nint need_messages_from_generator = 0;\nint max_delete = INT_MIN;\nOFF_T max_size = -1;\nOFF_T min_size = -1;\nint ignore_errors = 0;\nint modify_window = 0;\nint blocking_io = -1;\nint checksum_seed = 0;\nint inplace = 0;\nint delay_updates = 0;\nint32 block_size = 0;\ntime_t stop_at_utime = 0;\nchar *skip_compress = NULL;\nchar *copy_as = NULL;\nitem_list dparam_list = EMPTY_ITEM_LIST;\n\n/** Network address family. **/\nint default_af_hint\n#ifdef INET6\n\t= 0;\t\t/* Any protocol */\n#else\n\t= AF_INET;\t/* Must use IPv4 */\n# ifdef AF_INET6\n#  undef AF_INET6\n# endif\n# define AF_INET6 AF_INET /* make -6 option a no-op */\n#endif\n\n/** Do not go into the background when run as --daemon.  Good\n * for debugging and required for running as a service on W32,\n * or under Unix process-monitors. **/\nint no_detach\n#if defined _WIN32 || defined __WIN32__\n\t= 1;\n#else\n\t= 0;\n#endif\n\nint write_batch = 0;\nint read_batch = 0;\nint backup_dir_len = 0;\nint backup_suffix_len;\nunsigned int backup_dir_remainder;\n\nchar *backup_suffix = NULL;\nchar *tmpdir = NULL;\nchar *partial_dir = NULL;\nchar *basis_dir[MAX_BASIS_DIRS+1];\nchar *config_file = NULL;\nchar *shell_cmd = NULL;\nchar *logfile_name = NULL;\nchar *logfile_format = NULL;\nchar *stdout_format = NULL;\nchar *password_file = NULL;\nchar *early_input_file = NULL;\nchar *rsync_path = RSYNC_PATH;\nchar *backup_dir = NULL;\nchar backup_dir_buf[MAXPATHLEN];\nchar *sockopts = NULL;\nchar *usermap = NULL;\nchar *groupmap = NULL;\nint rsync_port = 0;\nint alt_dest_type = 0;\nint basis_dir_cnt = 0;\n\n#define DEFAULT_MAX_ALLOC (1024L * 1024 * 1024)\nsize_t max_alloc = DEFAULT_MAX_ALLOC;\nchar *max_alloc_arg;\n\nstatic int version_opt_cnt = 0;\nstatic int remote_option_alloc = 0;\nint remote_option_cnt = 0;\nconst char **remote_options = NULL;\nconst char *checksum_choice = NULL;\nconst char *compress_choice = NULL;\nstatic const char *empty_argv[1];\n\nint quiet = 0;\nint output_motd = 1;\nint log_before_transfer = 0;\nint stdout_format_has_i = 0;\nint stdout_format_has_o_or_i = 0;\nint logfile_format_has_i = 0;\nint logfile_format_has_o_or_i = 0;\nint always_checksum = 0;\nint list_only = 0;\n\n#define MAX_BATCH_NAME_LEN 256\t/* Must be less than MAXPATHLEN-13 */\nchar *batch_name = NULL;\n\nint need_unsorted_flist = 0;\nchar *iconv_opt =\n#ifdef ICONV_OPTION\n\t\tICONV_OPTION;\n#else\n\t\tNULL;\n#endif\n\nstruct chmod_mode_struct *chmod_modes = NULL;\n\nstatic const char *debug_verbosity[] = {\n\t/*0*/ NULL,\n\t/*1*/ NULL,\n\t/*2*/ \"BIND,CMD,CONNECT,DEL,DELTASUM,DUP,FILTER,FLIST,ICONV\",\n\t/*3*/ \"ACL,BACKUP,CONNECT2,DELTASUM2,DEL2,EXIT,FILTER2,FLIST2,FUZZY,GENR,OWN,RECV,SEND,TIME\",\n\t/*4*/ \"CMD2,DELTASUM3,DEL3,EXIT2,FLIST3,ICONV2,OWN2,PROTO,TIME2\",\n\t/*5*/ \"CHDIR,DELTASUM4,FLIST4,FUZZY2,HASH,HLINK\",\n};\n\n#define MAX_VERBOSITY ((int)(sizeof debug_verbosity / sizeof debug_verbosity[0]) - 1)\n\nstatic const char *info_verbosity[1+MAX_VERBOSITY] = {\n\t/*0*/ \"NONREG\",\n\t/*1*/ \"COPY,DEL,FLIST,MISC,NAME,STATS,SYMSAFE\",\n\t/*2*/ \"BACKUP,MISC2,MOUNT,NAME2,REMOVE,SKIP\",\n};\n\n#define MAX_OUT_LEVEL 4 /* The largest N allowed for any flagN word. */\n\nshort info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];\n\n#define DEFAULT_PRIORITY 0 \t/* Default/implied/--verbose set values. */\n#define HELP_PRIORITY 1\t\t/* The help output uses this level. */\n#define USER_PRIORITY 2\t\t/* User-specified via --info or --debug */\n#define LIMIT_PRIORITY 3\t/* Overriding priority when limiting values. */\n\n#define W_CLI (1<<0)\t/* client side */\n#define W_SRV (1<<1)\t/* server side */\n#define W_SND (1<<2)\t/* sending side */\n#define W_REC (1<<3)\t/* receiving side */\n\nstruct output_struct {\n\tchar *name;\t/* The name of the info/debug flag. */\n\tchar *help;\t/* The description of the info/debug flag. */\n\tuchar namelen;  /* The length of the name string. */\n\tuchar flag;\t/* The flag's value, for consistency check. */\n\tuchar where;\t/* Bits indicating where the flag is used. */\n\tuchar priority; /* See *_PRIORITY defines. */\n};\n\n#define INFO_WORD(flag, where, help) { #flag, help, sizeof #flag - 1, INFO_##flag, where, 0 }\n\nstatic struct output_struct info_words[COUNT_INFO+1] = {\n\tINFO_WORD(BACKUP, W_REC, \"Mention files backed up\"),\n\tINFO_WORD(COPY, W_REC, \"Mention files copied locally on the receiving side\"),\n\tINFO_WORD(DEL, W_REC, \"Mention deletions on the receiving side\"),\n\tINFO_WORD(FLIST, W_CLI, \"Mention file-list receiving/sending (levels 1-2)\"),\n\tINFO_WORD(MISC, W_SND|W_REC, \"Mention miscellaneous information (levels 1-2)\"),\n\tINFO_WORD(MOUNT, W_SND|W_REC, \"Mention mounts that were found or skipped\"),\n\tINFO_WORD(NAME, W_SND|W_REC, \"Mention 1) updated file/dir names, 2) unchanged names\"),\n\tINFO_WORD(NONREG, W_REC, \"Mention skipped non-regular files (default 1, 0 disables)\"),\n\tINFO_WORD(PROGRESS, W_CLI, \"Mention 1) per-file progress or 2) total transfer progress\"),\n\tINFO_WORD(REMOVE, W_SND, \"Mention files removed on the sending side\"),\n\tINFO_WORD(SKIP, W_REC, \"Mention files skipped due to transfer overrides (levels 1-2)\"),\n\tINFO_WORD(STATS, W_CLI|W_SRV, \"Mention statistics at end of run (levels 1-3)\"),\n\tINFO_WORD(SYMSAFE, W_SND|W_REC, \"Mention symlinks that are unsafe\"),\n\t{ NULL, \"--info\", 0, 0, 0, 0 }\n};\n\n#define DEBUG_WORD(flag, where, help) { #flag, help, sizeof #flag - 1, DEBUG_##flag, where, 0 }\n\nstatic struct output_struct debug_words[COUNT_DEBUG+1] = {\n\tDEBUG_WORD(ACL, W_SND|W_REC, \"Debug extra ACL info\"),\n\tDEBUG_WORD(BACKUP, W_REC, \"Debug backup actions (levels 1-2)\"),\n\tDEBUG_WORD(BIND, W_CLI, \"Debug socket bind actions\"),\n\tDEBUG_WORD(CHDIR, W_CLI|W_SRV, \"Debug when the current directory changes\"),\n\tDEBUG_WORD(CONNECT, W_CLI, \"Debug connection events (levels 1-2)\"),\n\tDEBUG_WORD(CMD, W_CLI, \"Debug commands+options that are issued (levels 1-2)\"),\n\tDEBUG_WORD(DEL, W_REC, \"Debug delete actions (levels 1-3)\"),\n\tDEBUG_WORD(DELTASUM, W_SND|W_REC, \"Debug delta-transfer checksumming (levels 1-4)\"),\n\tDEBUG_WORD(DUP, W_REC, \"Debug weeding of duplicate names\"),\n\tDEBUG_WORD(EXIT, W_CLI|W_SRV, \"Debug exit events (levels 1-3)\"),\n\tDEBUG_WORD(FILTER, W_SND|W_REC, \"Debug filter actions (levels 1-3)\"),\n\tDEBUG_WORD(FLIST, W_SND|W_REC, \"Debug file-list operations (levels 1-4)\"),\n\tDEBUG_WORD(FUZZY, W_REC, \"Debug fuzzy scoring (levels 1-2)\"),\n\tDEBUG_WORD(GENR, W_REC, \"Debug generator functions\"),\n\tDEBUG_WORD(HASH, W_SND|W_REC, \"Debug hashtable code\"),\n\tDEBUG_WORD(HLINK, W_SND|W_REC, \"Debug hard-link actions (levels 1-3)\"),\n\tDEBUG_WORD(ICONV, W_CLI|W_SRV, \"Debug iconv character conversions (levels 1-2)\"),\n\tDEBUG_WORD(IO, W_CLI|W_SRV, \"Debug I/O routines (levels 1-4)\"),\n\tDEBUG_WORD(NSTR, W_CLI|W_SRV, \"Debug negotiation strings\"),\n\tDEBUG_WORD(OWN, W_REC, \"Debug ownership changes in users & groups (levels 1-2)\"),\n\tDEBUG_WORD(PROTO, W_CLI|W_SRV, \"Debug protocol information\"),\n\tDEBUG_WORD(RECV, W_REC, \"Debug receiver functions\"),\n\tDEBUG_WORD(SEND, W_SND, \"Debug sender functions\"),\n\tDEBUG_WORD(TIME, W_REC, \"Debug setting of modified times (levels 1-2)\"),\n\t{ NULL, \"--debug\", 0, 0, 0, 0 }\n};\n\nstatic int verbose = 0;\nstatic int do_stats = 0;\nstatic int do_progress = 0;\nstatic int daemon_opt;   /* sets am_daemon after option error-reporting */\nstatic int F_option_cnt = 0;\nstatic int modify_window_set;\nstatic int itemize_changes = 0;\nstatic int refused_delete, refused_archive_part, refused_compress;\nstatic int refused_partial, refused_progress, refused_delete_before;\nstatic int refused_delete_during;\nstatic int refused_inplace, refused_no_iconv;\nstatic BOOL usermap_via_chown, groupmap_via_chown;\nstatic char *outbuf_mode;\nstatic char *bwlimit_arg, *max_size_arg, *min_size_arg;\nstatic char tmp_partialdir[] = \".~tmp~\";\n\n/** Local address to bind.  As a character string because it's\n * interpreted by the IPv6 layer: should be a numeric IP4 or IP6\n * address, or a hostname. **/\nchar *bind_address;\n\nstatic void output_item_help(struct output_struct *words);\n\n/* This constructs a string that represents all the options set for either\n * the --info or --debug setting, skipping any implied options (by -v, etc.).\n * This is used both when conveying the user's options to the server, and\n * when the help output wants to tell the user what options are implied. */\nstatic char *make_output_option(struct output_struct *words, short *levels, uchar where)\n{\n\tchar *str = words == info_words ? \"--info=\" : \"--debug=\";\n\tint j, counts[MAX_OUT_LEVEL+1], pos, skipped = 0, len = 0, max = 0, lev = 0;\n\tint word_count = words == info_words ? COUNT_INFO : COUNT_DEBUG;\n\tchar *buf;\n\n\tmemset(counts, 0, sizeof counts);\n\n\tfor (j = 0; words[j].name; j++) {\n\t\tif (words[j].flag != j) {\n\t\t\trprintf(FERROR, \"rsync: internal error on %s%s: %d != %d\\n\",\n\t\t\t\twords == info_words ? \"INFO_\" : \"DEBUG_\",\n\t\t\t\twords[j].name, words[j].flag, j);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t\tif (!(words[j].where & where))\n\t\t\tcontinue;\n\t\tif (words[j].priority == DEFAULT_PRIORITY) {\n\t\t\t/* Implied items don't need to be mentioned. */\n\t\t\tskipped++;\n\t\t\tcontinue;\n\t\t}\n\t\tlen += len ? 1 : strlen(str);\n\t\tlen += strlen(words[j].name);\n\t\tlen += levels[j] == 1 ? 0 : 1;\n\n\t\tif (words[j].priority == HELP_PRIORITY)\n\t\t\tcontinue; /* no abbreviating for help */\n\n\t\tassert(levels[j] <= MAX_OUT_LEVEL);\n\t\tif (++counts[levels[j]] > max) {\n\t\t\t/* Determine which level has the most items. */\n\t\t\tlev = levels[j];\n\t\t\tmax = counts[lev];\n\t\t}\n\t}\n\n\t/* Sanity check the COUNT_* define against the length of the table. */\n\tif (j != word_count) {\n\t\trprintf(FERROR, \"rsync: internal error: %s is wrong! (%d != %d)\\n\",\n\t\t\twords == info_words ? \"COUNT_INFO\" : \"COUNT_DEBUG\",\n\t\t\tj, word_count);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tif (!len)\n\t\treturn NULL;\n\n\tlen++;\n\tbuf = new_array(char, len);\n\tpos = 0;\n\n\tif (skipped || max < 5)\n\t\tlev = -1;\n\telse {\n\t\tif (lev == 0)\n\t\t\tpos += snprintf(buf, len, \"%sNONE\", str);\n\t\telse if (lev == 1)\n\t\t\tpos += snprintf(buf, len, \"%sALL\", str);\n\t\telse\n\t\t\tpos += snprintf(buf, len, \"%sALL%d\", str, lev);\n\t}\n\n\tfor (j = 0; words[j].name && pos < len; j++) {\n\t\tif (words[j].priority == DEFAULT_PRIORITY || levels[j] == lev || !(words[j].where & where))\n\t\t\tcontinue;\n\t\tif (pos)\n\t\t\tbuf[pos++] = ',';\n\t\telse\n\t\t\tpos += strlcpy(buf+pos, str, len-pos);\n\t\tif (pos < len)\n\t\t\tpos += strlcpy(buf+pos, words[j].name, len-pos);\n\t\t/* Level 1 is implied by the name alone. */\n\t\tif (levels[j] != 1 && pos < len)\n\t\t\tbuf[pos++] = '0' + levels[j];\n\t}\n\n\tbuf[pos] = '\\0';\n\n\treturn buf;\n}\n\nstatic void parse_output_words(struct output_struct *words, short *levels, const char *str, uchar priority)\n{\n\tconst char *s;\n\tint j, len, lev;\n\n\tfor ( ; str; str = s) {\n\t\tif ((s = strchr(str, ',')) != NULL)\n\t\t\tlen = s++ - str;\n\t\telse\n\t\t\tlen = strlen(str);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\tif (!isDigit(str)) {\n\t\t\twhile (len && isDigit(str+len-1))\n\t\t\t\tlen--;\n\t\t}\n\t\tlev = isDigit(str+len) ? atoi(str+len) : 1;\n\t\tif (lev > MAX_OUT_LEVEL)\n\t\t\tlev = MAX_OUT_LEVEL;\n\t\tif (len == 4 && strncasecmp(str, \"help\", 4) == 0) {\n\t\t\toutput_item_help(words);\n\t\t\texit_cleanup(0);\n\t\t}\n\t\tif (len == 4 && strncasecmp(str, \"none\", 4) == 0)\n\t\t\tlen = lev = 0;\n\t\telse if (len == 3 && strncasecmp(str, \"all\", 3) == 0)\n\t\t\tlen = 0;\n\t\tfor (j = 0; words[j].name; j++) {\n\t\t\tif (!len\n\t\t\t || (len == words[j].namelen && strncasecmp(str, words[j].name, len) == 0)) {\n\t\t\t\tif (priority >= words[j].priority) {\n\t\t\t\t\twords[j].priority = priority;\n\t\t\t\t\tlevels[j] = lev;\n\t\t\t\t}\n\t\t\t\tif (len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (len && !words[j].name && !am_server) {\n\t\t\trprintf(FERROR, \"Unknown %s item: \\\"%.*s\\\"\\n\",\n\t\t\t\twords[j].help, len, str);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t}\n}\n\n/* Tell the user what all the info or debug flags mean. */\nstatic void output_item_help(struct output_struct *words)\n{\n\tshort *levels = words == info_words ? info_levels : debug_levels;\n\tconst char **verbosity = words == info_words ? info_verbosity : debug_verbosity;\n\tchar buf[128], *opt, *fmt = \"%-10s %s\\n\";\n\tint j;\n\n\treset_output_levels();\n\n\trprintf(FINFO, \"Use OPT or OPT1 for level 1 output, OPT2 for level 2, etc.; OPT0 silences.\\n\");\n\trprintf(FINFO, \"\\n\");\n\tfor (j = 0; words[j].name; j++)\n\t\trprintf(FINFO, fmt, words[j].name, words[j].help);\n\trprintf(FINFO, \"\\n\");\n\n\tsnprintf(buf, sizeof buf, \"Set all %s options (e.g. all%d)\",\n\t\t words[j].help, MAX_OUT_LEVEL);\n\trprintf(FINFO, fmt, \"ALL\", buf);\n\n\tsnprintf(buf, sizeof buf, \"Silence all %s options (same as all0)\",\n\t\t words[j].help);\n\trprintf(FINFO, fmt, \"NONE\", buf);\n\n\trprintf(FINFO, fmt, \"HELP\", \"Output this help message\");\n\trprintf(FINFO, \"\\n\");\n\trprintf(FINFO, \"Options added at each level of verbosity:\\n\");\n\n\tfor (j = 0; j <= MAX_VERBOSITY; j++) {\n\t\tparse_output_words(words, levels, verbosity[j], HELP_PRIORITY);\n\t\topt = make_output_option(words, levels, W_CLI|W_SRV|W_SND|W_REC);\n\t\tif (opt) {\n\t\t\trprintf(FINFO, \"%d) %s\\n\", j, strchr(opt, '=')+1);\n\t\t\tfree(opt);\n\t\t}\n\t\treset_output_levels();\n\t}\n}\n\n/* The --verbose option now sets info+debug flags. */\nstatic void set_output_verbosity(int level, uchar priority)\n{\n\tint j;\n\n\tif (level > MAX_VERBOSITY)\n\t\tlevel = MAX_VERBOSITY;\n\n\tfor (j = 0; j <= level; j++) {\n\t\tparse_output_words(info_words, info_levels, info_verbosity[j], priority);\n\t\tparse_output_words(debug_words, debug_levels, debug_verbosity[j], priority);\n\t}\n}\n\n/* Limit the info+debug flag levels given a verbose-option level limit. */\nvoid limit_output_verbosity(int level)\n{\n\tshort info_limits[COUNT_INFO], debug_limits[COUNT_DEBUG];\n\tint j;\n\n\tif (level > MAX_VERBOSITY)\n\t\treturn;\n\n\tmemset(info_limits, 0, sizeof info_limits);\n\tmemset(debug_limits, 0, sizeof debug_limits);\n\n\t/* Compute the level limits in the above arrays. */\n\tfor (j = 0; j <= level; j++) {\n\t\tparse_output_words(info_words, info_limits, info_verbosity[j], LIMIT_PRIORITY);\n\t\tparse_output_words(debug_words, debug_limits, debug_verbosity[j], LIMIT_PRIORITY);\n\t}\n\n\tfor (j = 0; j < COUNT_INFO; j++) {\n\t\tif (info_levels[j] > info_limits[j])\n\t\t\tinfo_levels[j] = info_limits[j];\n\t}\n\n\tfor (j = 0; j < COUNT_DEBUG; j++) {\n\t\tif (debug_levels[j] > debug_limits[j])\n\t\t\tdebug_levels[j] = debug_limits[j];\n\t}\n}\n\nvoid reset_output_levels(void)\n{\n\tint j;\n\n\tmemset(info_levels, 0, sizeof info_levels);\n\tmemset(debug_levels, 0, sizeof debug_levels);\n\n\tfor (j = 0; j < COUNT_INFO; j++)\n\t\tinfo_words[j].priority = DEFAULT_PRIORITY;\n\n\tfor (j = 0; j < COUNT_DEBUG; j++)\n\t\tdebug_words[j].priority = DEFAULT_PRIORITY;\n}\n\nvoid negate_output_levels(void)\n{\n\tint j;\n\n\tfor (j = 0; j < COUNT_INFO; j++)\n\t\tinfo_levels[j] *= -1;\n\n\tfor (j = 0; j < COUNT_DEBUG; j++)\n\t\tdebug_levels[j] *= -1;\n}\n\nenum {OPT_SERVER = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,\n      OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,\n      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,\n      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,\n      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG, OPT_BLOCK_SIZE,\n      OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT, OPT_STDERR,\n      OPT_OLD_COMPRESS, OPT_NEW_COMPRESS, OPT_NO_COMPRESS, OPT_OLD_ARGS,\n      OPT_STOP_AFTER, OPT_STOP_AT,\n      OPT_REFUSED_BASE = 9000};\n\nstatic struct poptOption long_options[] = {\n  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */\n  {\"help\",             0,  POPT_ARG_NONE,   0, OPT_HELP, 0, 0 },\n  {\"version\",         'V', POPT_ARG_NONE,   0, 'V', 0, 0},\n  {\"verbose\",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },\n  {\"no-verbose\",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },\n  {\"no-v\",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },\n  {\"info\",             0,  POPT_ARG_STRING, 0, OPT_INFO, 0, 0 },\n  {\"debug\",            0,  POPT_ARG_STRING, 0, OPT_DEBUG, 0, 0 },\n  {\"stderr\",           0,  POPT_ARG_STRING, 0, OPT_STDERR, 0, 0 },\n  {\"msgs2stderr\",      0,  POPT_ARG_VAL,    &msgs2stderr, 1, 0, 0 },\n  {\"no-msgs2stderr\",   0,  POPT_ARG_VAL,    &msgs2stderr, 0, 0, 0 },\n  {\"quiet\",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },\n  {\"motd\",             0,  POPT_ARG_VAL,    &output_motd, 1, 0, 0 },\n  {\"no-motd\",          0,  POPT_ARG_VAL,    &output_motd, 0, 0, 0 },\n  {\"stats\",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },\n  {\"human-readable\",  'h', POPT_ARG_NONE,   0, 'h', 0, 0},\n  {\"no-human-readable\",0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},\n  {\"no-h\",             0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},\n  {\"dry-run\",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },\n  {\"archive\",         'a', POPT_ARG_NONE,   0, 'a', 0, 0 },\n  {\"recursive\",       'r', POPT_ARG_VAL,    &recurse, 2, 0, 0 },\n  {\"no-recursive\",     0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },\n  {\"no-r\",             0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },\n  {\"inc-recursive\",    0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },\n  {\"no-inc-recursive\", 0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },\n  {\"i-r\",              0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },\n  {\"no-i-r\",           0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },\n  {\"dirs\",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },\n  {\"no-dirs\",          0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },\n  {\"no-d\",             0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },\n  {\"old-dirs\",         0,  POPT_ARG_VAL,    &xfer_dirs, 4, 0, 0 },\n  {\"old-d\",            0,  POPT_ARG_VAL,    &xfer_dirs, 4, 0, 0 },\n  {\"perms\",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },\n  {\"no-perms\",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },\n  {\"no-p\",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },\n  {\"executability\",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },\n  {\"acls\",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },\n  {\"no-acls\",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },\n  {\"no-A\",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },\n  {\"xattrs\",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },\n  {\"no-xattrs\",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },\n  {\"no-X\",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },\n  {\"times\",           't', POPT_ARG_VAL,    &preserve_mtimes, 1, 0, 0 },\n  {\"no-times\",         0,  POPT_ARG_VAL,    &preserve_mtimes, 0, 0, 0 },\n  {\"no-t\",             0,  POPT_ARG_VAL,    &preserve_mtimes, 0, 0, 0 },\n  {\"atimes\",          'U', POPT_ARG_NONE,   0, 'U', 0, 0 },\n  {\"no-atimes\",        0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },\n  {\"no-U\",             0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },\n  {\"open-noatime\",     0,  POPT_ARG_VAL,    &open_noatime, 1, 0, 0 },\n  {\"no-open-noatime\",  0,  POPT_ARG_VAL,    &open_noatime, 0, 0, 0 },\n  {\"crtimes\",         'N', POPT_ARG_VAL,    &preserve_crtimes, 1, 0, 0 },\n  {\"no-crtimes\",       0,  POPT_ARG_VAL,    &preserve_crtimes, 0, 0, 0 },\n  {\"no-N\",             0,  POPT_ARG_VAL,    &preserve_crtimes, 0, 0, 0 },\n  {\"omit-dir-times\",  'O', POPT_ARG_VAL,    &omit_dir_times, 1, 0, 0 },\n  {\"no-omit-dir-times\",0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },\n  {\"no-O\",             0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },\n  {\"omit-link-times\", 'J', POPT_ARG_VAL,    &omit_link_times, 1, 0, 0 },\n  {\"no-omit-link-times\",0, POPT_ARG_VAL,    &omit_link_times, 0, 0, 0 },\n  {\"no-J\",             0,  POPT_ARG_VAL,    &omit_link_times, 0, 0, 0 },\n  {\"modify-window\",   '@', POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },\n  {\"super\",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },\n  {\"no-super\",         0,  POPT_ARG_VAL,    &am_root, 0, 0, 0 },\n  {\"fake-super\",       0,  POPT_ARG_VAL,    &am_root, -1, 0, 0 },\n  {\"owner\",           'o', POPT_ARG_VAL,    &preserve_uid, 1, 0, 0 },\n  {\"no-owner\",         0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },\n  {\"no-o\",             0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },\n  {\"group\",           'g', POPT_ARG_VAL,    &preserve_gid, 1, 0, 0 },\n  {\"no-group\",         0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },\n  {\"no-g\",             0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },\n  {0,                 'D', POPT_ARG_NONE,   0, 'D', 0, 0 },\n  {\"no-D\",             0,  POPT_ARG_NONE,   0, OPT_NO_D, 0, 0 },\n  {\"devices\",          0,  POPT_ARG_VAL,    &preserve_devices, 1, 0, 0 },\n  {\"no-devices\",       0,  POPT_ARG_VAL,    &preserve_devices, 0, 0, 0 },\n  {\"copy-devices\",     0,  POPT_ARG_NONE,   &copy_devices, 0, 0, 0 },\n  {\"write-devices\",    0,  POPT_ARG_VAL,    &write_devices, 1, 0, 0 },\n  {\"no-write-devices\", 0,  POPT_ARG_VAL,    &write_devices, 0, 0, 0 },\n  {\"specials\",         0,  POPT_ARG_VAL,    &preserve_specials, 1, 0, 0 },\n  {\"no-specials\",      0,  POPT_ARG_VAL,    &preserve_specials, 0, 0, 0 },\n  {\"links\",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },\n  {\"no-links\",         0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },\n  {\"no-l\",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },\n  {\"copy-links\",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },\n  {\"copy-unsafe-links\",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },\n  {\"safe-links\",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },\n  {\"munge-links\",      0,  POPT_ARG_VAL,    &munge_symlinks, 1, 0, 0 },\n  {\"no-munge-links\",   0,  POPT_ARG_VAL,    &munge_symlinks, 0, 0, 0 },\n  {\"copy-dirlinks\",   'k', POPT_ARG_NONE,   &copy_dirlinks, 0, 0, 0 },\n  {\"keep-dirlinks\",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },\n  {\"hard-links\",      'H', POPT_ARG_NONE,   0, 'H', 0, 0 },\n  {\"no-hard-links\",    0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },\n  {\"no-H\",             0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },\n  {\"relative\",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },\n  {\"no-relative\",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },\n  {\"no-R\",             0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },\n  {\"implied-dirs\",     0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },\n  {\"no-implied-dirs\",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },\n  {\"i-d\",              0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },\n  {\"no-i-d\",           0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },\n  {\"chmod\",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },\n  {\"ignore-times\",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },\n  {\"size-only\",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },\n  {\"one-file-system\", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },\n  {\"no-one-file-system\",0, POPT_ARG_VAL,    &one_file_system, 0, 0, 0 },\n  {\"no-x\",             0,  POPT_ARG_VAL,    &one_file_system, 0, 0, 0 },\n  {\"update\",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },\n  {\"existing\",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },\n  {\"ignore-non-existing\",0,POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },\n  {\"ignore-existing\",  0,  POPT_ARG_NONE,   &ignore_existing, 0, 0, 0 },\n  {\"max-size\",         0,  POPT_ARG_STRING, &max_size_arg, OPT_MAX_SIZE, 0, 0 },\n  {\"min-size\",         0,  POPT_ARG_STRING, &min_size_arg, OPT_MIN_SIZE, 0, 0 },\n  {\"max-alloc\",        0,  POPT_ARG_STRING, &max_alloc_arg, 0, 0, 0 },\n  {\"sparse\",          'S', POPT_ARG_VAL,    &sparse_files, 1, 0, 0 },\n  {\"no-sparse\",        0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },\n  {\"no-S\",             0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },\n  {\"preallocate\",      0,  POPT_ARG_NONE,   &preallocate_files, 0, 0, 0},\n  {\"inplace\",          0,  POPT_ARG_VAL,    &inplace, 1, 0, 0 },\n  {\"no-inplace\",       0,  POPT_ARG_VAL,    &inplace, 0, 0, 0 },\n  {\"append\",           0,  POPT_ARG_NONE,   0, OPT_APPEND, 0, 0 },\n  {\"append-verify\",    0,  POPT_ARG_VAL,    &append_mode, 2, 0, 0 },\n  {\"no-append\",        0,  POPT_ARG_VAL,    &append_mode, 0, 0, 0 },\n  {\"del\",              0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },\n  {\"delete\",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },\n  {\"delete-before\",    0,  POPT_ARG_NONE,   &delete_before, 0, 0, 0 },\n  {\"delete-during\",    0,  POPT_ARG_VAL,    &delete_during, 1, 0, 0 },\n  {\"delete-delay\",     0,  POPT_ARG_VAL,    &delete_during, 2, 0, 0 },\n  {\"delete-after\",     0,  POPT_ARG_NONE,   &delete_after, 0, 0, 0 },\n  {\"delete-excluded\",  0,  POPT_ARG_NONE,   &delete_excluded, 0, 0, 0 },\n  {\"delete-missing-args\",0,POPT_BIT_SET,    &missing_args, 2, 0, 0 },\n  {\"ignore-missing-args\",0,POPT_BIT_SET,    &missing_args, 1, 0, 0 },\n  {\"remove-sent-files\",0,  POPT_ARG_VAL,    &remove_source_files, 2, 0, 0 }, /* deprecated */\n  {\"remove-source-files\",0,POPT_ARG_VAL,    &remove_source_files, 1, 0, 0 },\n  {\"force\",            0,  POPT_ARG_VAL,    &force_delete, 1, 0, 0 },\n  {\"no-force\",         0,  POPT_ARG_VAL,    &force_delete, 0, 0, 0 },\n  {\"ignore-errors\",    0,  POPT_ARG_VAL,    &ignore_errors, 1, 0, 0 },\n  {\"no-ignore-errors\", 0,  POPT_ARG_VAL,    &ignore_errors, 0, 0, 0 },\n  {\"max-delete\",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },\n  {0,                 'F', POPT_ARG_NONE,   0, 'F', 0, 0 },\n  {\"filter\",          'f', POPT_ARG_STRING, 0, OPT_FILTER, 0, 0 },\n  {\"exclude\",          0,  POPT_ARG_STRING, 0, OPT_EXCLUDE, 0, 0 },\n  {\"include\",          0,  POPT_ARG_STRING, 0, OPT_INCLUDE, 0, 0 },\n  {\"exclude-from\",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },\n  {\"include-from\",     0,  POPT_ARG_STRING, 0, OPT_INCLUDE_FROM, 0, 0 },\n  {\"cvs-exclude\",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },\n  {\"whole-file\",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },\n  {\"no-whole-file\",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },\n  {\"no-W\",             0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },\n  {\"checksum\",        'c', POPT_ARG_VAL,    &always_checksum, 1, 0, 0 },\n  {\"no-checksum\",      0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },\n  {\"no-c\",             0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },\n  {\"checksum-choice\",  0,  POPT_ARG_STRING, &checksum_choice, 0, 0, 0 },\n  {\"cc\",               0,  POPT_ARG_STRING, &checksum_choice, 0, 0, 0 },\n  {\"block-size\",      'B', POPT_ARG_STRING, 0, OPT_BLOCK_SIZE, 0, 0 },\n  {\"compare-dest\",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },\n  {\"copy-dest\",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },\n  {\"link-dest\",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },\n  {\"fuzzy\",           'y', POPT_ARG_NONE,   0, 'y', 0, 0 },\n  {\"no-fuzzy\",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },\n  {\"no-y\",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },\n  {\"compress\",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },\n  {\"old-compress\",     0,  POPT_ARG_NONE,   0, OPT_OLD_COMPRESS, 0, 0 },\n  {\"new-compress\",     0,  POPT_ARG_NONE,   0, OPT_NEW_COMPRESS, 0, 0 },\n  {\"no-compress\",      0,  POPT_ARG_NONE,   0, OPT_NO_COMPRESS, 0, 0 },\n  {\"no-z\",             0,  POPT_ARG_NONE,   0, OPT_NO_COMPRESS, 0, 0 },\n  {\"compress-choice\",  0,  POPT_ARG_STRING, &compress_choice, 0, 0, 0 },\n  {\"zc\",               0,  POPT_ARG_STRING, &compress_choice, 0, 0, 0 },\n  {\"skip-compress\",    0,  POPT_ARG_STRING, &skip_compress, 0, 0, 0 },\n  {\"compress-level\",   0,  POPT_ARG_INT,    &do_compression_level, 0, 0, 0 },\n  {\"zl\",               0,  POPT_ARG_INT,    &do_compression_level, 0, 0, 0 },\n  {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },\n  {\"progress\",         0,  POPT_ARG_VAL,    &do_progress, 1, 0, 0 },\n  {\"no-progress\",      0,  POPT_ARG_VAL,    &do_progress, 0, 0, 0 },\n  {\"partial\",          0,  POPT_ARG_VAL,    &keep_partial, 1, 0, 0 },\n  {\"no-partial\",       0,  POPT_ARG_VAL,    &keep_partial, 0, 0, 0 },\n  {\"partial-dir\",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },\n  {\"delay-updates\",    0,  POPT_ARG_VAL,    &delay_updates, 1, 0, 0 },\n  {\"no-delay-updates\", 0,  POPT_ARG_VAL,    &delay_updates, 0, 0, 0 },\n  {\"prune-empty-dirs\",'m', POPT_ARG_VAL,    &prune_empty_dirs, 1, 0, 0 },\n  {\"no-prune-empty-dirs\",0,POPT_ARG_VAL,    &prune_empty_dirs, 0, 0, 0 },\n  {\"no-m\",             0,  POPT_ARG_VAL,    &prune_empty_dirs, 0, 0, 0 },\n  {\"log-file\",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },\n  {\"log-file-format\",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },\n  {\"out-format\",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 },\n  {\"log-format\",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 }, /* DEPRECATED */\n  {\"itemize-changes\", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },\n  {\"no-itemize-changes\",0, POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },\n  {\"no-i\",             0,  POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },\n  {\"bwlimit\",          0,  POPT_ARG_STRING, &bwlimit_arg, OPT_BWLIMIT, 0, 0 },\n  {\"no-bwlimit\",       0,  POPT_ARG_VAL,    &bwlimit, 0, 0, 0 },\n  {\"backup\",          'b', POPT_ARG_VAL,    &make_backups, 1, 0, 0 },\n  {\"no-backup\",        0,  POPT_ARG_VAL,    &make_backups, 0, 0, 0 },\n  {\"backup-dir\",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },\n  {\"suffix\",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },\n  {\"list-only\",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },\n  {\"read-batch\",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },\n  {\"write-batch\",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },\n  {\"only-write-batch\", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },\n  {\"files-from\",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },\n  {\"from0\",           '0', POPT_ARG_VAL,    &eol_nulls, 1, 0, 0},\n  {\"no-from0\",         0,  POPT_ARG_VAL,    &eol_nulls, 0, 0, 0},\n  {\"old-args\",         0,  POPT_ARG_NONE,   0, OPT_OLD_ARGS, 0, 0},\n  {\"no-old-args\",      0,  POPT_ARG_VAL,    &old_style_args, 0, 0, 0},\n  {\"secluded-args\",   's', POPT_ARG_VAL,    &protect_args, 1, 0, 0},\n  {\"no-secluded-args\", 0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},\n  {\"protect-args\",     0,  POPT_ARG_VAL,    &protect_args, 1, 0, 0},\n  {\"no-protect-args\",  0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},\n  {\"no-s\",             0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},\n  {\"trust-sender\",     0,  POPT_ARG_VAL,    &trust_sender, 1, 0, 0},\n  {\"numeric-ids\",      0,  POPT_ARG_VAL,    &numeric_ids, 1, 0, 0 },\n  {\"no-numeric-ids\",   0,  POPT_ARG_VAL,    &numeric_ids, 0, 0, 0 },\n  {\"usermap\",          0,  POPT_ARG_STRING, 0, OPT_USERMAP, 0, 0 },\n  {\"groupmap\",         0,  POPT_ARG_STRING, 0, OPT_GROUPMAP, 0, 0 },\n  {\"chown\",            0,  POPT_ARG_STRING, 0, OPT_CHOWN, 0, 0 },\n  {\"timeout\",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },\n  {\"no-timeout\",       0,  POPT_ARG_VAL,    &io_timeout, 0, 0, 0 },\n  {\"contimeout\",       0,  POPT_ARG_INT,    &connect_timeout, 0, 0, 0 },\n  {\"no-contimeout\",    0,  POPT_ARG_VAL,    &connect_timeout, 0, 0, 0 },\n  {\"fsync\",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },\n  {\"stop-after\",       0,  POPT_ARG_STRING, 0, OPT_STOP_AFTER, 0, 0 },\n  {\"time-limit\",       0,  POPT_ARG_STRING, 0, OPT_STOP_AFTER, 0, 0 }, /* earlier stop-after name */\n  {\"stop-at\",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },\n  {\"rsh\",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },\n  {\"rsync-path\",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },\n  {\"temp-dir\",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },\n  {\"iconv\",            0,  POPT_ARG_STRING, &iconv_opt, 0, 0, 0 },\n  {\"no-iconv\",         0,  POPT_ARG_NONE,   0, OPT_NO_ICONV, 0, 0 },\n  {\"ipv4\",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },\n  {\"ipv6\",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },\n  {\"8-bit-output\",    '8', POPT_ARG_VAL,    &allow_8bit_chars, 1, 0, 0 },\n  {\"no-8-bit-output\",  0,  POPT_ARG_VAL,    &allow_8bit_chars, 0, 0, 0 },\n  {\"no-8\",             0,  POPT_ARG_VAL,    &allow_8bit_chars, 0, 0, 0 },\n  {\"mkpath\",           0,  POPT_ARG_VAL,    &mkpath_dest_arg, 1, 0, 0 },\n  {\"no-mkpath\",        0,  POPT_ARG_VAL,    &mkpath_dest_arg, 0, 0, 0 },\n  {\"qsort\",            0,  POPT_ARG_NONE,   &use_qsort, 0, 0, 0 },\n  {\"copy-as\",          0,  POPT_ARG_STRING, &copy_as, 0, 0, 0 },\n  {\"address\",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },\n  {\"port\",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },\n  {\"sockopts\",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },\n  {\"password-file\",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },\n  {\"early-input\",      0,  POPT_ARG_STRING, &early_input_file, 0, 0, 0 },\n  {\"blocking-io\",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },\n  {\"no-blocking-io\",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },\n  {\"outbuf\",           0,  POPT_ARG_STRING, &outbuf_mode, 0, 0, 0 },\n  {\"remote-option\",   'M', POPT_ARG_STRING, 0, 'M', 0, 0 },\n  {\"protocol\",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },\n  {\"checksum-seed\",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },\n  {\"server\",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },\n  {\"sender\",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },\n  /* All the following options switch us into daemon-mode option-parsing. */\n  {\"config\",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },\n  {\"daemon\",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },\n  {\"dparam\",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },\n  {\"detach\",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },\n  {\"no-detach\",        0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },\n  {0,0,0,0, 0, 0, 0}\n};\n\nstatic struct poptOption long_daemon_options[] = {\n  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */\n  {\"address\",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },\n  {\"bwlimit\",          0,  POPT_ARG_INT,    &daemon_bwlimit, 0, 0, 0 },\n  {\"config\",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },\n  {\"daemon\",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },\n  {\"dparam\",          'M', POPT_ARG_STRING, 0, 'M', 0, 0 },\n  {\"ipv4\",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },\n  {\"ipv6\",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },\n  {\"detach\",           0,  POPT_ARG_VAL,    &no_detach, 0, 0, 0 },\n  {\"no-detach\",        0,  POPT_ARG_VAL,    &no_detach, 1, 0, 0 },\n  {\"log-file\",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },\n  {\"log-file-format\",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },\n  {\"port\",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },\n  {\"sockopts\",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },\n  {\"protocol\",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },\n  {\"server\",           0,  POPT_ARG_NONE,   &am_server, 0, 0, 0 },\n  {\"temp-dir\",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },\n  {\"verbose\",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },\n  {\"no-verbose\",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },\n  {\"no-v\",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },\n  {\"help\",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },\n  {0,0,0,0, 0, 0, 0}\n};\n\n\nstatic char err_buf[200];\n\n\n/**\n * Store the option error message, if any, so that we can log the\n * connection attempt (which requires parsing the options), and then\n * show the error later on.\n **/\nvoid option_error(void)\n{\n\tif (!err_buf[0]) {\n\t\tstrlcpy(err_buf, \"Error parsing options: option may \"\n\t\t\t\"be supported on client but not on server?\\n\",\n\t\t\tsizeof err_buf);\n\t}\n\n\trprintf(FERROR, RSYNC_NAME \": %s\", err_buf);\n\tio_flush(MSG_FLUSH);\n\tmsleep(20);\n}\n\n\nstatic void parse_one_refuse_match(int negated, const char *ref, const struct poptOption *list_end)\n{\n\tstruct poptOption *op;\n\tchar shortName[2];\n\tint is_wild = strpbrk(ref, \"*?[\") != NULL;\n\tint found_match = 0;\n\n\tshortName[1] = '\\0';\n\n\tif (strcmp(\"a\", ref) == 0 || strcmp(\"archive\", ref) == 0) {\n\t\tref = \"[ardlptgoD]\";\n\t\tis_wild = 1;\n\t}\n\n\tfor (op = long_options; op != list_end; op++) {\n\t\t*shortName = op->shortName;\n\t\tif ((op->longName && wildmatch(ref, op->longName))\n\t\t || (*shortName && wildmatch(ref, shortName))) {\n\t\t\tif (op->descrip[1] == '*')\n\t\t\t\top->descrip = negated ? \"a*\" : \"r*\";\n\t\t\telse if (!is_wild)\n\t\t\t\top->descrip = negated ? \"a=\" : \"r=\";\n\t\t\tfound_match = 1;\n\t\t\tif (!is_wild)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_match)\n\t\trprintf(FLOG, \"No match for refuse-options string \\\"%s\\\"\\n\", ref);\n}\n\n\n/**\n * Tweak the option table to disable all options that the rsyncd.conf\n * file has told us to refuse.\n **/\nstatic void set_refuse_options(void)\n{\n\tstruct poptOption *op, *list_end = NULL;\n\tchar *cp, *ref = lp_refuse_options(module_id);\n\tint negated;\n\n\tif (!ref)\n\t\tref = \"\";\n\n\tif (!am_daemon)\n\t\tref = \"\";\n\n\t/* We abuse the descrip field in poptOption to make it easy to flag which options\n\t * are refused (since we don't use it otherwise).  Start by marking all options\n\t * as \"a\"ccepted with a few options also marked as non-wild. */\n\tfor (op = long_options; ; op++) {\n\t\tconst char *longName = op->longName ? op->longName : \"\";\n\t\tif (!op->longName && !op->shortName) {\n\t\t\tlist_end = op;\n\t\t\tbreak;\n\t\t}\n\t\tif (!am_daemon\n\t\t || op->shortName == 'e' /* Required for compatibility flags */\n\t\t || op->shortName == '0' /* --from0 just modifies --files-from, so refuse that instead (or not) */\n\t\t || op->shortName == 's' /* --secluded-args is always OK */\n\t\t || op->shortName == 'n' /* --dry-run is always OK */\n\t\t || strcmp(\"iconv\", longName) == 0\n\t\t || strcmp(\"no-iconv\", longName) == 0\n\t\t || strcmp(\"checksum-seed\", longName) == 0\n\t\t || strcmp(\"copy-devices\", longName) == 0 /* disable wild-match (it gets refused below) */\n\t\t || strcmp(\"write-devices\", longName) == 0 /* disable wild-match (it gets refused below) */\n\t\t || strcmp(\"log-format\", longName) == 0 /* aka out-format (NOT log-file-format) */\n\t\t || strcmp(\"sender\", longName) == 0\n\t\t || strcmp(\"server\", longName) == 0)\n\t\t\top->descrip = \"a=\"; /* exact-match only */\n\t\telse\n\t\t\top->descrip = \"a*\"; /* wild-card-able */\n\t}\n\tassert(list_end != NULL);\n\n\tif (am_daemon) { /* Refused by default, but can be accepted via a negated exact match. */\n\t\tparse_one_refuse_match(0, \"copy-devices\", list_end);\n\t\tparse_one_refuse_match(0, \"write-devices\", list_end);\n\t}\n\n\twhile (1) {\n\t\twhile (*ref == ' ') ref++;\n\t\tif (!*ref)\n\t\t\tbreak;\n\t\tif ((cp = strchr(ref, ' ')) != NULL)\n\t\t\t*cp = '\\0';\n\t\tnegated = *ref == '!';\n\t\tif (negated && ref[1])\n\t\t\tref++;\n\t\tparse_one_refuse_match(negated, ref, list_end);\n\t\tif (!cp)\n\t\t\tbreak;\n\t\t*cp = ' ';\n\t\tref = cp + 1;\n\t}\n\n\tif (am_daemon) {\n#ifdef ICONV_OPTION\n\t\tif (!*lp_charset(module_id))\n\t\t\tparse_one_refuse_match(0, \"iconv\", list_end);\n#endif\n\t\tparse_one_refuse_match(0, \"log-file*\", list_end);\n\t}\n\n#ifndef SUPPORT_ATIMES\n\tparse_one_refuse_match(0, \"atimes\", list_end);\n#endif\n#ifndef SUPPORT_HARD_LINKS\n\tparse_one_refuse_match(0, \"link-dest\", list_end);\n#endif\n#ifndef HAVE_MKTIME\n\tparse_one_refuse_match(0, \"stop-at\", list_end);\n#endif\n#ifndef ICONV_OPTION\n\tparse_one_refuse_match(0, \"iconv\", list_end);\n#endif\n#ifndef HAVE_SETVBUF\n\tparse_one_refuse_match(0, \"outbuf\", list_end);\n#endif\n#ifndef SUPPORT_CRTIMES\n\tparse_one_refuse_match(0, \"crtimes\", list_end);\n#endif\n\n\t/* Now we use the descrip values to actually mark the options for refusal. */\n\tfor (op = long_options; op != list_end; op++) {\n\t\tint refused = op->descrip[0] == 'r';\n\t\top->descrip = NULL;\n\t\tif (!refused)\n\t\t\tcontinue;\n\t\tif (op->argInfo == POPT_ARG_VAL)\n\t\t\top->argInfo = POPT_ARG_NONE;\n\t\top->val = (op - long_options) + OPT_REFUSED_BASE;\n\t\t/* The following flags are set to let us easily check an implied option later in the code. */\n\t\tswitch (op->shortName) {\n\t\tcase 'r': case 'd': case 'l': case 'p':\n\t\tcase 't': case 'g': case 'o': case 'D':\n\t\t\trefused_archive_part = op->val;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\trefused_compress = op->val;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif (strcmp(\"delete\", op->longName) == 0)\n\t\t\t\trefused_delete = op->val;\n\t\t\telse if (strcmp(\"delete-before\", op->longName) == 0)\n\t\t\t\trefused_delete_before = op->val;\n\t\t\telse if (strcmp(\"delete-during\", op->longName) == 0)\n\t\t\t\trefused_delete_during = op->val;\n\t\t\telse if (strcmp(\"partial\", op->longName) == 0)\n\t\t\t\trefused_partial = op->val;\n\t\t\telse if (strcmp(\"progress\", op->longName) == 0)\n\t\t\t\trefused_progress = op->val;\n\t\t\telse if (strcmp(\"inplace\", op->longName) == 0)\n\t\t\t\trefused_inplace = op->val;\n\t\t\telse if (strcmp(\"no-iconv\", op->longName) == 0)\n\t\t\t\trefused_no_iconv = op->val;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic int count_args(const char **argv)\n{\n\tint i = 0;\n\n\tif (argv) {\n\t\twhile (argv[i] != NULL)\n\t\t\ti++;\n\t}\n\n\treturn i;\n}\n\n/* If the size_arg is an invalid string or the value is < min_value, an error\n * is put into err_buf & the return is -1.  Note that this parser does NOT\n * support negative numbers, so a min_value < 0 doesn't make any sense. */\nstatic ssize_t parse_size_arg(const char *size_arg, char def_suf, const char *opt_name,\n\t\t\t      ssize_t min_value, ssize_t max_value, BOOL unlimited_0)\n{\n\tint reps, mult, len;\n\tconst char *arg, *err = \"invalid\", *min_max = NULL;\n\tssize_t limit = -1, size = 1;\n\n\tfor (arg = size_arg; isDigit(arg); arg++) {}\n\tif (*arg == '.' || *arg == get_decimal_point()) /* backward compatibility: always allow '.' */\n\t\tfor (arg++; isDigit(arg); arg++) {}\n\tswitch (*arg && *arg != '+' && *arg != '-' ? *arg++ : def_suf) {\n\tcase 'b': case 'B':\n\t\treps = 0;\n\t\tbreak;\n\tcase 'k': case 'K':\n\t\treps = 1;\n\t\tbreak;\n\tcase 'm': case 'M':\n\t\treps = 2;\n\t\tbreak;\n\tcase 'g': case 'G':\n\t\treps = 3;\n\t\tbreak;\n\tcase 't': case 'T':\n\t\treps = 4;\n\t\tbreak;\n\tcase 'p': case 'P':\n\t\treps = 5;\n\t\tbreak;\n\tdefault:\n\t\tgoto failure;\n\t}\n\tif (*arg == 'b' || *arg == 'B')\n\t\tmult = 1000, arg++;\n\telse if (!*arg || *arg == '+' || *arg == '-')\n\t\tmult = 1024;\n\telse if (strncasecmp(arg, \"ib\", 2) == 0)\n\t\tmult = 1024, arg += 2;\n\telse\n\t\tgoto failure;\n\twhile (reps--)\n\t\tsize *= mult;\n\tsize *= atof(size_arg);\n\tif ((*arg == '+' || *arg == '-') && arg[1] == '1' && arg != size_arg)\n\t\tsize += atoi(arg), arg += 2;\n\tif (*arg)\n\t\tgoto failure;\n\tif (size < 0 || (max_value >= 0 && size > max_value)) {\n\t\terr = \"too large\";\n\t\tmin_max = \"max\";\n\t\tlimit = max_value;\n\t\tgoto failure;\n\t}\n\tif (size < min_value && (!unlimited_0 || size != 0)) {\n\t\terr = \"too small\";\n\t\tmin_max = \"min\";\n\t\tlimit = min_value;\n\t\tgoto failure;\n\t}\n\treturn size;\n\nfailure:\n\tlen = snprintf(err_buf, sizeof err_buf - 1, \"--%s=%s is %s\", opt_name, size_arg, err);\n\tif (min_max && limit >= 0 && len < (int)sizeof err_buf - 10) {\n\t\tlen += snprintf(err_buf + len, sizeof err_buf - len - 1, \" (%s: %s%s)\",\n\t\t\tmin_max, do_big_num(limit, 3, NULL),\n\t\t\tunlimited_0 && min_max[1] == 'i' ? \" or 0 for unlimited\" : \"\");\n\t}\n\terr_buf[len] = '\\n';\n\terr_buf[len+1] = '\\0';\n\treturn -1;\n}\n\n#ifdef HAVE_MKTIME\n/* Allow the user to specify a time in the format yyyy-mm-ddThh:mm while\n * also allowing abbreviated data.  For instance, if the time is omitted,\n * it defaults to midnight.  If the date is omitted, it defaults to the\n * next possible date in the future with the specified time.  Even the\n * year or year-month can be omitted, again defaulting to the next date\n * in the future that matches the specified information.  A 2-digit year\n * is also OK, as is using '/' instead of '-'. */\nstatic time_t parse_time(const char *arg)\n{\n\tconst char *cp;\n\ttime_t val, now = time(NULL);\n\tstruct tm t, *today = localtime(&now);\n\tint in_date, old_mday, n;\n\n\tmemset(&t, 0, sizeof t);\n\tt.tm_year = t.tm_mon = t.tm_mday = -1;\n\tt.tm_hour = t.tm_min = t.tm_isdst = -1;\n\tcp = arg;\n\tif (*cp == 'T' || *cp == 't' || *cp == ':') {\n\t\tin_date = *cp == ':' ? 0 : -1;\n\t\tcp++;\n\t} else\n\t\tin_date = 1;\n\tfor ( ; ; cp++) {\n\t\tif (!isDigit(cp))\n\t\t\treturn (time_t)-1;\n\t\tn = 0;\n\t\tdo {\n\t\t\tn = n * 10 + *cp++ - '0';\n\t\t} while (isDigit(cp));\n\t\tif (*cp == ':')\n\t\t\tin_date = 0;\n\t\tif (in_date > 0) {\n\t\t\tif (t.tm_year != -1)\n\t\t\t\treturn (time_t)-1;\n\t\t\tt.tm_year = t.tm_mon;\n\t\t\tt.tm_mon = t.tm_mday;\n\t\t\tt.tm_mday = n;\n\t\t\tif (!*cp)\n\t\t\t\tbreak;\n\t\t\tif (*cp == 'T' || *cp == 't') {\n\t\t\t\tif (!cp[1])\n\t\t\t\t\tbreak;\n\t\t\t\tin_date = -1;\n\t\t\t} else if (*cp != '-' && *cp != '/')\n\t\t\t\treturn (time_t)-1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (t.tm_hour != -1)\n\t\t\treturn (time_t)-1;\n\t\tt.tm_hour = t.tm_min;\n\t\tt.tm_min = n;\n\t\tif (!*cp) {\n\t\t\tif (in_date < 0)\n\t\t\t\treturn (time_t)-1;\n\t\t\tbreak;\n\t\t}\n\t\tif (*cp != ':')\n\t\t\treturn (time_t)-1;\n\t\tin_date = 0;\n\t}\n\n\tin_date = 0;\n\tif (t.tm_year < 0) {\n\t\tt.tm_year = today->tm_year;\n\t\tin_date = 1;\n\t} else if (t.tm_year < 100) {\n\t\twhile (t.tm_year < today->tm_year)\n\t\t\tt.tm_year += 100;\n\t} else\n\t\tt.tm_year -= 1900;\n\tif (t.tm_mon < 0) {\n\t\tt.tm_mon = today->tm_mon;\n\t\tin_date = 2;\n\t} else\n\t\tt.tm_mon--;\n\tif (t.tm_mday < 0) {\n\t\tt.tm_mday = today->tm_mday;\n\t\tin_date = 3;\n\t}\n\n\tn = 0;\n\tif (t.tm_min < 0) {\n\t\tt.tm_hour = t.tm_min = 0;\n\t} else if (t.tm_hour < 0) {\n\t\tif (in_date != 3)\n\t\t\treturn (time_t)-1;\n\t\tin_date = 0;\n\t\tt.tm_hour = today->tm_hour;\n\t\tn = 60*60;\n\t}\n\n\t/* Note that mktime() might change a too-large tm_mday into the start of\n\t * the following month which we need to undo in the following code! */\n\told_mday = t.tm_mday;\n\tif (t.tm_hour > 23 || t.tm_min > 59\n\t    || t.tm_mon < 0 || t.tm_mon >= 12\n\t    || t.tm_mday < 1 || t.tm_mday > 31\n\t    || (val = mktime(&t)) == (time_t)-1)\n\t\treturn (time_t)-1;\n\n\twhile (in_date && (val <= now || t.tm_mday < old_mday)) {\n\t\tswitch (in_date) {\n\t\tcase 3:\n\t\t\told_mday = ++t.tm_mday;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (t.tm_mday < old_mday)\n\t\t\t\tt.tm_mday = old_mday; /* The month already got bumped forward */\n\t\t\telse if (++t.tm_mon == 12) {\n\t\t\t\tt.tm_mon = 0;\n\t\t\t\tt.tm_year++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (t.tm_mday < old_mday) {\n\t\t\t\t/* mon==1 mday==29 got bumped to mon==2 */\n\t\t\t\tif (t.tm_mon != 2 || old_mday != 29)\n\t\t\t\t\treturn (time_t)-1;\n\t\t\t\tt.tm_mon = 1;\n\t\t\t\tt.tm_mday = 29;\n\t\t\t}\n\t\t\tt.tm_year++;\n\t\t\tbreak;\n\t\t}\n\t\tif ((val = mktime(&t)) == (time_t)-1) {\n\t\t\t/* This code shouldn't be needed, as mktime() should auto-round to the next month. */\n\t\t\tif (in_date != 3 || t.tm_mday <= 28)\n\t\t\t\treturn (time_t)-1;\n\t\t\tt.tm_mday = old_mday = 1;\n\t\t\tin_date = 2;\n\t\t}\n\t}\n\tif (n) {\n\t\twhile (val <= now)\n\t\t\tval += n;\n\t}\n\treturn val;\n}\n#endif\n\nstatic void create_refuse_error(int which)\n{\n\tconst char *msg;\n\tif (am_daemon)\n\t\tmsg = \"The server is configured to refuse\";\n\telse if (am_server)\n\t\tmsg = \"The server does not support\";\n\telse\n\t\tmsg = \"This rsync does not support\";\n\n\t/* The \"which\" value is the index + OPT_REFUSED_BASE. */\n\tstruct poptOption *op = &long_options[which - OPT_REFUSED_BASE];\n\tint n = snprintf(err_buf, sizeof err_buf, \"%s --%s\\n\", msg, op->longName) - 1;\n\tif (op->shortName)\n\t\tsnprintf(err_buf + n, sizeof err_buf - n, \" (-%c)\\n\", op->shortName);\n}\n\n/* This is used to make sure that --daemon & --server cannot be aliased to\n * something else. These options have always disabled popt aliases for the\n * parsing of a daemon or server command-line, but we have to make sure that\n * these options cannot vanish so that the alias disabling can take effect. */\nstatic void popt_unalias(poptContext con, const char *opt)\n{\n\tstruct poptAlias unalias;\n\n\tmemset(&unalias, 0, sizeof unalias);\n\n\tunalias.longName = opt + 2; /* point past the leading \"--\" */\n\tunalias.argc = 1;\n\tunalias.argv = new_array0(const char*, 2);\n\tunalias.argv[0] = strdup(opt);\n\n\tpoptAddAlias(con, unalias, 0);\n}\n\nchar *alt_dest_opt(int type)\n{\n\tif (!type)\n\t\ttype = alt_dest_type;\n\n\tswitch (type) {\n\tcase COMPARE_DEST:\n\t\treturn \"--compare-dest\";\n\tcase COPY_DEST:\n\t\treturn \"--copy-dest\";\n\tcase LINK_DEST:\n\t\treturn \"--link-dest\";\n\tdefault:\n\t\tNOISY_DEATH(\"Unknown alt_dest_opt type\");\n\t}\n}\n\n/**\n * Process command line arguments.  Called on both local and remote.\n *\n * @retval 1 if all options are OK; with globals set to appropriate\n * values\n *\n * @retval 0 on error, with err_buf containing an explanation\n **/\nint parse_arguments(int *argc_p, const char ***argv_p)\n{\n\tpoptContext pc;\n\tconst char *arg, **argv = *argv_p;\n\tint argc = *argc_p;\n\tint opt, want_dest_type;\n\tint orig_protect_args = protect_args;\n\n\tif (argc == 0) {\n\t\tstrlcpy(err_buf, \"argc is zero!\\n\", sizeof err_buf);\n\t\treturn 0;\n\t}\n\n\tset_refuse_options();\n\n#ifdef ICONV_OPTION\n\tif (!am_daemon && protect_args <= 0 && (arg = getenv(\"RSYNC_ICONV\")) != NULL && *arg)\n\t\ticonv_opt = strdup(arg);\n#endif\n\n\t/* TODO: Call poptReadDefaultConfig; handle errors. */\n\n\tpc = poptGetContext(RSYNC_NAME, argc, argv, long_options, 0);\n\tif (!am_server) {\n\t\tpoptReadDefaultConfig(pc, 0);\n\t\tpopt_unalias(pc, \"--daemon\");\n\t\tpopt_unalias(pc, \"--server\");\n\t}\n\n\twhile ((opt = poptGetNextOpt(pc)) != -1) {\n\t\t/* most options are handled automatically by popt;\n\t\t * only special cases are returned and listed here. */\n\n\t\tswitch (opt) {\n\t\tcase 'V':\n\t\t\tversion_opt_cnt++;\n\t\t\tbreak;\n\n\t\tcase OPT_SERVER:\n\t\t\tif (!am_server) {\n\t\t\t\t/* Disable popt aliases on the server side and\n\t\t\t\t * then start parsing the options again. */\n\t\t\t\tpoptFreeContext(pc);\n\t\t\t\tpc = poptGetContext(RSYNC_NAME, argc, argv, long_options, 0);\n\t\t\t\tam_server = 1;\n\t\t\t}\n#ifdef ICONV_OPTION\n\t\t\ticonv_opt = NULL;\n#endif\n\t\t\tbreak;\n\n\t\tcase OPT_SENDER:\n\t\t\tif (!am_server) {\n\t\t\t\tusage(FERROR);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tam_sender = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_DAEMON:\n\t\t\tif (am_daemon) {\n\t\t\t\tstrlcpy(err_buf,\n\t\t\t\t\t\"Attempt to hack rsync thwarted!\\n\",\n\t\t\t\t\tsizeof err_buf);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n#ifdef ICONV_OPTION\n\t\t\ticonv_opt = NULL;\n#endif\n\t\t\tprotect_args = 0;\n\t\t\tpoptFreeContext(pc);\n\t\t\tpc = poptGetContext(RSYNC_NAME, argc, argv, long_daemon_options, 0);\n\t\t\twhile ((opt = poptGetNextOpt(pc)) != -1) {\n\t\t\t\tchar **cpp;\n\t\t\t\tswitch (opt) {\n\t\t\t\tcase 'h':\n\t\t\t\t\tdaemon_usage(FINFO);\n\t\t\t\t\texit_cleanup(0);\n\n\t\t\t\tcase 'M':\n\t\t\t\t\targ = poptGetOptArg(pc);\n\t\t\t\t\tif (!strchr(arg, '=')) {\n\t\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\t\"--dparam value is missing an '=': %s\\n\",\n\t\t\t\t\t\t\targ);\n\t\t\t\t\t\tgoto daemon_error;\n\t\t\t\t\t}\n\t\t\t\t\tcpp = EXPAND_ITEM_LIST(&dparam_list, char *, 4);\n\t\t\t\t\t*cpp = strdup(arg);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'v':\n\t\t\t\t\tverbose++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"rsync: %s: %s (in daemon mode)\\n\",\n\t\t\t\t\t\tpoptBadOption(pc, POPT_BADOPTION_NOALIAS),\n\t\t\t\t\t\tpoptStrerror(opt));\n\t\t\t\t\tgoto daemon_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dparam_list.count && !set_dparams(1))\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\n\t\t\tif (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t \"the --temp-dir path is WAY too long.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (!daemon_opt) {\n\t\t\t\trprintf(FERROR, \"Daemon option(s) used without --daemon.\\n\");\n\t\t\t    daemon_error:\n\t\t\t\trprintf(FERROR, \"(Type \\\"rsync --daemon --help\\\" for assistance with daemon mode.)\\n\");\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\n\t\t\targv = poptGetArgs(pc);\n\t\t\targc = count_args(argv);\n\t\t\tif (!argc) {\n\t\t\t\t*argv_p = empty_argv;\n\t\t\t\t*argc_p = 0;\n\t\t\t} else if (poptDupArgv(argc, argv, argc_p, argv_p) != 0)\n\t\t\t\tout_of_memory(\"parse_arguments\");\n\t\t\targv = *argv_p;\n\t\t\tpoptFreeContext(pc);\n\n\t\t\tam_starting_up = 0;\n\t\t\tdaemon_opt = 0;\n\t\t\tam_daemon = 1;\n\t\t\treturn 1;\n\n\t\tcase OPT_MODIFY_WINDOW:\n\t\t\t/* The value has already been set by popt, but\n\t\t\t * we need to remember that we're using a\n\t\t\t * non-default setting. */\n\t\t\tmodify_window_set = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_FILTER:\n\t\t\tparse_filter_str(&filter_list, poptGetOptArg(pc),\n\t\t\t\t\trule_template(0), 0);\n\t\t\tbreak;\n\n\t\tcase OPT_EXCLUDE:\n\t\t\tparse_filter_str(&filter_list, poptGetOptArg(pc),\n\t\t\t\t\trule_template(0), XFLG_OLD_PREFIXES);\n\t\t\tbreak;\n\n\t\tcase OPT_INCLUDE:\n\t\t\tparse_filter_str(&filter_list, poptGetOptArg(pc),\n\t\t\t\t\trule_template(FILTRULE_INCLUDE), XFLG_OLD_PREFIXES);\n\t\t\tbreak;\n\n\t\tcase OPT_EXCLUDE_FROM:\n\t\tcase OPT_INCLUDE_FROM:\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tif (sanitize_paths)\n\t\t\t\targ = sanitize_path(NULL, arg, NULL, 0, SP_DEFAULT);\n\t\t\tif (daemon_filter_list.head) {\n\t\t\t\tint rej;\n\t\t\t\tchar *cp = strdup(arg);\n\t\t\t\tif (!*cp)\n\t\t\t\t\trej = 1;\n\t\t\t\telse {\n\t\t\t\t\tchar *dir = cp + (*cp == '/' ? module_dirlen : 0);\n\t\t\t\t\tclean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t\t\t\t\trej = check_filter(&daemon_filter_list, FLOG, dir, 0) < 0;\n\t\t\t\t}\n\t\t\t\tfree(cp);\n\t\t\t\tif (rej)\n\t\t\t\t\tgoto options_rejected;\n\t\t\t}\n\t\t\tparse_filter_file(&filter_list, arg,\n\t\t\t\trule_template(opt == OPT_INCLUDE_FROM ? FILTRULE_INCLUDE : 0),\n\t\t\t\tXFLG_FATAL_ERRORS | XFLG_OLD_PREFIXES);\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tif (refused_archive_part) {\n\t\t\t\tcreate_refuse_error(refused_archive_part);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!recurse) /* preserve recurse == 2 */\n\t\t\t\trecurse = 1;\n#ifdef SUPPORT_LINKS\n\t\t\tpreserve_links = 1;\n#endif\n\t\t\tpreserve_perms = 1;\n\t\t\tpreserve_mtimes = 1;\n\t\t\tpreserve_gid = 1;\n\t\t\tpreserve_uid = 1;\n\t\t\tpreserve_devices = 1;\n\t\t\tpreserve_specials = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tpreserve_devices = preserve_specials = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_NO_D:\n\t\t\tpreserve_devices = preserve_specials = 0;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\thuman_readable++;\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\tpreserve_hard_links++;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\titemize_changes++;\n\t\t\tbreak;\n\n\t\tcase 'U':\n\t\t\tif (++preserve_atimes > 1)\n\t\t\t\topen_noatime = 1;\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tfuzzy_basis++;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\tquiet++;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tone_file_system++;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tswitch (++F_option_cnt) {\n\t\t\tcase 1:\n\t\t\t\tparse_filter_str(&filter_list,\": /.rsync-filter\",rule_template(0),0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparse_filter_str(&filter_list,\"- .rsync-filter\",rule_template(0),0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'P':\n\t\t\tif (refused_partial || refused_progress) {\n\t\t\t\tcreate_refuse_error(refused_partial ? refused_partial : refused_progress);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tdo_progress = 1;\n\t\t\tkeep_partial = 1;\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\t\tdo_compression++;\n\t\t\tbreak;\n\n\t\tcase OPT_OLD_COMPRESS:\n\t\t\tcompress_choice = \"zlib\";\n\t\t\tbreak;\n\n\t\tcase OPT_NEW_COMPRESS:\n\t\t\tcompress_choice = \"zlibx\";\n\t\t\tbreak;\n\n\t\tcase OPT_NO_COMPRESS:\n\t\t\tdo_compression = 0;\n\t\t\tcompress_choice = NULL;\n\t\t\tbreak;\n\n\t\tcase OPT_OLD_ARGS:\n\t\t\tif (old_style_args <= 0)\n\t\t\t\told_style_args = 1;\n\t\t\telse\n\t\t\t\told_style_args++;\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tif (*arg != '-') {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"Remote option must start with a dash: %s\\n\", arg);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (remote_option_cnt+2 >= remote_option_alloc) {\n\t\t\t\tremote_option_alloc += 16;\n\t\t\t\tremote_options = realloc_array(remote_options,\n\t\t\t\t\t\t\tconst char *, remote_option_alloc);\n\t\t\t\tif (!remote_option_cnt)\n\t\t\t\t\tremote_options[0] = \"ARG0\";\n\t\t\t}\n\t\t\tremote_options[++remote_option_cnt] = arg;\n\t\t\tremote_options[remote_option_cnt+1] = NULL;\n\t\t\tbreak;\n\n\t\tcase OPT_WRITE_BATCH:\n\t\t\t/* batch_name is already set */\n\t\t\twrite_batch = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_ONLY_WRITE_BATCH:\n\t\t\t/* batch_name is already set */\n\t\t\twrite_batch = -1;\n\t\t\tbreak;\n\n\t\tcase OPT_READ_BATCH:\n\t\t\t/* batch_name is already set */\n\t\t\tread_batch = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_NO_ICONV:\n#ifdef ICONV_OPTION\n\t\t\ticonv_opt = NULL;\n#endif\n\t\t\tbreak;\n\n\t\tcase OPT_BLOCK_SIZE: {\n\t\t\t/* We may not know the real protocol_version at this point if this is the client\n\t\t\t * option parsing, but we still want to check it so that the client can specify\n\t\t\t * a --protocol=29 option with a larger block size. */\n\t\t\tint max_blength = protocol_version < 30 ? OLD_MAX_BLOCK_SIZE : MAX_BLOCK_SIZE;\n\t\t\tssize_t size;\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tif ((size = parse_size_arg(arg, 'b', \"block-size\", 0, max_blength, False)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t\tblock_size = (int32)size;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OPT_MAX_SIZE:\n\t\t\tif ((max_size = parse_size_arg(max_size_arg, 'b', \"max-size\", 0, -1, False)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t\tmax_size_arg = strdup(do_big_num(max_size, 0, NULL));\n\t\t\tbreak;\n\n\t\tcase OPT_MIN_SIZE:\n\t\t\tif ((min_size = parse_size_arg(min_size_arg, 'b', \"min-size\", 0, -1, False)) < 0)\n\t\t\t\tgoto cleanup;\n\t\t\tmin_size_arg = strdup(do_big_num(min_size, 0, NULL));\n\t\t\tbreak;\n\n\t\tcase OPT_BWLIMIT: {\n\t\t\tssize_t size = parse_size_arg(bwlimit_arg, 'K', \"bwlimit\", 512, -1, True);\n\t\t\tif (size < 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbwlimit_arg = strdup(do_big_num(size, 0, NULL));\n\t\t\tbwlimit = (size + 512) / 1024;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OPT_APPEND:\n\t\t\tif (am_server)\n\t\t\t\tappend_mode++;\n\t\t\telse\n\t\t\t\tappend_mode = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_LINK_DEST:\n\t\t\twant_dest_type = LINK_DEST;\n\t\t\tgoto set_dest_dir;\n\n\t\tcase OPT_COPY_DEST:\n\t\t\twant_dest_type = COPY_DEST;\n\t\t\tgoto set_dest_dir;\n\n\t\tcase OPT_COMPARE_DEST:\n\t\t\twant_dest_type = COMPARE_DEST;\n\n\t\tset_dest_dir:\n\t\t\tif (alt_dest_type && alt_dest_type != want_dest_type) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"ERROR: the %s option conflicts with the %s option\\n\",\n\t\t\t\t\talt_dest_opt(want_dest_type), alt_dest_opt(0));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\talt_dest_type = want_dest_type;\n\n\t\t\tif (basis_dir_cnt >= MAX_BASIS_DIRS) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"ERROR: at most %d %s args may be specified\\n\",\n\t\t\t\t\tMAX_BASIS_DIRS, alt_dest_opt(0));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* We defer sanitizing this arg until we know what\n\t\t\t * our destination directory is going to be. */\n\t\t\tbasis_dir[basis_dir_cnt++] = (char *)poptGetOptArg(pc);\n\t\t\tbreak;\n\n\t\tcase OPT_CHMOD:\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tif (!parse_chmod(arg, &chmod_modes)) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"Invalid argument passed to --chmod (%s)\\n\",\n\t\t\t\t\targ);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_INFO:\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tparse_output_words(info_words, info_levels, arg, USER_PRIORITY);\n\t\t\tbreak;\n\n\t\tcase OPT_DEBUG:\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tparse_output_words(debug_words, debug_levels, arg, USER_PRIORITY);\n\t\t\tbreak;\n\n\t\tcase OPT_USERMAP:\n\t\t\tif (usermap) {\n\t\t\t\tif (usermap_via_chown) {\n\t\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\t\"--usermap conflicts with prior --chown.\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"You can only specify --usermap once.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tusermap = (char *)poptGetOptArg(pc);\n\t\t\tusermap_via_chown = False;\n\t\t\tpreserve_uid = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_GROUPMAP:\n\t\t\tif (groupmap) {\n\t\t\t\tif (groupmap_via_chown) {\n\t\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\t\"--groupmap conflicts with prior --chown.\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"You can only specify --groupmap once.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tgroupmap = (char *)poptGetOptArg(pc);\n\t\t\tgroupmap_via_chown = False;\n\t\t\tpreserve_gid = 1;\n\t\t\tbreak;\n\n\t\tcase OPT_CHOWN: {\n\t\t\tconst char *chown = poptGetOptArg(pc);\n\t\t\tint len;\n\t\t\tif ((arg = strchr(chown, ':')) != NULL)\n\t\t\t\tlen = arg++ - chown;\n\t\t\telse\n\t\t\t\tlen = strlen(chown);\n\t\t\tif (len) {\n\t\t\t\tif (usermap) {\n\t\t\t\t\tif (!usermap_via_chown) {\n\t\t\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\t\t\"--chown conflicts with prior --usermap.\\n\");\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\t\"You can only specify a user-affecting --chown once.\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (asprintf(&usermap, \"*:%.*s\", len, chown) < 0)\n\t\t\t\t\tout_of_memory(\"parse_arguments\");\n\t\t\t\tusermap_via_chown = True;\n\t\t\t\tpreserve_uid = 1;\n\t\t\t}\n\t\t\tif (arg && *arg) {\n\t\t\t\tif (groupmap) {\n\t\t\t\t\tif (!groupmap_via_chown) {\n\t\t\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\t\t\"--chown conflicts with prior --groupmap.\\n\");\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\t\"You can only specify a group-affecting --chown once.\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (asprintf(&groupmap, \"*:%s\", arg) < 0)\n\t\t\t\t\tout_of_memory(\"parse_arguments\");\n\t\t\t\tgroupmap_via_chown = True;\n\t\t\t\tpreserve_gid = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OPT_HELP:\n\t\t\tusage(FINFO);\n\t\t\texit_cleanup(0);\n\n\t\tcase 'A':\n#ifdef SUPPORT_ACLS\n\t\t\tpreserve_acls = 1;\n\t\t\tpreserve_perms = 1;\n\t\t\tbreak;\n#else\n\t\t\t/* FIXME: this should probably be ignored with a\n\t\t\t * warning and then countermeasures taken to\n\t\t\t * restrict group and other access in the presence\n\t\t\t * of any more restrictive ACLs, but this is safe\n\t\t\t * for now */\n\t\t\tsnprintf(err_buf,sizeof(err_buf),\n\t\t\t\t \"ACLs are not supported on this %s\\n\",\n\t\t\t\t am_server ? \"server\" : \"client\");\n\t\t\tgoto cleanup;\n#endif\n\n\t\tcase 'X':\n#ifdef SUPPORT_XATTRS\n\t\t\tpreserve_xattrs++;\n\t\t\tbreak;\n#else\n\t\t\tsnprintf(err_buf,sizeof(err_buf),\n\t\t\t\t \"extended attributes are not supported on this %s\\n\",\n\t\t\t\t am_server ? \"server\" : \"client\");\n\t\t\tgoto cleanup;\n#endif\n\n\t\tcase OPT_STOP_AFTER: {\n\t\t\tlong val;\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tstop_at_utime = time(NULL);\n\t\t\tif ((val = atol(arg) * 60) <= 0 || LONG_MAX - val < stop_at_utime || (long)(time_t)val != val) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf, \"invalid --stop-after value: %s\\n\", arg);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tstop_at_utime += val;\n\t\t\tbreak;\n\t\t}\n\n#ifdef HAVE_MKTIME\n\t\tcase OPT_STOP_AT:\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tif ((stop_at_utime = parse_time(arg)) == (time_t)-1) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf, \"invalid --stop-at format: %s\\n\", arg);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (stop_at_utime <= time(NULL)) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf, \"--stop-at time is not in the future: %s\\n\", arg);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tcase OPT_STDERR: {\n\t\t\tint len;\n\t\t\targ = poptGetOptArg(pc);\n\t\t\tlen = strlen(arg);\n\t\t\tif (len && strncmp(\"errors\", arg, len) == 0)\n\t\t\t\tmsgs2stderr = 2;\n\t\t\telse if (len && strncmp(\"all\", arg, len) == 0)\n\t\t\t\tmsgs2stderr = 1;\n\t\t\telse if (len && strncmp(\"client\", arg, len) == 0)\n\t\t\t\tmsgs2stderr = 0;\n\t\t\telse {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"--stderr mode \\\"%s\\\" is not one of errors, all, or client\\n\", arg);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tsaw_stderr_opt = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\t/* A large opt value means that set_refuse_options()\n\t\t\t * turned this option off. */\n\t\t\tif (opt >= OPT_REFUSED_BASE) {\n\t\t\t\tcreate_refuse_error(opt);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tsnprintf(err_buf, sizeof err_buf, \"%s%s: %s\\n\",\n\t\t\t\t am_server ? \"on remote machine: \" : \"\",\n\t\t\t\t poptBadOption(pc, POPT_BADOPTION_NOALIAS),\n\t\t\t\t poptStrerror(opt));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (msgs2stderr != 2)\n\t\tsaw_stderr_opt = 1;\n\n\tif (version_opt_cnt) {\n\t\tprint_rsync_version(version_opt_cnt > 1 && !am_server ? FNONE : FINFO);\n\t\texit_cleanup(0);\n\t}\n\n\tif (!max_alloc_arg) {\n\t\tmax_alloc_arg = getenv(\"RSYNC_MAX_ALLOC\");\n\t\tif (max_alloc_arg && !*max_alloc_arg)\n\t\t\tmax_alloc_arg = NULL;\n\t}\n\tif (max_alloc_arg) {\n\t\tssize_t size = parse_size_arg(max_alloc_arg, 'B', \"max-alloc\", 1024*1024, -1, True);\n\t\tif (size < 0)\n\t\t\tgoto cleanup;\n\t\tmax_alloc = size;\n\t}\n\tif (!max_alloc)\n\t\tmax_alloc = SIZE_MAX;\n\n\tif (old_style_args < 0) {\n\t\tif (!am_server && protect_args <= 0 && (arg = getenv(\"RSYNC_OLD_ARGS\")) != NULL && *arg) {\n\t\t\tprotect_args = 0;\n\t\t\told_style_args = atoi(arg);\n\t\t} else\n\t\t\told_style_args = 0;\n\t} else if (old_style_args) {\n\t\tif (protect_args > 0) {\n\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t \"--secluded-args conflicts with --old-args.\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\tprotect_args = 0;\n\t}\n\n\tif (protect_args < 0) {\n\t\tif (am_server)\n\t\t\tprotect_args = 0;\n\t\telse if ((arg = getenv(\"RSYNC_PROTECT_ARGS\")) != NULL && *arg)\n\t\t\tprotect_args = atoi(arg) ? 1 : 0;\n\t\telse {\n#ifdef RSYNC_USE_SECLUDED_ARGS\n\t\t\tprotect_args = 1;\n#else\n\t\t\tprotect_args = 0;\n#endif\n\t\t}\n\t}\n\n\tif (checksum_choice && strcasecmp(checksum_choice, \"auto\") != 0 && strcasecmp(checksum_choice, \"auto,auto\") != 0) {\n\t\t/* Call this early to verify the args and figure out if we need to force\n\t\t * --whole-file. Note that the parse function will get called again later,\n\t\t * just in case an \"auto\" choice needs to know the protocol_version. */\n\t\tparse_checksum_choice(0);\n\t} else\n\t\tchecksum_choice = NULL;\n\n\tif (human_readable > 1 && argc == 2 && !am_server) {\n\t\t/* Allow the old meaning of 'h' (--help) on its own. */\n\t\tusage(FINFO);\n\t\texit_cleanup(0);\n\t}\n\n\tif (!compress_choice && do_compression > 1)\n\t\tcompress_choice = \"zlibx\";\n\tif (compress_choice && strcasecmp(compress_choice, \"auto\") != 0)\n\t\tparse_compress_choice(0); /* Twiddles do_compression and can possibly NULL-out compress_choice. */\n\telse\n\t\tcompress_choice = NULL;\n\n\tif (do_compression || do_compression_level != CLVL_NOT_SPECIFIED) {\n\t\tif (!do_compression)\n\t\t\tdo_compression = CPRES_AUTO;\n\t\tif (do_compression && refused_compress) {\n\t\t\tcreate_refuse_error(refused_compress);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n#ifdef HAVE_SETVBUF\n\tif (outbuf_mode && !am_server) {\n\t\tint mode = *(uchar *)outbuf_mode;\n\t\tif (islower(mode))\n\t\t\tmode = toupper(mode);\n\t\tfflush(stdout); /* Just in case... */\n\t\tswitch (mode) {\n\t\tcase 'N': /* None */\n\t\tcase 'U': /* Unbuffered */\n\t\t\tmode = _IONBF;\n\t\t\tbreak;\n\t\tcase 'L': /* Line */\n\t\t\tmode = _IOLBF;\n\t\t\tbreak;\n\t\tcase 'B': /* Block */\n\t\tcase 'F': /* Full */\n\t\t\tmode = _IOFBF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\"Invalid --outbuf setting -- specify N, L, or B.\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\tsetvbuf(stdout, (char *)NULL, mode, 0);\n\t}\n\n\tif (msgs2stderr == 1) { /* Are all messages going to stderr? */\n\t\t/* Make stderr line buffered for better sharing of the stream. */\n\t\tfflush(stderr); /* Just in case... */\n\t\tsetvbuf(stderr, (char *)NULL, _IOLBF, 0);\n\t}\n#endif\n\n\tset_output_verbosity(verbose, DEFAULT_PRIORITY);\n\n\tif (do_stats) {\n\t\tparse_output_words(info_words, info_levels,\n\t\t\tverbose > 1 ? \"stats3\" : \"stats2\", DEFAULT_PRIORITY);\n\t}\n\n#ifdef ICONV_OPTION\n\tif (iconv_opt && protect_args != 2) {\n\t\tif (!am_server && strcmp(iconv_opt, \"-\") == 0)\n\t\t\ticonv_opt = NULL;\n\t\telse\n\t\t\tneed_unsorted_flist = 1;\n\t}\n\tif (refused_no_iconv && !iconv_opt) {\n\t\tcreate_refuse_error(refused_no_iconv);\n\t\tgoto cleanup;\n\t}\n#endif\n\n\tif (fuzzy_basis > 1)\n\t\tfuzzy_basis = basis_dir_cnt + 1;\n\n\t/* Don't let the client reset protect_args if it was already processed */\n\tif (orig_protect_args == 2 && am_server)\n\t\tprotect_args = orig_protect_args;\n\n\tif (protect_args == 1 && am_server) {\n\t\tpoptFreeContext(pc);\n\t\treturn 1;\n\t}\n\n\t/* Because popt 1.19 has started to free the returned args data, we now\n\t * make a copy of the array and then do an immediate cleanup. */\n\targv = poptGetArgs(pc);\n\targc = count_args(argv);\n\tif (!argc) {\n\t\t*argv_p = empty_argv;\n\t\t*argc_p = 0;\n\t} else if (poptDupArgv(argc, argv, argc_p, argv_p) != 0)\n\t\tout_of_memory(\"parse_arguments\");\n\targv = *argv_p;\n\tpoptFreeContext(pc);\n\tpc = NULL;\n\n#ifndef SUPPORT_LINKS\n\tif (preserve_links && !am_sender) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t \"symlinks are not supported on this %s\\n\",\n\t\t\t am_server ? \"server\" : \"client\");\n\t\tgoto cleanup;\n\t}\n#endif\n\n#ifndef SUPPORT_HARD_LINKS\n\tif (preserve_hard_links) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t \"hard links are not supported on this %s\\n\",\n\t\t\t am_server ? \"server\" : \"client\");\n\t\tgoto cleanup;\n\t}\n#endif\n\n#ifdef SUPPORT_XATTRS\n\tif (am_root < 0 && preserve_xattrs > 1) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t \"--fake-super conflicts with -XX\\n\");\n\t\tgoto cleanup;\n\t}\n#else\n\tif (am_root < 0) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t \"--fake-super requires an rsync with extended attributes enabled\\n\");\n\t\tgoto cleanup;\n\t}\n#endif\n\n\tif (write_batch && read_batch) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"--write-batch and --read-batch can not be used together\\n\");\n\t\tgoto cleanup;\n\t}\n\tif (write_batch > 0 || read_batch) {\n\t\tif (am_server) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"ignoring --%s-batch option sent to server\\n\",\n\t\t\t\twrite_batch ? \"write\" : \"read\");\n\t\t\t/* We don't actually exit_cleanup(), so that we can\n\t\t\t * still service older version clients that still send\n\t\t\t * batch args to server. */\n\t\t\tread_batch = write_batch = 0;\n\t\t\tbatch_name = NULL;\n\t\t} else if (dry_run)\n\t\t\twrite_batch = 0;\n\t} else if (write_batch < 0 && dry_run)\n\t\twrite_batch = 0;\n\tif (read_batch && files_from) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"--read-batch cannot be used with --files-from\\n\");\n\t\tgoto cleanup;\n\t}\n\tif (read_batch && remove_source_files) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"--read-batch cannot be used with --remove-%s-files\\n\",\n\t\t\tremove_source_files == 1 ? \"source\" : \"sent\");\n\t\tgoto cleanup;\n\t}\n\tif (batch_name && strlen(batch_name) > MAX_BATCH_NAME_LEN) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"the batch-file name must be %d characters or less.\\n\",\n\t\t\tMAX_BATCH_NAME_LEN);\n\t\tgoto cleanup;\n\t}\n\n\tif (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t \"the --temp-dir path is WAY too long.\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tif (max_delete < 0 && max_delete != INT_MIN) {\n\t\t/* Negative numbers are treated as \"no deletions\". */\n\t\tmax_delete = 0;\n\t}\n\n\tif (files_from) {\n\t\tif (recurse == 1) /* preserve recurse == 2 */\n\t\t\trecurse = 0;\n\t\tif (xfer_dirs < 0)\n\t\t\txfer_dirs = 1;\n\t}\n\n\tif (argc < 2 && !read_batch && !am_server)\n\t\tlist_only |= 1;\n\n\tif (xfer_dirs >= 4) {\n\t\tparse_filter_str(&filter_list, \"- /*/*\", rule_template(0), 0);\n\t\trecurse = xfer_dirs = 1;\n\t} else if (recurse)\n\t\txfer_dirs = 1;\n\telse if (xfer_dirs < 0)\n\t\txfer_dirs = list_only ? 1 : 0;\n\n\tif (relative_paths < 0)\n\t\trelative_paths = files_from? 1 : 0;\n\tif (!relative_paths)\n\t\timplied_dirs = 0;\n\n\tif (delete_before + !!delete_during + delete_after > 1) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"You may not combine multiple --delete-WHEN options.\\n\");\n\t\tgoto cleanup;\n\t}\n\tif (delete_before || delete_during || delete_after)\n\t\tdelete_mode = 1;\n\telse if (delete_mode || delete_excluded) {\n\t\t/* Only choose now between before & during if one is refused. */\n\t\tif (refused_delete_before) {\n\t\t\tif (!refused_delete_during)\n\t\t\t\tdelete_during = 1;\n\t\t\telse {\n\t\t\t\tcreate_refuse_error(refused_delete_before);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else if (refused_delete_during)\n\t\t\tdelete_before = 1;\n\t\tdelete_mode = 1;\n\t}\n\tif (!xfer_dirs && delete_mode) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"--delete does not work without --recursive (-r) or --dirs (-d).\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tif (missing_args == 3) /* simplify if both options were specified */\n\t\tmissing_args = 2;\n\tif (refused_delete && (delete_mode || missing_args == 2)) {\n\t\tcreate_refuse_error(refused_delete);\n\t\tgoto cleanup;\n\t}\n\n\tif (remove_source_files) {\n\t\t/* We only want to infer this refusal of --remove-source-files\n\t\t * via the refusal of \"delete\", not any of the \"delete-FOO\"\n\t\t * options. */\n\t\tif (refused_delete && am_sender) {\n\t\t\tcreate_refuse_error(refused_delete);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tneed_messages_from_generator = 1;\n\t}\n\n\tif (munge_symlinks && !am_daemon) {\n\t\tSTRUCT_STAT st;\n\t\tchar prefix[SYMLINK_PREFIX_LEN]; /* NOT +1 ! */\n\t\tstrlcpy(prefix, SYMLINK_PREFIX, sizeof prefix); /* trim the trailing slash */\n\t\tif (do_stat(prefix, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\t\trprintf(FERROR, \"Symlink munging is unsafe when a %s directory exists.\\n\",\n\t\t\t\tprefix);\n\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t}\n\t}\n\n\tif (sanitize_paths) {\n\t\tint i;\n\t\tfor (i = argc; i-- > 0; )\n\t\t\targv[i] = sanitize_path(NULL, argv[i], \"\", 0, SP_KEEP_DOT_DIRS);\n\t\tif (tmpdir)\n\t\t\ttmpdir = sanitize_path(NULL, tmpdir, NULL, 0, SP_DEFAULT);\n\t\tif (backup_dir)\n\t\t\tbackup_dir = sanitize_path(NULL, backup_dir, NULL, 0, SP_DEFAULT);\n\t}\n\tif (daemon_filter_list.head && !am_sender) {\n\t\tfilter_rule_list *elp = &daemon_filter_list;\n\t\tif (tmpdir) {\n\t\t\tchar *dir;\n\t\t\tif (!*tmpdir)\n\t\t\t\tgoto options_rejected;\n\t\t\tdir = tmpdir + (*tmpdir == '/' ? module_dirlen : 0);\n\t\t\tclean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t\t\tif (check_filter(elp, FLOG, dir, 1) < 0)\n\t\t\t\tgoto options_rejected;\n\t\t}\n\t\tif (backup_dir) {\n\t\t\tchar *dir;\n\t\t\tif (!*backup_dir)\n\t\t\t\tgoto options_rejected;\n\t\t\tdir = backup_dir + (*backup_dir == '/' ? module_dirlen : 0);\n\t\t\tclean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t\t\tif (check_filter(elp, FLOG, dir, 1) < 0)\n\t\t\t\tgoto options_rejected;\n\t\t}\n\t}\n\n\tif (!backup_suffix)\n\t\tbackup_suffix = backup_dir ? \"\" : BACKUP_SUFFIX;\n\tbackup_suffix_len = strlen(backup_suffix);\n\tif (strchr(backup_suffix, '/') != NULL) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"--suffix cannot contain slashes: %s\\n\",\n\t\t\tbackup_suffix);\n\t\tgoto cleanup;\n\t}\n\tif (backup_dir) {\n\t\tsize_t len;\n\t\tmake_backups = 1; /* --backup-dir implies --backup */\n\t\twhile (*backup_dir == '.' && backup_dir[1] == '/')\n\t\t\tbackup_dir += 2;\n\t\tif (*backup_dir == '.' && backup_dir[1] == '\\0')\n\t\t\tbackup_dir++;\n\t\tlen = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);\n\t\tif (len > sizeof backup_dir_buf - 128) {\n\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\"the --backup-dir path is WAY too long.\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbackup_dir_len = (int)len;\n\t\tif (!backup_dir_len) {\n\t\t\tbackup_dir_len = -1;\n\t\t\tbackup_dir = NULL;\n\t\t} else if (backup_dir_buf[backup_dir_len - 1] != '/') {\n\t\t\tbackup_dir_buf[backup_dir_len++] = '/';\n\t\t\tbackup_dir_buf[backup_dir_len] = '\\0';\n\t\t}\n\t\tbackup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;\n\t}\n\tif (backup_dir) {\n\t\t/* No need for a suffix or a protect rule. */\n\t} else if (!backup_suffix_len && (!am_server || !am_sender)) {\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\"--suffix cannot be empty %s\\n\", backup_dir_len < 0\n\t\t\t? \"when --backup-dir is the same as the dest dir\"\n\t\t\t: \"without a --backup-dir\");\n\t\tgoto cleanup;\n\t} else if (make_backups && delete_mode && !delete_excluded && !am_server) {\n\t\tsnprintf(backup_dir_buf, sizeof backup_dir_buf,\n\t\t\t\"P *%s\", backup_suffix);\n\t\tparse_filter_str(&filter_list, backup_dir_buf, rule_template(0), 0);\n\t}\n\n\tif (make_backups && !backup_dir)\n\t\tomit_dir_times = -1; /* Implied, so avoid -O to sender. */\n\n\tif (stdout_format) {\n\t\tif (am_server && log_format_has(stdout_format, 'I'))\n\t\t\tstdout_format_has_i = 2;\n\t\telse if (log_format_has(stdout_format, 'i'))\n\t\t\tstdout_format_has_i = itemize_changes | 1;\n\t\tif (!log_format_has(stdout_format, 'b')\n\t\t && !log_format_has(stdout_format, 'c')\n\t\t && !log_format_has(stdout_format, 'C'))\n\t\t\tlog_before_transfer = !am_server;\n\t} else if (itemize_changes) {\n\t\tstdout_format = \"%i %n%L\";\n\t\tstdout_format_has_i = itemize_changes;\n\t\tlog_before_transfer = !am_server;\n\t}\n\n\tif (do_progress && !am_server) {\n\t\tif (!log_before_transfer && INFO_EQ(NAME, 0))\n\t\t\tparse_output_words(info_words, info_levels, \"name\", DEFAULT_PRIORITY);\n\t\tparse_output_words(info_words, info_levels, \"FLIST2,PROGRESS\", DEFAULT_PRIORITY);\n\t}\n\n\tif (dry_run)\n\t\tdo_xfers = 0;\n\n\tset_io_timeout(io_timeout);\n\n\tif (INFO_GTE(NAME, 1) && !stdout_format) {\n\t\tstdout_format = \"%n%L\";\n\t\tlog_before_transfer = !am_server;\n\t}\n\tif (stdout_format_has_i || log_format_has(stdout_format, 'o'))\n\t\tstdout_format_has_o_or_i = 1;\n\n\tif (logfile_name && !am_daemon) {\n\t\tif (!logfile_format) {\n\t\t\tlogfile_format = \"%i %n%L\";\n\t\t\tlogfile_format_has_i = logfile_format_has_o_or_i = 1;\n\t\t} else {\n\t\t\tif (log_format_has(logfile_format, 'i'))\n\t\t\t\tlogfile_format_has_i = 1;\n\t\t\tif (logfile_format_has_i || log_format_has(logfile_format, 'o'))\n\t\t\t\tlogfile_format_has_o_or_i = 1;\n\t\t}\n\t\tlog_init(0);\n\t} else if (!am_daemon)\n\t\tlogfile_format = NULL;\n\n\tif (daemon_bwlimit && (!bwlimit || bwlimit > daemon_bwlimit))\n\t\tbwlimit = daemon_bwlimit;\n\tif (bwlimit) {\n\t\tbwlimit_writemax = (size_t)bwlimit * 128;\n\t\tif (bwlimit_writemax < 512)\n\t\t\tbwlimit_writemax = 512;\n\t}\n\n\tif (append_mode) {\n\t\tif (whole_file > 0) {\n\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t \"--append cannot be used with --whole-file\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (refused_inplace) {\n\t\t\tcreate_refuse_error(refused_inplace);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinplace = 1;\n\t}\n\n\tif (write_devices) {\n\t\tif (refused_inplace) {\n\t\t\tcreate_refuse_error(refused_inplace);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinplace = 1;\n\t}\n\n\tif (delay_updates && !partial_dir)\n\t\tpartial_dir = tmp_partialdir;\n\n\tif (inplace) {\n#ifdef HAVE_FTRUNCATE\n\t\tif (partial_dir) {\n\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t \"--%s cannot be used with --%s\\n\",\n\t\t\t\t append_mode ? \"append\" : \"inplace\",\n\t\t\t\t delay_updates ? \"delay-updates\" : \"partial-dir\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* --inplace implies --partial for refusal purposes, but we\n\t\t * clear the keep_partial flag for internal logic purposes. */\n\t\tif (refused_partial) {\n\t\t\tcreate_refuse_error(refused_partial);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tkeep_partial = 0;\n#else\n\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t \"--%s is not supported on this %s\\n\",\n\t\t\t append_mode ? \"append\" : \"inplace\",\n\t\t\t am_server ? \"server\" : \"client\");\n\t\tgoto cleanup;\n#endif\n\t} else {\n\t\tif (keep_partial && !partial_dir && !am_server) {\n\t\t\tif ((arg = getenv(\"RSYNC_PARTIAL_DIR\")) != NULL && *arg)\n\t\t\t\tpartial_dir = strdup(arg);\n\t\t}\n\t\tif (partial_dir) {\n\t\t\tif (*partial_dir)\n\t\t\t\tclean_fname(partial_dir, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t\t\tif (!*partial_dir || strcmp(partial_dir, \".\") == 0)\n\t\t\t\tpartial_dir = NULL;\n\t\t\tif (!partial_dir && refused_partial) {\n\t\t\t\tcreate_refuse_error(refused_partial);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tkeep_partial = 1;\n\t\t}\n\t}\n\n\tif (files_from) {\n\t\tchar *h, *p;\n\t\tint q;\n\t\tif (argc > 2 || (!am_daemon && !am_server && argc == 1)) {\n\t\t\tusage(FERROR);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tif (strcmp(files_from, \"-\") == 0) {\n\t\t\tfilesfrom_fd = 0;\n\t\t\tif (am_server)\n\t\t\t\tfilesfrom_host = \"\"; /* reading from socket */\n\t\t} else if ((p = check_for_hostspec(files_from, &h, &q)) != 0) {\n\t\t\tif (am_server) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"The --files-from sent to the server cannot specify a host.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tfiles_from = p;\n\t\t\tfilesfrom_host = h;\n\t\t\tif (strcmp(files_from, \"-\") == 0) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"Invalid --files-from remote filename\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sanitize_paths)\n\t\t\t\tfiles_from = sanitize_path(NULL, files_from, NULL, 0, SP_DEFAULT);\n\t\t\tif (daemon_filter_list.head) {\n\t\t\t\tchar *dir;\n\t\t\t\tif (!*files_from)\n\t\t\t\t\tgoto options_rejected;\n\t\t\t\tdir = files_from + (*files_from == '/' ? module_dirlen : 0);\n\t\t\t\tclean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);\n\t\t\t\tif (check_filter(&daemon_filter_list, FLOG, dir, 0) < 0)\n\t\t\t\t\tgoto options_rejected;\n\t\t\t}\n\t\t\tfilesfrom_fd = open(files_from, O_RDONLY|O_BINARY);\n\t\t\tif (filesfrom_fd < 0) {\n\t\t\t\tsnprintf(err_buf, sizeof err_buf,\n\t\t\t\t\t\"failed to open files-from file %s: %s\\n\",\n\t\t\t\t\tfiles_from, strerror(errno));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (trust_sender || am_server || read_batch)\n\t\ttrust_sender_args = trust_sender_filter = 1;\n\telse if (old_style_args || filesfrom_host != NULL)\n\t\ttrust_sender_args = 1;\n\n\tam_starting_up = 0;\n\n\treturn 1;\n\n  options_rejected:\n\tsnprintf(err_buf, sizeof err_buf,\n\t\t\"Your options have been rejected by the server.\\n\");\n  cleanup:\n\tif (pc)\n\t\tpoptFreeContext(pc);\n\treturn 0;\n}\n\n\nstatic char SPLIT_ARG_WHEN_OLD[1];\n\n/**\n * Do backslash quoting of any weird chars in \"arg\", append the resulting\n * string to the end of the \"opt\" (which gets a \"=\" appended if it is not\n * an empty or NULL string), and return the (perhaps malloced) result.\n * If opt is NULL, arg is considered a filename arg that allows wildcards.\n * If it is \"\" or any other value, it is considered an option.\n **/\nchar *safe_arg(const char *opt, const char *arg)\n{\n#define SHELL_CHARS \"!#$&;|<>(){}\\\"'` \\t\\\\\"\n#define WILD_CHARS  \"*?[]\" /* We don't allow remote brace expansion */\n\tBOOL is_filename_arg = !opt;\n\tchar *escapes = is_filename_arg ? SHELL_CHARS : WILD_CHARS SHELL_CHARS;\n\tBOOL escape_leading_dash = is_filename_arg && *arg == '-';\n\tBOOL escape_leading_tilde = 0;\n\tint len1 = opt && *opt ? strlen(opt) + 1 : 0;\n\tint len2 = strlen(arg);\n\tint extras = escape_leading_dash ? 2 : 0;\n\tchar *ret;\n\tif (!protect_args && old_style_args < 2 && (!old_style_args || (!is_filename_arg && opt != SPLIT_ARG_WHEN_OLD))) {\n\t\tconst char *f;\n\t\tif (*arg == '~' && is_filename_arg && !am_sender && !trust_sender_args\n\t\t && ((relative_paths && !strstr(arg, \"/./\"))\n\t\t  || !strchr(arg, '/'))) {\n\t\t\textras++;\n\t\t\tescape_leading_tilde = 1;\n\t\t}\n\t\tfor (f = arg; *f; f++) {\n\t\t\tif (strchr(escapes, *f))\n\t\t\t\textras++;\n\t\t}\n\t}\n\tif (!len1 && !extras)\n\t\treturn (char*)arg;\n\tret = new_array(char, len1 + len2 + extras + 1);\n\tif (len1) {\n\t\tmemcpy(ret, opt, len1-1);\n\t\tret[len1-1] = '=';\n\t}\n\tif (escape_leading_dash) {\n\t\tret[len1++] = '.';\n\t\tret[len1++] = '/';\n\t\textras -= 2;\n\t}\n\tif (!extras)\n\t\tmemcpy(ret + len1, arg, len2);\n\telse {\n\t\tconst char *f = arg;\n\t\tchar *t = ret + len1;\n\t\tif (escape_leading_tilde)\n\t\t\t*t++ = '\\\\';\n\t\twhile (*f) {\n\t\t\tif (*f == '\\\\') {\n\t\t\t\tif (!is_filename_arg || !strchr(WILD_CHARS, f[1]))\n\t\t\t\t\t*t++ = '\\\\';\n\t\t\t} else if (strchr(escapes, *f))\n\t\t\t\t*t++ = '\\\\';\n\t\t\t*t++ = *f++;\n\t\t}\n\t}\n\tret[len1+len2+extras] = '\\0';\n\treturn ret;\n}\n\n\n/**\n * Construct a filtered list of options to pass through from the\n * client to the server.\n *\n * This involves setting options that will tell the server how to\n * behave, and also filtering out options that are processed only\n * locally.\n **/\nvoid server_options(char **args, int *argc_p)\n{\n\tstatic char argstr[64];\n\tint ac = *argc_p;\n\tuchar where;\n\tchar *arg;\n\tint i, x;\n\n\t/* This should always remain first on the server's command-line. */\n\targs[ac++] = \"--server\";\n\n\tif (!am_sender)\n\t\targs[ac++] = \"--sender\";\n\n\tx = 1;\n\targstr[0] = '-';\n\n\tif (protect_args)\n\t\targstr[x++] = 's';\n\n\tfor (i = 0; i < verbose; i++)\n\t\targstr[x++] = 'v';\n\n\tif (quiet && msgs2stderr)\n\t\targstr[x++] = 'q';\n\tif (make_backups)\n\t\targstr[x++] = 'b';\n\tif (update_only)\n\t\targstr[x++] = 'u';\n\tif (!do_xfers) /* Note: NOT \"dry_run\"! */\n\t\targstr[x++] = 'n';\n\tif (preserve_links)\n\t\targstr[x++] = 'l';\n\tif ((xfer_dirs >= 2 && xfer_dirs < 4)\n\t || (xfer_dirs && !recurse && (list_only || (delete_mode && am_sender))))\n\t\targstr[x++] = 'd';\n\tif (am_sender) {\n\t\tif (keep_dirlinks)\n\t\t\targstr[x++] = 'K';\n\t\tif (prune_empty_dirs)\n\t\t\targstr[x++] = 'm';\n\t\tif (omit_dir_times > 0)\n\t\t\targstr[x++] = 'O';\n\t\tif (omit_link_times)\n\t\t\targstr[x++] = 'J';\n\t\tif (fuzzy_basis) {\n\t\t\targstr[x++] = 'y';\n\t\t\tif (fuzzy_basis > 1)\n\t\t\t\targstr[x++] = 'y';\n\t\t}\n\t} else {\n\t\tif (copy_links)\n\t\t\targstr[x++] = 'L';\n\t\tif (copy_dirlinks)\n\t\t\targstr[x++] = 'k';\n\t}\n\n\tif (whole_file > 0)\n\t\targstr[x++] = 'W';\n\t/* We don't need to send --no-whole-file, because it's the\n\t * default for remote transfers, and in any case old versions\n\t * of rsync will not understand it. */\n\n\tif (preserve_hard_links) {\n\t\targstr[x++] = 'H';\n\t\tif (preserve_hard_links > 1)\n\t\t\targstr[x++] = 'H';\n\t}\n\tif (preserve_uid)\n\t\targstr[x++] = 'o';\n\tif (preserve_gid)\n\t\targstr[x++] = 'g';\n\tif (preserve_devices) /* ignore preserve_specials here */\n\t\targstr[x++] = 'D';\n\tif (preserve_mtimes)\n\t\targstr[x++] = 't';\n\tif (preserve_atimes) {\n\t\targstr[x++] = 'U';\n\t\tif (preserve_atimes > 1)\n\t\t\targstr[x++] = 'U';\n\t}\n#ifdef SUPPORT_CRTIMES\n\tif (preserve_crtimes)\n\t\targstr[x++] = 'N';\n#endif\n\tif (preserve_perms)\n\t\targstr[x++] = 'p';\n\telse if (preserve_executability && am_sender)\n\t\targstr[x++] = 'E';\n#ifdef SUPPORT_ACLS\n\tif (preserve_acls)\n\t\targstr[x++] = 'A';\n#endif\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs) {\n\t\targstr[x++] = 'X';\n\t\tif (preserve_xattrs > 1)\n\t\t\targstr[x++] = 'X';\n\t}\n#endif\n\tif (recurse)\n\t\targstr[x++] = 'r';\n\tif (always_checksum)\n\t\targstr[x++] = 'c';\n\tif (cvs_exclude)\n\t\targstr[x++] = 'C';\n\tif (ignore_times)\n\t\targstr[x++] = 'I';\n\tif (relative_paths)\n\t\targstr[x++] = 'R';\n\tif (one_file_system) {\n\t\targstr[x++] = 'x';\n\t\tif (one_file_system > 1)\n\t\t\targstr[x++] = 'x';\n\t}\n\tif (sparse_files)\n\t\targstr[x++] = 'S';\n\tif (do_compression == CPRES_ZLIB)\n\t\targstr[x++] = 'z';\n\n\tset_allow_inc_recurse();\n\n\t/* This '\\0'-terminates argstr and makes sure it didn't overflow. */\n\tx += maybe_add_e_option(argstr + x, (int)sizeof argstr - x);\n\n\tif (x > 1)\n\t\targs[ac++] = argstr;\n\n#ifdef ICONV_OPTION\n\tif (iconv_opt) {\n\t\tchar *set = strchr(iconv_opt, ',');\n\t\tif (set)\n\t\t\tset++;\n\t\telse\n\t\t\tset = iconv_opt;\n\t\targs[ac++] = safe_arg(\"--iconv\", set);\n\t}\n#endif\n\n\tif (protect_args && !local_server) /* unprotected args stop here */\n\t\targs[ac++] = NULL;\n\n\tif (list_only > 1)\n\t\targs[ac++] = \"--list-only\";\n\n\t/* This makes sure that the remote rsync can handle deleting with -d\n\t * sans -r because the --no-r option was added at the same time. */\n\tif (xfer_dirs && !recurse && delete_mode && am_sender)\n\t\targs[ac++] = \"--no-r\";\n\n\tif (do_compression && do_compression_level != CLVL_NOT_SPECIFIED) {\n\t\tif (asprintf(&arg, \"--compress-level=%d\", do_compression_level) < 0)\n\t\t\tgoto oom;\n\t\targs[ac++] = arg;\n\t}\n\n\tif (preserve_devices) {\n\t\t/* Note: sending \"--devices\" would not be backward-compatible. */\n\t\tif (!preserve_specials)\n\t\t\targs[ac++] = \"--no-specials\"; /* -D is already set. */\n\t} else if (preserve_specials)\n\t\targs[ac++] = \"--specials\";\n\n\t/* The server side doesn't use our log-format, but in certain\n\t * circumstances they need to know a little about the option. */\n\tif (stdout_format && am_sender) {\n\t\t/* Use --log-format, not --out-format, for compatibility. */\n\t\tif (stdout_format_has_i > 1)\n\t\t\targs[ac++] = \"--log-format=%i%I\";\n\t\telse if (stdout_format_has_i)\n\t\t\targs[ac++] = \"--log-format=%i\";\n\t\telse if (stdout_format_has_o_or_i)\n\t\t\targs[ac++] = \"--log-format=%o\";\n\t\telse if (!verbose)\n\t\t\targs[ac++] = \"--log-format=X\";\n\t}\n\n\tif (msgs2stderr == 1)\n\t\targs[ac++] = \"--msgs2stderr\";\n\telse if (msgs2stderr == 0)\n\t\targs[ac++] = \"--no-msgs2stderr\";\n\n\tif (block_size) {\n\t\tif (asprintf(&arg, \"-B%u\", (int)block_size) < 0)\n\t\t\tgoto oom;\n\t\targs[ac++] = arg;\n\t}\n\n\tif (io_timeout) {\n\t\tif (asprintf(&arg, \"--timeout=%d\", io_timeout) < 0)\n\t\t\tgoto oom;\n\t\targs[ac++] = arg;\n\t}\n\n\tif (bwlimit) {\n\t\tif (asprintf(&arg, \"--bwlimit=%d\", bwlimit) < 0)\n\t\t\tgoto oom;\n\t\targs[ac++] = arg;\n\t}\n\n\tif (backup_dir) {\n\t\t/* This split idiom allows for ~/path expansion via the shell. */\n\t\targs[ac++] = \"--backup-dir\";\n\t\targs[ac++] = safe_arg(\"\", backup_dir);\n\t}\n\n\t/* Only send --suffix if it specifies a non-default value. */\n\tif (strcmp(backup_suffix, backup_dir ? \"\" : BACKUP_SUFFIX) != 0)\n\t\targs[ac++] = safe_arg(\"--suffix\", backup_suffix);\n\n\tif (checksum_choice)\n\t\targs[ac++] = safe_arg(\"--checksum-choice\", checksum_choice);\n\n\tif (do_compression == CPRES_ZLIBX)\n\t\targs[ac++] = \"--new-compress\";\n\telse if (compress_choice && do_compression == CPRES_ZLIB)\n\t\targs[ac++] = \"--old-compress\";\n\telse if (compress_choice)\n\t\targs[ac++] = safe_arg(\"--compress-choice\", compress_choice);\n\n\tif (am_sender) {\n\t\tif (max_delete > 0) {\n\t\t\tif (asprintf(&arg, \"--max-delete=%d\", max_delete) < 0)\n\t\t\t\tgoto oom;\n\t\t\targs[ac++] = arg;\n\t\t} else if (max_delete == 0)\n\t\t\targs[ac++] = \"--max-delete=-1\";\n\t\tif (min_size >= 0)\n\t\t\targs[ac++] = safe_arg(\"--min-size\", min_size_arg);\n\t\tif (max_size >= 0)\n\t\t\targs[ac++] = safe_arg(\"--max-size\", max_size_arg);\n\t\tif (delete_before)\n\t\t\targs[ac++] = \"--delete-before\";\n\t\telse if (delete_during == 2)\n\t\t\targs[ac++] = \"--delete-delay\";\n\t\telse if (delete_during)\n\t\t\targs[ac++] = \"--delete-during\";\n\t\telse if (delete_after)\n\t\t\targs[ac++] = \"--delete-after\";\n\t\telse if (delete_mode && !delete_excluded)\n\t\t\targs[ac++] = \"--delete\";\n\t\tif (delete_excluded)\n\t\t\targs[ac++] = \"--delete-excluded\";\n\t\tif (force_delete)\n\t\t\targs[ac++] = \"--force\";\n\t\tif (write_batch < 0)\n\t\t\targs[ac++] = \"--only-write-batch=X\";\n\t\tif (am_root > 1)\n\t\t\targs[ac++] = \"--super\";\n\t\tif (size_only)\n\t\t\targs[ac++] = \"--size-only\";\n\t\tif (do_stats)\n\t\t\targs[ac++] = \"--stats\";\n\t} else {\n\t\tif (skip_compress)\n\t\t\targs[ac++] = safe_arg(\"--skip-compress\", skip_compress);\n\t}\n\n\tif (max_alloc_arg && max_alloc != DEFAULT_MAX_ALLOC)\n\t\targs[ac++] = safe_arg(\"--max-alloc\", max_alloc_arg);\n\n\t/* --delete-missing-args needs the cooperation of both sides, but\n\t * the sender can handle --ignore-missing-args by itself. */\n\tif (missing_args == 2)\n\t\targs[ac++] = \"--delete-missing-args\";\n\telse if (missing_args == 1 && !am_sender)\n\t\targs[ac++] = \"--ignore-missing-args\";\n\n\tif (modify_window_set && am_sender) {\n\t\tchar *fmt = modify_window < 0 ? \"-@%d\" : \"--modify-window=%d\";\n\t\tif (asprintf(&arg, fmt, modify_window) < 0)\n\t\t\tgoto oom;\n\t\targs[ac++] = arg;\n\t}\n\n\tif (checksum_seed) {\n\t\tif (asprintf(&arg, \"--checksum-seed=%d\", checksum_seed) < 0)\n\t\t\tgoto oom;\n\t\targs[ac++] = arg;\n\t}\n\n\tif (partial_dir && am_sender) {\n\t\tif (partial_dir != tmp_partialdir) {\n\t\t\targs[ac++] = \"--partial-dir\";\n\t\t\targs[ac++] = safe_arg(\"\", partial_dir);\n\t\t}\n\t\tif (delay_updates)\n\t\t\targs[ac++] = \"--delay-updates\";\n\t} else if (keep_partial && am_sender)\n\t\targs[ac++] = \"--partial\";\n\n\tif (ignore_errors)\n\t\targs[ac++] = \"--ignore-errors\";\n\n\tif (copy_unsafe_links)\n\t\targs[ac++] = \"--copy-unsafe-links\";\n\n\tif (safe_symlinks)\n\t\targs[ac++] = \"--safe-links\";\n\n\tif (numeric_ids)\n\t\targs[ac++] = \"--numeric-ids\";\n\n\tif (use_qsort)\n\t\targs[ac++] = \"--use-qsort\";\n\n\tif (am_sender) {\n\t\tif (usermap)\n\t\t\targs[ac++] = safe_arg(\"--usermap\", usermap);\n\n\t\tif (groupmap)\n\t\t\targs[ac++] = safe_arg(\"--groupmap\", groupmap);\n\n\t\tif (ignore_existing)\n\t\t\targs[ac++] = \"--ignore-existing\";\n\n\t\t/* Backward compatibility: send --existing, not --ignore-non-existing. */\n\t\tif (ignore_non_existing)\n\t\t\targs[ac++] = \"--existing\";\n\n\t\tif (tmpdir) {\n\t\t\targs[ac++] = \"--temp-dir\";\n\t\t\targs[ac++] = safe_arg(\"\", tmpdir);\n\t\t}\n\n\t\tif (do_fsync)\n\t\t\targs[ac++] = \"--fsync\";\n\n\t\tif (basis_dir[0]) {\n\t\t\t/* the server only needs this option if it is not the sender,\n\t\t\t *   and it may be an older version that doesn't know this\n\t\t\t *   option, so don't send it if client is the sender.\n\t\t\t */\n\t\t\tfor (i = 0; i < basis_dir_cnt; i++) {\n\t\t\t\targs[ac++] = alt_dest_opt(0);\n\t\t\t\targs[ac++] = safe_arg(\"\", basis_dir[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* What flags do we need to send to the other side? */\n\twhere = (am_server ? W_CLI : W_SRV) | (am_sender ? W_REC : W_SND);\n\targ = make_output_option(info_words, info_levels, where);\n\tif (arg)\n\t\targs[ac++] = arg;\n\n\tif (append_mode) {\n\t\tif (append_mode > 1)\n\t\t\targs[ac++] = \"--append\";\n\t\targs[ac++] = \"--append\";\n\t} else if (inplace) {\n\t\targs[ac++] = \"--inplace\";\n\t\t/* Work around a bug in older rsync versions (on the remote side) for --inplace --sparse */\n\t\tif (sparse_files && !whole_file && am_sender)\n\t\t\targs[ac++] = \"--no-W\";\n\t}\n\n\tif (files_from && (!am_sender || filesfrom_host)) {\n\t\tif (filesfrom_host) {\n\t\t\targs[ac++] = \"--files-from\";\n\t\t\targs[ac++] = safe_arg(\"\", files_from);\n\t\t\tif (eol_nulls)\n\t\t\t\targs[ac++] = \"--from0\";\n\t\t} else {\n\t\t\targs[ac++] = \"--files-from=-\";\n\t\t\targs[ac++] = \"--from0\";\n\t\t}\n\t\tif (!relative_paths)\n\t\t\targs[ac++] = \"--no-relative\";\n\t}\n\t/* It's OK that this checks the upper-bound of the protocol_version. */\n\tif (relative_paths && !implied_dirs && (!am_sender || protocol_version >= 30))\n\t\targs[ac++] = \"--no-implied-dirs\";\n\n\tif (write_devices && am_sender)\n\t\targs[ac++] = \"--write-devices\";\n\n\tif (remove_source_files == 1)\n\t\targs[ac++] = \"--remove-source-files\";\n\telse if (remove_source_files)\n\t\targs[ac++] = \"--remove-sent-files\";\n\n\tif (copy_devices && !am_sender)\n\t\targs[ac++] = \"--copy-devices\";\n\n\tif (preallocate_files && am_sender)\n\t\targs[ac++] = \"--preallocate\";\n\n\tif (open_noatime && preserve_atimes <= 1)\n\t\targs[ac++] = \"--open-noatime\";\n\n\tif (mkpath_dest_arg && am_sender)\n\t\targs[ac++] = \"--mkpath\";\n\n\tif (ac > MAX_SERVER_ARGS) { /* Not possible... */\n\t\trprintf(FERROR, \"argc overflow in server_options().\\n\");\n\t\texit_cleanup(RERR_MALLOC);\n\t}\n\n\tif (remote_option_cnt) {\n\t\tint j;\n\t\tif (ac + remote_option_cnt > MAX_SERVER_ARGS) {\n\t\t\trprintf(FERROR, \"too many remote options specified.\\n\");\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tfor (j = 1; j <= remote_option_cnt; j++)\n\t\t\targs[ac++] = safe_arg(SPLIT_ARG_WHEN_OLD, remote_options[j]);\n\t}\n\n\t*argc_p = ac;\n\treturn;\n\n    oom:\n\tout_of_memory(\"server_options\");\n}\n\nint maybe_add_e_option(char *buf, int buf_len)\n{\n\tint x = 0;\n\n\t/* We don't really know the actual protocol_version at this point,\n\t * but checking the pre-negotiated value allows the user to use a\n\t * --protocol=29 override to avoid the use of this -eFLAGS opt. */\n\tif (protocol_version >= 30 && buf_len > 0) {\n\t\t/* We make use of the -e option to let the server know about\n\t\t * any pre-release protocol version && some behavior flags. */\n\t\tbuf[x++] = 'e';\n\n#if SUBPROTOCOL_VERSION != 0\n\t\tif (protocol_version == PROTOCOL_VERSION)\n\t\t\tx += snprintf(buf + x, buf_len - x, \"%d.%d\", PROTOCOL_VERSION, SUBPROTOCOL_VERSION);\n\t\telse\n#endif\n\t\t\tbuf[x++] = '.';\n\t\tif (allow_inc_recurse)\n\t\t\tbuf[x++] = 'i';\n#ifdef CAN_SET_SYMLINK_TIMES\n\t\tbuf[x++] = 'L'; /* symlink time-setting support */\n#endif\n#ifdef ICONV_OPTION\n\t\tbuf[x++] = 's'; /* symlink iconv translation support */\n#endif\n\t\tbuf[x++] = 'f'; /* flist I/O-error safety support */\n\t\tbuf[x++] = 'x'; /* xattr hardlink optimization not desired */\n\t\tbuf[x++] = 'C'; /* support checksum seed order fix */\n\t\tbuf[x++] = 'I'; /* support inplace_partial behavior */\n\t\tbuf[x++] = 'v'; /* use varint for flist & compat flags; negotiate checksum */\n\t\tbuf[x++] = 'u'; /* include name of uid 0 & gid 0 in the id map */\n\n\t\t/* NOTE: Avoid using 'V' -- it was represented with the high bit of a write_byte() that became a write_varint(). */\n\t}\n\n\tif (x >= buf_len) { /* Not possible... */\n\t\trprintf(FERROR, \"overflow in add_e_flags().\\n\");\n\t\texit_cleanup(RERR_MALLOC);\n\t}\n\n\tbuf[x] = '\\0';\n\n\treturn x;\n}\n\n/* If str points to a valid hostspec, return allocated memory containing the\n * [USER@]HOST part of the string, and set the path_start_ptr to the part of\n * the string after the host part.  Otherwise, return NULL.  If port_ptr is\n * non-NULL, we must be parsing an rsync:// URL hostname, and we will set\n * *port_ptr if a port number is found.  Note that IPv6 IPs will have their\n * (required for parsing) [ and ] chars elided from the returned string. */\nstatic char *parse_hostspec(char *str, char **path_start_ptr, int *port_ptr)\n{\n\tchar *s, *host_start = str;\n\tint hostlen = 0, userlen = 0;\n\tchar *ret;\n\n\tfor (s = str; ; s++) {\n\t\tif (!*s) {\n\t\t\t/* It is only OK if we run out of string with rsync:// */\n\t\t\tif (!port_ptr)\n\t\t\t\treturn NULL;\n\t\t\tif (!hostlen)\n\t\t\t\thostlen = s - host_start;\n\t\t\tbreak;\n\t\t}\n\t\tif (*s == ':' || *s == '/') {\n\t\t\tif (!hostlen)\n\t\t\t\thostlen = s - host_start;\n\t\t\tif (*s++ == '/') {\n\t\t\t\tif (!port_ptr)\n\t\t\t\t\treturn NULL;\n\t\t\t} else if (port_ptr) {\n\t\t\t\t*port_ptr = atoi(s);\n\t\t\t\twhile (isDigit(s)) s++;\n\t\t\t\tif (*s && *s++ != '/')\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (*s == '@') {\n\t\t\tuserlen = s - str + 1;\n\t\t\thost_start = s + 1;\n\t\t} else if (*s == '[') {\n\t\t\tif (s != host_start++)\n\t\t\t\treturn NULL;\n\t\t\twhile (*s && *s != ']' && *s != '/') s++; /*SHARED ITERATOR*/\n\t\t\thostlen = s - host_start;\n\t\t\tif (*s != ']' || (s[1] && s[1] != '/' && s[1] != ':') || !hostlen)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t*path_start_ptr = s;\n\tret = new_array(char, userlen + hostlen + 1);\n\tif (userlen)\n\t\tstrlcpy(ret, str, userlen + 1);\n\tstrlcpy(ret + userlen, host_start, hostlen + 1);\n\treturn ret;\n}\n\n/* Look for a HOST specification of the form \"HOST:PATH\", \"HOST::PATH\", or\n * \"rsync://HOST:PORT/PATH\".  If found, *host_ptr will be set to some allocated\n * memory with the HOST.  If a daemon-accessing spec was specified, the value\n * of *port_ptr will contain a non-0 port number, otherwise it will be set to\n * 0.  The return value is a pointer to the PATH.  Note that the HOST spec can\n * be an IPv6 literal address enclosed in '[' and ']' (such as \"[::1]\" or\n * \"[::ffff:127.0.0.1]\") which is returned without the '[' and ']'. */\nchar *check_for_hostspec(char *s, char **host_ptr, int *port_ptr)\n{\n\tchar *path;\n\n\tif (port_ptr && strncasecmp(URL_PREFIX, s, strlen(URL_PREFIX)) == 0) {\n\t\t*host_ptr = parse_hostspec(s + strlen(URL_PREFIX), &path, port_ptr);\n\t\tif (*host_ptr) {\n\t\t\tif (!*port_ptr)\n\t\t\t\t*port_ptr = -1; /* -1 indicates they want the default */\n\t\t\treturn path;\n\t\t}\n\t}\n\n\t*host_ptr = parse_hostspec(s, &path, NULL);\n\tif (!*host_ptr)\n\t\treturn NULL;\n\n\tif (*path == ':') {\n\t\tif (port_ptr && !*port_ptr)\n\t\t\t*port_ptr = -1;\n\t\treturn path + 1;\n\t}\n\tif (port_ptr)\n\t\t*port_ptr = 0;\n\n\treturn path;\n}\n"
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "params.c",
          "type": "blob",
          "size": 21.2939453125,
          "content": "/* This modules is based on the params.c module from Samba, written by Karl Auer\n   and much modified by Christopher Hertel. */\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* -------------------------------------------------------------------------- **\n *\n * Module name: params\n *\n * -------------------------------------------------------------------------- **\n *\n *  This module performs lexical analysis and initial parsing of a\n *  Windows-like parameter file.  It recognizes and handles four token\n *  types:  section-name, parameter-name, parameter-value, and\n *  end-of-file.  Comments and line continuation are handled\n *  internally.\n *\n *  The entry point to the module is function pm_process().  This\n *  function opens the source file, calls the Parse() function to parse\n *  the input, and then closes the file when either the EOF is reached\n *  or a fatal error is encountered.\n *\n *  A sample parameter file might look like this:\n *\n *  [section one]\n *  parameter one = value string\n *  parameter two = another value\n *  [section two]\n *  new parameter = some value or t'other\n *\n *  The parameter file is divided into sections by section headers:\n *  section names enclosed in square brackets (eg. [section one]).\n *  Each section contains parameter lines, each of which consist of a\n *  parameter name and value delimited by an equal sign.  Roughly, the\n *  syntax is:\n *\n *    <file>            :==  { <section> } EOF\n *\n *    <section>         :==  <section header> { <parameter line> }\n *\n *    <section header>  :==  '[' NAME ']'\n *\n *    <parameter line>  :==  NAME '=' VALUE '\\n'\n *\n *  Blank lines and comment lines are ignored.  Comment lines are lines\n *  beginning with either a semicolon (';') or a pound sign ('#').\n *\n *  All whitespace in section names and parameter names is compressed\n *  to single spaces.  Leading and trailing whitespace is stripped from\n *  both names and values.\n *\n *  Only the first equals sign in a parameter line is significant.\n *  Parameter values may contain equals signs, square brackets and\n *  semicolons.  Internal whitespace is retained in parameter values,\n *  with the exception of the '\\r' character, which is stripped for\n *  historic reasons.  Parameter names may not start with a left square\n *  bracket, an equal sign, a pound sign, or a semicolon, because these\n *  are used to identify other tokens.\n *\n * -------------------------------------------------------------------------- **\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"itypes.h\"\n\n/* -------------------------------------------------------------------------- **\n * Constants...\n */\n\n#define BUFR_INC 1024\n\n\n/* -------------------------------------------------------------------------- **\n * Variables...\n *\n *  bufr        - pointer to a global buffer.  This is probably a kludge,\n *                but it was the nicest kludge I could think of (for now).\n *  bSize       - The size of the global buffer <bufr>.\n */\n\nstatic char *bufr  = NULL;\nstatic int   bSize = 0;\nstatic BOOL  (*the_sfunc)(char *);\nstatic BOOL  (*the_pfunc)(char *, char *);\n\n/* -------------------------------------------------------------------------- **\n * Functions...\n */\n\nstatic int EatWhitespace( FILE *InFile )\n  /* ------------------------------------------------------------------------ **\n   * Scan past whitespace (see ctype(3C)) and return the first non-whitespace\n   * character, or newline, or EOF.\n   *\n   *  Input:  InFile  - Input source.\n   *\n   *  Output: The next non-whitespace character in the input stream.\n   *\n   *  Notes:  Because the config files use a line-oriented grammar, we\n   *          explicitly exclude the newline character from the list of\n   *          whitespace characters.\n   *        - Note that both EOF (-1) and the nul character ('\\0') are\n   *          considered end-of-file markers.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  int c;\n\n  for( c = getc( InFile ); isspace( c ) && ('\\n' != c); c = getc( InFile ) )\n    ;\n  return( c );\n  } /* EatWhitespace */\n\nstatic int EatComment( FILE *InFile )\n  /* ------------------------------------------------------------------------ **\n   * Scan to the end of a comment.\n   *\n   *  Input:  InFile  - Input source.\n   *\n   *  Output: The character that marks the end of the comment.  Normally,\n   *          this will be a newline, but it *might* be an EOF.\n   *\n   *  Notes:  Because the config files use a line-oriented grammar, we\n   *          explicitly exclude the newline character from the list of\n   *          whitespace characters.\n   *        - Note that both EOF (-1) and the nul character ('\\0') are\n   *          considered end-of-file markers.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  int c;\n\n  for( c = getc( InFile ); ('\\n'!=c) && (EOF!=c) && (c>0); c = getc( InFile ) )\n    ;\n  return( c );\n  } /* EatComment */\n\nstatic int Continuation( char *line, int pos )\n  /* ------------------------------------------------------------------------ **\n   * Scan backwards within a string to discover if the last non-whitespace\n   * character is a line-continuation character ('\\\\').\n   *\n   *  Input:  line  - A pointer to a buffer containing the string to be\n   *                  scanned.\n   *          pos   - This is taken to be the offset of the end of the\n   *                  string.  This position is *not* scanned.\n   *\n   *  Output: The offset of the '\\\\' character if it was found, or -1 to\n   *          indicate that it was not.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  pos--;\n  while( pos >= 0 && isSpace(line + pos) )\n     pos--;\n\n  return( ((pos >= 0) && ('\\\\' == line[pos])) ? pos : -1 );\n  } /* Continuation */\n\n\nstatic BOOL Section( FILE *InFile, BOOL (*sfunc)(char *) )\n  /* ------------------------------------------------------------------------ **\n   * Scan a section name, and pass the name to function sfunc().\n   *\n   *  Input:  InFile  - Input source.\n   *          sfunc   - Pointer to the function to be called if the section\n   *                    name is successfully read.\n   *\n   *  Output: True if the section name was read and True was returned from\n   *          <sfunc>.  False if <sfunc> failed or if a lexical error was\n   *          encountered.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  int   c;\n  int   i;\n  int   end;\n  char *func  = \"params.c:Section() -\";\n\n  i = 0;      /* <i> is the offset of the next free byte in bufr[] and  */\n  end = 0;    /* <end> is the current \"end of string\" offset.  In most  */\n              /* cases these will be the same, but if the last          */\n              /* character written to bufr[] is a space, then <end>     */\n              /* will be one less than <i>.                             */\n\n  c = EatWhitespace( InFile );    /* We've already got the '['.  Scan */\n                                  /* past initial white space.        */\n\n  while( (EOF != c) && (c > 0) )\n    {\n\n    /* Check that the buffer is big enough for the next character. */\n    if( i > (bSize - 2) )\n      {\n      bSize += BUFR_INC;\n      bufr   = realloc_array( bufr, char, bSize );\n      }\n\n    /* Handle a single character. */\n    switch( c )\n      {\n      case ']':                       /* Found the closing bracket.         */\n        bufr[end] = '\\0';\n        if( 0 == end )                  /* Don't allow an empty name.       */\n          {\n          rprintf(FLOG, \"%s Empty section name in config file.\\n\", func );\n          return( False );\n          }\n        if( !sfunc( bufr ) )            /* Got a valid name.  Deal with it. */\n          return( False );\n        (void)EatComment( InFile );     /* Finish off the line.             */\n        return( True );\n\n      case '\\n':                      /* Got newline before closing ']'.    */\n        i = Continuation( bufr, i );    /* Check for line continuation.     */\n        if( i < 0 )\n          {\n          bufr[end] = '\\0';\n          rprintf(FLOG, \"%s Badly formed line in config file: %s\\n\",\n                   func, bufr );\n          return( False );\n          }\n        end = ( (i > 0) && (' ' == bufr[i - 1]) ) ? (i - 1) : (i);\n        c = getc( InFile );             /* Continue with next line.         */\n        break;\n\n      default:                        /* All else are a valid name chars.   */\n        if( isspace( c ) )              /* One space per whitespace region. */\n          {\n          bufr[end] = ' ';\n          i = end + 1;\n          c = EatWhitespace( InFile );\n          }\n        else                            /* All others copy verbatim.        */\n          {\n          bufr[i++] = c;\n          end = i;\n          c = getc( InFile );\n          }\n      }\n    }\n\n  /* We arrive here if we've met the EOF before the closing bracket. */\n  rprintf(FLOG, \"%s Unexpected EOF in the config file: %s\\n\", func, bufr );\n  return( False );\n  } /* Section */\n\nstatic BOOL Parameter( FILE *InFile, BOOL (*pfunc)(char *, char *), int c )\n  /* ------------------------------------------------------------------------ **\n   * Scan a parameter name and value, and pass these two fields to pfunc().\n   *\n   *  Input:  InFile  - The input source.\n   *          pfunc   - A pointer to the function that will be called to\n   *                    process the parameter, once it has been scanned.\n   *          c       - The first character of the parameter name, which\n   *                    would have been read by Parse().  Unlike a comment\n   *                    line or a section header, there is no lead-in\n   *                    character that can be discarded.\n   *\n   *  Output: True if the parameter name and value were scanned and processed\n   *          successfully, else False.\n   *\n   *  Notes:  This function is in two parts.  The first loop scans the\n   *          parameter name.  Internal whitespace is compressed, and an\n   *          equal sign (=) terminates the token.  Leading and trailing\n   *          whitespace is discarded.  The second loop scans the parameter\n   *          value.  When both have been successfully identified, they are\n   *          passed to pfunc() for processing.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  int   i       = 0;    /* Position within bufr. */\n  int   end     = 0;    /* bufr[end] is current end-of-string. */\n  int   vstart  = 0;    /* Starting position of the parameter value. */\n  char *func    = \"params.c:Parameter() -\";\n\n  /* Read the parameter name. */\n  while( 0 == vstart )  /* Loop until we've found the start of the value. */\n    {\n\n    if( i > (bSize - 2) )       /* Ensure there's space for next char.    */\n      {\n      bSize += BUFR_INC;\n      bufr   = realloc_array( bufr, char, bSize );\n      }\n\n    switch( c )\n      {\n      case '=':                 /* Equal sign marks end of param name. */\n        if( 0 == end )              /* Don't allow an empty name.      */\n          {\n          rprintf(FLOG, \"%s Invalid parameter name in config file.\\n\", func );\n          return( False );\n          }\n        bufr[end++] = '\\0';         /* Mark end of string & advance.   */\n        i = vstart = end;           /* New string starts here.         */\n        c = EatWhitespace(InFile);\n        break;\n\n      case '\\n':                /* Find continuation char, else error. */\n        i = Continuation( bufr, i );\n        if( i < 0 )\n          {\n          bufr[end] = '\\0';\n          rprintf(FLOG, \"%s Ignoring badly formed line in config file: %s\\n\",\n                   func, bufr );\n          return( True );\n          }\n        end = ( (i > 0) && (' ' == bufr[i - 1]) ) ? (i - 1) : (i);\n        c = getc( InFile );       /* Read past eoln.                   */\n        break;\n\n      case '\\0':                /* Shouldn't have EOF within param name. */\n      case EOF:\n        bufr[i] = '\\0';\n        rprintf(FLOG, \"%s Unexpected end-of-file at: %s\\n\", func, bufr );\n        return( True );\n\n      case ' ':\n      case '\\t':\n        /* A directive divides at the first space or tab. */\n        if (*bufr == '&') {\n          bufr[end++] = '\\0';\n          i = vstart = end;\n          c = EatWhitespace(InFile);\n          if (c == '=')\n            c = EatWhitespace(InFile);\n          break;\n        }\n        /* FALL THROUGH */\n\n      default:\n        if( isspace( c ) )     /* One ' ' per whitespace region.       */\n          {\n          bufr[end] = ' ';\n          i = end + 1;\n          c = EatWhitespace( InFile );\n          }\n        else                   /* All others verbatim.                 */\n          {\n          bufr[i++] = c;\n          end = i;\n          c = getc( InFile );\n          }\n      }\n    }\n\n  /* Now parse the value. */\n  while( (EOF !=c) && (c > 0) )\n    {\n\n    if( i > (bSize - 2) )       /* Make sure there's enough room. */\n      {\n      bSize += BUFR_INC;\n      bufr   = realloc_array( bufr, char, bSize );\n      }\n\n    switch( c )\n      {\n      case '\\r':              /* Explicitly remove '\\r' because the older */\n        c = getc( InFile );   /* version called fgets_slash() which also  */\n        break;                /* removes them.                            */\n\n      case '\\n':              /* Marks end of value unless there's a '\\'. */\n        i = Continuation( bufr, i );\n        if( i < 0 )\n          c = 0;\n        else\n          {\n          for( end = i; end >= 0 && isSpace(bufr + end); end-- )\n            ;\n          c = getc( InFile );\n          }\n        break;\n\n      default:               /* All others verbatim.  Note that spaces do */\n        bufr[i++] = c;       /* not advance <end>.  This allows trimming  */\n        if( !isspace( c ) )  /* of whitespace at the end of the line.     */\n          end = i;\n        c = getc( InFile );\n        break;\n      }\n    }\n  bufr[end] = '\\0';          /* End of value. */\n\n  return( pfunc( bufr, &bufr[vstart] ) );   /* Pass name & value to pfunc().  */\n  } /* Parameter */\n\nstatic int name_cmp(const void *n1, const void *n2)\n{\n    return strcmp(*(char * const *)n1, *(char * const *)n2);\n}\n\nstatic int include_config(char *include, int manage_globals)\n{\n    STRUCT_STAT sb;\n    char *match = manage_globals ? \"*.conf\" : \"*.inc\";\n    int ret;\n\n    if (do_stat(include, &sb) < 0) {\n\trsyserr(FLOG, errno, \"unable to stat config file \\\"%s\\\"\", include);\n\treturn 0;\n    }\n\n    if (S_ISREG(sb.st_mode)) {\n\tif (manage_globals && the_sfunc)\n\t    the_sfunc(\"]push\");\n\tret = pm_process(include, the_sfunc, the_pfunc);\n\tif (manage_globals && the_sfunc)\n\t    the_sfunc(\"]pop\");\n    } else if (S_ISDIR(sb.st_mode)) {\n\tchar buf[MAXPATHLEN], **bpp;\n\titem_list conf_list;\n\tstruct dirent *di;\n\tsize_t j;\n\tDIR *d;\n\n\tif (!(d = opendir(include))) {\n\t    rsyserr(FLOG, errno, \"unable to open config dir \\\"%s\\\"\", include);\n\t    return 0;\n\t}\n\n\tmemset(&conf_list, 0, sizeof conf_list);\n\n\twhile ((di = readdir(d)) != NULL) {\n\t    char *dname = d_name(di);\n\t    if (!wildmatch(match, dname))\n\t\tcontinue;\n\t    bpp = EXPAND_ITEM_LIST(&conf_list, char *, 32);\n\t    pathjoin(buf, sizeof buf, include, dname);\n\t    *bpp = strdup(buf);\n\t}\n\tclosedir(d);\n\n\tif (!(bpp = conf_list.items))\n\t    return 1;\n\n\tif (conf_list.count > 1)\n\t    qsort(bpp, conf_list.count, sizeof (char *), name_cmp);\n\n\tfor (j = 0, ret = 1; j < conf_list.count; j++) {\n\t    if (manage_globals && the_sfunc)\n\t\tthe_sfunc(j == 0 ? \"]push\" : \"]reset\");\n\t    if ((ret = pm_process(bpp[j], the_sfunc, the_pfunc)) != 1)\n\t\tbreak;\n\t}\n\n\tif (manage_globals && the_sfunc)\n\t    the_sfunc(\"]pop\");\n\n\tfor (j = 0; j < conf_list.count; j++)\n\t    free(bpp[j]);\n\tfree(bpp);\n    } else\n\tret = 0;\n\n    return ret;\n}\n\nstatic int parse_directives(char *name, char *val)\n{\n    if (strcasecmp(name, \"&include\") == 0)\n        return include_config(val, 1);\n    if (strcasecmp(name, \"&merge\") == 0)\n        return include_config(val, 0);\n    rprintf(FLOG, \"Unknown directive: %s.\\n\", name);\n    return 0;\n}\n\nstatic int Parse( FILE *InFile,\n                   BOOL (*sfunc)(char *),\n                   BOOL (*pfunc)(char *, char *) )\n  /* ------------------------------------------------------------------------ **\n   * Scan & parse the input.\n   *\n   *  Input:  InFile  - Input source.\n   *          sfunc   - Function to be called when a section name is scanned.\n   *                    See Section().\n   *          pfunc   - Function to be called when a parameter is scanned.\n   *                    See Parameter().\n   *\n   *  Output: 1 if the file was successfully scanned, 2 if the file was\n   *  scanned until a section header with no section function, else 0.\n   *\n   *  Notes:  The input can be viewed in terms of 'lines'.  There are four\n   *          types of lines:\n   *            Blank      - May contain whitespace, otherwise empty.\n   *            Comment    - First non-whitespace character is a ';' or '#'.\n   *                         The remainder of the line is ignored.\n   *            Section    - First non-whitespace character is a '['.\n   *            Parameter  - The default case.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  int    c;\n\n  c = EatWhitespace( InFile );\n  while( (EOF != c) && (c > 0) )\n    {\n    switch( c )\n      {\n      case '\\n':                        /* Blank line. */\n        c = EatWhitespace( InFile );\n        break;\n\n      case ';':                         /* Comment line. */\n      case '#':\n        c = EatComment( InFile );\n        break;\n\n      case '[':                         /* Section Header. */\n        if (!sfunc)\n          return 2;\n        if( !Section( InFile, sfunc ) )\n          return 0;\n        c = EatWhitespace( InFile );\n        break;\n\n      case '\\\\':                        /* Bogus backslash. */\n        c = EatWhitespace( InFile );\n        break;\n\n      case '&':                         /* Handle directives */\n        the_sfunc = sfunc;\n        the_pfunc = pfunc;\n        c = Parameter( InFile, parse_directives, c );\n        if (c != 1)\n          return c;\n        c = EatWhitespace( InFile );\n        break;\n\n      default:                          /* Parameter line. */\n        if( !Parameter( InFile, pfunc, c ) )\n          return 0;\n        c = EatWhitespace( InFile );\n        break;\n      }\n    }\n  return 1;\n  } /* Parse */\n\nstatic FILE *OpenConfFile( char *FileName )\n  /* ------------------------------------------------------------------------ **\n   * Open a config file.\n   *\n   *  Input:  FileName  - The pathname of the config file to be opened.\n   *\n   *  Output: A pointer of type (FILE *) to the opened file, or NULL if the\n   *          file could not be opened.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  FILE *OpenedFile;\n  char *func = \"params.c:OpenConfFile() -\";\n\n  if( NULL == FileName || 0 == *FileName )\n    {\n    rprintf(FLOG, \"%s No config filename specified.\\n\", func);\n    return( NULL );\n    }\n\n  OpenedFile = fopen( FileName, \"r\" );\n  if( NULL == OpenedFile )\n    {\n    rsyserr(FLOG, errno, \"unable to open config file \\\"%s\\\"\",\n\t    FileName);\n    }\n\n  return( OpenedFile );\n  } /* OpenConfFile */\n\nint pm_process( char *FileName,\n                 BOOL (*sfunc)(char *),\n                 BOOL (*pfunc)(char *, char *) )\n  /* ------------------------------------------------------------------------ **\n   * Process the named parameter file.\n   *\n   *  Input:  FileName  - The pathname of the parameter file to be opened.\n   *          sfunc     - A pointer to a function that will be called when\n   *                      a section name is discovered.\n   *          pfunc     - A pointer to a function that will be called when\n   *                      a parameter name and value are discovered.\n   *\n   *  Output: 1 if the file was successfully parsed, 2 if parsing ended at a\n   *  section header w/o a section function, else 0.\n   *\n   * ------------------------------------------------------------------------ **\n   */\n  {\n  int   result;\n  FILE *InFile;\n  char *func = \"params.c:pm_process() -\";\n\n  InFile = OpenConfFile( FileName );          /* Open the config file. */\n  if( NULL == InFile )\n    return( False );\n\n  if( NULL != bufr )                          /* If we already have a buffer */\n    result = Parse( InFile, sfunc, pfunc );   /* (recursive call), then just */\n                                              /* use it.                     */\n\n  else                                        /* If we don't have a buffer   */\n    {                                         /* allocate one, then parse,   */\n    bSize = BUFR_INC;                         /* then free.                  */\n    bufr = new_array( char, bSize );\n    result = Parse( InFile, sfunc, pfunc );\n    free( bufr );\n    bufr  = NULL;\n    bSize = 0;\n    }\n\n  fclose(InFile);\n\n  if( !result )                               /* Generic failure. */\n    {\n    rprintf(FLOG, \"%s Failed.  Error returned from params.c:parse().\\n\", func);\n    return 0;\n    }\n\n  return result;\n  } /* pm_process */\n\n/* -------------------------------------------------------------------------- */\n\n"
        },
        {
          "name": "pipe.c",
          "type": "blob",
          "size": 5.080078125,
          "content": "/*\n * Routines used to setup various kinds of inter-process pipes.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2004-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\nextern int am_sender;\nextern int am_server;\nextern int blocking_io;\nextern int filesfrom_fd;\nextern int munge_symlinks;\nextern char *logfile_name;\nextern int remote_option_cnt;\nextern const char **remote_options;\nextern struct chmod_mode_struct *chmod_modes;\n\n/**\n * Create a child connected to us via its stdin/stdout.\n *\n * This is derived from CVS code\n *\n * Note that in the child STDIN is set to blocking and STDOUT\n * is set to non-blocking. This is necessary as rsh relies on stdin being blocking\n *  and ssh relies on stdout being non-blocking\n *\n * If blocking_io is set then use blocking io on both fds. That can be\n * used to cope with badly broken rsh implementations like the one on\n * Solaris.\n **/\npid_t piped_child(char **command, int *f_in, int *f_out)\n{\n\tpid_t pid;\n\tint to_child_pipe[2];\n\tint from_child_pipe[2];\n\n\tif (DEBUG_GTE(CMD, 1))\n\t\tprint_child_argv(\"opening connection using:\", command);\n\n\tif (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {\n\t\trsyserr(FERROR, errno, \"pipe\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tpid = do_fork();\n\tif (pid == -1) {\n\t\trsyserr(FERROR, errno, \"fork\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tif (pid == 0) {\n\t\tif (dup2(to_child_pipe[0], STDIN_FILENO) < 0\n\t\t || close(to_child_pipe[1]) < 0\n\t\t || close(from_child_pipe[0]) < 0\n\t\t || dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {\n\t\t\trsyserr(FERROR, errno, \"Failed to dup/close\");\n\t\t\texit_cleanup(RERR_IPC);\n\t\t}\n\t\tif (to_child_pipe[0] != STDIN_FILENO)\n\t\t\tclose(to_child_pipe[0]);\n\t\tif (from_child_pipe[1] != STDOUT_FILENO)\n\t\t\tclose(from_child_pipe[1]);\n\t\tset_blocking(STDIN_FILENO);\n\t\tif (blocking_io > 0)\n\t\t\tset_blocking(STDOUT_FILENO);\n\t\texecvp(command[0], command);\n\t\trsyserr(FERROR, errno, \"Failed to exec %s\", command[0]);\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tif (close(from_child_pipe[1]) < 0 || close(to_child_pipe[0]) < 0) {\n\t\trsyserr(FERROR, errno, \"Failed to close\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\t*f_in = from_child_pipe[0];\n\t*f_out = to_child_pipe[1];\n\n\treturn pid;\n}\n\n/* This function forks a child which calls child_main().  First,\n * however, it has to establish communication paths to and from the\n * newborn child.  It creates two socket pairs -- one for writing to\n * the child (from the parent) and one for reading from the child\n * (writing to the parent).  Since that's four socket ends, each\n * process has to close the two ends it doesn't need.  The remaining\n * two socket ends are retained for reading and writing.  In the\n * child, the STDIN and STDOUT file descriptors refer to these\n * sockets.  In the parent, the function arguments f_in and f_out are\n * set to refer to these sockets. */\npid_t local_child(int argc, char **argv, int *f_in, int *f_out,\n\t\t  int (*child_main)(int, char*[]))\n{\n\tpid_t pid;\n\tint to_child_pipe[2];\n\tint from_child_pipe[2];\n\n\t/* The parent process is always the sender for a local rsync. */\n\tassert(am_sender);\n\n\tif (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {\n\t\trsyserr(FERROR, errno, \"pipe\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tpid = do_fork();\n\tif (pid == -1) {\n\t\trsyserr(FERROR, errno, \"fork\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tif (pid == 0) {\n\t\tam_sender = 0;\n\t\tam_server = 1;\n\t\tfilesfrom_fd = -1;\n\t\tmunge_symlinks = 0; /* Each side needs its own option. */\n\t\tchmod_modes = NULL; /* Let the sending side handle this. */\n\n\t\t/* Let the client side handle this. */\n\t\tif (logfile_name) {\n\t\t\tlogfile_name = NULL;\n\t\t\tlogfile_close();\n\t\t}\n\n\t\tif (remote_option_cnt) {\n\t\t\tint rc = remote_option_cnt + 1;\n\t\t\tconst char **rv = remote_options;\n\t\t\tif (!parse_arguments(&rc, &rv)) {\n\t\t\t\toption_error();\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t}\n\n\t\tif (dup2(to_child_pipe[0], STDIN_FILENO) < 0\n\t\t || close(to_child_pipe[1]) < 0\n\t\t || close(from_child_pipe[0]) < 0\n\t\t || dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {\n\t\t\trsyserr(FERROR, errno, \"Failed to dup/close\");\n\t\t\texit_cleanup(RERR_IPC);\n\t\t}\n\t\tif (to_child_pipe[0] != STDIN_FILENO)\n\t\t\tclose(to_child_pipe[0]);\n\t\tif (from_child_pipe[1] != STDOUT_FILENO)\n\t\t\tclose(from_child_pipe[1]);\n#ifdef ICONV_CONST\n\t\tsetup_iconv();\n#endif\n\t\tchild_main(argc, argv);\n\t}\n\n\tif (close(from_child_pipe[1]) < 0 || close(to_child_pipe[0]) < 0) {\n\t\trsyserr(FERROR, errno, \"Failed to close\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\t*f_in = from_child_pipe[0];\n\t*f_out = to_child_pipe[1];\n\n\treturn pid;\n}\n"
        },
        {
          "name": "popt",
          "type": "tree",
          "content": null
        },
        {
          "name": "prepare-source",
          "type": "blob",
          "size": 1.6884765625,
          "content": "#!/bin/sh\n# Either use autoconf and autoheader to create configure.sh and config.h.in\n# or (optionally) fetch the latest development versions of generated files.\n#\n# Specify one action or more than one to provide a fall-back:\n#\n#   build     build the config files [the default w/no arg]\n#   fetch     fetch the latest dev autoconfig files\n#   fetchgen  fetch all the latest dev generated files (including manpages)\n#   fetchSRC  fetch the latest dev source files [NON-GENERATED FILES]\n#\n# The script stops after the first successful action.\n\ndir=`dirname $0`\nif test x\"$dir\" = x; then\n    dir=.\nfi\n\nif test \"$dir\" = '.'; then\n    branch=`packaging/prep-auto-dir` || exit 1\n    if test x\"$branch\" != x; then\n\tcd build || exit 1\n\tdir=..\n    fi\nfi\n\nif test \"$dir\" != '.'; then\n    for lnk in configure.ac m4; do\n\tif test ! -h $lnk; then\n\t    rm -f $lnk # Just in case\n\t    ln -s \"$dir/$lnk\" $lnk\n\tfi\n    done\n    for fn in configure.sh config.h.in aclocal.m4; do\n\ttest ! -f $fn && test -f \"$dir/$fn\" && cp -p \"$dir/$fn\" $fn\n    done\nfi\n\nif test $# = 0; then\n    set -- build\nfi\n\nfor action in \"${@}\"; do\n    case \"$action\" in\n    build|make)\n\tmake -f \"$dir/prepare-source.mak\"\n\t;;\n    fetch|fetchgen)\n\tif test \"$action\" = fetchgen; then\n\t    match='*'\n\telse\n\t    match='[ca]*'\n\tfi\n\t$dir/rsync-ssl -iipc --no-motd \"rsync://download.samba.org/rsyncftp/generated-files/$match\" ./\n\ttest $? != 0 && continue\n\tsleep 1 # The following files need to be newer than aclocal.m4\n\ttouch configure.sh config.h.in\n\t;;\n    fetchSRC)\n\t./rsync-ssl -iipr --no-motd --exclude=/.git/ rsync://download.samba.org/ftp/pub/unpacked/rsync/ .\n\t;;\n    *)\n\techo \"Unknown action: $action\"\n\texit 1\n\t;;\n    esac\n    if test $? = 0; then\n\texit\n    fi\ndone\n\nexit 1\n"
        },
        {
          "name": "prepare-source.mak",
          "type": "blob",
          "size": 0.2255859375,
          "content": "SHELL=/bin/sh\n\nconf: configure.sh config.h.in\n.PHONY: conf\n\naclocal.m4: m4/*.m4\n\taclocal -I m4\n\nconfigure.sh: configure.ac aclocal.m4\n\tautoconf -o configure.sh\n\nconfig.h.in: configure.ac aclocal.m4\n\tautoheader && touch config.h.in\n"
        },
        {
          "name": "progress.c",
          "type": "blob",
          "size": 6.328125,
          "content": "/*\n * Routines to output progress information during a file transfer.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n\nextern int am_server;\nextern int flist_eof;\nextern int quiet;\nextern int need_unsorted_flist;\nextern int output_needs_newline;\nextern int stdout_format_has_i;\nextern struct stats stats;\nextern struct file_list *cur_flist;\n\nBOOL want_progress_now = False;\n\n#define PROGRESS_HISTORY_SECS 5\n\n#ifdef GETPGRP_VOID\n#define GETPGRP_ARG\n#else\n#define GETPGRP_ARG 0\n#endif\n\nstruct progress_history {\n\tstruct timeval time;\n\tOFF_T ofs;\n};\n\nstatic struct progress_history ph_start;\nstatic struct progress_history ph_list[PROGRESS_HISTORY_SECS];\nstatic int newest_hpos, oldest_hpos;\nstatic int current_file_index;\n\nstatic unsigned long msdiff(struct timeval *t1, struct timeval *t2)\n{\n\treturn (t2->tv_sec - t1->tv_sec) * 1000L\n\t     + (t2->tv_usec - t1->tv_usec) / 1000;\n}\n\n\n/**\n * @param ofs Current position in file\n * @param size Total size of file\n * @param is_last True if this is the last time progress will be\n * printed for this file, so we should output a newline.  (Not\n * necessarily the same as all bytes being received.)\n **/\nstatic void rprint_progress(OFF_T ofs, OFF_T size, struct timeval *now, int is_last)\n{\n\tchar rembuf[64], eol[128];\n\tconst char *units;\n\tunsigned long diff;\n\tdouble rate, remain;\n\tint pct;\n\n\tif (is_last) {\n\t\tint len = snprintf(eol, sizeof eol,\n\t\t\t\" (xfr#%d, %s-chk=%d/%d)\\n\",\n\t\t\tstats.xferred_files, flist_eof ? \"to\" : \"ir\",\n\t\t\tstats.num_files - current_file_index - 1,\n\t\t\tstats.num_files);\n\t\tif (INFO_GTE(PROGRESS, 2)) {\n\t\t\tstatic int last_len = 0;\n\t\t\t/* Drop \\n and pad with spaces if line got shorter. */\n\t\t\tif (last_len < --len)\n\t\t\t\tlast_len = len;\n\t\t\teol[last_len] = '\\0';\n\t\t\twhile (last_len > len)\n\t\t\t\teol[--last_len] = ' ';\n\t\t\tis_last = 0;\n\t\t}\n\t\t/* Compute stats based on the starting info. */\n\t\tif (!ph_start.time.tv_sec || !(diff = msdiff(&ph_start.time, now)))\n\t\t\tdiff = 1;\n\t\trate = (double) (ofs - ph_start.ofs) * 1000.0 / diff / 1024.0;\n\t\t/* Switch to total time taken for our last update. */\n\t\tremain = (double) diff / 1000.0;\n\t} else {\n\t\tstrlcpy(eol, \"  \", sizeof eol);\n\t\t/* Compute stats based on recent progress. */\n\t\tif (!(diff = msdiff(&ph_list[oldest_hpos].time, now)))\n\t\t\tdiff = 1;\n\t\trate = (double) (ofs - ph_list[oldest_hpos].ofs) * 1000.0 / diff / 1024.0;\n\t\tremain = rate ? (double) (size - ofs) / rate / 1000.0 : 0.0;\n\t}\n\n\tif (rate > 1024*1024) {\n\t\trate /= 1024.0 * 1024.0;\n\t\tunits = \"GB/s\";\n\t} else if (rate > 1024) {\n\t\trate /= 1024.0;\n\t\tunits = \"MB/s\";\n\t} else {\n\t\tunits = \"kB/s\";\n\t}\n\n\tif (remain < 0 || remain > 9999.0 * 3600.0)\n\t\tstrlcpy(rembuf, \"  ??:??:??\", sizeof rembuf);\n\telse {\n\t\tsnprintf(rembuf, sizeof rembuf, \"%4u:%02u:%02u\",\n\t\t\t (unsigned int) (remain / 3600.0),\n\t\t\t (unsigned int) (remain / 60.0) % 60,\n\t\t\t (unsigned int) remain % 60);\n\t}\n\n\toutput_needs_newline = 0;\n\tpct = ofs == size ? 100 : (int) (100.0 * ofs / size);\n\trprintf(FCLIENT, \"\\r%15s %3d%% %7.2f%s %s%s\",\n\t\thuman_num(ofs), pct, rate, units, rembuf, eol);\n\tif (!is_last && !quiet) {\n\t\toutput_needs_newline = 1;\n\t\trflush(FCLIENT);\n\t}\n}\n\nvoid progress_init(void)\n{\n\tif (!am_server && !INFO_GTE(PROGRESS, 1)) {\n\t\tstruct timeval now;\n\t\tgettimeofday(&now, NULL);\n\t\tph_start.time.tv_sec = now.tv_sec;\n\t\tph_start.time.tv_usec = now.tv_usec;\n\t}\n}\n\nvoid set_current_file_index(struct file_struct *file, int ndx)\n{\n\tif (!file)\n\t\tcurrent_file_index = cur_flist->used + cur_flist->ndx_start - 1;\n\telse if (need_unsorted_flist)\n\t\tcurrent_file_index = flist_find(cur_flist, file) + cur_flist->ndx_start;\n\telse\n\t\tcurrent_file_index = ndx;\n\tcurrent_file_index -= cur_flist->flist_num;\n}\n\nvoid instant_progress(const char *fname)\n{\n\t/* We only get here if want_progress_now is True */\n\tif (!stdout_format_has_i && !INFO_GTE(NAME, 1))\n\t\trprintf(FINFO, \"%s\\n\", fname);\n\tend_progress(0);\n\twant_progress_now = False;\n}\n\nvoid end_progress(OFF_T size)\n{\n\tif (!am_server) {\n\t\tstruct timeval now;\n\t\tgettimeofday(&now, NULL);\n\t\tif (INFO_GTE(PROGRESS, 2) || want_progress_now) {\n\t\t\trprint_progress(stats.total_transferred_size,\n\t\t\t\t\tstats.total_size, &now, True);\n\t\t} else {\n\t\t\trprint_progress(size, size, &now, True);\n\t\t\tmemset(&ph_start, 0, sizeof ph_start);\n\t\t}\n\t}\n}\n\nvoid show_progress(OFF_T ofs, OFF_T size)\n{\n\tstruct timeval now;\n#if defined HAVE_GETPGRP && defined HAVE_TCGETPGRP\n\tstatic pid_t pgrp = -1;\n\tpid_t tc_pgrp;\n#endif\n\n\tif (am_server)\n\t\treturn;\n\n#if defined HAVE_GETPGRP && defined HAVE_TCGETPGRP\n\tif (pgrp == -1)\n\t\tpgrp = getpgrp(GETPGRP_ARG);\n#endif\n\n\tgettimeofday(&now, NULL);\n\n\tif (INFO_GTE(PROGRESS, 2)) {\n\t\tofs = stats.total_transferred_size - size + ofs;\n\t\tsize = stats.total_size;\n\t}\n\n\tif (!ph_start.time.tv_sec) {\n\t\tint i;\n\n\t\t/* Try to guess the real starting time when the sender started\n\t\t * to send us data by using the time we last received some data\n\t\t * in the last file (if it was recent enough). */\n\t\tif (msdiff(&ph_list[newest_hpos].time, &now) <= 1500) {\n\t\t\tph_start.time = ph_list[newest_hpos].time;\n\t\t\tph_start.ofs = 0;\n\t\t} else {\n\t\t\tph_start.time.tv_sec = now.tv_sec;\n\t\t\tph_start.time.tv_usec = now.tv_usec;\n\t\t\tph_start.ofs = ofs;\n\t\t}\n\n\t\tfor (i = 0; i < PROGRESS_HISTORY_SECS; i++)\n\t\t\tph_list[i] = ph_start;\n\t}\n\telse {\n\t\tif (msdiff(&ph_list[newest_hpos].time, &now) < 1000)\n\t\t\treturn;\n\n\t\tnewest_hpos = oldest_hpos;\n\t\toldest_hpos = (oldest_hpos + 1) % PROGRESS_HISTORY_SECS;\n\t\tph_list[newest_hpos].time.tv_sec = now.tv_sec;\n\t\tph_list[newest_hpos].time.tv_usec = now.tv_usec;\n\t\tph_list[newest_hpos].ofs = ofs;\n\t}\n\n#if defined HAVE_GETPGRP && defined HAVE_TCGETPGRP\n\ttc_pgrp = tcgetpgrp(STDOUT_FILENO);\n\tif (tc_pgrp != pgrp && tc_pgrp != -1)\n\t\treturn;\n#endif\n\n\trprint_progress(ofs, size, &now, False);\n}\n"
        },
        {
          "name": "receiver.c",
          "type": "blob",
          "size": 27.6162109375,
          "content": "/*\n * Routines only used by the receiving process.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2003-2023 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n\nextern int dry_run;\nextern int do_xfers;\nextern int am_root;\nextern int am_server;\nextern int inc_recurse;\nextern int log_before_transfer;\nextern int stdout_format_has_i;\nextern int logfile_format_has_i;\nextern int want_xattr_optim;\nextern int csum_length;\nextern int read_batch;\nextern int write_batch;\nextern int batch_gen_fd;\nextern int protocol_version;\nextern int relative_paths;\nextern int preserve_hard_links;\nextern int preserve_perms;\nextern int write_devices;\nextern int preserve_xattrs;\nextern int do_fsync;\nextern int basis_dir_cnt;\nextern int make_backups;\nextern int cleanup_got_literal;\nextern int remove_source_files;\nextern int append_mode;\nextern int sparse_files;\nextern int preallocate_files;\nextern int keep_partial;\nextern int checksum_seed;\nextern int whole_file;\nextern int inplace;\nextern int inplace_partial;\nextern int allowed_lull;\nextern int delay_updates;\nextern BOOL want_progress_now;\nextern mode_t orig_umask;\nextern struct stats stats;\nextern char *tmpdir;\nextern char *partial_dir;\nextern char *basis_dir[MAX_BASIS_DIRS+1];\nextern char sender_file_sum[MAX_DIGEST_LEN];\nextern struct file_list *cur_flist, *first_flist, *dir_flist;\nextern filter_rule_list daemon_filter_list;\nextern OFF_T preallocated_len;\n\nextern struct name_num_item *xfer_sum_nni;\nextern int xfer_sum_len;\n\nstatic struct bitbag *delayed_bits = NULL;\nstatic int phase = 0, redoing = 0;\nstatic flist_ndx_list batch_redo_list;\n/* This is non-0 when we are updating the basis file or an identical copy: */\nstatic int updating_basis_or_equiv;\n\n#define TMPNAME_SUFFIX \".XXXXXX\"\n#define TMPNAME_SUFFIX_LEN ((int)sizeof TMPNAME_SUFFIX - 1)\n#define MAX_UNIQUE_NUMBER 999999\n#define MAX_UNIQUE_LOOP 100\n\n/* get_tmpname() - create a tmp filename for a given filename\n *\n * If a tmpdir is defined, use that as the directory to put it in.  Otherwise,\n * the tmp filename is in the same directory as the given name.  Note that\n * there may be no directory at all in the given name!\n *\n * The tmp filename is basically the given filename with a dot prepended, and\n * .XXXXXX appended (for mkstemp() to put its unique gunk in).  We take care\n * to not exceed either the MAXPATHLEN or NAME_MAX, especially the last, as\n * the basename basically becomes 8 characters longer.  In such a case, the\n * original name is shortened sufficiently to make it all fit.\n *\n * If the make_unique arg is True, the XXXXXX string is replaced with a unique\n * string that doesn't exist at the time of the check.  This is intended to be\n * used for creating hard links, symlinks, devices, and special files, since\n * normal files should be handled by mkstemp() for safety.\n *\n * Of course, the only reason the file is based on the original name is to\n * make it easier to figure out what purpose a temp file is serving when a\n * transfer is in progress. */\nint get_tmpname(char *fnametmp, const char *fname, BOOL make_unique)\n{\n\tint maxname, length = 0;\n\tconst char *f;\n\tchar *suf;\n\n\tif (tmpdir) {\n\t\t/* Note: this can't overflow, so the return value is safe */\n\t\tlength = strlcpy(fnametmp, tmpdir, MAXPATHLEN - 2);\n\t\tfnametmp[length++] = '/';\n\t}\n\n\tif ((f = strrchr(fname, '/')) != NULL) {\n\t\t++f;\n\t\tif (!tmpdir) {\n\t\t\tlength = f - fname;\n\t\t\t/* copy up to and including the slash */\n\t\t\tstrlcpy(fnametmp, fname, length + 1);\n\t\t}\n\t} else\n\t\tf = fname;\n\n\tif (!tmpdir) { /* using a tmpdir avoids the leading dot on our temp names */\n\t\tif (*f == '.') /* avoid an extra leading dot for OS X's sake */\n\t\t\tf++;\n\t\tfnametmp[length++] = '.';\n\t}\n\n\t/* The maxname value is bufsize, and includes space for the '\\0'.\n\t * NAME_MAX needs an extra -1 for the name's leading dot. */\n\tmaxname = MIN(MAXPATHLEN - length - TMPNAME_SUFFIX_LEN,\n\t\t      NAME_MAX - 1 - TMPNAME_SUFFIX_LEN);\n\n\tif (maxname < 0) {\n\t\trprintf(FERROR_XFER, \"temporary filename too long: %s\\n\", fname);\n\t\tfnametmp[0] = '\\0';\n\t\treturn 0;\n\t}\n\n\tif (maxname) {\n\t\tint added = strlcpy(fnametmp + length, f, maxname);\n\t\tif (added >= maxname)\n\t\t\tadded = maxname - 1;\n\t\tsuf = fnametmp + length + added;\n\n\t\t/* Trim any dangling high-bit chars if the first-trimmed char (if any) is\n\t\t * also a high-bit char, just in case we cut into a multi-byte sequence.\n\t\t * We are guaranteed to stop because of the leading '.' we added. */\n\t\tif ((int)f[added] & 0x80) {\n\t\t\twhile ((int)suf[-1] & 0x80)\n\t\t\t\tsuf--;\n\t\t}\n\t\t/* trim one trailing dot before our suffix's dot */\n\t\tif (suf[-1] == '.')\n\t\t\tsuf--;\n\t} else\n\t\tsuf = fnametmp + length - 1; /* overwrite the leading dot with suffix's dot */\n\n\tif (make_unique) {\n\t\tstatic unsigned counter_limit;\n\t\tunsigned counter;\n\n\t\tif (!counter_limit) {\n\t\t\tcounter_limit = (unsigned)getpid() + MAX_UNIQUE_LOOP;\n\t\t\tif (counter_limit > MAX_UNIQUE_NUMBER || counter_limit < MAX_UNIQUE_LOOP)\n\t\t\t\tcounter_limit = MAX_UNIQUE_LOOP;\n\t\t}\n\t\tcounter = counter_limit - MAX_UNIQUE_LOOP;\n\n\t\t/* This doesn't have to be very good because we don't need\n\t\t * to worry about someone trying to guess the values:  all\n\t\t * a conflict will do is cause a device, special file, hard\n\t\t * link, or symlink to fail to be created.  Also: avoid\n\t\t * using mktemp() due to gcc's annoying warning. */\n\t\twhile (1) {\n\t\t\tsnprintf(suf, TMPNAME_SUFFIX_LEN+1, \".%d\", counter);\n\t\t\tif (access(fnametmp, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tif (++counter >= counter_limit)\n\t\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tmemcpy(suf, TMPNAME_SUFFIX, TMPNAME_SUFFIX_LEN+1);\n\n\treturn 1;\n}\n\n/* Opens a temporary file for writing.\n * Success: Writes name into fnametmp, returns fd.\n * Failure: Clobbers fnametmp, returns -1.\n * Calling cleanup_set() is the caller's job. */\nint open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file)\n{\n\tint fd;\n\tmode_t added_perms;\n\n\tif (!get_tmpname(fnametmp, fname, False))\n\t\treturn -1;\n\n\tif (am_root < 0) {\n\t\t/* For --fake-super, the file must be useable by the copying\n\t\t * user, just like it would be for root. */\n\t\tadded_perms = S_IRUSR|S_IWUSR;\n\t} else {\n\t\t/* For a normal copy, we need to be able to tweak things like xattrs. */\n\t\tadded_perms = S_IWUSR;\n\t}\n\n\t/* We initially set the perms without the setuid/setgid bits or group\n\t * access to ensure that there is no race condition.  They will be\n\t * correctly updated after the right owner and group info is set.\n\t * (Thanks to snabb@epipe.fi for pointing this out.) */\n\tfd = do_mkstemp(fnametmp, (file->mode|added_perms) & INITACCESSPERMS);\n\n#if 0\n\t/* In most cases parent directories will already exist because their\n\t * information should have been previously transferred, but that may\n\t * not be the case with -R */\n\tif (fd == -1 && relative_paths && errno == ENOENT\n\t && make_path(fnametmp, MKP_SKIP_SLASH | MKP_DROP_NAME) == 0) {\n\t\t/* Get back to name with XXXXXX in it. */\n\t\tget_tmpname(fnametmp, fname, False);\n\t\tfd = do_mkstemp(fnametmp, (file->mode|added_perms) & INITACCESSPERMS);\n\t}\n#endif\n\n\tif (fd == -1) {\n\t\trsyserr(FERROR_XFER, errno, \"mkstemp %s failed\",\n\t\t\tfull_fname(fnametmp));\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,\n\t\t\tconst char *fname, int fd, struct file_struct *file, int inplace_sizing)\n{\n\tstatic char file_sum1[MAX_DIGEST_LEN];\n\tstruct map_struct *mapbuf;\n\tstruct sum_struct sum;\n\tint32 len;\n\tOFF_T total_size = F_LENGTH(file);\n\tOFF_T offset = 0;\n\tOFF_T offset2;\n\tchar *data;\n\tint32 i;\n\tchar *map = NULL;\n\n#ifdef SUPPORT_PREALLOCATION\n\tif (preallocate_files && fd != -1 && total_size > 0 && (!inplace_sizing || total_size > size_r)) {\n\t\t/* Try to preallocate enough space for file's eventual length.  Can\n\t\t * reduce fragmentation on filesystems like ext4, xfs, and NTFS. */\n\t\tif ((preallocated_len = do_fallocate(fd, 0, total_size)) < 0)\n\t\t\trsyserr(FWARNING, errno, \"do_fallocate %s\", full_fname(fname));\n\t} else\n#endif\n\tif (inplace_sizing) {\n#ifdef HAVE_FTRUNCATE\n\t\t/* The most compatible way to create a sparse file is to start with no length. */\n\t\tif (sparse_files > 0 && whole_file && fd >= 0 && do_ftruncate(fd, 0) == 0)\n\t\t\tpreallocated_len = 0;\n\t\telse\n#endif\n\t\t\tpreallocated_len = size_r;\n\t} else\n\t\tpreallocated_len = 0;\n\n\tread_sum_head(f_in, &sum);\n\n\tif (fd_r >= 0 && size_r > 0) {\n\t\tint32 read_size = MAX(sum.blength * 2, 16*1024);\n\t\tmapbuf = map_file(fd_r, size_r, read_size, sum.blength);\n\t\tif (DEBUG_GTE(DELTASUM, 2)) {\n\t\t\trprintf(FINFO, \"recv mapped %s of size %s\\n\",\n\t\t\t\tfname_r, big_num(size_r));\n\t\t}\n\t} else\n\t\tmapbuf = NULL;\n\n\tsum_init(xfer_sum_nni, checksum_seed);\n\n\tif (append_mode > 0) {\n\t\tOFF_T j;\n\t\tsum.flength = (OFF_T)sum.count * sum.blength;\n\t\tif (sum.remainder)\n\t\t\tsum.flength -= sum.blength - sum.remainder;\n\t\tif (append_mode == 2 && mapbuf) {\n\t\t\tfor (j = CHUNK_SIZE; j < sum.flength; j += CHUNK_SIZE) {\n\t\t\t\tif (INFO_GTE(PROGRESS, 1))\n\t\t\t\t\tshow_progress(offset, total_size);\n\t\t\t\tsum_update(map_ptr(mapbuf, offset, CHUNK_SIZE),\n\t\t\t\t\t   CHUNK_SIZE);\n\t\t\t\toffset = j;\n\t\t\t}\n\t\t\tif (offset < sum.flength) {\n\t\t\t\tint32 len = (int32)(sum.flength - offset);\n\t\t\t\tif (INFO_GTE(PROGRESS, 1))\n\t\t\t\t\tshow_progress(offset, total_size);\n\t\t\t\tsum_update(map_ptr(mapbuf, offset, len), len);\n\t\t\t}\n\t\t}\n\t\toffset = sum.flength;\n\t\tif (fd != -1 && (j = do_lseek(fd, offset, SEEK_SET)) != offset) {\n\t\t\trsyserr(FERROR_XFER, errno, \"lseek of %s returned %s, not %s\",\n\t\t\t\tfull_fname(fname), big_num(j), big_num(offset));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t}\n\n\twhile ((i = recv_token(f_in, &data)) != 0) {\n\t\tif (INFO_GTE(PROGRESS, 1))\n\t\t\tshow_progress(offset, total_size);\n\n\t\tif (allowed_lull)\n\t\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH | MSK_ACTIVE_RECEIVER);\n\n\t\tif (i > 0) {\n\t\t\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\t\t\trprintf(FINFO,\"data recv %d at %s\\n\",\n\t\t\t\t\ti, big_num(offset));\n\t\t\t}\n\n\t\t\tstats.literal_data += i;\n\t\t\tcleanup_got_literal = 1;\n\n\t\t\tsum_update(data, i);\n\n\t\t\tif (fd != -1 && write_file(fd, 0, offset, data, i) != i)\n\t\t\t\tgoto report_write_error;\n\t\t\toffset += i;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = -(i+1);\n\t\toffset2 = i * (OFF_T)sum.blength;\n\t\tlen = sum.blength;\n\t\tif (i == (int)sum.count-1 && sum.remainder != 0)\n\t\t\tlen = sum.remainder;\n\n\t\tstats.matched_data += len;\n\n\t\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"chunk[%d] of size %ld at %s offset=%s%s\\n\",\n\t\t\t\ti, (long)len, big_num(offset2), big_num(offset),\n\t\t\t\tupdating_basis_or_equiv && offset == offset2 ? \" (seek)\" : \"\");\n\t\t}\n\n\t\tif (mapbuf) {\n\t\t\tmap = map_ptr(mapbuf,offset2,len);\n\n\t\t\tsee_token(map, len);\n\t\t\tsum_update(map, len);\n\t\t}\n\n\t\tif (updating_basis_or_equiv) {\n\t\t\tif (offset == offset2 && fd != -1) {\n\t\t\t\tif (skip_matched(fd, offset, map, len) < 0)\n\t\t\t\t\tgoto report_write_error;\n\t\t\t\toffset += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fd != -1 && map && write_file(fd, 0, offset, map, len) != (int)len)\n\t\t\tgoto report_write_error;\n\t\toffset += len;\n\t}\n\n\tif (fd != -1 && offset > 0) {\n\t\tif (sparse_files > 0) {\n\t\t\tif (sparse_end(fd, offset, updating_basis_or_equiv) != 0)\n\t\t\t\tgoto report_write_error;\n\t\t} else if (flush_write_file(fd) < 0) {\n\t\t    report_write_error:\n\t\t\trsyserr(FERROR_XFER, errno, \"write failed on %s\", full_fname(fname));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t}\n\n#ifdef HAVE_FTRUNCATE\n\t/* inplace: New data could be shorter than old data.\n\t * preallocate_files: total_size could have been an overestimate.\n\t *     Cut off any extra preallocated zeros from dest file. */\n\tif ((inplace_sizing || preallocated_len > offset) && fd != -1 && !IS_DEVICE(file->mode)) {\n\t\tif (do_ftruncate(fd, offset) < 0)\n\t\t\trsyserr(FERROR_XFER, errno, \"ftruncate failed on %s\", full_fname(fname));\n\t}\n#endif\n\n\tif (INFO_GTE(PROGRESS, 1))\n\t\tend_progress(total_size);\n\n\tsum_end(file_sum1);\n\n\tif (do_fsync && fd != -1 && fsync(fd) != 0) {\n\t\trsyserr(FERROR, errno, \"fsync failed on %s\", full_fname(fname));\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n\n\tif (mapbuf)\n\t\tunmap_file(mapbuf);\n\n\tread_buf(f_in, sender_file_sum, xfer_sum_len);\n\tif (DEBUG_GTE(DELTASUM, 2))\n\t\trprintf(FINFO,\"got file_sum\\n\");\n\tif (fd != -1 && memcmp(file_sum1, sender_file_sum, xfer_sum_len) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic void discard_receive_data(int f_in, struct file_struct *file)\n{\n\treceive_data(f_in, NULL, -1, 0, NULL, -1, file, 0);\n}\n\nstatic void handle_delayed_updates(char *local_name)\n{\n\tchar *fname, *partialptr;\n\tint ndx;\n\n\tfor (ndx = -1; (ndx = bitbag_next_bit(delayed_bits, ndx)) >= 0; ) {\n\t\tstruct file_struct *file = cur_flist->files[ndx];\n\t\tfname = local_name ? local_name : f_name(file, NULL);\n\t\tif ((partialptr = partial_dir_fname(fname)) != NULL) {\n\t\t\tif (make_backups > 0 && !make_backup(fname, False))\n\t\t\t\tcontinue;\n\t\t\tif (DEBUG_GTE(RECV, 1)) {\n\t\t\t\trprintf(FINFO, \"renaming %s to %s\\n\",\n\t\t\t\t\tpartialptr, fname);\n\t\t\t}\n\t\t\t/* We don't use robust_rename() here because the\n\t\t\t * partial-dir must be on the same drive. */\n\t\t\tif (do_rename(partialptr, fname) < 0) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"rename failed for %s (from %s)\",\n\t\t\t\t\tfull_fname(fname), partialptr);\n\t\t\t} else {\n\t\t\t\tif (remove_source_files || (preserve_hard_links && F_IS_HLINKED(file)))\n\t\t\t\t\tsend_msg_success(fname, ndx);\n\t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void no_batched_update(int ndx, BOOL is_redo)\n{\n\tstruct file_list *flist = flist_for_ndx(ndx, \"no_batched_update\");\n\tstruct file_struct *file = flist->files[ndx - flist->ndx_start];\n\n\trprintf(FERROR_XFER, \"(No batched update for%s \\\"%s\\\")\\n\",\n\t\tis_redo ? \" resend of\" : \"\", f_name(file, NULL));\n\n\tif (inc_recurse && !dry_run)\n\t\tsend_msg_int(MSG_NO_SEND, ndx);\n}\n\nstatic int we_want_redo(int desired_ndx)\n{\n\tstatic int redo_ndx = -1;\n\n\twhile (redo_ndx < desired_ndx) {\n\t\tif (redo_ndx >= 0)\n\t\t\tno_batched_update(redo_ndx, True);\n\t\tif ((redo_ndx = flist_ndx_pop(&batch_redo_list)) < 0)\n\t\t\treturn 0;\n\t}\n\n\tif (redo_ndx == desired_ndx) {\n\t\tredo_ndx = -1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int gen_wants_ndx(int desired_ndx, int flist_num)\n{\n\tstatic int next_ndx = -1;\n\tstatic int done_cnt = 0;\n\tstatic BOOL got_eof = False;\n\n\tif (got_eof)\n\t\treturn 0;\n\n\t/* TODO: integrate gen-reading I/O into perform_io() so this is not needed? */\n\tio_flush(FULL_FLUSH);\n\n\twhile (next_ndx < desired_ndx) {\n\t\tif (inc_recurse && flist_num <= done_cnt)\n\t\t\treturn 0;\n\t\tif (next_ndx >= 0)\n\t\t\tno_batched_update(next_ndx, False);\n\t\tif ((next_ndx = read_int(batch_gen_fd)) < 0) {\n\t\t\tif (inc_recurse) {\n\t\t\t\tdone_cnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgot_eof = True;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (next_ndx == desired_ndx) {\n\t\tnext_ndx = -1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * main routine for receiver process.\n *\n * Receiver process runs on the same host as the generator process. */\nint recv_files(int f_in, int f_out, char *local_name)\n{\n\tint fd1,fd2;\n\tSTRUCT_STAT st;\n\tint iflags, xlen;\n\tchar *fname, fbuf[MAXPATHLEN];\n\tchar xname[MAXPATHLEN];\n\tchar *fnametmp, fnametmpbuf[MAXPATHLEN];\n\tchar *fnamecmp, *partialptr;\n\tchar fnamecmpbuf[MAXPATHLEN];\n\tuchar fnamecmp_type;\n\tstruct file_struct *file;\n\tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;\n\tenum logcode log_code = log_before_transfer ? FLOG : FINFO;\n\tint max_phase = protocol_version >= 29 ? 2 : 1;\n\tint dflt_perms = (ACCESSPERMS & ~orig_umask);\n#ifdef SUPPORT_ACLS\n\tconst char *parent_dirname = \"\";\n#endif\n\tint ndx, recv_ok, one_inplace;\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"recv_files(%d) starting\\n\", cur_flist->used);\n\n\tif (delay_updates)\n\t\tdelayed_bits = bitbag_create(cur_flist->used + 1);\n\n\tif (whole_file < 0)\n\t\twhole_file = 0;\n\n\tprogress_init();\n\n\twhile (1) {\n\t\tcleanup_disable();\n\n\t\t/* This call also sets cur_flist. */\n\t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,\n\t\t\t\t\t xname, &xlen);\n\t\tif (ndx == NDX_DONE) {\n\t\t\tif (!am_server && cur_flist) {\n\t\t\t\tset_current_file_index(NULL, 0);\n\t\t\t\tif (INFO_GTE(PROGRESS, 2))\n\t\t\t\t\tend_progress(0);\n\t\t\t}\n\t\t\tif (inc_recurse && first_flist) {\n\t\t\t\tif (read_batch) {\n\t\t\t\t\tndx = first_flist->used + first_flist->ndx_start;\n\t\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t\t}\n\t\t\t\tflist_free(first_flist);\n\t\t\t\tif (first_flist)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (read_batch && first_flist) {\n\t\t\t\tndx = first_flist->used;\n\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t}\n\t\t\tif (++phase > max_phase)\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\t\trprintf(FINFO, \"recv_files phase=%d\\n\", phase);\n\t\t\tif (phase == 2 && delay_updates)\n\t\t\t\thandle_delayed_updates(local_name);\n\t\t\twrite_int(f_out, NDX_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ndx - cur_flist->ndx_start >= 0)\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\telse\n\t\t\tfile = dir_flist->files[cur_flist->parent_ndx];\n\t\tfname = local_name ? local_name : f_name(file, fbuf);\n\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO, \"recv_files(%s)\\n\", fname);\n\n\t\tif (daemon_filter_list.head && (*fname != '.' || fname[1] != '\\0')) {\n\t\t\tint filt_flags = S_ISDIR(file->mode) ? NAME_IS_DIR : NAME_IS_FILE;\n\t\t\tif (check_filter(&daemon_filter_list, FLOG, fname, filt_flags) < 0) {\n\t\t\t\trprintf(FERROR, \"ERROR: rejecting file transfer request for daemon excluded file: %s\\n\",\n\t\t\t\t\tfname);\n\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t}\n\t\t}\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\t\trecv_xattr_request(file, f_in);\n#endif\n\n\t\tif (!(iflags & ITEM_TRANSFER)) {\n\t\t\tmaybe_log_item(file, iflags, itemizing, xname);\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t\t && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))\n\t\t\t\tset_file_attrs(fname, file, NULL, fname, 0);\n#endif\n\t\t\tif (iflags & ITEM_IS_NEW) {\n\t\t\t\tstats.created_files++;\n\t\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\t\t/* Nothing further to count. */\n\t\t\t\t} else if (S_ISDIR(file->mode))\n\t\t\t\t\tstats.created_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\t\telse if (S_ISLNK(file->mode))\n\t\t\t\t\tstats.created_symlinks++;\n#endif\n\t\t\t\telse if (IS_DEVICE(file->mode))\n\t\t\t\t\tstats.created_devices++;\n\t\t\t\telse\n\t\t\t\t\tstats.created_specials++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (phase == 2) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"got transfer request in phase 2 [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (file->flags & FLAG_FILE_SENT) {\n\t\t\tif (csum_length == SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups; /* prevents double backup */\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SUM_LENGTH;\n\t\t\t\tredoing = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (csum_length != SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\t\tredoing = 0;\n\t\t\t}\n\t\t\tif (iflags & ITEM_IS_NEW)\n\t\t\t\tstats.created_files++;\n\t\t}\n\n\t\tif (!am_server)\n\t\t\tset_current_file_index(file, ndx);\n\t\tstats.xferred_files++;\n\t\tstats.total_transferred_size += F_LENGTH(file);\n\n\t\tcleanup_got_literal = 0;\n\n\t\tif (read_batch) {\n\t\t\tint wanted = redoing\n\t\t\t\t   ? we_want_redo(ndx)\n\t\t\t\t   : gen_wants_ndx(ndx, cur_flist->flist_num);\n\t\t\tif (!wanted) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"(Skipping batched update for%s \\\"%s\\\")\\n\",\n\t\t\t\t\tredoing ? \" resend of\" : \"\",\n\t\t\t\t\tfname);\n\t\t\t\tdiscard_receive_data(f_in, file);\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tremember_initial_stats();\n\n\t\tif (!do_xfers) { /* log the transfer */\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (read_batch)\n\t\t\t\tdiscard_receive_data(f_in, file);\n\t\t\tcontinue;\n\t\t}\n\t\tif (write_batch < 0) {\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (!am_server)\n\t\t\t\tdiscard_receive_data(f_in, file);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_success(fname, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpartialptr = partial_dir ? partial_dir_fname(fname) : fname;\n\n\t\tif (protocol_version >= 29) {\n\t\t\tswitch (fnamecmp_type) {\n\t\t\tcase FNAMECMP_FNAME:\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_PARTIAL_DIR:\n\t\t\t\tfnamecmp = partialptr;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_BACKUP:\n\t\t\t\tfnamecmp = get_backup_name(fname);\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_FUZZY:\n\t\t\t\tif (file->dirname) {\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);\n\t\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\t} else\n\t\t\t\t\tfnamecmp = xname;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {\n\t\t\t\t\tfnamecmp_type -= FNAMECMP_FUZZY + 1;\n\t\t\t\t\tif (file->dirname) {\n\t\t\t\t\t\tstringjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t\t\t   basis_dir[fnamecmp_type], \"/\", file->dirname, \"/\", xname, NULL);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);\n\t\t\t\t} else if (fnamecmp_type >= basis_dir_cnt) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"invalid basis_dir index: %d.\\n\",\n\t\t\t\t\t\tfnamecmp_type);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t} else\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!fnamecmp || (daemon_filter_list.head\n\t\t\t  && check_filter(&daemon_filter_list, FLOG, fnamecmp, 0) < 0)) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfnamecmp_type = FNAMECMP_FNAME;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Reminder: --inplace && --partial-dir are never\n\t\t\t * enabled at the same time. */\n\t\t\tif (inplace && make_backups > 0) {\n\t\t\t\tif (!(fnamecmp = get_backup_name(fname)))\n\t\t\t\t\tfnamecmp = fname;\n\t\t\t\telse\n\t\t\t\t\tfnamecmp_type = FNAMECMP_BACKUP;\n\t\t\t} else if (partial_dir && partialptr)\n\t\t\t\tfnamecmp = partialptr;\n\t\t\telse\n\t\t\t\tfnamecmp = fname;\n\t\t}\n\n\t\t/* open the file */\n\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\n\t\tif (fd1 == -1 && protocol_version < 29) {\n\t\t\tif (fnamecmp != fname) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfnamecmp_type = FNAMECMP_FNAME;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\n\t\t\tif (fd1 == -1 && basis_dir[0]) {\n\t\t\t\t/* pre-29 allowed only one alternate basis */\n\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t basis_dir[0], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tfnamecmp_type = FNAMECMP_BASIS_DIR_LOW;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\t\t}\n\n\t\tone_inplace = inplace_partial && fnamecmp_type == FNAMECMP_PARTIAL_DIR;\n\t\tupdating_basis_or_equiv = one_inplace\n\t\t    || (inplace && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP));\n\n\t\tif (fd1 == -1) {\n\t\t\tst.st_mode = 0;\n\t\t\tst.st_size = 0;\n\t\t} else if (do_fstat(fd1,&st) != 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"fstat %s failed\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, file);\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {\n\t\t\t/* this special handling for directories\n\t\t\t * wouldn't be necessary if robust_rename()\n\t\t\t * and the underlying robust_unlink could cope\n\t\t\t * with directories\n\t\t\t */\n\t\t\trprintf(FERROR_XFER, \"recv_files: %s is a directory\\n\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, file);\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (write_devices && IS_DEVICE(st.st_mode)) {\n\t\t\tif (fd1 != -1 && st.st_size == 0)\n\t\t\t\tst.st_size = get_device_size(fd1, fname);\n\t\t\t/* Mark the file entry as a device so that we don't try to truncate it later on. */\n\t\t\tfile->mode = S_IFBLK | (file->mode & ACCESSPERMS);\n\t\t} else if (fd1 != -1 && !(S_ISREG(st.st_mode))) {\n\t\t\tclose(fd1);\n\t\t\tfd1 = -1;\n\t\t}\n\n\t\t/* If we're not preserving permissions, change the file-list's\n\t\t * mode based on the local permissions and some heuristics. */\n\t\tif (!preserve_perms) {\n\t\t\tint exists = fd1 != -1;\n#ifdef SUPPORT_ACLS\n\t\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\t\tif (parent_dirname != dn\n\t\t\t && strcmp(parent_dirname, dn) != 0) {\n\t\t\t\tdflt_perms = default_perms_for_dir(dn);\n\t\t\t\tparent_dirname = dn;\n\t\t\t}\n#endif\n\t\t\tfile->mode = dest_mode(file->mode, st.st_mode, dflt_perms, exists);\n\t\t}\n\n\t\t/* We now check to see if we are writing the file \"inplace\" */\n\t\tif (inplace || one_inplace)  {\n\t\t\tfnametmp = one_inplace ? partialptr : fname;\n\t\t\tfd2 = do_open(fnametmp, O_WRONLY|O_CREAT, 0600);\n#ifdef linux\n\t\t\tif (fd2 == -1 && errno == EACCES) {\n\t\t\t\t/* Maybe the error was due to protected_regular setting? */\n\t\t\t\tfd2 = do_open(fname, O_WRONLY, 0600);\n\t\t\t}\n#endif\n\t\t\tif (fd2 == -1) {\n\t\t\t\trsyserr(FERROR_XFER, errno, \"open %s failed\",\n\t\t\t\t\tfull_fname(fnametmp));\n\t\t\t} else if (updating_basis_or_equiv)\n\t\t\t\tcleanup_set(NULL, NULL, file, fd1, fd2);\n\t\t} else {\n\t\t\tfnametmp = fnametmpbuf;\n\t\t\tfd2 = open_tmpfile(fnametmp, fname, file);\n\t\t\tif (fd2 != -1)\n\t\t\t\tcleanup_set(fnametmp, partialptr, file, fd1, fd2);\n\t\t}\n\n\t\tif (fd2 == -1) {\n\t\t\tdiscard_receive_data(f_in, file);\n\t\t\tif (fd1 != -1)\n\t\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* log the transfer */\n\t\tif (log_before_transfer)\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))\n\t\t\trprintf(FINFO, \"%s\\n\", fname);\n\n\t\t/* recv file data */\n\t\trecv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size, fname, fd2, file, inplace || one_inplace);\n\n\t\tlog_item(log_code, file, iflags, NULL);\n\t\tif (want_progress_now)\n\t\t\tinstant_progress(fname);\n\n\t\tif (fd1 != -1)\n\t\t\tclose(fd1);\n\t\tif (close(fd2) < 0) {\n\t\t\trsyserr(FERROR, errno, \"close failed on %s\",\n\t\t\t\tfull_fname(fnametmp));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif ((recv_ok && (!delay_updates || !partialptr)) || inplace) {\n\t\t\tif (partialptr == fname)\n\t\t\t\tpartialptr = NULL;\n\t\t\tif (!finish_transfer(fname, fnametmp, fnamecmp, partialptr, file, recv_ok, 1))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (fnamecmp == partialptr) {\n\t\t\t\tif (!one_inplace)\n\t\t\t\t\tdo_unlink(partialptr);\n\t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t\t}\n\t\t} else if (keep_partial && partialptr && (!one_inplace || delay_updates)) {\n\t\t\tif (!handle_partial_dir(partialptr, PDIR_CREATE)) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"Unable to create partial-dir for %s -- discarding %s.\\n\",\n\t\t\t\t\tlocal_name ? local_name : f_name(file, NULL),\n\t\t\t\t\trecv_ok ? \"completed file\" : \"partial file\");\n\t\t\t\tdo_unlink(fnametmp);\n\t\t\t\trecv_ok = -1;\n\t\t\t} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,\n\t\t\t\t\t\t    file, recv_ok, !partial_dir))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (delay_updates && recv_ok) {\n\t\t\t\tbitbag_set_bit(delayed_bits, ndx);\n\t\t\t\trecv_ok = 2;\n\t\t\t} else\n\t\t\t\tpartialptr = NULL;\n\t\t} else if (!one_inplace)\n\t\t\tdo_unlink(fnametmp);\n\n\t\tcleanup_disable();\n\n\t\tif (read_batch)\n\t\t\tfile->flags |= FLAG_FILE_SENT;\n\n\t\tswitch (recv_ok) {\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (remove_source_files || inc_recurse || (preserve_hard_links && F_IS_HLINKED(file)))\n\t\t\t\tsend_msg_success(fname, ndx);\n\t\t\tbreak;\n\t\tcase 0: {\n\t\t\tenum logcode msgtype = redoing ? FERROR_XFER : FWARNING;\n\t\t\tif (msgtype == FERROR_XFER || INFO_GTE(NAME, 1) || stdout_format_has_i) {\n\t\t\t\tchar *errstr, *redostr, *keptstr;\n\t\t\t\tif (!(keep_partial && partialptr) && !inplace)\n\t\t\t\t\tkeptstr = \"discarded\";\n\t\t\t\telse if (partial_dir)\n\t\t\t\t\tkeptstr = \"put into partial-dir\";\n\t\t\t\telse\n\t\t\t\t\tkeptstr = \"retained\";\n\t\t\t\tif (msgtype == FERROR_XFER) {\n\t\t\t\t\terrstr = \"ERROR\";\n\t\t\t\t\tredostr = \"\";\n\t\t\t\t} else {\n\t\t\t\t\terrstr = \"WARNING\";\n\t\t\t\t\tredostr = read_batch ? \" (may try again)\"\n\t\t\t\t\t\t\t     : \" (will try again)\";\n\t\t\t\t}\n\t\t\t\trprintf(msgtype,\n\t\t\t\t\t\"%s: %s failed verification -- update %s%s.\\n\",\n\t\t\t\t\terrstr, local_name ? f_name(file, NULL) : fname,\n\t\t\t\t\tkeptstr, redostr);\n\t\t\t}\n\t\t\tif (!redoing) {\n\t\t\t\tif (read_batch)\n\t\t\t\t\tflist_ndx_push(&batch_redo_list, ndx);\n\t\t\t\tsend_msg_int(MSG_REDO, ndx);\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t} else if (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t}\n\t\tcase -1:\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (make_backups < 0)\n\t\tmake_backups = -make_backups;\n\n\tif (phase == 2 && delay_updates) /* for protocol_version < 29 */\n\t\thandle_delayed_updates(local_name);\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO,\"recv_files finished\\n\");\n\n\treturn 0;\n}\n"
        },
        {
          "name": "rounding.c",
          "type": "blob",
          "size": 1.1796875,
          "content": "/*\n * A pre-compilation helper program to aid in the creation of rounding.h.\n *\n * Copyright (C) 2007-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n#define ARRAY_LEN (EXTRA_ROUNDING+1)\n#define SIZEOF(x) ((long int)sizeof (x))\n\nstruct test {\n\tunion file_extras extras[ARRAY_LEN];\n\tint64 test;\n};\n\n#define ACTUAL_SIZE\tSIZEOF(struct test)\n#define EXPECTED_SIZE\t(SIZEOF(union file_extras) * ARRAY_LEN + SIZEOF(int64))\n\n int main(UNUSED(int argc), UNUSED(char *argv[]))\n{\n\tstatic int test_array[1 - 2 * (ACTUAL_SIZE != EXPECTED_SIZE)];\n\ttest_array[0] = 0;\n\treturn 0;\n}\n"
        },
        {
          "name": "rsync-ssl",
          "type": "blob",
          "size": 5.015625,
          "content": "#!/usr/bin/env bash\n\n# This script uses openssl, gnutls, or stunnel to secure an rsync daemon connection.\n\n# By default this script takes rsync args and hands them off to the actual\n# rsync command with an --rsh option that makes it open an SSL connection to an\n# rsync daemon.  See the rsync-ssl manpage for usage details and env variables.\n\n# When the first arg is --HELPER, we are being used by rsync as an --rsh helper\n# script, and the args are (note the trailing dot):\n#\n#    rsync-ssl --HELPER HOSTNAME rsync --server --daemon .\n#\n# --HELPER is not a user-facing option, so it is not documented in the manpage.\n\n# The first SSL setup was based on:  http://dozzie.jarowit.net/trac/wiki/RsyncSSL\n# Note that an stunnel connection requires at least version 4.x of stunnel.\n\nfunction rsync_ssl_run {\n    case \"$*\" in\n    *rsync://*) ;;\n    *::*) ;;\n    *)\n\techo \"You must use rsync-ssl with a daemon-style hostname.\" 1>&2\n\texit 1\n\t;;\n    esac\n\n    exec rsync --rsh=\"$0 --HELPER\" \"${@}\"\n}\n\nfunction rsync_ssl_helper {\n    if [[ -z \"$RSYNC_SSL_TYPE\" ]]; then\n\tfound=`path_search openssl stunnel4 stunnel` || exit 1\n\tif [[ \"$found\" == */openssl ]]; then\n\t    RSYNC_SSL_TYPE=openssl\n\t    RSYNC_SSL_OPENSSL=\"$found\"\n\telif [[ \"$found\" == */gnutls-cli ]]; then\n\t    RSYNC_SSL_TYPE=gnutls\n\t    RSYNC_SSL_GNUTLS=\"$found\"\n\telse\n\t    RSYNC_SSL_TYPE=stunnel\n\t    RSYNC_SSL_STUNNEL=\"$found\"\n\tfi\n    fi\n\n    case \"$RSYNC_SSL_TYPE\" in\n\topenssl)\n\t    if [[ -z \"$RSYNC_SSL_OPENSSL\" ]]; then\n\t\tRSYNC_SSL_OPENSSL=`path_search openssl` || exit 1\n\t    fi\n\t    optsep=' '\n\t    ;;\n\tgnutls)\n\t    if [[ -z \"$RSYNC_SSL_GNUTLS\" ]]; then\n\t\tRSYNC_SSL_GNUTLS=`path_search gnutls-cli` || exit 1\n\t    fi\n\t    optsep=' '\n\t    ;;\n\tstunnel)\n\t    if [[ -z \"$RSYNC_SSL_STUNNEL\" ]]; then\n\t\tRSYNC_SSL_STUNNEL=`path_search stunnel4 stunnel` || exit 1\n\t    fi\n\t    optsep=' = '\n\t    ;;\n\t*)\n\t    echo \"The RSYNC_SSL_TYPE specifies an unknown type: $RSYNC_SSL_TYPE\" 1>&2\n\t    exit 1\n\t    ;;\n    esac\n\n    if [[ -z \"$RSYNC_SSL_CERT\" ]]; then\n\tcertopt=\"\"\n\tgnutls_cert_opt=\"\"\n    else\n\tcertopt=\"-cert$optsep$RSYNC_SSL_CERT\"\n\tgnutls_cert_opt=\"--x509certfile=$RSYNC_SSL_CERT\"\n    fi\n\n    if [[ -z \"$RSYNC_SSL_KEY\" ]]; then\n\tkeyopt=\"\"\n\tgnutls_key_opt=\"\"\n    else\n\tkeyopt=\"-key$optsep$RSYNC_SSL_KEY\"\n\tgnutls_key_opt=\"--x509keyfile=$RSYNC_SSL_KEY\"\n    fi\n\n    if [[ -z ${RSYNC_SSL_CA_CERT+x} ]]; then\n\t# RSYNC_SSL_CA_CERT unset - default CA set AND verify:\n\t# openssl:\n\tcaopt=\"-verify_return_error -verify 4\"\n\t# gnutls:\n\tgnutls_opts=\"\"\n\t# stunnel:\n\t# Since there is no way of using the default CA certificate collection,\n\t# we cannot do any verification. Thus, stunnel should really only be\n\t# used if nothing else is available.\n\tcafile=\"\"\n\tverify=\"\"\n    elif [[ \"$RSYNC_SSL_CA_CERT\" == \"\" ]]; then\n\t# RSYNC_SSL_CA_CERT set but empty -do NO verifications:\n\t# openssl:\n\tcaopt=\"-verify 1\"\n\t# gnutls:\n\tgnutls_opts=\"--insecure\"\n\t# stunnel:\n\tcafile=\"\"\n\tverify=\"verifyChain = no\"\n    else\n\t# RSYNC_SSL_CA_CERT set - use CA AND verify:\n\t# openssl:\n\tcaopt=\"-CAfile $RSYNC_SSL_CA_CERT -verify_return_error -verify 4\"\n\t# gnutls:\n\tgnutls_opts=\"--x509cafile=$RSYNC_SSL_CA_CERT\"\n\t# stunnel:\n\tcafile=\"CAfile = $RSYNC_SSL_CA_CERT\"\n\tverify=\"verifyChain = yes\"\n    fi\n\n    port=\"${RSYNC_PORT:-0}\"\n    if [[ \"$port\" == 0 ]]; then\n\tport=\"${RSYNC_SSL_PORT:-874}\"\n    fi\n\n    # If the user specified USER@HOSTNAME::module, then rsync passes us\n    # the -l USER option too, so we must be prepared to ignore it.\n    if [[ \"$1\" == \"-l\" ]]; then\n\tshift 2\n    fi\n\n    hostname=\"$1\"\n    shift\n\n    if [[ -z \"$hostname\" || \"$1\" != rsync || \"$2\" != --server || \"$3\" != --daemon ]]; then\n\techo \"Usage: rsync-ssl --HELPER HOSTNAME rsync --server --daemon .\" 1>&2\n\texit 1\n    fi\n\n    if [[ $RSYNC_SSL_TYPE == openssl ]]; then\n\texec $RSYNC_SSL_OPENSSL s_client $caopt $certopt $keyopt -quiet -verify_quiet -servername $hostname -verify_hostname $hostname -connect $hostname:$port\n    elif [[ $RSYNC_SSL_TYPE == gnutls ]]; then\n\texec $RSYNC_SSL_GNUTLS --logfile=/dev/null $gnutls_cert_opt $gnutls_key_opt $gnutls_opts $hostname:$port\n    else\n\t# devzero@web.de came up with this no-tmpfile calling syntax:\n\texec $RSYNC_SSL_STUNNEL -fd 10 11<&0 <<EOF 10<&0 0<&11 11<&-\nforeground = yes\ndebug = crit\nconnect = $hostname:$port\nclient = yes\nTIMEOUTclose = 0\n$verify\n$certopt\n$cafile\nEOF\n    fi\n}\n\nfunction path_search {\n    IFS_SAVE=\"$IFS\"\n    IFS=:\n    for prog in \"${@}\"; do\n\tfor dir in $PATH; do\n\t    [[ -z \"$dir\" ]] && dir=.\n\t    if [[ -f \"$dir/$prog\" && -x \"$dir/$prog\" ]]; then\n\t\techo \"$dir/$prog\"\n\t\tIFS=\"$IFS_SAVE\"\n\t\treturn 0\n\t    fi\n\tdone\n    done\n\n    IFS=\"$IFS_SAVE\"\n    echo \"Failed to find on your path: $*\" 1>&2\n    echo \"See the rsync-ssl manpage for configuration assistance.\" 1>&2\n    return 1\n}\n\nif [[ \"$#\" == 0 ]]; then\n    echo \"Usage: rsync-ssl [--type=SSL_TYPE] RSYNC_ARG [...]\" 1>&2\n    echo \"The SSL_TYPE can be openssl or stunnel\"\n    exit 1\nfi\n\nif [[ \"$1\" = --help || \"$1\" = -h ]]; then\n    exec rsync --help\nfi\n\nif [[ \"$1\" == --HELPER ]]; then\n    shift\n    rsync_ssl_helper \"${@}\"\nfi\n\nif [[ \"$1\" == --type=* ]]; then\n    export RSYNC_SSL_TYPE=\"${1/--type=/}\"\n    shift\nfi\n\nrsync_ssl_run \"${@}\"\n"
        },
        {
          "name": "rsync-ssl.1.md",
          "type": "blob",
          "size": 4.5869140625,
          "content": "## NAME\n\nrsync-ssl - a helper script for connecting to an ssl rsync daemon\n\n## SYNOPSIS\n\n```\nrsync-ssl [--type=SSL_TYPE] RSYNC_ARGS\n```\n\nThe online version of this manpage (that includes cross-linking of topics)\nis available at <https://download.samba.org/pub/rsync/rsync-ssl.1>.\n\n## DESCRIPTION\n\nThe rsync-ssl script helps you to run an rsync copy to/from an rsync daemon\nthat requires ssl connections.\n\nThe script requires that you specify an rsync-daemon arg in the style of either\n`hostname::` (with 2 colons) or `rsync://hostname/`.  The default port used for\nconnecting is 874 (one higher than the normal 873) unless overridden in the\nenvironment.  You can specify an overriding port via `--port` or by including\nit in the normal spot in the URL format, though both of those require your\nrsync version to be at least 3.2.0.\n\n## OPTIONS\n\nIf the **first** arg is a `--type=SSL_TYPE` option, the script will only use\nthat particular program to open an ssl connection instead of trying to find an\nopenssl or stunnel executable via a simple heuristic (assuming that the\n`RSYNC_SSL_TYPE` environment variable is not set as well -- see below).  This\noption must specify one of `openssl` or `stunnel`.  The equal sign is\nrequired for this particular option.\n\nAll the other options are passed through to the rsync command, so consult the\n**rsync**(1) manpage for more information on how it works.\n\n## ENVIRONMENT VARIABLES\n\nThe ssl helper scripts are affected by the following environment variables:\n\n0.  `RSYNC_SSL_TYPE`\n\n    Specifies the program type that should be used to open the ssl connection.\n    It must be one of `openssl` or `stunnel`.  The `--type=SSL_TYPE` option\n    overrides this, when specified.\n\n0.  `RSYNC_SSL_PORT`\n\n    If specified, the value is the port number that is used as the default when\n    the user does not specify a port in their rsync command.  When not\n    specified, the default port number is 874.  (Note that older rsync versions\n    (prior to 3.2.0) did not communicate an overriding port number value to the\n    helper script.)\n\n0.  `RSYNC_SSL_CERT`\n\n    If specified, the value is a filename that contains a certificate to use\n    for the connection.\n\n0.  `RSYNC_SSL_KEY`\n\n    If specified, the value is a filename that contains a key for the provided\n    certificate to use for the connection.\n\n0.  `RSYNC_SSL_CA_CERT`\n\n    If specified, the value is a filename that contains a certificate authority\n    certificate that is used to validate the connection.\n\n0.  `RSYNC_SSL_OPENSSL`\n\n    Specifies the openssl executable to run when the connection type is set to\n    openssl.  If unspecified, the $PATH is searched for \"openssl\".\n\n0.  `RSYNC_SSL_GNUTLS`\n\n    Specifies the gnutls-cli executable to run when the connection type is set\n    to gnutls.  If unspecified, the $PATH is searched for \"gnutls-cli\".\n\n0.  `RSYNC_SSL_STUNNEL`\n\n    Specifies the stunnel executable to run when the connection type is set to\n    stunnel.  If unspecified, the $PATH is searched first for \"stunnel4\" and\n    then for \"stunnel\".\n\n## EXAMPLES\n\n>     rsync-ssl -aiv example.com::mod/ dest\n\n>     rsync-ssl --type=openssl -aiv example.com::mod/ dest\n\n>     rsync-ssl -aiv --port 9874 example.com::mod/ dest\n\n>     rsync-ssl -aiv rsync://example.com:9874/mod/ dest\n\n## THE SERVER SIDE\n\nFor help setting up an SSL/TLS supporting rsync, see the [instructions in\nrsyncd.conf](rsyncd.conf.5#SSL_TLS_Daemon_Setup).\n\n## SEE ALSO\n\n[**rsync**(1)](rsync.1), [**rsyncd.conf**(5)](rsyncd.conf.5)\n\n## CAVEATS\n\nNote that using an stunnel connection requires at least version 4 of stunnel,\nwhich should be the case on modern systems.  Also, it does not verify a\nconnection against the CA certificate collection, so it only encrypts the\nconnection without any cert validation unless you have specified the\ncertificate environment options.\n\nThis script also supports a `--type=gnutls` option, but at the time of this\nrelease the gnutls-cli command was dropping output, making it unusable.  If\nthat bug has been fixed in your version, feel free to put gnutls into an\nexported RSYNC_SSL_TYPE environment variable to make its use the default.\n\n## BUGS\n\nPlease report bugs! See the web site at <https://rsync.samba.org/>.\n\n## VERSION\n\nThis manpage is current for version @VERSION@ of rsync.\n\n## CREDITS\n\nRsync is distributed under the GNU General Public License.  See the file\n[COPYING](COPYING) for details.\n\nA web site is available at <https://rsync.samba.org/>.  The site includes an\nFAQ-O-Matic which may cover questions unanswered by this manual page.\n\n## AUTHOR\n\nThis manpage was written by Wayne Davison.\n\nMailing lists for support and development are available at\n<https://lists.samba.org/>.\n"
        },
        {
          "name": "rsync.1.md",
          "type": "blob",
          "size": 232.8544921875,
          "content": "## NAME\n\nrsync - a fast, versatile, remote (and local) file-copying tool\n\n## SYNOPSIS\n\n```\nLocal:\n    rsync [OPTION...] SRC... [DEST]\n\nAccess via remote shell:\n    Pull:\n        rsync [OPTION...] [USER@]HOST:SRC... [DEST]\n    Push:\n        rsync [OPTION...] SRC... [USER@]HOST:DEST\n\nAccess via rsync daemon:\n    Pull:\n        rsync [OPTION...] [USER@]HOST::SRC... [DEST]\n        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]\n    Push:\n        rsync [OPTION...] SRC... [USER@]HOST::DEST\n        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST)\n```\n\nUsages with just one SRC arg and no DEST arg will list the source files instead\nof copying.\n\nThe online version of this manpage (that includes cross-linking of topics)\nis available at <https://download.samba.org/pub/rsync/rsync.1>.\n\n## DESCRIPTION\n\nRsync is a fast and extraordinarily versatile file copying tool.  It can copy\nlocally, to/from another host over any remote shell, or to/from a remote rsync\ndaemon.  It offers a large number of options that control every aspect of its\nbehavior and permit very flexible specification of the set of files to be\ncopied.  It is famous for its delta-transfer algorithm, which reduces the\namount of data sent over the network by sending only the differences between\nthe source files and the existing files in the destination.  Rsync is widely\nused for backups and mirroring and as an improved copy command for everyday\nuse.\n\nRsync finds files that need to be transferred using a \"quick check\" algorithm\n(by default) that looks for files that have changed in size or in last-modified\ntime.  Any changes in the other preserved attributes (as requested by options)\nare made on the destination file directly when the quick check indicates that\nthe file's data does not need to be updated.\n\nSome of the additional features of rsync are:\n\n- support for copying links, devices, owners, groups, and permissions\n- exclude and exclude-from options similar to GNU tar\n- a CVS exclude mode for ignoring the same files that CVS would ignore\n- can use any transparent remote shell, including ssh or rsh\n- does not require super-user privileges\n- pipelining of file transfers to minimize latency costs\n- support for anonymous or authenticated rsync daemons (ideal for mirroring)\n\n## GENERAL\n\nRsync copies files either to or from a remote host, or locally on the current\nhost (it does not support copying files between two remote hosts).\n\nThere are two different ways for rsync to contact a remote system: using a\nremote-shell program as the transport (such as ssh or rsh) or contacting an\nrsync daemon directly via TCP.  The remote-shell transport is used whenever the\nsource or destination path contains a single colon (:) separator after a host\nspecification.  Contacting an rsync daemon directly happens when the source or\ndestination path contains a double colon (::) separator after a host\nspecification, OR when an rsync:// URL is specified (see also the [USING\nRSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION](#) section for an\nexception to this latter rule).\n\nAs a special case, if a single source arg is specified without a destination,\nthe files are listed in an output format similar to \"`ls -l`\".\n\nAs expected, if neither the source or destination path specify a remote host,\nthe copy occurs locally (see also the [`--list-only`](#opt) option).\n\nRsync refers to the local side as the client and the remote side as the server.\nDon't confuse server with an rsync daemon.  A daemon is always a server, but a\nserver can be either a daemon or a remote-shell spawned process.\n\n## SETUP\n\nSee the file README.md for installation instructions.\n\nOnce installed, you can use rsync to any machine that you can access via a\nremote shell (as well as some that you can access using the rsync daemon-mode\nprotocol).  For remote transfers, a modern rsync uses ssh for its\ncommunications, but it may have been configured to use a different remote shell\nby default, such as rsh or remsh.\n\nYou can also specify any remote shell you like, either by using the [`-e`](#opt)\ncommand line option, or by setting the [`RSYNC_RSH`](#) environment variable.\n\nNote that rsync must be installed on both the source and destination machines.\n\n## USAGE\n\nYou use rsync in the same way you use rcp.  You must specify a source and a\ndestination, one of which may be remote.\n\nPerhaps the best way to explain the syntax is with some examples:\n\n>     rsync -t *.c foo:src/\n\nThis would transfer all files matching the pattern `*.c` from the current\ndirectory to the directory src on the machine foo.  If any of the files already\nexist on the remote system then the rsync remote-update protocol is used to\nupdate the file by sending only the differences in the data.  Note that the\nexpansion of wildcards on the command-line (`*.c`) into a list of files is\nhandled by the shell before it runs rsync and not by rsync itself (exactly the\nsame as all other Posix-style programs).\n\n>     rsync -avz foo:src/bar /data/tmp\n\nThis would recursively transfer all files from the directory src/bar on the\nmachine foo into the /data/tmp/bar directory on the local machine.  The files\nare transferred in archive mode, which ensures that symbolic links, devices,\nattributes, permissions, ownerships, etc. are preserved in the transfer.\nAdditionally, compression will be used to reduce the size of data portions of\nthe transfer.\n\n>     rsync -avz foo:src/bar/ /data/tmp\n\nA trailing slash on the source changes this behavior to avoid creating an\nadditional directory level at the destination.  You can think of a trailing /\non a source as meaning \"copy the contents of this directory\" as opposed to\n\"copy the directory by name\", but in both cases the attributes of the\ncontaining directory are transferred to the containing directory on the\ndestination.  In other words, each of the following commands copies the files\nin the same way, including their setting of the attributes of /dest/foo:\n\n>     rsync -av /src/foo /dest\n>     rsync -av /src/foo/ /dest/foo\n\nNote also that host and module references don't require a trailing slash to\ncopy the contents of the default directory.  For example, both of these copy\nthe remote directory's contents into \"/dest\":\n\n>     rsync -av host: /dest\n>     rsync -av host::module /dest\n\nYou can also use rsync in local-only mode, where both the source and\ndestination don't have a ':' in the name.  In this case it behaves like an\nimproved copy command.\n\nFinally, you can list all the (listable) modules available from a particular\nrsync daemon by leaving off the module name:\n\n>     rsync somehost.mydomain.com::\n\n## COPYING TO A DIFFERENT NAME\n\nWhen you want to copy a directory to a different name, use a trailing slash on\nthe source directory to put the contents of the directory into any destination\ndirectory you like:\n\n>     rsync -ai foo/ bar/\n\nRsync also has the ability to customize a destination file's name when copying\na single item.  The rules for this are:\n\n- The transfer list must consist of a single item (either a file or an empty\n  directory)\n- The final element of the destination path must not exist as a directory\n- The destination path must not have been specified with a trailing slash\n\nUnder those circumstances, rsync will set the name of the destination's single\nitem to the last element of the destination path.  Keep in mind that it is best\nto only use this idiom when copying a file and use the above trailing-slash\nidiom when copying a directory.\n\nThe following example copies the `foo.c` file as `bar.c` in the `save` dir\n(assuming that `bar.c` isn't a directory):\n\n>     rsync -ai src/foo.c save/bar.c\n\nThe single-item copy rule might accidentally bite you if you unknowingly copy a\nsingle item and specify a destination dir that doesn't exist (without using a\ntrailing slash).  For example, if `src/*.c` matches one file and `save/dir`\ndoesn't exist, this will confuse you by naming the destination file `save/dir`:\n\n>     rsync -ai src/*.c save/dir\n\nTo prevent such an accident, either make sure the destination dir exists or\nspecify the destination path with a trailing slash:\n\n>     rsync -ai src/*.c save/dir/\n\n## SORTED TRANSFER ORDER\n\nRsync always sorts the specified filenames into its internal transfer list.\nThis handles the merging together of the contents of identically named\ndirectories, makes it easy to remove duplicate filenames. It can, however,\nconfuse someone when the files are transferred in a different order than what\nwas given on the command-line.\n\nIf you need a particular file to be transferred prior to another, either\nseparate the files into different rsync calls, or consider using\n[`--delay-updates`](#opt) (which doesn't affect the sorted transfer order, but\ndoes make the final file-updating phase happen much more rapidly).\n\n## MULTI-HOST SECURITY\n\nRsync takes steps to ensure that the file requests that are shared in a\ntransfer are protected against various security issues.  Most of the potential\nproblems arise on the receiving side where rsync takes steps to ensure that the\nlist of files being transferred remains within the bounds of what was\nrequested.\n\nToward this end, rsync 3.1.2 and later have aborted when a file list contains\nan absolute or relative path that tries to escape out of the top of the\ntransfer.  Also, beginning with version 3.2.5, rsync does two more safety\nchecks of the file list to (1) ensure that no extra source arguments were added\ninto the transfer other than those that the client requested and (2) ensure\nthat the file list obeys the exclude rules that were sent to the sender.\n\nFor those that don't yet have a 3.2.5 client rsync (or those that want to be\nextra careful), it is safest to do a copy into a dedicated destination\ndirectory for the remote files when you don't trust the remote host.  For\nexample, instead of doing an rsync copy into your home directory:\n\n>     rsync -aiv host1:dir1 ~\n\nDedicate a \"host1-files\" dir to the remote content:\n\n>     rsync -aiv host1:dir1 ~/host1-files\n\nSee the [`--trust-sender`](#opt) option for additional details.\n\nCAUTION: it is not particularly safe to use rsync to copy files from a\ncase-preserving filesystem to a case-ignoring filesystem.  If you must perform\nsuch a copy, you should either disable symlinks via `--no-links` or enable the\nmunging of symlinks via [`--munge-links`](#opt) (and make sure you use the\nright local or remote option).  This will prevent rsync from doing potentially\ndangerous things if a symlink name overlaps with a file or directory. It does\nnot, however, ensure that you get a full copy of all the files (since that may\nnot be possible when the names overlap). A potentially better solution is to\nlist all the source files and create a safe list of filenames that you pass to\nthe [`--files-from`](#opt) option.  Any files that conflict in name would need\nto be copied to different destination directories using more than one copy.\n\nWhile a copy of a case-ignoring filesystem to a case-ignoring filesystem can\nwork out fairly well, if no `--delete-during` or `--delete-before` option is\nactive, rsync can potentially update an existing file on the receiving side\nwithout noticing that the upper-/lower-case of the filename should be changed\nto match the sender.\n\n## ADVANCED USAGE\n\nThe syntax for requesting multiple files from a remote host is done by\nspecifying additional remote-host args in the same style as the first, or with\nthe hostname omitted.  For instance, all these work:\n\n>     rsync -aiv host:file1 :file2 host:file{3,4} /dest/\n>     rsync -aiv host::modname/file{1,2} host::modname/extra /dest/\n>     rsync -aiv host::modname/first ::extra-file{1,2} /dest/\n\nNote that a daemon connection only supports accessing one module per copy\ncommand, so if the start of a follow-up path doesn't begin with the\nmodname of the first path, it is assumed to be a path in the module (such as\nthe extra-file1 & extra-file2 that are grabbed above).\n\nReally old versions of rsync (2.6.9 and before) only allowed specifying one\nremote-source arg, so some people have instead relied on the remote-shell\nperforming space splitting to break up an arg into multiple paths. Such\nunintuitive behavior is no longer supported by default (though you can request\nit, as described below).\n\nStarting in 3.2.4, filenames are passed to a remote shell in such a way as to\npreserve the characters you give it. Thus, if you ask for a file with spaces\nin the name, that's what the remote rsync looks for:\n\n>     rsync -aiv host:'a simple file.pdf' /dest/\n\nIf you use scripts that have been written to manually apply extra quoting to\nthe remote rsync args (or to require remote arg splitting), you can ask rsync\nto let your script handle the extra escaping.  This is done by either adding\nthe [`--old-args`](#opt) option to the rsync runs in the script (which requires\na new rsync) or exporting [RSYNC_OLD_ARGS](#)=1 and [RSYNC_PROTECT_ARGS](#)=0\n(which works with old or new rsync versions).\n\n## CONNECTING TO AN RSYNC DAEMON\n\nIt is also possible to use rsync without a remote shell as the transport.  In\nthis case you will directly connect to a remote rsync daemon, typically using\nTCP port 873. (This obviously requires the daemon to be running on the remote\nsystem, so refer to the [STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS](#)\nsection below for information on that.)\n\nUsing rsync in this way is the same as using it with a remote shell except\nthat:\n\n- Use either double-colon syntax or rsync:// URL syntax instead of the\n  single-colon (remote shell) syntax.\n- The first element of the \"path\" is actually a module name.\n- Additional remote source args can use an abbreviated syntax that omits the\n  hostname and/or the module name, as discussed in [ADVANCED USAGE](#).\n- The remote daemon may print a \"message of the day\" when you connect.\n- If you specify only the host (with no module or path) then a list of\n  accessible modules on the daemon is output.\n- If you specify a remote source path but no destination, a listing of the\n  matching files on the remote daemon is output.\n- The [`--rsh`](#opt) (`-e`) option must be omitted to avoid changing the\n  connection style from using a socket connection to [USING RSYNC-DAEMON\n  FEATURES VIA A REMOTE-SHELL CONNECTION](#).\n\nAn example that copies all the files in a remote module named \"src\":\n\n>     rsync -av host::src /dest\n\nSome modules on the remote daemon may require authentication.  If so, you will\nreceive a password prompt when you connect.  You can avoid the password prompt\nby setting the environment variable [`RSYNC_PASSWORD`](#) to the password you\nwant to use or using the [`--password-file`](#opt) option.  This may be useful\nwhen scripting rsync.\n\nWARNING: On some systems environment variables are visible to all users.  On\nthose systems using [`--password-file`](#opt) is recommended.\n\nYou may establish the connection via a web proxy by setting the environment\nvariable [`RSYNC_PROXY`](#) to a hostname:port pair pointing to your web proxy.\nNote that your web proxy's configuration must support proxy connections to port\n873.\n\nYou may also establish a daemon connection using a program as a proxy by\nsetting the environment variable [`RSYNC_CONNECT_PROG`](#) to the commands you\nwish to run in place of making a direct socket connection.  The string may\ncontain the escape \"%H\" to represent the hostname specified in the rsync\ncommand (so use \"%%\" if you need a single \"%\" in your string).  For example:\n\n>     export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'\n>     rsync -av targethost1::module/src/ /dest/\n>     rsync -av rsync://targethost2/module/src/ /dest/\n\nThe command specified above uses ssh to run nc (netcat) on a proxyhost, which\nforwards all data to port 873 (the rsync daemon) on the targethost (%H).\n\nNote also that if the [`RSYNC_SHELL`](#) environment variable is set, that\nprogram will be used to run the `RSYNC_CONNECT_PROG` command instead of using\nthe default shell of the **system()** call.\n\n## USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION\n\nIt is sometimes useful to use various features of an rsync daemon (such as\nnamed modules) without actually allowing any new socket connections into a\nsystem (other than what is already required to allow remote-shell access).\nRsync supports connecting to a host using a remote shell and then spawning a\nsingle-use \"daemon\" server that expects to read its config file in the home dir\nof the remote user.  This can be useful if you want to encrypt a daemon-style\ntransfer's data, but since the daemon is started up fresh by the remote user,\nyou may not be able to use features such as chroot or change the uid used by\nthe daemon. (For another way to encrypt a daemon transfer, consider using ssh\nto tunnel a local port to a remote machine and configure a normal rsync daemon\non that remote host to only allow connections from \"localhost\".)\n\nFrom the user's perspective, a daemon transfer via a remote-shell connection\nuses nearly the same command-line syntax as a normal rsync-daemon transfer,\nwith the only exception being that you must explicitly set the remote shell\nprogram on the command-line with the [`--rsh=COMMAND`](#opt) option. (Setting the\nRSYNC_RSH in the environment will not turn on this functionality.) For example:\n\n>     rsync -av --rsh=ssh host::module /dest\n\nIf you need to specify a different remote-shell user, keep in mind that the\nuser@ prefix in front of the host is specifying the rsync-user value (for a\nmodule that requires user-based authentication).  This means that you must give\nthe '-l user' option to ssh when specifying the remote-shell, as in this\nexample that uses the short version of the [`--rsh`](#opt) option:\n\n>     rsync -av -e \"ssh -l ssh-user\" rsync-user@host::module /dest\n\nThe \"ssh-user\" will be used at the ssh level; the \"rsync-user\" will be used to\nlog-in to the \"module\".\n\nIn this setup, the daemon is started by the ssh command that is accessing the\nsystem (which can be forced via the `~/.ssh/authorized_keys` file, if desired).\nHowever, when accessing a daemon directly, it needs to be started beforehand.\n\n## STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS\n\nIn order to connect to an rsync daemon, the remote system needs to have a\ndaemon already running (or it needs to have configured something like inetd to\nspawn an rsync daemon for incoming connections on a particular port).  For full\ninformation on how to start a daemon that will handling incoming socket\nconnections, see the [**rsyncd.conf**(5)](rsyncd.conf.5) manpage -- that is\nthe config file for the daemon, and it contains the full details for how to run\nthe daemon (including stand-alone and inetd configurations).\n\nIf you're using one of the remote-shell transports for the transfer, there is\nno need to manually start an rsync daemon.\n\n## EXAMPLES\n\nHere are some examples of how rsync can be used.\n\nTo backup a home directory, which consists of large MS Word files and mail\nfolders, a per-user cron job can be used that runs this each day:\n\n>     rsync -aiz . bkhost:backup/joe/\n\nTo move some files from a remote host to the local host, you could run:\n\n>     rsync -aiv --remove-source-files rhost:/tmp/{file1,file2}.c ~/src/\n\n## OPTION SUMMARY\n\nHere is a short summary of the options available in rsync.  Each option also\nhas its own detailed description later in this manpage.\n\n[comment]: # (help-rsync.h)\n[comment]: # (Keep these short enough that they'll be under 80 chars when indented by 7 chars.)\n\n```\n--verbose, -v            increase verbosity\n--info=FLAGS             fine-grained informational verbosity\n--debug=FLAGS            fine-grained debug verbosity\n--stderr=e|a|c           change stderr output mode (default: errors)\n--quiet, -q              suppress non-error messages\n--no-motd                suppress daemon-mode MOTD\n--checksum, -c           skip based on checksum, not mod-time & size\n--archive, -a            archive mode is -rlptgoD (no -A,-X,-U,-N,-H)\n--no-OPTION              turn off an implied OPTION (e.g. --no-D)\n--recursive, -r          recurse into directories\n--relative, -R           use relative path names\n--no-implied-dirs        don't send implied dirs with --relative\n--backup, -b             make backups (see --suffix & --backup-dir)\n--backup-dir=DIR         make backups into hierarchy based in DIR\n--suffix=SUFFIX          backup suffix (default ~ w/o --backup-dir)\n--update, -u             skip files that are newer on the receiver\n--inplace                update destination files in-place\n--append                 append data onto shorter files\n--append-verify          --append w/old data in file checksum\n--dirs, -d               transfer directories without recursing\n--old-dirs, --old-d      works like --dirs when talking to old rsync\n--mkpath                 create destination's missing path components\n--links, -l              copy symlinks as symlinks\n--copy-links, -L         transform symlink into referent file/dir\n--copy-unsafe-links      only \"unsafe\" symlinks are transformed\n--safe-links             ignore symlinks that point outside the tree\n--munge-links            munge symlinks to make them safe & unusable\n--copy-dirlinks, -k      transform symlink to dir into referent dir\n--keep-dirlinks, -K      treat symlinked dir on receiver as dir\n--hard-links, -H         preserve hard links\n--perms, -p              preserve permissions\n--executability, -E      preserve executability\n--chmod=CHMOD            affect file and/or directory permissions\n--acls, -A               preserve ACLs (implies --perms)\n--xattrs, -X             preserve extended attributes\n--owner, -o              preserve owner (super-user only)\n--group, -g              preserve group\n--devices                preserve device files (super-user only)\n--copy-devices           copy device contents as a regular file\n--write-devices          write to devices as files (implies --inplace)\n--specials               preserve special files\n-D                       same as --devices --specials\n--times, -t              preserve modification times\n--atimes, -U             preserve access (use) times\n--open-noatime           avoid changing the atime on opened files\n--crtimes, -N            preserve create times (newness)\n--omit-dir-times, -O     omit directories from --times\n--omit-link-times, -J    omit symlinks from --times\n--super                  receiver attempts super-user activities\n--fake-super             store/recover privileged attrs using xattrs\n--sparse, -S             turn sequences of nulls into sparse blocks\n--preallocate            allocate dest files before writing them\n--dry-run, -n            perform a trial run with no changes made\n--whole-file, -W         copy files whole (w/o delta-xfer algorithm)\n--checksum-choice=STR    choose the checksum algorithm (aka --cc)\n--one-file-system, -x    don't cross filesystem boundaries\n--block-size=SIZE, -B    force a fixed checksum block-size\n--rsh=COMMAND, -e        specify the remote shell to use\n--rsync-path=PROGRAM     specify the rsync to run on remote machine\n--existing               skip creating new files on receiver\n--ignore-existing        skip updating files that exist on receiver\n--remove-source-files    sender removes synchronized files (non-dir)\n--del                    an alias for --delete-during\n--delete                 delete extraneous files from dest dirs\n--delete-before          receiver deletes before xfer, not during\n--delete-during          receiver deletes during the transfer\n--delete-delay           find deletions during, delete after\n--delete-after           receiver deletes after transfer, not during\n--delete-excluded        also delete excluded files from dest dirs\n--ignore-missing-args    ignore missing source args without error\n--delete-missing-args    delete missing source args from destination\n--ignore-errors          delete even if there are I/O errors\n--force                  force deletion of dirs even if not empty\n--max-delete=NUM         don't delete more than NUM files\n--max-size=SIZE          don't transfer any file larger than SIZE\n--min-size=SIZE          don't transfer any file smaller than SIZE\n--max-alloc=SIZE         change a limit relating to memory alloc\n--partial                keep partially transferred files\n--partial-dir=DIR        put a partially transferred file into DIR\n--delay-updates          put all updated files into place at end\n--prune-empty-dirs, -m   prune empty directory chains from file-list\n--numeric-ids            don't map uid/gid values by user/group name\n--usermap=STRING         custom username mapping\n--groupmap=STRING        custom groupname mapping\n--chown=USER:GROUP       simple username/groupname mapping\n--timeout=SECONDS        set I/O timeout in seconds\n--contimeout=SECONDS     set daemon connection timeout in seconds\n--ignore-times, -I       don't skip files that match size and time\n--size-only              skip files that match in size\n--modify-window=NUM, -@  set the accuracy for mod-time comparisons\n--temp-dir=DIR, -T       create temporary files in directory DIR\n--fuzzy, -y              find similar file for basis if no dest file\n--compare-dest=DIR       also compare destination files relative to DIR\n--copy-dest=DIR          ... and include copies of unchanged files\n--link-dest=DIR          hardlink to files in DIR when unchanged\n--compress, -z           compress file data during the transfer\n--compress-choice=STR    choose the compression algorithm (aka --zc)\n--compress-level=NUM     explicitly set compression level (aka --zl)\n--skip-compress=LIST     skip compressing files with suffix in LIST\n--cvs-exclude, -C        auto-ignore files in the same way CVS does\n--filter=RULE, -f        add a file-filtering RULE\n-F                       same as --filter='dir-merge /.rsync-filter'\n                         repeated: --filter='- .rsync-filter'\n--exclude=PATTERN        exclude files matching PATTERN\n--exclude-from=FILE      read exclude patterns from FILE\n--include=PATTERN        don't exclude files matching PATTERN\n--include-from=FILE      read include patterns from FILE\n--files-from=FILE        read list of source-file names from FILE\n--from0, -0              all *-from/filter files are delimited by 0s\n--old-args               disable the modern arg-protection idiom\n--secluded-args, -s      use the protocol to safely send the args\n--trust-sender           trust the remote sender's file list\n--copy-as=USER[:GROUP]   specify user & optional group for the copy\n--address=ADDRESS        bind address for outgoing socket to daemon\n--port=PORT              specify double-colon alternate port number\n--sockopts=OPTIONS       specify custom TCP options\n--blocking-io            use blocking I/O for the remote shell\n--outbuf=N|L|B           set out buffering to None, Line, or Block\n--stats                  give some file-transfer stats\n--8-bit-output, -8       leave high-bit chars unescaped in output\n--human-readable, -h     output numbers in a human-readable format\n--progress               show progress during transfer\n-P                       same as --partial --progress\n--itemize-changes, -i    output a change-summary for all updates\n--remote-option=OPT, -M  send OPTION to the remote side only\n--out-format=FORMAT      output updates using the specified FORMAT\n--log-file=FILE          log what we're doing to the specified FILE\n--log-file-format=FMT    log updates using the specified FMT\n--password-file=FILE     read daemon-access password from FILE\n--early-input=FILE       use FILE for daemon's early exec input\n--list-only              list the files instead of copying them\n--bwlimit=RATE           limit socket I/O bandwidth\n--stop-after=MINS        Stop rsync after MINS minutes have elapsed\n--stop-at=y-m-dTh:m      Stop rsync at the specified point in time\n--fsync                  fsync every written file\n--write-batch=FILE       write a batched update to FILE\n--only-write-batch=FILE  like --write-batch but w/o updating dest\n--read-batch=FILE        read a batched update from FILE\n--protocol=NUM           force an older protocol version to be used\n--iconv=CONVERT_SPEC     request charset conversion of filenames\n--checksum-seed=NUM      set block/file checksum seed (advanced)\n--ipv4, -4               prefer IPv4\n--ipv6, -6               prefer IPv6\n--version, -V            print the version + other info and exit\n--help, -h (*)           show this help (* -h is help only on its own)\n```\n\nRsync can also be run as a daemon, in which case the following options are\naccepted:\n\n[comment]: # (help-rsyncd.h)\n\n```\n--daemon                 run as an rsync daemon\n--address=ADDRESS        bind to the specified address\n--bwlimit=RATE           limit socket I/O bandwidth\n--config=FILE            specify alternate rsyncd.conf file\n--dparam=OVERRIDE, -M    override global daemon config parameter\n--no-detach              do not detach from the parent\n--port=PORT              listen on alternate port number\n--log-file=FILE          override the \"log file\" setting\n--log-file-format=FMT    override the \"log format\" setting\n--sockopts=OPTIONS       specify custom TCP options\n--verbose, -v            increase verbosity\n--ipv4, -4               prefer IPv4\n--ipv6, -6               prefer IPv6\n--help, -h               show this help (when used with --daemon)\n```\n\n## OPTIONS\n\nRsync accepts both long (double-dash + word) and short (single-dash + letter)\noptions.  The full list of the available options are described below.  If an\noption can be specified in more than one way, the choices are comma-separated.\nSome options only have a long variant, not a short.\n\nIf the option takes a parameter, the parameter is only listed after the long\nvariant, even though it must also be specified for the short.  When specifying\na parameter, you can either use the form `--option=param`, `--option param`,\n`-o=param`, `-o param`, or `-oparam` (the latter choices assume that your\noption has a short variant).\n\nThe parameter may need to be quoted in some manner for it to survive the\nshell's command-line parsing.  Also keep in mind that a leading tilde (`~`) in\na pathname is substituted by your shell, so make sure that you separate the\noption name from the pathname using a space if you want the local shell to\nexpand it.\n\n[comment]: # (Some markup below uses a literal non-breakable space when a backtick string)\n[comment]: # (needs to contain a space since markdown strips spaces from the start/end)\n\n[comment]: # (An OL starting at 0 is converted into a DL by the parser.)\n\n0.  `--help`\n\n    Print a short help page describing the options available in rsync and exit.\n    You can also use `-h` for `--help` when it is used without any other\n    options (since it normally means [`--human-readable`](#opt)).\n\n0.  `--version`, `-V`\n\n    Print the rsync version plus other info and exit.  When repeated, the\n    information is output is a JSON format that is still fairly readable\n    (client side only).\n\n    The output includes a list of compiled-in capabilities, a list of\n    optimizations, the default list of checksum algorithms, the default list of\n    compression algorithms, the default list of daemon auth digests, a link to\n    the rsync web site, and a few other items.\n\n0.  `--verbose`, `-v`\n\n    This option increases the amount of information you are given during the\n    transfer.  By default, rsync works silently.  A single `-v` will give you\n    information about what files are being transferred and a brief summary at\n    the end.  Two `-v` options will give you information on what files are\n    being skipped and slightly more information at the end.  More than two `-v`\n    options should only be used if you are debugging rsync.\n\n    The end-of-run summary tells you the number of bytes sent to the remote\n    rsync (which is the receiving side on a local copy), the number of bytes\n    received from the remote host, and the average bytes per second of the\n    transferred data computed over the entire length of the rsync run. The\n    second line shows the total size (in bytes), which is the sum of all the\n    file sizes that rsync considered transferring.  It also shows a \"speedup\"\n    value, which is a ratio of the total file size divided by the sum of the\n    sent and received bytes (which is really just a feel-good bigger-is-better\n    number).  Note that these byte values can be made more (or less)\n    human-readable by using the [`--human-readable`](#opt) (or\n    `--no-human-readable`) options.\n\n    In a modern rsync, the `-v` option is equivalent to the setting of groups\n    of [`--info`](#opt) and [`--debug`](#opt) options.  You can choose to use\n    these newer options in addition to, or in place of using `--verbose`, as\n    any fine-grained settings override the implied settings of `-v`.  Both\n    [`--info`](#opt) and [`--debug`](#opt) have a way to ask for help that\n    tells you exactly what flags are set for each increase in verbosity.\n\n    However, do keep in mind that a daemon's \"`max verbosity`\" setting will limit\n    how high of a level the various individual flags can be set on the daemon\n    side.  For instance, if the max is 2, then any info and/or debug flag that\n    is set to a higher value than what would be set by `-vv` will be downgraded\n    to the `-vv` level in the daemon's logging.\n\n0.  `--info=FLAGS`\n\n    This option lets you have fine-grained control over the information output\n    you want to see.  An individual flag name may be followed by a level\n    number, with 0 meaning to silence that output, 1 being the default output\n    level, and higher numbers increasing the output of that flag (for those\n    that support higher levels).  Use `--info=help` to see all the available\n    flag names, what they output, and what flag names are added for each\n    increase in the verbose level.  Some examples:\n\n    >     rsync -a --info=progress2 src/ dest/\n    >     rsync -avv --info=stats2,misc1,flist0 src/ dest/\n\n    Note that `--info=name`'s output is affected by the [`--out-format`](#opt)\n    and [`--itemize-changes`](#opt) (`-i`) options.  See those options for more\n    information on what is output and when.\n\n    This option was added to 3.1.0, so an older rsync on the server side might\n    reject your attempts at fine-grained control (if one or more flags needed\n    to be send to the server and the server was too old to understand them).\n    See also the \"`max verbosity`\" caveat above when dealing with a daemon.\n\n0.  `--debug=FLAGS`\n\n    This option lets you have fine-grained control over the debug output you\n    want to see.  An individual flag name may be followed by a level number,\n    with 0 meaning to silence that output, 1 being the default output level,\n    and higher numbers increasing the output of that flag (for those that\n    support higher levels).  Use `--debug=help` to see all the available flag\n    names, what they output, and what flag names are added for each increase in\n    the verbose level.  Some examples:\n\n    >     rsync -avvv --debug=none src/ dest/\n    >     rsync -avA --del --debug=del2,acl src/ dest/\n\n    Note that some debug messages will only be output when the [`--stderr=all`](#opt)\n    option is specified, especially those pertaining to I/O and buffer debugging.\n\n    Beginning in 3.2.0, this option is no longer auto-forwarded to the server\n    side in order to allow you to specify different debug values for each side\n    of the transfer, as well as to specify a new debug option that is only\n    present in one of the rsync versions.  If you want to duplicate the same\n    option on both sides, using brace expansion is an easy way to save you some\n    typing.  This works in zsh and bash:\n\n    >     rsync -aiv {-M,}--debug=del2 src/ dest/\n\n0.  `--stderr=errors|all|client`\n\n    This option controls which processes output to stderr and if info messages\n    are also changed to stderr.  The mode strings can be abbreviated, so feel\n    free to use a single letter value.  The 3 possible choices are:\n\n    - `errors` - (the default) causes all the rsync processes to send an\n      error directly to stderr, even if the process is on the remote side of\n      the transfer.  Info messages are sent to the client side via the protocol\n      stream.  If stderr is not available (i.e. when directly connecting with a\n      daemon via a socket) errors fall back to being sent via the protocol\n      stream.\n\n    - `all` - causes all rsync messages (info and error) to get written\n      directly to stderr from all (possible) processes.  This causes stderr to\n      become line-buffered (instead of raw) and eliminates the ability to\n      divide up the info and error messages by file handle.  For those doing\n      debugging or using several levels of verbosity, this option can help to\n      avoid clogging up the transfer stream (which should prevent any chance of\n      a deadlock bug hanging things up).  It also allows [`--debug`](#opt) to\n      enable some extra I/O related messages.\n\n    - `client` - causes all rsync messages to be sent to the client side\n      via the protocol stream.  One client process outputs all messages, with\n      errors on stderr and info messages on stdout.  This **was** the default\n      in older rsync versions, but can cause error delays when a lot of\n      transfer data is ahead of the messages.  If you're pushing files to an\n      older rsync, you may want to use `--stderr=all` since that idiom has\n      been around for several releases.\n\n    This option was added in rsync 3.2.3.  This version also began the\n    forwarding of a non-default setting to the remote side, though rsync uses\n    the backward-compatible options `--msgs2stderr` and `--no-msgs2stderr` to\n    represent the `all` and `client` settings, respectively.  A newer rsync\n    will continue to accept these older option names to maintain compatibility.\n\n0.  `--quiet`, `-q`\n\n    This option decreases the amount of information you are given during the\n    transfer, notably suppressing information messages from the remote server.\n    This option is useful when invoking rsync from cron.\n\n0.  `--no-motd`\n\n    This option affects the information that is output by the client at the\n    start of a daemon transfer.  This suppresses the message-of-the-day (MOTD)\n    text, but it also affects the list of modules that the daemon sends in\n    response to the \"rsync host::\" request (due to a limitation in the rsync\n    protocol), so omit this option if you want to request the list of modules\n    from the daemon.\n\n0.  `--ignore-times`, `-I`\n\n    Normally rsync will skip any files that are already the same size and have\n    the same modification timestamp.  This option turns off this \"quick check\"\n    behavior, causing all files to be updated.\n\n    This option can be confusing compared to [`--ignore-existing`](#opt) and\n    [`--ignore-non-existing`](#opt) in that that they cause rsync to transfer\n    fewer files, while this option causes rsync to transfer more files.\n\n0.  `--size-only`\n\n    This modifies rsync's \"quick check\" algorithm for finding files that need\n    to be transferred, changing it from the default of transferring files with\n    either a changed size or a changed last-modified time to just looking for\n    files that have changed in size.  This is useful when starting to use rsync\n    after using another mirroring system which may not preserve timestamps\n    exactly.\n\n0.  `--modify-window=NUM`, `-@`\n\n    When comparing two timestamps, rsync treats the timestamps as being equal\n    if they differ by no more than the modify-window value.  The default is 0,\n    which matches just integer seconds.  If you specify a negative value (and\n    the receiver is at least version 3.1.3) then nanoseconds will also be taken\n    into account.  Specifying 1 is useful for copies to/from MS Windows FAT\n    filesystems, because FAT represents times with a 2-second resolution\n    (allowing times to differ from the original by up to 1 second).\n\n    If you want all your transfers to default to comparing nanoseconds, you can\n    create a `~/.popt` file and put these lines in it:\n\n    >     rsync alias -a -a@-1\n    >     rsync alias -t -t@-1\n\n    With that as the default, you'd need to specify `--modify-window=0` (aka\n    `-@0`) to override it and ignore nanoseconds, e.g. if you're copying\n    between ext3 and ext4, or if the receiving rsync is older than 3.1.3.\n\n0.  `--checksum`, `-c`\n\n    This changes the way rsync checks if the files have been changed and are in\n    need of a transfer.  Without this option, rsync uses a \"quick check\" that\n    (by default) checks if each file's size and time of last modification match\n    between the sender and receiver.  This option changes this to compare a\n    128-bit checksum for each file that has a matching size.  Generating the\n    checksums means that both sides will expend a lot of disk I/O reading all\n    the data in the files in the transfer, so this can slow things down\n    significantly (and this is prior to any reading that will be done to\n    transfer changed files)\n\n    The sending side generates its checksums while it is doing the file-system\n    scan that builds the list of the available files.  The receiver generates\n    its checksums when it is scanning for changed files, and will checksum any\n    file that has the same size as the corresponding sender's file: files with\n    either a changed size or a changed checksum are selected for transfer.\n\n    Note that rsync always verifies that each _transferred_ file was correctly\n    reconstructed on the receiving side by checking a whole-file checksum that\n    is generated as the file is transferred, but that automatic\n    after-the-transfer verification has nothing to do with this option's\n    before-the-transfer \"Does this file need to be updated?\" check.\n\n    The checksum used is auto-negotiated between the client and the server, but\n    can be overridden using either the [`--checksum-choice`](#opt) (`--cc`)\n    option or an environment variable that is discussed in that option's\n    section.\n\n0.  `--archive`, `-a`\n\n    This is equivalent to `-rlptgoD`.  It is a quick way of saying you want\n    recursion and want to preserve almost everything.  Be aware that it does\n    **not** include preserving ACLs (`-A`), xattrs (`-X`), atimes (`-U`),\n    crtimes (`-N`), nor the finding and preserving of hardlinks (`-H`).\n\n    The only exception to the above equivalence is when [`--files-from`](#opt)\n    is specified, in which case [`-r`](#opt) is not implied.\n\n0.  `--no-OPTION`\n\n    You may turn off one or more implied options by prefixing the option name\n    with \"no-\".  Not all positive options have a negated opposite, but a lot\n    do, including those that can be used to disable an implied option (e.g.\n    `--no-D`, `--no-perms`) or have different defaults in various circumstances\n    (e.g. [`--no-whole-file`](#opt), `--no-blocking-io`, `--no-dirs`).  Every\n    valid negated option accepts both the short and the long option name after\n    the \"no-\" prefix (e.g. `--no-R` is the same as `--no-relative`).\n\n    As an example, if you want to use [`--archive`](#opt) (`-a`) but don't want\n    [`--owner`](#opt) (`-o`), instead of converting `-a` into `-rlptgD`, you\n    can specify `-a --no-o` (aka `--archive --no-owner`).\n\n    The order of the options is important: if you specify `--no-r -a`, the `-r`\n    option would end up being turned on, the opposite of `-a --no-r`.  Note\n    also that the side-effects of the [`--files-from`](#opt) option are NOT\n    positional, as it affects the default state of several options and slightly\n    changes the meaning of [`-a`](#opt) (see the [`--files-from`](#opt) option\n    for more details).\n\n0.  `--recursive`, `-r`\n\n    This tells rsync to copy directories recursively.  See also\n    [`--dirs`](#opt) (`-d`) for an option that allows the scanning of a single\n    directory.\n\n    See the [`--inc-recursive`](#opt) option for a discussion of the\n    incremental recursion for creating the list of files to transfer.\n\n0. `--inc-recursive`, `--i-r`\n\n    This option explicitly enables on incremental recursion when scanning for\n    files, which is enabled by default when using the [`--recursive`](#opt)\n    option and both sides of the transfer are running rsync 3.0.0 or newer.\n\n    Incremental recursion uses much less memory than non-incremental, while\n    also beginning the transfer more quickly (since it doesn't need to scan the\n    entire transfer hierarchy before it starts transferring files).  If no\n    recursion is enabled in the source files, this option has no effect.\n\n    Some options require rsync to know the full file list, so these options\n    disable the incremental recursion mode.  These include:\n    - [`--delete-before`](#opt) (the old default of [`--delete`](#opt))\n    - [`--delete-after`](#opt)\n    - [`--prune-empty-dirs`](#opt)\n    - [`--delay-updates`](#opt)\n\n    In order to make [`--delete`](#opt) compatible with incremental recursion,\n    rsync 3.0.0 made [`--delete-during`](#opt) the default delete mode (which\n    was first added in 2.6.4).\n\n    One side-effect of incremental recursion is that any missing\n    sub-directories inside a recursively-scanned directory are (by default)\n    created prior to recursing into the sub-dirs.  This earlier creation point\n    (compared to a non-incremental recursion) allows rsync to then set the\n    modify time of the finished directory right away (without having to delay\n    that until a bunch of recursive copying has finished).  However, these\n    early directories don't yet have their completed mode, mtime, or ownership\n    set -- they have more restrictive rights until the subdirectory's copying\n    actually begins.  This early-creation idiom can be avoided by using the\n    [`--omit-dir-times`](#opt) option.\n\n    Incremental recursion can be disabled using the\n    [`--no-inc-recursive`](#opt) (`--no-i-r`) option.\n\n0. `--no-inc-recursive`, `--no-i-r`\n\n    Disables the new incremental recursion algorithm of the\n    [`--recursive`](#opt) option.  This makes rsync scan the full file list\n    before it begins to transfer files.  See [`--inc-recursive`](#opt) for more\n    info.\n\n0.  `--relative`, `-R`\n\n    Use relative paths.  This means that the full path names specified on the\n    command line are sent to the server rather than just the last parts of the\n    filenames.  This is particularly useful when you want to send several\n    different directories at the same time.  For example, if you used this\n    command:\n\n    >     rsync -av /foo/bar/baz.c remote:/tmp/\n\n    would create a file named baz.c in /tmp/ on the remote machine.  If instead\n    you used\n\n    >     rsync -avR /foo/bar/baz.c remote:/tmp/\n\n    then a file named /tmp/foo/bar/baz.c would be created on the remote\n    machine, preserving its full path.  These extra path elements are called\n    \"implied directories\" (i.e. the \"foo\" and the \"foo/bar\" directories in the\n    above example).\n\n    Beginning with rsync 3.0.0, rsync always sends these implied directories as\n    real directories in the file list, even if a path element is really a\n    symlink on the sending side.  This prevents some really unexpected behaviors\n    when copying the full path of a file that you didn't realize had a symlink\n    in its path.  If you want to duplicate a server-side symlink, include both\n    the symlink via its path, and referent directory via its real path.  If\n    you're dealing with an older rsync on the sending side, you may need to use\n    the [`--no-implied-dirs`](#opt) option.\n\n    It is also possible to limit the amount of path information that is sent as\n    implied directories for each path you specify.  With a modern rsync on the\n    sending side (beginning with 2.6.7), you can insert a dot and a slash into\n    the source path, like this:\n\n    >     rsync -avR /foo/./bar/baz.c remote:/tmp/\n\n    That would create /tmp/bar/baz.c on the remote machine. (Note that the dot\n    must be followed by a slash, so \"/foo/.\" would not be abbreviated.) For\n    older rsync versions, you would need to use a chdir to limit the source\n    path.  For example, when pushing files:\n\n    >     (cd /foo; rsync -avR bar/baz.c remote:/tmp/)\n\n    (Note that the parens put the two commands into a sub-shell, so that the\n    \"cd\" command doesn't remain in effect for future commands.) If you're\n    pulling files from an older rsync, use this idiom (but only for a\n    non-daemon transfer):\n\n    >     rsync -avR --rsync-path=\"cd /foo; rsync\" \\\n    >          remote:bar/baz.c /tmp/\n\n0.  `--no-implied-dirs`\n\n    This option affects the default behavior of the [`--relative`](#opt) option.  When\n    it is specified, the attributes of the implied directories from the source\n    names are not included in the transfer.  This means that the corresponding\n    path elements on the destination system are left unchanged if they exist,\n    and any missing implied directories are created with default attributes.\n    This even allows these implied path elements to have big differences, such\n    as being a symlink to a directory on the receiving side.\n\n    For instance, if a command-line arg or a files-from entry told rsync to\n    transfer the file \"path/foo/file\", the directories \"path\" and \"path/foo\"\n    are implied when [`--relative`](#opt) is used.  If \"path/foo\" is a symlink to \"bar\"\n    on the destination system, the receiving rsync would ordinarily delete\n    \"path/foo\", recreate it as a directory, and receive the file into the new\n    directory.  With `--no-implied-dirs`, the receiving rsync updates\n    \"path/foo/file\" using the existing path elements, which means that the file\n    ends up being created in \"path/bar\".  Another way to accomplish this link\n    preservation is to use the [`--keep-dirlinks`](#opt) option (which will also affect\n    symlinks to directories in the rest of the transfer).\n\n    When pulling files from an rsync older than 3.0.0, you may need to use this\n    option if the sending side has a symlink in the path you request and you\n    wish the implied directories to be transferred as normal directories.\n\n0.  `--backup`, `-b`\n\n    With this option, preexisting destination files are renamed as each file is\n    transferred or deleted.  You can control where the backup file goes and\n    what (if any) suffix gets appended using the [`--backup-dir`](#opt) and\n    [`--suffix`](#opt) options.\n\n    If you don't specify [`--backup-dir`](#opt):\n\n    1. the [`--omit-dir-times`](#opt) option will be forced on\n    2. the use of [`--delete`](#opt) (without [`--delete-excluded`](#opt)),\n       causes rsync to add a \"protect\" [filter-rule](#FILTER_RULES) for the\n       backup suffix to the end of all your existing filters that looks like\n       this: `-f \"P *~\"`.  This rule prevents previously backed-up files from\n       being deleted.\n\n    Note that if you are supplying your own filter rules, you may need to\n    manually insert your own exclude/protect rule somewhere higher up in the\n    list so that it has a high enough priority to be effective (e.g. if your\n    rules specify a trailing inclusion/exclusion of `*`, the auto-added rule\n    would never be reached).\n\n0.  `--backup-dir=DIR`\n\n    This implies the [`--backup`](#opt) option, and tells rsync to store all\n    backups in the specified directory on the receiving side.  This can be used\n    for incremental backups.  You can additionally specify a backup suffix\n    using the [`--suffix`](#opt) option (otherwise the files backed up in the\n    specified directory will keep their original filenames).\n\n    Note that if you specify a relative path, the backup directory will be\n    relative to the destination directory, so you probably want to specify\n    either an absolute path or a path that starts with \"../\".  If an rsync\n    daemon is the receiver, the backup dir cannot go outside the module's path\n    hierarchy, so take extra care not to delete it or copy into it.\n\n0.  `--suffix=SUFFIX`\n\n    This option allows you to override the default backup suffix used with the\n    [`--backup`](#opt) (`-b`) option.  The default suffix is a `~` if no\n    [`--backup-dir`](#opt) was specified, otherwise it is an empty string.\n\n0.  `--update`, `-u`\n\n    This forces rsync to skip any files which exist on the destination and have\n    a modified time that is newer than the source file. (If an existing\n    destination file has a modification time equal to the source file's, it\n    will be updated if the sizes are different.)\n\n    Note that this does not affect the copying of dirs, symlinks, or other\n    special files.  Also, a difference of file format between the sender and\n    receiver is always considered to be important enough for an update, no\n    matter what date is on the objects.  In other words, if the source has a\n    directory where the destination has a file, the transfer would occur\n    regardless of the timestamps.\n\n    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any\n    exclude side effects.\n\n    A caution for those that choose to combine [`--inplace`](#opt) with\n    `--update`: an interrupted transfer will leave behind a partial file on the\n    receiving side that has a very recent modified time, so re-running the\n    transfer will probably **not** continue the interrupted file.  As such, it\n    is usually best to avoid combining this with[ `--inplace`](#opt) unless you\n    have implemented manual steps to handle any interrupted in-progress files.\n\n0.  `--inplace`\n\n    This option changes how rsync transfers a file when its data needs to be\n    updated: instead of the default method of creating a new copy of the file\n    and moving it into place when it is complete, rsync instead writes the\n    updated data directly to the destination file.\n\n    This has several effects:\n\n    - Hard links are not broken.  This means the new data will be visible\n      through other hard links to the destination file.  Moreover, attempts to\n      copy differing source files onto a multiply-linked destination file will\n      result in a \"tug of war\" with the destination data changing back and\n      forth.\n    - In-use binaries cannot be updated (either the OS will prevent this from\n      happening, or binaries that attempt to swap-in their data will misbehave\n      or crash).\n    - The file's data will be in an inconsistent state during the transfer and\n      will be left that way if the transfer is interrupted or if an update\n      fails.\n    - A file that rsync cannot write to cannot be updated.  While a super user\n      can update any file, a normal user needs to be granted write permission\n      for the open of the file for writing to be successful.\n    - The efficiency of rsync's delta-transfer algorithm may be reduced if some\n      data in the destination file is overwritten before it can be copied to a\n      position later in the file.  This does not apply if you use [`--backup`](#opt),\n      since rsync is smart enough to use the backup file as the basis file for\n      the transfer.\n\n    WARNING: you should not use this option to update files that are being\n    accessed by others, so be careful when choosing to use this for a copy.\n\n    This option is useful for transferring large files with block-based changes\n    or appended data, and also on systems that are disk bound, not network\n    bound.  It can also help keep a copy-on-write filesystem snapshot from\n    diverging the entire contents of a file that only has minor changes.\n\n    The option implies [`--partial`](#opt) (since an interrupted transfer does\n    not delete the file), but conflicts with [`--partial-dir`](#opt) and\n    [`--delay-updates`](#opt).  Prior to rsync 2.6.4 `--inplace` was also\n    incompatible with [`--compare-dest`](#opt) and [`--link-dest`](#opt).\n\n0.  `--append`\n\n    This special copy mode only works to efficiently update files that are\n    known to be growing larger where any existing content on the receiving side\n    is also known to be the same as the content on the sender.  The use of\n    `--append` **can be dangerous** if you aren't 100% sure that all the files\n    in the transfer are shared, growing files.  You should thus use filter\n    rules to ensure that you weed out any files that do not fit this criteria.\n\n    Rsync updates these growing file in-place without verifying any of the\n    existing content in the file (it only verifies the content that it is\n    appending).  Rsync skips any files that exist on the receiving side that\n    are not shorter than the associated file on the sending side (which means\n    that new files are transferred).  It also skips any files whose size on the\n    sending side gets shorter during the send negotiations (rsync warns about a\n    \"diminished\" file when this happens).\n\n    This does not interfere with the updating of a file's non-content\n    attributes (e.g.  permissions, ownership, etc.) when the file does not need\n    to be transferred, nor does it affect the updating of any directories or\n    non-regular files.\n\n0.  `--append-verify`\n\n    This special copy mode works like [`--append`](#opt) except that all the\n    data in the file is included in the checksum verification (making it less\n    efficient but also potentially safer).  This option **can be dangerous** if\n    you aren't 100% sure that all the files in the transfer are shared, growing\n    files.  See the [`--append`](#opt) option for more details.\n\n    Note: prior to rsync 3.0.0, the [`--append`](#opt) option worked like\n    `--append-verify`, so if you are interacting with an older rsync (or the\n    transfer is using a protocol prior to 30), specifying either append option\n    will initiate an `--append-verify` transfer.\n\n0.  `--dirs`, `-d`\n\n    Tell the sending side to include any directories that are encountered.\n    Unlike [`--recursive`](#opt), a directory's contents are not copied unless\n    the directory name specified is \".\" or ends with a trailing slash (e.g.\n    \".\", \"dir/.\", \"dir/\", etc.).  Without this option or the\n    [`--recursive`](#opt) option, rsync will skip all directories it encounters\n    (and output a message to that effect for each one).  If you specify both\n    `--dirs` and [`--recursive`](#opt), `--recursive` takes precedence.\n\n    The `--dirs` option is implied by the [`--files-from`](#opt) option or the\n    [`--list-only`](#opt) option (including an implied [`--list-only`](#opt)\n    usage) if [`--recursive`](#opt) wasn't specified (so that directories are\n    seen in the listing).  Specify `--no-dirs` (or `--no-d`) if you want to\n    turn this off.\n\n    There is also a backward-compatibility helper option, `--old-dirs`\n    (`--old-d`) that tells rsync to use a hack of `-r --exclude='/*/*'` to get\n    an older rsync to list a single directory without recursing.\n\n0.  `--mkpath`\n\n    Create all missing path components of the destination path.\n\n    By default, rsync allows only the final component of the destination path\n    to not exist, which is an attempt to help you to validate your destination\n    path.  With this option, rsync creates all the missing destination-path\n    components, just as if `mkdir -p $DEST_PATH` had been run on the receiving\n    side.\n\n    When specifying a destination path, including a trailing slash ensures that\n    the whole path is treated as directory names to be created, even when the\n    file list has a single item. See the [COPYING TO A DIFFERENT NAME](#)\n    section for full details on how rsync decides if a final destination-path\n    component should be created as a directory or not.\n\n    If you would like the newly-created destination dirs to match the dirs on\n    the sending side, you should be using [`--relative`](#opt) (`-R`) instead\n    of `--mkpath`.  For instance, the following two commands result in the same\n    destination tree, but only the second command ensures that the\n    \"some/extra/path\" components match the dirs on the sending side:\n\n    >     rsync -ai --mkpath host:some/extra/path/*.c some/extra/path/\n    >     rsync -aiR host:some/extra/path/*.c ./\n\n0.  `--links`, `-l`\n\n    Add symlinks to the transferred files instead of noisily ignoring them with\n    a \"non-regular file\" warning for each symlink encountered.  You can\n    alternately silence the warning by specifying [`--info=nonreg0`](#opt).\n\n    The default handling of symlinks is to recreate each symlink's unchanged\n    value on the receiving side.\n\n    See the [SYMBOLIC LINKS](#) section for multi-option info.\n\n0.  `--copy-links`, `-L`\n\n    The sender transforms each symlink encountered in the transfer into the\n    referent item, following the symlink chain to the file or directory that it\n    references.  If a symlink chain is broken, an error is output and the file\n    is dropped from the transfer.\n\n    This option supersedes any other options that affect symlinks in the\n    transfer, since there are no symlinks left in the transfer.\n\n    This option does not change the handling of existing symlinks on the\n    receiving side, unlike versions of rsync prior to 2.6.3 which had the\n    side-effect of telling the receiving side to also follow symlinks.  A\n    modern rsync won't forward this option to a remote receiver (since only the\n    sender needs to know about it), so this caveat should only affect someone\n    using an rsync client older than 2.6.7 (which is when `-L` stopped being\n    forwarded to the receiver).\n\n    See the [`--keep-dirlinks`](#opt) (`-K`) if you need a symlink to a\n    directory to be treated as a real directory on the receiving side.\n\n    See the [SYMBOLIC LINKS](#) section for multi-option info.\n\n0.  `--copy-unsafe-links`\n\n    This tells rsync to copy the referent of symbolic links that point outside\n    the copied tree.  Absolute symlinks are also treated like ordinary files,\n    and so are any symlinks in the source path itself when [`--relative`](#opt)\n    is used.\n\n    Note that the cut-off point is the top of the transfer, which is the part\n    of the path that rsync isn't mentioning in the verbose output.  If you copy\n    \"/src/subdir\" to \"/dest/\" then the \"subdir\" directory is a name inside the\n    transfer tree, not the top of the transfer (which is /src) so it is legal\n    for created relative symlinks to refer to other names inside the /src and\n    /dest directories.  If you instead copy \"/src/subdir/\" (with a trailing\n    slash) to \"/dest/subdir\" that would not allow symlinks to any files outside\n    of \"subdir\".\n\n    Note that safe symlinks are only copied if [`--links`](#opt) was also\n    specified or implied. The `--copy-unsafe-links` option has no extra effect\n    when combined with [`--copy-links`](#opt).\n\n    See the [SYMBOLIC LINKS](#) section for multi-option info.\n\n0.  `--safe-links`\n\n    This tells the receiving rsync to ignore any symbolic links in the transfer\n    which point outside the copied tree.  All absolute symlinks are also\n    ignored.\n\n    Since this ignoring is happening on the receiving side, it will still be\n    effective even when the sending side has munged symlinks (when it is using\n    [`--munge-links`](#opt)). It also affects deletions, since the file being\n    present in the transfer prevents any matching file on the receiver from\n    being deleted when the symlink is deemed to be unsafe and is skipped.\n\n    This option must be combined with [`--links`](#opt) (or\n    [`--archive`](#opt)) to have any symlinks in the transfer to conditionally\n    ignore. Its effect is superseded by [`--copy-unsafe-links`](#opt).\n\n    Using this option in conjunction with [`--relative`](#opt) may give\n    unexpected results.\n\n    See the [SYMBOLIC LINKS](#) section for multi-option info.\n\n0.  `--munge-links`\n\n    This option affects just one side of the transfer and tells rsync to munge\n    symlink values when it is receiving files or unmunge symlink values when it\n    is sending files.  The munged values make the symlinks unusable on disk but\n    allows the original contents of the symlinks to be recovered.\n\n    The server-side rsync often enables this option without the client's\n    knowledge, such as in an rsync daemon's configuration file or by an option\n    given to the rrsync (restricted rsync) script.  When specified on the\n    client side, specify the option normally if it is the client side that\n    has/needs the munged symlinks, or use `-M--munge-links` to give the option\n    to the server when it has/needs the munged symlinks.  Note that on a local\n    transfer, the client is the sender, so specifying the option directly\n    unmunges symlinks while specifying it as a remote option munges symlinks.\n\n    This option has no effect when sent to a daemon via [`--remote-option`](#opt)\n    because the daemon configures whether it wants munged symlinks via its\n    \"`munge symlinks`\" parameter.\n\n    The symlink value is munged/unmunged once it is in the transfer, so any\n    option that transforms symlinks into non-symlinks occurs prior to the\n    munging/unmunging **except** for [`--safe-links`](#opt), which is a choice\n    that the receiver makes, so it bases its decision on the munged/unmunged\n    value.  This does mean that if a receiver has munging enabled, that using\n    [`--safe-links`](#opt) will cause all symlinks to be ignored (since they\n    are all absolute).\n\n    The method that rsync uses to munge the symlinks is to prefix each one's\n    value with the string \"/rsyncd-munged/\".  This prevents the links from\n    being used as long as the directory does not exist.  When this option is\n    enabled, rsync will refuse to run if that path is a directory or a symlink\n    to a directory (though it only checks at startup).  See also the\n    \"munge-symlinks\" python script in the support directory of the source code\n    for a way to munge/unmunge one or more symlinks in-place.\n\n0.  `--copy-dirlinks`, `-k`\n\n    This option causes the sending side to treat a symlink to a directory as\n    though it were a real directory.  This is useful if you don't want symlinks\n    to non-directories to be affected, as they would be using\n    [`--copy-links`](#opt).\n\n    Without this option, if the sending side has replaced a directory with a\n    symlink to a directory, the receiving side will delete anything that is in\n    the way of the new symlink, including a directory hierarchy (as long as\n    [`--force`](#opt) or [`--delete`](#opt) is in effect).\n\n    See also [`--keep-dirlinks`](#opt) for an analogous option for the\n    receiving side.\n\n    `--copy-dirlinks` applies to all symlinks to directories in the source.  If\n    you want to follow only a few specified symlinks, a trick you can use is to\n    pass them as additional source args with a trailing slash, using\n    [`--relative`](#opt) to make the paths match up right.  For example:\n\n    >     rsync -r --relative src/./ src/./follow-me/ dest/\n\n    This works because rsync calls **lstat**(2) on the source arg as given, and\n    the trailing slash makes **lstat**(2) follow the symlink, giving rise to a\n    directory in the file-list which overrides the symlink found during the\n    scan of \"src/./\".\n\n    See the [SYMBOLIC LINKS](#) section for multi-option info.\n\n0.  `--keep-dirlinks`, `-K`\n\n    This option causes the receiving side to treat a symlink to a directory as\n    though it were a real directory, but only if it matches a real directory\n    from the sender.  Without this option, the receiver's symlink would be\n    deleted and replaced with a real directory.\n\n    For example, suppose you transfer a directory \"foo\" that contains a file\n    \"file\", but \"foo\" is a symlink to directory \"bar\" on the receiver.  Without\n    `--keep-dirlinks`, the receiver deletes symlink \"foo\", recreates it as a\n    directory, and receives the file into the new directory.  With\n    `--keep-dirlinks`, the receiver keeps the symlink and \"file\" ends up in\n    \"bar\".\n\n    One note of caution: if you use `--keep-dirlinks`, you must trust all the\n    symlinks in the copy or enable the [`--munge-links`](#opt) option on the\n    receiving side!  If it is possible for an untrusted user to create their\n    own symlink to any real directory, the user could then (on a subsequent\n    copy) replace the symlink with a real directory and affect the content of\n    whatever directory the symlink references.  For backup copies, you are\n    better off using something like a bind mount instead of a symlink to modify\n    your receiving hierarchy.\n\n    See also [`--copy-dirlinks`](#opt) for an analogous option for the sending\n    side.\n\n    See the [SYMBOLIC LINKS](#) section for multi-option info.\n\n0.  `--hard-links`, `-H`\n\n    This tells rsync to look for hard-linked files in the source and link\n    together the corresponding files on the destination.  Without this option,\n    hard-linked files in the source are treated as though they were separate\n    files.\n\n    This option does NOT necessarily ensure that the pattern of hard links on\n    the destination exactly matches that on the source.  Cases in which the\n    destination may end up with extra hard links include the following:\n\n    - If the destination contains extraneous hard-links (more linking than what\n      is present in the source file list), the copying algorithm will not break\n      them explicitly.  However, if one or more of the paths have content\n      differences, the normal file-update process will break those extra links\n      (unless you are using the [`--inplace`](#opt) option).\n    - If you specify a [`--link-dest`](#opt) directory that contains hard\n      links, the linking of the destination files against the\n      [`--link-dest`](#opt) files can cause some paths in the destination to\n      become linked together due to the [`--link-dest`](#opt) associations.\n\n    Note that rsync can only detect hard links between files that are inside\n    the transfer set.  If rsync updates a file that has extra hard-link\n    connections to files outside the transfer, that linkage will be broken.  If\n    you are tempted to use the [`--inplace`](#opt) option to avoid this breakage, be\n    very careful that you know how your files are being updated so that you are\n    certain that no unintended changes happen due to lingering hard links (and\n    see the [`--inplace`](#opt) option for more caveats).\n\n    If incremental recursion is active (see [`--inc-recursive`](#opt)), rsync\n    may transfer a missing hard-linked file before it finds that another link\n    for that contents exists elsewhere in the hierarchy.  This does not affect\n    the accuracy of the transfer (i.e. which files are hard-linked together),\n    just its efficiency (i.e. copying the data for a new, early copy of a\n    hard-linked file that could have been found later in the transfer in\n    another member of the hard-linked set of files).  One way to avoid this\n    inefficiency is to disable incremental recursion using the\n    [`--no-inc-recursive`](#opt) option.\n\n0.  `--perms`, `-p`\n\n    This option causes the receiving rsync to set the destination permissions\n    to be the same as the source permissions. (See also the [`--chmod`](#opt)\n    option for a way to modify what rsync considers to be the source\n    permissions.)\n\n    When this option is _off_, permissions are set as follows:\n\n    - Existing files (including updated files) retain their existing\n      permissions, though the [`--executability`](#opt) option might change\n      just the execute permission for the file.\n    - New files get their \"normal\" permission bits set to the source file's\n      permissions masked with the receiving directory's default permissions\n      (either the receiving process's umask, or the permissions specified via\n      the destination directory's default ACL), and their special permission\n      bits disabled except in the case where a new directory inherits a setgid\n      bit from its parent directory.\n\n    Thus, when `--perms` and [`--executability`](#opt) are both disabled, rsync's\n    behavior is the same as that of other file-copy utilities, such as **cp**(1)\n    and **tar**(1).\n\n    In summary: to give destination files (both old and new) the source\n    permissions, use `--perms`.  To give new files the destination-default\n    permissions (while leaving existing files unchanged), make sure that the\n    `--perms` option is off and use [`--chmod=ugo=rwX`](#opt) (which ensures\n    that all non-masked bits get enabled).  If you'd care to make this latter\n    behavior easier to type, you could define a popt alias for it, such as\n    putting this line in the file `~/.popt` (the following defines the `-Z`\n    option, and includes `--no-g` to use the default group of the destination\n    dir):\n\n    >      rsync alias -Z --no-p --no-g --chmod=ugo=rwX\n\n    You could then use this new option in a command such as this one:\n\n    >      rsync -avZ src/ dest/\n\n    (Caveat: make sure that `-a` does not follow `-Z`, or it will re-enable the\n    two `--no-*` options mentioned above.)\n\n    The preservation of the destination's setgid bit on newly-created\n    directories when `--perms` is off was added in rsync 2.6.7.  Older rsync\n    versions erroneously preserved the three special permission bits for\n    newly-created files when `--perms` was off, while overriding the\n    destination's setgid bit setting on a newly-created directory.  Default ACL\n    observance was added to the ACL patch for rsync 2.6.7, so older (or\n    non-ACL-enabled) rsyncs use the umask even if default ACLs are present.\n    (Keep in mind that it is the version of the receiving rsync that affects\n    these behaviors.)\n\n0.  `--executability`, `-E`\n\n    This option causes rsync to preserve the executability (or\n    non-executability) of regular files when [`--perms`](#opt) is not enabled.\n    A regular file is considered to be executable if at least one 'x' is turned\n    on in its permissions.  When an existing destination file's executability\n    differs from that of the corresponding source file, rsync modifies the\n    destination file's permissions as follows:\n\n    - To make a file non-executable, rsync turns off all its 'x' permissions.\n    - To make a file executable, rsync turns on each 'x' permission that has a\n      corresponding 'r' permission enabled.\n\n    If [`--perms`](#opt) is enabled, this option is ignored.\n\n0.  `--acls`, `-A`\n\n    This option causes rsync to update the destination ACLs to be the same as\n    the source ACLs.  The option also implies [`--perms`](#opt).\n\n    The source and destination systems must have compatible ACL entries for\n    this option to work properly.  See the [`--fake-super`](#opt) option for a\n    way to backup and restore ACLs that are not compatible.\n\n0.  `--xattrs`, `-X`\n\n    This option causes rsync to update the destination extended attributes to\n    be the same as the source ones.\n\n    For systems that support extended-attribute namespaces, a copy being done\n    by a super-user copies all namespaces except system.\\*.  A normal user only\n    copies the user.\\* namespace.  To be able to backup and restore non-user\n    namespaces as a normal user, see the [`--fake-super`](#opt) option.\n\n    The above name filtering can be overridden by using one or more filter\n    options with the **x** modifier.  When you specify an xattr-affecting\n    filter rule, rsync requires that you do your own system/user filtering, as\n    well as any additional filtering for what xattr names are copied and what\n    names are allowed to be deleted.  For example, to skip the system\n    namespace, you could specify:\n\n    >     --filter='-x system.*'\n\n    To skip all namespaces except the user namespace, you could specify a\n    negated-user match:\n\n    >     --filter='-x! user.*'\n\n    To prevent any attributes from being deleted, you could specify a\n    receiver-only rule that excludes all names:\n\n    >     --filter='-xr *'\n\n    Note that the `-X` option does not copy rsync's special xattr values (e.g.\n    those used by [`--fake-super`](#opt)) unless you repeat the option (e.g. `-XX`).\n    This \"copy all xattrs\" mode cannot be used with [`--fake-super`](#opt).\n\n0.  `--chmod=CHMOD`\n\n    This option tells rsync to apply one or more comma-separated \"chmod\" modes\n    to the permission of the files in the transfer.  The resulting value is\n    treated as though it were the permissions that the sending side supplied\n    for the file, which means that this option can seem to have no effect on\n    existing files if [`--perms`](#opt) is not enabled.\n\n    In addition to the normal parsing rules specified in the **chmod**(1)\n    manpage, you can specify an item that should only apply to a directory by\n    prefixing it with a 'D', or specify an item that should only apply to a\n    file by prefixing it with a 'F'.  For example, the following will ensure\n    that all directories get marked set-gid, that no files are other-writable,\n    that both are user-writable and group-writable, and that both have\n    consistent executability across all bits:\n\n    >     --chmod=Dg+s,ug+w,Fo-w,+X\n\n    Using octal mode numbers is also allowed:\n\n    >     --chmod=D2775,F664\n\n    It is also legal to specify multiple `--chmod` options, as each additional\n    option is just appended to the list of changes to make.\n\n    See the [`--perms`](#opt) and [`--executability`](#opt) options for how the\n    resulting permission value can be applied to the files in the transfer.\n\n0.  `--owner`, `-o`\n\n    This option causes rsync to set the owner of the destination file to be the\n    same as the source file, but only if the receiving rsync is being run as\n    the super-user (see also the [`--super`](#opt) and [`--fake-super`](#opt)\n    options).  Without this option, the owner of new and/or transferred files\n    are set to the invoking user on the receiving side.\n\n    The preservation of ownership will associate matching names by default, but\n    may fall back to using the ID number in some circumstances (see also the\n    [`--numeric-ids`](#opt) option for a full discussion).\n\n0.  `--group`, `-g`\n\n    This option causes rsync to set the group of the destination file to be the\n    same as the source file.  If the receiving program is not running as the\n    super-user (or if `--no-super` was specified), only groups that the\n    invoking user on the receiving side is a member of will be preserved.\n    Without this option, the group is set to the default group of the invoking\n    user on the receiving side.\n\n    The preservation of group information will associate matching names by\n    default, but may fall back to using the ID number in some circumstances\n    (see also the [`--numeric-ids`](#opt) option for a full discussion).\n\n0.  `--devices`\n\n    This option causes rsync to transfer character and block device files to\n    the remote system to recreate these devices.  If the receiving rsync is not\n    being run as the super-user, rsync silently skips creating the device files\n    (see also the [`--super`](#opt) and [`--fake-super`](#opt) options).\n\n    By default, rsync generates a \"non-regular file\" warning for each device\n    file encountered when this option is not set.  You can silence the warning\n    by specifying [`--info=nonreg0`](#opt).\n\n0.  `--specials`\n\n    This option causes rsync to transfer special files, such as named sockets\n    and fifos.  If the receiving rsync is not being run as the super-user,\n    rsync silently skips creating the special files (see also the\n    [`--super`](#opt) and [`--fake-super`](#opt) options).\n\n    By default, rsync generates a \"non-regular file\" warning for each special\n    file encountered when this option is not set.  You can silence the warning\n    by specifying [`--info=nonreg0`](#opt).\n\n0.  `-D`\n\n    The `-D` option is equivalent to \"[`--devices`](#opt)\n    [`--specials`](#opt)\".\n\n0.  `--copy-devices`\n\n    This tells rsync to treat a device on the sending side as a regular file,\n    allowing it to be copied to a normal destination file (or another device\n    if `--write-devices` was also specified).\n\n    This option is refused by default by an rsync daemon.\n\n0.  `--write-devices`\n\n    This tells rsync to treat a device on the receiving side as a regular file,\n    allowing the writing of file data into a device.\n\n    This option implies the [`--inplace`](#opt) option.\n\n    Be careful using this, as you should know what devices are present on the\n    receiving side of the transfer, especially when running rsync as root.\n\n    This option is refused by default by an rsync daemon.\n\n0.  `--times`, `-t`\n\n    This tells rsync to transfer modification times along with the files and\n    update them on the remote system.  Note that if this option is not used,\n    the optimization that excludes files that have not been modified cannot be\n    effective; in other words, a missing `-t` (or [`-a`](#opt)) will cause the\n    next transfer to behave as if it used [`--ignore-times`](#opt) (`-I`),\n    causing all files to be updated (though rsync's delta-transfer algorithm\n    will make the update fairly efficient if the files haven't actually\n    changed, you're much better off using `-t`).\n\n    A modern rsync that is using transfer protocol 30 or 31 conveys a modify\n    time using up to 8-bytes. If rsync is forced to speak an older protocol\n    (perhaps due to the remote rsync being older than 3.0.0) a modify time is\n    conveyed using 4-bytes. Prior to 3.2.7, these shorter values could convey\n    a date range of 13-Dec-1901 to 19-Jan-2038.  Beginning with 3.2.7, these\n    4-byte values now convey a date range of 1-Jan-1970 to 7-Feb-2106.  If you\n    have files dated older than 1970, make sure your rsync executables are\n    upgraded so that the full range of dates can be conveyed.\n\n0.  `--atimes`, `-U`\n\n    This tells rsync to set the access (use) times of the destination files to\n    the same value as the source files.\n\n    If repeated, it also sets the [`--open-noatime`](#opt) option, which can help you\n    to make the sending and receiving systems have the same access times on the\n    transferred files without needing to run rsync an extra time after a file\n    is transferred.\n\n    Note that some older rsync versions (prior to 3.2.0) may have been built\n    with a pre-release `--atimes` patch that does not imply\n    [`--open-noatime`](#opt) when this option is repeated.\n\n0.  `--open-noatime`\n\n    This tells rsync to open files with the O_NOATIME flag (on systems that\n    support it) to avoid changing the access time of the files that are being\n    transferred.  If your OS does not support the O_NOATIME flag then rsync\n    will silently ignore this option.  Note also that some filesystems are\n    mounted to avoid updating the atime on read access even without the\n    O_NOATIME flag being set.\n\n0.  `--crtimes`, `-N,`\n\n    This tells rsync to set the create times (newness) of the destination\n    files to the same value as the source files. Your OS & filesystem must\n    support the setting of arbitrary creation (birth) times for this option\n    to be supported.\n\n0.  `--omit-dir-times`, `-O`\n\n    This tells rsync to omit directories when it is preserving modification,\n    access, and create times.  If NFS is sharing the directories on the receiving\n    side, it is a good idea to use `-O`.  This option is inferred if you use\n    [`--backup`](#opt) without [`--backup-dir`](#opt).\n\n    This option also has the side-effect of avoiding early creation of missing\n    sub-directories when incremental recursion is enabled, as discussed in the\n    [`--inc-recursive`](#opt) section.\n\n0.  `--omit-link-times`, `-J`\n\n    This tells rsync to omit symlinks when it is preserving modification,\n    access, and create times.\n\n0.  `--super`\n\n    This tells the receiving side to attempt super-user activities even if the\n    receiving rsync wasn't run by the super-user.  These activities include:\n    preserving users via the [`--owner`](#opt) option, preserving all groups\n    (not just the current user's groups) via the [`--group`](#opt) option, and\n    copying devices via the [`--devices`](#opt) option.  This is useful for\n    systems that allow such activities without being the super-user, and also\n    for ensuring that you will get errors if the receiving side isn't being run\n    as the super-user.  To turn off super-user activities, the super-user can\n    use `--no-super`.\n\n0.  `--fake-super`\n\n    When this option is enabled, rsync simulates super-user activities by\n    saving/restoring the privileged attributes via special extended attributes\n    that are attached to each file (as needed).  This includes the file's owner\n    and group (if it is not the default), the file's device info (device &\n    special files are created as empty text files), and any permission bits\n    that we won't allow to be set on the real file (e.g. the real file gets\n    u-s,g-s,o-t for safety) or that would limit the owner's access (since the\n    real super-user can always access/change a file, the files we create can\n    always be accessed/changed by the creating user).  This option also handles\n    ACLs (if [`--acls`](#opt) was specified) and non-user extended attributes\n    (if [`--xattrs`](#opt) was specified).\n\n    This is a good way to backup data without using a super-user, and to store\n    ACLs from incompatible systems.\n\n    The `--fake-super` option only affects the side where the option is used.\n    To affect the remote side of a remote-shell connection, use the\n    [`--remote-option`](#opt) (`-M`) option:\n\n    >     rsync -av -M--fake-super /src/ host:/dest/\n\n    For a local copy, this option affects both the source and the destination.\n    If you wish a local copy to enable this option just for the destination\n    files, specify `-M--fake-super`.  If you wish a local copy to enable this\n    option just for the source files, combine `--fake-super` with `-M--super`.\n\n    This option is overridden by both [`--super`](#opt) and `--no-super`.\n\n    See also the [`fake super`](rsyncd.conf.5#fake_super) setting in the\n    daemon's rsyncd.conf file.\n\n0.  `--sparse`, `-S`\n\n    Try to handle sparse files efficiently so they take up less space on the\n    destination.  If combined with [`--inplace`](#opt) the file created might\n    not end up with sparse blocks with some combinations of kernel version\n    and/or filesystem type.  If [`--whole-file`](#opt) is in effect (e.g. for a\n    local copy) then it will always work because rsync truncates the file prior\n    to writing out the updated version.\n\n    Note that versions of rsync older than 3.1.3 will reject the combination of\n    `--sparse` and [`--inplace`](#opt).\n\n0.  `--preallocate`\n\n    This tells the receiver to allocate each destination file to its eventual\n    size before writing data to the file.  Rsync will only use the real\n    filesystem-level preallocation support provided by Linux's **fallocate**(2)\n    system call or Cygwin's **posix_fallocate**(3), not the slow glibc\n    implementation that writes a null byte into each block.\n\n    Without this option, larger files may not be entirely contiguous on the\n    filesystem, but with this option rsync will probably copy more slowly.  If\n    the destination is not an extent-supporting filesystem (such as ext4, xfs,\n    NTFS, etc.), this option may have no positive effect at all.\n\n    If combined with [`--sparse`](#opt), the file will only have sparse blocks\n    (as opposed to allocated sequences of null bytes) if the kernel version and\n    filesystem type support creating holes in the allocated data.\n\n0.  `--dry-run`, `-n`\n\n    This makes rsync perform a trial run that doesn't make any changes (and\n    produces mostly the same output as a real run).  It is most commonly used\n    in combination with the [`--verbose`](#opt) (`-v`) and/or\n    [`--itemize-changes`](#opt) (`-i`) options to see what an rsync command is\n    going to do before one actually runs it.\n\n    The output of [`--itemize-changes`](#opt) is supposed to be exactly the\n    same on a dry run and a subsequent real run (barring intentional trickery\n    and system call failures); if it isn't, that's a bug.  Other output should\n    be mostly unchanged, but may differ in some areas.  Notably, a dry run does\n    not send the actual data for file transfers, so [`--progress`](#opt) has no\n    effect, the \"bytes sent\", \"bytes received\", \"literal data\", and \"matched\n    data\" statistics are too small, and the \"speedup\" value is equivalent to a\n    run where no file transfers were needed.\n\n0.  `--whole-file`, `-W`\n\n    This option disables rsync's delta-transfer algorithm, which causes all\n    transferred files to be sent whole.  The transfer may be faster if this\n    option is used when the bandwidth between the source and destination\n    machines is higher than the bandwidth to disk (especially when the \"disk\"\n    is actually a networked filesystem).  This is the default when both the\n    source and destination are specified as local paths, but only if no\n    batch-writing option is in effect.\n\n0. `--no-whole-file`, `--no-W`\n\n    Disable whole-file updating when it is enabled by default for a local\n    transfer.  This usually slows rsync down, but it can be useful if you are\n    trying to minimize the writes to the destination file (if combined with\n    [`--inplace`](#opt)) or for testing the checksum-based update algorithm.\n\n    See also the [`--whole-file`](#opt) option.\n\n0.  `--checksum-choice=STR`, `--cc=STR`\n\n    This option overrides the checksum algorithms.  If one algorithm name is\n    specified, it is used for both the transfer checksums and (assuming\n    [`--checksum`](#opt) is specified) the pre-transfer checksums.  If two\n    comma-separated names are supplied, the first name affects the transfer\n    checksums, and the second name affects the pre-transfer checksums (`-c`).\n\n    The checksum options that you may be able to use are:\n\n    - `auto` (the default automatic choice)\n    - `xxh128`\n    - `xxh3`\n    - `xxh64` (aka `xxhash`)\n    - `md5`\n    - `md4`\n    - `sha1`\n    - `none`\n\n    Run `rsync --version` to see the default checksum list compiled into your\n    version (which may differ from the list above).\n\n    If \"none\" is specified for the first (or only) name, the [`--whole-file`](#opt)\n    option is forced on and no checksum verification is performed on the\n    transferred data.  If \"none\" is specified for the second (or only) name,\n    the [`--checksum`](#opt) option cannot be used.\n\n    The \"auto\" option is the default, where rsync bases its algorithm choice on\n    a negotiation between the client and the server as follows:\n\n    When both sides of the transfer are at least 3.2.0, rsync chooses the first\n    algorithm in the client's list of choices that is also in the server's list\n    of choices.  If no common checksum choice is found, rsync exits with\n    an error.  If the remote rsync is too old to support checksum negotiation,\n    a value is chosen based on the protocol version (which chooses between MD5\n    and various flavors of MD4 based on protocol age).\n\n    The default order can be customized by setting the environment variable\n    [`RSYNC_CHECKSUM_LIST`](#) to a space-separated list of acceptable checksum\n    names.  If the string contains a \"`&`\" character, it is separated into the\n    \"client string & server string\", otherwise the same string applies to both.\n    If the string (or string portion) contains no non-whitespace characters,\n    the default checksum list is used.  This method does not allow you to\n    specify the transfer checksum separately from the pre-transfer checksum,\n    and it discards \"auto\" and all unknown checksum names.  A list with only\n    invalid names results in a failed negotiation.\n\n    The use of the `--checksum-choice` option overrides this environment list.\n\n0.  `--one-file-system`, `-x`\n\n    This tells rsync to avoid crossing a filesystem boundary when recursing.\n    This does not limit the user's ability to specify items to copy from\n    multiple filesystems, just rsync's recursion through the hierarchy of each\n    directory that the user specified, and also the analogous recursion on the\n    receiving side during deletion.  Also keep in mind that rsync treats a\n    \"bind\" mount to the same device as being on the same filesystem.\n\n    If this option is repeated, rsync omits all mount-point directories from\n    the copy.  Otherwise, it includes an empty directory at each mount-point it\n    encounters (using the attributes of the mounted directory because those of\n    the underlying mount-point directory are inaccessible).\n\n    If rsync has been told to collapse symlinks (via [`--copy-links`](#opt) or\n    [`--copy-unsafe-links`](#opt)), a symlink to a directory on another device\n    is treated like a mount-point.  Symlinks to non-directories are unaffected\n    by this option.\n\n0.  `--ignore-non-existing`, `--existing`\n\n    This tells rsync to skip creating files (including directories) that do not\n    exist yet on the destination.  If this option is combined with the\n    [`--ignore-existing`](#opt) option, no files will be updated (which can be\n    useful if all you want to do is delete extraneous files).\n\n    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any\n    exclude side effects.\n\n0.  `--ignore-existing`\n\n    This tells rsync to skip updating files that already exist on the\n    destination (this does _not_ ignore existing directories, or nothing would\n    get done).  See also [`--ignore-non-existing`](#opt).\n\n    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any\n    exclude side effects.\n\n    This option can be useful for those doing backups using the\n    [`--link-dest`](#opt) option when they need to continue a backup run that\n    got interrupted.  Since a [`--link-dest`](#opt) run is copied into a new\n    directory hierarchy (when it is used properly), using [`--ignore-existing`\n    will ensure that the already-handled files don't get tweaked (which avoids\n    a change in permissions on the hard-linked files).  This does mean that\n    this option is only looking at the existing files in the destination\n    hierarchy itself.\n\n    When [`--info=skip2`](#opt) is used rsync will output \"FILENAME exists\n    (INFO)\" messages where the INFO indicates one of \"type change\", \"sum\n    change\" (requires [`-c`](#opt)), \"file change\" (based on the quick check),\n    \"attr change\", or \"uptodate\".  Using [`--info=skip1`](#opt) (which is also\n    implied by 2 [`-v`](#opt) options) outputs the exists message without the\n    INFO suffix.\n\n0.  `--remove-source-files`\n\n    This tells rsync to remove from the sending side the files (meaning\n    non-directories) that are a part of the transfer and have been successfully\n    duplicated on the receiving side.\n\n    Note that you should only use this option on source files that are\n    quiescent.  If you are using this to move files that show up in a\n    particular directory over to another host, make sure that the finished\n    files get renamed into the source directory, not directly written into it,\n    so that rsync can't possibly transfer a file that is not yet fully written.\n    If you can't first write the files into a different directory, you should\n    use a naming idiom that lets rsync avoid transferring files that are not\n    yet finished (e.g. name the file \"foo.new\" when it is written, rename it to\n    \"foo\" when it is done, and then use the option [`--exclude='*.new'`](#opt)\n    for the rsync transfer).\n\n    Starting with 3.1.0, rsync will skip the sender-side removal (and output an\n    error) if the file's size or modify time has not stayed unchanged.\n\n    Starting with 3.2.6, a local rsync copy will ensure that the sender does\n    not remove a file the receiver just verified, such as when the user\n    accidentally makes the source and destination directory the same path.\n\n0.  `--delete`\n\n    This tells rsync to delete extraneous files from the receiving side (ones\n    that aren't on the sending side), but only for the directories that are\n    being synchronized.  You must have asked rsync to send the whole directory\n    (e.g. \"`dir`\" or \"`dir/`\") without using a wildcard for the directory's\n    contents (e.g. \"`dir/*`\") since the wildcard is expanded by the shell and\n    rsync thus gets a request to transfer individual files, not the files'\n    parent directory.  Files that are excluded from the transfer are also\n    excluded from being deleted unless you use the [`--delete-excluded`](#opt)\n    option or mark the rules as only matching on the sending side (see the\n    include/exclude modifiers in the [FILTER RULES](#) section).\n\n    Prior to rsync 2.6.7, this option would have no effect unless\n    [`--recursive`](#opt) was enabled.  Beginning with 2.6.7, deletions will\n    also occur when [`--dirs`](#opt) (`-d`) is enabled, but only for\n    directories whose contents are being copied.\n\n    This option can be dangerous if used incorrectly! It is a very good idea to\n    first try a run using the [`--dry-run`](#opt) (`-n`) option to see what\n    files are going to be deleted.\n\n    If the sending side detects any I/O errors, then the deletion of any files\n    at the destination will be automatically disabled.  This is to prevent\n    temporary filesystem failures (such as NFS errors) on the sending side from\n    causing a massive deletion of files on the destination.  You can override\n    this with the [`--ignore-errors`](#opt) option.\n\n    The `--delete` option may be combined with one of the --delete-WHEN options\n    without conflict, as well as [`--delete-excluded`](#opt).  However, if none\n    of the `--delete-WHEN` options are specified, rsync will choose the\n    [`--delete-during`](#opt) algorithm when talking to rsync 3.0.0 or newer,\n    or the [`--delete-before`](#opt) algorithm when talking to an older rsync.\n    See also [`--delete-delay`](#opt) and [`--delete-after`](#opt).\n\n0.  `--delete-before`\n\n    Request that the file-deletions on the receiving side be done before the\n    transfer starts.  See [`--delete`](#opt) (which is implied) for more\n    details on file-deletion.\n\n    Deleting before the transfer is helpful if the filesystem is tight for\n    space and removing extraneous files would help to make the transfer\n    possible.  However, it does introduce a delay before the start of the\n    transfer, and this delay might cause the transfer to timeout (if\n    [`--timeout`](#opt) was specified).  It also forces rsync to use the old,\n    non-incremental recursion algorithm that requires rsync to scan all the\n    files in the transfer into memory at once (see [`--recursive`](#opt)).\n\n0.  `--delete-during`, `--del`\n\n    Request that the file-deletions on the receiving side be done incrementally\n    as the transfer happens.  The per-directory delete scan is done right\n    before each directory is checked for updates, so it behaves like a more\n    efficient [`--delete-before`](#opt), including doing the deletions prior to\n    any per-directory filter files being updated.  This option was first added\n    in rsync version 2.6.4.  See [`--delete`](#opt) (which is implied) for more\n    details on file-deletion.\n\n0.  `--delete-delay`\n\n    Request that the file-deletions on the receiving side be computed during\n    the transfer (like [`--delete-during`](#opt)), and then removed after the\n    transfer completes.  This is useful when combined with\n    [`--delay-updates`](#opt) and/or [`--fuzzy`](#opt), and is more efficient\n    than using [`--delete-after`](#opt) (but can behave differently, since\n    [`--delete-after`](#opt) computes the deletions in a separate pass after\n    all updates are done).  If the number of removed files overflows an\n    internal buffer, a temporary file will be created on the receiving side to\n    hold the names (it is removed while open, so you shouldn't see it during\n    the transfer).  If the creation of the temporary file fails, rsync will try\n    to fall back to using [`--delete-after`](#opt) (which it cannot do if\n    [`--recursive`](#opt) is doing an incremental scan).  See\n    [`--delete`](#opt) (which is implied) for more details on file-deletion.\n\n0.  `--delete-after`\n\n    Request that the file-deletions on the receiving side be done after the\n    transfer has completed.  This is useful if you are sending new\n    per-directory merge files as a part of the transfer and you want their\n    exclusions to take effect for the delete phase of the current transfer.  It\n    also forces rsync to use the old, non-incremental recursion algorithm that\n    requires rsync to scan all the files in the transfer into memory at once\n    (see [`--recursive`](#opt)). See [`--delete`](#opt) (which is implied) for\n    more details on file-deletion.\n\n    See also the [`--delete-delay`](#opt) option that might be a faster choice\n    for those that just want the deletions to occur at the end of the transfer.\n\n0.  `--delete-excluded`\n\n    This option turns any unqualified exclude/include rules into server-side\n    rules that do not affect the receiver's deletions.\n\n    By default, an exclude or include has both a server-side effect (to \"hide\"\n    and \"show\" files when building the server's file list) and a receiver-side\n    effect (to \"protect\" and \"risk\" files when deletions are occurring).  Any\n    rule that has no modifier to specify what sides it is executed on will be\n    instead treated as if it were a server-side rule only, avoiding any\n    \"protect\" effects of the rules.\n\n    A rule can still apply to both sides even with this option specified if the\n    rule is given both the sender & receiver modifier letters (e.g., `-f'-sr\n    foo'`).  Receiver-side protect/risk rules can also be explicitly specified\n    to limit the deletions.  This saves you from having to edit a bunch of\n    `-f'- foo'` rules into `-f'-s foo'` (aka `-f'H foo'`) rules (not to mention\n    the corresponding includes).\n\n    See the [FILTER RULES](#) section for more information.  See\n    [`--delete`](#opt) (which is implied) for more details on deletion.\n\n0.  `--ignore-missing-args`\n\n    When rsync is first processing the explicitly requested source files (e.g.\n    command-line arguments or [`--files-from`](#opt) entries), it is normally\n    an error if the file cannot be found.  This option suppresses that error,\n    and does not try to transfer the file.  This does not affect subsequent\n    vanished-file errors if a file was initially found to be present and later\n    is no longer there.\n\n0.  `--delete-missing-args`\n\n    This option takes the behavior of the (implied)\n    [`--ignore-missing-args`](#opt) option a step farther: each missing arg\n    will become a deletion request of the corresponding destination file on the\n    receiving side (should it exist).  If the destination file is a non-empty\n    directory, it will only be successfully deleted if [`--force`](#opt) or\n    [`--delete`](#opt) are in effect.  Other than that, this option is\n    independent of any other type of delete processing.\n\n    The missing source files are represented by special file-list entries which\n    display as a \"`*missing`\" entry in the [`--list-only`](#opt) output.\n\n0.  `--ignore-errors`\n\n    Tells [`--delete`](#opt) to go ahead and delete files even when there are\n    I/O errors.\n\n0.  `--force`\n\n    This option tells rsync to delete a non-empty directory when it is to be\n    replaced by a non-directory.  This is only relevant if deletions are not\n    active (see [`--delete`](#opt) for details).\n\n    Note for older rsync versions: `--force` used to still be required when\n    using [`--delete-after`](#opt), and it used to be non-functional unless the\n    [`--recursive`](#opt) option was also enabled.\n\n0.  `--max-delete=NUM`\n\n    This tells rsync not to delete more than NUM files or directories.  If that\n    limit is exceeded, all further deletions are skipped through the end of the\n    transfer.  At the end, rsync outputs a warning (including a count of the\n    skipped deletions) and exits with an error code of 25 (unless some more\n    important error condition also occurred).\n\n    Beginning with version 3.0.0, you may specify `--max-delete=0` to be warned\n    about any extraneous files in the destination without removing any of them.\n    Older clients interpreted this as \"unlimited\", so if you don't know what\n    version the client is, you can use the less obvious `--max-delete=-1` as a\n    backward-compatible way to specify that no deletions be allowed (though\n    really old versions didn't warn when the limit was exceeded).\n\n0.  `--max-size=SIZE`\n\n    This tells rsync to avoid transferring any file that is larger than the\n    specified SIZE.  A numeric value can be suffixed with a string to indicate\n    the numeric units or left unqualified to specify bytes.  Feel free to use a\n    fractional value along with the units, such as `--max-size=1.5m`.\n\n    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any\n    exclude side effects.\n\n    The first letter of a units string can be `B` (bytes), `K` (kilo), `M`\n    (mega), `G` (giga), `T` (tera), or `P` (peta).  If the string is a single\n    char or has \"ib\" added to it (e.g. \"G\" or \"GiB\") then the units are\n    multiples of 1024.  If you use a two-letter suffix that ends with a \"B\"\n    (e.g. \"kb\") then you get units that are multiples of 1000.  The string's\n    letters can be any mix of upper and lower-case that you want to use.\n\n    Finally, if the string ends with either \"+1\" or \"-1\", it is offset by one\n    byte in the indicated direction.  The largest possible value is usually\n    `8192P-1`.\n\n    Examples: `--max-size=1.5mb-1` is 1499999 bytes, and `--max-size=2g+1` is\n    2147483649 bytes.\n\n    Note that rsync versions prior to 3.1.0 did not allow `--max-size=0`.\n\n0.  `--min-size=SIZE`\n\n    This tells rsync to avoid transferring any file that is smaller than the\n    specified SIZE, which can help in not transferring small, junk files.  See\n    the [`--max-size`](#opt) option for a description of SIZE and other info.\n\n    Note that rsync versions prior to 3.1.0 did not allow `--min-size=0`.\n\n0.  `--max-alloc=SIZE`\n\n    By default rsync limits an individual malloc/realloc to about 1GB in size.\n    For most people this limit works just fine and prevents a protocol error\n    causing rsync to request massive amounts of memory.  However, if you have\n    many millions of files in a transfer, a large amount of server memory, and\n    you don't want to split up your transfer into multiple parts, you can\n    increase the per-allocation limit to something larger and rsync will\n    consume more memory.\n\n    Keep in mind that this is not a limit on the total size of allocated\n    memory.  It is a sanity-check value for each individual allocation.\n\n    See the [`--max-size`](#opt) option for a description of how SIZE can be\n    specified.  The default suffix if none is given is bytes.\n\n    Beginning in 3.2.7, a value of 0 is an easy way to specify SIZE_MAX (the\n    largest limit possible).\n\n    You can set a default value using the environment variable\n    [`RSYNC_MAX_ALLOC`](#) using the same SIZE values as supported by this\n    option.  If the remote rsync doesn't understand the `--max-alloc` option,\n    you can override an environmental value by specifying `--max-alloc=1g`,\n    which will make rsync avoid sending the option to the remote side (because\n    \"1G\" is the default).\n\n0.  `--block-size=SIZE`, `-B`\n\n    This forces the block size used in rsync's delta-transfer algorithm to a\n    fixed value.  It is normally selected based on the size of each file being\n    updated.  See the technical report for details.\n\n    Beginning in 3.2.3 the SIZE can be specified with a suffix as detailed in\n    the [`--max-size`](#opt) option.  Older versions only accepted a byte count.\n\n0.  `--rsh=COMMAND`, `-e`\n\n    This option allows you to choose an alternative remote shell program to use\n    for communication between the local and remote copies of rsync.  Typically,\n    rsync is configured to use ssh by default, but you may prefer to use rsh on\n    a local network.\n\n    If this option is used with `[user@]host::module/path`, then the remote\n    shell _COMMAND_ will be used to run an rsync daemon on the remote host, and\n    all data will be transmitted through that remote shell connection, rather\n    than through a direct socket connection to a running rsync daemon on the\n    remote host.  See the [USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL\n    CONNECTION](#) section above.\n\n    Beginning with rsync 3.2.0, the [`RSYNC_PORT`](#) environment variable will\n    be set when a daemon connection is being made via a remote-shell\n    connection.  It is set to 0 if the default daemon port is being assumed, or\n    it is set to the value of the rsync port that was specified via either the\n    [`--port`](#opt) option or a non-empty port value in an `rsync://` URL.\n    This allows the script to discern if a non-default port is being requested,\n    allowing for things such as an SSL or stunnel helper script to connect to a\n    default or alternate port.\n\n    Command-line arguments are permitted in COMMAND provided that COMMAND is\n    presented to rsync as a single argument.  You must use spaces (not tabs or\n    other whitespace) to separate the command and args from each other, and you\n    can use single- and/or double-quotes to preserve spaces in an argument (but\n    not backslashes).  Note that doubling a single-quote inside a single-quoted\n    string gives you a single-quote; likewise for double-quotes (though you\n    need to pay attention to which quotes your shell is parsing and which\n    quotes rsync is parsing).  Some examples:\n\n    >     -e 'ssh -p 2234'\n    >     -e 'ssh -o \"ProxyCommand nohup ssh firewall nc -w1 %h %p\"'\n\n    (Note that ssh users can alternately customize site-specific connect\n    options in their .ssh/config file.)\n\n    You can also choose the remote shell program using the [`RSYNC_RSH`](#)\n    environment variable, which accepts the same range of values as `-e`.\n\n    See also the [`--blocking-io`](#opt) option which is affected by this\n    option.\n\n0.  `--rsync-path=PROGRAM`\n\n    Use this to specify what program is to be run on the remote machine to\n    start-up rsync.  Often used when rsync is not in the default remote-shell's\n    path (e.g. `--rsync-path=/usr/local/bin/rsync`).  Note that PROGRAM is run\n    with the help of a shell, so it can be any program, script, or command\n    sequence you'd care to run, so long as it does not corrupt the standard-in\n    & standard-out that rsync is using to communicate.\n\n    One tricky example is to set a different default directory on the remote\n    machine for use with the [`--relative`](#opt) option.  For instance:\n\n    >     rsync -avR --rsync-path=\"cd /a/b && rsync\" host:c/d /e/\n\n0.  `--remote-option=OPTION`, `-M`\n\n    This option is used for more advanced situations where you want certain\n    effects to be limited to one side of the transfer only.  For instance, if\n    you want to pass [`--log-file=FILE`](#opt) and [`--fake-super`](#opt) to\n    the remote system, specify it like this:\n\n    >     rsync -av -M --log-file=foo -M--fake-super src/ dest/\n\n    If you want to have an option affect only the local side of a transfer when\n    it normally affects both sides, send its negation to the remote side.  Like\n    this:\n\n    >     rsync -av -x -M--no-x src/ dest/\n\n    Be cautious using this, as it is possible to toggle an option that will\n    cause rsync to have a different idea about what data to expect next over\n    the socket, and that will make it fail in a cryptic fashion.\n\n    Note that you should use a separate `-M` option for each remote option you\n    want to pass.  On older rsync versions, the presence of any spaces in the\n    remote-option arg could cause it to be split into separate remote args, but\n    this requires the use of [`--old-args`](#opt) in a modern rsync.\n\n    When performing a local transfer, the \"local\" side is the sender and the\n    \"remote\" side is the receiver.\n\n    Note some versions of the popt option-parsing library have a bug in them\n    that prevents you from using an adjacent arg with an equal in it next to a\n    short option letter (e.g. `-M--log-file=/tmp/foo`).  If this bug affects\n    your version of popt, you can use the version of popt that is included with\n    rsync.\n\n0.  `--cvs-exclude`, `-C`\n\n    This is a useful shorthand for excluding a broad range of files that you\n    often don't want to transfer between systems.  It uses a similar algorithm\n    to CVS to determine if a file should be ignored.\n\n    The exclude list is initialized to exclude the following items (these\n    initial items are marked as perishable -- see the [FILTER RULES](#)\n    section):\n\n    [comment]: # (This list gets used for the default-cvsignore.h file.)\n\n    > `RCS`\n    > `SCCS`\n    > `CVS`\n    > `CVS.adm`\n    > `RCSLOG`\n    > `cvslog.*`\n    > `tags`\n    > `TAGS`\n    > `.make.state`\n    > `.nse_depinfo`\n    > `*~`\n    > `#*`\n    > `.#*`\n    > `,*`\n    > `_$*`\n    > `*$`\n    > `*.old`\n    > `*.bak`\n    > `*.BAK`\n    > `*.orig`\n    > `*.rej`\n    > `.del-*`\n    > `*.a`\n    > `*.olb`\n    > `*.o`\n    > `*.obj`\n    > `*.so`\n    > `*.exe`\n    > `*.Z`\n    > `*.elc`\n    > `*.ln`\n    > `core`\n    > `.svn/`\n    > `.git/`\n    > `.hg/`\n    > `.bzr/`\n\n    then, files listed in a $HOME/.cvsignore are added to the list and any\n    files listed in the CVSIGNORE environment variable (all cvsignore names are\n    delimited by whitespace).\n\n    Finally, any file is ignored if it is in the same directory as a .cvsignore\n    file and matches one of the patterns listed therein.  Unlike rsync's\n    filter/exclude files, these patterns are split on whitespace.  See the\n    **cvs**(1) manual for more information.\n\n    If you're combining `-C` with your own [`--filter`](#opt) rules, you should\n    note that these CVS excludes are appended at the end of your own rules,\n    regardless of where the `-C` was placed on the command-line.  This makes\n    them a lower priority than any rules you specified explicitly.  If you want\n    to control where these CVS excludes get inserted into your filter rules,\n    you should omit the `-C` as a command-line option and use a combination of\n    [`--filter=:C`](#opt) and [`--filter=-C`](#opt) (either on your\n    command-line or by putting the \":C\" and \"-C\" rules into a filter file with\n    your other rules).  The first option turns on the per-directory scanning\n    for the .cvsignore file.  The second option does a one-time import of the\n    CVS excludes mentioned above.\n\n0.  `--filter=RULE`, `-f`\n\n    This option allows you to add rules to selectively exclude certain files\n    from the list of files to be transferred.  This is most useful in\n    combination with a recursive transfer.\n\n    You may use as many `--filter` options on the command line as you like to\n    build up the list of files to exclude.  If the filter contains whitespace,\n    be sure to quote it so that the shell gives the rule to rsync as a single\n    argument.  The text below also mentions that you can use an underscore to\n    replace the space that separates a rule from its arg.\n\n    See the [FILTER RULES](#) section for detailed information on this option.\n\n0.  `-F`\n\n    The `-F` option is a shorthand for adding two [`--filter`](#opt) rules to\n    your command.  The first time it is used is a shorthand for this rule:\n\n    >     --filter='dir-merge /.rsync-filter'\n\n    This tells rsync to look for per-directory .rsync-filter files that have\n    been sprinkled through the hierarchy and use their rules to filter the\n    files in the transfer.  If `-F` is repeated, it is a shorthand for this\n    rule:\n\n    >     --filter='exclude .rsync-filter'\n\n    This filters out the .rsync-filter files themselves from the transfer.\n\n    See the [FILTER RULES](#) section for detailed information on how these\n    options work.\n\n0.  `--exclude=PATTERN`\n\n    This option is a simplified form of the [`--filter`](#opt) option that\n    specifies an exclude rule and does not allow the full rule-parsing syntax\n    of normal filter rules.  This is equivalent to specifying `-f'- PATTERN'`.\n\n    See the [FILTER RULES](#) section for detailed information on this option.\n\n0.  `--exclude-from=FILE`\n\n    This option is related to the [`--exclude`](#opt) option, but it specifies\n    a FILE that contains exclude patterns (one per line).  Blank lines in the\n    file are ignored, as are whole-line comments that start with '`;`' or '`#`'\n    (filename rules that contain those characters are unaffected).\n\n    If a line begins with \"`- `\" (dash, space) or \"`+ `\" (plus, space), then\n    the type of rule is being explicitly specified as an exclude or an include\n    (respectively).  Any rules without such a prefix are taken to be an exclude.\n\n    If a line consists of just \"`!`\", then the current filter rules are cleared\n    before adding any further rules.\n\n    If _FILE_ is '`-`', the list will be read from standard input.\n\n0.  `--include=PATTERN`\n\n    This option is a simplified form of the [`--filter`](#opt) option that\n    specifies an include rule and does not allow the full rule-parsing syntax\n    of normal filter rules.  This is equivalent to specifying `-f'+ PATTERN'`.\n\n    See the [FILTER RULES](#) section for detailed information on this option.\n\n0.  `--include-from=FILE`\n\n    This option is related to the [`--include`](#opt) option, but it specifies\n    a FILE that contains include patterns (one per line).  Blank lines in the\n    file are ignored, as are whole-line comments that start with '`;`' or '`#`'\n    (filename rules that contain those characters are unaffected).\n\n    If a line begins with \"`- `\" (dash, space) or \"`+ `\" (plus, space), then\n    the type of rule is being explicitly specified as an exclude or an include\n    (respectively).  Any rules without such a prefix are taken to be an include.\n\n    If a line consists of just \"`!`\", then the current filter rules are cleared\n    before adding any further rules.\n\n    If _FILE_ is '`-`', the list will be read from standard input.\n\n0.  `--files-from=FILE`\n\n    Using this option allows you to specify the exact list of files to transfer\n    (as read from the specified FILE or '`-`' for standard input).  It also\n    tweaks the default behavior of rsync to make transferring just the\n    specified files and directories easier:\n\n    - The [`--relative`](#opt) (`-R`) option is implied, which preserves the\n      path information that is specified for each item in the file (use\n      `--no-relative` or `--no-R` if you want to turn that off).\n    - The [`--dirs`](#opt) (`-d`) option is implied, which will create\n      directories specified in the list on the destination rather than noisily\n      skipping them (use `--no-dirs` or `--no-d` if you want to turn that off).\n    - The [`--archive`](#opt) (`-a`) option's behavior does not imply\n      [`--recursive`](#opt) (`-r`), so specify it explicitly, if you want it.\n    - These side-effects change the default state of rsync, so the position of\n      the `--files-from` option on the command-line has no bearing on how other\n      options are parsed (e.g. [`-a`](#opt) works the same before or after\n      `--files-from`, as does `--no-R` and all other options).\n\n    The filenames that are read from the FILE are all relative to the source\n    dir -- any leading slashes are removed and no \"..\" references are allowed\n    to go higher than the source dir.  For example, take this command:\n\n    >     rsync -a --files-from=/tmp/foo /usr remote:/backup\n\n    If /tmp/foo contains the string \"bin\" (or even \"/bin\"), the /usr/bin\n    directory will be created as /backup/bin on the remote host.  If it\n    contains \"bin/\" (note the trailing slash), the immediate contents of the\n    directory would also be sent (without needing to be explicitly mentioned in\n    the file -- this began in version 2.6.4).  In both cases, if the\n    [`-r`](#opt) option was enabled, that dir's entire hierarchy would also be\n    transferred (keep in mind that [`-r`](#opt) needs to be specified\n    explicitly with `--files-from`, since it is not implied by [`-a`](#opt).\n    Also note that the effect of the (enabled by default) [`-r`](#opt) option\n    is to duplicate only the path info that is read from the file -- it does\n    not force the duplication of the source-spec path (/usr in this case).\n\n    In addition, the `--files-from` file can be read from the remote host\n    instead of the local host if you specify a \"host:\" in front of the file\n    (the host must match one end of the transfer).  As a short-cut, you can\n    specify just a prefix of \":\" to mean \"use the remote end of the transfer\".\n    For example:\n\n    >     rsync -a --files-from=:/path/file-list src:/ /tmp/copy\n\n    This would copy all the files specified in the /path/file-list file that\n    was located on the remote \"src\" host.\n\n    If the [`--iconv`](#opt) and [`--secluded-args`](#opt) options are specified\n    and the `--files-from` filenames are being sent from one host to another,\n    the filenames will be translated from the sending host's charset to the\n    receiving host's charset.\n\n    NOTE: sorting the list of files in the `--files-from` input helps rsync to\n    be more efficient, as it will avoid re-visiting the path elements that are\n    shared between adjacent entries.  If the input is not sorted, some path\n    elements (implied directories) may end up being scanned multiple times, and\n    rsync will eventually unduplicate them after they get turned into file-list\n    elements.\n\n0.  `--from0`, `-0`\n\n    This tells rsync that the rules/filenames it reads from a file are\n    terminated by a null ('\\\\0') character, not a NL, CR, or CR+LF.  This\n    affects [`--exclude-from`](#opt), [`--include-from`](#opt),\n    [`--files-from`](#opt), and any merged files specified in a\n    [`--filter`](#opt) rule.  It does not affect [`--cvs-exclude`](#opt) (since\n    all names read from a .cvsignore file are split on whitespace).\n\n0. `--old-args`\n\n    This option tells rsync to stop trying to protect the arg values on the\n    remote side from unintended word-splitting or other misinterpretation.\n    It also allows the client to treat an empty arg as a \".\" instead of\n    generating an error.\n\n    The default in a modern rsync is for \"shell-active\" characters (including\n    spaces) to be backslash-escaped in the args that are sent to the remote\n    shell.  The wildcard characters `*`, `?`, `[`, & `]` are not escaped in\n    filename args (allowing them to expand into multiple filenames) while being\n    protected in option args, such as [`--usermap`](#opt).\n\n    If you have a script that wants to use old-style arg splitting in its\n    filenames, specify this option once.  If the remote shell has a problem\n    with any backslash escapes at all, specify this option twice.\n\n    You may also control this setting via the [`RSYNC_OLD_ARGS`](#) environment\n    variable.  If it has the value \"1\", rsync will default to a single-option\n    setting.  If it has the value \"2\" (or more), rsync will default to a\n    repeated-option setting.  If it is \"0\", you'll get the default escaping\n    behavior.  The environment is always overridden by manually specified\n    positive or negative options (the negative is `--no-old-args`).\n\n    Note that this option also disables the extra safety check added in 3.2.5\n    that ensures that a remote sender isn't including extra top-level items in\n    the file-list that you didn't request.  This side-effect is necessary\n    because we can't know for sure what names to expect when the remote shell\n    is interpreting the args.\n\n    This option conflicts with the [`--secluded-args`](#opt) option.\n\n0.  `--secluded-args`, `-s`\n\n    This option sends all filenames and most options to the remote rsync via\n    the protocol (not the remote shell command line) which avoids letting the\n    remote shell modify them.  Wildcards are expanded on the remote host by\n    rsync instead of a shell.\n\n    This is similar to the default backslash-escaping of args that was added\n    in 3.2.4 (see [`--old-args`](#opt)) in that it prevents things like space\n    splitting and unwanted special-character side-effects. However, it has the\n    drawbacks of being incompatible with older rsync versions (prior to 3.0.0)\n    and of being refused by restricted shells that want to be able to inspect\n    all the option values for safety.\n\n    This option is useful for those times that you need the argument's\n    character set to be converted for the remote host, if the remote shell is\n    incompatible with the default backslash-escpaing method, or there is some\n    other reason that you want the majority of the options and arguments to\n    bypass the command-line of the remote shell.\n\n    If you combine this option with [`--iconv`](#opt), the args related to the\n    remote side will be translated from the local to the remote character-set.\n    The translation happens before wild-cards are expanded.  See also the\n    [`--files-from`](#opt) option.\n\n    You may also control this setting via the [`RSYNC_PROTECT_ARGS`](#)\n    environment variable.  If it has a non-zero value, this setting will be\n    enabled by default, otherwise it will be disabled by default.  Either state\n    is overridden by a manually specified positive or negative version of this\n    option (note that `--no-s` and `--no-secluded-args` are the negative\n    versions).  This environment variable is also superseded by a non-zero\n    [`RSYNC_OLD_ARGS`](#) export.\n\n    This option conflicts with the [`--old-args`](#opt) option.\n\n    This option used to be called `--protect-args` (before 3.2.6) and that\n    older name can still be used (though specifying it as `-s` is always the\n    easiest and most compatible choice).\n\n0.  `--trust-sender`\n\n    This option disables two extra validation checks that a local client\n    performs on the file list generated by a remote sender.  This option should\n    only be used if you trust the sender to not put something malicious in the\n    file list (something that could possibly be done via a modified rsync, a\n    modified shell, or some other similar manipulation).\n\n    Normally, the rsync client (as of version 3.2.5) runs two extra validation\n    checks when pulling files from a remote rsync:\n\n    - It verifies that additional arg items didn't get added at the top of the\n      transfer.\n    - It verifies that none of the items in the file list are names that should\n      have been excluded (if filter rules were specified).\n\n    Note that various options can turn off one or both of these checks if the\n    option interferes with the validation.  For instance:\n\n    - Using a per-directory filter file reads filter rules that only the server\n      knows about, so the filter checking is disabled.\n    - Using the [`--old-args`](#opt) option allows the sender to manipulate the\n      requested args, so the arg checking is disabled.\n    - Reading the files-from list from the server side means that the client\n      doesn't know the arg list, so the arg checking is disabled.\n    - Using [`--read-batch`](#opt) disables both checks since the batch file's\n      contents will have been verified when it was created.\n\n    This option may help an under-powered client server if the extra pattern\n    matching is slowing things down on a huge transfer.  It can also be used to\n    work around a currently-unknown bug in the verification logic for a transfer\n    from a trusted sender.\n\n    When using this option it is a good idea to specify a dedicated destination\n    directory, as discussed in the [MULTI-HOST SECURITY](#) section.\n\n0.  `--copy-as=USER[:GROUP]`\n\n    This option instructs rsync to use the USER and (if specified after a\n    colon) the GROUP for the copy operations.  This only works if the user that\n    is running rsync has the ability to change users.  If the group is not\n    specified then the user's default groups are used.\n\n    This option can help to reduce the risk of an rsync being run as root into\n    or out of a directory that might have live changes happening to it and you\n    want to make sure that root-level read or write actions of system files are\n    not possible.  While you could alternatively run all of rsync as the\n    specified user, sometimes you need the root-level host-access credentials\n    to be used, so this allows rsync to drop root for the copying part of the\n    operation after the remote-shell or daemon connection is established.\n\n    The option only affects one side of the transfer unless the transfer is\n    local, in which case it affects both sides.  Use the\n    [`--remote-option`](#opt) to affect the remote side, such as\n    `-M--copy-as=joe`.  For a local transfer, the lsh (or lsh.sh) support file\n    provides a local-shell helper script that can be used to allow a\n    \"localhost:\" or \"lh:\" host-spec to be specified without needing to setup\n    any remote shells, allowing you to specify remote options that affect the\n    side of the transfer that is using the host-spec (and using hostname \"lh\"\n    avoids the overriding of the remote directory to the user's home dir).\n\n    For example, the following rsync writes the local files as user \"joe\":\n\n    >     sudo rsync -aiv --copy-as=joe host1:backups/joe/ /home/joe/\n\n    This makes all files owned by user \"joe\", limits the groups to those that\n    are available to that user, and makes it impossible for the joe user to do\n    a timed exploit of the path to induce a change to a file that the joe user\n    has no permissions to change.\n\n    The following command does a local copy into the \"dest/\" dir as user \"joe\"\n    (assuming you've installed support/lsh into a dir on your $PATH):\n\n    >     sudo rsync -aive lsh -M--copy-as=joe src/ lh:dest/\n\n0.  `--temp-dir=DIR`, `-T`\n\n    This option instructs rsync to use DIR as a scratch directory when creating\n    temporary copies of the files transferred on the receiving side.  The\n    default behavior is to create each temporary file in the same directory as\n    the associated destination file.  Beginning with rsync 3.1.1, the temp-file\n    names inside the specified DIR will not be prefixed with an extra dot\n    (though they will still have a random suffix added).\n\n    This option is most often used when the receiving disk partition does not\n    have enough free space to hold a copy of the largest file in the transfer.\n    In this case (i.e. when the scratch directory is on a different disk\n    partition), rsync will not be able to rename each received temporary file\n    over the top of the associated destination file, but instead must copy it\n    into place.  Rsync does this by copying the file over the top of the\n    destination file, which means that the destination file will contain\n    truncated data during this copy.  If this were not done this way (even if\n    the destination file were first removed, the data locally copied to a\n    temporary file in the destination directory, and then renamed into place)\n    it would be possible for the old file to continue taking up disk space (if\n    someone had it open), and thus there might not be enough room to fit the\n    new version on the disk at the same time.\n\n    If you are using this option for reasons other than a shortage of disk\n    space, you may wish to combine it with the [`--delay-updates`](#opt)\n    option, which will ensure that all copied files get put into subdirectories\n    in the destination hierarchy, awaiting the end of the transfer.  If you\n    don't have enough room to duplicate all the arriving files on the\n    destination partition, another way to tell rsync that you aren't overly\n    concerned about disk space is to use the [`--partial-dir`](#opt) option\n    with a relative path; because this tells rsync that it is OK to stash off a\n    copy of a single file in a subdir in the destination hierarchy, rsync will\n    use the partial-dir as a staging area to bring over the copied file, and\n    then rename it into place from there. (Specifying a [`--partial-dir`](#opt)\n    with an absolute path does not have this side-effect.)\n\n0.  `--fuzzy`, `-y`\n\n    This option tells rsync that it should look for a basis file for any\n    destination file that is missing.  The current algorithm looks in the same\n    directory as the destination file for either a file that has an identical\n    size and modified-time, or a similarly-named file.  If found, rsync uses\n    the fuzzy basis file to try to speed up the transfer.\n\n    If the option is repeated, the fuzzy scan will also be done in any matching\n    alternate destination directories that are specified via\n    [`--compare-dest`](#opt), [`--copy-dest`](#opt), or [`--link-dest`](#opt).\n\n    Note that the use of the [`--delete`](#opt) option might get rid of any\n    potential fuzzy-match files, so either use [`--delete-after`](#opt) or\n    specify some filename exclusions if you need to prevent this.\n\n0.  `--compare-dest=DIR`\n\n    This option instructs rsync to use _DIR_ on the destination machine as an\n    additional hierarchy to compare destination files against doing transfers\n    (if the files are missing in the destination directory).  If a file is\n    found in _DIR_ that is identical to the sender's file, the file will NOT be\n    transferred to the destination directory.  This is useful for creating a\n    sparse backup of just files that have changed from an earlier backup.  This\n    option is typically used to copy into an empty (or newly created)\n    directory.\n\n    Beginning in version 2.6.4, multiple `--compare-dest` directories may be\n    provided, which will cause rsync to search the list in the order specified\n    for an exact match.  If a match is found that differs only in attributes, a\n    local copy is made and the attributes updated.  If a match is not found, a\n    basis file from one of the _DIRs_ will be selected to try to speed up the\n    transfer.\n\n    If _DIR_ is a relative path, it is relative to the destination directory.\n    See also [`--copy-dest`](#opt) and [`--link-dest`](#opt).\n\n    NOTE: beginning with version 3.1.0, rsync will remove a file from a\n    non-empty destination hierarchy if an exact match is found in one of the\n    compare-dest hierarchies (making the end result more closely match a fresh\n    copy).\n\n0.  `--copy-dest=DIR`\n\n    This option behaves like [`--compare-dest`](#opt), but rsync will also copy\n    unchanged files found in _DIR_ to the destination directory using a local\n    copy.  This is useful for doing transfers to a new destination while\n    leaving existing files intact, and then doing a flash-cutover when all\n    files have been successfully transferred.\n\n    Multiple `--copy-dest` directories may be provided, which will cause rsync\n    to search the list in the order specified for an unchanged file.  If a\n    match is not found, a basis file from one of the _DIRs_ will be selected to\n    try to speed up the transfer.\n\n    If _DIR_ is a relative path, it is relative to the destination directory.\n    See also [`--compare-dest`](#opt) and [`--link-dest`](#opt).\n\n0.  `--link-dest=DIR`\n\n    This option behaves like [`--copy-dest`](#opt), but unchanged files are\n    hard linked from _DIR_ to the destination directory.  The files must be\n    identical in all preserved attributes (e.g. permissions, possibly\n    ownership) in order for the files to be linked together.  An example:\n\n    >     rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/\n\n    If files aren't linking, double-check their attributes.  Also check if\n    some attributes are getting forced outside of rsync's control, such a mount\n    option that squishes root to a single user, or mounts a removable drive\n    with generic ownership (such as OS X's \"Ignore ownership on this volume\"\n    option).\n\n    Beginning in version 2.6.4, multiple `--link-dest` directories may be\n    provided, which will cause rsync to search the list in the order specified\n    for an exact match (there is a limit of 20 such directories).  If a match\n    is found that differs only in attributes, a local copy is made and the\n    attributes updated.  If a match is not found, a basis file from one of the\n    _DIRs_ will be selected to try to speed up the transfer.\n\n    This option works best when copying into an empty destination hierarchy, as\n    existing files may get their attributes tweaked, and that can affect\n    alternate destination files via hard-links.  Also, itemizing of changes can\n    get a bit muddled.  Note that prior to version 3.1.0, an\n    alternate-directory exact match would never be found (nor linked into the\n    destination) when a destination file already exists.\n\n    Note that if you combine this option with [`--ignore-times`](#opt), rsync will not\n    link any files together because it only links identical files together as a\n    substitute for transferring the file, never as an additional check after\n    the file is updated.\n\n    If _DIR_ is a relative path, it is relative to the destination directory.\n    See also [`--compare-dest`](#opt) and [`--copy-dest`](#opt).\n\n    Note that rsync versions prior to 2.6.1 had a bug that could prevent\n    `--link-dest` from working properly for a non-super-user when\n    [`--owner`](#opt) (`-o`) was specified (or implied).  You can work-around\n    this bug by avoiding the `-o` option (or using `--no-o`) when sending to an\n    old rsync.\n\n0.  `--compress`, `-z`\n\n    With this option, rsync compresses the file data as it is sent to the\n    destination machine, which reduces the amount of data being transmitted --\n    something that is useful over a slow connection.\n\n    Rsync supports multiple compression methods and will choose one for you\n    unless you force the choice using the [`--compress-choice`](#opt) (`--zc`)\n    option.\n\n    Run `rsync --version` to see the default compress list compiled into your\n    version.\n\n    When both sides of the transfer are at least 3.2.0, rsync chooses the first\n    algorithm in the client's list of choices that is also in the server's list\n    of choices.  If no common compress choice is found, rsync exits with\n    an error.  If the remote rsync is too old to support checksum negotiation,\n    its list is assumed to be \"zlib\".\n\n    The default order can be customized by setting the environment variable\n    [`RSYNC_COMPRESS_LIST`](#) to a space-separated list of acceptable\n    compression names.  If the string contains a \"`&`\" character, it is\n    separated into the \"client string & server string\", otherwise the same\n    string applies to both.  If the string (or string portion) contains no\n    non-whitespace characters, the default compress list is used.  Any unknown\n    compression names are discarded from the list, but a list with only invalid\n    names results in a failed negotiation.\n\n    There are some older rsync versions that were configured to reject a `-z`\n    option and require the use of `-zz` because their compression library was\n    not compatible with the default zlib compression method.  You can usually\n    ignore this weirdness unless the rsync server complains and tells you to\n    specify `-zz`.\n\n0.  `--compress-choice=STR`, `--zc=STR`\n\n    This option can be used to override the automatic negotiation of the\n    compression algorithm that occurs when [`--compress`](#opt) is used.  The\n    option implies [`--compress`](#opt) unless \"none\" was specified, which\n    instead implies `--no-compress`.\n\n    The compression options that you may be able to use are:\n\n    - `zstd`\n    - `lz4`\n    - `zlibx`\n    - `zlib`\n    - `none`\n\n    Run `rsync --version` to see the default compress list compiled into your\n    version (which may differ from the list above).\n\n    Note that if you see an error about an option named `--old-compress` or\n    `--new-compress`, this is rsync trying to send the `--compress-choice=zlib`\n    or `--compress-choice=zlibx` option in a backward-compatible manner that\n    more rsync versions understand.  This error indicates that the older rsync\n    version on the server will not allow you to force the compression type.\n\n    Note that the \"zlibx\" compression algorithm is just the \"zlib\" algorithm\n    with matched data excluded from the compression stream (to try to make it\n    more compatible with an external zlib implementation).\n\n0.  `--compress-level=NUM`, `--zl=NUM`\n\n    Explicitly set the compression level to use (see [`--compress`](#opt),\n    `-z`) instead of letting it default.  The [`--compress`](#opt) option is\n    implied as long as the level chosen is not a \"don't compress\" level for the\n    compression algorithm that is in effect (e.g. zlib compression treats level\n    0 as \"off\").\n\n    The level values vary depending on the checksum in effect.  Because rsync\n    will negotiate a checksum choice by default (when the remote rsync is new\n    enough), it can be good to combine this option with a\n    [`--compress-choice`](#opt) (`--zc`) option unless you're sure of the\n    choice in effect.  For example:\n\n    >     rsync -aiv --zc=zstd --zl=22 host:src/ dest/\n\n    For zlib & zlibx compression the valid values are from 1 to 9 with 6 being\n    the default.  Specifying `--zl=0` turns compression off, and specifying\n    `--zl=-1` chooses the default level of 6.\n\n    For zstd compression the valid values are from -131072 to 22 with 3 being\n    the default. Specifying 0 chooses the default of 3.\n\n    For lz4 compression there are no levels, so the value is always 0.\n\n    If you specify a too-large or too-small value, the number is silently\n    limited to a valid value.  This allows you to specify something like\n    `--zl=999999999` and be assured that you'll end up with the maximum\n    compression level no matter what algorithm was chosen.\n\n    If you want to know the compression level that is in effect, specify\n    [`--debug=nstr`](#opt) to see the \"negotiated string\" results.  This will\n    report something like \"`Client compress: zstd (level 3)`\" (along with the\n    checksum choice in effect).\n\n0.  `--skip-compress=LIST`\n\n    **NOTE:** no compression method currently supports per-file compression\n    changes, so this option has no effect.\n\n    Override the list of file suffixes that will be compressed as little as\n    possible.  Rsync sets the compression level on a per-file basis based on\n    the file's suffix.  If the compression algorithm has an \"off\" level, then\n    no compression occurs for those files.  Other algorithms that support\n    changing the streaming level on-the-fly will have the level minimized to\n    reduces the CPU usage as much as possible for a matching file.\n\n    The **LIST** should be one or more file suffixes (without the dot) separated\n    by slashes (`/`).  You may specify an empty string to indicate that no files\n    should be skipped.\n\n    Simple character-class matching is supported: each must consist of a list\n    of letters inside the square brackets (e.g. no special classes, such as\n    \"[:alpha:]\", are supported, and '-' has no special meaning).\n\n    The characters asterisk (`*`) and question-mark (`?`) have no special meaning.\n\n    Here's an example that specifies 6 suffixes to skip (since 1 of the 5 rules\n    matches 2 suffixes):\n\n    >     --skip-compress=gz/jpg/mp[34]/7z/bz2\n\n    The default file suffixes in the skip-compress list in this version of\n    rsync are:\n\n    [comment]: # (This list gets used for the default-dont-compress.h file.)\n\n    > 3g2\n    > 3gp\n    > 7z\n    > aac\n    > ace\n    > apk\n    > avi\n    > bz2\n    > deb\n    > dmg\n    > ear\n    > f4v\n    > flac\n    > flv\n    > gpg\n    > gz\n    > iso\n    > jar\n    > jpeg\n    > jpg\n    > lrz\n    > lz\n    > lz4\n    > lzma\n    > lzo\n    > m1a\n    > m1v\n    > m2a\n    > m2ts\n    > m2v\n    > m4a\n    > m4b\n    > m4p\n    > m4r\n    > m4v\n    > mka\n    > mkv\n    > mov\n    > mp1\n    > mp2\n    > mp3\n    > mp4\n    > mpa\n    > mpeg\n    > mpg\n    > mpv\n    > mts\n    > odb\n    > odf\n    > odg\n    > odi\n    > odm\n    > odp\n    > ods\n    > odt\n    > oga\n    > ogg\n    > ogm\n    > ogv\n    > ogx\n    > opus\n    > otg\n    > oth\n    > otp\n    > ots\n    > ott\n    > oxt\n    > png\n    > qt\n    > rar\n    > rpm\n    > rz\n    > rzip\n    > spx\n    > squashfs\n    > sxc\n    > sxd\n    > sxg\n    > sxm\n    > sxw\n    > sz\n    > tbz\n    > tbz2\n    > tgz\n    > tlz\n    > ts\n    > txz\n    > tzo\n    > vob\n    > war\n    > webm\n    > webp\n    > xz\n    > z\n    > zip\n    > zst\n\n    This list will be replaced by your `--skip-compress` list in all but one\n    situation: a copy from a daemon rsync will add your skipped suffixes to its\n    list of non-compressing files (and its list may be configured to a\n    different default).\n\n0.  `--numeric-ids`\n\n    With this option rsync will transfer numeric group and user IDs rather than\n    using user and group names and mapping them at both ends.\n\n    By default rsync will use the username and groupname to determine what\n    ownership to give files.  The special uid 0 and the special group 0 are\n    never mapped via user/group names even if the `--numeric-ids` option is not\n    specified.\n\n    If a user or group has no name on the source system or it has no match on\n    the destination system, then the numeric ID from the source system is used\n    instead.  See also the [`use chroot`](rsyncd.conf.5#use_chroot) setting\n    in the rsyncd.conf manpage for some comments on how the chroot setting\n    affects rsync's ability to look up the names of the users and groups and\n    what you can do about it.\n\n0.  `--usermap=STRING`, `--groupmap=STRING`\n\n    These options allow you to specify users and groups that should be mapped\n    to other values by the receiving side.  The **STRING** is one or more\n    **FROM**:**TO** pairs of values separated by commas.  Any matching **FROM**\n    value from the sender is replaced with a **TO** value from the receiver.\n    You may specify usernames or user IDs for the **FROM** and **TO** values,\n    and the **FROM** value may also be a wild-card string, which will be\n    matched against the sender's names (wild-cards do NOT match against ID\n    numbers, though see below for why a '`*`' matches everything).  You may\n    instead specify a range of ID numbers via an inclusive range: LOW-HIGH.\n    For example:\n\n    >     --usermap=0-99:nobody,wayne:admin,*:normal --groupmap=usr:1,1:usr\n\n    The first match in the list is the one that is used.  You should specify\n    all your user mappings using a single `--usermap` option, and/or all your\n    group mappings using a single `--groupmap` option.\n\n    Note that the sender's name for the 0 user and group are not transmitted to\n    the receiver, so you should either match these values using a 0, or use the\n    names in effect on the receiving side (typically \"root\").  All other\n    **FROM** names match those in use on the sending side.  All **TO** names\n    match those in use on the receiving side.\n\n    Any IDs that do not have a name on the sending side are treated as having\n    an empty name for the purpose of matching.  This allows them to be matched\n    via a \"`*`\" or using an empty name.  For instance:\n\n    >     --usermap=:nobody --groupmap=*:nobody\n\n    When the [`--numeric-ids`](#opt) option is used, the sender does not send any\n    names, so all the IDs are treated as having an empty name.  This means that\n    you will need to specify numeric **FROM** values if you want to map these\n    nameless IDs to different values.\n\n    For the `--usermap` option to work, the receiver will need to be running as\n    a super-user (see also the [`--super`](#opt) and [`--fake-super`](#opt)\n    options).  For the `--groupmap` option to work, the receiver will need to\n    have permissions to set that group.\n\n    Starting with rsync 3.2.4, the `--usermap` option implies the\n    [`--owner`](#opt) (`-o`) option while the `--groupmap` option implies the\n    [`--group`](#opt) (`-g`) option (since rsync needs to have those options\n    enabled for the mapping options to work).\n\n    An older rsync client may need to use [`-s`](#opt) to avoid a complaint\n    about wildcard characters, but a modern rsync handles this automatically.\n\n0.  `--chown=USER:GROUP`\n\n    This option forces all files to be owned by USER with group GROUP.  This is\n    a simpler interface than using [`--usermap`](#opt) & [`--groupmap`](#opt)\n    directly, but it is implemented using those options internally so they\n    cannot be mixed.  If either the USER or GROUP is empty, no mapping for the\n    omitted user/group will occur.  If GROUP is empty, the trailing colon may\n    be omitted, but if USER is empty, a leading colon must be supplied.\n\n    If you specify \"`--chown=foo:bar`\", this is exactly the same as specifying\n    \"`--usermap=*:foo --groupmap=*:bar`\", only easier (and with the same\n    implied [`--owner`](#opt) and/or [`--group`](#opt) options).\n\n    An older rsync client may need to use [`-s`](#opt) to avoid a complaint\n    about wildcard characters, but a modern rsync handles this automatically.\n\n0.  `--timeout=SECONDS`\n\n    This option allows you to set a maximum I/O timeout in seconds.  If no data\n    is transferred for the specified time then rsync will exit.  The default is\n    0, which means no timeout.\n\n0.  `--contimeout=SECONDS`\n\n    This option allows you to set the amount of time that rsync will wait for\n    its connection to an rsync daemon to succeed.  If the timeout is reached,\n    rsync exits with an error.\n\n0.  `--address=ADDRESS`\n\n    By default rsync will bind to the wildcard address when connecting to an\n    rsync daemon.  The `--address` option allows you to specify a specific IP\n    address (or hostname) to bind to.\n\n    See also [the daemon version of the `--address` option](#dopt--address).\n\n0.  `--port=PORT`\n\n    This specifies an alternate TCP port number to use rather than the default\n    of 873.  This is only needed if you are using the double-colon (::) syntax\n    to connect with an rsync daemon (since the URL syntax has a way to specify\n    the port as a part of the URL).\n\n    See also [the daemon version of the `--port` option](#dopt--port).\n\n0.  `--sockopts=OPTIONS`\n\n    This option can provide endless fun for people who like to tune their\n    systems to the utmost degree.  You can set all sorts of socket options\n    which may make transfers faster (or slower!).  Read the manpage for the\n    `setsockopt()` system call for details on some of the options you may be\n    able to set.  By default no special socket options are set.  This only\n    affects direct socket connections to a remote rsync daemon.\n\n    See also [the daemon version of the `--sockopts` option](#dopt--sockopts).\n\n0.  `--blocking-io`\n\n    This tells rsync to use blocking I/O when launching a remote shell\n    transport.  If the remote shell is either rsh or remsh, rsync defaults to\n    using blocking I/O, otherwise it defaults to using non-blocking I/O. (Note\n    that ssh prefers non-blocking I/O.)\n\n0.  `--outbuf=MODE`\n\n    This sets the output buffering mode.  The mode can be None (aka\n    Unbuffered), Line, or Block (aka Full).  You may specify as little as a\n    single letter for the mode, and use upper or lower case.\n\n    The main use of this option is to change Full buffering to Line buffering\n    when rsync's output is going to a file or pipe.\n\n0.  `--itemize-changes`, `-i`\n\n    Requests a simple itemized list of the changes that are being made to each\n    file, including attribute changes.  This is exactly the same as specifying\n    [`--out-format='%i %n%L'`](#opt).  If you repeat the option, unchanged\n    files will also be output, but only if the receiving rsync is at least\n    version 2.6.7 (you can use `-vv` with older versions of rsync, but that\n    also turns on the output of other verbose messages).\n\n    The \"%i\" escape has a cryptic output that is 11 letters long.  The general\n    format is like the string `YXcstpoguax`, where **Y** is replaced by the type\n    of update being done, **X** is replaced by the file-type, and the other\n    letters represent attributes that may be output if they are being modified.\n\n    The update types that replace the **Y** are as follows:\n\n    - A `<` means that a file is being transferred to the remote host (sent).\n    - A `>` means that a file is being transferred to the local host\n      (received).\n    - A `c` means that a local change/creation is occurring for the item (such\n      as the creation of a directory or the changing of a symlink, etc.).\n    - A `h` means that the item is a hard link to another item (requires\n      [`--hard-links`](#opt)).\n    - A `.` means that the item is not being updated (though it might have\n      attributes that are being modified).\n    - A `*` means that the rest of the itemized-output area contains a message\n      (e.g. \"deleting\").\n\n    The file-types that replace the **X** are: `f` for a file, a `d` for a\n    directory, an `L` for a symlink, a `D` for a device, and a `S` for a\n    special file (e.g. named sockets and fifos).\n\n    The other letters in the string indicate if some attributes of the file\n    have changed, as follows:\n\n    - \"`.`\" - the attribute is unchanged.\n    - \"`+`\" - the file is newly created.\n    - \"` `\" - all the attributes are unchanged (all dots turn to spaces).\n    - \"`?`\" - the change is unknown (when the remote rsync is old).\n    - A letter indicates an attribute is being updated.\n\n    The attribute that is associated with each letter is as follows:\n\n    - A `c` means either that a regular file has a different checksum (requires\n      [`--checksum`](#opt)) or that a symlink, device, or special file has a\n      changed value.  Note that if you are sending files to an rsync prior to\n      3.0.1, this change flag will be present only for checksum-differing\n      regular files.\n    - A `s` means the size of a regular file is different and will be updated\n      by the file transfer.\n    - A `t` means the modification time is different and is being updated to\n      the sender's value (requires [`--times`](#opt)).  An alternate value of\n      `T` means that the modification time will be set to the transfer time,\n      which happens when a file/symlink/device is updated without\n      [`--times`](#opt) and when a symlink is changed and the receiver can't\n      set its time. (Note: when using an rsync 3.0.0 client, you might see the\n      `s` flag combined with `t` instead of the proper `T` flag for this\n      time-setting failure.)\n    - A `p` means the permissions are different and are being updated to the\n      sender's value (requires [`--perms`](#opt)).\n    - An `o` means the owner is different and is being updated to the sender's\n      value (requires [`--owner`](#opt) and super-user privileges).\n    - A `g` means the group is different and is being updated to the sender's\n      value (requires [`--group`](#opt) and the authority to set the group).\n    - A `u`|`n`|`b` indicates the following information:\n      - `u`  means the access (use) time is different and is being updated to\n\tthe sender's value (requires [`--atimes`](#opt))\n      - `n` means the create time (newness) is different and is being updated\n\tto the sender's value (requires [`--crtimes`](#opt))\n      - `b` means that both the access and create times are being updated\n    - The `a` means that the ACL information is being changed.\n    - The `x` means that the extended attribute information is being changed.\n\n    One other output is possible: when deleting files, the \"%i\" will output the\n    string \"`*deleting`\" for each item that is being removed (assuming that you\n    are talking to a recent enough rsync that it logs deletions instead of\n    outputting them as a verbose message).\n\n0.  `--out-format=FORMAT`\n\n    This allows you to specify exactly what the rsync client outputs to the\n    user on a per-update basis.  The format is a text string containing\n    embedded single-character escape sequences prefixed with a percent (%)\n    character.  A default format of \"%n%L\" is assumed if either\n    [`--info=name`](#opt) or [`-v`](#opt) is specified (this tells you just the\n    name of the file and, if the item is a link, where it points).  For a full\n    list of the possible escape characters, see the [`log\n    format`](rsyncd.conf.5#log_format) setting in the rsyncd.conf manpage.\n\n    Specifying the `--out-format` option implies the [`--info=name`](#opt)\n    option, which will mention each file, dir, etc. that gets updated in a\n    significant way (a transferred file, a recreated symlink/device, or a\n    touched directory).  In addition, if the itemize-changes escape (%i) is\n    included in the string (e.g. if the [`--itemize-changes`](#opt) option was\n    used), the logging of names increases to mention any item that is changed\n    in any way (as long as the receiving side is at least 2.6.4).  See the\n    [`--itemize-changes`](#opt) option for a description of the output of \"%i\".\n\n    Rsync will output the out-format string prior to a file's transfer unless\n    one of the transfer-statistic escapes is requested, in which case the\n    logging is done at the end of the file's transfer.  When this late logging\n    is in effect and [`--progress`](#opt) is also specified, rsync will also\n    output the name of the file being transferred prior to its progress\n    information (followed, of course, by the out-format output).\n\n0.  `--log-file=FILE`\n\n    This option causes rsync to log what it is doing to a file.  This is\n    similar to the logging that a daemon does, but can be requested for the\n    client side and/or the server side of a non-daemon transfer.  If specified\n    as a client option, transfer logging will be enabled with a default format\n    of \"%i %n%L\".  See the [`--log-file-format`](#opt) option if you wish to\n    override this.\n\n    Here's an example command that requests the remote side to log what is\n    happening:\n\n    >     rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/\n\n    This is very useful if you need to debug why a connection is closing\n    unexpectedly.\n\n    See also [the daemon version of the `--log-file` option](#dopt--log-file).\n\n0.  `--log-file-format=FORMAT`\n\n    This allows you to specify exactly what per-update logging is put into the\n    file specified by the [`--log-file`](#opt) option (which must also be\n    specified for this option to have any effect).  If you specify an empty\n    string, updated files will not be mentioned in the log file.  For a list of\n    the possible escape characters, see the [`log format`](rsyncd.conf.5#log_format)\n    setting in the rsyncd.conf manpage.\n\n    The default FORMAT used if [`--log-file`](#opt) is specified and this\n    option is not is '%i %n%L'.\n\n    See also [the daemon version of the `--log-file-format`\n    option](#dopt--log-file-format).\n\n0.  `--stats`\n\n    This tells rsync to print a verbose set of statistics on the file transfer,\n    allowing you to tell how effective rsync's delta-transfer algorithm is for\n    your data.  This option is equivalent to [`--info=stats2`](#opt) if\n    combined with 0 or 1 [`-v`](#opt) options, or [`--info=stats3`](#opt) if\n    combined with 2 or more [`-v`](#opt) options.\n\n    The current statistics are as follows:\n\n    - `Number of files` is the count of all \"files\" (in the generic sense),\n      which includes directories, symlinks, etc.  The total count will be\n      followed by a list of counts by filetype (if the total is non-zero).  For\n      example: \"(reg: 5, dir: 3, link: 2, dev: 1, special: 1)\" lists the totals\n      for regular files, directories, symlinks, devices, and special files.  If\n      any of value is 0, it is completely omitted from the list.\n    - `Number of created files` is the count of how many \"files\" (generic\n      sense) were created (as opposed to updated).  The total count will be\n      followed by a list of counts by filetype (if the total is non-zero).\n    - `Number of deleted files` is the count of how many \"files\" (generic\n      sense) were deleted.  The total count will be\n      followed by a list of counts by filetype (if the total is non-zero).\n      Note that this line is only output if deletions are in effect, and only\n      if protocol 31 is being used (the default for rsync 3.1.x).\n    - `Number of regular files transferred` is the count of normal files that\n      were updated via rsync's delta-transfer algorithm, which does not include\n      dirs, symlinks, etc.  Note that rsync 3.1.0 added the word \"regular\" into\n      this heading.\n    - `Total file size` is the total sum of all file sizes in the transfer.\n      This does not count any size for directories or special files, but does\n      include the size of symlinks.\n    - `Total transferred file size` is the total sum of all files sizes for\n      just the transferred files.\n    - `Literal data` is how much unmatched file-update data we had to send to\n      the receiver for it to recreate the updated files.\n    - `Matched data` is how much data the receiver got locally when recreating\n      the updated files.\n    - `File list size` is how big the file-list data was when the sender sent\n      it to the receiver.  This is smaller than the in-memory size for the file\n      list due to some compressing of duplicated data when rsync sends the\n      list.\n    - `File list generation time` is the number of seconds that the sender\n      spent creating the file list.  This requires a modern rsync on the\n      sending side for this to be present.\n    - `File list transfer time` is the number of seconds that the sender spent\n      sending the file list to the receiver.\n    - `Total bytes sent` is the count of all the bytes that rsync sent from the\n      client side to the server side.\n    - `Total bytes received` is the count of all non-message bytes that rsync\n      received by the client side from the server side. \"Non-message\" bytes\n      means that we don't count the bytes for a verbose message that the server\n      sent to us, which makes the stats more consistent.\n\n0.  `--8-bit-output`, `-8`\n\n    This tells rsync to leave all high-bit characters unescaped in the output\n    instead of trying to test them to see if they're valid in the current\n    locale and escaping the invalid ones.  All control characters (but never\n    tabs) are always escaped, regardless of this option's setting.\n\n    The escape idiom that started in 2.6.7 is to output a literal backslash\n    (`\\`) and a hash (`#`), followed by exactly 3 octal digits.  For example, a\n    newline would output as \"`\\#012`\".  A literal backslash that is in a\n    filename is not escaped unless it is followed by a hash and 3 digits (0-9).\n\n0.  `--human-readable`, `-h`\n\n    Output numbers in a more human-readable format.  There are 3 possible levels:\n\n    1. output numbers with a separator between each set of 3 digits (either a\n       comma or a period, depending on if the decimal point is represented by a\n       period or a comma).\n    2. output numbers in units of 1000 (with a character suffix for larger\n       units -- see below).\n    3. output numbers in units of 1024.\n\n    The default is human-readable level 1.  Each `-h` option increases the\n    level by one.  You can take the level down to 0 (to output numbers as pure\n    digits) by specifying the `--no-human-readable` (`--no-h`) option.\n\n    The unit letters that are appended in levels 2 and 3 are: `K` (kilo), `M`\n    (mega), `G` (giga), `T` (tera), or `P` (peta).  For example, a 1234567-byte\n    file would output as 1.23M in level-2 (assuming that a period is your local\n    decimal point).\n\n    Backward compatibility note: versions of rsync prior to 3.1.0 do not\n    support human-readable level 1, and they default to level 0.  Thus,\n    specifying one or two `-h` options will behave in a comparable manner in\n    old and new versions as long as you didn't specify a `--no-h` option prior\n    to one or more `-h` options.  See the [`--list-only`](#opt) option for one\n    difference.\n\n0.  `--partial`\n\n    By default, rsync will delete any partially transferred file if the\n    transfer is interrupted.  In some circumstances it is more desirable to\n    keep partially transferred files.  Using the `--partial` option tells rsync\n    to keep the partial file which should make a subsequent transfer of the\n    rest of the file much faster.\n\n0.  `--partial-dir=DIR`\n\n    This option modifies the behavior of the [`--partial`](#opt) option while\n    also implying that it be enabled.  This enhanced partial-file method puts\n    any partially transferred files into the specified _DIR_ instead of writing\n    the partial file out to the destination file.  On the next transfer, rsync\n    will use a file found in this dir as data to speed up the resumption of the\n    transfer and then delete it after it has served its purpose.\n\n    Note that if [`--whole-file`](#opt) is specified (or implied), any\n    partial-dir files that are found for a file that is being updated will\n    simply be removed (since rsync is sending files without using rsync's\n    delta-transfer algorithm).\n\n    Rsync will create the _DIR_ if it is missing, but just the last dir -- not\n    the whole path.  This makes it easy to use a relative path (such as\n    \"`--partial-dir=.rsync-partial`\") to have rsync create the\n    partial-directory in the destination file's directory when it is needed,\n    and then remove it again when the partial file is deleted.  Note that this\n    directory removal is only done for a relative pathname, as it is expected\n    that an absolute path is to a directory that is reserved for partial-dir\n    work.\n\n    If the partial-dir value is not an absolute path, rsync will add an exclude\n    rule at the end of all your existing excludes.  This will prevent the\n    sending of any partial-dir files that may exist on the sending side, and\n    will also prevent the untimely deletion of partial-dir items on the\n    receiving side.  An example: the above `--partial-dir` option would add the\n    equivalent of this \"perishable\" exclude at the end of any other filter\n    rules: `-f '-p .rsync-partial/'`\n\n    If you are supplying your own exclude rules, you may need to add your own\n    exclude/hide/protect rule for the partial-dir because:\n\n    1. the auto-added rule may be ineffective at the end of your other rules, or\n    2. you may wish to override rsync's exclude choice.\n\n    For instance, if you want to make rsync clean-up any left-over partial-dirs\n    that may be lying around, you should specify [`--delete-after`](#opt) and\n    add a \"risk\" filter rule, e.g.  `-f 'R .rsync-partial/'`. Avoid using\n    [`--delete-before`](#opt) or [`--delete-during`](#opt) unless you don't\n    need rsync to use any of the left-over partial-dir data during the current\n    run.\n\n    IMPORTANT: the `--partial-dir` should not be writable by other users or it\n    is a security risk!  E.g. AVOID \"/tmp\"!\n\n    You can also set the partial-dir value the [`RSYNC_PARTIAL_DIR`](#)\n    environment variable.  Setting this in the environment does not force\n    [`--partial`](#opt) to be enabled, but rather it affects where partial\n    files go when [`--partial`](#opt) is specified.  For instance, instead of\n    using `--partial-dir=.rsync-tmp` along with [`--progress`](#opt), you could\n    set [`RSYNC_PARTIAL_DIR=.rsync-tmp`](#) in your environment and then use\n    the [`-P`](#opt) option to turn on the use of the .rsync-tmp dir for\n    partial transfers.  The only times that the [`--partial`](#opt) option does\n    not look for this environment value are:\n\n    1. when [`--inplace`](#opt) was specified (since [`--inplace`](#opt)\n       conflicts with `--partial-dir`), and\n    2. when [`--delay-updates`](#opt) was specified (see below).\n\n    When a modern rsync resumes the transfer of a file in the partial-dir, that\n    partial file is now updated in-place instead of creating yet another\n    tmp-file copy (so it maxes out at dest + tmp instead of dest + partial +\n    tmp).  This requires both ends of the transfer to be at least version\n    3.2.0.\n\n    For the purposes of the daemon-config's \"`refuse options`\" setting,\n    `--partial-dir` does _not_ imply [`--partial`](#opt).  This is so that a\n    refusal of the [`--partial`](#opt) option can be used to disallow the\n    overwriting of destination files with a partial transfer, while still\n    allowing the safer idiom provided by `--partial-dir`.\n\n0.  `--delay-updates`\n\n    This option puts the temporary file from each updated file into a holding\n    directory until the end of the transfer, at which time all the files are\n    renamed into place in rapid succession.  This attempts to make the updating\n    of the files a little more atomic.  By default the files are placed into a\n    directory named `.~tmp~` in each file's destination directory, but if\n    you've specified the [`--partial-dir`](#opt) option, that directory will be\n    used instead.  See the comments in the [`--partial-dir`](#opt) section for\n    a discussion of how this `.~tmp~` dir will be excluded from the transfer,\n    and what you can do if you want rsync to cleanup old `.~tmp~` dirs that\n    might be lying around.  Conflicts with [`--inplace`](#opt) and\n    [`--append`](#opt).\n\n    This option implies [`--no-inc-recursive`](#opt) since it needs the full\n    file list in memory in order to be able to iterate over it at the end.\n\n    This option uses more memory on the receiving side (one bit per file\n    transferred) and also requires enough free disk space on the receiving side\n    to hold an additional copy of all the updated files.  Note also that you\n    should not use an absolute path to [`--partial-dir`](#opt) unless:\n\n    1. there is no chance of any of the files in the transfer having the same\n       name (since all the updated files will be put into a single directory if\n       the path is absolute), and\n    2. there are no mount points in the hierarchy (since the delayed updates\n       will fail if they can't be renamed into place).\n\n    See also the \"atomic-rsync\" python script in the \"support\" subdir for an\n    update algorithm that is even more atomic (it uses [`--link-dest`](#opt)\n    and a parallel hierarchy of files).\n\n0.  `--prune-empty-dirs`, `-m`\n\n    This option tells the receiving rsync to get rid of empty directories from\n    the file-list, including nested directories that have no non-directory\n    children.  This is useful for avoiding the creation of a bunch of useless\n    directories when the sending rsync is recursively scanning a hierarchy of\n    files using include/exclude/filter rules.\n\n    This option can still leave empty directories on the receiving side if you\n    make use of [TRANSFER_RULES](#).\n\n    Because the file-list is actually being pruned, this option also affects\n    what directories get deleted when a delete is active.  However, keep in\n    mind that excluded files and directories can prevent existing items from\n    being deleted due to an exclude both hiding source files and protecting\n    destination files.  See the perishable filter-rule option for how to avoid\n    this.\n\n    You can prevent the pruning of certain empty directories from the file-list\n    by using a global \"protect\" filter.  For instance, this option would ensure\n    that the directory \"emptydir\" was kept in the file-list:\n\n    >     --filter 'protect emptydir/'\n\n    Here's an example that copies all .pdf files in a hierarchy, only creating\n    the necessary destination directories to hold the .pdf files, and ensures\n    that any superfluous files and directories in the destination are removed\n    (note the hide filter of non-directories being used instead of an exclude):\n\n    >     rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest\n\n    If you didn't want to remove superfluous destination files, the more\n    time-honored options of `--include='*/' --exclude='*'` would work\n    fine in place of the hide-filter (if that is more natural to you).\n\n0.  `--progress`\n\n    This option tells rsync to print information showing the progress of the\n    transfer.  This gives a bored user something to watch.  With a modern rsync\n    this is the same as specifying [`--info=flist2,name,progress`](#opt), but\n    any user-supplied settings for those info flags takes precedence (e.g.\n    [`--info=flist0 --progress`](#opt)).\n\n    While rsync is transferring a regular file, it updates a progress line that\n    looks like this:\n\n    >     782448  63%  110.64kB/s    0:00:04\n\n    In this example, the receiver has reconstructed 782448 bytes or 63% of the\n    sender's file, which is being reconstructed at a rate of 110.64 kilobytes\n    per second, and the transfer will finish in 4 seconds if the current rate\n    is maintained until the end.\n\n    These statistics can be misleading if rsync's delta-transfer algorithm is\n    in use.  For example, if the sender's file consists of the basis file\n    followed by additional data, the reported rate will probably drop\n    dramatically when the receiver gets to the literal data, and the transfer\n    will probably take much longer to finish than the receiver estimated as it\n    was finishing the matched part of the file.\n\n    When the file transfer finishes, rsync replaces the progress line with a\n    summary line that looks like this:\n\n    >     1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396)\n\n    In this example, the file was 1,238,099 bytes long in total, the average\n    rate of transfer for the whole file was 146.38 kilobytes per second over\n    the 8 seconds that it took to complete, it was the 5th transfer of a\n    regular file during the current rsync session, and there are 169 more files\n    for the receiver to check (to see if they are up-to-date or not) remaining\n    out of the 396 total files in the file-list.\n\n    In an incremental recursion scan, rsync won't know the total number of\n    files in the file-list until it reaches the ends of the scan, but since it\n    starts to transfer files during the scan, it will display a line with the\n    text \"ir-chk\" (for incremental recursion check) instead of \"to-chk\" until\n    the point that it knows the full size of the list, at which point it will\n    switch to using \"to-chk\".  Thus, seeing \"ir-chk\" lets you know that the\n    total count of files in the file list is still going to increase (and each\n    time it does, the count of files left to check will increase by the number\n    of the files added to the list).\n\n0.  `-P`\n\n    The `-P` option is equivalent to \"[`--partial`](#opt)\n    [`--progress`](#opt)\".  Its purpose is to make it much easier to specify\n    these two options for a long transfer that may be interrupted.\n\n    There is also a [`--info=progress2`](#opt) option that outputs statistics\n    based on the whole transfer, rather than individual files.  Use this flag\n    without outputting a filename (e.g. avoid `-v` or specify\n    [`--info=name0`](#opt)) if you want to see how the transfer is doing\n    without scrolling the screen with a lot of names. (You don't need to\n    specify the [`--progress`](#opt) option in order to use\n    [`--info=progress2`](#opt).)\n\n    Finally, you can get an instant progress report by sending rsync a signal\n    of either SIGINFO or SIGVTALRM.  On BSD systems, a SIGINFO is generated by\n    typing a Ctrl+T (Linux doesn't currently support a SIGINFO signal).  When\n    the client-side process receives one of those signals, it sets a flag to\n    output a single progress report which is output when the current file\n    transfer finishes (so it may take a little time if a big file is being\n    handled when the signal arrives).  A filename is output (if needed)\n    followed by the [`--info=progress2`](#opt) format of progress info.  If you\n    don't know which of the 3 rsync processes is the client process, it's OK to\n    signal all of them (since the non-client processes ignore the signal).\n\n    CAUTION: sending SIGVTALRM to an older rsync (pre-3.2.0) will kill it.\n\n0.  `--password-file=FILE`\n\n    This option allows you to provide a password for accessing an rsync daemon\n    via a file or via standard input if **FILE** is `-`.  The file should\n    contain just the password on the first line (all other lines are ignored).\n    Rsync will exit with an error if **FILE** is world readable or if a\n    root-run rsync command finds a non-root-owned file.\n\n    This option does not supply a password to a remote shell transport such as\n    ssh; to learn how to do that, consult the remote shell's documentation.\n    When accessing an rsync daemon using a remote shell as the transport, this\n    option only comes into effect after the remote shell finishes its\n    authentication (i.e. if you have also specified a password in the daemon's\n    config file).\n\n0.  `--early-input=FILE`\n\n    This option allows rsync to send up to 5K of data to the \"early exec\"\n    script on its stdin.  One possible use of this data is to give the script a\n    secret that can be used to mount an encrypted filesystem (which you should\n    unmount in the the \"post-xfer exec\" script).\n\n    The daemon must be at least version 3.2.1.\n\n0.  `--list-only`\n\n    This option will cause the source files to be listed instead of\n    transferred.  This option is inferred if there is a single source arg and\n    no destination specified, so its main uses are:\n\n    1. to turn a copy command that includes a destination arg into a\n       file-listing command, or\n    2. to be able to specify more than one source arg.  Note: be sure to\n       include the destination.\n\n    CAUTION: keep in mind that a source arg with a wild-card is expanded by the\n    shell into multiple args, so it is never safe to try to specify a single\n    wild-card arg to try to infer this option. A safe example is:\n\n    >     rsync -av --list-only foo* dest/\n\n    This option always uses an output format that looks similar to this:\n\n    >     drwxrwxr-x          4,096 2022/09/30 12:53:11 support\n    >     -rw-rw-r--             80 2005/01/11 10:37:37 support/Makefile\n\n    The only option that affects this output style is (as of 3.1.0) the\n    [`--human-readable`](#opt) (`-h`) option.  The default is to output sizes\n    as byte counts with digit separators (in a 14-character-width column).\n    Specifying at least one `-h` option makes the sizes output with unit\n    suffixes.  If you want old-style bytecount sizes without digit separators\n    (and an 11-character-width column) use `--no-h`.\n\n    Compatibility note: when requesting a remote listing of files from an rsync\n    that is version 2.6.3 or older, you may encounter an error if you ask for a\n    non-recursive listing.  This is because a file listing implies the\n    [`--dirs`](#opt) option w/o [`--recursive`](#opt), and older rsyncs don't\n    have that option.  To avoid this problem, either specify the `--no-dirs`\n    option (if you don't need to expand a directory's content), or turn on\n    recursion and exclude the content of subdirectories: `-r --exclude='/*/*'`.\n\n0.  `--bwlimit=RATE`\n\n    This option allows you to specify the maximum transfer rate for the data\n    sent over the socket, specified in units per second.  The RATE value can be\n    suffixed with a string to indicate a size multiplier, and may be a\n    fractional value (e.g. `--bwlimit=1.5m`).  If no suffix is specified, the\n    value will be assumed to be in units of 1024 bytes (as if \"K\" or \"KiB\" had\n    been appended).  See the [`--max-size`](#opt) option for a description of\n    all the available suffixes.  A value of 0 specifies no limit.\n\n    For backward-compatibility reasons, the rate limit will be rounded to the\n    nearest KiB unit, so no rate smaller than 1024 bytes per second is\n    possible.\n\n    Rsync writes data over the socket in blocks, and this option both limits\n    the size of the blocks that rsync writes, and tries to keep the average\n    transfer rate at the requested limit.  Some burstiness may be seen where\n    rsync writes out a block of data and then sleeps to bring the average rate\n    into compliance.\n\n    Due to the internal buffering of data, the [`--progress`](#opt) option may\n    not be an accurate reflection on how fast the data is being sent.  This is\n    because some files can show up as being rapidly sent when the data is\n    quickly buffered, while other can show up as very slow when the flushing of\n    the output buffer occurs.  This may be fixed in a future version.\n\n    See also [the daemon version of the `--bwlimit` option](#dopt--bwlimit).\n\n0.  `--stop-after=MINS`, (`--time-limit=MINS`)\n\n    This option tells rsync to stop copying when the specified number of\n    minutes has elapsed.\n\n    For maximal flexibility, rsync does not communicate this option to the\n    remote rsync since it is usually enough that one side of the connection\n    quits as specified.  This allows the option's use even when only one side\n    of the connection supports it.  You can tell the remote side about the time\n    limit using [`--remote-option`](#opt) (`-M`), should the need arise.\n\n    The `--time-limit` version of this option is deprecated.\n\n0.  `--stop-at=y-m-dTh:m`\n\n    This option tells rsync to stop copying when the specified point in time\n    has been reached. The date & time can be fully specified in a numeric\n    format of year-month-dayThour:minute (e.g. 2000-12-31T23:59) in the local\n    timezone.  You may choose to separate the date numbers using slashes\n    instead of dashes.\n\n    The value can also be abbreviated in a variety of ways, such as specifying\n    a 2-digit year and/or leaving off various values.  In all cases, the value\n    will be taken to be the next possible point in time where the supplied\n    information matches.  If the value specifies the current time or a past\n    time, rsync exits with an error.\n\n    For example, \"1-30\" specifies the next January 30th (at midnight local\n    time), \"14:00\" specifies the next 2 P.M., \"1\" specifies the next 1st of the\n    month at midnight, \"31\" specifies the next month where we can stop on its\n    31st day, and \":59\" specifies the next 59th minute after the hour.\n\n    For maximal flexibility, rsync does not communicate this option to the\n    remote rsync since it is usually enough that one side of the connection\n    quits as specified.  This allows the option's use even when only one side\n    of the connection supports it.  You can tell the remote side about the time\n    limit using [`--remote-option`](#opt) (`-M`), should the need arise.  Do\n    keep in mind that the remote host may have a different default timezone\n    than your local host.\n\n0.  `--fsync`\n\n    Cause the receiving side to fsync each finished file.  This may slow down\n    the transfer, but can help to provide peace of mind when updating critical\n    files.\n\n0.  `--write-batch=FILE`\n\n    Record a file that can later be applied to another identical destination\n    with [`--read-batch`](#opt).  See the \"BATCH MODE\" section for details, and\n    also the [`--only-write-batch`](#opt) option.\n\n    This option overrides the negotiated checksum & compress lists and always\n    negotiates a choice based on old-school md5/md4/zlib choices.  If you want\n    a more modern choice, use the [`--checksum-choice`](#opt) (`--cc`) and/or\n    [`--compress-choice`](#opt) (`--zc`) options.\n\n0.  `--only-write-batch=FILE`\n\n    Works like [`--write-batch`](#opt), except that no updates are made on the\n    destination system when creating the batch.  This lets you transport the\n    changes to the destination system via some other means and then apply the\n    changes via [`--read-batch`](#opt).\n\n    Note that you can feel free to write the batch directly to some portable\n    media: if this media fills to capacity before the end of the transfer, you\n    can just apply that partial transfer to the destination and repeat the\n    whole process to get the rest of the changes (as long as you don't mind a\n    partially updated destination system while the multi-update cycle is\n    happening).\n\n    Also note that you only save bandwidth when pushing changes to a remote\n    system because this allows the batched data to be diverted from the sender\n    into the batch file without having to flow over the wire to the receiver\n    (when pulling, the sender is remote, and thus can't write the batch).\n\n0.  `--read-batch=FILE`\n\n    Apply all of the changes stored in FILE, a file previously generated by\n    [`--write-batch`](#opt).  If _FILE_ is `-`, the batch data will be read\n    from standard input. See the \"BATCH MODE\" section for details.\n\n0.  `--protocol=NUM`\n\n    Force an older protocol version to be used.  This is useful for creating a\n    batch file that is compatible with an older version of rsync.  For\n    instance, if rsync 2.6.4 is being used with the [`--write-batch`](#opt)\n    option, but rsync 2.6.3 is what will be used to run the\n    [`--read-batch`](#opt) option, you should use \"--protocol=28\" when creating\n    the batch file to force the older protocol version to be used in the batch\n    file (assuming you can't upgrade the rsync on the reading system).\n\n0.  `--iconv=CONVERT_SPEC`\n\n    Rsync can convert filenames between character sets using this option.\n    Using a CONVERT_SPEC of \".\" tells rsync to look up the default\n    character-set via the locale setting.  Alternately, you can fully specify\n    what conversion to do by giving a local and a remote charset separated by a\n    comma in the order `--iconv=LOCAL,REMOTE`, e.g. `--iconv=utf8,iso88591`.\n    This order ensures that the option will stay the same whether you're\n    pushing or pulling files.  Finally, you can specify either `--no-iconv` or\n    a CONVERT_SPEC of \"-\" to turn off any conversion.  The default setting of\n    this option is site-specific, and can also be affected via the\n    [`RSYNC_ICONV`](#) environment variable.\n\n    For a list of what charset names your local iconv library supports, you can\n    run \"`iconv --list`\".\n\n    If you specify the [`--secluded-args`](#opt) (`-s`) option, rsync will\n    translate the filenames you specify on the command-line that are being sent\n    to the remote host.  See also the [`--files-from`](#opt) option.\n\n    Note that rsync does not do any conversion of names in filter files\n    (including include/exclude files).  It is up to you to ensure that you're\n    specifying matching rules that can match on both sides of the transfer.\n    For instance, you can specify extra include/exclude rules if there are\n    filename differences on the two sides that need to be accounted for.\n\n    When you pass an `--iconv` option to an rsync daemon that allows it, the\n    daemon uses the charset specified in its \"charset\" configuration parameter\n    regardless of the remote charset you actually pass.  Thus, you may feel\n    free to specify just the local charset for a daemon transfer (e.g.\n    `--iconv=utf8`).\n\n0.  `--ipv4`, `-4` or `--ipv6`, `-6`\n\n    Tells rsync to prefer IPv4/IPv6 when creating sockets or running ssh.  This\n    affects sockets that rsync has direct control over, such as the outgoing\n    socket when directly contacting an rsync daemon, as well as the forwarding\n    of the `-4` or `-6` option to ssh when rsync can deduce that ssh is being\n    used as the remote shell.  For other remote shells you'll need to specify\n    the \"`--rsh SHELL -4`\" option directly (or whatever IPv4/IPv6 hint options\n    it uses).\n\n    See also [the daemon version of these options](#dopt--ipv4).\n\n    If rsync was compiled without support for IPv6, the `--ipv6` option will\n    have no effect.  The `rsync --version` output will contain \"`no IPv6`\" if\n    is the case.\n\n0.  `--checksum-seed=NUM`\n\n    Set the checksum seed to the integer NUM.  This 4 byte checksum seed is\n    included in each block and MD4 file checksum calculation (the more modern\n    MD5 file checksums don't use a seed).  By default the checksum seed is\n    generated by the server and defaults to the current **time**().  This\n    option is used to set a specific checksum seed, which is useful for\n    applications that want repeatable block checksums, or in the case where the\n    user wants a more random checksum seed.  Setting NUM to 0 causes rsync to\n    use the default of **time**() for checksum seed.\n\n## DAEMON OPTIONS\n\nThe options allowed when starting an rsync daemon are as follows:\n\n0.  `--daemon`\n\n    This tells rsync that it is to run as a daemon.  The daemon you start\n    running may be accessed using an rsync client using the `host::module` or\n    `rsync://host/module/` syntax.\n\n    If standard input is a socket then rsync will assume that it is being run\n    via inetd, otherwise it will detach from the current terminal and become a\n    background daemon.  The daemon will read the config file (rsyncd.conf) on\n    each connect made by a client and respond to requests accordingly.\n\n    See the [**rsyncd.conf**(5)](rsyncd.conf.5) manpage for more details.\n\n0.  `--address=ADDRESS`\n\n    By default rsync will bind to the wildcard address when run as a daemon\n    with the `--daemon` option.  The `--address` option allows you to specify a\n    specific IP address (or hostname) to bind to.  This makes virtual hosting\n    possible in conjunction with the `--config` option.\n\n    See also the [address](rsyncd.conf.5#address) global option in the\n    rsyncd.conf manpage and the [client version of the `--address`\n    option](#opt--address).\n\n0.  `--bwlimit=RATE`\n\n    This option allows you to specify the maximum transfer rate for the data\n    the daemon sends over the socket.  The client can still specify a smaller\n    `--bwlimit` value, but no larger value will be allowed.\n\n    See the [client version of the `--bwlimit` option](#opt--bwlimit) for some\n    extra details.\n\n0.  `--config=FILE`\n\n    This specifies an alternate config file than the default.  This is only\n    relevant when [`--daemon`](#dopt) is specified.  The default is\n    /etc/rsyncd.conf unless the daemon is running over a remote shell program\n    and the remote user is not the super-user; in that case the default is\n    rsyncd.conf in the current directory (typically $HOME).\n\n0.  `--dparam=OVERRIDE`, `-M`\n\n    This option can be used to set a daemon-config parameter when starting up\n    rsync in daemon mode.  It is equivalent to adding the parameter at the end\n    of the global settings prior to the first module's definition.  The\n    parameter names can be specified without spaces, if you so desire.  For\n    instance:\n\n    >     rsync --daemon -M pidfile=/path/rsync.pid\n\n0.  `--no-detach`\n\n    When running as a daemon, this option instructs rsync to not detach itself\n    and become a background process.  This option is required when running as a\n    service on Cygwin, and may also be useful when rsync is supervised by a\n    program such as `daemontools` or AIX's `System Resource Controller`.\n    `--no-detach` is also recommended when rsync is run under a debugger.  This\n    option has no effect if rsync is run from inetd or sshd.\n\n0.  `--port=PORT`\n\n    This specifies an alternate TCP port number for the daemon to listen on\n    rather than the default of 873.\n\n    See also [the client version of the `--port` option](#opt--port) and the\n    [port](rsyncd.conf.5#port) global setting in the rsyncd.conf manpage.\n\n0.  `--log-file=FILE`\n\n    This option tells the rsync daemon to use the given log-file name instead\n    of using the \"`log file`\" setting in the config file.\n\n    See also [the client version of the `--log-file` option](#opt--log-file).\n\n0.  `--log-file-format=FORMAT`\n\n    This option tells the rsync daemon to use the given FORMAT string instead\n    of using the \"`log format`\" setting in the config file.  It also enables\n    \"`transfer logging`\" unless the string is empty, in which case transfer\n    logging is turned off.\n\n    See also [the client version of the `--log-file-format`\n    option](#opt--log-file-format).\n\n0.  `--sockopts`\n\n    This overrides the [`socket options`](rsyncd.conf.5#socket_options)\n    setting in the rsyncd.conf file and has the same syntax.\n\n    See also [the client version of the `--sockopts` option](#opt--sockopts).\n\n0.  `--verbose`, `-v`\n\n    This option increases the amount of information the daemon logs during its\n    startup phase.  After the client connects, the daemon's verbosity level\n    will be controlled by the options that the client used and the\n    \"`max verbosity`\" setting in the module's config section.\n\n    See also [the client version of the `--verbose` option](#opt--verbose).\n\n0.  `--ipv4`, `-4` or `--ipv6`, `-6`\n\n    Tells rsync to prefer IPv4/IPv6 when creating the incoming sockets that the\n    rsync daemon will use to listen for connections.  One of these options may\n    be required in older versions of Linux to work around an IPv6 bug in the\n    kernel (if you see an \"address already in use\" error when nothing else is\n    using the port, try specifying `--ipv6` or `--ipv4` when starting the\n    daemon).\n\n    See also [the client version of these options](#opt--ipv4).\n\n    If rsync was compiled without support for IPv6, the `--ipv6` option will\n    have no effect.  The `rsync --version` output will contain \"`no IPv6`\" if\n    is the case.\n\n0.  `--help`, `-h`\n\n    When specified after `--daemon`, print a short help page describing the\n    options available for starting an rsync daemon.\n\n## FILTER RULES\n\nThe filter rules allow for custom control of several aspects of how files are\nhandled:\n\n- Control which files the sending side puts into the file list that describes\n  the transfer hierarchy\n- Control which files the receiving side protects from deletion when the file\n  is not in the sender's file list\n- Control which extended attribute names are skipped when copying xattrs\n\nThe rules are either directly specified via option arguments or they can be\nread in from one or more files.  The filter-rule files can even be a part of\nthe hierarchy of files being copied, affecting different parts of the tree in\ndifferent ways.\n\n### SIMPLE INCLUDE/EXCLUDE RULES\n\nWe will first cover the basics of how include & exclude rules affect what files\nare transferred, ignoring any deletion side-effects.  Filter rules mainly\naffect the contents of directories that rsync is \"recursing\" into, but they can\nalso affect a top-level item in the transfer that was specified as a argument.\n\nThe default for any unmatched file/dir is for it to be included in the\ntransfer, which puts the file/dir into the sender's file list.  The use of an\nexclude rule causes one or more matching files/dirs to be left out of the\nsender's file list.  An include rule can be used to limit the effect of an\nexclude rule that is matching too many files.\n\nThe order of the rules is important because the first rule that matches is the\none that takes effect.  Thus, if an early rule excludes a file, no include rule\nthat comes after it can have any effect. This means that you must place any\ninclude overrides somewhere prior to the exclude that it is intended to limit.\n\nWhen a directory is excluded, all its contents and sub-contents are also\nexcluded.  The sender doesn't scan through any of it at all, which can save a\nlot of time when skipping large unneeded sub-trees.\n\nIt is also important to understand that the include/exclude rules are applied\nto every file and directory that the sender is recursing into. Thus, if you\nwant a particular deep file to be included, you have to make sure that none of\nthe directories that must be traversed on the way down to that file are\nexcluded or else the file will never be discovered to be included. As an\nexample, if the directory \"`a/path`\" was given as a transfer argument and you\nwant to ensure that the file \"`a/path/down/deep/wanted.txt`\" is a part of the\ntransfer, then the sender must not exclude the directories \"`a/path`\",\n\"`a/path/down`\", or \"`a/path/down/deep`\" as it makes it way scanning through\nthe file tree.\n\nWhen you are working on the rules, it can be helpful to ask rsync to tell you\nwhat is being excluded/included and why.  Specifying `--debug=FILTER` or (when\npulling files) `-M--debug=FILTER` turns on level 1 of the FILTER debug\ninformation that will output a message any time that a file or directory is\nincluded or excluded and which rule it matched.  Beginning in 3.2.4 it will\nalso warn if a filter rule has trailing whitespace, since an exclude of \"foo \"\n(with a trailing space) will not exclude a file named \"foo\".\n\nExclude and include rules can specify wildcard [PATTERN MATCHING RULES](#)\n(similar to shell wildcards) that allow you to match things like a file suffix\nor a portion of a filename.\n\nA rule can be limited to only affecting a directory by putting a trailing slash\nonto the filename.\n\n### SIMPLE INCLUDE/EXCLUDE EXAMPLE\n\nWith the following file tree created on the sending side:\n\n>     mkdir x/\n>     touch x/file.txt\n>     mkdir x/y/\n>     touch x/y/file.txt\n>     touch x/y/zzz.txt\n>     mkdir x/z/\n>     touch x/z/file.txt\n\nThen the following rsync command will transfer the file \"`x/y/file.txt`\" and\nthe directories needed to hold it, resulting in the path \"`/tmp/x/y/file.txt`\"\nexisting on the remote host:\n\n>     rsync -ai -f'+ x/' -f'+ x/y/' -f'+ x/y/file.txt' -f'- *' x host:/tmp/\n\nAside: this copy could also have been accomplished using the [`-R`](#opt)\noption (though the 2 commands behave differently if deletions are enabled):\n\n>     rsync -aiR x/y/file.txt host:/tmp/\n\nThe following command does not need an include of the \"x\" directory because it\nis not a part of the transfer (note the trailing slash).  Running this command\nwould copy just \"`/tmp/x/file.txt`\" because the \"y\" and \"z\" dirs get excluded:\n\n>     rsync -ai -f'+ file.txt' -f'- *' x/ host:/tmp/x/\n\nThis command would omit the zzz.txt file while copying \"x\" and everything else\nit contains:\n\n>     rsync -ai -f'- zzz.txt' x host:/tmp/\n\n### FILTER RULES WHEN DELETING\n\nBy default the include & exclude filter rules affect both the sender\n(as it creates its file list)\nand the receiver (as it creates its file lists for calculating deletions).  If\nno delete option is in effect, the receiver skips creating the delete-related\nfile lists.  This two-sided default can be manually overridden so that you are\nonly specifying sender rules or receiver rules, as described in the [FILTER\nRULES IN DEPTH](#) section.\n\nWhen deleting, an exclude protects a file from being removed on the receiving\nside while an include overrides that protection (putting the file at risk of\ndeletion). The default is for a file to be at risk -- its safety depends on it\nmatching a corresponding file from the sender.\n\nAn example of the two-sided exclude effect can be illustrated by the copying of\na C development directory between 2 systems.  When doing a touch-up copy, you\nmight want to skip copying the built executable and the `.o` files (sender\nhide) so that the receiving side can build their own and not lose any object\nfiles that are already correct (receiver protect).  For instance:\n\n>     rsync -ai --del -f'- *.o' -f'- cmd' src host:/dest/\n\nNote that using `-f'-p *.o'` is even better than `-f'- *.o'` if there is a\nchance that the directory structure may have changed.  The \"p\" modifier is\ndiscussed in [FILTER RULE MODIFIERS](#).\n\nOne final note, if your shell doesn't mind unexpanded wildcards, you could\nsimplify the typing of the filter options by using an underscore in place of\nthe space and leaving off the quotes.  For instance, `-f -_*.o -f -_cmd` (and\nsimilar) could be used instead of the filter options above.\n\n### FILTER RULES IN DEPTH\n\nRsync supports old-style include/exclude rules and new-style filter rules.  The\nolder rules are specified using [`--include`](#opt) and [`--exclude`](#opt) as\nwell as the [`--include-from`](#opt) and [`--exclude-from`](#opt). These are\nlimited in behavior but they don't require a \"-\" or \"+\" prefix.  An old-style\nexclude rule is turned into a \"`- name`\" filter rule (with no modifiers) and an\nold-style include rule is turned into a \"`+ name`\" filter rule (with no\nmodifiers).\n\nRsync builds an ordered list of filter rules as specified on the command-line\nand/or read-in from files.  New style filter rules have the following syntax:\n\n>     RULE [PATTERN_OR_FILENAME]\n>     RULE,MODIFIERS [PATTERN_OR_FILENAME]\n\nYou have your choice of using either short or long RULE names, as described\nbelow.  If you use a short-named rule, the ',' separating the RULE from the\nMODIFIERS is optional.  The PATTERN or FILENAME that follows (when present)\nmust come after either a single space or an underscore (\\_). Any additional\nspaces and/or underscores are considered to be a part of the pattern name.\nHere are the available rule prefixes:\n\n0.  `exclude, '-'` specifies an exclude pattern that (by default) is both a\n    `hide` and a `protect`.\n0.  `include, '+'` specifies an include pattern that (by default) is both a\n    `show` and a `risk`.\n0.  `merge, '.'` specifies a merge-file on the client side to read for more\n    rules.\n0.  `dir-merge, ':'` specifies a per-directory merge-file.  Using this kind of\n    filter rule requires that you trust the sending side's filter checking, so\n    it has the side-effect mentioned under the [`--trust-sender`](#opt) option.\n0.  `hide, 'H'` specifies a pattern for hiding files from the transfer.\n    Equivalent to a sender-only exclude, so `-f'H foo'` could also be specified\n    as `-f'-s foo'`.\n0.  `show, 'S'` files that match the pattern are not hidden. Equivalent to a\n    sender-only include, so `-f'S foo'` could also be specified as `-f'+s\n    foo'`.\n0.  `protect, 'P'` specifies a pattern for protecting files from deletion.\n    Equivalent to a receiver-only exclude, so `-f'P foo'` could also be\n    specified as `-f'-r foo'`.\n0.  `risk, 'R'` files that match the pattern are not protected. Equivalent to a\n    receiver-only include, so `-f'R foo'` could also be specified as `-f'+r\n    foo'`.\n0.  `clear, '!'` clears the current include/exclude list (takes no arg)\n\nWhen rules are being read from a file (using merge or dir-merge), empty lines\nare ignored, as are whole-line comments that start with a '`#`' (filename rules\nthat contain a hash character are unaffected).\n\nNote also that the [`--filter`](#opt), [`--include`](#opt), and\n[`--exclude`](#opt) options take one rule/pattern each.  To add multiple ones,\nyou can repeat the options on the command-line, use the merge-file syntax of\nthe [`--filter`](#opt) option, or the [`--include-from`](#opt) /\n[`--exclude-from`](#opt) options.\n\n### PATTERN MATCHING RULES\n\nMost of the rules mentioned above take an argument that specifies what the rule\nshould match.  If rsync is recursing through a directory hierarchy, keep in\nmind that each pattern is matched against the name of every directory in the\ndescent path as rsync finds the filenames to send.\n\nThe matching rules for the pattern argument take several forms:\n\n- If a pattern contains a `/` (not counting a trailing slash) or a \"`**`\"\n  (which can match a slash), then the pattern is matched against the full\n  pathname, including any leading directories within the transfer.  If the\n  pattern doesn't contain a (non-trailing) `/` or a \"`**`\", then it is matched\n  only against the final component of the filename or pathname. For example,\n  `foo` means that the final path component must be \"foo\" while `foo/bar` would\n  match the last 2 elements of the path (as long as both elements are within\n  the transfer).\n- A pattern that ends with a `/` only matches a directory, not a regular file,\n  symlink, or device.\n- A pattern that starts with a `/` is anchored to the start of the transfer\n  path instead of the end.  For example, `/foo/**` or `/foo/bar/**` match only\n  leading elements in the path.  If the rule is read from a per-directory\n  filter file, the transfer path being matched will begin at the level of the\n  filter file instead of the top of the transfer.  See the section on\n  [ANCHORING INCLUDE/EXCLUDE PATTERNS](#) for a full discussion of how to\n  specify a pattern that matches at the root of the transfer.\n\nRsync chooses between doing a simple string match and wildcard matching by\nchecking if the pattern contains one of these three wildcard characters: '`*`',\n'`?`', and '`[`' :\n\n- a '`?`' matches any single character except a slash (`/`).\n- a '`*`' matches zero or more non-slash characters.\n- a '`**`' matches zero or more characters, including slashes.\n- a '`[`' introduces a character class, such as `[a-z]` or `[[:alpha:]]`, that\n  must match one character.\n- a trailing `***` in the pattern is a shorthand that allows you to match a\n  directory and all its contents using a single rule.  For example, specifying\n  \"`dir_name/***`\" will match both the \"dir_name\" directory (as if \"`dir_name/`\"\n  had been specified) and everything in the directory (as if \"`dir_name/**`\"\n  had been specified).\n- a backslash can be used to escape a wildcard character, but it is only\n  interpreted as an escape character if at least one wildcard character is\n  present in the match pattern. For instance, the pattern \"`foo\\bar`\" matches\n  that single backslash literally, while the pattern \"`foo\\bar*`\" would need to\n  be changed to \"`foo\\\\bar*`\" to avoid the \"`\\b`\" becoming just \"b\".\n\nHere are some examples of exclude/include matching:\n\n- Option `-f'- *.o'` would exclude all filenames ending with `.o`\n- Option `-f'- /foo'` would exclude a file (or directory) named foo in the\n  transfer-root directory\n- Option `-f'- foo/'` would exclude any directory named foo\n- Option `-f'- foo/*/bar'` would exclude any file/dir named bar which is at two\n  levels below a directory named foo (if foo is in the transfer)\n- Option `-f'- /foo/**/bar'` would exclude any file/dir named bar that was two\n  or more levels below a top-level directory named foo (note that /foo/bar is\n  **not** excluded by this)\n- Options `-f'+ */' -f'+ *.c' -f'- *'` would include all directories and .c\n  source files but nothing else\n- Options `-f'+ foo/' -f'+ foo/bar.c' -f'- *'` would include only the foo\n  directory and foo/bar.c (the foo directory must be explicitly included or it\n  would be excluded by the \"`- *`\")\n\n### FILTER RULE MODIFIERS\n\nThe following modifiers are accepted after an include (+) or exclude (-) rule:\n\n- A `/` specifies that the include/exclude rule should be matched against the\n  absolute pathname of the current item.  For example, `-f'-/ /etc/passwd'`\n  would exclude the passwd file any time the transfer was sending files from\n  the \"/etc\" directory, and \"-/ subdir/foo\" would always exclude \"foo\" when it\n  is in a dir named \"subdir\", even if \"foo\" is at the root of the current\n  transfer.\n- A `!` specifies that the include/exclude should take effect if the pattern\n  fails to match.  For instance, `-f'-! */'` would exclude all non-directories.\n- A `C` is used to indicate that all the global CVS-exclude rules should be\n  inserted as excludes in place of the \"-C\".  No arg should follow.\n- An `s` is used to indicate that the rule applies to the sending side.  When a\n  rule affects the sending side, it affects what files are put into the\n  sender's file list.  The default is for a rule to affect both sides unless\n  [`--delete-excluded`](#opt) was specified, in which case default rules become\n  sender-side only.  See also the hide (H) and show (S) rules, which are an\n  alternate way to specify sending-side includes/excludes.\n- An `r` is used to indicate that the rule applies to the receiving side.  When\n  a rule affects the receiving side, it prevents files from being deleted.  See\n  the `s` modifier for more info.  See also the protect (P) and risk (R) rules,\n  which are an alternate way to specify receiver-side includes/excludes.\n- A `p` indicates that a rule is perishable, meaning that it is ignored in\n  directories that are being deleted.  For instance, the\n  [`--cvs-exclude`](#opt) (`-C`) option's default rules that exclude things\n  like \"CVS\" and \"`*.o`\" are marked as perishable, and will not prevent a\n  directory that was removed on the source from being deleted on the\n  destination.\n- An `x` indicates that a rule affects xattr names in xattr copy/delete\n  operations (and is thus ignored when matching file/dir names).  If no\n  xattr-matching rules are specified, a default xattr filtering rule is used\n  (see the [`--xattrs`](#opt) option).\n\n### MERGE-FILE FILTER RULES\n\nYou can merge whole files into your filter rules by specifying either a merge\n(.) or a dir-merge (:) filter rule (as introduced in the [FILTER RULES](#)\nsection above).\n\nThere are two kinds of merged files -- single-instance ('.') and per-directory\n(':').  A single-instance merge file is read one time, and its rules are\nincorporated into the filter list in the place of the \".\" rule.  For\nper-directory merge files, rsync will scan every directory that it traverses\nfor the named file, merging its contents when the file exists into the current\nlist of inherited rules.  These per-directory rule files must be created on the\nsending side because it is the sending side that is being scanned for the\navailable files to transfer.  These rule files may also need to be transferred\nto the receiving side if you want them to affect what files don't get deleted\n(see [PER-DIRECTORY RULES AND DELETE](#) below).\n\nSome examples:\n\n>     merge /etc/rsync/default.rules\n>     . /etc/rsync/default.rules\n>     dir-merge .per-dir-filter\n>     dir-merge,n- .non-inherited-per-dir-excludes\n>     :n- .non-inherited-per-dir-excludes\n\nThe following modifiers are accepted after a merge or dir-merge rule:\n\n- A `-` specifies that the file should consist of only exclude patterns, with\n  no other rule-parsing except for in-file comments.\n- A `+` specifies that the file should consist of only include patterns, with\n  no other rule-parsing except for in-file comments.\n- A `C` is a way to specify that the file should be read in a CVS-compatible\n  manner.  This turns on 'n', 'w', and '-', but also allows the list-clearing\n  token (!) to be specified.  If no filename is provided, \".cvsignore\" is\n  assumed.\n- A `e` will exclude the merge-file name from the transfer; e.g.  \"dir-merge,e\n  .rules\" is like \"dir-merge .rules\" and \"- .rules\".\n- An `n` specifies that the rules are not inherited by subdirectories.\n- A `w` specifies that the rules are word-split on whitespace instead of the\n  normal line-splitting.  This also turns off comments.  Note: the space that\n  separates the prefix from the rule is treated specially, so \"- foo + bar\" is\n  parsed as two rules (assuming that prefix-parsing wasn't also disabled).\n- You may also specify any of the modifiers for the \"+\" or \"-\" rules (above) in\n  order to have the rules that are read in from the file default to having that\n  modifier set (except for the `!` modifier, which would not be useful).  For\n  instance, \"merge,-/ .excl\" would treat the contents of .excl as absolute-path\n  excludes, while \"dir-merge,s .filt\" and \":sC\" would each make all their\n  per-directory rules apply only on the sending side.  If the merge rule\n  specifies sides to affect (via the `s` or `r` modifier or both), then the\n  rules in the file must not specify sides (via a modifier or a rule prefix\n  such as `hide`).\n\nPer-directory rules are inherited in all subdirectories of the directory where\nthe merge-file was found unless the 'n' modifier was used.  Each subdirectory's\nrules are prefixed to the inherited per-directory rules from its parents, which\ngives the newest rules a higher priority than the inherited rules.  The entire\nset of dir-merge rules are grouped together in the spot where the merge-file\nwas specified, so it is possible to override dir-merge rules via a rule that\ngot specified earlier in the list of global rules.  When the list-clearing rule\n(\"!\") is read from a per-directory file, it only clears the inherited rules for\nthe current merge file.\n\nAnother way to prevent a single rule from a dir-merge file from being inherited\nis to anchor it with a leading slash.  Anchored rules in a per-directory\nmerge-file are relative to the merge-file's directory, so a pattern \"/foo\"\nwould only match the file \"foo\" in the directory where the dir-merge filter\nfile was found.\n\nHere's an example filter file which you'd specify via `--filter=\". file\":`\n\n>     merge /home/user/.global-filter\n>     - *.gz\n>     dir-merge .rules\n>     + *.[ch]\n>     - *.o\n>     - foo*\n\nThis will merge the contents of the /home/user/.global-filter file at the start\nof the list and also turns the \".rules\" filename into a per-directory filter\nfile.  All rules read in prior to the start of the directory scan follow the\nglobal anchoring rules (i.e. a leading slash matches at the root of the\ntransfer).\n\nIf a per-directory merge-file is specified with a path that is a parent\ndirectory of the first transfer directory, rsync will scan all the parent dirs\nfrom that starting point to the transfer directory for the indicated\nper-directory file.  For instance, here is a common filter (see [`-F`](#opt)):\n\n>     --filter=': /.rsync-filter'\n\nThat rule tells rsync to scan for the file .rsync-filter in all directories\nfrom the root down through the parent directory of the transfer prior to the\nstart of the normal directory scan of the file in the directories that are sent\nas a part of the transfer. (Note: for an rsync daemon, the root is always the\nsame as the module's \"path\".)\n\nSome examples of this pre-scanning for per-directory files:\n\n>     rsync -avF /src/path/ /dest/dir\n>     rsync -av --filter=': ../../.rsync-filter' /src/path/ /dest/dir\n>     rsync -av --filter=': .rsync-filter' /src/path/ /dest/dir\n\nThe first two commands above will look for \".rsync-filter\" in \"/\" and \"/src\"\nbefore the normal scan begins looking for the file in \"/src/path\" and its\nsubdirectories.  The last command avoids the parent-dir scan and only looks for\nthe \".rsync-filter\" files in each directory that is a part of the transfer.\n\nIf you want to include the contents of a \".cvsignore\" in your patterns, you\nshould use the rule \":C\", which creates a dir-merge of the .cvsignore file, but\nparsed in a CVS-compatible manner.  You can use this to affect where the\n[`--cvs-exclude`](#opt) (`-C`) option's inclusion of the per-directory\n.cvsignore file gets placed into your rules by putting the \":C\" wherever you\nlike in your filter rules.  Without this, rsync would add the dir-merge rule\nfor the .cvsignore file at the end of all your other rules (giving it a lower\npriority than your command-line rules).  For example:\n\n> ```\n> cat <<EOT | rsync -avC --filter='. -' a/ b\n> + foo.o\n> :C\n> - *.old\n> EOT\n> rsync -avC --include=foo.o -f :C --exclude='*.old' a/ b\n> ```\n\nBoth of the above rsync commands are identical.  Each one will merge all the\nper-directory .cvsignore rules in the middle of the list rather than at the\nend.  This allows their dir-specific rules to supersede the rules that follow\nthe :C instead of being subservient to all your rules.  To affect the other CVS\nexclude rules (i.e. the default list of exclusions, the contents of\n$HOME/.cvsignore, and the value of $CVSIGNORE) you should omit the `-C`\ncommand-line option and instead insert a \"-C\" rule into your filter rules; e.g.\n\"`--filter=-C`\".\n\n### LIST-CLEARING FILTER RULE\n\nYou can clear the current include/exclude list by using the \"!\" filter rule (as\nintroduced in the [FILTER RULES](#) section above).  The \"current\" list is either\nthe global list of rules (if the rule is encountered while parsing the filter\noptions) or a set of per-directory rules (which are inherited in their own\nsub-list, so a subdirectory can use this to clear out the parent's rules).\n\n### ANCHORING INCLUDE/EXCLUDE PATTERNS\n\nAs mentioned earlier, global include/exclude patterns are anchored at the \"root\nof the transfer\" (as opposed to per-directory patterns, which are anchored at\nthe merge-file's directory).  If you think of the transfer as a subtree of\nnames that are being sent from sender to receiver, the transfer-root is where\nthe tree starts to be duplicated in the destination directory.  This root\ngoverns where patterns that start with a / match.\n\nBecause the matching is relative to the transfer-root, changing the trailing\nslash on a source path or changing your use of the [`--relative`](#opt) option\naffects the path you need to use in your matching (in addition to changing how\nmuch of the file tree is duplicated on the destination host).  The following\nexamples demonstrate this.\n\nLet's say that we want to match two source files, one with an absolute\npath of \"/home/me/foo/bar\", and one with a path of \"/home/you/bar/baz\".\nHere is how the various command choices differ for a 2-source transfer:\n\n> ```\n> Example cmd: rsync -a /home/me /home/you /dest\n> +/- pattern: /me/foo/bar\n> +/- pattern: /you/bar/baz\n> Target file: /dest/me/foo/bar\n> Target file: /dest/you/bar/baz\n> ```\n\n> ```\n> Example cmd: rsync -a /home/me/ /home/you/ /dest\n> +/- pattern: /foo/bar               (note missing \"me\")\n> +/- pattern: /bar/baz               (note missing \"you\")\n> Target file: /dest/foo/bar\n> Target file: /dest/bar/baz\n> ```\n\n> ```\n> Example cmd: rsync -a --relative /home/me/ /home/you /dest\n> +/- pattern: /home/me/foo/bar       (note full path)\n> +/- pattern: /home/you/bar/baz      (ditto)\n> Target file: /dest/home/me/foo/bar\n> Target file: /dest/home/you/bar/baz\n> ```\n\n> ```\n> Example cmd: cd /home; rsync -a --relative me/foo you/ /dest\n> +/- pattern: /me/foo/bar      (starts at specified path)\n> +/- pattern: /you/bar/baz     (ditto)\n> Target file: /dest/me/foo/bar\n> Target file: /dest/you/bar/baz\n> ```\n\nThe easiest way to see what name you should filter is to just look at the\noutput when using [`--verbose`](#opt) and put a / in front of the name (use the\n`--dry-run` option if you're not yet ready to copy any files).\n\n### PER-DIRECTORY RULES AND DELETE\n\nWithout a delete option, per-directory rules are only relevant on the sending\nside, so you can feel free to exclude the merge files themselves without\naffecting the transfer.  To make this easy, the 'e' modifier adds this exclude\nfor you, as seen in these two equivalent commands:\n\n>     rsync -av --filter=': .excl' --exclude=.excl host:src/dir /dest\n>     rsync -av --filter=':e .excl' host:src/dir /dest\n\nHowever, if you want to do a delete on the receiving side AND you want some\nfiles to be excluded from being deleted, you'll need to be sure that the\nreceiving side knows what files to exclude.  The easiest way is to include the\nper-directory merge files in the transfer and use [`--delete-after`](#opt),\nbecause this ensures that the receiving side gets all the same exclude rules as\nthe sending side before it tries to delete anything:\n\n>     rsync -avF --delete-after host:src/dir /dest\n\nHowever, if the merge files are not a part of the transfer, you'll need to\neither specify some global exclude rules (i.e. specified on the command line),\nor you'll need to maintain your own per-directory merge files on the receiving\nside.  An example of the first is this (assume that the remote .rules files\nexclude themselves):\n\n>     rsync -av --filter=': .rules' --filter='. /my/extra.rules'\n>        --delete host:src/dir /dest\n\nIn the above example the extra.rules file can affect both sides of the\ntransfer, but (on the sending side) the rules are subservient to the rules\nmerged from the .rules files because they were specified after the\nper-directory merge rule.\n\nIn one final example, the remote side is excluding the .rsync-filter files from\nthe transfer, but we want to use our own .rsync-filter files to control what\ngets deleted on the receiving side.  To do this we must specifically exclude\nthe per-directory merge files (so that they don't get deleted) and then put\nrules into the local files to control what else should not get deleted.  Like\none of these commands:\n\n> ```\n> rsync -av --filter=':e /.rsync-filter' --delete \\\n>     host:src/dir /dest\n> rsync -avFF --delete host:src/dir /dest\n> ```\n\n## TRANSFER RULES\n\nIn addition to the [FILTER RULES](#) that affect the recursive file scans that\ngenerate the file list on the sending and (when deleting) receiving sides,\nthere are transfer rules. These rules affect which files the generator decides\nneed to be transferred without the side effects of an exclude filter rule.\nTransfer rules affect only files and never directories.\n\nBecause a transfer rule does not affect what goes into the sender's (and\nreceiver's) file list, it cannot have any effect on which files get deleted on\nthe receiving side.  For example, if the file \"foo\" is present in the sender's\nlist but its size is such that it is omitted due to a transfer rule, the\nreceiving side does not request the file.  However, its presence in the file\nlist means that a delete pass will not remove a matching file named \"foo\" on\nthe receiving side.  On the other hand, a server-side exclude (hide) of the\nfile \"foo\" leaves the file out of the server's file list, and absent a\nreceiver-side exclude (protect) the receiver will remove a matching file named\n\"foo\" if deletions are requested.\n\nGiven that the files are still in the sender's file list, the\n[`--prune-empty-dirs`](#opt) option will not judge a directory as being empty\neven if it contains only files that the transfer rules omitted.\n\nSimilarly, a transfer rule does not have any extra effect on which files are\ndeleted on the receiving side, so setting a maximum file size for the transfer\ndoes not prevent big files from being deleted.\n\nExamples of transfer rules include the default \"quick check\" algorithm (which\ncompares size & modify time), the [`--update`](#opt) option, the\n[`--max-size`](#opt) option, the [`--ignore-non-existing`](#opt) option, and a\nfew others.\n\n## BATCH MODE\n\nBatch mode can be used to apply the same set of updates to many identical\nsystems.  Suppose one has a tree which is replicated on a number of hosts.  Now\nsuppose some changes have been made to this source tree and those changes need\nto be propagated to the other hosts.  In order to do this using batch mode,\nrsync is run with the write-batch option to apply the changes made to the\nsource tree to one of the destination trees.  The write-batch option causes the\nrsync client to store in a \"batch file\" all the information needed to repeat\nthis operation against other, identical destination trees.\n\nGenerating the batch file once saves having to perform the file status,\nchecksum, and data block generation more than once when updating multiple\ndestination trees.  Multicast transport protocols can be used to transfer the\nbatch update files in parallel to many hosts at once, instead of sending the\nsame data to every host individually.\n\nTo apply the recorded changes to another destination tree, run rsync with the\nread-batch option, specifying the name of the same batch file, and the\ndestination tree.  Rsync updates the destination tree using the information\nstored in the batch file.\n\nFor your convenience, a script file is also created when the write-batch option\nis used: it will be named the same as the batch file with \".sh\" appended.  This\nscript file contains a command-line suitable for updating a destination tree\nusing the associated batch file.  It can be executed using a Bourne (or\nBourne-like) shell, optionally passing in an alternate destination tree\npathname which is then used instead of the original destination path.  This is\nuseful when the destination tree path on the current host differs from the one\nused to create the batch file.\n\nExamples:\n\n>     $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/\n>     $ scp foo* remote:\n>     $ ssh remote ./foo.sh /bdest/dir/\n\n>     $ rsync --write-batch=foo -a /source/dir/ /adest/dir/\n>     $ ssh remote rsync --read-batch=- -a /bdest/dir/ <foo\n\nIn these examples, rsync is used to update /adest/dir/ from /source/dir/ and\nthe information to repeat this operation is stored in \"foo\" and \"foo.sh\".  The\nhost \"remote\" is then updated with the batched data going into the directory\n/bdest/dir.  The differences between the two examples reveals some of the\nflexibility you have in how you deal with batches:\n\n- The first example shows that the initial copy doesn't have to be local -- you\n  can push or pull data to/from a remote host using either the remote-shell\n  syntax or rsync daemon syntax, as desired.\n- The first example uses the created \"foo.sh\" file to get the right rsync\n  options when running the read-batch command on the remote host.\n- The second example reads the batch data via standard input so that the batch\n  file doesn't need to be copied to the remote machine first.  This example\n  avoids the foo.sh script because it needed to use a modified\n  [`--read-batch`](#opt) option, but you could edit the script file if you\n  wished to make use of it (just be sure that no other option is trying to use\n  standard input, such as the [`--exclude-from=-`](#opt) option).\n\nCaveats:\n\nThe read-batch option expects the destination tree that it is updating to be\nidentical to the destination tree that was used to create the batch update\nfileset.  When a difference between the destination trees is encountered the\nupdate might be discarded with a warning (if the file appears to be up-to-date\nalready) or the file-update may be attempted and then, if the file fails to\nverify, the update discarded with an error.  This means that it should be safe\nto re-run a read-batch operation if the command got interrupted.  If you wish\nto force the batched-update to always be attempted regardless of the file's\nsize and date, use the [`-I`](#opt) option (when reading the batch).  If an\nerror occurs, the destination tree will probably be in a partially updated\nstate.  In that case, rsync can be used in its regular (non-batch) mode of\noperation to fix up the destination tree.\n\nThe rsync version used on all destinations must be at least as new as the one\nused to generate the batch file.  Rsync will die with an error if the protocol\nversion in the batch file is too new for the batch-reading rsync to handle.\nSee also the [`--protocol`](#opt) option for a way to have the creating rsync\ngenerate a batch file that an older rsync can understand.  (Note that batch\nfiles changed format in version 2.6.3, so mixing versions older than that with\nnewer versions will not work.)\n\nWhen reading a batch file, rsync will force the value of certain options to\nmatch the data in the batch file if you didn't set them to the same as the\nbatch-writing command.  Other options can (and should) be changed.  For\ninstance [`--write-batch`](#opt) changes to [`--read-batch`](#opt),\n[`--files-from`](#opt) is dropped, and the [`--filter`](#opt) /\n[`--include`](#opt) / [`--exclude`](#opt) options are not needed unless one of\nthe [`--delete`](#opt) options is specified.\n\nThe code that creates the BATCH.sh file transforms any filter/include/exclude\noptions into a single list that is appended as a \"here\" document to the shell\nscript file.  An advanced user can use this to modify the exclude list if a\nchange in what gets deleted by [`--delete`](#opt) is desired.  A normal user\ncan ignore this detail and just use the shell script as an easy way to run the\nappropriate [`--read-batch`](#opt) command for the batched data.\n\nThe original batch mode in rsync was based on \"rsync+\", but the latest\nversion uses a new implementation.\n\n## SYMBOLIC LINKS\n\nThree basic behaviors are possible when rsync encounters a symbolic\nlink in the source directory.\n\nBy default, symbolic links are not transferred at all.  A message \"skipping\nnon-regular\" file is emitted for any symlinks that exist.\n\nIf [`--links`](#opt) is specified, then symlinks are added to the transfer\n(instead of being noisily ignored), and the default handling is to recreate\nthem with the same target on the destination.  Note that [`--archive`](#opt)\nimplies [`--links`](#opt).\n\nIf [`--copy-links`](#opt) is specified, then symlinks are \"collapsed\" by\ncopying their referent, rather than the symlink.\n\nRsync can also distinguish \"safe\" and \"unsafe\" symbolic links.  An example\nwhere this might be used is a web site mirror that wishes to ensure that the\nrsync module that is copied does not include symbolic links to `/etc/passwd` in\nthe public section of the site.  Using [`--copy-unsafe-links`](#opt) will cause\nany links to be copied as the file they point to on the destination.  Using\n[`--safe-links`](#opt) will cause unsafe links to be omitted by the receiver.\n(Note that you must specify or imply [`--links`](#opt) for\n[`--safe-links`](#opt) to have any effect.)\n\nSymbolic links are considered unsafe if they are absolute symlinks (start with\n`/`), empty, or if they contain enough \"..\" components to ascend from the top\nof the transfer.\n\nHere's a summary of how the symlink options are interpreted.  The list is in\norder of precedence, so if your combination of options isn't mentioned, use the\nfirst line that is a complete subset of your options:\n\n0.  `--copy-links` Turn all symlinks into normal files and directories\n    (leaving no symlinks in the transfer for any other options to affect).\n0.  `--copy-dirlinks` Turn just symlinks to directories into real\n    directories, leaving all other symlinks to be handled as described below.\n0.  `--links --copy-unsafe-links` Turn all unsafe symlinks\n    into files and create all safe symlinks.\n0.  `--copy-unsafe-links` Turn all unsafe symlinks into files, noisily\n    skip all safe symlinks.\n0.  `--links --safe-links` The receiver skips creating\n    unsafe symlinks found in the transfer and creates the safe ones.\n0.  `--links` Create all symlinks.\n\nFor the effect of [`--munge-links`](#opt), see the discussion in that option's\nsection.\n\nNote that the [`--keep-dirlinks`](#opt) option does not effect symlinks in the\ntransfer but instead affects how rsync treats a symlink to a directory that\nalready exists on the receiving side.  See that option's section for a warning.\n\n## DIAGNOSTICS\n\nRsync occasionally produces error messages that may seem a little cryptic.  The\none that seems to cause the most confusion is \"protocol version mismatch -- is\nyour shell clean?\".\n\nThis message is usually caused by your startup scripts or remote shell facility\nproducing unwanted garbage on the stream that rsync is using for its transport.\nThe way to diagnose this problem is to run your remote shell like this:\n\n>     ssh remotehost /bin/true > out.dat\n\nthen look at out.dat.  If everything is working correctly then out.dat should\nbe a zero length file.  If you are getting the above error from rsync then you\nwill probably find that out.dat contains some text or data.  Look at the\ncontents and try to work out what is producing it.  The most common cause is\nincorrectly configured shell startup scripts (such as .cshrc or .profile) that\ncontain output statements for non-interactive logins.\n\nIf you are having trouble debugging filter patterns, then try specifying the\n`-vv` option.  At this level of verbosity rsync will show why each individual\nfile is included or excluded.\n\n## EXIT VALUES\n\n- **0** - Success\n- **1** - Syntax or usage error\n- **2** - Protocol incompatibility\n- **3** - Errors selecting input/output files, dirs\n- **4** - Requested action not supported. Either:\n  - an attempt was made to manipulate 64-bit files on a platform that cannot support them\n  - an option was specified that is supported by the client and not by the server\n- **5** - Error starting client-server protocol\n- **6** - Daemon unable to append to log-file\n- **10** - Error in socket I/O\n- **11** - Error in file I/O\n- **12** - Error in rsync protocol data stream\n- **13** - Errors with program diagnostics\n- **14** - Error in IPC code\n- **20** - Received SIGUSR1 or SIGINT\n- **21** - Some error returned by **waitpid()**\n- **22** - Error allocating core memory buffers\n- **23** - Partial transfer due to error\n- **24** - Partial transfer due to vanished source files\n- **25** - The --max-delete limit stopped deletions\n- **30** - Timeout in data send/receive\n- **35** - Timeout waiting for daemon connection\n\n## ENVIRONMENT VARIABLES\n\n0.  `CVSIGNORE`\n\n    The CVSIGNORE environment variable supplements any ignore patterns in\n    .cvsignore files.  See the [`--cvs-exclude`](#opt) option for more details.\n\n0.  `RSYNC_ICONV`\n\n    Specify a default [`--iconv`](#opt) setting using this environment\n    variable. First supported in 3.0.0.\n\n0.  `RSYNC_OLD_ARGS`\n\n    Specify a \"1\" if you want the [`--old-args`](#opt) option to be enabled by\n    default, a \"2\" (or more) if you want it to be enabled in the\n    repeated-option state, or a \"0\" to make sure that it is disabled by\n    default. When this environment variable is set to a non-zero value, it\n    supersedes the [`RSYNC_PROTECT_ARGS`](#) variable.\n\n    This variable is ignored if [`--old-args`](#opt), `--no-old-args`, or\n    [`--secluded-args`](#opt) is specified on the command line.\n\n    First supported in 3.2.4.\n\n0.  `RSYNC_PROTECT_ARGS`\n\n    Specify a non-zero numeric value if you want the [`--secluded-args`](#opt)\n    option to be enabled by default, or a zero value to make sure that it is\n    disabled by default.\n\n    This variable is ignored if [`--secluded-args`](#opt), `--no-secluded-args`,\n    or [`--old-args`](#opt) is specified on the command line.\n\n    First supported in 3.1.0.  Starting in 3.2.4, this variable is ignored if\n    [`RSYNC_OLD_ARGS`](#) is set to a non-zero value.\n\n0.  `RSYNC_RSH`\n\n    This environment variable allows you to override the default shell used as\n    the transport for rsync.  Command line options are permitted after the\n    command name, just as in the [`--rsh`](#opt) (`-e`) option.\n\n0.  `RSYNC_PROXY`\n\n    This environment variable allows you to redirect your rsync\n    client to use a web proxy when connecting to an rsync daemon.  You should\n    set `RSYNC_PROXY` to a hostname:port pair.\n\n0.  `RSYNC_PASSWORD`\n\n    This environment variable allows you to set the password for an rsync\n    **daemon** connection, which avoids the password prompt.  Note that this\n    does **not** supply a password to a remote shell transport such as ssh\n    (consult its documentation for how to do that).\n\n0.  `USER` or `LOGNAME`\n\n    The USER or LOGNAME environment variables are used to determine the default\n    username sent to an rsync daemon.  If neither is set, the username defaults\n    to \"nobody\".  If both are set, `USER` takes precedence.\n\n0. `RSYNC_PARTIAL_DIR`\n\n    This environment variable specifies the directory to use for a\n    [`--partial`](#opt) transfer without implying that partial transfers be\n    enabled.  See the [`--partial-dir`](#opt) option for full details.\n\n0. `RSYNC_COMPRESS_LIST`\n\n    This environment variable allows you to customize the negotiation of the\n    compression algorithm by specifying an alternate order or a reduced list of\n    names.  Use the command `rsync --version` to see the available compression\n    names.  See the [`--compress`](#opt) option for full details.\n\n0. `RSYNC_CHECKSUM_LIST`\n\n    This environment variable allows you to customize the negotiation of the\n    checksum algorithm by specifying an alternate order or a reduced list of\n    names.  Use the command `rsync --version` to see the available checksum\n    names.  See the [`--checksum-choice`](#opt) option for full details.\n\n0. `RSYNC_MAX_ALLOC`\n\n    This environment variable sets an allocation maximum as if you had used the\n    [`--max-alloc`](#opt) option.\n\n0. `RSYNC_PORT`\n\n    This environment variable is not read by rsync, but is instead set in\n    its sub-environment when rsync is running the remote shell in combination\n    with a daemon connection.  This allows a script such as\n    [`rsync-ssl`](rsync-ssl.1) to be able to know the port number that the user\n    specified on the command line.\n\n0.  `HOME`\n\n    This environment variable is used to find the user's default .cvsignore\n    file.\n\n0. `RSYNC_CONNECT_PROG`\n\n    This environment variable is mainly used in debug setups to set the program\n    to use when making a daemon connection.  See [CONNECTING TO AN RSYNC\n    DAEMON](#) for full details.\n\n0. `RSYNC_SHELL`\n\n    This environment variable is mainly used in debug setups to set the program\n    to use to run the program specified by [`RSYNC_CONNECT_PROG`](#).  See\n    [CONNECTING TO AN RSYNC DAEMON](#) for full details.\n\n## FILES\n\n/etc/rsyncd.conf or rsyncd.conf\n\n## SEE ALSO\n\n[**rsync-ssl**(1)](rsync-ssl.1), [**rsyncd.conf**(5)](rsyncd.conf.5), [**rrsync**(1)](rrsync.1)\n\n## BUGS\n\n- Times are transferred as \\*nix time_t values.\n- When transferring to FAT filesystems rsync may re-sync unmodified files.  See\n  the comments on the [`--modify-window`](#opt) option.\n- File permissions, devices, etc. are transferred as native numerical values.\n- See also the comments on the [`--delete`](#opt) option.\n\nPlease report bugs! See the web site at <https://rsync.samba.org/>.\n\n## VERSION\n\nThis manpage is current for version @VERSION@ of rsync.\n\n## INTERNAL OPTIONS\n\nThe options `--server` and `--sender` are used internally by rsync, and should\nnever be typed by a user under normal circumstances.  Some awareness of these\noptions may be needed in certain scenarios, such as when setting up a login\nthat can only run an rsync command.  For instance, the support directory of the\nrsync distribution has an example script named rrsync (for restricted rsync)\nthat can be used with a restricted ssh login.\n\n## CREDITS\n\nRsync is distributed under the GNU General Public License.  See the file\n[COPYING](COPYING) for details.\n\nAn rsync web site is available at <https://rsync.samba.org/>.  The site\nincludes an FAQ-O-Matic which may cover questions unanswered by this manual\npage.\n\nThe rsync github project is <https://github.com/RsyncProject/rsync>.\n\nWe would be delighted to hear from you if you like this program.  Please\ncontact the mailing-list at <rsync@lists.samba.org>.\n\nThis program uses the excellent zlib compression library written by Jean-loup\nGailly and Mark Adler.\n\n## THANKS\n\nSpecial thanks go out to: John Van Essen, Matt McCutchen, Wesley W. Terpstra,\nDavid Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, and our\ngone-but-not-forgotten compadre, J.W. Schultz.\n\nThanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell and\nDavid Bell.  I've probably missed some people, my apologies if I have.\n\n## AUTHOR\n\nRsync was originally written by Andrew Tridgell and Paul Mackerras.  Many\npeople from around the world have helped to maintain and improve it.\n\nMailing lists for support and development are available at\n<https://lists.samba.org/>.\n"
        },
        {
          "name": "rsync.c",
          "type": "blob",
          "size": 23.5537109375,
          "content": "/*\n * Routines common to more than one of the rsync processes.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET\n#include <libcharset.h>\n#elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO\n#include <langinfo.h>\n#endif\n\nextern int dry_run;\nextern int preserve_acls;\nextern int preserve_xattrs;\nextern int preserve_perms;\nextern int preserve_executability;\nextern int preserve_mtimes;\nextern int omit_dir_times;\nextern int omit_link_times;\nextern int am_root;\nextern int am_server;\nextern int am_daemon;\nextern int am_sender;\nextern int am_receiver;\nextern int am_generator;\nextern int am_starting_up;\nextern int allow_8bit_chars;\nextern int protocol_version;\nextern int got_kill_signal;\nextern int called_from_signal_handler;\nextern int inc_recurse;\nextern int inplace;\nextern int flist_eof;\nextern int file_old_total;\nextern int keep_dirlinks;\nextern int make_backups;\nextern int sanitize_paths;\nextern struct file_list *cur_flist, *first_flist, *dir_flist;\nextern struct chmod_mode_struct *daemon_chmod_modes;\n#ifdef ICONV_OPTION\nextern char *iconv_opt;\n#endif\n\n#define UPDATED_OWNER (1<<0)\n#define UPDATED_GROUP (1<<1)\n#define UPDATED_MTIME (1<<2)\n#define UPDATED_ATIME (1<<3)\n#define UPDATED_ACLS  (1<<4)\n#define UPDATED_MODE  (1<<5)\n#define UPDATED_CRTIME (1<<6)\n\n#ifdef ICONV_CONST\niconv_t ic_chck = (iconv_t)-1;\n# ifdef ICONV_OPTION\niconv_t ic_send = (iconv_t)-1, ic_recv = (iconv_t)-1;\n# endif\n\nstatic const char *default_charset(void)\n{\n# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET\n\treturn locale_charset();\n# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO\n\treturn nl_langinfo(CODESET);\n# else\n\treturn \"\"; /* Works with (at the very least) gnu iconv... */\n# endif\n}\n\nvoid setup_iconv(void)\n{\n\tconst char *defset = default_charset();\n# ifdef ICONV_OPTION\n\tconst char *charset;\n\tchar *cp;\n# endif\n\n\tif (!am_server && !allow_8bit_chars) {\n\t\t/* It's OK if this fails... */\n\t\tic_chck = iconv_open(defset, defset);\n\n\t\tif (DEBUG_GTE(ICONV, 2)) {\n\t\t\tif (ic_chck == (iconv_t)-1) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"msg checking via isprint()\"\n\t\t\t\t\t\" (iconv_open(\\\"%s\\\", \\\"%s\\\") errno: %d)\\n\",\n\t\t\t\t\tdefset, defset, errno);\n\t\t\t} else {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"msg checking charset: %s\\n\",\n\t\t\t\t\tdefset);\n\t\t\t}\n\t\t}\n\t} else\n\t\tic_chck = (iconv_t)-1;\n\n# ifdef ICONV_OPTION\n\tif (!iconv_opt)\n\t\treturn;\n\n\tif ((cp = strchr(iconv_opt, ',')) != NULL) {\n\t\tif (am_server) /* A local transfer needs this. */\n\t\t\ticonv_opt = cp + 1;\n\t\telse\n\t\t\t*cp = '\\0';\n\t}\n\n\tif (!*iconv_opt || (*iconv_opt == '.' && iconv_opt[1] == '\\0'))\n\t\tcharset = defset;\n\telse\n\t\tcharset = iconv_opt;\n\n\tif ((ic_send = iconv_open(UTF8_CHARSET, charset)) == (iconv_t)-1) {\n\t\trprintf(FERROR, \"iconv_open(\\\"%s\\\", \\\"%s\\\") failed\\n\",\n\t\t\tUTF8_CHARSET, charset);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tif ((ic_recv = iconv_open(charset, UTF8_CHARSET)) == (iconv_t)-1) {\n\t\trprintf(FERROR, \"iconv_open(\\\"%s\\\", \\\"%s\\\") failed\\n\",\n\t\t\tcharset, UTF8_CHARSET);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tif (DEBUG_GTE(ICONV, 1)) {\n\t\trprintf(FINFO, \"[%s] charset: %s\\n\",\n\t\t\twho_am_i(), *charset ? charset : \"[LOCALE]\");\n\t}\n# endif\n}\n\n/* This function converts the chars in the \"in\" xbuf into characters in the\n * \"out\" xbuf.  The \".len\" chars of the \"in\" xbuf is used starting from its\n * \".pos\".  The \".size\" of the \"out\" xbuf restricts how many characters can\n * be stored, starting at its \".pos+.len\" position.  Note that the last byte\n * of the \"out\" xbuf is not used, which reserves space for a trailing '\\0'\n * (though it is up to the caller to store a trailing '\\0', as needed).\n *\n * We return a 0 on success or a -1 on error.  An error also sets errno to\n * E2BIG, EILSEQ, or EINVAL (see below); otherwise errno will be set to 0.\n * The \"in\" xbuf is altered to update \".pos\" and \".len\".  The \"out\" xbuf has\n * data appended, and its \".len\" incremented (see below for a \".size\" note).\n *\n * If ICB_CIRCULAR_OUT is set in \"flags\", the chars going into the \"out\" xbuf\n * can wrap around to the start, and the xbuf may have its \".size\" reduced\n * (presumably by 1 byte) if the iconv code doesn't have space to store a\n * multi-byte character at the physical end of the \".buf\" (though no reducing\n * happens if \".pos\" is <= 1, since there is no room to wrap around).\n *\n * If ICB_EXPAND_OUT is set in \"flags\", the \"out\" xbuf will be allocated if\n * empty, and (as long as ICB_CIRCULAR_OUT is not set) expanded if too small.\n * This prevents the return of E2BIG (except for a circular xbuf).\n *\n * If ICB_INCLUDE_BAD is set in \"flags\", any badly-encoded chars are included\n * verbatim in the \"out\" xbuf, so EILSEQ will not be returned.\n *\n * If ICB_INCLUDE_INCOMPLETE is set in \"flags\", any incomplete multi-byte\n * chars are included, which ensures that EINVAL is not returned.\n *\n * If ICB_INIT is set, the iconv() conversion state is initialized prior to\n * processing the characters. */\nint iconvbufs(iconv_t ic, xbuf *in, xbuf *out, int flags)\n{\n\tICONV_CONST char *ibuf;\n\tsize_t icnt, ocnt, opos;\n\tchar *obuf;\n\n\tif (!out->size && flags & ICB_EXPAND_OUT) {\n\t\tsize_t siz = ROUND_UP_1024(in->len * 2);\n\t\talloc_xbuf(out, siz);\n\t} else if (out->len+1 >= out->size) {\n\t\t/* There is no room to even start storing data. */\n\t\tif (!(flags & ICB_EXPAND_OUT) || flags & ICB_CIRCULAR_OUT) {\n\t\t\terrno = E2BIG;\n\t\t\treturn -1;\n\t\t}\n\t\trealloc_xbuf(out, out->size + ROUND_UP_1024(in->len * 2));\n\t}\n\n\tif (flags & ICB_INIT)\n\t\ticonv(ic, NULL, 0, NULL, 0);\n\n\tibuf = in->buf + in->pos;\n\ticnt = in->len;\n\n\topos = out->pos + out->len;\n\tif (flags & ICB_CIRCULAR_OUT) {\n\t\tif (opos >= out->size) {\n\t\t\topos -= out->size;\n\t\t\t/* We know that out->pos is not 0 due to the \"no room\" check\n\t\t\t * above, so this can't go \"negative\". */\n\t\t\tocnt = out->pos - opos - 1;\n\t\t} else {\n\t\t\t/* Allow the use of all bytes to the physical end of the buffer\n\t\t\t * unless pos is 0, in which case we reserve our trailing '\\0'. */\n\t\t\tocnt = out->size - opos - (out->pos ? 0 : 1);\n\t\t}\n\t} else\n\t\tocnt = out->size - opos - 1;\n\tobuf = out->buf + opos;\n\n\twhile (icnt) {\n\t\twhile (iconv(ic, &ibuf, &icnt, &obuf, &ocnt) == (size_t)-1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tif (!(flags & ICB_INCLUDE_INCOMPLETE))\n\t\t\t\t\tgoto finish;\n\t\t\t\tif (!ocnt)\n\t\t\t\t\tgoto e2big;\n\t\t\t} else if (errno == EILSEQ) {\n\t\t\t\tif (!(flags & ICB_INCLUDE_BAD))\n\t\t\t\t\tgoto finish;\n\t\t\t\tif (!ocnt)\n\t\t\t\t\tgoto e2big;\n\t\t\t} else if (errno == E2BIG) {\n\t\t\t\tsize_t siz;\n\t\t\t  e2big:\n\t\t\t\topos = obuf - out->buf;\n\t\t\t\tif (flags & ICB_CIRCULAR_OUT && out->pos > 1 && opos > out->pos) {\n\t\t\t\t\t/* We are in a divided circular buffer at the physical\n\t\t\t\t\t * end with room to wrap to the start.  If iconv() refused\n\t\t\t\t\t * to use one or more trailing bytes in the buffer, we\n\t\t\t\t\t * set the size to ignore the unused bytes. */\n\t\t\t\t\tif (opos < out->size)\n\t\t\t\t\t\treduce_iobuf_size(out, opos);\n\t\t\t\t\tobuf = out->buf;\n\t\t\t\t\tocnt = out->pos - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(flags & ICB_EXPAND_OUT) || flags & ICB_CIRCULAR_OUT) {\n\t\t\t\t\terrno = E2BIG;\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t\tsiz = ROUND_UP_1024(in->len * 2);\n\t\t\t\trealloc_xbuf(out, out->size + siz);\n\t\t\t\tobuf = out->buf + opos;\n\t\t\t\tocnt += siz;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\trsyserr(FERROR, errno, \"unexpected error from iconv()\");\n\t\t\t\texit_cleanup(RERR_UNSUPPORTED);\n\t\t\t}\n\t\t\t*obuf++ = *ibuf++;\n\t\t\tocnt--, icnt--;\n\t\t\tif (!icnt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\terrno = 0;\n\n  finish:\n\topos = obuf - out->buf;\n\tif (flags & ICB_CIRCULAR_OUT && opos < out->pos)\n\t\topos += out->size;\n\tout->len = opos - out->pos;\n\n\tin->len = icnt;\n\tin->pos = ibuf - in->buf;\n\n\treturn errno ? -1 : 0;\n}\n#endif\n\nvoid send_protected_args(int fd, char *args[])\n{\n\tint i;\n#ifdef ICONV_OPTION\n\tint convert = ic_send != (iconv_t)-1;\n\txbuf outbuf, inbuf;\n\n\tif (convert)\n\t\talloc_xbuf(&outbuf, 1024);\n#endif\n\n\tfor (i = 0; args[i]; i++) {} /* find first NULL */\n\targs[i] = \"rsync\"; /* set a new arg0 */\n\tif (DEBUG_GTE(CMD, 1))\n\t\tprint_child_argv(\"protected args:\", args + i + 1);\n\tdo {\n\t\tif (!args[i][0])\n\t\t\twrite_buf(fd, \".\", 2);\n#ifdef ICONV_OPTION\n\t\telse if (convert) {\n\t\t\tINIT_XBUF_STRLEN(inbuf, args[i]);\n\t\t\ticonvbufs(ic_send, &inbuf, &outbuf,\n\t\t\t\t  ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT);\n\t\t\toutbuf.buf[outbuf.len] = '\\0';\n\t\t\twrite_buf(fd, outbuf.buf, outbuf.len + 1);\n\t\t\toutbuf.len = 0;\n\t\t}\n#endif\n\t\telse\n\t\t\twrite_buf(fd, args[i], strlen(args[i]) + 1);\n\t} while (args[++i]);\n\twrite_byte(fd, 0);\n\n#ifdef ICONV_OPTION\n\tif (convert)\n\t\tfree(outbuf.buf);\n#endif\n}\n\nint read_ndx_and_attrs(int f_in, int f_out, int *iflag_ptr, uchar *type_ptr, char *buf, int *len_ptr)\n{\n\tint len, iflags = 0;\n\tstruct file_list *flist;\n\tuchar fnamecmp_type = FNAMECMP_FNAME;\n\tint ndx;\n\n  read_loop:\n\twhile (1) {\n\t\tndx = read_ndx(f_in);\n\n\t\tif (ndx >= 0)\n\t\t\tbreak;\n\t\tif (ndx == NDX_DONE)\n\t\t\treturn ndx;\n\t\tif (ndx == NDX_DEL_STATS) {\n\t\t\tread_del_stats(f_in);\n\t\t\tif (am_sender && am_server)\n\t\t\t\twrite_del_stats(f_out);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inc_recurse || am_sender) {\n\t\t\tint last;\n\t\t\tif (first_flist)\n\t\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t\telse\n\t\t\t\tlast = -1;\n\t\t\trprintf(FERROR,\n\t\t\t\t\"Invalid file index: %d (%d - %d) [%s]\\n\",\n\t\t\t\tndx, NDX_DONE, last, who_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (ndx == NDX_FLIST_EOF) {\n\t\t\tflist_eof = 1;\n\t\t\tif (DEBUG_GTE(FLIST, 3))\n\t\t\t\trprintf(FINFO, \"[%s] flist_eof=1\\n\", who_am_i());\n\t\t\twrite_int(f_out, NDX_FLIST_EOF);\n\t\t\tcontinue;\n\t\t}\n\t\tndx = NDX_FLIST_OFFSET - ndx;\n\t\tif (ndx < 0 || ndx >= dir_flist->used) {\n\t\t\tndx = NDX_FLIST_OFFSET - ndx;\n\t\t\trprintf(FERROR,\n\t\t\t\t\"Invalid dir index: %d (%d - %d) [%s]\\n\",\n\t\t\t\tndx, NDX_FLIST_OFFSET,\n\t\t\t\tNDX_FLIST_OFFSET - dir_flist->used + 1,\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (DEBUG_GTE(FLIST, 2)) {\n\t\t\trprintf(FINFO, \"[%s] receiving flist for dir %d\\n\",\n\t\t\t\twho_am_i(), ndx);\n\t\t}\n\t\t/* Send all the data we read for this flist to the generator. */\n\t\tstart_flist_forward(ndx);\n\t\tflist = recv_file_list(f_in, ndx);\n\t\tflist->parent_ndx = ndx;\n\t\tstop_flist_forward();\n\t}\n\n\tiflags = protocol_version >= 29 ? read_shortint(f_in)\n\t\t   : ITEM_TRANSFER | ITEM_MISSING_DATA;\n\n\t/* Support the protocol-29 keep-alive style. */\n\tif (protocol_version < 30 && ndx == cur_flist->used && iflags == ITEM_IS_NEW) {\n\t\tif (am_sender)\n\t\t\tmaybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);\n\t\tgoto read_loop;\n\t}\n\n\tflist = flist_for_ndx(ndx, \"read_ndx_and_attrs\");\n\tif (flist != cur_flist) {\n\t\tcur_flist = flist;\n\t\tif (am_sender) {\n\t\t\tfile_old_total = cur_flist->used;\n\t\t\tfor (flist = first_flist; flist != cur_flist; flist = flist->next)\n\t\t\t\tfile_old_total += flist->used;\n\t\t}\n\t}\n\n\tif (iflags & ITEM_BASIS_TYPE_FOLLOWS)\n\t\tfnamecmp_type = read_byte(f_in);\n\t*type_ptr = fnamecmp_type;\n\n\tif (iflags & ITEM_XNAME_FOLLOWS) {\n\t\tif ((len = read_vstring(f_in, buf, MAXPATHLEN)) < 0)\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\n\t\tif (sanitize_paths) {\n\t\t\tsanitize_path(buf, buf, \"\", 0, SP_DEFAULT);\n\t\t\tlen = strlen(buf);\n\t\t}\n\t} else {\n\t\t*buf = '\\0';\n\t\tlen = -1;\n\t}\n\t*len_ptr = len;\n\n\tif (iflags & ITEM_TRANSFER) {\n\t\tint i = ndx - cur_flist->ndx_start;\n\t\tif (i < 0 || !S_ISREG(cur_flist->files[i]->mode)) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"received request to transfer non-regular file: %d [%s]\\n\",\n\t\t\t\tndx, who_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t}\n\n\t*iflag_ptr = iflags;\n\treturn ndx;\n}\n\n/*\n  free a sums struct\n  */\nvoid free_sums(struct sum_struct *s)\n{\n\tif (s->sums) {\n\t\tfree(s->sums);\n\t\tfree(s->sum2_array);\n\t}\n\tfree(s);\n}\n\n/* This is only called when we aren't preserving permissions.  Figure out what\n * the permissions should be and return them merged back into the mode. */\nmode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms,\n\t\t int exists)\n{\n\tint new_mode;\n\t/* If the file already exists, we'll return the local permissions,\n\t * possibly tweaked by the --executability option. */\n\tif (exists) {\n\t\tnew_mode = (flist_mode & ~CHMOD_BITS) | (stat_mode & CHMOD_BITS);\n\t\tif (preserve_executability && S_ISREG(flist_mode)) {\n\t\t\t/* If the source file is executable, grant execute\n\t\t\t * rights to everyone who can read, but ONLY if the\n\t\t\t * file isn't already executable. */\n\t\t\tif (!(flist_mode & 0111))\n\t\t\t\tnew_mode &= ~0111;\n\t\t\telse if (!(stat_mode & 0111))\n\t\t\t\tnew_mode |= (new_mode & 0444) >> 2;\n\t\t}\n\t} else {\n\t\t/* Apply destination default permissions and turn\n\t\t * off special permissions. */\n\t\tnew_mode = flist_mode & (~CHMOD_BITS | dflt_perms);\n\t}\n\treturn new_mode;\n}\n\nstatic int same_mtime(struct file_struct *file, STRUCT_STAT *st, int extra_accuracy)\n{\n#ifdef ST_MTIME_NSEC\n\tuint32 f1_nsec = F_MOD_NSEC_or_0(file);\n\tuint32 f2_nsec = (uint32)st->ST_MTIME_NSEC;\n#else\n\tuint32 f1_nsec = 0, f2_nsec = 0;\n#endif\n\n\tif (extra_accuracy) /* ignore modify_window when setting the time after a transfer or checksum check */\n\t\treturn file->modtime == st->st_mtime && f1_nsec == f2_nsec;\n\n\treturn same_time(file->modtime, f1_nsec, st->st_mtime , f2_nsec);\n}\n\nint set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,\n\t\t   const char *fnamecmp, int flags)\n{\n\tint updated = 0;\n\tstat_x sx2;\n\tint change_uid, change_gid;\n\tmode_t new_mode = file->mode;\n\tint inherit;\n\n\tif (!sxp) {\n\t\tif (dry_run)\n\t\t\treturn 1;\n\t\tif (link_stat(fname, &sx2.st, 0) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"stat %s failed\",\n\t\t\t\tfull_fname(fname));\n\t\t\treturn 0;\n\t\t}\n\t\tinit_stat_x(&sx2);\n\t\tsxp = &sx2;\n\t\tinherit = !preserve_perms;\n\t} else\n\t\tinherit = !preserve_perms && file->flags & FLAG_DIR_CREATED;\n\n\tif (inherit && S_ISDIR(new_mode) && sxp->st.st_mode & S_ISGID) {\n\t\t/* We just created this directory and its setgid\n\t\t * bit is on, so make sure it stays on. */\n\t\tnew_mode |= S_ISGID;\n\t}\n\n\tif (daemon_chmod_modes && !S_ISLNK(new_mode))\n\t\tnew_mode = tweak_mode(new_mode, daemon_chmod_modes);\n\n#ifdef SUPPORT_ACLS\n\tif (preserve_acls && !S_ISLNK(file->mode) && !ACL_READY(*sxp))\n\t\tget_acl(fname, sxp);\n#endif\n\n\tchange_uid = am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file);\n\tchange_gid = gid_ndx && !(file->flags & FLAG_SKIP_GROUP)\n\t\t  && sxp->st.st_gid != (gid_t)F_GROUP(file);\n#ifndef CAN_CHOWN_SYMLINK\n\tif (S_ISLNK(sxp->st.st_mode)) {\n\t\t;\n\t} else\n#endif\n\tif (change_uid || change_gid) {\n\t\tif (DEBUG_GTE(OWN, 1)) {\n\t\t\tif (change_uid) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"set uid of %s from %u to %u\\n\",\n\t\t\t\t\tfname, (unsigned)sxp->st.st_uid, F_OWNER(file));\n\t\t\t}\n\t\t\tif (change_gid) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"set gid of %s from %u to %u\\n\",\n\t\t\t\t\tfname, (unsigned)sxp->st.st_gid, F_GROUP(file));\n\t\t\t}\n\t\t}\n\t\tif (am_root >= 0) {\n\t\t\tuid_t uid = change_uid ? (uid_t)F_OWNER(file) : sxp->st.st_uid;\n\t\t\tgid_t gid = change_gid ? (gid_t)F_GROUP(file) : sxp->st.st_gid;\n\t\t\tif (do_lchown(fname, uid, gid) != 0) {\n\t\t\t\t/* We shouldn't have attempted to change uid\n\t\t\t\t * or gid unless have the privilege. */\n\t\t\t\trsyserr(FERROR_XFER, errno, \"%s %s failed\",\n\t\t\t\t\tchange_uid ? \"chown\" : \"chgrp\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (uid == (uid_t)-1 && sxp->st.st_uid != (uid_t)-1)\n\t\t\t\trprintf(FERROR_XFER, \"uid 4294967295 (-1) is impossible to set on %s\\n\", full_fname(fname));\n\t\t\tif (gid == (gid_t)-1 && sxp->st.st_gid != (gid_t)-1)\n\t\t\t\trprintf(FERROR_XFER, \"gid 4294967295 (-1) is impossible to set on %s\\n\", full_fname(fname));\n\t\t\t/* A lchown had been done, so we need to re-stat if\n\t\t\t * the destination had the setuid or setgid bits set\n\t\t\t * (due to the side effect of the chown call). */\n\t\t\tif (sxp->st.st_mode & (S_ISUID | S_ISGID)) {\n\t\t\t\tlink_stat(fname, &sxp->st,\n\t\t\t\t\t  keep_dirlinks && S_ISDIR(sxp->st.st_mode));\n\t\t\t}\n\t\t}\n\t\tif (change_uid)\n\t\t\tupdated |= UPDATED_OWNER;\n\t\tif (change_gid)\n\t\t\tupdated |= UPDATED_GROUP;\n\t}\n\n#ifdef SUPPORT_XATTRS\n\tif (am_root < 0)\n\t\tset_stat_xattr(fname, file, new_mode);\n\tif (preserve_xattrs && fnamecmp)\n\t\tset_xattr(fname, file, fnamecmp, sxp);\n#endif\n\n\tif ((omit_dir_times && S_ISDIR(sxp->st.st_mode))\n\t || (omit_link_times && S_ISLNK(sxp->st.st_mode)))\n\t\tflags |= ATTRS_SKIP_MTIME | ATTRS_SKIP_ATIME | ATTRS_SKIP_CRTIME;\n\telse {\n\t\tif (!preserve_mtimes)\n\t\t\tflags |= ATTRS_SKIP_MTIME;\n\t\tif (!atimes_ndx || S_ISDIR(sxp->st.st_mode))\n\t\t\tflags |= ATTRS_SKIP_ATIME;\n\t\t/* Don't set the creation date on the root folder of an HFS+ volume. */\n\t\tif (sxp->st.st_ino == 2 && S_ISDIR(sxp->st.st_mode))\n\t\t\tflags |= ATTRS_SKIP_CRTIME;\n\t}\n\tif (sxp != &sx2)\n\t\tmemcpy(&sx2.st, &sxp->st, sizeof sx2.st);\n\tif (!(flags & ATTRS_SKIP_MTIME) && !same_mtime(file, &sxp->st, flags & ATTRS_ACCURATE_TIME)) {\n\t\tsx2.st.st_mtime = file->modtime;\n#ifdef ST_MTIME_NSEC\n\t\tsx2.st.ST_MTIME_NSEC = F_MOD_NSEC_or_0(file);\n#endif\n\t\tupdated |= UPDATED_MTIME;\n\t}\n\tif (!(flags & ATTRS_SKIP_ATIME)) {\n\t\ttime_t file_atime = F_ATIME(file);\n\t\tif (flags & ATTRS_ACCURATE_TIME || !same_time(sxp->st.st_atime, 0, file_atime, 0)) {\n\t\t\tsx2.st.st_atime = file_atime;\n#ifdef ST_ATIME_NSEC\n\t\t\tsx2.st.ST_ATIME_NSEC = 0;\n#endif\n\t\t\tupdated |= UPDATED_ATIME;\n\t\t}\n\t}\n#ifdef SUPPORT_CRTIMES\n\tif (crtimes_ndx && !(flags & ATTRS_SKIP_CRTIME)) {\n\t\ttime_t file_crtime = F_CRTIME(file);\n\t\tif (sxp->crtime == 0)\n\t\t\tsxp->crtime = get_create_time(fname, &sxp->st);\n\t\tif (!same_time(sxp->crtime, 0L, file_crtime, 0L)) {\n\t\t\tif (\n#ifdef HAVE_GETATTRLIST\n\t\t\t     do_setattrlist_crtime(fname, file_crtime) == 0\n#elif defined __CYGWIN__\n\t\t\t     do_SetFileTime(fname, file_crtime) == 0\n#else\n#error Unknown crtimes implementation\n#endif\n\t\t\t)\n\t\t\t\tupdated |= UPDATED_CRTIME;\n\t\t}\n\t}\n#endif\n\tif (updated & (UPDATED_MTIME|UPDATED_ATIME)) {\n\t\tint ret = set_times(fname, &sx2.st);\n\t\tif (ret < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"failed to set times on %s\", full_fname(fname));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (ret > 0) { /* ret == 1 if symlink could not be set */\n\t\t\tupdated &= ~(UPDATED_MTIME|UPDATED_ATIME);\n\t\t\tfile->flags |= FLAG_TIME_FAILED;\n\t\t}\n\t}\n\n#ifdef SUPPORT_ACLS\n\t/* It's OK to call set_acl() now, even for a dir, as the generator\n\t * will enable owner-writability using chmod, if necessary.\n\t *\n\t * If set_acl() changes permission bits in the process of setting\n\t * an access ACL, it changes sxp->st.st_mode so we know whether we\n\t * need to chmod(). */\n\tif (preserve_acls && !S_ISLNK(new_mode)) {\n\t\tif (set_acl(fname, file, sxp, new_mode) > 0)\n\t\t\tupdated |= UPDATED_ACLS;\n\t}\n#endif\n\n#ifdef HAVE_CHMOD\n\tif (!BITS_EQUAL(sxp->st.st_mode, new_mode, CHMOD_BITS)) {\n\t\tint ret = am_root < 0 ? 0 : do_chmod(fname, new_mode);\n\t\tif (ret < 0) {\n\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\"failed to set permissions on %s\",\n\t\t\t\tfull_fname(fname));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (ret == 0) /* ret == 1 if symlink could not be set */\n\t\t\tupdated |= UPDATED_MODE;\n\t}\n#endif\n\n\tif (INFO_GTE(NAME, 2) && flags & ATTRS_REPORT) {\n\t\tif (updated)\n\t\t\trprintf(FCLIENT, \"%s\\n\", fname);\n\t\telse\n\t\t\trprintf(FCLIENT, \"%s is uptodate\\n\", fname);\n\t}\n  cleanup:\n\tif (sxp == &sx2)\n\t\tfree_stat_x(&sx2);\n\treturn updated;\n}\n\n/* This is only called for SIGINT, SIGHUP, and SIGTERM. */\nvoid sig_int(int sig_num)\n{\n\tcalled_from_signal_handler = 1;\n\n\t/* KLUGE: if the user hits Ctrl-C while ssh is prompting\n\t * for a password, then our cleanup's sending of a SIGUSR1\n\t * signal to all our children may kill ssh before it has a\n\t * chance to restore the tty settings (i.e. turn echo back\n\t * on).  By sleeping for a short time, ssh gets a bigger\n\t * chance to do the right thing.  If child processes are\n\t * not ssh waiting for a password, then this tiny delay\n\t * shouldn't hurt anything. */\n\tmsleep(400);\n\n\t/* If we're an rsync daemon listener (not a daemon server),\n\t * we'll exit with status 0 if we received SIGTERM. */\n\tif (am_daemon && !am_server && sig_num == SIGTERM)\n\t\texit_cleanup(0);\n\n\t/* If the signal arrived on the server side (or for the receiver\n\t * process on the client), we want to try to do a controlled shutdown\n\t * that lets the client side (generator process) know what happened.\n\t * To do this, we set a flag and let the normal process handle the\n\t * shutdown.  We only attempt this if multiplexed IO is in effect and\n\t * we didn't already set the flag. */\n\tif (!got_kill_signal && (am_server || am_receiver)) {\n\t\tgot_kill_signal = sig_num;\n\t\tcalled_from_signal_handler = 0;\n\t\treturn;\n\t}\n\n\texit_cleanup(RERR_SIGNAL);\n}\n\n/* Finish off a file transfer: renaming the file and setting the file's\n * attributes (e.g. permissions, ownership, etc.).  If the robust_rename()\n * call is forced to copy the temp file and partialptr is both non-NULL and\n * not an absolute path, we stage the file into the partial-dir and then\n * rename it into place.  This returns 1 on success or 0 on failure. */\nint finish_transfer(const char *fname, const char *fnametmp,\n\t\t    const char *fnamecmp, const char *partialptr,\n\t\t    struct file_struct *file, int ok_to_set_time,\n\t\t    int overwriting_basis)\n{\n\tint ret;\n\tconst char *temp_copy_name = partialptr && *partialptr != '/' ? partialptr : NULL;\n\n\tif (inplace) {\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO, \"finishing %s\\n\", fname);\n\t\tfnametmp = fname;\n\t\tgoto do_set_file_attrs;\n\t}\n\n\tif (make_backups > 0 && overwriting_basis) {\n\t\tint ok = make_backup(fname, False);\n\t\tif (!ok)\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\tif (ok == 1 && fnamecmp == fname)\n\t\t\tfnamecmp = get_backup_name(fname);\n\t}\n\n\t/* Change permissions before putting the file into place. */\n\tset_file_attrs(fnametmp, file, NULL, fnamecmp,\n\t\t       ok_to_set_time ? ATTRS_ACCURATE_TIME : ATTRS_SKIP_MTIME | ATTRS_SKIP_ATIME | ATTRS_SKIP_CRTIME);\n\n\t/* move tmp file over real file */\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"renaming %s to %s\\n\", fnametmp, fname);\n\tret = robust_rename(fnametmp, fname, temp_copy_name, file->mode);\n\tif (ret < 0) {\n\t\trsyserr(FERROR_XFER, errno, \"%s %s -> \\\"%s\\\"\",\n\t\t\tret == -2 ? \"copy\" : \"rename\",\n\t\t\tfull_fname(fnametmp), fname);\n\t\tif (!partialptr || (ret == -2 && temp_copy_name)\n\t\t || robust_rename(fnametmp, partialptr, NULL, file->mode) < 0)\n\t\t\tdo_unlink(fnametmp);\n\t\treturn 0;\n\t}\n\tif (ret == 0) {\n\t\t/* The file was moved into place (not copied), so it's done. */\n\t\treturn 1;\n\t}\n\t/* The file was copied, so tweak the perms of the copied file.  If it\n\t * was copied to partialptr, move it into its final destination. */\n\tfnametmp = temp_copy_name ? temp_copy_name : fname;\n\n  do_set_file_attrs:\n\tset_file_attrs(fnametmp, file, NULL, fnamecmp,\n\t\t       ok_to_set_time ? ATTRS_ACCURATE_TIME : ATTRS_SKIP_MTIME | ATTRS_SKIP_ATIME | ATTRS_SKIP_CRTIME);\n\n\tif (temp_copy_name) {\n\t\tif (do_rename(fnametmp, fname) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"rename %s -> \\\"%s\\\"\",\n\t\t\t\tfull_fname(fnametmp), fname);\n\t\t\treturn 0;\n\t\t}\n\t\thandle_partial_dir(temp_copy_name, PDIR_DELETE);\n\t}\n\treturn 1;\n}\n\nstruct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc)\n{\n\tstruct file_list *flist = cur_flist;\n\n\tif (!flist && !(flist = first_flist))\n\t\tgoto not_found;\n\n\twhile (ndx < flist->ndx_start-1) {\n\t\tif (flist == first_flist)\n\t\t\tgoto not_found;\n\t\tflist = flist->prev;\n\t}\n\twhile (ndx >= flist->ndx_start + flist->used) {\n\t\tif (!(flist = flist->next))\n\t\t\tgoto not_found;\n\t}\n\treturn flist;\n\n  not_found:\n\tif (fatal_error_loc) {\n\t\tint first, last;\n\t\tif (first_flist) {\n\t\t\tfirst = first_flist->ndx_start - 1;\n\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tlast = -1;\n\t\t}\n\t\trprintf(FERROR,\n\t\t\t\"File-list index %d not in %d - %d (%s) [%s]\\n\",\n\t\t\tndx, first, last, fatal_error_loc, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\treturn NULL;\n}\n\nconst char *who_am_i(void)\n{\n\tif (am_starting_up)\n\t\treturn am_server ? \"server\" : \"client\";\n\treturn am_sender ? \"sender\"\n\t     : am_generator ? \"generator\"\n\t     : am_receiver ? \"receiver\"\n\t     : \"Receiver\"; /* pre-forked receiver */\n}\n"
        },
        {
          "name": "rsync.h",
          "type": "blob",
          "size": 41.2880859375,
          "content": "/*\n * Copyright (C) 1996, 2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#define False 0\n#define True 1\n#define Unset (-1) /* Our BOOL values are always an int. */\n\n#define BLOCK_SIZE 700\n#define RSYNC_RSH_ENV \"RSYNC_RSH\"\n#define RSYNC_RSH_IO_ENV \"RSYNC_RSH_IO\"\n\n#define RSYNC_NAME \"rsync\"\n/* RSYNCD_SYSCONF is now set in config.h */\n#define RSYNCD_USERCONF \"rsyncd.conf\"\n\n#define DEFAULT_LOCK_FILE \"/var/run/rsyncd.lock\"\n#define URL_PREFIX \"rsync://\"\n\n#define SYMLINK_PREFIX \"/rsyncd-munged/\"  /* This MUST have a trailing slash! */\n#define SYMLINK_PREFIX_LEN ((int)sizeof SYMLINK_PREFIX - 1)\n\n#define BACKUP_SUFFIX \"~\"\n\n/* a non-zero CHAR_OFFSET makes the rolling sum stronger, but is\n   incompatible with older versions :-( */\n#define CHAR_OFFSET 0\n\n/* These flags are only used during the flist transfer. */\n\n#define XMIT_TOP_DIR (1<<0)\n#define XMIT_SAME_MODE (1<<1)\n#define XMIT_SAME_RDEV_pre28 (1<<2)\t/* protocols 20 - 27  */\n#define XMIT_EXTENDED_FLAGS (1<<2)\t/* protocols 28 - now */\n#define XMIT_SAME_UID (1<<3)\n#define XMIT_SAME_GID (1<<4)\n#define XMIT_SAME_NAME (1<<5)\n#define XMIT_LONG_NAME (1<<6)\n#define XMIT_SAME_TIME (1<<7)\n\n#define XMIT_SAME_RDEV_MAJOR (1<<8)\t/* protocols 28 - now (devices only) */\n#define XMIT_NO_CONTENT_DIR (1<<8)\t/* protocols 30 - now (dirs only) */\n#define XMIT_HLINKED (1<<9)\t\t/* protocols 28 - now (non-dirs) */\n#define XMIT_SAME_DEV_pre30 (1<<10)\t/* protocols 28 - 29  */\n#define XMIT_USER_NAME_FOLLOWS (1<<10)\t/* protocols 30 - now */\n#define XMIT_RDEV_MINOR_8_pre30 (1<<11) /* protocols 28 - 29  */\n#define XMIT_GROUP_NAME_FOLLOWS (1<<11) /* protocols 30 - now */\n#define XMIT_HLINK_FIRST (1<<12)\t/* protocols 30 - now (HLINKED files only) */\n#define XMIT_IO_ERROR_ENDLIST (1<<12)\t/* protocols 31*- now (w/XMIT_EXTENDED_FLAGS) (also protocol 30 w/'f' compat flag) */\n#define XMIT_MOD_NSEC (1<<13)\t\t/* protocols 31 - now */\n#define XMIT_SAME_ATIME (1<<14) \t/* any protocol - restricted by command-line option */\n#define XMIT_UNUSED_15 (1<<15)  \t/* unused flag bit */\n\n/* The following XMIT flags require an rsync that uses a varint for the flag values */\n\n#define XMIT_RESERVED_16 (1<<16) \t/* reserved for future fileflags use */\n#define XMIT_CRTIME_EQ_MTIME (1<<17)\t/* any protocol - restricted by command-line option */\n\n/* These flags are used in the live flist data. */\n\n#define FLAG_TOP_DIR (1<<0)\t/* sender/receiver/generator */\n#define FLAG_OWNED_BY_US (1<<0) /* generator: set by make_file() for aux flists only */\n#define FLAG_FILE_SENT (1<<1)\t/* sender/receiver/generator */\n#define FLAG_DIR_CREATED (1<<1)\t/* generator */\n#define FLAG_CONTENT_DIR (1<<2)\t/* sender/receiver/generator */\n#define FLAG_MOUNT_DIR (1<<3)\t/* sender/generator (dirs only) */\n#define FLAG_SKIP_HLINK (1<<3)\t/* receiver/generator (w/FLAG_HLINKED) */\n#define FLAG_DUPLICATE (1<<4)\t/* sender */\n#define FLAG_MISSING_DIR (1<<4)\t/* generator */\n#define FLAG_HLINKED (1<<5)\t/* receiver/generator (checked on all types) */\n#define FLAG_HLINK_FIRST (1<<6)\t/* receiver/generator (w/FLAG_HLINKED) */\n#define FLAG_IMPLIED_DIR (1<<6)\t/* sender/receiver/generator (dirs only) */\n#define FLAG_HLINK_LAST (1<<7)\t/* receiver/generator */\n#define FLAG_HLINK_DONE (1<<8)\t/* receiver/generator (checked on all types) */\n#define FLAG_LENGTH64 (1<<9)\t/* sender/receiver/generator */\n#define FLAG_SKIP_GROUP (1<<10)\t/* receiver/generator */\n#define FLAG_TIME_FAILED (1<<11)/* generator */\n#define FLAG_MOD_NSEC (1<<12)\t/* sender/receiver/generator */\n\n/* These flags are passed to functions but not stored. */\n\n#define FLAG_DIVERT_DIRS (1<<16)   /* sender, but must be unique */\n#define FLAG_PERHAPS_DIR (1<<17)   /* generator */\n\n/* These flags are for get_dirlist(). */\n#define GDL_IGNORE_FILTER_RULES (1<<0)\n#define GDL_PERHAPS_DIR (1<<1)\n\n/* Some helper macros for matching bits. */\n#define BITS_SET(val,bits) (((val) & (bits)) == (bits))\n#define BITS_SETnUNSET(val,onbits,offbits) (((val) & ((onbits)|(offbits))) == (onbits))\n#define BITS_EQUAL(b1,b2,mask) (((unsigned)(b1) & (unsigned)(mask)) \\\n\t\t\t     == ((unsigned)(b2) & (unsigned)(mask)))\n\n/* Update this if you make incompatible changes and ALSO update the\n * SUBPROTOCOL_VERSION if it is not a final (official) release. */\n#define PROTOCOL_VERSION 31\n\n/* This is used when working on a new protocol version or for any unofficial\n * protocol tweaks.  It should be a non-zero value for each pre-release repo\n * change that affects the protocol. The official pre-release versions should\n * start with 1 (after incrementing the PROTOCOL_VERSION) and go up by 1 for\n * each new protocol change.  For unofficial changes, pick a fairly large\n * random number that will hopefully not collide with anyone else's unofficial\n * protocol.  It must ALWAYS be 0 when the protocol goes final (and official)\n * and NEVER before!  When rsync negotiates a protocol match, it will only\n * allow the newest protocol to be used if the SUBPROTOCOL_VERSION matches.\n * All older protocol versions MUST be compatible with the final, official\n * release of the protocol, so don't tweak the code to change the protocol\n * behavior for an older protocol version. */\n#define SUBPROTOCOL_VERSION 0\n\n/* We refuse to interoperate with versions that are not in this range.\n * Note that we assume we'll work with later versions: the onus is on\n * people writing them to make sure that they don't send us anything\n * we won't understand.\n *\n * Interoperation with old but supported protocol versions\n * should cause a warning to be printed.  At a future date\n * the old protocol will become the minimum and\n * compatibility code removed.\n *\n * There are two possible explanations for the limit at\n * MAX_PROTOCOL_VERSION: either to allow new major-rev versions that\n * do not interoperate with us, and (more likely) so that we can\n * detect an attempt to connect rsync to a non-rsync server, which is\n * unlikely to begin by sending a byte between MIN_PROTOCL_VERSION and\n * MAX_PROTOCOL_VERSION. */\n\n#define MIN_PROTOCOL_VERSION 20\n#define OLD_PROTOCOL_VERSION 25\n#define MAX_PROTOCOL_VERSION 40\n\n#define MIN_FILECNT_LOOKAHEAD 1000\n#define MAX_FILECNT_LOOKAHEAD 10000\n\n#define RSYNC_PORT 873\n\n#define SPARSE_WRITE_SIZE (1024)\n#define WRITE_SIZE (32*1024)\n#define CHUNK_SIZE (32*1024)\n#define MAX_MAP_SIZE (256*1024)\n#define IO_BUFFER_SIZE (32*1024)\n#define MAX_BLOCK_SIZE ((int32)1 << 17)\n\n/* For compatibility with older rsyncs */\n#define OLD_MAX_BLOCK_SIZE ((int32)1 << 29)\n\n#define ROUND_UP_1024(siz) ((siz) & (1024-1) ? ((siz) | (1024-1)) + 1 : (siz))\n\n#define IOERR_GENERAL\t(1<<0) /* For backward compatibility, this must == 1 */\n#define IOERR_VANISHED\t(1<<1)\n#define IOERR_DEL_LIMIT (1<<2)\n\n#define MAX_ARGS 1000\n#define MAX_BASIS_DIRS 20\n#define MAX_SERVER_ARGS (MAX_BASIS_DIRS*2 + 100)\n\n#define COMPARE_DEST 1\n#define COPY_DEST 2\n#define LINK_DEST 3\n\n#define MPLEX_BASE 7\n\n#define NO_FILTERS\t0\n#define SERVER_FILTERS\t1\n#define ALL_FILTERS\t2\n\n#define XFLG_FATAL_ERRORS\t(1<<0)\n#define XFLG_OLD_PREFIXES\t(1<<1)\n#define XFLG_ANCHORED2ABS\t(1<<2) /* leading slash indicates absolute */\n#define XFLG_ABS_IF_SLASH\t(1<<3) /* leading or interior slash is absolute */\n#define XFLG_DIR2WILD3\t\t(1<<4) /* dir/ match gets trailing *** added */\n\n#define ATTRS_REPORT\t\t(1<<0)\n#define ATTRS_SKIP_MTIME\t(1<<1)\n#define ATTRS_ACCURATE_TIME\t(1<<2)\n#define ATTRS_SKIP_ATIME\t(1<<3)\n#define ATTRS_SKIP_CRTIME\t(1<<5)\n\n#define MSG_FLUSH\t2\n#define FULL_FLUSH\t1\n#define NORMAL_FLUSH\t0\n\n#define PDIR_CREATE\t1\n#define PDIR_DELETE\t0\n\n/* Note: 0x00 - 0x7F are used for basis_dir[] indexes! */\n#define FNAMECMP_BASIS_DIR_LOW\t0x00 /* Must remain 0! */\n#define FNAMECMP_BASIS_DIR_HIGH 0x7F\n#define FNAMECMP_FNAME\t\t0x80\n#define FNAMECMP_PARTIAL_DIR\t0x81\n#define FNAMECMP_BACKUP \t0x82\n#define FNAMECMP_FUZZY\t\t0x83\n\n/* For use by the itemize_changes code */\n#define ITEM_REPORT_ATIME (1<<0)\n#define ITEM_REPORT_CHANGE (1<<1)\n#define ITEM_REPORT_SIZE (1<<2)     /* regular files only */\n#define ITEM_REPORT_TIMEFAIL (1<<2) /* symlinks only */\n#define ITEM_REPORT_TIME (1<<3)\n#define ITEM_REPORT_PERMS (1<<4)\n#define ITEM_REPORT_OWNER (1<<5)\n#define ITEM_REPORT_GROUP (1<<6)\n#define ITEM_REPORT_ACL (1<<7)\n#define ITEM_REPORT_XATTR (1<<8)\n#define ITEM_REPORT_CRTIME (1<<10)\n#define ITEM_BASIS_TYPE_FOLLOWS (1<<11)\n#define ITEM_XNAME_FOLLOWS (1<<12)\n#define ITEM_IS_NEW (1<<13)\n#define ITEM_LOCAL_CHANGE (1<<14)\n#define ITEM_TRANSFER (1<<15)\n/* These are outside the range of the transmitted flags. */\n#define ITEM_MISSING_DATA (1<<16)\t   /* used by log_formatted() */\n#define ITEM_DELETED (1<<17)\t\t   /* used by log_formatted() */\n#define ITEM_MATCHED (1<<18)\t\t   /* used by itemize() */\n\n#define SIGNIFICANT_ITEM_FLAGS (~(\\\n\tITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))\n\n#define CFN_KEEP_DOT_DIRS (1<<0)\n#define CFN_KEEP_TRAILING_SLASH (1<<1)\n#define CFN_DROP_TRAILING_DOT_DIR (1<<2)\n#define CFN_COLLAPSE_DOT_DOT_DIRS (1<<3)\n#define CFN_REFUSE_DOT_DOT_DIRS (1<<4)\n\n#define SP_DEFAULT 0\n#define SP_KEEP_DOT_DIRS (1<<0)\n\n#define CD_NORMAL 0\n#define CD_SKIP_CHDIR 1\n\n/* Log-message categories.  FLOG only goes to the log file, not the client;\n * FCLIENT is the opposite. */\nenum logcode {\n    FNONE=0, /* never sent */\n    FERROR_XFER=1, FINFO=2, /* sent over socket for any protocol */\n    FERROR=3, FWARNING=4, /* sent over socket for protocols >= 30 */\n    FERROR_SOCKET=5, FLOG=6, /* only sent via receiver -> generator pipe */\n    FERROR_UTF8=8, /* only sent via receiver -> generator pipe */\n    FCLIENT=7 /* never transmitted (e.g. server converts to FINFO) */\n};\n\n/* Messages types that are sent over the message channel.  The logcode\n * values must all be present here with identical numbers. */\nenum msgcode {\n\tMSG_DATA=0,\t/* raw data on the multiplexed stream */\n\tMSG_ERROR_XFER=FERROR_XFER, MSG_INFO=FINFO, /* remote logging */\n\tMSG_ERROR=FERROR, MSG_WARNING=FWARNING, /* protocol-30 remote logging */\n\tMSG_ERROR_SOCKET=FERROR_SOCKET, /* sibling logging */\n\tMSG_ERROR_UTF8=FERROR_UTF8, /* sibling logging */\n\tMSG_LOG=FLOG, MSG_CLIENT=FCLIENT, /* sibling logging */\n\tMSG_REDO=9,\t/* reprocess indicated flist index */\n\tMSG_STATS=10,\t/* message has stats data for generator */\n\tMSG_IO_ERROR=22,/* the sending side had an I/O error */\n\tMSG_IO_TIMEOUT=33,/* tell client about a daemon's timeout value */\n\tMSG_NOOP=42,\t/* a do-nothing message (legacy protocol-30 only) */\n\tMSG_ERROR_EXIT=86, /* synchronize an error exit (siblings and protocol >= 31) */\n\tMSG_SUCCESS=100,/* successfully updated indicated flist index */\n\tMSG_DELETED=101,/* successfully deleted a file on receiving side */\n\tMSG_NO_SEND=102,/* sender failed to open a file we wanted */\n};\n\nenum filetype {\n\tFT_UNSUPPORTED, FT_REG, FT_DIR, FT_SYMLINK, FT_SPECIAL, FT_DEVICE\n};\n\n#define NDX_DONE -1\n#define NDX_FLIST_EOF -2\n#define NDX_DEL_STATS -3\n#define NDX_FLIST_OFFSET -101\n\n/* For calling delete_item() and delete_dir_contents(). */\n#define DEL_NO_UID_WRITE \t(1<<0) /* file/dir has our uid w/o write perm */\n#define DEL_RECURSE\t\t(1<<1) /* if dir, delete all contents */\n#define DEL_DIR_IS_EMPTY\t(1<<2) /* internal delete_FUNCTIONS use only */\n#define DEL_FOR_FILE\t\t(1<<3) /* making room for a replacement file */\n#define DEL_FOR_DIR\t\t(1<<4) /* making room for a replacement dir */\n#define DEL_FOR_SYMLINK \t(1<<5) /* making room for a replacement symlink */\n#define DEL_FOR_DEVICE\t\t(1<<6) /* making room for a replacement device */\n#define DEL_FOR_SPECIAL \t(1<<7) /* making room for a replacement special */\n#define DEL_FOR_BACKUP\t \t(1<<8) /* the delete is for a backup operation */\n\n#define DEL_MAKE_ROOM (DEL_FOR_FILE|DEL_FOR_DIR|DEL_FOR_SYMLINK|DEL_FOR_DEVICE|DEL_FOR_SPECIAL)\n\nenum delret {\n\tDR_SUCCESS = 0, DR_FAILURE, DR_AT_LIMIT, DR_NOT_EMPTY\n};\n\n/* Defines for make_path() */\n#define MKP_DROP_NAME\t\t(1<<0) /* drop trailing filename or trailing slash */\n#define MKP_SKIP_SLASH\t\t(1<<1) /* skip one or more leading slashes */\n\n/* Defines for maybe_send_keepalive() */\n#define MSK_ALLOW_FLUSH \t(1<<0)\n#define MSK_ACTIVE_RECEIVER \t(1<<1)\n\n#include \"errcode.h\"\n\n#include \"config.h\"\n\n/* The default RSYNC_RSH is always set in config.h. */\n\n#include <stdio.h>\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#else\n# ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif\n#ifdef HAVE_STRING_H\n# if !defined STDC_HEADERS && defined HAVE_MEMORY_H\n#  include <memory.h>\n# endif\n# include <string.h>\n#endif\n#ifdef HAVE_BSD_STRING_H\n# include <bsd/string.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#if defined HAVE_MALLOC_H && (defined HAVE_MALLINFO || !defined HAVE_STDLIB_H)\n#include <malloc.h>\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <time.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#else\n#ifdef HAVE_SYS_FCNTL_H\n#include <sys/fcntl.h>\n#endif\n#endif\n\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_SYS_FILIO_H\n#include <sys/filio.h>\n#endif\n\n#include <signal.h>\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n#ifdef HAVE_CTYPE_H\n#include <ctype.h>\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#include <errno.h>\n\n#ifdef HAVE_UTIME_H\n#include <utime.h>\n#endif\n\n#if defined HAVE_UTIMENSAT || defined HAVE_LUTIMES || defined HAVE_SETATTRLIST\n#define CAN_SET_SYMLINK_TIMES 1\n#endif\n\n#if defined HAVE_LCHOWN || defined CHOWN_MODIFIES_SYMLINK\n#define CAN_CHOWN_SYMLINK 1\n#endif\n\n#if defined HAVE_LCHMOD || defined HAVE_SETATTRLIST\n#define CAN_CHMOD_SYMLINK 1\n#endif\n\n#if defined HAVE_UTIMENSAT || defined HAVE_SETATTRLIST\n#define CAN_SET_NSEC 1\n#endif\n\n#ifdef CAN_SET_NSEC\n#ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n#define ST_MTIME_NSEC st_mtim.tv_nsec\n#define ST_ATIME_NSEC st_atim.tv_nsec\n#elif defined(HAVE_STRUCT_STAT_ST_MTIMENSEC)\n#define ST_MTIME_NSEC st_mtimensec\n#define ST_ATIME_NSEC st_atimensec\n#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC)\n#define ST_MTIME_NSEC st_mtimespec.tv_nsec\n#define ST_ATIME_NSEC st_atimespec.tv_nsec\n#endif\n#endif\n\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#ifdef HAVE_SYS_MODE_H\n/* apparently AIX needs this for S_ISLNK */\n#ifndef S_ISLNK\n#include <sys/mode.h>\n#endif\n#endif\n\n/* these are needed for the uid/gid mapping code */\n#include <pwd.h>\n#include <grp.h>\n\n#include <stdarg.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#include <syslog.h>\n#ifdef HAVE_SYS_FILE_H\n#include <sys/file.h>\n#endif\n\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n#else\n# define dirent direct\n# ifdef HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# ifdef HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# ifdef HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n\n#ifdef MAJOR_IN_MKDEV\n#include <sys/mkdev.h>\n# if !defined makedev && (defined mkdev || defined _WIN32 || defined __WIN32__)\n#  define makedev mkdev\n# endif\n#elif defined MAJOR_IN_SYSMACROS\n#include <sys/sysmacros.h>\n#endif\n\n#ifdef MAKEDEV_TAKES_3_ARGS\n#define MAKEDEV(devmajor,devminor) makedev(0,devmajor,devminor)\n#else\n#ifndef __TANDEM\n#define MAKEDEV(devmajor,devminor) makedev(devmajor,devminor)\n#else\n# define major DEV_TO_MAJOR\n# define minor DEV_TO_MINOR\n# define MAKEDEV MAJORMINOR_TO_DEV\n#endif\n#endif\n\n#ifdef __TANDEM\n# include <floss.h(floss_read,floss_write,floss_fork,floss_execvp)>\n# include <floss.h(floss_getpwuid,floss_select,floss_seteuid)>\n# define S_IEXEC S_IXUSR\n# define ROOT_UID 65535\n#else\n# define ROOT_UID 0\n#endif\n\n#ifdef HAVE_COMPAT_H\n#include <compat.h>\n#endif\n\n#ifdef HAVE_LIMITS_H\n# include <limits.h>\n#endif\n\n#if defined USE_ICONV_OPEN && defined HAVE_ICONV_H\n#include <iconv.h>\n#ifndef ICONV_CONST\n#define ICONV_CONST\n#endif\n#else\n#ifdef ICONV_CONST\n#undef ICONV_CONST\n#endif\n#ifdef ICONV_OPTION\n#undef ICONV_OPTION\n#endif\n#ifdef iconv_t\n#undef iconv_t\n#endif\n#define iconv_t int\n#endif\n\n#include <assert.h>\n\n#include \"lib/pool_alloc.h\"\n\n#ifndef HAVE_ID_T\ntypedef unsigned int id_t;\n#endif\n#ifndef HAVE_PID_T\ntypedef int pid_t;\n#endif\n#ifndef HAVE_MODE_T\ntypedef unsigned int mode_t;\n#endif\n#ifndef HAVE_OFF_T\ntypedef long off_t;\n#undef SIZEOF_OFF_T\n#define SIZEOF_OFF_T SIZEOF_LONG\n#endif\n#ifndef HAVE_SIZE_T\ntypedef unsigned int size_t;\n#endif\n\n#define BOOL int\n\n#ifndef uchar\n#define uchar unsigned char\n#endif\n\n#ifdef SIGNED_CHAR_OK\n#define schar signed char\n#else\n#define schar char\n#endif\n\n#ifndef int16\n#if SIZEOF_INT16_T == 2\n# define int16 int16_t\n#else\n# define int16 short\n#endif\n#endif\n\n#ifndef uint16\n#if SIZEOF_UINT16_T == 2\n# define uint16 uint16_t\n#else\n# define uint16 unsigned int16\n#endif\n#endif\n\n#if !defined __APPLE__ || defined HAVE_GETATTRLIST\n#define SUPPORT_ATIMES 1\n#endif\n\n#if defined HAVE_GETATTRLIST || defined __CYGWIN__\n#define SUPPORT_CRTIMES 1\n#endif\n\n/* Find a variable that is either exactly 32-bits or longer.\n * If some code depends on 32-bit truncation, it will need to\n * take special action in a \"#if SIZEOF_INT32 > 4\" section. */\n#ifndef int32\n#if SIZEOF_INT32_T == 4\n# define int32 int32_t\n# define SIZEOF_INT32 4\n#elif SIZEOF_INT == 4\n# define int32 int\n# define SIZEOF_INT32 4\n#elif SIZEOF_LONG == 4\n# define int32 long\n# define SIZEOF_INT32 4\n#elif SIZEOF_SHORT == 4\n# define int32 short\n# define SIZEOF_INT32 4\n#elif SIZEOF_INT > 4\n# define int32 int\n# define SIZEOF_INT32 SIZEOF_INT\n#elif SIZEOF_LONG > 4\n# define int32 long\n# define SIZEOF_INT32 SIZEOF_LONG\n#else\n# error Could not find a 32-bit integer variable\n#endif\n#else\n# define SIZEOF_INT32 4\n#endif\n\n#ifndef uint32\n#if SIZEOF_UINT32_T == 4\n# define uint32 uint32_t\n#else\n# define uint32 unsigned int32\n#endif\n#endif\n\n#if SIZEOF_OFF_T == 8 || !SIZEOF_OFF64_T || !defined HAVE_STRUCT_STAT64\n#define OFF_T off_t\n#define STRUCT_STAT struct stat\n#define SIZEOF_CAPITAL_OFF_T SIZEOF_OFF_T\n#else\n#define OFF_T off64_t\n#define STRUCT_STAT struct stat64\n#define USE_STAT64_FUNCS 1\n#define SIZEOF_CAPITAL_OFF_T SIZEOF_OFF64_T\n#endif\n\n/* CAVEAT: on some systems, int64 will really be a 32-bit integer IFF\n * that's the maximum size the file system can handle and there is no\n * 64-bit type available.  The rsync source must therefore take steps\n * to ensure that any code that really requires a 64-bit integer has\n * it (e.g. the checksum code uses two 32-bit integers for its 64-bit\n * counter). */\n#if SIZEOF_INT64_T == 8\n# define int64 int64_t\n# define SIZEOF_INT64 8\n#elif SIZEOF_LONG == 8\n# define int64 long\n# define SIZEOF_INT64 8\n#elif SIZEOF_INT == 8\n# define int64 int\n# define SIZEOF_INT64 8\n#elif SIZEOF_LONG_LONG == 8\n# define int64 long long\n# define SIZEOF_INT64 8\n#elif SIZEOF_OFF64_T == 8\n# define int64 off64_t\n# define SIZEOF_INT64 8\n#elif SIZEOF_OFF_T == 8\n# define int64 off_t\n# define SIZEOF_INT64 8\n#elif SIZEOF_INT > 8\n# define int64 int\n# define SIZEOF_INT64 SIZEOF_INT\n#elif SIZEOF_LONG > 8\n# define int64 long\n# define SIZEOF_INT64 SIZEOF_LONG\n#elif SIZEOF_LONG_LONG > 8\n# define int64 long long\n# define SIZEOF_INT64 SIZEOF_LONG_LONG\n#else\n/* As long as it gets... */\n# define int64 off_t\n# define SIZEOF_INT64 SIZEOF_OFF_T\n#endif\n\n#define HT_KEY32 0\n#define HT_KEY64 1\n\nstruct hashtable {\n\tvoid *nodes;\n\tint32 size, entries;\n\tuint32 node_size;\n\tshort key64;\n};\n\nstruct ht_int32_node {\n\tvoid *data;\n\tint32 key;\n};\n\nstruct ht_int64_node {\n\tvoid *data;\n\tint64 key;\n};\n\n#define HT_NODE(tbl, bkts, i) ((void*)((char*)(bkts) + (i)*(tbl)->node_size))\n#define HT_KEY(node, k64) ((k64)? ((struct ht_int64_node*)(node))->key \\\n\t\t\t : (int64)((struct ht_int32_node*)(node))->key)\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 256\n#endif\n\n#define SUM_LENGTH 16\n#define SHORT_SUM_LENGTH 2\n#define BLOCKSUM_BIAS 10\n\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\n/* We want a roomy line buffer that can hold more than MAXPATHLEN,\n * and significantly more than an overly short MAXPATHLEN. */\n#if MAXPATHLEN < 4096\n#define BIGPATHBUFLEN (4096+1024)\n#else\n#define BIGPATHBUFLEN (MAXPATHLEN+1024)\n#endif\n\n#ifndef NAME_MAX\n#define NAME_MAX 255\n#endif\n\n#ifndef SIZE_MAX\n#define SIZE_MAX ((size_t)-1)\n#endif\n\n#ifndef INADDR_NONE\n#define INADDR_NONE 0xffffffff\n#endif\n\n#ifndef IN_LOOPBACKNET\n#define IN_LOOPBACKNET 127\n#endif\n\n#if HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS\n#define ACLS_NEED_MASK 1\n#endif\n\n#if defined HAVE_FALLOCATE || HAVE_SYS_FALLOCATE\n#ifdef HAVE_LINUX_FALLOC_H\n#include <linux/falloc.h>\n#endif\n#ifdef FALLOC_FL_KEEP_SIZE\n#define SUPPORT_PREALLOCATION 1\n#elif defined HAVE_FTRUNCATE\n#define SUPPORT_PREALLOCATION 1\n#define PREALLOCATE_NEEDS_TRUNCATE 1\n#endif\n#else /* !fallocate */\n#if defined HAVE_EFFICIENT_POSIX_FALLOCATE && defined HAVE_FTRUNCATE\n#define SUPPORT_PREALLOCATION 1\n#define PREALLOCATE_NEEDS_TRUNCATE 1\n#endif\n#endif\n\n#if SIZEOF_CHARP == 4\n# define PTRS_ARE_32 1\n# define PTR_EXTRA_CNT 1\n#elif SIZEOF_CHARP == 8\n# define PTRS_ARE_64 1\n# define PTR_EXTRA_CNT EXTRA64_CNT\n#else\n# error Character pointers are not 4 or 8 bytes.\n#endif\n\n#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#define USE_FLEXIBLE_ARRAY 1\n#define SIZE_T_FMT_MOD \"z\" /* printf supports %zd */\n#define SIZE_T_FMT_CAST size_t\n#else\n#define SIZE_T_FMT_MOD \"l\" /* printf supports %ld */\n#define SIZE_T_FMT_CAST long\n#endif\n\nunion file_extras {\n\tint32 num;\n\tuint32 unum;\n#ifdef PTRS_ARE_32\n\tconst char* ptr;\n#endif\n};\n\nunion file_extras64 {\n\tint64 num;\n#ifdef PTRS_ARE_64\n\tconst char* ptr;\n#endif\n};\n\nstruct file_struct {\n\tconst char *dirname;\t/* The dir info inside the transfer */\n\ttime_t modtime;\t\t/* When the item was last modified */\n\tuint32 len32;\t\t/* Lowest 32 bits of the file's length */\n\tuint16 mode;\t\t/* The item's type and permissions */\n\tuint16 flags;\t\t/* The FLAG_* bits for this item */\n#ifdef USE_FLEXIBLE_ARRAY\n\tconst char basename[];\t/* The basename (AKA filename) follows */\n#else\n\tconst char basename[1];\t/* A kluge that should work like a flexible array */\n#endif\n};\n\nextern int file_extra_cnt;\nextern int inc_recurse;\nextern int atimes_ndx;\nextern int crtimes_ndx;\nextern int pathname_ndx;\nextern int depth_ndx;\nextern int uid_ndx;\nextern int gid_ndx;\nextern int acls_ndx;\nextern int xattrs_ndx;\nextern int file_sum_extra_cnt;\n\n#ifdef USE_FLEXIBLE_ARRAY\n#define FILE_STRUCT_LEN (sizeof (struct file_struct))\n#else\n#define FILE_STRUCT_LEN (offsetof(struct file_struct, basename))\n#endif\n#define EXTRA_LEN (sizeof (union file_extras))\n#define DEV_EXTRA_CNT 2\n#define DIRNODE_EXTRA_CNT 3\n#define EXTRA64_CNT ((sizeof (union file_extras64) + EXTRA_LEN - 1) / EXTRA_LEN)\n#define SUM_EXTRA_CNT file_sum_extra_cnt\n\n#define REQ_EXTRA(f,ndx) ((union file_extras*)(f) - (ndx))\n#define OPT_EXTRA(f,bump) ((union file_extras*)(f) - file_extra_cnt - 1 - (bump))\n\n/* These are guaranteed to be allocated first in the array so that they\n * are aligned for direct int64-pointer access. */\n#define REQ_EXTRA64(f,ndx) ((union file_extras64*)REQ_EXTRA(f,ndx))\n\n#define NSEC_BUMP(f) ((f)->flags & FLAG_MOD_NSEC ? 1 : 0)\n#define LEN64_BUMP(f) ((f)->flags & FLAG_LENGTH64 ? 1 : 0)\n#define START_BUMP(f) (NSEC_BUMP(f) + LEN64_BUMP(f))\n#define HLINK_BUMP(f) ((f)->flags & (FLAG_HLINKED|FLAG_HLINK_DONE) ? inc_recurse+1 : 0)\n#define ACL_BUMP(f) (acls_ndx ? 1 : 0)\n\n/* The length applies to all items. */\n#if SIZEOF_INT64 < 8\n#define F_LENGTH(f) ((int64)(f)->len32)\n#else\n#define F_HIGH_LEN(f) (OPT_EXTRA(f, NSEC_BUMP(f))->unum)\n#define F_LENGTH(f) ((int64)(f)->len32 + ((f)->flags & FLAG_LENGTH64 ? (int64)F_HIGH_LEN(f) << 32 : 0))\n#endif\n\n#define F_MOD_NSEC(f) OPT_EXTRA(f, 0)->unum\n#define F_MOD_NSEC_or_0(f) ((f)->flags & FLAG_MOD_NSEC ? F_MOD_NSEC(f) : 0)\n\n/* If there is a symlink string, it is always right after the basename */\n#define F_SYMLINK(f) ((f)->basename + strlen((f)->basename) + 1)\n\n/* The sending side always has this available: */\n#ifdef PTRS_ARE_32\n#define F_PATHNAME(f) REQ_EXTRA(f, pathname_ndx)->ptr\n#else\n#define F_PATHNAME(f) REQ_EXTRA64(f, pathname_ndx)->ptr\n#endif\n\n/* The receiving side always has this available: */\n#define F_DEPTH(f) REQ_EXTRA(f, depth_ndx)->num\n\n/* When the associated option is on, all entries will have these present: */\n#define F_OWNER(f) REQ_EXTRA(f, uid_ndx)->unum\n#define F_GROUP(f) REQ_EXTRA(f, gid_ndx)->unum\n#define F_ACL(f) REQ_EXTRA(f, acls_ndx)->num\n#define F_XATTR(f) REQ_EXTRA(f, xattrs_ndx)->num\n#define F_NDX(f) REQ_EXTRA(f, unsort_ndx)->num\n#define F_ATIME(f) REQ_EXTRA64(f, atimes_ndx)->num\n#define F_CRTIME(f) REQ_EXTRA64(f, crtimes_ndx)->num\n\n/* These items are per-entry optional: */\n#define F_HL_GNUM(f) OPT_EXTRA(f, START_BUMP(f))->num /* non-dirs */\n#define F_HL_PREV(f) OPT_EXTRA(f, START_BUMP(f)+inc_recurse)->num /* non-dirs */\n#define F_DIR_NODE_P(f) (&OPT_EXTRA(f, START_BUMP(f) \\\n\t\t\t\t+ DIRNODE_EXTRA_CNT - 1)->num) /* sender dirs */\n#define F_DIR_RELNAMES_P(f) (&OPT_EXTRA(f, START_BUMP(f) + DIRNODE_EXTRA_CNT \\\n\t\t\t\t+ PTR_EXTRA_CNT - 1)->num) /* sender dirs */\n#define F_DIR_DEFACL(f) OPT_EXTRA(f, START_BUMP(f))->unum /* receiver dirs */\n#define F_DIR_DEV_P(f) (&OPT_EXTRA(f, START_BUMP(f) + ACL_BUMP(f) \\\n\t\t\t\t+ DEV_EXTRA_CNT - 1)->unum) /* receiver dirs */\n\n/* This optional item might follow an F_HL_*() item. */\n#define F_RDEV_P(f) (&OPT_EXTRA(f, START_BUMP(f) + HLINK_BUMP(f) + DEV_EXTRA_CNT - 1)->unum)\n\n/* The sum is only present on regular files. */\n#define F_SUM(f) ((char*)OPT_EXTRA(f, START_BUMP(f) + HLINK_BUMP(f) \\\n\t\t\t\t    + SUM_EXTRA_CNT - 1))\n\n/* Some utility defines: */\n#define F_IS_ACTIVE(f) (f)->basename[0]\n#define F_IS_HLINKED(f) ((f)->flags & FLAG_HLINKED)\n\n#define F_HLINK_NOT_FIRST(f) BITS_SETnUNSET((f)->flags, FLAG_HLINKED, FLAG_HLINK_FIRST)\n#define F_HLINK_NOT_LAST(f) BITS_SETnUNSET((f)->flags, FLAG_HLINKED, FLAG_HLINK_LAST)\n\n/* These access the F_DIR_DEV_P() and F_RDEV_P() values: */\n#define DEV_MAJOR(a) (a)[0]\n#define DEV_MINOR(a) (a)[1]\n\n/* These access the F_DIRS_NODE_P() values: */\n#define DIR_PARENT(a) (a)[0]\n#define DIR_FIRST_CHILD(a) (a)[1]\n#define DIR_NEXT_SIBLING(a) (a)[2]\n\n#define IS_MISSING_FILE(statbuf) ((statbuf).st_mode == 0)\n\n/*\n * Start the flist array at FLIST_START entries and grow it\n * by doubling until FLIST_LINEAR then grow by FLIST_LINEAR\n */\n#define FLIST_START\t\t(32)\n#define FLIST_START_LARGE\t(32 * 1024)\n#define FLIST_LINEAR\t\t(FLIST_START_LARGE * 512)\n\n/*\n * Extent size for allocation pools: A minimum size of 128KB\n * is needed to mmap them so that freeing will release the\n * space to the OS.\n *\n * Larger sizes reduce leftover fragments and speed free calls\n * (when they happen). Smaller sizes increase the chance of\n * freed allocations freeing whole extents.\n */\n#define NORMAL_EXTENT\t(256 * 1024)\n#define SMALL_EXTENT\t(128 * 1024)\n\n#define FLIST_TEMP\t(1<<1)\n\nstruct file_list {\n\tstruct file_list *next, *prev;\n\tstruct file_struct **files, **sorted;\n\talloc_pool_t file_pool;\n\tvoid *pool_boundary;\n\tint used, malloced;\n\tint low, high;  /* 0-relative index values excluding empties */\n\tint ndx_start;  /* the start offset for inc_recurse mode */\n\tint flist_num;  /* 1-relative file_list number or 0 */\n\tint parent_ndx; /* dir_flist index of parent directory */\n\tint in_progress, to_redo;\n};\n\n#define SUMFLG_SAME_OFFSET\t(1<<0)\n\nstruct sum_buf {\n\tOFF_T offset;\t\t/**< offset in file of this chunk */\n\tint32 len;\t\t/**< length of chunk of file */\n\tuint32 sum1;\t        /**< simple checksum */\n\tint32 chain;\t\t/**< next hash-table collision */\n\tshort flags;\t\t/**< flag bits */\n};\n\nstruct sum_struct {\n\tOFF_T flength;\t\t/**< total file length */\n\tstruct sum_buf *sums;\t/**< points to info for each chunk */\n\tchar *sum2_array;\t/**< checksums of length xfer_sum_len */\n\tint32 count;\t\t/**< how many chunks */\n\tint32 blength;\t\t/**< block_length */\n\tint32 remainder;\t/**< flength % block_length */\n\tint s2length;\t\t/**< sum2_length */\n};\n\nstruct map_struct {\n\tOFF_T file_size;\t/* File size (from stat)\t\t*/\n\tOFF_T p_offset;\t\t/* Window start\t\t\t\t*/\n\tOFF_T p_fd_offset;\t/* offset of cursor in fd ala lseek\t*/\n\tchar *p;\t\t/* Window pointer\t\t\t*/\n\tint32 p_size;\t\t/* Largest window size we allocated\t*/\n\tint32 p_len;\t\t/* Latest (rounded) window size\t\t*/\n\tint32 def_window_size;\t/* Default window size\t\t\t*/\n\tint fd;\t\t\t/* File Descriptor\t\t\t*/\n\tint status;\t\t/* first errno from read errors\t\t*/\n};\n\n#define sum2_at(s, i)\t((s)->sum2_array + ((size_t)(i) * xfer_sum_len))\n\n#define NAME_IS_FILE\t\t(0)    /* filter name as a file */\n#define NAME_IS_DIR\t\t(1<<0) /* filter name as a dir */\n#define NAME_IS_XATTR\t\t(1<<2) /* filter name as an xattr */\n\n#define FILTRULE_WILD\t\t(1<<0) /* pattern has '*', '[', and/or '?' */\n#define FILTRULE_WILD2\t\t(1<<1) /* pattern has '**' */\n#define FILTRULE_WILD2_PREFIX\t(1<<2) /* pattern starts with \"**\" */\n#define FILTRULE_WILD3_SUFFIX\t(1<<3) /* pattern ends with \"***\" */\n#define FILTRULE_ABS_PATH\t(1<<4) /* path-match on absolute path */\n#define FILTRULE_INCLUDE\t(1<<5) /* this is an include, not an exclude */\n#define FILTRULE_DIRECTORY\t(1<<6) /* this matches only directories */\n#define FILTRULE_WORD_SPLIT\t(1<<7) /* split rules on whitespace */\n#define FILTRULE_NO_INHERIT\t(1<<8) /* don't inherit these rules */\n#define FILTRULE_NO_PREFIXES\t(1<<9) /* parse no prefixes from patterns */\n#define FILTRULE_MERGE_FILE\t(1<<10)/* specifies a file to merge */\n#define FILTRULE_PERDIR_MERGE\t(1<<11)/* merge-file is searched per-dir */\n#define FILTRULE_EXCLUDE_SELF\t(1<<12)/* merge-file name should be excluded */\n#define FILTRULE_FINISH_SETUP\t(1<<13)/* per-dir merge file needs setup */\n#define FILTRULE_NEGATE \t(1<<14)/* rule matches when pattern does not */\n#define FILTRULE_CVS_IGNORE\t(1<<15)/* rule was -C or :C */\n#define FILTRULE_SENDER_SIDE\t(1<<16)/* rule applies to the sending side */\n#define FILTRULE_RECEIVER_SIDE\t(1<<17)/* rule applies to the receiving side */\n#define FILTRULE_CLEAR_LIST\t(1<<18)/* this item is the \"!\" token */\n#define FILTRULE_PERISHABLE\t(1<<19)/* perishable if parent dir goes away */\n#define FILTRULE_XATTR\t\t(1<<20)/* rule only applies to xattr names */\n\n#define FILTRULES_SIDES (FILTRULE_SENDER_SIDE | FILTRULE_RECEIVER_SIDE)\n\ntypedef struct filter_struct {\n\tstruct filter_struct *next;\n\tchar *pattern;\n\tuint32 rflags;\n\tunion {\n\t\tint slash_cnt;\n\t\tstruct filter_list_struct *mergelist;\n\t} u;\n\tuchar elide;\n} filter_rule;\n\ntypedef struct filter_list_struct {\n\tfilter_rule *head;\n\tfilter_rule *tail;\n\tchar *debug_type;\n} filter_rule_list;\n\nstruct stats {\n\tint64 total_size;\n\tint64 total_transferred_size;\n\tint64 total_written;\n\tint64 total_read;\n\tint64 literal_data;\n\tint64 matched_data;\n\tint64 flist_buildtime;\n\tint64 flist_xfertime;\n\tint64 flist_size;\n\tint num_files, num_dirs, num_symlinks, num_devices, num_specials;\n\tint created_files, created_dirs, created_symlinks, created_devices, created_specials;\n\tint deleted_files, deleted_dirs, deleted_symlinks, deleted_devices, deleted_specials;\n\tint xferred_files;\n};\n\nstruct chmod_mode_struct;\n\nstruct flist_ndx_item {\n\tstruct flist_ndx_item *next;\n\tint ndx;\n};\n\ntypedef struct {\n\tstruct flist_ndx_item *head, *tail;\n} flist_ndx_list;\n\n#define EMPTY_ITEM_LIST {NULL, 0, 0}\n\ntypedef struct {\n\tvoid *items;\n\tsize_t count;\n\tsize_t malloced;\n} item_list;\n\n#define EXPAND_ITEM_LIST(lp, type, incr) \\\n\t(type*)expand_item_list(lp, sizeof (type), #type, incr)\n\n#define EMPTY_XBUF {NULL, 0, 0, 0}\n\ntypedef struct {\n\tchar *buf;\n\tsize_t pos;  /* pos = read pos in the buf */\n\tsize_t len;  /* len = chars following pos */\n\tsize_t size; /* size = total space in buf */\n} xbuf;\n\n#define INIT_XBUF(xb, str, ln, sz) (xb).buf = (str), (xb).len = (ln), (xb).size = (sz), (xb).pos = 0\n#define INIT_XBUF_STRLEN(xb, str) (xb).buf = (str), (xb).len = strlen((xb).buf), (xb).size = (size_t)-1, (xb).pos = 0\n/* This one is used to make an output xbuf based on a char[] buffer: */\n#define INIT_CONST_XBUF(xb, bf) (xb).buf = (bf), (xb).size = sizeof (bf), (xb).len = (xb).pos = 0\n\n#define ICB_EXPAND_OUT (1<<0)\n#define ICB_INCLUDE_BAD (1<<1)\n#define ICB_INCLUDE_INCOMPLETE (1<<2)\n#define ICB_CIRCULAR_OUT (1<<3)\n#define ICB_INIT (1<<4)\n\n#define IOBUF_KEEP_BUFS 0\n#define IOBUF_FREE_BUFS 1\n\n#define MPLX_SWITCHING IOBUF_KEEP_BUFS\n#define MPLX_ALL_DONE IOBUF_FREE_BUFS\n#define MPLX_TO_BUFFERED 2\n\n#define RL_EOL_NULLS (1<<0)\n#define RL_DUMP_COMMENTS (1<<1)\n#define RL_CONVERT (1<<2)\n\ntypedef struct {\n\tchar name_type;\n#ifdef USE_FLEXIBLE_ARRAY\n\tchar fname[]; /* has variable size */\n#else\n\tchar fname[1]; /* A kluge that should work like a flexible array */\n#endif\n} relnamecache;\n\n#ifdef USE_FLEXIBLE_ARRAY\n#define RELNAMECACHE_LEN (sizeof (relnamecache))\n#else\n#define RELNAMECACHE_LEN (offsetof(relnamecache, fname))\n#endif\n\n#include \"byteorder.h\"\n#include \"lib/mdigest.h\"\n#include \"lib/wildmatch.h\"\n#include \"lib/permstring.h\"\n#include \"lib/addrinfo.h\"\n\n#ifndef __GNUC__\n#define __attribute__(x)\n#else\n# if __GNUC__ <= 2\n# define NORETURN\n# endif\n#endif\n\n#define UNUSED(x) x __attribute__((__unused__))\n#ifndef NORETURN\n#define NORETURN __attribute__((__noreturn__))\n#endif\n\ntypedef struct {\n    STRUCT_STAT st;\n    time_t crtime;\n#ifdef SUPPORT_ACLS\n    struct rsync_acl *acc_acl; /* access ACL */\n    struct rsync_acl *def_acl; /* default ACL */\n#endif\n#ifdef SUPPORT_XATTRS\n    item_list *xattr;\n#endif\n} stat_x;\n\n#define ACL_READY(sx) ((sx).acc_acl != NULL)\n#define XATTR_READY(sx) ((sx).xattr != NULL)\n\n#define CLVL_NOT_SPECIFIED INT_MIN\n\n#define CPRES_AUTO (-1)\n#define CPRES_NONE 0\n#define CPRES_ZLIB 1\n#define CPRES_ZLIBX 2\n#define CPRES_LZ4 3\n#define CPRES_ZSTD 4\n\n#define NSTR_CHECKSUM 0\n#define NSTR_COMPRESS 1\n\nstruct name_num_item {\n\tint num, flags;\n\tconst char *name;\n\tstruct name_num_item *main_nni;\n};\n\nstruct name_num_obj {\n\tconst char *type;\n\tstruct name_num_item *negotiated_nni;\n\tuchar *saw;\n\tint saw_len;\n\tstruct name_num_item *list;\n};\n\n#ifdef EXTERNAL_ZLIB\n#define read_buf read_buf_\n#endif\n\n#ifndef __cplusplus\n#include \"proto.h\"\n#endif\n\n#ifndef SUPPORT_XATTRS\n#define x_stat(fn,fst,xst) do_stat(fn,fst)\n#define x_lstat(fn,fst,xst) do_lstat(fn,fst)\n#define x_fstat(fd,fst,xst) do_fstat(fd,fst)\n#endif\n\n/* We have replacement versions of these if they're missing. */\n#ifndef HAVE_ASPRINTF\nint asprintf(char **ptr, const char *format, ...);\n#endif\n\n#ifndef HAVE_VASPRINTF\nint vasprintf(char **ptr, const char *format, va_list ap);\n#endif\n\n#if !defined HAVE_VSNPRINTF || !defined HAVE_C99_VSNPRINTF\n#define vsnprintf rsync_vsnprintf\nint vsnprintf(char *str, size_t count, const char *fmt, va_list args);\n#endif\n\n#if !defined HAVE_SNPRINTF || !defined HAVE_C99_VSNPRINTF\n#define snprintf rsync_snprintf\nint snprintf(char *str, size_t count, const char *fmt,...);\n#endif\n\n#ifndef HAVE_STRERROR\nextern char *sys_errlist[];\n#define strerror(i) sys_errlist[i]\n#endif\n\n#ifndef HAVE_STRCHR\n# define strchr                 index\n# define strrchr                rindex\n#endif\n\n#ifndef HAVE_ERRNO_DECL\nextern int errno;\n#endif\n\n#ifdef HAVE_READLINK\n#define SUPPORT_LINKS 1\n#if !defined NO_SYMLINK_XATTRS && !defined NO_SYMLINK_USER_XATTRS\n#define do_readlink(path, buf, bufsiz) readlink(path, buf, bufsiz)\n#endif\n#endif\n#ifdef HAVE_LINK\n#define SUPPORT_HARD_LINKS 1\n#endif\n\n#ifdef HAVE_SIGACTION\n#define SIGACTION(n,h) sigact.sa_handler=(h), sigaction((n),&sigact,NULL)\n#define signal(n,h) we_need_to_call_SIGACTION_not_signal(n,h)\n#else\n#define SIGACTION(n,h) signal(n,h)\n#endif\n\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK EAGAIN\n#endif\n\n#ifndef STDIN_FILENO\n#define STDIN_FILENO 0\n#endif\n\n#ifndef STDOUT_FILENO\n#define STDOUT_FILENO 1\n#endif\n\n#ifndef STDERR_FILENO\n#define STDERR_FILENO 2\n#endif\n\n#ifndef S_IRUSR\n#define S_IRUSR 0400\n#endif\n\n#ifndef S_IWUSR\n#define S_IWUSR 0200\n#endif\n\n#ifndef ACCESSPERMS\n#define ACCESSPERMS 0777\n#endif\n\n#ifndef S_ISVTX\n#define S_ISVTX 0\n#endif\n\n#define CHMOD_BITS (S_ISUID | S_ISGID | S_ISVTX | ACCESSPERMS)\n\n#ifndef _S_IFMT\n#define _S_IFMT        0170000\n#endif\n\n#ifndef _S_IFLNK\n#define _S_IFLNK  0120000\n#endif\n\n#ifndef S_ISLNK\n#define S_ISLNK(mode) (((mode) & (_S_IFMT)) == (_S_IFLNK))\n#endif\n\n#ifndef S_ISBLK\n#define S_ISBLK(mode) (((mode) & (_S_IFMT)) == (_S_IFBLK))\n#endif\n\n#ifndef S_ISCHR\n#define S_ISCHR(mode) (((mode) & (_S_IFMT)) == (_S_IFCHR))\n#endif\n\n#ifndef S_ISSOCK\n#ifdef _S_IFSOCK\n#define S_ISSOCK(mode) (((mode) & (_S_IFMT)) == (_S_IFSOCK))\n#else\n#define S_ISSOCK(mode) (0)\n#endif\n#endif\n\n#ifndef S_ISFIFO\n#ifdef _S_IFIFO\n#define S_ISFIFO(mode) (((mode) & (_S_IFMT)) == (_S_IFIFO))\n#else\n#define S_ISFIFO(mode) (0)\n#endif\n#endif\n\n#ifndef S_ISDIR\n#define S_ISDIR(mode) (((mode) & (_S_IFMT)) == (_S_IFDIR))\n#endif\n\n#ifndef S_ISREG\n#define S_ISREG(mode) (((mode) & (_S_IFMT)) == (_S_IFREG))\n#endif\n\n/* work out what fcntl flag to use for non-blocking */\n#ifdef O_NONBLOCK\n# define NONBLOCK_FLAG O_NONBLOCK\n#elif defined SYSV\n# define NONBLOCK_FLAG O_NDELAY\n#else\n# define NONBLOCK_FLAG FNDELAY\n#endif\n\n#ifndef INADDR_LOOPBACK\n#define INADDR_LOOPBACK 0x7f000001\n#endif\n\n#ifndef INADDR_NONE\n#define INADDR_NONE 0xffffffff\n#endif\n\n#define IS_SPECIAL(mode) (S_ISSOCK(mode) || S_ISFIFO(mode))\n#define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode))\n\n/* Initial mask on permissions given to temporary files.  Mask off setuid\n     bits and group access because of potential race-condition security\n     holes, and mask other access because mode 707 is bizarre */\n#define INITACCESSPERMS 0700\n\n/* handler for null strings in printf format */\n#define NS(s) ((s)?(s):\"<NULL>\")\n\nextern char *do_calloc;\n\n/* Convenient wrappers for malloc and realloc.  Use them. */\n#define new(type) ((type*)my_alloc(NULL, sizeof (type), 1, __FILE__, __LINE__))\n#define new0(type) ((type*)my_alloc(do_calloc, sizeof (type), 1, __FILE__, __LINE__))\n#define realloc_buf(ptr, num) my_alloc((ptr), (num), 1, __FILE__, __LINE__)\n\n#define new_array(type, num) ((type*)my_alloc(NULL, (num), sizeof (type), __FILE__, __LINE__))\n#define new_array0(type, num) ((type*)my_alloc(do_calloc, (num), sizeof (type), __FILE__, __LINE__))\n#define realloc_array(ptr, type, num) ((type*)my_alloc((ptr), (num), sizeof (type), __FILE__, __LINE__))\n\n#undef strdup\n#define strdup(s) my_strdup(s, __FILE__, __LINE__)\n\n#define out_of_memory(msg) _out_of_memory(msg, __FILE__, __LINE__)\n#define overflow_exit(msg) _overflow_exit(msg, __FILE__, __LINE__)\n\n/* use magic gcc attributes to catch format errors */\n void rprintf(enum logcode , const char *, ...)\n     __attribute__((format (printf, 2, 3)))\n;\n\n/* This is just like rprintf, but it also tries to print some\n * representation of the error code.  Normally errcode = errno. */\nvoid rsyserr(enum logcode, int, const char *, ...)\n     __attribute__((format (printf, 3, 4)))\n     ;\n\n/* Make sure that the O_BINARY flag is defined. */\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#ifndef HAVE_STRLCPY\nsize_t strlcpy(char *d, const char *s, size_t bufsize);\n#endif\n\n#ifndef HAVE_STRLCAT\nsize_t strlcat(char *d, const char *s, size_t bufsize);\n#endif\n\n#ifndef WEXITSTATUS\n#define\tWEXITSTATUS(stat)\t((int)(((stat)>>8)&0xFF))\n#endif\n#ifndef WIFEXITED\n#define\tWIFEXITED(stat)\t\t((int)((stat)&0xFF) == 0)\n#endif\n\n#define exit_cleanup(code) _exit_cleanup(code, __FILE__, __LINE__)\n\n#ifdef HAVE_GETEUID\n#define MY_UID() geteuid()\n#else\n#define MY_UID() getuid()\n#endif\n\n#ifdef HAVE_GETEGID\n#define MY_GID() getegid()\n#else\n#define MY_GID() getgid()\n#endif\n\n#ifdef FORCE_FD_ZERO_MEMSET\n#undef FD_ZERO\n#define FD_ZERO(fdsetp) memset(fdsetp, 0, sizeof (fd_set))\n#endif\n\nextern short info_levels[], debug_levels[];\n\n#define INFO_GTE(flag, lvl) (info_levels[INFO_##flag] >= (lvl))\n#define INFO_EQ(flag, lvl) (info_levels[INFO_##flag] == (lvl))\n#define DEBUG_GTE(flag, lvl) (debug_levels[DEBUG_##flag] >= (lvl))\n#define DEBUG_EQ(flag, lvl) (debug_levels[DEBUG_##flag] == (lvl))\n\n#define INFO_BACKUP 0\n#define INFO_COPY (INFO_BACKUP+1)\n#define INFO_DEL (INFO_COPY+1)\n#define INFO_FLIST (INFO_DEL+1)\n#define INFO_MISC (INFO_FLIST+1)\n#define INFO_MOUNT (INFO_MISC+1)\n#define INFO_NAME (INFO_MOUNT+1)\n#define INFO_NONREG (INFO_NAME+1)\n#define INFO_PROGRESS (INFO_NONREG+1)\n#define INFO_REMOVE (INFO_PROGRESS+1)\n#define INFO_SKIP (INFO_REMOVE+1)\n#define INFO_STATS (INFO_SKIP+1)\n#define INFO_SYMSAFE (INFO_STATS+1)\n\n#define COUNT_INFO (INFO_SYMSAFE+1)\n\n#define DEBUG_ACL 0\n#define DEBUG_BACKUP (DEBUG_ACL+1)\n#define DEBUG_BIND (DEBUG_BACKUP+1)\n#define DEBUG_CHDIR (DEBUG_BIND+1)\n#define DEBUG_CONNECT (DEBUG_CHDIR+1)\n#define DEBUG_CMD (DEBUG_CONNECT+1)\n#define DEBUG_DEL (DEBUG_CMD+1)\n#define DEBUG_DELTASUM (DEBUG_DEL+1)\n#define DEBUG_DUP (DEBUG_DELTASUM+1)\n#define DEBUG_EXIT (DEBUG_DUP+1)\n#define DEBUG_FILTER (DEBUG_EXIT+1)\n#define DEBUG_FLIST (DEBUG_FILTER+1)\n#define DEBUG_FUZZY (DEBUG_FLIST+1)\n#define DEBUG_GENR (DEBUG_FUZZY+1)\n#define DEBUG_HASH (DEBUG_GENR+1)\n#define DEBUG_HLINK (DEBUG_HASH+1)\n#define DEBUG_ICONV (DEBUG_HLINK+1)\n#define DEBUG_IO (DEBUG_ICONV+1)\n#define DEBUG_NSTR (DEBUG_IO+1)\n#define DEBUG_OWN (DEBUG_NSTR+1)\n#define DEBUG_PROTO (DEBUG_OWN+1)\n#define DEBUG_RECV (DEBUG_PROTO+1)\n#define DEBUG_SEND (DEBUG_RECV+1)\n#define DEBUG_TIME (DEBUG_SEND+1)\n\n#define COUNT_DEBUG (DEBUG_TIME+1)\n\n#ifndef HAVE_INET_NTOP\nconst char *inet_ntop(int af, const void *src, char *dst, size_t size);\n#endif\n\n#ifndef HAVE_INET_PTON\nint inet_pton(int af, const char *src, void *dst);\n#endif\n\n#ifndef HAVE_GETPASS\nchar *getpass(const char *prompt);\n#endif\n\n#ifdef MAINTAINER_MODE\nconst char *get_panic_action(void);\n#endif\n\n#define NOISY_DEATH(msg) do { \\\n    fprintf(stderr, \"%s in %s at line %d\\n\", msg, __FILE__, __LINE__); \\\n    exit_cleanup(RERR_UNSUPPORTED); \\\n} while (0)\n\n#ifdef HAVE_MALLINFO2\n#define MEM_ALLOC_INFO mallinfo2\n#elif defined HAVE_MALLINFO\n#define MEM_ALLOC_INFO mallinfo\n#endif\n"
        },
        {
          "name": "rsync3.txt",
          "type": "blob",
          "size": 14.33984375,
          "content": "-*- indented-text -*-\n\nNotes towards a new version of rsync\nMartin Pool <mbp@samba.org>, September 2001.\n\n\nGood things about the current implementation:\n\n  - Widely known and adopted.\n\n  - Fast/efficient, especially for moderately small sets of files over\n    slow links (transoceanic or modem.)\n\n  - Fairly reliable.\n\n  - The choice of running over a plain TCP socket or tunneling over\n    ssh.\n\n  - rsync operations are idempotent: you can always run the same\n    command twice to make sure it worked properly without any fear.\n    (Are there any exceptions?)\n\n  - Small changes to files cause small deltas.\n\n  - There is a way to evolve the protocol to some extent.\n\n  - rdiff and rsync --write-batch allow generation of standalone patch\n    sets.  rsync+ is pretty cheesy, though.  xdelta seems cleaner.\n\n  - Process triangle is creative, but seems to provoke OS bugs.\n\n  - \"Morning-after property\": you don't need to know anything on the\n    local machine about the state of the remote machine, or about\n    transfers that have been done in the past.\n\n  - You can easily push or pull simply by switching the order of\n    files.\n\n  - The \"modules\" system has some neat features compared to\n    e.g. Apache's per-directory configuration.  In particular, because\n    you can set a userid and chroot directory, there is strong\n    protection between different modules.  I haven't seen any calls\n    for a more flexible system.\n\n\nBad things about the current implementation:\n\n  - Persistent and hard-to-diagnose hang bugs remain\n\n  - Protocol is sketchily documented, tied to this implementation, and\n    hard to modify/extend\n\n  - Both the program and the protocol assume a single non-interactive\n    one-way transfer\n\n  - A list of all files are held in memory for the entire transfer,\n    which cripples scalability to large file trees\n\n  - Opening a new socket for every operation causes problems,\n    especially when running over SSH with password authentication.\n\n  - Renamed files are not handled: the old file is removed, and the\n    new file created from scratch.\n\n  - The versioning approach assumes that future versions of the\n    program know about all previous versions, and will do the right\n    thing.\n\n  - People always get confused about ':' vs '::'\n\n  - Error messages can be cryptic.\n\n  - Default behaviour is not intuitive: in too many cases rsync will\n    happily do nothing.  Perhaps -a should be the default?\n\n  - People get confused by trailing slashes, though it's hard to think\n    of another reasonable way to make this necessary distinction\n    between a directory and its contents.\n\n\nProtocol philosophy:\n\n   *The* big difference between protocols like HTTP, FTP, and NFS is\n    that their fundamental operations are \"read this file\", \"delete\n    this file\", and \"make this directory\", whereas rsync is \"make this\n    directory like this one\".\n\n\nQuestionable features:\n\n  These are neat, but not necessarily clean or worth preserving.\n\n  - The remote rsync can be wrapped by some other program, such as in\n    tridge's rsync-mail scripts.  The general feature of sending and\n    retrieving mail over rsync is good, but this is perhaps not the\n    right way to implement it.\n\n\nDesirable features:\n\n  These don't really require architectural changes; they're just\n  something to keep in mind.\n\n  - Synchronize ACLs and extended attributes\n\n  - Anonymous servers should be efficient\n\n  - Code should be portable to non-UNIX systems\n\n  - Should be possible to document the protocol in RFC form\n\n  - --dry-run option\n\n  - IPv6 support.  Pretty straightforward.\n\n  - Allow the basis and destination files to be different.  For\n    example, you could use this when you have a CD-ROM and want to\n    download an updated image onto a hard drive.\n\n  - Efficiently interrupt and restart a transfer.  We can write a\n    checkpoint file that says where we're up to in the filesystem.\n    Alternatively, as long as transfers are idempotent, we can just\n    restart the whole thing.  [NFSv4]\n\n  - Scripting support.\n\n  - Propagate atimes and do not modify them.  This is very ugly on\n    Unix.  It might be better to try to add O_NOATIME to kernels, and\n    call that.\n\n  - Unicode.  Probably just use UTF-8 for everything.\n\n  - Open authentication system.  Can we use PAM?  Is SASL an adequate\n    mapping of PAM to the network, or useful in some other way?\n\n  - Resume interrupted transfers without the --partial flag.  We need\n    to leave the temporary file behind, and then know to use it.  This\n    leaves a risk of large temporary files accumulating, which is not\n    good.  Perhaps it should be off by default.\n\n  - tcpwrappers support.  Should be trivial; can already be done\n    through tcpd or inetd.\n\n  - Socks support built in.  It's not clear this is any better than\n    just linking against the socks library, though.\n\n  - When run over SSH, invoke with predictable command-line arguments,\n    so that people can restrict what commands sshd will run.  (Is this\n    really required?)\n\n  - Comparison mode: give a list of which files are new, gone, or\n    different.  Set return code depending on whether anything has\n    changed.\n\n  - Internationalized messages (gettext?)\n\n  - Optionally use real regexps rather than globs?\n\n  - Show overall progress.  Pretty hard to do, especially if we insist\n    on not scanning the directory tree up front.\n\n\nRegression testing:\n\n  - Support automatic testing.\n\n  - Have hard internal timeouts against hangs.\n\n  - Be deterministic.\n\n  - Measure performance.\n\n\nHard links:\n\n  At the moment, we can recreate hard links, but it's a bit\n  inefficient: it depends on holding a list of all files in the tree.\n  Every time we see a file with a linkcount >1, we need to search for\n  another known name that has the same (fsid,inum) tuple.  We could do\n  that more efficiently by keeping a list of only files with\n  linkcount>1, and removing files from that list as all their names\n  become known.\n\n\nCommand-line options:\n\n  We have rather a lot at the moment.  We might get more if the tool\n  becomes more flexible.  Do we need a .rc or configuration file?\n  That wouldn't really fit with its pattern of use: cp and tar don't\n  have them, though ssh does.\n\n\nScripting issues:\n\n  - Perhaps support multiple scripting languages: candidates include\n    Perl, Python, Tcl, Scheme (guile?), sh, ...\n\n  - Simply running a subprocess and looking at its stdout/exit code\n    might be sufficient, though it could also be pretty slow if it's\n    called often.\n\n  - There are security issues about running remote code, at least if\n    it's not running in the users own account.  So we can either\n    disallow it, or use some kind of sandbox system.\n\n  - Python is a good language, but the syntax is not so good for\n    giving small fragments on the command line.\n\n  - Tcl is broken Lisp.\n\n  - Lots of sysadmins know Perl, though Perl can give some bizarre or\n    confusing errors.  The built in stat operators and regexps might\n    be useful.\n\n  - Sadly probably not enough people know Scheme.\n\n  - sh is hard to embed.\n\n\nScripting hooks:\n\n  - Whether to transfer a file\n\n  - What basis file to use\n\n  - Logging\n\n  - Whether to allow transfers (for public servers)\n\n  - Authentication\n\n  - Locking\n\n  - Cache\n\n  - Generating backup path/name.\n\n  - Post-processing of backups, e.g. to do compression.\n\n  - After transfer, before replacement: so that we can spit out a diff\n    of what was changed, or kick off some kind of reconciliation\n    process.\n\n\nVFS:\n\n  Rather than talking straight to the filesystem, rsyncd talks through\n  an internal API.  Samba has one.  Is it useful?\n\n  - Could be a tidy way to implement cached signatures.\n\n  - Keep files compressed on disk?\n\n\nInteractive interface:\n\n  - Something like ncFTP, or integration into GNOME-vfs.  Probably\n    hold a single socket connection open.\n\n  - Can either call us as a separate process, or as a library.\n\n  - The standalone process needs to produce output in a form easily\n    digestible by a calling program, like the --emacs feature some\n    have.  Same goes for output: rpm outputs a series of hash symbols,\n    which are easier for a GUI to handle than \"\\r30% complete\"\n    strings.\n\n  - Yow!  emacs support.  (You could probably build that already, of\n    course.)  I'd like to be able to write a simple script on a remote\n    machine that rsyncs it to my workstation, edits it there, then\n    pushes it back up.\n\n\nPie-in-the-sky features:\n\n  These might have a severe impact on the protocol, and are not\n  clearly in our core requirements.  It looks like in many of them\n  having scripting hooks will allow us\n\n  - Transport over UDP multicast.  The hard part is handling multiple\n    destinations which have different basis files.  We can look at\n    multicast-TFTP for inspiration.\n\n  - Conflict resolution.  Possibly general scripting support will be\n    sufficient.\n\n  - Integrate with locking.  It's hard to see a good general solution,\n    because Unix systems have several locking mechanisms, and grabbing\n    the lock from programs that don't expect it could cause deadlocks,\n    timeouts, or other problems.  Scripting support might help.\n\n  - Replicate in place, rather than to a temporary file.  This is\n    dangerous in the case of interruption, and it also means that the\n    delta can't refer to blocks that have already been overwritten.\n    On the other hand we could semi-trivially do this at first by\n    simply generating a delta with no copy instructions.\n\n  - Replicate block devices.  Most of the difficulties here are to do\n    with replication in place, though on some systems we will also\n    have to do I/O on block boundaries.\n\n  - Peer to peer features.  Flavour of the year.  Can we think about\n    ways for clients to smoothly and voluntarily become servers for\n    content they receive?\n\n  - Imagine a situation where the destination has a much faster link\n    to the cloud than the source.  In this case, Mojo Nation downloads\n    interleaved blocks from several slower servers.  The general\n    situation might be a way for a master rsync process to farm out\n    tasks to several subjobs.  In this particular case they'd need\n    different sockets.  This might be related to multicast.\n\n\nUnlikely features:\n\n  - Allow remote source and destination.  If this can be cleanly\n    designed into the protocol, perhaps with the remote machine acting\n    as a kind of echo, then it's good.  It's uncommon enough that we\n    don't want to shape the whole protocol around it, though.\n\n    In fact, in a triangle of machines there are two possibilities:\n    all traffic passes from remote1 to remote2 through local, or local\n    just sets up the transfer and then remote1 talks to remote2.  FTP\n    supports the second but it's not clearly good.  There are some\n    security problems with being able to instruct one machine to open\n    a connection to another.\n\n\nIn favour of evolving the protocol:\n\n  - Keeping compatibility with existing rsync servers will help with\n    adoption and testing.\n\n  - We should at the very least be able to fall back to the new\n    protocol.\n\n  - Error handling is not so good.\n\n\nIn favour of using a new protocol:\n\n  - Maintaining compatibility might soak up development time that\n    would better go into improving a new protocol.\n\n  - If we start from scratch, it can be documented as we go, and we\n    can avoid design decisions that make the protocol complex or\n    implementation-bound.\n\n\nError handling:\n\n  - Errors should come back reliably, and be clearly associated with\n    the particular file that caused the problem.\n\n  - Some errors ought to cause the whole transfer to abort; some are\n    just warnings.  If any errors have occurred, then rsync ought to\n    return an error.\n\n\nConcurrency:\n\n  - We want to keep the CPU, filesystem, and network as full as\n    possible as much of the time as possible.\n\n  - We can do nonblocking network IO, but not so for disk.\n\n  - It makes sense to on the destination be generating signatures and\n    applying patches at the same time.\n\n  - Can structure this with nonblocking, threads, separate processes,\n    etc.\n\n\nUses:\n\n  - Mirroring software distributions:\n\n  - Synchronizing laptop and desktop\n\n  - NFS filesystem migration/replication.  See\n    http://www.ietf.org/proceedings/00jul/00july-133.htm#P24510_1276764\n\n  - Sync with PDA\n\n  - Network backup systems\n\n  - CVS filemover\n\n\nConflict resolution:\n\n  - Requires application-specific knowledge.  We want to provide\n    policy, rather than mechanism.\n\n  - Possibly allowing two-way migration across a single connection\n    would be useful.\n\n\nMoved files:\n\n  - There's no trivial way to detect renamed files, especially if they\n    move between directories.\n\n  - If we had a picture of the remote directory from last time on\n    either machine, then the inode numbers might give us a hint about\n    files which may have been renamed.\n\n  - Files that are renamed and not modified can be detected by\n    examining the directory listing, looking for files with the same\n    size/date as the origin.\n\n\nFilesystem migration:\n\n  NFSv4 probably wants to migrate file locks, but that's not really\n  our problem.\n\n\nAtomic updates:\n\n  The NFSv4 working group wants atomic migration.  Most of the\n  responsibility for this lies on the NFS server or OS.\n\n  If migrating a whole tree, then we could do a nearly-atomic rename\n  at the end.  This ties in to having separate basis and destination\n  files.\n\n  There's no way in Unix to replace a whole set of files atomically.\n  However, if we get them all onto the destination machine and then do\n  the updates quickly it would greatly reduce the window.\n\n\nScalability:\n\n  We should aim to work well on machines in use in a year or two.\n  That probably means transfers of many millions of files in one\n  batch, and gigabytes or terabytes of data.\n\n  For argument's sake: at the low end, we want to sync ten files for a\n  total of 10kb across a 1kB/s link.  At the high end, we want to sync\n  1e9 files for 1TB of data across a 1GB/s link.\n\n  On the whole CPU usage is not normally a limiting factor, if only\n  because running over SSH burns a lot of cycles on encryption.\n\n  Perhaps have resource throttling without relying on rlimit.\n\n\nStreaming:\n\n  A big attraction of rsync is that there are few round-trip delays:\n  basically only one to get started, and then everything is\n  pipelined.  This is a problem with FTP, and NFS (at least up to\n  v3).  NFSv4 can pipeline operations, but building on that is\n  probably a bit complicated.\n\n\nRelated work:\n\n  - mirror.pl\n\n  - ProFTPd\n\n  - Apache\n\n  - BitTorrent -- p2p mirroring\n    http://bitconjurer.org/BitTorrent/\n"
        },
        {
          "name": "rsyncd.conf.5.md",
          "type": "blob",
          "size": 59.705078125,
          "content": "## NAME\n\nrsyncd.conf - configuration file for rsync in daemon mode\n\n## SYNOPSIS\n\nrsyncd.conf\n\nThe online version of this manpage (that includes cross-linking of topics)\nis available at <https://download.samba.org/pub/rsync/rsyncd.conf.5>.\n\n## DESCRIPTION\n\nThe rsyncd.conf file is the runtime configuration file for rsync when run as an\nrsync daemon.\n\nThe rsyncd.conf file controls authentication, access, logging and available\nmodules.\n\n## FILE FORMAT\n\nThe file consists of modules and parameters. A module begins with the name of\nthe module in square brackets and continues until the next module begins.\nModules contain parameters of the form `name = value`.\n\nThe file is line-based -- that is, each newline-terminated line represents\neither a comment, a module name or a parameter.\n\nOnly the first equals sign in a parameter is significant. Whitespace before or\nafter the first equals sign is discarded. Leading, trailing and internal\nwhitespace in module and parameter names is irrelevant. Leading and trailing\nwhitespace in a parameter value is discarded. Internal whitespace within a\nparameter value is retained verbatim.\n\nAny line **beginning** with a hash (`#`) is ignored, as are lines containing\nonly whitespace. (If a hash occurs after anything other than leading\nwhitespace, it is considered a part of the line's content.)\n\nAny line ending in a `\\` is \"continued\" on the next line in the customary UNIX\nfashion.\n\nThe values following the equals sign in parameters are all either a string (no\nquotes needed) or a boolean, which may be given as yes/no, 0/1 or true/false.\nCase is not significant in boolean values, but is preserved in string values.\n\n## LAUNCHING THE RSYNC DAEMON\n\nThe rsync daemon is launched by specifying the `--daemon` option to rsync.\n\nThe daemon must run with root privileges if you wish to use chroot, to bind to\na port numbered under 1024 (as is the default 873), or to set file ownership.\nOtherwise, it must just have permission to read and write the appropriate data,\nlog, and lock files.\n\nYou can launch it either via inetd, as a stand-alone daemon, or from an rsync\nclient via a remote shell.  If run as a stand-alone daemon then just run the\ncommand \"`rsync --daemon`\" from a suitable startup script.\n\nWhen run via inetd you should add a line like this to /etc/services:\n\n>     rsync           873/tcp\n\nand a single line something like this to /etc/inetd.conf:\n\n>     rsync   stream  tcp     nowait  root   @BINDIR@/rsync rsyncd --daemon\n\nReplace \"@BINDIR@/rsync\" with the path to where you have rsync installed on\nyour system.  You will then need to send inetd a HUP signal to tell it to\nreread its config file.\n\nNote that you should **not** send the rsync daemon a HUP signal to force it to\nreread the `rsyncd.conf` file. The file is re-read on each client connection.\n\n## GLOBAL PARAMETERS\n\nThe first parameters in the file (before a [module] header) are the global\nparameters:\n\n[comment]: # (An OL starting at 0 is converted into a DL by the parser.)\n\n0.  `motd file`\n\n    This parameter allows you to specify a \"message of the day\" (MOTD) to display\n    to clients on each connect. This usually contains site information and any\n    legal notices. The default is no MOTD file.  This can be overridden by the\n    `--dparam=motdfile=FILE` command-line option when starting the daemon.\n\n0.  `pid file`\n\n    This parameter tells the rsync daemon to write its process ID to that file.\n    The rsync keeps the file locked so that it can know when it is safe to\n    overwrite an existing file.\n\n    The filename can be overridden by the `--dparam=pidfile=FILE` command-line\n    option when starting the daemon.\n\n0.  `port`\n\n    You can override the default port the daemon will listen on by specifying\n    this value (defaults to 873).  This is ignored if the daemon is being run\n    by inetd, and is superseded by the `--port` command-line option.\n\n0.  `address`\n\n    You can override the default IP address the daemon will listen on by\n    specifying this value.  This is ignored if the daemon is being run by\n    inetd, and is superseded by the `--address` command-line option.\n\n0.  `socket options`\n\n    This parameter can provide endless fun for people who like to tune their\n    systems to the utmost degree. You can set all sorts of socket options which\n    may make transfers faster (or slower!). Read the manpage for the\n    **setsockopt()** system call for details on some of the options you may be\n    able to set. By default no special socket options are set.  These settings\n    can also be specified via the `--sockopts` command-line option.\n\n0.  `listen backlog`\n\n    You can override the default backlog value when the daemon listens for\n    connections.  It defaults to 5.\n\nYou may also include any [MODULE PARAMETERS](#) in the global part of the\nconfig file, in which case the supplied value will override the default for\nthat parameter.\n\nYou may use references to environment variables in the values of parameters.\nString parameters will have %VAR% references expanded as late as possible (when\nthe string is first used in the program), allowing for the use of variables\nthat rsync sets at connection time, such as RSYNC_USER_NAME.  Non-string\nparameters (such as true/false settings) are expanded when read from the config\nfile.  If a variable does not exist in the environment, or if a sequence of\ncharacters is not a valid reference (such as an un-paired percent sign), the\nraw characters are passed through unchanged.  This helps with backward\ncompatibility and safety (e.g. expanding a non-existent %VAR% to an empty\nstring in a path could result in a very unsafe path).  The safest way to insert\na literal % into a value is to use %%.\n\n## MODULE PARAMETERS\n\nAfter the global parameters you should define a number of modules, each module\nexports a directory tree as a symbolic name. Modules are exported by specifying\na module name in square brackets [module] followed by the parameters for that\nmodule.  The module name cannot contain a slash or a closing square bracket.\nIf the name contains whitespace, each internal sequence of whitespace will be\nchanged into a single space, while leading or trailing whitespace will be\ndiscarded.\n\nThere is also a special module name of \"[global]\" that does not define a module\nbut instead switches back to the global settings context where default\nparameters can be specified.  Because each defined module gets its full set of\nparameters as a combination of the default values that are set at that position\nin the config file plus its own parameter list, the use of a \"[global]\" section\ncan help to maintain shared config values for multiple modules.\n\nAs with [GLOBAL PARAMETERS](#), you may use references to environment variables\nin the values of parameters.  See that section for details.\n\n0.  `comment`\n\n    This parameter specifies a description string that is displayed next to the\n    module name when clients obtain a list of available modules. The default is\n    no comment.\n\n0.  `path`\n\n    This parameter specifies the directory in the daemon's filesystem to make\n    available in this module.  You must specify this parameter for each module\n    in `rsyncd.conf`.\n\n    If the value contains a \"/./\" element then the path will be divided at that\n    point into a chroot dir and an inner-chroot subdir.  If [`use chroot`](#)\n    is set to false, though, the extraneous dot dir is just cleaned out of the\n    path.  An example of this idiom is:\n\n    >     path = /var/rsync/./module1\n\n    This will (when chrooting) chroot to \"/var/rsync\" and set the inside-chroot\n    path to \"/module1\".\n\n    You may base the path's value off of an environment variable by surrounding\n    the variable name with percent signs.  You can even reference a variable\n    that is set by rsync when the user connects.  For example, this would use\n    the authorizing user's name in the path:\n\n    >     path = /home/%RSYNC_USER_NAME%\n\n    It is fine if the path includes internal spaces -- they will be retained\n    verbatim (which means that you shouldn't try to escape them).  If your\n    final directory has a trailing space (and this is somehow not something you\n    wish to fix), append a trailing slash to the path to avoid losing the\n    trailing whitespace.\n\n0.  `use chroot`\n\n    If \"use chroot\" is true, the rsync daemon will chroot to the \"[path](#)\" before\n    starting the file transfer with the client.  This has the advantage of\n    extra protection against possible implementation security holes, but it has\n    the disadvantages of requiring super-user privileges, of not being able to\n    follow symbolic links that are either absolute or outside of the new root\n    path, and of complicating the preservation of users and groups by name (see\n    below).\n\n    If `use chroot` is not set, it defaults to trying to enable a chroot but\n    allows the daemon to continue (after logging a warning) if it fails. The\n    one exception to this is when a module's [`path`](#) has a \"/./\" chroot\n    divider in it -- this causes an unset value to be treated as true for that\n    module.\n\n    Prior to rsync 3.2.7, the default value was \"true\".  The new \"unset\"\n    default makes it easier to setup an rsync daemon as a non-root user or to\n    run a daemon on a system where chroot fails.  Explicitly setting the value\n    to \"true\" in rsyncd.conf will always require the chroot to succeed.\n\n    It is also possible to specify a dot-dir in the module's \"[path](#)\" to\n    indicate that you want to chdir to the earlier part of the path and then\n    serve files from inside the latter part of the path (with sanitizing and\n    default symlink munging).  This can be useful if you need some library dirs\n    inside the chroot (typically for uid & gid lookups) but don't want to put\n    the lib dir into the top of the served path (even though they can be hidden\n    with an [`exclude`](#) directive).  However, a better choice for a modern\n    rsync setup is to use a [`name converter`](#)\" and try to avoid inner lib\n    dirs altogether.  See also the [`daemon chroot`](#) parameter, which causes\n    rsync to chroot into its own chroot area before doing any path-related\n    chrooting.\n\n    If the daemon is serving the \"/\" dir (either directly or due to being\n    chrooted to the module's path), rsync does not do any path sanitizing or\n    (default) munging.\n\n    When it has to limit access to a particular subdir (either due to chroot\n    being disabled or having an inside-chroot path set), rsync will munge\n    symlinks (by default) and sanitize paths.  Those that dislike munged\n    symlinks (and really, really trust their users to not break out of the\n    subdir) can disable the symlink munging via the \"[munge symlinks](#)\"\n    parameter.\n\n    When rsync is sanitizing paths, it trims \"..\" path elements from args that\n    it believes would escape the module hierarchy. It also substitutes leading\n    slashes in absolute paths with the module's path (so that options such as\n    `--backup-dir` & `--compare-dest` interpret an absolute path as rooted in\n    the module's \"[path](#)\" dir).\n\n    When a chroot is in effect *and* the \"[name converter](#)\" parameter is\n    *not* set, the \"[numeric ids](#)\" parameter will default to being enabled\n    (disabling name lookups).  This means that if you manually setup\n    name-lookup libraries in your chroot (instead of using a name converter)\n    that you need to explicitly set `numeric ids = false` for rsync to do name\n    lookups.\n\n    If you copy library resources into the module's chroot area, you should\n    protect them through your OS's normal user/group or ACL settings (to\n    prevent the rsync module's user from being able to change them), and then\n    hide them from the user's view via \"[exclude](#)\" (see how in the discussion of\n    that parameter).  However, it's easier and safer to setup a name converter.\n\n0.  `daemon chroot`\n\n    This parameter specifies a path to which the daemon will chroot before\n    beginning communication with clients. Module paths (and any \"[use chroot](#)\"\n    settings) will then be related to this one. This lets you choose if you\n    want the whole daemon to be chrooted (with this setting), just the\n    transfers to be chrooted (with \"[use chroot](#)\"), or both.  Keep in mind that\n    the \"daemon chroot\" area may need various OS/lib/etc files installed to\n    allow the daemon to function.  By default the daemon runs without any\n    chrooting.\n\n0.  `proxy protocol`\n\n    When this parameter is enabled, all incoming connections must start with a\n    V1 or V2 proxy protocol header.  If the header is not found, the connection\n    is closed.\n\n    Setting this to `true` requires a proxy server to forward source IP\n    information to rsync, allowing you to log proper IP/host info and make use\n    of client-oriented IP restrictions.  The default of `false` means that the\n    IP information comes directly from the socket's metadata.  If rsync is not\n    behind a proxy, this should be disabled.\n\n    _CAUTION_: using this option can be dangerous if you do not ensure that\n    only the proxy is allowed to connect to the rsync port.  If any non-proxied\n    connections are allowed through, the client will be able to use a modified\n    rsync to spoof any remote IP address that they desire.  You can lock this\n    down using something like iptables `-uid-owner root` rules (for strict\n    localhost access), various firewall rules, or you can require password\n    authorization so that any spoofing by users will not grant extra access.\n\n    This setting is global.  If you need some modules to require this and not\n    others, then you will need to setup multiple rsync daemon processes on\n    different ports.\n\n0.  `name converter`\n\n    This parameter lets you specify a program that will be run by the rsync\n    daemon to do user & group conversions between names & ids.  This script\n    is started prior to any chroot being setup, and runs as the daemon user\n    (not the transfer user).  You can specify a fully qualified pathname or\n    a program name that is on the $PATH.\n\n    The program can be used to do normal user & group lookups without having to\n    put any extra files into the chroot area of the module *or* you can do\n    customized conversions.\n\n    The nameconvert program has access to all of the environment variables that\n    are described in the section on `pre-xfer exec`.  This is useful if you\n    want to customize the conversion using information about the module and/or\n    the copy request.\n\n    There is a sample python script in the support dir named \"nameconvert\" that\n    implements the normal user & group lookups.  Feel free to customize it or\n    just use it as documentation to implement your own.\n\n0.  `numeric ids`\n\n    Enabling this parameter disables the mapping of users and groups by name\n    for the current daemon module.  This prevents the daemon from trying to\n    load any user/group-related files or libraries.  This enabling makes the\n    transfer behave as if the client had passed the `--numeric-ids`\n    command-line option.  By default, this parameter is enabled for chroot\n    modules and disabled for non-chroot modules.  Also keep in mind that\n    uid/gid preservation requires the module to be running as root (see \"[uid](#)\")\n    or for \"[fake super](#)\" to be configured.\n\n    A chroot-enabled module should not have this parameter set to false unless\n    you're using a \"[name converter](#)\" program *or* you've taken steps to ensure\n    that the module has the necessary resources it needs to translate names and\n    that it is not possible for a user to change those resources.\n\n0.  `munge symlinks`\n\n    This parameter tells rsync to modify all symlinks in the same way as the\n    (non-daemon-affecting) `--munge-links` command-line option (using a method\n    described below).  This should help protect your files from user trickery\n    when your daemon module is writable.  The default is disabled when\n    \"[use chroot](#)\" is on with an inside-chroot path of \"/\", OR if \"[daemon chroot](#)\"\n    is on, otherwise it is enabled.\n\n    If you disable this parameter on a daemon that is not read-only, there are\n    tricks that a user can play with uploaded symlinks to access\n    daemon-excluded items (if your module has any), and, if \"[use chroot](#)\" is\n    off, rsync can even be tricked into showing or changing data that is\n    outside the module's path (as access-permissions allow).\n\n    The way rsync disables the use of symlinks is to prefix each one with the\n    string \"/rsyncd-munged/\".  This prevents the links from being used as long\n    as that directory does not exist.  When this parameter is enabled, rsync\n    will refuse to run if that path is a directory or a symlink to a directory.\n    When using the \"munge symlinks\" parameter in a chroot area that has an\n    inside-chroot path of \"/\", you should add \"/rsyncd-munged/\" to the exclude\n    setting for the module so that a user can't try to create it.\n\n    Note:  rsync makes no attempt to verify that any pre-existing symlinks in\n    the module's hierarchy are as safe as you want them to be (unless, of\n    course, it just copied in the whole hierarchy).  If you setup an rsync\n    daemon on a new area or locally add symlinks, you can manually protect your\n    symlinks from being abused by prefixing \"/rsyncd-munged/\" to the start of\n    every symlink's value.  There is a perl script in the support directory of\n    the source code named \"munge-symlinks\" that can be used to add or remove\n    this prefix from your symlinks.\n\n    When this parameter is disabled on a writable module and \"[use chroot](#)\" is\n    off (or the inside-chroot path is not \"/\"), incoming symlinks will be\n    modified to drop a leading slash and to remove \"..\" path elements that\n    rsync believes will allow a symlink to escape the module's hierarchy.\n    There are tricky ways to work around this, though, so you had better trust\n    your users if you choose this combination of parameters.\n\n0.  `charset`\n\n    This specifies the name of the character set in which the module's\n    filenames are stored.  If the client uses an `--iconv` option, the daemon\n    will use the value of the \"charset\" parameter regardless of the character\n    set the client actually passed.  This allows the daemon to support charset\n    conversion in a chroot module without extra files in the chroot area, and\n    also ensures that name-translation is done in a consistent manner.  If the\n    \"charset\" parameter is not set, the `--iconv` option is refused, just as if\n    \"iconv\" had been specified via \"[refuse options](#)\".\n\n    If you wish to force users to always use `--iconv` for a particular module,\n    add \"no-iconv\" to the \"[refuse options](#)\" parameter.  Keep in mind that this\n    will restrict access to your module to very new rsync clients.\n\n0.  `max connections`\n\n    This parameter allows you to specify the maximum number of simultaneous\n    connections you will allow.  Any clients connecting when the maximum has\n    been reached will receive a message telling them to try later.  The default\n    is 0, which means no limit.  A negative value disables the module.  See\n    also the \"[lock file](#)\" parameter.\n\n0.  `log file`\n\n    When the \"log file\" parameter is set to a non-empty string, the rsync\n    daemon will log messages to the indicated file rather than using syslog.\n    This is particularly useful on systems (such as AIX) where **syslog()**\n    doesn't work for chrooted programs.  The file is opened before **chroot()**\n    is called, allowing it to be placed outside the transfer.  If this value is\n    set on a per-module basis instead of globally, the global log will still\n    contain any authorization failures or config-file error messages.\n\n    If the daemon fails to open the specified file, it will fall back to using\n    syslog and output an error about the failure.  (Note that the failure to\n    open the specified log file used to be a fatal error.)\n\n    This setting can be overridden by using the `--log-file=FILE` or\n    `--dparam=logfile=FILE` command-line options.  The former overrides all the\n    log-file parameters of the daemon and all module settings.  The latter sets\n    the daemon's log file and the default for all the modules, which still\n    allows modules to override the default setting.\n\n0.  `syslog facility`\n\n    This parameter allows you to specify the syslog facility name to use when\n    logging messages from the rsync daemon. You may use any standard syslog\n    facility name which is defined on your system. Common names are auth,\n    authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user,\n    uucp, local0, local1, local2, local3, local4, local5, local6 and local7.\n    The default is daemon.  This setting has no effect if the \"[log file](#)\"\n    setting is a non-empty string (either set in the per-modules settings, or\n    inherited from the global settings).\n\n0.  `syslog tag`\n\n    This parameter allows you to specify the syslog tag to use when logging\n    messages from the rsync daemon. The default is \"rsyncd\".  This setting has\n    no effect if the \"[log file](#)\" setting is a non-empty string (either set in\n    the per-modules settings, or inherited from the global settings).\n\n    For example, if you wanted each authenticated user's name to be included in\n    the syslog tag, you could do something like this:\n\n    >     syslog tag = rsyncd.%RSYNC_USER_NAME%\n\n0.  `max verbosity`\n\n    This parameter allows you to control the maximum amount of verbose\n    information that you'll allow the daemon to generate (since the information\n    goes into the log file). The default is 1, which allows the client to\n    request one level of verbosity.\n\n    This also affects the user's ability to request higher levels of `--info`\n    and `--debug` logging.  If the max value is 2, then no info and/or debug\n    value that is higher than what would be set by `-vv` will be honored by the\n    daemon in its logging.  To see how high of a verbosity level you need to\n    accept for a particular info/debug level, refer to `rsync --info=help` and\n    `rsync --debug=help`.  For instance, it takes max-verbosity 4 to be able to\n    output debug TIME2 and FLIST3.\n\n0.  `lock file`\n\n    This parameter specifies the file to use to support the \"[max connections](#)\"\n    parameter. The rsync daemon uses record locking on this file to ensure that\n    the max connections limit is not exceeded for the modules sharing the lock\n    file.  The default is `/var/run/rsyncd.lock`.\n\n0.  `read only`\n\n    This parameter determines whether clients will be able to upload files or\n    not. If \"read only\" is true then any attempted uploads will fail. If\n    \"read only\" is false then uploads will be possible if file permissions on\n    the daemon side allow them. The default is for all modules to be read only.\n\n    Note that \"[auth users](#)\" can override this setting on a per-user basis.\n\n0.  `write only`\n\n    This parameter determines whether clients will be able to download files or\n    not. If \"write only\" is true then any attempted downloads will fail. If\n    \"write only\" is false then downloads will be possible if file permissions\n    on the daemon side allow them.  The default is for this parameter to be\n    disabled.\n\n    Helpful hint: you probably want to specify \"refuse options = delete\" for a\n    write-only module.\n\n0.  `open noatime`\n\n    When set to True, this parameter tells the rsync daemon to open files with\n    the O_NOATIME flag\n    (on systems that support it) to avoid changing the access time of the files\n    that are being transferred.  If your OS does not support the O_NOATIME flag\n    then rsync will silently ignore this option.  Note also that some\n    filesystems are mounted to avoid updating the atime on read access even\n    without the O_NOATIME flag being set.\n\n    When set to False, this parameters ensures that files on the server are not\n    opened with O_NOATIME.\n\n    When set to Unset (the default) the user controls the setting via\n    `--open-noatime`.\n\n0.  `list`\n\n    This parameter determines whether this module is listed when the client\n    asks for a listing of available modules.  In addition, if this is false,\n    the daemon will pretend the module does not exist when a client denied by\n    \"[hosts allow](#)\" or \"[hosts deny](#)\" attempts to access it.  Realize that if\n    \"[reverse lookup](#)\" is disabled globally but enabled for the module, the\n    resulting reverse lookup to a potentially client-controlled DNS server may\n    still reveal to the client that it hit an existing module.  The default is\n    for modules to be listable.\n\n0.  `uid`\n\n    This parameter specifies the user name or user ID that file transfers to\n    and from that module should take place as when the daemon was run as root.\n    In combination with the \"[gid](#)\" parameter this determines what file\n    permissions are available. The default when run by a super-user is to\n    switch to the system's \"nobody\" user.  The default for a non-super-user is\n    to not try to change the user.  See also the \"[gid](#)\" parameter.\n\n    The RSYNC_USER_NAME environment variable may be used to request that rsync\n    run as the authorizing user.  For example, if you want a rsync to run as\n    the same user that was received for the rsync authentication, this setup is\n    useful:\n\n    >     uid = %RSYNC_USER_NAME%\n    >     gid = *\n\n0.  `gid`\n\n    This parameter specifies one or more group names/IDs that will be used when\n    accessing the module.  The first one will be the default group, and any\n    extra ones be set as supplemental groups.  You may also specify a \"`*`\" as\n    the first gid in the list, which will be replaced by all the normal groups\n    for the transfer's user (see \"[uid](#)\").  The default when run by a super-user\n    is to switch to your OS's \"nobody\" (or perhaps \"nogroup\") group with no\n    other supplementary groups.  The default for a non-super-user is to not\n    change any group attributes (and indeed, your OS may not allow a\n    non-super-user to try to change their group settings).\n\n    The specified list is normally split into tokens based on spaces and\n    commas.  However, if the list starts with a comma, then the list is only\n    split on commas, which allows a group name to contain a space.  In either\n    case any leading and/or trailing whitespace is removed from the tokens and\n    empty tokens are ignored.\n\n0.  `daemon uid`\n\n    This parameter specifies a uid under which the daemon will run. The daemon\n    usually runs as user root, and when this is left unset the user is left\n    unchanged. See also the \"[uid](#)\" parameter.\n\n0.  `daemon gid`\n\n    This parameter specifies a gid under which the daemon will run. The daemon\n    usually runs as group root, and when this is left unset, the group is left\n    unchanged. See also the \"[gid](#)\" parameter.\n\n0.  `fake super`\n\n    Setting \"fake super = yes\" for a module causes the daemon side to behave as\n    if the `--fake-super` command-line option had been specified.  This allows\n    the full attributes of a file to be stored without having to have the\n    daemon actually running as root.\n\n0.  `filter`\n\n    The daemon has its own filter chain that determines what files it will let\n    the client access.  This chain is not sent to the client and is independent\n    of any filters the client may have specified.  Files excluded by the daemon\n    filter chain (`daemon-excluded` files) are treated as non-existent if the\n    client tries to pull them, are skipped with an error message if the client\n    tries to push them (triggering exit code 23), and are never deleted from\n    the module.  You can use daemon filters to prevent clients from downloading\n    or tampering with private administrative files, such as files you may add\n    to support uid/gid name translations.\n\n    The daemon filter chain is built from the \"filter\", \"[include from](#)\",\n    \"[include](#)\", \"[exclude from](#)\", and \"[exclude](#)\" parameters, in that order of\n    priority.  Anchored patterns are anchored at the root of the module.  To\n    prevent access to an entire subtree, for example, \"`/secret`\", you **must**\n    exclude everything in the subtree; the easiest way to do this is with a\n    triple-star pattern like \"`/secret/***`\".\n\n    The \"filter\" parameter takes a space-separated list of daemon filter rules,\n    though it is smart enough to know not to split a token at an internal space\n    in a rule (e.g. \"`- /foo  - /bar`\" is parsed as two rules).  You may specify\n    one or more merge-file rules using the normal syntax.  Only one \"filter\"\n    parameter can apply to a given module in the config file, so put all the\n    rules you want in a single parameter.  Note that per-directory merge-file\n    rules do not provide as much protection as global rules, but they can be\n    used to make `--delete` work better during a client download operation if\n    the per-dir merge files are included in the transfer and the client\n    requests that they be used.\n\n0.  `exclude`\n\n    This parameter takes a space-separated list of daemon exclude patterns.  As\n    with the client `--exclude` option, patterns can be qualified with \"`- `\" or\n    \"`+ `\" to explicitly indicate exclude/include.  Only one \"exclude\" parameter\n    can apply to a given module.  See the \"filter\" parameter for a description\n    of how excluded files affect the daemon.\n\n0.  `include`\n\n    Use an \"include\" to override the effects of the \"[exclude](#)\" parameter.  Only\n    one \"include\" parameter can apply to a given module.  See the \"[filter](#)\"\n    parameter for a description of how excluded files affect the daemon.\n\n0.  `exclude from`\n\n    This parameter specifies the name of a file on the daemon that contains\n    daemon exclude patterns, one per line.  Only one \"exclude from\" parameter\n    can apply to a given module; if you have multiple exclude-from files, you\n    can specify them as a merge file in the \"[filter](#)\" parameter.  See the\n    \"[filter](#)\" parameter for a description of how excluded files affect the\n    daemon.\n\n0.  `include from`\n\n    Analogue of \"[exclude from](#)\" for a file of daemon include patterns.  Only one\n    \"include from\" parameter can apply to a given module.  See the \"[filter](#)\"\n    parameter for a description of how excluded files affect the daemon.\n\n0.  `incoming chmod`\n\n    This parameter allows you to specify a set of comma-separated chmod strings\n    that will affect the permissions of all incoming files (files that are\n    being received by the daemon).  These changes happen after all other\n    permission calculations, and this will even override destination-default\n    and/or existing permissions when the client does not specify `--perms`.\n    See the description of the `--chmod` rsync option and the **chmod**(1)\n    manpage for information on the format of this string.\n\n0.  `outgoing chmod`\n\n    This parameter allows you to specify a set of comma-separated chmod strings\n    that will affect the permissions of all outgoing files (files that are\n    being sent out from the daemon).  These changes happen first, making the\n    sent permissions appear to be different than those stored in the filesystem\n    itself.  For instance, you could disable group write permissions on the\n    server while having it appear to be on to the clients.  See the description\n    of the `--chmod` rsync option and the **chmod**(1) manpage for information\n    on the format of this string.\n\n0.  `auth users`\n\n    This parameter specifies a comma and/or space-separated list of\n    authorization rules.  In its simplest form, you list the usernames that\n    will be allowed to connect to this module. The usernames do not need to\n    exist on the local system. The rules may contain shell wildcard characters\n    that will be matched against the username provided by the client for\n    authentication. If \"auth users\" is set then the client will be challenged\n    to supply a username and password to connect to the module. A challenge\n    response authentication protocol is used for this exchange. The plain text\n    usernames and passwords are stored in the file specified by the\n    \"[secrets file](#)\" parameter. The default is for all users to be able to\n    connect without a password (this is called \"anonymous rsync\").\n\n    In addition to username matching, you can specify groupname matching via a\n    '@' prefix.  When using groupname matching, the authenticating username\n    must be a real user on the system, or it will be assumed to be a member of\n    no groups.  For example, specifying \"@rsync\" will match the authenticating\n    user if the named user is a member of the rsync group.\n\n    Finally, options may be specified after a colon (:).  The options allow you\n    to \"deny\" a user or a group, set the access to \"ro\" (read-only), or set the\n    access to \"rw\" (read/write).  Setting an auth-rule-specific ro/rw setting\n    overrides the module's \"[read only](#)\" setting.\n\n    Be sure to put the rules in the order you want them to be matched, because\n    the checking stops at the first matching user or group, and that is the\n    only auth that is checked.  For example:\n\n    >     auth users = joe:deny @guest:deny admin:rw @rsync:ro susan joe sam\n\n    In the above rule, user joe will be denied access no matter what.  Any user\n    that is in the group \"guest\" is also denied access.  The user \"admin\" gets\n    access in read/write mode, but only if the admin user is not in group\n    \"guest\" (because the admin user-matching rule would never be reached if the\n    user is in group \"guest\").  Any other user who is in group \"rsync\" will get\n    read-only access.  Finally, users susan, joe, and sam get the ro/rw setting\n    of the module, but only if the user didn't match an earlier group-matching\n    rule.\n\n    If you need to specify a user or group name with a space in it, start your\n    list with a comma to indicate that the list should only be split on commas\n    (though leading and trailing whitespace will also be removed, and empty\n    entries are just ignored).  For example:\n\n    >     auth users = , joe:deny, @Some Group:deny, admin:rw, @RO Group:ro\n\n    See the description of the secrets file for how you can have per-user\n    passwords as well as per-group passwords.  It also explains how a user can\n    authenticate using their user password or (when applicable) a group\n    password, depending on what rule is being authenticated.\n\n    See also the section entitled \"USING RSYNC-DAEMON FEATURES VIA A REMOTE\n    SHELL CONNECTION\" in **rsync**(1) for information on how handle an\n    rsyncd.conf-level username that differs from the remote-shell-level\n    username when using a remote shell to connect to an rsync daemon.\n\n0.  `secrets file`\n\n    This parameter specifies the name of a file that contains the\n    username:password and/or @groupname:password pairs used for authenticating\n    this module. This file is only consulted if the \"[auth users](#)\" parameter is\n    specified.  The file is line-based and contains one name:password pair per\n    line.  Any line has a hash (#) as the very first character on the line is\n    considered a comment and is skipped.  The passwords can contain any\n    characters but be warned that many operating systems limit the length of\n    passwords that can be typed at the client end, so you may find that\n    passwords longer than 8 characters don't work.\n\n    The use of group-specific lines are only relevant when the module is being\n    authorized using a matching \"@groupname\" rule.  When that happens, the user\n    can be authorized via either their \"username:password\" line or the\n    \"@groupname:password\" line for the group that triggered the authentication.\n\n    It is up to you what kind of password entries you want to include, either\n    users, groups, or both.  The use of group rules in \"[auth users](#)\" does not\n    require that you specify a group password if you do not want to use shared\n    passwords.\n\n    There is no default for the \"secrets file\" parameter, you must choose a\n    name (such as `/etc/rsyncd.secrets`).  The file must normally not be\n    readable by \"other\"; see \"[strict modes](#)\".  If the file is not found or is\n    rejected, no logins for an \"[auth users](#)\" module will be possible.\n\n0.  `strict modes`\n\n    This parameter determines whether or not the permissions on the secrets\n    file will be checked.  If \"strict modes\" is true, then the secrets file\n    must not be readable by any user ID other than the one that the rsync\n    daemon is running under.  If \"strict modes\" is false, the check is not\n    performed.  The default is true.  This parameter was added to accommodate\n    rsync running on the Windows operating system.\n\n0.  `hosts allow`\n\n    This parameter allows you to specify a list of comma- and/or\n    whitespace-separated patterns that are matched against a connecting\n    client's hostname and IP address.  If none of the patterns match, then the\n    connection is rejected.\n\n    Each pattern can be in one of six forms:\n\n    - a dotted decimal IPv4 address of the form a.b.c.d, or an IPv6 address of\n      the form a:b:c::d:e:f. In this case the incoming machine's IP address\n      must match exactly.\n    - an address/mask in the form ipaddr/n where ipaddr is the IP address and n\n      is the number of one bits in the netmask.  All IP addresses which match\n      the masked IP address will be allowed in.\n    - an address/mask in the form ipaddr/maskaddr where ipaddr is the IP\n      address and maskaddr is the netmask in dotted decimal notation for IPv4,\n      or similar for IPv6, e.g. ffff:ffff:ffff:ffff:: instead of /64. All IP\n      addresses which match the masked IP address will be allowed in.\n    - a hostname pattern using wildcards. If the hostname of the connecting IP\n      (as determined by a reverse lookup) matches the wildcarded name (using\n      the same rules as normal Unix filename matching), the client is allowed\n      in.  This only works if \"[reverse lookup](#)\" is enabled (the default).\n    - a hostname. A plain hostname is matched against the reverse DNS of the\n      connecting IP (if \"[reverse lookup](#)\" is enabled), and/or the IP of the\n      given hostname is matched against the connecting IP (if \"[forward lookup](#)\"\n      is enabled, as it is by default).  Any match will be allowed in.\n    - an '@' followed by a netgroup name, which will match if the reverse DNS\n      of the connecting IP is in the specified netgroup.\n\n    Note IPv6 link-local addresses can have a scope in the address\n    specification:\n\n    >     fe80::1%link1\n    >     fe80::%link1/64\n    >     fe80::%link1/ffff:ffff:ffff:ffff::\n\n    You can also combine \"hosts allow\" with \"[hosts deny](#)\" as a way to add\n    exceptions to your deny list.  When both parameters are specified, the\n    \"hosts allow\" parameter is checked first and a match results in the client\n    being able to connect.  A non-allowed host is then matched against the\n    \"[hosts deny](#)\" list to see if it should be rejected.  A host that does not\n    match either list is allowed to connect.\n\n    The default is no \"hosts allow\" parameter, which means all hosts can\n    connect.\n\n0.  `hosts deny`\n\n    This parameter allows you to specify a list of comma- and/or\n    whitespace-separated patterns that are matched against a connecting clients\n    hostname and IP address. If the pattern matches then the connection is\n    rejected. See the \"[hosts allow](#)\" parameter for more information.\n\n    The default is no \"hosts deny\" parameter, which means all hosts can\n    connect.\n\n0.  `reverse lookup`\n\n    Controls whether the daemon performs a reverse lookup on the client's IP\n    address to determine its hostname, which is used for \"[hosts allow](#)\" &\n    \"[hosts deny](#)\" checks and the \"%h\" log escape.  This is enabled by default,\n    but you may wish to disable it to save time if you know the lookup will not\n    return a useful result, in which case the daemon will use the name\n    \"UNDETERMINED\" instead.\n\n    If this parameter is enabled globally (even by default), rsync performs the\n    lookup as soon as a client connects, so disabling it for a module will not\n    avoid the lookup.  Thus, you probably want to disable it globally and then\n    enable it for modules that need the information.\n\n0.  `forward lookup`\n\n    Controls whether the daemon performs a forward lookup on any hostname\n    specified in an hosts allow/deny setting.  By default this is enabled,\n    allowing the use of an explicit hostname that would not be returned by\n    reverse DNS of the connecting IP.\n\n0.  `ignore errors`\n\n    This parameter tells rsyncd to ignore I/O errors on the daemon when\n    deciding whether to run the delete phase of the transfer. Normally rsync\n    skips the `--delete` step if any I/O errors have occurred in order to\n    prevent disastrous deletion due to a temporary resource shortage or other\n    I/O error. In some cases this test is counter productive so you can use\n    this parameter to turn off this behavior.\n\n0.  `ignore nonreadable`\n\n    This tells the rsync daemon to completely ignore files that are not\n    readable by the user. This is useful for public archives that may have some\n    non-readable files among the directories, and the sysadmin doesn't want\n    those files to be seen at all.\n\n0.  `transfer logging`\n\n    This parameter enables per-file logging of downloads and uploads in a\n    format somewhat similar to that used by ftp daemons.  The daemon always\n    logs the transfer at the end, so if a transfer is aborted, no mention will\n    be made in the log file.\n\n    If you want to customize the log lines, see the \"[log format](#)\" parameter.\n\n0.  `log format`\n\n    This parameter allows you to specify the format used for logging file\n    transfers when transfer logging is enabled.  The format is a text string\n    containing embedded single-character escape sequences prefixed with a\n    percent (%) character.  An optional numeric field width may also be\n    specified between the percent and the escape letter (e.g.\n    \"`%-50n %8l %07p`\").  In addition, one or more apostrophes may be specified\n    prior to a numerical escape to indicate that the numerical value should be\n    made more human-readable.  The 3 supported levels are the same as for the\n    `--human-readable` command-line option, though the default is for\n    human-readability to be off.  Each added apostrophe increases the level\n    (e.g. \"`%''l %'b %f`\").\n\n    The default log format is \"`%o %h [%a] %m (%u) %f %l`\", and a \"`%t [%p] `\"\n    is always prefixed when using the \"[log file](#)\" parameter.  (A perl script\n    that will summarize this default log format is included in the rsync source\n    code distribution in the \"support\" subdirectory: rsyncstats.)\n\n    The single-character escapes that are understood are as follows:\n\n    - %a the remote IP address (only available for a daemon)\n    - %b the number of bytes actually transferred\n    - %B the permission bits of the file (e.g. rwxrwxrwt)\n    - %c the total size of the block checksums received for the basis file\n      (only when sending)\n    - %C the full-file checksum if it is known for the file. For older rsync\n      protocols/versions, the checksum was salted, and is thus not a useful\n      value (and is not displayed when that is the case). For the checksum to\n      output for a file, either the `--checksum` option must be in-effect or\n      the file must have been transferred without a salted checksum being used.\n      See the `--checksum-choice` option for a way to choose the algorithm.\n    - %f the filename (long form on sender; no trailing \"/\")\n    - %G the gid of the file (decimal) or \"DEFAULT\"\n    - %h the remote host name (only available for a daemon)\n    - %i an itemized list of what is being updated\n    - %l the length of the file in bytes\n    - %L the string \"` -> SYMLINK`\", \"` => HARDLINK`\", or \"\" (where `SYMLINK`\n      or `HARDLINK` is a filename)\n    - %m the module name\n    - %M the last-modified time of the file\n    - %n the filename (short form; trailing \"/\" on dir)\n    - %o the operation, which is \"send\", \"recv\", or \"del.\" (the latter includes\n      the trailing period)\n    - %p the process ID of this rsync session\n    - %P the module path\n    - %t the current date time\n    - %u the authenticated username or an empty string\n    - %U the uid of the file (decimal)\n\n    For a list of what the characters mean that are output by \"%i\", see the\n    `--itemize-changes` option in the rsync manpage.\n\n    Note that some of the logged output changes when talking with older rsync\n    versions.  For instance, deleted files were only output as verbose messages\n    prior to rsync 2.6.4.\n\n0.  `timeout`\n\n    This parameter allows you to override the clients choice for I/O timeout\n    for this module. Using this parameter you can ensure that rsync won't wait\n    on a dead client forever. The timeout is specified in seconds. A value of\n    zero means no timeout and is the default. A good choice for anonymous rsync\n    daemons may be 600 (giving a 10 minute timeout).\n\n0.  `refuse options`\n\n    This parameter allows you to specify a space-separated list of rsync\n    command-line options that will be refused by your rsync daemon.  You may\n    specify the full option name, its one-letter abbreviation, or a wild-card\n    string that matches multiple options. Beginning in 3.2.0, you can also\n    negate a match term by starting it with a \"!\".\n\n    When an option is refused, the daemon prints an error message and exits.\n\n    For example, this would refuse `--checksum` (`-c`) and all the various\n    delete options:\n\n    >     refuse options = c delete\n\n    The reason the above refuses all delete options is that the options imply\n    `--delete`, and implied options are refused just like explicit options.\n\n    The use of a negated match allows you to fine-tune your refusals after a\n    wild-card, such as this:\n\n    >     refuse options = delete-* !delete-during\n\n    Negated matching can also turn your list of refused options into a list of\n    accepted options. To do this, begin the list with a \"`*`\" (to refuse all\n    options) and then specify one or more negated matches to accept.  For\n    example:\n\n    >     refuse options = * !a !v !compress*\n\n    Don't worry that the \"`*`\" will refuse certain vital options such as\n    `--dry-run`, `--server`, `--no-iconv`, `--seclude-args`, etc. These\n    important options are not matched by wild-card, so they must be overridden\n    by their exact name.  For instance, if you're forcing iconv transfers you\n    could use something like this:\n\n    >     refuse options = * no-iconv !a !v\n\n    As an additional aid (beginning in 3.2.0), refusing (or \"`!refusing`\") the\n    \"a\" or \"archive\"  option also affects all the options that the `--archive`\n    option implies (`-rdlptgoD`), but only if the option  is matched explicitly\n    (not using a wildcard). If you want to do something tricky, you can use\n    \"`archive*`\" to avoid this side-effect, but keep in mind that no normal\n    rsync client ever sends the actual archive option to the server.\n\n    As an additional safety feature, the refusal of \"delete\" also refuses\n    `remove-source-files` when the daemon is the sender; if you want the latter\n    without the former, instead refuse \"`delete-*`\" as that refuses all the\n    delete modes without affecting `--remove-source-files`. (Keep in mind that\n    the client's `--delete` option typically results in `--delete-during`.)\n\n    When un-refusing delete options, you should either specify \"`!delete*`\" (to\n    accept all delete options) or specify a limited set that includes \"delete\",\n    such as:\n\n    >     refuse options = * !a !delete !delete-during\n\n    ... whereas this accepts any delete option except `--delete-after`:\n\n    >     refuse options = * !a !delete* delete-after\n\n    A note on refusing \"compress\": it may be better to set the \"[dont compress](#)\"\n    daemon parameter to \"`*`\" and ensure that `RSYNC_COMPRESS_LIST=zlib` is set\n    in the environment of the daemon in order to disable compression silently\n    instead of returning an error that forces the client to remove the `-z`\n    option.\n\n    If you are un-refusing the compress option, you may want to match\n    \"`!compress*`\" if you also want to allow the `--compress-level` option.\n\n    Note that the \"copy-devices\" & \"write-devices\" options are refused by\n    default, but they can be explicitly accepted with \"`!copy-devices`\" and/or\n    \"`!write-devices`\".  The options \"log-file\" and \"log-file-format\" are\n    forcibly refused and cannot be accepted.\n\n    Here are all the options that are not matched by wild-cards:\n\n    - `--server`: Required for rsync to even work.\n    - `--rsh`, `-e`: Required to convey compatibility flags to the server.\n    - `--out-format`: This is required to convey output behavior to a remote\n      receiver.  While rsync passes the older alias `--log-format` for\n      compatibility reasons, this options should not be confused with\n      `--log-file-format`.\n    - `--sender`: Use \"[write only](#)\" parameter instead of refusing this.\n    - `--dry-run`, `-n`: Who would want to disable this?\n    - `--seclude-args`, `-s`: Is the oldest arg-protection method.\n    - `--from0`, `-0`: Makes it easier to accept/refuse `--files-from` without\n      affecting this helpful modifier.\n    - `--iconv`: This is auto-disabled based on \"[charset](#)\" parameter.\n    - `--no-iconv`: Most transfers use this option.\n    - `--checksum-seed`: Is a fairly rare, safe option.\n    - `--write-devices`: Is non-wild but also auto-disabled.\n\n0.  `dont compress`\n\n    **NOTE:** This parameter currently has no effect except in one instance: if\n    it is set to \"`*`\" then it minimizes or disables compression for all files\n    (for those that don't want to refuse the `--compress` option completely).\n\n    This parameter allows you to select filenames based on wildcard patterns\n    that should not be compressed when pulling files from the daemon (no\n    analogous parameter exists to govern the pushing of files to a daemon).\n    Compression can be expensive in terms of CPU usage, so it is usually good\n    to not try to compress files that won't compress well, such as already\n    compressed files.\n\n    The \"dont compress\" parameter takes a space-separated list of\n    case-insensitive wildcard patterns. Any source filename matching one of the\n    patterns will be compressed as little as possible during the transfer.  If\n    the compression algorithm has an \"off\" level, then no compression occurs\n    for those files.  If an algorithms has the ability to change the level in\n    mid-stream, it will be minimized to reduce the CPU usage as much as\n    possible.\n\n    See the `--skip-compress` parameter in the **rsync**(1) manpage for the\n    list of file suffixes that are skipped by default if this parameter is not\n    set.\n\n0.  `early exec`, `pre-xfer exec`, `post-xfer exec`\n\n    You may specify a command to be run in the early stages of the connection,\n    or right before and/or after the transfer.  If the `early exec` or\n    `pre-xfer exec` command returns an error code, the transfer is aborted\n    before it begins.  Any output from the `pre-xfer exec` command on stdout\n    (up to several KB) will be displayed to the user when aborting, but is\n    _not_ displayed if the script returns success.  The other programs cannot\n    send any text to the user.  All output except for the `pre-xfer exec`\n    stdout goes to the corresponding daemon's stdout/stderr, which is typically\n    discarded.  See the `--no-detach` option for a way to see the daemon's\n    output, which can assist with debugging.\n\n    Note that the `early exec` command runs before any part of the transfer\n    request is known except for the module name.  This helper script can be\n    used to setup a disk mount or decrypt some data into a module dir, but you\n    may need to use `lock file` and `max connections` to avoid concurrency\n    issues.  If the client rsync specified the `--early-input=FILE` option, it\n    can send up to about 5K of data to the stdin of the early script.  The\n    stdin will otherwise be empty.\n\n    Note that the `post-xfer exec` command is still run even if one of the\n    other scripts returns an error code. The `pre-xfer exec` command will _not_\n    be run, however, if the `early exec` command fails.\n\n    The following environment variables will be set, though some are specific\n    to the pre-xfer or the post-xfer environment:\n\n    - `RSYNC_MODULE_NAME`: The name of the module being accessed.\n    - `RSYNC_MODULE_PATH`: The path configured for the module.\n    - `RSYNC_HOST_ADDR`: The accessing host's IP address.\n    - `RSYNC_HOST_NAME`: The accessing host's name.\n    - `RSYNC_USER_NAME`: The accessing user's name (empty if no user).\n    - `RSYNC_PID`: A unique number for this transfer.\n    - `RSYNC_REQUEST`: (pre-xfer only) The module/path info specified by the\n      user.  Note that the user can specify multiple source files, so the\n      request can be something like \"mod/path1 mod/path2\", etc.\n    - `RSYNC_ARG#`: (pre-xfer only) The pre-request arguments are set in these\n      numbered values. RSYNC_ARG0 is always \"rsyncd\", followed by the options\n      that were used in RSYNC_ARG1, and so on.  There will be a value of \".\"\n      indicating that the options are done and the path args are beginning --\n      these contain similar information to RSYNC_REQUEST, but with values\n      separated and the module name stripped off.\n    - `RSYNC_EXIT_STATUS`: (post-xfer only) the server side's exit value.  This\n      will be 0 for a successful run, a positive value for an error that the\n      server generated, or a -1 if rsync failed to exit properly.  Note that an\n      error that occurs on the client side does not currently get sent to the\n      server side, so this is not the final exit status for the whole transfer.\n    - `RSYNC_RAW_STATUS`: (post-xfer only) the raw exit value from\n      **waitpid()**.\n\n    Even though the commands can be associated with a particular module, they\n    are run using the permissions of the user that started the daemon (not the\n    module's uid/gid setting) without any chroot restrictions.\n\n    These settings honor 2 environment variables: use RSYNC_SHELL to set a\n    shell to use when running the command (which otherwise uses your\n    **system()** call's default shell), and use RSYNC_NO_XFER_EXEC to disable\n    both options completely.\n\n## CONFIG DIRECTIVES\n\nThere are currently two config directives available that allow a config file to\nincorporate the contents of other files:  `&include` and `&merge`.  Both allow\na reference to either a file or a directory.  They differ in how segregated the\nfile's contents are considered to be.\n\nThe `&include` directive treats each file as more distinct, with each one\ninheriting the defaults of the parent file, starting the parameter parsing as\nglobals/defaults, and leaving the defaults unchanged for the parsing of the\nrest of the parent file.\n\nThe `&merge` directive, on the other hand, treats the file's contents as if it\nwere simply inserted in place of the directive, and thus it can set parameters\nin a module started in another file, can affect the defaults for other files,\netc.\n\nWhen an `&include` or `&merge` directive refers to a directory, it will read in\nall the `*.conf` or `*.inc` files (respectively) that are contained inside that\ndirectory (without any recursive scanning), with the files sorted into alpha\norder.  So, if you have a directory named \"rsyncd.d\" with the files \"foo.conf\",\n\"bar.conf\", and \"baz.conf\" inside it, this directive:\n\n>     &include /path/rsyncd.d\n\nwould be the same as this set of directives:\n\n>     &include /path/rsyncd.d/bar.conf\n>     &include /path/rsyncd.d/baz.conf\n>     &include /path/rsyncd.d/foo.conf\n\nexcept that it adjusts as files are added and removed from the directory.\n\nThe advantage of the `&include` directive is that you can define one or more\nmodules in a separate file without worrying about unintended side-effects\nbetween the self-contained module files.\n\nThe advantage of the `&merge` directive is that you can load config snippets\nthat can be included into multiple module definitions, and you can also set\nglobal values that will affect connections (such as `motd file`), or globals\nthat will affect other include files.\n\nFor example, this is a useful /etc/rsyncd.conf file:\n\n>     port = 873\n>     log file = /var/log/rsync.log\n>     pid file = /var/lock/rsync.lock\n>\n>     &merge /etc/rsyncd.d\n>     &include /etc/rsyncd.d\n\nThis would merge any `/etc/rsyncd.d/*.inc` files (for global values that should\nstay in effect), and then include any `/etc/rsyncd.d/*.conf` files (defining\nmodules without any global-value cross-talk).\n\n## AUTHENTICATION STRENGTH\n\nThe authentication protocol used in rsync is a 128 bit MD4 based challenge\nresponse system. This is fairly weak protection, though (with at least one\nbrute-force hash-finding algorithm publicly available), so if you want really\ntop-quality security, then I recommend that you run rsync over ssh.  (Yes, a\nfuture version of rsync will switch over to a stronger hashing method.)\n\nAlso note that the rsync daemon protocol does not currently provide any\nencryption of the data that is transferred over the connection. Only\nauthentication is provided. Use ssh as the transport if you want encryption.\n\nYou can also make use of SSL/TLS encryption if you put rsync behind an\nSSL proxy.\n\n## SSL/TLS Daemon Setup\n\nWhen setting up an rsync daemon for access via SSL/TLS, you will need to\nconfigure a TCP proxy (such as haproxy or nginx) as the front-end that handles\nthe encryption.\n\n- You should limit the access to the backend-rsyncd port to only allow the\n  proxy to connect.  If it is on the same host as the proxy, then configuring\n  it to only listen on localhost is a good idea.\n- You should consider turning on the `proxy protocol` rsync-daemon parameter if\n  your proxy supports sending that information.  The examples below assume that\n  this is enabled.\n\nAn example haproxy setup is as follows:\n\n> ```\n> frontend fe_rsync-ssl\n>    bind :::874 ssl crt /etc/letsencrypt/example.com/combined.pem\n>    mode tcp\n>    use_backend be_rsync\n>\n> backend be_rsync\n>    mode tcp\n>    server local-rsync 127.0.0.1:873 check send-proxy\n> ```\n\nAn example nginx proxy setup is as follows:\n\n> ```\n> stream {\n>    server {\n>        listen 874 ssl;\n>        listen [::]:874 ssl;\n>\n>        ssl_certificate /etc/letsencrypt/example.com/fullchain.pem;\n>        ssl_certificate_key /etc/letsencrypt/example.com/privkey.pem;\n>\n>        proxy_pass localhost:873;\n>        proxy_protocol on; # Requires rsyncd.conf \"proxy protocol = true\"\n>        proxy_timeout 1m;\n>        proxy_connect_timeout 5s;\n>    }\n> }\n> ```\n\nIf rsyncd should be accessible encrypted and unencrypted at the same time make\nthe proxy listen on port 873 as well and let it handle both streams.\n\n## DAEMON CONFIG EXAMPLES\n\nA simple rsyncd.conf file that allow anonymous rsync to a ftp area at\n`/home/ftp` would be:\n\n> ```\n> [ftp]\n>         path = /home/ftp\n>         comment = ftp export area\n> ```\n\nA more sophisticated example would be:\n\n> ```\n> uid = nobody\n> gid = nobody\n> use chroot = yes\n> max connections = 4\n> syslog facility = local5\n> pid file = /var/run/rsyncd.pid\n>\n> [ftp]\n>         path = /var/ftp/./pub\n>         comment = whole ftp area (approx 6.1 GB)\n>\n> [sambaftp]\n>         path = /var/ftp/./pub/samba\n>         comment = Samba ftp area (approx 300 MB)\n>\n> [rsyncftp]\n>         path = /var/ftp/./pub/rsync\n>         comment = rsync ftp area (approx 6 MB)\n>\n> [sambawww]\n>         path = /public_html/samba\n>         comment = Samba WWW pages (approx 240 MB)\n>\n> [cvs]\n>         path = /data/cvs\n>         comment = CVS repository (requires authentication)\n>         auth users = tridge, susan\n>         secrets file = /etc/rsyncd.secrets\n> ```\n\nThe /etc/rsyncd.secrets file would look something like this:\n\n>     tridge:mypass\n>     susan:herpass\n\n## FILES\n\n/etc/rsyncd.conf or rsyncd.conf\n\n## SEE ALSO\n\n[**rsync**(1)](rsync.1), [**rsync-ssl**(1)](rsync-ssl.1)\n\n## BUGS\n\nPlease report bugs! The rsync bug tracking system is online at\n<https://rsync.samba.org/>.\n\n## VERSION\n\nThis manpage is current for version @VERSION@ of rsync.\n\n## CREDITS\n\nRsync is distributed under the GNU General Public License.  See the file\n[COPYING](COPYING) for details.\n\nAn rsync web site is available at <https://rsync.samba.org/> and its github\nproject is <https://github.com/RsyncProject/rsync>.\n\n## THANKS\n\nThanks to Warren Stanley for his original idea and patch for the rsync daemon.\nThanks to Karsten Thygesen for his many suggestions and documentation!\n\n## AUTHOR\n\nRsync was originally written by Andrew Tridgell and Paul Mackerras.  Many\npeople from around the world have helped to maintain and improve it.\n\nMailing lists for support and development are available at\n<https://lists.samba.org/>.\n"
        },
        {
          "name": "rsyncsh.txt",
          "type": "blob",
          "size": 1.3076171875,
          "content": "rsyncsh\nCopyright (C) 2001 by Martin Pool\n\nThis is a quick hack to build an interactive shell around rsync, the\nsame way we have the ftp, lftp and ncftp programs for the FTP\nprotocol.  The key application for this is connecting to a public\nrsync server, such as rsync.kernel.org, change down through and list\ndirectories, and finally pull down the file you want.\n\nrsync is somewhat ill-at-ease as an interactive operation, since every\nnetwork connection is used to carry out exactly one operation.  rsync\nkind of \"forks across the network\" passing the options and filenames\nto operate upon, and the connection is closed when the transfer is\ncomplete.  (This might be fixed in the future, either by adapting the\ncurrent protocol to allow chained operations over a single socket, or\nby writing a new protocol that better supports interactive use.)\n\nSo, rsyncsh runs a new rsync command and opens a new socket for every\n(network-based) command you type.\n\nThis has two consequences.  Firstly, there is more command latency\nthan is really desirable.  More seriously, if the connection cannot be\ndone automatically, because for example it uses SSH with a password,\nthen you will need to enter the password every time.  We might even\nfix this in the future, though, by having a way to automatically feed\nthe password to SSH if it's entered once.\n"
        },
        {
          "name": "runtests.sh",
          "type": "blob",
          "size": 11.0546875,
          "content": "#! /bin/sh\n\n# Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>\n# Copyright (C) 2003-2022 Wayne Davison\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version\n# 2 as published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n# -------------------------------------------------------------------------\n\n# rsync top-level test script -- this invokes all the other more\n# detailed tests in order.  This script can either be called by `make\n# check' or `make installcheck'.  `check' runs against the copies of\n# the program and other files in the build directory, and\n# `installcheck' against the installed copy of the program.\n\n# It can also be called on a single test file using a run like this:\n#\n#  preserve_scratch=yes whichtests=itemize.test ./runtests.sh\n\n# In either case we need to also be able to find the source directory,\n# since we read test scripts and possibly other information from\n# there.\n\n# Whenever possible, informational messages are written to stdout and\n# error messages to stderr.  They're separated out by the build farm\n# display scripts.\n\n# According to the GNU autoconf manual, the only valid place to set up\n# directory locations is through Make, since users are allowed to (try\n# to) change their mind on the Make command line.  So, Make has to\n# pass in all the values we need.\n\n# For other configured settings we read ./config.sh, which tells us\n# about shell commands on this machine and similar things.\n\n# rsync_bin gives the location of the rsync binary.  This is either\n# builddir/rsync if we're testing an uninstalled copy, or\n# install_prefix/bin/rsync if we're testing an installed copy.  On the\n# build farm rsync will be installed, but into a scratch /usr.\n\n# srcdir gives the location of the source tree, which lets us find the\n# build scripts.  At the moment we assume we are invoked from the\n# source directory.\n\n# This script must be invoked from the build directory.\n\n# A scratch directory, 'testtmp', is used in the build directory to\n# hold per-test subdirectories.\n\n# This script also uses the $loglevel environment variable.  1 is the\n# default value, and 10 the most verbose.  You can set this from the\n# Make command line.  It's also set by the build farm to give more\n# detail for failing builds.\n\n# -------------------------------------------------------------------------\n\n# NOTES FOR TEST CASES:\n\n# Each test case runs in its own shell.\n\n# Exit codes from tests:\n\n#    1  tests failed\n#    2  error in starting tests\n#   77  this test skipped (random value unlikely to happen by chance, same as\n#       automake)\n\n# HOWEVER, the overall exit code to the farm is different: we return\n# the *number of tests that failed*, so that it will show up nicely in\n# the overall summary.\n\n# rsync.fns contains some general setup functions and definitions.\n\n# -------------------------------------------------------------------------\n\n# NOTES ON PORTABILITY:\n\n# Both this script and the Makefile have to be pretty conservative\n# about which Unix features they use.\n\n# We cannot count on Make exporting variables to commands, unless\n# they're explicitly given on the command line.\n\n# Also, we can't count on 'cp -a' or 'mkdir -p', although they're\n# pretty handy (see function makepath for the latter).\n\n# I think some of the GNU documentation suggests that we shouldn't\n# rely on shell functions.  However, the Bash manual seems to say that\n# they're in POSIX 1003.2, and since the build farm relies on them\n# they're probably working on most machines we really care about.\n\n# You cannot use \"function foo {\" syntax, but must instead say \"foo()\n# {\", or it breaks on FreeBSD.\n\n# BSD machines tend not to have \"head\" or \"seq\".\n\n# You cannot do \"export VAR=VALUE\" all on one line; the export must be\n# separate from the assignment.  (SCO SysV)\n\n# Don't rely on grep -q, as that doesn't work everywhere -- just redirect\n# stdout to /dev/null to keep it quiet.\n\n# -------------------------------------------------------------------------\n\n# STILL TO DO:\n\n# We need a good protection against tests that hang indefinitely.\n# Perhaps some combination of starting them in the background, wait,\n# and kill?\n\n# Perhaps we need a common way to cleanup tests.  At the moment just\n# clobbering the directory when we're done should be enough.\n\n# If any of the targets fail, then (GNU?) Make returns 2, instead of\n# the return code from the failing command.  This is fine, but it\n# means that the build farm just shows \"2\" for failed tests, not the\n# number of tests that actually failed.  For more details we might\n# need to grovel through the log files to find a line saying how many\n# failed.\n\n\nset -e\n\n. \"./shconfig\"\n\nRUNSHFLAGS='-e'\nexport RUNSHFLAGS\n\n# for Solaris\nif [ -d /usr/xpg4/bin ]; then\n    PATH=\"/usr/xpg4/bin/:$PATH\"\n    export PATH\nfi\n\nif [ \"x$loglevel\" != x ] && [ \"$loglevel\" -gt 8 ]; then\n    if set -x; then\n\t# If it doesn't work the first time, don't keep trying.\n\tRUNSHFLAGS=\"$RUNSHFLAGS -x\"\n    fi\nfi\n\nPOSIXLY_CORRECT=1\nif test x\"$TOOLDIR\" = x; then\n    TOOLDIR=`pwd`\nfi\nsrcdir=`dirname $0`\nif test x\"$srcdir\" = x || test x\"$srcdir\" = x.; then\n    srcdir=\"$TOOLDIR\"\nfi\nif test x\"$rsync_bin\" = x; then\n    rsync_bin=\"$TOOLDIR/rsync\"\nfi\n\n# This allows the user to specify extra rsync options -- use carefully!\nRSYNC=\"$rsync_bin $*\"\n#RSYNC=\"valgrind $rsync_bin $*\"\n\nTLS_ARGS=''\nif grep -E '^#define HAVE_LUTIMES 1' config.h >/dev/null; then\n    TLS_ARGS=\"$TLS_ARGS -l\"\nfi\nif grep -E '#undef CHOWN_MODIFIES_SYMLINK' config.h >/dev/null; then\n    TLS_ARGS=\"$TLS_ARGS -L\"\nfi\n\nexport POSIXLY_CORRECT TOOLDIR srcdir RSYNC TLS_ARGS\n\necho \"============================================================\"\necho \"$0 running in $TOOLDIR\"\necho \"    rsync_bin=$RSYNC\"\necho \"    srcdir=$srcdir\"\necho \"    TLS_ARGS=$TLS_ARGS\"\n\nif [ -f /usr/bin/whoami ]; then\n    testuser=`/usr/bin/whoami`\nelif [ -f /usr/ucb/whoami ]; then\n    testuser=`/usr/ucb/whoami`\nelif [ -f /bin/whoami ]; then\n    testuser=`/bin/whoami`\nelse\n    testuser=`id -un 2>/dev/null || echo ${LOGNAME:-${USERNAME:-${USER:-'UNKNOWN'}}}`\nfi\n\necho \"    testuser=$testuser\"\necho \"    os=`uname -a`\"\n\n# It must be \"yes\", not just nonnull\nif [ \"x$preserve_scratch\" = xyes ]; then\n    echo \"    preserve_scratch=yes\"\nelse\n    echo \"    preserve_scratch=no\"\nfi\n\n# Check if setacl/setfacl is around and if it supports the -k or -s option.\nif setacl -k u::7,g::5,o:5 testsuite 2>/dev/null; then\n    setfacl_nodef='setacl -k'\nelif setfacl --help 2>&1 | grep ' -k,\\|\\[-[a-z]*k' >/dev/null; then\n    setfacl_nodef='setfacl -k'\nelif setfacl -s u::7,g::5,o:5 testsuite 2>/dev/null; then\n    setfacl_nodef='setfacl -s u::7,g::5,o:5'\nelse\n    # The \"true\" command runs successfully, but does nothing.\n    setfacl_nodef=true\nfi\n\nexport setfacl_nodef\n\nif [ ! -f \"$rsync_bin\" ]; then\n    echo \"rsync_bin $rsync_bin is not a file\" >&2\n    exit 2\nfi\n\nif [ ! -d \"$srcdir\" ]; then\n    echo \"srcdir $srcdir is not a directory\" >&2\n    exit 2\nfi\n\nexpect_skipped=\"${RSYNC_EXPECT_SKIPPED-IGNORE}\"\nskipped_list=''\nskipped=0\nmissing=0\npassed=0\nfailed=0\n\n# Directory that holds the other test subdirs.  We create separate dirs\n# inside for each test case, so that they can be left behind in case of\n# failure to aid investigation.  We don't remove the testtmp subdir at\n# the end so that it can be configured as a symlink to a filesystem that\n# has ACLs and xattr support enabled (if desired).\nscratchbase=\"${scratchbase:-$TOOLDIR}\"/testtmp\necho \"    scratchbase=$scratchbase\"\n[ -d \"$scratchbase\" ] || mkdir \"$scratchbase\"\n\nsuitedir=\"$srcdir/testsuite\"\nTESTRUN_TIMEOUT=300\n\nexport scratchdir suitedir TESTRUN_TIMEOUT\n\nprep_scratch() {\n    [ -d \"$scratchdir\" ] && chmod -R u+rwX \"$scratchdir\" && rm -rf \"$scratchdir\"\n    mkdir \"$scratchdir\"\n    # Get rid of default ACLs and dir-setgid to avoid confusing some tests.\n    $setfacl_nodef \"$scratchdir\" 2>/dev/null || true\n    chmod g-s \"$scratchdir\"\n    case \"$srcdir\" in\n    /*) ln -s \"$srcdir\" \"$scratchdir/src\" ;;\n    *)  ln -s \"$TOOLDIR/$srcdir\" \"$scratchdir/src\" ;;\n    esac\n    return 0\n}\n\nmaybe_discard_scratch() {\n    [ x\"$preserve_scratch\" != xyes ] && [ -d \"$scratchdir\" ] && rm -rf \"$scratchdir\"\n    return 0\n}\n\nif [ \"x$whichtests\" = x ]; then\n    whichtests=\"*.test\"\n    full_run=yes\nelse\n    full_run=no\nfi\n\nfor testscript in $suitedir/$whichtests; do\n    testbase=`echo $testscript | sed -e 's!.*/!!' -e 's/.test\\$//'`\n    scratchdir=\"$scratchbase/$testbase\"\n\n    prep_scratch\n\n    case \"$testscript\" in\n    *hardlinks*) TESTRUN_TIMEOUT=600 ;;\n    *) TESTRUN_TIMEOUT=300 ;;\n    esac\n\n    set +e\n    \"$TOOLDIR/\"testrun $RUNSHFLAGS \"$testscript\" >\"$scratchdir/test.log\" 2>&1\n    result=$?\n    set -e\n\n    if [ \"x$always_log\" = xyes ] || ( [ $result != 0 ] && [ $result != 77 ] && [ $result != 78 ] )\n    then\n\techo \"----- $testbase log follows\"\n\tcat \"$scratchdir/test.log\"\n\techo \"----- $testbase log ends\"\n\tif [ -f \"$scratchdir/rsyncd.log\" ]; then\n\t    echo \"----- $testbase rsyncd.log follows\"\n\t    cat \"$scratchdir/rsyncd.log\"\n\t    echo \"----- $testbase rsyncd.log ends\"\n\tfi\n    fi\n\n    case $result in\n    0)\n\techo \"PASS    $testbase\"\n\tpassed=`expr $passed + 1`\n\tmaybe_discard_scratch\n\t;;\n    77)\n\t# backticks will fill the whole file onto one line, which is a feature\n\twhyskipped=`cat \"$scratchdir/whyskipped\"`\n\techo \"SKIP    $testbase ($whyskipped)\"\n\tskipped_list=\"$skipped_list,$testbase\"\n\tskipped=`expr $skipped + 1`\n\tmaybe_discard_scratch\n\t;;\n    78)\n        # It failed, but we expected that.  don't dump out error logs,\n\t# because most users won't want to see them.  But do leave\n\t# the working directory around.\n\techo \"XFAIL   $testbase\"\n\tfailed=`expr $failed + 1`\n\t;;\n    *)\n\techo \"FAIL    $testbase\"\n\tfailed=`expr $failed + 1`\n\tif [ \"x$nopersist\" = xyes ]; then\n\t    exit 1\n\tfi\n    esac\ndone\n\necho '------------------------------------------------------------'\necho \"----- overall results:\"\necho \"      $passed passed\"\n[ \"$failed\" -gt 0 ]  && echo \"      $failed failed\"\n[ \"$skipped\" -gt 0 ] && echo \"      $skipped skipped\"\n[ \"$missing\" -gt 0 ] && echo \"      $missing missing\"\nif [ \"$full_run\" = yes ] && [ \"$expect_skipped\" != IGNORE ]; then\n    skipped_list=`echo \"$skipped_list\" | sed 's/^,//'`\n    echo \"----- skipped results:\"\n    echo \"      expected: $expect_skipped\"\n    echo \"      got:      $skipped_list\"\nelse\n    skipped_list=''\n    expect_skipped=''\nfi\necho '------------------------------------------------------------'\n\n# OK, so expr exits with 0 if the result is neither null nor zero; and\n# 1 if the expression is null or zero.  This is the opposite of what\n# we want, and if we just call expr then this script will always fail,\n# because -e is set.\n\nresult=`expr $failed + $missing || true`\nif [ \"$result\" = 0 ] && [ \"$skipped_list\" != \"$expect_skipped\" ]; then\n    result=1\nfi\necho \"overall result is $result\"\nexit $result\n"
        },
        {
          "name": "sender.c",
          "type": "blob",
          "size": 11.896484375,
          "content": "/*\n * Routines only used by the sending process.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"inums.h\"\n\nextern int do_xfers;\nextern int am_server;\nextern int am_daemon;\nextern int local_server;\nextern int inc_recurse;\nextern int log_before_transfer;\nextern int stdout_format_has_i;\nextern int logfile_format_has_i;\nextern int want_xattr_optim;\nextern int xfer_sum_len;\nextern int csum_length;\nextern int append_mode;\nextern int copy_links;\nextern int io_error;\nextern int flist_eof;\nextern int whole_file;\nextern int allowed_lull;\nextern int copy_devices;\nextern int preserve_xattrs;\nextern int protocol_version;\nextern int remove_source_files;\nextern int updating_basis_file;\nextern int make_backups;\nextern int inplace;\nextern int inplace_partial;\nextern int batch_fd;\nextern int write_batch;\nextern int file_old_total;\nextern BOOL want_progress_now;\nextern struct stats stats;\nextern struct file_list *cur_flist, *first_flist, *dir_flist;\nextern char num_dev_ino_buf[4 + 8 + 8];\n\nBOOL extra_flist_sending_enabled;\n\n/**\n * @file\n *\n * The sender gets checksums from the generator, calculates deltas,\n * and transmits them to the receiver.  The sender process runs on the\n * machine holding the source files.\n **/\n\n/**\n * Receive the checksums for a buffer\n **/\nstatic struct sum_struct *receive_sums(int f)\n{\n\tstruct sum_struct *s = new(struct sum_struct);\n\tint lull_mod = protocol_version >= 31 ? 0 : allowed_lull * 5;\n\tOFF_T offset = 0;\n\tint32 i;\n\n\tread_sum_head(f, s);\n\n\ts->sums = NULL;\n\n\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\trprintf(FINFO, \"count=%s n=%ld rem=%ld\\n\",\n\t\t\tbig_num(s->count), (long)s->blength, (long)s->remainder);\n\t}\n\n\tif (append_mode > 0) {\n\t\ts->flength = (OFF_T)s->count * s->blength;\n\t\tif (s->remainder)\n\t\t\ts->flength -= s->blength - s->remainder;\n\t\treturn s;\n\t}\n\n\tif (s->count == 0)\n\t\treturn(s);\n\n\ts->sums = new_array(struct sum_buf, s->count);\n\ts->sum2_array = new_array(char, (size_t)s->count * xfer_sum_len);\n\n\tfor (i = 0; i < s->count; i++) {\n\t\ts->sums[i].sum1 = read_int(f);\n\t\tread_buf(f, sum2_at(s, i), s->s2length);\n\n\t\ts->sums[i].offset = offset;\n\t\ts->sums[i].flags = 0;\n\n\t\tif (i == s->count-1 && s->remainder != 0)\n\t\t\ts->sums[i].len = s->remainder;\n\t\telse\n\t\t\ts->sums[i].len = s->blength;\n\t\toffset += s->sums[i].len;\n\n\t\tif (lull_mod && !(i % lull_mod))\n\t\t\tmaybe_send_keepalive(time(NULL), True);\n\n\t\tif (DEBUG_GTE(DELTASUM, 3)) {\n\t\t\trprintf(FINFO,\n\t\t\t\t\"chunk[%d] len=%d offset=%s sum1=%08x\\n\",\n\t\t\t\ti, s->sums[i].len, big_num(s->sums[i].offset),\n\t\t\t\ts->sums[i].sum1);\n\t\t}\n\t}\n\n\ts->flength = offset;\n\n\treturn s;\n}\n\nvoid successful_send(int ndx)\n{\n\tchar fname[MAXPATHLEN];\n\tchar *failed_op;\n\tstruct file_struct *file;\n\tstruct file_list *flist;\n\tSTRUCT_STAT st;\n\n\tif (!remove_source_files)\n\t\treturn;\n\n\tflist = flist_for_ndx(ndx, \"successful_send\");\n\tfile = flist->files[ndx - flist->ndx_start];\n\tif (!change_pathname(file, NULL, 0))\n\t\treturn;\n\tf_name(file, fname);\n\n\tif ((copy_links ? do_stat(fname, &st) : do_lstat(fname, &st)) < 0) {\n\t\tfailed_op = \"re-lstat\";\n\t\tgoto failed;\n\t}\n\n\tif (local_server\n\t && (int64)st.st_dev == IVAL64(num_dev_ino_buf, 4)\n\t && (int64)st.st_ino == IVAL64(num_dev_ino_buf, 4 + 8)) {\n\t\trprintf(FERROR_XFER, \"ERROR: Skipping sender remove of destination file: %s\\n\", fname);\n\t\treturn;\n\t}\n\n\tif (st.st_size != F_LENGTH(file) || st.st_mtime != file->modtime\n#ifdef ST_MTIME_NSEC\n\t || (NSEC_BUMP(file) && (uint32)st.ST_MTIME_NSEC != F_MOD_NSEC(file))\n#endif\n\t) {\n\t\trprintf(FERROR_XFER, \"ERROR: Skipping sender remove for changed file: %s\\n\", fname);\n\t\treturn;\n\t}\n\n\tif (do_unlink(fname) < 0) {\n\t\tfailed_op = \"remove\";\n\t  failed:\n\t\tif (errno == ENOENT)\n\t\t\trprintf(FINFO, \"sender file already removed: %s\\n\", fname);\n\t\telse\n\t\t\trsyserr(FERROR_XFER, errno, \"sender failed to %s %s\", failed_op, fname);\n\t} else {\n\t\tif (INFO_GTE(REMOVE, 1))\n\t\t\trprintf(FINFO, \"sender removed %s\\n\", fname);\n\t}\n}\n\nstatic void write_ndx_and_attrs(int f_out, int ndx, int iflags,\n\t\t\t\tconst char *fname, struct file_struct *file,\n\t\t\t\tuchar fnamecmp_type, char *buf, int len)\n{\n\twrite_ndx(f_out, ndx);\n\tif (protocol_version < 29)\n\t\treturn;\n\twrite_shortint(f_out, iflags);\n\tif (iflags & ITEM_BASIS_TYPE_FOLLOWS)\n\t\twrite_byte(f_out, fnamecmp_type);\n\tif (iflags & ITEM_XNAME_FOLLOWS)\n\t\twrite_vstring(f_out, buf, len);\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\tsend_xattr_request(fname, file, f_out);\n#endif\n}\n\nvoid send_files(int f_in, int f_out)\n{\n\tint fd = -1;\n\tstruct sum_struct *s;\n\tstruct map_struct *mbuf = NULL;\n\tSTRUCT_STAT st;\n\tchar fname[MAXPATHLEN], xname[MAXPATHLEN];\n\tconst char *path, *slash;\n\tuchar fnamecmp_type;\n\tint iflags, xlen;\n\tstruct file_struct *file;\n\tint phase = 0, max_phase = protocol_version >= 29 ? 2 : 1;\n\tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;\n\tenum logcode log_code = log_before_transfer ? FLOG : FINFO;\n\tint f_xfer = write_batch < 0 ? batch_fd : f_out;\n\tint save_io_error = io_error;\n\tint ndx, j;\n\n\tif (DEBUG_GTE(SEND, 1))\n\t\trprintf(FINFO, \"send_files starting\\n\");\n\n\tif (whole_file < 0)\n\t\twhole_file = 0;\n\n\tprogress_init();\n\n\twhile (1) {\n\t\tif (inc_recurse) {\n\t\t\tsend_extra_file_list(f_out, MIN_FILECNT_LOOKAHEAD);\n\t\t\textra_flist_sending_enabled = !flist_eof;\n\t\t}\n\n\t\t/* This call also sets cur_flist. */\n\t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,\n\t\t\t\t\t xname, &xlen);\n\t\textra_flist_sending_enabled = False;\n\n\t\tif (ndx == NDX_DONE) {\n\t\t\tif (!am_server && cur_flist) {\n\t\t\t\tset_current_file_index(NULL, 0);\n\t\t\t\tif (INFO_GTE(PROGRESS, 2))\n\t\t\t\t\tend_progress(0);\n\t\t\t}\n\t\t\tif (inc_recurse && first_flist) {\n\t\t\t\tfile_old_total -= first_flist->used;\n\t\t\t\tflist_free(first_flist);\n\t\t\t\tif (first_flist) {\n\t\t\t\t\tif (first_flist == cur_flist)\n\t\t\t\t\t\tfile_old_total = cur_flist->used;\n\t\t\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++phase > max_phase)\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_GTE(SEND, 1))\n\t\t\t\trprintf(FINFO, \"send_files phase=%d\\n\", phase);\n\t\t\twrite_ndx(f_out, NDX_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (inc_recurse)\n\t\t\tsend_extra_file_list(f_out, MIN_FILECNT_LOOKAHEAD);\n\n\t\tif (ndx - cur_flist->ndx_start >= 0)\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\telse\n\t\t\tfile = dir_flist->files[cur_flist->parent_ndx];\n\t\tif (F_PATHNAME(file)) {\n\t\t\tpath = F_PATHNAME(file);\n\t\t\tslash = \"/\";\n\t\t} else {\n\t\t\tpath = slash = \"\";\n\t\t}\n\t\tif (!change_pathname(file, NULL, 0))\n\t\t\tcontinue;\n\t\tf_name(file, fname);\n\n\t\tif (DEBUG_GTE(SEND, 1))\n\t\t\trprintf(FINFO, \"send_files(%d, %s%s%s)\\n\", ndx, path,slash,fname);\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\t\trecv_xattr_request(file, f_in);\n#endif\n\n\t\tif (!(iflags & ITEM_TRANSFER)) {\n\t\t\tmaybe_log_item(file, iflags, itemizing, xname);\n\t\t\twrite_ndx_and_attrs(f_out, ndx, iflags, fname, file, fnamecmp_type, xname, xlen);\n\t\t\tif (iflags & ITEM_IS_NEW) {\n\t\t\t\tstats.created_files++;\n\t\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\t\t/* Nothing further to count. */\n\t\t\t\t} else if (S_ISDIR(file->mode))\n\t\t\t\t\tstats.created_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\t\telse if (S_ISLNK(file->mode))\n\t\t\t\t\tstats.created_symlinks++;\n#endif\n\t\t\t\telse if (IS_DEVICE(file->mode))\n\t\t\t\t\tstats.created_devices++;\n\t\t\t\telse\n\t\t\t\t\tstats.created_specials++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (phase == 2) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"got transfer request in phase 2 [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (file->flags & FLAG_FILE_SENT) {\n\t\t\tif (csum_length == SHORT_SUM_LENGTH) {\n\t\t\t\t/* For inplace: redo phase turns off the backup\n\t\t\t\t * flag so that we do a regular inplace send. */\n\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SUM_LENGTH;\n\t\t\t}\n\t\t} else {\n\t\t\tif (csum_length != SHORT_SUM_LENGTH) {\n\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\t}\n\t\t\tif (iflags & ITEM_IS_NEW)\n\t\t\t\tstats.created_files++;\n\t\t}\n\n\t\tupdating_basis_file = (inplace_partial && fnamecmp_type == FNAMECMP_PARTIAL_DIR)\n\t\t    || (inplace && (protocol_version >= 29 ? fnamecmp_type == FNAMECMP_FNAME : make_backups <= 0));\n\n\t\tif (!am_server)\n\t\t\tset_current_file_index(file, ndx);\n\t\tstats.xferred_files++;\n\t\tstats.total_transferred_size += F_LENGTH(file);\n\n\t\tremember_initial_stats();\n\n\t\tif (!do_xfers) { /* log the transfer */\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\twrite_ndx_and_attrs(f_out, ndx, iflags, fname, file, fnamecmp_type, xname, xlen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(s = receive_sums(f_in))) {\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trprintf(FERROR_XFER, \"receive_sums failed\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tfd = do_open(fname, O_RDONLY, 0);\n\t\tif (fd == -1) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tenum logcode c = am_daemon && protocol_version < 28 ? FERROR : FWARNING;\n\t\t\t\tio_error |= IOERR_VANISHED;\n\t\t\t\trprintf(c, \"file has vanished: %s\\n\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t} else {\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"send_files failed to open %s\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t}\n\t\t\tfree_sums(s);\n\t\t\tif (protocol_version >= 30)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* map the local file */\n\t\tif (do_fstat(fd, &st) != 0) {\n\t\t\tio_error |= IOERR_GENERAL;\n\t\t\trsyserr(FERROR_XFER, errno, \"fstat failed\");\n\t\t\tfree_sums(s);\n\t\t\tclose(fd);\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif (IS_DEVICE(st.st_mode)) {\n\t\t\tif (!copy_devices) {\n\t\t\t\trprintf(FERROR, \"attempt to copy device contents without --copy-devices\\n\");\n\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t}\n\t\t\tif (st.st_size == 0)\n\t\t\t\tst.st_size = get_device_size(fd, fname);\n\t\t}\n\n\t\tif (append_mode > 0 && st.st_size < F_LENGTH(file)) {\n\t\t\trprintf(FWARNING, \"skipped diminished file: %s\\n\",\n\t\t\t\tfull_fname(fname));\n\t\t\tfree_sums(s);\n\t\t\tclose(fd);\n\t\t\tif (protocol_version >= 30)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (st.st_size) {\n\t\t\tint32 read_size = MAX(s->blength * 3, MAX_MAP_SIZE);\n\t\t\tmbuf = map_file(fd, st.st_size, read_size, s->blength);\n\t\t} else\n\t\t\tmbuf = NULL;\n\n\t\tif (DEBUG_GTE(DELTASUM, 2)) {\n\t\t\trprintf(FINFO, \"send_files mapped %s%s%s of size %s\\n\",\n\t\t\t\tpath,slash,fname, big_num(st.st_size));\n\t\t}\n\n\t\twrite_ndx_and_attrs(f_out, ndx, iflags, fname, file, fnamecmp_type, xname, xlen);\n\t\twrite_sum_head(f_xfer, s);\n\n\t\tif (DEBUG_GTE(DELTASUM, 2))\n\t\t\trprintf(FINFO, \"calling match_sums %s%s%s\\n\", path,slash,fname);\n\n\t\tif (log_before_transfer)\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))\n\t\t\trprintf(FCLIENT, \"%s\\n\", fname);\n\n\t\tset_compression(fname);\n\n\t\tmatch_sums(f_xfer, s, mbuf, st.st_size);\n\t\tif (INFO_GTE(PROGRESS, 1))\n\t\t\tend_progress(st.st_size);\n\t\telse if (want_progress_now)\n\t\t\tinstant_progress(fname);\n\n\t\tlog_item(log_code, file, iflags, NULL);\n\n\t\tif (mbuf) {\n\t\t\tj = unmap_file(mbuf);\n\t\t\tif (j) {\n\t\t\t\tio_error |= IOERR_GENERAL;\n\t\t\t\trsyserr(FERROR_XFER, j,\n\t\t\t\t\t\"read errors mapping %s\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t}\n\t\t}\n\t\tclose(fd);\n\n\t\tfree_sums(s);\n\n\t\tif (DEBUG_GTE(SEND, 1))\n\t\t\trprintf(FINFO, \"sender finished %s%s%s\\n\", path,slash,fname);\n\n\t\t/* Flag that we actually sent this entry. */\n\t\tfile->flags |= FLAG_FILE_SENT;\n\t}\n\tif (make_backups < 0)\n\t\tmake_backups = -make_backups;\n\n\tif (io_error != save_io_error && protocol_version >= 30)\n\t\tsend_msg_int(MSG_IO_ERROR, io_error);\n\n\tif (DEBUG_GTE(SEND, 1))\n\t\trprintf(FINFO, \"send files finished\\n\");\n\n\tmatch_report();\n\n\twrite_ndx(f_out, NDX_DONE);\n}\n"
        },
        {
          "name": "shconfig.in",
          "type": "blob",
          "size": 0.3515625,
          "content": "#! /bin/sh\n\n# config.sh.in \n\n# This file is processed by config.status to produce config.status,\n# containing autoconf-determined values needed by the test scripts.\n\nECHO_T=\"@ECHO_T@\"\nECHO_N=\"@ECHO_N@\"\nECHO_C=\"@ECHO_C@\"\nHOST_OS=\"@host_os@\"\nSHELL_PATH=\"@SHELL_PATH@\"\nFAKEROOT_PATH=\"@FAKEROOT_PATH@\"\n\nexport ECHO_T ECHO_N ECHO_C HOST_OS SHELL_PATH FAKEROOT_PATH\n"
        },
        {
          "name": "simd-checksum-avx2.S",
          "type": "blob",
          "size": 3.26171875,
          "content": "#include \"config.h\"\n\n#ifdef USE_ROLL_ASM /* { */\n\n#define CHAR_OFFSET 0 /* Keep this the same as rsync.h, which isn't likely to change. */\n\n#ifdef __APPLE__\n#define get_checksum1_avx2_asm  _get_checksum1_avx2_asm\n#endif\n\n.intel_syntax noprefix\n.text\n\n\t.p2align 5\n\t.globl get_checksum1_avx2_asm\n\n# rdi=*buf, esi=len, edx=i, rcx= *ps1, r8= *ps2\nget_checksum1_avx2_asm:\n\tvmovd\txmm6,[rcx] # load *ps1\n\tlea\teax, [rsi-128] # at least 128 bytes to process?\n\tcmp\tedx, eax\n\tjg\t.exit\n\tlea\trax, .mul_T2[rip]\n\tvmovntdqa ymm7, [rax]   # load T2 multiplication constants\n\tvmovntdqa ymm12,[rax+32]# from memory.\n\tvpcmpeqd  ymm15, ymm15, ymm15 # set all elements to -1.\n\n#if CHAR_OFFSET != 0\n\tmov\teax, 32*CHAR_OFFSET\n\tvmovd\txmm10, eax\n\tvpbroadcastd\tymm10, xmm10\n\tmov\teax, 528*CHAR_OFFSET\n\tvmovd\txmm13, eax\n\tvpbroadcastd ymm13, xmm13\n#endif\n\tvpabsb\tymm15, ymm15  # set all byte size elements to 1.\n\tadd\trdi, rdx\n\tvmovdqu ymm2, [rdi]   # preload the first 64 bytes.\n\tvmovdqu ymm3, [rdi+32]\n\tand\tesi, ~63   # only needed during final reduction, \n\t\t\t   # done here to avoid a longer nop for \n\t\t\t   # alignment below.\n\tadd\tedx, esi\n\tshr\trsi, 6\t   # longer opcode for alignment\n\tadd\trdi, 64\n\tvpxor\txmm1, xmm1, xmm1 # reset both partial sums accumulators.\n\tvpxor\txmm4, xmm4, xmm4\n\tmov\teax, [r8]\n\t.p2align 4 \t\t# should fit into the LSD allocation queue.\n.loop:\n\tvpmaddubsw\tymm0, ymm15, ymm2  # s1 partial sums\n\tvpmaddubsw\tymm5, ymm15, ymm3 \n\tvmovdqu\tymm8,  [rdi]\t# preload the next \n\tvmovdqu\tymm9,  [rdi+32] # 64 bytes.\n\tadd\trdi, 64\n\tvpaddd\tymm4, ymm4, ymm6\n\tvpaddw\tymm5, ymm5, ymm0\n\tvpsrld\tymm0, ymm5, 16\n\tvpaddw\tymm5, ymm0, ymm5\n\tvpaddd\tymm6, ymm5, ymm6\n\tvpmaddubsw\tymm2, ymm7, ymm2  # s2 partial sums\n\tvpmaddubsw\tymm3, ymm12, ymm3\n\tprefetcht0\t[rdi+384] # prefetch 6 cachelines ahead.\n\tvpaddw\tymm3, ymm2, ymm3\n\tvpsrldq\tymm2, ymm3, 2\n\tvpaddd\tymm3, ymm2, ymm3\n\tvpaddd\tymm1, ymm1, ymm3\n\n#if CHAR_OFFSET != 0\n\tvpaddd ymm6, ymm10, ymm6  #  32*CHAR_OFFSET\n\tvpaddd ymm1, ymm13, ymm1  # 528*CHAR_OFFSET\n#endif\n\tvmovdqa ymm2, ymm8   # move the next 64 bytes \n\tvmovdqa ymm3, ymm9   # into the right registers\n\tsub\tesi, 1\n\tjnz\t.loop\n\n\t# now we reduce the partial sums.\n\tvpslld\tymm3, ymm4, 6\n\tvpsrldq\tymm2, ymm6, 4\n\t\n\tvpaddd  ymm0, ymm3, ymm1\n\tvpaddd\tymm6, ymm2, ymm6\n\tvpsrlq\tymm3, ymm0, 32\n\t\n\tvpsrldq\tymm2, ymm6, 8\n\tvpaddd\tymm0, ymm3, ymm0\n\tvpsrldq\tymm3, ymm0, 8\n\tvpaddd\tymm6, ymm2, ymm6\n\tvpaddd\tymm0, ymm3, ymm0\n\tvextracti128\txmm2, ymm6, 0x1\n\tvextracti128\txmm1, ymm0, 0x1\n\tvpaddd\txmm6, xmm2, xmm6\n\tvmovd\t[rcx], xmm6\n\tvpaddd\txmm1, xmm1, xmm0\n\tvmovd\tecx, xmm1\n\tadd\teax, ecx\n\tmov\t[r8], eax\n.exit:\n\tvzeroupper\n\tmov\teax, edx\n\tret\n\n#ifdef __APPLE__\n.data\n\t.align 6\n#else\n.section\t.rodata\n\t.p2align 6 \n#endif\n.mul_T2: \n\t.byte 64\n\t.byte 63\n\t.byte 62\n\t.byte 61\n\t.byte 60\n\t.byte 59\n\t.byte 58\n\t.byte 57\n\t.byte 56\n\t.byte 55\n\t.byte 54\n\t.byte 53\n\t.byte 52\n\t.byte 51\n\t.byte 50\n\t.byte 49\n\t.byte 48\n\t.byte 47\n\t.byte 46\n\t.byte 45\n\t.byte 44\n\t.byte 43\n\t.byte 42\n\t.byte 41\n\t.byte 40\n\t.byte 39\n\t.byte 38\n\t.byte 37\n\t.byte 36\n\t.byte 35\n\t.byte 34\n\t.byte 33\n\t.byte 32\n\t.byte 31\n\t.byte 30\n\t.byte 29\n\t.byte 28\n\t.byte 27\n\t.byte 26\n\t.byte 25\n\t.byte 24\n\t.byte 23\n\t.byte 22\n\t.byte 21\n\t.byte 20\n\t.byte 19\n\t.byte 18\n\t.byte 17\n\t.byte 16\n\t.byte 15\n\t.byte 14\n\t.byte 13\n\t.byte 12\n\t.byte 11\n\t.byte 10\n\t.byte 9\n\t.byte 8\n\t.byte 7\n\t.byte 6\n\t.byte 5\n\t.byte 4\n\t.byte 3\n\t.byte 2\n\t.byte 1\n\n#endif /* } USE_ROLL_ASM */\n"
        },
        {
          "name": "simd-checksum-x86_64.cpp",
          "type": "blob",
          "size": 23.8642578125,
          "content": "/*\n * SSE2/SSSE3/AVX2-optimized routines to support checksumming of bytes.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2004-2020 Wayne Davison\n * Copyright (C) 2020 Jorrit Jongma\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n/*\n * Optimization target for get_checksum1() was the Intel Atom D2700, the\n * slowest CPU in the test set and the most likely to be CPU limited during\n * transfers. The combination of intrinsics was chosen specifically for the\n * most gain on that CPU, other combinations were occasionally slightly\n * faster on the others.\n *\n * While on more modern CPUs transfers are less likely to be CPU limited\n * (at least by this specific function), lower CPU usage is always better.\n * Improvements may still be seen when matching chunks from NVMe storage\n * even on newer CPUs.\n *\n * Benchmarks (in MB/s)            C    SSE2   SSSE3    AVX2\n * - Intel Atom D2700            550     750    1000     N/A\n * - Intel i7-7700hq            1850    2550    4050    6200\n * - AMD ThreadRipper 2950x     2900    5600    8950    8100\n *\n * Curiously the AMD is slower with AVX2 than SSSE3, while the Intel is\n * significantly faster. AVX2 is kept because it's more likely to relieve\n * the bottleneck on the slower CPU.\n *\n * This optimization for get_checksum1() is intentionally limited to x86-64\n * as no 32-bit CPU was available for testing. As 32-bit CPUs only have half\n * the available xmm registers, this optimized version may not be faster than\n * the pure C version anyway. Note that all x86-64 CPUs support at least SSE2.\n *\n * This file is compiled using GCC 4.8+/clang 6+'s C++ front end to allow the\n * use of the target attribute, selecting the fastest code path based on\n * dispatch priority (GCC 5) or runtime detection of CPU capabilities (GCC 6+).\n * GCC 4.x are not supported to ease configure.ac logic.\n */\n\n#ifdef __x86_64__ /* { */\n#ifdef __cplusplus /* { */\n\n#include \"rsync.h\"\n\n#ifdef USE_ROLL_SIMD /* { */\n\n#include <immintrin.h>\n\n/* Some clang versions don't like it when you use static with multi-versioned functions: linker errors */\n#ifdef __clang__\n#define MVSTATIC\n#else\n#define MVSTATIC static\n#endif\n\n// Missing from the headers on gcc 6 and older, clang 8 and older\ntypedef long long __m128i_u __attribute__((__vector_size__(16), __may_alias__, __aligned__(16)));\ntypedef long long __m256i_u __attribute__((__vector_size__(32), __may_alias__, __aligned__(16)));\n\n/* Compatibility macros to let our SSSE3 algorithm run with only SSE2.\n   These used to be neat individual functions with target attributes switching between SSE2 and SSSE3 implementations\n   as needed, but though this works perfectly with GCC, clang fails to inline those properly leading to a near 50%\n   performance drop - combined with static and inline modifiers gets you linker errors and even compiler crashes...\n*/\n\n#define SSE2_INTERLEAVE_ODD_EPI16(a, b) _mm_packs_epi32(_mm_srai_epi32(a, 16), _mm_srai_epi32(b, 16))\n#define SSE2_INTERLEAVE_EVEN_EPI16(a, b) SSE2_INTERLEAVE_ODD_EPI16(_mm_slli_si128(a, 2), _mm_slli_si128(b, 2))\n#define SSE2_MULU_ODD_EPI8(a, b) _mm_mullo_epi16(_mm_srli_epi16(a, 8), _mm_srai_epi16(b, 8))\n#define SSE2_MULU_EVEN_EPI8(a, b) _mm_mullo_epi16(_mm_and_si128(a, _mm_set1_epi16(0xFF)), _mm_srai_epi16(_mm_slli_si128(b, 1), 8))\n\n#define SSE2_HADDS_EPI16(a, b) _mm_adds_epi16(SSE2_INTERLEAVE_EVEN_EPI16(a, b), SSE2_INTERLEAVE_ODD_EPI16(a, b))\n#define SSE2_MADDUBS_EPI16(a, b) _mm_adds_epi16(SSE2_MULU_EVEN_EPI8(a, b), SSE2_MULU_ODD_EPI8(a, b))\n\n#ifndef USE_ROLL_ASM\n__attribute__ ((target(\"default\"))) MVSTATIC int32 get_checksum1_avx2_64(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2) { return i; }\n#endif\n__attribute__ ((target(\"default\"))) MVSTATIC int32 get_checksum1_ssse3_32(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2) { return i; }\n__attribute__ ((target(\"default\"))) MVSTATIC int32 get_checksum1_sse2_32(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2) { return i; }\n\n/*\n  Original loop per 4 bytes:\n    s2 += 4*(s1 + buf[i]) + 3*buf[i+1] + 2*buf[i+2] + buf[i+3] + 10*CHAR_OFFSET;\n    s1 += buf[i] + buf[i+1] + buf[i+2] + buf[i+3] + 4*CHAR_OFFSET;\n\n  SSE2/SSSE3 loop per 32 bytes:\n    int16 t1[8];\n    int16 t2[8];\n    for (int j = 0; j < 8; j++) {\n      t1[j] = buf[j*4 + i] + buf[j*4 + i+1] + buf[j*4 + i+2] + buf[j*4 + i+3];\n      t2[j] = 4*buf[j*4 + i] + 3*buf[j*4 + i+1] + 2*buf[j*4 + i+2] + buf[j*4 + i+3];\n    }\n    s2 += 32*s1 + (uint32)(\n              28*t1[0] + 24*t1[1] + 20*t1[2] + 16*t1[3] + 12*t1[4] + 8*t1[5] + 4*t1[6] +\n              t2[0] + t2[1] + t2[2] + t2[3] + t2[4] + t2[5] + t2[6] + t2[7]\n          ) + 528*CHAR_OFFSET;\n    s1 += (uint32)(t1[0] + t1[1] + t1[2] + t1[3] + t1[4] + t1[5] + t1[6] + t1[7]) +\n          32*CHAR_OFFSET;\n */\n__attribute__ ((target(\"ssse3\"))) MVSTATIC int32 get_checksum1_ssse3_32(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2)\n{\n    if (len > 32) {\n        int aligned = ((uintptr_t)buf & 15) == 0;\n\n        uint32 x[4] = {0};\n        x[0] = *ps1;\n        __m128i ss1 = _mm_loadu_si128((__m128i_u*)x);\n        x[0] = *ps2;\n        __m128i ss2 = _mm_loadu_si128((__m128i_u*)x);\n\n        const int16 mul_t1_buf[8] = {28, 24, 20, 16, 12, 8, 4, 0};\n        __m128i mul_t1 = _mm_loadu_si128((__m128i_u*)mul_t1_buf);\n\n        for (; i < (len-32); i+=32) {\n            // Load ... 2*[int8*16]\n            __m128i in8_1, in8_2;\n            if (!aligned) {\n                // Synonymous with _mm_loadu_si128 on all but a handful of old CPUs\n                in8_1 = _mm_lddqu_si128((__m128i_u*)&buf[i]);\n                in8_2 = _mm_lddqu_si128((__m128i_u*)&buf[i + 16]);\n            } else {\n                in8_1 = _mm_load_si128((__m128i_u*)&buf[i]);\n                in8_2 = _mm_load_si128((__m128i_u*)&buf[i + 16]);\n            }\n\n            // (1*buf[i] + 1*buf[i+1]), (1*buf[i+2], 1*buf[i+3]), ... 2*[int16*8]\n            // Fastest, even though multiply by 1\n            __m128i mul_one = _mm_set1_epi8(1);\n            __m128i add16_1 = _mm_maddubs_epi16(mul_one, in8_1);\n            __m128i add16_2 = _mm_maddubs_epi16(mul_one, in8_2);\n\n            // (4*buf[i] + 3*buf[i+1]), (2*buf[i+2], buf[i+3]), ... 2*[int16*8]\n            __m128i mul_const = _mm_set1_epi32(4 + (3 << 8) + (2 << 16) + (1 << 24));\n            __m128i mul_add16_1 = _mm_maddubs_epi16(mul_const, in8_1);\n            __m128i mul_add16_2 = _mm_maddubs_epi16(mul_const, in8_2);\n\n            // s2 += 32*s1\n            ss2 = _mm_add_epi32(ss2, _mm_slli_epi32(ss1, 5));\n\n            // [sum(t1[0]..t1[7]), X, X, X] [int32*4]; faster than multiple _mm_hadds_epi16\n            // Shifting left, then shifting right again and shuffling (rather than just\n            // shifting right as with mul32 below) to cheaply end up with the correct sign\n            // extension as we go from int16 to int32.\n            __m128i sum_add32 = _mm_add_epi16(add16_1, add16_2);\n            sum_add32 = _mm_add_epi16(sum_add32, _mm_slli_si128(sum_add32, 2));\n            sum_add32 = _mm_add_epi16(sum_add32, _mm_slli_si128(sum_add32, 4));\n            sum_add32 = _mm_add_epi16(sum_add32, _mm_slli_si128(sum_add32, 8));\n            sum_add32 = _mm_srai_epi32(sum_add32, 16);\n            sum_add32 = _mm_shuffle_epi32(sum_add32, 3);\n\n            // [sum(t2[0]..t2[7]), X, X, X] [int32*4]; faster than multiple _mm_hadds_epi16\n            __m128i sum_mul_add32 = _mm_add_epi16(mul_add16_1, mul_add16_2);\n            sum_mul_add32 = _mm_add_epi16(sum_mul_add32, _mm_slli_si128(sum_mul_add32, 2));\n            sum_mul_add32 = _mm_add_epi16(sum_mul_add32, _mm_slli_si128(sum_mul_add32, 4));\n            sum_mul_add32 = _mm_add_epi16(sum_mul_add32, _mm_slli_si128(sum_mul_add32, 8));\n            sum_mul_add32 = _mm_srai_epi32(sum_mul_add32, 16);\n            sum_mul_add32 = _mm_shuffle_epi32(sum_mul_add32, 3);\n\n            // s1 += t1[0] + t1[1] + t1[2] + t1[3] + t1[4] + t1[5] + t1[6] + t1[7]\n            ss1 = _mm_add_epi32(ss1, sum_add32);\n\n            // s2 += t2[0] + t2[1] + t2[2] + t2[3] + t2[4] + t2[5] + t2[6] + t2[7]\n            ss2 = _mm_add_epi32(ss2, sum_mul_add32);\n\n            // [t1[0] + t1[1], t1[2] + t1[3] ...] [int16*8]\n            // We could've combined this with generating sum_add32 above and\n            // save an instruction but benchmarking shows that as being slower\n            __m128i add16 = _mm_hadds_epi16(add16_1, add16_2);\n\n            // [t1[0], t1[1], ...] -> [t1[0]*28 + t1[1]*24, ...] [int32*4]\n            __m128i mul32 = _mm_madd_epi16(add16, mul_t1);\n\n            // [sum(mul32), X, X, X] [int32*4]; faster than multiple _mm_hadd_epi32\n            mul32 = _mm_add_epi32(mul32, _mm_srli_si128(mul32, 4));\n            mul32 = _mm_add_epi32(mul32, _mm_srli_si128(mul32, 8));\n\n            // s2 += 28*t1[0] + 24*t1[1] + 20*t1[2] + 16*t1[3] + 12*t1[4] + 8*t1[5] + 4*t1[6]\n            ss2 = _mm_add_epi32(ss2, mul32);\n\n#if CHAR_OFFSET != 0\n            // s1 += 32*CHAR_OFFSET\n            __m128i char_offset_multiplier = _mm_set1_epi32(32 * CHAR_OFFSET);\n            ss1 = _mm_add_epi32(ss1, char_offset_multiplier);\n\n            // s2 += 528*CHAR_OFFSET\n            char_offset_multiplier = _mm_set1_epi32(528 * CHAR_OFFSET);\n            ss2 = _mm_add_epi32(ss2, char_offset_multiplier);\n#endif\n        }\n\n        _mm_store_si128((__m128i_u*)x, ss1);\n        *ps1 = x[0];\n        _mm_store_si128((__m128i_u*)x, ss2);\n        *ps2 = x[0];\n    }\n    return i;\n}\n\n/*\n  Same as SSSE3 version, but using macros defined above to emulate SSSE3 calls that are not available with SSE2.\n  For GCC-only the SSE2 and SSSE3 versions could be a single function calling other functions with the right\n  target attributes to emulate SSSE3 calls on SSE2 if needed, but clang doesn't inline those properly leading\n  to a near 50% performance drop.\n */\n__attribute__ ((target(\"sse2\"))) MVSTATIC int32 get_checksum1_sse2_32(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2)\n{\n    if (len > 32) {\n        int aligned = ((uintptr_t)buf & 15) == 0;\n\n        uint32 x[4] = {0};\n        x[0] = *ps1;\n        __m128i ss1 = _mm_loadu_si128((__m128i_u*)x);\n        x[0] = *ps2;\n        __m128i ss2 = _mm_loadu_si128((__m128i_u*)x);\n\n        const int16 mul_t1_buf[8] = {28, 24, 20, 16, 12, 8, 4, 0};\n        __m128i mul_t1 = _mm_loadu_si128((__m128i_u*)mul_t1_buf);\n\n        for (; i < (len-32); i+=32) {\n            // Load ... 2*[int8*16]\n            __m128i in8_1, in8_2;\n            if (!aligned) {\n                in8_1 = _mm_loadu_si128((__m128i_u*)&buf[i]);\n                in8_2 = _mm_loadu_si128((__m128i_u*)&buf[i + 16]);\n            } else {\n                in8_1 = _mm_load_si128((__m128i_u*)&buf[i]);\n                in8_2 = _mm_load_si128((__m128i_u*)&buf[i + 16]);\n            }\n\n            // (1*buf[i] + 1*buf[i+1]), (1*buf[i+2], 1*buf[i+3]), ... 2*[int16*8]\n            // Fastest, even though multiply by 1\n            __m128i mul_one = _mm_set1_epi8(1);\n            __m128i add16_1 = SSE2_MADDUBS_EPI16(mul_one, in8_1);\n            __m128i add16_2 = SSE2_MADDUBS_EPI16(mul_one, in8_2);\n\n            // (4*buf[i] + 3*buf[i+1]), (2*buf[i+2], buf[i+3]), ... 2*[int16*8]\n            __m128i mul_const = _mm_set1_epi32(4 + (3 << 8) + (2 << 16) + (1 << 24));\n            __m128i mul_add16_1 = SSE2_MADDUBS_EPI16(mul_const, in8_1);\n            __m128i mul_add16_2 = SSE2_MADDUBS_EPI16(mul_const, in8_2);\n\n            // s2 += 32*s1\n            ss2 = _mm_add_epi32(ss2, _mm_slli_epi32(ss1, 5));\n\n            // [sum(t1[0]..t1[7]), X, X, X] [int32*4]; faster than multiple _mm_hadds_epi16\n            // Shifting left, then shifting right again and shuffling (rather than just\n            // shifting right as with mul32 below) to cheaply end up with the correct sign\n            // extension as we go from int16 to int32.\n            __m128i sum_add32 = _mm_add_epi16(add16_1, add16_2);\n            sum_add32 = _mm_add_epi16(sum_add32, _mm_slli_si128(sum_add32, 2));\n            sum_add32 = _mm_add_epi16(sum_add32, _mm_slli_si128(sum_add32, 4));\n            sum_add32 = _mm_add_epi16(sum_add32, _mm_slli_si128(sum_add32, 8));\n            sum_add32 = _mm_srai_epi32(sum_add32, 16);\n            sum_add32 = _mm_shuffle_epi32(sum_add32, 3);\n\n            // [sum(t2[0]..t2[7]), X, X, X] [int32*4]; faster than multiple _mm_hadds_epi16\n            __m128i sum_mul_add32 = _mm_add_epi16(mul_add16_1, mul_add16_2);\n            sum_mul_add32 = _mm_add_epi16(sum_mul_add32, _mm_slli_si128(sum_mul_add32, 2));\n            sum_mul_add32 = _mm_add_epi16(sum_mul_add32, _mm_slli_si128(sum_mul_add32, 4));\n            sum_mul_add32 = _mm_add_epi16(sum_mul_add32, _mm_slli_si128(sum_mul_add32, 8));\n            sum_mul_add32 = _mm_srai_epi32(sum_mul_add32, 16);\n            sum_mul_add32 = _mm_shuffle_epi32(sum_mul_add32, 3);\n\n            // s1 += t1[0] + t1[1] + t1[2] + t1[3] + t1[4] + t1[5] + t1[6] + t1[7]\n            ss1 = _mm_add_epi32(ss1, sum_add32);\n\n            // s2 += t2[0] + t2[1] + t2[2] + t2[3] + t2[4] + t2[5] + t2[6] + t2[7]\n            ss2 = _mm_add_epi32(ss2, sum_mul_add32);\n\n            // [t1[0] + t1[1], t1[2] + t1[3] ...] [int16*8]\n            // We could've combined this with generating sum_add32 above and\n            // save an instruction but benchmarking shows that as being slower\n            __m128i add16 = SSE2_HADDS_EPI16(add16_1, add16_2);\n\n            // [t1[0], t1[1], ...] -> [t1[0]*28 + t1[1]*24, ...] [int32*4]\n            __m128i mul32 = _mm_madd_epi16(add16, mul_t1);\n\n            // [sum(mul32), X, X, X] [int32*4]; faster than multiple _mm_hadd_epi32\n            mul32 = _mm_add_epi32(mul32, _mm_srli_si128(mul32, 4));\n            mul32 = _mm_add_epi32(mul32, _mm_srli_si128(mul32, 8));\n\n            // s2 += 28*t1[0] + 24*t1[1] + 20*t1[2] + 16*t1[3] + 12*t1[4] + 8*t1[5] + 4*t1[6]\n            ss2 = _mm_add_epi32(ss2, mul32);\n\n#if CHAR_OFFSET != 0\n            // s1 += 32*CHAR_OFFSET\n            __m128i char_offset_multiplier = _mm_set1_epi32(32 * CHAR_OFFSET);\n            ss1 = _mm_add_epi32(ss1, char_offset_multiplier);\n\n            // s2 += 528*CHAR_OFFSET\n            char_offset_multiplier = _mm_set1_epi32(528 * CHAR_OFFSET);\n            ss2 = _mm_add_epi32(ss2, char_offset_multiplier);\n#endif\n        }\n\n        _mm_store_si128((__m128i_u*)x, ss1);\n        *ps1 = x[0];\n        _mm_store_si128((__m128i_u*)x, ss2);\n        *ps2 = x[0];\n    }\n    return i;\n}\n\n#ifdef USE_ROLL_ASM /* { */\n\nextern \"C\" __attribute__ ((target(\"avx2\"))) int32 get_checksum1_avx2_asm(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2);\n\n#else /* } { */\n\n/*\n  AVX2 loop per 64 bytes:\n    int16 t1[16];\n    int16 t2[16];\n    for (int j = 0; j < 16; j++) {\n      t1[j] = buf[j*4 + i] + buf[j*4 + i+1] + buf[j*4 + i+2] + buf[j*4 + i+3];\n      t2[j] = 4*buf[j*4 + i] + 3*buf[j*4 + i+1] + 2*buf[j*4 + i+2] + buf[j*4 + i+3];\n    }\n    s2 += 64*s1 + (uint32)(\n              60*t1[0] + 56*t1[1] + 52*t1[2] + 48*t1[3] + 44*t1[4] + 40*t1[5] + 36*t1[6] + 32*t1[7] + 28*t1[8] + 24*t1[9] + 20*t1[10] + 16*t1[11] + 12*t1[12] + 8*t1[13] + 4*t1[14] +\n              t2[0] + t2[1] + t2[2] + t2[3] + t2[4] + t2[5] + t2[6] + t2[7] + t2[8] + t2[9] + t2[10] + t2[11] + t2[12] + t2[13] + t2[14] + t2[15]\n          ) + 2080*CHAR_OFFSET;\n    s1 += (uint32)(t1[0] + t1[1] + t1[2] + t1[3] + t1[4] + t1[5] + t1[6] + t1[7] + t1[8] + t1[9] + t1[10] + t1[11] + t1[12] + t1[13] + t1[14] + t1[15]) +\n          64*CHAR_OFFSET;\n */\n\n__attribute__ ((target(\"avx2\"))) MVSTATIC int32 get_checksum1_avx2_64(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2)\n{\n    if (len > 64) {\n\n        uint32 x[4] = {0};\n        __m128i ss1 = _mm_cvtsi32_si128(*ps1);\n        __m128i ss2 = _mm_cvtsi32_si128(*ps2);\n\n        const char mul_t1_buf[16] = {60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0};\n\t__m128i tmp = _mm_load_si128((__m128i*) mul_t1_buf);\n        __m256i mul_t1 = _mm256_cvtepu8_epi16(tmp);\n\t__m256i mul_const = _mm256_broadcastd_epi32(_mm_cvtsi32_si128(4 | (3 << 8) | (2 << 16) | (1 << 24)));\n        __m256i mul_one;\n       \t    mul_one = _mm256_abs_epi8(_mm256_cmpeq_epi16(mul_one,mul_one)); // set all vector elements to 1\n\n        for (; i < (len-64); i+=64) {\n            // Load ... 4*[int8*16]\n            __m256i in8_1, in8_2;\n\t    __m128i in8_1_low, in8_2_low, in8_1_high, in8_2_high;\n\t    in8_1_low = _mm_loadu_si128((__m128i_u*)&buf[i]);\n\t    in8_2_low = _mm_loadu_si128((__m128i_u*)&buf[i+16]);\n\t    in8_1_high = _mm_loadu_si128((__m128i_u*)&buf[i+32]);\n\t    in8_2_high = _mm_loadu_si128((__m128i_u*)&buf[i+48]);\n\t    in8_1 = _mm256_inserti128_si256(_mm256_castsi128_si256(in8_1_low), in8_1_high,1);\n\t    in8_2 = _mm256_inserti128_si256(_mm256_castsi128_si256(in8_2_low), in8_2_high,1);\n\n            // (1*buf[i] + 1*buf[i+1]), (1*buf[i+2], 1*buf[i+3]), ... 2*[int16*8]\n            // Fastest, even though multiply by 1\n            __m256i add16_1 = _mm256_maddubs_epi16(mul_one, in8_1);\n            __m256i add16_2 = _mm256_maddubs_epi16(mul_one, in8_2);\n\n            // (4*buf[i] + 3*buf[i+1]), (2*buf[i+2], buf[i+3]), ... 2*[int16*8]\n            __m256i mul_add16_1 = _mm256_maddubs_epi16(mul_const, in8_1);\n            __m256i mul_add16_2 = _mm256_maddubs_epi16(mul_const, in8_2);\n\n            // s2 += 64*s1\n            ss2 = _mm_add_epi32(ss2, _mm_slli_epi32(ss1, 6));\n\n            // [sum(t1[0]..t1[7]), X, X, X] [int32*4]; faster than multiple _mm_hadds_epi16\n            __m256i sum_add32 = _mm256_add_epi16(add16_1, add16_2);\n            sum_add32 = _mm256_add_epi16(sum_add32, _mm256_srli_epi32(sum_add32, 16));\n            sum_add32 = _mm256_add_epi16(sum_add32, _mm256_srli_si256(sum_add32, 4));\n            sum_add32 = _mm256_add_epi16(sum_add32, _mm256_srli_si256(sum_add32, 8));\n\n            // [sum(t2[0]..t2[7]), X, X, X] [int32*4]; faster than multiple _mm_hadds_epi16\n            __m256i sum_mul_add32 = _mm256_add_epi16(mul_add16_1, mul_add16_2);\n            sum_mul_add32 = _mm256_add_epi16(sum_mul_add32, _mm256_srli_epi32(sum_mul_add32, 16));\n            sum_mul_add32 = _mm256_add_epi16(sum_mul_add32, _mm256_srli_si256(sum_mul_add32, 4));\n            sum_mul_add32 = _mm256_add_epi16(sum_mul_add32, _mm256_srli_si256(sum_mul_add32, 8));\n\n            // s1 += t1[0] + t1[1] + t1[2] + t1[3] + t1[4] + t1[5] + t1[6] + t1[7]\n\t    __m128i sum_add32_hi = _mm256_extracti128_si256(sum_add32, 0x1);\n            ss1 = _mm_add_epi32(ss1, _mm256_castsi256_si128(sum_add32));\n            ss1 = _mm_add_epi32(ss1, sum_add32_hi);\n\n            // s2 += t2[0] + t2[1] + t2[2] + t2[3] + t2[4] + t2[5] + t2[6] + t2[7]\n\t    __m128i sum_mul_add32_hi = _mm256_extracti128_si256(sum_mul_add32, 0x1);\n            ss2 = _mm_add_epi32(ss2, _mm256_castsi256_si128(sum_mul_add32));\n            ss2 = _mm_add_epi32(ss2, sum_mul_add32_hi);\n\n            // [t1[0] + t1[1], t1[2] + t1[3] ...] [int16*8]\n            // We could've combined this with generating sum_add32 above and\n            // save an instruction but benchmarking shows that as being slower\n            __m256i add16 = _mm256_hadds_epi16(add16_1, add16_2);\n\n            // [t1[0], t1[1], ...] -> [t1[0]*28 + t1[1]*24, ...] [int32*4]\n            __m256i mul32 = _mm256_madd_epi16(add16, mul_t1);\n\n            // [sum(mul32), X, X, X] [int32*4]; faster than multiple _mm_hadd_epi32\n            mul32 = _mm256_add_epi32(mul32, _mm256_srli_si256(mul32, 4));\n            mul32 = _mm256_add_epi32(mul32, _mm256_srli_si256(mul32, 8));\n\t    // prefetch 2 cacheline ahead\n            _mm_prefetch(&buf[i + 160], _MM_HINT_T0);\n\n            // s2 += 28*t1[0] + 24*t1[1] + 20*t1[2] + 16*t1[3] + 12*t1[4] + 8*t1[5] + 4*t1[6]\n\t    __m128i mul32_hi = _mm256_extracti128_si256(mul32, 0x1);\n            ss2 = _mm_add_epi32(ss2, _mm256_castsi256_si128(mul32));\n            ss2 = _mm_add_epi32(ss2, mul32_hi);\n\n#if CHAR_OFFSET != 0\n            // s1 += 32*CHAR_OFFSET\n            __m128i char_offset_multiplier = _mm_set1_epi32(32 * CHAR_OFFSET);\n            ss1 = _mm_add_epi32(ss1, char_offset_multiplier);\n\n            // s2 += 528*CHAR_OFFSET\n            char_offset_multiplier = _mm_set1_epi32(528 * CHAR_OFFSET);\n            ss2 = _mm_add_epi32(ss2, char_offset_multiplier);\n#endif\n        }\n\n        _mm_store_si128((__m128i_u*)x, ss1);\n        *ps1 = x[0];\n        _mm_store_si128((__m128i_u*)x, ss2);\n        *ps2 = x[0];\n    }\n    return i;\n}\n\n#endif /* } !USE_ROLL_ASM */\n\nstatic int32 get_checksum1_default_1(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2)\n{\n    uint32 s1 = *ps1;\n    uint32 s2 = *ps2;\n    for (; i < (len-4); i+=4) {\n        s2 += 4*(s1 + buf[i]) + 3*buf[i+1] + 2*buf[i+2] + buf[i+3] + 10*CHAR_OFFSET;\n        s1 += (buf[i+0] + buf[i+1] + buf[i+2] + buf[i+3] + 4*CHAR_OFFSET);\n    }\n    for (; i < len; i++) {\n        s1 += (buf[i]+CHAR_OFFSET); s2 += s1;\n    }\n    *ps1 = s1;\n    *ps2 = s2;\n    return i;\n}\n\n/* With GCC 10 putting this implementation inside 'extern \"C\"' causes an\n   assembler error. That worked fine on GCC 5-9 and clang 6-10...\n  */\nstatic inline uint32 get_checksum1_cpp(char *buf1, int32 len)\n{\n    int32 i = 0;\n    uint32 s1 = 0;\n    uint32 s2 = 0;\n\n    // multiples of 64 bytes using AVX2 (if available)\n#ifdef USE_ROLL_ASM\n    i = get_checksum1_avx2_asm((schar*)buf1, len, i, &s1, &s2);\n#else\n    i = get_checksum1_avx2_64((schar*)buf1, len, i, &s1, &s2);\n#endif\n\n    // multiples of 32 bytes using SSSE3 (if available)\n    i = get_checksum1_ssse3_32((schar*)buf1, len, i, &s1, &s2);\n\n    // multiples of 32 bytes using SSE2 (if available)\n    i = get_checksum1_sse2_32((schar*)buf1, len, i, &s1, &s2);\n\n    // whatever is left\n    i = get_checksum1_default_1((schar*)buf1, len, i, &s1, &s2);\n\n    return (s1 & 0xffff) + (s2 << 16);\n}\n\nextern \"C\" {\n\nuint32 get_checksum1(char *buf1, int32 len)\n{\n    return get_checksum1_cpp(buf1, len);\n}\n\n} // extern \"C\"\n\n#ifdef BENCHMARK_SIMD_CHECKSUM1\n#pragma clang optimize off\n#pragma GCC push_options\n#pragma GCC optimize (\"O0\")\n\n#define ROUNDS 1024\n#define BLOCK_LEN 1024*1024\n\n#ifndef CLOCK_MONOTONIC_RAW\n#define CLOCK_MONOTONIC_RAW CLOCK_MONOTONIC\n#endif\n\nstatic void benchmark(const char* desc, int32 (*func)(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2), schar* buf, int32 len) {\n    struct timespec start, end;\n    uint64_t us;\n    uint32_t cs, s1, s2;\n    int i, next;\n\n    clock_gettime(CLOCK_MONOTONIC_RAW, &start);\n    for (i = 0; i < ROUNDS; i++) {\n        s1 = s2 = 0;\n        next = func((schar*)buf, len, 0, &s1, &s2);\n        get_checksum1_default_1((schar*)buf, len, next, &s1, &s2);\n    }\n    clock_gettime(CLOCK_MONOTONIC_RAW, &end);\n    us = next == 0 ? 0 : (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_nsec - start.tv_nsec) / 1000;\n    cs = next == 0 ? 0 : (s1 & 0xffff) + (s2 << 16);\n    printf(\"%-5s :: %5.0f MB/s :: %08x\\n\", desc, us ? (float)(len / (1024 * 1024) * ROUNDS) / ((float)us / 1000000.0f) : 0, cs);\n}\n\nstatic int32 get_checksum1_auto(schar* buf, int32 len, int32 i, uint32* ps1, uint32* ps2) {\n    uint32 cs = get_checksum1((char*)buf, len);\n    *ps1 = cs & 0xffff;\n    *ps2 = cs >> 16;\n    return len;\n}\n\nint main() {\n    int i;\n    unsigned char* buf = (unsigned char*)aligned_alloc(64,BLOCK_LEN);\n    for (i = 0; i < BLOCK_LEN; i++) buf[i] = (i + (i % 3) + (i % 11)) % 256;\n\n    benchmark(\"Auto\", get_checksum1_auto, (schar*)buf, BLOCK_LEN);\n    benchmark(\"Raw-C\", get_checksum1_default_1, (schar*)buf, BLOCK_LEN);\n    benchmark(\"SSE2\", get_checksum1_sse2_32, (schar*)buf, BLOCK_LEN);\n    benchmark(\"SSSE3\", get_checksum1_ssse3_32, (schar*)buf, BLOCK_LEN);\n#ifdef USE_ROLL_ASM\n    benchmark(\"AVX2-ASM\", get_checksum1_avx2_asm, (schar*)buf, BLOCK_LEN);\n#else\n    benchmark(\"AVX2\", get_checksum1_avx2_64, (schar*)buf, BLOCK_LEN);\n#endif\n\n    free(buf);\n    return 0;\n}\n\n#pragma GCC pop_options\n#pragma clang optimize on\n#endif /* BENCHMARK_SIMD_CHECKSUM1 */\n\n#endif /* } USE_ROLL_SIMD */\n#endif /* } __cplusplus */\n#endif /* } __x86_64__ */\n"
        },
        {
          "name": "socket.c",
          "type": "blob",
          "size": 21.443359375,
          "content": "/*\n * Socket functions used in rsync.\n *\n * Copyright (C) 1992-2001 Andrew Tridgell <tridge@samba.org>\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* This file is now converted to use the new-style getaddrinfo()\n * interface, which supports IPv6 but is also supported on recent\n * IPv4-only machines.  On systems that don't have that interface, we\n * emulate it using the KAME implementation. */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"ifuncs.h\"\n#ifdef HAVE_NETINET_IN_SYSTM_H\n#include <netinet/in_systm.h>\n#endif\n#ifdef HAVE_NETINET_IP_H\n#include <netinet/ip.h>\n#endif\n#include <netinet/tcp.h>\n\nextern char *bind_address;\nextern char *sockopts;\nextern int default_af_hint;\nextern int connect_timeout;\nextern int pid_file_fd;\n\n#ifdef HAVE_SIGACTION\nstatic struct sigaction sigact;\n#endif\n\nstatic int sock_exec(const char *prog);\n\n/* Establish a proxy connection on an open socket to a web proxy by using the\n * CONNECT method.  If proxy_user and proxy_pass are not NULL, they are used to\n * authenticate to the proxy using the \"Basic\" proxy-authorization protocol. */\nstatic int establish_proxy_connection(int fd, char *host, int port, char *proxy_user, char *proxy_pass)\n{\n\tchar *cp, buffer[1024];\n\tchar *authhdr, authbuf[1024];\n\tint len;\n\n\tif (proxy_user && proxy_pass) {\n\t\tstringjoin(buffer, sizeof buffer,\n\t\t\t proxy_user, \":\", proxy_pass, NULL);\n\t\tlen = strlen(buffer);\n\n\t\tif ((len*8 + 5) / 6 >= (int)sizeof authbuf - 3) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"authentication information is too long\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbase64_encode(buffer, len, authbuf, 1);\n\t\tauthhdr = \"\\r\\nProxy-Authorization: Basic \";\n\t} else {\n\t\t*authbuf = '\\0';\n\t\tauthhdr = \"\";\n\t}\n\n\tlen = snprintf(buffer, sizeof buffer, \"CONNECT %s:%d HTTP/1.0%s%s\\r\\n\\r\\n\", host, port, authhdr, authbuf);\n\tassert(len > 0 && len < (int)sizeof buffer);\n\tif (write(fd, buffer, len) != len) {\n\t\trsyserr(FERROR, errno, \"failed to write to proxy\");\n\t\treturn -1;\n\t}\n\n\tfor (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {\n\t\tif (read(fd, cp, 1) != 1) {\n\t\t\trsyserr(FERROR, errno, \"failed to read from proxy\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (*cp == '\\n')\n\t\t\tbreak;\n\t}\n\n\tif (*cp != '\\n')\n\t\tcp++;\n\t*cp-- = '\\0';\n\tif (*cp == '\\r')\n\t\t*cp = '\\0';\n\tif (strncmp(buffer, \"HTTP/\", 5) != 0) {\n\t\trprintf(FERROR, \"bad response from proxy -- %s\\n\",\n\t\t\tbuffer);\n\t\treturn -1;\n\t}\n\tfor (cp = &buffer[5]; isDigit(cp) || *cp == '.'; cp++) {}\n\twhile (*cp == ' ')\n\t\tcp++;\n\tif (*cp != '2') {\n\t\trprintf(FERROR, \"bad response from proxy -- %s\\n\",\n\t\t\tbuffer);\n\t\treturn -1;\n\t}\n\t/* throw away the rest of the HTTP header */\n\twhile (1) {\n\t\tfor (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {\n\t\t\tif (read(fd, cp, 1) != 1) {\n\t\t\t\trsyserr(FERROR, errno,\n\t\t\t\t\t\"failed to read from proxy\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (*cp == '\\n')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (cp > buffer && *cp == '\\n')\n\t\t\tcp--;\n\t\tif (cp == buffer && (*cp == '\\n' || *cp == '\\r'))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n/* Try to set the local address for a newly-created socket.\n * Return -1 if this fails. */\nint try_bind_local(int s, int ai_family, int ai_socktype,\n\t\t   const char *bind_addr)\n{\n\tint error;\n\tstruct addrinfo bhints, *bres_all, *r;\n\n\tmemset(&bhints, 0, sizeof bhints);\n\tbhints.ai_family = ai_family;\n\tbhints.ai_socktype = ai_socktype;\n\tbhints.ai_flags = AI_PASSIVE;\n\tif ((error = getaddrinfo(bind_addr, NULL, &bhints, &bres_all))) {\n\t\trprintf(FERROR, RSYNC_NAME \": getaddrinfo %s: %s\\n\",\n\t\t\tbind_addr, gai_strerror(error));\n\t\treturn -1;\n\t}\n\n\tfor (r = bres_all; r; r = r->ai_next) {\n\t\tif (bind(s, r->ai_addr, r->ai_addrlen) == -1)\n\t\t\tcontinue;\n\t\tfreeaddrinfo(bres_all);\n\t\treturn s;\n\t}\n\n\t/* no error message; there might be some problem that allows\n\t * creation of the socket but not binding, perhaps if the\n\t * machine has no ipv6 address of this name. */\n\tfreeaddrinfo(bres_all);\n\treturn -1;\n}\n\n/* connect() timeout handler based on alarm() */\nstatic void contimeout_handler(UNUSED(int val))\n{\n\tconnect_timeout = -1;\n}\n\n/* Open a socket to a tcp remote host with the specified port.\n *\n * Based on code from Warren.  Proxy support by Stephen Rothwell.\n * getaddrinfo() rewrite contributed by KAME.net.\n *\n * Now that we support IPv6 we need to look up the remote machine's address\n * first, using af_hint to set a preference for the type of address.  Then\n * depending on whether it has v4 or v6 addresses we try to open a connection.\n *\n * The loop allows for machines with some addresses which may not be reachable,\n * perhaps because we can't e.g. route ipv6 to that network but we can get ip4\n * packets through.\n *\n * bind_addr: local address to use.  Normally NULL to bind the wildcard address.\n *\n * af_hint: address family, e.g. AF_INET or AF_INET6. */\nint open_socket_out(char *host, int port, const char *bind_addr, int af_hint)\n{\n\tint type = SOCK_STREAM;\n\tint error, s, j, addr_cnt, *errnos;\n\tstruct addrinfo hints, *res0, *res;\n\tchar portbuf[10];\n\tchar *h, *cp;\n\tint proxied = 0;\n\tchar buffer[1024];\n\tchar *proxy_user = NULL, *proxy_pass = NULL;\n\n\t/* if we have a RSYNC_PROXY env variable then redirect our\n\t * connection via a web proxy at the given address. */\n\th = getenv(\"RSYNC_PROXY\");\n\tproxied = h != NULL && *h != '\\0';\n\n\tif (proxied) {\n\t\tstrlcpy(buffer, h, sizeof buffer);\n\n\t\t/* Is the USER:PASS@ prefix present? */\n\t\tif ((cp = strrchr(buffer, '@')) != NULL) {\n\t\t\t*cp++ = '\\0';\n\t\t\t/* The remainder is the HOST:PORT part. */\n\t\t\th = cp;\n\n\t\t\tif ((cp = strchr(buffer, ':')) == NULL) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\"invalid proxy specification: should be USER:PASS@HOST:PORT\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*cp++ = '\\0';\n\n\t\t\tproxy_user = buffer;\n\t\t\tproxy_pass = cp;\n\t\t} else {\n\t\t\t/* The whole buffer is the HOST:PORT part. */\n\t\t\th = buffer;\n\t\t}\n\n\t\tif ((cp = strchr(h, ':')) == NULL) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"invalid proxy specification: should be HOST:PORT\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t*cp++ = '\\0';\n\t\tstrlcpy(portbuf, cp, sizeof portbuf);\n\t\tif (DEBUG_GTE(CONNECT, 1)) {\n\t\t\trprintf(FINFO, \"connection via http proxy %s port %s\\n\",\n\t\t\t\th, portbuf);\n\t\t}\n\t} else {\n\t\tsnprintf(portbuf, sizeof portbuf, \"%d\", port);\n\t\th = host;\n\t}\n\n\tmemset(&hints, 0, sizeof hints);\n\thints.ai_family = af_hint;\n\thints.ai_socktype = type;\n\terror = getaddrinfo(h, portbuf, &hints, &res0);\n\tif (error) {\n\t\trprintf(FERROR, RSYNC_NAME \": getaddrinfo: %s %s: %s\\n\",\n\t\t\th, portbuf, gai_strerror(error));\n\t\treturn -1;\n\t}\n\n\tfor (res = res0, addr_cnt = 0; res; res = res->ai_next, addr_cnt++) {}\n\terrnos = new_array0(int, addr_cnt);\n\n\ts = -1;\n\t/* Try to connect to all addresses for this machine until we get\n\t * through.  It might e.g. be multi-homed, or have both IPv4 and IPv6\n\t * addresses.  We need to create a socket for each record, since the\n\t * address record tells us what protocol to use to try to connect. */\n\tfor (res = res0, j = 0; res; res = res->ai_next, j++) {\n\t\ts = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\t\tif (s < 0)\n\t\t\tcontinue;\n\n\t\tif (bind_addr\n\t\t && try_bind_local(s, res->ai_family, type,\n\t\t\t\t   bind_addr) == -1) {\n\t\t\tclose(s);\n\t\t\ts = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (connect_timeout > 0) {\n\t\t\tSIGACTION(SIGALRM, contimeout_handler);\n\t\t\talarm(connect_timeout);\n\t\t}\n\n\t\tset_socket_options(s, sockopts);\n\t\twhile (connect(s, res->ai_addr, res->ai_addrlen) < 0) {\n\t\t\tif (connect_timeout < 0)\n\t\t\t\texit_cleanup(RERR_CONTIMEOUT);\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tclose(s);\n\t\t\ts = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (connect_timeout > 0)\n\t\t\talarm(0);\n\n\t\tif (s < 0) {\n\t\t\terrnos[j] = errno;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (proxied && establish_proxy_connection(s, host, port, proxy_user, proxy_pass) != 0) {\n\t\t\tclose(s);\n\t\t\ts = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (DEBUG_GTE(CONNECT, 2)) {\n\t\t\tchar buf[2048];\n\t\t\tif ((error = getnameinfo(res->ai_addr, res->ai_addrlen, buf, sizeof buf, NULL, 0, NI_NUMERICHOST)) != 0)\n\t\t\t\tsnprintf(buf, sizeof buf, \"*getnameinfo failure: %s*\", gai_strerror(error));\n\t\t\trprintf(FINFO, \"Connected to %s (%s)\\n\", h, buf);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (s < 0 || DEBUG_GTE(CONNECT, 2)) {\n\t\tchar buf[2048];\n\t\tfor (res = res0, j = 0; res; res = res->ai_next, j++) {\n\t\t\tif (errnos[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((error = getnameinfo(res->ai_addr, res->ai_addrlen, buf, sizeof buf, NULL, 0, NI_NUMERICHOST)) != 0)\n\t\t\t\tsnprintf(buf, sizeof buf, \"*getnameinfo failure: %s*\", gai_strerror(error));\n\t\t\trsyserr(FERROR, errnos[j], \"failed to connect to %s (%s)\", h, buf);\n\t\t}\n\t\tif (s < 0)\n\t\t\ts = -1;\n\t}\n\n\tfreeaddrinfo(res0);\n\tfree(errnos);\n\n\treturn s;\n}\n\n\n/* Open an outgoing socket, but allow for it to be intercepted by\n * $RSYNC_CONNECT_PROG, which will execute a program across a TCP\n * socketpair rather than really opening a socket.\n *\n * We use this primarily in testing to detect TCP flow bugs, but not\n * cause security problems by really opening remote connections.\n *\n * This is based on the Samba LIBSMB_PROG feature.\n *\n * bind_addr: local address to use.  Normally NULL to get the stack default. */\nint open_socket_out_wrapped(char *host, int port, const char *bind_addr, int af_hint)\n{\n\tchar *prog = getenv(\"RSYNC_CONNECT_PROG\");\n\n\tif (prog && strchr(prog, '%')) {\n\t\tint hlen = strlen(host);\n\t\tint len = strlen(prog) + 1;\n\t\tchar *f, *t;\n\t\tfor (f = prog; *f; f++) {\n\t\t\tif (*f != '%')\n\t\t\t\tcontinue;\n\t\t\t/* Compute more than enough room. */\n\t\t\tif (f[1] == '%')\n\t\t\t\tf++;\n\t\t\telse\n\t\t\t\tlen += hlen;\n\t\t}\n\t\tf = prog;\n\t\tprog = new_array(char, len);\n\t\tfor (t = prog; *f; f++) {\n\t\t\tif (*f == '%') {\n\t\t\t\tswitch (*++f) {\n\t\t\t\tcase '%':\n\t\t\t\t\t/* Just skips the extra '%'. */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'H':\n\t\t\t\t\tmemcpy(t, host, hlen);\n\t\t\t\t\tt += hlen;\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tf--; /* pass % through */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*t++ = *f;\n\t\t}\n\t\t*t = '\\0';\n\t}\n\n\tif (DEBUG_GTE(CONNECT, 1)) {\n\t\trprintf(FINFO, \"%sopening tcp connection to %s port %d\\n\",\n\t\t\tprog ? \"Using RSYNC_CONNECT_PROG instead of \" : \"\",\n\t\t\thost, port);\n\t}\n\tif (prog)\n\t\treturn sock_exec(prog);\n\treturn open_socket_out(host, port, bind_addr, af_hint);\n}\n\n\n/* Open one or more sockets for incoming data using the specified type,\n * port, and address.\n *\n * The getaddrinfo() call may return several address results, e.g. for\n * the machine's IPv4 and IPv6 name.\n *\n * We return an array of file-descriptors to the sockets, with a trailing\n * -1 value to indicate the end of the list.\n *\n * bind_addr: local address to bind, or NULL to allow it to default. */\nstatic int *open_socket_in(int type, int port, const char *bind_addr,\n\t\t\t   int af_hint)\n{\n\tint one = 1;\n\tint s, *socks, maxs, i, ecnt;\n\tstruct addrinfo hints, *all_ai, *resp;\n\tchar portbuf[10], **errmsgs;\n\tint error;\n\n\tmemset(&hints, 0, sizeof hints);\n\thints.ai_family = af_hint;\n\thints.ai_socktype = type;\n\thints.ai_flags = AI_PASSIVE;\n\tsnprintf(portbuf, sizeof portbuf, \"%d\", port);\n\terror = getaddrinfo(bind_addr, portbuf, &hints, &all_ai);\n\tif (error) {\n\t\trprintf(FERROR, RSYNC_NAME \": getaddrinfo: bind address %s: %s\\n\",\n\t\t\tbind_addr, gai_strerror(error));\n\t\treturn NULL;\n\t}\n\n\t/* Count max number of sockets we might open. */\n\tfor (maxs = 0, resp = all_ai; resp; resp = resp->ai_next, maxs++) {}\n\n\tsocks = new_array(int, maxs + 1);\n\terrmsgs = new_array(char *, maxs);\n\n\t/* We may not be able to create the socket, if for example the\n\t * machine knows about IPv6 in the C library, but not in the\n\t * kernel. */\n\tfor (resp = all_ai, i = ecnt = 0; resp; resp = resp->ai_next) {\n\t\ts = socket(resp->ai_family, resp->ai_socktype,\n\t\t\t   resp->ai_protocol);\n\n\t\tif (s == -1) {\n\t\t\tint r = asprintf(&errmsgs[ecnt++],\n\t\t\t\t\"socket(%d,%d,%d) failed: %s\\n\",\n\t\t\t\t(int)resp->ai_family, (int)resp->ai_socktype,\n\t\t\t\t(int)resp->ai_protocol, strerror(errno));\n\t\t\tif (r < 0)\n\t\t\t\tout_of_memory(\"open_socket_in\");\n\t\t\t/* See if there's another address that will work... */\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t   (char *)&one, sizeof one);\n\t\tif (sockopts)\n\t\t\tset_socket_options(s, sockopts);\n\t\telse\n\t\t\tset_socket_options(s, lp_socket_options());\n\n#ifdef IPV6_V6ONLY\n\t\tif (resp->ai_family == AF_INET6) {\n\t\t\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&one, sizeof one) < 0\n\t\t\t && default_af_hint != AF_INET6) {\n\t\t\t\tclose(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Now we've got a socket - we need to bind it. */\n\t\tif (bind(s, resp->ai_addr, resp->ai_addrlen) < 0) {\n\t\t\t/* Nope, try another */\n\t\t\tint r = asprintf(&errmsgs[ecnt++],\n\t\t\t\t\"bind() failed: %s (address-family %d)\\n\",\n\t\t\t\tstrerror(errno), (int)resp->ai_family);\n\t\t\tif (r < 0)\n\t\t\t\tout_of_memory(\"open_socket_in\");\n\t\t\tclose(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsocks[i++] = s;\n\t}\n\tsocks[i] = -1;\n\n\tif (all_ai)\n\t\tfreeaddrinfo(all_ai);\n\n\t/* Only output the socket()/bind() messages if we were totally\n\t * unsuccessful, or if the daemon is being run with -vv. */\n\tfor (s = 0; s < ecnt; s++) {\n\t\tif (!i || DEBUG_GTE(BIND, 1))\n\t\t\trwrite(FLOG, errmsgs[s], strlen(errmsgs[s]), 0);\n\t\tfree(errmsgs[s]);\n\t}\n\tfree(errmsgs);\n\n\tif (!i) {\n\t\trprintf(FERROR,\n\t\t\t\"unable to bind any inbound sockets on port %d\\n\",\n\t\t\tport);\n\t\tfree(socks);\n\t\treturn NULL;\n\t}\n\treturn socks;\n}\n\n\n/* Determine if a file descriptor is in fact a socket. */\nint is_a_socket(int fd)\n{\n\tint v;\n\tsocklen_t l = sizeof (int);\n\n\t/* Parameters to getsockopt, setsockopt etc are very\n\t * unstandardized across platforms, so don't be surprised if\n\t * there are compiler warnings on e.g. SCO OpenSwerver or AIX.\n\t * It seems they all eventually get the right idea.\n\t *\n\t * Debian says: ``The fifth argument of getsockopt and\n\t * setsockopt is in reality an int [*] (and this is what BSD\n\t * 4.* and libc4 and libc5 have).  Some POSIX confusion\n\t * resulted in the present socklen_t.  The draft standard has\n\t * not been adopted yet, but glibc2 already follows it and\n\t * also has socklen_t [*]. See also accept(2).''\n\t *\n\t * We now return to your regularly scheduled programming.  */\n\treturn getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&v, &l) == 0;\n}\n\n\nstatic void sigchld_handler(UNUSED(int val))\n{\n#ifdef WNOHANG\n\twhile (waitpid(-1, NULL, WNOHANG) > 0) {}\n#endif\n#ifndef HAVE_SIGACTION\n\tsignal(SIGCHLD, sigchld_handler);\n#endif\n}\n\n\nvoid start_accept_loop(int port, int (*fn)(int, int))\n{\n\tfd_set deffds;\n\tint *sp, maxfd, i;\n\n#ifdef HAVE_SIGACTION\n\tsigact.sa_flags = SA_NOCLDSTOP;\n#endif\n\n\t/* open an incoming socket */\n\tsp = open_socket_in(SOCK_STREAM, port, bind_address, default_af_hint);\n\tif (sp == NULL)\n\t\texit_cleanup(RERR_SOCKETIO);\n\n\t/* ready to listen */\n\tFD_ZERO(&deffds);\n\tfor (i = 0, maxfd = -1; sp[i] >= 0; i++) {\n\t\tif (listen(sp[i], lp_listen_backlog()) < 0) {\n\t\t\trsyserr(FERROR, errno, \"listen() on socket failed\");\n#ifdef INET6\n\t\t\tif (errno == EADDRINUSE && i > 0) {\n\t\t\t\trprintf(FINFO, \"Try using --ipv4 or --ipv6 to avoid this listen() error.\\n\");\n\t\t\t}\n#endif\n\t\t\texit_cleanup(RERR_SOCKETIO);\n\t\t}\n\t\tFD_SET(sp[i], &deffds);\n\t\tif (maxfd < sp[i])\n\t\t\tmaxfd = sp[i];\n\t}\n\n\t/* now accept incoming connections - forking a new process\n\t * for each incoming connection */\n\twhile (1) {\n\t\tfd_set fds;\n\t\tpid_t pid;\n\t\tint fd;\n\t\tstruct sockaddr_storage addr;\n\t\tsocklen_t addrlen = sizeof addr;\n\n\t\t/* close log file before the potentially very long select so\n\t\t * file can be trimmed by another process instead of growing\n\t\t * forever */\n\t\tlogfile_close();\n\n#ifdef FD_COPY\n\t\tFD_COPY(&deffds, &fds);\n#else\n\t\tfds = deffds;\n#endif\n\n\t\tif (select(maxfd + 1, &fds, NULL, NULL, NULL) < 1)\n\t\t\tcontinue;\n\n\t\tfor (i = 0, fd = -1; sp[i] >= 0; i++) {\n\t\t\tif (FD_ISSET(sp[i], &fds)) {\n\t\t\t\tfd = accept(sp[i], (struct sockaddr *)&addr, &addrlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\tSIGACTION(SIGCHLD, sigchld_handler);\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tint ret;\n\t\t\tif (pid_file_fd >= 0)\n\t\t\t\tclose(pid_file_fd);\n\t\t\tfor (i = 0; sp[i] >= 0; i++)\n\t\t\t\tclose(sp[i]);\n\t\t\t/* Re-open log file in child before possibly giving\n\t\t\t * up privileges (see logfile_close() above). */\n\t\t\tlogfile_reopen();\n\t\t\tret = fn(fd, fd);\n\t\t\tclose_all();\n\t\t\t_exit(ret);\n\t\t} else if (pid < 0) {\n\t\t\trsyserr(FERROR, errno,\n\t\t\t\t\"could not create child server process\");\n\t\t\tclose(fd);\n\t\t\t/* This might have happened because we're\n\t\t\t * overloaded.  Sleep briefly before trying to\n\t\t\t * accept again. */\n\t\t\tsleep(2);\n\t\t} else {\n\t\t\t/* Parent doesn't need this fd anymore. */\n\t\t\tclose(fd);\n\t\t}\n\t}\n}\n\n\nenum SOCK_OPT_TYPES {OPT_BOOL,OPT_INT,OPT_ON};\n\nstruct\n{\n  char *name;\n  int level;\n  int option;\n  int value;\n  int opttype;\n} socket_options[] = {\n  {\"SO_KEEPALIVE\",      SOL_SOCKET,    SO_KEEPALIVE,    0,                 OPT_BOOL},\n  {\"SO_REUSEADDR\",      SOL_SOCKET,    SO_REUSEADDR,    0,                 OPT_BOOL},\n#ifdef SO_BROADCAST\n  {\"SO_BROADCAST\",      SOL_SOCKET,    SO_BROADCAST,    0,                 OPT_BOOL},\n#endif\n#ifdef TCP_NODELAY\n  {\"TCP_NODELAY\",       IPPROTO_TCP,   TCP_NODELAY,     0,                 OPT_BOOL},\n#endif\n#ifdef IPTOS_LOWDELAY\n  {\"IPTOS_LOWDELAY\",    IPPROTO_IP,    IP_TOS,          IPTOS_LOWDELAY,    OPT_ON},\n#endif\n#ifdef IPTOS_THROUGHPUT\n  {\"IPTOS_THROUGHPUT\",  IPPROTO_IP,    IP_TOS,          IPTOS_THROUGHPUT,  OPT_ON},\n#endif\n#ifdef SO_SNDBUF\n  {\"SO_SNDBUF\",         SOL_SOCKET,    SO_SNDBUF,       0,                 OPT_INT},\n#endif\n#ifdef SO_RCVBUF\n  {\"SO_RCVBUF\",         SOL_SOCKET,    SO_RCVBUF,       0,                 OPT_INT},\n#endif\n#ifdef SO_SNDLOWAT\n  {\"SO_SNDLOWAT\",       SOL_SOCKET,    SO_SNDLOWAT,     0,                 OPT_INT},\n#endif\n#ifdef SO_RCVLOWAT\n  {\"SO_RCVLOWAT\",       SOL_SOCKET,    SO_RCVLOWAT,     0,                 OPT_INT},\n#endif\n#ifdef SO_SNDTIMEO\n  {\"SO_SNDTIMEO\",       SOL_SOCKET,    SO_SNDTIMEO,     0,                 OPT_INT},\n#endif\n#ifdef SO_RCVTIMEO\n  {\"SO_RCVTIMEO\",       SOL_SOCKET,    SO_RCVTIMEO,     0,                 OPT_INT},\n#endif\n  {NULL,0,0,0,0}\n};\n\n\n/* Set user socket options. */\nvoid set_socket_options(int fd, char *options)\n{\n\tchar *tok;\n\n\tif (!options || !*options)\n\t\treturn;\n\n\toptions = strdup(options);\n\n\tfor (tok = strtok(options, \" \\t,\"); tok; tok = strtok(NULL,\" \\t,\")) {\n\t\tint ret=0,i;\n\t\tint value = 1;\n\t\tchar *p;\n\t\tint got_value = 0;\n\n\t\tif ((p = strchr(tok,'='))) {\n\t\t\t*p = 0;\n\t\t\tvalue = atoi(p+1);\n\t\t\tgot_value = 1;\n\t\t}\n\n\t\tfor (i = 0; socket_options[i].name; i++) {\n\t\t\tif (strcmp(socket_options[i].name,tok)==0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!socket_options[i].name) {\n\t\t\trprintf(FERROR,\"Unknown socket option %s\\n\",tok);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (socket_options[i].opttype) {\n\t\tcase OPT_BOOL:\n\t\tcase OPT_INT:\n\t\t\tret = setsockopt(fd,socket_options[i].level,\n\t\t\t\t\t socket_options[i].option,\n\t\t\t\t\t (char *)&value, sizeof (int));\n\t\t\tbreak;\n\n\t\tcase OPT_ON:\n\t\t\tif (got_value)\n\t\t\t\trprintf(FERROR,\"syntax error -- %s does not take a value\\n\",tok);\n\n\t\t\t{\n\t\t\t\tint on = socket_options[i].value;\n\t\t\t\tret = setsockopt(fd,socket_options[i].level,\n\t\t\t\t\t\t socket_options[i].option,\n\t\t\t\t\t\t (char *)&on, sizeof (int));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret != 0) {\n\t\t\trsyserr(FERROR, errno,\n\t\t\t\t\"failed to set socket option %s\", tok);\n\t\t}\n\t}\n\n\tfree(options);\n}\n\n\n/* This is like socketpair but uses tcp.  The function guarantees that nobody\n * else can attach to the socket, or if they do that this function fails and\n * the socket gets closed.  Returns 0 on success, -1 on failure.  The resulting\n * file descriptors are symmetrical.  Currently only for RSYNC_CONNECT_PROG. */\nstatic int socketpair_tcp(int fd[2])\n{\n\tint listener;\n\tstruct sockaddr_in sock;\n\tstruct sockaddr_in sock2;\n\tsocklen_t socklen = sizeof sock;\n\tint connect_done = 0;\n\n\tfd[0] = fd[1] = listener = -1;\n\n\tmemset(&sock, 0, sizeof sock);\n\n\tif ((listener = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tmemset(&sock2, 0, sizeof sock2);\n#ifdef HAVE_SOCKADDR_IN_LEN\n\tsock2.sin_len = sizeof sock2;\n#endif\n\tsock2.sin_family = PF_INET;\n\tsock2.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n\tif (bind(listener, (struct sockaddr *)&sock2, sizeof sock2) != 0\n\t || listen(listener, 1) != 0\n\t || getsockname(listener, (struct sockaddr *)&sock, &socklen) != 0\n\t || (fd[1] = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tset_nonblocking(fd[1]);\n\n\tsock.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n\tif (connect(fd[1], (struct sockaddr *)&sock, sizeof sock) == -1) {\n\t\tif (errno != EINPROGRESS)\n\t\t\tgoto failed;\n\t} else\n\t\tconnect_done = 1;\n\n\tif ((fd[0] = accept(listener, (struct sockaddr *)&sock2, &socklen)) == -1)\n\t\tgoto failed;\n\n\tclose(listener);\n\tlistener = -1;\n\n\tset_blocking(fd[1]);\n\n\tif (connect_done == 0) {\n\t\tif (connect(fd[1], (struct sockaddr *)&sock, sizeof sock) != 0 && errno != EISCONN)\n\t\t\tgoto failed;\n\t}\n\n\t/* all OK! */\n\treturn 0;\n\n failed:\n\tif (fd[0] != -1)\n\t\tclose(fd[0]);\n\tif (fd[1] != -1)\n\t\tclose(fd[1]);\n\tif (listener != -1)\n\t\tclose(listener);\n\treturn -1;\n}\n\n\n/* Run a program on a local tcp socket, so that we can talk to it's stdin and\n * stdout.  This is used to fake a connection to a daemon for testing -- not\n * for the normal case of running SSH.\n *\n * Returns a socket which is attached to a subprocess running \"prog\". stdin and\n * stdout are attached. stderr is left attached to the original stderr. */\nstatic int sock_exec(const char *prog)\n{\n\tpid_t pid;\n\tint fd[2];\n\n\tif (socketpair_tcp(fd) != 0) {\n\t\trsyserr(FERROR, errno, \"socketpair_tcp failed\");\n\t\treturn -1;\n\t}\n\tif (DEBUG_GTE(CMD, 1))\n\t\trprintf(FINFO, \"Running socket program: \\\"%s\\\"\\n\", prog);\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\trsyserr(FERROR, errno, \"fork\");\n\t\texit_cleanup(RERR_IPC);\n\t}\n\n\tif (pid == 0) {\n\t\tclose(fd[0]);\n\t\tif (dup2(fd[1], STDIN_FILENO) < 0\n\t\t || dup2(fd[1], STDOUT_FILENO) < 0) {\n\t\t\tfprintf(stderr, \"Failed to run \\\"%s\\\"\\n\", prog);\n\t\t\texit(1);\n\t\t}\n\t\texit(shell_exec(prog));\n\t}\n\n\tclose(fd[1]);\n\treturn fd[0];\n}\n"
        },
        {
          "name": "stunnel-rsyncd.conf.in",
          "type": "blob",
          "size": 0.9921875,
          "content": "# This config for stunnel will start up rsync for an incoming ssl connection.\nforeground = no\n#output = /var/log/stunnel-rsyncd.log\npid = /var/run/stunnel-rsyncd.pid\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n#compression = rle\n# This must be root for rsync to use chroot -- rsync will drop permissions:\nsetuid = root\nsetgid = root\n\n[rsync]\naccept = 874\n# You can set the cert to a combo *.pem file and omit the key, if you like.\ncert = /etc/rsync-ssl/certs/server.crt\nkey  = /etc/rsync-ssl/certs/server.key\nclient = no\n\n# To allow anyone to try an ssl connection, use this:\nverify = 0\nCAfile = /etc/ssl/certs/ca-certificates.crt\n\n# To allow only cert-authorized clients, use something like this instead of the above:\n#verify = 3\n#CAfile = /etc/rsync-ssl/certs/allowed-clients.cert.pem\n\nexec = @bindir@/rsync\n# You can either share the same config as a normal daemon, or specify a separate config:\nexecargs = rsync --server --daemon .\n#execargs = rsync --server --daemon --config=/etc/rsync-ssl/rsyncd.conf .\n"
        },
        {
          "name": "support",
          "type": "tree",
          "content": null
        },
        {
          "name": "syscall.c",
          "type": "blob",
          "size": 15.28125,
          "content": "/*\n * Syscall wrappers to ensure that nothing gets done in dry_run mode\n * and to handle system peculiarities.\n *\n * Copyright (C) 1998 Andrew Tridgell\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n#if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n#ifdef HAVE_SYS_ATTR_H\n#include <sys/attr.h>\n#endif\n\n#if defined HAVE_SYS_FALLOCATE && !defined HAVE_FALLOCATE\n#include <sys/syscall.h>\n#endif\n\nextern int dry_run;\nextern int am_root;\nextern int am_sender;\nextern int read_only;\nextern int list_only;\nextern int inplace;\nextern int preallocate_files;\nextern int preserve_perms;\nextern int preserve_executability;\nextern int open_noatime;\n\n#ifndef S_BLKSIZE\n# if defined hpux || defined __hpux__ || defined __hpux\n#  define S_BLKSIZE 1024\n# elif defined _AIX && defined _I386\n#  define S_BLKSIZE 4096\n# else\n#  define S_BLKSIZE 512\n# endif\n#endif\n\n#ifdef SUPPORT_CRTIMES\n#ifdef HAVE_GETATTRLIST\n#pragma pack(push, 4)\nstruct create_time {\n\tuint32 length;\n\tstruct timespec crtime;\n};\n#pragma pack(pop)\n#elif defined __CYGWIN__\n#include <windows.h>\n#endif\n#endif\n\n#define RETURN_ERROR_IF(x,e) \\\n\tdo { \\\n\t\tif (x) { \\\n\t\t\terrno = (e); \\\n\t\t\treturn -1; \\\n\t\t} \\\n\t} while (0)\n\n#define RETURN_ERROR_IF_RO_OR_LO RETURN_ERROR_IF(read_only || list_only, EROFS)\n\nint do_unlink(const char *path)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\treturn unlink(path);\n}\n\n#ifdef SUPPORT_LINKS\nint do_symlink(const char *lnk, const char *path)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n#if defined NO_SYMLINK_XATTRS || defined NO_SYMLINK_USER_XATTRS\n\t/* For --fake-super, we create a normal file with mode 0600\n\t * and write the lnk into it. */\n\tif (am_root < 0) {\n\t\tint ok, len = strlen(lnk);\n\t\tint fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\t\tok = write(fd, lnk, len) == len;\n\t\tif (close(fd) < 0)\n\t\t\tok = 0;\n\t\treturn ok ? 0 : -1;\n\t}\n#endif\n\n\treturn symlink(lnk, path);\n}\n\n#if defined NO_SYMLINK_XATTRS || defined NO_SYMLINK_USER_XATTRS\nssize_t do_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\t/* For --fake-super, we read the link from the file. */\n\tif (am_root < 0) {\n\t\tint fd = do_open_nofollow(path, O_RDONLY);\n\t\tif (fd >= 0) {\n\t\t\tint len = read(fd, buf, bufsiz);\n\t\t\tclose(fd);\n\t\t\treturn len;\n\t\t}\n\t\tif (errno != ELOOP)\n\t\t\treturn -1;\n\t\t/* A real symlink needs to be turned into a fake one on the receiving\n\t\t * side, so tell the generator that the link has no length. */\n\t\tif (!am_sender)\n\t\t\treturn 0;\n\t\t/* Otherwise fall through and let the sender report the real length. */\n\t}\n\n\treturn readlink(path, buf, bufsiz);\n}\n#endif\n#endif\n\n#if defined HAVE_LINK || defined HAVE_LINKAT\nint do_link(const char *old_path, const char *new_path)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n#ifdef HAVE_LINKAT\n\treturn linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);\n#else\n\treturn link(old_path, new_path);\n#endif\n}\n#endif\n\nint do_lchown(const char *path, uid_t owner, gid_t group)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n#ifndef HAVE_LCHOWN\n#define lchown chown\n#endif\n\treturn lchown(path, owner, group);\n}\n\nint do_mknod(const char *pathname, mode_t mode, dev_t dev)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\t/* For --fake-super, we create a normal file with mode 0600. */\n\tif (am_root < 0) {\n\t\tint fd = open(pathname, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR);\n\t\tif (fd < 0 || close(fd) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n#if !defined MKNOD_CREATES_FIFOS && defined HAVE_MKFIFO\n\tif (S_ISFIFO(mode))\n\t\treturn mkfifo(pathname, mode);\n#endif\n#if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H\n\tif (S_ISSOCK(mode)) {\n\t\tint sock;\n\t\tstruct sockaddr_un saddr;\n\t\tunsigned int len = strlcpy(saddr.sun_path, pathname, sizeof saddr.sun_path);\n\t\tif (len >= sizeof saddr.sun_path) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn -1;\n\t\t}\n#ifdef HAVE_SOCKADDR_UN_LEN\n\t\tsaddr.sun_len = len + 1;\n#endif\n\t\tsaddr.sun_family = AF_UNIX;\n\n\t\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0\n\t\t || (unlink(pathname) < 0 && errno != ENOENT)\n\t\t || (bind(sock, (struct sockaddr*)&saddr, sizeof saddr)) < 0)\n\t\t\treturn -1;\n\t\tclose(sock);\n#ifdef HAVE_CHMOD\n\t\treturn do_chmod(pathname, mode);\n#else\n\t\treturn 0;\n#endif\n\t}\n#endif\n#ifdef HAVE_MKNOD\n\treturn mknod(pathname, mode, dev);\n#else\n\treturn -1;\n#endif\n}\n\nint do_rmdir(const char *pathname)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\treturn rmdir(pathname);\n}\n\nint do_open(const char *pathname, int flags, mode_t mode)\n{\n\tif (flags != O_RDONLY) {\n\t\tRETURN_ERROR_IF(dry_run, 0);\n\t\tRETURN_ERROR_IF_RO_OR_LO;\n\t}\n\n#ifdef O_NOATIME\n\tif (open_noatime)\n\t\tflags |= O_NOATIME;\n#endif\n\n\treturn open(pathname, flags | O_BINARY, mode);\n}\n\n#ifdef HAVE_CHMOD\nint do_chmod(const char *path, mode_t mode)\n{\n\tstatic int switch_step = 0;\n\tint code;\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tswitch (switch_step) {\n#ifdef HAVE_LCHMOD\n\tcase 0:\n\t\tif ((code = lchmod(path, mode & CHMOD_BITS)) == 0)\n\t\t\tbreak;\n\t\tif (errno == ENOSYS)\n\t\t\tswitch_step++;\n\t\telse if (errno != ENOTSUP)\n\t\t\tbreak;\n#endif\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tif (S_ISLNK(mode)) {\n# if defined HAVE_SETATTRLIST\n\t\t\tstruct attrlist attrList;\n\t\t\tuint32_t m = mode & CHMOD_BITS; /* manpage is wrong: not mode_t! */\n\n\t\t\tmemset(&attrList, 0, sizeof attrList);\n\t\t\tattrList.bitmapcount = ATTR_BIT_MAP_COUNT;\n\t\t\tattrList.commonattr = ATTR_CMN_ACCESSMASK;\n\t\t\tif ((code = setattrlist(path, &attrList, &m, sizeof m, FSOPT_NOFOLLOW)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == ENOTSUP)\n\t\t\t\tcode = 1;\n# else\n\t\t\tcode = 1;\n# endif\n\t\t} else\n\t\t\tcode = chmod(path, mode & CHMOD_BITS); /* DISCOURAGED FUNCTION */\n\t\tbreak;\n\t}\n\tif (code != 0 && (preserve_perms || preserve_executability))\n\t\treturn code;\n\treturn 0;\n}\n#endif\n\nint do_rename(const char *old_path, const char *new_path)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\treturn rename(old_path, new_path);\n}\n\n#ifdef HAVE_FTRUNCATE\nint do_ftruncate(int fd, OFF_T size)\n{\n\tint ret;\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tdo {\n\t\tret = ftruncate(fd, size);\n\t} while (ret < 0 && errno == EINTR);\n\n\treturn ret;\n}\n#endif\n\nvoid trim_trailing_slashes(char *name)\n{\n\tint l;\n\t/* Some BSD systems cannot make a directory if the name\n\t * contains a trailing slash.\n\t * <http://www.opensource.apple.com/bugs/X/BSD%20Kernel/2734739.html> */\n\n\t/* Don't change empty string; and also we can't improve on\n\t * \"/\" */\n\n\tl = strlen(name);\n\twhile (l > 1) {\n\t\tif (name[--l] != '/')\n\t\t\tbreak;\n\t\tname[l] = '\\0';\n\t}\n}\n\nint do_mkdir(char *path, mode_t mode)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\ttrim_trailing_slashes(path);\n\treturn mkdir(path, mode);\n}\n\n/* like mkstemp but forces permissions */\nint do_mkstemp(char *template, mode_t perms)\n{\n\tRETURN_ERROR_IF(dry_run, 0);\n\tRETURN_ERROR_IF(read_only, EROFS);\n\tperms |= S_IWUSR;\n\n#if defined HAVE_SECURE_MKSTEMP && defined HAVE_FCHMOD && (!defined HAVE_OPEN64 || defined HAVE_MKSTEMP64)\n\t{\n\t\tint fd = mkstemp(template);\n\t\tif (fd == -1)\n\t\t\treturn -1;\n\t\tif (fchmod(fd, perms) != 0 && preserve_perms) {\n\t\t\tint errno_save = errno;\n\t\t\tclose(fd);\n\t\t\tunlink(template);\n\t\t\terrno = errno_save;\n\t\t\treturn -1;\n\t\t}\n#if defined HAVE_SETMODE && O_BINARY\n\t\tsetmode(fd, O_BINARY);\n#endif\n\t\treturn fd;\n\t}\n#else\n\tif (!mktemp(template))\n\t\treturn -1;\n\treturn do_open(template, O_RDWR|O_EXCL|O_CREAT, perms);\n#endif\n}\n\nint do_stat(const char *path, STRUCT_STAT *st)\n{\n#ifdef USE_STAT64_FUNCS\n\treturn stat64(path, st);\n#else\n\treturn stat(path, st);\n#endif\n}\n\nint do_lstat(const char *path, STRUCT_STAT *st)\n{\n#ifdef SUPPORT_LINKS\n# ifdef USE_STAT64_FUNCS\n\treturn lstat64(path, st);\n# else\n\treturn lstat(path, st);\n# endif\n#else\n\treturn do_stat(path, st);\n#endif\n}\n\nint do_fstat(int fd, STRUCT_STAT *st)\n{\n#ifdef USE_STAT64_FUNCS\n\treturn fstat64(fd, st);\n#else\n\treturn fstat(fd, st);\n#endif\n}\n\nOFF_T do_lseek(int fd, OFF_T offset, int whence)\n{\n#ifdef HAVE_LSEEK64\n\treturn lseek64(fd, offset, whence);\n#else\n\treturn lseek(fd, offset, whence);\n#endif\n}\n\n#ifdef HAVE_SETATTRLIST\nint do_setattrlist_times(const char *path, STRUCT_STAT *stp)\n{\n\tstruct attrlist attrList;\n\tstruct timespec ts[2];\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\t/* Yes, this is in the opposite order of utime and similar. */\n\tts[0].tv_sec = stp->st_mtime;\n\tts[0].tv_nsec = stp->ST_MTIME_NSEC;\n\n\tts[1].tv_sec = stp->st_atime;\n\tts[1].tv_nsec = stp->ST_ATIME_NSEC;\n\n\tmemset(&attrList, 0, sizeof attrList);\n\tattrList.bitmapcount = ATTR_BIT_MAP_COUNT;\n\tattrList.commonattr = ATTR_CMN_MODTIME | ATTR_CMN_ACCTIME;\n\treturn setattrlist(path, &attrList, ts, sizeof ts, FSOPT_NOFOLLOW);\n}\n\n#ifdef SUPPORT_CRTIMES\nint do_setattrlist_crtime(const char *path, time_t crtime)\n{\n\tstruct attrlist attrList;\n\tstruct timespec ts;\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tts.tv_sec = crtime;\n\tts.tv_nsec = 0;\n\n\tmemset(&attrList, 0, sizeof attrList);\n\tattrList.bitmapcount = ATTR_BIT_MAP_COUNT;\n\tattrList.commonattr = ATTR_CMN_CRTIME;\n\treturn setattrlist(path, &attrList, &ts, sizeof ts, FSOPT_NOFOLLOW);\n}\n#endif\n#endif /* HAVE_SETATTRLIST */\n\n#ifdef SUPPORT_CRTIMES\ntime_t get_create_time(const char *path, STRUCT_STAT *stp)\n{\n#ifdef HAVE_GETATTRLIST\n\tstatic struct create_time attrBuf;\n\tstruct attrlist attrList;\n\n\t(void)stp;\n\tmemset(&attrList, 0, sizeof attrList);\n\tattrList.bitmapcount = ATTR_BIT_MAP_COUNT;\n\tattrList.commonattr = ATTR_CMN_CRTIME;\n\tif (getattrlist(path, &attrList, &attrBuf, sizeof attrBuf, FSOPT_NOFOLLOW) < 0)\n\t\treturn 0;\n\treturn attrBuf.crtime.tv_sec;\n#elif defined __CYGWIN__\n\t(void)path;\n\treturn stp->st_birthtime;\n#else\n#error Unknown crtimes implementation\n#endif\n}\n\n#if defined __CYGWIN__\nint do_SetFileTime(const char *path, time_t crtime)\n{\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tint cnt = MultiByteToWideChar(CP_UTF8, 0, path, -1, NULL, 0);\n\tif (cnt == 0)\n\t    return -1;\n\tWCHAR *pathw = new_array(WCHAR, cnt);\n\tif (!pathw)\n\t    return -1;\n\tMultiByteToWideChar(CP_UTF8, 0, path, -1, pathw, cnt);\n\tHANDLE handle = CreateFileW(pathw, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n\t\t\t\t    NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\tfree(pathw);\n\tif (handle == INVALID_HANDLE_VALUE)\n\t    return -1;\n\tint64 temp_time = Int32x32To64(crtime, 10000000) + 116444736000000000LL;\n\tFILETIME birth_time;\n\tbirth_time.dwLowDateTime = (DWORD)temp_time;\n\tbirth_time.dwHighDateTime = (DWORD)(temp_time >> 32);\n\tint ok = SetFileTime(handle, &birth_time, NULL, NULL);\n\tCloseHandle(handle);\n\treturn ok ? 0 : -1;\n}\n#endif\n#endif /* SUPPORT_CRTIMES */\n\n#ifdef HAVE_UTIMENSAT\nint do_utimensat(const char *path, STRUCT_STAT *stp)\n{\n\tstruct timespec t[2];\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tt[0].tv_sec = stp->st_atime;\n#ifdef ST_ATIME_NSEC\n\tt[0].tv_nsec = stp->ST_ATIME_NSEC;\n#else\n\tt[0].tv_nsec = 0;\n#endif\n\tt[1].tv_sec = stp->st_mtime;\n#ifdef ST_MTIME_NSEC\n\tt[1].tv_nsec = stp->ST_MTIME_NSEC;\n#else\n\tt[1].tv_nsec = 0;\n#endif\n\treturn utimensat(AT_FDCWD, path, t, AT_SYMLINK_NOFOLLOW);\n}\n#endif\n\n#ifdef HAVE_LUTIMES\nint do_lutimes(const char *path, STRUCT_STAT *stp)\n{\n\tstruct timeval t[2];\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tt[0].tv_sec = stp->st_atime;\n#ifdef ST_ATIME_NSEC\n\tt[0].tv_usec = stp->ST_ATIME_NSEC / 1000;\n#else\n\tt[0].tv_usec = 0;\n#endif\n\tt[1].tv_sec = stp->st_mtime;\n#ifdef ST_MTIME_NSEC\n\tt[1].tv_usec = stp->ST_MTIME_NSEC / 1000;\n#else\n\tt[1].tv_usec = 0;\n#endif\n\treturn lutimes(path, t);\n}\n#endif\n\n#ifdef HAVE_UTIMES\nint do_utimes(const char *path, STRUCT_STAT *stp)\n{\n\tstruct timeval t[2];\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n\tt[0].tv_sec = stp->st_atime;\n#ifdef ST_ATIME_NSEC\n\tt[0].tv_usec = stp->ST_ATIME_NSEC / 1000;\n#else\n\tt[0].tv_usec = 0;\n#endif\n\tt[1].tv_sec = stp->st_mtime;\n#ifdef ST_MTIME_NSEC\n\tt[1].tv_usec = stp->ST_MTIME_NSEC / 1000;\n#else\n\tt[1].tv_usec = 0;\n#endif\n\treturn utimes(path, t);\n}\n\n#elif defined HAVE_UTIME\nint do_utime(const char *path, STRUCT_STAT *stp)\n{\n#ifdef HAVE_STRUCT_UTIMBUF\n\tstruct utimbuf tbuf;\n#else\n\ttime_t t[2];\n#endif\n\n\tif (dry_run) return 0;\n\tRETURN_ERROR_IF_RO_OR_LO;\n\n# ifdef HAVE_STRUCT_UTIMBUF\n\ttbuf.actime = stp->st_atime;\n\ttbuf.modtime = stp->st_mtime;\n\treturn utime(path, &tbuf);\n# else\n\tt[0] = stp->st_atime;\n\tt[1] = stp->st_mtime;\n\treturn utime(path, t);\n# endif\n}\n\n#else\n#error Need utimes or utime function.\n#endif\n\n#ifdef SUPPORT_PREALLOCATION\n#ifdef FALLOC_FL_KEEP_SIZE\n#define DO_FALLOC_OPTIONS FALLOC_FL_KEEP_SIZE\n#else\n#define DO_FALLOC_OPTIONS 0\n#endif\n\nOFF_T do_fallocate(int fd, OFF_T offset, OFF_T length)\n{\n\tint opts = inplace || preallocate_files ? DO_FALLOC_OPTIONS : 0;\n\tint ret;\n\tRETURN_ERROR_IF(dry_run, 0);\n\tRETURN_ERROR_IF_RO_OR_LO;\n\tif (length & 1) /* make the length not match the desired length */\n\t\tlength++;\n\telse\n\t\tlength--;\n#if defined HAVE_FALLOCATE\n\tret = fallocate(fd, opts, offset, length);\n#elif defined HAVE_SYS_FALLOCATE\n\tret = syscall(SYS_fallocate, fd, opts, (loff_t)offset, (loff_t)length);\n#elif defined HAVE_EFFICIENT_POSIX_FALLOCATE\n\tret = posix_fallocate(fd, offset, length);\n#else\n#error Coding error in SUPPORT_PREALLOCATION logic.\n#endif\n\tif (ret < 0)\n\t\treturn ret;\n\tif (opts == 0) {\n\t\tSTRUCT_STAT st;\n\t\tif (do_fstat(fd, &st) < 0)\n\t\t\treturn length;\n\t\treturn st.st_blocks * S_BLKSIZE;\n\t}\n\treturn 0;\n}\n#endif\n\n/* Punch a hole at pos for len bytes. The current file position must be at pos and will be\n * changed to be at pos + len. */\nint do_punch_hole(int fd, OFF_T pos, OFF_T len)\n{\n#ifdef HAVE_FALLOCATE\n# ifdef HAVE_FALLOC_FL_PUNCH_HOLE\n\tif (fallocate(fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, pos, len) == 0) {\n\t\tif (do_lseek(fd, len, SEEK_CUR) != pos + len)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n# endif\n# ifdef HAVE_FALLOC_FL_ZERO_RANGE\n\tif (fallocate(fd, FALLOC_FL_ZERO_RANGE, pos, len) == 0) {\n\t\tif (do_lseek(fd, len, SEEK_CUR) != pos + len)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n# endif\n#else\n\t(void)pos;\n#endif\n\t{\n\t\tchar zeros[4096];\n\t\tmemset(zeros, 0, sizeof zeros);\n\t\twhile (len > 0) {\n\t\t\tint chunk = len > (int)sizeof zeros ? (int)sizeof zeros : len;\n\t\t\tint wrote = write(fd, zeros, chunk);\n\t\t\tif (wrote <= 0) {\n\t\t\t\tif (wrote < 0 && errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlen -= wrote;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint do_open_nofollow(const char *pathname, int flags)\n{\n#ifndef O_NOFOLLOW\n\tSTRUCT_STAT f_st, l_st;\n#endif\n\tint fd;\n\n\tif (flags != O_RDONLY) {\n\t\tRETURN_ERROR_IF(dry_run, 0);\n\t\tRETURN_ERROR_IF_RO_OR_LO;\n#ifndef O_NOFOLLOW\n\t\t/* This function doesn't support write attempts w/o O_NOFOLLOW. */\n\t\terrno = EINVAL;\n\t\treturn -1;\n#endif\n\t}\n\n#ifdef O_NOFOLLOW\n\tfd = open(pathname, flags|O_NOFOLLOW);\n#else\n\tif (do_lstat(pathname, &l_st) < 0)\n\t\treturn -1;\n\tif (S_ISLNK(l_st.st_mode)) {\n\t\terrno = ELOOP;\n\t\treturn -1;\n\t}\n\tif ((fd = open(pathname, flags)) < 0)\n\t\treturn fd;\n\tif (do_fstat(fd, &f_st) < 0) {\n\t  close_and_return_error:\n\t\t{\n\t\t\tint save_errno = errno;\n\t\t\tclose(fd);\n\t\t\terrno = save_errno;\n\t\t}\n\t\treturn -1;\n\t}\n\tif (l_st.st_dev != f_st.st_dev || l_st.st_ino != f_st.st_ino) {\n\t\terrno = EINVAL;\n\t\tgoto close_and_return_error;\n\t}\n#endif\n\n\treturn fd;\n}\n"
        },
        {
          "name": "t_stub.c",
          "type": "blob",
          "size": 2.5703125,
          "content": "/*\n * This file contains really simple implementations for rsync global\n * functions, so that module test harnesses can run standalone.\n *\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\nint do_fsync = 0;\nint inplace = 0;\nint modify_window = 0;\nint preallocate_files = 0;\nint protect_args = 0;\nint module_id = -1;\nint relative_paths = 0;\nunsigned int module_dirlen = 0;\nint preserve_xattrs = 0;\nint preserve_perms = 0;\nint preserve_executability = 0;\nint omit_link_times = 0;\nint open_noatime = 0;\nsize_t max_alloc = 0; /* max_alloc is needed when combined with util2.o */\nchar *partial_dir;\nchar *module_dir;\nfilter_rule_list daemon_filter_list;\n\n void rprintf(UNUSED(enum logcode code), const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n}\n\n void rsyserr(UNUSED(enum logcode code), int errcode, const char *format, ...)\n{\n\tva_list ap;\n\tfputs(RSYNC_NAME \": \", stderr);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n\tfprintf(stderr, \": %s (%d)\\n\", strerror(errcode), errcode);\n}\n\n void _exit_cleanup(int code, const char *file, int line)\n{\n\tfprintf(stderr, \"exit(%d): %s(%d)\\n\",\n\t\tcode, file, line);\n\texit(code);\n}\n\n int check_filter(UNUSED(filter_rule_list *listp), UNUSED(enum logcode code),\n\t\t  UNUSED(const char *name), UNUSED(int name_is_dir))\n{\n\t/* This function doesn't really get called in this test context, so\n\t * just return 0. */\n\treturn 0;\n}\n\n int copy_xattrs(UNUSED(const char *source), UNUSED(const char *dest))\n{\n\treturn -1;\n}\n\n void free_xattr(UNUSED(stat_x *sxp))\n{\n\treturn;\n}\n\n void free_acl(UNUSED(stat_x *sxp))\n{\n\treturn;\n}\n\n char *lp_name(UNUSED(int mod))\n{\n\treturn NULL;\n}\n\n BOOL lp_use_chroot(UNUSED(int mod))\n{\n\treturn 0;\n}\n\n const char *who_am_i(void)\n{\n\treturn \"tester\";\n}\n\n int csum_len_for_type(int cst, int flg)\n{\n\treturn cst || !flg ? 16 : 1;\n}\n\n int canonical_checksum(int cst)\n{\n\treturn cst ? 0 : 0;\n}\n"
        },
        {
          "name": "t_unsafe.c",
          "type": "blob",
          "size": 1.28125,
          "content": "/*\n * Test harness for unsafe_symlink().  Not linked into rsync itself.\n *\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2003-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* Prints either \"safe\" or \"unsafe\" depending on the two arguments.\n * Always returns 0 unless something extraordinary happens. */\n\n#include \"rsync.h\"\n\nint dry_run = 0;\nint am_root = 0;\nint am_sender = 1;\nint read_only = 0;\nint list_only = 0;\nshort info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];\n\nint\nmain(int argc, char **argv)\n{\n\tif (argc != 3) {\n\t\tfprintf(stderr, \"usage: t_unsafe LINKDEST SRCDIR\\n\");\n\t\treturn 1;\n\t}\n\n\tprintf(\"%s\\n\", unsafe_symlink(argv[1], argv[2]) ? \"unsafe\" : \"safe\");\n\n\treturn 0;\n}\n"
        },
        {
          "name": "tech_report.tex",
          "type": "blob",
          "size": 14.3310546875,
          "content": "\\documentclass[a4paper]{article}\n\\begin{document}\n\n\n\\title{The rsync algorithm}\n\n\\author{Andrew Tridgell \\quad\\quad Paul Mackerras\\\\\nDepartment of Computer Science \\\\\nAustralian National University \\\\\nCanberra, ACT 0200, Australia}\n\n\\maketitle\n\n\\begin{abstract}\n  This report presents an algorithm for updating a file on one machine\n  to be identical to a file on another machine.  We assume that the\n  two machines are connected by a low-bandwidth high-latency\n  bi-directional communications link.  The algorithm identifies parts\n  of the source file which are identical to some part of the\n  destination file, and only sends those parts which cannot be matched\n  in this way.  Effectively, the algorithm computes a set of\n  differences without having both files on the same machine.  The\n  algorithm works best when the files are similar, but will also\n  function correctly and reasonably efficiently when the files are\n  quite different.\n\\end{abstract}\n\n\\section{The problem}\n\nImagine you have two files, $A$ and $B$, and you wish to update $B$ to be\nthe same as $A$. The obvious method is to copy $A$ onto $B$.\n\nNow imagine that the two files are on machines connected by a slow\ncommunications link, for example a dialup IP link.  If $A$ is large,\ncopying $A$ onto $B$ will be slow.  To make it faster you could\ncompress $A$ before sending it, but that will usually only gain a\nfactor of 2 to 4.\n\nNow assume that $A$ and $B$ are quite similar, perhaps both derived\nfrom the same original file. To really speed things up you would need\nto take advantage of this similarity. A common method is to send just\nthe differences between $A$ and $B$ down the link and then use this\nlist of differences to reconstruct the file.\n\nThe problem is that the normal methods for creating a set of\ndifferences between two files rely on being able to read both files.\nThus they require that both files are available beforehand at one end\nof the link.  If they are not both available on the same machine,\nthese algorithms cannot be used (once you had copied the file over,\nyou wouldn't need the differences).  This is the problem that rsync\naddresses.\n\nThe rsync algorithm efficiently computes which parts of a source file\nmatch some part of an existing destination file.  These parts need not\nbe sent across the link; all that is needed is a reference to the part\nof the destination file.  Only parts of the source file which are not\nmatched in this way need to be sent verbatim.  The receiver can then\nconstruct a copy of the source file using the references to parts of\nthe existing destination file and the verbatim material.\n\nTrivially, the data sent to the receiver can be compressed using any\nof a range of common compression algorithms, for further speed\nimprovements.\n\n\\section{The rsync algorithm}\n\nSuppose we have two general purpose computers $\\alpha$ and $\\beta$.\nComputer $\\alpha$ has access to a file $A$ and $\\beta$ has access to\nfile $B$, where $A$ and $B$ are ``similar''.  There is a slow\ncommunications link between $\\alpha$ and $\\beta$.\n\nThe rsync algorithm consists of the following steps:\n\n\\begin{enumerate}\n\\item $\\beta$ splits the file $B$ into a series of non-overlapping\n  fixed-sized blocks of size S bytes\\footnote{We have found that\n  values of S between 500 and 1000 are quite good for most purposes}.\n  The last block may be shorter than $S$ bytes.\n\n\\item For each of these blocks $\\beta$ calculates two checksums:\n  a weak ``rolling'' 32-bit checksum (described below) and a strong\n  128-bit MD4 checksum.\n\n\\item $\\beta$ sends these checksums to $\\alpha$.\n  \n\\item $\\alpha$ searches through $A$ to find all blocks of length $S$\n  bytes (at any offset, not just multiples of $S$) that have the same\n  weak and strong checksum as one of the blocks of $B$. This can be\n  done in a single pass very quickly using a special property of the\n  rolling checksum described below.\n  \n\\item $\\alpha$ sends $\\beta$ a sequence of instructions for\n  constructing a copy of $A$.  Each instruction is either a reference\n  to a block of $B$, or literal data.  Literal data is sent only for\n  those sections of $A$ which did not match any of the blocks of $B$.\n\\end{enumerate}\n\nThe end result is that $\\beta$ gets a copy of $A$, but only the pieces\nof $A$ that are not found in $B$ (plus a small amount of data for\nchecksums and block indexes) are sent over the link. The algorithm\nalso only requires one round trip, which minimises the impact of the\nlink latency.\n\nThe most important details of the algorithm are the rolling checksum\nand the associated multi-alternate search mechanism which allows the\nall-offsets checksum search to proceed very quickly. These will be\ndiscussed in greater detail below.\n\n\\section{Rolling checksum}\n\nThe weak rolling checksum used in the rsync algorithm needs to have\nthe property that it is very cheap to calculate the checksum of a\nbuffer $X_2 .. X_{n+1}$ given the checksum of buffer $X_1 .. X_n$ and\nthe values of the bytes $X_1$ and $X_{n+1}$.\n\nThe weak checksum algorithm we used in our implementation was inspired\nby Mark Adler's adler-32 checksum.  Our checksum is defined by\n$$ a(k,l) = (\\sum_{i=k}^l X_i) \\bmod M $$\n$$ b(k,l) = (\\sum_{i=k}^l (l-i+1)X_i) \\bmod M $$\n$$ s(k,l) = a(k,l) + 2^{16} b(k,l) $$\n\nwhere $s(k,l)$ is the rolling checksum of the bytes $X_k \\ldots X_l$.\nFor simplicity and speed, we use $M = 2^{16}$.  \n\nThe important property of this checksum is that successive values can\nbe computed very efficiently using the recurrence relations\n\n$$ a(k+1,l+1) = (a(k,l) - X_k + X_{l+1}) \\bmod M $$\n$$ b(k+1,l+1) = (b(k,l) - (l-k+1) X_k + a(k+1,l+1)) \\bmod M $$\n\nThus the checksum can be calculated for blocks of length S at all\npossible offsets within a file in a ``rolling'' fashion, with very\nlittle computation at each point.\n\nDespite its simplicity, this checksum was found to be quite adequate as\na first-level check for a match of two file blocks.  We have found in\npractice that the probability of this checksum matching when the\nblocks are not equal is quite low.  This is important because the much\nmore expensive strong checksum must be calculated for each block where\nthe weak checksum matches.\n\n\\section{Checksum searching}\n\nOnce $\\alpha$ has received the list of checksums of the blocks of $B$,\nit must search $A$ for any blocks at any offset that match the\nchecksum of some block of $B$.  The basic strategy is to compute the\n32-bit rolling checksum for a block of length $S$ starting at each\nbyte of $A$ in turn, and for each checksum, search the list for a\nmatch.  To do this our implementation uses a\nsimple 3 level searching scheme.\n\nThe first level uses a 16-bit hash of the 32-bit rolling checksum and\na $2^{16}$ entry hash table.  The list of checksum values (i.e., the\nchecksums from the blocks of $B$) is sorted according to the 16-bit\nhash of the 32-bit rolling checksum.  Each entry in the hash table\npoints to the first element of the list for that hash value, or\ncontains a null value if no element of the list has that hash value.\n\nAt each offset in the file the 32-bit rolling checksum and its 16-bit\nhash are calculated.  If the hash table entry for that hash value is\nnot a null value, the second-level check is invoked.\n\nThe second-level check involves scanning the sorted checksum list\nstarting with the entry pointed to by the hash table entry, looking\nfor an entry whose 32-bit rolling checksum matches the current value.\nThe scan terminates when it reaches an entry whose 16-bit hash\ndiffers.  If this search finds a match, the third-level check is\ninvoked.\n\nThe third-level check involves calculating the strong checksum for the\ncurrent offset in the file and comparing it with the strong checksum\nvalue in the current list entry.  If the two strong checksums match,\nwe assume that we have found a block of $A$ which matches a block of\n$B$.  In fact the blocks could be different, but the probability of\nthis is microscopic, and in practice this is a reasonable assumption.\n\nWhen a match is found, $\\alpha$ sends $\\beta$ the data in $A$ between\nthe current file offset and the end of the previous match, followed by\nthe index of the block in $B$ that matched.  This data is sent\nimmediately a match is found, which allows us to overlap the\ncommunication with further computation.\n\nIf no match is found at a given offset in the file, the rolling\nchecksum is updated to the next offset and the search proceeds.  If a\nmatch is found, the search is restarted at the end of the matched\nblock.  This strategy saves a considerable amount of computation for\nthe common case where the two files are nearly identical.  In\naddition, it would be a simple matter to encode the block indexes as\nruns, for the common case where a portion of $A$ matches a series of\nblocks of $B$ in order.\n\n\\section{Pipelining}\n\nThe above sections describe the process for constructing a copy of one\nfile on a remote system.  If we have a several files to copy, we can\ngain a considerable latency advantage by pipelining the process.\n\nThis involves $\\beta$ initiating two independent processes. One of the\nprocesses generates and sends the checksums to $\\alpha$ while the\nother receives the difference information from $\\alpha$ and\nreconstructs the files. \n\nIf the communications link is buffered then these two processes can\nproceed independently and the link should be kept fully utilised in\nboth directions for most of the time. \n\n\\section{Results}\n\nTo test the algorithm, tar files were created of the Linux kernel\nsources for two versions of the kernel. The two kernel versions were\n1.99.10 and 2.0.0. These tar files are approximately 24MB in size and\nare separated by 5 released patch levels.\n\nOut of the 2441 files in the 1.99.10 release, 291 files had changed in\nthe 2.0.0 release, 19 files had been removed and 25 files had been\nadded.\n\nA ``diff'' of the two tar files using the standard GNU diff utility\nproduced over 32 thousand lines of output totalling 2.1 MB.\n\nThe following table shows the results for rsync between the two files\nwith a varying block size.\\footnote{All the tests in this section were\n  carried out using rsync version 0.5}\n\n\\vspace*{5mm}\n\\begin{tabular}{|l|l|l|l|l|l|l|} \\hline\n{\\bf block} & {\\bf matches} & {\\bf tag}  & {\\bf false}  & {\\bf data} & {\\bf written}  & {\\bf read} \\\\\n{\\bf size}  &               & {\\bf hits} & {\\bf alarms} &            &                &            \\\\ \\hline \\hline\n\n300         & 64247         & 3817434    & 948          & 5312200    & 5629158        & 1632284   \\\\ \\hline\n500         & 46989         & 620013     & 64           & 1091900    & 1283906        & 979384    \\\\ \\hline\n700         & 33255         & 571970     & 22           & 1307800    & 1444346        & 699564    \\\\ \\hline\n900         & 25686         & 525058     & 24           & 1469500    & 1575438        & 544124    \\\\ \\hline\n1100        & 20848         & 496844     & 21           & 1654500    & 1740838        & 445204    \\\\ \\hline\n\\end{tabular}\n\\vspace*{5mm}\n\nIn each case, the CPU time taken was less than the\ntime it takes to run ``diff'' on the two files.\\footnote{The wall\n  clock time was approximately 2 minutes per run on a 50 MHz SPARC 10\n  running SunOS, using rsh over loopback for communication.  GNU diff\n  took about 4 minutes.}\n\nThe columns in the table are as follows:\n\n\\begin{description}\n\\item [block size] The size in bytes of the checksummed blocks.\n\\item [matches] The number of times a block of $B$ was found in $A$.\n\\item [tag hits] The number of times the 16-bit hash of the rolling\n  checksum matched a hash of one of the checksums from $B$.\n\\item [false alarms] The number of times the 32-bit rolling checksum\n  matched but the strong checksum didn't.\n\\item [data] The amount of file data transferred verbatim, in bytes.\n\\item [written] The total number of bytes written by $\\alpha$,\n  including protocol overheads. This is almost all file data.\n\\item [read] The total number of bytes read by $\\alpha$, including\n  protocol overheads. This is almost all checksum information.\n\\end{description}\n\nThe results demonstrate that for block sizes above 300 bytes, only a\nsmall fraction (around 5\\%) of the file was transferred. The amount\ntransferred was also considerably less than the size of the diff file\nthat would have been transferred if the diff/patch method of updating\na remote file was used.\n\nThe checksums themselves took up a considerable amount of space,\nalthough much less than the size of the data transferred in each\ncase. Each pair of checksums consumes 20 bytes: 4 bytes for the\nrolling checksum plus 16 bytes for the 128-bit MD4 checksum.\n\nThe number of false alarms was less than $1/1000$ of the number of\ntrue matches, indicating that the 32-bit rolling checksum is quite\ngood at screening out false matches. \n\nThe number of tag hits indicates that the second level of the\nchecksum search algorithm was invoked about once every 50\ncharacters.  This is quite high because the total number of blocks in\nthe file is a large fraction of the size of the tag hash table. For\nsmaller files we would expect the tag hit rate to be much closer to\nthe number of matches.  For extremely large files, we should probably\nincrease the size of the hash table.\n\nThe next table shows similar results for a much smaller set of files.\nIn this case the files were not packed into a tar file first. Rather,\nrsync was invoked with an option to recursively descend the directory\ntree. The files used were from two source releases of another software\npackage called Samba. The total source code size is 1.7 MB and the\ndiff between the two releases is 4155 lines long totalling 120 kB.\n\n\\vspace*{5mm}\n\\begin{tabular}{|l|l|l|l|l|l|l|} \\hline\n{\\bf block} & {\\bf matches} & {\\bf tag}  & {\\bf false}  & {\\bf data} & {\\bf written}  & {\\bf read} \\\\\n{\\bf size}  &               & {\\bf hits} & {\\bf alarms} &            &                &            \\\\ \\hline \\hline\n\n300         & 3727          & 3899       & 0            & 129775     & 153999         & 83948       \\\\ \\hline\n500         & 2158          & 2325       & 0            & 171574     & 189330         & 50908       \\\\ \\hline\n700         & 1517          & 1649       & 0            & 195024     & 210144         & 36828        \\\\ \\hline\n900         & 1156          & 1281       & 0            & 222847     & 236471         & 29048        \\\\ \\hline\n1100        & 921           & 1049       & 0            & 250073     & 262725         & 23988        \\\\ \\hline\n\\end{tabular}\n\\vspace*{5mm}\n\n\n\\section{Availability}\n\nAn implementation of rsync which provides a convenient interface\nsimilar to the common UNIX command rcp has been written and is\navailable for download from http://rsync.samba.org/\n\n\\end{document}\n"
        },
        {
          "name": "testhelp",
          "type": "tree",
          "content": null
        },
        {
          "name": "testrun.c",
          "type": "blob",
          "size": 1.376953125,
          "content": "/* Run a testsuite script with a timeout. */\n\n#include \"rsync.h\"\n\n#define DEFAULT_TIMEOUT_SECS (5*60)\n#define TIMEOUT_ENV \"TESTRUN_TIMEOUT\"\n\n int main(int argc, char *argv[])\n{\n\tpid_t pid;\n\tchar *timeout_env;\n\tint status, timeout_secs, slept = 0;\n\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Usage: testrun [SHELL_OPTIONS] TESTSUITE_SCRIPT [ARGS]\\n\");\n\t\texit(1);\n\t}\n\n\tif ((timeout_env = getenv(TIMEOUT_ENV)) != NULL)\n\t\ttimeout_secs = atoi(timeout_env);\n\telse\n\t\ttimeout_secs = DEFAULT_TIMEOUT_SECS;\n\n\tif ((pid = fork()) < 0) {\n\t\tfprintf(stderr, \"TESTRUN ERROR: fork failed: %s\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (pid == 0) {\n\t\targv[0] = \"sh\";\n\t\texecvp(argv[0], argv);\n\t\tfprintf(stderr, \"TESTRUN ERROR: failed to exec %s: %s\\n\", argv[0], strerror(errno));\n\t\t_exit(1);\n\t}\n\n\twhile (1) {\n\t\tint ret = waitpid(pid, &status, WNOHANG);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"TESTRUN ERROR: waitpid failed: %s\\n\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tif (slept++ > timeout_secs) {\n\t\t\tfprintf(stderr, \"TESTRUN TIMEOUT: test took over %d seconds.\\n\", timeout_secs);\n\t\t\tif (kill(pid, SIGTERM) < 0)\n\t\t\t\tfprintf(stderr, \"TESTRUN ERROR: failed to kill pid %d: %s\\n\", (int)pid, strerror(errno));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"TESTRUN INFO: killed pid %d\\n\", (int)pid);\n\t\t\texit(1);\n\t\t}\n\t\tsleep(1);\n\t}\n\n\tif (!WIFEXITED(status))\n\t\texit(255);\n\n\treturn WEXITSTATUS(status);\n}\n"
        },
        {
          "name": "testsuite",
          "type": "tree",
          "content": null
        },
        {
          "name": "tls.c",
          "type": "blob",
          "size": 7.962890625,
          "content": "/*\n * Trivial ls for comparing two directories after running an rsync.\n *\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/* The problem with using the system's own ls is that some features\n * have little quirks that make directories look different when for\n * our purposes they're the same -- for example, the BSD braindamage\n * about setting the mode on symlinks based on your current umask.\n *\n * All the filenames must be given on the command line -- tls does not\n * even read directories, let alone recurse.  The typical usage is\n * \"find|sort|xargs tls\".\n *\n * The format is not exactly the same as any particular Unix ls(1).\n *\n * A key requirement for this program is that the output be \"very\n * reproducible.\"  So we mask away information that can accidentally\n * change. */\n\n#include \"rsync.h\"\n#include <popt.h>\n#include \"lib/sysxattrs.h\"\n\n#define PROGRAM \"tls\"\n\n/* These are to make syscall.o shut up. */\nint dry_run = 0;\nint am_root = 0;\nint am_sender = 1;\nint read_only = 1;\nint list_only = 0;\nint link_times = 0;\nint link_owner = 0;\nint nsec_times = 0;\n\n#ifdef SUPPORT_XATTRS\n\n#ifdef HAVE_LINUX_XATTRS\n#define XSTAT_ATTR \"user.rsync.%stat\"\n#else\n#define XSTAT_ATTR \"rsync.%stat\"\n#endif\n\nstatic int stat_xattr(const char *fname, STRUCT_STAT *fst)\n{\n\tunsigned int mode;\n\tint rdev_major, rdev_minor, uid, gid, len;\n\tchar buf[256];\n\n\tif (am_root >= 0 || IS_DEVICE(fst->st_mode) || IS_SPECIAL(fst->st_mode))\n\t\treturn -1;\n\n\tlen = sys_lgetxattr(fname, XSTAT_ATTR, buf, sizeof buf - 1);\n\tif (len >= (int)sizeof buf) {\n\t\tlen = -1;\n\t\terrno = ERANGE;\n\t}\n\tif (len < 0) {\n\t\tif (errno == ENOTSUP || errno == ENOATTR)\n\t\t\treturn -1;\n\t\tif (errno == EPERM && S_ISLNK(fst->st_mode)) {\n\t\t\tfst->st_uid = 0;\n\t\t\tfst->st_gid = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tfprintf(stderr, \"failed to read xattr %s for %s: %s\\n\",\n\t\t\tXSTAT_ATTR, fname, strerror(errno));\n\t\treturn -1;\n\t}\n\tbuf[len] = '\\0';\n\n\tif (sscanf(buf, \"%o %d,%d %d:%d\",\n\t\t   &mode, &rdev_major, &rdev_minor, &uid, &gid) != 5) {\n\t\tfprintf(stderr, \"Corrupt %s xattr attached to %s: \\\"%s\\\"\\n\",\n\t\t\tXSTAT_ATTR, fname, buf);\n\t\texit(1);\n\t}\n\n#if _S_IFLNK != 0120000\n\tif ((mode & (_S_IFMT)) == 0120000)\n\t\tmode = (mode & ~(_S_IFMT)) | _S_IFLNK;\n#endif\n\tfst->st_mode = mode;\n\n\tfst->st_rdev = MAKEDEV(rdev_major, rdev_minor);\n\tfst->st_uid = uid;\n\tfst->st_gid = gid;\n\n\treturn 0;\n}\n\n#endif\n\nstatic int display_atimes = 0;\n#ifdef SUPPORT_CRTIMES\nstatic int display_crtimes = 0;\n#endif\n\nstatic void failed(char const *what, char const *where)\n{\n\tfprintf(stderr, PROGRAM \": %s %s: %s\\n\",\n\t\twhat, where, strerror(errno));\n\texit(1);\n}\n\nstatic void storetime(char *dest, size_t destsize, time_t t, int nsecs)\n{\n\tif (t) {\n\t\tint len;\n\t\tstruct tm *mt = gmtime(&t);\n\n\t\tlen = snprintf(dest, destsize,\n\t\t\t\" %04d-%02d-%02d %02d:%02d:%02d\",\n\t\t\t(int)mt->tm_year + 1900,\n\t\t\t(int)mt->tm_mon + 1,\n\t\t\t(int)mt->tm_mday,\n\t\t\t(int)mt->tm_hour,\n\t\t\t(int)mt->tm_min,\n\t\t\t(int)mt->tm_sec);\n\t\tif (nsecs >= 0 && len >= 0)\n\t\t\tsnprintf(dest + len, destsize - len, \".%09d\", nsecs);\n\t} else {\n\t\tint has_nsecs = nsecs >= 0 ? 1 : 0;\n\t\tint len = MIN(20 + 10*has_nsecs, (int)destsize - 1);\n\t\tmemset(dest, ' ', len);\n\t\tdest[len] = '\\0';\n\t}\n}\n\nstatic void list_file(const char *fname)\n{\n\tSTRUCT_STAT buf;\n#ifdef SUPPORT_CRTIMES\n\ttime_t crtime = 0;\n#endif\n\tchar permbuf[PERMSTRING_SIZE];\n\tchar mtimebuf[50];\n\tchar atimebuf[50];\n\tchar crtimebuf[50];\n\tchar linkbuf[4096];\n\tint nsecs;\n\n\tif (do_lstat(fname, &buf) < 0)\n\t\tfailed(\"stat\", fname);\n#ifdef SUPPORT_CRTIMES\n\tif (display_crtimes && (crtime = get_create_time(fname, &buf)) == 0)\n\t\tfailed(\"get_create_time\", fname);\n#endif\n#ifdef SUPPORT_XATTRS\n\tif (am_root < 0)\n\t\tstat_xattr(fname, &buf);\n#endif\n\n\t/* The size of anything but a regular file is probably not\n\t * worth thinking about. */\n\tif (!S_ISREG(buf.st_mode))\n\t\tbuf.st_size = 0;\n\n\t/* On some BSD platforms the mode bits of a symlink are\n\t * undefined.  Also it tends not to be possible to reset a\n\t * symlink's mtime, so we default to ignoring it too. */\n\tif (S_ISLNK(buf.st_mode)) {\n\t\tint len;\n\t\tbuf.st_mode &= ~0777;\n\t\tif (!link_times)\n\t\t\tbuf.st_mtime = (time_t)0;\n\t\tif (!link_owner)\n\t\t\tbuf.st_uid = buf.st_gid = 0;\n\t\tstrlcpy(linkbuf, \" -> \", sizeof linkbuf);\n\t\t/* const-cast required for silly UNICOS headers */\n\t\tlen = do_readlink((char*)fname, linkbuf+4, sizeof linkbuf - 4);\n\t\tif (len == -1)\n\t\t\tfailed(\"do_readlink\", fname);\n\t\telse\n\t\t\t/* it's not nul-terminated */\n\t\t\tlinkbuf[4+len] = 0;\n\t} else {\n\t\tlinkbuf[0] = '\\0';\n\t}\n\n\tpermstring(permbuf, buf.st_mode);\n#ifdef ST_MTIME_NSEC\n\tif (nsec_times)\n\t\tnsecs = (int)buf.ST_MTIME_NSEC;\n\telse\n#endif\n\t\tnsecs = -1;\n\tstoretime(mtimebuf, sizeof mtimebuf, buf.st_mtime, nsecs);\n\tif (display_atimes)\n\t\tstoretime(atimebuf, sizeof atimebuf, S_ISDIR(buf.st_mode) ? 0 : buf.st_atime, -1);\n\telse\n\t\tatimebuf[0] = '\\0';\n#ifdef SUPPORT_CRTIMES\n\tif (display_crtimes)\n\t\tstoretime(crtimebuf, sizeof crtimebuf, crtime, -1);\n\telse\n#endif\n\t\tcrtimebuf[0] = '\\0';\n\n\t/* TODO: Perhaps escape special characters in fname? */\n\tprintf(\"%s \", permbuf);\n\n\tif (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) {\n\t\tprintf(\"%5ld,%6ld\", (long)major(buf.st_rdev), (long)minor(buf.st_rdev));\n\t} else\n\t\tprintf(\"%15s\", do_big_num(buf.st_size, 1, NULL));\n\n\tprintf(\" %6ld.%-6ld %6ld%s%s%s %s%s\\n\",\n\t       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,\n\t       mtimebuf, atimebuf, crtimebuf, fname, linkbuf);\n}\n\nstatic struct poptOption long_options[] = {\n  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */\n  {\"atimes\",          'U', POPT_ARG_NONE,   &display_atimes, 0, 0, 0},\n#ifdef SUPPORT_CRTIMES\n  {\"crtimes\",         'N', POPT_ARG_NONE,   &display_crtimes, 0, 0, 0},\n#endif\n  {\"link-times\",      'l', POPT_ARG_NONE,   &link_times, 0, 0, 0 },\n  {\"link-owner\",      'L', POPT_ARG_NONE,   &link_owner, 0, 0, 0 },\n#ifdef SUPPORT_XATTRS\n  {\"fake-super\",      'f', POPT_ARG_VAL,    &am_root, -1, 0, 0 },\n#endif\n#ifdef ST_MTIME_NSEC\n  {\"nsec\",            's', POPT_ARG_NONE,   &nsec_times, 0, 0, 0 },\n#endif\n  {\"help\",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },\n  {0,0,0,0,0,0,0}\n};\n\nstatic void NORETURN tls_usage(int ret)\n{\n  FILE *F = ret ? stderr : stdout;\n  fprintf(F,\"usage: \" PROGRAM \" [OPTIONS] FILE ...\\n\");\n  fprintf(F,\"Trivial file listing program for portably checking rsync\\n\");\n  fprintf(F,\"\\nOptions:\\n\");\n  fprintf(F,\" -U, --atimes                display access (last-used) times\\n\");\n#ifdef SUPPORT_CRTIMES\n  fprintf(F,\" -N, --crtimes               display create times (newness)\\n\");\n#endif\n  fprintf(F,\" -l, --link-times            display the time on a symlink\\n\");\n  fprintf(F,\" -L, --link-owner            display the owner+group on a symlink\\n\");\n#ifdef SUPPORT_XATTRS\n  fprintf(F,\" -f, --fake-super            display attributes including fake-super xattrs\\n\");\n#endif\n  fprintf(F,\" -h, --help                  show this help\\n\");\n  exit(ret);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tpoptContext pc;\n\tconst char **extra_args;\n\tint opt;\n\n\tpc = poptGetContext(PROGRAM, argc, (const char **)argv, long_options, 0);\n\twhile ((opt = poptGetNextOpt(pc)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\ttls_usage(0);\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s: %s\\n\",\n\t\t\t\tpoptBadOption(pc, POPT_BADOPTION_NOALIAS),\n\t\t\t\tpoptStrerror(opt));\n\t\t\ttls_usage(1);\n\t\t}\n\t}\n\n\textra_args = poptGetArgs(pc);\n\tif (!extra_args || *extra_args == NULL)\n\t\ttls_usage(1);\n\n\tfor (; *extra_args; extra_args++)\n\t\tlist_file(*extra_args);\n\tpoptFreeContext(pc);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "token.c",
          "type": "blob",
          "size": 26.2197265625,
          "content": "/*\n * Routines used by the file-transfer code.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include <zlib.h>\n#ifdef SUPPORT_ZSTD\n#include <zstd.h>\n#endif\n#ifdef SUPPORT_LZ4\n#include <lz4.h>\n#endif\n\nextern int do_compression;\nextern int protocol_version;\nextern int module_id;\nextern int do_compression_level;\nextern char *skip_compress;\n\n#ifndef Z_INSERT_ONLY\n#define Z_INSERT_ONLY Z_SYNC_FLUSH\n#endif\n\nstatic int skip_compression_level; /* The least possible compressing for handling skip-compress files. */\nstatic int per_file_default_level; /* The default level that each new file gets prior to checking its suffix. */\n\nstruct suffix_tree {\n\tstruct suffix_tree *sibling;\n\tstruct suffix_tree *child;\n\tchar letter, word_end;\n};\n\nstatic char *match_list;\nstatic struct suffix_tree *suftree;\n\nvoid init_compression_level(void)\n{\n\tint min_level, max_level, def_level, off_level;\n\n\tswitch (do_compression) {\n\tcase CPRES_NONE:\n\t\treturn;\n\tcase CPRES_ZLIB:\n\tcase CPRES_ZLIBX:\n\t\tmin_level = 1;\n\t\tmax_level = Z_BEST_COMPRESSION;\n\t\tdef_level = 6; /* Z_DEFAULT_COMPRESSION is -1, so set it to the real default */\n\t\toff_level = skip_compression_level = Z_NO_COMPRESSION;\n\t\tif (do_compression_level == Z_DEFAULT_COMPRESSION)\n\t\t\tdo_compression_level = def_level;\n\t\tbreak;\n#ifdef SUPPORT_ZSTD\n\tcase CPRES_ZSTD:\n\t\tmin_level = skip_compression_level = ZSTD_minCLevel();\n\t\tmax_level = ZSTD_maxCLevel();\n\t\tdef_level = ZSTD_CLEVEL_DEFAULT;\n\t\toff_level = CLVL_NOT_SPECIFIED;\n\t\tif (do_compression_level == 0)\n\t\t\tdo_compression_level = def_level;\n\t\tbreak;\n#endif\n#ifdef SUPPORT_LZ4\n\tcase CPRES_LZ4:\n\t\tmin_level = skip_compression_level = 0;\n\t\tmax_level = 0;\n\t\tdef_level = 0;\n\t\toff_level = CLVL_NOT_SPECIFIED;\n\t\tbreak;\n#endif\n\tdefault: /* paranoia to prevent missing case values */\n\t\tNOISY_DEATH(\"Unknown do_compression value\");\n\t}\n\n\tif (do_compression_level == CLVL_NOT_SPECIFIED)\n\t\tdo_compression_level = def_level;\n\telse if (do_compression_level == off_level) {\n\t\tdo_compression = CPRES_NONE;\n\t\treturn;\n\t}\n\n\t/* We don't bother with any errors or warnings -- just make sure that the values are valid. */\n\tif (do_compression_level < min_level)\n\t\tdo_compression_level = min_level;\n\telse if (do_compression_level > max_level)\n\t\tdo_compression_level = max_level;\n}\n\nstatic void add_suffix(struct suffix_tree **prior, char ltr, const char *str)\n{\n\tstruct suffix_tree *node, *newnode;\n\n\tif (ltr == '[') {\n\t\tconst char *after = strchr(str, ']');\n\t\t/* Treat \"[foo\" and \"[]\" as having a literal '['. */\n\t\tif (after && after++ != str+1) {\n\t\t\twhile ((ltr = *str++) != ']')\n\t\t\t\tadd_suffix(prior, ltr, after);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (node = *prior; node; prior = &node->sibling, node = node->sibling) {\n\t\tif (node->letter == ltr) {\n\t\t\tif (*str)\n\t\t\t\tadd_suffix(&node->child, *str, str+1);\n\t\t\telse\n\t\t\t\tnode->word_end = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (node->letter > ltr)\n\t\t\tbreak;\n\t}\n\tnewnode = new(struct suffix_tree);\n\tnewnode->sibling = node;\n\tnewnode->child = NULL;\n\tnewnode->letter = ltr;\n\t*prior = newnode;\n\tif (*str) {\n\t\tadd_suffix(&newnode->child, *str, str+1);\n\t\tnewnode->word_end = 0;\n\t} else\n\t\tnewnode->word_end = 1;\n}\n\nstatic void add_nocompress_suffixes(const char *str)\n{\n\tchar *buf, *t;\n\tconst char *f = str;\n\n\tbuf = new_array(char, strlen(f) + 1);\n\n\twhile (*f) {\n\t\tif (*f == '/') {\n\t\t\tf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tt = buf;\n\t\tdo {\n\t\t\tif (isUpper(f))\n\t\t\t\t*t++ = toLower(f);\n\t\t\telse\n\t\t\t\t*t++ = *f;\n\t\t} while (*++f != '/' && *f);\n\t\t*t++ = '\\0';\n\n\t\tadd_suffix(&suftree, *buf, buf+1);\n\t}\n\n\tfree(buf);\n}\n\nstatic void init_set_compression(void)\n{\n\tconst char *f;\n\tchar *t, *start;\n\n\tif (skip_compress)\n\t\tadd_nocompress_suffixes(skip_compress);\n\n\t/* A non-daemon transfer skips the default suffix list if the\n\t * user specified --skip-compress. */\n\tif (skip_compress && module_id < 0)\n\t\tf = \"\";\n\telse\n\t\tf = lp_dont_compress(module_id);\n\n\tmatch_list = t = new_array(char, strlen(f) + 2);\n\n\tper_file_default_level = do_compression_level;\n\n\twhile (*f) {\n\t\tif (*f == ' ') {\n\t\t\tf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = t;\n\t\tdo {\n\t\t\tif (isUpper(f))\n\t\t\t\t*t++ = toLower(f);\n\t\t\telse\n\t\t\t\t*t++ = *f;\n\t\t} while (*++f != ' ' && *f);\n\t\t*t++ = '\\0';\n\n\t\tif (t - start == 1+1 && *start == '*') {\n\t\t\t/* Optimize a match-string of \"*\". */\n\t\t\t*match_list = '\\0';\n\t\t\tsuftree = NULL;\n\t\t\tper_file_default_level = skip_compression_level;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Move *.foo items into the stuffix tree. */\n\t\tif (*start == '*' && start[1] == '.' && start[2]\n\t\t && !strpbrk(start+2, \".?*\")) {\n\t\t\tadd_suffix(&suftree, start[2], start+3);\n\t\t\tt = start;\n\t\t}\n\t}\n\t*t++ = '\\0';\n}\n\n/* determine the compression level based on a wildcard filename list */\nvoid set_compression(const char *fname)\n{\n#if 0 /* No compression algorithms currently allow mid-stream changing of the level. */\n\tconst struct suffix_tree *node;\n\tconst char *s;\n\tchar ltr;\n#endif\n\n\tif (!do_compression)\n\t\treturn;\n\n\tif (!match_list)\n\t\tinit_set_compression();\n\n#if 0\n\tcompression_level = per_file_default_level;\n\n\tif (!*match_list && !suftree)\n\t\treturn;\n\n\tif ((s = strrchr(fname, '/')) != NULL)\n\t\tfname = s + 1;\n\n\tfor (s = match_list; *s; s += strlen(s) + 1) {\n\t\tif (iwildmatch(s, fname)) {\n\t\t\tcompression_level = skip_compression_level;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!(node = suftree) || !(s = strrchr(fname, '.'))\n\t || s == fname || !(ltr = *++s))\n\t\treturn;\n\n\twhile (1) {\n\t\tif (isUpper(&ltr))\n\t\t\tltr = toLower(&ltr);\n\t\twhile (node->letter != ltr) {\n\t\t\tif (node->letter > ltr)\n\t\t\t\treturn;\n\t\t\tif (!(node = node->sibling))\n\t\t\t\treturn;\n\t\t}\n\t\tif ((ltr = *++s) == '\\0') {\n\t\t\tif (node->word_end)\n\t\t\t\tcompression_level = skip_compression_level;\n\t\t\treturn;\n\t\t}\n\t\tif (!(node = node->child))\n\t\t\treturn;\n\t}\n#else\n\t(void)fname;\n#endif\n}\n\n/* non-compressing recv token */\nstatic int32 simple_recv_token(int f, char **data)\n{\n\tstatic int32 residue;\n\tstatic char *buf;\n\tint32 n;\n\n\tif (!buf)\n\t\tbuf = new_array(char, CHUNK_SIZE);\n\n\tif (residue == 0) {\n\t\tint32 i = read_int(f);\n\t\tif (i <= 0)\n\t\t\treturn i;\n\t\tresidue = i;\n\t}\n\n\t*data = buf;\n\tn = MIN(CHUNK_SIZE,residue);\n\tresidue -= n;\n\tread_buf(f,buf,n);\n\treturn n;\n}\n\n/* non-compressing send token */\nstatic void simple_send_token(int f, int32 token, struct map_struct *buf, OFF_T offset, int32 n)\n{\n\tif (n > 0) {\n\t\tint32 len = 0;\n\t\twhile (len < n) {\n\t\t\tint32 n1 = MIN(CHUNK_SIZE, n-len);\n\t\t\twrite_int(f, n1);\n\t\t\twrite_buf(f, map_ptr(buf, offset+len, n1), n1);\n\t\t\tlen += n1;\n\t\t}\n\t}\n\t/* a -2 token means to send data only and no token */\n\tif (token != -2)\n\t\twrite_int(f, -(token+1));\n}\n\n/* Flag bytes in compressed stream are encoded as follows: */\n#define END_FLAG\t0\t/* that's all folks */\n#define TOKEN_LONG\t0x20\t/* followed by 32-bit token number */\n#define TOKENRUN_LONG\t0x21\t/* ditto with 16-bit run count */\n#define DEFLATED_DATA\t0x40\t/* + 6-bit high len, then low len byte */\n#define TOKEN_REL\t0x80\t/* + 6-bit relative token number */\n#define TOKENRUN_REL\t0xc0\t/* ditto with 16-bit run count */\n\n#define MAX_DATA_COUNT\t16383\t/* fit 14 bit count into 2 bytes with flags */\n\n/* zlib.h says that if we want to be able to compress something in a single\n * call, avail_out must be at least 0.1% larger than avail_in plus 12 bytes.\n * We'll add in 0.1%+16, just to be safe (and we'll avoid floating point,\n * to ensure that this is a compile-time value). */\n#define AVAIL_OUT_SIZE(avail_in_size) ((avail_in_size)*1001/1000+16)\n\n/* For coding runs of tokens */\nstatic int32 last_token = -1;\nstatic int32 run_start;\nstatic int32 last_run_end;\n\n/* Deflation state */\nstatic z_stream tx_strm;\n\n/* Output buffer */\nstatic char *obuf;\n\n/* We want obuf to be able to hold both MAX_DATA_COUNT+2 bytes as well as\n * AVAIL_OUT_SIZE(CHUNK_SIZE) bytes, so make sure that it's large enough. */\n#if MAX_DATA_COUNT+2 > AVAIL_OUT_SIZE(CHUNK_SIZE)\n#define OBUF_SIZE\t(MAX_DATA_COUNT+2)\n#else\n#define OBUF_SIZE\tAVAIL_OUT_SIZE(CHUNK_SIZE)\n#endif\n\n/* Send a deflated token */\nstatic void\nsend_deflated_token(int f, int32 token, struct map_struct *buf, OFF_T offset, int32 nb, int32 toklen)\n{\n\tstatic int init_done, flush_pending;\n\tint32 n, r;\n\n\tif (last_token == -1) {\n\t\t/* initialization */\n\t\tif (!init_done) {\n\t\t\ttx_strm.next_in = NULL;\n\t\t\ttx_strm.zalloc = NULL;\n\t\t\ttx_strm.zfree = NULL;\n\t\t\tif (deflateInit2(&tx_strm, per_file_default_level,\n\t\t\t\t\t Z_DEFLATED, -15, 8,\n\t\t\t\t\t Z_DEFAULT_STRATEGY) != Z_OK) {\n\t\t\t\trprintf(FERROR, \"compression init failed\\n\");\n\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t}\n\t\t\tobuf = new_array(char, OBUF_SIZE);\n\t\t\tinit_done = 1;\n\t\t} else\n\t\t\tdeflateReset(&tx_strm);\n\t\tlast_run_end = 0;\n\t\trun_start = token;\n\t\tflush_pending = 0;\n\t} else if (last_token == -2) {\n\t\trun_start = token;\n\t} else if (nb != 0 || token != last_token + 1 || token >= run_start + 65536) {\n\t\t/* output previous run */\n\t\tr = run_start - last_run_end;\n\t\tn = last_token - run_start;\n\t\tif (r >= 0 && r <= 63) {\n\t\t\twrite_byte(f, (n==0? TOKEN_REL: TOKENRUN_REL) + r);\n\t\t} else {\n\t\t\twrite_byte(f, (n==0? TOKEN_LONG: TOKENRUN_LONG));\n\t\t\twrite_int(f, run_start);\n\t\t}\n\t\tif (n != 0) {\n\t\t\twrite_byte(f, n);\n\t\t\twrite_byte(f, n >> 8);\n\t\t}\n\t\tlast_run_end = last_token;\n\t\trun_start = token;\n\t}\n\n\tlast_token = token;\n\n\tif (nb != 0 || flush_pending) {\n\t\t/* deflate the data starting at offset */\n\t\tint flush = Z_NO_FLUSH;\n\t\ttx_strm.avail_in = 0;\n\t\ttx_strm.avail_out = 0;\n\t\tdo {\n\t\t\tif (tx_strm.avail_in == 0 && nb != 0) {\n\t\t\t\t/* give it some more input */\n\t\t\t\tn = MIN(nb, CHUNK_SIZE);\n\t\t\t\ttx_strm.next_in = (Bytef *)\n\t\t\t\t\tmap_ptr(buf, offset, n);\n\t\t\t\ttx_strm.avail_in = n;\n\t\t\t\tnb -= n;\n\t\t\t\toffset += n;\n\t\t\t}\n\t\t\tif (tx_strm.avail_out == 0) {\n\t\t\t\ttx_strm.next_out = (Bytef *)(obuf + 2);\n\t\t\t\ttx_strm.avail_out = MAX_DATA_COUNT;\n\t\t\t\tif (flush != Z_NO_FLUSH) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We left the last 4 bytes in the\n\t\t\t\t\t * buffer, in case they are the\n\t\t\t\t\t * last 4.  Move them to the front.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy(tx_strm.next_out, obuf+MAX_DATA_COUNT-2, 4);\n\t\t\t\t\ttx_strm.next_out += 4;\n\t\t\t\t\ttx_strm.avail_out -= 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nb == 0 && token != -2)\n\t\t\t\tflush = Z_SYNC_FLUSH;\n\t\t\tr = deflate(&tx_strm, flush);\n\t\t\tif (r != Z_OK) {\n\t\t\t\trprintf(FERROR, \"deflate returned %d\\n\", r);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t\tif (nb == 0 || tx_strm.avail_out == 0) {\n\t\t\t\tn = MAX_DATA_COUNT - tx_strm.avail_out;\n\t\t\t\tif (flush != Z_NO_FLUSH) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We have to trim off the last 4\n\t\t\t\t\t * bytes of output when flushing\n\t\t\t\t\t * (they are just 0, 0, ff, ff).\n\t\t\t\t\t */\n\t\t\t\t\tn -= 4;\n\t\t\t\t}\n\t\t\t\tif (n > 0) {\n\t\t\t\t\tobuf[0] = DEFLATED_DATA + (n >> 8);\n\t\t\t\t\tobuf[1] = n;\n\t\t\t\t\twrite_buf(f, obuf, n+2);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (nb != 0 || tx_strm.avail_out == 0);\n\t\tflush_pending = token == -2;\n\t}\n\n\tif (token == -1) {\n\t\t/* end of file - clean up */\n\t\twrite_byte(f, END_FLAG);\n\t} else if (token != -2 && do_compression == CPRES_ZLIB) {\n\t\t/* Add the data in the current block to the compressor's\n\t\t * history and hash table. */\n\t\tdo {\n\t\t\t/* Break up long sections in the same way that\n\t\t\t * see_deflate_token() does. */\n\t\t\tint32 n1 = toklen > 0xffff ? 0xffff : toklen;\n\t\t\ttoklen -= n1;\n\t\t\ttx_strm.next_in = (Bytef *)map_ptr(buf, offset, n1);\n\t\t\ttx_strm.avail_in = n1;\n\t\t\tif (protocol_version >= 31) /* Newer protocols avoid a data-duplicating bug */\n\t\t\t\toffset += n1;\n\t\t\ttx_strm.next_out = (Bytef *) obuf;\n\t\t\ttx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);\n\t\t\tr = deflate(&tx_strm, Z_INSERT_ONLY);\n\t\t\tif (r != Z_OK || tx_strm.avail_in != 0) {\n\t\t\t\trprintf(FERROR, \"deflate on token returned %d (%d bytes left)\\n\",\n\t\t\t\t\tr, tx_strm.avail_in);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t} while (toklen > 0);\n\t}\n}\n\n/* tells us what the receiver is in the middle of doing */\nstatic enum { r_init, r_idle, r_running, r_inflating, r_inflated } recv_state;\n\n/* for inflating stuff */\nstatic z_stream rx_strm;\nstatic char *cbuf;\nstatic char *dbuf;\n\n/* for decoding runs of tokens */\nstatic int32 rx_token;\nstatic int32 rx_run;\n\n/* Receive a deflated token and inflate it */\nstatic int32 recv_deflated_token(int f, char **data)\n{\n\tstatic int init_done;\n\tstatic int32 saved_flag;\n\tint32 n, flag;\n\tint r;\n\n\tfor (;;) {\n\t\tswitch (recv_state) {\n\t\tcase r_init:\n\t\t\tif (!init_done) {\n\t\t\t\trx_strm.next_out = NULL;\n\t\t\t\trx_strm.zalloc = NULL;\n\t\t\t\trx_strm.zfree = NULL;\n\t\t\t\tif (inflateInit2(&rx_strm, -15) != Z_OK) {\n\t\t\t\t\trprintf(FERROR, \"inflate init failed\\n\");\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t}\n\t\t\t\tcbuf = new_array(char, MAX_DATA_COUNT);\n\t\t\t\tdbuf = new_array(char, AVAIL_OUT_SIZE(CHUNK_SIZE));\n\t\t\t\tinit_done = 1;\n\t\t\t} else {\n\t\t\t\tinflateReset(&rx_strm);\n\t\t\t}\n\t\t\trecv_state = r_idle;\n\t\t\trx_token = 0;\n\t\t\tbreak;\n\n\t\tcase r_idle:\n\t\tcase r_inflated:\n\t\t\tif (saved_flag) {\n\t\t\t\tflag = saved_flag & 0xff;\n\t\t\t\tsaved_flag = 0;\n\t\t\t} else\n\t\t\t\tflag = read_byte(f);\n\t\t\tif ((flag & 0xC0) == DEFLATED_DATA) {\n\t\t\t\tn = ((flag & 0x3f) << 8) + read_byte(f);\n\t\t\t\tread_buf(f, cbuf, n);\n\t\t\t\trx_strm.next_in = (Bytef *)cbuf;\n\t\t\t\trx_strm.avail_in = n;\n\t\t\t\trecv_state = r_inflating;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (recv_state == r_inflated) {\n\t\t\t\t/* check previous inflated stuff ended correctly */\n\t\t\t\trx_strm.avail_in = 0;\n\t\t\t\trx_strm.next_out = (Bytef *)dbuf;\n\t\t\t\trx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);\n\t\t\t\tr = inflate(&rx_strm, Z_SYNC_FLUSH);\n\t\t\t\tn = AVAIL_OUT_SIZE(CHUNK_SIZE) - rx_strm.avail_out;\n\t\t\t\t/*\n\t\t\t\t * Z_BUF_ERROR just means no progress was\n\t\t\t\t * made, i.e. the decompressor didn't have\n\t\t\t\t * any pending output for us.\n\t\t\t\t */\n\t\t\t\tif (r != Z_OK && r != Z_BUF_ERROR) {\n\t\t\t\t\trprintf(FERROR, \"inflate flush returned %d (%d bytes)\\n\",\n\t\t\t\t\t\tr, n);\n\t\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t\t}\n\t\t\t\tif (n != 0 && r != Z_BUF_ERROR) {\n\t\t\t\t\t/* have to return some more data and\n\t\t\t\t\t   save the flag for later. */\n\t\t\t\t\tsaved_flag = flag + 0x10000;\n\t\t\t\t\t*data = dbuf;\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * At this point the decompressor should\n\t\t\t\t * be expecting to see the 0, 0, ff, ff bytes.\n\t\t\t\t */\n\t\t\t\tif (!inflateSyncPoint(&rx_strm)) {\n\t\t\t\t\trprintf(FERROR, \"decompressor lost sync!\\n\");\n\t\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t\t}\n\t\t\t\trx_strm.avail_in = 4;\n\t\t\t\trx_strm.next_in = (Bytef *)cbuf;\n\t\t\t\tcbuf[0] = cbuf[1] = 0;\n\t\t\t\tcbuf[2] = cbuf[3] = (char)0xff;\n\t\t\t\tinflate(&rx_strm, Z_SYNC_FLUSH);\n\t\t\t\trecv_state = r_idle;\n\t\t\t}\n\t\t\tif (flag == END_FLAG) {\n\t\t\t\t/* that's all folks */\n\t\t\t\trecv_state = r_init;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* here we have a token of some kind */\n\t\t\tif (flag & TOKEN_REL) {\n\t\t\t\trx_token += flag & 0x3f;\n\t\t\t\tflag >>= 6;\n\t\t\t} else\n\t\t\t\trx_token = read_int(f);\n\t\t\tif (flag & 1) {\n\t\t\t\trx_run = read_byte(f);\n\t\t\t\trx_run += read_byte(f) << 8;\n\t\t\t\trecv_state = r_running;\n\t\t\t}\n\t\t\treturn -1 - rx_token;\n\n\t\tcase r_inflating:\n\t\t\trx_strm.next_out = (Bytef *)dbuf;\n\t\t\trx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);\n\t\t\tr = inflate(&rx_strm, Z_NO_FLUSH);\n\t\t\tn = AVAIL_OUT_SIZE(CHUNK_SIZE) - rx_strm.avail_out;\n\t\t\tif (r != Z_OK) {\n\t\t\t\trprintf(FERROR, \"inflate returned %d (%d bytes)\\n\", r, n);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t\tif (rx_strm.avail_in == 0)\n\t\t\t\trecv_state = r_inflated;\n\t\t\tif (n != 0) {\n\t\t\t\t*data = dbuf;\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase r_running:\n\t\t\t++rx_token;\n\t\t\tif (--rx_run == 0)\n\t\t\t\trecv_state = r_idle;\n\t\t\treturn -1 - rx_token;\n\t\t}\n\t}\n}\n\n/*\n * put the data corresponding to a token that we've just returned\n * from recv_deflated_token into the decompressor's history buffer.\n */\nstatic void see_deflate_token(char *buf, int32 len)\n{\n\tint r;\n\tint32 blklen;\n\tunsigned char hdr[5];\n\n\trx_strm.avail_in = 0;\n\tblklen = 0;\n\thdr[0] = 0;\n\tdo {\n\t\tif (rx_strm.avail_in == 0 && len != 0) {\n\t\t\tif (blklen == 0) {\n\t\t\t\t/* Give it a fake stored-block header. */\n\t\t\t\trx_strm.next_in = (Bytef *)hdr;\n\t\t\t\trx_strm.avail_in = 5;\n\t\t\t\tblklen = len;\n\t\t\t\tif (blklen > 0xffff)\n\t\t\t\t\tblklen = 0xffff;\n\t\t\t\thdr[1] = blklen;\n\t\t\t\thdr[2] = blklen >> 8;\n\t\t\t\thdr[3] = ~hdr[1];\n\t\t\t\thdr[4] = ~hdr[2];\n\t\t\t} else {\n\t\t\t\trx_strm.next_in = (Bytef *)buf;\n\t\t\t\trx_strm.avail_in = blklen;\n\t\t\t\tif (protocol_version >= 31) /* Newer protocols avoid a data-duplicating bug */\n\t\t\t\t\tbuf += blklen;\n\t\t\t\tlen -= blklen;\n\t\t\t\tblklen = 0;\n\t\t\t}\n\t\t}\n\t\trx_strm.next_out = (Bytef *)dbuf;\n\t\trx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);\n\t\tr = inflate(&rx_strm, Z_SYNC_FLUSH);\n\t\tif (r != Z_OK && r != Z_BUF_ERROR) {\n\t\t\trprintf(FERROR, \"inflate (token) returned %d\\n\", r);\n\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t}\n\t} while (len || rx_strm.avail_out == 0);\n}\n\n#ifdef SUPPORT_ZSTD\n\nstatic ZSTD_inBuffer zstd_in_buff;\nstatic ZSTD_outBuffer zstd_out_buff;\nstatic ZSTD_CCtx *zstd_cctx;\n\nstatic void send_zstd_token(int f, int32 token, struct map_struct *buf, OFF_T offset, int32 nb)\n{\n\tstatic int comp_init_done, flush_pending;\n\tZSTD_EndDirective flush = ZSTD_e_continue;\n\tint32 n, r;\n\n\t/* initialization */\n\tif (!comp_init_done) {\n\t\tzstd_cctx = ZSTD_createCCtx();\n\t\tif (!zstd_cctx) {\n\t\t\trprintf(FERROR, \"compression init failed\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tobuf = new_array(char, OBUF_SIZE);\n\n\t\tZSTD_CCtx_setParameter(zstd_cctx, ZSTD_c_compressionLevel, do_compression_level);\n\t\tzstd_out_buff.dst = obuf + 2;\n\n\t\tcomp_init_done = 1;\n\t}\n\n\tif (last_token == -1) {\n\t\tlast_run_end = 0;\n\t\trun_start = token;\n\t\tflush_pending = 0;\n\t} else if (last_token == -2) {\n\t\trun_start = token;\n\t} else if (nb != 0 || token != last_token + 1 || token >= run_start + 65536) {\n\t\t/* output previous run */\n\t\tr = run_start - last_run_end;\n\t\tn = last_token - run_start;\n\n\t\tif (r >= 0 && r <= 63) {\n\t\t\twrite_byte(f, (n==0? TOKEN_REL: TOKENRUN_REL) + r);\n\t\t} else {\n\t\t\twrite_byte(f, (n==0? TOKEN_LONG: TOKENRUN_LONG));\n\t\t\twrite_int(f, run_start);\n\t\t}\n\t\tif (n != 0) {\n\t\t\twrite_byte(f, n);\n\t\t\twrite_byte(f, n >> 8);\n\t\t}\n\t\tlast_run_end = last_token;\n\t\trun_start = token;\n\t}\n\n\tlast_token = token;\n\n\tif (nb || flush_pending) {\n\n\t\tzstd_in_buff.src = map_ptr(buf, offset, nb);\n\t\tzstd_in_buff.size = nb;\n\t\tzstd_in_buff.pos = 0;\n\n\t\tdo {\n\t\t\tif (zstd_out_buff.size == 0) {\n\t\t\t\tzstd_out_buff.size = MAX_DATA_COUNT;\n\t\t\t\tzstd_out_buff.pos = 0;\n\t\t\t}\n\n\t\t\t/* File ended, flush */\n\t\t\tif (token != -2)\n\t\t\t\tflush = ZSTD_e_flush;\n\n\t\t\tr = ZSTD_compressStream2(zstd_cctx, &zstd_out_buff, &zstd_in_buff, flush);\n\t\t\tif (ZSTD_isError(r)) {\n\t\t\t\trprintf(FERROR, \"ZSTD_compressStream returned %d\\n\", r);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Nothing is sent if the buffer isn't full so avoid smaller\n\t\t\t * transfers. If a file is finished then we flush the internal\n\t\t\t * state and send a smaller buffer so that the remote side can\n\t\t\t * finish the file.\n\t\t\t */\n\t\t\tif (zstd_out_buff.pos == zstd_out_buff.size || flush == ZSTD_e_flush) {\n\t\t\t\tn = zstd_out_buff.pos;\n\n\t\t\t\tobuf[0] = DEFLATED_DATA + (n >> 8);\n\t\t\t\tobuf[1] = n;\n\t\t\t\twrite_buf(f, obuf, n+2);\n\n\t\t\t\tzstd_out_buff.size = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Loop while the input buffer isn't full consumed or the\n\t\t\t * internal state isn't fully flushed.\n\t\t\t */\n\t\t} while (zstd_in_buff.pos < zstd_in_buff.size || r > 0);\n\t\tflush_pending = token == -2;\n\t}\n\n\tif (token == -1) {\n\t\t/* end of file - clean up */\n\t\twrite_byte(f, END_FLAG);\n\t}\n}\n\nstatic ZSTD_DCtx *zstd_dctx;\n\nstatic int32 recv_zstd_token(int f, char **data)\n{\n\tstatic int decomp_init_done;\n\tstatic int out_buffer_size;\n\tint32 n, flag;\n\tint r;\n\n\tif (!decomp_init_done) {\n\t\tzstd_dctx = ZSTD_createDCtx();\n\t\tif (!zstd_dctx) {\n\t\t\trprintf(FERROR, \"ZSTD_createDStream failed\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\t/* Output buffer fits two decompressed blocks */\n\t\tout_buffer_size = ZSTD_DStreamOutSize() * 2;\n\t\tcbuf = new_array(char, MAX_DATA_COUNT);\n\t\tdbuf = new_array(char, out_buffer_size);\n\n\t\tzstd_in_buff.src = cbuf;\n\t\tzstd_out_buff.dst = dbuf;\n\n\t\tdecomp_init_done = 1;\n\t}\n\n\tfor (;;) {\n\t\tswitch (recv_state) {\n\t\tcase r_init:\n\t\t\trecv_state = r_idle;\n\t\t\trx_token = 0;\n\t\t\tbreak;\n\n\t\tcase r_idle:\n\t\t\tflag = read_byte(f);\n\t\t\tif ((flag & 0xC0) == DEFLATED_DATA) {\n\t\t\t\tn = ((flag & 0x3f) << 8) + read_byte(f);\n\t\t\t\tread_buf(f, cbuf, n);\n\n\t\t\t\tzstd_in_buff.size = n;\n\t\t\t\tzstd_in_buff.pos = 0;\n\n\t\t\t\trecv_state = r_inflating;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flag == END_FLAG) {\n\t\t\t\t/* that's all folks */\n\t\t\t\trecv_state = r_init;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* here we have a token of some kind */\n\t\t\tif (flag & TOKEN_REL) {\n\t\t\t\trx_token += flag & 0x3f;\n\t\t\t\tflag >>= 6;\n\t\t\t} else\n\t\t\t\trx_token = read_int(f);\n\t\t\tif (flag & 1) {\n\t\t\t\trx_run = read_byte(f);\n\t\t\t\trx_run += read_byte(f) << 8;\n\t\t\t\trecv_state = r_running;\n\t\t\t}\n\t\t\treturn -1 - rx_token;\n\n\t\tcase r_inflated: /* zstd doesn't get into this state */\n\t\t\tbreak;\n\n\t\tcase r_inflating:\n\t\t\tzstd_out_buff.size = out_buffer_size;\n\t\t\tzstd_out_buff.pos = 0;\n\n\t\t\tr = ZSTD_decompressStream(zstd_dctx, &zstd_out_buff, &zstd_in_buff);\n\t\t\tn = zstd_out_buff.pos;\n\t\t\tif (ZSTD_isError(r)) {\n\t\t\t\trprintf(FERROR, \"ZSTD decomp returned %d (%d bytes)\\n\", r, n);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the input buffer is fully consumed and the output\n\t\t\t * buffer is not full then next step is to read more\n\t\t\t * data.\n\t\t\t */\n\t\t\tif (zstd_in_buff.size == zstd_in_buff.pos && n < out_buffer_size)\n\t\t\t\trecv_state = r_idle;\n\n\t\t\tif (n != 0) {\n\t\t\t\t*data = dbuf;\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase r_running:\n\t\t\t++rx_token;\n\t\t\tif (--rx_run == 0)\n\t\t\t\trecv_state = r_idle;\n\t\t\treturn -1 - rx_token;\n\t\t}\n\t}\n}\n#endif /* SUPPORT_ZSTD */\n\n#ifdef SUPPORT_LZ4\nstatic void\nsend_compressed_token(int f, int32 token, struct map_struct *buf, OFF_T offset, int32 nb)\n{\n\tstatic int init_done, flush_pending;\n\tint size = MAX(LZ4_compressBound(CHUNK_SIZE), MAX_DATA_COUNT+2);\n\tint32 n, r;\n\n\tif (last_token == -1) {\n\t\tif (!init_done) {\n\t\t\tobuf = new_array(char, size);\n\t\t\tinit_done = 1;\n\t\t}\n\t\tlast_run_end = 0;\n\t\trun_start = token;\n\t\tflush_pending = 0;\n\t} else if (last_token == -2) {\n\t\trun_start = token;\n\t} else if (nb != 0 || token != last_token + 1 || token >= run_start + 65536) {\n\t\t/* output previous run */\n\t\tr = run_start - last_run_end;\n\t\tn = last_token - run_start;\n\t\tif (r >= 0 && r <= 63) {\n\t\t\twrite_byte(f, (n==0? TOKEN_REL: TOKENRUN_REL) + r);\n\t\t} else {\n\t\t\twrite_byte(f, (n==0? TOKEN_LONG: TOKENRUN_LONG));\n\t\t\twrite_int(f, run_start);\n\t\t}\n\t\tif (n != 0) {\n\t\t\twrite_byte(f, n);\n\t\t\twrite_byte(f, n >> 8);\n\t\t}\n\t\tlast_run_end = last_token;\n\t\trun_start = token;\n\t}\n\n\tlast_token = token;\n\n\tif (nb != 0 || flush_pending) {\n\t\tint available_in, available_out = 0;\n\t\tconst char *next_in;\n\n\t\tdo {\n\t\t\tchar *next_out = obuf + 2;\n\n\t\t\tif (available_out == 0) {\n\t\t\t\tavailable_in = MIN(nb, MAX_DATA_COUNT);\n\t\t\t\tnext_in = map_ptr(buf, offset, available_in);\n\t\t\t} else\n\t\t\t\tavailable_in /= 2;\n\n\t\t\tavailable_out = LZ4_compress_default(next_in, next_out, available_in, size - 2);\n\t\t\tif (!available_out) {\n\t\t\t\trprintf(FERROR, \"compress returned %d\\n\", available_out);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t\tif (available_out <= MAX_DATA_COUNT) {\n\t\t\t\tobuf[0] = DEFLATED_DATA + (available_out >> 8);\n\t\t\t\tobuf[1] = available_out;\n\n\t\t\t\twrite_buf(f, obuf, available_out + 2);\n\n\t\t\t\tavailable_out = 0;\n\t\t\t\tnb -= available_in;\n\t\t\t\toffset += available_in;\n\t\t\t}\n\t\t} while (nb != 0);\n\t\tflush_pending = token == -2;\n\t}\n\tif (token == -1) {\n\t\t/* end of file - clean up */\n\t\twrite_byte(f, END_FLAG);\n\t}\n}\n\nstatic int32 recv_compressed_token(int f, char **data)\n{\n\tstatic int init_done;\n\tint32 n, flag;\n\tint size = MAX(LZ4_compressBound(CHUNK_SIZE), MAX_DATA_COUNT+2);\n\tstatic const char *next_in;\n\tstatic int avail_in;\n\tint avail_out;\n\n\tfor (;;) {\n\t\tswitch (recv_state) {\n\t\tcase r_init:\n\t\t\tif (!init_done) {\n\t\t\t\tcbuf = new_array(char, MAX_DATA_COUNT);\n\t\t\t\tdbuf = new_array(char, size);\n\t\t\t\tinit_done = 1;\n\t\t\t}\n\t\t\trecv_state = r_idle;\n\t\t\trx_token = 0;\n\t\t\tbreak;\n\n\t\tcase r_idle:\n\t\t\tflag = read_byte(f);\n\t\t\tif ((flag & 0xC0) == DEFLATED_DATA) {\n\t\t\t\tn = ((flag & 0x3f) << 8) + read_byte(f);\n\t\t\t\tread_buf(f, cbuf, n);\n\t\t\t\tnext_in = (char *)cbuf;\n\t\t\t\tavail_in = n;\n\t\t\t\trecv_state = r_inflating;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flag == END_FLAG) {\n\t\t\t\t/* that's all folks */\n\t\t\t\trecv_state = r_init;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* here we have a token of some kind */\n\t\t\tif (flag & TOKEN_REL) {\n\t\t\t\trx_token += flag & 0x3f;\n\t\t\t\tflag >>= 6;\n\t\t\t} else\n\t\t\t\trx_token = read_int(f);\n\t\t\tif (flag & 1) {\n\t\t\t\trx_run = read_byte(f);\n\t\t\t\trx_run += read_byte(f) << 8;\n\t\t\t\trecv_state = r_running;\n\t\t\t}\n\t\t\treturn -1 - rx_token;\n\n\t\tcase r_inflating:\n\t\t\tavail_out = LZ4_decompress_safe(next_in, dbuf, avail_in, size);\n\t\t\tif (avail_out < 0) {\n\t\t\t\trprintf(FERROR, \"uncompress failed: %d\\n\", avail_out);\n\t\t\t\texit_cleanup(RERR_STREAMIO);\n\t\t\t}\n\t\t\trecv_state = r_idle;\n\t\t\t*data = dbuf;\n\t\t\treturn avail_out;\n\n\t\tcase r_inflated: /* lz4 doesn't get into this state */\n\t\t\tbreak;\n\n\t\tcase r_running:\n\t\t\t++rx_token;\n\t\t\tif (--rx_run == 0)\n\t\t\t\trecv_state = r_idle;\n\t\t\treturn -1 - rx_token;\n\t\t}\n\t}\n}\n#endif /* SUPPORT_LZ4 */\n\n/**\n * Transmit a verbatim buffer of length @p n followed by a token.\n * If token == -1 then we have reached EOF\n * If n == 0 then don't send a buffer\n */\nvoid send_token(int f, int32 token, struct map_struct *buf, OFF_T offset,\n\t\tint32 n, int32 toklen)\n{\n\tswitch (do_compression) {\n\tcase CPRES_NONE:\n\t\tsimple_send_token(f, token, buf, offset, n);\n\t\tbreak;\n\tcase CPRES_ZLIB:\n\tcase CPRES_ZLIBX:\n\t\tsend_deflated_token(f, token, buf, offset, n, toklen);\n\t\tbreak;\n#ifdef SUPPORT_ZSTD\n\tcase CPRES_ZSTD:\n\t\tsend_zstd_token(f, token, buf, offset, n);\n\t\tbreak;\n#endif\n#ifdef SUPPORT_LZ4\n\tcase CPRES_LZ4:\n\t\tsend_compressed_token(f, token, buf, offset, n);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tNOISY_DEATH(\"Unknown do_compression value\");\n\t}\n}\n\n/*\n * receive a token or buffer from the other end. If the return value is >0 then\n * it is a data buffer of that length, and *data will point at the data.\n * if the return value is -i then it represents token i-1\n * if the return value is 0 then the end has been reached\n */\nint32 recv_token(int f, char **data)\n{\n\tswitch (do_compression) {\n\tcase CPRES_NONE:\n\t\treturn simple_recv_token(f,data);\n\tcase CPRES_ZLIB:\n\tcase CPRES_ZLIBX:\n\t\treturn recv_deflated_token(f, data);\n#ifdef SUPPORT_ZSTD\n\tcase CPRES_ZSTD:\n\t\treturn recv_zstd_token(f, data);\n#endif\n#ifdef SUPPORT_LZ4\n\tcase CPRES_LZ4:\n\t\treturn recv_compressed_token(f, data);\n#endif\n\tdefault:\n\t\tNOISY_DEATH(\"Unknown do_compression value\");\n\t}\n}\n\n/*\n * look at the data corresponding to a token, if necessary\n */\nvoid see_token(char *data, int32 toklen)\n{\n\tswitch (do_compression) {\n\tcase CPRES_NONE:\n\t\tbreak;\n\tcase CPRES_ZLIB:\n\t\tsee_deflate_token(data, toklen);\n\t\tbreak;\n\tcase CPRES_ZLIBX:\n\t\tbreak;\n#ifdef SUPPORT_ZSTD\n\tcase CPRES_ZSTD:\n\t\tbreak;\n#endif\n#ifdef SUPPORT_LZ4\n\tcase CPRES_LZ4:\n\t\t/*see_uncompressed_token(data, toklen);*/\n\t\tbreak;\n#endif\n\tdefault:\n\t\tNOISY_DEATH(\"Unknown do_compression value\");\n\t}\n}\n"
        },
        {
          "name": "trimslash.c",
          "type": "blob",
          "size": 1.1767578125,
          "content": "/*\n * Simple utility used only by the test harness.\n *\n * Copyright (C) 2002 Martin Pool\n * Copyright (C) 2003-2020 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n\n/* These are to make syscall.o shut up. */\nint dry_run = 0;\nint am_root = 0;\nint am_sender = 1;\nint read_only = 1;\nint list_only = 0;\n\nint\nmain(int argc, char **argv)\n{\n\tint i;\n\n\tif (argc <= 1) {\n\t\tfprintf(stderr, \"trimslash: needs at least one argument\\n\");\n\t\treturn 1;\n\t}\n\n\tfor (i = 1; i < argc; i++) {\n\t\ttrim_trailing_slashes(argv[i]);\t/* modify in place */\n\t\tprintf(\"%s\\n\", argv[i]);\n\t}\n\treturn 0;\n}\n"
        },
        {
          "name": "uidlist.c",
          "type": "blob",
          "size": 13.9716796875,
          "content": "/*\n * Handle the mapping of uid/gid and user/group names between systems.\n *\n * Copyright (C) 1996 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2004-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/* If the source username/group does not exist on the target then use\n * the numeric IDs.  Never do any mapping for uid=0 or gid=0 as these\n * are special. */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"itypes.h\"\n#include \"io.h\"\n\nextern int am_root;\nextern int preserve_uid;\nextern int preserve_gid;\nextern int preserve_acls;\nextern int numeric_ids;\nextern int xmit_id0_names;\nextern pid_t namecvt_pid;\nextern gid_t our_gid;\nextern char *usermap;\nextern char *groupmap;\n\n#ifdef HAVE_GETGROUPS\n# ifndef GETGROUPS_T\n#  define GETGROUPS_T gid_t\n# endif\n#endif\n\n#define NFLAGS_WILD_NAME_MATCH (1<<0)\n#define NFLAGS_NAME_MATCH (1<<1)\n\nunion name_or_id {\n\tconst char *name;\n\tid_t max_id;\n};\n\nstruct idlist {\n\tstruct idlist *next;\n\tunion name_or_id u;\n\tid_t id, id2;\n\tuint16 flags;\n};\n\nstatic struct idlist *uidlist, *uidmap;\nstatic struct idlist *gidlist, *gidmap;\n\nstatic inline int id_eq_uid(id_t id, uid_t uid)\n{\n\treturn id == (id_t)uid;\n}\n\nstatic inline int id_eq_gid(id_t id, gid_t gid)\n{\n\treturn id == (id_t)gid;\n}\n\nstatic id_t id_parse(const char *num_str)\n{\n\tid_t tmp, num = 0;\n\tconst char *cp = num_str;\n\n\twhile (*cp) {\n\t\tif (!isDigit(cp)) {\n\t\t  invalid_num:\n\t\t\trprintf(FERROR, \"Invalid ID number: %s\\n\", num_str);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\ttmp = num * 10 + *cp++ - '0';\n\t\tif (tmp < num)\n\t\t\tgoto invalid_num;\n\t\tnum = tmp;\n\t}\n\n\treturn num;\n}\n\nstatic struct idlist *add_to_list(struct idlist **root, id_t id, union name_or_id noiu,\n\t\t\t\t  id_t id2, uint16 flags)\n{\n\tstruct idlist *node = new(struct idlist);\n\tnode->next = *root;\n\tnode->u = noiu;\n\tnode->id = id;\n\tnode->id2 = id2;\n\tnode->flags = flags;\n\t*root = node;\n\treturn node;\n}\n\n/* turn a uid into a user name */\nconst char *uid_to_user(uid_t uid)\n{\n\tconst char *name = NULL;\n\n\tif (namecvt_pid) {\n\t\tid_t id = uid;\n\t\tnamecvt_call(\"uid\", &name, &id);\n\t} else {\n\t\tstruct passwd *pass = getpwuid(uid);\n\t\tif (pass)\n\t\t\tname = strdup(pass->pw_name);\n\t}\n\n\treturn name;\n}\n\n/* turn a gid into a group name */\nconst char *gid_to_group(gid_t gid)\n{\n\tconst char *name = NULL;\n\n\tif (namecvt_pid) {\n\t\tid_t id = gid;\n\t\tnamecvt_call(\"gid\", &name, &id);\n\t} else {\n\t\tstruct group *grp = getgrgid(gid);\n\t\tif (grp)\n\t\t\tname = strdup(grp->gr_name);\n\t}\n\n\treturn name;\n}\n\n/* Parse a user name or (optionally) a number into a uid */\nint user_to_uid(const char *name, uid_t *uid_p, BOOL num_ok)\n{\n\tif (!name || !*name)\n\t\treturn 0;\n\n\tif (num_ok && name[strspn(name, \"0123456789\")] == '\\0') {\n\t\t*uid_p = id_parse(name);\n\t\treturn 1;\n\t}\n\n\tif (namecvt_pid) {\n\t\tid_t id;\n\t\tif (!namecvt_call(\"usr\", &name, &id))\n\t\t\treturn 0;\n\t\t*uid_p = id;\n\t} else {\n\t\tstruct passwd *pass = getpwnam(name);\n\t\tif (!pass)\n\t\t\treturn 0;\n\t\t*uid_p = pass->pw_uid;\n\t}\n\n\treturn 1;\n}\n\n/* Parse a group name or (optionally) a number into a gid */\nint group_to_gid(const char *name, gid_t *gid_p, BOOL num_ok)\n{\n\tif (!name || !*name)\n\t\treturn 0;\n\n\tif (num_ok && name[strspn(name, \"0123456789\")] == '\\0') {\n\t\t*gid_p = id_parse(name);\n\t\treturn 1;\n\t}\n\n\tif (namecvt_pid) {\n\t\tid_t id;\n\t\tif (!namecvt_call(\"grp\", &name, &id))\n\t\t\treturn 0;\n\t\t*gid_p = id;\n\t} else {\n\t\tstruct group *grp = getgrnam(name);\n\t\tif (!grp)\n\t\t\treturn 0;\n\t\t*gid_p = grp->gr_gid;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_in_group(gid_t gid)\n{\n#ifdef HAVE_GETGROUPS\n\tstatic gid_t last_in;\n\tstatic int ngroups = -2, last_out = -1;\n\tstatic GETGROUPS_T *gidset;\n\tint n;\n\n\tif (gid == last_in && last_out >= 0)\n\t\treturn last_out;\n\tif (ngroups < -1) {\n\t\tif ((ngroups = getgroups(0, NULL)) < 0)\n\t\t\tngroups = 0;\n\t\tgidset = new_array(GETGROUPS_T, ngroups+1);\n\t\tif (ngroups > 0)\n\t\t\tngroups = getgroups(ngroups, gidset);\n\t\t/* The default gid might not be in the list on some systems. */\n\t\tfor (n = 0; n < ngroups; n++) {\n\t\t\tif ((gid_t)gidset[n] == our_gid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (n == ngroups)\n\t\t\tgidset[ngroups++] = our_gid;\n\t\tif (DEBUG_GTE(OWN, 2)) {\n\t\t\tint pos;\n\t\t\tchar *gidbuf = new_array(char, ngroups*21+32);\n\t\t\tpos = snprintf(gidbuf, 32, \"process has %d gid%s: \", ngroups, ngroups == 1? \"\" : \"s\");\n\t\t\tfor (n = 0; n < ngroups; n++) {\n\t\t\t\tpos += snprintf(gidbuf+pos, 21, \" %d\", (int)gidset[n]);\n\t\t\t}\n\t\t\trprintf(FINFO, \"%s\\n\", gidbuf);\n\t\t\tfree(gidbuf);\n\t\t}\n\t}\n\n\tlast_in = gid;\n\tfor (n = 0; n < ngroups; n++) {\n\t\tif ((gid_t)gidset[n] == gid)\n\t\t\treturn last_out = 1;\n\t}\n\treturn last_out = 0;\n\n#else\n\treturn gid == our_gid;\n#endif\n}\n\n/* Add a uid/gid to its list of ids.  Only called on receiving side. */\nstatic struct idlist *recv_add_id(struct idlist **idlist_ptr, struct idlist *idmap,\n\t\t\t\t  id_t id, const char *name)\n{\n\tstruct idlist *node;\n\tunion name_or_id noiu;\n\tint flag;\n\tid_t id2;\n\n\tnoiu.name = name; /* ensure that add_to_list() gets the raw value. */\n\tif (!name)\n\t\tname = \"\";\n\n\tfor (node = idmap; node; node = node->next) {\n\t\tif (node->flags & NFLAGS_WILD_NAME_MATCH) {\n\t\t\tif (!wildmatch(node->u.name, name))\n\t\t\t\tcontinue;\n\t\t} else if (node->flags & NFLAGS_NAME_MATCH) {\n\t\t\tif (strcmp(node->u.name, name) != 0)\n\t\t\t\tcontinue;\n\t\t} else if (node->u.max_id) {\n\t\t\tif (id < node->id || id > node->u.max_id)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (node->id != id)\n\t\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (node)\n\t\tid2 = node->id2;\n\telse if (*name && id) {\n\t\tif (idlist_ptr == &uidlist) {\n\t\t\tuid_t uid;\n\t\t\tid2 = user_to_uid(name, &uid, False) ? (id_t)uid : id;\n\t\t} else {\n\t\t\tgid_t gid;\n\t\t\tid2 = group_to_gid(name, &gid, False) ? (id_t)gid : id;\n\t\t}\n\t} else\n\t\tid2 = id;\n\n\tflag = idlist_ptr == &gidlist && !am_root && !is_in_group(id2) ? FLAG_SKIP_GROUP : 0;\n\tnode = add_to_list(idlist_ptr, id, noiu, id2, flag);\n\n\tif (DEBUG_GTE(OWN, 2)) {\n\t\trprintf(FINFO, \"%sid %u(%s) maps to %u\\n\",\n\t\t\tidlist_ptr == &uidlist ? \"u\" : \"g\",\n\t\t\t(unsigned)id, name, (unsigned)id2);\n\t}\n\n\treturn node;\n}\n\n/* this function is a definite candidate for a faster algorithm */\nuid_t match_uid(uid_t uid)\n{\n\tstatic struct idlist *last = NULL;\n\tstruct idlist *list;\n\n\tif (last && id_eq_uid(last->id, uid))\n\t\treturn last->id2;\n\n\tfor (list = uidlist; list; list = list->next) {\n\t\tif (id_eq_uid(list->id, uid))\n\t\t\tbreak;\n\t}\n\n\tif (!list)\n\t\tlist = recv_add_id(&uidlist, uidmap, uid, NULL);\n\tlast = list;\n\n\treturn list->id2;\n}\n\ngid_t match_gid(gid_t gid, uint16 *flags_ptr)\n{\n\tstatic struct idlist *last = NULL;\n\tstruct idlist *list;\n\n\tif (last && id_eq_gid(last->id, gid))\n\t\tlist = last;\n\telse {\n\t\tfor (list = gidlist; list; list = list->next) {\n\t\t\tif (id_eq_gid(list->id, gid))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!list)\n\t\t\tlist = recv_add_id(&gidlist, gidmap, gid, NULL);\n\t\tlast = list;\n\t}\n\n\tif (flags_ptr && list->flags & FLAG_SKIP_GROUP)\n\t\t*flags_ptr |= FLAG_SKIP_GROUP;\n\treturn list->id2;\n}\n\n/* Add a uid to the list of uids.  Only called on sending side. */\nconst char *add_uid(uid_t uid)\n{\n\tstruct idlist *list;\n\tstruct idlist *node;\n\tunion name_or_id noiu;\n\n\tfor (list = uidlist; list; list = list->next) {\n\t\tif (id_eq_uid(list->id, uid))\n\t\t\treturn NULL;\n\t}\n\n\tnoiu.name = uid_to_user(uid);\n\tnode = add_to_list(&uidlist, uid, noiu, 0, 0);\n\treturn node->u.name;\n}\n\n/* Add a gid to the list of gids.  Only called on sending side. */\nconst char *add_gid(gid_t gid)\n{\n\tstruct idlist *list;\n\tstruct idlist *node;\n\tunion name_or_id noiu;\n\n\tfor (list = gidlist; list; list = list->next) {\n\t\tif (id_eq_gid(list->id, gid))\n\t\t\treturn NULL;\n\t}\n\n\tnoiu.name = gid_to_group(gid);\n\tnode = add_to_list(&gidlist, gid, noiu, 0, 0);\n\treturn node->u.name;\n}\n\nstatic void send_one_name(int f, id_t id, const char *name)\n{\n\tint len;\n\n\tif (!name)\n\t\tname = \"\";\n\tif ((len = strlen(name)) > 255) /* Impossible? */\n\t\tlen = 255;\n\n\twrite_varint30(f, id);\n\twrite_byte(f, len);\n\tif (len)\n\t\twrite_buf(f, name, len);\n}\n\nstatic void send_one_list(int f, struct idlist *idlist, int usernames)\n{\n\tstruct idlist *list;\n\n\t/* we send sequences of id/byte-len/name */\n\tfor (list = idlist; list; list = list->next) {\n\t\tif (list->id && list->u.name)\n\t\t\tsend_one_name(f, list->id, list->u.name);\n\t}\n\n\t/* Terminate the uid list with 0 (which was excluded above).\n\t * A modern rsync also sends the name of id 0. */\n\tif (xmit_id0_names)\n\t\tsend_one_name(f, 0, usernames ? uid_to_user(0) : gid_to_group(0));\n\telse\n\t\twrite_varint30(f, 0);\n}\n\n/* send a complete uid/gid mapping to the peer */\nvoid send_id_lists(int f)\n{\n\tif (preserve_uid || preserve_acls)\n\t\tsend_one_list(f, uidlist, 1);\n\n\tif (preserve_gid || preserve_acls)\n\t\tsend_one_list(f, gidlist, 0);\n}\n\nuid_t recv_user_name(int f, uid_t uid)\n{\n\tstruct idlist *node;\n\tint len = read_byte(f);\n\tchar *name;\n\n\tif (len) {\n\t\tname = new_array(char, len+1);\n\t\tread_sbuf(f, name, len);\n\t\tif (numeric_ids < 0) {\n\t\t\tfree(name);\n\t\t\tname = NULL;\n\t\t}\n\t} else\n\t\tname = NULL;\n\n\tnode = recv_add_id(&uidlist, uidmap, uid, name); /* node keeps name's memory */\n\treturn node->id2;\n}\n\ngid_t recv_group_name(int f, gid_t gid, uint16 *flags_ptr)\n{\n\tstruct idlist *node;\n\tint len = read_byte(f);\n\tchar *name;\n\n\tif (len) {\n\t\tname = new_array(char, len+1);\n\t\tread_sbuf(f, name, len);\n\t\tif (numeric_ids < 0) {\n\t\t\tfree(name);\n\t\t\tname = NULL;\n\t\t}\n\t} else\n\t\tname = NULL;\n\n\tnode = recv_add_id(&gidlist, gidmap, gid, name); /* node keeps name's memory */\n\tif (flags_ptr && node->flags & FLAG_SKIP_GROUP)\n\t\t*flags_ptr |= FLAG_SKIP_GROUP;\n\treturn node->id2;\n}\n\n/* recv a complete uid/gid mapping from the peer and map the uid/gid\n * in the file list to local names */\nvoid recv_id_list(int f, struct file_list *flist)\n{\n\tid_t id;\n\tint i;\n\n\tif ((preserve_uid || preserve_acls) && numeric_ids <= 0) {\n\t\t/* read the uid list */\n\t\twhile ((id = read_varint30(f)) != 0)\n\t\t\trecv_user_name(f, id);\n\t\tif (xmit_id0_names)\n\t\t\trecv_user_name(f, 0);\n\t}\n\n\tif ((preserve_gid || preserve_acls) && numeric_ids <= 0) {\n\t\t/* read the gid list */\n\t\twhile ((id = read_varint30(f)) != 0)\n\t\t\trecv_group_name(f, id, NULL);\n\t\tif (xmit_id0_names)\n\t\t\trecv_group_name(f, 0, NULL);\n\t}\n\n\t/* Now convert all the uids/gids from sender values to our values. */\n#ifdef SUPPORT_ACLS\n\tif (preserve_acls && (!numeric_ids || usermap || groupmap))\n\t\tmatch_acl_ids();\n#endif\n\tif (am_root && preserve_uid && (!numeric_ids || usermap)) {\n\t\tfor (i = 0; i < flist->used; i++)\n\t\t\tF_OWNER(flist->files[i]) = match_uid(F_OWNER(flist->files[i]));\n\t}\n\tif (preserve_gid && (!am_root || !numeric_ids || groupmap)) {\n\t\tfor (i = 0; i < flist->used; i++) {\n\t\t\tF_GROUP(flist->files[i]) = match_gid(F_GROUP(flist->files[i]), &flist->files[i]->flags);\n\t\t}\n\t}\n}\n\nvoid parse_name_map(char *map, BOOL usernames)\n{\n\tstruct idlist **idmap_ptr = usernames ? &uidmap : &gidmap;\n\tstruct idlist **idlist_ptr = usernames ? &uidlist : &gidlist;\n\tchar *colon, *cp = map + strlen(map);\n\tunion name_or_id noiu;\n\tid_t id1;\n\tuint16 flags;\n\n\t/* Parse the list in reverse, so the order in the struct is right. */\n\twhile (1) {\n\t\twhile (cp > map && cp[-1] != ',') cp--;\n\t\tif (!(colon = strchr(cp, ':'))) {\n\t\t\trprintf(FERROR, \"No colon found in --%smap: %s\\n\",\n\t\t\t\tusernames ? \"user\" : \"group\", cp);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\tif (!colon[1]) {\n\t\t\trprintf(FERROR, \"No name found after colon --%smap: %s\\n\",\n\t\t\t\tusernames ? \"user\" : \"group\", cp);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t\t*colon = '\\0';\n\n\t\tif (isDigit(cp)) {\n\t\t\tchar *dash = strchr(cp, '-');\n\t\t\tif (strspn(cp, \"0123456789-\") != (size_t)(colon - cp)\n\t\t\t || (dash && (!dash[1] || strchr(dash+1, '-')))) {\n\t\t\t\trprintf(FERROR, \"Invalid number in --%smap: %s\\n\",\n\t\t\t\t\tusernames ? \"user\" : \"group\", cp);\n\t\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t\t}\n\t\t\tif (dash) {\n\t\t\t\t*dash = '\\0';\n\t\t\t\tnoiu.max_id = id_parse(dash+1);\n\t\t\t} else\n\t\t\t\tnoiu.max_id = 0;\n\t\t\tflags = 0;\n\t\t\tid1 = id_parse(cp);\n\t\t\tif (dash)\n\t\t\t\t*dash = '-';\n\t\t} else if (strpbrk(cp, \"*[?\")) {\n\t\t\tflags = NFLAGS_WILD_NAME_MATCH;\n\t\t\tnoiu.name = cp;\n\t\t\tid1 = 0;\n\t\t} else {\n\t\t\tflags = NFLAGS_NAME_MATCH;\n\t\t\tnoiu.name = cp;\n\t\t\tid1 = 0;\n\t\t}\n\n\t\tif (usernames) {\n\t\t\tuid_t uid;\n\t\t\tif (user_to_uid(colon+1, &uid, True))\n\t\t\t\tadd_to_list(idmap_ptr, id1, noiu, uid, flags);\n\t\t\telse {\n\t\t\t\trprintf(FERROR, \"Unknown --usermap name on receiver: %s\\n\", colon+1);\n\t\t\t}\n\t\t} else {\n\t\t\tgid_t gid;\n\t\t\tif (group_to_gid(colon+1, &gid, True))\n\t\t\t\tadd_to_list(idmap_ptr, id1, noiu, gid, flags);\n\t\t\telse {\n\t\t\t\trprintf(FERROR, \"Unknown --groupmap name on receiver: %s\\n\", colon+1);\n\t\t\t}\n\t\t}\n\n\t\tif (cp == map)\n\t\t\tbreak;\n\n\t\t*--cp = '\\0'; /* replace comma */\n\t}\n\n\t/* If the sender isn't going to xmit the id0 name, we assume it's \"root\". */\n\tif (!xmit_id0_names)\n\t\trecv_add_id(idlist_ptr, *idmap_ptr, 0, numeric_ids ? NULL : \"root\");\n}\n\n#ifdef HAVE_GETGROUPLIST\nconst char *getallgroups(uid_t uid, item_list *gid_list)\n{\n\tstruct passwd *pw;\n\tgid_t *gid_array;\n\tint size;\n\n\tif ((pw = getpwuid(uid)) == NULL)\n\t\treturn \"getpwuid failed\";\n\n\tgid_list->count = 0; /* We're overwriting any items in the list */\n\t(void)EXPAND_ITEM_LIST(gid_list, gid_t, 32);\n\tsize = gid_list->malloced;\n\n\t/* Get all the process's groups, with the pw_gid group first. */\n\tif (getgrouplist(pw->pw_name, pw->pw_gid, gid_list->items, &size) < 0) {\n\t\tif (size > (int)gid_list->malloced) {\n\t\t\tgid_list->count = gid_list->malloced;\n\t\t\t(void)EXPAND_ITEM_LIST(gid_list, gid_t, size);\n\t\t\tif (getgrouplist(pw->pw_name, pw->pw_gid, gid_list->items, &size) < 0)\n\t\t\t\tsize = -1;\n\t\t} else\n\t\t\tsize = -1;\n\t\tif (size < 0)\n\t\t\treturn \"getgrouplist failed\";\n\t}\n\tgid_list->count = size;\n\tgid_array = gid_list->items;\n\n\t/* Paranoia: is the default group not first in the list? */\n\tif (gid_array[0] != pw->pw_gid) {\n\t\tint j;\n\t\tfor (j = 1; j < size; j++) {\n\t\t\tif (gid_array[j] == pw->pw_gid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == size) { /* The default group wasn't found! */\n\t\t\t(void)EXPAND_ITEM_LIST(gid_list, gid_t, size+1);\n\t\t\tgid_array = gid_list->items;\n\t\t}\n\t\tgid_array[j] = gid_array[0];\n\t\tgid_array[0] = pw->pw_gid;\n\t}\n\n\treturn NULL;\n}\n#endif\n"
        },
        {
          "name": "usage.c",
          "type": "blob",
          "size": 9.1064453125,
          "content": "/*\n * Some usage & version related functions.\n *\n * Copyright (C) 2002-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"version.h\"\n#include \"latest-year.h\"\n#include \"git-version.h\"\n#include \"default-cvsignore.h\"\n#include \"itypes.h\"\n\nextern struct name_num_obj valid_checksums, valid_compressions, valid_auth_checksums;\n\nstatic char *istring(const char *fmt, int val)\n{\n\tchar *str;\n\tif (asprintf(&str, fmt, val) < 0)\n\t\tout_of_memory(\"istring\");\n\treturn str;\n}\n\nstatic void print_info_flags(enum logcode f)\n{\n\tSTRUCT_STAT *dumstat;\n\tBOOL as_json = f == FNONE ? 1 : 0; /* We use 1 == first attribute, 2 == need closing array */\n\tchar line_buf[75], item_buf[32];\n\tint line_len, j;\n\tchar *info_flags[] = {\n\n\t\"*Capabilities\",\n\n\t\tistring(\"%d-bit files\", (int)(sizeof (OFF_T) * 8)),\n\t\tistring(\"%d-bit inums\", (int)(sizeof dumstat->st_ino * 8)), /* Don't check ino_t! */\n\t\tistring(\"%d-bit timestamps\", (int)(sizeof (time_t) * 8)),\n\t\tistring(\"%d-bit long ints\", (int)(sizeof (int64) * 8)),\n\n#ifndef HAVE_SOCKETPAIR\n\t\t\"no \"\n#endif\n\t\t\t\"socketpairs\",\n\n#ifndef SUPPORT_LINKS\n\t\t\"no \"\n#endif\n\t\t\t\"symlinks\",\n\n#ifndef CAN_SET_SYMLINK_TIMES\n\t\t\"no \"\n#endif\n\t\t\t\"symtimes\",\n\n#ifndef SUPPORT_HARD_LINKS\n\t\t\"no \"\n#endif\n\t\t\t\"hardlinks\",\n\n#ifndef CAN_HARDLINK_SPECIAL\n\t\t\"no \"\n#endif\n\t\t\t\"hardlink-specials\",\n\n#ifndef CAN_HARDLINK_SYMLINK\n\t\t\"no \"\n#endif\n\t\t\t\"hardlink-symlinks\",\n\n#ifndef INET6\n\t\t\"no \"\n#endif\n\t\t\t\"IPv6\",\n\n#ifndef SUPPORT_ATIMES\n\t\t\"no \"\n#endif\n\t\t\t\"atimes\",\n\n\t\t\"batchfiles\",\n\n#ifndef HAVE_FTRUNCATE\n\t\t\"no \"\n#endif\n\t\t\t\"inplace\",\n\n#ifndef HAVE_FTRUNCATE\n\t\t\"no \"\n#endif\n\t\t\t\"append\",\n\n#ifndef SUPPORT_ACLS\n\t\t\"no \"\n#endif\n\t\t\t\"ACLs\",\n\n#ifndef SUPPORT_XATTRS\n\t\t\"no \"\n#endif\n\t\t\t\"xattrs\",\n\n#ifdef RSYNC_USE_SECLUDED_ARGS\n\t\t\"default \"\n#else\n\t\t\"optional \"\n#endif\n\t\t\t\"secluded-args\",\n\n#ifndef ICONV_OPTION\n\t\t\"no \"\n#endif\n\t\t\t\"iconv\",\n\n#ifndef SUPPORT_PREALLOCATION\n\t\t\"no \"\n#endif\n\t\t\t\"prealloc\",\n\n#ifndef HAVE_MKTIME\n\t\t\"no \"\n#endif\n\t\t\t\"stop-at\",\n\n#ifndef SUPPORT_CRTIMES\n\t\t\"no \"\n#endif\n\t\t\t\"crtimes\",\n\n\t\"*Optimizations\",\n\n#ifndef USE_ROLL_SIMD\n\t\t\"no \"\n#endif\n\t\t\t\"SIMD-roll\",\n\n#ifndef USE_ROLL_ASM\n\t\t\"no \"\n#endif\n\t\t\t\"asm-roll\",\n\n#ifndef USE_OPENSSL\n\t\t\"no \"\n#endif\n\t\t\t\"openssl-crypto\",\n\n#ifndef USE_MD5_ASM\n\t\t\"no \"\n#endif\n\t\t\t\"asm-MD5\",\n\n\t\tNULL\n\t};\n\n\tfor (line_len = 0, j = 0; ; j++) {\n\t\tchar *str = info_flags[j], *next_nfo = str ? info_flags[j+1] : NULL;\n\t\tint need_comma = next_nfo && *next_nfo != '*' ? 1 : 0;\n\t\tint item_len;\n\t\tif (!str || *str == '*')\n\t\t\titem_len = 1000;\n\t\telse if (as_json) {\n\t\t\tchar *space = strchr(str, ' ');\n\t\t\tint is_no = space && strncmp(str, \"no \", 3) == 0;\n\t\t\tint is_bits = space && isDigit(str);\n\t\t\tchar *quot = space && !is_no && !is_bits ? \"\\\"\" : \"\";\n\t\t\tchar *item = space ? space + 1 : str;\n\t\t\tchar *val = !space ? \"true\" : is_no ? \"false\" : str;\n\t\t\tint val_len = !space ? 4 : is_no ? 5 : space - str;\n\t\t\tif (is_bits && (space = strchr(val, '-')) != NULL)\n\t\t\t    val_len = space - str;\n\t\t\titem_len = snprintf(item_buf, sizeof item_buf,\n\t\t\t\t\t   \" \\\"%s%s\\\": %s%.*s%s%s\", item, is_bits ? \"bits\" : \"\",\n\t\t\t\t\t   quot, val_len, val, quot, need_comma ? \",\" : \"\");\n\t\t\tif (is_bits)\n\t\t\t\titem_buf[strlen(item)+2-1] = '_'; /* Turn the 's' into a '_' */\n\t\t\tfor (space = item; (space = strpbrk(space, \" -\")) != NULL; space++)\n\t\t\t\titem_buf[space - item + 2] = '_';\n\t\t} else\n\t\t\titem_len = snprintf(item_buf, sizeof item_buf, \" %s%s\", str, need_comma ? \",\" : \"\");\n\t\tif (line_len && line_len + item_len >= (int)sizeof line_buf) {\n\t\t\tif (as_json)\n\t\t\t\tprintf(\"   %s\\n\", line_buf);\n\t\t\telse\n\t\t\t\trprintf(f, \"   %s\\n\", line_buf);\n\t\t\tline_len = 0;\n\t\t}\n\t\tif (!str)\n\t\t\tbreak;\n\t\tif (*str == '*') {\n\t\t\tif (as_json) {\n\t\t\t\tif (as_json == 2)\n\t\t\t\t\tprintf(\"  }\");\n\t\t\t\telse\n\t\t\t\t\tas_json = 2;\n\t\t\t\tprintf(\",\\n  \\\"%c%s\\\": {\\n\", toLower(str+1), str+2);\n\t\t\t} else\n\t\t\t\trprintf(f, \"%s:\\n\", str+1);\n\t\t} else {\n\t\t\tstrlcpy(line_buf + line_len, item_buf, sizeof line_buf - line_len);\n\t\t\tline_len += item_len;\n\t\t}\n\t}\n\tif (as_json == 2)\n\t\tprintf(\"  }\");\n}\n\nstatic void output_nno_list(enum logcode f, const char *name, struct name_num_obj *nno)\n{\n\tchar namebuf[64], tmpbuf[256];\n\tchar *tok, *next_tok, *comma = \",\";\n\tchar *cp;\n\n\t/* Using '(' ensures that we get a trailing \"none\" but also includes aliases. */\n\tget_default_nno_list(nno, tmpbuf, sizeof tmpbuf - 1, '(');\n\tif (f != FNONE) {\n\t\trprintf(f, \"%s:\\n\", name);\n\t\trprintf(f, \"    %s\\n\", tmpbuf);\n\t\treturn;\n\t}\n\n\tstrlcpy(namebuf, name, sizeof namebuf);\n\tfor (cp = namebuf; *cp; cp++) {\n\t\tif (*cp == ' ')\n\t\t\t*cp = '_';\n\t\telse if (isUpper(cp))\n\t\t\t*cp = toLower(cp);\n\t}\n\n\tprintf(\",\\n  \\\"%s\\\": [\\n   \", namebuf);\n\n\tfor (tok = strtok(tmpbuf, \" \"); tok; tok = next_tok) {\n\t\tnext_tok = strtok(NULL, \" \");\n\t\tif (*tok != '(') /* Ignore the alises in the JSON output */\n\t\t\tprintf(\" \\\"%s\\\"%s\", tok, comma + (next_tok ? 0 : 1));\n\t}\n\n\tprintf(\"\\n  ]\");\n}\n\n/* A request of f == FNONE wants json on stdout. */\nvoid print_rsync_version(enum logcode f)\n{\n\tchar copyright[] = \"(C) 1996-\" LATEST_YEAR \" by Andrew Tridgell, Wayne Davison, and others.\";\n\tchar url[] = \"https://rsync.samba.org/\";\n\tBOOL first_line = 1;\n\n#define json_line(name, value) \\\n\tdo { \\\n\t\tprintf(\"%c\\n  \\\"%s\\\": \\\"%s\\\"\", first_line ? '{' : ',', name, value); \\\n\t\tfirst_line = 0; \\\n\t} while (0)\n\n\tif (f == FNONE) {\n\t\tchar verbuf[32];\n\t\tjson_line(\"program\", RSYNC_NAME);\n\t\tjson_line(\"version\", rsync_version());\n\t\t(void)snprintf(verbuf, sizeof verbuf, \"%d.%d\", PROTOCOL_VERSION, SUBPROTOCOL_VERSION);\n\t\tjson_line(\"protocol\", verbuf);\n\t\tjson_line(\"copyright\", copyright);\n\t\tjson_line(\"url\", url);\n\t} else {\n#if SUBPROTOCOL_VERSION != 0\n\t\tchar *subprotocol = istring(\".PR%d\", SUBPROTOCOL_VERSION);\n#else\n\t\tchar *subprotocol = \"\";\n#endif\n\t\trprintf(f, \"%s  version %s  protocol version %d%s\\n\",\n\t\t\tRSYNC_NAME, rsync_version(), PROTOCOL_VERSION, subprotocol);\n\t\trprintf(f, \"Copyright %s\\n\", copyright);\n\t\trprintf(f, \"Web site: %s\\n\", url);\n\t}\n\n\tprint_info_flags(f);\n\n\tinit_checksum_choices();\n\n\toutput_nno_list(f, \"Checksum list\", &valid_checksums);\n\toutput_nno_list(f, \"Compress list\", &valid_compressions);\n\toutput_nno_list(f, \"Daemon auth list\", &valid_auth_checksums);\n\n\tif (f == FNONE) {\n\t\tjson_line(\"license\", \"GPLv3\");\n\t\tjson_line(\"caveat\", \"rsync comes with ABSOLUTELY NO WARRANTY\");\n\t\tprintf(\"\\n}\\n\");\n\t\tfflush(stdout);\n\t\treturn;\n\t}\n\n#ifdef MAINTAINER_MODE\n\trprintf(f, \"Panic Action: \\\"%s\\\"\\n\", get_panic_action());\n#endif\n\n#if SIZEOF_INT64 < 8\n\trprintf(f, \"WARNING: no 64-bit integers on this platform!\\n\");\n#endif\n\tif (sizeof (int64) != SIZEOF_INT64) {\n\t\trprintf(f,\n\t\t\t\"WARNING: size mismatch in SIZEOF_INT64 define (%d != %d)\\n\",\n\t\t\t(int) SIZEOF_INT64, (int) sizeof (int64));\n\t}\n\n\trprintf(f,\"\\n\");\n\trprintf(f,\"rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you\\n\");\n\trprintf(f,\"are welcome to redistribute it under certain conditions.  See the GNU\\n\");\n\trprintf(f,\"General Public Licence for details.\\n\");\n}\n\nvoid usage(enum logcode F)\n{\n  print_rsync_version(F);\n\n  rprintf(F,\"\\n\");\n  rprintf(F,\"rsync is a file transfer program capable of efficient remote update\\n\");\n  rprintf(F,\"via a fast differencing algorithm.\\n\");\n\n  rprintf(F,\"\\n\");\n  rprintf(F,\"Usage: rsync [OPTION]... SRC [SRC]... DEST\\n\");\n  rprintf(F,\"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\\n\");\n  rprintf(F,\"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\\n\");\n  rprintf(F,\"  or   rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\\n\");\n  rprintf(F,\"  or   rsync [OPTION]... [USER@]HOST:SRC [DEST]\\n\");\n  rprintf(F,\"  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]\\n\");\n  rprintf(F,\"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\\n\");\n  rprintf(F,\"The ':' usages connect via remote shell, while '::' & 'rsync://' usages connect\\n\");\n  rprintf(F,\"to an rsync daemon, and require SRC or DEST to start with a module name.\\n\");\n  rprintf(F,\"\\n\");\n  rprintf(F,\"Options\\n\");\n#include \"help-rsync.h\"\n  rprintf(F,\"\\n\");\n  rprintf(F,\"Use \\\"rsync --daemon --help\\\" to see the daemon-mode command-line options.\\n\");\n  rprintf(F,\"Please see the rsync(1) and rsyncd.conf(5) manpages for full documentation.\\n\");\n  rprintf(F,\"See https://rsync.samba.org/ for updates, bug reports, and answers\\n\");\n}\n\nvoid daemon_usage(enum logcode F)\n{\n  print_rsync_version(F);\n\n  rprintf(F,\"\\n\");\n  rprintf(F,\"Usage: rsync --daemon [OPTION]...\\n\");\n#include \"help-rsyncd.h\"\n  rprintf(F,\"\\n\");\n  rprintf(F,\"If you were not trying to invoke rsync as a daemon, avoid using any of the\\n\");\n  rprintf(F,\"daemon-specific rsync options.  See also the rsyncd.conf(5) manpage.\\n\");\n}\n\nconst char *rsync_version(void)\n{\n\tchar *ver;\n#ifdef RSYNC_GITVER\n\tver = RSYNC_GITVER;\n#else\n\tver = RSYNC_VERSION;\n#endif\n\treturn *ver == 'v' ? ver+1 : ver;\n}\n\nconst char *default_cvsignore(void)\n{\n\treturn DEFAULT_CVSIGNORE;\n}\n"
        },
        {
          "name": "util1.c",
          "type": "blob",
          "size": 41.7431640625,
          "content": "/*\n * Utility routines used in rsync.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"itypes.h\"\n#include \"inums.h\"\n\nextern int dry_run;\nextern int module_id;\nextern int do_fsync;\nextern int protect_args;\nextern int modify_window;\nextern int relative_paths;\nextern int preserve_xattrs;\nextern int omit_link_times;\nextern int preallocate_files;\nextern char *module_dir;\nextern unsigned int module_dirlen;\nextern char *partial_dir;\nextern filter_rule_list daemon_filter_list;\n\nint sanitize_paths = 0;\n\nchar curr_dir[MAXPATHLEN];\nunsigned int curr_dir_len;\nint curr_dir_depth; /* This is only set for a sanitizing daemon. */\n\n/* Set a fd into nonblocking mode. */\nvoid set_nonblocking(int fd)\n{\n\tint val;\n\n\tif ((val = fcntl(fd, F_GETFL)) == -1)\n\t\treturn;\n\tif (!(val & NONBLOCK_FLAG)) {\n\t\tval |= NONBLOCK_FLAG;\n\t\tfcntl(fd, F_SETFL, val);\n\t}\n}\n\n/* Set a fd into blocking mode. */\nvoid set_blocking(int fd)\n{\n\tint val;\n\n\tif ((val = fcntl(fd, F_GETFL)) == -1)\n\t\treturn;\n\tif (val & NONBLOCK_FLAG) {\n\t\tval &= ~NONBLOCK_FLAG;\n\t\tfcntl(fd, F_SETFL, val);\n\t}\n}\n\n/**\n * Create a file descriptor pair - like pipe() but use socketpair if\n * possible (because of blocking issues on pipes).\n *\n * Always set non-blocking.\n */\nint fd_pair(int fd[2])\n{\n\tint ret;\n\n#ifdef HAVE_SOCKETPAIR\n\tret = socketpair(AF_UNIX, SOCK_STREAM, 0, fd);\n#else\n\tret = pipe(fd);\n#endif\n\n\tif (ret == 0) {\n\t\tset_nonblocking(fd[0]);\n\t\tset_nonblocking(fd[1]);\n\t}\n\n\treturn ret;\n}\n\nvoid print_child_argv(const char *prefix, char **cmd)\n{\n\tint cnt = 0;\n\trprintf(FCLIENT, \"%s \", prefix);\n\tfor (; *cmd; cmd++) {\n\t\t/* Look for characters that ought to be quoted.  This\n\t\t* is not a great quoting algorithm, but it's\n\t\t* sufficient for a log message. */\n\t\tif (strspn(*cmd, \"abcdefghijklmnopqrstuvwxyz\"\n\t\t\t   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t   \"0123456789\"\n\t\t\t   \",.-_=+@/\") != strlen(*cmd)) {\n\t\t\trprintf(FCLIENT, \"\\\"%s\\\" \", *cmd);\n\t\t} else {\n\t\t\trprintf(FCLIENT, \"%s \", *cmd);\n\t\t}\n\t\tcnt++;\n\t}\n\trprintf(FCLIENT, \" (%d args)\\n\", cnt);\n}\n\n/* This returns 0 for success, 1 for a symlink if symlink time-setting\n * is not possible, or -1 for any other error. */\nint set_times(const char *fname, STRUCT_STAT *stp)\n{\n\tstatic int switch_step = 0;\n\n\tif (DEBUG_GTE(TIME, 1)) {\n\t\trprintf(FINFO,\n\t\t\t\"set modtime, atime of %s to (%ld) %s, (%ld) %s\\n\",\n\t\t\tfname, (long)stp->st_mtime,\n\t\t\ttimestring(stp->st_mtime), (long)stp->st_atime, timestring(stp->st_atime));\n\t}\n\n\tswitch (switch_step) {\n#ifdef HAVE_SETATTRLIST\n#include \"case_N.h\"\n\t\tif (do_setattrlist_times(fname, stp) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOSYS)\n\t\t\treturn -1;\n\t\tswitch_step++;\n#endif\n\n#ifdef HAVE_UTIMENSAT\n#include \"case_N.h\"\n\t\tif (do_utimensat(fname, stp) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOSYS)\n\t\t\treturn -1;\n\t\tswitch_step++;\n#endif\n\n#ifdef HAVE_LUTIMES\n#include \"case_N.h\"\n\t\tif (do_lutimes(fname, stp) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOSYS)\n\t\t\treturn -1;\n\t\tswitch_step++;\n#endif\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\t\tif (!omit_link_times) {\n\t\t\tomit_link_times = 1;\n\t\t\tif (S_ISLNK(stp->st_mode))\n\t\t\t\treturn 1;\n\t\t}\n\n#include \"case_N.h\"\n#ifdef HAVE_UTIMES\n\t\tif (do_utimes(fname, stp) == 0)\n\t\t\tbreak;\n#else\n\t\tif (do_utime(fname, stp) == 0)\n\t\t\tbreak;\n#endif\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* Create any necessary directories in fname.  Any missing directories are\n * created with default permissions.  Returns < 0 on error, or the number\n * of directories created. */\nint make_path(char *fname, int flags)\n{\n\tchar *end, *p;\n\tint ret = 0;\n\n\tif (flags & MKP_SKIP_SLASH) {\n\t\twhile (*fname == '/')\n\t\t\tfname++;\n\t}\n\n\twhile (*fname == '.' && fname[1] == '/')\n\t\tfname += 2;\n\n\tif (flags & MKP_DROP_NAME) {\n\t\tend = strrchr(fname, '/');\n\t\tif (!end || end == fname)\n\t\t\treturn 0;\n\t\t*end = '\\0';\n\t} else\n\t\tend = fname + strlen(fname);\n\n\t/* Try to find an existing dir, starting from the deepest dir. */\n\tfor (p = end; ; ) {\n\t\tif (dry_run) {\n\t\t\tSTRUCT_STAT st;\n\t\t\tif (do_stat(fname, &st) == 0) {\n\t\t\t\tif (S_ISDIR(st.st_mode))\n\t\t\t\t\terrno = EEXIST;\n\t\t\t\telse\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t}\n\t\t} else if (do_mkdir(fname, ACCESSPERMS) == 0) {\n\t\t\tret++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (errno != ENOENT) {\n\t\t\tSTRUCT_STAT st;\n\t\t\tif (errno != EEXIST || (do_stat(fname, &st) == 0 && !S_ISDIR(st.st_mode)))\n\t\t\t\tret = -ret - 1;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (p == fname) {\n\t\t\t\t/* We got a relative path that doesn't exist, so assume that '.'\n\t\t\t\t * is there and just break out and create the whole thing. */\n\t\t\t\tp = NULL;\n\t\t\t\tgoto double_break;\n\t\t\t}\n\t\t\tif (*--p == '/') {\n\t\t\t\tif (p == fname) {\n\t\t\t\t\t/* We reached the \"/\" dir, which we assume is there. */\n\t\t\t\t\tgoto double_break;\n\t\t\t\t}\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n  double_break:\n\n\t/* Make all the dirs that we didn't find on the way here. */\n\twhile (p != end) {\n\t\tif (p)\n\t\t\t*p = '/';\n\t\telse\n\t\t\tp = fname;\n\t\tp += strlen(p);\n\t\tif (ret < 0) /* Skip mkdir on error, but keep restoring the path. */\n\t\t\tcontinue;\n\t\tif (do_mkdir(fname, ACCESSPERMS) < 0)\n\t\t\tret = -ret - 1;\n\t\telse\n\t\t\tret++;\n\t}\n\n\tif (flags & MKP_DROP_NAME)\n\t\t*end = '/';\n\n\treturn ret;\n}\n\n/**\n * Write @p len bytes at @p ptr to descriptor @p desc, retrying if\n * interrupted.\n *\n * @retval len upon success\n *\n * @retval <0 write's (negative) error code\n *\n * Derived from GNU C's cccp.c.\n */\nint full_write(int desc, const char *ptr, size_t len)\n{\n\tint total_written;\n\n\ttotal_written = 0;\n\twhile (len > 0) {\n\t\tint written = write(desc, ptr, len);\n\t\tif (written < 0)  {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn written;\n\t\t}\n\t\ttotal_written += written;\n\t\tptr += written;\n\t\tlen -= written;\n\t}\n\treturn total_written;\n}\n\n/**\n * Read @p len bytes at @p ptr from descriptor @p desc, retrying if\n * interrupted.\n *\n * @retval >0 the actual number of bytes read\n *\n * @retval 0 for EOF\n *\n * @retval <0 for an error.\n *\n * Derived from GNU C's cccp.c. */\nstatic int safe_read(int desc, char *ptr, size_t len)\n{\n\tint n_chars;\n\n\tif (len == 0)\n\t\treturn len;\n\n\tdo {\n\t\tn_chars = read(desc, ptr, len);\n\t} while (n_chars < 0 && errno == EINTR);\n\n\treturn n_chars;\n}\n\n/* Remove existing file @dest and reopen, creating a new file with @mode */\nstatic int unlink_and_reopen(const char *dest, mode_t mode)\n{\n\tint ofd;\n\n\tif (robust_unlink(dest) && errno != ENOENT) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"unlink %s\", full_fname(dest));\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs)\n\t\tmode |= S_IWUSR;\n#endif\n\tmode &= INITACCESSPERMS;\n\tif ((ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, save_errno, \"open %s\", full_fname(dest));\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\treturn ofd;\n}\n\n/* Copy contents of file @source to file @dest with mode @mode.\n *\n * If @tmpfilefd is < 0, copy_file unlinks @dest and then opens a new\n * file with name @dest.\n *\n * Otherwise, copy_file writes to and closes the provided file\n * descriptor.\n *\n * In either case, if --xattrs are being preserved, the dest file will\n * have its xattrs set from the source file.\n *\n * This is used in conjunction with the --temp-dir, --backup, and\n * --copy-dest options. */\nint copy_file(const char *source, const char *dest, int tmpfilefd, mode_t mode)\n{\n\tint ifd, ofd;\n\tchar buf[1024 * 8];\n\tint len;   /* Number of bytes read into `buf'. */\n\tOFF_T prealloc_len = 0, offset = 0;\n\n\tif ((ifd = do_open(source, O_RDONLY, 0)) < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"open %s\", full_fname(source));\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tif (tmpfilefd >= 0) {\n\t\tofd = tmpfilefd;\n\t} else {\n\t\tofd = unlink_and_reopen(dest, mode);\n\t\tif (ofd < 0) {\n\t\t\tint save_errno = errno;\n\t\t\tclose(ifd);\n\t\t\terrno = save_errno;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n#ifdef SUPPORT_PREALLOCATION\n\tif (preallocate_files) {\n\t\tSTRUCT_STAT srcst;\n\n\t\t/* Try to preallocate enough space for file's eventual length.  Can\n\t\t * reduce fragmentation on filesystems like ext4, xfs, and NTFS. */\n\t\tif (do_fstat(ifd, &srcst) < 0)\n\t\t\trsyserr(FWARNING, errno, \"fstat %s\", full_fname(source));\n\t\telse if (srcst.st_size > 0) {\n\t\t\tprealloc_len = do_fallocate(ofd, 0, srcst.st_size);\n\t\t\tif (prealloc_len < 0)\n\t\t\t\trsyserr(FWARNING, errno, \"do_fallocate %s\", full_fname(dest));\n\t\t}\n\t}\n#endif\n\n\twhile ((len = safe_read(ifd, buf, sizeof buf)) > 0) {\n\t\tif (full_write(ofd, buf, len) < 0) {\n\t\t\tint save_errno = errno;\n\t\t\trsyserr(FERROR_XFER, errno, \"write %s\", full_fname(dest));\n\t\t\tclose(ifd);\n\t\t\tclose(ofd);\n\t\t\terrno = save_errno;\n\t\t\treturn -1;\n\t\t}\n\t\toffset += len;\n\t}\n\n\tif (len < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"read %s\", full_fname(source));\n\t\tclose(ifd);\n\t\tclose(ofd);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tif (close(ifd) < 0) {\n\t\trsyserr(FWARNING, errno, \"close failed on %s\",\n\t\t\tfull_fname(source));\n\t}\n\n\t/* Source file might have shrunk since we fstatted it.\n\t * Cut off any extra preallocated zeros from dest file. */\n\tif (offset < prealloc_len) {\n#ifdef HAVE_FTRUNCATE\n\t\t/* If we fail to truncate, the dest file may be wrong, so we\n\t\t * must trigger the \"partial transfer\" error. */\n\t\tif (do_ftruncate(ofd, offset) < 0)\n\t\t\trsyserr(FERROR_XFER, errno, \"ftruncate %s\", full_fname(dest));\n#else\n\t\trprintf(FERROR_XFER, \"no ftruncate for over-long pre-alloc: %s\", full_fname(dest));\n#endif\n\t}\n\n\tif (do_fsync && fsync(ofd) < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR, errno, \"fsync failed on %s\", full_fname(dest));\n\t\tclose(ofd);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tif (close(ofd) < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"close failed on %s\", full_fname(dest));\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs)\n\t\tcopy_xattrs(source, dest);\n#endif\n\n\treturn 0;\n}\n\n/* MAX_RENAMES should be 10**MAX_RENAMES_DIGITS */\n#define MAX_RENAMES_DIGITS 3\n#define MAX_RENAMES 1000\n\n/**\n * Robust unlink: some OS'es (HPUX) refuse to unlink busy files, so\n * rename to <path>/.rsyncNNN instead.\n *\n * Note that successive rsync runs will shuffle the filenames around a\n * bit as long as the file is still busy; this is because this function\n * does not know if the unlink call is due to a new file coming in, or\n * --delete trying to remove old .rsyncNNN files, hence it renames it\n * each time.\n **/\nint robust_unlink(const char *fname)\n{\n#ifndef ETXTBSY\n\treturn do_unlink(fname);\n#else\n\tstatic int counter = 1;\n\tint rc, pos, start;\n\tchar path[MAXPATHLEN];\n\n\trc = do_unlink(fname);\n\tif (rc == 0 || errno != ETXTBSY)\n\t\treturn rc;\n\n\tif ((pos = strlcpy(path, fname, MAXPATHLEN)) >= MAXPATHLEN)\n\t\tpos = MAXPATHLEN - 1;\n\n\twhile (pos > 0 && path[pos-1] != '/')\n\t\tpos--;\n\tpos += strlcpy(path+pos, \".rsync\", MAXPATHLEN-pos);\n\n\tif (pos > (MAXPATHLEN-MAX_RENAMES_DIGITS-1)) {\n\t\terrno = ETXTBSY;\n\t\treturn -1;\n\t}\n\n\t/* start where the last one left off to reduce chance of clashes */\n\tstart = counter;\n\tdo {\n\t\tsnprintf(&path[pos], MAX_RENAMES_DIGITS+1, \"%03d\", counter);\n\t\tif (++counter >= MAX_RENAMES)\n\t\t\tcounter = 1;\n\t} while ((rc = access(path, 0)) == 0 && counter != start);\n\n\tif (INFO_GTE(MISC, 1)) {\n\t\trprintf(FWARNING, \"renaming %s to %s because of text busy\\n\",\n\t\t\tfname, path);\n\t}\n\n\t/* maybe we should return rename()'s exit status? Nah. */\n\tif (do_rename(fname, path) != 0) {\n\t\terrno = ETXTBSY;\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}\n\n/* Returns 0 on successful rename, 1 if we successfully copied the file\n * across filesystems, -2 if copy_file() failed, and -1 on other errors.\n * If partialptr is not NULL and we need to do a copy, copy the file into\n * the active partial-dir instead of over the destination file. */\nint robust_rename(const char *from, const char *to, const char *partialptr,\n\t\t  int mode)\n{\n\tint tries = 4;\n\n\t/* A resumed in-place partial-dir transfer might call us with from and\n\t * to pointing to the same buf if the transfer failed yet again. */\n\tif (from == to)\n\t\treturn 0;\n\n\twhile (tries--) {\n\t\tif (do_rename(from, to) == 0)\n\t\t\treturn 0;\n\n\t\tswitch (errno) {\n#ifdef ETXTBSY\n\t\tcase ETXTBSY:\n\t\t\tif (robust_unlink(to) != 0) {\n\t\t\t\terrno = ETXTBSY;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\terrno = ETXTBSY;\n\t\t\tbreak;\n#endif\n\t\tcase EXDEV:\n\t\t\tif (partialptr) {\n\t\t\t\tif (!handle_partial_dir(partialptr,PDIR_CREATE))\n\t\t\t\t\treturn -2;\n\t\t\t\tto = partialptr;\n\t\t\t}\n\t\t\tif (copy_file(from, to, -1, mode) != 0)\n\t\t\t\treturn -2;\n\t\t\tdo_unlink(from);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic pid_t all_pids[10];\nstatic int num_pids;\n\n/** Fork and record the pid of the child. **/\npid_t do_fork(void)\n{\n\tpid_t newpid = fork();\n\n\tif (newpid != 0  &&  newpid != -1) {\n\t\tall_pids[num_pids++] = newpid;\n\t}\n\treturn newpid;\n}\n\n/**\n * Kill all children.\n *\n * @todo It would be kind of nice to make sure that they are actually\n * all our children before we kill them, because their pids may have\n * been recycled by some other process.  Perhaps when we wait for a\n * child, we should remove it from this array.  Alternatively we could\n * perhaps use process groups, but I think that would not work on\n * ancient Unix versions that don't support them.\n **/\nvoid kill_all(int sig)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pids; i++) {\n\t\t/* Let's just be a little careful where we\n\t\t * point that gun, hey?  See kill(2) for the\n\t\t * magic caused by negative values. */\n\t\tpid_t p = all_pids[i];\n\n\t\tif (p == getpid())\n\t\t\tcontinue;\n\t\tif (p <= 0)\n\t\t\tcontinue;\n\n\t\tkill(p, sig);\n\t}\n}\n\n/** Lock a byte range in a open file */\nint lock_range(int fd, int offset, int len)\n{\n\tstruct flock lock;\n\n\tlock.l_type = F_WRLCK;\n\tlock.l_whence = SEEK_SET;\n\tlock.l_start = offset;\n\tlock.l_len = len;\n\tlock.l_pid = 0;\n\n\treturn fcntl(fd,F_SETLK,&lock) == 0;\n}\n\n#define ENSURE_MEMSPACE(buf, type, sz, req) \\\n\tdo { if ((req) > sz) buf = realloc_array(buf, type, sz = MAX(sz * 2, req)); } while(0)\n\nstatic inline void call_glob_match(const char *name, int len, int from_glob,\n\t\t\t\t   char *arg, int abpos, int fbpos);\n\nstatic struct glob_data {\n\tchar *arg_buf, *filt_buf, **argv;\n\tint absize, fbsize, maxargs, argc;\n} glob;\n\nstatic void glob_match(char *arg, int abpos, int fbpos)\n{\n\tint len;\n\tchar *slash;\n\n\twhile (*arg == '.' && arg[1] == '/') {\n\t\tif (fbpos < 0) {\n\t\t\tENSURE_MEMSPACE(glob.filt_buf, char, glob.fbsize, glob.absize);\n\t\t\tmemcpy(glob.filt_buf, glob.arg_buf, abpos + 1);\n\t\t\tfbpos = abpos;\n\t\t}\n\t\tENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, abpos + 3);\n\t\tglob.arg_buf[abpos++] = *arg++;\n\t\tglob.arg_buf[abpos++] = *arg++;\n\t\tglob.arg_buf[abpos] = '\\0';\n\t}\n\tif ((slash = strchr(arg, '/')) != NULL) {\n\t\t*slash = '\\0';\n\t\tlen = slash - arg;\n\t} else\n\t\tlen = strlen(arg);\n\tif (strpbrk(arg, \"*?[\")) {\n\t\tstruct dirent *di;\n\t\tDIR *d;\n\n\t\tif (!(d = opendir(abpos ? glob.arg_buf : \".\")))\n\t\t\treturn;\n\t\twhile ((di = readdir(d)) != NULL) {\n\t\t\tchar *dname = d_name(di);\n\t\t\tif (dname[0] == '.' && (dname[1] == '\\0'\n\t\t\t  || (dname[1] == '.' && dname[2] == '\\0')))\n\t\t\t\tcontinue;\n\t\t\tif (!wildmatch(arg, dname))\n\t\t\t\tcontinue;\n\t\t\tcall_glob_match(dname, strlen(dname), 1,\n\t\t\t\t\tslash ? arg + len + 1 : NULL,\n\t\t\t\t\tabpos, fbpos);\n\t\t}\n\t\tclosedir(d);\n\t} else {\n\t\tcall_glob_match(arg, len, 0,\n\t\t\t\tslash ? arg + len + 1 : NULL,\n\t\t\t\tabpos, fbpos);\n\t}\n\tif (slash)\n\t\t*slash = '/';\n}\n\nstatic inline void call_glob_match(const char *name, int len, int from_glob,\n\t\t\t\t   char *arg, int abpos, int fbpos)\n{\n\tchar *use_buf;\n\n\tENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, abpos + len + 2);\n\tmemcpy(glob.arg_buf + abpos, name, len);\n\tabpos += len;\n\tglob.arg_buf[abpos] = '\\0';\n\n\tif (fbpos >= 0) {\n\t\tENSURE_MEMSPACE(glob.filt_buf, char, glob.fbsize, fbpos + len + 2);\n\t\tmemcpy(glob.filt_buf + fbpos, name, len);\n\t\tfbpos += len;\n\t\tglob.filt_buf[fbpos] = '\\0';\n\t\tuse_buf = glob.filt_buf;\n\t} else\n\t\tuse_buf = glob.arg_buf;\n\n\tif (from_glob || (arg && len)) {\n\t\tSTRUCT_STAT st;\n\t\tint is_dir;\n\n\t\tif (do_stat(glob.arg_buf, &st) != 0)\n\t\t\treturn;\n\t\tis_dir = S_ISDIR(st.st_mode) != 0;\n\t\tif (arg && !is_dir)\n\t\t\treturn;\n\n\t\tif (daemon_filter_list.head\n\t\t && check_filter(&daemon_filter_list, FLOG, use_buf, is_dir) < 0)\n\t\t\treturn;\n\t}\n\n\tif (arg) {\n\t\tglob.arg_buf[abpos++] = '/';\n\t\tglob.arg_buf[abpos] = '\\0';\n\t\tif (fbpos >= 0) {\n\t\t\tglob.filt_buf[fbpos++] = '/';\n\t\t\tglob.filt_buf[fbpos] = '\\0';\n\t\t}\n\t\tglob_match(arg, abpos, fbpos);\n\t} else {\n\t\tENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, glob.argc + 1);\n\t\tglob.argv[glob.argc++] = strdup(glob.arg_buf);\n\t}\n}\n\n/* This routine performs wild-card expansion of the pathname in \"arg\".  Any\n * daemon-excluded files/dirs will not be matched by the wildcards.  Returns 0\n * if a wild-card string is the only returned item (due to matching nothing). */\nint glob_expand(const char *arg, char ***argv_p, int *argc_p, int *maxargs_p)\n{\n\tint ret, save_argc;\n\tchar *s;\n\n\tif (!arg) {\n\t\tif (glob.filt_buf)\n\t\t\tfree(glob.filt_buf);\n\t\tfree(glob.arg_buf);\n\t\tmemset(&glob, 0, sizeof glob);\n\t\treturn -1;\n\t}\n\n\tif (sanitize_paths)\n\t\ts = sanitize_path(NULL, arg, \"\", 0, SP_KEEP_DOT_DIRS);\n\telse {\n\t\ts = strdup(arg);\n\t\tclean_fname(s, CFN_KEEP_DOT_DIRS | CFN_KEEP_TRAILING_SLASH | CFN_COLLAPSE_DOT_DOT_DIRS);\n\t}\n\n\tENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, MAXPATHLEN);\n\t*glob.arg_buf = '\\0';\n\n\tglob.argc = save_argc = *argc_p;\n\tglob.argv = *argv_p;\n\tglob.maxargs = *maxargs_p;\n\n\tENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, 100);\n\n\tglob_match(s, 0, -1);\n\n\t/* The arg didn't match anything, so add the failed arg to the list. */\n\tif (glob.argc == save_argc) {\n\t\tENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, glob.argc + 1);\n\t\tglob.argv[glob.argc++] = s;\n\t\tret = 0;\n\t} else {\n\t\tfree(s);\n\t\tret = 1;\n\t}\n\n\t*maxargs_p = glob.maxargs;\n\t*argv_p = glob.argv;\n\t*argc_p = glob.argc;\n\n\treturn ret;\n}\n\n/* This routine is only used in daemon mode. */\nvoid glob_expand_module(char *base1, char *arg, char ***argv_p, int *argc_p, int *maxargs_p)\n{\n\tchar *p, *s;\n\tchar *base = base1;\n\tint base_len = strlen(base);\n\n\tif (!arg || !*arg)\n\t\treturn;\n\n\tif (strncmp(arg, base, base_len) == 0)\n\t\targ += base_len;\n\n\tif (protect_args) {\n\t\tglob_expand(arg, argv_p, argc_p, maxargs_p);\n\t\treturn;\n\t}\n\n\targ = strdup(arg);\n\n\tif (asprintf(&base,\" %s/\", base1) < 0)\n\t\tout_of_memory(\"glob_expand_module\");\n\tbase_len++;\n\n\tfor (s = arg; *s; s = p + base_len) {\n\t\tif ((p = strstr(s, base)) != NULL)\n\t\t\t*p = '\\0'; /* split it at this point */\n\t\tglob_expand(s, argv_p, argc_p, maxargs_p);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tfree(arg);\n\tfree(base);\n}\n\n/**\n * Convert a string to lower case\n **/\nvoid strlower(char *s)\n{\n\twhile (*s) {\n\t\tif (isUpper(s))\n\t\t\t*s = toLower(s);\n\t\ts++;\n\t}\n}\n\n/**\n * Split a string into tokens based (usually) on whitespace & commas.  If the\n * string starts with a comma (after skipping any leading whitespace), then\n * splitting is done only on commas. No empty tokens are ever returned. */\nchar *conf_strtok(char *str)\n{\n\tstatic int commas_only = 0;\n\n\tif (str) {\n\t\twhile (isSpace(str)) str++;\n\t\tif (*str == ',') {\n\t\t\tcommas_only = 1;\n\t\t\tstr++;\n\t\t} else\n\t\t\tcommas_only = 0;\n\t}\n\n\twhile (commas_only) {\n\t\tchar *end, *tok = strtok(str, \",\");\n\t\tif (!tok)\n\t\t\treturn NULL;\n\t\t/* Trim just leading and trailing whitespace. */\n\t\twhile (isSpace(tok))\n\t\t\ttok++;\n\t\tend = tok + strlen(tok);\n\t\twhile (end > tok && isSpace(end-1))\n\t\t\t*--end = '\\0';\n\t\tif (*tok)\n\t\t\treturn tok;\n\t\tstr = NULL;\n\t}\n\n\treturn strtok(str, \" ,\\t\\r\\n\");\n}\n\n/* Join strings p1 & p2 into \"dest\" with a guaranteed '/' between them.  (If\n * p1 ends with a '/', no extra '/' is inserted.)  Returns the length of both\n * strings + 1 (if '/' was inserted), regardless of whether the null-terminated\n * string fits into destsize. */\nsize_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2)\n{\n\tsize_t len = strlcpy(dest, p1, destsize);\n\tif (len < destsize - 1) {\n\t\tif (!len || dest[len-1] != '/')\n\t\t\tdest[len++] = '/';\n\t\tif (len < destsize - 1)\n\t\t\tlen += strlcpy(dest + len, p2, destsize - len);\n\t\telse {\n\t\t\tdest[len] = '\\0';\n\t\t\tlen += strlen(p2);\n\t\t}\n\t}\n\telse\n\t\tlen += strlen(p2) + 1; /* Assume we'd insert a '/'. */\n\treturn len;\n}\n\n/* Join any number of strings together, putting them in \"dest\".  The return\n * value is the length of all the strings, regardless of whether the null-\n * terminated whole fits in destsize.  Your list of string pointers must end\n * with a NULL to indicate the end of the list. */\nsize_t stringjoin(char *dest, size_t destsize, ...)\n{\n\tva_list ap;\n\tsize_t len, ret = 0;\n\tconst char *src;\n\n\tva_start(ap, destsize);\n\twhile (1) {\n\t\tif (!(src = va_arg(ap, const char *)))\n\t\t\tbreak;\n\t\tlen = strlen(src);\n\t\tret += len;\n\t\tif (destsize > 1) {\n\t\t\tif (len >= destsize)\n\t\t\t\tlen = destsize - 1;\n\t\t\tmemcpy(dest, src, len);\n\t\t\tdestsize -= len;\n\t\t\tdest += len;\n\t\t}\n\t}\n\t*dest = '\\0';\n\tva_end(ap);\n\n\treturn ret;\n}\n\nint count_dir_elements(const char *p)\n{\n\tint cnt = 0, new_component = 1;\n\twhile (*p) {\n\t\tif (*p++ == '/')\n\t\t\tnew_component = (*p != '.' || (p[1] != '/' && p[1] != '\\0'));\n\t\telse if (new_component) {\n\t\t\tnew_component = 0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n/* Turns multiple adjacent slashes into a single slash (possible exception:\n * the preserving of two leading slashes at the start), drops all leading or\n * interior \".\" elements unless CFN_KEEP_DOT_DIRS is flagged.  Will also drop\n * a trailing '.' after a '/' if CFN_DROP_TRAILING_DOT_DIR is flagged, removes\n * a trailing slash (perhaps after removing the aforementioned dot) unless\n * CFN_KEEP_TRAILING_SLASH is flagged, and will also collapse \"..\" elements\n * (except at the start) if CFN_COLLAPSE_DOT_DOT_DIRS is flagged.  If the\n * resulting name would be empty, returns \".\". */\nint clean_fname(char *name, int flags)\n{\n\tchar *limit = name - 1, *t = name, *f = name;\n\tint anchored;\n\n\tif (!name)\n\t\treturn 0;\n\n#define DOT_IS_DOT_DOT_DIR(bp) (bp[1] == '.' && (bp[2] == '/' || !bp[2]))\n\n\tif ((anchored = *f == '/') != 0) {\n\t\t*t++ = *f++;\n#ifdef __CYGWIN__\n\t\t/* If there are exactly 2 slashes at the start, preserve\n\t\t * them.  Would break daemon excludes unless the paths are\n\t\t * really treated differently, so used this sparingly. */\n\t\tif (*f == '/' && f[1] != '/')\n\t\t\t*t++ = *f++;\n#endif\n\t} else if (flags & CFN_KEEP_DOT_DIRS && *f == '.' && f[1] == '/') {\n\t\t*t++ = *f++;\n\t\t*t++ = *f++;\n\t} else if (flags & CFN_REFUSE_DOT_DOT_DIRS && *f == '.' && DOT_IS_DOT_DOT_DIR(f))\n\t\treturn -1;\n\twhile (*f) {\n\t\t/* discard extra slashes */\n\t\tif (*f == '/') {\n\t\t\tf++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*f == '.') {\n\t\t\t/* discard interior \".\" dirs */\n\t\t\tif (f[1] == '/' && !(flags & CFN_KEEP_DOT_DIRS)) {\n\t\t\t\tf += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f[1] == '\\0' && flags & CFN_DROP_TRAILING_DOT_DIR)\n\t\t\t\tbreak;\n\t\t\t/* collapse \"..\" dirs */\n\t\t\tif (flags & (CFN_COLLAPSE_DOT_DOT_DIRS|CFN_REFUSE_DOT_DOT_DIRS) && DOT_IS_DOT_DOT_DIR(f)) {\n\t\t\t\tchar *s = t - 1;\n\t\t\t\tif (flags & CFN_REFUSE_DOT_DOT_DIRS)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (s == name && anchored) {\n\t\t\t\t\tf += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (s > limit && *--s != '/') {}\n\t\t\t\tif (s != t - 1 && (s < name || *s == '/')) {\n\t\t\t\t\tt = s + 1;\n\t\t\t\t\tf += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlimit = t + 2;\n\t\t\t}\n\t\t}\n\t\twhile (*f && (*t++ = *f++) != '/') {}\n\t}\n\n\tif (t > name+anchored && t[-1] == '/' && !(flags & CFN_KEEP_TRAILING_SLASH))\n\t\tt--;\n\tif (t == name)\n\t\t*t++ = '.';\n\t*t = '\\0';\n\n#undef DOT_IS_DOT_DOT_DIR\n\n\treturn t - name;\n}\n\n/* Make path appear as if a chroot had occurred.  This handles a leading\n * \"/\" (either removing it or expanding it) and any leading or embedded\n * \"..\" components that attempt to escape past the module's top dir.\n *\n * If dest is NULL, a buffer is allocated to hold the result.  It is legal\n * to call with the dest and the path (p) pointing to the same buffer, but\n * rootdir will be ignored to avoid expansion of the string.\n *\n * The rootdir string contains a value to use in place of a leading slash.\n * Specify NULL to get the default of \"module_dir\".\n *\n * The depth var is a count of how many '..'s to allow at the start of the\n * path.\n *\n * We also clean the path in a manner similar to clean_fname() but with a\n * few differences:\n *\n * Turns multiple adjacent slashes into a single slash, gets rid of \".\" dir\n * elements (INCLUDING a trailing dot dir), PRESERVES a trailing slash, and\n * ALWAYS collapses \"..\" elements (except for those at the start of the\n * string up to \"depth\" deep).  If the resulting name would be empty,\n * change it into a \".\". */\nchar *sanitize_path(char *dest, const char *p, const char *rootdir, int depth, int flags)\n{\n\tchar *start, *sanp;\n\tint rlen = 0, drop_dot_dirs = !relative_paths || !(flags & SP_KEEP_DOT_DIRS);\n\n\tif (dest != p) {\n\t\tint plen = strlen(p); /* the path len INCLUDING any separating slash */\n\t\tif (*p == '/') {\n\t\t\tif (!rootdir)\n\t\t\t\trootdir = module_dir;\n\t\t\trlen = strlen(rootdir);\n\t\t\tdepth = 0;\n\t\t\tp++;\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new_array(char, MAX(rlen + plen + 1, 2));\n\t\telse if (rlen + plen + 1 >= MAXPATHLEN)\n\t\t\treturn NULL;\n\t\tif (rlen) { /* only true if p previously started with a slash */\n\t\t\tmemcpy(dest, rootdir, rlen);\n\t\t\tif (rlen > 1) /* a rootdir of len 1 is \"/\", so this avoids a 2nd slash */\n\t\t\t\tdest[rlen++] = '/';\n\t\t}\n\t}\n\n\tif (drop_dot_dirs) {\n\t\twhile (*p == '.' && p[1] == '/')\n\t\t\tp += 2;\n\t}\n\n\tstart = sanp = dest + rlen;\n\t/* This loop iterates once per filename component in p, pointing at\n\t * the start of the name (past any prior slash) for each iteration. */\n\twhile (*p) {\n\t\t/* discard leading or extra slashes */\n\t\tif (*p == '/') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (drop_dot_dirs) {\n\t\t\tif (*p == '.' && (p[1] == '/' || p[1] == '\\0')) {\n\t\t\t\t/* skip \".\" component */\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\0')) {\n\t\t\t/* \"..\" component followed by slash or end */\n\t\t\tif (depth <= 0 || sanp != start) {\n\t\t\t\tp += 2;\n\t\t\t\tif (sanp != start) {\n\t\t\t\t\t/* back up sanp one level */\n\t\t\t\t\t--sanp; /* now pointing at slash */\n\t\t\t\t\twhile (sanp > start && sanp[-1] != '/')\n\t\t\t\t\t\tsanp--;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* allow depth levels of .. at the beginning */\n\t\t\tdepth--;\n\t\t\t/* move the virtual beginning to leave the .. alone */\n\t\t\tstart = sanp + 3;\n\t\t}\n\t\t/* copy one component through next slash */\n\t\twhile (*p && (*sanp++ = *p++) != '/') {}\n\t}\n\tif (sanp == dest) {\n\t\t/* ended up with nothing, so put in \".\" component */\n\t\t*sanp++ = '.';\n\t}\n\t*sanp = '\\0';\n\n\treturn dest;\n}\n\n/* Like chdir(), but it keeps track of the current directory (in the\n * global \"curr_dir\"), and ensures that the path size doesn't overflow.\n * Also cleans the path using the clean_fname() function. */\nint change_dir(const char *dir, int set_path_only)\n{\n\tstatic int initialised, skipped_chdir;\n\tunsigned int len;\n\n\tif (!initialised) {\n\t\tinitialised = 1;\n\t\tif (getcwd(curr_dir, sizeof curr_dir - 1) == NULL) {\n\t\t\trsyserr(FERROR, errno, \"getcwd()\");\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t\tcurr_dir_len = strlen(curr_dir);\n\t}\n\n\tif (!dir)\t/* this call was probably just to initialize */\n\t\treturn 0;\n\n\tlen = strlen(dir);\n\tif (len == 1 && *dir == '.' && (!skipped_chdir || set_path_only))\n\t\treturn 1;\n\n\tif (*dir == '/') {\n\t\tif (len >= sizeof curr_dir) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!set_path_only && chdir(dir))\n\t\t\treturn 0;\n\t\tskipped_chdir = set_path_only;\n\t\tmemcpy(curr_dir, dir, len + 1);\n\t} else {\n\t\tunsigned int save_dir_len = curr_dir_len;\n\t\tif (curr_dir_len + 1 + len >= sizeof curr_dir) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(curr_dir_len && curr_dir[curr_dir_len-1] == '/'))\n\t\t\tcurr_dir[curr_dir_len++] = '/';\n\t\tmemcpy(curr_dir + curr_dir_len, dir, len + 1);\n\n\t\tif (!set_path_only && chdir(curr_dir)) {\n\t\t\tcurr_dir_len = save_dir_len;\n\t\t\tcurr_dir[curr_dir_len] = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tskipped_chdir = set_path_only;\n\t}\n\n\tcurr_dir_len = clean_fname(curr_dir, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);\n\tif (sanitize_paths) {\n\t\tif (module_dirlen > curr_dir_len)\n\t\t\tmodule_dirlen = curr_dir_len;\n\t\tcurr_dir_depth = count_dir_elements(curr_dir + module_dirlen);\n\t}\n\n\tif (DEBUG_GTE(CHDIR, 1) && !set_path_only)\n\t\trprintf(FINFO, \"[%s] change_dir(%s)\\n\", who_am_i(), curr_dir);\n\n\treturn 1;\n}\n\n/* This will make a relative path absolute and clean it up via clean_fname().\n * Returns the string, which might be newly allocated, or NULL on error. */\nchar *normalize_path(char *path, BOOL force_newbuf, unsigned int *len_ptr)\n{\n\tunsigned int len;\n\n\tif (*path != '/') { /* Make path absolute. */\n\t\tint len = strlen(path);\n\t\tif (curr_dir_len + 1 + len >= sizeof curr_dir)\n\t\t\treturn NULL;\n\t\tcurr_dir[curr_dir_len] = '/';\n\t\tmemcpy(curr_dir + curr_dir_len + 1, path, len + 1);\n\t\tpath = strdup(curr_dir);\n\t\tcurr_dir[curr_dir_len] = '\\0';\n\t} else if (force_newbuf)\n\t\tpath = strdup(path);\n\n\tlen = clean_fname(path, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);\n\n\tif (len_ptr)\n\t\t*len_ptr = len;\n\n\treturn path;\n}\n\n/**\n * Return a quoted string with the full pathname of the indicated filename.\n * The string \" (in MODNAME)\" may also be appended.  The returned pointer\n * remains valid until the next time full_fname() is called.\n **/\nchar *full_fname(const char *fn)\n{\n\tstatic char *result = NULL;\n\tchar *m1, *m2, *m3;\n\tchar *p1, *p2;\n\n\tif (result)\n\t\tfree(result);\n\n\tif (*fn == '/')\n\t\tp1 = p2 = \"\";\n\telse {\n\t\tp1 = curr_dir + module_dirlen;\n\t\tfor (p2 = p1; *p2 == '/'; p2++) {}\n\t\tif (*p2)\n\t\t\tp2 = \"/\";\n\t}\n\tif (module_id >= 0) {\n\t\tm1 = \" (in \";\n\t\tm2 = lp_name(module_id);\n\t\tm3 = \")\";\n\t} else\n\t\tm1 = m2 = m3 = \"\";\n\n\tif (asprintf(&result, \"\\\"%s%s%s\\\"%s%s%s\", p1, p2, fn, m1, m2, m3) < 0)\n\t\tout_of_memory(\"full_fname\");\n\n\treturn result;\n}\n\nstatic char partial_fname[MAXPATHLEN];\n\nchar *partial_dir_fname(const char *fname)\n{\n\tchar *t = partial_fname;\n\tint sz = sizeof partial_fname;\n\tconst char *fn;\n\n\tif ((fn = strrchr(fname, '/')) != NULL) {\n\t\tfn++;\n\t\tif (*partial_dir != '/') {\n\t\t\tint len = fn - fname;\n\t\t\tstrncpy(t, fname, len); /* safe */\n\t\t\tt += len;\n\t\t\tsz -= len;\n\t\t}\n\t} else\n\t\tfn = fname;\n\tif ((int)pathjoin(t, sz, partial_dir, fn) >= sz)\n\t\treturn NULL;\n\tif (daemon_filter_list.head) {\n\t\tt = strrchr(partial_fname, '/');\n\t\t*t = '\\0';\n\t\tif (check_filter(&daemon_filter_list, FLOG, partial_fname, 1) < 0)\n\t\t\treturn NULL;\n\t\t*t = '/';\n\t\tif (check_filter(&daemon_filter_list, FLOG, partial_fname, 0) < 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn partial_fname;\n}\n\n/* If no --partial-dir option was specified, we don't need to do anything\n * (the partial-dir is essentially '.'), so just return success. */\nint handle_partial_dir(const char *fname, int create)\n{\n\tchar *fn, *dir;\n\n\tif (fname != partial_fname)\n\t\treturn 1;\n\tif (!create && *partial_dir == '/')\n\t\treturn 1;\n\tif (!(fn = strrchr(partial_fname, '/')))\n\t\treturn 1;\n\n\t*fn = '\\0';\n\tdir = partial_fname;\n\tif (create) {\n\t\tSTRUCT_STAT st;\n\t\tint statret = do_lstat(dir, &st);\n\t\tif (statret == 0 && !S_ISDIR(st.st_mode)) {\n\t\t\tif (do_unlink(dir) < 0) {\n\t\t\t\t*fn = '/';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstatret = -1;\n\t\t}\n\t\tif (statret < 0 && do_mkdir(dir, 0700) < 0) {\n\t\t\t*fn = '/';\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tdo_rmdir(dir);\n\t*fn = '/';\n\n\treturn 1;\n}\n\n/* Determine if a symlink points outside the current directory tree.\n * This is considered \"unsafe\" because e.g. when mirroring somebody\n * else's machine it might allow them to establish a symlink to\n * /etc/passwd, and then read it through a web server.\n *\n * Returns 1 if unsafe, 0 if safe.\n *\n * Null symlinks and absolute symlinks are always unsafe.\n *\n * Basically here we are concerned with symlinks whose target contains\n * \"..\", because this might cause us to walk back up out of the\n * transferred directory.  We are not allowed to go back up and\n * reenter.\n *\n * \"dest\" is the target of the symlink in question.\n *\n * \"src\" is the top source directory currently applicable at the level\n * of the referenced symlink.  This is usually the symlink's full path\n * (including its name), as referenced from the root of the transfer. */\nint unsafe_symlink(const char *dest, const char *src)\n{\n\tconst char *name, *slash;\n\tint depth = 0;\n\n\t/* all absolute and null symlinks are unsafe */\n\tif (!dest || !*dest || *dest == '/')\n\t\treturn 1;\n\n\t/* find out what our safety margin is */\n\tfor (name = src; (slash = strchr(name, '/')) != 0; name = slash+1) {\n\t\t/* \"..\" segment starts the count over.  \".\" segment is ignored. */\n\t\tif (*name == '.' && (name[1] == '/' || (name[1] == '.' && name[2] == '/'))) {\n\t\t\tif (name[1] == '.')\n\t\t\t\tdepth = 0;\n\t\t} else\n\t\t\tdepth++;\n\t\twhile (slash[1] == '/') slash++; /* just in case src isn't clean */\n\t}\n\tif (*name == '.' && name[1] == '.' && name[2] == '\\0')\n\t\tdepth = 0;\n\n\tfor (name = dest; (slash = strchr(name, '/')) != 0; name = slash+1) {\n\t\tif (*name == '.' && (name[1] == '/' || (name[1] == '.' && name[2] == '/'))) {\n\t\t\tif (name[1] == '.') {\n\t\t\t\t/* if at any point we go outside the current directory\n\t\t\t\t   then stop - it is unsafe */\n\t\t\t\tif (--depth < 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else\n\t\t\tdepth++;\n\t\twhile (slash[1] == '/') slash++;\n\t}\n\tif (*name == '.' && name[1] == '.' && name[2] == '\\0')\n\t\tdepth--;\n\n\treturn depth < 0;\n}\n\n/* Return the date and time as a string.  Some callers tweak returned buf. */\nchar *timestring(time_t t)\n{\n\tstatic int ndx = 0;\n\tstatic char buffers[4][20]; /* We support 4 simultaneous timestring results. */\n\tchar *TimeBuf = buffers[ndx = (ndx + 1) % 4];\n\tstruct tm *tm = localtime(&t);\n\tint len = snprintf(TimeBuf, sizeof buffers[0], \"%4d/%02d/%02d %02d:%02d:%02d\",\n\t\t (int)tm->tm_year + 1900, (int)tm->tm_mon + 1, (int)tm->tm_mday,\n\t\t (int)tm->tm_hour, (int)tm->tm_min, (int)tm->tm_sec);\n\tassert(len > 0); /* Silence gcc warning */\n\n\treturn TimeBuf;\n}\n\n/* Determine if two time_t values are equivalent (either exact, or in\n * the modification timestamp window established by --modify-window).\n * Returns 1 if the times the \"same\", or 0 if they are different. */\nint same_time(time_t f1_sec, unsigned long f1_nsec, time_t f2_sec, unsigned long f2_nsec)\n{\n\tif (modify_window == 0)\n\t\treturn f1_sec == f2_sec;\n\tif (modify_window < 0)\n\t\treturn f1_sec == f2_sec && f1_nsec == f2_nsec;\n\t/* The nanoseconds do not figure into these checks -- time windows don't care about that. */\n\tif (f2_sec > f1_sec)\n\t\treturn f2_sec - f1_sec <= modify_window;\n\treturn f1_sec - f2_sec <= modify_window;\n}\n\n#ifdef __INSURE__XX\n#include <dlfcn.h>\n\n/**\n   This routine is a trick to immediately catch errors when debugging\n   with insure. A xterm with a gdb is popped up when insure catches\n   a error. It is Linux specific.\n**/\nint _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6)\n{\n\tstatic int (*fn)();\n\tint ret, pid_int = getpid();\n\tchar *cmd;\n\n\tif (asprintf(&cmd,\n\t    \"/usr/X11R6/bin/xterm -display :0 -T Panic -n Panic -e /bin/sh -c 'cat /tmp/ierrs.*.%d ; \"\n\t    \"gdb /proc/%d/exe %d'\", pid_int, pid_int, pid_int) < 0)\n\t\treturn -1;\n\n\tif (!fn) {\n\t\tstatic void *h;\n\t\th = dlopen(\"/usr/local/parasoft/insure++lite/lib.linux2/libinsure.so\", RTLD_LAZY);\n\t\tfn = dlsym(h, \"_Insure_trap_error\");\n\t}\n\n\tret = fn(a1, a2, a3, a4, a5, a6);\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\n\treturn ret;\n}\n#endif\n\n/* Take a filename and filename length and return the most significant\n * filename suffix we can find.  This ignores suffixes such as \"~\",\n * \".bak\", \".orig\", \".~1~\", etc. */\nconst char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)\n{\n\tconst char *suf, *s;\n\tBOOL had_tilde;\n\tint s_len;\n\n\t/* One or more dots at the start aren't a suffix. */\n\twhile (fn_len && *fn == '.') fn++, fn_len--;\n\n\t/* Ignore the ~ in a \"foo~\" filename. */\n\tif (fn_len > 1 && fn[fn_len-1] == '~')\n\t\tfn_len--, had_tilde = True;\n\telse\n\t\thad_tilde = False;\n\n\t/* Assume we don't find an suffix. */\n\tsuf = \"\";\n\t*len_ptr = 0;\n\n\t/* Find the last significant suffix. */\n\tfor (s = fn + fn_len; fn_len > 1; ) {\n\t\twhile (*--s != '.' && s != fn) {}\n\t\tif (s == fn)\n\t\t\tbreak;\n\t\ts_len = fn_len - (s - fn);\n\t\tfn_len = s - fn;\n\t\tif (s_len == 4) {\n\t\t\tif (strcmp(s+1, \"bak\") == 0\n\t\t\t || strcmp(s+1, \"old\") == 0)\n\t\t\t\tcontinue;\n\t\t} else if (s_len == 5) {\n\t\t\tif (strcmp(s+1, \"orig\") == 0)\n\t\t\t\tcontinue;\n\t\t} else if (s_len > 2 && had_tilde && s[1] == '~' && isDigit(s + 2))\n\t\t\tcontinue;\n\t\t*len_ptr = s_len;\n\t\tsuf = s;\n\t\tif (s_len == 1)\n\t\t\tbreak;\n\t\t/* Determine if the suffix is all digits. */\n\t\tfor (s++, s_len--; s_len > 0; s++, s_len--) {\n\t\t\tif (!isDigit(s))\n\t\t\t\treturn suf;\n\t\t}\n\t\t/* An all-digit suffix may not be that significant. */\n\t\ts = suf;\n\t}\n\n\treturn suf;\n}\n\n/* This is an implementation of the Levenshtein distance algorithm.  It\n * was implemented to avoid needing a two-dimensional matrix (to save\n * memory).  It was also tweaked to try to factor in the ASCII distance\n * between changed characters as a minor distance quantity.  The normal\n * Levenshtein units of distance (each signifying a single change between\n * the two strings) are defined as a \"UNIT\". */\n\n#define UNIT (1 << 16)\n\nuint32 fuzzy_distance(const char *s1, unsigned len1, const char *s2, unsigned len2, uint32 upperlimit)\n{\n\tuint32 a[MAXPATHLEN], diag, above, left, diag_inc, above_inc, left_inc;\n\tint32 cost;\n\tunsigned i1, i2;\n\n\t/* Check to see if the Levenshtein distance must be greater than the\n\t * upper limit defined by the previously found lowest distance using\n\t * the heuristic that the Levenshtein distance is greater than the\n\t * difference in length of the two strings */\n\tif ((len1 > len2 ? len1 - len2 : len2 - len1) * UNIT > upperlimit)\n\t\treturn 0xFFFFU * UNIT + 1;\n\n\tif (!len1 || !len2) {\n\t\tif (!len1) {\n\t\t\ts1 = s2;\n\t\t\tlen1 = len2;\n\t\t}\n\t\tfor (i1 = 0, cost = 0; i1 < len1; i1++)\n\t\t\tcost += s1[i1];\n\t\treturn (int32)len1 * UNIT + cost;\n\t}\n\n\tfor (i2 = 0; i2 < len2; i2++)\n\t\ta[i2] = (i2+1) * UNIT;\n\n\tfor (i1 = 0; i1 < len1; i1++) {\n\t\tdiag = i1 * UNIT;\n\t\tabove = (i1+1) * UNIT;\n\t\tfor (i2 = 0; i2 < len2; i2++) {\n\t\t\tleft = a[i2];\n\t\t\tif ((cost = *((uchar*)s1+i1) - *((uchar*)s2+i2)) != 0) {\n\t\t\t\tif (cost < 0)\n\t\t\t\t\tcost = UNIT - cost;\n\t\t\t\telse\n\t\t\t\t\tcost = UNIT + cost;\n\t\t\t}\n\t\t\tdiag_inc = diag + cost;\n\t\t\tleft_inc = left + UNIT + *((uchar*)s1+i1);\n\t\t\tabove_inc = above + UNIT + *((uchar*)s2+i2);\n\t\t\ta[i2] = above = left < above\n\t\t\t      ? (left_inc < diag_inc ? left_inc : diag_inc)\n\t\t\t      : (above_inc < diag_inc ? above_inc : diag_inc);\n\t\t\tdiag = left;\n\t\t}\n\t}\n\n\treturn a[len2-1];\n}\n\n#define BB_SLOT_SIZE     (16*1024)          /* Desired size in bytes */\n#define BB_PER_SLOT_BITS (BB_SLOT_SIZE * 8) /* Number of bits per slot */\n#define BB_PER_SLOT_INTS (BB_SLOT_SIZE / 4) /* Number of int32s per slot */\n\nstruct bitbag {\n\tuint32 **bits;\n\tint slot_cnt;\n};\n\nstruct bitbag *bitbag_create(int max_ndx)\n{\n\tstruct bitbag *bb = new(struct bitbag);\n\tbb->slot_cnt = (max_ndx + BB_PER_SLOT_BITS - 1) / BB_PER_SLOT_BITS;\n\n\tbb->bits = new_array0(uint32*, bb->slot_cnt);\n\n\treturn bb;\n}\n\nvoid bitbag_set_bit(struct bitbag *bb, int ndx)\n{\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tif (!bb->bits[slot])\n\t\tbb->bits[slot] = new_array0(uint32, BB_PER_SLOT_INTS);\n\n\tbb->bits[slot][ndx/32] |= 1u << (ndx % 32);\n}\n\n#if 0 /* not needed yet */\nvoid bitbag_clear_bit(struct bitbag *bb, int ndx)\n{\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tif (!bb->bits[slot])\n\t\treturn;\n\n\tbb->bits[slot][ndx/32] &= ~(1u << (ndx % 32));\n}\n\nint bitbag_check_bit(struct bitbag *bb, int ndx)\n{\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tif (!bb->bits[slot])\n\t\treturn 0;\n\n\treturn bb->bits[slot][ndx/32] & (1u << (ndx % 32)) ? 1 : 0;\n}\n#endif\n\n/* Call this with -1 to start checking from 0.  Returns -1 at the end. */\nint bitbag_next_bit(struct bitbag *bb, int after)\n{\n\tuint32 bits, mask;\n\tint i, ndx = after + 1;\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tmask = (1u << (ndx % 32)) - 1;\n\tfor (i = ndx / 32; slot < bb->slot_cnt; slot++, i = mask = 0) {\n\t\tif (!bb->bits[slot])\n\t\t\tcontinue;\n\t\tfor ( ; i < BB_PER_SLOT_INTS; i++, mask = 0) {\n\t\t\tif (!(bits = bb->bits[slot][i] & ~mask))\n\t\t\t\tcontinue;\n\t\t\t/* The xor magic figures out the lowest enabled bit in\n\t\t\t * bits, and the switch quickly computes log2(bit). */\n\t\t\tswitch (bits ^ (bits & (bits-1))) {\n#define LOG2(n) case 1u << n: return slot*BB_PER_SLOT_BITS + i*32 + n\n\t\t\t    LOG2(0);  LOG2(1);  LOG2(2);  LOG2(3);\n\t\t\t    LOG2(4);  LOG2(5);  LOG2(6);  LOG2(7);\n\t\t\t    LOG2(8);  LOG2(9);  LOG2(10); LOG2(11);\n\t\t\t    LOG2(12); LOG2(13); LOG2(14); LOG2(15);\n\t\t\t    LOG2(16); LOG2(17); LOG2(18); LOG2(19);\n\t\t\t    LOG2(20); LOG2(21); LOG2(22); LOG2(23);\n\t\t\t    LOG2(24); LOG2(25); LOG2(26); LOG2(27);\n\t\t\t    LOG2(28); LOG2(29); LOG2(30); LOG2(31);\n\t\t\t}\n\t\t\treturn -1; /* impossible... */\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid flist_ndx_push(flist_ndx_list *lp, int ndx)\n{\n\tstruct flist_ndx_item *item;\n\n\titem = new(struct flist_ndx_item);\n\titem->next = NULL;\n\titem->ndx = ndx;\n\tif (lp->tail)\n\t\tlp->tail->next = item;\n\telse\n\t\tlp->head = item;\n\tlp->tail = item;\n}\n\nint flist_ndx_pop(flist_ndx_list *lp)\n{\n\tstruct flist_ndx_item *next;\n\tint ndx;\n\n\tif (!lp->head)\n\t\treturn -1;\n\n\tndx = lp->head->ndx;\n\tnext = lp->head->next;\n\tfree(lp->head);\n\tlp->head = next;\n\tif (!next)\n\t\tlp->tail = NULL;\n\n\treturn ndx;\n}\n\n/* Make sure there is room for one more item in the item list.  If there\n * is not, expand the list as indicated by the value of \"incr\":\n *  - if incr < 0 then increase the malloced size by -1 * incr\n *  - if incr >= 0 then either make the malloced size equal to \"incr\"\n *    or (if that's not large enough) double the malloced size\n * After the size check, the list's count is incremented by 1 and a pointer\n * to the \"new\" list item is returned.\n */\nvoid *expand_item_list(item_list *lp, size_t item_size, const char *desc, int incr)\n{\n\t/* First time through, 0 <= 0, so list is expanded. */\n\tif (lp->malloced <= lp->count) {\n\t\tvoid *new_ptr;\n\t\tsize_t expand_size;\n\t\tif (incr < 0)\n\t\t\texpand_size = -incr; /* increase slowly */\n\t\telse if (lp->malloced < (size_t)incr)\n\t\t\texpand_size = incr - lp->malloced;\n\t\telse if (lp->malloced)\n\t\t\texpand_size = lp->malloced; /* double in size */\n\t\telse\n\t\t\texpand_size = 1;\n\t\tif (SIZE_MAX/item_size - expand_size < lp->malloced)\n\t\t\toverflow_exit(\"expand_item_list\");\n\t\texpand_size += lp->malloced;\n\t\tnew_ptr = realloc_buf(lp->items, expand_size * item_size);\n\t\tif (DEBUG_GTE(FLIST, 3)) {\n\t\t\trprintf(FINFO, \"[%s] expand %s to %s bytes, did%s move\\n\",\n\t\t\t\twho_am_i(), desc, big_num(expand_size * item_size),\n\t\t\t\tnew_ptr == lp->items ? \" not\" : \"\");\n\t\t}\n\n\t\tlp->items = new_ptr;\n\t\tlp->malloced = expand_size;\n\t}\n\treturn (char*)lp->items + (lp->count++ * item_size);\n}\n\n/* This zeroing of memory won't be optimized away by the compiler. */\nvoid force_memzero(void *buf, size_t len)\n{\n\tvolatile uchar *z = buf;\n\twhile (len-- > 0)\n\t\t*z++ = '\\0';\n}\n"
        },
        {
          "name": "util2.c",
          "type": "blob",
          "size": 3.46875,
          "content": "/*\n * Utility routines used in rsync.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2024 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"itypes.h\"\n#include \"inums.h\"\n\nextern size_t max_alloc;\n\nchar *do_calloc = \"42\";\n\n/**\n * Sleep for a specified number of milliseconds.\n *\n * Always returns True.\n **/\nint msleep(int t)\n{\n#ifdef HAVE_NANOSLEEP\n\tstruct timespec ts;\n\n\tts.tv_sec = t / 1000;\n\tts.tv_nsec = (t % 1000) * 1000000L;\n\n\twhile (nanosleep(&ts, &ts) < 0 && errno == EINTR) {}\n\n#elif defined HAVE_USLEEP\n\tusleep(t*1000);\n\n#else\n\tint tdiff = 0;\n\tstruct timeval tval, t1, t2;\n\n\tgettimeofday(&t1, NULL);\n\n\twhile (tdiff < t) {\n\t\ttval.tv_sec = (t-tdiff)/1000;\n\t\ttval.tv_usec = 1000*((t-tdiff)%1000);\n\n\t\terrno = 0;\n\t\tselect(0,NULL,NULL, NULL, &tval);\n\n\t\tgettimeofday(&t2, NULL);\n\t\ttdiff = (t2.tv_sec - t1.tv_sec)*1000 +\n\t\t\t(t2.tv_usec - t1.tv_usec)/1000;\n\t\tif (tdiff < 0)\n\t\t\tt1 = t2; /* Time went backwards, so start over. */\n\t}\n#endif\n\n\treturn True;\n}\n\nvoid *my_alloc(void *ptr, size_t num, size_t size, const char *file, int line)\n{\n\tif (num >= max_alloc/size) {\n\t\tif (!file)\n\t\t\treturn NULL;\n\t\trprintf(FERROR, \"[%s] exceeded --max-alloc=%s setting (file=%s, line=%d)\\n\",\n\t\t\twho_am_i(), do_big_num(max_alloc, 0, NULL), src_file(file), line);\n\t\texit_cleanup(RERR_MALLOC);\n\t}\n\tif (!ptr)\n\t\tptr = malloc(num * size);\n\telse if (ptr == do_calloc)\n\t\tptr = calloc(num, size);\n\telse\n\t\tptr = realloc(ptr, num * size);\n\tif (!ptr && file)\n\t\t_out_of_memory(\"my_alloc caller\", file, line);\n\treturn ptr;\n}\n\nconst char *sum_as_hex(int csum_type, const char *sum, int flist_csum)\n{\n\tstatic char buf[MAX_DIGEST_LEN*2+1];\n\tint i, x1, x2;\n\tint canonical = canonical_checksum(csum_type);\n\tint sum_len = csum_len_for_type(csum_type, flist_csum);\n\tchar *c;\n\n\tif (!canonical)\n\t\treturn NULL;\n\n\tassert(sum_len*2 < (int)sizeof buf);\n\n\tfor (i = sum_len, c = buf; --i >= 0; ) {\n\t\tint ndx = canonical < 0 ? sum_len - i - 1 : i;\n\t\tx2 = CVAL(sum, ndx);\n\t\tx1 = x2 >> 4;\n\t\tx2 &= 0xF;\n\t\t*c++ = x1 <= 9 ? x1 + '0' : x1 + 'a' - 10;\n\t\t*c++ = x2 <= 9 ? x2 + '0' : x2 + 'a' - 10;\n\t}\n\n\t*c = '\\0';\n\n\treturn buf;\n}\n\nNORETURN void _out_of_memory(const char *msg, const char *file, int line)\n{\n\trprintf(FERROR, \"[%s] out of memory: %s (file=%s, line=%d)\\n\", who_am_i(), msg, src_file(file), line);\n\texit_cleanup(RERR_MALLOC);\n}\n\nNORETURN void _overflow_exit(const char *msg, const char *file, int line)\n{\n\trprintf(FERROR, \"[%s] buffer overflow: %s (file=%s, line=%d)\\n\", who_am_i(), msg, src_file(file), line);\n\texit_cleanup(RERR_MALLOC);\n}\n\nconst char *src_file(const char *file)\n{\n\tstatic const char *util2 = __FILE__;\n\tstatic int prefix = -1;\n\n\tif (prefix < 0) {\n\t\tconst char *cp = strrchr(util2, '/');\n\t\tprefix = cp ? cp - util2 + 1 : 0;\n\t}\n\n\tif (prefix && strncmp(file, util2, prefix) == 0)\n\t\treturn file + prefix;\n\treturn file;\n}\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 0.0654296875,
          "content": "#define RSYNC_VERSION \"3.3.1dev\"\n#define MAINTAINER_TZ_OFFSET -7.0\n"
        },
        {
          "name": "wildtest.c",
          "type": "blob",
          "size": 5.4990234375,
          "content": "/*\n * Test suite for the wildmatch code.\n *\n * Copyright (C) 2003-2019 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n/*#define COMPARE_WITH_FNMATCH*/\n\n#define WILD_TEST_ITERATIONS\n#include \"lib/wildmatch.c\"\n\n#include <popt.h>\n\n#ifdef COMPARE_WITH_FNMATCH\n#include <fnmatch.h>\n\nint fnmatch_errors = 0;\n#endif\n\nint wildmatch_errors = 0;\n\ntypedef char bool;\n\nint output_iterations = 0;\nint explode_mod = 0;\nint empties_mod = 0;\nint empty_at_start = 0;\nint empty_at_end = 0;\n\nstatic struct poptOption long_options[] = {\n  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */\n  {\"iterations\",     'i', POPT_ARG_NONE,   &output_iterations, 0, 0, 0},\n  {\"empties\",        'e', POPT_ARG_STRING, 0, 'e', 0, 0},\n  {\"explode\",        'x', POPT_ARG_INT,    &explode_mod, 0, 0, 0},\n  {0,0,0,0, 0, 0, 0}\n};\n\n/* match just at the start of string (anchored tests) */\nstatic void\nrun_test(int line, bool matches,\n#ifdef COMPARE_WITH_FNMATCH\n\t bool same_as_fnmatch,\n#endif\n\t const char *text, const char *pattern)\n{\n    bool matched;\n#ifdef COMPARE_WITH_FNMATCH\n    bool fn_matched;\n    int flags = strstr(pattern, \"**\")? 0 : FNM_PATHNAME;\n#endif\n\n    if (explode_mod) {\n\tchar buf[MAXPATHLEN*2], *texts[MAXPATHLEN];\n\tint pos = 0, cnt = 0, ndx = 0, len = strlen(text);\n\n\tif (empty_at_start)\n\t    texts[ndx++] = \"\";\n\t/* An empty string must turn into at least one empty array item. */\n\twhile (1) {\n\t    texts[ndx] = buf + ndx * (explode_mod + 1);\n\t    strlcpy(texts[ndx++], text + pos, explode_mod + 1);\n\t    if (pos + explode_mod >= len)\n\t\tbreak;\n\t    pos += explode_mod;\n\t    if (!(++cnt % empties_mod))\n\t\ttexts[ndx++] = \"\";\n\t}\n\tif (empty_at_end)\n\t    texts[ndx++] = \"\";\n\ttexts[ndx] = NULL;\n\tmatched = wildmatch_array(pattern, (const char**)texts, 0);\n    } else\n\tmatched = wildmatch(pattern, text);\n#ifdef COMPARE_WITH_FNMATCH\n    fn_matched = !fnmatch(pattern, text, flags);\n#endif\n    if (matched != matches) {\n\tprintf(\"wildmatch failure on line %d:\\n  %s\\n  %s\\n  expected %s match\\n\",\n\t       line, text, pattern, matches? \"a\" : \"NO\");\n\twildmatch_errors++;\n    }\n#ifdef COMPARE_WITH_FNMATCH\n    if (fn_matched != (matches ^ !same_as_fnmatch)) {\n\tprintf(\"fnmatch disagreement on line %d:\\n  %s\\n  %s\\n  expected %s match\\n\",\n\t       line, text, pattern, matches ^ !same_as_fnmatch? \"a\" : \"NO\");\n\tfnmatch_errors++;\n    }\n#endif\n    if (output_iterations) {\n\tprintf(\"%d: \\\"%s\\\" iterations = %d\\n\", line, pattern,\n\t       wildmatch_iteration_count);\n    }\n}\n\nint\nmain(int argc, char **argv)\n{\n    char buf[2048], *s, *string[2], *end[2];\n    const char *arg;\n    FILE *fp;\n    int opt, line, i, flag[2];\n    poptContext pc = poptGetContext(\"wildtest\", argc, (const char**)argv,\n\t\t\t\t    long_options, 0);\n\n    while ((opt = poptGetNextOpt(pc)) != -1) {\n\tswitch (opt) {\n\t  case 'e':\n\t    arg = poptGetOptArg(pc);\n\t    empties_mod = atoi(arg);\n\t    if (strchr(arg, 's'))\n\t\tempty_at_start = 1;\n\t    if (strchr(arg, 'e'))\n\t\tempty_at_end = 1;\n\t    if (!explode_mod)\n\t\texplode_mod = 1024;\n\t    break;\n\t  default:\n\t    fprintf(stderr, \"%s: %s\\n\",\n\t\t    poptBadOption(pc, POPT_BADOPTION_NOALIAS),\n\t\t    poptStrerror(opt));\n\t    exit(1);\n\t}\n    }\n\n    if (explode_mod && !empties_mod)\n\tempties_mod = 1024;\n\n    argv = (char**)poptGetArgs(pc);\n    if (!argv || argv[1]) {\n\tfprintf(stderr, \"Usage: wildtest [OPTIONS] TESTFILE\\n\");\n\texit(1);\n    }\n\n    if ((fp = fopen(*argv, \"r\")) == NULL) {\n\tfprintf(stderr, \"Unable to open %s\\n\", *argv);\n\texit(1);\n    }\n\n    line = 0;\n    while (fgets(buf, sizeof buf, fp)) {\n\tline++;\n\tif (*buf == '#' || *buf == '\\n')\n\t    continue;\n\tfor (s = buf, i = 0; i <= 1; i++) {\n\t    if (*s == '1')\n\t\tflag[i] = 1;\n\t    else if (*s == '0')\n\t\tflag[i] = 0;\n\t    else\n\t\tflag[i] = -1;\n\t    if (*++s != ' ' && *s != '\\t')\n\t\tflag[i] = -1;\n\t    if (flag[i] < 0) {\n\t\tfprintf(stderr, \"Invalid flag syntax on line %d of %s:\\n%s\",\n\t\t\tline, *argv, buf);\n\t\texit(1);\n\t    }\n\t    while (*++s == ' ' || *s == '\\t') {}\n\t}\n\tfor (i = 0; i <= 1; i++) {\n\t    if (*s == '\\'' || *s == '\"' || *s == '`') {\n\t\tchar quote = *s++;\n\t\tstring[i] = s;\n\t\twhile (*s && *s != quote) s++;\n\t\tif (!*s) {\n\t\t    fprintf(stderr, \"Unmatched quote on line %d of %s:\\n%s\",\n\t\t\t    line, *argv, buf);\n\t\t    exit(1);\n\t\t}\n\t\tend[i] = s;\n\t    }\n\t    else {\n\t\tif (!*s || *s == '\\n') {\n\t\t    fprintf(stderr, \"Not enough strings on line %d of %s:\\n%s\",\n\t\t\t    line, *argv, buf);\n\t\t    exit(1);\n\t\t}\n\t\tstring[i] = s;\n\t\twhile (*++s && *s != ' ' && *s != '\\t' && *s != '\\n') {}\n\t\tend[i] = s;\n\t    }\n\t    while (*++s == ' ' || *s == '\\t') {}\n\t}\n\t*end[0] = *end[1] = '\\0';\n\trun_test(line, flag[0],\n#ifdef COMPARE_WITH_FNMATCH\n\t\t flag[1],\n#endif\n\t\t string[0], string[1]);\n    }\n\n    if (!wildmatch_errors)\n\tfputs(\"No\", stdout);\n    else\n\tprintf(\"%d\", wildmatch_errors);\n    printf(\" wildmatch error%s found.\\n\", wildmatch_errors == 1? \"\" : \"s\");\n\n#ifdef COMPARE_WITH_FNMATCH\n    if (!fnmatch_errors)\n\tfputs(\"No\", stdout);\n    else\n\tprintf(\"%d\", fnmatch_errors);\n    printf(\" fnmatch error%s found.\\n\", fnmatch_errors == 1? \"\" : \"s\");\n\n#endif\n\n    return 0;\n}\n"
        },
        {
          "name": "wildtest.txt",
          "type": "blob",
          "size": 4.1337890625,
          "content": "# Input is in the following format (all items white-space separated):\n#\n# The first two items are 1 or 0 indicating if the wildmat call is expected to\n# succeed and if fnmatch works the same way as wildmat, respectively.  After\n# that is a text string for the match, and a pattern string.  Strings can be\n# quoted (if desired) in either double or single quotes, as well as backticks.\n#\n# MATCH FNMATCH_SAME \"text to match\" 'pattern to use'\n\n# Basic wildmat features\n1 1 foo\t\t\tfoo\n0 1 foo\t\t\tbar\n1 1 ''\t\t\t\"\"\n1 1 foo\t\t\t???\n0 1 foo\t\t\t??\n1 1 foo\t\t\t*\n1 1 foo\t\t\tf*\n0 1 foo\t\t\t*f\n1 1 foo\t\t\t*foo*\n1 1 foobar\t\t*ob*a*r*\n1 1 aaaaaaabababab\t*ab\n1 1 foo*\t\tfoo\\*\n0 1 foobar\t\tfoo\\*bar\n1 1 f\\oo\t\tf\\\\oo\n1 1 ball\t\t*[al]?\n0 1 ten\t\t\t[ten]\n1 1 ten\t\t\t**[!te]\n0 1 ten\t\t\t**[!ten]\n1 1 ten\t\t\tt[a-g]n\n0 1 ten\t\t\tt[!a-g]n\n1 1 ton\t\t\tt[!a-g]n\n1 1 ton\t\t\tt[^a-g]n\n1 1 a]b\t\t\ta[]]b\n1 1 a-b\t\t\ta[]-]b\n1 1 a]b\t\t\ta[]-]b\n0 1 aab\t\t\ta[]-]b\n1 1 aab\t\t\ta[]a-]b\n1 1 ]\t\t\t]\n\n# Extended slash-matching features\n0 1 foo/baz/bar\t\tfoo*bar\n1 1 foo/baz/bar\t\tfoo**bar\n0 1 foo/bar\t\tfoo?bar\n0 1 foo/bar\t\tfoo[/]bar\n0 1 foo/bar\t\tf[^eiu][^eiu][^eiu][^eiu][^eiu]r\n1 1 foo-bar\t\tf[^eiu][^eiu][^eiu][^eiu][^eiu]r\n0 1 foo\t\t\t**/foo\n1 1 /foo\t\t**/foo\n1 1 bar/baz/foo\t\t**/foo\n0 1 bar/baz/foo\t\t*/foo\n0 0 foo/bar/baz\t\t**/bar*\n1 1 deep/foo/bar/baz\t**/bar/*\n0 1 deep/foo/bar/baz/\t**/bar/*\n1 1 deep/foo/bar/baz/\t**/bar/**\n0 1 deep/foo/bar\t**/bar/*\n1 1 deep/foo/bar/\t**/bar/**\n1 1 foo/bar/baz\t\t**/bar**\n1 1 foo/bar/baz/x\t*/bar/**\n0 0 deep/foo/bar/baz/x\t*/bar/**\n1 1 deep/foo/bar/baz/x\t**/bar/*/*\n\n# Various additional tests\n0 1 acrt\t\ta[c-c]st\n1 1 acrt\t\ta[c-c]rt\n0 1 ]\t\t\t[!]-]\n1 1 a\t\t\t[!]-]\n0 1 ''\t\t\t\\\n0 1 \\\t\t\t\\\n0 1 /\\\t\t\t*/\\\n1 1 /\\\t\t\t*/\\\\\n1 1 foo\t\t\tfoo\n1 1 @foo\t\t@foo\n0 1 foo\t\t\t@foo\n1 1 [ab]\t\t\\[ab]\n1 1 [ab]\t\t[[]ab]\n1 1 [ab]\t\t[[:]ab]\n0 1 [ab]\t\t[[::]ab]\n1 1 [ab]\t\t[[:digit]ab]\n1 1 [ab]\t\t[\\[:]ab]\n1 1 ?a?b\t\t\\??\\?b\n1 1 abc\t\t\t\\a\\b\\c\n0 1 foo\t\t\t''\n1 1 foo/bar/baz/to\t**/t[o]\n\n# Character class tests\n1 1 a1B\t\t[[:alpha:]][[:digit:]][[:upper:]]\n0 1 a\t\t[[:digit:][:upper:][:space:]]\n1 1 A\t\t[[:digit:][:upper:][:space:]]\n1 1 1\t\t[[:digit:][:upper:][:space:]]\n0 1 1\t\t[[:digit:][:upper:][:spaci:]]\n1 1 ' '\t\t[[:digit:][:upper:][:space:]]\n0 1 .\t\t[[:digit:][:upper:][:space:]]\n1 1 .\t\t[[:digit:][:punct:][:space:]]\n1 1 5\t\t[[:xdigit:]]\n1 1 f\t\t[[:xdigit:]]\n1 1 D\t\t[[:xdigit:]]\n1 1 _\t\t[[:alnum:][:alpha:][:blank:][:cntrl:][:digit:][:graph:][:lower:][:print:][:punct:][:space:][:upper:][:xdigit:]]\n#1 1 …\t\t[^[:alnum:][:alpha:][:blank:][:cntrl:][:digit:][:graph:][:lower:][:print:][:punct:][:space:][:upper:][:xdigit:]]\n1 1 \t\t[^[:alnum:][:alpha:][:blank:][:digit:][:graph:][:lower:][:print:][:punct:][:space:][:upper:][:xdigit:]]\n1 1 .\t\t[^[:alnum:][:alpha:][:blank:][:cntrl:][:digit:][:lower:][:space:][:upper:][:xdigit:]]\n1 1 5\t\t[a-c[:digit:]x-z]\n1 1 b\t\t[a-c[:digit:]x-z]\n1 1 y\t\t[a-c[:digit:]x-z]\n0 1 q\t\t[a-c[:digit:]x-z]\n\n# Additional tests, including some malformed wildmats\n1 1 ]\t\t[\\\\-^]\n0 1 [\t\t[\\\\-^]\n1 1 -\t\t[\\-_]\n1 1 ]\t\t[\\]]\n0 1 \\]\t\t[\\]]\n0 1 \\\t\t[\\]]\n0 1 ab\t\ta[]b\n0 1 a[]b\ta[]b\n0 1 ab[\t\tab[\n0 1 ab\t\t[!\n0 1 ab\t\t[-\n1 1 -\t\t[-]\n0 1 -\t\t[a-\n0 1 -\t\t[!a-\n1 1 -\t\t[--A]\n1 1 5\t\t[--A]\n1 1 ' '\t\t'[ --]'\n1 1 $\t\t'[ --]'\n1 1 -\t\t'[ --]'\n0 1 0\t\t'[ --]'\n1 1 -\t\t[---]\n1 1 -\t\t[------]\n0 1 j\t\t[a-e-n]\n1 1 -\t\t[a-e-n]\n1 1 a\t\t[!------]\n0 1 [\t\t[]-a]\n1 1 ^\t\t[]-a]\n0 1 ^\t\t[!]-a]\n1 1 [\t\t[!]-a]\n1 1 ^\t\t[a^bc]\n1 1 -b]\t\t[a-]b]\n0 1 \\\t\t[\\]\n1 1 \\\t\t[\\\\]\n0 1 \\\t\t[!\\\\]\n1 1 G\t\t[A-\\\\]\n0 1 aaabbb\tb*a\n0 1 aabcaa\t*ba*\n1 1 ,\t\t[,]\n1 1 ,\t\t[\\\\,]\n1 1 \\\t\t[\\\\,]\n1 1 -\t\t[,-.]\n0 1 +\t\t[,-.]\n0 1 -.]\t\t[,-.]\n1 1 2\t\t[\\1-\\3]\n1 1 3\t\t[\\1-\\3]\n0 1 4\t\t[\\1-\\3]\n1 1 \\\t\t[[-\\]]\n1 1 [\t\t[[-\\]]\n1 1 ]\t\t[[-\\]]\n0 1 -\t\t[[-\\]]\n\n# Test recursion and the abort code (use \"wildtest -i\" to see iteration counts)\n1 1 -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1\t-*-*-*-*-*-*-12-*-*-*-m-*-*-*\n0 1 -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1\t-*-*-*-*-*-*-12-*-*-*-m-*-*-*\n0 1 -adobe-courier-bold-o-normal--12-120-75-75-/-70-iso8859-1\t-*-*-*-*-*-*-12-*-*-*-m-*-*-*\n1 1 /adobe/courier/bold/o/normal//12/120/75/75/m/70/iso8859/1\t/*/*/*/*/*/*/12/*/*/*/m/*/*/*\n0 1 /adobe/courier/bold/o/normal//12/120/75/75/X/70/iso8859/1\t/*/*/*/*/*/*/12/*/*/*/m/*/*/*\n1 1 abcd/abcdefg/abcdefghijk/abcdefghijklmnop.txt\t\t**/*a*b*g*n*t\n0 1 abcd/abcdefg/abcdefghijk/abcdefghijklmnop.txtz\t\t**/*a*b*g*n*t\n"
        },
        {
          "name": "xattrs.c",
          "type": "blob",
          "size": 32.0947265625,
          "content": "/*\n * Extended Attribute support for rsync.\n * Written by Jay Fenlason, vaguely based on the ACLs patch.\n *\n * Copyright (C) 2004 Red Hat, Inc.\n * Copyright (C) 2006-2022 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"inums.h\"\n#include \"lib/sysxattrs.h\"\n\n#ifdef SUPPORT_XATTRS\n\nextern int dry_run;\nextern int am_root;\nextern int am_sender;\nextern int am_generator;\nextern int read_only;\nextern int list_only;\nextern int preserve_xattrs;\nextern int preserve_links;\nextern int preserve_devices;\nextern int preserve_specials;\nextern int checksum_seed;\nextern int saw_xattr_filter;\n\nextern struct name_num_item *xattr_sum_nni;\nextern int xattr_sum_len;\n\n#define RSYNC_XAL_INITIAL 5\n#define RSYNC_XAL_LIST_INITIAL 100\n\n#define MAX_XATTR_DIGEST_LEN MD5_DIGEST_LEN\n#define MAX_FULL_DATUM 32\n\n#define HAS_PREFIX(str, prfx) (*(str) == *(prfx) && strncmp(str, prfx, sizeof (prfx) - 1) == 0)\n\n#define XATTR_ABBREV(x) ((size_t)((x).name - (x).datum) < (x).datum_len)\n\n#define XSTATE_ABBREV\t1\n#define XSTATE_DONE\t2\n#define XSTATE_TODO\t3\n\n#define USER_PREFIX \"user.\"\n#define UPRE_LEN ((int)sizeof USER_PREFIX - 1)\n#define SYSTEM_PREFIX \"system.\"\n#define SPRE_LEN ((int)sizeof SYSTEM_PREFIX - 1)\n\n#ifdef HAVE_LINUX_XATTRS\n#define MIGHT_NEED_RPRE (am_root <= 0)\n#define RSYNC_PREFIX USER_PREFIX \"rsync.\"\n#else\n#define MIGHT_NEED_RPRE am_root\n#define RSYNC_PREFIX \"rsync.\"\n#endif\n#define RPRE_LEN ((int)sizeof RSYNC_PREFIX - 1)\n\n#define XSTAT_SUFFIX \"stat\"\n#define XSTAT_ATTR RSYNC_PREFIX \"%\" XSTAT_SUFFIX\n#define XACC_ACL_SUFFIX \"aacl\"\n#define XACC_ACL_ATTR RSYNC_PREFIX \"%\" XACC_ACL_SUFFIX\n#define XDEF_ACL_SUFFIX \"dacl\"\n#define XDEF_ACL_ATTR RSYNC_PREFIX \"%\" XDEF_ACL_SUFFIX\n\ntypedef struct {\n\tchar *datum, *name;\n\tsize_t datum_len, name_len;\n\tint num;\n} rsync_xa;\n\nstruct _rsync_xa_list;\n\ntypedef struct _rsync_xa_list_ref {\n\tstruct _rsync_xa_list_ref *next;\n\tint ndx;\n} rsync_xa_list_ref;\n\ntypedef struct _rsync_xa_list {\n\tint ndx;\n\tint64 key;\n\titem_list xa_items;\n} rsync_xa_list;\n\nstatic size_t namebuf_len = 0;\nstatic char *namebuf = NULL;\n\nstatic const rsync_xa_list empty_xa_list = {\n\t.xa_items = EMPTY_ITEM_LIST,\n};\nstatic const item_list empty_xattr = EMPTY_ITEM_LIST;\nstatic item_list rsync_xal_l = EMPTY_ITEM_LIST;\nstatic struct hashtable *rsync_xal_h = NULL;\n\nstatic size_t prior_xattr_count = (size_t)-1;\n\n/* ------------------------------------------------------------------------- */\n\nstatic void rsync_xal_free(item_list *xalp)\n{\n\tsize_t i;\n\trsync_xa *rxas = xalp->items;\n\n\tif (!xalp->malloced)\n\t\treturn;\n\n\tfor (i = 0; i < xalp->count; i++) {\n\t\tfree(rxas[i].datum);\n\t\t/*free(rxas[i].name);*/\n\t}\n\tfree(xalp->items);\n}\n\nvoid free_xattr(stat_x *sxp)\n{\n\tif (!sxp->xattr)\n\t\treturn;\n\trsync_xal_free(sxp->xattr);\n\tfree(sxp->xattr);\n\tsxp->xattr = NULL;\n}\n\nstatic int rsync_xal_compare_names(const void *x1, const void *x2)\n{\n\tconst rsync_xa *xa1 = x1;\n\tconst rsync_xa *xa2 = x2;\n\treturn strcmp(xa1->name, xa2->name);\n}\n\nstatic ssize_t get_xattr_names(const char *fname)\n{\n\tssize_t list_len;\n\tint64 arg;\n\n\tif (!namebuf) {\n\t\tnamebuf_len = 1024;\n\t\tnamebuf = new_array(char, namebuf_len);\n\t}\n\n\twhile (1) {\n\t\t/* The length returned includes all the '\\0' terminators. */\n\t\tlist_len = sys_llistxattr(fname, namebuf, namebuf_len);\n\t\tif (list_len >= 0) {\n\t\t\tif ((size_t)list_len <= namebuf_len)\n\t\t\t\tbreak;\n\t\t} else if (errno == ENOTSUP)\n\t\t\treturn 0;\n\t\telse if (errno != ERANGE) {\n\t\t\targ = namebuf_len;\n\t\t  got_error:\n\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\"get_xattr_names: llistxattr(%s,%s) failed\",\n\t\t\t\tfull_fname(fname), big_num(arg));\n\t\t\treturn -1;\n\t\t}\n\t\tlist_len = sys_llistxattr(fname, NULL, 0);\n\t\tif (list_len < 0) {\n\t\t\targ = 0;\n\t\t\tgoto got_error;\n\t\t}\n\t\tif (namebuf_len)\n\t\t\tfree(namebuf);\n\t\tnamebuf_len = list_len + 1024;\n\t\tnamebuf = new_array(char, namebuf_len);\n\t}\n\n\treturn list_len;\n}\n\n/* On entry, the *len_ptr parameter contains the size of the extra space we\n * should allocate when we create a buffer for the data.  On exit, it contains\n * the length of the datum. */\nstatic char *get_xattr_data(const char *fname, const char *name, size_t *len_ptr, int no_missing_error)\n{\n\tsize_t datum_len = sys_lgetxattr(fname, name, NULL, 0);\n\tsize_t extra_len = *len_ptr;\n\tchar *ptr;\n\n\t*len_ptr = datum_len;\n\n\tif (datum_len == (size_t)-1) {\n\t\tif (errno == ENOTSUP || no_missing_error)\n\t\t\treturn NULL;\n\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\"get_xattr_data: lgetxattr(%s,\\\"%s\\\",0) failed\",\n\t\t\tfull_fname(fname), name);\n\t\treturn NULL;\n\t}\n\n\tif (!datum_len && !extra_len)\n\t\textra_len = 1; /* request non-zero amount of memory */\n\tif (SIZE_MAX - datum_len < extra_len)\n\t\toverflow_exit(\"get_xattr_data\");\n\tptr = new_array(char, datum_len + extra_len);\n\n\tif (datum_len) {\n\t\tsize_t len = sys_lgetxattr(fname, name, ptr, datum_len);\n\t\tif (len != datum_len) {\n\t\t\tif (len == (size_t)-1) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"get_xattr_data: lgetxattr(%s,\\\"%s\\\",%ld) failed\",\n\t\t\t\t\tfull_fname(fname), name, (long)datum_len);\n\t\t\t} else {\n\t\t\t\trprintf(FERROR_XFER,\n\t\t\t\t\t\"get_xattr_data: lgetxattr(%s,\\\"%s\\\",%ld) returned %ld\\n\",\n\t\t\t\t\tfull_fname(fname), name,\n\t\t\t\t\t(long)datum_len, (long)len);\n\t\t\t}\n\t\t\tfree(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ptr;\n}\n\nstatic int rsync_xal_get(const char *fname, item_list *xalp)\n{\n\tssize_t list_len, name_len;\n\tsize_t datum_len, name_offset;\n\tchar *name, *ptr;\n#ifdef HAVE_LINUX_XATTRS\n\tint user_only = am_sender ? 0 : !am_root;\n#endif\n\trsync_xa *rxa;\n\tint count;\n\n\t/* This puts the name list into the \"namebuf\" buffer. */\n\tif ((list_len = get_xattr_names(fname)) < 0)\n\t\treturn -1;\n\n\tfor (name = namebuf; list_len > 0; name += name_len) {\n\t\tname_len = strlen(name) + 1;\n\t\tlist_len -= name_len;\n\n\t\tif (saw_xattr_filter) {\n\t\t\tif (name_is_excluded(name, NAME_IS_XATTR, ALL_FILTERS))\n\t\t\t\tcontinue;\n\t\t}\n#ifdef HAVE_LINUX_XATTRS\n\t\t/* Choose between ignoring the system namespace or (non-root) ignoring any non-user namespace. */\n\t\telse if (user_only ? !HAS_PREFIX(name, USER_PREFIX) : HAS_PREFIX(name, SYSTEM_PREFIX))\n\t\t\tcontinue;\n#endif\n\n\t\t/* No rsync.%FOO attributes are copied w/o 2 -X options. */\n\t\tif (name_len > RPRE_LEN && name[RPRE_LEN] == '%' && HAS_PREFIX(name, RSYNC_PREFIX)) {\n\t\t\tif ((am_sender && preserve_xattrs < 2)\n\t\t\t || (am_root < 0\n\t\t\t  && (strcmp(name+RPRE_LEN+1, XSTAT_SUFFIX) == 0\n\t\t\t   || strcmp(name+RPRE_LEN+1, XACC_ACL_SUFFIX) == 0\n\t\t\t   || strcmp(name+RPRE_LEN+1, XDEF_ACL_SUFFIX) == 0)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tdatum_len = name_len; /* Pass extra size to get_xattr_data() */\n\t\tif (!(ptr = get_xattr_data(fname, name, &datum_len, 0)))\n\t\t\treturn -1;\n\n\t\tif (datum_len > MAX_FULL_DATUM) {\n\t\t\t/* For large datums, we store a flag and a checksum. */\n\t\t\tname_offset = 1 + MAX_XATTR_DIGEST_LEN;\n\t\t\tsum_init(xattr_sum_nni, checksum_seed);\n\t\t\tsum_update(ptr, datum_len);\n\t\t\tfree(ptr);\n\n\t\t\tptr = new_array(char, name_offset + name_len);\n\t\t\t*ptr = XSTATE_ABBREV;\n\t\t\tsum_end(ptr + 1);\n\t\t} else\n\t\t\tname_offset = datum_len;\n\n\t\trxa = EXPAND_ITEM_LIST(xalp, rsync_xa, RSYNC_XAL_INITIAL);\n\t\trxa->name = ptr + name_offset;\n\t\tmemcpy(rxa->name, name, name_len);\n\t\trxa->datum = ptr;\n\t\trxa->name_len = name_len;\n\t\trxa->datum_len = datum_len;\n\t}\n\tcount = xalp->count;\n\trxa = xalp->items;\n\tif (count > 1)\n\t\tqsort(rxa, count, sizeof (rsync_xa), rsync_xal_compare_names);\n\tfor (rxa += count-1; count; count--, rxa--)\n\t\trxa->num = count;\n\treturn 0;\n}\n\n/* Read the xattr(s) for this filename. */\nint get_xattr(const char *fname, stat_x *sxp)\n{\n\tsxp->xattr = new(item_list);\n\t*sxp->xattr = empty_xattr;\n\n\tif (S_ISREG(sxp->st.st_mode) || S_ISDIR(sxp->st.st_mode)) {\n\t\t/* Everyone supports this. */\n\t} else if (S_ISLNK(sxp->st.st_mode)) {\n#ifndef NO_SYMLINK_XATTRS\n\t\tif (!preserve_links)\n#endif\n\t\t\treturn 0;\n\t} else if (IS_SPECIAL(sxp->st.st_mode)) {\n#ifndef NO_SPECIAL_XATTRS\n\t\tif (!preserve_specials)\n#endif\n\t\t\treturn 0;\n\t} else if (IS_DEVICE(sxp->st.st_mode)) {\n#ifndef NO_DEVICE_XATTRS\n\t\tif (!preserve_devices)\n#endif\n\t\t\treturn 0;\n\t} else if (IS_MISSING_FILE(sxp->st))\n\t\treturn 0;\n\n\tif (rsync_xal_get(fname, sxp->xattr) < 0) {\n\t\tfree_xattr(sxp);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint copy_xattrs(const char *source, const char *dest)\n{\n\tssize_t list_len, name_len;\n\tsize_t datum_len;\n\tchar *name, *ptr;\n#ifdef HAVE_LINUX_XATTRS\n\tint user_only = am_sender ? 0 : am_root <= 0;\n#endif\n\n\t/* This puts the name list into the \"namebuf\" buffer. */\n\tif ((list_len = get_xattr_names(source)) < 0)\n\t\treturn -1;\n\n\tfor (name = namebuf; list_len > 0; name += name_len) {\n\t\tname_len = strlen(name) + 1;\n\t\tlist_len -= name_len;\n\n\t\tif (saw_xattr_filter) {\n\t\t\tif (name_is_excluded(name, NAME_IS_XATTR, ALL_FILTERS))\n\t\t\t\tcontinue;\n\t\t}\n#ifdef HAVE_LINUX_XATTRS\n\t\t/* Choose between ignoring the system namespace or (non-root) ignoring any non-user namespace. */\n\t\telse if (user_only ? !HAS_PREFIX(name, USER_PREFIX) : HAS_PREFIX(name, SYSTEM_PREFIX))\n\t\t\tcontinue;\n#endif\n\n\t\tdatum_len = 0;\n\t\tif (!(ptr = get_xattr_data(source, name, &datum_len, 0)))\n\t\t\treturn -1;\n\t\tif (sys_lsetxattr(dest, name, ptr, datum_len) < 0) {\n\t\t\tint save_errno = errno ? errno : EINVAL;\n\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\"copy_xattrs: lsetxattr(%s,\\\"%s\\\") failed\",\n\t\t\t\tfull_fname(dest), name);\n\t\t\terrno = save_errno;\n\t\t\treturn -1;\n\t\t}\n\t\tfree(ptr);\n\t}\n\n\treturn 0;\n}\n\nstatic int64 xattr_lookup_hash(const item_list *xalp)\n{\n\tconst rsync_xa *rxas = xalp->items;\n\tsize_t i;\n\tint64 key = hashlittle2(&xalp->count, sizeof xalp->count);\n\n\tfor (i = 0; i < xalp->count; i++) {\n\t\tkey += hashlittle2(rxas[i].name, rxas[i].name_len);\n\t\tif (rxas[i].datum_len > MAX_FULL_DATUM)\n\t\t\tkey += hashlittle2(rxas[i].datum, xattr_sum_len);\n\t\telse\n\t\t\tkey += hashlittle2(rxas[i].datum, rxas[i].datum_len);\n\t}\n\n\treturn key;\n}\n\nstatic int find_matching_xattr(const item_list *xalp)\n{\n\tconst struct ht_int64_node *node;\n\tconst rsync_xa_list_ref *ref;\n\tint64 key;\n\n\tif (rsync_xal_h == NULL)\n\t\treturn -1;\n\n\tkey = xattr_lookup_hash(xalp);\n\n\tnode = hashtable_find(rsync_xal_h, key, NULL);\n\tif (node == NULL)\n\t\treturn -1;\n\n\tif (node->data == NULL)\n\t\treturn -1;\n\n\tfor (ref = node->data; ref != NULL; ref = ref->next) {\n\t\tconst rsync_xa_list *ptr = rsync_xal_l.items;\n\t\tconst rsync_xa *rxas1;\n\t\tconst rsync_xa *rxas2 = xalp->items;\n\t\tsize_t j;\n\n\t\tptr += ref->ndx;\n\t\trxas1 = ptr->xa_items.items;\n\n\t\t/* Wrong number of elements? */\n\t\tif (ptr->xa_items.count != xalp->count)\n\t\t\tcontinue;\n\t\t/* any elements different? */\n\t\tfor (j = 0; j < xalp->count; j++) {\n\t\t\tif (rxas1[j].name_len != rxas2[j].name_len\n\t\t\t || rxas1[j].datum_len != rxas2[j].datum_len\n\t\t\t || strcmp(rxas1[j].name, rxas2[j].name))\n\t\t\t\tbreak;\n\t\t\tif (rxas1[j].datum_len > MAX_FULL_DATUM) {\n\t\t\t\tif (memcmp(rxas1[j].datum + 1,\n\t\t\t\t\t   rxas2[j].datum + 1,\n\t\t\t\t\t   xattr_sum_len) != 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (memcmp(rxas1[j].datum, rxas2[j].datum,\n\t\t\t\t\t   rxas2[j].datum_len))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* no differences found.  This is The One! */\n\t\tif (j == xalp->count)\n\t\t\treturn ref->ndx;\n\t}\n\n\treturn -1;\n}\n\n/* Store *xalp on the end of rsync_xal_l */\nstatic int rsync_xal_store(item_list *xalp)\n{\n\tstruct ht_int64_node *node;\n\tint ndx = rsync_xal_l.count; /* pre-incremented count */\n\trsync_xa_list *new_list = EXPAND_ITEM_LIST(&rsync_xal_l, rsync_xa_list, RSYNC_XAL_LIST_INITIAL);\n\trsync_xa_list_ref *new_ref;\n\t/* Since the following call starts a new list, we know it will hold the\n\t * entire initial-count, not just enough space for one new item. */\n\t*new_list = empty_xa_list;\n\t(void)EXPAND_ITEM_LIST(&new_list->xa_items, rsync_xa, xalp->count);\n\tmemcpy(new_list->xa_items.items, xalp->items, xalp->count * sizeof (rsync_xa));\n\tnew_list->xa_items.count = xalp->count;\n\txalp->count = 0;\n\n\tnew_list->ndx = ndx;\n\tnew_list->key = xattr_lookup_hash(&new_list->xa_items);\n\n\tif (rsync_xal_h == NULL)\n\t\trsync_xal_h = hashtable_create(512, HT_KEY64);\n\n\tnew_ref = new0(rsync_xa_list_ref);\n\tnew_ref->ndx = ndx;\n\n\tnode = hashtable_find(rsync_xal_h, new_list->key, new_ref);\n\tif (node->data != (void*)new_ref) {\n\t\trsync_xa_list_ref *ref = node->data;\n\n\t\twhile (ref != NULL) {\n\t\t\tif (ref->next != NULL) {\n\t\t\t\tref = ref->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref->next = new_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ndx;\n}\n\n/* Send the make_xattr()-generated xattr list for this flist entry. */\nint send_xattr(int f, stat_x *sxp)\n{\n\tint ndx = find_matching_xattr(sxp->xattr);\n\n\t/* Send 0 (-1 + 1) to indicate that literal xattr data follows. */\n\twrite_varint(f, ndx + 1);\n\n\tif (ndx < 0) {\n\t\trsync_xa *rxa;\n\t\tint count = sxp->xattr->count;\n\t\twrite_varint(f, count);\n\t\tfor (rxa = sxp->xattr->items; count--; rxa++) {\n\t\t\tsize_t name_len = rxa->name_len;\n\t\t\tconst char *name = rxa->name;\n\t\t\t/* Strip the rsync prefix from disguised namespaces. */\n\t\t\tif (name_len > RPRE_LEN\n#ifdef HAVE_LINUX_XATTRS\n\t\t\t && am_root < 0\n#endif\n\t\t\t && name[RPRE_LEN] != '%' && HAS_PREFIX(name, RSYNC_PREFIX)) {\n\t\t\t\tname += RPRE_LEN;\n\t\t\t\tname_len -= RPRE_LEN;\n\t\t\t}\n#ifndef HAVE_LINUX_XATTRS\n\t\t\telse {\n\t\t\t\t/* Put everything else in the user namespace. */\n\t\t\t\tname_len += UPRE_LEN;\n\t\t\t}\n#endif\n\t\t\twrite_varint(f, name_len);\n\t\t\twrite_varint(f, rxa->datum_len);\n#ifndef HAVE_LINUX_XATTRS\n\t\t\tif (name_len > rxa->name_len) {\n\t\t\t\twrite_buf(f, USER_PREFIX, UPRE_LEN);\n\t\t\t\tname_len -= UPRE_LEN;\n\t\t\t}\n#endif\n\t\t\twrite_buf(f, name, name_len);\n\t\t\tif (rxa->datum_len > MAX_FULL_DATUM)\n\t\t\t\twrite_buf(f, rxa->datum + 1, xattr_sum_len);\n\t\t\telse\n\t\t\t\twrite_bigbuf(f, rxa->datum, rxa->datum_len);\n\t\t}\n\t\tndx = rsync_xal_store(sxp->xattr); /* adds item to rsync_xal_l */\n\t}\n\n\treturn ndx;\n}\n\n/* Return a flag indicating if we need to change a file's xattrs.  If\n * \"find_all\" is specified, also mark any abbreviated xattrs that we\n * need so that send_xattr_request() can tell the sender about them. */\nint xattr_diff(struct file_struct *file, stat_x *sxp, int find_all)\n{\n\tconst rsync_xa_list *glst = rsync_xal_l.items;\n\tconst item_list *lst;\n\trsync_xa *snd_rxa, *rec_rxa;\n\tint snd_cnt, rec_cnt;\n\tint cmp, same, xattrs_equal = 1;\n\n\tif (sxp && XATTR_READY(*sxp)) {\n\t\trec_rxa = sxp->xattr->items;\n\t\trec_cnt = sxp->xattr->count;\n\t} else {\n\t\trec_rxa = NULL;\n\t\trec_cnt = 0;\n\t}\n\n\tif (F_XATTR(file) >= 0) {\n\t\tglst += F_XATTR(file);\n\t\tlst = &glst->xa_items;\n\t} else\n\t\tlst = &empty_xattr;\n\n\tsnd_rxa = lst->items;\n\tsnd_cnt = lst->count;\n\n\t/* If the count of the sender's xattrs is different from our\n\t * (receiver's) xattrs, the lists are not the same. */\n\tif (snd_cnt != rec_cnt) {\n\t\tif (!find_all)\n\t\t\treturn 1;\n\t\txattrs_equal = 0;\n\t}\n\n\twhile (snd_cnt) {\n\t\tcmp = rec_cnt ? strcmp(snd_rxa->name, rec_rxa->name) : -1;\n\t\tif (cmp > 0)\n\t\t\tsame = 0;\n\t\telse if (snd_rxa->datum_len > MAX_FULL_DATUM) {\n\t\t\tsame = cmp == 0 && snd_rxa->datum_len == rec_rxa->datum_len\n\t\t\t    && memcmp(snd_rxa->datum + 1, rec_rxa->datum + 1,\n\t\t\t\t      xattr_sum_len) == 0;\n\t\t\t/* Flag unrequested items that we need. */\n\t\t\tif (!same && find_all && snd_rxa->datum[0] == XSTATE_ABBREV)\n\t\t\t\tsnd_rxa->datum[0] = XSTATE_TODO;\n\t\t} else {\n\t\t\tsame = cmp == 0 && snd_rxa->datum_len == rec_rxa->datum_len\n\t\t\t    && memcmp(snd_rxa->datum, rec_rxa->datum,\n\t\t\t\t      snd_rxa->datum_len) == 0;\n\t\t}\n\t\tif (!same) {\n\t\t\tif (!find_all)\n\t\t\t\treturn 1;\n\t\t\txattrs_equal = 0;\n\t\t}\n\n\t\tif (cmp <= 0) {\n\t\t\tsnd_rxa++;\n\t\t\tsnd_cnt--;\n\t\t}\n\t\tif (cmp >= 0) {\n\t\t\trec_rxa++;\n\t\t\trec_cnt--;\n\t\t}\n\t}\n\n\tif (rec_cnt)\n\t\txattrs_equal = 0;\n\n\treturn !xattrs_equal;\n}\n\n/* When called by the generator (with a NULL fname), this tells the sender\n * all the abbreviated xattr values we need.  When called by the sender\n * (with a non-NULL fname), we send all the extra xattr data it needs.\n * The generator may also call with f_out < 0 to just change all the\n * XSTATE_ABBREV states into XSTATE_DONE. */\nvoid send_xattr_request(const char *fname, struct file_struct *file, int f_out)\n{\n\tconst rsync_xa_list *glst = rsync_xal_l.items;\n\tconst item_list *lst;\n\tint cnt, prior_req = 0;\n\trsync_xa *rxa;\n\n\tglst += F_XATTR(file);\n\tlst = &glst->xa_items;\n\n\tfor (rxa = lst->items, cnt = lst->count; cnt--; rxa++) {\n\t\tif (rxa->datum_len <= MAX_FULL_DATUM)\n\t\t\tcontinue;\n\t\tswitch (rxa->datum[0]) {\n\t\tcase XSTATE_ABBREV:\n\t\t\t/* Items left abbreviated matched the sender's checksum, so\n\t\t\t * the receiver will cache the local data for future use. */\n\t\t\tif (am_generator)\n\t\t\t\trxa->datum[0] = XSTATE_DONE;\n\t\t\tcontinue;\n\t\tcase XSTATE_TODO:\n\t\t\tassert(f_out >= 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Flag that we handled this abbreviated item. */\n\t\trxa->datum[0] = XSTATE_DONE;\n\n\t\twrite_varint(f_out, rxa->num - prior_req);\n\t\tprior_req = rxa->num;\n\n\t\tif (fname) {\n\t\t\tsize_t len = 0;\n\t\t\tchar *ptr;\n\n\t\t\t/* Re-read the long datum. */\n\t\t\tif (!(ptr = get_xattr_data(fname, rxa->name, &len, 0))) {\n\t\t\t\trprintf(FERROR_XFER, \"failed to re-read xattr %s for %s\\n\", rxa->name, fname);\n\t\t\t\twrite_varint(f_out, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twrite_varint(f_out, len); /* length might have changed! */\n\t\t\twrite_bigbuf(f_out, ptr, len);\n\t\t\tfree(ptr);\n\t\t}\n\t}\n\n\tif (f_out >= 0)\n\t\twrite_byte(f_out, 0); /* end the list */\n}\n\n/* When called by the sender, read the request from the generator and mark\n * any needed xattrs with a flag that lets us know they need to be sent to\n * the receiver.  When called by the receiver, reads the sent data and\n * stores it in place of its checksum. */\nint recv_xattr_request(struct file_struct *file, int f_in)\n{\n\tconst rsync_xa_list *glst = rsync_xal_l.items;\n\tconst item_list *lst;\n\tchar *old_datum, *name;\n\trsync_xa *rxa;\n\tint rel_pos, cnt, num, got_xattr_data = 0;\n\n\tif (F_XATTR(file) < 0) {\n\t\trprintf(FERROR, \"recv_xattr_request: internal data error!\\n\");\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\tglst += F_XATTR(file);\n\tlst = &glst->xa_items;\n\n\tcnt = lst->count;\n\trxa = lst->items;\n\tnum = 0;\n\twhile ((rel_pos = read_varint(f_in)) != 0) {\n\t\tnum += rel_pos;\n\t\tif (am_sender) {\n\t\t\t/* The sender-related num values are only in order on the sender.\n\t\t\t * We use that order here to scan forward or backward as needed. */\n\t\t\tif (rel_pos < 0) {\n\t\t\t\twhile (cnt < (int)lst->count && rxa->num > num) {\n\t\t\t\t\trxa--;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (cnt > 1 && rxa->num < num) {\n\t\t\t\t\trxa++;\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint j;\n\t\t\t/* The receiving side has no known num order, so we just scan\n\t\t\t * forward (w/wrap) and hope that the next value is near by. */\n\t\t\tfor (j = lst->count; j > 1 && rxa->num != num; j--) {\n\t\t\t\tif (--cnt)\n\t\t\t\t\trxa++;\n\t\t\t\telse {\n\t\t\t\t\tcnt = lst->count;\n\t\t\t\t\trxa = lst->items;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!cnt || rxa->num != num) {\n\t\t\trprintf(FERROR, \"[%s] could not find xattr #%d for %s\\n\",\n\t\t\t\twho_am_i(), num, f_name(file, NULL));\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\t\tif (!XATTR_ABBREV(*rxa) || rxa->datum[0] != XSTATE_ABBREV) {\n\t\t\trprintf(FERROR, \"[%s] internal abbrev error on %s (%s, len=%ld)!\\n\",\n\t\t\t\twho_am_i(), f_name(file, NULL), rxa->name, (long)rxa->datum_len);\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (am_sender) {\n\t\t\trxa->datum[0] = XSTATE_TODO;\n\t\t\tcontinue;\n\t\t}\n\n\t\told_datum = rxa->datum;\n\t\trxa->datum_len = read_varint(f_in);\n\n\t\tif (SIZE_MAX - rxa->name_len < rxa->datum_len)\n\t\t\toverflow_exit(\"recv_xattr_request\");\n\t\trxa->datum = new_array(char, rxa->datum_len + rxa->name_len);\n\t\tname = rxa->datum + rxa->datum_len;\n\t\tmemcpy(name, rxa->name, rxa->name_len);\n\t\trxa->name = name;\n\t\tfree(old_datum);\n\t\tread_buf(f_in, rxa->datum, rxa->datum_len);\n\t\tgot_xattr_data = 1;\n\t}\n\n\treturn got_xattr_data;\n}\n\n/* ------------------------------------------------------------------------- */\n\n/* receive and build the rsync_xattr_lists */\nvoid receive_xattr(int f, struct file_struct *file)\n{\n\tstatic item_list temp_xattr = EMPTY_ITEM_LIST;\n\tint count, num;\n#ifdef HAVE_LINUX_XATTRS\n\tint need_sort = 0;\n#else\n\tint need_sort = 1;\n#endif\n\tint ndx = read_varint(f);\n\n\tif (ndx < 0 || (size_t)ndx > rsync_xal_l.count) {\n\t\trprintf(FERROR, \"receive_xattr: xa index %d out of\"\n\t\t\t\" range for %s\\n\", ndx, f_name(file, NULL));\n\t\texit_cleanup(RERR_STREAMIO);\n\t}\n\n\tif (ndx != 0) {\n\t\tF_XATTR(file) = ndx - 1;\n\t\treturn;\n\t}\n\n\tif ((count = read_varint(f)) != 0) {\n\t\t(void)EXPAND_ITEM_LIST(&temp_xattr, rsync_xa, count);\n\t\ttemp_xattr.count = 0;\n\t}\n\n\tfor (num = 1; num <= count; num++) {\n\t\tchar *ptr, *name;\n\t\trsync_xa *rxa;\n\t\tsize_t name_len = read_varint(f);\n\t\tsize_t datum_len = read_varint(f);\n\t\tsize_t dget_len = datum_len > MAX_FULL_DATUM ? 1 + (size_t)xattr_sum_len : datum_len;\n\t\tsize_t extra_len = MIGHT_NEED_RPRE ? RPRE_LEN : 0;\n\t\tif (SIZE_MAX - dget_len < extra_len || SIZE_MAX - dget_len - extra_len < name_len)\n\t\t\toverflow_exit(\"receive_xattr\");\n\t\tptr = new_array(char, dget_len + extra_len + name_len);\n\t\tname = ptr + dget_len + extra_len;\n\t\tread_buf(f, name, name_len);\n\t\tif (name_len < 1 || name[name_len-1] != '\\0') {\n\t\t\trprintf(FERROR, \"Invalid xattr name received (missing trailing \\\\0).\\n\");\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\t\tif (dget_len == datum_len)\n\t\t\tread_buf(f, ptr, dget_len);\n\t\telse {\n\t\t\t*ptr = XSTATE_ABBREV;\n\t\t\tread_buf(f, ptr + 1, xattr_sum_len);\n\t\t}\n\n\t\tif (saw_xattr_filter) {\n\t\t\tif (name_is_excluded(name, NAME_IS_XATTR, ALL_FILTERS)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#ifdef HAVE_LINUX_XATTRS\n\t\t/* Non-root can only save the user namespace. */\n\t\tif (am_root <= 0 && !HAS_PREFIX(name, USER_PREFIX)) {\n\t\t\tif (!am_root && !saw_xattr_filter) {\n\t\t\t\tfree(ptr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tname -= RPRE_LEN;\n\t\t\tname_len += RPRE_LEN;\n\t\t\tmemcpy(name, RSYNC_PREFIX, RPRE_LEN);\n\t\t\tneed_sort = 1;\n\t\t}\n#else\n\t\t/* This OS only has a user namespace, so we either\n\t\t * strip the user prefix, or we put a non-user\n\t\t * namespace inside our rsync hierarchy. */\n\t\tif (HAS_PREFIX(name, USER_PREFIX)) {\n\t\t\tname += UPRE_LEN;\n\t\t\tname_len -= UPRE_LEN;\n\t\t} else if (am_root) {\n\t\t\tname -= RPRE_LEN;\n\t\t\tname_len += RPRE_LEN;\n\t\t\tmemcpy(name, RSYNC_PREFIX, RPRE_LEN);\n\t\t} else {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t/* No rsync.%FOO attributes are copied w/o 2 -X options. */\n\t\tif (preserve_xattrs < 2 && name_len > RPRE_LEN\n\t\t && name[RPRE_LEN] == '%' && HAS_PREFIX(name, RSYNC_PREFIX)) {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\trxa = EXPAND_ITEM_LIST(&temp_xattr, rsync_xa, 1);\n\t\trxa->name = name;\n\t\trxa->datum = ptr;\n\t\trxa->name_len = name_len;\n\t\trxa->datum_len = datum_len;\n\t\trxa->num = num;\n\t}\n\n\tif (need_sort && count > 1)\n\t\tqsort(temp_xattr.items, count, sizeof (rsync_xa), rsync_xal_compare_names);\n\n\tndx = rsync_xal_store(&temp_xattr); /* adds item to rsync_xal_l */\n\n\tF_XATTR(file) = ndx;\n}\n\n/* Turn the xattr data in stat_x into cached xattr data, setting the index\n * values in the file struct. */\nvoid cache_tmp_xattr(struct file_struct *file, stat_x *sxp)\n{\n\tint ndx;\n\n\tif (!sxp->xattr)\n\t\treturn;\n\n\tif (prior_xattr_count == (size_t)-1)\n\t\tprior_xattr_count = rsync_xal_l.count;\n\tndx = find_matching_xattr(sxp->xattr);\n\tif (ndx < 0)\n\t\trsync_xal_store(sxp->xattr); /* adds item to rsync_xal_l */\n\n\tF_XATTR(file) = ndx;\n}\n\nvoid uncache_tmp_xattrs(void)\n{\n\tif (prior_xattr_count != (size_t)-1) {\n\t\trsync_xa_list *xa_list_item = rsync_xal_l.items;\n\t\trsync_xa_list *xa_list_start = xa_list_item + prior_xattr_count;\n\t\txa_list_item += rsync_xal_l.count;\n\t\trsync_xal_l.count = prior_xattr_count;\n\t\twhile (xa_list_item-- > xa_list_start) {\n\t\t\tstruct ht_int64_node *node;\n\t\t\trsync_xa_list_ref *ref;\n\n\t\t\trsync_xal_free(&xa_list_item->xa_items);\n\n\t\t\tif (rsync_xal_h == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tnode = hashtable_find(rsync_xal_h, xa_list_item->key, NULL);\n\t\t\tif (node == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (node->data == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tref = node->data;\n\t\t\tif (xa_list_item->ndx == ref->ndx) {\n\t\t\t\t/* xa_list_item is the first in the list. */\n\t\t\t\tnode->data = ref->next;\n\t\t\t\tfree(ref);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (1) {\n\t\t\t\trsync_xa_list_ref *next = ref->next;\n\t\t\t\tif (next == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (xa_list_item->ndx == next->ndx) {\n\t\t\t\t\tref->next = next->next;\n\t\t\t\t\tfree(next);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tref = next;\n\t\t\t}\n\t\t}\n\t\tprior_xattr_count = (size_t)-1;\n\t}\n}\n\nstatic int rsync_xal_set(const char *fname, item_list *xalp,\n\t\t\t const char *fnamecmp, stat_x *sxp)\n{\n\trsync_xa *rxas = xalp->items;\n\tssize_t list_len;\n\tsize_t i, len;\n\tchar *name, *ptr, sum[MAX_XATTR_DIGEST_LEN];\n#ifdef HAVE_LINUX_XATTRS\n\tint user_only = am_root <= 0;\n#endif\n\tsize_t name_len;\n\tint ret = 0;\n\n\t/* This puts the current name list into the \"namebuf\" buffer. */\n\tif ((list_len = get_xattr_names(fname)) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < xalp->count; i++) {\n\t\tname = rxas[i].name;\n\n\t\tif (XATTR_ABBREV(rxas[i])) {\n\t\t\t/* See if the fnamecmp version is identical. */\n\t\t\tlen = name_len = rxas[i].name_len;\n\t\t\tif ((ptr = get_xattr_data(fnamecmp, name, &len, 1)) == NULL) {\n\t\t\t  still_abbrev:\n\t\t\t\tif (am_generator)\n\t\t\t\t\tcontinue;\n\t\t\t\trprintf(FERROR, \"Missing abbreviated xattr value, %s, for %s\\n\",\n\t\t\t\t\trxas[i].name, full_fname(fname));\n\t\t\t\tret = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len != rxas[i].datum_len) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto still_abbrev;\n\t\t\t}\n\n\t\t\tsum_init(xattr_sum_nni, checksum_seed);\n\t\t\tsum_update(ptr, len);\n\t\t\tsum_end(sum);\n\t\t\tif (memcmp(sum, rxas[i].datum + 1, xattr_sum_len) != 0) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto still_abbrev;\n\t\t\t}\n\n\t\t\tif (fname == fnamecmp)\n\t\t\t\t; /* Value is already set when identical */\n\t\t\telse if (sys_lsetxattr(fname, name, ptr, len) < 0) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"rsync_xal_set: lsetxattr(%s,\\\"%s\\\") failed\",\n\t\t\t\t\tfull_fname(fname), name);\n\t\t\t\tret = -1;\n\t\t\t} else /* make sure caller sets mtime */\n\t\t\t\tsxp->st.st_mtime = (time_t)-1;\n\n\t\t\tif (am_generator) { /* generator items stay abbreviated */\n\t\t\t\tfree(ptr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(ptr + len, name, name_len);\n\t\t\tfree(rxas[i].datum);\n\n\t\t\trxas[i].name = name = ptr + len;\n\t\t\trxas[i].datum = ptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sys_lsetxattr(fname, name, rxas[i].datum, rxas[i].datum_len) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\"rsync_xal_set: lsetxattr(%s,\\\"%s\\\") failed\",\n\t\t\t\tfull_fname(fname), name);\n\t\t\tret = -1;\n\t\t} else /* make sure caller sets mtime */\n\t\t\tsxp->st.st_mtime = (time_t)-1;\n\t}\n\n\t/* Remove any extraneous names. */\n\tfor (name = namebuf; list_len > 0; name += name_len) {\n\t\tname_len = strlen(name) + 1;\n\t\tlist_len -= name_len;\n\n\t\tif (saw_xattr_filter) {\n\t\t\tif (name_is_excluded(name, NAME_IS_XATTR, ALL_FILTERS))\n\t\t\t\tcontinue;\n\t\t}\n#ifdef HAVE_LINUX_XATTRS\n\t\t/* Choose between ignoring the system namespace or (non-root) ignoring any non-user namespace. */\n\t\telse if (user_only ? !HAS_PREFIX(name, USER_PREFIX) : HAS_PREFIX(name, SYSTEM_PREFIX))\n\t\t\tcontinue;\n#endif\n\t\tif (am_root < 0 && name_len > RPRE_LEN && name[RPRE_LEN] == '%' && strcmp(name, XSTAT_ATTR) == 0)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < xalp->count; i++) {\n\t\t\tif (strcmp(name, rxas[i].name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == xalp->count) {\n\t\t\tif (sys_lremovexattr(fname, name) < 0) {\n\t\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\t\"rsync_xal_set: lremovexattr(%s,\\\"%s\\\") failed\",\n\t\t\t\t\tfull_fname(fname), name);\n\t\t\t\tret = -1;\n\t\t\t} else /* make sure caller sets mtime */\n\t\t\t\tsxp->st.st_mtime = (time_t)-1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* Set extended attributes on indicated filename. */\nint set_xattr(const char *fname, const struct file_struct *file, const char *fnamecmp, stat_x *sxp)\n{\n\trsync_xa_list *glst = rsync_xal_l.items;\n\titem_list *lst;\n\tint ndx, added_write_perm = 0;\n\n\tif (dry_run)\n\t\treturn 1; /* FIXME: --dry-run needs to compute this value */\n\n\tif (read_only || list_only) {\n\t\terrno = EROFS;\n\t\treturn -1;\n\t}\n\n#ifdef NO_SPECIAL_XATTRS\n\tif (IS_SPECIAL(sxp->st.st_mode)) {\n\t\terrno = ENOTSUP;\n\t\treturn -1;\n\t}\n#endif\n#ifdef NO_DEVICE_XATTRS\n\tif (IS_DEVICE(sxp->st.st_mode)) {\n\t\terrno = ENOTSUP;\n\t\treturn -1;\n\t}\n#endif\n#ifdef NO_SYMLINK_XATTRS\n\tif (S_ISLNK(sxp->st.st_mode)) {\n\t\terrno = ENOTSUP;\n\t\treturn -1;\n\t}\n#endif\n\n\t/* If the target file lacks write permission, we try to add it\n\t * temporarily so we can change the extended attributes. */\n\tif (!am_root\n#ifdef SUPPORT_LINKS\n\t && !S_ISLNK(sxp->st.st_mode)\n#endif\n\t && access(fname, W_OK) < 0\n\t && do_chmod(fname, (sxp->st.st_mode & CHMOD_BITS) | S_IWUSR) == 0)\n\t\tadded_write_perm = 1;\n\n\tndx = F_XATTR(file);\n\tglst += ndx;\n\tlst = &glst->xa_items;\n\tint return_value = rsync_xal_set(fname, lst, fnamecmp, sxp);\n\tif (added_write_perm) /* remove the temporary write permission */\n\t\tdo_chmod(fname, sxp->st.st_mode);\n\treturn return_value;\n}\n\n#ifdef SUPPORT_ACLS\nchar *get_xattr_acl(const char *fname, int is_access_acl, size_t *len_p)\n{\n\tconst char *name = is_access_acl ? XACC_ACL_ATTR : XDEF_ACL_ATTR;\n\t*len_p = 0; /* no extra data alloc needed from get_xattr_data() */\n\treturn get_xattr_data(fname, name, len_p, 1);\n}\n\nint set_xattr_acl(const char *fname, int is_access_acl, const char *buf, size_t buf_len)\n{\n\tconst char *name = is_access_acl ? XACC_ACL_ATTR : XDEF_ACL_ATTR;\n\tif (sys_lsetxattr(fname, name, buf, buf_len) < 0) {\n\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\"set_xattr_acl: lsetxattr(%s,\\\"%s\\\") failed\",\n\t\t\tfull_fname(fname), name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint del_def_xattr_acl(const char *fname)\n{\n\treturn sys_lremovexattr(fname, XDEF_ACL_ATTR);\n}\n#endif\n\nint get_stat_xattr(const char *fname, int fd, STRUCT_STAT *fst, STRUCT_STAT *xst)\n{\n\tunsigned int mode;\n\tint rdev_major, rdev_minor, uid, gid, len;\n\tchar buf[256];\n\n\tif (am_root >= 0 || IS_DEVICE(fst->st_mode) || IS_SPECIAL(fst->st_mode))\n\t\treturn -1;\n\n\tif (xst)\n\t\t*xst = *fst;\n\telse\n\t\txst = fst;\n\tif (fname) {\n\t\tfd = -1;\n\t\tlen = sys_lgetxattr(fname, XSTAT_ATTR, buf, sizeof buf - 1);\n\t} else {\n\t\tfname = \"fd\";\n\t\tlen = sys_fgetxattr(fd, XSTAT_ATTR, buf, sizeof buf - 1);\n\t}\n\tif (len >= (int)sizeof buf) {\n\t\tlen = -1;\n\t\terrno = ERANGE;\n\t}\n\tif (len < 0) {\n\t\tif (errno == ENOTSUP || errno == ENOATTR)\n\t\t\treturn -1;\n\t\tif (errno == EPERM && S_ISLNK(fst->st_mode)) {\n\t\t\txst->st_uid = 0;\n\t\t\txst->st_gid = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trsyserr(FERROR_XFER, errno, \"failed to read xattr %s for %s\",\n\t\t\tXSTAT_ATTR, full_fname(fname));\n\t\treturn -1;\n\t}\n\tbuf[len] = '\\0';\n\n\tif (sscanf(buf, \"%o %d,%d %d:%d\",\n\t\t   &mode, &rdev_major, &rdev_minor, &uid, &gid) != 5) {\n\t\trprintf(FERROR, \"Corrupt %s xattr attached to %s: \\\"%s\\\"\\n\",\n\t\t\tXSTAT_ATTR, full_fname(fname), buf);\n\t\texit_cleanup(RERR_FILEIO);\n\t}\n\n\txst->st_mode = from_wire_mode(mode);\n\txst->st_rdev = MAKEDEV(rdev_major, rdev_minor);\n\txst->st_uid = uid;\n\txst->st_gid = gid;\n\n\treturn 0;\n}\n\nint set_stat_xattr(const char *fname, struct file_struct *file, mode_t new_mode)\n{\n\tSTRUCT_STAT fst, xst;\n\tdev_t rdev;\n\tmode_t mode, fmode;\n\n\tif (dry_run)\n\t\treturn 0;\n\n\tif (read_only || list_only) {\n\t\trsyserr(FERROR_XFER, EROFS, \"failed to write xattr %s for %s\",\n\t\t\tXSTAT_ATTR, full_fname(fname));\n\t\treturn -1;\n\t}\n\n\tif (x_lstat(fname, &fst, &xst) < 0) {\n\t\trsyserr(FERROR_XFER, errno, \"failed to re-stat %s\",\n\t\t\tfull_fname(fname));\n\t\treturn -1;\n\t}\n\n\tfst.st_mode &= (_S_IFMT | CHMOD_BITS);\n\tfmode = new_mode & (_S_IFMT | CHMOD_BITS);\n\n\tif (IS_DEVICE(fmode)) {\n\t\tuint32 *devp = F_RDEV_P(file);\n\t\trdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));\n\t} else\n\t\trdev = 0;\n\n\t/* Dump the special permissions and enable full owner access. */\n\tmode = (fst.st_mode & _S_IFMT) | (fmode & ACCESSPERMS)\n\t     | (S_ISDIR(fst.st_mode) ? 0700 : 0600);\n\tif (fst.st_mode != mode)\n\t\tdo_chmod(fname, mode);\n\tif (!IS_DEVICE(fst.st_mode))\n\t\tfst.st_rdev = 0; /* just in case */\n\n\tif (mode == fmode && fst.st_rdev == rdev\n\t && fst.st_uid == F_OWNER(file) && fst.st_gid == F_GROUP(file)) {\n\t\t/* xst.st_mode will be 0 if there's no current stat xattr */\n\t\tif (xst.st_mode && sys_lremovexattr(fname, XSTAT_ATTR) < 0) {\n\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\"delete of stat xattr failed for %s\",\n\t\t\t\tfull_fname(fname));\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (xst.st_mode != fmode || xst.st_rdev != rdev\n\t || xst.st_uid != F_OWNER(file) || xst.st_gid != F_GROUP(file)) {\n\t\tchar buf[256];\n\t\tint len = snprintf(buf, sizeof buf, \"%o %u,%u %u:%u\",\n\t\t\tto_wire_mode(fmode),\n\t\t\t(int)major(rdev), (int)minor(rdev),\n\t\t\tF_OWNER(file), F_GROUP(file));\n\t\tif (sys_lsetxattr(fname, XSTAT_ATTR, buf, len) < 0) {\n\t\t\tif (errno == EPERM && S_ISLNK(fst.st_mode))\n\t\t\t\treturn 0;\n\t\t\trsyserr(FERROR_XFER, errno,\n\t\t\t\t\"failed to write xattr %s for %s\",\n\t\t\t\tXSTAT_ATTR, full_fname(fname));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint x_stat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst)\n{\n\tint ret = do_stat(fname, fst);\n\tif ((ret < 0 || get_stat_xattr(fname, -1, fst, xst) < 0) && xst)\n\t\txst->st_mode = 0;\n\treturn ret;\n}\n\nint x_lstat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst)\n{\n\tint ret = do_lstat(fname, fst);\n\tif ((ret < 0 || get_stat_xattr(fname, -1, fst, xst) < 0) && xst)\n\t\txst->st_mode = 0;\n\treturn ret;\n}\n\nint x_fstat(int fd, STRUCT_STAT *fst, STRUCT_STAT *xst)\n{\n\tint ret = do_fstat(fd, fst);\n\tif ((ret < 0 || get_stat_xattr(NULL, fd, fst, xst) < 0) && xst)\n\t\txst->st_mode = 0;\n\treturn ret;\n}\n\n#endif /* SUPPORT_XATTRS */\n"
        },
        {
          "name": "zlib",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}